/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 154 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/cplat.h"
typedef int BOOL;
#line 22 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/cprofile.h"
struct PROFILE_s;
#line 22 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/cprofile.h"
typedef struct PROFILE_s PROFILE;
#line 36
struct prfentry_s;
#line 36 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/cprofile.h"
typedef struct prfentry_s prfentry;
#line 37
struct prfsection_s;
#line 37 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/cprofile.h"
typedef struct prfsection_s prfsection;
#line 39 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/cprofile.h"
struct prfentry_s {
   char *name ;
   char *value ;
   prfentry *next ;
};
#line 45 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/cprofile.h"
struct prfsection_s {
   char *name ;
   prfentry *entry ;
   prfsection *next ;
};
#line 59 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/cprofile.h"
struct PROFILE_s {
   char *name ;
   FILE *file ;
   BOOL changed ;
   prfsection *section ;
};
#line 40 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stdarg.h"
typedef __builtin_va_list __gnuc_va_list;
#line 79 "/usr/include/stdio.h"
typedef __gnuc_va_list va_list;
#line 25 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/cpdfscan.h"
struct PDFSCAN_s;
#line 25 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/cpdfscan.h"
typedef struct PDFSCAN_s PDFSCAN;
#line 28
struct PDFBBOX_s;
#line 28 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/cpdfscan.h"
typedef struct PDFBBOX_s PDFBBOX;
#line 29 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/cpdfscan.h"
struct PDFBBOX_s {
   float llx ;
   float lly ;
   float urx ;
   float ury ;
};
#line 60 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/cpdfscan.c"
struct PDFMEM_s;
#line 60 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/cpdfscan.c"
typedef struct PDFMEM_s PDFMEM;
#line 61 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/cpdfscan.c"
struct PDFMEM_s {
   void *ptr ;
   int len ;
   PDFMEM *next ;
};
#line 68
enum rtype_e {
    invalidtype = 0,
    marktype = 1,
    nulltype = 2,
    booltype = 3,
    integertype = 4,
    realtype = 5,
    nametype = 6,
    stringtype = 7,
    arraytype = 8,
    dicttype = 9,
    optype = 10,
    streamtype = 11,
    objtype = 12,
    commenttype = 13
} ;
#line 68 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/cpdfscan.c"
typedef enum rtype_e rtype;
#line 94
struct ref_s;
#line 94 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/cpdfscan.c"
typedef struct ref_s ref;
#line 95 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/cpdfscan.c"
union value_u {
   void *voidval ;
   BOOL boolval ;
   int intval ;
   float realval ;
   char *nameval ;
   char *strval ;
   ref *arrayval ;
   ref *dictval ;
   char *opval ;
   unsigned long streamval ;
   int objval ;
};
#line 95 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/cpdfscan.c"
struct ref_s {
   rtype type ;
   int rsize ;
   union value_u value ;
};
#line 117 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/cpdfscan.c"
struct PDFXREF_s {
   unsigned long offset ;
   int generation ;
   BOOL used ;
};
#line 117 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/cpdfscan.c"
typedef struct PDFXREF_s PDFXREF;
#line 123 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/cpdfscan.c"
struct PDFSCAN_s {
   void *handle ;
   int (*print_fn)(void *handle , char const   *ptr , int len ) ;
   char filename[1024] ;
   FILE *file ;
   char *buf ;
   int buflen ;
   int len ;
   int offset ;
   int begin ;
   int end ;
   rtype token_type ;
   BOOL instream ;
   unsigned long xref_offset ;
   PDFXREF *xref ;
   int xref_len ;
   int root ;
   int info ;
   int pages ;
   int page_count ;
   int pagenum ;
   int rotate ;
   PDFBBOX mediabox ;
   PDFBBOX cropbox ;
   PDFMEM *memory_head ;
   PDFMEM *memory_tail ;
   ref *ostack ;
   int ostack_idx ;
   int ostack_len ;
   int ostack_maxlen ;
   ref *objs ;
   int objs_count ;
   int objs_len ;
   int objs_maxlen ;
};
#line 170
enum PDFSEEK_e {
    PDFSEEK_CUR = 0,
    PDFSEEK_END = 1,
    PDFSEEK_SET = 2
} ;
#line 170 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/cpdfscan.c"
typedef enum PDFSEEK_e PDFSEEK;
#line 51 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/cfile.h"
struct GFile_s;
#line 51 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/cfile.h"
typedef struct GFile_s GFile;
#line 49 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/common.h"
struct CDSC_s;
#line 49 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/common.h"
typedef struct CDSC_s CDSC;
#line 54
struct Doc_s;
#line 54 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/common.h"
typedef struct Doc_s Doc;
#line 84
struct GSview_s;
#line 84 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/common.h"
typedef struct GSview_s GSview;
#line 119
struct View_s;
#line 119 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/common.h"
typedef struct View_s View;
#line 189 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/common.h"
struct PAGELIST_s {
   int current ;
   BOOL multiple ;
   int page_count ;
   BOOL *select ;
   BOOL reverse ;
};
#line 189 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/common.h"
typedef struct PAGELIST_s PAGELIST;
#line 25 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/dscparse.h"
typedef int GSBOOL;
#line 26 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/dscparse.h"
typedef unsigned long GSDWORD;
#line 27 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/dscparse.h"
typedef unsigned int GSWORD;
#line 216 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/dscparse.h"
struct CDSCBBOX_S {
   int llx ;
   int lly ;
   int urx ;
   int ury ;
};
#line 216 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/dscparse.h"
typedef struct CDSCBBOX_S CDSCBBOX;
#line 223 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/dscparse.h"
struct CDSCFBBOX_S {
   float fllx ;
   float flly ;
   float furx ;
   float fury ;
};
#line 223 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/dscparse.h"
typedef struct CDSCFBBOX_S CDSCFBBOX;
#line 230 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/dscparse.h"
struct CDSCMEDIA_S {
   char const   *name ;
   float width ;
   float height ;
   float weight ;
   char const   *colour ;
   char const   *type ;
   CDSCBBOX *mediabox ;
};
#line 230 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/dscparse.h"
typedef struct CDSCMEDIA_S CDSCMEDIA;
#line 243 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/dscparse.h"
struct CDSCCTM_S {
   float xx ;
   float xy ;
   float yx ;
   float yy ;
};
#line 243 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/dscparse.h"
typedef struct CDSCCTM_S CDSCCTM;
#line 252 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/dscparse.h"
struct CDSCPAGE_S {
   int ordinal ;
   char const   *label ;
   unsigned long begin ;
   unsigned long end ;
   unsigned int orientation ;
   CDSCMEDIA const   *media ;
   CDSCBBOX *bbox ;
   CDSCCTM *viewing_orientation ;
   CDSCFBBOX *crop_box ;
};
#line 252 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/dscparse.h"
typedef struct CDSCPAGE_S CDSCPAGE;
#line 266 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/dscparse.h"
struct CDSCDOSEPS_S {
   GSDWORD ps_begin ;
   GSDWORD ps_length ;
   GSDWORD wmf_begin ;
   GSDWORD wmf_length ;
   GSDWORD tiff_begin ;
   GSDWORD tiff_length ;
   GSWORD checksum ;
};
#line 266 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/dscparse.h"
typedef struct CDSCDOSEPS_S CDSCDOSEPS;
#line 277 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/dscparse.h"
struct CDSCMACBIN_S {
   GSDWORD data_begin ;
   GSDWORD data_length ;
   GSDWORD resource_begin ;
   GSDWORD resource_length ;
};
#line 277 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/dscparse.h"
typedef struct CDSCMACBIN_S CDSCMACBIN;
#line 288
struct CDSCSTRING_S;
#line 288 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/dscparse.h"
typedef struct CDSCSTRING_S CDSCSTRING;
#line 289 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/dscparse.h"
struct CDSCSTRING_S {
   unsigned int index ;
   unsigned int length ;
   char *data ;
   CDSCSTRING *next ;
};
#line 297
struct CDCS2_S;
#line 297 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/dscparse.h"
typedef struct CDCS2_S CDCS2;
#line 298 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/dscparse.h"
struct CDCS2_S {
   char *colourname ;
   char *filetype ;
   char *location ;
   char *filename ;
   unsigned long begin ;
   unsigned long end ;
   CDCS2 *next ;
};
#line 311
enum CDSC_COLOUR_TYPE_e {
    CDSC_COLOUR_UNKNOWN = 0,
    CDSC_COLOUR_PROCESS = 1,
    CDSC_COLOUR_CUSTOM = 2
} ;
#line 311 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/dscparse.h"
typedef enum CDSC_COLOUR_TYPE_e CDSC_COLOUR_TYPE;
#line 317
enum CDSC_CUSTOM_COLOUR_e {
    CDSC_CUSTOM_COLOUR_UNKNOWN = 0,
    CDSC_CUSTOM_COLOUR_RGB = 1,
    CDSC_CUSTOM_COLOUR_CMYK = 2
} ;
#line 317 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/dscparse.h"
typedef enum CDSC_CUSTOM_COLOUR_e CDSC_CUSTOM_COLOUR;
#line 323
struct CDSCCOLOUR_S;
#line 323 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/dscparse.h"
typedef struct CDSCCOLOUR_S CDSCCOLOUR;
#line 324 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/dscparse.h"
struct CDSCCOLOUR_S {
   char *name ;
   CDSC_COLOUR_TYPE type ;
   CDSC_CUSTOM_COLOUR custom ;
   float red ;
   float green ;
   float blue ;
   float cyan ;
   float magenta ;
   float yellow ;
   float black ;
   CDSCCOLOUR *next ;
};
#line 363
enum CDSC_MESSAGE_SEVERITY_e {
    CDSC_ERROR_NONE = -1,
    CDSC_ERROR_INFORM = 0,
    CDSC_ERROR_WARN = 1,
    CDSC_ERROR_ERROR = 2
} ;
#line 363 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/dscparse.h"
typedef enum CDSC_MESSAGE_SEVERITY_e CDSC_MESSAGE_SEVERITY;
#line 384 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/dscparse.h"
struct CDSC_s {
   char dummy[1024] ;
   GSBOOL dsc ;
   GSBOOL ctrld ;
   GSBOOL pjl ;
   GSBOOL epsf ;
   GSBOOL pdf ;
   unsigned int preview ;
   char *dsc_version ;
   unsigned int language_level ;
   unsigned int document_data ;
   unsigned long begincomments ;
   unsigned long endcomments ;
   unsigned long beginpreview ;
   unsigned long endpreview ;
   unsigned long begindefaults ;
   unsigned long enddefaults ;
   unsigned long beginprolog ;
   unsigned long endprolog ;
   unsigned long beginsetup ;
   unsigned long endsetup ;
   unsigned long begintrailer ;
   unsigned long endtrailer ;
   CDSCPAGE *page ;
   unsigned int page_count ;
   unsigned int page_pages ;
   unsigned int page_order ;
   unsigned int page_orientation ;
   CDSCCTM *viewing_orientation ;
   unsigned int media_count ;
   CDSCMEDIA **media ;
   CDSCMEDIA const   *page_media ;
   CDSCBBOX *bbox ;
   CDSCBBOX *page_bbox ;
   CDSCDOSEPS *doseps ;
   char *dsc_title ;
   char *dsc_creator ;
   char *dsc_date ;
   char *dsc_for ;
   unsigned int max_error ;
   int const   *severity ;
   void *caller_data ;
   int id ;
   int scan_section ;
   unsigned long doseps_end ;
   unsigned int page_chunk_length ;
   unsigned long file_length ;
   int skip_document ;
   int skip_bytes ;
   int skip_lines ;
   GSBOOL skip_pjl ;
   int begin_font_count ;
   int begin_feature_count ;
   int begin_resource_count ;
   int begin_procset_count ;
   char data[8192] ;
   unsigned int data_length ;
   unsigned int data_index ;
   unsigned long data_offset ;
   GSBOOL eof ;
   char *line ;
   unsigned int line_length ;
   GSBOOL eol ;
   GSBOOL last_cr ;
   unsigned int line_count ;
   GSBOOL long_line ;
   char last_line[256] ;
   CDSCSTRING *string_head ;
   CDSCSTRING *string ;
   void *(*memalloc)(size_t size , void *closure_data ) ;
   void (*memfree)(void *ptr , void *closure_data ) ;
   void *mem_closure_data ;
   void (*debug_print_fn)(void *caller_data , char const   *str ) ;
   int (*dsc_error_fn)(void *caller_data , CDSC *dsc , unsigned int explanation ,
                       char const   *line , unsigned int line_len ) ;
   CDSCFBBOX *hires_bbox ;
   CDSCFBBOX *crop_box ;
   CDCS2 *dcs2 ;
   CDSCCOLOUR *colours ;
   int ref_count ;
   CDSCMACBIN *macbin ;
   GSBOOL dcs1 ;
   CDSC_MESSAGE_SEVERITY worst_error ;
};
#line 40 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/cdoc.h"
enum DocType_e {
    DOC_UNKNOWN = 0,
    DOC_PS = 1,
    DOC_PDF = 2,
    DOC_PCL = 3,
    DOC_BITMAP = 4
} ;
#line 40 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/cdoc.h"
typedef enum DocType_e DocType;
#line 88 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/cdoc.h"
struct Doc_s {
   void *handle ;
   GSview *app ;
   Doc *next ;
   int refcount ;
   View *viewlist ;
   char text_name[256] ;
   char name[256] ;
   char tname[256] ;
   DocType doctype ;
   BOOL gzip ;
   BOOL bzip2 ;
   int page_count ;
   unsigned long length1 ;
   unsigned long length2 ;
   unsigned long time1 ;
   unsigned long time2 ;
   unsigned int dpi ;
   CDSC *dsc ;
   BOOL ignore_dsc ;
   int dsc_warn ;
   BOOL verbose ;
   BOOL ctrld ;
   BOOL pjl ;
   PDFSCAN *pdfscan ;
};
#line 133 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/common.h"
enum __anonenum_CODEPAGE_44 {
    CODEPAGE_SBCS = 0,
    CODEPAGE_UTF8 = 1,
    CODEPAGE_EUC = 2,
    CODEPAGE_SJIS = 3
} ;
#line 133 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/common.h"
typedef enum __anonenum_CODEPAGE_44 CODEPAGE;
#line 124 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __dev_t;
#line 125 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uid_t;
#line 126 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __gid_t;
#line 127 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __ino_t;
#line 129 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __mode_t;
#line 130 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __nlink_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 153 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blksize_t;
#line 158 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blkcnt_t;
#line 175 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __syscall_slong_t;
#line 75 "/usr/include/time.h"
typedef __time_t time_t;
#line 120 "/usr/include/time.h"
struct timespec {
   __time_t tv_sec ;
   __syscall_slong_t tv_nsec ;
};
#line 46 "/usr/include/x86_64-linux-gnu/bits/stat.h"
struct stat {
   __dev_t st_dev ;
   __ino_t st_ino ;
   __nlink_t st_nlink ;
   __mode_t st_mode ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   int __pad0 ;
   __dev_t st_rdev ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   __syscall_slong_t __glibc_reserved[3] ;
};
#line 36 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/cfile.c"
struct GFile_s {
   FILE *m_file ;
   time_t m_filetime ;
   unsigned long m_length ;
};
#line 114 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/cplat.h"
struct _GdkRgbCmap;
#line 114 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/cplat.h"
typedef struct _GdkRgbCmap GdkRgbCmap;
#line 155 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/cplat.h"
typedef unsigned char BYTE;
#line 156 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/cplat.h"
typedef unsigned short WORD;
#line 94 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/common.h"
struct IMAGE_s;
#line 94 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/common.h"
typedef struct IMAGE_s IMAGE;
#line 22 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/cimg.h"
struct IMAGE_s {
   unsigned int width ;
   unsigned int height ;
   unsigned int raster ;
   unsigned int format ;
   unsigned char *image ;
   GdkRgbCmap *cmap ;
};
#line 20 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/clzw.h"
struct lzw_state_s;
#line 20 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/clzw.h"
typedef struct lzw_state_s lzw_state_t;
#line 1198 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/cimg.c"
struct scale_pixels_s {
   unsigned int end ;
   unsigned int frac ;
};
#line 1198 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/cimg.c"
typedef struct scale_pixels_s scale_pixels_t;
#line 133 "/usr/include/time.h"
struct tm {
   int tm_sec ;
   int tm_min ;
   int tm_hour ;
   int tm_mday ;
   int tm_mon ;
   int tm_year ;
   int tm_wday ;
   int tm_yday ;
   int tm_isdst ;
   long tm_gmtoff ;
   char const   *tm_zone ;
};
#line 157 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/cplat.h"
typedef unsigned long DWORD;
#line 158 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/cplat.h"
typedef long LONG;
#line 19 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/cbmp.h"
struct tagBITMAP2 {
   DWORD biSize ;
   LONG biWidth ;
   LONG biHeight ;
   WORD biPlanes ;
   WORD biBitCount ;
   DWORD biCompression ;
   DWORD biSizeImage ;
   LONG biXPelsPerMeter ;
   LONG biYPelsPerMeter ;
   DWORD biClrUsed ;
   DWORD biClrImportant ;
};
#line 19 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/cbmp.h"
typedef struct tagBITMAP2 BITMAP2;
#line 36 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/cbmp.h"
struct tagBITMAPFILE {
   WORD bfType ;
   DWORD bfSize ;
   WORD bfReserved1 ;
   WORD bfReserved2 ;
   DWORD bfOffBits ;
};
#line 36 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/cbmp.h"
typedef struct tagBITMAPFILE BITMAPFILE;
#line 47 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/cbmp.h"
struct tagRGB4 {
   BYTE rgbBlue ;
   BYTE rgbGreen ;
   BYTE rgbRed ;
   BYTE rgbReserved ;
};
#line 47 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/cbmp.h"
typedef struct tagRGB4 RGB4;
#line 62
enum PNM_FORMAT_s {
    PBMRAW = 4,
    PGMRAW = 5,
    PPMRAW = 6,
    PNMANY = 99
} ;
#line 62 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/cbmp.h"
typedef enum PNM_FORMAT_s PNM_FORMAT;
#line 33 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/cbmp.h"
typedef BITMAP2 *LPBITMAP2;
#line 19 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/cmac.h"
enum CMAC_TYPE_e {
    CMAC_TYPE_NONE = 0,
    CMAC_TYPE_SINGLE = 1,
    CMAC_TYPE_DOUBLE = 2,
    CMAC_TYPE_MACBIN = 3,
    CMAC_TYPE_RSRC = 4
} ;
#line 19 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/cmac.h"
typedef enum CMAC_TYPE_e CMAC_TYPE;
#line 28 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/cmac.h"
struct CMACFILE_s {
   CMAC_TYPE type ;
   unsigned char file_type[4] ;
   unsigned char file_creator[4] ;
   DWORD finder_begin ;
   DWORD finder_length ;
   DWORD data_begin ;
   DWORD data_length ;
   DWORD resource_begin ;
   DWORD resource_length ;
   DWORD pict_begin ;
   DWORD pict_length ;
};
#line 28 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/cmac.h"
typedef struct CMACFILE_s CMACFILE;
#line 42 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/ceps.h"
struct RENAME_SEPARATION_s;
#line 42 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/ceps.h"
typedef struct RENAME_SEPARATION_s RENAME_SEPARATION;
#line 43 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/ceps.h"
struct RENAME_SEPARATION_s {
   char *oldname ;
   char *newname ;
   RENAME_SEPARATION *next ;
};
#line 63 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/ceps.c"
struct WINRECT_s {
   WORD left ;
   WORD top ;
   WORD right ;
   WORD bottom ;
};
#line 63 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/ceps.c"
typedef struct WINRECT_s WINRECT;
#line 70 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/ceps.c"
struct METAFILEHEADER_s {
   DWORD key ;
   WORD hmf ;
   WINRECT bbox ;
   WORD inch ;
   DWORD reserved ;
   WORD checksum ;
};
#line 70 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/ceps.c"
typedef struct METAFILEHEADER_s METAFILEHEADER;
#line 726
enum PREVIEW_TYPE_e {
    PREVIEW_UNKNOWN = 0,
    PREVIEW_TIFF = 1,
    PREVIEW_WMF = 2
} ;
#line 726 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/ceps.c"
typedef enum PREVIEW_TYPE_e PREVIEW_TYPE;
#line 908 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/ceps.c"
struct tagMFH {
   WORD type ;
   WORD headersize ;
   WORD version ;
   DWORD size ;
   WORD nobj ;
   DWORD maxrec ;
   WORD noparam ;
};
#line 908 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/ceps.c"
typedef struct tagMFH MFH;
#line 133 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __pid_t;
#line 66 "/usr/include/x86_64-linux-gnu/bits/waitstatus.h"
struct __anonstruct___wait_terminated_7 {
   unsigned int __w_termsig : 7 ;
   unsigned int __w_coredump : 1 ;
   unsigned int __w_retcode : 8 ;
   unsigned int  : 16 ;
};
#line 66 "/usr/include/x86_64-linux-gnu/bits/waitstatus.h"
struct __anonstruct___wait_stopped_8 {
   unsigned int __w_stopval : 8 ;
   unsigned int __w_stopsig : 8 ;
   unsigned int  : 16 ;
};
#line 66 "/usr/include/x86_64-linux-gnu/bits/waitstatus.h"
union wait {
   int w_status ;
   struct __anonstruct___wait_terminated_7 __wait_terminated ;
   struct __anonstruct___wait_stopped_8 __wait_stopped ;
};
#line 98 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __pid_t pid_t;
#line 75 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
struct __pthread_internal_list {
   struct __pthread_internal_list *__prev ;
   struct __pthread_internal_list *__next ;
};
#line 75 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef struct __pthread_internal_list __pthread_list_t;
#line 90 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
struct __pthread_mutex_s {
   int __lock ;
   unsigned int __count ;
   int __owner ;
   unsigned int __nusers ;
   int __kind ;
   short __spins ;
   short __elision ;
   __pthread_list_t __list ;
};
#line 90 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
union __anonunion_pthread_mutex_t_15 {
   struct __pthread_mutex_s __data ;
   char __size[40] ;
   long __align ;
};
#line 90 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef union __anonunion_pthread_mutex_t_15 pthread_mutex_t;
#line 159 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/cplat.h"
struct POINT_s {
   int x ;
   int y ;
};
#line 159 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/cplat.h"
typedef struct POINT_s POINT;
#line 59 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/common.h"
struct GSDLL_s;
#line 59 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/common.h"
typedef struct GSDLL_s GSDLL;
#line 64
struct PLDLL_s;
#line 64 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/common.h"
typedef struct PLDLL_s PLDLL;
#line 74
struct GSREQ_s;
#line 74 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/common.h"
typedef struct GSREQ_s GSREQ;
#line 79
struct GSSRV_s;
#line 79 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/common.h"
typedef struct GSSRV_s GSSRV;
#line 99
struct MEDIA_s;
#line 99 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/common.h"
typedef struct MEDIA_s MEDIA;
#line 104
struct OPTION_s;
#line 104 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/common.h"
typedef struct OPTION_s OPTION;
#line 109
struct PAGECACHE_s;
#line 109 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/common.h"
typedef struct PAGECACHE_s PAGECACHE;
#line 204
enum ORIENT_e {
    ORIENT_DEFAULT = -1,
    ORIENT_PORTRAIT = 0,
    ORIENT_LANDSCAPE = 3,
    ORIENT_UPSIDEDOWN = 2,
    ORIENT_SEASCAPE = 1
} ;
#line 204 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/common.h"
typedef enum ORIENT_e ORIENT;
#line 214
enum DISPLAY_FORMAT_e {
    DISPLAY_FORMAT_AUTO = 0,
    DISPLAY_FORMAT_GREY_1 = 1,
    DISPLAY_FORMAT_GREY_8 = 2,
    DISPLAY_FORMAT_COLOUR_4 = 3,
    DISPLAY_FORMAT_COLOUR_8 = 4,
    DISPLAY_FORMAT_COLOUR_24 = 5,
    DISPLAY_FORMAT_CMYK_32 = 6,
    DISPLAY_FORMAT_COUNT = 7
} ;
#line 214 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/common.h"
typedef enum DISPLAY_FORMAT_e DISPLAY_FORMAT;
#line 229
struct PAGESPEC_s;
#line 229 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/common.h"
typedef struct PAGESPEC_s PAGESPEC;
#line 231
enum PAGESIZE_METHOD_e {
    PAGESIZE_GIVEN = 0,
    PAGESIZE_CROPBOX = 1,
    PAGESIZE_MEDIABOX = 2,
    PAGESIZE_VARIABLE = 3
} ;
#line 231 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/common.h"
typedef enum PAGESIZE_METHOD_e PAGESIZE_METHOD;
#line 239 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/common.h"
struct PAGESPEC_s {
   char filename[256] ;
   int page ;
   PAGESIZE_METHOD pagesize ;
   float llx ;
   float lly ;
   float urx ;
   float ury ;
   float xddpi ;
   float yddpi ;
   float xrdpi ;
   float yrdpi ;
   ORIENT orient_request ;
   ORIENT orient ;
   unsigned int format ;
   int alpha_text ;
   int alpha_graphics ;
};
#line 39 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/copt.h"
enum UNIT_e {
    UNIT_PT = 0,
    UNIT_MM = 1,
    UNIT_IN = 2
} ;
#line 39 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/copt.h"
typedef enum UNIT_e UNIT;
#line 45
enum SAFER_e {
    SAFER_UNSAFE = 0,
    SAFER_SAFE = 1,
    SAFER_PARANOID = 2
} ;
#line 45 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/copt.h"
typedef enum SAFER_e SAFER;
#line 51 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/copt.h"
struct MEDIA_s {
   char name[256] ;
   float width ;
   float height ;
   ORIENT orientation ;
   BOOL swap_landscape ;
   BOOL rotate ;
   float xdpi ;
   float ydpi ;
   DISPLAY_FORMAT depth ;
   int alpha_text ;
   int alpha_graphics ;
};
#line 69
struct USERMEDIA_s;
#line 69 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/copt.h"
typedef struct USERMEDIA_s USERMEDIA;
#line 70 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/copt.h"
struct USERMEDIA_s {
   char name[256] ;
   float width ;
   float height ;
};
#line 77 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/copt.h"
struct OPTION_s {
   int language ;
   int gsversion ;
   BOOL savesettings ;
   POINT img_origin ;
   POINT img_size ;
   char gsdll[256] ;
   char gsinclude[256] ;
   char gsother[256] ;
   char pldll[256] ;
   SAFER safer ;
   UNIT unit ;
   BOOL unitfine ;
   float custom_width ;
   float custom_height ;
   USERMEDIA usermedia[16] ;
   BOOL variable_pagesize ;
   MEDIA media ;
   int dsc_warn ;
   BOOL ignore_dsc ;
   BOOL epsf_clip ;
   BOOL pdf_crop ;
   float zoom_xdpi ;
   float zoom_ydpi ;
   float pcl_dpi ;
   BOOL epsf_warn ;
   char pdf_password[256] ;
};
#line 50 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/capp.h"
typedef void *gzFile;
#line 65 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/capp.h"
typedef void *bzFile;
#line 99
struct STRING_s;
#line 99 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/capp.h"
typedef struct STRING_s STRING;
#line 101
struct ZLIB_s;
#line 101 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/capp.h"
typedef struct ZLIB_s ZLIB;
#line 102 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/capp.h"
struct ZLIB_s {
   BOOL loaded ;
   void *hmodule ;
   gzFile (*gzopen)(char const   *path , char const   *mode ) ;
   int (*gzread)(gzFile file , void *buf , unsigned int len ) ;
   int (*gzclose)(gzFile file ) ;
};
#line 110
struct BZIP2_s;
#line 110 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/capp.h"
typedef struct BZIP2_s BZIP2;
#line 111 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/capp.h"
struct BZIP2_s {
   BOOL loaded ;
   void *hmodule ;
   bzFile (*bzopen)(char const   *path , char const   *mode ) ;
   int (*bzread)(bzFile file , void *buf , unsigned int len ) ;
   int (*bzclose)(bzFile file ) ;
};
#line 119 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/capp.h"
struct GSview_s {
   void *handle ;
   int refcount ;
   char last_files[4][256] ;
   int last_files_count ;
   Doc *doclist ;
   GSDLL *gsdll ;
   PLDLL *pldll ;
   GSSRV *gssrv ;
   GSSRV *plsrv ;
   PAGECACHE *pagecache ;
   OPTION option ;
   char option_name[256] ;
   ZLIB zlib ;
   BZIP2 bzip2 ;
   BOOL quitnow ;
   BOOL in_main ;
   BOOL go_main ;
   BOOL multithread ;
   pthread_mutex_t hmutex ;
   int lock_count ;
   char twbuf[61440] ;
   int twend ;
   STRING *strings ;
};
#line 38 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/cgssrv.h"
enum GSREQ_ACTION_e {
    GSREQ_ACTION_DISPLAY = 0,
    GSREQ_ACTION_CONVERT = 1,
    GSREQ_ACTION_ABORT = 2,
    GSREQ_ACTION_UNLOAD = 3,
    GSREQ_ACTION_CLOSE_THREAD = 4
} ;
#line 38 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/cgssrv.h"
typedef enum GSREQ_ACTION_e GSREQ_ACTION;
#line 54
enum CONVERT_OUTPUT_e {
    CONVERT_FILE = 0,
    CONVERT_PIPE = 1,
    CONVERT_HANDLE = 2
} ;
#line 54 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/cgssrv.h"
typedef enum CONVERT_OUTPUT_e CONVERT_OUTPUT;
#line 60
struct GSREQ_CONVERT_s;
#line 60 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/cgssrv.h"
typedef struct GSREQ_CONVERT_s GSREQ_CONVERT;
#line 62 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/cgssrv.h"
struct GSREQ_CONVERT_s {
   CONVERT_OUTPUT method ;
   char output[256] ;
   char gsdevice[256] ;
   PAGELIST pagelist ;
};
#line 71 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/cgssrv.h"
struct GSREQ_s {
   GSREQ *next ;
   GSREQ_ACTION action ;
   PAGESPEC pagespec ;
   GSREQ_CONVERT convert ;
   CDSC *dsc ;
   BOOL pdf ;
   BOOL dcs2multi ;
   BOOL temp_ps ;
   View *view ;
};
#line 103 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/epstool.c"
enum __anonenum_CMD_70 {
    CMD_UNKNOWN = 0,
    CMD_TIFF4 = 1,
    CMD_TIFF6U = 2,
    CMD_TIFF6P = 3,
    CMD_TIFF = 4,
    CMD_INTERCHANGE = 5,
    CMD_WMF = 6,
    CMD_PICT = 7,
    CMD_USER = 8,
    CMD_DCS2_MULTI = 9,
    CMD_DCS2_SINGLE = 10,
    CMD_DCS2_REPORT = 11,
    CMD_PREVIEW = 12,
    CMD_POSTSCRIPT = 13,
    CMD_BITMAP = 14,
    CMD_COPY = 15,
    CMD_DUMP = 16,
    CMD_HELP = 17,
    CMD_TEST = 18,
    CMD_VERSION = 19
} ;
#line 103 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/epstool.c"
typedef enum __anonenum_CMD_70 CMD;
#line 126
enum __anonenum_CUSTOM_COLOUR_TYPE_71 {
    CUSTOM_CMYK = 0,
    CUSTOM_RGB = 1
} ;
#line 126 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/epstool.c"
typedef enum __anonenum_CUSTOM_COLOUR_TYPE_71 CUSTOM_COLOUR_TYPE;
#line 130
struct CUSTOM_COLOUR_s;
#line 130 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/epstool.c"
typedef struct CUSTOM_COLOUR_s CUSTOM_COLOUR;
#line 131 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/epstool.c"
struct CUSTOM_COLOUR_s {
   char name[256] ;
   CUSTOM_COLOUR_TYPE type ;
   float cyan ;
   float magenta ;
   float yellow ;
   float black ;
   float red ;
   float green ;
   float blue ;
   CUSTOM_COLOUR *next ;
};
#line 146 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/epstool.c"
struct OPT_s {
   CMD cmd ;
   char device[64] ;
   BOOL composite ;
   BOOL bbox ;
   int dscwarn ;
   char gs[256] ;
   char gsargs[1024] ;
   char input[256] ;
   char output[256] ;
   char user_preview[256] ;
   BOOL quiet ;
   BOOL debug ;
   BOOL doseps_reverse ;
   float dpi ;
   float dpi_render ;
   BOOL help ;
   char custom_colours[256] ;
   CUSTOM_COLOUR *colours ;
   BOOL missing_separations ;
   char combine[256] ;
   int tolerance ;
   RENAME_SEPARATION *rename_sep ;
   CMAC_TYPE mac_type ;
   int page ;
   int image_compress ;
   int image_encode ;
};
#line 146 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/epstool.c"
typedef struct OPT_s OPT;
#line 21 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/cargs.h"
struct GSVIEW_ARGS_s;
#line 21 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/cargs.h"
typedef struct GSVIEW_ARGS_s GSVIEW_ARGS;
#line 24 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/cargs.h"
struct GSVIEW_ARGS_s {
   int debug ;
   int multithread ;
   int help ;
   int version ;
   char filename[256] ;
   char queue[256] ;
   char device[64] ;
   int print ;
   int convert ;
   int spool ;
   char media[64] ;
   int orient ;
   float xdpi ;
   float ydpi ;
   int geometry ;
   int geometry_width ;
   int geometry_height ;
   int geometry_xoffset ;
   int geometry_yoffset ;
};
#line 23 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/cdll.h"
typedef void *(*dll_proc)(void);
#line 204 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/cmac.c"
struct CMAC_RESOURCE_HEADER_s {
   DWORD data_begin ;
   DWORD map_begin ;
   DWORD data_length ;
   DWORD map_length ;
};
#line 204 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/cmac.c"
typedef struct CMAC_RESOURCE_HEADER_s CMAC_RESOURCE_HEADER;
#line 211 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/cmac.c"
struct CMAC_RESOURCE_MAP_s {
   unsigned char reshdr[16] ;
   DWORD reshdl ;
   WORD filerefno ;
   WORD attributes ;
   WORD offset_type_list ;
   WORD offset_name_list ;
   WORD type_count ;
};
#line 211 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/cmac.c"
typedef struct CMAC_RESOURCE_MAP_s CMAC_RESOURCE_MAP;
#line 221 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/cmac.c"
struct CMAC_RESOURCE_TYPE_LIST_s {
   unsigned char type[4] ;
   WORD count ;
   WORD offset_ref_list ;
};
#line 221 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/cmac.c"
typedef struct CMAC_RESOURCE_TYPE_LIST_s CMAC_RESOURCE_TYPE_LIST;
#line 227 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/cmac.c"
struct CMAC_RESOURCE_REF_LIST_s {
   WORD id ;
   WORD offset_name ;
   unsigned char attributes ;
   DWORD offset_data ;
   DWORD handle ;
};
#line 227 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/cmac.c"
typedef struct CMAC_RESOURCE_REF_LIST_s CMAC_RESOURCE_REF_LIST;
#line 38 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/clzw.c"
struct lzw_code_s {
   short code ;
   short base_code ;
   unsigned char ch ;
};
#line 38 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/clzw.c"
typedef struct lzw_code_s lzw_code_t;
#line 44 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/clzw.c"
struct lzw_state_s {
   short next_code ;
   short lzwstr ;
   lzw_code_t table[5021] ;
   int code_bit_length ;
   short code_change ;
   int output_bits ;
   int output_bits_count ;
   int bytes_in ;
   int bytes_out ;
};
#line 26 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/cdoc.h"
struct DocInfo_s;
#line 26 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/cdoc.h"
typedef struct DocInfo_s DocInfo;
#line 27 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/cdoc.h"
struct DocInfo_s {
   char name[256] ;
   char type[256] ;
   char title[256] ;
   char date[256] ;
   char bbox[256] ;
   char hiresbbox[256] ;
   char orientation[256] ;
   char pageorder[256] ;
   char pagemedia[256] ;
   char pages[256] ;
};
#line 26 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/cdoc.c"
enum PclType_e {
    PCLTYPE_UNKNOWN = 0,
    PCLTYPE_PCL = 1,
    PCLTYPE_PXL = 2,
    PCLTYPE_POSTSCRIPT = 3
} ;
#line 26 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/cdoc.c"
typedef enum PclType_e PclType;
#line 237 "/usr/include/stdio.h"
extern int fclose(FILE *__stream ) ;
#line 272
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 622
extern char *fgets(char * __restrict  __s , int __n , FILE * __restrict  __stream ) ;
#line 466 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 132 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strncpy)(char * __restrict  __dest ,
                                                                                                  char const   * __restrict  __src ,
                                                                                                  size_t __n ) ;
#line 144
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 236
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strchr)(char const   *__s ,
                                                                                               int __c )  __attribute__((__pure__)) ;
#line 348
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(2), __leaf__)) strtok)(char * __restrict  __s ,
                                                                                               char const   * __restrict  __delim ) ;
#line 399
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 25 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/cprofile.h"
PROFILE *profile_open(char const   *filename ) ;
#line 26
int profile_read_string(PROFILE *prf , char const   *section , char const   *entry ,
                        char const   *def , char *buffer , int len ) ;
#line 28
BOOL profile_write_string(PROFILE *prf , char const   *section , char const   *entry ,
                          char const   *value ) ;
#line 30
BOOL profile_close(PROFILE *prf ) ;
#line 46 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/cprofile.c"
static void profile_free_section(prfsection *section ) 
{ 
  prfentry *pe ;
  prfentry *ne ;

  {
#line 50
  pe = section->entry;
  {
#line 51
  while (1) {
    while_continue: /* CIL Label */ ;
#line 51
    if (! pe) {
#line 51
      goto while_break;
    }
#line 52
    if (pe->name) {
      {
#line 53
      free((void *)pe->name);
      }
    }
#line 54
    if (pe->value) {
      {
#line 55
      free((void *)pe->value);
      }
    }
    {
#line 56
    ne = pe->next;
#line 57
    free((void *)pe);
#line 58
    pe = ne;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 60
  if (section->name) {
    {
#line 61
    free((void *)section->name);
    }
  }
#line 62
  return;
}
}
#line 64 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/cprofile.c"
static PROFILE *profile_cleanup(PROFILE *prf ) 
{ 
  prfsection *ps ;
  prfsection *ns ;

  {
#line 68
  if ((unsigned long )prf == (unsigned long )((PROFILE *)((void *)0))) {
#line 69
    return ((PROFILE *)((void *)0));
  }
#line 70
  if (prf->file) {
    {
#line 71
    fclose(prf->file);
    }
  }
#line 72
  ps = prf->section;
  {
#line 73
  while (1) {
    while_continue: /* CIL Label */ ;
#line 73
    if (! ps) {
#line 73
      goto while_break;
    }
    {
#line 74
    profile_free_section(ps);
#line 75
    ns = ps->next;
#line 76
    free((void *)ps);
#line 77
    ps = ns;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 79
  if (prf->name) {
    {
#line 80
    free((void *)prf->name);
    }
  }
  {
#line 81
  free((void *)prf);
  }
#line 82
  return ((PROFILE *)((void *)0));
}
}
#line 85 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/cprofile.c"
PROFILE *profile_open(char const   *filename ) 
{ 
  char line[256] ;
  PROFILE *prf ;
  prfsection *ps ;
  prfsection *ns ;
  prfentry *pe ;
  prfentry *ne ;
  char *p ;
  int len ;
  void *tmp ;
  size_t tmp___0 ;
  PROFILE *tmp___1 ;
  char *tmp___2 ;
  void *tmp___3 ;
  FILE *tmp___4 ;
  PROFILE *tmp___5 ;
  void *tmp___6 ;
  size_t tmp___7 ;
  PROFILE *tmp___8 ;
  char *tmp___9 ;
  void *tmp___10 ;
  PROFILE *tmp___11 ;
  void *tmp___12 ;
  size_t tmp___13 ;
  PROFILE *tmp___14 ;
  char *tmp___15 ;
  void *tmp___16 ;
  size_t tmp___17 ;
  PROFILE *tmp___18 ;
  char *tmp___19 ;
  void *tmp___20 ;
  size_t tmp___21 ;
  size_t tmp___22 ;
  PROFILE *tmp___23 ;
  char *tmp___24 ;
  void *tmp___25 ;
  char *tmp___26 ;

  {
  {
#line 95
  tmp = malloc(sizeof(PROFILE ));
#line 95
  prf = (PROFILE *)tmp;
  }
#line 95
  if ((unsigned long )prf == (unsigned long )((PROFILE *)((void *)0))) {
#line 96
    return ((PROFILE *)((void *)0));
  }
  {
#line 97
  prf->changed = 0;
#line 98
  prf->section = (prfsection *)((void *)0);
#line 99
  tmp___0 = strlen(filename);
#line 99
  len = (int )tmp___0 + 1;
#line 100
  tmp___3 = malloc((unsigned long )len * sizeof(char ));
#line 100
  tmp___2 = (char *)tmp___3;
#line 100
  prf->name = tmp___2;
  }
#line 100
  if ((unsigned long )tmp___2 == (unsigned long )((char *)((void *)0))) {
    {
#line 101
    tmp___1 = profile_cleanup(prf);
    }
#line 101
    return (tmp___1);
  }
  {
#line 102
  strncpy((char */* __restrict  */)prf->name, (char const   */* __restrict  */)filename,
          (size_t )len);
#line 103
  tmp___4 = fopen((char const   */* __restrict  */)filename, (char const   */* __restrict  */)"r");
#line 103
  prf->file = tmp___4;
  }
#line 103
  if ((unsigned long )tmp___4 == (unsigned long )((FILE *)((void *)0))) {
#line 104
    return (prf);
  }
#line 105
  ns = (prfsection *)((void *)0);
#line 105
  ps = ns;
#line 106
  ne = (prfentry *)((void *)0);
#line 106
  pe = ne;
  {
#line 107
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 107
    tmp___26 = fgets((char */* __restrict  */)(line), (int )sizeof(line), (FILE */* __restrict  */)prf->file);
    }
#line 107
    if (! tmp___26) {
#line 107
      goto while_break;
    }
#line 108
    if ((int )line[0] == 91) {
      {
#line 109
      tmp___6 = malloc(sizeof(prfsection ));
#line 109
      ns = (prfsection *)tmp___6;
      }
#line 109
      if ((unsigned long )ns == (unsigned long )((prfsection *)((void *)0))) {
        {
#line 111
        tmp___5 = profile_cleanup(prf);
        }
#line 111
        return (tmp___5);
      }
#line 112
      ns->name = (char *)((void *)0);
#line 113
      ns->entry = (prfentry *)((void *)0);
#line 114
      ns->next = (prfsection *)((void *)0);
#line 115
      if (ps) {
#line 116
        ps->next = ns;
      } else {
#line 118
        prf->section = ns;
      }
      {
#line 119
      ps = ns;
#line 120
      pe = (prfentry *)((void *)0);
#line 121
      p = strchr((char const   *)(line + 1), ']');
      }
#line 121
      if ((unsigned long )p != (unsigned long )((char *)((void *)0))) {
#line 122
        *p = (char )'\000';
      }
      {
#line 123
      tmp___7 = strlen((char const   *)(line));
#line 123
      len = (int )tmp___7;
#line 124
      tmp___10 = malloc((size_t )len);
#line 124
      tmp___9 = (char *)tmp___10;
#line 124
      ns->name = tmp___9;
      }
#line 124
      if ((unsigned long )tmp___9 == (unsigned long )((char *)((void *)0))) {
        {
#line 125
        tmp___8 = profile_cleanup(prf);
        }
#line 125
        return (tmp___8);
      }
      {
#line 126
      strncpy((char */* __restrict  */)ns->name, (char const   */* __restrict  */)(line + 1),
              (size_t )len);
      }
    } else {
#line 129
      if ((unsigned long )ns == (unsigned long )((prfsection *)((void *)0))) {
#line 130
        goto while_continue;
      }
      {
#line 131
      p = strchr((char const   *)(line), '\n');
      }
#line 131
      if ((unsigned long )p != (unsigned long )((char *)((void *)0))) {
#line 132
        *p = (char )'\000';
      }
#line 133
      if ((int )line[0] == 0) {
#line 134
        goto while_continue;
      }
      {
#line 135
      tmp___12 = malloc(sizeof(prfentry ));
#line 135
      ne = (prfentry *)tmp___12;
      }
#line 135
      if ((unsigned long )ne == (unsigned long )((prfentry *)((void *)0))) {
        {
#line 137
        tmp___11 = profile_cleanup(prf);
        }
#line 137
        return (tmp___11);
      }
#line 138
      ne->name = (char *)((void *)0);
#line 139
      ne->value = (char *)((void *)0);
#line 140
      ne->next = (prfentry *)((void *)0);
#line 141
      if (pe) {
#line 142
        pe->next = ne;
      } else {
#line 144
        ns->entry = ne;
      }
#line 145
      pe = ne;
#line 146
      if ((int )line[0] == 59) {
        {
#line 147
        tmp___13 = strlen((char const   *)(line));
#line 147
        len = (int )tmp___13 + 1;
#line 148
        tmp___16 = malloc((size_t )len);
#line 148
        tmp___15 = (char *)tmp___16;
#line 148
        ne->value = tmp___15;
        }
#line 148
        if ((unsigned long )tmp___15 == (unsigned long )((char *)((void *)0))) {
          {
#line 149
          tmp___14 = profile_cleanup(prf);
          }
#line 149
          return (tmp___14);
        }
        {
#line 150
        strncpy((char */* __restrict  */)ne->value, (char const   */* __restrict  */)(line),
                (size_t )len);
        }
      } else {
        {
#line 153
        strtok((char */* __restrict  */)(line), (char const   */* __restrict  */)"=");
#line 154
        tmp___17 = strlen((char const   *)(line));
#line 154
        len = (int )tmp___17 + 1;
#line 155
        tmp___20 = malloc((size_t )len);
#line 155
        tmp___19 = (char *)tmp___20;
#line 155
        ne->name = tmp___19;
        }
#line 155
        if ((unsigned long )tmp___19 == (unsigned long )((char *)((void *)0))) {
          {
#line 156
          tmp___18 = profile_cleanup(prf);
          }
#line 156
          return (tmp___18);
        }
        {
#line 157
        strncpy((char */* __restrict  */)ne->name, (char const   */* __restrict  */)(line),
                (size_t )len);
#line 158
        tmp___21 = strlen((char const   *)(line));
#line 158
        p = (line + tmp___21) + 1;
#line 163
        tmp___22 = strlen((char const   *)p);
#line 163
        len = (int )tmp___22 + 1;
#line 164
        tmp___25 = malloc((size_t )len);
#line 164
        tmp___24 = (char *)tmp___25;
#line 164
        ne->value = tmp___24;
        }
#line 164
        if ((unsigned long )tmp___24 == (unsigned long )((char *)((void *)0))) {
          {
#line 165
          tmp___23 = profile_cleanup(prf);
          }
#line 165
          return (tmp___23);
        }
        {
#line 166
        strncpy((char */* __restrict  */)ne->value, (char const   */* __restrict  */)p,
                (size_t )len);
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 170
  fclose(prf->file);
#line 171
  prf->file = (FILE *)((void *)0);
  }
#line 172
  return (prf);
}
}
#line 175 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/cprofile.c"
int profile_read_string(PROFILE *prf , char const   *section , char const   *entry ,
                        char const   *def , char *buffer , int len ) 
{ 
  prfsection *ps ;
  prfentry *pe ;
  int count ;
  int slen ;
  char *p ;
  size_t tmp ;
  size_t tmp___0 ;
  int tmp___1 ;
  size_t tmp___3 ;
  int tmp___4 ;
  size_t tmp___5 ;
  size_t tmp___6 ;
  size_t tmp___7 ;
  int tmp___8 ;
  size_t tmp___10 ;
  int tmp___11 ;
  size_t tmp___12 ;
  size_t tmp___14 ;
  int tmp___15 ;
  size_t tmp___16 ;

  {
#line 184
  if ((unsigned long )prf == (unsigned long )((PROFILE *)((void *)0))) {
#line 185
    return (0);
  }
#line 186
  if ((unsigned long )buffer == (unsigned long )((char *)((void *)0))) {
#line 187
    return (0);
  }
#line 188
  ps = prf->section;
#line 189
  if ((unsigned long )section == (unsigned long )((void *)0)) {
#line 191
    count = 0;
#line 192
    p = buffer;
#line 193
    *p = (char )'\000';
    {
#line 194
    while (1) {
      while_continue: /* CIL Label */ ;
#line 194
      if (! ps) {
#line 194
        goto while_break;
      }
      {
#line 195
      tmp = strlen((char const   *)ps->name);
#line 195
      slen = (int )tmp + 1;
      }
#line 196
      if (ps->name) {
#line 196
        if ((slen + 2) + count < len) {
          {
#line 197
          strncpy((char */* __restrict  */)p, (char const   */* __restrict  */)ps->name,
                  (size_t )slen);
#line 198
          tmp___0 = strlen((char const   *)ps->name);
#line 198
          count += (int )tmp___0 + 1;
#line 199
          p = buffer + count;
          }
        }
      }
#line 201
      ps = ps->next;
    }
    while_break: /* CIL Label */ ;
    }
#line 203
    *p = (char )'\000';
#line 204
    return (count);
  }
  {
#line 206
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 206
    if (! ps) {
#line 206
      goto while_break___0;
    }
    {
#line 207
    tmp___1 = strcmp((char const   *)ps->name, section);
    }
#line 207
    if (tmp___1 == 0) {
#line 208
      goto while_break___0;
    }
#line 209
    ps = ps->next;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 211
  if ((unsigned long )ps == (unsigned long )((prfsection *)((void *)0))) {
    {
#line 212
    strncpy((char */* __restrict  */)buffer, (char const   */* __restrict  */)def,
            (size_t )len);
#line 213
    tmp___5 = strlen((char const   *)buffer);
    }
#line 213
    if ((int )tmp___5 < len) {
      {
#line 213
      tmp___3 = strlen((char const   *)buffer);
#line 213
      tmp___4 = (int )tmp___3;
      }
    } else {
#line 213
      tmp___4 = len;
    }
#line 213
    return (tmp___4);
  }
#line 216
  pe = ps->entry;
#line 217
  if ((unsigned long )entry == (unsigned long )((void *)0)) {
#line 219
    count = 0;
#line 220
    p = buffer;
#line 221
    *p = (char )'\000';
    {
#line 222
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 222
      if (! pe) {
#line 222
        goto while_break___1;
      }
      {
#line 223
      tmp___6 = strlen((char const   *)pe->name);
#line 223
      slen = (int )tmp___6 + 1;
      }
#line 224
      if (pe->name) {
#line 224
        if ((count + slen) + 2 < len) {
          {
#line 225
          strncpy((char */* __restrict  */)p, (char const   */* __restrict  */)pe->name,
                  (size_t )slen);
#line 226
          tmp___7 = strlen((char const   *)pe->name);
#line 226
          count += (int )tmp___7 + 1;
#line 227
          p = buffer + count;
          }
        }
      }
#line 229
      pe = pe->next;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 231
    *p = (char )'\000';
#line 232
    return (count);
  }
  {
#line 234
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 234
    if (! pe) {
#line 234
      goto while_break___2;
    }
#line 235
    if (pe->name) {
      {
#line 235
      tmp___8 = strcmp((char const   *)pe->name, entry);
      }
#line 235
      if (tmp___8 == 0) {
#line 236
        goto while_break___2;
      }
    }
#line 237
    pe = pe->next;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 239
  if ((unsigned long )pe == (unsigned long )((prfentry *)((void *)0))) {
#line 239
    goto _L;
  } else
#line 239
  if ((unsigned long )pe->value == (unsigned long )((char *)((void *)0))) {
    _L: /* CIL Label */ 
    {
#line 241
    strncpy((char */* __restrict  */)buffer, (char const   */* __restrict  */)def,
            (size_t )len);
#line 242
    tmp___12 = strlen((char const   *)buffer);
    }
#line 242
    if ((int )tmp___12 < len) {
      {
#line 242
      tmp___10 = strlen((char const   *)buffer);
#line 242
      tmp___11 = (int )tmp___10;
      }
    } else {
#line 242
      tmp___11 = len;
    }
#line 242
    return (tmp___11);
  }
  {
#line 245
  strncpy((char */* __restrict  */)buffer, (char const   */* __restrict  */)pe->value,
          (size_t )len);
#line 246
  tmp___16 = strlen((char const   *)buffer);
  }
#line 246
  if ((int )tmp___16 < len) {
    {
#line 246
    tmp___14 = strlen((char const   *)buffer);
#line 246
    tmp___15 = (int )tmp___14;
    }
  } else {
#line 246
    tmp___15 = len;
  }
#line 246
  return (tmp___15);
}
}
#line 249 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/cprofile.c"
BOOL profile_write_string(PROFILE *prf , char const   *section , char const   *entry ,
                          char const   *value ) 
{ 
  prfsection *ps ;
  prfsection *ns ;
  prfentry *pe ;
  prfentry *ne ;
  int slen ;
  int tmp ;
  void *tmp___0 ;
  size_t tmp___1 ;
  char *tmp___2 ;
  void *tmp___3 ;
  int tmp___4 ;
  void *tmp___5 ;
  size_t tmp___6 ;
  char *tmp___7 ;
  void *tmp___8 ;
  size_t tmp___9 ;
  char *tmp___10 ;
  void *tmp___11 ;

  {
#line 256
  if ((unsigned long )prf == (unsigned long )((PROFILE *)((void *)0))) {
#line 257
    return (0);
  }
#line 258
  ns = prf->section;
#line 259
  ps = (prfsection *)((void *)0);
  {
#line 260
  while (1) {
    while_continue: /* CIL Label */ ;
#line 260
    if (! ns) {
#line 260
      goto while_break;
    }
    {
#line 261
    tmp = strcmp((char const   *)ns->name, section);
    }
#line 261
    if (tmp == 0) {
#line 262
      goto while_break;
    }
#line 263
    ps = ns;
#line 264
    ns = ns->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 266
  if ((unsigned long )entry == (unsigned long )((char *)((void *)0))) {
#line 268
    if ((unsigned long )ns == (unsigned long )((prfsection *)((void *)0))) {
#line 269
      return (1);
    }
    {
#line 270
    profile_free_section(ns);
    }
#line 271
    if (ps) {
#line 272
      ps->next = ns->next;
    } else {
#line 274
      prf->section = ns->next;
    }
    {
#line 275
    free((void *)ns);
#line 276
    prf->changed = 1;
    }
#line 277
    return (1);
  }
#line 279
  if ((unsigned long )ns == (unsigned long )((prfsection *)((void *)0))) {
    {
#line 281
    tmp___0 = malloc(sizeof(prfsection ));
#line 281
    ns = (prfsection *)tmp___0;
    }
#line 281
    if ((unsigned long )ns == (unsigned long )((prfsection *)((void *)0))) {
#line 283
      return (0);
    }
#line 284
    ns->name = (char *)((void *)0);
#line 285
    ns->entry = (prfentry *)((void *)0);
#line 286
    ns->next = (prfsection *)((void *)0);
#line 287
    if (ps) {
#line 288
      ps->next = ns;
    } else {
#line 290
      prf->section = ns;
    }
    {
#line 291
    ps = ns;
#line 292
    pe = (prfentry *)((void *)0);
#line 293
    tmp___1 = strlen(section);
#line 293
    slen = (int )tmp___1 + 1;
#line 294
    tmp___3 = malloc((size_t )slen);
#line 294
    tmp___2 = (char *)tmp___3;
#line 294
    ns->name = tmp___2;
    }
#line 294
    if ((unsigned long )tmp___2 == (unsigned long )((char *)((void *)0))) {
#line 295
      return (0);
    }
    {
#line 296
    strncpy((char */* __restrict  */)ns->name, (char const   */* __restrict  */)section,
            (size_t )slen);
    }
  }
#line 298
  ne = ns->entry;
#line 299
  pe = (prfentry *)((void *)0);
  {
#line 300
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 300
    if (! ne) {
#line 300
      goto while_break___0;
    }
#line 301
    if (ne->name) {
      {
#line 301
      tmp___4 = strcmp((char const   *)ne->name, entry);
      }
#line 301
      if (tmp___4 == 0) {
#line 302
        goto while_break___0;
      }
    }
#line 303
    pe = ne;
#line 304
    ne = ne->next;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 306
  if ((unsigned long )ne == (unsigned long )((prfentry *)((void *)0))) {
    {
#line 308
    tmp___5 = malloc(sizeof(prfentry ));
#line 308
    ne = (prfentry *)tmp___5;
    }
#line 308
    if ((unsigned long )ne == (unsigned long )((prfentry *)((void *)0))) {
#line 310
      return (0);
    }
#line 311
    ne->name = (char *)((void *)0);
#line 312
    ne->value = (char *)((void *)0);
#line 313
    ne->next = (prfentry *)((void *)0);
#line 314
    if (pe) {
#line 315
      pe->next = ne;
    } else {
#line 317
      ns->entry = ne;
    }
    {
#line 318
    pe = ne;
#line 319
    tmp___6 = strlen(entry);
#line 319
    slen = (int )tmp___6 + 1;
#line 320
    tmp___8 = malloc((size_t )slen);
#line 320
    tmp___7 = (char *)tmp___8;
#line 320
    ne->name = tmp___7;
    }
#line 320
    if ((unsigned long )tmp___7 == (unsigned long )((char *)((void *)0))) {
#line 321
      return (0);
    }
    {
#line 322
    strncpy((char */* __restrict  */)ne->name, (char const   */* __restrict  */)entry,
            (size_t )slen);
    }
  }
#line 324
  if ((unsigned long )ne->value != (unsigned long )((char *)((void *)0))) {
    {
#line 325
    free((void *)ne->value);
    }
  }
#line 326
  if (value) {
    {
#line 327
    tmp___9 = strlen(value);
#line 327
    slen = (int )tmp___9 + 1;
#line 328
    tmp___11 = malloc((size_t )slen);
#line 328
    tmp___10 = (char *)tmp___11;
#line 328
    ne->value = tmp___10;
    }
#line 328
    if ((unsigned long )tmp___10 == (unsigned long )((char *)((void *)0))) {
#line 329
      return (0);
    }
    {
#line 330
    strncpy((char */* __restrict  */)ne->value, (char const   */* __restrict  */)value,
            (size_t )slen);
    }
  } else {
    {
#line 333
    free((void *)ne->name);
    }
#line 334
    if (pe) {
#line 335
      pe->next = ne->next;
    } else {
#line 337
      ns->entry = ne->next;
    }
    {
#line 338
    free((void *)ne);
    }
  }
#line 340
  prf->changed = 1;
#line 341
  return (1);
}
}
#line 344 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/cprofile.c"
BOOL profile_close(PROFILE *prf ) 
{ 
  prfsection *ps ;
  prfentry *pe ;
  FILE *tmp ;

  {
#line 349
  if ((unsigned long )prf == (unsigned long )((PROFILE *)((void *)0))) {
#line 350
    return (0);
  }
#line 351
  if (prf->changed) {
    {
#line 352
    tmp = fopen((char const   */* __restrict  */)prf->name, (char const   */* __restrict  */)"w");
#line 352
    prf->file = tmp;
    }
#line 352
    if ((unsigned long )tmp == (unsigned long )((FILE *)((void *)0))) {
      {
#line 353
      profile_cleanup(prf);
      }
#line 354
      return (0);
    }
#line 356
    ps = prf->section;
    {
#line 357
    while (1) {
      while_continue: /* CIL Label */ ;
#line 357
      if (! ps) {
#line 357
        goto while_break;
      }
#line 358
      if (ps->name) {
        {
#line 359
        fprintf((FILE */* __restrict  */)prf->file, (char const   */* __restrict  */)"[%s]\n",
                ps->name);
        }
      }
#line 360
      pe = ps->entry;
      {
#line 361
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 361
        if (! pe) {
#line 361
          goto while_break___0;
        }
#line 362
        if (pe->name) {
#line 363
          if (pe->value) {
            {
#line 364
            fprintf((FILE */* __restrict  */)prf->file, (char const   */* __restrict  */)"%s=%s\n",
                    pe->name, pe->value);
            }
          } else {
            {
#line 366
            fprintf((FILE */* __restrict  */)prf->file, (char const   */* __restrict  */)"%s=\n",
                    pe->name);
            }
          }
        } else
#line 369
        if (pe->value) {
          {
#line 370
          fprintf((FILE */* __restrict  */)prf->file, (char const   */* __restrict  */)"%s\n",
                  pe->value);
          }
        }
#line 372
        pe = pe->next;
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 374
      fprintf((FILE */* __restrict  */)prf->file, (char const   */* __restrict  */)"\n");
#line 375
      ps = ps->next;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 378
  profile_cleanup(prf);
  }
#line 379
  return (1);
}
}
/* compiler builtin: 
   void __builtin_va_start(__builtin_va_list  ) ;  */
/* compiler builtin: 
   void __builtin_va_end(__builtin_va_list  ) ;  */
#line 169 "/usr/include/stdio.h"
extern struct _IO_FILE *stdout ;
#line 390
extern  __attribute__((__nothrow__)) int ( /* format attribute */  vsnprintf)(char * __restrict  __s ,
                                                                              size_t __maxlen ,
                                                                              char const   * __restrict  __format ,
                                                                              __gnuc_va_list __arg ) ;
#line 709
extern size_t fread(void * __restrict  __ptr , size_t __size , size_t __n , FILE * __restrict  __stream ) ;
#line 715
extern size_t fwrite(void const   * __restrict  __ptr , size_t __size , size_t __n ,
                     FILE * __restrict  __s ) ;
#line 749
extern int fseek(FILE *__stream , long __off , int __whence ) ;
#line 754
extern long ftell(FILE *__stream ) ;
#line 144 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) double ( __attribute__((__nonnull__(1), __leaf__)) atof)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 147
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 150
extern  __attribute__((__nothrow__)) long ( __attribute__((__nonnull__(1), __leaf__)) atol)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 46 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memcpy)(void * __restrict  __dest ,
                                                                                                 void const   * __restrict  __src ,
                                                                                                 size_t __n ) ;
#line 50
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memmove)(void *__dest ,
                                                                                                  void const   *__src ,
                                                                                                  size_t __n ) ;
#line 66
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memset)(void *__s ,
                                                                                               int __c ,
                                                                                               size_t __n ) ;
#line 69
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) memcmp)(void const   *__s1 ,
                                                                                               void const   *__s2 ,
                                                                                               size_t __n )  __attribute__((__pure__)) ;
#line 79 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) unsigned short const   **( __attribute__((__leaf__)) __ctype_b_loc)(void)  __attribute__((__const__)) ;
#line 41 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/cpdfscan.h"
PDFSCAN *pdf_scan_open(char const   *filename , void *handle , int (*fn)(void *handle ,
                                                                         char const   *ptr ,
                                                                         int len ) ) ;
#line 45
int pdf_scan_page_count(PDFSCAN *ps ) ;
#line 49
int pdf_scan_page_media(PDFSCAN *ps , int pagenum , int *rotate , PDFBBOX *mediabox ,
                        PDFBBOX *cropbox ) ;
#line 53
void pdf_scan_close(PDFSCAN *ps ) ;
#line 85 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/cpdfscan.c"
char const   *rtype_string[14]  = 
#line 85 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/cpdfscan.c"
  {      "invalidtype",      "marktype",      "nulltype",      "booltype", 
        "integertype",      "realtype",      "nametype",      "stringtype", 
        "arraytype",      "dicttype",      "optype",      "streamtype", 
        "objtype",      "commenttype"};
#line 178
static int pdf_scan_next_token(PDFSCAN *ps ) ;
#line 179
static int pdf_scan_read_trailer(PDFSCAN *ps , unsigned long *prev ) ;
#line 180
static int pdf_scan_read_xref(PDFSCAN *ps , unsigned long xref_offset ) ;
#line 182
static void clear_stack(PDFSCAN *ps ) ;
#line 183
static void clear_objs(PDFSCAN *ps ) ;
#line 184
static void pdf_scan_freeall(PDFSCAN *ps ) ;
#line 185
static void pdf_scan_cleanup(PDFSCAN *ps ) ;
#line 186
static int pdf_scan_open_file(PDFSCAN *ps ) ;
#line 192 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/cpdfscan.c"
static int pdf_scan_write(PDFSCAN *ps , char const   *str , int len ) 
{ 


  {
#line 195
  if ((unsigned long )ps != (unsigned long )((void *)0)) {
    {
#line 196
    fwrite((void const   */* __restrict  */)str, (size_t )1, (size_t )len, (FILE */* __restrict  */)stdout);
    }
  } else {
    {
#line 198
    (*(ps->print_fn))(ps->handle, str, len);
    }
  }
#line 199
  return (len);
}
}
#line 202 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/cpdfscan.c"
static int pdf_scan_msgf(PDFSCAN *ps , char const   *fmt  , ...) 
{ 
  va_list args ;
  int count ;
  char buf[2048] ;

  {
  {
#line 208
  __builtin_va_start(args, fmt);
#line 209
  count = vsnprintf((char */* __restrict  */)(buf), sizeof(buf), (char const   */* __restrict  */)fmt,
                    args);
#line 210
  pdf_scan_write(ps, (char const   *)(buf), count);
#line 211
  __builtin_va_end(args);
  }
#line 212
  return (count);
}
}
#line 218 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/cpdfscan.c"
static void pdf_scan_cleanup(PDFSCAN *ps ) 
{ 


  {
#line 221
  if (ps->file) {
    {
#line 222
    fclose(ps->file);
    }
  }
  {
#line 223
  ps->file = (FILE *)((void *)0);
#line 224
  clear_stack(ps);
#line 225
  clear_objs(ps);
#line 226
  pdf_scan_freeall(ps);
  }
#line 227
  return;
}
}
#line 229 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/cpdfscan.c"
static void *pdf_scan_alloc(PDFSCAN *ps , void const   *ptr , int len ) 
{ 
  void *data ;
  PDFMEM *mem ;
  void *tmp ;
  PDFMEM *tmp___0 ;

  {
  {
#line 232
  tmp = malloc(sizeof(PDFMEM ));
#line 232
  mem = (PDFMEM *)tmp;
  }
#line 233
  if ((unsigned long )mem == (unsigned long )((void *)0)) {
#line 234
    return ((void *)0);
  }
  {
#line 236
  data = malloc((size_t )len);
  }
#line 237
  if ((unsigned long )data == (unsigned long )((void *)0)) {
    {
#line 238
    free((void *)mem);
    }
#line 239
    return ((void *)0);
  }
  {
#line 242
  mem->ptr = data;
#line 243
  mem->next = (PDFMEM *)((void *)0);
#line 244
  mem->len = len;
#line 245
  memcpy((void */* __restrict  */)data, (void const   */* __restrict  */)ptr, (size_t )len);
  }
#line 247
  if (ps->memory_tail) {
#line 248
    (ps->memory_tail)->next = mem;
#line 249
    ps->memory_tail = mem;
  } else {
#line 252
    tmp___0 = mem;
#line 252
    ps->memory_tail = tmp___0;
#line 252
    ps->memory_head = tmp___0;
  }
#line 253
  return (data);
}
}
#line 257 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/cpdfscan.c"
static void pdf_scan_freeall(PDFSCAN *ps ) 
{ 
  PDFMEM *memnext ;
  PDFMEM *mem ;
  PDFMEM *tmp ;

  {
#line 261
  mem = ps->memory_head;
  {
#line 262
  while (1) {
    while_continue: /* CIL Label */ ;
#line 262
    if (! mem) {
#line 262
      goto while_break;
    }
    {
#line 263
    memnext = mem->next;
#line 264
    free(mem->ptr);
#line 265
    free((void *)mem);
#line 266
    mem = memnext;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 268
  tmp = (PDFMEM *)((void *)0);
#line 268
  ps->memory_tail = tmp;
#line 268
  ps->memory_head = tmp;
#line 269
  return;
}
}
#line 274 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/cpdfscan.c"
static BOOL is_optoken(PDFSCAN *ps , char const   *str ) 
{ 
  size_t tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 276
  if ((unsigned int )ps->token_type == 10U) {
    {
#line 276
    tmp = strlen(str);
    }
#line 276
    if (ps->end - ps->begin == (int )tmp) {
      {
#line 276
      tmp___0 = memcmp((void const   *)(ps->buf + ps->begin), (void const   *)str,
                       (size_t )(ps->end - ps->begin));
      }
#line 276
      if (tmp___0 == 0) {
#line 276
        tmp___1 = 1;
      } else {
#line 276
        tmp___1 = 0;
      }
    } else {
#line 276
      tmp___1 = 0;
    }
  } else {
#line 276
    tmp___1 = 0;
  }
#line 276
  return (tmp___1);
}
}
#line 281 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/cpdfscan.c"
static int type_check(PDFSCAN *ps , rtype type ) 
{ 


  {
#line 284
  if ((unsigned int )ps->token_type == (unsigned int )type) {
#line 285
    return (0);
  }
  {
#line 287
  pdf_scan_msgf(ps, "Error at offset %ld.  Expecting %s and found %s\n", ps->offset + ps->begin,
                rtype_string[(int )type], rtype_string[(int )ps->token_type]);
#line 291
  pdf_scan_msgf(ps, "Token is \"");
#line 292
  pdf_scan_write(ps, (char const   *)(ps->buf + ps->begin), ps->end - ps->begin);
#line 293
  pdf_scan_msgf(ps, "\"\n");
  }
#line 294
  return (-1);
}
}
#line 297 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/cpdfscan.c"
static int op_check(PDFSCAN *ps , char const   *str ) 
{ 
  int code ;
  int tmp ;
  BOOL tmp___0 ;

  {
  {
#line 300
  tmp = type_check(ps, (rtype )10);
#line 300
  code = tmp;
  }
#line 301
  if (code) {
#line 302
    return (code);
  }
  {
#line 304
  tmp___0 = is_optoken(ps, str);
  }
#line 304
  if (! tmp___0) {
    {
#line 305
    pdf_scan_msgf(ps, "Error at offset %ld.  Expecting \"%s\" and found \"", ps->offset + ps->begin,
                  str);
#line 308
    pdf_scan_write(ps, (char const   *)(ps->buf + ps->begin), ps->end - ps->begin);
#line 309
    pdf_scan_msgf(ps, "\"\n");
#line 310
    code = -1;
    }
  }
#line 312
  return (code);
}
}
#line 318 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/cpdfscan.c"
struct ref_s  const  invalidref  =    {(rtype )0, 0, {(void *)0}};
#line 319 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/cpdfscan.c"
struct ref_s  const  markref  =    {(rtype )1, 0, {(void *)0}};
#line 323 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/cpdfscan.c"
static int push_stack(PDFSCAN *ps , ref r ) 
{ 
  int idx ;
  ref *newstack ;
  int newlen ;
  void *tmp ;

  {
#line 326
  if (ps->ostack_idx + 1 >= ps->ostack_len) {
#line 329
    newlen = ps->ostack_len + 256;
#line 330
    if (newlen > ps->ostack_maxlen) {
      {
#line 331
      pdf_scan_msgf(ps, "push_stack: stack overflow\n");
      }
#line 332
      return (0);
    }
    {
#line 334
    tmp = malloc((unsigned long )newlen * sizeof(ref ));
#line 334
    newstack = (ref *)tmp;
    }
#line 335
    if ((unsigned long )newstack == (unsigned long )((void *)0)) {
      {
#line 336
      pdf_scan_msgf(ps, "push_stack: Out of memory\n");
      }
#line 337
      return (0);
    }
    {
#line 339
    memcpy((void */* __restrict  */)newstack, (void const   */* __restrict  */)ps->ostack,
           (unsigned long )ps->ostack_len * sizeof(ref ));
#line 340
    free((void *)ps->ostack);
#line 341
    ps->ostack = newstack;
#line 342
    ps->ostack_len = newlen;
    }
  }
#line 344
  (ps->ostack_idx) ++;
#line 344
  idx = ps->ostack_idx;
#line 345
  *(ps->ostack + idx) = r;
#line 346
  return (idx);
}
}
#line 349 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/cpdfscan.c"
static ref pop_stack(PDFSCAN *ps ) 
{ 
  int tmp ;

  {
#line 351
  if (ps->ostack_idx <= 0) {
    {
#line 352
    pdf_scan_msgf(ps, "pop_stack: stack underflow\n");
    }
#line 353
    return ((ref )invalidref);
  }
#line 355
  tmp = ps->ostack_idx;
#line 355
  (ps->ostack_idx) --;
#line 355
  return (*(ps->ostack + tmp));
}
}
#line 358 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/cpdfscan.c"
static void clear_stack(PDFSCAN *ps ) 
{ 


  {
#line 360
  ps->ostack_idx = 0;
#line 361
  return;
}
}
#line 363 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/cpdfscan.c"
static ref index_stack(PDFSCAN *ps , int n ) 
{ 


  {
#line 365
  if (n < 0) {
    {
#line 366
    pdf_scan_msgf(ps, "index_stack: index must not be negative\n");
    }
#line 367
    return ((ref )invalidref);
  }
#line 369
  if (ps->ostack_idx <= n) {
    {
#line 370
    pdf_scan_msgf(ps, "index_stack: stack isn\'t that deep\n");
    }
#line 371
    return ((ref )invalidref);
  }
#line 373
  return (*(ps->ostack + (ps->ostack_idx - n)));
}
}
#line 376 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/cpdfscan.c"
static ref top_stack(PDFSCAN *ps ) 
{ 


  {
#line 378
  if (ps->ostack_idx <= 0) {
    {
#line 379
    pdf_scan_msgf(ps, "top_stack: stack is empty\n");
    }
#line 380
    return ((ref )invalidref);
  }
#line 382
  return (*(ps->ostack + ps->ostack_idx));
}
}
#line 389 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/cpdfscan.c"
static ref make_int(int value ) 
{ 
  ref r ;

  {
#line 392
  r.type = (rtype )4;
#line 393
  r.rsize = 0;
#line 394
  r.value.intval = value;
#line 395
  return (r);
}
}
#line 398 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/cpdfscan.c"
static ref make_string(PDFSCAN *ps , char const   *str , int len ) 
{ 
  ref r ;
  void *tmp ;

  {
  {
#line 401
  r.type = (rtype )7;
#line 402
  r.rsize = len;
#line 403
  tmp = pdf_scan_alloc(ps, (void const   *)str, len);
#line 403
  r.value.strval = (char *)tmp;
  }
#line 404
  if ((unsigned long )r.value.strval == (unsigned long )((void *)0)) {
#line 405
    return ((ref )invalidref);
  }
#line 406
  return (r);
}
}
#line 409 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/cpdfscan.c"
static ref make_name(PDFSCAN *ps , char const   *str , int len ) 
{ 
  ref r ;
  void *tmp ;

  {
  {
#line 412
  r.type = (rtype )6;
#line 413
  r.rsize = len;
#line 414
  tmp = pdf_scan_alloc(ps, (void const   *)str, len);
#line 414
  r.value.nameval = (char *)tmp;
  }
#line 415
  if ((unsigned long )r.value.nameval == (unsigned long )((void *)0)) {
#line 416
    return ((ref )invalidref);
  }
#line 417
  return (r);
}
}
#line 420 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/cpdfscan.c"
static BOOL nameref_equals(ref *r , char const   *name ) 
{ 
  int len ;
  size_t tmp ;
  int tmp___0 ;

  {
  {
#line 422
  tmp = strlen(name);
#line 422
  len = (int )tmp;
  }
#line 423
  if ((unsigned int )r->type != 6U) {
#line 424
    return (0);
  }
#line 425
  if (r->rsize != len) {
#line 426
    return (0);
  }
  {
#line 427
  tmp___0 = memcmp((void const   *)r->value.nameval, (void const   *)name, (size_t )len);
  }
#line 427
  return (tmp___0 == 0);
}
}
#line 432 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/cpdfscan.c"
static ref dict_get(PDFSCAN *ps , char const   *name ) 
{ 
  int namelen ;
  size_t tmp ;
  ref dict ;
  ref tmp___0 ;
  ref *r ;
  int dictlen ;
  int i ;
  int tmp___1 ;

  {
  {
#line 434
  tmp = strlen(name);
#line 434
  namelen = (int )tmp;
#line 435
  tmp___0 = top_stack(ps);
#line 435
  dict = tmp___0;
  }
#line 439
  if ((unsigned int )dict.type == 0U) {
#line 440
    return ((ref )invalidref);
  }
#line 441
  dictlen = dict.rsize * 2;
#line 442
  i = 0;
  {
#line 442
  while (1) {
    while_continue: /* CIL Label */ ;
#line 442
    if (! (i < dictlen)) {
#line 442
      goto while_break;
    }
#line 443
    r = dict.value.dictval + i;
#line 444
    if (r->rsize == namelen) {
#line 444
      if ((unsigned int )r->type == 6U) {
        {
#line 444
        tmp___1 = memcmp((void const   *)r->value.nameval, (void const   *)name, (size_t )namelen);
        }
#line 444
        if (tmp___1 == 0) {
#line 446
          return (*(dict.value.dictval + (i + 1)));
        }
      }
    }
#line 442
    i += 2;
  }
  while_break: /* CIL Label */ ;
  }
#line 448
  return ((ref )invalidref);
}
}
#line 452 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/cpdfscan.c"
static ref array_to_mark(PDFSCAN *ps ) 
{ 
  ref r ;
  ref *array ;
  int n ;
  int len ;
  void *tmp ;

  {
#line 456
  n = ps->ostack_idx;
  {
#line 458
  while (1) {
    while_continue: /* CIL Label */ ;
#line 458
    if (n > 0) {
#line 458
      if (! ((unsigned int )(ps->ostack + n)->type != 1U)) {
#line 458
        goto while_break;
      }
    } else {
#line 458
      goto while_break;
    }
#line 459
    n --;
  }
  while_break: /* CIL Label */ ;
  }
#line 460
  if (n == 0) {
    {
#line 461
    pdf_scan_msgf(ps, "array_to_mark: no mark on stack\n");
    }
#line 462
    return ((ref )invalidref);
  }
#line 464
  len = ps->ostack_idx - n;
#line 465
  r.type = (rtype )8;
#line 466
  r.rsize = len;
#line 467
  r.value.arrayval = (ref *)((void *)0);
#line 468
  if (len) {
    {
#line 469
    tmp = pdf_scan_alloc(ps, (void const   *)(ps->ostack + (n + 1)), (int )((unsigned long )len * sizeof(ref )));
#line 469
    array = (ref *)tmp;
    }
#line 470
    if (array) {
#line 471
      r.value.arrayval = array;
    } else {
#line 473
      return ((ref )invalidref);
    }
  }
  {
#line 475
  ps->ostack_idx -= len + 1;
#line 476
  push_stack(ps, r);
  }
#line 477
  return (r);
}
}
#line 481 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/cpdfscan.c"
static ref dict_to_mark(PDFSCAN *ps ) 
{ 
  ref r ;
  ref *dict ;
  int n ;
  int len ;
  void *tmp ;

  {
#line 485
  n = ps->ostack_idx;
  {
#line 487
  while (1) {
    while_continue: /* CIL Label */ ;
#line 487
    if (n > 0) {
#line 487
      if (! ((unsigned int )(ps->ostack + n)->type != 1U)) {
#line 487
        goto while_break;
      }
    } else {
#line 487
      goto while_break;
    }
#line 488
    n --;
  }
  while_break: /* CIL Label */ ;
  }
#line 489
  if (n == 0) {
    {
#line 490
    pdf_scan_msgf(ps, "dict_to_mark: no mark on stack\n");
    }
#line 491
    return ((ref )invalidref);
  }
#line 493
  len = ps->ostack_idx - n;
#line 494
  if (len & 1) {
    {
#line 495
    pdf_scan_msgf(ps, "dict_to_mark: must have name/value pairs\n");
    }
#line 496
    return ((ref )invalidref);
  }
#line 498
  r.type = (rtype )9;
#line 499
  r.rsize = len / 2;
#line 500
  r.value.arrayval = (ref *)((void *)0);
#line 501
  if (len) {
    {
#line 502
    tmp = pdf_scan_alloc(ps, (void const   *)(ps->ostack + (n + 1)), (int )((unsigned long )len * sizeof(ref )));
#line 502
    dict = (ref *)tmp;
    }
#line 503
    if (dict) {
#line 504
      r.value.arrayval = dict;
    } else {
#line 506
      return ((ref )invalidref);
    }
  }
  {
#line 508
  ps->ostack_idx -= len + 1;
#line 509
  push_stack(ps, r);
  }
#line 510
  return (r);
}
}
#line 516 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/cpdfscan.c"
static ref push_token(PDFSCAN *ps ) 
{ 
  ref r ;
  int len ;
  char const   *p ;
  int tmp ;
  int tmp___0 ;
  char buf[64] ;
  char buf___0[64] ;
  double tmp___1 ;

  {
#line 519
  len = ps->end - ps->begin;
#line 520
  p = (char const   *)(ps->buf + ps->begin);
#line 521
  r.type = ps->token_type;
#line 522
  r.rsize = 0;
#line 523
  r.value.voidval = (void *)0;
  {
#line 525
  if ((unsigned int )r.type == 0U) {
#line 525
    goto case_0;
  }
#line 527
  if ((unsigned int )r.type == 1U) {
#line 527
    goto case_1;
  }
#line 529
  if ((unsigned int )r.type == 2U) {
#line 529
    goto case_2;
  }
#line 531
  if ((unsigned int )r.type == 3U) {
#line 531
    goto case_3;
  }
#line 539
  if ((unsigned int )r.type == 4U) {
#line 539
    goto case_4;
  }
#line 550
  if ((unsigned int )r.type == 5U) {
#line 550
    goto case_5;
  }
#line 561
  if ((unsigned int )r.type == 6U) {
#line 561
    goto case_6;
  }
#line 564
  if ((unsigned int )r.type == 7U) {
#line 564
    goto case_7;
  }
#line 572
  if ((unsigned int )r.type == 9U) {
#line 572
    goto case_9;
  }
#line 572
  if ((unsigned int )r.type == 8U) {
#line 572
    goto case_9;
  }
#line 572
  if ((unsigned int )r.type == 10U) {
#line 572
    goto case_9;
  }
#line 572
  if ((unsigned int )r.type == 12U) {
#line 572
    goto case_9;
  }
#line 572
  if ((unsigned int )r.type == 13U) {
#line 572
    goto case_9;
  }
#line 572
  if ((unsigned int )r.type == 11U) {
#line 572
    goto case_9;
  }
#line 576
  goto switch_default;
  case_0: /* CIL Label */ 
#line 526
  goto switch_break;
  case_1: /* CIL Label */ 
#line 528
  goto switch_break;
  case_2: /* CIL Label */ 
#line 530
  goto switch_break;
  case_3: /* CIL Label */ 
#line 532
  if (len == 4) {
    {
#line 532
    tmp___0 = memcmp((void const   *)p, (void const   *)"true", (size_t )4);
    }
#line 532
    if (tmp___0 == 0) {
#line 533
      r.value.boolval = 1;
    } else {
#line 532
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 534
  if (len == 5) {
    {
#line 534
    tmp = memcmp((void const   *)p, (void const   *)"true", (size_t )5);
    }
#line 534
    if (tmp == 0) {
#line 535
      r.value.boolval = 0;
    } else {
#line 537
      r = (ref )invalidref;
    }
  } else {
#line 537
    r = (ref )invalidref;
  }
#line 538
  goto switch_break;
  case_4: /* CIL Label */ 
#line 541
  if (len > (int )sizeof(buf) - 1) {
#line 542
    r = (ref )invalidref;
  } else {
    {
#line 544
    memcpy((void */* __restrict  */)(buf), (void const   */* __restrict  */)p, (size_t )len);
#line 545
    buf[len] = (char )'\000';
#line 546
    r.value.intval = atoi((char const   *)(buf));
    }
  }
#line 549
  goto switch_break;
  case_5: /* CIL Label */ 
#line 552
  if (len > (int )sizeof(buf___0) - 1) {
#line 553
    r = (ref )invalidref;
  } else {
    {
#line 555
    memcpy((void */* __restrict  */)(buf___0), (void const   */* __restrict  */)p,
           (size_t )len);
#line 556
    buf___0[len] = (char )'\000';
#line 557
    tmp___1 = atof((char const   *)(buf___0));
#line 557
    r.value.realval = (float )tmp___1;
    }
  }
#line 560
  goto switch_break;
  case_6: /* CIL Label */ 
  {
#line 562
  r = make_name(ps, p + 1, len - 1);
  }
#line 563
  goto switch_break;
  case_7: /* CIL Label */ 
  {
#line 565
  r = make_string(ps, p, len);
  }
#line 566
  goto switch_break;
  case_9: /* CIL Label */ 
  case_8: /* CIL Label */ 
  case_10: /* CIL Label */ 
  case_12: /* CIL Label */ 
  case_13: /* CIL Label */ 
  case_11: /* CIL Label */ 
#line 575
  return ((ref )invalidref);
  switch_default: /* CIL Label */ 
#line 577
  r.type = (rtype )0;
#line 578
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 580
  push_stack(ps, r);
  }
#line 581
  return (r);
}
}
#line 585 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/cpdfscan.c"
static int process_op(PDFSCAN *ps ) 
{ 
  ref r ;
  ref r1 ;
  ref tmp ;
  BOOL tmp___0 ;
  BOOL tmp___1 ;
  BOOL tmp___2 ;
  BOOL tmp___3 ;
  BOOL tmp___4 ;
  BOOL tmp___5 ;
  BOOL tmp___6 ;

  {
#line 588
  if ((unsigned int )ps->token_type != 10U) {
#line 589
    return (1);
  }
  {
#line 590
  tmp___6 = is_optoken(ps, "R");
  }
#line 590
  if (tmp___6) {
    {
#line 592
    tmp = index_stack(ps, 1);
#line 592
    r1 = tmp;
#line 593
    r = top_stack(ps);
    }
#line 594
    if ((unsigned int )r.type == 4U) {
#line 594
      if ((unsigned int )r1.type == 4U) {
        {
#line 595
        r.type = (rtype )12;
#line 596
        r.rsize = r.value.intval;
#line 597
        r.value.intval = r1.value.intval;
#line 598
        pop_stack(ps);
#line 599
        pop_stack(ps);
#line 600
        push_stack(ps, r);
        }
      }
    }
  } else {
    {
#line 603
    tmp___5 = is_optoken(ps, "]");
    }
#line 603
    if (tmp___5) {
      {
#line 604
      array_to_mark(ps);
      }
    } else {
      {
#line 606
      tmp___4 = is_optoken(ps, ">>");
      }
#line 606
      if (tmp___4) {
        {
#line 607
        dict_to_mark(ps);
        }
      } else {
        {
#line 609
        tmp___3 = is_optoken(ps, "null");
        }
#line 609
        if (tmp___3) {
          {
#line 610
          r.type = (rtype )2;
#line 611
          r.rsize = 0;
#line 612
          r.value.voidval = (void *)0;
#line 613
          push_stack(ps, r);
          }
        } else {
          {
#line 615
          tmp___2 = is_optoken(ps, "obj");
          }
#line 615
          if (tmp___2) {
            {
#line 616
            pdf_scan_msgf(ps, "ignoring obj token\n");
            }
          } else {
            {
#line 619
            tmp___1 = is_optoken(ps, "endobj");
            }
#line 619
            if (tmp___1) {
              {
#line 620
              pdf_scan_msgf(ps, "ignoring endobj token\n");
              }
            } else {
              {
#line 623
              tmp___0 = is_optoken(ps, "stream");
              }
#line 623
              if (tmp___0) {
                {
#line 625
                r.type = (rtype )11;
#line 626
                r.rsize = 0;
#line 627
                r.value.streamval = (unsigned long )(ps->offset + ps->end);
#line 628
                push_stack(ps, r);
#line 630
                pdf_scan_next_token(ps);
                }
              } else {
                {
#line 633
                pdf_scan_msgf(ps, "process_op: unrecognised operator \"");
#line 634
                pdf_scan_write(ps, (char const   *)(ps->buf + ps->begin), ps->end - ps->begin);
#line 635
                pdf_scan_msgf(ps, "\"\n");
                }
#line 636
                return (-1);
              }
            }
          }
        }
      }
    }
  }
#line 638
  return (0);
}
}
#line 785 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/cpdfscan.c"
static int obj_add(PDFSCAN *ps , int objnum , ref objref ) 
{ 
  ref *newobjs ;
  int newlen ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 787
  if (ps->objs_count + 2 >= ps->objs_len) {
#line 790
    newlen = ps->objs_len + 256;
#line 791
    if (newlen > ps->objs_maxlen) {
      {
#line 792
      pdf_scan_msgf(ps, "obj_add: too many objects to cache\n");
      }
#line 793
      return (0);
    }
    {
#line 795
    tmp = malloc((unsigned long )newlen * sizeof(ref ));
#line 795
    newobjs = (ref *)tmp;
    }
#line 796
    if ((unsigned long )newobjs == (unsigned long )((void *)0)) {
      {
#line 797
      pdf_scan_msgf(ps, "obj_add: Out of memory\n");
      }
#line 798
      return (0);
    }
    {
#line 800
    memcpy((void */* __restrict  */)newobjs, (void const   */* __restrict  */)ps->objs,
           (unsigned long )ps->objs_len * sizeof(ref ));
#line 801
    free((void *)ps->objs);
#line 802
    ps->objs = newobjs;
#line 803
    ps->objs_len = newlen;
    }
  }
  {
#line 805
  tmp___0 = ps->objs_count;
#line 805
  (ps->objs_count) ++;
#line 805
  *(ps->objs + tmp___0) = make_int(objnum);
#line 806
  tmp___1 = ps->objs_count;
#line 806
  (ps->objs_count) ++;
#line 806
  *(ps->objs + tmp___1) = objref;
  }
#line 807
  return (ps->objs_count);
}
}
#line 810 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/cpdfscan.c"
static ref obj_find(PDFSCAN *ps , int objnum ) 
{ 
  int i ;

  {
#line 813
  i = 0;
  {
#line 813
  while (1) {
    while_continue: /* CIL Label */ ;
#line 813
    if (! (i < ps->objs_count)) {
#line 813
      goto while_break;
    }
#line 814
    if (objnum == (ps->objs + i)->value.intval) {
#line 815
      return (*(ps->objs + (i + 1)));
    }
#line 813
    i += 2;
  }
  while_break: /* CIL Label */ ;
  }
#line 817
  return ((ref )invalidref);
}
}
#line 820 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/cpdfscan.c"
static void clear_objs(PDFSCAN *ps ) 
{ 


  {
#line 822
  ps->objs_count = 0;
#line 823
  return;
}
}
#line 828 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/cpdfscan.c"
static int is_white(char ch ) 
{ 
  int tmp ;

  {
#line 830
  if ((int )ch == 0) {
#line 830
    tmp = 1;
  } else
#line 830
  if ((int )ch == 9) {
#line 830
    tmp = 1;
  } else
#line 830
  if ((int )ch == 10) {
#line 830
    tmp = 1;
  } else
#line 830
  if ((int )ch == 12) {
#line 830
    tmp = 1;
  } else
#line 830
  if ((int )ch == 13) {
#line 830
    tmp = 1;
  } else
#line 830
  if ((int )ch == 32) {
#line 830
    tmp = 1;
  } else {
#line 830
    tmp = 0;
  }
#line 830
  return (tmp);
}
}
#line 834 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/cpdfscan.c"
static int is_delimiter(char ch ) 
{ 
  int tmp ;

  {
#line 836
  if ((int )ch == 40) {
#line 836
    tmp = 1;
  } else
#line 836
  if ((int )ch == 41) {
#line 836
    tmp = 1;
  } else
#line 836
  if ((int )ch == 60) {
#line 836
    tmp = 1;
  } else
#line 836
  if ((int )ch == 62) {
#line 836
    tmp = 1;
  } else
#line 836
  if ((int )ch == 91) {
#line 836
    tmp = 1;
  } else
#line 836
  if ((int )ch == 93) {
#line 836
    tmp = 1;
  } else
#line 836
  if ((int )ch == 123) {
#line 836
    tmp = 1;
  } else
#line 836
  if ((int )ch == 125) {
#line 836
    tmp = 1;
  } else
#line 836
  if ((int )ch == 47) {
#line 836
    tmp = 1;
  } else
#line 836
  if ((int )ch == 37) {
#line 836
    tmp = 1;
  } else {
#line 836
    tmp = 0;
  }
#line 836
  return (tmp);
}
}
#line 848 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/cpdfscan.c"
static int pdf_scan_token(char const   *buf , int buflen , rtype *ttype , int *tbegin ,
                          int *tend ) 
{ 
  int code ;
  int i ;
  rtype type ;
  int begin ;
  int end ;
  int tmp ;
  int pcount ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int j ;
  char ch ;
  BOOL isreal ;
  BOOL isnum ;
  unsigned short const   **tmp___6 ;
  int tmp___7 ;

  {
#line 851
  code = -1;
#line 852
  i = 0;
#line 855
  type = (rtype )0;
#line 855
  *ttype = type;
#line 856
  begin = 0;
#line 856
  *tbegin = begin;
#line 857
  end = 0;
#line 857
  *tend = end;
  {
#line 858
  while (1) {
    while_continue: /* CIL Label */ ;
#line 858
    if (i < buflen) {
      {
#line 858
      tmp = is_white((char )*(buf + i));
      }
#line 858
      if (! tmp) {
#line 858
        goto while_break;
      }
    } else {
#line 858
      goto while_break;
    }
#line 859
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 860
  if (i == buflen) {
#line 861
    return (1);
  }
#line 863
  begin = i;
#line 864
  if ((int const   )*(buf + i) == 37) {
    {
#line 865
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 865
      if (! (i < buflen)) {
#line 865
        goto while_break___0;
      }
#line 866
      if ((int const   )*(buf + i) == 10) {
#line 867
        type = (rtype )13;
#line 868
        end = i;
#line 869
        code = 0;
#line 870
        goto while_break___0;
      } else
#line 866
      if ((int const   )*(buf + i) == 13) {
#line 867
        type = (rtype )13;
#line 868
        end = i;
#line 869
        code = 0;
#line 870
        goto while_break___0;
      }
#line 872
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 874
    if (i >= buflen) {
#line 875
      code = 1;
    }
  } else
#line 878
  if ((int const   )*(buf + i) == 40) {
#line 880
    pcount = 0;
#line 881
    type = (rtype )7;
#line 882
    i ++;
    {
#line 883
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 883
      if (! (i < buflen)) {
#line 883
        goto while_break___1;
      }
#line 884
      if ((int const   )*(buf + i) == 92) {
#line 885
        i ++;
      } else
#line 886
      if ((int const   )*(buf + i) == 40) {
#line 887
        pcount ++;
      } else
#line 888
      if ((int const   )*(buf + i) == 41) {
#line 889
        if (pcount <= 0) {
#line 890
          end = i + 1;
#line 891
          code = 0;
#line 892
          goto while_break___1;
        } else {
#line 895
          pcount --;
        }
      }
#line 897
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 899
    if (i >= buflen) {
#line 900
      code = 1;
    }
  } else
#line 902
  if ((int const   )*(buf + i) == 60) {
#line 903
    i ++;
#line 904
    if (i >= buflen) {
#line 905
      code = 1;
    } else
#line 907
    if ((int const   )*(buf + i) == 60) {
#line 909
      end = i + 1;
#line 910
      type = (rtype )1;
#line 911
      code = 0;
    } else {
#line 915
      type = (rtype )7;
      {
#line 916
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 916
        if (! (i < buflen)) {
#line 916
          goto while_break___2;
        }
#line 917
        if ((int const   )*(buf + i) == 62) {
#line 918
          end = i + 1;
#line 919
          code = 0;
#line 920
          goto while_break___2;
        }
#line 922
        i ++;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 924
      if (i >= buflen) {
#line 925
        code = 1;
      }
    }
  } else
#line 928
  if ((int const   )*(buf + i) == 91) {
#line 929
    code = 0;
#line 930
    end = i + 1;
#line 931
    type = (rtype )1;
  } else
#line 933
  if ((int const   )*(buf + i) == 47) {
#line 935
    type = (rtype )6;
#line 936
    i ++;
    {
#line 937
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 937
      if (! (i < buflen)) {
#line 937
        goto while_break___3;
      }
      {
#line 938
      tmp___0 = is_white((char )*(buf + i));
      }
#line 938
      if (tmp___0) {
#line 939
        end = i;
#line 940
        code = 0;
#line 941
        goto while_break___3;
      } else {
        {
#line 938
        tmp___1 = is_delimiter((char )*(buf + i));
        }
#line 938
        if (tmp___1) {
#line 939
          end = i;
#line 940
          code = 0;
#line 941
          goto while_break___3;
        }
      }
#line 943
      i ++;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 945
    if (i >= buflen) {
#line 946
      code = 1;
    }
  } else {
    {
#line 948
    tmp___7 = is_delimiter((char )*(buf + i));
    }
#line 948
    if (tmp___7) {
#line 950
      if ((int const   )*(buf + i) == 62) {
#line 951
        i ++;
#line 952
        if (i < buflen) {
#line 953
          if ((int const   )*(buf + i) == 62) {
#line 954
            type = (rtype )10;
#line 955
            end = i + 1;
#line 956
            code = 0;
          } else {
#line 959
            code = -1;
          }
        }
      } else {
#line 963
        type = (rtype )10;
#line 964
        end = i + 1;
#line 965
        code = 0;
      }
#line 967
      if (i >= buflen) {
#line 968
        code = 1;
      }
    } else {
#line 972
      type = (rtype )10;
      {
#line 973
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 973
        if (! (i < buflen)) {
#line 973
          goto while_break___4;
        }
        {
#line 974
        tmp___2 = is_white((char )*(buf + i));
        }
#line 974
        if (tmp___2) {
#line 975
          end = i;
#line 976
          code = 0;
#line 977
          goto while_break___4;
        } else {
          {
#line 974
          tmp___3 = is_delimiter((char )*(buf + i));
          }
#line 974
          if (tmp___3) {
#line 975
            end = i;
#line 976
            code = 0;
#line 977
            goto while_break___4;
          }
        }
#line 979
        i ++;
      }
      while_break___4: /* CIL Label */ ;
      }
#line 981
      if (i >= buflen) {
#line 982
        code = 1;
      }
#line 985
      if (code == 0) {
#line 985
        if ((unsigned int )type == 10U) {
#line 986
          if (end - begin == 4) {
            {
#line 986
            tmp___5 = memcmp((void const   *)(buf + begin), (void const   *)"true",
                             (size_t )4);
            }
#line 986
            if (tmp___5 == 0) {
#line 988
              type = (rtype )3;
            } else {
#line 986
              goto _L;
            }
          } else
          _L: /* CIL Label */ 
#line 990
          if (end - begin == 5) {
            {
#line 990
            tmp___4 = memcmp((void const   *)(buf + begin), (void const   *)"false",
                             (size_t )5);
            }
#line 990
            if (tmp___4 == 0) {
#line 992
              type = (rtype )3;
            }
          }
        }
      }
#line 997
      if (code == 0) {
#line 997
        if ((unsigned int )type == 10U) {
#line 1000
          isreal = 0;
#line 1001
          isnum = 1;
#line 1002
          j = begin;
          {
#line 1002
          while (1) {
            while_continue___5: /* CIL Label */ ;
#line 1002
            if (! (j < end)) {
#line 1002
              goto while_break___5;
            }
#line 1003
            ch = (char )*(buf + j);
#line 1004
            if ((int )ch == 46) {
#line 1005
              isreal = 1;
            }
#line 1006
            if (! ((int )ch == 45)) {
#line 1006
              if (! ((int )ch == 43)) {
#line 1006
                if (! ((int )ch == 46)) {
                  {
#line 1006
                  tmp___6 = __ctype_b_loc();
                  }
#line 1006
                  if (! ((int const   )*(*tmp___6 + (int )ch) & 2048)) {
#line 1008
                    isnum = 0;
                  }
                }
              }
            }
#line 1002
            j ++;
          }
          while_break___5: /* CIL Label */ ;
          }
#line 1010
          if (isnum) {
#line 1011
            if (isreal) {
#line 1012
              type = (rtype )5;
            } else {
#line 1014
              type = (rtype )4;
            }
          }
        }
      }
    }
  }
#line 1019
  *ttype = type;
#line 1020
  *tbegin = begin;
#line 1021
  *tend = end;
#line 1022
  return (code);
}
}
#line 1027 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/cpdfscan.c"
static void pdf_scan_finish(PDFSCAN *ps ) 
{ 


  {
#line 1029
  if (ps->file) {
    {
#line 1030
    fclose(ps->file);
#line 1031
    ps->file = (FILE *)((void *)0);
    }
  }
#line 1033
  if (ps->buf) {
    {
#line 1034
    free((void *)ps->buf);
#line 1035
    ps->buf = (char *)((void *)0);
    }
  }
#line 1037
  ps->buflen = 0;
#line 1038
  if (ps->xref) {
    {
#line 1039
    free((void *)ps->xref);
#line 1040
    ps->xref = (PDFXREF *)((void *)0);
    }
  }
#line 1042
  ps->xref_len = 0;
#line 1043
  if (ps->ostack) {
    {
#line 1044
    free((void *)ps->ostack);
#line 1045
    ps->ostack = (ref *)((void *)0);
    }
  }
#line 1047
  ps->ostack_len = 0;
#line 1048
  ps->ostack_idx = 0;
#line 1050
  if (ps->objs) {
    {
#line 1051
    free((void *)ps->objs);
#line 1052
    ps->objs = (ref *)((void *)0);
    }
  }
  {
#line 1054
  ps->objs_len = 0;
#line 1055
  ps->objs_count = 0;
#line 1056
  memset((void *)ps, 0, sizeof(PDFSCAN ));
  }
#line 1057
  return;
}
}
#line 1059 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/cpdfscan.c"
static int pdf_scan_open_file(PDFSCAN *ps ) 
{ 


  {
  {
#line 1061
  ps->file = fopen((char const   */* __restrict  */)(ps->filename), (char const   */* __restrict  */)"rb");
  }
#line 1062
  if ((unsigned long )ps->file == (unsigned long )((void *)0)) {
#line 1063
    return (-1);
  }
#line 1064
  return (0);
}
}
#line 1067 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/cpdfscan.c"
static int pdf_scan_init(PDFSCAN *ps , char const   *name ) 
{ 
  int len ;
  size_t tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;

  {
  {
#line 1069
  tmp = strlen(name);
#line 1069
  len = (int )((unsigned long )((int )(tmp + 1UL)) * sizeof(char ));
  }
#line 1070
  if (len > (int )sizeof(ps->filename)) {
#line 1071
    return (-1);
  }
  {
#line 1072
  memcpy((void */* __restrict  */)(ps->filename), (void const   */* __restrict  */)name,
         (size_t )len);
#line 1073
  tmp___0 = pdf_scan_open_file(ps);
  }
#line 1073
  if (tmp___0 != 0) {
#line 1074
    return (-1);
  }
  {
#line 1075
  ps->buflen = 256;
#line 1076
  tmp___1 = malloc((size_t )ps->buflen);
#line 1076
  ps->buf = (char *)tmp___1;
  }
#line 1077
  if ((unsigned long )ps->buf == (unsigned long )((void *)0)) {
    {
#line 1078
    pdf_scan_finish(ps);
    }
#line 1079
    return (-2);
  }
  {
#line 1081
  ps->ostack_maxlen = 4096;
#line 1082
  ps->ostack_len = 256;
#line 1083
  ps->ostack_idx = 0;
#line 1084
  tmp___2 = malloc((unsigned long )ps->ostack_len * sizeof(ref ));
#line 1084
  ps->ostack = (ref *)tmp___2;
  }
#line 1085
  if ((unsigned long )ps->ostack == (unsigned long )((void *)0)) {
    {
#line 1086
    pdf_scan_finish(ps);
    }
#line 1087
    return (-2);
  }
  {
#line 1090
  (ps->ostack + 0)->type = (rtype )0;
#line 1091
  (ps->ostack + 0)->rsize = 0;
#line 1092
  (ps->ostack + 0)->value.voidval = (void *)0;
#line 1095
  ps->objs_maxlen = 1024;
#line 1096
  ps->objs_len = 256;
#line 1097
  ps->objs_count = 0;
#line 1098
  tmp___3 = malloc((unsigned long )ps->objs_len * sizeof(ref ));
#line 1098
  ps->objs = (ref *)tmp___3;
  }
#line 1099
  if ((unsigned long )ps->objs == (unsigned long )((void *)0)) {
    {
#line 1100
    pdf_scan_finish(ps);
    }
#line 1101
    return (-2);
  }
#line 1104
  ps->pagenum = -1;
#line 1106
  return (0);
}
}
#line 1109 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/cpdfscan.c"
static int pdf_scan_seek(PDFSCAN *ps , long offset , PDFSEEK whence ) 
{ 
  int code ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  long tmp___3 ;

  {
#line 1111
  code = -1;
  {
#line 1113
  if ((unsigned int )whence == 0U) {
#line 1113
    goto case_0;
  }
#line 1115
  if ((unsigned int )whence == 2U) {
#line 1115
    goto case_2;
  }
#line 1120
  if ((unsigned int )whence == 1U) {
#line 1120
    goto case_1;
  }
#line 1112
  goto switch_break;
  case_0: /* CIL Label */ 
#line 1114
  offset = (long )(ps->offset + ps->end) + offset;
  case_2: /* CIL Label */ 
  {
#line 1116
  tmp___0 = 0;
#line 1116
  ps->len = tmp___0;
#line 1116
  tmp = tmp___0;
#line 1116
  ps->end = tmp;
#line 1116
  ps->begin = tmp;
#line 1117
  code = fseek(ps->file, offset, 0);
#line 1118
  ps->offset = (int )offset;
  }
#line 1119
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 1121
  code = fseek(ps->file, 0L, 2);
#line 1122
  tmp___2 = 0;
#line 1122
  ps->len = tmp___2;
#line 1122
  tmp___1 = tmp___2;
#line 1122
  ps->end = tmp___1;
#line 1122
  ps->begin = tmp___1;
#line 1123
  tmp___3 = ftell(ps->file);
#line 1123
  ps->offset = (int )tmp___3;
  }
#line 1124
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 1126
  return (code);
}
}
#line 1132 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/cpdfscan.c"
static int pdf_scan_next_token(PDFSCAN *ps ) 
{ 
  int code ;
  int count ;
  rtype type ;
  int begin ;
  int end ;
  char *newbuf ;
  int newbuflen ;
  void *tmp ;
  size_t tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 1134
  code = 0;
#line 1136
  type = (rtype )0;
#line 1137
  begin = 0;
#line 1137
  end = 0;
  {
#line 1139
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1140
    if (code == 1) {
#line 1140
      if (ps->end) {
#line 1142
        if (ps->len - ps->end) {
          {
#line 1143
          memmove((void *)ps->buf, (void const   *)(ps->buf + ps->end), (size_t )(ps->len - ps->end));
          }
        }
#line 1144
        ps->offset += ps->end;
#line 1145
        ps->len -= ps->end;
#line 1146
        ps->begin = 0;
#line 1147
        ps->end = 0;
      }
    }
#line 1150
    if (code == 1) {
#line 1150
      if (ps->len >= ps->buflen) {
        {
#line 1153
        newbuflen = 2 * ps->buflen;
#line 1154
        tmp = malloc((size_t )newbuflen);
#line 1154
        newbuf = (char *)tmp;
        }
#line 1155
        if (newbuf) {
          {
#line 1156
          memcpy((void */* __restrict  */)newbuf, (void const   */* __restrict  */)ps->buf,
                 (size_t )ps->buflen);
#line 1157
          free((void *)ps->buf);
#line 1158
          ps->buf = newbuf;
#line 1159
          ps->buflen = newbuflen;
          }
        } else {
          {
#line 1162
          pdf_scan_msgf(ps, "Out of memory in pdf_scan_next_token\n");
#line 1163
          pdf_scan_msgf(ps, "Tried to realloc %d to %d\n", ps->buflen, newbuflen);
#line 1165
          code = -2;
          }
#line 1166
          goto while_break;
        }
      }
    }
#line 1170
    if (code == 1) {
#line 1170
      goto _L;
    } else
#line 1170
    if (ps->len == 0) {
      _L: /* CIL Label */ 
      {
#line 1171
      tmp___0 = fread((void */* __restrict  */)(ps->buf + ps->len), (size_t )1, (size_t )(ps->buflen - ps->len),
                      (FILE */* __restrict  */)ps->file);
#line 1171
      count = (int )tmp___0;
      }
#line 1173
      if (count == 0) {
        {
#line 1174
        pdf_scan_msgf(ps, "EOF in pdf_scan_next_token\n");
#line 1175
        code = -1;
        }
#line 1176
        goto while_break;
      }
#line 1178
      ps->len += count;
    }
    {
#line 1181
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1181
      if (! ps->instream) {
#line 1181
        goto while_break___0;
      }
      {
#line 1186
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 1186
        if (ps->end < ps->len) {
#line 1186
          if (! ((int )*(ps->buf + ps->end) != 101)) {
#line 1186
            goto while_break___1;
          }
        } else {
#line 1186
          goto while_break___1;
        }
#line 1187
        (ps->end) ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 1189
      if (ps->end + 9 >= ps->len) {
#line 1190
        code = 1;
#line 1191
        goto while_break___0;
      }
      {
#line 1193
      tmp___1 = memcmp((void const   *)(ps->buf + ps->end), (void const   *)"endstream",
                       (size_t )9);
      }
#line 1193
      if (tmp___1 == 0) {
#line 1194
        ps->instream = 0;
      } else {
#line 1196
        (ps->end) ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1198
    if (! ps->instream) {
      {
#line 1199
      code = pdf_scan_token((char const   *)(ps->buf + ps->end), ps->len - ps->end,
                            & type, & begin, & end);
      }
    }
#line 1139
    if (! (code == 1)) {
#line 1139
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1204
  if (code == 0) {
#line 1206
    ps->begin = ps->end + begin;
#line 1207
    ps->end += end;
#line 1208
    ps->token_type = type;
#line 1210
    if ((unsigned int )type == 10U) {
#line 1210
      if (ps->end - ps->begin == 6) {
        {
#line 1210
        tmp___2 = memcmp((void const   *)(ps->buf + ps->begin), (void const   *)"stream",
                         (size_t )6);
        }
#line 1210
        if (tmp___2 == 0) {
#line 1212
          ps->instream = 1;
        }
      }
    }
  }
#line 1215
  return (code);
}
}
#line 1221 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/cpdfscan.c"
static int previous_line(char const   *str , int len ) 
{ 
  int i ;

  {
#line 1224
  i = len - 1;
  {
#line 1226
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1226
    if (i > 0) {
#line 1226
      if (! ((int const   )*(str + i) == 13)) {
#line 1226
        if (! ((int const   )*(str + i) == 10)) {
#line 1226
          goto while_break;
        }
      }
    } else {
#line 1226
      goto while_break;
    }
#line 1227
    i --;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1228
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1228
    if (i > 0) {
#line 1228
      if ((int const   )*(str + i) == 13) {
#line 1228
        goto while_break___0;
      } else
#line 1228
      if ((int const   )*(str + i) == 10) {
#line 1228
        goto while_break___0;
      }
    } else {
#line 1228
      goto while_break___0;
    }
#line 1229
    i --;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1230
  if (! ((int const   )*(str + i) == 13)) {
#line 1230
    if (! ((int const   )*(str + i) == 10)) {
#line 1231
      return (-1);
    }
  }
#line 1232
  return (i + 1);
}
}
#line 1235 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/cpdfscan.c"
static int pdf_scan_find_xref(PDFSCAN *ps ) 
{ 
  char buf[4096] ;
  int i ;
  int j ;
  int code ;
  int count ;
  size_t tmp ;
  int tmp___0 ;
  long tmp___1 ;
  int tmp___2 ;

  {
  {
#line 1240
  code = -1;
#line 1242
  pdf_scan_seek(ps, 0L, (PDFSEEK )1);
  }
#line 1243
  if ((int )sizeof(buf) < ps->offset) {
#line 1243
    count = (int )sizeof(buf);
  } else {
#line 1243
    count = ps->offset;
  }
  {
#line 1244
  pdf_scan_seek(ps, (long )(- count), (PDFSEEK )0);
#line 1245
  tmp = fread((void */* __restrict  */)(buf), (size_t )1, sizeof(buf), (FILE */* __restrict  */)ps->file);
#line 1245
  count = (int )tmp;
#line 1246
  pdf_scan_seek(ps, 0L, (PDFSEEK )2);
  }
#line 1247
  if (count == 0) {
#line 1248
    return (-1);
  }
#line 1249
  i = count - 5;
  {
#line 1250
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1250
    if (! (i > 0)) {
#line 1250
      goto while_break;
    }
    {
#line 1252
    tmp___0 = memcmp((void const   *)(buf + i), (void const   *)"%%EOF", (size_t )5);
    }
#line 1252
    if (tmp___0 == 0) {
#line 1253
      code = 0;
#line 1254
      goto while_break;
    }
#line 1256
    i --;
  }
  while_break: /* CIL Label */ ;
  }
#line 1258
  if (i == 0) {
    {
#line 1259
    pdf_scan_msgf(ps, "Failed to find %%EOF\n");
#line 1260
    code = -1;
    }
  }
#line 1262
  if (code == 0) {
    {
#line 1264
    j = previous_line((char const   *)(buf), i);
    }
#line 1265
    if (j >= 0) {
      {
#line 1266
      tmp___1 = atol((char const   *)(buf + j));
#line 1266
      ps->xref_offset = (unsigned long )tmp___1;
      }
    } else {
#line 1268
      code = -1;
    }
#line 1269
    i = j;
#line 1270
    if (ps->xref_offset == 0UL) {
#line 1271
      code = -1;
    }
#line 1272
    if (code != 0) {
      {
#line 1273
      pdf_scan_msgf(ps, "Failed to find cross reference table\n");
      }
    }
  }
#line 1276
  if (code == 0) {
    {
#line 1278
    j = previous_line((char const   *)(buf), i);
    }
#line 1279
    if (j >= 0) {
      {
#line 1280
      tmp___2 = memcmp((void const   *)(buf + j), (void const   *)"startxref", (size_t )9);
      }
#line 1280
      if (tmp___2 != 0) {
#line 1281
        code = -1;
      }
    } else {
#line 1284
      code = -1;
    }
#line 1286
    if (code != 0) {
      {
#line 1287
      pdf_scan_msgf(ps, "Failed to find startxref\n");
      }
    }
  }
#line 1289
  return (code);
}
}
#line 1294 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/cpdfscan.c"
static int pdf_scan_read_xref(PDFSCAN *ps , unsigned long xref_offset ) 
{ 
  int code ;
  int i ;
  int first ;
  int count ;
  unsigned long prev ;
  unsigned long offset ;
  int generation ;
  BOOL used ;
  BOOL tmp ;
  int len ;
  PDFXREF *newxref ;
  void *tmp___0 ;
  long tmp___1 ;
  BOOL tmp___2 ;
  BOOL tmp___3 ;

  {
  {
#line 1299
  first = 0;
#line 1300
  count = 0;
#line 1301
  prev = 0UL;
#line 1302
  offset = 0UL;
#line 1303
  generation = 0;
#line 1304
  used = 0;
#line 1305
  pdf_scan_seek(ps, (long )xref_offset, (PDFSEEK )2);
#line 1306
  code = pdf_scan_next_token(ps);
  }
#line 1307
  if (code == 0) {
    {
#line 1308
    code = op_check(ps, "xref");
    }
  }
  {
#line 1309
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1309
    if (! (code == 0)) {
#line 1309
      goto while_break;
    }
    {
#line 1310
    code = pdf_scan_next_token(ps);
    }
#line 1311
    if (code == 0) {
      {
#line 1311
      tmp = is_optoken(ps, "trailer");
      }
#line 1311
      if (tmp) {
#line 1312
        goto while_break;
      }
    }
#line 1313
    if (code == 0) {
      {
#line 1314
      first = atoi((char const   *)(ps->buf + ps->begin));
#line 1315
      code = pdf_scan_next_token(ps);
      }
    }
#line 1317
    if (code == 0) {
      {
#line 1318
      count = atoi((char const   *)(ps->buf + ps->begin));
      }
    }
#line 1320
    if (code == 0) {
#line 1322
      if (first + count > ps->xref_len) {
        {
#line 1323
        len = (int )((unsigned long )(first + count) * sizeof(PDFXREF ));
#line 1324
        tmp___0 = malloc((size_t )len);
#line 1324
        newxref = (PDFXREF *)tmp___0;
        }
#line 1325
        if (newxref) {
          {
#line 1326
          memset((void *)newxref, 0, (size_t )len);
#line 1327
          memcpy((void */* __restrict  */)newxref, (void const   */* __restrict  */)ps->xref,
                 (unsigned long )ps->xref_len * sizeof(PDFXREF ));
#line 1328
          free((void *)ps->xref);
#line 1329
          ps->xref = newxref;
#line 1330
          ps->xref_len = first + count;
          }
        } else {
          {
#line 1333
          pdf_scan_msgf(ps, "pdf_scan_read_xref: out of memory\n");
#line 1334
          code = -2;
          }
#line 1335
          goto while_break;
        }
      }
    }
#line 1339
    i = first;
    {
#line 1339
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1339
      if (! (i < first + count)) {
#line 1339
        goto while_break___0;
      }
      {
#line 1340
      code = pdf_scan_next_token(ps);
      }
#line 1341
      if (code == 0) {
        {
#line 1342
        tmp___1 = atol((char const   *)(ps->buf + ps->begin));
#line 1342
        offset = (unsigned long )tmp___1;
#line 1343
        code = pdf_scan_next_token(ps);
        }
      }
#line 1345
      if (code == 0) {
        {
#line 1346
        generation = atoi((char const   *)(ps->buf + ps->begin));
#line 1347
        code = pdf_scan_next_token(ps);
        }
      }
#line 1349
      if (code == 0) {
        {
#line 1350
        tmp___3 = is_optoken(ps, "n");
        }
#line 1350
        if (tmp___3) {
#line 1351
          used = 1;
        } else {
          {
#line 1352
          tmp___2 = is_optoken(ps, "f");
          }
#line 1352
          if (tmp___2) {
#line 1353
            used = 0;
          } else {
#line 1355
            code = -1;
          }
        }
      }
#line 1361
      if (code == 0) {
#line 1362
        if (! (ps->xref + i)->used) {
#line 1363
          (ps->xref + i)->offset = offset;
#line 1364
          (ps->xref + i)->generation = generation;
#line 1365
          (ps->xref + i)->used = used;
        }
      }
#line 1339
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1371
  if (code == 0) {
    {
#line 1372
    code = pdf_scan_read_trailer(ps, & prev);
    }
#line 1373
    if (code == 0) {
#line 1373
      if (prev) {
#line 1373
        if (prev != ps->xref_offset) {
          {
#line 1375
          code = pdf_scan_read_xref(ps, prev);
          }
        }
      }
    }
  }
#line 1379
  return (code);
}
}
#line 1383 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/cpdfscan.c"
static int pdf_scan_read_trailer(PDFSCAN *ps , unsigned long *prev ) 
{ 
  int code ;
  ref p ;
  BOOL tmp ;
  int tmp___0 ;

  {
  {
#line 1386
  code = 0;
#line 1388
  code = pdf_scan_next_token(ps);
  }
#line 1389
  if (code == 0) {
#line 1389
    if ((unsigned int )ps->token_type != 1U) {
#line 1390
      code = -1;
    }
  }
  {
#line 1391
  push_token(ps);
  }
  {
#line 1392
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1392
    if (! (code == 0)) {
#line 1392
      goto while_break;
    }
    {
#line 1393
    code = pdf_scan_next_token(ps);
    }
#line 1394
    if (code != 0) {
#line 1395
      goto while_break;
    }
    {
#line 1396
    tmp = is_optoken(ps, "startxref");
    }
#line 1396
    if (tmp) {
#line 1397
      if (ps->root == 0) {
        {
#line 1398
        p = dict_get(ps, "Root");
        }
#line 1399
        if ((unsigned int )p.type == 12U) {
#line 1400
          ps->root = p.value.objval;
        } else {
          {
#line 1402
          pdf_scan_msgf(ps, "trailer /Root requires indirect reference\n");
#line 1404
          code = -1;
          }
        }
      }
      {
#line 1407
      p = dict_get(ps, "Prev");
      }
#line 1408
      if ((unsigned int )p.type == 4U) {
#line 1409
        *prev = (unsigned long )p.value.intval;
      } else
#line 1410
      if ((unsigned int )p.type != 0U) {
        {
#line 1411
        code = -1;
#line 1412
        pdf_scan_msgf(ps, "trailer /Prev requires integer\n");
        }
      }
#line 1414
      goto while_break;
    }
    {
#line 1416
    tmp___0 = process_op(ps);
    }
#line 1416
    if (tmp___0 != 0) {
      {
#line 1417
      push_token(ps);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1419
  if (code != 0) {
    {
#line 1420
    pdf_scan_msgf(ps, "Error reading trailer\n");
    }
  }
#line 1421
  return (code);
}
}
#line 1425 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/cpdfscan.c"
static int pdf_scan_read_object_start(PDFSCAN *ps , int objnum ) 
{ 
  int code ;
  int value ;

  {
#line 1427
  code = 0;
#line 1428
  value = 0;
#line 1429
  if (objnum == 0) {
    {
#line 1430
    pdf_scan_msgf(ps, "Object 0 is always unused\n");
    }
#line 1431
    return (-1);
  }
#line 1433
  if (objnum >= ps->xref_len) {
    {
#line 1434
    pdf_scan_msgf(ps, "Object reference %d doesn\'t exist.  There are only %d objects\n",
                  objnum, ps->xref_len);
    }
#line 1435
    return (-1);
  }
#line 1437
  if (! (ps->xref + objnum)->used) {
    {
#line 1438
    pdf_scan_msgf(ps, "Object %d is unused\n", objnum);
    }
#line 1439
    return (-1);
  }
  {
#line 1441
  pdf_scan_seek(ps, (long )(ps->xref + objnum)->offset, (PDFSEEK )2);
#line 1443
  code = pdf_scan_next_token(ps);
  }
#line 1444
  if (code == 0) {
    {
#line 1445
    code = type_check(ps, (rtype )4);
    }
  }
#line 1446
  if (code == 0) {
    {
#line 1447
    value = atoi((char const   *)(ps->buf + ps->begin));
#line 1448
    code = pdf_scan_next_token(ps);
    }
  }
#line 1450
  if (code == 0) {
    {
#line 1451
    code = type_check(ps, (rtype )4);
    }
  }
#line 1452
  if (code == 0) {
    {
#line 1453
    code = pdf_scan_next_token(ps);
    }
  }
#line 1454
  if (code == 0) {
    {
#line 1455
    code = op_check(ps, "obj");
    }
  }
#line 1457
  if (value != objnum) {
    {
#line 1458
    pdf_scan_msgf(ps, "Didn\'t find object %d\n", objnum);
    }
#line 1459
    return (-1);
  }
#line 1461
  return (code);
}
}
#line 1467 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/cpdfscan.c"
static int pdf_scan_read_object(PDFSCAN *ps , int objnum ) 
{ 
  int code ;
  ref objref ;
  ref tmp ;
  ref tmp___0 ;
  BOOL tmp___1 ;
  int tmp___2 ;

  {
  {
#line 1471
  tmp = obj_find(ps, objnum);
#line 1471
  objref = tmp;
  }
#line 1473
  if ((unsigned int )objref.type != 0U) {
    {
#line 1475
    push_stack(ps, objref);
    }
#line 1476
    return (0);
  }
  {
#line 1479
  code = pdf_scan_read_object_start(ps, objnum);
  }
#line 1480
  if (code) {
    {
#line 1481
    pdf_scan_msgf(ps, "Didn\'t find object %d\n", objnum);
    }
#line 1482
    return (-1);
  }
  {
#line 1485
  code = pdf_scan_next_token(ps);
  }
#line 1486
  if (code == 0) {
#line 1486
    if ((unsigned int )ps->token_type != 1U) {
#line 1487
      code = -1;
    }
  }
  {
#line 1488
  push_token(ps);
  }
  {
#line 1489
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1489
    if (! (code == 0)) {
#line 1489
      goto while_break;
    }
    {
#line 1490
    code = pdf_scan_next_token(ps);
    }
#line 1491
    if (code != 0) {
#line 1492
      goto while_break;
    }
    {
#line 1493
    tmp___1 = is_optoken(ps, "endobj");
    }
#line 1493
    if (tmp___1) {
      {
#line 1494
      tmp___0 = top_stack(ps);
#line 1494
      obj_add(ps, objnum, tmp___0);
      }
#line 1495
      goto while_break;
    }
    {
#line 1497
    tmp___2 = process_op(ps);
    }
#line 1497
    if (tmp___2 != 0) {
      {
#line 1498
      push_token(ps);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1500
  return (code);
}
}
#line 1508 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/cpdfscan.c"
static int pdf_scan_find_page(PDFSCAN *ps , int pagenum ) 
{ 
  int code ;
  ref kids ;
  ref r ;
  int pageobj ;
  int count_base ;
  int count ;
  ref *pref ;
  int i ;
  int inext ;
  BOOL tmp ;
  BOOL tmp___0 ;

  {
#line 1513
  pageobj = 0;
#line 1514
  count_base = 0;
#line 1520
  if (pagenum >= ps->page_count) {
    {
#line 1521
    pdf_scan_msgf(ps, "Not that many pages\n");
    }
#line 1522
    return (-1);
  }
  {
#line 1524
  code = pdf_scan_read_object(ps, ps->pages);
  }
#line 1525
  if (code) {
    {
#line 1526
    pdf_scan_msgf(ps, "Didn\'t find Pages object\n");
    }
#line 1527
    return (-1);
  }
  {
#line 1530
  kids = dict_get(ps, "Kids");
  }
#line 1531
  if ((unsigned int )kids.type != 8U) {
    {
#line 1532
    pdf_scan_msgf(ps, "/Pages object %d must contain /Kids array\n", ps->pages);
    }
#line 1534
    return (-1);
  }
  {
#line 1536
  pop_stack(ps);
#line 1537
  i = 0;
  }
  {
#line 1537
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1537
    if (i < kids.rsize) {
#line 1537
      if (! (code == 0)) {
#line 1537
        goto while_break;
      }
    } else {
#line 1537
      goto while_break;
    }
#line 1538
    inext = i + 1;
#line 1539
    pref = kids.value.arrayval + i;
#line 1540
    if ((unsigned int )pref->type == 12U) {
      {
#line 1541
      code = pdf_scan_read_object(ps, pref->value.objval);
      }
    }
#line 1542
    if (code == 0) {
      {
#line 1543
      r = dict_get(ps, "Type");
#line 1544
      tmp___0 = nameref_equals(& r, "Page");
      }
#line 1544
      if (tmp___0) {
#line 1545
        if (count_base + i == pagenum) {
          {
#line 1547
          pageobj = pref->value.objval;
#line 1548
          pop_stack(ps);
          }
#line 1549
          goto while_break;
        }
      } else {
        {
#line 1552
        tmp = nameref_equals(& r, "Pages");
        }
#line 1552
        if (tmp) {
          {
#line 1553
          r = dict_get(ps, "Count");
          }
#line 1554
          if ((unsigned int )r.type == 4U) {
#line 1555
            count = r.value.intval;
#line 1556
            if (pagenum < count_base + count) {
              {
#line 1558
              inext = 0;
#line 1559
              pop_stack(ps);
#line 1560
              code = pdf_scan_read_object(ps, pref->value.objval);
              }
#line 1561
              if (code == 0) {
                {
#line 1562
                kids = dict_get(ps, "Kids");
                }
#line 1563
                if ((unsigned int )kids.type != 8U) {
                  {
#line 1564
                  pdf_scan_msgf(ps, "/Pages object %d must contain /Kids array\n",
                                pref->value.objval);
#line 1567
                  code = -1;
                  }
                }
              }
            } else {
#line 1572
              count_base += count;
            }
          } else {
            {
#line 1576
            pdf_scan_msgf(ps, "/Pages /Count must be integer\n");
#line 1577
            code = -1;
            }
          }
        } else {
          {
#line 1581
          pdf_scan_msgf(ps, "pdf_scan_find_page: object %d isn\'t Pages or Page\n",
                        pref->value.objval);
#line 1584
          code = -1;
          }
        }
      }
      {
#line 1586
      pop_stack(ps);
      }
    }
#line 1537
    i = inext;
  }
  while_break: /* CIL Label */ ;
  }
#line 1590
  if (pageobj <= 0) {
    {
#line 1591
    pdf_scan_msgf(ps, "Failed to find page %d\n", pagenum + 1);
#line 1592
    code = -1;
    }
  }
#line 1595
  if (code) {
#line 1596
    return (-1);
  }
#line 1602
  return (pageobj);
}
}
#line 1606 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/cpdfscan.c"
static int pdf_scan_read_page_count(PDFSCAN *ps ) 
{ 
  int code ;
  ref p ;
  BOOL tmp ;

  {
  {
#line 1611
  code = pdf_scan_read_object(ps, ps->pages);
  }
#line 1612
  if (code) {
    {
#line 1613
    pdf_scan_msgf(ps, "Didn\'t find Pages object\n");
    }
#line 1614
    return (-1);
  }
  {
#line 1617
  p = dict_get(ps, "Type");
#line 1618
  tmp = nameref_equals(& p, "Pages");
  }
#line 1618
  if (! tmp) {
    {
#line 1619
    pdf_scan_msgf(ps, "Pages object didn\'t have /Type /Pages\n");
    }
#line 1620
    return (-1);
  }
  {
#line 1622
  p = dict_get(ps, "Count");
  }
#line 1623
  if ((unsigned int )p.type != 4U) {
    {
#line 1624
    pdf_scan_msgf(ps, "Pages object didn\'t integer /Count\n");
    }
#line 1625
    return (-1);
  }
#line 1627
  ps->page_count = p.value.intval;
#line 1629
  return (code);
}
}
#line 1632 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/cpdfscan.c"
static int convert_float(ref r , float *f ) 
{ 


  {
#line 1634
  if ((unsigned int )r.type == 5U) {
#line 1635
    *f = r.value.realval;
  } else
#line 1636
  if ((unsigned int )r.type == 4U) {
#line 1637
    *f = (float )r.value.intval;
  } else {
#line 1639
    return (-1);
  }
#line 1640
  return (0);
}
}
#line 1643 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/cpdfscan.c"
static int pdf_scan_read_bbox(PDFBBOX *box , ref array ) 
{ 
  int code ;

  {
#line 1646
  code = 0;
#line 1647
  if ((unsigned int )array.type != 8U) {
#line 1648
    code = -1;
  }
#line 1649
  if (array.rsize != 4) {
#line 1650
    code = -1;
  }
#line 1651
  if (code == 0) {
    {
#line 1652
    code = convert_float(*(array.value.arrayval + 0), & box->llx);
    }
  }
#line 1653
  if (code == 0) {
    {
#line 1654
    code = convert_float(*(array.value.arrayval + 1), & box->lly);
    }
  }
#line 1655
  if (code == 0) {
    {
#line 1656
    code = convert_float(*(array.value.arrayval + 2), & box->urx);
    }
  }
#line 1657
  if (code == 0) {
    {
#line 1658
    code = convert_float(*(array.value.arrayval + 3), & box->ury);
    }
  }
#line 1659
  return (code);
}
}
#line 1663 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/cpdfscan.c"
static int pdf_scan_read_catalog(PDFSCAN *ps ) 
{ 
  int code ;
  ref p ;
  BOOL tmp ;

  {
  {
#line 1671
  code = pdf_scan_read_object(ps, ps->root);
  }
#line 1672
  if (code) {
    {
#line 1673
    pdf_scan_msgf(ps, "Didn\'t find Root object\n");
    }
#line 1674
    return (-1);
  }
  {
#line 1677
  p = dict_get(ps, "Type");
#line 1678
  tmp = nameref_equals(& p, "Catalog");
  }
#line 1678
  if (! tmp) {
    {
#line 1679
    pdf_scan_msgf(ps, "Root object didn\'t have /Type /Catalog\n");
    }
#line 1680
    return (-1);
  }
  {
#line 1682
  p = dict_get(ps, "Pages");
  }
#line 1683
  if ((unsigned int )p.type != 12U) {
    {
#line 1684
    pdf_scan_msgf(ps, "Root object didn\'t indirect reference to /Pages\n");
    }
#line 1685
    return (-1);
  }
#line 1687
  ps->pages = p.value.intval;
#line 1688
  return (0);
}
}
#line 1695 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/cpdfscan.c"
void pdf_scan_close(PDFSCAN *ps ) 
{ 


  {
  {
#line 1698
  pdf_scan_cleanup(ps);
#line 1699
  pdf_scan_finish(ps);
#line 1700
  free((void *)ps);
  }
#line 1701
  return;
}
}
#line 1704 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/cpdfscan.c"
PDFSCAN *pdf_scan_open(char const   *filename , void *handle , int (*fn)(void *handle ,
                                                                         char const   *ptr ,
                                                                         int len ) ) 
{ 
  int code ;
  int rotate ;
  PDFBBOX mediabox ;
  PDFBBOX cropbox ;
  PDFSCAN *ps ;
  void *tmp ;

  {
  {
#line 1711
  tmp = malloc(sizeof(PDFSCAN ));
#line 1711
  ps = (PDFSCAN *)tmp;
  }
#line 1712
  if ((unsigned long )ps == (unsigned long )((void *)0)) {
#line 1713
    return ((PDFSCAN *)((void *)0));
  }
  {
#line 1714
  memset((void *)ps, 0, sizeof(PDFSCAN ));
#line 1715
  ps->handle = handle;
#line 1716
  ps->print_fn = fn;
#line 1717
  code = pdf_scan_init(ps, filename);
  }
#line 1718
  if (code == -1) {
    {
#line 1719
    pdf_scan_msgf(ps, "Couldn\'t open PDF file\n");
    }
  } else
#line 1720
  if (code != 0) {
    {
#line 1721
    pdf_scan_msgf(ps, "Error initialising PDF scanner\n");
    }
  }
#line 1723
  if (code == 0) {
    {
#line 1724
    code = pdf_scan_find_xref(ps);
    }
  }
#line 1725
  if (code == 0) {
    {
#line 1726
    code = pdf_scan_read_xref(ps, ps->xref_offset);
    }
  }
#line 1727
  if (code == 0) {
    {
#line 1728
    code = pdf_scan_read_catalog(ps);
    }
  }
#line 1729
  if (code == 0) {
    {
#line 1730
    code = pdf_scan_read_page_count(ps);
    }
  }
#line 1731
  if (code == 0) {
    {
#line 1732
    code = pdf_scan_page_media(ps, 0, & rotate, & mediabox, & cropbox);
    }
  }
  {
#line 1734
  pdf_scan_cleanup(ps);
  }
#line 1735
  if (code != 0) {
    {
#line 1736
    pdf_scan_close(ps);
#line 1737
    ps = (PDFSCAN *)((void *)0);
    }
  }
#line 1739
  return (ps);
}
}
#line 1742 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/cpdfscan.c"
int pdf_scan_page_count(PDFSCAN *ps ) 
{ 


  {
#line 1745
  if ((unsigned long )ps == (unsigned long )((void *)0)) {
#line 1746
    return (0);
  }
#line 1747
  return (ps->page_count);
}
}
#line 1750 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/cpdfscan.c"
int pdf_scan_page_media(PDFSCAN *ps , int pagenum , int *rotate , PDFBBOX *mediabox ,
                        PDFBBOX *cropbox ) 
{ 
  BOOL found_rotate ;
  BOOL found_mediabox ;
  BOOL found_cropbox ;
  BOOL has_parent ;
  ref p ;
  ref objref ;
  int objnum ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 1754
  found_rotate = 0;
#line 1755
  found_mediabox = 0;
#line 1756
  found_cropbox = 0;
#line 1757
  has_parent = 1;
#line 1761
  if ((unsigned long )ps == (unsigned long )((void *)0)) {
#line 1762
    return (-1);
  }
#line 1764
  if (pagenum == ps->pagenum) {
#line 1766
    *rotate = ps->rotate;
#line 1767
    *mediabox = ps->mediabox;
#line 1768
    *cropbox = ps->cropbox;
#line 1769
    return (0);
  }
#line 1772
  if ((unsigned long )ps->file == (unsigned long )((void *)0)) {
    {
#line 1773
    tmp = pdf_scan_open_file(ps);
    }
#line 1773
    if (tmp != 0) {
#line 1774
      return (-1);
    }
  }
  {
#line 1776
  objnum = pdf_scan_find_page(ps, pagenum);
  }
#line 1777
  if (objnum <= 0) {
    {
#line 1778
    pdf_scan_cleanup(ps);
    }
#line 1779
    return (-1);
  }
  {
#line 1781
  tmp___0 = pdf_scan_read_object(ps, objnum);
  }
#line 1781
  if (tmp___0 < 0) {
    {
#line 1782
    pdf_scan_cleanup(ps);
    }
#line 1783
    return (-1);
  }
  {
#line 1786
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1786
    if (! has_parent) {
#line 1786
      goto while_break;
    }
#line 1787
    if (! found_rotate) {
      {
#line 1788
      p = dict_get(ps, "Rotate");
      }
#line 1789
      if ((unsigned int )p.type == 4U) {
#line 1790
        *rotate = p.value.intval;
#line 1791
        found_rotate = 1;
      }
    }
#line 1794
    if (! found_mediabox) {
      {
#line 1795
      p = dict_get(ps, "MediaBox");
#line 1796
      tmp___1 = pdf_scan_read_bbox(mediabox, p);
      }
#line 1796
      if (tmp___1 == 0) {
#line 1797
        found_mediabox = 1;
      }
    }
#line 1799
    if (! found_cropbox) {
      {
#line 1800
      p = dict_get(ps, "CropBox");
#line 1801
      tmp___2 = pdf_scan_read_bbox(cropbox, p);
      }
#line 1801
      if (tmp___2 == 0) {
#line 1802
        found_cropbox = 1;
      }
    }
#line 1804
    if (found_rotate) {
#line 1804
      if (found_mediabox) {
#line 1804
        if (found_cropbox) {
#line 1805
          goto while_break;
        }
      }
    }
    {
#line 1807
    p = dict_get(ps, "Parent");
    }
#line 1808
    if ((unsigned int )p.type == 12U) {
      {
#line 1809
      objref = pop_stack(ps);
#line 1810
      tmp___3 = pdf_scan_read_object(ps, p.value.objval);
      }
#line 1810
      if (tmp___3 < 0) {
        {
#line 1811
        push_stack(ps, objref);
#line 1812
        has_parent = 0;
        }
      }
    } else {
#line 1816
      has_parent = 0;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1818
  pop_stack(ps);
  }
#line 1819
  if (! found_cropbox) {
#line 1820
    *cropbox = *mediabox;
#line 1821
    found_cropbox = 1;
  }
#line 1823
  if (! found_rotate) {
#line 1824
    *rotate = 0;
#line 1825
    found_rotate = 1;
  }
  {
#line 1828
  pdf_scan_cleanup(ps);
  }
#line 1830
  if (found_rotate) {
#line 1830
    if (found_mediabox) {
#line 1830
      if (found_cropbox) {
#line 1832
        ps->pagenum = pagenum;
#line 1833
        ps->rotate = *rotate;
#line 1834
        ps->mediabox = *mediabox;
#line 1835
        ps->cropbox = *cropbox;
#line 1836
        return (0);
      }
    }
  }
#line 1839
  return (-1);
}
}
#line 386 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int ( /* format attribute */  snprintf)(char * __restrict  __s ,
                                                                             size_t __maxlen ,
                                                                             char const   * __restrict  __format 
                                                                             , ...) ;
#line 147 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strncmp)(char const   *__s1 ,
                                                                                                char const   *__s2 ,
                                                                                                size_t __n )  __attribute__((__pure__)) ;
#line 826 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) unlink)(char const   *__name ) ;
#line 68 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/cfile.h"
GFile *gfile_open(char const   *lpszFileName , unsigned int nOpenFlags ) ;
#line 71
void gfile_close(GFile *gf ) ;
#line 74
unsigned int gfile_read(GFile *gf , void *lpBuf , unsigned int nCount ) ;
#line 77
unsigned int gfile_write(GFile *gf , void const   *lpBuf , unsigned int nCount ) ;
#line 81
int gfile_seek(GFile *gf , long lOff , unsigned int nFrom ) ;
#line 84
unsigned long gfile_get_position(GFile *gf ) ;
#line 87
unsigned long gfile_get_length(GFile *gf ) ;
#line 166 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/common.h"
int debug ;
#line 76 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/capp.h"
int app_msg(GSview *a , char const   *str ) ;
#line 80
int app_csmsg(GSview *a , char const   *wstr ) ;
#line 57 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/cdoc.h"
DocType doc_type(Doc *doc ) ;
#line 63
int doc_map_page(Doc *doc , int page ) ;
#line 65
char const   *doc_name(Doc *doc ) ;
#line 25 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/cps.c"
int ps_extract(Doc *doc , char const   *filename , PAGELIST *pagelist , int copies ) ;
#line 26
int ps_copy(GFile *outfile , GFile *infile , long begin , long end ) ;
#line 27
int ps_fgets(char *s , int n , GFile *f ) ;
#line 29 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/cps.c"
static int ps_writestring(GFile *f , char const   *str ) 
{ 
  size_t tmp ;
  unsigned int tmp___0 ;

  {
  {
#line 31
  tmp = strlen(str);
#line 31
  tmp___0 = gfile_write(f, (void const   *)str, (unsigned int )((int )tmp));
  }
#line 31
  return ((int )tmp___0);
}
}
#line 40 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/cps.c"
int ps_fgets(char *s , int n , GFile *f ) 
{ 
  char ch ;
  int not_eof ;
  char *p ;
  int count ;
  char *tmp ;
  unsigned int tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  unsigned int tmp___3 ;
  char *tmp___4 ;

  {
#line 42
  ch = (char )'\000';
#line 43
  not_eof = 0;
#line 44
  p = s;
#line 45
  count = 0;
  {
#line 47
  while (1) {
    while_continue: /* CIL Label */ ;
#line 47
    if (count < n) {
      {
#line 47
      tmp___0 = gfile_read(f, (void *)(& ch), 1U);
#line 47
      not_eof = (int )tmp___0;
      }
#line 47
      if (not_eof != 0) {
#line 47
        if ((int )ch != 13) {
#line 47
          if (! ((int )ch != 10)) {
#line 47
            goto while_break;
          }
        } else {
#line 47
          goto while_break;
        }
      } else {
#line 47
        goto while_break;
      }
    } else {
#line 47
      goto while_break;
    }
#line 49
    tmp = p;
#line 49
    p ++;
#line 49
    *tmp = ch;
#line 50
    count ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 53
  if (count < n) {
#line 53
    if (not_eof) {
#line 55
      if ((int )ch == 13) {
#line 56
        tmp___1 = p;
#line 56
        p ++;
#line 56
        *tmp___1 = ch;
#line 57
        count ++;
#line 59
        if (count < n) {
          {
#line 59
          tmp___3 = gfile_read(f, (void *)(& ch), 1U);
#line 59
          not_eof = (int )tmp___3;
          }
#line 59
          if (not_eof != 0) {
#line 60
            if ((int )ch == 10) {
#line 62
              tmp___2 = p;
#line 62
              p ++;
#line 62
              *tmp___2 = ch;
#line 63
              count ++;
            } else {
              {
#line 67
              gfile_seek(f, -1L, 1U);
              }
            }
          }
        }
      } else {
#line 73
        tmp___4 = p;
#line 73
        p ++;
#line 73
        *tmp___4 = ch;
#line 74
        count ++;
      }
    }
  }
#line 77
  if (count < n) {
#line 78
    *p = (char )'\000';
  }
#line 80
  if (! not_eof) {
#line 80
    if ((unsigned long )p == (unsigned long )s) {
#line 81
      return (0);
    }
  }
#line 82
  return (count);
}
}
#line 87 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/cps.c"
static void ps_num_copies(GFile *f , int copies ) 
{ 
  char buf[256] ;

  {
#line 91
  if (copies >= 1) {
    {
#line 92
    snprintf((char */* __restrict  */)(buf), sizeof(buf) - 1UL, (char const   */* __restrict  */)"[{\n%%%%BeginFeature: *NumCopies %d\n",
             copies);
#line 94
    ps_writestring(f, (char const   *)(buf));
#line 95
    snprintf((char */* __restrict  */)(buf), sizeof(buf) - 1UL, (char const   */* __restrict  */)"<< /NumCopies %d >> setpagedevice\n",
             copies);
#line 97
    ps_writestring(f, (char const   *)(buf));
#line 98
    ps_writestring(f, "%%%%EndFeature\n} stopped cleartomark\n");
    }
  }
#line 100
  return;
}
}
#line 106 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/cps.c"
static BOOL ps_copy_find(GFile *outfile , GFile *infile , long end , char *s , int n ,
                         char const   *comment ) 
{ 
  int count ;
  int remain ;
  size_t tmp ;
  int tmp___0 ;
  unsigned long tmp___1 ;
  int tmp___2 ;

  {
  {
#line 112
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 112
    tmp___1 = gfile_get_position(infile);
#line 112
    remain = (int )((unsigned long )end - tmp___1);
    }
#line 112
    if (remain > 0) {
#line 112
      if (n - 1 < remain) {
#line 112
        tmp___2 = n - 1;
      } else {
#line 112
        tmp___2 = remain;
      }
      {
#line 112
      count = ps_fgets(s, tmp___2, infile);
      }
#line 112
      if (! (count != 0)) {
#line 112
        goto while_break;
      }
    } else {
#line 112
      goto while_break;
    }
    {
#line 114
    *(s + (n - 1)) = (char )'\000';
#line 115
    tmp = strlen(comment);
#line 115
    tmp___0 = strncmp((char const   *)s, comment, tmp);
    }
#line 115
    if (tmp___0 == 0) {
#line 116
      return (1);
    }
    {
#line 117
    gfile_write(outfile, (void const   *)s, (unsigned int )count);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 119
  return (0);
}
}
#line 122 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/cps.c"
int ps_copy(GFile *outfile , GFile *infile , long begin , long end ) 
{ 
  char *buf ;
  int count ;
  void *tmp ;
  unsigned long tmp___0 ;
  long tmp___1 ;
  unsigned int tmp___2 ;

  {
  {
#line 126
  count = 0;
#line 127
  tmp = malloc((size_t )4096);
#line 127
  buf = (char *)tmp;
  }
#line 128
  if ((unsigned long )buf == (unsigned long )((char *)((void *)0))) {
#line 129
    return (-1);
  }
#line 130
  if (begin >= 0L) {
    {
#line 131
    gfile_seek(infile, begin, 0U);
    }
  }
  {
#line 132
  tmp___0 = gfile_get_position(infile);
#line 132
  begin = (long )tmp___0;
  }
  {
#line 133
  while (1) {
    while_continue: /* CIL Label */ ;
#line 133
    if (! (begin < end)) {
#line 133
      goto while_break;
    }
#line 134
    if (end - begin < 4096L) {
#line 134
      tmp___1 = end - begin;
    } else {
#line 134
      tmp___1 = 4096L;
    }
    {
#line 134
    count = (int )tmp___1;
#line 135
    tmp___2 = gfile_read(infile, (void *)buf, (unsigned int )count);
#line 135
    count = (int )tmp___2;
    }
#line 135
    if (count > 0) {
      {
#line 136
      gfile_write(outfile, (void const   *)buf, (unsigned int )count);
#line 137
      begin += (long )count;
      }
    } else {
#line 140
      begin = end;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 142
  free((void *)buf);
  }
#line 143
  return (count);
}
}
#line 146 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/cps.c"
static int ps_copy_setup(GFile *outfile , GFile *infile , long begin , long end ,
                         int copies ) 
{ 
  char line[256] ;
  BOOL found ;
  int code ;

  {
#line 152
  code = 0;
#line 153
  if (copies > 1) {
#line 154
    if (begin != end) {
      {
#line 155
      gfile_seek(infile, begin, 0U);
#line 157
      found = ps_copy_find(outfile, infile, end, line, (int )(sizeof(line) - 1UL),
                           "%%EndSetup");
#line 160
      ps_num_copies(outfile, copies);
      }
#line 162
      if (found) {
        {
#line 163
        ps_writestring(outfile, (char const   *)(line));
        }
      }
      {
#line 164
      code = ps_copy(outfile, infile, -1L, end);
      }
    } else {
      {
#line 168
      ps_writestring(outfile, "%%BeginSetup\n");
#line 169
      ps_num_copies(outfile, copies);
#line 170
      ps_writestring(outfile, "%%EndSetup\n");
      }
    }
  } else {
    {
#line 174
    code = ps_copy(outfile, infile, begin, end);
    }
  }
#line 175
  return (code);
}
}
#line 181 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/cps.c"
static int ps_extract_pages(Doc *doc , GFile *infile , GFile *outfile , PAGELIST *pagelist ,
                            int copies ) 
{ 
  int i ;
  int pages ;
  int neworder ;
  BOOL reverse ;
  unsigned long position ;
  char line[256] ;
  char buf[256] ;
  BOOL end_header ;
  BOOL line_written ;
  BOOL pages_written ;
  BOOL pageorder_written ;
  CDSC *dsc ;
  int page ;
  int count ;
  int tmp ;
  unsigned long tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  unsigned long tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;

  {
#line 186
  pages = 0;
#line 194
  pages_written = 0;
#line 195
  pageorder_written = 0;
#line 196
  dsc = doc->dsc;
#line 200
  if ((unsigned long )dsc == (unsigned long )((void *)0)) {
#line 201
    return (-1);
  }
#line 202
  if (pagelist->page_count == 0) {
#line 203
    return (-1);
  } else
#line 202
  if ((unsigned long )pagelist->select == (unsigned long )((void *)0)) {
#line 203
    return (-1);
  }
#line 204
  if (pagelist->page_count != (int )dsc->page_count) {
#line 205
    return (-1);
  }
#line 206
  i = 0;
  {
#line 206
  while (1) {
    while_continue: /* CIL Label */ ;
#line 206
    if (! (i < pagelist->page_count)) {
#line 206
      goto while_break;
    }
#line 207
    if (*(pagelist->select + i)) {
#line 208
      pages ++;
    }
#line 206
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 213
  neworder = (int )dsc->page_order;
#line 214
  reverse = 0;
#line 215
  if (neworder == 0) {
#line 216
    neworder = 1;
  }
#line 218
  if (pagelist->reverse) {
#line 220
    if (neworder == 1) {
#line 221
      neworder = 2;
    } else
#line 222
    if (neworder == 2) {
#line 224
      reverse = 0;
    }
  } else
#line 228
  if (neworder == 2) {
#line 229
    neworder = 1;
#line 230
    reverse = 1;
  }
  {
#line 238
  tmp = gfile_seek(infile, (long )dsc->begincomments, 0U);
#line 238
  position = (unsigned long )tmp;
  }
  {
#line 239
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 239
    if (! (position < dsc->endcomments)) {
#line 239
      goto while_break___0;
    }
#line 240
    if (sizeof(line) < dsc->endcomments - position) {
#line 240
      tmp___0 = sizeof(line);
    } else {
#line 240
      tmp___0 = dsc->endcomments - position;
    }
    {
#line 240
    tmp___1 = ps_fgets(line, (int )tmp___0, infile);
    }
#line 240
    if (tmp___1 == 0) {
#line 242
      return (0);
    }
    {
#line 243
    position = gfile_get_position(infile);
#line 244
    tmp___2 = strncmp((char const   *)(line), "%%EndComments", (size_t )13);
#line 244
    end_header = tmp___2 == 0;
    }
#line 245
    if ((int )line[0] != 37) {
#line 245
      if ((int )line[0] != 32) {
#line 245
        if ((int )line[0] != 43) {
#line 245
          if ((int )line[0] != 9) {
#line 245
            if ((int )line[0] != 13) {
#line 245
              if ((int )line[0] != 10) {
#line 247
                end_header = 1;
              }
            }
          }
        }
      }
    }
#line 248
    line_written = 0;
#line 249
    if (end_header) {
#line 249
      goto _L;
    } else {
      {
#line 249
      tmp___3 = strncmp((char const   *)(line), "%%Pages:", (size_t )8);
      }
#line 249
      if (tmp___3 == 0) {
        _L: /* CIL Label */ 
#line 250
        if (! pages_written) {
          {
#line 251
          snprintf((char */* __restrict  */)(buf), sizeof(buf) - 1UL, (char const   */* __restrict  */)"%%%%Pages: %d\r\n",
                   pages);
#line 252
          ps_writestring(outfile, (char const   *)(buf));
#line 253
          pages_written = 1;
          }
        }
#line 255
        line_written = ! end_header;
      }
    }
#line 257
    if (end_header) {
#line 257
      goto _L___0;
    } else {
      {
#line 257
      tmp___4 = strncmp((char const   *)(line), "%%PageOrder:", (size_t )12);
      }
#line 257
      if (tmp___4 == 0) {
        _L___0: /* CIL Label */ 
#line 258
        if (! pageorder_written) {
#line 259
          if (neworder == 1) {
            {
#line 260
            ps_writestring(outfile, "%%PageOrder: Ascend\r\n");
            }
          } else
#line 261
          if (neworder == 2) {
            {
#line 262
            ps_writestring(outfile, "%%PageOrder: Descend\r\n");
            }
          } else {
            {
#line 264
            ps_writestring(outfile, "%%PageOrder: Special\r\n");
            }
          }
#line 265
          pageorder_written = 1;
        }
#line 267
        line_written = ! end_header;
      }
    }
#line 269
    if (! line_written) {
      {
#line 270
      ps_writestring(outfile, (char const   *)(line));
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 273
  if (dsc->begincomments != dsc->endcomments) {
#line 274
    if (! pages_written) {
      {
#line 275
      snprintf((char */* __restrict  */)(buf), sizeof(buf) - 1UL, (char const   */* __restrict  */)"%%%%Pages: %d\r\n",
               pages);
#line 276
      ps_writestring(outfile, (char const   *)(buf));
      }
    }
#line 279
    if (! pageorder_written) {
#line 280
      if (neworder == 1) {
        {
#line 281
        ps_writestring(outfile, "%%PageOrder: Ascend\r\n");
        }
      } else
#line 282
      if (neworder == 2) {
        {
#line 283
        ps_writestring(outfile, "%%PageOrder: Descend\r\n");
        }
      } else {
        {
#line 285
        ps_writestring(outfile, "%%PageOrder: Special\r\n");
        }
      }
    }
  }
  {
#line 290
  ps_copy(outfile, infile, (long )dsc->beginpreview, (long )dsc->endpreview);
#line 291
  ps_copy(outfile, infile, (long )dsc->begindefaults, (long )dsc->enddefaults);
#line 292
  ps_copy(outfile, infile, (long )dsc->beginprolog, (long )dsc->endprolog);
#line 293
  ps_copy_setup(outfile, infile, (long )dsc->beginsetup, (long )dsc->endsetup, copies);
#line 296
  page = 1;
  }
#line 297
  if (reverse) {
#line 297
    i = (int )(dsc->page_count - 1U);
  } else {
#line 297
    i = 0;
  }
  {
#line 298
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 298
    if (reverse) {
#line 298
      tmp___8 = i >= 0;
    } else {
#line 298
      tmp___8 = i < (int )dsc->page_count;
    }
#line 298
    if (! tmp___8) {
#line 298
      goto while_break___1;
    }
    {
#line 299
    tmp___6 = doc_map_page(doc, i);
    }
#line 299
    if (*(pagelist->select + tmp___6)) {
      {
#line 300
      gfile_seek(infile, (long )(dsc->page + i)->begin, 0U);
#line 301
      position = gfile_get_position(infile);
#line 303
      count = ps_fgets(line, (int )(sizeof(line) - 1UL), infile);
      }
#line 303
      if (count == 0) {
#line 304
        return (-1);
      }
#line 306
      if ((dsc->page + i)->label) {
        {
#line 307
        snprintf((char */* __restrict  */)(buf), sizeof(buf) - 1UL, (char const   */* __restrict  */)"%%%%Page: %s %d\r\n",
                 (dsc->page + i)->label, page);
        }
      } else {
        {
#line 310
        snprintf((char */* __restrict  */)(buf), sizeof(buf) - 1UL, (char const   */* __restrict  */)"%%%%Page: %d %d\r\n",
                 page, page);
        }
      }
      {
#line 312
      ps_writestring(outfile, (char const   *)(buf));
#line 313
      page ++;
#line 314
      tmp___5 = strncmp((char const   *)(line), "%%Page:", (size_t )7);
      }
#line 314
      if (tmp___5 != 0) {
        {
#line 315
        gfile_write(outfile, (void const   *)(line), (unsigned int )count);
        }
      }
      {
#line 316
      ps_copy(outfile, infile, -1L, (long )(dsc->page + i)->end);
      }
    }
#line 318
    if (reverse) {
#line 318
      tmp___7 = -1;
    } else {
#line 318
      tmp___7 = 1;
    }
#line 318
    i += tmp___7;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 322
  gfile_seek(infile, (long )dsc->begintrailer, 0U);
#line 323
  position = gfile_get_position(infile);
  }
  {
#line 324
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 324
    if (! (position < dsc->endtrailer)) {
#line 324
      goto while_break___2;
    }
#line 325
    if (sizeof(line) < dsc->endtrailer - position) {
#line 325
      tmp___9 = sizeof(line);
    } else {
#line 325
      tmp___9 = dsc->endtrailer - position;
    }
    {
#line 325
    tmp___10 = ps_fgets(line, (int )tmp___9, infile);
    }
#line 325
    if (tmp___10 == 0) {
#line 327
      return (-1);
    }
    {
#line 328
    position = gfile_get_position(infile);
#line 329
    tmp___12 = strncmp((char const   *)(line), "%%Pages:", (size_t )8);
    }
#line 329
    if (tmp___12 == 0) {
#line 330
      goto while_continue___2;
    } else {
      {
#line 332
      tmp___11 = strncmp((char const   *)(line), "%%PageOrder:", (size_t )12);
      }
#line 332
      if (tmp___11 == 0) {
#line 333
        goto while_continue___2;
      } else {
        {
#line 336
        ps_writestring(outfile, (char const   *)(line));
        }
      }
    }
  }
  while_break___2: /* CIL Label */ ;
  }
#line 339
  return (0);
}
}
#line 351 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/cps.c"
int ps_extract(Doc *doc , char const   *filename , PAGELIST *pagelist , int copies ) 
{ 
  GFile *infile ;
  GFile *outfile ;
  CDSC *dsc ;
  int code ;
  DocType tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  unsigned long tmp___2 ;
  unsigned long tmp___3 ;

  {
  {
#line 358
  tmp = doc_type(doc);
  }
#line 358
  if ((unsigned int )tmp == 2U) {
#line 359
    return (-1);
  }
  {
#line 360
  tmp___1 = doc_name(doc);
#line 360
  infile = gfile_open(tmp___1, 0U);
  }
#line 360
  if ((unsigned long )infile == (unsigned long )((GFile *)((void *)0))) {
    {
#line 361
    app_msg(doc->app, "File \"");
#line 362
    tmp___0 = doc_name(doc);
#line 362
    app_csmsg(doc->app, tmp___0);
#line 363
    app_msg(doc->app, "\" does not exist\n");
    }
#line 364
    return (-1);
  }
  {
#line 366
  outfile = gfile_open(filename, 4097U);
  }
#line 366
  if ((unsigned long )outfile == (unsigned long )((GFile *)((void *)0))) {
    {
#line 368
    app_msg(doc->app, "File \"");
#line 369
    app_csmsg(doc->app, filename);
#line 370
    app_msg(doc->app, "\" can not be opened for writing\n");
#line 371
    gfile_close(infile);
    }
#line 372
    return (-1);
  }
#line 375
  if ((unsigned long )pagelist == (unsigned long )((void *)0)) {
    {
#line 377
    tmp___2 = gfile_get_length(infile);
#line 377
    code = ps_copy(outfile, infile, 0L, (long )tmp___2);
    }
  } else
#line 379
  if (doc->dsc) {
#line 379
    if ((doc->dsc)->page_count) {
#line 379
      if (pagelist->page_count) {
#line 379
        if ((unsigned long )pagelist->select != (unsigned long )((void *)0)) {
          {
#line 382
          code = ps_extract_pages(doc, infile, outfile, pagelist, copies);
          }
        } else {
#line 379
          goto _L___1;
        }
      } else {
#line 379
        goto _L___1;
      }
    } else {
#line 379
      goto _L___1;
    }
  } else
  _L___1: /* CIL Label */ 
#line 384
  if (doc->dsc) {
    {
#line 386
    dsc = doc->dsc;
#line 387
    code = ps_copy(outfile, infile, (long )dsc->begincomments, (long )dsc->endcomments);
    }
#line 388
    if (! code) {
      {
#line 389
      code = ps_copy(outfile, infile, (long )dsc->begindefaults, (long )dsc->enddefaults);
      }
    }
#line 390
    if (! code) {
      {
#line 391
      code = ps_copy(outfile, infile, (long )dsc->beginprolog, (long )dsc->endprolog);
      }
    }
#line 392
    if (! code) {
      {
#line 393
      code = ps_copy_setup(outfile, infile, (long )dsc->beginsetup, (long )dsc->endsetup,
                           copies);
      }
    }
#line 395
    if (! code) {
      {
#line 396
      code = ps_copy(outfile, infile, (long )dsc->begintrailer, (long )dsc->endtrailer);
      }
    }
  } else {
#line 400
    if (copies > 1) {
      {
#line 401
      ps_num_copies(outfile, copies);
      }
    }
    {
#line 402
    tmp___3 = gfile_get_length(infile);
#line 402
    code = ps_copy(outfile, infile, 0L, (long )tmp___3);
    }
  }
  {
#line 405
  gfile_close(outfile);
#line 406
  gfile_close(infile);
  }
#line 407
  if (code) {
#line 407
    if (! (debug & 1)) {
      {
#line 408
      unlink(filename);
      }
    }
  }
#line 409
  return (code);
}
}
#line 140 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/common.h"
CODEPAGE global_codepage ;
#line 141
int char_next(char const   *str ) ;
#line 149
int char_to_narrow(char *nstr , int nlen , char const   *wstr , int wlen ) ;
#line 150
int narrow_to_char(char *wstr , int wlen , char const   *nstr , int nlen ) ;
#line 154
int latin1_to_utf8(char *ustr , int ulen , char const   *str , int slen ) ;
#line 46 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/cmbcs.c"
CODEPAGE global_codepage  =    (CODEPAGE )0;
#line 51 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/cmbcs.c"
int char_next(char const   *str ) 
{ 
  int i ;
  unsigned char const   *t ;

  {
#line 54
  t = (unsigned char const   *)str;
  {
#line 60
  if ((unsigned int )global_codepage == 1U) {
#line 60
    goto case_1;
  }
#line 73
  if ((unsigned int )global_codepage == 2U) {
#line 73
    goto case_2;
  }
#line 92
  if ((unsigned int )global_codepage == 3U) {
#line 92
    goto case_3;
  }
#line 56
  goto switch_default;
  switch_default: /* CIL Label */ 
#line 58
  i = 1;
#line 59
  goto switch_break;
  case_1: /* CIL Label */ 
#line 61
  if ((int const   )*(t + 0) == 0) {
#line 62
    i = 0;
  } else
#line 63
  if ((int const   )*(t + 0) > 0) {
#line 63
    if ((int const   )*(t + 0) <= 127) {
#line 64
      i = 1;
    } else {
#line 63
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
#line 68
    i = 0;
    {
#line 69
    while (1) {
      while_continue: /* CIL Label */ ;
#line 69
      if (*(t + i)) {
#line 69
        if ((int const   )*(t + i) >= 128) {
#line 69
          if (! ((int const   )*(t + i) <= 191)) {
#line 69
            goto while_break;
          }
        } else {
#line 69
          goto while_break;
        }
      } else {
#line 69
        goto while_break;
      }
#line 70
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 72
  goto switch_break;
  case_2: /* CIL Label */ 
#line 74
  if ((int const   )*(t + 0) == 143) {
#line 76
    if ((int const   )*(t + 1) == 0) {
#line 77
      i = 1;
    } else
#line 78
    if ((int const   )*(t + 2) == 0) {
#line 79
      i = 2;
    } else {
#line 81
      i = 3;
    }
  } else
#line 83
  if ((int const   )*(t + 0) & 128) {
#line 85
    if ((int const   )*(str + 1) == 0) {
#line 86
      i = 1;
    } else {
#line 88
      i = 2;
    }
  } else {
#line 91
    i = 1;
  }
  case_3: /* CIL Label */ 
#line 93
  if ((int const   )*(t + 0) == 0) {
#line 94
    i = 0;
  } else
#line 96
  if ((int const   )*(t + 0) > 0) {
#line 96
    if ((int const   )*(t + 0) <= 127) {
#line 97
      i = 1;
    } else {
#line 96
      goto _L___2;
    }
  } else
  _L___2: /* CIL Label */ 
#line 99
  if ((int const   )*(t + 0) >= 128) {
#line 99
    if ((int const   )*(t + 0) <= 191) {
#line 100
      if ((int const   )*(t + 1) == 0) {
#line 101
        i = 1;
      } else {
#line 103
        i = 2;
      }
    } else {
#line 99
      goto _L___1;
    }
  } else
  _L___1: /* CIL Label */ 
#line 105
  if ((int const   )*(t + 0) >= 160) {
#line 105
    if ((int const   )*(t + 0) <= 223) {
#line 106
      i = 1;
    } else {
#line 105
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 108
  if ((int const   )*(t + 0) >= 224) {
#line 108
    if ((int const   )*(t + 0) <= 239) {
#line 109
      if ((int const   )*(t + 1) == 0) {
#line 110
        i = 1;
      } else {
#line 112
        i = 2;
      }
    } else {
#line 115
      i = 1;
    }
  } else {
#line 115
    i = 1;
  }
  switch_break: /* CIL Label */ ;
  }
#line 117
  return (i);
}
}
#line 128 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/cmbcs.c"
int char_to_narrow(char *nstr , int nlen , char const   *wstr , int wlen ) 
{ 


  {
#line 132
  if (nlen == 0) {
#line 133
    return (wlen);
  }
#line 134
  if (nlen < wlen) {
#line 135
    return (0);
  }
  {
#line 136
  memcpy((void */* __restrict  */)nstr, (void const   */* __restrict  */)wstr, (size_t )wlen);
  }
#line 137
  return (wlen);
}
}
#line 142 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/cmbcs.c"
int narrow_to_char(char *wstr , int wlen , char const   *nstr , int nlen ) 
{ 


  {
#line 146
  if (wlen == 0) {
#line 147
    return (nlen);
  }
#line 148
  if (wlen < nlen) {
#line 149
    return (0);
  }
  {
#line 150
  memcpy((void */* __restrict  */)wstr, (void const   */* __restrict  */)nstr, (size_t )nlen);
  }
#line 151
  return (nlen);
}
}
#line 161 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/cmbcs.c"
int latin1_to_utf8(char *ustr , int ulen , char const   *str , int slen ) 
{ 
  int i ;
  int j ;
  char const   *p ;
  int len ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 165
  p = str;
#line 166
  len = slen;
#line 167
  i = 0;
  {
#line 167
  while (1) {
    while_continue: /* CIL Label */ ;
#line 167
    if (! (i < slen)) {
#line 167
      goto while_break;
    }
#line 168
    if ((int const   )*(p + i) & 128) {
#line 169
      len ++;
    }
#line 167
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 170
  if ((unsigned long )ustr != (unsigned long )((void *)0)) {
#line 170
    if (ulen <= len) {
#line 171
      p = str;
#line 172
      i = 0;
#line 172
      j = 0;
      {
#line 172
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 172
        if (! (i < slen)) {
#line 172
          goto while_break___0;
        }
#line 173
        if ((int const   )*p & 128) {
#line 174
          tmp = j;
#line 174
          j ++;
#line 174
          *(ustr + tmp) = (char )(192 | (int )(((int const   )*p & 192) >> 6));
#line 175
          tmp___0 = j;
#line 175
          j ++;
#line 175
          *(ustr + tmp___0) = (char )(128 | (int )((int const   )*p & 63));
        } else {
#line 178
          tmp___1 = j;
#line 178
          j ++;
#line 178
          *(ustr + tmp___1) = (char )*p;
        }
#line 179
        p ++;
#line 172
        i ++;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
  }
#line 182
  return (len);
}
}
#line 306 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) FILE *( __attribute__((__leaf__)) fdopen)(int __fd ,
                                                                               char const   *__modes ) ;
#line 759
extern void rewind(FILE *__stream ) ;
#line 830
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) ferror)(FILE *__stream ) ;
#line 858
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) fileno)(FILE *__stream ) ;
#line 214 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2), __leaf__)) fstat)(int __fd ,
                                                                                            struct stat *__buf ) ;
#line 65 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/cfile.h"
GFile *gfile_open_handle(void *hFile , unsigned int nOpenFlags ) ;
#line 94
int gfile_get_datetime(GFile *gf , unsigned long *pdt_low , unsigned long *pdt_high ) ;
#line 101
int gfile_changed(GFile *gf , unsigned long length , unsigned long dt_low , unsigned long dt_high ) ;
#line 105
int gfile_error(GFile *gf ) ;
#line 116
int gfile_puts(GFile *gf , char const   *str ) ;
#line 52 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/cfile.c"
int gfile_error(GFile *gf ) 
{ 
  int tmp ;

  {
  {
#line 57
  tmp = ferror(gf->m_file);
  }
#line 57
  return (tmp);
}
}
#line 60 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/cfile.c"
unsigned long gfile_get_length(GFile *gf ) 
{ 
  struct stat fstatus ;
  int tmp ;

  {
  {
#line 63
  tmp = fileno(gf->m_file);
#line 63
  fstat(tmp, & fstatus);
  }
#line 64
  return ((unsigned long )fstatus.st_size);
}
}
#line 67 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/cfile.c"
int gfile_get_datetime(GFile *gf , unsigned long *pdt_low , unsigned long *pdt_high ) 
{ 
  struct stat fstatus ;
  int tmp ;

  {
  {
#line 72
  tmp = fileno(gf->m_file);
#line 72
  fstat(tmp, & fstatus);
#line 73
  *pdt_low = (unsigned long )fstatus.st_mtim.tv_sec;
#line 74
  *pdt_high = 0UL;
  }
#line 75
  return (1);
}
}
#line 78 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/cfile.c"
int gfile_changed(GFile *gf , unsigned long length , unsigned long dt_low , unsigned long dt_high ) 
{ 
  unsigned long this_dt_low ;
  unsigned long this_dt_high ;
  unsigned long this_length ;
  unsigned long tmp ;
  int tmp___0 ;

  {
  {
#line 82
  tmp = gfile_get_length(gf);
#line 82
  this_length = tmp;
#line 83
  gfile_get_datetime(gf, & this_dt_low, & this_dt_high);
  }
#line 84
  if (this_length != length) {
#line 84
    tmp___0 = 1;
  } else
#line 84
  if (this_dt_low != dt_low) {
#line 84
    tmp___0 = 1;
  } else
#line 84
  if (this_dt_high != dt_high) {
#line 84
    tmp___0 = 1;
  } else {
#line 84
    tmp___0 = 0;
  }
#line 84
  return (tmp___0);
}
}
#line 88 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/cfile.c"
GFile *gfile_open_handle(void *hFile , unsigned int nOpenFlags ) 
{ 
  GFile *gf ;
  char const   *access___0 ;
  void *tmp ;

  {
#line 91
  access___0 = "rb";
#line 92
  if ((nOpenFlags & 15U) == 1U) {
#line 93
    access___0 = "wb";
  }
  {
#line 94
  tmp = malloc(sizeof(GFile ));
#line 94
  gf = (GFile *)tmp;
  }
#line 95
  if ((unsigned long )gf == (unsigned long )((void *)0)) {
#line 96
    return ((GFile *)((void *)0));
  }
  {
#line 97
  memset((void *)gf, 0, sizeof(GFile ));
#line 98
  gf->m_file = fdopen((int )((long )hFile), access___0);
  }
#line 99
  if ((unsigned long )gf->m_file == (unsigned long )((void *)0)) {
    {
#line 100
    free((void *)gf);
#line 101
    gf = (GFile *)((void *)0);
    }
  }
#line 103
  return (gf);
}
}
#line 106 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/cfile.c"
GFile *gfile_open(char const   *lpszFileName , unsigned int nOpenFlags ) 
{ 
  GFile *gf ;
  FILE *f ;
  char const   *access___0 ;
  void *tmp ;

  {
#line 110
  access___0 = "rb";
#line 111
  if ((nOpenFlags & 15U) == 1U) {
#line 112
    access___0 = "wb";
  }
#line 114
  if ((int const   )*(lpszFileName + 0) == 0) {
#line 115
    f = stdout;
  } else {
    {
#line 117
    f = fopen((char const   */* __restrict  */)lpszFileName, (char const   */* __restrict  */)access___0);
    }
  }
#line 118
  if ((unsigned long )f == (unsigned long )((FILE *)((void *)0))) {
#line 119
    return ((GFile *)((void *)0));
  }
  {
#line 121
  tmp = malloc(sizeof(GFile ));
#line 121
  gf = (GFile *)tmp;
  }
#line 122
  if ((unsigned long )gf == (unsigned long )((void *)0)) {
    {
#line 123
    fclose(f);
    }
#line 124
    return ((GFile *)((void *)0));
  }
  {
#line 126
  memset((void *)gf, 0, sizeof(GFile ));
#line 127
  gf->m_file = f;
  }
#line 128
  return (gf);
}
}
#line 131 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/cfile.c"
void gfile_close(GFile *gf ) 
{ 


  {
  {
#line 135
  fclose(gf->m_file);
#line 136
  gf->m_file = (FILE *)((void *)0);
#line 137
  free((void *)gf);
  }
#line 138
  return;
}
}
#line 141 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/cfile.c"
unsigned int gfile_read(GFile *gf , void *lpBuf , unsigned int nCount ) 
{ 
  size_t tmp ;

  {
  {
#line 145
  tmp = fread((void */* __restrict  */)lpBuf, (size_t )1, (size_t )nCount, (FILE */* __restrict  */)gf->m_file);
  }
#line 145
  return ((unsigned int )tmp);
}
}
#line 148 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/cfile.c"
unsigned int gfile_write(GFile *gf , void const   *lpBuf , unsigned int nCount ) 
{ 
  size_t tmp ;

  {
  {
#line 152
  tmp = fwrite((void const   */* __restrict  */)lpBuf, (size_t )1, (size_t )nCount,
               (FILE */* __restrict  */)gf->m_file);
  }
#line 152
  return ((unsigned int )tmp);
}
}
#line 156 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/cfile.c"
int gfile_seek(GFile *gf , long lOff , unsigned int nFrom ) 
{ 
  int origin ;
  int tmp ;

  {
  {
#line 167
  if (nFrom == 1U) {
#line 167
    goto case_1;
  }
#line 170
  if (nFrom == 2U) {
#line 170
    goto case_2;
  }
#line 163
  goto switch_default;
  switch_default: /* CIL Label */ 
#line 165
  origin = 0;
#line 166
  goto switch_break;
  case_1: /* CIL Label */ 
#line 168
  origin = 1;
#line 169
  goto switch_break;
  case_2: /* CIL Label */ 
#line 171
  origin = 2;
#line 172
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 174
  if (origin == 0) {
#line 174
    if (lOff == 0L) {
      {
#line 175
      rewind(gf->m_file);
      }
    }
  }
  {
#line 176
  tmp = fseek(gf->m_file, lOff, origin);
  }
#line 176
  return (tmp);
}
}
#line 179 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/cfile.c"
unsigned long gfile_get_position(GFile *gf ) 
{ 
  long tmp ;

  {
  {
#line 183
  tmp = ftell(gf->m_file);
  }
#line 183
  return ((unsigned long )tmp);
}
}
#line 186 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/cfile.c"
int gfile_puts(GFile *gf , char const   *str ) 
{ 
  size_t tmp ;
  unsigned int tmp___0 ;

  {
  {
#line 188
  tmp = strlen(str);
#line 188
  tmp___0 = gfile_write(gf, (void const   *)str, (unsigned int )tmp);
  }
#line 188
  return ((int )tmp___0);
}
}
#line 364 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
#line 377 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/dscparse.h"
char const   * const  dsc_message[17] ;
#line 557
void dsc_debug_print(CDSC *dsc , char const   *str ) ;
#line 563
int dsc_stricmp(char const   *s , char const   *t ) ;
#line 574
void dsc_display(CDSC *dsc , void (*dfn)(void *ptr , char const   *str ) ) ;
#line 31 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/dscutil.c"
int dsc_error_fn(void *caller_data , CDSC *dsc , unsigned int explanation , char const   *line ,
                 unsigned int line_len ) ;
#line 41 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/dscutil.c"
char const   * const  dsc_message[17]  = 
#line 41
  {      (char const   */* const  */)"This line is incorrect.\nThe bounding box must be in integer coordinates,\nnot floating point. A floating point bounding box should\nbe specified using %%HiResBoundingBox:\nA %%BoundingBox: should still be provided with integer values.\n\n\'OK\' will convert the coordinates to integers,\nrounding them outwards.\n\'Cancel\' will ignore this line\n",      (char const   */* const  */)"The trailer is normally at the end of a document.\nThis line was found more than 32k bytes from the end\nof the file.  Trailers are not usually this long.\nIt is more likely that another PostScript file has been included,\nwithout enclosing it in %%BeginDocument / %%EndDocument.\n\n\'OK\' will assume this is part of an included file.\n\'Cancel\' will assume this is the trailer\n",      (char const   */* const  */)"This line normally occurs at the end of a document.\nThis line was found more than 100 bytes from the end\nof the file.\nIt is more likely that another PostScript file has been included,\nwithout enclosing it in %%BeginDocument / %%EndDocument.\n\n\'OK\' will assume this is part of an included file.\n\'Cancel\' will assume this is part of the trailer\n",      (char const   */* const  */)"This %%Page: line occurred in the trailer, which is not legal.\nEPS files should be encapsulated in %%BeginDocument / %%EndDocument.\nIf is possible that an EPS file was incorrectly encapsulated,\nand that we have been confused by the %%Trailer in an EPS file.\n\n\'OK\' will process more pages.\n\'Cancel\' will ignore this page comment\n", 
        (char const   */* const  */)"This line is incorrect.\nThe two arguments should be a label and an ordinal.\nThe ordinal should be 1 for the first page and should\nincrease by 1 for each following page.\nThe page ordinal is missing or is not in sequence.\n\nIt is likely that this line is part of an included file that\nwas not enclosed in %%BeginDocument / %%EndDocument.\n\n\'OK\' will ignore this page, assuming it is part of an\nincorrectly encapsulated EPS file.\n\'Cancel\' will treat this as a valid page\n",      (char const   */* const  */)"%%Pages: doesn\'t match number of %%Page:\n\n\'OK\' will adjust the page count to match the number of %%Page:\ncomments found\n\'Cancel\' will set the page count from %%Pages:\n",      (char const   */* const  */)"This EPS file is missing the required %%BoundingBox:\nSee the GSview help for details of how to add/adjust the\nbounding box.\n\n\'OK\' will assume this as an EPS file\n\'Cancel\' will assume this is NOT an EPS file.\n",      (char const   */* const  */)"EPS files may have 0 or 1 pages.  This \'EPS\' file has\nmore than this and so is not an EPS file.\nYou cannot use `Print To` `Encapsulated PostScript File` for\nprinting multipage files.  The correct method is to connect\nthe printer to FILE: or to select \'Print to File\'.\n\n\'OK\' will assume this as an EPS file\n\'Cancel\' will assume this is NOT an EPS file.\n", 
        (char const   */* const  */)"Media was specified with %%DocumentMedia:, but no default\nmedia was specified with %%PageMedia:.\n\n\'OK\' will set the default media to the first listed media.\n\'Cancel\' will not set a default media.\n",      (char const   */* const  */)"This line is incorrect\nTo defer a value, you must use \'(atend)\', not \'atend\'\n\n\'OK\' will assume that (atend) was meant.\n\'Cancel\' will ignore this line.\n",      (char const   */* const  */)"This comment is duplicated in the header, which is unnecessary.\nThe first occurence of a header line takes precedence.\n\n\'OK\' or \'Cancel\' will ignore the duplicate line.\n",      (char const   */* const  */)"This comment is duplicated in the trailer, which is unnecessary.\nThe last occurence of a trailer line takes precedence.\n\n\'OK\' or \'Cancel\' will use the duplicate line.\n", 
        (char const   */* const  */)"The number of Begin and End comments do not match.\n\n\'OK\' or \'Cancel\' will ignore this mismatch.\n",      (char const   */* const  */)"This line is incorrect because it should not occur\nwithin a page.  This probably indicates that an EPS file\nwas incorrectly encapsulated.  The line will be ignored.\n\n\'OK\' or \'Cancel\' will ignore this line.\n",      (char const   */* const  */)"\n\nLines in DSC documents must be shorter than 255 characters.\n",      (char const   */* const  */)"This DSC comment line is incorrect.\nPlease refer to the DSC specification.\n\'OK\' or \'Cancel\' will ignore this mismatch.\n", 
        (char const   */* const  */)((void *)0)};
#line 170 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/dscutil.c"
int dsc_error_fn(void *caller_data , CDSC *dsc , unsigned int explanation , char const   *line ,
                 unsigned int line_len ) 
{ 
  int response ;
  int severity ;
  char buf[256] ;
  int length ;
  unsigned long tmp ;

  {
#line 177
  if (explanation > dsc->max_error) {
#line 178
    return (0);
  }
#line 180
  if ((unsigned long )caller_data == (unsigned long )((void *)0)) {
    {
#line 181
    dsc_debug_print(dsc, "");
    }
  }
#line 183
  severity = (int )*(dsc->severity + explanation);
#line 186
  if (dsc->debug_print_fn) {
    {
#line 188
    if (severity == 0) {
#line 188
      goto case_0;
    }
#line 191
    if (severity == 1) {
#line 191
      goto case_1;
    }
#line 194
    if (severity == 2) {
#line 194
      goto case_2;
    }
#line 187
    goto switch_break;
    case_0: /* CIL Label */ 
    {
#line 189
    dsc_debug_print(dsc, "\nDSC Information");
    }
#line 190
    goto switch_break;
    case_1: /* CIL Label */ 
    {
#line 192
    dsc_debug_print(dsc, "\nDSC Warning");
    }
#line 193
    goto switch_break;
    case_2: /* CIL Label */ 
    {
#line 195
    dsc_debug_print(dsc, "\nDSC Error");
    }
    switch_break: /* CIL Label */ ;
    }
    {
#line 197
    dsc_debug_print(dsc, "\n");
    }
#line 198
    if (explanation <= dsc->max_error) {
#line 199
      if (line) {
#line 199
        if (line_len) {
#line 200
          if ((unsigned long )line_len < sizeof(buf) - 1UL) {
#line 200
            tmp = (unsigned long )line_len;
          } else {
#line 200
            tmp = sizeof(buf) - 1UL;
          }
          {
#line 200
          length = (int )tmp;
#line 201
          sprintf((char */* __restrict  */)(buf), (char const   */* __restrict  */)"At line %d:\n",
                  dsc->line_count);
#line 202
          dsc_debug_print(dsc, (char const   *)(buf));
#line 203
          strncpy((char */* __restrict  */)(buf), (char const   */* __restrict  */)line,
                  (size_t )length);
#line 204
          buf[length] = (char )'\000';
#line 205
          dsc_debug_print(dsc, "  ");
#line 206
          dsc_debug_print(dsc, (char const   *)(buf));
          }
        }
      }
      {
#line 208
      dsc_debug_print(dsc, (char const   *)dsc_message[explanation]);
      }
    }
  }
#line 214
  response = 1;
#line 216
  if (dsc->debug_print_fn) {
    {
#line 218
    if (response == 0) {
#line 218
      goto case_0___0;
    }
#line 221
    if (response == 1) {
#line 221
      goto case_1___0;
    }
#line 224
    if (response == 2) {
#line 224
      goto case_2___0;
    }
#line 217
    goto switch_break___0;
    case_0___0: /* CIL Label */ 
    {
#line 219
    dsc_debug_print(dsc, "Response = OK\n");
    }
#line 220
    goto switch_break___0;
    case_1___0: /* CIL Label */ 
    {
#line 222
    dsc_debug_print(dsc, "Response = Cancel\n");
    }
#line 223
    goto switch_break___0;
    case_2___0: /* CIL Label */ 
    {
#line 225
    dsc_debug_print(dsc, "Response = Ignore All DSC\n");
    }
#line 226
    goto switch_break___0;
    switch_break___0: /* CIL Label */ ;
    }
  }
#line 230
  return (response);
}
}
#line 233 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/dscutil.c"
void dsc_display(CDSC *dsc , void (*dfn)(void *ptr , char const   *str ) ) 
{ 
  unsigned int i ;
  char const   *p ;
  char buf[256] ;
  void *ptr ;
  CDCS2 *pdcs ;
  CDSCCOLOUR *colour ;
  char fmtbuf[256] ;
  char const   *offset_fmt ;
  char const   *tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  int tmp___2 ;
  char const   *type ;
  char const   *tmp___3 ;
  char const   *tmp___4 ;
  char const   *tmp___5 ;

  {
  {
#line 239
  ptr = dsc->caller_data;
#line 240
  pdcs = dsc->dcs2;
#line 241
  colour = dsc->colours;
#line 243
  offset_fmt = "lu";
#line 244
  (*dfn)(ptr, "== DSC dump ==\n");
  }
#line 245
  if (dsc->dsc) {
    {
#line 246
    (*dfn)(ptr, "DSC ");
    }
  }
#line 247
  if (dsc->epsf) {
    {
#line 248
    (*dfn)(ptr, "EPSF ");
    }
  }
#line 249
  if (dsc->doseps) {
    {
#line 250
    (*dfn)(ptr, "DOSEPS ");
    }
  }
#line 251
  if (dsc->macbin) {
    {
#line 252
    (*dfn)(ptr, "MacBinary ");
    }
  }
#line 253
  if (dsc->pdf) {
    {
#line 254
    (*dfn)(ptr, "PDF ");
    }
  }
#line 255
  if (dsc->pjl) {
    {
#line 256
    (*dfn)(ptr, "PJL ");
    }
  }
#line 257
  if (dsc->ctrld) {
    {
#line 258
    (*dfn)(ptr, "CTRLD ");
    }
  }
#line 259
  if (dsc->dcs2) {
    {
#line 260
    (*dfn)(ptr, "DCS2.0 ");
    }
  }
  {
#line 261
  (*dfn)(ptr, "\n");
  }
#line 263
  if (dsc->dsc_version) {
    {
#line 264
    (*dfn)(ptr, "version ");
#line 265
    (*dfn)(ptr, (char const   *)dsc->dsc_version);
#line 266
    (*dfn)(ptr, "\n");
    }
  }
#line 268
  if (dsc->dsc_title) {
    {
#line 269
    (*dfn)(ptr, "title ");
#line 270
    (*dfn)(ptr, (char const   *)dsc->dsc_title);
#line 271
    (*dfn)(ptr, "\n");
    }
  }
#line 273
  if (dsc->dsc_creator) {
    {
#line 274
    (*dfn)(ptr, "creator ");
#line 275
    (*dfn)(ptr, (char const   *)dsc->dsc_creator);
#line 276
    (*dfn)(ptr, "\n");
    }
  }
#line 278
  if (dsc->dsc_date) {
    {
#line 279
    (*dfn)(ptr, "date ");
#line 280
    (*dfn)(ptr, (char const   *)dsc->dsc_date);
#line 281
    (*dfn)(ptr, "\n");
    }
  }
#line 283
  if (dsc->dsc_for) {
    {
#line 284
    (*dfn)(ptr, "for ");
#line 285
    (*dfn)(ptr, (char const   *)dsc->dsc_for);
#line 286
    (*dfn)(ptr, "\n");
    }
  }
#line 289
  if (dsc->doseps) {
    {
#line 290
    sprintf((char */* __restrict  */)(buf), (char const   */* __restrict  */)"doseps: ps=%ld %ld  wmf=%ld %ld  tiff=%ld %ld\n",
            (dsc->doseps)->ps_begin, (dsc->doseps)->ps_length, (dsc->doseps)->wmf_begin,
            (dsc->doseps)->wmf_length, (dsc->doseps)->tiff_begin, (dsc->doseps)->tiff_length);
#line 294
    (*dfn)(ptr, (char const   *)(buf));
    }
  }
#line 296
  if (dsc->macbin) {
    {
#line 297
    sprintf((char */* __restrict  */)(buf), (char const   */* __restrict  */)"macbin ps=%ld %ld  resource=%ld %ld\n",
            (dsc->macbin)->data_begin, (dsc->macbin)->data_length, (dsc->macbin)->resource_begin,
            (dsc->macbin)->resource_length);
#line 300
    (*dfn)(ptr, (char const   *)(buf));
    }
  }
#line 302
  if (dsc->bbox) {
    {
#line 303
    sprintf((char */* __restrict  */)(buf), (char const   */* __restrict  */)"boundingbox %d %d %d %d\n",
            (dsc->bbox)->llx, (dsc->bbox)->lly, (dsc->bbox)->urx, (dsc->bbox)->ury);
#line 305
    (*dfn)(ptr, (char const   *)(buf));
    }
  }
#line 307
  if (dsc->hires_bbox) {
    {
#line 308
    sprintf((char */* __restrict  */)(buf), (char const   */* __restrict  */)"hiresboundingbox %f %f %f %f\n",
            (double )(dsc->hires_bbox)->fllx, (double )(dsc->hires_bbox)->flly, (double )(dsc->hires_bbox)->furx,
            (double )(dsc->hires_bbox)->fury);
#line 311
    (*dfn)(ptr, (char const   *)(buf));
    }
  }
#line 313
  if (dsc->crop_box) {
    {
#line 314
    sprintf((char */* __restrict  */)(buf), (char const   */* __restrict  */)"cropbox %f %f %f %f\n",
            (double )(dsc->crop_box)->fllx, (double )(dsc->crop_box)->flly, (double )(dsc->crop_box)->furx,
            (double )(dsc->crop_box)->fury);
#line 317
    (*dfn)(ptr, (char const   *)(buf));
    }
  }
#line 319
  if (dsc->language_level != 0U) {
    {
#line 320
    sprintf((char */* __restrict  */)(buf), (char const   */* __restrict  */)"language level %d\n",
            dsc->language_level);
#line 321
    (*dfn)(ptr, (char const   *)(buf));
    }
  }
#line 323
  if (dsc->preview != 0U) {
    {
#line 325
    if (dsc->preview == 0U) {
#line 325
      goto case_0;
    }
#line 328
    if (dsc->preview == 1U) {
#line 328
      goto case_1;
    }
#line 331
    if (dsc->preview == 2U) {
#line 331
      goto case_2;
    }
#line 334
    if (dsc->preview == 3U) {
#line 334
      goto case_3;
    }
#line 337
    if (dsc->preview == 4U) {
#line 337
      goto case_4;
    }
#line 340
    goto switch_default;
    case_0: /* CIL Label */ 
#line 326
    p = "None";
#line 327
    goto switch_break;
    case_1: /* CIL Label */ 
#line 329
    p = "Interchange";
#line 330
    goto switch_break;
    case_2: /* CIL Label */ 
#line 332
    p = "TIFF";
#line 333
    goto switch_break;
    case_3: /* CIL Label */ 
#line 335
    p = "Windows MetaFile";
#line 336
    goto switch_break;
    case_4: /* CIL Label */ 
#line 338
    p = "Mac PICT";
#line 339
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 341
    p = "Unknown";
    switch_break: /* CIL Label */ ;
    }
    {
#line 343
    sprintf((char */* __restrict  */)(buf), (char const   */* __restrict  */)"preview type %s\n",
            p);
#line 344
    (*dfn)(ptr, (char const   *)(buf));
    }
  }
#line 347
  if (dsc->document_data != 0U) {
    {
#line 349
    if (dsc->document_data == 1U) {
#line 349
      goto case_1___0;
    }
#line 352
    if (dsc->document_data == 2U) {
#line 352
      goto case_2___0;
    }
#line 355
    if (dsc->document_data == 3U) {
#line 355
      goto case_3___0;
    }
#line 358
    goto switch_default___0;
    case_1___0: /* CIL Label */ 
#line 350
    p = "Clean7Bit";
#line 351
    goto switch_break___0;
    case_2___0: /* CIL Label */ 
#line 353
    p = "Clean8Bit";
#line 354
    goto switch_break___0;
    case_3___0: /* CIL Label */ 
#line 356
    p = "Binary";
#line 357
    goto switch_break___0;
    switch_default___0: /* CIL Label */ 
#line 359
    p = "Unknown";
    switch_break___0: /* CIL Label */ ;
    }
    {
#line 361
    sprintf((char */* __restrict  */)(buf), (char const   */* __restrict  */)"document data %s\n",
            p);
#line 362
    (*dfn)(ptr, (char const   *)(buf));
    }
  }
#line 366
  if (dsc->page_order != 0U) {
    {
#line 368
    if (dsc->page_order == 1U) {
#line 368
      goto case_1___1;
    }
#line 371
    if (dsc->page_order == 2U) {
#line 371
      goto case_2___1;
    }
#line 374
    if (dsc->page_order == 3U) {
#line 374
      goto case_3___1;
    }
#line 377
    goto switch_default___1;
    case_1___1: /* CIL Label */ 
#line 369
    p = "Ascend";
#line 370
    goto switch_break___1;
    case_2___1: /* CIL Label */ 
#line 372
    p = "Descend";
#line 373
    goto switch_break___1;
    case_3___1: /* CIL Label */ 
#line 375
    p = "Special";
#line 376
    goto switch_break___1;
    switch_default___1: /* CIL Label */ 
#line 378
    p = "Unknown";
    switch_break___1: /* CIL Label */ ;
    }
    {
#line 380
    sprintf((char */* __restrict  */)(buf), (char const   */* __restrict  */)"page order %s\n",
            p);
#line 381
    (*dfn)(ptr, (char const   *)(buf));
    }
  }
#line 384
  if (dsc->page_orientation != 0U) {
    {
#line 386
    if (dsc->page_orientation == 1U) {
#line 386
      goto case_1___2;
    }
#line 389
    if (dsc->page_orientation == 2U) {
#line 389
      goto case_2___2;
    }
#line 392
    goto switch_default___2;
    case_1___2: /* CIL Label */ 
#line 387
    p = "Portrait";
#line 388
    goto switch_break___2;
    case_2___2: /* CIL Label */ 
#line 390
    p = "Landscape";
#line 391
    goto switch_break___2;
    switch_default___2: /* CIL Label */ 
#line 393
    p = "Unknown";
    switch_break___2: /* CIL Label */ ;
    }
    {
#line 395
    sprintf((char */* __restrict  */)(buf), (char const   */* __restrict  */)"page orientation %s\n",
            p);
#line 396
    (*dfn)(ptr, (char const   *)(buf));
    }
  }
#line 398
  if (dsc->page_bbox) {
    {
#line 399
    sprintf((char */* __restrict  */)(buf), (char const   */* __restrict  */)"default page boundingbox %d %d %d %d\n",
            (dsc->page_bbox)->llx, (dsc->page_bbox)->lly, (dsc->page_bbox)->urx, (dsc->page_bbox)->ury);
#line 402
    (*dfn)(ptr, (char const   *)(buf));
    }
  }
#line 405
  i = 0U;
  {
#line 405
  while (1) {
    while_continue: /* CIL Label */ ;
#line 405
    if (dsc->media) {
#line 405
      if (! (i < dsc->media_count)) {
#line 405
        goto while_break;
      }
    } else {
#line 405
      goto while_break;
    }
#line 406
    if (*(dsc->media + i)) {
#line 407
      if ((*(dsc->media + i))->type) {
#line 407
        tmp = (*(dsc->media + i))->type;
      } else {
#line 407
        tmp = "";
      }
#line 407
      if ((*(dsc->media + i))->colour) {
#line 407
        tmp___0 = (*(dsc->media + i))->colour;
      } else {
#line 407
        tmp___0 = "";
      }
#line 407
      if ((*(dsc->media + i))->name) {
#line 407
        tmp___1 = (*(dsc->media + i))->name;
      } else {
#line 407
        tmp___1 = "";
      }
      {
#line 407
      sprintf((char */* __restrict  */)(buf), (char const   */* __restrict  */)"media %d   (%.50s) %g %g %g (%.50s) (%.50s)\n",
              i, tmp___1, (double )(*(dsc->media + i))->width, (double )(*(dsc->media + i))->height,
              (double )(*(dsc->media + i))->weight, tmp___0, tmp);
#line 413
      (*dfn)(ptr, (char const   *)(buf));
      }
#line 414
      if ((*(dsc->media + i))->mediabox) {
        {
#line 415
        sprintf((char */* __restrict  */)(buf), (char const   */* __restrict  */)"  mediabox %d %d %d %d\n",
                ((*(dsc->media + i))->mediabox)->llx, ((*(dsc->media + i))->mediabox)->llx,
                ((*(dsc->media + i))->mediabox)->llx, ((*(dsc->media + i))->mediabox)->llx);
#line 420
        (*dfn)(ptr, (char const   *)(buf));
        }
      }
    }
#line 405
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 424
  if (dsc->page_media) {
    {
#line 425
    sprintf((char */* __restrict  */)(buf), (char const   */* __restrict  */)"default page media %.50s\n",
            (dsc->page_media)->name);
#line 426
    (*dfn)(ptr, (char const   *)(buf));
    }
  }
#line 429
  if (dsc->viewing_orientation) {
    {
#line 430
    sprintf((char */* __restrict  */)(buf), (char const   */* __restrict  */)"default viewing orientation %f %f %f %f\n",
            (double )(dsc->viewing_orientation)->xx, (double )(dsc->viewing_orientation)->xy,
            (double )(dsc->viewing_orientation)->yx, (double )(dsc->viewing_orientation)->yy);
#line 435
    (*dfn)(ptr, (char const   *)(buf));
    }
  }
  {
#line 438
  sprintf((char */* __restrict  */)(fmtbuf), (char const   */* __restrict  */)"comments %%%s %%%s\n",
          offset_fmt, offset_fmt);
#line 439
  sprintf((char */* __restrict  */)(buf), (char const   */* __restrict  */)(fmtbuf),
          dsc->begincomments, dsc->endcomments);
#line 440
  (*dfn)(ptr, (char const   *)(buf));
#line 441
  sprintf((char */* __restrict  */)(fmtbuf), (char const   */* __restrict  */)"preview %%%s %%%s\n",
          offset_fmt, offset_fmt);
#line 442
  sprintf((char */* __restrict  */)(buf), (char const   */* __restrict  */)(fmtbuf),
          dsc->beginpreview, dsc->endpreview);
#line 443
  (*dfn)(ptr, (char const   *)(buf));
#line 444
  sprintf((char */* __restrict  */)(fmtbuf), (char const   */* __restrict  */)"defaults %%%s %%%s\n",
          offset_fmt, offset_fmt);
#line 445
  sprintf((char */* __restrict  */)(buf), (char const   */* __restrict  */)(fmtbuf),
          dsc->begindefaults, dsc->enddefaults);
#line 446
  (*dfn)(ptr, (char const   *)(buf));
#line 447
  sprintf((char */* __restrict  */)(fmtbuf), (char const   */* __restrict  */)"prolog %%%s %%%s\n",
          offset_fmt, offset_fmt);
#line 448
  sprintf((char */* __restrict  */)(buf), (char const   */* __restrict  */)(fmtbuf),
          dsc->beginprolog, dsc->endprolog);
#line 449
  (*dfn)(ptr, (char const   *)(buf));
#line 450
  sprintf((char */* __restrict  */)(fmtbuf), (char const   */* __restrict  */)"setup %%%s %%%s\n",
          offset_fmt, offset_fmt);
#line 451
  sprintf((char */* __restrict  */)(buf), (char const   */* __restrict  */)(fmtbuf),
          dsc->beginsetup, dsc->endsetup);
#line 452
  (*dfn)(ptr, (char const   *)(buf));
#line 453
  sprintf((char */* __restrict  */)(buf), (char const   */* __restrict  */)"pages %d\n",
          dsc->page_pages);
#line 454
  (*dfn)(ptr, (char const   *)(buf));
#line 455
  i = 0U;
  }
  {
#line 455
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 455
    if (! (i < dsc->page_count)) {
#line 455
      goto while_break___0;
    }
    {
#line 456
    sprintf((char */* __restrict  */)(fmtbuf), (char const   */* __restrict  */)"page %%.20s %%d  %%%s %%%s\n",
            offset_fmt, offset_fmt);
#line 457
    sprintf((char */* __restrict  */)(buf), (char const   */* __restrict  */)(fmtbuf),
            (dsc->page + i)->label, (dsc->page + i)->ordinal, (dsc->page + i)->begin,
            (dsc->page + i)->end);
#line 460
    (*dfn)(ptr, (char const   *)(buf));
    }
#line 461
    if ((dsc->page + i)->media) {
      {
#line 462
      sprintf((char */* __restrict  */)(buf), (char const   */* __restrict  */)"  page media %s\n",
              ((dsc->page + i)->media)->name);
#line 463
      (*dfn)(ptr, (char const   *)(buf));
      }
    }
#line 465
    if ((dsc->page + i)->orientation != 0U) {
      {
#line 467
      if ((dsc->page + i)->orientation == 1U) {
#line 467
        goto case_1___3;
      }
#line 470
      if ((dsc->page + i)->orientation == 2U) {
#line 470
        goto case_2___3;
      }
#line 473
      goto switch_default___3;
      case_1___3: /* CIL Label */ 
#line 468
      p = "Portrait";
#line 469
      goto switch_break___3;
      case_2___3: /* CIL Label */ 
#line 471
      p = "Landscape";
#line 472
      goto switch_break___3;
      switch_default___3: /* CIL Label */ 
#line 474
      p = "Unknown";
      switch_break___3: /* CIL Label */ ;
      }
      {
#line 476
      sprintf((char */* __restrict  */)(buf), (char const   */* __restrict  */)"  page orientation %s\n",
              p);
#line 477
      (*dfn)(ptr, (char const   *)(buf));
      }
    }
#line 479
    if ((dsc->page + i)->viewing_orientation) {
      {
#line 480
      sprintf((char */* __restrict  */)(buf), (char const   */* __restrict  */)"  viewing orientation %f %f %f %f\n",
              (double )((dsc->page + i)->viewing_orientation)->xx, (double )((dsc->page + i)->viewing_orientation)->xy,
              (double )((dsc->page + i)->viewing_orientation)->yx, (double )((dsc->page + i)->viewing_orientation)->yy);
#line 485
      (*dfn)(ptr, (char const   *)(buf));
      }
    }
#line 487
    if ((dsc->page + i)->crop_box) {
      {
#line 488
      sprintf((char */* __restrict  */)(buf), (char const   */* __restrict  */)"pagecropbox %f %f %f %f\n",
              (double )((dsc->page + i)->crop_box)->fllx, (double )((dsc->page + i)->crop_box)->flly,
              (double )((dsc->page + i)->crop_box)->furx, (double )((dsc->page + i)->crop_box)->fury);
#line 491
      (*dfn)(ptr, (char const   *)(buf));
      }
    }
#line 455
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 494
  sprintf((char */* __restrict  */)(fmtbuf), (char const   */* __restrict  */)"trailer %%%s %%%s\n",
          offset_fmt, offset_fmt);
#line 495
  sprintf((char */* __restrict  */)(buf), (char const   */* __restrict  */)(fmtbuf),
          dsc->begintrailer, dsc->endtrailer);
#line 496
  (*dfn)(ptr, (char const   *)(buf));
  }
#line 497
  if (pdcs) {
#line 498
    if (dsc->dcs1) {
      {
#line 499
      sprintf((char */* __restrict  */)(buf), (char const   */* __restrict  */)"DCS 1.0 separations\n");
      }
    } else {
      {
#line 501
      sprintf((char */* __restrict  */)(buf), (char const   */* __restrict  */)"DCS 2.0 separations\n");
      }
    }
    {
#line 502
    (*dfn)(ptr, (char const   *)(buf));
    }
  }
  {
#line 504
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 504
    if (! pdcs) {
#line 504
      goto while_break___1;
    }
#line 505
    if (pdcs->location) {
      {
#line 505
      tmp___2 = dsc_stricmp((char const   *)pdcs->location, "Local");
      }
#line 505
      if (tmp___2 == 0) {
        {
#line 506
        sprintf((char */* __restrict  */)(buf), (char const   */* __restrict  */)" %s %s\n",
                pdcs->colourname, pdcs->filename);
        }
      } else {
        {
#line 508
        sprintf((char */* __restrict  */)(fmtbuf), (char const   */* __restrict  */)" %%s #%%%s %%%s\n",
                offset_fmt, offset_fmt);
#line 509
        sprintf((char */* __restrict  */)(buf), (char const   */* __restrict  */)(fmtbuf),
                pdcs->colourname, pdcs->begin, pdcs->end);
        }
      }
    } else {
      {
#line 508
      sprintf((char */* __restrict  */)(fmtbuf), (char const   */* __restrict  */)" %%s #%%%s %%%s\n",
              offset_fmt, offset_fmt);
#line 509
      sprintf((char */* __restrict  */)(buf), (char const   */* __restrict  */)(fmtbuf),
              pdcs->colourname, pdcs->begin, pdcs->end);
      }
    }
    {
#line 511
    (*dfn)(ptr, (char const   *)(buf));
#line 512
    pdcs = pdcs->next;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 514
  if (colour) {
    {
#line 515
    sprintf((char */* __restrict  */)(buf), (char const   */* __restrict  */)"colours\n");
#line 516
    (*dfn)(ptr, (char const   *)(buf));
    }
  }
  {
#line 518
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 518
    if (! colour) {
#line 518
      goto while_break___2;
    }
    {
#line 521
    if ((unsigned int )colour->type == 1U) {
#line 521
      goto case_1___4;
    }
#line 524
    if ((unsigned int )colour->type == 2U) {
#line 524
      goto case_2___4;
    }
#line 527
    goto switch_default___4;
    case_1___4: /* CIL Label */ 
#line 522
    type = "Process";
#line 523
    goto switch_break___4;
    case_2___4: /* CIL Label */ 
#line 525
    type = "Custom";
#line 526
    goto switch_break___4;
    switch_default___4: /* CIL Label */ 
#line 528
    type = "Unknown";
    switch_break___4: /* CIL Label */ ;
    }
    {
#line 530
    sprintf((char */* __restrict  */)(buf), (char const   */* __restrict  */)" %s %s",
            colour->name, type);
#line 531
    (*dfn)(ptr, (char const   *)(buf));
    }
    {
#line 533
    if ((unsigned int )colour->custom == 2U) {
#line 533
      goto case_2___5;
    }
#line 537
    if ((unsigned int )colour->custom == 1U) {
#line 537
      goto case_1___5;
    }
#line 541
    goto switch_default___5;
    case_2___5: /* CIL Label */ 
    {
#line 534
    sprintf((char */* __restrict  */)(buf), (char const   */* __restrict  */)" CMYK %g %g %g %g\n",
            (double )colour->cyan, (double )colour->magenta, (double )colour->yellow,
            (double )colour->black);
    }
#line 536
    goto switch_break___5;
    case_1___5: /* CIL Label */ 
    {
#line 538
    sprintf((char */* __restrict  */)(buf), (char const   */* __restrict  */)" RGB %g %g %g\n",
            (double )colour->red, (double )colour->green, (double )colour->blue);
    }
#line 540
    goto switch_break___5;
    switch_default___5: /* CIL Label */ 
    {
#line 542
    sprintf((char */* __restrict  */)(buf), (char const   */* __restrict  */)"\n");
    }
    switch_break___5: /* CIL Label */ ;
    }
    {
#line 544
    (*dfn)(ptr, (char const   *)(buf));
#line 545
    colour = colour->next;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
#line 547
  i = 0U;
  {
#line 547
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 547
    if (dsc->media) {
#line 547
      if (! (i < dsc->media_count)) {
#line 547
        goto while_break___3;
      }
    } else {
#line 547
      goto while_break___3;
    }
#line 548
    if (*(dsc->media + i)) {
#line 549
      if ((*(dsc->media + i))->type) {
#line 549
        tmp___3 = (*(dsc->media + i))->type;
      } else {
#line 549
        tmp___3 = "";
      }
#line 549
      if ((*(dsc->media + i))->colour) {
#line 549
        tmp___4 = (*(dsc->media + i))->colour;
      } else {
#line 549
        tmp___4 = "";
      }
#line 549
      if ((*(dsc->media + i))->name) {
#line 549
        tmp___5 = (*(dsc->media + i))->name;
      } else {
#line 549
        tmp___5 = "";
      }
      {
#line 549
      sprintf((char */* __restrict  */)(buf), (char const   */* __restrict  */)"media %d   (%.50s) %g %g %g (%.50s) (%.50s)\n",
              i, tmp___5, (double )(*(dsc->media + i))->width, (double )(*(dsc->media + i))->height,
              (double )(*(dsc->media + i))->weight, tmp___4, tmp___3);
#line 555
      (*dfn)(ptr, (char const   *)(buf));
      }
#line 556
      if ((*(dsc->media + i))->mediabox) {
        {
#line 557
        sprintf((char */* __restrict  */)(buf), (char const   */* __restrict  */)"  mediabox %d %d %d %d\n",
                ((*(dsc->media + i))->mediabox)->llx, ((*(dsc->media + i))->mediabox)->llx,
                ((*(dsc->media + i))->mediabox)->llx, ((*(dsc->media + i))->mediabox)->llx);
#line 562
        (*dfn)(ptr, (char const   *)(buf));
        }
      }
    }
#line 547
    i ++;
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 566
  (*dfn)(ptr, "== END DSC dump ==\n");
  }
#line 567
  return;
}
}
#line 63 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/cimg.h"
int image_platform_init(IMAGE *img ) ;
#line 72
unsigned int image_platform_format(unsigned int format ) ;
#line 75
int image_copy(IMAGE *newimg , IMAGE *oldimg , unsigned int format ) ;
#line 76
int image_copy_resize(IMAGE *newimg , IMAGE *oldimg , unsigned int format , float xddpi ,
                      float yddpi , float xrdpi , float yrdpi ) ;
#line 78
unsigned char colour_to_grey(unsigned char r , unsigned char g , unsigned char b ) ;
#line 80
void image_colour(unsigned int format , int index___0 , unsigned char *r , unsigned char *g ,
                  unsigned char *b ) ;
#line 82
int image_depth(IMAGE *img ) ;
#line 84
int image_to_mono(IMAGE *img , unsigned char *dest , unsigned char *source ) ;
#line 86
int image_to_grey(IMAGE *img , unsigned char *dest , unsigned char *source ) ;
#line 87
void image_1grey_to_8grey(int width , unsigned char *dest , unsigned char *source ) ;
#line 88
void image_4grey_to_8grey(int width , unsigned char *dest , unsigned char *source ) ;
#line 89
void image_1native_to_8grey(int width , unsigned char *dest , unsigned char *source ) ;
#line 90
void image_4native_to_8grey(int width , unsigned char *dest , unsigned char *source ) ;
#line 91
void image_8native_to_8grey(int width , unsigned char *dest , unsigned char *source ) ;
#line 92
void image_24RGB_to_8grey(int width , unsigned char *dest , unsigned char *source ) ;
#line 94
void image_24BGR_to_8grey(int width , unsigned char *dest , unsigned char *source ) ;
#line 97
int image_to_24BGR(IMAGE *img , unsigned char *dest , unsigned char *source ) ;
#line 98
void image_4native_to_24BGR(int width , unsigned char *dest , unsigned char *source ) ;
#line 99
void image_32CMYK_to_24BGR(int width , unsigned char *dest , unsigned char *source ,
                           int sep ) ;
#line 101
void image_16RGB565_to_24BGR(int width , unsigned char *dest , unsigned char *source ) ;
#line 102
void image_16RGB555_to_24BGR(int width , unsigned char *dest , unsigned char *source ) ;
#line 103
void image_16BGR565_to_24BGR(int width , unsigned char *dest , unsigned char *source ) ;
#line 104
void image_16BGR555_to_24BGR(int width , unsigned char *dest , unsigned char *source ) ;
#line 106
int image_to_24RGB(IMAGE *img , unsigned char *dest , unsigned char *source ) ;
#line 107
void image_1grey_to_24RGB(int width , unsigned char *dest , unsigned char *source ) ;
#line 108
void image_4grey_to_24RGB(int width , unsigned char *dest , unsigned char *source ) ;
#line 109
void image_8grey_to_24RGB(int width , unsigned char *dest , unsigned char *source ) ;
#line 110
void image_1native_to_24RGB(int width , unsigned char *dest , unsigned char *source ) ;
#line 111
void image_4native_to_24RGB(int width , unsigned char *dest , unsigned char *source ) ;
#line 113
void image_32CMYK_to_24RGB(int width , unsigned char *dest , unsigned char *source ,
                           int sep ) ;
#line 114
void image_16RGB565_to_24RGB(int width , unsigned char *dest , unsigned char *source ) ;
#line 115
void image_16RGB555_to_24RGB(int width , unsigned char *dest , unsigned char *source ) ;
#line 116
void image_16BGR565_to_24RGB(int width , unsigned char *dest , unsigned char *source ) ;
#line 117
void image_16BGR555_to_24RGB(int width , unsigned char *dest , unsigned char *source ) ;
#line 119
int image_merge_cmyk(IMAGE *img , IMAGE *layer , float cyan , float magenta , float yellow ,
                     float black ) ;
#line 121
int image_down_scale(IMAGE *newimg , IMAGE *oldimg ) ;
#line 129
int image_to_eps(GFile *f , IMAGE *img , int llx , int lly , int urx , int ury , float fllx ,
                 float flly , float furx , float fury , int use_a85 , int compress ) ;
#line 131
int image_to_epsfile(IMAGE *img , char const   *filename , float xdpi , float ydpi ) ;
#line 132
int packbits(BYTE *comp , BYTE *raw , int length ) ;
#line 23 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/clzw.h"
lzw_state_t *lzw_new(void) ;
#line 41
void lzw_compress(lzw_state_t *state , unsigned char const   *inbuf , int *inlen ,
                  unsigned char *outbuf , int *outlen ) ;
#line 50
void lzw_free(lzw_state_t *state ) ;
#line 24 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/cimg.c"
static int a85write(char *line , unsigned char *buf , int count ) ;
#line 27 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/cimg.c"
void image_colour(unsigned int format , int index___0 , unsigned char *r , unsigned char *g ,
                  unsigned char *b ) 
{ 
  unsigned char tmp ;
  unsigned char tmp___0 ;
  int tmp___1 ;
  int one ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int one___0 ;
  int val ;
  unsigned char tmp___6 ;
  unsigned char tmp___7 ;
  unsigned char tmp___8 ;
  unsigned char tmp___9 ;
  int tmp___10 ;
  unsigned char tmp___11 ;
  unsigned char tmp___12 ;
  unsigned char tmp___13 ;
  unsigned char tmp___14 ;

  {
  {
#line 32
  if (((long )format & 15L) == 1L) {
#line 32
    goto case_1;
  }
#line 61
  if (((long )format & 15L) == 2L) {
#line 61
    goto case_2;
  }
#line 31
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 34
  if (((long )format & 65280L) == 256L) {
#line 34
    goto case_256;
  }
#line 37
  if (((long )format & 65280L) == 1024L) {
#line 37
    goto case_1024;
  }
#line 45
  if (((long )format & 65280L) == 2048L) {
#line 45
    goto case_2048;
  }
#line 33
  goto switch_break___0;
  case_256: /* CIL Label */ 
#line 35
  if (index___0) {
#line 35
    tmp___1 = 0;
  } else {
#line 35
    tmp___1 = 255;
  }
#line 35
  tmp___0 = (unsigned char )tmp___1;
#line 35
  *b = tmp___0;
#line 35
  tmp = tmp___0;
#line 35
  *g = tmp;
#line 35
  *r = tmp;
#line 36
  goto switch_break___0;
  case_1024: /* CIL Label */ 
#line 39
  if (index___0 & 8) {
#line 39
    tmp___2 = 255;
  } else {
#line 39
    tmp___2 = 128;
  }
#line 39
  one = tmp___2;
#line 40
  if (index___0 & 4) {
#line 40
    tmp___3 = one;
  } else {
#line 40
    tmp___3 = 0;
  }
#line 40
  *r = (unsigned char )tmp___3;
#line 41
  if (index___0 & 2) {
#line 41
    tmp___4 = one;
  } else {
#line 41
    tmp___4 = 0;
  }
#line 41
  *g = (unsigned char )tmp___4;
#line 42
  if (index___0 & 1) {
#line 42
    tmp___5 = one;
  } else {
#line 42
    tmp___5 = 0;
  }
#line 42
  *b = (unsigned char )tmp___5;
#line 44
  goto switch_break___0;
  case_2048: /* CIL Label */ 
#line 48
  if (index___0 < 64) {
#line 49
    one___0 = 85;
#line 50
    *r = (unsigned char )(((index___0 & 48) >> 4) * one___0);
#line 51
    *g = (unsigned char )(((index___0 & 12) >> 2) * one___0);
#line 52
    *b = (unsigned char )((index___0 & 3) * one___0);
  } else {
#line 55
    val = index___0 & 31;
#line 56
    tmp___7 = (unsigned char )((val << 3) + (val >> 2));
#line 56
    *b = tmp___7;
#line 56
    tmp___6 = tmp___7;
#line 56
    *g = tmp___6;
#line 56
    *r = tmp___6;
  }
#line 58
  goto switch_break___0;
  switch_break___0: /* CIL Label */ ;
  }
#line 60
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 63
  if (((long )format & 65280L) == 256L) {
#line 63
    goto case_256___0;
  }
#line 66
  if (((long )format & 65280L) == 1024L) {
#line 66
    goto case_1024___0;
  }
#line 69
  if (((long )format & 65280L) == 2048L) {
#line 69
    goto case_2048___0;
  }
#line 62
  goto switch_break___1;
  case_256___0: /* CIL Label */ 
#line 64
  if (index___0) {
#line 64
    tmp___10 = 255;
  } else {
#line 64
    tmp___10 = 0;
  }
#line 64
  tmp___9 = (unsigned char )tmp___10;
#line 64
  *b = tmp___9;
#line 64
  tmp___8 = tmp___9;
#line 64
  *g = tmp___8;
#line 64
  *r = tmp___8;
#line 65
  goto switch_break___1;
  case_1024___0: /* CIL Label */ 
#line 67
  tmp___12 = (unsigned char )((index___0 << 4) + index___0);
#line 67
  *b = tmp___12;
#line 67
  tmp___11 = tmp___12;
#line 67
  *g = tmp___11;
#line 67
  *r = tmp___11;
#line 68
  goto switch_break___1;
  case_2048___0: /* CIL Label */ 
#line 70
  tmp___14 = (unsigned char )index___0;
#line 70
  *b = tmp___14;
#line 70
  tmp___13 = tmp___14;
#line 70
  *g = tmp___13;
#line 70
  *r = tmp___13;
#line 71
  goto switch_break___1;
  switch_break___1: /* CIL Label */ ;
  }
#line 73
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 75
  return;
}
}
#line 77 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/cimg.c"
unsigned char colour_to_grey(unsigned char r , unsigned char g , unsigned char b ) 
{ 


  {
#line 80
  return ((unsigned char )((((int )r * 77) / 255 + ((int )g * 150) / 255) + ((int )b * 28) / 255));
}
}
#line 89 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/cimg.c"
void image_4native_to_24BGR(int width , unsigned char *dest , unsigned char *source ) 
{ 
  int i ;
  int val ;

  {
#line 94
  i = 0;
  {
#line 94
  while (1) {
    while_continue: /* CIL Label */ ;
#line 94
    if (! (i < width)) {
#line 94
      goto while_break;
    }
#line 95
    val = (int )*source;
#line 96
    if (i & 1) {
#line 97
      source ++;
    } else {
#line 99
      val >>= 4;
    }
    {
#line 100
    val &= 15;
#line 101
    image_colour(1025U, val, dest + 2, dest + 1, dest);
#line 103
    dest += 3;
#line 94
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 105
  return;
}
}
#line 110 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/cimg.c"
void image_16BGR555_to_24BGR(int width , unsigned char *dest , unsigned char *source ) 
{ 
  int i ;
  WORD w ;
  unsigned char value ;
  unsigned char *tmp ;
  unsigned char *tmp___0 ;
  unsigned char *tmp___1 ;

  {
#line 116
  i = 0;
  {
#line 116
  while (1) {
    while_continue: /* CIL Label */ ;
#line 116
    if (! (i < width)) {
#line 116
      goto while_break;
    }
#line 117
    w = (WORD )((int )*(source + 0) + ((int )*(source + 1) << 8));
#line 118
    value = (unsigned char )((int )w & 31);
#line 119
    tmp = dest;
#line 119
    dest ++;
#line 119
    *tmp = (unsigned char )(((int )value << 3) + ((int )value >> 2));
#line 120
    value = (unsigned char )(((int )w >> 5) & 31);
#line 121
    tmp___0 = dest;
#line 121
    dest ++;
#line 121
    *tmp___0 = (unsigned char )(((int )value << 3) + ((int )value >> 2));
#line 122
    value = (unsigned char )(((int )w >> 10) & 31);
#line 123
    tmp___1 = dest;
#line 123
    dest ++;
#line 123
    *tmp___1 = (unsigned char )(((int )value << 3) + ((int )value >> 2));
#line 124
    source += 2;
#line 116
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 126
  return;
}
}
#line 130 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/cimg.c"
void image_16BGR565_to_24BGR(int width , unsigned char *dest , unsigned char *source ) 
{ 
  int i ;
  WORD w ;
  unsigned char value ;
  unsigned char *tmp ;
  unsigned char *tmp___0 ;
  unsigned char *tmp___1 ;

  {
#line 136
  i = 0;
  {
#line 136
  while (1) {
    while_continue: /* CIL Label */ ;
#line 136
    if (! (i < width)) {
#line 136
      goto while_break;
    }
#line 137
    w = (WORD )((int )*(source + 0) + ((int )*(source + 1) << 8));
#line 138
    value = (unsigned char )((int )w & 31);
#line 139
    tmp = dest;
#line 139
    dest ++;
#line 139
    *tmp = (unsigned char )(((int )value << 3) + ((int )value >> 2));
#line 140
    value = (unsigned char )(((int )w >> 5) & 63);
#line 141
    tmp___0 = dest;
#line 141
    dest ++;
#line 141
    *tmp___0 = (unsigned char )(((int )value << 2) + ((int )value >> 4));
#line 142
    value = (unsigned char )(((int )w >> 11) & 31);
#line 143
    tmp___1 = dest;
#line 143
    dest ++;
#line 143
    *tmp___1 = (unsigned char )(((int )value << 3) + ((int )value >> 2));
#line 144
    source += 2;
#line 136
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 146
  return;
}
}
#line 150 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/cimg.c"
void image_16RGB555_to_24BGR(int width , unsigned char *dest , unsigned char *source ) 
{ 
  int i ;
  WORD w ;
  unsigned char value ;
  unsigned char *tmp ;
  unsigned char *tmp___0 ;
  unsigned char *tmp___1 ;

  {
#line 156
  i = 0;
  {
#line 156
  while (1) {
    while_continue: /* CIL Label */ ;
#line 156
    if (! (i < width)) {
#line 156
      goto while_break;
    }
#line 157
    w = (WORD )(((int )*(source + 0) << 8) + (int )*(source + 1));
#line 158
    value = (unsigned char )((int )w & 31);
#line 159
    tmp = dest;
#line 159
    dest ++;
#line 159
    *tmp = (unsigned char )(((int )value << 3) + ((int )value >> 2));
#line 160
    value = (unsigned char )(((int )w >> 5) & 31);
#line 161
    tmp___0 = dest;
#line 161
    dest ++;
#line 161
    *tmp___0 = (unsigned char )(((int )value << 3) + ((int )value >> 2));
#line 162
    value = (unsigned char )(((int )w >> 10) & 31);
#line 163
    tmp___1 = dest;
#line 163
    dest ++;
#line 163
    *tmp___1 = (unsigned char )(((int )value << 3) + ((int )value >> 2));
#line 164
    source += 2;
#line 156
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 166
  return;
}
}
#line 170 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/cimg.c"
void image_16RGB565_to_24BGR(int width , unsigned char *dest , unsigned char *source ) 
{ 
  int i ;
  WORD w ;
  unsigned char value ;
  unsigned char *tmp ;
  unsigned char *tmp___0 ;
  unsigned char *tmp___1 ;

  {
#line 176
  i = 0;
  {
#line 176
  while (1) {
    while_continue: /* CIL Label */ ;
#line 176
    if (! (i < width)) {
#line 176
      goto while_break;
    }
#line 177
    w = (WORD )(((int )*(source + 0) << 8) + (int )*(source + 1));
#line 178
    value = (unsigned char )((int )w & 31);
#line 179
    tmp = dest;
#line 179
    dest ++;
#line 179
    *tmp = (unsigned char )(((int )value << 3) + ((int )value >> 2));
#line 180
    value = (unsigned char )(((int )w >> 5) & 63);
#line 181
    tmp___0 = dest;
#line 181
    dest ++;
#line 181
    *tmp___0 = (unsigned char )(((int )value << 2) + ((int )value >> 4));
#line 182
    value = (unsigned char )(((int )w >> 11) & 31);
#line 183
    tmp___1 = dest;
#line 183
    dest ++;
#line 183
    *tmp___1 = (unsigned char )(((int )value << 3) + ((int )value >> 2));
#line 184
    source += 2;
#line 176
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 186
  return;
}
}
#line 190 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/cimg.c"
void image_32CMYK_to_24BGR(int width , unsigned char *dest , unsigned char *source ,
                           int sep ) 
{ 
  int i ;
  int cyan ;
  int magenta ;
  int yellow ;
  int black ;
  unsigned char *tmp ;
  unsigned char *tmp___0 ;
  unsigned char *tmp___1 ;

  {
#line 196
  i = 0;
  {
#line 196
  while (1) {
    while_continue: /* CIL Label */ ;
#line 196
    if (! (i < width)) {
#line 196
      goto while_break;
    }
#line 197
    cyan = (int )*(source + 0);
#line 198
    magenta = (int )*(source + 1);
#line 199
    yellow = (int )*(source + 2);
#line 200
    black = (int )*(source + 3);
#line 201
    if (! (sep & 8)) {
#line 202
      cyan = 0;
    }
#line 203
    if (! (sep & 4)) {
#line 204
      magenta = 0;
    }
#line 205
    if (! (sep & 2)) {
#line 206
      yellow = 0;
    }
#line 207
    if (! (sep & 1)) {
#line 208
      black = 0;
    }
#line 209
    tmp = dest;
#line 209
    dest ++;
#line 209
    *tmp = (unsigned char )(((255 - yellow) * (255 - black)) / 255);
#line 211
    tmp___0 = dest;
#line 211
    dest ++;
#line 211
    *tmp___0 = (unsigned char )(((255 - magenta) * (255 - black)) / 255);
#line 213
    tmp___1 = dest;
#line 213
    dest ++;
#line 213
    *tmp___1 = (unsigned char )(((255 - cyan) * (255 - black)) / 255);
#line 215
    source += 4;
#line 196
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 217
  return;
}
}
#line 219 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/cimg.c"
int image_to_24BGR(IMAGE *img , unsigned char *dest , unsigned char *source ) 
{ 
  unsigned char *d ;
  unsigned char *s ;
  int width ;
  unsigned int alpha ;
  BOOL bigendian ;
  int code ;
  int i ;
  unsigned char *tmp ;
  unsigned char *tmp___0 ;
  unsigned char *tmp___1 ;
  unsigned char *tmp___2 ;
  unsigned char *tmp___3 ;
  unsigned char *tmp___4 ;
  unsigned char *tmp___5 ;
  unsigned char *tmp___6 ;
  unsigned char *tmp___7 ;
  unsigned char *tmp___8 ;

  {
#line 222
  d = dest;
#line 223
  s = source;
#line 224
  width = (int )img->width;
#line 225
  alpha = (unsigned int )((long )img->format & 112L);
#line 226
  bigendian = ((long )img->format & 65536L) == 0L;
#line 227
  code = -1;
  {
#line 231
  if (((long )img->format & 15L) == 1L) {
#line 231
    goto case_1;
  }
#line 270
  if (((long )img->format & 15L) == 2L) {
#line 270
    goto case_2;
  }
#line 284
  if (((long )img->format & 15L) == 4L) {
#line 284
    goto case_4;
  }
#line 308
  if (((long )img->format & 15L) == 8L) {
#line 308
    goto case_8;
  }
#line 230
  goto switch_break;
  case_1: /* CIL Label */ 
#line 232
  if (((long )img->format & 65280L) == 256L) {
    {
#line 233
    image_1native_to_24RGB(width, dest, source);
#line 234
    code = 0;
    }
  } else
#line 236
  if (((long )img->format & 65280L) == 1024L) {
    {
#line 237
    image_4native_to_24BGR(width, dest, source);
#line 238
    code = 0;
    }
  } else
#line 240
  if (((long )img->format & 65280L) == 2048L) {
#line 241
    i = 0;
    {
#line 241
    while (1) {
      while_continue: /* CIL Label */ ;
#line 241
      if (! (i < width)) {
#line 241
        goto while_break;
      }
      {
#line 242
      tmp = s;
#line 242
      s ++;
#line 242
      image_colour(img->format, (int )*tmp, d + 2, d + 1, d);
#line 243
      d += 3;
#line 241
      i ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 245
    code = 0;
  } else
#line 247
  if (((long )img->format & 65280L) == 8192L) {
#line 248
    if (bigendian) {
#line 249
      if (((long )img->format & 262144L) == 0L) {
        {
#line 251
        image_16RGB555_to_24BGR((int )img->width, dest, source);
        }
      } else {
        {
#line 254
        image_16RGB565_to_24BGR((int )img->width, dest, source);
        }
      }
    } else
#line 258
    if (((long )img->format & 262144L) == 0L) {
      {
#line 260
      image_16BGR555_to_24BGR((int )img->width, dest, source);
      }
    } else {
      {
#line 264
      image_16BGR565_to_24BGR((int )img->width, dest, source);
      }
    }
#line 267
    code = 0;
  }
#line 269
  goto switch_break;
  case_2: /* CIL Label */ 
#line 271
  if (((long )img->format & 65280L) == 256L) {
    {
#line 272
    image_1grey_to_24RGB(width, dest, source);
#line 273
    code = 0;
    }
  } else
#line 275
  if (((long )img->format & 65280L) == 1024L) {
    {
#line 276
    image_4grey_to_24RGB(width, dest, source);
#line 277
    code = 0;
    }
  } else
#line 279
  if (((long )img->format & 65280L) == 2048L) {
    {
#line 280
    image_8grey_to_24RGB(width, dest, source);
#line 281
    code = 0;
    }
  }
#line 283
  goto switch_break;
  case_4: /* CIL Label */ 
#line 285
  if (((long )img->format & 65280L) == 2048L) {
#line 286
    i = 0;
    {
#line 286
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 286
      if (! (i < width)) {
#line 286
        goto while_break___0;
      }
#line 287
      if (alpha == 16U) {
#line 289
        s ++;
      } else
#line 287
      if (alpha == 64U) {
#line 289
        s ++;
      }
#line 290
      if (bigendian) {
#line 291
        tmp___0 = d;
#line 291
        d ++;
#line 291
        *tmp___0 = *(s + 2);
#line 292
        tmp___1 = d;
#line 292
        d ++;
#line 292
        *tmp___1 = *(s + 1);
#line 293
        tmp___2 = d;
#line 293
        d ++;
#line 293
        *tmp___2 = *(s + 0);
#line 294
        s += 3;
      } else {
#line 297
        tmp___3 = d;
#line 297
        d ++;
#line 297
        tmp___4 = s;
#line 297
        s ++;
#line 297
        *tmp___3 = *tmp___4;
#line 298
        tmp___5 = d;
#line 298
        d ++;
#line 298
        tmp___6 = s;
#line 298
        s ++;
#line 298
        *tmp___5 = *tmp___6;
#line 299
        tmp___7 = d;
#line 299
        d ++;
#line 299
        tmp___8 = s;
#line 299
        s ++;
#line 299
        *tmp___7 = *tmp___8;
      }
#line 301
      if (alpha == 32U) {
#line 303
        s ++;
      } else
#line 301
      if (alpha == 128U) {
#line 303
        s ++;
      }
#line 286
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 305
    code = 0;
  }
#line 307
  goto switch_break;
  case_8: /* CIL Label */ 
#line 309
  if (((long )img->format & 65280L) == 2048L) {
    {
#line 310
    image_32CMYK_to_24BGR(width, dest, source, 15);
#line 312
    code = 0;
    }
  }
#line 314
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 316
  return (code);
}
}
#line 324 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/cimg.c"
void image_16BGR555_to_24RGB(int width , unsigned char *dest , unsigned char *source ) 
{ 
  int i ;
  WORD w ;
  unsigned char value ;
  unsigned char *tmp ;
  unsigned char *tmp___0 ;
  unsigned char *tmp___1 ;

  {
#line 330
  i = 0;
  {
#line 330
  while (1) {
    while_continue: /* CIL Label */ ;
#line 330
    if (! (i < width)) {
#line 330
      goto while_break;
    }
#line 331
    w = (WORD )((int )*(source + 0) + ((int )*(source + 1) << 8));
#line 332
    value = (unsigned char )(((int )w >> 10) & 31);
#line 333
    tmp = dest;
#line 333
    dest ++;
#line 333
    *tmp = (unsigned char )(((int )value << 3) + ((int )value >> 2));
#line 334
    value = (unsigned char )(((int )w >> 5) & 31);
#line 335
    tmp___0 = dest;
#line 335
    dest ++;
#line 335
    *tmp___0 = (unsigned char )(((int )value << 3) + ((int )value >> 2));
#line 336
    value = (unsigned char )((int )w & 31);
#line 337
    tmp___1 = dest;
#line 337
    dest ++;
#line 337
    *tmp___1 = (unsigned char )(((int )value << 3) + ((int )value >> 2));
#line 338
    source += 2;
#line 330
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 340
  return;
}
}
#line 344 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/cimg.c"
void image_16BGR565_to_24RGB(int width , unsigned char *dest , unsigned char *source ) 
{ 
  int i ;
  WORD w ;
  unsigned char value ;
  unsigned char *tmp ;
  unsigned char *tmp___0 ;
  unsigned char *tmp___1 ;

  {
#line 350
  i = 0;
  {
#line 350
  while (1) {
    while_continue: /* CIL Label */ ;
#line 350
    if (! (i < width)) {
#line 350
      goto while_break;
    }
#line 351
    w = (WORD )((int )*(source + 0) + ((int )*(source + 1) << 8));
#line 352
    value = (unsigned char )(((int )w >> 11) & 31);
#line 353
    tmp = dest;
#line 353
    dest ++;
#line 353
    *tmp = (unsigned char )(((int )value << 3) + ((int )value >> 2));
#line 354
    value = (unsigned char )(((int )w >> 5) & 63);
#line 355
    tmp___0 = dest;
#line 355
    dest ++;
#line 355
    *tmp___0 = (unsigned char )(((int )value << 2) + ((int )value >> 4));
#line 356
    value = (unsigned char )((int )w & 31);
#line 357
    tmp___1 = dest;
#line 357
    dest ++;
#line 357
    *tmp___1 = (unsigned char )(((int )value << 3) + ((int )value >> 2));
#line 358
    source += 2;
#line 350
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 360
  return;
}
}
#line 364 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/cimg.c"
void image_16RGB555_to_24RGB(int width , unsigned char *dest , unsigned char *source ) 
{ 
  int i ;
  WORD w ;
  unsigned char value ;
  unsigned char *tmp ;
  unsigned char *tmp___0 ;
  unsigned char *tmp___1 ;

  {
#line 370
  i = 0;
  {
#line 370
  while (1) {
    while_continue: /* CIL Label */ ;
#line 370
    if (! (i < width)) {
#line 370
      goto while_break;
    }
#line 371
    w = (WORD )(((int )*(source + 0) << 8) + (int )*(source + 1));
#line 372
    value = (unsigned char )(((int )w >> 10) & 31);
#line 373
    tmp = dest;
#line 373
    dest ++;
#line 373
    *tmp = (unsigned char )(((int )value << 3) + ((int )value >> 2));
#line 374
    value = (unsigned char )(((int )w >> 5) & 31);
#line 375
    tmp___0 = dest;
#line 375
    dest ++;
#line 375
    *tmp___0 = (unsigned char )(((int )value << 3) + ((int )value >> 2));
#line 376
    value = (unsigned char )((int )w & 31);
#line 377
    tmp___1 = dest;
#line 377
    dest ++;
#line 377
    *tmp___1 = (unsigned char )(((int )value << 3) + ((int )value >> 2));
#line 378
    source += 2;
#line 370
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 380
  return;
}
}
#line 384 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/cimg.c"
void image_16RGB565_to_24RGB(int width , unsigned char *dest , unsigned char *source ) 
{ 
  int i ;
  WORD w ;
  unsigned char value ;
  unsigned char *tmp ;
  unsigned char *tmp___0 ;
  unsigned char *tmp___1 ;

  {
#line 390
  i = 0;
  {
#line 390
  while (1) {
    while_continue: /* CIL Label */ ;
#line 390
    if (! (i < width)) {
#line 390
      goto while_break;
    }
#line 391
    w = (WORD )(((int )*(source + 0) << 8) + (int )*(source + 1));
#line 392
    value = (unsigned char )(((int )w >> 11) & 31);
#line 393
    tmp = dest;
#line 393
    dest ++;
#line 393
    *tmp = (unsigned char )(((int )value << 3) + ((int )value >> 2));
#line 394
    value = (unsigned char )(((int )w >> 5) & 63);
#line 395
    tmp___0 = dest;
#line 395
    dest ++;
#line 395
    *tmp___0 = (unsigned char )(((int )value << 2) + ((int )value >> 4));
#line 396
    value = (unsigned char )((int )w & 31);
#line 397
    tmp___1 = dest;
#line 397
    dest ++;
#line 397
    *tmp___1 = (unsigned char )(((int )value << 3) + ((int )value >> 2));
#line 398
    source += 2;
#line 390
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 400
  return;
}
}
#line 404 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/cimg.c"
void image_32CMYK_to_24RGB(int width , unsigned char *dest , unsigned char *source ,
                           int sep ) 
{ 
  int i ;
  int cyan ;
  int magenta ;
  int yellow ;
  int black ;
  unsigned char *tmp ;
  unsigned char *tmp___0 ;
  unsigned char *tmp___1 ;

  {
#line 410
  i = 0;
  {
#line 410
  while (1) {
    while_continue: /* CIL Label */ ;
#line 410
    if (! (i < width)) {
#line 410
      goto while_break;
    }
#line 411
    cyan = (int )*(source + 0);
#line 412
    magenta = (int )*(source + 1);
#line 413
    yellow = (int )*(source + 2);
#line 414
    black = (int )*(source + 3);
#line 415
    if (! (sep & 8)) {
#line 416
      cyan = 0;
    }
#line 417
    if (! (sep & 4)) {
#line 418
      magenta = 0;
    }
#line 419
    if (! (sep & 2)) {
#line 420
      yellow = 0;
    }
#line 421
    if (! (sep & 1)) {
#line 422
      black = 0;
    }
#line 423
    tmp = dest;
#line 423
    dest ++;
#line 423
    *tmp = (unsigned char )(((255 - cyan) * (255 - black)) / 255);
#line 425
    tmp___0 = dest;
#line 425
    dest ++;
#line 425
    *tmp___0 = (unsigned char )(((255 - magenta) * (255 - black)) / 255);
#line 427
    tmp___1 = dest;
#line 427
    dest ++;
#line 427
    *tmp___1 = (unsigned char )(((255 - yellow) * (255 - black)) / 255);
#line 429
    source += 4;
#line 410
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 431
  return;
}
}
#line 434 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/cimg.c"
void image_1grey_to_24RGB(int width , unsigned char *dest , unsigned char *source ) 
{ 
  int i ;
  unsigned char tmp ;
  unsigned char tmp___0 ;
  unsigned char tmp___1 ;
  unsigned char tmp___2 ;

  {
#line 438
  i = 0;
  {
#line 438
  while (1) {
    while_continue: /* CIL Label */ ;
#line 438
    if (! (i < width)) {
#line 438
      goto while_break;
    }
#line 439
    if ((int )*source & (1 << (7 - (i & 7)))) {
#line 440
      tmp___0 = (unsigned char)255;
#line 440
      *(dest + 2) = tmp___0;
#line 440
      tmp = tmp___0;
#line 440
      *(dest + 1) = tmp;
#line 440
      *(dest + 0) = tmp;
    } else {
#line 442
      tmp___2 = (unsigned char)0;
#line 442
      *(dest + 2) = tmp___2;
#line 442
      tmp___1 = tmp___2;
#line 442
      *(dest + 1) = tmp___1;
#line 442
      *(dest + 0) = tmp___1;
    }
#line 443
    dest += 3;
#line 444
    if ((i & 7) == 7) {
#line 445
      source ++;
    }
#line 438
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 447
  return;
}
}
#line 450 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/cimg.c"
void image_4grey_to_24RGB(int width , unsigned char *dest , unsigned char *source ) 
{ 
  int i ;
  int val ;
  unsigned char tmp ;
  unsigned char tmp___0 ;

  {
#line 455
  i = 0;
  {
#line 455
  while (1) {
    while_continue: /* CIL Label */ ;
#line 455
    if (! (i < width)) {
#line 455
      goto while_break;
    }
#line 456
    if (i & 1) {
#line 457
      val = (int )*source & 15;
#line 458
      source ++;
    } else {
#line 461
      val = ((int )*source >> 4) & 15;
    }
#line 462
    val += val << 4;
#line 463
    tmp___0 = (unsigned char )val;
#line 463
    *(dest + 2) = tmp___0;
#line 463
    tmp = tmp___0;
#line 463
    *(dest + 1) = tmp;
#line 463
    *(dest + 0) = tmp;
#line 464
    dest += 3;
#line 455
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 466
  return;
}
}
#line 469 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/cimg.c"
void image_8grey_to_24RGB(int width , unsigned char *dest , unsigned char *source ) 
{ 
  int i ;
  unsigned char tmp ;
  unsigned char tmp___0 ;
  unsigned char *tmp___1 ;

  {
#line 473
  i = 0;
  {
#line 473
  while (1) {
    while_continue: /* CIL Label */ ;
#line 473
    if (! (i < width)) {
#line 473
      goto while_break;
    }
#line 474
    tmp___1 = source;
#line 474
    source ++;
#line 474
    tmp___0 = *tmp___1;
#line 474
    *(dest + 2) = tmp___0;
#line 474
    tmp = tmp___0;
#line 474
    *(dest + 1) = tmp;
#line 474
    *(dest + 0) = tmp;
#line 475
    dest += 3;
#line 473
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 477
  return;
}
}
#line 480 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/cimg.c"
void image_1native_to_24RGB(int width , unsigned char *dest , unsigned char *source ) 
{ 
  int i ;
  unsigned char tmp ;
  unsigned char tmp___0 ;
  unsigned char tmp___1 ;
  unsigned char tmp___2 ;

  {
#line 484
  i = 0;
  {
#line 484
  while (1) {
    while_continue: /* CIL Label */ ;
#line 484
    if (! (i < width)) {
#line 484
      goto while_break;
    }
#line 485
    if ((int )*source & (1 << (7 - (i & 7)))) {
#line 486
      tmp___0 = (unsigned char)0;
#line 486
      *(dest + 2) = tmp___0;
#line 486
      tmp = tmp___0;
#line 486
      *(dest + 1) = tmp;
#line 486
      *(dest + 0) = tmp;
    } else {
#line 488
      tmp___2 = (unsigned char)255;
#line 488
      *(dest + 2) = tmp___2;
#line 488
      tmp___1 = tmp___2;
#line 488
      *(dest + 1) = tmp___1;
#line 488
      *(dest + 0) = tmp___1;
    }
#line 489
    dest += 3;
#line 490
    if ((i & 7) == 7) {
#line 491
      source ++;
    }
#line 484
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 493
  return;
}
}
#line 496 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/cimg.c"
void image_4native_to_24RGB(int width , unsigned char *dest , unsigned char *source ) 
{ 
  int i ;
  int val ;

  {
#line 501
  i = 0;
  {
#line 501
  while (1) {
    while_continue: /* CIL Label */ ;
#line 501
    if (! (i < width)) {
#line 501
      goto while_break;
    }
#line 502
    val = (int )*source;
#line 503
    if (i & 1) {
#line 504
      source ++;
    } else {
#line 506
      val >>= 4;
    }
    {
#line 507
    val &= 15;
#line 508
    image_colour(1025U, val, dest, dest + 1, dest + 2);
#line 510
    dest += 3;
#line 501
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 512
  return;
}
}
#line 514 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/cimg.c"
int image_to_24RGB(IMAGE *img , unsigned char *dest , unsigned char *source ) 
{ 
  unsigned char *d ;
  unsigned char *s ;
  int width ;
  unsigned int alpha ;
  BOOL bigendian ;
  int i ;
  int code ;
  unsigned char *tmp ;
  unsigned char *tmp___0 ;
  unsigned char *tmp___1 ;
  unsigned char *tmp___2 ;
  unsigned char *tmp___3 ;
  unsigned char *tmp___4 ;
  unsigned char *tmp___5 ;
  unsigned char *tmp___6 ;
  unsigned char *tmp___7 ;
  unsigned char *tmp___8 ;

  {
#line 517
  d = dest;
#line 518
  s = source;
#line 519
  width = (int )img->width;
#line 520
  alpha = (unsigned int )((long )img->format & 112L);
#line 521
  bigendian = ((long )img->format & 65536L) == 0L;
#line 523
  code = -1;
  {
#line 526
  if (((long )img->format & 15L) == 1L) {
#line 526
    goto case_1;
  }
#line 565
  if (((long )img->format & 15L) == 2L) {
#line 565
    goto case_2;
  }
#line 579
  if (((long )img->format & 15L) == 4L) {
#line 579
    goto case_4;
  }
#line 603
  if (((long )img->format & 15L) == 8L) {
#line 603
    goto case_8;
  }
#line 525
  goto switch_break;
  case_1: /* CIL Label */ 
#line 527
  if (((long )img->format & 65280L) == 256L) {
    {
#line 528
    image_1native_to_24RGB((int )img->width, dest, source);
#line 529
    code = 0;
    }
  }
#line 531
  if (((long )img->format & 65280L) == 1024L) {
    {
#line 532
    image_4native_to_24RGB((int )img->width, dest, source);
#line 533
    code = 0;
    }
  }
#line 535
  if (((long )img->format & 65280L) == 2048L) {
#line 536
    i = 0;
    {
#line 536
    while (1) {
      while_continue: /* CIL Label */ ;
#line 536
      if (! (i < width)) {
#line 536
        goto while_break;
      }
      {
#line 537
      tmp = s;
#line 537
      s ++;
#line 537
      image_colour(img->format, (int )*tmp, d, d + 1, d + 2);
#line 538
      d += 3;
#line 536
      i ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 540
    code = 0;
  } else
#line 542
  if (((long )img->format & 65280L) == 8192L) {
#line 543
    if (bigendian) {
#line 544
      if (((long )img->format & 262144L) == 0L) {
        {
#line 546
        image_16RGB555_to_24RGB((int )img->width, dest, source);
        }
      } else {
        {
#line 549
        image_16RGB565_to_24RGB((int )img->width, dest, source);
        }
      }
    } else
#line 553
    if (((long )img->format & 262144L) == 0L) {
      {
#line 555
      image_16BGR555_to_24RGB((int )img->width, dest, source);
      }
    } else {
      {
#line 559
      image_16BGR565_to_24RGB((int )img->width, dest, source);
      }
    }
#line 562
    code = 0;
  }
#line 564
  goto switch_break;
  case_2: /* CIL Label */ 
#line 566
  if (((long )img->format & 65280L) == 256L) {
    {
#line 567
    image_1grey_to_24RGB(width, dest, source);
#line 568
    code = 0;
    }
  } else
#line 570
  if (((long )img->format & 65280L) == 1024L) {
    {
#line 571
    image_4grey_to_24RGB(width, dest, source);
#line 572
    code = 0;
    }
  } else
#line 574
  if (((long )img->format & 65280L) == 2048L) {
    {
#line 575
    image_8grey_to_24RGB(width, dest, source);
#line 576
    code = 0;
    }
  }
#line 578
  goto switch_break;
  case_4: /* CIL Label */ 
#line 580
  if (((long )img->format & 65280L) == 2048L) {
#line 581
    i = 0;
    {
#line 581
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 581
      if (! (i < width)) {
#line 581
        goto while_break___0;
      }
#line 582
      if (alpha == 16U) {
#line 584
        s ++;
      } else
#line 582
      if (alpha == 64U) {
#line 584
        s ++;
      }
#line 585
      if (bigendian) {
#line 586
        tmp___0 = d;
#line 586
        d ++;
#line 586
        tmp___1 = s;
#line 586
        s ++;
#line 586
        *tmp___0 = *tmp___1;
#line 587
        tmp___2 = d;
#line 587
        d ++;
#line 587
        tmp___3 = s;
#line 587
        s ++;
#line 587
        *tmp___2 = *tmp___3;
#line 588
        tmp___4 = d;
#line 588
        d ++;
#line 588
        tmp___5 = s;
#line 588
        s ++;
#line 588
        *tmp___4 = *tmp___5;
      } else {
#line 591
        tmp___6 = d;
#line 591
        d ++;
#line 591
        *tmp___6 = *(s + 2);
#line 592
        tmp___7 = d;
#line 592
        d ++;
#line 592
        *tmp___7 = *(s + 1);
#line 593
        tmp___8 = d;
#line 593
        d ++;
#line 593
        *tmp___8 = *(s + 0);
#line 594
        s += 3;
      }
#line 596
      if (alpha == 32U) {
#line 598
        s ++;
      } else
#line 596
      if (alpha == 128U) {
#line 598
        s ++;
      }
#line 581
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 600
    code = 0;
  }
#line 602
  goto switch_break;
  case_8: /* CIL Label */ 
#line 604
  if (((long )img->format & 65280L) == 2048L) {
    {
#line 605
    image_32CMYK_to_24RGB(width, dest, source, 15);
#line 607
    code = 0;
    }
  }
#line 609
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 611
  return (code);
}
}
#line 617 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/cimg.c"
void image_1grey_to_8grey(int width , unsigned char *dest , unsigned char *source ) 
{ 
  int i ;
  unsigned char *tmp ;
  unsigned char *tmp___0 ;

  {
#line 621
  i = 0;
  {
#line 621
  while (1) {
    while_continue: /* CIL Label */ ;
#line 621
    if (! (i < width)) {
#line 621
      goto while_break;
    }
#line 622
    if ((int )*source & (1 << (7 - (i & 7)))) {
#line 623
      tmp = dest;
#line 623
      dest ++;
#line 623
      *tmp = (unsigned char)255;
    } else {
#line 625
      tmp___0 = dest;
#line 625
      dest ++;
#line 625
      *tmp___0 = (unsigned char)0;
    }
#line 626
    if ((i & 7) == 7) {
#line 627
      source ++;
    }
#line 621
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 629
  return;
}
}
#line 631 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/cimg.c"
void image_4grey_to_8grey(int width , unsigned char *dest , unsigned char *source ) 
{ 
  int i ;
  int value ;
  unsigned char *tmp ;

  {
#line 636
  i = 0;
  {
#line 636
  while (1) {
    while_continue: /* CIL Label */ ;
#line 636
    if (! (i < width)) {
#line 636
      goto while_break;
    }
#line 637
    if (i & 1) {
#line 638
      value = ((int )*source >> 4) & 15;
    } else {
#line 640
      value = (int )*source & 15;
#line 641
      source ++;
    }
#line 643
    tmp = dest;
#line 643
    dest ++;
#line 643
    *tmp = (unsigned char )(value + (value << 4));
#line 636
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 645
  return;
}
}
#line 647 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/cimg.c"
void image_1native_to_8grey(int width , unsigned char *dest , unsigned char *source ) 
{ 
  int i ;
  unsigned char *tmp ;
  unsigned char *tmp___0 ;

  {
#line 651
  i = 0;
  {
#line 651
  while (1) {
    while_continue: /* CIL Label */ ;
#line 651
    if (! (i < width)) {
#line 651
      goto while_break;
    }
#line 652
    if ((int )*source & (1 << (7 - (i & 7)))) {
#line 653
      tmp = dest;
#line 653
      dest ++;
#line 653
      *tmp = (unsigned char)0;
    } else {
#line 655
      tmp___0 = dest;
#line 655
      dest ++;
#line 655
      *tmp___0 = (unsigned char)255;
    }
#line 656
    if ((i & 7) == 7) {
#line 657
      source ++;
    }
#line 651
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 659
  return;
}
}
#line 661 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/cimg.c"
void image_4native_to_8grey(int width , unsigned char *dest , unsigned char *source ) 
{ 
  int i ;
  int value ;
  unsigned char r ;
  unsigned char g ;
  unsigned char b ;
  unsigned char *tmp ;

  {
#line 667
  i = 0;
  {
#line 667
  while (1) {
    while_continue: /* CIL Label */ ;
#line 667
    if (! (i < width)) {
#line 667
      goto while_break;
    }
#line 668
    if (i & 1) {
#line 669
      value = ((int )*source >> 4) & 15;
    } else {
#line 671
      value = (int )*source & 15;
#line 672
      source ++;
    }
    {
#line 674
    image_colour(1025U, value, & r, & g, & b);
#line 676
    tmp = dest;
#line 676
    dest ++;
#line 676
    *tmp = colour_to_grey(r, g, b);
#line 667
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 678
  return;
}
}
#line 680 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/cimg.c"
void image_8native_to_8grey(int width , unsigned char *dest , unsigned char *source ) 
{ 
  int i ;
  int value ;
  unsigned char r ;
  unsigned char g ;
  unsigned char b ;
  unsigned char *tmp ;
  unsigned char *tmp___0 ;

  {
#line 686
  i = 0;
  {
#line 686
  while (1) {
    while_continue: /* CIL Label */ ;
#line 686
    if (! (i < width)) {
#line 686
      goto while_break;
    }
    {
#line 687
    tmp = source;
#line 687
    source ++;
#line 687
    value = (int )*tmp;
#line 688
    image_colour(2049U, value, & r, & g, & b);
#line 690
    tmp___0 = dest;
#line 690
    dest ++;
#line 690
    *tmp___0 = colour_to_grey(r, g, b);
#line 686
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 692
  return;
}
}
#line 695 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/cimg.c"
void image_24RGB_to_8grey(int width , unsigned char *dest , unsigned char *source ) 
{ 
  int i ;
  unsigned char *tmp ;

  {
#line 699
  i = 0;
  {
#line 699
  while (1) {
    while_continue: /* CIL Label */ ;
#line 699
    if (! (i < width)) {
#line 699
      goto while_break;
    }
    {
#line 700
    tmp = dest;
#line 700
    dest ++;
#line 700
    *tmp = colour_to_grey(*(source + 0), *(source + 1), *(source + 2));
#line 701
    source += 3;
#line 699
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 703
  return;
}
}
#line 705 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/cimg.c"
void image_24BGR_to_8grey(int width , unsigned char *dest , unsigned char *source ) 
{ 
  int i ;
  unsigned char *tmp ;

  {
#line 709
  i = 0;
  {
#line 709
  while (1) {
    while_continue: /* CIL Label */ ;
#line 709
    if (! (i < width)) {
#line 709
      goto while_break;
    }
    {
#line 710
    tmp = dest;
#line 710
    dest ++;
#line 710
    *tmp = colour_to_grey(*(source + 2), *(source + 1), *(source + 0));
#line 711
    source += 3;
#line 709
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 713
  return;
}
}
#line 715 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/cimg.c"
static int image_to_8grey(IMAGE *img , unsigned char *dest , unsigned char *source ) 
{ 
  unsigned char *row ;
  void *tmp ;
  int code ;

  {
  {
#line 719
  tmp = malloc((size_t )(img->width * 3U));
#line 719
  row = (unsigned char *)tmp;
#line 720
  code = -1;
  }
#line 721
  if (row) {
    {
#line 722
    code = image_to_24RGB(img, row, source);
#line 723
    image_24RGB_to_8grey((int )img->width, dest, row);
#line 724
    free((void *)row);
    }
  }
#line 726
  return (code);
}
}
#line 732 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/cimg.c"
int image_to_grey(IMAGE *img , unsigned char *dest , unsigned char *source ) 
{ 
  int width ;
  int code ;
  unsigned int alpha ;

  {
#line 735
  width = (int )img->width;
#line 736
  code = -1;
#line 737
  alpha = (unsigned int )((long )img->format & 112L);
  {
#line 739
  if (((long )img->format & 15L) == 1L) {
#line 739
    goto case_1;
  }
#line 755
  if (((long )img->format & 15L) == 2L) {
#line 755
    goto case_2;
  }
#line 769
  if (((long )img->format & 15L) == 4L) {
#line 769
    goto case_4;
  }
#line 782
  if (((long )img->format & 15L) == 8L) {
#line 782
    goto case_8;
  }
#line 738
  goto switch_break;
  case_1: /* CIL Label */ 
#line 740
  if (((long )img->format & 65280L) == 256L) {
    {
#line 741
    image_1native_to_8grey(width, dest, source);
#line 742
    code = 0;
    }
  } else
#line 744
  if (((long )img->format & 65280L) == 1024L) {
    {
#line 745
    image_4native_to_8grey(width, dest, source);
#line 746
    code = 0;
    }
  } else
#line 748
  if (((long )img->format & 65280L) == 2048L) {
    {
#line 749
    image_8native_to_8grey(width, dest, source);
#line 750
    code = 0;
    }
  } else {
    {
#line 753
    code = image_to_8grey(img, dest, source);
    }
  }
#line 754
  goto switch_break;
  case_2: /* CIL Label */ 
#line 756
  if (((long )img->format & 65280L) == 256L) {
    {
#line 757
    image_1grey_to_8grey(width, dest, source);
#line 758
    code = 0;
    }
  } else
#line 760
  if (((long )img->format & 65280L) == 1024L) {
    {
#line 761
    image_4grey_to_8grey(width, dest, source);
#line 762
    code = 0;
    }
  } else
#line 764
  if (((long )img->format & 65280L) == 2048L) {
    {
#line 765
    memcpy((void */* __restrict  */)dest, (void const   */* __restrict  */)source,
           (size_t )width);
#line 766
    code = 0;
    }
  }
#line 768
  goto switch_break;
  case_4: /* CIL Label */ 
#line 770
  if (((long )img->format & 65280L) != 2048L) {
#line 771
    code = -1;
  } else
#line 772
  if (alpha == 0U) {
#line 773
    if (((long )img->format & 65536L) == 0L) {
      {
#line 774
      image_24RGB_to_8grey(width, dest, source);
      }
    } else {
      {
#line 776
      image_24BGR_to_8grey(width, dest, source);
      }
    }
#line 777
    code = 0;
  } else {
    {
#line 780
    code = image_to_8grey(img, dest, source);
    }
  }
#line 781
  goto switch_break;
  case_8: /* CIL Label */ 
#line 783
  if (((long )img->format & 65280L) != 2048L) {
#line 784
    code = -1;
  } else {
    {
#line 786
    code = image_to_8grey(img, dest, source);
    }
  }
#line 787
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 790
  return (code);
}
}
#line 799 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/cimg.c"
int image_to_mono(IMAGE *img , unsigned char *dest , unsigned char *source ) 
{ 
  int width ;
  unsigned int alpha ;
  BOOL bigendian ;
  int bwidth ;
  unsigned char omask ;
  int oroll ;
  int black ;
  unsigned char *s ;
  unsigned char mask0 ;
  unsigned char mask1 ;
  unsigned char mask2 ;
  unsigned char mask3 ;
  int bytes_per_pixel ;
  BOOL additive ;
  int j ;
  int tmp ;

  {
#line 802
  width = (int )img->width;
#line 803
  alpha = (unsigned int )((long )img->format & 112L);
#line 804
  bigendian = ((long )img->format & 65536L) == 0L;
#line 805
  bwidth = ((width + 7) & -8) >> 3;
#line 806
  omask = (unsigned char)128;
#line 807
  oroll = 7;
#line 809
  s = source;
#line 810
  mask0 = (unsigned char)0;
#line 811
  mask1 = (unsigned char)0;
#line 812
  mask2 = (unsigned char)0;
#line 813
  mask3 = (unsigned char)0;
#line 814
  bytes_per_pixel = 0;
#line 815
  additive = 1;
  {
#line 819
  if (((long )img->format & 15L) == 1L) {
#line 819
    goto case_1;
  }
#line 889
  if (((long )img->format & 15L) == 2L) {
#line 889
    goto case_2;
  }
#line 923
  if (((long )img->format & 15L) == 4L) {
#line 923
    goto case_4;
  }
#line 946
  if (((long )img->format & 15L) == 8L) {
#line 946
    goto case_8;
  }
#line 818
  goto switch_break;
  case_1: /* CIL Label */ 
#line 820
  if (((long )img->format & 65280L) == 256L) {
#line 821
    j = 0;
    {
#line 821
    while (1) {
      while_continue: /* CIL Label */ ;
#line 821
      if (! (j < bwidth)) {
#line 821
        goto while_break;
      }
#line 822
      *(dest + j) = *(source + j);
#line 821
      j ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 823
    return (0);
  } else
#line 825
  if (((long )img->format & 65280L) == 1024L) {
#line 826
    j = 0;
    {
#line 826
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 826
      if (! (j < width)) {
#line 826
        goto while_break___0;
      }
#line 827
      if (j & 1) {
#line 828
        black = ((int )*s & 15) != 15;
#line 829
        s ++;
      } else {
#line 832
        black = ((int )*s & 240) != 240;
      }
#line 833
      if (black) {
#line 834
        *(dest + j / 8) = (unsigned char )((int )*(dest + j / 8) | (int )omask);
      } else {
#line 836
        *(dest + j / 8) = (unsigned char )((int )*(dest + j / 8) & (int )((unsigned char )(~ ((int )omask))));
      }
#line 837
      oroll --;
#line 838
      omask = (unsigned char )((int )omask >> 1);
#line 839
      if (oroll < 0) {
#line 840
        omask = (unsigned char)128;
#line 841
        oroll = 7;
      }
#line 826
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 844
    return (0);
  } else
#line 846
  if (((long )img->format & 65280L) == 2048L) {
#line 847
    j = 0;
    {
#line 847
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 847
      if (! (j < width)) {
#line 847
        goto while_break___1;
      }
#line 848
      if ((int )*s != 63) {
#line 848
        if ((int )*s != 95) {
#line 848
          tmp = 1;
        } else {
#line 848
          tmp = 0;
        }
      } else {
#line 848
        tmp = 0;
      }
#line 848
      black = tmp;
#line 849
      s ++;
#line 850
      if (black) {
#line 851
        *(dest + j / 8) = (unsigned char )((int )*(dest + j / 8) | (int )omask);
      } else {
#line 853
        *(dest + j / 8) = (unsigned char )((int )*(dest + j / 8) & (int )((unsigned char )(~ ((int )omask))));
      }
#line 854
      oroll --;
#line 855
      omask = (unsigned char )((int )omask >> 1);
#line 856
      if (oroll < 0) {
#line 857
        omask = (unsigned char)128;
#line 858
        oroll = 7;
      }
#line 847
      j ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 861
    return (0);
  } else
#line 863
  if (((long )img->format & 65280L) == 8192L) {
#line 864
    bytes_per_pixel = 2;
#line 865
    if (bigendian) {
#line 866
      if (((long )img->format & 262144L) == 0L) {
#line 868
        mask0 = (unsigned char)127;
#line 869
        mask1 = (unsigned char)255;
      } else {
#line 872
        mask0 = (unsigned char)255;
#line 873
        mask1 = (unsigned char)255;
      }
    } else
#line 877
    if (((long )img->format & 262144L) == 0L) {
#line 879
      mask0 = (unsigned char)255;
#line 880
      mask1 = (unsigned char)127;
    } else {
#line 883
      mask0 = (unsigned char)255;
#line 884
      mask1 = (unsigned char)255;
    }
  }
#line 888
  goto switch_break;
  case_2: /* CIL Label */ 
#line 890
  if (((long )img->format & 65280L) == 256L) {
#line 891
    j = 0;
    {
#line 891
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 891
      if (! (j < bwidth)) {
#line 891
        goto while_break___2;
      }
#line 892
      *(dest + j) = (unsigned char )(~ ((int )*(source + j)));
#line 891
      j ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 893
    return (0);
  } else
#line 895
  if (((long )img->format & 65280L) == 1024L) {
#line 896
    j = 0;
    {
#line 896
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 896
      if (! (j < width)) {
#line 896
        goto while_break___3;
      }
#line 897
      if (j & 1) {
#line 898
        black = ((int )*s & 15) != 15;
#line 899
        s ++;
      } else {
#line 902
        black = ((int )*s & 240) != 240;
      }
#line 903
      if (black) {
#line 904
        *(dest + j / 8) = (unsigned char )((int )*(dest + j / 8) | (int )omask);
      } else {
#line 906
        *(dest + j / 8) = (unsigned char )((int )*(dest + j / 8) & (int )((unsigned char )(~ ((int )omask))));
      }
#line 907
      oroll --;
#line 908
      omask = (unsigned char )((int )omask >> 1);
#line 909
      if (oroll < 0) {
#line 910
        omask = (unsigned char)128;
#line 911
        oroll = 7;
      }
#line 896
      j ++;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 914
    return (0);
  } else
#line 916
  if (((long )img->format & 65280L) == 2048L) {
#line 917
    bytes_per_pixel = 1;
#line 918
    mask0 = (unsigned char)255;
  } else {
#line 921
    return (-1);
  }
#line 922
  goto switch_break;
  case_4: /* CIL Label */ 
#line 924
  if (((long )img->format & 65280L) != 2048L) {
#line 925
    return (-1);
  }
#line 927
  if (alpha == 16U) {
#line 929
    bytes_per_pixel = 4;
#line 930
    mask0 = (unsigned char)0;
#line 931
    mask1 = (unsigned char)255;
#line 932
    mask2 = (unsigned char)255;
#line 933
    mask3 = (unsigned char)255;
  } else
#line 927
  if (alpha == 64U) {
#line 929
    bytes_per_pixel = 4;
#line 930
    mask0 = (unsigned char)0;
#line 931
    mask1 = (unsigned char)255;
#line 932
    mask2 = (unsigned char)255;
#line 933
    mask3 = (unsigned char)255;
  } else {
#line 936
    bytes_per_pixel = 3;
#line 937
    mask0 = (unsigned char)255;
#line 938
    mask1 = (unsigned char)255;
#line 939
    mask2 = (unsigned char)255;
#line 940
    mask3 = (unsigned char)0;
  }
#line 942
  if (alpha == 32U) {
#line 944
    bytes_per_pixel ++;
  } else
#line 942
  if (alpha == 128U) {
#line 944
    bytes_per_pixel ++;
  }
#line 945
  goto switch_break;
  case_8: /* CIL Label */ 
#line 947
  if (((long )img->format & 65280L) != 2048L) {
#line 948
    return (-1);
  }
#line 950
  additive = 0;
#line 951
  bytes_per_pixel = 4;
#line 952
  mask0 = (unsigned char)255;
#line 953
  mask1 = (unsigned char)255;
#line 954
  mask2 = (unsigned char)255;
#line 955
  mask3 = (unsigned char)255;
#line 956
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 961
  memset((void *)dest, 255, (size_t )bwidth);
#line 962
  omask = (unsigned char)128;
#line 963
  oroll = 7;
#line 965
  j = 0;
  }
  {
#line 965
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 965
    if (! (j < width)) {
#line 965
      goto while_break___4;
    }
#line 966
    if (additive) {
#line 968
      black = ((int )*(s + 0) & (int )mask0) != (int )mask0;
#line 969
      if (bytes_per_pixel > 1) {
#line 970
        black |= ((int )*(s + 1) & (int )mask1) != (int )mask1;
      }
#line 971
      if (bytes_per_pixel > 2) {
#line 972
        black |= ((int )*(s + 2) & (int )mask2) != (int )mask2;
      }
#line 973
      if (bytes_per_pixel > 3) {
#line 974
        black |= ((int )*(s + 3) & (int )mask3) != (int )mask3;
      }
    } else {
#line 978
      black = ((int )*(s + 0) & (int )mask0) != 0;
#line 979
      black |= ((int )*(s + 1) & (int )mask1) != 0;
#line 980
      black |= ((int )*(s + 2) & (int )mask2) != 0;
#line 981
      black |= ((int )*(s + 3) & (int )mask3) != 0;
    }
#line 983
    s += bytes_per_pixel;
#line 984
    if (black) {
#line 985
      *(dest + j / 8) = (unsigned char )((int )*(dest + j / 8) | (int )omask);
    } else {
#line 987
      *(dest + j / 8) = (unsigned char )((int )*(dest + j / 8) & (int )((unsigned char )(~ ((int )omask))));
    }
#line 988
    oroll --;
#line 989
    omask = (unsigned char )((int )omask >> 1);
#line 990
    if (oroll < 0) {
#line 991
      omask = (unsigned char)128;
#line 992
      oroll = 7;
    }
#line 965
    j ++;
  }
  while_break___4: /* CIL Label */ ;
  }
#line 995
  return (0);
}
}
#line 1002 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/cimg.c"
int image_depth(IMAGE *img ) 
{ 
  unsigned int alpha ;
  int bitcount ;

  {
#line 1005
  alpha = (unsigned int )((long )img->format & 112L);
#line 1006
  bitcount = -1;
  {
#line 1009
  if (((long )img->format & 15L) == 2L) {
#line 1009
    goto case_2;
  }
#line 1009
  if (((long )img->format & 15L) == 1L) {
#line 1009
    goto case_2;
  }
#line 1025
  if (((long )img->format & 15L) == 4L) {
#line 1025
    goto case_4;
  }
#line 1037
  if (((long )img->format & 15L) == 8L) {
#line 1037
    goto case_8;
  }
#line 1007
  goto switch_break;
  case_2: /* CIL Label */ 
  case_1: /* CIL Label */ 
  {
#line 1011
  if (((long )img->format & 65280L) == 256L) {
#line 1011
    goto case_256;
  }
#line 1014
  if (((long )img->format & 65280L) == 1024L) {
#line 1014
    goto case_1024;
  }
#line 1017
  if (((long )img->format & 65280L) == 2048L) {
#line 1017
    goto case_2048;
  }
#line 1020
  if (((long )img->format & 65280L) == 8192L) {
#line 1020
    goto case_8192;
  }
#line 1010
  goto switch_break___0;
  case_256: /* CIL Label */ 
#line 1012
  bitcount = 1;
#line 1013
  goto switch_break___0;
  case_1024: /* CIL Label */ 
#line 1015
  bitcount = 4;
#line 1016
  goto switch_break___0;
  case_2048: /* CIL Label */ 
#line 1018
  bitcount = 8;
#line 1019
  goto switch_break___0;
  case_8192: /* CIL Label */ 
#line 1021
  bitcount = 16;
#line 1022
  goto switch_break___0;
  switch_break___0: /* CIL Label */ ;
  }
#line 1024
  goto switch_break;
  case_4: /* CIL Label */ 
#line 1026
  if (((long )img->format & 65280L) == 2048L) {
#line 1027
    if (alpha == 16U) {
#line 1029
      bitcount = 32;
    } else
#line 1027
    if (alpha == 64U) {
#line 1029
      bitcount = 32;
    } else {
#line 1031
      bitcount = 24;
    }
#line 1032
    if (alpha == 32U) {
#line 1034
      bitcount += 8;
    } else
#line 1032
    if (alpha == 128U) {
#line 1034
      bitcount += 8;
    }
  }
#line 1036
  goto switch_break;
  case_8: /* CIL Label */ 
#line 1038
  if (((long )img->format & 65280L) == 2048L) {
#line 1039
    bitcount = 32;
  }
#line 1040
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 1043
  return (bitcount);
}
}
#line 1049 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/cimg.c"
int image_copy(IMAGE *newimg , IMAGE *oldimg , unsigned int format ) 
{ 
  int code ;
  int depth ;
  int colour_format ;
  BOOL mono ;
  BOOL grey ;
  BOOL rgb24 ;
  BOOL bgr24 ;
  int image_size ;
  void *tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  unsigned char *source ;
  unsigned char *dest ;
  BOOL invert ;
  int i ;

  {
  {
#line 1051
  code = 0;
#line 1053
  colour_format = (int )((long )format & 15L);
#line 1054
  mono = 0;
#line 1055
  grey = 0;
#line 1056
  rgb24 = 0;
#line 1057
  bgr24 = 0;
#line 1058
  memset((void *)newimg, 0, sizeof(IMAGE ));
#line 1059
  newimg->width = oldimg->width;
#line 1060
  newimg->height = oldimg->height;
#line 1061
  newimg->raster = oldimg->raster;
#line 1062
  newimg->format = format;
#line 1063
  newimg->image = (unsigned char *)((void *)0);
  }
#line 1064
  if (newimg->format == oldimg->format) {
    {
#line 1066
    image_size = (int )(newimg->height * newimg->raster);
#line 1067
    tmp = malloc((size_t )image_size);
#line 1067
    newimg->image = (unsigned char *)tmp;
    }
#line 1068
    if ((unsigned long )newimg->image == (unsigned long )((void *)0)) {
#line 1069
      code = -1;
    } else {
      {
#line 1071
      memcpy((void */* __restrict  */)newimg->image, (void const   */* __restrict  */)oldimg->image,
             (size_t )image_size);
#line 1072
      tmp___0 = image_platform_init(newimg);
      }
#line 1072
      if (tmp___0 < 0) {
        {
#line 1073
        free((void *)newimg->image);
#line 1074
        newimg->image = (unsigned char *)((void *)0);
#line 1075
        code = -1;
        }
      }
    }
#line 1078
    return (code);
  }
  {
#line 1083
  depth = image_depth(newimg);
  }
#line 1084
  if (depth == 1) {
#line 1084
    if (colour_format == 1) {
#line 1085
      mono = 1;
    } else {
#line 1084
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 1086
  if (depth == 8) {
#line 1086
    if (colour_format == 2) {
#line 1087
      grey = 1;
    } else {
#line 1086
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 1088
  if (depth == 24) {
#line 1088
    if (colour_format == 4) {
#line 1089
      if (((long )format & 65536L) == 0L) {
#line 1090
        rgb24 = 1;
      } else {
#line 1092
        bgr24 = 1;
      }
    } else {
#line 1095
      code = -1;
    }
  } else {
#line 1095
    code = -1;
  }
#line 1097
  if (code == 0) {
    {
#line 1098
    newimg->raster = ((((unsigned int )depth * newimg->width + 7U) >> 3) + 3U) & 4294967292U;
#line 1099
    tmp___1 = malloc((size_t )(newimg->raster * newimg->height));
#line 1099
    newimg->image = (unsigned char *)tmp___1;
    }
  }
#line 1103
  if ((unsigned long )newimg->image == (unsigned long )((void *)0)) {
#line 1104
    code = -1;
  } else
#line 1105
  if (code == 0) {
#line 1108
    invert = ((long )newimg->format & 131072L) != ((long )oldimg->format & 131072L);
#line 1111
    i = 0;
    {
#line 1111
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1111
      if (! (i < (int )newimg->height)) {
#line 1111
        goto while_break;
      }
#line 1112
      source = oldimg->image + oldimg->raster * (unsigned int )i;
#line 1113
      if (invert) {
#line 1114
        dest = newimg->image + newimg->raster * ((newimg->height - 1U) - (unsigned int )i);
      } else {
#line 1116
        dest = newimg->image + newimg->raster * (unsigned int )i;
      }
#line 1117
      if (mono) {
        {
#line 1118
        code = image_to_mono(oldimg, dest, source);
        }
      } else
#line 1119
      if (grey) {
        {
#line 1120
        code = image_to_grey(oldimg, dest, source);
        }
      } else
#line 1121
      if (rgb24) {
        {
#line 1122
        code = image_to_24RGB(oldimg, dest, source);
        }
      } else
#line 1123
      if (bgr24) {
        {
#line 1124
        code = image_to_24BGR(oldimg, dest, source);
        }
      }
#line 1125
      if (code) {
#line 1126
        goto while_break;
      }
#line 1111
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 1130
  if (code == 0) {
    {
#line 1131
    code = image_platform_init(newimg);
    }
  }
#line 1132
  if (code) {
#line 1133
    if (newimg->image) {
      {
#line 1134
      free((void *)newimg->image);
#line 1135
      newimg->image = (unsigned char *)((void *)0);
      }
    }
  }
#line 1138
  return (code);
}
}
#line 1144 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/cimg.c"
int image_merge_cmyk(IMAGE *img , IMAGE *layer , float cyan , float magenta , float yellow ,
                     float black ) 
{ 
  int x ;
  int y ;
  unsigned char *img_row ;
  unsigned char *layer_row ;
  unsigned char *p ;
  int img_topfirst ;
  int layer_topfirst ;
  unsigned int val ;
  int tmp ;
  int tmp___0 ;
  float tmp___1 ;
  float tmp___2 ;
  float tmp___3 ;
  float tmp___4 ;

  {
#line 1156
  if ((unsigned long )img == (unsigned long )((void *)0)) {
#line 1157
    return (-1);
  } else
#line 1156
  if ((unsigned long )img->image == (unsigned long )((void *)0)) {
#line 1157
    return (-1);
  }
#line 1158
  if ((unsigned long )layer == (unsigned long )((void *)0)) {
#line 1159
    return (-1);
  } else
#line 1158
  if ((unsigned long )layer->image == (unsigned long )((void *)0)) {
#line 1159
    return (-1);
  }
#line 1160
  if (((long )img->format & 15L) != 8L) {
#line 1161
    return (-1);
  }
#line 1162
  if (((long )img->format & 65280L) != 2048L) {
#line 1163
    return (-1);
  }
#line 1164
  if (((long )img->format & 65536L) != 0L) {
#line 1165
    return (-1);
  }
#line 1166
  if (((long )layer->format & 15L) != 2L) {
#line 1167
    return (-1);
  }
#line 1168
  if (((long )layer->format & 65280L) != 2048L) {
#line 1169
    return (-1);
  }
#line 1170
  if (img->width != layer->width) {
#line 1171
    return (-1);
  }
#line 1172
  if (img->height != layer->height) {
#line 1173
    return (-1);
  }
#line 1175
  img_topfirst = ((long )img->format & 131072L) == 0L;
#line 1176
  layer_topfirst = ((long )layer->format & 131072L) == 0L;
#line 1179
  y = 0;
  {
#line 1179
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1179
    if (! (y < (int )img->height)) {
#line 1179
      goto while_break;
    }
#line 1180
    if (img_topfirst) {
#line 1180
      tmp = y;
    } else {
#line 1180
      tmp = ((int )img->height - y) - 1;
    }
#line 1180
    img_row = img->image + img->raster * (unsigned int )tmp;
#line 1182
    if (layer_topfirst) {
#line 1182
      tmp___0 = y;
    } else {
#line 1182
      tmp___0 = ((int )layer->height - y) - 1;
    }
#line 1182
    layer_row = layer->image + layer->raster * (unsigned int )tmp___0;
#line 1184
    x = 0;
    {
#line 1184
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1184
      if (! (x < (int )img->width)) {
#line 1184
        goto while_break___0;
      }
#line 1185
      val = (unsigned int )*(layer_row + x);
#line 1186
      p = img_row + x * 4;
#line 1187
      if ((float )255 < (float )*(p + 0) + (float )(255U - val) * cyan) {
#line 1187
        tmp___1 = (float )255;
      } else {
#line 1187
        tmp___1 = (float )*(p + 0) + (float )(255U - val) * cyan;
      }
#line 1187
      *(p + 0) = (unsigned char )tmp___1;
#line 1188
      if ((float )255 < (float )*(p + 1) + (float )(255U - val) * magenta) {
#line 1188
        tmp___2 = (float )255;
      } else {
#line 1188
        tmp___2 = (float )*(p + 1) + (float )(255U - val) * magenta;
      }
#line 1188
      *(p + 1) = (unsigned char )tmp___2;
#line 1189
      if ((float )255 < (float )*(p + 2) + (float )(255U - val) * yellow) {
#line 1189
        tmp___3 = (float )255;
      } else {
#line 1189
        tmp___3 = (float )*(p + 2) + (float )(255U - val) * yellow;
      }
#line 1189
      *(p + 2) = (unsigned char )tmp___3;
#line 1190
      if ((float )255 < (float )*(p + 3) + (float )(255U - val) * black) {
#line 1190
        tmp___4 = (float )255;
      } else {
#line 1190
        tmp___4 = (float )*(p + 3) + (float )(255U - val) * black;
      }
#line 1190
      *(p + 3) = (unsigned char )tmp___4;
#line 1184
      x ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1179
    y ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1193
  return (0);
}
}
#line 1218 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/cimg.c"
int image_down_scale(IMAGE *newimg , IMAGE *oldimg ) 
{ 
  unsigned int i ;
  unsigned int xi ;
  unsigned int xo ;
  unsigned int yi ;
  unsigned int yo ;
  unsigned int end ;
  unsigned int last ;
  scale_pixels_t *spx ;
  scale_pixels_t *spy ;
  unsigned int *sum1 ;
  unsigned int *sumn ;
  unsigned int frac ;
  unsigned int val ;
  unsigned int maxval ;
  unsigned char *row_in ;
  unsigned char *row_out ;
  unsigned int mask ;
  unsigned int byteval ;
  unsigned int width_in ;
  unsigned int height_in ;
  unsigned int width_out ;
  unsigned int height_out ;
  BOOL mono_wb ;
  BOOL mono_bw ;
  BOOL cmyk_in ;
  BOOL cmyk_out ;
  unsigned int ncomp_in ;
  unsigned int ncomp_out ;
  unsigned int ncomp_out_first ;
  unsigned int ncomp_out_last ;
  int alpha ;
  int alpha___0 ;
  int tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  unsigned char tmp___5 ;
  unsigned char tmp___6 ;

  {
#line 1223
  spx = (scale_pixels_t *)((void *)0);
#line 1224
  spy = (scale_pixels_t *)((void *)0);
#line 1225
  sum1 = (unsigned int *)((void *)0);
#line 1226
  sumn = (unsigned int *)((void *)0);
#line 1233
  byteval = 0U;
#line 1234
  width_in = oldimg->width;
#line 1235
  height_in = oldimg->height;
#line 1236
  width_out = newimg->width;
#line 1237
  height_out = newimg->height;
#line 1238
  mono_wb = 0;
#line 1239
  mono_bw = 0;
#line 1240
  cmyk_in = 0;
#line 1241
  cmyk_out = 0;
#line 1242
  ncomp_in = 0U;
#line 1243
  ncomp_out = 0U;
#line 1244
  ncomp_out_first = 0U;
#line 1245
  ncomp_out_last = 0U;
  {
#line 1249
  if (((long )oldimg->format & 15L) == 1L) {
#line 1249
    goto case_1;
  }
#line 1257
  if (((long )oldimg->format & 15L) == 2L) {
#line 1257
    goto case_2;
  }
#line 1268
  if (((long )oldimg->format & 15L) == 4L) {
#line 1268
    goto case_4;
  }
#line 1280
  if (((long )oldimg->format & 15L) == 8L) {
#line 1280
    goto case_8;
  }
#line 1248
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 1251
  if (((long )oldimg->format & 65280L) == 256L) {
#line 1251
    goto case_256;
  }
#line 1250
  goto switch_break___0;
  case_256: /* CIL Label */ 
#line 1252
  ncomp_in = 1U;
#line 1253
  mono_wb = 1;
#line 1254
  goto switch_break___0;
  switch_break___0: /* CIL Label */ ;
  }
#line 1256
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 1259
  if (((long )oldimg->format & 65280L) == 256L) {
#line 1259
    goto case_256___0;
  }
#line 1263
  if (((long )oldimg->format & 65280L) == 2048L) {
#line 1263
    goto case_2048;
  }
#line 1258
  goto switch_break___1;
  case_256___0: /* CIL Label */ 
#line 1260
  ncomp_in = 1U;
#line 1261
  mono_bw = 1;
#line 1262
  goto switch_break___1;
  case_2048: /* CIL Label */ 
#line 1264
  ncomp_in = 1U;
#line 1265
  goto switch_break___1;
  switch_break___1: /* CIL Label */ ;
  }
#line 1267
  goto switch_break;
  case_4: /* CIL Label */ 
#line 1269
  if (((long )oldimg->format & 65280L) == 2048L) {
#line 1270
    alpha = (int )((long )oldimg->format & 112L);
#line 1271
    ncomp_in = 3U;
#line 1272
    if (alpha == 16) {
#line 1274
      ncomp_in ++;
    } else
#line 1272
    if (alpha == 64) {
#line 1274
      ncomp_in ++;
    }
#line 1275
    if (alpha == 32) {
#line 1277
      ncomp_in ++;
    } else
#line 1275
    if (alpha == 128) {
#line 1277
      ncomp_in ++;
    }
  }
#line 1279
  goto switch_break;
  case_8: /* CIL Label */ 
#line 1281
  if (((long )oldimg->format & 65280L) == 2048L) {
#line 1282
    ncomp_in = 4U;
#line 1283
    cmyk_in = 1;
  }
  switch_break: /* CIL Label */ ;
  }
#line 1287
  if (ncomp_in == 0U) {
#line 1288
    return (-1);
  }
  {
#line 1292
  if (((long )newimg->format & 15L) == 2L) {
#line 1292
    goto case_2___0;
  }
#line 1300
  if (((long )newimg->format & 15L) == 4L) {
#line 1300
    goto case_4___0;
  }
#line 1324
  if (((long )newimg->format & 15L) == 8L) {
#line 1324
    goto case_8___0;
  }
#line 1291
  goto switch_break___2;
  case_2___0: /* CIL Label */ 
  {
#line 1294
  if (((long )newimg->format & 65280L) == 2048L) {
#line 1294
    goto case_2048___0;
  }
#line 1293
  goto switch_break___3;
  case_2048___0: /* CIL Label */ 
#line 1295
  ncomp_out = 1U;
#line 1296
  ncomp_out_last = ncomp_out;
#line 1297
  goto switch_break___3;
  switch_break___3: /* CIL Label */ ;
  }
#line 1299
  goto switch_break___2;
  case_4___0: /* CIL Label */ 
#line 1301
  if (((long )newimg->format & 65280L) == 2048L) {
#line 1302
    alpha___0 = (int )((long )newimg->format & 112L);
#line 1303
    ncomp_out = 3U;
#line 1304
    ncomp_out_first = 0U;
#line 1305
    ncomp_out_last = ncomp_out;
#line 1306
    if (alpha___0 == 16) {
#line 1307
      ncomp_out ++;
#line 1308
      ncomp_out_last ++;
    } else
#line 1310
    if (alpha___0 == 64) {
#line 1311
      ncomp_out ++;
#line 1312
      ncomp_out_first ++;
#line 1313
      ncomp_out_last ++;
    }
#line 1315
    if (alpha___0 == 32) {
#line 1316
      ncomp_out ++;
#line 1317
      ncomp_out_last ++;
    } else
#line 1319
    if (alpha___0 == 128) {
#line 1320
      ncomp_out ++;
    }
  }
#line 1323
  goto switch_break___2;
  case_8___0: /* CIL Label */ 
#line 1325
  if (((long )newimg->format & 65280L) == 2048L) {
#line 1326
    ncomp_out = 4U;
#line 1327
    cmyk_out = 1;
  }
  switch_break___2: /* CIL Label */ ;
  }
#line 1331
  if (ncomp_out == 0U) {
#line 1332
    return (-1);
  }
#line 1333
  if (ncomp_out < ncomp_in) {
#line 1334
    return (-1);
  }
#line 1335
  if (ncomp_out != ncomp_in) {
#line 1335
    if (ncomp_in != 1U) {
#line 1336
      return (-1);
    }
  }
#line 1337
  if (cmyk_out != cmyk_in) {
#line 1338
    return (-1);
  }
#line 1340
  if (newimg->format) {
#line 1340
    tmp = 1;
  } else {
#line 1340
    tmp = 0;
  }
#line 1340
  if (oldimg->format) {
#line 1340
    tmp___0 = 1;
  } else {
#line 1340
    tmp___0 = 0;
  }
#line 1340
  if (tmp != tmp___0) {
#line 1342
    return (-1);
  }
#line 1344
  if (width_out > width_in) {
#line 1345
    width_out = width_in;
  }
#line 1346
  if (height_out > height_in) {
#line 1347
    height_out = height_in;
  }
  {
#line 1349
  maxval = (unsigned int )((int )((16U * width_in) / width_out) * (int )((16U * height_in) / height_out));
#line 1352
  tmp___1 = malloc((unsigned long )height_out * sizeof(scale_pixels_t ));
#line 1352
  spy = (scale_pixels_t *)tmp___1;
#line 1353
  tmp___2 = malloc((unsigned long )width_out * sizeof(scale_pixels_t ));
#line 1353
  spx = (scale_pixels_t *)tmp___2;
#line 1354
  tmp___3 = malloc((unsigned long )(width_out * ncomp_in) * sizeof(unsigned int ));
#line 1354
  sum1 = (unsigned int *)tmp___3;
#line 1355
  tmp___4 = malloc((unsigned long )(width_out * ncomp_in) * sizeof(unsigned int ));
#line 1355
  sumn = (unsigned int *)tmp___4;
  }
#line 1356
  if ((unsigned long )spy == (unsigned long )((void *)0)) {
#line 1356
    goto _L;
  } else
#line 1356
  if ((unsigned long )spx == (unsigned long )((void *)0)) {
#line 1356
    goto _L;
  } else
#line 1356
  if ((unsigned long )sum1 == (unsigned long )((void *)0)) {
#line 1356
    goto _L;
  } else
#line 1356
  if ((unsigned long )sumn == (unsigned long )((void *)0)) {
    _L: /* CIL Label */ 
#line 1357
    if ((unsigned long )spy != (unsigned long )((void *)0)) {
      {
#line 1358
      free((void *)spy);
      }
    }
#line 1359
    if ((unsigned long )spx != (unsigned long )((void *)0)) {
      {
#line 1360
      free((void *)spx);
      }
    }
#line 1361
    if ((unsigned long )sum1 != (unsigned long )((void *)0)) {
      {
#line 1362
      free((void *)sum1);
      }
    }
#line 1363
    if ((unsigned long )sumn == (unsigned long )((void *)0)) {
      {
#line 1364
      free((void *)sumn);
      }
    }
#line 1365
    return (-1);
  }
#line 1369
  xo = 0U;
  {
#line 1369
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1369
    if (! (xo < width_out)) {
#line 1369
      goto while_break;
    }
#line 1370
    last = (((xo + 1U) * 16U) * width_in) / width_out;
#line 1371
    end = last & 4294967280U;
#line 1372
    (spx + xo)->end = end >> 4;
#line 1373
    (spx + xo)->frac = last - end;
#line 1374
    if ((spx + xo)->frac == 0U) {
#line 1375
      ((spx + xo)->end) --;
#line 1376
      (spx + xo)->frac = 16U;
    }
#line 1369
    xo ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1379
  yo = 0U;
  {
#line 1379
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1379
    if (! (yo < height_out)) {
#line 1379
      goto while_break___0;
    }
#line 1380
    last = (((yo + 1U) * 16U) * height_in) / height_out;
#line 1381
    end = last & 4294967280U;
#line 1382
    (spy + yo)->end = end >> 4;
#line 1383
    (spy + yo)->frac = last - end;
#line 1384
    if ((spy + yo)->frac == 0U) {
#line 1385
      ((spy + yo)->end) --;
#line 1386
      (spy + yo)->frac = 16U;
    }
#line 1379
    yo ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 1389
  yo = 0U;
#line 1390
  memset((void *)sumn, 0, (unsigned long )(width_out * ncomp_in) * sizeof(unsigned int ));
#line 1391
  yi = 0U;
  }
  {
#line 1391
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1391
    if (! (yi < height_in)) {
#line 1391
      goto while_break___1;
    }
#line 1392
    xo = 0U;
#line 1393
    i = 0U;
    {
#line 1393
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 1393
      if (! (i < ncomp_in)) {
#line 1393
        goto while_break___2;
      }
#line 1394
      *(sum1 + (xo * ncomp_in + i)) = 0U;
#line 1393
      i ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 1395
    row_in = oldimg->image + yi * oldimg->raster;
#line 1396
    if (mono_wb) {
#line 1398
      mask = 0U;
#line 1399
      end = (spx + xo)->end;
#line 1400
      xi = 0U;
      {
#line 1400
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 1400
        if (! (xi < width_in)) {
#line 1400
          goto while_break___3;
        }
#line 1401
        mask >>= 1;
#line 1401
        if (mask == 0U) {
#line 1402
          mask = 128U;
#line 1403
          byteval = (unsigned int )*(row_in + (xi >> 3));
        }
#line 1405
        if (byteval & mask) {
#line 1405
          val = 0U;
        } else {
#line 1405
          val = 255U;
        }
#line 1406
        if (xi >= end) {
#line 1408
          frac = (spx + xo)->frac;
#line 1408
          *(sum1 + xo) += val * frac;
#line 1409
          xo ++;
#line 1409
          if (xo < width_out) {
#line 1410
            *(sum1 + xo) = val * (16U - frac);
          }
#line 1411
          end = (spx + xo)->end;
        } else {
#line 1414
          *(sum1 + xo) += val << 4;
        }
#line 1400
        xi ++;
      }
      while_break___3: /* CIL Label */ ;
      }
    } else
#line 1417
    if (mono_bw) {
#line 1419
      mask = 0U;
#line 1420
      end = (spx + xo)->end;
#line 1421
      xi = 0U;
      {
#line 1421
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 1421
        if (! (xi < width_in)) {
#line 1421
          goto while_break___4;
        }
#line 1422
        mask >>= 1;
#line 1422
        if (mask == 0U) {
#line 1423
          mask = 128U;
#line 1424
          byteval = (unsigned int )*(row_in + (xi >> 3));
        }
#line 1426
        if (byteval & mask) {
#line 1426
          val = 255U;
        } else {
#line 1426
          val = 0U;
        }
#line 1427
        if (xi >= end) {
#line 1429
          frac = (spx + xo)->frac;
#line 1429
          *(sum1 + xo) += val * frac;
#line 1430
          xo ++;
#line 1430
          if (xo < width_out) {
#line 1431
            *(sum1 + xo) = val * (16U - frac);
          }
#line 1432
          end = (spx + xo)->end;
        } else {
#line 1435
          *(sum1 + xo) += val << 4;
        }
#line 1421
        xi ++;
      }
      while_break___4: /* CIL Label */ ;
      }
    } else
#line 1438
    if (ncomp_in == 1U) {
#line 1440
      xi = 0U;
      {
#line 1440
      while (1) {
        while_continue___5: /* CIL Label */ ;
#line 1440
        if (! (xi < width_in)) {
#line 1440
          goto while_break___5;
        }
#line 1441
        val = (unsigned int )*(row_in + xi);
#line 1442
        if (xi >= (spx + xo)->end) {
#line 1444
          frac = (spx + xo)->frac;
#line 1444
          *(sum1 + xo) += val * frac;
#line 1445
          xo ++;
#line 1445
          if (xo < width_out) {
#line 1446
            *(sum1 + xo) = val * (16U - frac);
          }
        } else {
#line 1449
          *(sum1 + xo) += val << 4;
        }
#line 1440
        xi ++;
      }
      while_break___5: /* CIL Label */ ;
      }
    } else
#line 1452
    if (ncomp_in >= 3U) {
#line 1454
      xi = 0U;
      {
#line 1454
      while (1) {
        while_continue___6: /* CIL Label */ ;
#line 1454
        if (! (xi < width_in)) {
#line 1454
          goto while_break___6;
        }
#line 1455
        i = 0U;
        {
#line 1455
        while (1) {
          while_continue___7: /* CIL Label */ ;
#line 1455
          if (! (i < ncomp_in)) {
#line 1455
            goto while_break___7;
          }
#line 1456
          val = (unsigned int )*(row_in + (xi * ncomp_in + i));
#line 1457
          if (xi >= (spx + xo)->end) {
#line 1459
            frac = (spx + xo)->frac;
#line 1460
            *(sum1 + (xo * ncomp_in + i)) += val * frac;
#line 1461
            if (xo + 1U < width_out) {
#line 1462
              *(sum1 + ((xo + 1U) * ncomp_in + i)) = val * (16U - frac);
            }
          } else {
#line 1465
            *(sum1 + (xo * ncomp_in + i)) += val << 4;
          }
#line 1455
          i ++;
        }
        while_break___7: /* CIL Label */ ;
        }
#line 1467
        if (xi >= (spx + xo)->end) {
#line 1468
          xo ++;
        }
#line 1454
        xi ++;
      }
      while_break___6: /* CIL Label */ ;
      }
    }
#line 1471
    if (yi >= (spy + yo)->end) {
#line 1472
      frac = (spy + yo)->frac;
#line 1474
      xo = 0U;
      {
#line 1474
      while (1) {
        while_continue___8: /* CIL Label */ ;
#line 1474
        if (! (xo < width_out * ncomp_in)) {
#line 1474
          goto while_break___8;
        }
#line 1475
        *(sumn + xo) += *(sum1 + xo) * frac;
#line 1474
        xo ++;
      }
      while_break___8: /* CIL Label */ ;
      }
#line 1477
      row_out = newimg->image + yo * newimg->raster;
#line 1478
      xo = 0U;
      {
#line 1478
      while (1) {
        while_continue___9: /* CIL Label */ ;
#line 1478
        if (! (xo < width_out * ncomp_in)) {
#line 1478
          goto while_break___9;
        }
#line 1479
        val = *(sumn + xo) / maxval;
#line 1480
        if (val > 255U) {
#line 1481
          val = 255U;
        }
#line 1482
        if (ncomp_in == ncomp_out) {
#line 1483
          *(row_out + xo) = (unsigned char )val;
        } else
#line 1487
        if (cmyk_out) {
#line 1488
          tmp___6 = (unsigned char)0;
#line 1488
          *(row_out + (xo * ncomp_out + 2U)) = tmp___6;
#line 1488
          tmp___5 = tmp___6;
#line 1488
          *(row_out + (xo * ncomp_out + 1U)) = tmp___5;
#line 1488
          *(row_out + xo * ncomp_out) = tmp___5;
#line 1491
          *(row_out + (xo * ncomp_out + 3U)) = (unsigned char )val;
        } else {
#line 1496
          i = 0U;
          {
#line 1496
          while (1) {
            while_continue___10: /* CIL Label */ ;
#line 1496
            if (! (i < ncomp_out_first)) {
#line 1496
              goto while_break___10;
            }
#line 1497
            *(row_out + (xo * ncomp_out + i)) = (unsigned char)0;
#line 1496
            i ++;
          }
          while_break___10: /* CIL Label */ ;
          }
          {
#line 1498
          while (1) {
            while_continue___11: /* CIL Label */ ;
#line 1498
            if (! (i < ncomp_out_last)) {
#line 1498
              goto while_break___11;
            }
#line 1499
            *(row_out + (xo * ncomp_out + i)) = (unsigned char )val;
#line 1498
            i ++;
          }
          while_break___11: /* CIL Label */ ;
          }
          {
#line 1500
          while (1) {
            while_continue___12: /* CIL Label */ ;
#line 1500
            if (! (i < ncomp_out)) {
#line 1500
              goto while_break___12;
            }
#line 1501
            *(row_out + (xo * ncomp_out + i)) = (unsigned char)0;
#line 1500
            i ++;
          }
          while_break___12: /* CIL Label */ ;
          }
        }
#line 1478
        xo ++;
      }
      while_break___9: /* CIL Label */ ;
      }
#line 1506
      yo ++;
#line 1507
      frac = 16U - frac;
#line 1508
      if (yo < height_out) {
#line 1509
        xo = 0U;
        {
#line 1509
        while (1) {
          while_continue___13: /* CIL Label */ ;
#line 1509
          if (! (xo < width_out * ncomp_in)) {
#line 1509
            goto while_break___13;
          }
#line 1510
          *(sumn + xo) = *(sum1 + xo) * frac;
#line 1509
          xo ++;
        }
        while_break___13: /* CIL Label */ ;
        }
      }
    } else {
#line 1515
      xo = 0U;
      {
#line 1515
      while (1) {
        while_continue___14: /* CIL Label */ ;
#line 1515
        if (! (xo < width_out * ncomp_in)) {
#line 1515
          goto while_break___14;
        }
#line 1516
        *(sumn + xo) += *(sum1 + xo) * 16U;
#line 1515
        xo ++;
      }
      while_break___14: /* CIL Label */ ;
      }
    }
#line 1391
    yi ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 1520
  free((void *)spy);
#line 1521
  free((void *)spx);
#line 1522
  free((void *)sum1);
#line 1523
  free((void *)sumn);
  }
#line 1525
  return (0);
}
}
#line 1532 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/cimg.c"
int image_copy_resize(IMAGE *newimg , IMAGE *oldimg , unsigned int format , float xddpi ,
                      float yddpi , float xrdpi , float yrdpi ) 
{ 
  int temp_format ;
  int grey_format ;
  int tmp ;
  void *tmp___0 ;
  IMAGE tempimg ;
  int tmp___1 ;
  void *tmp___2 ;
  int tmp___3 ;
  void *tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;

  {
#line 1536
  if (xddpi != xrdpi) {
#line 1536
    if (yddpi != yrdpi) {
#line 1536
      if (xddpi <= xrdpi) {
#line 1536
        if (yddpi <= yrdpi) {
          {
#line 1538
          temp_format = 198660;
#line 1541
          grey_format = 198658;
#line 1545
          memset((void *)newimg, 0, sizeof(IMAGE ));
#line 1546
          newimg->width = (unsigned int )((double )(((float )oldimg->width * xddpi) / xrdpi) + 0.5);
#line 1547
          newimg->height = (unsigned int )((double )(((float )oldimg->height * yddpi) / yrdpi) + 0.5);
          }
#line 1548
          if (((long )format & 15L) == 1L) {
#line 1548
            goto _L;
          } else
#line 1548
          if (((long )format & 15L) == 2L) {
            _L: /* CIL Label */ 
#line 1548
            if (((long )format & 65280L) == 256L) {
              {
#line 1552
              newimg->format = image_platform_format((unsigned int )(((((long )format & -16L) & -65281L) | 2L) | 2048L));
              }
            } else {
#line 1556
              newimg->format = format;
            }
          } else {
#line 1556
            newimg->format = format;
          }
          {
#line 1557
          tmp = image_depth(newimg);
#line 1557
          newimg->raster = ((((unsigned int )tmp * newimg->width + 7U) >> 3) + 3U) & 4294967292U;
#line 1560
          tmp___0 = malloc((size_t )(newimg->raster * newimg->height));
#line 1560
          newimg->image = (unsigned char *)tmp___0;
          }
#line 1561
          if ((unsigned long )newimg->image == (unsigned long )((void *)0)) {
#line 1562
            return (-1);
          }
          {
#line 1563
          tmp___6 = image_down_scale(newimg, oldimg);
          }
#line 1563
          if (tmp___6 != 0) {
            {
#line 1569
            free((void *)newimg->image);
#line 1570
            newimg->image = (unsigned char *)((void *)0);
#line 1571
            memset((void *)(& tempimg), 0, sizeof(tempimg));
#line 1572
            tempimg.width = oldimg->width;
#line 1573
            tempimg.height = oldimg->height;
            }
#line 1574
            if (((long )oldimg->format & 15L) == 1L) {
#line 1574
              goto _L___1;
            } else
#line 1574
            if (((long )oldimg->format & 15L) == 2L) {
              _L___1: /* CIL Label */ 
#line 1574
              if (((long )oldimg->format & 65280L) == 256L) {
                {
#line 1585
                tempimg.format = image_platform_format((unsigned int )grey_format);
                }
              } else {
#line 1574
                goto _L___0;
              }
            } else
            _L___0: /* CIL Label */ 
#line 1574
            if (((long )oldimg->format & 15L) == 2L) {
#line 1574
              if (((long )oldimg->format & 65280L) == 2048L) {
                {
#line 1585
                tempimg.format = image_platform_format((unsigned int )grey_format);
                }
              } else {
                {
#line 1587
                tempimg.format = image_platform_format((unsigned int )temp_format);
                }
              }
            } else {
              {
#line 1587
              tempimg.format = image_platform_format((unsigned int )temp_format);
              }
            }
            {
#line 1588
            tmp___1 = image_depth(& tempimg);
#line 1588
            tempimg.raster = ((((unsigned int )tmp___1 * tempimg.width + 7U) >> 3) + 3U) & 4294967292U;
#line 1590
            tmp___2 = malloc((size_t )(tempimg.raster * tempimg.height));
#line 1590
            tempimg.image = (unsigned char *)tmp___2;
            }
#line 1591
            if ((unsigned long )tempimg.image == (unsigned long )((void *)0)) {
#line 1592
              return (-1);
            }
            {
#line 1594
            newimg->format = tempimg.format;
#line 1595
            tmp___3 = image_depth(newimg);
#line 1595
            newimg->raster = ((((unsigned int )tmp___3 * newimg->width + 7U) >> 3) + 3U) & 4294967292U;
#line 1597
            tmp___4 = malloc((size_t )(newimg->raster * newimg->height));
#line 1597
            newimg->image = (unsigned char *)tmp___4;
            }
#line 1598
            if ((unsigned long )newimg->image == (unsigned long )((void *)0)) {
              {
#line 1599
              free((void *)tempimg.image);
              }
#line 1600
              return (-1);
            }
            {
#line 1602
            image_copy(& tempimg, oldimg, tempimg.format);
#line 1603
            tmp___5 = image_down_scale(newimg, & tempimg);
            }
#line 1603
            if (tmp___5 != 0) {
              {
#line 1605
              free((void *)tempimg.image);
#line 1606
              free((void *)newimg->image);
#line 1607
              newimg->image = (unsigned char *)((void *)0);
              }
            } else {
              {
#line 1611
              free((void *)tempimg.image);
#line 1612
              image_platform_init(newimg);
              }
#line 1613
              return (0);
            }
          } else {
            {
#line 1617
            image_platform_init(newimg);
            }
#line 1618
            return (0);
          }
        }
      }
    }
  }
  {
#line 1623
  tmp___7 = image_copy(newimg, oldimg, format);
  }
#line 1623
  return (tmp___7);
}
}
#line 1634 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/cimg.c"
static int a85write(char *line , unsigned char *buf , int count ) 
{ 
  int i ;
  unsigned long value ;
  unsigned char abuf[5] ;

  {
#line 1640
  if (count == 0) {
#line 1641
    return (0);
  }
#line 1642
  if (count < 4) {
#line 1643
    i = count;
    {
#line 1643
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1643
      if (! (i < 4)) {
#line 1643
        goto while_break;
      }
#line 1644
      *(buf + i) = (unsigned char)0;
#line 1643
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 1646
  if (count == 4) {
#line 1646
    if ((int )*(buf + 0) == 0) {
#line 1646
      if ((int )*(buf + 1) == 0) {
#line 1646
        if ((int )*(buf + 2) == 0) {
#line 1646
          if ((int )*(buf + 3) == 0) {
#line 1648
            *(line + 0) = (char )'z';
#line 1649
            return (1);
          }
        }
      }
    }
  }
#line 1651
  value = (unsigned long )(((((unsigned int )*(buf + 0) << 24) + ((unsigned int )*(buf + 1) << 16)) + ((unsigned int )*(buf + 2) << 8)) + (unsigned int )*(buf + 3));
#line 1655
  abuf[0] = (unsigned char )(value / 52200625UL);
#line 1656
  value -= (unsigned long )((long )abuf[0] * 52200625L);
#line 1657
  abuf[1] = (unsigned char )(value / 614125UL);
#line 1658
  value -= (unsigned long )((long )abuf[1] * 614125L);
#line 1659
  abuf[2] = (unsigned char )(value / 7225UL);
#line 1660
  value -= (unsigned long )((long )abuf[2] * 7225L);
#line 1661
  abuf[3] = (unsigned char )(value / 85UL);
#line 1662
  value -= (unsigned long )((long )abuf[3] * 85L);
#line 1663
  abuf[4] = (unsigned char )value;
#line 1664
  i = 0;
  {
#line 1664
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1664
    if (! (i < count + 1)) {
#line 1664
      goto while_break___0;
    }
#line 1665
    *(line + i) = (char )((int )abuf[i] + 33);
#line 1664
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1666
  return (count + 1);
}
}
#line 1675 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/cimg.c"
int packbits(BYTE *comp , BYTE *raw , int length ) 
{ 
  BYTE *cp ;
  int literal ;
  int prevlit ;
  int repeat ;
  int start ;
  BYTE previous ;
  int i ;
  int j ;
  BYTE *tmp ;
  BYTE *tmp___0 ;
  BYTE *tmp___1 ;
  BYTE *tmp___2 ;
  BYTE *tmp___3 ;
  BYTE *tmp___4 ;
  BYTE *tmp___5 ;
  BYTE *tmp___6 ;
  BYTE *tmp___7 ;
  BYTE *tmp___8 ;
  BYTE *tmp___9 ;
  BYTE *tmp___10 ;
  BYTE *tmp___11 ;
  BYTE *tmp___12 ;

  {
#line 1679
  literal = 0;
#line 1680
  prevlit = 0;
#line 1681
  repeat = 0;
#line 1682
  start = 0;
#line 1683
  previous = *(raw + 0);
#line 1686
  cp = comp;
#line 1687
  i = 0;
  {
#line 1687
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1687
    if (! (i < length)) {
#line 1687
      goto while_break;
    }
#line 1688
    if (literal == 128) {
#line 1690
      tmp = cp;
#line 1690
      cp ++;
#line 1690
      *tmp = (BYTE )(literal - 1);
#line 1691
      j = 0;
      {
#line 1691
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1691
        if (! (j < literal)) {
#line 1691
          goto while_break___0;
        }
#line 1692
        tmp___0 = cp;
#line 1692
        cp ++;
#line 1692
        *tmp___0 = *(raw + (start + j));
#line 1691
        j ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 1693
      prevlit = 0;
#line 1694
      literal = 0;
#line 1696
      start = i;
#line 1697
      previous = *(raw + i);
    }
#line 1699
    if (repeat == 128) {
#line 1701
      tmp___1 = cp;
#line 1701
      cp ++;
#line 1701
      *tmp___1 = (BYTE )-127;
#line 1702
      tmp___2 = cp;
#line 1702
      cp ++;
#line 1702
      *tmp___2 = previous;
#line 1703
      repeat = 0;
#line 1704
      literal = 0;
#line 1705
      start = i;
#line 1706
      prevlit = 0;
#line 1707
      previous = *(raw + i);
    }
#line 1709
    if ((int )*(raw + i) == (int )previous) {
#line 1710
      if (literal == 1) {
#line 1712
        repeat = 1;
#line 1713
        literal = 0;
      } else
#line 1715
      if (literal) {
#line 1717
        literal --;
#line 1718
        tmp___3 = cp;
#line 1718
        cp ++;
#line 1718
        *tmp___3 = (BYTE )(literal - 1);
#line 1719
        j = 0;
        {
#line 1719
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 1719
          if (! (j < literal)) {
#line 1719
            goto while_break___1;
          }
#line 1720
          tmp___4 = cp;
#line 1720
          cp ++;
#line 1720
          *tmp___4 = *(raw + (start + j));
#line 1719
          j ++;
        }
        while_break___1: /* CIL Label */ ;
        }
#line 1721
        if (literal < 126) {
#line 1722
          prevlit = literal;
        } else {
#line 1724
          prevlit = 0;
        }
#line 1726
        start = i - 1;
#line 1727
        repeat = 1;
#line 1728
        literal = 0;
      }
#line 1730
      repeat ++;
    } else {
#line 1734
      if (repeat) {
#line 1736
        if (repeat == 1) {
#line 1738
          literal = repeat;
#line 1739
          repeat = 0;
        } else
#line 1740
        if (repeat == 2) {
#line 1743
          if (prevlit) {
#line 1743
            if (prevlit < 126) {
#line 1745
              start -= prevlit;
#line 1746
              cp -= prevlit + 1;
#line 1747
              literal = prevlit + 2;
#line 1748
              prevlit = 0;
#line 1749
              repeat = 0;
            } else {
#line 1743
              goto _L;
            }
          } else {
            _L: /* CIL Label */ 
#line 1753
            tmp___5 = cp;
#line 1753
            cp ++;
#line 1753
            *tmp___5 = (BYTE )(- repeat + 1);
#line 1754
            tmp___6 = cp;
#line 1754
            cp ++;
#line 1754
            *tmp___6 = previous;
#line 1755
            start = i;
#line 1756
            prevlit = 0;
#line 1758
            repeat = 0;
          }
        } else {
#line 1764
          tmp___7 = cp;
#line 1764
          cp ++;
#line 1764
          *tmp___7 = (BYTE )(- repeat + 1);
#line 1765
          tmp___8 = cp;
#line 1765
          cp ++;
#line 1765
          *tmp___8 = previous;
#line 1766
          start = i;
#line 1767
          repeat = 0;
#line 1768
          prevlit = 0;
        }
      }
#line 1771
      literal ++;
    }
#line 1773
    previous = *(raw + i);
#line 1687
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1775
  if (repeat == 1) {
#line 1777
    literal = 1;
#line 1778
    repeat = 0;
  }
#line 1780
  if (literal) {
#line 1782
    tmp___9 = cp;
#line 1782
    cp ++;
#line 1782
    *tmp___9 = (BYTE )(literal - 1);
#line 1783
    j = 0;
    {
#line 1783
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 1783
      if (! (j < literal)) {
#line 1783
        goto while_break___2;
      }
#line 1784
      tmp___10 = cp;
#line 1784
      cp ++;
#line 1784
      *tmp___10 = *(raw + (start + j));
#line 1783
      j ++;
    }
    while_break___2: /* CIL Label */ ;
    }
  }
#line 1786
  if (repeat) {
#line 1788
    tmp___11 = cp;
#line 1788
    cp ++;
#line 1788
    *tmp___11 = (BYTE )(- repeat + 1);
#line 1789
    tmp___12 = cp;
#line 1789
    cp ++;
#line 1789
    *tmp___12 = previous;
  }
#line 1791
  return ((int )(cp - comp));
}
}
#line 1803 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/cimg.c"
int image_to_eps(GFile *f , IMAGE *img , int llx , int lly , int urx , int ury , float fllx ,
                 float flly , float furx , float fury , int use_a85 , int compress ) 
{ 
  int x ;
  int y ;
  int topfirst ;
  int bigendian ;
  int hires_bbox_valid ;
  unsigned char *row ;
  int i ;
  int ncomp ;
  int count ;
  char hex___0[17] ;
  unsigned char *packin ;
  unsigned char *packout ;
  int packin_count ;
  int packout_count ;
  int packout_len ;
  int separate ;
  int depth ;
  int compwidth ;
  BOOL convert ;
  BOOL invert ;
  unsigned char *convert_row ;
  char buf[256] ;
  lzw_state_t *lzw ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int inlen ;
  int outlen ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;

  {
#line 1810
  hires_bbox_valid = 1;
#line 1814
  count = 0;
#line 1815
  hex___0[0] = (char )'0';
#line 1815
  hex___0[1] = (char )'1';
#line 1815
  hex___0[2] = (char )'2';
#line 1815
  hex___0[3] = (char )'3';
#line 1815
  hex___0[4] = (char )'4';
#line 1815
  hex___0[5] = (char )'5';
#line 1815
  hex___0[6] = (char )'6';
#line 1815
  hex___0[7] = (char )'7';
#line 1815
  hex___0[8] = (char )'8';
#line 1815
  hex___0[9] = (char )'9';
#line 1815
  hex___0[10] = (char )'a';
#line 1815
  hex___0[11] = (char )'b';
#line 1815
  hex___0[12] = (char )'c';
#line 1815
  hex___0[13] = (char )'d';
#line 1815
  hex___0[14] = (char )'e';
#line 1815
  hex___0[15] = (char )'f';
#line 1815
  hex___0[16] = (char )'\000';
#line 1821
  separate = 0;
#line 1824
  convert = 0;
#line 1825
  invert = 0;
#line 1826
  convert_row = (unsigned char *)((void *)0);
#line 1828
  lzw = (lzw_state_t *)((void *)0);
#line 1830
  if (fllx >= furx) {
#line 1831
    hires_bbox_valid = 0;
  } else
#line 1830
  if (flly >= fury) {
#line 1831
    hires_bbox_valid = 0;
  }
#line 1833
  topfirst = ((long )img->format & 131072L) == 0L;
#line 1834
  bigendian = ((long )img->format & 65536L) == 0L;
#line 1836
  if (((long )img->format & 65280L) == 256L) {
#line 1837
    depth = 1;
#line 1838
    compwidth = (int )((img->width + 7U) >> 3);
  } else
#line 1840
  if (((long )img->format & 65280L) == 1024L) {
#line 1841
    depth = 4;
#line 1842
    compwidth = (int )((img->width + 1U) >> 1);
  } else
#line 1844
  if (((long )img->format & 65280L) == 2048L) {
#line 1845
    depth = 8;
#line 1846
    compwidth = (int )img->width;
  } else {
#line 1849
    return (-1);
  }
#line 1852
  if (((long )img->format & 15L) == 8L) {
#line 1853
    ncomp = 4;
  } else
#line 1854
  if (((long )img->format & 15L) == 4L) {
#line 1855
    ncomp = 3;
#line 1856
    if (((long )img->format & 112L) != 0L) {
#line 1857
      convert = 1;
#line 1858
      compwidth = (int )img->width;
#line 1859
      bigendian = 1;
    }
  } else
#line 1862
  if (((long )img->format & 15L) == 2L) {
#line 1863
    ncomp = 1;
  } else
#line 1864
  if (((long )img->format & 15L) == 1L) {
#line 1865
    if (depth == 1) {
#line 1866
      ncomp = 1;
#line 1867
      invert = 1;
    } else {
#line 1870
      ncomp = 3;
#line 1871
      compwidth = (int )img->width;
#line 1872
      convert = 1;
#line 1873
      bigendian = 1;
    }
  } else {
#line 1877
    return (-1);
  }
  {
#line 1879
  tmp = malloc((size_t )(compwidth * ncomp));
#line 1879
  packin = (unsigned char *)tmp;
  }
#line 1880
  if ((unsigned long )packin == (unsigned long )((void *)0)) {
#line 1881
    return (-1);
  }
  {
#line 1882
  packout_len = ((compwidth * ncomp) * 5) / 4 + 4;
#line 1883
  tmp___0 = malloc((size_t )packout_len);
#line 1883
  packout = (unsigned char *)tmp___0;
  }
#line 1884
  if ((unsigned long )packout == (unsigned long )((void *)0)) {
    {
#line 1885
    free((void *)packin);
    }
#line 1886
    return (-1);
  }
#line 1888
  if (convert) {
    {
#line 1889
    tmp___1 = malloc((size_t )(compwidth * ncomp));
#line 1889
    convert_row = (unsigned char *)tmp___1;
    }
#line 1890
    if ((unsigned long )convert_row == (unsigned long )((void *)0)) {
      {
#line 1891
      free((void *)packin);
#line 1892
      free((void *)packout);
      }
#line 1893
      return (-1);
    }
  }
#line 1896
  if (compress == 2) {
    {
#line 1897
    lzw = lzw_new();
    }
#line 1898
    if ((unsigned long )lzw == (unsigned long )((lzw_state_t *)((void *)0))) {
      {
#line 1899
      free((void *)packin);
#line 1900
      free((void *)packout);
      }
#line 1901
      if (convert_row) {
        {
#line 1902
        free((void *)convert_row);
        }
      }
#line 1903
      return (-1);
    }
  }
  {
#line 1907
  gfile_puts(f, "%!PS-Adobe-3.0 EPSF-3.0\n");
#line 1908
  snprintf((char */* __restrict  */)(buf), sizeof(buf) - 1UL, (char const   */* __restrict  */)"%%%%BoundingBox: %d %d %d %d\n",
           llx, lly, urx, ury);
#line 1910
  gfile_puts(f, (char const   *)(buf));
  }
#line 1911
  if (hires_bbox_valid) {
    {
#line 1912
    snprintf((char */* __restrict  */)(buf), sizeof(buf) - 1UL, (char const   */* __restrict  */)"%%%%HiResBoundingBox: %g %g %g %g\n",
             (double )fllx, (double )flly, (double )furx, (double )fury);
#line 1914
    gfile_puts(f, (char const   *)(buf));
    }
  }
  {
#line 1916
  gfile_puts(f, "%%Pages: 1\n");
#line 1917
  gfile_puts(f, "%%EndComments\n");
#line 1918
  gfile_puts(f, "%%Page: 1 1\n");
#line 1919
  gfile_puts(f, "gsave\n");
  }
#line 1920
  if (hires_bbox_valid) {
    {
#line 1921
    snprintf((char */* __restrict  */)(buf), sizeof(buf) - 1UL, (char const   */* __restrict  */)"%g %g translate\n",
             (double )fllx, (double )flly);
#line 1922
    gfile_puts(f, (char const   *)(buf));
#line 1923
    snprintf((char */* __restrict  */)(buf), sizeof(buf) - 1UL, (char const   */* __restrict  */)"%g %g scale\n",
             (double )(furx - fllx), (double )(fury - flly));
#line 1924
    gfile_puts(f, (char const   *)(buf));
    }
  } else {
    {
#line 1927
    snprintf((char */* __restrict  */)(buf), sizeof(buf) - 1UL, (char const   */* __restrict  */)"%d %d translate\n",
             llx, lly);
#line 1928
    gfile_puts(f, (char const   *)(buf));
#line 1929
    snprintf((char */* __restrict  */)(buf), sizeof(buf) - 1UL, (char const   */* __restrict  */)"%d %d scale\n",
             urx - llx, ury - lly);
#line 1930
    gfile_puts(f, (char const   *)(buf));
    }
  }
#line 1932
  if (ncomp == 1) {
    {
#line 1933
    gfile_puts(f, "/DeviceGray setcolorspace\n");
    }
  } else
#line 1934
  if (ncomp == 3) {
    {
#line 1935
    gfile_puts(f, "/DeviceRGB setcolorspace\n");
    }
  } else
#line 1936
  if (ncomp == 4) {
    {
#line 1937
    gfile_puts(f, "/DeviceCMYK setcolorspace\n");
    }
  }
#line 1938
  if (ncomp > 1) {
#line 1938
    if (compress != 0) {
#line 1943
      separate = 1;
    }
  }
#line 1945
  if (separate) {
#line 1948
    if (use_a85) {
      {
#line 1949
      gfile_puts(f, "/infile currentfile /ASCII85Decode filter");
      }
    } else {
      {
#line 1951
      gfile_puts(f, "/infile currentfile /ASCIIHexDecode filter");
      }
    }
#line 1952
    if (compress == 2) {
      {
#line 1953
      gfile_puts(f, " /LZWDecode filter");
      }
    } else
#line 1954
    if (compress == 1) {
      {
#line 1955
      gfile_puts(f, " /RunLengthDecode filter");
      }
    }
    {
#line 1956
    gfile_puts(f, " def\n");
#line 1957
    i = 0;
    }
    {
#line 1957
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1957
      if (! (i < ncomp)) {
#line 1957
        goto while_break;
      }
      {
#line 1958
      snprintf((char */* __restrict  */)(buf), sizeof(buf) - 1UL, (char const   */* __restrict  */)"/str%d %d string def\n",
               i, img->width);
#line 1960
      gfile_puts(f, (char const   *)(buf));
#line 1957
      i ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 1963
  gfile_puts(f, "<<\n /ImageType 1\n");
#line 1964
  snprintf((char */* __restrict  */)(buf), sizeof(buf) - 1UL, (char const   */* __restrict  */)" /Width %d\n",
           img->width);
#line 1965
  gfile_puts(f, (char const   *)(buf));
#line 1966
  snprintf((char */* __restrict  */)(buf), sizeof(buf) - 1UL, (char const   */* __restrict  */)" /Height %d\n",
           img->height);
#line 1967
  gfile_puts(f, (char const   *)(buf));
#line 1968
  snprintf((char */* __restrict  */)(buf), sizeof(buf) - 1UL, (char const   */* __restrict  */)" /BitsPerComponent %d\n",
           depth);
#line 1969
  gfile_puts(f, (char const   *)(buf));
#line 1970
  gfile_puts(f, " /Decode [ ");
#line 1971
  i = 0;
  }
  {
#line 1971
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1971
    if (! (i < ncomp)) {
#line 1971
      goto while_break___0;
    }
#line 1972
    if (invert) {
      {
#line 1973
      gfile_puts(f, "1 0 ");
      }
    } else {
      {
#line 1975
      gfile_puts(f, "0 1 ");
      }
    }
#line 1971
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 1977
  gfile_puts(f, "]\n");
#line 1978
  snprintf((char */* __restrict  */)(buf), sizeof(buf) - 1UL, (char const   */* __restrict  */)" /ImageMatrix [%d 0 0 %d 0 %d]\n",
           img->width, - ((int )img->height), img->height);
#line 1980
  gfile_puts(f, (char const   *)(buf));
  }
#line 1981
  if (separate) {
    {
#line 1982
    gfile_puts(f, " /MultipleDataSources true\n");
#line 1983
    gfile_puts(f, " /DataSource [\n");
#line 1984
    i = 0;
    }
    {
#line 1984
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1984
      if (! (i < ncomp)) {
#line 1984
        goto while_break___1;
      }
      {
#line 1985
      snprintf((char */* __restrict  */)(buf), sizeof(buf) - 1UL, (char const   */* __restrict  */)"  {infile str%d readstring pop}\n",
               i);
#line 1987
      gfile_puts(f, (char const   *)(buf));
#line 1984
      i ++;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 1989
    gfile_puts(f, " ]\n");
    }
  } else {
#line 1992
    if (use_a85) {
      {
#line 1993
      gfile_puts(f, " /DataSource currentfile /ASCII85Decode filter\n");
      }
    } else {
      {
#line 1995
      gfile_puts(f, " /DataSource currentfile /ASCIIHexDecode filter\n");
      }
    }
#line 1996
    if (compress == 2) {
      {
#line 1997
      gfile_puts(f, " /LZWDecode filter\n");
      }
    } else
#line 1998
    if (compress == 1) {
      {
#line 1999
      gfile_puts(f, " /RunLengthDecode filter\n");
      }
    }
  }
  {
#line 2001
  gfile_puts(f, ">>\nimage\n");
#line 2002
  count = 0;
#line 2003
  packout_count = 0;
#line 2004
  y = 0;
  }
  {
#line 2004
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 2004
    if (! (y < (int )img->height)) {
#line 2004
      goto while_break___2;
    }
#line 2005
    if (topfirst != 0) {
#line 2005
      tmp___2 = y;
    } else {
#line 2005
      tmp___2 = ((int )img->height - y) - 1;
    }
#line 2005
    row = img->image + img->raster * (unsigned int )tmp___2;
#line 2007
    if (convert) {
      {
#line 2008
      image_to_24RGB(img, convert_row, row);
#line 2009
      row = convert_row;
      }
    }
#line 2011
    packin_count = 0;
#line 2012
    if (separate) {
#line 2013
      if (bigendian) {
#line 2014
        i = 0;
        {
#line 2014
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 2014
          if (! (i < ncomp)) {
#line 2014
            goto while_break___3;
          }
#line 2015
          x = 0;
          {
#line 2015
          while (1) {
            while_continue___4: /* CIL Label */ ;
#line 2015
            if (! (x < compwidth)) {
#line 2015
              goto while_break___4;
            }
#line 2016
            tmp___3 = packin_count;
#line 2016
            packin_count ++;
#line 2016
            *(packin + tmp___3) = *(row + (x * ncomp + i));
#line 2015
            x ++;
          }
          while_break___4: /* CIL Label */ ;
          }
#line 2014
          i ++;
        }
        while_break___3: /* CIL Label */ ;
        }
      } else {
#line 2019
        i = ncomp - 1;
        {
#line 2019
        while (1) {
          while_continue___5: /* CIL Label */ ;
#line 2019
          if (! (i >= 0)) {
#line 2019
            goto while_break___5;
          }
#line 2020
          x = 0;
          {
#line 2020
          while (1) {
            while_continue___6: /* CIL Label */ ;
#line 2020
            if (! (x < compwidth)) {
#line 2020
              goto while_break___6;
            }
#line 2021
            tmp___4 = packin_count;
#line 2021
            packin_count ++;
#line 2021
            *(packin + tmp___4) = *(row + (x * ncomp + i));
#line 2020
            x ++;
          }
          while_break___6: /* CIL Label */ ;
          }
#line 2019
          i --;
        }
        while_break___5: /* CIL Label */ ;
        }
      }
    } else {
#line 2025
      x = 0;
      {
#line 2025
      while (1) {
        while_continue___7: /* CIL Label */ ;
#line 2025
        if (! (x < compwidth)) {
#line 2025
          goto while_break___7;
        }
#line 2026
        if (bigendian) {
#line 2027
          i = 0;
          {
#line 2027
          while (1) {
            while_continue___8: /* CIL Label */ ;
#line 2027
            if (! (i < ncomp)) {
#line 2027
              goto while_break___8;
            }
#line 2028
            tmp___5 = packin_count;
#line 2028
            packin_count ++;
#line 2028
            *(packin + tmp___5) = *(row + (x * ncomp + i));
#line 2027
            i ++;
          }
          while_break___8: /* CIL Label */ ;
          }
        } else {
#line 2031
          i = ncomp - 1;
          {
#line 2031
          while (1) {
            while_continue___9: /* CIL Label */ ;
#line 2031
            if (! (i >= 0)) {
#line 2031
              goto while_break___9;
            }
#line 2032
            tmp___6 = packin_count;
#line 2032
            packin_count ++;
#line 2032
            *(packin + tmp___6) = *(row + (x * ncomp + i));
#line 2031
            i --;
          }
          while_break___9: /* CIL Label */ ;
          }
        }
#line 2025
        x ++;
      }
      while_break___7: /* CIL Label */ ;
      }
    }
#line 2036
    if (compress == 2) {
      {
#line 2037
      inlen = packin_count;
#line 2038
      outlen = packout_len - packout_count;
#line 2039
      lzw_compress(lzw, (unsigned char const   *)packin, & inlen, packout + packout_count,
                   & outlen);
#line 2040
      packout_count += outlen;
      }
#line 2041
      if (y == (int )img->height - 1) {
        {
#line 2044
        inlen = 0;
#line 2045
        outlen = packout_len - packout_count;
#line 2046
        lzw_compress(lzw, (unsigned char const   *)packin, & inlen, packout + packout_count,
                     & outlen);
#line 2048
        packout_count += outlen;
        }
      }
    } else
#line 2051
    if (compress == 1) {
      {
#line 2052
      tmp___7 = packbits(packout + packout_count, packin, packin_count);
#line 2052
      packout_count += tmp___7;
      }
    } else {
      {
#line 2056
      memcpy((void */* __restrict  */)(packout + packout_count), (void const   */* __restrict  */)packin,
             (size_t )packin_count);
#line 2057
      packout_count += packin_count;
      }
    }
#line 2059
    i = 0;
    {
#line 2059
    while (1) {
      while_continue___10: /* CIL Label */ ;
#line 2059
      if (! (i < packout_count)) {
#line 2059
        goto while_break___10;
      }
#line 2060
      if (use_a85) {
#line 2061
        if (packout_count - i < 4) {
#line 2062
          goto while_break___10;
        } else {
          {
#line 2064
          tmp___8 = a85write(buf + count, packout + i, 4);
#line 2064
          count += tmp___8;
          }
        }
#line 2065
        i += 3;
      } else {
#line 2068
        tmp___9 = count;
#line 2068
        count ++;
#line 2068
        buf[tmp___9] = hex___0[((int )*(packout + i) >> 4) & 15];
#line 2069
        tmp___10 = count;
#line 2069
        count ++;
#line 2069
        buf[tmp___10] = hex___0[(int )*(packout + i) & 15];
      }
#line 2071
      if (count >= 70) {
        {
#line 2072
        tmp___11 = count;
#line 2072
        count ++;
#line 2072
        buf[tmp___11] = (char )'\n';
#line 2073
        gfile_write(f, (void const   *)(buf), (unsigned int )count);
#line 2074
        count = 0;
        }
      }
#line 2059
      i ++;
    }
    while_break___10: /* CIL Label */ ;
    }
#line 2078
    if (packout_count - i > 0) {
      {
#line 2079
      memmove((void *)packout, (void const   *)(packout + i), (size_t )(packout_count - i));
      }
    }
#line 2080
    packout_count -= i;
#line 2004
    y ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 2082
  if (use_a85) {
#line 2083
    if (packout_count) {
      {
#line 2084
      tmp___12 = a85write(buf + count, packout, packout_count);
#line 2084
      count += tmp___12;
      }
    }
#line 2085
    tmp___13 = count;
#line 2085
    count ++;
#line 2085
    buf[tmp___13] = (char )'~';
#line 2086
    tmp___14 = count;
#line 2086
    count ++;
#line 2086
    buf[tmp___14] = (char )'>';
#line 2087
    tmp___15 = count;
#line 2087
    count ++;
#line 2087
    buf[tmp___15] = (char )'\n';
  } else {
#line 2090
    tmp___16 = count;
#line 2090
    count ++;
#line 2090
    buf[tmp___16] = (char )'>';
#line 2091
    tmp___17 = count;
#line 2091
    count ++;
#line 2091
    buf[tmp___17] = (char )'\n';
  }
  {
#line 2093
  gfile_write(f, (void const   *)(buf), (unsigned int )count);
#line 2094
  gfile_puts(f, "grestore\n");
#line 2095
  gfile_puts(f, "showpage\n");
#line 2096
  gfile_puts(f, "%%Trailer\n");
#line 2097
  gfile_puts(f, "%%EOF\n");
  }
#line 2098
  if (lzw) {
    {
#line 2099
    lzw_free(lzw);
    }
  }
#line 2100
  if (convert) {
    {
#line 2101
    free((void *)convert_row);
    }
  }
  {
#line 2102
  free((void *)packin);
#line 2103
  free((void *)packout);
  }
#line 2104
  return (0);
}
}
#line 2107 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/cimg.c"
int image_to_epsfile(IMAGE *img , char const   *filename , float xdpi , float ydpi ) 
{ 
  GFile *f ;
  int code ;
  int width ;
  int height ;

  {
#line 2111
  code = 0;
#line 2112
  width = (int )(((double )img->width * 72.0) / (double )xdpi);
#line 2113
  height = (int )(((double )img->height * 72.0) / (double )ydpi);
#line 2116
  if ((unsigned long )img == (unsigned long )((void *)0)) {
#line 2117
    return (-1);
  } else
#line 2116
  if ((unsigned long )img->image == (unsigned long )((void *)0)) {
#line 2117
    return (-1);
  }
  {
#line 2119
  f = gfile_open(filename, 4097U);
  }
#line 2120
  if ((unsigned long )f == (unsigned long )((void *)0)) {
#line 2121
    return (-1);
  }
  {
#line 2123
  code = image_to_eps(f, img, 0, 0, width, height, (float )0.0, (float )0.0, (float )width,
                      (float )height, 1, 2);
#line 2127
  gfile_close(f);
  }
#line 2128
  return (code);
}
}
#line 433 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) sscanf)(char const   * __restrict  __s ,
                                                                             char const   * __restrict  __format 
                                                                             , ...)  __asm__("__isoc99_sscanf")  ;
#line 192 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) time_t ( __attribute__((__leaf__)) time)(time_t *__timer ) ;
#line 243
extern  __attribute__((__nothrow__)) struct tm *( __attribute__((__leaf__)) localtime)(time_t const   *__timer ) ;
#line 71 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/cbmp.h"
IMAGE *bmpfile_to_image(char const   *filename ) ;
#line 72
IMAGE *bmp_to_image(unsigned char *pbitmap , unsigned int length ) ;
#line 73
IMAGE *pnmfile_to_image(char const   *filename ) ;
#line 74
void bitmap_image_free(IMAGE *img ) ;
#line 75
int image_to_bmpfile(IMAGE *img , char const   *filename , float xdpi , float ydpi ) ;
#line 76
int image_to_pnmfile(IMAGE *img , char const   *filename , PNM_FORMAT pnm_format ) ;
#line 77
int image_to_tifffile(IMAGE *img , char const   *filename , float xdpi , float ydpi ) ;
#line 78
int image_to_pngfile(IMAGE *img , char const   *filename ) ;
#line 79
int image_to_pictfile(IMAGE *img , char const   *filename , float xdpi , float ydpi ) ;
#line 80
IMAGE *pngfile_to_image(char const   *filename ) ;
#line 82
int image_to_tiff(GFile *f , IMAGE *img , int xoffset , int yoffset , int width ,
                  int height , float xdpi , float ydpi , BOOL tiff4 , BOOL use_packbits ) ;
#line 87
void write_dword(DWORD val , GFile *f ) ;
#line 88
void write_word_as_dword(WORD val , GFile *f ) ;
#line 89
void write_word(WORD val , GFile *f ) ;
#line 90
DWORD get_dword(unsigned char const   *buf ) ;
#line 91
WORD get_word(unsigned char const   *buf ) ;
#line 37 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/cbmp.c"
static int read_pbm_bits(unsigned char *pbitmap , unsigned int width , unsigned int height ,
                         GFile *f ) ;
#line 39
static int read_pgnm_bytes(unsigned char *pbitmap , unsigned int length , GFile *f ) ;
#line 41
static int image_bmp2init(IMAGE *img , BITMAP2 *bmp2 ) ;
#line 42
static void shift_bits(unsigned char *bits , int bwidth , int offset ) ;
#line 43
static void write_bigendian_dword(DWORD val , GFile *f ) ;
#line 44
static void write_bigendian_word(WORD val , GFile *f ) ;
#line 46 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/cbmp.c"
static char const   szGSviewName[7]  = {      (char const   )'G',      (char const   )'S',      (char const   )'v',      (char const   )'i', 
        (char const   )'e',      (char const   )'w',      (char const   )'\000'};
#line 50 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/cbmp.c"
DWORD get_dword(unsigned char const   *buf ) 
{ 
  DWORD dw ;

  {
#line 54
  dw = (DWORD )*(buf + 0);
#line 55
  dw += (DWORD )*(buf + 1) << 8;
#line 56
  dw += (DWORD )*(buf + 2) << 16;
#line 57
  dw += (DWORD )*(buf + 3) << 24;
#line 58
  return (dw);
}
}
#line 61 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/cbmp.c"
WORD get_word(unsigned char const   *buf ) 
{ 
  WORD w ;

  {
#line 65
  w = (WORD )*(buf + 0);
#line 66
  w = (WORD )((int )w | (int )((WORD )((int const   )*(buf + 1) << 8)));
#line 67
  return (w);
}
}
#line 71 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/cbmp.c"
void write_dword(DWORD val , GFile *f ) 
{ 
  unsigned char dw[4] ;

  {
  {
#line 75
  dw[0] = (unsigned char )(val & 255UL);
#line 76
  dw[1] = (unsigned char )((val >> 8) & 255UL);
#line 77
  dw[2] = (unsigned char )((val >> 16) & 255UL);
#line 78
  dw[3] = (unsigned char )((val >> 24) & 255UL);
#line 79
  gfile_write(f, (void const   *)(& dw), 4U);
  }
#line 80
  return;
}
}
#line 83 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/cbmp.c"
void write_word_as_dword(WORD val , GFile *f ) 
{ 
  unsigned char dw[4] ;

  {
  {
#line 87
  dw[0] = (unsigned char )((int )val & 255);
#line 88
  dw[1] = (unsigned char )(((int )val >> 8) & 255);
#line 89
  dw[2] = (unsigned char )'\000';
#line 90
  dw[3] = (unsigned char )'\000';
#line 91
  gfile_write(f, (void const   *)(& dw), 4U);
  }
#line 92
  return;
}
}
#line 95 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/cbmp.c"
void write_word(WORD val , GFile *f ) 
{ 
  unsigned char w[2] ;

  {
  {
#line 99
  w[0] = (unsigned char )((int )val & 255);
#line 100
  w[1] = (unsigned char )(((int )val >> 8) & 255);
#line 101
  gfile_write(f, (void const   *)(& w), 2U);
  }
#line 102
  return;
}
}
#line 105 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/cbmp.c"
static void write_bigendian_dword(DWORD val , GFile *f ) 
{ 
  unsigned char dw[4] ;

  {
  {
#line 109
  dw[3] = (unsigned char )(val & 255UL);
#line 110
  dw[2] = (unsigned char )((val >> 8) & 255UL);
#line 111
  dw[1] = (unsigned char )((val >> 16) & 255UL);
#line 112
  dw[0] = (unsigned char )((val >> 24) & 255UL);
#line 113
  gfile_write(f, (void const   *)(& dw), 4U);
  }
#line 114
  return;
}
}
#line 117 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/cbmp.c"
static void write_bigendian_word(WORD val , GFile *f ) 
{ 
  unsigned char w[2] ;

  {
  {
#line 121
  w[1] = (unsigned char )((int )val & 255);
#line 122
  w[0] = (unsigned char )(((int )val >> 8) & 255);
#line 123
  gfile_write(f, (void const   *)(& w), 2U);
  }
#line 124
  return;
}
}
#line 129 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/cbmp.c"
static void shift_bits(unsigned char *bits , int bwidth , int offset ) 
{ 
  int bitoffset ;
  int byteoffset ;
  int newwidth ;
  int shifter ;
  int i ;

  {
#line 137
  if (offset == 0) {
#line 138
    return;
  }
  {
#line 139
  byteoffset = offset / 8;
#line 140
  newwidth = bwidth - byteoffset;
#line 142
  memmove((void *)bits, (void const   *)(bits + byteoffset), (size_t )newwidth);
#line 143
  memset((void *)(bits + newwidth), 255, (size_t )(bwidth - newwidth));
#line 145
  bitoffset = offset - byteoffset * 8;
  }
#line 146
  if (bitoffset == 0) {
#line 147
    return;
  }
#line 148
  bitoffset = 8 - bitoffset;
#line 149
  i = 0;
  {
#line 149
  while (1) {
    while_continue: /* CIL Label */ ;
#line 149
    if (! (i < newwidth)) {
#line 149
      goto while_break;
    }
#line 150
    shifter = (int )*(bits + i) << 8;
#line 151
    if (i == newwidth - 1) {
#line 152
      shifter += 255;
    } else {
#line 154
      shifter += (int )*(bits + (i + 1));
    }
#line 155
    *(bits + i) = (unsigned char )(shifter >> bitoffset);
#line 149
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 157
  return;
}
}
#line 168 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/cbmp.c"
IMAGE *bmpfile_to_image(char const   *filename ) 
{ 
  GFile *f ;
  GFile *tmp ;
  IMAGE *img ;
  unsigned char bmf_buf[14] ;
  unsigned char *pbitmap ;
  unsigned int length ;
  unsigned int count ;
  BITMAPFILE bmf ;
  void *tmp___0 ;
  unsigned int tmp___1 ;

  {
  {
#line 171
  tmp = gfile_open(filename, 0U);
#line 171
  f = tmp;
  }
#line 178
  if ((unsigned long )f == (unsigned long )((GFile *)((void *)0))) {
#line 179
    return ((IMAGE *)((void *)0));
  }
  {
#line 180
  gfile_read(f, (void *)(bmf_buf), (unsigned int )sizeof(bmf_buf));
  }
#line 181
  if ((int )bmf_buf[0] != 66) {
    {
#line 183
    gfile_close(f);
    }
#line 184
    return ((IMAGE *)((void *)0));
  } else
#line 181
  if ((int )bmf_buf[1] != 77) {
    {
#line 183
    gfile_close(f);
    }
#line 184
    return ((IMAGE *)((void *)0));
  }
  {
#line 186
  bmf.bfType = get_word((unsigned char const   *)(bmf_buf));
#line 187
  bmf.bfSize = get_dword((unsigned char const   *)(bmf_buf + 2));
#line 188
  bmf.bfReserved1 = get_word((unsigned char const   *)(bmf_buf + 6));
#line 189
  bmf.bfReserved1 = get_word((unsigned char const   *)(bmf_buf + 8));
#line 190
  bmf.bfOffBits = get_dword((unsigned char const   *)(bmf_buf + 10));
#line 191
  length = (unsigned int )(bmf.bfSize - 14UL);
#line 193
  tmp___0 = malloc((size_t )length);
#line 193
  pbitmap = (unsigned char *)tmp___0;
  }
#line 194
  if ((unsigned long )pbitmap == (unsigned long )((void *)0)) {
    {
#line 195
    gfile_close(f);
    }
#line 196
    return ((IMAGE *)((void *)0));
  }
  {
#line 199
  tmp___1 = gfile_read(f, (void *)pbitmap, length);
#line 199
  count = (unsigned int )((int )tmp___1);
#line 200
  gfile_close(f);
#line 202
  img = bmp_to_image(pbitmap, length);
#line 203
  free((void *)pbitmap);
  }
#line 205
  return (img);
}
}
#line 208 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/cbmp.c"
static unsigned char const   clr555[12]  = 
#line 208
  {      (unsigned char const   )31,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )224,      (unsigned char const   )3,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )124,      (unsigned char const   )0,      (unsigned char const   )0};
#line 213 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/cbmp.c"
static unsigned char const   clr565[12]  = 
#line 213
  {      (unsigned char const   )31,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )224,      (unsigned char const   )7,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )248,      (unsigned char const   )0,      (unsigned char const   )0};
#line 219 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/cbmp.c"
IMAGE *bmp_to_image(unsigned char *pbitmap , unsigned int length ) 
{ 
  BITMAP2 bmp2 ;
  RGB4 colour[256] ;
  int depth ;
  int palcount ;
  int pallength ;
  int bytewidth ;
  BOOL convert ;
  int i ;
  int x ;
  int y ;
  IMAGE img ;
  IMAGE *pimage ;
  unsigned char *bits ;
  unsigned char *dest ;
  DWORD tmp ;
  DWORD tmp___0 ;
  DWORD tmp___1 ;
  DWORD tmp___2 ;
  BOOL grey ;
  int tmp___3 ;
  int tmp___4 ;
  unsigned char clr888[12] ;
  int tmp___5 ;
  void *tmp___6 ;
  int idx ;
  int shift ;
  unsigned char *tmp___7 ;
  unsigned char *tmp___8 ;
  unsigned char *tmp___9 ;
  unsigned char *tmp___10 ;
  unsigned char *tmp___11 ;
  unsigned char *tmp___12 ;
  unsigned char *tmp___13 ;
  unsigned char *tmp___14 ;
  unsigned char *tmp___15 ;
  unsigned char *tmp___16 ;
  unsigned char *tmp___17 ;
  unsigned char *tmp___18 ;
  void *tmp___19 ;

  {
  {
#line 235
  memset((void *)(& img), 0, sizeof(img));
  }
#line 236
  if (length < 40U) {
#line 237
    return ((IMAGE *)((void *)0));
  }
  {
#line 239
  bmp2.biSize = get_dword((unsigned char const   *)pbitmap);
#line 240
  pbitmap += 4;
  }
#line 241
  if (bmp2.biSize < 40UL) {
#line 242
    return ((IMAGE *)((void *)0));
  }
  {
#line 243
  tmp = get_dword((unsigned char const   *)pbitmap);
#line 243
  bmp2.biWidth = (LONG )tmp;
#line 244
  pbitmap += 4;
#line 245
  tmp___0 = get_dword((unsigned char const   *)pbitmap);
#line 245
  bmp2.biHeight = (LONG )tmp___0;
#line 246
  pbitmap += 4;
#line 247
  bmp2.biPlanes = get_word((unsigned char const   *)pbitmap);
#line 248
  pbitmap += 2;
#line 249
  bmp2.biBitCount = get_word((unsigned char const   *)pbitmap);
#line 250
  pbitmap += 2;
#line 251
  bmp2.biCompression = get_dword((unsigned char const   *)pbitmap);
#line 252
  pbitmap += 4;
#line 253
  bmp2.biSizeImage = get_dword((unsigned char const   *)pbitmap);
#line 254
  pbitmap += 4;
#line 255
  tmp___1 = get_dword((unsigned char const   *)pbitmap);
#line 255
  bmp2.biXPelsPerMeter = (LONG )tmp___1;
#line 256
  pbitmap += 4;
#line 257
  tmp___2 = get_dword((unsigned char const   *)pbitmap);
#line 257
  bmp2.biYPelsPerMeter = (LONG )tmp___2;
#line 258
  pbitmap += 4;
#line 259
  bmp2.biClrUsed = get_dword((unsigned char const   *)pbitmap);
#line 260
  pbitmap += 4;
#line 261
  bmp2.biClrImportant = get_dword((unsigned char const   *)pbitmap);
#line 262
  pbitmap += 4;
#line 263
  pbitmap += bmp2.biSize - 40UL;
#line 266
  depth = (int )bmp2.biPlanes * (int )bmp2.biBitCount;
#line 267
  bytewidth = (int )(((bmp2.biWidth * (LONG )depth + 31L) & -32L) >> 3);
#line 268
  palcount = 0;
  }
#line 269
  if (depth <= 8) {
#line 270
    if (bmp2.biClrUsed != 0UL) {
#line 270
      palcount = (int )bmp2.biClrUsed;
    } else {
#line 270
      palcount = 1 << depth;
    }
  }
#line 272
  pallength = 0;
#line 273
  if (depth == 16) {
#line 273
    goto _L;
  } else
#line 273
  if (depth == 32) {
    _L: /* CIL Label */ 
#line 274
    if (bmp2.biCompression == 3UL) {
#line 275
      pallength = 12;
    }
  } else {
#line 278
    pallength = palcount * 4;
  }
#line 279
  i = 0;
  {
#line 279
  while (1) {
    while_continue: /* CIL Label */ ;
#line 279
    if (! (i < palcount)) {
#line 279
      goto while_break;
    }
#line 280
    colour[i].rgbBlue = *(pbitmap + i * 4);
#line 281
    colour[i].rgbGreen = *(pbitmap + (i * 4 + 1));
#line 282
    colour[i].rgbRed = *(pbitmap + (i * 4 + 2));
#line 279
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 285
  if ((DWORD )length < (bmp2.biSize + (DWORD )pallength) + (DWORD )(bmp2.biHeight * (LONG )bytewidth)) {
#line 286
    return ((IMAGE *)((void *)0));
  }
#line 290
  img.width = (unsigned int )bmp2.biWidth;
#line 291
  img.height = (unsigned int )bmp2.biHeight;
#line 292
  img.raster = img.width * 3U;
#line 293
  img.format = 198660U;
#line 295
  convert = 0;
#line 300
  if (depth == 1) {
#line 301
    if ((int )colour[0].rgbBlue == 0) {
#line 301
      if ((int )colour[0].rgbGreen == 0) {
#line 301
        if ((int )colour[0].rgbRed == 0) {
#line 301
          if ((int )colour[1].rgbBlue == 255) {
#line 301
            if ((int )colour[1].rgbGreen == 255) {
#line 301
              if ((int )colour[1].rgbRed == 255) {
#line 308
                img.format = 196866U;
#line 310
                img.raster = (img.width + 7U) >> 3;
              } else {
#line 301
                goto _L___9;
              }
            } else {
#line 301
              goto _L___9;
            }
          } else {
#line 301
            goto _L___9;
          }
        } else {
#line 301
          goto _L___9;
        }
      } else {
#line 301
        goto _L___9;
      }
    } else
    _L___9: /* CIL Label */ 
#line 312
    if ((int )colour[0].rgbBlue == 255) {
#line 312
      if ((int )colour[0].rgbGreen == 255) {
#line 312
        if ((int )colour[0].rgbRed == 255) {
#line 312
          if ((int )colour[1].rgbBlue == 0) {
#line 312
            if ((int )colour[1].rgbGreen == 0) {
#line 312
              if ((int )colour[1].rgbRed == 0) {
#line 319
                img.format = 196865U;
#line 321
                img.raster = (img.width + 7U) >> 3;
              } else {
#line 312
                goto _L___4;
              }
            } else {
#line 312
              goto _L___4;
            }
          } else {
#line 312
            goto _L___4;
          }
        } else {
#line 312
          goto _L___4;
        }
      } else {
#line 312
        goto _L___4;
      }
    } else
    _L___4: /* CIL Label */ 
#line 323
    if ((int )colour[0].rgbBlue == (int )colour[0].rgbGreen) {
#line 323
      if ((int )colour[0].rgbRed == (int )colour[0].rgbGreen) {
#line 323
        if ((int )colour[1].rgbBlue == (int )colour[1].rgbGreen) {
#line 323
          if ((int )colour[1].rgbRed == (int )colour[1].rgbGreen) {
#line 328
            img.format = 198658U;
#line 330
            img.raster = img.width;
#line 331
            convert = 1;
          } else {
#line 335
            convert = 1;
          }
        } else {
#line 335
          convert = 1;
        }
      } else {
#line 335
        convert = 1;
      }
    } else {
#line 335
      convert = 1;
    }
  } else
#line 337
  if (depth == 4) {
#line 337
    goto _L___11;
  } else
#line 337
  if (depth == 8) {
    _L___11: /* CIL Label */ 
#line 338
    grey = 1;
#line 339
    i = 0;
    {
#line 339
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 339
      if (! (i < palcount)) {
#line 339
        goto while_break___0;
      }
#line 340
      if ((int )colour[i].rgbBlue != (int )colour[i].rgbGreen) {
#line 342
        grey = 0;
      } else
#line 340
      if ((int )colour[i].rgbRed != (int )colour[i].rgbGreen) {
#line 342
        grey = 0;
      }
#line 339
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 344
    if (grey) {
#line 345
      img.format = 198658U;
#line 347
      img.raster = img.width;
    }
#line 349
    convert = 1;
  } else
#line 352
  if (depth == 16) {
#line 353
    if (pallength == 0) {
#line 354
      img.format = 204801U;
#line 357
      img.raster = img.width * 2U;
    } else
#line 359
    if (pallength == 12) {
      {
#line 359
      tmp___4 = memcmp((void const   *)pbitmap, (void const   *)(clr555), sizeof(clr555));
      }
#line 359
      if (tmp___4 == 0) {
#line 361
        img.format = 204801U;
#line 364
        img.raster = img.width * 2U;
      } else {
#line 359
        goto _L___10;
      }
    } else
    _L___10: /* CIL Label */ 
#line 366
    if (pallength == 12) {
      {
#line 366
      tmp___3 = memcmp((void const   *)pbitmap, (void const   *)(clr565), sizeof(clr565));
      }
#line 366
      if (tmp___3 == 0) {
#line 368
        img.format = 466945U;
#line 371
        img.raster = img.width * 2U;
      } else {
#line 374
        return ((IMAGE *)((void *)0));
      }
    } else {
#line 374
      return ((IMAGE *)((void *)0));
    }
  } else
#line 376
  if (! (depth == 24)) {
#line 379
    if (depth == 32) {
#line 380
      clr888[0] = (unsigned char)255;
#line 380
      clr888[1] = (unsigned char)0;
#line 380
      clr888[2] = (unsigned char)0;
#line 380
      clr888[3] = (unsigned char)0;
#line 380
      clr888[4] = (unsigned char)0;
#line 380
      clr888[5] = (unsigned char)255;
#line 380
      clr888[6] = (unsigned char)0;
#line 380
      clr888[7] = (unsigned char)0;
#line 380
      clr888[8] = (unsigned char)0;
#line 380
      clr888[9] = (unsigned char)0;
#line 380
      clr888[10] = (unsigned char)255;
#line 380
      clr888[11] = (unsigned char)0;
#line 385
      if (pallength == 0) {
#line 388
        img.format = 198788U;
#line 390
        img.raster = img.width * 4U;
      } else
#line 385
      if (pallength == 12) {
        {
#line 385
        tmp___5 = memcmp((void const   *)pbitmap, (void const   *)(clr888), sizeof(clr888));
        }
#line 385
        if (tmp___5 == 0) {
#line 388
          img.format = 198788U;
#line 390
          img.raster = img.width * 4U;
        } else {
#line 393
          return ((IMAGE *)((void *)0));
        }
      } else {
#line 393
        return ((IMAGE *)((void *)0));
      }
    } else {
#line 396
      return ((IMAGE *)((void *)0));
    }
  }
  {
#line 398
  pbitmap += pallength;
#line 400
  img.raster = (img.raster + 3U) & 4294967292U;
#line 401
  tmp___6 = malloc((size_t )(img.raster * img.height));
#line 401
  bits = (unsigned char *)tmp___6;
  }
#line 402
  if ((unsigned long )bits == (unsigned long )((void *)0)) {
#line 403
    return ((IMAGE *)((void *)0));
  }
#line 405
  y = 0;
  {
#line 405
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 405
    if (! (y < (int )img.height)) {
#line 405
      goto while_break___1;
    }
#line 406
    dest = bits + (unsigned int )y * img.raster;
#line 407
    if (convert) {
#line 409
      shift = 7;
#line 410
      if (depth == 1) {
#line 411
        x = 0;
        {
#line 411
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 411
          if (! ((LONG )x < bmp2.biWidth)) {
#line 411
            goto while_break___2;
          }
#line 412
          idx = (int )*(pbitmap + (x >> 3));
#line 413
          idx = (idx >> shift) & 1;
#line 414
          if (((long )img.format & 15L) == 2L) {
#line 415
            tmp___7 = dest;
#line 415
            dest ++;
#line 415
            *tmp___7 = colour[idx].rgbBlue;
          } else {
#line 418
            tmp___8 = dest;
#line 418
            dest ++;
#line 418
            *tmp___8 = colour[idx].rgbBlue;
#line 419
            tmp___9 = dest;
#line 419
            dest ++;
#line 419
            *tmp___9 = colour[idx].rgbGreen;
#line 420
            tmp___10 = dest;
#line 420
            dest ++;
#line 420
            *tmp___10 = colour[idx].rgbRed;
          }
#line 422
          shift --;
#line 423
          if (shift < 0) {
#line 424
            shift = 7;
          }
#line 411
          x ++;
        }
        while_break___2: /* CIL Label */ ;
        }
      } else
#line 427
      if (depth == 4) {
#line 428
        x = 0;
        {
#line 428
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 428
          if (! ((LONG )x < bmp2.biWidth)) {
#line 428
            goto while_break___3;
          }
#line 429
          idx = (int )*(pbitmap + x / 2);
#line 433
          idx = (idx >> 4) & 15;
#line 434
          if (((long )img.format & 15L) == 2L) {
#line 435
            tmp___11 = dest;
#line 435
            dest ++;
#line 435
            *tmp___11 = colour[idx].rgbBlue;
          } else {
#line 438
            tmp___12 = dest;
#line 438
            dest ++;
#line 438
            *tmp___12 = colour[idx].rgbBlue;
#line 439
            tmp___13 = dest;
#line 439
            dest ++;
#line 439
            *tmp___13 = colour[idx].rgbGreen;
#line 440
            tmp___14 = dest;
#line 440
            dest ++;
#line 440
            *tmp___14 = colour[idx].rgbRed;
          }
#line 428
          x ++;
        }
        while_break___3: /* CIL Label */ ;
        }
      } else
#line 444
      if (depth == 8) {
#line 445
        x = 0;
        {
#line 445
        while (1) {
          while_continue___4: /* CIL Label */ ;
#line 445
          if (! ((LONG )x < bmp2.biWidth)) {
#line 445
            goto while_break___4;
          }
#line 446
          idx = (int )*(pbitmap + x);
#line 447
          if (((long )img.format & 15L) == 2L) {
#line 448
            tmp___15 = dest;
#line 448
            dest ++;
#line 448
            *tmp___15 = colour[idx].rgbBlue;
          } else {
#line 451
            tmp___16 = dest;
#line 451
            dest ++;
#line 451
            *tmp___16 = colour[idx].rgbBlue;
#line 452
            tmp___17 = dest;
#line 452
            dest ++;
#line 452
            *tmp___17 = colour[idx].rgbGreen;
#line 453
            tmp___18 = dest;
#line 453
            dest ++;
#line 453
            *tmp___18 = colour[idx].rgbRed;
          }
#line 445
          x ++;
        }
        while_break___4: /* CIL Label */ ;
        }
      } else {
        {
#line 458
        free((void *)bits);
        }
#line 459
        return ((IMAGE *)((void *)0));
      }
    } else {
      {
#line 463
      memcpy((void */* __restrict  */)dest, (void const   */* __restrict  */)pbitmap,
             (size_t )img.raster);
      }
    }
#line 465
    pbitmap += bytewidth;
#line 405
    y ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 468
  tmp___19 = malloc(sizeof(IMAGE ));
#line 468
  pimage = (IMAGE *)tmp___19;
  }
#line 469
  if ((unsigned long )pimage == (unsigned long )((void *)0)) {
    {
#line 470
    free((void *)bits);
    }
#line 471
    return ((IMAGE *)((void *)0));
  }
  {
#line 473
  memcpy((void */* __restrict  */)pimage, (void const   */* __restrict  */)(& img),
         sizeof(IMAGE ));
#line 474
  pimage->image = bits;
  }
#line 475
  return (pimage);
}
}
#line 480 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/cbmp.c"
static int read_pbm_bits(unsigned char *pbitmap , unsigned int width , unsigned int height ,
                         GFile *f ) 
{ 
  int count ;
  int ch ;
  int mask ;
  int x ;
  int y ;
  char buf[256] ;
  int buf_count ;
  int buf_idx ;
  unsigned long tmp ;
  unsigned int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 484
  count = 0;
#line 486
  mask = 128;
#line 489
  buf_count = 0;
#line 490
  buf_idx = 0;
#line 492
  y = 0;
  {
#line 492
  while (1) {
    while_continue: /* CIL Label */ ;
#line 492
    if (! (y < (int )height)) {
#line 492
      goto while_break;
    }
#line 493
    mask = 128;
#line 494
    x = 0;
    {
#line 494
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 494
      if (! (x < (int )width)) {
#line 494
        goto while_break___0;
      }
#line 495
      if (mask == 0) {
#line 496
        mask = 128;
#line 497
        pbitmap ++;
#line 498
        count ++;
      }
#line 500
      ch = 0;
      {
#line 501
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 501
        if (ch != 48) {
#line 501
          if (! (ch != 49)) {
#line 501
            goto while_break___1;
          }
        } else {
#line 501
          goto while_break___1;
        }
#line 502
        if (buf_idx >= buf_count) {
#line 503
          if (sizeof(buf) < (unsigned long )(width - (unsigned int )x)) {
#line 503
            tmp = sizeof(buf);
          } else {
#line 503
            tmp = (unsigned long )(width - (unsigned int )x);
          }
          {
#line 503
          tmp___0 = gfile_read(f, (void *)(buf), (unsigned int )tmp);
#line 503
          buf_count = (int )tmp___0;
          }
#line 504
          if (buf_count == 0) {
#line 505
            return (-1);
          }
#line 506
          buf_idx = 0;
        }
#line 508
        tmp___1 = buf_idx;
#line 508
        buf_idx ++;
#line 508
        ch = (int )buf[tmp___1];
      }
      while_break___1: /* CIL Label */ ;
      }
#line 510
      if (ch == 49) {
#line 510
        tmp___2 = (int )*pbitmap | mask;
      } else {
#line 510
        tmp___2 = (int )*pbitmap & ~ mask;
      }
#line 510
      *pbitmap = (unsigned char )tmp___2;
#line 512
      mask >>= 1;
#line 494
      x ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 514
    pbitmap ++;
#line 515
    count ++;
#line 492
    y ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 517
  return (count);
}
}
#line 521 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/cbmp.c"
static int read_pgnm_bytes(unsigned char *pbitmap , unsigned int length , GFile *f ) 
{ 
  int count ;
  int ch ;
  int val ;
  char buf[256] ;
  int buf_count ;
  int buf_idx ;
  unsigned long tmp ;
  unsigned int tmp___0 ;
  int tmp___1 ;
  unsigned long tmp___2 ;
  unsigned int tmp___3 ;
  int tmp___4 ;
  unsigned char *tmp___5 ;

  {
#line 524
  count = 0;
#line 525
  ch = 0;
#line 528
  buf_count = 0;
#line 529
  buf_idx = 0;
#line 531
  count = 0;
  {
#line 531
  while (1) {
    while_continue: /* CIL Label */ ;
#line 531
    if (! (count < (int )length)) {
#line 531
      goto while_break;
    }
#line 532
    val = 0;
    {
#line 533
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 533
      if (ch >= 48) {
#line 533
        if (ch <= 57) {
#line 533
          goto while_break___0;
        }
      }
#line 534
      if (buf_idx >= buf_count) {
#line 535
        if (sizeof(buf) < (unsigned long )(length - (unsigned int )count)) {
#line 535
          tmp = sizeof(buf);
        } else {
#line 535
          tmp = (unsigned long )(length - (unsigned int )count);
        }
        {
#line 535
        tmp___0 = gfile_read(f, (void *)(buf), (unsigned int )tmp);
#line 535
        buf_count = (int )tmp___0;
        }
#line 536
        if (buf_count == 0) {
#line 537
          return (-1);
        }
#line 538
        buf_idx = 0;
      }
#line 540
      tmp___1 = buf_idx;
#line 540
      buf_idx ++;
#line 540
      ch = (int )buf[tmp___1];
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 542
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 542
      if (ch >= 48) {
#line 542
        if (! (ch <= 57)) {
#line 542
          goto while_break___1;
        }
      } else {
#line 542
        goto while_break___1;
      }
#line 543
      val = (val * 10 + ch) - 48;
#line 544
      if (buf_idx >= buf_count) {
#line 545
        if (sizeof(buf) < (unsigned long )(length - (unsigned int )count)) {
#line 545
          tmp___2 = sizeof(buf);
        } else {
#line 545
          tmp___2 = (unsigned long )(length - (unsigned int )count);
        }
        {
#line 545
        tmp___3 = gfile_read(f, (void *)(buf), (unsigned int )tmp___2);
#line 545
        buf_count = (int )tmp___3;
        }
#line 546
        if (buf_count == 0) {
#line 547
          return (-1);
        }
#line 548
        buf_idx = 0;
      }
#line 550
      tmp___4 = buf_idx;
#line 550
      buf_idx ++;
#line 550
      ch = (int )buf[tmp___4];
    }
    while_break___1: /* CIL Label */ ;
    }
#line 552
    tmp___5 = pbitmap;
#line 552
    pbitmap ++;
#line 552
    *tmp___5 = (unsigned char )val;
#line 531
    count ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 554
  return (count);
}
}
#line 561 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/cbmp.c"
IMAGE *pnmfile_to_image(char const   *filename ) 
{ 
  GFile *f ;
  GFile *tmp ;
  IMAGE img ;
  IMAGE *pimage ;
  int code ;
  char typeline[256] ;
  char sizeline[256] ;
  char maxvalline[256] ;
  char hdrline[256] ;
  char tupltype[256] ;
  int width ;
  int height ;
  int maxval ;
  int depth ;
  int pam ;
  int pbm ;
  int pgm ;
  int ppm ;
  int raw ;
  int cmyk ;
  unsigned int length ;
  unsigned char *pbitmap ;
  int endhdr ;
  char *t1 ;
  char *t2 ;
  unsigned int count ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  void *tmp___23 ;
  unsigned int tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  void *tmp___27 ;

  {
  {
#line 564
  tmp = gfile_open(filename, 0U);
#line 564
  f = tmp;
#line 573
  width = 0;
#line 574
  height = 0;
#line 575
  maxval = 255;
#line 576
  depth = 0;
#line 577
  pam = 0;
#line 578
  pbm = 0;
#line 579
  pgm = 0;
#line 580
  ppm = 0;
#line 581
  raw = 0;
#line 582
  cmyk = 0;
  }
#line 591
  if ((unsigned long )f == (unsigned long )((GFile *)((void *)0))) {
#line 592
    return ((IMAGE *)((void *)0));
  }
  {
#line 593
  memset((void *)(& img), 0, sizeof(img));
#line 594
  memset((void *)(typeline), 0, sizeof(typeline));
#line 595
  memset((void *)(sizeline), 0, sizeof(sizeline));
#line 596
  memset((void *)(maxvalline), 0, sizeof(maxvalline));
#line 597
  tmp___0 = ps_fgets(typeline, (int )(sizeof(typeline) - 1UL), f);
#line 597
  code = tmp___0 == 0;
  }
#line 598
  if ((int )typeline[0] != 80) {
#line 599
    code = 1;
  }
  {
#line 601
  if ((int )typeline[1] == 49) {
#line 601
    goto case_49;
  }
#line 605
  if ((int )typeline[1] == 50) {
#line 605
    goto case_50;
  }
#line 609
  if ((int )typeline[1] == 51) {
#line 609
    goto case_51;
  }
#line 613
  if ((int )typeline[1] == 52) {
#line 613
    goto case_52;
  }
#line 617
  if ((int )typeline[1] == 53) {
#line 617
    goto case_53;
  }
#line 621
  if ((int )typeline[1] == 54) {
#line 621
    goto case_54;
  }
#line 625
  if ((int )typeline[1] == 55) {
#line 625
    goto case_55;
  }
#line 629
  goto switch_default;
  case_49: /* CIL Label */ 
#line 602
  pbm = 1;
#line 603
  raw = 0;
#line 604
  goto switch_break;
  case_50: /* CIL Label */ 
#line 606
  pgm = 1;
#line 607
  raw = 0;
#line 608
  goto switch_break;
  case_51: /* CIL Label */ 
#line 610
  ppm = 1;
#line 611
  raw = 0;
#line 612
  goto switch_break;
  case_52: /* CIL Label */ 
#line 614
  pbm = 1;
#line 615
  raw = 1;
#line 616
  goto switch_break;
  case_53: /* CIL Label */ 
#line 618
  pgm = 1;
#line 619
  raw = 1;
#line 620
  goto switch_break;
  case_54: /* CIL Label */ 
#line 622
  ppm = 1;
#line 623
  raw = 1;
#line 624
  goto switch_break;
  case_55: /* CIL Label */ 
#line 626
  pam = 1;
#line 627
  raw = 1;
#line 628
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 630
  code = 1;
  switch_break: /* CIL Label */ ;
  }
#line 633
  if (pam) {
#line 635
    endhdr = 0;
    {
#line 636
    while (1) {
      while_continue: /* CIL Label */ ;
#line 636
      if (! endhdr) {
#line 636
        if (! (! code)) {
#line 636
          goto while_break;
        }
      } else {
#line 636
        goto while_break;
      }
#line 637
      if (! code) {
        {
#line 638
        tmp___1 = ps_fgets(hdrline, (int )(sizeof(hdrline) - 1UL), f);
#line 638
        code = tmp___1 == 0;
        }
      }
      {
#line 639
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 639
        if (! code) {
#line 639
          if (! ((int )hdrline[0] == 35)) {
#line 639
            goto while_break___0;
          }
        } else {
#line 639
          goto while_break___0;
        }
        {
#line 641
        tmp___2 = ps_fgets(hdrline, (int )(sizeof(hdrline) - 1UL), f);
#line 641
        code = tmp___2 == 0;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
#line 642
      if (code) {
#line 643
        goto while_break;
      }
#line 644
      t1 = hdrline;
      {
#line 645
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 645
        if (*t1) {
#line 645
          if (! ((int )*t1 == 32)) {
#line 645
            if (! ((int )*t1 == 9)) {
#line 645
              goto while_break___1;
            }
          }
        } else {
#line 645
          goto while_break___1;
        }
#line 646
        t1 ++;
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 647
      t1 = strtok((char */* __restrict  */)t1, (char const   */* __restrict  */)" \t\r\n");
      }
#line 648
      if ((unsigned long )t1 == (unsigned long )((void *)0)) {
#line 649
        goto while_break;
      }
      {
#line 650
      t2 = strtok((char */* __restrict  */)((void *)0), (char const   */* __restrict  */)" \t\r\n");
#line 651
      tmp___12 = strcmp((char const   *)t1, "ENDHDR");
      }
#line 651
      if (tmp___12 == 0) {
#line 652
        endhdr = 1;
#line 653
        goto while_continue;
      } else {
        {
#line 655
        tmp___11 = strcmp((char const   *)t1, "WIDTH");
        }
#line 655
        if (tmp___11 == 0) {
#line 656
          if (t2) {
            {
#line 657
            tmp___3 = sscanf((char const   */* __restrict  */)t2, (char const   */* __restrict  */)"%u",
                             & width);
#line 657
            code = tmp___3 != 1;
            }
          }
        } else {
          {
#line 659
          tmp___10 = strcmp((char const   *)t1, "HEIGHT");
          }
#line 659
          if (tmp___10 == 0) {
#line 660
            if (t2) {
              {
#line 661
              tmp___4 = sscanf((char const   */* __restrict  */)t2, (char const   */* __restrict  */)"%u",
                               & height);
#line 661
              code = tmp___4 != 1;
              }
            }
          } else {
            {
#line 663
            tmp___9 = strcmp((char const   *)t1, "DEPTH");
            }
#line 663
            if (tmp___9 == 0) {
#line 664
              if (t2) {
                {
#line 665
                tmp___5 = sscanf((char const   */* __restrict  */)t2, (char const   */* __restrict  */)"%u",
                                 & depth);
#line 665
                code = tmp___5 != 1;
                }
              }
            } else {
              {
#line 667
              tmp___8 = strcmp((char const   *)t1, "MAXVAL");
              }
#line 667
              if (tmp___8 == 0) {
#line 668
                if (t2) {
                  {
#line 669
                  tmp___6 = sscanf((char const   */* __restrict  */)t2, (char const   */* __restrict  */)"%u",
                                   & maxval);
#line 669
                  code = tmp___6 != 1;
                  }
                }
              } else {
                {
#line 671
                tmp___7 = strcmp((char const   *)t1, "TUPLTYPE");
                }
#line 671
                if (tmp___7 == 0) {
#line 672
                  if (t2) {
                    {
#line 673
                    strncpy((char */* __restrict  */)(tupltype), (char const   */* __restrict  */)t2,
                            sizeof(tupltype) - 1UL);
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 676
    if (! endhdr) {
#line 677
      code = 1;
    }
#line 678
    if (width == 0) {
#line 679
      code = 1;
    } else
#line 678
    if (height == 0) {
#line 679
      code = 1;
    } else
#line 678
    if (depth == 0) {
#line 679
      code = 1;
    } else
#line 678
    if (maxval == 0) {
#line 679
      code = 1;
    }
    {
#line 680
    tmp___13 = strcmp((char const   *)(tupltype), "BLACKANDWHITE");
    }
#line 680
    if (tmp___13 == 0) {
#line 680
      if (depth == 1) {
#line 680
        if (maxval == 1) {
#line 682
          pbm = 1;
        }
      }
    }
    {
#line 683
    tmp___14 = strcmp((char const   *)(tupltype), "GRAYSCALE");
    }
#line 683
    if (tmp___14 == 0) {
#line 683
      if (depth == 1) {
#line 683
        if (maxval == 255) {
#line 685
          pgm = 1;
        }
      }
    }
    {
#line 686
    tmp___15 = strcmp((char const   *)(tupltype), "RGB");
    }
#line 686
    if (tmp___15 == 0) {
#line 686
      if (depth == 3) {
#line 686
        if (maxval == 255) {
#line 688
          ppm = 1;
        }
      }
    }
    {
#line 689
    tmp___16 = strcmp((char const   *)(tupltype), "CMYK");
    }
#line 689
    if (tmp___16 == 0) {
#line 689
      if (depth == 4) {
#line 689
        if (maxval == 255) {
#line 691
          cmyk = 1;
        }
      }
    }
  } else {
#line 694
    if (! code) {
      {
#line 695
      tmp___17 = ps_fgets(sizeline, (int )(sizeof(sizeline) - 1UL), f);
#line 695
      code = tmp___17 == 0;
      }
    }
    {
#line 696
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 696
      if (! code) {
#line 696
        if (! ((int )sizeline[0] == 35)) {
#line 696
          goto while_break___2;
        }
      } else {
#line 696
        goto while_break___2;
      }
      {
#line 697
      tmp___18 = ps_fgets(sizeline, (int )(sizeof(sizeline) - 1UL), f);
#line 697
      code = tmp___18 == 0;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
#line 699
    if (! code) {
      {
#line 700
      tmp___19 = sscanf((char const   */* __restrict  */)(sizeline), (char const   */* __restrict  */)"%u %u",
                        & width, & height);
#line 700
      code = tmp___19 != 2;
      }
    }
#line 701
    if (width == 0) {
#line 702
      code = 1;
    } else
#line 701
    if (height == 0) {
#line 702
      code = 1;
    }
#line 704
    if (! code) {
#line 704
      if (pgm) {
#line 704
        goto _L;
      } else
#line 704
      if (ppm) {
        _L: /* CIL Label */ 
        {
#line 705
        tmp___20 = ps_fgets(maxvalline, (int )(sizeof(maxvalline) - 1UL), f);
#line 705
        code = tmp___20 == 0;
        }
        {
#line 706
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 706
          if (! code) {
#line 706
            if (! ((int )maxvalline[0] == 35)) {
#line 706
              goto while_break___3;
            }
          } else {
#line 706
            goto while_break___3;
          }
          {
#line 707
          tmp___21 = ps_fgets(maxvalline, (int )(sizeof(maxvalline) - 1UL), f);
#line 707
          code = tmp___21 == 0;
          }
        }
        while_break___3: /* CIL Label */ ;
        }
#line 708
        if (! code) {
          {
#line 709
          tmp___22 = sscanf((char const   */* __restrict  */)(maxvalline), (char const   */* __restrict  */)"%u",
                            & maxval);
#line 709
          code = tmp___22 != 1;
          }
        }
      }
    }
#line 711
    if (maxval != 255) {
#line 712
      code = 1;
    }
  }
#line 715
  img.width = (unsigned int )width;
#line 716
  img.height = (unsigned int )height;
#line 717
  if (pbm) {
#line 718
    img.format = 257U;
#line 720
    img.raster = (img.width + 7U) >> 3;
  } else
#line 722
  if (pgm) {
#line 723
    img.format = 2050U;
#line 725
    img.raster = img.width;
  } else
#line 727
  if (ppm) {
#line 728
    img.format = 2052U;
#line 730
    img.raster = img.width * 3U;
  } else
#line 732
  if (cmyk) {
#line 733
    img.format = 2056U;
#line 735
    img.raster = img.width * 4U;
  } else {
#line 738
    code = 1;
  }
#line 740
  length = img.raster * img.height;
#line 742
  if (code) {
    {
#line 743
    gfile_close(f);
    }
#line 744
    return ((IMAGE *)((void *)0));
  }
  {
#line 747
  tmp___23 = malloc((size_t )length);
#line 747
  pbitmap = (unsigned char *)tmp___23;
  }
#line 748
  if ((unsigned long )pbitmap == (unsigned long )((void *)0)) {
    {
#line 749
    gfile_close(f);
    }
#line 750
    return ((IMAGE *)((void *)0));
  }
#line 753
  if (raw) {
    {
#line 754
    tmp___24 = gfile_read(f, (void *)pbitmap, length);
#line 754
    count = (unsigned int )((int )tmp___24);
    }
  } else
#line 755
  if (pbm) {
    {
#line 756
    tmp___25 = read_pbm_bits(pbitmap, img.width, img.height, f);
#line 756
    count = (unsigned int )tmp___25;
    }
  } else {
    {
#line 758
    tmp___26 = read_pgnm_bytes(pbitmap, length, f);
#line 758
    count = (unsigned int )tmp___26;
    }
  }
  {
#line 759
  gfile_close(f);
  }
#line 761
  if (count != length) {
    {
#line 762
    free((void *)pbitmap);
    }
#line 763
    return ((IMAGE *)((void *)0));
  }
  {
#line 766
  tmp___27 = malloc(sizeof(IMAGE ));
#line 766
  pimage = (IMAGE *)tmp___27;
  }
#line 767
  if ((unsigned long )pimage == (unsigned long )((void *)0)) {
    {
#line 768
    free((void *)pbitmap);
    }
#line 769
    return ((IMAGE *)((void *)0));
  }
  {
#line 771
  memcpy((void */* __restrict  */)pimage, (void const   */* __restrict  */)(& img),
         sizeof(IMAGE ));
#line 772
  pimage->image = pbitmap;
  }
#line 773
  return (pimage);
}
}
#line 777 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/cbmp.c"
void bitmap_image_free(IMAGE *img ) 
{ 


  {
#line 780
  if (img) {
#line 780
    if (img->image) {
      {
#line 781
      free((void *)img->image);
#line 782
      memset((void *)img, 0, sizeof(IMAGE ));
#line 783
      free((void *)img);
      }
    }
  }
#line 785
  return;
}
}
#line 787 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/cbmp.c"
static int image_bmp2init(IMAGE *img , BITMAP2 *bmp2 ) 
{ 


  {
#line 794
  bmp2->biSize = (DWORD )40;
#line 795
  bmp2->biWidth = (LONG )img->width;
#line 796
  bmp2->biHeight = (LONG )img->height;
#line 797
  bmp2->biPlanes = (WORD )1;
#line 798
  bmp2->biCompression = (DWORD )0;
  {
#line 800
  if (((long )img->format & 15L) == 1L) {
#line 800
    goto case_1;
  }
#line 840
  if (((long )img->format & 15L) == 2L) {
#line 840
    goto case_2;
  }
#line 863
  if (((long )img->format & 15L) == 4L) {
#line 863
    goto case_4;
  }
#line 871
  if (((long )img->format & 15L) == 8L) {
#line 871
    goto case_8;
  }
#line 799
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 802
  if (((long )img->format & 65280L) == 256L) {
#line 802
    goto case_256;
  }
#line 807
  if (((long )img->format & 65280L) == 1024L) {
#line 807
    goto case_1024;
  }
#line 813
  if (((long )img->format & 65280L) == 2048L) {
#line 813
    goto case_2048;
  }
#line 819
  if (((long )img->format & 65280L) == 8192L) {
#line 819
    goto case_8192;
  }
#line 836
  goto switch_default;
  case_256: /* CIL Label */ 
#line 803
  bmp2->biBitCount = (WORD )1;
#line 804
  bmp2->biClrUsed = (DWORD )2;
#line 805
  bmp2->biClrImportant = (DWORD )2;
#line 806
  goto switch_break___0;
  case_1024: /* CIL Label */ 
#line 809
  bmp2->biBitCount = (WORD )4;
#line 810
  bmp2->biClrUsed = (DWORD )16;
#line 811
  bmp2->biClrImportant = (DWORD )16;
#line 812
  goto switch_break___0;
  case_2048: /* CIL Label */ 
#line 815
  bmp2->biBitCount = (WORD )8;
#line 816
  bmp2->biClrUsed = (DWORD )96;
#line 817
  bmp2->biClrImportant = (DWORD )96;
#line 818
  goto switch_break___0;
  case_8192: /* CIL Label */ 
#line 822
  if (((long )img->format & 65536L) == 0L) {
#line 825
    bmp2->biBitCount = (WORD )24;
#line 826
    bmp2->biClrUsed = (DWORD )0;
#line 827
    bmp2->biClrImportant = (DWORD )0;
  } else {
#line 830
    bmp2->biBitCount = (WORD )16;
#line 831
    bmp2->biCompression = (DWORD )3L;
#line 832
    bmp2->biClrUsed = (DWORD )0;
#line 833
    bmp2->biClrImportant = (DWORD )0;
  }
#line 835
  goto switch_break___0;
  switch_default: /* CIL Label */ 
#line 837
  return (-1);
  switch_break___0: /* CIL Label */ ;
  }
#line 839
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 842
  if (((long )img->format & 65280L) == 256L) {
#line 842
    goto case_256___0;
  }
#line 847
  if (((long )img->format & 65280L) == 1024L) {
#line 847
    goto case_1024___0;
  }
#line 853
  if (((long )img->format & 65280L) == 2048L) {
#line 853
    goto case_2048___0;
  }
#line 859
  goto switch_default___0;
  case_256___0: /* CIL Label */ 
#line 843
  bmp2->biBitCount = (WORD )1;
#line 844
  bmp2->biClrUsed = (DWORD )2;
#line 845
  bmp2->biClrImportant = (DWORD )2;
#line 846
  goto switch_break___1;
  case_1024___0: /* CIL Label */ 
#line 849
  bmp2->biBitCount = (WORD )4;
#line 850
  bmp2->biClrUsed = (DWORD )16;
#line 851
  bmp2->biClrImportant = (DWORD )16;
#line 852
  goto switch_break___1;
  case_2048___0: /* CIL Label */ 
#line 855
  bmp2->biBitCount = (WORD )8;
#line 856
  bmp2->biClrUsed = (DWORD )256;
#line 857
  bmp2->biClrImportant = (DWORD )256;
#line 858
  goto switch_break___1;
  switch_default___0: /* CIL Label */ 
#line 860
  return (-1);
  switch_break___1: /* CIL Label */ ;
  }
#line 862
  goto switch_break;
  case_4: /* CIL Label */ 
#line 864
  if (((long )img->format & 65280L) != 2048L) {
#line 865
    return (-1);
  }
#line 867
  bmp2->biBitCount = (WORD )24;
#line 868
  bmp2->biClrUsed = (DWORD )0;
#line 869
  bmp2->biClrImportant = (DWORD )0;
#line 870
  goto switch_break;
  case_8: /* CIL Label */ 
#line 873
  bmp2->biBitCount = (WORD )24;
#line 874
  bmp2->biClrUsed = (DWORD )0;
#line 875
  bmp2->biClrImportant = (DWORD )0;
#line 876
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 879
  bmp2->biSizeImage = (DWORD )0;
#line 880
  bmp2->biXPelsPerMeter = (LONG )0;
#line 881
  bmp2->biYPelsPerMeter = (LONG )0;
#line 882
  return (0);
}
}
#line 888 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/cbmp.c"
int image_to_bmpfile(IMAGE *img , char const   *filename , float xdpi , float ydpi ) 
{ 
  BITMAP2 bmp2 ;
  BITMAPFILE bmf ;
  int bytewidth ;
  int depth ;
  int palcount ;
  int pallength ;
  GFile *f ;
  unsigned char r ;
  unsigned char g ;
  unsigned char b ;
  unsigned char quad[4] ;
  unsigned char nulchar ;
  int i ;
  unsigned char *bits ;
  unsigned char *row ;
  int topfirst ;
  int tmp ;
  void *tmp___0 ;
  int j ;

  {
#line 900
  nulchar = (unsigned char )'\000';
#line 906
  if ((unsigned long )img == (unsigned long )((void *)0)) {
#line 907
    return (-1);
  } else
#line 906
  if ((unsigned long )img->image == (unsigned long )((void *)0)) {
#line 907
    return (-1);
  }
  {
#line 908
  tmp = image_bmp2init(img, & bmp2);
  }
#line 908
  if (tmp < 0) {
#line 909
    return (-1);
  }
#line 911
  if ((double )xdpi > 0.0) {
#line 911
    if ((double )ydpi > 0.0) {
#line 912
      bmp2.biXPelsPerMeter = (LONG )((int )(((double )xdpi * 1000.0) / 25.4 + 0.5));
#line 913
      bmp2.biYPelsPerMeter = (LONG )((int )(((double )ydpi * 1000.0) / 25.4 + 0.5));
    }
  }
#line 916
  depth = (int )bmp2.biPlanes * (int )bmp2.biBitCount;
#line 917
  bytewidth = (int )(((bmp2.biWidth * (LONG )depth + 31L) & -32L) >> 3);
  {
#line 921
  if (depth == 8) {
#line 921
    goto case_8;
  }
#line 921
  if (depth == 4) {
#line 921
    goto case_8;
  }
#line 921
  if (depth == 1) {
#line 921
    goto case_8;
  }
#line 925
  if (depth == 16) {
#line 925
    goto case_16;
  }
#line 928
  goto switch_default;
  case_8: /* CIL Label */ 
  case_4: /* CIL Label */ 
  case_1: /* CIL Label */ 
#line 922
  palcount = 1 << depth;
#line 923
  pallength = palcount * 4;
#line 924
  goto switch_break;
  case_16: /* CIL Label */ 
#line 926
  palcount = 0;
#line 927
  pallength = 12;
  switch_default: /* CIL Label */ 
#line 929
  palcount = 0;
#line 930
  pallength = 0;
  switch_break: /* CIL Label */ ;
  }
  {
#line 933
  bmf.bfType = get_word((unsigned char const   *)"BM");
#line 934
  bmf.bfReserved1 = (WORD )0;
#line 935
  bmf.bfReserved2 = (WORD )0;
#line 936
  bmf.bfOffBits = (DWORD )(54 + palcount);
#line 937
  bmf.bfSize = bmf.bfOffBits + (DWORD )((LONG )bytewidth * bmp2.biHeight);
#line 939
  tmp___0 = malloc((size_t )bytewidth);
#line 939
  row = (unsigned char *)tmp___0;
  }
#line 940
  if ((unsigned long )row == (unsigned long )((void *)0)) {
#line 941
    return (-1);
  }
  {
#line 943
  f = gfile_open(filename, 4097U);
  }
#line 944
  if ((unsigned long )f == (unsigned long )((GFile *)((void *)0))) {
    {
#line 945
    free((void *)row);
    }
#line 946
    return (-1);
  }
  {
#line 950
  write_word(bmf.bfType, f);
#line 951
  write_dword(bmf.bfSize, f);
#line 952
  write_word(bmf.bfReserved1, f);
#line 953
  write_word(bmf.bfReserved2, f);
#line 954
  write_dword(bmf.bfOffBits, f);
#line 957
  write_dword(bmp2.biSize, f);
#line 958
  write_dword((DWORD )bmp2.biWidth, f);
#line 959
  write_dword((DWORD )bmp2.biHeight, f);
#line 960
  write_word(bmp2.biPlanes, f);
#line 961
  write_word(bmp2.biBitCount, f);
#line 962
  write_dword(bmp2.biCompression, f);
#line 963
  write_dword(bmp2.biSizeImage, f);
#line 964
  write_dword((DWORD )bmp2.biXPelsPerMeter, f);
#line 965
  write_dword((DWORD )bmp2.biYPelsPerMeter, f);
#line 966
  write_dword(bmp2.biClrUsed, f);
#line 967
  write_dword(bmp2.biClrImportant, f);
#line 970
  i = 0;
  }
  {
#line 970
  while (1) {
    while_continue: /* CIL Label */ ;
#line 970
    if (! (i < palcount)) {
#line 970
      goto while_break;
    }
    {
#line 971
    image_colour(img->format, i, & r, & g, & b);
#line 972
    quad[0] = b;
#line 973
    quad[1] = g;
#line 974
    quad[2] = r;
#line 975
    quad[3] = (unsigned char )'\000';
#line 976
    gfile_write(f, (void const   *)(quad), 4U);
#line 970
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 978
  if (bmp2.biCompression == 3UL) {
#line 979
    if (((long )img->format & 262144L) == 0L) {
      {
#line 980
      gfile_write(f, (void const   *)(clr555), (unsigned int )sizeof(clr555));
      }
    } else {
      {
#line 982
      gfile_write(f, (void const   *)(clr565), (unsigned int )sizeof(clr565));
      }
    }
  }
#line 986
  topfirst = ((long )img->format & 131072L) == 0L;
#line 987
  i = 0;
  {
#line 987
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 987
    if (! ((LONG )i < bmp2.biHeight)) {
#line 987
      goto while_break___0;
    }
#line 988
    if (topfirst) {
#line 989
      bits = img->image + img->raster * ((img->height - (unsigned int )i) - 1U);
    } else {
#line 991
      bits = img->image + img->raster * (unsigned int )i;
    }
#line 992
    if (depth == 24) {
      {
#line 993
      image_to_24BGR(img, row, bits);
#line 994
      gfile_write(f, (void const   *)row, (unsigned int )bytewidth);
      }
    } else
#line 997
    if ((int )img->raster < bytewidth) {
      {
#line 999
      gfile_write(f, (void const   *)bits, img->raster);
#line 1000
      j = (int )((unsigned int )bytewidth - img->raster);
      }
      {
#line 1000
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 1000
        if (! (j > 0)) {
#line 1000
          goto while_break___1;
        }
        {
#line 1001
        gfile_write(f, (void const   *)(& nulchar), 1U);
#line 1000
        j --;
        }
      }
      while_break___1: /* CIL Label */ ;
      }
    } else {
      {
#line 1004
      gfile_write(f, (void const   *)bits, (unsigned int )bytewidth);
      }
    }
#line 987
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 1008
  free((void *)row);
#line 1009
  gfile_close(f);
  }
#line 1010
  return (0);
}
}
#line 1056 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/cbmp.c"
int image_to_tiff(GFile *f , IMAGE *img , int xoffset , int yoffset , int width ,
                  int height , float xdpi , float ydpi , BOOL tiff4 , BOOL use_packbits ) 
{ 
  WORD ifd_length ;
  DWORD ifd_next ;
  DWORD tiff_end ;
  DWORD end ;
  int i ;
  int j ;
  unsigned char *preview ;
  BYTE *line ;
  unsigned char nulchar ;
  int temp_bwidth ;
  int bwidth ;
  BOOL soft_extra ;
  int bitoffset ;
  WORD *comp_length ;
  BYTE *comp_line ;
  int rowsperstrip ;
  int stripsperimage ;
  int strip ;
  int is ;
  int strip_len ;
  int lastrow ;
  int depth ;
  int preview_depth ;
  int topfirst ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;
  int len ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  int palcount ;
  int stripwidth ;
  time_t t ;
  char now[20] ;
  struct tm *dt ;
  size_t tmp___5 ;
  int palcount___0 ;
  unsigned char r ;
  unsigned char g ;
  unsigned char b ;
  int len___0 ;
  int tmp___6 ;

  {
#line 1068
  nulchar = (unsigned char )'\000';
#line 1070
  soft_extra = 0;
#line 1072
  comp_length = (WORD *)((void *)0);
#line 1073
  comp_line = (BYTE *)((void *)0);
#line 1084
  if ((unsigned long )img == (unsigned long )((void *)0)) {
#line 1085
    return (-1);
  }
  {
#line 1087
  topfirst = ((long )img->format & 131072L) == 0L;
#line 1089
  depth = image_depth(img);
  }
#line 1090
  if (depth == 1) {
#line 1091
    preview_depth = 1;
  } else
#line 1092
  if (depth == 4) {
#line 1093
    preview_depth = 4;
  } else
#line 1094
  if (depth == 8) {
#line 1095
    preview_depth = 8;
  } else {
#line 1097
    preview_depth = 24;
  }
#line 1098
  if (tiff4) {
#line 1099
    preview_depth = 1;
  }
#line 1106
  temp_bwidth = (int )((img->width * (unsigned int )preview_depth + 7U) >> 3);
#line 1108
  bwidth = (width * preview_depth + 7) >> 3;
#line 1110
  bitoffset = xoffset * preview_depth;
#line 1112
  if (tiff4) {
#line 1113
    rowsperstrip = 1;
  } else {
#line 1117
    rowsperstrip = 7936 / bwidth;
#line 1118
    if (rowsperstrip == 0) {
#line 1119
      rowsperstrip = 1;
    }
  }
#line 1121
  stripsperimage = ((height + rowsperstrip) - 1) / rowsperstrip;
#line 1122
  if (stripsperimage == 1) {
#line 1123
    rowsperstrip = height;
  }
  {
#line 1125
  tmp = malloc((size_t )img->raster);
#line 1125
  preview = (unsigned char *)tmp;
  }
#line 1126
  if ((unsigned long )preview == (unsigned long )((void *)0)) {
#line 1127
    return (-1);
  }
  {
#line 1128
  memset((void *)preview, 255, (size_t )img->raster);
  }
#line 1131
  if (use_packbits) {
    {
#line 1132
    tmp___0 = malloc((unsigned long )stripsperimage * sizeof(WORD ));
#line 1132
    comp_length = (WORD *)tmp___0;
    }
#line 1133
    if ((unsigned long )comp_length == (unsigned long )((void *)0)) {
      {
#line 1134
      free((void *)preview);
      }
#line 1135
      return (-1);
    }
    {
#line 1137
    tmp___1 = malloc((size_t )((bwidth + bwidth / 64) + 1));
#line 1137
    comp_line = (BYTE *)tmp___1;
    }
#line 1138
    if ((unsigned long )comp_line == (unsigned long )((void *)0)) {
      {
#line 1139
      free((void *)preview);
#line 1140
      free((void *)comp_length);
      }
#line 1141
      return (-1);
    }
#line 1143
    if (topfirst) {
#line 1144
      line = img->image + img->raster * ((img->height - (unsigned int )yoffset) - (unsigned int )height);
    } else {
#line 1146
      line = img->image + img->raster * (unsigned int )((yoffset + height) - 1);
    }
#line 1149
    strip = 0;
    {
#line 1149
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1149
      if (! (strip < stripsperimage)) {
#line 1149
        goto while_break;
      }
#line 1150
      is = strip * rowsperstrip;
#line 1151
      if (rowsperstrip < height - is) {
#line 1151
        lastrow = rowsperstrip;
      } else {
#line 1151
        lastrow = height - is;
      }
#line 1152
      *(comp_length + strip) = (WORD )0;
#line 1153
      strip_len = 0;
#line 1155
      i = 0;
      {
#line 1155
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1155
        if (! (i < lastrow)) {
#line 1155
          goto while_break___0;
        }
#line 1156
        if (preview_depth == 1) {
          {
#line 1157
          memset((void *)preview, 255, (size_t )img->raster);
#line 1158
          image_to_mono(img, preview, line);
#line 1159
          j = 0;
          }
          {
#line 1159
          while (1) {
            while_continue___1: /* CIL Label */ ;
#line 1159
            if (! (j < temp_bwidth)) {
#line 1159
              goto while_break___1;
            }
#line 1160
            *(preview + j) = (unsigned char )((int )*(preview + j) ^ 255);
#line 1159
            j ++;
          }
          while_break___1: /* CIL Label */ ;
          }
        } else
#line 1162
        if (preview_depth == 24) {
          {
#line 1163
          image_to_24RGB(img, preview, line);
          }
        } else
#line 1164
        if (depth == preview_depth) {
          {
#line 1165
          memmove((void *)preview, (void const   *)line, (size_t )img->raster);
          }
        }
#line 1166
        if (bitoffset) {
          {
#line 1167
          shift_bits(preview, temp_bwidth, bitoffset);
          }
        }
        {
#line 1168
        tmp___2 = packbits(comp_line, preview, bwidth);
#line 1168
        strip_len += tmp___2;
        }
#line 1169
        if (topfirst) {
#line 1170
          line += img->raster;
        } else {
#line 1172
          line -= img->raster;
        }
#line 1155
        i ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 1174
      *(comp_length + strip) = (WORD )strip_len;
#line 1149
      strip ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 1180
  tiff_end = (DWORD )8;
#line 1181
  write_word((WORD )18761, f);
#line 1182
  write_word((WORD )42, f);
#line 1183
  write_dword(tiff_end, f);
#line 1186
  tiff_end += 2UL;
  }
#line 1187
  if (tiff4) {
#line 1188
    ifd_length = (WORD )10;
  } else {
    {
#line 1191
    if (preview_depth == 24) {
#line 1191
      goto case_24;
    }
#line 1196
    if (preview_depth == 4) {
#line 1196
      goto case_4;
    }
#line 1196
    if (preview_depth == 8) {
#line 1196
      goto case_4;
    }
#line 1200
    goto switch_default;
    case_24: /* CIL Label */ 
#line 1193
    ifd_length = (WORD )15;
#line 1194
    goto switch_break;
    case_4: /* CIL Label */ 
    case_8: /* CIL Label */ 
#line 1198
    ifd_length = (WORD )15;
#line 1199
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 1201
    ifd_length = (WORD )13;
    switch_break: /* CIL Label */ ;
    }
  }
  {
#line 1204
  write_word(ifd_length, f);
#line 1206
  tiff_end += (DWORD )((int )ifd_length * 12 + 4);
#line 1207
  ifd_next = (DWORD )0;
  }
#line 1210
  if (tiff4) {
    {
#line 1211
    write_word((WORD )255, f);
#line 1212
    write_word((WORD )3, f);
#line 1213
    write_dword((DWORD )1, f);
#line 1214
    write_word_as_dword((WORD )0, f);
    }
  } else {
    {
#line 1217
    write_word((WORD )254, f);
#line 1218
    write_word((WORD )4, f);
#line 1219
    write_dword((DWORD )1, f);
#line 1220
    write_dword((DWORD )0, f);
    }
  }
  {
#line 1223
  write_word((WORD )256, f);
  }
#line 1224
  if (tiff4) {
    {
#line 1225
    write_word((WORD )3, f);
#line 1226
    write_dword((DWORD )1, f);
#line 1227
    write_word_as_dword((WORD )((short )width), f);
    }
  } else {
    {
#line 1230
    write_word((WORD )4, f);
#line 1231
    write_dword((DWORD )1, f);
#line 1232
    write_dword((DWORD )width, f);
    }
  }
  {
#line 1235
  write_word((WORD )257, f);
  }
#line 1236
  if (tiff4) {
    {
#line 1237
    write_word((WORD )3, f);
#line 1238
    write_dword((DWORD )1, f);
#line 1239
    write_word_as_dword((WORD )((short )height), f);
    }
  } else {
    {
#line 1242
    write_word((WORD )4, f);
#line 1243
    write_dword((DWORD )1, f);
#line 1244
    write_dword((DWORD )height, f);
    }
  }
#line 1247
  if (! tiff4) {
#line 1247
    if (preview_depth > 1) {
      {
#line 1248
      write_word((WORD )258, f);
#line 1249
      write_word((WORD )3, f);
      }
#line 1250
      if (preview_depth == 24) {
        {
#line 1251
        write_dword((DWORD )3, f);
#line 1252
        write_dword(tiff_end, f);
#line 1253
        tiff_end += 6UL;
        }
      } else {
        {
#line 1256
        write_dword((DWORD )1, f);
#line 1257
        write_word_as_dword((WORD )preview_depth, f);
        }
      }
    }
  }
  {
#line 1261
  write_word((WORD )259, f);
#line 1262
  write_word((WORD )3, f);
#line 1263
  write_dword((DWORD )1, f);
  }
#line 1264
  if (use_packbits) {
    {
#line 1265
    write_word_as_dword((WORD )32773U, f);
    }
  } else {
    {
#line 1267
    write_word_as_dword((WORD )1, f);
    }
  }
  {
#line 1269
  write_word((WORD )262, f);
#line 1270
  write_word((WORD )3, f);
#line 1271
  write_dword((DWORD )1, f);
  }
#line 1272
  if (tiff4) {
    {
#line 1273
    write_word_as_dword((WORD )1, f);
    }
  } else
#line 1272
  if (preview_depth == 1) {
    {
#line 1273
    write_word_as_dword((WORD )1, f);
    }
  } else
#line 1274
  if (preview_depth == 24) {
    {
#line 1275
    write_word_as_dword((WORD )2, f);
    }
  } else {
    {
#line 1277
    write_word_as_dword((WORD )3, f);
    }
  }
  {
#line 1279
  write_word((WORD )273, f);
#line 1280
  write_word((WORD )4, f);
  }
#line 1281
  if (stripsperimage == 1) {
    {
#line 1283
    len = 0;
#line 1284
    write_dword((DWORD )1, f);
#line 1285
    len += 16;
    }
#line 1286
    if (! tiff4) {
      {
#line 1287
      tmp___3 = strlen(szGSviewName);
#line 1287
      len += (((int )tmp___3 + 2) & -2) + 20;
      }
#line 1288
      if (preview_depth == 4) {
#line 1289
        len += 6 * (1 << preview_depth);
      } else
#line 1288
      if (preview_depth == 8) {
#line 1289
        len += 6 * (1 << preview_depth);
      }
    }
    {
#line 1291
    write_dword(tiff_end + (DWORD )len, f);
    }
  } else {
    {
#line 1294
    write_dword((DWORD )stripsperimage, f);
#line 1295
    write_dword(tiff_end, f);
#line 1296
    tiff_end += (DWORD )(stripsperimage * 4);
    }
  }
#line 1299
  if (! tiff4) {
#line 1299
    if (preview_depth == 24) {
      {
#line 1300
      write_word((WORD )277, f);
#line 1301
      write_word((WORD )3, f);
#line 1302
      write_dword((DWORD )1, f);
#line 1303
      write_word_as_dword((WORD )3, f);
      }
    }
  }
  {
#line 1306
  write_word((WORD )278, f);
#line 1307
  write_word((WORD )4, f);
#line 1308
  write_dword((DWORD )1, f);
#line 1309
  write_dword((DWORD )rowsperstrip, f);
#line 1311
  write_word((WORD )279, f);
#line 1312
  write_word((WORD )4, f);
  }
#line 1313
  if (stripsperimage == 1) {
    {
#line 1314
    write_dword((DWORD )1, f);
    }
#line 1315
    if (use_packbits) {
      {
#line 1316
      write_dword((DWORD )*(comp_length + 0), f);
      }
    } else {
      {
#line 1318
      write_dword((DWORD )(bwidth * rowsperstrip), f);
      }
    }
  } else {
    {
#line 1321
    write_dword((DWORD )stripsperimage, f);
#line 1322
    write_dword(tiff_end, f);
#line 1323
    tiff_end += (DWORD )(stripsperimage * 4);
    }
  }
  {
#line 1326
  write_word((WORD )282, f);
#line 1327
  write_word((WORD )5, f);
#line 1328
  write_dword((DWORD )1, f);
#line 1329
  write_dword(tiff_end, f);
#line 1330
  tiff_end += 8UL;
#line 1332
  write_word((WORD )283, f);
#line 1333
  write_word((WORD )5, f);
#line 1334
  write_dword((DWORD )1, f);
#line 1335
  write_dword(tiff_end, f);
#line 1336
  tiff_end += 8UL;
  }
#line 1338
  if (! tiff4) {
    {
#line 1339
    write_word((WORD )296, f);
#line 1340
    write_word((WORD )3, f);
#line 1341
    write_dword((DWORD )1, f);
#line 1342
    write_word_as_dword((WORD )2, f);
#line 1344
    write_word((WORD )305, f);
#line 1345
    write_word((WORD )2, f);
#line 1346
    tmp___4 = strlen(szGSviewName);
#line 1346
    i = (int )tmp___4 + 1;
#line 1347
    write_dword((DWORD )i, f);
#line 1348
    write_dword(tiff_end, f);
#line 1349
    tiff_end += (DWORD )i;
    }
#line 1350
    if (tiff_end & 1UL) {
#line 1351
      soft_extra = 1;
#line 1352
      tiff_end ++;
    }
    {
#line 1355
    write_word((WORD )306, f);
#line 1356
    write_word((WORD )2, f);
#line 1357
    write_dword((DWORD )20, f);
#line 1358
    write_dword(tiff_end, f);
#line 1359
    tiff_end += 20UL;
    }
#line 1361
    if (preview_depth == 4) {
#line 1361
      goto _L;
    } else
#line 1361
    if (preview_depth == 8) {
      _L: /* CIL Label */ 
      {
#line 1362
      palcount = 1 << preview_depth;
#line 1363
      write_word((WORD )320, f);
#line 1364
      write_word((WORD )3, f);
#line 1365
      write_dword((DWORD )(3 * palcount), f);
#line 1366
      write_dword(tiff_end, f);
#line 1367
      tiff_end += (DWORD )(6 * palcount);
      }
    }
  }
  {
#line 1373
  write_dword(ifd_next, f);
  }
#line 1376
  if (! tiff4) {
#line 1376
    if (preview_depth == 24) {
      {
#line 1377
      write_word((WORD )8, f);
#line 1378
      write_word((WORD )8, f);
#line 1379
      write_word((WORD )8, f);
      }
    }
  }
#line 1383
  end = tiff_end;
#line 1384
  if (stripsperimage > 1) {
#line 1385
    stripwidth = bwidth * rowsperstrip;
#line 1386
    i = 0;
    {
#line 1386
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 1386
      if (! (i < stripsperimage)) {
#line 1386
        goto while_break___2;
      }
      {
#line 1387
      write_dword(end, f);
      }
#line 1388
      if (use_packbits) {
#line 1389
        end += (DWORD )*(comp_length + i);
      } else {
#line 1391
        end += (DWORD )stripwidth;
      }
#line 1386
      i ++;
    }
    while_break___2: /* CIL Label */ ;
    }
  }
#line 1396
  if (stripsperimage > 1) {
#line 1397
    i = 0;
    {
#line 1397
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 1397
      if (! (i < stripsperimage)) {
#line 1397
        goto while_break___3;
      }
#line 1398
      if (use_packbits) {
        {
#line 1399
        write_dword((DWORD )*(comp_length + i), f);
        }
      } else {
#line 1401
        is = i * rowsperstrip;
#line 1402
        if (rowsperstrip < height - is) {
#line 1402
          lastrow = rowsperstrip;
        } else {
#line 1402
          lastrow = height - is;
        }
        {
#line 1403
        write_dword((DWORD )(lastrow * bwidth), f);
        }
      }
#line 1397
      i ++;
    }
    while_break___3: /* CIL Label */ ;
    }
  }
  {
#line 1409
  write_dword((DWORD )((int )xdpi), f);
#line 1410
  write_dword((DWORD )1, f);
#line 1412
  write_dword((DWORD )((int )ydpi), f);
#line 1413
  write_dword((DWORD )1, f);
  }
#line 1416
  if (! tiff4) {
    {
#line 1420
    tmp___5 = strlen(szGSviewName);
#line 1420
    gfile_write(f, (void const   *)(szGSviewName), (unsigned int )((int )tmp___5 + 1));
    }
#line 1421
    if (soft_extra) {
      {
#line 1422
      gfile_write(f, (void const   *)(& nulchar), 1U);
      }
    }
    {
#line 1423
    t = time((time_t *)((void *)0));
#line 1424
    dt = localtime((time_t const   *)(& t));
#line 1425
    snprintf((char */* __restrict  */)(now), sizeof(now), (char const   */* __restrict  */)"%04d:%02d:%02d %02d:%02d:%02d",
             dt->tm_year + 1900, dt->tm_mon + 1, dt->tm_mday, dt->tm_hour, dt->tm_min,
             dt->tm_sec);
#line 1428
    gfile_write(f, (void const   *)(now), 20U);
    }
  }
#line 1432
  if (! tiff4) {
#line 1432
    if (preview_depth == 4) {
#line 1432
      goto _L___0;
    } else
#line 1432
    if (preview_depth == 8) {
      _L___0: /* CIL Label */ 
#line 1433
      palcount___0 = 1 << preview_depth;
#line 1436
      i = 0;
      {
#line 1436
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 1436
        if (! (i < palcount___0)) {
#line 1436
          goto while_break___4;
        }
        {
#line 1437
        image_colour(img->format, i, & r, & g, & b);
#line 1438
        write_word((WORD )(((int )r << 8) | (int )r), f);
#line 1436
        i ++;
        }
      }
      while_break___4: /* CIL Label */ ;
      }
#line 1440
      i = 0;
      {
#line 1440
      while (1) {
        while_continue___5: /* CIL Label */ ;
#line 1440
        if (! (i < palcount___0)) {
#line 1440
          goto while_break___5;
        }
        {
#line 1441
        image_colour(img->format, i, & r, & g, & b);
#line 1442
        write_word((WORD )(((int )g << 8) | (int )g), f);
#line 1440
        i ++;
        }
      }
      while_break___5: /* CIL Label */ ;
      }
#line 1444
      i = 0;
      {
#line 1444
      while (1) {
        while_continue___6: /* CIL Label */ ;
#line 1444
        if (! (i < palcount___0)) {
#line 1444
          goto while_break___6;
        }
        {
#line 1445
        image_colour(img->format, i, & r, & g, & b);
#line 1446
        write_word((WORD )(((int )b << 8) | (int )b), f);
#line 1444
        i ++;
        }
      }
      while_break___6: /* CIL Label */ ;
      }
    }
  }
#line 1452
  if (topfirst) {
#line 1453
    line = img->image + img->raster * ((img->height - (unsigned int )yoffset) - (unsigned int )height);
  } else {
#line 1455
    line = img->image + img->raster * (unsigned int )((yoffset + height) - 1);
  }
#line 1458
  strip = 0;
  {
#line 1458
  while (1) {
    while_continue___7: /* CIL Label */ ;
#line 1458
    if (! (strip < stripsperimage)) {
#line 1458
      goto while_break___7;
    }
#line 1460
    is = strip * rowsperstrip;
#line 1461
    if (rowsperstrip < height - is) {
#line 1461
      lastrow = rowsperstrip;
    } else {
#line 1461
      lastrow = height - is;
    }
#line 1463
    i = 0;
    {
#line 1463
    while (1) {
      while_continue___8: /* CIL Label */ ;
#line 1463
      if (! (i < lastrow)) {
#line 1463
        goto while_break___8;
      }
#line 1464
      if (preview_depth == 1) {
        {
#line 1465
        memset((void *)preview, 0, (size_t )img->raster);
#line 1466
        image_to_mono(img, preview, line);
#line 1467
        j = 0;
        }
        {
#line 1467
        while (1) {
          while_continue___9: /* CIL Label */ ;
#line 1467
          if (! (j < temp_bwidth)) {
#line 1467
            goto while_break___9;
          }
#line 1468
          *(preview + j) = (unsigned char )((int )*(preview + j) ^ 255);
#line 1467
          j ++;
        }
        while_break___9: /* CIL Label */ ;
        }
      } else
#line 1470
      if (preview_depth == 24) {
        {
#line 1471
        image_to_24RGB(img, preview, line);
        }
      } else
#line 1472
      if (depth == preview_depth) {
        {
#line 1473
        memmove((void *)preview, (void const   *)line, (size_t )img->raster);
        }
      }
#line 1474
      if (bitoffset) {
        {
#line 1475
        shift_bits(preview, temp_bwidth, bitoffset);
        }
      }
#line 1476
      if (use_packbits) {
        {
#line 1477
        tmp___6 = packbits(comp_line, preview, bwidth);
#line 1477
        len___0 = (int )((WORD )tmp___6);
#line 1478
        gfile_write(f, (void const   *)comp_line, (unsigned int )len___0);
        }
      } else {
        {
#line 1481
        gfile_write(f, (void const   *)preview, (unsigned int )bwidth);
        }
      }
#line 1482
      if (topfirst) {
#line 1483
        line += img->raster;
      } else {
#line 1485
        line -= img->raster;
      }
#line 1463
      i ++;
    }
    while_break___8: /* CIL Label */ ;
    }
#line 1458
    strip ++;
  }
  while_break___7: /* CIL Label */ ;
  }
#line 1489
  if (use_packbits) {
    {
#line 1490
    free((void *)comp_length);
#line 1491
    free((void *)comp_line);
    }
  }
  {
#line 1493
  free((void *)preview);
  }
#line 1494
  return (0);
}
}
#line 1499 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/cbmp.c"
int image_to_tifffile(IMAGE *img , char const   *filename , float xdpi , float ydpi ) 
{ 
  GFile *f ;
  int code ;
  BOOL tiff4 ;

  {
#line 1503
  code = 0;
#line 1504
  tiff4 = ((long )img->format & 65280L) == 256L;
#line 1506
  if ((unsigned long )img == (unsigned long )((void *)0)) {
#line 1507
    return (-1);
  } else
#line 1506
  if ((unsigned long )img->image == (unsigned long )((void *)0)) {
#line 1507
    return (-1);
  }
  {
#line 1509
  f = gfile_open(filename, 4097U);
  }
#line 1510
  if ((unsigned long )f == (unsigned long )((GFile *)((void *)0))) {
#line 1511
    return (-1);
  }
  {
#line 1513
  code = image_to_tiff(f, img, 0, 0, (int )img->width, (int )img->height, xdpi, ydpi,
                       tiff4, ! tiff4);
#line 1516
  gfile_close(f);
  }
#line 1517
  return (0);
}
}
#line 1522 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/cbmp.c"
int image_to_pnmfile(IMAGE *img , char const   *filename , PNM_FORMAT pnm_format ) 
{ 
  PNM_FORMAT format ;
  FILE *f ;
  int bytewidth ;
  unsigned char *row ;
  unsigned char *bits ;
  int topfirst ;
  int i ;
  void *tmp ;

  {
#line 1525
  format = pnm_format;
#line 1532
  if ((unsigned long )img == (unsigned long )((void *)0)) {
#line 1533
    return (-1);
  } else
#line 1532
  if ((unsigned long )img->image == (unsigned long )((void *)0)) {
#line 1533
    return (-1);
  }
#line 1536
  if ((unsigned int )format != 4U) {
#line 1536
    if ((unsigned int )format != 5U) {
#line 1536
      if ((unsigned int )format != 6U) {
        {
#line 1538
        if (((long )img->format & 15L) == 1L) {
#line 1538
          goto case_1;
        }
#line 1552
        if (((long )img->format & 15L) == 2L) {
#line 1552
          goto case_2;
        }
#line 1566
        if (((long )img->format & 15L) == 4L) {
#line 1566
          goto case_4;
        }
#line 1571
        if (((long )img->format & 15L) == 8L) {
#line 1571
          goto case_8;
        }
#line 1537
        goto switch_break;
        case_1: /* CIL Label */ 
        {
#line 1540
        if (((long )img->format & 65280L) == 256L) {
#line 1540
          goto case_256;
        }
#line 1545
        if (((long )img->format & 65280L) == 8192L) {
#line 1545
          goto case_8192;
        }
#line 1545
        if (((long )img->format & 65280L) == 2048L) {
#line 1545
          goto case_8192;
        }
#line 1545
        if (((long )img->format & 65280L) == 1024L) {
#line 1545
          goto case_8192;
        }
#line 1548
        goto switch_default;
        case_256: /* CIL Label */ 
#line 1541
        format = (PNM_FORMAT )4;
#line 1542
        goto switch_break___0;
        case_8192: /* CIL Label */ 
        case_2048: /* CIL Label */ 
        case_1024: /* CIL Label */ 
#line 1546
        format = (PNM_FORMAT )6;
#line 1547
        goto switch_break___0;
        switch_default: /* CIL Label */ 
#line 1549
        return (-1);
        switch_break___0: /* CIL Label */ ;
        }
#line 1551
        goto switch_break;
        case_2: /* CIL Label */ 
        {
#line 1554
        if (((long )img->format & 65280L) == 256L) {
#line 1554
          goto case_256___0;
        }
#line 1558
        if (((long )img->format & 65280L) == 2048L) {
#line 1558
          goto case_2048___0;
        }
#line 1558
        if (((long )img->format & 65280L) == 1024L) {
#line 1558
          goto case_2048___0;
        }
#line 1562
        goto switch_default___0;
        case_256___0: /* CIL Label */ 
#line 1555
        format = (PNM_FORMAT )4;
#line 1556
        goto switch_break___1;
        case_2048___0: /* CIL Label */ 
        case_1024___0: /* CIL Label */ 
#line 1560
        format = (PNM_FORMAT )5;
#line 1561
        goto switch_break___1;
        switch_default___0: /* CIL Label */ 
#line 1563
        return (-1);
        switch_break___1: /* CIL Label */ ;
        }
#line 1565
        goto switch_break;
        case_4: /* CIL Label */ 
#line 1567
        if (((long )img->format & 65280L) != 2048L) {
#line 1568
          return (-1);
        }
#line 1569
        format = (PNM_FORMAT )6;
#line 1570
        goto switch_break;
        case_8: /* CIL Label */ 
#line 1573
        format = (PNM_FORMAT )6;
#line 1574
        goto switch_break;
        switch_break: /* CIL Label */ ;
        }
      }
    }
  }
#line 1577
  if ((unsigned int )format == 6U) {
#line 1578
    bytewidth = (int )(img->width * 3U);
  } else
#line 1579
  if ((unsigned int )format == 5U) {
#line 1580
    bytewidth = (int )img->width;
  } else {
#line 1582
    bytewidth = (int )((img->width + 7U) >> 3);
  }
  {
#line 1583
  tmp = malloc((size_t )bytewidth);
#line 1583
  row = (unsigned char *)tmp;
  }
#line 1584
  if ((unsigned long )row == (unsigned long )((void *)0)) {
#line 1585
    return (-1);
  }
  {
#line 1586
  topfirst = ((long )img->format & 131072L) == 0L;
#line 1588
  f = fopen((char const   */* __restrict  */)filename, (char const   */* __restrict  */)"wb");
  }
#line 1589
  if ((unsigned long )f == (unsigned long )((void *)0)) {
    {
#line 1590
    free((void *)row);
    }
#line 1591
    return (-1);
  }
  {
#line 1594
  fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"P%c\n", (int )((unsigned int )format + 48U));
#line 1595
  fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"# Created by GSview\n");
#line 1596
  fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"%d %d\n",
          img->width, img->height);
  }
#line 1597
  if ((unsigned int )format == 5U) {
    {
#line 1598
    fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"255\n");
    }
  } else
#line 1597
  if ((unsigned int )format == 6U) {
    {
#line 1598
    fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"255\n");
    }
  }
#line 1599
  i = 0;
  {
#line 1599
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1599
    if (! (i < (int )img->height)) {
#line 1599
      goto while_break;
    }
#line 1600
    if (topfirst) {
#line 1601
      bits = img->image + img->raster * (unsigned int )i;
    } else {
#line 1603
      bits = img->image + img->raster * ((img->height - (unsigned int )i) - 1U);
    }
#line 1604
    if ((unsigned int )format == 6U) {
      {
#line 1605
      image_to_24RGB(img, row, bits);
      }
    } else
#line 1606
    if ((unsigned int )format == 5U) {
      {
#line 1607
      image_to_grey(img, row, bits);
      }
    } else {
      {
#line 1609
      image_to_mono(img, row, bits);
      }
    }
    {
#line 1610
    fwrite((void const   */* __restrict  */)row, (size_t )1, (size_t )bytewidth, (FILE */* __restrict  */)f);
#line 1599
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1613
  free((void *)row);
#line 1614
  fclose(f);
  }
#line 1615
  return (0);
}
}
#line 1634 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/cbmp.c"
static int write_pict_pixdata(IMAGE *img , GFile *f ) 
{ 
  int i ;
  int j ;
  int count ;
  int topfirst ;
  unsigned char b ;
  unsigned char *bits ;
  unsigned char *row ;
  unsigned char *sep ;
  unsigned char *packed ;
  unsigned char *p ;
  int wcount ;
  int rowwidth ;
  int qdrowwidth ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  unsigned char *tmp___2 ;
  unsigned char *tmp___3 ;
  unsigned char *tmp___4 ;
  unsigned char *tmp___5 ;
  unsigned char *tmp___6 ;
  unsigned char *tmp___7 ;

  {
  {
#line 1644
  wcount = 0;
#line 1645
  rowwidth = (int )(img->width * 3U);
#line 1649
  qdrowwidth = (int )(img->width * 4U);
#line 1651
  tmp = malloc((size_t )rowwidth);
#line 1651
  row = (unsigned char *)tmp;
#line 1652
  tmp___0 = malloc((size_t )qdrowwidth);
#line 1652
  sep = (unsigned char *)tmp___0;
#line 1653
  tmp___1 = malloc((size_t )((rowwidth + rowwidth / 128) + 1));
#line 1653
  packed = (unsigned char *)tmp___1;
  }
#line 1654
  if ((unsigned long )row == (unsigned long )((void *)0)) {
#line 1654
    goto _L;
  } else
#line 1654
  if ((unsigned long )sep == (unsigned long )((void *)0)) {
#line 1654
    goto _L;
  } else
#line 1654
  if ((unsigned long )packed == (unsigned long )((void *)0)) {
    _L: /* CIL Label */ 
#line 1655
    if ((unsigned long )row != (unsigned long )((void *)0)) {
      {
#line 1656
      free((void *)row);
      }
    }
#line 1657
    if ((unsigned long )sep != (unsigned long )((void *)0)) {
      {
#line 1658
      free((void *)sep);
      }
    }
#line 1659
    if ((unsigned long )packed != (unsigned long )((void *)0)) {
      {
#line 1660
      free((void *)packed);
      }
    }
#line 1661
    return (-1);
  }
#line 1665
  wcount = 0;
#line 1666
  topfirst = ((long )img->format & 131072L) == 0L;
#line 1667
  i = 0;
  {
#line 1667
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1667
    if (! (i < (int )img->height)) {
#line 1667
      goto while_break;
    }
#line 1668
    if (topfirst) {
#line 1669
      bits = img->image + img->raster * (unsigned int )i;
    } else {
#line 1671
      bits = img->image + img->raster * ((img->height - (unsigned int )i) - 1U);
    }
    {
#line 1672
    image_to_24RGB(img, row, bits);
#line 1673
    p = row;
    }
#line 1674
    if (qdrowwidth < 8) {
#line 1676
      if (f) {
#line 1677
        j = 0;
        {
#line 1677
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 1677
          if (! (j < (int )img->width)) {
#line 1677
            goto while_break___0;
          }
#line 1679
          *(sep + 4 * j) = (unsigned char )'\000';
#line 1680
          tmp___2 = p;
#line 1680
          p ++;
#line 1680
          *(sep + (4 * j + 1)) = *tmp___2;
#line 1681
          tmp___3 = p;
#line 1681
          p ++;
#line 1681
          *(sep + (4 * j + 2)) = *tmp___3;
#line 1682
          tmp___4 = p;
#line 1682
          p ++;
#line 1682
          *(sep + (4 * j + 3)) = *tmp___4;
#line 1677
          j ++;
        }
        while_break___0: /* CIL Label */ ;
        }
        {
#line 1684
        gfile_write(f, (void const   *)sep, (unsigned int )qdrowwidth);
        }
      }
#line 1686
      wcount += 8;
    } else {
#line 1689
      j = 0;
      {
#line 1689
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 1689
        if (! (j < (int )img->width)) {
#line 1689
          goto while_break___1;
        }
#line 1691
        tmp___5 = p;
#line 1691
        p ++;
#line 1691
        *(sep + j) = *tmp___5;
#line 1692
        tmp___6 = p;
#line 1692
        p ++;
#line 1692
        *(sep + ((unsigned int )j + img->width)) = *tmp___6;
#line 1693
        tmp___7 = p;
#line 1693
        p ++;
#line 1693
        *(sep + (((unsigned int )j + img->width) + img->width)) = *tmp___7;
#line 1689
        j ++;
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 1695
      count = packbits(packed, sep, rowwidth);
      }
#line 1696
      if (qdrowwidth > 250) {
#line 1697
        if (f) {
          {
#line 1698
          write_bigendian_word((WORD )count, f);
          }
        }
#line 1699
        wcount += 2;
      } else {
#line 1702
        b = (unsigned char )count;
#line 1703
        if (f) {
          {
#line 1704
          gfile_write(f, (void const   *)(& b), 1U);
          }
        }
#line 1705
        wcount ++;
      }
#line 1707
      if (f) {
        {
#line 1708
        gfile_write(f, (void const   *)packed, (unsigned int )count);
        }
      }
#line 1709
      wcount += count;
    }
#line 1667
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1712
  if (wcount & 1) {
#line 1714
    b = (unsigned char)0;
#line 1715
    if (f) {
      {
#line 1716
      gfile_write(f, (void const   *)(& b), 1U);
      }
    }
#line 1717
    wcount ++;
  }
#line 1720
  return (wcount);
}
}
#line 1727 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/cbmp.c"
int image_to_pictfile(IMAGE *img , char const   *filename , float xdpi , float ydpi ) 
{ 
  int i ;
  int wcount ;
  GFile *f ;

  {
  {
#line 1732
  f = (GFile *)((void *)0);
#line 1735
  f = gfile_open(filename, 4097U);
  }
#line 1736
  if ((unsigned long )f == (unsigned long )((GFile *)((void *)0))) {
#line 1737
    return (-1);
  }
  {
#line 1740
  wcount = write_pict_pixdata(img, (GFile *)((void *)0));
#line 1743
  i = 0;
  }
  {
#line 1743
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1743
    if (! (i < 128)) {
#line 1743
      goto while_break;
    }
    {
#line 1744
    write_bigendian_dword((DWORD )0, f);
#line 1743
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1748
  write_bigendian_word((WORD )(wcount + 124), f);
#line 1750
  write_bigendian_word((WORD )0, f);
#line 1751
  write_bigendian_word((WORD )0, f);
#line 1752
  write_bigendian_word((WORD )img->height, f);
#line 1753
  write_bigendian_word((WORD )img->width, f);
#line 1757
  write_bigendian_word((WORD )17, f);
#line 1758
  write_bigendian_word((WORD )767, f);
#line 1762
  write_bigendian_word((WORD )3072, f);
#line 1763
  write_bigendian_word((WORD )-2, f);
#line 1764
  write_bigendian_word((WORD )0, f);
#line 1765
  write_bigendian_dword((DWORD )(xdpi * (float )65536), f);
#line 1766
  write_bigendian_dword((DWORD )(ydpi * (float )65536), f);
#line 1767
  write_bigendian_word((WORD )0, f);
#line 1768
  write_bigendian_word((WORD )0, f);
#line 1769
  write_bigendian_word((WORD )img->height, f);
#line 1770
  write_bigendian_word((WORD )img->width, f);
#line 1771
  write_bigendian_word((WORD )0, f);
#line 1772
  write_bigendian_word((WORD )0, f);
#line 1776
  write_bigendian_word((WORD )1, f);
#line 1777
  write_bigendian_word((WORD )10, f);
#line 1778
  write_bigendian_word((WORD )0, f);
#line 1779
  write_bigendian_word((WORD )0, f);
#line 1780
  write_bigendian_word((WORD )img->height, f);
#line 1781
  write_bigendian_word((WORD )img->width, f);
#line 1785
  write_bigendian_word((WORD )154, f);
#line 1786
  write_bigendian_dword((DWORD )255, f);
#line 1788
  write_bigendian_word((WORD )(32768U | img->width * 4U), f);
#line 1789
  write_bigendian_word((WORD )0, f);
#line 1790
  write_bigendian_word((WORD )0, f);
#line 1791
  write_bigendian_word((WORD )img->height, f);
#line 1792
  write_bigendian_word((WORD )img->width, f);
#line 1793
  write_bigendian_word((WORD )0, f);
#line 1794
  write_bigendian_word((WORD )4, f);
#line 1795
  write_bigendian_dword((DWORD )0, f);
#line 1796
  write_bigendian_dword((DWORD )(xdpi * (float )65536), f);
#line 1797
  write_bigendian_dword((DWORD )(ydpi * (float )65536), f);
#line 1798
  write_bigendian_word((WORD )16, f);
#line 1799
  write_bigendian_word((WORD )32, f);
#line 1800
  write_bigendian_word((WORD )3, f);
#line 1801
  write_bigendian_word((WORD )8, f);
#line 1802
  write_bigendian_dword((DWORD )0, f);
#line 1803
  write_bigendian_dword((DWORD )0, f);
#line 1804
  write_bigendian_dword((DWORD )0, f);
#line 1807
  write_bigendian_word((WORD )0, f);
#line 1808
  write_bigendian_word((WORD )0, f);
#line 1809
  write_bigendian_word((WORD )img->height, f);
#line 1810
  write_bigendian_word((WORD )img->width, f);
#line 1813
  write_bigendian_word((WORD )0, f);
#line 1814
  write_bigendian_word((WORD )0, f);
#line 1815
  write_bigendian_word((WORD )img->height, f);
#line 1816
  write_bigendian_word((WORD )img->width, f);
#line 1819
  write_bigendian_word((WORD )64, f);
#line 1822
  write_pict_pixdata(img, f);
#line 1824
  write_bigendian_word((WORD )255, f);
#line 1826
  gfile_close(f);
  }
#line 1827
  return (0);
}
}
#line 2148 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/cbmp.c"
int image_to_pngfile(IMAGE *img , char const   *filename ) 
{ 


  {
#line 2152
  return (-1);
}
}
#line 2155 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/cbmp.c"
IMAGE *pngfile_to_image(char const   *filename ) 
{ 


  {
#line 2159
  return ((IMAGE *)((void *)0));
}
}
#line 140 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strncat)(char * __restrict  __dest ,
                                                                                                  char const   * __restrict  __src ,
                                                                                                  size_t __n ) ;
#line 145 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/common.h"
int cs_to_narrow(char *nstr , int nlen , char const   *wstr , int wlen ) ;
#line 146
int narrow_to_cs(char *wstr , int wlen , char const   *nstr , int nlen ) ;
#line 560 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/dscparse.h"
char const   *dsc_find_platefile(CDSC *dsc , int page ) ;
#line 75 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/capp.h"
int app_msgf(GSview *a , char const   *fmt  , ...) ;
#line 79
int app_csmsgf(GSview *a , char const   *fmt  , ...) ;
#line 87
GFile *app_temp_gfile(GSview *app , char *fname , int len ) ;
#line 49 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/cmac.h"
CMACFILE *get_mactype(GFile *f ) ;
#line 53
int get_pict(GFile *f , CMACFILE *mac , int debug___0 ) ;
#line 57
int extract_mac_pict(GFile *f , CMACFILE *mac , char const   *outname ) ;
#line 71
int write_appledouble(GFile *f , char const   *pictname ) ;
#line 74
int write_applesingle(GFile *f , char const   *epsname , char const   *pictname ) ;
#line 78
int write_macbin(GFile *f , char const   *name , char const   *epsname , char const   *pictname ) ;
#line 84
int write_resource_pict(GFile *f , char const   *pictname ) ;
#line 20 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/ceps.h"
int extract_doseps(Doc *doc , char const   *outname , BOOL preview ) ;
#line 21
int extract_macbin(Doc *doc , char const   *outname , BOOL preview ) ;
#line 22
int make_eps_tiff(Doc *doc , IMAGE *img , CDSCBBOX devbbox , CDSCBBOX *bbox , CDSCFBBOX *hires_bbox ,
                  float xdpi , float ydpi , BOOL tiff4 , BOOL use_packbits , BOOL reverse ,
                  char const   *epsname ) ;
#line 26
int make_eps_user(Doc *doc , char const   *preview_name , BOOL reverse , char const   *epsname ) ;
#line 28
int make_eps_interchange(Doc *doc , IMAGE *img , CDSCBBOX devbbox , CDSCBBOX *bbox ,
                         CDSCFBBOX *hires_bbox , char const   *epsname ) ;
#line 31
int make_eps_metafile(Doc *doc , IMAGE *img , CDSCBBOX devbbox , CDSCBBOX *bbox ,
                      CDSCFBBOX *hires_bbox , float xdpi , float ydpi , BOOL reverse ,
                      char const   *epsname ) ;
#line 34
int make_eps_pict(Doc *doc , IMAGE *img , CDSCBBOX *bbox , CDSCFBBOX *hires_bbox ,
                  float xdpi , float ydpi , CMAC_TYPE mac_type , char const   *epsname ) ;
#line 37
int copy_page_temp(Doc *doc , GFile *f , int page ) ;
#line 38
int copy_page_nosave(Doc *doc , GFile *f , int page ) ;
#line 39
int copy_eps(Doc *doc , char const   *epsname , CDSCBBOX *bbox , CDSCFBBOX *hires_bbox ,
             int offset , BOOL dcs2_multi ) ;
#line 48
int rename_separations(CDSC *dsc , RENAME_SEPARATION *rs , char const   **renamed ) ;
#line 49
int copy_dcs2(Doc *doc , GFile *docfile , Doc *doc2 , GFile *docfile2 , GFile *epsfile ,
              char const   *epsname , int offset , BOOL dcs2_multi , BOOL write_all ,
              BOOL missing_separations , unsigned long *complen , GFile *composite ,
              RENAME_SEPARATION *rs , int tolerance ) ;
#line 37 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/ceps.c"
static void write_doseps_header(CDSCDOSEPS *doseps , GFile *outfile ) ;
#line 38
static void shift_preview(unsigned char *preview , int bwidth , int offset ) ;
#line 39
static void validate_devbbox(IMAGE *img , CDSCBBOX *devbbox ) ;
#line 40
int write_interchange(GFile *f , IMAGE *img , CDSCBBOX devbbox ) ;
#line 41
static void write_bitmap_info(IMAGE *img , LPBITMAP2 pbmi , GFile *f ) ;
#line 42
static void make_bmp_info(LPBITMAP2 pbmi , IMAGE *img , float xdpi , float ydpi ) ;
#line 43
void copy_nobbox(GFile *outfile , GFile *infile , unsigned long begin , unsigned long end ) ;
#line 45
void copy_bbox_header(GFile *outfile , GFile *infile , unsigned long begin , unsigned long end ,
                      CDSCBBOX *bbox , CDSCFBBOX *hiresbbox ) ;
#line 48
static int without_eol(char const   *str , int length ) ;
#line 49
static unsigned long write_platefile_comments(Doc *doc , GFile *docfile , GFile *epsfile ,
                                              char const   *epsname , int offset ,
                                              unsigned long file_offset , BOOL dcs2_multi ,
                                              BOOL write_all , BOOL missing_separations ,
                                              char const   **renamed , BOOL some_renamed ) ;
#line 54
static unsigned long write_singlefile_separations(Doc *doc , GFile *docfile , GFile *epsfile ,
                                                  BOOL dcs2_multi , BOOL write_all ,
                                                  BOOL missing_separations , BOOL some_renamed ) ;
#line 80 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/ceps.c"
static void write_doseps_header(CDSCDOSEPS *doseps , GFile *outfile ) 
{ 
  unsigned char doseps_id[4] ;

  {
  {
#line 83
  doseps_id[0] = (unsigned char)197;
#line 83
  doseps_id[1] = (unsigned char)208;
#line 83
  doseps_id[2] = (unsigned char)211;
#line 83
  doseps_id[3] = (unsigned char)198;
#line 84
  gfile_write(outfile, (void const   *)(doseps_id), 4U);
#line 85
  write_dword(doseps->ps_begin, outfile);
#line 86
  write_dword(doseps->ps_length, outfile);
#line 87
  write_dword(doseps->wmf_begin, outfile);
#line 88
  write_dword(doseps->wmf_length, outfile);
#line 89
  write_dword(doseps->tiff_begin, outfile);
#line 90
  write_dword(doseps->tiff_length, outfile);
#line 91
  write_word((WORD )doseps->checksum, outfile);
  }
#line 92
  return;
}
}
#line 97 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/ceps.c"
static void shift_preview(unsigned char *preview , int bwidth , int offset ) 
{ 
  int bitoffset ;
  int byteoffset ;
  int newwidth ;
  int shifter ;
  int i ;

  {
#line 105
  if (offset == 0) {
#line 106
    return;
  }
  {
#line 107
  byteoffset = offset / 8;
#line 108
  newwidth = bwidth - byteoffset;
#line 110
  memmove((void *)preview, (void const   *)(preview + byteoffset), (size_t )newwidth);
#line 111
  memset((void *)(preview + newwidth), 255, (size_t )(bwidth - newwidth));
#line 113
  bitoffset = offset - byteoffset * 8;
  }
#line 114
  if (bitoffset == 0) {
#line 115
    return;
  }
#line 116
  bitoffset = 8 - bitoffset;
#line 117
  i = 0;
  {
#line 117
  while (1) {
    while_continue: /* CIL Label */ ;
#line 117
    if (! (i < newwidth)) {
#line 117
      goto while_break;
    }
#line 118
    shifter = (int )*(preview + i) << 8;
#line 119
    if (i == newwidth - 1) {
#line 120
      shifter += 255;
    } else {
#line 122
      shifter += (int )*(preview + (i + 1));
    }
#line 123
    *(preview + i) = (unsigned char )(shifter >> bitoffset);
#line 117
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 125
  return;
}
}
#line 128 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/ceps.c"
static void validate_devbbox(IMAGE *img , CDSCBBOX *devbbox ) 
{ 
  int tmp ;

  {
#line 132
  if (devbbox->llx < 0) {
#line 133
    devbbox->llx = 0;
  } else
#line 132
  if (devbbox->llx >= (int )img->width) {
#line 133
    devbbox->llx = 0;
  }
#line 134
  if (devbbox->urx < 0) {
#line 135
    devbbox->urx = (int )img->width;
  } else
#line 134
  if (devbbox->urx >= (int )img->width) {
#line 135
    devbbox->urx = (int )img->width;
  }
#line 136
  if (devbbox->lly < 0) {
#line 137
    devbbox->lly = 0;
  } else
#line 136
  if (devbbox->lly >= (int )img->height) {
#line 137
    devbbox->lly = 0;
  }
#line 138
  if (devbbox->ury < 0) {
#line 139
    devbbox->ury = (int )img->height;
  } else
#line 138
  if (devbbox->ury >= (int )img->height) {
#line 139
    devbbox->ury = (int )img->height;
  }
#line 141
  if (devbbox->llx >= devbbox->urx) {
#line 142
    tmp = 0;
#line 142
    devbbox->lly = tmp;
#line 142
    devbbox->llx = tmp;
#line 143
    devbbox->urx = (int )img->width;
#line 144
    devbbox->ury = (int )img->height;
  } else
#line 141
  if (devbbox->lly >= devbbox->ury) {
#line 142
    tmp = 0;
#line 142
    devbbox->lly = tmp;
#line 142
    devbbox->llx = tmp;
#line 143
    devbbox->urx = (int )img->width;
#line 144
    devbbox->ury = (int )img->height;
  }
#line 146
  return;
}
}
#line 151 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/ceps.c"
static void write_bitmap_info(IMAGE *img , LPBITMAP2 pbmi , GFile *f ) 
{ 
  int i ;
  unsigned char r ;
  unsigned char g ;
  unsigned char b ;
  unsigned char quad[4] ;
  int palcount ;

  {
  {
#line 157
  palcount = 0;
#line 160
  write_dword((DWORD )40, f);
#line 161
  write_dword((DWORD )pbmi->biWidth, f);
#line 162
  write_dword((DWORD )pbmi->biHeight, f);
#line 163
  write_word(pbmi->biPlanes, f);
#line 164
  write_word(pbmi->biBitCount, f);
#line 165
  write_dword(pbmi->biCompression, f);
#line 166
  write_dword(pbmi->biSizeImage, f);
#line 167
  write_dword((DWORD )pbmi->biXPelsPerMeter, f);
#line 168
  write_dword((DWORD )pbmi->biYPelsPerMeter, f);
#line 169
  write_dword(pbmi->biClrUsed, f);
#line 170
  write_dword(pbmi->biClrImportant, f);
  }
#line 172
  if ((int )pbmi->biBitCount <= 8) {
#line 173
    palcount = 1 << (int )pbmi->biBitCount;
  }
#line 174
  i = 0;
  {
#line 174
  while (1) {
    while_continue: /* CIL Label */ ;
#line 174
    if (! (i < palcount)) {
#line 174
      goto while_break;
    }
    {
#line 175
    image_colour(img->format, i, & r, & g, & b);
#line 176
    quad[0] = b;
#line 177
    quad[1] = g;
#line 178
    quad[2] = r;
#line 179
    quad[3] = (unsigned char )'\000';
#line 180
    gfile_write(f, (void const   *)(quad), 4U);
#line 174
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 182
  return;
}
}
#line 189 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/ceps.c"
static void make_bmp_info(LPBITMAP2 pbmi , IMAGE *img , float xdpi , float ydpi ) 
{ 
  int palcount ;
  int depth ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 192
  palcount = 0;
#line 193
  tmp = image_depth(img);
#line 193
  depth = tmp;
  }
#line 194
  if (depth <= 8) {
#line 195
    palcount = 1 << depth;
  }
  {
#line 197
  pbmi->biSize = sizeof(BITMAP2 );
#line 198
  pbmi->biWidth = (LONG )img->width;
#line 199
  pbmi->biHeight = (LONG )img->width;
#line 200
  pbmi->biPlanes = (WORD )1;
#line 201
  tmp___0 = image_depth(img);
#line 201
  pbmi->biBitCount = (WORD )tmp___0;
#line 202
  pbmi->biCompression = (DWORD )0;
#line 203
  pbmi->biSizeImage = (DWORD )0;
#line 204
  pbmi->biXPelsPerMeter = (long )((double )((float )1000 * xdpi) / 25.4);
#line 205
  pbmi->biYPelsPerMeter = (long )((double )((float )1000 * ydpi) / 25.4);
#line 206
  pbmi->biClrUsed = (DWORD )palcount;
#line 207
  pbmi->biClrImportant = (DWORD )palcount;
  }
#line 208
  return;
}
}
#line 213 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/ceps.c"
int extract_doseps(Doc *doc , char const   *outname , BOOL preview ) 
{ 
  unsigned long pos ;
  unsigned long len ;
  unsigned int count ;
  char *buffer ;
  GFile *epsfile ;
  BOOL is_meta ;
  GFile *outfile ;
  CDSC *dsc ;
  char const   *tmp ;
  char const   *tmp___0 ;
  void *tmp___1 ;
  DWORD key ;
  char keybuf[4] ;
  DWORD wmf_key ;
  METAFILEHEADER mfh ;
  int i ;
  int temp ;
  unsigned short *pw ;
  unsigned short *tmp___2 ;
  unsigned int tmp___3 ;
  unsigned long tmp___4 ;

  {
#line 221
  is_meta = 1;
#line 223
  dsc = doc->dsc;
#line 225
  if ((unsigned long )dsc == (unsigned long )((CDSC *)((void *)0))) {
    {
#line 226
    app_csmsgf(doc->app, "Document \"%s\" is not a DOS EPS file\n", doc->name);
    }
#line 229
    return (-1);
  } else
#line 225
  if ((unsigned long )dsc->doseps == (unsigned long )((CDSCDOSEPS *)((void *)0))) {
    {
#line 226
    app_csmsgf(doc->app, "Document \"%s\" is not a DOS EPS file\n", doc->name);
    }
#line 229
    return (-1);
  }
  {
#line 232
  tmp = doc_name(doc);
#line 232
  epsfile = gfile_open(tmp, 0U);
#line 233
  pos = (dsc->doseps)->ps_begin;
#line 234
  len = (dsc->doseps)->ps_length;
  }
#line 235
  if (preview) {
#line 236
    pos = (dsc->doseps)->wmf_begin;
#line 237
    len = (dsc->doseps)->wmf_length;
#line 238
    if (pos == 0UL) {
#line 239
      pos = (dsc->doseps)->tiff_begin;
#line 240
      len = (dsc->doseps)->tiff_length;
#line 241
      is_meta = 0;
    }
  }
#line 244
  if (pos == 0UL) {
    {
#line 245
    gfile_close(epsfile);
    }
#line 246
    if (preview) {
#line 246
      tmp___0 = "preview";
    } else {
#line 246
      tmp___0 = "PostScript";
    }
    {
#line 246
    app_csmsgf(doc->app, "Document \"%s\" does not have a %s section\n", doc->name,
               tmp___0);
    }
#line 249
    return (-1);
  }
  {
#line 251
  gfile_seek(epsfile, (long )pos, 0U);
#line 253
  outfile = gfile_open(outname, 4097U);
  }
#line 254
  if ((unsigned long )outfile == (unsigned long )((GFile *)((void *)0))) {
    {
#line 255
    app_csmsgf(doc->app, "Failed to open output file \"%s\"\n", outname);
#line 257
    gfile_close(epsfile);
    }
#line 258
    return (-1);
  }
  {
#line 262
  tmp___1 = malloc((size_t )4096);
#line 262
  buffer = (char *)tmp___1;
  }
#line 263
  if ((unsigned long )buffer == (unsigned long )((char *)((void *)0))) {
    {
#line 264
    app_csmsgf(doc->app, "Out of memory in extract_doseps\n");
#line 265
    gfile_close(epsfile);
    }
#line 266
    if ((int const   )*outname != 0) {
      {
#line 267
      gfile_close(outfile);
      }
    }
#line 268
    return (-1);
  }
#line 271
  if (preview) {
#line 271
    if (is_meta) {
      {
#line 275
      wmf_key = 2596720087UL;
#line 276
      gfile_read(epsfile, (void *)(keybuf), 4U);
#line 277
      key = (DWORD )((((unsigned int )keybuf[0] + ((unsigned int )keybuf[1] << 8)) + ((unsigned int )keybuf[2] << 16)) + ((unsigned int )keybuf[3] << 24));
#line 281
      gfile_seek(epsfile, (long )pos, 0U);
      }
#line 282
      if (key != wmf_key) {
#line 287
        mfh.key = wmf_key;
#line 288
        mfh.hmf = (WORD )0;
#line 290
        mfh.bbox.left = (WORD )0;
#line 291
        mfh.bbox.top = (WORD )0;
#line 292
        if ((unsigned long )dsc->bbox != (unsigned long )((CDSCBBOX *)((void *)0))) {
#line 293
          temp = (dsc->bbox)->urx - (dsc->bbox)->llx;
#line 295
          mfh.bbox.right = (WORD )temp;
#line 296
          mfh.bbox.bottom = (WORD )((dsc->bbox)->ury - (dsc->bbox)->lly);
#line 297
          temp = (dsc->bbox)->ury - (dsc->bbox)->lly;
#line 298
          mfh.bbox.bottom = (WORD )temp;
        } else {
#line 302
          mfh.bbox.right = (WORD )595;
#line 303
          mfh.bbox.bottom = (WORD )842;
        }
#line 305
        mfh.inch = (WORD )72;
#line 306
        mfh.reserved = (DWORD )0L;
#line 307
        mfh.checksum = (WORD )0;
#line 308
        pw = (WORD *)(& mfh);
#line 309
        temp = 0;
#line 310
        i = 0;
        {
#line 310
        while (1) {
          while_continue: /* CIL Label */ ;
#line 310
          if (! (i < 10)) {
#line 310
            goto while_break;
          }
#line 311
          tmp___2 = pw;
#line 311
          pw ++;
#line 311
          temp ^= (int )*tmp___2;
#line 310
          i ++;
        }
        while_break: /* CIL Label */ ;
        }
        {
#line 313
        mfh.checksum = (WORD )temp;
#line 314
        write_dword(mfh.key, outfile);
#line 315
        write_word(mfh.hmf, outfile);
#line 316
        write_word(mfh.bbox.left, outfile);
#line 317
        write_word(mfh.bbox.top, outfile);
#line 318
        write_word(mfh.bbox.right, outfile);
#line 319
        write_word(mfh.bbox.bottom, outfile);
#line 320
        write_word(mfh.inch, outfile);
#line 321
        write_dword(mfh.reserved, outfile);
#line 322
        write_word(mfh.checksum, outfile);
        }
      }
    }
  }
  {
#line 326
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 326
    if (len < 4096UL) {
#line 326
      tmp___4 = len;
    } else {
#line 326
      tmp___4 = 4096UL;
    }
#line 326
    count = (unsigned int )tmp___4;
#line 326
    if (! (count != 0U)) {
#line 326
      goto while_break___0;
    }
    {
#line 327
    tmp___3 = gfile_read(epsfile, (void *)buffer, count);
#line 327
    count = (unsigned int )((int )tmp___3);
#line 328
    gfile_write(outfile, (void const   *)buffer, count);
    }
#line 329
    if (count == 0U) {
#line 330
      len = 0UL;
    } else {
#line 332
      len -= (unsigned long )count;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 334
  free((void *)buffer);
#line 335
  gfile_close(epsfile);
#line 336
  gfile_close(outfile);
  }
#line 338
  return (0);
}
}
#line 342 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/ceps.c"
int extract_macbin(Doc *doc , char const   *outname , BOOL preview ) 
{ 
  unsigned long pos ;
  unsigned long len ;
  unsigned int count ;
  char *buffer ;
  GFile *epsfile ;
  GFile *outfile ;
  CDSC *dsc ;
  CMACFILE *mac ;
  char const   *tmp ;
  char const   *tmp___0 ;
  int code ;
  void *tmp___1 ;
  unsigned int tmp___2 ;
  unsigned long tmp___3 ;

  {
#line 351
  dsc = doc->dsc;
#line 355
  if ((unsigned long )dsc == (unsigned long )((CDSC *)((void *)0))) {
    {
#line 356
    app_csmsgf(doc->app, "Document \"%s\" is not a Macintosh EPSF file with preview\n",
               doc->name);
    }
#line 359
    return (-1);
  } else
#line 355
  if ((unsigned long )dsc->macbin == (unsigned long )((CDSCMACBIN *)((void *)0))) {
    {
#line 356
    app_csmsgf(doc->app, "Document \"%s\" is not a Macintosh EPSF file with preview\n",
               doc->name);
    }
#line 359
    return (-1);
  }
  {
#line 362
  tmp = doc_name(doc);
#line 362
  epsfile = gfile_open(tmp, 0U);
  }
#line 363
  if ((unsigned long )epsfile == (unsigned long )((void *)0)) {
    {
#line 364
    tmp___0 = doc_name(doc);
#line 364
    app_csmsgf(doc->app, "Failed to open \"%s\"\n", tmp___0);
    }
#line 366
    return (-1);
  }
#line 369
  if (preview) {
    {
#line 370
    code = 0;
#line 371
    mac = get_mactype(epsfile);
    }
#line 372
    if ((unsigned long )mac == (unsigned long )((void *)0)) {
      {
#line 373
      app_csmsgf(doc->app, "Not a Mac file with resource fork\n");
#line 374
      code = -1;
      }
    }
#line 376
    if (code == 0) {
      {
#line 377
      code = get_pict(epsfile, mac, 0);
      }
#line 378
      if (code) {
        {
#line 379
        app_csmsgf(doc->app, "Resource fork didn\'t contain PICT preview\n");
        }
      }
    }
#line 382
    if (code == 0) {
      {
#line 383
      code = extract_mac_pict(epsfile, mac, outname);
      }
#line 384
      if (code) {
        {
#line 385
        app_csmsgf(doc->app, "Failed to find PICT preview or write file\n");
        }
      }
    }
    {
#line 388
    gfile_close(epsfile);
    }
#line 389
    return (code);
  }
#line 392
  pos = (dsc->macbin)->data_begin;
#line 393
  len = (dsc->macbin)->data_length;
#line 394
  if (len == 0UL) {
    {
#line 395
    app_csmsgf(doc->app, "File has not data section for EPSF\n");
#line 397
    gfile_close(epsfile);
    }
#line 398
    return (-1);
  }
  {
#line 400
  gfile_seek(epsfile, (long )pos, 0U);
#line 402
  outfile = gfile_open(outname, 4097U);
  }
#line 403
  if ((unsigned long )outfile == (unsigned long )((GFile *)((void *)0))) {
    {
#line 404
    app_csmsgf(doc->app, "Failed to open output file \"%s\"\n", outname);
#line 406
    gfile_close(epsfile);
    }
#line 407
    return (-1);
  }
  {
#line 411
  tmp___1 = malloc((size_t )4096);
#line 411
  buffer = (char *)tmp___1;
  }
#line 412
  if ((unsigned long )buffer == (unsigned long )((char *)((void *)0))) {
    {
#line 413
    app_csmsgf(doc->app, "Out of memory in extract_doseps\n");
#line 414
    gfile_close(epsfile);
    }
#line 415
    if ((int const   )*outname != 0) {
      {
#line 416
      gfile_close(outfile);
      }
    }
#line 417
    return (-1);
  }
  {
#line 420
  while (1) {
    while_continue: /* CIL Label */ ;
#line 420
    if (len < 4096UL) {
#line 420
      tmp___3 = len;
    } else {
#line 420
      tmp___3 = 4096UL;
    }
#line 420
    count = (unsigned int )tmp___3;
#line 420
    if (! (count != 0U)) {
#line 420
      goto while_break;
    }
    {
#line 421
    tmp___2 = gfile_read(epsfile, (void *)buffer, count);
#line 421
    count = (unsigned int )((int )tmp___2);
#line 422
    gfile_write(outfile, (void const   *)buffer, count);
    }
#line 423
    if (count == 0U) {
#line 424
      len = 0UL;
    } else {
#line 426
      len -= (unsigned long )count;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 428
  free((void *)buffer);
#line 429
  gfile_close(epsfile);
#line 430
  gfile_close(outfile);
  }
#line 432
  return (0);
}
}
#line 442 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/ceps.c"
int make_eps_tiff(Doc *doc , IMAGE *img , CDSCBBOX devbbox , CDSCBBOX *bbox , CDSCFBBOX *hires_bbox ,
                  float xdpi , float ydpi , BOOL tiff4 , BOOL use_packbits , BOOL reverse ,
                  char const   *epsname ) 
{ 
  GFile *epsfile ;
  GFile *tiff_file ;
  char tiffname[256] ;
  CDSCDOSEPS doseps ;
  int code ;
  GFile *tpsfile ;
  char tpsname[256] ;
  char *buffer ;
  unsigned int count ;
  CDSC *dsc ;
  void *tmp ;
  unsigned long tmp___0 ;
  unsigned long tmp___1 ;
  unsigned int tmp___2 ;
  unsigned int tmp___3 ;
  unsigned int tmp___4 ;

  {
#line 457
  dsc = doc->dsc;
#line 459
  if ((unsigned long )dsc == (unsigned long )((void *)0)) {
#line 460
    return (-1);
  }
  {
#line 462
  validate_devbbox(img, & devbbox);
#line 465
  tiff_file = app_temp_gfile(doc->app, tiffname, (int )(sizeof(tiffname) / sizeof(char )));
  }
#line 465
  if ((unsigned long )tiff_file == (unsigned long )((GFile *)((void *)0))) {
    {
#line 467
    app_csmsgf(doc->app, "Can\'t open temporary TIFF file \"%s\"\n", tiffname);
    }
#line 470
    return (-1);
  }
  {
#line 472
  code = image_to_tiff(tiff_file, img, devbbox.llx, devbbox.lly, devbbox.urx, devbbox.ury,
                       xdpi, ydpi, tiff4, use_packbits);
#line 475
  gfile_close(tiff_file);
  }
#line 476
  if (code) {
    {
#line 477
    app_csmsgf(doc->app, "Failed to write temporary TIFF file \"%s\"\n", tiffname);
    }
#line 480
    if (! (debug & 1)) {
      {
#line 481
      unlink((char const   *)(tiffname));
      }
    }
#line 482
    return (code);
  }
  {
#line 486
  tpsfile = (GFile *)((void *)0);
#line 487
  memset((void *)(tpsname), 0, sizeof(tpsname));
#line 488
  tpsfile = app_temp_gfile(doc->app, tpsname, (int )(sizeof(tpsname) / sizeof(char )));
  }
#line 488
  if ((unsigned long )tpsfile == (unsigned long )((GFile *)((void *)0))) {
    {
#line 490
    app_csmsgf(doc->app, "Can\'t create temporary EPS file \"%s\"\n", tpsname);
#line 493
    unlink((char const   *)(tiffname));
    }
#line 494
    return (-1);
  }
  {
#line 496
  gfile_close(tpsfile);
#line 498
  code = copy_eps(doc, (char const   *)(tpsname), bbox, hires_bbox, 30, 0);
  }
#line 500
  if (code) {
#line 501
    if (! (debug & 1)) {
      {
#line 502
      unlink((char const   *)(tiffname));
      }
    }
#line 503
    return (-1);
  }
  {
#line 507
  tpsfile = gfile_open((char const   *)(tpsname), 0U);
  }
#line 507
  if ((unsigned long )tpsfile == (unsigned long )((GFile *)((void *)0))) {
    {
#line 508
    app_csmsgf(doc->app, "Can\'t open temporary EPS file \"%s\"\n", tpsname);
    }
#line 511
    if (! (debug & 1)) {
      {
#line 512
      unlink((char const   *)(tiffname));
      }
    }
#line 513
    return (-1);
  }
  {
#line 517
  epsfile = gfile_open(epsname, 4097U);
  }
#line 518
  if ((unsigned long )epsfile == (unsigned long )((GFile *)((void *)0))) {
    {
#line 519
    app_csmsgf(doc->app, "Can\'t open output EPS file \"%s\"\n", epsname);
    }
#line 522
    if (! (debug & 1)) {
      {
#line 523
      unlink((char const   *)(tiffname));
      }
    }
    {
#line 524
    gfile_close(tpsfile);
    }
#line 525
    if (! (debug & 1)) {
      {
#line 526
      unlink((char const   *)(tpsname));
      }
    }
#line 527
    return (-1);
  }
  {
#line 530
  tmp = malloc((size_t )4096);
#line 530
  buffer = (char *)tmp;
  }
#line 531
  if ((unsigned long )buffer == (unsigned long )((char *)((void *)0))) {
#line 532
    if (*(epsname + 0)) {
      {
#line 533
      gfile_close(epsfile);
      }
#line 534
      if (! (debug & 1)) {
        {
#line 535
        unlink(epsname);
        }
      }
    }
#line 537
    if (! (debug & 1)) {
      {
#line 538
      unlink((char const   *)(tiffname));
      }
    }
    {
#line 539
    gfile_close(tpsfile);
    }
#line 540
    if (! (debug & 1)) {
      {
#line 541
      unlink((char const   *)(tpsname));
      }
    }
#line 542
    return (-1);
  }
  {
#line 545
  tiff_file = gfile_open((char const   *)(tiffname), 0U);
  }
#line 545
  if ((unsigned long )tiff_file == (unsigned long )((GFile *)((void *)0))) {
    {
#line 546
    app_csmsgf(doc->app, "Can\'t open temporary TIFF file \"%s\"\n", tiffname);
#line 549
    free((void *)buffer);
    }
#line 550
    if (! (debug & 1)) {
      {
#line 551
      unlink((char const   *)(tiffname));
      }
    }
    {
#line 552
    gfile_close(tpsfile);
    }
#line 553
    if (! (debug & 1)) {
      {
#line 554
      unlink((char const   *)(tpsname));
      }
    }
#line 555
    if (*(epsname + 0)) {
      {
#line 556
      gfile_close(epsfile);
      }
#line 557
      if (! (debug & 1)) {
        {
#line 558
        unlink(epsname);
        }
      }
    }
#line 560
    return (-1);
  }
  {
#line 562
  tmp___0 = gfile_get_length(tpsfile);
#line 562
  doseps.ps_length = tmp___0;
#line 563
  doseps.wmf_begin = (GSDWORD )0;
#line 564
  doseps.wmf_length = (GSDWORD )0;
#line 565
  tmp___1 = gfile_get_length(tiff_file);
#line 565
  doseps.tiff_length = tmp___1;
  }
#line 566
  if (reverse) {
#line 567
    doseps.tiff_begin = (GSDWORD )30;
#line 568
    doseps.ps_begin = doseps.tiff_begin + doseps.tiff_length;
  } else {
#line 571
    doseps.ps_begin = (GSDWORD )30;
#line 572
    doseps.tiff_begin = doseps.ps_begin + doseps.ps_length;
  }
  {
#line 574
  doseps.checksum = (GSWORD )65535;
#line 575
  write_doseps_header(& doseps, epsfile);
#line 577
  gfile_seek(tpsfile, 0L, 0U);
  }
#line 578
  if (! reverse) {
    {
#line 580
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 580
      tmp___2 = gfile_read(tpsfile, (void *)buffer, 4096U);
#line 580
      count = (unsigned int )((int )tmp___2);
      }
#line 580
      if (! (count != 0U)) {
#line 580
        goto while_break;
      }
      {
#line 581
      gfile_write(epsfile, (void const   *)buffer, count);
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 585
  gfile_seek(tiff_file, 0L, 0U);
  }
  {
#line 586
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 586
    tmp___3 = gfile_read(tiff_file, (void *)buffer, 4096U);
#line 586
    count = (unsigned int )((int )tmp___3);
    }
#line 586
    if (! (count != 0U)) {
#line 586
      goto while_break___0;
    }
    {
#line 587
    gfile_write(epsfile, (void const   *)buffer, count);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 589
  if (reverse) {
    {
#line 591
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 591
      tmp___4 = gfile_read(tpsfile, (void *)buffer, 4096U);
#line 591
      count = (unsigned int )((int )tmp___4);
      }
#line 591
      if (! (count != 0U)) {
#line 591
        goto while_break___1;
      }
      {
#line 592
      gfile_write(epsfile, (void const   *)buffer, count);
      }
    }
    while_break___1: /* CIL Label */ ;
    }
  }
  {
#line 595
  free((void *)buffer);
#line 596
  gfile_close(tiff_file);
  }
#line 597
  if (! (debug & 1)) {
    {
#line 598
    unlink((char const   *)(tiffname));
    }
  }
  {
#line 599
  gfile_close(tpsfile);
  }
#line 600
  if (! (debug & 1)) {
    {
#line 601
    unlink((char const   *)(tpsname));
    }
  }
  {
#line 602
  gfile_close(epsfile);
  }
#line 603
  return (0);
}
}
#line 608 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/ceps.c"
static char hex[17]  = 
#line 608
  {      (char )'0',      (char )'1',      (char )'2',      (char )'3', 
        (char )'4',      (char )'5',      (char )'6',      (char )'7', 
        (char )'8',      (char )'9',      (char )'A',      (char )'B', 
        (char )'C',      (char )'D',      (char )'E',      (char )'F', 
        (char )'\000'};
#line 614 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/ceps.c"
int write_interchange(GFile *f , IMAGE *img , CDSCBBOX devbbox ) 
{ 
  int i ;
  int j ;
  unsigned char *preview ;
  char buf[256] ;
  char const   *eol_str___0 ;
  char const   *endpreview_str ;
  BYTE *line ;
  int preview_width ;
  int bwidth ;
  int lines_per_scan ;
  int topfirst ;
  char hexline[76] ;
  int hexcount ;
  unsigned int value ;
  unsigned int depth ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  size_t tmp___9 ;
  size_t tmp___10 ;
  size_t tmp___11 ;

  {
  {
#line 620
  eol_str___0 = "\n";
#line 621
  endpreview_str = "%%EndPreview";
#line 625
  topfirst = ((long )img->format & 131072L) == 0L;
#line 627
  hexcount = 0;
#line 629
  depth = 8U;
#line 631
  validate_devbbox(img, & devbbox);
  }
  {
#line 635
  if (((long )img->format & 15L) == 2L) {
#line 635
    goto case_2;
  }
#line 635
  if (((long )img->format & 15L) == 1L) {
#line 635
    goto case_2;
  }
#line 633
  goto switch_break;
  case_2: /* CIL Label */ 
  case_1: /* CIL Label */ 
#line 636
  if (((long )img->format & 65280L) == 256L) {
#line 637
    depth = 1U;
  }
  switch_break: /* CIL Label */ ;
  }
  {
#line 641
  if (depth == 1U) {
#line 641
    goto case_1___0;
  }
#line 647
  if (depth == 8U) {
#line 647
    goto case_8;
  }
#line 651
  goto switch_default;
  case_1___0: /* CIL Label */ 
#line 643
  bwidth = (((devbbox.urx - devbbox.llx) + 7) & -8) >> 3;
#line 645
  preview_width = (int )(((img->width + 7U) & 4294967288U) >> 3);
#line 646
  goto switch_break___0;
  case_8: /* CIL Label */ 
#line 648
  bwidth = devbbox.urx - devbbox.llx;
#line 649
  preview_width = (int )img->width;
#line 650
  goto switch_break___0;
  switch_default: /* CIL Label */ 
#line 652
  return (-1);
  switch_break___0: /* CIL Label */ ;
  }
  {
#line 655
  tmp = malloc((size_t )preview_width);
#line 655
  preview = (unsigned char *)tmp;
#line 657
  lines_per_scan = ((bwidth + 35) - 1) / 35;
#line 658
  buf[sizeof(buf) - 1UL] = (char )'\000';
#line 659
  snprintf((char */* __restrict  */)(buf), (size_t )255, (char const   */* __restrict  */)"%%%%BeginPreview: %u %u %u %u%s",
           devbbox.urx - devbbox.llx, devbbox.ury - devbbox.lly, depth, (devbbox.ury - devbbox.lly) * lines_per_scan,
           eol_str___0);
#line 662
  gfile_puts(f, (char const   *)(buf));
  }
#line 664
  if (topfirst) {
#line 665
    line = img->image + img->raster * (img->height - (unsigned int )devbbox.ury);
  } else {
#line 667
    line = img->image + img->raster * (unsigned int )(devbbox.ury - 1);
  }
#line 670
  i = 0;
  {
#line 670
  while (1) {
    while_continue: /* CIL Label */ ;
#line 670
    if (! (i < devbbox.ury - devbbox.lly)) {
#line 670
      goto while_break;
    }
    {
#line 671
    memset((void *)preview, 255, (size_t )preview_width);
    }
#line 672
    if (depth == 1U) {
      {
#line 673
      image_to_mono(img, preview, line);
      }
#line 674
      if (devbbox.llx) {
        {
#line 675
        shift_preview(preview, preview_width, devbbox.llx);
        }
      }
    } else {
      {
#line 678
      image_to_grey(img, preview, line);
      }
#line 679
      if (devbbox.llx) {
        {
#line 680
        memmove((void *)preview, (void const   *)(preview + devbbox.llx), (size_t )preview_width);
        }
      }
    }
#line 682
    hexcount = 0;
#line 683
    tmp___0 = hexcount;
#line 683
    hexcount ++;
#line 683
    hexline[tmp___0] = (char )'%';
#line 684
    tmp___1 = hexcount;
#line 684
    hexcount ++;
#line 684
    hexline[tmp___1] = (char )' ';
#line 685
    j = 0;
    {
#line 685
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 685
      if (! (j < bwidth)) {
#line 685
        goto while_break___0;
      }
#line 686
      if (hexcount >= 72) {
        {
#line 687
        tmp___4 = strlen(eol_str___0);
        }
#line 687
        if (tmp___4 <= sizeof(hexline) - (unsigned long )hexcount) {
          {
#line 688
          tmp___2 = strlen(eol_str___0);
#line 688
          memcpy((void */* __restrict  */)(hexline + hexcount), (void const   */* __restrict  */)eol_str___0,
                 tmp___2);
#line 689
          tmp___3 = strlen(eol_str___0);
#line 689
          hexcount += (int )tmp___3;
          }
        }
        {
#line 691
        gfile_write(f, (void const   *)(hexline), (unsigned int )hexcount);
#line 692
        hexcount = 0;
#line 693
        tmp___5 = hexcount;
#line 693
        hexcount ++;
#line 693
        hexline[tmp___5] = (char )'%';
#line 694
        tmp___6 = hexcount;
#line 694
        hexcount ++;
#line 694
        hexline[tmp___6] = (char )' ';
        }
      }
#line 696
      value = (unsigned int )*(preview + j);
#line 697
      if (depth == 8U) {
#line 698
        value = 255U - value;
      }
#line 699
      tmp___7 = hexcount;
#line 699
      hexcount ++;
#line 699
      hexline[tmp___7] = hex[(value >> 4) & 15U];
#line 700
      tmp___8 = hexcount;
#line 700
      hexcount ++;
#line 700
      hexline[tmp___8] = hex[value & 15U];
#line 685
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 702
    if (hexcount) {
      {
#line 702
      tmp___11 = strlen(eol_str___0);
      }
#line 702
      if (tmp___11 <= sizeof(hexline) - (unsigned long )hexcount) {
        {
#line 703
        tmp___9 = strlen(eol_str___0);
#line 703
        memcpy((void */* __restrict  */)(hexline + hexcount), (void const   */* __restrict  */)eol_str___0,
               tmp___9);
#line 704
        tmp___10 = strlen(eol_str___0);
#line 704
        hexcount += (int )tmp___10;
        }
      }
    }
#line 706
    if (hexcount) {
      {
#line 707
      gfile_write(f, (void const   *)(hexline), (unsigned int )hexcount);
      }
    }
#line 709
    if (topfirst) {
#line 710
      line += img->raster;
    } else {
#line 712
      line -= img->raster;
    }
#line 670
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 717
  gfile_puts(f, endpreview_str);
#line 718
  gfile_puts(f, eol_str___0);
#line 719
  free((void *)preview);
  }
#line 721
  return (0);
}
}
#line 736 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/ceps.c"
int make_eps_user(Doc *doc , char const   *preview_name , BOOL reverse , char const   *epsname ) 
{ 
  GFile *epsfile ;
  GFile *preview_file ;
  unsigned long preview_length ;
  unsigned char id[4] ;
  PREVIEW_TYPE type ;
  CDSCDOSEPS doseps ;
  char *buffer ;
  unsigned int count ;
  GFile *tpsfile ;
  char tpsname[256] ;
  unsigned long tmp ;
  int tmp___0 ;
  unsigned long tmp___1 ;
  void *tmp___2 ;
  unsigned int tmp___3 ;
  unsigned int tmp___4 ;
  unsigned int tmp___5 ;

  {
#line 743
  type = (PREVIEW_TYPE )0;
#line 750
  if ((unsigned long )preview_name == (unsigned long )((void *)0)) {
#line 751
    return (-1);
  } else
#line 750
  if ((int const   )*(preview_name + 0) == 0) {
#line 751
    return (-1);
  }
#line 752
  if ((unsigned long )doc->dsc == (unsigned long )((void *)0)) {
#line 753
    return (-1);
  }
  {
#line 756
  preview_file = gfile_open(preview_name, 0U);
  }
#line 757
  if ((unsigned long )preview_file == (unsigned long )((GFile *)((void *)0))) {
    {
#line 758
    app_csmsgf(doc->app, "Can\'t open preview file \"%s\"\n", preview_name);
    }
#line 760
    return (-1);
  }
  {
#line 764
  gfile_read(preview_file, (void *)(id), 4U);
#line 765
  tmp = gfile_get_length(preview_file);
#line 765
  preview_length = tmp;
#line 766
  gfile_seek(preview_file, 0L, 0U);
  }
#line 768
  if ((int )id[0] == 73) {
#line 768
    if ((int )id[1] == 73) {
#line 769
      type = (PREVIEW_TYPE )1;
    }
  }
#line 770
  if ((int )id[0] == 77) {
#line 770
    if ((int )id[1] == 77) {
#line 771
      type = (PREVIEW_TYPE )1;
    }
  }
#line 772
  if ((int )id[0] == 1) {
#line 772
    if ((int )id[1] == 0) {
#line 772
      if ((int )id[2] == 9) {
#line 772
        if ((int )id[3] == 0) {
#line 774
          type = (PREVIEW_TYPE )2;
        }
      }
    }
  }
#line 775
  if ((int )id[0] == 215) {
#line 775
    if ((int )id[1] == 205) {
#line 775
      if ((int )id[2] == 198) {
#line 775
        if ((int )id[3] == 154) {
          {
#line 777
          type = (PREVIEW_TYPE )2;
#line 778
          preview_length -= 22UL;
#line 779
          gfile_seek(preview_file, 22L, 0U);
          }
        }
      }
    }
  }
#line 782
  if ((unsigned int )type == 0U) {
    {
#line 783
    app_csmsgf(doc->app, "Preview file \"%s\" is not TIFF or Windows Metafile\n",
               preview_name);
#line 786
    gfile_close(preview_file);
    }
#line 787
    return (-1);
  }
  {
#line 793
  tpsfile = (GFile *)((void *)0);
#line 794
  memset((void *)(tpsname), 0, sizeof(tpsname));
#line 795
  tpsfile = app_temp_gfile(doc->app, tpsname, (int )(sizeof(tpsname) / sizeof(char )));
  }
#line 795
  if ((unsigned long )tpsfile == (unsigned long )((GFile *)((void *)0))) {
    {
#line 797
    app_csmsgf(doc->app, "Can\'t create temporary EPS file \"%s\"\n", tpsname);
#line 800
    gfile_close(preview_file);
    }
#line 801
    return (-1);
  }
  {
#line 803
  gfile_close(tpsfile);
#line 805
  tmp___0 = copy_eps(doc, (char const   *)(tpsname), (doc->dsc)->bbox, (doc->dsc)->hires_bbox,
                     30, 0);
  }
#line 805
  if (tmp___0 < 0) {
#line 807
    return (-1);
  }
  {
#line 810
  tpsfile = gfile_open((char const   *)(tpsname), 0U);
  }
#line 810
  if ((unsigned long )tpsfile == (unsigned long )((GFile *)((void *)0))) {
    {
#line 811
    app_csmsgf(doc->app, "Can\'t open temporary EPS file \"%s\"\n", tpsname);
#line 814
    gfile_close(preview_file);
    }
#line 815
    return (-1);
  }
  {
#line 820
  epsfile = gfile_open(epsname, 4097U);
  }
#line 822
  if ((unsigned long )epsfile == (unsigned long )((GFile *)((void *)0))) {
    {
#line 823
    app_csmsgf(doc->app, "Can\'t open EPS output file \"%s\"\n", epsname);
#line 826
    gfile_close(preview_file);
#line 827
    gfile_close(tpsfile);
    }
#line 828
    if (! (debug & 1)) {
      {
#line 829
      unlink((char const   *)(tpsname));
      }
    }
#line 830
    return (-1);
  }
  {
#line 834
  tmp___1 = gfile_get_length(tpsfile);
#line 834
  doseps.ps_length = tmp___1;
  }
#line 835
  if ((unsigned int )type == 2U) {
#line 836
    doseps.wmf_length = preview_length;
#line 837
    doseps.tiff_begin = (GSDWORD )0;
#line 838
    doseps.tiff_length = (GSDWORD )0;
#line 839
    if (reverse) {
#line 840
      doseps.wmf_begin = (GSDWORD )30;
#line 841
      doseps.ps_begin = doseps.wmf_begin + doseps.wmf_length;
    } else {
#line 844
      doseps.ps_begin = (GSDWORD )30;
#line 845
      doseps.wmf_begin = doseps.ps_begin + doseps.ps_length;
    }
  } else {
#line 849
    doseps.wmf_begin = (GSDWORD )0;
#line 850
    doseps.wmf_length = (GSDWORD )0;
#line 851
    doseps.tiff_length = preview_length;
#line 852
    if (reverse) {
#line 853
      doseps.tiff_begin = (GSDWORD )30;
#line 854
      doseps.ps_begin = doseps.tiff_begin + doseps.tiff_length;
    } else {
#line 857
      doseps.ps_begin = (GSDWORD )30;
#line 858
      doseps.tiff_begin = doseps.ps_begin + doseps.ps_length;
    }
  }
  {
#line 861
  doseps.checksum = (GSWORD )65535;
#line 862
  write_doseps_header(& doseps, epsfile);
#line 864
  tmp___2 = malloc((size_t )4096);
#line 864
  buffer = (char *)tmp___2;
  }
#line 865
  if ((unsigned long )buffer == (unsigned long )((char *)((void *)0))) {
    {
#line 866
    app_csmsgf(doc->app, "Out of memory in make_eps_user\n");
    }
#line 867
    if (*(epsname + 0)) {
      {
#line 868
      gfile_close(epsfile);
      }
#line 869
      if (! (debug & 1)) {
        {
#line 870
        unlink(epsname);
        }
      }
    }
    {
#line 872
    gfile_close(preview_file);
#line 873
    gfile_close(tpsfile);
    }
#line 874
    if (! (debug & 1)) {
      {
#line 875
      unlink((char const   *)(tpsname));
      }
    }
#line 876
    return (-1);
  }
  {
#line 879
  gfile_seek(tpsfile, 0L, 0U);
  }
#line 880
  if (! reverse) {
    {
#line 882
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 882
      tmp___3 = gfile_read(tpsfile, (void *)buffer, 4096U);
#line 882
      count = (unsigned int )((int )tmp___3);
      }
#line 882
      if (! (count != 0U)) {
#line 882
        goto while_break;
      }
      {
#line 883
      gfile_write(epsfile, (void const   *)buffer, count);
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 887
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 887
    tmp___4 = gfile_read(preview_file, (void *)buffer, 4096U);
#line 887
    count = (unsigned int )((int )tmp___4);
    }
#line 887
    if (! (count != 0U)) {
#line 887
      goto while_break___0;
    }
    {
#line 888
    gfile_write(epsfile, (void const   *)buffer, count);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 890
  if (reverse) {
    {
#line 892
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 892
      tmp___5 = gfile_read(tpsfile, (void *)buffer, 4096U);
#line 892
      count = (unsigned int )((int )tmp___5);
      }
#line 892
      if (! (count != 0U)) {
#line 892
        goto while_break___1;
      }
      {
#line 893
      gfile_write(epsfile, (void const   *)buffer, count);
      }
    }
    while_break___1: /* CIL Label */ ;
    }
  }
  {
#line 896
  free((void *)buffer);
#line 897
  gfile_close(tpsfile);
  }
#line 898
  if (! (debug & 1)) {
    {
#line 899
    unlink((char const   *)(tpsname));
    }
  }
  {
#line 900
  gfile_close(preview_file);
#line 901
  gfile_close(epsfile);
  }
#line 902
  return (0);
}
}
#line 918
int write_metafile(GFile *f , IMAGE *img , CDSCBBOX devbbox , float xdpi , float ydpi ,
                   MFH *mf ) ;
#line 920
static int metafile_init(IMAGE *img , CDSCBBOX *pdevbbox , MFH *mf ) ;
#line 927 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/ceps.c"
static int metafile_init(IMAGE *img , CDSCBBOX *pdevbbox , MFH *mf ) 
{ 
  int wx ;
  int wy ;
  int ny ;
  int nylast ;
  int complete ;
  int partial ;
  int bytewidth ;
  int palcount ;
  unsigned long size ;
  int depth ;
  int tmp ;

  {
  {
#line 936
  tmp = image_depth(img);
#line 936
  depth = tmp;
  }
  {
#line 942
  if (depth == 24) {
#line 942
    goto case_24;
  }
#line 942
  if (depth == 8) {
#line 942
    goto case_24;
  }
#line 942
  if (depth == 4) {
#line 942
    goto case_24;
  }
#line 942
  if (depth == 1) {
#line 942
    goto case_24;
  }
#line 944
  goto switch_default;
  case_24: /* CIL Label */ 
  case_8: /* CIL Label */ 
  case_4: /* CIL Label */ 
  case_1: /* CIL Label */ 
#line 943
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 946
  return (-1);
  switch_break: /* CIL Label */ ;
  }
  {
#line 949
  validate_devbbox(img, pdevbbox);
#line 951
  wx = pdevbbox->urx - pdevbbox->llx;
#line 952
  wy = pdevbbox->ury - pdevbbox->lly;
#line 953
  bytewidth = ((wx * depth + 31) & -32) >> 3;
#line 954
  ny = (int )(64000L / (long )bytewidth);
  }
#line 955
  if (depth == 24) {
#line 956
    palcount = 0;
  } else {
#line 958
    palcount = 1 << depth;
  }
#line 960
  complete = wy / ny;
#line 961
  nylast = wy % ny;
#line 962
  if (nylast) {
#line 962
    partial = 1;
  } else {
#line 962
    partial = 0;
  }
#line 964
  mf->type = (WORD )1;
#line 965
  mf->headersize = (WORD )9;
#line 966
  mf->version = (WORD )768;
#line 967
  mf->size = 19UL;
#line 972
  mf->size += (DWORD )(14 * complete);
#line 973
  size = ((unsigned long )(40L + (long )palcount * 4L) + (unsigned long )ny * (unsigned long )bytewidth) / 2UL;
#line 974
  mf->size += size * (unsigned long )complete;
#line 976
  mf->size += (DWORD )(14 * partial);
#line 977
  size = ((unsigned long )(40L + (long )palcount * 4L) + (unsigned long )nylast * (unsigned long )bytewidth) / 2UL;
#line 978
  mf->size += size * (unsigned long )partial;
#line 979
  mf->size += 3UL;
#line 981
  mf->nobj = (WORD )0;
#line 982
  if (complete) {
#line 982
    size = ((unsigned long )(40L + (long )palcount * 4L) + (unsigned long )ny * (unsigned long )bytewidth) / 2UL;
  } else {
#line 982
    size = ((unsigned long )(40L + (long )palcount * 4L) + (unsigned long )nylast * (unsigned long )bytewidth) / 2UL;
  }
#line 985
  mf->maxrec = 14UL + size;
#line 986
  mf->noparam = (WORD )0;
#line 987
  return (0);
}
}
#line 993 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/ceps.c"
int write_metafile(GFile *f , IMAGE *img , CDSCBBOX devbbox , float xdpi , float ydpi ,
                   MFH *mf ) 
{ 
  int i ;
  int wx ;
  int ny ;
  int sy ;
  int dy ;
  int wy ;
  BYTE *line ;
  BYTE *line2 ;
  LPBITMAP2 pbmi ;
  int bsize ;
  int bitoffset ;
  int bytewidth ;
  int activewidth ;
  int palcount ;
  unsigned long size ;
  int depth ;
  int tmp ;
  int topfirst ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
  {
#line 1008
  tmp = image_depth(img);
#line 1008
  depth = tmp;
#line 1009
  topfirst = ((long )img->format & 131072L) == 0L;
#line 1011
  dy = 0;
#line 1012
  wx = devbbox.urx - devbbox.llx;
#line 1013
  sy = devbbox.lly;
#line 1014
  wy = devbbox.ury - devbbox.lly;
#line 1015
  bitoffset = devbbox.llx * depth;
#line 1016
  bytewidth = ((wx * depth + 31) & -32) >> 3;
#line 1017
  activewidth = ((wx * depth + 7) & -8) >> 3;
#line 1018
  ny = (int )(64000L / (long )bytewidth);
  }
#line 1019
  if (depth == 24) {
#line 1020
    palcount = 0;
  } else {
#line 1022
    palcount = 1 << depth;
  }
  {
#line 1025
  bsize = (int )(sizeof(BITMAP2 ) + (unsigned long )(palcount * 4));
#line 1026
  tmp___0 = malloc((size_t )bsize);
#line 1026
  pbmi = (LPBITMAP2 )tmp___0;
  }
#line 1027
  if ((unsigned long )pbmi == (unsigned long )((void *)0)) {
#line 1028
    return (-1);
  }
  {
#line 1030
  memset((void *)((char *)pbmi), 0, (size_t )bsize);
#line 1031
  make_bmp_info(pbmi, img, xdpi, ydpi);
#line 1032
  pbmi->biClrUsed = (DWORD )0;
#line 1033
  pbmi->biClrImportant = (DWORD )0;
#line 1035
  tmp___1 = malloc((size_t )img->raster);
#line 1035
  line2 = (BYTE *)tmp___1;
  }
#line 1036
  if ((unsigned long )line2 == (unsigned long )((BYTE *)((void *)0))) {
#line 1037
    return (-1);
  }
#line 1038
  pbmi->biWidth = (LONG )wx;
#line 1040
  if (topfirst) {
#line 1041
    line = img->image + img->raster * ((img->height - (unsigned int )devbbox.lly) - 1U);
  } else {
#line 1043
    line = img->image + img->raster * (unsigned int )devbbox.lly;
  }
  {
#line 1046
  write_word(mf->type, f);
#line 1047
  write_word(mf->headersize, f);
#line 1048
  write_word(mf->version, f);
#line 1049
  write_dword(mf->size, f);
#line 1050
  write_word(mf->nobj, f);
#line 1051
  write_dword(mf->maxrec, f);
#line 1052
  write_word(mf->noparam, f);
#line 1055
  write_dword((DWORD )5, f);
#line 1056
  write_word((WORD )523, f);
#line 1057
  write_word((WORD )0, f);
#line 1058
  write_word((WORD )0, f);
#line 1061
  write_dword((DWORD )5, f);
#line 1062
  write_word((WORD )524, f);
#line 1063
  write_word((WORD )wy, f);
#line 1064
  write_word((WORD )wx, f);
  }
  {
#line 1067
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1067
    if (! (wy > ny)) {
#line 1067
      goto while_break;
    }
    {
#line 1068
    pbmi->biHeight = (LONG )ny;
#line 1070
    size = (unsigned long )(40 + palcount * 4) + (unsigned long )bytewidth * (unsigned long )ny;
#line 1073
    write_dword(14UL + size / 2UL, f);
#line 1074
    write_word((WORD )3907, f);
#line 1075
    write_dword((DWORD )13369376L, f);
#line 1076
    write_word((WORD )0, f);
#line 1077
    write_word((WORD )ny, f);
#line 1078
    write_word((WORD )wx, f);
#line 1079
    write_word((WORD )0, f);
#line 1080
    write_word((WORD )0, f);
#line 1081
    write_word((WORD )ny, f);
#line 1082
    write_word((WORD )wx, f);
#line 1083
    write_word((WORD )(((devbbox.ury - devbbox.lly) - ny) - dy), f);
#line 1085
    write_word((WORD )0, f);
#line 1088
    write_bitmap_info(img, pbmi, f);
#line 1091
    i = 0;
    }
    {
#line 1091
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1091
      if (! (i < ny)) {
#line 1091
        goto while_break___0;
      }
#line 1092
      if (depth == 24) {
        {
#line 1093
        image_to_24BGR(img, line2, line);
        }
      } else {
        {
#line 1095
        memmove((void *)line2, (void const   *)line, (size_t )img->raster);
        }
      }
      {
#line 1096
      shift_preview(line2, (int )img->raster, bitoffset);
      }
#line 1097
      if (activewidth < bytewidth) {
        {
#line 1098
        memset((void *)(line2 + activewidth), 255, (size_t )(bytewidth - activewidth));
        }
      }
      {
#line 1099
      gfile_write(f, (void const   *)line2, (unsigned int )bytewidth);
      }
#line 1100
      if (topfirst) {
#line 1101
        line -= img->raster;
      } else {
#line 1103
        line += img->raster;
      }
#line 1091
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1067
    dy += ny;
#line 1067
    wy -= ny;
#line 1067
    sy += ny;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1109
  pbmi->biHeight = (LONG )wy;
#line 1110
  size = (unsigned long )(40 + palcount * 4) + (unsigned long )bytewidth * (unsigned long )wy;
#line 1112
  write_dword(14UL + size / 2UL, f);
#line 1113
  write_word((WORD )3907, f);
#line 1114
  write_dword((DWORD )13369376L, f);
#line 1115
  write_word((WORD )0, f);
#line 1116
  write_word((WORD )wy, f);
#line 1117
  write_word((WORD )wx, f);
#line 1118
  write_word((WORD )0, f);
#line 1119
  write_word((WORD )0, f);
#line 1120
  write_word((WORD )wy, f);
#line 1121
  write_word((WORD )wx, f);
#line 1122
  write_word((WORD )(((devbbox.ury - devbbox.lly) - wy) - dy), f);
#line 1123
  write_word((WORD )0, f);
#line 1126
  write_bitmap_info(img, pbmi, f);
#line 1129
  i = 0;
  }
  {
#line 1129
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1129
    if (! (i < wy)) {
#line 1129
      goto while_break___1;
    }
#line 1130
    if (depth == 24) {
      {
#line 1131
      image_to_24BGR(img, line2, line);
      }
    } else {
      {
#line 1133
      memmove((void *)line2, (void const   *)line, (size_t )img->raster);
      }
    }
    {
#line 1134
    shift_preview(line2, (int )img->raster, bitoffset);
    }
#line 1135
    if (activewidth < bytewidth) {
      {
#line 1136
      memset((void *)(line2 + activewidth), 255, (size_t )(bytewidth - activewidth));
      }
    }
    {
#line 1137
    gfile_write(f, (void const   *)line2, (unsigned int )bytewidth);
    }
#line 1138
    if (topfirst) {
#line 1139
      line -= img->raster;
    } else {
#line 1141
      line += img->raster;
    }
#line 1129
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 1145
  write_dword((DWORD )3, f);
#line 1146
  write_word((WORD )0, f);
#line 1148
  free((void *)((char *)pbmi));
#line 1149
  free((void *)line2);
  }
#line 1151
  return (0);
}
}
#line 1158 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/ceps.c"
void copy_nobbox(GFile *outfile , GFile *infile , unsigned long begin , unsigned long end ) 
{ 
  char bbox_str[15] ;
  char hiresbbox_str[20] ;
  char buf[256] ;
  int len ;
  unsigned long tmp ;
  size_t tmp___0 ;
  int tmp___1 ;
  size_t tmp___2 ;
  int tmp___3 ;

  {
  {
#line 1162
  bbox_str[0] = (char )'%';
#line 1162
  bbox_str[1] = (char )'%';
#line 1162
  bbox_str[2] = (char )'B';
#line 1162
  bbox_str[3] = (char )'o';
#line 1162
  bbox_str[4] = (char )'u';
#line 1162
  bbox_str[5] = (char )'n';
#line 1162
  bbox_str[6] = (char )'d';
#line 1162
  bbox_str[7] = (char )'i';
#line 1162
  bbox_str[8] = (char )'n';
#line 1162
  bbox_str[9] = (char )'g';
#line 1162
  bbox_str[10] = (char )'B';
#line 1162
  bbox_str[11] = (char )'o';
#line 1162
  bbox_str[12] = (char )'x';
#line 1162
  bbox_str[13] = (char )':';
#line 1162
  bbox_str[14] = (char )'\000';
#line 1163
  hiresbbox_str[0] = (char )'%';
#line 1163
  hiresbbox_str[1] = (char )'%';
#line 1163
  hiresbbox_str[2] = (char )'H';
#line 1163
  hiresbbox_str[3] = (char )'i';
#line 1163
  hiresbbox_str[4] = (char )'R';
#line 1163
  hiresbbox_str[5] = (char )'e';
#line 1163
  hiresbbox_str[6] = (char )'s';
#line 1163
  hiresbbox_str[7] = (char )'B';
#line 1163
  hiresbbox_str[8] = (char )'o';
#line 1163
  hiresbbox_str[9] = (char )'u';
#line 1163
  hiresbbox_str[10] = (char )'n';
#line 1163
  hiresbbox_str[11] = (char )'d';
#line 1163
  hiresbbox_str[12] = (char )'i';
#line 1163
  hiresbbox_str[13] = (char )'n';
#line 1163
  hiresbbox_str[14] = (char )'g';
#line 1163
  hiresbbox_str[15] = (char )'B';
#line 1163
  hiresbbox_str[16] = (char )'o';
#line 1163
  hiresbbox_str[17] = (char )'x';
#line 1163
  hiresbbox_str[18] = (char )':';
#line 1163
  hiresbbox_str[19] = (char )'\000';
#line 1166
  gfile_seek(infile, (long )begin, 0U);
#line 1167
  begin = gfile_get_position(infile);
  }
  {
#line 1168
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1168
    if (! (begin < end)) {
#line 1168
      goto while_break;
    }
#line 1169
    if (sizeof(buf) - 1UL < end - begin) {
#line 1169
      tmp = sizeof(buf) - 1UL;
    } else {
#line 1169
      tmp = end - begin;
    }
    {
#line 1169
    len = ps_fgets(buf, (int )tmp, infile);
#line 1170
    begin = gfile_get_position(infile);
    }
#line 1171
    if (len == 0) {
#line 1172
      return;
    } else {
      {
#line 1174
      tmp___2 = strlen((char const   *)(bbox_str));
#line 1174
      tmp___3 = strncmp((char const   *)(buf), (char const   *)(bbox_str), tmp___2);
      }
#line 1174
      if (! (tmp___3 == 0)) {
        {
#line 1177
        tmp___0 = strlen((char const   *)(hiresbbox_str));
#line 1177
        tmp___1 = strncmp((char const   *)(buf), (char const   *)(hiresbbox_str),
                          tmp___0);
        }
#line 1177
        if (! (tmp___1 == 0)) {
          {
#line 1181
          gfile_write(outfile, (void const   *)(buf), (unsigned int )len);
          }
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1183
  return;
}
}
#line 1188 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/ceps.c"
void copy_bbox_header(GFile *outfile , GFile *infile , unsigned long begin , unsigned long end ,
                      CDSCBBOX *bbox , CDSCFBBOX *hiresbbox ) 
{ 
  char buf[256] ;
  int len ;
  unsigned long tmp ;

  {
  {
#line 1196
  memset((void *)(buf), 0, sizeof(buf) - 1UL);
#line 1197
  gfile_seek(infile, (long )begin, 0U);
  }
#line 1198
  if (sizeof(buf) - 1UL < end - begin) {
#line 1198
    tmp = sizeof(buf) - 1UL;
  } else {
#line 1198
    tmp = end - begin;
  }
  {
#line 1198
  len = ps_fgets(buf, (int )tmp, infile);
  }
#line 1199
  if (len) {
    {
#line 1200
    gfile_write(outfile, (void const   *)(buf), (unsigned int )len);
    }
  }
#line 1202
  if (bbox) {
    {
#line 1203
    snprintf((char */* __restrict  */)(buf), sizeof(buf) - 1UL, (char const   */* __restrict  */)"%%%%BoundingBox: %d %d %d %d\n",
             bbox->llx, bbox->lly, bbox->urx, bbox->ury);
#line 1205
    gfile_puts(outfile, (char const   *)(buf));
    }
  }
#line 1207
  if (hiresbbox) {
    {
#line 1208
    snprintf((char */* __restrict  */)(buf), sizeof(buf) - 1UL, (char const   */* __restrict  */)"%%%%HiResBoundingBox: %.3f %.3f %.3f %.3f\n",
             (double )hiresbbox->fllx, (double )hiresbbox->flly, (double )hiresbbox->furx,
             (double )hiresbbox->fury);
#line 1211
    gfile_puts(outfile, (char const   *)(buf));
    }
  }
  {
#line 1214
  begin = gfile_get_position(infile);
#line 1215
  copy_nobbox(outfile, infile, begin, end);
  }
#line 1216
  return;
}
}
#line 1219 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/ceps.c"
static int without_eol(char const   *str , int length ) 
{ 
  int j ;

  {
#line 1223
  j = length - 1;
  {
#line 1223
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1223
    if (! (j >= 0)) {
#line 1223
      goto while_break;
    }
#line 1224
    if (! ((int const   )*(str + j) == 13)) {
#line 1224
      if (! ((int const   )*(str + j) == 10)) {
#line 1225
        j ++;
#line 1226
        goto while_break;
      }
    }
#line 1223
    j --;
  }
  while_break: /* CIL Label */ ;
  }
#line 1229
  if (j < 0) {
#line 1230
    j = 0;
  }
#line 1231
  return (j);
}
}
#line 1234 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/ceps.c"
static BOOL is_process_colour(char const   *name ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  {
#line 1236
  tmp = dsc_stricmp(name, "Cyan");
  }
#line 1236
  if (tmp == 0) {
#line 1236
    tmp___3 = 1;
  } else {
    {
#line 1236
    tmp___0 = dsc_stricmp(name, "Magenta");
    }
#line 1236
    if (tmp___0 == 0) {
#line 1236
      tmp___3 = 1;
    } else {
      {
#line 1236
      tmp___1 = dsc_stricmp(name, "Yellow");
      }
#line 1236
      if (tmp___1 == 0) {
#line 1236
        tmp___3 = 1;
      } else {
        {
#line 1236
        tmp___2 = dsc_stricmp(name, "Black");
        }
#line 1236
        if (tmp___2 == 0) {
#line 1236
          tmp___3 = 1;
        } else {
#line 1236
          tmp___3 = 0;
        }
      }
    }
  }
#line 1236
  return (tmp___3);
}
}
#line 1244 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/ceps.c"
static char const   process_str[25]  = 
#line 1244
  {      (char const   )'%',      (char const   )'%',      (char const   )'D',      (char const   )'o', 
        (char const   )'c',      (char const   )'u',      (char const   )'m',      (char const   )'e', 
        (char const   )'n',      (char const   )'t',      (char const   )'P',      (char const   )'r', 
        (char const   )'o',      (char const   )'c',      (char const   )'e',      (char const   )'s', 
        (char const   )'s',      (char const   )'C',      (char const   )'o',      (char const   )'l', 
        (char const   )'o',      (char const   )'r',      (char const   )'s',      (char const   )':', 
        (char const   )'\000'};
#line 1245 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/ceps.c"
static char const   custom_str[24]  = 
#line 1245
  {      (char const   )'%',      (char const   )'%',      (char const   )'D',      (char const   )'o', 
        (char const   )'c',      (char const   )'u',      (char const   )'m',      (char const   )'e', 
        (char const   )'n',      (char const   )'t',      (char const   )'C',      (char const   )'u', 
        (char const   )'s',      (char const   )'t',      (char const   )'o',      (char const   )'m', 
        (char const   )'C',      (char const   )'o',      (char const   )'l',      (char const   )'o', 
        (char const   )'r',      (char const   )'s',      (char const   )':',      (char const   )'\000'};
#line 1246 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/ceps.c"
static char const   cmyk_custom_str[19]  = 
#line 1246
  {      (char const   )'%',      (char const   )'%',      (char const   )'C',      (char const   )'M', 
        (char const   )'Y',      (char const   )'K',      (char const   )'C',      (char const   )'u', 
        (char const   )'s',      (char const   )'t',      (char const   )'o',      (char const   )'m', 
        (char const   )'C',      (char const   )'o',      (char const   )'l',      (char const   )'o', 
        (char const   )'r',      (char const   )':',      (char const   )'\000'};
#line 1247 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/ceps.c"
static char const   rgb_custom_str[18]  = 
#line 1247
  {      (char const   )'%',      (char const   )'%',      (char const   )'R',      (char const   )'G', 
        (char const   )'B',      (char const   )'C',      (char const   )'u',      (char const   )'s', 
        (char const   )'t',      (char const   )'o',      (char const   )'m',      (char const   )'C', 
        (char const   )'o',      (char const   )'l',      (char const   )'o',      (char const   )'r', 
        (char const   )':',      (char const   )'\000'};
#line 1248 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/ceps.c"
static char const   eol_str[2]  = {      (char const   )'\n',      (char const   )'\000'};
#line 1250 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/ceps.c"
static char const   *separation_name(RENAME_SEPARATION *rs , char const   *name ) 
{ 
  RENAME_SEPARATION *s ;
  char const   *newname ;
  int tmp ;

  {
#line 1254
  newname = name;
#line 1255
  s = rs;
  {
#line 1255
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1255
    if (! s) {
#line 1255
      goto while_break;
    }
    {
#line 1256
    tmp = strcmp((char const   *)s->oldname, name);
    }
#line 1256
    if (tmp == 0) {
#line 1257
      newname = (char const   *)s->newname;
#line 1258
      goto while_break;
    }
#line 1255
    s = s->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 1261
  return (newname);
}
}
#line 1269 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/ceps.c"
int rename_separations(CDSC *dsc , RENAME_SEPARATION *rs , char const   **renamed ) 
{ 
  int duplicated ;
  int i ;
  int j ;
  char const   *sepname ;
  int tmp ;
  int tmp___0 ;

  {
#line 1272
  duplicated = 0;
#line 1275
  *(renamed + 0) = (dsc->page + 0)->label;
#line 1276
  i = 1;
  {
#line 1276
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1276
    if (! (i < (int )dsc->page_count)) {
#line 1276
      goto while_break;
    }
    {
#line 1277
    sepname = separation_name(rs, (dsc->page + i)->label);
#line 1281
    j = 1;
    }
    {
#line 1281
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1281
      if (! (j < i)) {
#line 1281
        goto while_break___0;
      }
      {
#line 1282
      tmp = strcmp((dsc->page + j)->label, (dsc->page + i)->label);
      }
#line 1282
      if (tmp == 0) {
#line 1283
        sepname = (char const   *)((void *)0);
#line 1284
        duplicated = 1;
      }
#line 1281
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1288
    if (sepname) {
#line 1289
      j = 1;
      {
#line 1289
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 1289
        if (! (j < i)) {
#line 1289
          goto while_break___1;
        }
        {
#line 1290
        tmp___0 = strcmp(*(renamed + j), sepname);
        }
#line 1290
        if (tmp___0 == 0) {
#line 1291
          sepname = (char const   *)((void *)0);
#line 1292
          duplicated = 1;
#line 1293
          goto while_break___1;
        }
#line 1289
        j ++;
      }
      while_break___1: /* CIL Label */ ;
      }
    }
#line 1297
    if ((unsigned long )sepname == (unsigned long )((void *)0)) {
#line 1298
      sepname = (dsc->page + i)->label;
    }
#line 1299
    *(renamed + i) = sepname;
#line 1276
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1301
  if (duplicated) {
#line 1302
    return (-1);
  }
#line 1303
  return (0);
}
}
#line 1307 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/ceps.c"
static int dcs2_separation(CDSC *dsc , int pagenum , char const   **fname , unsigned long *pbegin ,
                           unsigned long *pend ) 
{ 
  GFile *f ;
  char wfname[256] ;
  size_t tmp ;
  unsigned long tmp___0 ;

  {
  {
#line 1313
  *fname = dsc_find_platefile(dsc, pagenum);
  }
#line 1314
  if (*fname) {
    {
#line 1315
    tmp = strlen(*fname);
#line 1315
    narrow_to_cs(wfname, (int )sizeof(wfname), *fname, (int )tmp + 1);
#line 1317
    f = gfile_open((char const   *)(wfname), 0U);
    }
#line 1317
    if ((unsigned long )f != (unsigned long )((GFile *)((void *)0))) {
      {
#line 1318
      *pbegin = 0UL;
#line 1319
      *pend = gfile_get_length(f);
#line 1320
      gfile_close(f);
      }
    } else {
#line 1324
      tmp___0 = 0UL;
#line 1324
      *pend = tmp___0;
#line 1324
      *pbegin = tmp___0;
#line 1325
      return (1);
    }
  } else {
#line 1329
    *pbegin = (dsc->page + pagenum)->begin;
#line 1330
    *pend = (dsc->page + pagenum)->end;
  }
#line 1332
  return (0);
}
}
#line 1336 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/ceps.c"
static int fix_custom(Doc *doc , char *buf , int buflen , char const   **renamed ) 
{ 
  CDSC *dsc ;
  int i ;
  int missing ;
  int n ;
  unsigned long begin ;
  unsigned long end ;
  char const   *fname ;
  int count ;
  size_t tmp___0 ;
  int tmp___1 ;
  size_t tmp___2 ;
  char const   *sepname ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  size_t tmp___5 ;
  BOOL tmp___6 ;

  {
  {
#line 1342
  dsc = doc->dsc;
#line 1345
  n = 0;
#line 1348
  tmp___2 = strlen((char const   *)buf);
  }
#line 1348
  if ((int )tmp___2 < buflen) {
    {
#line 1348
    tmp___0 = strlen((char const   *)buf);
#line 1348
    tmp___1 = (int )tmp___0;
    }
  } else {
#line 1348
    tmp___1 = buflen;
  }
#line 1348
  count = tmp___1;
#line 1349
  if ((unsigned long )dsc == (unsigned long )((void *)0)) {
#line 1350
    return (0);
  } else
#line 1349
  if (! dsc->dcs2) {
#line 1350
    return (0);
  }
#line 1351
  i = 1;
  {
#line 1351
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1351
    if (! (i < (int )dsc->page_count)) {
#line 1351
      goto while_break;
    }
    {
#line 1352
    sepname = *(renamed + i);
#line 1353
    missing = dcs2_separation(dsc, i, & fname, & begin, & end);
    }
#line 1354
    if (! missing) {
      {
#line 1354
      tmp___6 = is_process_colour(sepname);
      }
#line 1354
      if (! tmp___6) {
        {
#line 1355
        n ++;
#line 1356
        strncpy((char */* __restrict  */)(buf + count), (char const   */* __restrict  */)" (",
                (size_t )((buflen - count) - 1));
#line 1357
        tmp___3 = strlen((char const   *)buf);
#line 1357
        count = (int )tmp___3;
#line 1358
        strncpy((char */* __restrict  */)(buf + count), (char const   */* __restrict  */)sepname,
                (size_t )((buflen - count) - 1));
#line 1359
        tmp___4 = strlen((char const   *)buf);
#line 1359
        count = (int )tmp___4;
#line 1360
        strncpy((char */* __restrict  */)(buf + count), (char const   */* __restrict  */)")",
                (size_t )((buflen - count) - 1));
#line 1361
        tmp___5 = strlen((char const   *)buf);
#line 1361
        count = (int )tmp___5;
        }
      }
    }
#line 1351
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1364
  return (n);
}
}
#line 1367 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/ceps.c"
static int fix_process(Doc *doc , char *buf , int buflen , char const   **renamed ) 
{ 
  CDSC *dsc ;
  int i ;
  int n ;
  int missing ;
  unsigned long begin ;
  unsigned long end ;
  char const   *fname ;
  int count ;
  size_t tmp___0 ;
  int tmp___1 ;
  size_t tmp___2 ;
  char const   *sepname ;
  size_t tmp___3 ;
  BOOL tmp___4 ;

  {
  {
#line 1373
  dsc = doc->dsc;
#line 1375
  n = 0;
#line 1379
  tmp___2 = strlen((char const   *)buf);
  }
#line 1379
  if ((int )tmp___2 < buflen) {
    {
#line 1379
    tmp___0 = strlen((char const   *)buf);
#line 1379
    tmp___1 = (int )tmp___0;
    }
  } else {
#line 1379
    tmp___1 = buflen;
  }
#line 1379
  count = tmp___1;
#line 1380
  if ((unsigned long )dsc == (unsigned long )((void *)0)) {
#line 1381
    return (0);
  } else
#line 1380
  if (! dsc->dcs2) {
#line 1381
    return (0);
  }
#line 1382
  i = 1;
  {
#line 1382
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1382
    if (! (i < (int )dsc->page_count)) {
#line 1382
      goto while_break;
    }
    {
#line 1383
    sepname = *(renamed + i);
#line 1384
    missing = dcs2_separation(dsc, i, & fname, & begin, & end);
    }
#line 1385
    if (! missing) {
      {
#line 1385
      tmp___4 = is_process_colour(sepname);
      }
#line 1385
      if (tmp___4) {
        {
#line 1386
        n ++;
#line 1387
        strncpy((char */* __restrict  */)(buf + count), (char const   */* __restrict  */)" ",
                (size_t )((buflen - count) - 1));
#line 1388
        count ++;
#line 1389
        strncpy((char */* __restrict  */)(buf + count), (char const   */* __restrict  */)sepname,
                (size_t )((buflen - count) - 1));
#line 1390
        tmp___3 = strlen((char const   *)buf);
#line 1390
        count = (int )tmp___3;
        }
      }
    }
#line 1382
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1393
  return (n);
}
}
#line 1399 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/ceps.c"
static int write_cmyk_custom(GFile *gf , Doc *doc , char const   **renamed , int count ) 
{ 
  CDSC *dsc ;
  CDSCCOLOUR *colour ;
  int i ;
  int missing ;
  int n ;
  unsigned long begin ;
  unsigned long end ;
  char const   *fname ;
  char buf[256] ;
  char const   *sepname ;
  int tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  BOOL tmp___2 ;

  {
#line 1405
  dsc = doc->dsc;
#line 1409
  n = count;
#line 1413
  if ((unsigned long )dsc == (unsigned long )((void *)0)) {
#line 1414
    return (0);
  } else
#line 1413
  if (! dsc->dcs2) {
#line 1414
    return (0);
  }
#line 1415
  buf[sizeof(buf) - 1UL] = (char )'\000';
#line 1416
  i = 1;
  {
#line 1416
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1416
    if (! (i < (int )dsc->page_count)) {
#line 1416
      goto while_break;
    }
    {
#line 1417
    sepname = *(renamed + i);
#line 1418
    missing = dcs2_separation(dsc, i, & fname, & begin, & end);
    }
#line 1419
    if (! missing) {
      {
#line 1419
      tmp___2 = is_process_colour(sepname);
      }
#line 1419
      if (! tmp___2) {
#line 1421
        colour = dsc->colours;
        {
#line 1421
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 1421
          if (! colour) {
#line 1421
            goto while_break___0;
          }
          {
#line 1422
          tmp = strcmp((char const   *)colour->name, (dsc->page + i)->label);
          }
#line 1422
          if (tmp == 0) {
#line 1423
            goto while_break___0;
          }
#line 1421
          colour = colour->next;
        }
        while_break___0: /* CIL Label */ ;
        }
#line 1425
        if ((unsigned long )colour != (unsigned long )((void *)0)) {
#line 1425
          if ((unsigned int )colour->custom == 2U) {
#line 1427
            if (n == 0) {
              {
#line 1428
              strncpy((char */* __restrict  */)(buf), (char const   */* __restrict  */)(cmyk_custom_str),
                      sizeof(buf) - 1UL);
              }
            } else {
              {
#line 1430
              strncpy((char */* __restrict  */)(buf), (char const   */* __restrict  */)"%%+",
                      sizeof(buf) - 1UL);
              }
            }
            {
#line 1431
            tmp___0 = strlen((char const   *)(buf));
#line 1431
            tmp___1 = strlen((char const   *)(buf));
#line 1431
            snprintf((char */* __restrict  */)(buf + tmp___1), (sizeof(buf) - 1UL) - tmp___0,
                     (char const   */* __restrict  */)" %g %g %g %g (%s)", (double )colour->cyan,
                     (double )colour->magenta, (double )colour->yellow, (double )colour->black,
                     sepname);
#line 1435
            gfile_puts(gf, (char const   *)(buf));
#line 1436
            gfile_puts(gf, eol_str);
#line 1437
            n ++;
            }
          }
        }
      }
    }
#line 1416
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1441
  return (n);
}
}
#line 1447 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/ceps.c"
static int write_rgb_custom(GFile *gf , Doc *doc , char const   **renamed , int count ) 
{ 
  CDSC *dsc ;
  CDSCCOLOUR *colour ;
  int i ;
  int missing ;
  int n ;
  unsigned long begin ;
  unsigned long end ;
  char const   *fname ;
  char buf[256] ;
  char const   *sepname ;
  int tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  BOOL tmp___2 ;

  {
#line 1453
  dsc = doc->dsc;
#line 1457
  n = count;
#line 1461
  if ((unsigned long )dsc == (unsigned long )((void *)0)) {
#line 1462
    return (0);
  } else
#line 1461
  if (! dsc->dcs2) {
#line 1462
    return (0);
  }
#line 1463
  buf[sizeof(buf) - 1UL] = (char )'\000';
#line 1464
  i = 1;
  {
#line 1464
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1464
    if (! (i < (int )dsc->page_count)) {
#line 1464
      goto while_break;
    }
    {
#line 1465
    sepname = *(renamed + i);
#line 1466
    missing = dcs2_separation(dsc, i, & fname, & begin, & end);
    }
#line 1467
    if (! missing) {
      {
#line 1467
      tmp___2 = is_process_colour(sepname);
      }
#line 1467
      if (! tmp___2) {
#line 1469
        colour = dsc->colours;
        {
#line 1469
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 1469
          if (! colour) {
#line 1469
            goto while_break___0;
          }
          {
#line 1470
          tmp = strcmp((char const   *)colour->name, (dsc->page + i)->label);
          }
#line 1470
          if (tmp == 0) {
#line 1471
            goto while_break___0;
          }
#line 1469
          colour = colour->next;
        }
        while_break___0: /* CIL Label */ ;
        }
#line 1473
        if ((unsigned long )colour != (unsigned long )((void *)0)) {
#line 1473
          if ((unsigned int )colour->custom == 1U) {
#line 1475
            if (n == 0) {
              {
#line 1476
              strncpy((char */* __restrict  */)(buf), (char const   */* __restrict  */)(cmyk_custom_str),
                      sizeof(buf) - 1UL);
              }
            } else {
              {
#line 1478
              strncpy((char */* __restrict  */)(buf), (char const   */* __restrict  */)"%%+",
                      sizeof(buf) - 1UL);
              }
            }
            {
#line 1479
            tmp___0 = strlen((char const   *)(buf));
#line 1479
            tmp___1 = strlen((char const   *)(buf));
#line 1479
            snprintf((char */* __restrict  */)(buf + tmp___1), (sizeof(buf) - 1UL) - tmp___0,
                     (char const   */* __restrict  */)" %g %g %g (%s)", (double )colour->red,
                     (double )colour->green, (double )colour->blue, sepname);
#line 1483
            gfile_puts(gf, (char const   *)(buf));
#line 1484
            gfile_puts(gf, eol_str);
#line 1485
            n ++;
            }
          }
        }
      }
    }
#line 1464
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1489
  return (n);
}
}
#line 1493 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/ceps.c"
static unsigned long write_platefile_comments(Doc *doc , GFile *docfile , GFile *epsfile ,
                                              char const   *epsname , int offset ,
                                              unsigned long file_offset , BOOL dcs2_multi ,
                                              BOOL write_all , BOOL missing_separations ,
                                              char const   **renamed , BOOL some_renamed ) 
{ 
  int i ;
  CDSC *dsc ;
  unsigned long begin ;
  unsigned long end ;
  unsigned long len ;
  char platename[256] ;
  char outbuf[256] ;
  GFile *f ;
  unsigned long offset2 ;
  int missing ;
  char const   *fname ;
  char const   *sepname ;
  int j ;
  int duplicate ;
  size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  char wfname[256] ;
  GFile *pf ;
  size_t tmp___5 ;
  char const   *fname___0 ;
  char const   *tmp___6 ;
  size_t tmp___7 ;
  char fmtbuf[256] ;

  {
#line 1501
  dsc = doc->dsc;
#line 1507
  offset2 = 0UL;
#line 1510
  i = 1;
  {
#line 1510
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1510
    if (! (i < (int )dsc->page_count)) {
#line 1510
      goto while_break;
    }
    {
#line 1513
    fname = (char const   *)((void *)0);
#line 1514
    sepname = *(renamed + i);
#line 1515
    missing = dcs2_separation(dsc, i, & fname, & begin, & end);
#line 1516
    len = end - begin;
    }
#line 1518
    if (missing) {
#line 1518
      if (missing_separations) {
#line 1518
        goto _L___0;
      } else
#line 1518
      if (some_renamed) {
        _L___0: /* CIL Label */ 
#line 1519
        if (debug & 1) {
          {
#line 1520
          app_msgf(doc->app, "Skipping missing separation page %d \"%s\"\n", i, (dsc->page + i)->label);
          }
        }
      } else {
#line 1518
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 1524
    if (dcs2_multi) {
      {
#line 1526
      duplicate = 0;
#line 1527
      memset((void *)(platename), 0, sizeof(platename));
#line 1528
      tmp = strlen(epsname);
#line 1528
      cs_to_narrow(platename, (int )(sizeof(platename) - 1UL), epsname, (int )tmp + 1);
#line 1530
      tmp___0 = strlen((char const   *)(platename));
#line 1530
      strncat((char */* __restrict  */)(platename), (char const   */* __restrict  */)".",
              sizeof(platename) - tmp___0);
#line 1531
      tmp___1 = strlen((char const   *)(platename));
#line 1531
      strncat((char */* __restrict  */)(platename), (char const   */* __restrict  */)sepname,
              sizeof(platename) - tmp___1);
#line 1532
      j = 1;
      }
      {
#line 1532
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1532
        if (! (j < i)) {
#line 1532
          goto while_break___0;
        }
        {
#line 1534
        tmp___2 = strcmp(sepname, *(renamed + j));
        }
#line 1534
        if (tmp___2 == 0) {
#line 1535
          duplicate = 1;
        }
#line 1532
        j ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 1537
      if (duplicate) {
        {
#line 1538
        tmp___3 = strlen((char const   *)(platename));
#line 1538
        tmp___4 = strlen((char const   *)(platename));
#line 1538
        snprintf((char */* __restrict  */)(platename + tmp___4), sizeof(platename) - tmp___3,
                 (char const   */* __restrict  */)".%d", i);
        }
      }
      {
#line 1541
      snprintf((char */* __restrict  */)(outbuf), sizeof(outbuf) - 1UL, (char const   */* __restrict  */)"%%%%PlateFile: (%s) EPS Local %s",
               sepname, platename);
#line 1544
      gfile_puts(epsfile, (char const   *)(outbuf));
#line 1545
      gfile_puts(epsfile, eol_str);
      }
#line 1546
      if (write_all) {
        {
#line 1550
        tmp___5 = strlen((char const   *)(platename));
#line 1550
        narrow_to_cs(wfname, (int )sizeof(wfname), (char const   *)(platename), (int )tmp___5 + 1);
#line 1552
        pf = gfile_open((char const   *)(wfname), 4097U);
        }
#line 1553
        if ((unsigned long )pf != (unsigned long )((GFile *)((void *)0))) {
          {
#line 1554
          tmp___6 = dsc_find_platefile(dsc, i);
#line 1554
          fname___0 = tmp___6;
          }
#line 1555
          if (fname___0) {
            {
#line 1556
            tmp___7 = strlen(fname___0);
#line 1556
            narrow_to_cs(wfname, (int )sizeof(wfname), fname___0, (int )tmp___7 + 1);
#line 1558
            f = gfile_open((char const   *)(wfname), 0U);
            }
#line 1558
            if ((unsigned long )f != (unsigned long )((GFile *)((void *)0))) {
              {
#line 1560
              ps_copy(pf, f, (long )begin, (long )end);
#line 1561
              gfile_close(f);
              }
            }
          } else {
            {
#line 1565
            ps_copy(pf, docfile, (long )begin, (long )end);
            }
          }
          {
#line 1567
          gfile_close(pf);
          }
        } else {
#line 1570
          return (0xffffffffffffffffUL);
        }
      }
    } else {
      {
#line 1576
      snprintf((char */* __restrict  */)(fmtbuf), sizeof(fmtbuf) - 1UL, (char const   */* __restrict  */)"%%%%%%%%PlateFile: (%%s) EPS #%%010%s %%010%s",
               "lu", "lu");
#line 1579
      snprintf((char */* __restrict  */)(outbuf), sizeof(outbuf) - 1UL, (char const   */* __restrict  */)(fmtbuf),
               sepname, ((unsigned long )offset + file_offset) + offset2, len);
#line 1581
      gfile_puts(epsfile, (char const   *)(outbuf));
#line 1582
      gfile_puts(epsfile, eol_str);
#line 1583
      offset2 += len;
      }
    }
#line 1510
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1586
  return (offset2);
}
}
#line 1590 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/ceps.c"
static unsigned long write_singlefile_separations(Doc *doc , GFile *docfile , GFile *epsfile ,
                                                  BOOL dcs2_multi , BOOL write_all ,
                                                  BOOL missing_separations , BOOL some_renamed ) 
{ 
  int i ;
  CDSC *dsc ;
  unsigned long begin ;
  unsigned long end ;
  unsigned long len ;
  GFile *f ;
  int missing ;
  char const   *fname ;
  char wfname[256] ;
  size_t tmp ;

  {
#line 1597
  dsc = doc->dsc;
#line 1601
  if (write_all) {
#line 1601
    if (! dcs2_multi) {
#line 1602
      i = 1;
      {
#line 1602
      while (1) {
        while_continue: /* CIL Label */ ;
#line 1602
        if (! (i < (int )dsc->page_count)) {
#line 1602
          goto while_break;
        }
        {
#line 1604
        fname = (char const   *)((void *)0);
#line 1605
        missing = dcs2_separation(dsc, i, & fname, & begin, & end);
#line 1606
        len = end - begin;
        }
#line 1607
        if (missing) {
#line 1607
          if (missing_separations) {
#line 1607
            goto _L___0;
          } else
#line 1607
          if (some_renamed) {
            _L___0: /* CIL Label */ 
#line 1608
            if (debug & 1) {
              {
#line 1609
              app_msgf(doc->app, "Skipping missing separation page %d \"%s\"\n", i,
                       (dsc->page + i)->label);
              }
            }
          } else {
#line 1607
            goto _L;
          }
        } else
        _L: /* CIL Label */ 
#line 1613
        if (fname) {
          {
#line 1615
          tmp = strlen(fname);
#line 1615
          narrow_to_cs(wfname, (int )sizeof(wfname), fname, (int )tmp + 1);
#line 1617
          f = gfile_open((char const   *)(wfname), 0U);
          }
#line 1617
          if ((unsigned long )f != (unsigned long )((GFile *)((void *)0))) {
            {
#line 1618
            begin = 0UL;
#line 1619
            end = gfile_get_length(f);
            }
#line 1620
            if (debug & 1) {
              {
#line 1621
              app_msgf(doc->app, "Copying page %d from \"%s\"  %ld %ld\n", i, fname,
                       begin, end);
              }
            }
            {
#line 1624
            ps_copy(epsfile, f, (long )begin, (long )end);
#line 1625
            gfile_close(f);
            }
          }
        } else {
#line 1629
          begin = (dsc->page + i)->begin;
#line 1630
          end = (dsc->page + i)->end;
#line 1631
          if (debug & 1) {
            {
#line 1632
            app_msgf(doc->app, "Copying page %d  %ld %ld\n", i, fname, begin, end);
            }
          }
          {
#line 1635
          ps_copy(epsfile, docfile, (long )begin, (long )end);
          }
        }
#line 1602
        i ++;
      }
      while_break: /* CIL Label */ ;
      }
    }
  }
#line 1639
  return (0UL);
}
}
#line 1643 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/ceps.c"
static int check_dcs2_combine(Doc *doc1 , Doc *doc2 , char const   **renamed1 , char const   **renamed2 ,
                              int tolerance ) 
{ 
  CDSC *dsc1 ;
  CDSC *dsc2 ;
  char const   *sepname1 ;
  char const   *sepname2 ;
  int i ;
  int j ;
  int tmp ;

  {
#line 1653
  if ((unsigned long )doc1 == (unsigned long )((void *)0)) {
#line 1654
    return (-1);
  }
#line 1655
  if ((unsigned long )doc2 == (unsigned long )((void *)0)) {
#line 1656
    return (-1);
  }
#line 1657
  dsc1 = doc1->dsc;
#line 1658
  dsc2 = doc2->dsc;
#line 1659
  if (! dsc1->dcs2) {
#line 1660
    return (-1);
  }
#line 1661
  if (! dsc2->dcs2) {
#line 1662
    return (-1);
  }
#line 1663
  if ((unsigned long )dsc1->bbox == (unsigned long )((void *)0)) {
#line 1664
    return (-1);
  }
#line 1665
  if ((unsigned long )dsc2->bbox == (unsigned long )((void *)0)) {
#line 1666
    return (-1);
  }
#line 1668
  if ((dsc1->bbox)->llx > (dsc2->bbox)->llx + tolerance) {
    {
#line 1676
    app_msgf(doc1->app, "Bounding Boxes don\'t match\n");
    }
#line 1677
    return (-1);
  } else
#line 1668
  if ((dsc1->bbox)->llx < (dsc2->bbox)->llx - tolerance) {
    {
#line 1676
    app_msgf(doc1->app, "Bounding Boxes don\'t match\n");
    }
#line 1677
    return (-1);
  } else
#line 1668
  if ((dsc1->bbox)->lly > (dsc2->bbox)->lly + tolerance) {
    {
#line 1676
    app_msgf(doc1->app, "Bounding Boxes don\'t match\n");
    }
#line 1677
    return (-1);
  } else
#line 1668
  if ((dsc1->bbox)->lly < (dsc2->bbox)->lly - tolerance) {
    {
#line 1676
    app_msgf(doc1->app, "Bounding Boxes don\'t match\n");
    }
#line 1677
    return (-1);
  } else
#line 1668
  if ((dsc1->bbox)->urx > (dsc2->bbox)->urx + tolerance) {
    {
#line 1676
    app_msgf(doc1->app, "Bounding Boxes don\'t match\n");
    }
#line 1677
    return (-1);
  } else
#line 1668
  if ((dsc1->bbox)->urx < (dsc2->bbox)->urx - tolerance) {
    {
#line 1676
    app_msgf(doc1->app, "Bounding Boxes don\'t match\n");
    }
#line 1677
    return (-1);
  } else
#line 1668
  if ((dsc1->bbox)->ury > (dsc2->bbox)->ury + tolerance) {
    {
#line 1676
    app_msgf(doc1->app, "Bounding Boxes don\'t match\n");
    }
#line 1677
    return (-1);
  } else
#line 1668
  if ((dsc1->bbox)->ury < (dsc2->bbox)->ury - tolerance) {
    {
#line 1676
    app_msgf(doc1->app, "Bounding Boxes don\'t match\n");
    }
#line 1677
    return (-1);
  }
#line 1680
  i = 1;
  {
#line 1680
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1680
    if (! (i < (int )dsc1->page_count)) {
#line 1680
      goto while_break;
    }
#line 1681
    sepname1 = *(renamed1 + i);
#line 1682
    j = 1;
    {
#line 1682
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1682
      if (! (i < (int )dsc2->page_count)) {
#line 1682
        goto while_break___0;
      }
      {
#line 1683
      sepname2 = *(renamed2 + j);
#line 1684
      tmp = strcmp(sepname1, sepname2);
      }
#line 1684
      if (tmp == 0) {
        {
#line 1685
        app_msgf(doc1->app, "Separation \"%s\" appears in both files\n", sepname1);
        }
#line 1688
        return (-1);
      }
#line 1682
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1680
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1692
  return (0);
}
}
#line 1712 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/ceps.c"
int copy_dcs2(Doc *doc , GFile *docfile , Doc *doc2 , GFile *docfile2 , GFile *epsfile ,
              char const   *epsname , int offset , BOOL dcs2_multi , BOOL write_all ,
              BOOL missing_separations , unsigned long *complen , GFile *composite ,
              RENAME_SEPARATION *rs , int tolerance ) 
{ 
  char platefile_str[13] ;
  char cyanplate_str[13] ;
  char magentaplate_str[16] ;
  char yellowplate_str[15] ;
  char blackplate_str[14] ;
  char endcomments_str[14] ;
  char buf[256] ;
  char outbuf[256] ;
  CDSC *dsc ;
  unsigned long len ;
  unsigned long file_offset ;
  unsigned long begin ;
  unsigned long end ;
  unsigned long header_position ;
  BOOL found_endheader ;
  BOOL ignore_continuation ;
  int count ;
  char const   **renamed1 ;
  char const   **renamed2 ;
  void *tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  unsigned long tmp___4 ;
  int tmp___5 ;
  size_t tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  size_t tmp___9 ;
  int tmp___10 ;
  size_t tmp___11 ;
  int tmp___12 ;
  size_t tmp___13 ;
  int tmp___14 ;
  size_t tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  size_t tmp___18 ;
  int tmp___19 ;
  size_t tmp___20 ;
  int tmp___21 ;
  size_t tmp___22 ;
  int tmp___23 ;
  size_t tmp___24 ;
  int tmp___25 ;
  size_t tmp___26 ;
  int tmp___27 ;
  unsigned long tmp___28 ;
  int n ;
  int tmp___29 ;
  size_t tmp___30 ;
  int tmp___31 ;
  int tmp___32 ;
  size_t tmp___33 ;
  int tmp___34 ;
  int tmp___35 ;

  {
#line 1720
  platefile_str[0] = (char )'%';
#line 1720
  platefile_str[1] = (char )'%';
#line 1720
  platefile_str[2] = (char )'P';
#line 1720
  platefile_str[3] = (char )'l';
#line 1720
  platefile_str[4] = (char )'a';
#line 1720
  platefile_str[5] = (char )'t';
#line 1720
  platefile_str[6] = (char )'e';
#line 1720
  platefile_str[7] = (char )'F';
#line 1720
  platefile_str[8] = (char )'i';
#line 1720
  platefile_str[9] = (char )'l';
#line 1720
  platefile_str[10] = (char )'e';
#line 1720
  platefile_str[11] = (char )':';
#line 1720
  platefile_str[12] = (char )'\000';
#line 1721
  cyanplate_str[0] = (char )'%';
#line 1721
  cyanplate_str[1] = (char )'%';
#line 1721
  cyanplate_str[2] = (char )'C';
#line 1721
  cyanplate_str[3] = (char )'y';
#line 1721
  cyanplate_str[4] = (char )'a';
#line 1721
  cyanplate_str[5] = (char )'n';
#line 1721
  cyanplate_str[6] = (char )'P';
#line 1721
  cyanplate_str[7] = (char )'l';
#line 1721
  cyanplate_str[8] = (char )'a';
#line 1721
  cyanplate_str[9] = (char )'t';
#line 1721
  cyanplate_str[10] = (char )'e';
#line 1721
  cyanplate_str[11] = (char )':';
#line 1721
  cyanplate_str[12] = (char )'\000';
#line 1722
  magentaplate_str[0] = (char )'%';
#line 1722
  magentaplate_str[1] = (char )'%';
#line 1722
  magentaplate_str[2] = (char )'M';
#line 1722
  magentaplate_str[3] = (char )'a';
#line 1722
  magentaplate_str[4] = (char )'g';
#line 1722
  magentaplate_str[5] = (char )'e';
#line 1722
  magentaplate_str[6] = (char )'n';
#line 1722
  magentaplate_str[7] = (char )'t';
#line 1722
  magentaplate_str[8] = (char )'a';
#line 1722
  magentaplate_str[9] = (char )'P';
#line 1722
  magentaplate_str[10] = (char )'l';
#line 1722
  magentaplate_str[11] = (char )'a';
#line 1722
  magentaplate_str[12] = (char )'t';
#line 1722
  magentaplate_str[13] = (char )'e';
#line 1722
  magentaplate_str[14] = (char )':';
#line 1722
  magentaplate_str[15] = (char )'\000';
#line 1723
  yellowplate_str[0] = (char )'%';
#line 1723
  yellowplate_str[1] = (char )'%';
#line 1723
  yellowplate_str[2] = (char )'Y';
#line 1723
  yellowplate_str[3] = (char )'e';
#line 1723
  yellowplate_str[4] = (char )'l';
#line 1723
  yellowplate_str[5] = (char )'l';
#line 1723
  yellowplate_str[6] = (char )'o';
#line 1723
  yellowplate_str[7] = (char )'w';
#line 1723
  yellowplate_str[8] = (char )'P';
#line 1723
  yellowplate_str[9] = (char )'l';
#line 1723
  yellowplate_str[10] = (char )'a';
#line 1723
  yellowplate_str[11] = (char )'t';
#line 1723
  yellowplate_str[12] = (char )'e';
#line 1723
  yellowplate_str[13] = (char )':';
#line 1723
  yellowplate_str[14] = (char )'\000';
#line 1724
  blackplate_str[0] = (char )'%';
#line 1724
  blackplate_str[1] = (char )'%';
#line 1724
  blackplate_str[2] = (char )'B';
#line 1724
  blackplate_str[3] = (char )'l';
#line 1724
  blackplate_str[4] = (char )'a';
#line 1724
  blackplate_str[5] = (char )'c';
#line 1724
  blackplate_str[6] = (char )'k';
#line 1724
  blackplate_str[7] = (char )'P';
#line 1724
  blackplate_str[8] = (char )'l';
#line 1724
  blackplate_str[9] = (char )'a';
#line 1724
  blackplate_str[10] = (char )'t';
#line 1724
  blackplate_str[11] = (char )'e';
#line 1724
  blackplate_str[12] = (char )':';
#line 1724
  blackplate_str[13] = (char )'\000';
#line 1725
  endcomments_str[0] = (char )'%';
#line 1725
  endcomments_str[1] = (char )'%';
#line 1725
  endcomments_str[2] = (char )'E';
#line 1725
  endcomments_str[3] = (char )'n';
#line 1725
  endcomments_str[4] = (char )'d';
#line 1725
  endcomments_str[5] = (char )'C';
#line 1725
  endcomments_str[6] = (char )'o';
#line 1725
  endcomments_str[7] = (char )'m';
#line 1725
  endcomments_str[8] = (char )'m';
#line 1725
  endcomments_str[9] = (char )'e';
#line 1725
  endcomments_str[10] = (char )'n';
#line 1725
  endcomments_str[11] = (char )'t';
#line 1725
  endcomments_str[12] = (char )'s';
#line 1725
  endcomments_str[13] = (char )'\000';
#line 1728
  dsc = doc->dsc;
#line 1730
  file_offset = *complen;
#line 1733
  found_endheader = 0;
#line 1734
  ignore_continuation = 0;
#line 1736
  renamed1 = (char const   **)((void *)0);
#line 1737
  renamed2 = (char const   **)((void *)0);
#line 1739
  if (dsc->page_count == 0U) {
#line 1740
    return (-1);
  }
  {
#line 1743
  tmp = malloc(sizeof(char const   *) * (unsigned long )dsc->page_count);
#line 1743
  renamed1 = (char const   **)tmp;
  }
#line 1744
  if ((unsigned long )renamed1 == (unsigned long )((void *)0)) {
#line 1745
    return (-1);
  }
  {
#line 1746
  tmp___0 = rename_separations(dsc, rs, renamed1);
  }
#line 1746
  if (tmp___0 != 0) {
    {
#line 1747
    free((void *)renamed1);
    }
#line 1748
    return (-1);
  }
#line 1750
  if (doc2) {
    {
#line 1751
    tmp___1 = malloc(sizeof(char const   *) * (unsigned long )(doc2->dsc)->page_count);
#line 1751
    renamed2 = (char const   **)tmp___1;
    }
#line 1753
    if ((unsigned long )renamed2 == (unsigned long )((void *)0)) {
      {
#line 1754
      free((void *)renamed1);
      }
#line 1755
      return (-1);
    }
    {
#line 1757
    tmp___2 = rename_separations(doc2->dsc, rs, renamed2);
    }
#line 1757
    if (tmp___2 != 0) {
      {
#line 1758
      free((void *)renamed1);
#line 1759
      free((void *)renamed2);
      }
#line 1760
      return (-1);
    }
  }
#line 1764
  if (doc2) {
    {
#line 1764
    tmp___3 = check_dcs2_combine(doc, doc2, renamed1, renamed2, tolerance);
    }
#line 1764
    if (tmp___3) {
      {
#line 1765
      free((void *)renamed1);
#line 1766
      free((void *)renamed2);
      }
#line 1767
      return (-1);
    }
  }
  {
#line 1770
  gfile_seek(docfile, (long )(dsc->page + 0)->begin, 0U);
#line 1771
  memset((void *)(buf), 0, sizeof(buf) - 1UL);
  }
#line 1772
  if (sizeof(buf) - 1UL < (dsc->page + 0)->end - (dsc->page + 0)->begin) {
#line 1772
    tmp___4 = sizeof(buf) - 1UL;
  } else {
#line 1772
    tmp___4 = (dsc->page + 0)->end - (dsc->page + 0)->begin;
  }
  {
#line 1772
  count = ps_fgets(buf, (int )tmp___4, docfile);
#line 1774
  header_position = gfile_get_position(docfile);
  }
#line 1775
  if (count) {
    {
#line 1777
    tmp___5 = without_eol((char const   *)(buf), count);
#line 1777
    gfile_write(epsfile, (void const   *)(buf), (unsigned int )tmp___5);
#line 1778
    gfile_puts(epsfile, eol_str);
    }
  }
  {
#line 1780
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1780
    if (sizeof(buf) - 1UL < (dsc->page + 0)->end - header_position) {
#line 1780
      tmp___28 = sizeof(buf) - 1UL;
    } else {
#line 1780
      tmp___28 = (dsc->page + 0)->end - header_position;
    }
    {
#line 1780
    count = ps_fgets(buf, (int )tmp___28, docfile);
    }
#line 1780
    if (! (count != 0)) {
#line 1780
      goto while_break;
    }
    {
#line 1783
    header_position = gfile_get_position(docfile);
    }
#line 1785
    if (count < 2) {
#line 1786
      found_endheader = 1;
    }
#line 1787
    if ((int )buf[0] != 37) {
#line 1788
      found_endheader = 1;
    }
#line 1789
    if ((int )buf[0] == 37) {
#line 1789
      if ((int )buf[1] == 32) {
#line 1791
        found_endheader = 1;
      } else
#line 1789
      if ((int )buf[1] == 9) {
#line 1791
        found_endheader = 1;
      } else
#line 1789
      if ((int )buf[1] == 13) {
#line 1791
        found_endheader = 1;
      } else
#line 1789
      if ((int )buf[1] == 10) {
#line 1791
        found_endheader = 1;
      }
    }
    {
#line 1792
    tmp___6 = strlen((char const   *)(endcomments_str));
#line 1792
    tmp___7 = strncmp((char const   *)(buf), (char const   *)(endcomments_str), tmp___6);
    }
#line 1792
    if (tmp___7 == 0) {
#line 1793
      found_endheader = 1;
    }
    {
#line 1794
    tmp___8 = strncmp((char const   *)(buf), "%%Begin", (size_t )7);
    }
#line 1794
    if (tmp___8 == 0) {
#line 1795
      found_endheader = 1;
    }
#line 1796
    if (found_endheader) {
#line 1797
      goto while_break;
    }
#line 1798
    if ((int )buf[0] == 37) {
#line 1798
      if ((int )buf[1] == 37) {
#line 1798
        if ((int )buf[2] == 43) {
#line 1798
          if (ignore_continuation) {
#line 1800
            goto while_continue;
          } else {
#line 1802
            ignore_continuation = 0;
          }
        } else {
#line 1802
          ignore_continuation = 0;
        }
      } else {
#line 1802
        ignore_continuation = 0;
      }
    } else {
#line 1802
      ignore_continuation = 0;
    }
    {
#line 1803
    tmp___18 = strlen((char const   *)(platefile_str));
#line 1803
    tmp___19 = strncmp((char const   *)(buf), (char const   *)(platefile_str), tmp___18);
    }
#line 1803
    if (tmp___19 != 0) {
      {
#line 1803
      tmp___20 = strlen((char const   *)(cyanplate_str));
#line 1803
      tmp___21 = strncmp((char const   *)(buf), (char const   *)(cyanplate_str), tmp___20);
      }
#line 1803
      if (tmp___21 != 0) {
        {
#line 1803
        tmp___22 = strlen((char const   *)(magentaplate_str));
#line 1803
        tmp___23 = strncmp((char const   *)(buf), (char const   *)(magentaplate_str),
                           tmp___22);
        }
#line 1803
        if (tmp___23 != 0) {
          {
#line 1803
          tmp___24 = strlen((char const   *)(yellowplate_str));
#line 1803
          tmp___25 = strncmp((char const   *)(buf), (char const   *)(yellowplate_str),
                             tmp___24);
          }
#line 1803
          if (tmp___25 != 0) {
            {
#line 1803
            tmp___26 = strlen((char const   *)(blackplate_str));
#line 1803
            tmp___27 = strncmp((char const   *)(buf), (char const   *)(blackplate_str),
                               tmp___26);
            }
#line 1803
            if (tmp___27 != 0) {
#line 1809
              if ((unsigned long )rs != (unsigned long )((void *)0)) {
#line 1809
                goto _L;
              } else
#line 1809
              if (missing_separations) {
#line 1809
                goto _L;
              } else
#line 1809
              if (doc2) {
                _L: /* CIL Label */ 
                {
#line 1811
                tmp___15 = strlen(custom_str);
#line 1811
                tmp___16 = strncmp((char const   *)(buf), custom_str, tmp___15);
                }
#line 1811
                if (tmp___16 == 0) {
#line 1812
                  count = 0;
#line 1813
                  ignore_continuation = 1;
                } else {
                  {
#line 1815
                  tmp___13 = strlen(process_str);
#line 1815
                  tmp___14 = strncmp((char const   *)(buf), process_str, tmp___13);
                  }
#line 1815
                  if (tmp___14 == 0) {
#line 1816
                    count = 0;
#line 1817
                    ignore_continuation = 1;
                  } else {
                    {
#line 1819
                    tmp___11 = strlen(cmyk_custom_str);
#line 1819
                    tmp___12 = strncmp((char const   *)(buf), cmyk_custom_str, tmp___11);
                    }
#line 1819
                    if (tmp___12 == 0) {
#line 1821
                      count = 0;
#line 1822
                      ignore_continuation = 1;
                    } else {
                      {
#line 1824
                      tmp___9 = strlen(rgb_custom_str);
#line 1824
                      tmp___10 = strncmp((char const   *)(buf), rgb_custom_str, tmp___9);
                      }
#line 1824
                      if (tmp___10 == 0) {
#line 1826
                        count = 0;
#line 1827
                        ignore_continuation = 1;
                      }
                    }
                  }
                }
              }
#line 1830
              if (count == 0) {
#line 1831
                goto while_continue;
              }
              {
#line 1832
              tmp___17 = without_eol((char const   *)(buf), count);
#line 1832
              gfile_write(epsfile, (void const   *)(buf), (unsigned int )tmp___17);
#line 1833
              gfile_puts(epsfile, eol_str);
              }
            }
          }
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1840
  if ((unsigned long )rs != (unsigned long )((void *)0)) {
#line 1840
    goto _L___0;
  } else
#line 1840
  if (missing_separations) {
#line 1840
    goto _L___0;
  } else
#line 1840
  if (doc2) {
    _L___0: /* CIL Label */ 
    {
#line 1842
    strncpy((char */* __restrict  */)(outbuf), (char const   */* __restrict  */)(process_str),
            sizeof(outbuf));
#line 1843
    n = fix_process(doc, outbuf, (int )sizeof(outbuf), renamed1);
    }
#line 1844
    if (doc2) {
      {
#line 1845
      tmp___29 = fix_process(doc2, outbuf, (int )sizeof(outbuf), renamed2);
#line 1845
      n += tmp___29;
      }
    }
#line 1846
    if (n) {
      {
#line 1847
      tmp___30 = strlen((char const   *)(outbuf));
#line 1847
      tmp___31 = without_eol((char const   *)(outbuf), (int )tmp___30);
#line 1847
      gfile_write(epsfile, (void const   *)(outbuf), (unsigned int )tmp___31);
#line 1849
      gfile_puts(epsfile, eol_str);
      }
    }
    {
#line 1851
    strncpy((char */* __restrict  */)(outbuf), (char const   */* __restrict  */)(custom_str),
            sizeof(outbuf));
#line 1852
    n = fix_custom(doc, outbuf, (int )sizeof(outbuf), renamed1);
    }
#line 1853
    if (doc2) {
      {
#line 1854
      tmp___32 = fix_custom(doc2, outbuf, (int )sizeof(outbuf), renamed2);
#line 1854
      n += tmp___32;
      }
    }
#line 1855
    if (n) {
      {
#line 1856
      tmp___33 = strlen((char const   *)(outbuf));
#line 1856
      tmp___34 = without_eol((char const   *)(outbuf), (int )tmp___33);
#line 1856
      gfile_write(epsfile, (void const   *)(outbuf), (unsigned int )tmp___34);
#line 1858
      gfile_puts(epsfile, eol_str);
      }
    }
    {
#line 1860
    n = write_cmyk_custom(epsfile, doc, renamed1, 0);
    }
#line 1861
    if (doc2) {
      {
#line 1862
      write_cmyk_custom(epsfile, doc2, renamed2, n);
      }
    }
    {
#line 1863
    n = write_rgb_custom(epsfile, doc, renamed1, 0);
    }
#line 1864
    if (doc2) {
      {
#line 1865
      write_rgb_custom(epsfile, doc2, renamed2, n);
      }
    }
  }
  {
#line 1870
  len = write_platefile_comments(doc, docfile, epsfile, epsname, offset, file_offset,
                                 dcs2_multi, write_all, missing_separations, renamed1,
                                 (unsigned long )rs != (unsigned long )((void *)0));
  }
#line 1873
  if (len == 0xffffffffffffffffUL) {
    {
#line 1874
    free((void *)renamed1);
    }
#line 1875
    if (renamed2) {
      {
#line 1876
      free((void *)renamed2);
      }
    }
#line 1877
    return (-1);
  }
#line 1879
  file_offset += len;
#line 1880
  if (doc2) {
    {
#line 1881
    len = write_platefile_comments(doc2, docfile2, epsfile, epsname, offset, file_offset,
                                   dcs2_multi, write_all, missing_separations, renamed2,
                                   (unsigned long )rs != (unsigned long )((void *)0));
    }
#line 1884
    if (len == 0xffffffffffffffffUL) {
      {
#line 1885
      free((void *)renamed1);
      }
#line 1886
      if (renamed2) {
        {
#line 1887
        free((void *)renamed2);
        }
      }
#line 1888
      return (-1);
    }
#line 1890
    file_offset += len;
  }
#line 1894
  if (found_endheader) {
    {
#line 1895
    tmp___35 = without_eol((char const   *)(buf), count);
#line 1895
    gfile_write(epsfile, (void const   *)(buf), (unsigned int )tmp___35);
#line 1896
    gfile_puts(epsfile, eol_str);
    }
  }
#line 1899
  if (composite) {
#line 1900
    if (dsc->page_pages == 1U) {
      {
#line 1901
      gfile_puts(epsfile, "%%Page: 1 1");
#line 1902
      gfile_puts(epsfile, eol_str);
      }
    }
    {
#line 1904
    end = gfile_get_length(composite);
#line 1905
    gfile_seek(composite, 0L, 0U);
#line 1906
    snprintf((char */* __restrict  */)(outbuf), sizeof(outbuf) - 1UL, (char const   */* __restrict  */)"%%BeginDocument: composite");
#line 1907
    gfile_puts(epsfile, "%%BeginDocument: composite");
#line 1908
    gfile_puts(epsfile, eol_str);
#line 1909
    ps_copy(epsfile, composite, 0L, (long )end);
#line 1910
    gfile_puts(epsfile, "%%EndDocument");
#line 1911
    gfile_puts(epsfile, eol_str);
#line 1912
    gfile_puts(epsfile, "%%Trailer");
#line 1913
    gfile_puts(epsfile, eol_str);
    }
  } else {
    {
#line 1916
    begin = header_position;
#line 1917
    end = (dsc->page + 0)->end;
#line 1918
    ps_copy(epsfile, docfile, (long )begin, (long )end);
    }
  }
  {
#line 1921
  file_offset = gfile_get_position(epsfile);
#line 1922
  *complen = file_offset;
#line 1925
  write_singlefile_separations(doc, docfile, epsfile, dcs2_multi, write_all, missing_separations,
                               (unsigned long )rs != (unsigned long )((void *)0));
  }
#line 1927
  if (doc2) {
    {
#line 1928
    write_singlefile_separations(doc2, docfile2, epsfile, dcs2_multi, write_all, missing_separations,
                                 (unsigned long )rs != (unsigned long )((void *)0));
    }
  }
  {
#line 1930
  free((void *)renamed1);
  }
#line 1931
  if (renamed2) {
    {
#line 1932
    free((void *)renamed2);
    }
  }
#line 1933
  return (0);
}
}
#line 1944 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/ceps.c"
int copy_eps(Doc *doc , char const   *epsname , CDSCBBOX *bbox , CDSCFBBOX *hires_bbox ,
             int offset , BOOL dcs2_multi ) 
{ 
  GFile *docfile ;
  GFile *f ;
  CDSC *dsc ;
  int code ;
  char const   *tmp ;
  char const   *tmp___0 ;
  unsigned long complen ;

  {
  {
#line 1949
  f = (GFile *)((void *)0);
#line 1950
  dsc = doc->dsc;
#line 1951
  code = 0;
#line 1953
  tmp = doc_name(doc);
#line 1953
  docfile = gfile_open(tmp, 0U);
  }
#line 1954
  if ((unsigned long )docfile == (unsigned long )((GFile *)((void *)0))) {
    {
#line 1955
    tmp___0 = doc_name(doc);
#line 1955
    app_csmsgf(doc->app, "Can\'t open document file \"%s\"\n", tmp___0);
    }
#line 1957
    return (-1);
  }
  {
#line 1960
  f = gfile_open(epsname, 4097U);
  }
#line 1961
  if ((unsigned long )f == (unsigned long )((GFile *)((void *)0))) {
    {
#line 1962
    app_csmsgf(doc->app, "Can\'t open EPS file \"%s\"\n", epsname);
#line 1964
    gfile_close(docfile);
    }
#line 1965
    return (-1);
  }
#line 1968
  if (dsc->dcs2) {
    {
#line 1972
    complen = 0UL;
#line 1974
    code = copy_dcs2(doc, docfile, (Doc *)((void *)0), (GFile *)((void *)0), f, epsname,
                     offset, dcs2_multi, 0, 0, & complen, (GFile *)((void *)0), (RENAME_SEPARATION *)((void *)0),
                     0);
#line 1976
    gfile_seek(docfile, 0L, 0U);
#line 1977
    gfile_close(f);
#line 1978
    f = (GFile *)((void *)0);
    }
#line 1979
    if (code == 0) {
      {
#line 1980
      f = gfile_open(epsname, 4097U);
      }
#line 1981
      if ((unsigned long )f == (unsigned long )((GFile *)((void *)0))) {
        {
#line 1982
        app_csmsgf(doc->app, "Can\'t open EPS file \"%s\"\n", epsname);
#line 1984
        gfile_close(docfile);
        }
#line 1985
        return (-1);
      }
    }
#line 1988
    if (code == 0) {
      {
#line 1990
      gfile_seek(f, 0L, 0U);
#line 1991
      code = copy_dcs2(doc, docfile, (Doc *)((void *)0), (GFile *)((void *)0), f,
                       epsname, offset, dcs2_multi, 1, 0, & complen, (GFile *)((void *)0),
                       (RENAME_SEPARATION *)((void *)0), 0);
      }
    }
  } else {
    {
#line 1999
    copy_bbox_header(f, docfile, dsc->begincomments, dsc->endcomments, bbox, hires_bbox);
#line 2002
    ps_copy(f, docfile, (long )dsc->begindefaults, (long )dsc->enddefaults);
#line 2003
    ps_copy(f, docfile, (long )dsc->beginprolog, (long )dsc->endprolog);
#line 2004
    ps_copy(f, docfile, (long )dsc->beginsetup, (long )dsc->endsetup);
    }
#line 2005
    if (dsc->page_count) {
      {
#line 2006
      ps_copy(f, docfile, (long )(dsc->page + 0)->begin, (long )(dsc->page + 0)->end);
      }
    }
    {
#line 2007
    copy_nobbox(f, docfile, dsc->begintrailer, dsc->endtrailer);
    }
  }
#line 2009
  if (f) {
    {
#line 2010
    gfile_close(f);
    }
  }
  {
#line 2011
  gfile_close(docfile);
  }
#line 2012
  return (code);
}
}
#line 2021 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/ceps.c"
int make_eps_interchange(Doc *doc , IMAGE *img , CDSCBBOX devbbox , CDSCBBOX *bbox ,
                         CDSCFBBOX *hires_bbox , char const   *epsname ) 
{ 
  GFile *epsfile ;
  GFile *docfile ;
  int code ;
  CDSC *dsc ;
  char const   *tmp ;
  char const   *tmp___0 ;

  {
#line 2028
  dsc = doc->dsc;
#line 2030
  if ((unsigned long )dsc == (unsigned long )((void *)0)) {
#line 2031
    return (-1);
  }
  {
#line 2033
  tmp___0 = doc_name(doc);
#line 2033
  docfile = gfile_open(tmp___0, 0U);
  }
#line 2033
  if ((unsigned long )docfile == (unsigned long )((GFile *)((void *)0))) {
    {
#line 2035
    tmp = doc_name(doc);
#line 2035
    app_csmsgf(doc->app, "Can\'t open EPS file \"%s\"\n", tmp);
    }
#line 2038
    return (-1);
  }
  {
#line 2041
  epsfile = gfile_open(epsname, 4097U);
  }
#line 2043
  if ((unsigned long )epsfile == (unsigned long )((GFile *)((void *)0))) {
    {
#line 2044
    app_csmsgf(doc->app, "Can\'t open output EPS file \"%s\"\n", epsname);
#line 2047
    gfile_close(docfile);
    }
#line 2048
    return (-1);
  }
  {
#line 2052
  copy_bbox_header(epsfile, docfile, dsc->begincomments, dsc->endcomments, bbox, hires_bbox);
#line 2055
  code = write_interchange(epsfile, img, devbbox);
#line 2057
  ps_copy(epsfile, docfile, (long )dsc->begindefaults, (long )dsc->enddefaults);
#line 2058
  ps_copy(epsfile, docfile, (long )dsc->beginprolog, (long )dsc->endprolog);
#line 2059
  ps_copy(epsfile, docfile, (long )dsc->beginsetup, (long )dsc->endsetup);
  }
#line 2060
  if (dsc->page_count) {
    {
#line 2061
    ps_copy(epsfile, docfile, (long )(dsc->page + 0)->begin, (long )(dsc->page + 0)->end);
    }
  }
  {
#line 2062
  copy_nobbox(epsfile, docfile, dsc->begintrailer, dsc->endtrailer);
#line 2063
  gfile_close(docfile);
  }
#line 2064
  if ((int const   )*epsname != 0) {
    {
#line 2065
    gfile_close(epsfile);
    }
#line 2066
    if (code) {
#line 2066
      if (! (debug & 1)) {
        {
#line 2067
        unlink(epsname);
        }
      }
    }
  }
#line 2069
  return (code);
}
}
#line 2078 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/ceps.c"
int make_eps_metafile(Doc *doc , IMAGE *img , CDSCBBOX devbbox , CDSCBBOX *bbox ,
                      CDSCFBBOX *hires_bbox , float xdpi , float ydpi , BOOL reverse ,
                      char const   *epsname ) 
{ 
  MFH mf ;
  GFile *epsfile ;
  GFile *tpsfile ;
  char tpsname[256] ;
  int code ;
  int count ;
  char *buffer ;
  CDSCDOSEPS doseps ;
  unsigned long tmp ;
  void *tmp___0 ;
  unsigned int tmp___1 ;
  unsigned int tmp___2 ;

  {
  {
#line 2093
  code = metafile_init(img, & devbbox, & mf);
#line 2096
  tpsfile = (GFile *)((void *)0);
#line 2097
  memset((void *)(tpsname), 0, sizeof(tpsname));
#line 2098
  tpsfile = app_temp_gfile(doc->app, tpsname, (int )(sizeof(tpsname) / sizeof(char )));
  }
#line 2098
  if ((unsigned long )tpsfile == (unsigned long )((GFile *)((void *)0))) {
    {
#line 2100
    app_csmsgf(doc->app, "Can\'t create temporary EPS file \"%s\"\n", tpsname);
    }
#line 2103
    return (-1);
  }
  {
#line 2105
  gfile_close(tpsfile);
#line 2107
  code = copy_eps(doc, (char const   *)(tpsname), bbox, hires_bbox, 30, 0);
  }
#line 2108
  if (code) {
#line 2109
    return (-1);
  }
  {
#line 2111
  tpsfile = gfile_open((char const   *)(tpsname), 0U);
  }
#line 2111
  if ((unsigned long )tpsfile == (unsigned long )((GFile *)((void *)0))) {
    {
#line 2112
    app_csmsgf(doc->app, "Can\'t open temporary EPS file \"%s\"\n", tpsname);
    }
#line 2115
    return (-1);
  }
  {
#line 2119
  epsfile = gfile_open(epsname, 4097U);
  }
#line 2120
  if ((unsigned long )epsfile == (unsigned long )((GFile *)((void *)0))) {
    {
#line 2121
    app_csmsgf(doc->app, "Can\'t open output EPS file \"%s\"\n", epsname);
#line 2124
    gfile_close(tpsfile);
    }
#line 2125
    if (! (debug & 1)) {
      {
#line 2126
      unlink((char const   *)(tpsname));
      }
    }
#line 2127
    return (-1);
  }
  {
#line 2130
  tmp = gfile_get_length(tpsfile);
#line 2130
  doseps.ps_length = tmp;
#line 2131
  doseps.wmf_length = mf.size * 2UL;
#line 2132
  doseps.tiff_begin = (GSDWORD )0;
#line 2133
  doseps.tiff_length = (GSDWORD )0;
#line 2134
  doseps.checksum = (GSWORD )65535;
  }
#line 2135
  if (reverse) {
#line 2136
    doseps.wmf_begin = (GSDWORD )30;
#line 2137
    doseps.ps_begin = doseps.wmf_begin + doseps.wmf_length;
  } else {
#line 2140
    doseps.ps_begin = (GSDWORD )30;
#line 2141
    doseps.wmf_begin = doseps.ps_begin + doseps.ps_length;
  }
  {
#line 2143
  write_doseps_header(& doseps, epsfile);
#line 2145
  tmp___0 = malloc((size_t )4096);
#line 2145
  buffer = (char *)tmp___0;
  }
#line 2146
  if ((unsigned long )buffer == (unsigned long )((char *)((void *)0))) {
#line 2147
    if (*(epsname + 0)) {
      {
#line 2148
      gfile_close(epsfile);
      }
#line 2149
      if (! (debug & 1)) {
        {
#line 2150
        unlink(epsname);
        }
      }
    }
    {
#line 2152
    gfile_close(tpsfile);
    }
#line 2153
    if (! (debug & 1)) {
      {
#line 2154
      unlink((char const   *)(tpsname));
      }
    }
#line 2155
    return (-1);
  }
  {
#line 2158
  gfile_seek(tpsfile, 0L, 0U);
  }
#line 2159
  if (! reverse) {
    {
#line 2161
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 2161
      tmp___1 = gfile_read(tpsfile, (void *)buffer, 4096U);
#line 2161
      count = (int )tmp___1;
      }
#line 2161
      if (! (count != 0)) {
#line 2161
        goto while_break;
      }
      {
#line 2162
      gfile_write(epsfile, (void const   *)buffer, (unsigned int )count);
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 2166
  code = write_metafile(epsfile, img, devbbox, xdpi, ydpi, & mf);
  }
#line 2168
  if (reverse) {
    {
#line 2170
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 2170
      tmp___2 = gfile_read(tpsfile, (void *)buffer, 4096U);
#line 2170
      count = (int )tmp___2;
      }
#line 2170
      if (! (count != 0)) {
#line 2170
        goto while_break___0;
      }
      {
#line 2171
      gfile_write(epsfile, (void const   *)buffer, (unsigned int )count);
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  {
#line 2174
  free((void *)buffer);
#line 2175
  gfile_close(tpsfile);
  }
#line 2176
  if (! (debug & 1)) {
    {
#line 2177
    unlink((char const   *)(tpsname));
    }
  }
#line 2178
  if (*(epsname + 0)) {
    {
#line 2179
    gfile_close(epsfile);
    }
  }
#line 2180
  return (0);
}
}
#line 2187 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/ceps.c"
int make_eps_pict(Doc *doc , IMAGE *img , CDSCBBOX *bbox , CDSCFBBOX *hires_bbox ,
                  float xdpi , float ydpi , CMAC_TYPE mac_type , char const   *epsname ) 
{ 
  GFile *epsfile ;
  GFile *tpsfile ;
  char tpsname[256] ;
  GFile *tpictfile ;
  char tpictname[256] ;
  char filename[256] ;
  int code ;
  int len ;
  CMAC_TYPE type ;
  char const   *tp ;
  char const   *tq ;
  size_t tmp ;
  int tmp___0 ;
  int tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  int tmp___4 ;

  {
  {
#line 2198
  code = 0;
#line 2200
  type = mac_type;
#line 2203
  tmp = strlen(epsname);
#line 2203
  len = (int )tmp;
  }
#line 2204
  if ((unsigned int )mac_type != 0U) {
#line 2205
    type = mac_type;
  } else
#line 2206
  if ((int const   )*(epsname + 0) == 46) {
#line 2207
    type = (CMAC_TYPE )2;
  } else
#line 2208
  if (len > 3) {
#line 2208
    if ((int const   )*(epsname + (len - 3)) == 46) {
#line 2208
      if ((int const   )*(epsname + (len - 2)) == 97) {
#line 2208
        goto _L___5;
      } else
#line 2208
      if ((int const   )*(epsname + (len - 2)) == 65) {
        _L___5: /* CIL Label */ 
#line 2208
        if ((int const   )*(epsname + (len - 1)) == 115) {
#line 2212
          type = (CMAC_TYPE )1;
        } else
#line 2208
        if ((int const   )*(epsname + (len - 1)) == 83) {
#line 2212
          type = (CMAC_TYPE )1;
        } else {
#line 2208
          goto _L___6;
        }
      } else {
#line 2208
        goto _L___6;
      }
    } else {
#line 2208
      goto _L___6;
    }
  } else
  _L___6: /* CIL Label */ 
#line 2213
  if (len > 5) {
#line 2213
    if ((int const   )*(epsname + (len - 5)) == 46) {
#line 2213
      goto _L___2;
    } else
#line 2213
    if ((int const   )*(epsname + (len - 5)) == 47) {
      _L___2: /* CIL Label */ 
#line 2213
      if ((int const   )*(epsname + (len - 4)) == 114) {
#line 2213
        goto _L___1;
      } else
#line 2213
      if ((int const   )*(epsname + (len - 4)) == 82) {
        _L___1: /* CIL Label */ 
#line 2213
        if ((int const   )*(epsname + (len - 3)) == 115) {
#line 2213
          goto _L___0;
        } else
#line 2213
        if ((int const   )*(epsname + (len - 3)) == 83) {
          _L___0: /* CIL Label */ 
#line 2213
          if ((int const   )*(epsname + (len - 2)) == 114) {
#line 2213
            goto _L;
          } else
#line 2213
          if ((int const   )*(epsname + (len - 2)) == 82) {
            _L: /* CIL Label */ 
#line 2213
            if ((int const   )*(epsname + (len - 1)) == 99) {
#line 2219
              type = (CMAC_TYPE )4;
            } else
#line 2213
            if ((int const   )*(epsname + (len - 1)) == 67) {
#line 2219
              type = (CMAC_TYPE )4;
            } else {
#line 2221
              type = (CMAC_TYPE )3;
            }
          } else {
#line 2221
            type = (CMAC_TYPE )3;
          }
        } else {
#line 2221
          type = (CMAC_TYPE )3;
        }
      } else {
#line 2221
        type = (CMAC_TYPE )3;
      }
    } else {
#line 2221
      type = (CMAC_TYPE )3;
    }
  } else {
#line 2221
    type = (CMAC_TYPE )3;
  }
  {
#line 2224
  tpsfile = (GFile *)((void *)0);
#line 2225
  memset((void *)(tpsname), 0, sizeof(tpsname));
#line 2226
  tpsfile = app_temp_gfile(doc->app, tpsname, (int )(sizeof(tpsname) / sizeof(char )));
  }
#line 2226
  if ((unsigned long )tpsfile == (unsigned long )((GFile *)((void *)0))) {
    {
#line 2228
    app_csmsgf(doc->app, "Can\'t create temporary EPS file \"%s\"\n", tpsname);
    }
#line 2231
    return (-1);
  }
  {
#line 2233
  gfile_close(tpsfile);
#line 2235
  code = copy_eps(doc, (char const   *)(tpsname), bbox, hires_bbox, 0, 0);
  }
#line 2236
  if (code) {
#line 2237
    return (-1);
  }
  {
#line 2239
  tpsfile = gfile_open((char const   *)(tpsname), 0U);
  }
#line 2239
  if ((unsigned long )tpsfile == (unsigned long )((GFile *)((void *)0))) {
    {
#line 2240
    app_csmsgf(doc->app, "Can\'t open temporary EPS file \"%s\"\n", tpsname);
    }
#line 2243
    return (-1);
  }
  {
#line 2245
  gfile_close(tpsfile);
#line 2248
  tpictfile = (GFile *)((void *)0);
#line 2249
  memset((void *)(tpictname), 0, sizeof(tpictname));
#line 2250
  tpictfile = app_temp_gfile(doc->app, tpictname, (int )(sizeof(tpictname) / sizeof(char )));
  }
#line 2250
  if ((unsigned long )tpictfile == (unsigned long )((GFile *)((void *)0))) {
    {
#line 2252
    app_csmsgf(doc->app, "Can\'t create temporary PICT file \"%s\"\n", tpictname);
    }
#line 2255
    return (-1);
  }
  {
#line 2257
  gfile_close(tpictfile);
#line 2258
  code = image_to_pictfile(img, (char const   *)(tpictname), xdpi, ydpi);
#line 2261
  epsfile = gfile_open(epsname, 4097U);
  }
#line 2262
  if ((unsigned long )epsfile == (unsigned long )((GFile *)((void *)0))) {
    {
#line 2263
    app_csmsgf(doc->app, "Can\'t open output EPS file \"%s\"\n", epsname);
#line 2266
    gfile_close(tpsfile);
    }
#line 2267
    if (! (debug & 1)) {
      {
#line 2268
      unlink((char const   *)(tpsname));
      }
    }
#line 2269
    return (-1);
  }
  {
#line 2273
  if ((unsigned int )type == 1U) {
#line 2273
    goto case_1;
  }
#line 2276
  if ((unsigned int )type == 2U) {
#line 2276
    goto case_2;
  }
#line 2279
  if ((unsigned int )type == 3U) {
#line 2279
    goto case_3;
  }
#line 2300
  if ((unsigned int )type == 4U) {
#line 2300
    goto case_4;
  }
#line 2304
  goto switch_default;
  case_1: /* CIL Label */ 
  {
#line 2274
  code = write_applesingle(epsfile, (char const   *)(tpsname), (char const   *)(tpictname));
  }
#line 2275
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 2277
  code = write_appledouble(epsfile, (char const   *)(tpictname));
  }
#line 2278
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 2280
  memset((void *)(filename), 0, sizeof(filename));
#line 2282
  tq = epsname;
#line 2282
  tp = tq;
  }
  {
#line 2283
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2283
    if (! ((int const   )*tp != 0)) {
#line 2283
      goto while_break;
    }
#line 2284
    if ((int const   )*tp == 92) {
#line 2284
      goto _L___7;
    } else
#line 2284
    if ((int const   )*tp == 47) {
#line 2284
      goto _L___7;
    } else
#line 2284
    if ((int const   )*tp == 58) {
      _L___7: /* CIL Label */ 
#line 2285
      if ((unsigned int )global_codepage == 0U) {
#line 2285
        tq = tp + 1;
      } else {
        {
#line 2285
        tmp___0 = char_next(tp);
#line 2285
        tq = tp + tmp___0;
        }
      }
    }
#line 2286
    if ((unsigned int )global_codepage == 0U) {
#line 2286
      tp ++;
    } else {
      {
#line 2286
      tmp___1 = char_next(tp);
#line 2286
      tp += tmp___1;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2288
  tmp___2 = strlen(tq);
#line 2288
  cs_to_narrow(filename, (int )sizeof(filename) - 1, tq, (int )tmp___2 + 1);
#line 2290
  tmp___3 = strlen((char const   *)(filename));
#line 2290
  len = (int )tmp___3;
  }
#line 2292
  if (len > 4) {
#line 2292
    if ((int )filename[len - 4] == 46) {
#line 2292
      if ((int )filename[len - 3] == 98) {
#line 2292
        goto _L___9;
      } else
#line 2292
      if ((int )filename[len - 3] == 66) {
        _L___9: /* CIL Label */ 
#line 2292
        if ((int )filename[len - 2] == 105) {
#line 2292
          goto _L___8;
        } else
#line 2292
        if ((int )filename[len - 2] == 73) {
          _L___8: /* CIL Label */ 
#line 2292
          if ((int )filename[len - 1] == 110) {
#line 2297
            filename[len - 4] = (char )'\000';
          } else
#line 2292
          if ((int )filename[len - 1] == 78) {
#line 2297
            filename[len - 4] = (char )'\000';
          }
        }
      }
    }
  }
  {
#line 2298
  code = write_macbin(epsfile, (char const   *)(filename), (char const   *)(tpsname),
                      (char const   *)(tpictname));
  }
#line 2299
  goto switch_break;
  case_4: /* CIL Label */ 
  {
#line 2302
  tmp___4 = write_resource_pict(epsfile, (char const   *)(tpictname));
#line 2302
  code = tmp___4 < 0;
  }
#line 2303
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 2305
  code = -1;
  switch_break: /* CIL Label */ ;
  }
#line 2308
  if (! (debug & 1)) {
    {
#line 2309
    unlink((char const   *)(tpsname));
    }
  }
#line 2310
  if (! (debug & 1)) {
    {
#line 2311
    unlink((char const   *)(tpictname));
    }
  }
#line 2312
  if (*(epsname + 0)) {
    {
#line 2313
    gfile_close(epsfile);
    }
#line 2314
    if (code < 0) {
#line 2314
      if (! (debug & 1)) {
        {
#line 2315
        unlink(epsname);
        }
      }
    }
  }
#line 2317
  return (code);
}
}
#line 2326 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/ceps.c"
int copy_page_temp(Doc *doc , GFile *f , int page ) 
{ 
  char save_str[48] ;
  char restore_str[52] ;
  int code ;

  {
  {
#line 2329
  save_str[0] = (char )'%';
#line 2329
  save_str[1] = (char )'!';
#line 2329
  save_str[2] = (char )'\n';
#line 2329
  save_str[3] = (char )'s';
#line 2329
  save_str[4] = (char )'a';
#line 2329
  save_str[5] = (char )'v';
#line 2329
  save_str[6] = (char )'e';
#line 2329
  save_str[7] = (char )' ';
#line 2329
  save_str[8] = (char )'/';
#line 2329
  save_str[9] = (char )'G';
#line 2329
  save_str[10] = (char )'S';
#line 2329
  save_str[11] = (char )'v';
#line 2329
  save_str[12] = (char )'i';
#line 2329
  save_str[13] = (char )'e';
#line 2329
  save_str[14] = (char )'w';
#line 2329
  save_str[15] = (char )'_';
#line 2329
  save_str[16] = (char )'s';
#line 2329
  save_str[17] = (char )'a';
#line 2329
  save_str[18] = (char )'v';
#line 2329
  save_str[19] = (char )'e';
#line 2329
  save_str[20] = (char )' ';
#line 2329
  save_str[21] = (char )'e';
#line 2329
  save_str[22] = (char )'x';
#line 2329
  save_str[23] = (char )'c';
#line 2329
  save_str[24] = (char )'h';
#line 2329
  save_str[25] = (char )' ';
#line 2329
  save_str[26] = (char )'d';
#line 2329
  save_str[27] = (char )'e';
#line 2329
  save_str[28] = (char )'f';
#line 2329
  save_str[29] = (char )'\n';
#line 2329
  save_str[30] = (char )'/';
#line 2329
  save_str[31] = (char )'s';
#line 2329
  save_str[32] = (char )'h';
#line 2329
  save_str[33] = (char )'o';
#line 2329
  save_str[34] = (char )'w';
#line 2329
  save_str[35] = (char )'p';
#line 2329
  save_str[36] = (char )'a';
#line 2329
  save_str[37] = (char )'g';
#line 2329
  save_str[38] = (char )'e';
#line 2329
  save_str[39] = (char )' ';
#line 2329
  save_str[40] = (char )'{';
#line 2329
  save_str[41] = (char )'}';
#line 2329
  save_str[42] = (char )' ';
#line 2329
  save_str[43] = (char )'d';
#line 2329
  save_str[44] = (char )'e';
#line 2329
  save_str[45] = (char )'f';
#line 2329
  save_str[46] = (char )'\n';
#line 2329
  save_str[47] = (char )'\000';
#line 2331
  restore_str[0] = (char )'\n';
#line 2331
  restore_str[1] = (char )'c';
#line 2331
  restore_str[2] = (char )'l';
#line 2331
  restore_str[3] = (char )'e';
#line 2331
  restore_str[4] = (char )'a';
#line 2331
  restore_str[5] = (char )'r';
#line 2331
  restore_str[6] = (char )' ';
#line 2331
  restore_str[7] = (char )'c';
#line 2331
  restore_str[8] = (char )'l';
#line 2331
  restore_str[9] = (char )'e';
#line 2331
  restore_str[10] = (char )'a';
#line 2331
  restore_str[11] = (char )'r';
#line 2331
  restore_str[12] = (char )'d';
#line 2331
  restore_str[13] = (char )'i';
#line 2331
  restore_str[14] = (char )'c';
#line 2331
  restore_str[15] = (char )'t';
#line 2331
  restore_str[16] = (char )'s';
#line 2331
  restore_str[17] = (char )'t';
#line 2331
  restore_str[18] = (char )'a';
#line 2331
  restore_str[19] = (char )'c';
#line 2331
  restore_str[20] = (char )'k';
#line 2331
  restore_str[21] = (char )' ';
#line 2331
  restore_str[22] = (char )'G';
#line 2331
  restore_str[23] = (char )'S';
#line 2331
  restore_str[24] = (char )'v';
#line 2331
  restore_str[25] = (char )'i';
#line 2331
  restore_str[26] = (char )'e';
#line 2331
  restore_str[27] = (char )'w';
#line 2331
  restore_str[28] = (char )'_';
#line 2331
  restore_str[29] = (char )'s';
#line 2331
  restore_str[30] = (char )'a';
#line 2331
  restore_str[31] = (char )'v';
#line 2331
  restore_str[32] = (char )'e';
#line 2331
  restore_str[33] = (char )' ';
#line 2331
  restore_str[34] = (char )'r';
#line 2331
  restore_str[35] = (char )'e';
#line 2331
  restore_str[36] = (char )'s';
#line 2331
  restore_str[37] = (char )'t';
#line 2331
  restore_str[38] = (char )'o';
#line 2331
  restore_str[39] = (char )'r';
#line 2331
  restore_str[40] = (char )'e';
#line 2331
  restore_str[41] = (char )'\n';
#line 2331
  restore_str[42] = (char )'s';
#line 2331
  restore_str[43] = (char )'h';
#line 2331
  restore_str[44] = (char )'o';
#line 2331
  restore_str[45] = (char )'w';
#line 2331
  restore_str[46] = (char )'p';
#line 2331
  restore_str[47] = (char )'a';
#line 2331
  restore_str[48] = (char )'g';
#line 2331
  restore_str[49] = (char )'e';
#line 2331
  restore_str[50] = (char )'\n';
#line 2331
  restore_str[51] = (char )'\000';
#line 2334
  gfile_puts(f, (char const   *)(save_str));
#line 2335
  code = copy_page_nosave(doc, f, page);
#line 2336
  gfile_puts(f, (char const   *)(restore_str));
  }
#line 2337
  return (code);
}
}
#line 2340 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/ceps.c"
int copy_page_nosave(Doc *doc , GFile *f , int page ) 
{ 
  CDSC *dsc ;
  GFile *docfile ;
  char const   *fname ;
  unsigned long end ;
  char wfname[256] ;
  size_t tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;

  {
#line 2343
  dsc = doc->dsc;
#line 2346
  if ((unsigned long )dsc == (unsigned long )((void *)0)) {
#line 2347
    return (-1);
  }
  {
#line 2349
  fname = dsc_find_platefile(dsc, page);
  }
#line 2350
  if (fname) {
    {
#line 2354
    tmp = strlen(fname);
#line 2354
    narrow_to_cs(wfname, (int )sizeof(wfname), fname, (int )tmp + 1);
#line 2355
    docfile = gfile_open((char const   *)(wfname), 0U);
    }
#line 2355
    if ((unsigned long )docfile != (unsigned long )((GFile *)((void *)0))) {
      {
#line 2356
      end = gfile_get_length(docfile);
#line 2357
      ps_copy(f, docfile, 0L, (long )end);
#line 2358
      gfile_close(docfile);
      }
    }
  } else {
    {
#line 2364
    tmp___1 = doc_name(doc);
#line 2364
    docfile = gfile_open(tmp___1, 0U);
    }
#line 2364
    if ((unsigned long )docfile == (unsigned long )((GFile *)((void *)0))) {
      {
#line 2366
      tmp___0 = doc_name(doc);
#line 2366
      app_csmsgf(doc->app, "Can\'t open document file \"%s\"\n", tmp___0);
      }
#line 2369
      return (-1);
    }
    {
#line 2371
    ps_copy(f, docfile, (long )dsc->begincomments, (long )dsc->endcomments);
#line 2372
    ps_copy(f, docfile, (long )dsc->begindefaults, (long )dsc->enddefaults);
#line 2373
    ps_copy(f, docfile, (long )dsc->beginprolog, (long )dsc->endprolog);
#line 2374
    ps_copy(f, docfile, (long )dsc->beginsetup, (long )dsc->endsetup);
    }
#line 2375
    if (dsc->page_count) {
#line 2375
      if (page >= 0) {
#line 2375
        if (page < (int )dsc->page_count) {
          {
#line 2376
          ps_copy(f, docfile, (long )(dsc->page + page)->begin, (long )(dsc->page + page)->end);
          }
        }
      }
    }
    {
#line 2377
    ps_copy(f, docfile, (long )dsc->begintrailer, (long )dsc->endtrailer);
#line 2378
    gfile_close(docfile);
    }
  }
#line 2381
  return (0);
}
}
#line 127 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) toupper)(int __c ) ;
#line 241 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/dscparse.h"
CDSCMEDIA const   dsc_known_media[25] ;
#line 517
CDSC *dsc_init(void *caller_data ) ;
#line 519
CDSC *dsc_init_with_alloc(void *caller_data , void *(*memalloc)(size_t size , void *closure_data ) ,
                          void (*memfree)(void *ptr , void *closure_data ) , void *closure_data ) ;
#line 526
void dsc_free(CDSC *dsc ) ;
#line 532
CDSC *dsc_new(void *caller_data ) ;
#line 533
int dsc_ref(CDSC *dsc ) ;
#line 534
int dsc_unref(CDSC *dsc ) ;
#line 539
void dsc_set_length(CDSC *dsc , unsigned long len ) ;
#line 542
int dsc_scan_data(CDSC *dsc , char const   *data , int length ) ;
#line 545
int dsc_fixup(CDSC *dsc ) ;
#line 548
void dsc_set_error_function(CDSC *dsc , int (*fn)(void *caller_data , CDSC *dsc ,
                                                  unsigned int explanation , char const   *line ,
                                                  unsigned int line_len ) ) ;
#line 553
void dsc_set_debug_function(CDSC *dsc , void (*debug_fn)(void *caller_data , char const   *str ) ) ;
#line 568
int dsc_add_page(CDSC *dsc , int ordinal , char *label ) ;
#line 569
int dsc_add_media(CDSC *dsc , CDSCMEDIA *media ) ;
#line 570
int dsc_set_page_bbox(CDSC *dsc , unsigned int page_number , int llx , int lly , int urx ,
                      int ury ) ;
#line 82 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/dscparse.c"
static void *dsc_memalloc(CDSC *dsc , size_t size ) ;
#line 83
static void dsc_memfree(CDSC *dsc , void *ptr ) ;
#line 84
static CDSC *dsc_init2(CDSC *dsc ) ;
#line 85
static void dsc_reset(CDSC *dsc ) ;
#line 86
static void dsc_section_join(unsigned long begin , unsigned long *pend , unsigned long **pplast ) ;
#line 87
static int dsc_read_line(CDSC *dsc ) ;
#line 88
static int dsc_read_doseps(CDSC *dsc ) ;
#line 89
static int dsc_read_macbin(CDSC *dsc ) ;
#line 90
static int dsc_read_applesingle(CDSC *dsc ) ;
#line 91
static char *dsc_alloc_string(CDSC *dsc , char const   *str , int len ) ;
#line 92
static char *dsc_add_line(CDSC *dsc , char const   *line , unsigned int len ) ;
#line 93
static char *dsc_copy_string(char *str , unsigned int slen , char *line , unsigned int len ,
                             unsigned int *offset ) ;
#line 95
static GSDWORD dsc_get_dword(unsigned char const   *buf ) ;
#line 96
static GSWORD dsc_get_word(unsigned char const   *buf ) ;
#line 97
static GSDWORD dsc_get_bigendian_dword(unsigned char const   *buf ) ;
#line 98
static GSWORD dsc_get_bigendian_word(unsigned char const   *buf ) ;
#line 99
static int dsc_get_int(char const   *line , unsigned int len , unsigned int *offset ) ;
#line 100
static float dsc_get_real(char const   *line , unsigned int len , unsigned int *offset ) ;
#line 102
static void dsc_unknown(CDSC *dsc ) ;
#line 103
static GSBOOL dsc_is_section(char *line ) ;
#line 104
static int dsc_parse_pages(CDSC *dsc ) ;
#line 105
static int dsc_parse_feature(CDSC *dsc ) ;
#line 106
static int dsc_parse_bounding_box(CDSC *dsc , CDSCBBOX **pbbox , int offset ) ;
#line 107
static int dsc_parse_float_bounding_box(CDSC *dsc , CDSCFBBOX **pbbox , int offset ) ;
#line 108
static int dsc_parse_orientation(CDSC *dsc , unsigned int *porientation , int offset ) ;
#line 110
static int dsc_parse_order(CDSC *dsc ) ;
#line 111
static int dsc_parse_media(CDSC *dsc , CDSCMEDIA const   **page_media ) ;
#line 112
static int dsc_parse_document_media(CDSC *dsc ) ;
#line 113
static int dsc_parse_viewing_orientation(CDSC *dsc , CDSCCTM **pctm ) ;
#line 114
static int dsc_parse_page(CDSC *dsc ) ;
#line 115
static void dsc_save_line(CDSC *dsc ) ;
#line 116
static int dsc_scan_type(CDSC *dsc ) ;
#line 117
static int dsc_scan_comments(CDSC *dsc ) ;
#line 118
static int dsc_scan_preview(CDSC *dsc ) ;
#line 119
static int dsc_scan_defaults(CDSC *dsc ) ;
#line 120
static int dsc_scan_prolog(CDSC *dsc ) ;
#line 121
static int dsc_scan_setup(CDSC *dsc ) ;
#line 122
static int dsc_scan_page(CDSC *dsc ) ;
#line 123
static int dsc_scan_trailer(CDSC *dsc ) ;
#line 124
static int dsc_error(CDSC *dsc , unsigned int explanation , char *line , unsigned int line_len ) ;
#line 126
static int dsc_dcs2_fixup(CDSC *dsc ) ;
#line 127
static int dsc_parse_platefile(CDSC *dsc ) ;
#line 128
static int dsc_parse_dcs1plate(CDSC *dsc ) ;
#line 129
static CDSCCOLOUR *dsc_find_colour(CDSC *dsc , char const   *colourname ) ;
#line 130
static int dsc_parse_process_colours(CDSC *dsc ) ;
#line 131
static int dsc_parse_custom_colours(CDSC *dsc ) ;
#line 132
static int dsc_parse_cmyk_custom_colour(CDSC *dsc ) ;
#line 133
static int dsc_parse_rgb_custom_colour(CDSC *dsc ) ;
#line 136 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/dscparse.c"
static int const   dsc_severity[17]  = 
#line 136
  {      (int const   )1,      (int const   )1,      (int const   )1,      (int const   )2, 
        (int const   )2,      (int const   )2,      (int const   )2,      (int const   )2, 
        (int const   )1,      (int const   )1,      (int const   )0,      (int const   )0, 
        (int const   )1,      (int const   )0,      (int const   )0,      (int const   )1, 
        (int const   )0};
#line 158 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/dscparse.c"
CDSCMEDIA const   dsc_known_media[25]  = 
#line 158
  {      {"11x17", (float )792, (float )1224, (float )0, (char const   *)((void *)0),
      (char const   *)((void *)0), (CDSCBBOX *)((void *)0)}, 
        {"A3", (float )842, (float )1190, (float )0, (char const   *)((void *)0), (char const   *)((void *)0),
      (CDSCBBOX *)((void *)0)}, 
        {"A4", (float )595, (float )842, (float )0, (char const   *)((void *)0), (char const   *)((void *)0),
      (CDSCBBOX *)((void *)0)}, 
        {"A5", (float )421, (float )595, (float )0, (char const   *)((void *)0), (char const   *)((void *)0),
      (CDSCBBOX *)((void *)0)}, 
        {"B4", (float )709, (float )1002, (float )0, (char const   *)((void *)0), (char const   *)((void *)0),
      (CDSCBBOX *)((void *)0)}, 
        {"B5", (float )501, (float )709, (float )0, (char const   *)((void *)0), (char const   *)((void *)0),
      (CDSCBBOX *)((void *)0)}, 
        {"Ledger", (float )1224, (float )792, (float )0, (char const   *)((void *)0),
      (char const   *)((void *)0), (CDSCBBOX *)((void *)0)}, 
        {"Legal", (float )612, (float )1008, (float )0, (char const   *)((void *)0),
      (char const   *)((void *)0), (CDSCBBOX *)((void *)0)}, 
        {"Letter", (float )612, (float )792, (float )0, (char const   *)((void *)0),
      (char const   *)((void *)0), (CDSCBBOX *)((void *)0)}, 
        {"Note", (float )612, (float )792, (float )0, (char const   *)((void *)0), (char const   *)((void *)0),
      (CDSCBBOX *)((void *)0)}, 
        {"A0", (float )2384, (float )3370, (float )0, (char const   *)((void *)0), (char const   *)((void *)0),
      (CDSCBBOX *)((void *)0)}, 
        {"A1", (float )1684, (float )2384, (float )0, (char const   *)((void *)0), (char const   *)((void *)0),
      (CDSCBBOX *)((void *)0)}, 
        {"A2", (float )1190, (float )1684, (float )0, (char const   *)((void *)0), (char const   *)((void *)0),
      (CDSCBBOX *)((void *)0)}, 
        {"AnsiA", (float )612, (float )792, (float )0, (char const   *)((void *)0), (char const   *)((void *)0),
      (CDSCBBOX *)((void *)0)}, 
        {"AnsiB", (float )792, (float )1224, (float )0, (char const   *)((void *)0),
      (char const   *)((void *)0), (CDSCBBOX *)((void *)0)}, 
        {"AnsiC", (float )1224, (float )1584, (float )0, (char const   *)((void *)0),
      (char const   *)((void *)0), (CDSCBBOX *)((void *)0)}, 
        {"AnsiD", (float )1584, (float )2448, (float )0, (char const   *)((void *)0),
      (char const   *)((void *)0), (CDSCBBOX *)((void *)0)}, 
        {"AnsiE", (float )2448, (float )3168, (float )0, (char const   *)((void *)0),
      (char const   *)((void *)0), (CDSCBBOX *)((void *)0)}, 
        {"ArchA", (float )648, (float )864, (float )0, (char const   *)((void *)0), (char const   *)((void *)0),
      (CDSCBBOX *)((void *)0)}, 
        {"ArchB", (float )864, (float )1296, (float )0, (char const   *)((void *)0),
      (char const   *)((void *)0), (CDSCBBOX *)((void *)0)}, 
        {"ArchC", (float )1296, (float )1728, (float )0, (char const   *)((void *)0),
      (char const   *)((void *)0), (CDSCBBOX *)((void *)0)}, 
        {"ArchD", (float )1728, (float )2592, (float )0, (char const   *)((void *)0),
      (char const   *)((void *)0), (CDSCBBOX *)((void *)0)}, 
        {"ArchE", (float )2592, (float )3456, (float )0, (char const   *)((void *)0),
      (char const   *)((void *)0), (CDSCBBOX *)((void *)0)}, 
        {"ArchF", (float )2160, (float )3024, (float )0, (char const   *)((void *)0),
      (char const   *)((void *)0), (CDSCBBOX *)((void *)0)}, 
        {(char const   *)((void *)0), (float )0, (float )0, (float )0, (char const   *)((void *)0),
      (char const   *)((void *)0), (CDSCBBOX *)((void *)0)}};
#line 208 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/dscparse.c"
static char const   * const  dsc_scan_section_name[15]  = 
#line 208
  {      (char const   */* const  */)"Type",      (char const   */* const  */)"Comments",      (char const   */* const  */)"pre-Preview",      (char const   */* const  */)"Preview", 
        (char const   */* const  */)"pre-Defaults",      (char const   */* const  */)"Defaults",      (char const   */* const  */)"pre-Prolog",      (char const   */* const  */)"Prolog", 
        (char const   */* const  */)"pre-Setup",      (char const   */* const  */)"Setup",      (char const   */* const  */)"pre-Page",      (char const   */* const  */)"Page", 
        (char const   */* const  */)"pre-Trailer",      (char const   */* const  */)"Trailer",      (char const   */* const  */)"EOF"};
#line 225 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/dscparse.c"
CDSC *dsc_init(void *caller_data ) 
{ 
  CDSC *dsc ;
  void *tmp ;
  CDSC *tmp___0 ;

  {
  {
#line 228
  tmp = malloc(sizeof(CDSC ));
#line 228
  dsc = (CDSC *)tmp;
  }
#line 229
  if ((unsigned long )dsc == (unsigned long )((void *)0)) {
#line 230
    return ((CDSC *)((void *)0));
  }
  {
#line 231
  memset((void *)dsc, 0, sizeof(CDSC ));
#line 232
  dsc->caller_data = caller_data;
#line 233
  dsc->ref_count = 0;
#line 234
  dsc_ref(dsc);
#line 236
  tmp___0 = dsc_init2(dsc);
  }
#line 236
  return (tmp___0);
}
}
#line 240 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/dscparse.c"
CDSC *dsc_init_with_alloc(void *caller_data , void *(*memalloc)(size_t size , void *closure_data ) ,
                          void (*memfree)(void *ptr , void *closure_data ) , void *closure_data ) 
{ 
  CDSC *dsc ;
  void *tmp ;
  CDSC *tmp___0 ;

  {
  {
#line 247
  tmp = (*memalloc)(sizeof(CDSC ), closure_data);
#line 247
  dsc = (CDSC *)tmp;
  }
#line 248
  if ((unsigned long )dsc == (unsigned long )((void *)0)) {
#line 249
    return ((CDSC *)((void *)0));
  }
  {
#line 250
  memset((void *)dsc, 0, sizeof(CDSC ));
#line 251
  dsc->caller_data = caller_data;
#line 253
  dsc->memalloc = memalloc;
#line 254
  dsc->memfree = memfree;
#line 255
  dsc->mem_closure_data = closure_data;
#line 256
  dsc->ref_count = 0;
#line 257
  dsc_ref(dsc);
#line 259
  tmp___0 = dsc_init2(dsc);
  }
#line 259
  return (tmp___0);
}
}
#line 265 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/dscparse.c"
void dsc_free(CDSC *dsc ) 
{ 


  {
#line 268
  if ((unsigned long )dsc == (unsigned long )((void *)0)) {
#line 269
    return;
  }
  {
#line 270
  dsc_reset(dsc);
#line 271
  dsc_memfree(dsc, (void *)dsc);
  }
#line 272
  return;
}
}
#line 275 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/dscparse.c"
CDSC *dsc_new(void *caller_data ) 
{ 
  CDSC *tmp ;

  {
  {
#line 278
  tmp = dsc_init(caller_data);
  }
#line 278
  return (tmp);
}
}
#line 281 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/dscparse.c"
int dsc_ref(CDSC *dsc ) 
{ 


  {
#line 284
  (dsc->ref_count) ++;
#line 284
  return (dsc->ref_count);
}
}
#line 287 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/dscparse.c"
int dsc_unref(CDSC *dsc ) 
{ 


  {
#line 290
  if (dsc->ref_count <= 0) {
#line 291
    return (-1);
  }
#line 292
  (dsc->ref_count) --;
#line 293
  if (dsc->ref_count == 0) {
    {
#line 294
    dsc_free(dsc);
    }
#line 295
    return (0);
  }
#line 297
  return (dsc->ref_count);
}
}
#line 304 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/dscparse.c"
void dsc_set_length(CDSC *dsc , unsigned long len ) 
{ 


  {
#line 307
  dsc->file_length = len;
#line 308
  return;
}
}
#line 317 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/dscparse.c"
int dsc_scan_data(CDSC *dsc , char const   *data , int length ) 
{ 
  int bytes_read ;
  int code ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 321
  code = 0;
#line 323
  if ((unsigned long )dsc == (unsigned long )((void *)0)) {
#line 324
    return (-1);
  }
#line 326
  if (dsc->id == 1) {
#line 327
    return (1);
  }
#line 328
  dsc->id = 0;
#line 329
  if (dsc->eof) {
#line 330
    return (0);
  }
#line 332
  if (length == 0) {
#line 334
    dsc->eof = 1;
  }
  {
#line 337
  while (1) {
    while_continue: /* CIL Label */ ;
#line 338
    if (dsc->id == 1) {
#line 339
      goto while_break;
    }
#line 341
    if (length != 0) {
#line 343
      if (dsc->data_length > 4096U) {
        {
#line 344
        memmove((void *)(dsc->data), (void const   *)(dsc->data + dsc->data_index),
                (size_t )(dsc->data_length - dsc->data_index));
#line 346
        dsc->data_offset += (unsigned long )dsc->data_index;
#line 347
        dsc->data_length -= dsc->data_index;
#line 348
        dsc->data_index = 0U;
        }
      }
#line 351
      if (length < (int )(8192U - dsc->data_length)) {
#line 351
        bytes_read = length;
      } else {
#line 351
        bytes_read = (int )(8192U - dsc->data_length);
      }
      {
#line 352
      memcpy((void */* __restrict  */)(dsc->data + dsc->data_length), (void const   */* __restrict  */)data,
             (size_t )bytes_read);
#line 353
      dsc->data_length += (unsigned int )bytes_read;
#line 354
      data += bytes_read;
#line 355
      length -= bytes_read;
      }
    }
#line 357
    if (dsc->scan_section == 0) {
      {
#line 358
      code = dsc_scan_type(dsc);
      }
#line 359
      if (code == 11) {
#line 361
        code = 0;
#line 362
        goto while_break;
      }
#line 364
      dsc->id = code;
    }
#line 367
    if (code == 1) {
#line 368
      dsc->id = 1;
#line 369
      goto while_break;
    }
    {
#line 372
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 372
      code = dsc_read_line(dsc);
      }
#line 372
      if (! (code > 0)) {
#line 372
        goto while_break___0;
      }
#line 373
      if (dsc->id == 1) {
#line 374
        goto while_break___0;
      }
#line 375
      if (dsc->file_length) {
#line 375
        if (dsc->data_offset + (unsigned long )dsc->data_index > dsc->file_length) {
#line 378
          return (0);
        }
      }
#line 380
      if (dsc->doseps_end) {
#line 380
        if (dsc->data_offset + (unsigned long )dsc->data_index > dsc->doseps_end) {
#line 385
          return (0);
        }
      }
#line 387
      if (dsc->eof) {
#line 388
        return (0);
      }
#line 389
      if (dsc->skip_document) {
#line 390
        goto while_continue___0;
      }
#line 391
      if (dsc->skip_lines) {
#line 392
        goto while_continue___0;
      }
      {
#line 393
      tmp = strncmp((char const   *)dsc->line, "%%BeginData:", sizeof("%%BeginData:") - 1UL);
      }
#line 393
      if (tmp == 0) {
#line 394
        goto while_continue___0;
      }
      {
#line 395
      tmp___0 = strncmp((char const   *)dsc->line, "%%BeginBinary:", sizeof("%%BeginBinary:") - 1UL);
      }
#line 395
      if (tmp___0 == 0) {
#line 396
        goto while_continue___0;
      }
      {
#line 397
      tmp___1 = strncmp((char const   *)dsc->line, "%%EndDocument", sizeof("%%EndDocument") - 1UL);
      }
#line 397
      if (tmp___1 == 0) {
#line 398
        goto while_continue___0;
      }
      {
#line 399
      tmp___2 = strncmp((char const   *)dsc->line, "%%EndData", sizeof("%%EndData") - 1UL);
      }
#line 399
      if (tmp___2 == 0) {
#line 400
        goto while_continue___0;
      }
      {
#line 401
      tmp___3 = strncmp((char const   *)dsc->line, "%%EndBinary", sizeof("%%EndBinary") - 1UL);
      }
#line 401
      if (tmp___3 == 0) {
#line 402
        goto while_continue___0;
      }
      {
#line 404
      while (1) {
        while_continue___1: /* CIL Label */ ;
        {
#line 406
        if (dsc->scan_section == 1) {
#line 406
          goto case_1;
        }
#line 410
        if (dsc->scan_section == 3) {
#line 410
          goto case_3;
        }
#line 410
        if (dsc->scan_section == 2) {
#line 410
          goto case_3;
        }
#line 414
        if (dsc->scan_section == 5) {
#line 414
          goto case_5;
        }
#line 414
        if (dsc->scan_section == 4) {
#line 414
          goto case_5;
        }
#line 418
        if (dsc->scan_section == 7) {
#line 418
          goto case_7;
        }
#line 418
        if (dsc->scan_section == 6) {
#line 418
          goto case_7;
        }
#line 422
        if (dsc->scan_section == 9) {
#line 422
          goto case_9;
        }
#line 422
        if (dsc->scan_section == 8) {
#line 422
          goto case_9;
        }
#line 426
        if (dsc->scan_section == 11) {
#line 426
          goto case_11;
        }
#line 426
        if (dsc->scan_section == 10) {
#line 426
          goto case_11;
        }
#line 430
        if (dsc->scan_section == 13) {
#line 430
          goto case_13;
        }
#line 430
        if (dsc->scan_section == 12) {
#line 430
          goto case_13;
        }
#line 433
        if (dsc->scan_section == 14) {
#line 433
          goto case_14;
        }
#line 436
        goto switch_default;
        case_1: /* CIL Label */ 
        {
#line 407
        code = dsc_scan_comments(dsc);
        }
#line 408
        goto switch_break;
        case_3: /* CIL Label */ 
        case_2: /* CIL Label */ 
        {
#line 411
        code = dsc_scan_preview(dsc);
        }
#line 412
        goto switch_break;
        case_5: /* CIL Label */ 
        case_4: /* CIL Label */ 
        {
#line 415
        code = dsc_scan_defaults(dsc);
        }
#line 416
        goto switch_break;
        case_7: /* CIL Label */ 
        case_6: /* CIL Label */ 
        {
#line 419
        code = dsc_scan_prolog(dsc);
        }
#line 420
        goto switch_break;
        case_9: /* CIL Label */ 
        case_8: /* CIL Label */ 
        {
#line 423
        code = dsc_scan_setup(dsc);
        }
#line 424
        goto switch_break;
        case_11: /* CIL Label */ 
        case_10: /* CIL Label */ 
        {
#line 427
        code = dsc_scan_page(dsc);
        }
#line 428
        goto switch_break;
        case_13: /* CIL Label */ 
        case_12: /* CIL Label */ 
        {
#line 431
        code = dsc_scan_trailer(dsc);
        }
#line 432
        goto switch_break;
        case_14: /* CIL Label */ 
#line 434
        code = 0;
#line 435
        goto switch_break;
        switch_default: /* CIL Label */ 
#line 438
        code = -1;
        switch_break: /* CIL Label */ ;
        }
#line 404
        if (! (code == 10)) {
#line 404
          goto while_break___1;
        }
      }
      while_break___1: /* CIL Label */ ;
      }
#line 444
      if (code == 11) {
#line 445
        code = 0;
#line 446
        goto while_break___0;
      }
#line 448
      if (code == 1) {
#line 449
        dsc->id = 1;
#line 450
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 337
    if (! (length != 0)) {
#line 337
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 455
  if (code < 0) {
#line 455
    tmp___4 = code;
  } else {
#line 455
    tmp___4 = dsc->id;
  }
#line 455
  return (tmp___4);
}
}
#line 459 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/dscparse.c"
int dsc_fixup(CDSC *dsc ) 
{ 
  unsigned int i ;
  char buf[32] ;
  unsigned long *last ;
  int rc ;
  int tmp ;
  int rc___0 ;
  int tmp___0 ;
  int rc___1 ;
  int tmp___1 ;
  int rc___2 ;
  int tmp___2 ;
  char const   *tmp___3 ;
  size_t tmp___4 ;
  char *tmp___5 ;
  size_t tmp___6 ;

  {
#line 466
  if (dsc->id == 1) {
#line 467
    return (0);
  }
  {
#line 470
  dsc_scan_data(dsc, (char const   *)((void *)0), 0);
  }
#line 474
  if (dsc->eof) {
#line 474
    if (dsc->skip_lines) {
#line 474
      goto _L;
    } else
#line 474
    if (dsc->skip_bytes) {
#line 474
      goto _L;
    } else
#line 474
    if (dsc->skip_document) {
      _L: /* CIL Label */ 
      {
#line 477
      if (dsc->scan_section == 1) {
#line 477
        goto case_1;
      }
#line 480
      if (dsc->scan_section == 3) {
#line 480
        goto case_3;
      }
#line 483
      if (dsc->scan_section == 5) {
#line 483
        goto case_5;
      }
#line 486
      if (dsc->scan_section == 7) {
#line 486
        goto case_7;
      }
#line 489
      if (dsc->scan_section == 9) {
#line 489
        goto case_9;
      }
#line 492
      if (dsc->scan_section == 11) {
#line 492
        goto case_11;
      }
#line 497
      if (dsc->scan_section == 14) {
#line 497
        goto case_14;
      }
#line 497
      if (dsc->scan_section == 13) {
#line 497
        goto case_14;
      }
#line 476
      goto switch_break;
      case_1: /* CIL Label */ 
#line 478
      dsc->endcomments = dsc->data_offset + (unsigned long )dsc->data_index;
#line 479
      goto switch_break;
      case_3: /* CIL Label */ 
#line 481
      dsc->endpreview = dsc->data_offset + (unsigned long )dsc->data_index;
#line 482
      goto switch_break;
      case_5: /* CIL Label */ 
#line 484
      dsc->enddefaults = dsc->data_offset + (unsigned long )dsc->data_index;
#line 485
      goto switch_break;
      case_7: /* CIL Label */ 
#line 487
      dsc->endprolog = dsc->data_offset + (unsigned long )dsc->data_index;
#line 488
      goto switch_break;
      case_9: /* CIL Label */ 
#line 490
      dsc->endsetup = dsc->data_offset + (unsigned long )dsc->data_index;
#line 491
      goto switch_break;
      case_11: /* CIL Label */ 
#line 493
      if (dsc->page_count) {
#line 494
        (dsc->page + (dsc->page_count - 1U))->end = dsc->data_offset + (unsigned long )dsc->data_index;
      }
#line 495
      goto switch_break;
      case_14: /* CIL Label */ 
      case_13: /* CIL Label */ 
#line 498
      dsc->endtrailer = dsc->data_offset + (unsigned long )dsc->data_index;
#line 499
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    }
  }
#line 504
  if (dsc->page_count) {
#line 504
    if ((dsc->page + 0)->begin != dsc->endsetup) {
#line 504
      if (dsc->endsetup != dsc->beginsetup) {
        {
#line 506
        dsc->endsetup = (dsc->page + 0)->begin;
#line 507
        dsc_debug_print(dsc, "Warning: code included between setup and first page\n");
        }
      }
    }
  }
#line 512
  if (dsc->page_count) {
#line 512
    if (dsc->begintrailer != 0UL) {
#line 512
      if ((dsc->page + (dsc->page_count - 1U))->end != dsc->begintrailer) {
        {
#line 514
        dsc_debug_print(dsc, "Ignoring earlier misplaced trailer\n");
#line 515
        dsc_debug_print(dsc, "and extending last page to start of trailer\n");
#line 516
        (dsc->page + (dsc->page_count - 1U))->end = dsc->begintrailer;
        }
      }
    }
  }
  {
#line 524
  last = & dsc->endcomments;
#line 525
  dsc_section_join(dsc->beginpreview, & dsc->endpreview, & last);
#line 526
  dsc_section_join(dsc->begindefaults, & dsc->enddefaults, & last);
#line 527
  dsc_section_join(dsc->beginprolog, & dsc->endprolog, & last);
#line 528
  dsc_section_join(dsc->beginsetup, & dsc->endsetup, & last);
#line 529
  i = 0U;
  }
  {
#line 529
  while (1) {
    while_continue: /* CIL Label */ ;
#line 529
    if (! (i < dsc->page_count)) {
#line 529
      goto while_break;
    }
    {
#line 530
    dsc_section_join((dsc->page + i)->begin, & (dsc->page + i)->end, & last);
#line 529
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 531
  if (dsc->begintrailer) {
#line 532
    *last = dsc->begintrailer;
  }
#line 534
  if (dsc->page_pages == 0U) {
#line 534
    if (dsc->page_count == 1U) {
#line 537
      dsc->page_pages = dsc->page_count;
    }
  }
#line 541
  if (dsc->page_count != dsc->page_pages) {
    {
#line 542
    tmp = dsc_error(dsc, 5U, (char *)((void *)0), 0U);
#line 542
    rc = tmp;
    }
    {
#line 544
    if (rc == 0) {
#line 544
      goto case_0;
    }
#line 548
    if (rc == 1) {
#line 548
      goto case_1___0;
    }
#line 550
    if (rc == 2) {
#line 550
      goto case_2;
    }
#line 543
    goto switch_break___0;
    case_0: /* CIL Label */ 
#line 546
    dsc->page_pages = dsc->page_count;
#line 547
    goto switch_break___0;
    case_1___0: /* CIL Label */ 
#line 549
    goto switch_break___0;
    case_2: /* CIL Label */ 
#line 551
    return (1);
    switch_break___0: /* CIL Label */ ;
    }
  }
#line 555
  if (dsc->epsf) {
#line 555
    if ((unsigned long )dsc->bbox == (unsigned long )((CDSCBBOX *)((void *)0))) {
      {
#line 557
      tmp___0 = dsc_error(dsc, 6U, (char *)((void *)0), 0U);
#line 557
      rc___0 = tmp___0;
      }
      {
#line 559
      if (rc___0 == 0) {
#line 559
        goto case_0___0;
      }
#line 562
      if (rc___0 == 1) {
#line 562
        goto case_1___1;
      }
#line 565
      if (rc___0 == 2) {
#line 565
        goto case_2___0;
      }
#line 558
      goto switch_break___1;
      case_0___0: /* CIL Label */ 
#line 561
      goto switch_break___1;
      case_1___1: /* CIL Label */ 
#line 564
      dsc->epsf = 0;
      case_2___0: /* CIL Label */ 
#line 566
      return (1);
      switch_break___1: /* CIL Label */ ;
      }
    }
  }
#line 570
  if (dsc->epsf) {
#line 570
    if (dsc->page_count > 1U) {
#line 570
      goto _L___0;
    } else
#line 570
    if (dsc->page_pages > 1U) {
      _L___0: /* CIL Label */ 
      {
#line 571
      tmp___1 = dsc_error(dsc, 7U, (char *)((void *)0), 0U);
#line 571
      rc___1 = tmp___1;
      }
      {
#line 573
      if (rc___1 == 0) {
#line 573
        goto case_0___1;
      }
#line 576
      if (rc___1 == 1) {
#line 576
        goto case_1___2;
      }
#line 580
      if (rc___1 == 2) {
#line 580
        goto case_2___1;
      }
#line 572
      goto switch_break___2;
      case_0___1: /* CIL Label */ 
#line 575
      goto switch_break___2;
      case_1___2: /* CIL Label */ 
#line 578
      dsc->epsf = 0;
#line 579
      goto switch_break___2;
      case_2___1: /* CIL Label */ 
#line 581
      return (1);
      switch_break___2: /* CIL Label */ ;
      }
    }
  }
  {
#line 586
  dsc_dcs2_fixup(dsc);
  }
#line 588
  if (dsc->media_count == 1U) {
#line 588
    if ((unsigned long )dsc->page_media == (unsigned long )((void *)0)) {
#line 591
      dsc->page_media = (CDSCMEDIA const   *)*(dsc->media + 0);
    }
  }
#line 594
  if (dsc->media_count != 0U) {
#line 594
    if ((unsigned long )dsc->page_media == (unsigned long )((void *)0)) {
      {
#line 595
      tmp___2 = dsc_error(dsc, 8U, (char *)((void *)0), 0U);
#line 595
      rc___2 = tmp___2;
      }
      {
#line 597
      if (rc___2 == 0) {
#line 597
        goto case_0___2;
      }
#line 601
      if (rc___2 == 1) {
#line 601
        goto case_1___3;
      }
#line 604
      if (rc___2 == 2) {
#line 604
        goto case_2___2;
      }
#line 596
      goto switch_break___3;
      case_0___2: /* CIL Label */ 
#line 599
      dsc->page_media = (CDSCMEDIA const   *)*(dsc->media + 0);
#line 600
      goto switch_break___3;
      case_1___3: /* CIL Label */ 
#line 603
      goto switch_break___3;
      case_2___2: /* CIL Label */ 
#line 605
      return (1);
      switch_break___3: /* CIL Label */ ;
      }
    }
  }
#line 610
  i = 0U;
  {
#line 610
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 610
    if (! (i < dsc->page_count)) {
#line 610
      goto while_break___0;
    }
    {
#line 611
    tmp___6 = strlen((dsc->page + i)->label);
    }
#line 611
    if (tmp___6 == 0UL) {
      {
#line 612
      sprintf((char */* __restrict  */)(buf), (char const   */* __restrict  */)"%d",
              i + 1U);
#line 613
      tmp___4 = strlen((char const   *)(buf));
#line 613
      tmp___5 = dsc_alloc_string(dsc, (char const   *)(buf), (int )tmp___4);
#line 613
      tmp___3 = (char const   *)tmp___5;
#line 613
      (dsc->page + i)->label = tmp___3;
      }
#line 613
      if ((unsigned long )tmp___3 == (unsigned long )((char *)((void *)0))) {
#line 615
        return (-1);
      }
    }
#line 610
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 618
  return (0);
}
}
#line 625 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/dscparse.c"
void dsc_set_error_function(CDSC *dsc , int (*fn)(void *caller_data , CDSC *dsc ,
                                                  unsigned int explanation , char const   *line ,
                                                  unsigned int line_len ) ) 
{ 


  {
#line 630
  dsc->dsc_error_fn = fn;
#line 631
  return;
}
}
#line 636 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/dscparse.c"
void dsc_set_debug_function(CDSC *dsc , void (*debug_fn)(void *caller_data , char const   *str ) ) 
{ 


  {
#line 640
  dsc->debug_print_fn = debug_fn;
#line 641
  return;
}
}
#line 645 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/dscparse.c"
int dsc_add_page(CDSC *dsc , int ordinal , char *label ) 
{ 
  size_t tmp ;
  char *tmp___0 ;
  CDSCPAGE *new_page ;
  void *tmp___1 ;

  {
  {
#line 648
  (dsc->page + dsc->page_count)->ordinal = ordinal;
#line 649
  tmp = strlen((char const   *)label);
#line 649
  tmp___0 = dsc_alloc_string(dsc, (char const   *)label, (int )tmp + 1);
#line 649
  (dsc->page + dsc->page_count)->label = (char const   *)tmp___0;
#line 651
  (dsc->page + dsc->page_count)->begin = 0UL;
#line 652
  (dsc->page + dsc->page_count)->end = 0UL;
#line 653
  (dsc->page + dsc->page_count)->orientation = 0U;
#line 654
  (dsc->page + dsc->page_count)->media = (CDSCMEDIA const   *)((void *)0);
#line 655
  (dsc->page + dsc->page_count)->bbox = (CDSCBBOX *)((void *)0);
#line 656
  (dsc->page + dsc->page_count)->viewing_orientation = (CDSCCTM *)((void *)0);
#line 657
  (dsc->page + dsc->page_count)->crop_box = (CDSCFBBOX *)((void *)0);
#line 659
  (dsc->page_count) ++;
  }
#line 660
  if (dsc->page_count >= dsc->page_chunk_length) {
    {
#line 661
    tmp___1 = dsc_memalloc(dsc, (unsigned long )(128U + dsc->page_count) * sizeof(CDSCPAGE ));
#line 661
    new_page = (CDSCPAGE *)tmp___1;
    }
#line 663
    if ((unsigned long )new_page == (unsigned long )((void *)0)) {
#line 664
      return (-1);
    }
    {
#line 665
    memcpy((void */* __restrict  */)new_page, (void const   */* __restrict  */)dsc->page,
           (unsigned long )dsc->page_count * sizeof(CDSCPAGE ));
#line 667
    dsc_memfree(dsc, (void *)dsc->page);
#line 668
    dsc->page = new_page;
#line 669
    dsc->page_chunk_length = 128U + dsc->page_count;
    }
  }
#line 671
  return (0);
}
}
#line 676 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/dscparse.c"
int dsc_add_media(CDSC *dsc , CDSCMEDIA *media ) 
{ 
  CDSCMEDIA **newmedia_array ;
  CDSCMEDIA *newmedia ;
  void *tmp ;
  CDSCMEDIA *tmp___0 ;
  void *tmp___1 ;
  size_t tmp___2 ;
  char *tmp___3 ;
  size_t tmp___4 ;
  char *tmp___5 ;
  size_t tmp___6 ;
  char *tmp___7 ;
  void *tmp___8 ;

  {
  {
#line 683
  tmp = dsc_memalloc(dsc, (unsigned long )(dsc->media_count + 1U) * sizeof(CDSCMEDIA *));
#line 683
  newmedia_array = (CDSCMEDIA **)tmp;
  }
#line 685
  if ((unsigned long )newmedia_array == (unsigned long )((void *)0)) {
#line 686
    return (-1);
  }
#line 687
  if ((unsigned long )dsc->media != (unsigned long )((void *)0)) {
    {
#line 688
    memcpy((void */* __restrict  */)newmedia_array, (void const   */* __restrict  */)dsc->media,
           (unsigned long )dsc->media_count * sizeof(CDSCMEDIA *));
#line 690
    dsc_memfree(dsc, (void *)dsc->media);
    }
  }
  {
#line 692
  dsc->media = newmedia_array;
#line 695
  tmp___1 = dsc_memalloc(dsc, sizeof(CDSCMEDIA ));
#line 695
  tmp___0 = (CDSCMEDIA *)tmp___1;
#line 695
  *(dsc->media + dsc->media_count) = tmp___0;
#line 695
  newmedia = tmp___0;
  }
#line 697
  if ((unsigned long )newmedia == (unsigned long )((void *)0)) {
#line 698
    return (-1);
  }
#line 699
  newmedia->name = (char const   *)((void *)0);
#line 700
  newmedia->width = (float )595.0;
#line 701
  newmedia->height = (float )842.0;
#line 702
  newmedia->weight = (float )80.0;
#line 703
  newmedia->colour = (char const   *)((void *)0);
#line 704
  newmedia->type = (char const   *)((void *)0);
#line 705
  newmedia->mediabox = (CDSCBBOX *)((void *)0);
#line 707
  (dsc->media_count) ++;
#line 709
  if (media->name) {
    {
#line 710
    tmp___2 = strlen(media->name);
#line 710
    tmp___3 = dsc_alloc_string(dsc, media->name, (int )tmp___2);
#line 710
    newmedia->name = (char const   *)tmp___3;
    }
#line 712
    if ((unsigned long )newmedia->name == (unsigned long )((void *)0)) {
#line 713
      return (-1);
    }
  }
#line 715
  newmedia->width = media->width;
#line 716
  newmedia->height = media->height;
#line 717
  newmedia->weight = media->weight;
#line 718
  if (media->colour) {
    {
#line 719
    tmp___4 = strlen(media->colour);
#line 719
    tmp___5 = dsc_alloc_string(dsc, media->colour, (int )tmp___4);
#line 719
    newmedia->colour = (char const   *)tmp___5;
    }
#line 721
    if ((unsigned long )newmedia->colour == (unsigned long )((void *)0)) {
#line 722
      return (-1);
    }
  }
#line 724
  if (media->type) {
    {
#line 725
    tmp___6 = strlen(media->type);
#line 725
    tmp___7 = dsc_alloc_string(dsc, media->type, (int )tmp___6);
#line 725
    newmedia->type = (char const   *)tmp___7;
    }
#line 727
    if ((unsigned long )newmedia->type == (unsigned long )((void *)0)) {
#line 728
      return (-1);
    }
  }
#line 730
  newmedia->mediabox = (CDSCBBOX *)((void *)0);
#line 732
  if (media->mediabox) {
    {
#line 733
    tmp___8 = dsc_memalloc(dsc, sizeof(CDSCBBOX ));
#line 733
    newmedia->mediabox = (CDSCBBOX *)tmp___8;
    }
#line 734
    if ((unsigned long )newmedia->mediabox == (unsigned long )((void *)0)) {
#line 735
      return (-1);
    }
#line 736
    *(newmedia->mediabox) = *(media->mediabox);
  }
#line 738
  return (0);
}
}
#line 743 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/dscparse.c"
int dsc_set_page_bbox(CDSC *dsc , unsigned int page_number , int llx , int lly , int urx ,
                      int ury ) 
{ 
  CDSCBBOX *bbox ;
  void *tmp ;

  {
#line 748
  if (page_number >= dsc->page_count) {
#line 749
    return (-1);
  }
#line 750
  bbox = (dsc->page + page_number)->bbox;
#line 751
  if ((unsigned long )bbox == (unsigned long )((void *)0)) {
    {
#line 752
    tmp = dsc_memalloc(dsc, sizeof(CDSCBBOX ));
#line 752
    bbox = (CDSCBBOX *)tmp;
#line 752
    (dsc->page + page_number)->bbox = bbox;
    }
  }
#line 754
  if ((unsigned long )bbox == (unsigned long )((void *)0)) {
#line 755
    return (-1);
  }
#line 756
  bbox->llx = llx;
#line 757
  bbox->lly = lly;
#line 758
  bbox->urx = urx;
#line 759
  bbox->ury = ury;
#line 760
  return (0);
}
}
#line 768 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/dscparse.c"
static void *dsc_memalloc(CDSC *dsc , size_t size ) 
{ 
  void *tmp ;
  void *tmp___0 ;

  {
#line 771
  if (dsc->memalloc) {
    {
#line 772
    tmp = (*(dsc->memalloc))(size, dsc->mem_closure_data);
    }
#line 772
    return (tmp);
  }
  {
#line 773
  tmp___0 = malloc(size);
  }
#line 773
  return (tmp___0);
}
}
#line 776 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/dscparse.c"
static void dsc_memfree(CDSC *dsc , void *ptr ) 
{ 


  {
#line 779
  if (dsc->memfree) {
    {
#line 780
    (*(dsc->memfree))(ptr, dsc->mem_closure_data);
    }
  } else {
    {
#line 782
    free(ptr);
    }
  }
#line 783
  return;
}
}
#line 786 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/dscparse.c"
static CDSC *dsc_init2(CDSC *dsc ) 
{ 
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
  {
#line 789
  dsc_reset(dsc);
#line 791
  tmp = dsc_memalloc(dsc, sizeof(CDSCSTRING ));
#line 791
  dsc->string_head = (CDSCSTRING *)tmp;
  }
#line 792
  if ((unsigned long )dsc->string_head == (unsigned long )((void *)0)) {
    {
#line 793
    dsc_free(dsc);
    }
#line 794
    return ((CDSC *)((void *)0));
  }
  {
#line 796
  dsc->string = dsc->string_head;
#line 797
  (dsc->string)->next = (CDSCSTRING *)((void *)0);
#line 798
  tmp___0 = dsc_memalloc(dsc, (size_t )4096);
#line 798
  (dsc->string)->data = (char *)tmp___0;
  }
#line 799
  if ((unsigned long )(dsc->string)->data == (unsigned long )((void *)0)) {
    {
#line 800
    dsc_free(dsc);
    }
#line 801
    return ((CDSC *)((void *)0));
  }
  {
#line 803
  (dsc->string)->index = 0U;
#line 804
  (dsc->string)->length = 4096U;
#line 806
  tmp___1 = dsc_memalloc(dsc, 128UL * sizeof(CDSCPAGE ));
#line 806
  dsc->page = (CDSCPAGE *)tmp___1;
  }
#line 807
  if ((unsigned long )dsc->page == (unsigned long )((void *)0)) {
    {
#line 808
    dsc_free(dsc);
    }
#line 809
    return ((CDSC *)((void *)0));
  }
#line 811
  dsc->page_chunk_length = 128U;
#line 812
  dsc->page_count = 0U;
#line 814
  dsc->line = (char *)((void *)0);
#line 815
  dsc->data_length = 0U;
#line 816
  dsc->data_index = dsc->data_length;
#line 818
  return (dsc);
}
}
#line 822 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/dscparse.c"
static void dsc_reset(CDSC *dsc ) 
{ 
  unsigned int i ;
  CDCS2 *this_dcs ;
  CDCS2 *next_dcs ;
  CDSCCOLOUR *this_colour ;
  CDSCCOLOUR *next_colour ;

  {
#line 827
  dsc->dsc = 0;
#line 828
  dsc->ctrld = 0;
#line 829
  dsc->pjl = 0;
#line 830
  dsc->epsf = 0;
#line 831
  dsc->pdf = 0;
#line 832
  dsc->epsf = 0;
#line 833
  dsc->preview = 0U;
#line 834
  dsc->dsc_version = (char *)((void *)0);
#line 835
  dsc->language_level = 0U;
#line 836
  dsc->document_data = 0U;
#line 837
  dsc->begincomments = 0UL;
#line 838
  dsc->endcomments = 0UL;
#line 839
  dsc->beginpreview = 0UL;
#line 840
  dsc->endpreview = 0UL;
#line 841
  dsc->begindefaults = 0UL;
#line 842
  dsc->enddefaults = 0UL;
#line 843
  dsc->beginprolog = 0UL;
#line 844
  dsc->endprolog = 0UL;
#line 845
  dsc->beginsetup = 0UL;
#line 846
  dsc->endsetup = 0UL;
#line 847
  dsc->begintrailer = 0UL;
#line 848
  dsc->endtrailer = 0UL;
#line 850
  i = 0U;
  {
#line 850
  while (1) {
    while_continue: /* CIL Label */ ;
#line 850
    if (! (i < dsc->page_count)) {
#line 850
      goto while_break;
    }
#line 854
    if ((dsc->page + i)->bbox) {
      {
#line 855
      dsc_memfree(dsc, (void *)(dsc->page + i)->bbox);
      }
    }
#line 856
    if ((dsc->page + i)->viewing_orientation) {
      {
#line 857
      dsc_memfree(dsc, (void *)(dsc->page + i)->viewing_orientation);
      }
    }
#line 858
    if ((dsc->page + i)->crop_box) {
      {
#line 859
      dsc_memfree(dsc, (void *)(dsc->page + i)->crop_box);
      }
    }
#line 850
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 861
  if (dsc->page) {
    {
#line 862
    dsc_memfree(dsc, (void *)dsc->page);
    }
  }
#line 863
  dsc->page = (CDSCPAGE *)((void *)0);
#line 865
  dsc->page_count = 0U;
#line 866
  dsc->page_pages = 0U;
#line 867
  dsc->page_order = 0U;
#line 868
  dsc->page_orientation = 0U;
#line 869
  if (dsc->viewing_orientation) {
    {
#line 870
    dsc_memfree(dsc, (void *)dsc->viewing_orientation);
    }
  }
#line 871
  dsc->viewing_orientation = (CDSCCTM *)((void *)0);
#line 873
  if (dsc->media) {
#line 874
    i = 0U;
    {
#line 874
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 874
      if (! (i < dsc->media_count)) {
#line 874
        goto while_break___0;
      }
#line 875
      if (*(dsc->media + i)) {
#line 876
        if ((*(dsc->media + i))->mediabox) {
          {
#line 877
          dsc_memfree(dsc, (void *)(*(dsc->media + i))->mediabox);
          }
        }
        {
#line 878
        dsc_memfree(dsc, (void *)*(dsc->media + i));
        }
      }
#line 874
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 881
    dsc_memfree(dsc, (void *)dsc->media);
    }
  }
#line 883
  dsc->media_count = 0U;
#line 884
  dsc->media = (CDSCMEDIA **)((void *)0);
#line 888
  dsc->page_media = (CDSCMEDIA const   *)((void *)0);
#line 890
  if (dsc->bbox) {
    {
#line 891
    dsc_memfree(dsc, (void *)dsc->bbox);
    }
  }
#line 892
  dsc->bbox = (CDSCBBOX *)((void *)0);
#line 893
  if (dsc->page_bbox) {
    {
#line 894
    dsc_memfree(dsc, (void *)dsc->page_bbox);
    }
  }
#line 895
  dsc->page_bbox = (CDSCBBOX *)((void *)0);
#line 896
  if (dsc->doseps) {
    {
#line 897
    dsc_memfree(dsc, (void *)dsc->doseps);
    }
  }
  {
#line 898
  dsc->doseps = (CDSCDOSEPS *)((void *)0);
#line 900
  dsc->dsc_title = (char *)((void *)0);
#line 901
  dsc->dsc_creator = (char *)((void *)0);
#line 902
  dsc->dsc_date = (char *)((void *)0);
#line 903
  dsc->dsc_for = (char *)((void *)0);
#line 906
  dsc->max_error = (unsigned int )(sizeof(dsc_severity) / sizeof(int ) - 2UL);
#line 907
  dsc->severity = dsc_severity;
#line 911
  dsc->id = 0;
#line 912
  dsc->scan_section = 0;
#line 913
  dsc->doseps_end = 0UL;
#line 914
  dsc->page_chunk_length = 0U;
#line 915
  dsc->file_length = 0UL;
#line 916
  dsc->skip_document = 0;
#line 917
  dsc->skip_bytes = 0;
#line 918
  dsc->skip_lines = 0;
#line 919
  dsc->skip_pjl = 0;
#line 920
  dsc->begin_font_count = 0;
#line 921
  dsc->begin_feature_count = 0;
#line 922
  dsc->begin_resource_count = 0;
#line 923
  dsc->begin_procset_count = 0;
#line 925
  dsc->data_length = 0U;
#line 926
  dsc->data_index = 0U;
#line 927
  dsc->data_offset = 0UL;
#line 929
  dsc->eof = 0;
#line 931
  dsc->line = (char *)0;
#line 932
  dsc->line_length = 0U;
#line 933
  dsc->eol = 0;
#line 934
  dsc->last_cr = 0;
#line 935
  dsc->line_count = 1U;
#line 936
  dsc->long_line = 0;
#line 937
  memset((void *)(dsc->last_line), 0, sizeof(dsc->last_line));
#line 939
  dsc->string = dsc->string_head;
  }
  {
#line 940
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 940
    if (! ((unsigned long )dsc->string != (unsigned long )((CDSCSTRING *)((void *)0)))) {
#line 940
      goto while_break___1;
    }
#line 941
    if ((dsc->string)->data) {
      {
#line 942
      dsc_memfree(dsc, (void *)(dsc->string)->data);
      }
    }
    {
#line 943
    dsc->string_head = dsc->string;
#line 944
    dsc->string = (dsc->string)->next;
#line 945
    dsc_memfree(dsc, (void *)dsc->string_head);
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 947
  dsc->string_head = (CDSCSTRING *)((void *)0);
#line 948
  dsc->string = (CDSCSTRING *)((void *)0);
#line 953
  if (dsc->hires_bbox) {
    {
#line 954
    dsc_memfree(dsc, (void *)dsc->hires_bbox);
    }
  }
#line 955
  dsc->hires_bbox = (CDSCFBBOX *)((void *)0);
#line 956
  if (dsc->crop_box) {
    {
#line 957
    dsc_memfree(dsc, (void *)dsc->crop_box);
    }
  }
#line 958
  dsc->crop_box = (CDSCFBBOX *)((void *)0);
#line 960
  if (dsc->dcs2) {
#line 962
    this_dcs = dsc->dcs2;
    {
#line 963
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 963
      if (! this_dcs) {
#line 963
        goto while_break___2;
      }
      {
#line 964
      next_dcs = this_dcs->next;
#line 966
      dsc_memfree(dsc, (void *)this_dcs);
#line 967
      this_dcs = next_dcs;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
#line 969
    dsc->dcs2 = (CDCS2 *)((void *)0);
  }
#line 971
  if (dsc->colours) {
#line 973
    this_colour = dsc->colours;
    {
#line 974
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 974
      if (! this_colour) {
#line 974
        goto while_break___3;
      }
      {
#line 975
      next_colour = this_colour->next;
#line 977
      dsc_memfree(dsc, (void *)this_colour);
#line 978
      this_colour = next_colour;
      }
    }
    while_break___3: /* CIL Label */ ;
    }
#line 980
    dsc->colours = (CDSCCOLOUR *)((void *)0);
  }
#line 983
  if (dsc->macbin) {
    {
#line 984
    dsc_memfree(dsc, (void *)dsc->macbin);
    }
  }
#line 985
  dsc->macbin = (CDSCMACBIN *)((void *)0);
#line 987
  dsc->worst_error = (CDSC_MESSAGE_SEVERITY )-1;
#line 988
  return;
}
}
#line 998 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/dscparse.c"
static void dsc_section_join(unsigned long begin , unsigned long *pend , unsigned long **pplast ) 
{ 


  {
#line 1001
  if (begin) {
#line 1002
    *(*pplast) = begin;
  }
#line 1003
  if (*pend > begin) {
#line 1004
    *pplast = pend;
  }
#line 1005
  return;
}
}
#line 1009 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/dscparse.c"
static int dsc_read_line(CDSC *dsc ) 
{ 
  char *p ;
  char *last ;
  int cnt ;
  int tmp ;
  unsigned int tmp___0 ;
  int tmp___1 ;
  char begindata[257] ;
  int cnt___0 ;
  char const   *numberof ;
  char const   *bytesorlines ;
  char *tmp___2 ;
  char *tmp___3 ;
  int rc ;
  int tmp___4 ;
  int tmp___5 ;
  int cnt___1 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;

  {
#line 1013
  dsc->line = (char *)((void *)0);
#line 1015
  if (dsc->eof) {
#line 1017
    dsc->line = dsc->data + dsc->data_index;
#line 1018
    dsc->line_length = dsc->data_length - dsc->data_index;
#line 1019
    dsc->data_index = dsc->data_length;
#line 1020
    return ((int )dsc->line_length);
  }
#line 1023
  if (dsc->file_length) {
#line 1023
    if (dsc->data_offset + (unsigned long )dsc->data_index >= dsc->file_length) {
#line 1027
      dsc->line = dsc->data + dsc->data_index;
#line 1028
      dsc->line_length = dsc->data_length - dsc->data_index;
#line 1029
      dsc->data_index = dsc->data_length;
#line 1030
      return ((int )dsc->line_length);
    }
  }
#line 1033
  if (dsc->doseps_end) {
#line 1033
    if (dsc->data_offset + (unsigned long )dsc->data_index >= dsc->doseps_end) {
#line 1037
      dsc->line = dsc->data + dsc->data_index;
#line 1038
      dsc->line_length = dsc->data_length - dsc->data_index;
#line 1039
      dsc->data_index = dsc->data_length;
#line 1040
      return ((int )dsc->line_length);
    }
  }
#line 1044
  if (dsc->skip_bytes) {
#line 1045
    if (dsc->skip_bytes < (int )(dsc->data_length - dsc->data_index)) {
#line 1045
      tmp = dsc->skip_bytes;
    } else {
#line 1045
      tmp = (int )(dsc->data_length - dsc->data_index);
    }
#line 1045
    cnt = tmp;
#line 1047
    dsc->skip_bytes -= cnt;
#line 1048
    dsc->data_index += (unsigned int )cnt;
#line 1049
    if (dsc->skip_bytes != 0) {
#line 1050
      return (0);
    }
  }
  {
#line 1053
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1054
    dsc->line = dsc->data + dsc->data_index;
#line 1055
    last = dsc->data + dsc->data_length;
#line 1056
    if (dsc->data_index == dsc->data_length) {
#line 1057
      dsc->line_length = 0U;
#line 1058
      return (0);
    }
#line 1060
    if (dsc->eol) {
#line 1062
      (dsc->line_count) ++;
#line 1063
      if (dsc->skip_lines) {
#line 1064
        (dsc->skip_lines) --;
      }
    }
#line 1068
    if (dsc->last_cr) {
#line 1068
      if ((int )*(dsc->line + 0) == 10) {
#line 1069
        (dsc->data_index) ++;
#line 1070
        (dsc->line) ++;
      }
    }
#line 1072
    dsc->last_cr = 0;
#line 1075
    dsc->eol = 0;
#line 1076
    p = dsc->line;
    {
#line 1076
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1076
      if (! ((unsigned long )p < (unsigned long )last)) {
#line 1076
        goto while_break___0;
      }
#line 1077
      if ((int )*p == 13) {
#line 1078
        p ++;
#line 1079
        if ((unsigned long )p < (unsigned long )last) {
#line 1079
          if ((int )*p == 10) {
#line 1080
            p ++;
          } else {
#line 1082
            dsc->last_cr = 1;
          }
        } else {
#line 1082
          dsc->last_cr = 1;
        }
#line 1083
        dsc->eol = 1;
#line 1084
        goto while_break___0;
      }
#line 1086
      if ((int )*p == 10) {
#line 1087
        p ++;
#line 1088
        dsc->eol = 1;
#line 1089
        goto while_break___0;
      }
#line 1091
      if ((int )*p == 26) {
#line 1092
        dsc->eol = 1;
      }
#line 1076
      p ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1095
    if (dsc->eol == 0) {
#line 1097
      if ((unsigned long )(dsc->data_length - dsc->data_index) < sizeof(dsc->data) / 2UL) {
#line 1099
        dsc->line_length = 0U;
#line 1100
        return (0);
      }
    }
#line 1103
    tmp___0 = (unsigned int )((int )(p - dsc->line));
#line 1103
    dsc->line_length = tmp___0;
#line 1103
    dsc->data_index += tmp___0;
#line 1053
    if (dsc->skip_lines) {
#line 1053
      if (! dsc->line_length) {
#line 1053
        goto while_break;
      }
    } else {
#line 1053
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1106
  if (dsc->line_length == 0U) {
#line 1107
    return (0);
  }
#line 1109
  if ((int )*(dsc->line + 0) == 37) {
#line 1109
    if ((int )*(dsc->line + 1) == 37) {
#line 1111
      if (dsc->skip_document) {
#line 1111
        if (dsc->line_length) {
          {
#line 1111
          tmp___1 = strncmp((char const   *)dsc->line, "%%EndDocument", sizeof("%%EndDocument") - 1UL);
          }
#line 1111
          if (tmp___1 == 0) {
#line 1113
            (dsc->skip_document) --;
          }
        }
      }
      {
#line 1117
      tmp___8 = strncmp((char const   *)dsc->line, "%%BeginData:", sizeof("%%BeginData:") - 1UL);
      }
#line 1117
      if (tmp___8 == 0) {
#line 1126
        cnt___0 = (int )dsc->line_length;
#line 1127
        if ((unsigned long )dsc->line_length > sizeof(begindata) - 1UL) {
#line 1128
          cnt___0 = (int )(sizeof(begindata) - 1UL);
        }
        {
#line 1129
        memcpy((void */* __restrict  */)(begindata), (void const   */* __restrict  */)dsc->line,
               (size_t )cnt___0);
#line 1130
        begindata[cnt___0] = (char )'\000';
#line 1131
        tmp___2 = strtok((char */* __restrict  */)(begindata + 12), (char const   */* __restrict  */)" \r\n");
#line 1131
        numberof = (char const   *)tmp___2;
#line 1132
        strtok((char */* __restrict  */)((void *)0), (char const   */* __restrict  */)" \r\n");
#line 1133
        tmp___3 = strtok((char */* __restrict  */)((void *)0), (char const   */* __restrict  */)" \r\n");
#line 1133
        bytesorlines = (char const   *)tmp___3;
        }
#line 1134
        if ((unsigned long )bytesorlines == (unsigned long )((void *)0)) {
#line 1135
          bytesorlines = "Bytes";
        }
#line 1137
        if ((unsigned long )numberof == (unsigned long )((void *)0)) {
#line 1137
          goto _L___0;
        } else
#line 1137
        if ((unsigned long )bytesorlines == (unsigned long )((void *)0)) {
          _L___0: /* CIL Label */ 
          {
#line 1140
          tmp___4 = dsc_error(dsc, 15U, dsc->line, dsc->line_length);
#line 1140
          rc = tmp___4;
          }
          {
#line 1144
          if (rc == 1) {
#line 1144
            goto case_1;
          }
#line 1144
          if (rc == 0) {
#line 1144
            goto case_1;
          }
#line 1146
          if (rc == 2) {
#line 1146
            goto case_2;
          }
#line 1142
          goto switch_break;
          case_1: /* CIL Label */ 
          case_0: /* CIL Label */ 
#line 1145
          goto switch_break;
          case_2: /* CIL Label */ 
#line 1147
          return (0);
          switch_break: /* CIL Label */ ;
          }
        } else {
          {
#line 1151
          cnt___0 = atoi(numberof);
          }
#line 1152
          if (cnt___0) {
#line 1153
            if (bytesorlines) {
              {
#line 1153
              tmp___5 = dsc_stricmp(bytesorlines, "Lines");
              }
#line 1153
              if (tmp___5 == 0) {
#line 1155
                if (dsc->skip_lines == 0) {
#line 1157
                  dsc->skip_lines = cnt___0 + 1;
                }
              } else {
#line 1153
                goto _L;
              }
            } else
            _L: /* CIL Label */ 
#line 1164
            if (dsc->skip_bytes == 0) {
#line 1166
              dsc->skip_bytes = cnt___0;
            }
          }
        }
      } else {
        {
#line 1173
        tmp___7 = strncmp((char const   *)dsc->line, "%%BeginBinary:", sizeof("%%BeginBinary:") - 1UL);
        }
#line 1173
        if (tmp___7 == 0) {
          {
#line 1175
          tmp___6 = dsc_get_int((char const   *)(dsc->line + 14), dsc->line_length - 14U,
                                (unsigned int *)((void *)0));
#line 1175
          cnt___1 = tmp___6;
          }
#line 1177
          if (dsc->skip_bytes == 0) {
#line 1179
            dsc->skip_bytes = cnt___1;
          }
        }
      }
    }
  }
#line 1184
  if ((int )*(dsc->line + 0) == 37) {
#line 1184
    if ((int )*(dsc->line + 1) == 37) {
      {
#line 1184
      tmp___9 = strncmp((char const   *)dsc->line, "%%BeginDocument:", sizeof("%%BeginDocument:") - 1UL);
      }
#line 1184
      if (tmp___9 == 0) {
#line 1187
        (dsc->skip_document) ++;
      }
    }
  }
#line 1190
  if (! dsc->long_line) {
#line 1190
    if (dsc->line_length > 255U) {
      {
#line 1191
      dsc_error(dsc, 14U, dsc->line, dsc->line_length);
#line 1192
      dsc->long_line = 1;
      }
    }
  }
#line 1195
  return ((int )dsc->line_length);
}
}
#line 1200 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/dscparse.c"
static void dsc_save_line(CDSC *dsc ) 
{ 
  int len ;
  unsigned long tmp ;

  {
#line 1203
  if (sizeof(dsc->last_line) < (unsigned long )dsc->line_length) {
#line 1203
    tmp = sizeof(dsc->last_line);
  } else {
#line 1203
    tmp = (unsigned long )dsc->line_length;
  }
  {
#line 1203
  len = (int )tmp;
#line 1204
  memcpy((void */* __restrict  */)(dsc->last_line), (void const   */* __restrict  */)dsc->line,
         (size_t )len);
  }
#line 1205
  return;
}
}
#line 1208 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/dscparse.c"
static void dsc_unknown(CDSC *dsc ) 
{ 
  char line[255] ;
  unsigned int length ;
  unsigned int tmp ;

  {
#line 1211
  if (dsc->debug_print_fn) {
#line 1213
    if (254U < dsc->line_length) {
#line 1213
      tmp = 254U;
    } else {
#line 1213
      tmp = dsc->line_length;
    }
    {
#line 1213
    length = tmp;
#line 1214
    sprintf((char */* __restrict  */)(line), (char const   */* __restrict  */)"Unknown in %s section at line %d:\n  ",
            dsc_scan_section_name[dsc->scan_section], dsc->line_count);
#line 1216
    dsc_debug_print(dsc, (char const   *)(line));
#line 1217
    strncpy((char */* __restrict  */)(line), (char const   */* __restrict  */)dsc->line,
            (size_t )length);
#line 1218
    line[length] = (char )'\000';
#line 1219
    dsc_debug_print(dsc, (char const   *)(line));
#line 1220
    dsc_debug_print(dsc, "\n");
    }
  }
#line 1222
  return;
}
}
#line 1225 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/dscparse.c"
static GSBOOL dsc_is_section(char *line ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 1228
  if ((int )*(line + 0) == 37) {
#line 1228
    if (! ((int )*(line + 1) == 37)) {
#line 1229
      return (0);
    }
  } else {
#line 1229
    return (0);
  }
  {
#line 1230
  tmp = strncmp((char const   *)line, "%%BeginPreview", sizeof("%%BeginPreview") - 1UL);
  }
#line 1230
  if (tmp == 0) {
#line 1231
    return (1);
  }
  {
#line 1232
  tmp___0 = strncmp((char const   *)line, "%%BeginDefaults", sizeof("%%BeginDefaults") - 1UL);
  }
#line 1232
  if (tmp___0 == 0) {
#line 1233
    return (1);
  }
  {
#line 1234
  tmp___1 = strncmp((char const   *)line, "%%BeginProlog", sizeof("%%BeginProlog") - 1UL);
  }
#line 1234
  if (tmp___1 == 0) {
#line 1235
    return (1);
  }
  {
#line 1236
  tmp___2 = strncmp((char const   *)line, "%%BeginSetup", sizeof("%%BeginSetup") - 1UL);
  }
#line 1236
  if (tmp___2 == 0) {
#line 1237
    return (1);
  }
  {
#line 1238
  tmp___3 = strncmp((char const   *)line, "%%Page:", sizeof("%%Page:") - 1UL);
  }
#line 1238
  if (tmp___3 == 0) {
#line 1239
    return (1);
  }
  {
#line 1240
  tmp___4 = strncmp((char const   *)line, "%%Trailer", sizeof("%%Trailer") - 1UL);
  }
#line 1240
  if (tmp___4 == 0) {
#line 1241
    return (1);
  }
  {
#line 1242
  tmp___5 = strncmp((char const   *)line, "%%EOF", sizeof("%%EOF") - 1UL);
  }
#line 1242
  if (tmp___5 == 0) {
#line 1243
    return (1);
  }
#line 1244
  return (0);
}
}
#line 1248 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/dscparse.c"
static GSDWORD dsc_get_dword(unsigned char const   *buf ) 
{ 
  GSDWORD dw ;

  {
#line 1252
  dw = (GSDWORD )*(buf + 0);
#line 1253
  dw += (GSDWORD )*(buf + 1) << 8;
#line 1254
  dw += (GSDWORD )*(buf + 2) << 16;
#line 1255
  dw += (GSDWORD )*(buf + 3) << 24;
#line 1256
  return (dw);
}
}
#line 1259 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/dscparse.c"
static GSWORD dsc_get_word(unsigned char const   *buf ) 
{ 
  GSWORD w ;

  {
#line 1263
  w = (GSWORD )*(buf + 0);
#line 1264
  w |= (GSWORD )((int const   )*(buf + 1) << 8);
#line 1265
  return (w);
}
}
#line 1269 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/dscparse.c"
static GSDWORD dsc_get_bigendian_dword(unsigned char const   *buf ) 
{ 
  GSDWORD dw ;

  {
#line 1273
  dw = (GSDWORD )*(buf + 3);
#line 1274
  dw += (GSDWORD )*(buf + 2) << 8;
#line 1275
  dw += (GSDWORD )*(buf + 1) << 16;
#line 1276
  dw += (GSDWORD )*(buf + 0) << 24;
#line 1277
  return (dw);
}
}
#line 1280 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/dscparse.c"
static GSWORD dsc_get_bigendian_word(unsigned char const   *buf ) 
{ 
  GSWORD w ;

  {
#line 1284
  w = (GSWORD )*(buf + 1);
#line 1285
  w |= (GSWORD )((int const   )*(buf + 0) << 8);
#line 1286
  return (w);
}
}
#line 1289 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/dscparse.c"
static int dsc_read_doseps(CDSC *dsc ) 
{ 
  unsigned char *line ;
  CDSCDOSEPS *tmp ;
  void *tmp___0 ;

  {
  {
#line 1292
  line = (unsigned char *)dsc->line;
#line 1293
  tmp___0 = dsc_memalloc(dsc, sizeof(CDSCDOSEPS ));
#line 1293
  tmp = (CDSCDOSEPS *)tmp___0;
#line 1293
  dsc->doseps = tmp;
  }
#line 1293
  if ((unsigned long )tmp == (unsigned long )((void *)0)) {
#line 1294
    return (-1);
  }
  {
#line 1296
  (dsc->doseps)->ps_begin = dsc_get_dword((unsigned char const   *)(line + 4));
#line 1297
  (dsc->doseps)->ps_length = dsc_get_dword((unsigned char const   *)(line + 8));
#line 1298
  (dsc->doseps)->wmf_begin = dsc_get_dword((unsigned char const   *)(line + 12));
#line 1299
  (dsc->doseps)->wmf_length = dsc_get_dword((unsigned char const   *)(line + 16));
#line 1300
  (dsc->doseps)->tiff_begin = dsc_get_dword((unsigned char const   *)(line + 20));
#line 1301
  (dsc->doseps)->tiff_length = dsc_get_dword((unsigned char const   *)(line + 24));
#line 1302
  (dsc->doseps)->checksum = dsc_get_word((unsigned char const   *)(line + 28));
  }
#line 1304
  if (dsc->file_length) {
#line 1304
    if ((dsc->doseps)->ps_begin + (dsc->doseps)->ps_length > dsc->file_length) {
#line 1311
      (dsc->doseps)->ps_length = dsc->file_length - (dsc->doseps)->ps_begin;
    }
  }
#line 1315
  dsc->doseps_end = (dsc->doseps)->ps_begin + (dsc->doseps)->ps_length;
#line 1318
  dsc->data_index -= dsc->line_length - 30U;
#line 1320
  dsc->line_count = 0U;
#line 1322
  dsc->skip_bytes = (int )((dsc->doseps)->ps_begin - 30UL);
#line 1324
  if ((dsc->doseps)->tiff_begin) {
#line 1325
    dsc->preview = 2U;
  }
#line 1326
  if ((dsc->doseps)->wmf_begin) {
#line 1327
    dsc->preview = 3U;
  }
#line 1329
  return (0);
}
}
#line 1333 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/dscparse.c"
static int dsc_read_macbin(CDSC *dsc ) 
{ 
  unsigned char *line ;
  CDSCMACBIN *tmp ;
  void *tmp___0 ;

  {
  {
#line 1336
  line = (unsigned char *)dsc->line;
#line 1337
  tmp___0 = dsc_memalloc(dsc, sizeof(CDSCMACBIN ));
#line 1337
  tmp = (CDSCMACBIN *)tmp___0;
#line 1337
  dsc->macbin = tmp;
  }
#line 1337
  if ((unsigned long )tmp == (unsigned long )((void *)0)) {
#line 1339
    return (-1);
  }
  {
#line 1341
  (dsc->macbin)->data_begin = (GSDWORD )128;
#line 1342
  (dsc->macbin)->data_length = dsc_get_bigendian_dword((unsigned char const   *)(line + 83));
#line 1343
  (dsc->macbin)->resource_begin = (((dsc->macbin)->data_begin + (dsc->macbin)->data_length) + 127UL) & 0xffffffffffffff80UL;
#line 1345
  (dsc->macbin)->resource_length = dsc_get_bigendian_dword((unsigned char const   *)(line + 87));
  }
#line 1351
  if (dsc->file_length) {
#line 1351
    if ((dsc->macbin)->resource_begin + (dsc->macbin)->resource_length > dsc->file_length) {
#line 1354
      return (-1);
    }
  }
#line 1357
  dsc->doseps_end = (dsc->macbin)->data_begin + (dsc->macbin)->data_length;
#line 1360
  dsc->data_index -= dsc->line_length - 128U;
#line 1362
  dsc->line_count = 0U;
#line 1364
  dsc->preview = 4U;
#line 1366
  return (0);
}
}
#line 1370 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/dscparse.c"
static int dsc_read_applesingle(CDSC *dsc ) 
{ 
  GSDWORD EntryID ;
  GSDWORD Offset ;
  GSDWORD Length ;
  GSWORD entries ;
  int index___0 ;
  int header ;
  int i ;
  unsigned char *line ;
  CDSCMACBIN *tmp ;
  void *tmp___0 ;

  {
  {
#line 1381
  line = (unsigned char *)dsc->line;
#line 1382
  tmp___0 = dsc_memalloc(dsc, sizeof(CDSCMACBIN ));
#line 1382
  tmp = (CDSCMACBIN *)tmp___0;
#line 1382
  dsc->macbin = tmp;
  }
#line 1382
  if ((unsigned long )tmp == (unsigned long )((void *)0)) {
#line 1384
    return (-1);
  }
  {
#line 1385
  entries = dsc_get_bigendian_word((unsigned char const   *)(line + 24));
#line 1386
  i = 0;
  }
  {
#line 1386
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1386
    if (! (i < (int )entries)) {
#line 1386
      goto while_break;
    }
    {
#line 1387
    index___0 = 26 + i * 12;
#line 1388
    EntryID = dsc_get_bigendian_dword((unsigned char const   *)(line + index___0));
#line 1389
    Offset = dsc_get_bigendian_dword((unsigned char const   *)((line + index___0) + 4));
#line 1390
    Length = dsc_get_bigendian_dword((unsigned char const   *)((line + index___0) + 8));
    }
#line 1391
    if (EntryID == 1UL) {
#line 1393
      (dsc->macbin)->data_begin = Offset;
#line 1394
      (dsc->macbin)->data_length = Length;
    } else
#line 1396
    if (EntryID == 2UL) {
#line 1398
      (dsc->macbin)->resource_begin = Offset;
#line 1399
      (dsc->macbin)->resource_length = Length;
    }
#line 1386
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1403
  if (dsc->file_length) {
#line 1403
    if ((dsc->macbin)->resource_begin + (dsc->macbin)->resource_length > dsc->file_length) {
#line 1406
      return (-1);
    }
  }
#line 1408
  if (dsc->file_length) {
#line 1408
    if ((dsc->macbin)->data_begin + (dsc->macbin)->data_length > dsc->file_length) {
#line 1411
      return (-1);
    }
  }
#line 1414
  dsc->doseps_end = (dsc->macbin)->data_begin + (dsc->macbin)->data_length;
#line 1416
  header = (int )(26U + entries * 12U);
#line 1418
  dsc->data_index -= dsc->line_length - (unsigned int )header;
#line 1420
  dsc->line_count = 0U;
#line 1422
  dsc->skip_bytes = (int )((dsc->macbin)->data_begin - (GSDWORD )header);
#line 1424
  dsc->preview = 4U;
#line 1426
  return (0);
}
}
#line 1429 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/dscparse.c"
static int dsc_parse_pages(CDSC *dsc ) 
{ 
  int ip ;
  int io ;
  unsigned int i ;
  char *p ;
  int n ;
  int rc ;
  int tmp ;
  int rc___0 ;
  int tmp___0 ;
  int tmp___2 ;
  int rc___1 ;
  int tmp___3 ;
  int rc___2 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
#line 1436
  if (dsc->page_pages != 0U) {
#line 1436
    if (dsc->scan_section == 1) {
      {
#line 1437
      tmp = dsc_error(dsc, 10U, dsc->line, dsc->line_length);
#line 1437
      rc = tmp;
      }
      {
#line 1441
      if (rc == 1) {
#line 1441
        goto case_1;
      }
#line 1441
      if (rc == 0) {
#line 1441
        goto case_1;
      }
#line 1443
      if (rc == 2) {
#line 1443
        goto case_2;
      }
#line 1439
      goto switch_break;
      case_1: /* CIL Label */ 
      case_0: /* CIL Label */ 
#line 1442
      return (0);
      case_2: /* CIL Label */ 
#line 1444
      return (1);
      switch_break: /* CIL Label */ ;
      }
    }
  }
#line 1447
  if (dsc->page_pages != 0U) {
#line 1447
    if (dsc->scan_section == 13) {
      {
#line 1448
      tmp___0 = dsc_error(dsc, 11U, dsc->line, dsc->line_length);
#line 1448
      rc___0 = tmp___0;
      }
      {
#line 1452
      if (rc___0 == 1) {
#line 1452
        goto case_1___0;
      }
#line 1452
      if (rc___0 == 0) {
#line 1452
        goto case_1___0;
      }
#line 1454
      if (rc___0 == 2) {
#line 1454
        goto case_2___0;
      }
#line 1450
      goto switch_break___0;
      case_1___0: /* CIL Label */ 
      case_0___0: /* CIL Label */ 
#line 1453
      goto switch_break___0;
      case_2___0: /* CIL Label */ 
#line 1455
      return (1);
      switch_break___0: /* CIL Label */ ;
      }
    }
  }
  {
#line 1459
  tmp___2 = strncmp((char const   *)dsc->line, "%%+", sizeof("%%+") - 1UL);
  }
#line 1459
  if (tmp___2 == 0) {
#line 1459
    n = 3;
  } else {
#line 1459
    n = 8;
  }
  {
#line 1460
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1460
    if (! ((int )*(dsc->line + n) == 32)) {
#line 1460
      if (! ((int )*(dsc->line + n) == 9)) {
#line 1460
        goto while_break;
      }
    }
#line 1461
    n ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1462
  p = dsc->line + n;
#line 1463
  tmp___6 = strncmp((char const   *)p, "atend", sizeof("atend") - 1UL);
  }
#line 1463
  if (tmp___6 == 0) {
#line 1464
    if (dsc->scan_section != 1) {
      {
#line 1465
      dsc_unknown(dsc);
      }
    } else {
      {
#line 1467
      tmp___3 = dsc_error(dsc, 9U, dsc->line, dsc->line_length);
#line 1467
      rc___1 = tmp___3;
      }
      {
#line 1470
      if (rc___1 == 0) {
#line 1470
        goto case_0___1;
      }
#line 1474
      if (rc___1 == 1) {
#line 1474
        goto case_1___1;
      }
#line 1477
      if (rc___1 == 2) {
#line 1477
        goto case_2___1;
      }
#line 1469
      goto switch_break___1;
      case_0___1: /* CIL Label */ 
#line 1473
      goto switch_break___1;
      case_1___1: /* CIL Label */ 
#line 1476
      goto switch_break___1;
      case_2___1: /* CIL Label */ 
#line 1478
      return (1);
      switch_break___1: /* CIL Label */ ;
      }
    }
  } else {
    {
#line 1482
    tmp___5 = strncmp((char const   *)p, "(atend)", sizeof("(atend)") - 1UL);
    }
#line 1482
    if (tmp___5 == 0) {
#line 1483
      if (dsc->scan_section != 1) {
        {
#line 1484
        dsc_unknown(dsc);
        }
      }
    } else {
      {
#line 1489
      ip = dsc_get_int((char const   *)(dsc->line + n), dsc->line_length - (unsigned int )n,
                       & i);
      }
#line 1490
      if (i) {
        {
#line 1491
        n = (int )((unsigned int )n + i);
#line 1492
        dsc->page_pages = (unsigned int )ip;
#line 1493
        io = dsc_get_int((char const   *)(dsc->line + n), dsc->line_length - (unsigned int )n,
                         & i);
        }
#line 1494
        if (i) {
#line 1497
          if (dsc->page_order == 0U) {
            {
#line 1499
            if (io == -1) {
#line 1499
              goto case_neg_1;
            }
#line 1502
            if (io == 0) {
#line 1502
              goto case_0___2;
            }
#line 1505
            if (io == 1) {
#line 1505
              goto case_1___2;
            }
#line 1498
            goto switch_break___2;
            case_neg_1: /* CIL Label */ 
#line 1500
            dsc->page_order = 2U;
#line 1501
            goto switch_break___2;
            case_0___2: /* CIL Label */ 
#line 1503
            dsc->page_order = 3U;
#line 1504
            goto switch_break___2;
            case_1___2: /* CIL Label */ 
#line 1506
            dsc->page_order = 1U;
#line 1507
            goto switch_break___2;
            switch_break___2: /* CIL Label */ ;
            }
          }
        }
      } else {
        {
#line 1512
        tmp___4 = dsc_error(dsc, 15U, dsc->line, dsc->line_length);
#line 1512
        rc___2 = tmp___4;
        }
        {
#line 1516
        if (rc___2 == 1) {
#line 1516
          goto case_1___3;
        }
#line 1516
        if (rc___2 == 0) {
#line 1516
          goto case_1___3;
        }
#line 1519
        if (rc___2 == 2) {
#line 1519
          goto case_2___2;
        }
#line 1514
        goto switch_break___3;
        case_1___3: /* CIL Label */ 
        case_0___3: /* CIL Label */ 
#line 1518
        goto switch_break___3;
        case_2___2: /* CIL Label */ 
#line 1520
        return (1);
        switch_break___3: /* CIL Label */ ;
        }
      }
    }
  }
#line 1524
  return (0);
}
}
#line 1527 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/dscparse.c"
static int dsc_parse_bounding_box(CDSC *dsc , CDSCBBOX **pbbox , int offset ) 
{ 
  unsigned int i ;
  unsigned int n ;
  int llx ;
  int lly ;
  int urx ;
  int ury ;
  float fllx ;
  float flly ;
  float furx ;
  float fury ;
  char *p ;
  int rc ;
  int tmp ;
  int rc___0 ;
  int tmp___0 ;
  int rc___1 ;
  int tmp___1 ;
  int rc___2 ;
  int tmp___2 ;
  void *tmp___3 ;
  int rc___3 ;
  int tmp___4 ;
  void *tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;

  {
#line 1535
  if ((unsigned long )*pbbox != (unsigned long )((void *)0)) {
#line 1535
    if (dsc->scan_section == 1) {
      {
#line 1536
      tmp = dsc_error(dsc, 10U, dsc->line, dsc->line_length);
#line 1536
      rc = tmp;
      }
      {
#line 1540
      if (rc == 1) {
#line 1540
        goto case_1;
      }
#line 1540
      if (rc == 0) {
#line 1540
        goto case_1;
      }
#line 1542
      if (rc == 2) {
#line 1542
        goto case_2;
      }
#line 1538
      goto switch_break;
      case_1: /* CIL Label */ 
      case_0: /* CIL Label */ 
#line 1541
      return (0);
      case_2: /* CIL Label */ 
#line 1543
      return (1);
      switch_break: /* CIL Label */ ;
      }
    }
  }
#line 1546
  if ((unsigned long )*pbbox != (unsigned long )((void *)0)) {
#line 1546
    if (dsc->scan_section == 11) {
      {
#line 1547
      tmp___0 = dsc_error(dsc, 10U, dsc->line, dsc->line_length);
#line 1547
      rc___0 = tmp___0;
      }
      {
#line 1551
      if (rc___0 == 1) {
#line 1551
        goto case_1___0;
      }
#line 1551
      if (rc___0 == 0) {
#line 1551
        goto case_1___0;
      }
#line 1553
      if (rc___0 == 2) {
#line 1553
        goto case_2___0;
      }
#line 1549
      goto switch_break___0;
      case_1___0: /* CIL Label */ 
      case_0___0: /* CIL Label */ 
#line 1552
      return (0);
      case_2___0: /* CIL Label */ 
#line 1554
      return (1);
      switch_break___0: /* CIL Label */ ;
      }
    }
  }
#line 1557
  if ((unsigned long )*pbbox != (unsigned long )((void *)0)) {
#line 1557
    if (dsc->scan_section == 13) {
      {
#line 1558
      tmp___1 = dsc_error(dsc, 11U, dsc->line, dsc->line_length);
#line 1558
      rc___1 = tmp___1;
      }
      {
#line 1562
      if (rc___1 == 1) {
#line 1562
        goto case_1___1;
      }
#line 1562
      if (rc___1 == 0) {
#line 1562
        goto case_1___1;
      }
#line 1564
      if (rc___1 == 2) {
#line 1564
        goto case_2___1;
      }
#line 1560
      goto switch_break___1;
      case_1___1: /* CIL Label */ 
      case_0___1: /* CIL Label */ 
#line 1563
      goto switch_break___1;
      case_2___1: /* CIL Label */ 
#line 1565
      return (1);
      switch_break___1: /* CIL Label */ ;
      }
    }
  }
#line 1568
  if ((unsigned long )*pbbox != (unsigned long )((void *)0)) {
    {
#line 1569
    dsc_memfree(dsc, (void *)*pbbox);
#line 1570
    *pbbox = (CDSCBBOX *)((void *)0);
    }
  }
  {
#line 1575
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1575
    if (! ((int )*(dsc->line + offset) == 32)) {
#line 1575
      if (! ((int )*(dsc->line + offset) == 9)) {
#line 1575
        goto while_break;
      }
    }
#line 1576
    offset ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1577
  p = dsc->line + offset;
#line 1579
  tmp___7 = strncmp((char const   *)p, "atend", sizeof("atend") - 1UL);
  }
#line 1579
  if (tmp___7 == 0) {
#line 1580
    if (dsc->scan_section == 13) {
      {
#line 1581
      dsc_unknown(dsc);
      }
    } else {
      {
#line 1583
      tmp___2 = dsc_error(dsc, 9U, dsc->line, dsc->line_length);
#line 1583
      rc___2 = tmp___2;
      }
      {
#line 1586
      if (rc___2 == 0) {
#line 1586
        goto case_0___2;
      }
#line 1590
      if (rc___2 == 1) {
#line 1590
        goto case_1___2;
      }
#line 1593
      if (rc___2 == 2) {
#line 1593
        goto case_2___2;
      }
#line 1585
      goto switch_break___2;
      case_0___2: /* CIL Label */ 
#line 1589
      goto switch_break___2;
      case_1___2: /* CIL Label */ 
#line 1592
      goto switch_break___2;
      case_2___2: /* CIL Label */ 
#line 1594
      return (1);
      switch_break___2: /* CIL Label */ ;
      }
    }
  } else {
    {
#line 1598
    tmp___6 = strncmp((char const   *)p, "(atend)", sizeof("(atend)") - 1UL);
    }
#line 1598
    if (tmp___6 == 0) {
#line 1599
      if (dsc->scan_section == 13) {
        {
#line 1600
        dsc_unknown(dsc);
        }
      }
    } else {
      {
#line 1605
      ury = 0;
#line 1605
      urx = ury;
#line 1605
      lly = urx;
#line 1606
      n = (unsigned int )offset;
#line 1607
      llx = dsc_get_int((char const   *)(dsc->line + n), dsc->line_length - n, & i);
#line 1608
      n += i;
      }
#line 1609
      if (i) {
        {
#line 1610
        lly = dsc_get_int((char const   *)(dsc->line + n), dsc->line_length - n, & i);
        }
      }
#line 1611
      n += i;
#line 1612
      if (i) {
        {
#line 1613
        urx = dsc_get_int((char const   *)(dsc->line + n), dsc->line_length - n, & i);
        }
      }
#line 1614
      n += i;
#line 1615
      if (i) {
        {
#line 1616
        ury = dsc_get_int((char const   *)(dsc->line + n), dsc->line_length - n, & i);
        }
      }
#line 1617
      if (i) {
        {
#line 1618
        tmp___3 = dsc_memalloc(dsc, sizeof(CDSCBBOX ));
#line 1618
        *pbbox = (CDSCBBOX *)tmp___3;
        }
#line 1619
        if ((unsigned long )*pbbox == (unsigned long )((void *)0)) {
#line 1620
          return (-1);
        }
#line 1621
        (*pbbox)->llx = llx;
#line 1622
        (*pbbox)->lly = lly;
#line 1623
        (*pbbox)->urx = urx;
#line 1624
        (*pbbox)->ury = ury;
      } else {
        {
#line 1627
        tmp___4 = dsc_error(dsc, 0U, dsc->line, dsc->line_length);
#line 1627
        rc___3 = tmp___4;
        }
        {
#line 1630
        if (rc___3 == 0) {
#line 1630
          goto case_0___3;
        }
#line 1654
        if (rc___3 == 1) {
#line 1654
          goto case_1___3;
        }
#line 1656
        if (rc___3 == 2) {
#line 1656
          goto case_2___3;
        }
#line 1629
        goto switch_break___3;
        case_0___3: /* CIL Label */ 
        {
#line 1631
        fury = (float )0.0;
#line 1631
        furx = fury;
#line 1631
        flly = furx;
#line 1632
        n = (unsigned int )offset;
#line 1633
        n += i;
#line 1634
        fllx = dsc_get_real((char const   *)(dsc->line + n), dsc->line_length - n,
                            & i);
#line 1635
        n += i;
        }
#line 1636
        if (i) {
          {
#line 1637
          flly = dsc_get_real((char const   *)(dsc->line + n), dsc->line_length - n,
                              & i);
          }
        }
#line 1638
        n += i;
#line 1639
        if (i) {
          {
#line 1640
          furx = dsc_get_real((char const   *)(dsc->line + n), dsc->line_length - n,
                              & i);
          }
        }
#line 1641
        n += i;
#line 1642
        if (i) {
          {
#line 1643
          fury = dsc_get_real((char const   *)(dsc->line + n), dsc->line_length - n,
                              & i);
          }
        }
#line 1644
        if (i) {
          {
#line 1645
          tmp___5 = dsc_memalloc(dsc, sizeof(CDSCBBOX ));
#line 1645
          *pbbox = (CDSCBBOX *)tmp___5;
          }
#line 1646
          if ((unsigned long )*pbbox == (unsigned long )((void *)0)) {
#line 1647
            return (-1);
          }
#line 1648
          (*pbbox)->llx = (int )fllx;
#line 1649
          (*pbbox)->lly = (int )flly;
#line 1650
          (*pbbox)->urx = (int )((double )furx + 0.999);
#line 1651
          (*pbbox)->ury = (int )((double )fury + 0.999);
        }
#line 1653
        return (0);
        case_1___3: /* CIL Label */ 
#line 1655
        return (0);
        case_2___3: /* CIL Label */ 
#line 1657
        return (1);
        switch_break___3: /* CIL Label */ ;
        }
      }
    }
  }
#line 1661
  return (0);
}
}
#line 1664 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/dscparse.c"
static int dsc_parse_float_bounding_box(CDSC *dsc , CDSCFBBOX **pbbox , int offset ) 
{ 
  unsigned int i ;
  unsigned int n ;
  float fllx ;
  float flly ;
  float furx ;
  float fury ;
  char *p ;
  int rc ;
  int tmp ;
  int rc___0 ;
  int tmp___0 ;
  int rc___1 ;
  int tmp___1 ;
  int rc___2 ;
  int tmp___2 ;
  void *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 1673
  if ((unsigned long )*pbbox != (unsigned long )((void *)0)) {
#line 1673
    if (dsc->scan_section == 1) {
      {
#line 1674
      tmp = dsc_error(dsc, 10U, dsc->line, dsc->line_length);
#line 1674
      rc = tmp;
      }
      {
#line 1678
      if (rc == 1) {
#line 1678
        goto case_1;
      }
#line 1678
      if (rc == 0) {
#line 1678
        goto case_1;
      }
#line 1680
      if (rc == 2) {
#line 1680
        goto case_2;
      }
#line 1676
      goto switch_break;
      case_1: /* CIL Label */ 
      case_0: /* CIL Label */ 
#line 1679
      return (0);
      case_2: /* CIL Label */ 
#line 1681
      return (1);
      switch_break: /* CIL Label */ ;
      }
    }
  }
#line 1684
  if ((unsigned long )*pbbox != (unsigned long )((void *)0)) {
#line 1684
    if (dsc->scan_section == 11) {
      {
#line 1685
      tmp___0 = dsc_error(dsc, 10U, dsc->line, dsc->line_length);
#line 1685
      rc___0 = tmp___0;
      }
      {
#line 1689
      if (rc___0 == 1) {
#line 1689
        goto case_1___0;
      }
#line 1689
      if (rc___0 == 0) {
#line 1689
        goto case_1___0;
      }
#line 1691
      if (rc___0 == 2) {
#line 1691
        goto case_2___0;
      }
#line 1687
      goto switch_break___0;
      case_1___0: /* CIL Label */ 
      case_0___0: /* CIL Label */ 
#line 1690
      return (0);
      case_2___0: /* CIL Label */ 
#line 1692
      return (1);
      switch_break___0: /* CIL Label */ ;
      }
    }
  }
#line 1695
  if ((unsigned long )*pbbox != (unsigned long )((void *)0)) {
#line 1695
    if (dsc->scan_section == 13) {
      {
#line 1696
      tmp___1 = dsc_error(dsc, 11U, dsc->line, dsc->line_length);
#line 1696
      rc___1 = tmp___1;
      }
      {
#line 1700
      if (rc___1 == 1) {
#line 1700
        goto case_1___1;
      }
#line 1700
      if (rc___1 == 0) {
#line 1700
        goto case_1___1;
      }
#line 1702
      if (rc___1 == 2) {
#line 1702
        goto case_2___1;
      }
#line 1698
      goto switch_break___1;
      case_1___1: /* CIL Label */ 
      case_0___1: /* CIL Label */ 
#line 1701
      goto switch_break___1;
      case_2___1: /* CIL Label */ 
#line 1703
      return (1);
      switch_break___1: /* CIL Label */ ;
      }
    }
  }
#line 1706
  if ((unsigned long )*pbbox != (unsigned long )((void *)0)) {
    {
#line 1707
    dsc_memfree(dsc, (void *)*pbbox);
#line 1708
    *pbbox = (CDSCFBBOX *)((void *)0);
    }
  }
  {
#line 1713
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1713
    if (! ((int )*(dsc->line + offset) == 32)) {
#line 1713
      if (! ((int )*(dsc->line + offset) == 9)) {
#line 1713
        goto while_break;
      }
    }
#line 1714
    offset ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1715
  p = dsc->line + offset;
#line 1717
  tmp___5 = strncmp((char const   *)p, "atend", sizeof("atend") - 1UL);
  }
#line 1717
  if (tmp___5 == 0) {
#line 1718
    if (dsc->scan_section == 13) {
      {
#line 1719
      dsc_unknown(dsc);
      }
    } else {
      {
#line 1721
      tmp___2 = dsc_error(dsc, 9U, dsc->line, dsc->line_length);
#line 1721
      rc___2 = tmp___2;
      }
      {
#line 1724
      if (rc___2 == 0) {
#line 1724
        goto case_0___2;
      }
#line 1728
      if (rc___2 == 1) {
#line 1728
        goto case_1___2;
      }
#line 1731
      if (rc___2 == 2) {
#line 1731
        goto case_2___2;
      }
#line 1723
      goto switch_break___2;
      case_0___2: /* CIL Label */ 
#line 1727
      goto switch_break___2;
      case_1___2: /* CIL Label */ 
#line 1730
      goto switch_break___2;
      case_2___2: /* CIL Label */ 
#line 1732
      return (1);
      switch_break___2: /* CIL Label */ ;
      }
    }
  } else {
    {
#line 1736
    tmp___4 = strncmp((char const   *)p, "(atend)", sizeof("(atend)") - 1UL);
    }
#line 1736
    if (tmp___4 == 0) {
#line 1737
      if (dsc->scan_section == 13) {
        {
#line 1738
        dsc_unknown(dsc);
        }
      }
    } else {
      {
#line 1743
      fury = (float )0.0;
#line 1743
      furx = fury;
#line 1743
      flly = furx;
#line 1744
      n = (unsigned int )offset;
#line 1745
      fllx = dsc_get_real((char const   *)(dsc->line + n), dsc->line_length - n, & i);
#line 1746
      n += i;
      }
#line 1747
      if (i) {
        {
#line 1748
        flly = dsc_get_real((char const   *)(dsc->line + n), dsc->line_length - n,
                            & i);
        }
      }
#line 1749
      n += i;
#line 1750
      if (i) {
        {
#line 1751
        furx = dsc_get_real((char const   *)(dsc->line + n), dsc->line_length - n,
                            & i);
        }
      }
#line 1752
      n += i;
#line 1753
      if (i) {
        {
#line 1754
        fury = dsc_get_real((char const   *)(dsc->line + n), dsc->line_length - n,
                            & i);
        }
      }
#line 1755
      if (i) {
        {
#line 1756
        tmp___3 = dsc_memalloc(dsc, sizeof(CDSCFBBOX ));
#line 1756
        *pbbox = (CDSCFBBOX *)tmp___3;
        }
#line 1757
        if ((unsigned long )*pbbox == (unsigned long )((void *)0)) {
#line 1758
          return (-1);
        }
#line 1759
        (*pbbox)->fllx = fllx;
#line 1760
        (*pbbox)->flly = flly;
#line 1761
        (*pbbox)->furx = furx;
#line 1762
        (*pbbox)->fury = fury;
      }
    }
  }
#line 1765
  return (0);
}
}
#line 1768 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/dscparse.c"
static int dsc_parse_orientation(CDSC *dsc , unsigned int *porientation , int offset ) 
{ 
  char *p ;
  int rc ;
  int tmp ;
  int rc___0 ;
  int tmp___0 ;
  int rc___1 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 1772
  if (dsc->page_orientation != 0U) {
#line 1772
    if (dsc->scan_section == 1) {
      {
#line 1774
      tmp = dsc_error(dsc, 10U, dsc->line, dsc->line_length);
#line 1774
      rc = tmp;
      }
      {
#line 1778
      if (rc == 1) {
#line 1778
        goto case_1;
      }
#line 1778
      if (rc == 0) {
#line 1778
        goto case_1;
      }
#line 1780
      if (rc == 2) {
#line 1780
        goto case_2;
      }
#line 1776
      goto switch_break;
      case_1: /* CIL Label */ 
      case_0: /* CIL Label */ 
#line 1779
      return (0);
      case_2: /* CIL Label */ 
#line 1781
      return (1);
      switch_break: /* CIL Label */ ;
      }
    }
  }
#line 1784
  if (dsc->page_orientation != 0U) {
#line 1784
    if (dsc->scan_section == 13) {
      {
#line 1786
      tmp___0 = dsc_error(dsc, 11U, dsc->line, dsc->line_length);
#line 1786
      rc___0 = tmp___0;
      }
      {
#line 1790
      if (rc___0 == 1) {
#line 1790
        goto case_1___0;
      }
#line 1790
      if (rc___0 == 0) {
#line 1790
        goto case_1___0;
      }
#line 1792
      if (rc___0 == 2) {
#line 1792
        goto case_2___0;
      }
#line 1788
      goto switch_break___0;
      case_1___0: /* CIL Label */ 
      case_0___0: /* CIL Label */ 
#line 1791
      goto switch_break___0;
      case_2___0: /* CIL Label */ 
#line 1793
      return (1);
      switch_break___0: /* CIL Label */ ;
      }
    }
  }
#line 1796
  p = dsc->line + offset;
  {
#line 1797
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1797
    if (! ((int )*p == 32)) {
#line 1797
      if (! ((int )*p == 9)) {
#line 1797
        goto while_break;
      }
    }
#line 1798
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1799
  tmp___5 = strncmp((char const   *)p, "atend", sizeof("atend") - 1UL);
  }
#line 1799
  if (tmp___5 == 0) {
#line 1800
    if (dsc->scan_section == 13) {
      {
#line 1801
      dsc_unknown(dsc);
      }
    } else {
      {
#line 1803
      tmp___1 = dsc_error(dsc, 9U, dsc->line, dsc->line_length);
#line 1803
      rc___1 = tmp___1;
      }
      {
#line 1806
      if (rc___1 == 0) {
#line 1806
        goto case_0___1;
      }
#line 1810
      if (rc___1 == 1) {
#line 1810
        goto case_1___1;
      }
#line 1813
      if (rc___1 == 2) {
#line 1813
        goto case_2___1;
      }
#line 1805
      goto switch_break___1;
      case_0___1: /* CIL Label */ 
#line 1809
      goto switch_break___1;
      case_1___1: /* CIL Label */ 
#line 1812
      goto switch_break___1;
      case_2___1: /* CIL Label */ 
#line 1814
      return (1);
      switch_break___1: /* CIL Label */ ;
      }
    }
  } else {
    {
#line 1818
    tmp___4 = strncmp((char const   *)p, "(atend)", sizeof("(atend)") - 1UL);
    }
#line 1818
    if (tmp___4 == 0) {
#line 1819
      if (dsc->scan_section == 13) {
        {
#line 1820
        dsc_unknown(dsc);
        }
      }
    } else {
      {
#line 1824
      tmp___3 = strncmp((char const   *)p, "Portrait", sizeof("Portrait") - 1UL);
      }
#line 1824
      if (tmp___3 == 0) {
#line 1825
        *porientation = 1U;
      } else {
        {
#line 1827
        tmp___2 = strncmp((char const   *)p, "Landscape", sizeof("Landscape") - 1UL);
        }
#line 1827
        if (tmp___2 == 0) {
#line 1828
          *porientation = 2U;
        } else {
          {
#line 1831
          dsc_unknown(dsc);
          }
        }
      }
    }
  }
#line 1833
  return (0);
}
}
#line 1836 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/dscparse.c"
static int dsc_parse_order(CDSC *dsc ) 
{ 
  char *p ;
  int rc ;
  int tmp ;
  int rc___0 ;
  int tmp___0 ;
  int tmp___2 ;
  int tmp___3 ;
  int rc___1 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;

  {
#line 1840
  if (dsc->page_order != 0U) {
#line 1840
    if (dsc->scan_section == 1) {
      {
#line 1842
      tmp = dsc_error(dsc, 10U, dsc->line, dsc->line_length);
#line 1842
      rc = tmp;
      }
      {
#line 1846
      if (rc == 1) {
#line 1846
        goto case_1;
      }
#line 1846
      if (rc == 0) {
#line 1846
        goto case_1;
      }
#line 1848
      if (rc == 2) {
#line 1848
        goto case_2;
      }
#line 1844
      goto switch_break;
      case_1: /* CIL Label */ 
      case_0: /* CIL Label */ 
#line 1847
      return (0);
      case_2: /* CIL Label */ 
#line 1849
      return (1);
      switch_break: /* CIL Label */ ;
      }
    }
  }
#line 1852
  if (dsc->page_order != 0U) {
#line 1852
    if (dsc->scan_section == 13) {
      {
#line 1854
      tmp___0 = dsc_error(dsc, 11U, dsc->line, dsc->line_length);
#line 1854
      rc___0 = tmp___0;
      }
      {
#line 1858
      if (rc___0 == 1) {
#line 1858
        goto case_1___0;
      }
#line 1858
      if (rc___0 == 0) {
#line 1858
        goto case_1___0;
      }
#line 1860
      if (rc___0 == 2) {
#line 1860
        goto case_2___0;
      }
#line 1856
      goto switch_break___0;
      case_1___0: /* CIL Label */ 
      case_0___0: /* CIL Label */ 
#line 1859
      goto switch_break___0;
      case_2___0: /* CIL Label */ 
#line 1861
      return (1);
      switch_break___0: /* CIL Label */ ;
      }
    }
  }
  {
#line 1865
  tmp___3 = strncmp((char const   *)dsc->line, "%%+", sizeof("%%+") - 1UL);
  }
#line 1865
  if (tmp___3 == 0) {
#line 1865
    tmp___2 = 3;
  } else {
#line 1865
    tmp___2 = 13;
  }
#line 1865
  p = dsc->line + tmp___2;
  {
#line 1866
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1866
    if (! ((int )*p == 32)) {
#line 1866
      if (! ((int )*p == 9)) {
#line 1866
        goto while_break;
      }
    }
#line 1867
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1868
  tmp___9 = strncmp((char const   *)p, "atend", sizeof("atend") - 1UL);
  }
#line 1868
  if (tmp___9 == 0) {
#line 1869
    if (dsc->scan_section == 13) {
      {
#line 1870
      dsc_unknown(dsc);
      }
    } else {
      {
#line 1872
      tmp___4 = dsc_error(dsc, 9U, dsc->line, dsc->line_length);
#line 1872
      rc___1 = tmp___4;
      }
      {
#line 1875
      if (rc___1 == 0) {
#line 1875
        goto case_0___1;
      }
#line 1879
      if (rc___1 == 1) {
#line 1879
        goto case_1___1;
      }
#line 1882
      if (rc___1 == 2) {
#line 1882
        goto case_2___1;
      }
#line 1874
      goto switch_break___1;
      case_0___1: /* CIL Label */ 
#line 1878
      goto switch_break___1;
      case_1___1: /* CIL Label */ 
#line 1881
      goto switch_break___1;
      case_2___1: /* CIL Label */ 
#line 1883
      return (1);
      switch_break___1: /* CIL Label */ ;
      }
    }
  } else {
    {
#line 1887
    tmp___8 = strncmp((char const   *)p, "(atend)", sizeof("(atend)") - 1UL);
    }
#line 1887
    if (tmp___8 == 0) {
#line 1888
      if (dsc->scan_section == 13) {
        {
#line 1889
        dsc_unknown(dsc);
        }
      }
    } else {
      {
#line 1893
      tmp___7 = strncmp((char const   *)p, "Ascend", sizeof("Ascend") - 1UL);
      }
#line 1893
      if (tmp___7 == 0) {
#line 1894
        dsc->page_order = 1U;
      } else {
        {
#line 1896
        tmp___6 = strncmp((char const   *)p, "Descend", sizeof("Descend") - 1UL);
        }
#line 1896
        if (tmp___6 == 0) {
#line 1897
          dsc->page_order = 2U;
        } else {
          {
#line 1899
          tmp___5 = strncmp((char const   *)p, "Special", sizeof("Special") - 1UL);
          }
#line 1899
          if (tmp___5 == 0) {
#line 1900
            dsc->page_order = 3U;
          } else {
            {
#line 1903
            dsc_unknown(dsc);
            }
          }
        }
      }
    }
  }
#line 1905
  return (0);
}
}
#line 1909 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/dscparse.c"
static int dsc_parse_media(CDSC *dsc , CDSCMEDIA const   **page_media ) 
{ 
  char media_name[256] ;
  int n ;
  int tmp___0 ;
  int tmp___1 ;
  unsigned int i ;
  int tmp___2 ;
  char *tmp___3 ;

  {
  {
#line 1913
  tmp___1 = strncmp((char const   *)dsc->line, "%%+", sizeof("%%+") - 1UL);
  }
#line 1913
  if (tmp___1 == 0) {
#line 1913
    tmp___0 = 3;
  } else {
#line 1913
    tmp___0 = 12;
  }
  {
#line 1913
  n = tmp___0;
#line 1916
  tmp___3 = dsc_copy_string(media_name, (unsigned int )(sizeof(media_name) - 1UL),
                            dsc->line + n, dsc->line_length - (unsigned int )n, (unsigned int *)((void *)0));
  }
#line 1916
  if (tmp___3) {
#line 1918
    i = 0U;
    {
#line 1918
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1918
      if (! (i < dsc->media_count)) {
#line 1918
        goto while_break;
      }
#line 1919
      if ((*(dsc->media + i))->name) {
        {
#line 1919
        tmp___2 = dsc_stricmp((char const   *)(media_name), (*(dsc->media + i))->name);
        }
#line 1919
        if (tmp___2 == 0) {
#line 1921
          *page_media = (CDSCMEDIA const   *)*(dsc->media + i);
#line 1922
          return (0);
        }
      }
#line 1918
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 1926
  dsc_unknown(dsc);
  }
#line 1928
  return (0);
}
}
#line 1932 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/dscparse.c"
static int dsc_parse_document_media(CDSC *dsc ) 
{ 
  unsigned int i ;
  unsigned int n ;
  CDSCMEDIA lmedia ;
  GSBOOL blank_line ;
  int tmp ;
  int tmp___0 ;
  char name[256] ;
  char colour[256] ;
  char type[256] ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;

  {
  {
#line 1939
  tmp___0 = strncmp((char const   *)dsc->line, "%%DocumentMedia:", sizeof("%%DocumentMedia:") - 1UL);
  }
#line 1939
  if (tmp___0 == 0) {
#line 1940
    n = 16U;
  } else {
    {
#line 1941
    tmp = strncmp((char const   *)dsc->line, "%%+", sizeof("%%+") - 1UL);
    }
#line 1941
    if (tmp == 0) {
#line 1942
      n = 3U;
    } else {
#line 1944
      return (-1);
    }
  }
#line 1947
  blank_line = 1;
#line 1948
  i = n;
  {
#line 1948
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1948
    if (! (i < dsc->line_length)) {
#line 1948
      goto while_break;
    }
#line 1949
    if (! ((int )*(dsc->line + i) == 32)) {
#line 1949
      if (! ((int )*(dsc->line + i) == 9)) {
#line 1949
        if (! ((int )*(dsc->line + i) == 13)) {
#line 1949
          if (! ((int )*(dsc->line + i) == 10)) {
#line 1950
            blank_line = 0;
#line 1951
            goto while_break;
          }
        }
      }
    }
#line 1948
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1955
  if (! blank_line) {
    {
#line 1959
    lmedia.type = (char const   *)((char *)((void *)0));
#line 1959
    lmedia.colour = lmedia.type;
#line 1959
    lmedia.name = lmedia.colour;
#line 1960
    lmedia.weight = (float )0;
#line 1960
    lmedia.height = lmedia.weight;
#line 1960
    lmedia.width = lmedia.height;
#line 1961
    lmedia.mediabox = (CDSCBBOX *)((void *)0);
#line 1962
    tmp___1 = dsc_copy_string(name, (unsigned int )sizeof(name), dsc->line + n, dsc->line_length - n,
                              & i);
#line 1962
    lmedia.name = (char const   *)tmp___1;
#line 1964
    n += i;
    }
#line 1965
    if (i) {
      {
#line 1966
      lmedia.width = dsc_get_real((char const   *)(dsc->line + n), dsc->line_length - n,
                                  & i);
      }
    }
#line 1967
    n += i;
#line 1968
    if (i) {
      {
#line 1969
      lmedia.height = dsc_get_real((char const   *)(dsc->line + n), dsc->line_length - n,
                                   & i);
      }
    }
#line 1970
    n += i;
#line 1971
    if (i) {
      {
#line 1972
      lmedia.weight = dsc_get_real((char const   *)(dsc->line + n), dsc->line_length - n,
                                   & i);
      }
    }
#line 1973
    n += i;
#line 1974
    if (i) {
      {
#line 1975
      tmp___2 = dsc_copy_string(colour, (unsigned int )sizeof(colour), dsc->line + n,
                                dsc->line_length - n, & i);
#line 1975
      lmedia.colour = (char const   *)tmp___2;
      }
    }
#line 1977
    n += i;
#line 1978
    if (i) {
      {
#line 1979
      tmp___3 = dsc_copy_string(type, (unsigned int )sizeof(type), dsc->line + n,
                                dsc->line_length - n, & i);
#line 1979
      lmedia.type = (char const   *)tmp___3;
      }
    }
#line 1982
    if (i == 0U) {
      {
#line 1983
      dsc_unknown(dsc);
      }
    } else {
      {
#line 1985
      tmp___4 = dsc_add_media(dsc, & lmedia);
      }
#line 1985
      if (tmp___4) {
#line 1986
        return (-1);
      }
    }
  }
#line 1989
  return (0);
}
}
#line 1995 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/dscparse.c"
static int dsc_parse_viewing_orientation(CDSC *dsc , CDSCCTM **pctm ) 
{ 
  CDSCCTM ctm ;
  unsigned int i ;
  unsigned int n ;
  int tmp___0 ;
  void *tmp___1 ;

  {
#line 2001
  if ((unsigned long )*pctm != (unsigned long )((void *)0)) {
    {
#line 2002
    dsc_memfree(dsc, (void *)*pctm);
#line 2003
    *pctm = (CDSCCTM *)((void *)0);
    }
  }
  {
#line 2006
  tmp___0 = strncmp((char const   *)dsc->line, "%%+", sizeof("%%+") - 1UL);
  }
#line 2006
  if (tmp___0 == 0) {
#line 2006
    n = 3U;
  } else {
#line 2006
    n = 21U;
  }
  {
#line 2007
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2007
    if (! ((int )*(dsc->line + n) == 32)) {
#line 2007
      if (! ((int )*(dsc->line + n) == 9)) {
#line 2007
        goto while_break;
      }
    }
#line 2008
    n ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2010
  ctm.yy = (float )0.0;
#line 2010
  ctm.yx = ctm.yy;
#line 2010
  ctm.xy = ctm.yx;
#line 2011
  ctm.xx = dsc_get_real((char const   *)(dsc->line + n), dsc->line_length - n, & i);
#line 2012
  n += i;
  }
#line 2013
  if (i) {
    {
#line 2014
    ctm.xy = dsc_get_real((char const   *)(dsc->line + n), dsc->line_length - n, & i);
    }
  }
#line 2015
  n += i;
#line 2016
  if (i) {
    {
#line 2017
    ctm.yx = dsc_get_real((char const   *)(dsc->line + n), dsc->line_length - n, & i);
    }
  }
#line 2018
  n += i;
#line 2019
  if (i) {
    {
#line 2020
    ctm.yy = dsc_get_real((char const   *)(dsc->line + n), dsc->line_length - n, & i);
    }
  }
#line 2021
  if (i == 0U) {
    {
#line 2022
    dsc_unknown(dsc);
    }
  } else {
    {
#line 2025
    tmp___1 = dsc_memalloc(dsc, sizeof(CDSCCTM ));
#line 2025
    *pctm = (CDSCCTM *)tmp___1;
    }
#line 2026
    if ((unsigned long )*pctm == (unsigned long )((void *)0)) {
#line 2027
      return (-1);
    }
#line 2028
    *(*pctm) = ctm;
  }
#line 2030
  return (0);
}
}
#line 2038 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/dscparse.c"
static int dsc_scan_type(CDSC *dsc ) 
{ 
  unsigned char *p ;
  unsigned char *line ;
  int length ;
  int cnt ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  GSDWORD version ;
  GSWORD entries ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;

  {
#line 2042
  line = (unsigned char *)(dsc->data + dsc->data_index);
#line 2043
  length = (int )(dsc->data_length - dsc->data_index);
#line 2058
  if (length == 0) {
#line 2059
    return (11);
  }
#line 2063
  if (dsc->skip_bytes) {
#line 2064
    if (dsc->skip_bytes < (int )(dsc->data_length - dsc->data_index)) {
#line 2064
      tmp = dsc->skip_bytes;
    } else {
#line 2064
      tmp = (int )(dsc->data_length - dsc->data_index);
    }
#line 2064
    cnt = tmp;
#line 2066
    dsc->skip_bytes -= cnt;
#line 2067
    dsc->data_index += (unsigned int )cnt;
#line 2068
    length -= cnt;
#line 2069
    line += cnt;
#line 2070
    if (dsc->skip_bytes != 0) {
#line 2071
      return (11);
    }
  }
#line 2074
  if (dsc->skip_pjl) {
    {
#line 2076
    while (1) {
      while_continue: /* CIL Label */ ;
#line 2076
      if (! (length >= 2)) {
#line 2076
        goto while_break;
      }
      {
#line 2077
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 2077
        if (length) {
#line 2077
          if ((int )*(line + 0) == 13) {
#line 2077
            goto while_break___0;
          } else
#line 2077
          if ((int )*(line + 0) == 10) {
#line 2077
            goto while_break___0;
          }
        } else {
#line 2077
          goto while_break___0;
        }
#line 2079
        line ++;
#line 2080
        (dsc->data_index) ++;
#line 2081
        length --;
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 2083
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 2083
        if (length >= 2) {
#line 2083
          if ((int )*(line + 0) == 13) {
#line 2083
            goto _L;
          } else
#line 2083
          if ((int )*(line + 0) == 10) {
            _L: /* CIL Label */ 
#line 2083
            if (! ((int )*(line + 1) == 13)) {
#line 2083
              if (! ((int )*(line + 1) == 10)) {
#line 2083
                goto while_break___1;
              }
            }
          } else {
#line 2083
            goto while_break___1;
          }
        } else {
#line 2083
          goto while_break___1;
        }
#line 2085
        line ++;
#line 2086
        (dsc->data_index) ++;
#line 2087
        length --;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 2089
      if (length < 2) {
#line 2090
        return (11);
      }
#line 2092
      if ((int )*(line + 0) == 13) {
#line 2092
        goto _L___0;
      } else
#line 2092
      if ((int )*(line + 0) == 10) {
        _L___0: /* CIL Label */ 
#line 2092
        if ((int )*(line + 1) == 37) {
#line 2093
          line ++;
#line 2094
          (dsc->data_index) ++;
#line 2095
          length --;
#line 2096
          dsc->skip_pjl = 0;
#line 2097
          goto while_break;
        } else {
#line 2100
          line ++;
#line 2101
          (dsc->data_index) ++;
#line 2102
          length --;
        }
      } else {
#line 2100
        line ++;
#line 2101
        (dsc->data_index) ++;
#line 2102
        length --;
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 2105
    if (dsc->skip_pjl) {
#line 2106
      return (11);
    }
  }
#line 2109
  if (length == 0) {
#line 2110
    return (11);
  }
#line 2112
  if ((int )*(line + 0) == 4) {
#line 2113
    line ++;
#line 2114
    (dsc->data_index) ++;
#line 2115
    length --;
#line 2116
    dsc->ctrld = 1;
  }
#line 2119
  if ((int )*(line + 0) == 27) {
#line 2121
    if (length < 9) {
#line 2122
      return (11);
    }
    {
#line 2123
    tmp___1 = strncmp((char const   *)line, "\033%-12345X", sizeof("\033%-12345X") - 1UL);
    }
#line 2123
    if (tmp___1 == 0) {
      {
#line 2124
      dsc->skip_pjl = 1;
#line 2125
      dsc->pjl = 1;
#line 2126
      dsc->data_index += 9U;
#line 2127
      tmp___0 = dsc_scan_type(dsc);
      }
#line 2127
      return (tmp___0);
    }
  }
#line 2131
  if ((int )*(line + 0) == 0) {
#line 2131
    if (length < 2) {
#line 2132
      return (11);
    }
  }
#line 2133
  if ((int )*(line + 0) == 0) {
#line 2133
    if ((int )*(line + 1) >= 1) {
#line 2133
      if ((int )*(line + 1) <= 63) {
#line 2133
        if (length < 128) {
#line 2134
          return (11);
        }
      }
    }
  }
#line 2135
  if ((int )*(line + 0) == 0) {
#line 2135
    if ((int )*(line + 1) == 5) {
#line 2135
      if (length < 4) {
#line 2136
        return (11);
      }
    }
  }
#line 2137
  if ((int )*(line + 0) == 197) {
#line 2137
    if (length < 4) {
#line 2138
      return (11);
    }
  }
#line 2140
  if ((int )*(line + 0) == 197) {
#line 2140
    if ((int )*(line + 1) == 208) {
#line 2140
      if ((int )*(line + 2) == 211) {
#line 2140
        if ((int )*(line + 3) == 198) {
#line 2144
          if (length < 30) {
#line 2145
            return (11);
          }
          {
#line 2146
          dsc->line = (char *)line;
#line 2147
          tmp___2 = dsc_read_doseps(dsc);
          }
#line 2147
          if (tmp___2) {
#line 2148
            return (-1);
          }
        } else {
#line 2140
          goto _L___15;
        }
      } else {
#line 2140
        goto _L___15;
      }
    } else {
#line 2140
      goto _L___15;
    }
  } else
  _L___15: /* CIL Label */ 
#line 2150
  if ((int )*(line + 0) == 0) {
#line 2150
    if ((int )*(line + 1) == 5) {
#line 2150
      if ((int )*(line + 2) == 22) {
#line 2150
        if ((int )*(line + 3) == 0) {
#line 2150
          goto _L___10;
        } else
#line 2150
        if ((int )*(line + 3) == 7) {
          _L___10: /* CIL Label */ 
#line 2155
          if (length < 26) {
#line 2156
            return (11);
          }
          {
#line 2157
          version = dsc_get_bigendian_dword((unsigned char const   *)(line + 4));
#line 2158
          entries = dsc_get_bigendian_word((unsigned char const   *)(line + 24));
          }
#line 2159
          if (version == 65536UL) {
#line 2159
            goto _L___1;
          } else
#line 2159
          if (version == 131072UL) {
            _L___1: /* CIL Label */ 
#line 2160
            if (length < (int )(26U + entries * 12U)) {
#line 2161
              return (11);
            }
            {
#line 2162
            dsc->line = (char *)line;
#line 2163
            tmp___3 = dsc_read_applesingle(dsc);
            }
#line 2163
            if (tmp___3) {
#line 2164
              return (-1);
            }
          }
        } else {
#line 2150
          goto _L___12;
        }
      } else {
#line 2150
        goto _L___12;
      }
    } else {
#line 2150
      goto _L___12;
    }
  } else
  _L___12: /* CIL Label */ 
#line 2167
  if ((int )*(line + 0) == 0) {
#line 2167
    if ((int )*(line + 1) >= 1) {
#line 2167
      if ((int )*(line + 1) <= 63) {
#line 2167
        if ((int )*(line + 74) == 0) {
#line 2167
          if ((int )*(line + 65) == 69) {
#line 2167
            if ((int )*(line + 66) == 80) {
#line 2167
              if ((int )*(line + 67) == 83) {
#line 2167
                if ((int )*(line + 68) == 70) {
                  {
#line 2173
                  dsc->line = (char *)line;
#line 2174
                  tmp___4 = dsc_read_macbin(dsc);
                  }
#line 2174
                  if (tmp___4) {
#line 2175
                    return (-1);
                  }
                } else {
#line 2167
                  goto _L___8;
                }
              } else {
#line 2167
                goto _L___8;
              }
            } else {
#line 2167
              goto _L___8;
            }
          } else {
#line 2167
            goto _L___8;
          }
        } else {
#line 2167
          goto _L___8;
        }
      } else {
#line 2167
        goto _L___8;
      }
    } else {
#line 2167
      goto _L___8;
    }
  } else {
    _L___8: /* CIL Label */ 
#line 2178
    if (length < 2) {
#line 2179
      return (11);
    }
#line 2180
    if ((int )*(line + 0) == 37) {
#line 2180
      if ((int )*(line + 1) == 80) {
#line 2181
        if (length < 5) {
#line 2182
          return (11);
        }
        {
#line 2183
        tmp___5 = strncmp((char const   *)line, "%PDF-", sizeof("%PDF-") - 1UL);
        }
#line 2183
        if (tmp___5 == 0) {
#line 2184
          dsc->pdf = 1;
#line 2185
          dsc->scan_section = 1;
#line 2186
          return (0);
        }
      }
    }
  }
  {
#line 2193
  tmp___6 = dsc_read_line(dsc);
  }
#line 2193
  if (tmp___6 <= 0) {
#line 2194
    return (11);
  }
  {
#line 2196
  dsc->dsc_version = dsc_add_line(dsc, (char const   *)dsc->line, dsc->line_length);
#line 2197
  tmp___8 = strncmp((char const   *)dsc->line, "%!PS-Adobe", sizeof("%!PS-Adobe") - 1UL);
  }
#line 2197
  if (tmp___8 == 0) {
#line 2198
    dsc->dsc = 1;
#line 2199
    dsc->begincomments = (dsc->data_offset + (unsigned long )dsc->data_index) - (unsigned long )dsc->line_length;
#line 2200
    if ((unsigned long )dsc->dsc_version == (unsigned long )((void *)0)) {
#line 2201
      return (-1);
    }
#line 2202
    p = (unsigned char *)dsc->line + 14;
    {
#line 2203
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 2203
      if (! ((int )*p == 32)) {
#line 2203
        if (! ((int )*p == 9)) {
#line 2203
          goto while_break___2;
        }
      }
#line 2204
      p ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 2205
    tmp___7 = strncmp((char const   *)p, "EPSF-", sizeof("EPSF-") - 1UL);
    }
#line 2205
    if (tmp___7 == 0) {
#line 2206
      dsc->epsf = 1;
    }
#line 2207
    dsc->scan_section = 1;
#line 2208
    return (200);
  }
  {
#line 2210
  tmp___9 = strncmp((char const   *)dsc->line, "%!", sizeof("%!") - 1UL);
  }
#line 2210
  if (tmp___9 == 0) {
#line 2211
    dsc->scan_section = 1;
#line 2212
    return (1);
  }
#line 2215
  dsc->scan_section = 1;
#line 2216
  return (1);
}
}
#line 2221 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/dscparse.c"
static int dsc_scan_comments(CDSC *dsc ) 
{ 
  char *line ;
  GSBOOL continued ;
  int tmp ;
  GSBOOL tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  unsigned int n ;
  int tmp___5 ;
  unsigned int i ;
  int ll ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  unsigned int n___0 ;
  int tmp___16 ;
  unsigned int count ;
  unsigned int i___0 ;
  char name[256] ;
  char *p ;
  CDSCMEDIA const   *m ;
  CDSCMEDIA lmedia ;
  int tmp___17 ;
  size_t tmp___18 ;
  char *tmp___19 ;
  int tmp___20 ;
  unsigned int n___1 ;
  int tmp___21 ;
  unsigned int count___0 ;
  unsigned int i___1 ;
  char type[256] ;
  char *p___0 ;
  CDSCMEDIA lmedia___0 ;
  int tmp___22 ;
  size_t tmp___23 ;
  char *tmp___24 ;
  unsigned int n___2 ;
  int tmp___25 ;
  unsigned int count___1 ;
  unsigned int i___2 ;
  char colour[256] ;
  char *p___1 ;
  CDSCMEDIA lmedia___1 ;
  int tmp___26 ;
  size_t tmp___27 ;
  char *tmp___28 ;
  unsigned int n___3 ;
  int tmp___29 ;
  unsigned int count___2 ;
  unsigned int i___3 ;
  float w ;
  CDSCMEDIA lmedia___2 ;
  int tmp___30 ;
  unsigned int n___4 ;
  int tmp___31 ;
  char *p___2 ;
  int tmp___32 ;
  int tmp___33 ;
  int tmp___34 ;
  int tmp___35 ;
  int tmp___36 ;
  int tmp___37 ;
  int tmp___38 ;
  int tmp___39 ;
  int tmp___40 ;
  int tmp___41 ;
  int tmp___42 ;
  int tmp___43 ;
  int tmp___44 ;
  int tmp___45 ;
  int tmp___46 ;
  int tmp___47 ;
  int tmp___48 ;
  int tmp___49 ;
  int tmp___50 ;
  int tmp___51 ;
  int tmp___52 ;
  int tmp___53 ;
  int tmp___54 ;
  int tmp___55 ;
  int tmp___56 ;
  int tmp___57 ;
  int tmp___58 ;
  int tmp___59 ;
  int tmp___60 ;
  int tmp___61 ;
  int tmp___62 ;
  int tmp___63 ;
  int tmp___64 ;
  int tmp___65 ;
  int tmp___66 ;
  int tmp___67 ;
  int tmp___68 ;
  int tmp___69 ;

  {
  {
#line 2230
  line = dsc->line;
#line 2231
  continued = 0;
#line 2232
  dsc->id = 0;
#line 2233
  tmp___2 = strncmp((char const   *)line, "%%EndComments", sizeof("%%EndComments") - 1UL);
  }
#line 2233
  if (tmp___2 == 0) {
#line 2234
    dsc->id = 202;
#line 2235
    dsc->endcomments = dsc->data_offset + (unsigned long )dsc->data_index;
#line 2236
    dsc->scan_section = 2;
#line 2237
    return (0);
  } else {
    {
#line 2239
    tmp___1 = strncmp((char const   *)line, "%%BeginComments", sizeof("%%BeginComments") - 1UL);
    }
#line 2239
    if (tmp___1 == 0) {
#line 2241
      dsc->id = 201;
    } else {
      {
#line 2243
      tmp___0 = dsc_is_section(line);
      }
#line 2243
      if (tmp___0) {
#line 2244
        dsc->endcomments = (dsc->data_offset + (unsigned long )dsc->data_index) - (unsigned long )dsc->line_length;
#line 2245
        dsc->scan_section = 2;
#line 2246
        return (10);
      } else
#line 2248
      if ((int )*(line + 0) == 37) {
#line 2248
        if ((int )*(line + 1) == 32) {
#line 2249
          dsc->endcomments = (dsc->data_offset + (unsigned long )dsc->data_index) - (unsigned long )dsc->line_length;
#line 2250
          dsc->scan_section = 2;
#line 2251
          return (10);
        } else
#line 2248
        if ((int )*(line + 1) == 9) {
#line 2249
          dsc->endcomments = (dsc->data_offset + (unsigned long )dsc->data_index) - (unsigned long )dsc->line_length;
#line 2250
          dsc->scan_section = 2;
#line 2251
          return (10);
        } else
#line 2248
        if ((int )*(line + 1) == 13) {
#line 2249
          dsc->endcomments = (dsc->data_offset + (unsigned long )dsc->data_index) - (unsigned long )dsc->line_length;
#line 2250
          dsc->scan_section = 2;
#line 2251
          return (10);
        } else
#line 2248
        if ((int )*(line + 1) == 10) {
#line 2249
          dsc->endcomments = (dsc->data_offset + (unsigned long )dsc->data_index) - (unsigned long )dsc->line_length;
#line 2250
          dsc->scan_section = 2;
#line 2251
          return (10);
        } else {
#line 2248
          goto _L;
        }
      } else
      _L: /* CIL Label */ 
#line 2253
      if ((int )*(line + 0) != 37) {
#line 2254
        dsc->id = 0;
#line 2255
        dsc->endcomments = (dsc->data_offset + (unsigned long )dsc->data_index) - (unsigned long )dsc->line_length;
#line 2256
        dsc->scan_section = 2;
#line 2257
        return (10);
      } else {
        {
#line 2259
        tmp = strncmp((char const   *)line, "%%Begin", sizeof("%%Begin") - 1UL);
        }
#line 2259
        if (tmp == 0) {
#line 2260
          dsc->endcomments = (dsc->data_offset + (unsigned long )dsc->data_index) - (unsigned long )dsc->line_length;
#line 2261
          dsc->scan_section = 2;
#line 2262
          return (10);
        }
      }
    }
  }
  {
#line 2273
  tmp___3 = strncmp((char const   *)line, "%%+", sizeof("%%+") - 1UL);
  }
#line 2273
  if (tmp___3 == 0) {
#line 2274
    line = dsc->last_line;
#line 2275
    continued = 1;
  } else {
    {
#line 2278
    dsc_save_line(dsc);
    }
  }
  {
#line 2280
  tmp___69 = strncmp((char const   *)line, "%%Pages:", sizeof("%%Pages:") - 1UL);
  }
#line 2280
  if (tmp___69 == 0) {
    {
#line 2281
    dsc->id = 203;
#line 2282
    tmp___4 = dsc_parse_pages(dsc);
    }
#line 2282
    if (tmp___4 != 0) {
#line 2283
      return (-1);
    }
  } else {
    {
#line 2285
    tmp___68 = strncmp((char const   *)line, "%%Creator:", sizeof("%%Creator:") - 1UL);
    }
#line 2285
    if (tmp___68 == 0) {
      {
#line 2286
      dsc->id = 204;
#line 2287
      dsc->dsc_creator = dsc_add_line(dsc, (char const   *)(dsc->line + 10), dsc->line_length - 10U);
      }
#line 2288
      if ((unsigned long )dsc->dsc_creator == (unsigned long )((void *)0)) {
#line 2289
        return (-1);
      }
    } else {
      {
#line 2291
      tmp___67 = strncmp((char const   *)line, "%%CreationDate:", sizeof("%%CreationDate:") - 1UL);
      }
#line 2291
      if (tmp___67 == 0) {
        {
#line 2292
        dsc->id = 205;
#line 2293
        dsc->dsc_date = dsc_add_line(dsc, (char const   *)(dsc->line + 15), dsc->line_length - 15U);
        }
#line 2294
        if ((unsigned long )dsc->dsc_date == (unsigned long )((void *)0)) {
#line 2295
          return (-1);
        }
      } else {
        {
#line 2297
        tmp___66 = strncmp((char const   *)line, "%%Title:", sizeof("%%Title:") - 1UL);
        }
#line 2297
        if (tmp___66 == 0) {
          {
#line 2298
          dsc->id = 206;
#line 2299
          dsc->dsc_title = dsc_add_line(dsc, (char const   *)(dsc->line + 8), dsc->line_length - 8U);
          }
#line 2300
          if ((unsigned long )dsc->dsc_title == (unsigned long )((void *)0)) {
#line 2301
            return (-1);
          }
        } else {
          {
#line 2303
          tmp___65 = strncmp((char const   *)line, "%%For:", sizeof("%%For:") - 1UL);
          }
#line 2303
          if (tmp___65 == 0) {
            {
#line 2304
            dsc->id = 207;
#line 2305
            dsc->dsc_for = dsc_add_line(dsc, (char const   *)(dsc->line + 6), dsc->line_length - 6U);
            }
#line 2306
            if ((unsigned long )dsc->dsc_for == (unsigned long )((void *)0)) {
#line 2307
              return (-1);
            }
          } else {
            {
#line 2309
            tmp___64 = strncmp((char const   *)line, "%%LanguageLevel:", sizeof("%%LanguageLevel:") - 1UL);
            }
#line 2309
            if (tmp___64 == 0) {
#line 2310
              if (continued) {
#line 2310
                tmp___5 = 3;
              } else {
#line 2310
                tmp___5 = 16;
              }
              {
#line 2310
              n = (unsigned int )tmp___5;
#line 2313
              dsc->id = 208;
#line 2314
              ll = dsc_get_int((char const   *)(dsc->line + n), dsc->line_length - n,
                               & i);
              }
#line 2315
              if (i) {
#line 2316
                if (ll == 1) {
#line 2317
                  dsc->language_level = (unsigned int )ll;
                } else
#line 2316
                if (ll == 2) {
#line 2317
                  dsc->language_level = (unsigned int )ll;
                } else
#line 2316
                if (ll == 3) {
#line 2317
                  dsc->language_level = (unsigned int )ll;
                } else {
                  {
#line 2319
                  dsc_unknown(dsc);
                  }
                }
              } else {
                {
#line 2323
                dsc_unknown(dsc);
                }
              }
            } else {
              {
#line 2325
              tmp___63 = strncmp((char const   *)line, "%%BoundingBox:", sizeof("%%BoundingBox:") - 1UL);
              }
#line 2325
              if (tmp___63 == 0) {
#line 2326
                dsc->id = 209;
#line 2327
                if (continued) {
#line 2327
                  tmp___6 = 3;
                } else {
#line 2327
                  tmp___6 = 14;
                }
                {
#line 2327
                tmp___7 = dsc_parse_bounding_box(dsc, & dsc->bbox, tmp___6);
                }
#line 2327
                if (tmp___7) {
#line 2328
                  return (-1);
                }
              } else {
                {
#line 2330
                tmp___62 = strncmp((char const   *)line, "%%HiResBoundingBox:", sizeof("%%HiResBoundingBox:") - 1UL);
                }
#line 2330
                if (tmp___62 == 0) {
#line 2331
                  dsc->id = 221;
#line 2332
                  if (continued) {
#line 2332
                    tmp___8 = 3;
                  } else {
#line 2332
                    tmp___8 = 19;
                  }
                  {
#line 2332
                  tmp___9 = dsc_parse_float_bounding_box(dsc, & dsc->hires_bbox, tmp___8);
                  }
#line 2332
                  if (tmp___9) {
#line 2334
                    return (-1);
                  }
                } else {
                  {
#line 2336
                  tmp___61 = strncmp((char const   *)line, "%%CropBox:", sizeof("%%CropBox:") - 1UL);
                  }
#line 2336
                  if (tmp___61 == 0) {
#line 2337
                    dsc->id = 222;
#line 2338
                    if (continued) {
#line 2338
                      tmp___10 = 3;
                    } else {
#line 2338
                      tmp___10 = 10;
                    }
                    {
#line 2338
                    tmp___11 = dsc_parse_float_bounding_box(dsc, & dsc->crop_box,
                                                            tmp___10);
                    }
#line 2338
                    if (tmp___11) {
#line 2340
                      return (-1);
                    }
                  } else {
                    {
#line 2342
                    tmp___60 = strncmp((char const   *)line, "%%Orientation:", sizeof("%%Orientation:") - 1UL);
                    }
#line 2342
                    if (tmp___60 == 0) {
#line 2343
                      dsc->id = 210;
#line 2344
                      if (continued) {
#line 2344
                        tmp___12 = 3;
                      } else {
#line 2344
                        tmp___12 = 14;
                      }
                      {
#line 2344
                      tmp___13 = dsc_parse_orientation(dsc, & dsc->page_orientation,
                                                       tmp___12);
                      }
#line 2344
                      if (tmp___13) {
#line 2346
                        return (-1);
                      }
                    } else {
                      {
#line 2348
                      tmp___59 = strncmp((char const   *)line, "%%PageOrder:", sizeof("%%PageOrder:") - 1UL);
                      }
#line 2348
                      if (tmp___59 == 0) {
                        {
#line 2349
                        dsc->id = 211;
#line 2350
                        tmp___14 = dsc_parse_order(dsc);
                        }
#line 2350
                        if (tmp___14) {
#line 2351
                          return (-1);
                        }
                      } else {
                        {
#line 2353
                        tmp___58 = strncmp((char const   *)line, "%%DocumentMedia:",
                                           sizeof("%%DocumentMedia:") - 1UL);
                        }
#line 2353
                        if (tmp___58 == 0) {
                          {
#line 2354
                          dsc->id = 212;
#line 2355
                          tmp___15 = dsc_parse_document_media(dsc);
                          }
#line 2355
                          if (tmp___15) {
#line 2356
                            return (-1);
                          }
                        } else {
                          {
#line 2358
                          tmp___57 = strncmp((char const   *)line, "%%DocumentPaperSizes:",
                                             sizeof("%%DocumentPaperSizes:") - 1UL);
                          }
#line 2358
                          if (tmp___57 == 0) {
#line 2360
                            if (continued) {
#line 2360
                              tmp___16 = 3;
                            } else {
#line 2360
                              tmp___16 = 21;
                            }
#line 2360
                            n___0 = (unsigned int )tmp___16;
#line 2361
                            count = 0U;
#line 2362
                            i___0 = 1U;
#line 2365
                            dsc->id = 213;
                            {
#line 2366
                            while (1) {
                              while_continue: /* CIL Label */ ;
#line 2366
                              if (i___0) {
#line 2366
                                if ((int )*(dsc->line + n___0) != 13) {
#line 2366
                                  if (! ((int )*(dsc->line + n___0) != 10)) {
#line 2366
                                    goto while_break;
                                  }
                                } else {
#line 2366
                                  goto while_break;
                                }
                              } else {
#line 2366
                                goto while_break;
                              }
                              {
#line 2367
                              p = dsc_copy_string(name, (unsigned int )(sizeof(name) - 1UL),
                                                  dsc->line + n___0, dsc->line_length - n___0,
                                                  & i___0);
                              }
#line 2369
                              if (i___0) {
#line 2369
                                if (p) {
#line 2370
                                  m = dsc_known_media;
#line 2371
                                  if (count >= dsc->media_count) {
                                    {
#line 2374
                                    lmedia.name = (char const   *)p;
#line 2375
                                    lmedia.width = (float )595.0;
#line 2376
                                    lmedia.height = (float )842.0;
#line 2377
                                    lmedia.weight = (float )80.0;
#line 2378
                                    lmedia.colour = (char const   *)((void *)0);
#line 2379
                                    lmedia.type = (char const   *)((void *)0);
#line 2380
                                    lmedia.mediabox = (CDSCBBOX *)((void *)0);
#line 2381
                                    tmp___17 = dsc_add_media(dsc, & lmedia);
                                    }
#line 2381
                                    if (tmp___17) {
#line 2382
                                      return (-1);
                                    }
                                  } else {
                                    {
#line 2385
                                    tmp___18 = strlen((char const   *)p);
#line 2385
                                    tmp___19 = dsc_alloc_string(dsc, (char const   *)p,
                                                                (int )tmp___18);
#line 2385
                                    (*(dsc->media + count))->name = (char const   *)tmp___19;
                                    }
                                  }
                                  {
#line 2388
                                  while (1) {
                                    while_continue___0: /* CIL Label */ ;
#line 2388
                                    if (m) {
#line 2388
                                      if (! m->name) {
#line 2388
                                        goto while_break___0;
                                      }
                                    } else {
#line 2388
                                      goto while_break___0;
                                    }
                                    {
#line 2389
                                    tmp___20 = dsc_stricmp((char const   *)p, (char const   *)m->name);
                                    }
#line 2389
                                    if (tmp___20 == 0) {
#line 2390
                                      (*(dsc->media + count))->width = (float )m->width;
#line 2391
                                      (*(dsc->media + count))->height = (float )m->height;
#line 2392
                                      goto while_break___0;
                                    }
#line 2394
                                    m ++;
                                  }
                                  while_break___0: /* CIL Label */ ;
                                  }
                                }
                              }
#line 2397
                              n___0 += i___0;
#line 2398
                              count ++;
                            }
                            while_break: /* CIL Label */ ;
                            }
                          } else {
                            {
#line 2401
                            tmp___56 = strncmp((char const   *)line, "%%DocumentPaperForms:",
                                               sizeof("%%DocumentPaperForms:") - 1UL);
                            }
#line 2401
                            if (tmp___56 == 0) {
#line 2403
                              if (continued) {
#line 2403
                                tmp___21 = 3;
                              } else {
#line 2403
                                tmp___21 = 21;
                              }
#line 2403
                              n___1 = (unsigned int )tmp___21;
#line 2404
                              count___0 = 0U;
#line 2405
                              i___1 = 1U;
#line 2408
                              dsc->id = 214;
                              {
#line 2409
                              while (1) {
                                while_continue___1: /* CIL Label */ ;
#line 2409
                                if (i___1) {
#line 2409
                                  if ((int )*(dsc->line + n___1) != 13) {
#line 2409
                                    if (! ((int )*(dsc->line + n___1) != 10)) {
#line 2409
                                      goto while_break___1;
                                    }
                                  } else {
#line 2409
                                    goto while_break___1;
                                  }
                                } else {
#line 2409
                                  goto while_break___1;
                                }
                                {
#line 2410
                                p___0 = dsc_copy_string(type, (unsigned int )(sizeof(type) - 1UL),
                                                        dsc->line + n___1, dsc->line_length - n___1,
                                                        & i___1);
                                }
#line 2412
                                if (i___1) {
#line 2412
                                  if (p___0) {
#line 2413
                                    if (count___0 >= dsc->media_count) {
                                      {
#line 2416
                                      lmedia___0.name = (char const   *)((void *)0);
#line 2417
                                      lmedia___0.width = (float )595.0;
#line 2418
                                      lmedia___0.height = (float )842.0;
#line 2419
                                      lmedia___0.weight = (float )80.0;
#line 2420
                                      lmedia___0.colour = (char const   *)((void *)0);
#line 2421
                                      lmedia___0.type = (char const   *)p___0;
#line 2422
                                      lmedia___0.mediabox = (CDSCBBOX *)((void *)0);
#line 2423
                                      tmp___22 = dsc_add_media(dsc, & lmedia___0);
                                      }
#line 2423
                                      if (tmp___22) {
#line 2424
                                        return (-1);
                                      }
                                    } else {
                                      {
#line 2427
                                      tmp___23 = strlen((char const   *)p___0);
#line 2427
                                      tmp___24 = dsc_alloc_string(dsc, (char const   *)p___0,
                                                                  (int )tmp___23);
#line 2427
                                      (*(dsc->media + count___0))->type = (char const   *)tmp___24;
                                      }
                                    }
                                  }
                                }
#line 2430
                                n___1 += i___1;
#line 2431
                                count___0 ++;
                              }
                              while_break___1: /* CIL Label */ ;
                              }
                            } else {
                              {
#line 2434
                              tmp___55 = strncmp((char const   *)line, "%%DocumentPaperColors:",
                                                 sizeof("%%DocumentPaperColors:") - 1UL);
                              }
#line 2434
                              if (tmp___55 == 0) {
#line 2436
                                if (continued) {
#line 2436
                                  tmp___25 = 3;
                                } else {
#line 2436
                                  tmp___25 = 22;
                                }
#line 2436
                                n___2 = (unsigned int )tmp___25;
#line 2437
                                count___1 = 0U;
#line 2438
                                i___2 = 1U;
#line 2441
                                dsc->id = 215;
                                {
#line 2442
                                while (1) {
                                  while_continue___2: /* CIL Label */ ;
#line 2442
                                  if (i___2) {
#line 2442
                                    if ((int )*(dsc->line + n___2) != 13) {
#line 2442
                                      if (! ((int )*(dsc->line + n___2) != 10)) {
#line 2442
                                        goto while_break___2;
                                      }
                                    } else {
#line 2442
                                      goto while_break___2;
                                    }
                                  } else {
#line 2442
                                    goto while_break___2;
                                  }
                                  {
#line 2443
                                  p___1 = dsc_copy_string(colour, (unsigned int )(sizeof(colour) - 1UL),
                                                          dsc->line + n___2, dsc->line_length - n___2,
                                                          & i___2);
                                  }
#line 2445
                                  if (i___2) {
#line 2445
                                    if (p___1) {
#line 2446
                                      if (count___1 >= dsc->media_count) {
                                        {
#line 2449
                                        lmedia___1.name = (char const   *)((void *)0);
#line 2450
                                        lmedia___1.width = (float )595.0;
#line 2451
                                        lmedia___1.height = (float )842.0;
#line 2452
                                        lmedia___1.weight = (float )80.0;
#line 2453
                                        lmedia___1.colour = (char const   *)p___1;
#line 2454
                                        lmedia___1.type = (char const   *)((void *)0);
#line 2455
                                        lmedia___1.mediabox = (CDSCBBOX *)((void *)0);
#line 2456
                                        tmp___26 = dsc_add_media(dsc, & lmedia___1);
                                        }
#line 2456
                                        if (tmp___26) {
#line 2457
                                          return (-1);
                                        }
                                      } else {
                                        {
#line 2460
                                        tmp___27 = strlen((char const   *)p___1);
#line 2460
                                        tmp___28 = dsc_alloc_string(dsc, (char const   *)p___1,
                                                                    (int )tmp___27);
#line 2460
                                        (*(dsc->media + count___1))->colour = (char const   *)tmp___28;
                                        }
                                      }
                                    }
                                  }
#line 2463
                                  n___2 += i___2;
#line 2464
                                  count___1 ++;
                                }
                                while_break___2: /* CIL Label */ ;
                                }
                              } else {
                                {
#line 2467
                                tmp___54 = strncmp((char const   *)line, "%%DocumentPaperWeights:",
                                                   sizeof("%%DocumentPaperWeights:") - 1UL);
                                }
#line 2467
                                if (tmp___54 == 0) {
#line 2469
                                  if (continued) {
#line 2469
                                    tmp___29 = 3;
                                  } else {
#line 2469
                                    tmp___29 = 23;
                                  }
#line 2469
                                  n___3 = (unsigned int )tmp___29;
#line 2470
                                  count___2 = 0U;
#line 2471
                                  i___3 = 1U;
#line 2473
                                  dsc->id = 216;
                                  {
#line 2474
                                  while (1) {
                                    while_continue___3: /* CIL Label */ ;
#line 2474
                                    if (i___3) {
#line 2474
                                      if ((int )*(dsc->line + n___3) != 13) {
#line 2474
                                        if (! ((int )*(dsc->line + n___3) != 10)) {
#line 2474
                                          goto while_break___3;
                                        }
                                      } else {
#line 2474
                                        goto while_break___3;
                                      }
                                    } else {
#line 2474
                                      goto while_break___3;
                                    }
                                    {
#line 2475
                                    w = dsc_get_real((char const   *)(dsc->line + n___3),
                                                     dsc->line_length - n___3, & i___3);
                                    }
#line 2476
                                    if (i___3) {
#line 2477
                                      if (count___2 >= dsc->media_count) {
                                        {
#line 2480
                                        lmedia___2.name = (char const   *)((void *)0);
#line 2481
                                        lmedia___2.width = (float )595.0;
#line 2482
                                        lmedia___2.height = (float )842.0;
#line 2483
                                        lmedia___2.weight = w;
#line 2484
                                        lmedia___2.colour = (char const   *)((void *)0);
#line 2485
                                        lmedia___2.type = (char const   *)((void *)0);
#line 2486
                                        lmedia___2.mediabox = (CDSCBBOX *)((void *)0);
#line 2487
                                        tmp___30 = dsc_add_media(dsc, & lmedia___2);
                                        }
#line 2487
                                        if (tmp___30) {
#line 2488
                                          return (-1);
                                        }
                                      } else {
#line 2491
                                        (*(dsc->media + count___2))->weight = w;
                                      }
                                    }
#line 2493
                                    n___3 += i___3;
#line 2494
                                    count___2 ++;
                                  }
                                  while_break___3: /* CIL Label */ ;
                                  }
                                } else {
                                  {
#line 2497
                                  tmp___53 = strncmp((char const   *)line, "%%DocumentData:",
                                                     sizeof("%%DocumentData:") - 1UL);
                                  }
#line 2497
                                  if (tmp___53 == 0) {
#line 2498
                                    if (continued) {
#line 2498
                                      tmp___31 = 3;
                                    } else {
#line 2498
                                      tmp___31 = 15;
                                    }
#line 2498
                                    n___4 = (unsigned int )tmp___31;
#line 2499
                                    p___2 = dsc->line + n___4;
                                    {
#line 2500
                                    while (1) {
                                      while_continue___4: /* CIL Label */ ;
#line 2500
                                      if (! ((int )*p___2 == 32)) {
#line 2500
                                        if (! ((int )*p___2 == 9)) {
#line 2500
                                          goto while_break___4;
                                        }
                                      }
#line 2501
                                      p___2 ++;
                                    }
                                    while_break___4: /* CIL Label */ ;
                                    }
                                    {
#line 2502
                                    dsc->id = 217;
#line 2503
                                    tmp___34 = strncmp((char const   *)p___2, "Clean7Bit",
                                                       sizeof("Clean7Bit") - 1UL);
                                    }
#line 2503
                                    if (tmp___34 == 0) {
#line 2504
                                      dsc->document_data = 1U;
                                    } else {
                                      {
#line 2505
                                      tmp___33 = strncmp((char const   *)p___2, "Clean8Bit",
                                                         sizeof("Clean8Bit") - 1UL);
                                      }
#line 2505
                                      if (tmp___33 == 0) {
#line 2506
                                        dsc->document_data = 2U;
                                      } else {
                                        {
#line 2507
                                        tmp___32 = strncmp((char const   *)p___2,
                                                           "Binary", sizeof("Binary") - 1UL);
                                        }
#line 2507
                                        if (tmp___32 == 0) {
#line 2508
                                          dsc->document_data = 3U;
                                        } else {
                                          {
#line 2510
                                          dsc_unknown(dsc);
                                          }
                                        }
                                      }
                                    }
                                  } else {
                                    {
#line 2512
                                    tmp___52 = strncmp((char const   *)line, "%%Requirements:",
                                                       sizeof("%%Requirements:") - 1UL);
                                    }
#line 2512
                                    if (tmp___52 == 0) {
#line 2513
                                      dsc->id = 218;
                                    } else {
                                      {
#line 2516
                                      tmp___51 = strncmp((char const   *)line, "%%DocumentNeededFonts:",
                                                         sizeof("%%DocumentNeededFonts:") - 1UL);
                                      }
#line 2516
                                      if (tmp___51 == 0) {
#line 2517
                                        dsc->id = 219;
                                      } else {
                                        {
#line 2520
                                        tmp___50 = strncmp((char const   *)line, "%%DocumentSuppliedFonts:",
                                                           sizeof("%%DocumentSuppliedFonts:") - 1UL);
                                        }
#line 2520
                                        if (tmp___50 == 0) {
#line 2521
                                          dsc->id = 220;
                                        } else {
                                          {
#line 2524
                                          tmp___49 = strncmp((char const   *)line,
                                                             "%%PlateFile:", sizeof("%%PlateFile:") - 1UL);
                                          }
#line 2524
                                          if (tmp___49 == 0) {
                                            {
#line 2525
                                            dsc->id = 223;
#line 2526
                                            tmp___35 = dsc_parse_platefile(dsc);
                                            }
#line 2526
                                            if (tmp___35 != 0) {
#line 2527
                                              dsc->id = 100;
                                            }
                                          } else {
                                            {
#line 2529
                                            tmp___45 = strncmp((char const   *)line,
                                                               "%%CyanPlate:", sizeof("%%CyanPlate:") - 1UL);
                                            }
#line 2529
                                            if (tmp___45 == 0) {
#line 2529
                                              goto _L___0;
                                            } else {
                                              {
#line 2529
                                              tmp___46 = strncmp((char const   *)line,
                                                                 "%%MagentaPlate:",
                                                                 sizeof("%%MagentaPlate:") - 1UL);
                                              }
#line 2529
                                              if (tmp___46 == 0) {
#line 2529
                                                goto _L___0;
                                              } else {
                                                {
#line 2529
                                                tmp___47 = strncmp((char const   *)line,
                                                                   "%%YellowPlate:",
                                                                   sizeof("%%YellowPlate:") - 1UL);
                                                }
#line 2529
                                                if (tmp___47 == 0) {
#line 2529
                                                  goto _L___0;
                                                } else {
                                                  {
#line 2529
                                                  tmp___48 = strncmp((char const   *)line,
                                                                     "%%BlackPlate:",
                                                                     sizeof("%%BlackPlate:") - 1UL);
                                                  }
#line 2529
                                                  if (tmp___48 == 0) {
                                                    _L___0: /* CIL Label */ 
                                                    {
#line 2533
                                                    dsc->id = 223;
#line 2534
                                                    tmp___36 = dsc_parse_dcs1plate(dsc);
                                                    }
#line 2534
                                                    if (tmp___36 != 0) {
#line 2535
                                                      dsc->id = 100;
                                                    }
                                                  } else {
                                                    {
#line 2537
                                                    tmp___44 = strncmp((char const   *)line,
                                                                       "%%DocumentProcessColors:",
                                                                       sizeof("%%DocumentProcessColors:") - 1UL);
                                                    }
#line 2537
                                                    if (tmp___44 == 0) {
                                                      {
#line 2538
                                                      dsc->id = 224;
#line 2539
                                                      tmp___37 = dsc_parse_process_colours(dsc);
                                                      }
#line 2539
                                                      if (tmp___37 != 0) {
#line 2540
                                                        dsc->id = 100;
                                                      }
                                                    } else {
                                                      {
#line 2542
                                                      tmp___43 = strncmp((char const   *)line,
                                                                         "%%DocumentCustomColors:",
                                                                         sizeof("%%DocumentCustomColors:") - 1UL);
                                                      }
#line 2542
                                                      if (tmp___43 == 0) {
                                                        {
#line 2543
                                                        dsc->id = 225;
#line 2544
                                                        tmp___38 = dsc_parse_custom_colours(dsc);
                                                        }
#line 2544
                                                        if (tmp___38 != 0) {
#line 2545
                                                          dsc->id = 100;
                                                        }
                                                      } else {
                                                        {
#line 2547
                                                        tmp___42 = strncmp((char const   *)line,
                                                                           "%%CMYKCustomColor:",
                                                                           sizeof("%%CMYKCustomColor:") - 1UL);
                                                        }
#line 2547
                                                        if (tmp___42 == 0) {
                                                          {
#line 2548
                                                          dsc->id = 226;
#line 2549
                                                          tmp___39 = dsc_parse_cmyk_custom_colour(dsc);
                                                          }
#line 2549
                                                          if (tmp___39 != 0) {
#line 2550
                                                            dsc->id = 100;
                                                          }
                                                        } else {
                                                          {
#line 2552
                                                          tmp___41 = strncmp((char const   *)line,
                                                                             "%%RGBCustomColor:",
                                                                             sizeof("%%RGBCustomColor:") - 1UL);
                                                          }
#line 2552
                                                          if (tmp___41 == 0) {
                                                            {
#line 2553
                                                            dsc->id = 227;
#line 2554
                                                            tmp___40 = dsc_parse_rgb_custom_colour(dsc);
                                                            }
#line 2554
                                                            if (tmp___40 != 0) {
#line 2555
                                                              dsc->id = 100;
                                                            }
                                                          } else
#line 2557
                                                          if ((int )*(dsc->line + 0) == 37) {
#line 2557
                                                            if ((int )*(dsc->line + 1) == 32) {
#line 2558
                                                              dsc->id = 0;
                                                            } else
#line 2557
                                                            if ((int )*(dsc->line + 1) == 9) {
#line 2558
                                                              dsc->id = 0;
                                                            } else
#line 2557
                                                            if ((int )*(dsc->line + 1) == 13) {
#line 2558
                                                              dsc->id = 0;
                                                            } else
#line 2557
                                                            if ((int )*(dsc->line + 1) == 10) {
#line 2558
                                                              dsc->id = 0;
                                                            } else {
                                                              {
#line 2562
                                                              dsc->id = 100;
#line 2563
                                                              dsc_unknown(dsc);
                                                              }
                                                            }
                                                          } else {
                                                            {
#line 2562
                                                            dsc->id = 100;
#line 2563
                                                            dsc_unknown(dsc);
                                                            }
                                                          }
                                                        }
                                                      }
                                                    }
                                                  }
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
#line 2566
  dsc->endcomments = dsc->data_offset + (unsigned long )dsc->data_index;
#line 2567
  return (0);
}
}
#line 2571 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/dscparse.c"
static int dsc_scan_preview(CDSC *dsc ) 
{ 
  char *line ;
  int tmp ;
  int tmp___0 ;
  GSBOOL tmp___1 ;
  int tmp___2 ;

  {
#line 2578
  line = dsc->line;
#line 2579
  dsc->id = 0;
#line 2581
  if (dsc->scan_section == 2) {
#line 2582
    if ((int )*(line + 0) == 13) {
#line 2583
      return (0);
    } else
#line 2582
    if ((int )*(line + 0) == 10) {
#line 2583
      return (0);
    } else {
      {
#line 2584
      tmp = strncmp((char const   *)line, "%%BeginPreview", sizeof("%%BeginPreview") - 1UL);
      }
#line 2584
      if (tmp == 0) {
#line 2585
        dsc->id = 301;
#line 2586
        dsc->beginpreview = (dsc->data_offset + (unsigned long )dsc->data_index) - (unsigned long )dsc->line_length;
#line 2587
        dsc->endpreview = dsc->data_offset + (unsigned long )dsc->data_index;
#line 2588
        dsc->scan_section = 3;
#line 2590
        if (dsc->preview == 0U) {
#line 2591
          dsc->preview = 1U;
        }
#line 2592
        return (0);
      } else {
#line 2595
        dsc->scan_section = 4;
#line 2596
        return (10);
      }
    }
  }
  {
#line 2600
  tmp___2 = strncmp((char const   *)line, "%%BeginPreview", sizeof("%%BeginPreview") - 1UL);
  }
#line 2600
  if (! (tmp___2 == 0)) {
    {
#line 2603
    tmp___1 = dsc_is_section(line);
    }
#line 2603
    if (tmp___1) {
#line 2604
      dsc->endpreview = (dsc->data_offset + (unsigned long )dsc->data_index) - (unsigned long )dsc->line_length;
#line 2605
      dsc->scan_section = 4;
#line 2606
      return (10);
    } else {
      {
#line 2608
      tmp___0 = strncmp((char const   *)line, "%%EndPreview", sizeof("%%EndPreview") - 1UL);
      }
#line 2608
      if (tmp___0 == 0) {
#line 2609
        dsc->id = 302;
#line 2610
        dsc->endpreview = dsc->data_offset + (unsigned long )dsc->data_index;
#line 2611
        dsc->scan_section = 4;
#line 2612
        return (0);
      } else
#line 2614
      if ((int )*(line + 0) == 37) {
#line 2614
        if (! ((int )*(line + 1) != 37)) {
          {
#line 2618
          dsc->id = 100;
#line 2620
          dsc_unknown(dsc);
          }
        }
      } else {
        {
#line 2618
        dsc->id = 100;
#line 2620
        dsc_unknown(dsc);
        }
      }
    }
  }
#line 2623
  dsc->endpreview = dsc->data_offset + (unsigned long )dsc->data_index;
#line 2624
  return (0);
}
}
#line 2627 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/dscparse.c"
static int dsc_scan_defaults(CDSC *dsc ) 
{ 
  char *line ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  GSBOOL tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;

  {
#line 2634
  line = dsc->line;
#line 2635
  dsc->id = 0;
#line 2637
  if (dsc->scan_section == 4) {
#line 2638
    if ((int )*(line + 0) == 13) {
#line 2639
      return (0);
    } else
#line 2638
    if ((int )*(line + 0) == 10) {
#line 2639
      return (0);
    } else {
      {
#line 2640
      tmp = strncmp((char const   *)line, "%%BeginDefaults", sizeof("%%BeginDefaults") - 1UL);
      }
#line 2640
      if (tmp == 0) {
#line 2641
        dsc->id = 401;
#line 2642
        dsc->begindefaults = (dsc->data_offset + (unsigned long )dsc->data_index) - (unsigned long )dsc->line_length;
#line 2643
        dsc->enddefaults = dsc->data_offset + (unsigned long )dsc->data_index;
#line 2644
        dsc->scan_section = 5;
#line 2645
        return (0);
      } else {
#line 2648
        dsc->scan_section = 6;
#line 2649
        return (10);
      }
    }
  }
#line 2653
  if (! ((int )*(line + 0) != 37)) {
#line 2653
    if (! ((int )*(line + 1) != 37)) {
      {
#line 2656
      tmp___12 = strncmp((char const   *)line, "%%BeginPreview", sizeof("%%BeginPreview") - 1UL);
      }
#line 2656
      if (! (tmp___12 == 0)) {
        {
#line 2659
        tmp___11 = strncmp((char const   *)line, "%%BeginDefaults", sizeof("%%BeginDefaults") - 1UL);
        }
#line 2659
        if (! (tmp___11 == 0)) {
          {
#line 2662
          tmp___10 = dsc_is_section(line);
          }
#line 2662
          if (tmp___10) {
#line 2663
            dsc->enddefaults = (dsc->data_offset + (unsigned long )dsc->data_index) - (unsigned long )dsc->line_length;
#line 2664
            dsc->scan_section = 6;
#line 2665
            return (10);
          } else {
            {
#line 2667
            tmp___9 = strncmp((char const   *)line, "%%EndDefaults", sizeof("%%EndDefaults") - 1UL);
            }
#line 2667
            if (tmp___9 == 0) {
#line 2668
              dsc->id = 402;
#line 2669
              dsc->enddefaults = dsc->data_offset + (unsigned long )dsc->data_index;
#line 2670
              dsc->scan_section = 6;
#line 2671
              return (0);
            } else {
              {
#line 2673
              tmp___8 = strncmp((char const   *)line, "%%PageMedia:", sizeof("%%PageMedia:") - 1UL);
              }
#line 2673
              if (tmp___8 == 0) {
                {
#line 2674
                dsc->id = 704;
#line 2675
                dsc_parse_media(dsc, & dsc->page_media);
                }
              } else {
                {
#line 2677
                tmp___7 = strncmp((char const   *)line, "%%PageOrientation:", sizeof("%%PageOrientation:") - 1UL);
                }
#line 2677
                if (tmp___7 == 0) {
                  {
#line 2678
                  dsc->id = 705;
#line 2680
                  tmp___0 = dsc_parse_orientation(dsc, & dsc->page_orientation, 18);
                  }
#line 2680
                  if (tmp___0) {
#line 2681
                    return (-1);
                  }
                } else {
                  {
#line 2683
                  tmp___6 = strncmp((char const   *)line, "%%PageBoundingBox:", sizeof("%%PageBoundingBox:") - 1UL);
                  }
#line 2683
                  if (tmp___6 == 0) {
                    {
#line 2684
                    dsc->id = 706;
#line 2685
                    tmp___1 = dsc_parse_bounding_box(dsc, & dsc->page_bbox, 18);
                    }
#line 2685
                    if (tmp___1) {
#line 2686
                      return (-1);
                    }
                  } else {
                    {
#line 2688
                    tmp___5 = strncmp((char const   *)line, "%%ViewingOrientation:",
                                      sizeof("%%ViewingOrientation:") - 1UL);
                    }
#line 2688
                    if (tmp___5 == 0) {
                      {
#line 2689
                      dsc->id = 708;
#line 2690
                      tmp___2 = dsc_parse_viewing_orientation(dsc, & dsc->viewing_orientation);
                      }
#line 2690
                      if (tmp___2) {
#line 2691
                        return (-1);
                      }
                    } else {
                      {
#line 2693
                      tmp___4 = strncmp((char const   *)line, "%%PageCropBox:", sizeof("%%PageCropBox:") - 1UL);
                      }
#line 2693
                      if (tmp___4 == 0) {
                        {
#line 2694
                        dsc->id = 709;
#line 2695
                        tmp___3 = dsc_parse_float_bounding_box(dsc, & dsc->crop_box,
                                                               14);
                        }
#line 2695
                        if (tmp___3) {
#line 2696
                          return (-1);
                        }
                      } else {
                        {
#line 2699
                        dsc->id = 100;
#line 2701
                        dsc_unknown(dsc);
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
#line 2703
  dsc->enddefaults = dsc->data_offset + (unsigned long )dsc->data_index;
#line 2704
  return (0);
}
}
#line 2709 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/dscparse.c"
static int dsc_check_match_prompt(CDSC *dsc , char const   *str , int count ) 
{ 
  char buf[512] ;
  size_t tmp ;
  size_t tmp___0 ;
  int tmp___1 ;

  {
#line 2712
  if (count != 0) {
#line 2714
    if (dsc->line_length < (unsigned int )(sizeof(buf) / 2UL - 1UL)) {
      {
#line 2715
      strncpy((char */* __restrict  */)(buf), (char const   */* __restrict  */)dsc->line,
              (size_t )dsc->line_length);
#line 2716
      buf[dsc->line_length] = (char )'\000';
      }
    }
    {
#line 2718
    tmp = strlen((char const   *)(buf));
#line 2718
    sprintf((char */* __restrict  */)(buf + tmp), (char const   */* __restrict  */)"\n%%%%Begin%.40s: / %%%%End%.40s\n",
            str, str);
#line 2719
    tmp___0 = strlen((char const   *)(buf));
#line 2719
    tmp___1 = dsc_error(dsc, 12U, buf, (unsigned int )((int )tmp___0));
    }
#line 2719
    return (tmp___1);
  }
#line 2721
  return (1);
}
}
#line 2724 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/dscparse.c"
static int dsc_check_match_type(CDSC *dsc , char const   *str , int count ) 
{ 
  int tmp ;

  {
  {
#line 2727
  tmp = dsc_check_match_prompt(dsc, str, count);
  }
#line 2727
  if (tmp == 2) {
#line 2728
    return (1);
  }
#line 2729
  return (0);
}
}
#line 2734 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/dscparse.c"
static int dsc_check_match(CDSC *dsc ) 
{ 
  int rc ;
  char const   *font ;
  char const   *feature ;
  char const   *resource ;
  char const   *procset ;

  {
#line 2737
  rc = 0;
#line 2738
  font = "Font";
#line 2739
  feature = "Feature";
#line 2740
  resource = "Resource";
#line 2741
  procset = "ProcSet";
#line 2743
  if (! rc) {
    {
#line 2744
    rc = dsc_check_match_type(dsc, font, dsc->begin_font_count);
    }
  }
#line 2745
  if (! rc) {
    {
#line 2746
    rc = dsc_check_match_type(dsc, feature, dsc->begin_feature_count);
    }
  }
#line 2747
  if (! rc) {
    {
#line 2748
    rc = dsc_check_match_type(dsc, resource, dsc->begin_resource_count);
    }
  }
#line 2749
  if (! rc) {
    {
#line 2750
    rc = dsc_check_match_type(dsc, procset, dsc->begin_procset_count);
    }
  }
#line 2752
  dsc->begin_font_count = 0;
#line 2753
  dsc->begin_feature_count = 0;
#line 2754
  dsc->begin_resource_count = 0;
#line 2755
  dsc->begin_procset_count = 0;
#line 2756
  return (rc);
}
}
#line 2760 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/dscparse.c"
static int dsc_scan_prolog(CDSC *dsc ) 
{ 
  char *line ;
  GSBOOL tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  GSBOOL tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;

  {
#line 2767
  line = dsc->line;
#line 2768
  dsc->id = 0;
#line 2770
  if (dsc->scan_section == 6) {
    {
#line 2771
    tmp = dsc_is_section(line);
    }
#line 2771
    if (tmp) {
      {
#line 2771
      tmp___0 = strncmp((char const   *)line, "%%BeginProlog", sizeof("%%BeginProlog") - 1UL);
      }
#line 2771
      if (! (tmp___0 == 0)) {
#line 2772
        dsc->scan_section = 8;
#line 2773
        return (10);
      }
    }
    {
#line 2775
    dsc->id = 501;
#line 2776
    dsc->beginprolog = (dsc->data_offset + (unsigned long )dsc->data_index) - (unsigned long )dsc->line_length;
#line 2777
    dsc->endprolog = dsc->data_offset + (unsigned long )dsc->data_index;
#line 2778
    dsc->scan_section = 7;
#line 2779
    tmp___1 = strncmp((char const   *)line, "%%BeginProlog", sizeof("%%BeginProlog") - 1UL);
    }
#line 2779
    if (tmp___1 == 0) {
#line 2780
      return (0);
    }
  }
#line 2783
  if (! ((int )*(line + 0) != 37)) {
#line 2783
    if (! ((int )*(line + 1) != 37)) {
      {
#line 2786
      tmp___16 = strncmp((char const   *)line, "%%BeginPreview", sizeof("%%BeginPreview") - 1UL);
      }
#line 2786
      if (! (tmp___16 == 0)) {
        {
#line 2789
        tmp___15 = strncmp((char const   *)line, "%%BeginDefaults", sizeof("%%BeginDefaults") - 1UL);
        }
#line 2789
        if (! (tmp___15 == 0)) {
          {
#line 2792
          tmp___14 = strncmp((char const   *)line, "%%BeginProlog", sizeof("%%BeginProlog") - 1UL);
          }
#line 2792
          if (! (tmp___14 == 0)) {
            {
#line 2795
            tmp___13 = dsc_is_section(line);
            }
#line 2795
            if (tmp___13) {
              {
#line 2796
              dsc->endprolog = (dsc->data_offset + (unsigned long )dsc->data_index) - (unsigned long )dsc->line_length;
#line 2797
              dsc->scan_section = 8;
#line 2798
              tmp___2 = dsc_check_match(dsc);
              }
#line 2798
              if (tmp___2) {
#line 2799
                return (1);
              }
#line 2800
              return (10);
            } else {
              {
#line 2802
              tmp___12 = strncmp((char const   *)line, "%%EndProlog", sizeof("%%EndProlog") - 1UL);
              }
#line 2802
              if (tmp___12 == 0) {
                {
#line 2803
                dsc->id = 502;
#line 2804
                dsc->endprolog = dsc->data_offset + (unsigned long )dsc->data_index;
#line 2805
                dsc->scan_section = 8;
#line 2806
                tmp___3 = dsc_check_match(dsc);
                }
#line 2806
                if (tmp___3) {
#line 2807
                  return (1);
                }
#line 2808
                return (0);
              } else {
                {
#line 2810
                tmp___11 = strncmp((char const   *)line, "%%BeginFont:", sizeof("%%BeginFont:") - 1UL);
                }
#line 2810
                if (tmp___11 == 0) {
#line 2811
                  dsc->id = 503;
#line 2814
                  (dsc->begin_font_count) ++;
                } else {
                  {
#line 2816
                  tmp___10 = strncmp((char const   *)line, "%%EndFont", sizeof("%%EndFont") - 1UL);
                  }
#line 2816
                  if (tmp___10 == 0) {
#line 2817
                    dsc->id = 504;
#line 2818
                    (dsc->begin_font_count) --;
                  } else {
                    {
#line 2820
                    tmp___9 = strncmp((char const   *)line, "%%BeginFeature:", sizeof("%%BeginFeature:") - 1UL);
                    }
#line 2820
                    if (tmp___9 == 0) {
#line 2821
                      dsc->id = 505;
#line 2824
                      (dsc->begin_feature_count) ++;
                    } else {
                      {
#line 2826
                      tmp___8 = strncmp((char const   *)line, "%%EndFeature", sizeof("%%EndFeature") - 1UL);
                      }
#line 2826
                      if (tmp___8 == 0) {
#line 2827
                        dsc->id = 506;
#line 2828
                        (dsc->begin_feature_count) --;
                      } else {
                        {
#line 2830
                        tmp___7 = strncmp((char const   *)line, "%%BeginResource:",
                                          sizeof("%%BeginResource:") - 1UL);
                        }
#line 2830
                        if (tmp___7 == 0) {
#line 2831
                          dsc->id = 507;
#line 2834
                          (dsc->begin_resource_count) ++;
                        } else {
                          {
#line 2836
                          tmp___6 = strncmp((char const   *)line, "%%EndResource",
                                            sizeof("%%EndResource") - 1UL);
                          }
#line 2836
                          if (tmp___6 == 0) {
#line 2837
                            dsc->id = 508;
#line 2838
                            (dsc->begin_resource_count) --;
                          } else {
                            {
#line 2840
                            tmp___5 = strncmp((char const   *)line, "%%BeginProcSet:",
                                              sizeof("%%BeginProcSet:") - 1UL);
                            }
#line 2840
                            if (tmp___5 == 0) {
#line 2841
                              dsc->id = 509;
#line 2844
                              (dsc->begin_procset_count) ++;
                            } else {
                              {
#line 2846
                              tmp___4 = strncmp((char const   *)line, "%%EndProcSet",
                                                sizeof("%%EndProcSet") - 1UL);
                              }
#line 2846
                              if (tmp___4 == 0) {
#line 2847
                                dsc->id = 510;
#line 2848
                                (dsc->begin_procset_count) --;
                              } else {
                                {
#line 2852
                                dsc->id = 100;
#line 2853
                                dsc_unknown(dsc);
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
#line 2856
  dsc->endprolog = dsc->data_offset + (unsigned long )dsc->data_index;
#line 2857
  return (0);
}
}
#line 2860 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/dscparse.c"
static int dsc_scan_setup(CDSC *dsc ) 
{ 
  char *line ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  GSBOOL found_media ;
  int i ;
  int n ;
  char buf[256] ;
  int tmp___3 ;
  CDSCMEDIA const   *m ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  GSBOOL tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;

  {
#line 2868
  line = dsc->line;
#line 2869
  dsc->id = 0;
#line 2871
  if (dsc->scan_section == 8) {
#line 2872
    if ((int )*(line + 0) == 13) {
#line 2873
      return (0);
    } else
#line 2872
    if ((int )*(line + 0) == 10) {
#line 2873
      return (0);
    } else {
      {
#line 2874
      tmp = strncmp((char const   *)line, "%%BeginSetup", sizeof("%%BeginSetup") - 1UL);
      }
#line 2874
      if (tmp == 0) {
#line 2875
        dsc->id = 601;
#line 2876
        dsc->beginsetup = (dsc->data_offset + (unsigned long )dsc->data_index) - (unsigned long )dsc->line_length;
#line 2877
        dsc->endsetup = dsc->data_offset + (unsigned long )dsc->data_index;
#line 2878
        dsc->scan_section = 9;
#line 2879
        return (0);
      } else {
#line 2882
        dsc->scan_section = 10;
#line 2883
        return (10);
      }
    }
  }
#line 2887
  if (! ((int )*(line + 0) != 37)) {
#line 2887
    if (! ((int )*(line + 1) != 37)) {
      {
#line 2890
      tmp___19 = strncmp((char const   *)line, "%%BeginPreview", sizeof("%%BeginPreview") - 1UL);
      }
#line 2890
      if (! (tmp___19 == 0)) {
        {
#line 2893
        tmp___18 = strncmp((char const   *)line, "%%BeginDefaults", sizeof("%%BeginDefaults") - 1UL);
        }
#line 2893
        if (! (tmp___18 == 0)) {
          {
#line 2896
          tmp___17 = strncmp((char const   *)line, "%%BeginProlog", sizeof("%%BeginProlog") - 1UL);
          }
#line 2896
          if (! (tmp___17 == 0)) {
            {
#line 2899
            tmp___16 = strncmp((char const   *)line, "%%BeginSetup", sizeof("%%BeginSetup") - 1UL);
            }
#line 2899
            if (! (tmp___16 == 0)) {
              {
#line 2902
              tmp___15 = dsc_is_section(line);
              }
#line 2902
              if (tmp___15) {
                {
#line 2903
                dsc->endsetup = (dsc->data_offset + (unsigned long )dsc->data_index) - (unsigned long )dsc->line_length;
#line 2904
                dsc->scan_section = 10;
#line 2905
                tmp___0 = dsc_check_match(dsc);
                }
#line 2905
                if (tmp___0) {
#line 2906
                  return (1);
                }
#line 2907
                return (10);
              } else {
                {
#line 2909
                tmp___14 = strncmp((char const   *)line, "%%EndSetup", sizeof("%%EndSetup") - 1UL);
                }
#line 2909
                if (tmp___14 == 0) {
                  {
#line 2910
                  dsc->id = 602;
#line 2911
                  dsc->endsetup = dsc->data_offset + (unsigned long )dsc->data_index;
#line 2912
                  dsc->scan_section = 10;
#line 2913
                  tmp___1 = dsc_check_match(dsc);
                  }
#line 2913
                  if (tmp___1) {
#line 2914
                    return (1);
                  }
#line 2915
                  return (0);
                } else {
                  {
#line 2917
                  tmp___13 = strncmp((char const   *)line, "%%BeginFeature:", sizeof("%%BeginFeature:") - 1UL);
                  }
#line 2917
                  if (tmp___13 == 0) {
                    {
#line 2918
                    dsc->id = 505;
#line 2921
                    (dsc->begin_feature_count) ++;
#line 2923
                    tmp___2 = dsc_parse_feature(dsc);
                    }
#line 2923
                    if (tmp___2) {
#line 2924
                      return (-1);
                    }
                  } else {
                    {
#line 2926
                    tmp___12 = strncmp((char const   *)line, "%%EndFeature", sizeof("%%EndFeature") - 1UL);
                    }
#line 2926
                    if (tmp___12 == 0) {
#line 2927
                      dsc->id = 506;
#line 2928
                      (dsc->begin_feature_count) --;
                    } else {
                      {
#line 2930
                      tmp___11 = strncmp((char const   *)line, "%%Feature:", sizeof("%%Feature:") - 1UL);
                      }
#line 2930
                      if (tmp___11 == 0) {
#line 2931
                        dsc->id = 603;
                      } else {
                        {
#line 2934
                        tmp___10 = strncmp((char const   *)line, "%%BeginResource:",
                                           sizeof("%%BeginResource:") - 1UL);
                        }
#line 2934
                        if (tmp___10 == 0) {
#line 2935
                          dsc->id = 507;
#line 2938
                          (dsc->begin_resource_count) ++;
                        } else {
                          {
#line 2940
                          tmp___9 = strncmp((char const   *)line, "%%EndResource",
                                            sizeof("%%EndResource") - 1UL);
                          }
#line 2940
                          if (tmp___9 == 0) {
#line 2941
                            dsc->id = 508;
#line 2942
                            (dsc->begin_resource_count) --;
                          } else {
                            {
#line 2944
                            tmp___8 = strncmp((char const   *)line, "%%PaperColor:",
                                              sizeof("%%PaperColor:") - 1UL);
                            }
#line 2944
                            if (tmp___8 == 0) {
#line 2945
                              dsc->id = 604;
                            } else {
                              {
#line 2948
                              tmp___7 = strncmp((char const   *)line, "%%PaperForm:",
                                                sizeof("%%PaperForm:") - 1UL);
                              }
#line 2948
                              if (tmp___7 == 0) {
#line 2949
                                dsc->id = 605;
                              } else {
                                {
#line 2952
                                tmp___6 = strncmp((char const   *)line, "%%PaperWeight:",
                                                  sizeof("%%PaperWeight:") - 1UL);
                                }
#line 2952
                                if (tmp___6 == 0) {
#line 2953
                                  dsc->id = 606;
                                } else {
                                  {
#line 2956
                                  tmp___5 = strncmp((char const   *)line, "%%PaperSize:",
                                                    sizeof("%%PaperSize:") - 1UL);
                                  }
#line 2956
                                  if (tmp___5 == 0) {
                                    {
#line 2958
                                    found_media = 0;
#line 2960
                                    n = 12;
#line 2962
                                    buf[0] = (char )'\000';
#line 2963
                                    dsc->id = 607;
#line 2964
                                    dsc_copy_string(buf, (unsigned int )(sizeof(buf) - 1UL),
                                                    dsc->line + n, dsc->line_length - (unsigned int )n,
                                                    (unsigned int *)((void *)0));
#line 2966
                                    i = 0;
                                    }
                                    {
#line 2966
                                    while (1) {
                                      while_continue: /* CIL Label */ ;
#line 2966
                                      if (! (i < (int )dsc->media_count)) {
#line 2966
                                        goto while_break;
                                      }
#line 2967
                                      if (*(dsc->media + i)) {
#line 2967
                                        if ((*(dsc->media + i))->name) {
                                          {
#line 2967
                                          tmp___3 = dsc_stricmp((char const   *)(buf),
                                                                (*(dsc->media + i))->name);
                                          }
#line 2967
                                          if (tmp___3 == 0) {
#line 2969
                                            dsc->page_media = (CDSCMEDIA const   *)*(dsc->media + i);
#line 2970
                                            found_media = 1;
#line 2971
                                            goto while_break;
                                          }
                                        }
                                      }
#line 2966
                                      i ++;
                                    }
                                    while_break: /* CIL Label */ ;
                                    }
#line 2974
                                    if (! found_media) {
#line 2977
                                      m = dsc_known_media;
                                      {
#line 2978
                                      while (1) {
                                        while_continue___0: /* CIL Label */ ;
#line 2978
                                        if (! m->name) {
#line 2978
                                          goto while_break___0;
                                        }
                                        {
#line 2979
                                        tmp___4 = dsc_stricmp((char const   *)(buf),
                                                              (char const   *)m->name);
                                        }
#line 2979
                                        if (tmp___4 == 0) {
#line 2980
                                          dsc->page_media = m;
#line 2981
                                          goto while_break___0;
                                        }
#line 2983
                                        m ++;
                                      }
                                      while_break___0: /* CIL Label */ ;
                                      }
#line 2985
                                      if ((unsigned long )m->name == (unsigned long )((void *)0)) {
                                        {
#line 2986
                                        dsc_unknown(dsc);
                                        }
                                      }
                                    }
                                  } else {
                                    {
#line 2991
                                    dsc->id = 100;
#line 2992
                                    dsc_unknown(dsc);
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
#line 2995
  dsc->endsetup = dsc->data_offset + (unsigned long )dsc->data_index;
#line 2996
  return (0);
}
}
#line 2999 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/dscparse.c"
static int dsc_scan_page(CDSC *dsc ) 
{ 
  char *line ;
  unsigned long *last ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int code ;
  int tmp___2 ;
  int rc ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int rc___0 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int rc___1 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  GSBOOL found_media ;
  int i ;
  int n ;
  char buf[256] ;
  int tmp___13 ;
  CDSCMEDIA const   *m ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  int tmp___27 ;
  int tmp___28 ;
  int tmp___29 ;
  int tmp___30 ;
  int tmp___31 ;
  int tmp___32 ;
  int tmp___33 ;
  int tmp___34 ;
  int tmp___35 ;
  int tmp___36 ;
  int tmp___37 ;
  int tmp___38 ;
  int tmp___39 ;
  GSBOOL tmp___40 ;
  int tmp___41 ;
  int tmp___42 ;
  int tmp___43 ;
  int tmp___44 ;
  int tmp___45 ;

  {
#line 3006
  line = dsc->line;
#line 3007
  dsc->id = 0;
#line 3009
  if (dsc->scan_section == 10) {
    {
#line 3010
    tmp___1 = strncmp((char const   *)line, "%%Page:", sizeof("%%Page:") - 1UL);
    }
#line 3010
    if (tmp___1 == 0) {
#line 3011
      dsc->scan_section = 11;
    } else {
#line 3020
      if (dsc->endsetup != 0UL) {
#line 3021
        last = & dsc->endsetup;
      } else
#line 3022
      if (dsc->endprolog != 0UL) {
#line 3023
        last = & dsc->endprolog;
      } else
#line 3024
      if (dsc->enddefaults != 0UL) {
#line 3025
        last = & dsc->enddefaults;
      } else
#line 3026
      if (dsc->endpreview != 0UL) {
#line 3027
        last = & dsc->endpreview;
      } else
#line 3028
      if (dsc->endcomments != 0UL) {
#line 3029
        last = & dsc->endcomments;
      } else {
#line 3031
        last = & dsc->begincomments;
      }
      {
#line 3032
      *last = (dsc->data_offset + (unsigned long )dsc->data_index) - (unsigned long )dsc->line_length;
#line 3033
      tmp = strncmp((char const   *)line, "%%Trailer", sizeof("%%Trailer") - 1UL);
      }
#line 3033
      if (tmp == 0) {
#line 3034
        dsc->scan_section = 12;
#line 3035
        return (10);
      } else {
        {
#line 3033
        tmp___0 = strncmp((char const   *)line, "%%EOF", sizeof("%%EOF") - 1UL);
        }
#line 3033
        if (tmp___0 == 0) {
#line 3034
          dsc->scan_section = 12;
#line 3035
          return (10);
        }
      }
#line 3037
      *last = dsc->data_offset + (unsigned long )dsc->data_index;
#line 3038
      return (0);
    }
  }
#line 3042
  if (! ((int )*(line + 0) != 37)) {
#line 3042
    if (! ((int )*(line + 1) != 37)) {
      {
#line 3045
      tmp___45 = strncmp((char const   *)line, "%%Page:", sizeof("%%Page:") - 1UL);
      }
#line 3045
      if (tmp___45 == 0) {
#line 3047
        dsc->id = 700;
#line 3048
        if (dsc->page_count) {
          {
#line 3049
          (dsc->page + (dsc->page_count - 1U))->end = (dsc->data_offset + (unsigned long )dsc->data_index) - (unsigned long )dsc->line_length;
#line 3050
          tmp___2 = dsc_check_match(dsc);
          }
#line 3050
          if (tmp___2) {
#line 3051
            return (1);
          }
        }
        {
#line 3054
        code = dsc_parse_page(dsc);
        }
#line 3054
        if (code != 0) {
#line 3055
          return (code);
        }
#line 3056
        if (dsc->page_count == 0U) {
#line 3057
          dsc->scan_section = 10;
        }
      } else {
        {
#line 3059
        tmp___44 = strncmp((char const   *)line, "%%BeginPreview", sizeof("%%BeginPreview") - 1UL);
        }
#line 3059
        if (! (tmp___44 == 0)) {
          {
#line 3062
          tmp___43 = strncmp((char const   *)line, "%%BeginDefaults", sizeof("%%BeginDefaults") - 1UL);
          }
#line 3062
          if (! (tmp___43 == 0)) {
            {
#line 3065
            tmp___42 = strncmp((char const   *)line, "%%BeginProlog", sizeof("%%BeginProlog") - 1UL);
            }
#line 3065
            if (! (tmp___42 == 0)) {
              {
#line 3068
              tmp___41 = strncmp((char const   *)line, "%%BeginSetup", sizeof("%%BeginSetup") - 1UL);
              }
#line 3068
              if (! (tmp___41 == 0)) {
                {
#line 3071
                tmp___40 = dsc_is_section(line);
                }
#line 3071
                if (tmp___40) {
                  {
#line 3072
                  tmp___12 = strncmp((char const   *)line, "%%Trailer", sizeof("%%Trailer") - 1UL);
                  }
#line 3072
                  if (tmp___12 == 0) {
#line 3073
                    if (dsc->page_count) {
#line 3074
                      (dsc->page + (dsc->page_count - 1U))->end = (dsc->data_offset + (unsigned long )dsc->data_index) - (unsigned long )dsc->line_length;
                    }
#line 3075
                    if (dsc->file_length) {
#line 3076
                      if (! dsc->doseps_end) {
#line 3076
                        if ((dsc->data_offset + (unsigned long )dsc->data_index) + 32768UL < dsc->file_length) {
#line 3076
                          goto _L;
                        } else {
#line 3076
                          goto _L___1;
                        }
                      } else
                      _L___1: /* CIL Label */ 
#line 3076
                      if (dsc->doseps_end) {
#line 3076
                        if ((dsc->data_offset + (unsigned long )dsc->data_index) + 32768UL < dsc->doseps_end) {
                          _L: /* CIL Label */ 
                          {
#line 3080
                          tmp___3 = dsc_error(dsc, 1U, dsc->line, dsc->line_length);
#line 3080
                          rc = tmp___3;
                          }
                          {
#line 3083
                          if (rc == 0) {
#line 3083
                            goto case_0;
                          }
#line 3086
                          if (rc == 1) {
#line 3086
                            goto case_1;
                          }
#line 3092
                          if (rc == 2) {
#line 3092
                            goto case_2;
                          }
#line 3082
                          goto switch_break;
                          case_0: /* CIL Label */ 
#line 3085
                          goto switch_break;
                          case_1: /* CIL Label */ 
                          {
#line 3088
                          dsc->scan_section = 12;
#line 3089
                          tmp___4 = dsc_check_match(dsc);
                          }
#line 3089
                          if (tmp___4) {
#line 3090
                            return (1);
                          }
#line 3091
                          return (10);
                          case_2: /* CIL Label */ 
#line 3093
                          return (1);
                          switch_break: /* CIL Label */ ;
                          }
                        } else {
#line 3076
                          goto _L___0;
                        }
                      } else {
                        _L___0: /* CIL Label */ 
                        {
#line 3097
                        dsc->scan_section = 12;
#line 3098
                        tmp___5 = dsc_check_match(dsc);
                        }
#line 3098
                        if (tmp___5) {
#line 3099
                          return (1);
                        }
#line 3100
                        return (10);
                      }
                    } else {
                      {
#line 3104
                      dsc->scan_section = 12;
#line 3105
                      tmp___6 = dsc_check_match(dsc);
                      }
#line 3105
                      if (tmp___6) {
#line 3106
                        return (1);
                      }
#line 3107
                      return (10);
                    }
                  } else {
                    {
#line 3110
                    tmp___11 = strncmp((char const   *)line, "%%EOF", sizeof("%%EOF") - 1UL);
                    }
#line 3110
                    if (tmp___11 == 0) {
#line 3111
                      if (dsc->page_count) {
#line 3112
                        (dsc->page + (dsc->page_count - 1U))->end = (dsc->data_offset + (unsigned long )dsc->data_index) - (unsigned long )dsc->line_length;
                      }
#line 3113
                      if (dsc->file_length) {
#line 3114
                        if (! dsc->doseps_end) {
#line 3114
                          if ((dsc->data_offset + (unsigned long )dsc->data_index) + 100UL < dsc->file_length) {
#line 3114
                            goto _L___2;
                          } else {
#line 3114
                            goto _L___3;
                          }
                        } else
                        _L___3: /* CIL Label */ 
#line 3114
                        if (dsc->doseps_end) {
#line 3114
                          if ((dsc->data_offset + (unsigned long )dsc->data_index) + 100UL < dsc->doseps_end) {
                            _L___2: /* CIL Label */ 
                            {
#line 3118
                            tmp___7 = dsc_error(dsc, 2U, dsc->line, dsc->line_length);
#line 3118
                            rc___0 = tmp___7;
                            }
                            {
#line 3121
                            if (rc___0 == 0) {
#line 3121
                              goto case_0___0;
                            }
#line 3124
                            if (rc___0 == 1) {
#line 3124
                              goto case_1___0;
                            }
#line 3131
                            if (rc___0 == 2) {
#line 3131
                              goto case_2___0;
                            }
#line 3120
                            goto switch_break___0;
                            case_0___0: /* CIL Label */ 
#line 3123
                            goto switch_break___0;
                            case_1___0: /* CIL Label */ 
                            {
#line 3126
                            dsc->scan_section = 14;
#line 3127
                            dsc->eof = 1;
#line 3128
                            tmp___8 = dsc_check_match(dsc);
                            }
#line 3128
                            if (tmp___8) {
#line 3129
                              return (1);
                            }
#line 3130
                            return (10);
                            case_2___0: /* CIL Label */ 
#line 3132
                            return (1);
                            switch_break___0: /* CIL Label */ ;
                            }
                          }
                        }
                      } else {
                        {
#line 3138
                        tmp___9 = dsc_check_match(dsc);
                        }
#line 3138
                        if (tmp___9) {
#line 3139
                          return (1);
                        }
#line 3140
                        return (0);
                      }
                    } else {
                      {
#line 3146
                      tmp___10 = dsc_error(dsc, 13U, dsc->line, dsc->line_length);
#line 3146
                      rc___1 = tmp___10;
                      }
#line 3148
                      if (rc___1 == 2) {
#line 3149
                        return (1);
                      }
                    }
                  }
                } else {
                  {
#line 3152
                  tmp___39 = strncmp((char const   *)line, "%%PageTrailer", sizeof("%%PageTrailer") - 1UL);
                  }
#line 3152
                  if (tmp___39 == 0) {
#line 3153
                    dsc->id = 701;
                  } else {
                    {
#line 3156
                    tmp___38 = strncmp((char const   *)line, "%%BeginPageSetup", sizeof("%%BeginPageSetup") - 1UL);
                    }
#line 3156
                    if (tmp___38 == 0) {
#line 3157
                      dsc->id = 702;
                    } else {
                      {
#line 3160
                      tmp___37 = strncmp((char const   *)line, "%%EndPageSetup", sizeof("%%EndPageSetup") - 1UL);
                      }
#line 3160
                      if (tmp___37 == 0) {
#line 3161
                        dsc->id = 703;
                      } else {
                        {
#line 3164
                        tmp___36 = strncmp((char const   *)line, "%%PageMedia:", sizeof("%%PageMedia:") - 1UL);
                        }
#line 3164
                        if (tmp___36 == 0) {
#line 3165
                          dsc->id = 704;
#line 3166
                          if (dsc->page_count) {
                            {
#line 3167
                            dsc_parse_media(dsc, & (dsc->page + (dsc->page_count - 1U))->media);
                            }
                          }
                        } else {
                          {
#line 3169
                          tmp___35 = strncmp((char const   *)line, "%%PaperColor:",
                                             sizeof("%%PaperColor:") - 1UL);
                          }
#line 3169
                          if (tmp___35 == 0) {
#line 3170
                            dsc->id = 604;
                          } else {
                            {
#line 3173
                            tmp___34 = strncmp((char const   *)line, "%%PaperForm:",
                                               sizeof("%%PaperForm:") - 1UL);
                            }
#line 3173
                            if (tmp___34 == 0) {
#line 3174
                              dsc->id = 605;
                            } else {
                              {
#line 3177
                              tmp___33 = strncmp((char const   *)line, "%%PaperWeight:",
                                                 sizeof("%%PaperWeight:") - 1UL);
                              }
#line 3177
                              if (tmp___33 == 0) {
#line 3178
                                dsc->id = 606;
                              } else {
                                {
#line 3181
                                tmp___32 = strncmp((char const   *)line, "%%PaperSize:",
                                                   sizeof("%%PaperSize:") - 1UL);
                                }
#line 3181
                                if (tmp___32 == 0) {
                                  {
#line 3183
                                  found_media = 0;
#line 3185
                                  n = 12;
#line 3187
                                  buf[0] = (char )'\000';
#line 3188
                                  dsc_copy_string(buf, (unsigned int )(sizeof(buf) - 1UL),
                                                  dsc->line + n, dsc->line_length - (unsigned int )n,
                                                  (unsigned int *)((void *)0));
#line 3190
                                  i = 0;
                                  }
                                  {
#line 3190
                                  while (1) {
                                    while_continue: /* CIL Label */ ;
#line 3190
                                    if (! (i < (int )dsc->media_count)) {
#line 3190
                                      goto while_break;
                                    }
#line 3191
                                    if (*(dsc->media + i)) {
#line 3191
                                      if ((*(dsc->media + i))->name) {
                                        {
#line 3191
                                        tmp___13 = dsc_stricmp((char const   *)(buf),
                                                               (*(dsc->media + i))->name);
                                        }
#line 3191
                                        if (tmp___13 == 0) {
#line 3193
                                          if (dsc->page_count) {
#line 3194
                                            (dsc->page + (dsc->page_count - 1U))->media = (CDSCMEDIA const   *)*(dsc->media + i);
                                          }
#line 3195
                                          found_media = 1;
#line 3196
                                          goto while_break;
                                        }
                                      }
                                    }
#line 3190
                                    i ++;
                                  }
                                  while_break: /* CIL Label */ ;
                                  }
#line 3199
                                  if (! found_media) {
#line 3202
                                    m = dsc_known_media;
                                    {
#line 3203
                                    while (1) {
                                      while_continue___0: /* CIL Label */ ;
#line 3203
                                      if (! m->name) {
#line 3203
                                        goto while_break___0;
                                      }
                                      {
#line 3204
                                      tmp___14 = dsc_stricmp((char const   *)(buf),
                                                             (char const   *)m->name);
                                      }
#line 3204
                                      if (tmp___14 == 0) {
#line 3205
                                        if (dsc->page_count) {
#line 3206
                                          (dsc->page + (dsc->page_count - 1U))->media = m;
                                        }
#line 3207
                                        goto while_break___0;
                                      }
#line 3209
                                      m ++;
                                    }
                                    while_break___0: /* CIL Label */ ;
                                    }
#line 3211
                                    if ((unsigned long )m->name == (unsigned long )((void *)0)) {
                                      {
#line 3212
                                      dsc_unknown(dsc);
                                      }
                                    }
                                  }
                                } else {
                                  {
#line 3215
                                  tmp___31 = strncmp((char const   *)line, "%%PageOrientation:",
                                                     sizeof("%%PageOrientation:") - 1UL);
                                  }
#line 3215
                                  if (tmp___31 == 0) {
#line 3216
                                    if (dsc->page_count) {
                                      {
#line 3217
                                      dsc->id = 705;
#line 3218
                                      tmp___15 = dsc_parse_orientation(dsc, & (dsc->page + (dsc->page_count - 1U))->orientation,
                                                                       18);
                                      }
#line 3218
                                      if (tmp___15) {
#line 3220
                                        return (1);
                                      }
                                    }
                                  } else {
                                    {
#line 3223
                                    tmp___30 = strncmp((char const   *)line, "%%PageBoundingBox:",
                                                       sizeof("%%PageBoundingBox:") - 1UL);
                                    }
#line 3223
                                    if (tmp___30 == 0) {
#line 3224
                                      if (dsc->page_count) {
                                        {
#line 3225
                                        dsc->id = 706;
#line 3226
                                        tmp___16 = dsc_parse_bounding_box(dsc, & (dsc->page + (dsc->page_count - 1U))->bbox,
                                                                          18);
                                        }
#line 3226
                                        if (tmp___16) {
#line 3228
                                          return (1);
                                        }
                                      }
                                    } else {
                                      {
#line 3231
                                      tmp___29 = strncmp((char const   *)line, "%%ViewingOrientation:",
                                                         sizeof("%%ViewingOrientation:") - 1UL);
                                      }
#line 3231
                                      if (tmp___29 == 0) {
#line 3232
                                        if (dsc->page_count) {
                                          {
#line 3233
                                          dsc->id = 708;
#line 3234
                                          tmp___17 = dsc_parse_viewing_orientation(dsc,
                                                                                   & (dsc->page + (dsc->page_count - 1U))->viewing_orientation);
                                          }
#line 3234
                                          if (tmp___17) {
#line 3236
                                            return (-1);
                                          }
                                        }
                                      } else {
                                        {
#line 3239
                                        tmp___28 = strncmp((char const   *)line, "%%PageCropBox:",
                                                           sizeof("%%PageCropBox:") - 1UL);
                                        }
#line 3239
                                        if (tmp___28 == 0) {
#line 3240
                                          if (dsc->page_count) {
                                            {
#line 3241
                                            dsc->id = 709;
#line 3242
                                            tmp___18 = dsc_parse_float_bounding_box(dsc,
                                                                                    & (dsc->page + (dsc->page_count - 1U))->crop_box,
                                                                                    14);
                                            }
#line 3242
                                            if (tmp___18) {
#line 3244
                                              return (-1);
                                            }
                                          }
                                        } else {
                                          {
#line 3247
                                          tmp___27 = strncmp((char const   *)line,
                                                             "%%BeginFont:", sizeof("%%BeginFont:") - 1UL);
                                          }
#line 3247
                                          if (tmp___27 == 0) {
#line 3248
                                            dsc->id = 503;
#line 3251
                                            (dsc->begin_font_count) ++;
                                          } else {
                                            {
#line 3253
                                            tmp___26 = strncmp((char const   *)line,
                                                               "%%EndFont", sizeof("%%EndFont") - 1UL);
                                            }
#line 3253
                                            if (tmp___26 == 0) {
#line 3254
                                              dsc->id = 503;
#line 3255
                                              (dsc->begin_font_count) --;
                                            } else {
                                              {
#line 3257
                                              tmp___25 = strncmp((char const   *)line,
                                                                 "%%BeginFeature:",
                                                                 sizeof("%%BeginFeature:") - 1UL);
                                              }
#line 3257
                                              if (tmp___25 == 0) {
#line 3258
                                                dsc->id = 505;
#line 3261
                                                (dsc->begin_feature_count) ++;
                                              } else {
                                                {
#line 3263
                                                tmp___24 = strncmp((char const   *)line,
                                                                   "%%EndFeature",
                                                                   sizeof("%%EndFeature") - 1UL);
                                                }
#line 3263
                                                if (tmp___24 == 0) {
#line 3264
                                                  dsc->id = 506;
#line 3265
                                                  (dsc->begin_feature_count) --;
                                                } else {
                                                  {
#line 3267
                                                  tmp___23 = strncmp((char const   *)line,
                                                                     "%%BeginResource:",
                                                                     sizeof("%%BeginResource:") - 1UL);
                                                  }
#line 3267
                                                  if (tmp___23 == 0) {
#line 3268
                                                    dsc->id = 507;
#line 3271
                                                    (dsc->begin_resource_count) ++;
                                                  } else {
                                                    {
#line 3273
                                                    tmp___22 = strncmp((char const   *)line,
                                                                       "%%EndResource",
                                                                       sizeof("%%EndResource") - 1UL);
                                                    }
#line 3273
                                                    if (tmp___22 == 0) {
#line 3274
                                                      dsc->id = 508;
#line 3275
                                                      (dsc->begin_resource_count) --;
                                                    } else {
                                                      {
#line 3277
                                                      tmp___21 = strncmp((char const   *)line,
                                                                         "%%BeginProcSet:",
                                                                         sizeof("%%BeginProcSet:") - 1UL);
                                                      }
#line 3277
                                                      if (tmp___21 == 0) {
#line 3278
                                                        dsc->id = 509;
#line 3281
                                                        (dsc->begin_procset_count) ++;
                                                      } else {
                                                        {
#line 3283
                                                        tmp___20 = strncmp((char const   *)line,
                                                                           "%%EndProcSet",
                                                                           sizeof("%%EndProcSet") - 1UL);
                                                        }
#line 3283
                                                        if (tmp___20 == 0) {
#line 3284
                                                          dsc->id = 510;
#line 3285
                                                          (dsc->begin_procset_count) --;
                                                        } else {
                                                          {
#line 3287
                                                          tmp___19 = strncmp((char const   *)line,
                                                                             "%%IncludeFont:",
                                                                             sizeof("%%IncludeFont:") - 1UL);
                                                          }
#line 3287
                                                          if (tmp___19 == 0) {
#line 3288
                                                            dsc->id = 707;
                                                          } else {
                                                            {
#line 3293
                                                            dsc->id = 100;
#line 3294
                                                            dsc_unknown(dsc);
                                                            }
                                                          }
                                                        }
                                                      }
                                                    }
                                                  }
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
#line 3297
  if (dsc->page_count) {
#line 3298
    (dsc->page + (dsc->page_count - 1U))->end = dsc->data_offset + (unsigned long )dsc->data_index;
  }
#line 3299
  return (0);
}
}
#line 3348 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/dscparse.c"
static int dsc_scan_trailer(CDSC *dsc ) 
{ 
  char *line ;
  GSBOOL continued ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int rc ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  int tmp___27 ;
  int tmp___28 ;
  int tmp___29 ;

  {
#line 3355
  line = dsc->line;
#line 3356
  continued = 0;
#line 3357
  dsc->id = 0;
#line 3359
  if (dsc->scan_section == 12) {
    {
#line 3360
    tmp___0 = strncmp((char const   *)line, "%%Trailer", sizeof("%%Trailer") - 1UL);
    }
#line 3360
    if (tmp___0 == 0) {
#line 3361
      dsc->id = 800;
#line 3362
      dsc->begintrailer = (dsc->data_offset + (unsigned long )dsc->data_index) - (unsigned long )dsc->line_length;
#line 3363
      dsc->endtrailer = dsc->data_offset + (unsigned long )dsc->data_index;
#line 3364
      dsc->scan_section = 13;
#line 3365
      return (0);
    } else {
      {
#line 3367
      tmp = strncmp((char const   *)line, "%%EOF", sizeof("%%EOF") - 1UL);
      }
#line 3367
      if (tmp == 0) {
#line 3368
        dsc->id = 900;
#line 3369
        dsc->begintrailer = (dsc->data_offset + (unsigned long )dsc->data_index) - (unsigned long )dsc->line_length;
#line 3370
        dsc->endtrailer = dsc->data_offset + (unsigned long )dsc->data_index;
#line 3371
        dsc->scan_section = 13;
#line 3373
        return (0);
      } else {
#line 3381
        if (dsc->beginsetup) {
#line 3382
          dsc->endsetup = dsc->data_offset + (unsigned long )dsc->data_index;
        } else
#line 3383
        if (dsc->beginprolog) {
#line 3384
          dsc->endprolog = dsc->data_offset + (unsigned long )dsc->data_index;
        }
#line 3388
        return (0);
      }
    }
  }
  {
#line 3396
  tmp___1 = strncmp((char const   *)line, "%%+", sizeof("%%+") - 1UL);
  }
#line 3396
  if (tmp___1 == 0) {
#line 3397
    line = dsc->last_line;
#line 3398
    continued = 1;
  } else {
    {
#line 3401
    dsc_save_line(dsc);
    }
  }
#line 3403
  if (! ((int )*(line + 0) != 37)) {
#line 3403
    if (! ((int )*(line + 1) != 37)) {
      {
#line 3406
      tmp___29 = strncmp((char const   *)dsc->line, "%%EOF", sizeof("%%EOF") - 1UL);
      }
#line 3406
      if (tmp___29 == 0) {
#line 3408
        dsc->id = 900;
      } else {
        {
#line 3410
        tmp___28 = strncmp((char const   *)dsc->line, "%%Trailer", sizeof("%%Trailer") - 1UL);
        }
#line 3410
        if (tmp___28 == 0) {
#line 3413
          dsc->id = 800;
#line 3414
          dsc->begintrailer = (dsc->data_offset + (unsigned long )dsc->data_index) - (unsigned long )dsc->line_length;
        } else {
          {
#line 3416
          tmp___27 = strncmp((char const   *)line, "%%Pages:", sizeof("%%Pages:") - 1UL);
          }
#line 3416
          if (tmp___27 == 0) {
            {
#line 3417
            dsc->id = 203;
#line 3418
            tmp___2 = dsc_parse_pages(dsc);
            }
#line 3418
            if (tmp___2 != 0) {
#line 3419
              return (-1);
            }
          } else {
            {
#line 3421
            tmp___26 = strncmp((char const   *)line, "%%BoundingBox:", sizeof("%%BoundingBox:") - 1UL);
            }
#line 3421
            if (tmp___26 == 0) {
#line 3422
              dsc->id = 209;
#line 3423
              if (continued) {
#line 3423
                tmp___3 = 3;
              } else {
#line 3423
                tmp___3 = 14;
              }
              {
#line 3423
              tmp___4 = dsc_parse_bounding_box(dsc, & dsc->bbox, tmp___3);
              }
#line 3423
              if (tmp___4) {
#line 3424
                return (-1);
              }
            } else {
              {
#line 3426
              tmp___25 = strncmp((char const   *)line, "%%HiResBoundingBox:", sizeof("%%HiResBoundingBox:") - 1UL);
              }
#line 3426
              if (tmp___25 == 0) {
#line 3427
                dsc->id = 221;
#line 3428
                if (continued) {
#line 3428
                  tmp___5 = 3;
                } else {
#line 3428
                  tmp___5 = 19;
                }
                {
#line 3428
                tmp___6 = dsc_parse_float_bounding_box(dsc, & dsc->hires_bbox, tmp___5);
                }
#line 3428
                if (tmp___6) {
#line 3430
                  return (-1);
                }
              } else {
                {
#line 3432
                tmp___24 = strncmp((char const   *)line, "%%CropBox:", sizeof("%%CropBox:") - 1UL);
                }
#line 3432
                if (tmp___24 == 0) {
#line 3433
                  dsc->id = 222;
#line 3434
                  if (continued) {
#line 3434
                    tmp___7 = 3;
                  } else {
#line 3434
                    tmp___7 = 10;
                  }
                  {
#line 3434
                  tmp___8 = dsc_parse_float_bounding_box(dsc, & dsc->crop_box, tmp___7);
                  }
#line 3434
                  if (tmp___8) {
#line 3436
                    return (-1);
                  }
                } else {
                  {
#line 3438
                  tmp___23 = strncmp((char const   *)line, "%%Orientation:", sizeof("%%Orientation:") - 1UL);
                  }
#line 3438
                  if (tmp___23 == 0) {
#line 3439
                    dsc->id = 210;
#line 3440
                    if (continued) {
#line 3440
                      tmp___9 = 3;
                    } else {
#line 3440
                      tmp___9 = 14;
                    }
                    {
#line 3440
                    tmp___10 = dsc_parse_orientation(dsc, & dsc->page_orientation,
                                                     tmp___9);
                    }
#line 3440
                    if (tmp___10) {
#line 3441
                      return (-1);
                    }
                  } else {
                    {
#line 3443
                    tmp___22 = strncmp((char const   *)line, "%%PageOrder:", sizeof("%%PageOrder:") - 1UL);
                    }
#line 3443
                    if (tmp___22 == 0) {
                      {
#line 3444
                      dsc->id = 211;
#line 3445
                      tmp___11 = dsc_parse_order(dsc);
                      }
#line 3445
                      if (tmp___11) {
#line 3446
                        return (-1);
                      }
                    } else {
                      {
#line 3448
                      tmp___21 = strncmp((char const   *)line, "%%DocumentMedia:",
                                         sizeof("%%DocumentMedia:") - 1UL);
                      }
#line 3448
                      if (tmp___21 == 0) {
                        {
#line 3449
                        dsc->id = 212;
#line 3450
                        tmp___12 = dsc_parse_document_media(dsc);
                        }
#line 3450
                        if (tmp___12) {
#line 3451
                          return (-1);
                        }
                      } else {
                        {
#line 3453
                        tmp___20 = strncmp((char const   *)dsc->line, "%%Page:", sizeof("%%Page:") - 1UL);
                        }
#line 3453
                        if (tmp___20 == 0) {
                          {
#line 3457
                          tmp___13 = dsc_error(dsc, 3U, dsc->line, dsc->line_length);
#line 3457
                          rc = tmp___13;
                          }
                          {
#line 3460
                          if (rc == 0) {
#line 3460
                            goto case_0;
                          }
#line 3467
                          if (rc == 1) {
#line 3467
                            goto case_1;
                          }
#line 3470
                          if (rc == 2) {
#line 3470
                            goto case_2;
                          }
#line 3459
                          goto switch_break;
                          case_0: /* CIL Label */ 
#line 3463
                          dsc->scan_section = 10;
#line 3464
                          if (dsc->page_count) {
#line 3465
                            (dsc->page + (dsc->page_count - 1U))->end = (dsc->data_offset + (unsigned long )dsc->data_index) - (unsigned long )dsc->line_length;
                          }
#line 3466
                          return (10);
                          case_1: /* CIL Label */ 
#line 3469
                          goto switch_break;
                          case_2: /* CIL Label */ 
#line 3471
                          return (1);
                          switch_break: /* CIL Label */ ;
                          }
                        } else {
                          {
#line 3474
                          tmp___19 = strncmp((char const   *)line, "%%DocumentNeededFonts:",
                                             sizeof("%%DocumentNeededFonts:") - 1UL);
                          }
#line 3474
                          if (tmp___19 == 0) {
#line 3475
                            dsc->id = 219;
                          } else {
                            {
#line 3478
                            tmp___18 = strncmp((char const   *)line, "%%DocumentSuppliedFonts:",
                                               sizeof("%%DocumentSuppliedFonts:") - 1UL);
                            }
#line 3478
                            if (tmp___18 == 0) {
#line 3479
                              dsc->id = 220;
                            } else {
                              {
#line 3482
                              tmp___17 = strncmp((char const   *)line, "%%DocumentProcessColors:",
                                                 sizeof("%%DocumentProcessColors:") - 1UL);
                              }
#line 3482
                              if (tmp___17 == 0) {
                                {
#line 3483
                                dsc->id = 224;
#line 3484
                                tmp___14 = dsc_parse_process_colours(dsc);
                                }
#line 3484
                                if (tmp___14 != 0) {
#line 3485
                                  dsc->id = 100;
                                }
                              } else {
                                {
#line 3487
                                tmp___16 = strncmp((char const   *)line, "%%DocumentCustomColors:",
                                                   sizeof("%%DocumentCustomColors:") - 1UL);
                                }
#line 3487
                                if (tmp___16 == 0) {
                                  {
#line 3488
                                  dsc->id = 225;
#line 3489
                                  tmp___15 = dsc_parse_custom_colours(dsc);
                                  }
#line 3489
                                  if (tmp___15 != 0) {
#line 3490
                                    dsc->id = 100;
                                  }
                                } else {
                                  {
#line 3494
                                  dsc->id = 100;
#line 3495
                                  dsc_unknown(dsc);
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
#line 3498
  dsc->endtrailer = dsc->data_offset + (unsigned long )dsc->data_index;
#line 3499
  return (0);
}
}
#line 3503 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/dscparse.c"
static char *dsc_alloc_string(CDSC *dsc , char const   *str , int len ) 
{ 
  char *p ;
  void *tmp ;
  void *tmp___0 ;
  CDSCSTRING *newstring ;
  void *tmp___1 ;
  void *tmp___2 ;

  {
#line 3507
  if ((unsigned long )dsc->string_head == (unsigned long )((void *)0)) {
    {
#line 3508
    tmp = dsc_memalloc(dsc, sizeof(CDSCSTRING ));
#line 3508
    dsc->string_head = (CDSCSTRING *)tmp;
    }
#line 3509
    if ((unsigned long )dsc->string_head == (unsigned long )((void *)0)) {
#line 3510
      return ((char *)((void *)0));
    }
    {
#line 3511
    dsc->string = dsc->string_head;
#line 3512
    (dsc->string)->next = (CDSCSTRING *)((void *)0);
#line 3513
    tmp___0 = dsc_memalloc(dsc, (size_t )4096);
#line 3513
    (dsc->string)->data = (char *)tmp___0;
    }
#line 3514
    if ((unsigned long )(dsc->string)->data == (unsigned long )((void *)0)) {
      {
#line 3515
      dsc_reset(dsc);
      }
#line 3516
      return ((char *)((void *)0));
    }
#line 3518
    (dsc->string)->index = 0U;
#line 3519
    (dsc->string)->length = 4096U;
  }
#line 3521
  if (((dsc->string)->index + (unsigned int )len) + 1U > (dsc->string)->length) {
    {
#line 3523
    tmp___1 = dsc_memalloc(dsc, sizeof(CDSCSTRING ));
#line 3523
    newstring = (CDSCSTRING *)tmp___1;
    }
#line 3524
    if ((unsigned long )newstring == (unsigned long )((void *)0)) {
      {
#line 3525
      dsc_debug_print(dsc, "Out of memory\n");
      }
#line 3526
      return ((char *)((void *)0));
    }
    {
#line 3528
    newstring->next = (CDSCSTRING *)((void *)0);
#line 3529
    newstring->length = 0U;
#line 3530
    newstring->index = 0U;
#line 3531
    tmp___2 = dsc_memalloc(dsc, (size_t )4096);
#line 3531
    newstring->data = (char *)tmp___2;
    }
#line 3532
    if ((unsigned long )newstring->data == (unsigned long )((void *)0)) {
      {
#line 3533
      dsc_memfree(dsc, (void *)newstring);
#line 3534
      dsc_debug_print(dsc, "Out of memory\n");
      }
#line 3535
      return ((char *)((void *)0));
    }
#line 3537
    newstring->length = 4096U;
#line 3538
    (dsc->string)->next = newstring;
#line 3539
    dsc->string = newstring;
  }
#line 3541
  if (((dsc->string)->index + (unsigned int )len) + 1U > (dsc->string)->length) {
#line 3542
    return ((char *)((void *)0));
  }
  {
#line 3543
  p = (dsc->string)->data + (dsc->string)->index;
#line 3544
  memcpy((void */* __restrict  */)p, (void const   */* __restrict  */)str, (size_t )len);
#line 3545
  *(p + len) = (char )'\000';
#line 3546
  (dsc->string)->index += (unsigned int )(len + 1);
  }
#line 3547
  return (p);
}
}
#line 3551 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/dscparse.c"
static char *dsc_add_line(CDSC *dsc , char const   *line , unsigned int len ) 
{ 
  char *newline ;
  unsigned int i ;

  {
  {
#line 3556
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3556
    if (len) {
#line 3556
      if (! ((int const   )*line == 32)) {
#line 3556
        if (! ((int const   )*line == 9)) {
#line 3556
          goto while_break;
        }
      }
    } else {
#line 3556
      goto while_break;
    }
#line 3557
    len --;
#line 3558
    line ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 3560
  newline = dsc_alloc_string(dsc, line, (int )len);
  }
#line 3561
  if ((unsigned long )newline == (unsigned long )((void *)0)) {
#line 3562
    return ((char *)((void *)0));
  }
#line 3564
  i = 0U;
  {
#line 3564
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 3564
    if (! (i < len)) {
#line 3564
      goto while_break___0;
    }
#line 3565
    if ((int )*(newline + i) == 13) {
#line 3566
      *(newline + i) = (char )'\000';
#line 3567
      goto while_break___0;
    }
#line 3569
    if ((int )*(newline + i) == 10) {
#line 3570
      *(newline + i) = (char )'\000';
#line 3571
      goto while_break___0;
    }
#line 3564
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 3574
  return (newline);
}
}
#line 3584 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/dscparse.c"
static char *dsc_copy_string(char *str , unsigned int slen , char *line , unsigned int len ,
                             unsigned int *offset ) 
{ 
  int quoted ;
  int instring ;
  unsigned int newlength ;
  unsigned int i ;
  unsigned char ch ;
  int j ;

  {
#line 3588
  quoted = 0;
#line 3589
  instring = 0;
#line 3590
  newlength = 0U;
#line 3591
  i = 0U;
#line 3593
  if (len > slen) {
#line 3594
    len = slen - 1U;
  }
  {
#line 3595
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3595
    if (i < len) {
#line 3595
      if (! ((int )*(line + i) == 32)) {
#line 3595
        if (! ((int )*(line + i) == 9)) {
#line 3595
          goto while_break;
        }
      }
    } else {
#line 3595
      goto while_break;
    }
#line 3596
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 3597
  if (i < len) {
#line 3597
    if ((int )*(line + i) == 40) {
#line 3598
      quoted = 1;
#line 3599
      instring ++;
#line 3600
      i ++;
    }
  }
  {
#line 3602
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 3602
    if (! (i < len)) {
#line 3602
      goto while_break___0;
    }
#line 3603
    ch = (unsigned char )*(line + i);
#line 3603
    *(str + newlength) = (char )ch;
#line 3604
    i ++;
#line 3605
    if (quoted) {
#line 3606
      if ((int )ch == 40) {
#line 3607
        instring ++;
      }
#line 3608
      if ((int )ch == 41) {
#line 3609
        instring --;
      }
#line 3610
      if (instring == 0) {
#line 3611
        goto while_break___0;
      }
    } else
#line 3613
    if ((int )ch == 32) {
#line 3614
      goto while_break___0;
    }
#line 3616
    if ((int )ch == 13) {
#line 3617
      goto while_break___0;
    }
#line 3618
    if ((int )ch == 10) {
#line 3619
      goto while_break___0;
    } else
#line 3620
    if ((int )ch == 92) {
#line 3620
      if (i + 1U < len) {
#line 3621
        ch = (unsigned char )*(line + i);
#line 3622
        if ((int )ch >= 48) {
#line 3622
          if ((int )ch <= 57) {
#line 3624
            j = 3;
#line 3625
            ch = (unsigned char)0;
            {
#line 3626
            while (1) {
              while_continue___1: /* CIL Label */ ;
#line 3626
              if (j) {
#line 3626
                if (i < len) {
#line 3626
                  if ((int )*(line + i) >= 48) {
#line 3626
                    if (! ((int )*(line + i) <= 55)) {
#line 3626
                      goto while_break___1;
                    }
                  } else {
#line 3626
                    goto while_break___1;
                  }
                } else {
#line 3626
                  goto while_break___1;
                }
              } else {
#line 3626
                goto while_break___1;
              }
#line 3627
              ch = (unsigned char )(((int )ch << 3) + ((int )*(line + i) - 48));
#line 3628
              i ++;
#line 3629
              j --;
            }
            while_break___1: /* CIL Label */ ;
            }
#line 3631
            *(str + newlength) = (char )ch;
          } else {
#line 3622
            goto _L;
          }
        } else
        _L: /* CIL Label */ 
#line 3633
        if ((int )ch == 40) {
#line 3634
          *(str + newlength) = (char )ch;
#line 3635
          i ++;
        } else
#line 3637
        if ((int )ch == 41) {
#line 3638
          *(str + newlength) = (char )ch;
#line 3639
          i ++;
        } else
#line 3641
        if ((int )ch == 98) {
#line 3642
          *(str + newlength) = (char )'\b';
#line 3643
          i ++;
        } else
#line 3645
        if ((int )ch == 102) {
#line 3646
          *(str + newlength) = (char )'\b';
#line 3647
          i ++;
        } else
#line 3649
        if ((int )ch == 110) {
#line 3650
          *(str + newlength) = (char )'\n';
#line 3651
          i ++;
        } else
#line 3653
        if ((int )ch == 114) {
#line 3654
          *(str + newlength) = (char )'\r';
#line 3655
          i ++;
        } else
#line 3657
        if ((int )ch == 116) {
#line 3658
          *(str + newlength) = (char )'\t';
#line 3659
          i ++;
        } else
#line 3661
        if ((int )ch == 92) {
#line 3662
          *(str + newlength) = (char )'\\';
#line 3663
          i ++;
        }
      }
    }
#line 3666
    newlength ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 3668
  *(str + newlength) = (char )'\000';
#line 3669
  if ((unsigned long )offset != (unsigned long )((unsigned int *)((void *)0))) {
#line 3670
    *offset = i;
  }
#line 3671
  return (str);
}
}
#line 3674 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/dscparse.c"
static int dsc_get_int(char const   *line , unsigned int len , unsigned int *offset ) 
{ 
  char newline[256] ;
  int newlength ;
  unsigned int i ;
  unsigned char ch ;
  unsigned short const   **tmp ;
  int tmp___0 ;

  {
#line 3678
  newlength = 0;
#line 3679
  i = 0U;
#line 3682
  if ((unsigned long )len < sizeof(newline) - 1UL) {
#line 3682
    len = len;
  } else {
#line 3682
    len = (unsigned int )(sizeof(newline) - 1UL);
  }
  {
#line 3683
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3683
    if (i < len) {
#line 3683
      if (! ((int const   )*(line + i) == 32)) {
#line 3683
        if (! ((int const   )*(line + i) == 9)) {
#line 3683
          goto while_break;
        }
      }
    } else {
#line 3683
      goto while_break;
    }
#line 3684
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 3685
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 3685
    if (! (i < len)) {
#line 3685
      goto while_break___0;
    }
    {
#line 3686
    ch = (unsigned char )*(line + i);
#line 3686
    newline[newlength] = (char )ch;
#line 3687
    tmp = __ctype_b_loc();
    }
#line 3687
    if (! ((int const   )*(*tmp + (int )ch) & 2048)) {
#line 3687
      if (! ((int )ch == 45)) {
#line 3687
        if (! ((int )ch == 43)) {
#line 3688
          goto while_break___0;
        }
      }
    }
#line 3689
    i ++;
#line 3690
    newlength ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 3692
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 3692
    if (i < len) {
#line 3692
      if (! ((int const   )*(line + i) == 32)) {
#line 3692
        if (! ((int const   )*(line + i) == 9)) {
#line 3692
          goto while_break___1;
        }
      }
    } else {
#line 3692
      goto while_break___1;
    }
#line 3693
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 3694
  newline[newlength] = (char )'\000';
#line 3695
  if ((unsigned long )offset != (unsigned long )((unsigned int *)((void *)0))) {
#line 3696
    *offset = i;
  }
  {
#line 3697
  tmp___0 = atoi((char const   *)(newline));
  }
#line 3697
  return (tmp___0);
}
}
#line 3700 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/dscparse.c"
static float dsc_get_real(char const   *line , unsigned int len , unsigned int *offset ) 
{ 
  char newline[256] ;
  int newlength ;
  unsigned int i ;
  unsigned char ch ;
  unsigned short const   **tmp ;
  double tmp___0 ;

  {
#line 3704
  newlength = 0;
#line 3705
  i = 0U;
#line 3708
  if ((unsigned long )len < sizeof(newline) - 1UL) {
#line 3708
    len = len;
  } else {
#line 3708
    len = (unsigned int )(sizeof(newline) - 1UL);
  }
  {
#line 3709
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3709
    if (i < len) {
#line 3709
      if (! ((int const   )*(line + i) == 32)) {
#line 3709
        if (! ((int const   )*(line + i) == 9)) {
#line 3709
          goto while_break;
        }
      }
    } else {
#line 3709
      goto while_break;
    }
#line 3710
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 3711
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 3711
    if (! (i < len)) {
#line 3711
      goto while_break___0;
    }
    {
#line 3712
    ch = (unsigned char )*(line + i);
#line 3712
    newline[newlength] = (char )ch;
#line 3713
    tmp = __ctype_b_loc();
    }
#line 3713
    if (! ((int const   )*(*tmp + (int )ch) & 2048)) {
#line 3713
      if (! ((int )ch == 46)) {
#line 3713
        if (! ((int )ch == 45)) {
#line 3713
          if (! ((int )ch == 43)) {
#line 3713
            if (! ((int )ch == 101)) {
#line 3713
              if (! ((int )ch == 69)) {
#line 3715
                goto while_break___0;
              }
            }
          }
        }
      }
    }
#line 3716
    i ++;
#line 3717
    newlength ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 3719
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 3719
    if (i < len) {
#line 3719
      if (! ((int const   )*(line + i) == 32)) {
#line 3719
        if (! ((int const   )*(line + i) == 9)) {
#line 3719
          goto while_break___1;
        }
      }
    } else {
#line 3719
      goto while_break___1;
    }
#line 3720
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 3722
  newline[newlength] = (char )'\000';
#line 3724
  if ((unsigned long )offset != (unsigned long )((unsigned int *)((void *)0))) {
#line 3725
    *offset = i;
  }
  {
#line 3726
  tmp___0 = atof((char const   *)(newline));
  }
#line 3726
  return ((float )tmp___0);
}
}
#line 3729 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/dscparse.c"
int dsc_stricmp(char const   *s , char const   *t ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 3732
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 3732
    tmp = toupper((int )*s);
#line 3732
    tmp___0 = toupper((int )*t);
    }
#line 3732
    if (! (tmp == tmp___0)) {
#line 3732
      goto while_break;
    }
#line 3733
    if ((int const   )*s == 0) {
#line 3734
      return (0);
    }
#line 3735
    s ++;
#line 3736
    t ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 3738
  tmp___1 = toupper((int )*s);
#line 3738
  tmp___2 = toupper((int )*t);
  }
#line 3738
  return (tmp___1 - tmp___2);
}
}
#line 3742 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/dscparse.c"
static int dsc_parse_page(CDSC *dsc ) 
{ 
  char *p ;
  unsigned int i ;
  char page_label[256] ;
  char *pl ;
  int page_ordinal ;
  int page_number ;
  unsigned short const   **tmp ;
  int rc ;
  int tmp___0 ;
  size_t tmp___1 ;

  {
  {
#line 3752
  p = dsc->line + 7;
#line 3753
  pl = dsc_copy_string(page_label, (unsigned int )sizeof(page_label), p, dsc->line_length - 7U,
                       & i);
  }
#line 3754
  if ((unsigned long )pl == (unsigned long )((void *)0)) {
#line 3755
    return (-1);
  }
#line 3756
  p += i;
#line 3757
  if ((dsc->line_length - 7U) - i == 0U) {
    {
#line 3760
    while (1) {
      while_continue: /* CIL Label */ ;
#line 3760
      if (! (i > 0U)) {
#line 3760
        goto while_break;
      }
#line 3761
      if (! ((int )*(p + -1) == 32)) {
#line 3761
        if (! ((int )*(p + -1) == 9)) {
#line 3761
          if (! ((int )*(p + -1) == 13)) {
#line 3761
            if (! ((int )*(p + -1) == 10)) {
#line 3762
              goto while_break;
            }
          }
        }
      }
#line 3763
      p --;
#line 3764
      i --;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 3766
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 3766
      if (! (i > 0U)) {
#line 3766
        goto while_break___0;
      }
      {
#line 3767
      tmp = __ctype_b_loc();
      }
#line 3767
      if (! ((int const   )*(*tmp + (int )*(p + -1)) & 2048)) {
#line 3768
        goto while_break___0;
      }
#line 3769
      p --;
#line 3770
      i --;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  {
#line 3773
  page_ordinal = dsc_get_int((char const   *)p, (dsc->line_length - 7U) - i, (unsigned int *)((void *)0));
  }
#line 3775
  if (page_ordinal == 0) {
#line 3775
    goto _L;
  } else {
    {
#line 3775
    tmp___1 = strlen((char const   *)(page_label));
    }
#line 3775
    if (tmp___1 == 0UL) {
#line 3775
      goto _L;
    } else
#line 3775
    if (dsc->page_count == 0U) {
#line 3775
      if (page_ordinal != 1) {
#line 3775
        goto _L;
      } else {
#line 3775
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 3775
    if (dsc->page_count) {
#line 3775
      if (page_ordinal != (dsc->page + (dsc->page_count - 1U))->ordinal + 1) {
        _L: /* CIL Label */ 
        {
#line 3779
        tmp___0 = dsc_error(dsc, 4U, dsc->line, dsc->line_length);
#line 3779
        rc = tmp___0;
        }
        {
#line 3782
        if (rc == 0) {
#line 3782
          goto case_0;
        }
#line 3785
        if (rc == 1) {
#line 3785
          goto case_1;
        }
#line 3788
        if (rc == 2) {
#line 3788
          goto case_2;
        }
#line 3781
        goto switch_break;
        case_0: /* CIL Label */ 
#line 3784
        return (0);
        case_1: /* CIL Label */ 
#line 3787
        goto switch_break;
        case_2: /* CIL Label */ 
#line 3789
        return (1);
        switch_break: /* CIL Label */ ;
        }
      }
    }
  }
  {
#line 3793
  page_number = (int )dsc->page_count;
#line 3794
  dsc_add_page(dsc, page_ordinal, page_label);
#line 3795
  (dsc->page + page_number)->begin = (dsc->data_offset + (unsigned long )dsc->data_index) - (unsigned long )dsc->line_length;
#line 3796
  (dsc->page + page_number)->end = (dsc->data_offset + (unsigned long )dsc->data_index) - (unsigned long )dsc->line_length;
  }
#line 3798
  if ((unsigned long )(dsc->page + page_number)->label == (unsigned long )((void *)0)) {
#line 3799
    return (-1);
  }
#line 3801
  return (0);
}
}
#line 3805 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/dscparse.c"
static int dsc_parse_feature(CDSC *dsc ) 
{ 
  char *p ;
  unsigned int i ;
  char feature_name[256] ;
  char feature_value[256] ;
  char *fn ;
  char *fv ;
  int found ;
  int media_index ;
  int tmp ;
  int tmp___0 ;
  CDSCMEDIA lmedia ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 3815
  feature_name[0] = (char )'\000';
#line 3816
  feature_value[0] = (char )'\000';
#line 3817
  p = dsc->line + 15;
#line 3818
  fn = dsc_copy_string(feature_name, (unsigned int )sizeof(feature_name), p, dsc->line_length - 15U,
                       & i);
  }
#line 3820
  if ((unsigned long )fn == (unsigned long )((void *)0)) {
#line 3821
    return (-1);
  }
  {
#line 3822
  p += i;
#line 3823
  fv = dsc_copy_string(feature_value, (unsigned int )sizeof(feature_value), p, (dsc->line_length - 15U) - i,
                       & i);
#line 3826
  tmp___2 = dsc_stricmp((char const   *)(feature_name), "*PageSize");
  }
#line 3826
  if (tmp___2 == 0) {
#line 3826
    if ((unsigned long )fv != (unsigned long )((void *)0)) {
#line 3826
      if (dsc->scan_section == 9) {
#line 3832
        found = 0;
#line 3833
        media_index = -1;
#line 3834
        i = 0U;
        {
#line 3834
        while (1) {
          while_continue: /* CIL Label */ ;
#line 3834
          if (! (i < dsc->media_count)) {
#line 3834
            goto while_break;
          }
#line 3835
          if ((*(dsc->media + i))->name) {
            {
#line 3835
            tmp = dsc_stricmp((char const   *)(feature_value), (*(dsc->media + i))->name);
            }
#line 3835
            if (tmp == 0) {
#line 3837
              found = 1;
            }
          }
#line 3834
          i ++;
        }
        while_break: /* CIL Label */ ;
        }
#line 3839
        i = 0U;
        {
#line 3839
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 3839
          if (! dsc_known_media[i].name) {
#line 3839
            goto while_break___0;
          }
          {
#line 3840
          tmp___0 = dsc_stricmp((char const   *)(feature_value), (char const   *)dsc_known_media[i].name);
          }
#line 3840
          if (tmp___0 == 0) {
#line 3841
            media_index = (int )i;
#line 3842
            goto while_break___0;
          }
#line 3839
          i ++;
        }
        while_break___0: /* CIL Label */ ;
        }
#line 3846
        if (! found) {
#line 3846
          if (media_index >= 0) {
            {
#line 3851
            lmedia.name = (char const   *)(feature_value);
#line 3852
            lmedia.width = (float )dsc_known_media[i].width;
#line 3853
            lmedia.height = (float )dsc_known_media[i].height;
#line 3854
            lmedia.weight = (float )80.0;
#line 3855
            lmedia.colour = (char const   *)((void *)0);
#line 3856
            lmedia.type = (char const   *)((void *)0);
#line 3857
            lmedia.mediabox = (CDSCBBOX *)((void *)0);
#line 3858
            tmp___1 = dsc_add_media(dsc, & lmedia);
            }
#line 3858
            if (tmp___1) {
#line 3859
              return (-1);
            }
          }
        }
      }
    }
  }
#line 3863
  return (0);
}
}
#line 3869 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/dscparse.c"
void dsc_debug_print(CDSC *dsc , char const   *str ) 
{ 


  {
#line 3872
  if (dsc->debug_print_fn) {
    {
#line 3873
    (*(dsc->debug_print_fn))(dsc->caller_data, str);
    }
  }
#line 3874
  return;
}
}
#line 3889 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/dscparse.c"
static int dsc_error(CDSC *dsc , unsigned int explanation , char *line , unsigned int line_len ) 
{ 
  int tmp ;

  {
#line 3893
  if ((unsigned long )explanation > sizeof(dsc_severity) / sizeof(int ) - 2UL) {
#line 3894
    return (1);
  }
#line 3895
  if ((int )dsc->worst_error < (int )dsc_severity[explanation]) {
#line 3896
    dsc->worst_error = (CDSC_MESSAGE_SEVERITY )dsc_severity[explanation];
  }
#line 3898
  if (dsc->dsc_error_fn) {
    {
#line 3899
    tmp = (*(dsc->dsc_error_fn))(dsc->caller_data, dsc, explanation, (char const   *)line,
                                 line_len);
    }
#line 3899
    return (tmp);
  }
#line 3903
  return (1);
}
}
#line 3908 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/dscparse.c"
static int dsc_dcs2_fixup(CDSC *dsc ) 
{ 
  char composite[10] ;
  int code ;
  int page_number ;
  unsigned long *pbegin ;
  unsigned long *pend ;
  unsigned long end ;
  CDCS2 *pdcs ;
  size_t tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 3911
  composite[0] = (char )'C';
#line 3911
  composite[1] = (char )'o';
#line 3911
  composite[2] = (char )'m';
#line 3911
  composite[3] = (char )'p';
#line 3911
  composite[4] = (char )'o';
#line 3911
  composite[5] = (char )'s';
#line 3911
  composite[6] = (char )'i';
#line 3911
  composite[7] = (char )'t';
#line 3911
  composite[8] = (char )'e';
#line 3911
  composite[9] = (char )'\000';
#line 3916
  if (dsc->dcs2) {
#line 3917
    code = 0;
#line 3922
    pdcs = dsc->dcs2;
#line 3926
    if (dsc->page_count == 0U) {
      {
#line 3927
      code = dsc_add_page(dsc, 1, composite);
      }
    } else
#line 3928
    if (dsc->page_count == 1U) {
      {
#line 3929
      tmp = strlen((char const   *)(composite));
#line 3929
      tmp___0 = dsc_alloc_string(dsc, (char const   *)(composite), (int )tmp + 1);
#line 3929
      (dsc->page + 0)->label = (char const   *)tmp___0;
      }
    }
#line 3931
    if (code != 0) {
#line 3932
      return (code);
    }
#line 3933
    page_number = (int )(dsc->page_count - 1U);
#line 3934
    pbegin = & (dsc->page + page_number)->begin;
#line 3935
    pend = & (dsc->page + page_number)->end;
#line 3936
    if (*pbegin == *pend) {
#line 3938
      *pbegin = 999999999UL;
#line 3939
      *pend = 0UL;
    }
#line 3942
    if (dsc->begincomments != dsc->endcomments) {
#line 3943
      if (dsc->begincomments < *pbegin) {
#line 3943
        *pbegin = dsc->begincomments;
      } else {
#line 3943
        *pbegin = *pbegin;
      }
#line 3944
      dsc->begincomments = 0UL;
#line 3945
      if (dsc->endcomments > *pend) {
#line 3945
        *pend = dsc->endcomments;
      } else {
#line 3945
        *pend = *pend;
      }
#line 3946
      dsc->endcomments = 0UL;
    }
#line 3949
    if (dsc->beginpreview != dsc->endpreview) {
#line 3950
      if (dsc->beginpreview < *pbegin) {
#line 3950
        *pbegin = dsc->beginpreview;
      } else {
#line 3950
        *pbegin = *pbegin;
      }
#line 3951
      dsc->beginpreview = 0UL;
#line 3952
      if (dsc->endpreview > *pend) {
#line 3952
        *pend = dsc->endpreview;
      } else {
#line 3952
        *pend = *pend;
      }
#line 3953
      dsc->endpreview = 0UL;
    }
#line 3956
    if (dsc->begindefaults != dsc->enddefaults) {
#line 3957
      if (dsc->begindefaults < *pbegin) {
#line 3957
        *pbegin = dsc->begindefaults;
      } else {
#line 3957
        *pbegin = *pbegin;
      }
#line 3958
      dsc->begindefaults = 0UL;
#line 3959
      if (dsc->enddefaults > *pend) {
#line 3959
        *pend = dsc->enddefaults;
      } else {
#line 3959
        *pend = *pend;
      }
#line 3960
      dsc->enddefaults = 0UL;
    }
#line 3963
    if (dsc->beginprolog != dsc->endprolog) {
#line 3964
      if (dsc->beginprolog < *pbegin) {
#line 3964
        *pbegin = dsc->beginprolog;
      } else {
#line 3964
        *pbegin = *pbegin;
      }
#line 3965
      dsc->beginprolog = 0UL;
#line 3966
      if (dsc->endprolog > *pend) {
#line 3966
        *pend = dsc->endprolog;
      } else {
#line 3966
        *pend = *pend;
      }
#line 3967
      dsc->endprolog = 0UL;
    }
#line 3970
    if (dsc->beginsetup != dsc->endsetup) {
#line 3971
      if (dsc->beginsetup < *pbegin) {
#line 3971
        *pbegin = dsc->beginsetup;
      } else {
#line 3971
        *pbegin = *pbegin;
      }
#line 3972
      dsc->beginsetup = 0UL;
#line 3973
      if (dsc->endsetup > *pend) {
#line 3973
        *pend = dsc->endsetup;
      } else {
#line 3973
        *pend = *pend;
      }
#line 3974
      dsc->endsetup = 0UL;
    }
#line 3977
    if (dsc->begintrailer != dsc->endtrailer) {
#line 3978
      if (dsc->begintrailer < *pbegin) {
#line 3978
        *pbegin = dsc->begintrailer;
      } else {
#line 3978
        *pbegin = *pbegin;
      }
#line 3979
      dsc->begintrailer = 0UL;
#line 3980
      if (dsc->endtrailer > *pend) {
#line 3980
        *pend = dsc->endtrailer;
      } else {
#line 3980
        *pend = *pend;
      }
#line 3981
      dsc->endtrailer = 0UL;
    }
#line 3984
    if (*pbegin == 999999999UL) {
#line 3985
      *pbegin = *pend;
    }
#line 3986
    end = 0UL;
    {
#line 3988
    while (1) {
      while_continue: /* CIL Label */ ;
#line 3988
      if (! pdcs) {
#line 3988
        goto while_break;
      }
#line 3989
      page_number = (int )dsc->page_count;
#line 3990
      if (pdcs->begin) {
#line 3990
        if ((unsigned long )pdcs->colourname != (unsigned long )((void *)0)) {
          {
#line 3992
          code = dsc_add_page(dsc, page_number + 1, pdcs->colourname);
          }
#line 3993
          if (code) {
#line 3994
            return (code);
          }
#line 3995
          (dsc->page + page_number)->begin = pdcs->begin;
#line 3996
          (dsc->page + page_number)->end = pdcs->end;
#line 3997
          if (end != 0UL) {
#line 3998
            if (end < pdcs->begin) {
#line 3998
              end = end;
            } else {
#line 3998
              end = pdcs->begin;
            }
          } else {
#line 4000
            end = pdcs->begin;
          }
        } else {
#line 3990
          goto _L___0;
        }
      } else
      _L___0: /* CIL Label */ 
#line 4004
      if ((unsigned long )pdcs->location != (unsigned long )((void *)0)) {
#line 4004
        if ((unsigned long )pdcs->filetype != (unsigned long )((void *)0)) {
#line 4004
          if ((unsigned long )pdcs->colourname != (unsigned long )((void *)0)) {
            {
#line 4004
            tmp___1 = dsc_stricmp((char const   *)pdcs->location, "Local");
            }
#line 4004
            if (tmp___1 == 0) {
              {
#line 4004
              tmp___2 = dsc_stricmp((char const   *)pdcs->filetype, "EPS");
              }
#line 4004
              if (tmp___2 == 0) {
#line 4004
                goto _L;
              } else {
                {
#line 4004
                tmp___3 = dsc_stricmp((char const   *)pdcs->filetype, "EPSF");
                }
#line 4004
                if (tmp___3 == 0) {
                  _L: /* CIL Label */ 
                  {
#line 4010
                  code = dsc_add_page(dsc, page_number + 1, pdcs->colourname);
                  }
#line 4011
                  if (code) {
#line 4012
                    return (code);
                  }
#line 4013
                  (dsc->page + page_number)->begin = 0UL;
#line 4014
                  (dsc->page + page_number)->end = 0UL;
                }
              }
            }
          }
        }
      }
#line 4017
      pdcs = pdcs->next;
    }
    while_break: /* CIL Label */ ;
    }
#line 4020
    if (end != 0UL) {
#line 4021
      *pend = end;
    }
#line 4031
    if (dsc->doseps_end) {
#line 4031
      if (*pend > dsc->doseps_end) {
#line 4032
        *pend = dsc->doseps_end;
      }
    }
  }
#line 4034
  return (0);
}
}
#line 4038 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/dscparse.c"
static int dsc_parse_platefile(CDSC *dsc ) 
{ 
  unsigned int i ;
  unsigned int n ;
  CDCS2 dcs2 ;
  CDCS2 *pdcs2 ;
  char colourname[256] ;
  char filetype[256] ;
  char location[256] ;
  char *filename ;
  int filename_length ;
  GSBOOL blank_line ;
  GSBOOL single ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int j ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  size_t tmp___5 ;
  size_t tmp___6 ;
  size_t tmp___7 ;
  size_t tmp___8 ;
  void *tmp___9 ;
  CDCS2 *this_dcs2 ;

  {
  {
#line 4047
  filename = (char *)((void *)0);
#line 4048
  filename_length = 0;
#line 4050
  single = 0;
#line 4051
  tmp___0 = strncmp((char const   *)dsc->line, "%%PlateFile:", sizeof("%%PlateFile:") - 1UL);
  }
#line 4051
  if (tmp___0 == 0) {
#line 4052
    n = 12U;
  } else {
    {
#line 4053
    tmp = strncmp((char const   *)dsc->line, "%%+", sizeof("%%+") - 1UL);
    }
#line 4053
    if (tmp == 0) {
#line 4054
      n = 3U;
    } else {
#line 4056
      return (-1);
    }
  }
  {
#line 4058
  memset((void *)(& dcs2), 0, sizeof(dcs2));
#line 4059
  memset((void *)(& colourname), 0, sizeof(colourname));
#line 4060
  memset((void *)(& filetype), 0, sizeof(filetype));
#line 4061
  memset((void *)(& location), 0, sizeof(location));
#line 4062
  memset((void *)(& filename), 0, sizeof(filename));
#line 4065
  blank_line = 1;
#line 4066
  i = n;
  }
  {
#line 4066
  while (1) {
    while_continue: /* CIL Label */ ;
#line 4066
    if (! (i < dsc->line_length)) {
#line 4066
      goto while_break;
    }
#line 4067
    if (! ((int )*(dsc->line + i) == 32)) {
#line 4067
      if (! ((int )*(dsc->line + i) == 9)) {
#line 4067
        if (! ((int )*(dsc->line + i) == 13)) {
#line 4067
          if (! ((int )*(dsc->line + i) == 10)) {
#line 4068
            blank_line = 0;
#line 4069
            goto while_break;
          }
        }
      }
    }
#line 4066
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 4073
  if (! blank_line) {
    {
#line 4074
    dsc_copy_string(colourname, (unsigned int )sizeof(colourname), dsc->line + n,
                    dsc->line_length - n, & i);
#line 4076
    n += i;
    }
#line 4077
    if (i) {
      {
#line 4078
      dsc_copy_string(filetype, (unsigned int )sizeof(filetype), dsc->line + n, dsc->line_length - n,
                      & i);
      }
    }
#line 4080
    n += i;
    {
#line 4081
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 4081
      if (! ((int )*(dsc->line + n) == 32)) {
#line 4081
        if (! ((int )*(dsc->line + n) == 9)) {
#line 4081
          if (! ((int )*(dsc->line + n) == 13)) {
#line 4081
            if (! ((int )*(dsc->line + n) == 10)) {
#line 4081
              goto while_break___0;
            }
          }
        }
      }
#line 4082
      n ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 4083
    if ((int )*(dsc->line + n) == 35) {
#line 4085
      single = 1;
#line 4086
      n ++;
#line 4087
      if (i) {
        {
#line 4088
        tmp___1 = dsc_get_int((char const   *)(dsc->line + n), dsc->line_length - n,
                              & i);
#line 4088
        dcs2.begin = (unsigned long )tmp___1;
        }
      }
#line 4089
      n += i;
#line 4090
      if (i) {
        {
#line 4091
        tmp___2 = dsc_get_int((char const   *)(dsc->line + n), dsc->line_length - n,
                              & i);
#line 4091
        dcs2.end = dcs2.begin + (unsigned long )tmp___2;
        }
      }
    } else {
#line 4096
      if (i) {
        {
#line 4097
        dsc_copy_string(location, (unsigned int )sizeof(location), dsc->line + n,
                        dsc->line_length - n, & i);
        }
      }
#line 4099
      n += i;
#line 4100
      if (i) {
#line 4101
        filename = dsc->line + n;
#line 4102
        filename_length = (int )(dsc->line_length - n);
#line 4103
        if ((int )*(filename + 0) == 40) {
#line 4106
          j = 0;
          {
#line 4106
          while (1) {
            while_continue___1: /* CIL Label */ ;
#line 4106
            if (! (j < filename_length)) {
#line 4106
              goto while_break___1;
            }
#line 4107
            if ((int )*(filename + j) == 41) {
#line 4108
              goto while_break___1;
            }
#line 4106
            j ++;
          }
          while_break___1: /* CIL Label */ ;
          }
#line 4109
          if (j < filename_length) {
#line 4110
            filename ++;
#line 4111
            filename_length = j - 1;
          }
        }
      }
    }
#line 4116
    if (i == 0U) {
      {
#line 4117
      dsc_unknown(dsc);
      }
    } else {
      {
#line 4120
      tmp___4 = strlen((char const   *)(colourname));
      }
#line 4120
      if (tmp___4) {
        {
#line 4121
        tmp___3 = strlen((char const   *)(colourname));
#line 4121
        dcs2.colourname = dsc_alloc_string(dsc, (char const   *)(colourname), (int )tmp___3);
        }
      }
      {
#line 4123
      tmp___6 = strlen((char const   *)(filetype));
      }
#line 4123
      if (tmp___6) {
        {
#line 4124
        tmp___5 = strlen((char const   *)(filetype));
#line 4124
        dcs2.filetype = dsc_alloc_string(dsc, (char const   *)(filetype), (int )tmp___5);
        }
      }
      {
#line 4126
      tmp___8 = strlen((char const   *)(location));
      }
#line 4126
      if (tmp___8) {
        {
#line 4127
        tmp___7 = strlen((char const   *)(location));
#line 4127
        dcs2.location = dsc_alloc_string(dsc, (char const   *)(location), (int )tmp___7);
        }
      }
#line 4129
      if (filename) {
        {
#line 4130
        dcs2.filename = dsc_add_line(dsc, (char const   *)filename, (unsigned int )filename_length);
        }
      }
#line 4133
      if (single) {
#line 4134
        if (dsc->file_length < dcs2.begin) {
#line 4134
          dsc->file_length = dsc->file_length;
        } else {
#line 4134
          dsc->file_length = dcs2.begin;
        }
      }
      {
#line 4136
      tmp___9 = dsc_memalloc(dsc, sizeof(CDCS2 ));
#line 4136
      pdcs2 = (CDCS2 *)tmp___9;
      }
#line 4137
      if ((unsigned long )pdcs2 == (unsigned long )((void *)0)) {
#line 4138
        return (-1);
      }
      {
#line 4139
      memcpy((void */* __restrict  */)pdcs2, (void const   */* __restrict  */)(& dcs2),
             sizeof(CDCS2 ));
      }
#line 4141
      if ((unsigned long )dsc->dcs2 == (unsigned long )((void *)0)) {
#line 4142
        dsc->dcs2 = pdcs2;
      } else {
#line 4144
        this_dcs2 = dsc->dcs2;
        {
#line 4145
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 4145
          if (! this_dcs2->next) {
#line 4145
            goto while_break___2;
          }
#line 4146
          this_dcs2 = this_dcs2->next;
        }
        while_break___2: /* CIL Label */ ;
        }
#line 4147
        this_dcs2->next = pdcs2;
      }
    }
  }
#line 4151
  return (0);
}
}
#line 4155 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/dscparse.c"
static int dsc_parse_dcs1plate(CDSC *dsc ) 
{ 
  unsigned int i ;
  unsigned int n ;
  CDCS2 dcs2 ;
  CDCS2 *pdcs2 ;
  char const   *colourname ;
  char *filename ;
  int filename_length ;
  GSBOOL blank_line ;
  GSBOOL continued ;
  char *line ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  size_t tmp___4 ;
  void *tmp___5 ;
  CDCS2 *this_dcs2 ;
  size_t tmp___6 ;

  {
  {
#line 4158
  n = 0U;
#line 4162
  filename = (char *)((void *)0);
#line 4163
  filename_length = 0;
#line 4165
  continued = 0;
#line 4166
  line = dsc->line;
#line 4168
  memset((void *)(& dcs2), 0, sizeof(dcs2));
#line 4169
  memset((void *)(& filename), 0, sizeof(filename));
#line 4171
  tmp = strncmp((char const   *)line, "%%+", sizeof("%%+") - 1UL);
  }
#line 4171
  if (tmp == 0) {
#line 4172
    n = 3U;
#line 4173
    line = dsc->last_line;
#line 4174
    continued = 1;
  }
  {
#line 4177
  tmp___3 = strncmp((char const   *)line, "%%CyanPlate:", sizeof("%%CyanPlate:") - 1UL);
  }
#line 4177
  if (tmp___3 == 0) {
#line 4178
    colourname = "Cyan";
#line 4179
    if (! continued) {
#line 4180
      n = 12U;
    }
  } else {
    {
#line 4182
    tmp___2 = strncmp((char const   *)line, "%%MagentaPlate:", sizeof("%%MagentaPlate:") - 1UL);
    }
#line 4182
    if (tmp___2 == 0) {
#line 4183
      colourname = "Magenta";
#line 4184
      if (! continued) {
#line 4185
        n = 15U;
      }
    } else {
      {
#line 4187
      tmp___1 = strncmp((char const   *)line, "%%YellowPlate:", sizeof("%%YellowPlate:") - 1UL);
      }
#line 4187
      if (tmp___1 == 0) {
#line 4188
        colourname = "Yellow";
#line 4189
        if (! continued) {
#line 4190
          n = 14U;
        }
      } else {
        {
#line 4192
        tmp___0 = strncmp((char const   *)line, "%%BlackPlate:", sizeof("%%BlackPlate:") - 1UL);
        }
#line 4192
        if (tmp___0 == 0) {
#line 4193
          colourname = "Black";
#line 4194
          if (! continued) {
#line 4195
            n = 13U;
          }
        } else {
#line 4198
          return (-1);
        }
      }
    }
  }
#line 4201
  blank_line = 1;
#line 4202
  i = n;
  {
#line 4202
  while (1) {
    while_continue: /* CIL Label */ ;
#line 4202
    if (! (i < dsc->line_length)) {
#line 4202
      goto while_break;
    }
#line 4203
    if (! ((int )*(dsc->line + i) == 32)) {
#line 4203
      if (! ((int )*(dsc->line + i) == 9)) {
#line 4203
        if (! ((int )*(dsc->line + i) == 13)) {
#line 4203
          if (! ((int )*(dsc->line + i) == 10)) {
#line 4204
            blank_line = 0;
#line 4205
            goto while_break;
          }
        }
      }
    }
#line 4202
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 4209
  if (! blank_line) {
#line 4210
    filename = dsc->line + n;
#line 4211
    filename_length = (int )(dsc->line_length - n);
#line 4212
    if (filename_length == 0) {
      {
#line 4213
      dsc_unknown(dsc);
      }
    } else {
      {
#line 4212
      tmp___6 = strlen((char const   *)filename);
      }
#line 4212
      if (tmp___6 == 0UL) {
        {
#line 4213
        dsc_unknown(dsc);
        }
      } else {
        {
#line 4216
        tmp___4 = strlen(colourname);
#line 4216
        dcs2.colourname = dsc_alloc_string(dsc, colourname, (int )tmp___4);
#line 4218
        dcs2.filetype = dsc_alloc_string(dsc, "EPS", 3);
#line 4219
        dcs2.location = dsc_alloc_string(dsc, "Local", 5);
#line 4220
        dcs2.filename = dsc_add_line(dsc, (char const   *)filename, (unsigned int )filename_length);
#line 4223
        tmp___5 = dsc_memalloc(dsc, sizeof(CDCS2 ));
#line 4223
        pdcs2 = (CDCS2 *)tmp___5;
        }
#line 4224
        if ((unsigned long )pdcs2 == (unsigned long )((void *)0)) {
#line 4225
          return (-1);
        }
        {
#line 4226
        memcpy((void */* __restrict  */)pdcs2, (void const   */* __restrict  */)(& dcs2),
               sizeof(CDCS2 ));
        }
#line 4228
        if ((unsigned long )dsc->dcs2 == (unsigned long )((void *)0)) {
#line 4229
          dsc->dcs2 = pdcs2;
        } else {
#line 4231
          this_dcs2 = dsc->dcs2;
          {
#line 4232
          while (1) {
            while_continue___0: /* CIL Label */ ;
#line 4232
            if (! this_dcs2->next) {
#line 4232
              goto while_break___0;
            }
#line 4233
            this_dcs2 = this_dcs2->next;
          }
          while_break___0: /* CIL Label */ ;
          }
#line 4234
          this_dcs2->next = pdcs2;
        }
#line 4237
        dsc->dcs1 = 1;
      }
    }
  }
#line 4240
  return (0);
}
}
#line 4250 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/dscparse.c"
char const   *dsc_find_platefile(CDSC *dsc , int page ) 
{ 
  CDCS2 *pdcs ;
  int i ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 4253
  pdcs = dsc->dcs2;
#line 4254
  i = 1;
  {
#line 4255
  while (1) {
    while_continue: /* CIL Label */ ;
#line 4255
    if (! pdcs) {
#line 4255
      goto while_break;
    }
#line 4256
    if (pdcs->begin != pdcs->end) {
#line 4257
      return ((char const   *)((void *)0));
    }
#line 4258
    if (pdcs->location) {
#line 4258
      if (pdcs->filetype) {
#line 4258
        if (pdcs->colourname) {
          {
#line 4258
          tmp = dsc_stricmp((char const   *)pdcs->location, "Local");
          }
#line 4258
          if (tmp == 0) {
            {
#line 4258
            tmp___0 = dsc_stricmp((char const   *)pdcs->filetype, "EPS");
            }
#line 4258
            if (tmp___0 == 0) {
#line 4258
              goto _L;
            } else {
              {
#line 4258
              tmp___1 = dsc_stricmp((char const   *)pdcs->filetype, "EPSF");
              }
#line 4258
              if (tmp___1 == 0) {
                _L: /* CIL Label */ 
#line 4262
                if (i == page) {
#line 4263
                  return ((char const   *)pdcs->filename);
                }
#line 4264
                i ++;
              }
            }
          }
        }
      }
    }
#line 4266
    pdcs = pdcs->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 4268
  return ((char const   *)((void *)0));
}
}
#line 4272 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/dscparse.c"
static CDSCCOLOUR *dsc_find_colour(CDSC *dsc , char const   *colourname ) 
{ 
  CDSCCOLOUR *colour ;
  int tmp ;

  {
#line 4275
  colour = dsc->colours;
  {
#line 4276
  while (1) {
    while_continue: /* CIL Label */ ;
#line 4276
    if (! colour) {
#line 4276
      goto while_break;
    }
#line 4277
    if (colour->name) {
      {
#line 4277
      tmp = dsc_stricmp((char const   *)colour->name, colourname);
      }
#line 4277
      if (tmp == 0) {
#line 4278
        return (colour);
      }
    }
#line 4279
    colour = colour->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 4281
  return ((CDSCCOLOUR *)0);
}
}
#line 4284 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/dscparse.c"
static int dsc_parse_process_colours(CDSC *dsc ) 
{ 
  unsigned int i ;
  unsigned int n ;
  CDSCCOLOUR *pcolour ;
  char colourname[256] ;
  GSBOOL blank_line ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  void *tmp___2 ;
  size_t tmp___3 ;
  CDSCCOLOUR *this_colour ;
  float tmp___4 ;
  float tmp___5 ;
  float tmp___6 ;
  float tmp___7 ;
  float tmp___8 ;
  float tmp___9 ;
  float tmp___10 ;
  float tmp___11 ;
  float tmp___12 ;
  float tmp___13 ;
  float tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  size_t tmp___22 ;

  {
  {
#line 4291
  tmp___0 = strncmp((char const   *)dsc->line, "%%DocumentProcessColors:", sizeof("%%DocumentProcessColors:") - 1UL);
  }
#line 4291
  if (tmp___0 == 0) {
#line 4292
    n = 24U;
  } else {
    {
#line 4293
    tmp = strncmp((char const   *)dsc->line, "%%+", sizeof("%%+") - 1UL);
    }
#line 4293
    if (tmp == 0) {
#line 4294
      n = 3U;
    } else {
#line 4296
      return (-1);
    }
  }
  {
#line 4298
  memset((void *)(& colourname), 0, sizeof(colourname));
#line 4301
  blank_line = 1;
#line 4302
  i = n;
  }
  {
#line 4302
  while (1) {
    while_continue: /* CIL Label */ ;
#line 4302
    if (! (i < dsc->line_length)) {
#line 4302
      goto while_break;
    }
#line 4303
    if (! ((int )*(dsc->line + i) == 32)) {
#line 4303
      if (! ((int )*(dsc->line + i) == 9)) {
#line 4303
        if (! ((int )*(dsc->line + i) == 13)) {
#line 4303
          if (! ((int )*(dsc->line + i) == 10)) {
#line 4304
            blank_line = 0;
#line 4305
            goto while_break;
          }
        }
      }
    }
#line 4302
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 4308
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 4308
    if (! ((int )*(dsc->line + n) == 32)) {
#line 4308
      if (! ((int )*(dsc->line + n) == 9)) {
#line 4308
        goto while_break___0;
      }
    }
#line 4309
    n ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 4310
  tmp___1 = strncmp((char const   *)(dsc->line + n), "(atend)", sizeof("(atend)") - 1UL);
  }
#line 4310
  if (tmp___1 == 0) {
#line 4311
    if (dsc->scan_section == 1) {
#line 4312
      blank_line = 1;
    } else {
      {
#line 4314
      dsc_unknown(dsc);
      }
#line 4315
      return (1);
    }
  }
#line 4319
  if (! blank_line) {
    {
#line 4320
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 4321
      dsc_copy_string(colourname, (unsigned int )sizeof(colourname), dsc->line + n,
                      dsc->line_length - n, & i);
#line 4323
      n += i;
      }
#line 4324
      if (i) {
        {
#line 4324
        tmp___22 = strlen((char const   *)(colourname));
        }
#line 4324
        if (tmp___22) {
          {
#line 4325
          pcolour = dsc_find_colour(dsc, (char const   *)(colourname));
          }
#line 4325
          if ((unsigned long )pcolour == (unsigned long )((void *)0)) {
            {
#line 4326
            tmp___2 = dsc_memalloc(dsc, sizeof(CDSCCOLOUR ));
#line 4326
            pcolour = (CDSCCOLOUR *)tmp___2;
            }
#line 4328
            if ((unsigned long )pcolour == (unsigned long )((void *)0)) {
#line 4329
              return (-1);
            }
            {
#line 4330
            memset((void *)pcolour, 0, sizeof(CDSCCOLOUR ));
#line 4331
            pcolour->custom = (CDSC_CUSTOM_COLOUR )0;
#line 4332
            tmp___3 = strlen((char const   *)(colourname));
#line 4332
            pcolour->name = dsc_alloc_string(dsc, (char const   *)(colourname), (int )tmp___3);
            }
#line 4334
            if ((unsigned long )dsc->colours == (unsigned long )((void *)0)) {
#line 4335
              dsc->colours = pcolour;
            } else {
#line 4337
              this_colour = dsc->colours;
              {
#line 4338
              while (1) {
                while_continue___2: /* CIL Label */ ;
#line 4338
                if (! this_colour->next) {
#line 4338
                  goto while_break___2;
                }
#line 4339
                this_colour = this_colour->next;
              }
              while_break___2: /* CIL Label */ ;
              }
#line 4340
              this_colour->next = pcolour;
            }
          }
          {
#line 4343
          pcolour->type = (CDSC_COLOUR_TYPE )1;
#line 4344
          tmp___21 = dsc_stricmp((char const   *)(colourname), "Cyan");
          }
#line 4344
          if (tmp___21 == 0) {
#line 4345
            pcolour->custom = (CDSC_CUSTOM_COLOUR )2;
#line 4346
            pcolour->cyan = (float )1.0;
#line 4347
            tmp___5 = (float )0.0;
#line 4347
            pcolour->black = tmp___5;
#line 4347
            tmp___4 = tmp___5;
#line 4347
            pcolour->yellow = tmp___4;
#line 4347
            pcolour->magenta = tmp___4;
          } else {
            {
#line 4349
            tmp___20 = dsc_stricmp((char const   *)(colourname), "Magenta");
            }
#line 4349
            if (tmp___20 == 0) {
#line 4350
              pcolour->custom = (CDSC_CUSTOM_COLOUR )2;
#line 4351
              pcolour->magenta = (float )1.0;
#line 4352
              tmp___7 = (float )0.0;
#line 4352
              pcolour->black = tmp___7;
#line 4352
              tmp___6 = tmp___7;
#line 4352
              pcolour->yellow = tmp___6;
#line 4352
              pcolour->cyan = tmp___6;
            } else {
              {
#line 4354
              tmp___19 = dsc_stricmp((char const   *)(colourname), "Yellow");
              }
#line 4354
              if (tmp___19 == 0) {
#line 4355
                pcolour->custom = (CDSC_CUSTOM_COLOUR )2;
#line 4356
                pcolour->yellow = (float )1.0;
#line 4357
                tmp___9 = (float )0.0;
#line 4357
                pcolour->black = tmp___9;
#line 4357
                tmp___8 = tmp___9;
#line 4357
                pcolour->magenta = tmp___8;
#line 4357
                pcolour->cyan = tmp___8;
              } else {
                {
#line 4359
                tmp___18 = dsc_stricmp((char const   *)(colourname), "Black");
                }
#line 4359
                if (tmp___18 == 0) {
#line 4360
                  pcolour->custom = (CDSC_CUSTOM_COLOUR )2;
#line 4361
                  pcolour->black = (float )1.0;
#line 4362
                  tmp___11 = (float )0.0;
#line 4362
                  pcolour->yellow = tmp___11;
#line 4362
                  tmp___10 = tmp___11;
#line 4362
                  pcolour->magenta = tmp___10;
#line 4362
                  pcolour->cyan = tmp___10;
                } else {
                  {
#line 4364
                  tmp___17 = dsc_stricmp((char const   *)(colourname), "Red");
                  }
#line 4364
                  if (tmp___17 == 0) {
#line 4365
                    pcolour->custom = (CDSC_CUSTOM_COLOUR )1;
#line 4366
                    pcolour->red = (float )1.0;
#line 4367
                    tmp___12 = (float )0.0;
#line 4367
                    pcolour->blue = tmp___12;
#line 4367
                    pcolour->green = tmp___12;
                  } else {
                    {
#line 4369
                    tmp___16 = dsc_stricmp((char const   *)(colourname), "Green");
                    }
#line 4369
                    if (tmp___16 == 0) {
#line 4370
                      pcolour->custom = (CDSC_CUSTOM_COLOUR )1;
#line 4371
                      pcolour->green = (float )1.0;
#line 4372
                      tmp___13 = (float )0.0;
#line 4372
                      pcolour->blue = tmp___13;
#line 4372
                      pcolour->red = tmp___13;
                    } else {
                      {
#line 4374
                      tmp___15 = dsc_stricmp((char const   *)(colourname), "Blue");
                      }
#line 4374
                      if (tmp___15 == 0) {
#line 4375
                        pcolour->custom = (CDSC_CUSTOM_COLOUR )1;
#line 4376
                        pcolour->blue = (float )1.0;
#line 4377
                        tmp___14 = (float )0.0;
#line 4377
                        pcolour->green = tmp___14;
#line 4377
                        pcolour->red = tmp___14;
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
#line 4320
      if (! (i != 0U)) {
#line 4320
        goto while_break___1;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
  }
#line 4382
  return (0);
}
}
#line 4385 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/dscparse.c"
static int dsc_parse_custom_colours(CDSC *dsc ) 
{ 
  unsigned int i ;
  unsigned int n ;
  CDSCCOLOUR *pcolour ;
  char colourname[256] ;
  GSBOOL blank_line ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  void *tmp___2 ;
  size_t tmp___3 ;
  CDSCCOLOUR *this_colour ;
  size_t tmp___4 ;

  {
  {
#line 4392
  tmp___0 = strncmp((char const   *)dsc->line, "%%DocumentCustomColors:", sizeof("%%DocumentCustomColors:") - 1UL);
  }
#line 4392
  if (tmp___0 == 0) {
#line 4393
    n = 23U;
  } else {
    {
#line 4394
    tmp = strncmp((char const   *)dsc->line, "%%+", sizeof("%%+") - 1UL);
    }
#line 4394
    if (tmp == 0) {
#line 4395
      n = 3U;
    } else {
#line 4397
      return (-1);
    }
  }
  {
#line 4399
  memset((void *)(& colourname), 0, sizeof(colourname));
#line 4402
  blank_line = 1;
#line 4403
  i = n;
  }
  {
#line 4403
  while (1) {
    while_continue: /* CIL Label */ ;
#line 4403
    if (! (i < dsc->line_length)) {
#line 4403
      goto while_break;
    }
#line 4404
    if (! ((int )*(dsc->line + i) == 32)) {
#line 4404
      if (! ((int )*(dsc->line + i) == 9)) {
#line 4404
        if (! ((int )*(dsc->line + i) == 13)) {
#line 4404
          if (! ((int )*(dsc->line + i) == 10)) {
#line 4405
            blank_line = 0;
#line 4406
            goto while_break;
          }
        }
      }
    }
#line 4403
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 4409
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 4409
    if (! ((int )*(dsc->line + n) == 32)) {
#line 4409
      if (! ((int )*(dsc->line + n) == 9)) {
#line 4409
        goto while_break___0;
      }
    }
#line 4410
    n ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 4411
  tmp___1 = strncmp((char const   *)(dsc->line + n), "(atend)", sizeof("(atend)") - 1UL);
  }
#line 4411
  if (tmp___1 == 0) {
#line 4412
    if (dsc->scan_section == 1) {
#line 4413
      blank_line = 1;
    } else {
      {
#line 4415
      dsc_unknown(dsc);
      }
#line 4416
      return (1);
    }
  }
#line 4420
  if (! blank_line) {
    {
#line 4421
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 4422
      dsc_copy_string(colourname, (unsigned int )sizeof(colourname), dsc->line + n,
                      dsc->line_length - n, & i);
#line 4424
      n += i;
      }
#line 4425
      if (i) {
        {
#line 4425
        tmp___4 = strlen((char const   *)(colourname));
        }
#line 4425
        if (tmp___4) {
          {
#line 4426
          pcolour = dsc_find_colour(dsc, (char const   *)(colourname));
          }
#line 4426
          if ((unsigned long )pcolour == (unsigned long )((void *)0)) {
            {
#line 4427
            tmp___2 = dsc_memalloc(dsc, sizeof(CDSCCOLOUR ));
#line 4427
            pcolour = (CDSCCOLOUR *)tmp___2;
            }
#line 4429
            if ((unsigned long )pcolour == (unsigned long )((void *)0)) {
#line 4430
              return (-1);
            }
            {
#line 4431
            memset((void *)pcolour, 0, sizeof(CDSCCOLOUR ));
#line 4432
            tmp___3 = strlen((char const   *)(colourname));
#line 4432
            pcolour->name = dsc_alloc_string(dsc, (char const   *)(colourname), (int )tmp___3);
#line 4434
            pcolour->custom = (CDSC_CUSTOM_COLOUR )0;
            }
#line 4435
            if ((unsigned long )dsc->colours == (unsigned long )((void *)0)) {
#line 4436
              dsc->colours = pcolour;
            } else {
#line 4438
              this_colour = dsc->colours;
              {
#line 4439
              while (1) {
                while_continue___2: /* CIL Label */ ;
#line 4439
                if (! this_colour->next) {
#line 4439
                  goto while_break___2;
                }
#line 4440
                this_colour = this_colour->next;
              }
              while_break___2: /* CIL Label */ ;
              }
#line 4441
              this_colour->next = pcolour;
            }
          }
#line 4444
          pcolour->type = (CDSC_COLOUR_TYPE )2;
        }
      }
#line 4421
      if (! (i != 0U)) {
#line 4421
        goto while_break___1;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
  }
#line 4448
  return (0);
}
}
#line 4452 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/dscparse.c"
static int dsc_parse_cmyk_custom_colour(CDSC *dsc ) 
{ 
  unsigned int i ;
  unsigned int n ;
  CDSCCOLOUR *pcolour ;
  char colourname[256] ;
  float cyan ;
  float magenta ;
  float yellow ;
  float black ;
  GSBOOL blank_line ;
  int tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  size_t tmp___2 ;
  CDSCCOLOUR *this_colour ;
  size_t tmp___3 ;

  {
  {
#line 4460
  tmp___0 = strncmp((char const   *)dsc->line, "%%CMYKCustomColor:", sizeof("%%CMYKCustomColor:") - 1UL);
  }
#line 4460
  if (tmp___0 == 0) {
#line 4461
    n = 18U;
  } else {
    {
#line 4462
    tmp = strncmp((char const   *)dsc->line, "%%+", sizeof("%%+") - 1UL);
    }
#line 4462
    if (tmp == 0) {
#line 4463
      n = 3U;
    } else {
#line 4465
      return (-1);
    }
  }
  {
#line 4467
  memset((void *)(& colourname), 0, sizeof(colourname));
  }
  {
#line 4471
  while (1) {
    while_continue: /* CIL Label */ ;
#line 4472
    blank_line = 1;
#line 4473
    i = n;
    {
#line 4473
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 4473
      if (! (i < dsc->line_length)) {
#line 4473
        goto while_break___0;
      }
#line 4474
      if (! ((int )*(dsc->line + i) == 32)) {
#line 4474
        if (! ((int )*(dsc->line + i) == 9)) {
#line 4474
          if (! ((int )*(dsc->line + i) == 13)) {
#line 4474
            if (! ((int )*(dsc->line + i) == 10)) {
#line 4475
              blank_line = 0;
#line 4476
              goto while_break___0;
            }
          }
        }
      }
#line 4473
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 4479
    if (blank_line) {
#line 4480
      goto while_break;
    } else {
      {
#line 4482
      black = (float )0.0;
#line 4482
      yellow = black;
#line 4482
      magenta = yellow;
#line 4482
      cyan = magenta;
#line 4483
      cyan = dsc_get_real((char const   *)(dsc->line + n), dsc->line_length - n, & i);
#line 4484
      n += i;
      }
#line 4485
      if (i) {
        {
#line 4486
        magenta = dsc_get_real((char const   *)(dsc->line + n), dsc->line_length - n,
                               & i);
        }
      }
#line 4487
      n += i;
#line 4488
      if (i) {
        {
#line 4489
        yellow = dsc_get_real((char const   *)(dsc->line + n), dsc->line_length - n,
                              & i);
        }
      }
#line 4490
      n += i;
#line 4491
      if (i) {
        {
#line 4492
        black = dsc_get_real((char const   *)(dsc->line + n), dsc->line_length - n,
                             & i);
        }
      }
#line 4493
      n += i;
#line 4494
      if (i) {
        {
#line 4495
        dsc_copy_string(colourname, (unsigned int )sizeof(colourname), dsc->line + n,
                        dsc->line_length - n, & i);
        }
      }
#line 4497
      n += i;
#line 4498
      if (i) {
        {
#line 4498
        tmp___3 = strlen((char const   *)(colourname));
        }
#line 4498
        if (tmp___3) {
          {
#line 4499
          pcolour = dsc_find_colour(dsc, (char const   *)(colourname));
          }
#line 4499
          if ((unsigned long )pcolour == (unsigned long )((void *)0)) {
            {
#line 4500
            tmp___1 = dsc_memalloc(dsc, sizeof(CDSCCOLOUR ));
#line 4500
            pcolour = (CDSCCOLOUR *)tmp___1;
            }
#line 4502
            if ((unsigned long )pcolour == (unsigned long )((void *)0)) {
#line 4503
              return (-1);
            }
            {
#line 4504
            memset((void *)pcolour, 0, sizeof(CDSCCOLOUR ));
#line 4505
            tmp___2 = strlen((char const   *)(colourname));
#line 4505
            pcolour->name = dsc_alloc_string(dsc, (char const   *)(colourname), (int )tmp___2);
#line 4507
            pcolour->type = (CDSC_COLOUR_TYPE )0;
            }
#line 4508
            if ((unsigned long )dsc->colours == (unsigned long )((void *)0)) {
#line 4509
              dsc->colours = pcolour;
            } else {
#line 4511
              this_colour = dsc->colours;
              {
#line 4512
              while (1) {
                while_continue___1: /* CIL Label */ ;
#line 4512
                if (! this_colour->next) {
#line 4512
                  goto while_break___1;
                }
#line 4513
                this_colour = this_colour->next;
              }
              while_break___1: /* CIL Label */ ;
              }
#line 4514
              this_colour->next = pcolour;
            }
          }
#line 4517
          pcolour->custom = (CDSC_CUSTOM_COLOUR )2;
#line 4518
          pcolour->cyan = cyan;
#line 4519
          pcolour->magenta = magenta;
#line 4520
          pcolour->yellow = yellow;
#line 4521
          pcolour->black = black;
        }
      }
    }
#line 4471
    if (! (i != 0U)) {
#line 4471
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 4525
  return (0);
}
}
#line 4528 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/dscparse.c"
static int dsc_parse_rgb_custom_colour(CDSC *dsc ) 
{ 
  unsigned int i ;
  unsigned int n ;
  CDSCCOLOUR *pcolour ;
  char colourname[256] ;
  float red ;
  float green ;
  float blue ;
  GSBOOL blank_line ;
  int tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  size_t tmp___2 ;
  CDSCCOLOUR *this_colour ;
  size_t tmp___3 ;

  {
  {
#line 4536
  tmp___0 = strncmp((char const   *)dsc->line, "%%RGBCustomColor:", sizeof("%%RGBCustomColor:") - 1UL);
  }
#line 4536
  if (tmp___0 == 0) {
#line 4537
    n = 17U;
  } else {
    {
#line 4538
    tmp = strncmp((char const   *)dsc->line, "%%+", sizeof("%%+") - 1UL);
    }
#line 4538
    if (tmp == 0) {
#line 4539
      n = 3U;
    } else {
#line 4541
      return (-1);
    }
  }
  {
#line 4543
  memset((void *)(& colourname), 0, sizeof(colourname));
  }
  {
#line 4547
  while (1) {
    while_continue: /* CIL Label */ ;
#line 4548
    blank_line = 1;
#line 4549
    i = n;
    {
#line 4549
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 4549
      if (! (i < dsc->line_length)) {
#line 4549
        goto while_break___0;
      }
#line 4550
      if (! ((int )*(dsc->line + i) == 32)) {
#line 4550
        if (! ((int )*(dsc->line + i) == 9)) {
#line 4550
          if (! ((int )*(dsc->line + i) == 13)) {
#line 4550
            if (! ((int )*(dsc->line + i) == 10)) {
#line 4551
              blank_line = 0;
#line 4552
              goto while_break___0;
            }
          }
        }
      }
#line 4549
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 4555
    if (blank_line) {
#line 4556
      goto while_break;
    } else {
      {
#line 4558
      blue = (float )0.0;
#line 4558
      green = blue;
#line 4558
      red = green;
#line 4559
      red = dsc_get_real((char const   *)(dsc->line + n), dsc->line_length - n, & i);
#line 4560
      n += i;
      }
#line 4561
      if (i) {
        {
#line 4562
        green = dsc_get_real((char const   *)(dsc->line + n), dsc->line_length - n,
                             & i);
        }
      }
#line 4563
      n += i;
#line 4564
      if (i) {
        {
#line 4565
        blue = dsc_get_real((char const   *)(dsc->line + n), dsc->line_length - n,
                            & i);
        }
      }
#line 4566
      n += i;
#line 4567
      if (i) {
        {
#line 4568
        dsc_copy_string(colourname, (unsigned int )sizeof(colourname), dsc->line + n,
                        dsc->line_length - n, & i);
        }
      }
#line 4570
      n += i;
#line 4571
      if (i) {
        {
#line 4571
        tmp___3 = strlen((char const   *)(colourname));
        }
#line 4571
        if (tmp___3) {
          {
#line 4572
          pcolour = dsc_find_colour(dsc, (char const   *)(colourname));
          }
#line 4572
          if ((unsigned long )pcolour == (unsigned long )((void *)0)) {
            {
#line 4573
            tmp___1 = dsc_memalloc(dsc, sizeof(CDSCCOLOUR ));
#line 4573
            pcolour = (CDSCCOLOUR *)tmp___1;
            }
#line 4575
            if ((unsigned long )pcolour == (unsigned long )((void *)0)) {
#line 4576
              return (-1);
            }
            {
#line 4577
            memset((void *)pcolour, 0, sizeof(CDSCCOLOUR ));
#line 4578
            tmp___2 = strlen((char const   *)(colourname));
#line 4578
            pcolour->name = dsc_alloc_string(dsc, (char const   *)(colourname), (int )tmp___2);
#line 4580
            pcolour->type = (CDSC_COLOUR_TYPE )0;
            }
#line 4581
            if ((unsigned long )dsc->colours == (unsigned long )((void *)0)) {
#line 4582
              dsc->colours = pcolour;
            } else {
#line 4584
              this_colour = dsc->colours;
              {
#line 4585
              while (1) {
                while_continue___1: /* CIL Label */ ;
#line 4585
                if (! this_colour->next) {
#line 4585
                  goto while_break___1;
                }
#line 4586
                this_colour = this_colour->next;
              }
              while_break___1: /* CIL Label */ ;
              }
#line 4587
              this_colour->next = pcolour;
            }
          }
#line 4590
          pcolour->custom = (CDSC_CUSTOM_COLOUR )1;
#line 4591
          pcolour->red = red;
#line 4592
          pcolour->green = green;
#line 4593
          pcolour->blue = blue;
        }
      }
    }
#line 4547
    if (! (i != 0U)) {
#line 4547
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 4597
  return (0);
}
}
#line 170 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 689
extern int fputs(char const   * __restrict  __s , FILE * __restrict  __stream ) ;
#line 543 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 353 "/usr/include/unistd.h"
extern int close(int __fd ) ;
#line 534
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) dup2)(int __fd ,
                                                                           int __fd2 ) ;
#line 578
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) execvp)(char const   *__file ,
                                                                                               char * const  *__argv ) ;
#line 756
extern  __attribute__((__nothrow__)) __pid_t fork(void) ;
#line 21 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/capp.h"
int app_platform_init(GSview *a ) ;
#line 22
int app_platform_finish(GSview *a ) ;
#line 25
GSview *app_new(void *handle , BOOL multithread ) ;
#line 28
int app_unref(GSview *a ) ;
#line 35
int app_lock(GSview *a ) ;
#line 36
int app_unlock(GSview *a ) ;
#line 74
void app_log(char const   *str , int len ) ;
#line 84
int load_string(GSview *a , int id , char *buf , int len ) ;
#line 86
int get_dsc_response(GSview *app , char const   *str ) ;
#line 88
FILE *app_temp_file(GSview *app , char *fname , int len ) ;
#line 89
int app_msg_box(GSview *a , char const   *str , int icon ) ;
#line 48 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/cdoc.h"
Doc *doc_new(GSview *a ) ;
#line 49
int doc_add(Doc *d , GSview *a ) ;
#line 50
int doc_remove(Doc *d ) ;
#line 52
int doc_unref(Doc *d ) ;
#line 55
int doc_open(Doc *doc , char const   *filename ) ;
#line 56
int doc_close(Doc *doc ) ;
#line 60
void doc_dsc_warn(Doc *doc , int level ) ;
#line 61
void doc_verbose(Doc *doc , BOOL verbose ) ;
#line 71
void doc_savestat(Doc *doc ) ;
#line 94 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/cgssrv.h"
int gssrv_request(GSSRV *s , GSREQ *reqnew ) ;
#line 88 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/cmac.h"
int dump_macfile(char const   *filename , int verbose ) ;
#line 26 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/cpagec.h"
int pagecache_unref_all(GSview *a ) ;
#line 146 "/usr/include/fcntl.h"
extern int ( __attribute__((__nonnull__(1))) open)(char const   *__file , int __oflag 
                                                   , ...) ;
#line 102 "/usr/include/x86_64-linux-gnu/sys/wait.h"
extern __pid_t wait(union wait *__stat_loc ) ;
#line 50 "/usr/include/x86_64-linux-gnu/bits/errno.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
#line 46 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/epstool.c"
char const   *epstool_name  =    "epstool";
#line 47 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/epstool.c"
char const   *epstool_version  =    "3.08";
#line 48 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/epstool.c"
char const   *epstool_date  =    "2005-06-06";
#line 49 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/epstool.c"
char const   *copyright  =    "Copyright 1995-2005 Ghostgum Software Pty Ltd";
#line 51 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/epstool.c"
char const   *cmd_help  =    "Commands (one only):\n  --add-tiff4-preview        or  -t4\n  --add-tiff6u-preview       or  -t6u\n  --add-tiff6p-preview       or  -t6p\n  --add-tiff-preview         or  -tg\n  --add-interchange-preview  or  -i\n  --add-metafile-preview     or  -w\n  --add-pict-preview\n  --add-user-preview filename\n  --dcs2-multi\n  --dcs2-single\n  --dcs2-report\n  --extract-postscript       or  -p\n  --extract-preview          or  -v\n  --bitmap\n  --copy\n  --dump\n  --help                     or  -h\n  --test-eps\n  --version\n";
#line 74 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/epstool.c"
char const   *opt_help  =    "Options:\n  --bbox                     or  -b\n  --combine-separations filename\n  --combine-tolerance pts\n  --custom-colours filename\n  --debug                    or  -d\n  --device name\n  --doseps-reverse\n  --dpi resolution\n  --dpi-render resolution\n  --ignore-information\n  --ignore-warnings\n  --ignore-errors\n  --gs command\n  --gs-args arguments\n  --mac-binary\n  --mac-double\n  --mac-rsrc\n  --mac-single\n  --missing-separations\n  --output filename\n  --page-number\n  --quiet\n  --rename-separation old_name new_name\n  --replace-composite\n";
#line 179 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/epstool.c"
char const   gsexe[3]  = {      (char const   )'g',      (char const   )'s',      (char const   )'\000'};
#line 200
static void print_help(void) ;
#line 201
static void print_version(void) ;
#line 202
static int parse_args(OPT *opt , int argc , char **argv ) ;
#line 203
static Doc *epstool_open_document(GSview *app , OPT *opt , char *name ) ;
#line 204
static int epstool_add_preview(Doc *doc , OPT *opt ) ;
#line 205
static int epstool_dcs2_copy(Doc *doc , Doc *doc2 , OPT *opt ) ;
#line 206
static int epstool_dcs2_report(Doc *doc ) ;
#line 207
static int epstool_dcs2_composite(Doc *doc , OPT *opt , GFile *compfile ) ;
#line 208
static int epstool_dcs2_check_files(Doc *doc , OPT *opt ) ;
#line 209
static int epstool_extract(Doc *doc , OPT *opt ) ;
#line 210
static int epstool_bitmap(Doc *doc , OPT *opt ) ;
#line 211
static int epstool_copy(Doc *doc , OPT *opt ) ;
#line 212
static int epstool_copy_bitmap(Doc *doc , OPT *opt ) ;
#line 213
static int epstool_test(Doc *doc , OPT *opt ) ;
#line 214
static void epstool_dump_fn(void *caller_data , char const   *str ) ;
#line 216
static IMAGE *make_preview_image(Doc *doc , OPT *opt , int page , char const   *device ,
                                 CDSCBBOX *bbox , CDSCFBBOX *hires_bbox , int calc_bbox ) ;
#line 218
static int make_preview_file(Doc *doc , OPT *opt , int page , char const   *preview ,
                             char const   *device , float dpi , CDSCBBOX *bbox , CDSCFBBOX *hires_bbox ,
                             int calc_bbox ) ;
#line 221
static int calculate_bbox(Doc *doc , OPT *opt , char const   *psname , CDSCBBOX *bbox ,
                          CDSCFBBOX *hires_bbox ) ;
#line 223
static int calc_device_size(float dpi , CDSCBBOX *bbox , CDSCFBBOX *hires_bbox , int *width ,
                            int *height , float *xoffset , float *yoffset ) ;
#line 225
static int exec_program(char *command , int hstdin , int hstdout , int hstderr , char const   *stdin_name ,
                        char const   *stdout_name , char const   *stderr_name ) ;
#line 228
static int custom_colours_read(OPT *opt ) ;
#line 229
static CUSTOM_COLOUR *custom_colours_find(OPT *opt , char const   *name ) ;
#line 230
static void custom_colours_free(OPT *opt ) ;
#line 231
static int colour_to_cmyk(CDSC *dsc , char const   *name , float *cyan , float *magenta ,
                          float *yellow , float *black ) ;
#line 235 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/epstool.c"
static void print_version(void) 
{ 


  {
  {
#line 238
  fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"%s %s %s\n",
          epstool_name, epstool_version, epstool_date);
  }
#line 239
  return;
}
}
#line 241 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/epstool.c"
static void print_help(void) 
{ 


  {
  {
#line 244
  print_version();
#line 245
  fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"%s\n",
          copyright);
#line 246
  fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"Usage: epstool command [options] inputfile outputfile\n");
#line 247
  fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"%s",
          cmd_help);
#line 248
  fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"%s",
          opt_help);
  }
#line 249
  return;
}
}
#line 254 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/epstool.c"
static int parse_args(OPT *opt , int argc , char **argv ) 
{ 
  int arg ;
  char const   *p ;
  char buf[256] ;
  size_t tmp ;
  RENAME_SEPARATION *rs ;
  void *tmp___0 ;
  void *tmp___1 ;
  char oldname[256] ;
  char newname[256] ;
  char *p___0 ;
  char *q ;
  int len ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  void *tmp___4 ;
  size_t tmp___5 ;
  size_t tmp___6 ;
  void *tmp___7 ;
  char buf___0[256] ;
  size_t tmp___8 ;
  int tmp___9 ;
  char buf___1[256] ;
  size_t tmp___10 ;
  double tmp___11 ;
  char buf___2[256] ;
  size_t tmp___12 ;
  double tmp___13 ;
  char buf___3[256] ;
  size_t tmp___14 ;
  char buf___4[256] ;
  size_t tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  int tmp___27 ;
  int tmp___28 ;
  int tmp___29 ;
  int tmp___30 ;
  int tmp___31 ;
  int tmp___32 ;
  int tmp___33 ;
  int tmp___34 ;
  int tmp___35 ;
  int tmp___36 ;
  int tmp___37 ;
  int tmp___38 ;
  int tmp___39 ;
  int tmp___40 ;
  int tmp___41 ;
  int tmp___42 ;
  int tmp___43 ;
  int tmp___44 ;
  int tmp___45 ;
  int tmp___46 ;
  int tmp___47 ;
  int tmp___48 ;
  int tmp___49 ;
  int tmp___50 ;
  int tmp___51 ;
  int tmp___52 ;
  int tmp___53 ;
  int tmp___54 ;
  int tmp___55 ;
  int tmp___56 ;
  int tmp___57 ;
  int tmp___58 ;
  int tmp___59 ;
  int tmp___60 ;
  int tmp___61 ;
  int tmp___62 ;
  int tmp___63 ;
  int tmp___64 ;
  int tmp___65 ;
  int tmp___66 ;
  int tmp___67 ;
  int tmp___68 ;
  int tmp___69 ;
  int tmp___70 ;
  int tmp___71 ;
  int tmp___72 ;
  int tmp___73 ;

  {
  {
#line 259
  memset((void *)opt, 0, sizeof(OPT ));
#line 260
  opt->cmd = (CMD )0;
#line 261
  opt->dpi = (float )72.0;
#line 262
  opt->dpi_render = (float )0.0;
#line 263
  opt->mac_type = (CMAC_TYPE )0;
#line 264
  opt->dscwarn = -1;
#line 265
  opt->image_encode = 1;
#line 266
  opt->image_compress = 2;
#line 267
  strncpy((char */* __restrict  */)(opt->gs), (char const   */* __restrict  */)(gsexe),
          sizeof(opt->gs) / sizeof(char ) - 1UL);
#line 268
  arg = 1;
  }
  {
#line 268
  while (1) {
    while_continue: /* CIL Label */ ;
#line 268
    if (! (arg < argc)) {
#line 268
      goto while_break;
    }
    {
#line 269
    p = (char const   *)*(argv + arg);
#line 270
    tmp___72 = strcmp(p, "--add-tiff4-preview");
    }
#line 270
    if (tmp___72 == 0) {
#line 270
      goto _L___8;
    } else {
      {
#line 270
      tmp___73 = strcmp(p, "-t4");
      }
#line 270
      if (tmp___73 == 0) {
        _L___8: /* CIL Label */ 
#line 272
        if ((unsigned int )opt->cmd != 0U) {
#line 273
          return (arg);
        }
#line 274
        opt->cmd = (CMD )1;
      } else {
        {
#line 276
        tmp___70 = strcmp(p, "--add-tiff6u-preview");
        }
#line 276
        if (tmp___70 == 0) {
#line 276
          goto _L___7;
        } else {
          {
#line 276
          tmp___71 = strcmp(p, "-t6u");
          }
#line 276
          if (tmp___71 == 0) {
            _L___7: /* CIL Label */ 
#line 278
            if ((unsigned int )opt->cmd != 0U) {
#line 279
              return (arg);
            }
#line 280
            opt->cmd = (CMD )2;
          } else {
            {
#line 282
            tmp___68 = strcmp(p, "--add-tiff6p-preview");
            }
#line 282
            if (tmp___68 == 0) {
#line 282
              goto _L___6;
            } else {
              {
#line 282
              tmp___69 = strcmp(p, "-t6p");
              }
#line 282
              if (tmp___69 == 0) {
                _L___6: /* CIL Label */ 
#line 284
                if ((unsigned int )opt->cmd != 0U) {
#line 285
                  return (arg);
                }
#line 286
                opt->cmd = (CMD )3;
              } else {
                {
#line 288
                tmp___66 = strcmp(p, "--add-tiff-preview");
                }
#line 288
                if (tmp___66 == 0) {
#line 288
                  goto _L___5;
                } else {
                  {
#line 288
                  tmp___67 = strcmp(p, "-tg");
                  }
#line 288
                  if (tmp___67 == 0) {
                    _L___5: /* CIL Label */ 
#line 290
                    if ((unsigned int )opt->cmd != 0U) {
#line 291
                      return (arg);
                    }
#line 292
                    opt->cmd = (CMD )4;
                  } else {
                    {
#line 294
                    tmp___64 = strcmp(p, "--add-interchange-preview");
                    }
#line 294
                    if (tmp___64 == 0) {
#line 294
                      goto _L___4;
                    } else {
                      {
#line 294
                      tmp___65 = strcmp(p, "-i");
                      }
#line 294
                      if (tmp___65 == 0) {
                        _L___4: /* CIL Label */ 
#line 296
                        if ((unsigned int )opt->cmd != 0U) {
#line 297
                          return (arg);
                        }
#line 298
                        opt->cmd = (CMD )5;
                      } else {
                        {
#line 300
                        tmp___62 = strcmp(p, "--add-metafile-preview");
                        }
#line 300
                        if (tmp___62 == 0) {
#line 300
                          goto _L___3;
                        } else {
                          {
#line 300
                          tmp___63 = strcmp(p, "-w");
                          }
#line 300
                          if (tmp___63 == 0) {
                            _L___3: /* CIL Label */ 
#line 302
                            if ((unsigned int )opt->cmd != 0U) {
#line 303
                              return (arg);
                            }
#line 304
                            opt->cmd = (CMD )6;
                          } else {
                            {
#line 306
                            tmp___60 = strcmp(p, "--add-pict-preview");
                            }
#line 306
                            if (tmp___60 == 0) {
#line 306
                              goto _L___2;
                            } else {
                              {
#line 306
                              tmp___61 = strcmp(p, "-w");
                              }
#line 306
                              if (tmp___61 == 0) {
                                _L___2: /* CIL Label */ 
#line 308
                                if ((unsigned int )opt->cmd != 0U) {
#line 309
                                  return (arg);
                                }
#line 310
                                opt->cmd = (CMD )7;
                              } else {
                                {
#line 312
                                tmp___59 = strcmp(p, "--add-user-preview");
                                }
#line 312
                                if (tmp___59 == 0) {
#line 313
                                  if ((unsigned int )opt->cmd != 0U) {
#line 314
                                    return (arg);
                                  }
#line 315
                                  opt->cmd = (CMD )8;
#line 316
                                  arg ++;
#line 317
                                  if (arg == argc) {
#line 318
                                    return (arg);
                                  }
                                  {
#line 319
                                  strncpy((char */* __restrict  */)(opt->user_preview),
                                          (char const   */* __restrict  */)*(argv + arg),
                                          sizeof(opt->user_preview) / sizeof(char ) - 1UL);
                                  }
                                } else {
                                  {
#line 322
                                  tmp___58 = strcmp(p, "--dcs2-multi");
                                  }
#line 322
                                  if (tmp___58 == 0) {
#line 323
                                    if ((unsigned int )opt->cmd != 0U) {
#line 324
                                      return (arg);
                                    }
#line 325
                                    opt->cmd = (CMD )9;
                                  } else {
                                    {
#line 327
                                    tmp___57 = strcmp(p, "--dcs2-single");
                                    }
#line 327
                                    if (tmp___57 == 0) {
#line 328
                                      if ((unsigned int )opt->cmd != 0U) {
#line 329
                                        return (arg);
                                      }
#line 330
                                      opt->cmd = (CMD )10;
                                    } else {
                                      {
#line 332
                                      tmp___56 = strcmp(p, "--dcs2-report");
                                      }
#line 332
                                      if (tmp___56 == 0) {
#line 333
                                        if ((unsigned int )opt->cmd != 0U) {
#line 334
                                          return (arg);
                                        }
#line 335
                                        opt->cmd = (CMD )11;
                                      } else {
                                        {
#line 337
                                        tmp___55 = strcmp(p, "--dump");
                                        }
#line 337
                                        if (tmp___55 == 0) {
#line 338
                                          if ((unsigned int )opt->cmd != 0U) {
#line 339
                                            return (arg);
                                          }
#line 340
                                          opt->cmd = (CMD )16;
                                        } else {
                                          {
#line 342
                                          tmp___54 = strcmp(p, "--test-eps");
                                          }
#line 342
                                          if (tmp___54 == 0) {
#line 343
                                            if ((unsigned int )opt->cmd != 0U) {
#line 344
                                              return (arg);
                                            }
#line 345
                                            opt->cmd = (CMD )18;
                                          } else {
                                            {
#line 347
                                            tmp___53 = strcmp(p, "--replace-composite");
                                            }
#line 347
                                            if (tmp___53 == 0) {
#line 348
                                              opt->composite = 1;
                                            } else {
                                              {
#line 350
                                              tmp___52 = strcmp(p, "--missing-separations");
                                              }
#line 350
                                              if (tmp___52 == 0) {
#line 351
                                                opt->missing_separations = 1;
                                              } else {
                                                {
#line 353
                                                tmp___51 = strcmp(p, "--combine-separations");
                                                }
#line 353
                                                if (tmp___51 == 0) {
#line 354
                                                  arg ++;
#line 355
                                                  if (arg == argc) {
#line 356
                                                    return (arg);
                                                  }
                                                  {
#line 357
                                                  strncpy((char */* __restrict  */)(opt->combine),
                                                          (char const   */* __restrict  */)*(argv + arg),
                                                          sizeof(opt->combine) / sizeof(char ) - 1UL);
                                                  }
                                                } else {
                                                  {
#line 359
                                                  tmp___50 = strcmp(p, "--combine-tolerance");
                                                  }
#line 359
                                                  if (tmp___50 == 0) {
#line 361
                                                    arg ++;
#line 362
                                                    if (arg == argc) {
#line 363
                                                      return (arg);
                                                    }
                                                    {
#line 364
                                                    tmp = strlen((char const   *)*(argv + arg));
#line 364
                                                    cs_to_narrow(buf, (int )sizeof(buf) - 1,
                                                                 (char const   *)*(argv + arg),
                                                                 (int )tmp + 1);
#line 365
                                                    opt->tolerance = atoi((char const   *)(buf));
                                                    }
                                                  } else {
                                                    {
#line 367
                                                    tmp___49 = strcmp(p, "--rename-separation");
                                                    }
#line 367
                                                    if (tmp___49 == 0) {
#line 368
                                                      rs = opt->rename_sep;
#line 369
                                                      arg ++;
#line 370
                                                      if (arg + 1 == argc) {
#line 371
                                                        return (arg);
                                                      }
#line 372
                                                      if (rs) {
                                                        {
#line 373
                                                        while (1) {
                                                          while_continue___0: /* CIL Label */ ;
#line 373
                                                          if (rs) {
#line 373
                                                            if (! ((unsigned long )rs->next != (unsigned long )((void *)0))) {
#line 373
                                                              goto while_break___0;
                                                            }
                                                          } else {
#line 373
                                                            goto while_break___0;
                                                          }
#line 374
                                                          rs = rs->next;
                                                        }
                                                        while_break___0: /* CIL Label */ ;
                                                        }
                                                        {
#line 375
                                                        tmp___0 = malloc(sizeof(RENAME_SEPARATION ));
#line 375
                                                        rs->next = (RENAME_SEPARATION *)tmp___0;
#line 377
                                                        rs = rs->next;
                                                        }
                                                      } else {
                                                        {
#line 380
                                                        tmp___1 = malloc(sizeof(RENAME_SEPARATION ));
#line 380
                                                        rs = (RENAME_SEPARATION *)tmp___1;
#line 380
                                                        opt->rename_sep = rs;
                                                        }
                                                      }
#line 383
                                                      if (rs) {
                                                        {
#line 389
                                                        memset((void *)rs, 0, sizeof(RENAME_SEPARATION ));
#line 390
                                                        rs->next = (RENAME_SEPARATION *)((void *)0);
#line 391
                                                        memset((void *)(oldname),
                                                               0, sizeof(oldname));
#line 392
                                                        tmp___2 = strlen((char const   *)*(argv + arg));
#line 392
                                                        cs_to_narrow(oldname, (int )sizeof(oldname) - 1,
                                                                     (char const   *)*(argv + arg),
                                                                     (int )tmp___2 + 1);
#line 394
                                                        tmp___3 = strlen((char const   *)(oldname));
#line 394
                                                        len = (int )tmp___3 + 1;
#line 395
                                                        tmp___4 = malloc((size_t )len);
#line 395
                                                        p___0 = (char *)tmp___4;
                                                        }
#line 396
                                                        if (p___0) {
                                                          {
#line 397
                                                          memcpy((void */* __restrict  */)p___0,
                                                                 (void const   */* __restrict  */)(oldname),
                                                                 (size_t )len);
#line 398
                                                          rs->oldname = p___0;
                                                          }
                                                        }
                                                        {
#line 400
                                                        arg ++;
#line 401
                                                        memset((void *)(newname),
                                                               0, sizeof(newname));
#line 402
                                                        tmp___5 = strlen((char const   *)*(argv + arg));
#line 402
                                                        cs_to_narrow(newname, (int )sizeof(newname) - 1,
                                                                     (char const   *)*(argv + arg),
                                                                     (int )tmp___5 + 1);
#line 404
                                                        tmp___6 = strlen((char const   *)(newname));
#line 404
                                                        len = (int )tmp___6 + 1;
#line 405
                                                        tmp___7 = malloc((size_t )len);
#line 405
                                                        q = (char *)tmp___7;
                                                        }
#line 406
                                                        if (q) {
                                                          {
#line 407
                                                          memcpy((void */* __restrict  */)q,
                                                                 (void const   */* __restrict  */)(newname),
                                                                 (size_t )len);
#line 408
                                                          rs->newname = q;
                                                          }
                                                        }
#line 410
                                                        if ((unsigned long )p___0 == (unsigned long )((void *)0)) {
                                                          {
#line 411
                                                          fprintf((FILE */* __restrict  */)stderr,
                                                                  (char const   */* __restrict  */)"Out of memory\n");
                                                          }
#line 412
                                                          return (arg);
                                                        } else
#line 410
                                                        if ((unsigned long )q == (unsigned long )((void *)0)) {
                                                          {
#line 411
                                                          fprintf((FILE */* __restrict  */)stderr,
                                                                  (char const   */* __restrict  */)"Out of memory\n");
                                                          }
#line 412
                                                          return (arg);
                                                        }
                                                      } else {
                                                        {
#line 416
                                                        fprintf((FILE */* __restrict  */)stderr,
                                                                (char const   */* __restrict  */)"Out of memory\n");
                                                        }
#line 417
                                                        return (arg);
                                                      }
                                                    } else {
                                                      {
#line 420
                                                      tmp___48 = strcmp(p, "--custom-colours");
                                                      }
#line 420
                                                      if (tmp___48 == 0) {
#line 421
                                                        arg ++;
#line 422
                                                        if (arg == argc) {
#line 423
                                                          return (arg);
                                                        }
                                                        {
#line 424
                                                        strncpy((char */* __restrict  */)(opt->custom_colours),
                                                                (char const   */* __restrict  */)*(argv + arg),
                                                                sizeof(opt->custom_colours) / sizeof(char ) - 1UL);
                                                        }
                                                      } else {
                                                        {
#line 427
                                                        tmp___46 = strcmp(p, "--extract-preview");
                                                        }
#line 427
                                                        if (tmp___46 == 0) {
#line 427
                                                          goto _L___1;
                                                        } else {
                                                          {
#line 427
                                                          tmp___47 = strcmp(p, "-v");
                                                          }
#line 427
                                                          if (tmp___47 == 0) {
                                                            _L___1: /* CIL Label */ 
#line 429
                                                            if ((unsigned int )opt->cmd != 0U) {
#line 430
                                                              return (arg);
                                                            }
#line 431
                                                            opt->cmd = (CMD )12;
                                                          } else {
                                                            {
#line 433
                                                            tmp___44 = strcmp(p, "--extract-postscript");
                                                            }
#line 433
                                                            if (tmp___44 == 0) {
#line 433
                                                              goto _L___0;
                                                            } else {
                                                              {
#line 433
                                                              tmp___45 = strcmp(p,
                                                                                "-p");
                                                              }
#line 433
                                                              if (tmp___45 == 0) {
                                                                _L___0: /* CIL Label */ 
#line 435
                                                                if ((unsigned int )opt->cmd != 0U) {
#line 436
                                                                  return (arg);
                                                                }
#line 437
                                                                opt->cmd = (CMD )13;
                                                              } else {
                                                                {
#line 439
                                                                tmp___43 = strcmp(p,
                                                                                  "--bitmap");
                                                                }
#line 439
                                                                if (tmp___43 == 0) {
#line 440
                                                                  if ((unsigned int )opt->cmd != 0U) {
#line 441
                                                                    return (arg);
                                                                  }
#line 442
                                                                  opt->cmd = (CMD )14;
                                                                } else {
                                                                  {
#line 444
                                                                  tmp___42 = strcmp(p,
                                                                                    "--copy");
                                                                  }
#line 444
                                                                  if (tmp___42 == 0) {
#line 445
                                                                    if ((unsigned int )opt->cmd != 0U) {
#line 446
                                                                      return (arg);
                                                                    }
#line 447
                                                                    opt->cmd = (CMD )15;
                                                                  } else {
                                                                    {
#line 449
                                                                    tmp___41 = strcmp(p,
                                                                                      "--device");
                                                                    }
#line 449
                                                                    if (tmp___41 == 0) {
#line 450
                                                                      arg ++;
#line 451
                                                                      if (arg == argc) {
#line 452
                                                                        return (arg);
                                                                      }
                                                                      {
#line 453
                                                                      strncpy((char */* __restrict  */)(opt->device),
                                                                              (char const   */* __restrict  */)*(argv + arg),
                                                                              sizeof(opt->device) / sizeof(char ) - 1UL);
                                                                      }
                                                                    } else {
                                                                      {
#line 455
                                                                      tmp___40 = strcmp(p,
                                                                                        "--page-number");
                                                                      }
#line 455
                                                                      if (tmp___40 == 0) {
#line 457
                                                                        arg ++;
#line 458
                                                                        if (arg == argc) {
#line 459
                                                                          return (arg);
                                                                        }
                                                                        {
#line 460
                                                                        tmp___8 = strlen((char const   *)*(argv + arg));
#line 460
                                                                        cs_to_narrow(buf___0,
                                                                                     (int )sizeof(buf___0) - 1,
                                                                                     (char const   *)*(argv + arg),
                                                                                     (int )tmp___8 + 1);
#line 462
                                                                        tmp___9 = atoi((char const   *)(buf___0));
#line 462
                                                                        opt->page = tmp___9 - 1;
                                                                        }
#line 463
                                                                        if (opt->page < 0) {
#line 464
                                                                          opt->page = 0;
                                                                        }
                                                                      } else {
                                                                        {
#line 466
                                                                        tmp___38 = strcmp(p,
                                                                                          "--bbox");
                                                                        }
#line 466
                                                                        if (tmp___38 == 0) {
#line 468
                                                                          opt->bbox = 1;
                                                                        } else {
                                                                          {
#line 466
                                                                          tmp___39 = strcmp(p,
                                                                                            "-b");
                                                                          }
#line 466
                                                                          if (tmp___39 == 0) {
#line 468
                                                                            opt->bbox = 1;
                                                                          } else {
                                                                            {
#line 470
                                                                            tmp___37 = strcmp(p,
                                                                                              "--ignore-information");
                                                                            }
#line 470
                                                                            if (tmp___37 == 0) {
#line 471
                                                                              opt->dscwarn = 0;
                                                                            } else {
                                                                              {
#line 473
                                                                              tmp___36 = strcmp(p,
                                                                                                "--ignore-warnings");
                                                                              }
#line 473
                                                                              if (tmp___36 == 0) {
#line 474
                                                                                opt->dscwarn = 1;
                                                                              } else {
                                                                                {
#line 476
                                                                                tmp___35 = strcmp(p,
                                                                                                  "--ignore-errors");
                                                                                }
#line 476
                                                                                if (tmp___35 == 0) {
#line 477
                                                                                  opt->dscwarn = 2;
                                                                                } else {
                                                                                  {
#line 479
                                                                                  tmp___34 = strcmp(p,
                                                                                                    "--gs");
                                                                                  }
#line 479
                                                                                  if (tmp___34 == 0) {
#line 480
                                                                                    arg ++;
#line 481
                                                                                    if (arg == argc) {
#line 482
                                                                                      return (arg);
                                                                                    }
                                                                                    {
#line 483
                                                                                    strncpy((char */* __restrict  */)(opt->gs),
                                                                                            (char const   */* __restrict  */)*(argv + arg),
                                                                                            sizeof(opt->gs) / sizeof(char ) - 1UL);
                                                                                    }
                                                                                  } else {
                                                                                    {
#line 485
                                                                                    tmp___33 = strcmp(p,
                                                                                                      "--gs-args");
                                                                                    }
#line 485
                                                                                    if (tmp___33 == 0) {
#line 486
                                                                                      arg ++;
#line 487
                                                                                      if (arg == argc) {
#line 488
                                                                                        return (arg);
                                                                                      }
                                                                                      {
#line 489
                                                                                      strncpy((char */* __restrict  */)(opt->gsargs),
                                                                                              (char const   */* __restrict  */)*(argv + arg),
                                                                                              sizeof(opt->gsargs) / sizeof(char ) - 1UL);
                                                                                      }
                                                                                    } else {
                                                                                      {
#line 491
                                                                                      tmp___32 = strcmp(p,
                                                                                                        "--mac-binary");
                                                                                      }
#line 491
                                                                                      if (tmp___32 == 0) {
#line 492
                                                                                        opt->mac_type = (CMAC_TYPE )3;
                                                                                      } else {
                                                                                        {
#line 494
                                                                                        tmp___31 = strcmp(p,
                                                                                                          "--mac-double");
                                                                                        }
#line 494
                                                                                        if (tmp___31 == 0) {
#line 495
                                                                                          opt->mac_type = (CMAC_TYPE )2;
                                                                                        } else {
                                                                                          {
#line 497
                                                                                          tmp___30 = strcmp(p,
                                                                                                            "--mac-rsrc");
                                                                                          }
#line 497
                                                                                          if (tmp___30 == 0) {
#line 498
                                                                                            opt->mac_type = (CMAC_TYPE )4;
                                                                                          } else {
                                                                                            {
#line 500
                                                                                            tmp___29 = strcmp(p,
                                                                                                              "--mac-single");
                                                                                            }
#line 500
                                                                                            if (tmp___29 == 0) {
#line 501
                                                                                              opt->mac_type = (CMAC_TYPE )1;
                                                                                            } else {
                                                                                              {
#line 503
                                                                                              tmp___28 = strcmp(p,
                                                                                                                "--output");
                                                                                              }
#line 503
                                                                                              if (tmp___28 == 0) {
#line 504
                                                                                                arg ++;
#line 505
                                                                                                if (arg == argc) {
#line 506
                                                                                                  return (arg);
                                                                                                }
                                                                                                {
#line 507
                                                                                                strncpy((char */* __restrict  */)(opt->output),
                                                                                                        (char const   */* __restrict  */)*(argv + arg),
                                                                                                        sizeof(opt->output) / sizeof(char ) - 1UL);
                                                                                                }
                                                                                              } else {
                                                                                                {
#line 510
                                                                                                tmp___27 = strcmp(p,
                                                                                                                  "--quiet");
                                                                                                }
#line 510
                                                                                                if (tmp___27 == 0) {
#line 511
                                                                                                  opt->quiet = 1;
                                                                                                } else {
                                                                                                  {
#line 513
                                                                                                  tmp___25 = strcmp(p,
                                                                                                                    "--debug");
                                                                                                  }
#line 513
                                                                                                  if (tmp___25 == 0) {
#line 515
                                                                                                    opt->debug = 1;
                                                                                                  } else {
                                                                                                    {
#line 513
                                                                                                    tmp___26 = strcmp(p,
                                                                                                                      "-d");
                                                                                                    }
#line 513
                                                                                                    if (tmp___26 == 0) {
#line 515
                                                                                                      opt->debug = 1;
                                                                                                    } else {
                                                                                                      {
#line 517
                                                                                                      tmp___23 = strcmp(p,
                                                                                                                        "--doseps-reverse");
                                                                                                      }
#line 517
                                                                                                      if (tmp___23 == 0) {
#line 519
                                                                                                        opt->doseps_reverse = 1;
                                                                                                      } else {
                                                                                                        {
#line 517
                                                                                                        tmp___24 = strcmp(p,
                                                                                                                          "-d");
                                                                                                        }
#line 517
                                                                                                        if (tmp___24 == 0) {
#line 519
                                                                                                          opt->doseps_reverse = 1;
                                                                                                        } else {
                                                                                                          {
#line 521
                                                                                                          tmp___22 = strcmp(p,
                                                                                                                            "--dpi");
                                                                                                          }
#line 521
                                                                                                          if (tmp___22 == 0) {
#line 523
                                                                                                            arg ++;
#line 524
                                                                                                            if (arg == argc) {
#line 525
                                                                                                              return (arg);
                                                                                                            }
                                                                                                            {
#line 526
                                                                                                            tmp___10 = strlen((char const   *)*(argv + arg));
#line 526
                                                                                                            cs_to_narrow(buf___1,
                                                                                                                         (int )sizeof(buf___1) - 1,
                                                                                                                         (char const   *)*(argv + arg),
                                                                                                                         (int )tmp___10 + 1);
#line 528
                                                                                                            tmp___11 = atof((char const   *)(buf___1));
#line 528
                                                                                                            opt->dpi = (float )tmp___11;
                                                                                                            }
                                                                                                          } else {
                                                                                                            {
#line 530
                                                                                                            tmp___21 = strcmp(p,
                                                                                                                              "--dpi-render");
                                                                                                            }
#line 530
                                                                                                            if (tmp___21 == 0) {
#line 532
                                                                                                              arg ++;
#line 533
                                                                                                              if (arg == argc) {
#line 534
                                                                                                                return (arg);
                                                                                                              }
                                                                                                              {
#line 535
                                                                                                              tmp___12 = strlen((char const   *)*(argv + arg));
#line 535
                                                                                                              cs_to_narrow(buf___2,
                                                                                                                           (int )sizeof(buf___2) - 1,
                                                                                                                           (char const   *)*(argv + arg),
                                                                                                                           (int )tmp___12 + 1);
#line 537
                                                                                                              tmp___13 = atof((char const   *)(buf___2));
#line 537
                                                                                                              opt->dpi_render = (float )tmp___13;
                                                                                                              }
                                                                                                            } else {
                                                                                                              {
#line 539
                                                                                                              tmp___20 = strcmp(p,
                                                                                                                                "--image-encode");
                                                                                                              }
#line 539
                                                                                                              if (tmp___20 == 0) {
#line 542
                                                                                                                arg ++;
#line 543
                                                                                                                if (arg == argc) {
#line 544
                                                                                                                  return (arg);
                                                                                                                }
                                                                                                                {
#line 545
                                                                                                                tmp___14 = strlen((char const   *)*(argv + arg));
#line 545
                                                                                                                cs_to_narrow(buf___3,
                                                                                                                             (int )sizeof(buf___3) - 1,
                                                                                                                             (char const   *)*(argv + arg),
                                                                                                                             (int )tmp___14 + 1);
#line 547
                                                                                                                opt->image_encode = atoi((char const   *)(buf___3));
                                                                                                                }
#line 548
                                                                                                                if (opt->image_encode < 0) {
#line 550
                                                                                                                  opt->image_encode = 1;
                                                                                                                } else
#line 548
                                                                                                                if (opt->image_encode > 1) {
#line 550
                                                                                                                  opt->image_encode = 1;
                                                                                                                }
                                                                                                              } else {
                                                                                                                {
#line 552
                                                                                                                tmp___19 = strcmp(p,
                                                                                                                                  "--image-compress");
                                                                                                                }
#line 552
                                                                                                                if (tmp___19 == 0) {
#line 555
                                                                                                                  arg ++;
#line 556
                                                                                                                  if (arg == argc) {
#line 557
                                                                                                                    return (arg);
                                                                                                                  }
                                                                                                                  {
#line 558
                                                                                                                  tmp___15 = strlen((char const   *)*(argv + arg));
#line 558
                                                                                                                  cs_to_narrow(buf___4,
                                                                                                                               (int )sizeof(buf___4) - 1,
                                                                                                                               (char const   *)*(argv + arg),
                                                                                                                               (int )tmp___15 + 1);
#line 560
                                                                                                                  opt->image_compress = atoi((char const   *)(buf___4));
                                                                                                                  }
#line 561
                                                                                                                  if (opt->image_compress < 0) {
#line 563
                                                                                                                    opt->image_compress = 2;
                                                                                                                  } else
#line 561
                                                                                                                  if (opt->image_compress > 2) {
#line 563
                                                                                                                    opt->image_compress = 2;
                                                                                                                  }
                                                                                                                } else {
                                                                                                                  {
#line 565
                                                                                                                  tmp___17 = strcmp(p,
                                                                                                                                    "--help");
                                                                                                                  }
#line 565
                                                                                                                  if (tmp___17 == 0) {
#line 565
                                                                                                                    goto _L;
                                                                                                                  } else {
                                                                                                                    {
#line 565
                                                                                                                    tmp___18 = strcmp(p,
                                                                                                                                      "-h");
                                                                                                                    }
#line 565
                                                                                                                    if (tmp___18 == 0) {
                                                                                                                      _L: /* CIL Label */ 
#line 566
                                                                                                                      opt->help = 1;
#line 567
                                                                                                                      if ((unsigned int )opt->cmd != 0U) {
#line 568
                                                                                                                        return (arg);
                                                                                                                      }
#line 569
                                                                                                                      opt->cmd = (CMD )17;
                                                                                                                    } else {
                                                                                                                      {
#line 571
                                                                                                                      tmp___16 = strcmp(p,
                                                                                                                                        "--version");
                                                                                                                      }
#line 571
                                                                                                                      if (tmp___16 == 0) {
#line 572
                                                                                                                        if ((unsigned int )opt->cmd != 0U) {
#line 573
                                                                                                                          return (arg);
                                                                                                                        }
#line 574
                                                                                                                        opt->cmd = (CMD )19;
                                                                                                                      } else
#line 576
                                                                                                                      if ((int const   )*p != 45) {
#line 577
                                                                                                                        if ((int )opt->input[0] == 0) {
                                                                                                                          {
#line 578
                                                                                                                          strncpy((char */* __restrict  */)(opt->input),
                                                                                                                                  (char const   */* __restrict  */)*(argv + arg),
                                                                                                                                  sizeof(opt->input) / sizeof(char ) - 1UL);
                                                                                                                          }
                                                                                                                        } else
#line 580
                                                                                                                        if ((int )opt->output[0] == 0) {
                                                                                                                          {
#line 581
                                                                                                                          strncpy((char */* __restrict  */)(opt->output),
                                                                                                                                  (char const   */* __restrict  */)*(argv + arg),
                                                                                                                                  sizeof(opt->output) / sizeof(char ) - 1UL);
                                                                                                                          }
                                                                                                                        } else {
#line 584
                                                                                                                          return (arg);
                                                                                                                        }
                                                                                                                      } else {
#line 587
                                                                                                                        return (arg);
                                                                                                                      }
                                                                                                                    }
                                                                                                                  }
                                                                                                                }
                                                                                                              }
                                                                                                            }
                                                                                                          }
                                                                                                        }
                                                                                                      }
                                                                                                    }
                                                                                                  }
                                                                                                }
                                                                                              }
                                                                                            }
                                                                                          }
                                                                                        }
                                                                                      }
                                                                                    }
                                                                                  }
                                                                                }
                                                                              }
                                                                            }
                                                                          }
                                                                        }
                                                                      }
                                                                    }
                                                                  }
                                                                }
                                                              }
                                                            }
                                                          }
                                                        }
                                                      }
                                                    }
                                                  }
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
#line 268
    arg ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 590
  return (0);
}
}
#line 594 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/epstool.c"
static Doc *epstool_open_document(GSview *app , OPT *opt , char *name ) 
{ 
  int code ;
  Doc *doc ;
  int require_eps ;

  {
  {
#line 599
  require_eps = 1;
#line 601
  doc = doc_new(app);
  }
#line 602
  if ((unsigned long )doc == (unsigned long )((void *)0)) {
    {
#line 603
    debug |= 8;
#line 604
    app_csmsgf(app, "Failed to create new Doc\n");
#line 605
    app_unref(app);
    }
#line 606
    return ((Doc *)((void *)0));
  }
  {
#line 609
  doc_add(doc, app);
#line 610
  doc_dsc_warn(doc, opt->dscwarn);
#line 611
  doc_verbose(doc, opt->debug);
#line 613
  code = doc_open(doc, (char const   *)name);
  }
#line 614
  if (code < 0) {
    {
#line 615
    debug |= 8;
#line 616
    app_csmsgf(app, "Error opening file \"%s\".\n", name);
#line 617
    code = -1;
    }
  } else
#line 619
  if (code > 0) {
    {
#line 620
    debug |= 8;
#line 621
    app_csmsgf(app, "Input file \"%s\" didn\'t have DSC comments.\n", name);
#line 623
    code = -1;
    }
  }
#line 627
  if ((unsigned int )opt->cmd == 11U) {
#line 628
    require_eps = 0;
  }
#line 629
  if ((unsigned int )opt->cmd == 18U) {
#line 630
    require_eps = 0;
  }
#line 631
  if ((unsigned int )opt->cmd == 16U) {
#line 632
    require_eps = 0;
  }
#line 633
  if ((unsigned int )opt->cmd == 15U) {
#line 633
    if ((unsigned int )doc->doctype == 4U) {
#line 634
      require_eps = 0;
    }
  }
#line 636
  if (code == 0) {
#line 636
    if (require_eps) {
#line 636
      if ((unsigned long )doc->dsc == (unsigned long )((void *)0)) {
        {
#line 638
        debug |= 8;
#line 639
        app_csmsgf(app, "Input file \"%s\" is not EPSF.\n", name);
#line 641
        code = -1;
        }
      } else
#line 636
      if (! (doc->dsc)->epsf) {
        {
#line 638
        debug |= 8;
#line 639
        app_csmsgf(app, "Input file \"%s\" is not EPSF.\n", name);
#line 641
        code = -1;
        }
      }
    }
  }
#line 643
  if (code == 0) {
#line 643
    if (require_eps) {
#line 643
      if ((unsigned long )doc->dsc != (unsigned long )((void *)0)) {
#line 644
        if ((int )(doc->dsc)->worst_error > 0) {
#line 644
          if ((int )(doc->dsc)->worst_error > opt->dscwarn) {
            {
#line 646
            app_csmsgf(app, "EPS had unacceptable warnings or errors.\n");
#line 648
            code = -1;
            }
          }
        }
      }
    }
  }
#line 651
  if (code) {
    {
#line 652
    doc_close(doc);
#line 653
    doc_remove(doc);
#line 654
    doc_unref(doc);
#line 655
    doc = (Doc *)((void *)0);
    }
  }
#line 657
  return (doc);
}
}
#line 664 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/epstool.c"
int main(int argc , char **argv ) 
{ 
  GSview *app ;
  Doc *doc ;
  Doc *doc2 ;
  int code ;
  int i ;
  int arg ;
  OPT opt ;
  FILE *f ;
  FILE *tmp ;
  FILE *f___0 ;
  FILE *tmp___0 ;
  RENAME_SEPARATION *rs ;
  char const   *tmp___1 ;

  {
  {
#line 668
  doc = (Doc *)((void *)0);
#line 669
  doc2 = (Doc *)((void *)0);
#line 670
  code = 0;
#line 684
  memset((void *)(& opt), 0, sizeof(opt));
#line 685
  arg = parse_args(& opt, argc, argv);
#line 686
  debug = 0;
  }
#line 687
  if (opt.debug) {
#line 688
    debug = 13;
#line 689
    opt.quiet = 0;
  }
#line 691
  if (! opt.quiet) {
#line 692
    debug |= 8;
  }
#line 693
  if (opt.help) {
    {
#line 694
    print_help();
    }
#line 695
    return (1);
  }
#line 697
  if ((unsigned int )opt.cmd == 19U) {
    {
#line 698
    print_version();
    }
#line 699
    return (1);
  }
#line 701
  if (opt.dpi_render < opt.dpi) {
#line 702
    opt.dpi_render = opt.dpi;
  }
  {
#line 704
  app = app_new((void *)0, 0);
  }
#line 705
  if ((unsigned long )app == (unsigned long )((void *)0)) {
    {
#line 706
    fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"Can\'t create epstool app\n");
    }
#line 707
    return (1);
  }
#line 710
  if (arg != 0) {
    {
#line 711
    debug |= 8;
#line 712
    app_csmsgf(app, "epstool: Error in command line arguments:\n  ");
#line 713
    i = 0;
    }
    {
#line 713
    while (1) {
      while_continue: /* CIL Label */ ;
#line 713
      if (! (i < arg)) {
#line 713
        goto while_break;
      }
      {
#line 714
      app_csmsgf(app, "%s ", *(argv + i));
#line 713
      i ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 715
    app_csmsgf(app, "\n    The next argument is unrecognised, missing, or conflicts:\n  ");
    }
    {
#line 716
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 716
      if (! (i < argc)) {
#line 716
        goto while_break___0;
      }
      {
#line 717
      app_csmsgf(app, "%s ", *(argv + i));
#line 716
      i ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 718
    app_csmsgf(app, "\n");
#line 719
    app_unref(app);
    }
#line 720
    return (1);
  }
#line 723
  if ((unsigned int )opt.cmd == 4U) {
#line 723
    if ((int )opt.device[0] == 0) {
      {
#line 724
      debug |= 8;
#line 725
      app_csmsgf(app, "--add-tiff-preview requires a device to be specified with --device\n");
#line 726
      code = -1;
      }
    }
  }
#line 728
  if ((unsigned int )opt.cmd == 0U) {
    {
#line 729
    debug |= 8;
#line 730
    app_csmsgf(app, "No command specified.\n");
#line 731
    code = -1;
    }
  }
#line 733
  if ((int )opt.input[0] == 0) {
    {
#line 734
    debug |= 8;
#line 735
    app_csmsgf(app, "Input file not specified.\n");
#line 736
    code = -1;
    }
  }
#line 738
  if ((int )opt.custom_colours[0] != 0) {
    {
#line 739
    tmp = fopen((char const   */* __restrict  */)(opt.custom_colours), (char const   */* __restrict  */)"rb");
#line 739
    f = tmp;
    }
#line 740
    if ((unsigned long )f == (unsigned long )((FILE *)((void *)0))) {
      {
#line 741
      debug |= 8;
#line 742
      app_csmsgf(app, "Failed to open \"%s\".\n", opt.custom_colours);
#line 744
      code = -1;
      }
    } else {
      {
#line 747
      fclose(f);
      }
    }
  }
#line 749
  if (code == 0) {
    {
#line 750
    tmp___0 = fopen((char const   */* __restrict  */)(opt.input), (char const   */* __restrict  */)"rb");
#line 750
    f___0 = tmp___0;
    }
#line 751
    if ((unsigned long )f___0 == (unsigned long )((FILE *)((void *)0))) {
      {
#line 752
      debug |= 8;
#line 753
      app_csmsgf(app, "Failed to open \"%s\".\n", opt.input);
#line 754
      code = -1;
      }
    } else {
      {
#line 757
      fclose(f___0);
      }
    }
  }
#line 759
  if ((int )opt.output[0] == 0) {
#line 759
    if (! ((unsigned int )opt.cmd == 11U)) {
#line 759
      if (! ((unsigned int )opt.cmd == 18U)) {
#line 759
        if (! ((unsigned int )opt.cmd == 16U)) {
          {
#line 763
          debug |= 8;
#line 764
          app_csmsgf(app, "Output file not specified.\n");
#line 765
          code = -1;
          }
        }
      }
    }
  }
#line 767
  if ((int )opt.output[0] == 45) {
#line 767
    if ((int )opt.output[1] == 0) {
#line 768
      opt.output[0] = (char )'\000';
    }
  }
#line 769
  if (code != 0) {
    {
#line 770
    debug |= 8;
#line 771
    app_csmsgf(app, "Run \"epstool --help\" for more details.\n");
#line 772
    app_unref(app);
    }
#line 773
    return (1);
  }
#line 776
  if ((unsigned int )opt.cmd == 16U) {
    {
#line 777
    dump_macfile((char const   *)(opt.input), 1);
    }
  }
  {
#line 779
  doc = epstool_open_document(app, & opt, opt.input);
  }
#line 780
  if ((unsigned long )doc == (unsigned long )((void *)0)) {
#line 781
    code = -1;
  }
#line 783
  if (opt.combine[0]) {
    {
#line 785
    doc2 = epstool_open_document(app, & opt, opt.combine);
    }
#line 786
    if ((unsigned long )doc2 == (unsigned long )((void *)0)) {
#line 787
      code = -1;
    }
  }
#line 790
  if (code == 0) {
#line 790
    if (opt.bbox) {
      {
#line 797
      if ((unsigned int )opt.cmd == 15U) {
#line 797
        goto case_15;
      }
#line 797
      if ((unsigned int )opt.cmd == 6U) {
#line 797
        goto case_15;
      }
#line 797
      if ((unsigned int )opt.cmd == 5U) {
#line 797
        goto case_15;
      }
#line 797
      if ((unsigned int )opt.cmd == 3U) {
#line 797
        goto case_15;
      }
#line 797
      if ((unsigned int )opt.cmd == 2U) {
#line 797
        goto case_15;
      }
#line 797
      if ((unsigned int )opt.cmd == 1U) {
#line 797
        goto case_15;
      }
#line 805
      goto switch_default;
      case_15: /* CIL Label */ 
      case_6: /* CIL Label */ 
      case_5: /* CIL Label */ 
      case_3: /* CIL Label */ 
      case_2: /* CIL Label */ 
      case_1: /* CIL Label */ 
#line 798
      if ((doc->dsc)->dcs2) {
        {
#line 799
        debug |= 8;
#line 800
        app_csmsgf(app, "Ignoring --bbox for DCS 2.0.\n");
#line 801
        opt.bbox = 0;
        }
      }
#line 804
      goto switch_break;
      switch_default: /* CIL Label */ 
      {
#line 806
      debug |= 8;
#line 807
      app_csmsgf(app, "Can\'t use --bbox with this command.  Ignoring --bbox.\n");
#line 809
      opt.bbox = 0;
      }
      switch_break: /* CIL Label */ ;
      }
    }
  }
#line 813
  if (code == 0) {
    {
#line 822
    if ((unsigned int )opt.cmd == 8U) {
#line 822
      goto case_8;
    }
#line 822
    if ((unsigned int )opt.cmd == 7U) {
#line 822
      goto case_8;
    }
#line 822
    if ((unsigned int )opt.cmd == 6U) {
#line 822
      goto case_8;
    }
#line 822
    if ((unsigned int )opt.cmd == 5U) {
#line 822
      goto case_8;
    }
#line 822
    if ((unsigned int )opt.cmd == 4U) {
#line 822
      goto case_8;
    }
#line 822
    if ((unsigned int )opt.cmd == 3U) {
#line 822
      goto case_8;
    }
#line 822
    if ((unsigned int )opt.cmd == 2U) {
#line 822
      goto case_8;
    }
#line 822
    if ((unsigned int )opt.cmd == 1U) {
#line 822
      goto case_8;
    }
#line 826
    if ((unsigned int )opt.cmd == 9U) {
#line 826
      goto case_9;
    }
#line 826
    if ((unsigned int )opt.cmd == 10U) {
#line 826
      goto case_9;
    }
#line 832
    if ((unsigned int )opt.cmd == 11U) {
#line 832
      goto case_11;
    }
#line 836
    if ((unsigned int )opt.cmd == 13U) {
#line 836
      goto case_13;
    }
#line 836
    if ((unsigned int )opt.cmd == 12U) {
#line 836
      goto case_13;
    }
#line 839
    if ((unsigned int )opt.cmd == 14U) {
#line 839
      goto case_14;
    }
#line 842
    if ((unsigned int )opt.cmd == 15U) {
#line 842
      goto case_15___0;
    }
#line 845
    if ((unsigned int )opt.cmd == 18U) {
#line 845
      goto case_18;
    }
#line 848
    if ((unsigned int )opt.cmd == 16U) {
#line 848
      goto case_16;
    }
#line 852
    goto switch_default___0;
    case_8: /* CIL Label */ 
    case_7: /* CIL Label */ 
    case_6___0: /* CIL Label */ 
    case_5___0: /* CIL Label */ 
    case_4: /* CIL Label */ 
    case_3___0: /* CIL Label */ 
    case_2___0: /* CIL Label */ 
    case_1___0: /* CIL Label */ 
    {
#line 823
    code = epstool_add_preview(doc, & opt);
    }
#line 824
    goto switch_break___0;
    case_9: /* CIL Label */ 
    case_10: /* CIL Label */ 
#line 827
    if ((doc->dsc)->dcs2) {
      {
#line 828
      code = epstool_dcs2_check_files(doc, & opt);
      }
    }
#line 829
    if (code == 0) {
      {
#line 830
      code = epstool_dcs2_copy(doc, doc2, & opt);
      }
    }
#line 831
    goto switch_break___0;
    case_11: /* CIL Label */ 
    {
#line 833
    code = epstool_dcs2_report(doc);
    }
#line 834
    goto switch_break___0;
    case_13: /* CIL Label */ 
    case_12: /* CIL Label */ 
    {
#line 837
    code = epstool_extract(doc, & opt);
    }
#line 838
    goto switch_break___0;
    case_14: /* CIL Label */ 
    {
#line 840
    code = epstool_bitmap(doc, & opt);
    }
#line 841
    goto switch_break___0;
    case_15___0: /* CIL Label */ 
    {
#line 843
    code = epstool_copy(doc, & opt);
    }
#line 844
    goto switch_break___0;
    case_18: /* CIL Label */ 
    {
#line 846
    code = epstool_test(doc, & opt);
    }
#line 847
    goto switch_break___0;
    case_16: /* CIL Label */ 
#line 849
    if (doc) {
#line 849
      if (doc->dsc) {
        {
#line 850
        dsc_display(doc->dsc, & epstool_dump_fn);
        }
      }
    }
#line 851
    goto switch_break___0;
    switch_default___0: /* CIL Label */ 
#line 856
    code = -1;
#line 857
    goto switch_break___0;
    switch_break___0: /* CIL Label */ ;
    }
  }
#line 862
  if (doc) {
    {
#line 863
    doc_close(doc);
#line 864
    doc_remove(doc);
#line 865
    doc_unref(doc);
    }
  }
  {
#line 868
  app_unref(app);
#line 874
  debug &= -5;
  }
  {
#line 875
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 875
    if (! opt.rename_sep) {
#line 875
      goto while_break___1;
    }
#line 876
    rs = opt.rename_sep;
#line 877
    if (rs->oldname) {
      {
#line 878
      free((void *)rs->oldname);
      }
    }
#line 879
    if (rs->newname) {
      {
#line 880
      free((void *)rs->newname);
      }
    }
    {
#line 881
    opt.rename_sep = rs->next;
#line 882
    free((void *)rs);
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 885
  if (! opt.quiet) {
#line 886
    if (code == 0) {
#line 886
      tmp___1 = "OK";
    } else {
#line 886
      tmp___1 = "Failed";
    }
    {
#line 886
    fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"%s\n",
            tmp___1);
    }
  }
#line 887
  if (code != 0) {
#line 888
    return (1);
  }
#line 889
  return (code);
}
}
#line 894 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/epstool.c"
static int epstool_add_preview(Doc *doc , OPT *opt ) 
{ 
  int code ;
  CDSCBBOX devbbox ;
  CDSCBBOX bbox ;
  CDSCFBBOX hires_bbox ;
  CDSCFBBOX *phires_bbox ;
  char const   *device ;
  FILE *f ;
  char preview[256] ;
  IMAGE *img ;

  {
#line 897
  code = 0;
#line 898
  devbbox.llx = 0;
#line 898
  devbbox.lly = 0;
#line 898
  devbbox.urx = 595;
#line 898
  devbbox.ury = 842;
#line 899
  bbox.llx = 0;
#line 899
  bbox.lly = 0;
#line 899
  bbox.urx = 0;
#line 899
  bbox.ury = 0;
#line 900
  hires_bbox.fllx = (float )0.0;
#line 900
  hires_bbox.flly = (float )0.0;
#line 900
  hires_bbox.furx = (float )0.0;
#line 900
  hires_bbox.fury = (float )0.0;
#line 901
  phires_bbox = (CDSCFBBOX *)((void *)0);
#line 902
  device = "ppmraw";
#line 905
  img = (IMAGE *)((void *)0);
#line 906
  if ((int )opt->device[0] != 0) {
#line 907
    device = (char const   *)(opt->device);
  } else
#line 908
  if ((unsigned int )opt->cmd == 5U) {
#line 909
    device = "pbmraw";
  }
#line 910
  if ((unsigned int )opt->cmd == 1U) {
#line 911
    device = "pbmraw";
  }
#line 913
  if ((doc->dsc)->bbox) {
#line 914
    bbox = *((doc->dsc)->bbox);
  } else {
#line 917
    opt->bbox = 1;
  }
#line 919
  if ((doc->dsc)->hires_bbox) {
#line 920
    hires_bbox = *((doc->dsc)->hires_bbox);
#line 921
    phires_bbox = & hires_bbox;
  }
#line 924
  if ((unsigned int )opt->cmd == 8U) {
    {
#line 927
    img = bmpfile_to_image((char const   *)(opt->user_preview));
    }
#line 928
    if ((unsigned long )img == (unsigned long )((void *)0)) {
      {
#line 929
      img = pnmfile_to_image((char const   *)(opt->user_preview));
      }
    }
  } else
#line 931
  if (! ((unsigned int )opt->cmd == 4U)) {
    {
#line 935
    img = make_preview_image(doc, opt, 0, device, & bbox, & hires_bbox, opt->bbox);
    }
#line 937
    if ((unsigned long )img == (unsigned long )((void *)0)) {
      {
#line 938
      app_csmsgf(doc->app, "Couldn\'t make preview image\n");
      }
#line 939
      return (-1);
    }
#line 941
    if (hires_bbox.fllx < hires_bbox.furx) {
#line 941
      if (hires_bbox.flly < hires_bbox.fury) {
#line 943
        phires_bbox = & hires_bbox;
      }
    }
  }
#line 946
  if (img) {
#line 947
    devbbox.lly = 0;
#line 947
    devbbox.llx = devbbox.lly;
#line 948
    devbbox.urx = (int )img->width;
#line 949
    devbbox.ury = (int )img->height;
  }
  {
#line 955
  if ((unsigned int )opt->cmd == 1U) {
#line 955
    goto case_1;
  }
#line 960
  if ((unsigned int )opt->cmd == 2U) {
#line 960
    goto case_2;
  }
#line 965
  if ((unsigned int )opt->cmd == 3U) {
#line 965
    goto case_3;
  }
#line 970
  if ((unsigned int )opt->cmd == 4U) {
#line 970
    goto case_4;
  }
#line 992
  if ((unsigned int )opt->cmd == 5U) {
#line 992
    goto case_5;
  }
#line 996
  if ((unsigned int )opt->cmd == 6U) {
#line 996
    goto case_6;
  }
#line 1000
  if ((unsigned int )opt->cmd == 7U) {
#line 1000
    goto case_7;
  }
#line 1004
  if ((unsigned int )opt->cmd == 8U) {
#line 1004
    goto case_8;
  }
#line 1013
  goto switch_default;
  case_1: /* CIL Label */ 
  {
#line 956
  code = make_eps_tiff(doc, img, devbbox, & bbox, phires_bbox, opt->dpi, opt->dpi,
                       1, 0, opt->doseps_reverse, (char const   *)(opt->output));
  }
#line 959
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 961
  code = make_eps_tiff(doc, img, devbbox, & bbox, phires_bbox, opt->dpi, opt->dpi,
                       0, 0, opt->doseps_reverse, (char const   *)(opt->output));
  }
#line 964
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 966
  code = make_eps_tiff(doc, img, devbbox, & bbox, phires_bbox, opt->dpi, opt->dpi,
                       0, 1, opt->doseps_reverse, (char const   *)(opt->output));
  }
#line 969
  goto switch_break;
  case_4: /* CIL Label */ 
  {
#line 972
  preview[0] = (char )'\000';
#line 973
  f = app_temp_file(doc->app, preview, (int )(sizeof(preview) / sizeof(char )));
  }
#line 973
  if ((unsigned long )f == (unsigned long )((FILE *)((void *)0))) {
    {
#line 975
    app_csmsgf(doc->app, "Can\'t create temporary tiff file \"%s\"\n", preview);
#line 978
    code = -1;
    }
  } else {
    {
#line 981
    fclose(f);
    }
#line 982
    if (code == 0) {
      {
#line 983
      code = make_preview_file(doc, opt, 0, (char const   *)(preview), device, opt->dpi,
                               & bbox, & hires_bbox, opt->bbox);
      }
    }
#line 985
    if (code == 0) {
      {
#line 986
      code = make_eps_user(doc, (char const   *)(preview), opt->doseps_reverse, (char const   *)(opt->output));
      }
    }
#line 988
    if (! (debug & 1)) {
      {
#line 989
      unlink((char const   *)(preview));
      }
    }
  }
#line 991
  goto switch_break;
  case_5: /* CIL Label */ 
  {
#line 993
  code = make_eps_interchange(doc, img, devbbox, & bbox, phires_bbox, (char const   *)(opt->output));
  }
#line 995
  goto switch_break;
  case_6: /* CIL Label */ 
  {
#line 997
  code = make_eps_metafile(doc, img, devbbox, & bbox, phires_bbox, opt->dpi, opt->dpi,
                           opt->doseps_reverse, (char const   *)(opt->output));
  }
#line 999
  goto switch_break;
  case_7: /* CIL Label */ 
  {
#line 1001
  code = make_eps_pict(doc, img, & bbox, phires_bbox, opt->dpi, opt->dpi, opt->mac_type,
                       (char const   *)(opt->output));
  }
#line 1003
  goto switch_break;
  case_8: /* CIL Label */ 
#line 1005
  if (img) {
    {
#line 1006
    code = make_eps_tiff(doc, img, devbbox, & bbox, phires_bbox, opt->dpi, opt->dpi,
                         0, 1, opt->doseps_reverse, (char const   *)(opt->output));
    }
  } else {
    {
#line 1010
    code = make_eps_user(doc, (char const   *)(opt->user_preview), opt->doseps_reverse,
                         (char const   *)(opt->output));
    }
  }
#line 1012
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 1014
  return (0);
  switch_break: /* CIL Label */ ;
  }
#line 1017
  if (img) {
    {
#line 1018
    bitmap_image_free(img);
    }
  }
#line 1019
  return (code);
}
}
#line 1024 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/epstool.c"
static int epstool_extract(Doc *doc , OPT *opt ) 
{ 
  int code ;

  {
#line 1028
  if ((unsigned long )doc->dsc != (unsigned long )((CDSC *)((void *)0))) {
#line 1028
    if ((unsigned long )(doc->dsc)->macbin != (unsigned long )((CDSCMACBIN *)((void *)0))) {
      {
#line 1030
      code = extract_macbin(doc, (char const   *)(opt->output), (unsigned int )opt->cmd == 12U);
      }
    } else {
      {
#line 1032
      code = extract_doseps(doc, (char const   *)(opt->output), (unsigned int )opt->cmd == 12U);
      }
    }
  } else {
    {
#line 1032
    code = extract_doseps(doc, (char const   *)(opt->output), (unsigned int )opt->cmd == 12U);
    }
  }
#line 1033
  return (code);
}
}
#line 1038 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/epstool.c"
static int epstool_bitmap(Doc *doc , OPT *opt ) 
{ 
  int code ;
  CDSCBBOX bbox ;
  CDSCFBBOX hires_bbox ;
  char const   *device ;
  int page ;

  {
#line 1041
  code = 0;
#line 1044
  device = "ppmraw";
#line 1045
  page = opt->page;
#line 1046
  if ((int )opt->device[0] != 0) {
#line 1047
    device = (char const   *)(opt->device);
  }
#line 1049
  if ((doc->dsc)->bbox) {
#line 1050
    bbox = *((doc->dsc)->bbox);
  } else {
#line 1052
    bbox.ury = 0;
#line 1052
    bbox.urx = bbox.ury;
#line 1052
    bbox.lly = bbox.urx;
#line 1052
    bbox.llx = bbox.lly;
#line 1053
    opt->bbox = 1;
  }
#line 1056
  if ((doc->dsc)->hires_bbox) {
#line 1057
    hires_bbox = *((doc->dsc)->hires_bbox);
  } else {
#line 1059
    hires_bbox.fllx = (float )bbox.llx;
#line 1060
    hires_bbox.flly = (float )bbox.lly;
#line 1061
    hires_bbox.furx = (float )bbox.urx;
#line 1062
    hires_bbox.fury = (float )bbox.ury;
  }
#line 1065
  if ((doc->dsc)->page_count == 0U) {
#line 1066
    page = 0;
  } else
#line 1067
  if (opt->page < 0) {
#line 1068
    return (-1);
  } else
#line 1067
  if (opt->page >= (int )(doc->dsc)->page_count) {
#line 1068
    return (-1);
  }
  {
#line 1070
  code = make_preview_file(doc, opt, page, (char const   *)(opt->output), device,
                           opt->dpi, & bbox, & hires_bbox, opt->bbox);
  }
#line 1073
  return (code);
}
}
#line 1078 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/epstool.c"
static int epstool_copy(Doc *doc , OPT *opt ) 
{ 
  int code ;
  int tmp ;
  CDSCBBOX bbox ;
  CDSCFBBOX hires_bbox ;
  GFile *f ;
  char tpsname[256] ;

  {
#line 1081
  code = 0;
#line 1088
  if ((unsigned int )doc->doctype == 4U) {
    {
#line 1089
    tmp = epstool_copy_bitmap(doc, opt);
    }
#line 1089
    return (tmp);
  }
#line 1092
  if (opt->bbox) {
    {
#line 1098
    memset((void *)(tpsname), 0, sizeof(tpsname));
#line 1099
    memset((void *)(& bbox), 0, sizeof(bbox));
#line 1100
    memset((void *)(& hires_bbox), 0, sizeof(hires_bbox));
    }
#line 1101
    if ((doc->dsc)->bbox) {
      {
#line 1102
      memcpy((void */* __restrict  */)(& bbox), (void const   */* __restrict  */)(& (doc->dsc)->bbox),
             sizeof(bbox));
      }
    }
#line 1103
    if ((doc->dsc)->hires_bbox) {
      {
#line 1104
      memcpy((void */* __restrict  */)(& hires_bbox), (void const   */* __restrict  */)(& (doc->dsc)->hires_bbox),
             sizeof(hires_bbox));
      }
    }
    {
#line 1107
    f = app_temp_gfile(doc->app, tpsname, (int )(sizeof(tpsname) / sizeof(char )));
    }
#line 1107
    if ((unsigned long )f == (unsigned long )((GFile *)((void *)0))) {
      {
#line 1109
      app_csmsgf(doc->app, "Can\'t create temporary ps file \"%s\"\n", tpsname);
      }
#line 1112
      return (-1);
    }
    {
#line 1114
    code = copy_page_temp(doc, f, 0);
#line 1115
    gfile_close(f);
    }
#line 1116
    if (code != 0) {
#line 1117
      if (! (debug & 1)) {
        {
#line 1118
        unlink((char const   *)(tpsname));
        }
      }
#line 1119
      return (-1);
    }
    {
#line 1121
    code = calculate_bbox(doc, opt, (char const   *)(tpsname), & bbox, & hires_bbox);
    }
#line 1123
    if (code == 0) {
      {
#line 1124
      code = copy_eps(doc, (char const   *)(opt->output), & bbox, & hires_bbox, 0,
                      0);
      }
    }
#line 1127
    if (! (debug & 1)) {
      {
#line 1128
      unlink((char const   *)(tpsname));
      }
    }
  } else {
    {
#line 1131
    code = copy_eps(doc, (char const   *)(opt->output), (doc->dsc)->bbox, (doc->dsc)->hires_bbox,
                    0, 0);
    }
  }
#line 1135
  return (code);
}
}
#line 1139 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/epstool.c"
static int epstool_copy_bitmap(Doc *doc , OPT *opt ) 
{ 
  int code ;
  IMAGE *img ;
  GFile *f ;
  double width ;
  double height ;

  {
  {
#line 1142
  code = 0;
#line 1144
  img = bmpfile_to_image((char const   *)(doc->name));
  }
#line 1145
  if ((unsigned long )img == (unsigned long )((void *)0)) {
    {
#line 1146
    img = pnmfile_to_image((char const   *)(doc->name));
    }
  }
#line 1147
  if ((unsigned long )img == (unsigned long )((void *)0)) {
    {
#line 1148
    img = pngfile_to_image((char const   *)(doc->name));
    }
  }
#line 1149
  if ((unsigned long )img == (unsigned long )((void *)0)) {
#line 1150
    code = -1;
  }
#line 1152
  if (code == 0) {
#line 1153
    f = (GFile *)((void *)0);
#line 1154
    width = ((double )img->width * 72.0) / (double )opt->dpi;
#line 1155
    height = ((double )img->height * 72.0) / (double )opt->dpi;
#line 1157
    if ((unsigned long )img == (unsigned long )((void *)0)) {
#line 1158
      code = -1;
    } else
#line 1157
    if ((unsigned long )img->image == (unsigned long )((void *)0)) {
#line 1158
      code = -1;
    }
#line 1160
    if (code == 0) {
      {
#line 1161
      f = gfile_open((char const   *)(opt->output), 4097U);
      }
#line 1162
      if ((unsigned long )f == (unsigned long )((void *)0)) {
        {
#line 1163
        code = -1;
#line 1164
        app_msgf(doc->app, "Failed to open \"%s\" for writing\n", opt->output);
        }
      }
    }
#line 1169
    if (code == 0) {
      {
#line 1170
      code = image_to_eps(f, img, 0, 0, (int )(width + 0.999), (int )(height + 0.999),
                          (float )0.0, (float )0.0, (float )width, (float )height,
                          opt->image_encode, opt->image_compress);
      }
    }
#line 1174
    if (f) {
      {
#line 1175
      gfile_close(f);
      }
    }
  }
#line 1177
  return (code);
}
}
#line 1185 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/epstool.c"
static int epstool_dcs2_copy(Doc *doc , Doc *doc2 , OPT *opt ) 
{ 
  GFile *infile ;
  GFile *doc2file ;
  GFile *outfile ;
  unsigned long complen ;
  int code ;
  GFile *compfile ;
  char compname[256] ;
  char temp_outname[256] ;
  char const   *tmp ;
  char const   *tmp___0 ;

  {
#line 1188
  infile = (GFile *)((void *)0);
#line 1189
  doc2file = (GFile *)((void *)0);
#line 1190
  outfile = (GFile *)((void *)0);
#line 1191
  complen = 0UL;
#line 1192
  code = 0;
#line 1193
  compfile = (GFile *)((void *)0);
#line 1197
  if ((unsigned long )(doc->dsc)->dcs2 == (unsigned long )((void *)0)) {
    {
#line 1198
    app_csmsgf(doc->app, "Input file is not DCS 2.0\n");
    }
#line 1199
    return (-1);
  }
  {
#line 1201
  memset((void *)(compname), 0, sizeof(compname));
  }
#line 1202
  if (opt->composite) {
    {
#line 1206
    compfile = app_temp_gfile(doc->app, compname, (int )(sizeof(compname) / sizeof(char )));
    }
#line 1206
    if ((unsigned long )compfile == (unsigned long )((GFile *)((void *)0))) {
      {
#line 1208
      app_csmsgf(doc->app, "Can\'t create temporary composite EPS file \"%s\"\n",
                 compname);
      }
#line 1211
      return (-1);
    }
    {
#line 1213
    custom_colours_read(opt);
#line 1214
    code = epstool_dcs2_composite(doc, opt, compfile);
#line 1215
    custom_colours_free(opt);
#line 1216
    gfile_close(compfile);
    }
#line 1217
    if (code == 0) {
      {
#line 1218
      compfile = gfile_open((char const   *)(compname), 0U);
      }
#line 1219
      if ((unsigned long )compfile == (unsigned long )((GFile *)((void *)0))) {
#line 1220
        code = -1;
      }
    }
#line 1222
    if (code) {
#line 1223
      if (! (debug & 1)) {
#line 1223
        if (compname[0]) {
          {
#line 1224
          unlink((char const   *)(compname));
          }
        }
      }
#line 1225
      return (-1);
    }
  }
#line 1230
  if (code == 0) {
    {
#line 1231
    tmp = doc_name(doc);
#line 1231
    infile = gfile_open(tmp, 0U);
#line 1231
    code = (unsigned long )infile == (unsigned long )((GFile *)((void *)0));
    }
  }
#line 1233
  if (code == 0) {
#line 1233
    if (doc2) {
      {
#line 1234
      tmp___0 = doc_name(doc2);
#line 1234
      doc2file = gfile_open(tmp___0, 0U);
#line 1234
      code = (unsigned long )doc2file == (unsigned long )((GFile *)((void *)0));
      }
    }
  }
#line 1236
  if ((unsigned int )opt->cmd == 10U) {
#line 1237
    if (code == 0) {
      {
#line 1238
      outfile = app_temp_gfile(doc->app, temp_outname, (int )(sizeof(temp_outname) / sizeof(char )));
#line 1238
      code = (unsigned long )outfile == (unsigned long )((GFile *)((void *)0));
      }
    }
#line 1240
    if (code == 0) {
      {
#line 1241
      code = copy_dcs2(doc, infile, doc2, doc2file, outfile, (char const   *)(temp_outname),
                       0, 0, 0, opt->missing_separations, & complen, compfile, opt->rename_sep,
                       opt->tolerance);
      }
    }
    {
#line 1248
    gfile_seek(infile, 0L, 0U);
    }
#line 1249
    if (compfile) {
      {
#line 1250
      gfile_seek(compfile, 0L, 0U);
      }
    }
    {
#line 1251
    gfile_close(outfile);
#line 1252
    outfile = (GFile *)((void *)0);
    }
#line 1253
    if (! (debug & 1)) {
#line 1253
      if (temp_outname[0]) {
        {
#line 1254
        unlink((char const   *)(temp_outname));
        }
      }
    }
  }
#line 1256
  if (code == 0) {
    {
#line 1257
    outfile = gfile_open((char const   *)(opt->output), 4097U);
#line 1257
    code = (unsigned long )outfile == (unsigned long )((GFile *)((void *)0));
    }
#line 1259
    if (code) {
      {
#line 1260
      app_msgf(doc->app, "Failed to open \"%s\" for writing\n", opt->output);
      }
    }
  }
#line 1263
  if (code == 0) {
    {
#line 1264
    code = copy_dcs2(doc, infile, doc2, doc2file, outfile, (char const   *)(opt->output),
                     0, (unsigned int )opt->cmd == 9U, 1, opt->missing_separations,
                     & complen, compfile, opt->rename_sep, opt->tolerance);
    }
  }
#line 1271
  if ((unsigned long )infile != (unsigned long )((GFile *)((void *)0))) {
    {
#line 1272
    gfile_close(infile);
    }
  }
#line 1273
  if ((unsigned long )doc2file != (unsigned long )((GFile *)((void *)0))) {
    {
#line 1274
    gfile_close(doc2file);
    }
  }
#line 1275
  if ((unsigned long )outfile != (unsigned long )((GFile *)((void *)0))) {
    {
#line 1276
    gfile_close(outfile);
    }
  }
#line 1277
  if ((unsigned long )compfile != (unsigned long )((GFile *)((void *)0))) {
    {
#line 1278
    gfile_close(compfile);
    }
  }
#line 1279
  if (! (debug & 1)) {
#line 1279
    if (compname[0]) {
      {
#line 1280
      unlink((char const   *)(compname));
      }
    }
  }
#line 1282
  return (code);
}
}
#line 1285 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/epstool.c"
static int epstool_dcs2_report(Doc *doc ) 
{ 
  int i ;
  int code ;
  CDSC *dsc ;
  char const   *type ;
  char const   *preview ;
  unsigned long length ;
  GFile *f ;
  char const   *tmp ;
  int found ;
  char const   *name ;
  float cyan ;
  float magenta ;
  float yellow ;
  float black ;
  int tmp___0 ;

  {
#line 1289
  code = 0;
#line 1290
  dsc = doc->dsc;
#line 1291
  type = "Unknown";
#line 1292
  preview = "Unknown";
#line 1294
  if (dsc) {
#line 1294
    if (dsc->dcs2) {
#line 1295
      length = 0UL;
#line 1298
      if (dsc->page_count == 0U) {
        {
#line 1300
        app_msgf(doc->app, "WARNING: Missing composite, so a separation offset is probably wrong.\n");
#line 1301
        code = 2;
        }
      } else
#line 1298
      if ((dsc->page + 0)->begin == (dsc->page + 0)->end) {
        {
#line 1300
        app_msgf(doc->app, "WARNING: Missing composite, so a separation offset is probably wrong.\n");
#line 1301
        code = 2;
        }
      }
      {
#line 1304
      tmp = doc_name(doc);
#line 1304
      f = gfile_open(tmp, 0U);
      }
#line 1304
      if ((unsigned long )f != (unsigned long )((GFile *)((void *)0))) {
        {
#line 1305
        length = gfile_get_length(f);
#line 1306
        gfile_close(f);
        }
      }
#line 1308
      i = 0;
      {
#line 1308
      while (1) {
        while_continue: /* CIL Label */ ;
#line 1308
        if (! (i < (int )dsc->page_count)) {
#line 1308
          goto while_break;
        }
#line 1309
        if ((dsc->page + i)->begin > length) {
          {
#line 1311
          app_msgf(doc->app, "WARNING: separation %s extends beyond EOF\n", (dsc->page + i)->label);
#line 1314
          code = 2;
          }
        } else
#line 1309
        if ((dsc->page + i)->end > length) {
          {
#line 1311
          app_msgf(doc->app, "WARNING: separation %s extends beyond EOF\n", (dsc->page + i)->label);
#line 1314
          code = 2;
          }
        }
#line 1308
        i ++;
      }
      while_break: /* CIL Label */ ;
      }
    }
  }
#line 1320
  if ((unsigned long )dsc == (unsigned long )((void *)0)) {
#line 1321
    if ((unsigned int )doc->doctype == 2U) {
#line 1322
      type = "PDF";
    } else {
#line 1324
      type = "Unknown";
    }
  } else
#line 1326
  if (dsc->dcs2) {
#line 1327
    if (dsc->dcs1) {
#line 1328
      type = "DCS1.0";
    } else {
#line 1330
      type = "DCS2.0";
    }
  } else
#line 1332
  if (dsc->epsf) {
#line 1333
    type = "EPSF";
  } else
#line 1334
  if (dsc->pdf) {
#line 1335
    type = "PDF";
  } else {
#line 1337
    type = "DSC";
  }
  {
#line 1338
  fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"Type\t%s\n",
          type);
  }
#line 1339
  if ((unsigned long )dsc == (unsigned long )((void *)0)) {
#line 1340
    return (1);
  }
  {
#line 1348
  if (dsc->preview == 1U) {
#line 1348
    goto case_1;
  }
#line 1351
  if (dsc->preview == 2U) {
#line 1351
    goto case_2;
  }
#line 1354
  if (dsc->preview == 3U) {
#line 1354
    goto case_3;
  }
#line 1357
  if (dsc->preview == 4U) {
#line 1357
    goto case_4;
  }
#line 1344
  goto switch_default;
  switch_default: /* CIL Label */ 
#line 1346
  preview = "None";
#line 1347
  goto switch_break;
  case_1: /* CIL Label */ 
#line 1349
  preview = "Interchange";
#line 1350
  goto switch_break;
  case_2: /* CIL Label */ 
#line 1352
  preview = "TIFF";
#line 1353
  goto switch_break;
  case_3: /* CIL Label */ 
#line 1355
  preview = "WMF";
#line 1356
  goto switch_break;
  case_4: /* CIL Label */ 
#line 1358
  preview = "PICT";
#line 1359
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 1361
  fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"Preview\t%s\n",
          preview);
  }
#line 1363
  if (dsc->bbox) {
    {
#line 1364
    fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"BoundingBox\t%d\t%d\t%d\t%d\n",
            (dsc->bbox)->llx, (dsc->bbox)->lly, (dsc->bbox)->urx, (dsc->bbox)->ury);
    }
  } else {
    {
#line 1368
    fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"BoundingBox\n");
    }
  }
#line 1369
  if (dsc->hires_bbox) {
    {
#line 1370
    fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"HiBoundingBox\t%g\t%g\t%g\t%g\n",
            (double )(dsc->hires_bbox)->fllx, (double )(dsc->hires_bbox)->flly, (double )(dsc->hires_bbox)->furx,
            (double )(dsc->hires_bbox)->fury);
    }
  } else {
    {
#line 1374
    fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"HiResBoundingBox\n");
    }
  }
#line 1377
  if (! dsc->dcs2) {
#line 1378
    return (1);
  }
#line 1381
  i = 0;
  {
#line 1381
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1381
    if (! (i < (int )dsc->page_count)) {
#line 1381
      goto while_break___0;
    }
#line 1382
    found = -1;
#line 1383
    name = (dsc->page + i)->label;
#line 1385
    black = (float )0.0;
#line 1385
    yellow = black;
#line 1385
    magenta = yellow;
#line 1385
    cyan = magenta;
#line 1386
    if ((unsigned long )name == (unsigned long )((void *)0)) {
#line 1387
      name = "Unknown";
    }
    {
#line 1388
    tmp___0 = strcmp(name, "Composite");
    }
#line 1388
    if (tmp___0 != 0) {
      {
#line 1389
      found = colour_to_cmyk(dsc, name, & cyan, & magenta, & yellow, & black);
      }
    }
#line 1390
    if (found == 0) {
      {
#line 1391
      fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"%s\t%lu\t%g\t%g\t%g\t%g\n",
              name, (dsc->page + i)->end - (dsc->page + i)->begin, (double )cyan,
              (double )magenta, (double )yellow, (double )black);
      }
    } else {
      {
#line 1395
      fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"%s\t%lu\n",
              name, (dsc->page + i)->end - (dsc->page + i)->begin);
      }
    }
#line 1381
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1398
  return (code);
}
}
#line 1402 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/epstool.c"
static int epstool_dcs2_check_files(Doc *doc , OPT *opt ) 
{ 
  int code ;
  int i ;
  CDSC *dsc ;
  GFile *f ;
  char const   *fname ;
  char const   **renamed1 ;
  char wfname[256] ;
  size_t tmp ;
  void *tmp___0 ;
  int tmp___1 ;

  {
#line 1405
  code = 0;
#line 1407
  dsc = doc->dsc;
#line 1410
  renamed1 = (char const   **)((void *)0);
#line 1411
  i = 1;
  {
#line 1411
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1411
    if (! (i < (int )dsc->page_count)) {
#line 1411
      goto while_break;
    }
    {
#line 1413
    fname = dsc_find_platefile(dsc, i);
    }
#line 1414
    if (fname) {
      {
#line 1416
      tmp = strlen(fname);
#line 1416
      narrow_to_cs(wfname, (int )(sizeof(wfname) / sizeof(char ) - 1UL), fname, (int )tmp + 1);
#line 1418
      f = gfile_open((char const   *)(wfname), 0U);
      }
#line 1418
      if ((unsigned long )f != (unsigned long )((GFile *)((void *)0))) {
        {
#line 1419
        gfile_close(f);
        }
      } else {
#line 1422
        if (! opt->missing_separations) {
#line 1423
          code = -1;
        }
#line 1424
        if (! opt->quiet) {
          {
#line 1425
          app_msgf(doc->app, "Separation \"%s\" is missing file \"%s\"\n", (dsc->page + i)->label,
                   fname);
          }
        }
      }
    } else
#line 1431
    if ((dsc->page + i)->end <= (dsc->page + i)->begin) {
#line 1432
      if (! opt->quiet) {
        {
#line 1433
        app_msgf(doc->app, "Separation \"%s\" is empty\n", (dsc->page + i)->label);
        }
      }
#line 1436
      if (! opt->missing_separations) {
#line 1437
        code = -1;
      }
    }
#line 1411
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1442
  tmp___0 = malloc(sizeof(char const   *) * (unsigned long )dsc->page_count);
#line 1442
  renamed1 = (char const   **)tmp___0;
  }
#line 1443
  if ((unsigned long )renamed1 != (unsigned long )((void *)0)) {
    {
#line 1444
    tmp___1 = rename_separations(dsc, opt->rename_sep, renamed1);
    }
#line 1444
    if (tmp___1 != 0) {
#line 1445
      code = -1;
#line 1446
      if (! opt->quiet) {
        {
#line 1447
        app_msgf(doc->app, "Duplicate separations are not permitted.\n");
        }
      }
    }
    {
#line 1449
    free((void *)renamed1);
    }
  }
#line 1452
  return (code);
}
}
#line 1458 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/epstool.c"
static int custom_colours_read(OPT *opt ) 
{ 
  FILE *f ;
  char line[256] ;
  CUSTOM_COLOUR colour ;
  CUSTOM_COLOUR *pcolour ;
  CUSTOM_COLOUR *tail ;
  int i ;
  char *s ;
  int code ;
  double tmp ;
  double tmp___0 ;
  double tmp___1 ;
  double tmp___2 ;
  double tmp___3 ;
  double tmp___4 ;
  double tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  void *tmp___10 ;
  char *tmp___11 ;

  {
#line 1465
  tail = opt->colours;
#line 1468
  code = 0;
#line 1469
  if (opt->custom_colours[0]) {
    {
#line 1471
    f = fopen((char const   */* __restrict  */)(opt->custom_colours), (char const   */* __restrict  */)"r");
    }
#line 1472
    if ((unsigned long )f == (unsigned long )((void *)0)) {
#line 1473
      return (-1);
    }
    {
#line 1474
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1474
      if (tail) {
#line 1474
        if (! tail->next) {
#line 1474
          goto while_break;
        }
      } else {
#line 1474
        goto while_break;
      }
#line 1475
      tail = tail->next;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 1476
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 1476
      tmp___11 = fgets((char */* __restrict  */)(line), (int )sizeof(line), (FILE */* __restrict  */)f);
      }
#line 1476
      if (! ((unsigned long )tmp___11 != (unsigned long )((void *)0))) {
#line 1476
        goto while_break___0;
      }
      {
#line 1477
      memset((void *)(& colour), 0, sizeof(colour));
#line 1478
      i = 0;
#line 1479
      s = line;
#line 1480
      tmp___7 = strncmp((char const   *)(line), "%%CMYKCustomColor:", (size_t )18);
      }
#line 1480
      if (tmp___7 == 0) {
#line 1481
        s += 18;
#line 1482
        colour.type = (CUSTOM_COLOUR_TYPE )0;
        {
#line 1483
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 1483
          if (*s) {
#line 1483
            if (! ((int )*s == 32)) {
#line 1483
              goto while_break___1;
            }
          } else {
#line 1483
            goto while_break___1;
          }
#line 1484
          s ++;
        }
        while_break___1: /* CIL Label */ ;
        }
        {
#line 1486
        s = strtok((char */* __restrict  */)s, (char const   */* __restrict  */)" \t\r\n");
        }
#line 1487
        if ((unsigned long )s != (unsigned long )((void *)0)) {
          {
#line 1488
          tmp = atof((char const   *)s);
#line 1488
          colour.cyan = (float )tmp;
#line 1489
          s = strtok((char */* __restrict  */)((void *)0), (char const   */* __restrict  */)" \t\r\n");
          }
        }
#line 1491
        if ((unsigned long )s != (unsigned long )((void *)0)) {
          {
#line 1492
          tmp___0 = atof((char const   *)s);
#line 1492
          colour.magenta = (float )tmp___0;
#line 1493
          s = strtok((char */* __restrict  */)((void *)0), (char const   */* __restrict  */)" \t\r\n");
          }
        }
#line 1495
        if ((unsigned long )s != (unsigned long )((void *)0)) {
          {
#line 1496
          tmp___1 = atof((char const   *)s);
#line 1496
          colour.yellow = (float )tmp___1;
#line 1497
          s = strtok((char */* __restrict  */)((void *)0), (char const   */* __restrict  */)" \t\r\n");
          }
        }
#line 1499
        if ((unsigned long )s != (unsigned long )((void *)0)) {
          {
#line 1500
          tmp___2 = atof((char const   *)s);
#line 1500
          colour.black = (float )tmp___2;
#line 1501
          s = strtok((char */* __restrict  */)((void *)0), (char const   */* __restrict  */)"\t\r\n");
          }
        }
      } else {
        {
#line 1504
        tmp___6 = strncmp((char const   *)(line), "%%RGBCustomColor:", (size_t )17);
        }
#line 1504
        if (tmp___6 == 0) {
#line 1505
          s += 17;
#line 1506
          colour.type = (CUSTOM_COLOUR_TYPE )1;
          {
#line 1507
          while (1) {
            while_continue___2: /* CIL Label */ ;
#line 1507
            if (*s) {
#line 1507
              if (! ((int )*s == 32)) {
#line 1507
                goto while_break___2;
              }
            } else {
#line 1507
              goto while_break___2;
            }
#line 1508
            s ++;
          }
          while_break___2: /* CIL Label */ ;
          }
          {
#line 1510
          s = strtok((char */* __restrict  */)s, (char const   */* __restrict  */)" \t\r\n");
          }
#line 1511
          if ((unsigned long )s != (unsigned long )((void *)0)) {
            {
#line 1512
            tmp___3 = atof((char const   *)s);
#line 1512
            colour.red = (float )tmp___3;
#line 1513
            s = strtok((char */* __restrict  */)((void *)0), (char const   */* __restrict  */)" \t\r\n");
            }
          }
#line 1515
          if ((unsigned long )s != (unsigned long )((void *)0)) {
            {
#line 1516
            tmp___4 = atof((char const   *)s);
#line 1516
            colour.green = (float )tmp___4;
#line 1517
            s = strtok((char */* __restrict  */)((void *)0), (char const   */* __restrict  */)" \t\r\n");
            }
          }
#line 1519
          if ((unsigned long )s != (unsigned long )((void *)0)) {
            {
#line 1520
            tmp___5 = atof((char const   *)s);
#line 1520
            colour.blue = (float )tmp___5;
#line 1521
            s = strtok((char */* __restrict  */)((void *)0), (char const   */* __restrict  */)"\t\r\n");
            }
          }
        } else {
#line 1525
          s = (char *)((void *)0);
        }
      }
#line 1528
      if ((unsigned long )s != (unsigned long )((void *)0)) {
        {
#line 1530
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 1530
          if (*s) {
#line 1530
            if (! ((int )*s == 32)) {
#line 1530
              goto while_break___3;
            }
          } else {
#line 1530
            goto while_break___3;
          }
#line 1531
          s ++;
        }
        while_break___3: /* CIL Label */ ;
        }
#line 1532
        if ((int )*s == 40) {
#line 1533
          s ++;
          {
#line 1534
          while (1) {
            while_continue___4: /* CIL Label */ ;
#line 1534
            if (*s) {
#line 1534
              if (! ((int )*s != 41)) {
#line 1534
                goto while_break___4;
              }
            } else {
#line 1534
              goto while_break___4;
            }
#line 1535
            if (i < (int )sizeof(colour.name) - 1) {
#line 1536
              tmp___8 = i;
#line 1536
              i ++;
#line 1536
              colour.name[tmp___8] = *s;
            }
#line 1537
            s ++;
          }
          while_break___4: /* CIL Label */ ;
          }
#line 1539
          if ((int )*s == 41) {
#line 1540
            s ++;
          }
        } else {
          {
#line 1543
          while (1) {
            while_continue___5: /* CIL Label */ ;
#line 1543
            if (*s) {
#line 1543
              if ((int )*s != 32) {
#line 1543
                if ((int )*s != 9) {
#line 1543
                  if ((int )*s != 13) {
#line 1543
                    if (! ((int )*s != 10)) {
#line 1543
                      goto while_break___5;
                    }
                  } else {
#line 1543
                    goto while_break___5;
                  }
                } else {
#line 1543
                  goto while_break___5;
                }
              } else {
#line 1543
                goto while_break___5;
              }
            } else {
#line 1543
              goto while_break___5;
            }
#line 1545
            if (i < (int )sizeof(colour.name) - 1) {
#line 1546
              tmp___9 = i;
#line 1546
              i ++;
#line 1546
              colour.name[tmp___9] = *s;
            }
#line 1547
            s ++;
          }
          while_break___5: /* CIL Label */ ;
          }
        }
#line 1550
        colour.name[i] = (char )'\000';
      }
#line 1552
      if (debug & 1) {
#line 1553
        if ((unsigned long )s == (unsigned long )((void *)0)) {
          {
#line 1554
          fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"Unrecognised line: %s\n",
                  line);
          }
        } else
#line 1555
        if ((unsigned int )colour.type == 0U) {
          {
#line 1556
          fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"CMYK Colour: %g %g %g %g (%s)\n",
                  (double )colour.cyan, (double )colour.magenta, (double )colour.yellow,
                  (double )colour.black, colour.name);
          }
        } else
#line 1559
        if ((unsigned int )colour.type == 1U) {
          {
#line 1560
          fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"RGB Colour: %g %g %g (%s)\n",
                  (double )colour.red, (double )colour.green, (double )colour.blue,
                  colour.name);
          }
        } else {
          {
#line 1564
          fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"Unrecognised colour\n");
          }
        }
      }
#line 1566
      if ((unsigned long )s == (unsigned long )((void *)0)) {
#line 1567
        if (code == 0) {
#line 1568
          code = 1;
        }
      } else {
        {
#line 1571
        tmp___10 = malloc(sizeof(CUSTOM_COLOUR ));
#line 1571
        pcolour = (CUSTOM_COLOUR *)tmp___10;
        }
#line 1572
        if ((unsigned long )pcolour == (unsigned long )((void *)0)) {
#line 1573
          code = -1;
        } else {
          {
#line 1576
          memcpy((void */* __restrict  */)pcolour, (void const   */* __restrict  */)(& colour),
                 sizeof(colour));
          }
#line 1577
          if (tail) {
#line 1578
            tail->next = pcolour;
#line 1579
            tail = pcolour;
          } else {
#line 1582
            tail = pcolour;
#line 1582
            opt->colours = tail;
          }
        }
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 1586
    fclose(f);
    }
  }
#line 1588
  return (code);
}
}
#line 1591 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/epstool.c"
static void custom_colours_free(OPT *opt ) 
{ 
  CUSTOM_COLOUR *pcolour ;

  {
  {
#line 1595
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1595
    if (! opt->colours) {
#line 1595
      goto while_break;
    }
    {
#line 1596
    pcolour = opt->colours;
#line 1597
    opt->colours = (opt->colours)->next;
#line 1598
    free((void *)pcolour);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1600
  return;
}
}
#line 1602 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/epstool.c"
static CUSTOM_COLOUR *custom_colours_find(OPT *opt , char const   *name ) 
{ 
  CUSTOM_COLOUR *pcolour ;
  int tmp ;

  {
#line 1605
  pcolour = opt->colours;
  {
#line 1606
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1606
    if (! pcolour) {
#line 1606
      goto while_break;
    }
    {
#line 1607
    tmp = strcmp(name, (char const   *)(pcolour->name));
    }
#line 1607
    if (tmp == 0) {
#line 1608
      goto while_break;
    }
#line 1609
    pcolour = pcolour->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 1611
  return (pcolour);
}
}
#line 1615 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/epstool.c"
static float round_float(float f , int n ) 
{ 


  {
#line 1618
  return ((float )((int )((double )(f * (float )n) + 0.5)) / (float )n);
}
}
#line 1622 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/epstool.c"
static int calculate_bbox(Doc *doc , OPT *opt , char const   *psname , CDSCBBOX *bbox ,
                          CDSCFBBOX *hires_bbox ) 
{ 
  FILE *bboxfile ;
  char bboxname[256] ;
  char command[2048] ;
  char line[256] ;
  int got_bbox ;
  int got_hires_bbox ;
  int code ;
  int llx ;
  int lly ;
  int urx ;
  int ury ;
  float fllx ;
  float flly ;
  float furx ;
  float fury ;
  int pagesize ;
  int offset ;
  char const   *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  char *tmp___5 ;

  {
  {
#line 1629
  got_bbox = 0;
#line 1630
  got_hires_bbox = 0;
#line 1631
  code = 0;
#line 1634
  pagesize = 9400;
#line 1635
  offset = 3000;
#line 1636
  bboxfile = app_temp_file(doc->app, bboxname, (int )(sizeof(bboxname) / sizeof(char )));
  }
#line 1636
  if ((unsigned long )bboxfile == (unsigned long )((FILE *)((void *)0))) {
    {
#line 1638
    app_csmsgf(doc->app, "Can\'t create temporary bbox file \"%s\"\n", bboxname);
    }
#line 1640
    return (-1);
  }
  {
#line 1642
  fclose(bboxfile);
  }
#line 1644
  if (opt->quiet) {
#line 1644
    tmp = "-dQUIET";
  } else {
#line 1644
    tmp = "";
  }
  {
#line 1644
  snprintf((char */* __restrict  */)(command), sizeof(command) / sizeof(char ), (char const   */* __restrict  */)"\"%s\" %s -dNOPAUSE -dBATCH -sDEVICE=bbox %s  -c \"<</PageSize [%d %d] /PageOffset [%d %d]>> setpagedevice\" -f \"%s\"",
           opt->gs, tmp, opt->gsargs, pagesize, pagesize, offset, offset, psname);
  }
#line 1649
  if (! opt->quiet) {
    {
#line 1650
    app_csmsgf(doc->app, "%s\n", command);
    }
  }
  {
#line 1651
  tmp___0 = fileno(stdout);
#line 1651
  code = exec_program(command, -1, tmp___0, -1, (char const   *)((void *)0), (char const   *)((void *)0),
                      (char const   *)(bboxname));
  }
#line 1652
  if (code != 0) {
    {
#line 1653
    app_csmsgf(doc->app, "Ghostscript failed to obtain bounding box\n");
    }
  }
#line 1657
  if (code == 0) {
    {
#line 1658
    bboxfile = fopen((char const   */* __restrict  */)(bboxname), (char const   */* __restrict  */)"rb");
    }
#line 1658
    if ((unsigned long )bboxfile == (unsigned long )((FILE *)((void *)0))) {
      {
#line 1659
      app_csmsgf(doc->app, "Can\'t open temporary bbox file \"%s\"\n", bboxname);
#line 1662
      code = -1;
      }
    }
  }
#line 1666
  if (code == 0) {
    {
#line 1667
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 1667
      tmp___5 = fgets((char */* __restrict  */)(line), (int )sizeof(line), (FILE */* __restrict  */)bboxfile);
      }
#line 1667
      if (! ((unsigned long )tmp___5 != (unsigned long )((void *)0))) {
#line 1667
        goto while_break;
      }
      {
#line 1668
      tmp___4 = strncmp((char const   *)(line), "%%BoundingBox: ", (size_t )15);
      }
#line 1668
      if (tmp___4 == 0) {
#line 1669
        if (! opt->quiet) {
          {
#line 1670
          app_msgf(doc->app, "%s", line);
          }
        }
        {
#line 1671
        tmp___1 = sscanf((char const   */* __restrict  */)(line + 15), (char const   */* __restrict  */)"%d %d %d %d",
                         & llx, & lly, & urx, & ury);
        }
#line 1671
        if (tmp___1 == 4) {
#line 1673
          bbox->llx = llx - offset;
#line 1674
          bbox->lly = lly - offset;
#line 1675
          bbox->urx = urx - offset;
#line 1676
          bbox->ury = ury - offset;
#line 1677
          got_bbox = 1;
        }
      } else {
        {
#line 1680
        tmp___3 = strncmp((char const   *)(line), "%%HiResBoundingBox: ", (size_t )20);
        }
#line 1680
        if (tmp___3 == 0) {
#line 1681
          if (! opt->quiet) {
            {
#line 1682
            app_msgf(doc->app, "%s", line);
            }
          }
          {
#line 1683
          tmp___2 = sscanf((char const   */* __restrict  */)(line + 20), (char const   */* __restrict  */)"%f %f %f %f",
                           & fllx, & flly, & furx, & fury);
          }
#line 1683
          if (tmp___2 == 4) {
            {
#line 1685
            hires_bbox->fllx = round_float(fllx - (float )offset, 1000);
#line 1686
            hires_bbox->flly = round_float(flly - (float )offset, 1000);
#line 1687
            hires_bbox->furx = round_float(furx - (float )offset, 1000);
#line 1688
            hires_bbox->fury = round_float(fury - (float )offset, 1000);
#line 1689
            got_hires_bbox = 1;
            }
          }
        }
      }
#line 1692
      if (got_bbox) {
#line 1692
        if (got_hires_bbox) {
#line 1693
          goto while_break;
        }
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 1697
  fclose(bboxfile);
  }
#line 1698
  if (! (debug & 1)) {
    {
#line 1699
    unlink((char const   *)(bboxname));
    }
  }
#line 1701
  if (code == 0) {
#line 1701
    if (! got_bbox) {
      {
#line 1702
      app_csmsgf(doc->app, "Didn\'t get bounding box\n");
#line 1703
      code = -1;
      }
    }
  }
#line 1705
  if (code == 0) {
#line 1705
    if (! got_hires_bbox) {
      {
#line 1706
      app_csmsgf(doc->app, "Didn\'t get hires bounding box\n");
#line 1707
      code = -1;
      }
    }
  }
#line 1709
  return (code);
}
}
#line 1712 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/epstool.c"
static int calc_device_size(float dpi , CDSCBBOX *bbox , CDSCFBBOX *hires_bbox , int *width ,
                            int *height , float *xoffset , float *yoffset ) 
{ 
  int code ;
  int hires_bbox_valid ;

  {
#line 1716
  code = 0;
#line 1717
  hires_bbox_valid = 1;
#line 1718
  if (bbox->llx >= bbox->urx) {
#line 1720
    code = -1;
  } else
#line 1718
  if (bbox->lly >= bbox->ury) {
#line 1720
    code = -1;
  }
#line 1723
  if (hires_bbox->fllx > hires_bbox->furx) {
#line 1725
    hires_bbox_valid = 0;
#line 1726
    code = -1;
  } else
#line 1723
  if (hires_bbox->flly > hires_bbox->fury) {
#line 1725
    hires_bbox_valid = 0;
#line 1726
    code = -1;
  }
#line 1728
  if (hires_bbox->fllx == hires_bbox->furx) {
#line 1730
    hires_bbox_valid = 0;
  } else
#line 1728
  if (hires_bbox->flly == hires_bbox->fury) {
#line 1730
    hires_bbox_valid = 0;
  }
#line 1735
  if (hires_bbox_valid) {
#line 1736
    *width = (int )((double )((hires_bbox->furx - hires_bbox->fllx) * dpi) / 72.0 + 0.5);
#line 1737
    *height = (int )((double )((hires_bbox->fury - hires_bbox->flly) * dpi) / 72.0 + 0.5);
#line 1738
    *xoffset = - hires_bbox->fllx;
#line 1739
    *yoffset = - hires_bbox->flly;
  } else {
#line 1742
    *width = (int )((double )((float )(bbox->urx - bbox->llx) * dpi) / 72.0 + 0.5);
#line 1743
    *height = (int )((double )((float )(bbox->ury - bbox->lly) * dpi) / 72.0 + 0.5);
#line 1744
    *xoffset = (float )(- bbox->llx);
#line 1745
    *yoffset = (float )(- bbox->lly);
  }
#line 1747
  return (0);
}
}
#line 1751 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/epstool.c"
static int make_preview_file(Doc *doc , OPT *opt , int page , char const   *preview ,
                             char const   *device , float dpi , CDSCBBOX *bbox , CDSCFBBOX *hires_bbox ,
                             int calc_bbox ) 
{ 
  GFile *f ;
  int code ;
  char tpsname[256] ;
  char command[2048] ;
  int width ;
  int height ;
  float xoffset ;
  float yoffset ;
  char const   *tmp ;
  char const   *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 1757
  code = 0;
#line 1764
  f = app_temp_gfile(doc->app, tpsname, (int )(sizeof(tpsname) / sizeof(char )));
  }
#line 1764
  if ((unsigned long )f == (unsigned long )((GFile *)((void *)0))) {
    {
#line 1766
    app_csmsgf(doc->app, "Can\'t create temporary ps file \"%s\"\n", tpsname);
    }
#line 1769
    return (-1);
  }
  {
#line 1771
  code = copy_page_temp(doc, f, page);
#line 1772
  gfile_close(f);
  }
#line 1773
  if (code != 0) {
#line 1774
    if (! (debug & 1)) {
      {
#line 1775
      unlink((char const   *)(tpsname));
      }
    }
#line 1776
    return (-1);
  }
#line 1780
  if (code == 0) {
#line 1780
    if (calc_bbox) {
      {
#line 1781
      code = calculate_bbox(doc, opt, (char const   *)(tpsname), bbox, hires_bbox);
      }
    }
  }
#line 1782
  height = 0;
#line 1782
  width = height;
#line 1783
  yoffset = (float )0.0;
#line 1783
  xoffset = yoffset;
#line 1784
  if (code == 0) {
    {
#line 1785
    code = calc_device_size(dpi, bbox, hires_bbox, & width, & height, & xoffset, & yoffset);
    }
  }
#line 1787
  if (code) {
    {
#line 1788
    app_csmsgf(doc->app, "BoundingBox is invalid\n");
    }
#line 1789
    if (! (debug & 1)) {
      {
#line 1790
      unlink((char const   *)(tpsname));
      }
    }
#line 1791
    return (-1);
  }
#line 1795
  if ((int const   )*(preview + 0) == 0) {
#line 1795
    tmp = "-";
  } else {
#line 1795
    tmp = preview;
  }
#line 1795
  if (opt->quiet) {
#line 1795
    tmp___0 = "-dQUIET";
  } else {
#line 1795
    tmp___0 = "";
  }
  {
#line 1795
  snprintf((char */* __restrict  */)(command), sizeof(command) / sizeof(char ), (char const   */* __restrict  */)"\"%s\" %s -dNOPAUSE -dBATCH -sDEVICE=%s -sOutputFile=\"%s\" -r%g -g%dx%d %s -c %f %f translate -f \"%s\"",
           opt->gs, tmp___0, device, tmp, (double )dpi, width, height, opt->gsargs,
           (double )xoffset, (double )yoffset, tpsname);
  }
#line 1800
  if (! opt->quiet) {
    {
#line 1801
    app_csmsgf(doc->app, "%s\n", command);
    }
  }
  {
#line 1802
  tmp___1 = fileno(stderr);
#line 1802
  tmp___2 = fileno(stdout);
#line 1802
  code = exec_program(command, -1, tmp___2, tmp___1, (char const   *)((void *)0),
                      (char const   *)((void *)0), (char const   *)((void *)0));
  }
#line 1804
  if (code != 0) {
    {
#line 1805
    app_csmsgf(doc->app, "Ghostscript failed to create preview image\n");
    }
  }
#line 1809
  if (! (debug & 1)) {
    {
#line 1810
    unlink((char const   *)(tpsname));
    }
  }
#line 1812
  return (code);
}
}
#line 1816 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/epstool.c"
static IMAGE *make_preview_image(Doc *doc , OPT *opt , int page , char const   *device ,
                                 CDSCBBOX *bbox , CDSCFBBOX *hires_bbox , int calc_bbox ) 
{ 
  IMAGE *img ;
  IMAGE *newimg ;
  char preview[256] ;
  GFile *f ;
  int code ;
  void *tmp ;
  int ncomp ;
  int width ;
  int height ;
  float xoffset ;
  float yoffset ;
  void *tmp___0 ;
  int tmp___1 ;

  {
  {
#line 1820
  img = (IMAGE *)((void *)0);
#line 1821
  newimg = (IMAGE *)((void *)0);
#line 1824
  code = 0;
#line 1827
  f = app_temp_gfile(doc->app, preview, (int )(sizeof(preview) / sizeof(char )));
  }
#line 1827
  if ((unsigned long )f == (unsigned long )((GFile *)((void *)0))) {
    {
#line 1829
    app_csmsgf(doc->app, "Can\'t create temporary bitmap file \"%s\"\n", preview);
#line 1832
    code = -1;
    }
  } else {
    {
#line 1835
    gfile_close(f);
    }
  }
#line 1837
  if (code == 0) {
    {
#line 1838
    code = make_preview_file(doc, opt, page, (char const   *)(preview), device, opt->dpi_render,
                             bbox, hires_bbox, calc_bbox);
    }
  }
#line 1841
  if (code == 0) {
    {
#line 1843
    img = bmpfile_to_image((char const   *)(preview));
    }
#line 1844
    if ((unsigned long )img == (unsigned long )((void *)0)) {
      {
#line 1845
      img = pnmfile_to_image((char const   *)(preview));
      }
    }
  }
#line 1848
  if (img) {
#line 1848
    if (opt->dpi_render != opt->dpi) {
      {
#line 1850
      tmp = malloc(sizeof(IMAGE ));
#line 1850
      newimg = (IMAGE *)tmp;
      }
#line 1851
      if ((unsigned long )newimg != (unsigned long )((void *)0)) {
        {
#line 1855
        memset((void *)newimg, 0, sizeof(newimg));
#line 1856
        calc_device_size(opt->dpi, bbox, hires_bbox, & width, & height, & xoffset,
                         & yoffset);
#line 1858
        newimg->width = (unsigned int )width;
#line 1859
        newimg->height = (unsigned int )height;
#line 1860
        newimg->format = img->format;
        }
#line 1861
        if (((long )newimg->format & 15L) == 8L) {
#line 1863
          ncomp = 4;
        } else
#line 1864
        if (((long )newimg->format & 15L) == 4L) {
#line 1866
          ncomp = 3;
        } else {
#line 1868
          ncomp = 1;
        }
        {
#line 1869
        newimg->raster = newimg->width * (unsigned int )ncomp;
#line 1870
        tmp___0 = malloc((size_t )(newimg->raster * newimg->height));
#line 1870
        newimg->image = (unsigned char *)tmp___0;
        }
#line 1871
        if ((unsigned long )newimg->image == (unsigned long )((void *)0)) {
          {
#line 1872
          free((void *)newimg);
#line 1873
          newimg = (IMAGE *)((void *)0);
          }
        }
      }
#line 1876
      if ((unsigned long )newimg != (unsigned long )((void *)0)) {
        {
#line 1877
        memset((void *)newimg->image, 0, (size_t )(newimg->raster * newimg->height));
#line 1878
        tmp___1 = image_down_scale(newimg, img);
        }
#line 1878
        if (tmp___1 != 0) {
          {
#line 1879
          bitmap_image_free(newimg);
#line 1880
          newimg = (IMAGE *)((void *)0);
          }
        }
      }
#line 1883
      if ((unsigned long )newimg != (unsigned long )((void *)0)) {
        {
#line 1884
        bitmap_image_free(img);
#line 1885
        img = newimg;
        }
      }
    }
  }
#line 1889
  if (! (debug & 1)) {
    {
#line 1890
    unlink((char const   *)(preview));
    }
  }
#line 1891
  return (img);
}
}
#line 1896 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/epstool.c"
static int epstool_dcs2_composite(Doc *doc , OPT *opt , GFile *compfile ) 
{ 
  CDSC *dsc ;
  IMAGE img ;
  IMAGE *layer ;
  int width ;
  int height ;
  float xoffset ;
  float yoffset ;
  float cyan ;
  float magenta ;
  float yellow ;
  float black ;
  int code ;
  int i ;
  CDSCBBOX bbox ;
  CDSCFBBOX hires_bbox ;
  int hires_bbox_valid ;
  void *tmp ;
  int found ;
  CUSTOM_COLOUR *ccolour ;
  char const   *name ;
  float tmp___1 ;
  float tmp___2 ;

  {
#line 1899
  dsc = doc->dsc;
#line 1901
  layer = (IMAGE *)((void *)0);
#line 1905
  code = 0;
#line 1907
  bbox.llx = 0;
#line 1907
  bbox.lly = 0;
#line 1907
  bbox.urx = 0;
#line 1907
  bbox.ury = 0;
#line 1908
  hires_bbox.fllx = (float )0.0;
#line 1908
  hires_bbox.flly = (float )0.0;
#line 1908
  hires_bbox.furx = (float )0.0;
#line 1908
  hires_bbox.fury = (float )0.0;
#line 1909
  hires_bbox_valid = 0;
#line 1912
  if ((unsigned long )doc->dsc == (unsigned long )((void *)0)) {
#line 1913
    return (-1);
  }
#line 1914
  if ((unsigned long )(doc->dsc)->dcs2 == (unsigned long )((void *)0)) {
#line 1915
    return (-1);
  }
#line 1917
  if (dsc->bbox) {
#line 1918
    bbox = *(dsc->bbox);
  } else {
#line 1921
    return (-1);
  }
#line 1922
  if (dsc->hires_bbox) {
#line 1923
    hires_bbox = *(dsc->hires_bbox);
#line 1924
    hires_bbox_valid = 1;
  }
  {
#line 1928
  code = calc_device_size(opt->dpi, & bbox, & hires_bbox, & width, & height, & xoffset,
                          & yoffset);
  }
#line 1930
  if (code) {
    {
#line 1931
    app_csmsgf(doc->app, "BoundingBox is invalid\n");
    }
#line 1932
    return (-1);
  }
  {
#line 1934
  memset((void *)(& img), 0, sizeof(img));
#line 1935
  img.width = (unsigned int )width;
#line 1936
  img.height = (unsigned int )height;
#line 1937
  img.raster = img.width * 4U;
#line 1938
  img.format = 2056U;
#line 1940
  tmp = malloc((size_t )(img.raster * img.height));
#line 1940
  img.image = (unsigned char *)tmp;
  }
#line 1941
  if ((unsigned long )img.image == (unsigned long )((void *)0)) {
#line 1942
    return (-1);
  }
  {
#line 1943
  memset((void *)img.image, 0, (size_t )(img.raster * img.height));
#line 1948
  i = 1;
  }
  {
#line 1948
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1948
    if (! (i < (int )dsc->page_count)) {
#line 1948
      goto while_break;
    }
#line 1951
    ccolour = (CUSTOM_COLOUR *)((void *)0);
#line 1952
    name = (dsc->page + i)->label;
#line 1953
    if ((unsigned long )name == (unsigned long )((void *)0)) {
      {
#line 1954
      app_msgf(doc->app, "Page %d doesn\'t have a label\n", i);
#line 1955
      code = -1;
      }
#line 1956
      goto while_break;
    }
    {
#line 1958
    found = colour_to_cmyk(dsc, name, & cyan, & magenta, & yellow, & black);
#line 1959
    ccolour = custom_colours_find(opt, name);
    }
#line 1959
    if ((unsigned long )ccolour != (unsigned long )((void *)0)) {
#line 1961
      found = 0;
#line 1962
      if ((unsigned int )ccolour->type == 1U) {
#line 1963
        cyan = (float )(1.0 - (double )ccolour->red);
#line 1964
        magenta = (float )(1.0 - (double )ccolour->green);
#line 1965
        yellow = (float )(1.0 - (double )ccolour->blue);
#line 1966
        if (magenta < yellow) {
#line 1966
          tmp___2 = magenta;
        } else {
#line 1966
          tmp___2 = yellow;
        }
#line 1966
        if (cyan < tmp___2) {
#line 1966
          black = cyan;
        } else {
#line 1966
          if (magenta < yellow) {
#line 1966
            tmp___1 = magenta;
          } else {
#line 1966
            tmp___1 = yellow;
          }
#line 1966
          black = tmp___1;
        }
#line 1967
        if ((double )black > 0.0) {
#line 1968
          cyan -= black;
#line 1969
          magenta -= black;
#line 1970
          yellow -= black;
        }
      } else {
#line 1974
        cyan = ccolour->cyan;
#line 1975
        magenta = ccolour->magenta;
#line 1976
        yellow = ccolour->yellow;
#line 1977
        black = ccolour->black;
      }
    }
#line 1980
    if (found < 0) {
      {
#line 1981
      app_msgf(doc->app, "Unrecognised colour (%s)\n", name);
#line 1982
      code = -1;
      }
#line 1983
      goto while_break;
    }
#line 1986
    if ((double )cyan == 0.0) {
#line 1986
      if ((double )magenta == 0.0) {
#line 1986
        if ((double )yellow == 0.0) {
#line 1986
          if ((double )black == 0.0) {
#line 1988
            if (! opt->quiet) {
              {
#line 1989
              app_msgf(doc->app, "Skipping blank separation %s\n", name);
              }
            }
#line 1990
            goto __Cont;
          }
        }
      }
    }
#line 1992
    if (! opt->quiet) {
      {
#line 1993
      app_msgf(doc->app, "Creating image from separation %s\n", name);
      }
    }
    {
#line 1995
    layer = make_preview_image(doc, opt, i, "pgmraw", & bbox, & hires_bbox, 0);
    }
#line 1997
    if ((unsigned long )layer == (unsigned long )((void *)0)) {
      {
#line 1998
      app_msgf(doc->app, "Failed to make image for separation (%s)\n", name);
#line 2000
      code = -1;
      }
#line 2001
      goto while_break;
    } else {
#line 2004
      if (! opt->quiet) {
        {
#line 2005
        app_msgf(doc->app, "Merging separation %g %g %g %g  %s\n", (double )cyan,
                 (double )magenta, (double )yellow, (double )black, name);
        }
      }
      {
#line 2007
      code = image_merge_cmyk(& img, layer, cyan, magenta, yellow, black);
#line 2008
      bitmap_image_free(layer);
      }
#line 2009
      if (code < 0) {
        {
#line 2010
        app_msgf(doc->app, "Failed to merge separation (%s)\n", name);
#line 2011
        code = -1;
        }
#line 2012
        goto while_break;
      }
    }
    __Cont: /* CIL Label */ 
#line 1948
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2019
  if (code == 0) {
#line 2020
    if (! opt->quiet) {
      {
#line 2021
      app_msgf(doc->app, "Writing composite as EPS\n");
      }
    }
    {
#line 2022
    code = image_to_eps(compfile, & img, bbox.llx, bbox.lly, bbox.urx, bbox.ury, hires_bbox.fllx,
                        hires_bbox.flly, hires_bbox.furx, hires_bbox.fury, opt->image_encode,
                        opt->image_compress);
    }
  }
  {
#line 2030
  free((void *)img.image);
  }
#line 2031
  return (code);
}
}
#line 2035 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/epstool.c"
static int colour_to_cmyk(CDSC *dsc , char const   *name , float *cyan , float *magenta ,
                          float *yellow , float *black ) 
{ 
  int code ;
  CDSCCOLOUR *colour ;
  int tmp ;
  float tmp___1 ;
  float tmp___2 ;
  float tmp___3 ;
  float tmp___4 ;
  float tmp___5 ;
  float tmp___6 ;
  float tmp___7 ;
  float tmp___8 ;
  float tmp___9 ;
  float tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;

  {
#line 2039
  code = 0;
#line 2040
  colour = dsc->colours;
#line 2041
  if ((unsigned long )name == (unsigned long )((void *)0)) {
#line 2042
    return (-1);
  }
  {
#line 2043
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2043
    if (! colour) {
#line 2043
      goto while_break;
    }
#line 2044
    if (colour->name) {
      {
#line 2044
      tmp = dsc_stricmp((char const   *)colour->name, name);
      }
#line 2044
      if (tmp == 0) {
#line 2045
        goto while_break;
      }
    }
#line 2046
    colour = colour->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 2049
  if (colour) {
#line 2049
    if ((unsigned int )colour->custom == 2U) {
#line 2050
      *cyan = colour->cyan;
#line 2051
      *magenta = colour->magenta;
#line 2052
      *yellow = colour->yellow;
#line 2053
      *black = colour->black;
    } else {
#line 2049
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 2055
  if (colour) {
#line 2055
    if ((unsigned int )colour->custom == 1U) {
#line 2056
      *cyan = (float )(1.0 - (double )colour->red);
#line 2057
      *magenta = (float )(1.0 - (double )colour->green);
#line 2058
      *yellow = (float )(1.0 - (double )colour->blue);
#line 2059
      if (*magenta < *yellow) {
#line 2059
        tmp___2 = *magenta;
      } else {
#line 2059
        tmp___2 = *yellow;
      }
#line 2059
      if (*cyan < tmp___2) {
#line 2059
        *black = *cyan;
      } else {
#line 2059
        if (*magenta < *yellow) {
#line 2059
          tmp___1 = *magenta;
        } else {
#line 2059
          tmp___1 = *yellow;
        }
#line 2059
        *black = tmp___1;
      }
#line 2060
      if ((double )*black > 0.0) {
#line 2061
        *cyan -= *black;
#line 2062
        *magenta -= *black;
#line 2063
        *yellow -= *black;
      }
    } else {
#line 2055
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
    {
#line 2067
    tmp___14 = dsc_stricmp(name, "Cyan");
    }
#line 2067
    if (tmp___14 == 0) {
#line 2068
      *cyan = (float )1.0;
#line 2069
      tmp___4 = (float )0.0;
#line 2069
      *black = tmp___4;
#line 2069
      tmp___3 = tmp___4;
#line 2069
      *yellow = tmp___3;
#line 2069
      *magenta = tmp___3;
    } else {
      {
#line 2071
      tmp___13 = dsc_stricmp(name, "Magenta");
      }
#line 2071
      if (tmp___13 == 0) {
#line 2072
        *magenta = (float )1.0;
#line 2073
        tmp___6 = (float )0.0;
#line 2073
        *black = tmp___6;
#line 2073
        tmp___5 = tmp___6;
#line 2073
        *yellow = tmp___5;
#line 2073
        *cyan = tmp___5;
      } else {
        {
#line 2075
        tmp___12 = dsc_stricmp(name, "Yellow");
        }
#line 2075
        if (tmp___12 == 0) {
#line 2076
          *yellow = (float )1.0;
#line 2077
          tmp___8 = (float )0.0;
#line 2077
          *black = tmp___8;
#line 2077
          tmp___7 = tmp___8;
#line 2077
          *magenta = tmp___7;
#line 2077
          *cyan = tmp___7;
        } else {
          {
#line 2079
          tmp___11 = dsc_stricmp(name, "Black");
          }
#line 2079
          if (tmp___11 == 0) {
#line 2080
            *black = (float )1.0;
#line 2081
            tmp___10 = (float )0.0;
#line 2081
            *magenta = tmp___10;
#line 2081
            tmp___9 = tmp___10;
#line 2081
            *yellow = tmp___9;
#line 2081
            *cyan = tmp___9;
          } else {
#line 2084
            code = -1;
          }
        }
      }
    }
  }
#line 2087
  return (code);
}
}
#line 2090 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/epstool.c"
char const   *epswarn_prolog[135]  = 
#line 2090
  {      "%!\n",      "% This code is wrapped around an EPS file to partly test if it complies\n",      "% with the EPS specfication.\n",      "\n", 
        "/eps_warn_file (%stdout) (w) file def\n",      "\n",      "globaldict begin /eps_warn_ok true def end\n",      "\n", 
        "/eps_write_only { % name string -- name\n",      "  eps_warn_file exch writestring\n",      "  eps_warn_file ( /) writestring\n",      "  dup eps_warn_file exch 32 string cvs writestring\n", 
        "  eps_warn_file (\\n) writestring \n",      "  eps_warn_file flushfile\n",      "} bind def\n",      "\n", 
        "/eps_write { % name string -- name\n",      "  eps_write_only\n",      "  //globaldict /eps_warn_ok false put\n",      "} bind def\n", 
        "\n",      "/eps_warn { % name --\n",      "  (EPSWARN FAIL: EPS file must not use) \n",      "  eps_write\n", 
        "  //systemdict exch get exec\n",      "} bind def\n",      "\n",      "% Prohibited operators in systemdict\n", 
        "/banddevice {/banddevice eps_warn} def\n",      "/clear {/clear eps_warn} def\n",      "/cleardictstack {/cleardictstack eps_warn} def\n",      "/copypage {/copypage eps_warn} def\n", 
        "/erasepage {/erasepage eps_warn} def\n",      "/exitserver {/exitserver eps_warn} def % this won\'t work - exitserver is in serverdict\n",      "/serverdict {/serverdict eps_warn} def % so use this to provide warnings instead\n",      "/statusdict {/statusdict eps_warn} def\n", 
        "/framedevice {/framedevice eps_warn} def\n",      "/grestoreall {/grestoreall eps_warn} def\n",      "/initclip {/initclip eps_warn} def\n",      "/initgraphics {/initgraphics eps_warn} def\n", 
        "/initmatrix {/initmatrix eps_warn} def\n",      "/renderbands {/renderbands eps_warn} def\n",      "/setglobal {/setglobal eps_warn} def\n",      "/setpagedevice {/setpagedevice eps_warn} def\n", 
        "/setpageparams {/setpageparams eps_warn} def\n",      "/setshared {/setshared eps_warn} def\n",      "/startjob {/startjob eps_warn} def\n",      "% If quit is executed, then epswarn_check will never be run.\n", 
        "/quit {\n",      "  % systemdict /quit doesn\'t work when it has been redefined in userdict\n",      "  /quit (EPSWARN FAIL: EPS file must not use) eps_write\n",      "  //globaldict /eps_warn_ok false put\n", 
        "  //systemdict begin quit \n",      "} def\n",      "\n",      "% These page sizes are defined in userdict, not systemdict\n", 
        "/eps_pagesize_warn {\n",      "  (EPSWARN FAIL: EPS file must not set page size:)\n",      "  eps_write pop\n",      "} def\n", 
        "/11x17 {/11x17 eps_pagesize_warn} def\n",      "/a3 {/a3 eps_pagesize_warn} def\n",      "/a4 {/a4 eps_pagesize_warn} def\n",      "/a4small {/a4small eps_pagesize_warn} def\n", 
        "/a5 {/a5 eps_pagesize_warn} def\n",      "/ledger {/ledger eps_pagesize_warn} def\n",      "/legal {/legal eps_pagesize_warn} def\n",      "/letter {/letter eps_pagesize_warn} def\n", 
        "/lettersmall {/lettersmall eps_pagesize_warn} def\n",      "/note {/note eps_pagesize_warn} def\n",      "\n",      "% These operators can only be used if the parameter\n", 
        "% is saved and restored afterwards, or if setting\n",      "% them takes into account their previous value.\n",      "% For example \'matrix setmatrix\' is not permitted,\n",      "% but \'matrix current matrix setmatrix\' is allowed.\n", 
        "/eps_warntwo {\n",      "  (EPSWARN WARNING: EPS file should be careful using) \n",      "  eps_write_only\n",      "  //systemdict exch get exec\n", 
        "} def\n",      "/nulldevice {/nulldevice eps_warntwo} def % can\'t test this\n",      "/setgstate {/setgstate eps_warntwo} def % can\'t test this\n",      "/sethalftone {/sethalftone eps_warntwo} def\n", 
        "/setmatrix {/setmatrix eps_warntwo} def\n",      "/setscreen {/setscreen eps_warntwo} def\n",      "/settransfer {/settransfer eps_warntwo} def\n",      "/setcolortransfer {/setcolortransfer eps_warntwo} def\n", 
        "\n",      "% Take snapshot of some items\n",      "count /eps_count exch def\n",      "countdictstack /eps_countdictstack exch def\n", 
        "currentpagedevice /PageCount get /eps_pagecount exch def\n",      "/eps_showpage_count 0 def\n",      "\n",      "\n", 
        "/epswarn_check_write { % string --\n",      "  eps_warn_file exch writestring\n",      "  eps_warn_file flushfile\n",      "  //globaldict /eps_warn_ok false put\n", 
        "} def\n",      "\n",      "/epswarn_check {\n",      "  % count\n", 
        "  count eps_count ne {\n",      "    (EPSWARN FAIL: EPS file altered operand stack count\\n) epswarn_check_write \n",      "  } if\n",      "  //systemdict /clear get exec\n", 
        "  % countdictstack\n",      "  countdictstack eps_countdictstack ne {\n",      "   (EPSWARN FAIL: EPS file altered dictionary stack count\\n) \n",      "   epswarn_check_write\n", 
        "  } if\n",      "  countdictstack eps_countdictstack sub {end} repeat\n",      "  % real page count\n",      "  currentpagedevice /PageCount get eps_pagecount ne {\n", 
        "    (EPSWARN FAIL: EPS file forcibly output a page\\n) epswarn_check_write\n",      "  } if\n",      "  % showpage count\n",      "  eps_showpage_count 1 gt {\n", 
        "    (EPSWARN FAIL: EPS file used showpage more than once\\n) epswarn_check_write\n",      "  } if\n",      "} def\n",      "\n", 
        "% EPS files are normally encapsulated inside a save/restore\n",      "save /epswarn_save exch def\n",      "\n",      "% redefine showpage, and count how many times it is called\n", 
        "/showpage { userdict dup /eps_showpage_count get 1 add \n",      "  /eps_showpage_count exch put \n",      "} def\n",      "\n", 
        "% Now for something to test this\n",      "\n",      (char const   *)((void *)0)};
#line 2227 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/epstool.c"
char const   epswarn_epilog[240]  = 
#line 2227
  {      (char const   )'%',      (char const   )'!',      (char const   )'\n',      (char const   )'%', 
        (char const   )' ',      (char const   )'C',      (char const   )'h',      (char const   )'e', 
        (char const   )'c',      (char const   )'k',      (char const   )' ',      (char const   )'t', 
        (char const   )'h',      (char const   )'a',      (char const   )'t',      (char const   )' ', 
        (char const   )'a',      (char const   )'l',      (char const   )'l',      (char const   )' ', 
        (char const   )'i',      (char const   )'s',      (char const   )' ',      (char const   )'w', 
        (char const   )'e',      (char const   )'l',      (char const   )'l',      (char const   )'\n', 
        (char const   )'e',      (char const   )'p',      (char const   )'s',      (char const   )'w', 
        (char const   )'a',      (char const   )'r',      (char const   )'n',      (char const   )'_', 
        (char const   )'c',      (char const   )'h',      (char const   )'e',      (char const   )'c', 
        (char const   )'k',      (char const   )'\n',      (char const   )'%',      (char const   )'e', 
        (char const   )'p',      (char const   )'s',      (char const   )'w',      (char const   )'a', 
        (char const   )'r',      (char const   )'n',      (char const   )'_',      (char const   )'s', 
        (char const   )'a',      (char const   )'v',      (char const   )'e',      (char const   )' ', 
        (char const   )'r',      (char const   )'e',      (char const   )'s',      (char const   )'t', 
        (char const   )'o',      (char const   )'r',      (char const   )'e',      (char const   )'\n', 
        (char const   )'/',      (char const   )'/',      (char const   )'g',      (char const   )'l', 
        (char const   )'o',      (char const   )'b',      (char const   )'a',      (char const   )'l', 
        (char const   )'d',      (char const   )'i',      (char const   )'c',      (char const   )'t', 
        (char const   )' ',      (char const   )'/',      (char const   )'e',      (char const   )'p', 
        (char const   )'s',      (char const   )'_',      (char const   )'w',      (char const   )'a', 
        (char const   )'r',      (char const   )'n',      (char const   )'_',      (char const   )'o', 
        (char const   )'k',      (char const   )' ',      (char const   )'g',      (char const   )'e', 
        (char const   )'t',      (char const   )' ',      (char const   )'n',      (char const   )'o', 
        (char const   )'t',      (char const   )' ',      (char const   )'\n',      (char const   )' ', 
        (char const   )'{',      (char const   )'e',      (char const   )'p',      (char const   )'s', 
        (char const   )'_',      (char const   )'w',      (char const   )'a',      (char const   )'r', 
        (char const   )'n',      (char const   )'_',      (char const   )'f',      (char const   )'i', 
        (char const   )'l',      (char const   )'e',      (char const   )' ',      (char const   )'(', 
        (char const   )'\n',      (char const   )'E',      (char const   )'P',      (char const   )'S', 
        (char const   )'W',      (char const   )'A',      (char const   )'R',      (char const   )'N', 
        (char const   )' ',      (char const   )'F',      (char const   )'A',      (char const   )'I', 
        (char const   )'L',      (char const   )'\\',      (char const   )'n',      (char const   )')', 
        (char const   )' ',      (char const   )'w',      (char const   )'r',      (char const   )'i', 
        (char const   )'t',      (char const   )'e',      (char const   )'s',      (char const   )'t', 
        (char const   )'r',      (char const   )'i',      (char const   )'n',      (char const   )'g', 
        (char const   )'}',      (char const   )' ',      (char const   )'\n',      (char const   )' ', 
        (char const   )'{',      (char const   )'e',      (char const   )'p',      (char const   )'s', 
        (char const   )'_',      (char const   )'w',      (char const   )'a',      (char const   )'r', 
        (char const   )'n',      (char const   )'_',      (char const   )'f',      (char const   )'i', 
        (char const   )'l',      (char const   )'e',      (char const   )' ',      (char const   )'(', 
        (char const   )'\n',      (char const   )'E',      (char const   )'P',      (char const   )'S', 
        (char const   )'W',      (char const   )'A',      (char const   )'R',      (char const   )'N', 
        (char const   )' ',      (char const   )'P',      (char const   )'A',      (char const   )'S', 
        (char const   )'S',      (char const   )'\\',      (char const   )'n',      (char const   )')', 
        (char const   )' ',      (char const   )'w',      (char const   )'r',      (char const   )'i', 
        (char const   )'t',      (char const   )'e',      (char const   )'s',      (char const   )'t', 
        (char const   )'r',      (char const   )'i',      (char const   )'n',      (char const   )'g', 
        (char const   )'}',      (char const   )' ',      (char const   )'\n',      (char const   )' ', 
        (char const   )'i',      (char const   )'f',      (char const   )'e',      (char const   )'l', 
        (char const   )'s',      (char const   )'e',      (char const   )'\n',      (char const   )'s', 
        (char const   )'y',      (char const   )'s',      (char const   )'t',      (char const   )'e', 
        (char const   )'m',      (char const   )'d',      (char const   )'i',      (char const   )'c', 
        (char const   )'t',      (char const   )' ',      (char const   )'b',      (char const   )'e', 
        (char const   )'g',      (char const   )'i',      (char const   )'n',      (char const   )' ', 
        (char const   )'%',      (char const   )' ',      (char const   )'s',      (char const   )'o', 
        (char const   )' ',      (char const   )'q',      (char const   )'u',      (char const   )'i', 
        (char const   )'t',      (char const   )' ',      (char const   )'w',      (char const   )'o', 
        (char const   )'r',      (char const   )'k',      (char const   )'s',      (char const   )'.', 
        (char const   )'.',      (char const   )'.',      (char const   )'\n',      (char const   )'\000'};
#line 2241 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/epstool.c"
static int epstool_test(Doc *doc , OPT *opt ) 
{ 
  GFile *f ;
  int code ;
  char tpsname[256] ;
  char command[2048] ;
  unsigned int len ;
  FILE *testfile ;
  char testname[256] ;
  CDSCBBOX bbox ;
  CDSCFBBOX hires_bbox ;
  BOOL found_error ;
  BOOL found_warning ;
  BOOL found_pass ;
  BOOL bbox_valid ;
  char line[256] ;
  int i ;
  BOOL dsc_error___0 ;
  BOOL dsc_warning ;
  size_t tmp ;
  unsigned int tmp___0 ;
  size_t tmp___1 ;
  unsigned int tmp___2 ;
  char const   *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  char *tmp___8 ;

  {
#line 2245
  code = 0;
#line 2249
  testfile = (FILE *)((void *)0);
#line 2253
  found_error = 0;
#line 2254
  found_warning = 0;
#line 2255
  found_pass = 0;
#line 2256
  bbox_valid = 0;
#line 2259
  dsc_error___0 = 0;
#line 2260
  dsc_warning = 0;
#line 2262
  if (doc->dsc) {
#line 2263
    dsc_error___0 = (int )(doc->dsc)->worst_error == 2;
#line 2264
    dsc_warning = (int )(doc->dsc)->worst_error == 1;
  }
  {
#line 2268
  f = app_temp_gfile(doc->app, tpsname, (int )(sizeof(tpsname) / sizeof(char )));
  }
#line 2268
  if ((unsigned long )f == (unsigned long )((GFile *)((void *)0))) {
    {
#line 2270
    app_csmsgf(doc->app, "Can\'t create temporary ps file \"%s\"\n", tpsname);
    }
#line 2273
    return (-1);
  }
#line 2275
  i = 0;
  {
#line 2275
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2275
    if (! epswarn_prolog[i]) {
#line 2275
      goto while_break;
    }
    {
#line 2276
    tmp = strlen(epswarn_prolog[i]);
#line 2276
    len = (unsigned int )((int )tmp);
    }
#line 2277
    if (! code) {
      {
#line 2277
      tmp___0 = gfile_write(f, (void const   *)epswarn_prolog[i], len);
      }
#line 2277
      if (len != tmp___0) {
#line 2278
        code = -1;
      }
    }
#line 2275
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2280
  code = copy_page_nosave(doc, f, 0);
#line 2281
  tmp___1 = strlen(epswarn_epilog);
#line 2281
  len = (unsigned int )((int )tmp___1);
#line 2282
  tmp___2 = gfile_write(f, (void const   *)(epswarn_epilog), len);
  }
#line 2282
  if (len != tmp___2) {
#line 2283
    code = -1;
  }
  {
#line 2284
  gfile_close(f);
  }
#line 2285
  if (code != 0) {
#line 2286
    if (! (debug & 1)) {
      {
#line 2287
      unlink((char const   *)(tpsname));
      }
    }
#line 2288
    return (-1);
  }
  {
#line 2291
  testfile = app_temp_file(doc->app, testname, (int )(sizeof(testname) / sizeof(char )));
  }
#line 2291
  if ((unsigned long )testfile == (unsigned long )((FILE *)((void *)0))) {
    {
#line 2293
    app_csmsgf(doc->app, "Can\'t create temporary file \"%s\"\n", testname);
    }
#line 2295
    if (! (debug & 1)) {
      {
#line 2296
      unlink((char const   *)(tpsname));
      }
    }
#line 2297
    return (-1);
  }
  {
#line 2299
  fclose(testfile);
#line 2300
  testfile = (FILE *)((void *)0);
  }
#line 2303
  if (opt->quiet) {
#line 2303
    tmp___3 = "-dQUIET";
  } else {
#line 2303
    tmp___3 = "";
  }
  {
#line 2303
  snprintf((char */* __restrict  */)(command), sizeof(command) / sizeof(char ), (char const   */* __restrict  */)"\"%s\" %s -dNOEPS -dNOPAUSE -dBATCH -dNODISPLAY %s \"%s\"",
           opt->gs, tmp___3, opt->gsargs, tpsname);
  }
#line 2307
  if (! opt->quiet) {
    {
#line 2308
    app_csmsgf(doc->app, "%s\n", command);
    }
  }
  {
#line 2309
  tmp___4 = fileno(stderr);
#line 2309
  code = exec_program(command, -1, -1, tmp___4, (char const   *)((void *)0), (char const   *)(testname),
                      (char const   *)((void *)0));
  }
#line 2311
  if (code != 0) {
    {
#line 2312
    app_csmsgf(doc->app, "Ghostscript failed to interpret file\n");
    }
  }
#line 2315
  if (! (debug & 1)) {
    {
#line 2316
    unlink((char const   *)(tpsname));
    }
  }
#line 2319
  if (code == 0) {
    {
#line 2320
    testfile = fopen((char const   */* __restrict  */)(testname), (char const   */* __restrict  */)"rb");
    }
#line 2320
    if ((unsigned long )testfile == (unsigned long )((FILE *)((void *)0))) {
      {
#line 2321
      app_csmsgf(doc->app, "Can\'t open temporary file \"%s\"\n", testname);
#line 2324
      code = -1;
      }
    }
  }
#line 2328
  if (code == 0) {
    {
#line 2329
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 2329
      tmp___8 = fgets((char */* __restrict  */)(line), (int )sizeof(line), (FILE */* __restrict  */)testfile);
      }
#line 2329
      if (! ((unsigned long )tmp___8 != (unsigned long )((void *)0))) {
#line 2329
        goto while_break___0;
      }
#line 2330
      if (! opt->quiet) {
        {
#line 2331
        app_msgf(doc->app, "%s", line);
        }
      }
      {
#line 2332
      tmp___7 = strncmp((char const   *)(line), "EPSWARN FAIL: ", (size_t )14);
      }
#line 2332
      if (tmp___7 == 0) {
#line 2333
        found_error = 1;
      } else {
        {
#line 2334
        tmp___6 = strncmp((char const   *)(line), "EPSWARN WARNING: ", (size_t )17);
        }
#line 2334
        if (tmp___6 == 0) {
#line 2335
          found_warning = 1;
        } else {
          {
#line 2336
          tmp___5 = strncmp((char const   *)(line), "EPSWARN PASS", (size_t )12);
          }
#line 2336
          if (tmp___5 == 0) {
#line 2337
            found_pass = 1;
          }
        }
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 2340
  if (testfile) {
    {
#line 2341
    fclose(testfile);
    }
  }
#line 2342
  if (! (debug & 1)) {
    {
#line 2343
    unlink((char const   *)(testname));
    }
  }
#line 2344
  if (! opt->quiet) {
    {
#line 2345
    app_csmsg(doc->app, "\n");
    }
  }
#line 2347
  if (code == 0) {
#line 2347
    if (doc->dsc) {
#line 2347
      if ((doc->dsc)->bbox) {
        {
#line 2349
        f = app_temp_gfile(doc->app, tpsname, (int )(sizeof(tpsname) / sizeof(char )));
        }
#line 2349
        if ((unsigned long )f == (unsigned long )((GFile *)((void *)0))) {
          {
#line 2351
          app_csmsgf(doc->app, "Can\'t create temporary ps file \"%s\"\n", tpsname);
          }
#line 2354
          return (-1);
        }
        {
#line 2356
        code = copy_page_temp(doc, f, 0);
#line 2357
        gfile_close(f);
        }
#line 2358
        if (code != 0) {
#line 2359
          if (! (debug & 1)) {
            {
#line 2360
            unlink((char const   *)(tpsname));
            }
          }
#line 2361
          return (-1);
        }
        {
#line 2363
        code = calculate_bbox(doc, opt, (char const   *)(tpsname), & bbox, & hires_bbox);
        }
#line 2364
        if (! opt->quiet) {
          {
#line 2365
          app_csmsg(doc->app, "\n");
          }
        }
#line 2366
        if (code == 0) {
#line 2367
          if (bbox.llx >= ((doc->dsc)->bbox)->llx - 1) {
#line 2367
            if (bbox.lly >= ((doc->dsc)->bbox)->lly - 1) {
#line 2367
              if (bbox.urx <= ((doc->dsc)->bbox)->urx + 1) {
#line 2367
                if (bbox.ury <= ((doc->dsc)->bbox)->ury + 1) {
#line 2371
                  bbox_valid = 1;
                }
              }
            }
          }
#line 2373
          if (! opt->quiet) {
            {
#line 2374
            app_csmsgf(doc->app, "File has   %%%%BoundingBox: %d %d %d %d\n", ((doc->dsc)->bbox)->llx,
                       ((doc->dsc)->bbox)->lly, ((doc->dsc)->bbox)->urx, ((doc->dsc)->bbox)->ury);
#line 2378
            app_csmsgf(doc->app, "Correct is %%%%BoundingBox: %d %d %d %d\n", bbox.llx,
                       bbox.lly, bbox.urx, bbox.ury);
            }
#line 2381
            if (! bbox_valid) {
              {
#line 2382
              app_csmsgf(doc->app, "File bounding box needs to be larger\n");
              }
            }
          }
        } else
#line 2387
        if (! opt->quiet) {
          {
#line 2388
          app_csmsgf(doc->app, "Failed to calculate bounding box\n");
          }
        }
#line 2393
        if (! (debug & 1)) {
          {
#line 2394
          unlink((char const   *)(tpsname));
          }
        }
      } else {
#line 2347
        goto _L___0;
      }
    } else {
#line 2347
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 2397
  if (! opt->quiet) {
    {
#line 2398
    app_csmsgf(doc->app, "Missing %%%%BoundingBox\n");
    }
  }
#line 2402
  if (found_error) {
#line 2405
    code = -1;
  } else
#line 2402
  if (! found_pass) {
#line 2405
    code = -1;
  } else
#line 2402
  if (! bbox_valid) {
#line 2405
    code = -1;
  } else
#line 2402
  if (dsc_error___0) {
#line 2405
    code = -1;
  } else
#line 2402
  if (dsc_warning) {
#line 2405
    code = -1;
  } else
#line 2402
  if (! doc->dsc) {
#line 2405
    code = -1;
  } else
#line 2402
  if (! (doc->dsc)->epsf) {
#line 2405
    code = -1;
  }
#line 2407
  if (! opt->quiet) {
#line 2408
    if (found_warning) {
      {
#line 2409
      app_csmsgf(doc->app, "File used operators that sometimes cause problems in an EPS file.\n");
      }
    }
#line 2410
    if (found_error) {
      {
#line 2411
      app_csmsgf(doc->app, "File used PostScript operators that are prohibited in an EPS file.\n");
      }
    }
#line 2412
    if (found_pass) {
      {
#line 2413
      app_csmsgf(doc->app, "PostScript appears well behaved.\n");
      }
    }
#line 2414
    if (doc->dsc) {
#line 2414
      if ((doc->dsc)->epsf) {
        {
#line 2415
        app_csmsgf(doc->app, "File claims to be EPS.\n");
        }
      } else {
        {
#line 2417
        app_csmsgf(doc->app, "File is not EPS.\n");
        }
      }
    } else {
      {
#line 2417
      app_csmsgf(doc->app, "File is not EPS.\n");
      }
    }
  }
#line 2420
  if (code != 0) {
    {
#line 2421
    fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"FAIL: File does not comply with EPS specification.\n");
    }
  } else {
    {
#line 2423
    fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"PASS: File appears to be well behaved EPS.\n");
    }
  }
#line 2425
  return (code);
}
}
#line 2428 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/epstool.c"
static void epstool_dump_fn(void *caller_data , char const   *str ) 
{ 


  {
  {
#line 2430
  fputs((char const   */* __restrict  */)str, (FILE */* __restrict  */)stdout);
  }
#line 2431
  return;
}
}
#line 2442 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/epstool.c"
int app_platform_init(GSview *a ) 
{ 


  {
#line 2445
  return (0);
}
}
#line 2448 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/epstool.c"
int app_platform_finish(GSview *a ) 
{ 


  {
#line 2451
  return (0);
}
}
#line 2454 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/epstool.c"
int app_lock(GSview *a ) 
{ 


  {
#line 2457
  return (0);
}
}
#line 2460 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/epstool.c"
int app_unlock(GSview *a ) 
{ 


  {
#line 2463
  return (0);
}
}
#line 2466 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/epstool.c"
void app_log(char const   *str , int len ) 
{ 


  {
  {
#line 2469
  fwrite((void const   */* __restrict  */)str, (size_t )1, (size_t )len, (FILE */* __restrict  */)stdout);
  }
#line 2470
  return;
}
}
#line 2472 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/epstool.c"
int cs_to_narrow(char *nstr , int nlen , char const   *wstr , int wlen ) 
{ 
  int tmp ;

  {
  {
#line 2478
  tmp = char_to_narrow(nstr, nlen, wstr, wlen);
  }
#line 2478
  return (tmp);
}
}
#line 2482 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/epstool.c"
int narrow_to_cs(char *wstr , int wlen , char const   *nstr , int nlen ) 
{ 
  int tmp ;

  {
  {
#line 2488
  tmp = narrow_to_char(wstr, wlen, nstr, nlen);
  }
#line 2488
  return (tmp);
}
}
#line 2492 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/epstool.c"
int get_dsc_response(GSview *app , char const   *str ) 
{ 


  {
  {
#line 2494
  app_csmsgf(app, "\n%s\n", str);
  }
#line 2495
  return (0);
}
}
#line 2498 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/epstool.c"
int load_string(GSview *a , int id , char *buf , int len ) 
{ 
  char msg[256] ;
  char const   *s ;
  int reslen ;
  int dscmsg ;
  size_t tmp ;
  size_t tmp___0 ;
  int tmp___1 ;

  {
#line 2502
  s = (char const   *)((void *)0);
#line 2504
  dscmsg = (id - 2400) / 2;
#line 2505
  if (buf) {
#line 2505
    if (len) {
#line 2506
      *(buf + 0) = (char )'\000';
    }
  }
#line 2508
  if (a) {
#line 2508
    if (dscmsg >= 0) {
#line 2508
      if (dscmsg <= 15) {
#line 2510
        if (((id - 2400) & 1) == 0) {
#line 2511
          s = (char const   *)dsc_message[dscmsg];
        } else {
#line 2513
          s = "";
        }
      } else {
#line 2508
        goto _L___0;
      }
    } else {
#line 2508
      goto _L___0;
    }
  } else {
    _L___0: /* CIL Label */ 
    {
#line 2517
    if (id == 2253) {
#line 2517
      goto case_2253;
    }
#line 2520
    if (id == 2250) {
#line 2520
      goto case_2250;
    }
#line 2523
    if (id == 2251) {
#line 2523
      goto case_2251;
    }
#line 2526
    if (id == 2252) {
#line 2526
      goto case_2252;
    }
#line 2516
    goto switch_break;
    case_2253: /* CIL Label */ 
#line 2518
    s = "%sAt line %d:";
#line 2519
    goto switch_break;
    case_2250: /* CIL Label */ 
#line 2521
    s = "DSC Information\n";
#line 2522
    goto switch_break;
    case_2251: /* CIL Label */ 
#line 2524
    s = "DSC Warning\n";
#line 2525
    goto switch_break;
    case_2252: /* CIL Label */ 
#line 2527
    s = "DSC Error\n";
#line 2528
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
#line 2531
  if ((unsigned long )s == (unsigned long )((void *)0)) {
    {
#line 2532
    snprintf((char */* __restrict  */)(msg), sizeof(msg), (char const   */* __restrict  */)"String %d\n",
             id);
#line 2533
    s = (char const   *)(msg);
    }
  }
  {
#line 2536
  tmp = strlen(s);
#line 2536
  reslen = narrow_to_cs((char *)((void *)0), 0, s, (int )tmp + 1);
  }
#line 2537
  if (reslen > len) {
#line 2538
    return (reslen);
  }
  {
#line 2539
  tmp___0 = strlen(s);
#line 2539
  tmp___1 = narrow_to_cs(buf, len, s, (int )tmp___0 + 1);
  }
#line 2539
  return (tmp___1);
}
}
#line 2542 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/epstool.c"
int app_msg_box(GSview *a , char const   *str , int icon ) 
{ 


  {
  {
#line 2544
  app_csmsgf(a, "%s\n", str);
  }
#line 2545
  return (0);
}
}
#line 2548 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/epstool.c"
int gssrv_request(GSSRV *s , GSREQ *reqnew ) 
{ 


  {
#line 2551
  return (-1);
}
}
#line 2554 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/epstool.c"
int pagecache_unref_all(GSview *a ) 
{ 


  {
#line 2557
  return (0);
}
}
#line 2561 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/epstool.c"
void doc_savestat(Doc *doc ) 
{ 


  {
#line 2564
  return;
}
}
#line 2566 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/epstool.c"
int image_platform_init(IMAGE *img ) 
{ 


  {
#line 2569
  return (0);
}
}
#line 2572 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/epstool.c"
unsigned int image_platform_format(unsigned int format ) 
{ 


  {
#line 2575
  return (format);
}
}
#line 2739 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/epstool.c"
static int exec_program(char *command , int hstdin , int hstdout , int hstderr , char const   *stdin_name ,
                        char const   *stdout_name , char const   *stderr_name ) 
{ 
  int code ;
  int hChildStdinRd ;
  int hChildStdoutWr ;
  int hChildStderrWr ;
  int handle ;
  pid_t pid ;
  int exitcode ;
  char *argv[65] ;
  int argc ;
  char *args ;
  char *d ;
  char *e ;
  char *p ;
  size_t tmp ;
  void *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  int *tmp___6 ;
  int *tmp___7 ;
  int *tmp___8 ;
  int tmp___9 ;

  {
  {
#line 2744
  code = 0;
#line 2745
  hChildStdinRd = -1;
#line 2746
  hChildStdoutWr = -1;
#line 2747
  hChildStderrWr = -1;
#line 2753
  argc = 0;
#line 2757
  memset((void *)(argv), 0, sizeof(argv));
#line 2758
  argc = 0;
#line 2759
  tmp = strlen((char const   *)command);
#line 2759
  tmp___0 = malloc(tmp + 1UL);
#line 2759
  args = (char *)tmp___0;
  }
#line 2760
  if ((unsigned long )args == (unsigned long )((char *)((void *)0))) {
#line 2761
    return (-1);
  }
#line 2762
  p = command;
#line 2763
  d = args;
  {
#line 2764
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2764
    if (! *p) {
#line 2764
      goto while_break;
    }
#line 2766
    if (argc >= 63) {
      {
#line 2767
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Too many arguments\n");
#line 2768
      free((void *)args);
      }
#line 2769
      return (-1);
    }
#line 2772
    e = d;
    {
#line 2773
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 2773
      if (*p) {
#line 2773
        if (! ((int )*p != 32)) {
#line 2773
          goto while_break___0;
        }
      } else {
#line 2773
        goto while_break___0;
      }
#line 2774
      if ((int )*p == 34) {
#line 2777
        p ++;
        {
#line 2778
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 2778
          if (*p) {
#line 2778
            if (! ((int )*p != 34)) {
#line 2778
              goto while_break___1;
            }
          } else {
#line 2778
            goto while_break___1;
          }
#line 2779
          tmp___1 = d;
#line 2779
          d ++;
#line 2779
          tmp___2 = p;
#line 2779
          p ++;
#line 2779
          *tmp___1 = *tmp___2;
        }
        while_break___1: /* CIL Label */ ;
        }
      } else {
#line 2782
        tmp___3 = d;
#line 2782
        d ++;
#line 2782
        *tmp___3 = *p;
      }
#line 2783
      if (*p) {
#line 2784
        p ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 2786
    tmp___4 = d;
#line 2786
    d ++;
#line 2786
    *tmp___4 = (char )'\000';
#line 2787
    tmp___5 = argc;
#line 2787
    argc ++;
#line 2787
    argv[tmp___5] = e;
    {
#line 2789
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 2789
      if (*p) {
#line 2789
        if (! ((int )*p == 32)) {
#line 2789
          goto while_break___2;
        }
      } else {
#line 2789
        goto while_break___2;
      }
#line 2790
      p ++;
    }
    while_break___2: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2792
  argv[argc] = (char *)((void *)0);
#line 2794
  pid = fork();
  }
#line 2795
  if (pid == -1) {
    {
#line 2797
    tmp___6 = __errno_location();
#line 2797
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Failed to fork, error=%d\n",
            *tmp___6);
    }
#line 2798
    return (-1);
  } else
#line 2800
  if (pid == 0) {
#line 2803
    if (code == 0) {
#line 2803
      if (hstdin != -1) {
        {
#line 2804
        hChildStdinRd = dup2(hstdin, 0);
        }
#line 2805
        if (hChildStdinRd == -1) {
#line 2806
          code = -1;
        }
      }
    }
#line 2808
    if (code == 0) {
#line 2808
      if (hstdout != -1) {
        {
#line 2809
        hChildStdoutWr = dup2(hstdout, 1);
        }
#line 2810
        if (hChildStdoutWr == -1) {
#line 2811
          code = -1;
        }
      }
    }
#line 2813
    if (code == 0) {
#line 2813
      if (hstderr != -1) {
        {
#line 2814
        hChildStderrWr = dup2(hstderr, 2);
        }
#line 2815
        if (hChildStderrWr == -1) {
#line 2816
          code = -1;
        }
      }
    }
#line 2818
    if (code == 0) {
#line 2818
      if (stdin_name) {
#line 2818
        if (hChildStdinRd == -1) {
          {
#line 2819
          handle = open(stdin_name, 0);
#line 2820
          hChildStdinRd = dup2(handle, 0);
          }
#line 2821
          if (handle != -1) {
            {
#line 2822
            close(handle);
            }
          }
#line 2823
          if (hChildStdinRd == -1) {
#line 2824
            code = -1;
          }
        }
      }
    }
#line 2826
    if (code == 0) {
#line 2826
      if (stdout_name) {
#line 2826
        if (hChildStdoutWr == -1) {
          {
#line 2827
          handle = open(stdout_name, 65, 438);
#line 2828
          hChildStdoutWr = dup2(handle, 1);
          }
#line 2829
          if (handle != -1) {
            {
#line 2830
            close(handle);
            }
          }
#line 2831
          if (hChildStdoutWr == -1) {
#line 2832
            code = -1;
          }
        }
      }
    }
#line 2834
    if (code == 0) {
#line 2834
      if (stderr_name) {
#line 2834
        if (hChildStderrWr == -1) {
          {
#line 2835
          handle = open(stderr_name, 65, 438);
#line 2836
          hChildStderrWr = dup2(handle, 2);
          }
#line 2837
          if (handle != -1) {
            {
#line 2838
            close(handle);
            }
          }
#line 2839
          if (hChildStderrWr == -1) {
#line 2840
            code = -1;
          }
        }
      }
    }
#line 2843
    if (code) {
      {
#line 2844
      tmp___7 = __errno_location();
#line 2844
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Failed to open stdin/out/err, error=%d\n",
              *tmp___7);
      }
#line 2845
      if (hChildStdinRd) {
        {
#line 2846
        close(hChildStdinRd);
        }
      }
#line 2847
      if (hChildStdoutWr) {
        {
#line 2848
        close(hChildStdoutWr);
        }
      }
#line 2849
      if (hChildStderrWr) {
        {
#line 2850
        close(hChildStderrWr);
        }
      }
      {
#line 2851
      exit(1);
      }
    }
    {
#line 2855
    tmp___9 = execvp((char const   *)argv[0], (char * const  *)(argv));
    }
#line 2855
    if (tmp___9 == -1) {
      {
#line 2856
      tmp___8 = __errno_location();
#line 2856
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Failed to execute ghostscript, error=%d\n",
              *tmp___8);
#line 2857
      exit(1);
      }
    }
  }
  {
#line 2862
  free((void *)args);
#line 2863
  wait((union wait *)(& exitcode));
  }
#line 2864
  return (exitcode);
}
}
#line 564 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) getenv)(char const   *__name ) ;
#line 620
extern int ( __attribute__((__nonnull__(1))) mkstemp)(char *__template ) ;
#line 23 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/capp.h"
int app_gssrv_request(GSview *a , GSREQ *reqnew ) ;
#line 24
int app_plsrv_request(GSview *a , GSREQ *reqnew ) ;
#line 27
int app_ref(GSview *a ) ;
#line 29
GSDLL **app_dll(GSview *a ) ;
#line 30
PLDLL **app_pldll(GSview *a ) ;
#line 31
Doc **app_docs(GSview *a ) ;
#line 32
OPTION *app_option(GSview *a ) ;
#line 33
PAGECACHE **app_pagecache(GSview *a ) ;
#line 34
BOOL app_multithread(GSview *a ) ;
#line 38
void app_update_last_files(GSview *a , char const   *filename ) ;
#line 39
char const   *app_last_files(GSview *a , int i ) ;
#line 40
int app_read_last_files(GSview *a , char const   *filename ) ;
#line 41
int app_write_last_files(GSview *a , char const   *filename ) ;
#line 43
int zlib_load(GSview *a ) ;
#line 44
void zlib_free(GSview *a ) ;
#line 45
int zlib_uncompress(GSview *app , GFile *outfile , char const   *filename ) ;
#line 58
int bzip2_load(GSview *a ) ;
#line 59
void bzip2_free(GSview *a ) ;
#line 60
int bzip2_uncompress(GSview *app , GFile *outfile , char const   *filename ) ;
#line 77
int app_msg_len(GSview *a , char const   *str , int len ) ;
#line 78
int app_msg_len_nolock(GSview *a , char const   *str , int len ) ;
#line 81
int app_csmsg_len(GSview *a , char const   *wstr , int wlen ) ;
#line 82
int app_csmsg_len_nolock(GSview *a , char const   *wstr , int wlen ) ;
#line 92
char const   szAppName[7] ;
#line 204
float app_get_points(GSview *a , char const   *str ) ;
#line 205
void app_put_points(GSview *a , UNIT unit , char *buf , int len , float n ) ;
#line 51 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/cargs.h"
void app_use_args(GSview *app , GSVIEW_ARGS *args ) ;
#line 24 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/cdll.h"
int dll_open(void **hmodule , char const   *name , char *msg , int msglen ) ;
#line 25
int dll_close(void **hmodule ) ;
#line 26
dll_proc dll_sym(void **hmodule , char const   *name ) ;
#line 34 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/capp.c"
int debug  =    1;
#line 35 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/capp.c"
char const   szAppName[7]  = {      (char const   )'G',      (char const   )'S',      (char const   )'v',      (char const   )'i', 
        (char const   )'e',      (char const   )'w',      (char const   )'\000'};
#line 38
static void rotate_last_files(GSview *a , int count ) ;
#line 40 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/capp.c"
GSDLL **app_dll(GSview *a ) 
{ 


  {
#line 46
  return (& a->gsdll);
}
}
#line 49 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/capp.c"
PLDLL **app_pldll(GSview *a ) 
{ 


  {
#line 55
  return (& a->pldll);
}
}
#line 58 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/capp.c"
Doc **app_docs(GSview *a ) 
{ 


  {
#line 61
  return (& a->doclist);
}
}
#line 64 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/capp.c"
OPTION *app_option(GSview *a ) 
{ 


  {
#line 67
  return (& a->option);
}
}
#line 70 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/capp.c"
PAGECACHE **app_pagecache(GSview *a ) 
{ 


  {
#line 73
  return (& a->pagecache);
}
}
#line 76 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/capp.c"
BOOL app_multithread(GSview *a ) 
{ 


  {
#line 79
  return (a->multithread);
}
}
#line 82 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/capp.c"
int app_gssrv_request(GSview *a , GSREQ *reqnew ) 
{ 
  int tmp ;

  {
#line 85
  if (a->gssrv) {
    {
#line 86
    tmp = gssrv_request(a->gssrv, reqnew);
    }
#line 86
    return (tmp);
  }
#line 87
  return (-1);
}
}
#line 90 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/capp.c"
int app_plsrv_request(GSview *a , GSREQ *reqnew ) 
{ 
  int tmp ;

  {
#line 93
  if (a->plsrv) {
    {
#line 94
    tmp = gssrv_request(a->plsrv, reqnew);
    }
#line 94
    return (tmp);
  }
#line 95
  return (-1);
}
}
#line 99 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/capp.c"
int app_msg_len_nolock(GSview *a , char const   *str , int len ) 
{ 
  char *p ;
  char const   *s ;
  int i ;
  int lfcount ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char const   *tmp___2 ;

  {
#line 107
  if (debug & 8) {
    {
#line 108
    app_log(str, len);
    }
  }
#line 111
  lfcount = 0;
#line 112
  s = str;
#line 113
  i = 0;
  {
#line 113
  while (1) {
    while_continue: /* CIL Label */ ;
#line 113
    if (! (i < len)) {
#line 113
      goto while_break;
    }
#line 114
    if ((int const   )*s == 10) {
#line 115
      lfcount ++;
    }
#line 116
    s ++;
#line 113
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 118
  if (len + lfcount >= 1024) {
#line 119
    return (0);
  }
#line 120
  if ((len + lfcount) + a->twend >= 61439) {
    {
#line 122
    a->twend -= 1024;
#line 123
    memmove((void *)(a->twbuf), (void const   *)(a->twbuf + 1024), (size_t )a->twend);
    }
  }
#line 125
  p = a->twbuf + a->twend;
#line 126
  i = 0;
  {
#line 126
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 126
    if (! (i < len)) {
#line 126
      goto while_break___0;
    }
#line 127
    if ((int const   )*str == 10) {
#line 128
      tmp = p;
#line 128
      p ++;
#line 128
      *tmp = (char )'\r';
    }
#line 130
    if ((int const   )*str == 0) {
#line 131
      tmp___0 = p;
#line 131
      p ++;
#line 131
      *tmp___0 = (char )' ';
#line 132
      str ++;
    } else {
#line 135
      tmp___1 = p;
#line 135
      p ++;
#line 135
      tmp___2 = str;
#line 135
      str ++;
#line 135
      *tmp___1 = (char )*tmp___2;
    }
#line 126
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 137
  a->twend += len + lfcount;
#line 138
  *(a->twbuf + a->twend) = (char )'\000';
#line 139
  return (len);
}
}
#line 143 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/capp.c"
int app_msg_len(GSview *a , char const   *str , int len ) 
{ 
  int n ;

  {
  {
#line 147
  app_lock(a);
#line 148
  n = app_msg_len_nolock(a, str, len);
#line 149
  app_unlock(a);
  }
#line 150
  return (n);
}
}
#line 153 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/capp.c"
int app_msg(GSview *a , char const   *str ) 
{ 
  size_t tmp ;
  int tmp___0 ;

  {
  {
#line 156
  tmp = strlen(str);
#line 156
  tmp___0 = app_msg_len(a, str, (int )tmp);
  }
#line 156
  return (tmp___0);
}
}
#line 159 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/capp.c"
int app_msgf(GSview *a , char const   *fmt  , ...) 
{ 
  va_list args ;
  int count ;
  char buf[2048] ;

  {
  {
#line 165
  __builtin_va_start(args, fmt);
#line 166
  count = vsnprintf((char */* __restrict  */)(buf), sizeof(buf), (char const   */* __restrict  */)fmt,
                    args);
#line 167
  buf[sizeof(buf) - 1UL] = (char )'\000';
  }
#line 168
  if (count >= (int )sizeof(buf) - 1) {
    {
#line 169
    debug |= 8;
#line 170
    app_msg(a, "PANIC: internal buffer overflow.  Stack is corrupted\n");
    }
  }
  {
#line 172
  app_msg(a, (char const   *)(buf));
#line 173
  __builtin_va_end(args);
  }
#line 174
  return (count);
}
}
#line 177 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/capp.c"
int app_csmsg_len_nolock(GSview *a , char const   *wstr , int wlen ) 
{ 
  char buf[256] ;
  char *nstr ;
  int nlen ;
  int tmp ;
  void *tmp___0 ;

  {
  {
#line 181
  nstr = (char *)((void *)0);
#line 182
  tmp = cs_to_narrow((char *)((void *)0), 0, wstr, wlen);
#line 182
  nlen = tmp;
  }
#line 183
  if (nlen < (int )sizeof(buf)) {
#line 184
    nstr = buf;
  } else {
    {
#line 186
    tmp___0 = malloc((size_t )nlen);
#line 186
    nstr = (char *)tmp___0;
    }
  }
#line 187
  if (nstr) {
    {
#line 188
    cs_to_narrow(nstr, nlen, wstr, wlen);
#line 189
    app_msg_len_nolock(a, (char const   *)nstr, nlen);
    }
#line 190
    if ((unsigned long )nstr != (unsigned long )(buf)) {
      {
#line 191
      free((void *)nstr);
      }
    }
  }
#line 193
  return (wlen);
}
}
#line 196 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/capp.c"
int app_csmsg_len(GSview *a , char const   *wstr , int wlen ) 
{ 
  int n ;

  {
  {
#line 200
  app_lock(a);
#line 201
  n = app_csmsg_len_nolock(a, wstr, wlen);
#line 202
  app_unlock(a);
  }
#line 203
  return (n);
}
}
#line 207 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/capp.c"
int app_csmsg(GSview *a , char const   *wstr ) 
{ 
  size_t tmp ;
  int tmp___0 ;

  {
  {
#line 210
  tmp = strlen(wstr);
#line 210
  tmp___0 = app_csmsg_len(a, wstr, (int )tmp);
  }
#line 210
  return (tmp___0);
}
}
#line 213 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/capp.c"
int app_csmsgf(GSview *a , char const   *fmt  , ...) 
{ 
  va_list args ;
  int count ;
  char buf[2048] ;

  {
  {
#line 219
  __builtin_va_start(args, fmt);
#line 220
  count = vsnprintf((char */* __restrict  */)(buf), sizeof(buf) / sizeof(char ), (char const   */* __restrict  */)fmt,
                    args);
  }
#line 221
  if (count >= (int )sizeof(buf) / (int )sizeof(char ) - 1) {
    {
#line 222
    debug |= 8;
#line 223
    app_msg(a, "PANIC: internal buffer overflow.  Stack is corrupted\n");
    }
  }
  {
#line 225
  app_csmsg(a, (char const   *)(buf));
#line 226
  __builtin_va_end(args);
  }
#line 227
  return (count);
}
}
#line 260 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/capp.c"
static void rotate_last_files(GSview *a , int count ) 
{ 
  int i ;
  char buf[256] ;

  {
#line 265
  if (count >= 4) {
#line 266
    return;
  }
  {
#line 267
  strncpy((char */* __restrict  */)(buf), (char const   */* __restrict  */)(a->last_files[count]),
          (size_t )255);
#line 268
  i = count;
  }
  {
#line 268
  while (1) {
    while_continue: /* CIL Label */ ;
#line 268
    if (! (i > 0)) {
#line 268
      goto while_break;
    }
    {
#line 269
    strncpy((char */* __restrict  */)(a->last_files[i]), (char const   */* __restrict  */)(a->last_files[i - 1]),
            (size_t )255);
#line 268
    i --;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 270
  strncpy((char */* __restrict  */)(a->last_files[0]), (char const   */* __restrict  */)(buf),
          (size_t )255);
  }
#line 271
  return;
}
}
#line 273 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/capp.c"
void app_update_last_files(GSview *a , char const   *filename ) 
{ 
  int i ;
  int tmp ;

  {
#line 277
  i = 0;
  {
#line 277
  while (1) {
    while_continue: /* CIL Label */ ;
#line 277
    if (! (i < a->last_files_count)) {
#line 277
      goto while_break;
    }
    {
#line 278
    tmp = strcmp(filename, (char const   *)(a->last_files[i]));
    }
#line 278
    if (tmp == 0) {
#line 279
      goto while_break;
    }
#line 277
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 281
  if (i < a->last_files_count) {
    {
#line 283
    rotate_last_files(a, i);
    }
#line 284
    return;
  }
#line 286
  if (a->last_files_count < 4) {
#line 287
    (a->last_files_count) ++;
  }
  {
#line 288
  rotate_last_files(a, a->last_files_count - 1);
#line 289
  strncpy((char */* __restrict  */)(a->last_files[0]), (char const   */* __restrict  */)filename,
          (size_t )255);
  }
#line 290
  return;
}
}
#line 292 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/capp.c"
char const   *app_last_files(GSview *a , int i ) 
{ 


  {
#line 295
  if (i < a->last_files_count) {
#line 296
    return ((char const   *)(a->last_files[i]));
  }
#line 297
  return ((char const   *)((void *)0));
}
}
#line 301 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/capp.c"
int app_read_last_files(GSview *a , char const   *filename ) 
{ 
  int i ;
  char buf[256] ;
  char lastfile[256] ;
  char const   *section ;
  PROFILE *prf ;
  size_t tmp ;

  {
  {
#line 307
  section = "GSview";
#line 309
  prf = profile_open(filename);
  }
#line 310
  if ((unsigned long )prf == (unsigned long )((void *)0)) {
#line 311
    return (-1);
  }
  {
#line 313
  a->last_files_count = 0;
#line 314
  memset((void *)(lastfile), 0, sizeof(lastfile));
#line 315
  i = 0;
  }
  {
#line 315
  while (1) {
    while_continue: /* CIL Label */ ;
#line 315
    if (! (i < 4)) {
#line 315
      goto while_break;
    }
    {
#line 316
    snprintf((char */* __restrict  */)(buf), sizeof(buf), (char const   */* __restrict  */)"LastFile%d",
             i);
#line 317
    buf[sizeof(buf) - 1UL] = (char )'\000';
#line 318
    profile_read_string(prf, section, (char const   *)(buf), "", lastfile, (int )sizeof(lastfile));
#line 320
    tmp = strlen((char const   *)(lastfile));
#line 320
    narrow_to_cs(a->last_files[i], (int )(sizeof(a->last_files[i]) / sizeof(char ) - 1UL),
                 (char const   *)(lastfile), (int )tmp + 1);
    }
#line 322
    if (a->last_files[i][0]) {
#line 323
      (a->last_files_count) ++;
    }
#line 315
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 325
  profile_close(prf);
  }
#line 326
  return (0);
}
}
#line 329 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/capp.c"
int app_write_last_files(GSview *a , char const   *filename ) 
{ 
  int i ;
  char buf[256] ;
  char lastfile[256] ;
  char const   *section ;
  PROFILE *prf ;
  size_t tmp ;

  {
  {
#line 335
  section = "GSview";
#line 337
  prf = profile_open(filename);
  }
#line 338
  if ((unsigned long )prf == (unsigned long )((void *)0)) {
#line 339
    return (-1);
  }
  {
#line 341
  a->last_files_count = 0;
#line 342
  memset((void *)(lastfile), 0, sizeof(lastfile));
#line 343
  i = 0;
  }
  {
#line 343
  while (1) {
    while_continue: /* CIL Label */ ;
#line 343
    if (! (i < 4)) {
#line 343
      goto while_break;
    }
    {
#line 344
    snprintf((char */* __restrict  */)(buf), sizeof(buf), (char const   */* __restrict  */)"LastFile%d",
             i);
#line 345
    buf[sizeof(buf) - 1UL] = (char )'\000';
#line 346
    tmp = strlen((char const   *)(a->last_files[i]));
#line 346
    cs_to_narrow(lastfile, (int )(sizeof(lastfile) - 1UL), (char const   *)(a->last_files[i]),
                 (int )tmp + 1);
#line 348
    profile_write_string(prf, section, (char const   *)(buf), (char const   *)(lastfile));
#line 343
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 350
  profile_close(prf);
  }
#line 351
  return (0);
}
}
#line 355 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/capp.c"
void app_use_args(GSview *app , GSVIEW_ARGS *args ) 
{ 
  OPTION *opt ;
  OPTION *tmp ;

  {
  {
#line 358
  tmp = app_option(app);
#line 358
  opt = tmp;
  }
#line 359
  if (args->geometry) {
#line 360
    if (args->geometry == 4) {
#line 361
      opt->img_origin.x = args->geometry_xoffset;
#line 362
      opt->img_origin.y = args->geometry_yoffset;
    }
#line 364
    if (args->geometry >= 2) {
#line 365
      opt->img_size.x = args->geometry_width;
#line 366
      opt->img_size.y = args->geometry_height;
    }
  }
#line 369
  return;
}
}
#line 372 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/capp.c"
static int app_init(GSview *a ) 
{ 


  {
  {
#line 375
  app_platform_init(a);
  }
#line 376
  return (0);
}
}
#line 379 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/capp.c"
static int app_finish(GSview *a ) 
{ 


  {
  {
#line 382
  pagecache_unref_all(a);
#line 383
  zlib_free(a);
#line 384
  bzip2_free(a);
#line 385
  app_platform_finish(a);
  }
#line 386
  return (0);
}
}
#line 390 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/capp.c"
GSview *app_new(void *handle , BOOL multithread ) 
{ 
  GSview *a ;
  void *tmp ;

  {
  {
#line 393
  tmp = malloc(sizeof(GSview ));
#line 393
  a = (GSview *)tmp;
  }
#line 394
  if (a) {
    {
#line 395
    memset((void *)a, 0, sizeof(GSview ));
#line 396
    a->handle = handle;
#line 397
    a->multithread = multithread;
#line 398
    app_init(a);
#line 399
    app_ref(a);
    }
  }
#line 401
  return (a);
}
}
#line 407 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/capp.c"
int app_ref(GSview *a ) 
{ 
  int refcount ;
  char buf[256] ;
  size_t tmp ;

  {
#line 410
  (a->refcount) ++;
#line 410
  refcount = a->refcount;
#line 411
  if (debug & 128) {
    {
#line 413
    snprintf((char */* __restrict  */)(buf), sizeof(buf), (char const   */* __restrict  */)"app refcount=%d\n",
             refcount);
#line 414
    tmp = strlen((char const   *)(buf));
#line 414
    app_msg_len_nolock(a, (char const   *)(buf), (int )tmp);
    }
  }
#line 416
  return (refcount);
}
}
#line 422 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/capp.c"
int app_unref(GSview *a ) 
{ 
  int refcount ;
  char buf[256] ;
  size_t tmp ;

  {
#line 426
  if (a->refcount > 0) {
#line 427
    (a->refcount) --;
  }
#line 428
  refcount = a->refcount;
#line 429
  if (debug & 128) {
    {
#line 431
    snprintf((char */* __restrict  */)(buf), sizeof(buf), (char const   */* __restrict  */)"app refcount=%d\n",
             refcount);
#line 432
    buf[sizeof(buf) - 1UL] = (char )'\000';
#line 433
    tmp = strlen((char const   *)(buf));
#line 433
    app_msg_len_nolock(a, (char const   *)(buf), (int )tmp);
    }
  }
#line 435
  if (refcount == 0) {
    {
#line 436
    app_finish(a);
#line 437
    memset((void *)a, 0, sizeof(GSview ));
#line 438
    free((void *)a);
    }
  }
#line 441
  return (refcount);
}
}
#line 446 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/capp.c"
int zlib_load(GSview *a ) 
{ 
  int code ;
  char buf[1024] ;
  ZLIB *zlib ;
  dll_proc tmp ;
  dll_proc tmp___0 ;
  dll_proc tmp___1 ;

  {
#line 449
  code = 0;
#line 451
  zlib = & a->zlib;
#line 452
  if (zlib->loaded) {
#line 453
    return (0);
  }
  {
#line 455
  memset((void *)(buf), 0, sizeof(buf));
#line 456
  code = dll_open(& zlib->hmodule, "libz.so", buf, (int )(sizeof(buf) / sizeof(char ) - 1UL));
  }
#line 458
  if (code != 0) {
    {
#line 459
    app_csmsg(a, (char const   *)(buf));
    }
  } else {
#line 462
    if (code == 0) {
      {
#line 463
      tmp = dll_sym(& zlib->hmodule, "gzopen");
#line 463
      zlib->gzopen = (gzFile (*)(char const   *path , char const   *mode ))tmp;
      }
    }
#line 464
    if ((unsigned long )zlib->gzopen == (unsigned long )((void *)0)) {
      {
#line 465
      app_msg(a, "Can\'t find gzopen\n");
#line 466
      code = -1;
      }
    }
#line 468
    if (code == 0) {
      {
#line 469
      tmp___0 = dll_sym(& zlib->hmodule, "gzread");
#line 469
      zlib->gzread = (int (*)(gzFile file , void *buf , unsigned int len ))tmp___0;
      }
    }
#line 470
    if ((unsigned long )zlib->gzread == (unsigned long )((void *)0)) {
      {
#line 471
      app_msg(a, "Can\'t find gzread\n");
#line 472
      code = -1;
      }
    }
#line 474
    if (code == 0) {
      {
#line 475
      tmp___1 = dll_sym(& zlib->hmodule, "gzclose");
#line 475
      zlib->gzclose = (int (*)(gzFile file ))tmp___1;
      }
    }
#line 476
    if ((unsigned long )zlib->gzclose == (unsigned long )((void *)0)) {
      {
#line 477
      app_msg(a, "Can\'t find gzclose\n");
#line 478
      code = -1;
      }
    }
#line 480
    if (code == 0) {
#line 481
      zlib->loaded = 1;
    } else {
      {
#line 483
      dll_close(& zlib->hmodule);
#line 484
      memset((void *)zlib, 0, sizeof(ZLIB ));
#line 485
      zlib->loaded = 0;
      }
    }
  }
#line 488
  return (code);
}
}
#line 491 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/capp.c"
void zlib_free(GSview *a ) 
{ 


  {
#line 494
  if (a->zlib.loaded == 0) {
#line 495
    return;
  }
  {
#line 496
  dll_close(& a->zlib.hmodule);
#line 497
  a->zlib.hmodule = (void *)0;
#line 498
  a->zlib.gzopen = (gzFile (*)(char const   *path , char const   *mode ))((void *)0);
#line 499
  a->zlib.gzread = (int (*)(gzFile file , void *buf , unsigned int len ))((void *)0);
#line 500
  a->zlib.gzclose = (int (*)(gzFile file ))((void *)0);
#line 501
  a->zlib.loaded = 0;
  }
#line 502
  return;
}
}
#line 504 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/capp.c"
int zlib_uncompress(GSview *app , GFile *outfile , char const   *filename ) 
{ 
  gzFile infile ;
  char *buffer ;
  int count ;
  int tmp ;
  void *tmp___0 ;

  {
  {
#line 511
  tmp = zlib_load(app);
  }
#line 511
  if (tmp) {
#line 512
    return (-1);
  }
  {
#line 515
  tmp___0 = malloc((size_t )4096);
#line 515
  buffer = (char *)tmp___0;
  }
#line 516
  if ((unsigned long )buffer == (unsigned long )((char *)((void *)0))) {
#line 517
    return (-1);
  }
  {
#line 519
  infile = (*(app->zlib.gzopen))(filename, "rb");
  }
#line 519
  if ((unsigned long )infile == (unsigned long )((void *)0)) {
    {
#line 520
    free((void *)buffer);
    }
#line 521
    return (-1);
  }
  {
#line 524
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 524
    count = (*(app->zlib.gzread))(infile, (void *)buffer, 4096U);
    }
#line 524
    if (! (count > 0)) {
#line 524
      goto while_break;
    }
    {
#line 525
    gfile_write(outfile, (void const   *)buffer, (unsigned int )count);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 527
  free((void *)buffer);
#line 528
  (*(app->zlib.gzclose))(infile);
  }
#line 529
  if (count < 0) {
#line 530
    return (-1);
  }
#line 531
  return (0);
}
}
#line 534 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/capp.c"
int bzip2_load(GSview *a ) 
{ 
  int code ;
  char buf[1024] ;
  BZIP2 *bzip2 ;
  dll_proc tmp ;
  dll_proc tmp___0 ;
  dll_proc tmp___1 ;

  {
#line 537
  code = 0;
#line 539
  bzip2 = & a->bzip2;
#line 540
  if (bzip2->loaded) {
#line 541
    return (0);
  }
  {
#line 543
  memset((void *)(buf), 0, sizeof(buf));
#line 544
  code = dll_open(& bzip2->hmodule, "libbz2.so", buf, (int )(sizeof(buf) / sizeof(char ) - 1UL));
  }
#line 546
  if (code != 0) {
    {
#line 547
    app_csmsg(a, (char const   *)(buf));
    }
  } else {
#line 550
    if (code == 0) {
      {
#line 551
      tmp = dll_sym(& bzip2->hmodule, "BZ2_bzopen");
#line 551
      bzip2->bzopen = (bzFile (*)(char const   *path , char const   *mode ))tmp;
      }
    }
#line 552
    if ((unsigned long )bzip2->bzopen == (unsigned long )((void *)0)) {
      {
#line 553
      app_msg(a, "Can\'t find bzopen\n");
#line 554
      code = -1;
      }
    }
#line 556
    if (code == 0) {
      {
#line 557
      tmp___0 = dll_sym(& bzip2->hmodule, "BZ2_bzread");
#line 557
      bzip2->bzread = (int (*)(bzFile file , void *buf , unsigned int len ))tmp___0;
      }
    }
#line 558
    if ((unsigned long )bzip2->bzread == (unsigned long )((void *)0)) {
      {
#line 559
      app_msg(a, "Can\'t find bzread\n");
#line 560
      code = -1;
      }
    }
#line 562
    if (code == 0) {
      {
#line 563
      tmp___1 = dll_sym(& bzip2->hmodule, "BZ2_bzclose");
#line 563
      bzip2->bzclose = (int (*)(bzFile file ))tmp___1;
      }
    }
#line 564
    if ((unsigned long )bzip2->bzclose == (unsigned long )((void *)0)) {
      {
#line 565
      app_msg(a, "Can\'t find bzclose\n");
#line 566
      code = -1;
      }
    }
#line 568
    if (code == 0) {
#line 569
      bzip2->loaded = 1;
    } else {
      {
#line 571
      dll_close(& bzip2->hmodule);
#line 572
      memset((void *)bzip2, 0, sizeof(ZLIB ));
#line 573
      bzip2->loaded = 0;
      }
    }
  }
#line 576
  return (code);
}
}
#line 579 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/capp.c"
void bzip2_free(GSview *a ) 
{ 


  {
#line 582
  if (a->bzip2.loaded == 0) {
#line 583
    return;
  }
  {
#line 584
  dll_close(& a->bzip2.hmodule);
#line 585
  a->bzip2.hmodule = (void *)0;
#line 586
  a->bzip2.bzopen = (bzFile (*)(char const   *path , char const   *mode ))((void *)0);
#line 587
  a->bzip2.bzread = (int (*)(bzFile file , void *buf , unsigned int len ))((void *)0);
#line 588
  a->bzip2.bzclose = (int (*)(bzFile file ))((void *)0);
#line 589
  a->bzip2.loaded = 0;
  }
#line 590
  return;
}
}
#line 592 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/capp.c"
int bzip2_uncompress(GSview *app , GFile *outfile , char const   *filename ) 
{ 
  bzFile infile ;
  char *buffer ;
  int count ;
  int tmp ;
  void *tmp___0 ;

  {
  {
#line 599
  tmp = bzip2_load(app);
  }
#line 599
  if (tmp) {
#line 600
    return (-1);
  }
  {
#line 603
  tmp___0 = malloc((size_t )4096);
#line 603
  buffer = (char *)tmp___0;
  }
#line 604
  if ((unsigned long )buffer == (unsigned long )((char *)((void *)0))) {
#line 605
    return (-1);
  }
  {
#line 607
  infile = (*(app->bzip2.bzopen))(filename, "rb");
  }
#line 607
  if ((unsigned long )infile == (unsigned long )((void *)0)) {
    {
#line 608
    free((void *)buffer);
    }
#line 609
    return (-1);
  }
  {
#line 612
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 612
    count = (*(app->bzip2.bzread))(infile, (void *)buffer, 4096U);
    }
#line 612
    if (! (count > 0)) {
#line 612
      goto while_break;
    }
    {
#line 613
    gfile_write(outfile, (void const   *)buffer, (unsigned int )count);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 615
  free((void *)buffer);
#line 616
  (*(app->bzip2.bzclose))(infile);
  }
#line 617
  if (count < 0) {
#line 618
    return (-1);
  }
#line 619
  return (0);
}
}
#line 622 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/capp.c"
GFile *app_temp_gfile(GSview *app , char *fname , int len ) 
{ 
  char *temp ;
  long fd ;
  size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  int tmp___4 ;
  GFile *tmp___5 ;

  {
  {
#line 629
  memset((void *)fname, 0, (unsigned long )len * sizeof(char ));
#line 630
  temp = getenv("TEMP");
  }
#line 630
  if ((unsigned long )temp == (unsigned long )((void *)0)) {
    {
#line 632
    strncpy((char */* __restrict  */)fname, (char const   */* __restrict  */)"/tmp",
            (size_t )(len - 1));
    }
  } else {
    {
#line 637
    strncpy((char */* __restrict  */)fname, (char const   */* __restrict  */)temp,
            (size_t )(len - 1));
    }
  }
  {
#line 649
  tmp___0 = strlen((char const   *)fname);
  }
#line 649
  if (tmp___0) {
    {
#line 649
    tmp___1 = strlen((char const   *)fname);
    }
#line 649
    if ((int )*(fname + (tmp___1 - 1UL)) != (int )*("/" + 0)) {
      {
#line 650
      tmp = strlen((char const   *)fname);
#line 650
      strncat((char */* __restrict  */)fname, (char const   */* __restrict  */)"/",
              (size_t )(len - 1) - tmp);
      }
    }
  }
  {
#line 652
  tmp___2 = strlen((char const   *)fname);
#line 652
  strncat((char */* __restrict  */)fname, (char const   */* __restrict  */)"gsview",
          (size_t )(len - 1) - tmp___2);
#line 653
  tmp___3 = strlen((char const   *)fname);
#line 653
  strncat((char */* __restrict  */)fname, (char const   */* __restrict  */)"XXXXXX",
          (size_t )(len - 1) - tmp___3);
#line 655
  tmp___4 = mkstemp(fname);
#line 655
  fd = (long )tmp___4;
  }
#line 656
  if (debug & 1) {
    {
#line 657
    app_csmsgf(app, "Creating temporary file \"%s\"\n", fname);
    }
  }
  {
#line 658
  tmp___5 = gfile_open_handle((void *)fd, 4097U);
  }
#line 658
  return (tmp___5);
}
}
#line 667 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/capp.c"
FILE *app_temp_file(GSview *app , char *fname , int len ) 
{ 
  char *temp ;
  long fd ;
  size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  int tmp___4 ;
  FILE *tmp___5 ;

  {
  {
#line 674
  memset((void *)fname, 0, (unsigned long )len * sizeof(char ));
#line 675
  temp = getenv("TEMP");
  }
#line 675
  if ((unsigned long )temp == (unsigned long )((void *)0)) {
    {
#line 677
    strncpy((char */* __restrict  */)fname, (char const   */* __restrict  */)"/tmp",
            (size_t )(len - 1));
    }
  } else {
    {
#line 682
    strncpy((char */* __restrict  */)fname, (char const   */* __restrict  */)temp,
            (size_t )(len - 1));
    }
  }
  {
#line 694
  tmp___0 = strlen((char const   *)fname);
  }
#line 694
  if (tmp___0) {
    {
#line 694
    tmp___1 = strlen((char const   *)fname);
    }
#line 694
    if ((int )*(fname + (tmp___1 - 1UL)) != (int )*("/" + 0)) {
      {
#line 695
      tmp = strlen((char const   *)fname);
#line 695
      strncat((char */* __restrict  */)fname, (char const   */* __restrict  */)"/",
              (size_t )(len - 1) - tmp);
      }
    }
  }
  {
#line 697
  tmp___2 = strlen((char const   *)fname);
#line 697
  strncat((char */* __restrict  */)fname, (char const   */* __restrict  */)"gsview",
          (size_t )(len - 1) - tmp___2);
#line 698
  tmp___3 = strlen((char const   *)fname);
#line 698
  strncat((char */* __restrict  */)fname, (char const   */* __restrict  */)"XXXXXX",
          (size_t )(len - 1) - tmp___3);
#line 700
  tmp___4 = mkstemp(fname);
#line 700
  fd = (long )tmp___4;
  }
#line 701
  if (debug & 1) {
    {
#line 702
    app_csmsgf(app, "Creating temporary file \"%s\"\n", fname);
    }
  }
  {
#line 703
  tmp___5 = fdopen((int )fd, "wb");
  }
#line 703
  return (tmp___5);
}
}
#line 713 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/capp.c"
float app_get_points(GSview *a , char const   *str ) 
{ 
  float val ;
  char ptbuf[16] ;
  char inchbuf[16] ;
  char mmbuf[16] ;
  char unitbuf[256] ;
  char *p ;
  char *q ;
  char fbuf[64] ;
  int i ;
  int tmp ;
  size_t tmp___0 ;
  double tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  size_t tmp___10 ;
  int tmp___11 ;
  size_t tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  size_t tmp___16 ;
  int tmp___17 ;
  size_t tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  size_t tmp___22 ;
  int tmp___23 ;
  size_t tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;

  {
  {
#line 721
  p = unitbuf;
#line 725
  memset((void *)(unitbuf), 0, sizeof(unitbuf));
#line 726
  strncpy((char */* __restrict  */)(unitbuf), (char const   */* __restrict  */)str,
          sizeof(unitbuf) / sizeof(char ) - 1UL);
#line 727
  mmbuf[0] = (char )'\000';
#line 727
  inchbuf[0] = mmbuf[0];
#line 727
  ptbuf[0] = inchbuf[0];
#line 728
  load_string(a, 2030, ptbuf, (int )sizeof(ptbuf));
#line 730
  load_string(a, 2032, inchbuf, (int )sizeof(inchbuf));
#line 732
  load_string(a, 2031, mmbuf, (int )sizeof(mmbuf));
  }
  {
#line 734
  while (1) {
    while_continue: /* CIL Label */ ;
#line 734
    if (*p) {
#line 734
      if (! ((int )*p == 32)) {
#line 734
        goto while_break;
      }
    } else {
#line 734
      goto while_break;
    }
#line 735
    if ((unsigned int )global_codepage == 0U) {
#line 735
      p ++;
    } else {
      {
#line 735
      tmp = char_next((char const   *)p);
#line 735
      p += tmp;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 736
  tmp___0 = strlen((char const   *)p);
#line 736
  cs_to_narrow(fbuf, (int )sizeof(fbuf) - 1, (char const   *)p, (int )tmp___0 + 1);
#line 737
  fbuf[sizeof(fbuf) - 1UL] = (char )'\000';
#line 738
  tmp___1 = atof((char const   *)(fbuf));
#line 738
  val = (float )tmp___1;
  }
  {
#line 739
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 739
    if (*p) {
#line 739
      if ((int )*p >= 48) {
#line 739
        if (! ((int )*p <= 57)) {
#line 739
          goto _L;
        }
      } else
      _L: /* CIL Label */ 
#line 739
      if (! ((int )*p == 46)) {
#line 739
        goto while_break___0;
      }
    } else {
#line 739
      goto while_break___0;
    }
#line 740
    if ((unsigned int )global_codepage == 0U) {
#line 740
      p ++;
    } else {
      {
#line 740
      tmp___2 = char_next((char const   *)p);
#line 740
      p += tmp___2;
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 741
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 741
    if (*p) {
#line 741
      if (! ((int )*p == 32)) {
#line 741
        goto while_break___1;
      }
    } else {
#line 741
      goto while_break___1;
    }
#line 742
    if ((unsigned int )global_codepage == 0U) {
#line 742
      p ++;
    } else {
      {
#line 742
      tmp___3 = char_next((char const   *)p);
#line 742
      p += tmp___3;
      }
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 743
  q = p;
  {
#line 744
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 744
    if (*q) {
#line 744
      if (! ((int )*q >= 65)) {
#line 744
        goto while_break___2;
      }
    } else {
#line 744
      goto while_break___2;
    }
#line 745
    if ((unsigned int )global_codepage == 0U) {
#line 745
      q ++;
    } else {
      {
#line 745
      tmp___4 = char_next((char const   *)q);
#line 745
      q += tmp___4;
      }
    }
  }
  while_break___2: /* CIL Label */ ;
  }
#line 746
  if (*q) {
#line 747
    if ((unsigned int )global_codepage == 0U) {
#line 747
      q ++;
    } else {
      {
#line 747
      tmp___5 = char_next((char const   *)q);
#line 747
      q += tmp___5;
      }
    }
  }
  {
#line 748
  i = (int )(q - p);
#line 749
  tmp___24 = strlen((char const   *)(ptbuf));
  }
#line 749
  if (i > (int )tmp___24) {
#line 749
    tmp___23 = i;
  } else {
    {
#line 749
    tmp___22 = strlen((char const   *)(ptbuf));
#line 749
    tmp___23 = (int )tmp___22;
    }
  }
  {
#line 749
  tmp___25 = strncmp((char const   *)p, (char const   *)(ptbuf), (size_t )tmp___23);
  }
#line 749
  if (! (tmp___25 == 0)) {
    {
#line 749
    tmp___26 = strncmp((char const   *)p, "pt", (size_t )2);
    }
#line 749
    if (! (tmp___26 == 0)) {
      {
#line 753
      tmp___18 = strlen((char const   *)(inchbuf));
      }
#line 753
      if (i > (int )tmp___18) {
#line 753
        tmp___17 = i;
      } else {
        {
#line 753
        tmp___16 = strlen((char const   *)(inchbuf));
#line 753
        tmp___17 = (int )tmp___16;
        }
      }
      {
#line 753
      tmp___19 = strncmp((char const   *)p, (char const   *)(inchbuf), (size_t )tmp___17);
      }
#line 753
      if (tmp___19 == 0) {
#line 755
        val = (float )((double )val * 72.0);
      } else {
        {
#line 753
        tmp___20 = strncmp((char const   *)p, "in", (size_t )2);
        }
#line 753
        if (tmp___20 == 0) {
#line 755
          val = (float )((double )val * 72.0);
        } else {
          {
#line 756
          tmp___12 = strlen((char const   *)(mmbuf));
          }
#line 756
          if (i > (int )tmp___12) {
#line 756
            tmp___11 = i;
          } else {
            {
#line 756
            tmp___10 = strlen((char const   *)(mmbuf));
#line 756
            tmp___11 = (int )tmp___10;
            }
          }
          {
#line 756
          tmp___13 = strncmp((char const   *)p, (char const   *)(mmbuf), (size_t )tmp___11);
          }
#line 756
          if (tmp___13 == 0) {
#line 758
            val *= (float )(72.0 / 25.4);
          } else {
            {
#line 756
            tmp___14 = strncmp((char const   *)p, "mm", (size_t )2);
            }
#line 756
            if (tmp___14 == 0) {
#line 758
              val *= (float )(72.0 / 25.4);
            } else {
              {
#line 759
              tmp___8 = strncmp((char const   *)p, "cm", (size_t )2);
              }
#line 759
              if (tmp___8 == 0) {
#line 760
                val *= (float )(72.0 / 2.54);
              } else {
                {
#line 761
                tmp___7 = strncmp((char const   *)p, "m", (size_t )1);
                }
#line 761
                if (tmp___7 == 0) {
#line 762
                  val *= (float )(72.0 / 0.0254);
                } else {
                  {
#line 763
                  tmp___6 = strncmp((char const   *)p, "ft", (size_t )2);
                  }
#line 763
                  if (tmp___6 == 0) {
#line 764
                    val *= (float )(72.0 * 12.0);
                  }
                }
              }
            }
          }
        }
      }
    }
  }
#line 765
  return (val);
}
}
#line 768 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/capp.c"
void app_put_points(GSview *a , UNIT unit , char *buf , int len , float n ) 
{ 
  char ubuf[16] ;
  float factor ;
  size_t tmp ;

  {
#line 772
  factor = (float )1.0;
#line 773
  if (len < 1) {
#line 774
    return;
  }
  {
#line 775
  *(buf + 0) = (char )'\000';
#line 776
  ubuf[0] = (char )'\000';
#line 777
  load_string(a, (int )(2030U + (unsigned int )unit), ubuf, (int )sizeof(ubuf));
#line 778
  tmp = strlen((char const   *)(ubuf));
  }
#line 778
  if (len < 32 + (int )tmp) {
#line 779
    return;
  }
  {
#line 781
  if ((unsigned int )unit == 1U) {
#line 781
    goto case_1;
  }
#line 784
  if ((unsigned int )unit == 2U) {
#line 784
    goto case_2;
  }
#line 788
  goto switch_default;
  case_1: /* CIL Label */ 
#line 782
  factor = (float )(25.4 / 72.0);
#line 783
  goto switch_break;
  case_2: /* CIL Label */ 
#line 785
  factor = (float )(1.0 / 72.0);
#line 786
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 789
  factor = (float )1.0;
  switch_break: /* CIL Label */ ;
  }
  {
#line 791
  snprintf((char */* __restrict  */)buf, (size_t )len, (char const   */* __restrict  */)"%g %s",
           (double )(n * factor), ubuf);
#line 792
  *(buf + (len - 1)) = (char )'0';
  }
#line 793
  return;
}
}
#line 43 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/cmac.h"
DWORD get_bigendian_dword(unsigned char const   *buf ) ;
#line 44
WORD get_bigendian_word(unsigned char const   *buf ) ;
#line 45
void put_bigendian_dword(unsigned char *dw , DWORD val ) ;
#line 46
void put_bigendian_word(unsigned char *w , WORD val ) ;
#line 61
int extract_mac_epsf(GFile *f , CMACFILE *mac , char const   *outname ) ;
#line 36 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/cmac.c"
static int extract_mac_data(GFile *f , char const   *outname , unsigned long begin ,
                            unsigned long length , unsigned long header ) ;
#line 39 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/cmac.c"
DWORD get_bigendian_dword(unsigned char const   *buf ) 
{ 
  DWORD dw ;

  {
#line 43
  dw = (DWORD )*(buf + 0) << 24;
#line 44
  dw += (DWORD )*(buf + 1) << 16;
#line 45
  dw += (DWORD )*(buf + 2) << 8;
#line 46
  dw += (DWORD )*(buf + 3);
#line 47
  return (dw);
}
}
#line 50 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/cmac.c"
WORD get_bigendian_word(unsigned char const   *buf ) 
{ 
  WORD w ;

  {
#line 54
  w = (WORD )((int const   )*(buf + 0) << 8);
#line 55
  w = (WORD )((int )w | (int )((WORD )*(buf + 1)));
#line 56
  return (w);
}
}
#line 60 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/cmac.c"
void put_bigendian_dword(unsigned char *dw , DWORD val ) 
{ 


  {
#line 63
  *(dw + 0) = (unsigned char )((val >> 24) & 255UL);
#line 64
  *(dw + 1) = (unsigned char )((val >> 16) & 255UL);
#line 65
  *(dw + 2) = (unsigned char )((val >> 8) & 255UL);
#line 66
  *(dw + 3) = (unsigned char )(val & 255UL);
#line 67
  return;
}
}
#line 71 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/cmac.c"
void put_bigendian_word(unsigned char *w , WORD val ) 
{ 


  {
#line 74
  *(w + 0) = (unsigned char )(((int )val >> 8) & 255);
#line 75
  *(w + 1) = (unsigned char )((int )val & 255);
#line 76
  return;
}
}
#line 78 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/cmac.c"
unsigned char const   apple_single_magic[4]  = {      (unsigned char const   )0,      (unsigned char const   )5,      (unsigned char const   )22,      (unsigned char const   )0};
#line 79 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/cmac.c"
unsigned char const   apple_double_magic[4]  = {      (unsigned char const   )0,      (unsigned char const   )5,      (unsigned char const   )22,      (unsigned char const   )7};
#line 81 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/cmac.c"
CMACFILE *get_mactype(GFile *f ) 
{ 
  unsigned char data[128] ;
  CMAC_TYPE type ;
  CMACFILE *mac ;
  int i ;
  int asd_entries ;
  DWORD version ;
  DWORD EntryID ;
  DWORD Offset ;
  DWORD Length ;
  unsigned long file_length ;
  int count ;
  unsigned int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  WORD tmp___2 ;
  unsigned int tmp___3 ;
  DWORD data_begin ;
  DWORD tmp___4 ;
  DWORD map_begin ;
  DWORD tmp___5 ;
  DWORD data_length ;
  DWORD tmp___6 ;
  DWORD map_length ;
  DWORD tmp___7 ;
  void *tmp___8 ;
  unsigned int tmp___9 ;
  unsigned long tmp___10 ;
  unsigned int tmp___11 ;

  {
#line 86
  type = (CMAC_TYPE )0;
#line 89
  asd_entries = 0;
#line 97
  if ((unsigned long )f == (unsigned long )((void *)0)) {
#line 98
    return ((CMACFILE *)((void *)0));
  }
  {
#line 99
  file_length = gfile_get_length(f);
#line 100
  tmp = gfile_read(f, (void *)(data), 26U);
#line 100
  count = (int )tmp;
  }
#line 101
  if (count >= 26) {
    {
#line 102
    tmp___1 = memcmp((void const   *)(data), (void const   *)(apple_single_magic),
                     (size_t )4);
    }
#line 102
    if (tmp___1 == 0) {
#line 103
      type = (CMAC_TYPE )1;
    } else {
      {
#line 104
      tmp___0 = memcmp((void const   *)(data), (void const   *)(apple_double_magic),
                       (size_t )4);
      }
#line 104
      if (tmp___0 == 0) {
#line 105
        type = (CMAC_TYPE )2;
      }
    }
#line 106
    if ((unsigned int )type == 1U) {
#line 106
      goto _L___20;
    } else
#line 106
    if ((unsigned int )type == 2U) {
      _L___20: /* CIL Label */ 
      {
#line 107
      version = get_bigendian_dword((unsigned char const   *)(data + 4));
      }
#line 108
      if (version != 65536UL) {
#line 108
        if (version != 131072UL) {
#line 109
          type = (CMAC_TYPE )0;
        }
      }
      {
#line 110
      tmp___2 = get_bigendian_word((unsigned char const   *)(data + 24));
#line 110
      asd_entries = (int )tmp___2;
      }
    } else
#line 112
    if ((unsigned int )type == 0U) {
      {
#line 113
      tmp___3 = gfile_read(f, (void *)(data + 26), 102U);
#line 113
      count = (int )((unsigned int )count + tmp___3);
      }
#line 115
      if (count >= 128) {
#line 115
        if ((int )data[0] == 0) {
#line 115
          if ((int )data[1] >= 1) {
#line 115
            if ((int )data[1] <= 63) {
#line 115
              if ((int )data[74] == 0) {
#line 115
                if ((int )data[82] == 0) {
#line 115
                  if ((int )data[65] >= 32) {
#line 115
                    if ((int )data[65] <= 122) {
#line 115
                      if ((int )data[66] >= 32) {
#line 115
                        if ((int )data[66] <= 122) {
#line 115
                          if ((int )data[67] >= 32) {
#line 115
                            if ((int )data[67] <= 122) {
#line 115
                              if ((int )data[68] >= 32) {
#line 115
                                if ((int )data[68] <= 122) {
#line 115
                                  if ((int )data[69] >= 32) {
#line 115
                                    if ((int )data[69] <= 122) {
#line 115
                                      if ((int )data[70] >= 32) {
#line 115
                                        if ((int )data[70] <= 122) {
#line 115
                                          if ((int )data[71] >= 32) {
#line 115
                                            if ((int )data[71] <= 122) {
#line 115
                                              if ((int )data[72] >= 32) {
#line 115
                                                if ((int )data[72] <= 122) {
#line 127
                                                  type = (CMAC_TYPE )3;
                                                } else {
#line 115
                                                  goto _L___19;
                                                }
                                              } else {
#line 115
                                                goto _L___19;
                                              }
                                            } else {
#line 115
                                              goto _L___19;
                                            }
                                          } else {
#line 115
                                            goto _L___19;
                                          }
                                        } else {
#line 115
                                          goto _L___19;
                                        }
                                      } else {
#line 115
                                        goto _L___19;
                                      }
                                    } else {
#line 115
                                      goto _L___19;
                                    }
                                  } else {
#line 115
                                    goto _L___19;
                                  }
                                } else {
#line 115
                                  goto _L___19;
                                }
                              } else {
#line 115
                                goto _L___19;
                              }
                            } else {
#line 115
                              goto _L___19;
                            }
                          } else {
#line 115
                            goto _L___19;
                          }
                        } else {
#line 115
                          goto _L___19;
                        }
                      } else {
#line 115
                        goto _L___19;
                      }
                    } else {
#line 115
                      goto _L___19;
                    }
                  } else {
#line 115
                    goto _L___19;
                  }
                } else {
#line 115
                  goto _L___19;
                }
              } else {
#line 115
                goto _L___19;
              }
            } else {
#line 115
              goto _L___19;
            }
          } else {
#line 115
            goto _L___19;
          }
        } else {
#line 115
          goto _L___19;
        }
      } else {
        _L___19: /* CIL Label */ 
        {
#line 131
        tmp___4 = get_bigendian_dword((unsigned char const   *)(data));
#line 131
        data_begin = tmp___4;
#line 132
        tmp___5 = get_bigendian_dword((unsigned char const   *)(data + 4));
#line 132
        map_begin = tmp___5;
#line 133
        tmp___6 = get_bigendian_dword((unsigned char const   *)(data + 8));
#line 133
        data_length = tmp___6;
#line 134
        tmp___7 = get_bigendian_dword((unsigned char const   *)(data + 12));
#line 134
        map_length = tmp___7;
        }
#line 135
        if (data_begin == 256UL) {
#line 135
          if (data_begin + data_length == map_begin) {
#line 135
            if (map_begin + map_length == file_length) {
#line 138
              type = (CMAC_TYPE )4;
            }
          }
        }
      }
    }
  }
#line 143
  if ((unsigned int )type == 0U) {
#line 144
    return ((CMACFILE *)((void *)0));
  }
  {
#line 146
  tmp___8 = malloc(sizeof(CMACFILE ));
#line 146
  mac = (CMACFILE *)tmp___8;
  }
#line 147
  if ((unsigned long )mac == (unsigned long )((void *)0)) {
#line 148
    return ((CMACFILE *)((void *)0));
  }
  {
#line 149
  memset((void *)mac, 0, sizeof(CMACFILE ));
#line 150
  mac->type = type;
  }
#line 153
  if ((unsigned int )type == 3U) {
    {
#line 154
    memcpy((void */* __restrict  */)(mac->file_type), (void const   */* __restrict  */)(data + 65),
           (size_t )4);
#line 155
    memcpy((void */* __restrict  */)(mac->file_creator), (void const   */* __restrict  */)(data + 69),
           (size_t )4);
#line 156
    mac->data_begin = (DWORD )128;
#line 157
    mac->data_length = get_bigendian_dword((unsigned char const   *)(data + 83));
#line 158
    mac->resource_begin = ((mac->data_begin + mac->data_length) + 127UL) & 0xffffffffffffff80UL;
#line 160
    mac->resource_length = get_bigendian_dword((unsigned char const   *)(data + 87));
    }
  } else
#line 162
  if ((unsigned int )type == 4U) {
    {
#line 163
    memcpy((void */* __restrict  */)(mac->file_type), (void const   */* __restrict  */)"    ",
           (size_t )4);
#line 164
    memcpy((void */* __restrict  */)(mac->file_creator), (void const   */* __restrict  */)"    ",
           (size_t )4);
#line 165
    mac->resource_begin = (DWORD )0;
#line 166
    mac->resource_length = file_length;
    }
  } else {
#line 170
    i = 0;
    {
#line 170
    while (1) {
      while_continue: /* CIL Label */ ;
#line 170
      if (! (i < asd_entries)) {
#line 170
        goto while_break;
      }
      {
#line 171
      tmp___9 = gfile_read(f, (void *)(data), 12U);
#line 171
      count = (int )tmp___9;
#line 172
      EntryID = get_bigendian_dword((unsigned char const   *)(data));
#line 173
      Offset = get_bigendian_dword((unsigned char const   *)(data + 4));
#line 174
      Length = get_bigendian_dword((unsigned char const   *)(data + 8));
      }
      {
#line 176
      if (EntryID == 1UL) {
#line 176
        goto case_1;
      }
#line 180
      if (EntryID == 2UL) {
#line 180
        goto case_2;
      }
#line 184
      if (EntryID == 9UL) {
#line 184
        goto case_9;
      }
#line 175
      goto switch_break;
      case_1: /* CIL Label */ 
#line 177
      mac->data_begin = Offset;
#line 178
      mac->data_length = Length;
#line 179
      goto switch_break;
      case_2: /* CIL Label */ 
#line 181
      mac->resource_begin = Offset;
#line 182
      mac->resource_length = Length;
#line 183
      goto switch_break;
      case_9: /* CIL Label */ 
#line 185
      mac->finder_begin = Offset;
#line 186
      mac->finder_length = Length;
#line 187
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
#line 170
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 190
    if (mac->finder_begin != 0UL) {
      {
#line 191
      gfile_seek(f, (long )mac->finder_begin, 0U);
      }
#line 192
      if (sizeof(data) < mac->finder_length) {
#line 192
        tmp___10 = sizeof(data);
      } else {
#line 192
        tmp___10 = mac->finder_length;
      }
      {
#line 192
      tmp___11 = gfile_read(f, (void *)(data), (unsigned int )tmp___10);
#line 192
      count = (int )tmp___11;
      }
#line 193
      if (count >= 8) {
        {
#line 194
        memcpy((void */* __restrict  */)(mac->file_type), (void const   */* __restrict  */)(data),
               (size_t )4);
#line 195
        memcpy((void */* __restrict  */)(mac->file_creator), (void const   */* __restrict  */)(data + 4),
               (size_t )4);
        }
      }
    }
  }
#line 200
  return (mac);
}
}
#line 237 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/cmac.c"
int get_pict(GFile *f , CMACFILE *mac , int debug___0 ) 
{ 
  CMAC_RESOURCE_HEADER reshdr ;
  CMAC_RESOURCE_MAP resmap ;
  CMAC_RESOURCE_TYPE_LIST typelist ;
  CMAC_RESOURCE_REF_LIST reflist ;
  DWORD res_offset ;
  DWORD map_offset ;
  DWORD type_offset ;
  DWORD ref_offset ;
  DWORD preview_offset ;
  DWORD preview_length ;
  unsigned char data[16] ;
  char name[257] ;
  int name_length ;
  int count ;
  int i ;
  int j ;
  unsigned int tmp ;
  unsigned int tmp___0 ;
  unsigned int tmp___1 ;
  unsigned int tmp___2 ;
  unsigned int tmp___3 ;
  unsigned int tmp___4 ;
  unsigned int tmp___5 ;
  DWORD tmp___6 ;
  DWORD tmp___7 ;
  unsigned int tmp___8 ;
  unsigned int tmp___9 ;
  int tmp___10 ;

  {
#line 248
  preview_offset = (DWORD )0;
#line 249
  preview_length = (DWORD )0;
#line 255
  if ((unsigned long )mac == (unsigned long )((void *)0)) {
#line 256
    return (1);
  }
#line 257
  if ((unsigned int )mac->type == 0U) {
#line 258
    return (1);
  }
#line 259
  if ((unsigned int )mac->type != 4U) {
#line 259
    if (mac->resource_begin == 0UL) {
#line 261
      return (1);
    } else {
#line 259
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 259
  if (mac->resource_length == 0UL) {
#line 261
    return (1);
  }
  {
#line 263
  memset((void *)(& resmap), 0, sizeof(resmap));
#line 264
  memset((void *)(& typelist), 0, sizeof(typelist));
#line 265
  memset((void *)(& reflist), 0, sizeof(reflist));
#line 267
  res_offset = mac->resource_begin;
#line 268
  gfile_seek(f, (long )res_offset, 0U);
#line 269
  tmp = gfile_read(f, (void *)(data), 16U);
#line 269
  count = (int )tmp;
  }
#line 270
  if (count != 16) {
#line 271
    return (-1);
  }
  {
#line 272
  reshdr.data_begin = get_bigendian_dword((unsigned char const   *)(data));
#line 273
  reshdr.map_begin = get_bigendian_dword((unsigned char const   *)(data + 4));
#line 274
  reshdr.data_length = get_bigendian_dword((unsigned char const   *)(data + 8));
#line 275
  reshdr.map_length = get_bigendian_dword((unsigned char const   *)(data + 12));
  }
#line 276
  if (debug___0) {
    {
#line 277
    fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"resource data: %ld %ld\n",
            reshdr.data_begin, reshdr.data_length);
#line 279
    fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"resource map: %ld %ld\n",
            reshdr.map_begin, reshdr.map_length);
    }
  }
  {
#line 283
  map_offset = res_offset + reshdr.map_begin;
#line 284
  gfile_seek(f, (long )map_offset, 0U);
#line 285
  tmp___0 = gfile_read(f, (void *)(& resmap.reshdr), 16U);
#line 285
  count = (int )tmp___0;
  }
#line 286
  if (count != 16) {
#line 287
    return (-1);
  }
  {
#line 288
  tmp___1 = gfile_read(f, (void *)(data), 14U);
#line 288
  count = (int )tmp___1;
  }
#line 289
  if (count != 14) {
#line 290
    return (-1);
  }
  {
#line 291
  resmap.reshdl = get_bigendian_dword((unsigned char const   *)(data));
#line 292
  resmap.filerefno = get_bigendian_word((unsigned char const   *)(data + 4));
#line 293
  resmap.attributes = get_bigendian_word((unsigned char const   *)(data + 6));
#line 294
  resmap.offset_type_list = get_bigendian_word((unsigned char const   *)(data + 8));
#line 295
  resmap.offset_name_list = get_bigendian_word((unsigned char const   *)(data + 10));
#line 296
  resmap.type_count = get_bigendian_word((unsigned char const   *)(data + 12));
  }
#line 298
  if (debug___0) {
    {
#line 299
    fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)" resource handle %ld\n",
            resmap.reshdl);
#line 300
    fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)" file reference number %d\n",
            (int )resmap.filerefno);
#line 302
    fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)" attributes 0x%x\n",
            (int )resmap.attributes);
#line 303
    fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)" offset type list %d\n",
            (int )resmap.offset_type_list);
#line 304
    fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)" offset name list %d\n",
            (int )resmap.offset_name_list);
#line 305
    fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)" type count %d\n",
            (int )resmap.type_count);
    }
  }
#line 313
  type_offset = map_offset + (DWORD )resmap.offset_type_list;
#line 314
  i = 0;
  {
#line 314
  while (1) {
    while_continue: /* CIL Label */ ;
#line 314
    if (! (i <= (int )resmap.type_count)) {
#line 314
      goto while_break;
    }
    {
#line 315
    gfile_seek(f, (long )((type_offset + 2UL) + (DWORD )(i * 8)), 0U);
#line 316
    tmp___2 = gfile_read(f, (void *)(& typelist.type), 4U);
#line 316
    count = (int )tmp___2;
    }
#line 317
    if (count != 4) {
#line 318
      return (-1);
    }
    {
#line 319
    tmp___3 = gfile_read(f, (void *)(data), 4U);
#line 319
    count = (int )tmp___3;
    }
#line 320
    if (count != 4) {
#line 321
      return (-1);
    }
    {
#line 322
    typelist.count = get_bigendian_word((unsigned char const   *)(data));
#line 323
    typelist.offset_ref_list = get_bigendian_word((unsigned char const   *)(data + 2));
    }
#line 324
    if (debug___0) {
      {
#line 325
      fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"type %d %c%c%c%c count=%d offset=%d\n",
              i, (int )typelist.type[0], (int )typelist.type[1], (int )typelist.type[2],
              (int )typelist.type[3], (int )typelist.count, (int )typelist.offset_ref_list);
      }
    }
#line 329
    ref_offset = type_offset + (DWORD )typelist.offset_ref_list;
#line 330
    j = 0;
    {
#line 330
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 330
      if (! (j <= (int )typelist.count)) {
#line 330
        goto while_break___0;
      }
      {
#line 331
      gfile_seek(f, (long )(ref_offset + (DWORD )(j * 12)), 0U);
#line 332
      tmp___4 = gfile_read(f, (void *)(data), 12U);
#line 332
      count = (int )tmp___4;
      }
#line 333
      if (count != 12) {
#line 334
        return (-1);
      }
      {
#line 335
      reflist.id = get_bigendian_word((unsigned char const   *)(data));
#line 336
      reflist.offset_name = get_bigendian_word((unsigned char const   *)(data + 2));
#line 337
      reflist.attributes = data[4];
#line 338
      reflist.offset_data = (DWORD )data[5] << 16;
#line 339
      reflist.offset_data += (DWORD )data[6] << 8;
#line 340
      reflist.offset_data += (DWORD )data[7];
#line 341
      reflist.handle = get_bigendian_dword((unsigned char const   *)(data + 8));
      }
#line 342
      if (debug___0) {
        {
#line 343
        fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"  reflist %d id=%d name=%d attributes=0x%x data=%ld 0x%lx\n",
                j, (int )reflist.id, (int )reflist.offset_name, (int )reflist.attributes,
                reflist.offset_data, reflist.offset_data);
#line 346
        gfile_seek(f, (long )((res_offset + reshdr.data_begin) + reflist.offset_data),
                   0U);
#line 348
        tmp___5 = gfile_read(f, (void *)(data), 4U);
#line 348
        count = (int )tmp___5;
        }
#line 349
        if (count != 4) {
#line 350
          return (-1);
        }
        {
#line 351
        tmp___6 = get_bigendian_dword((unsigned char const   *)(data));
#line 351
        tmp___7 = get_bigendian_dword((unsigned char const   *)(data));
#line 351
        fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"  length=%ld 0x%lx\n",
                tmp___7, tmp___6);
        }
      }
#line 356
      if ((DWORD )resmap.offset_name_list < reshdr.map_length) {
#line 356
        if ((int )resmap.offset_name_list != 65535) {
#line 356
          if ((int )reflist.offset_name != 65535) {
            {
#line 359
            gfile_seek(f, (long )((map_offset + (DWORD )resmap.offset_name_list) + (DWORD )reflist.offset_name),
                       0U);
#line 361
            tmp___8 = gfile_read(f, (void *)(data), 1U);
#line 361
            count = (int )tmp___8;
            }
#line 362
            if (count != 1) {
#line 363
              return (-1);
            }
#line 364
            name_length = (int )data[0];
#line 365
            if (name_length <= 256) {
              {
#line 366
              tmp___9 = gfile_read(f, (void *)(name), (unsigned int )name_length);
#line 366
              count = (int )tmp___9;
              }
#line 367
              if (count != name_length) {
#line 368
                return (-1);
              }
#line 369
              name[name_length] = (char )'\000';
#line 370
              if (debug___0) {
                {
#line 371
                fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"    name=%s\n",
                        name);
                }
              }
            }
          }
        }
      }
      {
#line 374
      tmp___10 = memcmp((void const   *)(typelist.type), (void const   *)"PICT", (size_t )4);
      }
#line 374
      if (tmp___10 == 0) {
#line 374
        if ((int )reflist.id == 256) {
#line 377
          preview_offset = (res_offset + reshdr.data_begin) + reflist.offset_data;
        }
      }
#line 330
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 314
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 383
  if (preview_offset != 0UL) {
    {
#line 384
    gfile_seek(f, (long )preview_offset, 0U);
#line 385
    gfile_read(f, (void *)(data), 4U);
#line 386
    preview_length = get_bigendian_dword((unsigned char const   *)(data));
    }
#line 387
    if (preview_length != 0UL) {
#line 388
      mac->pict_begin = preview_offset + 4UL;
#line 389
      mac->pict_length = preview_length;
    }
  }
#line 392
  return (0);
}
}
#line 398 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/cmac.c"
static int extract_mac_data(GFile *f , char const   *outname , unsigned long begin ,
                            unsigned long length , unsigned long header ) 
{ 
  unsigned long len ;
  unsigned int count ;
  char *buffer ;
  GFile *outfile ;
  int code ;
  void *tmp ;
  unsigned int tmp___0 ;
  unsigned long tmp___1 ;

  {
#line 406
  code = 0;
#line 407
  if (begin == 0UL) {
#line 408
    return (-1);
  } else
#line 407
  if (length == 0UL) {
#line 408
    return (-1);
  }
#line 410
  if ((int const   )*outname == 0) {
#line 411
    return (-1);
  }
  {
#line 414
  tmp = malloc((size_t )4096);
#line 414
  buffer = (char *)tmp;
  }
#line 415
  if ((unsigned long )buffer == (unsigned long )((char *)((void *)0))) {
#line 416
    return (-1);
  }
  {
#line 418
  outfile = gfile_open(outname, 4097U);
  }
#line 419
  if ((unsigned long )outfile == (unsigned long )((GFile *)((void *)0))) {
    {
#line 420
    free((void *)buffer);
    }
#line 421
    return (-1);
  }
  {
#line 425
  memset((void *)buffer, 0, (size_t )4096);
  }
#line 426
  if (header) {
#line 426
    if (header < 4096UL) {
      {
#line 427
      gfile_write(outfile, (void const   *)buffer, (unsigned int )header);
      }
    }
  }
  {
#line 429
  gfile_seek(f, (long )begin, 0U);
#line 430
  len = length;
  }
  {
#line 431
  while (1) {
    while_continue: /* CIL Label */ ;
#line 431
    if (len < 4096UL) {
#line 431
      tmp___1 = len;
    } else {
#line 431
      tmp___1 = 4096UL;
    }
#line 431
    count = (unsigned int )tmp___1;
#line 431
    if (! (count != 0U)) {
#line 431
      goto while_break;
    }
    {
#line 432
    tmp___0 = gfile_read(f, (void *)buffer, count);
#line 432
    count = (unsigned int )((int )tmp___0);
#line 433
    gfile_write(outfile, (void const   *)buffer, count);
    }
#line 434
    if (count == 0U) {
#line 435
      len = 0UL;
#line 436
      code = -1;
    } else {
#line 439
      len -= (unsigned long )count;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 441
  free((void *)buffer);
#line 442
  gfile_close(outfile);
  }
#line 444
  return (code);
}
}
#line 449 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/cmac.c"
int extract_mac_pict(GFile *f , CMACFILE *mac , char const   *outname ) 
{ 
  int tmp ;

  {
#line 452
  if ((unsigned long )f == (unsigned long )((void *)0)) {
#line 453
    return (-1);
  } else
#line 452
  if ((unsigned long )mac == (unsigned long )((void *)0)) {
#line 453
    return (-1);
  }
  {
#line 455
  tmp = extract_mac_data(f, outname, mac->pict_begin, mac->pict_length, 512UL);
  }
#line 455
  return (tmp);
}
}
#line 461 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/cmac.c"
int extract_mac_epsf(GFile *f , CMACFILE *mac , char const   *outname ) 
{ 
  int tmp ;

  {
#line 464
  if ((unsigned long )f == (unsigned long )((void *)0)) {
#line 465
    return (-1);
  } else
#line 464
  if ((unsigned long )mac == (unsigned long )((void *)0)) {
#line 465
    return (-1);
  }
  {
#line 466
  tmp = extract_mac_data(f, outname, mac->data_begin, mac->data_length, 0UL);
  }
#line 466
  return (tmp);
}
}
#line 474 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/cmac.c"
int write_resource_pict(GFile *f , char const   *pictname ) 
{ 
  GFile *pictfile ;
  unsigned long pict_length ;
  unsigned char data[256] ;
  unsigned long data_offset ;
  unsigned long map_length ;
  unsigned long pict_offset ;
  unsigned int resource_length ;
  unsigned long len ;
  unsigned int count ;
  int code ;
  unsigned long tmp ;
  unsigned int tmp___0 ;
  unsigned long tmp___1 ;

  {
  {
#line 480
  data_offset = 256UL;
#line 481
  map_length = 58UL;
#line 482
  pict_offset = 0UL;
#line 486
  code = 0;
#line 488
  pictfile = gfile_open(pictname, 0U);
  }
#line 489
  if ((unsigned long )pictfile == (unsigned long )((void *)0)) {
#line 490
    return (-1);
  }
  {
#line 491
  tmp = gfile_get_length(pictfile);
#line 491
  pict_length = tmp - 512UL;
  }
#line 492
  if ((long )pict_length < 0L) {
    {
#line 493
    gfile_close(pictfile);
    }
#line 494
    return (-1);
  }
#line 496
  resource_length = (unsigned int )(((data_offset + 4UL) + pict_length) + map_length);
#line 497
  if ((unsigned long )f == (unsigned long )((void *)0)) {
    {
#line 498
    gfile_close(pictfile);
    }
#line 499
    return ((int )resource_length);
  }
  {
#line 503
  memset((void *)(data), 0, sizeof(data));
#line 504
  put_bigendian_dword(data, data_offset);
#line 505
  put_bigendian_dword(data + 4, (data_offset + 4UL) + pict_length);
#line 506
  put_bigendian_dword(data + 8, pict_length + 4UL);
#line 507
  put_bigendian_dword(data + 12, map_length);
#line 508
  gfile_write(f, (void const   *)(data), (unsigned int )data_offset);
#line 511
  put_bigendian_dword(data, pict_length);
#line 512
  gfile_write(f, (void const   *)(data), 4U);
#line 513
  len = pict_length;
#line 514
  gfile_seek(pictfile, 512L, 0U);
  }
  {
#line 515
  while (1) {
    while_continue: /* CIL Label */ ;
#line 515
    if (len < sizeof(data)) {
#line 515
      tmp___1 = len;
    } else {
#line 515
      tmp___1 = sizeof(data);
    }
#line 515
    count = (unsigned int )tmp___1;
#line 515
    if (! (count != 0U)) {
#line 515
      goto while_break;
    }
    {
#line 516
    tmp___0 = gfile_read(pictfile, (void *)(data), count);
#line 516
    count = (unsigned int )((int )tmp___0);
#line 517
    gfile_write(f, (void const   *)(data), count);
    }
#line 518
    if (count == 0U) {
#line 519
      len = 0UL;
#line 520
      code = -1;
    } else {
#line 523
      len -= (unsigned long )count;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 525
  gfile_close(pictfile);
  }
#line 526
  if (code < 0) {
#line 527
    return (code);
  }
  {
#line 530
  memset((void *)(data), 0, sizeof(data));
#line 531
  put_bigendian_dword(data + 16, (DWORD )0);
#line 532
  put_bigendian_word(data + 20, (WORD )0);
#line 533
  put_bigendian_word(data + 22, (WORD )0);
#line 534
  put_bigendian_word(data + 24, (WORD )28);
#line 535
  put_bigendian_word(data + 26, (WORD )50);
#line 536
  gfile_write(f, (void const   *)(data), 28U);
#line 539
  memset((void *)(data), 0, sizeof(data));
#line 540
  put_bigendian_word(data, (WORD )0);
#line 541
  memcpy((void */* __restrict  */)(data + 2), (void const   */* __restrict  */)"PICT",
         (size_t )4);
#line 542
  put_bigendian_word(data + 6, (WORD )0);
#line 543
  put_bigendian_word(data + 8, (WORD )10);
#line 544
  gfile_write(f, (void const   *)(data), 10U);
#line 547
  memset((void *)(data), 0, sizeof(data));
#line 548
  put_bigendian_word(data, (WORD )256);
#line 549
  put_bigendian_word(data + 2, (WORD )0);
#line 550
  data[4] = (unsigned char )'\000';
#line 551
  data[5] = (unsigned char )((pict_offset >> 16) & 255UL);
#line 552
  data[6] = (unsigned char )((pict_offset >> 8) & 255UL);
#line 553
  data[7] = (unsigned char )(pict_offset & 255UL);
#line 554
  put_bigendian_dword(data + 8, (DWORD )0);
#line 555
  gfile_write(f, (void const   *)(data), 12U);
#line 558
  memset((void *)(data), 0, sizeof(data));
#line 559
  data[0] = (unsigned char)7;
#line 560
  memcpy((void */* __restrict  */)(data + 1), (void const   */* __restrict  */)"Preview",
         (size_t )7);
#line 561
  gfile_write(f, (void const   *)(data), 8U);
  }
#line 563
  return ((int )resource_length);
}
}
#line 567 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/cmac.c"
int write_appledouble(GFile *f , char const   *pictname ) 
{ 
  unsigned char data[256] ;
  unsigned long resource_length ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 574
  tmp = write_resource_pict((GFile *)((void *)0), pictname);
#line 574
  resource_length = (unsigned long )tmp;
#line 576
  memset((void *)(data), 0, sizeof(data));
#line 577
  memcpy((void */* __restrict  */)(data), (void const   */* __restrict  */)(apple_double_magic),
         (size_t )4);
#line 578
  put_bigendian_dword(data + 4, (DWORD )131072);
#line 580
  put_bigendian_word(data + 24, (WORD )2);
#line 582
  put_bigendian_dword(data + 26, (DWORD )9);
#line 583
  put_bigendian_dword(data + 30, (DWORD )50);
#line 584
  put_bigendian_dword(data + 34, (DWORD )32);
#line 586
  put_bigendian_dword(data + 38, (DWORD )2);
#line 587
  put_bigendian_dword(data + 42, (DWORD )82);
#line 588
  put_bigendian_dword(data + 46, resource_length);
#line 590
  memcpy((void */* __restrict  */)(data + 50), (void const   */* __restrict  */)"EPSF",
         (size_t )4);
#line 591
  memcpy((void */* __restrict  */)(data + 54), (void const   */* __restrict  */)"MSWD",
         (size_t )4);
#line 592
  data[58] = (unsigned char)1;
#line 593
  gfile_write(f, (void const   *)(data), 82U);
#line 596
  tmp___0 = write_resource_pict(f, pictname);
  }
#line 596
  if (tmp___0 <= 0) {
#line 597
    return (-1);
  }
#line 598
  return (0);
}
}
#line 605 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/cmac.c"
int write_applesingle(GFile *f , char const   *epsname , char const   *pictname ) 
{ 
  unsigned long resource_length ;
  unsigned long data_length ;
  unsigned char data[256] ;
  unsigned char *buffer ;
  GFile *epsfile ;
  unsigned long len ;
  unsigned int count ;
  int code ;
  void *tmp ;
  int tmp___0 ;
  unsigned int tmp___1 ;
  unsigned long tmp___2 ;
  int tmp___3 ;

  {
  {
#line 615
  code = 0;
#line 617
  tmp = malloc((size_t )4096);
#line 617
  buffer = (unsigned char *)tmp;
  }
#line 618
  if ((unsigned long )buffer == (unsigned long )((unsigned char *)((void *)0))) {
#line 619
    return (-1);
  }
  {
#line 622
  epsfile = gfile_open(epsname, 0U);
  }
#line 623
  if ((unsigned long )epsname == (unsigned long )((void *)0)) {
    {
#line 624
    free((void *)buffer);
    }
#line 625
    return (-1);
  }
  {
#line 627
  data_length = gfile_get_length(epsfile);
#line 628
  tmp___0 = write_resource_pict((GFile *)((void *)0), pictname);
#line 628
  resource_length = (unsigned long )tmp___0;
#line 630
  memset((void *)(data), 0, sizeof(data));
#line 631
  memcpy((void */* __restrict  */)(data), (void const   */* __restrict  */)(apple_single_magic),
         (size_t )4);
#line 632
  put_bigendian_dword(data + 4, (DWORD )131072);
#line 634
  put_bigendian_word(data + 24, (WORD )3);
#line 636
  put_bigendian_dword(data + 26, (DWORD )9);
#line 637
  put_bigendian_dword(data + 30, (DWORD )62);
#line 638
  put_bigendian_dword(data + 34, (DWORD )32);
#line 640
  put_bigendian_dword(data + 38, (DWORD )1);
#line 641
  put_bigendian_dword(data + 42, (DWORD )94);
#line 642
  put_bigendian_dword(data + 46, data_length);
#line 644
  put_bigendian_dword(data + 50, (DWORD )2);
#line 645
  put_bigendian_dword(data + 54, 94UL + data_length);
#line 646
  put_bigendian_dword(data + 58, resource_length);
#line 648
  memcpy((void */* __restrict  */)(data + 62), (void const   */* __restrict  */)"EPSF",
         (size_t )4);
#line 649
  memcpy((void */* __restrict  */)(data + 66), (void const   */* __restrict  */)"MSWD",
         (size_t )4);
#line 650
  data[70] = (unsigned char)1;
#line 651
  gfile_write(f, (void const   *)(data), 94U);
#line 654
  len = data_length;
  }
  {
#line 655
  while (1) {
    while_continue: /* CIL Label */ ;
#line 655
    if (len < 4096UL) {
#line 655
      tmp___2 = len;
    } else {
#line 655
      tmp___2 = 4096UL;
    }
#line 655
    count = (unsigned int )tmp___2;
#line 655
    if (! (count != 0U)) {
#line 655
      goto while_break;
    }
    {
#line 656
    tmp___1 = gfile_read(epsfile, (void *)buffer, count);
#line 656
    count = (unsigned int )((int )tmp___1);
#line 657
    gfile_write(f, (void const   *)buffer, count);
    }
#line 658
    if (count == 0U) {
#line 659
      len = 0UL;
#line 660
      code = -1;
    } else {
#line 663
      len -= (unsigned long )count;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 665
  gfile_close(epsfile);
#line 666
  free((void *)buffer);
  }
#line 667
  if (code < 0) {
#line 668
    return (code);
  }
  {
#line 671
  tmp___3 = write_resource_pict(f, pictname);
  }
#line 671
  if (tmp___3 <= 0) {
#line 672
    return (-1);
  }
#line 673
  return (0);
}
}
#line 681 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/cmac.c"
int write_macbin(GFile *f , char const   *name , char const   *epsname , char const   *pictname ) 
{ 
  unsigned char *buffer ;
  unsigned char data[128] ;
  char const   *macname ;
  int macname_length ;
  unsigned long data_length ;
  unsigned long resource_length ;
  unsigned long len ;
  unsigned int count ;
  int code ;
  GFile *epsfile ;
  time_t now ;
  time_t tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  unsigned int tmp___5 ;
  unsigned long tmp___6 ;
  int tmp___7 ;

  {
  {
#line 692
  code = 0;
#line 694
  tmp = time((time_t *)((void *)0));
#line 694
  now = tmp;
#line 695
  now = (time_t )((unsigned long )now + 2082844800UL);
#line 696
  macname = name;
  }
#line 697
  if ((int const   )*(name + 0) == 0) {
#line 698
    macname = "Unknown";
  }
  {
#line 700
  tmp___0 = malloc((size_t )4096);
#line 700
  buffer = (unsigned char *)tmp___0;
  }
#line 701
  if ((unsigned long )buffer == (unsigned long )((unsigned char *)((void *)0))) {
#line 702
    return (-1);
  }
  {
#line 705
  epsfile = gfile_open(epsname, 0U);
  }
#line 706
  if ((unsigned long )epsname == (unsigned long )((void *)0)) {
    {
#line 707
    free((void *)buffer);
    }
#line 708
    return (-1);
  }
  {
#line 710
  data_length = gfile_get_length(epsfile);
#line 711
  tmp___1 = write_resource_pict((GFile *)((void *)0), pictname);
#line 711
  resource_length = (unsigned long )tmp___1;
#line 714
  memset((void *)(data), 0, sizeof(data));
#line 715
  data[0] = (unsigned char)0;
#line 716
  tmp___4 = strlen(macname);
  }
#line 716
  if (63 < (int )tmp___4) {
#line 716
    macname_length = 63;
  } else {
    {
#line 716
    tmp___3 = strlen(macname);
#line 716
    macname_length = (int )tmp___3;
    }
  }
  {
#line 717
  data[1] = (unsigned char )macname_length;
#line 718
  memcpy((void */* __restrict  */)(data + 2), (void const   */* __restrict  */)macname,
         (size_t )macname_length);
#line 719
  memcpy((void */* __restrict  */)(data + 65), (void const   */* __restrict  */)"EPSF",
         (size_t )4);
#line 720
  memcpy((void */* __restrict  */)(data + 69), (void const   */* __restrict  */)"MSWD",
         (size_t )4);
#line 721
  data[73] = (unsigned char)1;
#line 722
  put_bigendian_dword(data + 83, data_length);
#line 723
  put_bigendian_dword(data + 87, resource_length);
#line 724
  put_bigendian_dword(data + 91, (DWORD )now);
#line 725
  put_bigendian_dword(data + 95, (DWORD )now);
#line 726
  gfile_write(f, (void const   *)(data), 128U);
#line 729
  len = data_length;
  }
  {
#line 730
  while (1) {
    while_continue: /* CIL Label */ ;
#line 730
    if (len < 4096UL) {
#line 730
      tmp___6 = len;
    } else {
#line 730
      tmp___6 = 4096UL;
    }
#line 730
    count = (unsigned int )tmp___6;
#line 730
    if (! (count != 0U)) {
#line 730
      goto while_break;
    }
    {
#line 731
    tmp___5 = gfile_read(epsfile, (void *)buffer, count);
#line 731
    count = (unsigned int )((int )tmp___5);
#line 732
    gfile_write(f, (void const   *)buffer, count);
    }
#line 733
    if (count == 0U) {
#line 734
      len = 0UL;
#line 735
      code = -1;
    } else {
#line 738
      len -= (unsigned long )count;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 740
  gfile_close(epsfile);
#line 741
  free((void *)buffer);
  }
#line 742
  if (code < 0) {
#line 743
    return (code);
  }
  {
#line 746
  memset((void *)(data), 0, sizeof(data));
#line 747
  count = (unsigned int )(data_length & 127UL);
  }
#line 748
  if (count) {
    {
#line 749
    gfile_write(f, (void const   *)(data), 128U - count);
    }
  }
  {
#line 752
  tmp___7 = write_resource_pict(f, pictname);
  }
#line 752
  if (tmp___7 <= 0) {
#line 753
    return (-1);
  }
#line 756
  count = (unsigned int )(resource_length & 127UL);
#line 757
  if (count) {
    {
#line 758
    gfile_write(f, (void const   *)(data), 128U - count);
    }
  }
#line 760
  return (0);
}
}
#line 766 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/cmac.c"
int dump_macfile(char const   *filename , int verbose ) 
{ 
  CMACFILE *mac ;
  char const   *p ;
  GFile *f ;
  GFile *tmp ;

  {
  {
#line 770
  tmp = gfile_open(filename, 0U);
#line 770
  f = tmp;
  }
#line 771
  if ((unsigned long )f == (unsigned long )((void *)0)) {
#line 772
    return (-1);
  }
  {
#line 773
  mac = get_mactype(f);
  }
#line 774
  if (mac) {
    {
#line 775
    get_pict(f, mac, verbose > 1);
    }
  }
  {
#line 777
  gfile_close(f);
  }
#line 779
  if ((unsigned long )mac == (unsigned long )((void *)0)) {
#line 780
    return (1);
  }
#line 781
  if (verbose) {
    {
#line 783
    if ((unsigned int )mac->type == 1U) {
#line 783
      goto case_1;
    }
#line 786
    if ((unsigned int )mac->type == 2U) {
#line 786
      goto case_2;
    }
#line 789
    if ((unsigned int )mac->type == 3U) {
#line 789
      goto case_3;
    }
#line 792
    if ((unsigned int )mac->type == 4U) {
#line 792
      goto case_4;
    }
#line 795
    goto switch_default;
    case_1: /* CIL Label */ 
#line 784
    p = "AppleSingle";
#line 785
    goto switch_break;
    case_2: /* CIL Label */ 
#line 787
    p = "AppleDouble";
#line 788
    goto switch_break;
    case_3: /* CIL Label */ 
#line 790
    p = "MacBinary";
#line 791
    goto switch_break;
    case_4: /* CIL Label */ 
#line 793
    p = "Resource";
#line 794
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 796
    p = "Unknown";
    switch_break: /* CIL Label */ ;
    }
    {
#line 798
    fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"Macintosh Binary Format: %s\n",
            p);
#line 799
    fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)" File Type: %c%c%c%c\n",
            (int )mac->file_type[0], (int )mac->file_type[1], (int )mac->file_type[2],
            (int )mac->file_type[3]);
#line 802
    fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)" File Creator: %c%c%c%c\n",
            (int )mac->file_creator[0], (int )mac->file_creator[1], (int )mac->file_creator[2],
            (int )mac->file_creator[3]);
#line 805
    fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)" Finder Info: %ld %ld\n",
            mac->finder_begin, mac->finder_length);
#line 807
    fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)" Data Fork: %ld %ld\n",
            mac->data_begin, mac->data_length);
#line 809
    fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)" Resource Fork: %ld %ld\n",
            mac->resource_begin, mac->resource_length);
#line 811
    fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)" PICT: %ld %ld, 0x%lx 0x%lx\n",
            mac->pict_begin, mac->pict_length, mac->pict_begin, mac->pict_length);
    }
  }
  {
#line 815
  free((void *)mac);
  }
#line 816
  return (0);
}
}
#line 58 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/clzw.c"
static void lzw_reset(lzw_state_t *state ) 
{ 
  int i ;
  lzw_code_t *table ;

  {
#line 62
  table = state->table;
#line 63
  state->next_code = (short)258;
#line 64
  state->code_bit_length = 9;
#line 65
  state->code_change = (short )((1 << state->code_bit_length) - 1);
#line 66
  state->bytes_in = 0;
#line 67
  state->bytes_out = 0;
#line 68
  i = 0;
  {
#line 68
  while (1) {
    while_continue: /* CIL Label */ ;
#line 68
    if (! (i < 5021)) {
#line 68
      goto while_break;
    }
#line 69
    (table + i)->code = (short)-1;
#line 70
    (table + i)->base_code = (short)-1;
#line 71
    (table + i)->ch = (unsigned char)0;
#line 68
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 73
  return;
}
}
#line 75 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/clzw.c"
static void lzw_init(lzw_state_t *state ) 
{ 


  {
  {
#line 78
  memset((void *)state, 0, sizeof(lzw_state_t ));
#line 79
  state->next_code = (short)258;
#line 80
  state->code_bit_length = 9;
#line 81
  state->output_bits = 0;
#line 82
  state->output_bits_count = 0;
#line 83
  state->lzwstr = (short)-1;
#line 84
  lzw_reset(state);
  }
#line 85
  return;
}
}
#line 87 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/clzw.c"
lzw_state_t *lzw_new(void) 
{ 
  lzw_state_t *state ;
  void *tmp ;

  {
  {
#line 90
  tmp = malloc(sizeof(lzw_state_t ));
#line 90
  state = (lzw_state_t *)tmp;
  }
#line 91
  if ((unsigned long )state != (unsigned long )((lzw_state_t *)((void *)0))) {
    {
#line 92
    lzw_init(state);
    }
  }
#line 93
  return (state);
}
}
#line 98 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/clzw.c"
static int lzw_find_match(lzw_code_t *table , short code , unsigned char ch ) 
{ 
  int i ;
  int hash_offset ;
  int tmp ;

  {
#line 101
  i = ((int )ch << 4) ^ (int )code;
#line 102
  if (i == 0) {
#line 102
    tmp = 1;
  } else {
#line 102
    tmp = 5021 - i;
  }
#line 102
  hash_offset = tmp;
  {
#line 104
  while (1) {
    while_continue: /* CIL Label */ ;
#line 104
    if (! table) {
#line 104
      goto while_break;
    }
#line 105
    if ((int )(table + i)->code == -1) {
#line 106
      goto while_break;
    } else
#line 107
    if ((int )(table + i)->base_code == (int )code) {
#line 107
      if ((int )(table + i)->ch == (int )ch) {
#line 108
        goto while_break;
      } else {
#line 107
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
#line 111
      i += hash_offset;
#line 112
      if (i >= 5021) {
#line 113
        i -= 5021;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 116
  return (i);
}
}
#line 119 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/clzw.c"
void lzw_compress(lzw_state_t *state , unsigned char const   *inbuf , int *inlen ,
                  unsigned char *outbuf , int *outlen ) 
{ 
  int icount ;
  int ilen ;
  int ocount ;
  int olen ;
  unsigned char ch ;
  int hash_index ;
  int bits ;
  int len ;
  int code_len ;
  short lzwstr ;
  short next_code ;
  lzw_code_t *table ;
  int do_reset ;
  int bytes_in ;
  int bytes_out ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  short tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
#line 124
  icount = 0;
#line 125
  ilen = *inlen;
#line 126
  ocount = 0;
#line 127
  olen = *outlen;
#line 130
  bits = state->output_bits;
#line 131
  len = state->output_bits_count;
#line 132
  code_len = state->code_bit_length;
#line 133
  lzwstr = state->lzwstr;
#line 134
  next_code = state->next_code;
#line 135
  table = state->table;
#line 136
  do_reset = 0;
#line 137
  bytes_in = state->bytes_in;
#line 138
  bytes_out = state->bytes_out;
#line 140
  if ((int )lzwstr == -1) {
#line 142
    tmp = icount;
#line 142
    icount ++;
#line 142
    lzwstr = (short )*(inbuf + tmp);
#line 144
    bits = 256;
#line 145
    len = code_len;
  }
  {
#line 148
  while (1) {
    while_continue: /* CIL Label */ ;
#line 148
    if (len >= 8) {
#line 148
      if (! (ocount < olen)) {
#line 148
        goto while_break;
      }
    } else {
#line 148
      goto while_break;
    }
#line 149
    tmp___0 = ocount;
#line 149
    ocount ++;
#line 149
    *(outbuf + tmp___0) = (unsigned char )(bits >> (len - 8));
#line 150
    len -= 8;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 152
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 152
    if (icount < ilen) {
#line 152
      if (! (ocount < olen)) {
#line 152
        goto while_break___0;
      }
    } else {
#line 152
      goto while_break___0;
    }
    {
#line 153
    tmp___1 = icount;
#line 153
    icount ++;
#line 153
    ch = (unsigned char )*(inbuf + tmp___1);
#line 154
    hash_index = lzw_find_match(table, lzwstr, ch);
    }
#line 155
    if ((int )(table + hash_index)->code != -1) {
#line 156
      lzwstr = (table + hash_index)->code;
    } else {
#line 159
      bits = (bits << code_len) + (int )lzwstr;
#line 160
      len += code_len;
      {
#line 161
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 161
        if (len >= 8) {
#line 161
          if (! (ocount < olen)) {
#line 161
            goto while_break___1;
          }
        } else {
#line 161
          goto while_break___1;
        }
#line 162
        tmp___2 = ocount;
#line 162
        ocount ++;
#line 162
        *(outbuf + tmp___2) = (unsigned char )(bits >> (len - 8));
#line 163
        len -= 8;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 166
      if ((int )next_code == (int )state->code_change) {
#line 167
        code_len ++;
#line 167
        state->code_bit_length = code_len;
#line 168
        state->code_change = (short )((1 << code_len) - 1);
#line 170
        bytes_in = state->bytes_in + icount;
#line 171
        bytes_out = state->bytes_out + ocount;
#line 172
        if (bytes_out > bytes_in + bytes_in / 16) {
#line 175
          do_reset = 1;
        }
      }
#line 179
      if (do_reset) {
#line 179
        goto _L;
      } else
#line 179
      if ((int )next_code >= 4094) {
        _L: /* CIL Label */ 
#line 181
        bits = (bits << code_len) + 256;
#line 182
        len += code_len;
        {
#line 183
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 183
          if (len >= 8) {
#line 183
            if (! (ocount < olen)) {
#line 183
              goto while_break___2;
            }
          } else {
#line 183
            goto while_break___2;
          }
#line 184
          tmp___3 = ocount;
#line 184
          ocount ++;
#line 184
          *(outbuf + tmp___3) = (unsigned char )(bits >> (len - 8));
#line 185
          len -= 8;
        }
        while_break___2: /* CIL Label */ ;
        }
        {
#line 187
        lzw_reset(state);
#line 188
        lzwstr = (short )ch;
#line 189
        next_code = state->next_code;
#line 190
        code_len = state->code_bit_length;
#line 191
        do_reset = 0;
        }
      } else {
#line 195
        tmp___4 = next_code;
#line 195
        next_code = (short )((int )next_code + 1);
#line 195
        (table + hash_index)->code = tmp___4;
#line 196
        (table + hash_index)->base_code = lzwstr;
#line 197
        (table + hash_index)->ch = ch;
#line 198
        lzwstr = (short )ch;
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 202
  if (*inlen == 0) {
#line 204
    bits = ((bits << 2 * code_len) + ((int )lzwstr << code_len)) + 257;
#line 205
    len += 2 * code_len;
    {
#line 206
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 206
      if (len >= 8) {
#line 206
        if (! (ocount < olen)) {
#line 206
          goto while_break___3;
        }
      } else {
#line 206
        goto while_break___3;
      }
#line 207
      tmp___5 = ocount;
#line 207
      ocount ++;
#line 207
      *(outbuf + tmp___5) = (unsigned char )(bits >> (len - 8));
#line 208
      len -= 8;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 210
    if (len > 0) {
#line 210
      if (ocount < olen) {
#line 211
        tmp___6 = ocount;
#line 211
        ocount ++;
#line 211
        *(outbuf + tmp___6) = (unsigned char )(bits << (8 - len));
      }
    }
  }
#line 215
  state->output_bits = bits;
#line 216
  state->output_bits_count = len;
#line 217
  state->code_bit_length = code_len;
#line 218
  state->lzwstr = lzwstr;
#line 219
  state->next_code = next_code;
#line 220
  state->bytes_in += icount;
#line 221
  state->bytes_out += ocount;
#line 222
  *outlen = ocount;
#line 223
  *inlen = icount;
#line 224
  return;
}
}
#line 226 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/clzw.c"
void lzw_free(lzw_state_t *state ) 
{ 


  {
  {
#line 229
  free((void *)state);
  }
#line 230
  return;
}
}
#line 26 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/xnodll.c"
static int dll_msg(char *msg , char const   *str , int msglen ) 
{ 
  int len ;
  size_t tmp ;

  {
  {
#line 29
  tmp = strlen(str);
#line 29
  len = (int )tmp;
  }
#line 30
  if (len < msglen) {
    {
#line 31
    strncat((char */* __restrict  */)msg, (char const   */* __restrict  */)str, (size_t )len);
#line 32
    msglen -= len;
    }
  }
#line 34
  return (msglen);
}
}
#line 41 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/xnodll.c"
int dll_open(void **hmodule , char const   *name , char *msg , int msglen ) 
{ 


  {
  {
#line 44
  memset((void *)msg, 0, (size_t )msglen);
#line 45
  msglen = dll_msg(msg, "Trying to load ", msglen);
#line 46
  msglen = dll_msg(msg, name, msglen);
#line 47
  msglen = dll_msg(msg, "\n", msglen);
#line 48
  msglen = dll_msg(msg, "Can\'t load libraries on this platform.\n", msglen);
#line 49
  *hmodule = (void *)0;
  }
#line 50
  return (-1);
}
}
#line 54 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/xnodll.c"
int dll_close(void **hmodule ) 
{ 


  {
#line 57
  return (-1);
}
}
#line 60 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/xnodll.c"
dll_proc dll_sym(void **hmodule , char const   *name ) 
{ 


  {
#line 63
  return ((dll_proc )((void *)0));
}
}
#line 51 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/cdoc.h"
int doc_ref(Doc *d ) ;
#line 53
GSview *doc_app(Doc *doc ) ;
#line 54
View **doc_views(Doc *doc ) ;
#line 58
BOOL doc_is_open(Doc *doc ) ;
#line 59
void doc_ignore_dsc(Doc *doc , BOOL flag ) ;
#line 62
void doc_dump(Doc *doc ) ;
#line 64
int doc_page_limit(Doc *doc , int page ) ;
#line 66
void doc_info(Doc *doc , DocInfo *info ) ;
#line 67
void doc_ordlabel(Doc *doc , char *buf , int buflen , int page_number ) ;
#line 68
int doc_copyfile(Doc *doc , char const   *filename ) ;
#line 35 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/cdoc.c"
static int doc_scan(Doc *doc ) ;
#line 36
static int doc_init(Doc *doc ) ;
#line 37
static int doc_gunzip(Doc *doc ) ;
#line 38
static int doc_bunzip2(Doc *doc ) ;
#line 39
static int doc_msg_len(void *handle , char const   *str , int len ) ;
#line 40
static PclType doc_pl_parse(char const   *str , int len , unsigned int *resolution ) ;
#line 41
static int doc_pl_readline(char const   *str , int len ) ;
#line 42
static PclType doc_pjl_parse(char const   *str , int len , unsigned int *resolution ) ;
#line 45
void doc_message(void *caller_data , char const   *str ) ;
#line 46
int show_dsc_error(void *caller_data , CDSC *dsc , unsigned int explanation , char const   *line ,
                   unsigned int line_len ) ;
#line 51 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/cdoc.c"
Doc *doc_new(GSview *a ) 
{ 
  Doc *d ;
  void *tmp ;

  {
  {
#line 54
  tmp = malloc(sizeof(Doc ));
#line 54
  d = (Doc *)tmp;
  }
#line 55
  if ((unsigned long )d == (unsigned long )((void *)0)) {
    {
#line 56
    app_msg(a, "Out of memory\n");
    }
#line 57
    return ((Doc *)((void *)0));
  }
  {
#line 59
  app_lock(a);
#line 60
  doc_init(d);
#line 61
  d->app = a;
#line 62
  app_ref(a);
#line 63
  doc_ref(d);
#line 64
  app_unlock(a);
  }
#line 65
  return (d);
}
}
#line 70 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/cdoc.c"
int doc_add(Doc *d , GSview *a ) 
{ 
  Doc *dn ;
  Doc **tmp ;
  Doc **tmp___0 ;

  {
  {
#line 74
  app_lock(a);
#line 75
  tmp = app_docs(a);
#line 75
  dn = *tmp;
  }
  {
#line 76
  while (1) {
    while_continue: /* CIL Label */ ;
#line 76
    if (dn) {
#line 76
      if (! dn->next) {
#line 76
        goto while_break;
      }
    } else {
#line 76
      goto while_break;
    }
#line 77
    dn = dn->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 78
  if ((unsigned long )dn == (unsigned long )((void *)0)) {
    {
#line 79
    tmp___0 = app_docs(a);
#line 79
    *tmp___0 = d;
    }
  } else {
#line 81
    dn->next = d;
  }
  {
#line 82
  doc_ref(d);
#line 83
  app_unlock(a);
  }
#line 84
  return (0);
}
}
#line 88 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/cdoc.c"
int doc_remove(Doc *d ) 
{ 
  GSview *a ;
  int code ;
  Doc *dn ;
  Doc **tmp ;
  char str[16] ;
  size_t tmp___0 ;
  Doc **tmp___1 ;
  char str___0[15] ;
  size_t tmp___2 ;

  {
  {
#line 91
  a = d->app;
#line 92
  code = 0;
#line 94
  app_lock(a);
#line 95
  tmp = app_docs(a);
#line 95
  dn = *tmp;
  }
#line 96
  if ((unsigned long )dn == (unsigned long )((void *)0)) {
    {
#line 98
    str[0] = (char )'A';
#line 98
    str[1] = (char )'p';
#line 98
    str[2] = (char )'p';
#line 98
    str[3] = (char )' ';
#line 98
    str[4] = (char )'h';
#line 98
    str[5] = (char )'a';
#line 98
    str[6] = (char )'s';
#line 98
    str[7] = (char )' ';
#line 98
    str[8] = (char )'n';
#line 98
    str[9] = (char )'o';
#line 98
    str[10] = (char )' ';
#line 98
    str[11] = (char )'D';
#line 98
    str[12] = (char )'o';
#line 98
    str[13] = (char )'c';
#line 98
    str[14] = (char )'\n';
#line 98
    str[15] = (char )'\000';
#line 100
    tmp___0 = strlen((char const   *)(str));
#line 100
    app_msg_len_nolock(a, (char const   *)(str), (int )tmp___0);
#line 101
    code = -1;
    }
  } else
#line 103
  if ((unsigned long )dn == (unsigned long )d) {
    {
#line 104
    tmp___1 = app_docs(a);
#line 104
    *tmp___1 = d->next;
#line 105
    doc_unref(d);
    }
  } else {
    {
#line 108
    while (1) {
      while_continue: /* CIL Label */ ;
#line 108
      if (dn) {
#line 108
        if (! ((unsigned long )dn->next != (unsigned long )d)) {
#line 108
          goto while_break;
        }
      } else {
#line 108
        goto while_break;
      }
#line 109
      dn = dn->next;
    }
    while_break: /* CIL Label */ ;
    }
#line 110
    if (dn) {
#line 110
      if ((unsigned long )dn->next == (unsigned long )d) {
        {
#line 111
        dn->next = d->next;
#line 112
        doc_unref(d);
        }
      } else {
#line 110
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
      {
#line 115
      str___0[0] = (char )'D';
#line 115
      str___0[1] = (char )'o';
#line 115
      str___0[2] = (char )'c';
#line 115
      str___0[3] = (char )' ';
#line 115
      str___0[4] = (char )'n';
#line 115
      str___0[5] = (char )'o';
#line 115
      str___0[6] = (char )'t';
#line 115
      str___0[7] = (char )' ';
#line 115
      str___0[8] = (char )'f';
#line 115
      str___0[9] = (char )'o';
#line 115
      str___0[10] = (char )'u';
#line 115
      str___0[11] = (char )'n';
#line 115
      str___0[12] = (char )'d';
#line 115
      str___0[13] = (char )'\n';
#line 115
      str___0[14] = (char )'\000';
#line 117
      tmp___2 = strlen((char const   *)(str___0));
#line 117
      app_msg_len_nolock(a, (char const   *)(str___0), (int )tmp___2);
#line 118
      code = -1;
      }
    }
  }
  {
#line 121
  app_unlock(a);
  }
#line 122
  return (code);
}
}
#line 129 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/cdoc.c"
int doc_ref(Doc *d ) 
{ 
  int refcount ;
  char buf[256] ;
  size_t tmp ;

  {
#line 132
  (d->refcount) ++;
#line 132
  refcount = d->refcount;
#line 133
  if (debug & 128) {
    {
#line 135
    snprintf((char */* __restrict  */)(buf), sizeof(buf), (char const   */* __restrict  */)"doc refcount=%d\n",
             refcount);
#line 136
    buf[sizeof(buf) - 1UL] = (char )'\000';
#line 137
    tmp = strlen((char const   *)(buf));
#line 137
    app_msg_len_nolock(d->app, (char const   *)(buf), (int )tmp);
    }
  }
#line 139
  return (refcount);
}
}
#line 145 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/cdoc.c"
int doc_unref(Doc *d ) 
{ 
  int refcount ;
  GSview *a ;
  char buf[256] ;
  size_t tmp ;

  {
#line 149
  a = d->app;
#line 150
  if (d->refcount > 0) {
#line 151
    (d->refcount) --;
  }
#line 152
  refcount = d->refcount;
#line 153
  if (debug & 128) {
    {
#line 155
    snprintf((char */* __restrict  */)(buf), sizeof(buf), (char const   */* __restrict  */)"doc refcount=%d\n",
             refcount);
#line 156
    buf[sizeof(buf) - 1UL] = (char )'\000';
#line 157
    tmp = strlen((char const   *)(buf));
#line 157
    app_msg_len_nolock(d->app, (char const   *)(buf), (int )tmp);
    }
  }
#line 159
  if (d->refcount == 0) {
    {
#line 160
    doc_close(d);
#line 161
    d->app = (GSview *)((void *)0);
#line 162
    app_unref(a);
#line 163
    memset((void *)d, 0, sizeof(Doc ));
#line 164
    free((void *)d);
    }
  }
#line 166
  return (refcount);
}
}
#line 169 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/cdoc.c"
GSview *doc_app(Doc *doc ) 
{ 


  {
#line 172
  return (doc->app);
}
}
#line 176 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/cdoc.c"
static int doc_init(Doc *doc ) 
{ 


  {
  {
#line 179
  memset((void *)doc, 0, sizeof(Doc ));
#line 180
  doc->handle = (void *)0;
#line 181
  doc->app = (GSview *)((void *)0);
#line 182
  doc->next = (Doc *)((void *)0);
#line 183
  doc->viewlist = (View *)((void *)0);
#line 184
  doc->doctype = (DocType )0;
#line 185
  doc->page_count = -1;
#line 186
  doc->ignore_dsc = 0;
#line 187
  doc->dsc_warn = 1;
#line 188
  doc->verbose = 1;
  }
#line 189
  return (0);
}
}
#line 192 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/cdoc.c"
int doc_close(Doc *doc ) 
{ 


  {
#line 204
  if (doc->tname[0]) {
    {
#line 205
    unlink((char const   *)(doc->tname));
    }
  }
  {
#line 207
  memset((void *)(doc->name), 0, sizeof(doc->name));
#line 208
  memset((void *)(doc->tname), 0, sizeof(doc->tname));
#line 209
  doc->doctype = (DocType )0;
#line 210
  doc->gzip = 0;
#line 211
  doc->bzip2 = 0;
#line 212
  doc->page_count = 0;
#line 213
  doc->length1 = 0UL;
#line 214
  doc->length2 = 0UL;
#line 215
  doc->time1 = 0UL;
#line 216
  doc->time2 = 0UL;
  }
#line 218
  if (doc->dsc) {
    {
#line 219
    dsc_unref(doc->dsc);
    }
  }
#line 220
  doc->dsc = (CDSC *)((void *)0);
#line 225
  doc->ctrld = 0;
#line 226
  doc->pjl = 0;
#line 228
  if (doc->pdfscan) {
    {
#line 229
    pdf_scan_close(doc->pdfscan);
    }
  }
#line 230
  doc->pdfscan = (PDFSCAN *)((void *)0);
#line 231
  return (0);
}
}
#line 239 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/cdoc.c"
int doc_open(Doc *doc , char const   *filename ) 
{ 
  int code ;

  {
  {
#line 243
  doc_close(doc);
#line 244
  strncpy((char */* __restrict  */)(doc->name), (char const   */* __restrict  */)filename,
          sizeof(doc->name) / sizeof(char ) - 1UL);
#line 245
  code = doc_scan(doc);
  }
#line 246
  if (code < 0) {
    {
#line 247
    doc_close(doc);
    }
  }
#line 248
  return (code);
}
}
#line 251 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/cdoc.c"
DocType doc_type(Doc *doc ) 
{ 


  {
#line 254
  return (doc->doctype);
}
}
#line 257 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/cdoc.c"
BOOL doc_is_open(Doc *doc ) 
{ 


  {
#line 260
  return ((int )doc->name[0] != 0);
}
}
#line 263 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/cdoc.c"
void doc_ignore_dsc(Doc *doc , BOOL flag ) 
{ 


  {
#line 266
  doc->ignore_dsc = flag;
#line 267
  return;
}
}
#line 269 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/cdoc.c"
void doc_dsc_warn(Doc *doc , int level ) 
{ 


  {
#line 272
  doc->dsc_warn = level;
#line 273
  return;
}
}
#line 275 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/cdoc.c"
void doc_verbose(Doc *doc , BOOL verbose ) 
{ 


  {
#line 278
  doc->verbose = verbose;
#line 279
  return;
}
}
#line 281 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/cdoc.c"
void doc_message(void *caller_data , char const   *str ) 
{ 


  {
  {
#line 284
  app_msg(((Doc *)caller_data)->app, str);
  }
#line 285
  return;
}
}
#line 289 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/cdoc.c"
void doc_dump(Doc *doc ) 
{ 


  {
  {
#line 292
  app_csmsgf(doc->app, "DSC dump for %.200s\n", doc->name);
#line 293
  dsc_display(doc->dsc, & doc_message);
#line 294
  app_csmsgf(doc->app, "End of DSC dump\n");
  }
#line 295
  return;
}
}
#line 297 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/cdoc.c"
int show_dsc_error(void *caller_data , CDSC *dsc , unsigned int explanation , char const   *line ,
                   unsigned int line_len ) 
{ 
  Doc *doc ;
  int response ;
  int severity ;
  char buf[256] ;
  int len ;
  char title[256] ;
  char linefmt[256] ;
  int i ;
  char *p ;
  int length ;
  unsigned long tmp ;
  void *tmp___0 ;
  int len___0 ;
  int wlen ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  size_t tmp___5 ;

  {
#line 301
  doc = (Doc *)caller_data;
#line 302
  response = 1;
#line 311
  if (explanation > dsc->max_error) {
#line 312
    return (0);
  }
#line 314
  severity = (int )*(dsc->severity + explanation);
#line 318
  if (dsc->debug_print_fn) {
    {
#line 320
    if (severity == 0) {
#line 320
      goto case_0;
    }
#line 323
    if (severity == 1) {
#line 323
      goto case_1;
    }
#line 326
    if (severity == 2) {
#line 326
      goto case_2;
    }
#line 319
    goto switch_break;
    case_0: /* CIL Label */ 
    {
#line 321
    dsc_debug_print(dsc, "\nDSC Information");
    }
#line 322
    goto switch_break;
    case_1: /* CIL Label */ 
    {
#line 324
    dsc_debug_print(dsc, "\nDSC Warning");
    }
#line 325
    goto switch_break;
    case_2: /* CIL Label */ 
    {
#line 327
    dsc_debug_print(dsc, "\nDSC Error");
    }
#line 328
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
    {
#line 330
    dsc_debug_print(dsc, "\n");
    }
#line 331
    if (explanation <= dsc->max_error) {
#line 332
      if (line) {
#line 332
        if (line_len) {
#line 333
          if ((unsigned long )line_len < sizeof(buf) - 1UL) {
#line 333
            tmp = (unsigned long )line_len;
          } else {
#line 333
            tmp = sizeof(buf) - 1UL;
          }
          {
#line 333
          length = (int )tmp;
#line 334
          snprintf((char */* __restrict  */)(buf), sizeof(buf), (char const   */* __restrict  */)"At line %d:\n",
                   dsc->line_count);
#line 335
          buf[sizeof(buf) - 1UL] = (char )'\000';
#line 336
          dsc_debug_print(dsc, (char const   *)(buf));
#line 337
          strncpy((char */* __restrict  */)(buf), (char const   */* __restrict  */)line,
                  (size_t )length);
#line 338
          buf[length] = (char )'\000';
#line 339
          dsc_debug_print(dsc, "  ");
#line 340
          dsc_debug_print(dsc, (char const   *)(buf));
          }
        }
      }
      {
#line 342
      dsc_debug_print(dsc, (char const   *)dsc_message[explanation]);
      }
    }
  }
#line 347
  if (severity <= doc->dsc_warn) {
#line 348
    return (response);
  }
  {
#line 351
  if (severity == 0) {
#line 351
    goto case_0___0;
  }
#line 354
  if (severity == 1) {
#line 354
    goto case_1___0;
  }
#line 357
  if (severity == 2) {
#line 357
    goto case_2___0;
  }
#line 360
  goto switch_default;
  case_0___0: /* CIL Label */ 
#line 352
  i = 2250;
#line 353
  goto switch_break___0;
  case_1___0: /* CIL Label */ 
#line 355
  i = 2251;
#line 356
  goto switch_break___0;
  case_2___0: /* CIL Label */ 
#line 358
  i = 2252;
#line 359
  goto switch_break___0;
  switch_default: /* CIL Label */ 
#line 361
  i = -1;
  switch_break___0: /* CIL Label */ ;
  }
#line 363
  if (i != -1) {
    {
#line 364
    load_string(doc->app, i, title, (int )(sizeof(title) / sizeof(char )));
    }
  } else {
#line 366
    title[0] = (char )'\000';
  }
  {
#line 370
  tmp___0 = malloc(4096UL * sizeof(char ));
#line 370
  p = (char *)tmp___0;
#line 371
  memset((void *)p, 0, 4096UL * sizeof(char ));
  }
#line 372
  if ((unsigned long )p == (unsigned long )((char *)((void *)0))) {
#line 373
    return (response);
  }
#line 375
  if (line) {
    {
#line 378
    load_string(doc->app, 2253, linefmt, (int )(sizeof(linefmt) / sizeof(char )));
#line 379
    snprintf((char */* __restrict  */)p, (size_t )4096, (char const   */* __restrict  */)(linefmt),
             title, dsc->line_count);
#line 380
    tmp___1 = strlen((char const   *)p);
#line 380
    strncat((char */* __restrict  */)p, (char const   */* __restrict  */)"\n   ",
            4095UL - tmp___1);
#line 381
    tmp___2 = strlen((char const   *)p);
#line 381
    len___0 = (int )tmp___2;
    }
#line 382
    if (line_len > 256U) {
#line 383
      line_len = 256U;
    }
    {
#line 384
    wlen = narrow_to_cs((char *)((void *)0), 0, line, (int )line_len);
#line 385
    narrow_to_cs(p + len___0, 4095 - len___0, line, (int )line_len);
#line 386
    *(p + (len___0 + wlen)) = (char )'\000';
    }
  } else {
    {
#line 389
    strncpy((char */* __restrict  */)p, (char const   */* __restrict  */)(title),
            (size_t )4095);
#line 390
    tmp___3 = strlen((char const   *)p);
#line 390
    strncat((char */* __restrict  */)p, (char const   */* __restrict  */)"\n", 4095UL - tmp___3);
    }
  }
  {
#line 392
  tmp___4 = strlen((char const   *)p);
#line 392
  len = (int )tmp___4;
#line 393
  load_string(doc->app, (int )(2400U + explanation * 2U), p + len, 4096 - len);
#line 395
  tmp___5 = strlen((char const   *)p);
#line 395
  len = (int )tmp___5;
#line 396
  load_string(doc->app, (int )((2400U + explanation * 2U) + 1U), p + len, 4096 - len);
#line 399
  response = get_dsc_response(doc->app, (char const   *)p);
#line 401
  free((void *)p);
  }
#line 403
  if (dsc->debug_print_fn) {
    {
#line 405
    if (response == 0) {
#line 405
      goto case_0___1;
    }
#line 408
    if (response == 1) {
#line 408
      goto case_1___1;
    }
#line 411
    if (response == 2) {
#line 411
      goto case_2___1;
    }
#line 404
    goto switch_break___1;
    case_0___1: /* CIL Label */ 
    {
#line 406
    dsc_debug_print(dsc, "Response = OK\n");
    }
#line 407
    goto switch_break___1;
    case_1___1: /* CIL Label */ 
    {
#line 409
    dsc_debug_print(dsc, "Response = Cancel\n");
    }
#line 410
    goto switch_break___1;
    case_2___1: /* CIL Label */ 
    {
#line 412
    dsc_debug_print(dsc, "Response = Ignore All DSC\n");
    }
#line 413
    goto switch_break___1;
    switch_break___1: /* CIL Label */ ;
    }
  }
#line 417
  return (response);
}
}
#line 420 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/cdoc.c"
char const   *doc_name(Doc *doc ) 
{ 


  {
#line 424
  if ((int )doc->tname[0] != 0) {
#line 424
    if (doc->gzip) {
#line 425
      return ((char const   *)(doc->tname));
    } else
#line 424
    if (doc->bzip2) {
#line 425
      return ((char const   *)(doc->tname));
    }
  }
#line 427
  return ((char const   *)(doc->name));
}
}
#line 432 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/cdoc.c"
static int doc_gunzip(Doc *doc ) 
{ 
  GFile *outfile ;
  int code ;
  char name[512] ;
  char buf[256] ;
  size_t tmp ;

  {
  {
#line 438
  outfile = app_temp_gfile(doc->app, doc->tname, (int )(sizeof(doc->tname) / sizeof(char ) - 1UL));
  }
#line 438
  if ((unsigned long )outfile == (unsigned long )((GFile *)((void *)0))) {
    {
#line 442
    load_string(doc->app, 662, buf, (int )(sizeof(buf) / sizeof(char )));
#line 443
    app_csmsg(doc->app, (char const   *)(buf));
    }
#line 444
    return (-1);
  }
  {
#line 447
  tmp = strlen((char const   *)(doc->name));
#line 447
  cs_to_narrow(name, (int )(sizeof(name) - 1UL), (char const   *)(doc->name), (int )tmp + 1);
#line 448
  app_msg(doc->app, "Uncompressing ");
#line 449
  app_msg(doc->app, (char const   *)(name));
#line 450
  app_msg(doc->app, " to ");
#line 451
  app_csmsg(doc->app, (char const   *)(doc->tname));
#line 452
  app_msg(doc->app, "\n");
#line 454
  code = zlib_uncompress(doc->app, outfile, (char const   *)(name));
#line 455
  gfile_close(outfile);
  }
#line 456
  if (code != 0) {
    {
#line 457
    unlink((char const   *)(doc->tname));
#line 458
    doc->tname[0] = (char )'\000';
    }
#line 459
    return (-1);
  }
#line 462
  return (0);
}
}
#line 467 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/cdoc.c"
static int doc_bunzip2(Doc *doc ) 
{ 
  GFile *outfile ;
  int code ;
  char name[512] ;
  char buf[256] ;
  size_t tmp ;

  {
  {
#line 473
  outfile = app_temp_gfile(doc->app, doc->tname, (int )(sizeof(doc->tname) / sizeof(char ) - 1UL));
  }
#line 473
  if ((unsigned long )outfile == (unsigned long )((GFile *)((void *)0))) {
    {
#line 477
    load_string(doc->app, 662, buf, (int )(sizeof(buf) / sizeof(char )));
#line 478
    app_csmsg(doc->app, (char const   *)(buf));
    }
#line 479
    return (-1);
  }
  {
#line 482
  tmp = strlen((char const   *)(doc->name));
#line 482
  cs_to_narrow(name, (int )(sizeof(name) - 1UL), (char const   *)(doc->name), (int )tmp + 1);
#line 483
  app_msg(doc->app, "Uncompressing ");
#line 484
  app_msg(doc->app, (char const   *)(name));
#line 485
  app_msg(doc->app, " to ");
#line 486
  app_csmsg(doc->app, (char const   *)(doc->tname));
#line 487
  app_msg(doc->app, "\n");
#line 489
  code = bzip2_uncompress(doc->app, outfile, (char const   *)(name));
#line 490
  gfile_close(outfile);
  }
#line 491
  if (code != 0) {
    {
#line 492
    unlink((char const   *)(doc->tname));
#line 493
    doc->tname[0] = (char )'\000';
    }
#line 494
    return (-1);
  }
#line 497
  return (0);
}
}
#line 509 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/cdoc.c"
static PclType doc_pl_parse(char const   *str , int len , unsigned int *resolution ) 
{ 
  PclType type ;
  int tmp ;
  int tmp___0 ;

  {
#line 512
  *resolution = 0U;
#line 513
  if (len >= 9) {
    {
#line 513
    tmp___0 = memcmp((void const   *)str, (void const   *)"\033%-12345X", (size_t )9);
    }
#line 513
    if (tmp___0 == 0) {
      {
#line 514
      type = doc_pjl_parse(str, len, resolution);
      }
    } else {
#line 513
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 515
  if (len >= 11) {
    {
#line 515
    tmp = memcmp((void const   *)str, (void const   *)") HP-PCL XL", (size_t )11);
    }
#line 515
    if (tmp == 0) {
#line 516
      type = (PclType )2;
    } else {
#line 515
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 517
  if (len >= 2) {
#line 517
    if ((int const   )*(str + 0) == 27) {
#line 517
      if ((int const   )*(str + 1) == 37) {
#line 519
        type = (PclType )1;
      } else
#line 517
      if ((int const   )*(str + 1) == 69) {
#line 519
        type = (PclType )1;
      } else
#line 517
      if ((int const   )*(str + 1) == 42) {
#line 519
        type = (PclType )1;
      } else
#line 517
      if ((int const   )*(str + 1) == 38) {
#line 519
        type = (PclType )1;
      } else {
#line 521
        type = (PclType )0;
      }
    } else {
#line 521
      type = (PclType )0;
    }
  } else {
#line 521
    type = (PclType )0;
  }
#line 522
  return (type);
}
}
#line 527 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/cdoc.c"
static int doc_pl_readline(char const   *str , int len ) 
{ 
  int i ;

  {
#line 529
  i = 0;
  {
#line 531
  while (1) {
    while_continue: /* CIL Label */ ;
#line 531
    if (i < len) {
#line 531
      if ((int const   )*(str + i) != 13) {
#line 531
        if (! ((int const   )*(str + i) != 10)) {
#line 531
          goto while_break;
        }
      } else {
#line 531
        goto while_break;
      }
    } else {
#line 531
      goto while_break;
    }
#line 532
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 534
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 534
    if (i < len) {
#line 534
      if (! ((int const   )*(str + i) == 13)) {
#line 534
        if (! ((int const   )*(str + i) == 10)) {
#line 534
          goto while_break___0;
        }
      }
    } else {
#line 534
      goto while_break___0;
    }
#line 535
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 536
  return (i);
}
}
#line 549 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/cdoc.c"
static PclType doc_pjl_parse(char const   *str , int len , unsigned int *resolution ) 
{ 
  PclType type ;
  char const   *p ;
  int idx ;
  int count ;
  int i ;
  char buf[16] ;
  int bufcnt ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
#line 551
  type = (PclType )1;
#line 553
  idx = 0;
#line 558
  if (len < 9) {
#line 559
    return ((PclType )0);
  } else {
    {
#line 558
    tmp = memcmp((void const   *)str, (void const   *)"\033%-12345X", (size_t )9);
    }
#line 558
    if (tmp != 0) {
#line 559
      return ((PclType )0);
    }
  }
#line 560
  idx = 9;
  {
#line 561
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 561
    count = doc_pl_readline(str + idx, len - idx);
    }
#line 561
    if (! (count != 0)) {
#line 561
      goto while_break;
    }
#line 562
    p = str + idx;
#line 563
    if (count >= 9) {
      {
#line 563
      tmp___0 = memcmp((void const   *)p, (void const   *)"\033%-12345X", (size_t )9);
      }
#line 563
      if (tmp___0 == 0) {
#line 564
        count -= 9;
#line 565
        p += 9;
#line 566
        idx += 9;
#line 567
        if (count == 0) {
#line 568
          goto while_break;
        }
      }
    }
#line 570
    if ((int const   )*p != 64) {
#line 571
      goto while_break;
    }
#line 572
    if (count >= 19) {
      {
#line 572
      tmp___6 = memcmp((void const   *)p, (void const   *)"@PJL SET RESOLUTION", (size_t )19);
      }
#line 572
      if (tmp___6 == 0) {
#line 574
        i = 19;
        {
#line 575
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 575
          if (i < count) {
#line 575
            if (! ((int const   )*(p + i) == 32)) {
#line 575
              goto while_break___0;
            }
          } else {
#line 575
            goto while_break___0;
          }
#line 576
          i ++;
        }
        while_break___0: /* CIL Label */ ;
        }
#line 577
        if (i < count) {
#line 577
          if ((int const   )*(p + i) == 61) {
#line 578
            i ++;
            {
#line 579
            while (1) {
              while_continue___1: /* CIL Label */ ;
#line 579
              if (i < count) {
#line 579
                if (! ((int const   )*(p + i) == 32)) {
#line 579
                  goto while_break___1;
                }
              } else {
#line 579
                goto while_break___1;
              }
#line 580
              i ++;
            }
            while_break___1: /* CIL Label */ ;
            }
#line 582
            if (count - i < (int )sizeof(buf) - 1) {
#line 582
              bufcnt = count - i;
            } else {
#line 582
              bufcnt = (int )sizeof(buf) - 1;
            }
            {
#line 583
            memcpy((void */* __restrict  */)(buf), (void const   */* __restrict  */)(p + i),
                   (size_t )bufcnt);
#line 584
            buf[bufcnt] = (char )'\000';
#line 585
            tmp___1 = atoi((char const   *)(buf));
#line 585
            *resolution = (unsigned int )tmp___1;
            }
          }
        }
      } else {
#line 572
        goto _L___1;
      }
    } else
    _L___1: /* CIL Label */ 
#line 588
    if (count >= 19) {
      {
#line 588
      tmp___5 = memcmp((void const   *)p, (void const   *)"@PJL ENTER LANGUAGE", (size_t )19);
      }
#line 588
      if (tmp___5 == 0) {
#line 590
        i = 19;
        {
#line 591
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 591
          if (i < count) {
#line 591
            if (! ((int const   )*(p + i) == 32)) {
#line 591
              goto while_break___2;
            }
          } else {
#line 591
            goto while_break___2;
          }
#line 592
          i ++;
        }
        while_break___2: /* CIL Label */ ;
        }
#line 593
        if (i < count) {
#line 593
          if ((int const   )*(p + i) == 61) {
#line 594
            i ++;
            {
#line 595
            while (1) {
              while_continue___3: /* CIL Label */ ;
#line 595
              if (i < count) {
#line 595
                if (! ((int const   )*(p + i) == 32)) {
#line 595
                  goto while_break___3;
                }
              } else {
#line 595
                goto while_break___3;
              }
#line 596
              i ++;
            }
            while_break___3: /* CIL Label */ ;
            }
#line 598
            if (count - i >= 10) {
              {
#line 598
              tmp___4 = memcmp((void const   *)(p + i), (void const   *)"POSTSCRIPT",
                               (size_t )10);
              }
#line 598
              if (tmp___4 == 0) {
#line 600
                type = (PclType )3;
              } else {
#line 598
                goto _L___0;
              }
            } else
            _L___0: /* CIL Label */ 
#line 601
            if (count - i >= 5) {
              {
#line 601
              tmp___3 = memcmp((void const   *)(p + i), (void const   *)"PCLXL", (size_t )5);
              }
#line 601
              if (tmp___3 == 0) {
#line 603
                type = (PclType )2;
              } else {
#line 601
                goto _L;
              }
            } else
            _L: /* CIL Label */ 
#line 604
            if (count - i >= 3) {
              {
#line 604
              tmp___2 = memcmp((void const   *)(p + i), (void const   *)"PCL", (size_t )3);
              }
#line 604
              if (tmp___2 == 0) {
#line 606
                type = (PclType )1;
              }
            }
          }
        }
      }
    }
#line 609
    idx += count;
  }
  while_break: /* CIL Label */ ;
  }
#line 611
  return (type);
}
}
#line 619 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/cdoc.c"
static int doc_scan(Doc *doc ) 
{ 
  char line[4096] ;
  unsigned long file_length ;
  GFile *f ;
  CDSC *dsc ;
  PclType pcltype ;
  char const   *tmp ;
  int tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  int tmp___3 ;
  char const   *tmp___4 ;
  char const   *tmp___5 ;
  char const   *tmp___6 ;
  int tmp___7 ;
  size_t tmp___8 ;
  int tmp___9 ;
  int code ;
  int count ;
  char *d ;
  void *tmp___10 ;
  unsigned int tmp___11 ;
  BOOL bad_header ;
  char buf[256] ;

  {
  {
#line 626
  pcltype = (PclType )0;
#line 628
  f = gfile_open((char const   *)(doc->name), 0U);
  }
#line 628
  if ((unsigned long )f == (unsigned long )((GFile *)((void *)0))) {
    {
#line 629
    app_msg(doc->app, "File \"");
#line 630
    tmp = doc_name(doc);
#line 630
    app_csmsg(doc->app, tmp);
#line 631
    app_msg(doc->app, "\" does not exist\n");
    }
#line 632
    return (-1);
  }
#line 635
  if (doc->dsc) {
    {
#line 636
    dsc_unref(doc->dsc);
    }
  }
  {
#line 637
  doc->dsc = (CDSC *)((void *)0);
#line 640
  memset((void *)(line), 0, sizeof(line));
#line 641
  gfile_read(f, (void *)(line), (unsigned int )(sizeof(line) - 1UL));
#line 642
  gfile_seek(f, 0L, 0U);
#line 645
  doc->gzip = 0;
#line 646
  doc->bzip2 = 0;
  }
#line 647
  if ((int )line[0] == 31) {
#line 647
    if ((int )line[1] == -117) {
      {
#line 648
      doc->gzip = 1;
#line 649
      gfile_close(f);
#line 650
      tmp___0 = doc_gunzip(doc);
      }
#line 650
      if (tmp___0 != 0) {
        {
#line 651
        app_msg(doc->app, "Failed to gunzip file\n");
        }
#line 652
        return (-1);
      }
      {
#line 654
      tmp___2 = doc_name(doc);
#line 654
      f = gfile_open(tmp___2, 0U);
      }
#line 654
      if ((unsigned long )f == (unsigned long )((GFile *)((void *)0))) {
        {
#line 655
        app_msg(doc->app, "File \'");
#line 656
        tmp___1 = doc_name(doc);
#line 656
        app_csmsg(doc->app, tmp___1);
#line 657
        app_msg(doc->app, "\' does not exist\n");
        }
#line 658
        return (-1);
      }
      {
#line 660
      gfile_read(f, (void *)(line), (unsigned int )(sizeof(line) - 1UL));
#line 661
      gfile_seek(f, 0L, 0U);
      }
    }
  }
#line 665
  if ((int )line[0] == 66) {
#line 665
    if ((int )line[1] == 90) {
#line 665
      if ((int )line[2] == 104) {
        {
#line 666
        doc->bzip2 = 1;
#line 667
        gfile_close(f);
#line 668
        tmp___3 = doc_bunzip2(doc);
        }
#line 668
        if (tmp___3 != 0) {
          {
#line 669
          app_msg(doc->app, "Failed to uncompress bzip2 file\n");
          }
#line 670
          return (-1);
        }
        {
#line 672
        tmp___5 = doc_name(doc);
#line 672
        f = gfile_open(tmp___5, 0U);
        }
#line 672
        if ((unsigned long )f == (unsigned long )((GFile *)((void *)0))) {
          {
#line 673
          app_msg(doc->app, "File \'");
#line 674
          tmp___4 = doc_name(doc);
#line 674
          app_csmsg(doc->app, tmp___4);
#line 675
          app_msg(doc->app, "\' does not exist\n");
          }
#line 676
          return (-1);
        }
        {
#line 678
        gfile_read(f, (void *)(line), (unsigned int )(sizeof(line) - 1UL));
#line 679
        gfile_seek(f, 0L, 0U);
        }
      }
    }
  }
  {
#line 682
  file_length = gfile_get_length(f);
#line 685
  doc_savestat(doc);
#line 687
  doc->doctype = (DocType )0;
#line 688
  doc->dpi = 0U;
#line 691
  tmp___7 = strncmp("%PDF-", (char const   *)(line), (size_t )5);
  }
#line 691
  if (tmp___7 == 0) {
    {
#line 692
    gfile_close(f);
#line 693
    doc->doctype = (DocType )2;
#line 694
    doc->page_count = 0;
    }
#line 695
    if (doc->pdfscan) {
      {
#line 696
      pdf_scan_close(doc->pdfscan);
      }
    }
    {
#line 697
    doc->pdfscan = (PDFSCAN *)((void *)0);
#line 698
    tmp___6 = doc_name(doc);
#line 698
    doc->pdfscan = pdf_scan_open(tmp___6, (void *)doc->app, & doc_msg_len);
#line 699
    doc->page_count = pdf_scan_page_count(doc->pdfscan);
    }
#line 700
    if (debug & 1) {
      {
#line 701
      app_msgf(doc->app, "PDF page count %d\n", doc->page_count);
      }
    }
#line 702
    return (0);
  }
  {
#line 719
  tmp___8 = strlen((char const   *)(line));
#line 719
  pcltype = doc_pl_parse((char const   *)(line), (int )tmp___8, & doc->dpi);
  }
#line 720
  if ((unsigned int )pcltype == 1U) {
#line 720
    goto _L;
  } else
#line 720
  if ((unsigned int )pcltype == 2U) {
    _L: /* CIL Label */ 
#line 721
    doc->doctype = (DocType )3;
#line 722
    if (debug & 1) {
      {
#line 723
      app_msgf(doc->app, "Document is PCL or PXL\n");
      }
    }
    {
#line 724
    gfile_close(f);
    }
#line 725
    return (0);
  }
#line 730
  if ((int )line[0] == 66) {
#line 730
    if ((int )line[1] == 77) {
      {
#line 735
      doc->doctype = (DocType )4;
#line 736
      doc->page_count = 1;
#line 737
      gfile_close(f);
      }
#line 738
      return (0);
    } else {
#line 730
      goto _L___2;
    }
  } else
  _L___2: /* CIL Label */ 
#line 730
  if ((int )line[0] == 80) {
#line 730
    if ((int )line[1] >= 49) {
#line 730
      if ((int )line[1] <= 54) {
        {
#line 735
        doc->doctype = (DocType )4;
#line 736
        doc->page_count = 1;
#line 737
        gfile_close(f);
        }
#line 738
        return (0);
      } else {
#line 730
        goto _L___1;
      }
    } else {
#line 730
      goto _L___1;
    }
  } else
  _L___1: /* CIL Label */ 
#line 730
  if ((int )((unsigned char )line[0]) == 137) {
#line 730
    if ((int )line[1] == 80) {
#line 730
      if ((int )line[2] == 78) {
#line 730
        if ((int )line[3] == 71) {
          {
#line 735
          doc->doctype = (DocType )4;
#line 736
          doc->page_count = 1;
#line 737
          gfile_close(f);
          }
#line 738
          return (0);
        }
      }
    }
  }
  {
#line 742
  doc->doctype = (DocType )1;
#line 745
  doc->ctrld = (int )line[0] == 4;
#line 747
  doc->pjl = 0;
#line 748
  tmp___9 = strncmp("\033%-12345X", (char const   *)(line), (size_t )9);
  }
#line 748
  if (tmp___9 == 0) {
#line 749
    doc->pjl = 1;
  }
#line 750
  if (doc->ignore_dsc) {
#line 751
    doc->dsc = (CDSC *)((void *)0);
  } else {
    {
#line 753
    code = 0;
#line 756
    doc->dsc = (CDSC *)((void *)0);
#line 757
    tmp___10 = malloc((size_t )4096);
#line 757
    d = (char *)tmp___10;
    }
#line 757
    if ((unsigned long )d == (unsigned long )((void *)0)) {
#line 758
      return (-1);
    }
    {
#line 760
    doc->dsc = dsc_new((void *)doc);
    }
#line 761
    if (doc->verbose) {
      {
#line 762
      dsc_set_debug_function(doc->dsc, & doc_message);
      }
    }
    {
#line 763
    dsc_set_error_function(doc->dsc, & show_dsc_error);
#line 764
    dsc_set_length(doc->dsc, file_length);
    }
    {
#line 765
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 765
      tmp___11 = gfile_read(f, (void *)d, 4096U);
#line 765
      count = (int )tmp___11;
      }
#line 765
      if (! (count != 0)) {
#line 765
        goto while_break;
      }
      {
#line 766
      code = dsc_scan_data(doc->dsc, (char const   *)d, count);
      }
#line 767
      if (code == -1) {
#line 769
        goto while_break;
      } else
#line 767
      if (code == 1) {
#line 769
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 772
    if (code == -1) {
      {
#line 773
      dsc_unref(doc->dsc);
#line 774
      doc->dsc = (CDSC *)((void *)0);
      }
    } else
#line 772
    if (code == 1) {
      {
#line 773
      dsc_unref(doc->dsc);
#line 774
      doc->dsc = (CDSC *)((void *)0);
      }
    } else {
      {
#line 777
      dsc_fixup(doc->dsc);
      }
    }
    {
#line 779
    free((void *)d);
    }
  }
  {
#line 781
  gfile_close(f);
#line 784
  dsc = doc->dsc;
  }
#line 785
  if ((unsigned long )dsc == (unsigned long )((CDSC *)((void *)0))) {
#line 786
    return (1);
  }
#line 788
  if (dsc->doseps) {
#line 789
    bad_header = 0;
#line 791
    if ((dsc->doseps)->ps_begin > file_length) {
#line 792
      bad_header = 1;
    }
#line 793
    if ((dsc->doseps)->ps_begin + (dsc->doseps)->ps_length > file_length) {
#line 794
      bad_header = 1;
    }
#line 795
    if ((dsc->doseps)->wmf_begin > file_length) {
#line 796
      bad_header = 1;
    }
#line 797
    if ((dsc->doseps)->wmf_begin + (dsc->doseps)->wmf_length > file_length) {
#line 798
      bad_header = 1;
    }
#line 799
    if ((dsc->doseps)->tiff_begin > file_length) {
#line 800
      bad_header = 1;
    }
#line 801
    if ((dsc->doseps)->tiff_begin + (dsc->doseps)->tiff_length > file_length) {
#line 802
      bad_header = 1;
    }
#line 803
    if (bad_header) {
      {
#line 805
      load_string(doc->app, 670, buf, (int )(sizeof(buf) / sizeof(char )));
#line 807
      app_csmsgf(doc->app, "%s\n", buf);
#line 808
      app_msg_box(doc->app, (char const   *)(buf), 0);
#line 810
      dsc_unref(doc->dsc);
#line 811
      doc->dsc = (CDSC *)((void *)0);
      }
#line 812
      return (-1);
    }
  }
#line 816
  if (debug & 1) {
    {
#line 817
    doc_dump(doc);
    }
  }
#line 819
  return (0);
}
}
#line 824 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/cdoc.c"
int doc_map_page(Doc *doc , int page ) 
{ 


  {
#line 827
  if ((unsigned long )doc->dsc != (unsigned long )((CDSC *)((void *)0))) {
#line 828
    if ((doc->dsc)->page_order == 2U) {
#line 829
      return ((int )(((doc->dsc)->page_count - 1U) - (unsigned int )page));
    }
  }
#line 830
  return (page);
}
}
#line 833 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/cdoc.c"
int doc_page_limit(Doc *doc , int page ) 
{ 


  {
#line 836
  if ((unsigned long )doc == (unsigned long )((void *)0)) {
#line 837
    return (0);
  }
#line 838
  if ((unsigned int )doc->doctype == 1U) {
#line 839
    if (doc->dsc) {
#line 840
      if (page >= (int )(doc->dsc)->page_count) {
#line 841
        page = (int )((doc->dsc)->page_count - 1U);
      }
#line 842
      if (page < 0) {
#line 843
        page = 0;
      }
    } else
#line 845
    if (doc->page_count) {
#line 846
      if (page >= doc->page_count) {
#line 847
        page = doc->page_count - 1;
      }
    }
  } else
#line 850
  if ((unsigned int )doc->doctype == 2U) {
#line 851
    if (page >= doc->page_count) {
#line 852
      page = doc->page_count - 1;
    }
#line 853
    if (page < 0) {
#line 854
      page = 0;
    }
  } else
#line 856
  if ((unsigned int )doc->doctype == 4U) {
#line 857
    page = 0;
  }
#line 858
  return (page);
}
}
#line 862 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/cdoc.c"
View **doc_views(Doc *doc ) 
{ 


  {
#line 865
  return (& doc->viewlist);
}
}
#line 869 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/cdoc.c"
static char *csappend(char *dest , char const   *src , int len ) 
{ 
  size_t tmp ;
  char *tmp___0 ;

  {
  {
#line 872
  tmp = strlen((char const   *)dest);
#line 872
  tmp___0 = strncat((char */* __restrict  */)dest, (char const   */* __restrict  */)src,
                    ((unsigned long )len - (unsigned long )((int )tmp) / sizeof(char )) - 1UL);
  }
#line 872
  return (tmp___0);
}
}
#line 876 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/cdoc.c"
void doc_info(Doc *doc , DocInfo *info ) 
{ 
  char buf[256] ;
  CDSC *dsc ;
  int typelen ;
  size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  int wlen ;
  size_t tmp___2 ;
  int tmp___3 ;

  {
  {
#line 880
  dsc = doc->dsc;
#line 882
  memset((void *)info, 0, sizeof(DocInfo ));
#line 883
  tmp = strlen((char const   *)(doc->name));
  }
#line 883
  if (tmp) {
    {
#line 884
    strncpy((char */* __restrict  */)(info->name), (char const   */* __restrict  */)(doc->name),
            sizeof(info->name) / sizeof(char ));
    }
  } else {
    {
#line 886
    load_string(doc->app, 611, info->name, (int )(sizeof(info->name) / sizeof(char )));
    }
  }
#line 889
  typelen = (int )(sizeof(info->type) / sizeof(char ));
#line 890
  if (doc->gzip) {
    {
#line 891
    csappend(info->type, "gzip ", typelen);
    }
  }
#line 892
  if (doc->bzip2) {
    {
#line 893
    csappend(info->type, "bzip2 ", typelen);
    }
  }
#line 894
  if (dsc) {
    {
#line 895
    load_string(doc->app, 633, buf, (int )(sizeof(buf) / sizeof(char )));
    }
#line 896
    if (doc->ctrld) {
      {
#line 897
      csappend(info->type, (char const   *)(buf), typelen);
      }
    }
    {
#line 898
    load_string(doc->app, 634, buf, (int )(sizeof(buf) / sizeof(char )));
    }
#line 899
    if (doc->pjl) {
      {
#line 900
      csappend(info->type, (char const   *)(buf), typelen);
      }
    }
    {
#line 901
    load_string(doc->app, 635, buf, (int )(sizeof(buf) / sizeof(char )));
    }
#line 902
    if (dsc->dcs2) {
      {
#line 903
      csappend(info->type, (char const   *)(buf), typelen);
      }
    }
#line 904
    if (dsc->epsf) {
      {
#line 910
      if (dsc->preview == 1U) {
#line 910
        goto case_1;
      }
#line 914
      if (dsc->preview == 2U) {
#line 914
        goto case_2;
      }
#line 918
      if (dsc->preview == 3U) {
#line 918
        goto case_3;
      }
#line 906
      goto switch_default;
      switch_default: /* CIL Label */ 
#line 908
      buf[0] = (char )'\000';
#line 909
      goto switch_break;
      case_1: /* CIL Label */ 
      {
#line 911
      load_string(doc->app, 626, buf, (int )(sizeof(buf) / sizeof(char )));
      }
#line 913
      goto switch_break;
      case_2: /* CIL Label */ 
      {
#line 915
      load_string(doc->app, 627, buf, (int )(sizeof(buf) / sizeof(char )));
      }
#line 917
      goto switch_break;
      case_3: /* CIL Label */ 
      {
#line 919
      load_string(doc->app, 628, buf, (int )(sizeof(buf) / sizeof(char )));
      }
#line 921
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
      {
#line 923
      csappend(info->type, (char const   *)(buf), typelen);
      }
    } else {
      {
#line 926
      load_string(doc->app, 629, buf, (int )(sizeof(buf) / sizeof(char )));
#line 927
      csappend(info->type, (char const   *)(buf), typelen);
      }
    }
#line 929
    if (dsc->dsc_title) {
      {
#line 930
      tmp___0 = strlen((char const   *)dsc->dsc_title);
#line 930
      narrow_to_cs(info->title, (int )(sizeof(info->title) / sizeof(char ) - 1UL),
                   (char const   *)dsc->dsc_title, (int )tmp___0 + 1);
      }
    }
#line 932
    if (dsc->dsc_date) {
      {
#line 933
      tmp___1 = strlen((char const   *)dsc->dsc_date);
#line 933
      narrow_to_cs(info->date, (int )(sizeof(info->date) / sizeof(char ) - 1UL), (char const   *)dsc->dsc_date,
                   (int )tmp___1 + 1);
      }
    }
#line 935
    if (dsc->bbox) {
      {
#line 936
      snprintf((char */* __restrict  */)(buf), sizeof(buf) / sizeof(char ), (char const   */* __restrict  */)"%d %d %d %d",
               (dsc->bbox)->llx, (dsc->bbox)->lly, (dsc->bbox)->urx, (dsc->bbox)->ury);
#line 939
      buf[sizeof(buf) - 1UL] = (char )'\000';
#line 940
      strncpy((char */* __restrict  */)(info->bbox), (char const   */* __restrict  */)(buf),
              sizeof(info->bbox) / sizeof(char ));
      }
    }
#line 942
    if (dsc->hires_bbox) {
      {
#line 943
      snprintf((char */* __restrict  */)(buf), sizeof(buf) / sizeof(char ), (char const   */* __restrict  */)"%g %g %g %g",
               (double )(dsc->hires_bbox)->fllx, (double )(dsc->hires_bbox)->flly,
               (double )(dsc->hires_bbox)->furx, (double )(dsc->hires_bbox)->fury);
#line 946
      buf[sizeof(buf) - 1UL] = (char )'\000';
#line 947
      strncpy((char */* __restrict  */)(info->hiresbbox), (char const   */* __restrict  */)(buf),
              sizeof(info->hiresbbox) / sizeof(char ));
      }
    }
    {
#line 951
    if (dsc->page_orientation == 1U) {
#line 951
      goto case_1___0;
    }
#line 955
    if (dsc->page_orientation == 2U) {
#line 955
      goto case_2___0;
    }
#line 950
    goto switch_break___0;
    case_1___0: /* CIL Label */ 
    {
#line 952
    load_string(doc->app, 616, info->orientation, (int )(sizeof(info->orientation) / sizeof(char )));
    }
#line 954
    goto switch_break___0;
    case_2___0: /* CIL Label */ 
    {
#line 956
    load_string(doc->app, 615, info->orientation, (int )(sizeof(info->orientation) / sizeof(char )));
    }
#line 958
    goto switch_break___0;
    switch_break___0: /* CIL Label */ ;
    }
    {
#line 961
    if (dsc->page_order == 1U) {
#line 961
      goto case_1___1;
    }
#line 965
    if (dsc->page_order == 2U) {
#line 965
      goto case_2___1;
    }
#line 969
    if (dsc->page_order == 3U) {
#line 969
      goto case_3___0;
    }
#line 960
    goto switch_break___1;
    case_1___1: /* CIL Label */ 
    {
#line 962
    load_string(doc->app, 617, info->pageorder, (int )(sizeof(info->pageorder) / sizeof(char )));
    }
#line 964
    goto switch_break___1;
    case_2___1: /* CIL Label */ 
    {
#line 966
    load_string(doc->app, 615, info->pageorder, (int )(sizeof(info->pageorder) / sizeof(char )));
    }
#line 968
    goto switch_break___1;
    case_3___0: /* CIL Label */ 
    {
#line 970
    load_string(doc->app, 619, info->pageorder, (int )(sizeof(info->pageorder) / sizeof(char )));
    }
#line 972
    goto switch_break___1;
    switch_break___1: /* CIL Label */ ;
    }
#line 974
    if (dsc->page_media) {
#line 974
      if ((dsc->page_media)->name) {
        {
#line 975
        tmp___2 = strlen((char const   *)(dsc->page_media)->name);
#line 975
        tmp___3 = narrow_to_cs(buf, (int )((unsigned long )((int )sizeof(buf)) / sizeof(char )),
                               (char const   *)(dsc->page_media)->name, (int )tmp___2 + 1);
#line 975
        wlen = tmp___3;
#line 977
        snprintf((char */* __restrict  */)(buf + wlen), sizeof(buf) / sizeof(char ) - (unsigned long )wlen,
                 (char const   */* __restrict  */)" %g %g", (double const   )(dsc->page_media)->width,
                 (double const   )(dsc->page_media)->height);
#line 979
        buf[sizeof(buf) - 1UL] = (char )'\000';
        }
      } else {
#line 982
        buf[0] = (char )'\000';
      }
    } else {
#line 982
      buf[0] = (char )'\000';
    }
    {
#line 984
    strncpy((char */* __restrict  */)(info->pagemedia), (char const   */* __restrict  */)(buf),
            sizeof(info->pages) / sizeof(char ));
#line 985
    snprintf((char */* __restrict  */)(buf), sizeof(buf) / sizeof(char ), (char const   */* __restrict  */)"%d",
             dsc->page_count);
#line 986
    buf[sizeof(buf) - 1UL] = (char )'\000';
#line 987
    strncpy((char */* __restrict  */)(info->pages), (char const   */* __restrict  */)(buf),
            sizeof(info->pages) / sizeof(char ));
    }
  } else
#line 989
  if ((unsigned int )doc->doctype == 2U) {
    {
#line 990
    load_string(doc->app, 631, buf, (int )(sizeof(buf) / sizeof(char )));
#line 991
    csappend(info->type, (char const   *)(buf), typelen);
#line 992
    snprintf((char */* __restrict  */)(buf), sizeof(buf) / sizeof(char ), (char const   */* __restrict  */)"%d",
             doc->page_count);
#line 994
    buf[sizeof(buf) - 1UL] = (char )'\000';
#line 995
    strncpy((char */* __restrict  */)(info->pages), (char const   */* __restrict  */)(buf),
            sizeof(info->pages) / sizeof(char ));
    }
  }
#line 997
  return;
}
}
#line 1003 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/cdoc.c"
void doc_ordlabel(Doc *doc , char *buf , int buflen , int page_number ) 
{ 
  char const   *label ;
  int ordinal ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 1006
  if ((unsigned int )doc->doctype == 2U) {
    {
#line 1007
    snprintf((char */* __restrict  */)buf, (size_t )buflen, (char const   */* __restrict  */)"%d",
             page_number + 1);
    }
  } else
#line 1009
  if (doc->dsc) {
    {
#line 1012
    tmp = doc_map_page(doc, page_number);
#line 1012
    label = ((doc->dsc)->page + tmp)->label;
#line 1013
    tmp___0 = doc_map_page(doc, page_number);
#line 1013
    ordinal = ((doc->dsc)->page + tmp___0)->ordinal;
#line 1014
    snprintf((char */* __restrict  */)buf, (size_t )buflen, (char const   */* __restrict  */)"%d",
             ordinal);
#line 1015
    tmp___1 = strcmp((char const   *)buf, label);
    }
#line 1015
    if (tmp___1 != 0) {
      {
#line 1017
      snprintf((char */* __restrict  */)buf, (size_t )buflen, (char const   */* __restrict  */)"%d  \"%s\"",
               ordinal, label);
      }
    }
  }
#line 1020
  return;
}
}
#line 1022 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/cdoc.c"
static int doc_msg_len(void *handle , char const   *str , int len ) 
{ 
  int tmp ;

  {
  {
#line 1025
  tmp = app_msg_len((GSview *)handle, str, len);
  }
#line 1025
  return (tmp);
}
}
#line 1029 "/home/june/repo/benchmarks/collector/temp/epstool-3.08+repack/./src/cdoc.c"
int doc_copyfile(Doc *doc , char const   *filename ) 
{ 
  GFile *infile ;
  GFile *outfile ;
  int code ;
  char *buf ;
  int count ;
  void *tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  unsigned int tmp___2 ;
  unsigned int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
  {
#line 1033
  code = 0;
#line 1035
  count = 0;
#line 1037
  tmp = malloc((size_t )4096);
#line 1037
  buf = (char *)tmp;
  }
#line 1038
  if ((unsigned long )buf == (unsigned long )((char *)((void *)0))) {
#line 1039
    return (-1);
  }
  {
#line 1041
  tmp___1 = doc_name(doc);
#line 1041
  infile = gfile_open(tmp___1, 0U);
  }
#line 1041
  if ((unsigned long )infile == (unsigned long )((GFile *)((void *)0))) {
    {
#line 1042
    app_msg(doc->app, "File \"");
#line 1043
    tmp___0 = doc_name(doc);
#line 1043
    app_csmsg(doc->app, tmp___0);
#line 1044
    app_msg(doc->app, "\" does not exist\n");
#line 1045
    free((void *)buf);
    }
#line 1046
    return (-1);
  }
  {
#line 1048
  outfile = gfile_open(filename, 4097U);
  }
#line 1048
  if ((unsigned long )outfile == (unsigned long )((GFile *)((void *)0))) {
    {
#line 1050
    app_msg(doc->app, "File \"");
#line 1051
    app_csmsg(doc->app, filename);
#line 1052
    app_msg(doc->app, "\" can not be opened for writing\n");
#line 1053
    free((void *)buf);
#line 1054
    gfile_close(infile);
    }
#line 1055
    return (-1);
  }
  {
#line 1058
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1058
    tmp___3 = gfile_read(infile, (void *)buf, 4096U);
#line 1058
    count = (int )tmp___3;
    }
#line 1058
    if (! (count > 0)) {
#line 1058
      goto while_break;
    }
    {
#line 1059
    tmp___2 = gfile_write(outfile, (void const   *)buf, (unsigned int )count);
    }
#line 1059
    if ((int )tmp___2 != count) {
#line 1060
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1061
  free((void *)buf);
#line 1063
  tmp___4 = gfile_error(infile);
  }
#line 1063
  if (tmp___4 != 0) {
#line 1064
    code = -1;
  }
  {
#line 1065
  tmp___5 = gfile_error(outfile);
  }
#line 1065
  if (tmp___5 != 0) {
#line 1066
    code = -1;
  }
  {
#line 1068
  gfile_close(outfile);
#line 1069
  gfile_close(infile);
  }
#line 1070
  if (code) {
#line 1070
    if (! (debug & 1)) {
      {
#line 1071
      unlink(filename);
      }
    }
  }
#line 1072
  return (code);
}
}
