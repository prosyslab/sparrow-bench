/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 55 "/usr/include/stdint.h"
typedef unsigned long uint64_t;
#line 14 "/home/june/repo/benchmarks/collector/temp/rhash-1.3.1/librhash/ripemd-160.h"
struct ripemd160_ctx {
   unsigned int message[16] ;
   uint64_t length ;
   unsigned int hash[5] ;
};
#line 14 "/home/june/repo/benchmarks/collector/temp/rhash-1.3.1/librhash/ripemd-160.h"
typedef struct ripemd160_ctx ripemd160_ctx;
#line 13 "/home/june/repo/benchmarks/collector/temp/rhash-1.3.1/librhash/has160.h"
struct has160_ctx {
   unsigned int message[16] ;
   uint64_t length ;
   unsigned int hash[5] ;
};
#line 13 "/home/june/repo/benchmarks/collector/temp/rhash-1.3.1/librhash/has160.h"
typedef struct has160_ctx has160_ctx;
#line 124 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __dev_t;
#line 125 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uid_t;
#line 126 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __gid_t;
#line 127 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __ino_t;
#line 128 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __ino64_t;
#line 129 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __mode_t;
#line 130 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __nlink_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 141 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __suseconds_t;
#line 153 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blksize_t;
#line 158 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blkcnt_t;
#line 175 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __syscall_slong_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 120 "/usr/include/time.h"
struct timespec {
   __time_t tv_sec ;
   __syscall_slong_t tv_nsec ;
};
#line 324 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef int wchar_t;
#line 30 "/usr/include/x86_64-linux-gnu/bits/time.h"
struct timeval {
   __time_t tv_sec ;
   __suseconds_t tv_usec ;
};
#line 83 "/home/june/repo/benchmarks/collector/temp/rhash-1.3.1/common_func.h"
struct file_t {
   char *path ;
   wchar_t *wpath ;
   uint64_t size ;
   uint64_t mtime ;
   unsigned int mode ;
};
#line 83 "/home/june/repo/benchmarks/collector/temp/rhash-1.3.1/common_func.h"
typedef struct file_t file_t;
#line 137
struct stat;
#line 163 "/home/june/repo/benchmarks/collector/temp/rhash-1.3.1/common_func.h"
struct vector_t {
   void **array ;
   size_t size ;
   size_t allocated ;
   void (*destructor)(void * ) ;
};
#line 163 "/home/june/repo/benchmarks/collector/temp/rhash-1.3.1/common_func.h"
typedef struct vector_t vector_t;
#line 217 "/home/june/repo/benchmarks/collector/temp/rhash-1.3.1/common_func.h"
struct strbuf_t {
   char *str ;
   size_t allocated ;
   size_t len ;
};
#line 22 "/usr/include/x86_64-linux-gnu/bits/dirent.h"
struct dirent {
   __ino64_t d_ino ;
   __off64_t d_off ;
   unsigned short d_reclen ;
   unsigned char d_type ;
   char d_name[256] ;
};
#line 127 "/usr/include/dirent.h"
struct __dirstream;
#line 127 "/usr/include/dirent.h"
typedef struct __dirstream DIR;
#line 46 "/usr/include/x86_64-linux-gnu/bits/stat.h"
struct stat {
   __dev_t st_dev ;
   __ino_t st_ino ;
   __nlink_t st_nlink ;
   __mode_t st_mode ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   int __pad0 ;
   __dev_t st_rdev ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   __syscall_slong_t __glibc_reserved[3] ;
};
#line 19 "/home/june/repo/benchmarks/collector/temp/rhash-1.3.1/librhash/rhash_timing.h"
typedef struct timeval timedelta_t;
#line 18 "/home/june/repo/benchmarks/collector/temp/rhash-1.3.1/parse_cmdline.h"
typedef char opt_tchar;
#line 67
struct file_search_data;
#line 67 "/home/june/repo/benchmarks/collector/temp/rhash-1.3.1/parse_cmdline.h"
struct options_t {
   unsigned int flags ;
   unsigned int sum_flags ;
   unsigned int fmt ;
   unsigned int mode ;
   char const   *config_file ;
   char *printf_str ;
   char *template_file ;
   opt_tchar *output ;
   opt_tchar *log ;
   char *embed_crc_delimiter ;
   char path_separator ;
   int find_max_depth ;
   struct vector_t *files_accept ;
   struct vector_t *crc_accept ;
   unsigned int openssl_mask ;
   size_t bt_piece_length ;
   char *bt_announce ;
   char *bt_batch_file ;
   char **argv ;
   int n_files ;
   struct file_search_data *search_data ;
   struct vector_t *mem ;
};
#line 14 "/home/june/repo/benchmarks/collector/temp/rhash-1.3.1/rhash_main.h"
struct print_item;
#line 14
struct rhash_context;
#line 14 "/home/june/repo/benchmarks/collector/temp/rhash-1.3.1/rhash_main.h"
struct rhash_t {
   FILE *out ;
   FILE *log ;
   FILE *upd_fd ;
   int saved_console_codepage ;
   unsigned int saved_cursor_size ;
   char *printf_str ;
   struct print_item *print_list ;
   struct strbuf_t *template_text ;
   struct rhash_context *rctx ;
   int interrupted ;
   unsigned int processed ;
   unsigned int ok ;
   unsigned int miss ;
   uint64_t total_size ;
   uint64_t batch_size ;
   int error_flag ;
};
#line 24 "/home/june/repo/benchmarks/collector/temp/rhash-1.3.1/hash_check.h"
struct hash_value {
   unsigned int hash_id ;
   unsigned short offset ;
   unsigned char length ;
   unsigned char format ;
};
#line 24 "/home/june/repo/benchmarks/collector/temp/rhash-1.3.1/hash_check.h"
typedef struct hash_value hash_value;
#line 37 "/home/june/repo/benchmarks/collector/temp/rhash-1.3.1/hash_check.h"
struct hash_check {
   char *file_path ;
   uint64_t file_size ;
   unsigned int hash_mask ;
   unsigned int flags ;
   unsigned int embedded_crc32_be ;
   char *data ;
   unsigned int found_hash_ids ;
   unsigned int wrong_hashes ;
   int hashes_num ;
   hash_value hashes[32] ;
};
#line 37 "/home/june/repo/benchmarks/collector/temp/rhash-1.3.1/hash_check.h"
typedef struct hash_check hash_check;
#line 14 "/home/june/repo/benchmarks/collector/temp/rhash-1.3.1/file_set.h"
struct file_set_item {
   unsigned int hash ;
   char *filepath ;
   char *search_filepath ;
};
#line 14 "/home/june/repo/benchmarks/collector/temp/rhash-1.3.1/file_set.h"
typedef struct file_set_item file_set_item;
#line 23 "/home/june/repo/benchmarks/collector/temp/rhash-1.3.1/file_set.h"
typedef struct vector_t file_set;
#line 12 "/home/june/repo/benchmarks/collector/temp/rhash-1.3.1/file_mask.h"
typedef struct vector_t file_mask_array;
#line 40 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stdarg.h"
typedef __builtin_va_list __gnuc_va_list;
#line 79 "/usr/include/stdio.h"
typedef __gnuc_va_list va_list;
#line 75 "/usr/include/time.h"
typedef __time_t time_t;
#line 133 "/usr/include/time.h"
struct tm {
   int tm_sec ;
   int tm_min ;
   int tm_hour ;
   int tm_mday ;
   int tm_mon ;
   int tm_year ;
   int tm_wday ;
   int tm_yday ;
   int tm_isdst ;
   long tm_gmtoff ;
   char const   *tm_zone ;
};
#line 55 "/usr/include/x86_64-linux-gnu/sys/time.h"
struct timezone {
   int tz_minuteswest ;
   int tz_dsttime ;
};
#line 61 "/usr/include/x86_64-linux-gnu/sys/time.h"
typedef struct timezone * __restrict  __timezone_ptr_t;
#line 59 "/home/june/repo/benchmarks/collector/temp/rhash-1.3.1/common_func.h"
typedef char rsh_tchar;
#line 187 "/home/june/repo/benchmarks/collector/temp/rhash-1.3.1/common_func.h"
struct blocks_vector_t {
   size_t size ;
   vector_t blocks ;
};
#line 187 "/home/june/repo/benchmarks/collector/temp/rhash-1.3.1/common_func.h"
typedef struct blocks_vector_t blocks_vector_t;
#line 217 "/home/june/repo/benchmarks/collector/temp/rhash-1.3.1/common_func.h"
typedef struct strbuf_t strbuf_t;
#line 66 "/home/june/repo/benchmarks/collector/temp/rhash-1.3.1/librhash/rhash.h"
struct rhash_context {
   unsigned long long msg_size ;
   unsigned int hash_id ;
};
#line 78 "/home/june/repo/benchmarks/collector/temp/rhash-1.3.1/librhash/rhash.h"
typedef struct rhash_context *rhash;
#line 183 "/home/june/repo/benchmarks/collector/temp/rhash-1.3.1/librhash/rhash.h"
typedef unsigned long long rhash_uptr_t;
#line 9 "/home/june/repo/benchmarks/collector/temp/rhash-1.3.1/hash_print.h"
struct print_item {
   struct print_item *next ;
   unsigned int flags ;
   unsigned int hash_id ;
   unsigned int width ;
   char const   *data ;
};
#line 9 "/home/june/repo/benchmarks/collector/temp/rhash-1.3.1/hash_print.h"
typedef struct print_item print_item;
#line 26
struct file_info;
#line 16 "/home/june/repo/benchmarks/collector/temp/rhash-1.3.1/output.h"
struct percents_output_info_t {
   int (*init)(struct file_info *info ) ;
   void (*update)(struct file_info *info , uint64_t offset ) ;
   void (*finish)(struct file_info *info , int process_res ) ;
   char const   *name ;
};
#line 19 "/home/june/repo/benchmarks/collector/temp/rhash-1.3.1/calc_sums.h"
struct file_info {
   char *full_path ;
   char const   *print_path ;
   char *utf8_print_path ;
   uint64_t size ;
   uint64_t msg_offset ;
   double time ;
   struct file_t *file ;
   struct rhash_context *rctx ;
   int error ;
   char *allocated_ptr ;
   unsigned int sums_flags ;
   struct hash_check hc ;
};
#line 85 "/usr/include/signal.h"
typedef void (*__sighandler_t)(int  );
#line 25 "/home/june/repo/benchmarks/collector/temp/rhash-1.3.1/find_file.h"
struct file_search_data {
   int options ;
   int max_depth ;
   blocks_vector_t root_files ;
   int (*call_back)(file_t *file , int data ) ;
   int call_back_data ;
   int errors_count ;
};
#line 25 "/home/june/repo/benchmarks/collector/temp/rhash-1.3.1/find_file.h"
typedef struct file_search_data file_search_data;
#line 17 "/home/june/repo/benchmarks/collector/temp/rhash-1.3.1/hash_print.h"
struct print_hash_info {
   char short_name[16] ;
   char short_char ;
   char const   *name ;
};
#line 17 "/home/june/repo/benchmarks/collector/temp/rhash-1.3.1/hash_print.h"
typedef struct print_hash_info print_hash_info;
#line 40 "/usr/include/stdint.h"
typedef long int64_t;
#line 315 "/usr/include/libio.h"
typedef struct _IO_FILE _IO_FILE;
#line 111 "/home/june/repo/benchmarks/collector/temp/rhash-1.3.1/output.c"
struct percents_t {
   int points ;
   int use_cursor ;
   int same_output ;
   unsigned int ticks ;
};
#line 26 "/home/june/repo/benchmarks/collector/temp/rhash-1.3.1/parse_cmdline.c"
typedef struct options_t options_t;
#line 250 "/home/june/repo/benchmarks/collector/temp/rhash-1.3.1/parse_cmdline.c"
struct cmdline_opt_t {
   unsigned short type ;
   char short1 ;
   char short2 ;
   char *long_name ;
   void *ptr ;
   unsigned int param ;
};
#line 250 "/home/june/repo/benchmarks/collector/temp/rhash-1.3.1/parse_cmdline.c"
typedef struct cmdline_opt_t cmdline_opt_t;
#line 384 "/home/june/repo/benchmarks/collector/temp/rhash-1.3.1/parse_cmdline.c"
struct parsed_option_t {
   cmdline_opt_t *o ;
   char const   *name ;
   char buf[4] ;
   void *parameter ;
};
#line 384 "/home/june/repo/benchmarks/collector/temp/rhash-1.3.1/parse_cmdline.c"
typedef struct parsed_option_t parsed_option_t;
#line 644 "/home/june/repo/benchmarks/collector/temp/rhash-1.3.1/parse_cmdline.c"
struct parsed_cmd_line_t {
   blocks_vector_t options ;
   int argc ;
   char **argv ;
   int n_files ;
   rsh_tchar **files ;
};
#line 239 "/home/june/repo/benchmarks/collector/temp/rhash-1.3.1/hash_check.c"
struct hc_search {
   char *begin ;
   char *end ;
   hash_check *hc ;
   unsigned int expected_hash_id ;
   int hash_type ;
   char *url_name ;
   size_t url_length ;
};
#line 239 "/home/june/repo/benchmarks/collector/temp/rhash-1.3.1/hash_check.c"
typedef struct hc_search hc_search;
#line 223 "/home/june/repo/benchmarks/collector/temp/rhash-1.3.1/find_file.c"
struct dir_entry {
   struct dir_entry *next ;
   char *filename ;
   unsigned int type ;
};
#line 223 "/home/june/repo/benchmarks/collector/temp/rhash-1.3.1/find_file.c"
typedef struct dir_entry dir_entry;
#line 287 "/home/june/repo/benchmarks/collector/temp/rhash-1.3.1/find_file.c"
struct dir_iterator {
   int left ;
   char *dir_path ;
};
#line 287 "/home/june/repo/benchmarks/collector/temp/rhash-1.3.1/find_file.c"
typedef struct dir_iterator dir_iterator;
#line 46 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memcpy)(void * __restrict  __dest ,
                                                                                                 void const   * __restrict  __src ,
                                                                                                 size_t __n ) ;
#line 23 "/home/june/repo/benchmarks/collector/temp/rhash-1.3.1/librhash/ripemd-160.h"
void rhash_ripemd160_init(ripemd160_ctx *ctx ) ;
#line 24
void rhash_ripemd160_update(ripemd160_ctx *ctx , unsigned char const   *msg , size_t size ) ;
#line 25
void rhash_ripemd160_final(ripemd160_ctx *ctx , unsigned char *result ) ;
#line 29 "/home/june/repo/benchmarks/collector/temp/rhash-1.3.1/librhash/ripemd-160.c"
void rhash_ripemd160_init(ripemd160_ctx *ctx ) 
{ 


  {
#line 31
  ctx->length = (uint64_t )0;
#line 34
  ctx->hash[0] = 1732584193U;
#line 35
  ctx->hash[1] = 4023233417U;
#line 36
  ctx->hash[2] = 2562383102U;
#line 37
  ctx->hash[3] = 271733878U;
#line 38
  ctx->hash[4] = 3285377520U;
#line 39
  return;
}
}
#line 71 "/home/june/repo/benchmarks/collector/temp/rhash-1.3.1/librhash/ripemd-160.c"
static void rhash_ripemd160_process_block(unsigned int *hash , unsigned int const   *X ) 
{ 
  register unsigned int A ;
  register unsigned int B ;
  register unsigned int C ;
  register unsigned int D ;
  register unsigned int E ;
  unsigned int a1 ;
  unsigned int b1 ;
  unsigned int c1 ;
  unsigned int d1 ;
  unsigned int e1 ;

  {
#line 73
  A = *(hash + 0);
#line 73
  B = *(hash + 1);
#line 73
  C = *(hash + 2);
#line 73
  D = *(hash + 3);
#line 73
  E = *(hash + 4);
#line 78
  A += ((B ^ C) ^ D) + (unsigned int )*(X + 0);
#line 78
  A = ((A << 11) ^ (A >> 21)) + E;
#line 78
  C = (C << 10) ^ (C >> 22);
#line 79
  E += ((A ^ B) ^ C) + (unsigned int )*(X + 1);
#line 79
  E = ((E << 14) ^ (E >> 18)) + D;
#line 79
  B = (B << 10) ^ (B >> 22);
#line 80
  D += ((E ^ A) ^ B) + (unsigned int )*(X + 2);
#line 80
  D = ((D << 15) ^ (D >> 17)) + C;
#line 80
  A = (A << 10) ^ (A >> 22);
#line 81
  C += ((D ^ E) ^ A) + (unsigned int )*(X + 3);
#line 81
  C = ((C << 12) ^ (C >> 20)) + B;
#line 81
  E = (E << 10) ^ (E >> 22);
#line 82
  B += ((C ^ D) ^ E) + (unsigned int )*(X + 4);
#line 82
  B = ((B << 5) ^ (B >> 27)) + A;
#line 82
  D = (D << 10) ^ (D >> 22);
#line 83
  A += ((B ^ C) ^ D) + (unsigned int )*(X + 5);
#line 83
  A = ((A << 8) ^ (A >> 24)) + E;
#line 83
  C = (C << 10) ^ (C >> 22);
#line 84
  E += ((A ^ B) ^ C) + (unsigned int )*(X + 6);
#line 84
  E = ((E << 7) ^ (E >> 25)) + D;
#line 84
  B = (B << 10) ^ (B >> 22);
#line 85
  D += ((E ^ A) ^ B) + (unsigned int )*(X + 7);
#line 85
  D = ((D << 9) ^ (D >> 23)) + C;
#line 85
  A = (A << 10) ^ (A >> 22);
#line 86
  C += ((D ^ E) ^ A) + (unsigned int )*(X + 8);
#line 86
  C = ((C << 11) ^ (C >> 21)) + B;
#line 86
  E = (E << 10) ^ (E >> 22);
#line 87
  B += ((C ^ D) ^ E) + (unsigned int )*(X + 9);
#line 87
  B = ((B << 13) ^ (B >> 19)) + A;
#line 87
  D = (D << 10) ^ (D >> 22);
#line 88
  A += ((B ^ C) ^ D) + (unsigned int )*(X + 10);
#line 88
  A = ((A << 14) ^ (A >> 18)) + E;
#line 88
  C = (C << 10) ^ (C >> 22);
#line 89
  E += ((A ^ B) ^ C) + (unsigned int )*(X + 11);
#line 89
  E = ((E << 15) ^ (E >> 17)) + D;
#line 89
  B = (B << 10) ^ (B >> 22);
#line 90
  D += ((E ^ A) ^ B) + (unsigned int )*(X + 12);
#line 90
  D = ((D << 6) ^ (D >> 26)) + C;
#line 90
  A = (A << 10) ^ (A >> 22);
#line 91
  C += ((D ^ E) ^ A) + (unsigned int )*(X + 13);
#line 91
  C = ((C << 7) ^ (C >> 25)) + B;
#line 91
  E = (E << 10) ^ (E >> 22);
#line 92
  B += ((C ^ D) ^ E) + (unsigned int )*(X + 14);
#line 92
  B = ((B << 9) ^ (B >> 23)) + A;
#line 92
  D = (D << 10) ^ (D >> 22);
#line 93
  A += ((B ^ C) ^ D) + (unsigned int )*(X + 15);
#line 93
  A = ((A << 8) ^ (A >> 24)) + E;
#line 93
  C = (C << 10) ^ (C >> 22);
#line 95
  E = (unsigned int )((unsigned long )E + ((unsigned long )((((B ^ C) & A) ^ C) + (unsigned int )*(X + 7)) + 1518500249UL));
#line 95
  E = ((E << 7) ^ (E >> 25)) + D;
#line 95
  B = (B << 10) ^ (B >> 22);
#line 96
  D = (unsigned int )((unsigned long )D + ((unsigned long )((((A ^ B) & E) ^ B) + (unsigned int )*(X + 4)) + 1518500249UL));
#line 96
  D = ((D << 6) ^ (D >> 26)) + C;
#line 96
  A = (A << 10) ^ (A >> 22);
#line 97
  C = (unsigned int )((unsigned long )C + ((unsigned long )((((E ^ A) & D) ^ A) + (unsigned int )*(X + 13)) + 1518500249UL));
#line 97
  C = ((C << 8) ^ (C >> 24)) + B;
#line 97
  E = (E << 10) ^ (E >> 22);
#line 98
  B = (unsigned int )((unsigned long )B + ((unsigned long )((((D ^ E) & C) ^ E) + (unsigned int )*(X + 1)) + 1518500249UL));
#line 98
  B = ((B << 13) ^ (B >> 19)) + A;
#line 98
  D = (D << 10) ^ (D >> 22);
#line 99
  A = (unsigned int )((unsigned long )A + ((unsigned long )((((C ^ D) & B) ^ D) + (unsigned int )*(X + 10)) + 1518500249UL));
#line 99
  A = ((A << 11) ^ (A >> 21)) + E;
#line 99
  C = (C << 10) ^ (C >> 22);
#line 100
  E = (unsigned int )((unsigned long )E + ((unsigned long )((((B ^ C) & A) ^ C) + (unsigned int )*(X + 6)) + 1518500249UL));
#line 100
  E = ((E << 9) ^ (E >> 23)) + D;
#line 100
  B = (B << 10) ^ (B >> 22);
#line 101
  D = (unsigned int )((unsigned long )D + ((unsigned long )((((A ^ B) & E) ^ B) + (unsigned int )*(X + 15)) + 1518500249UL));
#line 101
  D = ((D << 7) ^ (D >> 25)) + C;
#line 101
  A = (A << 10) ^ (A >> 22);
#line 102
  C = (unsigned int )((unsigned long )C + ((unsigned long )((((E ^ A) & D) ^ A) + (unsigned int )*(X + 3)) + 1518500249UL));
#line 102
  C = ((C << 15) ^ (C >> 17)) + B;
#line 102
  E = (E << 10) ^ (E >> 22);
#line 103
  B = (unsigned int )((unsigned long )B + ((unsigned long )((((D ^ E) & C) ^ E) + (unsigned int )*(X + 12)) + 1518500249UL));
#line 103
  B = ((B << 7) ^ (B >> 25)) + A;
#line 103
  D = (D << 10) ^ (D >> 22);
#line 104
  A = (unsigned int )((unsigned long )A + ((unsigned long )((((C ^ D) & B) ^ D) + (unsigned int )*(X + 0)) + 1518500249UL));
#line 104
  A = ((A << 12) ^ (A >> 20)) + E;
#line 104
  C = (C << 10) ^ (C >> 22);
#line 105
  E = (unsigned int )((unsigned long )E + ((unsigned long )((((B ^ C) & A) ^ C) + (unsigned int )*(X + 9)) + 1518500249UL));
#line 105
  E = ((E << 15) ^ (E >> 17)) + D;
#line 105
  B = (B << 10) ^ (B >> 22);
#line 106
  D = (unsigned int )((unsigned long )D + ((unsigned long )((((A ^ B) & E) ^ B) + (unsigned int )*(X + 5)) + 1518500249UL));
#line 106
  D = ((D << 9) ^ (D >> 23)) + C;
#line 106
  A = (A << 10) ^ (A >> 22);
#line 107
  C = (unsigned int )((unsigned long )C + ((unsigned long )((((E ^ A) & D) ^ A) + (unsigned int )*(X + 2)) + 1518500249UL));
#line 107
  C = ((C << 11) ^ (C >> 21)) + B;
#line 107
  E = (E << 10) ^ (E >> 22);
#line 108
  B = (unsigned int )((unsigned long )B + ((unsigned long )((((D ^ E) & C) ^ E) + (unsigned int )*(X + 14)) + 1518500249UL));
#line 108
  B = ((B << 7) ^ (B >> 25)) + A;
#line 108
  D = (D << 10) ^ (D >> 22);
#line 109
  A = (unsigned int )((unsigned long )A + ((unsigned long )((((C ^ D) & B) ^ D) + (unsigned int )*(X + 11)) + 1518500249UL));
#line 109
  A = ((A << 13) ^ (A >> 19)) + E;
#line 109
  C = (C << 10) ^ (C >> 22);
#line 110
  E = (unsigned int )((unsigned long )E + ((unsigned long )((((B ^ C) & A) ^ C) + (unsigned int )*(X + 8)) + 1518500249UL));
#line 110
  E = ((E << 12) ^ (E >> 20)) + D;
#line 110
  B = (B << 10) ^ (B >> 22);
#line 112
  D = (unsigned int )((unsigned long )D + ((unsigned long )(((E | ~ A) ^ B) + (unsigned int )*(X + 3)) + 1859775393UL));
#line 112
  D = ((D << 11) ^ (D >> 21)) + C;
#line 112
  A = (A << 10) ^ (A >> 22);
#line 113
  C = (unsigned int )((unsigned long )C + ((unsigned long )(((D | ~ E) ^ A) + (unsigned int )*(X + 10)) + 1859775393UL));
#line 113
  C = ((C << 13) ^ (C >> 19)) + B;
#line 113
  E = (E << 10) ^ (E >> 22);
#line 114
  B = (unsigned int )((unsigned long )B + ((unsigned long )(((C | ~ D) ^ E) + (unsigned int )*(X + 14)) + 1859775393UL));
#line 114
  B = ((B << 6) ^ (B >> 26)) + A;
#line 114
  D = (D << 10) ^ (D >> 22);
#line 115
  A = (unsigned int )((unsigned long )A + ((unsigned long )(((B | ~ C) ^ D) + (unsigned int )*(X + 4)) + 1859775393UL));
#line 115
  A = ((A << 7) ^ (A >> 25)) + E;
#line 115
  C = (C << 10) ^ (C >> 22);
#line 116
  E = (unsigned int )((unsigned long )E + ((unsigned long )(((A | ~ B) ^ C) + (unsigned int )*(X + 9)) + 1859775393UL));
#line 116
  E = ((E << 14) ^ (E >> 18)) + D;
#line 116
  B = (B << 10) ^ (B >> 22);
#line 117
  D = (unsigned int )((unsigned long )D + ((unsigned long )(((E | ~ A) ^ B) + (unsigned int )*(X + 15)) + 1859775393UL));
#line 117
  D = ((D << 9) ^ (D >> 23)) + C;
#line 117
  A = (A << 10) ^ (A >> 22);
#line 118
  C = (unsigned int )((unsigned long )C + ((unsigned long )(((D | ~ E) ^ A) + (unsigned int )*(X + 8)) + 1859775393UL));
#line 118
  C = ((C << 13) ^ (C >> 19)) + B;
#line 118
  E = (E << 10) ^ (E >> 22);
#line 119
  B = (unsigned int )((unsigned long )B + ((unsigned long )(((C | ~ D) ^ E) + (unsigned int )*(X + 1)) + 1859775393UL));
#line 119
  B = ((B << 15) ^ (B >> 17)) + A;
#line 119
  D = (D << 10) ^ (D >> 22);
#line 120
  A = (unsigned int )((unsigned long )A + ((unsigned long )(((B | ~ C) ^ D) + (unsigned int )*(X + 2)) + 1859775393UL));
#line 120
  A = ((A << 14) ^ (A >> 18)) + E;
#line 120
  C = (C << 10) ^ (C >> 22);
#line 121
  E = (unsigned int )((unsigned long )E + ((unsigned long )(((A | ~ B) ^ C) + (unsigned int )*(X + 7)) + 1859775393UL));
#line 121
  E = ((E << 8) ^ (E >> 24)) + D;
#line 121
  B = (B << 10) ^ (B >> 22);
#line 122
  D = (unsigned int )((unsigned long )D + ((unsigned long )(((E | ~ A) ^ B) + (unsigned int )*(X + 0)) + 1859775393UL));
#line 122
  D = ((D << 13) ^ (D >> 19)) + C;
#line 122
  A = (A << 10) ^ (A >> 22);
#line 123
  C = (unsigned int )((unsigned long )C + ((unsigned long )(((D | ~ E) ^ A) + (unsigned int )*(X + 6)) + 1859775393UL));
#line 123
  C = ((C << 6) ^ (C >> 26)) + B;
#line 123
  E = (E << 10) ^ (E >> 22);
#line 124
  B = (unsigned int )((unsigned long )B + ((unsigned long )(((C | ~ D) ^ E) + (unsigned int )*(X + 13)) + 1859775393UL));
#line 124
  B = ((B << 5) ^ (B >> 27)) + A;
#line 124
  D = (D << 10) ^ (D >> 22);
#line 125
  A = (unsigned int )((unsigned long )A + ((unsigned long )(((B | ~ C) ^ D) + (unsigned int )*(X + 11)) + 1859775393UL));
#line 125
  A = ((A << 12) ^ (A >> 20)) + E;
#line 125
  C = (C << 10) ^ (C >> 22);
#line 126
  E = (unsigned int )((unsigned long )E + ((unsigned long )(((A | ~ B) ^ C) + (unsigned int )*(X + 5)) + 1859775393UL));
#line 126
  E = ((E << 7) ^ (E >> 25)) + D;
#line 126
  B = (B << 10) ^ (B >> 22);
#line 127
  D = (unsigned int )((unsigned long )D + ((unsigned long )(((E | ~ A) ^ B) + (unsigned int )*(X + 12)) + 1859775393UL));
#line 127
  D = ((D << 5) ^ (D >> 27)) + C;
#line 127
  A = (A << 10) ^ (A >> 22);
#line 129
  C = (unsigned int )((unsigned long )C + ((unsigned long )((((D ^ E) & A) ^ E) + (unsigned int )*(X + 1)) + 2400959708UL));
#line 129
  C = ((C << 11) ^ (C >> 21)) + B;
#line 129
  E = (E << 10) ^ (E >> 22);
#line 130
  B = (unsigned int )((unsigned long )B + ((unsigned long )((((C ^ D) & E) ^ D) + (unsigned int )*(X + 9)) + 2400959708UL));
#line 130
  B = ((B << 12) ^ (B >> 20)) + A;
#line 130
  D = (D << 10) ^ (D >> 22);
#line 131
  A = (unsigned int )((unsigned long )A + ((unsigned long )((((B ^ C) & D) ^ C) + (unsigned int )*(X + 11)) + 2400959708UL));
#line 131
  A = ((A << 14) ^ (A >> 18)) + E;
#line 131
  C = (C << 10) ^ (C >> 22);
#line 132
  E = (unsigned int )((unsigned long )E + ((unsigned long )((((A ^ B) & C) ^ B) + (unsigned int )*(X + 10)) + 2400959708UL));
#line 132
  E = ((E << 15) ^ (E >> 17)) + D;
#line 132
  B = (B << 10) ^ (B >> 22);
#line 133
  D = (unsigned int )((unsigned long )D + ((unsigned long )((((E ^ A) & B) ^ A) + (unsigned int )*(X + 0)) + 2400959708UL));
#line 133
  D = ((D << 14) ^ (D >> 18)) + C;
#line 133
  A = (A << 10) ^ (A >> 22);
#line 134
  C = (unsigned int )((unsigned long )C + ((unsigned long )((((D ^ E) & A) ^ E) + (unsigned int )*(X + 8)) + 2400959708UL));
#line 134
  C = ((C << 15) ^ (C >> 17)) + B;
#line 134
  E = (E << 10) ^ (E >> 22);
#line 135
  B = (unsigned int )((unsigned long )B + ((unsigned long )((((C ^ D) & E) ^ D) + (unsigned int )*(X + 12)) + 2400959708UL));
#line 135
  B = ((B << 9) ^ (B >> 23)) + A;
#line 135
  D = (D << 10) ^ (D >> 22);
#line 136
  A = (unsigned int )((unsigned long )A + ((unsigned long )((((B ^ C) & D) ^ C) + (unsigned int )*(X + 4)) + 2400959708UL));
#line 136
  A = ((A << 8) ^ (A >> 24)) + E;
#line 136
  C = (C << 10) ^ (C >> 22);
#line 137
  E = (unsigned int )((unsigned long )E + ((unsigned long )((((A ^ B) & C) ^ B) + (unsigned int )*(X + 13)) + 2400959708UL));
#line 137
  E = ((E << 9) ^ (E >> 23)) + D;
#line 137
  B = (B << 10) ^ (B >> 22);
#line 138
  D = (unsigned int )((unsigned long )D + ((unsigned long )((((E ^ A) & B) ^ A) + (unsigned int )*(X + 3)) + 2400959708UL));
#line 138
  D = ((D << 14) ^ (D >> 18)) + C;
#line 138
  A = (A << 10) ^ (A >> 22);
#line 139
  C = (unsigned int )((unsigned long )C + ((unsigned long )((((D ^ E) & A) ^ E) + (unsigned int )*(X + 7)) + 2400959708UL));
#line 139
  C = ((C << 5) ^ (C >> 27)) + B;
#line 139
  E = (E << 10) ^ (E >> 22);
#line 140
  B = (unsigned int )((unsigned long )B + ((unsigned long )((((C ^ D) & E) ^ D) + (unsigned int )*(X + 15)) + 2400959708UL));
#line 140
  B = ((B << 6) ^ (B >> 26)) + A;
#line 140
  D = (D << 10) ^ (D >> 22);
#line 141
  A = (unsigned int )((unsigned long )A + ((unsigned long )((((B ^ C) & D) ^ C) + (unsigned int )*(X + 14)) + 2400959708UL));
#line 141
  A = ((A << 8) ^ (A >> 24)) + E;
#line 141
  C = (C << 10) ^ (C >> 22);
#line 142
  E = (unsigned int )((unsigned long )E + ((unsigned long )((((A ^ B) & C) ^ B) + (unsigned int )*(X + 5)) + 2400959708UL));
#line 142
  E = ((E << 6) ^ (E >> 26)) + D;
#line 142
  B = (B << 10) ^ (B >> 22);
#line 143
  D = (unsigned int )((unsigned long )D + ((unsigned long )((((E ^ A) & B) ^ A) + (unsigned int )*(X + 6)) + 2400959708UL));
#line 143
  D = ((D << 5) ^ (D >> 27)) + C;
#line 143
  A = (A << 10) ^ (A >> 22);
#line 144
  C = (unsigned int )((unsigned long )C + ((unsigned long )((((D ^ E) & A) ^ E) + (unsigned int )*(X + 2)) + 2400959708UL));
#line 144
  C = ((C << 12) ^ (C >> 20)) + B;
#line 144
  E = (E << 10) ^ (E >> 22);
#line 146
  B = (unsigned int )((unsigned long )B + ((unsigned long )((C ^ (D | ~ E)) + (unsigned int )*(X + 4)) + 2840853838UL));
#line 146
  B = ((B << 9) ^ (B >> 23)) + A;
#line 146
  D = (D << 10) ^ (D >> 22);
#line 147
  A = (unsigned int )((unsigned long )A + ((unsigned long )((B ^ (C | ~ D)) + (unsigned int )*(X + 0)) + 2840853838UL));
#line 147
  A = ((A << 15) ^ (A >> 17)) + E;
#line 147
  C = (C << 10) ^ (C >> 22);
#line 148
  E = (unsigned int )((unsigned long )E + ((unsigned long )((A ^ (B | ~ C)) + (unsigned int )*(X + 5)) + 2840853838UL));
#line 148
  E = ((E << 5) ^ (E >> 27)) + D;
#line 148
  B = (B << 10) ^ (B >> 22);
#line 149
  D = (unsigned int )((unsigned long )D + ((unsigned long )((E ^ (A | ~ B)) + (unsigned int )*(X + 9)) + 2840853838UL));
#line 149
  D = ((D << 11) ^ (D >> 21)) + C;
#line 149
  A = (A << 10) ^ (A >> 22);
#line 150
  C = (unsigned int )((unsigned long )C + ((unsigned long )((D ^ (E | ~ A)) + (unsigned int )*(X + 7)) + 2840853838UL));
#line 150
  C = ((C << 6) ^ (C >> 26)) + B;
#line 150
  E = (E << 10) ^ (E >> 22);
#line 151
  B = (unsigned int )((unsigned long )B + ((unsigned long )((C ^ (D | ~ E)) + (unsigned int )*(X + 12)) + 2840853838UL));
#line 151
  B = ((B << 8) ^ (B >> 24)) + A;
#line 151
  D = (D << 10) ^ (D >> 22);
#line 152
  A = (unsigned int )((unsigned long )A + ((unsigned long )((B ^ (C | ~ D)) + (unsigned int )*(X + 2)) + 2840853838UL));
#line 152
  A = ((A << 13) ^ (A >> 19)) + E;
#line 152
  C = (C << 10) ^ (C >> 22);
#line 153
  E = (unsigned int )((unsigned long )E + ((unsigned long )((A ^ (B | ~ C)) + (unsigned int )*(X + 10)) + 2840853838UL));
#line 153
  E = ((E << 12) ^ (E >> 20)) + D;
#line 153
  B = (B << 10) ^ (B >> 22);
#line 154
  D = (unsigned int )((unsigned long )D + ((unsigned long )((E ^ (A | ~ B)) + (unsigned int )*(X + 14)) + 2840853838UL));
#line 154
  D = ((D << 5) ^ (D >> 27)) + C;
#line 154
  A = (A << 10) ^ (A >> 22);
#line 155
  C = (unsigned int )((unsigned long )C + ((unsigned long )((D ^ (E | ~ A)) + (unsigned int )*(X + 1)) + 2840853838UL));
#line 155
  C = ((C << 12) ^ (C >> 20)) + B;
#line 155
  E = (E << 10) ^ (E >> 22);
#line 156
  B = (unsigned int )((unsigned long )B + ((unsigned long )((C ^ (D | ~ E)) + (unsigned int )*(X + 3)) + 2840853838UL));
#line 156
  B = ((B << 13) ^ (B >> 19)) + A;
#line 156
  D = (D << 10) ^ (D >> 22);
#line 157
  A = (unsigned int )((unsigned long )A + ((unsigned long )((B ^ (C | ~ D)) + (unsigned int )*(X + 8)) + 2840853838UL));
#line 157
  A = ((A << 14) ^ (A >> 18)) + E;
#line 157
  C = (C << 10) ^ (C >> 22);
#line 158
  E = (unsigned int )((unsigned long )E + ((unsigned long )((A ^ (B | ~ C)) + (unsigned int )*(X + 11)) + 2840853838UL));
#line 158
  E = ((E << 11) ^ (E >> 21)) + D;
#line 158
  B = (B << 10) ^ (B >> 22);
#line 159
  D = (unsigned int )((unsigned long )D + ((unsigned long )((E ^ (A | ~ B)) + (unsigned int )*(X + 6)) + 2840853838UL));
#line 159
  D = ((D << 8) ^ (D >> 24)) + C;
#line 159
  A = (A << 10) ^ (A >> 22);
#line 160
  C = (unsigned int )((unsigned long )C + ((unsigned long )((D ^ (E | ~ A)) + (unsigned int )*(X + 15)) + 2840853838UL));
#line 160
  C = ((C << 5) ^ (C >> 27)) + B;
#line 160
  E = (E << 10) ^ (E >> 22);
#line 161
  B = (unsigned int )((unsigned long )B + ((unsigned long )((C ^ (D | ~ E)) + (unsigned int )*(X + 13)) + 2840853838UL));
#line 161
  B = ((B << 6) ^ (B >> 26)) + A;
#line 161
  D = (D << 10) ^ (D >> 22);
#line 163
  a1 = A;
#line 163
  b1 = B;
#line 163
  c1 = C;
#line 163
  d1 = D;
#line 163
  e1 = E;
#line 164
  A = *(hash + 0);
#line 164
  B = *(hash + 1);
#line 164
  C = *(hash + 2);
#line 164
  D = *(hash + 3);
#line 164
  E = *(hash + 4);
#line 168
  A = (unsigned int )((unsigned long )A + ((unsigned long )((B ^ (C | ~ D)) + (unsigned int )*(X + 5)) + 1352829926UL));
#line 168
  A = ((A << 8) ^ (A >> 24)) + E;
#line 168
  C = (C << 10) ^ (C >> 22);
#line 169
  E = (unsigned int )((unsigned long )E + ((unsigned long )((A ^ (B | ~ C)) + (unsigned int )*(X + 14)) + 1352829926UL));
#line 169
  E = ((E << 9) ^ (E >> 23)) + D;
#line 169
  B = (B << 10) ^ (B >> 22);
#line 170
  D = (unsigned int )((unsigned long )D + ((unsigned long )((E ^ (A | ~ B)) + (unsigned int )*(X + 7)) + 1352829926UL));
#line 170
  D = ((D << 9) ^ (D >> 23)) + C;
#line 170
  A = (A << 10) ^ (A >> 22);
#line 171
  C = (unsigned int )((unsigned long )C + ((unsigned long )((D ^ (E | ~ A)) + (unsigned int )*(X + 0)) + 1352829926UL));
#line 171
  C = ((C << 11) ^ (C >> 21)) + B;
#line 171
  E = (E << 10) ^ (E >> 22);
#line 172
  B = (unsigned int )((unsigned long )B + ((unsigned long )((C ^ (D | ~ E)) + (unsigned int )*(X + 9)) + 1352829926UL));
#line 172
  B = ((B << 13) ^ (B >> 19)) + A;
#line 172
  D = (D << 10) ^ (D >> 22);
#line 173
  A = (unsigned int )((unsigned long )A + ((unsigned long )((B ^ (C | ~ D)) + (unsigned int )*(X + 2)) + 1352829926UL));
#line 173
  A = ((A << 15) ^ (A >> 17)) + E;
#line 173
  C = (C << 10) ^ (C >> 22);
#line 174
  E = (unsigned int )((unsigned long )E + ((unsigned long )((A ^ (B | ~ C)) + (unsigned int )*(X + 11)) + 1352829926UL));
#line 174
  E = ((E << 15) ^ (E >> 17)) + D;
#line 174
  B = (B << 10) ^ (B >> 22);
#line 175
  D = (unsigned int )((unsigned long )D + ((unsigned long )((E ^ (A | ~ B)) + (unsigned int )*(X + 4)) + 1352829926UL));
#line 175
  D = ((D << 5) ^ (D >> 27)) + C;
#line 175
  A = (A << 10) ^ (A >> 22);
#line 176
  C = (unsigned int )((unsigned long )C + ((unsigned long )((D ^ (E | ~ A)) + (unsigned int )*(X + 13)) + 1352829926UL));
#line 176
  C = ((C << 7) ^ (C >> 25)) + B;
#line 176
  E = (E << 10) ^ (E >> 22);
#line 177
  B = (unsigned int )((unsigned long )B + ((unsigned long )((C ^ (D | ~ E)) + (unsigned int )*(X + 6)) + 1352829926UL));
#line 177
  B = ((B << 7) ^ (B >> 25)) + A;
#line 177
  D = (D << 10) ^ (D >> 22);
#line 178
  A = (unsigned int )((unsigned long )A + ((unsigned long )((B ^ (C | ~ D)) + (unsigned int )*(X + 15)) + 1352829926UL));
#line 178
  A = ((A << 8) ^ (A >> 24)) + E;
#line 178
  C = (C << 10) ^ (C >> 22);
#line 179
  E = (unsigned int )((unsigned long )E + ((unsigned long )((A ^ (B | ~ C)) + (unsigned int )*(X + 8)) + 1352829926UL));
#line 179
  E = ((E << 11) ^ (E >> 21)) + D;
#line 179
  B = (B << 10) ^ (B >> 22);
#line 180
  D = (unsigned int )((unsigned long )D + ((unsigned long )((E ^ (A | ~ B)) + (unsigned int )*(X + 1)) + 1352829926UL));
#line 180
  D = ((D << 14) ^ (D >> 18)) + C;
#line 180
  A = (A << 10) ^ (A >> 22);
#line 181
  C = (unsigned int )((unsigned long )C + ((unsigned long )((D ^ (E | ~ A)) + (unsigned int )*(X + 10)) + 1352829926UL));
#line 181
  C = ((C << 14) ^ (C >> 18)) + B;
#line 181
  E = (E << 10) ^ (E >> 22);
#line 182
  B = (unsigned int )((unsigned long )B + ((unsigned long )((C ^ (D | ~ E)) + (unsigned int )*(X + 3)) + 1352829926UL));
#line 182
  B = ((B << 12) ^ (B >> 20)) + A;
#line 182
  D = (D << 10) ^ (D >> 22);
#line 183
  A = (unsigned int )((unsigned long )A + ((unsigned long )((B ^ (C | ~ D)) + (unsigned int )*(X + 12)) + 1352829926UL));
#line 183
  A = ((A << 6) ^ (A >> 26)) + E;
#line 183
  C = (C << 10) ^ (C >> 22);
#line 185
  E = (unsigned int )((unsigned long )E + ((unsigned long )((((A ^ B) & C) ^ B) + (unsigned int )*(X + 6)) + 1548603684UL));
#line 185
  E = ((E << 9) ^ (E >> 23)) + D;
#line 185
  B = (B << 10) ^ (B >> 22);
#line 186
  D = (unsigned int )((unsigned long )D + ((unsigned long )((((E ^ A) & B) ^ A) + (unsigned int )*(X + 11)) + 1548603684UL));
#line 186
  D = ((D << 13) ^ (D >> 19)) + C;
#line 186
  A = (A << 10) ^ (A >> 22);
#line 187
  C = (unsigned int )((unsigned long )C + ((unsigned long )((((D ^ E) & A) ^ E) + (unsigned int )*(X + 3)) + 1548603684UL));
#line 187
  C = ((C << 15) ^ (C >> 17)) + B;
#line 187
  E = (E << 10) ^ (E >> 22);
#line 188
  B = (unsigned int )((unsigned long )B + ((unsigned long )((((C ^ D) & E) ^ D) + (unsigned int )*(X + 7)) + 1548603684UL));
#line 188
  B = ((B << 7) ^ (B >> 25)) + A;
#line 188
  D = (D << 10) ^ (D >> 22);
#line 189
  A = (unsigned int )((unsigned long )A + ((unsigned long )((((B ^ C) & D) ^ C) + (unsigned int )*(X + 0)) + 1548603684UL));
#line 189
  A = ((A << 12) ^ (A >> 20)) + E;
#line 189
  C = (C << 10) ^ (C >> 22);
#line 190
  E = (unsigned int )((unsigned long )E + ((unsigned long )((((A ^ B) & C) ^ B) + (unsigned int )*(X + 13)) + 1548603684UL));
#line 190
  E = ((E << 8) ^ (E >> 24)) + D;
#line 190
  B = (B << 10) ^ (B >> 22);
#line 191
  D = (unsigned int )((unsigned long )D + ((unsigned long )((((E ^ A) & B) ^ A) + (unsigned int )*(X + 5)) + 1548603684UL));
#line 191
  D = ((D << 9) ^ (D >> 23)) + C;
#line 191
  A = (A << 10) ^ (A >> 22);
#line 192
  C = (unsigned int )((unsigned long )C + ((unsigned long )((((D ^ E) & A) ^ E) + (unsigned int )*(X + 10)) + 1548603684UL));
#line 192
  C = ((C << 11) ^ (C >> 21)) + B;
#line 192
  E = (E << 10) ^ (E >> 22);
#line 193
  B = (unsigned int )((unsigned long )B + ((unsigned long )((((C ^ D) & E) ^ D) + (unsigned int )*(X + 14)) + 1548603684UL));
#line 193
  B = ((B << 7) ^ (B >> 25)) + A;
#line 193
  D = (D << 10) ^ (D >> 22);
#line 194
  A = (unsigned int )((unsigned long )A + ((unsigned long )((((B ^ C) & D) ^ C) + (unsigned int )*(X + 15)) + 1548603684UL));
#line 194
  A = ((A << 7) ^ (A >> 25)) + E;
#line 194
  C = (C << 10) ^ (C >> 22);
#line 195
  E = (unsigned int )((unsigned long )E + ((unsigned long )((((A ^ B) & C) ^ B) + (unsigned int )*(X + 8)) + 1548603684UL));
#line 195
  E = ((E << 12) ^ (E >> 20)) + D;
#line 195
  B = (B << 10) ^ (B >> 22);
#line 196
  D = (unsigned int )((unsigned long )D + ((unsigned long )((((E ^ A) & B) ^ A) + (unsigned int )*(X + 12)) + 1548603684UL));
#line 196
  D = ((D << 7) ^ (D >> 25)) + C;
#line 196
  A = (A << 10) ^ (A >> 22);
#line 197
  C = (unsigned int )((unsigned long )C + ((unsigned long )((((D ^ E) & A) ^ E) + (unsigned int )*(X + 4)) + 1548603684UL));
#line 197
  C = ((C << 6) ^ (C >> 26)) + B;
#line 197
  E = (E << 10) ^ (E >> 22);
#line 198
  B = (unsigned int )((unsigned long )B + ((unsigned long )((((C ^ D) & E) ^ D) + (unsigned int )*(X + 9)) + 1548603684UL));
#line 198
  B = ((B << 15) ^ (B >> 17)) + A;
#line 198
  D = (D << 10) ^ (D >> 22);
#line 199
  A = (unsigned int )((unsigned long )A + ((unsigned long )((((B ^ C) & D) ^ C) + (unsigned int )*(X + 1)) + 1548603684UL));
#line 199
  A = ((A << 13) ^ (A >> 19)) + E;
#line 199
  C = (C << 10) ^ (C >> 22);
#line 200
  E = (unsigned int )((unsigned long )E + ((unsigned long )((((A ^ B) & C) ^ B) + (unsigned int )*(X + 2)) + 1548603684UL));
#line 200
  E = ((E << 11) ^ (E >> 21)) + D;
#line 200
  B = (B << 10) ^ (B >> 22);
#line 202
  D = (unsigned int )((unsigned long )D + ((unsigned long )(((E | ~ A) ^ B) + (unsigned int )*(X + 15)) + 1836072691UL));
#line 202
  D = ((D << 9) ^ (D >> 23)) + C;
#line 202
  A = (A << 10) ^ (A >> 22);
#line 203
  C = (unsigned int )((unsigned long )C + ((unsigned long )(((D | ~ E) ^ A) + (unsigned int )*(X + 5)) + 1836072691UL));
#line 203
  C = ((C << 7) ^ (C >> 25)) + B;
#line 203
  E = (E << 10) ^ (E >> 22);
#line 204
  B = (unsigned int )((unsigned long )B + ((unsigned long )(((C | ~ D) ^ E) + (unsigned int )*(X + 1)) + 1836072691UL));
#line 204
  B = ((B << 15) ^ (B >> 17)) + A;
#line 204
  D = (D << 10) ^ (D >> 22);
#line 205
  A = (unsigned int )((unsigned long )A + ((unsigned long )(((B | ~ C) ^ D) + (unsigned int )*(X + 3)) + 1836072691UL));
#line 205
  A = ((A << 11) ^ (A >> 21)) + E;
#line 205
  C = (C << 10) ^ (C >> 22);
#line 206
  E = (unsigned int )((unsigned long )E + ((unsigned long )(((A | ~ B) ^ C) + (unsigned int )*(X + 7)) + 1836072691UL));
#line 206
  E = ((E << 8) ^ (E >> 24)) + D;
#line 206
  B = (B << 10) ^ (B >> 22);
#line 207
  D = (unsigned int )((unsigned long )D + ((unsigned long )(((E | ~ A) ^ B) + (unsigned int )*(X + 14)) + 1836072691UL));
#line 207
  D = ((D << 6) ^ (D >> 26)) + C;
#line 207
  A = (A << 10) ^ (A >> 22);
#line 208
  C = (unsigned int )((unsigned long )C + ((unsigned long )(((D | ~ E) ^ A) + (unsigned int )*(X + 6)) + 1836072691UL));
#line 208
  C = ((C << 6) ^ (C >> 26)) + B;
#line 208
  E = (E << 10) ^ (E >> 22);
#line 209
  B = (unsigned int )((unsigned long )B + ((unsigned long )(((C | ~ D) ^ E) + (unsigned int )*(X + 9)) + 1836072691UL));
#line 209
  B = ((B << 14) ^ (B >> 18)) + A;
#line 209
  D = (D << 10) ^ (D >> 22);
#line 210
  A = (unsigned int )((unsigned long )A + ((unsigned long )(((B | ~ C) ^ D) + (unsigned int )*(X + 11)) + 1836072691UL));
#line 210
  A = ((A << 12) ^ (A >> 20)) + E;
#line 210
  C = (C << 10) ^ (C >> 22);
#line 211
  E = (unsigned int )((unsigned long )E + ((unsigned long )(((A | ~ B) ^ C) + (unsigned int )*(X + 8)) + 1836072691UL));
#line 211
  E = ((E << 13) ^ (E >> 19)) + D;
#line 211
  B = (B << 10) ^ (B >> 22);
#line 212
  D = (unsigned int )((unsigned long )D + ((unsigned long )(((E | ~ A) ^ B) + (unsigned int )*(X + 12)) + 1836072691UL));
#line 212
  D = ((D << 5) ^ (D >> 27)) + C;
#line 212
  A = (A << 10) ^ (A >> 22);
#line 213
  C = (unsigned int )((unsigned long )C + ((unsigned long )(((D | ~ E) ^ A) + (unsigned int )*(X + 2)) + 1836072691UL));
#line 213
  C = ((C << 14) ^ (C >> 18)) + B;
#line 213
  E = (E << 10) ^ (E >> 22);
#line 214
  B = (unsigned int )((unsigned long )B + ((unsigned long )(((C | ~ D) ^ E) + (unsigned int )*(X + 10)) + 1836072691UL));
#line 214
  B = ((B << 13) ^ (B >> 19)) + A;
#line 214
  D = (D << 10) ^ (D >> 22);
#line 215
  A = (unsigned int )((unsigned long )A + ((unsigned long )(((B | ~ C) ^ D) + (unsigned int )*(X + 0)) + 1836072691UL));
#line 215
  A = ((A << 13) ^ (A >> 19)) + E;
#line 215
  C = (C << 10) ^ (C >> 22);
#line 216
  E = (unsigned int )((unsigned long )E + ((unsigned long )(((A | ~ B) ^ C) + (unsigned int )*(X + 4)) + 1836072691UL));
#line 216
  E = ((E << 7) ^ (E >> 25)) + D;
#line 216
  B = (B << 10) ^ (B >> 22);
#line 217
  D = (unsigned int )((unsigned long )D + ((unsigned long )(((E | ~ A) ^ B) + (unsigned int )*(X + 13)) + 1836072691UL));
#line 217
  D = ((D << 5) ^ (D >> 27)) + C;
#line 217
  A = (A << 10) ^ (A >> 22);
#line 219
  C = (unsigned int )((unsigned long )C + ((unsigned long )((((E ^ A) & D) ^ A) + (unsigned int )*(X + 8)) + 2053994217UL));
#line 219
  C = ((C << 15) ^ (C >> 17)) + B;
#line 219
  E = (E << 10) ^ (E >> 22);
#line 220
  B = (unsigned int )((unsigned long )B + ((unsigned long )((((D ^ E) & C) ^ E) + (unsigned int )*(X + 6)) + 2053994217UL));
#line 220
  B = ((B << 5) ^ (B >> 27)) + A;
#line 220
  D = (D << 10) ^ (D >> 22);
#line 221
  A = (unsigned int )((unsigned long )A + ((unsigned long )((((C ^ D) & B) ^ D) + (unsigned int )*(X + 4)) + 2053994217UL));
#line 221
  A = ((A << 8) ^ (A >> 24)) + E;
#line 221
  C = (C << 10) ^ (C >> 22);
#line 222
  E = (unsigned int )((unsigned long )E + ((unsigned long )((((B ^ C) & A) ^ C) + (unsigned int )*(X + 1)) + 2053994217UL));
#line 222
  E = ((E << 11) ^ (E >> 21)) + D;
#line 222
  B = (B << 10) ^ (B >> 22);
#line 223
  D = (unsigned int )((unsigned long )D + ((unsigned long )((((A ^ B) & E) ^ B) + (unsigned int )*(X + 3)) + 2053994217UL));
#line 223
  D = ((D << 14) ^ (D >> 18)) + C;
#line 223
  A = (A << 10) ^ (A >> 22);
#line 224
  C = (unsigned int )((unsigned long )C + ((unsigned long )((((E ^ A) & D) ^ A) + (unsigned int )*(X + 11)) + 2053994217UL));
#line 224
  C = ((C << 14) ^ (C >> 18)) + B;
#line 224
  E = (E << 10) ^ (E >> 22);
#line 225
  B = (unsigned int )((unsigned long )B + ((unsigned long )((((D ^ E) & C) ^ E) + (unsigned int )*(X + 15)) + 2053994217UL));
#line 225
  B = ((B << 6) ^ (B >> 26)) + A;
#line 225
  D = (D << 10) ^ (D >> 22);
#line 226
  A = (unsigned int )((unsigned long )A + ((unsigned long )((((C ^ D) & B) ^ D) + (unsigned int )*(X + 0)) + 2053994217UL));
#line 226
  A = ((A << 14) ^ (A >> 18)) + E;
#line 226
  C = (C << 10) ^ (C >> 22);
#line 227
  E = (unsigned int )((unsigned long )E + ((unsigned long )((((B ^ C) & A) ^ C) + (unsigned int )*(X + 5)) + 2053994217UL));
#line 227
  E = ((E << 6) ^ (E >> 26)) + D;
#line 227
  B = (B << 10) ^ (B >> 22);
#line 228
  D = (unsigned int )((unsigned long )D + ((unsigned long )((((A ^ B) & E) ^ B) + (unsigned int )*(X + 12)) + 2053994217UL));
#line 228
  D = ((D << 9) ^ (D >> 23)) + C;
#line 228
  A = (A << 10) ^ (A >> 22);
#line 229
  C = (unsigned int )((unsigned long )C + ((unsigned long )((((E ^ A) & D) ^ A) + (unsigned int )*(X + 2)) + 2053994217UL));
#line 229
  C = ((C << 12) ^ (C >> 20)) + B;
#line 229
  E = (E << 10) ^ (E >> 22);
#line 230
  B = (unsigned int )((unsigned long )B + ((unsigned long )((((D ^ E) & C) ^ E) + (unsigned int )*(X + 13)) + 2053994217UL));
#line 230
  B = ((B << 9) ^ (B >> 23)) + A;
#line 230
  D = (D << 10) ^ (D >> 22);
#line 231
  A = (unsigned int )((unsigned long )A + ((unsigned long )((((C ^ D) & B) ^ D) + (unsigned int )*(X + 9)) + 2053994217UL));
#line 231
  A = ((A << 12) ^ (A >> 20)) + E;
#line 231
  C = (C << 10) ^ (C >> 22);
#line 232
  E = (unsigned int )((unsigned long )E + ((unsigned long )((((B ^ C) & A) ^ C) + (unsigned int )*(X + 7)) + 2053994217UL));
#line 232
  E = ((E << 5) ^ (E >> 27)) + D;
#line 232
  B = (B << 10) ^ (B >> 22);
#line 233
  D = (unsigned int )((unsigned long )D + ((unsigned long )((((A ^ B) & E) ^ B) + (unsigned int )*(X + 10)) + 2053994217UL));
#line 233
  D = ((D << 15) ^ (D >> 17)) + C;
#line 233
  A = (A << 10) ^ (A >> 22);
#line 234
  C = (unsigned int )((unsigned long )C + ((unsigned long )((((E ^ A) & D) ^ A) + (unsigned int )*(X + 14)) + 2053994217UL));
#line 234
  C = ((C << 8) ^ (C >> 24)) + B;
#line 234
  E = (E << 10) ^ (E >> 22);
#line 236
  B += ((C ^ D) ^ E) + (unsigned int )*(X + 12);
#line 236
  B = ((B << 8) ^ (B >> 24)) + A;
#line 236
  D = (D << 10) ^ (D >> 22);
#line 237
  A += ((B ^ C) ^ D) + (unsigned int )*(X + 15);
#line 237
  A = ((A << 5) ^ (A >> 27)) + E;
#line 237
  C = (C << 10) ^ (C >> 22);
#line 238
  E += ((A ^ B) ^ C) + (unsigned int )*(X + 10);
#line 238
  E = ((E << 12) ^ (E >> 20)) + D;
#line 238
  B = (B << 10) ^ (B >> 22);
#line 239
  D += ((E ^ A) ^ B) + (unsigned int )*(X + 4);
#line 239
  D = ((D << 9) ^ (D >> 23)) + C;
#line 239
  A = (A << 10) ^ (A >> 22);
#line 240
  C += ((D ^ E) ^ A) + (unsigned int )*(X + 1);
#line 240
  C = ((C << 12) ^ (C >> 20)) + B;
#line 240
  E = (E << 10) ^ (E >> 22);
#line 241
  B += ((C ^ D) ^ E) + (unsigned int )*(X + 5);
#line 241
  B = ((B << 5) ^ (B >> 27)) + A;
#line 241
  D = (D << 10) ^ (D >> 22);
#line 242
  A += ((B ^ C) ^ D) + (unsigned int )*(X + 8);
#line 242
  A = ((A << 14) ^ (A >> 18)) + E;
#line 242
  C = (C << 10) ^ (C >> 22);
#line 243
  E += ((A ^ B) ^ C) + (unsigned int )*(X + 7);
#line 243
  E = ((E << 6) ^ (E >> 26)) + D;
#line 243
  B = (B << 10) ^ (B >> 22);
#line 244
  D += ((E ^ A) ^ B) + (unsigned int )*(X + 6);
#line 244
  D = ((D << 8) ^ (D >> 24)) + C;
#line 244
  A = (A << 10) ^ (A >> 22);
#line 245
  C += ((D ^ E) ^ A) + (unsigned int )*(X + 2);
#line 245
  C = ((C << 13) ^ (C >> 19)) + B;
#line 245
  E = (E << 10) ^ (E >> 22);
#line 246
  B += ((C ^ D) ^ E) + (unsigned int )*(X + 13);
#line 246
  B = ((B << 6) ^ (B >> 26)) + A;
#line 246
  D = (D << 10) ^ (D >> 22);
#line 247
  A += ((B ^ C) ^ D) + (unsigned int )*(X + 14);
#line 247
  A = ((A << 5) ^ (A >> 27)) + E;
#line 247
  C = (C << 10) ^ (C >> 22);
#line 248
  E += ((A ^ B) ^ C) + (unsigned int )*(X + 0);
#line 248
  E = ((E << 15) ^ (E >> 17)) + D;
#line 248
  B = (B << 10) ^ (B >> 22);
#line 249
  D += ((E ^ A) ^ B) + (unsigned int )*(X + 3);
#line 249
  D = ((D << 13) ^ (D >> 19)) + C;
#line 249
  A = (A << 10) ^ (A >> 22);
#line 250
  C += ((D ^ E) ^ A) + (unsigned int )*(X + 9);
#line 250
  C = ((C << 11) ^ (C >> 21)) + B;
#line 250
  E = (E << 10) ^ (E >> 22);
#line 251
  B += ((C ^ D) ^ E) + (unsigned int )*(X + 11);
#line 251
  B = ((B << 11) ^ (B >> 21)) + A;
#line 251
  D = (D << 10) ^ (D >> 22);
#line 254
  D += c1 + *(hash + 1);
#line 255
  *(hash + 1) = (*(hash + 2) + d1) + E;
#line 256
  *(hash + 2) = (*(hash + 3) + e1) + A;
#line 257
  *(hash + 3) = (*(hash + 4) + a1) + B;
#line 258
  *(hash + 4) = (*(hash + 0) + b1) + C;
#line 259
  *(hash + 0) = D;
#line 260
  return;
}
}
#line 270 "/home/june/repo/benchmarks/collector/temp/rhash-1.3.1/librhash/ripemd-160.c"
void rhash_ripemd160_update(ripemd160_ctx *ctx , unsigned char const   *msg , size_t size ) 
{ 
  unsigned int index___0 ;
  unsigned int left ;
  size_t tmp ;
  unsigned int *aligned_message_block ;

  {
#line 272
  index___0 = (unsigned int )ctx->length & 63U;
#line 273
  ctx->length += size;
#line 276
  if (index___0) {
#line 277
    left = 64U - index___0;
#line 278
    if (size < (size_t )left) {
#line 278
      tmp = size;
    } else {
#line 278
      tmp = (size_t )left;
    }
    {
#line 278
    memcpy((void */* __restrict  */)((char *)(ctx->message) + index___0), (void const   */* __restrict  */)msg,
           tmp);
    }
#line 279
    if (size < (size_t )left) {
#line 279
      return;
    }
    {
#line 282
    rhash_ripemd160_process_block(ctx->hash, (unsigned int const   *)(ctx->message));
#line 283
    msg += left;
#line 284
    size -= (size_t )left;
    }
  }
  {
#line 286
  while (1) {
    while_continue: /* CIL Label */ ;
#line 286
    if (! (size >= 64UL)) {
#line 286
      goto while_break;
    }
#line 288
    if (0L == (3L & ((char const   *)msg - (char const   *)0))) {
#line 291
      aligned_message_block = (unsigned int *)msg;
    } else {
      {
#line 293
      memcpy((void */* __restrict  */)(ctx->message + 0), (void const   */* __restrict  */)msg,
             (size_t )64);
#line 294
      aligned_message_block = ctx->message;
      }
    }
    {
#line 297
    rhash_ripemd160_process_block(ctx->hash, (unsigned int const   *)aligned_message_block);
#line 298
    msg += 64;
#line 299
    size -= 64UL;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 301
  if (size) {
    {
#line 303
    memcpy((void */* __restrict  */)(ctx->message + 0), (void const   */* __restrict  */)msg,
           size);
    }
  }
#line 305
  return;
}
}
#line 313 "/home/june/repo/benchmarks/collector/temp/rhash-1.3.1/librhash/ripemd-160.c"
void rhash_ripemd160_final(ripemd160_ctx *ctx , unsigned char *result ) 
{ 
  unsigned int index___0 ;
  unsigned int shift ;
  unsigned int tmp ;
  unsigned int tmp___0 ;
  unsigned int tmp___1 ;

  {
#line 315
  index___0 = ((unsigned int )ctx->length & 63U) >> 2;
#line 316
  shift = ((unsigned int )ctx->length & 3U) * 8U;
#line 321
  ctx->message[index___0] &= ~ (4294967295U << shift);
#line 322
  tmp = index___0;
#line 322
  index___0 ++;
#line 322
  ctx->message[tmp] ^= (unsigned int )(128 << shift);
#line 325
  if (index___0 > 14U) {
    {
#line 327
    while (1) {
      while_continue: /* CIL Label */ ;
#line 327
      if (! (index___0 < 16U)) {
#line 327
        goto while_break;
      }
#line 328
      tmp___0 = index___0;
#line 328
      index___0 ++;
#line 328
      ctx->message[tmp___0] = 0U;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 330
    rhash_ripemd160_process_block(ctx->hash, (unsigned int const   *)(ctx->message));
#line 331
    index___0 = 0U;
    }
  }
  {
#line 333
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 333
    if (! (index___0 < 14U)) {
#line 333
      goto while_break___0;
    }
#line 334
    tmp___1 = index___0;
#line 334
    index___0 ++;
#line 334
    ctx->message[tmp___1] = 0U;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 336
  ctx->message[14] = (unsigned int )(ctx->length << 3);
#line 337
  ctx->message[15] = (unsigned int )(ctx->length >> 29);
#line 338
  rhash_ripemd160_process_block(ctx->hash, (unsigned int const   *)(ctx->message));
#line 340
  memcpy((void */* __restrict  */)(result + 0), (void const   */* __restrict  */)(& ctx->hash),
         (size_t )20);
  }
#line 341
  return;
}
}
#line 22 "/home/june/repo/benchmarks/collector/temp/rhash-1.3.1/librhash/has160.h"
void rhash_has160_init(has160_ctx *ctx ) ;
#line 23
void rhash_has160_update(has160_ctx *ctx , unsigned char const   *msg , size_t size ) ;
#line 24
void rhash_has160_final(has160_ctx *ctx , unsigned char *result ) ;
#line 34 "/home/june/repo/benchmarks/collector/temp/rhash-1.3.1/librhash/has160.c"
void rhash_has160_init(has160_ctx *ctx ) 
{ 


  {
#line 36
  ctx->length = (uint64_t )0;
#line 39
  ctx->hash[0] = 1732584193U;
#line 40
  ctx->hash[1] = 4023233417U;
#line 41
  ctx->hash[2] = 2562383102U;
#line 42
  ctx->hash[3] = 271733878U;
#line 43
  ctx->hash[4] = 3285377520U;
#line 44
  return;
}
}
#line 70 "/home/june/repo/benchmarks/collector/temp/rhash-1.3.1/librhash/has160.c"
static void rhash_has160_process_block(unsigned int *hash , unsigned int const   *block ) 
{ 
  unsigned int X[32] ;
  unsigned int j ;
  unsigned int A ;
  unsigned int B ;
  unsigned int C ;
  unsigned int D ;
  unsigned int E ;

  {
#line 75
  j = 0U;
  {
#line 75
  while (1) {
    while_continue: /* CIL Label */ ;
#line 75
    if (! (j < 16U)) {
#line 75
      goto while_break;
    }
#line 76
    X[j] = (unsigned int )*(block + j);
#line 75
    j ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 79
  X[16] = ((X[0] ^ X[1]) ^ X[2]) ^ X[3];
#line 80
  X[17] = ((X[4] ^ X[5]) ^ X[6]) ^ X[7];
#line 81
  X[18] = ((X[8] ^ X[9]) ^ X[10]) ^ X[11];
#line 82
  X[19] = ((X[12] ^ X[13]) ^ X[14]) ^ X[15];
#line 83
  X[20] = ((X[3] ^ X[6]) ^ X[9]) ^ X[12];
#line 84
  X[21] = ((X[2] ^ X[5]) ^ X[8]) ^ X[15];
#line 85
  X[22] = ((X[1] ^ X[4]) ^ X[11]) ^ X[14];
#line 86
  X[23] = ((X[0] ^ X[7]) ^ X[10]) ^ X[13];
#line 87
  X[24] = ((X[5] ^ X[7]) ^ X[12]) ^ X[14];
#line 88
  X[25] = ((X[0] ^ X[2]) ^ X[9]) ^ X[11];
#line 89
  X[26] = ((X[4] ^ X[6]) ^ X[13]) ^ X[15];
#line 90
  X[27] = ((X[1] ^ X[3]) ^ X[8]) ^ X[10];
#line 91
  X[28] = ((X[2] ^ X[7]) ^ X[8]) ^ X[13];
#line 92
  X[29] = ((X[3] ^ X[4]) ^ X[9]) ^ X[14];
#line 93
  X[30] = ((X[0] ^ X[5]) ^ X[10]) ^ X[15];
#line 94
  X[31] = ((X[1] ^ X[6]) ^ X[11]) ^ X[12];
#line 101
  A = *(hash + 0);
#line 102
  B = *(hash + 1);
#line 103
  C = *(hash + 2);
#line 104
  D = *(hash + 3);
#line 105
  E = *(hash + 4);
#line 107
  E += (((A << 5) ^ (A >> 27)) + (D ^ (B & (C ^ D)))) + X[18];
#line 107
  B = (B << 10) ^ (B >> 22);
#line 108
  D += (((E << 11) ^ (E >> 21)) + (C ^ (A & (B ^ C)))) + X[0];
#line 108
  A = (A << 10) ^ (A >> 22);
#line 109
  C += (((D << 7) ^ (D >> 25)) + (B ^ (E & (A ^ B)))) + X[1];
#line 109
  E = (E << 10) ^ (E >> 22);
#line 110
  B += (((C << 15) ^ (C >> 17)) + (A ^ (D & (E ^ A)))) + X[2];
#line 110
  D = (D << 10) ^ (D >> 22);
#line 111
  A += (((B << 6) ^ (B >> 26)) + (E ^ (C & (D ^ E)))) + X[3];
#line 111
  C = (C << 10) ^ (C >> 22);
#line 112
  E += (((A << 13) ^ (A >> 19)) + (D ^ (B & (C ^ D)))) + X[19];
#line 112
  B = (B << 10) ^ (B >> 22);
#line 113
  D += (((E << 8) ^ (E >> 24)) + (C ^ (A & (B ^ C)))) + X[4];
#line 113
  A = (A << 10) ^ (A >> 22);
#line 114
  C += (((D << 14) ^ (D >> 18)) + (B ^ (E & (A ^ B)))) + X[5];
#line 114
  E = (E << 10) ^ (E >> 22);
#line 115
  B += (((C << 7) ^ (C >> 25)) + (A ^ (D & (E ^ A)))) + X[6];
#line 115
  D = (D << 10) ^ (D >> 22);
#line 116
  A += (((B << 12) ^ (B >> 20)) + (E ^ (C & (D ^ E)))) + X[7];
#line 116
  C = (C << 10) ^ (C >> 22);
#line 117
  E += (((A << 9) ^ (A >> 23)) + (D ^ (B & (C ^ D)))) + X[16];
#line 117
  B = (B << 10) ^ (B >> 22);
#line 118
  D += (((E << 11) ^ (E >> 21)) + (C ^ (A & (B ^ C)))) + X[8];
#line 118
  A = (A << 10) ^ (A >> 22);
#line 119
  C += (((D << 8) ^ (D >> 24)) + (B ^ (E & (A ^ B)))) + X[9];
#line 119
  E = (E << 10) ^ (E >> 22);
#line 120
  B += (((C << 15) ^ (C >> 17)) + (A ^ (D & (E ^ A)))) + X[10];
#line 120
  D = (D << 10) ^ (D >> 22);
#line 121
  A += (((B << 6) ^ (B >> 26)) + (E ^ (C & (D ^ E)))) + X[11];
#line 121
  C = (C << 10) ^ (C >> 22);
#line 122
  E += (((A << 12) ^ (A >> 20)) + (D ^ (B & (C ^ D)))) + X[17];
#line 122
  B = (B << 10) ^ (B >> 22);
#line 123
  D += (((E << 9) ^ (E >> 23)) + (C ^ (A & (B ^ C)))) + X[12];
#line 123
  A = (A << 10) ^ (A >> 22);
#line 124
  C += (((D << 14) ^ (D >> 18)) + (B ^ (E & (A ^ B)))) + X[13];
#line 124
  E = (E << 10) ^ (E >> 22);
#line 125
  B += (((C << 5) ^ (C >> 27)) + (A ^ (D & (E ^ A)))) + X[14];
#line 125
  D = (D << 10) ^ (D >> 22);
#line 126
  A += (((B << 13) ^ (B >> 19)) + (E ^ (C & (D ^ E)))) + X[15];
#line 126
  C = (C << 10) ^ (C >> 22);
#line 128
  E += ((((A << 5) ^ (A >> 27)) + ((B ^ C) ^ D)) + X[22]) + 1518500249U;
#line 128
  B = (B << 17) ^ (B >> 15);
#line 129
  D += ((((E << 11) ^ (E >> 21)) + ((A ^ B) ^ C)) + X[3]) + 1518500249U;
#line 129
  A = (A << 17) ^ (A >> 15);
#line 130
  C += ((((D << 7) ^ (D >> 25)) + ((E ^ A) ^ B)) + X[6]) + 1518500249U;
#line 130
  E = (E << 17) ^ (E >> 15);
#line 131
  B += ((((C << 15) ^ (C >> 17)) + ((D ^ E) ^ A)) + X[9]) + 1518500249U;
#line 131
  D = (D << 17) ^ (D >> 15);
#line 132
  A += ((((B << 6) ^ (B >> 26)) + ((C ^ D) ^ E)) + X[12]) + 1518500249U;
#line 132
  C = (C << 17) ^ (C >> 15);
#line 133
  E += ((((A << 13) ^ (A >> 19)) + ((B ^ C) ^ D)) + X[23]) + 1518500249U;
#line 133
  B = (B << 17) ^ (B >> 15);
#line 134
  D += ((((E << 8) ^ (E >> 24)) + ((A ^ B) ^ C)) + X[15]) + 1518500249U;
#line 134
  A = (A << 17) ^ (A >> 15);
#line 135
  C += ((((D << 14) ^ (D >> 18)) + ((E ^ A) ^ B)) + X[2]) + 1518500249U;
#line 135
  E = (E << 17) ^ (E >> 15);
#line 136
  B += ((((C << 7) ^ (C >> 25)) + ((D ^ E) ^ A)) + X[5]) + 1518500249U;
#line 136
  D = (D << 17) ^ (D >> 15);
#line 137
  A += ((((B << 12) ^ (B >> 20)) + ((C ^ D) ^ E)) + X[8]) + 1518500249U;
#line 137
  C = (C << 17) ^ (C >> 15);
#line 138
  E += ((((A << 9) ^ (A >> 23)) + ((B ^ C) ^ D)) + X[20]) + 1518500249U;
#line 138
  B = (B << 17) ^ (B >> 15);
#line 139
  D += ((((E << 11) ^ (E >> 21)) + ((A ^ B) ^ C)) + X[11]) + 1518500249U;
#line 139
  A = (A << 17) ^ (A >> 15);
#line 140
  C += ((((D << 8) ^ (D >> 24)) + ((E ^ A) ^ B)) + X[14]) + 1518500249U;
#line 140
  E = (E << 17) ^ (E >> 15);
#line 141
  B += ((((C << 15) ^ (C >> 17)) + ((D ^ E) ^ A)) + X[1]) + 1518500249U;
#line 141
  D = (D << 17) ^ (D >> 15);
#line 142
  A += ((((B << 6) ^ (B >> 26)) + ((C ^ D) ^ E)) + X[4]) + 1518500249U;
#line 142
  C = (C << 17) ^ (C >> 15);
#line 143
  E += ((((A << 12) ^ (A >> 20)) + ((B ^ C) ^ D)) + X[21]) + 1518500249U;
#line 143
  B = (B << 17) ^ (B >> 15);
#line 144
  D += ((((E << 9) ^ (E >> 23)) + ((A ^ B) ^ C)) + X[7]) + 1518500249U;
#line 144
  A = (A << 17) ^ (A >> 15);
#line 145
  C += ((((D << 14) ^ (D >> 18)) + ((E ^ A) ^ B)) + X[10]) + 1518500249U;
#line 145
  E = (E << 17) ^ (E >> 15);
#line 146
  B += ((((C << 5) ^ (C >> 27)) + ((D ^ E) ^ A)) + X[13]) + 1518500249U;
#line 146
  D = (D << 17) ^ (D >> 15);
#line 147
  A += ((((B << 13) ^ (B >> 19)) + ((C ^ D) ^ E)) + X[0]) + 1518500249U;
#line 147
  C = (C << 17) ^ (C >> 15);
#line 149
  E += ((((A << 5) ^ (A >> 27)) + (C ^ (B | ~ D))) + X[26]) + 1859775393U;
#line 149
  B = (B << 25) ^ (B >> 7);
#line 150
  D += ((((E << 11) ^ (E >> 21)) + (B ^ (A | ~ C))) + X[12]) + 1859775393U;
#line 150
  A = (A << 25) ^ (A >> 7);
#line 151
  C += ((((D << 7) ^ (D >> 25)) + (A ^ (E | ~ B))) + X[5]) + 1859775393U;
#line 151
  E = (E << 25) ^ (E >> 7);
#line 152
  B += ((((C << 15) ^ (C >> 17)) + (E ^ (D | ~ A))) + X[14]) + 1859775393U;
#line 152
  D = (D << 25) ^ (D >> 7);
#line 153
  A += ((((B << 6) ^ (B >> 26)) + (D ^ (C | ~ E))) + X[7]) + 1859775393U;
#line 153
  C = (C << 25) ^ (C >> 7);
#line 154
  E += ((((A << 13) ^ (A >> 19)) + (C ^ (B | ~ D))) + X[27]) + 1859775393U;
#line 154
  B = (B << 25) ^ (B >> 7);
#line 155
  D += ((((E << 8) ^ (E >> 24)) + (B ^ (A | ~ C))) + X[0]) + 1859775393U;
#line 155
  A = (A << 25) ^ (A >> 7);
#line 156
  C += ((((D << 14) ^ (D >> 18)) + (A ^ (E | ~ B))) + X[9]) + 1859775393U;
#line 156
  E = (E << 25) ^ (E >> 7);
#line 157
  B += ((((C << 7) ^ (C >> 25)) + (E ^ (D | ~ A))) + X[2]) + 1859775393U;
#line 157
  D = (D << 25) ^ (D >> 7);
#line 158
  A += ((((B << 12) ^ (B >> 20)) + (D ^ (C | ~ E))) + X[11]) + 1859775393U;
#line 158
  C = (C << 25) ^ (C >> 7);
#line 159
  E += ((((A << 9) ^ (A >> 23)) + (C ^ (B | ~ D))) + X[24]) + 1859775393U;
#line 159
  B = (B << 25) ^ (B >> 7);
#line 160
  D += ((((E << 11) ^ (E >> 21)) + (B ^ (A | ~ C))) + X[4]) + 1859775393U;
#line 160
  A = (A << 25) ^ (A >> 7);
#line 161
  C += ((((D << 8) ^ (D >> 24)) + (A ^ (E | ~ B))) + X[13]) + 1859775393U;
#line 161
  E = (E << 25) ^ (E >> 7);
#line 162
  B += ((((C << 15) ^ (C >> 17)) + (E ^ (D | ~ A))) + X[6]) + 1859775393U;
#line 162
  D = (D << 25) ^ (D >> 7);
#line 163
  A += ((((B << 6) ^ (B >> 26)) + (D ^ (C | ~ E))) + X[15]) + 1859775393U;
#line 163
  C = (C << 25) ^ (C >> 7);
#line 164
  E += ((((A << 12) ^ (A >> 20)) + (C ^ (B | ~ D))) + X[25]) + 1859775393U;
#line 164
  B = (B << 25) ^ (B >> 7);
#line 165
  D += ((((E << 9) ^ (E >> 23)) + (B ^ (A | ~ C))) + X[8]) + 1859775393U;
#line 165
  A = (A << 25) ^ (A >> 7);
#line 166
  C += ((((D << 14) ^ (D >> 18)) + (A ^ (E | ~ B))) + X[1]) + 1859775393U;
#line 166
  E = (E << 25) ^ (E >> 7);
#line 167
  B += ((((C << 5) ^ (C >> 27)) + (E ^ (D | ~ A))) + X[10]) + 1859775393U;
#line 167
  D = (D << 25) ^ (D >> 7);
#line 168
  A += ((((B << 13) ^ (B >> 19)) + (D ^ (C | ~ E))) + X[3]) + 1859775393U;
#line 168
  C = (C << 25) ^ (C >> 7);
#line 170
  E += ((((A << 5) ^ (A >> 27)) + ((B ^ C) ^ D)) + X[30]) + 2400959708U;
#line 170
  B = (B << 30) ^ (B >> 2);
#line 171
  D += ((((E << 11) ^ (E >> 21)) + ((A ^ B) ^ C)) + X[7]) + 2400959708U;
#line 171
  A = (A << 30) ^ (A >> 2);
#line 172
  C += ((((D << 7) ^ (D >> 25)) + ((E ^ A) ^ B)) + X[2]) + 2400959708U;
#line 172
  E = (E << 30) ^ (E >> 2);
#line 173
  B += ((((C << 15) ^ (C >> 17)) + ((D ^ E) ^ A)) + X[13]) + 2400959708U;
#line 173
  D = (D << 30) ^ (D >> 2);
#line 174
  A += ((((B << 6) ^ (B >> 26)) + ((C ^ D) ^ E)) + X[8]) + 2400959708U;
#line 174
  C = (C << 30) ^ (C >> 2);
#line 175
  E += ((((A << 13) ^ (A >> 19)) + ((B ^ C) ^ D)) + X[31]) + 2400959708U;
#line 175
  B = (B << 30) ^ (B >> 2);
#line 176
  D += ((((E << 8) ^ (E >> 24)) + ((A ^ B) ^ C)) + X[3]) + 2400959708U;
#line 176
  A = (A << 30) ^ (A >> 2);
#line 177
  C += ((((D << 14) ^ (D >> 18)) + ((E ^ A) ^ B)) + X[14]) + 2400959708U;
#line 177
  E = (E << 30) ^ (E >> 2);
#line 178
  B += ((((C << 7) ^ (C >> 25)) + ((D ^ E) ^ A)) + X[9]) + 2400959708U;
#line 178
  D = (D << 30) ^ (D >> 2);
#line 179
  A += ((((B << 12) ^ (B >> 20)) + ((C ^ D) ^ E)) + X[4]) + 2400959708U;
#line 179
  C = (C << 30) ^ (C >> 2);
#line 180
  E += ((((A << 9) ^ (A >> 23)) + ((B ^ C) ^ D)) + X[28]) + 2400959708U;
#line 180
  B = (B << 30) ^ (B >> 2);
#line 181
  D += ((((E << 11) ^ (E >> 21)) + ((A ^ B) ^ C)) + X[15]) + 2400959708U;
#line 181
  A = (A << 30) ^ (A >> 2);
#line 182
  C += ((((D << 8) ^ (D >> 24)) + ((E ^ A) ^ B)) + X[10]) + 2400959708U;
#line 182
  E = (E << 30) ^ (E >> 2);
#line 183
  B += ((((C << 15) ^ (C >> 17)) + ((D ^ E) ^ A)) + X[5]) + 2400959708U;
#line 183
  D = (D << 30) ^ (D >> 2);
#line 184
  A += ((((B << 6) ^ (B >> 26)) + ((C ^ D) ^ E)) + X[0]) + 2400959708U;
#line 184
  C = (C << 30) ^ (C >> 2);
#line 185
  E += ((((A << 12) ^ (A >> 20)) + ((B ^ C) ^ D)) + X[29]) + 2400959708U;
#line 185
  B = (B << 30) ^ (B >> 2);
#line 186
  D += ((((E << 9) ^ (E >> 23)) + ((A ^ B) ^ C)) + X[11]) + 2400959708U;
#line 186
  A = (A << 30) ^ (A >> 2);
#line 187
  C += ((((D << 14) ^ (D >> 18)) + ((E ^ A) ^ B)) + X[6]) + 2400959708U;
#line 187
  E = (E << 30) ^ (E >> 2);
#line 188
  B += ((((C << 5) ^ (C >> 27)) + ((D ^ E) ^ A)) + X[1]) + 2400959708U;
#line 188
  D = (D << 30) ^ (D >> 2);
#line 189
  A += ((((B << 13) ^ (B >> 19)) + ((C ^ D) ^ E)) + X[12]) + 2400959708U;
#line 189
  C = (C << 30) ^ (C >> 2);
#line 191
  *(hash + 0) += A;
#line 192
  *(hash + 1) += B;
#line 193
  *(hash + 2) += C;
#line 194
  *(hash + 3) += D;
#line 195
  *(hash + 4) += E;
#line 197
  return;
}
}
#line 207 "/home/june/repo/benchmarks/collector/temp/rhash-1.3.1/librhash/has160.c"
void rhash_has160_update(has160_ctx *ctx , unsigned char const   *msg , size_t size ) 
{ 
  unsigned int index___0 ;
  unsigned int left ;
  size_t tmp ;
  unsigned int *aligned_message_block ;

  {
#line 209
  index___0 = (unsigned int )ctx->length & 63U;
#line 210
  ctx->length += size;
#line 213
  if (index___0) {
#line 214
    left = 64U - index___0;
#line 215
    if (size < (size_t )left) {
#line 215
      tmp = size;
    } else {
#line 215
      tmp = (size_t )left;
    }
    {
#line 215
    memcpy((void */* __restrict  */)((char *)(ctx->message) + index___0), (void const   */* __restrict  */)msg,
           tmp);
    }
#line 216
    if (size < (size_t )left) {
#line 216
      return;
    }
    {
#line 219
    rhash_has160_process_block(ctx->hash, (unsigned int const   *)(ctx->message));
#line 220
    msg += left;
#line 221
    size -= (size_t )left;
    }
  }
  {
#line 223
  while (1) {
    while_continue: /* CIL Label */ ;
#line 223
    if (! (size >= 64UL)) {
#line 223
      goto while_break;
    }
#line 225
    if (0L == (3L & ((char const   *)msg - (char const   *)0))) {
#line 228
      aligned_message_block = (unsigned int *)msg;
    } else {
      {
#line 230
      memcpy((void */* __restrict  */)(ctx->message), (void const   */* __restrict  */)msg,
             (size_t )64);
#line 231
      aligned_message_block = ctx->message;
      }
    }
    {
#line 234
    rhash_has160_process_block(ctx->hash, (unsigned int const   *)aligned_message_block);
#line 235
    msg += 64;
#line 236
    size -= 64UL;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 238
  if (size) {
    {
#line 240
    memcpy((void */* __restrict  */)(ctx->message), (void const   */* __restrict  */)msg,
           size);
    }
  }
#line 242
  return;
}
}
#line 250 "/home/june/repo/benchmarks/collector/temp/rhash-1.3.1/librhash/has160.c"
void rhash_has160_final(has160_ctx *ctx , unsigned char *result ) 
{ 
  unsigned int shift ;
  unsigned int index___0 ;
  unsigned int tmp ;
  unsigned int tmp___0 ;
  unsigned int tmp___1 ;

  {
#line 252
  shift = ((unsigned int )ctx->length & 3U) * 8U;
#line 253
  index___0 = ((unsigned int )ctx->length & 63U) >> 2;
#line 257
  ctx->message[index___0] &= ~ (4294967295U << shift);
#line 258
  tmp = index___0;
#line 258
  index___0 ++;
#line 258
  ctx->message[tmp] ^= (unsigned int )(128 << shift);
#line 265
  if (index___0 > 14U) {
    {
#line 267
    while (1) {
      while_continue: /* CIL Label */ ;
#line 267
      if (! (index___0 < 16U)) {
#line 267
        goto while_break;
      }
#line 268
      tmp___0 = index___0;
#line 268
      index___0 ++;
#line 268
      ctx->message[tmp___0] = 0U;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 270
    rhash_has160_process_block(ctx->hash, (unsigned int const   *)(ctx->message));
#line 271
    index___0 = 0U;
    }
  }
  {
#line 273
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 273
    if (! (index___0 < 14U)) {
#line 273
      goto while_break___0;
    }
#line 274
    tmp___1 = index___0;
#line 274
    index___0 ++;
#line 274
    ctx->message[tmp___1] = 0U;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 276
  ctx->message[14] = (unsigned int )(ctx->length << 3);
#line 277
  ctx->message[15] = (unsigned int )(ctx->length >> 29);
#line 278
  rhash_has160_process_block(ctx->hash, (unsigned int const   *)(ctx->message));
#line 280
  memcpy((void */* __restrict  */)(result + 0), (void const   */* __restrict  */)(& ctx->hash),
         (size_t )20);
  }
#line 281
  return;
}
}
#line 180 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) rename)(char const   *__old ,
                                                                             char const   *__new ) ;
#line 237
extern int fclose(FILE *__stream ) ;
#line 283
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes )  __asm__("fopen64")  ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 531
extern int fgetc(FILE *__stream ) ;
#line 622
extern char *fgets(char * __restrict  __s , int __n , FILE * __restrict  __stream ) ;
#line 689
extern int fputs(char const   * __restrict  __s , FILE * __restrict  __stream ) ;
#line 749
extern int fseek(FILE *__stream , long __off , int __whence ) ;
#line 828
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) feof)(FILE *__stream ) ;
#line 830
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) ferror)(FILE *__stream ) ;
#line 46 "/home/june/repo/benchmarks/collector/temp/rhash-1.3.1/common_func.h"
int is_binary_string(char const   *str ) ;
#line 101
char const   *get_basename(char const   *path ) ;
#line 102
char *get_dirname(char const   *path ) ;
#line 103
char *make_path(char const   *dir_path , char const   *filename ) ;
#line 108
void rsh_file_cleanup(file_t *file ) ;
#line 110
int rsh_file_stat2(file_t *file , int use_lstat ) ;
#line 148
void *rhash_malloc(size_t size , char const   *srcfile , int srcline ) ;
#line 150
char *rhash_strdup(char const   *str , char const   *srcfile , int srcline ) ;
#line 171
vector_t *rsh_vector_new(void (*destructor)(void * ) ) ;
#line 173
void rsh_vector_free(vector_t *vect ) ;
#line 483 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 129 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcpy)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 399
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 413
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) strerror)(int __errnum ) ;
#line 134 "/usr/include/dirent.h"
extern DIR *( __attribute__((__nonnull__(1))) opendir)(char const   *__name ) ;
#line 165
extern struct dirent *( __attribute__((__nonnull__(1))) readdir)(DIR *__dirp )  __asm__("readdir64")  ;
#line 217 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) stat)(char const   * __restrict  __file ,
                                                                                             struct stat * __restrict  __buf )  __asm__("stat64")  ;
#line 50 "/usr/include/x86_64-linux-gnu/bits/errno.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
#line 24 "/home/june/repo/benchmarks/collector/temp/rhash-1.3.1/librhash/rhash_timing.h"
extern void rhash_timer_start(timedelta_t *timer ) ;
#line 25
extern double rhash_timer_stop(timedelta_t *timer ) ;
#line 93 "/home/june/repo/benchmarks/collector/temp/rhash-1.3.1/parse_cmdline.h"
struct options_t opt ;
#line 33 "/home/june/repo/benchmarks/collector/temp/rhash-1.3.1/output.h"
void log_msg(char const   *format  , ...) ;
#line 34
void log_error(char const   *format  , ...) ;
#line 36
void log_file_error(char const   *filepath ) ;
#line 40
void print_time_stats(double time___0 , uint64_t size , int total ) ;
#line 39 "/home/june/repo/benchmarks/collector/temp/rhash-1.3.1/rhash_main.h"
struct rhash_t rhash_data ;
#line 51 "/home/june/repo/benchmarks/collector/temp/rhash-1.3.1/hash_check.h"
int hash_check_parse_line(char *line , hash_check *hashes , int check_eol ) ;
#line 41 "/home/june/repo/benchmarks/collector/temp/rhash-1.3.1/calc_sums.h"
int calculate_and_print_sums(FILE *out , file_t *file , char const   *print_path ) ;
#line 44
void print_sfv_banner(FILE *out ) ;
#line 30 "/home/june/repo/benchmarks/collector/temp/rhash-1.3.1/file_set.h"
void file_set_item_free(file_set_item *item ) ;
#line 31
void file_set_add_name(file_set *set , char const   *filepath ) ;
#line 32
void file_set_sort(file_set *set ) ;
#line 33
void file_set_sort_by_path(file_set *set ) ;
#line 34
int file_set_exist(file_set *set , char const   *filepath ) ;
#line 19 "/home/june/repo/benchmarks/collector/temp/rhash-1.3.1/file_mask.h"
int file_mask_match(file_mask_array *vect , char const   *name ) ;
#line 9 "/home/june/repo/benchmarks/collector/temp/rhash-1.3.1/hash_update.h"
int update_hash_file(file_t *file ) ;
#line 22 "/home/june/repo/benchmarks/collector/temp/rhash-1.3.1/hash_update.c"
static int add_new_crc_entries(char const   *hash_file_path , file_set *crc_entries ) ;
#line 23
static int file_set_load_from_crc_file(file_set *set , char const   *hash_file_path ) ;
#line 24
static int fix_sfv_header(char const   *hash_file_path ) ;
#line 33 "/home/june/repo/benchmarks/collector/temp/rhash-1.3.1/hash_update.c"
int update_hash_file(file_t *file ) 
{ 
  file_set *crc_entries ;
  timedelta_t timer ;
  int res ;
  char const   *tmp ;
  double time___0 ;
  double tmp___0 ;

  {
#line 39
  if (opt.flags & 512U) {
    {
#line 40
    log_msg("Updating: %s\n", file->path);
    }
  }
  {
#line 43
  crc_entries = rsh_vector_new((void (*)(void * ))(& file_set_item_free));
#line 44
  res = file_set_load_from_crc_file(crc_entries, (char const   *)file->path);
  }
#line 46
  if (opt.flags & 2048U) {
    {
#line 46
    rhash_timer_start(& timer);
    }
  }
#line 47
  rhash_data.total_size = (uint64_t )0;
#line 48
  rhash_data.processed = 0U;
#line 50
  if (res == 0) {
    {
#line 52
    tmp = get_basename((char const   *)file->path);
#line 52
    file_set_add_name(crc_entries, tmp);
#line 53
    file_set_sort(crc_entries);
#line 56
    res = add_new_crc_entries((char const   *)file->path, crc_entries);
    }
  }
  {
#line 58
  rsh_vector_free(crc_entries);
  }
#line 60
  if (opt.flags & 2048U) {
#line 60
    if (rhash_data.processed > 0U) {
      {
#line 61
      tmp___0 = rhash_timer_stop(& timer);
#line 61
      time___0 = tmp___0;
#line 62
      print_time_stats(time___0, rhash_data.total_size, 1);
      }
    }
  }
#line 65
  return (res);
}
}
#line 75 "/home/june/repo/benchmarks/collector/temp/rhash-1.3.1/hash_update.c"
static int file_set_load_from_crc_file(file_set *set , char const   *hash_file_path ) 
{ 
  FILE *fd ;
  int line_num ;
  char buf[2048] ;
  hash_check hc ;
  int tmp___0 ;
  int *tmp___1 ;
  char *line ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  char *tmp___6 ;

  {
  {
#line 82
  fd = fopen((char const   */* __restrict  */)hash_file_path, (char const   */* __restrict  */)"rb");
  }
#line 82
  if (! fd) {
    {
#line 84
    tmp___1 = __errno_location();
    }
#line 84
    if (*tmp___1 == 2) {
#line 84
      tmp___0 = 0;
    } else {
#line 84
      tmp___0 = -1;
    }
#line 84
    return (tmp___0);
  }
#line 86
  line_num = 0;
  {
#line 86
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 86
    tmp___6 = fgets((char */* __restrict  */)(buf), 2048, (FILE */* __restrict  */)fd);
    }
#line 86
    if (! tmp___6) {
#line 86
      goto while_break;
    }
#line 87
    line = buf;
#line 90
    if (line_num == 0) {
#line 90
      if ((int )buf[0] == -17) {
#line 90
        if ((int )buf[1] == -69) {
#line 90
          if ((int )buf[2] == -65) {
#line 90
            line += 3;
          }
        }
      }
    }
#line 92
    if ((int )*line == 0) {
#line 92
      goto __Cont;
    }
    {
#line 94
    tmp___2 = is_binary_string((char const   *)line);
    }
#line 94
    if (tmp___2) {
      {
#line 95
      log_error("skipping binary file %s\n", hash_file_path);
#line 96
      fclose(fd);
      }
#line 97
      return (-1);
    }
#line 100
    if ((int )*line == 59) {
#line 100
      goto __Cont;
    } else
#line 100
    if ((int )*line == 35) {
#line 100
      goto __Cont;
    } else
#line 100
    if ((int )*line == 13) {
#line 100
      goto __Cont;
    } else
#line 100
    if ((int )*line == 10) {
#line 100
      goto __Cont;
    }
    {
#line 103
    tmp___3 = feof(fd);
    }
#line 103
    if (tmp___3) {
#line 103
      tmp___4 = 0;
    } else {
#line 103
      tmp___4 = 1;
    }
    {
#line 103
    tmp___5 = hash_check_parse_line(line, & hc, tmp___4);
    }
#line 103
    if (tmp___5) {
#line 105
      if (hc.file_path) {
        {
#line 105
        file_set_add_name(set, (char const   *)hc.file_path);
        }
      }
    }
    __Cont: /* CIL Label */ 
#line 86
    line_num ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 108
  fclose(fd);
  }
#line 109
  return (0);
}
}
#line 122 "/home/june/repo/benchmarks/collector/temp/rhash-1.3.1/hash_update.c"
static int add_sums_to_file(char const   *hash_file_path , char *dir_path , file_set *files_to_add ) 
{ 
  struct stat st ;
  FILE *fd ;
  unsigned int i ;
  int ch ;
  int print_banner ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  file_t file ;
  char *print_path ;

  {
  {
#line 130
  print_banner = opt.fmt == 2U;
#line 131
  st.st_size = (__off_t )0;
#line 132
  tmp = stat((char const   */* __restrict  */)hash_file_path, (struct stat */* __restrict  */)(& st));
  }
#line 132
  if (tmp == 0) {
#line 133
    if (print_banner) {
#line 133
      if (st.st_size > 0L) {
#line 133
        print_banner = 0;
      }
    }
  }
  {
#line 137
  fd = fopen((char const   */* __restrict  */)hash_file_path, (char const   */* __restrict  */)"r+");
  }
#line 137
  if (! fd) {
    {
#line 138
    log_file_error(hash_file_path);
    }
#line 139
    return (-1);
  }
#line 141
  rhash_data.upd_fd = fd;
#line 143
  if (st.st_size > 0L) {
    {
#line 145
    tmp___0 = fseek(fd, -1L, 2);
    }
#line 145
    if (tmp___0 != 0) {
      {
#line 146
      log_file_error(hash_file_path);
      }
#line 147
      return (-1);
    }
    {
#line 149
    ch = fgetc(fd);
#line 152
    tmp___1 = fseek(fd, 0L, 2);
    }
#line 152
    if (tmp___1 != 0) {
      {
#line 153
      log_file_error(hash_file_path);
      }
#line 154
      return (-1);
    }
#line 158
    if (ch != 10) {
#line 158
      if (ch != 13) {
        {
#line 160
        fprintf((FILE */* __restrict  */)fd, (char const   */* __restrict  */)"\n");
        }
      }
    }
  }
#line 165
  i = 0U;
  {
#line 165
  while (1) {
    while_continue: /* CIL Label */ ;
#line 165
    if (! ((size_t )i < files_to_add->size)) {
#line 165
      goto while_break;
    }
#line 168
    print_path = ((file_set_item *)*(files_to_add->array + i))->filepath;
#line 169
    file.wpath = (wchar_t *)0;
#line 171
    if ((int )*(dir_path + 0) != 46) {
      {
#line 173
      file.path = make_path((char const   *)dir_path, (char const   *)print_path);
      }
    } else
#line 171
    if ((int )*(dir_path + 1) != 0) {
      {
#line 173
      file.path = make_path((char const   *)dir_path, (char const   *)print_path);
      }
    } else {
      {
#line 175
      file.path = rhash_strdup((char const   *)print_path, "/home/june/repo/benchmarks/collector/temp/rhash-1.3.1/hash_update.c",
                               175);
      }
    }
#line 178
    if (opt.fmt == 2U) {
#line 179
      if (print_banner) {
        {
#line 180
        print_sfv_banner(fd);
#line 181
        print_banner = 0;
        }
      }
    }
    {
#line 184
    rsh_file_stat2(& file, 0);
#line 187
    calculate_and_print_sums(fd, & file, (char const   *)print_path);
#line 189
    rsh_file_cleanup(& file);
    }
#line 191
    if (rhash_data.interrupted) {
      {
#line 192
      fclose(fd);
      }
#line 193
      return (0);
    }
#line 165
    i ++;
#line 165
    (rhash_data.processed) ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 196
  fclose(fd);
#line 197
  log_msg("Updated: %s\n", hash_file_path);
  }
#line 198
  return (0);
}
}
#line 210 "/home/june/repo/benchmarks/collector/temp/rhash-1.3.1/hash_update.c"
static int load_filtered_dir(char const   *dir_path , file_set *crc_entries , file_set *files_to_add ) 
{ 
  DIR *dp ;
  struct dirent *de ;
  struct stat st ;
  char *path ;
  int res ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 217
  dp = opendir(dir_path);
  }
#line 218
  if (! dp) {
#line 218
    return (-1);
  }
  {
#line 220
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 220
    de = readdir(dp);
    }
#line 220
    if (! ((unsigned long )de != (unsigned long )((void *)0))) {
#line 220
      goto while_break;
    }
#line 225
    if ((int )de->d_name[0] == 46) {
#line 225
      if ((int )de->d_name[1] == 0) {
#line 227
        goto while_continue;
      } else
#line 225
      if ((int )de->d_name[1] == 46) {
#line 225
        if ((int )de->d_name[2] == 0) {
#line 227
          goto while_continue;
        }
      }
    }
    {
#line 231
    path = make_path(dir_path, (char const   *)(de->d_name));
#line 232
    res = stat((char const   */* __restrict  */)path, (struct stat */* __restrict  */)(& st));
#line 233
    free((void *)path);
    }
#line 238
    if (res < 0) {
#line 241
      goto while_continue;
    } else
#line 238
    if ((st.st_mode & 61440U) == 16384U) {
#line 241
      goto while_continue;
    } else {
      {
#line 238
      tmp = file_mask_match(opt.files_accept, (char const   *)(de->d_name));
      }
#line 238
      if (tmp) {
        {
#line 238
        tmp___0 = file_set_exist(crc_entries, (char const   *)(de->d_name));
        }
#line 238
        if (tmp___0) {
#line 241
          goto while_continue;
        }
      } else {
#line 241
        goto while_continue;
      }
    }
    {
#line 244
    file_set_add_name(files_to_add, (char const   *)(de->d_name));
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 246
  return (0);
}
}
#line 263 "/home/june/repo/benchmarks/collector/temp/rhash-1.3.1/hash_update.c"
static int add_new_crc_entries(char const   *hash_file_path , file_set *crc_entries ) 
{ 
  file_set *files_to_add ;
  char *dir_path ;
  int res ;

  {
  {
#line 267
  res = 0;
#line 269
  dir_path = get_dirname(hash_file_path);
#line 270
  files_to_add = rsh_vector_new((void (*)(void * ))(& file_set_item_free));
#line 273
  load_filtered_dir((char const   *)dir_path, crc_entries, files_to_add);
  }
#line 275
  if (files_to_add->size > 0UL) {
    {
#line 277
    file_set_sort_by_path(files_to_add);
#line 280
    res = add_sums_to_file(hash_file_path, dir_path, files_to_add);
    }
#line 282
    if (res == 0) {
#line 282
      if (opt.fmt == 2U) {
#line 282
        if (! rhash_data.interrupted) {
          {
#line 284
          res = fix_sfv_header(hash_file_path);
          }
        }
      }
    }
  }
  {
#line 288
  rsh_vector_free(files_to_add);
#line 289
  free((void *)dir_path);
  }
#line 290
  return (res);
}
}
#line 297 "/home/june/repo/benchmarks/collector/temp/rhash-1.3.1/hash_update.c"
static int fix_sfv_header(char const   *hash_file_path ) 
{ 
  FILE *in ;
  FILE *out ;
  char line[2048] ;
  size_t len ;
  char *tmp_file ;
  int err ;
  void *tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int *tmp___8 ;
  char *tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;

  {
  {
#line 304
  err = 0;
#line 306
  in = fopen((char const   */* __restrict  */)hash_file_path, (char const   */* __restrict  */)"r");
  }
#line 306
  if (! in) {
    {
#line 307
    log_file_error(hash_file_path);
    }
#line 308
    return (-1);
  }
  {
#line 312
  len = strlen(hash_file_path);
#line 313
  tmp = rhash_malloc(len + 8UL, "/home/june/repo/benchmarks/collector/temp/rhash-1.3.1/hash_update.c",
                     313);
#line 313
  tmp_file = (char *)tmp;
#line 314
  memcpy((void */* __restrict  */)tmp_file, (void const   */* __restrict  */)hash_file_path,
         len);
#line 315
  strcpy((char */* __restrict  */)(tmp_file + len), (char const   */* __restrict  */)".new");
#line 318
  out = fopen((char const   */* __restrict  */)tmp_file, (char const   */* __restrict  */)"w");
  }
#line 318
  if (! out) {
    {
#line 319
    log_file_error((char const   *)tmp_file);
#line 320
    free((void *)tmp_file);
#line 321
    fclose(in);
    }
#line 322
    return (-1);
  }
  {
#line 326
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 326
    tmp___1 = fgets((char */* __restrict  */)(line), 2048, (FILE */* __restrict  */)in);
    }
#line 326
    if (! tmp___1) {
#line 326
      goto while_break;
    }
#line 327
    if ((int )line[0] == 59) {
      {
#line 328
      tmp___0 = fputs((char const   */* __restrict  */)(line), (FILE */* __restrict  */)out);
      }
#line 328
      if (tmp___0 < 0) {
#line 328
        goto while_break;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 331
  tmp___4 = ferror(out);
  }
#line 331
  if (! tmp___4) {
    {
#line 331
    tmp___5 = ferror(in);
    }
#line 331
    if (! tmp___5) {
      {
#line 332
      fseek(in, 0L, 0);
      }
      {
#line 334
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 334
        tmp___3 = fgets((char */* __restrict  */)(line), 2048, (FILE */* __restrict  */)in);
        }
#line 334
        if (! tmp___3) {
#line 334
          goto while_break___0;
        }
#line 335
        if ((int )line[0] != 59) {
          {
#line 336
          tmp___2 = fputs((char const   */* __restrict  */)(line), (FILE */* __restrict  */)out);
          }
#line 336
          if (tmp___2 < 0) {
#line 336
            goto while_break___0;
          }
        }
      }
      while_break___0: /* CIL Label */ ;
      }
    }
  }
  {
#line 340
  tmp___6 = ferror(in);
  }
#line 340
  if (tmp___6) {
    {
#line 341
    log_file_error(hash_file_path);
#line 342
    err = 1;
    }
  }
  {
#line 344
  tmp___7 = ferror(out);
  }
#line 344
  if (tmp___7) {
    {
#line 345
    log_file_error((char const   *)tmp_file);
#line 346
    err = 1;
    }
  }
  {
#line 349
  fclose(in);
#line 350
  fclose(out);
  }
#line 353
  if (! err) {
    {
#line 358
    tmp___10 = rename((char const   *)tmp_file, hash_file_path);
    }
#line 358
    if (tmp___10 < 0) {
      {
#line 359
      tmp___8 = __errno_location();
#line 359
      tmp___9 = strerror(*tmp___8);
#line 359
      log_error("can\'t move %s to %s: %s\n", tmp_file, hash_file_path, tmp___9);
#line 361
      err = 1;
      }
    }
  }
  {
#line 364
  free((void *)tmp_file);
  }
#line 365
  if (err) {
#line 365
    tmp___11 = -1;
  } else {
#line 365
    tmp___11 = 0;
  }
#line 365
  return (tmp___11);
}
}
/* compiler builtin: 
   void __builtin_va_start(__builtin_va_list  ) ;  */
/* compiler builtin: 
   void __builtin_va_end(__builtin_va_list  ) ;  */
#line 170 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 371
extern int vfprintf(FILE * __restrict  __s , char const   * __restrict  __format ,
                    __gnuc_va_list __arg ) ;
#line 243 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) struct tm *( __attribute__((__leaf__)) localtime)(time_t const   *__timer ) ;
#line 71 "/usr/include/x86_64-linux-gnu/sys/time.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) gettimeofday)(struct timeval * __restrict  __tv ,
                                                                                                   __timezone_ptr_t __tz ) ;
#line 42 "/home/june/repo/benchmarks/collector/temp/rhash-1.3.1/common_func.h"
void sprintI64(char *dst , uint64_t number , int min_width ) ;
#line 43
int int_len(uint64_t num ) ;
#line 45
int urlencode(char *dst , char const   *name ) ;
#line 47
char *str_tolower(char const   *str ) ;
#line 48
char *str_trim(char *str ) ;
#line 49
char *str_set(char *buf , int ch , int length ) ;
#line 50
char *str_append(char const   *orig , char const   *append ) ;
#line 51
size_t strlen_utf8_c(char const   *str ) ;
#line 104
int are_paths_equal(rsh_tchar const   *a , rsh_tchar const   *b ) ;
#line 106
void print_time(FILE *out , time_t time___0 ) ;
#line 107
void print_time64(FILE *out , uint64_t time___0 ) ;
#line 109
int rsh_file_stat(file_t *file ) ;
#line 139
unsigned int rhash_get_ticks(void) ;
#line 140
void rhash_exit(int code ) ;
#line 149
void *rhash_calloc(size_t num , size_t size , char const   *srcfile , int srcline ) ;
#line 151
void *rhash_realloc(void *mem , size_t size , char const   *srcfile , int srcline ) ;
#line 159
void (*rsh_exit)(int code ) ;
#line 160
void (*rsh_report_error)(char const   *srcfile , int srcline , char const   *format 
                         , ...) ;
#line 172
struct vector_t *rsh_vector_new_simple(void) ;
#line 174
void rsh_vector_destroy(vector_t *vect ) ;
#line 175
void rsh_vector_add_ptr(vector_t *vect , void *item ) ;
#line 176
void rsh_vector_add_empty(struct vector_t *vect , size_t item_size ) ;
#line 193
void rsh_blocks_vector_init(blocks_vector_t *bvector ) ;
#line 194
void rsh_blocks_vector_destroy(blocks_vector_t *bvector ) ;
#line 224
strbuf_t *rsh_str_new(void) ;
#line 225
void rsh_str_free(strbuf_t *ptr ) ;
#line 226
void rsh_str_ensure_size(strbuf_t *str , size_t new_size ) ;
#line 227
void rsh_str_append_n(strbuf_t *str , char const   *text , size_t length ) ;
#line 228
void rsh_str_append(strbuf_t *str , char const   *text ) ;
#line 466 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 468
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) calloc)(size_t __nmemb ,
                                                                               size_t __size )  __attribute__((__malloc__)) ;
#line 480
extern  __attribute__((__nothrow__)) void *( __attribute__((__warn_unused_result__,
__leaf__)) realloc)(void *__ptr , size_t __size ) ;
#line 543
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 66 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memset)(void *__s ,
                                                                                               int __c ,
                                                                                               size_t __n ) ;
#line 176
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strdup)(char const   *__s )  __attribute__((__malloc__)) ;
#line 236
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strchr)(char const   *__s ,
                                                                                               int __c )  __attribute__((__pure__)) ;
#line 79 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) unsigned short const   **( __attribute__((__leaf__)) __ctype_b_loc)(void)  __attribute__((__const__)) ;
#line 124
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) tolower)(int __c ) ;
#line 267 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) lstat)(char const   * __restrict  __file ,
                                                                                              struct stat * __restrict  __buf )  __asm__("lstat64")  ;
#line 31 "/home/june/repo/benchmarks/collector/temp/rhash-1.3.1/common_func.c"
void sprintI64(char *dst , uint64_t number , int min_width ) 
{ 
  char buf[24] ;
  size_t len ;
  char *p ;
  char *tmp ;
  char *tmp___0 ;

  {
#line 35
  p = buf + 23;
#line 36
  tmp = p;
#line 36
  p --;
#line 36
  *tmp = (char)0;
#line 37
  if (number == 0UL) {
#line 38
    tmp___0 = p;
#line 38
    p --;
#line 38
    *tmp___0 = (char )'0';
  } else {
    {
#line 40
    while (1) {
      while_continue: /* CIL Label */ ;
#line 40
      if ((unsigned long )p >= (unsigned long )(buf)) {
#line 40
        if (! (number != 0UL)) {
#line 40
          goto while_break;
        }
      } else {
#line 40
        goto while_break;
      }
#line 41
      *p = (char )(48 + (int )((char )(number % 10UL)));
#line 40
      p --;
#line 40
      number /= 10UL;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 44
  len = (size_t )((buf + 22) - p);
#line 45
  if ((size_t )min_width > len) {
    {
#line 46
    memset((void *)dst, 32, (size_t )min_width - len);
#line 47
    dst += (size_t )min_width - len;
    }
  }
  {
#line 49
  memcpy((void */* __restrict  */)dst, (void const   */* __restrict  */)(p + 1), len + 1UL);
  }
#line 50
  return;
}
}
#line 58 "/home/june/repo/benchmarks/collector/temp/rhash-1.3.1/common_func.c"
int int_len(uint64_t num ) 
{ 
  int len ;
  int tmp ;

  {
#line 61
  len = 0;
  {
#line 61
  while (1) {
    while_continue: /* CIL Label */ ;
#line 61
    if (! num) {
#line 61
      goto while_break;
    }
#line 61
    len ++;
#line 61
    num /= 10UL;
  }
  while_break: /* CIL Label */ ;
  }
#line 62
  if (len == 0) {
#line 62
    tmp = 1;
  } else {
#line 62
    tmp = len;
  }
#line 62
  return (tmp);
}
}
#line 74 "/home/june/repo/benchmarks/collector/temp/rhash-1.3.1/common_func.c"
static char *print_hex_byte(char *dst , unsigned char const   byte , int upper_case ) 
{ 
  char add ;
  int tmp ;
  unsigned char c ;
  char *tmp___0 ;
  char *tmp___1 ;

  {
#line 76
  if (upper_case) {
#line 76
    tmp = 55;
  } else {
#line 76
    tmp = 87;
  }
#line 76
  add = (char )tmp;
#line 77
  c = (unsigned char )(((int const   )byte >> 4) & 15);
#line 78
  tmp___0 = dst;
#line 78
  dst ++;
#line 78
  if ((int )c > 9) {
#line 78
    *tmp___0 = (char )((int )c + (int )add);
  } else {
#line 78
    *tmp___0 = (char )((int )c + 48);
  }
#line 79
  c = (unsigned char )((int const   )byte & 15);
#line 80
  tmp___1 = dst;
#line 80
  dst ++;
#line 80
  if ((int )c > 9) {
#line 80
    *tmp___1 = (char )((int )c + (int )add);
  } else {
#line 80
    *tmp___1 = (char )((int )c + 48);
  }
#line 81
  return (dst);
}
}
#line 95 "/home/june/repo/benchmarks/collector/temp/rhash-1.3.1/common_func.c"
int urlencode(char *dst , char const   *name ) 
{ 
  char const   *start ;
  int len ;
  int tmp___1 ;
  unsigned short const   **tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  unsigned short const   **tmp___6 ;
  char *tmp___7 ;

  {
#line 98
  if (! dst) {
#line 100
    len = 0;
    {
#line 100
    while (1) {
      while_continue: /* CIL Label */ ;
#line 100
      if (! *name) {
#line 100
        goto while_break;
      }
      {
#line 100
      tmp___2 = __ctype_b_loc();
      }
#line 100
      if ((int const   )*(*tmp___2 + (int )((unsigned char )*name)) & 8) {
#line 100
        tmp___1 = 1;
      } else {
        {
#line 100
        tmp___3 = strchr("$-_.!\'(),", (int )*name);
        }
#line 100
        if (tmp___3) {
#line 100
          tmp___1 = 1;
        } else {
#line 100
          tmp___1 = 3;
        }
      }
#line 100
      len += tmp___1;
#line 100
      name ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 101
    return (len);
  }
#line 104
  start = (char const   *)dst;
  {
#line 104
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 104
    if (! *name) {
#line 104
      goto while_break___0;
    }
    {
#line 105
    tmp___6 = __ctype_b_loc();
    }
#line 105
    if ((int const   )*(*tmp___6 + (int )((unsigned char )*name)) & 8) {
#line 106
      tmp___4 = dst;
#line 106
      dst ++;
#line 106
      *tmp___4 = (char )*name;
    } else {
      {
#line 105
      tmp___7 = strchr("$-_.!\'(),", (int )*name);
      }
#line 105
      if (tmp___7) {
#line 106
        tmp___4 = dst;
#line 106
        dst ++;
#line 106
        *tmp___4 = (char )*name;
      } else {
        {
#line 108
        tmp___5 = dst;
#line 108
        dst ++;
#line 108
        *tmp___5 = (char )'%';
#line 109
        dst = print_hex_byte(dst, (unsigned char const   )*name, 'A');
        }
      }
    }
#line 104
    name ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 112
  *dst = (char)0;
#line 113
  return ((int )(dst - (char *)start));
}
}
#line 124 "/home/june/repo/benchmarks/collector/temp/rhash-1.3.1/common_func.c"
char *str_tolower(char const   *str ) 
{ 
  char *buf ;
  char *tmp ;
  char *p ;
  int tmp___0 ;

  {
  {
#line 126
  tmp = rhash_strdup(str, "/home/june/repo/benchmarks/collector/temp/rhash-1.3.1/common_func.c",
                     126);
#line 126
  buf = tmp;
  }
#line 128
  if (buf) {
#line 129
    p = buf;
    {
#line 129
    while (1) {
      while_continue: /* CIL Label */ ;
#line 129
      if (! *p) {
#line 129
        goto while_break;
      }
      {
#line 129
      tmp___0 = tolower((int )*p);
#line 129
      *p = (char )tmp___0;
#line 129
      p ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 131
  return (buf);
}
}
#line 140 "/home/june/repo/benchmarks/collector/temp/rhash-1.3.1/common_func.c"
char *str_trim(char *str ) 
{ 
  char *last ;
  size_t tmp ;
  unsigned short const   **tmp___0 ;
  char *tmp___1 ;
  unsigned short const   **tmp___2 ;

  {
  {
#line 142
  tmp = strlen((char const   *)str);
#line 142
  last = (str + tmp) - 1;
  }
  {
#line 143
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 143
    tmp___0 = __ctype_b_loc();
    }
#line 143
    if (! ((int const   )*(*tmp___0 + (int )((unsigned char )*str)) & 8192)) {
#line 143
      goto while_break;
    }
#line 143
    str ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 144
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 144
    tmp___2 = __ctype_b_loc();
    }
#line 144
    if ((int const   )*(*tmp___2 + (int )((unsigned char )*last)) & 8192) {
#line 144
      if (! ((unsigned long )last > (unsigned long )str)) {
#line 144
        goto while_break___0;
      }
    } else {
#line 144
      goto while_break___0;
    }
#line 144
    tmp___1 = last;
#line 144
    last --;
#line 144
    *tmp___1 = (char)0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 145
  return (str);
}
}
#line 157 "/home/june/repo/benchmarks/collector/temp/rhash-1.3.1/common_func.c"
char *str_set(char *buf , int ch , int length ) 
{ 


  {
  {
#line 159
  memset((void *)buf, ch, (size_t )length);
#line 160
  *(buf + length) = (char )'\000';
  }
#line 161
  return (buf);
}
}
#line 171 "/home/june/repo/benchmarks/collector/temp/rhash-1.3.1/common_func.c"
char *str_append(char const   *orig , char const   *append ) 
{ 
  size_t len1 ;
  size_t tmp ;
  size_t len2 ;
  size_t tmp___0 ;
  char *res ;
  void *tmp___1 ;

  {
  {
#line 173
  tmp = strlen(orig);
#line 173
  len1 = tmp;
#line 174
  tmp___0 = strlen(append);
#line 174
  len2 = tmp___0;
#line 175
  tmp___1 = rhash_malloc((len1 + len2) + 1UL, "/home/june/repo/benchmarks/collector/temp/rhash-1.3.1/common_func.c",
                         175);
#line 175
  res = (char *)tmp___1;
#line 178
  memcpy((void */* __restrict  */)res, (void const   */* __restrict  */)orig, len1);
#line 179
  memcpy((void */* __restrict  */)(res + len1), (void const   */* __restrict  */)append,
         len2 + 1UL);
  }
#line 180
  return (res);
}
}
#line 190 "/home/june/repo/benchmarks/collector/temp/rhash-1.3.1/common_func.c"
int is_binary_string(char const   *str ) 
{ 


  {
  {
#line 192
  while (1) {
    while_continue: /* CIL Label */ ;
#line 192
    if (! *str) {
#line 192
      goto while_break;
    }
#line 193
    if ((int )((unsigned char )*str) < 32) {
#line 193
      if ((1 << (int )((unsigned char )*str)) & -9729) {
#line 194
        return (1);
      }
    }
#line 192
    str ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 197
  return (0);
}
}
#line 206 "/home/june/repo/benchmarks/collector/temp/rhash-1.3.1/common_func.c"
size_t strlen_utf8_c(char const   *str ) 
{ 
  size_t length ;

  {
#line 208
  length = (size_t )0;
  {
#line 209
  while (1) {
    while_continue: /* CIL Label */ ;
#line 209
    if (! *str) {
#line 209
      goto while_break;
    }
#line 210
    if (((int const   )*str & 192) != 128) {
#line 210
      length ++;
    }
#line 209
    str ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 212
  return (length);
}
}
#line 220 "/home/june/repo/benchmarks/collector/temp/rhash-1.3.1/common_func.c"
void rhash_exit(int code ) 
{ 


  {
  {
#line 223
  exit(code);
  }
}
}
#line 234 "/home/june/repo/benchmarks/collector/temp/rhash-1.3.1/common_func.c"
char const   *get_basename(char const   *path ) 
{ 
  char const   *p ;
  size_t tmp ;

  {
  {
#line 236
  tmp = strlen(path);
#line 236
  p = (path + tmp) - 1;
  }
  {
#line 237
  while (1) {
    while_continue: /* CIL Label */ ;
#line 237
    if ((unsigned long )p >= (unsigned long )path) {
#line 237
      if (! (! ((int const   )*p == 47))) {
#line 237
        goto while_break;
      }
    } else {
#line 237
      goto while_break;
    }
#line 237
    p --;
  }
  while_break: /* CIL Label */ ;
  }
#line 238
  return (p + 1);
}
}
#line 248 "/home/june/repo/benchmarks/collector/temp/rhash-1.3.1/common_func.c"
char *get_dirname(char const   *path ) 
{ 
  char const   *p ;
  size_t tmp ;
  char *res ;
  void *tmp___0 ;
  char *tmp___1 ;

  {
  {
#line 250
  tmp = strlen(path);
#line 250
  p = (path + tmp) - 1;
  }
  {
#line 252
  while (1) {
    while_continue: /* CIL Label */ ;
#line 252
    if ((unsigned long )p > (unsigned long )path) {
#line 252
      if (! (! ((int const   )*p == 47))) {
#line 252
        goto while_break;
      }
    } else {
#line 252
      goto while_break;
    }
#line 252
    p --;
  }
  while_break: /* CIL Label */ ;
  }
#line 253
  if (p - path > 1L) {
    {
#line 254
    tmp___0 = rhash_malloc((size_t )((p - path) + 1L), "/home/june/repo/benchmarks/collector/temp/rhash-1.3.1/common_func.c",
                           254);
#line 254
    res = (char *)tmp___0;
#line 255
    memcpy((void */* __restrict  */)res, (void const   */* __restrict  */)path, (size_t )(p - path));
#line 256
    *(res + (p - path)) = (char)0;
    }
#line 257
    return (res);
  } else {
    {
#line 259
    tmp___1 = rhash_strdup(".", "/home/june/repo/benchmarks/collector/temp/rhash-1.3.1/common_func.c",
                           259);
    }
#line 259
    return (tmp___1);
  }
}
}
#line 270 "/home/june/repo/benchmarks/collector/temp/rhash-1.3.1/common_func.c"
char *make_path(char const   *dir_path , char const   *filename ) 
{ 
  char *buf ;
  size_t len ;
  size_t tmp ;
  void *tmp___0 ;
  size_t tmp___1 ;

  {
  {
#line 278
  while (1) {
    while_continue: /* CIL Label */ ;
#line 278
    if (! ((int const   )*filename == 47)) {
#line 278
      goto while_break;
    }
#line 278
    filename ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 281
  len = strlen(dir_path);
#line 282
  tmp = strlen(filename);
#line 282
  tmp___0 = rhash_malloc((len + tmp) + 2UL, "/home/june/repo/benchmarks/collector/temp/rhash-1.3.1/common_func.c",
                         282);
#line 282
  buf = (char *)tmp___0;
#line 283
  strcpy((char */* __restrict  */)buf, (char const   */* __restrict  */)dir_path);
  }
#line 286
  if (len > 0UL) {
#line 286
    if (! ((int )*(buf + (len - 1UL)) == 47)) {
#line 287
      tmp___1 = len;
#line 287
      len ++;
#line 287
      *(buf + tmp___1) = (char )'/';
    }
  }
  {
#line 291
  strcpy((char */* __restrict  */)(buf + len), (char const   */* __restrict  */)filename);
  }
#line 292
  return (buf);
}
}
#line 303 "/home/june/repo/benchmarks/collector/temp/rhash-1.3.1/common_func.c"
int are_paths_equal(rsh_tchar const   *a , rsh_tchar const   *b ) 
{ 


  {
#line 305
  if (! a) {
#line 305
    return (0);
  } else
#line 305
  if (! b) {
#line 305
    return (0);
  }
#line 306
  if ((int const   )*(a + 0) == 46) {
#line 306
    if ((int const   )*(a + 1) == 47) {
#line 306
      a += 2;
    } else
#line 306
    if ((int const   )*(a + 1) == 92) {
#line 306
      a += 2;
    }
  }
#line 307
  if ((int const   )*(b + 0) == 46) {
#line 307
    if ((int const   )*(b + 1) == 47) {
#line 307
      b += 2;
    } else
#line 307
    if ((int const   )*(b + 1) == 92) {
#line 307
      b += 2;
    }
  }
  {
#line 309
  while (1) {
    while_continue: /* CIL Label */ ;
#line 309
    if (! *a) {
#line 309
      goto while_break;
    }
#line 311
    if ((int const   )*a != (int const   )*b) {
#line 311
      if ((int const   )*b == 47) {
#line 311
        goto _L;
      } else
#line 311
      if ((int const   )*b == 92) {
        _L: /* CIL Label */ 
#line 311
        if (! ((int const   )*a == 47)) {
#line 311
          if (! ((int const   )*a == 92)) {
#line 314
            return (0);
          }
        }
      } else {
#line 314
        return (0);
      }
    }
#line 309
    a ++;
#line 309
    b ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 319
  return ((int const   )*a == (int const   )*b);
}
}
#line 331 "/home/june/repo/benchmarks/collector/temp/rhash-1.3.1/common_func.c"
static struct tm zero_tm  ;
#line 328 "/home/june/repo/benchmarks/collector/temp/rhash-1.3.1/common_func.c"
void print_time(FILE *out , time_t time___0 ) 
{ 
  struct tm *t ;
  struct tm *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
  {
#line 330
  tmp = localtime((time_t const   *)(& time___0));
#line 330
  t = tmp;
  }
#line 332
  if ((unsigned long )t == (unsigned long )((void *)0)) {
#line 334
    t = & zero_tm;
#line 335
    tmp___4 = 0;
#line 335
    t->tm_mday = tmp___4;
#line 335
    tmp___3 = tmp___4;
#line 335
    t->tm_mon = tmp___3;
#line 335
    tmp___2 = tmp___3;
#line 335
    t->tm_year = tmp___2;
#line 335
    tmp___1 = tmp___2;
#line 335
    t->tm_sec = tmp___1;
#line 335
    tmp___0 = tmp___1;
#line 335
    t->tm_min = tmp___0;
#line 335
    t->tm_hour = tmp___0;
  }
  {
#line 338
  fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)"%02u:%02u.%02u %4u-%02u-%02u",
          t->tm_hour, t->tm_min, t->tm_sec, 1900 + t->tm_year, t->tm_mon + 1, t->tm_mday);
  }
#line 340
  return;
}
}
#line 342 "/home/june/repo/benchmarks/collector/temp/rhash-1.3.1/common_func.c"
void print_time64(FILE *out , uint64_t time___0 ) 
{ 


  {
  {
#line 344
  print_time(out, (time_t )time___0);
  }
#line 345
  return;
}
}
#line 354 "/home/june/repo/benchmarks/collector/temp/rhash-1.3.1/common_func.c"
unsigned int rhash_get_ticks(void) 
{ 
  struct timeval tv ;

  {
  {
#line 360
  gettimeofday((struct timeval */* __restrict  */)(& tv), (__timezone_ptr_t )((void *)0));
  }
#line 361
  return ((unsigned int )(tv.tv_sec * 1000L + tv.tv_usec / 1000L));
}
}
#line 400 "/home/june/repo/benchmarks/collector/temp/rhash-1.3.1/common_func.c"
int rsh_file_stat2(file_t *file , int use_lstat ) 
{ 
  struct stat st ;
  int res ;
  int tmp ;
  int tmp___0 ;

  {
#line 427
  res = -1;
#line 428
  if (use_lstat) {
    {
#line 428
    tmp = lstat((char const   */* __restrict  */)file->path, (struct stat */* __restrict  */)(& st));
#line 428
    res = tmp;
    }
  } else {
    {
#line 428
    tmp___0 = stat((char const   */* __restrict  */)file->path, (struct stat */* __restrict  */)(& st));
#line 428
    res = tmp___0;
    }
  }
#line 429
  file->size = (uint64_t )st.st_size;
#line 430
  file->mtime = (uint64_t )st.st_mtim.tv_sec;
#line 432
  file->mode = 0U;
#line 433
  if ((st.st_mode & 61440U) == 16384U) {
#line 433
    file->mode |= 1U;
  }
#line 435
  return (res);
}
}
#line 445 "/home/june/repo/benchmarks/collector/temp/rhash-1.3.1/common_func.c"
int rsh_file_stat(file_t *file ) 
{ 
  int tmp ;

  {
  {
#line 447
  tmp = rsh_file_stat2(file, 0);
  }
#line 447
  return (tmp);
}
}
#line 450 "/home/june/repo/benchmarks/collector/temp/rhash-1.3.1/common_func.c"
void rsh_file_cleanup(file_t *file ) 
{ 
  uint64_t tmp ;

  {
  {
#line 452
  free((void *)file->path);
#line 453
  file->path = (char *)((void *)0);
#line 460
  tmp = (uint64_t )0;
#line 460
  file->size = tmp;
#line 460
  file->mtime = tmp;
#line 461
  file->mode = 0U;
  }
#line 462
  return;
}
}
#line 466
static void report_error_default(char const   *srcfile , int srcline , char const   *format 
                                 , ...) ;
#line 469 "/home/june/repo/benchmarks/collector/temp/rhash-1.3.1/common_func.c"
void (*rsh_exit)(int code )  =    (void (*)(int code ))(& exit);
#line 470 "/home/june/repo/benchmarks/collector/temp/rhash-1.3.1/common_func.c"
void (*rsh_report_error)(char const   *srcfile , int srcline , char const   *format 
                         , ...)  =    & report_error_default;
#line 480 "/home/june/repo/benchmarks/collector/temp/rhash-1.3.1/common_func.c"
static void report_error_default(char const   *srcfile , int srcline , char const   *format 
                                 , ...) 
{ 
  va_list ap ;

  {
  {
#line 483
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"RHash: error at %s:%u: ",
          srcfile, srcline);
#line 484
  __builtin_va_start(ap, format);
#line 485
  vfprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)format,
           ap);
#line 486
  __builtin_va_end(ap);
  }
#line 487
  return;
}
}
#line 499 "/home/june/repo/benchmarks/collector/temp/rhash-1.3.1/common_func.c"
void *rhash_malloc(size_t size , char const   *srcfile , int srcline ) 
{ 
  void *res ;
  void *tmp ;

  {
  {
#line 501
  tmp = malloc(size);
#line 501
  res = tmp;
  }
#line 502
  if (! res) {
    {
#line 503
    (*rsh_report_error)(srcfile, srcline, "%s(%u) failed\n", "malloc", (unsigned int )size);
#line 504
    (*rsh_exit)(2);
    }
  }
#line 506
  return (res);
}
}
#line 518 "/home/june/repo/benchmarks/collector/temp/rhash-1.3.1/common_func.c"
void *rhash_calloc(size_t num , size_t size , char const   *srcfile , int srcline ) 
{ 
  void *res ;
  void *tmp ;

  {
  {
#line 520
  tmp = calloc(num, size);
#line 520
  res = tmp;
  }
#line 521
  if (! res) {
    {
#line 522
    (*rsh_report_error)(srcfile, srcline, "calloc(%u, %u) failed\n", (unsigned int )num,
                        (unsigned int )size);
#line 523
    (*rsh_exit)(2);
    }
  }
#line 525
  return (res);
}
}
#line 537 "/home/june/repo/benchmarks/collector/temp/rhash-1.3.1/common_func.c"
char *rhash_strdup(char const   *str , char const   *srcfile , int srcline ) 
{ 
  char *res ;
  char *tmp ;

  {
  {
#line 540
  tmp = strdup(str);
#line 540
  res = tmp;
  }
#line 546
  if (! res) {
    {
#line 547
    (*rsh_report_error)(srcfile, srcline, "strdup(\"%s\") failed\n", str);
#line 548
    (*rsh_exit)(2);
    }
  }
#line 550
  return (res);
}
}
#line 583 "/home/june/repo/benchmarks/collector/temp/rhash-1.3.1/common_func.c"
void *rhash_realloc(void *mem , size_t size , char const   *srcfile , int srcline ) 
{ 
  void *res ;
  void *tmp ;

  {
  {
#line 585
  tmp = realloc(mem, size);
#line 585
  res = tmp;
  }
#line 586
  if (! res) {
    {
#line 587
    (*rsh_report_error)(srcfile, srcline, "realloc(%p, %u) failed\n", mem, (unsigned int )size);
#line 588
    (*rsh_exit)(2);
    }
  }
#line 590
  return (res);
}
}
#line 603 "/home/june/repo/benchmarks/collector/temp/rhash-1.3.1/common_func.c"
vector_t *rsh_vector_new(void (*destructor)(void * ) ) 
{ 
  vector_t *ptr ;
  void *tmp ;

  {
  {
#line 605
  tmp = rhash_malloc(sizeof(vector_t ), "/home/june/repo/benchmarks/collector/temp/rhash-1.3.1/common_func.c",
                     605);
#line 605
  ptr = (vector_t *)tmp;
#line 606
  memset((void *)ptr, 0, sizeof(vector_t ));
#line 607
  ptr->destructor = destructor;
  }
#line 608
  return (ptr);
}
}
#line 617 "/home/june/repo/benchmarks/collector/temp/rhash-1.3.1/common_func.c"
struct vector_t *rsh_vector_new_simple(void) 
{ 
  vector_t *tmp ;

  {
  {
#line 619
  tmp = rsh_vector_new((void (*)(void * ))(& free));
  }
#line 619
  return (tmp);
}
}
#line 627 "/home/june/repo/benchmarks/collector/temp/rhash-1.3.1/common_func.c"
void rsh_vector_destroy(vector_t *vect ) 
{ 
  unsigned int i ;
  size_t tmp ;

  {
#line 629
  if (! vect) {
#line 629
    return;
  }
#line 630
  if (vect->destructor) {
#line 632
    i = 0U;
    {
#line 632
    while (1) {
      while_continue: /* CIL Label */ ;
#line 632
      if (! ((size_t )i < vect->size)) {
#line 632
        goto while_break;
      }
      {
#line 632
      (*(vect->destructor))(*(vect->array + i));
#line 632
      i ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 634
  free((void *)vect->array);
#line 635
  tmp = (size_t )0;
#line 635
  vect->allocated = tmp;
#line 635
  vect->size = tmp;
#line 636
  vect->array = (void **)0;
  }
#line 637
  return;
}
}
#line 644 "/home/june/repo/benchmarks/collector/temp/rhash-1.3.1/common_func.c"
void rsh_vector_free(vector_t *vect ) 
{ 


  {
  {
#line 646
  rsh_vector_destroy(vect);
#line 647
  free((void *)vect);
  }
#line 648
  return;
}
}
#line 656 "/home/june/repo/benchmarks/collector/temp/rhash-1.3.1/common_func.c"
void rsh_vector_add_ptr(vector_t *vect , void *item ) 
{ 
  size_t size ;
  size_t tmp ;
  void *tmp___0 ;

  {
#line 659
  if (vect->size >= vect->allocated) {
#line 660
    if (vect->allocated == 0UL) {
#line 660
      tmp = (size_t )128;
    } else {
#line 660
      tmp = vect->allocated * 2UL;
    }
    {
#line 660
    size = tmp;
#line 661
    tmp___0 = rhash_realloc((void *)vect->array, size * sizeof(void *), "/home/june/repo/benchmarks/collector/temp/rhash-1.3.1/common_func.c",
                            661);
#line 661
    vect->array = (void **)tmp___0;
#line 662
    vect->allocated = size;
    }
  }
#line 665
  *(vect->array + vect->size) = item;
#line 666
  (vect->size) ++;
#line 667
  return;
}
}
#line 675 "/home/june/repo/benchmarks/collector/temp/rhash-1.3.1/common_func.c"
void rsh_vector_add_empty(struct vector_t *vect , size_t item_size ) 
{ 
  size_t size ;
  size_t tmp ;
  void *tmp___0 ;

  {
#line 678
  if (vect->size >= vect->allocated) {
#line 679
    if (vect->allocated == 0UL) {
#line 679
      tmp = (size_t )128;
    } else {
#line 679
      tmp = vect->allocated * 2UL;
    }
    {
#line 679
    size = tmp;
#line 680
    tmp___0 = rhash_realloc((void *)vect->array, size * item_size, "/home/june/repo/benchmarks/collector/temp/rhash-1.3.1/common_func.c",
                            680);
#line 680
    vect->array = (void **)tmp___0;
#line 681
    vect->allocated = size;
    }
  }
#line 683
  (vect->size) ++;
#line 684
  return;
}
}
#line 691 "/home/june/repo/benchmarks/collector/temp/rhash-1.3.1/common_func.c"
void rsh_blocks_vector_init(blocks_vector_t *bvector ) 
{ 


  {
  {
#line 693
  memset((void *)bvector, 0, sizeof(*bvector));
#line 694
  bvector->blocks.destructor = (void (*)(void * ))(& free);
  }
#line 695
  return;
}
}
#line 703 "/home/june/repo/benchmarks/collector/temp/rhash-1.3.1/common_func.c"
void rsh_blocks_vector_destroy(blocks_vector_t *bvector ) 
{ 


  {
  {
#line 705
  rsh_vector_destroy(& bvector->blocks);
  }
#line 706
  return;
}
}
#line 715 "/home/june/repo/benchmarks/collector/temp/rhash-1.3.1/common_func.c"
strbuf_t *rsh_str_new(void) 
{ 
  strbuf_t *res ;
  void *tmp ;

  {
  {
#line 717
  tmp = malloc(sizeof(strbuf_t ));
#line 717
  res = (strbuf_t *)tmp;
#line 718
  memset((void *)res, 0, sizeof(strbuf_t ));
  }
#line 719
  return (res);
}
}
#line 727 "/home/june/repo/benchmarks/collector/temp/rhash-1.3.1/common_func.c"
void rsh_str_free(strbuf_t *ptr ) 
{ 


  {
#line 729
  if (ptr) {
    {
#line 730
    free((void *)ptr->str);
#line 731
    free((void *)ptr);
    }
  }
#line 733
  return;
}
}
#line 742 "/home/june/repo/benchmarks/collector/temp/rhash-1.3.1/common_func.c"
void rsh_str_ensure_size(strbuf_t *str , size_t new_size ) 
{ 
  void *tmp ;

  {
#line 744
  if (new_size >= str->allocated) {
#line 745
    if (new_size < 64UL) {
#line 745
      new_size = (size_t )64;
    }
    {
#line 746
    tmp = rhash_realloc((void *)str->str, new_size, "/home/june/repo/benchmarks/collector/temp/rhash-1.3.1/common_func.c",
                        746);
#line 746
    str->str = (char *)tmp;
#line 747
    str->allocated = new_size;
    }
  }
#line 749
  return;
}
}
#line 761 "/home/june/repo/benchmarks/collector/temp/rhash-1.3.1/common_func.c"
void rsh_str_append_n(strbuf_t *str , char const   *text , size_t length ) 
{ 


  {
#line 763
  if ((str->len + length) + 1UL >= str->allocated) {
    {
#line 763
    rsh_str_ensure_size(str, ((str->len + length) + 1UL) + 1UL);
    }
  }
  {
#line 764
  memcpy((void */* __restrict  */)(str->str + str->len), (void const   */* __restrict  */)text,
         length);
#line 765
  str->len += length;
#line 766
  *(str->str + str->len) = (char )'\000';
  }
#line 767
  return;
}
}
#line 775 "/home/june/repo/benchmarks/collector/temp/rhash-1.3.1/common_func.c"
void rsh_str_append(strbuf_t *str , char const   *text ) 
{ 
  size_t tmp ;

  {
  {
#line 777
  tmp = strlen(text);
#line 777
  rsh_str_append_n(str, text, tmp);
  }
#line 778
  return;
}
}
#line 168 "/usr/include/stdio.h"
extern struct _IO_FILE *stdin ;
#line 242
extern int fflush(FILE *__stream ) ;
#line 715
extern size_t fwrite(void const   * __restrict  __ptr , size_t __size , size_t __n ,
                     FILE * __restrict  __s ) ;
#line 192 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) time_t ( __attribute__((__leaf__)) time)(time_t *__timer ) ;
#line 263 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strrchr)(char const   *__s ,
                                                                                                int __c )  __attribute__((__pure__)) ;
#line 826 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) unlink)(char const   *__name ) ;
#line 88 "/home/june/repo/benchmarks/collector/temp/rhash-1.3.1/librhash/rhash.h"
extern int rhash_file_update(rhash ctx , FILE *fd ) ;
#line 95
extern rhash rhash_init(unsigned int hash_id ) ;
#line 98
extern int rhash_final(rhash ctx , unsigned char *first_result ) ;
#line 99
extern void rhash_reset(rhash ctx ) ;
#line 100
extern void rhash_free(rhash ctx ) ;
#line 103
extern void rhash_set_callback(rhash ctx , void (*callback)(void *data , unsigned long long offset ) ,
                               void *callback_data ) ;
#line 171
extern size_t rhash_print(char *output , rhash ctx , unsigned int hash_id , int flags ) ;
#line 196
extern rhash_uptr_t rhash_transmit(unsigned int msg_id , void *dst , rhash_uptr_t ldata ,
                                   rhash_uptr_t rdata ) ;
#line 30 "/home/june/repo/benchmarks/collector/temp/rhash-1.3.1/hash_print.h"
void print_line(FILE *out , print_item *list , struct file_info *info ) ;
#line 25 "/home/june/repo/benchmarks/collector/temp/rhash-1.3.1/output.h"
struct percents_output_info_t *percents_output ;
#line 35
void log_warning(char const   *format  , ...) ;
#line 37
void report_interrupted(void) ;
#line 38
void print_check_stats(void) ;
#line 41
void print_file_time_stats(struct file_info *info ) ;
#line 52 "/home/june/repo/benchmarks/collector/temp/rhash-1.3.1/hash_check.h"
int hash_check_verify(hash_check *hashes , struct rhash_context *ctx ) ;
#line 55
void rhash_hex_to_byte(char const   *str , unsigned char *bin , int len ) ;
#line 37 "/home/june/repo/benchmarks/collector/temp/rhash-1.3.1/calc_sums.h"
void file_info_destroy(struct file_info *info ) ;
#line 38
char const   *file_info_get_utf8_print_path(struct file_info *info ) ;
#line 40
void save_torrent_to(char const   *path , struct rhash_context *rctx ) ;
#line 42
int check_hash_file(file_t *file , int chdir___0 ) ;
#line 43
int rename_file_by_embeding_crc32(struct file_info *info ) ;
#line 45
int print_sfv_header_line(FILE *out , file_t *file , char const   *printpath ) ;
#line 31 "/home/june/repo/benchmarks/collector/temp/rhash-1.3.1/calc_sums.c"
static void init_btih_data(struct file_info *info ) 
{ 
  char const   *tmp ;

  {
  {
#line 34
  tmp = file_info_get_utf8_print_path(info);
#line 34
  rhash_transmit(32U, (void *)info->rctx, (rhash_uptr_t )((char *)tmp), (rhash_uptr_t )(& info->size));
#line 36
  rhash_transmit(36U, (void *)info->rctx, (rhash_uptr_t )"RHash/1.3.1", (rhash_uptr_t )0);
  }
#line 38
  if (opt.flags & 4096U) {
    {
#line 39
    rhash_transmit(33U, (void *)info->rctx, (rhash_uptr_t )1, (rhash_uptr_t )0);
    }
  }
#line 42
  if (opt.bt_announce) {
    {
#line 43
    rhash_transmit(34U, (void *)info->rctx, (rhash_uptr_t )opt.bt_announce, (rhash_uptr_t )0);
    }
  }
#line 46
  if (opt.bt_piece_length) {
    {
#line 47
    rhash_transmit(35U, (void *)info->rctx, (rhash_uptr_t )opt.bt_piece_length, (rhash_uptr_t )0);
    }
  } else
#line 48
  if (opt.bt_batch_file) {
#line 48
    if (rhash_data.batch_size) {
      {
#line 49
      rhash_transmit(38U, (void *)info->rctx, (rhash_uptr_t )(& rhash_data.batch_size),
                     (rhash_uptr_t )0);
      }
    }
  }
#line 51
  return;
}
}
#line 58 "/home/june/repo/benchmarks/collector/temp/rhash-1.3.1/calc_sums.c"
static void re_init_rhash_context(struct file_info *info ) 
{ 
  char const   *tmp ;

  {
#line 60
  if ((unsigned long )rhash_data.rctx != (unsigned long )((struct rhash_context *)0)) {
#line 61
    if (opt.mode & 3U) {
      {
#line 63
      rhash_free(rhash_data.rctx);
#line 64
      rhash_data.rctx = (struct rhash_context *)0;
      }
    } else {
#line 66
      info->rctx = rhash_data.rctx;
#line 67
      if (! opt.bt_batch_file) {
        {
#line 68
        rhash_reset(rhash_data.rctx);
        }
      } else {
        {
#line 71
        tmp = file_info_get_utf8_print_path(info);
#line 71
        rhash_transmit(32U, (void *)rhash_data.rctx, (rhash_uptr_t )((char *)tmp),
                       (rhash_uptr_t )(& info->size));
        }
#line 73
        return;
      }
    }
  }
#line 78
  if ((unsigned long )rhash_data.rctx == (unsigned long )((struct rhash_context *)0)) {
    {
#line 79
    rhash_data.rctx = rhash_init(info->sums_flags);
#line 79
    info->rctx = rhash_data.rctx;
    }
  }
#line 83
  if (info->sums_flags & 64U) {
    {
#line 84
    init_btih_data(info);
    }
  }
#line 86
  return;
}
}
#line 95 "/home/june/repo/benchmarks/collector/temp/rhash-1.3.1/calc_sums.c"
static int calc_sums(struct file_info *info ) 
{ 
  FILE *fd ;
  int res ;
  int *tmp ;

  {
#line 97
  fd = stdin;
#line 101
  if ((info->file)->mode & 32U) {
#line 102
    info->print_path = "(stdin)";
  } else {
#line 111
    if (opt.mode & 3U) {
#line 111
      if ((info->file)->mode & 1U) {
        {
#line 112
        tmp = __errno_location();
#line 112
        *tmp = 21;
        }
#line 113
        return (-1);
      }
    }
#line 116
    info->size = (info->file)->size;
#line 118
    if (! info->sums_flags) {
#line 118
      return (0);
    }
    {
#line 122
    fd = fopen((char const   */* __restrict  */)info->full_path, (char const   */* __restrict  */)"rb");
    }
#line 123
    if (! fd) {
#line 124
      return (-1);
    }
  }
  {
#line 128
  re_init_rhash_context(info);
#line 130
  info->msg_offset = (uint64_t )(info->rctx)->msg_size;
  }
#line 132
  if ((unsigned long )percents_output->update != (unsigned long )((void (*)(struct file_info *info ,
                                                                            uint64_t offset ))0)) {
    {
#line 133
    rhash_set_callback(info->rctx, (void (*)(void *data , unsigned long long offset ))percents_output->update,
                       (void *)info);
    }
  }
  {
#line 137
  res = rhash_file_update(info->rctx, fd);
  }
#line 137
  if (res != -1) {
#line 138
    if (! opt.bt_batch_file) {
      {
#line 139
      rhash_final(info->rctx, (unsigned char *)0);
      }
    }
  }
#line 143
  info->size = (uint64_t )((info->rctx)->msg_size - (unsigned long long )info->msg_offset);
#line 144
  rhash_data.total_size += info->size;
#line 146
  if ((unsigned long )fd != (unsigned long )stdin) {
    {
#line 146
    fclose(fd);
    }
  }
#line 147
  return (res);
}
}
#line 155 "/home/june/repo/benchmarks/collector/temp/rhash-1.3.1/calc_sums.c"
void file_info_destroy(struct file_info *info ) 
{ 


  {
  {
#line 157
  free((void *)info->utf8_print_path);
#line 158
  free((void *)info->allocated_ptr);
  }
#line 159
  return;
}
}
#line 168 "/home/june/repo/benchmarks/collector/temp/rhash-1.3.1/calc_sums.c"
static void file_info_set_print_path(struct file_info *info , char const   *print_path ) 
{ 
  char *p ;
  char wrong_sep ;
  char *tmp ;

  {
#line 174
  if (opt.path_separator) {
#line 175
    if ((int )opt.path_separator == 47) {
#line 175
      wrong_sep = (char )'\\';
    } else {
#line 175
      wrong_sep = (char )'/';
    }
    {
#line 176
    tmp = strchr(print_path, (int )wrong_sep);
#line 176
    p = tmp;
    }
#line 176
    if ((unsigned long )p != (unsigned long )((void *)0)) {
      {
#line 177
      info->allocated_ptr = rhash_strdup(print_path, "/home/june/repo/benchmarks/collector/temp/rhash-1.3.1/calc_sums.c",
                                         177);
#line 178
      info->print_path = (char const   *)info->allocated_ptr;
#line 179
      p = info->allocated_ptr + (p - (char *)print_path);
      }
      {
#line 182
      while (1) {
        while_continue: /* CIL Label */ ;
#line 182
        if (! *p) {
#line 182
          goto while_break;
        }
#line 183
        if ((int )*p == (int )wrong_sep) {
#line 183
          *p = opt.path_separator;
        }
#line 182
        p ++;
      }
      while_break: /* CIL Label */ ;
      }
#line 185
      return;
    }
  }
#line 190
  info->print_path = print_path;
#line 191
  return;
}
}
#line 199 "/home/june/repo/benchmarks/collector/temp/rhash-1.3.1/calc_sums.c"
char const   *file_info_get_utf8_print_path(struct file_info *info ) 
{ 


  {
#line 201
  if ((unsigned long )info->utf8_print_path == (unsigned long )((void *)0)) {
#line 202
    return (info->print_path);
#line 203
    info->utf8_print_path = (char *)((void *)0);
  }
#line 205
  return ((char const   *)info->utf8_print_path);
}
}
#line 217 "/home/june/repo/benchmarks/collector/temp/rhash-1.3.1/calc_sums.c"
static int find_embedded_crc32(char const   *filepath , unsigned int *crc32_be ) 
{ 
  char const   *e ;
  size_t tmp ;
  char const   *p ;
  int tmp___0 ;

  {
  {
#line 219
  tmp = strlen(filepath);
#line 219
  e = (filepath + tmp) - 10;
  }
  {
#line 222
  while (1) {
    while_continue: /* CIL Label */ ;
#line 222
    if ((unsigned long )e >= (unsigned long )filepath) {
#line 222
      if (! (! ((int const   )*e == 47))) {
#line 222
        goto while_break;
      }
    } else {
#line 222
      goto while_break;
    }
#line 223
    if ((int const   )*e == 91) {
#line 223
      if ((int const   )*(e + 9) == 93) {
#line 223
        goto _L;
      } else {
#line 223
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 223
    if ((int const   )*e == 40) {
#line 223
      if ((int const   )*(e + 9) == 41) {
        _L: /* CIL Label */ 
#line 224
        p = e + 8;
        {
#line 225
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 225
          if ((unsigned long )p > (unsigned long )e) {
#line 225
            if ((int const   )*p <= 57) {
#line 225
              tmp___0 = (int const   )*p >= 48;
            } else {
#line 225
              tmp___0 = (unsigned int )(((int const   )*p - 65) & -33) <= 5U;
            }
#line 225
            if (! tmp___0) {
#line 225
              goto while_break___0;
            }
          } else {
#line 225
            goto while_break___0;
          }
#line 225
          p --;
        }
        while_break___0: /* CIL Label */ ;
        }
#line 226
        if ((unsigned long )p == (unsigned long )e) {
          {
#line 227
          rhash_hex_to_byte(e + 1, (unsigned char *)crc32_be, 8);
          }
#line 228
          return (1);
        }
#line 230
        e -= 9;
      }
    }
#line 222
    e --;
  }
  while_break: /* CIL Label */ ;
  }
#line 233
  return (0);
}
}
#line 243 "/home/june/repo/benchmarks/collector/temp/rhash-1.3.1/calc_sums.c"
int rename_file_by_embeding_crc32(struct file_info *info ) 
{ 
  size_t len ;
  size_t tmp ;
  char const   *p ;
  char const   *c ;
  char *new_path ;
  char *insertion_point ;
  unsigned int crc32_be ;
  unsigned char *c___0 ;
  rhash_uptr_t tmp___0 ;
  unsigned int actual_crc32 ;
  char crc32_str[9] ;
  int tmp___1 ;
  void *tmp___2 ;
  char *tmp___3 ;
  int *tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  size_t tmp___7 ;

  {
  {
#line 245
  tmp = strlen((char const   *)info->full_path);
#line 245
  len = tmp;
#line 246
  p = (char const   *)(info->full_path + len);
#line 247
  c = p - 1;
#line 254
  tmp___1 = find_embedded_crc32(info->print_path, & crc32_be);
  }
#line 254
  if (tmp___1) {
    {
#line 255
    tmp___0 = rhash_transmit(1U, (void *)info->rctx, (rhash_uptr_t )1, (rhash_uptr_t )0);
#line 255
    c___0 = (unsigned char *)((void *)((char *)0 + tmp___0));
#line 257
    actual_crc32 = ((((unsigned int )*(c___0 + 0) << 24) | ((unsigned int )*(c___0 + 1) << 16)) | ((unsigned int )*(c___0 + 2) << 8)) | (unsigned int )*(c___0 + 3);
    }
#line 261
    if (crc32_be != actual_crc32) {
      {
#line 263
      rhash_print(crc32_str, info->rctx, 1U, 8);
#line 265
      log_warning("wrong embedded CRC32, should be %s\n", crc32_str);
      }
    } else {
#line 266
      return (0);
    }
  }
  {
#line 270
  while (1) {
    while_continue: /* CIL Label */ ;
#line 270
    if ((unsigned long )c >= (unsigned long )info->full_path) {
#line 270
      if (! (! ((int const   )*c == 47))) {
#line 270
        goto while_break;
      }
    } else {
#line 270
      goto while_break;
    }
#line 271
    if ((int const   )*c == 46) {
#line 272
      p = c;
#line 273
      goto while_break;
    }
#line 270
    c --;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 278
  tmp___2 = rhash_malloc(len + 12UL, "/home/june/repo/benchmarks/collector/temp/rhash-1.3.1/calc_sums.c",
                         278);
#line 278
  new_path = (char *)tmp___2;
#line 279
  insertion_point = new_path + (p - (char const   *)info->full_path);
#line 280
  memcpy((void */* __restrict  */)new_path, (void const   */* __restrict  */)info->full_path,
         (size_t )(p - (char const   *)info->full_path));
  }
#line 281
  if (opt.embed_crc_delimiter) {
#line 281
    if (*(opt.embed_crc_delimiter)) {
#line 281
      tmp___3 = insertion_point;
#line 281
      insertion_point ++;
#line 281
      *tmp___3 = *(opt.embed_crc_delimiter);
    }
  }
  {
#line 282
  rhash_print(insertion_point + 1, info->rctx, 1U, 8);
#line 283
  *(insertion_point + 0) = (char )'[';
#line 284
  *(insertion_point + 9) = (char )']';
#line 285
  strcpy((char */* __restrict  */)(insertion_point + 10), (char const   */* __restrict  */)p);
#line 288
  tmp___6 = rename((char const   *)info->full_path, (char const   *)new_path);
  }
#line 288
  if (tmp___6 < 0) {
    {
#line 289
    tmp___4 = __errno_location();
#line 289
    tmp___5 = strerror(*tmp___4);
#line 289
    log_error("can\'t move %s to %s: %s\n", info->full_path, new_path, tmp___5);
#line 291
    free((void *)new_path);
    }
#line 292
    return (-1);
  }
#line 296
  if ((unsigned long )info->print_path >= (unsigned long )info->full_path) {
#line 296
    if ((unsigned long )info->print_path < (unsigned long )p) {
      {
#line 297
      tmp___7 = strlen(info->print_path);
#line 297
      file_info_set_print_path(info, (char const   *)((new_path + len) - tmp___7));
      }
    } else {
      {
#line 299
      file_info_set_print_path(info, (char const   *)new_path);
      }
    }
  } else {
    {
#line 299
    file_info_set_print_path(info, (char const   *)new_path);
    }
  }
  {
#line 302
  free((void *)info->full_path);
#line 303
  info->full_path = new_path;
  }
#line 304
  return (0);
}
}
#line 313 "/home/june/repo/benchmarks/collector/temp/rhash-1.3.1/calc_sums.c"
void save_torrent_to(char const   *path , struct rhash_context *rctx ) 
{ 
  FILE *fd ;
  struct stat stat_buf ;
  size_t text_len ;
  char *str ;
  rhash_uptr_t tmp ;
  char *bak_path ;
  char *tmp___0 ;
  int tmp___1 ;
  size_t tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
  {
#line 321
  tmp = rhash_transmit(37U, (void *)rctx, (rhash_uptr_t )(& str), (rhash_uptr_t )0);
#line 321
  text_len = (size_t )tmp;
#line 324
  tmp___1 = stat((char const   */* __restrict  */)path, (struct stat */* __restrict  */)(& stat_buf));
  }
#line 324
  if (tmp___1 >= 0) {
    {
#line 326
    tmp___0 = str_append(path, ".bak");
#line 326
    bak_path = tmp___0;
#line 327
    unlink((char const   *)bak_path);
#line 328
    rename(path, (char const   *)bak_path);
#line 329
    free((void *)bak_path);
    }
  }
  {
#line 333
  fd = fopen((char const   */* __restrict  */)path, (char const   */* __restrict  */)"wb");
  }
#line 334
  if (fd) {
    {
#line 334
    tmp___2 = fwrite((void const   */* __restrict  */)str, (size_t )1, text_len, (FILE */* __restrict  */)fd);
    }
#line 334
    if (text_len == tmp___2) {
      {
#line 334
      tmp___3 = ferror(fd);
      }
#line 334
      if (tmp___3) {
        {
#line 339
        log_file_error(path);
        }
      } else {
        {
#line 334
        tmp___4 = fflush(fd);
        }
#line 334
        if (tmp___4) {
          {
#line 339
          log_file_error(path);
          }
        } else {
          {
#line 337
          log_msg("%s saved\n", path);
          }
        }
      }
    } else {
      {
#line 339
      log_file_error(path);
      }
    }
  } else {
    {
#line 339
    log_file_error(path);
    }
  }
#line 341
  if (fd) {
    {
#line 341
    fclose(fd);
    }
  }
#line 342
  return;
}
}
#line 349 "/home/june/repo/benchmarks/collector/temp/rhash-1.3.1/calc_sums.c"
static void save_torrent(struct file_info *info ) 
{ 
  char *path ;
  char *tmp ;

  {
  {
#line 352
  tmp = str_append((char const   *)info->full_path, ".torrent");
#line 352
  path = tmp;
#line 353
  save_torrent_to((char const   *)path, info->rctx);
#line 354
  free((void *)path);
  }
#line 355
  return;
}
}
#line 365 "/home/june/repo/benchmarks/collector/temp/rhash-1.3.1/calc_sums.c"
int calculate_and_print_sums(FILE *out , file_t *file , char const   *print_path ) 
{ 
  struct file_info info ;
  timedelta_t timer ;
  int res ;
  int *tmp ;
  int tmp___0 ;

  {
  {
#line 369
  res = 0;
#line 371
  memset((void *)(& info), 0, sizeof(info));
#line 372
  info.file = file;
#line 373
  info.full_path = rhash_strdup((char const   *)file->path, "/home/june/repo/benchmarks/collector/temp/rhash-1.3.1/calc_sums.c",
                                373);
#line 374
  file_info_set_print_path(& info, print_path);
#line 375
  info.size = (uint64_t )0;
#line 377
  info.sums_flags = opt.sum_flags;
  }
#line 379
  if (file->mode & 32U) {
#line 380
    print_path = "(stdin)";
  } else {
#line 382
    if (file->mode & 1U) {
#line 382
      return (0);
    }
#line 383
    info.size = file->size;
  }
  {
#line 387
  (*(percents_output->init))(& info);
#line 388
  rhash_timer_start(& timer);
  }
#line 390
  if (info.sums_flags) {
    {
#line 392
    tmp___0 = calc_sums(& info);
    }
#line 392
    if (tmp___0 < 0) {
      {
#line 394
      tmp = __errno_location();
      }
#line 394
      if (*tmp == 13) {
#line 394
        return (0);
      }
      {
#line 395
      log_file_error((char const   *)file->path);
#line 396
      res = -1;
      }
    }
#line 398
    if (rhash_data.interrupted) {
      {
#line 399
      report_interrupted();
      }
#line 400
      return (0);
    }
  }
  {
#line 404
  info.time = rhash_timer_stop(& timer);
#line 405
  (*(percents_output->finish))(& info, res);
  }
#line 407
  if (opt.flags & 32U) {
    {
#line 409
    rename_file_by_embeding_crc32(& info);
    }
  }
#line 412
  if (opt.mode & 16U) {
#line 412
    if (! opt.bt_batch_file) {
      {
#line 413
      save_torrent(& info);
      }
    }
  }
#line 416
  if (opt.mode & 4U) {
#line 416
    if (opt.fmt == 2U) {
      {
#line 418
      print_sfv_header_line(rhash_data.upd_fd, file, (char const   *)0);
      }
#line 419
      if (opt.flags & 512U) {
        {
#line 420
        print_sfv_header_line(rhash_data.log, file, (char const   *)0);
#line 421
        fflush(rhash_data.log);
        }
      }
      {
#line 423
      rsh_file_cleanup(file);
      }
    }
  }
#line 426
  if (rhash_data.print_list) {
#line 426
    if (res >= 0) {
#line 427
      if (! opt.bt_batch_file) {
        {
#line 428
        print_line(out, rhash_data.print_list, & info);
#line 429
        fflush(out);
        }
#line 432
        if (opt.mode & 4U) {
#line 432
          if (opt.flags & 512U) {
            {
#line 433
            print_line(rhash_data.log, rhash_data.print_list, & info);
#line 434
            fflush(rhash_data.log);
            }
          }
        }
      }
#line 438
      if (opt.flags & 2048U) {
#line 438
        if (info.sums_flags) {
          {
#line 439
          print_file_time_stats(& info);
          }
        }
      }
    }
  }
  {
#line 442
  free((void *)info.full_path);
#line 443
  file_info_destroy(& info);
  }
#line 444
  return (res);
}
}
#line 453 "/home/june/repo/benchmarks/collector/temp/rhash-1.3.1/calc_sums.c"
static int verify_sums(struct file_info *info ) 
{ 
  timedelta_t timer ;
  int res ;
  int *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 456
  res = 0;
#line 457
  tmp = __errno_location();
#line 457
  *tmp = 0;
#line 460
  (*(percents_output->init))(info);
#line 461
  rhash_timer_start(& timer);
#line 463
  tmp___0 = calc_sums(info);
  }
#line 463
  if (tmp___0 < 0) {
    {
#line 464
    (*(percents_output->finish))(info, -1);
    }
#line 465
    return (-1);
  }
  {
#line 467
  info->time = rhash_timer_stop(& timer);
  }
#line 469
  if (rhash_data.interrupted) {
    {
#line 470
    report_interrupted();
    }
#line 471
    return (0);
  }
#line 474
  if (opt.flags & 32U) {
    {
#line 474
    tmp___1 = find_embedded_crc32(info->print_path, & info->hc.embedded_crc32_be);
    }
#line 474
    if (tmp___1) {
#line 476
      info->hc.flags |= 2U;
    }
  }
  {
#line 480
  tmp___2 = hash_check_verify(& info->hc, info->rctx);
  }
#line 480
  if (! tmp___2) {
#line 481
    res = -2;
  }
  {
#line 484
  (*(percents_output->finish))(info, res);
  }
#line 486
  if (opt.flags & 2048U) {
#line 486
    if (info->sums_flags) {
      {
#line 487
      print_file_time_stats(info);
      }
    }
  }
#line 489
  return (res);
}
}
#line 500 "/home/june/repo/benchmarks/collector/temp/rhash-1.3.1/calc_sums.c"
int check_hash_file(file_t *file , int chdir___0 ) 
{ 
  FILE *fd ;
  char buf[2048] ;
  size_t pos ;
  char const   *ralign ;
  timedelta_t timer ;
  struct file_info info ;
  char const   *hash_file_path ;
  int res ;
  int line_num ;
  double time___0 ;
  unsigned int crc32_be ;
  int *tmp ;
  int tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;
  char *line ;
  char *path_without_ext ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  char *point ;
  file_t file_to_check ;
  int is_absolute ;
  size_t len ;
  size_t tmp___8 ;
  void *tmp___9 ;
  int *tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  int tmp___13 ;

  {
#line 508
  hash_file_path = (char const   *)file->path;
#line 509
  res = 0;
#line 509
  line_num = 0;
#line 513
  if (opt.mode & 2U) {
    {
#line 515
    tmp___0 = find_embedded_crc32(hash_file_path, & crc32_be);
    }
#line 515
    if (tmp___0) {
      {
#line 517
      memset((void *)(& info), 0, sizeof(info));
#line 518
      info.full_path = rhash_strdup(hash_file_path, "/home/june/repo/benchmarks/collector/temp/rhash-1.3.1/calc_sums.c",
                                    518);
#line 519
      info.file = file;
#line 520
      file_info_set_print_path(& info, (char const   *)info.full_path);
#line 521
      info.hc.hash_mask = 1U;
#line 521
      info.sums_flags = info.hc.hash_mask;
#line 522
      info.hc.flags = 2U;
#line 523
      info.hc.embedded_crc32_be = crc32_be;
#line 525
      res = verify_sums(& info);
#line 526
      fflush(rhash_data.out);
      }
#line 527
      if (! rhash_data.interrupted) {
#line 528
        if (res == 0) {
#line 528
          (rhash_data.ok) ++;
        } else
#line 529
        if (res == -1) {
          {
#line 529
          tmp = __errno_location();
          }
#line 529
          if (*tmp == 2) {
#line 529
            (rhash_data.miss) ++;
          }
        }
#line 530
        (rhash_data.processed) ++;
      }
      {
#line 533
      free((void *)info.full_path);
#line 534
      file_info_destroy(& info);
      }
    } else {
      {
#line 536
      log_warning("file name doesn\'t contain a CRC32: %s\n", hash_file_path);
      }
#line 537
      return (-1);
    }
#line 539
    return (0);
  }
#line 543
  rhash_data.miss = 0U;
#line 543
  rhash_data.ok = rhash_data.miss;
#line 543
  rhash_data.processed = rhash_data.ok;
#line 544
  rhash_data.total_size = (uint64_t )0;
#line 546
  if (file->mode & 32U) {
#line 547
    fd = stdin;
#line 548
    hash_file_path = "<stdin>";
  } else {
    {
#line 549
    fd = fopen((char const   */* __restrict  */)hash_file_path, (char const   */* __restrict  */)"rb");
    }
#line 549
    if (! fd) {
      {
#line 550
      log_file_error(hash_file_path);
      }
#line 551
      return (-1);
    }
  }
  {
#line 554
  tmp___1 = strlen(hash_file_path);
#line 554
  pos = tmp___1 + 16UL;
  }
#line 555
  if (pos < 80UL) {
#line 555
    tmp___2 = 80 - (int )pos;
  } else {
#line 555
    tmp___2 = 2;
  }
  {
#line 555
  tmp___3 = str_set(buf, '-', tmp___2);
#line 555
  ralign = (char const   *)tmp___3;
#line 556
  fprintf((FILE */* __restrict  */)rhash_data.out, (char const   */* __restrict  */)"\n--( Verifying %s )%s\n",
          hash_file_path, ralign);
#line 557
  fflush(rhash_data.out);
#line 558
  rhash_timer_start(& timer);
  }
#line 561
  if (chdir___0) {
    {
#line 562
    pos = strlen(hash_file_path);
    }
    {
#line 563
    while (1) {
      while_continue: /* CIL Label */ ;
#line 563
      if (pos > 0UL) {
#line 563
        if (! (! ((int const   )*(hash_file_path + pos) == 47))) {
#line 563
          goto while_break;
        }
      } else {
#line 563
        goto while_break;
      }
#line 563
      pos --;
    }
    while_break: /* CIL Label */ ;
    }
#line 564
    if ((int const   )*(hash_file_path + pos) == 47) {
#line 564
      pos ++;
    }
  } else {
#line 565
    pos = (size_t )0;
  }
#line 568
  line_num = 0;
  {
#line 568
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 568
    tmp___11 = fgets((char */* __restrict  */)(buf), 2048, (FILE */* __restrict  */)fd);
    }
#line 568
    if (! tmp___11) {
#line 568
      goto while_break___0;
    }
#line 570
    line = buf;
#line 571
    path_without_ext = (char *)((void *)0);
#line 574
    if (line_num == 0) {
#line 574
      if ((int )buf[0] == -17) {
#line 574
        if ((int )buf[1] == -69) {
#line 574
          if ((int )buf[2] == -65) {
#line 574
            line += 3;
          }
        }
      }
    }
#line 576
    if ((int )*line == 0) {
#line 576
      goto __Cont;
    }
    {
#line 578
    tmp___4 = is_binary_string((char const   *)line);
    }
#line 578
    if (tmp___4) {
      {
#line 579
      log_error("file is binary: %s\n", hash_file_path);
      }
#line 580
      if ((unsigned long )fd != (unsigned long )stdin) {
        {
#line 580
        fclose(fd);
        }
      }
#line 581
      return (-1);
    }
#line 585
    if ((int )*line == 59) {
#line 585
      goto __Cont;
    } else
#line 585
    if ((int )*line == 35) {
#line 585
      goto __Cont;
    } else
#line 585
    if ((int )*line == 13) {
#line 585
      goto __Cont;
    } else
#line 585
    if ((int )*line == 10) {
#line 585
      goto __Cont;
    }
    {
#line 587
    memset((void *)(& info), 0, sizeof(info));
#line 589
    tmp___5 = feof(fd);
    }
#line 589
    if (tmp___5) {
#line 589
      tmp___6 = 0;
    } else {
#line 589
      tmp___6 = 1;
    }
    {
#line 589
    tmp___7 = hash_check_parse_line(line, & info.hc, tmp___6);
    }
#line 589
    if (! tmp___7) {
#line 589
      goto __Cont;
    }
#line 590
    if (info.hc.hash_mask == 0U) {
#line 590
      goto __Cont;
    }
#line 592
    info.print_path = (char const   *)info.hc.file_path;
#line 593
    info.sums_flags = info.hc.hash_mask;
#line 596
    if ((unsigned long )info.print_path == (unsigned long )((void *)0)) {
      {
#line 598
      path_without_ext = rhash_strdup(hash_file_path, "/home/june/repo/benchmarks/collector/temp/rhash-1.3.1/calc_sums.c",
                                      598);
#line 599
      point = strrchr((char const   *)path_without_ext, '.');
      }
#line 601
      if (point) {
        {
#line 602
        *point = (char )'\000';
#line 603
        file_info_set_print_path(& info, (char const   *)path_without_ext);
        }
      }
    }
#line 607
    if ((unsigned long )info.print_path != (unsigned long )((void *)0)) {
#line 609
      is_absolute = (int const   )*(info.print_path + 0) == 47;
#line 613
      if (pos) {
#line 613
        if (! is_absolute) {
          {
#line 614
          tmp___8 = strlen(info.print_path);
#line 614
          len = tmp___8;
#line 615
          tmp___9 = rhash_malloc((pos + len) + 1UL, "/home/june/repo/benchmarks/collector/temp/rhash-1.3.1/calc_sums.c",
                                 615);
#line 615
          info.full_path = (char *)tmp___9;
#line 616
          memcpy((void */* __restrict  */)info.full_path, (void const   */* __restrict  */)hash_file_path,
                 pos);
#line 617
          strcpy((char */* __restrict  */)(info.full_path + pos), (char const   */* __restrict  */)info.print_path);
          }
        } else {
          {
#line 619
          info.full_path = rhash_strdup(info.print_path, "/home/june/repo/benchmarks/collector/temp/rhash-1.3.1/calc_sums.c",
                                        619);
          }
        }
      } else {
        {
#line 619
        info.full_path = rhash_strdup(info.print_path, "/home/june/repo/benchmarks/collector/temp/rhash-1.3.1/calc_sums.c",
                                      619);
        }
      }
      {
#line 621
      memset((void *)(& file_to_check), 0, sizeof(file_t ));
#line 622
      file_to_check.path = info.full_path;
#line 623
      rsh_file_stat(& file_to_check);
#line 624
      info.file = & file_to_check;
#line 627
      res = verify_sums(& info);
#line 629
      fflush(rhash_data.out);
#line 630
      rsh_file_cleanup(& file_to_check);
#line 631
      file_info_destroy(& info);
      }
#line 633
      if (rhash_data.interrupted) {
        {
#line 634
        free((void *)path_without_ext);
        }
#line 635
        goto while_break___0;
      }
#line 639
      if (res == 0) {
#line 639
        (rhash_data.ok) ++;
      } else
#line 640
      if (res == -1) {
        {
#line 640
        tmp___10 = __errno_location();
        }
#line 640
        if (*tmp___10 == 2) {
#line 640
          (rhash_data.miss) ++;
        }
      }
#line 641
      (rhash_data.processed) ++;
    }
    {
#line 643
    free((void *)path_without_ext);
    }
    __Cont: /* CIL Label */ 
#line 568
    line_num ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 645
  time___0 = rhash_timer_stop(& timer);
#line 647
  tmp___12 = str_set(buf, '-', 80);
#line 647
  fprintf((FILE */* __restrict  */)rhash_data.out, (char const   */* __restrict  */)"%s\n",
          tmp___12);
#line 648
  print_check_stats();
  }
#line 650
  if (rhash_data.processed != rhash_data.ok) {
#line 650
    rhash_data.error_flag = 1;
  }
#line 652
  if (opt.flags & 2048U) {
#line 652
    if (rhash_data.processed > 1U) {
      {
#line 653
      print_time_stats(time___0, rhash_data.total_size, 1);
      }
    }
  }
  {
#line 656
  rhash_data.processed = 0U;
#line 657
  res = ferror(fd);
  }
#line 658
  if ((unsigned long )fd != (unsigned long )stdin) {
    {
#line 658
    fclose(fd);
    }
  }
#line 659
  if (res == 0) {
#line 659
    tmp___13 = 0;
  } else {
#line 659
    tmp___13 = -1;
  }
#line 659
  return (tmp___13);
}
}
#line 669 "/home/june/repo/benchmarks/collector/temp/rhash-1.3.1/calc_sums.c"
int print_sfv_header_line(FILE *out , file_t *file , char const   *printpath ) 
{ 
  char buf[24] ;

  {
#line 674
  if ((file->mode & 32U) != 0U) {
#line 674
    return (0);
  }
#line 683
  if (! printpath) {
#line 683
    printpath = (char const   *)file->path;
  }
#line 684
  if ((int const   )*(printpath + 0) == 46) {
#line 684
    if ((int const   )*(printpath + 1) == 47) {
#line 684
      printpath += 2;
    }
  }
  {
#line 686
  sprintI64(buf, file->size, 12);
#line 687
  fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)"; %s  ",
          buf);
#line 688
  print_time64(out, file->mtime);
#line 689
  fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)" %s\n",
          printpath);
  }
#line 690
  return (0);
}
}
#line 699 "/home/june/repo/benchmarks/collector/temp/rhash-1.3.1/calc_sums.c"
void print_sfv_banner(FILE *out ) 
{ 
  time_t cur_time ;
  time_t tmp ;
  struct tm *t ;
  struct tm *tmp___0 ;

  {
  {
#line 701
  tmp = time((time_t *)((void *)0));
#line 701
  cur_time = tmp;
#line 702
  tmp___0 = localtime((time_t const   *)(& cur_time));
#line 702
  t = tmp___0;
  }
#line 703
  if (t) {
    {
#line 704
    fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)"; Generated by %s v%s on %4u-%02u-%02u at %02u:%02u.%02u\n",
            "RHash", "1.3.1", 1900 + t->tm_year, t->tm_mon + 1, t->tm_mday, t->tm_hour,
            t->tm_min, t->tm_sec);
#line 707
    fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)"; Written by Aleksey (Akademgorodok) - http://rhash.sourceforge.net/\n;\n");
    }
  }
#line 709
  return;
}
}
#line 765 "/usr/include/stdlib.h"
extern void ( __attribute__((__nonnull__(1,4))) qsort)(void *__base , size_t __nmemb ,
                                                       size_t __size , int (*__compar)(void const   * ,
                                                                                       void const   * ) ) ;
#line 144 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 86 "/home/june/repo/benchmarks/collector/temp/rhash-1.3.1/librhash/rhash.h"
extern int rhash_msg(unsigned int hash_id , void const   *message , size_t length ,
                     unsigned char *result ) ;
#line 23 "/home/june/repo/benchmarks/collector/temp/rhash-1.3.1/file_set.c"
static unsigned int file_set_make_hash(char const   *string ) 
{ 
  unsigned int hash ;
  size_t tmp ;
  int tmp___0 ;

  {
  {
#line 26
  tmp = strlen(string);
#line 26
  tmp___0 = rhash_msg(1U, (void const   *)string, tmp, (unsigned char *)(& hash));
  }
#line 26
  if (tmp___0 < 0) {
#line 27
    return (0U);
  }
#line 28
  return (hash);
}
}
#line 37 "/home/june/repo/benchmarks/collector/temp/rhash-1.3.1/file_set.c"
static int file_set_item_set_filepath(file_set_item *item , char const   *filepath ) 
{ 
  char *tmp ;

  {
#line 39
  if ((unsigned long )item->search_filepath != (unsigned long )item->filepath) {
    {
#line 40
    free((void *)item->search_filepath);
    }
  }
  {
#line 41
  free((void *)item->filepath);
#line 42
  item->filepath = rhash_strdup(filepath, "/home/june/repo/benchmarks/collector/temp/rhash-1.3.1/file_set.c",
                                42);
  }
#line 43
  if (! item->filepath) {
#line 43
    return (0);
  }
#line 48
  if (opt.flags & 256U) {
    {
#line 48
    tmp = str_tolower((char const   *)item->filepath);
#line 48
    item->search_filepath = tmp;
    }
  } else {
#line 48
    item->search_filepath = item->filepath;
  }
  {
#line 49
  item->hash = file_set_make_hash((char const   *)item->search_filepath);
  }
#line 50
  return (1);
}
}
#line 59 "/home/june/repo/benchmarks/collector/temp/rhash-1.3.1/file_set.c"
static file_set_item *file_set_item_new(char const   *filepath ) 
{ 
  file_set_item *item ;
  void *tmp ;
  int tmp___0 ;

  {
  {
#line 61
  tmp = rhash_malloc(sizeof(file_set_item ), "/home/june/repo/benchmarks/collector/temp/rhash-1.3.1/file_set.c",
                     61);
#line 61
  item = (file_set_item *)tmp;
#line 62
  memset((void *)item, 0, sizeof(file_set_item ));
  }
#line 64
  if (filepath) {
    {
#line 65
    tmp___0 = file_set_item_set_filepath(item, filepath);
    }
#line 65
    if (! tmp___0) {
      {
#line 66
      free((void *)item);
      }
#line 67
      return ((file_set_item *)((void *)0));
    }
  }
#line 70
  return (item);
}
}
#line 78 "/home/june/repo/benchmarks/collector/temp/rhash-1.3.1/file_set.c"
void file_set_item_free(file_set_item *item ) 
{ 


  {
#line 80
  if ((unsigned long )item->search_filepath != (unsigned long )item->filepath) {
    {
#line 81
    free((void *)item->search_filepath);
    }
  }
  {
#line 83
  free((void *)item->filepath);
#line 84
  free((void *)item);
  }
#line 85
  return;
}
}
#line 94 "/home/june/repo/benchmarks/collector/temp/rhash-1.3.1/file_set.c"
static int crc_pp_rec_compare(void const   *pp_rec1 , void const   *pp_rec2 ) 
{ 
  file_set_item const   *rec1 ;
  file_set_item const   *rec2 ;
  int tmp ;
  int tmp___0 ;

  {
#line 96
  rec1 = (file_set_item const   *)*((file_set_item * const  *)pp_rec1);
#line 97
  rec2 = (file_set_item const   *)*((file_set_item * const  *)pp_rec2);
#line 98
  if (rec1->hash != rec2->hash) {
#line 98
    if (rec1->hash < rec2->hash) {
#line 98
      tmp = -1;
    } else {
#line 98
      tmp = 1;
    }
#line 98
    return (tmp);
  }
  {
#line 99
  tmp___0 = strcmp((char const   *)rec1->search_filepath, (char const   *)rec2->search_filepath);
  }
#line 99
  return (tmp___0);
}
}
#line 109 "/home/june/repo/benchmarks/collector/temp/rhash-1.3.1/file_set.c"
static int path_compare(void const   *rec1 , void const   *rec2 ) 
{ 
  int tmp ;

  {
  {
#line 111
  tmp = strcmp((char const   *)(*((file_set_item * const  *)rec1))->filepath, (char const   *)(*((file_set_item * const  *)rec2))->filepath);
  }
#line 111
  return (tmp);
}
}
#line 120 "/home/june/repo/benchmarks/collector/temp/rhash-1.3.1/file_set.c"
void file_set_sort(file_set *set ) 
{ 


  {
#line 122
  if (set->array) {
    {
#line 122
    qsort((void *)set->array, set->size, sizeof(file_set_item *), & crc_pp_rec_compare);
    }
  }
#line 123
  return;
}
}
#line 130 "/home/june/repo/benchmarks/collector/temp/rhash-1.3.1/file_set.c"
void file_set_sort_by_path(file_set *set ) 
{ 


  {
  {
#line 132
  qsort((void *)set->array, set->size, sizeof(file_set_item *), & path_compare);
  }
#line 133
  return;
}
}
#line 141 "/home/june/repo/benchmarks/collector/temp/rhash-1.3.1/file_set.c"
void file_set_add_name(file_set *set , char const   *filepath ) 
{ 
  file_set_item *item ;
  file_set_item *tmp ;

  {
  {
#line 143
  tmp = file_set_item_new(filepath);
#line 143
  item = tmp;
  }
#line 144
  if (item) {
    {
#line 144
    rsh_vector_add_ptr(set, (void *)item);
    }
  }
#line 145
  return;
}
}
#line 154 "/home/june/repo/benchmarks/collector/temp/rhash-1.3.1/file_set.c"
int file_set_exist(file_set *set , char const   *filepath ) 
{ 
  int a ;
  int b ;
  int c ;
  int cmp ;
  int res ;
  unsigned int hash ;
  char *search_filepath ;
  char *tmp ;
  file_set_item *item ;

  {
#line 157
  res = 0;
#line 161
  if (! set->size) {
#line 161
    return (0);
  }
#line 165
  if (opt.flags & 256U) {
    {
#line 165
    tmp = str_tolower(filepath);
#line 165
    search_filepath = tmp;
    }
  } else {
#line 165
    search_filepath = (char *)filepath;
  }
  {
#line 169
  hash = file_set_make_hash((char const   *)search_filepath);
#line 172
  a = -1;
#line 172
  b = (int )set->size;
  }
  {
#line 172
  while (1) {
    while_continue: /* CIL Label */ ;
#line 172
    if (! (a + 1 < b)) {
#line 172
      goto while_break;
    }
#line 175
    c = (a + b) / 2;
#line 178
    item = (file_set_item *)*(set->array + c);
#line 179
    if (hash != item->hash) {
#line 180
      if (hash < item->hash) {
#line 180
        cmp = -1;
      } else {
#line 180
        cmp = 1;
      }
    } else {
      {
#line 182
      cmp = strcmp((char const   *)search_filepath, (char const   *)item->search_filepath);
      }
#line 183
      if (cmp == 0) {
#line 184
        res = 1;
#line 185
        goto while_break;
      }
    }
#line 188
    if (cmp < 0) {
#line 188
      b = c;
    } else {
#line 189
      a = c;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 191
  if ((unsigned long )search_filepath != (unsigned long )filepath) {
    {
#line 191
    free((void *)search_filepath);
    }
  }
#line 192
  return (res);
}
}
#line 69 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) memcmp)(void const   *__s1 ,
                                                                                               void const   *__s2 ,
                                                                                               size_t __n )  __attribute__((__pure__)) ;
#line 17 "/home/june/repo/benchmarks/collector/temp/rhash-1.3.1/file_mask.h"
file_mask_array *file_mask_new_from_list(char const   *comma_separated_list ) ;
#line 18
void file_mask_add_list(file_mask_array *vect , char const   *comma_separated_list ) ;
#line 17 "/home/june/repo/benchmarks/collector/temp/rhash-1.3.1/file_mask.c"
static void file_mask_add(file_mask_array *vect , char const   *mask___0 ) 
{ 
  char *tmp ;

  {
  {
#line 19
  tmp = str_tolower(mask___0);
#line 19
  rsh_vector_add_ptr(vect, (void *)tmp);
  }
#line 20
  return;
}
}
#line 28 "/home/june/repo/benchmarks/collector/temp/rhash-1.3.1/file_mask.c"
file_mask_array *file_mask_new_from_list(char const   *comma_separated_list ) 
{ 
  file_mask_array *vect ;
  vector_t *tmp ;

  {
  {
#line 30
  tmp = rsh_vector_new_simple();
#line 30
  vect = tmp;
#line 31
  file_mask_add_list(vect, comma_separated_list);
  }
#line 32
  return (vect);
}
}
#line 41 "/home/june/repo/benchmarks/collector/temp/rhash-1.3.1/file_mask.c"
void file_mask_add_list(file_mask_array *vect , char const   *comma_separated_list ) 
{ 
  char *buf ;
  char *cur ;
  char *next ;
  char *tmp ;

  {
#line 44
  if (! comma_separated_list) {
#line 45
    return;
  } else
#line 44
  if (! *comma_separated_list) {
#line 45
    return;
  }
  {
#line 47
  buf = rhash_strdup(comma_separated_list, "/home/june/repo/benchmarks/collector/temp/rhash-1.3.1/file_mask.c",
                     47);
#line 48
  cur = buf;
  }
  {
#line 48
  while (1) {
    while_continue: /* CIL Label */ ;
#line 48
    if (cur) {
#line 48
      if (! *cur) {
#line 48
        goto while_break;
      }
    } else {
#line 48
      goto while_break;
    }
    {
#line 49
    next = strchr((char const   *)cur, ',');
    }
#line 50
    if (next) {
#line 50
      tmp = next;
#line 50
      next ++;
#line 50
      *tmp = (char )'\000';
    }
#line 51
    if ((int )*cur != 0) {
      {
#line 51
      file_mask_add(vect, (char const   *)cur);
      }
    }
#line 48
    cur = next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 53
  free((void *)buf);
  }
#line 54
  return;
}
}
#line 64 "/home/june/repo/benchmarks/collector/temp/rhash-1.3.1/file_mask.c"
int file_mask_match(file_mask_array *vect , char const   *name ) 
{ 
  unsigned int i ;
  int res ;
  size_t len ;
  size_t namelen ;
  char *buf ;
  int tmp ;

  {
#line 67
  res = 0;
#line 72
  if (! vect) {
#line 72
    return (1);
  } else
#line 72
  if (! vect->size) {
#line 72
    return (1);
  }
  {
#line 75
  buf = str_tolower(name);
#line 76
  namelen = strlen((char const   *)buf);
#line 77
  i = 0U;
  }
  {
#line 77
  while (1) {
    while_continue: /* CIL Label */ ;
#line 77
    if (! ((size_t )i < vect->size)) {
#line 77
      goto while_break;
    }
    {
#line 78
    len = strlen((char const   *)((char *)*(vect->array + i)));
    }
#line 79
    if (namelen >= len) {
      {
#line 79
      tmp = memcmp((void const   *)((buf + namelen) - len), (void const   *)*(vect->array + i),
                   len);
      }
#line 79
      if (tmp == 0) {
#line 80
        res = 1;
#line 81
        goto while_break;
      }
    }
#line 77
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 84
  free((void *)buf);
  }
#line 85
  return (res);
}
}
#line 169 "/usr/include/stdio.h"
extern struct _IO_FILE *stdout ;
#line 709
extern size_t fread(void * __restrict  __ptr , size_t __size , size_t __n , FILE * __restrict  __stream ) ;
#line 102 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) __sighandler_t ( __attribute__((__leaf__)) signal)(int __sig ,
                                                                                        void (*__handler)(int  ) ) ;
#line 124 "/usr/include/locale.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) setlocale)(int __category ,
                                                                                  char const   *__locale ) ;
#line 83 "/home/june/repo/benchmarks/collector/temp/rhash-1.3.1/librhash/rhash.h"
extern void rhash_library_init(void) ;
#line 36 "/home/june/repo/benchmarks/collector/temp/rhash-1.3.1/librhash/rhash_timing.h"
extern void rhash_run_benchmark(unsigned int hash_id , unsigned int flags , FILE *output ) ;
#line 38 "/home/june/repo/benchmarks/collector/temp/rhash-1.3.1/find_file.h"
void scan_files(file_search_data *data ) ;
#line 29 "/home/june/repo/benchmarks/collector/temp/rhash-1.3.1/hash_print.h"
print_item *parse_print_string(char const   *format , unsigned int *sum_mask ) ;
#line 31
void free_print_list(print_item *list ) ;
#line 33
void init_hash_info_table(void) ;
#line 34
void init_printf_format(struct strbuf_t *out ) ;
#line 95 "/home/june/repo/benchmarks/collector/temp/rhash-1.3.1/parse_cmdline.h"
void read_options(int argc , char **argv ) ;
#line 96
void options_destroy(struct options_t *o ) ;
#line 39 "/home/june/repo/benchmarks/collector/temp/rhash-1.3.1/rhash_main.h"
struct rhash_t rhash_data  ;
#line 41
void rhash_destroy(struct rhash_t *ptr ) ;
#line 41 "/home/june/repo/benchmarks/collector/temp/rhash-1.3.1/rhash_main.c"
static int must_skip_file(file_t *file ) 
{ 
  rsh_tchar const   *path ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 43
  path = (rsh_tchar const   *)file->path;
#line 46
  if (opt.output) {
    {
#line 46
    tmp = are_paths_equal(path, (rsh_tchar const   *)opt.output);
    }
#line 46
    if (tmp) {
#line 46
      tmp___1 = 1;
    } else {
#line 46
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 46
  if (opt.log) {
    {
#line 46
    tmp___0 = are_paths_equal(path, (rsh_tchar const   *)opt.log);
    }
#line 46
    if (tmp___0) {
#line 46
      tmp___1 = 1;
    } else {
#line 46
      tmp___1 = 0;
    }
  } else {
#line 46
    tmp___1 = 0;
  }
#line 46
  return (tmp___1);
}
}
#line 57 "/home/june/repo/benchmarks/collector/temp/rhash-1.3.1/rhash_main.c"
static int find_file_callback(file_t *file , int preprocess ) 
{ 
  int res ;
  int tmp ;
  int tmp___0 ;
  int not_root ;
  file_mask_array *masks ;
  struct vector_t *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  char const   *print_path ;

  {
#line 59
  res = 0;
#line 63
  if (rhash_data.interrupted) {
#line 64
    (opt.search_data)->options |= 16;
#line 65
    return (0);
  }
#line 68
  if (preprocess) {
    {
#line 69
    tmp = file_mask_match(opt.files_accept, (char const   *)file->path);
    }
#line 69
    if (tmp) {
      {
#line 69
      tmp___0 = must_skip_file(file);
      }
#line 69
      if (tmp___0) {
#line 70
        return (0);
      }
    } else {
#line 70
      return (0);
    }
#line 73
    if (opt.fmt & 2U) {
      {
#line 74
      print_sfv_header_line(rhash_data.out, file, (char const   *)0);
      }
    }
#line 77
    rhash_data.batch_size += file->size;
  } else {
#line 79
    not_root = ! (file->mode & 16U);
#line 81
    if (not_root) {
#line 83
      if (opt.mode & 5U) {
#line 83
        tmp___1 = opt.crc_accept;
      } else {
#line 83
        tmp___1 = opt.files_accept;
      }
      {
#line 83
      masks = tmp___1;
#line 85
      tmp___2 = file_mask_match(masks, (char const   *)file->path);
      }
#line 85
      if (! tmp___2) {
#line 85
        return (0);
      }
    }
    {
#line 87
    tmp___3 = must_skip_file(file);
    }
#line 87
    if (tmp___3) {
#line 87
      return (0);
    }
#line 89
    if (opt.mode & 3U) {
      {
#line 90
      res = check_hash_file(file, not_root);
      }
    } else
#line 92
    if (opt.mode & 4U) {
      {
#line 93
      res = update_hash_file(file);
      }
    } else {
#line 96
      print_path = (char const   *)file->path;
#line 97
      if ((int const   )*(print_path + 0) == 46) {
#line 97
        if ((int const   )*(print_path + 1) == 47) {
#line 97
          print_path += 2;
        }
      }
      {
#line 98
      res = calculate_and_print_sums(rhash_data.out, file, print_path);
      }
#line 99
      if (rhash_data.interrupted) {
#line 99
        return (0);
      }
#line 100
      (rhash_data.processed) ++;
    }
  }
#line 104
  if (res < 0) {
#line 104
    rhash_data.error_flag = 1;
  }
#line 105
  return (1);
}
}
#line 109 "/home/june/repo/benchmarks/collector/temp/rhash-1.3.1/rhash_main.c"
void (*prev_sigint_handler)(int  )  =    (void (*)(int  ))((void *)0);
#line 117 "/home/june/repo/benchmarks/collector/temp/rhash-1.3.1/rhash_main.c"
static void ctrl_c_handler(int signum ) 
{ 


  {
#line 120
  rhash_data.interrupted = 1;
#line 121
  if (rhash_data.rctx) {
    {
#line 122
    rhash_transmit(2U, (void *)rhash_data.rctx, (rhash_uptr_t )0, (rhash_uptr_t )0);
    }
  }
#line 124
  return;
}
}
#line 131 "/home/june/repo/benchmarks/collector/temp/rhash-1.3.1/rhash_main.c"
static int load_printf_template(void) 
{ 
  FILE *fd ;
  FILE *tmp ;
  char buffer[8192] ;
  size_t len ;
  int error ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 133
  tmp = fopen((char const   */* __restrict  */)opt.template_file, (char const   */* __restrict  */)"rb");
#line 133
  fd = tmp;
#line 136
  error = 0;
  }
#line 138
  if (! fd) {
    {
#line 139
    log_file_error((char const   *)opt.template_file);
    }
#line 140
    return (0);
  }
  {
#line 143
  rhash_data.template_text = rsh_str_new();
  }
  {
#line 145
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 145
    tmp___0 = feof(fd);
    }
#line 145
    if (tmp___0) {
#line 145
      goto while_break;
    }
    {
#line 146
    len = fread((void */* __restrict  */)(buffer), (size_t )1, (size_t )8192, (FILE */* __restrict  */)fd);
    }
#line 148
    if (len == 0xffffffffffffffffUL) {
#line 148
      goto while_break;
    }
    {
#line 149
    rsh_str_append_n(rhash_data.template_text, (char const   *)(buffer), len);
    }
#line 150
    if ((rhash_data.template_text)->len >= 65536UL) {
      {
#line 151
      log_msg("%s: template file is too big\n", opt.template_file);
#line 152
      error = 1;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 156
  tmp___1 = ferror(fd);
  }
#line 156
  if (tmp___1) {
    {
#line 157
    log_file_error((char const   *)opt.template_file);
#line 158
    error = 1;
    }
  }
  {
#line 161
  fclose(fd);
#line 162
  rhash_data.printf_str = (rhash_data.template_text)->str;
  }
#line 163
  return (! error);
}
}
#line 171 "/home/june/repo/benchmarks/collector/temp/rhash-1.3.1/rhash_main.c"
void rhash_destroy(struct rhash_t *ptr ) 
{ 


  {
  {
#line 173
  free_print_list(ptr->print_list);
#line 174
  rsh_str_free(ptr->template_text);
  }
#line 175
  if (ptr->rctx) {
    {
#line 175
    rhash_free(ptr->rctx);
    }
  }
#line 177
  return;
}
}
#line 179 "/home/june/repo/benchmarks/collector/temp/rhash-1.3.1/rhash_main.c"
static void i18n_initialize(void) 
{ 


  {
  {
#line 181
  setlocale(6, "");
  }
#line 187
  return;
}
}
#line 196 "/home/june/repo/benchmarks/collector/temp/rhash-1.3.1/rhash_main.c"
int main(int argc , char **argv ) 
{ 
  timedelta_t timer ;
  int exit_code ;
  int sfv ;
  unsigned int flags ;
  int tmp ;
  int tmp___0 ;
  char *str ;
  char *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  double time___0 ;
  double tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
  {
#line 202
  i18n_initialize();
#line 204
  memset((void *)(& rhash_data), 0, sizeof(rhash_data));
#line 205
  rhash_data.out = stdout;
#line 206
  rhash_data.log = stderr;
#line 208
  init_hash_info_table();
#line 210
  read_options(argc, argv);
#line 211
  prev_sigint_handler = signal(2, & ctrl_c_handler);
#line 212
  rhash_library_init();
  }
#line 215
  if (opt.mode & 8U) {
#line 216
    if (opt.flags & 65536U) {
#line 216
      tmp = 6;
    } else {
#line 216
      tmp = 2;
    }
#line 216
    flags = (unsigned int )tmp;
#line 217
    if ((opt.flags & 65536U) == 0U) {
      {
#line 218
      fprintf((FILE */* __restrict  */)rhash_data.out, (char const   */* __restrict  */)"%s v%s benchmarking...\n",
              "RHash", "1.3.1");
      }
    }
    {
#line 220
    rhash_run_benchmark(opt.sum_flags, flags, rhash_data.out);
#line 221
    (*rsh_exit)(0);
    }
  }
#line 224
  if (opt.n_files == 0) {
#line 225
    if (argc > 1) {
      {
#line 226
      log_warning("no files/directories were specified at command line\n");
      }
    }
    {
#line 230
    log_msg("Usage: %s [OPTION...] <FILE>...\n\nRun `%s --help\' for more help.\n",
            "rhash", "rhash");
#line 232
    (*rsh_exit)(0);
    }
  }
#line 237
  rhash_data.printf_str = opt.printf_str;
#line 239
  if (opt.template_file) {
    {
#line 240
    tmp___0 = load_printf_template();
    }
#line 240
    if (! tmp___0) {
      {
#line 240
      (*rsh_exit)(2);
      }
    }
  } else
#line 241
  if (! rhash_data.printf_str) {
#line 241
    if (! (opt.mode & 3U)) {
      {
#line 243
      rhash_data.template_text = rsh_str_new();
#line 243
      init_printf_format(rhash_data.template_text);
#line 244
      rhash_data.printf_str = (rhash_data.template_text)->str;
      }
#line 246
      if (opt.flags & 512U) {
        {
#line 247
        tmp___1 = rhash_strdup((char const   *)rhash_data.printf_str, "/home/june/repo/benchmarks/collector/temp/rhash-1.3.1/rhash_main.c",
                               247);
#line 247
        str = tmp___1;
#line 248
        tmp___2 = str_trim(str);
#line 248
        log_msg("Format string is: %s\n", tmp___2);
#line 249
        free((void *)str);
        }
      }
    }
  }
#line 253
  if (rhash_data.printf_str) {
    {
#line 254
    rhash_data.print_list = parse_print_string((char const   *)rhash_data.printf_str,
                                               & opt.sum_flags);
    }
  }
#line 257
  (opt.search_data)->options = 4;
#line 258
  (opt.search_data)->call_back = & find_file_callback;
#line 260
  if (opt.fmt == 2U) {
#line 260
    if (! opt.mode) {
#line 260
      tmp___3 = 1;
    } else {
#line 260
      tmp___3 = 0;
    }
  } else {
#line 260
    tmp___3 = 0;
  }
#line 260
  sfv = tmp___3;
#line 260
  if (sfv) {
    {
#line 261
    print_sfv_banner(rhash_data.out);
    }
  }
#line 265
  if (sfv) {
    {
#line 267
    (opt.search_data)->call_back_data = 1;
#line 268
    scan_files(opt.search_data);
#line 270
    fflush(rhash_data.out);
    }
  } else
#line 265
  if (opt.bt_batch_file) {
    {
#line 267
    (opt.search_data)->call_back_data = 1;
#line 268
    scan_files(opt.search_data);
#line 270
    fflush(rhash_data.out);
    }
  }
  {
#line 274
  rhash_timer_start(& timer);
#line 275
  rhash_data.processed = 0U;
#line 278
  (opt.search_data)->options = 12;
#line 279
  (opt.search_data)->call_back_data = 0;
#line 280
  scan_files(opt.search_data);
  }
#line 282
  if (opt.mode & 2U) {
#line 282
    if (rhash_data.processed > 1U) {
      {
#line 283
      print_check_stats();
      }
    }
  }
#line 286
  if (! rhash_data.interrupted) {
#line 288
    if (opt.bt_batch_file) {
#line 288
      if (rhash_data.rctx) {
        {
#line 289
        rhash_final(rhash_data.rctx, (unsigned char *)0);
#line 290
        save_torrent_to((char const   *)opt.bt_batch_file, rhash_data.rctx);
        }
      }
    }
#line 293
    if (opt.flags & 2048U) {
#line 293
      if (! (opt.mode & 5U)) {
#line 293
        if (rhash_data.processed > 1U) {
          {
#line 297
          tmp___4 = rhash_timer_stop(& timer);
#line 297
          time___0 = tmp___4;
#line 298
          print_time_stats(time___0, rhash_data.total_size, 1);
          }
        }
      }
    }
  } else
#line 302
  if (rhash_data.interrupted == 1) {
    {
#line 302
    report_interrupted();
    }
  }
#line 305
  if (rhash_data.error_flag) {
#line 305
    exit_code = 1;
  } else {
#line 305
    if ((opt.search_data)->errors_count) {
#line 305
      tmp___6 = 2;
    } else {
#line 305
      if (rhash_data.interrupted) {
#line 305
        tmp___5 = 3;
      } else {
#line 305
        tmp___5 = 0;
      }
#line 305
      tmp___6 = tmp___5;
    }
#line 305
    exit_code = tmp___6;
  }
  {
#line 308
  options_destroy(& opt);
#line 309
  rhash_destroy(& rhash_data);
  }
#line 312
  return (exit_code);
}
}
#line 128 "/home/june/repo/benchmarks/collector/temp/rhash-1.3.1/librhash/rhash.h"
extern char const   *rhash_get_name(unsigned int hash_id ) ;
#line 129
extern char const   *rhash_get_magnet_name(unsigned int hash_id ) ;
#line 24 "/home/june/repo/benchmarks/collector/temp/rhash-1.3.1/hash_print.h"
print_hash_info hash_info_table[32]  ;
#line 39 "/home/june/repo/benchmarks/collector/temp/rhash-1.3.1/hash_print.c"
static print_item *parse_percent_item(char const   **str ) ;
#line 49 "/home/june/repo/benchmarks/collector/temp/rhash-1.3.1/hash_print.c"
static print_item *new_print_item(unsigned int flags , unsigned int hash_id , char const   *data ) 
{ 
  print_item *item ;
  void *tmp ;
  char *tmp___0 ;

  {
  {
#line 51
  tmp = rhash_malloc(sizeof(print_item ), "/home/june/repo/benchmarks/collector/temp/rhash-1.3.1/hash_print.c",
                     51);
#line 51
  item = (print_item *)tmp;
#line 52
  item->flags = flags;
#line 53
  item->hash_id = hash_id;
#line 54
  item->width = 0U;
  }
#line 55
  if (data) {
    {
#line 55
    tmp___0 = rhash_strdup(data, "/home/june/repo/benchmarks/collector/temp/rhash-1.3.1/hash_print.c",
                           55);
#line 55
    item->data = (char const   *)tmp___0;
    }
  } else {
#line 55
    item->data = (char const   *)((void *)0);
  }
#line 56
  item->next = (struct print_item *)((void *)0);
#line 57
  return (item);
}
}
#line 67 "/home/june/repo/benchmarks/collector/temp/rhash-1.3.1/hash_print.c"
static char parse_escaped_char(char const   **pformat ) 
{ 
  char const   *start ;
  char const   *tmp ;
  int ch ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int ch___0 ;
  char const   *tmp___3 ;
  char const   *tmp___4 ;
  char const   *tmp___5 ;

  {
#line 69
  start = *pformat;
#line 70
  tmp = *pformat;
#line 70
  (*pformat) ++;
  {
#line 71
  if ((int const   )*tmp == 116) {
#line 71
    goto case_116;
  }
#line 72
  if ((int const   )*tmp == 114) {
#line 72
    goto case_114;
  }
#line 73
  if ((int const   )*tmp == 110) {
#line 73
    goto case_110;
  }
#line 74
  if ((int const   )*tmp == 92) {
#line 74
    goto case_92;
  }
#line 75
  if ((int const   )*tmp == 120) {
#line 75
    goto case_120;
  }
#line 89
  goto switch_default;
  case_116: /* CIL Label */ 
#line 71
  return ((char )'\t');
  case_114: /* CIL Label */ 
#line 72
  return ((char )'\r');
  case_110: /* CIL Label */ 
#line 73
  return ((char )'\n');
  case_92: /* CIL Label */ 
#line 74
  return ((char )'\\');
  case_120: /* CIL Label */ 
#line 77
  if ((int const   )*(*pformat) <= 57) {
#line 77
    tmp___2 = (int const   )*(*pformat) >= 48;
  } else {
#line 77
    tmp___2 = (unsigned int )(((int const   )*(*pformat) - 65) & -33) <= 5U;
  }
#line 77
  if (tmp___2) {
#line 79
    if ((int const   )*(*pformat) <= 57) {
#line 79
      ch = (int )((int const   )*(*pformat) & 15);
    } else {
#line 79
      ch = (int )(((int const   )*(*pformat) + 9) & 15);
    }
#line 80
    (*pformat) ++;
#line 81
    if ((int const   )*(*pformat) <= 57) {
#line 81
      tmp___1 = (int const   )*(*pformat) >= 48;
    } else {
#line 81
      tmp___1 = (unsigned int )(((int const   )*(*pformat) - 65) & -33) <= 5U;
    }
#line 81
    if (tmp___1) {
#line 83
      if ((int const   )*(*pformat) <= 57) {
#line 83
        tmp___0 = (int const   )*(*pformat) & 15;
      } else {
#line 83
        tmp___0 = ((int const   )*(*pformat) + 9) & 15;
      }
#line 83
      ch = 16 * ch + (int )tmp___0;
#line 84
      (*pformat) ++;
    }
#line 86
    if (ch) {
#line 86
      return ((char )ch);
    }
  }
#line 88
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 90
  (*pformat) --;
#line 92
  if (48 < (int )*(*pformat)) {
#line 92
    if ((int const   )*(*pformat) <= 55) {
#line 93
      tmp___3 = *pformat;
#line 93
      (*pformat) ++;
#line 93
      ch___0 = (int )((int const   )*tmp___3 - 48);
#line 94
      if (48 <= (int )*(*pformat)) {
#line 94
        if ((int const   )*(*pformat) <= 55) {
#line 95
          tmp___4 = *pformat;
#line 95
          (*pformat) ++;
#line 95
          ch___0 = (ch___0 * 8 + (int )*tmp___4) - 48;
#line 96
          if (48 <= (int )*(*pformat)) {
#line 96
            if ((int const   )*(*pformat) <= 55) {
#line 97
              tmp___5 = *pformat;
#line 97
              (*pformat) ++;
#line 97
              ch___0 = (ch___0 * 8 + (int )*tmp___5) - 48;
            }
          }
        }
      }
#line 99
      return ((char )ch___0);
    }
  }
  switch_break: /* CIL Label */ ;
  }
#line 102
  *pformat = start;
#line 103
  return ((char )'\\');
}
}
#line 111 "/home/june/repo/benchmarks/collector/temp/rhash-1.3.1/hash_print.c"
print_item *parse_print_string(char const   *format , unsigned int *sum_mask ) 
{ 
  char *buf ;
  char *p ;
  print_item *list ;
  print_item **tail ;
  print_item *item ;
  size_t tmp ;
  void *tmp___0 ;
  char *tmp___1 ;
  char const   *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char const   *tmp___5 ;
  char *tmp___6 ;

  {
  {
#line 114
  list = (print_item *)((void *)0);
#line 114
  item = (print_item *)((void *)0);
#line 116
  tmp = strlen(format);
#line 116
  tmp___0 = rhash_malloc(tmp + 1UL, "/home/june/repo/benchmarks/collector/temp/rhash-1.3.1/hash_print.c",
                         116);
#line 116
  p = (char *)tmp___0;
#line 116
  buf = p;
#line 117
  tail = & list;
#line 118
  *sum_mask = 0U;
  }
  {
#line 120
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 121
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 121
      if (*format) {
#line 121
        if ((int const   )*format != 37) {
#line 121
          if (! ((int const   )*format != 92)) {
#line 121
            goto while_break___0;
          }
        } else {
#line 121
          goto while_break___0;
        }
      } else {
#line 121
        goto while_break___0;
      }
#line 122
      tmp___1 = p;
#line 122
      p ++;
#line 122
      tmp___2 = format;
#line 122
      format ++;
#line 122
      *tmp___1 = (char )*tmp___2;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 124
    if ((int const   )*format == 92) {
#line 125
      format ++;
#line 125
      if ((int const   )*format == 48) {
        {
#line 126
        item = new_print_item(268435457U, 0U, (char const   *)((void *)0));
#line 127
        format ++;
        }
      } else {
        {
#line 129
        tmp___3 = p;
#line 129
        p ++;
#line 129
        *tmp___3 = parse_escaped_char(& format);
        }
#line 130
        goto __Cont;
      }
    } else
#line 132
    if ((int const   )*format == 37) {
#line 133
      format ++;
#line 133
      if ((int const   )*format == 37) {
#line 134
        tmp___4 = p;
#line 134
        p ++;
#line 134
        tmp___5 = format;
#line 134
        format ++;
#line 134
        *tmp___4 = (char )*tmp___5;
#line 135
        goto __Cont;
      } else {
        {
#line 137
        item = parse_percent_item(& format);
        }
#line 138
        if (! item) {
#line 139
          tmp___6 = p;
#line 139
          p ++;
#line 139
          *tmp___6 = (char )'%';
#line 140
          goto __Cont;
        }
#line 142
        if (item->hash_id) {
#line 143
          *sum_mask |= item->hash_id;
        }
      }
    }
#line 146
    if ((unsigned long )p > (unsigned long )buf) {
      {
#line 147
      *p = (char )'\000';
#line 148
      *tail = new_print_item(268435456U, 0U, (char const   *)buf);
#line 149
      tail = & (*tail)->next;
#line 150
      p = buf;
      }
    } else
#line 146
    if (! *format) {
#line 146
      if ((unsigned long )list == (unsigned long )((void *)0)) {
#line 146
        if ((unsigned long )item == (unsigned long )((void *)0)) {
          {
#line 147
          *p = (char )'\000';
#line 148
          *tail = new_print_item(268435456U, 0U, (char const   *)buf);
#line 149
          tail = & (*tail)->next;
#line 150
          p = buf;
          }
        }
      }
    }
#line 152
    if (item) {
#line 153
      *tail = item;
#line 154
      tail = & item->next;
#line 155
      item = (print_item *)((void *)0);
    }
#line 157
    if (! *format) {
#line 158
      goto while_break;
    }
    __Cont: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 160
  free((void *)buf);
  }
#line 161
  return (list);
}
}
#line 171 "/home/june/repo/benchmarks/collector/temp/rhash-1.3.1/hash_print.c"
static unsigned int printf_name_to_id(char const   *name , size_t length , unsigned int *flags ) 
{ 
  char buf[20] ;
  size_t i ;
  print_hash_info *info ;
  unsigned int bit ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 175
  info = hash_info_table;
#line 178
  if (length > sizeof(buf) - 1UL) {
#line 178
    return (0U);
  }
#line 179
  i = (size_t )0;
  {
#line 179
  while (1) {
    while_continue: /* CIL Label */ ;
#line 179
    if (! (i < length)) {
#line 179
      goto while_break;
    }
    {
#line 179
    tmp = tolower((int )*(name + i));
#line 179
    buf[i] = (char )tmp;
#line 179
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 182
  if (length == 7UL) {
    {
#line 182
    tmp___1 = memcmp((void const   *)(buf), (void const   *)"urlname", (size_t )7);
    }
#line 182
    if (tmp___1 == 0) {
#line 183
      *flags = 268435460U;
#line 184
      return (0U);
    } else {
#line 182
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 185
  if (length == 5UL) {
    {
#line 185
    tmp___0 = memcmp((void const   *)(buf), (void const   *)"mtime", (size_t )5);
    }
#line 185
    if (tmp___0 == 0) {
#line 186
      *flags = 268435462U;
#line 187
      return (0U);
    }
  }
#line 190
  bit = 1U;
  {
#line 190
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 190
    if (! (bit <= 67108863U)) {
#line 190
      goto while_break___0;
    }
    {
#line 191
    tmp___2 = memcmp((void const   *)(buf), (void const   *)(info->short_name), length);
    }
#line 191
    if (tmp___2 == 0) {
#line 191
      if ((int )info->short_name[length] == 0) {
#line 192
        return (bit);
      }
    }
#line 190
    bit <<= 1;
#line 190
    info ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 194
  return (0U);
}
}
#line 213 "/home/june/repo/benchmarks/collector/temp/rhash-1.3.1/hash_print.c"
static char const   *short_hash  =    "CMHTGWRAE";
#line 214 "/home/june/repo/benchmarks/collector/temp/rhash-1.3.1/hash_print.c"
static char const   *short_other  =    "Llpfus";
#line 215 "/home/june/repo/benchmarks/collector/temp/rhash-1.3.1/hash_print.c"
static unsigned int const   hash_ids[9]  = 
#line 215
  {      (unsigned int const   )1,      (unsigned int const   )4,      (unsigned int const   )8,      (unsigned int const   )32, 
        (unsigned int const   )2048,      (unsigned int const   )512,      (unsigned int const   )1024,      (unsigned int const   )256, 
        (unsigned int const   )128};
#line 219 "/home/june/repo/benchmarks/collector/temp/rhash-1.3.1/hash_print.c"
static unsigned int const   other_flags[6]  = {      (unsigned int const   )1048576,      (unsigned int const   )1048576,      (unsigned int const   )268435458,      (unsigned int const   )268435459, 
        (unsigned int const   )268435460,      (unsigned int const   )268435461};
#line 202 "/home/june/repo/benchmarks/collector/temp/rhash-1.3.1/hash_print.c"
static print_item *parse_percent_item(char const   **str ) 
{ 
  char const   *format ;
  char const   *p ;
  unsigned int hash_id ;
  unsigned int modifier_flags ;
  int id_found ;
  int width ;
  int pad_with_zero_bit ;
  print_item *item ;
  unsigned short const   **tmp ;
  char const   *p___0 ;
  unsigned short const   **tmp___0 ;
  int tmp___1 ;
  char upper ;
  int tmp___2 ;
  int tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;

  {
#line 204
  format = *str;
#line 205
  p = (char const   *)((void *)0);
#line 206
  hash_id = 0U;
#line 207
  modifier_flags = 0U;
#line 208
  id_found = 0;
#line 209
  width = 0;
#line 210
  pad_with_zero_bit = 0;
#line 211
  item = (print_item *)((void *)0);
#line 224
  if ((int const   )*format == 48) {
#line 225
    pad_with_zero_bit = 67108864;
#line 226
    format ++;
  }
#line 230
  if ((int const   )*format == 120) {
#line 231
    modifier_flags |= 8388608U;
#line 232
    format ++;
  } else
#line 233
  if ((int const   )*format == 98) {
#line 234
    modifier_flags |= 16777216U;
#line 235
    format ++;
  } else
#line 236
  if ((int const   )*format == 66) {
#line 237
    modifier_flags |= 33554432U;
#line 238
    format ++;
  } else
#line 239
  if ((int const   )*format == 64) {
#line 240
    modifier_flags |= 4194304U;
#line 241
    format ++;
  }
  {
#line 243
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 243
    tmp = __ctype_b_loc();
    }
#line 243
    if (! ((int const   )*(*tmp + (int )((unsigned char )*format)) & 2048)) {
#line 243
      goto while_break;
    }
#line 243
    width = 10 * width + (int )((int const   )*format - 48);
#line 243
    format ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 245
  if ((int const   )*format == 123) {
#line 247
    format ++;
#line 247
    p___0 = format;
    {
#line 248
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 248
      tmp___0 = __ctype_b_loc();
      }
#line 248
      if (! ((int const   )*(*tmp___0 + (int )((unsigned char )*p___0)) & 8)) {
#line 248
        if (! ((int const   )*p___0 == 45)) {
#line 248
          goto while_break___0;
        }
      }
#line 248
      p___0 ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 249
    if ((int const   )*p___0 == 125) {
      {
#line 250
      hash_id = printf_name_to_id(format, (size_t )((int )(p___0 - format)), & modifier_flags);
#line 251
      format --;
      }
#line 252
      if (hash_id) {
#line 252
        goto _L;
      } else
#line 252
      if (modifier_flags == 268435460U) {
#line 252
        goto _L;
      } else
#line 252
      if (modifier_flags == 268435462U) {
        _L: /* CIL Label */ 
#line 254
        if ((int const   )*(format + 1) & 32) {
#line 254
          tmp___1 = 0;
        } else {
#line 254
          tmp___1 = 2097152;
        }
#line 254
        modifier_flags |= (unsigned int )tmp___1;
#line 255
        format = p___0;
#line 256
        id_found = 1;
      }
    } else {
#line 258
      format --;
    }
  }
#line 261
  if (! id_found) {
#line 262
    upper = (char )((int const   )*format & -33);
#line 263
    if ((int const   )*format == 0) {
#line 263
      return ((print_item *)((void *)0));
    }
    {
#line 264
    tmp___5 = strchr(short_hash, (int )upper);
#line 264
    p = (char const   *)tmp___5;
    }
#line 264
    if (p) {
#line 266
      hash_id = (unsigned int )hash_ids[p - short_hash];
#line 267
      if ((int const   )*format & 32) {
#line 267
        tmp___2 = 0;
      } else {
#line 267
        tmp___2 = 2097152;
      }
#line 267
      modifier_flags |= (unsigned int )tmp___2;
    } else {
      {
#line 268
      tmp___4 = strchr(short_other, (int )*format);
#line 268
      p = (char const   *)tmp___4;
      }
#line 268
      if (p) {
#line 270
        modifier_flags = (unsigned int )other_flags[p - short_other];
#line 272
        if (modifier_flags == 1048576U) {
#line 273
          if ((int const   )*p & 32) {
#line 273
            tmp___3 = 0;
          } else {
#line 273
            tmp___3 = 2097152;
          }
#line 273
          modifier_flags |= (unsigned int )tmp___3;
#line 274
          hash_id = 384U;
        }
      } else {
#line 277
        return ((print_item *)0);
      }
    }
  }
  {
#line 280
  modifier_flags |= (unsigned int )pad_with_zero_bit;
#line 282
  item = new_print_item(modifier_flags, hash_id, (char const   *)((void *)0));
#line 283
  item->width = (unsigned int )width;
#line 284
  format ++;
#line 284
  *str = format;
  }
#line 285
  return (item);
}
}
#line 296 "/home/june/repo/benchmarks/collector/temp/rhash-1.3.1/hash_print.c"
static void fprint_ed2k_url(FILE *out , struct file_info *info , int print_type ) 
{ 
  char const   *filename ;
  char const   *tmp ;
  char const   *tmp___0 ;
  int upper_case ;
  int tmp___1 ;
  int len ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  char *buf ;
  void *tmp___5 ;
  char *dst ;
  int tmp___6 ;
  char *tmp___7 ;
  size_t tmp___8 ;
  char *tmp___9 ;

  {
  {
#line 298
  tmp = file_info_get_utf8_print_path(info);
#line 298
  tmp___0 = get_basename(tmp);
#line 298
  filename = tmp___0;
  }
#line 299
  if (print_type & 2097152) {
#line 299
    tmp___1 = 8;
  } else {
#line 299
    tmp___1 = 0;
  }
  {
#line 299
  upper_case = tmp___1;
#line 300
  tmp___2 = urlencode((char *)((void *)0), filename);
#line 300
  tmp___3 = int_len(info->size);
  }
#line 300
  if (info->sums_flags & 256U) {
#line 300
    tmp___4 = 84;
  } else {
#line 300
    tmp___4 = 49;
  }
  {
#line 300
  len = (tmp___2 + tmp___3) + tmp___4;
#line 301
  tmp___5 = rhash_malloc((size_t )(len + 1), "/home/june/repo/benchmarks/collector/temp/rhash-1.3.1/hash_print.c",
                         301);
#line 301
  buf = (char *)tmp___5;
#line 302
  dst = buf;
#line 307
  strcpy((char */* __restrict  */)dst, (char const   */* __restrict  */)"ed2k://|file|");
#line 308
  dst += 13;
#line 309
  tmp___6 = urlencode(dst, filename);
#line 309
  dst += tmp___6;
#line 310
  tmp___7 = dst;
#line 310
  dst ++;
#line 310
  *tmp___7 = (char )'|';
#line 311
  sprintI64(dst, info->size, 0);
#line 312
  tmp___8 = strlen((char const   *)dst);
#line 312
  dst += tmp___8;
#line 313
  tmp___9 = dst;
#line 313
  dst ++;
#line 313
  *tmp___9 = (char )'|';
#line 314
  rhash_print(dst, info->rctx, 128U, upper_case);
#line 315
  dst += 32;
  }
#line 316
  if ((info->sums_flags & 256U) != 0U) {
    {
#line 317
    strcpy((char */* __restrict  */)dst, (char const   */* __restrict  */)"|h=");
#line 318
    dst += 3;
#line 318
    rhash_print(dst, info->rctx, 256U, 3 | upper_case);
#line 319
    dst += 32;
    }
  }
  {
#line 321
  strcpy((char */* __restrict  */)dst, (char const   */* __restrict  */)"|/");
#line 322
  fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)"%s", buf);
#line 323
  free((void *)buf);
  }
#line 324
  return;
}
}
#line 334 "/home/june/repo/benchmarks/collector/temp/rhash-1.3.1/hash_print.c"
static void fprintI64(FILE *out , uint64_t filesize , int width , int zero_pad ) 
{ 
  char *buf ;
  int tmp ;
  void *tmp___0 ;
  int len ;
  int tmp___1 ;

  {
#line 336
  if (width > 40) {
#line 336
    tmp = width + 1;
  } else {
#line 336
    tmp = 41;
  }
  {
#line 336
  tmp___0 = rhash_malloc((size_t )tmp, "/home/june/repo/benchmarks/collector/temp/rhash-1.3.1/hash_print.c",
                         336);
#line 336
  buf = (char *)tmp___0;
#line 337
  tmp___1 = int_len(filesize);
#line 337
  len = tmp___1;
#line 338
  sprintI64(buf, filesize, width);
  }
#line 339
  if (len < width) {
#line 339
    if (zero_pad) {
      {
#line 340
      memset((void *)buf, '0', (size_t )(width - len));
      }
    }
  }
  {
#line 342
  fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)"%s", buf);
#line 343
  free((void *)buf);
  }
#line 344
  return;
}
}
#line 353 "/home/june/repo/benchmarks/collector/temp/rhash-1.3.1/hash_print.c"
void print_line(FILE *out , print_item *list , struct file_info *info ) 
{ 
  char const   *basename ;
  char const   *tmp ;
  char const   *tmp___0 ;
  char *url ;
  char *ed2k_url ;
  char buffer[130] ;
  int print_type ;
  size_t len ;
  unsigned int hash_id ;
  int print_flags ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  size_t tmp___6 ;
  char const   *tmp___7 ;
  int tmp___8 ;
  void *tmp___9 ;

  {
  {
#line 355
  tmp = get_basename(info->print_path);
#line 355
  basename = tmp;
#line 356
  url = (char *)((void *)0);
#line 356
  ed2k_url = (char *)((void *)0);
  }
  {
#line 359
  while (1) {
    while_continue: /* CIL Label */ ;
#line 359
    if (! list) {
#line 359
      goto while_break;
    }
#line 360
    print_type = (int )(list->flags & 4162846719U);
#line 364
    if (list->hash_id) {
#line 364
      if (print_type != 1048576) {
#line 365
        hash_id = list->hash_id;
#line 366
        if (list->flags & 2097152U) {
#line 366
          tmp___1 = 8;
        } else {
#line 366
          tmp___1 = 0;
        }
#line 366
        if (list->flags & 4194304U) {
#line 366
          tmp___2 = 1;
        } else {
#line 366
          tmp___2 = 0;
        }
#line 366
        if (list->flags & 16777216U) {
#line 366
          tmp___3 = 3;
        } else {
#line 366
          tmp___3 = 0;
        }
#line 366
        if (list->flags & 33554432U) {
#line 366
          tmp___4 = 4;
        } else {
#line 366
          tmp___4 = 0;
        }
#line 366
        if (list->flags & 8388608U) {
#line 366
          tmp___5 = 2;
        } else {
#line 366
          tmp___5 = 0;
        }
#line 366
        print_flags = (((tmp___1 | tmp___2) | tmp___3) | tmp___4) | tmp___5;
#line 371
        if (hash_id == 2048U) {
#line 371
          goto _L;
        } else
#line 371
        if (hash_id == 4096U) {
          _L: /* CIL Label */ 
#line 371
          if (opt.flags & 32768U) {
#line 372
            print_flags |= 16;
          }
        }
        {
#line 374
        len = rhash_print(buffer, info->rctx, hash_id, print_flags);
#line 378
        tmp___6 = fwrite((void const   */* __restrict  */)(buffer), (size_t )1, len,
                         (FILE */* __restrict  */)out);
        }
#line 378
        if (tmp___6 != len) {
#line 378
          goto while_break;
        }
#line 379
        goto __Cont;
      }
    }
    {
#line 384
    if (print_type == 268435456) {
#line 384
      goto case_268435456;
    }
#line 387
    if (print_type == 268435457) {
#line 387
      goto case_268435457;
    }
#line 390
    if (print_type == 268435458) {
#line 390
      goto case_268435458;
    }
#line 393
    if (print_type == 268435459) {
#line 393
      goto case_268435459;
    }
#line 396
    if (print_type == 268435460) {
#line 396
      goto case_268435460;
    }
#line 404
    if (print_type == 268435462) {
#line 404
      goto case_268435462;
    }
#line 407
    if (print_type == 268435461) {
#line 407
      goto case_268435461;
    }
#line 410
    if (print_type == 1048576) {
#line 410
      goto case_1048576;
    }
#line 383
    goto switch_break;
    case_268435456: /* CIL Label */ 
    {
#line 385
    fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)"%s", list->data);
    }
#line 386
    goto switch_break;
    case_268435457: /* CIL Label */ 
    {
#line 388
    fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)"%c", 0);
    }
#line 389
    goto switch_break;
    case_268435458: /* CIL Label */ 
    {
#line 391
    fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)"%s", info->print_path);
    }
#line 392
    goto switch_break;
    case_268435459: /* CIL Label */ 
    {
#line 394
    fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)"%s", basename);
    }
#line 395
    goto switch_break;
    case_268435460: /* CIL Label */ 
#line 397
    if (! url) {
      {
#line 398
      tmp___7 = file_info_get_utf8_print_path(info);
#line 398
      tmp___0 = get_basename(tmp___7);
#line 399
      tmp___8 = urlencode((char *)((void *)0), tmp___0);
#line 399
      tmp___9 = rhash_malloc((size_t )(tmp___8 + 1), "/home/june/repo/benchmarks/collector/temp/rhash-1.3.1/hash_print.c",
                             399);
#line 399
      url = (char *)tmp___9;
#line 400
      urlencode(url, tmp___0);
      }
    }
    {
#line 402
    fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)"%s", url);
    }
#line 403
    goto switch_break;
    case_268435462: /* CIL Label */ 
    {
#line 405
    print_time64(out, (info->file)->mtime);
    }
#line 406
    goto switch_break;
    case_268435461: /* CIL Label */ 
    {
#line 408
    fprintI64(out, info->size, (int )list->width, (int )(list->flags & 67108864U));
    }
#line 409
    goto switch_break;
    case_1048576: /* CIL Label */ 
    {
#line 411
    fprint_ed2k_url(out, info, (int )list->flags);
    }
#line 412
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
    __Cont: /* CIL Label */ 
#line 359
    list = list->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 415
  free((void *)url);
#line 416
  free((void *)ed2k_url);
  }
#line 417
  return;
}
}
#line 424 "/home/june/repo/benchmarks/collector/temp/rhash-1.3.1/hash_print.c"
void free_print_list(print_item *list ) 
{ 
  print_item *next ;

  {
  {
#line 426
  while (1) {
    while_continue: /* CIL Label */ ;
#line 426
    if (! list) {
#line 426
      goto while_break;
    }
    {
#line 427
    next = list->next;
#line 428
    free((void *)((char *)list->data));
#line 429
    free((void *)list);
#line 430
    list = next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 432
  return;
}
}
#line 438 "/home/june/repo/benchmarks/collector/temp/rhash-1.3.1/hash_print.c"
void init_hash_info_table(void) 
{ 
  unsigned int index___0 ;
  unsigned int bit ;
  unsigned int short_opt_mask ;
  char *short_opt ;
  print_hash_info *info ;
  unsigned int fullmask ;
  char const   *p ;
  char *e ;
  char *d ;
  char *tmp ;
  char const   *tmp___0 ;
  char *tmp___1 ;

  {
  {
#line 441
  short_opt_mask = 268439469U;
#line 443
  short_opt = (char *)"cmhteawrgl";
#line 444
  info = hash_info_table;
#line 445
  fullmask = 335544319U;
#line 447
  memset((void *)(hash_info_table), 0, sizeof(hash_info_table));
#line 449
  index___0 = 0U;
#line 449
  bit = 1U;
  }
  {
#line 449
  while (1) {
    while_continue: /* CIL Label */ ;
#line 449
    if (! (bit <= fullmask)) {
#line 449
      goto while_break;
    }
#line 453
    if ((bit & short_opt_mask) != 0U) {
#line 453
      if (*short_opt) {
#line 453
        tmp = short_opt;
#line 453
        short_opt ++;
#line 453
        info->short_char = *tmp;
      } else {
#line 453
        info->short_char = (char)0;
      }
    } else {
#line 453
      info->short_char = (char)0;
    }
#line 456
    if (bit & 67108863U) {
      {
#line 456
      tmp___0 = rhash_get_name(bit);
#line 456
      info->name = tmp___0;
      }
    } else {
#line 456
      info->name = "ED2K_LINK";
    }
#line 457
    d = info->short_name;
#line 458
    e = info->short_name + 15;
#line 460
    p = info->name;
    {
#line 460
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 460
      if (*p) {
#line 460
        if (! ((unsigned long )d < (unsigned long )e)) {
#line 460
          goto while_break___0;
        }
      } else {
#line 460
        goto while_break___0;
      }
#line 460
      if ((int const   )*p != 45) {
#line 460
        tmp___1 = d;
#line 460
        d ++;
#line 460
        *tmp___1 = (char )((int const   )*p | 32);
      } else
#line 460
      if ((int const   )*(p + 1) >= 57) {
#line 460
        tmp___1 = d;
#line 460
        d ++;
#line 460
        *tmp___1 = (char )((int const   )*p | 32);
      }
#line 460
      p ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 461
    *d = (char)0;
#line 449
    index___0 ++;
#line 449
    bit <<= 1;
#line 449
    info ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 463
  return;
}
}
#line 472 "/home/june/repo/benchmarks/collector/temp/rhash-1.3.1/hash_print.c"
void init_printf_format(struct strbuf_t *out ) 
{ 
  char const   *fmt ;
  char const   *tail ;
  unsigned int bit ;
  unsigned int index___0 ;
  int uppercase ;
  char up_flag ;
  unsigned int force_base32_mask ;
  int tmp ;
  char const   *p ;
  print_hash_info *info ;
  int i ;
  size_t tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  size_t tmp___5 ;
  char *letter ;
  size_t tmp___6 ;
  size_t tmp___7 ;
  char const   *tmp___8 ;
  size_t tmp___9 ;
  size_t tmp___10 ;

  {
#line 474
  tail = (char const   *)0;
#line 475
  index___0 = 0U;
#line 478
  force_base32_mask = 0U;
#line 480
  if (! opt.fmt) {
#line 482
    if (opt.sum_flags == 1U) {
#line 482
      opt.fmt = 2U;
    } else
#line 482
    if (! opt.sum_flags) {
#line 482
      opt.fmt = 2U;
    } else {
#line 482
      opt.fmt = 4U;
    }
  }
#line 484
  if (opt.flags & 8192U) {
#line 484
    tmp = 1;
  } else
#line 484
  if (! (opt.flags & 16384U)) {
#line 484
    if (opt.fmt & 2U) {
#line 484
      tmp = 1;
    } else {
#line 484
      tmp = 0;
    }
  } else {
#line 484
    tmp = 0;
  }
#line 484
  uppercase = tmp;
#line 486
  if (uppercase) {
#line 486
    up_flag = (char )(~ 32);
  } else {
#line 486
    up_flag = (char)-1;
  }
  {
#line 488
  rsh_str_ensure_size(out, (size_t )1024);
  }
#line 490
  if (opt.sum_flags & 268435456U) {
    {
#line 491
    rsh_str_append_n(out, "%l", (size_t )2);
#line 492
    *(out->str + 1) = (char )((int )*(out->str + 1) & (int )up_flag);
    }
#line 493
    return;
  }
#line 496
  if (opt.sum_flags == 0U) {
#line 496
    return;
  }
#line 498
  if (opt.fmt == 1U) {
#line 499
    fmt = "\003(%p) = \001\\n";
  } else
#line 500
  if (opt.fmt == 8U) {
    {
#line 501
    rsh_str_append(out, "magnet:?xl=%s&dn=%{urlname}");
#line 502
    fmt = "&xt=urn:\002:\001";
#line 503
    force_base32_mask = 72U;
#line 504
    tail = "\\n";
    }
  } else
#line 505
  if (opt.fmt == 4U) {
#line 505
    if (0U == (opt.sum_flags & (opt.sum_flags - 1U))) {
#line 506
      fmt = "\001  %p\\n";
    } else {
#line 505
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
    {
#line 508
    rsh_str_append_n(out, "%p", (size_t )2);
    }
#line 509
    if (opt.fmt == 2U) {
#line 509
      fmt = " \001";
    } else {
#line 509
      fmt = "  \001";
    }
#line 510
    tail = "\\n";
  }
#line 514
  bit = (unsigned int )(1 << index___0);
  {
#line 514
  while (1) {
    while_continue: /* CIL Label */ ;
#line 514
    if (! (bit <= opt.sum_flags)) {
#line 514
      goto while_break;
    }
#line 518
    if ((bit & opt.sum_flags) == 0U) {
#line 518
      goto __Cont;
    }
    {
#line 519
    p = fmt;
#line 520
    info = & hash_info_table[index___0];
#line 523
    rsh_str_ensure_size(out, out->len + 256UL);
    }
    {
#line 525
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 527
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 527
        if (! ((int const   )*p >= 32)) {
#line 527
          goto while_break___1;
        }
#line 527
        tmp___0 = out->len;
#line 527
        (out->len) ++;
#line 527
        tmp___1 = p;
#line 527
        p ++;
#line 527
        *(out->str + tmp___0) = (char )*tmp___1;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 528
      if ((int const   )*p == 0) {
#line 528
        goto while_break___0;
      }
#line 529
      tmp___2 = p;
#line 529
      p ++;
      {
#line 530
      if ((int )*tmp___2 == 1) {
#line 530
        goto case_1;
      }
#line 545
      if ((int )*tmp___2 == 2) {
#line 545
        goto case_2;
      }
#line 548
      if ((int )*tmp___2 == 3) {
#line 548
        goto case_3;
      }
#line 529
      goto switch_break;
      case_1: /* CIL Label */ 
#line 531
      tmp___3 = out->len;
#line 531
      (out->len) ++;
#line 531
      *(out->str + tmp___3) = (char )'%';
#line 532
      if ((bit & force_base32_mask) != 0U) {
#line 533
        tmp___4 = out->len;
#line 533
        (out->len) ++;
#line 533
        *(out->str + tmp___4) = (char )'b';
      }
#line 535
      if (info->short_char) {
#line 535
        tmp___5 = out->len;
#line 535
        (out->len) ++;
#line 535
        *(out->str + tmp___5) = (char )((int )info->short_char & (int )up_flag);
      } else {
        {
#line 538
        tmp___6 = out->len;
#line 538
        (out->len) ++;
#line 538
        *(out->str + tmp___6) = (char )'{';
#line 539
        letter = out->str + out->len;
#line 540
        rsh_str_append(out, (char const   *)(info->short_name));
#line 541
        *letter = (char )((int )*letter & (int )up_flag);
#line 542
        tmp___7 = out->len;
#line 542
        (out->len) ++;
#line 542
        *(out->str + tmp___7) = (char )'}';
        }
      }
#line 544
      goto switch_break;
      case_2: /* CIL Label */ 
      {
#line 546
      tmp___8 = rhash_get_magnet_name(bit);
#line 546
      rsh_str_append(out, tmp___8);
      }
#line 547
      goto switch_break;
      case_3: /* CIL Label */ 
      {
#line 549
      rsh_str_append(out, info->name);
#line 550
      tmp___9 = strlen(info->name);
#line 550
      i = (int )tmp___9;
      }
#line 551
      if (i < 5) {
#line 551
        i = 6 - i;
      } else {
#line 551
        i = 1;
      }
      {
#line 551
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 551
        if (! (i > 0)) {
#line 551
          goto while_break___2;
        }
#line 551
        tmp___10 = out->len;
#line 551
        (out->len) ++;
#line 551
        *(out->str + tmp___10) = (char )' ';
#line 551
        i --;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 552
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    __Cont: /* CIL Label */ 
#line 514
    bit <<= 1;
#line 514
    index___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 556
  if (tail) {
    {
#line 557
    rsh_str_append(out, tail);
    }
  }
#line 559
  *(out->str + out->len) = (char )'\000';
#line 560
  return;
}
}
#line 435 "/usr/include/libio.h"
extern int _IO_putc(int __c , _IO_FILE *__fp ) ;
#line 779 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) isatty)(int __fd ) ;
#line 125 "/home/june/repo/benchmarks/collector/temp/rhash-1.3.1/librhash/rhash.h"
extern int rhash_get_digest_size(unsigned int hash_id ) ;
#line 31 "/home/june/repo/benchmarks/collector/temp/rhash-1.3.1/output.h"
void setup_output(void) ;
#line 33 "/home/june/repo/benchmarks/collector/temp/rhash-1.3.1/output.c"
struct percents_output_info_t *percents_output  =    (struct percents_output_info_t *)((void *)0);
#line 41 "/home/june/repo/benchmarks/collector/temp/rhash-1.3.1/output.c"
static void log_va_msg(char const   *format , va_list args ) 
{ 


  {
  {
#line 43
  vfprintf((FILE */* __restrict  */)rhash_data.log, (char const   */* __restrict  */)format,
           args);
#line 44
  fflush(rhash_data.log);
  }
#line 45
  return;
}
}
#line 52 "/home/june/repo/benchmarks/collector/temp/rhash-1.3.1/output.c"
void log_msg(char const   *format  , ...) 
{ 
  va_list ap ;

  {
  {
#line 55
  __builtin_va_start(ap, format);
#line 56
  log_va_msg(format, ap);
  }
#line 57
  return;
}
}
#line 64 "/home/june/repo/benchmarks/collector/temp/rhash-1.3.1/output.c"
void log_error(char const   *format  , ...) 
{ 
  va_list ap ;

  {
  {
#line 67
  __builtin_va_start(ap, format);
#line 68
  fprintf((FILE */* __restrict  */)rhash_data.log, (char const   */* __restrict  */)"%s: ",
          "RHash");
#line 69
  log_va_msg(format, ap);
  }
#line 70
  return;
}
}
#line 77 "/home/june/repo/benchmarks/collector/temp/rhash-1.3.1/output.c"
void log_warning(char const   *format  , ...) 
{ 
  va_list ap ;

  {
  {
#line 80
  __builtin_va_start(ap, format);
#line 81
  fprintf((FILE */* __restrict  */)rhash_data.log, (char const   */* __restrict  */)"%s: ",
          "RHash");
#line 82
  log_va_msg(format, ap);
  }
#line 83
  return;
}
}
#line 90 "/home/june/repo/benchmarks/collector/temp/rhash-1.3.1/output.c"
void log_file_error(char const   *filepath ) 
{ 
  int *tmp ;
  char *tmp___0 ;

  {
#line 92
  if (! filepath) {
#line 92
    filepath = "(null)";
  }
  {
#line 93
  tmp = __errno_location();
#line 93
  tmp___0 = strerror(*tmp);
#line 93
  log_error("%s: %s\n", filepath, tmp___0);
  }
#line 94
  return;
}
}
#line 100 "/home/june/repo/benchmarks/collector/temp/rhash-1.3.1/output.c"
void report_interrupted(void) 
{ 


  {
  {
#line 103
  rhash_data.interrupted = 2;
#line 104
  log_msg("Interrupted by user...\n");
  }
#line 105
  return;
}
}
#line 123 "/home/june/repo/benchmarks/collector/temp/rhash-1.3.1/output.c"
static struct percents_t percents  ;
#line 133 "/home/june/repo/benchmarks/collector/temp/rhash-1.3.1/output.c"
static void print_verbose_error(struct file_info *info ) 
{ 
  char actual[130] ;
  char expected[130] ;
  int i ;
  unsigned int reported ;
  hash_value *hv ;
  char *expected_hash ;
  unsigned int hid ;
  int pflags ;
  int tmp___0 ;
  char const   *tmp___1 ;

  {
  {
#line 138
  fprintf((FILE */* __restrict  */)rhash_data.out, (char const   */* __restrict  */)"ERROR");
  }
#line 140
  if (4U & info->hc.flags) {
    {
#line 141
    sprintI64(actual, (uint64_t )(info->rctx)->msg_size, 0);
#line 142
    sprintI64(expected, info->hc.file_size, 0);
#line 143
    fprintf((FILE */* __restrict  */)rhash_data.out, (char const   */* __restrict  */)", size is %s should be %s",
            actual, expected);
    }
  }
#line 146
  if (8U & info->hc.flags) {
    {
#line 147
    rhash_print(expected, info->rctx, 1U, 8);
#line 148
    fprintf((FILE */* __restrict  */)rhash_data.out, (char const   */* __restrict  */)", embedded CRC32 should be %s",
            expected);
    }
  }
#line 151
  if (16U & info->hc.flags) {
#line 153
    reported = 0U;
#line 154
    i = 0;
    {
#line 154
    while (1) {
      while_continue: /* CIL Label */ ;
#line 154
      if (! (i < info->hc.hashes_num)) {
#line 154
        goto while_break;
      }
#line 155
      hv = & info->hc.hashes[i];
#line 156
      expected_hash = info->hc.data + (int )hv->offset;
#line 157
      hid = hv->hash_id;
#line 159
      if ((info->hc.wrong_hashes & (unsigned int )(1 << i)) == 0U) {
#line 159
        goto __Cont;
      }
#line 164
      if ((hid & (hid - 1U)) != 0U) {
#line 166
        if (hid & opt.sum_flags) {
#line 166
          hid &= opt.sum_flags;
        }
#line 167
        if (hid & ~ info->hc.found_hash_ids) {
#line 167
          hid &= ~ info->hc.found_hash_ids;
        }
#line 168
        if (hid & ~ reported) {
#line 168
          hid &= ~ reported;
        }
#line 169
        if (hid & 655364U) {
#line 169
          hid &= 655364U;
        }
#line 170
        hid &= (unsigned int )(- ((int )hid));
      }
      {
#line 173
      reported |= hid;
#line 175
      tmp___0 = rhash_get_digest_size(hid);
      }
#line 175
      if ((int )hv->length == tmp___0 * 2) {
#line 175
        pflags = 10;
      } else {
#line 175
        pflags = 11;
      }
      {
#line 177
      rhash_print(actual, info->rctx, hid, pflags);
#line 178
      tmp___1 = rhash_get_name(hid);
#line 178
      fprintf((FILE */* __restrict  */)rhash_data.out, (char const   */* __restrict  */)", %s is %s should be %s",
              tmp___1, actual, expected_hash);
      }
      __Cont: /* CIL Label */ 
#line 154
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 183
  fprintf((FILE */* __restrict  */)rhash_data.out, (char const   */* __restrict  */)"\n");
  }
#line 184
  return;
}
}
#line 195 "/home/june/repo/benchmarks/collector/temp/rhash-1.3.1/output.c"
static void print_check_result(struct file_info *info , int print_name , int print_result ) 
{ 
  int *tmp ;
  char *tmp___0 ;
  char const   *tmp___1 ;

  {
#line 197
  if (print_name) {
    {
#line 198
    fprintf((FILE */* __restrict  */)rhash_data.out, (char const   */* __restrict  */)"%-51s ",
            info->print_path);
    }
  }
#line 200
  if (print_result) {
#line 201
    if (info->error == -1) {
      {
#line 203
      tmp = __errno_location();
#line 203
      tmp___0 = strerror(*tmp);
#line 203
      fprintf((FILE */* __restrict  */)rhash_data.out, (char const   */* __restrict  */)"%s\n",
              tmp___0);
      }
    } else
#line 204
    if (! (info->hc.flags & 28U)) {
#line 204
      goto _L;
    } else
#line 204
    if (! (opt.flags & 512U)) {
      _L: /* CIL Label */ 
#line 206
      if (! (info->hc.flags & 28U)) {
#line 206
        tmp___1 = "OK \n";
      } else {
#line 206
        tmp___1 = "ERR\n";
      }
      {
#line 206
      fprintf((FILE */* __restrict  */)rhash_data.out, (char const   */* __restrict  */)tmp___1);
      }
    } else {
      {
#line 210
      print_verbose_error(info);
      }
    }
  }
  {
#line 213
  fflush(rhash_data.out);
  }
#line 214
  return;
}
}
#line 223 "/home/june/repo/benchmarks/collector/temp/rhash-1.3.1/output.c"
static void print_results_on_check(struct file_info *info , int init ) 
{ 
  int print_name ;
  int tmp ;
  int *tmp___0 ;

  {
#line 225
  if (opt.mode & 3U) {
#line 226
    if (opt.flags & 1152U) {
#line 226
      tmp = ! init;
    } else {
#line 226
      tmp = init;
    }
#line 226
    print_name = tmp;
#line 228
    if (! init) {
#line 228
      if (opt.flags & 128U) {
        {
#line 228
        tmp___0 = __errno_location();
        }
#line 228
        if (*tmp___0 == 0) {
#line 228
          if (! (info->hc.flags & 28U)) {
#line 229
            return;
          }
        }
      }
    }
    {
#line 232
    print_check_result(info, print_name, ! init);
    }
  }
#line 234
  return;
}
}
#line 245 "/home/june/repo/benchmarks/collector/temp/rhash-1.3.1/output.c"
static int dummy_init_percents(struct file_info *info ) 
{ 


  {
  {
#line 247
  print_results_on_check(info, 1);
  }
#line 248
  return (1);
}
}
#line 258 "/home/june/repo/benchmarks/collector/temp/rhash-1.3.1/output.c"
static void dummy_finish_percents(struct file_info *info , int process_res ) 
{ 


  {
  {
#line 260
  info->error = process_res;
#line 261
  print_results_on_check(info, 0);
  }
#line 262
  return;
}
}
#line 272 "/home/june/repo/benchmarks/collector/temp/rhash-1.3.1/output.c"
static int dots_init_percents(struct file_info *info ) 
{ 


  {
  {
#line 275
  fflush(rhash_data.out);
#line 276
  fflush(rhash_data.log);
#line 277
  percents.points = 0;
#line 278
  print_results_on_check(info, 1);
  }
#line 279
  return (1);
}
}
#line 289 "/home/june/repo/benchmarks/collector/temp/rhash-1.3.1/output.c"
static void dots_finish_percents(struct file_info *info , int process_res ) 
{ 
  char buf[80] ;
  char *tmp ;

  {
#line 292
  info->error = process_res;
#line 294
  if (percents.points % 74 != 0) {
    {
#line 295
    tmp = str_set(buf, ' ', 74 - percents.points % 74);
#line 295
    log_msg("%s 100%%\n", tmp);
    }
  }
  {
#line 297
  print_results_on_check(info, 0);
  }
#line 298
  return;
}
}
#line 306 "/home/june/repo/benchmarks/collector/temp/rhash-1.3.1/output.c"
static void dots_update_percents(struct file_info *info , uint64_t offset ) 
{ 
  int pt_size ;
  int perc ;

  {
#line 308
  pt_size = 1048576;
#line 309
  offset -= info->msg_offset;
#line 310
  if (offset % (unsigned long )pt_size != 0UL) {
#line 310
    return;
  }
#line 312
  if (percents.points == 0) {
#line 313
    if (opt.mode & 3U) {
      {
#line 314
      fprintf((FILE */* __restrict  */)rhash_data.log, (char const   */* __restrict  */)"\nChecking %s\n",
              info->print_path);
      }
    } else {
      {
#line 316
      fprintf((FILE */* __restrict  */)rhash_data.log, (char const   */* __restrict  */)"\nProcessing %s\n",
              info->print_path);
      }
    }
    {
#line 318
    fflush(rhash_data.log);
    }
  }
  {
#line 320
  _IO_putc('.', rhash_data.log);
#line 322
  (percents.points) ++;
  }
#line 322
  if (percents.points % 74 == 0) {
#line 323
    if (info->size > 0UL) {
      {
#line 324
      perc = (int )(((double )offset * 100.0) / (double )info->size + 0.5);
#line 325
      fprintf((FILE */* __restrict  */)rhash_data.log, (char const   */* __restrict  */)"  %2u%%\n",
              perc);
#line 326
      fflush(rhash_data.log);
      }
    } else {
      {
#line 328
      _IO_putc('\n', rhash_data.log);
      }
    }
  }
#line 331
  return;
}
}
#line 341 "/home/june/repo/benchmarks/collector/temp/rhash-1.3.1/output.c"
static int p_init_percents(struct file_info *info ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  {
#line 349
  percents.points = 0;
#line 350
  percents.same_output = 0;
#line 351
  percents.use_cursor = 0;
#line 353
  fflush(rhash_data.out);
#line 354
  fflush(rhash_data.log);
#line 358
  fprintf((FILE */* __restrict  */)rhash_data.log, (char const   */* __restrict  */)"%-51s ",
          info->print_path);
  }
#line 375
  if ((unsigned long )rhash_data.out == (unsigned long )stdout) {
    {
#line 375
    tmp = isatty(0);
    }
#line 375
    if (tmp) {
#line 375
      tmp___0 = 1;
    } else {
#line 375
      tmp___0 = 0;
    }
  } else {
#line 375
    tmp___0 = 0;
  }
  {
#line 375
  percents.same_output = tmp___0;
#line 376
  percents.ticks = rhash_get_ticks();
  }
#line 377
  return (1);
}
}
#line 390
static void p_update_percents(struct file_info *info , uint64_t offset ) ;
#line 390 "/home/june/repo/benchmarks/collector/temp/rhash-1.3.1/output.c"
static char const   rot[4]  = {      (char const   )'-',      (char const   )'\\',      (char const   )'|',      (char const   )'/'};
#line 388 "/home/june/repo/benchmarks/collector/temp/rhash-1.3.1/output.c"
static void p_update_percents(struct file_info *info , uint64_t offset ) 
{ 
  int perc ;
  unsigned int ticks ;
  int tmp ;

  {
#line 391
  perc = 0;
#line 399
  if (info->size > 0UL) {
#line 400
    offset -= info->msg_offset;
#line 402
    perc = (int )(((double )offset * 99.9) / (double )info->size);
#line 403
    if (percents.points == perc) {
#line 403
      return;
    }
  }
  {
#line 407
  ticks = rhash_get_ticks();
  }
#line 408
  if (ticks - percents.ticks < 50U) {
#line 408
    return;
  }
#line 411
  if (info->size > 0UL) {
    {
#line 412
    fprintf((FILE */* __restrict  */)rhash_data.log, (char const   */* __restrict  */)"%u%%",
            perc);
#line 413
    percents.points = perc;
    }
  } else {
    {
#line 415
    tmp = percents.points;
#line 415
    (percents.points) ++;
#line 415
    fprintf((FILE */* __restrict  */)rhash_data.log, (char const   */* __restrict  */)"%c",
            (int const   )rot[tmp & 3]);
    }
  }
  {
#line 429
  fprintf((FILE */* __restrict  */)rhash_data.log, (char const   */* __restrict  */)"\r%-51s ",
          info->print_path);
#line 430
  fflush(rhash_data.log);
#line 432
  percents.ticks = ticks;
  }
#line 433
  return;
}
}
#line 442 "/home/june/repo/benchmarks/collector/temp/rhash-1.3.1/output.c"
static void p_finish_percents(struct file_info *info , int process_res ) 
{ 
  int need_check_result ;
  int *tmp ;
  int tmp___0 ;

  {
#line 450
  if (opt.mode & 3U) {
#line 450
    if (opt.flags & 128U) {
      {
#line 450
      tmp = __errno_location();
      }
#line 450
      if (*tmp == 0) {
#line 450
        if (! (info->hc.flags & 28U)) {
#line 450
          tmp___0 = 0;
        } else {
#line 450
          tmp___0 = 1;
        }
      } else {
#line 450
        tmp___0 = 1;
      }
    } else {
#line 450
      tmp___0 = 1;
    }
  } else {
#line 450
    tmp___0 = 0;
  }
#line 450
  need_check_result = tmp___0;
#line 452
  info->error = process_res;
#line 454
  if (percents.same_output) {
#line 454
    if (need_check_result) {
      {
#line 455
      print_check_result(info, 0, 1);
      }
    } else {
#line 454
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
    {
#line 457
    fprintf((FILE */* __restrict  */)rhash_data.log, (char const   */* __restrict  */)"100%%\n");
#line 458
    fflush(rhash_data.log);
    }
#line 459
    if (need_check_result) {
      {
#line 459
      print_check_result(info, 1, 1);
      }
    }
  }
#line 461
  return;
}
}
#line 464 "/home/june/repo/benchmarks/collector/temp/rhash-1.3.1/output.c"
struct percents_output_info_t dummy_perc  =    {& dummy_init_percents, (void (*)(struct file_info *info , uint64_t offset ))0,
    & dummy_finish_percents, "dummy"};
#line 467 "/home/june/repo/benchmarks/collector/temp/rhash-1.3.1/output.c"
struct percents_output_info_t dots_perc  =    {& dots_init_percents, & dots_update_percents, & dots_finish_percents, "dots"};
#line 470 "/home/june/repo/benchmarks/collector/temp/rhash-1.3.1/output.c"
struct percents_output_info_t p_perc  =    {& p_init_percents, & p_update_percents, & p_finish_percents, "digits"};
#line 474 "/home/june/repo/benchmarks/collector/temp/rhash-1.3.1/output.c"
static void setup_log_stream(FILE **p_stream , opt_tchar const   *stream_path ) 
{ 
  FILE *tmp ;

  {
#line 476
  if (stream_path) {
    {
#line 481
    tmp = fopen((char const   */* __restrict  */)stream_path, (char const   */* __restrict  */)"w");
#line 481
    *p_stream = tmp;
    }
#line 481
    if (! tmp) {
      {
#line 482
      log_file_error(stream_path);
#line 484
      (*rsh_exit)(2);
      }
    }
  }
#line 487
  return;
}
}
#line 492 "/home/june/repo/benchmarks/collector/temp/rhash-1.3.1/output.c"
void setup_output(void) 
{ 
  int tmp ;

  {
  {
#line 494
  rhash_data.out = stdout;
#line 495
  rhash_data.log = stderr;
#line 497
  setup_log_stream(& rhash_data.log, (opt_tchar const   *)opt.log);
#line 498
  setup_log_stream(& rhash_data.out, (opt_tchar const   *)opt.output);
  }
#line 500
  if (opt.flags & 1024U) {
#line 503
    if ((unsigned long )rhash_data.log == (unsigned long )stderr) {
      {
#line 503
      tmp = isatty(2);
      }
#line 503
      if (tmp) {
#line 505
        percents_output = & p_perc;
      } else {
#line 508
        percents_output = & dots_perc;
      }
    } else {
#line 508
      percents_output = & dots_perc;
    }
  } else {
#line 511
    percents_output = & dummy_perc;
  }
#line 513
  return;
}
}
#line 520 "/home/june/repo/benchmarks/collector/temp/rhash-1.3.1/output.c"
void print_check_stats(void) 
{ 


  {
#line 522
  if (rhash_data.processed == rhash_data.ok) {
    {
#line 524
    fprintf((FILE */* __restrict  */)rhash_data.out, (char const   */* __restrict  */)"Everything OK\n");
    }
  } else {
    {
#line 526
    fprintf((FILE */* __restrict  */)rhash_data.out, (char const   */* __restrict  */)"Errors Occurred: Errors:%-3u Miss:%-3u Success:%-3u Total:%-3u\n",
            (rhash_data.processed - rhash_data.ok) - rhash_data.miss, rhash_data.miss,
            rhash_data.ok, rhash_data.processed);
    }
  }
  {
#line 528
  fflush(rhash_data.out);
  }
#line 529
  return;
}
}
#line 534 "/home/june/repo/benchmarks/collector/temp/rhash-1.3.1/output.c"
void print_file_time_stats(struct file_info *info ) 
{ 


  {
  {
#line 536
  print_time_stats(info->time, info->size, 0);
  }
#line 537
  return;
}
}
#line 542 "/home/june/repo/benchmarks/collector/temp/rhash-1.3.1/output.c"
void print_time_stats(double time___0 , uint64_t size , int total ) 
{ 
  double speed ;
  double tmp ;

  {
#line 544
  if (time___0 == (double )0) {
#line 544
    tmp = (double )0;
  } else {
#line 544
    tmp = ((double )((int64_t )size) / 1048576.0) / time___0;
  }
#line 544
  speed = tmp;
#line 545
  if (total) {
    {
#line 546
    fprintf((FILE */* __restrict  */)rhash_data.log, (char const   */* __restrict  */)"Total %.3f sec, %4.2f MBps\n",
            time___0, speed);
    }
  } else {
    {
#line 548
    fprintf((FILE */* __restrict  */)rhash_data.log, (char const   */* __restrict  */)"Calculated in %.3f sec, %4.2f MBps\n",
            time___0, speed);
    }
  }
  {
#line 550
  fflush(rhash_data.log);
  }
#line 551
  return;
}
}
#line 147 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 564
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) getenv)(char const   *__name ) ;
#line 147 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strncmp)(char const   *__s1 ,
                                                                                                char const   *__s2 ,
                                                                                                size_t __n )  __attribute__((__pure__)) ;
#line 285
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1,2), __leaf__)) strcspn)(char const   *__s ,
                                                                                                   char const   *__reject )  __attribute__((__pure__)) ;
#line 289
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1,2), __leaf__)) strspn)(char const   *__s ,
                                                                                                  char const   *__accept )  __attribute__((__pure__)) ;
#line 342
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strstr)(char const   *__haystack ,
                                                                                                 char const   *__needle )  __attribute__((__pure__)) ;
#line 35 "/home/june/repo/benchmarks/collector/temp/rhash-1.3.1/find_file.h"
file_search_data *create_file_search_data(rsh_tchar **paths , size_t count , int max_depth ) ;
#line 36
void destroy_file_search_data(file_search_data *data ) ;
#line 93 "/home/june/repo/benchmarks/collector/temp/rhash-1.3.1/parse_cmdline.h"
struct options_t opt  ;
#line 27 "/home/june/repo/benchmarks/collector/temp/rhash-1.3.1/parse_cmdline.c"
struct options_t conf_opt  ;
#line 30 "/home/june/repo/benchmarks/collector/temp/rhash-1.3.1/parse_cmdline.c"
static void print_help_line(char const   *option , char const   *text ) 
{ 


  {
  {
#line 32
  fprintf((FILE */* __restrict  */)rhash_data.out, (char const   */* __restrict  */)"%s%s",
          option, text);
  }
#line 33
  return;
}
}
#line 38 "/home/june/repo/benchmarks/collector/temp/rhash-1.3.1/parse_cmdline.c"
static void print_help(void) 
{ 


  {
  {
#line 43
  fprintf((FILE */* __restrict  */)rhash_data.out, (char const   */* __restrict  */)"%s\nUsage: %s [OPTION...] [FILE | -]...\n       %s --printf=<format string> [FILE | -]...\n\n",
          "RHash v1.3.1\n", "rhash", "rhash");
#line 46
  fprintf((FILE */* __restrict  */)rhash_data.out, (char const   */* __restrict  */)"Options:\n");
#line 48
  print_help_line("  -V, --version ", "Print program version and exit.\n");
#line 49
  print_help_line("  -h, --help    ", "Print this help screen.\n");
#line 50
  print_help_line("  -C, --crc32   ", "Calculate CRC32 hash sum.\n");
#line 51
  print_help_line("      --md4     ", "Calculate MD4   hash sum.\n");
#line 52
  print_help_line("  -M, --md5     ", "Calculate MD5   hash sum.\n");
#line 53
  print_help_line("  -H, --sha1    ", "Calculate SHA1  hash sum.\n");
#line 54
  print_help_line("      --sha224, --sha256, --sha384, --sha512 ", "Calculate SHA2 hash sum.\n");
#line 55
  print_help_line("      --sha3-224, --sha3-256, --sha3-384, --sha3-512 ", "Calculate SHA3 hash sum.\n");
#line 56
  print_help_line("  -T, --tth     ", "Calculate TTH sum.\n");
#line 57
  print_help_line("      --btih    ", "Calculate BitTorrent InfoHash.\n");
#line 58
  print_help_line("  -A, --aich    ", "Calculate AICH hash.\n");
#line 59
  print_help_line("  -E, --ed2k    ", "Calculate eDonkey hash sum.\n");
#line 60
  print_help_line("  -L, --ed2k-link  ", "Calculate and print eDonkey link.\n");
#line 61
  print_help_line("      --tiger   ", "Calculate Tiger hash sum.\n");
#line 62
  print_help_line("  -G, --gost    ", "Calculate GOST R 34.11-94 hash.\n");
#line 63
  print_help_line("      --gost-cryptopro ", "CryptoPro version of the GOST R 34.11-94 hash.\n");
#line 64
  print_help_line("      --ripemd160  ", "Calculate RIPEMD-160 hash.\n");
#line 65
  print_help_line("      --has160  ", "Calculate HAS-160 hash.\n");
#line 66
  print_help_line("      --edonr256, --edonr512  ", "Calculate EDON-R 256/512 hash.\n");
#line 67
  print_help_line("      --snefru128, --snefru256  ", "Calculate SNEFRU-128/256 hash.\n");
#line 68
  print_help_line("  -a, --all     ", "Calculate all supported hashes.\n");
#line 69
  print_help_line("  -c, --check   ", "Check hash files specified by command line.\n");
#line 70
  print_help_line("  -u, --update  ", "Update hash files specified by command line.\n");
#line 71
  print_help_line("  -e, --embed-crc  ", "Rename files by inserting crc32 sum into name.\n");
#line 72
  print_help_line("  -k, --check-embedded  ", "Verify files by crc32 sum embedded in their names.\n");
#line 73
  print_help_line("      --list-hashes  ", "List the names of supported hashes, one per line.\n");
#line 74
  print_help_line("  -B, --benchmark  ", "Benchmark selected algorithm.\n");
#line 75
  print_help_line("  -v, --verbose ", "Be verbose.\n");
#line 76
  print_help_line("  -r, --recursive  ", "Process directories recursively.\n");
#line 77
  print_help_line("      --skip-ok ", "Don\'t print OK messages for successfully verified files.\n");
#line 78
  print_help_line("  -i, --ignore-case  ", "Ignore case of filenames when updating hash files.\n");
#line 79
  print_help_line("      --percents   ", "Show percents, while calculating or checking hashes.\n");
#line 80
  print_help_line("      --speed   ", "Output per-file and total processing speed.\n");
#line 81
  print_help_line("      --maxdepth=<n> ", "Descend at most <n> levels of directories.\n");
#line 82
  print_help_line("  -o, --output=<file> ", "File to output calculation or checking results.\n");
#line 83
  print_help_line("  -l, --log=<file>    ", "File to log errors and verbose information.\n");
#line 84
  print_help_line("      --sfv     ", "Print hash sums, using SFV format (default).\n");
#line 85
  print_help_line("      --bsd     ", "Print hash sums, using BSD-like format.\n");
#line 86
  print_help_line("      --simple  ", "Print hash sums, using simple format.\n");
#line 87
  print_help_line("  -m, --magnet  ", "Print hash sums  as magnet links.\n");
#line 88
  print_help_line("      --torrent ", "Create torrent files.\n");
#line 92
  print_help_line("      --template=<file> ", "Load a printf-like template from the <file>\n");
#line 93
  print_help_line("  -p, --printf=<format string>  ", "Format and print hash sums.\n                See the RHash manual for details.\n");
#line 95
  (*rsh_exit)(0);
  }
#line 96
  return;
}
}
#line 101 "/home/june/repo/benchmarks/collector/temp/rhash-1.3.1/parse_cmdline.c"
static void list_hashes(void) 
{ 
  int id ;
  char const   *hash_name ;
  char const   *tmp ;

  {
#line 104
  id = 1;
  {
#line 104
  while (1) {
    while_continue: /* CIL Label */ ;
#line 104
    if (! (id < 67108863)) {
#line 104
      goto while_break;
    }
    {
#line 105
    tmp = rhash_get_name((unsigned int )id);
#line 105
    hash_name = tmp;
    }
#line 106
    if (hash_name) {
      {
#line 106
      fprintf((FILE */* __restrict  */)rhash_data.out, (char const   */* __restrict  */)"%s\n",
              hash_name);
      }
    }
#line 104
    id <<= 1;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 108
  (*rsh_exit)(0);
  }
#line 109
  return;
}
}
#line 118 "/home/june/repo/benchmarks/collector/temp/rhash-1.3.1/parse_cmdline.c"
static void crc_accept(options_t *o , char *accept_string , unsigned int type ) 
{ 
  file_mask_array **ptr ;
  struct vector_t **tmp ;

  {
#line 120
  if (type) {
#line 120
    tmp = & o->crc_accept;
  } else {
#line 120
    tmp = & o->files_accept;
  }
#line 120
  ptr = tmp;
#line 121
  if (! *ptr) {
    {
#line 121
    *ptr = rsh_vector_new_simple();
    }
  }
  {
#line 122
  file_mask_add_list(*ptr, (char const   *)accept_string);
  }
#line 123
  return;
}
}
#line 132 "/home/june/repo/benchmarks/collector/temp/rhash-1.3.1/parse_cmdline.c"
static void openssl_flags(options_t *o , char *openssl_hashes , unsigned int type ) 
{ 


  {
  {
#line 164
  log_warning("compiled without openssl support\n");
  }
#line 166
  return;
}
}
#line 173 "/home/june/repo/benchmarks/collector/temp/rhash-1.3.1/parse_cmdline.c"
static void accept_video(options_t *o ) 
{ 


  {
  {
#line 175
  crc_accept(o, (char *)".avi,.ogm,.mkv,.mp4,.mpeg,.mpg,.asf,.rm,.wmv,.vob", 0U);
  }
#line 176
  return;
}
}
#line 181 "/home/june/repo/benchmarks/collector/temp/rhash-1.3.1/parse_cmdline.c"
static void nya(void) 
{ 


  {
  {
#line 183
  fprintf((FILE */* __restrict  */)rhash_data.out, (char const   */* __restrict  */)"  /\\__/\\\n (^ _ ^.) %s\n  (_uu__)\n",
          "Purrr...");
#line 186
  (*rsh_exit)(0);
  }
#line 187
  return;
}
}
#line 196 "/home/june/repo/benchmarks/collector/temp/rhash-1.3.1/parse_cmdline.c"
static void set_max_depth(options_t *o , char *number , unsigned int param ) 
{ 
  size_t tmp ;
  size_t tmp___0 ;

  {
  {
#line 199
  tmp = strspn((char const   *)number, "0123456789");
#line 199
  tmp___0 = strlen((char const   *)number);
  }
#line 199
  if (tmp < tmp___0) {
    {
#line 200
    log_error("maxdepth parameter is not a number: %s\n", number);
#line 201
    (*rsh_exit)(2);
    }
  }
  {
#line 203
  o->find_max_depth = atoi((char const   *)number);
  }
#line 204
  return;
}
}
#line 213 "/home/june/repo/benchmarks/collector/temp/rhash-1.3.1/parse_cmdline.c"
static void set_bt_piece_length(options_t *o , char *number , unsigned int param ) 
{ 
  size_t tmp ;
  size_t tmp___0 ;
  int tmp___1 ;

  {
  {
#line 216
  tmp = strspn((char const   *)number, "0123456789");
#line 216
  tmp___0 = strlen((char const   *)number);
  }
#line 216
  if (tmp < tmp___0) {
    {
#line 217
    log_error("bt-piece-length parameter is not a number: %s\n", number);
#line 218
    (*rsh_exit)(2);
    }
  }
  {
#line 220
  tmp___1 = atoi((char const   *)number);
#line 220
  o->bt_piece_length = (size_t )tmp___1;
  }
#line 221
  return;
}
}
#line 230 "/home/june/repo/benchmarks/collector/temp/rhash-1.3.1/parse_cmdline.c"
static void set_path_separator(options_t *o , char *sep , unsigned int param ) 
{ 


  {
#line 233
  if ((int )*sep == 47) {
#line 233
    goto _L;
  } else
#line 233
  if ((int )*sep == 92) {
    _L: /* CIL Label */ 
#line 233
    if ((int )*(sep + 1) == 0) {
#line 234
      o->path_separator = *sep;
    } else {
      {
#line 242
      log_error("path-separator is not \'/\' or \'\\\': %s\n", sep);
#line 243
      (*rsh_exit)(2);
      }
    }
  } else {
    {
#line 242
    log_error("path-separator is not \'/\' or \'\\\': %s\n", sep);
#line 243
    (*rsh_exit)(2);
    }
  }
#line 245
  return;
}
}
#line 276 "/home/june/repo/benchmarks/collector/temp/rhash-1.3.1/parse_cmdline.c"
cmdline_opt_t cmdline_opt[68]  = 
#line 276
  {      {(unsigned short)1, (char )'c', (char)0, (char *)"check", (void *)(& opt.mode),
      1U}, 
        {(unsigned short)1, (char )'k', (char)0, (char *)"check-embedded", (void *)(& opt.mode),
      2U}, 
        {(unsigned short)1, (char )'u', (char)0, (char *)"update", (void *)(& opt.mode),
      4U}, 
        {(unsigned short)1, (char )'B', (char)0, (char *)"benchmark", (void *)(& opt.mode),
      8U}, 
        {(unsigned short)1, (char)0, (char)0, (char *)"torrent", (void *)(& opt.mode),
      16U}, 
        {(unsigned short)4, (char)0, (char)0, (char *)"list-hashes", (void *)(& list_hashes),
      0U}, 
        {(unsigned short)4, (char )'h', (char)0, (char *)"help", (void *)(& print_help),
      0U}, 
        {(unsigned short)6, (char )'V', (char)0, (char *)"version", (void *)"RHash v1.3.1\n",
      0U}, 
        {(unsigned short)1, (char )'a', (char)0, (char *)"all", (void *)(& opt.sum_flags),
      67108863U}, 
        {(unsigned short)1, (char )'C', (char)0, (char *)"crc32", (void *)(& opt.sum_flags),
      1U}, 
        {(unsigned short)1, (char)0, (char)0, (char *)"md4", (void *)(& opt.sum_flags),
      2U}, 
        {(unsigned short)1, (char )'M', (char)0, (char *)"md5", (void *)(& opt.sum_flags),
      4U}, 
        {(unsigned short)1, (char )'H', (char)0, (char *)"sha1", (void *)(& opt.sum_flags),
      8U}, 
        {(unsigned short)1, (char)0, (char)0, (char *)"sha224", (void *)(& opt.sum_flags),
      65536U}, 
        {(unsigned short)1, (char)0, (char)0, (char *)"sha256", (void *)(& opt.sum_flags),
      131072U}, 
        {(unsigned short)1, (char)0, (char)0, (char *)"sha384", (void *)(& opt.sum_flags),
      262144U}, 
        {(unsigned short)1, (char)0, (char)0, (char *)"sha512", (void *)(& opt.sum_flags),
      524288U}, 
        {(unsigned short)1, (char)0, (char)0, (char *)"sha3-224", (void *)(& opt.sum_flags),
      4194304U}, 
        {(unsigned short)1, (char)0, (char)0, (char *)"sha3-256", (void *)(& opt.sum_flags),
      8388608U}, 
        {(unsigned short)1, (char)0, (char)0, (char *)"sha3-384", (void *)(& opt.sum_flags),
      16777216U}, 
        {(unsigned short)1, (char)0, (char)0, (char *)"sha3-512", (void *)(& opt.sum_flags),
      33554432U}, 
        {(unsigned short)1, (char)0, (char)0, (char *)"tiger", (void *)(& opt.sum_flags),
      16U}, 
        {(unsigned short)1, (char )'T', (char)0, (char *)"tth", (void *)(& opt.sum_flags),
      32U}, 
        {(unsigned short)1, (char)0, (char)0, (char *)"btih", (void *)(& opt.sum_flags),
      64U}, 
        {(unsigned short)1, (char )'E', (char)0, (char *)"ed2k", (void *)(& opt.sum_flags),
      128U}, 
        {(unsigned short)1, (char )'A', (char)0, (char *)"aich", (void *)(& opt.sum_flags),
      256U}, 
        {(unsigned short)1, (char )'G', (char)0, (char *)"gost", (void *)(& opt.sum_flags),
      2048U}, 
        {(unsigned short)1, (char)0, (char)0, (char *)"gost-cryptopro", (void *)(& opt.sum_flags),
      4096U}, 
        {(unsigned short)1, (char )'W', (char)0, (char *)"whirlpool", (void *)(& opt.sum_flags),
      512U}, 
        {(unsigned short)1, (char)0, (char)0, (char *)"ripemd160", (void *)(& opt.sum_flags),
      1024U}, 
        {(unsigned short)1, (char)0, (char)0, (char *)"has160", (void *)(& opt.sum_flags),
      8192U}, 
        {(unsigned short)1, (char)0, (char)0, (char *)"snefru128", (void *)(& opt.sum_flags),
      16384U}, 
        {(unsigned short)1, (char)0, (char)0, (char *)"snefru256", (void *)(& opt.sum_flags),
      32768U}, 
        {(unsigned short)1, (char)0, (char)0, (char *)"edonr256", (void *)(& opt.sum_flags),
      1048576U}, 
        {(unsigned short)1, (char)0, (char)0, (char *)"edonr512", (void *)(& opt.sum_flags),
      2097152U}, 
        {(unsigned short)1, (char )'L', (char)0, (char *)"ed2k-link", (void *)(& opt.sum_flags),
      268435456U}, 
        {(unsigned short)1, (char)0, (char)0, (char *)"sfv", (void *)(& opt.fmt), 2U}, 
        {(unsigned short)1,
      (char)0, (char)0, (char *)"bsd", (void *)(& opt.fmt), 1U}, 
        {(unsigned short)1, (char)0, (char)0, (char *)"simple", (void *)(& opt.fmt),
      4U}, 
        {(unsigned short)1, (char )'m', (char)0, (char *)"magnet", (void *)(& opt.fmt),
      8U}, 
        {(unsigned short)1, (char)0, (char)0, (char *)"uppercase", (void *)(& opt.flags),
      8192U}, 
        {(unsigned short)1, (char)0, (char)0, (char *)"lowercase", (void *)(& opt.flags),
      16384U}, 
        {(unsigned short)18, (char)0, (char)0, (char *)"template", (void *)(& opt.template_file),
      0U}, 
        {(unsigned short)18, (char )'p', (char)0, (char *)"printf", (void *)(& opt.printf_str),
      0U}, 
        {(unsigned short)1, (char )'r', (char )'R', (char *)"recursive", (void *)(& opt.flags),
      64U}, 
        {(unsigned short)1, (char )'v', (char)0, (char *)"verbose", (void *)(& opt.flags),
      512U}, 
        {(unsigned short)1, (char)0, (char)0, (char *)"gost-reverse", (void *)(& opt.flags),
      32768U}, 
        {(unsigned short)1, (char)0, (char)0, (char *)"skip-ok", (void *)(& opt.flags),
      128U}, 
        {(unsigned short)1, (char )'i', (char)0, (char *)"ignore-case", (void *)(& opt.flags),
      256U}, 
        {(unsigned short)33, (char)0, (char)0, (char *)"percents", (void *)(& opt.flags),
      1024U}, 
        {(unsigned short)1, (char)0, (char)0, (char *)"speed", (void *)(& opt.flags),
      2048U}, 
        {(unsigned short)1, (char )'e', (char)0, (char *)"embed-crc", (void *)(& opt.flags),
      32U}, 
        {(unsigned short)18, (char)0, (char)0, (char *)"embed-crc-delimiter", (void *)(& opt.embed_crc_delimiter),
      0U}, 
        {(unsigned short)21, (char)0, (char)0, (char *)"path-separator", (void *)(& set_path_separator),
      0U}, 
        {(unsigned short)51, (char )'o', (char)0, (char *)"output", (void *)(& opt.output),
      0U}, 
        {(unsigned short)51, (char )'l', (char)0, (char *)"log", (void *)(& opt.log),
      0U}, 
        {(unsigned short)21, (char )'q', (char)0, (char *)"accept", (void *)(& crc_accept),
      0U}, 
        {(unsigned short)21, (char )'t', (char)0, (char *)"crc-accept", (void *)(& crc_accept),
      1U}, 
        {(unsigned short)4, (char)0, (char)0, (char *)"video", (void *)(& accept_video),
      0U}, 
        {(unsigned short)4, (char)0, (char)0, (char *)"nya", (void *)(& nya), 0U}, 
        {(unsigned short)21, (char)0, (char)0, (char *)"maxdepth", (void *)(& set_max_depth),
      0U}, 
        {(unsigned short)1, (char)0, (char)0, (char *)"bt-private", (void *)(& opt.flags),
      4096U}, 
        {(unsigned short)21, (char)0, (char)0, (char *)"bt-piece-length", (void *)(& set_bt_piece_length),
      0U}, 
        {(unsigned short)18, (char)0, (char)0, (char *)"bt-announce", (void *)(& opt.bt_announce),
      0U}, 
        {(unsigned short)18, (char)0, (char)0, (char *)"bt-batch", (void *)(& opt.bt_batch_file),
      0U}, 
        {(unsigned short)1, (char)0, (char)0, (char *)"benchmark-raw", (void *)(& opt.flags),
      65536U}, 
        {(unsigned short)21, (char)0, (char)0, (char *)"openssl", (void *)(& openssl_flags),
      0U}, 
        {(unsigned short)0, (char)0, (char)0, (char *)0, (void *)0, 0U}};
#line 366 "/home/june/repo/benchmarks/collector/temp/rhash-1.3.1/parse_cmdline.c"
static void die(char const   *msg ) 
{ 


  {
  {
#line 368
  log_error(msg);
#line 369
  (*rsh_exit)(2);
  }
#line 370
  return;
}
}
#line 377 "/home/june/repo/benchmarks/collector/temp/rhash-1.3.1/parse_cmdline.c"
static void fail_on_unknow_option(char const   *option_name ) 
{ 
  char const   *tmp ;

  {
#line 379
  if (option_name) {
#line 379
    tmp = option_name;
  } else {
#line 379
    tmp = "?";
  }
  {
#line 379
  log_error("unknown option: %s", tmp);
#line 380
  (*rsh_exit)(2);
  }
#line 381
  return;
}
}
#line 398 "/home/june/repo/benchmarks/collector/temp/rhash-1.3.1/parse_cmdline.c"
static void apply_option(options_t *opts , parsed_option_t *option ) 
{ 
  cmdline_opt_t *o ;
  unsigned short option_type ;
  char *value ;

  {
#line 400
  o = option->o;
#line 401
  option_type = o->type;
#line 402
  value = (char *)((void *)0);
#line 405
  if ((int )option_type & 16) {
#line 406
    if (! option->parameter) {
      {
#line 407
      log_error("argument is required for option %s\n", option->name);
#line 408
      (*rsh_exit)(2);
      }
    }
#line 421
    value = (char *)option->parameter;
  }
  {
#line 428
  if ((int )option_type == 33) {
#line 428
    goto case_33;
  }
#line 428
  if ((int )option_type == 1) {
#line 428
    goto case_33;
  }
#line 432
  if ((int )option_type == 51) {
#line 432
    goto case_51;
  }
#line 432
  if ((int )option_type == 18) {
#line 432
    goto case_51;
  }
#line 436
  if ((int )option_type == 21) {
#line 436
    goto case_21;
  }
#line 440
  if ((int )option_type == 4) {
#line 440
    goto case_4;
  }
#line 443
  if ((int )option_type == 6) {
#line 443
    goto case_6;
  }
#line 447
  goto switch_default;
  case_33: /* CIL Label */ 
  case_1: /* CIL Label */ 
#line 429
  *((unsigned int *)((char *)opts + ((char *)o->ptr - (char *)(& opt)))) |= o->param;
#line 430
  goto switch_break;
  case_51: /* CIL Label */ 
  case_18: /* CIL Label */ 
#line 434
  *((char **)((char *)opts + ((char *)o->ptr - (char *)(& opt)))) = value;
#line 435
  goto switch_break;
  case_21: /* CIL Label */ 
  {
#line 438
  (*((void (*)(options_t * , char * , unsigned int  ))o->ptr))(opts, value, o->param);
  }
#line 439
  goto switch_break;
  case_4: /* CIL Label */ 
  {
#line 441
  (*((void (*)(options_t * ))o->ptr))(opts);
  }
#line 442
  goto switch_break;
  case_6: /* CIL Label */ 
  {
#line 444
  log_msg("%s", (char *)o->ptr);
#line 445
  (*rsh_exit)(0);
  }
#line 446
  goto switch_break;
  switch_default: /* CIL Label */ ;
  switch_break: /* CIL Label */ ;
  }
#line 450
  return;
}
}
#line 457 "/home/june/repo/benchmarks/collector/temp/rhash-1.3.1/parse_cmdline.c"
static char const   *find_conf_file(void) 
{ 
  struct stat st ;
  char *dir1 ;
  char *path ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 465
  dir1 = getenv("HOME");
  }
#line 465
  if (dir1) {
    {
#line 466
    path = make_path((char const   *)dir1, ".rhashrc");
#line 467
    tmp = stat((char const   */* __restrict  */)path, (struct stat */* __restrict  */)(& st));
    }
#line 467
    if (tmp >= 0) {
      {
#line 468
      rsh_vector_add_ptr(opt.mem, (void *)path);
#line 469
      conf_opt.config_file = (char const   *)path;
      }
#line 469
      return (conf_opt.config_file);
    }
    {
#line 471
    free((void *)path);
    }
  }
  {
#line 474
  path = (char *)"/etc/rhashrc";
#line 474
  tmp___0 = stat((char const   */* __restrict  */)path, (struct stat */* __restrict  */)(& st));
  }
#line 474
  if (tmp___0 >= 0) {
#line 475
    conf_opt.config_file = (char const   *)path;
#line 475
    return (conf_opt.config_file);
  }
#line 502
  conf_opt.config_file = (char const   *)((void *)0);
#line 502
  return (conf_opt.config_file);
}
}
#line 562
static int read_config(void) ;
#line 562 "/home/june/repo/benchmarks/collector/temp/rhash-1.3.1/parse_cmdline.c"
static char const   *strings[4]  = {      "1",      "on",      "yes",      (char const   *)0};
#line 510 "/home/june/repo/benchmarks/collector/temp/rhash-1.3.1/parse_cmdline.c"
static int read_config(void) 
{ 
  char buf[2048] ;
  FILE *fd ;
  parsed_option_t option ;
  int res ;
  char const   *tmp ;
  size_t index___0 ;
  cmdline_opt_t *t ;
  char *line ;
  char *tmp___0 ;
  char *name ;
  char *value ;
  int tmp___1 ;
  char const   **cmp ;
  int tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;

  {
  {
#line 519
  memset((void *)(& conf_opt), 0, sizeof(opt));
#line 520
  conf_opt.find_max_depth = -1;
#line 522
  tmp = find_conf_file();
  }
#line 522
  if (! tmp) {
#line 522
    return (0);
  }
  {
#line 524
  fd = fopen((char const   */* __restrict  */)conf_opt.config_file, (char const   */* __restrict  */)"r");
  }
#line 525
  if (! fd) {
#line 525
    return (-1);
  }
  {
#line 527
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 527
    tmp___3 = fgets((char */* __restrict  */)(buf), 2048, (FILE */* __restrict  */)fd);
    }
#line 527
    if (! tmp___3) {
#line 527
      goto while_break;
    }
    {
#line 530
    tmp___0 = str_trim(buf);
#line 530
    line = tmp___0;
    }
#line 533
    if ((int )*line == 0) {
#line 533
      goto while_continue;
    } else
#line 533
    if ((int )*line == 59) {
#line 533
      goto while_continue;
    } else
#line 533
    if ((int )*line == 35) {
#line 533
      goto while_continue;
    }
    {
#line 536
    index___0 = strcspn((char const   *)line, "=");
    }
#line 537
    if ((int )*(line + index___0) == 0) {
      {
#line 538
      log_warning("%s: can\'t parse line \"%s\"\n", conf_opt.config_file, line);
      }
#line 539
      goto while_continue;
    }
    {
#line 541
    *(line + index___0) = (char)0;
#line 542
    name = str_trim(line);
#line 544
    t = cmdline_opt;
    }
    {
#line 544
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 544
      if (! t->type) {
#line 544
        goto while_break___0;
      }
      {
#line 545
      tmp___1 = strcmp((char const   *)name, (char const   *)t->long_name);
      }
#line 545
      if (tmp___1 == 0) {
#line 546
        goto while_break___0;
      }
#line 544
      t ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 550
    if (! t->type) {
      {
#line 551
      log_warning("%s: unknown option \"%s\"\n", conf_opt.config_file, line);
      }
#line 552
      goto while_continue;
    }
    {
#line 555
    value = str_trim((line + index___0) + 1);
    }
#line 558
    if ((int )t->type & 16) {
      {
#line 559
      value = rhash_strdup((char const   *)value, "/home/june/repo/benchmarks/collector/temp/rhash-1.3.1/parse_cmdline.c",
                           559);
#line 559
      rsh_vector_add_ptr(opt.mem, (void *)value);
      }
    } else {
#line 564
      cmp = strings;
      {
#line 564
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 564
        if (*cmp) {
          {
#line 564
          tmp___2 = strcmp((char const   *)value, *cmp);
          }
#line 564
          if (! tmp___2) {
#line 564
            goto while_break___1;
          }
        } else {
#line 564
          goto while_break___1;
        }
#line 564
        cmp ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 565
      if ((unsigned long )*cmp == (unsigned long )((char const   *)0)) {
#line 565
        goto while_continue;
      }
    }
    {
#line 568
    option.name = (char const   *)name;
#line 569
    option.parameter = (void *)value;
#line 570
    option.o = t;
#line 571
    apply_option(& conf_opt, & option);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 573
  res = fclose(fd);
  }
#line 578
  if (res == 0) {
#line 578
    tmp___4 = 0;
  } else {
#line 578
    tmp___4 = -1;
  }
#line 578
  return (tmp___4);
}
}
#line 588 "/home/june/repo/benchmarks/collector/temp/rhash-1.3.1/parse_cmdline.c"
static void parse_long_option(parsed_option_t *option , rsh_tchar ***parg ) 
{ 
  size_t length ;
  rsh_tchar *eq_sign ;
  cmdline_opt_t *t ;
  char *name ;
  size_t tmp ;
  int tmp___0 ;
  size_t tmp___1 ;

  {
  {
#line 621
  option->name = (char const   *)*(*parg);
#line 622
  name = *(*parg) + 2;
#line 623
  eq_sign = strchr((char const   *)name, '=');
  }
#line 623
  if (eq_sign) {
#line 623
    length = (size_t )(eq_sign - name);
  } else {
    {
#line 623
    tmp = strlen((char const   *)name);
#line 623
    length = tmp;
    }
  }
#line 624
  *(name + length) = (char )'\000';
#line 627
  t = cmdline_opt;
  {
#line 627
  while (1) {
    while_continue: /* CIL Label */ ;
#line 627
    if (t->type) {
      {
#line 627
      tmp___0 = strncmp((char const   *)name, (char const   *)t->long_name, length);
      }
#line 627
      if (! (tmp___0 != 0)) {
        {
#line 627
        tmp___1 = strlen((char const   *)t->long_name);
        }
#line 627
        if (! (tmp___1 != length)) {
#line 627
          goto while_break;
        }
      }
    } else {
#line 627
      goto while_break;
    }
#line 627
    t ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 630
  if (! t->type) {
    {
#line 631
    fail_on_unknow_option(option->name);
    }
  }
#line 634
  option->o = t;
#line 635
  if ((int )t->type & 16) {
#line 637
    if (eq_sign) {
#line 637
      option->parameter = (void *)(eq_sign + 1);
    } else {
#line 637
      (*parg) ++;
#line 637
      option->parameter = (void *)*(*parg);
    }
  }
#line 639
  return;
}
}
#line 661 "/home/june/repo/benchmarks/collector/temp/rhash-1.3.1/parse_cmdline.c"
static void parse_cmdline_options(struct parsed_cmd_line_t *cmd_line ) 
{ 
  int argc ;
  int n_files ;
  int b_opt_end ;
  rsh_tchar **files ;
  rsh_tchar **parg ;
  rsh_tchar **end_arg ;
  parsed_option_t *next_opt ;
  void *tmp ;
  int tmp___0 ;
  cmdline_opt_t *t ;
  void *tmp___1 ;
  size_t tmp___2 ;
  rsh_tchar *ptr ;
  cmdline_opt_t *t___0 ;
  char ch ;
  void *tmp___3 ;
  size_t tmp___4 ;

  {
  {
#line 664
  n_files = 0;
#line 664
  b_opt_end = 0;
#line 675
  argc = cmd_line->argc;
#line 676
  parg = cmd_line->argv;
#line 680
  tmp = rhash_malloc((unsigned long )argc * sizeof(rsh_tchar *), "/home/june/repo/benchmarks/collector/temp/rhash-1.3.1/parse_cmdline.c",
                     680);
#line 680
  files = (rsh_tchar **)tmp;
#line 681
  end_arg = parg + argc;
#line 684
  parg ++;
  }
  {
#line 684
  while (1) {
    while_continue: /* CIL Label */ ;
#line 684
    if (! ((unsigned long )parg < (unsigned long )end_arg)) {
#line 684
      goto while_break;
    }
#line 687
    if ((int )*(*parg + 0) != 45) {
#line 689
      tmp___0 = n_files;
#line 689
      n_files ++;
#line 689
      *(files + tmp___0) = *parg;
#line 690
      goto __Cont;
    } else
#line 687
    if ((int )*(*parg + 1) == 0) {
#line 689
      tmp___0 = n_files;
#line 689
      n_files ++;
#line 689
      *(files + tmp___0) = *parg;
#line 690
      goto __Cont;
    } else
#line 687
    if (b_opt_end) {
#line 689
      tmp___0 = n_files;
#line 689
      n_files ++;
#line 689
      *(files + tmp___0) = *parg;
#line 690
      goto __Cont;
    }
#line 695
    if ((int )*(*parg + 1) == 45) {
#line 695
      if ((int )*(*parg + 2) == 0) {
#line 696
        b_opt_end = 1;
#line 697
        goto __Cont;
      }
    }
#line 701
    if ((int )*(*parg + 1) == 45) {
#line 705
      tmp___2 = cmd_line->options.size;
#line 705
      (cmd_line->options.size) ++;
#line 705
      if (tmp___2 % 16UL == 0UL) {
        {
#line 705
        tmp___1 = rhash_malloc(sizeof(parsed_option_t ) * 16UL, "/home/june/repo/benchmarks/collector/temp/rhash-1.3.1/parse_cmdline.c",
                               705);
#line 705
        rsh_vector_add_ptr(& cmd_line->options.blocks, tmp___1);
        }
      }
      {
#line 706
      next_opt = (parsed_option_t *)*(cmd_line->options.blocks.array + (cmd_line->options.size - 1UL) / 16UL) + (cmd_line->options.size - 1UL) % 16UL;
#line 709
      parse_long_option(next_opt, & parg);
#line 710
      t = next_opt->o;
      }
#line 713
      if ((int )t->type & 32) {
        {
#line 714
        apply_option(& opt, next_opt);
        }
      }
    } else
#line 716
    if ((int )*(*parg + 1) != 0) {
#line 722
      ptr = *parg + 1;
      {
#line 722
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 722
        if (! *ptr) {
#line 722
          goto while_break___0;
        }
#line 724
        ch = *ptr;
#line 733
        tmp___4 = cmd_line->options.size;
#line 733
        (cmd_line->options.size) ++;
#line 733
        if (tmp___4 % 16UL == 0UL) {
          {
#line 733
          tmp___3 = rhash_malloc(sizeof(parsed_option_t ) * 16UL, "/home/june/repo/benchmarks/collector/temp/rhash-1.3.1/parse_cmdline.c",
                                 733);
#line 733
          rsh_vector_add_ptr(& cmd_line->options.blocks, tmp___3);
          }
        }
#line 734
        next_opt = (parsed_option_t *)*(cmd_line->options.blocks.array + (cmd_line->options.size - 1UL) / 16UL) + (cmd_line->options.size - 1UL) % 16UL;
#line 736
        next_opt->buf[0] = (char )'-';
#line 736
        next_opt->buf[1] = ch;
#line 736
        next_opt->buf[2] = (char )'\000';
#line 737
        next_opt->name = (char const   *)(next_opt->buf);
#line 738
        next_opt->parameter = (void *)0;
#line 741
        t___0 = cmdline_opt;
        {
#line 741
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 741
          if (t___0->type) {
#line 741
            if ((int )ch != (int )t___0->short1) {
#line 741
              if (! ((int )ch != (int )t___0->short2)) {
#line 741
                goto while_break___1;
              }
            } else {
#line 741
              goto while_break___1;
            }
          } else {
#line 741
            goto while_break___1;
          }
#line 741
          t___0 ++;
        }
        while_break___1: /* CIL Label */ ;
        }
#line 742
        if (! t___0->type) {
          {
#line 742
          fail_on_unknow_option((char const   *)(next_opt->buf));
          }
        }
#line 743
        next_opt->o = t___0;
#line 744
        if ((int )t___0->type & 16) {
#line 745
          if (*(ptr + 1)) {
#line 745
            next_opt->parameter = (void *)(ptr + 1);
          } else {
#line 745
            parg ++;
#line 745
            next_opt->parameter = (void *)*parg;
          }
#line 746
          if (! next_opt->parameter) {
            {
#line 748
            log_error("argument is required for option %s\n", next_opt->name);
#line 749
            (*rsh_exit)(2);
            }
          }
        }
#line 754
        if ((int )t___0->type & 32) {
          {
#line 755
          apply_option(& opt, next_opt);
          }
        }
#line 757
        if (next_opt->parameter) {
#line 757
          goto while_break___0;
        }
#line 722
        ptr ++;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
    __Cont: /* CIL Label */ 
#line 684
    parg ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 763
  cmd_line->n_files = n_files;
#line 764
  cmd_line->files = files;
#line 765
  return;
}
}
#line 773 "/home/june/repo/benchmarks/collector/temp/rhash-1.3.1/parse_cmdline.c"
static void apply_cmdline_options(struct parsed_cmd_line_t *cmd_line ) 
{ 
  size_t count ;
  size_t i ;
  parsed_option_t *o ;

  {
#line 775
  count = cmd_line->options.size;
#line 777
  i = (size_t )0;
  {
#line 777
  while (1) {
    while_continue: /* CIL Label */ ;
#line 777
    if (! (i < count)) {
#line 777
      goto while_break;
    }
#line 778
    o = (parsed_option_t *)((unsigned char *)*(cmd_line->options.blocks.array + i / 16UL) + sizeof(parsed_option_t ) * (i % 16UL));
#line 782
    if (! ((int )(o->o)->type & 32)) {
      {
#line 783
      apply_option(& opt, o);
      }
    }
#line 777
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 788
  if (! opt.printf_str) {
#line 788
    if (! opt.template_file) {
#line 788
      if (! opt.sum_flags) {
#line 788
        if (! opt.fmt) {
#line 789
          opt.printf_str = conf_opt.printf_str;
#line 790
          opt.template_file = conf_opt.template_file;
        }
      }
    }
  }
#line 793
  if (! opt.printf_str) {
#line 793
    if (! opt.template_file) {
#line 794
      if (! opt.fmt) {
#line 794
        opt.fmt = conf_opt.fmt;
      }
#line 795
      if (! opt.sum_flags) {
#line 795
        opt.sum_flags = conf_opt.sum_flags;
      }
    }
  }
#line 798
  if (! opt.mode) {
#line 798
    opt.mode = conf_opt.mode;
  }
#line 799
  opt.flags |= conf_opt.flags;
#line 801
  if ((unsigned long )opt.files_accept == (unsigned long )((struct vector_t *)0)) {
#line 801
    opt.files_accept = conf_opt.files_accept;
  }
#line 802
  if ((unsigned long )opt.crc_accept == (unsigned long )((struct vector_t *)0)) {
#line 802
    opt.crc_accept = conf_opt.crc_accept;
  }
#line 803
  if ((unsigned long )opt.embed_crc_delimiter == (unsigned long )((char *)0)) {
#line 803
    opt.embed_crc_delimiter = conf_opt.embed_crc_delimiter;
  }
#line 804
  if (! opt.path_separator) {
#line 804
    opt.path_separator = conf_opt.path_separator;
  }
#line 805
  if (opt.find_max_depth < 0) {
#line 805
    opt.find_max_depth = conf_opt.find_max_depth;
  }
#line 806
  if (! (opt.flags & 64U)) {
#line 806
    opt.find_max_depth = 0;
  }
#line 807
  if (opt.flags & 32U) {
#line 807
    opt.sum_flags |= 1U;
  }
#line 808
  if (opt.openssl_mask == 0U) {
#line 808
    opt.openssl_mask = conf_opt.openssl_mask;
  }
#line 811
  if ((unsigned long )opt.embed_crc_delimiter == (unsigned long )((char *)0)) {
#line 811
    opt.embed_crc_delimiter = (char *)" ";
  }
#line 812
  return;
}
}
#line 819 "/home/june/repo/benchmarks/collector/temp/rhash-1.3.1/parse_cmdline.c"
static void set_default_sums_flags(char const   *progName ) 
{ 
  char *buf ;
  int res ;
  char const   *p ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;
  char *tmp___14 ;
  char *tmp___15 ;
  char *tmp___16 ;
  char *tmp___17 ;
  char *tmp___18 ;
  char *tmp___19 ;
  char *tmp___20 ;
  char *tmp___21 ;
  char *tmp___22 ;
  char *tmp___23 ;
  char *tmp___24 ;
  char *tmp___25 ;
  char *tmp___26 ;
  char *tmp___27 ;
  char *tmp___28 ;
  char *tmp___29 ;
  int tmp___30 ;

  {
  {
#line 822
  res = 0;
#line 825
  tmp = strrchr(progName, '/');
#line 825
  p = (char const   *)tmp;
  }
#line 826
  if (p) {
#line 826
    progName = p + 1;
  }
  {
#line 833
  buf = str_tolower(progName);
#line 835
  tmp___0 = strstr((char const   *)buf, "crc32");
  }
#line 835
  if (tmp___0) {
#line 835
    res |= 1;
  }
  {
#line 836
  tmp___1 = strstr((char const   *)buf, "md4");
  }
#line 836
  if (tmp___1) {
#line 836
    res |= 2;
  }
  {
#line 837
  tmp___2 = strstr((char const   *)buf, "md5");
  }
#line 837
  if (tmp___2) {
#line 837
    res |= 4;
  }
  {
#line 838
  tmp___3 = strstr((char const   *)buf, "sha1");
  }
#line 838
  if (tmp___3) {
#line 838
    res |= 8;
  }
  {
#line 839
  tmp___4 = strstr((char const   *)buf, "sha256");
  }
#line 839
  if (tmp___4) {
#line 839
    res |= 131072;
  }
  {
#line 840
  tmp___5 = strstr((char const   *)buf, "sha512");
  }
#line 840
  if (tmp___5) {
#line 840
    res |= 524288;
  }
  {
#line 841
  tmp___6 = strstr((char const   *)buf, "sha224");
  }
#line 841
  if (tmp___6) {
#line 841
    res |= 65536;
  }
  {
#line 842
  tmp___7 = strstr((char const   *)buf, "sha384");
  }
#line 842
  if (tmp___7) {
#line 842
    res |= 262144;
  }
  {
#line 843
  tmp___8 = strstr((char const   *)buf, "sha3-256");
  }
#line 843
  if (tmp___8) {
#line 843
    res |= 8388608;
  }
  {
#line 844
  tmp___9 = strstr((char const   *)buf, "sha3-512");
  }
#line 844
  if (tmp___9) {
#line 844
    res |= 33554432;
  }
  {
#line 845
  tmp___10 = strstr((char const   *)buf, "sha3-224");
  }
#line 845
  if (tmp___10) {
#line 845
    res |= 4194304;
  }
  {
#line 846
  tmp___11 = strstr((char const   *)buf, "sha3-384");
  }
#line 846
  if (tmp___11) {
#line 846
    res |= 16777216;
  }
  {
#line 847
  tmp___12 = strstr((char const   *)buf, "tiger");
  }
#line 847
  if (tmp___12) {
#line 847
    res |= 16;
  }
  {
#line 848
  tmp___13 = strstr((char const   *)buf, "tth");
  }
#line 848
  if (tmp___13) {
#line 848
    res |= 32;
  }
  {
#line 849
  tmp___14 = strstr((char const   *)buf, "btih");
  }
#line 849
  if (tmp___14) {
#line 849
    res |= 64;
  }
  {
#line 850
  tmp___15 = strstr((char const   *)buf, "aich");
  }
#line 850
  if (tmp___15) {
#line 850
    res |= 256;
  }
  {
#line 851
  tmp___16 = strstr((char const   *)buf, "gost");
  }
#line 851
  if (tmp___16) {
#line 851
    res |= 2048;
  }
  {
#line 852
  tmp___17 = strstr((char const   *)buf, "gost-cryptopro");
  }
#line 852
  if (tmp___17) {
#line 852
    res |= 4096;
  }
  {
#line 853
  tmp___18 = strstr((char const   *)buf, "has160");
  }
#line 853
  if (tmp___18) {
#line 853
    res |= 8192;
  }
  {
#line 854
  tmp___19 = strstr((char const   *)buf, "ripemd160");
  }
#line 854
  if (tmp___19) {
#line 854
    res |= 1024;
  }
  {
#line 855
  tmp___20 = strstr((char const   *)buf, "whirlpool");
  }
#line 855
  if (tmp___20) {
#line 855
    res |= 512;
  }
  {
#line 856
  tmp___21 = strstr((char const   *)buf, "edonr256");
  }
#line 856
  if (tmp___21) {
#line 856
    res |= 1048576;
  }
  {
#line 857
  tmp___22 = strstr((char const   *)buf, "edonr512");
  }
#line 857
  if (tmp___22) {
#line 857
    res |= 2097152;
  }
  {
#line 858
  tmp___23 = strstr((char const   *)buf, "snefru256");
  }
#line 858
  if (tmp___23) {
#line 858
    res |= 16384;
  }
  {
#line 859
  tmp___24 = strstr((char const   *)buf, "snefru128");
  }
#line 859
  if (tmp___24) {
#line 859
    res |= 32768;
  }
  {
#line 860
  tmp___26 = strstr((char const   *)buf, "ed2k-link");
  }
#line 860
  if (tmp___26) {
#line 860
    res |= 268435456;
  } else {
    {
#line 860
    tmp___27 = strstr((char const   *)buf, "ed2k-hash");
    }
#line 860
    if (tmp___27) {
#line 860
      res |= 268435456;
    } else {
      {
#line 861
      tmp___25 = strstr((char const   *)buf, "ed2k");
      }
#line 861
      if (tmp___25) {
#line 861
        res |= 128;
      }
    }
  }
  {
#line 863
  tmp___28 = strstr((char const   *)buf, "sfv");
  }
#line 863
  if (tmp___28) {
#line 863
    if (opt.fmt == 0U) {
#line 863
      opt.fmt = 2U;
    }
  }
  {
#line 864
  tmp___29 = strstr((char const   *)buf, "magnet");
  }
#line 864
  if (tmp___29) {
#line 864
    if (opt.fmt == 0U) {
#line 864
      opt.fmt = 8U;
    }
  }
  {
#line 866
  free((void *)buf);
  }
#line 869
  if (! opt.sum_flags) {
#line 870
    if (res) {
#line 870
      opt.sum_flags = (unsigned int )res;
    } else {
#line 870
      if (opt.fmt == 8U) {
#line 870
        tmp___30 = 416;
      } else {
#line 870
        tmp___30 = 1;
      }
#line 870
      opt.sum_flags = (unsigned int )tmp___30;
    }
  }
#line 872
  return;
}
}
#line 879 "/home/june/repo/benchmarks/collector/temp/rhash-1.3.1/parse_cmdline.c"
void options_destroy(struct options_t *o ) 
{ 


  {
  {
#line 881
  rsh_vector_free(o->files_accept);
#line 882
  rsh_vector_free(o->crc_accept);
#line 883
  rsh_vector_free(o->mem);
#line 884
  destroy_file_search_data(o->search_data);
  }
#line 885
  return;
}
}
#line 891 "/home/june/repo/benchmarks/collector/temp/rhash-1.3.1/parse_cmdline.c"
static void make_final_options_checks(void) 
{ 
  unsigned int ff ;
  char const   *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 895
  if (opt.flags & 512U) {
#line 895
    if (conf_opt.config_file) {
#line 897
      if (conf_opt.config_file) {
#line 897
        tmp = conf_opt.config_file;
      } else {
#line 897
        tmp = "None";
      }
      {
#line 897
      log_msg("Config file: %s\n", tmp);
      }
    }
  }
#line 900
  if (opt.bt_batch_file) {
#line 900
    opt.mode |= 16U;
  }
#line 901
  if (opt.mode & 16U) {
#line 901
    opt.sum_flags |= 64U;
  }
#line 904
  if (opt.mode & (opt.mode - 1U)) {
    {
#line 905
    die("incompatible program modes\n");
    }
  }
#line 908
  if (opt.printf_str) {
#line 908
    tmp___0 = 1;
  } else {
#line 908
    tmp___0 = 0;
  }
#line 908
  if (opt.template_file) {
#line 908
    tmp___1 = 2;
  } else {
#line 908
    tmp___1 = 0;
  }
#line 908
  if (opt.fmt) {
#line 908
    tmp___2 = 4;
  } else {
#line 908
    tmp___2 = 0;
  }
#line 908
  ff = (unsigned int )((tmp___0 | tmp___1) | tmp___2);
#line 909
  if (opt.fmt & (opt.fmt - 1U)) {
    {
#line 910
    die("too many formating options\n");
    }
  } else
#line 909
  if (ff & (ff - 1U)) {
    {
#line 910
    die("too many formating options\n");
    }
  }
#line 913
  if (! opt.crc_accept) {
    {
#line 913
    opt.crc_accept = file_mask_new_from_list(".sfv");
    }
  }
#line 915
  if (opt.openssl_mask) {
    {
#line 915
    rhash_transmit(10U, (void *)0, (rhash_uptr_t )opt.openssl_mask, (rhash_uptr_t )0);
    }
  }
#line 916
  return;
}
}
#line 923 "/home/june/repo/benchmarks/collector/temp/rhash-1.3.1/parse_cmdline.c"
void read_options(int argc , char **argv ) 
{ 
  struct parsed_cmd_line_t cmd_line ;

  {
  {
#line 927
  memset((void *)(& opt), 0, sizeof(opt));
#line 928
  opt.mem = rsh_vector_new_simple();
#line 929
  opt.find_max_depth = -1;
#line 932
  memset((void *)(& cmd_line), 0, sizeof(cmd_line));
#line 933
  rsh_blocks_vector_init(& cmd_line.options);
#line 934
  cmd_line.argv = argv;
#line 935
  cmd_line.argc = argc;
#line 938
  parse_cmdline_options(& cmd_line);
#line 939
  read_config();
#line 949
  setup_output();
#line 951
  apply_cmdline_options(& cmd_line);
#line 954
  rsh_blocks_vector_destroy(& cmd_line.options);
#line 957
  opt.search_data = create_file_search_data(cmd_line.files, (size_t )cmd_line.n_files,
                                            opt.find_max_depth);
#line 958
  opt.n_files = cmd_line.n_files;
#line 960
  free((void *)cmd_line.files);
#line 966
  make_final_options_checks();
#line 968
  set_default_sums_flags((char const   *)*(argv + 0));
  }
#line 969
  return;
}
}
/* compiler builtin: 
   int __builtin_ctz(unsigned int  ) ;  */
#line 127 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) toupper)(int __c ) ;
#line 27 "/home/june/repo/benchmarks/collector/temp/rhash-1.3.1/hash_check.c"
void rhash_hex_to_byte(char const   *str , unsigned char *bin , int len ) 
{ 
  unsigned char *tmp ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;
  unsigned char *tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
#line 30
  if ((len & 1) != 0) {
#line 31
    tmp = bin;
#line 31
    bin ++;
#line 31
    tmp___3 = str;
#line 31
    str ++;
#line 31
    if ((int const   )*tmp___3 <= 57) {
#line 31
      tmp___1 = str;
#line 31
      str ++;
#line 31
      *tmp = (unsigned char )((int const   )*tmp___1 & 15);
    } else {
#line 31
      tmp___2 = str;
#line 31
      str ++;
#line 31
      *tmp = (unsigned char )((((int const   )*tmp___2 - 97) + 10) & 15);
    }
#line 32
    len --;
  }
  {
#line 36
  while (1) {
    while_continue: /* CIL Label */ ;
#line 36
    if (! (len >= 2)) {
#line 36
      goto while_break;
    }
#line 37
    tmp___4 = bin;
#line 37
    bin ++;
#line 37
    if ((int const   )*(str + 0) <= 57) {
#line 37
      tmp___5 = (int const   )*(str + 0) & 15;
    } else {
#line 37
      tmp___5 = (((int const   )*(str + 0) - 97) + 10) & 15;
    }
#line 37
    if ((int const   )*(str + 1) <= 57) {
#line 37
      tmp___6 = (int const   )*(str + 1) & 15;
    } else {
#line 37
      tmp___6 = (((int const   )*(str + 1) - 97) + 10) & 15;
    }
#line 37
    *tmp___4 = (unsigned char )((tmp___5 << 4) | tmp___6);
#line 36
    len -= 2;
#line 36
    str += 2;
  }
  while_break: /* CIL Label */ ;
  }
#line 39
  return;
}
}
#line 46 "/home/june/repo/benchmarks/collector/temp/rhash-1.3.1/hash_check.c"
static void urldecode(char *buffer ) 
{ 
  char *wpos ;
  char *tmp ;
  int ch ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 48
  wpos = buffer;
  {
#line 49
  while (1) {
    while_continue: /* CIL Label */ ;
#line 49
    if (! *buffer) {
#line 49
      goto while_break;
    }
#line 50
    tmp = buffer;
#line 50
    buffer ++;
#line 50
    *wpos = *tmp;
#line 51
    if ((int )*wpos == 37) {
#line 52
      if ((int )*buffer == 37) {
#line 53
        buffer ++;
      } else {
#line 54
        if ((int )*buffer <= 57) {
#line 54
          tmp___3 = (int )*buffer >= 48;
        } else {
#line 54
          tmp___3 = (unsigned int )(((int )*buffer - 65) & -33) <= 5U;
        }
#line 54
        if (tmp___3) {
#line 56
          if ((int )*buffer <= 57) {
#line 56
            tmp___0 = (int )*buffer & 15;
          } else {
#line 56
            tmp___0 = (((int )*buffer - 97) + 10) & 15;
          }
#line 56
          ch = tmp___0;
#line 57
          buffer ++;
#line 58
          if ((int )*buffer <= 57) {
#line 58
            tmp___2 = (int )*buffer >= 48;
          } else {
#line 58
            tmp___2 = (unsigned int )(((int )*buffer - 65) & -33) <= 5U;
          }
#line 58
          if (tmp___2) {
#line 59
            if ((int )*buffer <= 57) {
#line 59
              tmp___1 = (int )*buffer & 15;
            } else {
#line 59
              tmp___1 = (((int )*buffer - 97) + 10) & 15;
            }
#line 59
            ch = (ch << 4) | tmp___1;
#line 60
            buffer ++;
          }
#line 62
          *wpos = (char )ch;
        }
      }
    }
#line 49
    wpos ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 66
  *wpos = (char )'\000';
#line 67
  return;
}
}
#line 76 "/home/june/repo/benchmarks/collector/temp/rhash-1.3.1/hash_check.c"
static void process_backslashes(char *path ) 
{ 


  {
  {
#line 78
  while (1) {
    while_continue: /* CIL Label */ ;
#line 78
    if (! *path) {
#line 78
      goto while_break;
    }
#line 79
    if ((int )*path == 92) {
#line 79
      *path = (char )'/';
    }
#line 78
    path ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 81
  return;
}
}
#line 117 "/home/june/repo/benchmarks/collector/temp/rhash-1.3.1/hash_check.c"
static int code_digest_size(int digest_size ) 
{ 
  int pow ;
  int code ;
  int tmp ;

  {
#line 121
  if ((unsigned int )(digest_size - 1) > 127U) {
#line 121
    return (32);
  }
  {
#line 122
  pow = __builtin_ctz((unsigned int )(digest_size >> 2));
#line 123
  code = ((digest_size >> (pow + 3)) << 3) | pow;
  }
#line 124
  if (code <= 24) {
#line 124
    tmp = code;
  } else {
#line 124
    tmp = 32;
  }
#line 124
  return (tmp);
}
}
#line 135
static unsigned int hash_check_mask_by_digest_size(int digest_size ) ;
#line 135 "/home/june/repo/benchmarks/collector/temp/rhash-1.3.1/hash_check.c"
static unsigned int mask[26]  = 
#line 135
  {      0U,      0U,      0U,      0U, 
        0U,      0U,      0U,      0U, 
        0U,      0U,      0U,      0U, 
        0U,      0U,      0U,      0U, 
        0U,      0U,      0U,      0U, 
        0U,      0U,      0U,      0U, 
        0U,      0U};
#line 133 "/home/june/repo/benchmarks/collector/temp/rhash-1.3.1/hash_check.c"
static unsigned int hash_check_mask_by_digest_size(int digest_size ) 
{ 
  int code ;
  unsigned int hid ;
  int tmp ;
  unsigned int tmp___0 ;

  {
#line 139
  if (mask[25] == 0U) {
#line 141
    hid = 1U;
    {
#line 141
    while (1) {
      while_continue: /* CIL Label */ ;
#line 141
      if (! (hid <= 67108863U)) {
#line 141
        goto while_break;
      }
      {
#line 142
      tmp = rhash_get_digest_size(hid);
#line 142
      code = code_digest_size(tmp);
      }
#line 144
      if (code <= 24) {
#line 144
        mask[code] |= hid;
      }
#line 141
      hid <<= 1;
    }
    while_break: /* CIL Label */ ;
    }
#line 146
    mask[25] = 1U;
  }
  {
#line 148
  code = code_digest_size(digest_size);
  }
#line 149
  if (code <= 24) {
#line 149
    tmp___0 = mask[code];
  } else {
#line 149
    tmp___0 = 0U;
  }
#line 149
  return (tmp___0);
}
}
#line 162 "/home/june/repo/benchmarks/collector/temp/rhash-1.3.1/hash_check.c"
static int test_hash_char(char c ) 
{ 
  int tmp___0 ;
  int tmp___1 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 164
  if ((int )c <= 57) {
#line 164
    tmp___1 = (int )c >= 48;
  } else {
#line 164
    tmp___1 = (unsigned int )(((int )c - 65) & -33) <= 5U;
  }
#line 164
  if (tmp___1) {
#line 164
    tmp___0 = 1;
  } else {
#line 164
    tmp___0 = 0;
  }
#line 164
  if ((int )c <= 55) {
#line 164
    tmp___4 = 50 <= (int )c;
  } else {
#line 164
    tmp___4 = (unsigned int )(((int )c - 65) & -33) <= 25U;
  }
#line 164
  if (tmp___4) {
#line 164
    tmp___3 = 2;
  } else {
#line 164
    tmp___3 = 0;
  }
#line 164
  return (tmp___0 | tmp___3);
}
}
#line 175 "/home/june/repo/benchmarks/collector/temp/rhash-1.3.1/hash_check.c"
static int detect_hash_type(char **ptr , char *end , int *p_len ) 
{ 
  int len ;
  int char_type ;
  int next_type ;
  int tmp ;
  int tmp___0 ;

  {
#line 177
  len = 0;
#line 178
  char_type = 0;
#line 178
  next_type = 3;
#line 180
  if ((unsigned long )*ptr < (unsigned long )end) {
#line 182
    if (end - *ptr >= 129L) {
#line 182
      end = *ptr + 129;
    }
    {
#line 183
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 183
      tmp = test_hash_char(*(*ptr));
#line 183
      next_type &= tmp;
      }
#line 183
      if (next_type) {
#line 183
        if (! ((unsigned long )*ptr <= (unsigned long )end)) {
#line 183
          goto while_break;
        }
      } else {
#line 183
        goto while_break;
      }
#line 184
      char_type = next_type;
#line 183
      len ++;
#line 183
      (*ptr) ++;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
#line 188
    if (*ptr - end >= 129L) {
#line 188
      end = *ptr - 129;
    }
    {
#line 189
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 189
      tmp___0 = test_hash_char(*(*ptr + -1));
#line 189
      next_type &= tmp___0;
      }
#line 189
      if (next_type) {
#line 189
        if (! ((unsigned long )*ptr >= (unsigned long )end)) {
#line 189
          goto while_break___0;
        }
      } else {
#line 189
        goto while_break___0;
      }
#line 190
      char_type = next_type;
#line 189
      len ++;
#line 189
      (*ptr) --;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 193
  *p_len = len;
#line 194
  return (char_type);
}
}
#line 206 "/home/june/repo/benchmarks/collector/temp/rhash-1.3.1/hash_check.c"
static unsigned char test_hash_string(char **ptr , char *end , int *p_len ) 
{ 
  int len ;
  int char_type ;
  int tmp ;
  unsigned char hash_type ;
  int pow ;
  int tmp___0 ;
  int code ;

  {
  {
#line 208
  len = 0;
#line 209
  tmp = detect_hash_type(ptr, end, & len);
#line 209
  char_type = tmp;
#line 210
  hash_type = (unsigned char)0;
  }
#line 212
  if (char_type & 1) {
#line 212
    if ((len & 7) == 0) {
#line 212
      if (len <= 256) {
        {
#line 213
        tmp___0 = __builtin_ctz((unsigned int )(len >> 3));
#line 213
        pow = tmp___0;
#line 214
        code = ((len >> (pow + 4)) << 3) | pow;
        }
#line 215
        if (code < 32) {
#line 215
          if ((1 << code) & 16844317) {
#line 215
            hash_type = (unsigned char )((int )hash_type | 1);
          }
        }
      }
    }
  }
#line 217
  if (char_type & 2) {
#line 217
    if (len == 32) {
#line 218
      hash_type = (unsigned char )((int )hash_type | 2);
    } else
#line 217
    if (len == 39) {
#line 218
      hash_type = (unsigned char )((int )hash_type | 2);
    }
  }
#line 220
  if ((int )hash_type != 0) {
#line 221
    *p_len = len;
  }
#line 223
  return (hash_type);
}
}
#line 231 "/home/june/repo/benchmarks/collector/temp/rhash-1.3.1/hash_check.c"
static int rhash_isspace(char ch ) 
{ 
  unsigned short const   **tmp ;
  int tmp___0 ;

  {
#line 233
  if ((int )((unsigned char )ch) <= 127) {
    {
#line 233
    tmp = __ctype_b_loc();
    }
#line 233
    if ((int const   )*(*tmp + (int )((unsigned char )ch)) & 8192) {
#line 233
      tmp___0 = 1;
    } else {
#line 233
      tmp___0 = 0;
    }
  } else {
#line 233
    tmp___0 = 0;
  }
#line 233
  return (tmp___0);
}
}
#line 265 "/home/june/repo/benchmarks/collector/temp/rhash-1.3.1/hash_check.c"
static int hash_check_find_str(hc_search *search , char const   *format ) 
{ 
  int backward ;
  char buf[20] ;
  char const   *fend ;
  char *tmp ;
  char *begin ;
  char *end ;
  hash_check *hc ;
  hash_value hv ;
  int unsaved_hashval ;
  char const   *search_str ;
  int i ;
  int len ;
  uint64_t file_size ;
  char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int dlen ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  char *tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;

  {
  {
#line 267
  backward = 0;
#line 269
  tmp = strchr(format, '\000');
#line 269
  fend = (char const   *)tmp;
#line 270
  begin = search->begin;
#line 271
  end = search->end;
#line 272
  hc = search->hc;
#line 274
  unsaved_hashval = 0;
#line 275
  memset((void *)(& hv), 0, sizeof(hash_value ));
  }
  {
#line 277
  while (1) {
    while_continue: /* CIL Label */ ;
#line 277
    if (! ((unsigned long )format < (unsigned long )fend)) {
#line 277
      goto while_break;
    }
#line 279
    len = 0;
#line 282
    if (backward) {
      {
#line 283
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 283
        if ((int const   )*(fend + -1) >= 45) {
#line 283
          if (! ((unsigned long )format < (unsigned long )fend)) {
#line 283
            goto while_break___0;
          }
        } else {
#line 283
          goto while_break___0;
        }
#line 283
        fend --;
#line 283
        len ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 284
      if (len == 0) {
#line 284
        fend --;
      }
#line 285
      search_str = fend;
    } else {
#line 287
      search_str = format;
      {
#line 288
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 288
        if ((int const   )*format >= 45) {
#line 288
          if (! ((unsigned long )format < (unsigned long )fend)) {
#line 288
            goto while_break___1;
          }
        } else {
#line 288
          goto while_break___1;
        }
#line 288
        format ++;
#line 288
        len ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 289
      if (len == 0) {
#line 289
        format ++;
      }
    }
#line 291
    if (len > 0) {
#line 292
      if (end - begin < (long )len) {
#line 292
        return (0);
      }
#line 293
      if (backward) {
#line 293
        tmp___0 = end - len;
      } else {
#line 293
        tmp___0 = begin;
      }
      {
#line 293
      tmp___1 = memcmp((void const   *)search_str, (void const   *)tmp___0, (size_t )len);
      }
#line 293
      if (0 != tmp___1) {
#line 293
        return (0);
      }
#line 294
      if (backward) {
#line 294
        end -= len;
      } else {
#line 295
        begin += len;
      }
#line 296
      goto while_continue;
    }
    {
#line 302
    if ((int const   )*search_str == 1) {
#line 302
      goto case_1;
    }
#line 324
    if ((int const   )*search_str == 3) {
#line 324
      goto case_3;
    }
#line 324
    if ((int const   )*search_str == 2) {
#line 324
      goto case_3;
    }
#line 345
    if ((int const   )*search_str == 4) {
#line 345
      goto case_4;
    }
#line 351
    if ((int const   )*search_str == 5) {
#line 351
      goto case_5;
    }
#line 365
    if ((int const   )*search_str == 32) {
#line 365
      goto case_32;
    }
#line 365
    if ((int const   )*search_str == 7) {
#line 365
      goto case_32;
    }
#line 365
    if ((int const   )*search_str == 6) {
#line 365
      goto case_32;
    }
#line 375
    if ((int const   )*search_str == 36) {
#line 375
      goto case_36;
    }
#line 378
    goto switch_default;
    case_1: /* CIL Label */ 
    {
#line 305
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 305
      if ((int )*(begin + len) <= 57) {
#line 305
        if ((int )*(begin + len) >= 48) {
#line 305
          tmp___3 = 1;
        } else
#line 305
        if ((int )*(begin + len) == 45) {
#line 305
          tmp___3 = 1;
        } else {
#line 305
          tmp___3 = 0;
        }
#line 305
        tmp___4 = tmp___3;
      } else {
#line 305
        tmp___4 = (int )*(begin + len) >= 65;
      }
#line 305
      if (! tmp___4) {
#line 305
        goto while_break___2;
      }
#line 306
      if (len >= 20) {
#line 306
        return (0);
      }
      {
#line 307
      tmp___2 = toupper((int )*(begin + len));
#line 307
      buf[len] = (char )tmp___2;
#line 305
      len ++;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
#line 309
    begin += len;
#line 310
    if (len == 0) {
#line 310
      return (0);
    }
#line 311
    buf[len] = (char )'\000';
#line 312
    search->expected_hash_id = 0U;
#line 315
    i = 0;
    {
#line 315
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 315
      if (! (i < 26)) {
#line 315
        goto while_break___3;
      }
      {
#line 316
      tmp___5 = strcmp((char const   *)(buf), hash_info_table[i].name);
      }
#line 316
      if (tmp___5 == 0) {
#line 317
        search->expected_hash_id = (unsigned int )(1 << i);
#line 318
        search->hash_type = 3;
#line 319
        goto while_break___3;
      }
#line 315
      i ++;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 322
    goto switch_break;
    case_3: /* CIL Label */ 
    case_2: /* CIL Label */ 
#line 325
    if (backward) {
      {
#line 326
      hv.format = test_hash_string(& end, begin, & len);
#line 327
      hv.offset = (unsigned short )(end - hc->data);
      }
    } else {
      {
#line 329
      hv.offset = (unsigned short )(begin - hc->data);
#line 330
      hv.format = test_hash_string(& begin, end, & len);
      }
    }
#line 332
    if (! hv.format) {
#line 332
      return (0);
    }
#line 333
    if ((int const   )*search_str == 3) {
      {
#line 335
      tmp___6 = rhash_get_digest_size(search->expected_hash_id);
#line 335
      dlen = tmp___6;
#line 336
      hv.format = (unsigned char )((int )hv.format & search->hash_type);
      }
#line 337
      if (! ((int )hv.format & 1)) {
#line 337
        goto _L;
      } else
#line 337
      if (len != dlen * 2) {
        _L: /* CIL Label */ 
#line 337
        if (! ((int )hv.format & 2)) {
#line 339
          return (0);
        } else
#line 337
        if (len != (dlen * 8 + 4) / 5) {
#line 339
          return (0);
        }
      }
#line 340
      hv.hash_id = search->expected_hash_id;
    } else {
#line 341
      hv.hash_id = 0U;
    }
#line 342
    hv.length = (unsigned char )len;
#line 343
    unsaved_hashval = 1;
#line 344
    goto switch_break;
    case_4: /* CIL Label */ 
    {
#line 346
    search->url_name = begin;
#line 347
    search->url_length = strcspn((char const   *)begin, "?&|");
    }
#line 348
    if (search->url_length == 0UL) {
#line 348
      return (0);
    }
#line 349
    begin += search->url_length;
#line 350
    goto switch_break;
    case_5: /* CIL Label */ 
#line 353
    file_size = (uint64_t )0L;
    {
#line 354
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 354
      if (48 <= (int )*begin) {
#line 354
        if (! ((int )*begin <= 57)) {
#line 354
          goto while_break___4;
        }
      } else {
#line 354
        goto while_break___4;
      }
#line 355
      file_size = file_size * 10UL + (uint64_t )((int )*begin - 48);
#line 354
      begin ++;
#line 354
      len ++;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 357
    if (len == 0) {
#line 357
      return (0);
    } else {
#line 359
      hc->file_size = file_size;
#line 360
      hc->flags |= 1U;
    }
#line 362
    goto switch_break;
    case_32: /* CIL Label */ 
    case_7: /* CIL Label */ 
    case_6: /* CIL Label */ 
#line 366
    if (backward) {
      {
#line 366
      while (1) {
        while_continue___5: /* CIL Label */ ;
#line 366
        if ((unsigned long )begin < (unsigned long )end) {
          {
#line 366
          tmp___7 = rhash_isspace(*(end + -1));
          }
#line 366
          if (! tmp___7) {
#line 366
            goto while_break___5;
          }
        } else {
#line 366
          goto while_break___5;
        }
#line 366
        end --;
#line 366
        len ++;
      }
      while_break___5: /* CIL Label */ ;
      }
    } else {
      {
#line 367
      while (1) {
        while_continue___6: /* CIL Label */ ;
        {
#line 367
        tmp___8 = rhash_isspace(*begin);
        }
#line 367
        if (tmp___8) {
#line 367
          if (! ((unsigned long )begin < (unsigned long )end)) {
#line 367
            goto while_break___6;
          }
        } else {
#line 367
          goto while_break___6;
        }
#line 367
        begin ++;
#line 367
        len ++;
      }
      while_break___6: /* CIL Label */ ;
      }
    }
#line 369
    if ((int const   )*search_str != 32) {
#line 369
      if (len == 0) {
#line 372
        if ((int const   )*search_str == 6) {
#line 372
          return (0);
        } else
#line 372
        if ((unsigned long )begin < (unsigned long )end) {
#line 372
          return (0);
        }
      }
    }
#line 374
    goto switch_break;
    case_36: /* CIL Label */ 
#line 376
    backward = 1;
#line 377
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 379
    if (backward) {
#line 379
      end --;
#line 379
      tmp___10 = (int )*end;
    } else {
#line 379
      tmp___9 = begin;
#line 379
      begin ++;
#line 379
      tmp___10 = (int )*tmp___9;
    }
#line 379
    if (tmp___10 != (int )*search_str) {
#line 379
      return (0);
    }
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 383
  if (unsaved_hashval) {
#line 383
    if (hc->hashes_num < 32) {
#line 384
      tmp___11 = hc->hashes_num;
#line 384
      (hc->hashes_num) ++;
#line 384
      hc->hashes[tmp___11] = hv;
    }
  }
#line 386
  search->begin = begin;
#line 387
  search->end = end;
#line 389
  return (1);
}
}
#line 413 "/home/june/repo/benchmarks/collector/temp/rhash-1.3.1/hash_check.c"
int hash_check_parse_line(char *line , hash_check *hashes , int check_eol ) 
{ 
  hc_search hs ;
  char *le ;
  char *tmp ;
  char *url_name ;
  size_t url_length ;
  int single_hash ;
  int reversed ;
  int bad ;
  int i ;
  int j ;
  int tmp___0 ;
  int tmp___1 ;
  char *next ;
  char *tmp___2 ;
  char *param_end ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *hf_end ;
  int tmp___5 ;
  char const   *urn ;
  char const   *tmp___6 ;
  size_t len ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  hash_value tmp___17 ;
  hash_value *hv ;
  char *hash_str ;
  unsigned int mask___0 ;
  unsigned int tmp___18 ;
  unsigned int tmp___19 ;

  {
  {
#line 416
  tmp = strchr((char const   *)line, '\000');
#line 416
  le = tmp;
#line 417
  url_name = (char *)((void *)0);
#line 418
  url_length = (size_t )0;
#line 419
  single_hash = 0;
#line 420
  reversed = 0;
#line 421
  bad = 0;
  }
#line 425
  if ((int )*(line + 0) == 0) {
#line 425
    return (0);
  } else
#line 425
  if ((int )*(le + -1) != 10) {
#line 425
    if (check_eol) {
#line 425
      return (0);
    }
  }
  {
#line 430
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 430
    tmp___0 = rhash_isspace(*(le + -1));
    }
#line 430
    if (tmp___0) {
#line 430
      if (! ((unsigned long )le > (unsigned long )line)) {
#line 430
        goto while_break;
      }
    } else {
#line 430
      goto while_break;
    }
#line 430
    le --;
#line 430
    *le = (char)0;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 432
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 432
    tmp___1 = rhash_isspace(*line);
    }
#line 432
    if (! tmp___1) {
#line 432
      goto while_break___0;
    }
#line 432
    line ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 434
  memset((void *)(& hs), 0, sizeof(hs));
#line 435
  hs.begin = line;
#line 436
  hs.end = le;
#line 437
  hs.hc = hashes;
#line 439
  memset((void *)hashes, 0, sizeof(hash_check ));
#line 440
  hashes->data = line;
#line 441
  hashes->file_size = (uint64_t )-1;
#line 443
  tmp___16 = strncmp((char const   *)line, "magnet:?", (size_t )8);
  }
#line 443
  if (tmp___16 == 0) {
#line 444
    hs.begin += 8;
    {
#line 447
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 448
      tmp___2 = strchr((char const   *)hs.begin, '&');
#line 448
      next = tmp___2;
      }
#line 449
      if (next) {
#line 449
        tmp___3 = next;
#line 449
        next ++;
#line 449
        tmp___4 = tmp___3;
      } else {
#line 449
        tmp___4 = hs.end;
      }
#line 449
      param_end = tmp___4;
#line 452
      hs.begin += 3;
#line 452
      if ((unsigned long )hs.begin < (unsigned long )param_end) {
        {
#line 454
        if (((((unsigned int )*(hs.begin + -3) << 16) | ((unsigned int )*(hs.begin + -2) << 8)) | (unsigned int )*(hs.begin + -1)) == (((100U << 16) | (110U << 8)) | 61U)) {
#line 454
          goto case_exp;
        }
#line 458
        if (((((unsigned int )*(hs.begin + -3) << 16) | ((unsigned int )*(hs.begin + -2) << 8)) | (unsigned int )*(hs.begin + -1)) == (((120U << 16) | (108U << 8)) | 61U)) {
#line 458
          goto case_exp___0;
        }
#line 462
        if (((((unsigned int )*(hs.begin + -3) << 16) | ((unsigned int )*(hs.begin + -2) << 8)) | (unsigned int )*(hs.begin + -1)) == (((120U << 16) | (116U << 8)) | 61U)) {
#line 462
          goto case_exp___1;
        }
#line 453
        goto switch_break;
        case_exp: /* CIL Label */ 
#line 455
        url_name = hs.begin;
#line 456
        url_length = (size_t )(param_end - hs.begin);
#line 457
        goto switch_break;
        case_exp___0: /* CIL Label */ 
        {
#line 459
        tmp___5 = hash_check_find_str(& hs, "\005");
        }
#line 459
        if (! tmp___5) {
#line 459
          bad = 1;
        }
#line 460
        if ((unsigned long )hs.begin != (unsigned long )param_end) {
#line 460
          bad = 1;
        }
#line 461
        goto switch_break;
        case_exp___1: /* CIL Label */ 
#line 464
        hf_end = param_end - 1;
        {
#line 464
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 464
          if ((int )*hf_end != 58) {
#line 464
            if (! ((unsigned long )hf_end > (unsigned long )hs.begin)) {
#line 464
              goto while_break___2;
            }
          } else {
#line 464
            goto while_break___2;
          }
#line 464
          hf_end --;
        }
        while_break___2: /* CIL Label */ ;
        }
#line 467
        hs.begin += 4;
#line 467
        if ((unsigned long )hs.begin >= (unsigned long )hf_end) {
#line 467
          return (0);
        }
#line 468
        if (((((117U << 24) | (114U << 16)) | (110U << 8)) | 58U) != (((((unsigned int )*(hs.begin + -4) << 24) | ((unsigned int )*(hs.begin + -3) << 16)) | ((unsigned int )*(hs.begin + -2) << 8)) | (unsigned int )*(hs.begin + -1))) {
#line 469
          return (0);
        }
#line 472
        i = 0;
        {
#line 472
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 472
          if (! (i < 26)) {
#line 472
            goto while_break___3;
          }
          {
#line 473
          tmp___6 = rhash_get_magnet_name((unsigned int )(1 << i));
#line 473
          urn = tmp___6;
#line 474
          len = (size_t )(hf_end - hs.begin);
#line 475
          tmp___7 = strncmp((char const   *)hs.begin, urn, len);
          }
#line 475
          if (tmp___7 == 0) {
#line 475
            if ((int const   )*(urn + len) == 0) {
#line 476
              goto while_break___3;
            }
          }
#line 472
          i ++;
        }
        while_break___3: /* CIL Label */ ;
        }
#line 478
        if (i >= 26) {
#line 479
          if (opt.flags & 512U) {
            {
#line 480
            *hf_end = (char )'\000';
#line 481
            log_warning("unknown hash in magnet link: %s\n", hs.begin);
            }
          }
#line 483
          return (0);
        }
        {
#line 486
        hs.begin = hf_end + 1;
#line 487
        hs.expected_hash_id = (unsigned int )(1 << i);
#line 488
        hs.hash_type = 3;
#line 489
        tmp___8 = hash_check_find_str(& hs, "\003");
        }
#line 489
        if (! tmp___8) {
#line 489
          bad = 1;
        }
#line 490
        if ((unsigned long )hs.begin != (unsigned long )param_end) {
#line 490
          bad = 1;
        }
#line 491
        goto switch_break;
        switch_break: /* CIL Label */ ;
        }
      }
#line 496
      if (! bad) {
#line 496
        if (next) {
#line 496
          hs.begin = next;
        } else {
#line 497
          goto while_break___1;
        }
      } else {
#line 497
        goto while_break___1;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
#line 499
    if (! url_name) {
#line 499
      bad = 1;
    }
  } else {
    {
#line 500
    tmp___15 = strncmp((char const   *)line, "ed2k://|file|", (size_t )13);
    }
#line 500
    if (tmp___15 == 0) {
      {
#line 501
      hs.begin += 13;
#line 502
      hs.expected_hash_id = 128U;
#line 503
      hs.hash_type = 1;
#line 504
      tmp___9 = hash_check_find_str(& hs, "\004|\005|\003|");
      }
#line 504
      if (tmp___9) {
#line 505
        url_name = hs.url_name;
#line 506
        url_length = hs.url_length;
      } else {
#line 507
        bad = 1;
      }
      {
#line 510
      hs.expected_hash_id = 256U;
#line 511
      hs.hash_type = 3;
#line 512
      hash_check_find_str(& hs, "h=\003|");
      }
    } else {
      {
#line 514
      tmp___14 = hash_check_find_str(& hs, "\001 ( $ ) = \003");
      }
#line 514
      if (! tmp___14) {
        {
#line 516
        tmp___13 = hash_check_find_str(& hs, "$\006\002");
        }
#line 516
        if (tmp___13) {
          {
#line 517
          while (1) {
            while_continue___4: /* CIL Label */ ;
            {
#line 517
            tmp___10 = hash_check_find_str(& hs, "$\006\002");
            }
#line 517
            if (! tmp___10) {
#line 517
              goto while_break___4;
            }
          }
          while_break___4: /* CIL Label */ ;
          }
#line 518
          if (hashes->hashes_num > 1) {
#line 518
            reversed = 1;
          }
        } else {
          {
#line 519
          tmp___12 = hash_check_find_str(& hs, "\002\a");
          }
#line 519
          if (tmp___12) {
#line 520
            if ((unsigned long )hs.begin == (unsigned long )hs.end) {
#line 522
              single_hash = 1;
            } else {
              {
#line 524
              while (1) {
                while_continue___5: /* CIL Label */ ;
                {
#line 524
                tmp___11 = hash_check_find_str(& hs, "\002\006");
                }
#line 524
                if (! tmp___11) {
#line 524
                  goto while_break___5;
                }
              }
              while_break___5: /* CIL Label */ ;
              }
#line 526
              if ((int )*(hs.begin) == 42) {
#line 526
                (hs.begin) ++;
              }
            }
          } else {
#line 528
            bad = 1;
          }
        }
      }
#line 530
      if ((unsigned long )hs.begin >= (unsigned long )hs.end) {
#line 530
        if (! single_hash) {
#line 530
          bad = 1;
        }
      }
    }
  }
#line 533
  if (bad) {
    {
#line 534
    log_warning("can\'t parse line: %s\n", line);
    }
#line 535
    return (0);
  }
#line 541
  if (url_name) {
    {
#line 542
    hashes->file_path = url_name;
#line 543
    *(url_name + url_length) = (char )'\000';
#line 544
    urldecode(url_name);
#line 545
    process_backslashes(url_name);
    }
  } else
#line 546
  if (! single_hash) {
    {
#line 548
    hashes->file_path = hs.begin;
#line 549
    *(hs.end) = (char )'\000';
#line 550
    process_backslashes(hs.begin);
    }
  }
#line 553
  if (reversed) {
#line 555
    i = 0;
#line 555
    j = hashes->hashes_num - 1;
    {
#line 555
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 555
      if (! (i < j)) {
#line 555
        goto while_break___6;
      }
#line 556
      tmp___17 = hashes->hashes[i];
#line 557
      hashes->hashes[i] = hashes->hashes[j];
#line 558
      hashes->hashes[j] = tmp___17;
#line 555
      i ++;
#line 555
      j --;
    }
    while_break___6: /* CIL Label */ ;
    }
  }
#line 563
  i = 0;
  {
#line 563
  while (1) {
    while_continue___7: /* CIL Label */ ;
#line 563
    if (! (i < hashes->hashes_num)) {
#line 563
      goto while_break___7;
    }
#line 564
    hv = & hashes->hashes[i];
#line 565
    hash_str = hashes->data + (int )hv->offset;
#line 567
    if (hv->hash_id == 0U) {
#line 569
      mask___0 = 0U;
#line 570
      if ((int )hv->format & 1) {
        {
#line 571
        tmp___18 = hash_check_mask_by_digest_size((int )hv->length >> 1);
#line 571
        mask___0 |= tmp___18;
        }
      }
#line 573
      if ((int )hv->format & 2) {
        {
#line 575
        tmp___19 = hash_check_mask_by_digest_size(((int )hv->length * 5) / 8);
#line 575
        mask___0 |= tmp___19;
        }
      }
#line 578
      if ((mask___0 & opt.sum_flags) != 0U) {
#line 578
        mask___0 &= opt.sum_flags;
      }
#line 579
      hv->hash_id = mask___0;
    }
#line 581
    hashes->hash_mask |= hv->hash_id;
#line 584
    j = 0;
    {
#line 584
    while (1) {
      while_continue___8: /* CIL Label */ ;
#line 584
      if (! (j < (int )hv->length)) {
#line 584
        goto while_break___8;
      }
#line 585
      if ((int )*(hash_str + j) >= 97) {
#line 585
        *(hash_str + j) = (char )((int )*(hash_str + j) & -33);
      }
#line 584
      j ++;
    }
    while_break___8: /* CIL Label */ ;
    }
#line 587
    *(hash_str + j) = (char )'\000';
#line 563
    i ++;
  }
  while_break___7: /* CIL Label */ ;
  }
#line 590
  return (1);
}
}
#line 606 "/home/june/repo/benchmarks/collector/temp/rhash-1.3.1/hash_check.c"
static int frhexcmp(void const   *mem1 , void const   *mem2 , size_t size ) 
{ 
  char const   *p1 ;
  char const   *p2 ;
  char const   *pe ;
  int tmp ;

  {
  {
#line 609
  tmp = memcmp(mem1, mem2, size);
  }
#line 609
  if (tmp == 0) {
#line 609
    return (0);
  }
#line 610
  if ((size & 1UL) != 0UL) {
#line 610
    return (1);
  }
#line 612
  p1 = (char const   *)mem1;
#line 612
  p2 = ((char const   *)mem2 + size) - 2;
#line 613
  pe = (char const   *)mem1 + size / 2UL;
  {
#line 613
  while (1) {
    while_continue: /* CIL Label */ ;
#line 613
    if (! ((unsigned long )p1 < (unsigned long )pe)) {
#line 613
      goto while_break;
    }
#line 614
    if ((int const   )*(p1 + 0) != (int const   )*(p2 + 0)) {
#line 614
      return (1);
    } else
#line 614
    if ((int const   )*(p1 + 1) != (int const   )*(p2 + 1)) {
#line 614
      return (1);
    }
#line 613
    p1 += 2;
#line 613
    p2 -= 2;
  }
  while_break: /* CIL Label */ ;
  }
#line 616
  return (0);
}
}
#line 628 "/home/june/repo/benchmarks/collector/temp/rhash-1.3.1/hash_check.c"
int hash_check_verify(hash_check *hashes , struct rhash_context *ctx ) 
{ 
  unsigned int unverified_mask ;
  unsigned int hid ;
  unsigned int printed ;
  char hex[132] ;
  char b32[104] ;
  int j ;
  unsigned char *c ;
  rhash_uptr_t tmp ;
  unsigned int crc32_be ;
  hash_value *hv ;
  char *hash_str ;
  char *hash_orig ;
  int dgst_size ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 637
  if ((hashes->flags & 1U) != 0U) {
#line 637
    if ((unsigned long long )hashes->file_size != ctx->msg_size) {
#line 639
      hashes->flags |= 4U;
    }
  }
#line 643
  if ((hashes->flags & 2U) != 0U) {
    {
#line 644
    tmp = rhash_transmit(1U, (void *)ctx, (rhash_uptr_t )1, (rhash_uptr_t )0);
#line 644
    c = (unsigned char *)((void *)((char *)0 + tmp));
#line 646
    crc32_be = ((((unsigned int )*(c + 0) << 24) | ((unsigned int )*(c + 1) << 16)) | ((unsigned int )*(c + 2) << 8)) | (unsigned int )*(c + 3);
    }
#line 648
    if (crc32_be != hashes->embedded_crc32_be) {
#line 649
      hashes->flags |= 8U;
    }
  }
#line 654
  if (hashes->hashes_num == 0) {
#line 654
    return (! (hashes->flags & 28U));
  }
#line 656
  unverified_mask = (unsigned int )((1 << hashes->hashes_num) - 1);
#line 658
  hid = 1U;
  {
#line 658
  while (1) {
    while_continue: /* CIL Label */ ;
#line 658
    if (! (hid <= 67108863U)) {
#line 658
      goto while_break;
    }
#line 659
    if ((hashes->hash_mask & hid) == 0U) {
#line 659
      goto __Cont;
    }
#line 660
    printed = 0U;
#line 662
    j = 0;
    {
#line 662
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 662
      if (! (j < hashes->hashes_num)) {
#line 662
        goto while_break___0;
      }
#line 663
      hv = & hashes->hashes[j];
#line 668
      if (! (unverified_mask & (unsigned int )(1 << j))) {
#line 668
        goto __Cont___0;
      } else
#line 668
      if (! (hv->hash_id & hid)) {
#line 668
        goto __Cont___0;
      }
      {
#line 669
      dgst_size = rhash_get_digest_size(hid);
      }
#line 670
      if ((int )hv->length == dgst_size * 2) {
#line 675
        if ((printed & 1U) == 0U) {
          {
#line 676
          rhash_print(hex, ctx, hid, 10);
#line 677
          printed |= 1U;
          }
        }
#line 679
        hash_str = hex;
      } else {
#line 686
        if ((printed & 2U) == 0U) {
          {
#line 687
          rhash_print(b32, ctx, hid, 11);
#line 688
          printed |= 2U;
          }
        }
#line 690
        hash_str = b32;
      }
#line 692
      hash_orig = hashes->data + (int )hv->offset;
#line 694
      if ((hid & 6144U) != 0U) {
        {
#line 695
        tmp___0 = frhexcmp((void const   *)hash_orig, (void const   *)hash_str, (size_t )hv->length);
        }
#line 695
        if (tmp___0 != 0) {
#line 695
          goto __Cont___0;
        }
      } else {
        {
#line 697
        tmp___1 = memcmp((void const   *)hash_orig, (void const   *)hash_str, (size_t )hv->length);
        }
#line 697
        if (tmp___1 != 0) {
#line 697
          goto __Cont___0;
        }
      }
#line 700
      unverified_mask &= (unsigned int )(~ (1 << j));
#line 701
      hashes->found_hash_ids |= hid;
#line 704
      if (unverified_mask == 0U) {
#line 704
        goto hc_verify_exit;
      }
      __Cont___0: /* CIL Label */ 
#line 662
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    __Cont: /* CIL Label */ 
#line 658
    hid <<= 1;
  }
  while_break: /* CIL Label */ ;
  }
  hc_verify_exit: 
#line 709
  hashes->wrong_hashes = unverified_mask;
#line 710
  if (unverified_mask != 0U) {
#line 710
    hashes->flags |= 16U;
  }
#line 711
  return (! (hashes->flags & 28U));
}
}
#line 149 "/usr/include/dirent.h"
extern int ( __attribute__((__nonnull__(1))) closedir)(DIR *__dirp ) ;
#line 40 "/home/june/repo/benchmarks/collector/temp/rhash-1.3.1/find_file.h"
int find_file(file_t *start_dir , file_search_data *options ) ;
#line 41 "/home/june/repo/benchmarks/collector/temp/rhash-1.3.1/find_file.c"
file_search_data *create_file_search_data(rsh_tchar **paths , size_t count , int max_depth ) 
{ 
  size_t i ;
  file_search_data *data ;
  void *tmp ;
  file_t file ;
  int tmp___0 ;
  void *tmp___1 ;

  {
  {
#line 45
  tmp = rhash_malloc(sizeof(file_search_data ), "/home/june/repo/benchmarks/collector/temp/rhash-1.3.1/find_file.c",
                     45);
#line 45
  data = (file_search_data *)tmp;
#line 46
  memset((void *)data, 0, sizeof(file_search_data ));
#line 47
  rsh_blocks_vector_init(& data->root_files);
#line 48
  data->max_depth = max_depth;
#line 155
  i = (size_t )0;
  }
  {
#line 155
  while (1) {
    while_continue: /* CIL Label */ ;
#line 155
    if (! (i < count)) {
#line 155
      goto while_break;
    }
    {
#line 158
    file.path = rhash_strdup((char const   *)*(paths + i), "/home/june/repo/benchmarks/collector/temp/rhash-1.3.1/find_file.c",
                             158);
#line 159
    file.wpath = (wchar_t *)0;
#line 160
    file.size = (uint64_t )0;
#line 160
    file.mtime = file.size;
    }
#line 162
    if ((int )*(file.path + 0) == 45) {
#line 162
      if ((int )*(file.path + 1) == 0) {
#line 164
        file.mode = 32U;
      } else {
#line 162
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
      {
#line 166
      tmp___0 = rsh_file_stat2(& file, 1);
      }
#line 166
      if (tmp___0 < 0) {
        {
#line 167
        log_file_error((char const   *)file.path);
#line 168
        free((void *)file.path);
        }
#line 169
        goto __Cont;
      }
    }
#line 172
    file.mode |= 16U;
#line 173
    if (data->root_files.size % 256UL == 0UL) {
      {
#line 173
      tmp___1 = rhash_malloc(sizeof(file_t ) * 256UL, "/home/june/repo/benchmarks/collector/temp/rhash-1.3.1/find_file.c",
                             173);
#line 173
      rsh_vector_add_ptr(& data->root_files.blocks, tmp___1);
      }
    }
    {
#line 173
    memcpy((void */* __restrict  */)((unsigned char *)*(data->root_files.blocks.array + data->root_files.size / 256UL) + sizeof(file_t ) * (data->root_files.size % 256UL)),
           (void const   */* __restrict  */)(& file), sizeof(file_t ));
#line 173
    (data->root_files.size) ++;
    }
    __Cont: /* CIL Label */ 
#line 155
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 176
  return (data);
}
}
#line 182 "/home/june/repo/benchmarks/collector/temp/rhash-1.3.1/find_file.c"
void destroy_file_search_data(file_search_data *data ) 
{ 
  size_t i ;
  file_t *file ;

  {
#line 186
  i = (size_t )0;
  {
#line 186
  while (1) {
    while_continue: /* CIL Label */ ;
#line 186
    if (! (i < data->root_files.size)) {
#line 186
      goto while_break;
    }
    {
#line 188
    file = (file_t *)*(data->root_files.blocks.array + i / 256UL) + i % 256UL;
#line 189
    rsh_file_cleanup(file);
#line 186
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 191
  rsh_blocks_vector_destroy(& data->root_files);
  }
#line 192
  return;
}
}
#line 194 "/home/june/repo/benchmarks/collector/temp/rhash-1.3.1/find_file.c"
void scan_files(file_search_data *data ) 
{ 
  size_t i ;
  size_t count ;
  file_t *file ;
  int *tmp ;

  {
#line 197
  count = data->root_files.size;
#line 199
  i = (size_t )0;
  {
#line 199
  while (1) {
    while_continue: /* CIL Label */ ;
#line 199
    if (i < count) {
#line 199
      if (! (! (data->options & 16))) {
#line 199
        goto while_break;
      }
    } else {
#line 199
      goto while_break;
    }
#line 201
    file = (file_t *)*(data->root_files.blocks.array + i / 256UL) + i % 256UL;
#line 205
    if (file->mode & 1U) {
#line 206
      if (data->max_depth != 0) {
        {
#line 207
        find_file(file, data);
        }
      } else
#line 208
      if ((data->options & 8) != 0) {
        {
#line 209
        tmp = __errno_location();
#line 209
        *tmp = 21;
#line 210
        log_file_error((char const   *)file->path);
        }
      }
#line 212
      goto __Cont;
    } else {
      {
#line 215
      (*(data->call_back))(file, data->call_back_data);
      }
    }
    __Cont: /* CIL Label */ 
#line 199
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 218
  return;
}
}
#line 238 "/home/june/repo/benchmarks/collector/temp/rhash-1.3.1/find_file.c"
static dir_entry *dir_entry_new(dir_entry *next , char *filename , unsigned int type ) 
{ 
  dir_entry *e ;
  void *tmp ;

  {
  {
#line 240
  tmp = malloc(sizeof(dir_entry ));
#line 240
  e = (dir_entry *)tmp;
  }
#line 241
  if (! e) {
#line 241
    return ((dir_entry *)((void *)0));
  }
#line 242
  if (filename) {
    {
#line 243
    e->filename = rhash_strdup((char const   *)filename, "/home/june/repo/benchmarks/collector/temp/rhash-1.3.1/find_file.c",
                               243);
    }
#line 244
    if (! e->filename) {
      {
#line 245
      free((void *)e);
      }
#line 246
      return ((dir_entry *)((void *)0));
    }
  } else {
#line 249
    e->filename = (char *)((void *)0);
  }
#line 251
  e->next = next;
#line 252
  e->type = type;
#line 253
  return (e);
}
}
#line 264 "/home/june/repo/benchmarks/collector/temp/rhash-1.3.1/find_file.c"
static dir_entry *dir_entry_insert(dir_entry **at , char *filename , unsigned int type ) 
{ 
  dir_entry *e ;
  dir_entry *tmp ;

  {
  {
#line 266
  tmp = dir_entry_new(*at, filename, type);
#line 266
  e = tmp;
  }
#line 267
  if (e) {
#line 267
    *at = e;
  }
#line 268
  return (e);
}
}
#line 276 "/home/june/repo/benchmarks/collector/temp/rhash-1.3.1/find_file.c"
static void dir_entry_drop_head(dir_entry **p ) 
{ 
  dir_entry *e ;

  {
  {
#line 278
  e = *p;
#line 279
  *p = e->next;
#line 280
  free((void *)e->filename);
#line 281
  free((void *)e);
  }
#line 282
  return;
}
}
#line 301 "/home/june/repo/benchmarks/collector/temp/rhash-1.3.1/find_file.c"
int find_file(file_t *start_dir , file_search_data *options ) 
{ 
  dir_entry *dirs_stack ;
  dir_iterator *it ;
  int level ;
  int max_depth ;
  int flags ;
  file_t file ;
  int *tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  dir_entry **insert_at ;
  char *dir_path ;
  DIR *dp ;
  struct dirent *de ;
  int tmp___2 ;
  int res ;
  dir_entry *tmp___3 ;
  int tmp___4 ;

  {
#line 303
  dirs_stack = (dir_entry *)((void *)0);
#line 305
  level = 0;
#line 306
  max_depth = options->max_depth;
#line 307
  flags = options->options;
#line 310
  if (max_depth < 0) {
#line 311
    max_depth = 63;
  } else
#line 310
  if (max_depth >= 64) {
#line 311
    max_depth = 63;
  }
#line 315
  if (! max_depth) {
#line 315
    return (0);
  }
#line 317
  if (! (start_dir->mode & 1U)) {
    {
#line 318
    tmp = __errno_location();
#line 318
    *tmp = 20;
    }
#line 319
    return (-1);
  }
#line 323
  if ((flags & 5) == 0) {
    {
#line 324
    tmp___0 = (*(options->call_back))(start_dir, options->call_back_data);
    }
#line 324
    if (! tmp___0) {
#line 325
      return (0);
    }
  }
  {
#line 329
  tmp___1 = malloc(65UL * sizeof(dir_iterator ));
#line 329
  it = (dir_iterator *)tmp___1;
  }
#line 330
  if (! it) {
#line 331
    return (-1);
  }
  {
#line 335
  (it + 0)->left = 1;
#line 336
  (it + 0)->dir_path = (char *)0;
#line 338
  memset((void *)(& file), 0, sizeof(file));
  }
  {
#line 340
  while (1) {
    while_continue: /* CIL Label */ ;
#line 340
    if (! (! (options->options & 16))) {
#line 340
      goto while_break;
    }
    {
#line 348
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 348
      ((it + level)->left) --;
#line 348
      if (! ((it + level)->left < 0)) {
#line 348
        goto while_break___0;
      }
      {
#line 350
      free((void *)(it + level)->dir_path);
#line 352
      level --;
      }
#line 352
      if (level < 0) {
        {
#line 355
        free((void *)it);
        }
#line 356
        return (0);
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 362
    if (level) {
      {
#line 364
      dir_path = make_path((char const   *)(it + level)->dir_path, (char const   *)dirs_stack->filename);
#line 365
      dir_entry_drop_head(& dirs_stack);
      }
    } else {
      {
#line 368
      dir_path = rhash_strdup((char const   *)start_dir->path, "/home/june/repo/benchmarks/collector/temp/rhash-1.3.1/find_file.c",
                              368);
      }
    }
#line 371
    if (! dir_path) {
#line 371
      goto while_continue;
    }
#line 374
    level ++;
#line 376
    (it + level)->left = 0;
#line 377
    (it + level)->dir_path = dir_path;
#line 379
    if ((flags & 5) == 1) {
      {
#line 381
      file.path = rhash_strdup((char const   *)dir_path, "/home/june/repo/benchmarks/collector/temp/rhash-1.3.1/find_file.c",
                               381);
#line 382
      rsh_file_stat2(& file, 1);
#line 385
      tmp___2 = (*(options->call_back))(& file, options->call_back_data);
      }
#line 385
      if (! tmp___2) {
        {
#line 386
        rsh_file_cleanup(& file);
        }
#line 387
        goto while_continue;
      }
    }
    {
#line 392
    dp = opendir((char const   *)dir_path);
    }
#line 393
    if (! dp) {
#line 393
      goto while_continue;
    }
#line 395
    insert_at = & dirs_stack;
    {
#line 397
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 397
      de = readdir(dp);
      }
#line 397
      if (! ((unsigned long )de != (unsigned long )((void *)0))) {
#line 397
        goto while_break___1;
      }
#line 402
      if ((int )de->d_name[0] == 46) {
#line 402
        if (! de->d_name[1]) {
#line 402
          goto while_continue___1;
        } else
#line 402
        if ((int )de->d_name[1] == 46) {
#line 402
          if (! de->d_name[2]) {
#line 402
            goto while_continue___1;
          }
        }
      }
      {
#line 404
      file.path = make_path((char const   *)dir_path, (char const   *)(de->d_name));
      }
#line 405
      if (! file.path) {
#line 405
        goto while_continue___1;
      }
      {
#line 407
      res = rsh_file_stat2(& file, 1);
      }
#line 408
      if (res >= 0) {
#line 410
        if (file.mode & 1U) {
#line 410
          if (flags & 5) {
#line 411
            res = 1;
          } else {
            {
#line 414
            res = (*(options->call_back))(& file, options->call_back_data);
            }
          }
        } else {
          {
#line 414
          res = (*(options->call_back))(& file, options->call_back_data);
          }
        }
#line 419
        if (file.mode & 1U) {
#line 419
          if (res) {
#line 419
            if (level < max_depth) {
              {
#line 421
              tmp___3 = dir_entry_insert(insert_at, de->d_name, file.mode);
              }
#line 421
              if (tmp___3) {
#line 423
                insert_at = & (*insert_at)->next;
#line 424
                ((it + level)->left) ++;
              }
            }
          }
        }
      } else
#line 427
      if (options->options & 8) {
        {
#line 429
        log_file_error((char const   *)file.path);
        }
      }
      {
#line 431
      rsh_file_cleanup(& file);
      }
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 433
    closedir(dp);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 436
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 436
    if (! dirs_stack) {
#line 436
      goto while_break___2;
    }
    {
#line 437
    dir_entry_drop_head(& dirs_stack);
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 439
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 439
    if (! level) {
#line 439
      goto while_break___3;
    }
    {
#line 440
    tmp___4 = level;
#line 440
    level --;
#line 440
    free((void *)(it + tmp___4)->dir_path);
    }
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 442
  free((void *)it);
#line 443
  rsh_file_cleanup(& file);
  }
#line 444
  return (0);
}
}
