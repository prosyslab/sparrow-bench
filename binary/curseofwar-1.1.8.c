/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 52 "/home/june/repo/benchmarks/collector/temp/curseofwar-1.1.8/grid.h"
enum tile_class {
    abyss = 0,
    mountain = 1,
    mine = 2,
    grassland = 3,
    village = 4,
    town = 5,
    castle = 6
} ;
#line 64
enum stencil {
    st_rhombus = 0,
    st_rect = 1,
    st_hex = 2
} ;
#line 81 "/home/june/repo/benchmarks/collector/temp/curseofwar-1.1.8/grid.h"
struct tile {
   enum tile_class cl ;
   int pl ;
   int units[8][1] ;
};
#line 95 "/home/june/repo/benchmarks/collector/temp/curseofwar-1.1.8/grid.h"
struct loc {
   int i ;
   int j ;
};
#line 108 "/home/june/repo/benchmarks/collector/temp/curseofwar-1.1.8/grid.h"
struct grid {
   int width ;
   int height ;
   struct tile tiles[40][29] ;
};
#line 159 "/home/june/repo/benchmarks/collector/temp/curseofwar-1.1.8/grid.h"
struct flag_grid {
   int width ;
   int height ;
   int flag[40][29] ;
   int call[40][29] ;
};
#line 172 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __ssize_t;
#line 189 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __socklen_t;
#line 109 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __ssize_t ssize_t;
#line 33 "/usr/include/x86_64-linux-gnu/bits/socket.h"
typedef __socklen_t socklen_t;
#line 28 "/usr/include/x86_64-linux-gnu/bits/sockaddr.h"
typedef unsigned short sa_family_t;
#line 149 "/usr/include/x86_64-linux-gnu/bits/socket.h"
struct sockaddr {
   sa_family_t sa_family ;
   char sa_data[14] ;
};
#line 162 "/usr/include/x86_64-linux-gnu/bits/socket.h"
struct sockaddr_storage {
   sa_family_t ss_family ;
   unsigned long __ss_align ;
   char __ss_padding[128UL - 2UL * sizeof(unsigned long )] ;
};
#line 48 "/usr/include/stdint.h"
typedef unsigned char uint8_t;
#line 49 "/usr/include/stdint.h"
typedef unsigned short uint16_t;
#line 51 "/usr/include/stdint.h"
typedef unsigned int uint32_t;
#line 567 "/usr/include/netdb.h"
struct addrinfo {
   int ai_flags ;
   int ai_family ;
   int ai_socktype ;
   int ai_protocol ;
   socklen_t ai_addrlen ;
   struct sockaddr *ai_addr ;
   char *ai_canonname ;
   struct addrinfo *ai_next ;
};
#line 46 "/home/june/repo/benchmarks/collector/temp/curseofwar-1.1.8/common.h"
enum config_speed {
    sp_pause = 0,
    sp_slowest = 1,
    sp_slower = 2,
    sp_slow = 3,
    sp_normal = 4,
    sp_fast = 5,
    sp_faster = 6,
    sp_fastest = 7
} ;
#line 49
enum config_dif {
    dif_easiest = 0,
    dif_easy = 1,
    dif_normal = 2,
    dif_hard = 3,
    dif_hardest = 4
} ;
#line 44 "/home/june/repo/benchmarks/collector/temp/curseofwar-1.1.8/messaging.h"
struct msg_c_data {
   uint8_t i ;
   uint8_t j ;
   uint8_t info ;
};
#line 50 "/home/june/repo/benchmarks/collector/temp/curseofwar-1.1.8/messaging.h"
struct msg_s_data {
   uint8_t control ;
   uint8_t pause_request ;
   uint32_t gold[8] ;
   uint32_t time ;
   uint8_t width ;
   uint8_t height ;
   uint8_t flag[40][29] ;
   uint8_t owner[40][29] ;
   uint16_t pop[40][29] ;
   uint8_t tile[40][29] ;
};
#line 29 "/home/june/repo/benchmarks/collector/temp/curseofwar-1.1.8/king.h"
struct country {
   long gold ;
};
#line 64
enum strategy {
    none = 0,
    aggr_greedy = 1,
    one_greedy = 2,
    persistent_greedy = 3,
    opportunist = 4,
    noble = 5,
    midas = 6
} ;
#line 79 "/home/june/repo/benchmarks/collector/temp/curseofwar-1.1.8/king.h"
struct king {
   int value[40][29] ;
   int pl ;
   enum strategy strategy ;
};
#line 37 "/home/june/repo/benchmarks/collector/temp/curseofwar-1.1.8/state.h"
struct ui {
   struct loc cursor ;
   int xskip ;
};
#line 43 "/home/june/repo/benchmarks/collector/temp/curseofwar-1.1.8/state.h"
struct timeline {
   float data[8][72] ;
   unsigned long time[72] ;
   int mark ;
};
#line 73 "/home/june/repo/benchmarks/collector/temp/curseofwar-1.1.8/state.h"
struct state {
   struct grid grid ;
   struct flag_grid fg[8] ;
   struct king king[8] ;
   int kings_num ;
   struct timeline timeline ;
   int show_timeline ;
   struct country country[8] ;
   unsigned long time ;
   int map_seed ;
   int controlled ;
   int conditions ;
   int inequality ;
   enum config_speed speed ;
   enum config_speed prev_speed ;
   enum config_dif dif ;
};
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 30 "/usr/include/netinet/in.h"
typedef uint32_t in_addr_t;
#line 31 "/usr/include/netinet/in.h"
struct in_addr {
   in_addr_t s_addr ;
};
#line 117 "/usr/include/netinet/in.h"
typedef uint16_t in_port_t;
#line 209 "/usr/include/netinet/in.h"
union __anonunion___in6_u_20 {
   uint8_t __u6_addr8[16] ;
   uint16_t __u6_addr16[8] ;
   uint32_t __u6_addr32[4] ;
};
#line 209 "/usr/include/netinet/in.h"
struct in6_addr {
   union __anonunion___in6_u_20 __in6_u ;
};
#line 237 "/usr/include/netinet/in.h"
struct sockaddr_in {
   sa_family_t sin_family ;
   in_port_t sin_port ;
   struct in_addr sin_addr ;
   unsigned char sin_zero[((sizeof(struct sockaddr ) - sizeof(unsigned short )) - sizeof(in_port_t )) - sizeof(struct in_addr )] ;
};
#line 252 "/usr/include/netinet/in.h"
struct sockaddr_in6 {
   sa_family_t sin6_family ;
   in_port_t sin6_port ;
   uint32_t sin6_flowinfo ;
   struct in6_addr sin6_addr ;
   uint32_t sin6_scope_id ;
};
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 150 "/usr/include/curses.h"
typedef unsigned long chtype;
#line 358
struct _win_st;
#line 358 "/usr/include/curses.h"
typedef struct _win_st WINDOW;
#line 360 "/usr/include/curses.h"
typedef chtype attr_t;
#line 405
struct ldat;
#line 407 "/usr/include/curses.h"
struct pdat {
   short _pad_y ;
   short _pad_x ;
   short _pad_top ;
   short _pad_left ;
   short _pad_bottom ;
   short _pad_right ;
};
#line 407 "/usr/include/curses.h"
struct _win_st {
   short _cury ;
   short _curx ;
   short _maxy ;
   short _maxx ;
   short _begy ;
   short _begx ;
   short _flags ;
   attr_t _attrs ;
   chtype _bkgd ;
   _Bool _notimeout ;
   _Bool _clear ;
   _Bool _leaveok ;
   _Bool _scroll ;
   _Bool _idlok ;
   _Bool _idcok ;
   _Bool _immed ;
   _Bool _sync ;
   _Bool _use_keypad ;
   int _delay ;
   struct ldat *_line ;
   short _regtop ;
   short _regbottom ;
   int _parx ;
   int _pary ;
   WINDOW *_parent ;
   struct pdat _pad ;
   short _yoffset ;
};
#line 125 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uid_t;
#line 133 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __pid_t;
#line 135 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __clock_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 141 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __suseconds_t;
#line 22 "/usr/include/x86_64-linux-gnu/bits/sigset.h"
typedef int __sig_atomic_t;
#line 27 "/usr/include/x86_64-linux-gnu/bits/sigset.h"
struct __anonstruct___sigset_t_10 {
   unsigned long __val[1024UL / (8UL * sizeof(unsigned long ))] ;
};
#line 27 "/usr/include/x86_64-linux-gnu/bits/sigset.h"
typedef struct __anonstruct___sigset_t_10 __sigset_t;
#line 40 "/usr/include/signal.h"
typedef __sig_atomic_t sig_atomic_t;
#line 49 "/usr/include/signal.h"
typedef __sigset_t sigset_t;
#line 32 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
union sigval {
   int sival_int ;
   void *sival_ptr ;
};
#line 32 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
typedef union sigval sigval_t;
#line 58 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
typedef __clock_t __sigchld_clock_t;
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__kill_13 {
   __pid_t si_pid ;
   __uid_t si_uid ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__timer_14 {
   int si_tid ;
   int si_overrun ;
   sigval_t si_sigval ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__rt_15 {
   __pid_t si_pid ;
   __uid_t si_uid ;
   sigval_t si_sigval ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__sigchld_16 {
   __pid_t si_pid ;
   __uid_t si_uid ;
   int si_status ;
   __sigchld_clock_t si_utime ;
   __sigchld_clock_t si_stime ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__sigfault_17 {
   void *si_addr ;
   short si_addr_lsb ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__sigpoll_18 {
   long si_band ;
   int si_fd ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__sigsys_19 {
   void *_call_addr ;
   int _syscall ;
   unsigned int _arch ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
union __anonunion__sifields_12 {
   int _pad[128UL / sizeof(int ) - 4UL] ;
   struct __anonstruct__kill_13 _kill ;
   struct __anonstruct__timer_14 _timer ;
   struct __anonstruct__rt_15 _rt ;
   struct __anonstruct__sigchld_16 _sigchld ;
   struct __anonstruct__sigfault_17 _sigfault ;
   struct __anonstruct__sigpoll_18 _sigpoll ;
   struct __anonstruct__sigsys_19 _sigsys ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct_siginfo_t_11 {
   int si_signo ;
   int si_errno ;
   int si_code ;
   union __anonunion__sifields_12 _sifields ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
typedef struct __anonstruct_siginfo_t_11 siginfo_t;
#line 24 "/usr/include/x86_64-linux-gnu/bits/sigaction.h"
union __anonunion___sigaction_handler_31 {
   void (*sa_handler)(int  ) ;
   void (*sa_sigaction)(int  , siginfo_t * , void * ) ;
};
#line 24 "/usr/include/x86_64-linux-gnu/bits/sigaction.h"
struct sigaction {
   union __anonunion___sigaction_handler_31 __sigaction_handler ;
   __sigset_t sa_mask ;
   int sa_flags ;
   void (*sa_restorer)(void) ;
};
#line 75 "/usr/include/time.h"
typedef __time_t time_t;
#line 30 "/usr/include/x86_64-linux-gnu/bits/time.h"
struct timeval {
   __time_t tv_sec ;
   __suseconds_t tv_usec ;
};
#line 107 "/usr/include/x86_64-linux-gnu/sys/time.h"
struct itimerval {
   struct timeval it_interval ;
   struct timeval it_value ;
};
#line 120 "/usr/include/x86_64-linux-gnu/sys/time.h"
typedef int __itimer_which_t;
#line 33 "/home/june/repo/benchmarks/collector/temp/curseofwar-1.1.8/server.h"
struct client_record {
   int pl ;
   int id ;
   char *name ;
   struct sockaddr_storage sa ;
};
#line 44
enum server_mode {
    server_mode_lobby = 0,
    server_mode_play = 1
} ;
#line 374 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) rand)(void) ;
#line 466
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 100 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h"
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) exp)(double __x ) ;
#line 153
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) pow)(double __x ,
                                                                             double __y ) ;
#line 156
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) sqrt)(double __x ) ;
#line 56 "/home/june/repo/benchmarks/collector/temp/curseofwar-1.1.8/grid.h"
int is_a_city(enum tile_class t ) ;
#line 60
int is_inhabitable(enum tile_class t ) ;
#line 62
int is_visible(enum tile_class t ) ;
#line 68
int stencil_avlbl_loc_num(enum stencil st ) ;
#line 101
struct loc  const  dirs[6] ;
#line 119
void grid_init(struct grid *g , int w , int h ) ;
#line 121
void apply_stencil(enum stencil st , struct grid *g , int d , struct loc *loc , int *avlbl_loc_num ) ;
#line 140
int conflict(struct grid *g , struct loc *loc_arr , int available_loc_num , int *players ,
             int players_num , int locations_num , int *ui_players , int ui_players_num ,
             int conditions , int ineq ) ;
#line 146
int is_connected(struct grid *g ) ;
#line 170
void flag_grid_init(struct flag_grid *fg , int w , int h ) ;
#line 178
void spread(struct grid *g , int (*u)[29] , int (*v)[29] , int x , int y , int val ,
            int factor ) ;
#line 179
void even(struct grid *g , int (*v)[29] , int x , int y , int val ) ;
#line 185
void add_flag(struct grid *g , struct flag_grid *fg , int x , int y , int val ) ;
#line 191
void remove_flag(struct grid *g , struct flag_grid *fg , int x , int y , int val ) ;
#line 198
void remove_flags_with_prob(struct grid *g , struct flag_grid *fg , float prob ) ;
#line 22 "/home/june/repo/benchmarks/collector/temp/curseofwar-1.1.8/grid.c"
int is_a_city(enum tile_class t ) 
{ 


  {
  {
#line 24
  if ((unsigned int )t == 4U) {
#line 24
    goto case_4;
  }
#line 25
  if ((unsigned int )t == 5U) {
#line 25
    goto case_5;
  }
#line 26
  if ((unsigned int )t == 6U) {
#line 26
    goto case_6;
  }
#line 27
  goto switch_default;
  case_4: /* CIL Label */ 
#line 24
  return (1);
  case_5: /* CIL Label */ 
#line 25
  return (1);
  case_6: /* CIL Label */ 
#line 26
  return (1);
  switch_default: /* CIL Label */ 
#line 27
  return (0);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 31 "/home/june/repo/benchmarks/collector/temp/curseofwar-1.1.8/grid.c"
int is_inhabitable(enum tile_class t ) 
{ 


  {
  {
#line 35
  if ((unsigned int )t == 2U) {
#line 35
    goto case_2;
  }
#line 35
  if ((unsigned int )t == 1U) {
#line 35
    goto case_2;
  }
#line 35
  if ((unsigned int )t == 0U) {
#line 35
    goto case_2;
  }
#line 36
  goto switch_default;
  case_2: /* CIL Label */ 
  case_1: /* CIL Label */ 
  case_0: /* CIL Label */ 
#line 35
  return (0);
  switch_default: /* CIL Label */ 
#line 36
  return (1);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 40 "/home/june/repo/benchmarks/collector/temp/curseofwar-1.1.8/grid.c"
int is_visible(enum tile_class t ) 
{ 


  {
  {
#line 42
  if ((unsigned int )t == 0U) {
#line 42
    goto case_0;
  }
#line 43
  goto switch_default;
  case_0: /* CIL Label */ 
#line 42
  return (0);
  switch_default: /* CIL Label */ 
#line 43
  return (1);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 47 "/home/june/repo/benchmarks/collector/temp/curseofwar-1.1.8/grid.c"
struct loc  const  dirs[6]  = {      {-1, 0}, 
        {1, 0}, 
        {0, -1}, 
        {0, 1}, 
        {1, -1}, 
        {-1, 1}};
#line 49 "/home/june/repo/benchmarks/collector/temp/curseofwar-1.1.8/grid.c"
void grid_init(struct grid *g , int w , int h ) 
{ 
  int i ;
  int j ;
  int x ;
  int tmp ;
  int y ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int p ;
  int c ;
  int owner ;
  int tmp___3 ;

  {
#line 50
  if (w < 40) {
#line 50
    g->width = w;
  } else {
#line 50
    g->width = 40;
  }
#line 51
  if (h < 29) {
#line 51
    g->height = h;
  } else {
#line 51
    g->height = 29;
  }
#line 53
  i = 0;
  {
#line 53
  while (1) {
    while_continue: /* CIL Label */ ;
#line 53
    if (! (i < g->width)) {
#line 53
      goto while_break;
    }
#line 54
    j = 0;
    {
#line 54
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 54
      if (! (j < g->height)) {
#line 54
        goto while_break___0;
      }
      {
#line 55
      g->tiles[i][j].cl = (enum tile_class )3;
#line 56
      tmp = rand();
#line 56
      x = tmp % 20;
      }
#line 57
      if (0 == x) {
        {
#line 58
        tmp___0 = rand();
#line 58
        y = tmp___0 % 6;
        }
        {
#line 60
        if (y == 0) {
#line 60
          goto case_0;
        }
#line 62
        if (y == 2) {
#line 62
          goto case_2;
        }
#line 62
        if (y == 1) {
#line 62
          goto case_2;
        }
#line 64
        goto switch_default;
        case_0: /* CIL Label */ 
#line 61
        g->tiles[i][j].cl = (enum tile_class )6;
#line 61
        goto switch_break;
        case_2: /* CIL Label */ 
        case_1: /* CIL Label */ 
#line 63
        g->tiles[i][j].cl = (enum tile_class )5;
#line 63
        goto switch_break;
        switch_default: /* CIL Label */ 
#line 65
        g->tiles[i][j].cl = (enum tile_class )4;
        switch_break: /* CIL Label */ ;
        }
      }
#line 68
      if (x > 0) {
#line 68
        if (x < 5) {
          {
#line 70
          tmp___1 = rand();
          }
#line 70
          if (tmp___1 % 10 == 0) {
#line 71
            g->tiles[i][j].cl = (enum tile_class )2;
          } else {
#line 73
            g->tiles[i][j].cl = (enum tile_class )1;
          }
#line 74
          g->tiles[i][j].pl = 0;
        } else {
#line 68
          goto _L;
        }
      } else {
        _L: /* CIL Label */ 
        {
#line 77
        tmp___2 = rand();
#line 77
        x = 1 + tmp___2 % 7;
        }
#line 78
        if (x < 8) {
#line 78
          g->tiles[i][j].pl = x;
        } else {
#line 80
          g->tiles[i][j].pl = 0;
        }
      }
#line 84
      p = 0;
      {
#line 84
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 84
        if (! (p < 8)) {
#line 84
          goto while_break___1;
        }
#line 85
        c = 0;
        {
#line 85
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 85
          if (! (c < 1)) {
#line 85
            goto while_break___2;
          }
#line 86
          g->tiles[i][j].units[p][c] = 0;
#line 85
          c ++;
        }
        while_break___2: /* CIL Label */ ;
        }
#line 84
        p ++;
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 90
      tmp___3 = is_a_city(g->tiles[i][j].cl);
      }
#line 90
      if (tmp___3) {
#line 91
        owner = g->tiles[i][j].pl;
#line 92
        g->tiles[i][j].units[owner][0] = 10;
      }
#line 54
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 53
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 97
  return;
}
}
#line 100 "/home/june/repo/benchmarks/collector/temp/curseofwar-1.1.8/grid.c"
int stencil_avlbl_loc_num(enum stencil st ) 
{ 


  {
  {
#line 102
  if ((unsigned int )st == 0U) {
#line 102
    goto case_0;
  }
#line 103
  if ((unsigned int )st == 1U) {
#line 103
    goto case_1;
  }
#line 104
  if ((unsigned int )st == 2U) {
#line 104
    goto case_2;
  }
#line 101
  goto switch_break;
  case_0: /* CIL Label */ 
#line 102
  return (4);
  case_1: /* CIL Label */ 
#line 103
  return (4);
  case_2: /* CIL Label */ 
#line 104
  return (6);
  switch_break: /* CIL Label */ ;
  }
#line 106
  return (0);
}
}
#line 112 "/home/june/repo/benchmarks/collector/temp/curseofwar-1.1.8/grid.c"
void stencil_rhombus(struct grid *g , int d , struct loc *loc ) 
{ 
  int xs[4] ;
  int ys[4] ;
  int loc_num ;
  int k ;

  {
#line 113
  xs[0] = d;
#line 113
  xs[1] = (g->width - 1) - d;
#line 113
  xs[2] = d;
#line 113
  xs[3] = (g->width - 1) - d;
#line 114
  ys[0] = d;
#line 114
  ys[1] = (g->height - 1) - d;
#line 114
  ys[2] = (g->height - 1) - d;
#line 114
  ys[3] = d;
#line 115
  loc_num = 4;
#line 117
  k = 0;
  {
#line 117
  while (1) {
    while_continue: /* CIL Label */ ;
#line 117
    if (! (k < loc_num)) {
#line 117
      goto while_break;
    }
#line 118
    (loc + k)->i = xs[k];
#line 119
    (loc + k)->j = ys[k];
#line 117
    k ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 121
  return;
}
}
#line 123 "/home/june/repo/benchmarks/collector/temp/curseofwar-1.1.8/grid.c"
void stencil_rect(struct grid *g , int d , struct loc *loc ) 
{ 
  int i ;
  int j ;
  float x ;
  float y ;
  float epsilon ;
  float x0 ;
  float y0___0 ;
  float x1 ;
  float y1___0 ;
  int loc_num ;
  int dx ;
  struct loc temp_loc[4] ;
  int k ;

  {
#line 126
  epsilon = (float )0.1;
#line 127
  x0 = (float )((0.5 * (double )(g->height - 1) + (double )0) - (double )epsilon);
#line 128
  y0___0 = (float )0 - epsilon;
#line 129
  x1 = (float )((0.5 * (double )0 + (double )(g->width - 1)) + (double )epsilon);
#line 130
  y1___0 = (float )(g->height - 1) + epsilon;
#line 131
  i = 0;
  {
#line 131
  while (1) {
    while_continue: /* CIL Label */ ;
#line 131
    if (! (i < g->width)) {
#line 131
      goto while_break;
    }
#line 132
    j = 0;
    {
#line 132
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 132
      if (! (j < g->height)) {
#line 132
        goto while_break___0;
      }
#line 133
      x = (float )(0.5 * (double )j + (double )i);
#line 134
      y = (float )j;
#line 135
      if (x < x0) {
#line 136
        g->tiles[i][j].cl = (enum tile_class )0;
      } else
#line 135
      if (x > x1) {
#line 136
        g->tiles[i][j].cl = (enum tile_class )0;
      } else
#line 135
      if (y < y0___0) {
#line 136
        g->tiles[i][j].cl = (enum tile_class )0;
      } else
#line 135
      if (y > y1___0) {
#line 136
        g->tiles[i][j].cl = (enum tile_class )0;
      }
#line 132
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 131
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 139
  loc_num = 4;
#line 140
  dx = g->height / 2;
#line 141
  temp_loc[0].i = (dx + d) - 1;
#line 141
  temp_loc[0].j = d;
#line 141
  temp_loc[1].i = (((g->width - dx) - 1) - d) + 1;
#line 141
  temp_loc[1].j = (g->height - 1) - d;
#line 141
  temp_loc[2].i = d + 1;
#line 141
  temp_loc[2].j = (g->height - 1) - d;
#line 141
  temp_loc[3].i = ((g->width - 1) - d) - 1;
#line 141
  temp_loc[3].j = d;
#line 148
  k = 0;
  {
#line 148
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 148
    if (! (k < loc_num)) {
#line 148
      goto while_break___1;
    }
#line 149
    *(loc + k) = temp_loc[k];
#line 148
    k ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 151
  return;
}
}
#line 153 "/home/june/repo/benchmarks/collector/temp/curseofwar-1.1.8/grid.c"
void stencil_hex(struct grid *g , int d , struct loc *loc ) 
{ 
  int i ;
  int j ;
  int dx ;
  int loc_num ;
  struct loc temp_loc[6] ;
  int k ;

  {
#line 155
  dx = g->height / 2;
#line 156
  i = 0;
  {
#line 156
  while (1) {
    while_continue: /* CIL Label */ ;
#line 156
    if (! (i < g->width)) {
#line 156
      goto while_break;
    }
#line 157
    j = 0;
    {
#line 157
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 157
      if (! (j < g->height)) {
#line 157
        goto while_break___0;
      }
#line 158
      if (i + j < dx) {
#line 159
        g->tiles[i][j].cl = (enum tile_class )0;
      } else
#line 158
      if (i + j > (((g->width - 1) + g->height) - 1) - dx) {
#line 159
        g->tiles[i][j].cl = (enum tile_class )0;
      }
#line 157
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 156
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 162
  loc_num = 6;
#line 163
  temp_loc[0].i = (dx + d) - 2;
#line 163
  temp_loc[0].j = d;
#line 163
  temp_loc[1].i = d;
#line 163
  temp_loc[1].j = (g->height - 1) - d;
#line 163
  temp_loc[2].i = (g->width - 1) - d;
#line 163
  temp_loc[2].j = dx;
#line 163
  temp_loc[3].i = d;
#line 163
  temp_loc[3].j = dx;
#line 163
  temp_loc[4].i = (((g->width - 1) - d) - 2) + 2;
#line 163
  temp_loc[4].j = d;
#line 163
  temp_loc[5].i = (((g->width - 1) - dx) - d) + 2;
#line 163
  temp_loc[5].j = (g->height - 1) - d;
#line 172
  k = 0;
  {
#line 172
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 172
    if (! (k < loc_num)) {
#line 172
      goto while_break___1;
    }
#line 173
    *(loc + k) = temp_loc[k];
#line 172
    k ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 175
  return;
}
}
#line 177 "/home/june/repo/benchmarks/collector/temp/curseofwar-1.1.8/grid.c"
void apply_stencil(enum stencil st , struct grid *g , int d , struct loc *loc , int *avlbl_loc_num ) 
{ 
  int i ;
  int j ;
  int p ;

  {
  {
#line 178
  *avlbl_loc_num = stencil_avlbl_loc_num(st);
  }
  {
#line 181
  if ((unsigned int )st == 0U) {
#line 181
    goto case_0;
  }
#line 182
  if ((unsigned int )st == 1U) {
#line 182
    goto case_1;
  }
#line 183
  if ((unsigned int )st == 2U) {
#line 183
    goto case_2;
  }
#line 184
  goto switch_default;
  case_0: /* CIL Label */ 
  {
#line 181
  stencil_rhombus(g, d, loc);
  }
#line 181
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 182
  stencil_rect(g, d, loc);
  }
#line 182
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 183
  stencil_hex(g, d, loc);
  }
#line 183
  goto switch_break;
  switch_default: /* CIL Label */ ;
  switch_break: /* CIL Label */ ;
  }
#line 187
  i = 0;
  {
#line 187
  while (1) {
    while_continue: /* CIL Label */ ;
#line 187
    if (! (i < g->width)) {
#line 187
      goto while_break;
    }
#line 188
    j = 0;
    {
#line 188
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 188
      if (! (j < g->height)) {
#line 188
        goto while_break___0;
      }
#line 189
      if ((unsigned int )g->tiles[i][j].cl == 0U) {
#line 191
        p = 0;
        {
#line 191
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 191
          if (! (p < 8)) {
#line 191
            goto while_break___1;
          }
#line 192
          g->tiles[i][j].units[p][0] = 0;
#line 193
          g->tiles[i][j].pl = 0;
#line 191
          p ++;
        }
        while_break___1: /* CIL Label */ ;
        }
      }
#line 188
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 187
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 197
  return;
}
}
#line 203 "/home/june/repo/benchmarks/collector/temp/curseofwar-1.1.8/grid.c"
void floodfill_closest(struct grid *g , int (*u)[29] , int (*d)[29] , int x , int y ,
                       int val , int dist ) 
{ 
  int tmp ;
  int k ;

  {
#line 204
  if (x < 0) {
#line 205
    return;
  } else
#line 204
  if (x >= g->width) {
#line 205
    return;
  } else
#line 204
  if (y < 0) {
#line 205
    return;
  } else
#line 204
  if (y >= g->height) {
#line 205
    return;
  } else {
    {
#line 204
    tmp = is_inhabitable(g->tiles[x][y].cl);
    }
#line 204
    if (tmp == 0) {
#line 205
      return;
    } else
#line 204
    if ((*(d + x))[y] <= dist) {
#line 205
      return;
    }
  }
#line 207
  (*(u + x))[y] = val;
#line 208
  (*(d + x))[y] = dist;
#line 211
  k = 0;
  {
#line 211
  while (1) {
    while_continue: /* CIL Label */ ;
#line 211
    if (! (k < 6)) {
#line 211
      goto while_break;
    }
    {
#line 212
    floodfill_closest(g, u, d, x + (int )dirs[k].i, y + (int )dirs[k].j, val, dist + 1);
#line 211
    k ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 213
  return;
}
}
#line 219 "/home/june/repo/benchmarks/collector/temp/curseofwar-1.1.8/grid.c"
void eval_locations(struct grid *g , struct loc *loc , int *result , int len ) 
{ 
  int u[40][29] ;
  int d[40][29] ;
  int i ;
  int j ;
  int unreachable ;
  int competition ;
  int k ;
  int x ;
  int y ;
  int single_owner ;
  int max_dist ;
  int min_dist ;
  int tmp ;
  double tmp___0 ;

  {
#line 223
  unreachable = -1;
#line 224
  competition = -2;
#line 226
  i = 0;
  {
#line 226
  while (1) {
    while_continue: /* CIL Label */ ;
#line 226
    if (! (i < g->width)) {
#line 226
      goto while_break;
    }
#line 227
    j = 0;
    {
#line 227
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 227
      if (! (j < g->height)) {
#line 227
        goto while_break___0;
      }
#line 228
      d[i][j] = 1161;
#line 229
      u[i][j] = unreachable;
#line 227
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 226
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 233
  k = 0;
  {
#line 233
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 233
    if (! (k < len)) {
#line 233
      goto while_break___1;
    }
    {
#line 235
    floodfill_closest(g, (int (*)[29])(u), (int (*)[29])(d), (loc + k)->i, (loc + k)->j,
                      k, 0);
#line 233
    k ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 248
  i = 0;
  {
#line 248
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 248
    if (! (i < g->width)) {
#line 248
      goto while_break___2;
    }
#line 249
    j = 0;
    {
#line 249
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 249
      if (! (j < g->height)) {
#line 249
        goto while_break___3;
      }
#line 250
      if ((unsigned int )g->tiles[i][j].cl == 2U) {
#line 251
        single_owner = unreachable;
#line 252
        max_dist = 0;
#line 253
        min_dist = 1161;
#line 254
        k = 0;
        {
#line 254
        while (1) {
          while_continue___4: /* CIL Label */ ;
#line 254
          if (! (k < 6)) {
#line 254
            goto while_break___4;
          }
#line 255
          x = i + (int )dirs[k].i;
#line 256
          y = j + (int )dirs[k].j;
#line 257
          if (x < 0) {
#line 258
            goto __Cont;
          } else
#line 257
          if (x >= g->width) {
#line 258
            goto __Cont;
          } else
#line 257
          if (y < 0) {
#line 258
            goto __Cont;
          } else
#line 257
          if (y >= g->height) {
#line 258
            goto __Cont;
          } else {
            {
#line 257
            tmp = is_inhabitable(g->tiles[x][y].cl);
            }
#line 257
            if (tmp == 0) {
#line 258
              goto __Cont;
            }
          }
#line 264
          if (single_owner == unreachable) {
#line 265
            single_owner = u[x][y];
#line 266
            max_dist = d[x][y];
#line 267
            min_dist = d[x][y];
          } else
#line 270
          if (u[x][y] == single_owner) {
#line 271
            if (max_dist < d[x][y]) {
#line 271
              max_dist = d[x][y];
            } else {
#line 271
              max_dist = max_dist;
            }
#line 272
            if (min_dist < d[x][y]) {
#line 272
              min_dist = min_dist;
            } else {
#line 272
              min_dist = d[x][y];
            }
          } else
#line 274
          if (u[x][y] != unreachable) {
#line 274
            single_owner = competition;
          }
          __Cont: /* CIL Label */ 
#line 254
          k ++;
        }
        while_break___4: /* CIL Label */ ;
        }
#line 277
        if (single_owner != competition) {
#line 277
          if (single_owner != unreachable) {
            {
#line 278
            tmp___0 = exp(((- 10.0 * (double )((float )max_dist)) * (double )min_dist) / (double )1160);
#line 278
            *(result + single_owner) += (int )((100.0 * (double )69) * tmp___0);
            }
          }
        }
      }
#line 249
      j ++;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 248
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 281
  return;
}
}
#line 285 "/home/june/repo/benchmarks/collector/temp/curseofwar-1.1.8/grid.c"
void shuffle(int *arr , int len ) 
{ 
  int t ;
  int i ;
  int j ;
  int s ;
  int tmp ;
  int tmp___0 ;

  {
#line 287
  t = 0;
  {
#line 287
  while (1) {
    while_continue: /* CIL Label */ ;
#line 287
    if (! (t < len)) {
#line 287
      goto while_break;
    }
    {
#line 288
    tmp = rand();
#line 288
    i = tmp % len;
#line 289
    tmp___0 = rand();
#line 289
    j = tmp___0 % len;
#line 290
    s = *(arr + i);
#line 291
    *(arr + i) = *(arr + j);
#line 292
    *(arr + j) = s;
#line 287
    t ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 294
  return;
}
}
#line 297 "/home/june/repo/benchmarks/collector/temp/curseofwar-1.1.8/grid.c"
void sort(int *val , int *item , int len ) 
{ 
  int i ;
  int j ;
  int k ;
  int t ;

  {
#line 300
  i = 0;
  {
#line 300
  while (1) {
    while_continue: /* CIL Label */ ;
#line 300
    if (! (i < len - 1)) {
#line 300
      goto while_break;
    }
#line 301
    k = i;
#line 302
    j = i + 1;
    {
#line 302
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 302
      if (! (j < len)) {
#line 302
        goto while_break___0;
      }
#line 303
      if (*(val + j) < *(val + k)) {
#line 303
        k = j;
      }
#line 302
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 306
    t = *(val + i);
#line 306
    *(val + i) = *(val + k);
#line 306
    *(val + k) = t;
#line 307
    t = *(item + i);
#line 307
    *(item + i) = *(item + k);
#line 307
    *(item + k) = t;
#line 300
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 309
  return;
}
}
#line 311 "/home/june/repo/benchmarks/collector/temp/curseofwar-1.1.8/grid.c"
int conflict(struct grid *g , struct loc *loc_arr , int available_loc_num , int *players ,
             int players_num , int locations_num , int *ui_players , int ui_players_num ,
             int conditions , int ineq ) 
{ 
  int i ;
  int j ;
  int p ;
  int c ;
  int tmp ;
  int tmp___0 ;
  int num ;
  int tmp___1 ;
  int di ;
  int tmp___2 ;
  struct loc chosen_loc[7] ;
  int ii ;
  int x ;
  int y ;
  int dir ;
  int tmp___3 ;
  int ri ;
  int rj ;
  int m ;
  int mine_i ;
  int mine_j ;
  int eval_result[7] ;
  int loc_index[7] ;
  float avg ;
  float var ;
  double tmp___4 ;
  float diff ;
  double tmp___5 ;
  float x___0 ;
  int *sh_players_comp ;
  void *tmp___6 ;
  int *sh_players ;
  void *tmp___7 ;
  int dplayer ;
  int tmp___8 ;
  int ihuman ;
  int tmp___9 ;
  int select___0 ;
  int tmp___10 ;
  int tmp___11 ;
  int ii___0 ;
  int x___1 ;
  int y___0 ;

  {
#line 317
  i = 0;
  {
#line 317
  while (1) {
    while_continue: /* CIL Label */ ;
#line 317
    if (! (i < g->width)) {
#line 317
      goto while_break;
    }
#line 318
    j = 0;
    {
#line 318
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 318
      if (! (j < g->height)) {
#line 318
        goto while_break___0;
      }
#line 319
      p = 0;
      {
#line 319
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 319
        if (! (p < 8)) {
#line 319
          goto while_break___1;
        }
#line 320
        c = 0;
        {
#line 320
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 320
          if (! (c < 1)) {
#line 320
            goto while_break___2;
          }
          {
#line 321
          g->tiles[i][j].units[p][c] = 0;
#line 322
          g->tiles[i][j].pl = 0;
#line 323
          tmp = is_a_city(g->tiles[i][j].cl);
          }
#line 323
          if (tmp) {
#line 324
            g->tiles[i][j].cl = (enum tile_class )3;
          }
#line 320
          c ++;
        }
        while_break___2: /* CIL Label */ ;
        }
#line 319
        p ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 318
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 317
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 331
  if (locations_num < 2) {
#line 331
    locations_num = 2;
  } else {
#line 331
    if (locations_num > available_loc_num) {
#line 331
      tmp___0 = available_loc_num;
    } else {
#line 331
      tmp___0 = locations_num;
    }
#line 331
    locations_num = tmp___0;
  }
#line 333
  if (locations_num < players_num + ui_players_num) {
#line 333
    tmp___1 = locations_num;
  } else {
#line 333
    tmp___1 = players_num + ui_players_num;
  }
  {
#line 333
  num = tmp___1;
#line 336
  tmp___2 = rand();
#line 336
  di = tmp___2 % available_loc_num;
#line 340
  i = 0;
  }
  {
#line 341
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 341
    if (! (i < num)) {
#line 341
      goto while_break___3;
    }
    {
#line 342
    ii = ((i + di) + available_loc_num) % available_loc_num;
#line 343
    x = (loc_arr + ii)->i;
#line 344
    y = (loc_arr + ii)->j;
#line 346
    chosen_loc[i].i = x;
#line 347
    chosen_loc[i].j = y;
#line 349
    g->tiles[x][y].cl = (enum tile_class )6;
#line 352
    tmp___3 = rand();
#line 352
    dir = tmp___3 % 6;
#line 353
    ri = (int )dirs[dir].i;
#line 354
    rj = (int )dirs[dir].j;
#line 356
    m = 1;
#line 357
    mine_i = x + m * ri;
#line 358
    mine_j = y + m * rj;
#line 359
    g->tiles[mine_i][mine_j].cl = (enum tile_class )2;
#line 360
    g->tiles[mine_i][mine_j].pl = 0;
#line 361
    mine_i = x - (2 * m) * ri;
#line 362
    mine_j = y - (2 * m) * rj;
#line 363
    g->tiles[mine_i][mine_j].cl = (enum tile_class )2;
#line 364
    g->tiles[mine_i][mine_j].pl = 0;
#line 365
    mine_i = x - m * ri;
#line 366
    mine_j = y - m * rj;
#line 367
    g->tiles[mine_i][mine_j].cl = (enum tile_class )3;
#line 368
    g->tiles[mine_i][mine_j].pl = 0;
#line 370
    i ++;
    }
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 374
  eval_result[0] = 0;
#line 374
  eval_result[1] = 0;
#line 374
  eval_result[2] = 0;
#line 374
  eval_result[3] = 0;
#line 374
  eval_result[4] = 0;
#line 374
  eval_result[5] = 0;
#line 374
  eval_result[6] = 0;
#line 375
  loc_index[0] = 0;
#line 375
  loc_index[1] = 1;
#line 375
  loc_index[2] = 2;
#line 375
  loc_index[3] = 3;
#line 375
  loc_index[4] = 4;
#line 375
  loc_index[5] = 5;
#line 375
  loc_index[6] = 6;
#line 376
  eval_locations(g, chosen_loc, eval_result, num);
#line 378
  sort(eval_result, loc_index, num);
  }
#line 381
  if (ineq != -1) {
#line 383
    avg = (float )0;
#line 384
    i = 0;
    {
#line 384
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 384
      if (! (i < num)) {
#line 384
        goto while_break___4;
      }
#line 384
      avg += (float )eval_result[i];
#line 384
      i ++;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 385
    avg /= (float )num;
#line 386
    var = (float )0;
#line 387
    i = 0;
    {
#line 387
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 387
      if (! (i < num)) {
#line 387
        goto while_break___5;
      }
      {
#line 388
      tmp___4 = pow((double )((float )eval_result[i] - avg), (double )2);
#line 388
      var = (float )((double )var + tmp___4);
#line 387
      i ++;
      }
    }
    while_break___5: /* CIL Label */ ;
    }
    {
#line 389
    var /= (float )num;
#line 391
    tmp___5 = sqrt((double )var);
#line 391
    diff = (float )tmp___5;
#line 392
    x___0 = (float )(((double )diff * 1000.0) / (double )avg);
    }
    {
#line 394
    if (ineq == 0) {
#line 394
      goto case_0;
    }
#line 395
    if (ineq == 1) {
#line 395
      goto case_1;
    }
#line 396
    if (ineq == 2) {
#line 396
      goto case_2;
    }
#line 397
    if (ineq == 3) {
#line 397
      goto case_3;
    }
#line 398
    if (ineq == 4) {
#line 398
      goto case_4;
    }
#line 393
    goto switch_break;
    case_0: /* CIL Label */ 
#line 394
    if (x___0 > (float )50) {
#line 394
      return (-1);
    }
#line 394
    goto switch_break;
    case_1: /* CIL Label */ 
#line 395
    if (x___0 <= (float )50) {
#line 395
      return (-1);
    } else
#line 395
    if (x___0 > (float )100) {
#line 395
      return (-1);
    }
#line 395
    goto switch_break;
    case_2: /* CIL Label */ 
#line 396
    if (x___0 <= (float )100) {
#line 396
      return (-1);
    } else
#line 396
    if (x___0 > (float )250) {
#line 396
      return (-1);
    }
#line 396
    goto switch_break;
    case_3: /* CIL Label */ 
#line 397
    if (x___0 <= (float )250) {
#line 397
      return (-1);
    } else
#line 397
    if (x___0 > (float )500) {
#line 397
      return (-1);
    }
#line 397
    goto switch_break;
    case_4: /* CIL Label */ 
#line 398
    if (x___0 <= (float )500) {
#line 398
      return (-1);
    }
#line 398
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  {
#line 403
  tmp___6 = malloc(sizeof(int ) * (unsigned long )players_num);
#line 403
  sh_players_comp = (int *)tmp___6;
#line 404
  i = 0;
  }
  {
#line 404
  while (1) {
    while_continue___6: /* CIL Label */ ;
#line 404
    if (! (i < players_num)) {
#line 404
      goto while_break___6;
    }
#line 405
    *(sh_players_comp + i) = *(players + i);
#line 404
    i ++;
  }
  while_break___6: /* CIL Label */ ;
  }
  {
#line 406
  shuffle(sh_players_comp, players_num);
#line 409
  tmp___7 = malloc(sizeof(int ) * (unsigned long )num);
#line 409
  sh_players = (int *)tmp___7;
#line 410
  i = 0;
  }
  {
#line 410
  while (1) {
    while_continue___7: /* CIL Label */ ;
#line 410
    if (! (i < ui_players_num)) {
#line 410
      goto while_break___7;
    }
#line 411
    *(sh_players + i) = *(ui_players + i);
#line 410
    i ++;
  }
  while_break___7: /* CIL Label */ ;
  }
  {
#line 412
  tmp___8 = rand();
#line 412
  dplayer = tmp___8 % players_num;
  }
  {
#line 413
  while (1) {
    while_continue___8: /* CIL Label */ ;
#line 413
    if (! (i < num)) {
#line 413
      goto while_break___8;
    }
#line 414
    *(sh_players + i) = *(sh_players_comp + ((i - ui_players_num) + dplayer) % players_num);
#line 413
    i ++;
  }
  while_break___8: /* CIL Label */ ;
  }
  {
#line 415
  shuffle(sh_players, num);
#line 418
  tmp___9 = rand();
#line 418
  ihuman = tmp___9 % num;
  }
#line 420
  if (conditions > 0) {
#line 421
    if (num - conditions < 0) {
#line 421
      tmp___11 = 0;
    } else {
#line 421
      if (num - conditions > num - 1) {
#line 421
        tmp___10 = num - 1;
      } else {
#line 421
        tmp___10 = num - conditions;
      }
#line 421
      tmp___11 = tmp___10;
    }
#line 421
    select___0 = tmp___11;
#line 422
    ihuman = loc_index[select___0];
  }
#line 425
  i = 0;
  {
#line 426
  while (1) {
    while_continue___9: /* CIL Label */ ;
#line 426
    if (! (i < num)) {
#line 426
      goto while_break___9;
    }
#line 427
    ii___0 = loc_index[i];
#line 428
    x___1 = chosen_loc[ii___0].i;
#line 429
    y___0 = chosen_loc[ii___0].j;
#line 436
    if (ui_players_num > 1) {
#line 437
      g->tiles[x___1][y___0].pl = *(sh_players + i);
    } else
#line 440
    if (ii___0 == ihuman) {
#line 441
      g->tiles[x___1][y___0].pl = *(ui_players + 0);
    } else {
#line 443
      g->tiles[x___1][y___0].pl = *(sh_players_comp + i);
    }
#line 445
    g->tiles[x___1][y___0].units[g->tiles[x___1][y___0].pl][0] = 10;
#line 447
    i ++;
  }
  while_break___9: /* CIL Label */ ;
  }
  {
#line 451
  free((void *)sh_players);
  }
#line 453
  return (0);
}
}
#line 457 "/home/june/repo/benchmarks/collector/temp/curseofwar-1.1.8/grid.c"
void floodfill(struct grid *g , int (*u)[29] , int x , int y , int val ) 
{ 
  int tmp ;
  int k ;

  {
#line 458
  if (x < 0) {
#line 460
    return;
  } else
#line 458
  if (x >= g->width) {
#line 460
    return;
  } else
#line 458
  if (y < 0) {
#line 460
    return;
  } else
#line 458
  if (y >= g->height) {
#line 460
    return;
  } else {
    {
#line 458
    tmp = is_inhabitable(g->tiles[x][y].cl);
    }
#line 458
    if (tmp == 0) {
#line 460
      return;
    } else
#line 458
    if ((*(u + x))[y] == val) {
#line 460
      return;
    }
  }
#line 462
  (*(u + x))[y] = val;
#line 464
  k = 0;
  {
#line 464
  while (1) {
    while_continue: /* CIL Label */ ;
#line 464
    if (! (k < 6)) {
#line 464
      goto while_break;
    }
    {
#line 465
    floodfill(g, u, x + (int )dirs[k].i, y + (int )dirs[k].j, val);
#line 464
    k ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 466
  return;
}
}
#line 468 "/home/june/repo/benchmarks/collector/temp/curseofwar-1.1.8/grid.c"
int is_connected(struct grid *g ) 
{ 
  int m[40][29] ;
  int i ;
  int j ;
  int colored ;

  {
#line 471
  i = 0;
  {
#line 471
  while (1) {
    while_continue: /* CIL Label */ ;
#line 471
    if (! (i < g->width)) {
#line 471
      goto while_break;
    }
#line 472
    j = 0;
    {
#line 472
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 472
      if (! (j < g->height)) {
#line 472
        goto while_break___0;
      }
#line 473
      m[i][j] = 0;
#line 472
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 471
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 475
  colored = 0;
#line 476
  i = 0;
  {
#line 476
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 476
    if (! (i < g->width)) {
#line 476
      goto while_break___1;
    }
#line 477
    j = 0;
    {
#line 477
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 477
      if (! (j < g->height)) {
#line 477
        goto while_break___2;
      }
#line 478
      if (g->tiles[i][j].pl != 0) {
#line 479
        if (colored) {
#line 479
          if (m[i][j] == 0) {
#line 479
            return (0);
          }
        }
        {
#line 480
        colored = 1;
#line 481
        floodfill(g, (int (*)[29])(m), i, j, 1);
        }
      }
#line 477
      j ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 476
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 485
  return (1);
}
}
#line 488 "/home/june/repo/benchmarks/collector/temp/curseofwar-1.1.8/grid.c"
void flag_grid_init(struct flag_grid *fg , int w , int h ) 
{ 
  int i ;
  int j ;

  {
#line 489
  if (w < 40) {
#line 489
    fg->width = w;
  } else {
#line 489
    fg->width = 40;
  }
#line 490
  if (h < 29) {
#line 490
    fg->height = h;
  } else {
#line 490
    fg->height = 29;
  }
#line 492
  i = 0;
  {
#line 492
  while (1) {
    while_continue: /* CIL Label */ ;
#line 492
    if (! (i < fg->width)) {
#line 492
      goto while_break;
    }
#line 493
    j = 0;
    {
#line 493
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 493
      if (! (j < fg->height)) {
#line 493
        goto while_break___0;
      }
#line 494
      fg->flag[i][j] = 0;
#line 495
      fg->call[i][j] = 0;
#line 493
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 492
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 498
  return;
}
}
#line 500 "/home/june/repo/benchmarks/collector/temp/curseofwar-1.1.8/grid.c"
void spread(struct grid *g , int (*u)[29] , int (*v)[29] , int x , int y , int val ,
            int factor ) 
{ 
  int tmp ;
  int d ;
  int k ;

  {
#line 501
  if (x < 0) {
#line 502
    return;
  } else
#line 501
  if (x >= g->width) {
#line 502
    return;
  } else
#line 501
  if (y < 0) {
#line 502
    return;
  } else
#line 501
  if (y >= g->height) {
#line 502
    return;
  } else {
    {
#line 501
    tmp = is_inhabitable(g->tiles[x][y].cl);
    }
#line 501
    if (tmp == 0) {
#line 502
      return;
    }
  }
#line 504
  d = val - (*(u + x))[y];
#line 505
  if (d > 0) {
#line 506
    if (0 < (*(v + x))[y] + d * factor) {
#line 506
      (*(v + x))[y] += d * factor;
    } else {
#line 506
      (*(v + x))[y] = 0;
    }
#line 507
    (*(u + x))[y] += d;
#line 510
    k = 0;
    {
#line 510
    while (1) {
      while_continue: /* CIL Label */ ;
#line 510
      if (! (k < 6)) {
#line 510
        goto while_break;
      }
      {
#line 511
      spread(g, u, v, x + (int )dirs[k].i, y + (int )dirs[k].j, val / 2, factor);
#line 510
      k ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 513
  return;
}
}
#line 515 "/home/june/repo/benchmarks/collector/temp/curseofwar-1.1.8/grid.c"
void even(struct grid *g , int (*v)[29] , int x , int y , int val ) 
{ 
  int k ;

  {
#line 516
  if (x < 0) {
#line 517
    return;
  } else
#line 516
  if (x >= g->width) {
#line 517
    return;
  } else
#line 516
  if (y < 0) {
#line 517
    return;
  } else
#line 516
  if (y >= g->height) {
#line 517
    return;
  } else
#line 516
  if ((*(v + x))[y] == val) {
#line 517
    return;
  }
#line 519
  (*(v + x))[y] = val;
#line 522
  k = 0;
  {
#line 522
  while (1) {
    while_continue: /* CIL Label */ ;
#line 522
    if (! (k < 6)) {
#line 522
      goto while_break;
    }
    {
#line 523
    even(g, v, x + (int )dirs[k].i, y + (int )dirs[k].j, val);
#line 522
    k ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 524
  return;
}
}
#line 526 "/home/june/repo/benchmarks/collector/temp/curseofwar-1.1.8/grid.c"
void add_flag(struct grid *g , struct flag_grid *fg , int x , int y , int val ) 
{ 
  int tmp ;
  int u[40][29] ;
  int i ;
  int j ;

  {
#line 528
  if (x < 0) {
#line 530
    return;
  } else
#line 528
  if (x >= g->width) {
#line 530
    return;
  } else
#line 528
  if (y < 0) {
#line 530
    return;
  } else
#line 528
  if (y >= g->height) {
#line 530
    return;
  } else {
    {
#line 528
    tmp = is_inhabitable(g->tiles[x][y].cl);
    }
#line 528
    if (tmp == 0) {
#line 530
      return;
    } else
#line 528
    if (fg->flag[x][y] == 1) {
#line 530
      return;
    }
  }
#line 535
  i = 0;
  {
#line 535
  while (1) {
    while_continue: /* CIL Label */ ;
#line 535
    if (! (i < 40)) {
#line 535
      goto while_break;
    }
#line 536
    j = 0;
    {
#line 536
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 536
      if (! (j < 29)) {
#line 536
        goto while_break___0;
      }
#line 537
      u[i][j] = 0;
#line 536
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 535
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 541
  fg->flag[x][y] = 1;
#line 542
  spread(g, (int (*)[29])(u), (int (*)[29])(fg->call), x, y, val, 1);
  }
#line 543
  return;
}
}
#line 545 "/home/june/repo/benchmarks/collector/temp/curseofwar-1.1.8/grid.c"
void remove_flag(struct grid *g , struct flag_grid *fg , int x , int y , int val ) 
{ 
  int tmp ;
  int u[40][29] ;
  int i ;
  int j ;

  {
#line 547
  if (x < 0) {
#line 549
    return;
  } else
#line 547
  if (x >= g->width) {
#line 549
    return;
  } else
#line 547
  if (y < 0) {
#line 549
    return;
  } else
#line 547
  if (y >= g->height) {
#line 549
    return;
  } else {
    {
#line 547
    tmp = is_inhabitable(g->tiles[x][y].cl);
    }
#line 547
    if (tmp == 0) {
#line 549
      return;
    } else
#line 547
    if (fg->flag[x][y] == 0) {
#line 549
      return;
    }
  }
#line 554
  i = 0;
  {
#line 554
  while (1) {
    while_continue: /* CIL Label */ ;
#line 554
    if (! (i < 40)) {
#line 554
      goto while_break;
    }
#line 555
    j = 0;
    {
#line 555
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 555
      if (! (j < 29)) {
#line 555
        goto while_break___0;
      }
#line 556
      u[i][j] = 0;
#line 555
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 554
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 560
  fg->flag[x][y] = 0;
#line 561
  spread(g, (int (*)[29])(u), (int (*)[29])(fg->call), x, y, val, -1);
  }
#line 562
  return;
}
}
#line 564 "/home/june/repo/benchmarks/collector/temp/curseofwar-1.1.8/grid.c"
void remove_flags_with_prob(struct grid *g , struct flag_grid *fg , float prob ) 
{ 
  int i ;
  int j ;
  int tmp ;

  {
#line 566
  i = 0;
  {
#line 566
  while (1) {
    while_continue: /* CIL Label */ ;
#line 566
    if (! (i < g->width)) {
#line 566
      goto while_break;
    }
#line 567
    j = 0;
    {
#line 567
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 567
      if (! (j < g->height)) {
#line 567
        goto while_break___0;
      }
#line 568
      if (fg->flag[i][j]) {
        {
#line 568
        tmp = rand();
        }
#line 568
        if ((float )tmp / (float )2147483647 <= prob) {
          {
#line 569
          remove_flag(g, fg, i, j, 8);
          }
        }
      }
#line 567
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 566
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 573
  return;
}
}
#line 163 "/usr/include/x86_64-linux-gnu/sys/socket.h"
extern ssize_t sendto(int __fd , void const   *__buf , size_t __n , int __flags ,
                      struct sockaddr  const  *__addr , socklen_t __addr_len ) ;
#line 174
extern ssize_t recvfrom(int __fd , void * __restrict  __buf , size_t __n , int __flags ,
                        struct sockaddr * __restrict  __addr , socklen_t * __restrict  __addr_len ) ;
#line 374 "/usr/include/netinet/in.h"
extern  __attribute__((__nothrow__)) uint32_t ( __attribute__((__leaf__)) ntohl)(uint32_t __netlong )  __attribute__((__const__)) ;
#line 375
extern  __attribute__((__nothrow__)) uint16_t ( __attribute__((__leaf__)) ntohs)(uint16_t __netshort )  __attribute__((__const__)) ;
#line 846 "/usr/include/stdio.h"
extern void perror(char const   *__s ) ;
#line 46 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memcpy)(void * __restrict  __dest ,
                                                                                                 void const   * __restrict  __src ,
                                                                                                 size_t __n ) ;
#line 27 "/home/june/repo/benchmarks/collector/temp/curseofwar-1.1.8/client.h"
int client_process_input(struct state *st , struct ui *ui , char c , int sfd , struct addrinfo *srv_addr ) ;
#line 28
int client_process_msg_s_state(struct state *st , struct msg_s_data *msg ) ;
#line 30
int client_receive_msg_s(int sfd , struct state *st ) ;
#line 32
void send_msg_c(int sfd , struct addrinfo *srv_addr , uint8_t msg , uint8_t i , uint8_t j ,
                uint8_t info ) ;
#line 27 "/home/june/repo/benchmarks/collector/temp/curseofwar-1.1.8/client.c"
int client_process_msg_s_state(struct state *st , struct msg_s_data *msg ) 
{ 
  uint32_t tmp ;
  int p ;
  int i ;
  int j ;
  uint32_t tmp___0 ;
  uint32_t tmp___1 ;
  uint16_t tmp___2 ;

  {
  {
#line 29
  tmp = ntohl(msg->time);
  }
#line 29
  if ((unsigned long )tmp <= st->time) {
#line 29
    return (-1);
  }
#line 32
  p = 0;
  {
#line 32
  while (1) {
    while_continue: /* CIL Label */ ;
#line 32
    if (! (p < 8)) {
#line 32
      goto while_break;
    }
    {
#line 33
    tmp___0 = ntohl(msg->gold[p]);
#line 33
    st->country[p].gold = (long )tmp___0;
#line 35
    st->fg[p].width = (int )msg->width;
#line 36
    st->fg[p].height = (int )msg->height;
#line 32
    p ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 39
  tmp___1 = ntohl(msg->time);
#line 39
  st->time = (unsigned long )tmp___1;
#line 41
  st->controlled = (int )msg->control;
#line 43
  st->grid.width = (int )msg->width;
#line 44
  st->grid.height = (int )msg->height;
#line 46
  i = 0;
  }
  {
#line 46
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 46
    if (! (i < 40)) {
#line 46
      goto while_break___0;
    }
#line 47
    j = 0;
    {
#line 47
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 47
      if (! (j < 29)) {
#line 47
        goto while_break___1;
      }
#line 48
      st->grid.tiles[i][j].cl = (enum tile_class )msg->tile[i][j];
#line 50
      p = 0;
      {
#line 50
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 50
        if (! (p < 8)) {
#line 50
          goto while_break___2;
        }
#line 51
        st->grid.tiles[i][j].units[p][0] = 0;
#line 50
        p ++;
      }
      while_break___2: /* CIL Label */ ;
      }
      {
#line 53
      st->grid.tiles[i][j].pl = (int )msg->owner[i][j];
#line 54
      tmp___2 = ntohs(msg->pop[i][j]);
#line 54
      st->grid.tiles[i][j].units[msg->owner[i][j]][0] = (int )tmp___2;
#line 56
      p = 0;
      }
      {
#line 56
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 56
        if (! (p < 8)) {
#line 56
          goto while_break___3;
        }
#line 57
        st->fg[p].call[i][j] = 0;
#line 58
        if (((int )msg->flag[i][j] & (1 << p)) == 0) {
#line 59
          st->fg[p].flag[i][j] = 0;
        } else {
#line 61
          st->fg[p].flag[i][j] = 1;
        }
#line 56
        p ++;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 47
      j ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 46
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 65
  return (0);
}
}
#line 69 "/home/june/repo/benchmarks/collector/temp/curseofwar-1.1.8/client.c"
static uint8_t buf[50000]  ;
#line 70 "/home/june/repo/benchmarks/collector/temp/curseofwar-1.1.8/client.c"
static struct msg_s_data msg_data  ;
#line 68 "/home/june/repo/benchmarks/collector/temp/curseofwar-1.1.8/client.c"
int client_receive_msg_s(int sfd , struct state *st ) 
{ 
  struct sockaddr_storage peer_addr ;
  socklen_t peer_addr_len ;
  int nread ;
  ssize_t tmp ;
  uint8_t msg ;

  {
  {
#line 73
  peer_addr_len = (socklen_t )sizeof(peer_addr);
#line 75
  tmp = recvfrom(sfd, (void */* __restrict  */)(buf), (size_t )49999, 0, (struct sockaddr */* __restrict  */)((struct sockaddr *)(& peer_addr)),
                 (socklen_t */* __restrict  */)(& peer_addr_len));
#line 75
  nread = (int )tmp;
  }
#line 77
  if (nread == -1) {
#line 77
    return (-1);
  }
#line 79
  msg = (uint8_t )0;
#line 80
  if (nread >= 1) {
#line 81
    msg = buf[0];
    {
#line 83
    if ((int )msg == 10) {
#line 83
      goto case_10;
    }
#line 82
    goto switch_break;
    case_10: /* CIL Label */ 
#line 84
    if ((unsigned long )(nread - 1) >= sizeof(struct msg_s_data )) {
      {
#line 85
      memcpy((void */* __restrict  */)(& msg_data), (void const   */* __restrict  */)(buf + 1),
             sizeof(struct msg_s_data ));
#line 86
      client_process_msg_s_state(st, & msg_data);
      }
    } else {
#line 88
      return (-1);
    }
#line 89
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
#line 93
  return ((int )msg);
}
}
#line 96 "/home/june/repo/benchmarks/collector/temp/curseofwar-1.1.8/client.c"
int client_process_input(struct state *st , struct ui *ui , char c , int sfd , struct addrinfo *srv_addr ) 
{ 
  int cursi ;
  int cursj ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 97
  cursi = ui->cursor.i;
#line 98
  cursj = ui->cursor.j;
  {
#line 102
  if ((int )c == 113) {
#line 102
    goto case_113;
  }
#line 102
  if ((int )c == 81) {
#line 102
    goto case_113;
  }
#line 114
  if ((int )c == 112) {
#line 114
    goto case_112;
  }
#line 121
  if ((int )c == 68) {
#line 121
    goto case_68;
  }
#line 121
  if ((int )c == 104) {
#line 121
    goto case_68;
  }
#line 124
  if ((int )c == 67) {
#line 124
    goto case_67;
  }
#line 124
  if ((int )c == 108) {
#line 124
    goto case_67;
  }
#line 127
  if ((int )c == 65) {
#line 127
    goto case_65;
  }
#line 127
  if ((int )c == 107) {
#line 127
    goto case_65;
  }
#line 132
  if ((int )c == 66) {
#line 132
    goto case_66;
  }
#line 132
  if ((int )c == 106) {
#line 132
    goto case_66;
  }
#line 137
  if ((int )c == 32) {
#line 137
    goto case_32;
  }
#line 143
  if ((int )c == 120) {
#line 143
    goto case_120;
  }
#line 146
  if ((int )c == 99) {
#line 146
    goto case_99;
  }
#line 150
  if ((int )c == 118) {
#line 150
    goto case_118;
  }
#line 150
  if ((int )c == 114) {
#line 150
    goto case_118;
  }
#line 155
  if ((int )c == 91) {
#line 155
    goto case_91;
  }
#line 155
  if ((int )c == 27) {
#line 155
    goto case_91;
  }
#line 100
  goto switch_break;
  case_113: /* CIL Label */ 
  case_81: /* CIL Label */ 
#line 103
  return (1);
  case_112: /* CIL Label */ 
#line 115
  if ((unsigned int )st->speed == 0U) {
    {
#line 116
    send_msg_c(sfd, srv_addr, (uint8_t )40, (uint8_t )0, (uint8_t )0, (uint8_t )0);
    }
  } else {
    {
#line 118
    send_msg_c(sfd, srv_addr, (uint8_t )41, (uint8_t )0, (uint8_t )0, (uint8_t )0);
    }
  }
#line 120
  goto switch_break;
  case_68: /* CIL Label */ 
  case_104: /* CIL Label */ 
#line 122
  cursi --;
#line 123
  goto switch_break;
  case_67: /* CIL Label */ 
  case_108: /* CIL Label */ 
#line 125
  cursi ++;
#line 126
  goto switch_break;
  case_65: /* CIL Label */ 
  case_107: /* CIL Label */ 
#line 128
  cursj --;
#line 129
  if (cursj % 2 == 1) {
#line 130
    cursi ++;
  }
#line 131
  goto switch_break;
  case_66: /* CIL Label */ 
  case_106: /* CIL Label */ 
#line 133
  cursj ++;
#line 134
  if (cursj % 2 == 0) {
#line 135
    cursi --;
  }
#line 136
  goto switch_break;
  case_32: /* CIL Label */ 
#line 138
  if (st->fg[st->controlled].flag[ui->cursor.i][ui->cursor.j] == 0) {
    {
#line 139
    send_msg_c(sfd, srv_addr, (uint8_t )21, (uint8_t )ui->cursor.i, (uint8_t )ui->cursor.j,
               (uint8_t )0);
    }
  } else {
    {
#line 141
    send_msg_c(sfd, srv_addr, (uint8_t )22, (uint8_t )ui->cursor.i, (uint8_t )ui->cursor.j,
               (uint8_t )0);
    }
  }
#line 142
  goto switch_break;
  case_120: /* CIL Label */ 
  {
#line 144
  send_msg_c(sfd, srv_addr, (uint8_t )23, (uint8_t )0, (uint8_t )0, (uint8_t )0);
  }
#line 145
  goto switch_break;
  case_99: /* CIL Label */ 
  {
#line 147
  send_msg_c(sfd, srv_addr, (uint8_t )24, (uint8_t )0, (uint8_t )0, (uint8_t )0);
  }
#line 148
  goto switch_break;
  case_118: /* CIL Label */ 
  case_114: /* CIL Label */ 
  {
#line 151
  send_msg_c(sfd, srv_addr, (uint8_t )20, (uint8_t )ui->cursor.i, (uint8_t )ui->cursor.j,
             (uint8_t )0);
  }
#line 152
  goto switch_break;
  case_91: /* CIL Label */ 
  case_27: /* CIL Label */ 
#line 156
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 159
  if (cursi < 0) {
#line 159
    cursi = 0;
  } else {
#line 159
    if (cursi > st->grid.width - 1) {
#line 159
      tmp = st->grid.width - 1;
    } else {
#line 159
      tmp = cursi;
    }
#line 159
    cursi = tmp;
  }
#line 160
  if (cursj < 0) {
#line 160
    cursj = 0;
  } else {
#line 160
    if (cursj > st->grid.height - 1) {
#line 160
      tmp___0 = st->grid.height - 1;
    } else {
#line 160
      tmp___0 = cursj;
    }
#line 160
    cursj = tmp___0;
  }
  {
#line 161
  tmp___1 = is_visible(st->grid.tiles[cursi][cursj].cl);
  }
#line 161
  if (tmp___1) {
#line 162
    ui->cursor.i = cursi;
#line 163
    ui->cursor.j = cursj;
  }
#line 165
  return (0);
}
}
#line 170 "/home/june/repo/benchmarks/collector/temp/curseofwar-1.1.8/client.c"
static uint8_t buf___0[50000]  ;
#line 168 "/home/june/repo/benchmarks/collector/temp/curseofwar-1.1.8/client.c"
void send_msg_c(int sfd , struct addrinfo *srv_addr , uint8_t msg , uint8_t i , uint8_t j ,
                uint8_t info ) 
{ 
  struct msg_c_data mcd ;
  int nsent ;
  ssize_t tmp ;

  {
  {
#line 169
  mcd.i = i;
#line 169
  mcd.j = j;
#line 169
  mcd.info = info;
#line 171
  buf___0[0] = msg;
#line 172
  memcpy((void */* __restrict  */)(buf___0 + 1), (void const   */* __restrict  */)(& mcd),
         sizeof(mcd));
#line 173
  tmp = sendto(sfd, (void const   *)(buf___0), 1UL + sizeof(mcd), 0, (struct sockaddr  const  *)srv_addr->ai_addr,
               srv_addr->ai_addrlen);
#line 173
  nsent = (int )tmp;
  }
#line 174
  if (nsent == -1) {
    {
#line 175
    perror("client: sendto");
    }
  }
#line 177
  return;
}
}
#line 113 "/usr/include/x86_64-linux-gnu/sys/socket.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) socket)(int __domain ,
                                                                             int __type ,
                                                                             int __protocol ) ;
#line 123
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) bind)(int __fd ,
                                                                           struct sockaddr  const  *__addr ,
                                                                           socklen_t __len ) ;
#line 662 "/usr/include/netdb.h"
extern int getaddrinfo(char const   * __restrict  __name , char const   * __restrict  __service ,
                       struct addrinfo  const  * __restrict  __req , struct addrinfo ** __restrict  __pai ) ;
#line 668
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) freeaddrinfo)(struct addrinfo *__ai ) ;
#line 671
extern  __attribute__((__nothrow__)) char const   *( __attribute__((__leaf__)) gai_strerror)(int __ecode ) ;
#line 170 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 353 "/usr/include/unistd.h"
extern int close(int __fd ) ;
#line 66 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memset)(void *__s ,
                                                                                               int __c ,
                                                                                               size_t __n ) ;
#line 35 "/home/june/repo/benchmarks/collector/temp/curseofwar-1.1.8/network.h"
void *get_in_addr(struct sockaddr *sa ) ;
#line 38
in_port_t get_in_port(struct sockaddr *sa ) ;
#line 42
int sa_match(struct sockaddr_storage *sa1 , struct sockaddr_storage *sa2 ) ;
#line 44
int server_init(int *p_sfd , char *str_port ) ;
#line 45
int client_init_session(int *p_sfd , char *str_my_port , struct addrinfo *srv , char *str_server_addr ,
                        char *str_server_port ) ;
#line 23 "/home/june/repo/benchmarks/collector/temp/curseofwar-1.1.8/network.c"
void *get_in_addr(struct sockaddr *sa ) 
{ 


  {
#line 24
  if ((int )sa->sa_family == 2) {
#line 25
    return ((void *)(& ((struct sockaddr_in *)sa)->sin_addr));
  }
#line 27
  return ((void *)(& ((struct sockaddr_in6 *)sa)->sin6_addr));
}
}
#line 31 "/home/june/repo/benchmarks/collector/temp/curseofwar-1.1.8/network.c"
in_port_t get_in_port(struct sockaddr *sa ) 
{ 


  {
#line 32
  if ((int )sa->sa_family == 2) {
#line 33
    return (((struct sockaddr_in *)sa)->sin_port);
  }
#line 35
  return (((struct sockaddr_in6 *)sa)->sin6_port);
}
}
#line 40 "/home/june/repo/benchmarks/collector/temp/curseofwar-1.1.8/network.c"
int eq_6_addr(uint8_t *s1 , uint8_t *s2 ) 
{ 
  int i ;

  {
#line 42
  i = 0;
  {
#line 42
  while (1) {
    while_continue: /* CIL Label */ ;
#line 42
    if (! (i < 16)) {
#line 42
      goto while_break;
    }
#line 43
    if ((int )*(s1 + i) != (int )*(s2 + i)) {
#line 43
      return (0);
    }
#line 42
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 45
  return (1);
}
}
#line 49 "/home/june/repo/benchmarks/collector/temp/curseofwar-1.1.8/network.c"
int sa_match(struct sockaddr_storage *sa1 , struct sockaddr_storage *sa2 ) 
{ 
  struct sockaddr *s1 ;
  struct sockaddr *s2 ;
  int tmp ;
  in_port_t tmp___0 ;
  in_port_t tmp___1 ;
  int tmp___2 ;

  {
#line 50
  s1 = (struct sockaddr *)sa1;
#line 51
  s2 = (struct sockaddr *)sa2;
#line 52
  if ((int )s1->sa_family == 2) {
#line 52
    if ((int )s2->sa_family == 2) {
#line 52
      if (((struct sockaddr_in *)s1)->sin_addr.s_addr == ((struct sockaddr_in *)s2)->sin_addr.s_addr) {
#line 52
        goto _L;
      } else {
#line 52
        goto _L___1;
      }
    } else {
#line 52
      goto _L___1;
    }
  } else
  _L___1: /* CIL Label */ 
#line 52
  if ((int )s1->sa_family == 10) {
#line 52
    if ((int )s2->sa_family == 10) {
      {
#line 52
      tmp = eq_6_addr((uint8_t *)(((struct sockaddr_in6 *)s1)->sin6_addr.__in6_u.__u6_addr8),
                      (uint8_t *)(((struct sockaddr_in6 *)s2)->sin6_addr.__in6_u.__u6_addr8));
      }
#line 52
      if (tmp) {
        _L: /* CIL Label */ 
        {
#line 52
        tmp___0 = get_in_port(s1);
#line 52
        tmp___1 = get_in_port(s2);
        }
#line 52
        if ((int )tmp___0 == (int )tmp___1) {
#line 52
          tmp___2 = 1;
        } else {
#line 52
          tmp___2 = 0;
        }
      } else {
#line 52
        tmp___2 = 0;
      }
    } else {
#line 52
      tmp___2 = 0;
    }
  } else {
#line 52
    tmp___2 = 0;
  }
#line 52
  return (tmp___2);
}
}
#line 69 "/home/june/repo/benchmarks/collector/temp/curseofwar-1.1.8/network.c"
int server_init(int *p_sfd , char *str_port ) 
{ 
  struct addrinfo hints ;
  struct addrinfo *result ;
  struct addrinfo *rp ;
  int s ;
  char const   *tmp ;
  int tmp___0 ;

  {
  {
#line 74
  memset((void *)(& hints), 0, sizeof(struct addrinfo ));
#line 75
  hints.ai_family = 0;
#line 76
  hints.ai_socktype = 2;
#line 77
  hints.ai_flags = 1;
#line 78
  hints.ai_protocol = 0;
#line 79
  hints.ai_canonname = (char *)((void *)0);
#line 80
  hints.ai_addr = (struct sockaddr *)((void *)0);
#line 81
  hints.ai_next = (struct addrinfo *)((void *)0);
#line 83
  s = getaddrinfo((char const   */* __restrict  */)((void *)0), (char const   */* __restrict  */)str_port,
                  (struct addrinfo  const  */* __restrict  */)(& hints), (struct addrinfo **/* __restrict  */)(& result));
  }
#line 84
  if (s != 0) {
    {
#line 85
    tmp = gai_strerror(s);
#line 85
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"getaddrinfo: %s\n",
            tmp);
    }
#line 86
    return (-1);
  }
#line 94
  rp = result;
  {
#line 94
  while (1) {
    while_continue: /* CIL Label */ ;
#line 94
    if (! ((unsigned long )rp != (unsigned long )((void *)0))) {
#line 94
      goto while_break;
    }
    {
#line 95
    *p_sfd = socket(rp->ai_family, rp->ai_socktype, rp->ai_protocol);
    }
#line 97
    if (*p_sfd == -1) {
#line 98
      goto __Cont;
    }
    {
#line 100
    tmp___0 = bind(*p_sfd, (struct sockaddr  const  *)rp->ai_addr, rp->ai_addrlen);
    }
#line 100
    if (tmp___0 == 0) {
#line 101
      goto while_break;
    }
    {
#line 103
    close(*p_sfd);
    }
    __Cont: /* CIL Label */ 
#line 94
    rp = rp->ai_next;
  }
  while_break: /* CIL Label */ ;
  }
#line 106
  if ((unsigned long )rp == (unsigned long )((void *)0)) {
    {
#line 107
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Could not bind\n");
    }
#line 108
    return (-1);
  }
  {
#line 111
  freeaddrinfo(result);
  }
#line 112
  return (0);
}
}
#line 116 "/home/june/repo/benchmarks/collector/temp/curseofwar-1.1.8/network.c"
int client_init_session(int *p_sfd , char *str_my_port , struct addrinfo *srv , char *str_server_addr ,
                        char *str_server_port ) 
{ 
  struct addrinfo hints ;
  struct addrinfo *result ;
  struct addrinfo *rp ;
  int s ;
  char const   *tmp ;
  int tmp___0 ;
  char const   *tmp___1 ;

  {
  {
#line 121
  memset((void *)(& hints), 0, sizeof(struct addrinfo ));
#line 122
  hints.ai_family = 0;
#line 123
  hints.ai_socktype = 2;
#line 124
  hints.ai_flags = 1;
#line 125
  hints.ai_protocol = 0;
#line 126
  hints.ai_canonname = (char *)((void *)0);
#line 127
  hints.ai_addr = (struct sockaddr *)((void *)0);
#line 128
  hints.ai_next = (struct addrinfo *)((void *)0);
#line 130
  s = getaddrinfo((char const   */* __restrict  */)((void *)0), (char const   */* __restrict  */)str_my_port,
                  (struct addrinfo  const  */* __restrict  */)(& hints), (struct addrinfo **/* __restrict  */)(& result));
  }
#line 131
  if (s != 0) {
    {
#line 132
    tmp = gai_strerror(s);
#line 132
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"getaddrinfo: %s\n",
            tmp);
    }
#line 133
    return (-1);
  }
#line 141
  rp = result;
  {
#line 141
  while (1) {
    while_continue: /* CIL Label */ ;
#line 141
    if (! ((unsigned long )rp != (unsigned long )((void *)0))) {
#line 141
      goto while_break;
    }
    {
#line 142
    *p_sfd = socket(rp->ai_family, rp->ai_socktype, rp->ai_protocol);
    }
#line 144
    if (*p_sfd == -1) {
#line 145
      goto __Cont;
    }
    {
#line 147
    tmp___0 = bind(*p_sfd, (struct sockaddr  const  *)rp->ai_addr, rp->ai_addrlen);
    }
#line 147
    if (tmp___0 == 0) {
#line 148
      goto while_break;
    }
    {
#line 150
    close(*p_sfd);
    }
    __Cont: /* CIL Label */ 
#line 141
    rp = rp->ai_next;
  }
  while_break: /* CIL Label */ ;
  }
#line 153
  if ((unsigned long )rp == (unsigned long )((void *)0)) {
    {
#line 154
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Could not bind\n");
    }
#line 155
    return (-1);
  }
  {
#line 158
  freeaddrinfo(result);
#line 164
  memset((void *)(& hints), 0, sizeof(struct addrinfo ));
#line 165
  hints.ai_family = 0;
#line 166
  hints.ai_socktype = 2;
#line 167
  hints.ai_flags = 0;
#line 168
  hints.ai_protocol = 0;
#line 170
  s = getaddrinfo((char const   */* __restrict  */)str_server_addr, (char const   */* __restrict  */)str_server_port,
                  (struct addrinfo  const  */* __restrict  */)(& hints), (struct addrinfo **/* __restrict  */)(& result));
  }
#line 171
  if (s != 0) {
    {
#line 172
    tmp___1 = gai_strerror(s);
#line 172
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"getaddrinfo: %s\n",
            tmp___1);
    }
#line 173
    return (-1);
  }
#line 182
  rp = result;
#line 184
  if ((unsigned long )rp == (unsigned long )((void *)0)) {
    {
#line 185
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Could not connect\n");
    }
#line 186
    return (-1);
  }
#line 188
  *srv = *rp;
#line 190
  return (0);
}
}
#line 364 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
#line 309 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h"
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) round)(double __x )  __attribute__((__const__)) ;
#line 35 "/home/june/repo/benchmarks/collector/temp/curseofwar-1.1.8/output.h"
void output_grid(struct state *st , struct ui *ui , int ktime ) ;
#line 37
void output_dialog_quit_on(struct state *st , struct ui *ui ) ;
#line 38
void output_dialog_quit_off(struct state *st , struct ui *ui ) ;
#line 41
void output_timeline(struct state *st , struct ui *ui ) ;
#line 785 "/usr/include/curses.h"
extern int waddch(WINDOW * , chtype const    ) ;
#line 788
extern int waddnstr(WINDOW * , char const   * , int  ) ;
#line 824
extern int wmove(WINDOW * , int  , int  ) ;
#line 829
extern int wrefresh(WINDOW * ) ;
#line 1386
extern WINDOW *stdscr ;
#line 399 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 29 "/home/june/repo/benchmarks/collector/temp/curseofwar-1.1.8/output.c"
int player_color(int p ) 
{ 


  {
  {
#line 31
  if (p == 0) {
#line 31
    goto case_0;
  }
#line 32
  if (p == 1) {
#line 32
    goto case_1;
  }
#line 33
  if (p == 2) {
#line 33
    goto case_2;
  }
#line 34
  if (p == 3) {
#line 34
    goto case_3;
  }
#line 35
  if (p == 4) {
#line 35
    goto case_4;
  }
#line 36
  if (p == 5) {
#line 36
    goto case_5;
  }
#line 37
  if (p == 6) {
#line 37
    goto case_6;
  }
#line 38
  if (p == 7) {
#line 38
    goto case_7;
  }
#line 39
  goto switch_default;
  case_0: /* CIL Label */ 
#line 31
  return (6);
  case_1: /* CIL Label */ 
#line 32
  return (4);
  case_2: /* CIL Label */ 
#line 33
  return (5);
  case_3: /* CIL Label */ 
#line 34
  return (3);
  case_4: /* CIL Label */ 
#line 35
  return (6);
  case_5: /* CIL Label */ 
#line 36
  return (7);
  case_6: /* CIL Label */ 
#line 37
  return (8);
  case_7: /* CIL Label */ 
#line 38
  return (2);
  switch_default: /* CIL Label */ 
#line 39
  return (-1);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 44 "/home/june/repo/benchmarks/collector/temp/curseofwar-1.1.8/output.c"
int player_style(int p ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 45
  if (p != 0) {
    {
#line 46
    tmp = player_color(p);
    }
#line 46
    return ((int )((1UL << 21) | ((chtype )tmp << 8)));
  } else {
    {
#line 48
    tmp___0 = player_color(p);
    }
#line 48
    return ((int )((chtype )tmp___0 << 8));
  }
}
}
#line 51 "/home/june/repo/benchmarks/collector/temp/curseofwar-1.1.8/output.c"
void time_to_ymd(unsigned long time___0 , int *y , int *m , int *d ) 
{ 
  int year ;
  int month ;
  int day ;

  {
#line 52
  year = (int )(time___0 / 360UL);
#line 53
  month = (int )(time___0 - (unsigned long )(year * 360));
#line 54
  day = month % 30 + 1;
#line 55
  month = month / 30 + 1;
#line 57
  *y = year;
#line 58
  *m = month;
#line 59
  *d = day;
#line 60
  return;
}
}
#line 63 "/home/june/repo/benchmarks/collector/temp/curseofwar-1.1.8/output.c"
void output_units(struct ui *ui , struct tile *t , int i , int j ) 
{ 
  int p ;
  int num ;

  {
#line 65
  num = 0;
#line 66
  p = 0;
  {
#line 66
  while (1) {
    while_continue: /* CIL Label */ ;
#line 66
    if (! (p < 8)) {
#line 66
      goto while_break;
    }
#line 67
    num += t->units[p][0];
#line 66
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 69
  wmove(stdscr, j + 1, ((i * 4 + j * 2) + 1) - ui->xskip * 4);
  }
#line 70
  if (num > 400) {
    {
#line 71
    waddnstr(stdscr, ":::", -1);
    }
  } else
#line 72
  if (num > 200) {
    {
#line 73
    waddnstr(stdscr, ".::", -1);
    }
  } else
#line 74
  if (num > 100) {
    {
#line 75
    waddnstr(stdscr, " ::", -1);
    }
  } else
#line 76
  if (num > 50) {
    {
#line 77
    waddnstr(stdscr, ".:.", -1);
    }
  } else
#line 78
  if (num > 25) {
    {
#line 79
    waddnstr(stdscr, ".: ", -1);
    }
  } else
#line 80
  if (num > 12) {
    {
#line 81
    waddnstr(stdscr, " : ", -1);
    }
  } else
#line 82
  if (num > 6) {
    {
#line 83
    waddnstr(stdscr, "...", -1);
    }
  } else
#line 84
  if (num > 3) {
    {
#line 85
    waddnstr(stdscr, ".. ", -1);
    }
  } else
#line 86
  if (num > 0) {
    {
#line 87
    waddnstr(stdscr, " . ", -1);
    }
  }
#line 88
  return;
}
}
#line 91 "/home/june/repo/benchmarks/collector/temp/curseofwar-1.1.8/output.c"
void output_key(int y , int x , char *key , int key_style , char *s , int s_style ) 
{ 
  int keylen ;
  size_t tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  {
#line 92
  tmp = strlen((char const   *)key);
#line 92
  keylen = (int )tmp;
  }
#line 93
  if (stdscr) {
#line 93
    stdscr->_attrs = (attr_t )key_style;
  }
  {
#line 94
  tmp___0 = wmove(stdscr, y, x + 1);
  }
#line 94
  if (! (tmp___0 == -1)) {
    {
#line 94
    waddnstr(stdscr, (char const   *)key, -1);
    }
  }
#line 95
  if (stdscr) {
#line 95
    stdscr->_attrs = (attr_t )s_style;
  }
  {
#line 96
  tmp___1 = wmove(stdscr, y, x);
  }
#line 96
  if (! (tmp___1 == -1)) {
    {
#line 96
    waddch(stdscr, (chtype const   )'[');
    }
  }
  {
#line 97
  tmp___2 = wmove(stdscr, y, (x + keylen) + 1);
  }
#line 97
  if (! (tmp___2 == -1)) {
    {
#line 97
    waddch(stdscr, (chtype const   )']');
    }
  }
  {
#line 98
  tmp___3 = wmove(stdscr, y, (x + keylen) + 3);
  }
#line 98
  if (! (tmp___3 == -1)) {
    {
#line 98
    waddnstr(stdscr, (char const   *)s, -1);
    }
  }
#line 99
  return;
}
}
#line 102 "/home/june/repo/benchmarks/collector/temp/curseofwar-1.1.8/output.c"
void output_grid(struct state *st , struct ui *ui , int ktime ) 
{ 
  int i ;
  int j ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int p ;
  int tmp___3 ;
  int tmp___4 ;
  int k ;
  int b ;
  int di ;
  int dj ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int p___0 ;
  char buf___2[32] ;
  int y ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int text_style ;
  int key_style ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int year ;
  int month ;
  int day ;
  int tmp___19 ;

  {
#line 104
  i = 0;
  {
#line 104
  while (1) {
    while_continue: /* CIL Label */ ;
#line 104
    if (! (i < st->grid.width)) {
#line 104
      goto while_break;
    }
#line 105
    j = 0;
    {
#line 105
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 105
      if (! (j < st->grid.height)) {
#line 105
        goto while_break___0;
      }
      {
#line 107
      wmove(stdscr, j + 1, (((i * 4 + j * 2) + 1) - ui->xskip * 4) - 1);
      }
      {
#line 109
      if ((unsigned int )st->grid.tiles[i][j].cl == 1U) {
#line 109
        goto case_1;
      }
#line 113
      if ((unsigned int )st->grid.tiles[i][j].cl == 2U) {
#line 113
        goto case_2;
      }
#line 129
      if ((unsigned int )st->grid.tiles[i][j].cl == 3U) {
#line 129
        goto case_3;
      }
#line 133
      if ((unsigned int )st->grid.tiles[i][j].cl == 4U) {
#line 133
        goto case_4;
      }
#line 137
      if ((unsigned int )st->grid.tiles[i][j].cl == 5U) {
#line 137
        goto case_5;
      }
#line 141
      if ((unsigned int )st->grid.tiles[i][j].cl == 6U) {
#line 141
        goto case_6;
      }
#line 145
      goto switch_default;
      case_1: /* CIL Label */ 
#line 110
      if (stdscr) {
#line 110
        stdscr->_attrs = 4UL << 8;
      }
      {
#line 111
      waddnstr(stdscr, " /\\^ ", -1);
      }
#line 112
      goto switch_break;
      case_2: /* CIL Label */ 
#line 114
      if (stdscr) {
#line 114
        stdscr->_attrs = 4UL << 8;
      }
      {
#line 115
      waddnstr(stdscr, " /$\\ ", -1);
#line 116
      wmove(stdscr, j + 1, (((i * 4 + j * 2) + 1) - ui->xskip * 4) + 1);
      }
#line 117
      if (st->grid.tiles[i][j].pl != 0) {
#line 118
        if (stdscr) {
#line 118
          stdscr->_attrs = (1UL << 21) | (6UL << 8);
        }
      } else
#line 120
      if (stdscr) {
#line 120
        stdscr->_attrs = 6UL << 8;
      }
      {
#line 121
      waddnstr(stdscr, "$", -1);
      }
#line 122
      goto switch_break;
      case_3: /* CIL Label */ 
#line 130
      if (stdscr) {
#line 130
        stdscr->_attrs = 4UL << 8;
      }
      {
#line 131
      waddnstr(stdscr, "  -  ", -1);
      }
#line 132
      goto switch_break;
      case_4: /* CIL Label */ 
#line 134
      if (stdscr) {
        {
#line 134
        tmp = player_style(st->grid.tiles[i][j].pl);
#line 134
        stdscr->_attrs = (attr_t )tmp;
        }
      }
      {
#line 135
      waddnstr(stdscr, "  n  ", -1);
      }
#line 136
      goto switch_break;
      case_5: /* CIL Label */ 
#line 138
      if (stdscr) {
        {
#line 138
        tmp___0 = player_style(st->grid.tiles[i][j].pl);
#line 138
        stdscr->_attrs = (attr_t )tmp___0;
        }
      }
      {
#line 139
      waddnstr(stdscr, " i=i ", -1);
      }
#line 140
      goto switch_break;
      case_6: /* CIL Label */ 
#line 142
      if (stdscr) {
        {
#line 142
        tmp___1 = player_style(st->grid.tiles[i][j].pl);
#line 142
        stdscr->_attrs = (attr_t )tmp___1;
        }
      }
      {
#line 143
      waddnstr(stdscr, " W#W ", -1);
      }
#line 144
      goto switch_break;
      switch_default: /* CIL Label */ ;
      switch_break: /* CIL Label */ ;
      }
#line 147
      if (stdscr) {
#line 147
        stdscr->_attrs = 1UL << 8;
      }
#line 149
      if ((unsigned int )st->grid.tiles[i][j].cl == 3U) {
#line 150
        if (stdscr) {
          {
#line 150
          tmp___2 = player_style(st->grid.tiles[i][j].pl);
#line 150
          stdscr->_attrs = (attr_t )tmp___2;
          }
        }
        {
#line 151
        output_units(ui, & st->grid.tiles[i][j], i, j);
        }
#line 152
        if (stdscr) {
#line 152
          stdscr->_attrs = 1UL << 8;
        }
      }
#line 156
      p = 0;
      {
#line 156
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 156
        if (! (p < 8)) {
#line 156
          goto while_break___1;
        }
#line 157
        if (p != st->controlled) {
#line 158
          if (st->fg[p].flag[i][j] != 0) {
#line 158
            if (((ktime + p) / 5) % 10 < 10) {
#line 159
              if (stdscr) {
                {
#line 159
                tmp___3 = player_style(p);
#line 159
                stdscr->_attrs = (attr_t )tmp___3;
                }
              }
              {
#line 160
              tmp___4 = wmove(stdscr, j + 1, ((i * 4 + j * 2) + 1) - ui->xskip * 4);
              }
#line 160
              if (! (tmp___4 == -1)) {
                {
#line 160
                waddch(stdscr, (chtype const   )'x');
                }
              }
#line 161
              if (stdscr) {
#line 161
                stdscr->_attrs = 1UL << 8;
              }
            }
          }
        }
#line 156
        p ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 168
      b = 0;
#line 169
      k = 0;
      {
#line 169
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 169
        if (! (k < 6)) {
#line 169
          goto while_break___2;
        }
#line 170
        di = (int )dirs[k].i;
#line 171
        dj = (int )dirs[k].j;
#line 172
        if (i + di >= 0) {
#line 172
          if (i + di < st->grid.width) {
#line 172
            if (j + dj >= 0) {
#line 172
              if (j + dj < st->grid.height) {
#line 172
                if (st->grid.tiles[i + di][j + dj].units[st->controlled][0] > 0) {
#line 175
                  b = 1;
#line 176
                  goto while_break___2;
                }
              }
            }
          }
        }
#line 169
        k ++;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 184
      if (st->fg[st->controlled].flag[i][j] != 0) {
#line 184
        if ((ktime / 5) % 10 < 10) {
#line 185
          if (stdscr) {
#line 185
            stdscr->_attrs = (1UL << 21) | (1UL << 8);
          }
          {
#line 186
          tmp___5 = wmove(stdscr, j + 1, (((i * 4 + j * 2) + 1) - ui->xskip * 4) + 2);
          }
#line 186
          if (! (tmp___5 == -1)) {
            {
#line 186
            waddch(stdscr, (chtype const   )'P');
            }
          }
#line 187
          if (stdscr) {
#line 187
            stdscr->_attrs = 1UL << 8;
          }
        }
      }
#line 105
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 104
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 193
  i = ui->cursor.i;
#line 194
  j = ui->cursor.j;
#line 195
  if (stdscr) {
#line 195
    stdscr->_attrs = (1UL << 21) | (1UL << 8);
  }
  {
#line 196
  tmp___6 = wmove(stdscr, j + 1, (((i * 4 + j * 2) + 1) - ui->xskip * 4) - 1);
  }
#line 196
  if (! (tmp___6 == -1)) {
    {
#line 196
    waddch(stdscr, (chtype const   )'(');
    }
  }
  {
#line 197
  tmp___7 = wmove(stdscr, j + 1, ((((i + 1) * 4 + j * 2) + 1) - ui->xskip * 4) - 1);
  }
#line 197
  if (! (tmp___7 == -1)) {
    {
#line 197
    waddch(stdscr, (chtype const   )')');
    }
  }
#line 198
  if (stdscr) {
#line 198
    stdscr->_attrs = 1UL << 8;
  }
  {
#line 203
  y = (st->grid.height + 1) + 1;
#line 204
  tmp___8 = wmove(stdscr, y, 0);
  }
#line 204
  if (! (tmp___8 == -1)) {
    {
#line 204
    waddnstr(stdscr, " Gold:", -1);
    }
  }
  {
#line 205
  sprintf((char */* __restrict  */)(buf___2), (char const   */* __restrict  */)"%li    ",
          st->country[st->controlled].gold);
  }
#line 206
  if (stdscr) {
    {
#line 206
    tmp___9 = player_style(st->controlled);
#line 206
    stdscr->_attrs = (attr_t )tmp___9;
    }
  }
  {
#line 207
  tmp___10 = wmove(stdscr, y, 8);
  }
#line 207
  if (! (tmp___10 == -1)) {
    {
#line 207
    waddnstr(stdscr, (char const   *)(buf___2), -1);
    }
  }
  {
#line 208
  tmp___11 = wmove(stdscr, y, 8);
  }
#line 208
  if (! (tmp___11 == -1)) {
    {
#line 208
    waddnstr(stdscr, (char const   *)(buf___2), -1);
    }
  }
#line 209
  if (stdscr) {
#line 209
    stdscr->_attrs = 1UL << 8;
  }
  {
#line 210
  tmp___12 = wmove(stdscr, y + 1, 0);
  }
#line 210
  if (! (tmp___12 == -1)) {
    {
#line 210
    waddnstr(stdscr, " Prices: 150, 300, 600.", -1);
    }
  }
  {
#line 212
  wmove(stdscr, y + 2, 1);
#line 213
  waddnstr(stdscr, "Speed: ", -1);
  }
#line 214
  if (stdscr) {
    {
#line 214
    tmp___13 = player_style(st->controlled);
#line 214
    stdscr->_attrs = (attr_t )tmp___13;
    }
  }
  {
#line 216
  if ((unsigned int )st->speed == 7U) {
#line 216
    goto case_7;
  }
#line 217
  if ((unsigned int )st->speed == 6U) {
#line 217
    goto case_6___0;
  }
#line 218
  if ((unsigned int )st->speed == 5U) {
#line 218
    goto case_5___0;
  }
#line 219
  if ((unsigned int )st->speed == 4U) {
#line 219
    goto case_4___0;
  }
#line 220
  if ((unsigned int )st->speed == 3U) {
#line 220
    goto case_3___0;
  }
#line 221
  if ((unsigned int )st->speed == 2U) {
#line 221
    goto case_2___0;
  }
#line 222
  if ((unsigned int )st->speed == 1U) {
#line 222
    goto case_1___0;
  }
#line 223
  if ((unsigned int )st->speed == 0U) {
#line 223
    goto case_0;
  }
#line 215
  goto switch_break___0;
  case_7: /* CIL Label */ 
  {
#line 216
  waddnstr(stdscr, "Fastest", -1);
  }
#line 216
  goto switch_break___0;
  case_6___0: /* CIL Label */ 
  {
#line 217
  waddnstr(stdscr, "Faster ", -1);
  }
#line 217
  goto switch_break___0;
  case_5___0: /* CIL Label */ 
  {
#line 218
  waddnstr(stdscr, "Fast   ", -1);
  }
#line 218
  goto switch_break___0;
  case_4___0: /* CIL Label */ 
  {
#line 219
  waddnstr(stdscr, "Normal ", -1);
  }
#line 219
  goto switch_break___0;
  case_3___0: /* CIL Label */ 
  {
#line 220
  waddnstr(stdscr, "Slow   ", -1);
  }
#line 220
  goto switch_break___0;
  case_2___0: /* CIL Label */ 
  {
#line 221
  waddnstr(stdscr, "Slower ", -1);
  }
#line 221
  goto switch_break___0;
  case_1___0: /* CIL Label */ 
  {
#line 222
  waddnstr(stdscr, "Slowest", -1);
  }
#line 222
  goto switch_break___0;
  case_0: /* CIL Label */ 
  {
#line 223
  waddnstr(stdscr, "Pause  ", -1);
  }
#line 223
  goto switch_break___0;
  switch_break___0: /* CIL Label */ ;
  }
#line 226
  if (stdscr) {
#line 226
    stdscr->_attrs = (1UL << 21) | (1UL << 8);
  }
  {
#line 228
  text_style = (int )(1UL << 8);
#line 229
  tmp___14 = player_style(st->controlled);
#line 229
  key_style = tmp___14;
#line 231
  output_key(y + 4, 1, (char *)"Space", key_style, (char *)"add/remove a flag", text_style);
#line 232
  output_key(y + 5, 1, (char *)"R or V", key_style, (char *)"build", text_style);
#line 234
  output_key(y + 4, 30, (char *)"X", key_style, (char *)"remove all flags", text_style);
#line 235
  output_key(y + 5, 30, (char *)"C", key_style, (char *)"remove 50% of flags", text_style);
#line 237
  output_key(y + 5, 57, (char *)"S", key_style, (char *)"slow down", text_style);
#line 238
  output_key(y + 4, 57, (char *)"F", key_style, (char *)"speed up", text_style);
#line 239
  output_key(y + 6, 57, (char *)"P", key_style, (char *)"pause", text_style);
#line 241
  tmp___15 = wmove(stdscr, y + 1, 30);
  }
#line 241
  if (! (tmp___15 == -1)) {
    {
#line 241
    waddnstr(stdscr, " Population at the cursor:", -1);
    }
  }
#line 242
  p___0 = 0;
  {
#line 242
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 242
    if (! (p___0 < 8)) {
#line 242
      goto while_break___3;
    }
#line 243
    if (p___0 == 0) {
#line 243
      goto __Cont;
    }
#line 244
    if (stdscr) {
      {
#line 244
      tmp___16 = player_style(p___0);
#line 244
      stdscr->_attrs = (attr_t )tmp___16;
      }
    }
    {
#line 245
    sprintf((char */* __restrict  */)(buf___2), (char const   */* __restrict  */)"%3i",
            st->grid.tiles[i][j].units[p___0][0]);
#line 246
    tmp___17 = wmove(stdscr, y + 2, 30 + p___0 * 5);
    }
#line 246
    if (! (tmp___17 == -1)) {
      {
#line 246
      waddnstr(stdscr, (char const   *)(buf___2), -1);
      }
    }
    __Cont: /* CIL Label */ 
#line 242
    p___0 ++;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 252
  if (stdscr) {
#line 252
    stdscr->_attrs = 1UL << 8;
  }
  {
#line 254
  tmp___18 = wmove(stdscr, y, 65);
  }
#line 254
  if (! (tmp___18 == -1)) {
    {
#line 254
    waddnstr(stdscr, "Date:", -1);
    }
  }
#line 255
  if (stdscr) {
#line 255
    stdscr->_attrs = (attr_t )key_style;
  }
  {
#line 257
  time_to_ymd(st->time, & year, & month, & day);
#line 258
  sprintf((char */* __restrict  */)(buf___2), (char const   */* __restrict  */)"%i-%02i-%02i ",
          year, month, day);
#line 259
  tmp___19 = wmove(stdscr, y, 72);
  }
#line 259
  if (! (tmp___19 == -1)) {
    {
#line 259
    waddnstr(stdscr, (char const   *)(buf___2), -1);
    }
  }
  {
#line 261
  wrefresh(stdscr);
  }
#line 262
  return;
}
}
#line 264 "/home/june/repo/benchmarks/collector/temp/curseofwar-1.1.8/output.c"
void output_dialog_quit_on(struct state *st , struct ui *ui ) 
{ 
  int y ;
  int x ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int text_style ;
  int key_style ;
  int tmp___3 ;

  {
#line 265
  y = st->grid.height / 2 + 1;
#line 266
  x = ((((st->grid.width / 2) * 4 + (st->grid.height / 2) * 2) + 1) - ui->xskip * 4) - 8;
#line 268
  if (stdscr) {
#line 268
    stdscr->_attrs = 1UL << 8;
  }
  {
#line 269
  tmp = wmove(stdscr, y - 2, x);
  }
#line 269
  if (! (tmp == -1)) {
    {
#line 269
    waddnstr(stdscr, "                 ", -1);
    }
  }
  {
#line 270
  tmp___0 = wmove(stdscr, y - 1, x);
  }
#line 270
  if (! (tmp___0 == -1)) {
    {
#line 270
    waddnstr(stdscr, "   Quit? [Y/N]   ", -1);
    }
  }
  {
#line 271
  tmp___1 = wmove(stdscr, y, x);
  }
#line 271
  if (! (tmp___1 == -1)) {
    {
#line 271
    waddnstr(stdscr, "        [Q/Esc]  ", -1);
    }
  }
  {
#line 272
  tmp___2 = wmove(stdscr, y + 1, x);
  }
#line 272
  if (! (tmp___2 == -1)) {
    {
#line 272
    waddnstr(stdscr, "                 ", -1);
    }
  }
  {
#line 274
  text_style = (int )(1UL << 8);
#line 275
  tmp___3 = player_style(st->controlled);
#line 275
  key_style = tmp___3;
#line 277
  output_key(y - 1, x + 9, (char *)"Y/N", key_style, (char *)"", text_style);
  }
#line 280
  if (stdscr) {
#line 280
    stdscr->_attrs = 1UL << 8;
  }
  {
#line 281
  wrefresh(stdscr);
  }
#line 282
  return;
}
}
#line 284 "/home/june/repo/benchmarks/collector/temp/curseofwar-1.1.8/output.c"
void output_dialog_quit_off(struct state *st , struct ui *ui ) 
{ 
  int y ;
  int x ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 285
  y = st->grid.height / 2 + 1;
#line 286
  x = ((((st->grid.width / 2) * 4 + (st->grid.height / 2) * 2) + 1) - ui->xskip * 4) - 8;
#line 287
  tmp = wmove(stdscr, y - 1, x);
  }
#line 287
  if (! (tmp == -1)) {
    {
#line 287
    waddnstr(stdscr, "                 ", -1);
    }
  }
  {
#line 288
  tmp___0 = wmove(stdscr, y, x);
  }
#line 288
  if (! (tmp___0 == -1)) {
    {
#line 288
    waddnstr(stdscr, "                 ", -1);
    }
  }
  {
#line 289
  wrefresh(stdscr);
  }
#line 290
  return;
}
}
#line 296 "/home/june/repo/benchmarks/collector/temp/curseofwar-1.1.8/output.c"
void insert_position(int *pl , float *val , int i , int p , float v ) 
{ 
  int tp ;
  float tv ;

  {
#line 297
  if (i >= 5) {
#line 297
    return;
  }
#line 299
  if (*(pl + i) == 0) {
#line 300
    *(pl + i) = p;
#line 301
    *(val + i) = v;
  } else
#line 304
  if (*(val + i) >= v) {
    {
#line 305
    insert_position(pl, val, i + 1, p, v);
    }
  } else {
    {
#line 308
    tp = *(pl + i);
#line 308
    tv = *(val + i);
#line 309
    *(pl + i) = p;
#line 309
    *(val + i) = v;
#line 310
    insert_position(pl, val, i + 1, tp, tv);
    }
  }
#line 313
  return;
}
}
#line 315 "/home/june/repo/benchmarks/collector/temp/curseofwar-1.1.8/output.c"
void output_timeline(struct state *st , struct ui *ui ) 
{ 
  struct timeline *t ;
  int non_zero[8] ;
  int p ;
  int i ;
  int v ;
  float max ;
  float min ;
  float one_over_delta ;
  int y0___0 ;
  int x0 ;
  int j ;
  int y1___0 ;
  int m1 ;
  int d1 ;
  int y2 ;
  int m2 ;
  int d2 ;
  int x_shift_year ;
  char buf___2[20] ;
  int tmp ;
  int tmp___0 ;
  int dy ;
  int dx ;
  int pp ;
  int store_pl_row[8] ;
  char c ;
  int tmp___1 ;
  double tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int pl_arr[5] ;
  float val_arr[5] ;
  int tmp___7 ;
  int tmp___8 ;

  {
#line 316
  t = & st->timeline;
#line 321
  p = 0;
  {
#line 321
  while (1) {
    while_continue: /* CIL Label */ ;
#line 321
    if (! (p < 8)) {
#line 321
      goto while_break;
    }
#line 322
    non_zero[p] = 0;
#line 323
    i = 0;
    {
#line 323
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 323
      if (! (i <= t->mark)) {
#line 323
        goto while_break___0;
      }
#line 324
      v = (int )t->data[p][i];
#line 325
      if ((double )v >= 0.1) {
#line 325
        non_zero[p] = 1;
      }
#line 323
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 321
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 329
  max = (float )0.0;
#line 330
  min = (float )0.0;
#line 332
  p = 0;
  {
#line 332
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 332
    if (! (p < 8)) {
#line 332
      goto while_break___1;
    }
#line 333
    if (non_zero[p]) {
#line 334
      max = t->data[p][0];
#line 335
      min = max;
    }
#line 332
    p ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 339
  p = 0;
  {
#line 339
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 339
    if (! (p < 8)) {
#line 339
      goto while_break___2;
    }
#line 340
    if (non_zero[p]) {
#line 341
      i = 0;
      {
#line 341
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 341
        if (! (i <= t->mark)) {
#line 341
          goto while_break___3;
        }
#line 342
        v = (int )t->data[p][i];
#line 343
        if ((float )v > max) {
#line 343
          max = (float )v;
        }
#line 344
        if ((float )v < min) {
#line 344
          min = (float )v;
        }
#line 341
        i ++;
      }
      while_break___3: /* CIL Label */ ;
      }
    }
#line 339
    p ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 350
  if ((double )(max - min) < 0.1) {
#line 350
    max = (float )((double )min + 0.1);
  }
#line 351
  one_over_delta = (float )(1.0 / (double )(max - min));
#line 353
  y0___0 = (st->grid.height + 1) + 8;
#line 354
  x0 = 2;
#line 358
  j = 0;
  {
#line 358
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 358
    if (! (j < 6)) {
#line 358
      goto while_break___4;
    }
    {
#line 359
    wmove(stdscr, y0___0 + j, x0);
#line 360
    i = 0;
    }
    {
#line 360
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 360
      if (! (i < 87)) {
#line 360
        goto while_break___5;
      }
      {
#line 361
      waddch(stdscr, (chtype const   )' ');
#line 360
      i ++;
      }
    }
    while_break___5: /* CIL Label */ ;
    }
#line 358
    j ++;
  }
  while_break___4: /* CIL Label */ ;
  }
#line 373
  x_shift_year = -1;
#line 377
  if (stdscr) {
#line 377
    stdscr->_attrs = 1UL << 8;
  }
#line 378
  i = 1 - x_shift_year;
  {
#line 378
  while (1) {
    while_continue___6: /* CIL Label */ ;
#line 378
    if (! (i <= t->mark)) {
#line 378
      goto while_break___6;
    }
    {
#line 379
    time_to_ymd(t->time[i - 1], & y1___0, & m1, & d1);
#line 380
    time_to_ymd(t->time[i], & y2, & m2, & d2);
    }
#line 381
    if (y1___0 < y2) {
      {
#line 382
      sprintf((char */* __restrict  */)(buf___2), (char const   */* __restrict  */)"%i",
              y2);
#line 383
      tmp = wmove(stdscr, ((y0___0 + 5) - 1) + 1, (x0 + i) + x_shift_year);
      }
#line 383
      if (! (tmp == -1)) {
        {
#line 383
        waddnstr(stdscr, (char const   *)(buf___2), -1);
        }
      }
#line 385
      j = 0;
      {
#line 385
      while (1) {
        while_continue___7: /* CIL Label */ ;
#line 385
        if (! (j < 4)) {
#line 385
          goto while_break___7;
        }
        {
#line 386
        tmp___0 = wmove(stdscr, y0___0 + j, x0 + i);
        }
#line 386
        if (! (tmp___0 == -1)) {
          {
#line 386
          waddch(stdscr, (chtype const   )'.');
          }
        }
#line 385
        j ++;
      }
      while_break___7: /* CIL Label */ ;
      }
    }
#line 378
    i ++;
  }
  while_break___6: /* CIL Label */ ;
  }
#line 396
  i = 0;
  {
#line 396
  while (1) {
    while_continue___8: /* CIL Label */ ;
#line 396
    if (! (i <= t->mark)) {
#line 396
      goto while_break___8;
    }
#line 397
    c = (char )'-';
#line 398
    pp = 0;
    {
#line 398
    while (1) {
      while_continue___9: /* CIL Label */ ;
#line 398
      if (! (pp <= 8)) {
#line 398
        goto while_break___9;
      }
#line 399
      p = (pp + i) % 8;
#line 400
      if (pp == 8) {
#line 400
        p = st->controlled;
#line 400
        c = (char )'*';
      }
#line 401
      if (non_zero[p]) {
#line 402
        if (stdscr) {
          {
#line 402
          tmp___1 = player_style(p);
#line 402
          stdscr->_attrs = (attr_t )tmp___1;
          }
        }
        {
#line 403
        dx = i;
#line 404
        tmp___2 = round((double )(((float )4 * (t->data[p][i] - min)) * one_over_delta));
#line 404
        v = (int )tmp___2;
#line 405
        dy = 4 - v;
        }
#line 406
        if (dy < 0) {
#line 406
          dy = 0;
        } else {
#line 406
          if (dy > 4) {
#line 406
            tmp___3 = 4;
          } else {
#line 406
            tmp___3 = dy;
          }
#line 406
          dy = tmp___3;
        }
#line 407
        if (i == t->mark) {
#line 408
          store_pl_row[p] = dy;
        }
        {
#line 409
        tmp___4 = wmove(stdscr, y0___0 + dy, x0 + dx);
        }
#line 409
        if (! (tmp___4 == -1)) {
          {
#line 409
          waddch(stdscr, (chtype const   )c);
          }
        }
      }
#line 398
      pp ++;
    }
    while_break___9: /* CIL Label */ ;
    }
#line 396
    i ++;
  }
  while_break___8: /* CIL Label */ ;
  }
#line 413
  if (stdscr) {
#line 413
    stdscr->_attrs = 1UL << 8;
  }
  {
#line 415
  sprintf((char */* __restrict  */)(buf___2), (char const   */* __restrict  */)"%g",
          (double )max);
#line 416
  tmp___5 = wmove(stdscr, y0___0, x0);
  }
#line 416
  if (! (tmp___5 == -1)) {
    {
#line 416
    waddnstr(stdscr, (char const   *)(buf___2), -1);
    }
  }
  {
#line 417
  sprintf((char */* __restrict  */)(buf___2), (char const   */* __restrict  */)"%g",
          (double )min);
#line 418
  tmp___6 = wmove(stdscr, (y0___0 + 5) - 1, x0);
  }
#line 418
  if (! (tmp___6 == -1)) {
    {
#line 418
    waddnstr(stdscr, (char const   *)(buf___2), -1);
    }
  }
#line 424
  i = 0;
  {
#line 424
  while (1) {
    while_continue___10: /* CIL Label */ ;
#line 424
    if (! (i < 5)) {
#line 424
      goto while_break___10;
    }
#line 425
    pl_arr[i] = 0;
#line 426
    val_arr[i] = (float )0.0;
#line 424
    i ++;
  }
  while_break___10: /* CIL Label */ ;
  }
#line 428
  p = 1;
  {
#line 428
  while (1) {
    while_continue___11: /* CIL Label */ ;
#line 428
    if (! (p < 8)) {
#line 428
      goto while_break___11;
    }
#line 429
    if (non_zero[p]) {
      {
#line 430
      insert_position((int *)(pl_arr), (float *)(val_arr), store_pl_row[p], p, t->data[p][t->mark]);
      }
    }
#line 428
    p ++;
  }
  while_break___11: /* CIL Label */ ;
  }
#line 432
  i = 0;
  {
#line 432
  while (1) {
    while_continue___12: /* CIL Label */ ;
#line 432
    if (! (i < 5)) {
#line 432
      goto while_break___12;
    }
#line 433
    if (pl_arr[i] != 0) {
      {
#line 434
      dx = t->mark + 3;
#line 435
      dy = i;
#line 436
      sprintf((char */* __restrict  */)(buf___2), (char const   */* __restrict  */)"%g",
              (double )val_arr[i]);
      }
#line 437
      if (stdscr) {
        {
#line 437
        tmp___7 = player_style(pl_arr[i]);
#line 437
        stdscr->_attrs = (attr_t )tmp___7;
        }
      }
      {
#line 438
      tmp___8 = wmove(stdscr, y0___0 + dy, x0 + dx);
      }
#line 438
      if (! (tmp___8 == -1)) {
        {
#line 438
        waddnstr(stdscr, (char const   *)(buf___2), -1);
        }
      }
    }
#line 432
    i ++;
  }
  while_break___12: /* CIL Label */ ;
  }
#line 441
  if (stdscr) {
#line 441
    stdscr->_attrs = 1UL << 8;
  }
#line 443
  return;
}
}
#line 376 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) srand)(unsigned int __seed ) ;
#line 61 "/home/june/repo/benchmarks/collector/temp/curseofwar-1.1.8/king.h"
int degrade(struct grid *g , int i , int j ) ;
#line 91
void king_evaluate_map(struct king *k , struct grid *g , enum config_dif dif ) ;
#line 100
void king_init(struct king *k , int pl , enum strategy strat , struct grid *g , enum config_dif dif ) ;
#line 111
int builder_default(struct king *k , struct country *c , struct grid *g , struct flag_grid *fg ) ;
#line 121
void place_flags(struct king *k , struct grid *g , struct flag_grid *fg ) ;
#line 30 "/home/june/repo/benchmarks/collector/temp/curseofwar-1.1.8/state.h"
enum config_speed faster(enum config_speed sp ) ;
#line 35
enum config_speed slower(enum config_speed sp ) ;
#line 111
void state_init(struct state *s , int w , int h , enum stencil shape , unsigned int map_seed ,
                int keep_random , int locations_num , int clients_num , int conditions ,
                int inequality , enum config_speed speed , enum config_dif dif , int timeline_flag ) ;
#line 117
void ui_init(struct state *s , struct ui *ui ) ;
#line 123
void kings_move(struct state *s ) ;
#line 129
void simulate(struct state *s ) ;
#line 134
void update_timeline(struct state *s ) ;
#line 24 "/home/june/repo/benchmarks/collector/temp/curseofwar-1.1.8/state.c"
enum config_speed faster(enum config_speed sp ) 
{ 


  {
  {
#line 26
  if ((unsigned int )sp == 0U) {
#line 26
    goto case_0;
  }
#line 27
  if ((unsigned int )sp == 1U) {
#line 27
    goto case_1;
  }
#line 28
  if ((unsigned int )sp == 2U) {
#line 28
    goto case_2;
  }
#line 29
  if ((unsigned int )sp == 3U) {
#line 29
    goto case_3;
  }
#line 30
  if ((unsigned int )sp == 4U) {
#line 30
    goto case_4;
  }
#line 31
  if ((unsigned int )sp == 5U) {
#line 31
    goto case_5;
  }
#line 32
  goto switch_default;
  case_0: /* CIL Label */ 
#line 26
  return ((enum config_speed )1);
  case_1: /* CIL Label */ 
#line 27
  return ((enum config_speed )2);
  case_2: /* CIL Label */ 
#line 28
  return ((enum config_speed )3);
  case_3: /* CIL Label */ 
#line 29
  return ((enum config_speed )4);
  case_4: /* CIL Label */ 
#line 30
  return ((enum config_speed )5);
  case_5: /* CIL Label */ 
#line 31
  return ((enum config_speed )6);
  switch_default: /* CIL Label */ 
#line 32
  return ((enum config_speed )7);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 36 "/home/june/repo/benchmarks/collector/temp/curseofwar-1.1.8/state.c"
enum config_speed slower(enum config_speed sp ) 
{ 


  {
  {
#line 38
  if ((unsigned int )sp == 7U) {
#line 38
    goto case_7;
  }
#line 39
  if ((unsigned int )sp == 6U) {
#line 39
    goto case_6;
  }
#line 40
  if ((unsigned int )sp == 5U) {
#line 40
    goto case_5;
  }
#line 41
  if ((unsigned int )sp == 4U) {
#line 41
    goto case_4;
  }
#line 42
  if ((unsigned int )sp == 3U) {
#line 42
    goto case_3;
  }
#line 43
  if ((unsigned int )sp == 2U) {
#line 43
    goto case_2;
  }
#line 44
  goto switch_default;
  case_7: /* CIL Label */ 
#line 38
  return ((enum config_speed )6);
  case_6: /* CIL Label */ 
#line 39
  return ((enum config_speed )5);
  case_5: /* CIL Label */ 
#line 40
  return ((enum config_speed )4);
  case_4: /* CIL Label */ 
#line 41
  return ((enum config_speed )3);
  case_3: /* CIL Label */ 
#line 42
  return ((enum config_speed )2);
  case_2: /* CIL Label */ 
#line 43
  return ((enum config_speed )1);
  switch_default: /* CIL Label */ 
#line 44
  return ((enum config_speed )0);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 48 "/home/june/repo/benchmarks/collector/temp/curseofwar-1.1.8/state.c"
void state_init(struct state *s , int w , int h , enum stencil shape , unsigned int map_seed ,
                int keep_random , int locations_num , int clients_num , int conditions ,
                int inequality , enum config_speed speed , enum config_dif dif , int timeline_flag ) 
{ 
  int tmp ;
  int tmp___0 ;
  int all_players[7] ;
  int comp_players[8] ;
  int comp_players_num ;
  int ui_players[8] ;
  int ui_players_num ;
  int i ;
  int j ;
  int conflict_code ;
  struct loc loc_arr[7] ;
  int available_loc_num ;
  int d ;
  int tmp___1 ;
  int p ;

  {
  {
#line 53
  s->speed = speed;
#line 54
  s->prev_speed = s->speed;
#line 55
  s->dif = dif;
#line 56
  s->map_seed = (int )map_seed;
#line 57
  s->conditions = conditions;
#line 58
  s->inequality = inequality;
#line 59
  tmp = rand();
#line 59
  tmp___0 = rand();
#line 59
  s->time = (unsigned long )((1850 + tmp % 100) * 360 + tmp___0 % 360);
#line 62
  s->controlled = 1;
#line 66
  all_players[0] = 1;
#line 66
  all_players[1] = 2;
#line 66
  all_players[2] = 3;
#line 66
  all_players[3] = 4;
#line 66
  all_players[4] = 5;
#line 66
  all_players[5] = 6;
#line 66
  all_players[6] = 7;
#line 68
  comp_players_num = 7 - clients_num;
#line 70
  s->kings_num = comp_players_num;
#line 72
  ui_players_num = clients_num;
#line 74
  i = 0;
  }
  {
#line 74
  while (1) {
    while_continue: /* CIL Label */ ;
#line 74
    if (! (i < 7)) {
#line 74
      goto while_break;
    }
#line 75
    if (i < clients_num) {
#line 76
      ui_players[i] = all_players[i];
    } else {
#line 78
      j = i - clients_num;
#line 79
      comp_players[j] = all_players[i];
      {
#line 81
      if (i == 1) {
#line 81
        goto case_1;
      }
#line 84
      if (i == 2) {
#line 84
        goto case_2;
      }
#line 87
      if (i == 3) {
#line 87
        goto case_3;
      }
#line 90
      if (i == 4) {
#line 90
        goto case_4;
      }
#line 93
      if (i == 5) {
#line 93
        goto case_5;
      }
#line 96
      if (i == 6) {
#line 96
        goto case_6;
      }
#line 80
      goto switch_break;
      case_1: /* CIL Label */ 
      {
#line 82
      king_init(& s->king[j], i + 1, (enum strategy )4, & s->grid, s->dif);
      }
#line 83
      goto switch_break;
      case_2: /* CIL Label */ 
      {
#line 85
      king_init(& s->king[j], i + 1, (enum strategy )2, & s->grid, s->dif);
      }
#line 86
      goto switch_break;
      case_3: /* CIL Label */ 
      {
#line 88
      king_init(& s->king[j], i + 1, (enum strategy )0, & s->grid, s->dif);
      }
#line 89
      goto switch_break;
      case_4: /* CIL Label */ 
      {
#line 91
      king_init(& s->king[j], i + 1, (enum strategy )1, & s->grid, s->dif);
      }
#line 92
      goto switch_break;
      case_5: /* CIL Label */ 
      {
#line 94
      king_init(& s->king[j], i + 1, (enum strategy )5, & s->grid, s->dif);
      }
#line 95
      goto switch_break;
      case_6: /* CIL Label */ 
      {
#line 97
      king_init(& s->king[j], i + 1, (enum strategy )3, & s->grid, s->dif);
      }
#line 98
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    }
#line 74
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 104
  srand((unsigned int )s->map_seed);
#line 108
  conflict_code = 0;
  }
  {
#line 109
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 110
    grid_init(& s->grid, w, h);
#line 114
    available_loc_num = 0;
#line 115
    d = 2;
#line 116
    apply_stencil(shape, & s->grid, d, (struct loc *)(loc_arr), & available_loc_num);
#line 119
    conflict_code = 0;
    }
#line 120
    if (! keep_random) {
      {
#line 121
      conflict_code = conflict(& s->grid, loc_arr, available_loc_num, comp_players,
                               comp_players_num, locations_num, ui_players, ui_players_num,
                               s->conditions, s->inequality);
      }
    }
#line 109
    if (! (conflict_code != 0)) {
      {
#line 109
      tmp___1 = is_connected(& s->grid);
      }
#line 109
      if (tmp___1) {
#line 109
        goto while_break___0;
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 128
  p = 0;
  {
#line 128
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 128
    if (! (p < 8)) {
#line 128
      goto while_break___1;
    }
    {
#line 129
    flag_grid_init(& s->fg[p], w, h);
#line 130
    s->country[p].gold = 0L;
#line 128
    p ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 134
  p = 0;
  {
#line 134
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 134
    if (! (p < s->kings_num)) {
#line 134
      goto while_break___2;
    }
    {
#line 135
    king_evaluate_map(& s->king[p], & s->grid, dif);
#line 134
    p ++;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
#line 139
  s->show_timeline = timeline_flag;
#line 140
  s->timeline.mark = -1;
#line 141
  i = 0;
  {
#line 141
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 141
    if (! (i < 72)) {
#line 141
      goto while_break___3;
    }
#line 142
    s->timeline.time[i] = s->time;
#line 143
    p = 0;
    {
#line 143
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 143
      if (! (p < 8)) {
#line 143
        goto while_break___4;
      }
#line 144
      s->timeline.data[p][i] = (float )0.0;
#line 143
      p ++;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 141
    i ++;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 147
  return;
}
}
#line 150 "/home/june/repo/benchmarks/collector/temp/curseofwar-1.1.8/state.c"
void ui_init(struct state *s , struct ui *ui ) 
{ 
  int i ;
  int j ;
  int x ;
  int tmp ;

  {
#line 152
  ui->cursor.i = s->grid.width / 2;
#line 153
  ui->cursor.j = s->grid.height / 2;
#line 155
  i = 0;
  {
#line 155
  while (1) {
    while_continue: /* CIL Label */ ;
#line 155
    if (! (i < s->grid.width)) {
#line 155
      goto while_break;
    }
#line 156
    j = 0;
    {
#line 156
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 156
      if (! (j < s->grid.height)) {
#line 156
        goto while_break___0;
      }
#line 157
      if (s->grid.tiles[i][j].units[s->controlled][0] > s->grid.tiles[ui->cursor.i][ui->cursor.j].units[s->controlled][0]) {
#line 159
        ui->cursor.i = i;
#line 160
        ui->cursor.j = j;
      }
#line 156
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 155
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 165
  ui->xskip = 81;
#line 166
  i = 0;
  {
#line 166
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 166
    if (! (i < s->grid.width)) {
#line 166
      goto while_break___1;
    }
#line 167
    j = 0;
    {
#line 167
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 167
      if (! (j < s->grid.height)) {
#line 167
        goto while_break___2;
      }
      {
#line 168
      tmp = is_visible(s->grid.tiles[i][j].cl);
      }
#line 168
      if (tmp) {
#line 169
        x = i * 2 + j;
#line 170
        if (ui->xskip > x) {
#line 171
          ui->xskip = x;
        }
      }
#line 167
      j ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 166
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 173
  ui->xskip /= 2;
#line 174
  return;
}
}
#line 184 "/home/june/repo/benchmarks/collector/temp/curseofwar-1.1.8/state.c"
float growth(enum tile_class t ) 
{ 


  {
  {
#line 186
  if ((unsigned int )t == 4U) {
#line 186
    goto case_4;
  }
#line 187
  if ((unsigned int )t == 5U) {
#line 187
    goto case_5;
  }
#line 188
  if ((unsigned int )t == 6U) {
#line 188
    goto case_6;
  }
#line 189
  goto switch_default;
  case_4: /* CIL Label */ 
#line 186
  return ((float )1.10);
  case_5: /* CIL Label */ 
#line 187
  return ((float )1.20);
  case_6: /* CIL Label */ 
#line 188
  return ((float )1.30);
  switch_default: /* CIL Label */ 
#line 189
  return ((float )0);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 193 "/home/june/repo/benchmarks/collector/temp/curseofwar-1.1.8/state.c"
int rnd_round(float x ) 
{ 
  int i ;
  int tmp ;

  {
  {
#line 194
  i = (int )x;
#line 195
  tmp = rand();
  }
#line 195
  if ((float )tmp / (float )2147483647 < x - (float )i) {
#line 195
    i ++;
  }
#line 196
  return (i);
}
}
#line 199 "/home/june/repo/benchmarks/collector/temp/curseofwar-1.1.8/state.c"
void kings_move(struct state *s ) 
{ 
  int i ;
  int ev ;
  int pl ;
  int code ;
  int tmp ;
  int tmp___0 ;

  {
#line 201
  ev = 0;
#line 202
  i = 0;
  {
#line 202
  while (1) {
    while_continue: /* CIL Label */ ;
#line 202
    if (! (i < s->kings_num)) {
#line 202
      goto while_break;
    }
    {
#line 203
    pl = s->king[i].pl;
#line 204
    place_flags(& s->king[i], & s->grid, & s->fg[pl]);
#line 205
    tmp = builder_default(& s->king[i], & s->country[pl], & s->grid, & s->fg[pl]);
#line 205
    code = tmp;
    }
#line 206
    if (ev) {
#line 206
      tmp___0 = 1;
    } else
#line 206
    if (code == 0) {
#line 206
      tmp___0 = 1;
    } else {
#line 206
      tmp___0 = 0;
    }
#line 206
    ev = tmp___0;
#line 202
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 208
  if (ev) {
#line 209
    i = 0;
    {
#line 209
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 209
      if (! (i < s->kings_num)) {
#line 209
        goto while_break___0;
      }
      {
#line 210
      king_evaluate_map(& s->king[i], & s->grid, s->dif);
#line 209
      i ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 213
  return;
}
}
#line 215 "/home/june/repo/benchmarks/collector/temp/curseofwar-1.1.8/state.c"
void simulate(struct state *s ) 
{ 
  int i ;
  int j ;
  struct tile (*t)[29] ;
  int enemy_pop[8] ;
  int my_pop[8] ;
  int need_to_reeval ;
  int k ;
  int owner ;
  int di ;
  int dj ;
  int pl ;
  int tmp ;
  int p ;
  int total_pop ;
  int defender_dmg ;
  int dmg ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int owner___0 ;
  int pop ;
  float fnpop ;
  float tmp___4 ;
  int npop ;
  int tmp___5 ;
  int tmp___6 ;
  int k___0 ;
  int di___0 ;
  int dj___0 ;
  int p___0 ;
  int i_start ;
  int i_end ;
  int i_inc ;
  int j_start ;
  int j_end ;
  int j_inc ;
  int tmp___7 ;
  int tmp___8 ;
  int initial_pop ;
  int k_shift ;
  int tmp___9 ;
  int pop___0 ;
  int dcall ;
  int tmp___10 ;
  int dpop ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int add_gold ;

  {
#line 217
  t = s->grid.tiles;
#line 221
  need_to_reeval = 0;
#line 224
  (s->time) ++;
#line 227
  i = 0;
  {
#line 227
  while (1) {
    while_continue: /* CIL Label */ ;
#line 227
    if (! (i < s->grid.width)) {
#line 227
      goto while_break;
    }
#line 228
    j = 0;
    {
#line 228
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 228
      if (! (j < s->grid.height)) {
#line 228
        goto while_break___0;
      }
#line 230
      if ((unsigned int )(*(t + i))[j].cl == 2U) {
#line 232
        owner = 0;
#line 233
        k = 0;
        {
#line 233
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 233
          if (! (k < 6)) {
#line 233
            goto while_break___1;
          }
#line 234
          di = (int )dirs[k].i;
#line 235
          dj = (int )dirs[k].j;
#line 236
          if (i + di >= 0) {
#line 236
            if (i + di < s->grid.width) {
#line 236
              if (j + dj >= 0) {
#line 236
                if (j + dj < s->grid.height) {
                  {
#line 236
                  tmp = is_inhabitable((*(t + (i + di)))[j + dj].cl);
                  }
#line 236
                  if (tmp) {
#line 239
                    pl = (*(t + (i + di)))[j + dj].pl;
#line 240
                    if (owner == 0) {
#line 241
                      owner = pl;
                    } else
#line 242
                    if (owner != pl) {
#line 242
                      if (pl != 0) {
#line 243
                        owner = -1;
                      }
                    }
                  }
                }
              }
            }
          }
#line 233
          k ++;
        }
        while_break___1: /* CIL Label */ ;
        }
#line 246
        if (owner != -1) {
#line 247
          (*(t + i))[j].pl = owner;
        } else {
#line 249
          (*(t + i))[j].pl = 0;
        }
#line 251
        if ((*(t + i))[j].pl != 0) {
#line 252
          (s->country[owner].gold) ++;
        }
      }
#line 258
      total_pop = 0;
#line 259
      p = 0;
      {
#line 259
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 259
        if (! (p < 8)) {
#line 259
          goto while_break___2;
        }
#line 260
        my_pop[p] = (*(t + i))[j].units[p][0];
#line 261
        total_pop += my_pop[p];
#line 259
        p ++;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 263
      defender_dmg = 0;
#line 264
      p = 0;
      {
#line 264
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 264
        if (! (p < 8)) {
#line 264
          goto while_break___3;
        }
        {
#line 265
        enemy_pop[p] = total_pop - my_pop[p];
#line 266
        tmp___0 = rnd_round(((float )enemy_pop[p] * (float )my_pop[p]) / (float )total_pop);
#line 266
        dmg = tmp___0;
        }
#line 267
        if (my_pop[p] - dmg < 0) {
#line 267
          (*(t + i))[j].units[p][0] = 0;
        } else {
#line 267
          (*(t + i))[j].units[p][0] = my_pop[p] - dmg;
        }
#line 269
        if ((*(t + i))[j].pl == p) {
#line 270
          defender_dmg = dmg;
        }
#line 264
        p ++;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 274
      if ((double )defender_dmg > (2.0 * (double )499) * 0.1) {
        {
#line 274
        tmp___2 = is_a_city((*(t + i))[j].cl);
        }
#line 274
        if (tmp___2) {
          {
#line 275
          tmp___1 = rand();
#line 276
          need_to_reeval = 1;
#line 277
          degrade(& s->grid, i, j);
          }
        }
      }
      {
#line 282
      tmp___3 = is_inhabitable((*(t + i))[j].cl);
      }
#line 282
      if (tmp___3) {
#line 283
        (*(t + i))[j].pl = 0;
#line 284
        p = 0;
        {
#line 284
        while (1) {
          while_continue___4: /* CIL Label */ ;
#line 284
          if (! (p < 8)) {
#line 284
            goto while_break___4;
          }
#line 285
          if ((*(t + i))[j].units[p][0] > (*(t + i))[j].units[(*(t + i))[j].pl][0]) {
#line 286
            (*(t + i))[j].pl = p;
          }
#line 284
          p ++;
        }
        while_break___4: /* CIL Label */ ;
        }
      }
      {
#line 291
      tmp___6 = is_a_city((*(t + i))[j].cl);
      }
#line 291
      if (tmp___6) {
        {
#line 293
        owner___0 = (*(t + i))[j].pl;
#line 294
        pop = (*(t + i))[j].units[owner___0][0];
#line 295
        tmp___4 = growth((*(t + i))[j].cl);
#line 295
        fnpop = (float )pop * tmp___4;
#line 296
        tmp___5 = rnd_round(fnpop);
#line 296
        npop = tmp___5;
        }
#line 297
        if (npop < 499) {
#line 297
          npop = npop;
        } else {
#line 297
          npop = 499;
        }
#line 302
        (*(t + i))[j].units[owner___0][0] = npop;
      }
#line 228
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 227
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 312
  tmp___7 = rand();
  }
#line 312
  if (tmp___7 % 2 == 0) {
#line 312
    i_start = 0;
#line 312
    i_end = s->grid.width;
#line 312
    i_inc = 1;
  } else {
#line 313
    i_start = s->grid.width - 1;
#line 313
    i_end = -1;
#line 313
    i_inc = -1;
  }
  {
#line 315
  tmp___8 = rand();
  }
#line 315
  if (tmp___8 % 2 == 0) {
#line 315
    j_start = 0;
#line 315
    j_end = s->grid.height;
#line 315
    j_inc = 1;
  } else {
#line 316
    j_start = s->grid.height - 1;
#line 316
    j_end = -1;
#line 316
    j_inc = -1;
  }
#line 318
  i = i_start;
  {
#line 318
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 318
    if (! (i != i_end)) {
#line 318
      goto while_break___5;
    }
#line 319
    j = j_start;
    {
#line 319
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 319
      if (! (j != j_end)) {
#line 319
        goto while_break___6;
      }
#line 320
      p___0 = 0;
      {
#line 320
      while (1) {
        while_continue___7: /* CIL Label */ ;
#line 320
        if (! (p___0 < 8)) {
#line 320
          goto while_break___7;
        }
        {
#line 321
        initial_pop = (*(t + i))[j].units[p___0][0];
#line 323
        tmp___9 = rand();
#line 323
        k_shift = tmp___9 % 6;
#line 324
        k___0 = 0;
        }
        {
#line 324
        while (1) {
          while_continue___8: /* CIL Label */ ;
#line 324
          if (! (k___0 < 6)) {
#line 324
            goto while_break___8;
          }
#line 325
          di___0 = (int )dirs[(k___0 + k_shift) % 6].i;
#line 326
          dj___0 = (int )dirs[(k___0 + k_shift) % 6].j;
#line 327
          if (i + di___0 >= 0) {
#line 327
            if (i + di___0 < s->grid.width) {
#line 327
              if (j + dj___0 >= 0) {
#line 327
                if (j + dj___0 < s->grid.height) {
                  {
#line 327
                  tmp___12 = is_inhabitable((*(t + (i + di___0)))[j + dj___0].cl);
                  }
#line 327
                  if (tmp___12) {
#line 330
                    pop___0 = (*(t + i))[j].units[p___0][0];
#line 331
                    if (0 < s->fg[p___0].call[i + di___0][j + dj___0] - s->fg[p___0].call[i][j]) {
#line 331
                      tmp___10 = s->fg[p___0].call[i + di___0][j + dj___0] - s->fg[p___0].call[i][j];
                    } else {
#line 331
                      tmp___10 = 0;
                    }
#line 331
                    dcall = tmp___10;
#line 332
                    if (pop___0 > 0) {
                      {
#line 333
                      tmp___11 = rnd_round((float )(0.05 * (double )initial_pop + (0.10 * (double )dcall) * (double )initial_pop));
#line 333
                      dpop = tmp___11;
                      }
#line 334
                      if (dpop < pop___0) {
#line 334
                        dpop = dpop;
                      } else {
#line 334
                        dpop = pop___0;
                      }
#line 335
                      if (dpop < 499 - (*(t + (i + di___0)))[j + dj___0].units[p___0][0]) {
#line 335
                        dpop = dpop;
                      } else {
#line 335
                        dpop = 499 - (*(t + (i + di___0)))[j + dj___0].units[p___0][0];
                      }
#line 336
                      (*(t + (i + di___0)))[j + dj___0].units[p___0][0] += dpop;
#line 337
                      (*(t + i))[j].units[p___0][0] -= dpop;
                    }
                  }
                }
              }
            }
          }
#line 324
          k___0 ++;
        }
        while_break___8: /* CIL Label */ ;
        }
#line 320
        p___0 ++;
      }
      while_break___7: /* CIL Label */ ;
      }
#line 319
      j += j_inc;
    }
    while_break___6: /* CIL Label */ ;
    }
#line 318
    i += i_inc;
  }
  while_break___5: /* CIL Label */ ;
  }
#line 346
  i = 0;
  {
#line 346
  while (1) {
    while_continue___9: /* CIL Label */ ;
#line 346
    if (! (i < s->grid.width)) {
#line 346
      goto while_break___9;
    }
#line 347
    j = 0;
    {
#line 347
    while (1) {
      while_continue___10: /* CIL Label */ ;
#line 347
      if (! (j < s->grid.height)) {
#line 347
        goto while_break___10;
      }
      {
#line 348
      tmp___13 = is_inhabitable((*(t + i))[j].cl);
      }
#line 348
      if (tmp___13) {
#line 349
        (*(t + i))[j].pl = 0;
#line 350
        p___0 = 0;
        {
#line 350
        while (1) {
          while_continue___11: /* CIL Label */ ;
#line 350
          if (! (p___0 < 8)) {
#line 350
            goto while_break___11;
          }
#line 351
          if ((*(t + i))[j].units[p___0][0] > (*(t + i))[j].units[(*(t + i))[j].pl][0]) {
#line 352
            (*(t + i))[j].pl = p___0;
          }
#line 350
          p___0 ++;
        }
        while_break___11: /* CIL Label */ ;
        }
      }
#line 347
      j ++;
    }
    while_break___10: /* CIL Label */ ;
    }
#line 346
    i ++;
  }
  while_break___9: /* CIL Label */ ;
  }
#line 359
  if (need_to_reeval) {
#line 360
    i = 0;
    {
#line 360
    while (1) {
      while_continue___12: /* CIL Label */ ;
#line 360
      if (! (i < s->kings_num)) {
#line 360
        goto while_break___12;
      }
      {
#line 361
      king_evaluate_map(& s->king[i], & s->grid, s->dif);
#line 360
      i ++;
      }
    }
    while_break___12: /* CIL Label */ ;
    }
  }
#line 366
  add_gold = 0;
  {
#line 368
  if ((unsigned int )s->dif == 3U) {
#line 368
    goto case_3;
  }
#line 369
  if ((unsigned int )s->dif == 4U) {
#line 369
    goto case_4;
  }
#line 370
  goto switch_default;
  case_3: /* CIL Label */ 
#line 368
  add_gold = 1;
#line 368
  goto switch_break;
  case_4: /* CIL Label */ 
#line 369
  add_gold = 2;
#line 369
  goto switch_break;
  switch_default: /* CIL Label */ ;
  switch_break: /* CIL Label */ ;
  }
#line 372
  i = 0;
  {
#line 372
  while (1) {
    while_continue___13: /* CIL Label */ ;
#line 372
    if (! (i < 8)) {
#line 372
      goto while_break___13;
    }
#line 373
    if (i != 0) {
#line 373
      if (i != s->controlled) {
#line 373
        if (s->country[i].gold > 0L) {
#line 374
          s->country[i].gold += (long )add_gold;
        }
      }
    }
#line 372
    i ++;
  }
  while_break___13: /* CIL Label */ ;
  }
#line 376
  return;
}
}
#line 379 "/home/june/repo/benchmarks/collector/temp/curseofwar-1.1.8/state.c"
void update_timeline(struct state *s ) 
{ 
  struct timeline *t ;
  int p ;
  int i ;
  int j ;
  int count ;

  {
#line 381
  t = & s->timeline;
#line 385
  if (t->mark + 1 < 72) {
#line 386
    (t->mark) ++;
  } else {
#line 389
    i = 0;
    {
#line 389
    while (1) {
      while_continue: /* CIL Label */ ;
#line 389
      if (! (i < 71)) {
#line 389
        goto while_break;
      }
#line 390
      t->time[i] = t->time[i + 1];
#line 391
      p = 0;
      {
#line 391
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 391
        if (! (p < 8)) {
#line 391
          goto while_break___0;
        }
#line 392
        t->data[p][i] = t->data[p][i + 1];
#line 391
        p ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 389
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 398
  t->time[t->mark] = s->time;
#line 400
  p = 0;
  {
#line 400
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 400
    if (! (p < 8)) {
#line 400
      goto while_break___1;
    }
#line 401
    count = 0;
#line 402
    i = 0;
    {
#line 402
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 402
      if (! (i < 40)) {
#line 402
        goto while_break___2;
      }
#line 403
      j = 0;
      {
#line 403
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 403
        if (! (j < 29)) {
#line 403
          goto while_break___3;
        }
#line 404
        count += s->grid.tiles[i][j].units[p][0];
#line 403
        j ++;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 402
      i ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 407
    t->data[p][t->mark] = (float )count;
#line 400
    p ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 410
  return;
}
}
#line 469 "/usr/include/unistd.h"
extern int pause(void) ;
#line 57 "/usr/include/getopt.h"
extern char *optarg ;
#line 76
extern int opterr ;
#line 150
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) getopt)(int ___argc ,
                                                                             char * const  *___argv ,
                                                                             char const   *__shortopts ) ;
#line 168 "/usr/include/stdio.h"
extern struct _IO_FILE *stdin ;
#line 362
extern int printf(char const   * __restrict  __format  , ...) ;
#line 709
extern size_t fread(void * __restrict  __ptr , size_t __size , size_t __n , FILE * __restrict  __stream ) ;
#line 587 "/usr/include/curses.h"
extern int cbreak(void) ;
#line 597
extern int curs_set(int  ) ;
#line 608
extern int echo(void) ;
#line 611
extern int endwin(void) ;
#line 632
extern WINDOW *initscr(void) ;
#line 634
extern int init_pair(short  , short  , short  ) ;
#line 711
extern int noecho(void) ;
#line 764
extern int start_color(void) ;
#line 801
extern int wclear(WINDOW * ) ;
#line 804
extern int wcolor_set(WINDOW * , short  , void * ) ;
#line 890
extern int assume_default_colors(int  , int  ) ;
#line 899
extern int use_default_colors(void) ;
#line 124 "/usr/include/locale.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) setlocale)(int __category ,
                                                                                  char const   *__locale ) ;
#line 215 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) sigemptyset)(sigset_t *__set ) ;
#line 259
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) sigaction)(int __sig ,
                                                                                struct sigaction  const  * __restrict  __act ,
                                                                                struct sigaction * __restrict  __oact ) ;
#line 144 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 176
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strdup)(char const   *__s )  __attribute__((__malloc__)) ;
#line 131 "/usr/include/x86_64-linux-gnu/sys/time.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) setitimer)(__itimer_which_t __which ,
                                                                                struct itimerval  const  * __restrict  __new ,
                                                                                struct itimerval * __restrict  __old ) ;
#line 192 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) time_t ( __attribute__((__leaf__)) time)(time_t *__timer ) ;
#line 137 "/usr/include/fcntl.h"
extern int fcntl(int __fd , int __cmd  , ...) ;
#line 183 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) long ( __attribute__((__nonnull__(1), __leaf__)) strtol)(char const   * __restrict  __nptr ,
                                                                                              char ** __restrict  __endptr ,
                                                                                              int __base ) ;
#line 515
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) abort)(void) ;
#line 775
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) abs)(int __x )  __attribute__((__const__)) ;
#line 50 "/home/june/repo/benchmarks/collector/temp/curseofwar-1.1.8/king.h"
int build(struct grid *g , struct country *c , int pl , int i , int j ) ;
#line 46 "/home/june/repo/benchmarks/collector/temp/curseofwar-1.1.8/server.h"
void server_send_msg_s_state(int sfd , struct client_record *cl , int cl_num , struct state *st ) ;
#line 48
int server_process_msg_c(uint8_t *buf___2 , int nread , struct state *st , int pl ) ;
#line 50
int server_get_msg(uint8_t *buf___2 , int nread ) ;
#line 44 "/home/june/repo/benchmarks/collector/temp/curseofwar-1.1.8/main.c"
sig_atomic_t volatile   input_ready  ;
#line 45 "/home/june/repo/benchmarks/collector/temp/curseofwar-1.1.8/main.c"
sig_atomic_t volatile   time_to_redraw  ;
#line 51
void on_timer(int signum ) ;
#line 52
int update_from_input(struct state *st , struct ui *ui ) ;
#line 53
int update_from_input_client(struct state *st , struct ui *ui , int sfd , struct addrinfo *srv_addr ) ;
#line 54
int update_from_input_server(struct state *st ) ;
#line 56 "/home/june/repo/benchmarks/collector/temp/curseofwar-1.1.8/main.c"
void print_help(void) 
{ 


  {
  {
#line 57
  printf((char const   */* __restrict  */)"                                 __                      \n    ____                        /  ]                     \n   / __ \\_ _ ___ ___ ___    __ _| |_  /\\      /\\___ ___  \n _/ /  \\/ | |X _/ __/ __\\  /   \\   /  \\ \\ /\\ / /__ \\X _/ \n \\ X    | | | | |__ | __X  | X || |    \\ V  V // _ | |   \n  \\ \\__/\\ __X_| \\___/___/  \\___/| |     \\ /\\ / \\___X_|   \n   \\____/                       |/       V  V            \n\n  Written by Alexey Nikolaev in 2013.\n\n");
#line 69
  printf((char const   */* __restrict  */)"  Command line arguments:\n\n");
#line 70
  printf((char const   */* __restrict  */)"-W width\n\tMap width (default is 21)\n\n-H height\n\tMap height (default is 21)\n\n-S [rhombus|rect|hex]\n\tMap shape (rectangle is default). Max number of countries N=4 for rhombus and rectangle, and N=6 for the hexagon.\n\n-l [2|3| ... N]\n\tSets L, the number of countries (default is N).\n\n-i [0|1|2|3|4]\n\tInequality between the countries (0 is the lowest, 4 in the highest).\n\n-q [1|2| ... L]\n\tChoose player\'s location by its quality (1 = the best available on the map, L = the worst). Only in the singleplayer mode.\n\n-r\n\tAbsolutely random initial conditions, overrides options -l, -i, and -q.\n\n-d [ee|e|n|h|hh]\n\tDifficulty level (AI) from the easiest to the hardest (default is normal).\n\n-s [p|sss|ss|s|n|f|ff|fff]\n\tGame speed from the slowest to the fastest (default is normal).\n\n-R seed\n\tSpecify a random seed (unsigned integer) for map generation.\n\n-T\n\tShow the timeline.\n\n-E [1|2| ... L]\n\tStart a server for not more than L clients.\n\n-e port\n\tServer\'s port (19140 is default).\n\n-C IP\n\tStart a client and connect to the provided server\'s IP-address.\n\n-c port\n\tClients\'s port (19150 is default).\n\n-h\n\tDisplay this help \n\n");
  }
#line 104
  return;
}
}
#line 106 "/home/june/repo/benchmarks/collector/temp/curseofwar-1.1.8/main.c"
void win_or_lose(struct state *st , int k ) 
{ 
  int i ;
  int j ;
  int p ;
  int pop[8] ;
  int tmp ;
  int win ;
  int lose ;
  int best ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 109
  p = 0;
  {
#line 109
  while (1) {
    while_continue: /* CIL Label */ ;
#line 109
    if (! (p < 8)) {
#line 109
      goto while_break;
    }
#line 109
    pop[p] = 0;
#line 109
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 111
  i = 0;
  {
#line 111
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 111
    if (! (i < st->grid.width)) {
#line 111
      goto while_break___0;
    }
#line 112
    j = 0;
    {
#line 112
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 112
      if (! (j < st->grid.height)) {
#line 112
        goto while_break___1;
      }
      {
#line 113
      tmp = is_inhabitable(st->grid.tiles[i][j].cl);
      }
#line 113
      if (tmp) {
#line 114
        p = 0;
        {
#line 114
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 114
          if (! (p < 8)) {
#line 114
            goto while_break___2;
          }
#line 115
          pop[p] += st->grid.tiles[i][j].units[p][0];
#line 114
          p ++;
        }
        while_break___2: /* CIL Label */ ;
        }
      }
#line 112
      j ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 111
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 121
  win = 1;
#line 122
  lose = 0;
#line 123
  best = 0;
#line 124
  p = 0;
  {
#line 124
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 124
    if (! (p < 8)) {
#line 124
      goto while_break___3;
    }
#line 125
    if (pop[best] < pop[p]) {
#line 125
      best = p;
    }
#line 126
    if (p != st->controlled) {
#line 126
      if (pop[p] > 0) {
#line 126
        win = 0;
      }
    }
#line 124
    p ++;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 128
  if (pop[st->controlled] == 0) {
#line 128
    lose = 1;
  }
#line 130
  if (win) {
#line 131
    if (stdscr) {
#line 131
      stdscr->_attrs = (1UL << 21) | (4UL << 8);
    }
    {
#line 132
    tmp___0 = wmove(stdscr, 2 + st->grid.height, 31);
    }
#line 132
    if (! (tmp___0 == -1)) {
      {
#line 132
      waddnstr(stdscr, "You are victorious!", -1);
      }
    }
  } else
#line 134
  if (lose) {
#line 135
    if (stdscr) {
#line 135
      stdscr->_attrs = (1UL << 21) | (2UL << 8);
    }
    {
#line 136
    tmp___1 = wmove(stdscr, 2 + st->grid.height, 31);
    }
#line 136
    if (! (tmp___1 == -1)) {
      {
#line 136
      waddnstr(stdscr, "You are defeated!", -1);
      }
    }
  }
#line 138
  return;
}
}
#line 140 "/home/june/repo/benchmarks/collector/temp/curseofwar-1.1.8/main.c"
int game_slowdown(int speed ) 
{ 
  int slowdown ;

  {
#line 141
  slowdown = 20;
  {
#line 143
  if (speed == 0) {
#line 143
    goto case_0;
  }
#line 144
  if (speed == 1) {
#line 144
    goto case_1;
  }
#line 145
  if (speed == 2) {
#line 145
    goto case_2;
  }
#line 146
  if (speed == 3) {
#line 146
    goto case_3;
  }
#line 147
  if (speed == 4) {
#line 147
    goto case_4;
  }
#line 148
  if (speed == 5) {
#line 148
    goto case_5;
  }
#line 149
  if (speed == 6) {
#line 149
    goto case_6;
  }
#line 150
  if (speed == 7) {
#line 150
    goto case_7;
  }
#line 142
  goto switch_break;
  case_0: /* CIL Label */ 
#line 143
  slowdown = 1;
#line 143
  goto switch_break;
  case_1: /* CIL Label */ 
#line 144
  slowdown = 160;
#line 144
  goto switch_break;
  case_2: /* CIL Label */ 
#line 145
  slowdown = 80;
#line 145
  goto switch_break;
  case_3: /* CIL Label */ 
#line 146
  slowdown = 40;
#line 146
  goto switch_break;
  case_4: /* CIL Label */ 
#line 147
  slowdown = 20;
#line 147
  goto switch_break;
  case_5: /* CIL Label */ 
#line 148
  slowdown = 10;
#line 148
  goto switch_break;
  case_6: /* CIL Label */ 
#line 149
  slowdown = 5;
#line 149
  goto switch_break;
  case_7: /* CIL Label */ 
#line 150
  slowdown = 2;
#line 150
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 152
  return (slowdown);
}
}
#line 156 "/home/june/repo/benchmarks/collector/temp/curseofwar-1.1.8/main.c"
void run(struct state *st , struct ui *ui ) 
{ 
  int k ;
  int finished ;
  int slowdown ;
  int tmp ;

  {
#line 157
  k = 0;
#line 158
  finished = 0;
  {
#line 159
  while (1) {
    while_continue: /* CIL Label */ ;
#line 159
    if (! (! finished)) {
#line 159
      goto while_break;
    }
#line 160
    if (time_to_redraw) {
#line 161
      k ++;
#line 162
      if (k >= 1600) {
#line 162
        k = 0;
      }
      {
#line 164
      tmp = game_slowdown((int )st->speed);
#line 164
      slowdown = tmp;
      }
#line 165
      if (k % slowdown == 0) {
#line 165
        if ((unsigned int )st->speed != 0U) {
          {
#line 166
          kings_move(st);
#line 167
          simulate(st);
          }
#line 168
          if (st->show_timeline) {
#line 169
            if (st->time % 10UL == 0UL) {
              {
#line 170
              update_timeline(st);
              }
            }
          }
        }
      }
      {
#line 173
      output_grid(st, ui, k);
      }
#line 174
      if (st->show_timeline) {
#line 175
        if (st->time % 10UL == 0UL) {
          {
#line 176
          output_timeline(st, ui);
          }
        }
      }
#line 178
      time_to_redraw = (sig_atomic_t volatile   )0;
#line 180
      if (k % 100 == 0) {
        {
#line 180
        win_or_lose(st, k);
        }
      }
    }
    {
#line 182
    finished = update_from_input(st, ui);
#line 183
    pause();
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 185
  return;
}
}
#line 188 "/home/june/repo/benchmarks/collector/temp/curseofwar-1.1.8/main.c"
void run_client(struct state *st , struct ui *ui , char *s_server_addr , char *s_server_port ,
                char *s_client_port ) 
{ 
  int sfd ;
  int ret_code ;
  struct addrinfo srv_addr ;
  int k ;
  int finished ;
  int initialized ;
  int msg ;
  int tmp ;

  {
  {
#line 195
  ret_code = client_init_session(& sfd, s_client_port, & srv_addr, s_server_addr,
                                 s_server_port);
  }
#line 195
  if (ret_code != 0) {
    {
#line 197
    perror("Failed to initialize networking");
    }
#line 198
    return;
  }
  {
#line 201
  fcntl(sfd, 4, 2048);
#line 203
  k = 0;
#line 204
  finished = 0;
#line 205
  initialized = 0;
#line 206
  st->time = 0UL;
  }
  {
#line 207
  while (1) {
    while_continue: /* CIL Label */ ;
#line 207
    if (! (! finished)) {
#line 207
      goto while_break;
    }
#line 208
    if (time_to_redraw) {
#line 209
      k ++;
#line 210
      if (k >= 1600) {
#line 210
        k = 0;
      }
#line 211
      time_to_redraw = (sig_atomic_t volatile   )0;
#line 213
      if (k % 50 == 0) {
        {
#line 214
        send_msg_c(sfd, & srv_addr, (uint8_t )30, (uint8_t )0, (uint8_t )0, (uint8_t )0);
        }
      }
      {
#line 216
      tmp = client_receive_msg_s(sfd, st);
#line 216
      msg = tmp;
      }
#line 217
      if (msg == 10) {
#line 217
        if (initialized != 1) {
          {
#line 218
          initialized = 1;
#line 219
          ui_init(st, ui);
          }
        }
      }
#line 221
      if (initialized) {
        {
#line 222
        output_grid(st, ui, k);
        }
      }
    }
    {
#line 225
    finished = update_from_input_client(st, ui, sfd, & srv_addr);
#line 226
    pause();
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 229
  close(sfd);
  }
#line 230
  return;
}
}
#line 233 "/home/june/repo/benchmarks/collector/temp/curseofwar-1.1.8/main.c"
void run_server(struct state *st , int cl_num_need , char *s_server_port ) 
{ 
  int sfd ;
  struct sockaddr_storage peer_addr ;
  socklen_t peer_addr_len ;
  ssize_t nread ;
  uint8_t buf___2[50000] ;
  int ret_code ;
  int cl_num ;
  struct client_record cl[8] ;
  enum server_mode mode ;
  int finished ;
  int k ;
  int i ;
  int found ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int slowdown ;
  int tmp___2 ;
  int found_i ;
  int i___0 ;
  int tmp___3 ;
  int msg ;
  int tmp___4 ;

  {
  {
#line 236
  peer_addr_len = (socklen_t )sizeof(struct sockaddr_storage );
#line 243
  ret_code = server_init(& sfd, s_server_port);
  }
#line 243
  if (ret_code != 0) {
    {
#line 244
    perror("Failed to initialize networking");
    }
#line 245
    return;
  }
  {
#line 248
  fcntl(sfd, 4, 2048);
#line 250
  cl_num = 0;
#line 252
  mode = (enum server_mode )0;
#line 253
  finished = 0;
#line 254
  k = 0;
  }
  {
#line 255
  while (1) {
    while_continue: /* CIL Label */ ;
#line 255
    if (! (! finished)) {
#line 255
      goto while_break;
    }
#line 256
    if (time_to_redraw) {
      {
#line 258
      if ((unsigned int )mode == 0U) {
#line 258
        goto case_0;
      }
#line 286
      if ((unsigned int )mode == 1U) {
#line 286
        goto case_1;
      }
#line 257
      goto switch_break;
      case_0: /* CIL Label */ 
      {
#line 260
      nread = recvfrom(sfd, (void */* __restrict  */)(buf___2), (size_t )49999, 0,
                       (struct sockaddr */* __restrict  */)((struct sockaddr *)(& peer_addr)),
                       (socklen_t */* __restrict  */)(& peer_addr_len));
#line 263
      tmp___1 = server_get_msg((uint8_t *)(buf___2), (int )nread);
      }
#line 263
      if (tmp___1 > 0) {
#line 265
        found = 0;
#line 266
        i = 0;
        {
#line 266
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 266
          if (! (i < cl_num)) {
#line 266
            goto while_break___0;
          }
#line 267
          if (found) {
#line 267
            tmp___0 = 1;
          } else {
            {
#line 267
            tmp = sa_match(& peer_addr, & cl[i].sa);
            }
#line 267
            if (tmp) {
#line 267
              tmp___0 = 1;
            } else {
#line 267
              tmp___0 = 0;
            }
          }
#line 267
          found = tmp___0;
#line 266
          i ++;
        }
        while_break___0: /* CIL Label */ ;
        }
#line 269
        if (! found) {
#line 269
          if (cl_num < cl_num_need) {
            {
#line 270
            cl[cl_num].name = (char *)"Jim";
#line 271
            cl[cl_num].id = cl_num;
#line 272
            cl[cl_num].pl = cl_num + 1;
#line 273
            cl[cl_num].sa = peer_addr;
#line 275
            waddnstr(stdscr, "!", -1);
#line 276
            wrefresh(stdscr);
#line 277
            cl_num ++;
            }
          }
        }
#line 280
        if (cl_num >= cl_num_need) {
#line 281
          mode = (enum server_mode )1;
#line 282
          cl_num = cl_num_need;
        }
      }
#line 285
      goto switch_break;
      case_1: /* CIL Label */ 
#line 288
      k ++;
#line 289
      if (k >= 1600) {
#line 289
        k = 0;
      }
      {
#line 290
      tmp___2 = game_slowdown((int )st->speed);
#line 290
      slowdown = tmp___2;
      }
#line 291
      if (k % slowdown == 0) {
#line 291
        if ((unsigned int )st->speed != 0U) {
          {
#line 292
          kings_move(st);
#line 293
          simulate(st);
#line 294
          server_send_msg_s_state(sfd, cl, cl_num, st);
          }
        }
      }
      {
#line 297
      nread = recvfrom(sfd, (void */* __restrict  */)(buf___2), (size_t )49999, 0,
                       (struct sockaddr */* __restrict  */)((struct sockaddr *)(& peer_addr)),
                       (socklen_t */* __restrict  */)(& peer_addr_len));
      }
#line 299
      if (nread != -1L) {
#line 300
        found_i = -1;
#line 302
        i___0 = 0;
        {
#line 302
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 302
          if (! (i___0 < cl_num)) {
#line 302
            goto while_break___1;
          }
          {
#line 303
          tmp___3 = sa_match(& peer_addr, & cl[i___0].sa);
          }
#line 303
          if (tmp___3) {
#line 303
            found_i = i___0;
          }
#line 302
          i___0 ++;
        }
        while_break___1: /* CIL Label */ ;
        }
#line 305
        if (found_i > -1) {
          {
#line 306
          tmp___4 = server_process_msg_c((uint8_t *)(buf___2), (int )nread, st, cl[found_i].pl);
#line 306
          msg = tmp___4;
          }
#line 307
          if (msg == 30) {
            {
#line 307
            waddnstr(stdscr, ".", -1);
            }
          } else {
            {
#line 308
            waddnstr(stdscr, "+", -1);
            }
          }
          {
#line 309
          wrefresh(stdscr);
          }
        }
      }
#line 312
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
#line 315
      time_to_redraw = (sig_atomic_t volatile   )0;
    }
    {
#line 317
    finished = update_from_input_server(st);
#line 318
    pause();
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 320
  close(sfd);
  }
#line 321
  return;
}
}
#line 326 "/home/june/repo/benchmarks/collector/temp/curseofwar-1.1.8/main.c"
int main(int argc , char **argv ) 
{ 
  time_t tmp ;
  int r_flag ;
  int dif_val ;
  int sp_val ;
  int w_val ;
  int h_val ;
  int l_val ;
  unsigned int seed_val ;
  int tmp___0 ;
  int conditions_val ;
  int conditions_were_set ;
  int timeline_flag ;
  int ineq_val ;
  enum stencil shape_val ;
  int multiplayer_flag ;
  int server_flag ;
  char *val_client_port ;
  char *tmp___1 ;
  char *val_server_addr ;
  char *tmp___2 ;
  char *val_server_port ;
  char *tmp___3 ;
  int val_clients_num ;
  int c ;
  char *endptr ;
  long tmp___5 ;
  long tmp___6 ;
  char *endptr___0 ;
  long tmp___8 ;
  long tmp___9 ;
  char *endptr___1 ;
  long tmp___10 ;
  char *endptr___2 ;
  long tmp___11 ;
  char *endptr___3 ;
  long tmp___12 ;
  char *endptr___4 ;
  long tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  int tmp___27 ;
  int tmp___28 ;
  int tmp___29 ;
  int tmp___30 ;
  int tmp___31 ;
  int tmp___32 ;
  int tmp___33 ;
  int tmp___34 ;
  int tmp___35 ;
  int tmp___36 ;
  int tmp___37 ;
  int tmp___38 ;
  int tmp___39 ;
  int tmp___40 ;
  char *endptr___5 ;
  long tmp___41 ;
  int avlbl_loc_num ;
  int tmp___42 ;
  struct sigaction newhandler ;
  sigset_t blocked ;
  int tmp___43 ;
  struct state st ;
  struct ui ui ;
  int tmp___44 ;
  int fd_flags ;
  int tmp___45 ;
  struct itimerval it ;

  {
  {
#line 328
  tmp = time((time_t *)((void *)0));
#line 328
  srand((unsigned int )tmp);
#line 331
  r_flag = 0;
#line 332
  dif_val = 2;
#line 333
  sp_val = 4;
#line 334
  w_val = 21;
#line 335
  h_val = 21;
#line 336
  l_val = 0;
#line 337
  tmp___0 = rand();
#line 337
  seed_val = (unsigned int )tmp___0;
#line 338
  conditions_val = 0;
#line 339
  conditions_were_set = 0;
#line 340
  timeline_flag = 0;
#line 342
  ineq_val = -1;
#line 343
  shape_val = (enum stencil )1;
#line 346
  multiplayer_flag = 0;
#line 347
  server_flag = 1;
#line 349
  tmp___1 = strdup("19150");
#line 349
  val_client_port = tmp___1;
#line 350
  tmp___2 = strdup("127.0.0.1");
#line 350
  val_server_addr = tmp___2;
#line 351
  tmp___3 = strdup("19140");
#line 351
  val_server_port = tmp___3;
#line 353
  val_clients_num = 1;
#line 355
  opterr = 0;
  }
  {
#line 357
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 357
    c = getopt(argc, (char * const  *)argv, "hrTW:H:i:l:q:d:s:R:S:E:e:C:c:");
    }
#line 357
    if (! (c != -1)) {
#line 357
      goto while_break;
    }
    {
#line 359
    if (c == 114) {
#line 359
      goto case_114;
    }
#line 360
    if (c == 84) {
#line 360
      goto case_84;
    }
#line 362
    if (c == 87) {
#line 362
      goto case_87;
    }
#line 370
    if (c == 72) {
#line 370
      goto case_72;
    }
#line 378
    if (c == 105) {
#line 378
      goto case_105;
    }
#line 386
    if (c == 108) {
#line 386
      goto case_108;
    }
#line 394
    if (c == 113) {
#line 394
      goto case_113;
    }
#line 403
    if (c == 82) {
#line 403
      goto case_82;
    }
#line 411
    if (c == 100) {
#line 411
      goto case_100;
    }
#line 425
    if (c == 115) {
#line 425
      goto case_115;
    }
#line 438
    if (c == 83) {
#line 438
      goto case_83;
    }
#line 448
    if (c == 69) {
#line 448
      goto case_69;
    }
#line 458
    if (c == 101) {
#line 458
      goto case_101;
    }
#line 462
    if (c == 67) {
#line 462
      goto case_67;
    }
#line 468
    if (c == 99) {
#line 468
      goto case_99;
    }
#line 472
    if (c == 104) {
#line 472
      goto case_104;
    }
#line 472
    if (c == 63) {
#line 472
      goto case_104;
    }
#line 475
    goto switch_default;
    case_114: /* CIL Label */ 
#line 359
    r_flag = 1;
#line 359
    goto switch_break;
    case_84: /* CIL Label */ 
#line 360
    timeline_flag = 1;
#line 360
    goto switch_break;
    case_87: /* CIL Label */ 
    {
#line 362
    endptr = (char *)((void *)0);
#line 363
    tmp___6 = strtol((char const   */* __restrict  */)optarg, (char **/* __restrict  */)(& endptr),
                     10);
    }
#line 363
    if (14L < tmp___6) {
      {
#line 363
      tmp___5 = strtol((char const   */* __restrict  */)optarg, (char **/* __restrict  */)(& endptr),
                       10);
#line 363
      w_val = (int )tmp___5;
      }
    } else {
#line 363
      w_val = 14;
    }
#line 364
    if ((int )*endptr != 0) {
      {
#line 365
      print_help();
      }
#line 366
      return (1);
    }
#line 369
    goto switch_break;
    case_72: /* CIL Label */ 
    {
#line 370
    endptr___0 = (char *)((void *)0);
#line 371
    tmp___9 = strtol((char const   */* __restrict  */)optarg, (char **/* __restrict  */)(& endptr___0),
                     10);
    }
#line 371
    if (14L < tmp___9) {
      {
#line 371
      tmp___8 = strtol((char const   */* __restrict  */)optarg, (char **/* __restrict  */)(& endptr___0),
                       10);
#line 371
      h_val = (int )tmp___8;
      }
    } else {
#line 371
      h_val = 14;
    }
#line 372
    if ((int )*endptr___0 != 0) {
      {
#line 373
      print_help();
      }
#line 374
      return (1);
    }
#line 377
    goto switch_break;
    case_105: /* CIL Label */ 
    {
#line 378
    endptr___1 = (char *)((void *)0);
#line 379
    tmp___10 = strtol((char const   */* __restrict  */)optarg, (char **/* __restrict  */)(& endptr___1),
                      10);
#line 379
    ineq_val = (int )tmp___10;
    }
#line 380
    if ((int )*endptr___1 != 0) {
      {
#line 381
      print_help();
      }
#line 382
      return (1);
    } else
#line 380
    if (ineq_val < 0) {
      {
#line 381
      print_help();
      }
#line 382
      return (1);
    } else
#line 380
    if (ineq_val > 4) {
      {
#line 381
      print_help();
      }
#line 382
      return (1);
    }
#line 385
    goto switch_break;
    case_108: /* CIL Label */ 
    {
#line 386
    endptr___2 = (char *)((void *)0);
#line 387
    tmp___11 = strtol((char const   */* __restrict  */)optarg, (char **/* __restrict  */)(& endptr___2),
                      10);
#line 387
    l_val = (int )tmp___11;
    }
#line 388
    if ((int )*endptr___2 != 0) {
      {
#line 389
      print_help();
      }
#line 390
      return (1);
    }
#line 393
    goto switch_break;
    case_113: /* CIL Label */ 
    {
#line 394
    endptr___3 = (char *)((void *)0);
#line 395
    tmp___12 = strtol((char const   */* __restrict  */)optarg, (char **/* __restrict  */)(& endptr___3),
                      10);
#line 395
    conditions_val = (int )tmp___12;
#line 396
    conditions_were_set = 1;
    }
#line 397
    if ((int )*endptr___3 != 0) {
      {
#line 398
      print_help();
      }
#line 399
      return (1);
    }
#line 402
    goto switch_break;
    case_82: /* CIL Label */ 
    {
#line 403
    endptr___4 = (char *)((void *)0);
#line 404
    tmp___13 = strtol((char const   */* __restrict  */)optarg, (char **/* __restrict  */)(& endptr___4),
                      10);
#line 404
    tmp___14 = abs((int )tmp___13);
#line 404
    seed_val = (unsigned int )tmp___14;
    }
#line 405
    if ((int )*endptr___4 != 0) {
      {
#line 406
      print_help();
      }
#line 407
      return (1);
    } else
#line 405
    if ((int )*optarg == 0) {
      {
#line 406
      print_help();
      }
#line 407
      return (1);
    }
#line 410
    goto switch_break;
    case_100: /* CIL Label */ 
    {
#line 411
    tmp___23 = strcmp((char const   *)optarg, "n");
    }
#line 411
    if (tmp___23 == 0) {
#line 411
      dif_val = 2;
    } else {
      {
#line 412
      tmp___22 = strcmp((char const   *)optarg, "e");
      }
#line 412
      if (tmp___22 == 0) {
#line 412
        dif_val = 1;
      } else {
        {
#line 413
        tmp___21 = strcmp((char const   *)optarg, "e1");
        }
#line 413
        if (tmp___21 == 0) {
#line 413
          dif_val = 1;
        } else {
          {
#line 414
          tmp___20 = strcmp((char const   *)optarg, "ee");
          }
#line 414
          if (tmp___20 == 0) {
#line 414
            dif_val = 0;
          } else {
            {
#line 415
            tmp___19 = strcmp((char const   *)optarg, "e2");
            }
#line 415
            if (tmp___19 == 0) {
#line 415
              dif_val = 0;
            } else {
              {
#line 416
              tmp___18 = strcmp((char const   *)optarg, "h");
              }
#line 416
              if (tmp___18 == 0) {
#line 416
                dif_val = 3;
              } else {
                {
#line 417
                tmp___17 = strcmp((char const   *)optarg, "h1");
                }
#line 417
                if (tmp___17 == 0) {
#line 417
                  dif_val = 3;
                } else {
                  {
#line 418
                  tmp___16 = strcmp((char const   *)optarg, "hh");
                  }
#line 418
                  if (tmp___16 == 0) {
#line 418
                    dif_val = 4;
                  } else {
                    {
#line 419
                    tmp___15 = strcmp((char const   *)optarg, "h2");
                    }
#line 419
                    if (tmp___15 == 0) {
#line 419
                      dif_val = 4;
                    } else {
                      {
#line 421
                      print_help();
                      }
#line 422
                      return (1);
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
#line 424
    goto switch_break;
    case_115: /* CIL Label */ 
    {
#line 425
    tmp___37 = strcmp((char const   *)optarg, "n");
    }
#line 425
    if (tmp___37 == 0) {
#line 425
      sp_val = 4;
    } else {
      {
#line 426
      tmp___35 = strcmp((char const   *)optarg, "s");
      }
#line 426
      if (tmp___35 == 0) {
#line 426
        sp_val = 3;
      } else {
        {
#line 426
        tmp___36 = strcmp((char const   *)optarg, "s1");
        }
#line 426
        if (tmp___36 == 0) {
#line 426
          sp_val = 3;
        } else {
          {
#line 427
          tmp___33 = strcmp((char const   *)optarg, "ss");
          }
#line 427
          if (tmp___33 == 0) {
#line 427
            sp_val = 2;
          } else {
            {
#line 427
            tmp___34 = strcmp((char const   *)optarg, "s2");
            }
#line 427
            if (tmp___34 == 0) {
#line 427
              sp_val = 2;
            } else {
              {
#line 428
              tmp___31 = strcmp((char const   *)optarg, "sss");
              }
#line 428
              if (tmp___31 == 0) {
#line 428
                sp_val = 1;
              } else {
                {
#line 428
                tmp___32 = strcmp((char const   *)optarg, "s3");
                }
#line 428
                if (tmp___32 == 0) {
#line 428
                  sp_val = 1;
                } else {
                  {
#line 429
                  tmp___29 = strcmp((char const   *)optarg, "f");
                  }
#line 429
                  if (tmp___29 == 0) {
#line 429
                    sp_val = 5;
                  } else {
                    {
#line 429
                    tmp___30 = strcmp((char const   *)optarg, "f1");
                    }
#line 429
                    if (tmp___30 == 0) {
#line 429
                      sp_val = 5;
                    } else {
                      {
#line 430
                      tmp___27 = strcmp((char const   *)optarg, "ff");
                      }
#line 430
                      if (tmp___27 == 0) {
#line 430
                        sp_val = 6;
                      } else {
                        {
#line 430
                        tmp___28 = strcmp((char const   *)optarg, "f2");
                        }
#line 430
                        if (tmp___28 == 0) {
#line 430
                          sp_val = 6;
                        } else {
                          {
#line 431
                          tmp___25 = strcmp((char const   *)optarg, "fff");
                          }
#line 431
                          if (tmp___25 == 0) {
#line 431
                            sp_val = 7;
                          } else {
                            {
#line 431
                            tmp___26 = strcmp((char const   *)optarg, "f3");
                            }
#line 431
                            if (tmp___26 == 0) {
#line 431
                              sp_val = 7;
                            } else {
                              {
#line 432
                              tmp___24 = strcmp((char const   *)optarg, "p");
                              }
#line 432
                              if (tmp___24 == 0) {
#line 432
                                sp_val = 0;
                              } else {
                                {
#line 434
                                print_help();
                                }
#line 435
                                return (1);
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
#line 437
    goto switch_break;
    case_83: /* CIL Label */ 
    {
#line 438
    tmp___40 = strcmp((char const   *)optarg, "rhombus");
    }
#line 438
    if (tmp___40 == 0) {
#line 438
      shape_val = (enum stencil )0;
    } else {
      {
#line 439
      tmp___39 = strcmp((char const   *)optarg, "rect");
      }
#line 439
      if (tmp___39 == 0) {
#line 439
        shape_val = (enum stencil )1;
      } else {
        {
#line 440
        tmp___38 = strcmp((char const   *)optarg, "hex");
        }
#line 440
        if (tmp___38 == 0) {
#line 440
          shape_val = (enum stencil )2;
        } else {
          {
#line 442
          print_help();
          }
#line 443
          return (1);
        }
      }
    }
#line 445
    goto switch_break;
    case_69: /* CIL Label */ 
    {
#line 448
    endptr___5 = (char *)((void *)0);
#line 449
    tmp___41 = strtol((char const   */* __restrict  */)optarg, (char **/* __restrict  */)(& endptr___5),
                      10);
#line 449
    val_clients_num = (int )tmp___41;
    }
#line 450
    if ((int )*endptr___5 != 0) {
      {
#line 451
      print_help();
      }
#line 452
      return (1);
    }
#line 454
    multiplayer_flag = 1;
#line 455
    server_flag = 1;
#line 457
    goto switch_break;
    case_101: /* CIL Label */ 
    {
#line 459
    free((void *)val_server_port);
#line 460
    val_server_port = strdup((char const   *)optarg);
    }
#line 461
    goto switch_break;
    case_67: /* CIL Label */ 
    {
#line 463
    multiplayer_flag = 1;
#line 464
    server_flag = 0;
#line 465
    free((void *)val_server_addr);
#line 466
    val_server_addr = strdup((char const   *)optarg);
    }
#line 467
    goto switch_break;
    case_99: /* CIL Label */ 
    {
#line 469
    free((void *)val_client_port);
#line 470
    val_client_port = strdup((char const   *)optarg);
    }
#line 471
    goto switch_break;
    case_104: /* CIL Label */ 
    case_63: /* CIL Label */ 
    {
#line 473
    print_help();
    }
#line 474
    return (1);
    switch_default: /* CIL Label */ 
    {
#line 475
    abort();
    }
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 480
  tmp___42 = stencil_avlbl_loc_num(shape_val);
#line 480
  avlbl_loc_num = tmp___42;
  }
#line 481
  if (l_val == 0) {
#line 481
    l_val = avlbl_loc_num;
  }
#line 483
  if (l_val < 2) {
    {
#line 484
    print_help();
    }
#line 485
    return (1);
  } else
#line 483
  if (l_val > avlbl_loc_num) {
    {
#line 484
    print_help();
    }
#line 485
    return (1);
  }
#line 487
  if (conditions_were_set) {
#line 487
    if (conditions_val < 1) {
      {
#line 488
      print_help();
      }
#line 489
      return (1);
    } else
#line 487
    if (conditions_val > l_val) {
      {
#line 488
      print_help();
      }
#line 489
      return (1);
    }
  }
#line 492
  if (val_clients_num < 1) {
    {
#line 493
    print_help();
    }
#line 494
    return (1);
  } else
#line 492
  if (val_clients_num > l_val) {
    {
#line 493
    print_help();
    }
#line 494
    return (1);
  }
#line 497
  if ((unsigned int )shape_val == 1U) {
#line 498
    if (39 < w_val + (h_val + 1) / 2) {
#line 498
      w_val = 39;
    } else {
#line 498
      w_val += (h_val + 1) / 2;
    }
  }
  {
#line 505
  newhandler.sa_flags = 268435456;
#line 506
  sigemptyset(& blocked);
#line 507
  newhandler.sa_mask = blocked;
#line 508
  newhandler.__sigaction_handler.sa_handler = & on_timer;
#line 509
  tmp___43 = sigaction(14, (struct sigaction  const  */* __restrict  */)(& newhandler),
                       (struct sigaction */* __restrict  */)((void *)0));
  }
#line 509
  if (tmp___43 == -1) {
    {
#line 510
    perror("sigaction");
    }
  }
  {
#line 514
  setlocale(6, "");
#line 515
  initscr();
#line 516
  cbreak();
#line 517
  noecho();
#line 518
  start_color();
#line 519
  wclear(stdscr);
#line 520
  curs_set(0);
#line 522
  use_default_colors();
#line 523
  init_pair((short)0, (short)7, (short)0);
#line 524
  init_pair((short)1, (short)7, (short)0);
#line 525
  init_pair((short)2, (short)0, (short)0);
#line 526
  init_pair((short)3, (short)1, (short)0);
#line 527
  init_pair((short)4, (short)2, (short)0);
#line 528
  init_pair((short)5, (short)4, (short)0);
#line 529
  init_pair((short)6, (short)3, (short)0);
#line 530
  init_pair((short)7, (short)5, (short)0);
#line 531
  init_pair((short)8, (short)6, (short)0);
#line 533
  wcolor_set(stdscr, (short)0, (void *)0);
#line 534
  assume_default_colors(7, 0);
#line 535
  wclear(stdscr);
  }
#line 541
  if (stdscr) {
#line 541
    stdscr->_attrs = (1UL << 21) | (2UL << 8);
  }
  {
#line 542
  tmp___44 = wmove(stdscr, 0, 0);
  }
#line 542
  if (! (tmp___44 == -1)) {
    {
#line 542
    waddnstr(stdscr, "Map is generated. Please wait.", -1);
    }
  }
  {
#line 543
  wrefresh(stdscr);
#line 545
  state_init(& st, w_val, h_val, shape_val, seed_val, r_flag, l_val, val_clients_num,
             conditions_val, ineq_val, (enum config_speed )sp_val, (enum config_dif )dif_val,
             timeline_flag);
#line 547
  ui_init(& st, & ui);
#line 549
  wclear(stdscr);
#line 552
  tmp___45 = fcntl(0, 3);
#line 552
  fd_flags = tmp___45;
#line 553
  fcntl(0, 4, fd_flags | 2048);
#line 557
  it.it_value.tv_sec = (__time_t )0;
#line 558
  it.it_value.tv_usec = (__suseconds_t )10000;
#line 559
  it.it_interval.tv_sec = (__time_t )0;
#line 560
  it.it_interval.tv_usec = (__suseconds_t )10000;
#line 561
  setitimer(0, (struct itimerval  const  */* __restrict  */)(& it), (struct itimerval */* __restrict  */)((void *)0));
#line 563
  wrefresh(stdscr);
#line 564
  input_ready = (sig_atomic_t volatile   )0;
#line 565
  time_to_redraw = (sig_atomic_t volatile   )1;
  }
#line 567
  if (! multiplayer_flag) {
    {
#line 569
    run(& st, & ui);
    }
  } else
#line 572
  if (server_flag) {
    {
#line 572
    run_server(& st, val_clients_num, val_server_port);
    }
  } else {
    {
#line 573
    run_client(& st, & ui, val_server_addr, val_server_port, val_client_port);
    }
  }
  {
#line 577
  echo();
#line 578
  curs_set(1);
#line 579
  wclear(stdscr);
#line 580
  endwin();
  }
#line 582
  if (! multiplayer_flag) {
    {
#line 583
    printf((char const   */* __restrict  */)"Random seed was %i\n", st.map_seed);
    }
  } else
#line 582
  if (server_flag) {
    {
#line 583
    printf((char const   */* __restrict  */)"Random seed was %i\n", st.map_seed);
    }
  }
  {
#line 585
  free((void *)val_server_addr);
#line 586
  free((void *)val_server_port);
#line 587
  free((void *)val_client_port);
  }
#line 588
  return (0);
}
}
#line 596 "/home/june/repo/benchmarks/collector/temp/curseofwar-1.1.8/main.c"
int dialog_quit_confirm(struct state *st , struct ui *ui ) 
{ 
  int done ;
  int finished ;
  char buf___2[1] ;
  char c ;
  size_t tmp ;

  {
  {
#line 597
  output_dialog_quit_on(st, ui);
#line 598
  done = 0;
#line 599
  finished = 0;
  }
  {
#line 601
  while (1) {
    while_continue: /* CIL Label */ ;
#line 601
    if (! (! done)) {
#line 601
      goto while_break;
    }
    {
#line 602
    tmp = fread((void */* __restrict  */)(buf___2), (size_t )1, (size_t )1, (FILE */* __restrict  */)stdin);
    }
#line 602
    if (tmp == 1UL) {
#line 603
      c = buf___2[0];
      {
#line 605
      if ((int )c == 81) {
#line 605
        goto case_81;
      }
#line 605
      if ((int )c == 113) {
#line 605
        goto case_81;
      }
#line 605
      if ((int )c == 89) {
#line 605
        goto case_81;
      }
#line 605
      if ((int )c == 121) {
#line 605
        goto case_81;
      }
#line 609
      if ((int )c == 27) {
#line 609
        goto case_27;
      }
#line 609
      if ((int )c == 78) {
#line 609
        goto case_27;
      }
#line 609
      if ((int )c == 110) {
#line 609
        goto case_27;
      }
#line 613
      goto switch_default;
      case_81: /* CIL Label */ 
      case_113: /* CIL Label */ 
      case_89: /* CIL Label */ 
      case_121: /* CIL Label */ 
#line 606
      finished = 1;
#line 607
      done = 1;
#line 608
      goto switch_break;
      case_27: /* CIL Label */ 
      case_78: /* CIL Label */ 
      case_110: /* CIL Label */ 
#line 610
      finished = 0;
#line 611
      done = 1;
#line 612
      goto switch_break;
      switch_default: /* CIL Label */ 
#line 614
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    } else {
      {
#line 618
      pause();
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 620
  output_dialog_quit_off(st, ui);
  }
#line 621
  return (finished);
}
}
#line 624 "/home/june/repo/benchmarks/collector/temp/curseofwar-1.1.8/main.c"
int update_from_input(struct state *st , struct ui *ui ) 
{ 
  int c ;
  char buf___2[1] ;
  int finished ;
  int cursi ;
  int cursj ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  size_t tmp___2 ;

  {
#line 628
  finished = 0;
  {
#line 630
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 630
    tmp___2 = fread((void */* __restrict  */)(buf___2), (size_t )1, (size_t )1, (FILE */* __restrict  */)stdin);
    }
#line 630
    if (! (tmp___2 == 1UL)) {
#line 630
      goto while_break;
    }
#line 631
    c = (int )buf___2[0];
#line 632
    cursi = ui->cursor.i;
#line 633
    cursj = ui->cursor.j;
    {
#line 637
    if (c == 113) {
#line 637
      goto case_113;
    }
#line 637
    if (c == 81) {
#line 637
      goto case_113;
    }
#line 640
    if (c == 102) {
#line 640
      goto case_102;
    }
#line 644
    if (c == 115) {
#line 644
      goto case_115;
    }
#line 648
    if (c == 112) {
#line 648
      goto case_112;
    }
#line 656
    if (c == 68) {
#line 656
      goto case_68;
    }
#line 656
    if (c == 104) {
#line 656
      goto case_68;
    }
#line 659
    if (c == 67) {
#line 659
      goto case_67;
    }
#line 659
    if (c == 108) {
#line 659
      goto case_67;
    }
#line 662
    if (c == 65) {
#line 662
      goto case_65;
    }
#line 662
    if (c == 107) {
#line 662
      goto case_65;
    }
#line 667
    if (c == 66) {
#line 667
      goto case_66;
    }
#line 667
    if (c == 106) {
#line 667
      goto case_66;
    }
#line 672
    if (c == 32) {
#line 672
      goto case_32;
    }
#line 678
    if (c == 120) {
#line 678
      goto case_120;
    }
#line 681
    if (c == 99) {
#line 681
      goto case_99;
    }
#line 685
    if (c == 118) {
#line 685
      goto case_118;
    }
#line 685
    if (c == 114) {
#line 685
      goto case_118;
    }
#line 690
    if (c == 91) {
#line 690
      goto case_91;
    }
#line 690
    if (c == 27) {
#line 690
      goto case_91;
    }
#line 635
    goto switch_break;
    case_113: /* CIL Label */ 
    case_81: /* CIL Label */ 
    {
#line 638
    finished = dialog_quit_confirm(st, ui);
    }
#line 639
    goto switch_break;
    case_102: /* CIL Label */ 
    {
#line 641
    st->prev_speed = st->speed;
#line 642
    st->speed = faster(st->speed);
    }
#line 643
    goto switch_break;
    case_115: /* CIL Label */ 
    {
#line 645
    st->prev_speed = st->speed;
#line 646
    st->speed = slower(st->speed);
    }
#line 647
    goto switch_break;
    case_112: /* CIL Label */ 
#line 649
    if ((unsigned int )st->speed == 0U) {
#line 650
      st->speed = st->prev_speed;
    } else {
#line 652
      st->prev_speed = st->speed;
#line 653
      st->speed = (enum config_speed )0;
    }
#line 655
    goto switch_break;
    case_68: /* CIL Label */ 
    case_104: /* CIL Label */ 
#line 657
    cursi --;
#line 658
    goto switch_break;
    case_67: /* CIL Label */ 
    case_108: /* CIL Label */ 
#line 660
    cursi ++;
#line 661
    goto switch_break;
    case_65: /* CIL Label */ 
    case_107: /* CIL Label */ 
#line 663
    cursj --;
#line 664
    if (cursj % 2 == 1) {
#line 665
      cursi ++;
    }
#line 666
    goto switch_break;
    case_66: /* CIL Label */ 
    case_106: /* CIL Label */ 
#line 668
    cursj ++;
#line 669
    if (cursj % 2 == 0) {
#line 670
      cursi --;
    }
#line 671
    goto switch_break;
    case_32: /* CIL Label */ 
#line 673
    if (st->fg[st->controlled].flag[ui->cursor.i][ui->cursor.j] == 0) {
      {
#line 674
      add_flag(& st->grid, & st->fg[st->controlled], ui->cursor.i, ui->cursor.j, 8);
      }
    } else {
      {
#line 676
      remove_flag(& st->grid, & st->fg[st->controlled], ui->cursor.i, ui->cursor.j,
                  8);
      }
    }
#line 677
    goto switch_break;
    case_120: /* CIL Label */ 
    {
#line 679
    remove_flags_with_prob(& st->grid, & st->fg[st->controlled], (float )1.0);
    }
#line 680
    goto switch_break;
    case_99: /* CIL Label */ 
    {
#line 682
    remove_flags_with_prob(& st->grid, & st->fg[st->controlled], (float )0.5);
    }
#line 683
    goto switch_break;
    case_118: /* CIL Label */ 
    case_114: /* CIL Label */ 
    {
#line 686
    build(& st->grid, & st->country[st->controlled], st->controlled, ui->cursor.i,
          ui->cursor.j);
    }
#line 687
    goto switch_break;
    case_91: /* CIL Label */ 
    case_27: /* CIL Label */ 
#line 691
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 694
    if (cursi < 0) {
#line 694
      cursi = 0;
    } else {
#line 694
      if (cursi > st->grid.width - 1) {
#line 694
        tmp = st->grid.width - 1;
      } else {
#line 694
        tmp = cursi;
      }
#line 694
      cursi = tmp;
    }
#line 695
    if (cursj < 0) {
#line 695
      cursj = 0;
    } else {
#line 695
      if (cursj > st->grid.height - 1) {
#line 695
        tmp___0 = st->grid.height - 1;
      } else {
#line 695
        tmp___0 = cursj;
      }
#line 695
      cursj = tmp___0;
    }
    {
#line 696
    tmp___1 = is_visible(st->grid.tiles[cursi][cursj].cl);
    }
#line 696
    if (tmp___1) {
#line 697
      ui->cursor.i = cursi;
#line 698
      ui->cursor.j = cursj;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 702
  return (finished);
}
}
#line 706 "/home/june/repo/benchmarks/collector/temp/curseofwar-1.1.8/main.c"
int update_from_input_client(struct state *st , struct ui *ui , int sfd , struct addrinfo *srv_addr ) 
{ 
  int c ;
  char buf___2[1] ;
  int finished ;
  size_t tmp ;

  {
#line 710
  finished = 0;
  {
#line 712
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 712
    tmp = fread((void */* __restrict  */)(buf___2), (size_t )1, (size_t )1, (FILE */* __restrict  */)stdin);
    }
#line 712
    if (! (tmp == 1UL)) {
#line 712
      goto while_break;
    }
#line 713
    c = (int )buf___2[0];
    {
#line 715
    if (c == 81) {
#line 715
      goto case_81;
    }
#line 715
    if (c == 113) {
#line 715
      goto case_81;
    }
#line 718
    goto switch_default;
    case_81: /* CIL Label */ 
    case_113: /* CIL Label */ 
    {
#line 716
    finished = dialog_quit_confirm(st, ui);
    }
#line 717
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 719
    finished = client_process_input(st, ui, (char )c, sfd, srv_addr);
    }
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 722
  return (finished);
}
}
#line 726 "/home/june/repo/benchmarks/collector/temp/curseofwar-1.1.8/main.c"
int update_from_input_server(struct state *st ) 
{ 
  int c ;
  char buf___2[1] ;
  int finished ;
  size_t tmp ;

  {
#line 730
  finished = 0;
  {
#line 732
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 732
    tmp = fread((void */* __restrict  */)(buf___2), (size_t )1, (size_t )1, (FILE */* __restrict  */)stdin);
    }
#line 732
    if (! (tmp == 1UL)) {
#line 732
      goto while_break;
    }
#line 733
    c = (int )buf___2[0];
    {
#line 735
    if (c == 81) {
#line 735
      goto case_81;
    }
#line 735
    if (c == 113) {
#line 735
      goto case_81;
    }
#line 734
    goto switch_break;
    case_81: /* CIL Label */ 
    case_113: /* CIL Label */ 
#line 735
    finished = 1;
#line 735
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 738
  return (finished);
}
}
#line 745 "/home/june/repo/benchmarks/collector/temp/curseofwar-1.1.8/main.c"
void on_timer(int signum ) 
{ 


  {
#line 747
  time_to_redraw = (sig_atomic_t volatile   )1;
#line 749
  return;
}
}
#line 377 "/usr/include/netinet/in.h"
extern  __attribute__((__nothrow__)) uint32_t ( __attribute__((__leaf__)) htonl)(uint32_t __hostlong )  __attribute__((__const__)) ;
#line 379
extern  __attribute__((__nothrow__)) uint16_t ( __attribute__((__leaf__)) htons)(uint16_t __hostshort )  __attribute__((__const__)) ;
#line 24 "/home/june/repo/benchmarks/collector/temp/curseofwar-1.1.8/server.c"
static uint8_t buf___1[50000]  ;
#line 25 "/home/june/repo/benchmarks/collector/temp/curseofwar-1.1.8/server.c"
static struct msg_s_data msg_data___0  ;
#line 23 "/home/june/repo/benchmarks/collector/temp/curseofwar-1.1.8/server.c"
void server_send_msg_s_state(int sfd , struct client_record *cl , int cl_num , struct state *st ) 
{ 
  int p ;
  int i ;
  int j ;
  int owner ;
  int size ;
  int n_to_send ;
  socklen_t peer_addr_len ;

  {
#line 29
  p = 0;
  {
#line 29
  while (1) {
    while_continue: /* CIL Label */ ;
#line 29
    if (! (p < 8)) {
#line 29
      goto while_break;
    }
    {
#line 30
    msg_data___0.gold[p] = htonl((uint32_t )st->country[p].gold);
#line 32
    msg_data___0.width = (uint8_t )st->fg[p].width;
#line 33
    msg_data___0.height = (uint8_t )st->fg[p].height;
#line 29
    p ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 36
  msg_data___0.time = htonl((uint32_t )st->time);
#line 38
  msg_data___0.control = (uint8_t )0;
#line 39
  msg_data___0.width = (uint8_t )st->grid.width;
#line 40
  msg_data___0.height = (uint8_t )st->grid.height;
#line 41
  i = 0;
  }
  {
#line 41
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 41
    if (! (i < 40)) {
#line 41
      goto while_break___0;
    }
#line 42
    j = 0;
    {
#line 42
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 42
      if (! (j < 29)) {
#line 42
        goto while_break___1;
      }
      {
#line 43
      msg_data___0.tile[i][j] = (uint8_t )st->grid.tiles[i][j].cl;
#line 45
      owner = st->grid.tiles[i][j].pl;
#line 46
      msg_data___0.owner[i][j] = (uint8_t )owner;
#line 47
      msg_data___0.pop[i][j] = htons((uint16_t )st->grid.tiles[i][j].units[owner][0]);
#line 49
      msg_data___0.flag[i][j] = (uint8_t )0;
#line 50
      p = 0;
      }
      {
#line 50
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 50
        if (! (p < 8)) {
#line 50
          goto while_break___2;
        }
#line 51
        if (st->fg[p].flag[i][j]) {
#line 52
          msg_data___0.flag[i][j] = (uint8_t )((int )msg_data___0.flag[i][j] | (1 << p));
        }
#line 50
        p ++;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 42
      j ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 41
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 58
  buf___1[0] = (uint8_t )10;
#line 59
  size = (int )sizeof(msg_data___0);
#line 60
  memcpy((void */* __restrict  */)(buf___1 + 1), (void const   */* __restrict  */)(& msg_data___0),
         (size_t )size);
#line 61
  n_to_send = size + 1;
#line 65
  i = 0;
  }
  {
#line 65
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 65
    if (! (i < cl_num)) {
#line 65
      goto while_break___3;
    }
    {
#line 66
    peer_addr_len = (socklen_t )sizeof((cl + i)->sa);
#line 67
    buf___1[1] = (uint8_t )(cl + i)->pl;
#line 68
    sendto(sfd, (void const   *)(buf___1), (size_t )n_to_send, 0, (struct sockaddr  const  *)((struct sockaddr *)(& (cl + i)->sa)),
           peer_addr_len);
#line 65
    i ++;
    }
  }
  while_break___3: /* CIL Label */ ;
  }
#line 70
  return;
}
}
#line 72 "/home/june/repo/benchmarks/collector/temp/curseofwar-1.1.8/server.c"
void process_msg_c(struct state *st , int pl , uint8_t msg , struct msg_c_data *cm ) 
{ 


  {
  {
#line 74
  if ((int )msg == 20) {
#line 74
    goto case_20;
  }
#line 77
  if ((int )msg == 21) {
#line 77
    goto case_21;
  }
#line 80
  if ((int )msg == 22) {
#line 80
    goto case_22;
  }
#line 83
  if ((int )msg == 23) {
#line 83
    goto case_23;
  }
#line 86
  if ((int )msg == 24) {
#line 86
    goto case_24;
  }
#line 89
  if ((int )msg == 30) {
#line 89
    goto case_30;
  }
#line 93
  goto switch_default;
  case_20: /* CIL Label */ 
  {
#line 75
  build(& st->grid, & st->country[pl], pl, (int )cm->i, (int )cm->j);
  }
#line 76
  goto switch_break;
  case_21: /* CIL Label */ 
  {
#line 78
  add_flag(& st->grid, & st->fg[pl], (int )cm->i, (int )cm->j, 8);
  }
#line 79
  goto switch_break;
  case_22: /* CIL Label */ 
  {
#line 81
  remove_flag(& st->grid, & st->fg[pl], (int )cm->i, (int )cm->j, 8);
  }
#line 82
  goto switch_break;
  case_23: /* CIL Label */ 
  {
#line 84
  remove_flags_with_prob(& st->grid, & st->fg[pl], (float )1.0);
  }
#line 85
  goto switch_break;
  case_24: /* CIL Label */ 
  {
#line 87
  remove_flags_with_prob(& st->grid, & st->fg[pl], (float )0.5);
  }
#line 88
  goto switch_break;
  case_30: /* CIL Label */ 
#line 90
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 94
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 96
  return;
}
}
#line 100 "/home/june/repo/benchmarks/collector/temp/curseofwar-1.1.8/server.c"
static struct msg_c_data msg_data___1  ;
#line 98 "/home/june/repo/benchmarks/collector/temp/curseofwar-1.1.8/server.c"
int server_process_msg_c(uint8_t *buf___2 , int nread , struct state *st , int pl ) 
{ 
  uint8_t msg ;

  {
#line 101
  if ((unsigned long )nread >= 1UL + sizeof(struct msg_c_data )) {
    {
#line 102
    msg = *(buf___2 + 0);
#line 103
    memcpy((void */* __restrict  */)(& msg_data___1), (void const   */* __restrict  */)(buf___2 + 1),
           sizeof(struct msg_c_data ));
#line 104
    process_msg_c(st, pl, msg, & msg_data___1);
    }
  } else {
#line 106
    return (-1);
  }
#line 108
  return ((int )msg);
}
}
#line 111 "/home/june/repo/benchmarks/collector/temp/curseofwar-1.1.8/server.c"
int server_get_msg(uint8_t *buf___2 , int nread ) 
{ 


  {
#line 112
  if (nread >= 1) {
#line 112
    return ((int )*(buf___2 + 0));
  } else {
#line 112
    return (0);
  }
}
}
#line 23 "/home/june/repo/benchmarks/collector/temp/curseofwar-1.1.8/king.c"
int build(struct grid *g , struct country *c , int pl , int i , int j ) 
{ 
  int price ;
  enum tile_class cl ;

  {
#line 24
  if (i >= 0) {
#line 24
    if (i < g->width) {
#line 24
      if (j >= 0) {
#line 24
        if (j < g->height) {
#line 24
          if (g->tiles[i][j].pl == pl) {
#line 25
            price = 0;
#line 26
            cl = (enum tile_class )3;
            {
#line 28
            if ((unsigned int )g->tiles[i][j].cl == 3U) {
#line 28
              goto case_3;
            }
#line 29
            if ((unsigned int )g->tiles[i][j].cl == 4U) {
#line 29
              goto case_4;
            }
#line 30
            if ((unsigned int )g->tiles[i][j].cl == 5U) {
#line 30
              goto case_5;
            }
#line 31
            goto switch_default;
            case_3: /* CIL Label */ 
#line 28
            price = 150;
#line 28
            cl = (enum tile_class )4;
#line 28
            goto switch_break;
            case_4: /* CIL Label */ 
#line 29
            price = 300;
#line 29
            cl = (enum tile_class )5;
#line 29
            goto switch_break;
            case_5: /* CIL Label */ 
#line 30
            price = 600;
#line 30
            cl = (enum tile_class )6;
#line 30
            goto switch_break;
            switch_default: /* CIL Label */ 
#line 31
            return (-1);
            switch_break: /* CIL Label */ ;
            }
#line 33
            if (c->gold >= (long )price) {
#line 33
              g->tiles[i][j].cl = cl;
#line 33
              c->gold -= (long )price;
#line 33
              return (0);
            }
          }
        }
      }
    }
  }
#line 35
  return (-1);
}
}
#line 38 "/home/june/repo/benchmarks/collector/temp/curseofwar-1.1.8/king.c"
int degrade(struct grid *g , int i , int j ) 
{ 
  enum tile_class cl ;

  {
#line 39
  if (i >= 0) {
#line 39
    if (i < g->width) {
#line 39
      if (j >= 0) {
#line 39
        if (j < g->height) {
#line 40
          cl = (enum tile_class )3;
          {
#line 42
          if ((unsigned int )g->tiles[i][j].cl == 4U) {
#line 42
            goto case_4;
          }
#line 43
          if ((unsigned int )g->tiles[i][j].cl == 5U) {
#line 43
            goto case_5;
          }
#line 44
          if ((unsigned int )g->tiles[i][j].cl == 6U) {
#line 44
            goto case_6;
          }
#line 45
          goto switch_default;
          case_4: /* CIL Label */ 
#line 42
          cl = (enum tile_class )3;
#line 42
          goto switch_break;
          case_5: /* CIL Label */ 
#line 43
          cl = (enum tile_class )4;
#line 43
          goto switch_break;
          case_6: /* CIL Label */ 
#line 44
          cl = (enum tile_class )5;
#line 44
          goto switch_break;
          switch_default: /* CIL Label */ 
#line 45
          return (-1);
          switch_break: /* CIL Label */ ;
          }
#line 47
          g->tiles[i][j].cl = cl;
#line 48
          return (0);
        }
      }
    }
  }
#line 50
  return (-1);
}
}
#line 53 "/home/june/repo/benchmarks/collector/temp/curseofwar-1.1.8/king.c"
void king_evaluate_map(struct king *k , struct grid *g , enum config_dif dif ) 
{ 
  int i ;
  int j ;
  int u[40][29] ;
  int tmp ;
  int tmp___0 ;
  int d ;
  int ii ;
  int jj ;
  int x ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 56
  i = 0;
  {
#line 56
  while (1) {
    while_continue: /* CIL Label */ ;
#line 56
    if (! (i < g->width)) {
#line 56
      goto while_break;
    }
#line 57
    j = 0;
    {
#line 57
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 57
      if (! (j < g->height)) {
#line 57
        goto while_break___0;
      }
#line 58
      u[i][j] = 0;
#line 59
      k->value[i][j] = 0;
#line 57
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 56
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 62
  i = 0;
  {
#line 62
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 62
    if (! (i < g->width)) {
#line 62
      goto while_break___1;
    }
#line 63
    j = 0;
    {
#line 63
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 63
      if (! (j < g->height)) {
#line 63
        goto while_break___2;
      }
      {
#line 64
      tmp = is_inhabitable(g->tiles[i][j].cl);
      }
#line 64
      if (tmp) {
#line 64
        (k->value[i][j]) ++;
      }
      {
#line 66
      if ((unsigned int )k->strategy == 3U) {
#line 66
        goto case_3;
      }
#line 69
      goto switch_default;
      case_3: /* CIL Label */ 
      {
#line 67
      tmp___0 = is_inhabitable(g->tiles[i][j].cl);
      }
#line 67
      if (tmp___0) {
#line 67
        (k->value[i][j]) ++;
      }
#line 68
      goto switch_break;
      switch_default: /* CIL Label */ ;
      switch_break: /* CIL Label */ ;
      }
      {
#line 73
      if ((unsigned int )g->tiles[i][j].cl == 6U) {
#line 73
        goto case_6;
      }
#line 80
      if ((unsigned int )g->tiles[i][j].cl == 5U) {
#line 80
        goto case_5;
      }
#line 84
      if ((unsigned int )g->tiles[i][j].cl == 4U) {
#line 84
        goto case_4;
      }
#line 91
      if ((unsigned int )g->tiles[i][j].cl == 2U) {
#line 91
        goto case_2;
      }
#line 104
      goto switch_default___0;
      case_6: /* CIL Label */ 
#line 74
      if ((unsigned int )k->strategy == 5U) {
        {
#line 75
        spread(g, (int (*)[29])(u), (int (*)[29])(k->value), i, j, 32, 1);
        }
      } else {
        {
#line 77
        spread(g, (int (*)[29])(u), (int (*)[29])(k->value), i, j, 16, 1);
        }
      }
      {
#line 78
      even(g, (int (*)[29])(u), i, j, 0);
      }
#line 79
      goto switch_break___0;
      case_5: /* CIL Label */ 
      {
#line 81
      spread(g, (int (*)[29])(u), (int (*)[29])(k->value), i, j, 8, 1);
#line 82
      even(g, (int (*)[29])(u), i, j, 0);
      }
#line 83
      goto switch_break___0;
      case_4: /* CIL Label */ 
#line 85
      if ((unsigned int )k->strategy == 5U) {
        {
#line 86
        spread(g, (int (*)[29])(u), (int (*)[29])(k->value), i, j, 2, 1);
        }
      } else {
        {
#line 88
        spread(g, (int (*)[29])(u), (int (*)[29])(k->value), i, j, 4, 1);
        }
      }
      {
#line 89
      even(g, (int (*)[29])(u), i, j, 0);
      }
#line 90
      goto switch_break___0;
      case_2: /* CIL Label */ 
#line 93
      d = 0;
      {
#line 93
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 93
        if (! (d < 6)) {
#line 93
          goto while_break___3;
        }
#line 94
        ii = i + (int )dirs[d].i;
#line 95
        jj = j + (int )dirs[d].j;
#line 96
        if ((unsigned int )k->strategy == 6U) {
          {
#line 97
          spread(g, (int (*)[29])(u), (int (*)[29])(k->value), ii, jj, 8, 1);
          }
        } else {
          {
#line 99
          spread(g, (int (*)[29])(u), (int (*)[29])(k->value), ii, jj, 4, 1);
          }
        }
        {
#line 100
        even(g, (int (*)[29])(u), ii, jj, 0);
#line 93
        d ++;
        }
      }
      while_break___3: /* CIL Label */ ;
      }
#line 103
      goto switch_break___0;
      switch_default___0: /* CIL Label */ ;
      switch_break___0: /* CIL Label */ ;
      }
#line 63
      j ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 62
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 110
  i = 0;
  {
#line 110
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 110
    if (! (i < g->width)) {
#line 110
      goto while_break___4;
    }
#line 111
    j = 0;
    {
#line 111
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 111
      if (! (j < g->height)) {
#line 111
        goto while_break___5;
      }
      {
#line 113
      if ((unsigned int )dif == 0U) {
#line 113
        goto case_0;
      }
#line 118
      if ((unsigned int )dif == 1U) {
#line 118
        goto case_1;
      }
#line 123
      goto switch_default___1;
      case_0: /* CIL Label */ 
      {
#line 114
      x = k->value[i][j] / 4;
#line 115
      tmp___1 = rand();
#line 115
      x = (x + tmp___1 % 7) - 3;
      }
#line 116
      if (0 < x) {
#line 116
        k->value[i][j] = x;
      } else {
#line 116
        k->value[i][j] = 0;
      }
#line 117
      goto switch_break___1;
      case_1: /* CIL Label */ 
      {
#line 119
      x = k->value[i][j] / 2;
#line 120
      tmp___2 = rand();
#line 120
      x = (x + tmp___2 % 3) - 1;
      }
#line 121
      if (0 < x) {
#line 121
        k->value[i][j] = x;
      } else {
#line 121
        k->value[i][j] = 0;
      }
#line 122
      goto switch_break___1;
      switch_default___1: /* CIL Label */ ;
      switch_break___1: /* CIL Label */ ;
      }
#line 111
      j ++;
    }
    while_break___5: /* CIL Label */ ;
    }
#line 110
    i ++;
  }
  while_break___4: /* CIL Label */ ;
  }
#line 127
  return;
}
}
#line 129 "/home/june/repo/benchmarks/collector/temp/curseofwar-1.1.8/king.c"
void king_init(struct king *k , int pl , enum strategy strat , struct grid *g , enum config_dif dif ) 
{ 


  {
#line 130
  k->pl = pl;
#line 131
  k->strategy = strat;
#line 133
  return;
}
}
#line 135 "/home/june/repo/benchmarks/collector/temp/curseofwar-1.1.8/king.c"
int builder_default(struct king *k , struct country *c , struct grid *g , struct flag_grid *fg ) 
{ 
  int i ;
  int j ;
  int i_best ;
  int j_best ;
  float v_best ;
  float v ;
  int n ;
  int ok ;
  int di ;
  int dj ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int army ;
  int enemy ;
  int p ;
  int base ;
  int tmp___2 ;

  {
#line 137
  i_best = 0;
#line 137
  j_best = 0;
#line 138
  v_best = (float )0.0;
#line 142
  i = 0;
  {
#line 142
  while (1) {
    while_continue: /* CIL Label */ ;
#line 142
    if (! (i < g->width)) {
#line 142
      goto while_break;
    }
#line 143
    j = 0;
    {
#line 143
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 143
      if (! (j < g->height)) {
#line 143
        goto while_break___0;
      }
#line 145
      ok = 0;
#line 146
      if (g->tiles[i][j].pl == k->pl) {
        {
#line 146
        tmp___1 = is_inhabitable(g->tiles[i][j].cl);
        }
#line 146
        if (tmp___1) {
#line 147
          ok = 1;
#line 149
          n = 0;
          {
#line 149
          while (1) {
            while_continue___1: /* CIL Label */ ;
#line 149
            if (! (n < 6)) {
#line 149
              goto while_break___1;
            }
#line 150
            di = (int )dirs[n].i;
#line 151
            dj = (int )dirs[n].j;
#line 152
            if (i + di >= 0) {
#line 152
              if (i + di < g->width) {
#line 152
                if (j + dj >= 0) {
#line 152
                  if (j + dj < g->height) {
                    {
#line 152
                    tmp___0 = is_inhabitable(g->tiles[i + di][j + dj].cl);
                    }
#line 152
                    if (tmp___0) {
#line 155
                      if (ok) {
#line 155
                        if (g->tiles[i + di][j + dj].pl == k->pl) {
#line 155
                          tmp = 1;
                        } else {
#line 155
                          tmp = 0;
                        }
                      } else {
#line 155
                        tmp = 0;
                      }
#line 155
                      ok = tmp;
                    }
                  }
                }
              }
            }
#line 149
            n ++;
          }
          while_break___1: /* CIL Label */ ;
          }
        }
      }
#line 160
      army = g->tiles[i][j].units[k->pl][0];
#line 161
      enemy = 0;
#line 163
      p = 0;
      {
#line 163
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 163
        if (! (p < 8)) {
#line 163
          goto while_break___2;
        }
#line 164
        if (p != k->pl) {
#line 165
          enemy += g->tiles[i][j].units[p][0];
        }
#line 163
        p ++;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 168
      base = (int )1.0;
      {
#line 170
      if ((unsigned int )g->tiles[i][j].cl == 3U) {
#line 170
        goto case_3;
      }
#line 171
      if ((unsigned int )g->tiles[i][j].cl == 4U) {
#line 171
        goto case_4;
      }
#line 172
      if ((unsigned int )g->tiles[i][j].cl == 5U) {
#line 172
        goto case_5;
      }
#line 173
      goto switch_default;
      case_3: /* CIL Label */ 
#line 170
      base = (int )1.0;
#line 170
      goto switch_break;
      case_4: /* CIL Label */ 
#line 171
      base = (int )8.0;
#line 171
      goto switch_break;
      case_5: /* CIL Label */ 
#line 172
      base = (int )32.0;
#line 172
      goto switch_break;
      switch_default: /* CIL Label */ 
#line 173
      base = (int )0.0;
      switch_break: /* CIL Label */ ;
      }
#line 175
      if ((unsigned int )k->strategy == 6U) {
#line 176
        base *= k->value[i][j] + 10;
      }
#line 178
      v = (float )((ok * base) * (499 - army));
#line 179
      if (army < 49) {
#line 179
        v = (float )0.0;
      }
#line 181
      if ((double )v > 0.0) {
#line 181
        if (v > v_best) {
#line 182
          i_best = i;
#line 183
          j_best = j;
#line 184
          v_best = v;
        }
      }
#line 143
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 142
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 188
  if ((double )v_best > 0.0) {
    {
#line 189
    tmp___2 = build(g, c, k->pl, i_best, j_best);
    }
#line 189
    return (tmp___2);
  } else {
#line 191
    return (-1);
  }
}
}
#line 197 "/home/june/repo/benchmarks/collector/temp/curseofwar-1.1.8/king.c"
void action_aggr_greedy(struct king *k , struct grid *g , struct flag_grid *fg ) 
{ 
  int i ;
  int j ;
  int army ;
  int enemy ;
  int p ;
  float v ;
  double tmp ;

  {
#line 199
  i = 0;
  {
#line 199
  while (1) {
    while_continue: /* CIL Label */ ;
#line 199
    if (! (i < g->width)) {
#line 199
      goto while_break;
    }
#line 200
    j = 0;
    {
#line 200
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 200
      if (! (j < g->height)) {
#line 200
        goto while_break___0;
      }
#line 201
      if (fg->flag[i][j]) {
        {
#line 202
        remove_flag(g, fg, i, j, 8);
        }
      }
#line 205
      army = g->tiles[i][j].units[k->pl][0];
#line 206
      enemy = 0;
#line 208
      p = 0;
      {
#line 208
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 208
        if (! (p < 8)) {
#line 208
          goto while_break___1;
        }
#line 209
        if (p != k->pl) {
#line 210
          enemy += g->tiles[i][j].units[p][0];
        }
#line 208
        p ++;
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 212
      tmp = pow((double )army, 0.5);
#line 212
      v = (float )(((double )((float )k->value[i][j]) * (2.0 * (double )enemy - (double )army)) * tmp);
      }
#line 214
      if (v > (float )5000) {
        {
#line 215
        add_flag(g, fg, i, j, 8);
        }
      }
#line 200
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 199
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 218
  return;
}
}
#line 220 "/home/june/repo/benchmarks/collector/temp/curseofwar-1.1.8/king.c"
void action_one_greedy(struct king *k , struct grid *g , struct flag_grid *fg ) 
{ 
  int i ;
  int j ;
  int i_best ;
  int j_best ;
  float v_best ;
  int army ;
  int enemy ;
  int p ;
  float v ;
  double tmp ;

  {
#line 222
  i_best = 0;
#line 222
  j_best = 0;
#line 223
  v_best = (float )(- 1.0);
#line 224
  i = 0;
  {
#line 224
  while (1) {
    while_continue: /* CIL Label */ ;
#line 224
    if (! (i < g->width)) {
#line 224
      goto while_break;
    }
#line 225
    j = 0;
    {
#line 225
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 225
      if (! (j < g->height)) {
#line 225
        goto while_break___0;
      }
#line 226
      if (fg->flag[i][j]) {
        {
#line 227
        remove_flag(g, fg, i, j, 8);
        }
      }
#line 230
      army = g->tiles[i][j].units[k->pl][0];
#line 231
      enemy = 0;
#line 233
      p = 0;
      {
#line 233
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 233
        if (! (p < 8)) {
#line 233
          goto while_break___1;
        }
#line 234
        if (p != k->pl) {
#line 235
          enemy += g->tiles[i][j].units[p][0];
        }
#line 233
        p ++;
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 237
      tmp = pow((double )army, 0.5);
#line 237
      v = (float )(((double )((float )k->value[i][j]) * (5.0 * (double )enemy - (double )army)) * tmp);
      }
#line 239
      if (v > v_best) {
#line 239
        if (v > (float )5000) {
#line 239
          v_best = v;
#line 239
          i_best = i;
#line 239
          j_best = j;
        }
      }
#line 225
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 224
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 242
  if (v_best > (float )0) {
    {
#line 243
    add_flag(g, fg, i_best, j_best, 8);
    }
  }
#line 244
  return;
}
}
#line 246 "/home/june/repo/benchmarks/collector/temp/curseofwar-1.1.8/king.c"
void action_persistent_greedy(struct king *k , struct grid *g , struct flag_grid *fg ) 
{ 
  int i ;
  int j ;
  int army ;
  int enemy ;
  int p ;
  float v1 ;
  double tmp ;
  float v2 ;
  double tmp___0 ;
  float v ;
  float tmp___1 ;

  {
#line 248
  i = 0;
  {
#line 248
  while (1) {
    while_continue: /* CIL Label */ ;
#line 248
    if (! (i < g->width)) {
#line 248
      goto while_break;
    }
#line 249
    j = 0;
    {
#line 249
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 249
      if (! (j < g->height)) {
#line 249
        goto while_break___0;
      }
#line 251
      army = g->tiles[i][j].units[k->pl][0];
#line 252
      enemy = 0;
#line 254
      p = 0;
      {
#line 254
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 254
        if (! (p < 8)) {
#line 254
          goto while_break___1;
        }
#line 255
        if (p != k->pl) {
#line 256
          enemy += g->tiles[i][j].units[p][0];
        }
#line 254
        p ++;
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 258
      tmp = pow((double )army, 0.7);
#line 258
      v1 = (float )(((double )((float )k->value[i][j]) * (2.5 * (double )enemy - (double )army)) * tmp);
#line 260
      tmp___0 = pow((double )army, 0.7);
#line 260
      v2 = (float )(((double )((float )k->value[i][j] * (float )(499 - (enemy - army))) * tmp___0) * 0.5);
      }
#line 261
      if (enemy <= army) {
#line 261
        v2 = (float )-10000;
      }
#line 262
      if (v1 < v2) {
#line 262
        tmp___1 = v2;
      } else {
#line 262
        tmp___1 = v1;
      }
#line 262
      v = tmp___1;
#line 264
      if (fg->flag[i][j] == 1) {
#line 265
        if (v < (float )1000) {
          {
#line 266
          remove_flag(g, fg, i, j, 8);
          }
        }
      } else
#line 269
      if (v > (float )9000) {
        {
#line 270
        add_flag(g, fg, i, j, 8);
        }
      }
#line 249
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 248
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 274
  return;
}
}
#line 276 "/home/june/repo/benchmarks/collector/temp/curseofwar-1.1.8/king.c"
void action_opportunist(struct king *k , struct grid *g , struct flag_grid *fg ) 
{ 
  int i ;
  int j ;
  int army ;
  int enemy ;
  int p ;
  float v ;
  double tmp ;

  {
#line 278
  i = 0;
  {
#line 278
  while (1) {
    while_continue: /* CIL Label */ ;
#line 278
    if (! (i < g->width)) {
#line 278
      goto while_break;
    }
#line 279
    j = 0;
    {
#line 279
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 279
      if (! (j < g->height)) {
#line 279
        goto while_break___0;
      }
#line 280
      if (fg->flag[i][j]) {
        {
#line 281
        remove_flag(g, fg, i, j, 8);
        }
      }
#line 284
      army = g->tiles[i][j].units[k->pl][0];
#line 285
      enemy = 0;
#line 287
      p = 0;
      {
#line 287
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 287
        if (! (p < 8)) {
#line 287
          goto while_break___1;
        }
#line 288
        if (p != k->pl) {
#line 289
          enemy += g->tiles[i][j].units[p][0];
        }
#line 287
        p ++;
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 291
      tmp = pow((double )army, 0.5);
#line 291
      v = (float )((double )((float )k->value[i][j] * (float )(499 - (enemy - army))) * tmp);
      }
#line 293
      if (enemy > army) {
#line 293
        if (v > (float )7000) {
          {
#line 294
          add_flag(g, fg, i, j, 8);
          }
        }
      }
#line 279
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 278
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 297
  return;
}
}
#line 302 "/home/june/repo/benchmarks/collector/temp/curseofwar-1.1.8/king.c"
struct loc  const  no_loc  =    {-1, -1};
#line 305 "/home/june/repo/benchmarks/collector/temp/curseofwar-1.1.8/king.c"
void init_locval(struct loc *loc , int *val , int len ) 
{ 
  int i ;

  {
#line 307
  i = 0;
  {
#line 307
  while (1) {
    while_continue: /* CIL Label */ ;
#line 307
    if (! (i < len)) {
#line 307
      goto while_break;
    }
#line 308
    *(loc + i) = (struct loc )no_loc;
#line 309
    *(val + i) = -1;
#line 307
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 311
  return;
}
}
#line 314 "/home/june/repo/benchmarks/collector/temp/curseofwar-1.1.8/king.c"
void insert_locval(struct loc *loc , int *val , int len , struct loc lx , int vx ) 
{ 
  int i ;
  int j ;

  {
#line 316
  i = 0;
  {
#line 316
  while (1) {
    while_continue: /* CIL Label */ ;
#line 316
    if (i < len) {
#line 316
      if (i < 32) {
#line 316
        if (! (*(val + i) >= vx)) {
#line 316
          goto while_break;
        }
      } else {
#line 316
        goto while_break;
      }
    } else {
#line 316
      goto while_break;
    }
#line 316
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 317
  if (i < len) {
#line 317
    if (i < 32) {
#line 319
      j = len - 1;
      {
#line 319
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 319
        if (! (j > i)) {
#line 319
          goto while_break___0;
        }
#line 320
        *(loc + j) = *(loc + (j - 1));
#line 321
        *(val + j) = *(val + (j - 1));
#line 319
        j --;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 323
      *(loc + i) = lx;
#line 324
      *(val + i) = vx;
    }
  }
#line 326
  return;
}
}
#line 328 "/home/june/repo/benchmarks/collector/temp/curseofwar-1.1.8/king.c"
void action_noble(struct king *k , struct grid *g , struct flag_grid *fg ) 
{ 
  int i ;
  int j ;
  int locval_len ;
  struct loc loc[32] ;
  int val[32] ;
  int army ;
  int enemy ;
  int p ;
  float v ;
  double tmp ;
  struct loc lx ;

  {
  {
#line 331
  locval_len = 5;
#line 334
  init_locval((struct loc *)(loc), (int *)(val), locval_len);
#line 336
  i = 0;
  }
  {
#line 336
  while (1) {
    while_continue: /* CIL Label */ ;
#line 336
    if (! (i < g->width)) {
#line 336
      goto while_break;
    }
#line 337
    j = 0;
    {
#line 337
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 337
      if (! (j < g->height)) {
#line 337
        goto while_break___0;
      }
#line 338
      if (fg->flag[i][j]) {
        {
#line 339
        remove_flag(g, fg, i, j, 8);
        }
      }
#line 342
      army = g->tiles[i][j].units[k->pl][0];
#line 343
      enemy = 0;
#line 345
      p = 0;
      {
#line 345
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 345
        if (! (p < 8)) {
#line 345
          goto while_break___1;
        }
#line 346
        if (p != k->pl) {
#line 347
          enemy += g->tiles[i][j].units[p][0];
        }
#line 345
        p ++;
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 349
      tmp = pow((double )army, 0.5);
#line 349
      v = (float )((double )((float )k->value[i][j] * (float )(499 - (enemy - army))) * tmp);
      }
#line 351
      if (enemy > army) {
#line 351
        if (v > (float )7000) {
          {
#line 353
          lx.i = i;
#line 353
          lx.j = j;
#line 354
          insert_locval((struct loc *)(loc), (int *)(val), locval_len, lx, (int )v);
          }
        }
      }
#line 337
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 336
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 358
  i = 0;
  {
#line 358
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 358
    if (i < locval_len) {
#line 358
      if (! (val[i] > 0)) {
#line 358
        goto while_break___2;
      }
    } else {
#line 358
      goto while_break___2;
    }
    {
#line 359
    add_flag(g, fg, loc[i].i, loc[i].j, 8);
#line 358
    i ++;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
#line 361
  return;
}
}
#line 363 "/home/june/repo/benchmarks/collector/temp/curseofwar-1.1.8/king.c"
void place_flags(struct king *k , struct grid *g , struct flag_grid *fg ) 
{ 


  {
  {
#line 365
  if ((unsigned int )k->strategy == 1U) {
#line 365
    goto case_1;
  }
#line 366
  if ((unsigned int )k->strategy == 2U) {
#line 366
    goto case_2;
  }
#line 367
  if ((unsigned int )k->strategy == 3U) {
#line 367
    goto case_3;
  }
#line 368
  if ((unsigned int )k->strategy == 4U) {
#line 368
    goto case_4;
  }
#line 369
  if ((unsigned int )k->strategy == 5U) {
#line 369
    goto case_5;
  }
#line 370
  if ((unsigned int )k->strategy == 6U) {
#line 370
    goto case_6;
  }
#line 371
  goto switch_default;
  case_1: /* CIL Label */ 
  {
#line 365
  action_aggr_greedy(k, g, fg);
  }
#line 365
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 366
  action_one_greedy(k, g, fg);
  }
#line 366
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 367
  action_persistent_greedy(k, g, fg);
  }
#line 367
  goto switch_break;
  case_4: /* CIL Label */ 
  {
#line 368
  action_opportunist(k, g, fg);
  }
#line 368
  goto switch_break;
  case_5: /* CIL Label */ 
  {
#line 369
  action_noble(k, g, fg);
  }
#line 369
  goto switch_break;
  case_6: /* CIL Label */ 
#line 370
  goto switch_break;
  switch_default: /* CIL Label */ ;
  switch_break: /* CIL Label */ ;
  }
#line 373
  return;
}
}
