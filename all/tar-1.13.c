/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 141 "/usr/include/stdint.h"
typedef unsigned long long uintmax_t;
#line 17 "xstrtol.h"
enum strtol_error {
    LONGINT_OK = 0,
    LONGINT_INVALID = 1,
    LONGINT_INVALID_SUFFIX_CHAR = 2,
    LONGINT_OVERFLOW = 3
} ;
#line 21 "xstrtol.h"
typedef enum strtol_error strtol_error;
#line 213 "/usr/lib/gcc-lib/i486-linux/3.3.5/include/stddef.h"
typedef unsigned int size_t;
#line 182 "/usr/include/bits/types.h"
typedef int __ssize_t;
#line 110 "/usr/include/sys/types.h"
typedef __ssize_t ssize_t;
#line 21 "quotearg.h"
enum quoting_style {
    literal_quoting_style = 0,
    shell_quoting_style = 1,
    shell_always_quoting_style = 2,
    c_quoting_style = 3,
    escape_quoting_style = 4
} ;
#line 40
struct quoting_options;
#line 60 "quotearg.c"
struct quoting_options {
   enum quoting_style style ;
   int quote_these_too[256UL / (sizeof(int ) * 8UL) + (unsigned long )(256UL % (sizeof(int ) * 8UL) != 0UL)] ;
};
#line 309 "quotearg.c"
struct slotvec {
   size_t size ;
   char *val ;
};
#line 152 "/usr/include/bits/types.h"
typedef unsigned int __useconds_t;
#line 136 "/usr/include/bits/types.h"
typedef unsigned long long __dev_t;
#line 137 "/usr/include/bits/types.h"
typedef unsigned int __uid_t;
#line 138 "/usr/include/bits/types.h"
typedef unsigned int __gid_t;
#line 139 "/usr/include/bits/types.h"
typedef unsigned long __ino_t;
#line 140 "/usr/include/bits/types.h"
typedef unsigned long long __ino64_t;
#line 141 "/usr/include/bits/types.h"
typedef unsigned int __mode_t;
#line 142 "/usr/include/bits/types.h"
typedef unsigned int __nlink_t;
#line 144 "/usr/include/bits/types.h"
typedef long long __off64_t;
#line 151 "/usr/include/bits/types.h"
typedef long __time_t;
#line 166 "/usr/include/bits/types.h"
typedef long __blksize_t;
#line 172 "/usr/include/bits/types.h"
typedef long long __blkcnt64_t;
#line 72 "/usr/include/sys/types.h"
typedef __mode_t mode_t;
#line 118 "/usr/include/time.h"
struct timespec {
   __time_t tv_sec ;
   long tv_nsec ;
};
#line 38 "modechange.h"
struct mode_change {
   char op ;
   char flags ;
   mode_t affected ;
   mode_t value ;
   struct mode_change *next ;
};
#line 36 "/usr/include/bits/stat.h"
struct stat {
   __dev_t st_dev ;
   unsigned short __pad1 ;
   __ino_t __st_ino ;
   __mode_t st_mode ;
   __nlink_t st_nlink ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   __dev_t st_rdev ;
   unsigned short __pad2 ;
   __off64_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt64_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   __ino64_t st_ino ;
};
#line 76 "/usr/include/time.h"
typedef __time_t time_t;
#line 133 "getdate.y"
struct _TABLE {
   char const   *name ;
   int type ;
   int value ;
};
#line 133 "getdate.y"
typedef struct _TABLE TABLE;
#line 143
enum _MERIDIAN {
    MERam = 0,
    MERpm = 1,
    MER24 = 2
} ;
#line 143 "getdate.y"
typedef enum _MERIDIAN MERIDIAN;
#line 182 "getdate.y"
union __anonunion_YYSTYPE_27 {
   int Number ;
   enum _MERIDIAN Meridian ;
};
#line 182 "getdate.y"
typedef union __anonunion_YYSTYPE_27 YYSTYPE;
#line 131 "/usr/include/time.h"
struct tm {
   int tm_sec ;
   int tm_min ;
   int tm_hour ;
   int tm_mday ;
   int tm_mon ;
   int tm_year ;
   int tm_wday ;
   int tm_yday ;
   int tm_isdst ;
   long tm_gmtoff ;
   char const   *tm_zone ;
};
#line 29 "exclude.h"
struct exclude;
#line 143 "/usr/include/bits/types.h"
typedef long __off_t;
#line 46 "/usr/include/stdio.h"
struct _IO_FILE;
#line 46 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 173 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 179 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 264 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   int _mode ;
   char _unused2[15UL * sizeof(int ) - 2UL * sizeof(void *)] ;
};
#line 328 "/usr/include/libio.h"
typedef struct _IO_FILE _IO_FILE;
#line 39 "exclude.c"
struct exclude {
   char const   **exclude ;
   int exclude_alloc ;
   int exclude_count ;
};
#line 43 "/usr/lib/gcc-lib/i486-linux/3.3.5/include/stdarg.h"
typedef __builtin_va_list __gnuc_va_list;
#line 77 "/usr/include/stdio.h"
typedef __gnuc_va_list va_list;
#line 23 "backupfile.h"
enum backup_type {
    none = 0,
    simple = 1,
    numbered_existing = 2,
    numbered = 3
} ;
#line 23 "/usr/include/bits/dirent.h"
struct dirent {
   __ino64_t d_ino ;
   __off64_t d_off ;
   unsigned short d_reclen ;
   unsigned char d_type ;
   char d_name[256] ;
};
#line 128 "/usr/include/dirent.h"
struct __dirstream;
#line 128 "/usr/include/dirent.h"
typedef struct __dirstream DIR;
#line 62 "/usr/include/sys/types.h"
typedef __dev_t dev_t;
#line 90 "/usr/include/sys/types.h"
typedef __off64_t off_t;
#line 37 "tar.h"
struct posix_header {
   char name[100] ;
   char mode[8] ;
   char uid[8] ;
   char gid[8] ;
   char size[12] ;
   char mtime[12] ;
   char chksum[8] ;
   char typeflag ;
   char linkname[100] ;
   char magic[6] ;
   char version[2] ;
   char uname[32] ;
   char gname[32] ;
   char devmajor[8] ;
   char devminor[8] ;
   char prefix[155] ;
};
#line 109 "tar.h"
struct sparse {
   char offset[12] ;
   char numbytes[12] ;
};
#line 135 "tar.h"
struct extra_header {
   char atime[12] ;
   char ctime[12] ;
   char offset[12] ;
   char realsize[12] ;
   char longnames[4] ;
   char unused_pad1[68] ;
   struct sparse sp[16] ;
   char isextended ;
};
#line 154 "tar.h"
struct sparse_header {
   struct sparse sp[21] ;
   char isextended ;
};
#line 170 "tar.h"
struct oldgnu_header {
   char unused_pad1[345] ;
   char atime[12] ;
   char ctime[12] ;
   char offset[12] ;
   char longnames[4] ;
   char unused_pad2 ;
   struct sparse sp[4] ;
   char isextended ;
   char realsize[12] ;
};
#line 223
enum archive_format {
    DEFAULT_FORMAT = 0,
    V7_FORMAT = 1,
    OLDGNU_FORMAT = 2,
    POSIX_FORMAT = 3,
    GNU_FORMAT = 4
} ;
#line 232 "tar.h"
union block {
   char buffer[512] ;
   struct posix_header header ;
   struct extra_header extra_header ;
   struct oldgnu_header oldgnu_header ;
   struct sparse_header sparse_header ;
};
#line 88 "common.h"
enum subcommand {
    UNKNOWN_SUBCOMMAND = 0,
    APPEND_SUBCOMMAND = 1,
    CAT_SUBCOMMAND = 2,
    CREATE_SUBCOMMAND = 3,
    DELETE_SUBCOMMAND = 4,
    DIFF_SUBCOMMAND = 5,
    EXTRACT_SUBCOMMAND = 6,
    LIST_SUBCOMMAND = 7,
    UPDATE_SUBCOMMAND = 8
} ;
#line 289 "common.h"
struct name {
   struct name *next ;
   size_t length ;
   char found ;
   char firstch ;
   char regexp ;
   char *change_dir ;
   char const   *dir_contents ;
   char fake ;
   char name[1] ;
};
#line 320
enum access_mode {
    ACCESS_READ = 0,
    ACCESS_WRITE = 1,
    ACCESS_UPDATE = 2
} ;
#line 406
enum read_header {
    HEADER_STILL_UNREAD = 0,
    HEADER_SUCCESS = 1,
    HEADER_ZERO_BLOCK = 2,
    HEADER_END_OF_FILE = 3,
    HEADER_FAILURE = 4
} ;
#line 67 "/usr/include/sys/types.h"
typedef __gid_t gid_t;
#line 82 "/usr/include/sys/types.h"
typedef __uid_t uid_t;
#line 73 "/usr/include/signal.h"
typedef void (*__sighandler_t)(int  );
#line 83 "../lib/getopt.h"
struct option {
   char const   *name ;
   int has_arg ;
   int *flag ;
   int val ;
};
#line 46 "arith.h"
typedef unsigned long long tarlong;
#line 305 "common.h"
struct sp_array {
   off_t offset ;
   size_t numbytes ;
};
#line 145 "/usr/include/bits/types.h"
typedef int __pid_t;
#line 155 "/usr/include/bits/types.h"
typedef int __daddr_t;
#line 100 "/usr/include/sys/types.h"
typedef __pid_t pid_t;
#line 31 "/usr/include/sys/mtio.h"
struct mtop {
   short mt_op ;
   int mt_count ;
};
#line 82 "/usr/include/sys/mtio.h"
struct mtget {
   long mt_type ;
   long mt_resid ;
   long mt_dsreg ;
   long mt_gstat ;
   long mt_erreg ;
   __daddr_t mt_fileno ;
   __daddr_t mt_blkno ;
};
#line 50 "/usr/include/pwd.h"
struct passwd {
   char *pw_name ;
   char *pw_passwd ;
   __uid_t pw_uid ;
   __gid_t pw_gid ;
   char *pw_gecos ;
   char *pw_dir ;
   char *pw_shell ;
};
#line 43 "/usr/include/grp.h"
struct group {
   char *gr_name ;
   char *gr_passwd ;
   __gid_t gr_gid ;
   char **gr_mem ;
};
#line 25 "mangle.c"
struct mangled {
   struct mangled *next ;
   int type ;
   char mangled[100] ;
   char *linked_to ;
   char normal[1] ;
};
#line 52 "/usr/include/sys/types.h"
typedef __ino64_t ino_t;
#line 27 "incremen.c"
struct accumulator {
   size_t allocated ;
   size_t length ;
   char *pointer ;
};
#line 98 "incremen.c"
struct directory {
   struct directory *next ;
   char const   *name ;
   dev_t device_number ;
   ino_t inode_number ;
   char allnew ;
   char nfs ;
   char const   *dir_text ;
};
#line 38 "/usr/include/utime.h"
struct utimbuf {
   __time_t actime ;
   __time_t modtime ;
};
#line 50 "extract.c"
struct delayed_set_stat {
   struct delayed_set_stat *next ;
   char *file_name ;
   struct stat stat_info ;
};
#line 47 "create.c"
struct link {
   struct link *next ;
   dev_t dev ;
   ino_t ino ;
   short linkcount ;
   char name[1] ;
};
#line 62 "/usr/include/sys/wait.h"
union wait;
#line 65 "/usr/include/bits/waitstatus.h"
struct __anonstruct___wait_terminated_39 {
   unsigned int __w_termsig : 7 ;
   unsigned int __w_coredump : 1 ;
   unsigned int __w_retcode : 8 ;
   unsigned int  : 16 ;
};
#line 65 "/usr/include/bits/waitstatus.h"
struct __anonstruct___wait_stopped_40 {
   unsigned int __w_stopval : 8 ;
   unsigned int __w_stopsig : 8 ;
   unsigned int  : 16 ;
};
#line 65 "/usr/include/bits/waitstatus.h"
union wait {
   int w_status ;
   struct __anonstruct___wait_terminated_39 __wait_terminated ;
   struct __anonstruct___wait_stopped_40 __wait_stopped ;
};
#line 1456 "buffer.c"
union __anonunion___u_56 {
   int __in ;
   int __i ;
};
#line 1456 "buffer.c"
union __anonunion___u_57 {
   int __in ;
   int __i ;
};
#line 1456 "buffer.c"
union __anonunion___u_58 {
   int __in ;
   int __i ;
};
#line 1455 "buffer.c"
union __anonunion___u_59 {
   int __in ;
   int __i ;
};
#line 1467 "buffer.c"
union __anonunion___u_60 {
   int __in ;
   int __i ;
};
#line 1465 "buffer.c"
union __anonunion___u_61 {
   int __in ;
   int __i ;
};
#line 1466 "buffer.c"
union __anonunion___u_62 {
   int __in ;
   int __i ;
};
#line 1447 "buffer.c"
union __anonunion___u_63 {
   int __in ;
   int __i ;
};
/* compiler builtin: 
   long __builtin_expect(long  , long  ) ;  */
#line 309 "/usr/include/inttypes.h"
extern uintmax_t strtoumax(char const   * __restrict  __nptr , char ** __restrict  __endptr ,
                           int __base ) ;
#line 162 "/usr/include/string.h"
extern char *strchr(char const   *__s , int __c )  __attribute__((__pure__)) ;
#line 70 "/usr/include/assert.h"
extern  __attribute__((__noreturn__)) void __assert_fail(char const   *__assertion ,
                                                         char const   *__file , unsigned int __line ,
                                                         char const   *__function ) ;
#line 81 "/usr/include/ctype.h"
extern unsigned short const   **__ctype_b_loc(void)  __attribute__((__const__)) ;
#line 38 "/usr/include/bits/errno.h"
extern int *__errno_location(void)  __attribute__((__const__)) ;
#line 30 "xstrtol.h"
strtol_error xstrtoumax(char const   *s , char **ptr , int strtol_base , uintmax_t *val ,
                        char const   *valid_suffixes ) ;
#line 93 "xstrtol.c"
static int bkm_scale(uintmax_t *x , int scale_factor ) 
{ 
  uintmax_t product ;

  {
#line 96
  product = *x * (uintmax_t )scale_factor;
#line 97
  if (*x != product / (uintmax_t )scale_factor) {
#line 98
    return (1);
  }
#line 99
  *x = product;
#line 100
  return (0);
}
}
#line 103 "xstrtol.c"
static int bkm_scale_by_power(uintmax_t *x , int base , int power ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  {
#line 106
  while (1) {
    while_continue: /* CIL Label */ ;
#line 106
    tmp___0 = power;
#line 106
    power --;
#line 106
    if (! tmp___0) {
#line 106
      goto while_break;
    }
    {
#line 107
    tmp = bkm_scale(x, base);
    }
#line 107
    if (tmp) {
#line 108
      return (1);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 110
  return (0);
}
}
#line 115 "xstrtol.c"
strtol_error xstrtoumax(char const   *s , char **ptr , int strtol_base , uintmax_t *val ,
                        char const   *valid_suffixes ) 
{ 
  char *t_ptr ;
  char **p ;
  uintmax_t tmp ;
  int tmp___0 ;
  long tmp___1 ;
  char const   *q ;
  unsigned short const   **tmp___2 ;
  int *tmp___3 ;
  int *tmp___4 ;
  int base ;
  int suffixes ;
  int overflow ;
  char *tmp___5 ;
  char *tmp___6 ;

  {
#line 123
  if (0 <= strtol_base) {
#line 123
    if (strtol_base <= 36) {
#line 123
      tmp___0 = 1;
    } else {
#line 123
      tmp___0 = 0;
    }
  } else {
#line 123
    tmp___0 = 0;
  }
  {
#line 123
  tmp___1 = __builtin_expect((long )tmp___0, 1L);
  }
#line 123
  if (! tmp___1) {
    {
#line 123
    __assert_fail("0 <= strtol_base && strtol_base <= 36", "xstrtol.c", 123U, "xstrtoumax");
    }
  }
#line 125
  if (ptr) {
#line 125
    p = ptr;
  } else {
#line 125
    p = & t_ptr;
  }
#line 129
  q = s;
  {
#line 130
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 130
    tmp___2 = __ctype_b_loc();
    }
#line 130
    if (! ((int const   )*(*tmp___2 + (int )((unsigned char )*q)) & 8192)) {
#line 130
      goto while_break;
    }
#line 131
    q ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 132
  if ((int const   )*q == 45) {
#line 133
    return ((strtol_error )1);
  }
  {
#line 136
  tmp___3 = __errno_location();
#line 136
  *tmp___3 = 0;
#line 137
  tmp = strtoumax((char const   */* __restrict  */)s, (char **/* __restrict  */)p,
                  strtol_base);
#line 138
  tmp___4 = __errno_location();
  }
#line 138
  if (*tmp___4 != 0) {
#line 139
    return ((strtol_error )3);
  }
#line 140
  if ((unsigned long )*p == (unsigned long )s) {
#line 141
    return ((strtol_error )1);
  }
#line 146
  if (! valid_suffixes) {
#line 148
    *val = tmp;
#line 149
    return ((strtol_error )0);
  }
#line 152
  if ((int )*(*p) != 0) {
    {
#line 154
    base = 1024;
#line 155
    suffixes = 1;
#line 158
    tmp___5 = strchr(valid_suffixes, (int )*(*p));
    }
#line 158
    if (! tmp___5) {
#line 160
      *val = tmp;
#line 161
      return ((strtol_error )2);
    }
    {
#line 164
    tmp___6 = strchr(valid_suffixes, '0');
    }
#line 164
    if (tmp___6) {
      {
#line 172
      if ((int )*(*(p + 0) + 1) == 66) {
#line 172
        goto case_66;
      }
#line 176
      if ((int )*(*(p + 0) + 1) == 68) {
#line 176
        goto case_68;
      }
#line 170
      goto switch_break;
      case_66: /* CIL Label */ 
#line 173
      suffixes ++;
#line 174
      goto switch_break;
      case_68: /* CIL Label */ 
#line 177
      base = 1000;
#line 178
      suffixes ++;
#line 179
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    }
    {
#line 185
    if ((int )*(*p) == 98) {
#line 185
      goto case_98;
    }
#line 189
    if ((int )*(*p) == 66) {
#line 189
      goto case_66___0;
    }
#line 193
    if ((int )*(*p) == 99) {
#line 193
      goto case_99;
    }
#line 197
    if ((int )*(*p) == 69) {
#line 197
      goto case_69;
    }
#line 201
    if ((int )*(*p) == 71) {
#line 201
      goto case_71;
    }
#line 205
    if ((int )*(*p) == 107) {
#line 205
      goto case_107;
    }
#line 210
    if ((int )*(*p) == 109) {
#line 210
      goto case_109;
    }
#line 210
    if ((int )*(*p) == 77) {
#line 210
      goto case_109;
    }
#line 214
    if ((int )*(*p) == 80) {
#line 214
      goto case_80;
    }
#line 218
    if ((int )*(*p) == 84) {
#line 218
      goto case_84;
    }
#line 222
    if ((int )*(*p) == 119) {
#line 222
      goto case_119;
    }
#line 226
    if ((int )*(*p) == 89) {
#line 226
      goto case_89;
    }
#line 230
    if ((int )*(*p) == 90) {
#line 230
      goto case_90;
    }
#line 234
    goto switch_default;
    case_98: /* CIL Label */ 
    {
#line 186
    overflow = bkm_scale(& tmp, 512);
    }
#line 187
    goto switch_break___0;
    case_66___0: /* CIL Label */ 
    {
#line 190
    overflow = bkm_scale(& tmp, 1024);
    }
#line 191
    goto switch_break___0;
    case_99: /* CIL Label */ 
#line 194
    overflow = 0;
#line 195
    goto switch_break___0;
    case_69: /* CIL Label */ 
    {
#line 198
    overflow = bkm_scale_by_power(& tmp, base, 6);
    }
#line 199
    goto switch_break___0;
    case_71: /* CIL Label */ 
    {
#line 202
    overflow = bkm_scale_by_power(& tmp, base, 3);
    }
#line 203
    goto switch_break___0;
    case_107: /* CIL Label */ 
    {
#line 206
    overflow = bkm_scale_by_power(& tmp, base, 1);
    }
#line 207
    goto switch_break___0;
    case_109: /* CIL Label */ 
    case_77: /* CIL Label */ 
    {
#line 211
    overflow = bkm_scale_by_power(& tmp, base, 2);
    }
#line 212
    goto switch_break___0;
    case_80: /* CIL Label */ 
    {
#line 215
    overflow = bkm_scale_by_power(& tmp, base, 5);
    }
#line 216
    goto switch_break___0;
    case_84: /* CIL Label */ 
    {
#line 219
    overflow = bkm_scale_by_power(& tmp, base, 4);
    }
#line 220
    goto switch_break___0;
    case_119: /* CIL Label */ 
    {
#line 223
    overflow = bkm_scale(& tmp, 2);
    }
#line 224
    goto switch_break___0;
    case_89: /* CIL Label */ 
    {
#line 227
    overflow = bkm_scale_by_power(& tmp, base, 8);
    }
#line 228
    goto switch_break___0;
    case_90: /* CIL Label */ 
    {
#line 231
    overflow = bkm_scale_by_power(& tmp, base, 7);
    }
#line 232
    goto switch_break___0;
    switch_default: /* CIL Label */ 
#line 235
    *val = tmp;
#line 236
    return ((strtol_error )2);
#line 237
    goto switch_break___0;
    switch_break___0: /* CIL Label */ ;
    }
#line 240
    if (overflow) {
#line 241
      return ((strtol_error )3);
    }
#line 243
    *p += suffixes;
  }
#line 246
  *val = tmp;
#line 247
  return ((strtol_error )0);
}
}
#line 179 "/usr/include/stdlib.h"
extern unsigned long strtoul(char const   * __restrict  __nptr , char ** __restrict  __endptr ,
                             int __base ) ;
#line 29 "xstrtol.h"
strtol_error xstrtoul(char const   *s , char **ptr , int strtol_base , unsigned long *val ,
                      char const   *valid_suffixes ) ;
#line 93 "xstrtol.c"
static int bkm_scale___0(unsigned long *x , int scale_factor ) 
{ 
  unsigned long product ;

  {
#line 96
  product = *x * (unsigned long )scale_factor;
#line 97
  if (*x != product / (unsigned long )scale_factor) {
#line 98
    return (1);
  }
#line 99
  *x = product;
#line 100
  return (0);
}
}
#line 103 "xstrtol.c"
static int bkm_scale_by_power___0(unsigned long *x , int base , int power ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  {
#line 106
  while (1) {
    while_continue: /* CIL Label */ ;
#line 106
    tmp___0 = power;
#line 106
    power --;
#line 106
    if (! tmp___0) {
#line 106
      goto while_break;
    }
    {
#line 107
    tmp = bkm_scale___0(x, base);
    }
#line 107
    if (tmp) {
#line 108
      return (1);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 110
  return (0);
}
}
#line 115 "xstrtol.c"
strtol_error xstrtoul(char const   *s , char **ptr , int strtol_base , unsigned long *val ,
                      char const   *valid_suffixes ) 
{ 
  char *t_ptr ;
  char **p ;
  unsigned long tmp ;
  int tmp___0 ;
  long tmp___1 ;
  char const   *q ;
  unsigned short const   **tmp___2 ;
  int *tmp___3 ;
  int *tmp___4 ;
  int base ;
  int suffixes ;
  int overflow ;
  char *tmp___5 ;
  char *tmp___6 ;

  {
#line 123
  if (0 <= strtol_base) {
#line 123
    if (strtol_base <= 36) {
#line 123
      tmp___0 = 1;
    } else {
#line 123
      tmp___0 = 0;
    }
  } else {
#line 123
    tmp___0 = 0;
  }
  {
#line 123
  tmp___1 = __builtin_expect((long )tmp___0, 1L);
  }
#line 123
  if (! tmp___1) {
    {
#line 123
    __assert_fail("0 <= strtol_base && strtol_base <= 36", "xstrtol.c", 123U, "xstrtoul");
    }
  }
#line 125
  if (ptr) {
#line 125
    p = ptr;
  } else {
#line 125
    p = & t_ptr;
  }
#line 129
  q = s;
  {
#line 130
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 130
    tmp___2 = __ctype_b_loc();
    }
#line 130
    if (! ((int const   )*(*tmp___2 + (int )((unsigned char )*q)) & 8192)) {
#line 130
      goto while_break;
    }
#line 131
    q ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 132
  if ((int const   )*q == 45) {
#line 133
    return ((strtol_error )1);
  }
  {
#line 136
  tmp___3 = __errno_location();
#line 136
  *tmp___3 = 0;
#line 137
  tmp = strtoul((char const   */* __restrict  */)s, (char **/* __restrict  */)p, strtol_base);
#line 138
  tmp___4 = __errno_location();
  }
#line 138
  if (*tmp___4 != 0) {
#line 139
    return ((strtol_error )3);
  }
#line 140
  if ((unsigned long )*p == (unsigned long )s) {
#line 141
    return ((strtol_error )1);
  }
#line 146
  if (! valid_suffixes) {
#line 148
    *val = tmp;
#line 149
    return ((strtol_error )0);
  }
#line 152
  if ((int )*(*p) != 0) {
    {
#line 154
    base = 1024;
#line 155
    suffixes = 1;
#line 158
    tmp___5 = strchr(valid_suffixes, (int )*(*p));
    }
#line 158
    if (! tmp___5) {
#line 160
      *val = tmp;
#line 161
      return ((strtol_error )2);
    }
    {
#line 164
    tmp___6 = strchr(valid_suffixes, '0');
    }
#line 164
    if (tmp___6) {
      {
#line 172
      if ((int )*(*(p + 0) + 1) == 66) {
#line 172
        goto case_66;
      }
#line 176
      if ((int )*(*(p + 0) + 1) == 68) {
#line 176
        goto case_68;
      }
#line 170
      goto switch_break;
      case_66: /* CIL Label */ 
#line 173
      suffixes ++;
#line 174
      goto switch_break;
      case_68: /* CIL Label */ 
#line 177
      base = 1000;
#line 178
      suffixes ++;
#line 179
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    }
    {
#line 185
    if ((int )*(*p) == 98) {
#line 185
      goto case_98;
    }
#line 189
    if ((int )*(*p) == 66) {
#line 189
      goto case_66___0;
    }
#line 193
    if ((int )*(*p) == 99) {
#line 193
      goto case_99;
    }
#line 197
    if ((int )*(*p) == 69) {
#line 197
      goto case_69;
    }
#line 201
    if ((int )*(*p) == 71) {
#line 201
      goto case_71;
    }
#line 205
    if ((int )*(*p) == 107) {
#line 205
      goto case_107;
    }
#line 210
    if ((int )*(*p) == 109) {
#line 210
      goto case_109;
    }
#line 210
    if ((int )*(*p) == 77) {
#line 210
      goto case_109;
    }
#line 214
    if ((int )*(*p) == 80) {
#line 214
      goto case_80;
    }
#line 218
    if ((int )*(*p) == 84) {
#line 218
      goto case_84;
    }
#line 222
    if ((int )*(*p) == 119) {
#line 222
      goto case_119;
    }
#line 226
    if ((int )*(*p) == 89) {
#line 226
      goto case_89;
    }
#line 230
    if ((int )*(*p) == 90) {
#line 230
      goto case_90;
    }
#line 234
    goto switch_default;
    case_98: /* CIL Label */ 
    {
#line 186
    overflow = bkm_scale___0(& tmp, 512);
    }
#line 187
    goto switch_break___0;
    case_66___0: /* CIL Label */ 
    {
#line 190
    overflow = bkm_scale___0(& tmp, 1024);
    }
#line 191
    goto switch_break___0;
    case_99: /* CIL Label */ 
#line 194
    overflow = 0;
#line 195
    goto switch_break___0;
    case_69: /* CIL Label */ 
    {
#line 198
    overflow = bkm_scale_by_power___0(& tmp, base, 6);
    }
#line 199
    goto switch_break___0;
    case_71: /* CIL Label */ 
    {
#line 202
    overflow = bkm_scale_by_power___0(& tmp, base, 3);
    }
#line 203
    goto switch_break___0;
    case_107: /* CIL Label */ 
    {
#line 206
    overflow = bkm_scale_by_power___0(& tmp, base, 1);
    }
#line 207
    goto switch_break___0;
    case_109: /* CIL Label */ 
    case_77: /* CIL Label */ 
    {
#line 211
    overflow = bkm_scale_by_power___0(& tmp, base, 2);
    }
#line 212
    goto switch_break___0;
    case_80: /* CIL Label */ 
    {
#line 215
    overflow = bkm_scale_by_power___0(& tmp, base, 5);
    }
#line 216
    goto switch_break___0;
    case_84: /* CIL Label */ 
    {
#line 219
    overflow = bkm_scale_by_power___0(& tmp, base, 4);
    }
#line 220
    goto switch_break___0;
    case_119: /* CIL Label */ 
    {
#line 223
    overflow = bkm_scale___0(& tmp, 2);
    }
#line 224
    goto switch_break___0;
    case_89: /* CIL Label */ 
    {
#line 227
    overflow = bkm_scale_by_power___0(& tmp, base, 8);
    }
#line 228
    goto switch_break___0;
    case_90: /* CIL Label */ 
    {
#line 231
    overflow = bkm_scale_by_power___0(& tmp, base, 7);
    }
#line 232
    goto switch_break___0;
    switch_default: /* CIL Label */ 
#line 235
    *val = tmp;
#line 236
    return ((strtol_error )2);
#line 237
    goto switch_break___0;
    switch_break___0: /* CIL Label */ ;
    }
#line 240
    if (overflow) {
#line 241
      return ((strtol_error )3);
    }
#line 243
    *p += suffixes;
  }
#line 246
  *val = tmp;
#line 247
  return ((strtol_error )0);
}
}
#line 176 "/usr/include/stdlib.h"
extern long strtol(char const   * __restrict  __nptr , char ** __restrict  __endptr ,
                   int __base ) ;
#line 28 "xstrtol.h"
strtol_error xstrtol(char const   *s , char **ptr , int strtol_base , long *val ,
                     char const   *valid_suffixes ) ;
#line 93 "xstrtol.c"
static int bkm_scale___1(long *x , int scale_factor ) 
{ 
  long product ;

  {
#line 96
  product = *x * (long )scale_factor;
#line 97
  if (*x != product / (long )scale_factor) {
#line 98
    return (1);
  }
#line 99
  *x = product;
#line 100
  return (0);
}
}
#line 103 "xstrtol.c"
static int bkm_scale_by_power___1(long *x , int base , int power ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  {
#line 106
  while (1) {
    while_continue: /* CIL Label */ ;
#line 106
    tmp___0 = power;
#line 106
    power --;
#line 106
    if (! tmp___0) {
#line 106
      goto while_break;
    }
    {
#line 107
    tmp = bkm_scale___1(x, base);
    }
#line 107
    if (tmp) {
#line 108
      return (1);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 110
  return (0);
}
}
#line 115 "xstrtol.c"
strtol_error xstrtol(char const   *s , char **ptr , int strtol_base , long *val ,
                     char const   *valid_suffixes ) 
{ 
  char *t_ptr ;
  char **p ;
  long tmp ;
  int tmp___0 ;
  long tmp___1 ;
  int *tmp___3 ;
  int *tmp___4 ;
  int base ;
  int suffixes ;
  int overflow ;
  char *tmp___5 ;
  char *tmp___6 ;

  {
#line 123
  if (0 <= strtol_base) {
#line 123
    if (strtol_base <= 36) {
#line 123
      tmp___0 = 1;
    } else {
#line 123
      tmp___0 = 0;
    }
  } else {
#line 123
    tmp___0 = 0;
  }
  {
#line 123
  tmp___1 = __builtin_expect((long )tmp___0, 1L);
  }
#line 123
  if (! tmp___1) {
    {
#line 123
    __assert_fail("0 <= strtol_base && strtol_base <= 36", "xstrtol.c", 123U, "xstrtol");
    }
  }
#line 125
  if (ptr) {
#line 125
    p = ptr;
  } else {
#line 125
    p = & t_ptr;
  }
  {
#line 136
  tmp___3 = __errno_location();
#line 136
  *tmp___3 = 0;
#line 137
  tmp = strtol((char const   */* __restrict  */)s, (char **/* __restrict  */)p, strtol_base);
#line 138
  tmp___4 = __errno_location();
  }
#line 138
  if (*tmp___4 != 0) {
#line 139
    return ((strtol_error )3);
  }
#line 140
  if ((unsigned long )*p == (unsigned long )s) {
#line 141
    return ((strtol_error )1);
  }
#line 146
  if (! valid_suffixes) {
#line 148
    *val = tmp;
#line 149
    return ((strtol_error )0);
  }
#line 152
  if ((int )*(*p) != 0) {
    {
#line 154
    base = 1024;
#line 155
    suffixes = 1;
#line 158
    tmp___5 = strchr(valid_suffixes, (int )*(*p));
    }
#line 158
    if (! tmp___5) {
#line 160
      *val = tmp;
#line 161
      return ((strtol_error )2);
    }
    {
#line 164
    tmp___6 = strchr(valid_suffixes, '0');
    }
#line 164
    if (tmp___6) {
      {
#line 172
      if ((int )*(*(p + 0) + 1) == 66) {
#line 172
        goto case_66;
      }
#line 176
      if ((int )*(*(p + 0) + 1) == 68) {
#line 176
        goto case_68;
      }
#line 170
      goto switch_break;
      case_66: /* CIL Label */ 
#line 173
      suffixes ++;
#line 174
      goto switch_break;
      case_68: /* CIL Label */ 
#line 177
      base = 1000;
#line 178
      suffixes ++;
#line 179
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    }
    {
#line 185
    if ((int )*(*p) == 98) {
#line 185
      goto case_98;
    }
#line 189
    if ((int )*(*p) == 66) {
#line 189
      goto case_66___0;
    }
#line 193
    if ((int )*(*p) == 99) {
#line 193
      goto case_99;
    }
#line 197
    if ((int )*(*p) == 69) {
#line 197
      goto case_69;
    }
#line 201
    if ((int )*(*p) == 71) {
#line 201
      goto case_71;
    }
#line 205
    if ((int )*(*p) == 107) {
#line 205
      goto case_107;
    }
#line 210
    if ((int )*(*p) == 109) {
#line 210
      goto case_109;
    }
#line 210
    if ((int )*(*p) == 77) {
#line 210
      goto case_109;
    }
#line 214
    if ((int )*(*p) == 80) {
#line 214
      goto case_80;
    }
#line 218
    if ((int )*(*p) == 84) {
#line 218
      goto case_84;
    }
#line 222
    if ((int )*(*p) == 119) {
#line 222
      goto case_119;
    }
#line 226
    if ((int )*(*p) == 89) {
#line 226
      goto case_89;
    }
#line 230
    if ((int )*(*p) == 90) {
#line 230
      goto case_90;
    }
#line 234
    goto switch_default;
    case_98: /* CIL Label */ 
    {
#line 186
    overflow = bkm_scale___1(& tmp, 512);
    }
#line 187
    goto switch_break___0;
    case_66___0: /* CIL Label */ 
    {
#line 190
    overflow = bkm_scale___1(& tmp, 1024);
    }
#line 191
    goto switch_break___0;
    case_99: /* CIL Label */ 
#line 194
    overflow = 0;
#line 195
    goto switch_break___0;
    case_69: /* CIL Label */ 
    {
#line 198
    overflow = bkm_scale_by_power___1(& tmp, base, 6);
    }
#line 199
    goto switch_break___0;
    case_71: /* CIL Label */ 
    {
#line 202
    overflow = bkm_scale_by_power___1(& tmp, base, 3);
    }
#line 203
    goto switch_break___0;
    case_107: /* CIL Label */ 
    {
#line 206
    overflow = bkm_scale_by_power___1(& tmp, base, 1);
    }
#line 207
    goto switch_break___0;
    case_109: /* CIL Label */ 
    case_77: /* CIL Label */ 
    {
#line 211
    overflow = bkm_scale_by_power___1(& tmp, base, 2);
    }
#line 212
    goto switch_break___0;
    case_80: /* CIL Label */ 
    {
#line 215
    overflow = bkm_scale_by_power___1(& tmp, base, 5);
    }
#line 216
    goto switch_break___0;
    case_84: /* CIL Label */ 
    {
#line 219
    overflow = bkm_scale_by_power___1(& tmp, base, 4);
    }
#line 220
    goto switch_break___0;
    case_119: /* CIL Label */ 
    {
#line 223
    overflow = bkm_scale___1(& tmp, 2);
    }
#line 224
    goto switch_break___0;
    case_89: /* CIL Label */ 
    {
#line 227
    overflow = bkm_scale_by_power___1(& tmp, base, 8);
    }
#line 228
    goto switch_break___0;
    case_90: /* CIL Label */ 
    {
#line 231
    overflow = bkm_scale_by_power___1(& tmp, base, 7);
    }
#line 232
    goto switch_break___0;
    switch_default: /* CIL Label */ 
#line 235
    *val = tmp;
#line 236
    return ((strtol_error )2);
#line 237
    goto switch_break___0;
    switch_break___0: /* CIL Label */ ;
    }
#line 240
    if (overflow) {
#line 241
      return ((strtol_error )3);
    }
#line 243
    *p += suffixes;
  }
#line 246
  *val = tmp;
#line 247
  return ((strtol_error )0);
}
}
#line 82 "/usr/include/string.h"
extern char *strcpy(char * __restrict  __dest , char const   * __restrict  __src ) ;
#line 230
extern size_t strlen(char const   *__s )  __attribute__((__pure__)) ;
#line 38 "xstrdup.c"
void *xmalloc(size_t n ) ;
#line 42 "xstrdup.c"
char *xstrdup(char const   *string ) 
{ 
  size_t tmp ;
  void *tmp___0 ;
  char *tmp___1 ;

  {
  {
#line 45
  tmp = strlen(string);
#line 45
  tmp___0 = xmalloc(tmp + 1U);
#line 45
  tmp___1 = strcpy((char */* __restrict  */)tmp___0, (char const   */* __restrict  */)string);
  }
#line 45
  return (tmp___1);
}
}
#line 556 "/usr/include/stdlib.h"
extern void *malloc(size_t __size )  __attribute__((__malloc__)) ;
#line 558
extern void *calloc(size_t __nmemb , size_t __size )  __attribute__((__malloc__)) ;
#line 567
extern void *realloc(void *__ptr , size_t __size )  __attribute__((__malloc__)) ;
#line 40 "/usr/include/libintl.h"
extern char *gettext(char const   *__msgid ) ;
#line 49 "error.h"
void ( /* format attribute */  error)(int status , int errnum , char const   *message 
                                      , ...) ;
#line 32 "xalloc.h"
int xalloc_exit_failure ;
#line 36
void (*xalloc_fail_func)() ;
#line 41
char * const  xalloc_msg_memory_exhausted ;
#line 44
void *xcalloc(size_t n , size_t s ) ;
#line 45
void *xrealloc(void *p , size_t n ) ;
#line 59 "xmalloc.c"
int xalloc_exit_failure  =    1;
#line 62 "xmalloc.c"
void (*xalloc_fail_func)()  =    (void (*)())0;
#line 66 "xmalloc.c"
char * const  xalloc_msg_memory_exhausted  =    (char */* const  */)"Memory exhausted";
#line 68 "xmalloc.c"
static void xalloc_fail(void) 
{ 
  char *tmp ;

  {
#line 71
  if (xalloc_fail_func) {
    {
#line 72
    (*xalloc_fail_func)();
    }
  }
  {
#line 73
  tmp = gettext((char const   *)xalloc_msg_memory_exhausted);
#line 73
  error(xalloc_exit_failure, 0, "%s", tmp);
  }
#line 74
  return;
}
}
#line 78 "xmalloc.c"
void *xmalloc(size_t n ) 
{ 
  void *p ;

  {
  {
#line 83
  p = malloc(n);
  }
#line 84
  if ((unsigned long )p == (unsigned long )((void *)0)) {
    {
#line 85
    xalloc_fail();
    }
  }
#line 86
  return (p);
}
}
#line 93 "xmalloc.c"
void *xrealloc(void *p , size_t n ) 
{ 


  {
  {
#line 96
  p = realloc(p, n);
  }
#line 97
  if ((unsigned long )p == (unsigned long )((void *)0)) {
    {
#line 98
    xalloc_fail();
    }
  }
#line 99
  return (p);
}
}
#line 104 "xmalloc.c"
void *xcalloc(size_t n , size_t s ) 
{ 
  void *p ;

  {
  {
#line 109
  p = calloc(n, s);
  }
#line 110
  if ((unsigned long )p == (unsigned long )((void *)0)) {
    {
#line 111
    xalloc_fail();
    }
  }
#line 112
  return (p);
}
}
#line 448 "/usr/include/unistd.h"
extern char *getcwd(char *__buf , size_t __size ) ;
#line 45 "xgetcwd.c"
extern void free(void *__ptr ) ;
#line 50 "xgetcwd.c"
char *xgetcwd(void) 
{ 
  char *cwd ;
  char *ret ;
  unsigned int path_max ;
  int *tmp ;
  void *tmp___0 ;
  int *tmp___1 ;
  void *tmp___2 ;
  int *tmp___3 ;
  int *tmp___4 ;
  int save_errno ;
  int *tmp___5 ;
  int *tmp___6 ;

  {
  {
#line 57
  tmp = __errno_location();
#line 57
  *tmp = 0;
#line 58
  path_max = 4096U;
#line 59
  path_max += 2U;
#line 61
  tmp___0 = xmalloc(path_max);
#line 61
  cwd = (char *)tmp___0;
#line 63
  tmp___1 = __errno_location();
#line 63
  *tmp___1 = 0;
  }
  {
#line 64
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 64
    ret = getcwd(cwd, path_max);
    }
#line 64
    if ((unsigned long )ret == (unsigned long )((void *)0)) {
      {
#line 64
      tmp___4 = __errno_location();
      }
#line 64
      if (! (*tmp___4 == 34)) {
#line 64
        goto while_break;
      }
    } else {
#line 64
      goto while_break;
    }
    {
#line 66
    path_max += 32U;
#line 67
    tmp___2 = xrealloc(cwd, path_max);
#line 67
    cwd = (char *)tmp___2;
#line 68
    tmp___3 = __errno_location();
#line 68
    *tmp___3 = 0;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 71
  if ((unsigned long )ret == (unsigned long )((void *)0)) {
    {
#line 73
    tmp___5 = __errno_location();
#line 73
    save_errno = *tmp___5;
#line 74
    free(cwd);
#line 75
    tmp___6 = __errno_location();
#line 75
    *tmp___6 = save_errno;
    }
#line 76
    return ((char *)((void *)0));
  }
#line 78
  return (cwd);
}
}
#line 312 "/usr/include/unistd.h"
extern ssize_t read(int __fd , void *__buf , size_t __nbytes ) ;
#line 10 "safe-read.h"
ssize_t safe_read(int desc , void *ptr , size_t len ) ;
#line 40 "safe-read.c"
ssize_t safe_read(int desc , void *ptr , size_t len ) 
{ 
  ssize_t n_chars ;
  int *tmp ;

  {
#line 45
  if (len <= 0U) {
#line 46
    return ((ssize_t )len);
  }
  {
#line 49
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 51
    n_chars = read(desc, ptr, len);
    }
#line 49
    if (n_chars < 0) {
      {
#line 49
      tmp = __errno_location();
      }
#line 49
      if (! (*tmp == 4)) {
#line 49
        goto while_break;
      }
    } else {
#line 49
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 58
  return (n_chars);
}
}
#line 37 "quotearg.h"
char const   * const  quoting_style_args[6] ;
#line 38
enum quoting_style  const  quoting_style_vals[5] ;
#line 56
struct quoting_options *clone_quoting_options(struct quoting_options *o___0 ) ;
#line 60
enum quoting_style get_quoting_style(struct quoting_options *o___0 ) ;
#line 64
void set_quoting_style(struct quoting_options *o___0 , enum quoting_style s ) ;
#line 72
int set_char_quoting(struct quoting_options *o___0 , char c , int i ) ;
#line 82
size_t quotearg_buffer(char *buffer___1 , size_t buffersize , char const   *arg ,
                       size_t argsize , struct quoting_options  const  *o___0 ) ;
#line 91
char *quotearg_n(unsigned int n , char const   *arg ) ;
#line 94
char *quotearg(char const   *arg ) ;
#line 97
char *quotearg_char(char const   *arg , char ch ) ;
#line 100
char *quotearg_colon(char const   *arg ) ;
#line 594 "/usr/include/stdlib.h"
extern  __attribute__((__noreturn__)) void abort(void) ;
#line 58 "/usr/include/string.h"
extern void *memset(void *__s , int __c , size_t __n ) ;
#line 72 "quotearg.c"
char const   * const  quoting_style_args[6]  = {      (char const   */* const  */)"literal",      (char const   */* const  */)"shell",      (char const   */* const  */)"shell-always",      (char const   */* const  */)"c", 
        (char const   */* const  */)"escape",      (char const   */* const  */)0};
#line 83 "quotearg.c"
enum quoting_style  const  quoting_style_vals[5]  = {      (enum quoting_style  const  )0,      (enum quoting_style  const  )1,      (enum quoting_style  const  )2,      (enum quoting_style  const  )3, 
        (enum quoting_style  const  )4};
#line 93 "quotearg.c"
static struct quoting_options default_quoting_options  ;
#line 98 "quotearg.c"
struct quoting_options *clone_quoting_options(struct quoting_options *o___0 ) 
{ 
  struct quoting_options *p ;
  void *tmp ;
  struct quoting_options *tmp___0 ;

  {
  {
#line 101
  tmp = xmalloc((size_t )sizeof(struct quoting_options ));
#line 101
  p = (struct quoting_options *)tmp;
  }
#line 103
  if (o___0) {
#line 103
    tmp___0 = o___0;
  } else {
#line 103
    tmp___0 = & default_quoting_options;
  }
#line 103
  *p = *tmp___0;
#line 104
  return (p);
}
}
#line 108 "quotearg.c"
enum quoting_style get_quoting_style(struct quoting_options *o___0 ) 
{ 
  struct quoting_options *tmp ;

  {
#line 111
  if (o___0) {
#line 111
    tmp = o___0;
  } else {
#line 111
    tmp = & default_quoting_options;
  }
#line 111
  return (tmp->style);
}
}
#line 116 "quotearg.c"
void set_quoting_style(struct quoting_options *o___0 , enum quoting_style s ) 
{ 
  struct quoting_options *tmp ;

  {
#line 119
  if (o___0) {
#line 119
    tmp = o___0;
  } else {
#line 119
    tmp = & default_quoting_options;
  }
#line 119
  tmp->style = s;
#line 120
  return;
}
}
#line 127 "quotearg.c"
int set_char_quoting(struct quoting_options *o___0 , char c , int i ) 
{ 
  unsigned char uc ;
  int *p ;
  struct quoting_options *tmp ;
  int shift ;
  int r ;

  {
#line 130
  uc = (unsigned char )c;
#line 131
  if (o___0) {
#line 131
    tmp = o___0;
  } else {
#line 131
    tmp = & default_quoting_options;
  }
#line 131
  p = tmp->quote_these_too + (unsigned long )uc / (sizeof(int ) * 8UL);
#line 132
  shift = (int )((unsigned long )uc % (sizeof(int ) * 8UL));
#line 133
  r = (*p >> shift) & 1;
#line 134
  *p ^= ((i & 1) ^ r) << shift;
#line 135
  return (r);
}
}
#line 146 "quotearg.c"
size_t quotearg_buffer(char *buffer___1 , size_t buffersize , char const   *arg ,
                       size_t argsize , struct quoting_options  const  *o___0 ) 
{ 
  unsigned char c ;
  size_t i ;
  size_t len ;
  int quote_mark ;
  struct quoting_options  const  *p ;
  struct quoting_options  const  *tmp ;
  enum quoting_style quoting_style ;
  int tmp___0 ;
  int tmp___1 ;
  unsigned short const   **tmp___2 ;
  int tmp___3 ;

  {
#line 155
  if (o___0) {
#line 155
    tmp = o___0;
  } else {
#line 155
    tmp = (struct quoting_options  const  *)(& default_quoting_options);
  }
#line 155
  p = tmp;
#line 156
  quoting_style = (enum quoting_style )p->style;
  {
#line 168
  if ((unsigned int )quoting_style == 1U) {
#line 168
    goto case_1;
  }
#line 209
  if ((unsigned int )quoting_style == 2U) {
#line 209
    goto case_2;
  }
#line 213
  if ((unsigned int )quoting_style == 3U) {
#line 213
    goto case_3;
  }
#line 217
  goto switch_default___0;
  case_1: /* CIL Label */ 
#line 169
  if (argsize == 4294967295U) {
#line 169
    tmp___1 = (int const   )*(arg + 0) == 0;
  } else {
#line 169
    tmp___1 = argsize == 0U;
  }
#line 169
  if (! tmp___1) {
    {
#line 173
    if ((int const   )*(arg + 0) == 126) {
#line 173
      goto case_126;
    }
#line 173
    if ((int const   )*(arg + 0) == 35) {
#line 173
      goto case_126;
    }
#line 176
    goto switch_default;
    case_126: /* CIL Label */ 
    case_35: /* CIL Label */ 
#line 174
    goto switch_break___0;
    switch_default: /* CIL Label */ 
#line 177
    len = (size_t )0;
#line 178
    i = (size_t )0;
    {
#line 178
    while (1) {
      while_continue: /* CIL Label */ ;
#line 180
      if (argsize == 4294967295U) {
#line 180
        tmp___0 = (int const   )*(arg + i) == 0;
      } else {
#line 180
        tmp___0 = i == argsize;
      }
#line 180
      if (tmp___0) {
#line 181
        goto done;
      }
#line 183
      c = (unsigned char )*(arg + i);
      {
#line 193
      if ((int )c == 124) {
#line 193
        goto case_124;
      }
#line 193
      if ((int )c == 96) {
#line 193
        goto case_124;
      }
#line 193
      if ((int )c == 94) {
#line 193
        goto case_124;
      }
#line 193
      if ((int )c == 92) {
#line 193
        goto case_124;
      }
#line 193
      if ((int )c == 91) {
#line 193
        goto case_124;
      }
#line 193
      if ((int )c == 63) {
#line 193
        goto case_124;
      }
#line 193
      if ((int )c == 62) {
#line 193
        goto case_124;
      }
#line 193
      if ((int )c == 60) {
#line 193
        goto case_124;
      }
#line 193
      if ((int )c == 59) {
#line 193
        goto case_124;
      }
#line 193
      if ((int )c == 42) {
#line 193
        goto case_124;
      }
#line 193
      if ((int )c == 41) {
#line 193
        goto case_124;
      }
#line 193
      if ((int )c == 40) {
#line 193
        goto case_124;
      }
#line 193
      if ((int )c == 39) {
#line 193
        goto case_124;
      }
#line 193
      if ((int )c == 38) {
#line 193
        goto case_124;
      }
#line 193
      if ((int )c == 36) {
#line 193
        goto case_124;
      }
#line 193
      if ((int )c == 34) {
#line 193
        goto case_124;
      }
#line 193
      if ((int )c == 33) {
#line 193
        goto case_124;
      }
#line 193
      if ((int )c == 32) {
#line 193
        goto case_124;
      }
#line 193
      if ((int )c == 10) {
#line 193
        goto case_124;
      }
#line 193
      if ((int )c == 9) {
#line 193
        goto case_124;
      }
#line 185
      goto switch_break___1;
      case_124: /* CIL Label */ 
      case_96: /* CIL Label */ 
      case_94: /* CIL Label */ 
      case_92: /* CIL Label */ 
      case_91: /* CIL Label */ 
      case_63: /* CIL Label */ 
      case_62: /* CIL Label */ 
      case_60: /* CIL Label */ 
      case_59: /* CIL Label */ 
      case_42: /* CIL Label */ 
      case_41: /* CIL Label */ 
      case_40: /* CIL Label */ 
      case_39: /* CIL Label */ 
      case_38: /* CIL Label */ 
      case_36: /* CIL Label */ 
      case_34: /* CIL Label */ 
      case_33: /* CIL Label */ 
      case_32: /* CIL Label */ 
      case_10: /* CIL Label */ 
      case_9: /* CIL Label */ 
#line 194
      goto needs_quoting;
      switch_break___1: /* CIL Label */ ;
      }
#line 197
      if (p->quote_these_too[(unsigned long )c / (sizeof(int ) * 8UL)] & (1 << (unsigned long )c % (sizeof(int ) * 8UL))) {
#line 198
        goto needs_quoting;
      }
      {
#line 200
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 200
        if (len < buffersize) {
#line 200
          *(buffer___1 + len) = (char )c;
        }
#line 200
        len ++;
#line 200
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 178
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
    needs_quoting: ;
#line 204
    goto switch_break___0;
    switch_break___0: /* CIL Label */ ;
    }
  }
  case_2: /* CIL Label */ 
#line 210
  quote_mark = '\'';
#line 211
  goto switch_break;
  case_3: /* CIL Label */ 
#line 214
  quote_mark = '\"';
#line 215
  goto switch_break;
  switch_default___0: /* CIL Label */ 
#line 218
  quote_mark = 0;
#line 219
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 222
  len = (size_t )0;
#line 224
  if (quote_mark) {
    {
#line 225
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 225
      if (len < buffersize) {
#line 225
        *(buffer___1 + len) = (char )quote_mark;
      }
#line 225
      len ++;
#line 225
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
#line 227
  i = (size_t )0;
  {
#line 227
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 227
    if (argsize == 4294967295U) {
#line 227
      tmp___3 = (int const   )*(arg + i) == 0;
    } else {
#line 227
      tmp___3 = i == argsize;
    }
#line 227
    if (tmp___3) {
#line 227
      goto while_break___2;
    }
#line 229
    c = (unsigned char )*(arg + i);
    {
#line 233
    if ((unsigned int )quoting_style == 0U) {
#line 233
      goto case_0;
    }
#line 237
    if ((unsigned int )quoting_style == 2U) {
#line 237
      goto case_2___0;
    }
#line 237
    if ((unsigned int )quoting_style == 1U) {
#line 237
      goto case_2___0;
    }
#line 247
    if ((unsigned int )quoting_style == 4U) {
#line 247
      goto case_4;
    }
#line 247
    if ((unsigned int )quoting_style == 3U) {
#line 247
      goto case_4;
    }
#line 231
    goto switch_break___2;
    case_0: /* CIL Label */ 
#line 234
    goto switch_break___2;
    case_2___0: /* CIL Label */ 
    case_1___0: /* CIL Label */ 
#line 238
    if ((int )c == 39) {
      {
#line 240
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 240
        if (len < buffersize) {
#line 240
          *(buffer___1 + len) = (char )'\'';
        }
#line 240
        len ++;
#line 240
        goto while_break___3;
      }
      while_break___3: /* CIL Label */ ;
      }
      {
#line 241
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 241
        if (len < buffersize) {
#line 241
          *(buffer___1 + len) = (char )'\\';
        }
#line 241
        len ++;
#line 241
        goto while_break___4;
      }
      while_break___4: /* CIL Label */ ;
      }
      {
#line 242
      while (1) {
        while_continue___5: /* CIL Label */ ;
#line 242
        if (len < buffersize) {
#line 242
          *(buffer___1 + len) = (char )'\'';
        }
#line 242
        len ++;
#line 242
        goto while_break___5;
      }
      while_break___5: /* CIL Label */ ;
      }
    }
#line 244
    goto switch_break___2;
    case_4: /* CIL Label */ 
    case_3___0: /* CIL Label */ 
    {
#line 251
    if ((int )c == 92) {
#line 251
      goto case_92___0;
    }
#line 251
    if ((int )c == 63) {
#line 251
      goto case_92___0;
    }
#line 253
    if ((int )c == 7) {
#line 253
      goto case_7;
    }
#line 254
    if ((int )c == 8) {
#line 254
      goto case_8;
    }
#line 255
    if ((int )c == 12) {
#line 255
      goto case_12;
    }
#line 256
    if ((int )c == 10) {
#line 256
      goto case_10___0;
    }
#line 257
    if ((int )c == 13) {
#line 257
      goto case_13;
    }
#line 258
    if ((int )c == 9) {
#line 258
      goto case_9___0;
    }
#line 259
    if ((int )c == 11) {
#line 259
      goto case_11;
    }
#line 261
    if ((int )c == 34) {
#line 261
      goto case_34___0;
    }
#line 266
    goto switch_default___1;
    case_92___0: /* CIL Label */ 
    case_63___0: /* CIL Label */ 
#line 251
    goto store_escape;
    case_7: /* CIL Label */ 
#line 253
    c = (unsigned char )'a';
#line 253
    goto store_escape;
    case_8: /* CIL Label */ 
#line 254
    c = (unsigned char )'b';
#line 254
    goto store_escape;
    case_12: /* CIL Label */ 
#line 255
    c = (unsigned char )'f';
#line 255
    goto store_escape;
    case_10___0: /* CIL Label */ 
#line 256
    c = (unsigned char )'n';
#line 256
    goto store_escape;
    case_13: /* CIL Label */ 
#line 257
    c = (unsigned char )'r';
#line 257
    goto store_escape;
    case_9___0: /* CIL Label */ 
#line 258
    c = (unsigned char )'t';
#line 258
    goto store_escape;
    case_11: /* CIL Label */ 
#line 259
    c = (unsigned char )'v';
#line 259
    goto store_escape;
    case_34___0: /* CIL Label */ 
#line 262
    if ((unsigned int )quoting_style == 3U) {
#line 263
      goto store_escape;
    }
#line 264
    goto switch_break___3;
    switch_default___1: /* CIL Label */ 
    {
#line 267
    tmp___2 = __ctype_b_loc();
    }
#line 267
    if (! ((int const   )*(*tmp___2 + (int )c) & 32768)) {
      {
#line 269
      while (1) {
        while_continue___6: /* CIL Label */ ;
#line 269
        if (len < buffersize) {
#line 269
          *(buffer___1 + len) = (char )'\\';
        }
#line 269
        len ++;
#line 269
        goto while_break___6;
      }
      while_break___6: /* CIL Label */ ;
      }
      {
#line 270
      while (1) {
        while_continue___7: /* CIL Label */ ;
#line 270
        if (len < buffersize) {
#line 270
          *(buffer___1 + len) = (char )(48 + ((int )c >> 6));
        }
#line 270
        len ++;
#line 270
        goto while_break___7;
      }
      while_break___7: /* CIL Label */ ;
      }
      {
#line 271
      while (1) {
        while_continue___8: /* CIL Label */ ;
#line 271
        if (len < buffersize) {
#line 271
          *(buffer___1 + len) = (char )(48 + (((int )c >> 3) & 7));
        }
#line 271
        len ++;
#line 271
        goto while_break___8;
      }
      while_break___8: /* CIL Label */ ;
      }
#line 272
      c = (unsigned char )(48 + ((int )c & 7));
#line 273
      goto store_c;
    }
#line 275
    goto switch_break___3;
    switch_break___3: /* CIL Label */ ;
    }
#line 278
    if (! (p->quote_these_too[(unsigned long )c / (sizeof(int ) * 8UL)] & (1 << (unsigned long )c % (sizeof(int ) * 8UL)))) {
#line 279
      goto store_c;
    }
    store_escape: 
    {
#line 282
    while (1) {
      while_continue___9: /* CIL Label */ ;
#line 282
      if (len < buffersize) {
#line 282
        *(buffer___1 + len) = (char )'\\';
      }
#line 282
      len ++;
#line 282
      goto while_break___9;
    }
    while_break___9: /* CIL Label */ ;
    }
    switch_break___2: /* CIL Label */ ;
    }
    store_c: 
    {
#line 286
    while (1) {
      while_continue___10: /* CIL Label */ ;
#line 286
      if (len < buffersize) {
#line 286
        *(buffer___1 + len) = (char )c;
      }
#line 286
      len ++;
#line 286
      goto while_break___10;
    }
    while_break___10: /* CIL Label */ ;
    }
#line 227
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 289
  if (quote_mark) {
    {
#line 290
    while (1) {
      while_continue___11: /* CIL Label */ ;
#line 290
      if (len < buffersize) {
#line 290
        *(buffer___1 + len) = (char )quote_mark;
      }
#line 290
      len ++;
#line 290
      goto while_break___11;
    }
    while_break___11: /* CIL Label */ ;
    }
  }
  done: 
#line 293
  if (len < buffersize) {
#line 294
    *(buffer___1 + len) = (char )'\000';
  }
#line 295
  return (len);
}
}
#line 308 "quotearg.c"
static unsigned int nslots  ;
#line 309 "quotearg.c"
static struct slotvec *slotvec  ;
#line 304 "quotearg.c"
static char *quotearg_n_options(int n , char const   *arg , struct quoting_options  const  *options ) 
{ 
  int n1 ;
  size_t s ;
  void *tmp ;
  size_t size ;
  char *val ;
  size_t qsize ;
  size_t tmp___0 ;
  void *tmp___1 ;

  {
#line 315
  if (nslots <= (unsigned int )n) {
#line 317
    n1 = n + 1;
#line 318
    s = (size_t )((unsigned long )n1 * sizeof(struct slotvec ));
#line 319
    if (0 < n1) {
#line 319
      if (! ((unsigned long )n1 == (unsigned long )s / sizeof(struct slotvec ))) {
        {
#line 320
        abort();
        }
      }
    } else {
      {
#line 320
      abort();
      }
    }
    {
#line 321
    tmp = xrealloc((void *)slotvec, s);
#line 321
    slotvec = (struct slotvec *)tmp;
#line 322
    memset((void *)(slotvec + nslots), 0, (size_t )((unsigned long )((unsigned int )n1 - nslots) * sizeof(struct slotvec )));
#line 323
    nslots = (unsigned int )n;
    }
  }
  {
#line 327
  size = (slotvec + n)->size;
#line 328
  val = (slotvec + n)->val;
#line 329
  tmp___0 = quotearg_buffer(val, size, arg, (size_t )-1, options);
#line 329
  qsize = tmp___0;
  }
#line 331
  if (size <= qsize) {
    {
#line 333
    size = qsize + 1U;
#line 333
    (slotvec + n)->size = size;
#line 334
    tmp___1 = xrealloc((void *)val, size);
#line 334
    val = (char *)tmp___1;
#line 334
    (slotvec + n)->val = val;
#line 335
    quotearg_buffer(val, size, arg, (size_t )-1, options);
    }
  }
#line 338
  return (val);
}
}
#line 342 "quotearg.c"
char *quotearg_n(unsigned int n , char const   *arg ) 
{ 
  char *tmp ;

  {
  {
#line 345
  tmp = quotearg_n_options((int )n, arg, (struct quoting_options  const  *)(& default_quoting_options));
  }
#line 345
  return (tmp);
}
}
#line 348 "quotearg.c"
char *quotearg(char const   *arg ) 
{ 
  char *tmp ;

  {
  {
#line 351
  tmp = quotearg_n(0U, arg);
  }
#line 351
  return (tmp);
}
}
#line 354 "quotearg.c"
char *quotearg_char(char const   *arg , char ch ) 
{ 
  struct quoting_options options ;
  char *tmp ;

  {
  {
#line 358
  options = default_quoting_options;
#line 359
  set_char_quoting(& options, ch, 1);
#line 360
  tmp = quotearg_n_options(0, arg, (struct quoting_options  const  *)(& options));
  }
#line 360
  return (tmp);
}
}
#line 363 "quotearg.c"
char *quotearg_colon(char const   *arg ) 
{ 
  char *tmp ;

  {
  {
#line 366
  tmp = quotearg_char(arg, (char )':');
  }
#line 366
  return (tmp);
}
}
#line 405 "/usr/include/unistd.h"
extern int usleep(__useconds_t __useconds ) ;
#line 63 "msleep.c"
void msleep(int milliseconds ) 
{ 


  {
#line 69
  if (milliseconds > 0) {
    {
#line 70
    usleep((__useconds_t )((long )milliseconds * 1000L));
    }
  }
#line 131
  return;
}
}
#line 66 "modechange.h"
struct mode_change *mode_compile(char const   *mode_string , unsigned int masked_ops ) ;
#line 67
struct mode_change *mode_create_from_ref(char const   *ref_file ) ;
#line 68
mode_t mode_adjust(mode_t oldmode , struct mode_change  const  *changes ) ;
#line 69
void mode_free(struct mode_change *changes ) ;
#line 215 "/usr/include/sys/stat.h"
__inline extern int stat(char const   * __restrict  __path , struct stat * __restrict  __statbuf )  __asm__("stat64")  ;
#line 219
__inline extern int fstat(int __fd , struct stat *__statbuf )  __asm__("fstat64")  ;
#line 239
__inline extern int lstat(char const   * __restrict  __path , struct stat * __restrict  __statbuf )  __asm__("lstat64")  ;
#line 272
extern __mode_t umask(__mode_t __mask ) ;
#line 287
__inline extern int mknod(char const   *__path , __mode_t __mode , __dev_t __dev ) ;
#line 326
extern int __fxstat(int __ver , int __fildes , struct stat *__stat_buf )  __asm__("__fxstat64")  ;
#line 329
extern int __xstat(int __ver , char const   *__filename , struct stat *__stat_buf )  __asm__("__xstat64")  ;
#line 331
extern int __lxstat(int __ver , char const   *__filename , struct stat *__stat_buf )  __asm__("__lxstat64")  ;
#line 350
extern int __xmknod(int __ver , char const   *__path , __mode_t __mode , __dev_t *__dev ) ;
#line 356
__inline extern int stat(char const   * __restrict  __path , struct stat * __restrict  __statbuf )  __asm__("stat64")  ;
#line 356 "/usr/include/sys/stat.h"
__inline extern int stat(char const   * __restrict  __path , struct stat * __restrict  __statbuf ) 
{ 
  int tmp ;

  {
  {
#line 359
  tmp = __xstat(3, (char const   *)__path, (struct stat *)__statbuf);
  }
#line 359
  return (tmp);
}
}
#line 363
__inline extern int lstat(char const   * __restrict  __path , struct stat * __restrict  __statbuf )  __asm__("lstat64")  ;
#line 363 "/usr/include/sys/stat.h"
__inline extern int lstat(char const   * __restrict  __path , struct stat * __restrict  __statbuf ) 
{ 
  int tmp ;

  {
  {
#line 366
  tmp = __lxstat(3, (char const   *)__path, (struct stat *)__statbuf);
  }
#line 366
  return (tmp);
}
}
#line 370
__inline extern int fstat(int __fd , struct stat *__statbuf )  __asm__("fstat64")  ;
#line 370 "/usr/include/sys/stat.h"
__inline extern int fstat(int __fd , struct stat *__statbuf ) 
{ 
  int tmp ;

  {
  {
#line 372
  tmp = __fxstat(3, __fd, __statbuf);
  }
#line 372
  return (tmp);
}
}
#line 376 "/usr/include/sys/stat.h"
__inline extern int mknod(char const   *__path , __mode_t __mode , __dev_t __dev ) 
{ 
  int tmp ;

  {
  {
#line 379
  tmp = __xmknod(1, __path, __mode, & __dev);
  }
#line 379
  return (tmp);
}
}
#line 110 "modechange.c"
static struct mode_change *make_node_op_equals(mode_t new_mode ) 
{ 
  struct mode_change *p ;
  void *tmp ;

  {
  {
#line 114
  tmp = malloc((size_t )sizeof(struct mode_change ));
#line 114
  p = (struct mode_change *)tmp;
  }
#line 115
  if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 116
    return (p);
  }
#line 117
  p->next = (struct mode_change *)((void *)0);
#line 118
  p->op = (char )'=';
#line 119
  p->flags = (char)0;
#line 120
  p->value = new_mode;
#line 121
  p->affected = (mode_t )((4032 | (448 >> 3)) | ((448 >> 3) >> 3));
#line 122
  return (p);
}
}
#line 128 "modechange.c"
static void mode_append_entry(struct mode_change **head , struct mode_change **tail ,
                              struct mode_change *e ) 
{ 
  struct mode_change *tmp ;

  {
#line 133
  if ((unsigned long )*head == (unsigned long )((void *)0)) {
#line 134
    tmp = e;
#line 134
    *tail = tmp;
#line 134
    *head = tmp;
  } else {
#line 137
    (*tail)->next = e;
#line 138
    *tail = e;
  }
#line 140
  return;
}
}
#line 155 "modechange.c"
struct mode_change *mode_compile(char const   *mode_string , unsigned int masked_ops ) 
{ 
  struct mode_change *head ;
  struct mode_change *tail ;
  unsigned long mode_value ;
  char *string_end ;
  mode_t umask_value ;
  struct mode_change *p ;
  strtol_error tmp ;
  mode_t affected_bits ;
  mode_t affected_masked ;
  unsigned int ops_to_mask ;
  int who_specified_p ;
  struct mode_change *change ;
  void *tmp___0 ;
  struct mode_change *p___0 ;
  struct mode_change *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
  {
#line 164
  head = (struct mode_change *)((void *)0);
#line 169
  tmp = xstrtoul(mode_string, & string_end, 8, & mode_value, "");
  }
#line 169
  if ((unsigned int )tmp == 0U) {
#line 172
    if (mode_value > (unsigned long )((4032 | (448 >> 3)) | ((448 >> 3) >> 3))) {
#line 173
      return ((struct mode_change *)0);
    }
    {
#line 174
    p = make_node_op_equals((mode_t )mode_value);
    }
#line 175
    if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 176
      return ((struct mode_change *)1);
    }
    {
#line 177
    mode_append_entry(& head, & tail, p);
    }
#line 178
    return (head);
  }
  {
#line 181
  umask_value = umask((__mode_t )0);
#line 182
  umask(umask_value);
#line 183
  mode_string --;
  }
  {
#line 186
  while (1) {
    while_continue: /* CIL Label */ ;
#line 189
    affected_bits = (mode_t )0;
#line 193
    ops_to_mask = 0U;
#line 197
    affected_bits = (mode_t )0;
#line 198
    ops_to_mask = 0U;
#line 200
    mode_string ++;
    {
#line 200
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 203
      if ((int const   )*mode_string == 117) {
#line 203
        goto case_117;
      }
#line 206
      if ((int const   )*mode_string == 103) {
#line 206
        goto case_103;
      }
#line 209
      if ((int const   )*mode_string == 111) {
#line 209
        goto case_111;
      }
#line 212
      if ((int const   )*mode_string == 97) {
#line 212
        goto case_97;
      }
#line 215
      goto switch_default;
      case_117: /* CIL Label */ 
#line 204
      affected_bits |= 2496U;
#line 205
      goto switch_break;
      case_103: /* CIL Label */ 
#line 207
      affected_bits |= (unsigned int )(1024 | (448 >> 3));
#line 208
      goto switch_break;
      case_111: /* CIL Label */ 
#line 210
      affected_bits |= (unsigned int )(512 | ((448 >> 3) >> 3));
#line 211
      goto switch_break;
      case_97: /* CIL Label */ 
#line 213
      affected_bits |= (unsigned int )((4032 | (448 >> 3)) | ((448 >> 3) >> 3));
#line 214
      goto switch_break;
      switch_default: /* CIL Label */ 
#line 216
      goto no_more_affected;
      switch_break: /* CIL Label */ ;
      }
#line 200
      mode_string ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    no_more_affected: 
#line 222
    if (affected_bits) {
#line 223
      who_specified_p = 1;
    } else {
#line 226
      who_specified_p = 0;
#line 227
      affected_bits = (mode_t )((4032 | (448 >> 3)) | ((448 >> 3) >> 3));
#line 228
      ops_to_mask = masked_ops;
    }
    {
#line 231
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 231
      if (! ((int const   )*mode_string == 61)) {
#line 231
        if (! ((int const   )*mode_string == 43)) {
#line 231
          if (! ((int const   )*mode_string == 45)) {
#line 231
            goto while_break___1;
          }
        }
      }
      {
#line 233
      tmp___0 = malloc((size_t )sizeof(struct mode_change ));
#line 233
      change = (struct mode_change *)tmp___0;
      }
#line 234
      if ((unsigned long )change == (unsigned long )((void *)0)) {
        {
#line 236
        mode_free(head);
        }
#line 237
        return ((struct mode_change *)1);
      }
#line 240
      change->next = (struct mode_change *)((void *)0);
#line 241
      change->op = (char )*mode_string;
#line 242
      affected_masked = affected_bits;
#line 246
      if (! who_specified_p) {
#line 246
        if ((int const   )*mode_string == 61) {
#line 246
          tmp___2 = 1;
        } else {
#line 246
          tmp___2 = 0;
        }
#line 246
        if (ops_to_mask & (unsigned int )tmp___2) {
          {
#line 249
          tmp___1 = make_node_op_equals((mode_t )0);
#line 249
          p___0 = tmp___1;
          }
#line 250
          if ((unsigned long )p___0 == (unsigned long )((void *)0)) {
#line 251
            return ((struct mode_change *)1);
          }
          {
#line 252
          mode_append_entry(& head, & tail, p___0);
          }
        }
      }
#line 255
      if ((int const   )*mode_string == 61) {
#line 255
        tmp___4 = 1;
      } else {
#line 255
        if ((int const   )*mode_string == 43) {
#line 255
          tmp___3 = 2;
        } else {
#line 255
          tmp___3 = 4;
        }
#line 255
        tmp___4 = tmp___3;
      }
#line 255
      if (ops_to_mask & (unsigned int )tmp___4) {
#line 258
        affected_masked &= ~ umask_value;
      }
      {
#line 259
      change->affected = affected_masked;
#line 260
      change->value = (mode_t )0;
#line 261
      change->flags = (char)0;
#line 265
      mode_append_entry(& head, & tail, change);
#line 268
      mode_string ++;
      }
      {
#line 268
      while (1) {
        while_continue___2: /* CIL Label */ ;
        {
#line 271
        if ((int const   )*mode_string == 114) {
#line 271
          goto case_114;
        }
#line 275
        if ((int const   )*mode_string == 119) {
#line 275
          goto case_119;
        }
#line 279
        if ((int const   )*mode_string == 88) {
#line 279
          goto case_88;
        }
#line 282
        if ((int const   )*mode_string == 120) {
#line 282
          goto case_120;
        }
#line 286
        if ((int const   )*mode_string == 115) {
#line 286
          goto case_115;
        }
#line 290
        if ((int const   )*mode_string == 116) {
#line 290
          goto case_116;
        }
#line 294
        if ((int const   )*mode_string == 117) {
#line 294
          goto case_117___0;
        }
#line 302
        if ((int const   )*mode_string == 103) {
#line 302
          goto case_103___0;
        }
#line 310
        if ((int const   )*mode_string == 111) {
#line 310
          goto case_111___0;
        }
#line 318
        goto switch_default___0;
        case_114: /* CIL Label */ 
#line 272
        change->value |= (unsigned int )((256 | (256 >> 3)) | ((256 >> 3) >> 3)) & affected_masked;
#line 274
        goto switch_break___0;
        case_119: /* CIL Label */ 
#line 276
        change->value |= (unsigned int )((128 | (128 >> 3)) | ((128 >> 3) >> 3)) & affected_masked;
#line 278
        goto switch_break___0;
        case_88: /* CIL Label */ 
#line 280
        change->flags = (char )((int )change->flags | 1);
        case_120: /* CIL Label */ 
#line 283
        change->value |= (unsigned int )((64 | (64 >> 3)) | ((64 >> 3) >> 3)) & affected_masked;
#line 285
        goto switch_break___0;
        case_115: /* CIL Label */ 
#line 288
        change->value |= 3072U & affected_masked;
#line 289
        goto switch_break___0;
        case_116: /* CIL Label */ 
#line 292
        change->value |= 512U & affected_masked;
#line 293
        goto switch_break___0;
        case_117___0: /* CIL Label */ 
#line 297
        if (change->value) {
#line 298
          goto invalid;
        }
#line 299
        change->value = (mode_t )448;
#line 300
        change->flags = (char )((int )change->flags | 2);
#line 301
        goto switch_break___0;
        case_103___0: /* CIL Label */ 
#line 305
        if (change->value) {
#line 306
          goto invalid;
        }
#line 307
        change->value = (mode_t )(448 >> 3);
#line 308
        change->flags = (char )((int )change->flags | 2);
#line 309
        goto switch_break___0;
        case_111___0: /* CIL Label */ 
#line 313
        if (change->value) {
#line 314
          goto invalid;
        }
#line 315
        change->value = (mode_t )((448 >> 3) >> 3);
#line 316
        change->flags = (char )((int )change->flags | 2);
#line 317
        goto switch_break___0;
        switch_default___0: /* CIL Label */ 
#line 319
        goto no_more_values;
        switch_break___0: /* CIL Label */ ;
        }
#line 268
        mode_string ++;
      }
      while_break___2: /* CIL Label */ ;
      }
      no_more_values: ;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 186
    if (! ((int const   )*mode_string == 44)) {
#line 186
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 324
  if ((int const   )*mode_string == 0) {
#line 325
    return (head);
  }
  invalid: 
  {
#line 327
  mode_free(head);
  }
#line 328
  return ((struct mode_change *)0);
}
}
#line 334 "modechange.c"
struct mode_change *mode_create_from_ref(char const   *ref_file ) 
{ 
  struct mode_change *change ;
  struct stat ref_stats ;
  int tmp ;
  void *tmp___0 ;

  {
  {
#line 340
  tmp = stat((char const   */* __restrict  */)ref_file, (struct stat */* __restrict  */)(& ref_stats));
  }
#line 340
  if (tmp) {
#line 341
    return ((struct mode_change *)2);
  }
  {
#line 343
  tmp___0 = malloc((size_t )sizeof(struct mode_change ));
#line 343
  change = (struct mode_change *)tmp___0;
  }
#line 345
  if ((unsigned long )change == (unsigned long )((void *)0)) {
#line 346
    return ((struct mode_change *)1);
  }
#line 348
  change->op = (char )'=';
#line 349
  change->flags = (char)0;
#line 350
  change->affected = (mode_t )((4032 | (448 >> 3)) | ((448 >> 3) >> 3));
#line 351
  change->value = ref_stats.st_mode;
#line 352
  change->next = (struct mode_change *)((void *)0);
#line 354
  return (change);
}
}
#line 362 "modechange.c"
mode_t mode_adjust(mode_t oldmode , struct mode_change  const  *changes ) 
{ 
  mode_t newmode ;
  mode_t value ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;

  {
#line 368
  newmode = oldmode & (unsigned int )((4032 | (448 >> 3)) | ((448 >> 3) >> 3));
  {
#line 370
  while (1) {
    while_continue: /* CIL Label */ ;
#line 370
    if (! changes) {
#line 370
      goto while_break;
    }
#line 372
    if ((int const   )changes->flags & 2) {
#line 376
      value = newmode & (unsigned int )changes->value;
#line 378
      if (changes->value & 448U) {
#line 380
        if (value & 256U) {
#line 380
          tmp = (256 >> 3) | ((256 >> 3) >> 3);
        } else {
#line 380
          tmp = 0;
        }
#line 380
        if (value & 128U) {
#line 380
          tmp___0 = (128 >> 3) | ((256 >> 3) >> 3);
        } else {
#line 380
          tmp___0 = 0;
        }
#line 380
        if (value & 64U) {
#line 380
          tmp___1 = (64 >> 3) | ((64 >> 3) >> 3);
        } else {
#line 380
          tmp___1 = 0;
        }
#line 380
        value |= (unsigned int )((tmp | tmp___0) | tmp___1);
      } else
#line 383
      if (changes->value & (unsigned int const   )(448 >> 3)) {
#line 385
        if (value & (unsigned int )(256 >> 3)) {
#line 385
          tmp___2 = 256 | ((256 >> 3) >> 3);
        } else {
#line 385
          tmp___2 = 0;
        }
#line 385
        if (value & (unsigned int )(128 >> 3)) {
#line 385
          tmp___3 = 128 | ((256 >> 3) >> 3);
        } else {
#line 385
          tmp___3 = 0;
        }
#line 385
        if (value & (unsigned int )(64 >> 3)) {
#line 385
          tmp___4 = 64 | ((64 >> 3) >> 3);
        } else {
#line 385
          tmp___4 = 0;
        }
#line 385
        value |= (unsigned int )((tmp___2 | tmp___3) | tmp___4);
      } else {
#line 390
        if (value & (unsigned int )((256 >> 3) >> 3)) {
#line 390
          tmp___5 = 256 | (256 >> 3);
        } else {
#line 390
          tmp___5 = 0;
        }
#line 390
        if (value & (unsigned int )((128 >> 3) >> 3)) {
#line 390
          tmp___6 = 128 | (256 >> 3);
        } else {
#line 390
          tmp___6 = 0;
        }
#line 390
        if (value & (unsigned int )((64 >> 3) >> 3)) {
#line 390
          tmp___7 = 64 | (64 >> 3);
        } else {
#line 390
          tmp___7 = 0;
        }
#line 390
        value |= (unsigned int )((tmp___5 | tmp___6) | tmp___7);
      }
#line 399
      value &= (unsigned int )changes->affected;
    } else {
#line 403
      value = (mode_t )changes->value;
#line 406
      if ((int const   )changes->flags & 1) {
#line 406
        if (! ((oldmode & 61440U) == 16384U)) {
#line 406
          if ((newmode & (unsigned int )((64 | (64 >> 3)) | ((64 >> 3) >> 3))) == 0U) {
#line 410
            value &= (unsigned int )(~ ((64 | (64 >> 3)) | ((64 >> 3) >> 3)));
          }
        }
      }
    }
    {
#line 415
    if ((int const   )changes->op == 61) {
#line 415
      goto case_61;
    }
#line 420
    if ((int const   )changes->op == 43) {
#line 420
      goto case_43;
    }
#line 423
    if ((int const   )changes->op == 45) {
#line 423
      goto case_45;
    }
#line 413
    goto switch_break;
    case_61: /* CIL Label */ 
#line 418
    newmode = (newmode & (unsigned int )(~ changes->affected)) | value;
#line 419
    goto switch_break;
    case_43: /* CIL Label */ 
#line 421
    newmode |= value;
#line 422
    goto switch_break;
    case_45: /* CIL Label */ 
#line 424
    newmode &= ~ value;
#line 425
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 370
    changes = (struct mode_change  const  *)changes->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 428
  return (newmode);
}
}
#line 434 "modechange.c"
void mode_free(struct mode_change *changes ) 
{ 
  register struct mode_change *next ;

  {
  {
#line 439
  while (1) {
    while_continue: /* CIL Label */ ;
#line 439
    if (! changes) {
#line 439
      goto while_break;
    }
    {
#line 441
    next = changes->next;
#line 442
    free((void *)changes);
#line 443
    changes = next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 445
  return;
}
}
/* compiler builtin: 
   void *__builtin_memcpy(void * , void const   * , unsigned long  ) ;  */
/* compiler builtin: 
   void *__builtin_alloca(unsigned long  ) ;  */
#line 116 "/usr/include/ctype.h"
extern int tolower(int __c ) ;
#line 96 "/usr/include/string.h"
extern int strcmp(char const   *__s1 , char const   *__s2 )  __attribute__((__pure__)) ;
#line 99
extern int strncmp(char const   *__s1 , char const   *__s2 , size_t __n )  __attribute__((__pure__)) ;
#line 122 "getdate.y"
static int gd_lex(void) ;
#line 123
static int gd_error(char *s  __attribute__((__unused__)) ) ;
#line 154 "getdate.y"
static char const   *yyInput  ;
#line 155 "getdate.y"
static int yyDayOrdinal  ;
#line 156 "getdate.y"
static int yyDayNumber  ;
#line 157 "getdate.y"
static int yyHaveDate  ;
#line 158 "getdate.y"
static int yyHaveDay  ;
#line 159 "getdate.y"
static int yyHaveRel  ;
#line 160 "getdate.y"
static int yyHaveTime  ;
#line 161 "getdate.y"
static int yyHaveZone  ;
#line 162 "getdate.y"
static int yyTimezone  ;
#line 163 "getdate.y"
static int yyDay  ;
#line 164 "getdate.y"
static int yyHour  ;
#line 165 "getdate.y"
static int yyMinutes  ;
#line 166 "getdate.y"
static int yyMonth  ;
#line 167 "getdate.y"
static int yySeconds  ;
#line 168 "getdate.y"
static int yyYear  ;
#line 169 "getdate.y"
static MERIDIAN yyMeridian  ;
#line 170 "getdate.y"
static int yyRelDay  ;
#line 171 "getdate.y"
static int yyRelHour  ;
#line 172 "getdate.y"
static int yyRelMinutes  ;
#line 173 "getdate.y"
static int yyRelMonth  ;
#line 174 "getdate.y"
static int yyRelSeconds  ;
#line 175 "getdate.y"
static int yyRelYear  ;
#line 202 "getdate.y"
static char const   yytranslate[273]  = 
#line 202
  {      (char const   )0,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )20,      (char const   )2,      (char const   )2,      (char const   )21, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )19,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )1,      (char const   )3,      (char const   )4,      (char const   )5, 
        (char const   )6,      (char const   )7,      (char const   )8,      (char const   )9, 
        (char const   )10,      (char const   )11,      (char const   )12,      (char const   )13, 
        (char const   )14,      (char const   )15,      (char const   )16,      (char const   )17, 
        (char const   )18};
#line 283 "getdate.y"
static short const   gd_r1[51]  = 
#line 283
  {      (short const   )0,      (short const   )22,      (short const   )22,      (short const   )23, 
        (short const   )23,      (short const   )23,      (short const   )23,      (short const   )23, 
        (short const   )23,      (short const   )24,      (short const   )24,      (short const   )24, 
        (short const   )24,      (short const   )24,      (short const   )25,      (short const   )25, 
        (short const   )25,      (short const   )26,      (short const   )26,      (short const   )26, 
        (short const   )27,      (short const   )27,      (short const   )27,      (short const   )27, 
        (short const   )27,      (short const   )27,      (short const   )27,      (short const   )27, 
        (short const   )28,      (short const   )28,      (short const   )29,      (short const   )29, 
        (short const   )29,      (short const   )29,      (short const   )29,      (short const   )29, 
        (short const   )29,      (short const   )29,      (short const   )29,      (short const   )29, 
        (short const   )29,      (short const   )29,      (short const   )29,      (short const   )29, 
        (short const   )29,      (short const   )29,      (short const   )29,      (short const   )29, 
        (short const   )30,      (short const   )31,      (short const   )31};
#line 291 "getdate.y"
static short const   gd_r2[51]  = 
#line 291
  {      (short const   )0,      (short const   )0,      (short const   )2,      (short const   )1, 
        (short const   )1,      (short const   )1,      (short const   )1,      (short const   )1, 
        (short const   )1,      (short const   )2,      (short const   )4,      (short const   )4, 
        (short const   )6,      (short const   )6,      (short const   )1,      (short const   )1, 
        (short const   )2,      (short const   )1,      (short const   )2,      (short const   )2, 
        (short const   )3,      (short const   )5,      (short const   )3,      (short const   )3, 
        (short const   )2,      (short const   )4,      (short const   )2,      (short const   )3, 
        (short const   )2,      (short const   )1,      (short const   )2,      (short const   )2, 
        (short const   )1,      (short const   )2,      (short const   )2,      (short const   )1, 
        (short const   )2,      (short const   )2,      (short const   )1,      (short const   )2, 
        (short const   )2,      (short const   )1,      (short const   )2,      (short const   )2, 
        (short const   )1,      (short const   )2,      (short const   )2,      (short const   )1, 
        (short const   )1,      (short const   )0,      (short const   )1};
#line 299 "getdate.y"
static short const   yydefact[62]  = 
#line 299
  {      (short const   )1,      (short const   )0,      (short const   )17,      (short const   )38, 
        (short const   )15,      (short const   )41,      (short const   )44,      (short const   )0, 
        (short const   )35,      (short const   )47,      (short const   )0,      (short const   )48, 
        (short const   )32,      (short const   )14,      (short const   )2,      (short const   )3, 
        (short const   )4,      (short const   )6,      (short const   )5,      (short const   )7, 
        (short const   )29,      (short const   )8,      (short const   )18,      (short const   )24, 
        (short const   )37,      (short const   )40,      (short const   )43,      (short const   )34, 
        (short const   )46,      (short const   )31,      (short const   )19,      (short const   )36, 
        (short const   )39,      (short const   )9,      (short const   )42,      (short const   )26, 
        (short const   )33,      (short const   )45,      (short const   )0,      (short const   )30, 
        (short const   )0,      (short const   )0,      (short const   )16,      (short const   )28, 
        (short const   )0,      (short const   )23,      (short const   )27,      (short const   )22, 
        (short const   )49,      (short const   )20,      (short const   )25,      (short const   )50, 
        (short const   )11,      (short const   )0,      (short const   )10,      (short const   )0, 
        (short const   )49,      (short const   )21,      (short const   )13,      (short const   )12, 
        (short const   )0,      (short const   )0};
#line 309 "getdate.y"
static short const   yydefgoto[10]  = 
#line 309
  {      (short const   )1,      (short const   )14,      (short const   )15,      (short const   )16, 
        (short const   )17,      (short const   )18,      (short const   )19,      (short const   )20, 
        (short const   )21,      (short const   )54};
#line 313 "getdate.y"
static short const   gd_pact[62]  = 
#line 313
  {      (short const   )-32768,      (short const   )0,      (short const   )-19,      (short const   )-32768, 
        (short const   )-32768,      (short const   )-32768,      (short const   )-32768,      (short const   )-13, 
        (short const   )-32768,      (short const   )-32768,      (short const   )30,      (short const   )15, 
        (short const   )-32768,      (short const   )14,      (short const   )-32768,      (short const   )-32768, 
        (short const   )-32768,      (short const   )-32768,      (short const   )-32768,      (short const   )-32768, 
        (short const   )19,      (short const   )-32768,      (short const   )-32768,      (short const   )4, 
        (short const   )-32768,      (short const   )-32768,      (short const   )-32768,      (short const   )-32768, 
        (short const   )-32768,      (short const   )-32768,      (short const   )-32768,      (short const   )-32768, 
        (short const   )-32768,      (short const   )-32768,      (short const   )-32768,      (short const   )-6, 
        (short const   )-32768,      (short const   )-32768,      (short const   )16,      (short const   )-32768, 
        (short const   )17,      (short const   )23,      (short const   )-32768,      (short const   )-32768, 
        (short const   )24,      (short const   )-32768,      (short const   )-32768,      (short const   )-32768, 
        (short const   )27,      (short const   )28,      (short const   )-32768,      (short const   )-32768, 
        (short const   )-32768,      (short const   )29,      (short const   )-32768,      (short const   )32, 
        (short const   )-8,      (short const   )-32768,      (short const   )-32768,      (short const   )-32768, 
        (short const   )50,      (short const   )-32768};
#line 323 "getdate.y"
static short const   yypgoto[10]  = 
#line 323
  {      (short const   )-32768,      (short const   )-32768,      (short const   )-32768,      (short const   )-32768, 
        (short const   )-32768,      (short const   )-32768,      (short const   )-32768,      (short const   )-32768, 
        (short const   )-32768,      (short const   )-5};
#line 331 "getdate.y"
static short const   gd_yytable[52]  = 
#line 331
  {      (short const   )60,      (short const   )22,      (short const   )51,      (short const   )23, 
        (short const   )2,      (short const   )3,      (short const   )4,      (short const   )58, 
        (short const   )5,      (short const   )45,      (short const   )46,      (short const   )6, 
        (short const   )7,      (short const   )8,      (short const   )9,      (short const   )10, 
        (short const   )11,      (short const   )12,      (short const   )13,      (short const   )30, 
        (short const   )31,      (short const   )42,      (short const   )43,      (short const   )32, 
        (short const   )44,      (short const   )33,      (short const   )34,      (short const   )35, 
        (short const   )36,      (short const   )37,      (short const   )38,      (short const   )47, 
        (short const   )39,      (short const   )48,      (short const   )40,      (short const   )24, 
        (short const   )41,      (short const   )51,      (short const   )25,      (short const   )49, 
        (short const   )50,      (short const   )26,      (short const   )52,      (short const   )27, 
        (short const   )28,      (short const   )56,      (short const   )53,      (short const   )29, 
        (short const   )57,      (short const   )55,      (short const   )61,      (short const   )59};
#line 340 "getdate.y"
static short const   gd_yycheck[52]  = 
#line 340
  {      (short const   )0,      (short const   )20,      (short const   )10,      (short const   )16, 
        (short const   )4,      (short const   )5,      (short const   )6,      (short const   )15, 
        (short const   )8,      (short const   )15,      (short const   )16,      (short const   )11, 
        (short const   )12,      (short const   )13,      (short const   )14,      (short const   )15, 
        (short const   )16,      (short const   )17,      (short const   )18,      (short const   )4, 
        (short const   )5,      (short const   )7,      (short const   )3,      (short const   )8, 
        (short const   )20,      (short const   )10,      (short const   )11,      (short const   )12, 
        (short const   )13,      (short const   )14,      (short const   )15,      (short const   )15, 
        (short const   )17,      (short const   )16,      (short const   )19,      (short const   )5, 
        (short const   )21,      (short const   )10,      (short const   )8,      (short const   )16, 
        (short const   )16,      (short const   )11,      (short const   )15,      (short const   )13, 
        (short const   )14,      (short const   )16,      (short const   )19,      (short const   )17, 
        (short const   )16,      (short const   )21,      (short const   )0,      (short const   )56};
#line 137 "/opt/reb/share/bison.simple"
int gd_char  ;
#line 138 "/opt/reb/share/bison.simple"
YYSTYPE gd_lval  ;
#line 146 "/opt/reb/share/bison.simple"
int gd_nerrs  ;
#line 242
int gd_parse(void) ;
#line 246 "/opt/reb/share/bison.simple"
int gd_parse(void) 
{ 
  register int gd_state ;
  register int yyn ;
  register short *yyssp ;
  register YYSTYPE *yyvsp ;
  int yyerrstatus ;
  int yychar1 ;
  short yyssa[200] ;
  YYSTYPE yyvsa[200] ;
  short *yyss ;
  YYSTYPE *yyvs ;
  int yystacksize ;
  int yyfree_stacks ;
  YYSTYPE gd_val ;
  int gd_yylen ;
  YYSTYPE *yyvs1 ;
  short *yyss1 ;
  int size ;
  void *tmp ;
  void *tmp___0 ;

  {
#line 255
  yychar1 = 0;
#line 260
  yyss = yyssa;
#line 261
  yyvs = yyvsa;
#line 273
  yystacksize = 200;
#line 274
  yyfree_stacks = 0;
#line 296
  gd_state = 0;
#line 297
  yyerrstatus = 0;
#line 298
  gd_nerrs = 0;
#line 299
  gd_char = -2;
#line 306
  yyssp = yyss - 1;
#line 307
  yyvsp = yyvs;
  yynewstate: 
#line 317
  yyssp ++;
#line 317
  *yyssp = (short )gd_state;
#line 319
  if ((unsigned long )yyssp >= (unsigned long )((yyss + yystacksize) - 1)) {
#line 323
    yyvs1 = yyvs;
#line 324
    yyss1 = yyss;
#line 330
    size = (int )((yyssp - yyss) + 1L);
#line 356
    if (yystacksize >= 10000) {
      {
#line 358
      gd_error("parser stack overflow");
      }
#line 359
      if (yyfree_stacks) {
        {
#line 361
        free((void *)yyss);
#line 362
        free((void *)yyvs);
        }
      }
#line 367
      return (2);
    }
#line 369
    yystacksize *= 2;
#line 370
    if (yystacksize > 10000) {
#line 371
      yystacksize = 10000;
    }
    {
#line 375
    tmp = __builtin_alloca((unsigned long )yystacksize * sizeof(*yyssp));
#line 375
    yyss = (short *)tmp;
#line 376
    __builtin_memcpy((void *)((char *)yyss), (void const   *)((char *)yyss1), (unsigned long )((unsigned int )size * (unsigned int )sizeof(*yyssp)));
#line 378
    tmp___0 = __builtin_alloca((unsigned long )yystacksize * sizeof(*yyvsp));
#line 378
    yyvs = (YYSTYPE *)tmp___0;
#line 379
    __builtin_memcpy((void *)((char *)yyvs), (void const   *)((char *)yyvs1), (unsigned long )((unsigned int )size * (unsigned int )sizeof(*yyvsp)));
#line 388
    yyssp = (yyss + size) - 1;
#line 389
    yyvsp = (yyvs + size) - 1;
    }
#line 399
    if ((unsigned long )yyssp >= (unsigned long )((yyss + yystacksize) - 1)) {
#line 400
      goto yyabortlab;
    }
  }
#line 408
  goto yybackup;
  yybackup: 
#line 417
  yyn = (int )gd_pact[gd_state];
#line 418
  if (yyn == -32768) {
#line 419
    goto yydefault;
  }
#line 426
  if (gd_char == -2) {
    {
#line 432
    gd_char = gd_lex();
    }
  }
#line 437
  if (gd_char <= 0) {
#line 439
    yychar1 = 0;
#line 440
    gd_char = 0;
  } else
#line 449
  if ((unsigned int )gd_char <= 272U) {
#line 449
    yychar1 = (int )yytranslate[gd_char];
  } else {
#line 449
    yychar1 = 32;
  }
#line 465
  yyn += yychar1;
#line 466
  if (yyn < 0) {
#line 467
    goto yydefault;
  } else
#line 466
  if (yyn > 51) {
#line 467
    goto yydefault;
  } else
#line 466
  if ((int const   )gd_yycheck[yyn] != (int const   )yychar1) {
#line 467
    goto yydefault;
  }
#line 469
  yyn = (int )gd_yytable[yyn];
#line 478
  if (yyn < 0) {
#line 480
    if (yyn == -32768) {
#line 481
      goto yyerrlab;
    }
#line 482
    yyn = - yyn;
#line 483
    goto yyreduce;
  } else
#line 485
  if (yyn == 0) {
#line 486
    goto yyerrlab;
  }
#line 488
  if (yyn == 61) {
#line 489
    goto yyacceptlab;
  }
#line 499
  if (gd_char != 0) {
#line 500
    gd_char = -2;
  }
#line 502
  yyvsp ++;
#line 502
  *yyvsp = gd_lval;
#line 508
  if (yyerrstatus) {
#line 508
    yyerrstatus --;
  }
#line 510
  gd_state = yyn;
#line 511
  goto yynewstate;
  yydefault: 
#line 516
  yyn = (int )yydefact[gd_state];
#line 517
  if (yyn == 0) {
#line 518
    goto yyerrlab;
  }
  yyreduce: 
#line 522
  gd_yylen = (int )gd_r2[yyn];
#line 523
  if (gd_yylen > 0) {
#line 524
    gd_val = *(yyvsp + (1 - gd_yylen));
  }
  {
#line 544
  if (yyn == 3) {
#line 544
    goto case_3;
  }
#line 206
  if (yyn == 4) {
#line 206 "getdate.y"
    goto case_4;
  }
#line 209
  if (yyn == 5) {
#line 209
    goto case_5;
  }
#line 212
  if (yyn == 6) {
#line 212
    goto case_6;
  }
#line 215
  if (yyn == 7) {
#line 215
    goto case_7;
  }
#line 218
  if (yyn == 9) {
#line 218
    goto case_9;
  }
#line 227
  if (yyn == 10) {
#line 227
    goto case_10;
  }
#line 233
  if (yyn == 11) {
#line 233
    goto case_11;
  }
#line 242
  if (yyn == 12) {
#line 242
    goto case_12;
  }
#line 248
  if (yyn == 13) {
#line 248
    goto case_13;
  }
#line 258
  if (yyn == 14) {
#line 258
    goto case_14;
  }
#line 263
  if (yyn == 15) {
#line 263
    goto case_15;
  }
#line 266
  if (yyn == 16) {
#line 266
    goto case_16;
  }
#line 270
  if (yyn == 17) {
#line 270
    goto case_17;
  }
#line 276
  if (yyn == 18) {
#line 276
    goto case_18;
  }
#line 280
  if (yyn == 19) {
#line 280
    goto case_19;
  }
#line 284
  if (yyn == 20) {
#line 284
    goto case_20;
  }
#line 290
  if (yyn == 21) {
#line 290
    goto case_21;
  }
#line 308
  if (yyn == 22) {
#line 308
    goto case_22;
  }
#line 314
  if (yyn == 23) {
#line 314
    goto case_23;
  }
#line 320
  if (yyn == 24) {
#line 320
    goto case_24;
  }
#line 324
  if (yyn == 25) {
#line 324
    goto case_25;
  }
#line 329
  if (yyn == 26) {
#line 329
    goto case_26;
  }
#line 333
  if (yyn == 27) {
#line 333
    goto case_27;
  }
#line 338
  if (yyn == 28) {
#line 338
    goto case_28;
  }
#line 348
  if (yyn == 30) {
#line 348
    goto case_30;
  }
#line 354
  if (yyn == 31) {
#line 354
    goto case_31;
  }
#line 357
  if (yyn == 32) {
#line 357
    goto case_32;
  }
#line 360
  if (yyn == 33) {
#line 360
    goto case_33;
  }
#line 363
  if (yyn == 34) {
#line 363
    goto case_34;
  }
#line 366
  if (yyn == 35) {
#line 366
    goto case_35;
  }
#line 369
  if (yyn == 36) {
#line 369
    goto case_36;
  }
#line 372
  if (yyn == 37) {
#line 372
    goto case_37;
  }
#line 375
  if (yyn == 38) {
#line 375
    goto case_38;
  }
#line 378
  if (yyn == 39) {
#line 378
    goto case_39;
  }
#line 381
  if (yyn == 40) {
#line 381
    goto case_40;
  }
#line 384
  if (yyn == 41) {
#line 384
    goto case_41;
  }
#line 387
  if (yyn == 42) {
#line 387
    goto case_42;
  }
#line 390
  if (yyn == 43) {
#line 390
    goto case_43;
  }
#line 393
  if (yyn == 44) {
#line 393
    goto case_44;
  }
#line 396
  if (yyn == 45) {
#line 396
    goto case_45;
  }
#line 399
  if (yyn == 46) {
#line 399
    goto case_46;
  }
#line 402
  if (yyn == 47) {
#line 402
    goto case_47;
  }
#line 405
  if (yyn == 48) {
#line 405
    goto case_48;
  }
#line 438
  if (yyn == 49) {
#line 438
    goto case_49;
  }
#line 444
  if (yyn == 50) {
#line 444
    goto case_50;
  }
#line 542 "/opt/reb/share/bison.simple"
  goto switch_break;
  case_3: /* CIL Label */ 
#line 203 "getdate.y"
  yyHaveTime ++;
#line 205
  goto switch_break;
  case_4: /* CIL Label */ 
#line 206
  yyHaveZone ++;
#line 208
  goto switch_break;
  case_5: /* CIL Label */ 
#line 209
  yyHaveDate ++;
#line 211
  goto switch_break;
  case_6: /* CIL Label */ 
#line 212
  yyHaveDay ++;
#line 214
  goto switch_break;
  case_7: /* CIL Label */ 
#line 215
  yyHaveRel ++;
#line 217
  goto switch_break;
  case_9: /* CIL Label */ 
#line 221
  yyHour = (yyvsp + -1)->Number;
#line 222
  yyMinutes = 0;
#line 223
  yySeconds = 0;
#line 224
  yyMeridian = (yyvsp + 0)->Meridian;
#line 226
  goto switch_break;
  case_10: /* CIL Label */ 
#line 227
  yyHour = (yyvsp + -3)->Number;
#line 228
  yyMinutes = (yyvsp + -1)->Number;
#line 229
  yySeconds = 0;
#line 230
  yyMeridian = (yyvsp + 0)->Meridian;
#line 232
  goto switch_break;
  case_11: /* CIL Label */ 
#line 233
  yyHour = (yyvsp + -3)->Number;
#line 234
  yyMinutes = (yyvsp + -1)->Number;
#line 235
  yyMeridian = (MERIDIAN )2;
#line 236
  yyHaveZone ++;
#line 237
  if ((yyvsp + 0)->Number < 0) {
#line 237
    yyTimezone = - (yyvsp + 0)->Number % 100 + (- (yyvsp + 0)->Number / 100) * 60;
  } else {
#line 237
    yyTimezone = - ((yyvsp + 0)->Number % 100 + ((yyvsp + 0)->Number / 100) * 60);
  }
#line 241
  goto switch_break;
  case_12: /* CIL Label */ 
#line 242
  yyHour = (yyvsp + -5)->Number;
#line 243
  yyMinutes = (yyvsp + -3)->Number;
#line 244
  yySeconds = (yyvsp + -1)->Number;
#line 245
  yyMeridian = (yyvsp + 0)->Meridian;
#line 247
  goto switch_break;
  case_13: /* CIL Label */ 
#line 248
  yyHour = (yyvsp + -5)->Number;
#line 249
  yyMinutes = (yyvsp + -3)->Number;
#line 250
  yySeconds = (yyvsp + -1)->Number;
#line 251
  yyMeridian = (MERIDIAN )2;
#line 252
  yyHaveZone ++;
#line 253
  if ((yyvsp + 0)->Number < 0) {
#line 253
    yyTimezone = - (yyvsp + 0)->Number % 100 + (- (yyvsp + 0)->Number / 100) * 60;
  } else {
#line 253
    yyTimezone = - ((yyvsp + 0)->Number % 100 + ((yyvsp + 0)->Number / 100) * 60);
  }
#line 257
  goto switch_break;
  case_14: /* CIL Label */ 
#line 260
  yyTimezone = (yyvsp + 0)->Number;
#line 262
  goto switch_break;
  case_15: /* CIL Label */ 
#line 263
  yyTimezone = (yyvsp + 0)->Number - 60;
#line 265
  goto switch_break;
  case_16: /* CIL Label */ 
#line 267
  yyTimezone = (yyvsp + -1)->Number - 60;
#line 269
  goto switch_break;
  case_17: /* CIL Label */ 
#line 272
  yyDayOrdinal = 1;
#line 273
  yyDayNumber = (yyvsp + 0)->Number;
#line 275
  goto switch_break;
  case_18: /* CIL Label */ 
#line 276
  yyDayOrdinal = 1;
#line 277
  yyDayNumber = (yyvsp + -1)->Number;
#line 279
  goto switch_break;
  case_19: /* CIL Label */ 
#line 280
  yyDayOrdinal = (yyvsp + -1)->Number;
#line 281
  yyDayNumber = (yyvsp + 0)->Number;
#line 283
  goto switch_break;
  case_20: /* CIL Label */ 
#line 286
  yyMonth = (yyvsp + -2)->Number;
#line 287
  yyDay = (yyvsp + 0)->Number;
#line 289
  goto switch_break;
  case_21: /* CIL Label */ 
#line 294
  if ((yyvsp + -4)->Number >= 1000) {
#line 296
    yyYear = (yyvsp + -4)->Number;
#line 297
    yyMonth = (yyvsp + -2)->Number;
#line 298
    yyDay = (yyvsp + 0)->Number;
  } else {
#line 302
    yyMonth = (yyvsp + -4)->Number;
#line 303
    yyDay = (yyvsp + -2)->Number;
#line 304
    yyYear = (yyvsp + 0)->Number;
  }
#line 307
  goto switch_break;
  case_22: /* CIL Label */ 
#line 309
  yyYear = (yyvsp + -2)->Number;
#line 310
  yyMonth = - (yyvsp + -1)->Number;
#line 311
  yyDay = - (yyvsp + 0)->Number;
#line 313
  goto switch_break;
  case_23: /* CIL Label */ 
#line 315
  yyDay = (yyvsp + -2)->Number;
#line 316
  yyMonth = (yyvsp + -1)->Number;
#line 317
  yyYear = - (yyvsp + 0)->Number;
#line 319
  goto switch_break;
  case_24: /* CIL Label */ 
#line 320
  yyMonth = (yyvsp + -1)->Number;
#line 321
  yyDay = (yyvsp + 0)->Number;
#line 323
  goto switch_break;
  case_25: /* CIL Label */ 
#line 324
  yyMonth = (yyvsp + -3)->Number;
#line 325
  yyDay = (yyvsp + -2)->Number;
#line 326
  yyYear = (yyvsp + 0)->Number;
#line 328
  goto switch_break;
  case_26: /* CIL Label */ 
#line 329
  yyMonth = (yyvsp + 0)->Number;
#line 330
  yyDay = (yyvsp + -1)->Number;
#line 332
  goto switch_break;
  case_27: /* CIL Label */ 
#line 333
  yyMonth = (yyvsp + -1)->Number;
#line 334
  yyDay = (yyvsp + -2)->Number;
#line 335
  yyYear = (yyvsp + 0)->Number;
#line 337
  goto switch_break;
  case_28: /* CIL Label */ 
#line 340
  yyRelSeconds = - yyRelSeconds;
#line 341
  yyRelMinutes = - yyRelMinutes;
#line 342
  yyRelHour = - yyRelHour;
#line 343
  yyRelDay = - yyRelDay;
#line 344
  yyRelMonth = - yyRelMonth;
#line 345
  yyRelYear = - yyRelYear;
#line 347
  goto switch_break;
  case_30: /* CIL Label */ 
#line 351
  yyRelYear += (yyvsp + -1)->Number * (yyvsp + 0)->Number;
#line 353
  goto switch_break;
  case_31: /* CIL Label */ 
#line 354
  yyRelYear += (yyvsp + -1)->Number * (yyvsp + 0)->Number;
#line 356
  goto switch_break;
  case_32: /* CIL Label */ 
#line 357
  yyRelYear += (yyvsp + 0)->Number;
#line 359
  goto switch_break;
  case_33: /* CIL Label */ 
#line 360
  yyRelMonth += (yyvsp + -1)->Number * (yyvsp + 0)->Number;
#line 362
  goto switch_break;
  case_34: /* CIL Label */ 
#line 363
  yyRelMonth += (yyvsp + -1)->Number * (yyvsp + 0)->Number;
#line 365
  goto switch_break;
  case_35: /* CIL Label */ 
#line 366
  yyRelMonth += (yyvsp + 0)->Number;
#line 368
  goto switch_break;
  case_36: /* CIL Label */ 
#line 369
  yyRelDay += (yyvsp + -1)->Number * (yyvsp + 0)->Number;
#line 371
  goto switch_break;
  case_37: /* CIL Label */ 
#line 372
  yyRelDay += (yyvsp + -1)->Number * (yyvsp + 0)->Number;
#line 374
  goto switch_break;
  case_38: /* CIL Label */ 
#line 375
  yyRelDay += (yyvsp + 0)->Number;
#line 377
  goto switch_break;
  case_39: /* CIL Label */ 
#line 378
  yyRelHour += (yyvsp + -1)->Number * (yyvsp + 0)->Number;
#line 380
  goto switch_break;
  case_40: /* CIL Label */ 
#line 381
  yyRelHour += (yyvsp + -1)->Number * (yyvsp + 0)->Number;
#line 383
  goto switch_break;
  case_41: /* CIL Label */ 
#line 384
  yyRelHour += (yyvsp + 0)->Number;
#line 386
  goto switch_break;
  case_42: /* CIL Label */ 
#line 387
  yyRelMinutes += (yyvsp + -1)->Number * (yyvsp + 0)->Number;
#line 389
  goto switch_break;
  case_43: /* CIL Label */ 
#line 390
  yyRelMinutes += (yyvsp + -1)->Number * (yyvsp + 0)->Number;
#line 392
  goto switch_break;
  case_44: /* CIL Label */ 
#line 393
  yyRelMinutes += (yyvsp + 0)->Number;
#line 395
  goto switch_break;
  case_45: /* CIL Label */ 
#line 396
  yyRelSeconds += (yyvsp + -1)->Number * (yyvsp + 0)->Number;
#line 398
  goto switch_break;
  case_46: /* CIL Label */ 
#line 399
  yyRelSeconds += (yyvsp + -1)->Number * (yyvsp + 0)->Number;
#line 401
  goto switch_break;
  case_47: /* CIL Label */ 
#line 402
  yyRelSeconds += (yyvsp + 0)->Number;
#line 404
  goto switch_break;
  case_48: /* CIL Label */ 
#line 408
  if (yyHaveTime) {
#line 408
    if (yyHaveDate) {
#line 408
      if (! yyHaveRel) {
#line 409
        yyYear = (yyvsp + 0)->Number;
      } else {
#line 408
        goto _L___0;
      }
    } else {
#line 408
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 412
  if ((yyvsp + 0)->Number > 10000) {
#line 414
    yyHaveDate ++;
#line 415
    yyDay = (yyvsp + 0)->Number % 100;
#line 416
    yyMonth = ((yyvsp + 0)->Number / 100) % 100;
#line 417
    yyYear = (yyvsp + 0)->Number / 10000;
  } else {
#line 421
    yyHaveTime ++;
#line 422
    if ((yyvsp + 0)->Number < 100) {
#line 424
      yyHour = (yyvsp + 0)->Number;
#line 425
      yyMinutes = 0;
    } else {
#line 429
      yyHour = (yyvsp + 0)->Number / 100;
#line 430
      yyMinutes = (yyvsp + 0)->Number % 100;
    }
#line 432
    yySeconds = 0;
#line 433
    yyMeridian = (MERIDIAN )2;
  }
#line 437
  goto switch_break;
  case_49: /* CIL Label */ 
#line 441
  gd_val.Meridian = (enum _MERIDIAN )2;
#line 443
  goto switch_break;
  case_50: /* CIL Label */ 
#line 445
  gd_val.Meridian = (yyvsp + 0)->Meridian;
#line 447
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 544 "/opt/reb/share/bison.simple"
  yyvsp -= gd_yylen;
#line 545
  yyssp -= gd_yylen;
#line 561
  yyvsp ++;
#line 561
  *yyvsp = gd_val;
#line 585
  yyn = (int )gd_r1[yyn];
#line 587
  gd_state = (int )((int const   )yypgoto[yyn - 22] + (int const   )*yyssp);
#line 588
  if (gd_state >= 0) {
#line 588
    if (gd_state <= 51) {
#line 588
      if ((int const   )gd_yycheck[gd_state] == (int const   )*yyssp) {
#line 589
        gd_state = (int )gd_yytable[gd_state];
      } else {
#line 591
        gd_state = (int )yydefgoto[yyn - 22];
      }
    } else {
#line 591
      gd_state = (int )yydefgoto[yyn - 22];
    }
  } else {
#line 591
    gd_state = (int )yydefgoto[yyn - 22];
  }
#line 593
  goto yynewstate;
  yyerrlab: 
#line 597
  if (! yyerrstatus) {
    {
#line 600
    gd_nerrs ++;
#line 643
    gd_error("parse error");
    }
  }
#line 646
  goto yyerrlab1;
  yyerrlab1: 
#line 649
  if (yyerrstatus == 3) {
#line 654
    if (gd_char == 0) {
#line 655
      goto yyabortlab;
    }
#line 662
    gd_char = -2;
  }
#line 668
  yyerrstatus = 3;
#line 670
  goto yyerrhandle;
  yyerrdefault: 
#line 683
  if ((unsigned long )yyssp == (unsigned long )yyss) {
#line 683
    goto yyabortlab;
  }
#line 684
  yyvsp --;
#line 685
  yyssp --;
#line 685
  gd_state = (int )*yyssp;
  yyerrhandle: 
#line 703
  yyn = (int )gd_pact[gd_state];
#line 704
  if (yyn == -32768) {
#line 705
    goto yyerrdefault;
  }
#line 707
  yyn ++;
#line 708
  if (yyn < 0) {
#line 709
    goto yyerrdefault;
  } else
#line 708
  if (yyn > 51) {
#line 709
    goto yyerrdefault;
  } else
#line 708
  if ((int const   )gd_yycheck[yyn] != 1) {
#line 709
    goto yyerrdefault;
  }
#line 711
  yyn = (int )gd_yytable[yyn];
#line 712
  if (yyn < 0) {
#line 714
    if (yyn == -32768) {
#line 715
      goto yyerrdefault;
    }
#line 716
    yyn = - yyn;
#line 717
    goto yyreduce;
  } else
#line 719
  if (yyn == 0) {
#line 720
    goto yyerrdefault;
  }
#line 722
  if (yyn == 61) {
#line 723
    goto yyacceptlab;
  }
#line 730
  yyvsp ++;
#line 730
  *yyvsp = gd_lval;
#line 735
  gd_state = yyn;
#line 736
  goto yynewstate;
  yyacceptlab: 
#line 740
  if (yyfree_stacks) {
    {
#line 742
    free((void *)yyss);
#line 743
    free((void *)yyvs);
    }
  }
#line 748
  return (0);
  yyabortlab: 
#line 752
  if (yyfree_stacks) {
    {
#line 754
    free((void *)yyss);
#line 755
    free((void *)yyvs);
    }
  }
#line 760
  return (1);
}
}
#line 184 "/usr/include/time.h"
extern time_t time(time_t *__timer ) ;
#line 191
extern time_t mktime(struct tm *__tp ) ;
#line 229
extern struct tm *gmtime(time_t const   *__timer ) ;
#line 233
extern struct tm *localtime(time_t const   *__timer ) ;
#line 46 "getdate.h"
time_t get_date(char const   *p , time_t const   *now___0 ) ;
#line 461 "getdate.y"
static TABLE const   MonthDayTable[25]  = 
#line 461 "getdate.y"
  {      {"january", 266, 1}, 
        {"february", 266, 2}, 
        {"march", 266, 3}, 
        {"april", 266, 4}, 
        {"may", 266, 5}, 
        {"june", 266, 6}, 
        {"july", 266, 7}, 
        {"august", 266, 8}, 
        {"september", 266, 9}, 
        {"sept", 266, 9}, 
        {"october", 266, 10}, 
        {"november", 266, 11}, 
        {"december", 266, 12}, 
        {"sunday", 258, 0}, 
        {"monday", 258, 1}, 
        {"tuesday", 258, 2}, 
        {"tues", 258, 2}, 
        {"wednesday", 258, 3}, 
        {"wednes", 258, 3}, 
        {"thursday", 258, 4}, 
        {"thur", 258, 4}, 
        {"thurs", 258, 4}, 
        {"friday", 258, 5}, 
        {"saturday", 258, 6}, 
        {(char const   *)((void *)0), 0, 0}};
#line 490 "getdate.y"
static TABLE const   UnitsTable[11]  = 
#line 490
  {      {"year", 271, 1}, 
        {"month", 267, 1}, 
        {"fortnight", 259, 14}, 
        {"week", 259, 7}, 
        {"day", 259, 1}, 
        {"hour", 262, 1}, 
        {"minute", 265, 1}, 
        {"min", 265, 1}, 
        {"second", 268, 1}, 
        {"sec", 268, 1}, 
        {(char const   *)((void *)0), 0, 0}};
#line 505 "getdate.y"
static TABLE const   OtherTable[20]  = 
#line 505
  {      {"tomorrow", 265, 1440}, 
        {"yesterday", 265, -1440}, 
        {"today", 265, 0}, 
        {"now", 265, 0}, 
        {"last", 270, -1}, 
        {"this", 265, 0}, 
        {"next", 270, 1}, 
        {"first", 270, 1}, 
        {"third", 270, 3}, 
        {"fourth", 270, 4}, 
        {"fifth", 270, 5}, 
        {"sixth", 270, 6}, 
        {"seventh", 270, 7}, 
        {"eighth", 270, 8}, 
        {"ninth", 270, 9}, 
        {"tenth", 270, 10}, 
        {"eleventh", 270, 11}, 
        {"twelfth", 270, 12}, 
        {"ago", 257, 1}, 
        {(char const   *)((void *)0), 0, 0}};
#line 530 "getdate.y"
static TABLE const   TimezoneTable[51]  = 
#line 530
  {      {"gmt", 272, 0}, 
        {"ut", 272, 0}, 
        {"utc", 272, 0}, 
        {"wet", 272, 0}, 
        {"bst", 260, 0}, 
        {"wat", 272, 60}, 
        {"at", 272, 120}, 
        {"ast", 272, 240}, 
        {"adt", 260, 240}, 
        {"est", 272, 300}, 
        {"edt", 260, 300}, 
        {"cst", 272, 360}, 
        {"cdt", 260, 360}, 
        {"mst", 272, 420}, 
        {"mdt", 260, 420}, 
        {"pst", 272, 480}, 
        {"pdt", 260, 480}, 
        {"yst", 272, 540}, 
        {"ydt", 260, 540}, 
        {"hst", 272, 600}, 
        {"hdt", 260, 600}, 
        {"cat", 272, 600}, 
        {"ahst", 272, 600}, 
        {"nt", 272, 660}, 
        {"idlw", 272, 720}, 
        {"cet", 272, -60}, 
        {"met", 272, -60}, 
        {"mewt", 272, -60}, 
        {"mest", 260, -60}, 
        {"mesz", 260, -60}, 
        {"swt", 272, -60}, 
        {"sst", 260, -60}, 
        {"fwt", 272, -60}, 
        {"fst", 260, -60}, 
        {"eet", 272, -120}, 
        {"bt", 272, -180}, 
        {"zp4", 272, -240}, 
        {"zp5", 272, -300}, 
        {"zp6", 272, -360}, 
        {"wast", 272, -420}, 
        {"wadt", 260, -420}, 
        {"cct", 272, -480}, 
        {"jst", 272, -540}, 
        {"east", 272, -600}, 
        {"eadt", 260, -600}, 
        {"gst", 272, -600}, 
        {"nzt", 272, -720}, 
        {"nzst", 272, -720}, 
        {"nzdt", 260, -720}, 
        {"idle", 272, -720}, 
        {(char const   *)((void *)0), 0, 0}};
#line 615 "getdate.y"
static TABLE const   MilitaryTable[26]  = 
#line 615
  {      {"a", 272, 60}, 
        {"b", 272, 120}, 
        {"c", 272, 180}, 
        {"d", 272, 240}, 
        {"e", 272, 300}, 
        {"f", 272, 360}, 
        {"g", 272, 420}, 
        {"h", 272, 480}, 
        {"i", 272, 540}, 
        {"k", 272, 600}, 
        {"l", 272, 660}, 
        {"m", 272, 720}, 
        {"n", 272, -60}, 
        {"o", 272, -120}, 
        {"p", 272, -180}, 
        {"q", 272, -240}, 
        {"r", 272, -300}, 
        {"s", 272, -360}, 
        {"t", 272, -420}, 
        {"u", 272, -480}, 
        {"v", 272, -540}, 
        {"w", 272, -600}, 
        {"x", 272, -660}, 
        {"y", 272, -720}, 
        {"z", 272, 0}, 
        {(char const   *)((void *)0), 0, 0}};
#line 648 "getdate.y"
static int gd_error(char *s  __attribute__((__unused__)) ) 
{ 


  {
#line 652
  return (0);
}
}
#line 655 "getdate.y"
static int ToHour(int Hours , MERIDIAN Meridian ) 
{ 


  {
  {
#line 662
  if ((unsigned int )Meridian == 2U) {
#line 662
    goto case_2;
  }
#line 666
  if ((unsigned int )Meridian == 0U) {
#line 666
    goto case_0;
  }
#line 672
  if ((unsigned int )Meridian == 1U) {
#line 672
    goto case_1;
  }
#line 678
  goto switch_default;
  case_2: /* CIL Label */ 
#line 663
  if (Hours < 0) {
#line 664
    return (-1);
  } else
#line 663
  if (Hours > 23) {
#line 664
    return (-1);
  }
#line 665
  return (Hours);
  case_0: /* CIL Label */ 
#line 667
  if (Hours < 1) {
#line 668
    return (-1);
  } else
#line 667
  if (Hours > 12) {
#line 668
    return (-1);
  }
#line 669
  if (Hours == 12) {
#line 670
    Hours = 0;
  }
#line 671
  return (Hours);
  case_1: /* CIL Label */ 
#line 673
  if (Hours < 1) {
#line 674
    return (-1);
  } else
#line 673
  if (Hours > 12) {
#line 674
    return (-1);
  }
#line 675
  if (Hours == 12) {
#line 676
    Hours = 0;
  }
#line 677
  return (Hours + 12);
  switch_default: /* CIL Label */ 
  {
#line 679
  abort();
  }
  switch_break: /* CIL Label */ ;
  }
}
}
#line 684 "getdate.y"
static int ToYear(int Year ) 
{ 


  {
#line 688
  if (Year < 0) {
#line 689
    Year = - Year;
  }
#line 693
  if (Year < 69) {
#line 694
    Year += 2000;
  } else
#line 695
  if (Year < 100) {
#line 696
    Year += 1900;
  }
#line 698
  return (Year);
}
}
#line 701 "getdate.y"
static int LookupWord(char *buff ) 
{ 
  register char *p ;
  register char *q ;
  register TABLE const   *tp ;
  int i ;
  int abbrev ;
  int tmp ;
  unsigned short const   **tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  size_t tmp___5 ;
  size_t tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  size_t tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  unsigned short const   **tmp___16 ;
  char *tmp___17 ;
  int tmp___18 ;

  {
#line 712
  p = buff;
  {
#line 712
  while (1) {
    while_continue: /* CIL Label */ ;
#line 712
    if (! *p) {
#line 712
      goto while_break;
    }
    {
#line 713
    tmp___0 = __ctype_b_loc();
    }
#line 713
    if ((int const   )*(*tmp___0 + (int )((unsigned char )*p)) & 256) {
      {
#line 714
      tmp = tolower((int )*p);
#line 714
      *p = (char )tmp;
      }
    }
#line 712
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 716
  tmp___1 = strcmp((char const   *)buff, "am");
  }
#line 716
  if (tmp___1 == 0) {
#line 718
    gd_lval.Meridian = (enum _MERIDIAN )0;
#line 719
    return (264);
  } else {
    {
#line 716
    tmp___2 = strcmp((char const   *)buff, "a.m.");
    }
#line 716
    if (tmp___2 == 0) {
#line 718
      gd_lval.Meridian = (enum _MERIDIAN )0;
#line 719
      return (264);
    }
  }
  {
#line 721
  tmp___3 = strcmp((char const   *)buff, "pm");
  }
#line 721
  if (tmp___3 == 0) {
#line 723
    gd_lval.Meridian = (enum _MERIDIAN )1;
#line 724
    return (264);
  } else {
    {
#line 721
    tmp___4 = strcmp((char const   *)buff, "p.m.");
    }
#line 721
    if (tmp___4 == 0) {
#line 723
      gd_lval.Meridian = (enum _MERIDIAN )1;
#line 724
      return (264);
    }
  }
  {
#line 728
  tmp___6 = strlen((char const   *)buff);
  }
#line 728
  if (tmp___6 == 3U) {
#line 729
    abbrev = 1;
  } else {
    {
#line 730
    tmp___5 = strlen((char const   *)buff);
    }
#line 730
    if (tmp___5 == 4U) {
#line 730
      if ((int )*(buff + 3) == 46) {
#line 732
        abbrev = 1;
#line 733
        *(buff + 3) = (char )'\000';
      } else {
#line 736
        abbrev = 0;
      }
    } else {
#line 736
      abbrev = 0;
    }
  }
#line 738
  tp = MonthDayTable;
  {
#line 738
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 738
    if (! tp->name) {
#line 738
      goto while_break___0;
    }
#line 740
    if (abbrev) {
      {
#line 742
      tmp___7 = strncmp((char const   *)buff, (char const   *)tp->name, (size_t )3);
      }
#line 742
      if (tmp___7 == 0) {
#line 744
        gd_lval.Number = (int )tp->value;
#line 745
        return ((int )tp->type);
      }
    } else {
      {
#line 748
      tmp___8 = strcmp((char const   *)buff, (char const   *)tp->name);
      }
#line 748
      if (tmp___8 == 0) {
#line 750
        gd_lval.Number = (int )tp->value;
#line 751
        return ((int )tp->type);
      }
    }
#line 738
    tp ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 755
  tp = TimezoneTable;
  {
#line 755
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 755
    if (! tp->name) {
#line 755
      goto while_break___1;
    }
    {
#line 756
    tmp___9 = strcmp((char const   *)buff, (char const   *)tp->name);
    }
#line 756
    if (tmp___9 == 0) {
#line 758
      gd_lval.Number = (int )tp->value;
#line 759
      return ((int )tp->type);
    }
#line 755
    tp ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 762
  tmp___10 = strcmp((char const   *)buff, "dst");
  }
#line 762
  if (tmp___10 == 0) {
#line 763
    return (261);
  }
#line 765
  tp = UnitsTable;
  {
#line 765
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 765
    if (! tp->name) {
#line 765
      goto while_break___2;
    }
    {
#line 766
    tmp___11 = strcmp((char const   *)buff, (char const   *)tp->name);
    }
#line 766
    if (tmp___11 == 0) {
#line 768
      gd_lval.Number = (int )tp->value;
#line 769
      return ((int )tp->type);
    }
#line 765
    tp ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 773
  tmp___12 = strlen((char const   *)buff);
#line 773
  i = (int )(tmp___12 - 1U);
  }
#line 774
  if ((int )*(buff + i) == 115) {
#line 776
    *(buff + i) = (char )'\000';
#line 777
    tp = UnitsTable;
    {
#line 777
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 777
      if (! tp->name) {
#line 777
        goto while_break___3;
      }
      {
#line 778
      tmp___13 = strcmp((char const   *)buff, (char const   *)tp->name);
      }
#line 778
      if (tmp___13 == 0) {
#line 780
        gd_lval.Number = (int )tp->value;
#line 781
        return ((int )tp->type);
      }
#line 777
      tp ++;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 783
    *(buff + i) = (char )'s';
  }
#line 786
  tp = OtherTable;
  {
#line 786
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 786
    if (! tp->name) {
#line 786
      goto while_break___4;
    }
    {
#line 787
    tmp___14 = strcmp((char const   *)buff, (char const   *)tp->name);
    }
#line 787
    if (tmp___14 == 0) {
#line 789
      gd_lval.Number = (int )tp->value;
#line 790
      return ((int )tp->type);
    }
#line 786
    tp ++;
  }
  while_break___4: /* CIL Label */ ;
  }
#line 794
  if ((int )*(buff + 1) == 0) {
    {
#line 794
    tmp___16 = __ctype_b_loc();
    }
#line 794
    if ((int const   )*(*tmp___16 + (int )((unsigned char )*buff)) & 1024) {
#line 796
      tp = MilitaryTable;
      {
#line 796
      while (1) {
        while_continue___5: /* CIL Label */ ;
#line 796
        if (! tp->name) {
#line 796
          goto while_break___5;
        }
        {
#line 797
        tmp___15 = strcmp((char const   *)buff, (char const   *)tp->name);
        }
#line 797
        if (tmp___15 == 0) {
#line 799
          gd_lval.Number = (int )tp->value;
#line 800
          return ((int )tp->type);
        }
#line 796
        tp ++;
      }
      while_break___5: /* CIL Label */ ;
      }
    }
  }
#line 805
  i = 0;
#line 805
  q = buff;
#line 805
  p = q;
  {
#line 805
  while (1) {
    while_continue___6: /* CIL Label */ ;
#line 805
    if (! *q) {
#line 805
      goto while_break___6;
    }
#line 806
    if ((int )*q != 46) {
#line 807
      tmp___17 = p;
#line 807
      p ++;
#line 807
      *tmp___17 = *q;
    } else {
#line 809
      i ++;
    }
#line 805
    q ++;
  }
  while_break___6: /* CIL Label */ ;
  }
#line 810
  *p = (char )'\000';
#line 811
  if (i) {
#line 812
    tp = TimezoneTable;
    {
#line 812
    while (1) {
      while_continue___7: /* CIL Label */ ;
#line 812
      if (! tp->name) {
#line 812
        goto while_break___7;
      }
      {
#line 813
      tmp___18 = strcmp((char const   *)buff, (char const   *)tp->name);
      }
#line 813
      if (tmp___18 == 0) {
#line 815
        gd_lval.Number = (int )tp->value;
#line 816
        return ((int )tp->type);
      }
#line 812
      tp ++;
    }
    while_break___7: /* CIL Label */ ;
    }
  }
#line 819
  return (263);
}
}
#line 822 "getdate.y"
static int gd_lex(void) 
{ 
  register unsigned char c ;
  register char *p ;
  char buff[20] ;
  int Count ;
  int sign ;
  unsigned short const   **tmp ;
  char const   *tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  char const   *tmp___3 ;
  unsigned short const   **tmp___4 ;
  int tmp___5 ;
  unsigned short const   **tmp___6 ;
  char const   *tmp___7 ;
  char const   *tmp___8 ;

  {
  {
#line 831
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 833
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 833
      tmp = __ctype_b_loc();
      }
#line 833
      if (! ((int const   )*(*tmp + (int )((unsigned char )*yyInput)) & 8192)) {
#line 833
        goto while_break___0;
      }
#line 834
      yyInput ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 836
    c = (unsigned char )*yyInput;
#line 836
    if ((unsigned int )c - 48U <= 9U) {
#line 836
      goto _L___0;
    } else
#line 836
    if ((int )c == 45) {
#line 836
      goto _L___0;
    } else
#line 836
    if ((int )c == 43) {
      _L___0: /* CIL Label */ 
#line 838
      if ((int )c == 45) {
#line 838
        goto _L;
      } else
#line 838
      if ((int )c == 43) {
        _L: /* CIL Label */ 
#line 840
        if ((int )c == 45) {
#line 840
          sign = -1;
        } else {
#line 840
          sign = 1;
        }
#line 841
        yyInput ++;
#line 841
        if (! ((unsigned int )*yyInput - 48U <= 9U)) {
#line 843
          goto __Cont;
        }
      } else {
#line 846
        sign = 0;
      }
#line 847
      gd_lval.Number = 0;
      {
#line 847
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 847
        tmp___0 = yyInput;
#line 847
        yyInput ++;
#line 847
        c = (unsigned char )*tmp___0;
#line 847
        if (! ((unsigned int )c - 48U <= 9U)) {
#line 847
          goto while_break___1;
        }
#line 848
        gd_lval.Number = (10 * gd_lval.Number + (int )c) - 48;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 849
      yyInput --;
#line 850
      if (sign < 0) {
#line 851
        gd_lval.Number = - gd_lval.Number;
      }
#line 852
      if (sign) {
#line 852
        tmp___1 = 269;
      } else {
#line 852
        tmp___1 = 270;
      }
#line 852
      return (tmp___1);
    }
    {
#line 854
    tmp___6 = __ctype_b_loc();
    }
#line 854
    if ((int const   )*(*tmp___6 + (int )c) & 1024) {
#line 856
      p = buff;
      {
#line 856
      while (1) {
        while_continue___2: /* CIL Label */ ;
        {
#line 856
        tmp___3 = yyInput;
#line 856
        yyInput ++;
#line 856
        c = (unsigned char )*tmp___3;
#line 856
        tmp___4 = __ctype_b_loc();
        }
#line 856
        if (! (((int const   )*(*tmp___4 + (int )c) & 1024) != 0)) {
#line 856
          if (! ((int )c == 46)) {
#line 856
            goto while_break___2;
          }
        }
#line 857
        if ((unsigned long )p < (unsigned long )(& buff[sizeof(buff) - 1UL])) {
#line 858
          tmp___2 = p;
#line 858
          p ++;
#line 858
          *tmp___2 = (char )c;
        }
      }
      while_break___2: /* CIL Label */ ;
      }
      {
#line 859
      *p = (char )'\000';
#line 860
      yyInput --;
#line 861
      tmp___5 = LookupWord(buff);
      }
#line 861
      return (tmp___5);
    }
#line 863
    if ((int )c != 40) {
#line 864
      tmp___7 = yyInput;
#line 864
      yyInput ++;
#line 864
      return ((int )*tmp___7);
    }
#line 865
    Count = 0;
    {
#line 866
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 868
      tmp___8 = yyInput;
#line 868
      yyInput ++;
#line 868
      c = (unsigned char )*tmp___8;
#line 869
      if ((int )c == 0) {
#line 870
        return ((int )c);
      }
#line 871
      if ((int )c == 40) {
#line 872
        Count ++;
      } else
#line 873
      if ((int )c == 41) {
#line 874
        Count --;
      }
#line 866
      if (! (Count > 0)) {
#line 866
        goto while_break___3;
      }
    }
    while_break___3: /* CIL Label */ ;
    }
    __Cont: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 883 "getdate.y"
static long difftm(struct tm *a , struct tm *b ) 
{ 
  int ay ;
  int by ;
  long days ;

  {
#line 886
  ay = a->tm_year + 1899;
#line 887
  by = b->tm_year + 1899;
#line 888
  days = (long )((((a->tm_yday - b->tm_yday) + ((ay >> 2) - (by >> 2))) - (ay / 100 - by / 100)) + ((ay / 100 >> 2) - (by / 100 >> 2))) + (long )(ay - by) * 365L;
#line 898
  return (60L * (60L * (24L * days + (long )(a->tm_hour - b->tm_hour)) + (long )(a->tm_min - b->tm_min)) + (long )(a->tm_sec - b->tm_sec));
}
}
#line 903 "getdate.y"
time_t get_date(char const   *p , time_t const   *now___0 ) 
{ 
  struct tm tm ;
  struct tm tm0 ;
  struct tm *tmp ;
  time_t Start ;
  time_t tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  long delta ;
  struct tm *gmt ;
  struct tm *tmp___3 ;
  long tmp___4 ;

  {
#line 909
  yyInput = p;
#line 910
  if (now___0) {
#line 910
    Start = (time_t )*now___0;
  } else {
    {
#line 910
    tmp___0 = time((time_t *)((void *)0));
#line 910
    Start = tmp___0;
    }
  }
  {
#line 911
  tmp = localtime((time_t const   *)(& Start));
  }
#line 912
  if (! tmp) {
#line 913
    return ((time_t )-1);
  }
  {
#line 914
  yyYear = tmp->tm_year + 1900;
#line 915
  yyMonth = tmp->tm_mon + 1;
#line 916
  yyDay = tmp->tm_mday;
#line 917
  yyHour = tmp->tm_hour;
#line 918
  yyMinutes = tmp->tm_min;
#line 919
  yySeconds = tmp->tm_sec;
#line 920
  tm.tm_isdst = tmp->tm_isdst;
#line 921
  yyMeridian = (MERIDIAN )2;
#line 922
  yyRelSeconds = 0;
#line 923
  yyRelMinutes = 0;
#line 924
  yyRelHour = 0;
#line 925
  yyRelDay = 0;
#line 926
  yyRelMonth = 0;
#line 927
  yyRelYear = 0;
#line 928
  yyHaveDate = 0;
#line 929
  yyHaveDay = 0;
#line 930
  yyHaveRel = 0;
#line 931
  yyHaveTime = 0;
#line 932
  yyHaveZone = 0;
#line 934
  tmp___1 = gd_parse();
  }
#line 934
  if (tmp___1) {
#line 936
    return ((time_t )-1);
  } else
#line 934
  if (yyHaveTime > 1) {
#line 936
    return ((time_t )-1);
  } else
#line 934
  if (yyHaveZone > 1) {
#line 936
    return ((time_t )-1);
  } else
#line 934
  if (yyHaveDate > 1) {
#line 936
    return ((time_t )-1);
  } else
#line 934
  if (yyHaveDay > 1) {
#line 936
    return ((time_t )-1);
  }
  {
#line 938
  tmp___2 = ToYear(yyYear);
#line 938
  tm.tm_year = (tmp___2 - 1900) + yyRelYear;
#line 939
  tm.tm_mon = (yyMonth - 1) + yyRelMonth;
#line 940
  tm.tm_mday = yyDay + yyRelDay;
  }
#line 941
  if (yyHaveTime) {
#line 941
    goto _L;
  } else
#line 941
  if (yyHaveRel) {
#line 941
    if (! yyHaveDate) {
#line 941
      if (! yyHaveDay) {
        _L: /* CIL Label */ 
        {
#line 943
        tm.tm_hour = ToHour(yyHour, yyMeridian);
        }
#line 944
        if (tm.tm_hour < 0) {
#line 945
          return ((time_t )-1);
        }
#line 946
        tm.tm_min = yyMinutes;
#line 947
        tm.tm_sec = yySeconds;
      } else {
#line 951
        tm.tm_sec = 0;
#line 951
        tm.tm_min = tm.tm_sec;
#line 951
        tm.tm_hour = tm.tm_min;
      }
    } else {
#line 951
      tm.tm_sec = 0;
#line 951
      tm.tm_min = tm.tm_sec;
#line 951
      tm.tm_hour = tm.tm_min;
    }
  } else {
#line 951
    tm.tm_sec = 0;
#line 951
    tm.tm_min = tm.tm_sec;
#line 951
    tm.tm_hour = tm.tm_min;
  }
#line 953
  tm.tm_hour += yyRelHour;
#line 954
  tm.tm_min += yyRelMinutes;
#line 955
  tm.tm_sec += yyRelSeconds;
#line 959
  if (((((yyHaveDate | yyHaveDay) | yyHaveTime) | yyRelDay) | yyRelMonth) | yyRelYear) {
#line 960
    tm.tm_isdst = -1;
  }
  {
#line 962
  tm0 = tm;
#line 964
  Start = mktime(& tm);
  }
#line 966
  if (Start == -1L) {
#line 977
    if (yyHaveZone) {
#line 979
      tm = tm0;
#line 980
      if (tm.tm_year <= 70) {
#line 982
        (tm.tm_mday) ++;
#line 983
        yyTimezone -= 1440;
      } else {
#line 987
        (tm.tm_mday) --;
#line 988
        yyTimezone += 1440;
      }
      {
#line 990
      Start = mktime(& tm);
      }
    }
#line 993
    if (Start == -1L) {
#line 994
      return (Start);
    }
  }
#line 997
  if (yyHaveDay) {
#line 997
    if (! yyHaveDate) {
      {
#line 999
      tm.tm_mday += ((yyDayNumber - tm.tm_wday) + 7) % 7 + 7 * (yyDayOrdinal - (0 < yyDayOrdinal));
#line 1001
      Start = mktime(& tm);
      }
#line 1002
      if (Start == -1L) {
#line 1003
        return (Start);
      }
    }
  }
#line 1006
  if (yyHaveZone) {
    {
#line 1009
    tmp___3 = gmtime((time_t const   *)(& Start));
#line 1009
    gmt = tmp___3;
    }
#line 1010
    if (! gmt) {
#line 1011
      return ((time_t )-1);
    }
    {
#line 1012
    tmp___4 = difftm(& tm, gmt);
#line 1012
    delta = (long )yyTimezone * 60L + tmp___4;
    }
#line 1013
    if ((Start + delta < Start) != (delta < 0L)) {
#line 1014
      return ((time_t )-1);
    }
#line 1015
    Start += delta;
  }
#line 1018
  return (Start);
}
}
#line 9 "safe-read.h"
ssize_t full_write(int desc , char const   *ptr , size_t len ) ;
#line 318 "/usr/include/unistd.h"
extern ssize_t write(int __fd , void const   *__buf , size_t __n ) ;
#line 41 "full-write.c"
ssize_t full_write(int desc , char const   *ptr , size_t len ) 
{ 
  ssize_t total_written___0 ;
  ssize_t written ;
  ssize_t tmp ;
  int *tmp___0 ;

  {
#line 44
  total_written___0 = 0;
  {
#line 46
  while (1) {
    while_continue: /* CIL Label */ ;
#line 46
    if (! (len > 0U)) {
#line 46
      goto while_break;
    }
    {
#line 48
    tmp = write(desc, (void const   *)ptr, len);
#line 48
    written = tmp;
    }
#line 53
    if (written < 0) {
      {
#line 56
      tmp___0 = __errno_location();
      }
#line 56
      if (*tmp___0 == 4) {
#line 57
        goto while_continue;
      }
#line 59
      return (written);
    }
#line 61
    total_written___0 += written;
#line 62
    ptr += written;
#line 63
    len -= (size_t )written;
  }
  while_break: /* CIL Label */ ;
  }
#line 65
  return (total_written___0);
}
}
#line 31 "exclude.h"
struct exclude *new_exclude(void) ;
#line 32
void add_exclude(struct exclude *ex , char const   *pattern ) ;
#line 33
int add_exclude_file(struct exclude *ex , char const   *filename , char line_end ) ;
#line 34
int excluded_filename(struct exclude  const  *ex , char const   *f ) ;
#line 62 "fnmatch.h"
extern int fnmatch(char const   *__pattern , char const   *__string , int __flags ) ;
#line 433 "/usr/include/libio.h"
extern int _IO_getc(_IO_FILE *__fp ) ;
#line 142 "/usr/include/stdio.h"
extern struct _IO_FILE *stdin ;
#line 206
extern int fclose(FILE *__stream ) ;
#line 252
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes )  __asm__("fopen64")  ;
#line 724
extern int ferror(FILE *__stream ) ;
#line 46 "exclude.c"
struct exclude *new_exclude(void) 
{ 
  struct exclude *ex ;
  void *tmp ;
  void *tmp___0 ;

  {
  {
#line 49
  tmp = xmalloc((size_t )sizeof(struct exclude ));
#line 49
  ex = (struct exclude *)tmp;
#line 50
  ex->exclude_count = 0;
#line 51
  ex->exclude_alloc = 64;
#line 52
  tmp___0 = xmalloc((size_t )((unsigned long )ex->exclude_alloc * sizeof(char *)));
#line 52
  ex->exclude = (char const   **)tmp___0;
  }
#line 53
  return (ex);
}
}
#line 56 "exclude.c"
int excluded_filename(struct exclude  const  *ex , char const   *f ) 
{ 
  char const   * const  *exclude ;
  int exclude_count ;
  int i ;
  int tmp ;

  {
#line 59
  exclude = (char const   * const  *)ex->exclude;
#line 60
  exclude_count = (int )ex->exclude_count;
#line 63
  i = 0;
  {
#line 63
  while (1) {
    while_continue: /* CIL Label */ ;
#line 63
    if (! (i < exclude_count)) {
#line 63
      goto while_break;
    }
    {
#line 64
    tmp = fnmatch((char const   *)*(exclude + i), f, 0);
    }
#line 64
    if (tmp == 0) {
#line 65
      return (1);
    }
#line 63
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 67
  return (0);
}
}
#line 70 "exclude.c"
void add_exclude(struct exclude *ex , char const   *pattern ) 
{ 
  int tmp ;
  void *tmp___0 ;
  int tmp___1 ;

  {
#line 73
  if (ex->exclude_alloc <= ex->exclude_count) {
    {
#line 74
    tmp = ex->exclude_alloc * 2;
#line 74
    ex->exclude_alloc = tmp;
#line 74
    tmp___0 = xrealloc((void *)ex->exclude, (size_t )((unsigned long )tmp * sizeof(char *)));
#line 74
    ex->exclude = (char const   **)tmp___0;
    }
  }
#line 78
  tmp___1 = ex->exclude_count;
#line 78
  (ex->exclude_count) ++;
#line 78
  *(ex->exclude + tmp___1) = pattern;
#line 79
  return;
}
}
#line 81 "exclude.c"
int add_exclude_file(struct exclude *ex , char const   *filename , char line_end ) 
{ 
  int use_stdin ;
  int tmp ;
  FILE *in ;
  char *buf ;
  char *p ;
  char const   *pattern ;
  char const   *lim ;
  size_t buf_alloc ;
  size_t buf_count ;
  int c ;
  int e ;
  void *tmp___0 ;
  size_t tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  int *tmp___4 ;
  int tmp___5 ;
  int *tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int *tmp___10 ;
  int tmp___11 ;

  {
#line 84
  if ((int const   )*(filename + 0) == 45) {
#line 84
    if (! *(filename + 1)) {
#line 84
      tmp = 1;
    } else {
#line 84
      tmp = 0;
    }
  } else {
#line 84
    tmp = 0;
  }
#line 84
  use_stdin = tmp;
#line 90
  buf_alloc = (size_t )1024;
#line 91
  buf_count = (size_t )0;
#line 93
  e = 0;
#line 95
  if (use_stdin) {
#line 96
    in = stdin;
  } else {
    {
#line 97
    in = fopen((char const   */* __restrict  */)filename, (char const   */* __restrict  */)"r");
    }
#line 97
    if (! in) {
#line 98
      return (-1);
    }
  }
  {
#line 100
  tmp___0 = xmalloc(buf_alloc);
#line 100
  buf = (char *)tmp___0;
  }
  {
#line 102
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 102
    c = _IO_getc(in);
    }
#line 102
    if (! (c != -1)) {
#line 102
      goto while_break;
    }
#line 104
    tmp___1 = buf_count;
#line 104
    buf_count ++;
#line 104
    *(buf + tmp___1) = (char )c;
#line 105
    if (buf_count == buf_alloc) {
      {
#line 106
      buf_alloc *= 2U;
#line 106
      tmp___2 = xrealloc((void *)buf, buf_alloc);
#line 106
      buf = (char *)tmp___2;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 109
  tmp___3 = xrealloc((void *)buf, buf_count + 1U);
#line 109
  buf = (char *)tmp___3;
#line 111
  tmp___5 = ferror(in);
  }
#line 111
  if (tmp___5) {
    {
#line 112
    tmp___4 = __errno_location();
#line 112
    e = *tmp___4;
    }
  }
#line 114
  if (! use_stdin) {
    {
#line 114
    tmp___7 = fclose(in);
    }
#line 114
    if (tmp___7 != 0) {
      {
#line 115
      tmp___6 = __errno_location();
#line 115
      e = *tmp___6;
      }
    }
  }
#line 117
  p = buf;
#line 117
  pattern = (char const   *)p;
#line 117
  lim = (char const   *)(buf + buf_count);
  {
#line 117
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 117
    if (! ((unsigned long )p <= (unsigned long )lim)) {
#line 117
      goto while_break___0;
    }
#line 118
    if ((unsigned long )p < (unsigned long )lim) {
#line 118
      tmp___9 = (int )*p == (int )line_end;
    } else {
#line 118
      if ((unsigned long )buf < (unsigned long )p) {
#line 118
        if (*(p + -1)) {
#line 118
          tmp___8 = 1;
        } else {
#line 118
          tmp___8 = 0;
        }
      } else {
#line 118
        tmp___8 = 0;
      }
#line 118
      tmp___9 = tmp___8;
    }
#line 118
    if (tmp___9) {
      {
#line 120
      *p = (char )'\000';
#line 121
      add_exclude(ex, pattern);
#line 122
      pattern = (char const   *)(p + 1);
      }
    }
#line 117
    p ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 125
  tmp___10 = __errno_location();
#line 125
  *tmp___10 = e;
  }
#line 126
  if (e) {
#line 126
    tmp___11 = -1;
  } else {
#line 126
    tmp___11 = 0;
  }
#line 126
  return (tmp___11);
}
}
/* compiler builtin: 
   void __builtin_va_start(__builtin_va_list  ) ;  */
/* compiler builtin: 
   void __builtin_va_end(__builtin_va_list  ) ;  */
#line 434 "/usr/include/libio.h"
extern int _IO_putc(int __c , _IO_FILE *__fp ) ;
#line 143 "/usr/include/stdio.h"
extern struct _IO_FILE *stdout ;
#line 144
extern struct _IO_FILE *stderr ;
#line 211
extern int fflush(FILE *__stream ) ;
#line 321
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 336
extern int vfprintf(FILE * __restrict  __s , char const   * __restrict  __format ,
                    __gnuc_va_list __arg ) ;
#line 612 "/usr/include/stdlib.h"
extern  __attribute__((__noreturn__)) void exit(int __status ) ;
#line 243 "/usr/include/string.h"
extern char *strerror(int __errnum ) ;
#line 52 "error.h"
void ( /* format attribute */  error_at_line)(int status , int errnum , char const   *file_name ,
                                              unsigned int line_number , char const   *message 
                                              , ...) ;
#line 59 "error.h"
void (*error_print_progname)(void)  ;
#line 68 "error.h"
unsigned int error_message_count  ;
#line 72 "error.h"
int error_one_per_line  ;
#line 83 "error.c"
char const   *program_name ;
#line 115 "error.c"
void ( /* format attribute */  error)(int status , int errnum , char const   *message 
                                      , ...) 
{ 
  va_list args ;
  char *tmp ;

  {
#line 130
  if (error_print_progname) {
    {
#line 131
    (*error_print_progname)();
    }
  } else {
    {
#line 134
    fflush(stdout);
#line 135
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: ",
            program_name);
    }
  }
  {
#line 139
  __builtin_va_start(args, message);
#line 141
  vfprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)message,
           args);
#line 145
  __builtin_va_end(args);
#line 150
  error_message_count ++;
  }
#line 151
  if (errnum) {
    {
#line 160
    tmp = strerror(errnum);
#line 160
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)": %s",
            tmp);
    }
  }
  {
#line 163
  _IO_putc('\n', stderr);
#line 164
  fflush(stderr);
  }
#line 165
  if (status) {
    {
#line 166
    exit(status);
    }
  }
#line 167
  return;
}
}
#line 193 "error.c"
static char const   *old_file_name  ;
#line 194 "error.c"
static unsigned int old_line_number  ;
#line 173 "error.c"
void ( /* format attribute */  error_at_line)(int status , int errnum , char const   *file_name ,
                                              unsigned int line_number , char const   *message 
                                              , ...) 
{ 
  va_list args ;
  int tmp ;
  char *tmp___0 ;

  {
#line 191
  if (error_one_per_line) {
#line 196
    if (old_line_number == line_number) {
#line 196
      if ((unsigned long )file_name == (unsigned long )old_file_name) {
#line 199
        return;
      } else {
        {
#line 196
        tmp = strcmp(old_file_name, file_name);
        }
#line 196
        if (! tmp) {
#line 199
          return;
        }
      }
    }
#line 201
    old_file_name = file_name;
#line 202
    old_line_number = line_number;
  }
#line 205
  if (error_print_progname) {
    {
#line 206
    (*error_print_progname)();
    }
  } else {
    {
#line 209
    fflush(stdout);
#line 210
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s:",
            program_name);
    }
  }
#line 213
  if ((unsigned long )file_name != (unsigned long )((void *)0)) {
    {
#line 214
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s:%d: ",
            file_name, line_number);
    }
  }
  {
#line 217
  __builtin_va_start(args, message);
#line 219
  vfprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)message,
           args);
#line 223
  __builtin_va_end(args);
#line 228
  error_message_count ++;
  }
#line 229
  if (errnum) {
    {
#line 235
    tmp___0 = strerror(errnum);
#line 235
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)": %s",
            tmp___0);
    }
  }
  {
#line 238
  _IO_putc('\n', stderr);
#line 239
  fflush(stderr);
  }
#line 240
  if (status) {
    {
#line 241
    exit(status);
    }
  }
#line 242
  return;
}
}
#line 35 "basename.c"
char *base_name(char const   *name ) 
{ 
  char const   *base ;
  int all_slashes ;
  char const   *p ;

  {
#line 38
  name += 0;
#line 38
  base = name;
#line 39
  all_slashes = 1;
#line 42
  p = name;
  {
#line 42
  while (1) {
    while_continue: /* CIL Label */ ;
#line 42
    if (! *p) {
#line 42
      goto while_break;
    }
#line 44
    if ((int const   )*p == 47) {
#line 45
      base = p + 1;
    } else {
#line 47
      all_slashes = 0;
    }
#line 42
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 51
  if ((int const   )*base == 0) {
#line 51
    if ((int const   )*name == 47) {
#line 51
      if (all_slashes) {
#line 52
        base --;
      }
    }
  }
#line 54
  return ((char *)base);
}
}
#line 71 "argmatch.h"
void (*argmatch_die)(void) ;
#line 99
int __xargmatch_internal(char const   *context , char const   *arg , char const   * const  *arglist ,
                         char const   *vallist , size_t valsize , int case_sensitive ,
                         void (*exit_fn)(void) ) ;
#line 45 "backupfile.h"
char const   *simple_backup_suffix ;
#line 55
char *find_backup_file_name(char const   *file , enum backup_type backup_type___0 ) ;
#line 56
enum backup_type get_version(char const   *context , char const   *version ) ;
#line 57
enum backup_type xget_version(char const   *context , char const   *version ) ;
#line 58
void addext(char *filename , char const   *ext , int e ) ;
#line 329 "/usr/include/stdio.h"
extern int sprintf(char * __restrict  __s , char const   * __restrict  __format  , ...) ;
#line 135 "/usr/include/dirent.h"
extern DIR *opendir(char const   *__name ) ;
#line 142
extern int closedir(DIR *__dirp ) ;
#line 158
extern struct dirent *readdir(DIR *__dirp )  __asm__("readdir64")  ;
#line 626 "/usr/include/stdlib.h"
extern char *getenv(char const   *__name ) ;
#line 108 "backupfile.c"
char const   *simple_backup_suffix  =    "~";
#line 110
static int max_backup_version(char const   *file , char const   *dir ) ;
#line 111
static int version_number(char const   *base , char const   *backup , size_t base_length ) ;
#line 118 "backupfile.c"
char *find_backup_file_name(char const   *file , enum backup_type backup_type___0 ) 
{ 
  size_t backup_suffix_size_max ;
  size_t file_len ;
  size_t tmp ;
  size_t numbered_suffix_size_max ;
  char *s ;
  char const   *suffix ;
  size_t tmp___0 ;
  void *tmp___1 ;
  int highest_backup ;
  size_t dir_len ;
  char *tmp___2 ;
  char *numbered_suffix ;

  {
  {
#line 122
  tmp = strlen(file);
#line 122
  file_len = tmp;
#line 123
  numbered_suffix_size_max = (size_t )((((sizeof(int ) * 8UL - 1UL) * 302UL) / 1000UL + 2UL) + 4UL);
#line 125
  suffix = simple_backup_suffix;
#line 128
  tmp___0 = strlen(simple_backup_suffix);
#line 128
  backup_suffix_size_max = tmp___0 + 1U;
  }
#line 129
  if (backup_suffix_size_max < numbered_suffix_size_max) {
#line 130
    backup_suffix_size_max = numbered_suffix_size_max;
  }
  {
#line 132
  tmp___1 = malloc((file_len + backup_suffix_size_max) + numbered_suffix_size_max);
#line 132
  s = (char *)tmp___1;
  }
#line 133
  if (s) {
    {
#line 135
    strcpy((char */* __restrict  */)s, (char const   */* __restrict  */)file);
    }
#line 138
    if ((unsigned int )backup_type___0 != 1U) {
      {
#line 141
      tmp___2 = base_name((char const   *)s);
#line 141
      dir_len = (size_t )(tmp___2 - s);
#line 143
      strcpy((char */* __restrict  */)(s + dir_len), (char const   */* __restrict  */)".");
#line 144
      highest_backup = max_backup_version(file + dir_len, (char const   *)s);
      }
#line 145
      if ((unsigned int )backup_type___0 == 2U) {
#line 145
        if (! (highest_backup == 0)) {
          {
#line 147
          numbered_suffix = s + (file_len + backup_suffix_size_max);
#line 148
          sprintf((char */* __restrict  */)numbered_suffix, (char const   */* __restrict  */)".~%d~",
                  highest_backup + 1);
#line 149
          suffix = (char const   *)numbered_suffix;
          }
        }
      } else {
        {
#line 147
        numbered_suffix = s + (file_len + backup_suffix_size_max);
#line 148
        sprintf((char */* __restrict  */)numbered_suffix, (char const   */* __restrict  */)".~%d~",
                highest_backup + 1);
#line 149
        suffix = (char const   *)numbered_suffix;
        }
      }
      {
#line 151
      strcpy((char */* __restrict  */)s, (char const   */* __restrict  */)file);
      }
    }
    {
#line 155
    addext(s, suffix, '~');
    }
  }
#line 157
  return (s);
}
}
#line 167 "backupfile.c"
static int max_backup_version(char const   *file , char const   *dir ) 
{ 
  DIR *dirp ;
  struct dirent *dp ;
  int highest_version ;
  int this_version ;
  size_t file_name_length ;
  size_t tmp ;
  int tmp___0 ;

  {
  {
#line 176
  dirp = opendir(dir);
  }
#line 177
  if (! dirp) {
#line 178
    return (0);
  }
  {
#line 180
  highest_version = 0;
#line 181
  file_name_length = strlen(file);
  }
  {
#line 183
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 183
    dp = readdir(dirp);
    }
#line 183
    if (! ((unsigned long )dp != (unsigned long )((struct dirent *)0))) {
#line 183
      goto while_break;
    }
#line 185
    if (! (dp->d_ino != 0ULL)) {
#line 186
      goto while_continue;
    } else {
      {
#line 185
      tmp = strlen((char const   *)(dp->d_name));
      }
#line 185
      if (tmp < file_name_length + 4U) {
#line 186
        goto while_continue;
      }
    }
    {
#line 188
    this_version = version_number(file, (char const   *)(dp->d_name), file_name_length);
    }
#line 189
    if (this_version > highest_version) {
#line 190
      highest_version = this_version;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 192
  tmp___0 = closedir(dirp);
  }
#line 192
  if (tmp___0) {
#line 193
    return (0);
  }
#line 194
  return (highest_version);
}
}
#line 201 "backupfile.c"
static int version_number(char const   *base , char const   *backup , size_t base_length ) 
{ 
  int version ;
  char const   *p ;
  int tmp ;

  {
  {
#line 207
  version = 0;
#line 208
  tmp = strncmp(base, backup, base_length);
  }
#line 208
  if (tmp == 0) {
#line 208
    if ((int const   )*(backup + base_length) == 46) {
#line 208
      if ((int const   )*(backup + (base_length + 1U)) == 126) {
#line 212
        p = backup + (base_length + 2U);
        {
#line 212
        while (1) {
          while_continue: /* CIL Label */ ;
#line 212
          if (! ((unsigned int )*p - 48U <= 9U)) {
#line 212
            goto while_break;
          }
#line 213
          version = (version * 10 + (int )*p) - 48;
#line 212
          p ++;
        }
        while_break: /* CIL Label */ ;
        }
#line 214
        if ((int const   )*(p + 0) != 126) {
#line 215
          version = 0;
        } else
#line 214
        if (*(p + 1)) {
#line 215
          version = 0;
        }
      }
    }
  }
#line 217
  return (version);
}
}
#line 221 "backupfile.c"
static char const   * const  backup_args[9]  = 
#line 221
  {      (char const   */* const  */)"none",      (char const   */* const  */)"off",      (char const   */* const  */)"simple",      (char const   */* const  */)"never", 
        (char const   */* const  */)"existing",      (char const   */* const  */)"nil",      (char const   */* const  */)"numbered",      (char const   */* const  */)"t", 
        (char const   */* const  */)0};
#line 232 "backupfile.c"
static enum backup_type  const  backup_types[8]  = 
#line 232
  {      (enum backup_type  const  )0,      (enum backup_type  const  )0,      (enum backup_type  const  )1,      (enum backup_type  const  )1, 
        (enum backup_type  const  )2,      (enum backup_type  const  )2,      (enum backup_type  const  )3,      (enum backup_type  const  )3};
#line 245 "backupfile.c"
enum backup_type get_version(char const   *context , char const   *version ) 
{ 
  int tmp ;

  {
#line 248
  if ((unsigned long )version == (unsigned long )((char const   *)0)) {
#line 249
    return ((enum backup_type )2);
  } else
#line 248
  if ((int const   )*version == 0) {
#line 249
    return ((enum backup_type )2);
  } else {
    {
#line 251
    tmp = __xargmatch_internal(context, version, backup_args, (char const   *)(backup_types),
                               (size_t )sizeof(backup_types[0]), 1, argmatch_die);
    }
#line 251
    return ((enum backup_type )backup_types[tmp]);
  }
}
}
#line 261 "backupfile.c"
enum backup_type xget_version(char const   *context , char const   *version ) 
{ 
  enum backup_type tmp ;
  char *tmp___0 ;
  enum backup_type tmp___1 ;

  {
#line 264
  if (version) {
#line 264
    if (*version) {
      {
#line 265
      tmp = get_version(context, version);
      }
#line 265
      return (tmp);
    } else {
      {
#line 267
      tmp___0 = getenv("VERSION_CONTROL");
#line 267
      tmp___1 = get_version("$VERSION_CONTROL", (char const   *)tmp___0);
      }
#line 267
      return (tmp___1);
    }
  } else {
    {
#line 267
    tmp___0 = getenv("VERSION_CONTROL");
#line 267
    tmp___1 = get_version("$VERSION_CONTROL", (char const   *)tmp___0);
    }
#line 267
    return (tmp___1);
  }
}
}
#line 54 "argmatch.h"
int argmatch(char const   *arg , char const   * const  *arglist , char const   *vallist ,
             size_t valsize ) ;
#line 57
int argcasematch(char const   *arg , char const   * const  *arglist , char const   *vallist ,
                 size_t valsize ) ;
#line 75
void argmatch_invalid(char const   *context , char const   *value , int problem ) ;
#line 87
void argmatch_valid(char const   * const  *arglist , char const   *vallist , size_t valsize ) ;
#line 121
char const   *argmatch_to_argument(char const   *value , char const   * const  *arglist ,
                                   char const   *vallist , size_t valsize ) ;
#line 61 "/usr/include/string.h"
extern int memcmp(void const   *__s1 , void const   *__s2 , size_t __n )  __attribute__((__pure__)) ;
#line 291
extern int strncasecmp(char const   *__s1 , char const   *__s2 , size_t __n )  __attribute__((__pure__)) ;
#line 66 "argmatch.c"
static void __argmatch_die(void) 
{ 


  {
  {
#line 69
  exit(1);
  }
}
}
#line 74 "argmatch.c"
void (*argmatch_die)(void)  =    & __argmatch_die;
#line 89 "argmatch.c"
static int __argmatch_internal(char const   *arg , char const   * const  *arglist ,
                               char const   *vallist , size_t valsize , int case_sensitive ) 
{ 
  int i ;
  size_t arglen ;
  int matchind ;
  int ambiguous ;
  int tmp ;
  size_t tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
  {
#line 96
  matchind = -1;
#line 97
  ambiguous = 0;
#line 99
  arglen = strlen(arg);
#line 102
  i = 0;
  }
  {
#line 102
  while (1) {
    while_continue: /* CIL Label */ ;
#line 102
    if (! *(arglist + i)) {
#line 102
      goto while_break;
    }
#line 104
    if (case_sensitive) {
      {
#line 104
      tmp___1 = strncmp((char const   *)*(arglist + i), arg, arglen);
      }
#line 104
      if (tmp___1) {
#line 104
        tmp___2 = 0;
      } else {
#line 104
        tmp___2 = 1;
      }
#line 104
      tmp___5 = tmp___2;
    } else {
      {
#line 104
      tmp___3 = strncasecmp((char const   *)*(arglist + i), arg, arglen);
      }
#line 104
      if (tmp___3) {
#line 104
        tmp___4 = 0;
      } else {
#line 104
        tmp___4 = 1;
      }
#line 104
      tmp___5 = tmp___4;
    }
#line 104
    if (tmp___5) {
      {
#line 108
      tmp___0 = strlen((char const   *)*(arglist + i));
      }
#line 108
      if (tmp___0 == arglen) {
#line 110
        return (i);
      } else
#line 111
      if (matchind == -1) {
#line 113
        matchind = i;
      } else
#line 117
      if ((unsigned long )vallist == (unsigned long )((void *)0)) {
#line 123
        ambiguous = 1;
      } else {
        {
#line 117
        tmp = memcmp((void const   *)(vallist + valsize * (size_t )matchind), (void const   *)(vallist + valsize * (size_t )i),
                     valsize);
        }
#line 117
        if (tmp) {
#line 123
          ambiguous = 1;
        }
      }
    }
#line 102
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 128
  if (ambiguous) {
#line 129
    return (-2);
  } else {
#line 131
    return (matchind);
  }
}
}
#line 135 "argmatch.c"
int argmatch(char const   *arg , char const   * const  *arglist , char const   *vallist ,
             size_t valsize ) 
{ 
  int tmp ;

  {
  {
#line 139
  tmp = __argmatch_internal(arg, arglist, vallist, valsize, 1);
  }
#line 139
  return (tmp);
}
}
#line 143 "argmatch.c"
int argcasematch(char const   *arg , char const   * const  *arglist , char const   *vallist ,
                 size_t valsize ) 
{ 
  int tmp ;

  {
  {
#line 147
  tmp = __argmatch_internal(arg, arglist, vallist, valsize, 0);
  }
#line 147
  return (tmp);
}
}
#line 155 "argmatch.c"
void argmatch_invalid(char const   *context , char const   *value , int problem ) 
{ 
  enum quoting_style saved_quoting_style ;
  char const   *format ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;

  {
  {
#line 163
  saved_quoting_style = get_quoting_style((struct quoting_options *)((void *)0));
#line 164
  set_quoting_style((struct quoting_options *)((void *)0), (enum quoting_style )4);
  }
#line 166
  if (problem == -1) {
    {
#line 166
    tmp = gettext("invalid argument `%s\' for `%s\'");
#line 166
    format = (char const   *)tmp;
    }
  } else {
    {
#line 166
    tmp___0 = gettext("ambiguous argument `%s\' for `%s\'");
#line 166
    format = (char const   *)tmp___0;
    }
  }
  {
#line 170
  tmp___1 = quotearg(value);
#line 170
  error(0, 0, format, tmp___1, context);
#line 172
  set_quoting_style((struct quoting_options *)((void *)0), saved_quoting_style);
  }
#line 173
  return;
}
}
#line 179 "argmatch.c"
void argmatch_valid(char const   * const  *arglist , char const   *vallist , size_t valsize ) 
{ 
  int i ;
  char const   *last_val ;
  char *tmp ;
  int tmp___0 ;

  {
  {
#line 184
  last_val = (char const   *)((void *)0);
#line 188
  tmp = gettext("Valid arguments are:");
#line 188
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp);
#line 189
  i = 0;
  }
  {
#line 189
  while (1) {
    while_continue: /* CIL Label */ ;
#line 189
    if (! *(arglist + i)) {
#line 189
      goto while_break;
    }
#line 190
    if (i == 0) {
      {
#line 193
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n  - `%s\'",
              *(arglist + i));
#line 194
      last_val = vallist + valsize * (size_t )i;
      }
    } else {
      {
#line 190
      tmp___0 = memcmp((void const   *)last_val, (void const   *)(vallist + valsize * (size_t )i),
                       valsize);
      }
#line 190
      if (tmp___0) {
        {
#line 193
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n  - `%s\'",
                *(arglist + i));
#line 194
        last_val = vallist + valsize * (size_t )i;
        }
      } else {
        {
#line 198
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)", `%s\'",
                *(arglist + i));
        }
      }
    }
#line 189
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 200
  _IO_putc('\n', stderr);
  }
#line 201
  return;
}
}
#line 209 "argmatch.c"
int __xargmatch_internal(char const   *context , char const   *arg , char const   * const  *arglist ,
                         char const   *vallist , size_t valsize , int case_sensitive ,
                         void (*exit_fn)(void) ) 
{ 
  int res ;
  int tmp ;

  {
  {
#line 216
  tmp = __argmatch_internal(arg, arglist, vallist, valsize, case_sensitive);
#line 216
  res = tmp;
  }
#line 219
  if (res >= 0) {
#line 221
    return (res);
  }
  {
#line 224
  argmatch_invalid(context, arg, res);
#line 225
  argmatch_valid(arglist, vallist, valsize);
#line 226
  (*exit_fn)();
  }
#line 228
  return (-1);
}
}
#line 233 "argmatch.c"
char const   *argmatch_to_argument(char const   *value , char const   * const  *arglist ,
                                   char const   *vallist , size_t valsize ) 
{ 
  int i ;
  int tmp ;

  {
#line 240
  i = 0;
  {
#line 240
  while (1) {
    while_continue: /* CIL Label */ ;
#line 240
    if (! *(arglist + i)) {
#line 240
      goto while_break;
    }
    {
#line 241
    tmp = memcmp((void const   *)value, (void const   *)(vallist + valsize * (size_t )i),
                 valsize);
    }
#line 241
    if (! tmp) {
#line 242
      return ((char const   *)*(arglist + i));
    }
#line 240
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 243
  return ((char const   *)((void *)0));
}
}
#line 57 "addext.c"
void addext(char *filename , char const   *ext , int e ) 
{ 
  char *s ;
  char *tmp ;
  size_t slen ;
  size_t tmp___0 ;
  size_t extlen ;
  size_t tmp___1 ;
  long slen_max ;

  {
  {
#line 60
  tmp = base_name((char const   *)filename);
#line 60
  s = tmp;
#line 61
  tmp___0 = strlen((char const   *)s);
#line 61
  slen = tmp___0;
#line 61
  tmp___1 = strlen(ext);
#line 61
  extlen = tmp___1;
#line 62
  slen_max = -1L;
  }
#line 78
  if (slen_max < 0L) {
#line 79
    slen_max = 14L;
  }
#line 96
  if ((long )(slen + extlen) <= slen_max) {
    {
#line 97
    strcpy((char */* __restrict  */)(s + slen), (char const   */* __restrict  */)ext);
    }
  } else {
#line 100
    if (slen_max <= (long )slen) {
#line 101
      slen = (size_t )(slen_max - 1L);
    }
#line 102
    *(s + slen) = (char )e;
#line 103
    *(s + (slen + 1U)) = (char)0;
  }
#line 105
  return;
}
}
#line 75 "/usr/include/fcntl.h"
extern int open(char const   *__file , int __oflag  , ...)  __asm__("open64")  ;
#line 305 "/usr/include/unistd.h"
extern int close(int __fd ) ;
#line 50 "common.h"
int exit_status ;
#line 101
enum subcommand subcommand_option ;
#line 172
int interactive_option ;
#line 276
char *current_file_name ;
#line 336
size_t available_space_after(union block *pointer ) ;
#line 338
void close_archive(void) ;
#line 340
union block *find_next_block(void) ;
#line 346
void open_archive(enum access_mode access___0 ) ;
#line 348
void reset_eof(void) ;
#line 349
void set_next_block_after(union block *block ) ;
#line 354
void dump_file(char *p , dev_t parent_device , int top_level ) ;
#line 356
void write_eot(void) ;
#line 415
union block *current_header ;
#line 416
struct stat current_stat ;
#line 419
void decode_header(union block *header , struct stat *stat_info , enum archive_format *format_pointer ,
                   int do_user_group ) ;
#line 423
char *stringify_uintmax_t_backwards(uintmax_t o___0 , char *buf ) ;
#line 449
enum read_header read_header(void) ;
#line 450
void skip_extended_headers(void) ;
#line 451
void skip_file(off_t size ) ;
#line 483
void name_gather(void) ;
#line 486
void names_notfound(void) ;
#line 487
void name_expand(void) ;
#line 488
struct name *name_scan(char const   *path___0 ) ;
#line 489
char *name_from_list(void) ;
#line 495
int confirm(char const   *message_action , char const   *message_name ) ;
#line 500 "common.h"
char *output_start  ;
#line 502
void update_archive(void) ;
#line 28 "update.c"
union block *current_block ;
#line 33 "update.c"
int time_to_start_writing  =    0;
#line 45 "update.c"
static void append_file(char *path___0 ) 
{ 
  int handle ;
  struct stat stat_data ;
  off_t bytes_left ;
  char *tmp ;
  int *tmp___0 ;
  int tmp___1 ;
  union block *start ;
  union block *tmp___2 ;
  size_t buffer_size ;
  size_t tmp___3 ;
  ssize_t status ;
  char buf[(((sizeof(uintmax_t ) * 8UL) * 302UL) / 1000UL + 1UL) + 1UL] ;
  char *tmp___4 ;
  char *tmp___5 ;
  int *tmp___6 ;
  char *tmp___7 ;
  char buf___0[(((sizeof(uintmax_t ) * 8UL) * 302UL) / 1000UL + 1UL) + 1UL] ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;

  {
  {
#line 52
  tmp___1 = stat((char const   */* __restrict  */)path___0, (struct stat */* __restrict  */)(& stat_data));
  }
#line 52
  if (tmp___1 != 0) {
    {
#line 55
    tmp = gettext("Cannot open file %s");
#line 55
    tmp___0 = __errno_location();
#line 55
    error(0, *tmp___0, (char const   *)tmp, path___0);
#line 55
    exit_status = 2;
    }
#line 56
    return;
  } else {
    {
#line 52
    handle = open((char const   *)path___0, 0);
    }
#line 52
    if (handle < 0) {
      {
#line 55
      tmp = gettext("Cannot open file %s");
#line 55
      tmp___0 = __errno_location();
#line 55
      error(0, *tmp___0, (char const   *)tmp, path___0);
#line 55
      exit_status = 2;
      }
#line 56
      return;
    }
  }
#line 59
  bytes_left = stat_data.st_size;
  {
#line 61
  while (1) {
    while_continue: /* CIL Label */ ;
#line 61
    if (! (bytes_left > 0LL)) {
#line 61
      goto while_break;
    }
    {
#line 63
    tmp___2 = find_next_block();
#line 63
    start = tmp___2;
#line 64
    tmp___3 = available_space_after(start);
#line 64
    buffer_size = tmp___3;
    }
#line 67
    if (bytes_left < (off_t )buffer_size) {
#line 69
      buffer_size = (size_t )bytes_left;
#line 70
      status = (ssize_t )(buffer_size % 512U);
#line 71
      if (status) {
        {
#line 72
        memset((void *)(start->buffer + bytes_left), 0, (size_t )(512 - status));
        }
      }
    }
    {
#line 76
    status = safe_read(handle, (void *)(start->buffer), buffer_size);
    }
#line 77
    if (status < 0) {
      {
#line 80
      tmp___4 = stringify_uintmax_t_backwards((uintmax_t )(stat_data.st_size - bytes_left),
                                              buf + sizeof(buf));
#line 80
      tmp___5 = gettext("Read error at byte %s reading %lu bytes in file %s");
#line 80
      tmp___6 = __errno_location();
#line 80
      error(0, *tmp___6, (char const   *)tmp___5, tmp___4, (unsigned long )buffer_size,
            path___0);
#line 80
      tmp___7 = gettext("Error is not recoverable: exiting now");
#line 80
      error(2, 0, (char const   *)tmp___7);
      }
    }
    {
#line 85
    bytes_left -= (off_t )status;
#line 87
    set_next_block_after(start + (status - 1) / 512);
    }
#line 89
    if ((size_t )status != buffer_size) {
      {
#line 92
      tmp___8 = stringify_uintmax_t_backwards((uintmax_t )bytes_left, buf___0 + sizeof(buf___0));
#line 92
      tmp___9 = gettext("%s: File shrunk by %s bytes, (yark!)");
#line 92
      error(0, 0, (char const   *)tmp___9, path___0, tmp___8);
#line 92
      tmp___10 = gettext("Error is not recoverable: exiting now");
#line 92
      error(2, 0, (char const   *)tmp___10);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 97
  close(handle);
  }
#line 98
  return;
}
}
#line 106 "update.c"
void update_archive(void) 
{ 
  enum read_header previous_status ;
  int found_end ;
  enum read_header status ;
  enum read_header tmp ;
  struct name *name ;
  struct stat stat_data ;
  enum archive_format unused ;
  char *tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *path___0 ;
  int tmp___5 ;

  {
  {
#line 109
  previous_status = (enum read_header )0;
#line 110
  found_end = 0;
#line 112
  name_gather();
  }
#line 113
  if ((unsigned int )subcommand_option == 8U) {
    {
#line 114
    name_expand();
    }
  }
  {
#line 115
  open_archive((enum access_mode )2);
  }
  {
#line 117
  while (1) {
    while_continue: /* CIL Label */ ;
#line 117
    if (! (! found_end)) {
#line 117
      goto while_break;
    }
    {
#line 119
    tmp = read_header();
#line 119
    status = tmp;
    }
    {
#line 123
    if ((unsigned int )status == 0U) {
#line 123
      goto case_0;
    }
#line 126
    if ((unsigned int )status == 1U) {
#line 126
      goto case_1;
    }
#line 149
    if ((unsigned int )status == 2U) {
#line 149
      goto case_2;
    }
#line 154
    if ((unsigned int )status == 3U) {
#line 154
      goto case_3;
    }
#line 158
    if ((unsigned int )status == 4U) {
#line 158
      goto case_4;
    }
#line 121
    goto switch_break;
    case_0: /* CIL Label */ 
    {
#line 124
    abort();
    }
    case_1: /* CIL Label */ 
#line 130
    if ((unsigned int )subcommand_option == 8U) {
      {
#line 130
      name = name_scan((char const   *)current_file_name);
      }
#line 130
      if (name) {
        {
#line 136
        decode_header(current_header, & current_stat, & unused, 0);
#line 137
        tmp___2 = stat((char const   */* __restrict  */)current_file_name, (struct stat */* __restrict  */)(& stat_data));
        }
#line 137
        if (tmp___2 < 0) {
          {
#line 138
          tmp___0 = gettext("Cannot stat %s");
#line 138
          tmp___1 = __errno_location();
#line 138
          error(0, *tmp___1, (char const   *)tmp___0, current_file_name);
#line 138
          exit_status = 2;
          }
        } else
#line 139
        if (current_stat.st_mtim.tv_sec >= stat_data.st_mtim.tv_sec) {
#line 140
          name->found = (char)1;
        }
      }
    }
    {
#line 142
    set_next_block_after(current_header);
    }
#line 143
    if (current_header->oldgnu_header.isextended) {
      {
#line 144
      skip_extended_headers();
      }
    }
    {
#line 145
    skip_file(current_stat.st_size);
    }
#line 146
    goto switch_break;
    case_2: /* CIL Label */ 
#line 150
    current_block = current_header;
#line 151
    found_end = 1;
#line 152
    goto switch_break;
    case_3: /* CIL Label */ 
#line 155
    found_end = 1;
#line 156
    goto switch_break;
    case_4: /* CIL Label */ 
    {
#line 159
    set_next_block_after(current_header);
    }
    {
#line 162
    if ((unsigned int )previous_status == 0U) {
#line 162
      goto case_0___0;
    }
#line 167
    if ((unsigned int )previous_status == 2U) {
#line 167
      goto case_2___0;
    }
#line 167
    if ((unsigned int )previous_status == 1U) {
#line 167
      goto case_2___0;
    }
#line 171
    if ((unsigned int )previous_status == 4U) {
#line 171
      goto case_4___0;
    }
#line 174
    if ((unsigned int )previous_status == 3U) {
#line 174
      goto case_3___0;
    }
#line 160
    goto switch_break___0;
    case_0___0: /* CIL Label */ 
    {
#line 163
    tmp___3 = gettext("This does not look like a tar archive");
#line 163
    error(0, 0, (char const   *)tmp___3);
    }
    case_2___0: /* CIL Label */ 
    case_1___0: /* CIL Label */ 
    {
#line 168
    tmp___4 = gettext("Skipping to next header");
#line 168
    error(0, 0, (char const   *)tmp___4);
#line 168
    exit_status = 2;
    }
    case_4___0: /* CIL Label */ 
#line 172
    goto switch_break___0;
    case_3___0: /* CIL Label */ 
    {
#line 175
    abort();
    }
    switch_break___0: /* CIL Label */ ;
    }
#line 177
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 180
    previous_status = status;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 183
  reset_eof();
#line 184
  time_to_start_writing = 1;
#line 185
  output_start = current_block->buffer;
  }
  {
#line 190
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 190
    path___0 = name_from_list();
    }
#line 190
    if (! path___0) {
#line 190
      goto while_break___0;
    }
#line 192
    if (interactive_option) {
      {
#line 192
      tmp___5 = confirm("add", (char const   *)path___0);
      }
#line 192
      if (! tmp___5) {
#line 193
        goto while_continue___0;
      }
    }
#line 194
    if ((unsigned int )subcommand_option == 2U) {
      {
#line 195
      append_file(path___0);
      }
    } else {
      {
#line 197
      dump_file(path___0, (dev_t )-1, 1);
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 201
  write_eot();
#line 202
  close_archive();
#line 203
  names_notfound();
  }
#line 204
  return;
}
}
#line 36 "../lib/getopt.h"
extern char *optarg ;
#line 90 "/usr/include/signal.h"
extern __sighandler_t signal(int __sig , void (*__handler)(int  ) ) ;
#line 327 "/usr/include/stdio.h"
extern int printf(char const   * __restrict  __format  , ...) ;
#line 583
extern int fputs(char const   * __restrict  __s , FILE * __restrict  __stream ) ;
#line 125 "/usr/include/locale.h"
extern char *setlocale(int __category , char const   *__locale ) ;
#line 81 "/usr/include/libintl.h"
extern char *textdomain(char const   *__domainname ) ;
#line 85
extern char *bindtextdomain(char const   *__domainname , char const   *__dirname ) ;
#line 140 "../lib/getopt.h"
extern int getopt_long(int __argc , char * const  *__argv , char const   *__shortopts ,
                       struct option  const  *__longopts , int *__longind ) ;
#line 50 "common.h"
int exit_status  ;
#line 84 "common.h"
char const   *program_name  ;
#line 101 "common.h"
enum subcommand subcommand_option  ;
#line 104 "common.h"
enum archive_format archive_format  ;
#line 107 "common.h"
char filename_terminator  ;
#line 113 "common.h"
int blocking_factor  ;
#line 114 "common.h"
size_t record_size  ;
#line 117 "common.h"
int absolute_names_option  ;
#line 123 "common.h"
int after_date_option  ;
#line 126 "common.h"
int atime_preserve_option  ;
#line 129 "common.h"
int backup_option  ;
#line 132 "common.h"
enum backup_type backup_type  ;
#line 135 "common.h"
int block_number_option  ;
#line 138 "common.h"
int checkpoint_option  ;
#line 141 "common.h"
char const   *use_compress_program_option  ;
#line 144 "common.h"
int dereference_option  ;
#line 147 "common.h"
struct exclude *excluded  ;
#line 150 "common.h"
char const   *files_from_option  ;
#line 153 "common.h"
int force_local_option  ;
#line 157 "common.h"
gid_t group_option  ;
#line 160 "common.h"
int ignore_failed_read_option  ;
#line 163 "common.h"
int ignore_zeros_option  ;
#line 166 "common.h"
int incremental_option  ;
#line 169 "common.h"
char const   *info_script_option  ;
#line 172 "common.h"
int interactive_option  ;
#line 175 "common.h"
int keep_old_files_option  ;
#line 178 "common.h"
char const   *listed_incremental_option  ;
#line 181 "common.h"
struct mode_change *mode_option  ;
#line 184 "common.h"
int multi_volume_option  ;
#line 193 "common.h"
time_t newer_mtime_option  ;
#line 196 "common.h"
int no_recurse_option  ;
#line 199 "common.h"
int numeric_owner_option  ;
#line 202 "common.h"
int one_file_system_option  ;
#line 206 "common.h"
uid_t owner_option  ;
#line 209 "common.h"
int recursive_unlink_option  ;
#line 212 "common.h"
int read_full_records_option  ;
#line 215 "common.h"
int remove_files_option  ;
#line 218 "common.h"
char const   *rsh_command_option  ;
#line 221 "common.h"
int same_order_option  ;
#line 224 "common.h"
int same_owner_option  ;
#line 227 "common.h"
int same_permissions_option  ;
#line 230 "common.h"
int show_omitted_dirs_option  ;
#line 233 "common.h"
int sparse_option  ;
#line 236 "common.h"
int starting_file_option  ;
#line 239 "common.h"
tarlong tape_length_option  ;
#line 242 "common.h"
int to_stdout_option  ;
#line 245 "common.h"
int totals_option  ;
#line 248 "common.h"
int touch_option  ;
#line 251 "common.h"
int unlink_first_option  ;
#line 256 "common.h"
int verbose_option  ;
#line 259 "common.h"
int verify_option  ;
#line 262 "common.h"
char const   *volno_file_option  ;
#line 265 "common.h"
char const   *volume_label_option  ;
#line 270 "common.h"
int archive  ;
#line 273 "common.h"
int dev_null_output  ;
#line 276 "common.h"
char *current_file_name  ;
#line 279 "common.h"
char *current_link_name  ;
#line 283 "common.h"
char const   **archive_name_array  ;
#line 284 "common.h"
int archive_names  ;
#line 285 "common.h"
int allocated_archive_names  ;
#line 286 "common.h"
char const   **archive_name_cursor  ;
#line 301 "common.h"
struct name *namelist  ;
#line 302 "common.h"
struct name *namelast  ;
#line 310 "common.h"
struct sp_array *sparsearray  ;
#line 313 "common.h"
int sp_array_size  ;
#line 330
FILE *stdlis ;
#line 339
void closeout_volume_number(void) ;
#line 344
void init_total_written(void) ;
#line 345
void init_volume_number(void) ;
#line 347
void print_total_written(void) ;
#line 353
void create_archive(void) ;
#line 382
void diff_archive(void) ;
#line 383
void diff_init(void) ;
#line 388
void extr_init(void) ;
#line 389
void extract_archive(void) ;
#line 394
void delete_archive_members(void) ;
#line 445
void list_archive(void) ;
#line 448
void read_and(void (*do_something)() ) ;
#line 473
int gname_to_gid(char *gname , gid_t *gidp ) ;
#line 475
int uname_to_uid(char *uname , uid_t *uidp ) ;
#line 477
void init_names(void) ;
#line 478
void name_add(char const   *name ) ;
#line 479
void name_init(int argc , char * const  *argv ) ;
#line 480
void name_term(void) ;
#line 482
void name_close(void) ;
#line 484
void addname(char const   *string ) ;
#line 496
void request_stdin(char const   *option ) ;
#line 49 "tar.c"
static void usage(int status ) ;
#line 58 "tar.c"
static char const   *stdin_used_by  =    (char const   *)((void *)0);
#line 60 "tar.c"
void request_stdin(char const   *option ) 
{ 
  char *tmp ;

  {
#line 63
  if (stdin_used_by) {
    {
#line 64
    tmp = gettext("Options `-%s\' and `-%s\' both want standard input");
#line 64
    error(0, 0, (char const   *)tmp, stdin_used_by, option);
#line 64
    usage(2);
    }
  }
#line 67
  stdin_used_by = option;
#line 68
  return;
}
}
#line 77 "tar.c"
static FILE *confirm_file  =    (FILE *)((void *)0);
#line 74 "tar.c"
int confirm(char const   *message_action , char const   *message_name ) 
{ 
  char *tmp ;
  char *tmp___0 ;
  int reply ;
  int tmp___1 ;
  int character ;
  int tmp___2 ;

  {
#line 79
  if (! confirm_file) {
#line 81
    if (archive == 0) {
      {
#line 82
      confirm_file = fopen((char const   */* __restrict  */)"/dev/tty", (char const   */* __restrict  */)"r");
      }
    } else
#line 81
    if (stdin_used_by) {
      {
#line 82
      confirm_file = fopen((char const   */* __restrict  */)"/dev/tty", (char const   */* __restrict  */)"r");
      }
    } else {
      {
#line 85
      request_stdin("-w");
#line 86
      confirm_file = stdin;
      }
    }
#line 89
    if (! confirm_file) {
      {
#line 90
      tmp = gettext("Cannot read confirmation from user");
#line 90
      error(0, 0, (char const   *)tmp);
#line 90
      tmp___0 = gettext("Error is not recoverable: exiting now");
#line 90
      error(2, 0, (char const   *)tmp___0);
      }
    }
  }
  {
#line 93
  fprintf((FILE */* __restrict  */)stdlis, (char const   */* __restrict  */)"%s %s?",
          message_action, message_name);
#line 94
  fflush(stdlis);
#line 97
  tmp___1 = _IO_getc(confirm_file);
#line 97
  reply = tmp___1;
#line 100
  character = reply;
  }
  {
#line 100
  while (1) {
    while_continue: /* CIL Label */ ;
#line 100
    if (character != 10) {
#line 100
      if (! (character != -1)) {
#line 100
        goto while_break;
      }
    } else {
#line 100
      goto while_break;
    }
#line 103
    goto __Cont;
    __Cont: /* CIL Label */ 
    {
#line 100
    character = _IO_getc(confirm_file);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 104
  if (reply == 121) {
#line 104
    tmp___2 = 1;
  } else
#line 104
  if (reply == 89) {
#line 104
    tmp___2 = 1;
  } else {
#line 104
    tmp___2 = 0;
  }
#line 104
  return (tmp___2);
}
}
#line 150 "tar.c"
static int show_help  =    0;
#line 153 "tar.c"
static int show_version  =    0;
#line 155 "tar.c"
struct option long_options[87]  = 
#line 155
  {      {"absolute-names", 0, (int *)((void *)0), 'P'}, 
        {"absolute-paths", 0, (int *)((void *)0), 144}, 
        {"after-date", 1, (int *)((void *)0), 'N'}, 
        {"append", 0, (int *)((void *)0), 'r'}, 
        {"atime-preserve", 0, & atime_preserve_option, 1}, 
        {"backup", 2, (int *)((void *)0), 128}, 
        {"block-compress", 0, (int *)((void *)0), 145}, 
        {"block-number", 0, (int *)((void *)0), 'R'}, 
        {"block-size", 1, (int *)((void *)0), 146}, 
        {"blocking-factor", 1, (int *)((void *)0), 'b'}, 
        {"catenate", 0, (int *)((void *)0), 'A'}, 
        {"checkpoint", 0, & checkpoint_option, 1}, 
        {"compare", 0, (int *)((void *)0), 'd'}, 
        {"compress", 0, (int *)((void *)0), 'Z'}, 
        {"concatenate", 0, (int *)((void *)0), 'A'}, 
        {"confirmation", 0, (int *)((void *)0), 'w'}, 
        {"create", 0, (int *)((void *)0), 'c'}, 
        {"delete", 0, (int *)((void *)0), 129}, 
        {"dereference", 0, (int *)((void *)0), 'h'}, 
        {"diff", 0, (int *)((void *)0), 'd'}, 
        {"directory", 1, (int *)((void *)0), 'C'}, 
        {"exclude", 1, (int *)((void *)0), 130}, 
        {"exclude-from", 1, (int *)((void *)0), 'X'}, 
        {"extract", 0, (int *)((void *)0), 'x'}, 
        {"file", 1, (int *)((void *)0), 'f'}, 
        {"files-from", 1, (int *)((void *)0), 'T'}, 
        {"force-local", 0, & force_local_option, 1}, 
        {"get", 0, (int *)((void *)0), 'x'}, 
        {"group", 1, (int *)((void *)0), 131}, 
        {"gunzip", 0, (int *)((void *)0), 'z'}, 
        {"gzip", 0, (int *)((void *)0), 'z'}, 
        {"help", 0, & show_help, 1}, 
        {"ignore-failed-read", 0, & ignore_failed_read_option, 1}, 
        {"ignore-zeros", 0, (int *)((void *)0), 'i'}, 
        {"incremental", 0, (int *)((void *)0), 'G'}, 
        {"info-script", 1, (int *)((void *)0), 'F'}, 
        {"interactive", 0, (int *)((void *)0), 'w'}, 
        {"keep-old-files", 0, (int *)((void *)0), 'k'}, 
        {"label", 1, (int *)((void *)0), 'V'}, 
        {"list", 0, (int *)((void *)0), 't'}, 
        {"listed-incremental", 1, (int *)((void *)0), 'g'}, 
        {"mode", 1, (int *)((void *)0), 132}, 
        {"modification-time", 0, (int *)((void *)0), 149}, 
        {"multi-volume", 0, (int *)((void *)0), 'M'}, 
        {"new-volume-script", 1, (int *)((void *)0), 'F'}, 
        {"newer", 1, (int *)((void *)0), 'N'}, 
        {"newer-mtime", 1, (int *)((void *)0), 133}, 
        {"null", 0, (int *)((void *)0), 135}, 
        {"no-recursion", 0, (int *)((void *)0), 134}, 
        {"numeric-owner", 0, & numeric_owner_option, 1}, 
        {"old-archive", 0, (int *)((void *)0), 'o'}, 
        {"one-file-system", 0, (int *)((void *)0), 'l'}, 
        {"owner", 1, (int *)((void *)0), 136}, 
        {"portability", 0, (int *)((void *)0), 'o'}, 
        {"posix", 0, (int *)((void *)0), 137}, 
        {"preserve", 0, (int *)((void *)0), 138}, 
        {"preserve-order", 0, (int *)((void *)0), 's'}, 
        {"preserve-permissions", 0, (int *)((void *)0), 'p'}, 
        {"recursive-unlink", 0, & recursive_unlink_option, 1}, 
        {"read-full-blocks", 0, (int *)((void *)0), 148}, 
        {"read-full-records", 0, (int *)((void *)0), 'B'}, 
        {"record-number", 0, (int *)((void *)0), 147}, 
        {"record-size", 1, (int *)((void *)0), 139}, 
        {"remove-files", 0, & remove_files_option, 1}, 
        {"rsh-command", 1, (int *)((void *)0), 140}, 
        {"same-order", 0, (int *)((void *)0), 's'}, 
        {"same-owner", 0, & same_owner_option, 1}, 
        {"same-permissions", 0, (int *)((void *)0), 'p'}, 
        {"show-omitted-dirs", 0, & show_omitted_dirs_option, 1}, 
        {"sparse", 0, (int *)((void *)0), 'S'}, 
        {"starting-file", 1, (int *)((void *)0), 'K'}, 
        {"suffix", 1, (int *)((void *)0), 141}, 
        {"tape-length", 1, (int *)((void *)0), 'L'}, 
        {"to-stdout", 0, (int *)((void *)0), 'O'}, 
        {"totals", 0, & totals_option, 1}, 
        {"touch", 0, (int *)((void *)0), 'm'}, 
        {"uncompress", 0, (int *)((void *)0), 'Z'}, 
        {"ungzip", 0, (int *)((void *)0), 'z'}, 
        {"unlink-first", 0, (int *)((void *)0), 'U'}, 
        {"update", 0, (int *)((void *)0), 'u'}, 
        {"use-compress-program", 1, (int *)((void *)0), 142}, 
        {"verbose", 0, (int *)((void *)0), 'v'}, 
        {"verify", 0, (int *)((void *)0), 'W'}, 
        {"version", 0, & show_version, 1}, 
        {"version-control", 1, (int *)((void *)0), 150}, 
        {"volno-file", 1, (int *)((void *)0), 143}, 
        {(char const   *)0, 0, (int *)0, 0}};
#line 254 "tar.c"
static void usage(int status ) 
{ 
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;
  char *tmp___14 ;
  char *tmp___15 ;

  {
#line 257
  if (status != 0) {
    {
#line 258
    tmp = gettext("Try `%s --help\' for more information.\n");
#line 258
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp,
            program_name);
    }
  } else {
    {
#line 262
    tmp___0 = gettext("GNU `tar\' saves many files together into a single tape or disk archive, and\ncan restore individual files from the archive.\n");
#line 262
    fputs((char const   */* __restrict  */)tmp___0, (FILE */* __restrict  */)stdout);
#line 266
    tmp___1 = gettext("\nUsage: %s [OPTION]... [FILE]...\n");
#line 266
    printf((char const   */* __restrict  */)tmp___1, program_name);
#line 267
    tmp___2 = gettext("\nIf a long option shows an argument as mandatory, then it is mandatory\nfor the equivalent short option also.  Similarly for optional arguments.\n");
#line 267
    fputs((char const   */* __restrict  */)tmp___2, (FILE */* __restrict  */)stdout);
#line 272
    tmp___3 = gettext("\nMain operation mode:\n  -t, --list              list the contents of an archive\n  -x, --extract, --get    extract files from an archive\n  -c, --create            create a new archive\n  -d, --diff, --compare   find differences between archive and file system\n  -r, --append            append files to the end of an archive\n  -u, --update            only append files newer than copy in archive\n  -A, --catenate          append tar files to an archive\n      --concatenate       same as -A\n      --delete            delete from the archive (not on mag tapes!)\n");
#line 272
    fputs((char const   */* __restrict  */)tmp___3, (FILE */* __restrict  */)stdout);
#line 285
    tmp___4 = gettext("\nOperation modifiers:\n  -W, --verify               attempt to verify the archive after writing it\n      --remove-files         remove files after adding them to the archive\n  -k, --keep-old-files       don\'t overwrite existing files when extracting\n  -U, --unlink-first         remove each file prior to extracting over it\n      --recursive-unlink     empty hierarchies prior to extracting directory\n  -S, --sparse               handle sparse files efficiently\n  -O, --to-stdout            extract files to standard output\n  -G, --incremental          handle old GNU-format incremental backup\n  -g, --listed-incremental   handle new GNU-format incremental backup\n      --ignore-failed-read   do not exit with nonzero on unreadable files\n");
#line 285
    fputs((char const   */* __restrict  */)tmp___4, (FILE */* __restrict  */)stdout);
#line 299
    tmp___5 = gettext("\nHandling of file attributes:\n      --owner=NAME             force NAME as owner for added files\n      --group=NAME             force NAME as group for added files\n      --mode=CHANGES           force (symbolic) mode CHANGES for added files\n      --atime-preserve         don\'t change access times on dumped files\n  -m, --modification-time      don\'t extract file modified time\n      --same-owner             try extracting files with the same ownership\n      --numeric-owner          always use numbers for user/group names\n  -p, --same-permissions       extract all protection information\n      --preserve-permissions   same as -p\n  -s, --same-order             sort names to extract to match archive\n      --preserve-order         same as -s\n      --preserve               same as both -p and -s\n");
#line 299
    fputs((char const   */* __restrict  */)tmp___5, (FILE */* __restrict  */)stdout);
#line 315
    tmp___6 = gettext("\nDevice selection and switching:\n  -f, --file=ARCHIVE             use archive file or device ARCHIVE\n      --force-local              archive file is local even if has a colon\n      --rsh-command=COMMAND      use remote COMMAND instead of rsh\n  -[0-7][lmh]                    specify drive and density\n  -M, --multi-volume             create/list/extract multi-volume archive\n  -L, --tape-length=NUM          change tape after writing NUM x 1024 bytes\n  -F, --info-script=FILE         run script at end of each tape (implies -M)\n      --new-volume-script=FILE   same as -F FILE\n      --volno-file=FILE          use/update the volume number in FILE\n");
#line 315
    fputs((char const   */* __restrict  */)tmp___6, (FILE */* __restrict  */)stdout);
#line 328
    tmp___7 = gettext("\nDevice blocking:\n  -b, --blocking-factor=BLOCKS   BLOCKS x 512 bytes per record\n      --record-size=SIZE         SIZE bytes per record, multiple of 512\n  -i, --ignore-zeros             ignore zeroed blocks in archive (means EOF)\n  -B, --read-full-records        reblock as we read (for 4.2BSD pipes)\n");
#line 328
    fputs((char const   */* __restrict  */)tmp___7, (FILE */* __restrict  */)stdout);
#line 336
    tmp___8 = gettext("\nArchive format selection:\n  -V, --label=NAME                   create archive with volume name NAME\n              PATTERN                at list/extract time, a globbing PATTERN\n  -o, --old-archive, --portability   write a V7 format archive\n      --posix                        write a POSIX conformant archive\n  -z, --gzip, --ungzip               filter the archive through gzip\n  -Z, --compress, --uncompress       filter the archive through compress\n      --use-compress-program=PROG    filter through PROG (must accept -d)\n");
#line 336
    fputs((char const   */* __restrict  */)tmp___8, (FILE */* __restrict  */)stdout);
#line 347
    tmp___9 = gettext("\nLocal file selection:\n  -C, --directory=DIR          change to directory DIR\n  -T, --files-from=NAME        get names to extract or create from file NAME\n      --null                   -T reads null-terminated names, disable -C\n      --exclude=PATTERN        exclude files, given as a globbing PATTERN\n  -X, --exclude-from=FILE      exclude globbing patterns listed in FILE\n  -P, --absolute-names         don\'t strip leading `/\'s from file names\n  -h, --dereference            dump instead the files symlinks point to\n      --no-recursion           avoid descending automatically in directories\n  -l, --one-file-system        stay in local file system when creating archive\n  -K, --starting-file=NAME     begin at file NAME in the archive\n");
#line 347
    fputs((char const   */* __restrict  */)tmp___9, (FILE */* __restrict  */)stdout);
#line 362
    tmp___10 = gettext("  -N, --newer=DATE             only store files newer than DATE\n      --newer-mtime            compare date and time when data changed only\n      --after-date=DATE        same as -N\n");
#line 362
    fputs((char const   */* __restrict  */)tmp___10, (FILE */* __restrict  */)stdout);
#line 368
    tmp___11 = gettext("      --backup[=CONTROL]       backup before removal, choose version control\n      --suffix=SUFFIX          backup before removel, override usual suffix\n");
#line 368
    fputs((char const   */* __restrict  */)tmp___11, (FILE */* __restrict  */)stdout);
#line 372
    tmp___12 = gettext("\nInformative output:\n      --help            print this help, then exit\n      --version         print tar program version number, then exit\n  -v, --verbose         verbosely list files processed\n      --checkpoint      print directory names while reading the archive\n      --totals          print total bytes written while creating archive\n  -R, --block-number    show block number within archive with each message\n  -w, --interactive     ask for confirmation for every action\n      --confirmation    same as -w\n");
#line 372
    fputs((char const   */* __restrict  */)tmp___12, (FILE */* __restrict  */)stdout);
#line 384
    tmp___13 = gettext("\nThe backup suffix is `~\', unless set with --suffix or SIMPLE_BACKUP_SUFFIX.\nThe version control may be set with --backup or VERSION_CONTROL, values are:\n\n  t, numbered     make numbered backups\n  nil, existing   numbered if numbered backups exist, simple otherwise\n  never, simple   always make simple backups\n");
#line 384
    fputs((char const   */* __restrict  */)tmp___13, (FILE */* __restrict  */)stdout);
#line 393
    tmp___14 = gettext("\nGNU tar cannot read nor produce `--posix\' archives.  If POSIXLY_CORRECT\nis set in the environment, GNU extensions are disallowed with `--posix\'.\nSupport for POSIX is only partially implemented, don\'t count on it yet.\nARCHIVE may be FILE, HOST:FILE or USER@HOST:FILE; and FILE may be a file\nor a device.  *This* `tar\' defaults to `-f%s -b%d\'.\n");
#line 393
    printf((char const   */* __restrict  */)tmp___14, "-", 20);
#line 401
    tmp___15 = gettext("\nReport bugs to <tar-bugs@gnu.org>.\n");
#line 401
    fputs((char const   */* __restrict  */)tmp___15, (FILE */* __restrict  */)stdout);
    }
  }
  {
#line 406
  exit(status);
  }
}
}
#line 421 "tar.c"
static void set_subcommand_option(enum subcommand subcommand ) 
{ 
  char *tmp ;

  {
#line 424
  if ((unsigned int )subcommand_option != 0U) {
#line 424
    if ((unsigned int )subcommand_option != (unsigned int )subcommand) {
      {
#line 426
      tmp = gettext("You may not specify more than one `-Acdtrux\' option");
#line 426
      error(0, 0, (char const   *)tmp);
#line 426
      usage(2);
      }
    }
  }
#line 429
  subcommand_option = subcommand;
#line 430
  return;
}
}
#line 432 "tar.c"
static void set_use_compress_program_option(char const   *string ) 
{ 
  char *tmp ;
  int tmp___0 ;

  {
#line 435
  if (use_compress_program_option) {
    {
#line 435
    tmp___0 = strcmp(use_compress_program_option, string);
    }
#line 435
    if (tmp___0 != 0) {
      {
#line 436
      tmp = gettext("Conflicting compression options");
#line 436
      error(0, 0, (char const   *)tmp);
#line 436
      usage(2);
      }
    }
  }
#line 438
  use_compress_program_option = string;
#line 439
  return;
}
}
#line 441 "tar.c"
static void decode_options(int argc , char * const  *argv ) 
{ 
  int optchar ;
  int input_files ;
  char const   *backup_suffix_string ;
  char const   *version_control_string ;
  char *tmp ;
  int new_argc ;
  char **new_argv ;
  char * const  *in ;
  char **out ;
  char const   *letter ;
  char buffer___1[3] ;
  char const   *cursor ;
  size_t tmp___0 ;
  void *tmp___1 ;
  char **tmp___2 ;
  char * const  *tmp___3 ;
  char * const  *tmp___4 ;
  char **tmp___5 ;
  char *tmp___6 ;
  char **tmp___7 ;
  char * const  *tmp___8 ;
  char *tmp___9 ;
  char **tmp___10 ;
  char * const  *tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;
  long l ;
  char *tmp___14 ;
  strtol_error tmp___15 ;
  char *tmp___16 ;
  void *tmp___17 ;
  int tmp___18 ;
  unsigned long u ;
  char *tmp___19 ;
  strtol_error tmp___20 ;
  char *tmp___21 ;
  char *tmp___22 ;
  char *tmp___23 ;
  char *tmp___24 ;
  char *tmp___25 ;
  char *tmp___26 ;
  int *tmp___27 ;
  char *tmp___28 ;
  int tmp___29 ;
  char *tmp___30 ;
  uintmax_t g ;
  char *tmp___31 ;
  strtol_error tmp___32 ;
  size_t tmp___33 ;
  int tmp___34 ;
  char *tmp___35 ;
  char *tmp___36 ;
  uintmax_t u___0 ;
  char *tmp___37 ;
  strtol_error tmp___38 ;
  size_t tmp___39 ;
  int tmp___40 ;
  char *tmp___41 ;
  uintmax_t u___1 ;
  char *tmp___42 ;
  strtol_error tmp___43 ;
  char *tmp___44 ;
  char *tmp___45 ;
  char *tmp___46 ;
  char *tmp___47 ;
  char *tmp___48 ;
  char *tmp___49 ;
  char *tmp___50 ;
  char *tmp___51 ;
  char *tmp___52 ;
  char *tmp___53 ;
  int tmp___54 ;
  char *tmp___55 ;
  int tmp___56 ;
  char *tmp___57 ;

  {
  {
#line 447
  version_control_string = (char const   *)((void *)0);
#line 451
  subcommand_option = (enum subcommand )0;
#line 452
  archive_format = (enum archive_format )0;
#line 453
  blocking_factor = 20;
#line 454
  record_size = (size_t )10240;
#line 455
  excluded = new_exclude();
#line 457
  owner_option = (uid_t )-1;
#line 458
  group_option = (gid_t )-1;
#line 460
  tmp = getenv("SIMPLE_BACKUP_SUFFIX");
#line 460
  backup_suffix_string = (char const   *)tmp;
  }
#line 465
  if (argc > 1) {
#line 465
    if ((int )*(*(argv + 1) + 0) != 45) {
      {
#line 477
      buffer___1[0] = (char )'-';
#line 478
      buffer___1[2] = (char )'\000';
#line 482
      tmp___0 = strlen((char const   *)*(argv + 1));
#line 482
      new_argc = (int )((size_t )(argc - 1) + tmp___0);
#line 483
      tmp___1 = xmalloc((size_t )((unsigned long )new_argc * sizeof(char *)));
#line 483
      new_argv = (char **)tmp___1;
#line 484
      in = argv;
#line 485
      out = new_argv;
#line 486
      tmp___2 = out;
#line 486
      out ++;
#line 486
      tmp___3 = in;
#line 486
      in ++;
#line 486
      *tmp___2 = (char *)*tmp___3;
#line 491
      tmp___4 = in;
#line 491
      in ++;
#line 491
      letter = (char const   *)*tmp___4;
      }
      {
#line 491
      while (1) {
        while_continue: /* CIL Label */ ;
#line 491
        if (! *letter) {
#line 491
          goto while_break;
        }
        {
#line 493
        buffer___1[1] = (char )*letter;
#line 494
        tmp___5 = out;
#line 494
        out ++;
#line 494
        *tmp___5 = xstrdup((char const   *)(buffer___1));
#line 495
        tmp___6 = strchr("-01234567ABC:F:GK:L:MN:OPRST:UV:WX:Zb:cdf:g:hiklmoprstuvwxz",
                         (int )*letter);
#line 495
        cursor = (char const   *)tmp___6;
        }
#line 496
        if (cursor) {
#line 496
          if ((int const   )*(cursor + 1) == 58) {
#line 498
            if ((unsigned long )in < (unsigned long )(argv + argc)) {
#line 499
              tmp___7 = out;
#line 499
              out ++;
#line 499
              tmp___8 = in;
#line 499
              in ++;
#line 499
              *tmp___7 = (char *)*tmp___8;
            } else {
              {
#line 501
              tmp___9 = gettext("Old option `%c\' requires an argument.");
#line 501
              error(0, 0, (char const   *)tmp___9, (int const   )*letter);
#line 501
              usage(2);
              }
            }
          }
        }
#line 491
        letter ++;
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 508
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 508
        if (! ((unsigned long )in < (unsigned long )(argv + argc))) {
#line 508
          goto while_break___0;
        }
#line 509
        tmp___10 = out;
#line 509
        out ++;
#line 509
        tmp___11 = in;
#line 509
        in ++;
#line 509
        *tmp___10 = (char *)*tmp___11;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 513
      argc = new_argc;
#line 514
      argv = (char * const  *)new_argv;
    }
  }
#line 519
  input_files = 0;
  {
#line 521
  while (1) {
    while_continue___1: /* CIL Label */ ;
    {
#line 521
    optchar = getopt_long(argc, argv, "-01234567ABC:F:GK:L:MN:OPRST:UV:WX:Zb:cdf:g:hiklmoprstuvwxz",
                          (struct option  const  *)(long_options), (int *)((void *)0));
    }
#line 521
    if (! (optchar != -1)) {
#line 521
      goto while_break___1;
    }
    {
#line 525
    if (optchar == 63) {
#line 525
      goto case_63;
    }
#line 528
    if (optchar == 0) {
#line 528
      goto case_0;
    }
#line 531
    if (optchar == 1) {
#line 531
      goto case_1;
    }
#line 539
    if (optchar == 65) {
#line 539
      goto case_65;
    }
#line 543
    if (optchar == 145) {
#line 543
      goto case_145;
    }
#line 547
    if (optchar == 146) {
#line 547
      goto case_146;
    }
#line 551
    if (optchar == 98) {
#line 551
      goto case_98;
    }
#line 562
    if (optchar == 148) {
#line 562
      goto case_148;
    }
#line 567
    if (optchar == 66) {
#line 567
      goto case_66;
    }
#line 578
    if (optchar == 99) {
#line 578
      goto case_99;
    }
#line 582
    if (optchar == 67) {
#line 582
      goto case_67;
    }
#line 587
    if (optchar == 100) {
#line 587
      goto case_100;
    }
#line 591
    if (optchar == 102) {
#line 591
      goto case_102;
    }
#line 602
    if (optchar == 70) {
#line 602
      goto case_70;
    }
#line 610
    if (optchar == 103) {
#line 610
      goto case_103;
    }
#line 614
    if (optchar == 71) {
#line 614
      goto case_71;
    }
#line 622
    if (optchar == 104) {
#line 622
      goto case_104;
    }
#line 628
    if (optchar == 105) {
#line 628
      goto case_105;
    }
#line 636
    if (optchar == 107) {
#line 636
      goto case_107;
    }
#line 642
    if (optchar == 75) {
#line 642
      goto case_75;
    }
#line 647
    if (optchar == 108) {
#line 647
      goto case_108;
    }
#line 654
    if (optchar == 76) {
#line 654
      goto case_76;
    }
#line 666
    if (optchar == 149) {
#line 666
      goto case_149;
    }
#line 670
    if (optchar == 109) {
#line 670
      goto case_109;
    }
#line 674
    if (optchar == 77) {
#line 674
      goto case_77;
    }
#line 682
    if (optchar == 78) {
#line 682
      goto case_78;
    }
#line 686
    if (optchar == 133) {
#line 686
      goto case_133;
    }
#line 697
    if (optchar == 111) {
#line 697
      goto case_111;
    }
#line 704
    if (optchar == 79) {
#line 704
      goto case_79;
    }
#line 708
    if (optchar == 112) {
#line 708
      goto case_112;
    }
#line 712
    if (optchar == 144) {
#line 712
      goto case_144;
    }
#line 716
    if (optchar == 80) {
#line 716
      goto case_80;
    }
#line 720
    if (optchar == 114) {
#line 720
      goto case_114;
    }
#line 724
    if (optchar == 147) {
#line 724
      goto case_147;
    }
#line 728
    if (optchar == 82) {
#line 728
      goto case_82;
    }
#line 739
    if (optchar == 115) {
#line 739
      goto case_115;
    }
#line 745
    if (optchar == 83) {
#line 745
      goto case_83;
    }
#line 749
    if (optchar == 116) {
#line 749
      goto case_116;
    }
#line 754
    if (optchar == 84) {
#line 754
      goto case_84;
    }
#line 758
    if (optchar == 117) {
#line 758
      goto case_117;
    }
#line 762
    if (optchar == 85) {
#line 762
      goto case_85;
    }
#line 766
    if (optchar == 118) {
#line 766
      goto case_118;
    }
#line 770
    if (optchar == 86) {
#line 770
      goto case_86;
    }
#line 774
    if (optchar == 119) {
#line 774
      goto case_119;
    }
#line 778
    if (optchar == 87) {
#line 778
      goto case_87;
    }
#line 782
    if (optchar == 120) {
#line 782
      goto case_120;
    }
#line 786
    if (optchar == 88) {
#line 786
      goto case_88;
    }
#line 791
    if (optchar == 122) {
#line 791
      goto case_122;
    }
#line 795
    if (optchar == 90) {
#line 795
      goto case_90;
    }
#line 799
    if (optchar == 150) {
#line 799
      goto case_150;
    }
#line 803
    if (optchar == 128) {
#line 803
      goto case_128;
    }
#line 809
    if (optchar == 129) {
#line 809
      goto case_129;
    }
#line 813
    if (optchar == 130) {
#line 813
      goto case_130;
    }
#line 817
    if (optchar == 131) {
#line 817
      goto case_131;
    }
#line 830
    if (optchar == 132) {
#line 830
      goto case_132;
    }
#line 840
    if (optchar == 134) {
#line 840
      goto case_134;
    }
#line 844
    if (optchar == 135) {
#line 844
      goto case_135;
    }
#line 848
    if (optchar == 136) {
#line 848
      goto case_136;
    }
#line 861
    if (optchar == 137) {
#line 861
      goto case_137;
    }
#line 875
    if (optchar == 138) {
#line 875
      goto case_138;
    }
#line 880
    if (optchar == 139) {
#line 880
      goto case_139;
    }
#line 894
    if (optchar == 140) {
#line 894
      goto case_140;
    }
#line 898
    if (optchar == 141) {
#line 898
      goto case_141;
    }
#line 903
    if (optchar == 143) {
#line 903
      goto case_143;
    }
#line 907
    if (optchar == 142) {
#line 907
      goto case_142;
    }
#line 918
    if (optchar == 55) {
#line 918
      goto case_55;
    }
#line 918
    if (optchar == 54) {
#line 918
      goto case_55;
    }
#line 918
    if (optchar == 53) {
#line 918
      goto case_55;
    }
#line 918
    if (optchar == 52) {
#line 918
      goto case_55;
    }
#line 918
    if (optchar == 51) {
#line 918
      goto case_55;
    }
#line 918
    if (optchar == 50) {
#line 918
      goto case_55;
    }
#line 918
    if (optchar == 49) {
#line 918
      goto case_55;
    }
#line 918
    if (optchar == 48) {
#line 918
      goto case_55;
    }
#line 523
    goto switch_break;
    case_63: /* CIL Label */ 
    {
#line 526
    usage(2);
    }
    case_0: /* CIL Label */ 
#line 529
    goto switch_break;
    case_1: /* CIL Label */ 
    {
#line 535
    name_add((char const   *)optarg);
#line 536
    input_files ++;
    }
#line 537
    goto switch_break;
    case_65: /* CIL Label */ 
    {
#line 540
    set_subcommand_option((enum subcommand )2);
    }
#line 541
    goto switch_break;
    case_145: /* CIL Label */ 
    {
#line 544
    tmp___12 = gettext("Obsolete option, now implied by --blocking-factor");
#line 544
    error(0, 0, (char const   *)tmp___12);
    }
#line 545
    goto switch_break;
    case_146: /* CIL Label */ 
    {
#line 548
    tmp___13 = gettext("Obsolete option name replaced by --blocking-factor");
#line 548
    error(0, 0, (char const   *)tmp___13);
    }
    case_98: /* CIL Label */ 
    {
#line 554
    tmp___15 = xstrtol((char const   *)optarg, (char **)0, 10, & l, "");
    }
#line 554
    if ((unsigned int )tmp___15 == 0U) {
#line 554
      blocking_factor = (int )l;
#line 554
      if (l == (long )blocking_factor) {
#line 554
        if (0 < blocking_factor) {
#line 554
          record_size = (size_t )(l * 512L);
#line 554
          if (! (l == (long )(record_size / 512U))) {
            {
#line 558
            tmp___14 = gettext("Invalid blocking factor");
#line 558
            error(0, 0, (char const   *)tmp___14);
#line 558
            usage(2);
            }
          }
        } else {
          {
#line 558
          tmp___14 = gettext("Invalid blocking factor");
#line 558
          error(0, 0, (char const   *)tmp___14);
#line 558
          usage(2);
          }
        }
      } else {
        {
#line 558
        tmp___14 = gettext("Invalid blocking factor");
#line 558
        error(0, 0, (char const   *)tmp___14);
#line 558
        usage(2);
        }
      }
    } else {
      {
#line 558
      tmp___14 = gettext("Invalid blocking factor");
#line 558
      error(0, 0, (char const   *)tmp___14);
#line 558
      usage(2);
      }
    }
#line 560
    goto switch_break;
    case_148: /* CIL Label */ 
    {
#line 563
    tmp___16 = gettext("Obsolete option name replaced by --read-full-records");
#line 563
    error(0, 0, (char const   *)tmp___16);
    }
    case_66: /* CIL Label */ 
#line 575
    read_full_records_option = 1;
#line 576
    goto switch_break;
    case_99: /* CIL Label */ 
    {
#line 579
    set_subcommand_option((enum subcommand )3);
    }
#line 580
    goto switch_break;
    case_67: /* CIL Label */ 
    {
#line 583
    name_add("-C");
#line 584
    name_add((char const   *)optarg);
    }
#line 585
    goto switch_break;
    case_100: /* CIL Label */ 
    {
#line 588
    set_subcommand_option((enum subcommand )5);
    }
#line 589
    goto switch_break;
    case_102: /* CIL Label */ 
#line 592
    if (archive_names == allocated_archive_names) {
      {
#line 594
      allocated_archive_names *= 2;
#line 595
      tmp___17 = xrealloc((void *)archive_name_array, (size_t )(sizeof(char const   *) * (unsigned long )allocated_archive_names));
#line 595
      archive_name_array = (char const   **)tmp___17;
      }
    }
#line 599
    tmp___18 = archive_names;
#line 599
    archive_names ++;
#line 599
    *(archive_name_array + tmp___18) = (char const   *)optarg;
#line 600
    goto switch_break;
    case_70: /* CIL Label */ 
#line 606
    info_script_option = (char const   *)optarg;
#line 607
    multi_volume_option = 1;
#line 608
    goto switch_break;
    case_103: /* CIL Label */ 
#line 611
    listed_incremental_option = (char const   *)optarg;
    case_71: /* CIL Label */ 
#line 619
    incremental_option = 1;
#line 620
    goto switch_break;
    case_104: /* CIL Label */ 
#line 625
    dereference_option = 1;
#line 626
    goto switch_break;
    case_105: /* CIL Label */ 
#line 633
    ignore_zeros_option = 1;
#line 634
    goto switch_break;
    case_107: /* CIL Label */ 
#line 639
    keep_old_files_option = 1;
#line 640
    goto switch_break;
    case_75: /* CIL Label */ 
    {
#line 643
    starting_file_option = 1;
#line 644
    addname((char const   *)optarg);
    }
#line 645
    goto switch_break;
    case_108: /* CIL Label */ 
#line 651
    one_file_system_option = 1;
#line 652
    goto switch_break;
    case_76: /* CIL Label */ 
    {
#line 657
    tmp___20 = xstrtoul((char const   *)optarg, (char **)0, 10, & u, "");
    }
#line 657
    if ((long )tmp___20 != 2147483647L) {
      {
#line 658
      tmp___19 = gettext("Invalid tape length");
#line 658
      error(0, 0, (char const   *)tmp___19);
#line 658
      usage(2);
      }
    }
#line 659
    tape_length_option = (tarlong )0;
#line 660
    tape_length_option += (tarlong )u;
#line 661
    tape_length_option *= 1024ULL;
#line 662
    multi_volume_option = 1;
#line 664
    goto switch_break;
    case_149: /* CIL Label */ 
    {
#line 667
    tmp___21 = gettext("Obsolete option name replaced by --touch");
#line 667
    error(0, 0, (char const   *)tmp___21);
    }
    case_109: /* CIL Label */ 
#line 671
    touch_option = 1;
#line 672
    goto switch_break;
    case_77: /* CIL Label */ 
#line 678
    multi_volume_option = 1;
#line 679
    goto switch_break;
    case_78: /* CIL Label */ 
#line 683
    after_date_option = 1;
    case_133: /* CIL Label */ 
#line 687
    if (newer_mtime_option) {
      {
#line 688
      tmp___22 = gettext("More than one threshold date");
#line 688
      error(0, 0, (char const   *)tmp___22);
#line 688
      usage(2);
      }
    }
    {
#line 690
    newer_mtime_option = get_date(optarg, (void *)0);
    }
#line 691
    if (newer_mtime_option == -1L) {
      {
#line 692
      tmp___23 = gettext("Invalid date format `%s\'");
#line 692
      error(0, 0, (char const   *)tmp___23, optarg);
#line 692
      usage(2);
      }
    }
#line 694
    goto switch_break;
    case_111: /* CIL Label */ 
#line 698
    if ((unsigned int )archive_format == 0U) {
#line 699
      archive_format = (enum archive_format )1;
    } else
#line 700
    if ((unsigned int )archive_format != 1U) {
      {
#line 701
      tmp___24 = gettext("Conflicting archive format options");
#line 701
      error(0, 0, (char const   *)tmp___24);
#line 701
      usage(2);
      }
    }
#line 702
    goto switch_break;
    case_79: /* CIL Label */ 
#line 705
    to_stdout_option = 1;
#line 706
    goto switch_break;
    case_112: /* CIL Label */ 
#line 709
    same_permissions_option = 1;
#line 710
    goto switch_break;
    case_144: /* CIL Label */ 
    {
#line 713
    tmp___25 = gettext("Obsolete option name replaced by --absolute-names");
#line 713
    error(0, 0, (char const   *)tmp___25);
    }
    case_80: /* CIL Label */ 
#line 717
    absolute_names_option = 1;
#line 718
    goto switch_break;
    case_114: /* CIL Label */ 
    {
#line 721
    set_subcommand_option((enum subcommand )1);
    }
#line 722
    goto switch_break;
    case_147: /* CIL Label */ 
    {
#line 725
    tmp___26 = gettext("Obsolete option name replaced by --block-number");
#line 725
    error(0, 0, (char const   *)tmp___26);
    }
    case_82: /* CIL Label */ 
#line 736
    block_number_option = 1;
#line 737
    goto switch_break;
    case_115: /* CIL Label */ 
#line 742
    same_order_option = 1;
#line 743
    goto switch_break;
    case_83: /* CIL Label */ 
#line 746
    sparse_option = 1;
#line 747
    goto switch_break;
    case_116: /* CIL Label */ 
    {
#line 750
    set_subcommand_option((enum subcommand )7);
#line 751
    verbose_option ++;
    }
#line 752
    goto switch_break;
    case_84: /* CIL Label */ 
#line 755
    files_from_option = (char const   *)optarg;
#line 756
    goto switch_break;
    case_117: /* CIL Label */ 
    {
#line 759
    set_subcommand_option((enum subcommand )8);
    }
#line 760
    goto switch_break;
    case_85: /* CIL Label */ 
#line 763
    unlink_first_option = 1;
#line 764
    goto switch_break;
    case_118: /* CIL Label */ 
#line 767
    verbose_option ++;
#line 768
    goto switch_break;
    case_86: /* CIL Label */ 
#line 771
    volume_label_option = (char const   *)optarg;
#line 772
    goto switch_break;
    case_119: /* CIL Label */ 
#line 775
    interactive_option = 1;
#line 776
    goto switch_break;
    case_87: /* CIL Label */ 
#line 779
    verify_option = 1;
#line 780
    goto switch_break;
    case_120: /* CIL Label */ 
    {
#line 783
    set_subcommand_option((enum subcommand )6);
    }
#line 784
    goto switch_break;
    case_88: /* CIL Label */ 
    {
#line 787
    tmp___29 = add_exclude_file(excluded, (char const   *)optarg, (char )'\n');
    }
#line 787
    if (tmp___29 != 0) {
      {
#line 788
      tmp___27 = __errno_location();
#line 788
      error(0, *tmp___27, "%s", optarg);
#line 788
      tmp___28 = gettext("Error is not recoverable: exiting now");
#line 788
      error(2, 0, (char const   *)tmp___28);
      }
    }
#line 789
    goto switch_break;
    case_122: /* CIL Label */ 
    {
#line 792
    set_use_compress_program_option("gzip");
    }
#line 793
    goto switch_break;
    case_90: /* CIL Label */ 
    {
#line 796
    set_use_compress_program_option("compress");
    }
#line 797
    goto switch_break;
    case_150: /* CIL Label */ 
    {
#line 800
    tmp___30 = gettext("Obsolete option name replaced by --backup");
#line 800
    error(0, 0, (char const   *)tmp___30);
    }
    case_128: /* CIL Label */ 
#line 804
    backup_option = 1;
#line 805
    if (optarg) {
#line 806
      version_control_string = (char const   *)optarg;
    }
#line 807
    goto switch_break;
    case_129: /* CIL Label */ 
    {
#line 810
    set_subcommand_option((enum subcommand )4);
    }
#line 811
    goto switch_break;
    case_130: /* CIL Label */ 
    {
#line 814
    add_exclude(excluded, (char const   *)optarg);
    }
#line 815
    goto switch_break;
    case_131: /* CIL Label */ 
    {
#line 818
    tmp___33 = strlen((char const   *)optarg);
    }
#line 818
    if (tmp___33 < 32U) {
      {
#line 818
      tmp___34 = gname_to_gid((char *)optarg, & group_option);
      }
#line 818
      if (! tmp___34) {
#line 818
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
      {
#line 822
      tmp___32 = xstrtoumax((char const   *)optarg, (char **)0, 10, & g, "");
      }
#line 822
      if ((unsigned int )tmp___32 == 0U) {
#line 822
        if (g == (uintmax_t )((gid_t )g)) {
#line 824
          group_option = (gid_t )g;
        } else {
          {
#line 826
          tmp___31 = gettext("Invalid group given on option");
#line 826
          error(2, 0, (char const   *)tmp___31);
#line 826
          exit_status = 2;
          }
        }
      } else {
        {
#line 826
        tmp___31 = gettext("Invalid group given on option");
#line 826
        error(2, 0, (char const   *)tmp___31);
#line 826
        exit_status = 2;
        }
      }
    }
#line 828
    goto switch_break;
    case_132: /* CIL Label */ 
    {
#line 831
    mode_option = mode_compile((char const   *)optarg, 7U);
    }
#line 834
    if ((unsigned long )mode_option == (unsigned long )((struct mode_change *)0)) {
      {
#line 835
      tmp___35 = gettext("Invalid mode given on option");
#line 835
      error(2, 0, (char const   *)tmp___35);
#line 835
      exit_status = 2;
      }
    }
#line 836
    if ((unsigned long )mode_option == (unsigned long )((struct mode_change *)1)) {
      {
#line 837
      tmp___36 = gettext("Memory exhausted");
#line 837
      error(2, 0, (char const   *)tmp___36);
#line 837
      exit_status = 2;
      }
    }
#line 838
    goto switch_break;
    case_134: /* CIL Label */ 
#line 841
    no_recurse_option = 1;
#line 842
    goto switch_break;
    case_135: /* CIL Label */ 
#line 845
    filename_terminator = (char )'\000';
#line 846
    goto switch_break;
    case_136: /* CIL Label */ 
    {
#line 849
    tmp___39 = strlen((char const   *)optarg);
    }
#line 849
    if (tmp___39 < 32U) {
      {
#line 849
      tmp___40 = uname_to_uid((char *)optarg, & owner_option);
      }
#line 849
      if (! tmp___40) {
#line 849
        goto _L___0;
      }
    } else {
      _L___0: /* CIL Label */ 
      {
#line 853
      tmp___38 = xstrtoumax((char const   *)optarg, (char **)0, 10, & u___0, "");
      }
#line 853
      if ((unsigned int )tmp___38 == 0U) {
#line 853
        if (u___0 == (uintmax_t )((uid_t )u___0)) {
#line 855
          owner_option = (uid_t )u___0;
        } else {
          {
#line 857
          tmp___37 = gettext("Invalid owner given on option");
#line 857
          error(2, 0, (char const   *)tmp___37);
#line 857
          exit_status = 2;
          }
        }
      } else {
        {
#line 857
        tmp___37 = gettext("Invalid owner given on option");
#line 857
        error(2, 0, (char const   *)tmp___37);
#line 857
        exit_status = 2;
        }
      }
    }
#line 859
    goto switch_break;
    case_137: /* CIL Label */ 
#line 863
    if ((unsigned int )archive_format == 0U) {
#line 864
      archive_format = (enum archive_format )4;
    } else
#line 865
    if ((unsigned int )archive_format != 4U) {
      {
#line 866
      tmp___41 = gettext("Conflicting archive format options");
#line 866
      error(0, 0, (char const   *)tmp___41);
#line 866
      usage(2);
      }
    }
#line 873
    goto switch_break;
    case_138: /* CIL Label */ 
#line 876
    same_permissions_option = 1;
#line 877
    same_order_option = 1;
#line 878
    goto switch_break;
    case_139: /* CIL Label */ 
    {
#line 883
    tmp___43 = xstrtoumax((char const   *)optarg, (char **)0, 10, & u___1, "");
    }
#line 883
    if ((long )tmp___43 == 2147483647L) {
#line 883
      if (! (u___1 == (uintmax_t )((size_t )u___1))) {
        {
#line 885
        tmp___42 = gettext("Invalid record size");
#line 885
        error(0, 0, (char const   *)tmp___42);
#line 885
        usage(2);
        }
      }
    } else {
      {
#line 885
      tmp___42 = gettext("Invalid record size");
#line 885
      error(0, 0, (char const   *)tmp___42);
#line 885
      usage(2);
      }
    }
#line 886
    record_size = (size_t )u___1;
#line 887
    if (record_size % 512U != 0U) {
      {
#line 888
      tmp___44 = gettext("Record size must be a multiple of %d.");
#line 888
      error(0, 0, (char const   *)tmp___44, 512);
#line 888
      usage(2);
      }
    }
#line 890
    blocking_factor = (int )(record_size / 512U);
#line 892
    goto switch_break;
    case_140: /* CIL Label */ 
#line 895
    rsh_command_option = (char const   *)optarg;
#line 896
    goto switch_break;
    case_141: /* CIL Label */ 
#line 899
    backup_option = 1;
#line 900
    backup_suffix_string = (char const   *)optarg;
#line 901
    goto switch_break;
    case_143: /* CIL Label */ 
#line 904
    volno_file_option = (char const   *)optarg;
#line 905
    goto switch_break;
    case_142: /* CIL Label */ 
    {
#line 908
    set_use_compress_program_option((char const   *)optarg);
    }
#line 909
    goto switch_break;
    case_55: /* CIL Label */ 
    case_54: /* CIL Label */ 
    case_53: /* CIL Label */ 
    case_52: /* CIL Label */ 
    case_51: /* CIL Label */ 
    case_50: /* CIL Label */ 
    case_49: /* CIL Label */ 
    case_48: /* CIL Label */ 
    {
#line 984
    tmp___45 = gettext("Options `-[0-7][lmh]\' not supported by *this* tar");
#line 984
    error(0, 0, (char const   *)tmp___45);
#line 984
    usage(2);
    }
    switch_break: /* CIL Label */ ;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 992
  if (show_version) {
    {
#line 994
    printf((char const   */* __restrict  */)"tar (GNU %s) %s\n", "tar", "1.13");
#line 995
    tmp___46 = gettext("\nCopyright (C) 1988, 92,93,94,95,96,97,98, 1999 Free Software Foundation, Inc.\n");
#line 995
    fputs((char const   */* __restrict  */)tmp___46, (FILE */* __restrict  */)stdout);
#line 999
    tmp___47 = gettext("This is free software; see the source for copying conditions.  There is NO\nwarranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n");
#line 999
    fputs((char const   */* __restrict  */)tmp___47, (FILE */* __restrict  */)stdout);
#line 1003
    tmp___48 = gettext("\nWritten by John Gilmore and Jay Fenlason.\n");
#line 1003
    fputs((char const   */* __restrict  */)tmp___48, (FILE */* __restrict  */)stdout);
#line 1007
    exit(0);
    }
  }
#line 1010
  if (show_help) {
    {
#line 1011
    usage(0);
    }
  }
#line 1015
  if ((unsigned int )archive_format == 0U) {
#line 1018
    archive_format = (enum archive_format )2;
  }
#line 1024
  if ((unsigned int )archive_format == 4U) {
    {
#line 1024
    tmp___49 = getenv("POSIXLY_CORRECT");
    }
#line 1024
    if (tmp___49) {
#line 1025
      archive_format = (enum archive_format )3;
    }
  }
#line 1027
  if ((unsigned long )volume_label_option != (unsigned long )((void *)0)) {
#line 1027
    goto _L___1;
  } else
#line 1027
  if (incremental_option) {
#line 1027
    goto _L___1;
  } else
#line 1027
  if (multi_volume_option) {
#line 1027
    goto _L___1;
  } else
#line 1027
  if (sparse_option) {
    _L___1: /* CIL Label */ 
#line 1027
    if ((unsigned int )archive_format != 2U) {
#line 1027
      if ((unsigned int )archive_format != 4U) {
        {
#line 1030
        tmp___50 = gettext("GNU features wanted on incompatible archive format");
#line 1030
        error(0, 0, (char const   *)tmp___50);
#line 1030
        usage(2);
        }
      }
    }
  }
#line 1033
  if (archive_names == 0) {
    {
#line 1038
    archive_names = 1;
#line 1039
    tmp___51 = getenv("TAPE");
#line 1039
    *(archive_name_array + 0) = (char const   *)tmp___51;
    }
#line 1040
    if ((unsigned long )*(archive_name_array + 0) == (unsigned long )((void *)0)) {
#line 1041
      *(archive_name_array + 0) = "-";
    }
  }
#line 1046
  if (archive_names > 1) {
#line 1046
    if (! multi_volume_option) {
      {
#line 1047
      tmp___52 = gettext("Multiple archive files requires `-M\' option");
#line 1047
      error(0, 0, (char const   *)tmp___52);
#line 1047
      usage(2);
      }
    }
  }
#line 1051
  if (recursive_unlink_option) {
#line 1052
    unlink_first_option = 1;
  }
  {
#line 1059
  if ((unsigned int )subcommand_option == 3U) {
#line 1059
    goto case_3;
  }
#line 1067
  if ((unsigned int )subcommand_option == 5U) {
#line 1067
    goto case_5;
  }
#line 1067
  if ((unsigned int )subcommand_option == 7U) {
#line 1067
    goto case_5;
  }
#line 1067
  if ((unsigned int )subcommand_option == 6U) {
#line 1067
    goto case_5;
  }
#line 1077
  if ((unsigned int )subcommand_option == 1U) {
#line 1077
    goto case_1___0;
  }
#line 1077
  if ((unsigned int )subcommand_option == 8U) {
#line 1077
    goto case_1___0;
  }
#line 1077
  if ((unsigned int )subcommand_option == 2U) {
#line 1077
    goto case_1___0;
  }
#line 1085
  goto switch_default;
  case_3: /* CIL Label */ 
#line 1060
  if (input_files == 0) {
#line 1060
    if (! files_from_option) {
      {
#line 1061
      tmp___53 = gettext("Cowardly refusing to create an empty archive");
#line 1061
      error(0, 0, (char const   *)tmp___53);
#line 1061
      usage(2);
      }
    }
  }
#line 1063
  goto switch_break___0;
  case_5: /* CIL Label */ 
  case_7: /* CIL Label */ 
  case_6: /* CIL Label */ 
#line 1068
  archive_name_cursor = archive_name_array;
  {
#line 1068
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 1068
    if (! ((unsigned long )archive_name_cursor < (unsigned long )(archive_name_array + archive_names))) {
#line 1068
      goto while_break___2;
    }
    {
#line 1071
    tmp___54 = strcmp(*archive_name_cursor, "-");
    }
#line 1071
    if (! tmp___54) {
      {
#line 1072
      request_stdin("-f");
      }
    }
#line 1068
    archive_name_cursor ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 1073
  goto switch_break___0;
  case_1___0: /* CIL Label */ 
  case_8: /* CIL Label */ 
  case_2: /* CIL Label */ 
#line 1078
  archive_name_cursor = archive_name_array;
  {
#line 1078
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 1078
    if (! ((unsigned long )archive_name_cursor < (unsigned long )(archive_name_array + archive_names))) {
#line 1078
      goto while_break___3;
    }
    {
#line 1081
    tmp___56 = strcmp(*archive_name_cursor, "-");
    }
#line 1081
    if (! tmp___56) {
      {
#line 1082
      tmp___55 = gettext("Options `-Aru\' are incompatible with `-f -\'");
#line 1082
      error(0, 0, (char const   *)tmp___55);
#line 1082
      usage(2);
      }
    }
#line 1078
    archive_name_cursor ++;
  }
  while_break___3: /* CIL Label */ ;
  }
  switch_default: /* CIL Label */ 
#line 1086
  goto switch_break___0;
  switch_break___0: /* CIL Label */ ;
  }
#line 1089
  archive_name_cursor = archive_name_array;
#line 1093
  if (backup_suffix_string) {
    {
#line 1094
    tmp___57 = xstrdup(backup_suffix_string);
#line 1094
    simple_backup_suffix = (char const   *)tmp___57;
    }
  }
#line 1096
  if (backup_option) {
    {
#line 1097
    backup_type = xget_version("--backup", version_control_string);
    }
  }
#line 1098
  return;
}
}
#line 1106 "tar.c"
int main(int argc , char * const  *argv ) 
{ 
  void *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;

  {
  {
#line 1109
  program_name = (char const   *)*(argv + 0);
#line 1110
  setlocale(6, "");
#line 1111
  bindtextdomain("tar", "/usr/local/share/locale");
#line 1112
  textdomain("tar");
#line 1114
  exit_status = 0;
#line 1115
  filename_terminator = (char )'\n';
#line 1119
  allocated_archive_names = 10;
#line 1120
  tmp = xmalloc((size_t )(sizeof(char const   *) * (unsigned long )allocated_archive_names));
#line 1120
  archive_name_array = (char const   **)tmp;
#line 1122
  archive_names = 0;
#line 1126
  signal(17, (void (*)(int  ))0);
#line 1129
  init_names();
#line 1133
  decode_options(argc, argv);
#line 1134
  name_init(argc, argv);
  }
#line 1138
  if (volno_file_option) {
    {
#line 1139
    init_volume_number();
    }
  }
  {
#line 1143
  if ((unsigned int )subcommand_option == 0U) {
#line 1143
    goto case_0;
  }
#line 1149
  if ((unsigned int )subcommand_option == 1U) {
#line 1149
    goto case_1;
  }
#line 1149
  if ((unsigned int )subcommand_option == 8U) {
#line 1149
    goto case_1;
  }
#line 1149
  if ((unsigned int )subcommand_option == 2U) {
#line 1149
    goto case_1;
  }
#line 1153
  if ((unsigned int )subcommand_option == 4U) {
#line 1153
    goto case_4;
  }
#line 1157
  if ((unsigned int )subcommand_option == 3U) {
#line 1157
    goto case_3;
  }
#line 1168
  if ((unsigned int )subcommand_option == 6U) {
#line 1168
    goto case_6;
  }
#line 1173
  if ((unsigned int )subcommand_option == 7U) {
#line 1173
    goto case_7;
  }
#line 1177
  if ((unsigned int )subcommand_option == 5U) {
#line 1177
    goto case_5;
  }
#line 1141
  goto switch_break;
  case_0: /* CIL Label */ 
  {
#line 1144
  tmp___0 = gettext("You must specify one of the `-Acdtrux\' options");
#line 1144
  error(0, 0, (char const   *)tmp___0);
#line 1144
  usage(2);
  }
  case_1: /* CIL Label */ 
  case_8: /* CIL Label */ 
  case_2: /* CIL Label */ 
  {
#line 1150
  update_archive();
  }
#line 1151
  goto switch_break;
  case_4: /* CIL Label */ 
  {
#line 1154
  delete_archive_members();
  }
#line 1155
  goto switch_break;
  case_3: /* CIL Label */ 
#line 1158
  if (totals_option) {
    {
#line 1159
    init_total_written();
    }
  }
  {
#line 1161
  create_archive();
#line 1162
  name_close();
  }
#line 1164
  if (totals_option) {
    {
#line 1165
    print_total_written();
    }
  }
#line 1166
  goto switch_break;
  case_6: /* CIL Label */ 
  {
#line 1169
  extr_init();
#line 1170
  read_and(& extract_archive);
  }
#line 1171
  goto switch_break;
  case_7: /* CIL Label */ 
  {
#line 1174
  read_and(& list_archive);
  }
#line 1175
  goto switch_break;
  case_5: /* CIL Label */ 
  {
#line 1178
  diff_init();
#line 1179
  read_and(& diff_archive);
  }
#line 1180
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 1183
  if (volno_file_option) {
    {
#line 1184
    closeout_volume_number();
    }
  }
  {
#line 1188
  free((void *)archive_name_array);
#line 1189
  name_term();
  }
#line 1191
  if (exit_status == 2) {
    {
#line 1192
    tmp___1 = gettext("Error exit delayed from previous errors");
#line 1192
    error(0, 0, (char const   *)tmp___1);
    }
  }
  {
#line 1193
  exit(exit_status);
  }
}
}
#line 369 "/usr/include/unistd.h"
extern int pipe(int *__pipedes ) ;
#line 466
extern int dup(int __fd ) ;
#line 500
extern int execl(char const   *__path , char const   *__arg  , ...) ;
#line 613
extern __uid_t getuid(void) ;
#line 619
extern __gid_t getgid(void) ;
#line 638
extern int setuid(__uid_t __uid ) ;
#line 655
extern int setgid(__gid_t __gid ) ;
#line 690
extern __pid_t fork(void) ;
#line 144 "/usr/include/stdlib.h"
extern int atoi(char const   *__nptr )  __attribute__((__pure__)) ;
#line 146
extern long atol(char const   *__nptr )  __attribute__((__pure__)) ;
#line 18 "rmt.h"
char *rmt_path__  ;
#line 20
int rmt_open__(char const   *path___0 , int open_mode , int bias , char const   *remote_shell ) ;
#line 21
int rmt_close__(int handle ) ;
#line 22
ssize_t rmt_read__(int handle , char *buffer___1 , size_t length ) ;
#line 23
ssize_t rmt_write__(int handle , char *buffer___1 , size_t length ) ;
#line 24
off_t rmt_lseek__(int handle , off_t offset , int whence ) ;
#line 25
int rmt_ioctl__(int handle , int operation , char *argument ) ;
#line 87 "rtapelib.c"
static int from_remote[4][2]  = { {        -1,        -1}, 
   {        -1,        -1}, 
   {        -1,        -1}, 
   {        -1,        -1}};
#line 90 "rtapelib.c"
static int to_remote[4][2]  = { {        -1,        -1}, 
   {        -1,        -1}, 
   {        -1,        -1}, 
   {        -1,        -1}};
#line 100 "rtapelib.c"
static void _rmt_shutdown(int handle , int errno_value ) 
{ 
  int *tmp ;

  {
  {
#line 103
  close(from_remote[handle][0]);
#line 104
  close(to_remote[handle][1]);
#line 105
  from_remote[handle][0] = -1;
#line 106
  to_remote[handle][1] = -1;
#line 107
  tmp = __errno_location();
#line 107
  *tmp = errno_value;
  }
#line 108
  return;
}
}
#line 115 "rtapelib.c"
static int do_command(int handle , char const   *buffer___1 ) 
{ 
  size_t length ;
  void (*pipe_handler)() ;
  __sighandler_t tmp ;
  ssize_t tmp___0 ;

  {
  {
#line 123
  tmp = signal(13, (void (*)(int  ))1);
#line 123
  pipe_handler = (void (*)())tmp;
#line 124
  length = strlen(buffer___1);
#line 125
  tmp___0 = full_write(to_remote[handle][1], buffer___1, length);
  }
#line 125
  if ((size_t )tmp___0 == length) {
    {
#line 127
    signal(13, (void (*)(int  ))pipe_handler);
    }
#line 128
    return (0);
  }
  {
#line 133
  signal(13, (void (*)(int  ))pipe_handler);
#line 134
  _rmt_shutdown(handle, 5);
  }
#line 135
  return (-1);
}
}
#line 138 "rtapelib.c"
static char *get_status_string(int handle , char *command_buffer ) 
{ 
  char *cursor ;
  int counter ;
  ssize_t tmp ;
  int *tmp___0 ;
  char character ;
  ssize_t tmp___1 ;
  int *tmp___2 ;

  {
#line 146
  counter = 0;
#line 146
  cursor = command_buffer;
  {
#line 146
  while (1) {
    while_continue: /* CIL Label */ ;
#line 146
    if (! (counter < 64)) {
#line 146
      goto while_break;
    }
    {
#line 150
    tmp = safe_read(from_remote[handle][0], (void *)cursor, (size_t )1);
    }
#line 150
    if (tmp != 1) {
      {
#line 152
      _rmt_shutdown(handle, 5);
      }
#line 153
      return ((char *)0);
    }
#line 155
    if ((int )*cursor == 10) {
#line 157
      *cursor = (char )'\000';
#line 158
      goto while_break;
    }
#line 146
    counter ++;
#line 146
    cursor ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 162
  if (counter == 64) {
    {
#line 164
    _rmt_shutdown(handle, 5);
    }
#line 165
    return ((char *)0);
  }
#line 170
  cursor = command_buffer;
  {
#line 170
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 170
    if (! *cursor) {
#line 170
      goto while_break___0;
    }
#line 171
    if ((int )*cursor != 32) {
#line 172
      goto while_break___0;
    }
#line 170
    cursor ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 174
  if ((int )*cursor == 69) {
#line 174
    goto _L;
  } else
#line 174
  if ((int )*cursor == 70) {
    _L: /* CIL Label */ 
    {
#line 176
    tmp___0 = __errno_location();
#line 176
    *tmp___0 = atoi((char const   *)(cursor + 1));
    }
    {
#line 186
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 186
      tmp___1 = safe_read(from_remote[handle][0], (void *)(& character), (size_t )1);
      }
#line 186
      if (! (tmp___1 == 1)) {
#line 186
        goto while_break___1;
      }
#line 187
      if ((int )character == 10) {
#line 188
        goto while_break___1;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
#line 191
    if ((int )*cursor == 70) {
      {
#line 192
      tmp___2 = __errno_location();
#line 192
      _rmt_shutdown(handle, *tmp___2);
      }
    }
#line 194
    return ((char *)0);
  }
#line 199
  if ((int )*cursor != 65) {
    {
#line 201
    _rmt_shutdown(handle, 5);
    }
#line 202
    return ((char *)0);
  }
#line 207
  return (cursor + 1);
}
}
#line 215 "rtapelib.c"
static long get_status(int handle ) 
{ 
  char command_buffer[64] ;
  char const   *status ;
  char *tmp ;
  long tmp___0 ;
  long tmp___1 ;

  {
  {
#line 219
  tmp = get_status_string(handle, command_buffer);
#line 219
  status = (char const   *)tmp;
  }
#line 220
  if (status) {
    {
#line 220
    tmp___0 = atol(status);
#line 220
    tmp___1 = tmp___0;
    }
  } else {
#line 220
    tmp___1 = -1L;
  }
#line 220
  return (tmp___1);
}
}
#line 223 "rtapelib.c"
static off_t get_status_off(int handle ) 
{ 
  char command_buffer[64] ;
  char const   *status ;
  char *tmp ;
  off_t count ;
  int negative ;
  int tmp___0 ;
  int digit ;
  char const   *tmp___1 ;
  off_t c10 ;
  off_t nc ;
  off_t tmp___2 ;
  int tmp___3 ;

  {
  {
#line 227
  tmp = get_status_string(handle, command_buffer);
#line 227
  status = (char const   *)tmp;
  }
#line 229
  if (! status) {
#line 230
    return ((off_t )-1);
  } else {
#line 237
    count = (off_t )0;
    {
#line 240
    while (1) {
      while_continue: /* CIL Label */ ;
#line 240
      if (! ((int const   )*status == 32)) {
#line 240
        if (! ((int const   )*status == 9)) {
#line 240
          goto while_break;
        }
      }
#line 241
      goto __Cont;
      __Cont: /* CIL Label */ 
#line 240
      status ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 243
    negative = (int const   )*status == 45;
#line 244
    if (negative) {
#line 244
      tmp___0 = 1;
    } else
#line 244
    if ((int const   )*status == 43) {
#line 244
      tmp___0 = 1;
    } else {
#line 244
      tmp___0 = 0;
    }
#line 244
    status += tmp___0;
    {
#line 246
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 248
      tmp___1 = status;
#line 248
      status ++;
#line 248
      digit = (int )((int const   )*tmp___1 - 48);
#line 249
      if (9U < (unsigned int )digit) {
#line 250
        goto while_break___0;
      } else {
#line 253
        c10 = 10LL * count;
#line 254
        if (negative) {
#line 254
          tmp___2 = c10 - (off_t )digit;
        } else {
#line 254
          tmp___2 = c10 + (off_t )digit;
        }
#line 254
        nc = tmp___2;
#line 255
        if (c10 / 10LL != count) {
#line 256
          return ((off_t )-1);
        } else {
#line 255
          if (negative) {
#line 255
            tmp___3 = c10 < nc;
          } else {
#line 255
            tmp___3 = nc < c10;
          }
#line 255
          if (tmp___3) {
#line 256
            return ((off_t )-1);
          }
        }
#line 257
        count = nc;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 261
    return (count);
  }
}
}
#line 322 "rtapelib.c"
int rmt_open__(char const   *path___0 , int open_mode , int bias , char const   *remote_shell ) 
{ 
  int remote_pipe_number ;
  char *path_copy ;
  char *remote_host ;
  char *remote_file ;
  char *remote_user ;
  int *tmp ;
  char *cursor ;
  char const   *remote_shell_basename ;
  pid_t status ;
  char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  __uid_t tmp___3 ;
  __gid_t tmp___4 ;
  char *tmp___5 ;
  int *tmp___6 ;
  char command_buffer[64] ;
  int *tmp___7 ;
  int tmp___8 ;
  long tmp___9 ;

  {
#line 333
  remote_pipe_number = 0;
  {
#line 333
  while (1) {
    while_continue: /* CIL Label */ ;
#line 333
    if (! (remote_pipe_number < 4)) {
#line 333
      goto while_break;
    }
#line 336
    if (from_remote[remote_pipe_number][0] == -1) {
#line 336
      if (to_remote[remote_pipe_number][1] == -1) {
#line 338
        goto while_break;
      }
    }
#line 333
    remote_pipe_number ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 340
  if (remote_pipe_number == 4) {
    {
#line 342
    tmp = __errno_location();
#line 342
    *tmp = 24;
    }
#line 343
    return (-1);
  }
  {
#line 351
  path_copy = xstrdup(path___0);
#line 352
  remote_host = path_copy;
#line 353
  remote_user = (char *)((void *)0);
#line 354
  remote_file = (char *)((void *)0);
#line 356
  cursor = path_copy;
  }
  {
#line 356
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 356
    if (! *cursor) {
#line 356
      goto while_break___0;
    }
    {
#line 362
    if ((int )*cursor == 64) {
#line 362
      goto case_64;
    }
#line 371
    if ((int )*cursor == 58) {
#line 371
      goto case_58;
    }
#line 359
    goto switch_default;
    switch_default: /* CIL Label */ 
#line 360
    goto switch_break;
    case_64: /* CIL Label */ 
#line 363
    if (! remote_user) {
#line 365
      remote_user = remote_host;
#line 366
      *cursor = (char )'\000';
#line 367
      remote_host = cursor + 1;
    }
#line 369
    goto switch_break;
    case_58: /* CIL Label */ 
#line 372
    if (! remote_file) {
#line 374
      *cursor = (char )'\000';
#line 375
      remote_file = cursor + 1;
    }
#line 377
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 356
    cursor ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 383
  if (remote_user) {
#line 383
    if ((int )*remote_user == 0) {
#line 384
      remote_user = (char *)((void *)0);
    }
  }
#line 406
  if (! remote_shell) {
#line 409
    remote_shell = "/usr/bin/rsh";
  }
  {
#line 416
  tmp___0 = base_name(remote_shell);
#line 416
  remote_shell_basename = (char const   *)tmp___0;
  }
#line 417
  if (remote_shell_basename) {
#line 418
    remote_shell_basename ++;
  } else {
#line 420
    remote_shell_basename = remote_shell;
  }
  {
#line 424
  tmp___1 = pipe((int *)(to_remote[remote_pipe_number]));
  }
#line 424
  if (tmp___1 == -1) {
    {
#line 427
    free((void *)path_copy);
    }
#line 428
    return (-1);
  } else {
    {
#line 424
    tmp___2 = pipe((int *)(from_remote[remote_pipe_number]));
    }
#line 424
    if (tmp___2 == -1) {
      {
#line 427
      free((void *)path_copy);
      }
#line 428
      return (-1);
    }
  }
  {
#line 431
  status = fork();
  }
#line 432
  if (status == -1) {
    {
#line 434
    free((void *)path_copy);
    }
#line 435
    return (-1);
  }
#line 438
  if (status == 0) {
    {
#line 442
    close(0);
#line 443
    dup(to_remote[remote_pipe_number][0]);
#line 444
    close(to_remote[remote_pipe_number][0]);
#line 445
    close(to_remote[remote_pipe_number][1]);
#line 447
    close(1);
#line 448
    dup(from_remote[remote_pipe_number][1]);
#line 449
    close(from_remote[remote_pipe_number][0]);
#line 450
    close(from_remote[remote_pipe_number][1]);
#line 453
    tmp___3 = getuid();
#line 453
    setuid(tmp___3);
#line 454
    tmp___4 = getgid();
#line 454
    setgid(tmp___4);
    }
#line 457
    if (remote_user) {
      {
#line 458
      execl(remote_shell, remote_shell_basename, remote_host, "-l", remote_user, "/etc/rmt",
            (char *)0);
      }
    } else {
      {
#line 461
      execl(remote_shell, remote_shell_basename, remote_host, "/etc/rmt", (char *)0);
      }
    }
    {
#line 467
    tmp___5 = gettext("Cannot execute remote shell");
#line 467
    tmp___6 = __errno_location();
#line 467
    error(128, *tmp___6, (char const   *)tmp___5);
    }
  }
  {
#line 472
  close(from_remote[remote_pipe_number][1]);
#line 473
  close(to_remote[remote_pipe_number][0]);
#line 482
  sprintf((char */* __restrict  */)(command_buffer), (char const   */* __restrict  */)"O%s\n%d\n",
          remote_file, open_mode);
#line 483
  tmp___8 = do_command(remote_pipe_number, (char const   *)(command_buffer));
  }
#line 483
  if (tmp___8 == -1) {
    {
#line 486
    tmp___7 = __errno_location();
#line 486
    _rmt_shutdown(remote_pipe_number, *tmp___7);
#line 487
    free((void *)path_copy);
    }
#line 488
    return (-1);
  } else {
    {
#line 483
    tmp___9 = get_status(remote_pipe_number);
    }
#line 483
    if (tmp___9 == -1L) {
      {
#line 486
      tmp___7 = __errno_location();
#line 486
      _rmt_shutdown(remote_pipe_number, *tmp___7);
#line 487
      free((void *)path_copy);
      }
#line 488
      return (-1);
    }
  }
  {
#line 492
  free((void *)path_copy);
  }
#line 493
  return (remote_pipe_number + bias);
}
}
#line 501 "rtapelib.c"
int rmt_close__(int handle ) 
{ 
  int status ;
  int tmp ;
  long tmp___0 ;
  int *tmp___1 ;

  {
  {
#line 506
  tmp = do_command(handle, "C\n");
  }
#line 506
  if (tmp == -1) {
#line 507
    return (-1);
  }
  {
#line 509
  tmp___0 = get_status(handle);
#line 509
  status = (int )tmp___0;
#line 510
  tmp___1 = __errno_location();
#line 510
  _rmt_shutdown(handle, *tmp___1);
  }
#line 511
  return (status);
}
}
#line 519 "rtapelib.c"
ssize_t rmt_read__(int handle , char *buffer___1 , size_t length ) 
{ 
  char command_buffer[64] ;
  ssize_t status ;
  ssize_t rlen ;
  size_t counter ;
  int tmp ;
  long tmp___0 ;

  {
  {
#line 526
  sprintf((char */* __restrict  */)(command_buffer), (char const   */* __restrict  */)"R%lu\n",
          (unsigned long )length);
#line 527
  tmp = do_command(handle, (char const   *)(command_buffer));
  }
#line 527
  if (tmp == -1) {
#line 529
    return (-1);
  } else {
    {
#line 527
    tmp___0 = get_status(handle);
#line 527
    status = (ssize_t )tmp___0;
    }
#line 527
    if (status == -1) {
#line 529
      return (-1);
    }
  }
#line 531
  counter = (size_t )0;
  {
#line 531
  while (1) {
    while_continue: /* CIL Label */ ;
#line 531
    if (! (counter < (size_t )status)) {
#line 531
      goto while_break;
    }
    {
#line 533
    rlen = safe_read(from_remote[handle][0], (void *)buffer___1, (size_t )status - counter);
    }
#line 534
    if (rlen <= 0) {
      {
#line 536
      _rmt_shutdown(handle, 5);
      }
#line 537
      return (-1);
    }
#line 531
    counter += (size_t )rlen;
#line 531
    buffer___1 += rlen;
  }
  while_break: /* CIL Label */ ;
  }
#line 541
  return (status);
}
}
#line 549 "rtapelib.c"
ssize_t rmt_write__(int handle , char *buffer___1 , size_t length ) 
{ 
  char command_buffer[64] ;
  void (*pipe_handler)() ;
  int tmp ;
  __sighandler_t tmp___0 ;
  long tmp___1 ;
  ssize_t tmp___2 ;

  {
  {
#line 555
  sprintf((char */* __restrict  */)(command_buffer), (char const   */* __restrict  */)"W%lu\n",
          (unsigned long )length);
#line 556
  tmp = do_command(handle, (char const   *)(command_buffer));
  }
#line 556
  if (tmp == -1) {
#line 557
    return (-1);
  }
  {
#line 559
  tmp___0 = signal(13, (void (*)(int  ))1);
#line 559
  pipe_handler = (void (*)())tmp___0;
#line 560
  tmp___2 = full_write(to_remote[handle][1], (char const   *)buffer___1, length);
  }
#line 560
  if ((size_t )tmp___2 == length) {
    {
#line 562
    signal(13, (void (*)(int  ))pipe_handler);
#line 563
    tmp___1 = get_status(handle);
    }
#line 563
    return ((ssize_t )tmp___1);
  }
  {
#line 568
  signal(13, (void (*)(int  ))pipe_handler);
#line 569
  _rmt_shutdown(handle, 5);
  }
#line 570
  return (-1);
}
}
#line 578 "rtapelib.c"
off_t rmt_lseek__(int handle , off_t offset , int whence ) 
{ 
  char command_buffer[64] ;
  char operand_buffer[(((sizeof(uintmax_t ) * 8UL) * 302UL) / 1000UL + 1UL) + 1UL] ;
  uintmax_t u ;
  uintmax_t tmp ;
  char *p ;
  int tmp___0 ;
  off_t tmp___1 ;

  {
#line 583
  if (offset < 0LL) {
#line 583
    tmp = - ((uintmax_t )offset);
  } else {
#line 583
    tmp = (uintmax_t )offset;
  }
#line 583
  u = tmp;
#line 584
  p = operand_buffer + sizeof(operand_buffer);
  {
#line 586
  while (1) {
    while_continue: /* CIL Label */ ;
#line 587
    p --;
#line 587
    *p = (char )(48 + (int )(u % 10ULL));
#line 586
    u /= 10ULL;
#line 586
    if (! (u != 0ULL)) {
#line 586
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 589
  if (offset < 0LL) {
#line 590
    p --;
#line 590
    *p = (char )'-';
  }
  {
#line 594
  if (whence == 0) {
#line 594
    goto case_0;
  }
#line 595
  if (whence == 1) {
#line 595
    goto case_1;
  }
#line 596
  if (whence == 2) {
#line 596
    goto case_2;
  }
#line 597
  goto switch_default;
  case_0: /* CIL Label */ 
#line 594
  whence = 0;
#line 594
  goto switch_break;
  case_1: /* CIL Label */ 
#line 595
  whence = 1;
#line 595
  goto switch_break;
  case_2: /* CIL Label */ 
#line 596
  whence = 2;
#line 596
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 597
  abort();
  }
  switch_break: /* CIL Label */ ;
  }
  {
#line 600
  sprintf((char */* __restrict  */)(command_buffer), (char const   */* __restrict  */)"L%s\n%d\n",
          p, whence);
#line 602
  tmp___0 = do_command(handle, (char const   *)(command_buffer));
  }
#line 602
  if (tmp___0 == -1) {
#line 603
    return ((off_t )-1);
  }
  {
#line 605
  tmp___1 = get_status_off(handle);
  }
#line 605
  return (tmp___1);
}
}
#line 613 "rtapelib.c"
int rmt_ioctl__(int handle , int operation , char *argument ) 
{ 
  int *tmp ;
  char command_buffer[64] ;
  char operand_buffer[(((sizeof(uintmax_t ) * 8UL) * 302UL) / 1000UL + 1UL) + 1UL] ;
  uintmax_t u ;
  uintmax_t tmp___0 ;
  char *p ;
  int tmp___1 ;
  long tmp___2 ;
  ssize_t status ;
  ssize_t counter ;
  int tmp___3 ;
  long tmp___4 ;
  char copy ;

  {
  {
#line 623
  if (operation == (int )((unsigned long )(((1U << 30) | (unsigned int )(109 << 8)) | 1U) | (sizeof(struct mtop ) << 16))) {
#line 623
    goto case_exp;
  }
#line 650
  if (operation == (int )((unsigned long )(((2U << 30) | (unsigned int )(109 << 8)) | 2U) | (sizeof(struct mtget ) << 16))) {
#line 650
    goto case_exp___0;
  }
#line 618
  goto switch_default;
  switch_default: /* CIL Label */ 
  {
#line 619
  tmp = __errno_location();
#line 619
  *tmp = 95;
  }
#line 620
  return (-1);
  case_exp: /* CIL Label */ 
#line 627
  if (((struct mtop *)argument)->mt_count < 0) {
#line 627
    tmp___0 = - ((uintmax_t )((struct mtop *)argument)->mt_count);
  } else {
#line 627
    tmp___0 = (uintmax_t )((struct mtop *)argument)->mt_count;
  }
#line 627
  u = tmp___0;
#line 630
  p = operand_buffer + sizeof(operand_buffer);
  {
#line 632
  while (1) {
    while_continue: /* CIL Label */ ;
#line 633
    p --;
#line 633
    *p = (char )(48 + (int )(u % 10ULL));
#line 632
    u /= 10ULL;
#line 632
    if (! (u != 0ULL)) {
#line 632
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 635
  if (((struct mtop *)argument)->mt_count < 0) {
#line 636
    p --;
#line 636
    *p = (char )'-';
  }
  {
#line 640
  sprintf((char */* __restrict  */)(command_buffer), (char const   */* __restrict  */)"I%d\n%s\n",
          (int )((struct mtop *)argument)->mt_op, p);
#line 642
  tmp___1 = do_command(handle, (char const   *)(command_buffer));
  }
#line 642
  if (tmp___1 == -1) {
#line 643
    return (-1);
  }
  {
#line 645
  tmp___2 = get_status(handle);
  }
#line 645
  return ((int )tmp___2);
  case_exp___0: /* CIL Label */ 
  {
#line 661
  tmp___3 = do_command(handle, "S");
  }
#line 661
  if (tmp___3 == -1) {
#line 663
    return (-1);
  } else {
    {
#line 661
    tmp___4 = get_status(handle);
#line 661
    status = (ssize_t )tmp___4;
    }
#line 661
    if (status == -1) {
#line 663
      return (-1);
    }
  }
  {
#line 665
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 665
    if (! (status > 0)) {
#line 665
      goto while_break___0;
    }
    {
#line 667
    counter = safe_read(from_remote[handle][0], (void *)argument, (size_t )status);
    }
#line 669
    if (counter <= 0) {
      {
#line 671
      _rmt_shutdown(handle, 5);
      }
#line 672
      return (-1);
    }
#line 665
    status -= counter;
#line 665
    argument += counter;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 681
  if (((struct mtget *)argument)->mt_type < 256L) {
#line 682
    return (0);
  }
#line 684
  counter = 0;
  {
#line 684
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 684
    if (! (counter < status)) {
#line 684
      goto while_break___1;
    }
#line 686
    copy = *(argument + counter);
#line 688
    *(argument + counter) = *(argument + (counter + 1));
#line 689
    *(argument + (counter + 1)) = copy;
#line 684
    counter += 2;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 692
  return (0);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 85 "/usr/include/string.h"
extern char *strncpy(char * __restrict  __dest , char const   * __restrict  __src ,
                     size_t __n ) ;
#line 434 "/usr/include/unistd.h"
extern int chdir(char const   *__path ) ;
#line 111 "/usr/include/pwd.h"
extern struct passwd *getpwuid(__uid_t __uid ) ;
#line 117
extern struct passwd *getpwnam(char const   *__name ) ;
#line 63 "/usr/include/grp.h"
extern void setgrent(void) ;
#line 103
extern struct group *getgrgid(__gid_t __gid ) ;
#line 109
extern struct group *getgrnam(char const   *__name ) ;
#line 461 "common.h"
int unquote_string(char *string ) ;
#line 472
void gid_to_gname(gid_t gid , char *gname ) ;
#line 474
void uid_to_uname(uid_t uid , char *uname ) ;
#line 481
char *name_next(int change_dirs ) ;
#line 485
int name_match(char const   *path___0 ) ;
#line 490
void blank_name_list(void) ;
#line 491
char *new_name(char const   *path___0 , char const   *name ) ;
#line 45 "names.c"
static char cached_uname[32]  = {      (char )'\000'};
#line 46 "names.c"
static char cached_gname[32]  = {      (char )'\000'};
#line 48 "names.c"
static uid_t cached_uid  ;
#line 49 "names.c"
static gid_t cached_gid  ;
#line 52 "names.c"
static char cached_no_such_uname[32]  = {      (char )'\000'};
#line 53 "names.c"
static char cached_no_such_gname[32]  = {      (char )'\000'};
#line 57 "names.c"
static uid_t cached_no_such_uid  =    (uid_t )0;
#line 58 "names.c"
static gid_t cached_no_such_gid  =    (gid_t )0;
#line 64 "names.c"
void uid_to_uname(uid_t uid , char *uname ) 
{ 
  struct passwd *passwd ;

  {
#line 69
  if (uid != 0U) {
#line 69
    if (uid == cached_no_such_uid) {
#line 71
      *uname = (char )'\000';
#line 72
      return;
    }
  }
#line 75
  if (! cached_uname[0]) {
#line 75
    goto _L;
  } else
#line 75
  if (uid != cached_uid) {
    _L: /* CIL Label */ 
    {
#line 77
    passwd = getpwuid(uid);
    }
#line 78
    if (passwd) {
      {
#line 80
      cached_uid = uid;
#line 81
      strncpy((char */* __restrict  */)(cached_uname), (char const   */* __restrict  */)passwd->pw_name,
              (size_t )32);
      }
    } else {
#line 85
      cached_no_such_uid = uid;
#line 86
      *uname = (char )'\000';
#line 87
      return;
    }
  }
  {
#line 90
  strncpy((char */* __restrict  */)uname, (char const   */* __restrict  */)(cached_uname),
          (size_t )32);
  }
#line 91
  return;
}
}
#line 97 "names.c"
void gid_to_gname(gid_t gid , char *gname ) 
{ 
  struct group *group ;

  {
#line 102
  if (gid != 0U) {
#line 102
    if (gid == cached_no_such_gid) {
#line 104
      *gname = (char )'\000';
#line 105
      return;
    }
  }
#line 108
  if (! cached_gname[0]) {
#line 108
    goto _L;
  } else
#line 108
  if (gid != cached_gid) {
    _L: /* CIL Label */ 
    {
#line 110
    setgrent();
#line 111
    group = getgrgid(gid);
    }
#line 112
    if (group) {
      {
#line 114
      cached_gid = gid;
#line 115
      strncpy((char */* __restrict  */)(cached_gname), (char const   */* __restrict  */)group->gr_name,
              (size_t )32);
      }
    } else {
#line 119
      cached_no_such_gid = gid;
#line 120
      *gname = (char )'\000';
#line 121
      return;
    }
  }
  {
#line 124
  strncpy((char */* __restrict  */)gname, (char const   */* __restrict  */)(cached_gname),
          (size_t )32);
  }
#line 125
  return;
}
}
#line 131 "names.c"
int uname_to_uid(char *uname , uid_t *uidp ) 
{ 
  struct passwd *passwd ;
  int tmp ;
  int tmp___0 ;

  {
#line 136
  if (cached_no_such_uname[0]) {
    {
#line 136
    tmp = strncmp((char const   *)uname, (char const   *)(cached_no_such_uname), (size_t )32);
    }
#line 136
    if (tmp == 0) {
#line 138
      return (0);
    }
  }
#line 140
  if (! cached_uname[0]) {
#line 140
    goto _L;
  } else
#line 140
  if ((int )*(uname + 0) != (int )cached_uname[0]) {
#line 140
    goto _L;
  } else {
    {
#line 140
    tmp___0 = strncmp((char const   *)uname, (char const   *)(cached_uname), (size_t )32);
    }
#line 140
    if (tmp___0 != 0) {
      _L: /* CIL Label */ 
      {
#line 144
      passwd = getpwnam((char const   *)uname);
      }
#line 145
      if (passwd) {
        {
#line 147
        cached_uid = passwd->pw_uid;
#line 148
        strncpy((char */* __restrict  */)(cached_uname), (char const   */* __restrict  */)uname,
                (size_t )32);
        }
      } else {
        {
#line 152
        strncpy((char */* __restrict  */)(cached_no_such_uname), (char const   */* __restrict  */)uname,
                (size_t )32);
        }
#line 153
        return (0);
      }
    }
  }
#line 156
  *uidp = cached_uid;
#line 157
  return (1);
}
}
#line 164 "names.c"
int gname_to_gid(char *gname , gid_t *gidp ) 
{ 
  struct group *group ;
  int tmp ;
  int tmp___0 ;

  {
#line 169
  if (cached_no_such_gname[0]) {
    {
#line 169
    tmp = strncmp((char const   *)gname, (char const   *)(cached_no_such_gname), (size_t )32);
    }
#line 169
    if (tmp == 0) {
#line 171
      return (0);
    }
  }
#line 173
  if (! cached_gname[0]) {
#line 173
    goto _L;
  } else
#line 173
  if ((int )*(gname + 0) != (int )cached_gname[0]) {
#line 173
    goto _L;
  } else {
    {
#line 173
    tmp___0 = strncmp((char const   *)gname, (char const   *)(cached_gname), (size_t )32);
    }
#line 173
    if (tmp___0 != 0) {
      _L: /* CIL Label */ 
      {
#line 177
      group = getgrnam((char const   *)gname);
      }
#line 178
      if (group) {
        {
#line 180
        cached_gid = group->gr_gid;
#line 181
        strncpy((char */* __restrict  */)(cached_gname), (char const   */* __restrict  */)gname,
                (size_t )32);
        }
      } else {
        {
#line 185
        strncpy((char */* __restrict  */)(cached_no_such_gname), (char const   */* __restrict  */)gname,
                (size_t )32);
        }
#line 186
        return (0);
      }
    }
  }
#line 189
  *gidp = cached_gid;
#line 190
  return (1);
}
}
#line 195 "names.c"
static char const   **name_array  ;
#line 196 "names.c"
static int allocated_names  ;
#line 197 "names.c"
static int names  ;
#line 198 "names.c"
static int name_index  =    0;
#line 204 "names.c"
void init_names(void) 
{ 
  void *tmp ;

  {
  {
#line 207
  allocated_names = 10;
#line 208
  tmp = xmalloc((size_t )(sizeof(char const   *) * (unsigned long )allocated_names));
#line 208
  name_array = (char const   **)tmp;
#line 210
  names = 0;
  }
#line 211
  return;
}
}
#line 217 "names.c"
void name_add(char const   *name ) 
{ 
  void *tmp ;
  int tmp___0 ;

  {
#line 220
  if (names == allocated_names) {
    {
#line 222
    allocated_names *= 2;
#line 223
    tmp = xrealloc((void *)name_array, (size_t )(sizeof(char const   *) * (unsigned long )allocated_names));
#line 223
    name_array = (char const   **)tmp;
    }
  }
#line 226
  tmp___0 = names;
#line 226
  names ++;
#line 226
  *(name_array + tmp___0) = name;
#line 227
  return;
}
}
#line 231 "names.c"
static FILE *name_file  ;
#line 232 "names.c"
static char *name_buffer  ;
#line 233 "names.c"
static size_t name_buffer_length  ;
#line 243 "names.c"
__inline static int is_pattern(char const   *string ) 
{ 
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;

  {
  {
#line 246
  tmp = strchr(string, '*');
  }
#line 246
  if (tmp) {
#line 246
    tmp___2 = 1;
  } else {
    {
#line 246
    tmp___0 = strchr(string, '[');
    }
#line 246
    if (tmp___0) {
#line 246
      tmp___2 = 1;
    } else {
      {
#line 246
      tmp___1 = strchr(string, '?');
      }
#line 246
      if (tmp___1) {
#line 246
        tmp___2 = 1;
      } else {
#line 246
        tmp___2 = 0;
      }
    }
  }
#line 246
  return (tmp___2);
}
}
#line 254 "names.c"
void name_init(int argc , char * const  *argv ) 
{ 
  void *tmp ;
  char *tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;

  {
  {
#line 257
  tmp = xmalloc((size_t )102);
#line 257
  name_buffer = (char *)tmp;
#line 258
  name_buffer_length = (size_t )100;
  }
#line 260
  if (files_from_option) {
    {
#line 262
    tmp___3 = strcmp(files_from_option, "-");
    }
#line 262
    if (tmp___3) {
      {
#line 267
      name_file = fopen((char const   */* __restrict  */)files_from_option, (char const   */* __restrict  */)"r");
      }
#line 267
      if (! name_file) {
        {
#line 268
        tmp___0 = gettext("Cannot open file %s");
#line 268
        tmp___1 = __errno_location();
#line 268
        error(0, *tmp___1, (char const   *)tmp___0, files_from_option);
#line 268
        tmp___2 = gettext("Error is not recoverable: exiting now");
#line 268
        error(2, 0, (char const   *)tmp___2);
        }
      }
    } else {
      {
#line 264
      request_stdin("-T");
#line 265
      name_file = stdin;
      }
    }
  }
#line 270
  return;
}
}
#line 276 "names.c"
void name_term(void) 
{ 


  {
  {
#line 279
  free((void *)name_buffer);
#line 280
  free((void *)name_array);
  }
#line 281
  return;
}
}
#line 289 "names.c"
static int read_name_from_file(void) 
{ 
  int character ;
  size_t counter ;
  void *tmp ;
  size_t tmp___0 ;
  int tmp___1 ;
  void *tmp___2 ;

  {
#line 293
  counter = (size_t )0;
  {
#line 299
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 299
    character = _IO_getc(name_file);
    }
#line 299
    if (character != -1) {
#line 299
      if (character != (int )filename_terminator) {
#line 299
        tmp___1 = 1;
      } else {
#line 299
        tmp___1 = 0;
      }
    } else {
#line 299
      tmp___1 = 0;
    }
#line 299
    if (! tmp___1) {
#line 299
      goto while_break;
    }
#line 302
    if (counter == name_buffer_length) {
      {
#line 304
      name_buffer_length += 100U;
#line 305
      tmp = xrealloc((void *)name_buffer, name_buffer_length + 2U);
#line 305
      name_buffer = (char *)tmp;
      }
    }
#line 307
    tmp___0 = counter;
#line 307
    counter ++;
#line 307
    *(name_buffer + tmp___0) = (char )character;
  }
  while_break: /* CIL Label */ ;
  }
#line 310
  if (counter == 0U) {
#line 310
    if (character == -1) {
#line 311
      return (0);
    }
  }
#line 313
  if (counter == name_buffer_length) {
    {
#line 315
    name_buffer_length += 100U;
#line 316
    tmp___2 = xrealloc((void *)name_buffer, name_buffer_length + 2U);
#line 316
    name_buffer = (char *)tmp___2;
    }
  }
#line 318
  *(name_buffer + counter) = (char )'\000';
#line 320
  return (1);
}
}
#line 332 "names.c"
char *name_next(int change_dirs ) 
{ 
  char const   *source ;
  char *cursor ;
  int chdir_flag ;
  int tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  int *tmp___6 ;
  char *tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;

  {
#line 337
  chdir_flag = 0;
#line 339
  if ((int )filename_terminator == 0) {
#line 340
    change_dirs = 0;
  }
  {
#line 342
  while (1) {
    while_continue: /* CIL Label */ ;
#line 346
    if (name_file) {
      {
#line 348
      tmp = read_name_from_file();
      }
#line 348
      if (! tmp) {
#line 349
        goto while_break;
      }
    } else {
#line 353
      if (name_index == names) {
#line 354
        goto while_break;
      }
      {
#line 356
      tmp___0 = name_index;
#line 356
      name_index ++;
#line 356
      source = *(name_array + tmp___0);
#line 357
      tmp___2 = strlen(source);
      }
#line 357
      if (tmp___2 > name_buffer_length) {
        {
#line 359
        free((void *)name_buffer);
#line 360
        name_buffer_length = strlen(source);
#line 361
        tmp___1 = xmalloc(name_buffer_length + 2U);
#line 361
        name_buffer = (char *)tmp___1;
        }
      }
      {
#line 363
      strcpy((char */* __restrict  */)name_buffer, (char const   */* __restrict  */)source);
      }
    }
    {
#line 368
    tmp___3 = strlen((char const   *)name_buffer);
#line 368
    cursor = (name_buffer + tmp___3) - 1;
    }
    {
#line 369
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 369
      if ((unsigned long )cursor > (unsigned long )name_buffer) {
#line 369
        if (! ((int )*cursor == 47)) {
#line 369
          goto while_break___0;
        }
      } else {
#line 369
        goto while_break___0;
      }
#line 370
      tmp___4 = cursor;
#line 370
      cursor --;
#line 370
      *tmp___4 = (char )'\000';
    }
    while_break___0: /* CIL Label */ ;
    }
#line 372
    if (chdir_flag) {
      {
#line 374
      tmp___8 = chdir((char const   *)name_buffer);
      }
#line 374
      if (tmp___8 < 0) {
        {
#line 375
        tmp___5 = gettext("Cannot change to directory %s");
#line 375
        tmp___6 = __errno_location();
#line 375
        error(0, *tmp___6, (char const   *)tmp___5, name_buffer);
#line 375
        tmp___7 = gettext("Error is not recoverable: exiting now");
#line 375
        error(2, 0, (char const   *)tmp___7);
        }
      }
#line 377
      chdir_flag = 0;
    } else
#line 379
    if (change_dirs) {
      {
#line 379
      tmp___9 = strcmp((char const   *)name_buffer, "-C");
      }
#line 379
      if (tmp___9 == 0) {
#line 380
        chdir_flag = 1;
      } else {
        {
#line 383
        unquote_string(name_buffer);
        }
#line 384
        return (name_buffer);
      }
    } else {
      {
#line 383
      unquote_string(name_buffer);
      }
#line 384
      return (name_buffer);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 390
  if (name_file) {
#line 390
    if (chdir_flag) {
      {
#line 391
      tmp___10 = gettext("Missing file name after -C");
#line 391
      error(0, 0, (char const   *)tmp___10);
#line 391
      tmp___11 = gettext("Error is not recoverable: exiting now");
#line 391
      error(2, 0, (char const   *)tmp___11);
      }
    }
  }
#line 393
  return ((char *)((void *)0));
}
}
#line 400 "names.c"
void name_close(void) 
{ 
  int *tmp ;
  int tmp___0 ;

  {
#line 403
  if ((unsigned long )name_file != (unsigned long )((void *)0)) {
#line 403
    if ((unsigned long )name_file != (unsigned long )stdin) {
      {
#line 404
      tmp___0 = fclose(name_file);
      }
#line 404
      if (tmp___0 == -1) {
        {
#line 405
        tmp = __errno_location();
#line 405
        error(0, *tmp, "%s", name_buffer);
#line 405
        exit_status = 2;
        }
      }
    }
  }
#line 406
  return;
}
}
#line 424 "names.c"
static struct name *buffer  ;
#line 425 "names.c"
static size_t allocated_length  =    (size_t )0;
#line 420 "names.c"
void name_gather(void) 
{ 
  char *name ;
  void *tmp ;
  char *copy ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  void *tmp___5 ;

  {
#line 429
  if (same_order_option) {
#line 431
    if (allocated_length == 0U) {
      {
#line 433
      allocated_length = (size_t )(sizeof(struct name ) + 100UL);
#line 434
      tmp = xmalloc(allocated_length);
#line 434
      buffer = (struct name *)tmp;
#line 436
      memset((void *)buffer, 0, allocated_length);
      }
    }
    {
#line 438
    name = name_next(0);
    }
#line 439
    if (name) {
      {
#line 441
      tmp___4 = strcmp((char const   *)name, "-C");
      }
#line 441
      if (tmp___4 == 0) {
        {
#line 443
        tmp___0 = name_next(0);
#line 443
        tmp___1 = xstrdup((char const   *)tmp___0);
#line 443
        copy = tmp___1;
#line 445
        name = name_next(0);
        }
#line 446
        if (! name) {
          {
#line 447
          tmp___2 = gettext("Missing file name after -C");
#line 447
          error(0, 0, (char const   *)tmp___2);
#line 447
          tmp___3 = gettext("Error is not recoverable: exiting now");
#line 447
          error(2, 0, (char const   *)tmp___3);
          }
        }
#line 448
        buffer->change_dir = copy;
      }
      {
#line 450
      buffer->length = strlen((char const   *)name);
      }
#line 451
      if (sizeof(struct name ) + (unsigned long )buffer->length >= (unsigned long )allocated_length) {
        {
#line 453
        allocated_length = (size_t )(sizeof(struct name ) + (unsigned long )buffer->length);
#line 454
        tmp___5 = xrealloc((void *)buffer, allocated_length);
#line 454
        buffer = (struct name *)tmp___5;
        }
      }
      {
#line 456
      strncpy((char */* __restrict  */)(buffer->name), (char const   */* __restrict  */)name,
              buffer->length);
#line 457
      buffer->name[buffer->length] = (char)0;
#line 458
      buffer->next = (struct name *)((void *)0);
#line 459
      buffer->found = (char)0;
#line 462
      namelist = buffer;
#line 463
      namelast = namelist;
      }
    }
#line 465
    return;
  }
  {
#line 470
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 470
    name = name_next(0);
    }
#line 470
    if (! name) {
#line 470
      goto while_break;
    }
    {
#line 471
    addname((char const   *)name);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 472
  return;
}
}
#line 482 "names.c"
static char *chdir_name  =    (char *)((void *)0);
#line 478 "names.c"
void addname(char const   *string ) 
{ 
  struct name *name ;
  size_t length ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *path___0 ;
  void *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  int tmp___7 ;
  size_t tmp___8 ;
  void *tmp___9 ;
  int tmp___10 ;

  {
  {
#line 487
  tmp___7 = strcmp(string, "-C");
  }
#line 487
  if (tmp___7 == 0) {
    {
#line 489
    tmp = name_next(0);
#line 489
    chdir_name = xstrdup((char const   *)tmp);
#line 490
    tmp___0 = name_next(0);
#line 490
    string = (char const   *)tmp___0;
    }
#line 491
    if (! chdir_name) {
      {
#line 492
      tmp___1 = gettext("Missing file name after -C");
#line 492
      error(0, 0, (char const   *)tmp___1);
#line 492
      tmp___2 = gettext("Error is not recoverable: exiting now");
#line 492
      error(2, 0, (char const   *)tmp___2);
      }
    }
#line 494
    if ((int )*(chdir_name + 0) != 47) {
      {
#line 496
      tmp___3 = xmalloc((size_t )4096);
#line 496
      path___0 = (char *)tmp___3;
#line 500
      tmp___6 = getcwd(path___0, (size_t )4096);
      }
#line 500
      if (! tmp___6) {
        {
#line 501
        tmp___4 = gettext("Could not get current directory");
#line 501
        error(0, 0, (char const   *)tmp___4);
#line 501
        tmp___5 = gettext("Error is not recoverable: exiting now");
#line 501
        error(2, 0, (char const   *)tmp___5);
        }
      }
      {
#line 509
      chdir_name = new_name((char const   *)path___0, (char const   *)chdir_name);
#line 510
      free((void *)path___0);
      }
    }
  }
#line 514
  if (string) {
    {
#line 514
    tmp___8 = strlen(string);
#line 514
    length = tmp___8;
    }
  } else {
#line 514
    length = (size_t )0;
  }
  {
#line 515
  tmp___9 = xmalloc((size_t )(sizeof(struct name ) + (unsigned long )length));
#line 515
  name = (struct name *)tmp___9;
#line 516
  memset((void *)name, 0, (size_t )(sizeof(struct name ) + (unsigned long )length));
#line 517
  name->next = (struct name *)((void *)0);
  }
#line 519
  if (string) {
    {
#line 521
    name->fake = (char)0;
#line 522
    name->length = length;
#line 524
    strncpy((char */* __restrict  */)(name->name), (char const   */* __restrict  */)string,
            length);
#line 525
    name->name[length] = (char )'\000';
    }
  } else {
#line 528
    name->fake = (char)1;
  }
#line 530
  name->found = (char)0;
#line 531
  name->regexp = (char)0;
#line 532
  name->firstch = (char)1;
#line 533
  name->change_dir = chdir_name;
#line 534
  name->dir_contents = (char const   *)0;
#line 536
  if (string) {
    {
#line 536
    tmp___10 = is_pattern(string);
    }
#line 536
    if (tmp___10) {
#line 538
      name->regexp = (char)1;
#line 539
      if ((int const   )*(string + 0) == 42) {
#line 540
        name->firstch = (char)0;
      } else
#line 539
      if ((int const   )*(string + 0) == 91) {
#line 540
        name->firstch = (char)0;
      } else
#line 539
      if ((int const   )*(string + 0) == 63) {
#line 540
        name->firstch = (char)0;
      }
    }
  }
#line 543
  if (namelast) {
#line 544
    namelast->next = name;
  }
#line 545
  namelast = name;
#line 546
  if (! namelist) {
#line 547
    namelist = name;
  }
#line 548
  return;
}
}
#line 555 "names.c"
int name_match(char const   *path___0 ) 
{ 
  size_t length ;
  size_t tmp ;
  struct name *cursor ;
  char *tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  char *tmp___4 ;
  int *tmp___5 ;
  char *tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  char *tmp___9 ;
  int *tmp___10 ;
  char *tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;

  {
  {
#line 558
  tmp = strlen(path___0);
#line 558
  length = tmp;
  }
  {
#line 560
  while (1) {
    while_continue: /* CIL Label */ ;
#line 562
    cursor = namelist;
#line 564
    if (! cursor) {
#line 565
      return (1);
    }
#line 567
    if (cursor->fake) {
#line 569
      if (cursor->change_dir) {
        {
#line 569
        tmp___3 = chdir((char const   *)cursor->change_dir);
        }
#line 569
        if (tmp___3) {
          {
#line 570
          tmp___0 = gettext("Cannot change to directory %s");
#line 570
          tmp___1 = __errno_location();
#line 570
          error(0, *tmp___1, (char const   *)tmp___0, cursor->change_dir);
#line 570
          tmp___2 = gettext("Error is not recoverable: exiting now");
#line 570
          error(2, 0, (char const   *)tmp___2);
          }
        }
      }
#line 572
      namelist = (struct name *)0;
#line 573
      return (1);
    }
    {
#line 576
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 576
      if (! cursor) {
#line 576
        goto while_break___0;
      }
#line 580
      if (cursor->firstch) {
#line 580
        if ((int )cursor->name[0] != (int )*(path___0 + 0)) {
#line 581
          goto __Cont;
        }
      }
#line 585
      if (cursor->regexp) {
        {
#line 587
        tmp___8 = fnmatch((char const   *)(cursor->name), path___0, 1 << 3);
        }
#line 587
        if (tmp___8 == 0) {
#line 589
          cursor->found = (char)1;
#line 590
          if (starting_file_option) {
            {
#line 592
            free((void *)namelist);
#line 593
            namelist = (struct name *)((void *)0);
            }
          }
#line 595
          if (cursor->change_dir) {
            {
#line 595
            tmp___7 = chdir((char const   *)cursor->change_dir);
            }
#line 595
            if (tmp___7) {
              {
#line 596
              tmp___4 = gettext("Cannot change to directory %s");
#line 596
              tmp___5 = __errno_location();
#line 596
              error(0, *tmp___5, (char const   *)tmp___4, cursor->change_dir);
#line 596
              tmp___6 = gettext("Error is not recoverable: exiting now");
#line 596
              error(2, 0, (char const   *)tmp___6);
              }
            }
          }
#line 600
          return (1);
        }
#line 602
        goto __Cont;
      }
#line 607
      if (cursor->length <= length) {
#line 607
        if ((int const   )*(path___0 + cursor->length) == 0) {
#line 607
          goto _L;
        } else
#line 607
        if ((int const   )*(path___0 + cursor->length) == 47) {
          _L: /* CIL Label */ 
          {
#line 607
          tmp___13 = strncmp(path___0, (char const   *)(cursor->name), cursor->length);
          }
#line 607
          if (tmp___13 == 0) {
#line 615
            cursor->found = (char)1;
#line 616
            if (starting_file_option) {
              {
#line 618
              free((void *)namelist);
#line 619
              namelist = (struct name *)0;
              }
            }
#line 621
            if (cursor->change_dir) {
              {
#line 621
              tmp___12 = chdir((char const   *)cursor->change_dir);
              }
#line 621
              if (tmp___12) {
                {
#line 622
                tmp___9 = gettext("Cannot change to directory %s");
#line 622
                tmp___10 = __errno_location();
#line 622
                error(0, *tmp___10, (char const   *)tmp___9, cursor->change_dir);
#line 622
                tmp___11 = gettext("Error is not recoverable: exiting now");
#line 622
                error(2, 0, (char const   *)tmp___11);
                }
              }
            }
#line 626
            return (1);
          }
        }
      }
      __Cont: /* CIL Label */ 
#line 576
      cursor = cursor->next;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 635
    if (same_order_option) {
#line 635
      if (namelist->found) {
        {
#line 637
        name_gather();
        }
#line 638
        if (namelist->found) {
#line 639
          return (0);
        }
      } else {
#line 642
        return (0);
      }
    } else {
#line 642
      return (0);
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 650 "names.c"
void names_notfound(void) 
{ 
  struct name *cursor ;
  struct name *next ;
  char *tmp ;
  char *name ;
  char *tmp___0 ;

  {
#line 656
  cursor = namelist;
  {
#line 656
  while (1) {
    while_continue: /* CIL Label */ ;
#line 656
    if (! cursor) {
#line 656
      goto while_break;
    }
#line 658
    next = cursor->next;
#line 659
    if (! cursor->found) {
#line 659
      if (! cursor->fake) {
        {
#line 660
        tmp = gettext("%s: Not found in archive");
#line 660
        error(0, 0, (char const   *)tmp, cursor->name);
#line 660
        exit_status = 2;
        }
      }
    }
#line 656
    cursor = next;
  }
  while_break: /* CIL Label */ ;
  }
#line 671
  namelist = (struct name *)((void *)0);
#line 672
  namelast = (struct name *)((void *)0);
#line 674
  if (same_order_option) {
    {
#line 678
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 678
      name = name_next(1);
      }
#line 678
      if (! name) {
#line 678
        goto while_break___0;
      }
      {
#line 679
      tmp___0 = gettext("%s: Not found in archive");
#line 679
      error(0, 0, (char const   *)tmp___0, name);
#line 679
      exit_status = 2;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 681
  return;
}
}
#line 687 "names.c"
void name_expand(void) 
{ 


  {
#line 690
  return;
}
}
#line 699 "names.c"
struct name *name_scan(char const   *path___0 ) 
{ 
  size_t length ;
  size_t tmp ;
  struct name *cursor ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 702
  tmp = strlen(path___0);
#line 702
  length = tmp;
  }
  {
#line 704
  while (1) {
    while_continue: /* CIL Label */ ;
#line 706
    cursor = namelist;
#line 708
    if (! cursor) {
#line 709
      return ((struct name *)((void *)0));
    }
    {
#line 711
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 711
      if (! cursor) {
#line 711
        goto while_break___0;
      }
#line 715
      if (cursor->firstch) {
#line 715
        if ((int )cursor->name[0] != (int )*(path___0 + 0)) {
#line 716
          goto __Cont;
        }
      }
#line 720
      if (cursor->regexp) {
        {
#line 722
        tmp___0 = fnmatch((char const   *)(cursor->name), path___0, 1 << 3);
        }
#line 722
        if (tmp___0 == 0) {
#line 723
          return (cursor);
        }
#line 724
        goto __Cont;
      }
#line 729
      if (cursor->length <= length) {
#line 729
        if ((int const   )*(path___0 + cursor->length) == 0) {
#line 729
          goto _L;
        } else
#line 729
        if ((int const   )*(path___0 + cursor->length) == 47) {
          _L: /* CIL Label */ 
          {
#line 729
          tmp___1 = strncmp(path___0, (char const   *)(cursor->name), cursor->length);
          }
#line 729
          if (tmp___1 == 0) {
#line 736
            return (cursor);
          }
        }
      }
      __Cont: /* CIL Label */ 
#line 711
      cursor = cursor->next;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 744
    if (same_order_option) {
#line 744
      if (namelist->found) {
        {
#line 746
        name_gather();
        }
#line 747
        if (namelist->found) {
#line 748
          return ((struct name *)((void *)0));
        }
      } else {
#line 751
        return ((struct name *)((void *)0));
      }
    } else {
#line 751
      return ((struct name *)((void *)0));
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 761 "names.c"
struct name *gnu_list_name  =    (struct name *)((void *)0);
#line 763 "names.c"
char *name_from_list(void) 
{ 
  char *tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;

  {
#line 766
  if (! gnu_list_name) {
#line 767
    gnu_list_name = namelist;
  }
  {
#line 768
  while (1) {
    while_continue: /* CIL Label */ ;
#line 768
    if (gnu_list_name) {
#line 768
      if (! gnu_list_name->found) {
#line 768
        goto while_break;
      }
    } else {
#line 768
      goto while_break;
    }
#line 769
    gnu_list_name = gnu_list_name->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 770
  if (gnu_list_name) {
#line 772
    gnu_list_name->found = (char)1;
#line 773
    if (gnu_list_name->change_dir) {
      {
#line 774
      tmp___2 = chdir((char const   *)gnu_list_name->change_dir);
      }
#line 774
      if (tmp___2 < 0) {
        {
#line 775
        tmp = gettext("Cannot change to directory %s");
#line 775
        tmp___0 = __errno_location();
#line 775
        error(0, *tmp___0, (char const   *)tmp, gnu_list_name->change_dir);
#line 775
        tmp___1 = gettext("Error is not recoverable: exiting now");
#line 775
        error(2, 0, (char const   *)tmp___1);
        }
      }
    }
#line 777
    return (gnu_list_name->name);
  }
#line 779
  return ((char *)((void *)0));
}
}
#line 786 "names.c"
void blank_name_list(void) 
{ 
  struct name *name ;

  {
#line 791
  gnu_list_name = (struct name *)0;
#line 792
  name = namelist;
  {
#line 792
  while (1) {
    while_continue: /* CIL Label */ ;
#line 792
    if (! name) {
#line 792
      goto while_break;
    }
#line 793
    name->found = (char)0;
#line 792
    name = name->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 794
  return;
}
}
#line 800 "names.c"
char *new_name(char const   *path___0 , char const   *name ) 
{ 
  char *buffer___1 ;
  size_t tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;

  {
  {
#line 803
  tmp = strlen(path___0);
#line 803
  tmp___0 = strlen(name);
#line 803
  tmp___1 = xmalloc((tmp + tmp___0) + 2U);
#line 803
  buffer___1 = (char *)tmp___1;
#line 805
  sprintf((char */* __restrict  */)buffer___1, (char const   */* __restrict  */)"%s/%s",
          path___0, name);
  }
#line 806
  return (buffer___1);
}
}
#line 38 "/usr/include/string.h"
extern void *memcpy(void * __restrict  __dest , void const   * __restrict  __src ,
                    size_t __n ) ;
#line 736 "/usr/include/unistd.h"
extern int unlink(char const   *__name ) ;
#line 739
extern int rmdir(char const   *__path ) ;
#line 154 "/usr/include/stdio.h"
extern int rename(char const   *__old , char const   *__new ) ;
#line 459 "common.h"
void assign_string(char **string , char const   *value ) ;
#line 460
char *quote_copy_string(char const   *string ) ;
#line 463
char *merge_sort(char *list , int length , int offset , int (*compare)(char * , char * ) ) ;
#line 465
int is_dot_or_dotdot(char const   *p ) ;
#line 466
int remove_any_file(char const   *path___0 , int recurse ) ;
#line 467
int maybe_backup_file(char const   *path___0 , int archive___0 ) ;
#line 468
void undo_last_backup(void) ;
#line 29 "misc.c"
void assign_string(char **string , char const   *value ) 
{ 
  char *tmp ;

  {
#line 32
  if (*string) {
    {
#line 33
    free((void *)*string);
    }
  }
#line 34
  if (value) {
    {
#line 34
    tmp = xstrdup(value);
#line 34
    *string = tmp;
    }
  } else {
#line 34
    *string = (char *)((void *)0);
  }
#line 35
  return;
}
}
#line 48 "misc.c"
char *quote_copy_string(char const   *string ) 
{ 
  char const   *source ;
  char *destination ;
  char *buffer___1 ;
  int copying ;
  int character ;
  char const   *tmp ;
  size_t length ;
  size_t tmp___0 ;
  void *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  size_t length___0 ;
  size_t tmp___5 ;
  void *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;
  char *tmp___14 ;
  char *tmp___15 ;
  char *tmp___16 ;
  unsigned short const   **tmp___17 ;

  {
#line 51
  source = string;
#line 52
  destination = (char *)((void *)0);
#line 53
  buffer___1 = (char *)((void *)0);
#line 54
  copying = 0;
  {
#line 56
  while (1) {
    while_continue: /* CIL Label */ ;
#line 56
    if (! *source) {
#line 56
      goto while_break;
    }
#line 58
    tmp = source;
#line 58
    source ++;
#line 58
    character = (int )((unsigned char )*tmp);
#line 60
    if (character == 92) {
#line 62
      if (! copying) {
        {
#line 64
        length = (size_t )((source - string) - 1L);
#line 66
        copying = 1;
#line 67
        tmp___0 = strlen(source);
#line 67
        tmp___1 = xmalloc((length + 5U) + tmp___0 * 4U);
#line 67
        buffer___1 = (char *)tmp___1;
#line 68
        memcpy((void */* __restrict  */)buffer___1, (void const   */* __restrict  */)string,
               length);
#line 69
        destination = buffer___1 + length;
        }
      }
#line 71
      tmp___2 = destination;
#line 71
      destination ++;
#line 71
      *tmp___2 = (char )'\\';
#line 72
      tmp___3 = destination;
#line 72
      destination ++;
#line 72
      *tmp___3 = (char )'\\';
    } else {
      {
#line 74
      tmp___17 = __ctype_b_loc();
      }
#line 74
      if ((int const   )*(*tmp___17 + character) & 16384) {
#line 76
        if (copying) {
#line 77
          tmp___4 = destination;
#line 77
          destination ++;
#line 77
          *tmp___4 = (char )character;
        }
      } else {
#line 81
        if (! copying) {
          {
#line 83
          length___0 = (size_t )((source - string) - 1L);
#line 85
          copying = 1;
#line 86
          tmp___5 = strlen(source);
#line 86
          tmp___6 = xmalloc((length___0 + 5U) + tmp___5 * 4U);
#line 86
          buffer___1 = (char *)tmp___6;
#line 87
          memcpy((void */* __restrict  */)buffer___1, (void const   */* __restrict  */)string,
                 length___0);
#line 88
          destination = buffer___1 + length___0;
          }
        }
#line 90
        tmp___7 = destination;
#line 90
        destination ++;
#line 90
        *tmp___7 = (char )'\\';
        {
#line 93
        if (character == 10) {
#line 93
          goto case_10;
        }
#line 97
        if (character == 9) {
#line 97
          goto case_9;
        }
#line 101
        if (character == 12) {
#line 101
          goto case_12;
        }
#line 105
        if (character == 8) {
#line 105
          goto case_8;
        }
#line 109
        if (character == 13) {
#line 109
          goto case_13;
        }
#line 113
        if (character == 127) {
#line 113
          goto case_127;
        }
#line 117
        goto switch_default;
        case_10: /* CIL Label */ 
#line 94
        tmp___8 = destination;
#line 94
        destination ++;
#line 94
        *tmp___8 = (char )'n';
#line 95
        goto switch_break;
        case_9: /* CIL Label */ 
#line 98
        tmp___9 = destination;
#line 98
        destination ++;
#line 98
        *tmp___9 = (char )'t';
#line 99
        goto switch_break;
        case_12: /* CIL Label */ 
#line 102
        tmp___10 = destination;
#line 102
        destination ++;
#line 102
        *tmp___10 = (char )'f';
#line 103
        goto switch_break;
        case_8: /* CIL Label */ 
#line 106
        tmp___11 = destination;
#line 106
        destination ++;
#line 106
        *tmp___11 = (char )'b';
#line 107
        goto switch_break;
        case_13: /* CIL Label */ 
#line 110
        tmp___12 = destination;
#line 110
        destination ++;
#line 110
        *tmp___12 = (char )'r';
#line 111
        goto switch_break;
        case_127: /* CIL Label */ 
#line 114
        tmp___13 = destination;
#line 114
        destination ++;
#line 114
        *tmp___13 = (char )'?';
#line 115
        goto switch_break;
        switch_default: /* CIL Label */ 
#line 118
        tmp___14 = destination;
#line 118
        destination ++;
#line 118
        *tmp___14 = (char )((character >> 6) + 48);
#line 119
        tmp___15 = destination;
#line 119
        destination ++;
#line 119
        *tmp___15 = (char )(((character >> 3) & 7) + 48);
#line 120
        tmp___16 = destination;
#line 120
        destination ++;
#line 120
        *tmp___16 = (char )((character & 7) + 48);
#line 121
        goto switch_break;
        switch_break: /* CIL Label */ ;
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 125
  if (copying) {
#line 127
    *destination = (char )'\000';
#line 128
    return (buffer___1);
  }
#line 130
  return ((char *)((void *)0));
}
}
#line 145 "misc.c"
int unquote_string(char *string ) 
{ 
  int result ;
  char *source ;
  char *destination ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  int value ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;
  char *tmp___14 ;
  char *tmp___15 ;
  char *tmp___16 ;

  {
#line 148
  result = 1;
#line 149
  source = string;
#line 150
  destination = string;
  {
#line 152
  while (1) {
    while_continue: /* CIL Label */ ;
#line 152
    if (! *source) {
#line 152
      goto while_break;
    }
#line 153
    if ((int )*source == 92) {
#line 154
      source ++;
      {
#line 156
      if ((int )*source == 92) {
#line 156
        goto case_92;
      }
#line 161
      if ((int )*source == 110) {
#line 161
        goto case_110;
      }
#line 166
      if ((int )*source == 116) {
#line 166
        goto case_116;
      }
#line 171
      if ((int )*source == 102) {
#line 171
        goto case_102;
      }
#line 176
      if ((int )*source == 98) {
#line 176
        goto case_98;
      }
#line 181
      if ((int )*source == 114) {
#line 181
        goto case_114;
      }
#line 186
      if ((int )*source == 63) {
#line 186
        goto case_63;
      }
#line 198
      if ((int )*source == 55) {
#line 198
        goto case_55;
      }
#line 198
      if ((int )*source == 54) {
#line 198
        goto case_55;
      }
#line 198
      if ((int )*source == 53) {
#line 198
        goto case_55;
      }
#line 198
      if ((int )*source == 52) {
#line 198
        goto case_55;
      }
#line 198
      if ((int )*source == 51) {
#line 198
        goto case_55;
      }
#line 198
      if ((int )*source == 50) {
#line 198
        goto case_55;
      }
#line 198
      if ((int )*source == 49) {
#line 198
        goto case_55;
      }
#line 198
      if ((int )*source == 48) {
#line 198
        goto case_55;
      }
#line 218
      goto switch_default;
      case_92: /* CIL Label */ 
#line 157
      tmp = destination;
#line 157
      destination ++;
#line 157
      *tmp = (char )'\\';
#line 158
      source ++;
#line 159
      goto switch_break;
      case_110: /* CIL Label */ 
#line 162
      tmp___0 = destination;
#line 162
      destination ++;
#line 162
      *tmp___0 = (char )'\n';
#line 163
      source ++;
#line 164
      goto switch_break;
      case_116: /* CIL Label */ 
#line 167
      tmp___1 = destination;
#line 167
      destination ++;
#line 167
      *tmp___1 = (char )'\t';
#line 168
      source ++;
#line 169
      goto switch_break;
      case_102: /* CIL Label */ 
#line 172
      tmp___2 = destination;
#line 172
      destination ++;
#line 172
      *tmp___2 = (char )'\f';
#line 173
      source ++;
#line 174
      goto switch_break;
      case_98: /* CIL Label */ 
#line 177
      tmp___3 = destination;
#line 177
      destination ++;
#line 177
      *tmp___3 = (char )'\b';
#line 178
      source ++;
#line 179
      goto switch_break;
      case_114: /* CIL Label */ 
#line 182
      tmp___4 = destination;
#line 182
      destination ++;
#line 182
      *tmp___4 = (char )'\r';
#line 183
      source ++;
#line 184
      goto switch_break;
      case_63: /* CIL Label */ 
#line 187
      tmp___5 = destination;
#line 187
      destination ++;
#line 187
      *tmp___5 = (char)127;
#line 188
      source ++;
#line 189
      goto switch_break;
      case_55: /* CIL Label */ 
      case_54: /* CIL Label */ 
      case_53: /* CIL Label */ 
      case_52: /* CIL Label */ 
      case_51: /* CIL Label */ 
      case_50: /* CIL Label */ 
      case_49: /* CIL Label */ 
      case_48: /* CIL Label */ 
#line 200
      tmp___6 = source;
#line 200
      source ++;
#line 200
      value = (int )*tmp___6 - 48;
#line 202
      if ((int )*source < 48) {
#line 204
        tmp___7 = destination;
#line 204
        destination ++;
#line 204
        *tmp___7 = (char )value;
#line 205
        goto switch_break;
      } else
#line 202
      if ((int )*source > 55) {
#line 204
        tmp___7 = destination;
#line 204
        destination ++;
#line 204
        *tmp___7 = (char )value;
#line 205
        goto switch_break;
      }
#line 207
      tmp___8 = source;
#line 207
      source ++;
#line 207
      value = (value * 8 + (int )*tmp___8) - 48;
#line 208
      if ((int )*source < 48) {
#line 210
        tmp___9 = destination;
#line 210
        destination ++;
#line 210
        *tmp___9 = (char )value;
#line 211
        goto switch_break;
      } else
#line 208
      if ((int )*source > 55) {
#line 210
        tmp___9 = destination;
#line 210
        destination ++;
#line 210
        *tmp___9 = (char )value;
#line 211
        goto switch_break;
      }
#line 213
      tmp___10 = source;
#line 213
      source ++;
#line 213
      value = (value * 8 + (int )*tmp___10) - 48;
#line 214
      tmp___11 = destination;
#line 214
      destination ++;
#line 214
      *tmp___11 = (char )value;
#line 215
      goto switch_break;
      switch_default: /* CIL Label */ 
#line 219
      result = 0;
#line 220
      tmp___12 = destination;
#line 220
      destination ++;
#line 220
      *tmp___12 = (char )'\\';
#line 221
      if (*source) {
#line 222
        tmp___13 = destination;
#line 222
        destination ++;
#line 222
        tmp___14 = source;
#line 222
        source ++;
#line 222
        *tmp___13 = *tmp___14;
      }
#line 223
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    } else
#line 225
    if ((unsigned long )source != (unsigned long )destination) {
#line 226
      tmp___15 = destination;
#line 226
      destination ++;
#line 226
      tmp___16 = source;
#line 226
      source ++;
#line 226
      *tmp___15 = *tmp___16;
    } else {
#line 228
      source ++;
#line 228
      destination ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 230
  if ((unsigned long )source != (unsigned long )destination) {
#line 231
    *destination = (char )'\000';
  }
#line 232
  return (result);
}
}
#line 241 "misc.c"
char *merge_sort(char *list , int length , int offset , int (*compare)(char * , char * ) ) 
{ 
  char *first_list ;
  char *second_list ;
  int first_length ;
  int second_length ;
  char *result ;
  char **merge_point ;
  char *cursor ;
  int counter ;
  int tmp ;
  int tmp___0 ;

  {
#line 256
  if (length == 1) {
#line 257
    return (list);
  }
#line 259
  if (length == 2) {
    {
#line 261
    tmp = (*compare)(list, *((char **)(list + offset)));
    }
#line 261
    if (tmp > 0) {
#line 263
      result = *((char **)(list + offset));
#line 264
      *((char **)(result + offset)) = list;
#line 265
      *((char **)(list + offset)) = (char *)((void *)0);
#line 266
      return (result);
    }
#line 268
    return (list);
  }
#line 271
  first_list = list;
#line 272
  first_length = (length + 1) / 2;
#line 273
  second_length = length / 2;
#line 274
  cursor = list;
#line 274
  counter = first_length - 1;
  {
#line 274
  while (1) {
    while_continue: /* CIL Label */ ;
#line 274
    if (! counter) {
#line 274
      goto while_break;
    }
#line 277
    goto __Cont;
    __Cont: /* CIL Label */ 
#line 274
    cursor = *((char **)(cursor + offset));
#line 274
    counter --;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 278
  second_list = *((char **)(cursor + offset));
#line 279
  *((char **)(cursor + offset)) = (char *)((void *)0);
#line 281
  first_list = merge_sort(first_list, first_length, offset, compare);
#line 282
  second_list = merge_sort(second_list, second_length, offset, compare);
#line 284
  merge_point = & result;
  }
  {
#line 285
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 285
    if (first_list) {
#line 285
      if (! second_list) {
#line 285
        goto while_break___0;
      }
    } else {
#line 285
      goto while_break___0;
    }
    {
#line 286
    tmp___0 = (*compare)(first_list, second_list);
    }
#line 286
    if (tmp___0 < 0) {
#line 288
      cursor = *((char **)(first_list + offset));
#line 289
      *merge_point = first_list;
#line 290
      merge_point = (char **)(first_list + offset);
#line 291
      first_list = cursor;
    } else {
#line 295
      cursor = *((char **)(second_list + offset));
#line 296
      *merge_point = second_list;
#line 297
      merge_point = (char **)(second_list + offset);
#line 298
      second_list = cursor;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 300
  if (first_list) {
#line 301
    *merge_point = first_list;
  } else {
#line 303
    *merge_point = second_list;
  }
#line 305
  return (result);
}
}
#line 313 "misc.c"
static char *before_backup_name  =    (char *)((void *)0);
#line 314 "misc.c"
static char *after_backup_name  =    (char *)((void *)0);
#line 324 "misc.c"
int is_dot_or_dotdot(char const   *p ) 
{ 
  int tmp ;

  {
#line 327
  if ((int const   )*(p + 0) == 0) {
#line 327
    tmp = 1;
  } else
#line 327
  if ((int const   )*(p + 0) == 46) {
#line 327
    if ((int const   )*(p + 1) == 0) {
#line 327
      tmp = 1;
    } else
#line 327
    if ((int const   )*(p + 1) == 46) {
#line 327
      if ((int const   )*(p + 2) == 0) {
#line 327
        tmp = 1;
      } else {
#line 327
        tmp = 0;
      }
    } else {
#line 327
      tmp = 0;
    }
  } else {
#line 327
    tmp = 0;
  }
#line 327
  return (tmp);
}
}
#line 339 "misc.c"
int remove_any_file(char const   *path___0 , int recurse ) 
{ 
  struct stat stat_buffer ;
  int tmp ;
  DIR *dirp ;
  DIR *tmp___0 ;
  struct dirent *dp ;
  char *path_buffer ;
  char *tmp___1 ;
  int saved_errno ;
  int *tmp___2 ;
  int *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int saved_errno___0 ;
  int *tmp___7 ;
  int tmp___8 ;
  int *tmp___9 ;
  int tmp___10 ;

  {
  {
#line 344
  tmp = lstat((char const   */* __restrict  */)path___0, (struct stat */* __restrict  */)(& stat_buffer));
  }
#line 344
  if (tmp < 0) {
#line 345
    return (0);
  }
#line 347
  if ((stat_buffer.st_mode & 61440U) == 16384U) {
#line 349
    if (recurse) {
      {
#line 351
      tmp___0 = opendir(path___0);
#line 351
      dirp = tmp___0;
      }
#line 354
      if ((unsigned long )dirp == (unsigned long )((void *)0)) {
#line 355
        return (0);
      }
      {
#line 357
      while (1) {
        while_continue: /* CIL Label */ ;
        {
#line 357
        dp = readdir(dirp);
        }
#line 357
        if (! dp) {
#line 357
          goto while_break;
        }
        {
#line 358
        tmp___5 = is_dot_or_dotdot((char const   *)(dp->d_name));
        }
#line 358
        if (! tmp___5) {
          {
#line 360
          tmp___1 = new_name(path___0, (char const   *)(dp->d_name));
#line 360
          path_buffer = tmp___1;
#line 362
          tmp___4 = remove_any_file((char const   *)path_buffer, 1);
          }
#line 362
          if (! tmp___4) {
            {
#line 364
            tmp___2 = __errno_location();
#line 364
            saved_errno = *tmp___2;
#line 366
            free((void *)path_buffer);
#line 367
            closedir(dirp);
#line 369
            tmp___3 = __errno_location();
#line 369
            *tmp___3 = saved_errno;
            }
#line 370
            return (0);
          }
          {
#line 372
          free((void *)path_buffer);
          }
        }
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 374
      closedir(dirp);
#line 375
      tmp___6 = rmdir(path___0);
      }
#line 375
      return (tmp___6 >= 0);
    } else {
      {
#line 381
      tmp___7 = __errno_location();
#line 381
      saved_errno___0 = *tmp___7;
#line 383
      tmp___8 = rmdir(path___0);
      }
#line 383
      if (tmp___8 >= 0) {
#line 384
        return (1);
      }
      {
#line 385
      tmp___9 = __errno_location();
#line 385
      *tmp___9 = saved_errno___0;
      }
#line 386
      return (0);
    }
  }
  {
#line 390
  tmp___10 = unlink(path___0);
  }
#line 390
  return (tmp___10 >= 0);
}
}
#line 402 "misc.c"
int maybe_backup_file(char const   *path___0 , int archive___0 ) 
{ 
  struct stat file_stat ;
  int *tmp ;
  int *tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  char *tmp___5 ;
  int *tmp___6 ;

  {
#line 409
  if (archive___0) {
#line 409
    if (! force_local_option) {
      {
#line 409
      rmt_path__ = strchr(path___0, ':');
      }
#line 409
      if (rmt_path__) {
#line 409
        if ((unsigned long )rmt_path__ > (unsigned long )path___0) {
#line 409
          if ((int )*(rmt_path__ + -1) != 47) {
#line 410
            return (1);
          }
        }
      }
    }
  }
  {
#line 412
  tmp___1 = stat((char const   */* __restrict  */)path___0, (struct stat */* __restrict  */)(& file_stat));
  }
#line 412
  if (tmp___1) {
    {
#line 414
    tmp = __errno_location();
    }
#line 414
    if (*tmp == 2) {
#line 415
      return (1);
    }
    {
#line 417
    tmp___0 = __errno_location();
#line 417
    error(0, *tmp___0, "%s", path___0);
#line 417
    exit_status = 2;
    }
#line 418
    return (0);
  }
#line 421
  if ((file_stat.st_mode & 61440U) == 16384U) {
#line 422
    return (1);
  }
#line 425
  if (archive___0) {
#line 425
    if ((file_stat.st_mode & 61440U) == 24576U) {
#line 426
      return (1);
    }
  }
#line 430
  if (archive___0) {
#line 430
    if ((file_stat.st_mode & 61440U) == 8192U) {
#line 431
      return (1);
    }
  }
  {
#line 434
  assign_string(& before_backup_name, path___0);
#line 441
  assign_string(& after_backup_name, (char const   *)((void *)0));
#line 442
  after_backup_name = find_backup_file_name(path___0, backup_type);
  }
#line 443
  if ((unsigned long )after_backup_name == (unsigned long )((void *)0)) {
    {
#line 444
    error(0, 0, "Virtual memory exhausted");
#line 444
    tmp___2 = gettext("Error is not recoverable: exiting now");
#line 444
    error(2, 0, (char const   *)tmp___2);
    }
  }
  {
#line 446
  tmp___4 = rename((char const   *)before_backup_name, (char const   *)after_backup_name);
  }
#line 446
  if (tmp___4 == 0) {
#line 448
    if (verbose_option) {
      {
#line 449
      tmp___3 = gettext("Renaming previous `%s\' to `%s\'\n");
#line 449
      fprintf((FILE */* __restrict  */)stdlis, (char const   */* __restrict  */)tmp___3,
              before_backup_name, after_backup_name);
      }
    }
#line 451
    return (1);
  }
  {
#line 456
  tmp___5 = gettext("%s: Cannot rename for backup");
#line 456
  tmp___6 = __errno_location();
#line 456
  error(0, *tmp___6, (char const   *)tmp___5, before_backup_name);
#line 456
  exit_status = 2;
#line 457
  assign_string(& after_backup_name, (char const   *)((void *)0));
  }
#line 458
  return (0);
}
}
#line 466 "misc.c"
void undo_last_backup(void) 
{ 
  char *tmp ;
  int *tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;

  {
#line 469
  if (after_backup_name) {
    {
#line 471
    tmp___1 = rename((char const   *)after_backup_name, (char const   *)before_backup_name);
    }
#line 471
    if (tmp___1 != 0) {
      {
#line 472
      tmp = gettext("%s: Cannot rename from backup");
#line 472
      tmp___0 = __errno_location();
#line 472
      error(0, *tmp___0, (char const   *)tmp, before_backup_name);
#line 472
      exit_status = 2;
      }
    }
#line 474
    if (verbose_option) {
      {
#line 475
      tmp___2 = gettext("Renaming `%s\' back to `%s\'\n");
#line 475
      fprintf((FILE */* __restrict  */)stdlis, (char const   */* __restrict  */)tmp___2,
              after_backup_name, before_backup_name);
      }
    }
    {
#line 477
    assign_string(& after_backup_name, (char const   *)((void *)0));
    }
  }
#line 479
  return;
}
}
#line 726 "/usr/include/unistd.h"
extern int symlink(char const   *__from , char const   *__to ) ;
#line 455 "common.h"
void extract_mangle(void) ;
#line 35 "mangle.c"
struct mangled *first_mangle  ;
#line 36 "mangle.c"
int mangled_num  =    0;
#line 44 "mangle.c"
void extract_mangle(void) 
{ 
  off_t size ;
  char *buffer___1 ;
  void *tmp ;
  char *copy ;
  char *cursor ;
  char *tmp___0 ;
  char *tmp___1 ;
  union block *block ;
  union block *tmp___2 ;
  size_t available ;
  char *tmp___3 ;
  char *next_cursor ;
  char *name ;
  char *name_end ;
  char *tmp___4 ;
  int tmp___5 ;
  char *tmp___6 ;
  int *tmp___7 ;
  char *tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  char *tmp___11 ;
  int *tmp___12 ;
  char *tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  char *tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;

  {
  {
#line 47
  size = current_stat.st_size;
#line 48
  tmp = xmalloc((size_t )(size + 1LL));
#line 48
  buffer___1 = (char *)tmp;
#line 49
  copy = buffer___1;
#line 50
  cursor = buffer___1;
  }
#line 52
  if (size != (off_t )((size_t )size)) {
    {
#line 53
    tmp___0 = gettext("Memory exhausted");
#line 53
    error(0, 0, (char const   *)tmp___0);
#line 53
    tmp___1 = gettext("Error is not recoverable: exiting now");
#line 53
    error(2, 0, (char const   *)tmp___1);
    }
  } else
#line 52
  if (size == 4294967295LL) {
    {
#line 53
    tmp___0 = gettext("Memory exhausted");
#line 53
    error(0, 0, (char const   *)tmp___0);
#line 53
    tmp___1 = gettext("Error is not recoverable: exiting now");
#line 53
    error(2, 0, (char const   *)tmp___1);
    }
  }
#line 55
  *(buffer___1 + size) = (char )'\000';
  {
#line 57
  while (1) {
    while_continue: /* CIL Label */ ;
#line 57
    if (! (size > 0LL)) {
#line 57
      goto while_break;
    }
    {
#line 59
    tmp___2 = find_next_block();
#line 59
    block = tmp___2;
    }
#line 62
    if (! block) {
      {
#line 64
      tmp___3 = gettext("Unexpected EOF in mangled names");
#line 64
      error(0, 0, (char const   *)tmp___3);
#line 64
      exit_status = 2;
      }
#line 65
      return;
    }
    {
#line 67
    available = available_space_after(block);
    }
#line 68
    if ((off_t )available > size) {
#line 69
      available = (size_t )size;
    }
    {
#line 70
    memcpy((void */* __restrict  */)copy, (void const   */* __restrict  */)(block->buffer),
           available);
#line 71
    copy += available;
#line 72
    size -= (off_t )available;
#line 73
    set_next_block_after((union block *)((block->buffer + available) - 1));
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 76
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 76
    if (! *cursor) {
#line 76
      goto while_break___0;
    }
    {
#line 82
    next_cursor = strchr((char const   *)cursor, '\n');
#line 83
    tmp___4 = next_cursor;
#line 83
    next_cursor ++;
#line 83
    *tmp___4 = (char )'\000';
#line 85
    tmp___19 = strncmp((char const   *)cursor, "Rename ", (size_t )7);
    }
#line 85
    if (tmp___19) {
      {
#line 105
      tmp___18 = strncmp((char const   *)cursor, "Symlink ", (size_t )8);
      }
#line 105
      if (tmp___18) {
        {
#line 126
        tmp___17 = gettext("Unknown demangling command %s");
#line 126
        error(0, 0, (char const   *)tmp___17, cursor);
#line 126
        exit_status = 2;
        }
      } else {
        {
#line 107
        name = cursor + 8;
#line 108
        name_end = strchr((char const   *)name, ' ');
        }
        {
#line 109
        while (1) {
          while_continue___1: /* CIL Label */ ;
          {
#line 109
          tmp___10 = strncmp((char const   *)name_end, " to ", (size_t )4);
          }
#line 109
          if (! tmp___10) {
#line 109
            goto while_break___1;
          }
          {
#line 111
          name_end ++;
#line 112
          name_end = strchr((char const   *)name_end, ' ');
          }
        }
        while_break___1: /* CIL Label */ ;
        }
        {
#line 114
        *name_end = (char )'\000';
#line 115
        unquote_string(name);
#line 116
        unquote_string(name_end + 4);
#line 117
        tmp___14 = symlink((char const   *)name, (char const   *)(name_end + 4));
        }
#line 117
        if (tmp___14) {
          {
#line 117
          tmp___15 = unlink((char const   *)(name_end + 4));
          }
#line 117
          if (tmp___15) {
            {
#line 119
            tmp___11 = gettext("Cannot symlink %s to %s");
#line 119
            tmp___12 = __errno_location();
#line 119
            error(0, *tmp___12, (char const   *)tmp___11, name, name_end + 4);
#line 119
            exit_status = 2;
            }
          } else {
            {
#line 117
            tmp___16 = symlink((char const   *)name, (char const   *)(name_end + 4));
            }
#line 117
            if (tmp___16) {
              {
#line 119
              tmp___11 = gettext("Cannot symlink %s to %s");
#line 119
              tmp___12 = __errno_location();
#line 119
              error(0, *tmp___12, (char const   *)tmp___11, name, name_end + 4);
#line 119
              exit_status = 2;
              }
            } else {
#line 117
              goto _L;
            }
          }
        } else
        _L: /* CIL Label */ 
#line 121
        if (verbose_option) {
          {
#line 122
          tmp___13 = gettext("Symlinked %s to %s");
#line 122
          error(0, 0, (char const   *)tmp___13, name, name_end + 4);
          }
        }
      }
    } else {
      {
#line 88
      name = cursor + 7;
#line 89
      name_end = strchr((char const   *)name, ' ');
      }
      {
#line 90
      while (1) {
        while_continue___2: /* CIL Label */ ;
        {
#line 90
        tmp___5 = strncmp((char const   *)name_end, " to ", (size_t )4);
        }
#line 90
        if (! tmp___5) {
#line 90
          goto while_break___2;
        }
        {
#line 92
        name_end ++;
#line 93
        name_end = strchr((char const   *)name_end, ' ');
        }
      }
      while_break___2: /* CIL Label */ ;
      }
#line 95
      *name_end = (char )'\000';
#line 96
      if ((int )*(next_cursor + -2) == 47) {
#line 97
        *(next_cursor + -2) = (char )'\000';
      }
      {
#line 98
      unquote_string(name_end + 4);
#line 99
      tmp___9 = rename((char const   *)name, (char const   *)(name_end + 4));
      }
#line 99
      if (tmp___9) {
        {
#line 100
        tmp___6 = gettext("Cannot rename %s to %s");
#line 100
        tmp___7 = __errno_location();
#line 100
        error(0, *tmp___7, (char const   *)tmp___6, name, name_end + 4);
#line 100
        exit_status = 2;
        }
      } else
#line 101
      if (verbose_option) {
        {
#line 102
        tmp___8 = gettext("Renamed %s to %s");
#line 102
        error(0, 0, (char const   *)tmp___8, name, name_end + 4);
        }
      }
    }
#line 128
    cursor = next_cursor;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 130
  return;
}
}
#line 477 "/usr/include/stdio.h"
extern int fputc(int __c , FILE *__stream ) ;
#line 609
extern size_t fwrite(void const   * __restrict  __ptr , size_t __size , size_t __n ,
                     FILE * __restrict  __s ) ;
#line 331 "common.h"
char *save_name ;
#line 332
off_t save_sizeleft ;
#line 333
off_t save_totsize ;
#line 337
off_t current_block_ordinal(void) ;
#line 390
void apply_delayed_set_stat(void) ;
#line 415 "common.h"
union block *current_header  ;
#line 416 "common.h"
struct stat current_stat  ;
#line 417 "common.h"
enum archive_format current_format  ;
#line 435
gid_t gid_from_oct(char const   *p , size_t s ) ;
#line 436
int major_from_oct(char const   *p , size_t s ) ;
#line 437
int minor_from_oct(char const   *p , size_t s ) ;
#line 438
mode_t mode_from_oct(char const   *p , size_t s ) ;
#line 439
off_t off_from_oct(char const   *p , size_t s ) ;
#line 440
size_t size_from_oct(char const   *p , size_t s ) ;
#line 441
time_t time_from_oct(char const   *p , size_t s ) ;
#line 442
uid_t uid_from_oct(char const   *p , size_t s ) ;
#line 443
uintmax_t uintmax_from_oct(char const   *p , size_t s ) ;
#line 446
void print_for_mkdir(char *pathname , int length , mode_t mode ) ;
#line 447
void print_header(void) ;
#line 37 "list.c"
static uintmax_t from_oct(char const   *where0 , size_t digs0 , char const   *type ,
                          uintmax_t maxval ) ;
#line 44 "list.c"
void read_and(void (*do_something)() ) 
{ 
  enum read_header status ;
  enum read_header prev_status ;
  char save_typeflag ;
  int isextended ;
  char *tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  char buf[(((sizeof(uintmax_t ) * 8UL) * 302UL) / 1000UL + 1UL) + 1UL] ;
  off_t tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char buf___0[(((sizeof(uintmax_t ) * 8UL) * 302UL) / 1000UL + 1UL) + 1UL] ;
  off_t tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;

  {
  {
#line 47
  status = (enum read_header )0;
#line 51
  name_gather();
#line 52
  open_archive((enum access_mode )0);
  }
  {
#line 54
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 56
    prev_status = status;
#line 57
    status = read_header();
    }
    {
#line 60
    if ((unsigned int )status == 0U) {
#line 60
      goto case_0;
    }
#line 63
    if ((unsigned int )status == 1U) {
#line 63
      goto case_1;
    }
#line 123
    if ((unsigned int )status == 2U) {
#line 123
      goto case_2;
    }
#line 137
    if ((unsigned int )status == 3U) {
#line 137
      goto case_3;
    }
#line 146
    if ((unsigned int )status == 4U) {
#line 146
      goto case_4;
    }
#line 58
    goto switch_break;
    case_0: /* CIL Label */ 
    {
#line 61
    abort();
    }
    case_1: /* CIL Label */ 
    {
#line 69
    current_stat.st_mtim.tv_sec = time_from_oct((char const   *)(current_header->header.mtime),
                                                (size_t )sizeof(current_header->header.mtime));
#line 71
    tmp___0 = name_match((char const   *)current_file_name);
    }
#line 71
    if (tmp___0) {
#line 71
      if (current_stat.st_mtim.tv_sec < newer_mtime_option) {
#line 71
        goto _L;
      } else {
        {
#line 71
        tmp___1 = base_name((char const   *)current_file_name);
#line 71
        tmp___2 = excluded_filename((struct exclude  const  *)excluded, (char const   *)tmp___1);
        }
#line 71
        if (tmp___2) {
          _L: /* CIL Label */ 
#line 75
          isextended = 0;
#line 77
          if ((int )current_header->header.typeflag == 86) {
            {
#line 81
            (*do_something)();
            }
#line 82
            goto while_continue;
          } else
#line 77
          if ((int )current_header->header.typeflag == 77) {
            {
#line 81
            (*do_something)();
            }
#line 82
            goto while_continue;
          } else
#line 77
          if ((int )current_header->header.typeflag == 78) {
            {
#line 81
            (*do_something)();
            }
#line 82
            goto while_continue;
          }
#line 84
          if (show_omitted_dirs_option) {
#line 84
            if ((int )current_header->header.typeflag == 53) {
              {
#line 86
              tmp = gettext("Omitting %s");
#line 86
              error(0, 0, (char const   *)tmp, current_file_name);
              }
            }
          }
#line 90
          if (current_header->oldgnu_header.isextended) {
#line 91
            isextended = 1;
          }
          {
#line 92
          save_typeflag = current_header->header.typeflag;
#line 93
          set_next_block_after(current_header);
          }
#line 94
          if (isextended) {
            {
#line 110
            skip_extended_headers();
            }
          }
#line 115
          if ((int )save_typeflag != 53) {
            {
#line 116
            skip_file(current_stat.st_size);
            }
          }
#line 117
          goto while_continue;
        }
      }
    } else {
#line 71
      goto _L;
    }
    {
#line 120
    (*do_something)();
    }
#line 121
    goto while_continue;
    case_2: /* CIL Label */ 
#line 124
    if (block_number_option) {
      {
#line 127
      tmp___3 = current_block_ordinal();
#line 127
      tmp___4 = stringify_uintmax_t_backwards((uintmax_t )tmp___3, buf + sizeof(buf));
#line 127
      tmp___5 = gettext("block %s: ** Block of NULs **\n");
#line 127
      fprintf((FILE */* __restrict  */)stdlis, (char const   */* __restrict  */)tmp___5,
              tmp___4);
      }
    }
    {
#line 131
    set_next_block_after(current_header);
#line 132
    status = prev_status;
    }
#line 133
    if (ignore_zeros_option) {
#line 134
      goto while_continue;
    }
#line 135
    goto switch_break;
    case_3: /* CIL Label */ 
#line 138
    if (block_number_option) {
      {
#line 141
      tmp___6 = current_block_ordinal();
#line 141
      tmp___7 = stringify_uintmax_t_backwards((uintmax_t )tmp___6, buf___0 + sizeof(buf___0));
#line 141
      tmp___8 = gettext("block %s: ** End of File **\n");
#line 141
      fprintf((FILE */* __restrict  */)stdlis, (char const   */* __restrict  */)tmp___8,
              tmp___7);
      }
    }
#line 144
    goto switch_break;
    case_4: /* CIL Label */ 
    {
#line 149
    set_next_block_after(current_header);
    }
    {
#line 152
    if ((unsigned int )prev_status == 0U) {
#line 152
      goto case_0___0;
    }
#line 157
    if ((unsigned int )prev_status == 1U) {
#line 157
      goto case_1___0;
    }
#line 157
    if ((unsigned int )prev_status == 2U) {
#line 157
      goto case_1___0;
    }
#line 162
    if ((unsigned int )prev_status == 4U) {
#line 162
      goto case_4___0;
    }
#line 162
    if ((unsigned int )prev_status == 3U) {
#line 162
      goto case_4___0;
    }
#line 150
    goto switch_break___0;
    case_0___0: /* CIL Label */ 
    {
#line 153
    tmp___9 = gettext("Hmm, this doesn\'t look like a tar archive");
#line 153
    error(0, 0, (char const   *)tmp___9);
    }
    case_1___0: /* CIL Label */ 
    case_2___0: /* CIL Label */ 
    {
#line 158
    tmp___10 = gettext("Skipping to next file header");
#line 158
    error(0, 0, (char const   *)tmp___10);
    }
#line 159
    goto switch_break___0;
    case_4___0: /* CIL Label */ 
    case_3___0: /* CIL Label */ 
#line 164
    goto switch_break___0;
    switch_break___0: /* CIL Label */ ;
    }
#line 166
    goto while_continue;
    switch_break: /* CIL Label */ ;
    }
#line 168
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 171
  apply_delayed_set_stat();
#line 172
  close_archive();
#line 173
  names_notfound();
  }
#line 174
  return;
}
}
#line 180 "list.c"
void list_archive(void) 
{ 
  int isextended ;
  off_t size ;
  size_t written ;
  size_t check ;
  union block *data_block ;
  char *tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  int *tmp___2 ;

  {
#line 183
  isextended = 0;
#line 187
  if (verbose_option) {
#line 189
    if (verbose_option > 1) {
      {
#line 190
      decode_header(current_header, & current_stat, & current_format, 0);
      }
    }
    {
#line 191
    print_header();
    }
  }
#line 194
  if (incremental_option) {
#line 194
    if ((int )current_header->header.typeflag == 68) {
      {
#line 200
      set_next_block_after(current_header);
      }
#line 201
      if (multi_volume_option) {
        {
#line 203
        assign_string(& save_name, (char const   *)current_file_name);
#line 204
        save_totsize = current_stat.st_size;
        }
      }
#line 206
      size = current_stat.st_size;
      {
#line 206
      while (1) {
        while_continue: /* CIL Label */ ;
#line 206
        if (! (size > 0LL)) {
#line 206
          goto while_break;
        }
#line 208
        if (multi_volume_option) {
#line 209
          save_sizeleft = size;
        }
        {
#line 210
        data_block = find_next_block();
        }
#line 211
        if (! data_block) {
          {
#line 213
          tmp = gettext("EOF in archive file");
#line 213
          error(0, 0, (char const   *)tmp);
#line 213
          exit_status = 2;
          }
#line 214
          goto while_break;
        }
        {
#line 216
        written = available_space_after(data_block);
        }
#line 217
        if ((off_t )written > size) {
#line 218
          written = (size_t )size;
        }
        {
#line 219
        tmp___0 = __errno_location();
#line 219
        *tmp___0 = 0;
#line 220
        check = fwrite((void const   */* __restrict  */)(data_block->buffer), (size_t )sizeof(char ),
                       written, (FILE */* __restrict  */)stdlis);
#line 221
        set_next_block_after((union block *)((data_block->buffer + written) - 1));
        }
#line 223
        if (check != written) {
          {
#line 225
          tmp___1 = gettext("Only wrote %lu of %lu bytes to file %s");
#line 225
          tmp___2 = __errno_location();
#line 225
          error(0, *tmp___2, (char const   *)tmp___1, (unsigned long )check, (unsigned long )written,
                current_file_name);
#line 225
          exit_status = 2;
#line 228
          skip_file(size - (off_t )written);
          }
#line 229
          goto while_break;
        }
#line 206
        size -= (off_t )written;
      }
      while_break: /* CIL Label */ ;
      }
#line 232
      if (multi_volume_option) {
        {
#line 233
        assign_string(& save_name, (char const   *)((void *)0));
        }
      }
      {
#line 234
      fputc('\n', stdlis);
#line 235
      fflush(stdlis);
      }
#line 236
      return;
    }
  }
#line 242
  if (current_header->oldgnu_header.isextended) {
#line 243
    isextended = 1;
  }
  {
#line 247
  set_next_block_after(current_header);
  }
#line 252
  if (isextended) {
    {
#line 269
    skip_extended_headers();
    }
  }
#line 272
  if (multi_volume_option) {
    {
#line 273
    assign_string(& save_name, (char const   *)current_file_name);
    }
  }
  {
#line 277
  skip_file(current_stat.st_size);
  }
#line 279
  if (multi_volume_option) {
    {
#line 280
    assign_string(& save_name, (char const   *)((void *)0));
    }
  }
#line 281
  return;
}
}
#line 321 "list.c"
static char *next_long_name  ;
#line 321 "list.c"
static char *next_long_link  ;
#line 307 "list.c"
enum read_header read_header(void) 
{ 
  size_t i ;
  long unsigned_sum ;
  long signed_sum ;
  long recorded_sum ;
  uintmax_t parsed_sum ;
  char *p ;
  union block *header ;
  char **longp ;
  char *bp ;
  union block *data_block ;
  size_t size ;
  size_t written ;
  char *tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  void *tmp___5 ;
  char *tmp___6 ;
  char *name ;
  struct posix_header *h ;
  char namebuf[((sizeof(h->prefix) + 1UL) + sizeof(h->name)) + 1UL] ;
  char *np ;
  size_t tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;

  {
  {
#line 323
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 325
    header = find_next_block();
#line 326
    current_header = header;
    }
#line 327
    if (! header) {
#line 328
      return ((enum read_header )3);
    }
    {
#line 330
    parsed_sum = from_oct((char const   *)(header->header.chksum), (size_t )sizeof(header->header.chksum),
                          (char const   *)((char *)0), (uintmax_t )(-1L - (-1L << (sizeof(long ) * 8UL - 1UL))));
    }
#line 333
    if (parsed_sum == 0xffffffffffffffffULL) {
#line 334
      return ((enum read_header )4);
    }
#line 336
    recorded_sum = (long )parsed_sum;
#line 337
    unsigned_sum = 0L;
#line 338
    signed_sum = 0L;
#line 339
    p = header->buffer;
#line 340
    i = (size_t )sizeof(*header);
    {
#line 340
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 340
      tmp___0 = i;
#line 340
      i --;
#line 340
      if (! (tmp___0 != 0U)) {
#line 340
        goto while_break___0;
      }
#line 345
      unsigned_sum += (long )(255 & (int )*p);
#line 346
      tmp = p;
#line 346
      p ++;
#line 346
      signed_sum += (long )*tmp;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 351
    i = (size_t )sizeof(header->header.chksum);
    {
#line 351
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 351
      tmp___1 = i;
#line 351
      i --;
#line 351
      if (! (tmp___1 != 0U)) {
#line 351
        goto while_break___1;
      }
#line 353
      unsigned_sum -= (long )(255 & (int )header->header.chksum[i]);
#line 354
      signed_sum -= (long )header->header.chksum[i];
    }
    while_break___1: /* CIL Label */ ;
    }
#line 356
    unsigned_sum = (long )((unsigned long )unsigned_sum + 32UL * sizeof(header->header.chksum));
#line 357
    signed_sum = (long )((unsigned long )signed_sum + 32UL * sizeof(header->header.chksum));
#line 359
    if ((unsigned long )unsigned_sum == sizeof(header->header.chksum) * 32UL) {
#line 364
      return ((enum read_header )2);
    }
#line 367
    if (unsigned_sum != recorded_sum) {
#line 367
      if (signed_sum != recorded_sum) {
#line 368
        return ((enum read_header )4);
      }
    }
#line 372
    if ((int )header->header.typeflag == 49) {
#line 373
      current_stat.st_size = (__off64_t )0;
    } else {
      {
#line 375
      current_stat.st_size = off_from_oct((char const   *)(header->header.size), (size_t )sizeof(header->header.size));
      }
    }
#line 377
    header->header.name[99] = (char )'\000';
#line 378
    if ((int )header->header.typeflag == 76) {
#line 378
      goto _L;
    } else
#line 378
    if ((int )header->header.typeflag == 75) {
      _L: /* CIL Label */ 
#line 381
      if ((int )header->header.typeflag == 76) {
#line 381
        longp = & next_long_name;
      } else {
#line 381
        longp = & next_long_link;
      }
      {
#line 385
      set_next_block_after(header);
      }
#line 386
      if (*longp) {
        {
#line 387
        free((void *)*longp);
        }
      }
#line 388
      size = (size_t )current_stat.st_size;
#line 389
      if ((__off64_t )size != current_stat.st_size) {
        {
#line 390
        tmp___2 = gettext("Memory exhausted");
#line 390
        error(0, 0, (char const   *)tmp___2);
#line 390
        tmp___3 = gettext("Error is not recoverable: exiting now");
#line 390
        error(2, 0, (char const   *)tmp___3);
        }
      }
      {
#line 391
      tmp___5 = xmalloc(size);
#line 391
      tmp___4 = (char *)tmp___5;
#line 391
      *longp = tmp___4;
#line 391
      bp = tmp___4;
      }
      {
#line 393
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 393
        if (! (size > 0U)) {
#line 393
          goto while_break___2;
        }
        {
#line 395
        data_block = find_next_block();
        }
#line 396
        if ((unsigned long )data_block == (unsigned long )((void *)0)) {
          {
#line 398
          tmp___6 = gettext("Unexpected EOF on archive file");
#line 398
          error(0, 0, (char const   *)tmp___6);
#line 398
          exit_status = 2;
          }
#line 399
          goto while_break___2;
        }
        {
#line 401
        written = available_space_after(data_block);
        }
#line 402
        if (written > size) {
#line 403
          written = size;
        }
        {
#line 405
        memcpy((void */* __restrict  */)bp, (void const   */* __restrict  */)(data_block->buffer),
               written);
#line 406
        bp += written;
#line 407
        set_next_block_after((union block *)((data_block->buffer + written) - 1));
#line 393
        size -= written;
        }
      }
      while_break___2: /* CIL Label */ ;
      }
    } else {
#line 416
      name = next_long_name;
#line 417
      h = & current_header->header;
#line 420
      if (! name) {
#line 424
        np = namebuf;
#line 425
        if (h->prefix[0]) {
          {
#line 427
          memcpy((void */* __restrict  */)np, (void const   */* __restrict  */)(h->prefix),
                 (size_t )sizeof(h->prefix));
#line 428
          *(np + sizeof(h->prefix)) = (char )'\000';
#line 429
          tmp___7 = strlen((char const   *)np);
#line 429
          np += tmp___7;
#line 430
          tmp___8 = np;
#line 430
          np ++;
#line 430
          *tmp___8 = (char )'/';
          }
        }
        {
#line 432
        memcpy((void */* __restrict  */)np, (void const   */* __restrict  */)(h->name),
               (size_t )sizeof(h->name));
#line 433
        *(np + sizeof(h->name)) = (char )'\000';
#line 434
        name = namebuf;
        }
      }
      {
#line 437
      assign_string(& current_file_name, (char const   *)name);
      }
#line 438
      if (next_long_link) {
#line 438
        tmp___9 = next_long_link;
      } else {
#line 438
        tmp___9 = current_header->header.linkname;
      }
      {
#line 438
      assign_string(& current_link_name, (char const   *)tmp___9);
#line 441
      next_long_name = (char *)0;
#line 441
      next_long_link = next_long_name;
      }
#line 442
      return ((enum read_header )1);
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 463 "list.c"
void decode_header(union block *header , struct stat *stat_info , enum archive_format *format_pointer ,
                   int do_user_group ) 
{ 
  enum archive_format format ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
  {
#line 469
  tmp___0 = strcmp((char const   *)(header->header.magic), "ustar");
  }
#line 469
  if (tmp___0 == 0) {
#line 470
    format = (enum archive_format )3;
  } else {
    {
#line 471
    tmp = strcmp((char const   *)(header->header.magic), "ustar  ");
    }
#line 471
    if (tmp == 0) {
#line 472
      format = (enum archive_format )2;
    } else {
#line 474
      format = (enum archive_format )1;
    }
  }
  {
#line 475
  *format_pointer = format;
#line 477
  stat_info->st_mode = mode_from_oct((char const   *)(header->header.mode), (size_t )sizeof(header->header.mode));
#line 478
  stat_info->st_mtim.tv_sec = time_from_oct((char const   *)(header->header.mtime),
                                            (size_t )sizeof(header->header.mtime));
  }
#line 480
  if ((unsigned int )format == 2U) {
#line 480
    if (incremental_option) {
      {
#line 482
      stat_info->st_atim.tv_sec = time_from_oct((char const   *)(header->oldgnu_header.atime),
                                                (size_t )sizeof(header->oldgnu_header.atime));
#line 483
      stat_info->st_ctim.tv_sec = time_from_oct((char const   *)(header->oldgnu_header.ctime),
                                                (size_t )sizeof(header->oldgnu_header.ctime));
      }
    }
  }
#line 486
  if ((unsigned int )format == 1U) {
    {
#line 488
    stat_info->st_uid = uid_from_oct((char const   *)(header->header.uid), (size_t )sizeof(header->header.uid));
#line 489
    stat_info->st_gid = gid_from_oct((char const   *)(header->header.gid), (size_t )sizeof(header->header.gid));
#line 490
    stat_info->st_rdev = (__dev_t )0;
    }
  } else {
#line 494
    if (do_user_group) {
#line 498
      if (numeric_owner_option) {
        {
#line 501
        stat_info->st_uid = uid_from_oct((char const   *)(header->header.uid), (size_t )sizeof(header->header.uid));
        }
      } else
#line 498
      if (! header->header.uname[0]) {
        {
#line 501
        stat_info->st_uid = uid_from_oct((char const   *)(header->header.uid), (size_t )sizeof(header->header.uid));
        }
      } else {
        {
#line 498
        tmp___1 = uname_to_uid((char *)(header->header.uname), & stat_info->st_uid);
        }
#line 498
        if (! tmp___1) {
          {
#line 501
          stat_info->st_uid = uid_from_oct((char const   *)(header->header.uid), (size_t )sizeof(header->header.uid));
          }
        }
      }
#line 503
      if (numeric_owner_option) {
        {
#line 506
        stat_info->st_gid = gid_from_oct((char const   *)(header->header.gid), (size_t )sizeof(header->header.gid));
        }
      } else
#line 503
      if (! header->header.gname[0]) {
        {
#line 506
        stat_info->st_gid = gid_from_oct((char const   *)(header->header.gid), (size_t )sizeof(header->header.gid));
        }
      } else {
        {
#line 503
        tmp___2 = gname_to_gid((char *)(header->header.gname), & stat_info->st_gid);
        }
#line 503
        if (! tmp___2) {
          {
#line 506
          stat_info->st_gid = gid_from_oct((char const   *)(header->header.gid), (size_t )sizeof(header->header.gid));
          }
        }
      }
    }
    {
#line 511
    if ((int )header->header.typeflag == 52) {
#line 511
      goto case_52;
    }
#line 519
    if ((int )header->header.typeflag == 51) {
#line 519
      goto case_51;
    }
#line 526
    goto switch_default;
    case_52: /* CIL Label */ 
    {
#line 512
    tmp___3 = major_from_oct((char const   *)(header->header.devmajor), (size_t )sizeof(header->header.devmajor));
#line 512
    tmp___4 = minor_from_oct((char const   *)(header->header.devminor), (size_t )sizeof(header->header.devminor));
#line 512
    stat_info->st_rdev = (__dev_t )(((unsigned int )tmp___3 << 8) | (unsigned int )tmp___4);
    }
#line 515
    goto switch_break;
    case_51: /* CIL Label */ 
    {
#line 520
    tmp___5 = major_from_oct((char const   *)(header->header.devmajor), (size_t )sizeof(header->header.devmajor));
#line 520
    tmp___6 = minor_from_oct((char const   *)(header->header.devminor), (size_t )sizeof(header->header.devminor));
#line 520
    stat_info->st_rdev = (__dev_t )(((unsigned int )tmp___5 << 8) | (unsigned int )tmp___6);
    }
#line 523
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 527
    stat_info->st_rdev = (__dev_t )0;
    switch_break: /* CIL Label */ ;
    }
  }
#line 530
  return;
}
}
#line 575 "list.c"
static struct quoting_options *o  ;
#line 537 "list.c"
static uintmax_t from_oct(char const   *where0 , size_t digs0 , char const   *type ,
                          uintmax_t maxval ) 
{ 
  uintmax_t value ;
  char const   *where ;
  size_t digs ;
  char *tmp ;
  unsigned short const   **tmp___0 ;
  char const   *tmp___1 ;
  char buf[1000] ;
  char *tmp___2 ;
  unsigned short const   **tmp___3 ;
  char *tmp___4 ;

  {
#line 541
  where = where0;
#line 542
  digs = digs0;
  {
#line 544
  while (1) {
    while_continue: /* CIL Label */ ;
#line 546
    if (digs == 0U) {
#line 548
      if (type) {
        {
#line 549
        tmp = gettext("Blanks in header where octal %s value expected");
#line 549
        error(0, 0, (char const   *)tmp, type);
#line 549
        exit_status = 2;
        }
      }
#line 551
      return ((uintmax_t )-1);
    }
    {
#line 553
    tmp___0 = __ctype_b_loc();
    }
#line 553
    if (! ((int const   )*(*tmp___0 + (int )((unsigned char )*where)) & 8192)) {
#line 554
      goto while_break;
    }
#line 555
    where ++;
#line 556
    digs --;
  }
  while_break: /* CIL Label */ ;
  }
#line 559
  value = (uintmax_t )0;
  {
#line 560
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 560
    if (digs != 0U) {
#line 560
      if (! ((unsigned int )*where - 48U <= 7U)) {
#line 560
        goto while_break___0;
      }
    } else {
#line 560
      goto while_break___0;
    }
#line 564
    if ((value << 3) >> 3 != value) {
#line 565
      goto out_of_range;
    }
#line 566
    tmp___1 = where;
#line 566
    where ++;
#line 566
    value = (value << 3) | (unsigned long long )((int const   )*tmp___1 - 48);
#line 567
    digs --;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 570
  if (digs != 0U) {
#line 570
    if (*where) {
      {
#line 570
      tmp___3 = __ctype_b_loc();
      }
#line 570
      if (! ((int const   )*(*tmp___3 + (int )((unsigned char )*where)) & 8192)) {
#line 572
        if (type) {
#line 577
          if (! o) {
            {
#line 579
            o = clone_quoting_options((struct quoting_options *)0);
#line 580
            set_quoting_style(o, (enum quoting_style )4);
            }
          }
          {
#line 583
          quotearg_buffer(buf, (size_t )sizeof(buf), where0, digs0, (struct quoting_options  const  *)o);
#line 584
          tmp___2 = gettext("Header contains \"%.*s\" where octal %s value expected");
#line 584
          error(0, 0, (char const   *)tmp___2, (int )sizeof(buf), buf, type);
#line 584
          exit_status = 2;
          }
        }
#line 589
        return ((uintmax_t )-1);
      }
    }
  }
#line 592
  if (value <= maxval) {
#line 593
    return (value);
  }
  out_of_range: 
#line 596
  if (type) {
    {
#line 597
    tmp___4 = gettext("Octal value `%.*s\' is out of range for %s");
#line 597
    error(0, 0, (char const   *)tmp___4, (int )digs0, where0, type);
#line 597
    exit_status = 2;
    }
  }
#line 599
  return ((uintmax_t )-1);
}
}
#line 601 "list.c"
gid_t gid_from_oct(char const   *p , size_t s ) 
{ 
  uintmax_t tmp ;

  {
  {
#line 604
  tmp = from_oct(p, s, "gid_t", (uintmax_t )4294967295U);
  }
#line 604
  return ((gid_t )tmp);
}
}
#line 606 "list.c"
int major_from_oct(char const   *p , size_t s ) 
{ 
  uintmax_t tmp ;

  {
  {
#line 609
  tmp = from_oct(p, s, "major_t", (uintmax_t )(-1 - (-1 << (sizeof(int ) * 8UL - 1UL))));
  }
#line 609
  return ((int )tmp);
}
}
#line 611 "list.c"
int minor_from_oct(char const   *p , size_t s ) 
{ 
  uintmax_t tmp ;

  {
  {
#line 614
  tmp = from_oct(p, s, "minor_t", (uintmax_t )(-1 - (-1 << (sizeof(int ) * 8UL - 1UL))));
  }
#line 614
  return ((int )tmp);
}
}
#line 616 "list.c"
mode_t mode_from_oct(char const   *p , size_t s ) 
{ 
  unsigned int u ;
  uintmax_t tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;

  {
  {
#line 620
  tmp = from_oct(p, s, "mode_t", 0xffffffffffffffffULL);
#line 620
  u = (unsigned int )tmp;
  }
#line 621
  if (u & 2048U) {
#line 621
    tmp___0 = 2048;
  } else {
#line 621
    tmp___0 = 0;
  }
#line 621
  if (u & 1024U) {
#line 621
    tmp___1 = 1024;
  } else {
#line 621
    tmp___1 = 0;
  }
#line 621
  if (u & 512U) {
#line 621
    tmp___2 = 512;
  } else {
#line 621
    tmp___2 = 0;
  }
#line 621
  if (u & 256U) {
#line 621
    tmp___3 = 256;
  } else {
#line 621
    tmp___3 = 0;
  }
#line 621
  if (u & 128U) {
#line 621
    tmp___4 = 128;
  } else {
#line 621
    tmp___4 = 0;
  }
#line 621
  if (u & 64U) {
#line 621
    tmp___5 = 64;
  } else {
#line 621
    tmp___5 = 0;
  }
#line 621
  if (u & 32U) {
#line 621
    tmp___6 = 256 >> 3;
  } else {
#line 621
    tmp___6 = 0;
  }
#line 621
  if (u & 16U) {
#line 621
    tmp___7 = 128 >> 3;
  } else {
#line 621
    tmp___7 = 0;
  }
#line 621
  if (u & 8U) {
#line 621
    tmp___8 = 64 >> 3;
  } else {
#line 621
    tmp___8 = 0;
  }
#line 621
  if (u & 4U) {
#line 621
    tmp___9 = (256 >> 3) >> 3;
  } else {
#line 621
    tmp___9 = 0;
  }
#line 621
  if (u & 2U) {
#line 621
    tmp___10 = (128 >> 3) >> 3;
  } else {
#line 621
    tmp___10 = 0;
  }
#line 621
  if (u & 1U) {
#line 621
    tmp___11 = (64 >> 3) >> 3;
  } else {
#line 621
    tmp___11 = 0;
  }
#line 621
  return ((mode_t )(((((((((((tmp___0 | tmp___1) | tmp___2) | tmp___3) | tmp___4) | tmp___5) | tmp___6) | tmp___7) | tmp___8) | tmp___9) | tmp___10) | tmp___11));
}
}
#line 634 "list.c"
off_t off_from_oct(char const   *p , size_t s ) 
{ 
  uintmax_t tmp ;

  {
  {
#line 637
  tmp = from_oct(p, s, "off_t", (uintmax_t )(-1LL - (-1LL << (sizeof(off_t ) * 8UL - 1UL))));
  }
#line 637
  return ((off_t )tmp);
}
}
#line 639 "list.c"
size_t size_from_oct(char const   *p , size_t s ) 
{ 
  uintmax_t tmp ;

  {
  {
#line 642
  tmp = from_oct(p, s, "size_t", (uintmax_t )4294967295U);
  }
#line 642
  return ((size_t )tmp);
}
}
#line 644 "list.c"
time_t time_from_oct(char const   *p , size_t s ) 
{ 
  uintmax_t tmp ;

  {
  {
#line 647
  tmp = from_oct(p, s, "time_t", (uintmax_t )(-1L - (-1L << (sizeof(time_t ) * 8UL - 1UL))));
  }
#line 647
  return ((time_t )tmp);
}
}
#line 649 "list.c"
uid_t uid_from_oct(char const   *p , size_t s ) 
{ 
  uintmax_t tmp ;

  {
  {
#line 652
  tmp = from_oct(p, s, "uid_t", (uintmax_t )4294967295U);
  }
#line 652
  return ((uid_t )tmp);
}
}
#line 654 "list.c"
uintmax_t uintmax_from_oct(char const   *p , size_t s ) 
{ 
  uintmax_t tmp ;

  {
  {
#line 657
  tmp = from_oct(p, s, "uintmax_t", 0xffffffffffffffffULL);
  }
#line 657
  return (tmp);
}
}
#line 666 "list.c"
char *stringify_uintmax_t_backwards(uintmax_t o___0 , char *buf ) 
{ 


  {
#line 669
  buf --;
#line 669
  *buf = (char )'\000';
  {
#line 670
  while (1) {
    while_continue: /* CIL Label */ ;
#line 671
    buf --;
#line 671
    *buf = (char )(48 + (int )(o___0 % 10ULL));
#line 670
    o___0 /= 10ULL;
#line 670
    if (! (o___0 != 0ULL)) {
#line 670
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 673
  return (buf);
}
}
#line 687 "list.c"
static char buffer___0[21]  ;
#line 684 "list.c"
static char *isotime(time_t const   *time___0 ) 
{ 
  struct tm *tm ;

  {
  {
#line 690
  tm = localtime(time___0);
#line 691
  sprintf((char */* __restrict  */)(buffer___0), (char const   */* __restrict  */)"%4d-%02d-%02d %02d:%02d:%02d\n",
          tm->tm_year + 1900, tm->tm_mon + 1, tm->tm_mday, tm->tm_hour, tm->tm_min,
          tm->tm_sec);
  }
#line 694
  return (buffer___0);
}
}
#line 704 "list.c"
static void decode_mode(mode_t mode , char *string ) 
{ 
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;

  {
#line 707
  tmp = string;
#line 707
  string ++;
#line 707
  if (mode & 256U) {
#line 707
    *tmp = (char )'r';
  } else {
#line 707
    *tmp = (char )'-';
  }
#line 708
  tmp___0 = string;
#line 708
  string ++;
#line 708
  if (mode & 128U) {
#line 708
    *tmp___0 = (char )'w';
  } else {
#line 708
    *tmp___0 = (char )'-';
  }
#line 709
  tmp___1 = string;
#line 709
  string ++;
#line 709
  if (mode & 2048U) {
#line 709
    if (mode & 64U) {
#line 709
      tmp___2 = 's';
    } else {
#line 709
      tmp___2 = 'S';
    }
#line 709
    *tmp___1 = (char )tmp___2;
  } else {
#line 709
    if (mode & 64U) {
#line 709
      tmp___3 = 'x';
    } else {
#line 709
      tmp___3 = '-';
    }
#line 709
    *tmp___1 = (char )tmp___3;
  }
#line 712
  tmp___4 = string;
#line 712
  string ++;
#line 712
  if (mode & (unsigned int )(256 >> 3)) {
#line 712
    *tmp___4 = (char )'r';
  } else {
#line 712
    *tmp___4 = (char )'-';
  }
#line 713
  tmp___5 = string;
#line 713
  string ++;
#line 713
  if (mode & (unsigned int )(128 >> 3)) {
#line 713
    *tmp___5 = (char )'w';
  } else {
#line 713
    *tmp___5 = (char )'-';
  }
#line 714
  tmp___6 = string;
#line 714
  string ++;
#line 714
  if (mode & 1024U) {
#line 714
    if (mode & (unsigned int )(64 >> 3)) {
#line 714
      tmp___7 = 's';
    } else {
#line 714
      tmp___7 = 'S';
    }
#line 714
    *tmp___6 = (char )tmp___7;
  } else {
#line 714
    if (mode & (unsigned int )(64 >> 3)) {
#line 714
      tmp___8 = 'x';
    } else {
#line 714
      tmp___8 = '-';
    }
#line 714
    *tmp___6 = (char )tmp___8;
  }
#line 717
  tmp___9 = string;
#line 717
  string ++;
#line 717
  if (mode & (unsigned int )((256 >> 3) >> 3)) {
#line 717
    *tmp___9 = (char )'r';
  } else {
#line 717
    *tmp___9 = (char )'-';
  }
#line 718
  tmp___10 = string;
#line 718
  string ++;
#line 718
  if (mode & (unsigned int )((128 >> 3) >> 3)) {
#line 718
    *tmp___10 = (char )'w';
  } else {
#line 718
    *tmp___10 = (char )'-';
  }
#line 719
  tmp___11 = string;
#line 719
  string ++;
#line 719
  if (mode & 512U) {
#line 719
    if (mode & (unsigned int )((64 >> 3) >> 3)) {
#line 719
      tmp___12 = 't';
    } else {
#line 719
      tmp___12 = 'T';
    }
#line 719
    *tmp___11 = (char )tmp___12;
  } else {
#line 719
    if (mode & (unsigned int )((64 >> 3) >> 3)) {
#line 719
      tmp___13 = 'x';
    } else {
#line 719
      tmp___13 = '-';
    }
#line 719
    *tmp___11 = (char )tmp___13;
  }
#line 722
  *string = (char )'\000';
#line 723
  return;
}
}
#line 742 "list.c"
static int ugswidth  =    18;
#line 751 "list.c"
void print_header(void) 
{ 
  char modes[11] ;
  char *timestamp ;
  char uform[(((sizeof(uintmax_t ) * 8UL) * 302UL) / 1000UL + 1UL) + 1UL] ;
  char gform[(((sizeof(uintmax_t ) * 8UL) * 302UL) / 1000UL + 1UL) + 1UL] ;
  char *user ;
  char *group ;
  char size[2UL * ((((sizeof(uintmax_t ) * 8UL) * 302UL) / 1000UL + 1UL) + 1UL)] ;
  char uintbuf[(((sizeof(uintmax_t ) * 8UL) * 302UL) / 1000UL + 1UL) + 1UL] ;
  time_t longie ;
  int pad ;
  char *name ;
  char buf[(((sizeof(uintmax_t ) * 8UL) * 302UL) / 1000UL + 1UL) + 1UL] ;
  off_t tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *quoted_name ;
  char *tmp___2 ;
  char *tmp___3 ;
  size_t tmp___4 ;
  uintmax_t tmp___5 ;
  uintmax_t tmp___6 ;
  uintmax_t tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  size_t tmp___10 ;
  size_t tmp___11 ;
  size_t tmp___12 ;
  char *tmp___13 ;
  char *tmp___14 ;
  char *tmp___15 ;
  char *tmp___16 ;
  uintmax_t tmp___17 ;
  char *tmp___18 ;
  char *tmp___19 ;
  char *tmp___20 ;

  {
#line 766
  if (block_number_option) {
    {
#line 769
    tmp = current_block_ordinal();
#line 769
    tmp___0 = stringify_uintmax_t_backwards((uintmax_t )tmp, buf + sizeof(buf));
#line 769
    tmp___1 = gettext("block %s: ");
#line 769
    fprintf((FILE */* __restrict  */)stdlis, (char const   */* __restrict  */)tmp___1,
            tmp___0);
    }
  }
#line 773
  if (verbose_option <= 1) {
    {
#line 777
    tmp___2 = quote_copy_string((char const   *)current_file_name);
#line 777
    quoted_name = tmp___2;
    }
#line 779
    if (quoted_name) {
      {
#line 781
      fprintf((FILE */* __restrict  */)stdlis, (char const   */* __restrict  */)"%s\n",
              quoted_name);
#line 782
      free((void *)quoted_name);
      }
    } else {
      {
#line 785
      fprintf((FILE */* __restrict  */)stdlis, (char const   */* __restrict  */)"%s\n",
              current_file_name);
      }
    }
  } else {
#line 791
    modes[0] = (char )'?';
    {
#line 794
    if ((int )current_header->header.typeflag == 86) {
#line 794
      goto case_86;
    }
#line 798
    if ((int )current_header->header.typeflag == 77) {
#line 798
      goto case_77;
    }
#line 802
    if ((int )current_header->header.typeflag == 78) {
#line 802
      goto case_78;
    }
#line 807
    if ((int )current_header->header.typeflag == 75) {
#line 807
      goto case_75;
    }
#line 807
    if ((int )current_header->header.typeflag == 76) {
#line 807
      goto case_75;
    }
#line 814
    if ((int )current_header->header.typeflag == 49) {
#line 814
      goto case_49;
    }
#line 814
    if ((int )current_header->header.typeflag == 0) {
#line 814
      goto case_49;
    }
#line 814
    if ((int )current_header->header.typeflag == 48) {
#line 814
      goto case_49;
    }
#line 814
    if ((int )current_header->header.typeflag == 83) {
#line 814
      goto case_49;
    }
#line 819
    if ((int )current_header->header.typeflag == 68) {
#line 819
      goto case_68;
    }
#line 822
    if ((int )current_header->header.typeflag == 53) {
#line 822
      goto case_53;
    }
#line 825
    if ((int )current_header->header.typeflag == 50) {
#line 825
      goto case_50;
    }
#line 828
    if ((int )current_header->header.typeflag == 52) {
#line 828
      goto case_52;
    }
#line 831
    if ((int )current_header->header.typeflag == 51) {
#line 831
      goto case_51;
    }
#line 834
    if ((int )current_header->header.typeflag == 54) {
#line 834
      goto case_54;
    }
#line 837
    if ((int )current_header->header.typeflag == 55) {
#line 837
      goto case_55;
    }
#line 792
    goto switch_break;
    case_86: /* CIL Label */ 
#line 795
    modes[0] = (char )'V';
#line 796
    goto switch_break;
    case_77: /* CIL Label */ 
#line 799
    modes[0] = (char )'M';
#line 800
    goto switch_break;
    case_78: /* CIL Label */ 
#line 803
    modes[0] = (char )'N';
#line 804
    goto switch_break;
    case_75: /* CIL Label */ 
    case_76: /* CIL Label */ 
    {
#line 808
    tmp___3 = gettext("Visible longname error");
#line 808
    error(0, 0, (char const   *)tmp___3);
#line 808
    exit_status = 2;
    }
#line 809
    goto switch_break;
    case_49: /* CIL Label */ 
    case_0: /* CIL Label */ 
    case_48: /* CIL Label */ 
    case_83: /* CIL Label */ 
    {
#line 815
    modes[0] = (char )'-';
#line 816
    tmp___4 = strlen((char const   *)current_file_name);
    }
#line 816
    if ((int )*(current_file_name + (tmp___4 - 1U)) == 47) {
#line 817
      modes[0] = (char )'d';
    }
#line 818
    goto switch_break;
    case_68: /* CIL Label */ 
#line 820
    modes[0] = (char )'d';
#line 821
    goto switch_break;
    case_53: /* CIL Label */ 
#line 823
    modes[0] = (char )'d';
#line 824
    goto switch_break;
    case_50: /* CIL Label */ 
#line 826
    modes[0] = (char )'l';
#line 827
    goto switch_break;
    case_52: /* CIL Label */ 
#line 829
    modes[0] = (char )'b';
#line 830
    goto switch_break;
    case_51: /* CIL Label */ 
#line 832
    modes[0] = (char )'c';
#line 833
    goto switch_break;
    case_54: /* CIL Label */ 
#line 835
    modes[0] = (char )'p';
#line 836
    goto switch_break;
    case_55: /* CIL Label */ 
#line 838
    modes[0] = (char )'C';
#line 839
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
    {
#line 842
    decode_mode(current_stat.st_mode, modes + 1);
#line 846
    longie = current_stat.st_mtim.tv_sec;
#line 852
    timestamp = isotime((time_t const   *)(& longie));
#line 853
    *(timestamp + 16) = (char )'\000';
    }
#line 858
    if (current_header->header.uname[0]) {
#line 858
      if ((unsigned int )current_format != 1U) {
#line 859
        user = current_header->header.uname;
      } else {
        {
#line 861
        tmp___5 = uintmax_from_oct((char const   *)(current_header->header.uid), (size_t )sizeof(current_header->header.uid));
#line 861
        user = stringify_uintmax_t_backwards(tmp___5, uform + sizeof(uform));
        }
      }
    } else {
      {
#line 861
      tmp___5 = uintmax_from_oct((char const   *)(current_header->header.uid), (size_t )sizeof(current_header->header.uid));
#line 861
      user = stringify_uintmax_t_backwards(tmp___5, uform + sizeof(uform));
      }
    }
#line 864
    if (current_header->header.gname[0]) {
#line 864
      if ((unsigned int )current_format != 1U) {
#line 865
        group = current_header->header.gname;
      } else {
        {
#line 867
        tmp___6 = uintmax_from_oct((char const   *)(current_header->header.gid), (size_t )sizeof(current_header->header.gid));
#line 867
        group = stringify_uintmax_t_backwards(tmp___6, gform + sizeof(gform));
        }
      }
    } else {
      {
#line 867
      tmp___6 = uintmax_from_oct((char const   *)(current_header->header.gid), (size_t )sizeof(current_header->header.gid));
#line 867
      group = stringify_uintmax_t_backwards(tmp___6, gform + sizeof(gform));
      }
    }
    {
#line 877
    if ((int )current_header->header.typeflag == 52) {
#line 877
      goto case_52___0;
    }
#line 877
    if ((int )current_header->header.typeflag == 51) {
#line 877
      goto case_52___0;
    }
#line 883
    if ((int )current_header->header.typeflag == 83) {
#line 883
      goto case_83___0;
    }
#line 889
    goto switch_default;
    case_52___0: /* CIL Label */ 
    case_51___0: /* CIL Label */ 
    {
#line 878
    sprintf((char */* __restrict  */)(size), (char const   */* __restrict  */)"%lu,%lu",
            (unsigned long )((int )((current_stat.st_rdev >> 8) & 255ULL)), (unsigned long )((int )(current_stat.st_rdev & 255ULL)));
    }
#line 881
    goto switch_break___0;
    case_83___0: /* CIL Label */ 
    {
#line 884
    tmp___7 = uintmax_from_oct((char const   *)(current_header->oldgnu_header.realsize),
                               (size_t )sizeof(current_header->oldgnu_header.realsize));
#line 884
    tmp___8 = stringify_uintmax_t_backwards(tmp___7, uintbuf + sizeof(uintbuf));
#line 884
    strcpy((char */* __restrict  */)(size), (char const   */* __restrict  */)tmp___8);
    }
#line 888
    goto switch_break___0;
    switch_default: /* CIL Label */ 
    {
#line 890
    tmp___9 = stringify_uintmax_t_backwards((uintmax_t )current_stat.st_size, uintbuf + sizeof(uintbuf));
#line 890
    strcpy((char */* __restrict  */)(size), (char const   */* __restrict  */)tmp___9);
    }
#line 891
    goto switch_break___0;
    switch_break___0: /* CIL Label */ ;
    }
    {
#line 896
    tmp___10 = strlen((char const   *)user);
#line 896
    tmp___11 = strlen((char const   *)group);
#line 896
    tmp___12 = strlen((char const   *)(size));
#line 896
    pad = (int )(((tmp___10 + tmp___11) + tmp___12) + 1U);
    }
#line 897
    if (pad > ugswidth) {
#line 898
      ugswidth = pad;
    }
    {
#line 905
    fprintf((FILE */* __restrict  */)stdlis, (char const   */* __restrict  */)"%s %s/%s %*s%s %s",
            modes, user, group, ugswidth - pad, "", size, timestamp);
#line 909
    name = quote_copy_string((char const   *)current_file_name);
    }
#line 910
    if (name) {
      {
#line 912
      fprintf((FILE */* __restrict  */)stdlis, (char const   */* __restrict  */)" %s",
              name);
#line 913
      free((void *)name);
      }
    } else {
      {
#line 916
      fprintf((FILE */* __restrict  */)stdlis, (char const   */* __restrict  */)" %s",
              current_file_name);
      }
    }
    {
#line 920
    if ((int )current_header->header.typeflag == 50) {
#line 920
      goto case_50___0;
    }
#line 931
    if ((int )current_header->header.typeflag == 49) {
#line 931
      goto case_49___0;
    }
#line 955
    if ((int )current_header->header.typeflag == 68) {
#line 955
      goto case_68___0;
    }
#line 955
    if ((int )current_header->header.typeflag == 55) {
#line 955
      goto case_68___0;
    }
#line 955
    if ((int )current_header->header.typeflag == 54) {
#line 955
      goto case_68___0;
    }
#line 955
    if ((int )current_header->header.typeflag == 53) {
#line 955
      goto case_68___0;
    }
#line 955
    if ((int )current_header->header.typeflag == 52) {
#line 955
      goto case_68___0;
    }
#line 955
    if ((int )current_header->header.typeflag == 51) {
#line 955
      goto case_68___0;
    }
#line 955
    if ((int )current_header->header.typeflag == 83) {
#line 955
      goto case_68___0;
    }
#line 955
    if ((int )current_header->header.typeflag == 48) {
#line 955
      goto case_68___0;
    }
#line 955
    if ((int )current_header->header.typeflag == 0) {
#line 955
      goto case_68___0;
    }
#line 959
    if ((int )current_header->header.typeflag == 86) {
#line 959
      goto case_86___0;
    }
#line 963
    if ((int )current_header->header.typeflag == 77) {
#line 963
      goto case_77___0;
    }
#line 971
    if ((int )current_header->header.typeflag == 78) {
#line 971
      goto case_78___0;
    }
#line 942
    goto switch_default___0;
    case_50___0: /* CIL Label */ 
    {
#line 921
    name = quote_copy_string((char const   *)current_link_name);
    }
#line 922
    if (name) {
      {
#line 924
      fprintf((FILE */* __restrict  */)stdlis, (char const   */* __restrict  */)" -> %s\n",
              name);
#line 925
      free((void *)name);
      }
    } else {
      {
#line 928
      fprintf((FILE */* __restrict  */)stdlis, (char const   */* __restrict  */)" -> %s\n",
              current_link_name);
      }
    }
#line 929
    goto switch_break___1;
    case_49___0: /* CIL Label */ 
    {
#line 932
    name = quote_copy_string((char const   *)current_link_name);
    }
#line 933
    if (name) {
      {
#line 935
      tmp___13 = gettext(" link to %s\n");
#line 935
      fprintf((FILE */* __restrict  */)stdlis, (char const   */* __restrict  */)tmp___13,
              name);
#line 936
      free((void *)name);
      }
    } else {
      {
#line 939
      tmp___14 = gettext(" link to %s\n");
#line 939
      fprintf((FILE */* __restrict  */)stdlis, (char const   */* __restrict  */)tmp___14,
              current_link_name);
      }
    }
#line 940
    goto switch_break___1;
    switch_default___0: /* CIL Label */ 
    {
#line 943
    tmp___15 = gettext(" unknown file type `%c\'\n");
#line 943
    fprintf((FILE */* __restrict  */)stdlis, (char const   */* __restrict  */)tmp___15,
            (int )current_header->header.typeflag);
    }
#line 945
    goto switch_break___1;
    case_68___0: /* CIL Label */ 
    case_55___0: /* CIL Label */ 
    case_54___0: /* CIL Label */ 
    case_53___0: /* CIL Label */ 
    case_52___1: /* CIL Label */ 
    case_51___1: /* CIL Label */ 
    case_83___1: /* CIL Label */ 
    case_48___0: /* CIL Label */ 
    case_0___0: /* CIL Label */ 
    {
#line 956
    _IO_putc('\n', stdlis);
    }
#line 957
    goto switch_break___1;
    case_86___0: /* CIL Label */ 
    {
#line 960
    tmp___16 = gettext("--Volume Header--\n");
#line 960
    fprintf((FILE */* __restrict  */)stdlis, (char const   */* __restrict  */)tmp___16);
    }
#line 961
    goto switch_break___1;
    case_77___0: /* CIL Label */ 
    {
#line 964
    tmp___17 = uintmax_from_oct((char const   *)(current_header->oldgnu_header.offset),
                                (size_t )sizeof(current_header->oldgnu_header.offset));
#line 964
    tmp___18 = stringify_uintmax_t_backwards(tmp___17, uintbuf + sizeof(uintbuf));
#line 964
    strcpy((char */* __restrict  */)(size), (char const   */* __restrict  */)tmp___18);
#line 968
    tmp___19 = gettext("--Continued at byte %s--\n");
#line 968
    fprintf((FILE */* __restrict  */)stdlis, (char const   */* __restrict  */)tmp___19,
            size);
    }
#line 969
    goto switch_break___1;
    case_78___0: /* CIL Label */ 
    {
#line 972
    tmp___20 = gettext("--Mangled file names--\n");
#line 972
    fprintf((FILE */* __restrict  */)stdlis, (char const   */* __restrict  */)tmp___20);
    }
#line 973
    goto switch_break___1;
    switch_break___1: /* CIL Label */ ;
    }
  }
  {
#line 976
  fflush(stdlis);
  }
#line 977
  return;
}
}
#line 983 "list.c"
void print_for_mkdir(char *pathname , int length , mode_t mode ) 
{ 
  char modes[11] ;
  char *name ;
  char buf[(((sizeof(uintmax_t ) * 8UL) * 302UL) / 1000UL + 1UL) + 1UL] ;
  off_t tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;

  {
#line 989
  if (verbose_option > 1) {
    {
#line 993
    modes[0] = (char )'d';
#line 994
    decode_mode(mode, modes + 1);
    }
#line 996
    if (block_number_option) {
      {
#line 999
      tmp = current_block_ordinal();
#line 999
      tmp___0 = stringify_uintmax_t_backwards((uintmax_t )tmp, buf + sizeof(buf));
#line 999
      tmp___1 = gettext("block %s: ");
#line 999
      fprintf((FILE */* __restrict  */)stdlis, (char const   */* __restrict  */)tmp___1,
              tmp___0);
      }
    }
    {
#line 1002
    name = quote_copy_string((char const   *)pathname);
    }
#line 1003
    if (name) {
      {
#line 1005
      tmp___2 = gettext("Creating directory:");
#line 1005
      fprintf((FILE */* __restrict  */)stdlis, (char const   */* __restrict  */)"%s %*s %.*s\n",
              modes, ugswidth + 18, tmp___2, length, name);
#line 1007
      free((void *)name);
      }
    } else {
      {
#line 1010
      tmp___3 = gettext("Creating directory:");
#line 1010
      fprintf((FILE */* __restrict  */)stdlis, (char const   */* __restrict  */)"%s %*s %.*s\n",
              modes, ugswidth + 18, tmp___3, length, pathname);
      }
    }
  }
#line 1013
  return;
}
}
#line 1019 "list.c"
void skip_file(off_t size ) 
{ 
  union block *x ;
  char *tmp ;
  char *tmp___0 ;

  {
#line 1024
  if (multi_volume_option) {
#line 1026
    save_totsize = size;
#line 1027
    save_sizeleft = size;
  }
  {
#line 1030
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1030
    if (! (size > 0LL)) {
#line 1030
      goto while_break;
    }
    {
#line 1032
    x = find_next_block();
    }
#line 1033
    if ((unsigned long )x == (unsigned long )((void *)0)) {
      {
#line 1034
      tmp = gettext("Unexpected EOF on archive file");
#line 1034
      error(0, 0, (char const   *)tmp);
#line 1034
      tmp___0 = gettext("Error is not recoverable: exiting now");
#line 1034
      error(2, 0, (char const   *)tmp___0);
      }
    }
    {
#line 1036
    set_next_block_after(x);
#line 1037
    size -= 512LL;
    }
#line 1038
    if (multi_volume_option) {
#line 1039
      save_sizeleft -= 512LL;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1041
  return;
}
}
#line 1047 "list.c"
void skip_extended_headers(void) 
{ 
  union block *exhdr ;

  {
  {
#line 1052
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1054
    exhdr = find_next_block();
    }
#line 1055
    if (! exhdr->sparse_header.isextended) {
      {
#line 1057
      set_next_block_after(exhdr);
      }
#line 1058
      goto while_break;
    }
    {
#line 1060
    set_next_block_after(exhdr);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1062
  return;
}
}
#line 89 "/usr/include/string.h"
extern char *strcat(char * __restrict  __dest , char const   * __restrict  __src ) ;
#line 743 "/usr/include/stdlib.h"
extern void qsort(void *__base , size_t __nmemb , size_t __size , int (*__compar)(void const   * ,
                                                                                  void const   * ) ) ;
#line 526 "/usr/include/stdio.h"
extern char *fgets(char * __restrict  __s , int __n , FILE * __restrict  __stream ) ;
#line 398 "common.h"
void collect_and_sort_names(void) ;
#line 399
char *get_directory_contents(char *path___0 , dev_t device ) ;
#line 400
void write_dir_file(void) ;
#line 401
void gnu_restore(int skipcrud ) ;
#line 41 "incremen.c"
static char *get_accumulator(struct accumulator *accumulator ) 
{ 


  {
#line 44
  return (accumulator->pointer);
}
}
#line 51 "incremen.c"
static struct accumulator *new_accumulator(void) 
{ 
  struct accumulator *accumulator ;
  void *tmp ;
  void *tmp___0 ;

  {
  {
#line 54
  tmp = xmalloc((size_t )sizeof(struct accumulator ));
#line 54
  accumulator = (struct accumulator *)tmp;
#line 57
  accumulator->allocated = (size_t )50;
#line 58
  tmp___0 = xmalloc((size_t )50);
#line 58
  accumulator->pointer = (char *)tmp___0;
#line 59
  accumulator->length = (size_t )0;
  }
#line 60
  return (accumulator);
}
}
#line 67 "incremen.c"
static void delete_accumulator(struct accumulator *accumulator ) 
{ 


  {
  {
#line 70
  free((void *)accumulator->pointer);
#line 71
  free((void *)accumulator);
  }
#line 72
  return;
}
}
#line 78 "incremen.c"
static void add_to_accumulator(struct accumulator *accumulator , char const   *data ,
                               size_t size ) 
{ 
  void *tmp ;

  {
#line 82
  if (accumulator->length + size > accumulator->allocated) {
    {
#line 84
    accumulator->allocated = (accumulator->length + size) + 50U;
#line 85
    tmp = xrealloc((void *)accumulator->pointer, accumulator->allocated);
#line 85
    accumulator->pointer = (char *)tmp;
    }
  }
  {
#line 88
  memcpy((void */* __restrict  */)(accumulator->pointer + accumulator->length), (void const   */* __restrict  */)data,
         size);
#line 89
  accumulator->length += size;
  }
#line 90
  return;
}
}
#line 95 "incremen.c"
static time_t time_now  ;
#line 108 "incremen.c"
static struct directory *directory_list  =    (struct directory *)((void *)0);
#line 123 "incremen.c"
static void note_directory(char *name , struct stat *st , char const   *text ) 
{ 
  struct directory *directory ;
  void *tmp ;
  char *tmp___0 ;

  {
  {
#line 126
  tmp = xmalloc((size_t )sizeof(struct directory ));
#line 126
  directory = (struct directory *)tmp;
#line 129
  directory->next = directory_list;
#line 130
  directory_list = directory;
#line 132
  directory->device_number = st->st_dev;
#line 133
  directory->inode_number = st->st_ino;
#line 134
  tmp___0 = xstrdup((char const   *)name);
#line 134
  directory->name = (char const   *)tmp___0;
#line 135
  directory->dir_text = text;
#line 136
  directory->allnew = (char)0;
#line 137
  directory->nfs = (char )((st->st_dev & (0xffffffffffffffffULL << (sizeof(st->st_dev) * 8UL - 1UL))) != 0ULL);
  }
#line 138
  return;
}
}
#line 144 "incremen.c"
static struct directory *find_directory(char *name ) 
{ 
  struct directory *directory ;
  int tmp ;

  {
#line 149
  directory = directory_list;
  {
#line 149
  while (1) {
    while_continue: /* CIL Label */ ;
#line 149
    if (! directory) {
#line 149
      goto while_break;
    }
    {
#line 153
    tmp = strcmp(directory->name, (char const   *)name);
    }
#line 153
    if (! tmp) {
#line 154
      return (directory);
    }
#line 149
    directory = directory->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 156
  return ((struct directory *)((void *)0));
}
}
#line 163 "incremen.c"
static int compare_dirents(void const   *first , void const   *second ) 
{ 
  int tmp ;

  {
  {
#line 166
  tmp = strcmp((char const   *)(*((char * const  *)first) + 1), (char const   *)(*((char * const  *)second) + 1));
  }
#line 166
  return (tmp);
}
}
#line 174 "incremen.c"
char *get_directory_contents(char *path___0 , dev_t device ) 
{ 
  struct accumulator *accumulator ;
  DIR *dirp ;
  DIR *tmp ;
  struct dirent *entry ;
  char *name_buffer___0 ;
  size_t name_buffer_size ;
  size_t name_length ;
  struct directory *directory ;
  int all_children ;
  char *tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  size_t tmp___3 ;
  void *tmp___4 ;
  size_t tmp___5 ;
  int tmp___6 ;
  struct stat stat_data ;
  size_t tmp___7 ;
  void *tmp___8 ;
  size_t tmp___9 ;
  char *tmp___10 ;
  int *tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  char *tmp___15 ;
  char *tmp___16 ;
  int tmp___17 ;
  size_t tmp___18 ;
  char *pointer ;
  char *tmp___19 ;
  size_t counter ;
  char *cursor ;
  char *buffer___1 ;
  char **array ;
  char **array_cursor ;
  size_t tmp___20 ;
  void *tmp___21 ;
  size_t tmp___22 ;
  char **tmp___23 ;
  void *tmp___24 ;
  char *string ;
  char *tmp___25 ;
  char tmp___26 ;
  char *tmp___27 ;

  {
  {
#line 182
  tmp = opendir((char const   *)path___0);
#line 182
  dirp = tmp;
  }
#line 190
  if ((unsigned long )dirp == (unsigned long )((void *)0)) {
    {
#line 192
    tmp___0 = gettext("Cannot open directory %s");
#line 192
    tmp___1 = __errno_location();
#line 192
    error(0, *tmp___1, (char const   *)tmp___0, path___0);
#line 192
    exit_status = 2;
    }
#line 193
    return ((char *)((void *)0));
  }
  {
#line 195
  tmp___2 = __errno_location();
#line 195
  *tmp___2 = 0;
#line 197
  tmp___3 = strlen((char const   *)path___0);
#line 197
  name_buffer_size = tmp___3 + 100U;
#line 198
  tmp___4 = xmalloc(name_buffer_size + 2U);
#line 198
  name_buffer___0 = (char *)tmp___4;
#line 199
  strcpy((char */* __restrict  */)name_buffer___0, (char const   */* __restrict  */)path___0);
#line 200
  tmp___5 = strlen((char const   *)path___0);
  }
#line 200
  if ((int )*(path___0 + (tmp___5 - 1U)) != 47) {
    {
#line 201
    strcat((char */* __restrict  */)name_buffer___0, (char const   */* __restrict  */)"/");
    }
  }
  {
#line 202
  name_length = strlen((char const   *)name_buffer___0);
#line 204
  directory = find_directory(path___0);
  }
#line 205
  if (directory) {
#line 205
    all_children = (int )directory->allnew;
  } else {
#line 205
    all_children = 0;
  }
  {
#line 207
  accumulator = new_accumulator();
  }
  {
#line 209
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 209
    entry = readdir(dirp);
    }
#line 209
    if (! entry) {
#line 209
      goto while_break;
    }
    {
#line 213
    tmp___6 = is_dot_or_dotdot((char const   *)(entry->d_name));
    }
#line 213
    if (tmp___6) {
#line 214
      goto while_continue;
    }
    {
#line 216
    tmp___17 = excluded_filename((struct exclude  const  *)excluded, (char const   *)(entry->d_name));
    }
#line 216
    if (tmp___17) {
      {
#line 217
      add_to_accumulator(accumulator, "N", (size_t )1);
      }
    } else {
      {
#line 222
      tmp___9 = strlen((char const   *)(entry->d_name));
      }
#line 222
      if (tmp___9 + name_length >= name_buffer_size) {
        {
#line 224
        while (1) {
          while_continue___0: /* CIL Label */ ;
          {
#line 224
          tmp___7 = strlen((char const   *)(entry->d_name));
          }
#line 224
          if (! (tmp___7 + name_length >= name_buffer_size)) {
#line 224
            goto while_break___0;
          }
#line 225
          name_buffer_size += 100U;
        }
        while_break___0: /* CIL Label */ ;
        }
        {
#line 226
        tmp___8 = xrealloc((void *)name_buffer___0, name_buffer_size + 2U);
#line 226
        name_buffer___0 = (char *)tmp___8;
        }
      }
      {
#line 229
      strcpy((char */* __restrict  */)(name_buffer___0 + name_length), (char const   */* __restrict  */)(entry->d_name));
      }
#line 231
      if (dereference_option) {
        {
#line 231
        tmp___12 = stat((char const   */* __restrict  */)name_buffer___0, (struct stat */* __restrict  */)(& stat_data));
#line 231
        tmp___14 = tmp___12;
        }
      } else {
        {
#line 231
        tmp___13 = lstat((char const   */* __restrict  */)name_buffer___0, (struct stat */* __restrict  */)(& stat_data));
#line 231
        tmp___14 = tmp___13;
        }
      }
#line 231
      if (tmp___14) {
        {
#line 241
        tmp___10 = gettext("Cannot stat %s");
#line 241
        tmp___11 = __errno_location();
#line 241
        error(0, *tmp___11, (char const   *)tmp___10, name_buffer___0);
#line 241
        exit_status = 2;
        }
#line 242
        goto while_continue;
      }
#line 245
      if (one_file_system_option) {
#line 245
        if (device != stat_data.st_dev) {
          {
#line 246
          add_to_accumulator(accumulator, "N", (size_t )1);
          }
        } else {
#line 245
          goto _L___2;
        }
      } else
      _L___2: /* CIL Label */ 
#line 257
      if ((stat_data.st_mode & 61440U) == 16384U) {
        {
#line 259
        directory = find_directory(name_buffer___0);
        }
#line 259
        if (directory) {
#line 270
          if (directory->nfs) {
#line 270
            if ((stat_data.st_dev & (0xffffffffffffffffULL << (sizeof(stat_data.st_dev) * 8UL - 1UL))) != 0ULL) {
#line 270
              goto _L___0;
            } else {
#line 270
              goto _L___1;
            }
          } else
          _L___1: /* CIL Label */ 
#line 270
          if (directory->device_number == stat_data.st_dev) {
            _L___0: /* CIL Label */ 
#line 270
            if (! (directory->inode_number == stat_data.st_ino)) {
#line 270
              goto _L;
            }
          } else {
            _L: /* CIL Label */ 
#line 274
            if (verbose_option) {
              {
#line 275
              tmp___15 = gettext("Directory %s has been renamed");
#line 275
              error(0, 0, (char const   *)tmp___15, name_buffer___0);
              }
            }
#line 277
            directory->allnew = (char)1;
#line 278
            directory->nfs = (char )((stat_data.st_dev & (0xffffffffffffffffULL << (sizeof(stat_data.st_dev) * 8UL - 1UL))) != 0ULL);
#line 279
            directory->device_number = stat_data.st_dev;
#line 280
            directory->inode_number = stat_data.st_ino;
          }
#line 282
          directory->dir_text = "";
        } else {
#line 286
          if (verbose_option) {
            {
#line 287
            tmp___16 = gettext("Directory %s is new");
#line 287
            error(0, 0, (char const   *)tmp___16, name_buffer___0);
            }
          }
          {
#line 288
          note_directory(name_buffer___0, & stat_data, "");
#line 289
          directory = find_directory(name_buffer___0);
#line 290
          directory->allnew = (char)1;
          }
        }
#line 292
        if (all_children) {
#line 292
          if (directory) {
#line 293
            directory->allnew = (char)1;
          }
        }
        {
#line 295
        add_to_accumulator(accumulator, "D", (size_t )1);
        }
      } else
#line 299
      if (! all_children) {
#line 299
        if (stat_data.st_mtim.tv_sec < newer_mtime_option) {
#line 299
          if (! after_date_option) {
            {
#line 303
            add_to_accumulator(accumulator, "N", (size_t )1);
            }
          } else
#line 299
          if (stat_data.st_ctim.tv_sec < newer_mtime_option) {
            {
#line 303
            add_to_accumulator(accumulator, "N", (size_t )1);
            }
          } else {
            {
#line 305
            add_to_accumulator(accumulator, "Y", (size_t )1);
            }
          }
        } else {
          {
#line 305
          add_to_accumulator(accumulator, "Y", (size_t )1);
          }
        }
      } else {
        {
#line 305
        add_to_accumulator(accumulator, "Y", (size_t )1);
        }
      }
    }
    {
#line 308
    tmp___18 = strlen((char const   *)(entry->d_name));
#line 308
    add_to_accumulator(accumulator, (char const   *)(entry->d_name), tmp___18 + 1U);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 311
  add_to_accumulator(accumulator, "\000\000", (size_t )2);
#line 313
  free((void *)name_buffer___0);
#line 314
  closedir(dirp);
#line 320
  tmp___19 = get_accumulator(accumulator);
#line 320
  pointer = tmp___19;
#line 327
  counter = (size_t )0;
#line 328
  cursor = pointer;
  }
  {
#line 328
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 328
    if (! *cursor) {
#line 328
      goto while_break___1;
    }
    {
#line 329
    counter ++;
#line 328
    tmp___20 = strlen((char const   *)cursor);
#line 328
    cursor += tmp___20 + 1U;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 331
  if (counter == 0U) {
    {
#line 333
    delete_accumulator(accumulator);
    }
#line 334
    return ((char *)((void *)0));
  }
  {
#line 337
  tmp___21 = xmalloc((size_t )(sizeof(char *) * (unsigned long )(counter + 1U)));
#line 337
  array = (char **)tmp___21;
#line 339
  array_cursor = array;
#line 340
  cursor = pointer;
  }
  {
#line 340
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 340
    if (! *cursor) {
#line 340
      goto while_break___2;
    }
    {
#line 341
    tmp___23 = array_cursor;
#line 341
    array_cursor ++;
#line 341
    *tmp___23 = cursor;
#line 340
    tmp___22 = strlen((char const   *)cursor);
#line 340
    cursor += tmp___22 + 1U;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 342
  *array_cursor = (char *)((void *)0);
#line 344
  qsort((void *)array, counter, (size_t )sizeof(char *), & compare_dirents);
#line 346
  tmp___24 = xmalloc((size_t )((cursor - pointer) + 2L));
#line 346
  buffer___1 = (char *)tmp___24;
#line 348
  cursor = buffer___1;
#line 349
  array_cursor = array;
  }
  {
#line 349
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 349
    if (! *array_cursor) {
#line 349
      goto while_break___3;
    }
#line 351
    string = *array_cursor;
    {
#line 353
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 353
      tmp___25 = cursor;
#line 353
      cursor ++;
#line 353
      tmp___27 = string;
#line 353
      string ++;
#line 353
      tmp___26 = *tmp___27;
#line 353
      *tmp___25 = tmp___26;
#line 353
      if (! tmp___26) {
#line 353
        goto while_break___4;
      }
#line 354
      goto while_continue___4;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 349
    array_cursor ++;
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 356
  *cursor = (char )'\000';
#line 358
  delete_accumulator(accumulator);
#line 359
  free((void *)array);
  }
#line 360
  return (buffer___1);
}
}
#line 369 "incremen.c"
static void add_hierarchy_to_namelist(char *path___0 , dev_t device ) 
{ 
  char *buffer___1 ;
  char *tmp ;
  struct name *name ;
  int tmp___0 ;
  size_t name_length ;
  size_t tmp___1 ;
  size_t allocated_length___0 ;
  size_t tmp___2 ;
  char *name_buffer___0 ;
  void *tmp___3 ;
  char *string ;
  size_t string_length ;
  size_t tmp___4 ;
  void *tmp___5 ;

  {
  {
#line 372
  tmp = get_directory_contents(path___0, device);
#line 372
  buffer___1 = tmp;
#line 377
  name = namelist;
  }
  {
#line 377
  while (1) {
    while_continue: /* CIL Label */ ;
#line 377
    if (! name) {
#line 377
      goto while_break;
    }
    {
#line 378
    tmp___0 = strcmp((char const   *)(name->name), (char const   *)path___0);
    }
#line 378
    if (tmp___0 == 0) {
#line 379
      goto while_break;
    }
#line 377
    name = name->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 380
  if (name) {
#line 381
    if (buffer___1) {
#line 381
      name->dir_contents = (char const   *)buffer___1;
    } else {
#line 381
      name->dir_contents = "\000\000\000\000";
    }
  }
#line 384
  if (buffer___1) {
    {
#line 386
    tmp___1 = strlen((char const   *)path___0);
#line 386
    name_length = tmp___1;
    }
#line 387
    if (name_length >= 100U) {
#line 387
      tmp___2 = name_length + 100U;
    } else {
#line 387
      tmp___2 = (size_t )100;
    }
    {
#line 387
    allocated_length___0 = tmp___2;
#line 390
    tmp___3 = xmalloc(allocated_length___0 + 1U);
#line 390
    name_buffer___0 = (char *)tmp___3;
#line 395
    strcpy((char */* __restrict  */)name_buffer___0, (char const   */* __restrict  */)path___0);
    }
#line 396
    if ((int )*(name_buffer___0 + (name_length - 1U)) != 47) {
#line 398
      tmp___4 = name_length;
#line 398
      name_length ++;
#line 398
      *(name_buffer___0 + tmp___4) = (char )'/';
#line 399
      *(name_buffer___0 + name_length) = (char )'\000';
    }
#line 402
    string = buffer___1;
    {
#line 402
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 402
      if (! *string) {
#line 402
        goto while_break___0;
      }
      {
#line 404
      string_length = strlen((char const   *)string);
      }
#line 405
      if ((int )*string == 68) {
#line 407
        if (name_length + string_length >= allocated_length___0) {
          {
#line 409
          while (1) {
            while_continue___1: /* CIL Label */ ;
#line 409
            if (! (name_length + string_length >= allocated_length___0)) {
#line 409
              goto while_break___1;
            }
#line 410
            allocated_length___0 += 100U;
          }
          while_break___1: /* CIL Label */ ;
          }
          {
#line 411
          tmp___5 = xrealloc((void *)name_buffer___0, allocated_length___0 + 1U);
#line 411
          name_buffer___0 = (char *)tmp___5;
          }
        }
        {
#line 414
        strcpy((char */* __restrict  */)(name_buffer___0 + name_length), (char const   */* __restrict  */)(string + 1));
#line 415
        addname((char const   *)name_buffer___0);
#line 416
        add_hierarchy_to_namelist(name_buffer___0, device);
        }
      }
#line 402
      string += string_length + 1U;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 420
    free((void *)name_buffer___0);
    }
  }
#line 422
  return;
}
}
#line 434
static void read_directory_file(void) ;
#line 434 "incremen.c"
static char *path  =    (char *)((void *)0);
#line 428 "incremen.c"
static void read_directory_file(void) 
{ 
  char *strp ;
  FILE *fp ;
  char buf[512] ;
  void *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  size_t tmp___4 ;
  size_t tmp___5 ;
  char *tmp___6 ;
  int *tmp___7 ;
  int *tmp___8 ;
  struct stat st ;
  long l ;
  size_t tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;
  unsigned short const   **tmp___12 ;
  char *tmp___13 ;
  int *tmp___14 ;
  int tmp___15 ;

  {
#line 436
  if ((unsigned long )path == (unsigned long )((void *)0)) {
    {
#line 437
    tmp = xmalloc((size_t )4096);
#line 437
    path = (char *)tmp;
    }
  }
  {
#line 438
  time(& time_now);
  }
#line 439
  if ((int const   )*(listed_incremental_option + 0) != 47) {
    {
#line 442
    tmp___2 = getcwd(path, (size_t )4096);
    }
#line 442
    if (! tmp___2) {
      {
#line 443
      tmp___0 = gettext("Could not get current directory");
#line 443
      error(0, 0, (char const   *)tmp___0);
#line 443
      tmp___1 = gettext("Error is not recoverable: exiting now");
#line 443
      error(2, 0, (char const   *)tmp___1);
      }
    }
    {
#line 451
    tmp___4 = strlen((char const   *)path);
#line 451
    tmp___5 = strlen(listed_incremental_option);
    }
#line 451
    if (((tmp___4 + 1U) + tmp___5) + 1U > 4096U) {
      {
#line 452
      tmp___3 = gettext("File name %s/%s too long");
#line 452
      error(2, 0, (char const   *)tmp___3, path, listed_incremental_option);
#line 452
      exit_status = 2;
      }
    }
    {
#line 455
    strcat((char */* __restrict  */)path, (char const   */* __restrict  */)"/");
#line 456
    strcat((char */* __restrict  */)path, (char const   */* __restrict  */)listed_incremental_option);
#line 457
    listed_incremental_option = (char const   *)path;
    }
  }
  {
#line 459
  fp = fopen((char const   */* __restrict  */)listed_incremental_option, (char const   */* __restrict  */)"r");
  }
#line 460
  if ((unsigned long )fp == (unsigned long )((FILE *)0)) {
    {
#line 460
    tmp___8 = __errno_location();
    }
#line 460
    if (*tmp___8 != 2) {
      {
#line 462
      tmp___6 = gettext("Cannot open %s");
#line 462
      tmp___7 = __errno_location();
#line 462
      error(0, *tmp___7, (char const   *)tmp___6, listed_incremental_option);
#line 462
      exit_status = 2;
      }
#line 463
      return;
    }
  }
#line 465
  if (! fp) {
#line 466
    return;
  }
  {
#line 467
  fgets((char */* __restrict  */)(buf), (int )sizeof(buf), (FILE */* __restrict  */)fp);
  }
#line 474
  if (! after_date_option) {
    {
#line 476
    newer_mtime_option = atol((char const   *)(buf));
#line 477
    after_date_option = 1;
    }
  }
  {
#line 480
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 480
    tmp___13 = fgets((char */* __restrict  */)(buf), (int )sizeof(buf), (FILE */* __restrict  */)fp);
    }
#line 480
    if (! tmp___13) {
#line 480
      goto while_break;
    }
    {
#line 485
    tmp___9 = strlen((char const   *)(buf));
#line 485
    strp = & buf[tmp___9];
    }
#line 486
    if ((int )*(strp + -1) == 10) {
#line 487
      *(strp + -1) = (char )'\000';
    }
    {
#line 491
    memset((void *)(& st), 0, (size_t )sizeof(st));
#line 492
    strp = buf;
#line 493
    l = atol((char const   *)strp);
#line 493
    st.st_dev = (__dev_t )l;
    }
#line 494
    if (st.st_dev != (__dev_t )l) {
      {
#line 495
      tmp___10 = gettext("Device number out of range");
#line 495
      error(0, 0, (char const   *)tmp___10);
#line 495
      exit_status = 2;
      }
    }
    {
#line 496
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 496
      if (! ((unsigned int )*strp - 48U <= 9U)) {
#line 496
        goto while_break___0;
      }
#line 497
      strp ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 498
    l = atol((char const   *)strp);
#line 498
    st.st_ino = (__ino64_t )l;
    }
#line 499
    if (st.st_ino != (__ino64_t )l) {
      {
#line 500
      tmp___11 = gettext("Inode number out of range");
#line 500
      error(0, 0, (char const   *)tmp___11);
#line 500
      exit_status = 2;
      }
    }
    {
#line 501
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 501
      tmp___12 = __ctype_b_loc();
      }
#line 501
      if (! ((int const   )*(*tmp___12 + (int )((unsigned char )*strp)) & 8192)) {
#line 501
        goto while_break___1;
      }
#line 502
      strp ++;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 503
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 503
      if (! ((unsigned int )*strp - 48U <= 9U)) {
#line 503
        goto while_break___2;
      }
#line 504
      strp ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 505
    strp ++;
#line 506
    unquote_string(strp);
#line 507
    note_directory(strp, & st, (char const   *)((void *)0));
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 509
  tmp___15 = fclose(fp);
  }
#line 509
  if (tmp___15 == -1) {
    {
#line 510
    tmp___14 = __errno_location();
#line 510
    error(0, *tmp___14, "%s", listed_incremental_option);
#line 510
    exit_status = 2;
    }
  }
#line 511
  return;
}
}
#line 517 "incremen.c"
void write_dir_file(void) 
{ 
  FILE *fp ;
  struct directory *directory ;
  char *str ;
  char *tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;

  {
  {
#line 524
  fp = fopen((char const   */* __restrict  */)listed_incremental_option, (char const   */* __restrict  */)"w");
  }
#line 525
  if ((unsigned long )fp == (unsigned long )((FILE *)0)) {
    {
#line 527
    tmp = gettext("Cannot write to %s");
#line 527
    tmp___0 = __errno_location();
#line 527
    error(0, *tmp___0, (char const   *)tmp, listed_incremental_option);
#line 527
    exit_status = 2;
    }
#line 528
    return;
  }
  {
#line 530
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"%lu\n", (unsigned long )time_now);
#line 531
  directory = directory_list;
  }
  {
#line 531
  while (1) {
    while_continue: /* CIL Label */ ;
#line 531
    if (! directory) {
#line 531
      goto while_break;
    }
#line 533
    if (! directory->dir_text) {
#line 534
      goto __Cont;
    }
    {
#line 535
    str = quote_copy_string(directory->name);
    }
#line 536
    if (str) {
      {
#line 538
      fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"%lu %lu %s\n",
              (unsigned long )directory->device_number, (unsigned long )directory->inode_number,
              str);
#line 542
      free((void *)str);
      }
    } else {
      {
#line 545
      fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"%lu %lu %s\n",
              (unsigned long )directory->device_number, (unsigned long )directory->inode_number,
              directory->name);
      }
    }
    __Cont: /* CIL Label */ 
#line 531
    directory = directory->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 550
  tmp___2 = fclose(fp);
  }
#line 550
  if (tmp___2 == -1) {
    {
#line 551
    tmp___1 = __errno_location();
#line 551
    error(0, *tmp___1, "%s", listed_incremental_option);
#line 551
    exit_status = 2;
    }
  }
#line 552
  return;
}
}
#line 558 "incremen.c"
static int compare_names(char *param1 , char *param2 ) 
{ 
  struct name *n1 ;
  struct name *n2 ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 561
  n1 = (struct name *)param1;
#line 562
  n2 = (struct name *)param2;
#line 564
  if (n1->found) {
#line 565
    if (n2->found) {
      {
#line 565
      tmp = strcmp((char const   *)(n1->name), (char const   *)(n2->name));
#line 565
      tmp___0 = tmp;
      }
    } else {
#line 565
      tmp___0 = -1;
    }
#line 565
    return (tmp___0);
  }
#line 567
  if (n2->found) {
#line 568
    return (1);
  }
  {
#line 570
  tmp___1 = strcmp((char const   *)(n1->name), (char const   *)(n2->name));
  }
#line 570
  return (tmp___1);
}
}
#line 578 "incremen.c"
void collect_and_sort_names(void) 
{ 
  struct name *name ;
  struct name *next_name ;
  int num_names ;
  struct stat statbuf ;
  char *tmp ;
  int *tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  int *tmp___3 ;
  int tmp___4 ;
  char *tmp___5 ;

  {
  {
#line 586
  name_gather();
  }
#line 588
  if (listed_incremental_option) {
    {
#line 589
    read_directory_file();
    }
  }
#line 591
  if (! namelist) {
    {
#line 592
    addname(".");
    }
  }
#line 594
  name = namelist;
  {
#line 594
  while (1) {
    while_continue: /* CIL Label */ ;
#line 594
    if (! name) {
#line 594
      goto while_break;
    }
#line 596
    next_name = name->next;
#line 597
    if (name->found) {
#line 598
      goto __Cont;
    } else
#line 597
    if (name->dir_contents) {
#line 598
      goto __Cont;
    }
#line 599
    if (name->regexp) {
#line 600
      goto __Cont;
    }
#line 601
    if (name->change_dir) {
      {
#line 602
      tmp___1 = chdir((char const   *)name->change_dir);
      }
#line 602
      if (tmp___1 < 0) {
        {
#line 604
        tmp = gettext("Cannot chdir to %s");
#line 604
        tmp___0 = __errno_location();
#line 604
        error(0, *tmp___0, (char const   *)tmp, name->change_dir);
#line 604
        exit_status = 2;
        }
#line 605
        goto __Cont;
      }
    }
    {
#line 608
    tmp___4 = lstat((char const   */* __restrict  */)(name->name), (struct stat */* __restrict  */)(& statbuf));
    }
#line 608
    if (tmp___4 < 0) {
      {
#line 616
      tmp___2 = gettext("Cannot stat %s");
#line 616
      tmp___3 = __errno_location();
#line 616
      error(0, *tmp___3, (char const   *)tmp___2, name->name);
#line 616
      exit_status = 2;
      }
#line 617
      goto __Cont;
    }
#line 619
    if ((statbuf.st_mode & 61440U) == 16384U) {
      {
#line 621
      name->found = (char)1;
#line 622
      add_hierarchy_to_namelist(name->name, statbuf.st_dev);
      }
    }
    __Cont: /* CIL Label */ 
#line 594
    name = next_name;
  }
  while_break: /* CIL Label */ ;
  }
#line 626
  num_names = 0;
#line 627
  name = namelist;
  {
#line 627
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 627
    if (! name) {
#line 627
      goto while_break___0;
    }
#line 628
    num_names ++;
#line 627
    name = name->next;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 629
  tmp___5 = merge_sort((char *)((void *)namelist), num_names, (int )((char *)(& namelist->next) - (char *)namelist),
                       & compare_names);
#line 629
  namelist = (struct name *)tmp___5;
#line 634
  name = namelist;
  }
  {
#line 634
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 634
    if (! name) {
#line 634
      goto while_break___1;
    }
#line 635
    name->found = (char)0;
#line 634
    name = name->next;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 637
  if (listed_incremental_option) {
    {
#line 638
    write_dir_file();
    }
  }
#line 639
  return;
}
}
#line 647 "incremen.c"
void gnu_restore(int skipcrud ) 
{ 
  char *current_dir ;
  char *archive_dir ;
  struct accumulator *accumulator ;
  char *p ;
  DIR *dirp ;
  struct dirent *d ;
  char *cur ;
  char *arc ;
  off_t size ;
  size_t copied ;
  union block *data_block ;
  char *to ;
  int tmp ;
  size_t tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  void *tmp___3 ;
  char *tmp___4 ;
  size_t tmp___5 ;
  size_t tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  int *tmp___11 ;
  int tmp___12 ;

  {
  {
#line 664
  dirp = opendir((char const   *)(current_file_name + skipcrud));
  }
#line 666
  if (! dirp) {
    {
#line 671
    skip_file(current_stat.st_size);
    }
#line 672
    return;
  }
  {
#line 675
  accumulator = new_accumulator();
  }
  {
#line 676
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 676
    d = readdir(dirp);
    }
#line 676
    if (! d) {
#line 676
      goto while_break;
    }
    {
#line 678
    tmp = is_dot_or_dotdot((char const   *)(d->d_name));
    }
#line 678
    if (tmp) {
#line 679
      goto while_continue;
    }
    {
#line 681
    tmp___0 = strlen((char const   *)(d->d_name));
#line 681
    add_to_accumulator(accumulator, (char const   *)(d->d_name), tmp___0 + 1U);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 683
  closedir(dirp);
#line 684
  add_to_accumulator(accumulator, "", (size_t )1);
#line 686
  current_dir = get_accumulator(accumulator);
#line 687
  size = current_stat.st_size;
  }
#line 688
  if (size != current_stat.st_size) {
    {
#line 689
    tmp___1 = gettext("Memory exhausted");
#line 689
    error(0, 0, (char const   *)tmp___1);
#line 689
    tmp___2 = gettext("Error is not recoverable: exiting now");
#line 689
    error(2, 0, (char const   *)tmp___2);
    }
  }
  {
#line 690
  tmp___3 = xmalloc((size_t )size);
#line 690
  archive_dir = (char *)tmp___3;
#line 691
  to = archive_dir;
  }
  {
#line 692
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 692
    if (! (size > 0LL)) {
#line 692
      goto while_break___0;
    }
    {
#line 694
    data_block = find_next_block();
    }
#line 695
    if (! data_block) {
      {
#line 697
      tmp___4 = gettext("Unexpected EOF in archive");
#line 697
      error(0, 0, (char const   *)tmp___4);
#line 697
      exit_status = 2;
      }
#line 698
      goto while_break___0;
    }
    {
#line 700
    copied = available_space_after(data_block);
    }
#line 701
    if ((off_t )copied > size) {
#line 702
      copied = (size_t )size;
    }
    {
#line 703
    memcpy((void */* __restrict  */)to, (void const   */* __restrict  */)(data_block->buffer),
           copied);
#line 704
    to += copied;
#line 705
    set_next_block_after((union block *)((data_block->buffer + copied) - 1));
#line 692
    size -= (off_t )copied;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 709
  cur = current_dir;
  {
#line 709
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 709
    if (! *cur) {
#line 709
      goto while_break___1;
    }
#line 711
    arc = archive_dir;
    {
#line 711
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 711
      if (! *arc) {
#line 711
        goto while_break___2;
      }
      {
#line 713
      arc ++;
#line 714
      tmp___7 = strcmp((char const   *)arc, (char const   *)cur);
      }
#line 714
      if (! tmp___7) {
#line 715
        goto while_break___2;
      }
      {
#line 711
      tmp___6 = strlen((char const   *)arc);
#line 711
      arc += tmp___6 + 1U;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
#line 717
    if ((int )*arc == 0) {
      {
#line 719
      p = new_name((char const   *)(current_file_name + skipcrud), (char const   *)cur);
      }
#line 720
      if (interactive_option) {
        {
#line 720
        tmp___8 = confirm("delete", (char const   *)p);
        }
#line 720
        if (! tmp___8) {
          {
#line 722
          free((void *)p);
          }
#line 723
          goto __Cont;
        }
      }
#line 725
      if (verbose_option) {
        {
#line 726
        tmp___9 = gettext("%s: Deleting %s\n");
#line 726
        fprintf((FILE */* __restrict  */)stdlis, (char const   */* __restrict  */)tmp___9,
                program_name, p);
        }
      }
      {
#line 727
      tmp___12 = remove_any_file((char const   *)p, 1);
      }
#line 727
      if (! tmp___12) {
        {
#line 728
        tmp___10 = gettext("Error while deleting %s");
#line 728
        tmp___11 = __errno_location();
#line 728
        error(0, *tmp___11, (char const   *)tmp___10, p);
#line 728
        exit_status = 2;
        }
      }
      {
#line 729
      free((void *)p);
      }
    }
    __Cont: /* CIL Label */ 
    {
#line 709
    tmp___5 = strlen((char const   *)cur);
#line 709
    cur += tmp___5 + 1U;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 733
  delete_accumulator(accumulator);
#line 734
  free((void *)archive_dir);
  }
#line 737
  return;
}
}
#line 255 "/usr/include/sys/stat.h"
extern int chmod(char const   *__file , __mode_t __mode ) ;
#line 281
extern int mkdir(char const   *__path , __mode_t __mode ) ;
#line 293
extern int mkfifo(char const   *__path , __mode_t __mode ) ;
#line 289 "/usr/include/unistd.h"
extern __off64_t lseek(int __fd , __off64_t __offset , int __whence )  __asm__("lseek64")  ;
#line 418
extern int chown(char const   *__file , __uid_t __owner , __gid_t __group ) ;
#line 428
extern int lchown(char const   *__file , __uid_t __owner , __gid_t __group ) ;
#line 616
extern __uid_t geteuid(void) ;
#line 722
extern int link(char const   *__from , char const   *__to ) ;
#line 46 "/usr/include/utime.h"
extern int utime(char const   *__file , struct utimbuf  const  *__file_times ) ;
#line 36 "extract.c"
static time_t now  ;
#line 37 "extract.c"
static int we_are_root  ;
#line 38 "extract.c"
static mode_t newdir_umask  ;
#line 39 "extract.c"
static mode_t current_umask  ;
#line 57 "extract.c"
static struct delayed_set_stat *delayed_set_stat_head  ;
#line 63 "extract.c"
void extr_init(void) 
{ 
  __uid_t tmp ;

  {
  {
#line 66
  now = time((time_t *)0);
#line 67
  tmp = geteuid();
#line 67
  we_are_root = tmp == 0U;
#line 73
  newdir_umask = umask((__mode_t )0);
  }
#line 74
  if (same_permissions_option) {
#line 75
    current_umask = (mode_t )0;
  } else {
    {
#line 78
    umask(newdir_umask);
#line 79
    current_umask = newdir_umask;
    }
  }
#line 84
  newdir_umask &= 4294967103U;
#line 85
  return;
}
}
#line 91 "extract.c"
static void set_mode(char *file_name , struct stat *stat_info ) 
{ 
  char *tmp ;
  int *tmp___0 ;
  int tmp___1 ;

  {
#line 104
  if (! keep_old_files_option) {
#line 104
    goto _L;
  } else
#line 104
  if (stat_info->st_mode & 3584U) {
    _L: /* CIL Label */ 
    {
#line 106
    tmp___1 = chmod((char const   *)file_name, ~ current_umask & stat_info->st_mode);
    }
#line 106
    if (tmp___1 < 0) {
      {
#line 107
      tmp = gettext("%s: Cannot change mode to %04lo");
#line 107
      tmp___0 = __errno_location();
#line 107
      error(0, *tmp___0, (char const   *)tmp, file_name, (unsigned long )(~ current_umask & stat_info->st_mode));
#line 107
      exit_status = 2;
      }
    }
  }
#line 110
  return;
}
}
#line 123 "extract.c"
static void set_stat(char *file_name , struct stat *stat_info , int symlink_flag ) 
{ 
  struct utimbuf utimbuf ;
  char *tmp ;
  int *tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  int *tmp___3 ;
  int tmp___4 ;
  char *tmp___5 ;
  int *tmp___6 ;
  int tmp___7 ;

  {
#line 128
  if (! symlink_flag) {
#line 133
    if (! touch_option) {
#line 141
      if (incremental_option) {
#line 142
        utimbuf.actime = stat_info->st_atim.tv_sec;
      } else {
#line 144
        utimbuf.actime = now;
      }
      {
#line 146
      utimbuf.modtime = stat_info->st_mtim.tv_sec;
#line 148
      tmp___1 = utime((char const   *)file_name, (struct utimbuf  const  *)(& utimbuf));
      }
#line 148
      if (tmp___1 < 0) {
        {
#line 149
        tmp = gettext("%s: Could not change access and modification times");
#line 149
        tmp___0 = __errno_location();
#line 149
        error(0, *tmp___0, (char const   *)tmp, file_name);
#line 149
        exit_status = 2;
        }
      }
    }
    {
#line 158
    set_mode(file_name, stat_info);
    }
  }
#line 165
  if (we_are_root) {
#line 165
    goto _L;
  } else
#line 165
  if (same_owner_option) {
    _L: /* CIL Label */ 
#line 174
    if (symlink_flag) {
      {
#line 176
      tmp___4 = lchown((char const   *)file_name, stat_info->st_uid, stat_info->st_gid);
      }
#line 176
      if (tmp___4 < 0) {
        {
#line 177
        tmp___2 = gettext("%s: Cannot lchown to uid %lu gid %lu");
#line 177
        tmp___3 = __errno_location();
#line 177
        error(0, *tmp___3, (char const   *)tmp___2, file_name, (unsigned long )stat_info->st_uid,
              (unsigned long )stat_info->st_gid);
#line 177
        exit_status = 2;
        }
      }
    } else {
      {
#line 184
      tmp___7 = chown((char const   *)file_name, stat_info->st_uid, stat_info->st_gid);
      }
#line 184
      if (tmp___7 < 0) {
        {
#line 185
        tmp___5 = gettext("%s: Cannot chown to uid %lu gid %lu");
#line 185
        tmp___6 = __errno_location();
#line 185
        error(0, *tmp___6, (char const   *)tmp___5, file_name, (unsigned long )stat_info->st_uid,
              (unsigned long )stat_info->st_gid);
#line 185
        exit_status = 2;
        }
      }
    }
#line 203
    if (! symlink_flag) {
#line 209
      if (stat_info->st_mode & 3584U) {
        {
#line 210
        set_mode(file_name, stat_info);
        }
      }
    }
  }
#line 212
  return;
}
}
#line 220 "extract.c"
static int make_directories(char *file_name ) 
{ 
  char *cursor ;
  int did_something ;
  int saved_errno ;
  int *tmp ;
  int status ;
  char *tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;
  int *tmp___3 ;
  int *tmp___4 ;

  {
  {
#line 224
  did_something = 0;
#line 225
  tmp = __errno_location();
#line 225
  saved_errno = *tmp;
#line 228
  cursor = strchr((char const   *)file_name, '/');
  }
  {
#line 228
  while (1) {
    while_continue: /* CIL Label */ ;
#line 228
    if (! ((unsigned long )cursor != (unsigned long )((void *)0))) {
#line 228
      goto while_break;
    }
#line 234
    if ((unsigned long )cursor == (unsigned long )file_name) {
#line 235
      goto __Cont;
    } else
#line 234
    if ((int )*(cursor + -1) == 47) {
#line 235
      goto __Cont;
    }
#line 239
    if ((int )*(cursor + -1) == 46) {
#line 239
      if ((unsigned long )cursor == (unsigned long )(file_name + 1)) {
#line 240
        goto __Cont;
      } else
#line 239
      if ((int )*(cursor + -2) == 47) {
#line 240
        goto __Cont;
      }
    }
    {
#line 242
    *cursor = (char )'\000';
#line 243
    status = mkdir((char const   *)file_name, ~ newdir_umask & (unsigned int )(((64 | (64 >> 3)) | ((64 >> 3) >> 3)) | (((128 | (128 >> 3)) | ((128 >> 3) >> 3)) | ((256 | (256 >> 3)) | ((256 >> 3) >> 3)))));
    }
#line 245
    if (status == 0) {
#line 249
      if (we_are_root) {
        {
#line 250
        tmp___2 = chown((char const   *)file_name, current_stat.st_uid, current_stat.st_gid);
        }
#line 250
        if (tmp___2 < 0) {
          {
#line 251
          tmp___0 = gettext("%s: Cannot change owner to uid %lu, gid %lu");
#line 251
          tmp___1 = __errno_location();
#line 251
          error(0, *tmp___1, (char const   *)tmp___0, file_name, (unsigned long )current_stat.st_uid,
                (unsigned long )current_stat.st_gid);
#line 251
          exit_status = 2;
          }
        }
      }
      {
#line 257
      print_for_mkdir(file_name, (int )(cursor - file_name), ~ newdir_umask & (unsigned int )(((64 | (64 >> 3)) | ((64 >> 3) >> 3)) | (((128 | (128 >> 3)) | ((128 >> 3) >> 3)) | ((256 | (256 >> 3)) | ((256 >> 3) >> 3)))));
#line 259
      did_something = 1;
#line 261
      *cursor = (char )'/';
      }
#line 262
      goto __Cont;
    }
    {
#line 265
    *cursor = (char )'/';
#line 267
    tmp___3 = __errno_location();
    }
#line 267
    if (*tmp___3 == 17) {
#line 274
      goto __Cont;
    }
#line 277
    goto while_break;
    __Cont: /* CIL Label */ 
    {
#line 228
    cursor = strchr((char const   *)(cursor + 1), '/');
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 280
  tmp___4 = __errno_location();
#line 280
  *tmp___4 = saved_errno;
  }
#line 281
  return (did_something);
}
}
#line 291 "extract.c"
static int maybe_recoverable(char *file_name ) 
{ 
  int *tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 294
  tmp = __errno_location();
  }
  {
#line 296
  if (*tmp == 17) {
#line 296
    goto case_17;
  }
#line 305
  if (*tmp == 2) {
#line 305
    goto case_2;
  }
#line 310
  goto switch_default;
  case_17: /* CIL Label */ 
#line 300
  if (keep_old_files_option) {
#line 301
    return (0);
  }
  {
#line 303
  tmp___0 = remove_any_file((char const   *)file_name, 0);
  }
#line 303
  return (tmp___0);
  case_2: /* CIL Label */ 
  {
#line 308
  tmp___1 = make_directories(file_name);
  }
#line 308
  return (tmp___1);
  switch_default: /* CIL Label */ 
#line 313
  return (0);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 321 "extract.c"
static void extract_sparse_file(int fd , off_t *sizeleft , off_t totalsize , char *name ) 
{ 
  int sparse_ind ;
  size_t written ;
  ssize_t count ;
  union block *data_block ;
  union block *tmp ;
  char *tmp___0 ;
  char buf[(((sizeof(uintmax_t ) * 8UL) * 302UL) / 1000UL + 1UL) + 1UL] ;
  char *tmp___1 ;
  char *tmp___2 ;
  int *tmp___3 ;
  __off64_t tmp___4 ;
  int tmp___5 ;
  char *tmp___6 ;
  int *tmp___7 ;
  char *tmp___8 ;
  int *tmp___9 ;
  char buf1[(((sizeof(uintmax_t ) * 8UL) * 302UL) / 1000UL + 1UL) + 1UL] ;
  char buf2[(((sizeof(uintmax_t ) * 8UL) * 302UL) / 1000UL + 1UL) + 1UL] ;
  char *tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;

  {
#line 324
  sparse_ind = 0;
  {
#line 330
  while (1) {
    while_continue: /* CIL Label */ ;
#line 330
    if (! (*sizeleft > 0LL)) {
#line 330
      goto while_break;
    }
    {
#line 332
    tmp = find_next_block();
#line 332
    data_block = tmp;
    }
#line 333
    if ((unsigned long )data_block == (unsigned long )((void *)0)) {
      {
#line 335
      tmp___0 = gettext("Unexpected EOF on archive file");
#line 335
      error(0, 0, (char const   *)tmp___0);
#line 335
      exit_status = 2;
      }
#line 336
      return;
    }
    {
#line 338
    tmp___4 = lseek(fd, (sparsearray + sparse_ind)->offset, 0);
    }
#line 338
    if (tmp___4 < 0LL) {
      {
#line 341
      tmp___1 = stringify_uintmax_t_backwards((uintmax_t )(sparsearray + sparse_ind)->offset,
                                              buf + sizeof(buf));
#line 341
      tmp___2 = gettext("%s: lseek error at byte %s");
#line 341
      tmp___3 = __errno_location();
#line 341
      error(0, *tmp___3, (char const   *)tmp___2, tmp___1, name);
#line 341
      exit_status = 2;
      }
#line 344
      return;
    }
#line 346
    tmp___5 = sparse_ind;
#line 346
    sparse_ind ++;
#line 346
    written = (sparsearray + tmp___5)->numbytes;
    {
#line 347
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 347
      if (! (written > 512U)) {
#line 347
        goto while_break___0;
      }
      {
#line 349
      count = full_write(fd, (char const   *)(data_block->buffer), (size_t )512);
      }
#line 350
      if (count < 0) {
        {
#line 351
        tmp___6 = gettext("%s: Could not write to file");
#line 351
        tmp___7 = __errno_location();
#line 351
        error(0, *tmp___7, (char const   *)tmp___6, name);
#line 351
        exit_status = 2;
        }
      }
      {
#line 352
      written -= (size_t )count;
#line 353
      *sizeleft -= (off_t )count;
#line 354
      set_next_block_after(data_block);
#line 355
      data_block = find_next_block();
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 358
    count = full_write(fd, (char const   *)(data_block->buffer), written);
    }
#line 360
    if (count < 0) {
      {
#line 361
      tmp___8 = gettext("%s: Could not write to file");
#line 361
      tmp___9 = __errno_location();
#line 361
      error(0, *tmp___9, (char const   *)tmp___8, name);
#line 361
      exit_status = 2;
      }
    } else
#line 362
    if ((size_t )count != written) {
      {
#line 366
      tmp___10 = stringify_uintmax_t_backwards((uintmax_t )totalsize, buf2 + sizeof(buf2));
#line 366
      tmp___11 = stringify_uintmax_t_backwards((uintmax_t )(totalsize - *sizeleft),
                                               buf1 + sizeof(buf1));
#line 366
      tmp___12 = gettext("%s: Could only write %s of %s bytes");
#line 366
      error(0, 0, (char const   *)tmp___12, name, tmp___11, tmp___10);
#line 366
      exit_status = 2;
#line 370
      skip_file(*sizeleft);
      }
    }
    {
#line 373
    written -= (size_t )count;
#line 374
    *sizeleft -= (off_t )count;
#line 375
    set_next_block_after(data_block);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 378
  free((void *)sparsearray);
  }
#line 379
  return;
}
}
#line 428 "extract.c"
static int warned_once  =    0;
#line 580 "extract.c"
static int conttype_diagnosed  =    0;
#line 385 "extract.c"
void extract_archive(void) 
{ 
  union block *data_block ;
  int fd ;
  int status ;
  ssize_t sstatus ;
  size_t name_length ;
  size_t written ;
  int openflag ;
  off_t size ;
  int skipcrud ;
  int counter ;
  char typeflag ;
  union block *exhdr ;
  struct delayed_set_stat *data ;
  int tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  int *tmp___2 ;
  int tmp___3 ;
  void *tmp___4 ;
  int ind ;
  void *tmp___5 ;
  size_t tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  char *tmp___9 ;
  int tmp___10 ;
  char *tmp___11 ;
  int *tmp___12 ;
  char *name ;
  size_t name_length_bis ;
  size_t tmp___13 ;
  void *tmp___14 ;
  char *tmp___15 ;
  int *tmp___16 ;
  char *tmp___17 ;
  int *tmp___18 ;
  char *tmp___19 ;
  char *tmp___20 ;
  int *tmp___21 ;
  int tmp___22 ;
  char *tmp___23 ;
  int *tmp___24 ;
  struct stat st1 ;
  struct stat st2 ;
  int tmp___25 ;
  int *tmp___26 ;
  int tmp___27 ;
  int tmp___28 ;
  char *tmp___29 ;
  int *tmp___30 ;
  int tmp___31 ;
  char *tmp___32 ;
  int *tmp___33 ;
  int tmp___34 ;
  char *tmp___35 ;
  int *tmp___36 ;
  size_t tmp___37 ;
  size_t tmp___38 ;
  int tmp___39 ;
  struct stat st1___0 ;
  int saved_errno ;
  int *tmp___40 ;
  int tmp___41 ;
  int *tmp___42 ;
  int *tmp___43 ;
  int tmp___44 ;
  char *tmp___45 ;
  int *tmp___46 ;
  char *tmp___47 ;
  void *tmp___48 ;
  char *tmp___49 ;
  char *tmp___50 ;
  char *tmp___51 ;
  char *tmp___52 ;

  {
  {
#line 407
  set_next_block_after(current_header);
#line 408
  decode_header(current_header, & current_stat, & current_format, 1);
  }
#line 410
  if (interactive_option) {
    {
#line 410
    tmp = confirm("extract", (char const   *)current_file_name);
    }
#line 410
    if (! tmp) {
#line 412
      if (current_header->oldgnu_header.isextended) {
        {
#line 413
        skip_extended_headers();
        }
      }
      {
#line 414
      skip_file(current_stat.st_size);
      }
#line 415
      return;
    }
  }
#line 420
  if (verbose_option) {
    {
#line 421
    print_header();
    }
  }
#line 425
  skipcrud = 0;
  {
#line 426
  while (1) {
    while_continue: /* CIL Label */ ;
#line 426
    if (! absolute_names_option) {
#line 426
      if (! ((int )*((current_file_name + skipcrud) + 0) == 47)) {
#line 426
        goto while_break;
      }
    } else {
#line 426
      goto while_break;
    }
#line 430
    skipcrud ++;
#line 431
    if (! warned_once) {
      {
#line 433
      warned_once = 1;
#line 434
      tmp___0 = gettext("Removing leading `/\' from absolute path names in the archive");
#line 434
      error(0, 0, (char const   *)tmp___0);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 441
  if (backup_option) {
#line 441
    if (! to_stdout_option) {
      {
#line 442
      tmp___3 = maybe_backup_file((char const   *)(current_file_name + skipcrud),
                                  0);
      }
#line 442
      if (! tmp___3) {
        {
#line 444
        tmp___1 = gettext("%s: Was unable to backup this file");
#line 444
        tmp___2 = __errno_location();
#line 444
        error(0, *tmp___2, (char const   *)tmp___1, current_file_name + skipcrud);
#line 444
        exit_status = 2;
        }
#line 446
        if (current_header->oldgnu_header.isextended) {
          {
#line 447
          skip_extended_headers();
          }
        }
        {
#line 448
        skip_file(current_stat.st_size);
        }
#line 449
        return;
      }
    }
  }
#line 454
  typeflag = current_header->header.typeflag;
  {
#line 471
  if ((int )typeflag == 83) {
#line 471
    goto case_83;
  }
#line 532
  if ((int )typeflag == 55) {
#line 532
    goto case_55;
  }
#line 532
  if ((int )typeflag == 48) {
#line 532
    goto case_55;
  }
#line 532
  if ((int )typeflag == 0) {
#line 532
    goto case_55;
  }
#line 695
  if ((int )typeflag == 50) {
#line 695
    goto case_50;
  }
#line 741
  if ((int )typeflag == 49) {
#line 741
    goto case_49;
  }
#line 777
  if ((int )typeflag == 51) {
#line 777
    goto case_51;
  }
#line 783
  if ((int )typeflag == 52) {
#line 783
    goto case_52;
  }
#line 812
  if ((int )typeflag == 54) {
#line 812
    goto case_54;
  }
#line 836
  if ((int )typeflag == 68) {
#line 836
    goto case_68;
  }
#line 836
  if ((int )typeflag == 53) {
#line 836
    goto case_68;
  }
#line 944
  if ((int )typeflag == 86) {
#line 944
    goto case_86;
  }
#line 949
  if ((int )typeflag == 78) {
#line 949
    goto case_78;
  }
#line 953
  if ((int )typeflag == 77) {
#line 953
    goto case_77;
  }
#line 963
  if ((int )typeflag == 75) {
#line 963
    goto case_75;
  }
#line 963
  if ((int )typeflag == 76) {
#line 963
    goto case_75;
  }
#line 970
  goto switch_default;
  case_83: /* CIL Label */ 
  {
#line 472
  sp_array_size = 10;
#line 473
  tmp___4 = xmalloc((size_t )((unsigned long )sp_array_size * sizeof(struct sp_array )));
#line 473
  sparsearray = (struct sp_array *)tmp___4;
#line 476
  counter = 0;
  }
  {
#line 476
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 476
    if (! (counter < 4)) {
#line 476
      goto while_break___0;
    }
    {
#line 478
    (sparsearray + counter)->offset = off_from_oct((char const   *)(current_header->oldgnu_header.sp[counter].offset),
                                                   (size_t )sizeof(current_header->oldgnu_header.sp[counter].offset));
#line 480
    (sparsearray + counter)->numbytes = size_from_oct((char const   *)(current_header->oldgnu_header.sp[counter].numbytes),
                                                      (size_t )sizeof(current_header->oldgnu_header.sp[counter].numbytes));
    }
#line 482
    if (! (sparsearray + counter)->numbytes) {
#line 483
      goto while_break___0;
    }
#line 476
    counter ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 486
  if (current_header->oldgnu_header.isextended) {
#line 492
    ind = 4;
    {
#line 494
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 496
      exhdr = find_next_block();
#line 497
      counter = 0;
      }
      {
#line 497
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 497
        if (! (counter < 21)) {
#line 497
          goto while_break___2;
        }
#line 499
        if (counter + ind > sp_array_size - 1) {
          {
#line 504
          sp_array_size *= 2;
#line 505
          tmp___5 = xrealloc((void *)sparsearray, (size_t )((unsigned long )sp_array_size * sizeof(struct sp_array )));
#line 505
          sparsearray = (struct sp_array *)tmp___5;
          }
        }
#line 511
        if ((unsigned long )(exhdr->sparse_header.sp[counter].numbytes) == (unsigned long )((char *)0)) {
#line 512
          goto while_break___2;
        }
        {
#line 513
        (sparsearray + (counter + ind))->offset = off_from_oct((char const   *)(exhdr->sparse_header.sp[counter].offset),
                                                               (size_t )sizeof(exhdr->sparse_header.sp[counter].offset));
#line 515
        (sparsearray + (counter + ind))->numbytes = size_from_oct((char const   *)(exhdr->sparse_header.sp[counter].numbytes),
                                                                  (size_t )sizeof(exhdr->sparse_header.sp[counter].numbytes));
#line 497
        counter ++;
        }
      }
      while_break___2: /* CIL Label */ ;
      }
#line 518
      if (! exhdr->sparse_header.isextended) {
#line 519
        goto while_break___1;
      } else {
        {
#line 522
        ind += 21;
#line 523
        set_next_block_after(exhdr);
        }
      }
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 526
    set_next_block_after(exhdr);
    }
  }
  case_55: /* CIL Label */ 
  case_48: /* CIL Label */ 
  case_0: /* CIL Label */ 
  {
#line 537
  tmp___6 = strlen((char const   *)(current_file_name + skipcrud));
#line 537
  name_length = tmp___6 - 1U;
  }
#line 538
  if ((int )*((current_file_name + skipcrud) + name_length) == 47) {
#line 539
    goto really_dir;
  }
  again_file: 
#line 544
  if (keep_old_files_option) {
#line 544
    tmp___7 = 2241;
  } else {
#line 544
    tmp___7 = 2625;
  }
#line 544
  if ((int )typeflag == 83) {
#line 544
    tmp___8 = 0;
  } else {
#line 544
    tmp___8 = 1024;
  }
#line 544
  openflag = tmp___7 | tmp___8;
#line 558
  if (to_stdout_option) {
#line 560
    fd = 1;
#line 561
    goto extract_file;
  }
#line 564
  if (unlink_first_option) {
    {
#line 565
    remove_any_file((char const   *)(current_file_name + skipcrud), recursive_unlink_option);
    }
  }
#line 578
  if ((int )typeflag == 55) {
#line 582
    if (! conttype_diagnosed) {
      {
#line 584
      conttype_diagnosed = 1;
#line 585
      tmp___9 = gettext("Extracting contiguous files as regular files");
#line 585
      error(0, 0, (char const   *)tmp___9);
      }
    }
  }
  {
#line 588
  fd = open((char const   *)(current_file_name + skipcrud), openflag, current_stat.st_mode);
  }
#line 592
  if (fd < 0) {
    {
#line 594
    tmp___10 = maybe_recoverable(current_file_name + skipcrud);
    }
#line 594
    if (tmp___10) {
#line 595
      goto again_file;
    }
    {
#line 597
    tmp___11 = gettext("%s: Could not create file");
#line 597
    tmp___12 = __errno_location();
#line 597
    error(0, *tmp___12, (char const   *)tmp___11, current_file_name + skipcrud);
#line 597
    exit_status = 2;
    }
#line 599
    if (current_header->oldgnu_header.isextended) {
      {
#line 600
      skip_extended_headers();
      }
    }
    {
#line 601
    skip_file(current_stat.st_size);
    }
#line 602
    if (backup_option) {
      {
#line 603
      undo_last_backup();
      }
    }
#line 604
    goto switch_break;
  }
  extract_file: 
#line 608
  if ((int )typeflag == 83) {
    {
#line 619
    tmp___13 = strlen((char const   *)(current_file_name + skipcrud));
#line 619
    name_length_bis = tmp___13 + 1U;
#line 620
    tmp___14 = xmalloc(name_length_bis);
#line 620
    name = (char *)tmp___14;
#line 621
    memcpy((void */* __restrict  */)name, (void const   */* __restrict  */)(current_file_name + skipcrud),
           name_length_bis);
#line 622
    size = current_stat.st_size;
#line 623
    extract_sparse_file(fd, & size, current_stat.st_size, name);
    }
  } else {
#line 626
    size = current_stat.st_size;
    {
#line 626
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 626
      if (! (size > 0LL)) {
#line 626
        goto while_break___3;
      }
#line 630
      if (multi_volume_option) {
        {
#line 632
        assign_string(& save_name, (char const   *)current_file_name);
#line 633
        save_totsize = current_stat.st_size;
#line 634
        save_sizeleft = size;
        }
      }
      {
#line 641
      data_block = find_next_block();
      }
#line 642
      if ((unsigned long )data_block == (unsigned long )((void *)0)) {
        {
#line 644
        tmp___15 = gettext("Unexpected EOF on archive file");
#line 644
        error(0, 0, (char const   *)tmp___15);
#line 644
        exit_status = 2;
        }
#line 645
        goto while_break___3;
      }
      {
#line 648
      written = available_space_after(data_block);
      }
#line 650
      if ((off_t )written > size) {
#line 651
        written = (size_t )size;
      }
      {
#line 652
      tmp___16 = __errno_location();
#line 652
      *tmp___16 = 0;
#line 653
      sstatus = full_write(fd, (char const   *)(data_block->buffer), written);
#line 655
      set_next_block_after((union block *)((data_block->buffer + written) - 1));
      }
#line 657
      if ((size_t )sstatus == written) {
#line 658
        goto __Cont;
      }
#line 663
      if (sstatus < 0) {
        {
#line 664
        tmp___17 = gettext("%s: Could not write to file");
#line 664
        tmp___18 = __errno_location();
#line 664
        error(0, *tmp___18, (char const   *)tmp___17, current_file_name + skipcrud);
#line 664
        exit_status = 2;
        }
      } else {
        {
#line 667
        tmp___19 = gettext("%s: Could only write %lu of %lu bytes");
#line 667
        error(0, 0, (char const   *)tmp___19, current_file_name + skipcrud, (unsigned long )sstatus,
              (unsigned long )written);
#line 667
        exit_status = 2;
        }
      }
      {
#line 671
      skip_file(size - (off_t )written);
      }
#line 672
      goto while_break___3;
      __Cont: /* CIL Label */ 
#line 626
      size -= (off_t )written;
    }
    while_break___3: /* CIL Label */ ;
    }
  }
#line 675
  if (multi_volume_option) {
    {
#line 676
    assign_string(& save_name, (char const   *)((void *)0));
    }
  }
#line 681
  if (to_stdout_option) {
#line 682
    goto switch_break;
  }
  {
#line 684
  status = close(fd);
  }
#line 685
  if (status < 0) {
    {
#line 687
    tmp___20 = gettext("%s: Error while closing");
#line 687
    tmp___21 = __errno_location();
#line 687
    error(0, *tmp___21, (char const   *)tmp___20, current_file_name + skipcrud);
#line 687
    exit_status = 2;
    }
#line 688
    if (backup_option) {
      {
#line 689
      undo_last_backup();
      }
    }
  }
  {
#line 692
  set_stat(current_file_name + skipcrud, & current_stat, 0);
  }
#line 693
  goto switch_break;
  case_50: /* CIL Label */ 
#line 696
  if (to_stdout_option) {
#line 697
    goto switch_break;
  }
#line 700
  if (unlink_first_option) {
    {
#line 701
    remove_any_file((char const   *)(current_file_name + skipcrud), recursive_unlink_option);
    }
  }
  {
#line 703
  while (1) {
    while_continue___4: /* CIL Label */ ;
    {
#line 703
    status = symlink((char const   *)current_link_name, (char const   *)(current_file_name + skipcrud));
    }
#line 703
    if (! (status != 0)) {
#line 703
      goto while_break___4;
    }
    {
#line 705
    tmp___22 = maybe_recoverable(current_file_name + skipcrud);
    }
#line 705
    if (! tmp___22) {
#line 706
      goto while_break___4;
    }
  }
  while_break___4: /* CIL Label */ ;
  }
#line 708
  if (status == 0) {
    {
#line 715
    set_stat(current_file_name + skipcrud, & current_stat, 1);
    }
  } else {
    {
#line 719
    tmp___23 = gettext("%s: Could not create symlink to `%s\'");
#line 719
    tmp___24 = __errno_location();
#line 719
    error(0, *tmp___24, (char const   *)tmp___23, current_file_name + skipcrud, current_link_name);
#line 719
    exit_status = 2;
    }
#line 721
    if (backup_option) {
      {
#line 722
      undo_last_backup();
      }
    }
  }
#line 724
  goto switch_break;
  case_49: /* CIL Label */ 
#line 742
  if (to_stdout_option) {
#line 743
    goto switch_break;
  }
#line 745
  if (unlink_first_option) {
    {
#line 746
    remove_any_file((char const   *)(current_file_name + skipcrud), recursive_unlink_option);
    }
  }
  again_link: 
  {
#line 754
  status = link((char const   *)current_link_name, (char const   *)(current_file_name + skipcrud));
  }
#line 756
  if (status == 0) {
#line 757
    goto switch_break;
  }
  {
#line 758
  tmp___25 = maybe_recoverable(current_file_name + skipcrud);
  }
#line 758
  if (tmp___25) {
#line 759
    goto again_link;
  }
#line 761
  if (incremental_option) {
    {
#line 761
    tmp___26 = __errno_location();
    }
#line 761
    if (*tmp___26 == 17) {
#line 762
      goto switch_break;
    }
  }
  {
#line 763
  tmp___27 = stat((char const   */* __restrict  */)current_link_name, (struct stat */* __restrict  */)(& st1));
  }
#line 763
  if (tmp___27 == 0) {
    {
#line 763
    tmp___28 = stat((char const   */* __restrict  */)(current_file_name + skipcrud),
                    (struct stat */* __restrict  */)(& st2));
    }
#line 763
    if (tmp___28 == 0) {
#line 763
      if (st1.st_dev == st2.st_dev) {
#line 763
        if (st1.st_ino == st2.st_ino) {
#line 767
          goto switch_break;
        }
      }
    }
  }
  {
#line 769
  tmp___29 = gettext("%s: Could not link to `%s\'");
#line 769
  tmp___30 = __errno_location();
#line 769
  error(0, *tmp___30, (char const   *)tmp___29, current_file_name + skipcrud, current_link_name);
#line 769
  exit_status = 2;
  }
#line 771
  if (backup_option) {
    {
#line 772
    undo_last_backup();
    }
  }
#line 774
  goto switch_break;
  case_51: /* CIL Label */ 
#line 778
  current_stat.st_mode |= 8192U;
#line 779
  goto make_node;
  case_52: /* CIL Label */ 
#line 784
  current_stat.st_mode |= 24576U;
  make_node: 
#line 789
  if (to_stdout_option) {
#line 790
    goto switch_break;
  }
#line 792
  if (unlink_first_option) {
    {
#line 793
    remove_any_file((char const   *)(current_file_name + skipcrud), recursive_unlink_option);
    }
  }
  {
#line 795
  status = mknod((char const   *)(current_file_name + skipcrud), current_stat.st_mode,
                 current_stat.st_rdev);
  }
#line 797
  if (status != 0) {
    {
#line 799
    tmp___31 = maybe_recoverable(current_file_name + skipcrud);
    }
#line 799
    if (tmp___31) {
#line 800
      goto make_node;
    }
    {
#line 802
    tmp___32 = gettext("%s: Could not make node");
#line 802
    tmp___33 = __errno_location();
#line 802
    error(0, *tmp___33, (char const   *)tmp___32, current_file_name + skipcrud);
#line 802
    exit_status = 2;
    }
#line 803
    if (backup_option) {
      {
#line 804
      undo_last_backup();
      }
    }
#line 805
    goto switch_break;
  }
  {
#line 807
  set_stat(current_file_name + skipcrud, & current_stat, 0);
  }
#line 808
  goto switch_break;
  case_54: /* CIL Label */ 
#line 813
  if (to_stdout_option) {
#line 814
    goto switch_break;
  }
#line 816
  if (unlink_first_option) {
    {
#line 817
    remove_any_file((char const   *)(current_file_name + skipcrud), recursive_unlink_option);
    }
  }
  {
#line 819
  while (1) {
    while_continue___5: /* CIL Label */ ;
    {
#line 819
    status = mkfifo((char const   *)(current_file_name + skipcrud), current_stat.st_mode);
    }
#line 819
    if (! (status != 0)) {
#line 819
      goto while_break___5;
    }
    {
#line 821
    tmp___34 = maybe_recoverable(current_file_name + skipcrud);
    }
#line 821
    if (! tmp___34) {
#line 822
      goto while_break___5;
    }
  }
  while_break___5: /* CIL Label */ ;
  }
#line 824
  if (status == 0) {
    {
#line 825
    set_stat(current_file_name + skipcrud, & current_stat, 0);
    }
  } else {
    {
#line 828
    tmp___35 = gettext("%s: Could not make fifo");
#line 828
    tmp___36 = __errno_location();
#line 828
    error(0, *tmp___36, (char const   *)tmp___35, current_file_name + skipcrud);
#line 828
    exit_status = 2;
    }
#line 829
    if (backup_option) {
      {
#line 830
      undo_last_backup();
      }
    }
  }
#line 832
  goto switch_break;
  case_68: /* CIL Label */ 
  case_53: /* CIL Label */ 
  {
#line 837
  tmp___37 = strlen((char const   *)(current_file_name + skipcrud));
#line 837
  name_length = tmp___37 - 1U;
  }
  really_dir: 
  {
#line 841
  while (1) {
    while_continue___6: /* CIL Label */ ;
#line 841
    if (name_length) {
#line 841
      if (! ((int )*((current_file_name + skipcrud) + name_length) == 47)) {
#line 841
        goto while_break___6;
      }
    } else {
#line 841
      goto while_break___6;
    }
#line 842
    tmp___38 = name_length;
#line 842
    name_length --;
#line 842
    *((current_file_name + skipcrud) + tmp___38) = (char )'\000';
  }
  while_break___6: /* CIL Label */ ;
  }
#line 844
  if (incremental_option) {
    {
#line 849
    gnu_restore(skipcrud);
    }
  } else
#line 851
  if ((int )typeflag == 68) {
    {
#line 852
    skip_file(current_stat.st_size);
    }
  }
#line 854
  if (to_stdout_option) {
#line 855
    goto switch_break;
  }
  again_dir: 
#line 858
  if (we_are_root) {
#line 858
    tmp___39 = 0;
  } else {
#line 858
    tmp___39 = 192;
  }
  {
#line 858
  status = mkdir((char const   *)(current_file_name + skipcrud), (unsigned int )tmp___39 | current_stat.st_mode);
  }
#line 861
  if (status != 0) {
    {
#line 882
    tmp___43 = __errno_location();
    }
#line 882
    if (*tmp___43 == 17) {
      {
#line 885
      tmp___40 = __errno_location();
#line 885
      saved_errno = *tmp___40;
#line 887
      tmp___41 = stat((char const   */* __restrict  */)(current_file_name + skipcrud),
                      (struct stat */* __restrict  */)(& st1___0));
      }
#line 887
      if (tmp___41 == 0) {
#line 887
        if ((st1___0.st_mode & 61440U) == 16384U) {
#line 888
          goto check_perms;
        }
      }
      {
#line 890
      tmp___42 = __errno_location();
#line 890
      *tmp___42 = saved_errno;
      }
    }
    {
#line 893
    tmp___44 = maybe_recoverable(current_file_name + skipcrud);
    }
#line 893
    if (tmp___44) {
#line 894
      goto again_dir;
    }
#line 900
    if ((int )*((current_file_name + skipcrud) + name_length) == 46) {
#line 900
      if (name_length == 0U) {
#line 903
        goto check_perms;
      } else
#line 900
      if ((int )*((current_file_name + skipcrud) + (name_length - 1U)) == 47) {
#line 903
        goto check_perms;
      }
    }
    {
#line 905
    tmp___45 = gettext("%s: Could not create directory");
#line 905
    tmp___46 = __errno_location();
#line 905
    error(0, *tmp___46, (char const   *)tmp___45, current_file_name + skipcrud);
#line 905
    exit_status = 2;
    }
#line 907
    if (backup_option) {
      {
#line 908
      undo_last_backup();
      }
    }
#line 909
    goto switch_break;
  }
  check_perms: 
#line 913
  if (! we_are_root) {
#line 913
    if (192U != (192U & current_stat.st_mode)) {
      {
#line 915
      current_stat.st_mode |= 192U;
#line 916
      tmp___47 = gettext("Added write and execute permission to directory %s");
#line 916
      error(0, 0, (char const   *)tmp___47, current_file_name + skipcrud);
      }
    }
  }
#line 924
  if (touch_option) {
    {
#line 930
    set_mode(current_file_name + skipcrud, & current_stat);
    }
  } else {
    {
#line 934
    tmp___48 = xmalloc((size_t )sizeof(struct delayed_set_stat ));
#line 934
    data = (struct delayed_set_stat *)tmp___48;
#line 936
    data->file_name = xstrdup((char const   *)(current_file_name + skipcrud));
#line 937
    data->stat_info = current_stat;
#line 938
    data->next = delayed_set_stat_head;
#line 939
    delayed_set_stat_head = data;
    }
  }
#line 942
  goto switch_break;
  case_86: /* CIL Label */ 
#line 945
  if (verbose_option) {
    {
#line 946
    tmp___49 = gettext("Reading %s\n");
#line 946
    fprintf((FILE */* __restrict  */)stdlis, (char const   */* __restrict  */)tmp___49,
            current_file_name);
    }
  }
#line 947
  goto switch_break;
  case_78: /* CIL Label */ 
  {
#line 950
  extract_mangle();
  }
#line 951
  goto switch_break;
  case_77: /* CIL Label */ 
  {
#line 954
  tmp___50 = gettext("Cannot extract `%s\' -- file is continued from another volume");
#line 954
  error(0, 0, (char const   *)tmp___50, current_file_name);
#line 954
  exit_status = 2;
#line 957
  skip_file(current_stat.st_size);
  }
#line 958
  if (backup_option) {
    {
#line 959
    undo_last_backup();
    }
  }
#line 960
  goto switch_break;
  case_75: /* CIL Label */ 
  case_76: /* CIL Label */ 
  {
#line 964
  tmp___51 = gettext("Visible long name error");
#line 964
  error(0, 0, (char const   *)tmp___51);
#line 964
  exit_status = 2;
#line 965
  skip_file(current_stat.st_size);
  }
#line 966
  if (backup_option) {
    {
#line 967
    undo_last_backup();
    }
  }
#line 968
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 971
  tmp___52 = gettext("Unknown file type \'%c\' for %s, extracted as normal file");
#line 971
  error(0, 0, (char const   *)tmp___52, (int )typeflag, current_file_name + skipcrud);
  }
#line 974
  goto again_file;
  switch_break: /* CIL Label */ ;
  }
#line 978
  return;
}
}
#line 984 "extract.c"
void apply_delayed_set_stat(void) 
{ 
  struct delayed_set_stat *data ;

  {
  {
#line 989
  while (1) {
    while_continue: /* CIL Label */ ;
#line 989
    if (! ((unsigned long )delayed_set_stat_head != (unsigned long )((void *)0))) {
#line 989
      goto while_break;
    }
    {
#line 991
    data = delayed_set_stat_head;
#line 992
    delayed_set_stat_head = delayed_set_stat_head->next;
#line 993
    set_stat(data->file_name, & data->stat_info, 0);
#line 994
    free((void *)data->file_name);
#line 995
    free((void *)data);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 997
  return;
}
}
#line 56 "/usr/include/asm/ioctl.h"
extern unsigned int __invalid_size_argument_for_IOC ;
#line 42 "/usr/include/sys/ioctl.h"
extern int ioctl(int __fd , unsigned long __request  , ...) ;
#line 334 "common.h"
int write_archive_to_stdout ;
#line 341
void flush_read(void) ;
#line 342
void flush_write(void) ;
#line 343
void flush_archive(void) ;
#line 23 "delete.c"
static union block *new_record  =    (union block *)((void *)0);
#line 24 "delete.c"
static union block *save_record  =    (union block *)((void *)0);
#line 25 "delete.c"
static off_t records_read  =    (off_t )0;
#line 26 "delete.c"
static int new_blocks  =    0;
#line 27 "delete.c"
static int blocks_needed  =    0;
#line 31
union block *record_start ;
#line 32
union block *record_end ;
#line 42 "delete.c"
static void move_archive(off_t count ) 
{ 
  struct mtop operation ;
  int status ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  unsigned long tmp___3 ;
  int tmp___4 ;
  unsigned long tmp___5 ;
  int tmp___6 ;
  unsigned long tmp___7 ;
  int tmp___8 ;
  unsigned long tmp___9 ;
  int tmp___10 ;
  int *tmp___11 ;
  off_t position0 ;
  off_t tmp___12 ;
  __off64_t tmp___13 ;
  off_t tmp___14 ;
  off_t increment ;
  off_t position ;
  char *tmp___15 ;
  char *tmp___16 ;
  off_t tmp___17 ;
  __off64_t tmp___18 ;
  off_t tmp___19 ;

  {
#line 50
  if (count > 0LL) {
#line 52
    operation.mt_op = (short)3;
#line 53
    operation.mt_count = (int )count;
#line 54
    if ((off_t )operation.mt_count != count) {
      {
#line 55
      tmp = gettext("Could not re-position archive file");
#line 55
      error(0, 0, (char const   *)tmp);
#line 55
      tmp___0 = gettext("Error is not recoverable: exiting now");
#line 55
      error(2, 0, (char const   *)tmp___0);
      }
    }
  } else {
#line 59
    operation.mt_op = (short)4;
#line 60
    operation.mt_count = (int )(- count);
#line 61
    if ((off_t )operation.mt_count != - count) {
      {
#line 62
      tmp___1 = gettext("Could not re-position archive file");
#line 62
      error(0, 0, (char const   *)tmp___1);
#line 62
      tmp___2 = gettext("Error is not recoverable: exiting now");
#line 62
      error(2, 0, (char const   *)tmp___2);
      }
    }
  }
#line 65
  if (archive >= 128) {
#line 65
    if (sizeof(struct mtop ) == sizeof(struct mtop [1])) {
#line 65
      if (sizeof(struct mtop ) < (unsigned long )(1 << 14)) {
#line 65
        tmp___3 = sizeof(struct mtop );
      } else {
#line 65
        tmp___3 = (unsigned long )__invalid_size_argument_for_IOC;
      }
    } else {
#line 65
      tmp___3 = (unsigned long )__invalid_size_argument_for_IOC;
    }
    {
#line 65
    tmp___4 = rmt_ioctl__(archive - 128, (int )((unsigned long )(((1U << 30) | (unsigned int )(109 << 8)) | 1U) | (tmp___3 << 16)),
                          (char *)(& operation));
#line 65
    status = tmp___4;
    }
  } else {
#line 65
    if (sizeof(struct mtop ) == sizeof(struct mtop [1])) {
#line 65
      if (sizeof(struct mtop ) < (unsigned long )(1 << 14)) {
#line 65
        tmp___5 = sizeof(struct mtop );
      } else {
#line 65
        tmp___5 = (unsigned long )__invalid_size_argument_for_IOC;
      }
    } else {
#line 65
      tmp___5 = (unsigned long )__invalid_size_argument_for_IOC;
    }
    {
#line 65
    tmp___6 = ioctl(archive, (unsigned long )(((1U << 30) | (unsigned int )(109 << 8)) | 1U) | (tmp___5 << 16),
                    (char *)(& operation));
#line 65
    status = tmp___6;
    }
  }
#line 65
  if (status >= 0) {
#line 67
    return;
  }
  {
#line 69
  tmp___11 = __errno_location();
  }
#line 69
  if (*tmp___11 == 5) {
#line 70
    if (archive >= 128) {
#line 70
      if (sizeof(struct mtop ) == sizeof(struct mtop [1])) {
#line 70
        if (sizeof(struct mtop ) < (unsigned long )(1 << 14)) {
#line 70
          tmp___7 = sizeof(struct mtop );
        } else {
#line 70
          tmp___7 = (unsigned long )__invalid_size_argument_for_IOC;
        }
      } else {
#line 70
        tmp___7 = (unsigned long )__invalid_size_argument_for_IOC;
      }
      {
#line 70
      tmp___8 = rmt_ioctl__(archive - 128, (int )((unsigned long )(((1U << 30) | (unsigned int )(109 << 8)) | 1U) | (tmp___7 << 16)),
                            (char *)(& operation));
#line 70
      status = tmp___8;
      }
    } else {
#line 70
      if (sizeof(struct mtop ) == sizeof(struct mtop [1])) {
#line 70
        if (sizeof(struct mtop ) < (unsigned long )(1 << 14)) {
#line 70
          tmp___9 = sizeof(struct mtop );
        } else {
#line 70
          tmp___9 = (unsigned long )__invalid_size_argument_for_IOC;
        }
      } else {
#line 70
        tmp___9 = (unsigned long )__invalid_size_argument_for_IOC;
      }
      {
#line 70
      tmp___10 = ioctl(archive, (unsigned long )(((1U << 30) | (unsigned int )(109 << 8)) | 1U) | (tmp___9 << 16),
                       (char *)(& operation));
#line 70
      status = tmp___10;
      }
    }
#line 70
    if (status >= 0) {
#line 72
      return;
    }
  }
#line 77
  if (archive >= 128) {
    {
#line 77
    tmp___12 = rmt_lseek__(archive - 128, (off_t )0, 1);
#line 77
    tmp___14 = tmp___12;
    }
  } else {
    {
#line 77
    tmp___13 = lseek(archive, (off_t )0, 1);
#line 77
    tmp___14 = tmp___13;
    }
  }
#line 77
  position0 = tmp___14;
#line 78
  increment = (off_t )record_size * count;
#line 79
  position = position0 + increment;
#line 81
  if (increment / count != (off_t )record_size) {
    {
#line 84
    tmp___15 = gettext("Could not re-position archive file");
#line 84
    error(0, 0, (char const   *)tmp___15);
#line 84
    tmp___16 = gettext("Error is not recoverable: exiting now");
#line 84
    error(2, 0, (char const   *)tmp___16);
    }
  } else
#line 81
  if ((position < position0) != (increment < 0LL)) {
    {
#line 84
    tmp___15 = gettext("Could not re-position archive file");
#line 84
    error(0, 0, (char const   *)tmp___15);
#line 84
    tmp___16 = gettext("Error is not recoverable: exiting now");
#line 84
    error(2, 0, (char const   *)tmp___16);
    }
  } else {
#line 81
    if (archive >= 128) {
      {
#line 81
      tmp___17 = rmt_lseek__(archive - 128, position, 0);
#line 81
      tmp___19 = tmp___17;
      }
    } else {
      {
#line 81
      tmp___18 = lseek(archive, position, 0);
#line 81
      tmp___19 = tmp___18;
      }
    }
#line 81
    if (tmp___19 != position) {
      {
#line 84
      tmp___15 = gettext("Could not re-position archive file");
#line 84
      error(0, 0, (char const   *)tmp___15);
#line 84
      tmp___16 = gettext("Error is not recoverable: exiting now");
#line 84
      error(2, 0, (char const   *)tmp___16);
      }
    }
  }
#line 86
  return;
}
}
#line 95 "delete.c"
static void write_record(int move_back_flag ) 
{ 


  {
#line 98
  save_record = record_start;
#line 99
  record_start = new_record;
#line 101
  if (archive == 0) {
    {
#line 103
    archive = 1;
#line 104
    flush_write();
#line 105
    archive = 0;
    }
  } else {
    {
#line 109
    move_archive(- (records_read + 1LL));
#line 110
    flush_write();
    }
  }
#line 113
  record_start = save_record;
#line 115
  if (move_back_flag) {
#line 119
    if (archive != 0) {
      {
#line 120
      move_archive(records_read);
      }
    }
#line 122
    records_read --;
  }
#line 125
  blocks_needed = blocking_factor;
#line 126
  new_blocks = 0;
#line 127
  return;
}
}
#line 133 "delete.c"
void delete_archive_members(void) 
{ 
  enum read_header logical_status ;
  enum read_header previous_status ;
  struct name *name ;
  off_t blocks_to_skip ;
  off_t blocks_to_keep ;
  int kept_blocks_in_record ;
  enum read_header status ;
  enum read_header tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  void *tmp___2 ;
  enum read_header status___0 ;
  char *tmp___3 ;
  int count ;

  {
  {
#line 136
  logical_status = (enum read_header )0;
#line 137
  previous_status = (enum read_header )0;
#line 141
  blocks_to_skip = (off_t )0;
#line 142
  blocks_to_keep = (off_t )0;
#line 145
  name_gather();
#line 146
  open_archive((enum access_mode )2);
  }
  {
#line 148
  while (1) {
    while_continue: /* CIL Label */ ;
#line 148
    if (! ((unsigned int )logical_status == 0U)) {
#line 148
      goto while_break;
    }
    {
#line 150
    tmp = read_header();
#line 150
    status = tmp;
    }
    {
#line 154
    if ((unsigned int )status == 0U) {
#line 154
      goto case_0;
    }
#line 157
    if ((unsigned int )status == 1U) {
#line 157
      goto case_1;
    }
#line 171
    if ((unsigned int )status == 3U) {
#line 171
      goto case_3;
    }
#line 171
    if ((unsigned int )status == 2U) {
#line 171
      goto case_3;
    }
#line 175
    if ((unsigned int )status == 4U) {
#line 175
      goto case_4;
    }
#line 152
    goto switch_break;
    case_0: /* CIL Label */ 
    {
#line 155
    abort();
    }
    case_1: /* CIL Label */ 
    {
#line 158
    name = name_scan((char const   *)current_file_name);
    }
#line 158
    if (! name) {
      {
#line 160
      set_next_block_after(current_header);
      }
#line 161
      if (current_header->oldgnu_header.isextended) {
        {
#line 162
        skip_extended_headers();
        }
      }
      {
#line 163
      skip_file(current_stat.st_size);
      }
#line 164
      goto switch_break;
    }
#line 166
    name->found = (char)1;
#line 167
    logical_status = (enum read_header )1;
#line 168
    goto switch_break;
    case_3: /* CIL Label */ 
    case_2: /* CIL Label */ 
#line 172
    logical_status = (enum read_header )3;
#line 173
    goto switch_break;
    case_4: /* CIL Label */ 
    {
#line 176
    set_next_block_after(current_header);
    }
    {
#line 179
    if ((unsigned int )previous_status == 0U) {
#line 179
      goto case_0___0;
    }
#line 184
    if ((unsigned int )previous_status == 2U) {
#line 184
      goto case_2___0;
    }
#line 184
    if ((unsigned int )previous_status == 1U) {
#line 184
      goto case_2___0;
    }
#line 188
    if ((unsigned int )previous_status == 4U) {
#line 188
      goto case_4___0;
    }
#line 191
    if ((unsigned int )previous_status == 3U) {
#line 191
      goto case_3___0;
    }
#line 177
    goto switch_break___0;
    case_0___0: /* CIL Label */ 
    {
#line 180
    tmp___0 = gettext("This does not look like a tar archive");
#line 180
    error(0, 0, (char const   *)tmp___0);
    }
    case_2___0: /* CIL Label */ 
    case_1___0: /* CIL Label */ 
    {
#line 185
    tmp___1 = gettext("Skipping to next header");
#line 185
    error(0, 0, (char const   *)tmp___1);
#line 185
    exit_status = 2;
    }
    case_4___0: /* CIL Label */ 
#line 189
    goto switch_break___0;
    case_3___0: /* CIL Label */ 
    {
#line 192
    abort();
    }
    switch_break___0: /* CIL Label */ ;
    }
#line 194
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 197
    previous_status = status;
  }
  while_break: /* CIL Label */ ;
  }
#line 200
  if ((unsigned int )logical_status != 1U) {
    {
#line 202
    write_eot();
#line 203
    close_archive();
#line 204
    names_notfound();
    }
#line 205
    return;
  }
  {
#line 208
  write_archive_to_stdout = 0;
#line 209
  tmp___2 = xmalloc(record_size);
#line 209
  new_record = (union block *)tmp___2;
#line 213
  new_blocks = (int )(current_block - record_start);
#line 214
  blocks_needed = blocking_factor - new_blocks;
  }
#line 215
  if (new_blocks) {
    {
#line 216
    memcpy((void */* __restrict  */)((void *)new_record), (void const   */* __restrict  */)((void *)record_start),
           (size_t )(new_blocks * 512));
    }
  }
#line 226
  logical_status = (enum read_header )0;
#line 227
  goto flush_file;
  {
#line 232
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 238
    if ((unsigned long )current_block == (unsigned long )record_end) {
      {
#line 240
      flush_archive();
#line 241
      records_read ++;
      }
    }
    {
#line 243
    status___0 = read_header();
    }
#line 245
    if ((unsigned int )status___0 == 2U) {
#line 245
      if (ignore_zeros_option) {
        {
#line 247
        set_next_block_after(current_header);
        }
#line 248
        goto while_continue___0;
      }
    }
#line 250
    if ((unsigned int )status___0 == 3U) {
#line 250
      goto _L;
    } else
#line 250
    if ((unsigned int )status___0 == 2U) {
      _L: /* CIL Label */ 
      {
#line 252
      logical_status = (enum read_header )3;
#line 253
      memset((void *)((new_record + new_blocks)->buffer), 0, (size_t )(512 * blocks_needed));
#line 255
      new_blocks += blocks_needed;
#line 256
      blocks_needed = 0;
#line 257
      write_record(0);
      }
#line 258
      goto while_break___0;
    }
#line 261
    if ((unsigned int )status___0 == 4U) {
      {
#line 263
      tmp___3 = gettext("Deleting non-header from archive");
#line 263
      error(0, 0, (char const   *)tmp___3);
#line 263
      exit_status = 2;
#line 264
      set_next_block_after(current_header);
      }
#line 265
      goto while_continue___0;
    }
    {
#line 270
    name = name_scan((char const   *)current_file_name);
    }
#line 270
    if (name) {
#line 272
      name->found = (char)1;
      flush_file: 
      {
#line 274
      set_next_block_after(current_header);
#line 275
      blocks_to_skip = ((current_stat.st_size + 512LL) - 1LL) / 512LL;
      }
      {
#line 277
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 277
        if (! ((off_t )(record_end - current_block) <= blocks_to_skip)) {
#line 277
          goto while_break___1;
        }
        {
#line 279
        blocks_to_skip -= (off_t )(record_end - current_block);
#line 280
        flush_archive();
#line 281
        records_read ++;
        }
      }
      while_break___1: /* CIL Label */ ;
      }
#line 283
      current_block += blocks_to_skip;
#line 284
      blocks_to_skip = (off_t )0;
#line 285
      goto while_continue___0;
    }
    {
#line 290
    *(new_record + new_blocks) = *current_header;
#line 291
    new_blocks ++;
#line 292
    blocks_needed --;
#line 293
    blocks_to_keep = ((current_stat.st_size + 512LL) - 1LL) / 512LL;
#line 295
    set_next_block_after(current_header);
    }
#line 296
    if (blocks_needed == 0) {
      {
#line 297
      write_record(1);
      }
    }
#line 301
    kept_blocks_in_record = (int )(record_end - current_block);
#line 302
    if ((off_t )kept_blocks_in_record > blocks_to_keep) {
#line 303
      kept_blocks_in_record = (int )blocks_to_keep;
    }
    {
#line 305
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 305
      if (! blocks_to_keep) {
#line 305
        goto while_break___2;
      }
#line 309
      if ((unsigned long )current_block == (unsigned long )record_end) {
        {
#line 311
        flush_read();
#line 312
        records_read ++;
#line 313
        current_block = record_start;
#line 314
        kept_blocks_in_record = blocking_factor;
        }
#line 315
        if ((off_t )kept_blocks_in_record > blocks_to_keep) {
#line 316
          kept_blocks_in_record = (int )blocks_to_keep;
        }
      }
#line 318
      count = kept_blocks_in_record;
#line 319
      if (count > blocks_needed) {
#line 320
        count = blocks_needed;
      }
      {
#line 322
      memcpy((void */* __restrict  */)((void *)(new_record + new_blocks)), (void const   */* __restrict  */)((void *)current_block),
             (size_t )(count * 512));
#line 325
      new_blocks += count;
#line 326
      blocks_needed -= count;
#line 327
      current_block += count;
#line 328
      blocks_to_keep -= (off_t )count;
#line 329
      kept_blocks_in_record -= count;
      }
#line 331
      if (blocks_needed == 0) {
        {
#line 332
        write_record(1);
        }
      }
    }
    while_break___2: /* CIL Label */ ;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 336
  write_eot();
#line 337
  close_archive();
#line 338
  names_notfound();
  }
}
}
#line 256 "/usr/include/unistd.h"
extern int access(char const   *__name , int __type ) ;
#line 731
extern int readlink(char const   * __restrict  __path , char * __restrict  __buf ,
                    size_t __len ) ;
#line 355 "common.h"
void finish_header(union block *header ) ;
#line 368
void gid_to_oct(gid_t v , char *p , size_t s ) ;
#line 369
void major_to_oct(int v , char *p , size_t s ) ;
#line 370
void minor_to_oct(int v , char *p , size_t s ) ;
#line 371
void mode_to_oct(mode_t v , char *p , size_t s ) ;
#line 372
void off_to_oct(off_t v , char *p , size_t s ) ;
#line 373
void size_to_oct(size_t v , char *p , size_t s ) ;
#line 374
void time_to_oct(time_t v , char *p , size_t s ) ;
#line 375
void uid_to_oct(uid_t v , char *p , size_t s ) ;
#line 376
void uintmax_to_oct(uintmax_t v , char *p , size_t s ) ;
#line 39 "create.c"
dev_t ar_dev ;
#line 40
ino_t ar_ino ;
#line 56 "create.c"
struct link *linklist  =    (struct link *)((void *)0);
#line 74 "create.c"
static void to_oct(uintmax_t value , uintmax_t substitute , char *where , size_t size ,
                   char const   *type ) 
{ 
  uintmax_t v ;
  size_t i ;
  uintmax_t tmp ;
  uintmax_t maxval ;
  uintmax_t tmp___0 ;
  char buf1[(((sizeof(uintmax_t ) * 8UL) * 302UL) / 1000UL + 1UL) + 1UL] ;
  char buf2[(((sizeof(uintmax_t ) * 8UL) * 302UL) / 1000UL + 1UL) + 1UL] ;
  char buf3[(((sizeof(uintmax_t ) * 8UL) * 302UL) / 1000UL + 1UL) + 1UL] ;
  char *value_string ;
  char *tmp___1 ;
  char *maxval_string ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;

  {
#line 77
  v = value;
#line 78
  i = size;
#line 86
  if ((unsigned long )((size - 1U) * 3U) < sizeof(uintmax_t ) * 8UL) {
#line 86
    tmp = (1ULL << (size - 1U) * 3U) - 1ULL;
  } else {
#line 86
    tmp = (uintmax_t )-1;
  }
#line 86
  if (value <= tmp) {
#line 87
    i --;
#line 87
    *(where + i) = (char )'\000';
  }
  {
#line 91
  while (1) {
    while_continue: /* CIL Label */ ;
#line 93
    i --;
#line 93
    *(where + i) = (char )(48 + (int )(v & 7ULL));
#line 94
    v >>= 3;
#line 91
    if (i != 0U) {
#line 91
      if (! (v != 0ULL)) {
#line 91
        goto while_break;
      }
    } else {
#line 91
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 99
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 99
    if (! (i != 0U)) {
#line 99
      goto while_break___0;
    }
#line 100
    i --;
#line 100
    *(where + i) = (char )'0';
  }
  while_break___0: /* CIL Label */ ;
  }
#line 102
  if (v != 0ULL) {
#line 104
    if ((unsigned long )(size * 3U) < sizeof(uintmax_t ) * 8UL) {
#line 104
      tmp___0 = (1ULL << size * 3U) - 1ULL;
    } else {
#line 104
      tmp___0 = (uintmax_t )-1;
    }
    {
#line 104
    maxval = tmp___0;
#line 108
    tmp___1 = stringify_uintmax_t_backwards(value, buf1 + sizeof(buf1));
#line 108
    value_string = tmp___1;
#line 109
    tmp___2 = stringify_uintmax_t_backwards(maxval, buf2 + sizeof(buf2));
#line 109
    maxval_string = tmp___2;
    }
#line 110
    if (substitute) {
      {
#line 112
      substitute &= maxval;
#line 113
      tmp___3 = stringify_uintmax_t_backwards(substitute, buf3 + sizeof(buf3));
#line 113
      tmp___4 = gettext("%s value %s too large (max=%s); substituting %s");
#line 113
      error(0, 0, (char const   *)tmp___4, type, value_string, maxval_string, tmp___3);
#line 116
      to_oct(substitute, (uintmax_t )0, where, size, type);
      }
    } else {
      {
#line 119
      tmp___5 = gettext("%s value %s too large (max=%s)");
#line 119
      error(0, 0, (char const   *)tmp___5, type, value_string, maxval_string);
#line 119
      exit_status = 2;
      }
    }
  }
#line 122
  return;
}
}
#line 126 "create.c"
void gid_to_oct(gid_t v , char *p , size_t s ) 
{ 


  {
  {
#line 129
  to_oct((uintmax_t )v, (uintmax_t )0, p, s, "gid_t");
  }
#line 130
  return;
}
}
#line 131 "create.c"
void major_to_oct(int v , char *p , size_t s ) 
{ 


  {
  {
#line 134
  to_oct((uintmax_t )v, (uintmax_t )0, p, s, "major_t");
  }
#line 135
  return;
}
}
#line 136 "create.c"
void minor_to_oct(int v , char *p , size_t s ) 
{ 


  {
  {
#line 139
  to_oct((uintmax_t )v, (uintmax_t )0, p, s, "minor_t");
  }
#line 140
  return;
}
}
#line 141 "create.c"
void mode_to_oct(mode_t v , char *p , size_t s ) 
{ 
  uintmax_t u ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  mode_t tmp___11 ;

  {
#line 148
  if (256 >> 3 == 32) {
#line 148
    if (128 >> 3 == 16) {
#line 148
      if (64 >> 3 == 8) {
#line 148
        if ((256 >> 3) >> 3 == 4) {
#line 148
          if ((128 >> 3) >> 3 == 2) {
#line 148
            if ((64 >> 3) >> 3 == 1) {
#line 148
              tmp___11 = v;
            } else {
#line 148
              goto _L___3;
            }
          } else {
#line 148
            goto _L___3;
          }
        } else {
#line 148
          goto _L___3;
        }
      } else {
#line 148
        goto _L___3;
      }
    } else {
#line 148
      goto _L___3;
    }
  } else {
    _L___3: /* CIL Label */ 
#line 148
    if (v & 2048U) {
#line 148
      tmp = 2048;
    } else {
#line 148
      tmp = 0;
    }
#line 148
    if (v & 1024U) {
#line 148
      tmp___0 = 1024;
    } else {
#line 148
      tmp___0 = 0;
    }
#line 148
    if (v & 512U) {
#line 148
      tmp___1 = 512;
    } else {
#line 148
      tmp___1 = 0;
    }
#line 148
    if (v & 256U) {
#line 148
      tmp___2 = 256;
    } else {
#line 148
      tmp___2 = 0;
    }
#line 148
    if (v & 128U) {
#line 148
      tmp___3 = 128;
    } else {
#line 148
      tmp___3 = 0;
    }
#line 148
    if (v & 64U) {
#line 148
      tmp___4 = 64;
    } else {
#line 148
      tmp___4 = 0;
    }
#line 148
    if (v & (unsigned int )(256 >> 3)) {
#line 148
      tmp___5 = 32;
    } else {
#line 148
      tmp___5 = 0;
    }
#line 148
    if (v & (unsigned int )(128 >> 3)) {
#line 148
      tmp___6 = 16;
    } else {
#line 148
      tmp___6 = 0;
    }
#line 148
    if (v & (unsigned int )(64 >> 3)) {
#line 148
      tmp___7 = 8;
    } else {
#line 148
      tmp___7 = 0;
    }
#line 148
    if (v & (unsigned int )((256 >> 3) >> 3)) {
#line 148
      tmp___8 = 4;
    } else {
#line 148
      tmp___8 = 0;
    }
#line 148
    if (v & (unsigned int )((128 >> 3) >> 3)) {
#line 148
      tmp___9 = 2;
    } else {
#line 148
      tmp___9 = 0;
    }
#line 148
    if (v & (unsigned int )((64 >> 3) >> 3)) {
#line 148
      tmp___10 = 1;
    } else {
#line 148
      tmp___10 = 0;
    }
#line 148
    tmp___11 = (mode_t )(((((((((((tmp | tmp___0) | tmp___1) | tmp___2) | tmp___3) | tmp___4) | tmp___5) | tmp___6) | tmp___7) | tmp___8) | tmp___9) | tmp___10);
  }
  {
#line 148
  u = (uintmax_t )tmp___11;
#line 166
  to_oct(u, (uintmax_t )0, p, s, "mode_t");
  }
#line 167
  return;
}
}
#line 168 "create.c"
void off_to_oct(off_t v , char *p , size_t s ) 
{ 


  {
  {
#line 171
  to_oct((uintmax_t )v, (uintmax_t )0, p, s, "off_t");
  }
#line 172
  return;
}
}
#line 173 "create.c"
void size_to_oct(size_t v , char *p , size_t s ) 
{ 


  {
  {
#line 176
  to_oct((uintmax_t )v, (uintmax_t )0, p, s, "size_t");
  }
#line 177
  return;
}
}
#line 178 "create.c"
void time_to_oct(time_t v , char *p , size_t s ) 
{ 


  {
  {
#line 181
  to_oct((uintmax_t )v, (uintmax_t )0, p, s, "time_t");
  }
#line 182
  return;
}
}
#line 186 "create.c"
void uid_to_oct(uid_t v , char *p , size_t s ) 
{ 


  {
  {
#line 189
  to_oct((uintmax_t )v, (uintmax_t )0, p, s, "uid_t");
  }
#line 190
  return;
}
}
#line 191 "create.c"
void uintmax_to_oct(uintmax_t v , char *p , size_t s ) 
{ 


  {
  {
#line 194
  to_oct(v, (uintmax_t )0, p, s, "uintmax_t");
  }
#line 195
  return;
}
}
#line 204 "create.c"
static void clear_buffer(char *buffer___1 ) 
{ 


  {
  {
#line 207
  memset((void *)buffer___1, 0, (size_t )512);
  }
#line 208
  return;
}
}
#line 216 "create.c"
void write_eot(void) 
{ 
  union block *pointer ;
  union block *tmp ;
  size_t space ;
  size_t tmp___0 ;

  {
  {
#line 219
  tmp = find_next_block();
#line 219
  pointer = tmp;
  }
#line 221
  if (pointer) {
    {
#line 223
    tmp___0 = available_space_after(pointer);
#line 223
    space = tmp___0;
#line 225
    memset((void *)(pointer->buffer), 0, space);
#line 226
    set_next_block_after(pointer);
    }
  }
#line 228
  return;
}
}
#line 236
static union block *start_header(char const   *name , struct stat *st ) ;
#line 238 "create.c"
static void write_long(char const   *p , char type ) 
{ 
  size_t size ;
  size_t tmp ;
  size_t bufsize ;
  union block *header ;
  struct stat foo ;

  {
  {
#line 241
  tmp = strlen(p);
#line 241
  size = tmp + 1U;
#line 246
  memset((void *)(& foo), 0, (size_t )sizeof(foo));
#line 247
  foo.st_size = (__off64_t )size;
#line 249
  header = start_header("././@LongLink", & foo);
#line 250
  header->header.typeflag = type;
#line 251
  finish_header(header);
#line 253
  header = find_next_block();
#line 255
  bufsize = available_space_after(header);
  }
  {
#line 257
  while (1) {
    while_continue: /* CIL Label */ ;
#line 257
    if (! (bufsize < size)) {
#line 257
      goto while_break;
    }
    {
#line 259
    memcpy((void */* __restrict  */)(header->buffer), (void const   */* __restrict  */)p,
           bufsize);
#line 260
    p += bufsize;
#line 261
    size -= bufsize;
#line 262
    set_next_block_after(header + (bufsize - 1U) / 512U);
#line 263
    header = find_next_block();
#line 264
    bufsize = available_space_after(header);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 266
  memcpy((void */* __restrict  */)(header->buffer), (void const   */* __restrict  */)p,
         size);
#line 267
  memset((void *)(header->buffer + size), 0, bufsize - size);
#line 268
  set_next_block_after(header + (size - 1U) / 512U);
  }
#line 269
  return;
}
}
#line 285 "create.c"
static int warned_once___0  =    0;
#line 278 "create.c"
static union block *start_header(char const   *name , struct stat *st ) 
{ 
  union block *header ;
  char *tmp ;
  size_t tmp___0 ;
  mode_t tmp___1 ;

  {
#line 283
  if (! absolute_names_option) {
    {
#line 299
    while (1) {
      while_continue: /* CIL Label */ ;
#line 299
      if (! ((int const   )*name == 47)) {
#line 299
        goto while_break;
      }
#line 301
      name ++;
#line 302
      if (! warned_once___0) {
        {
#line 304
        warned_once___0 = 1;
#line 305
        tmp = gettext("Removing leading `/\' from absolute path names in the archive");
#line 305
        error(0, 0, (char const   *)tmp);
        }
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 313
  tmp___0 = strlen(name);
  }
#line 313
  if (tmp___0 >= 100U) {
    {
#line 314
    write_long(name, (char )'L');
    }
  }
  {
#line 315
  header = find_next_block();
#line 316
  memset((void *)(header->buffer), 0, (size_t )sizeof(union block ));
#line 318
  assign_string(& current_file_name, name);
#line 320
  strncpy((char */* __restrict  */)(header->header.name), (char const   */* __restrict  */)name,
          (size_t )100);
#line 321
  header->header.name[99] = (char )'\000';
  }
#line 325
  if (owner_option != 4294967295U) {
#line 326
    st->st_uid = owner_option;
  }
#line 327
  if (group_option != 4294967295U) {
#line 328
    st->st_gid = group_option;
  }
#line 329
  if (mode_option) {
    {
#line 330
    tmp___1 = mode_adjust(st->st_mode, (struct mode_change  const  *)mode_option);
#line 330
    st->st_mode = (st->st_mode & 61440U) | tmp___1;
    }
  }
#line 356
  if ((unsigned int )archive_format == 1U) {
    {
#line 357
    mode_to_oct(st->st_mode & (unsigned int )(3584 | (((64 | (64 >> 3)) | ((64 >> 3) >> 3)) | (((128 | (128 >> 3)) | ((128 >> 3) >> 3)) | ((256 | (256 >> 3)) | ((256 >> 3) >> 3))))),
                header->header.mode, (size_t )sizeof(header->header.mode));
    }
  } else {
    {
#line 359
    mode_to_oct(st->st_mode, header->header.mode, (size_t )sizeof(header->header.mode));
    }
  }
  {
#line 361
  uid_to_oct(st->st_uid, header->header.uid, (size_t )sizeof(header->header.uid));
#line 362
  gid_to_oct(st->st_gid, header->header.gid, (size_t )sizeof(header->header.gid));
#line 363
  off_to_oct(st->st_size, header->header.size, (size_t )sizeof(header->header.size));
#line 364
  time_to_oct(st->st_mtim.tv_sec, header->header.mtime, (size_t )sizeof(header->header.mtime));
  }
#line 366
  if (incremental_option) {
#line 367
    if ((unsigned int )archive_format == 2U) {
      {
#line 369
      time_to_oct(st->st_atim.tv_sec, header->oldgnu_header.atime, (size_t )sizeof(header->oldgnu_header.atime));
#line 370
      time_to_oct(st->st_ctim.tv_sec, header->oldgnu_header.ctime, (size_t )sizeof(header->oldgnu_header.ctime));
      }
    }
  }
#line 373
  if ((unsigned int )archive_format == 1U) {
#line 373
    header->header.typeflag = (char )'\000';
  } else {
#line 373
    header->header.typeflag = (char )'0';
  }
  {
#line 378
  if ((unsigned int )archive_format == 1U) {
#line 378
    goto case_1;
  }
#line 378
  if ((unsigned int )archive_format == 0U) {
#line 378
    goto case_1;
  }
#line 381
  if ((unsigned int )archive_format == 2U) {
#line 381
    goto case_2;
  }
#line 387
  if ((unsigned int )archive_format == 4U) {
#line 387
    goto case_4;
  }
#line 387
  if ((unsigned int )archive_format == 3U) {
#line 387
    goto case_4;
  }
#line 375
  goto switch_break;
  case_1: /* CIL Label */ 
  case_0: /* CIL Label */ 
#line 379
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 383
  strcpy((char */* __restrict  */)(header->header.magic), (char const   */* __restrict  */)"ustar  ");
  }
#line 384
  goto switch_break;
  case_4: /* CIL Label */ 
  case_3: /* CIL Label */ 
  {
#line 388
  strncpy((char */* __restrict  */)(header->header.magic), (char const   */* __restrict  */)"ustar",
          (size_t )6);
#line 389
  strncpy((char */* __restrict  */)(header->header.version), (char const   */* __restrict  */)"00",
          (size_t )2);
  }
#line 390
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 393
  if (! ((unsigned int )archive_format == 1U)) {
#line 393
    if (! numeric_owner_option) {
      {
#line 399
      uid_to_uname(st->st_uid, (char *)(header->header.uname));
#line 400
      gid_to_gname(st->st_gid, (char *)(header->header.gname));
      }
    }
  }
#line 403
  return (header);
}
}
#line 411 "create.c"
void finish_header(union block *header ) 
{ 
  size_t i ;
  int sum ;
  char *p ;
  char *tmp ;
  size_t tmp___0 ;

  {
  {
#line 418
  memcpy((void */* __restrict  */)(header->header.chksum), (void const   */* __restrict  */)"        ",
         (size_t )sizeof(header->header.chksum));
#line 420
  sum = 0;
#line 421
  p = header->buffer;
#line 422
  i = (size_t )sizeof(*header);
  }
  {
#line 422
  while (1) {
    while_continue: /* CIL Label */ ;
#line 422
    tmp___0 = i;
#line 422
    i --;
#line 422
    if (! (tmp___0 != 0U)) {
#line 422
      goto while_break;
    }
#line 424
    tmp = p;
#line 424
    p ++;
#line 424
    sum += 255 & (int )*tmp;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 436
  uintmax_to_oct((uintmax_t )sum, header->header.chksum, (size_t )7);
#line 438
  set_next_block_after(header);
  }
#line 440
  if (verbose_option) {
#line 440
    if ((int )header->header.typeflag != 75) {
#line 440
      if ((int )header->header.typeflag != 76) {
        {
#line 446
        current_header = header;
#line 448
        current_format = archive_format;
#line 449
        print_header();
        }
      }
    }
  }
#line 451
  return;
}
}
#line 461 "create.c"
static int zero_block_p(char *buffer___1 ) 
{ 
  int counter ;

  {
#line 466
  counter = 0;
  {
#line 466
  while (1) {
    while_continue: /* CIL Label */ ;
#line 466
    if (! (counter < 512)) {
#line 466
      goto while_break;
    }
#line 467
    if ((int )*(buffer___1 + counter) != 0) {
#line 468
      return (0);
    }
#line 466
    counter ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 469
  return (1);
}
}
#line 476 "create.c"
static void init_sparsearray(void) 
{ 
  int counter ;
  void *tmp ;

  {
  {
#line 481
  sp_array_size = 10;
#line 485
  tmp = xmalloc((size_t )((unsigned long )sp_array_size * sizeof(struct sp_array )));
#line 485
  sparsearray = (struct sp_array *)tmp;
#line 487
  counter = 0;
  }
  {
#line 487
  while (1) {
    while_continue: /* CIL Label */ ;
#line 487
    if (! (counter < sp_array_size)) {
#line 487
      goto while_break;
    }
#line 489
    (sparsearray + counter)->offset = (off_t )0;
#line 490
    (sparsearray + counter)->numbytes = (size_t )0;
#line 487
    counter ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 492
  return;
}
}
#line 498 "create.c"
static void find_new_file_size(off_t *filesize , int highest_index ) 
{ 
  int counter ;

  {
#line 503
  *filesize = (off_t )0;
#line 504
  counter = 0;
  {
#line 504
  while (1) {
    while_continue: /* CIL Label */ ;
#line 504
    if ((sparsearray + counter)->numbytes) {
#line 504
      if (! (counter <= highest_index)) {
#line 504
        goto while_break;
      }
    } else {
#line 504
      goto while_break;
    }
#line 507
    *filesize += (off_t )(sparsearray + counter)->numbytes;
#line 504
    counter ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 508
  return;
}
}
#line 523 "create.c"
static int deal_with_sparse(char *name , union block *header ) 
{ 
  size_t numbytes ;
  off_t offset ;
  int file ;
  int sparse_index ;
  ssize_t count ;
  char buffer___1[512] ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 526
  numbytes = (size_t )0;
#line 527
  offset = (off_t )0;
#line 529
  sparse_index = 0;
#line 533
  if ((unsigned int )archive_format == 2U) {
#line 534
    header->oldgnu_header.isextended = (char)0;
  }
  {
#line 536
  file = open((char const   *)name, 0);
  }
#line 536
  if (file < 0) {
#line 538
    return (0);
  }
  {
#line 540
  init_sparsearray();
#line 541
  clear_buffer(buffer___1);
  }
  {
#line 543
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 543
    count = safe_read(file, (void *)(buffer___1), (size_t )sizeof(buffer___1));
    }
#line 543
    if (! (count != 0)) {
#line 543
      goto while_break;
    }
#line 548
    if (sparse_index > sp_array_size - 1) {
      {
#line 551
      tmp = xrealloc((void *)sparsearray, (size_t )((unsigned long )(2 * sp_array_size) * sizeof(struct sp_array )));
#line 551
      sparsearray = (struct sp_array *)tmp;
#line 554
      sp_array_size *= 2;
      }
    }
#line 559
    if ((unsigned long )count == sizeof(buffer___1)) {
      {
#line 561
      tmp___1 = zero_block_p(buffer___1);
      }
#line 561
      if (tmp___1) {
#line 563
        if (numbytes) {
#line 565
          tmp___0 = sparse_index;
#line 565
          sparse_index ++;
#line 565
          (sparsearray + tmp___0)->numbytes = numbytes;
#line 566
          numbytes = (size_t )0;
        }
      } else {
#line 571
        if (! numbytes) {
#line 572
          (sparsearray + sparse_index)->offset = offset;
        }
#line 573
        numbytes += (size_t )count;
      }
    } else {
      {
#line 580
      tmp___2 = zero_block_p(buffer___1);
      }
#line 580
      if (tmp___2) {
#line 593
        if (numbytes) {
#line 594
          numbytes += (size_t )count;
        }
      } else {
#line 582
        if (! numbytes) {
#line 583
          (sparsearray + sparse_index)->offset = offset;
        }
#line 584
        numbytes += (size_t )count;
      }
    }
    {
#line 598
    offset += (off_t )count;
#line 600
    clear_buffer(buffer___1);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 603
  if (numbytes) {
#line 604
    tmp___3 = sparse_index;
#line 604
    sparse_index ++;
#line 604
    (sparsearray + tmp___3)->numbytes = numbytes;
  } else {
#line 607
    (sparsearray + sparse_index)->offset = offset - 1LL;
#line 608
    tmp___4 = sparse_index;
#line 608
    sparse_index ++;
#line 608
    (sparsearray + tmp___4)->numbytes = (size_t )1;
  }
  {
#line 611
  close(file);
  }
#line 612
  return (sparse_index - 1);
}
}
#line 619 "create.c"
static int finish_sparse_file(int file , off_t *sizeleft , off_t fullsize , char *name ) 
{ 
  union block *start ;
  size_t bufsize ;
  int sparse_index ;
  ssize_t count ;
  char buf1[(((sizeof(uintmax_t ) * 8UL) * 302UL) / 1000UL + 1UL) + 1UL] ;
  char buf2[(((sizeof(uintmax_t ) * 8UL) * 302UL) / 1000UL + 1UL) + 1UL] ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char buf[(((sizeof(uintmax_t ) * 8UL) * 302UL) / 1000UL + 1UL) + 1UL] ;
  char *tmp___2 ;
  char *tmp___3 ;
  int *tmp___4 ;
  int tmp___5 ;
  __off64_t tmp___6 ;
  char buf___0[(((sizeof(uintmax_t ) * 8UL) * 302UL) / 1000UL + 1UL) + 1UL] ;
  char *tmp___7 ;
  char *tmp___8 ;
  int *tmp___9 ;
  char buffer___1[512] ;
  char buf___1[(((sizeof(uintmax_t ) * 8UL) * 302UL) / 1000UL + 1UL) + 1UL] ;
  char *tmp___10 ;
  char *tmp___11 ;
  int *tmp___12 ;

  {
#line 624
  sparse_index = 0;
  {
#line 627
  while (1) {
    while_continue: /* CIL Label */ ;
#line 627
    if (! (*sizeleft > 0LL)) {
#line 627
      goto while_break;
    }
    {
#line 629
    start = find_next_block();
#line 630
    memset((void *)(start->buffer), 0, (size_t )512);
#line 631
    bufsize = (sparsearray + sparse_index)->numbytes;
    }
#line 632
    if (! bufsize) {
      {
#line 638
      tmp = stringify_uintmax_t_backwards((uintmax_t )fullsize, buf2 + sizeof(buf2));
#line 638
      tmp___0 = stringify_uintmax_t_backwards((uintmax_t )(fullsize - *sizeleft),
                                              buf1 + sizeof(buf1));
#line 638
      tmp___1 = gettext("Wrote %s of %s bytes to file %s");
#line 638
      error(0, 0, (char const   *)tmp___1, tmp___0, tmp, name);
#line 638
      exit_status = 2;
      }
#line 642
      goto while_break;
    }
    {
#line 645
    tmp___5 = sparse_index;
#line 645
    sparse_index ++;
#line 645
    tmp___6 = lseek(file, (sparsearray + tmp___5)->offset, 0);
    }
#line 645
    if (tmp___6 < 0LL) {
      {
#line 648
      tmp___2 = stringify_uintmax_t_backwards((uintmax_t )(sparsearray + (sparse_index - 1))->offset,
                                              buf + sizeof(buf));
#line 648
      tmp___3 = gettext("lseek error at byte %s in file %s");
#line 648
      tmp___4 = __errno_location();
#line 648
      error(0, *tmp___4, (char const   *)tmp___3, tmp___2, name);
#line 648
      exit_status = 2;
      }
#line 651
      goto while_break;
    }
    {
#line 657
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 657
      if (! (bufsize > 512U)) {
#line 657
        goto while_break___0;
      }
      {
#line 673
      count = safe_read(file, (void *)(start->buffer), (size_t )512);
      }
#line 674
      if (count < 0) {
        {
#line 677
        tmp___7 = stringify_uintmax_t_backwards((uintmax_t )(fullsize - *sizeleft),
                                                buf___0 + sizeof(buf___0));
#line 677
        tmp___8 = gettext("Read error at byte %s, reading %lu bytes, in file %s");
#line 677
        tmp___9 = __errno_location();
#line 677
        error(0, *tmp___9, (char const   *)tmp___8, tmp___7, (unsigned long )bufsize,
              name);
#line 677
        exit_status = 2;
        }
#line 681
        return (1);
      }
      {
#line 683
      bufsize -= (size_t )count;
#line 684
      *sizeleft -= (off_t )count;
#line 685
      set_next_block_after(start);
#line 686
      start = find_next_block();
#line 687
      memset((void *)(start->buffer), 0, (size_t )512);
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 693
    clear_buffer(buffer___1);
#line 694
    count = safe_read(file, (void *)(buffer___1), bufsize);
#line 695
    memcpy((void */* __restrict  */)(start->buffer), (void const   */* __restrict  */)(buffer___1),
           (size_t )512);
    }
#line 698
    if (count < 0) {
      {
#line 702
      tmp___10 = stringify_uintmax_t_backwards((uintmax_t )(fullsize - *sizeleft),
                                               buf___1 + sizeof(buf___1));
#line 702
      tmp___11 = gettext("Read error at byte %s, reading %lu bytes, in file %s");
#line 702
      tmp___12 = __errno_location();
#line 702
      error(0, *tmp___12, (char const   *)tmp___11, tmp___10, (unsigned long )bufsize,
            name);
#line 702
      exit_status = 2;
      }
#line 706
      return (1);
    }
    {
#line 725
    *sizeleft -= (off_t )count;
#line 726
    set_next_block_after(start);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 729
  free((void *)sparsearray);
  }
#line 733
  return (0);
}
}
#line 742 "create.c"
void create_archive(void) 
{ 
  char *p ;
  char *buffer___1 ;
  void *tmp ;
  char const   *q ;
  char *bufp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;

  {
  {
#line 747
  open_archive((enum access_mode )1);
  }
#line 749
  if (incremental_option) {
    {
#line 751
    tmp = xmalloc((size_t )4096);
#line 751
    buffer___1 = (char *)tmp;
#line 755
    collect_and_sort_names();
    }
    {
#line 757
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 757
      p = name_from_list();
      }
#line 757
      if (! p) {
#line 757
        goto while_break;
      }
      {
#line 758
      dump_file(p, (dev_t )-1, 1);
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 760
    blank_name_list();
    }
    {
#line 761
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 761
      p = name_from_list();
      }
#line 761
      if (! p) {
#line 761
        goto while_break___0;
      }
      {
#line 763
      strcpy((char */* __restrict  */)buffer___1, (char const   */* __restrict  */)p);
#line 764
      tmp___0 = strlen((char const   *)p);
      }
#line 764
      if ((int )*(p + (tmp___0 - 1U)) != 47) {
        {
#line 765
        strcat((char */* __restrict  */)buffer___1, (char const   */* __restrict  */)"/");
        }
      }
      {
#line 766
      tmp___1 = strlen((char const   *)buffer___1);
#line 766
      bufp = buffer___1 + tmp___1;
#line 767
      q = gnu_list_name->dir_contents;
      }
      {
#line 767
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 767
        if (q) {
#line 767
          if (! *q) {
#line 767
            goto while_break___1;
          }
        } else {
#line 767
          goto while_break___1;
        }
#line 771
        if ((int const   )*q == 89) {
          {
#line 773
          strcpy((char */* __restrict  */)bufp, (char const   */* __restrict  */)(q + 1));
#line 774
          dump_file(buffer___1, (dev_t )-1, 1);
          }
        }
        {
#line 767
        tmp___2 = strlen(q);
#line 767
        q += tmp___2 + 1U;
        }
      }
      while_break___1: /* CIL Label */ ;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 778
    free((void *)buffer___1);
    }
  } else {
    {
#line 782
    while (1) {
      while_continue___2: /* CIL Label */ ;
      {
#line 782
      p = name_next(1);
      }
#line 782
      if (! p) {
#line 782
        goto while_break___2;
      }
      {
#line 783
      dump_file(p, (dev_t )-1, 1);
      }
    }
    while_break___2: /* CIL Label */ ;
    }
  }
  {
#line 786
  write_eot();
#line 787
  close_archive();
  }
#line 789
  if (listed_incremental_option) {
    {
#line 790
    write_dir_file();
    }
  }
#line 791
  return;
}
}
#line 913 "create.c"
static int warned_once___1  =    0;
#line 804 "create.c"
void dump_file(char *p , dev_t parent_device , int top_level ) 
{ 
  union block *header ;
  char type ;
  union block *exhdr ;
  char save_typeflag ;
  struct utimbuf restore_times ;
  off_t restore_size ;
  int tmp ;
  char *tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  struct link *lp ;
  char *link_name ;
  char *tmp___7 ;
  size_t tmp___8 ;
  char *tmp___9 ;
  int *tmp___10 ;
  int tmp___11 ;
  size_t tmp___12 ;
  void *tmp___13 ;
  int f ;
  size_t bufsize ;
  ssize_t count ;
  off_t sizeleft ;
  union block *start ;
  int header_moved ;
  char isextended ;
  int upperbound ;
  off_t filesize ;
  int counter ;
  char *tmp___14 ;
  int *tmp___15 ;
  int counter___0 ;
  int index_offset ;
  int tmp___16 ;
  char buf[(((sizeof(uintmax_t ) * 8UL) * 302UL) / 1000UL + 1UL) + 1UL] ;
  char *tmp___17 ;
  char *tmp___18 ;
  int *tmp___19 ;
  char buf___0[(((sizeof(uintmax_t ) * 8UL) * 302UL) / 1000UL + 1UL) + 1UL] ;
  char *tmp___20 ;
  char *tmp___21 ;
  struct stat final_stat ;
  int *tmp___22 ;
  char *tmp___23 ;
  int *tmp___24 ;
  int tmp___25 ;
  char *tmp___26 ;
  int *tmp___27 ;
  int tmp___28 ;
  char *tmp___29 ;
  int *tmp___30 ;
  int tmp___31 ;
  int size ;
  char *buffer___1 ;
  void *tmp___32 ;
  char *tmp___33 ;
  int *tmp___34 ;
  char *tmp___35 ;
  int *tmp___36 ;
  int tmp___37 ;
  DIR *directory ;
  struct dirent *entry ;
  char *namebuf ;
  size_t buflen ;
  size_t len ;
  dev_t our_device ;
  char *tmp___38 ;
  int *tmp___39 ;
  int tmp___40 ;
  __uid_t tmp___41 ;
  void *tmp___42 ;
  size_t tmp___43 ;
  off_t sizeleft___0 ;
  off_t totsize ;
  size_t bufsize___0 ;
  union block *start___0 ;
  ssize_t count___0 ;
  char const   *buffer___2 ;
  char const   *p_buffer ;
  size_t tmp___44 ;
  size_t tmp___45 ;
  char *tmp___46 ;
  int *tmp___47 ;
  char *tmp___48 ;
  int *tmp___49 ;
  int tmp___50 ;
  int tmp___51 ;
  size_t tmp___52 ;
  void *tmp___53 ;
  size_t tmp___54 ;
  char *tmp___55 ;
  int *tmp___56 ;
  int tmp___57 ;
  char *tmp___58 ;

  {
#line 817
  if (interactive_option) {
    {
#line 817
    tmp = confirm("add", (char const   *)p);
    }
#line 817
    if (! tmp) {
#line 818
      return;
    }
  }
#line 823
  if (dereference_option != 0) {
    {
#line 823
    tmp___2 = stat((char const   */* __restrict  */)p, (struct stat */* __restrict  */)(& current_stat));
#line 823
    tmp___4 = tmp___2;
    }
  } else {
    {
#line 823
    tmp___3 = lstat((char const   */* __restrict  */)p, (struct stat */* __restrict  */)(& current_stat));
#line 823
    tmp___4 = tmp___3;
    }
  }
#line 823
  if (tmp___4) {
    {
#line 832
    tmp___0 = gettext("Cannot add file %s");
#line 832
    tmp___1 = __errno_location();
#line 832
    error(0, *tmp___1, (char const   *)tmp___0, p);
    }
#line 833
    if (! ignore_failed_read_option) {
#line 834
      exit_status = 2;
    }
#line 835
    return;
  }
#line 838
  restore_times.actime = current_stat.st_atim.tv_sec;
#line 839
  restore_times.modtime = current_stat.st_mtim.tv_sec;
#line 840
  restore_size = current_stat.st_size;
#line 858
  if (! incremental_option) {
#line 858
    if (! ((current_stat.st_mode & 61440U) == 16384U)) {
#line 858
      if (current_stat.st_mtim.tv_sec < newer_mtime_option) {
#line 858
        if (! after_date_option) {
#line 858
          goto _L;
        } else
#line 858
        if (current_stat.st_ctim.tv_sec < newer_mtime_option) {
          _L: /* CIL Label */ 
#line 862
          if (parent_device == 0xffffffffffffffffULL) {
            {
#line 863
            tmp___5 = gettext("%s: is unchanged; not dumped");
#line 863
            error(0, 0, (char const   *)tmp___5, p);
            }
          }
#line 865
          return;
        }
      }
    }
  }
#line 871
  if (ar_dev) {
#line 871
    if (current_stat.st_dev == ar_dev) {
#line 871
      if (current_stat.st_ino == ar_ino) {
        {
#line 873
        tmp___6 = gettext("%s is the archive; not dumped");
#line 873
        error(0, 0, (char const   *)tmp___6, p);
        }
#line 874
        return;
      }
    }
  }
#line 884
  if (current_stat.st_nlink > 1U) {
#line 884
    if ((current_stat.st_mode & 61440U) == 32768U) {
#line 884
      goto _L___0;
    } else
#line 884
    if ((current_stat.st_mode & 61440U) == 8192U) {
#line 884
      goto _L___0;
    } else
#line 884
    if ((current_stat.st_mode & 61440U) == 24576U) {
#line 884
      goto _L___0;
    } else
#line 884
    if ((current_stat.st_mode & 61440U) == 4096U) {
      _L___0: /* CIL Label */ 
#line 904
      lp = linklist;
      {
#line 904
      while (1) {
        while_continue: /* CIL Label */ ;
#line 904
        if (! lp) {
#line 904
          goto while_break;
        }
#line 905
        if (lp->ino == current_stat.st_ino) {
#line 905
          if (lp->dev == current_stat.st_dev) {
#line 907
            link_name = lp->name;
            {
#line 911
            while (1) {
              while_continue___0: /* CIL Label */ ;
#line 911
              if (! absolute_names_option) {
#line 911
                if (! ((int )*link_name == 47)) {
#line 911
                  goto while_break___0;
                }
              } else {
#line 911
                goto while_break___0;
              }
#line 915
              if (! warned_once___1) {
                {
#line 917
                warned_once___1 = 1;
#line 918
                tmp___7 = gettext("Removing leading `/\' from absolute links");
#line 918
                error(0, 0, (char const   *)tmp___7);
                }
              }
#line 921
              link_name ++;
            }
            while_break___0: /* CIL Label */ ;
            }
            {
#line 923
            tmp___8 = strlen((char const   *)link_name);
            }
#line 923
            if (tmp___8 >= 100U) {
              {
#line 924
              write_long((char const   *)link_name, (char )'K');
              }
            }
            {
#line 925
            assign_string(& current_link_name, (char const   *)link_name);
#line 927
            current_stat.st_size = (__off64_t )0;
#line 928
            header = start_header((char const   *)p, & current_stat);
            }
#line 929
            if ((unsigned long )header == (unsigned long )((void *)0)) {
#line 931
              exit_status = 2;
#line 932
              return;
            }
            {
#line 934
            strncpy((char */* __restrict  */)(header->header.linkname), (char const   */* __restrict  */)link_name,
                    (size_t )100);
#line 939
            header->header.linkname[99] = (char)0;
#line 941
            header->header.typeflag = (char )'1';
#line 942
            finish_header(header);
            }
#line 946
            if (remove_files_option) {
              {
#line 947
              tmp___11 = unlink((char const   *)p);
              }
#line 947
              if (tmp___11 == -1) {
                {
#line 948
                tmp___9 = gettext("Cannot remove %s");
#line 948
                tmp___10 = __errno_location();
#line 948
                error(0, *tmp___10, (char const   *)tmp___9, p);
#line 948
                exit_status = 2;
                }
              }
            }
#line 951
            return;
          }
        }
#line 904
        lp = lp->next;
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 956
      tmp___12 = strlen((char const   *)p);
#line 956
      tmp___13 = xmalloc((size_t )(sizeof(struct link ) + (unsigned long )tmp___12));
#line 956
      lp = (struct link *)tmp___13;
#line 958
      lp->ino = current_stat.st_ino;
#line 959
      lp->dev = current_stat.st_dev;
#line 960
      strcpy((char */* __restrict  */)(lp->name), (char const   */* __restrict  */)p);
#line 961
      lp->next = linklist;
#line 962
      linklist = lp;
      }
    }
  }
#line 967
  if ((current_stat.st_mode & 61440U) == 32768U) {
#line 979
    isextended = (char)0;
#line 985
    header_moved = 0;
#line 987
    if (sparse_option) {
#line 1020
      if (current_stat.st_blocks < current_stat.st_size / 512LL + (__off64_t )(current_stat.st_size % 512LL != 0LL)) {
        {
#line 1024
        filesize = current_stat.st_size;
#line 1027
        header = start_header((char const   *)p, & current_stat);
        }
#line 1028
        if ((unsigned long )header == (unsigned long )((void *)0)) {
#line 1030
          exit_status = 2;
#line 1031
          return;
        }
        {
#line 1033
        header->header.typeflag = (char )'S';
#line 1034
        header_moved = 1;
#line 1041
        upperbound = deal_with_sparse(p, header);
        }
#line 1045
        if (upperbound > 3) {
#line 1046
          header->oldgnu_header.isextended = (char)1;
        }
        {
#line 1053
        off_to_oct(current_stat.st_size, header->oldgnu_header.realsize, (size_t )sizeof(header->oldgnu_header.realsize));
#line 1060
        find_new_file_size(& filesize, upperbound);
#line 1061
        current_stat.st_size = filesize;
#line 1062
        off_to_oct(filesize, header->header.size, (size_t )sizeof(header->header.size));
#line 1064
        counter = 0;
        }
        {
#line 1064
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 1064
          if (! (counter < 4)) {
#line 1064
            goto while_break___1;
          }
#line 1066
          if (! (sparsearray + counter)->numbytes) {
#line 1067
            goto while_break___1;
          }
          {
#line 1069
          off_to_oct((sparsearray + counter)->offset, header->oldgnu_header.sp[counter].offset,
                     (size_t )sizeof(header->oldgnu_header.sp[counter].offset));
#line 1071
          size_to_oct((sparsearray + counter)->numbytes, header->oldgnu_header.sp[counter].numbytes,
                      (size_t )sizeof(header->oldgnu_header.sp[counter].numbytes));
#line 1064
          counter ++;
          }
        }
        while_break___1: /* CIL Label */ ;
        }
      }
    } else {
#line 1078
      upperbound = 3;
    }
#line 1080
    sizeleft = current_stat.st_size;
#line 1085
    if (dev_null_output) {
#line 1088
      f = -1;
    } else
#line 1085
    if (sizeleft == 0LL) {
#line 1085
      if ((unsigned int )((256 | (256 >> 3)) | ((256 >> 3) >> 3)) == ((unsigned int )((256 | (256 >> 3)) | ((256 >> 3) >> 3)) & current_stat.st_mode)) {
#line 1088
        f = -1;
      } else {
#line 1085
        goto _L___1;
      }
    } else {
      _L___1: /* CIL Label */ 
      {
#line 1091
      f = open((char const   *)p, 0);
      }
#line 1092
      if (f < 0) {
        {
#line 1094
        tmp___14 = gettext("Cannot add file %s");
#line 1094
        tmp___15 = __errno_location();
#line 1094
        error(0, *tmp___15, (char const   *)tmp___14, p);
        }
#line 1095
        if (! ignore_failed_read_option) {
#line 1096
          exit_status = 2;
        }
#line 1097
        return;
      }
    }
#line 1103
    if (! header_moved) {
      {
#line 1105
      header = start_header((char const   *)p, & current_stat);
      }
#line 1106
      if ((unsigned long )header == (unsigned long )((void *)0)) {
#line 1108
        if (f >= 0) {
          {
#line 1109
          close(f);
          }
        }
#line 1110
        exit_status = 2;
#line 1111
        return;
      }
    }
    {
#line 1120
    isextended = header->oldgnu_header.isextended;
#line 1121
    save_typeflag = header->header.typeflag;
#line 1122
    finish_header(header);
    }
#line 1123
    if (isextended) {
#line 1133
      index_offset = 4;
      extend: 
      {
#line 1136
      exhdr = find_next_block();
      }
#line 1138
      if ((unsigned long )exhdr == (unsigned long )((void *)0)) {
#line 1140
        exit_status = 2;
#line 1141
        return;
      }
      {
#line 1143
      memset((void *)(exhdr->buffer), 0, (size_t )512);
#line 1144
      counter___0 = 0;
      }
      {
#line 1144
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 1144
        if (! (counter___0 < 21)) {
#line 1144
          goto while_break___2;
        }
#line 1146
        if (counter___0 + index_offset > upperbound) {
#line 1147
          goto while_break___2;
        }
        {
#line 1149
        size_to_oct((sparsearray + (counter___0 + index_offset))->numbytes, exhdr->sparse_header.sp[counter___0].numbytes,
                    (size_t )sizeof(exhdr->sparse_header.sp[counter___0].numbytes));
#line 1151
        off_to_oct((sparsearray + (counter___0 + index_offset))->offset, exhdr->sparse_header.sp[counter___0].offset,
                   (size_t )sizeof(exhdr->sparse_header.sp[counter___0].offset));
#line 1144
        counter___0 ++;
        }
      }
      while_break___2: /* CIL Label */ ;
      }
      {
#line 1154
      set_next_block_after(exhdr);
      }
#line 1160
      if (index_offset + counter___0 <= upperbound) {
#line 1162
        index_offset += counter___0;
#line 1163
        exhdr->sparse_header.isextended = (char)1;
#line 1164
        goto extend;
      }
    }
#line 1168
    if ((int )save_typeflag == 83) {
#line 1170
      if (f < 0) {
#line 1172
        goto padit;
      } else {
        {
#line 1170
        tmp___16 = finish_sparse_file(f, & sizeleft, current_stat.st_size, p);
        }
#line 1170
        if (tmp___16) {
#line 1172
          goto padit;
        }
      }
    } else {
      {
#line 1175
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 1175
        if (! (sizeleft > 0LL)) {
#line 1175
          goto while_break___3;
        }
#line 1177
        if (multi_volume_option) {
          {
#line 1179
          assign_string(& save_name, (char const   *)p);
#line 1180
          save_sizeleft = sizeleft;
#line 1181
          save_totsize = current_stat.st_size;
          }
        }
        {
#line 1183
        start = find_next_block();
#line 1185
        bufsize = available_space_after(start);
        }
#line 1187
        if (sizeleft < (off_t )bufsize) {
#line 1191
          bufsize = (size_t )sizeleft;
#line 1192
          count = (ssize_t )(bufsize % 512U);
#line 1193
          if (count) {
            {
#line 1194
            memset((void *)(start->buffer + sizeleft), 0, (size_t )(512 - count));
            }
          }
        }
#line 1197
        if (f < 0) {
#line 1198
          count = (ssize_t )bufsize;
        } else {
          {
#line 1200
          count = safe_read(f, (void *)(start->buffer), bufsize);
          }
        }
#line 1201
        if (count < 0) {
          {
#line 1204
          tmp___17 = stringify_uintmax_t_backwards((uintmax_t )(current_stat.st_size - sizeleft),
                                                   buf + sizeof(buf));
#line 1204
          tmp___18 = gettext("Read error at byte %s, reading %lu bytes, in file %s");
#line 1204
          tmp___19 = __errno_location();
#line 1204
          error(0, *tmp___19, (char const   *)tmp___18, tmp___17, (unsigned long )bufsize,
                p);
#line 1204
          exit_status = 2;
          }
#line 1209
          goto padit;
        }
        {
#line 1211
        sizeleft -= (off_t )count;
#line 1215
        set_next_block_after(start + (count - 1) / 512);
        }
#line 1217
        if ((size_t )count == bufsize) {
#line 1218
          goto while_continue___3;
        } else {
          {
#line 1222
          tmp___20 = stringify_uintmax_t_backwards((uintmax_t )sizeleft, buf___0 + sizeof(buf___0));
#line 1222
          tmp___21 = gettext("File %s shrunk by %s bytes, padding with zeros");
#line 1222
          error(0, 0, (char const   *)tmp___21, p, tmp___20);
#line 1222
          exit_status = 2;
          }
#line 1225
          goto padit;
        }
      }
      while_break___3: /* CIL Label */ ;
      }
    }
#line 1229
    if (multi_volume_option) {
      {
#line 1230
      assign_string(& save_name, (char const   *)((void *)0));
      }
    }
#line 1232
    if (f >= 0) {
      {
#line 1235
      tmp___25 = fstat(f, & final_stat);
      }
#line 1235
      if (tmp___25 != 0) {
        {
#line 1236
        tmp___22 = __errno_location();
#line 1236
        error(0, *tmp___22, "%s: fstat", p);
#line 1236
        exit_status = 2;
        }
      } else
#line 1237
      if (final_stat.st_mtim.tv_sec != restore_times.modtime) {
        {
#line 1239
        tmp___23 = gettext("%s: file changed as we read it");
#line 1239
        tmp___24 = __errno_location();
#line 1239
        error(0, *tmp___24, (char const   *)tmp___23, p);
#line 1239
        exit_status = 2;
        }
      } else
#line 1237
      if (final_stat.st_size != restore_size) {
        {
#line 1239
        tmp___23 = gettext("%s: file changed as we read it");
#line 1239
        tmp___24 = __errno_location();
#line 1239
        error(0, *tmp___24, (char const   *)tmp___23, p);
#line 1239
        exit_status = 2;
        }
      }
      {
#line 1240
      tmp___28 = close(f);
      }
#line 1240
      if (tmp___28 != 0) {
        {
#line 1241
        tmp___26 = gettext("%s: close");
#line 1241
        tmp___27 = __errno_location();
#line 1241
        error(0, *tmp___27, (char const   *)tmp___26, p);
#line 1241
        exit_status = 2;
        }
      }
#line 1242
      if (atime_preserve_option) {
        {
#line 1243
        utime((char const   *)p, (struct utimbuf  const  *)(& restore_times));
        }
      }
    }
#line 1245
    if (remove_files_option) {
      {
#line 1247
      tmp___31 = unlink((char const   *)p);
      }
#line 1247
      if (tmp___31 == -1) {
        {
#line 1248
        tmp___29 = gettext("Cannot remove %s");
#line 1248
        tmp___30 = __errno_location();
#line 1248
        error(0, *tmp___30, (char const   *)tmp___29, p);
#line 1248
        exit_status = 2;
        }
      }
    }
#line 1250
    return;
    padit: 
    {
#line 1256
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 1256
      if (! (sizeleft > 0LL)) {
#line 1256
        goto while_break___4;
      }
      {
#line 1258
      save_sizeleft = sizeleft;
#line 1259
      start = find_next_block();
#line 1260
      memset((void *)(start->buffer), 0, (size_t )512);
#line 1261
      set_next_block_after(start);
#line 1262
      sizeleft -= 512LL;
      }
    }
    while_break___4: /* CIL Label */ ;
    }
#line 1264
    if (multi_volume_option) {
      {
#line 1265
      assign_string(& save_name, (char const   *)((void *)0));
      }
    }
#line 1266
    if (f >= 0) {
      {
#line 1268
      close(f);
      }
#line 1269
      if (atime_preserve_option) {
        {
#line 1270
        utime((char const   *)p, (struct utimbuf  const  *)(& restore_times));
        }
      }
    }
#line 1272
    return;
  } else
#line 1276
  if ((current_stat.st_mode & 61440U) == 40960U) {
    {
#line 1279
    tmp___32 = __builtin_alloca(4097UL);
#line 1279
    buffer___1 = (char *)tmp___32;
#line 1281
    size = readlink((char const   */* __restrict  */)p, (char */* __restrict  */)buffer___1,
                    (size_t )4097);
    }
#line 1282
    if (size < 0) {
      {
#line 1284
      tmp___33 = gettext("Cannot add file %s");
#line 1284
      tmp___34 = __errno_location();
#line 1284
      error(0, *tmp___34, (char const   *)tmp___33, p);
      }
#line 1285
      if (! ignore_failed_read_option) {
#line 1286
        exit_status = 2;
      }
#line 1287
      return;
    }
#line 1289
    *(buffer___1 + size) = (char )'\000';
#line 1290
    if (size >= 100) {
      {
#line 1291
      write_long((char const   *)buffer___1, (char )'K');
      }
    }
    {
#line 1292
    assign_string(& current_link_name, (char const   *)buffer___1);
#line 1294
    current_stat.st_size = (__off64_t )0;
#line 1295
    header = start_header((char const   *)p, & current_stat);
    }
#line 1296
    if ((unsigned long )header == (unsigned long )((void *)0)) {
#line 1298
      exit_status = 2;
#line 1299
      return;
    }
    {
#line 1301
    strncpy((char */* __restrict  */)(header->header.linkname), (char const   */* __restrict  */)buffer___1,
            (size_t )100);
#line 1302
    header->header.linkname[99] = (char )'\000';
#line 1303
    header->header.typeflag = (char )'2';
#line 1304
    finish_header(header);
    }
#line 1305
    if (remove_files_option) {
      {
#line 1307
      tmp___37 = unlink((char const   *)p);
      }
#line 1307
      if (tmp___37 == -1) {
        {
#line 1308
        tmp___35 = gettext("Cannot remove %s");
#line 1308
        tmp___36 = __errno_location();
#line 1308
        error(0, *tmp___36, (char const   *)tmp___35, p);
#line 1308
        exit_status = 2;
        }
      }
    }
#line 1310
    return;
  } else
#line 1314
  if ((current_stat.st_mode & 61440U) == 16384U) {
    {
#line 1321
    our_device = current_stat.st_dev;
#line 1330
    tmp___40 = access((char const   *)p, 4);
    }
#line 1330
    if (tmp___40 == -1) {
      {
#line 1330
      tmp___41 = geteuid();
      }
#line 1330
      if (tmp___41 != 0U) {
        {
#line 1332
        tmp___38 = gettext("Cannot add directory %s");
#line 1332
        tmp___39 = __errno_location();
#line 1332
        error(0, *tmp___39, (char const   *)tmp___38, p);
        }
#line 1333
        if (! ignore_failed_read_option) {
#line 1334
          exit_status = 2;
        }
#line 1335
        return;
      }
    }
    {
#line 1340
    len = strlen((char const   *)p);
#line 1341
    buflen = len + 100U;
#line 1342
    tmp___42 = xmalloc(buflen + 1U);
#line 1342
    namebuf = (char *)tmp___42;
#line 1343
    strncpy((char */* __restrict  */)namebuf, (char const   */* __restrict  */)p,
            buflen);
    }
    {
#line 1344
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 1344
      if (len >= 1U) {
#line 1344
        if (! ((int )*(namebuf + (len - 1U)) == 47)) {
#line 1344
          goto while_break___5;
        }
      } else {
#line 1344
        goto while_break___5;
      }
#line 1345
      len --;
    }
    while_break___5: /* CIL Label */ ;
    }
    {
#line 1346
    tmp___43 = len;
#line 1346
    len ++;
#line 1346
    *(namebuf + tmp___43) = (char )'/';
#line 1347
    *(namebuf + len) = (char )'\000';
#line 1361
    current_stat.st_size = (__off64_t )0;
#line 1372
    header = start_header((char const   *)namebuf, & current_stat);
    }
#line 1373
    if ((unsigned long )header == (unsigned long )((void *)0)) {
#line 1375
      exit_status = 2;
#line 1376
      return;
    }
#line 1379
    if (incremental_option) {
#line 1380
      header->header.typeflag = (char )'D';
    } else {
#line 1382
      header->header.typeflag = (char )'5';
    }
#line 1386
    if (! incremental_option) {
      {
#line 1387
      finish_header(header);
      }
    }
#line 1390
    if (incremental_option) {
#line 1390
      if (gnu_list_name->dir_contents) {
#line 1399
        buffer___2 = gnu_list_name->dir_contents;
#line 1400
        totsize = (off_t )0;
#line 1401
        p_buffer = buffer___2;
        {
#line 1401
        while (1) {
          while_continue___6: /* CIL Label */ ;
#line 1401
          if (p_buffer) {
#line 1401
            if (! *p_buffer) {
#line 1401
              goto while_break___6;
            }
          } else {
#line 1401
            goto while_break___6;
          }
          {
#line 1405
          tmp___45 = strlen(p_buffer);
#line 1405
          tmp___44 = tmp___45 + 1U;
#line 1406
          totsize += (off_t )tmp___44;
#line 1407
          p_buffer += tmp___44;
          }
        }
        while_break___6: /* CIL Label */ ;
        }
        {
#line 1409
        totsize ++;
#line 1410
        off_to_oct(totsize, header->header.size, (size_t )sizeof(header->header.size));
#line 1411
        finish_header(header);
#line 1412
        p_buffer = buffer___2;
#line 1413
        sizeleft___0 = totsize;
        }
        {
#line 1414
        while (1) {
          while_continue___7: /* CIL Label */ ;
#line 1414
          if (! (sizeleft___0 > 0LL)) {
#line 1414
            goto while_break___7;
          }
#line 1416
          if (multi_volume_option) {
            {
#line 1418
            assign_string(& save_name, (char const   *)p);
#line 1419
            save_sizeleft = sizeleft___0;
#line 1420
            save_totsize = totsize;
            }
          }
          {
#line 1422
          start___0 = find_next_block();
#line 1423
          bufsize___0 = available_space_after(start___0);
          }
#line 1424
          if (sizeleft___0 < (off_t )bufsize___0) {
#line 1426
            bufsize___0 = (size_t )sizeleft___0;
#line 1427
            count___0 = (ssize_t )(bufsize___0 % 512U);
#line 1428
            if (count___0) {
              {
#line 1429
              memset((void *)(start___0->buffer + sizeleft___0), 0, (size_t )(512 - count___0));
              }
            }
          }
          {
#line 1432
          memcpy((void */* __restrict  */)(start___0->buffer), (void const   */* __restrict  */)p_buffer,
                 bufsize___0);
#line 1433
          sizeleft___0 -= (off_t )bufsize___0;
#line 1434
          p_buffer += bufsize___0;
#line 1435
          set_next_block_after(start___0 + (bufsize___0 - 1U) / 512U);
          }
        }
        while_break___7: /* CIL Label */ ;
        }
#line 1437
        if (multi_volume_option) {
          {
#line 1438
          assign_string(& save_name, (char const   *)((void *)0));
          }
        }
#line 1439
        if (atime_preserve_option) {
          {
#line 1440
          utime((char const   *)p, (struct utimbuf  const  *)(& restore_times));
          }
        }
#line 1441
        return;
      }
    }
#line 1447
    if (no_recurse_option) {
#line 1448
      return;
    }
#line 1453
    if (one_file_system_option) {
#line 1453
      if (! top_level) {
#line 1453
        if (parent_device != current_stat.st_dev) {
#line 1456
          if (verbose_option) {
            {
#line 1457
            tmp___46 = gettext("%s: On a different filesystem; not dumped");
#line 1457
            error(0, 0, (char const   *)tmp___46, p);
            }
          }
#line 1458
          return;
        }
      }
    }
    {
#line 1463
    tmp___47 = __errno_location();
#line 1463
    *tmp___47 = 0;
#line 1465
    directory = opendir((char const   *)p);
    }
#line 1466
    if (! directory) {
      {
#line 1468
      tmp___48 = gettext("Cannot open directory %s");
#line 1468
      tmp___49 = __errno_location();
#line 1468
      error(0, *tmp___49, (char const   *)tmp___48, p);
#line 1468
      exit_status = 2;
      }
#line 1469
      return;
    }
#line 1474
    if (len == 2U) {
#line 1474
      if ((int )*(namebuf + 0) == 46) {
#line 1474
        if ((int )*(namebuf + 1) == 47) {
#line 1475
          len = (size_t )0;
        }
      }
    }
    {
#line 1479
    while (1) {
      while_continue___8: /* CIL Label */ ;
      {
#line 1479
      entry = readdir(directory);
      }
#line 1479
      if (! entry) {
#line 1479
        goto while_break___8;
      }
      {
#line 1483
      tmp___50 = is_dot_or_dotdot((char const   *)(entry->d_name));
      }
#line 1483
      if (tmp___50) {
#line 1485
        goto while_continue___8;
      } else {
        {
#line 1483
        tmp___51 = excluded_filename((struct exclude  const  *)excluded, (char const   *)(entry->d_name));
        }
#line 1483
        if (tmp___51) {
#line 1485
          goto while_continue___8;
        }
      }
      {
#line 1487
      tmp___54 = strlen((char const   *)(entry->d_name));
      }
#line 1487
      if ((size_t )((int )tmp___54) + len >= buflen) {
        {
#line 1489
        tmp___52 = strlen((char const   *)(entry->d_name));
#line 1489
        buflen = len + tmp___52;
#line 1490
        tmp___53 = xrealloc((void *)namebuf, buflen + 1U);
#line 1490
        namebuf = (char *)tmp___53;
        }
      }
      {
#line 1498
      strcpy((char */* __restrict  */)(namebuf + len), (char const   */* __restrict  */)(entry->d_name));
#line 1499
      dump_file(namebuf, our_device, 0);
      }
    }
    while_break___8: /* CIL Label */ ;
    }
    {
#line 1502
    closedir(directory);
#line 1503
    free((void *)namebuf);
    }
#line 1504
    if (atime_preserve_option) {
      {
#line 1505
      utime((char const   *)p, (struct utimbuf  const  *)(& restore_times));
      }
    }
#line 1506
    return;
  } else
#line 1510
  if ((current_stat.st_mode & 61440U) == 8192U) {
#line 1511
    type = (char )'3';
  } else
#line 1515
  if ((current_stat.st_mode & 61440U) == 24576U) {
#line 1516
    type = (char )'4';
  } else
#line 1522
  if ((current_stat.st_mode & 61440U) == 4096U) {
#line 1523
    type = (char )'6';
  } else
#line 1527
  if ((current_stat.st_mode & 61440U) == 49152U) {
#line 1528
    type = (char )'6';
  } else {
#line 1532
    goto unknown;
  }
#line 1534
  if ((unsigned int )archive_format == 1U) {
#line 1535
    goto unknown;
  }
  {
#line 1537
  current_stat.st_size = (__off64_t )0;
#line 1538
  header = start_header((char const   *)p, & current_stat);
  }
#line 1539
  if ((unsigned long )header == (unsigned long )((void *)0)) {
#line 1541
    exit_status = 2;
#line 1542
    return;
  }
#line 1545
  header->header.typeflag = type;
#line 1548
  if ((int )type != 54) {
    {
#line 1550
    major_to_oct((int )((current_stat.st_rdev >> 8) & 255ULL), header->header.devmajor,
                 (size_t )sizeof(header->header.devmajor));
#line 1551
    minor_to_oct((int )(current_stat.st_rdev & 255ULL), header->header.devminor, (size_t )sizeof(header->header.devminor));
    }
  }
  {
#line 1555
  finish_header(header);
  }
#line 1556
  if (remove_files_option) {
    {
#line 1558
    tmp___57 = unlink((char const   *)p);
    }
#line 1558
    if (tmp___57 == -1) {
      {
#line 1559
      tmp___55 = gettext("Cannot remove %s");
#line 1559
      tmp___56 = __errno_location();
#line 1559
      error(0, *tmp___56, (char const   *)tmp___55, p);
#line 1559
      exit_status = 2;
      }
    }
  }
#line 1561
  return;
  unknown: 
  {
#line 1564
  tmp___58 = gettext("%s: Unknown file type; file ignored");
#line 1564
  error(0, 0, (char const   *)tmp___58, p);
#line 1564
  exit_status = 2;
  }
#line 1565
  return;
}
}
#line 857 "/usr/include/unistd.h"
extern int fsync(int __fd ) ;
#line 326 "common.h"
enum access_mode access_mode ;
#line 380
int now_verifying ;
#line 384
void verify_volume(void) ;
#line 32 "compare.c"
int now_verifying  =    0;
#line 35 "compare.c"
static int diff_handle  ;
#line 38 "compare.c"
static char *diff_buffer  =    (char *)((void *)0);
#line 44 "compare.c"
void diff_init(void) 
{ 
  void *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;

  {
  {
#line 47
  tmp = malloc(record_size);
#line 47
  diff_buffer = (char *)tmp;
  }
#line 48
  if (! diff_buffer) {
    {
#line 49
    tmp___0 = gettext("Could not allocate memory for diff buffer of %lu bytes");
#line 49
    error(0, 0, (char const   *)tmp___0, (unsigned long )record_size);
#line 49
    tmp___1 = gettext("Error is not recoverable: exiting now");
#line 49
    error(2, 0, (char const   *)tmp___1);
    }
  }
#line 52
  return;
}
}
#line 59 "compare.c"
static void report_difference(char const   *message ) 
{ 


  {
#line 62
  if (message) {
    {
#line 63
    fprintf((FILE */* __restrict  */)stdlis, (char const   */* __restrict  */)"%s: %s\n",
            current_file_name, message);
    }
  }
#line 65
  if (exit_status == 0) {
#line 66
    exit_status = 1;
  }
#line 67
  return;
}
}
#line 76 "compare.c"
static int process_noop(size_t size , char *data ) 
{ 


  {
#line 79
  return (1);
}
}
#line 86 "compare.c"
static int process_rawdata(size_t bytes , char *buffer___1 ) 
{ 
  ssize_t status ;
  ssize_t tmp ;
  char message[100] ;
  char *tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;

  {
  {
#line 89
  tmp = safe_read(diff_handle, (void *)diff_buffer, bytes);
#line 89
  status = tmp;
  }
#line 92
  if ((size_t )status != bytes) {
#line 94
    if (status < 0) {
      {
#line 96
      tmp___0 = gettext("Cannot read %s");
#line 96
      tmp___1 = __errno_location();
#line 96
      error(0, *tmp___1, (char const   *)tmp___0, current_file_name);
#line 97
      report_difference((char const   *)((void *)0));
      }
    } else {
      {
#line 101
      tmp___2 = gettext("Could only read %lu of %lu bytes");
#line 101
      sprintf((char */* __restrict  */)(message), (char const   */* __restrict  */)tmp___2,
              (unsigned long )status, (unsigned long )bytes);
#line 103
      report_difference((char const   *)(message));
      }
    }
#line 105
    return (0);
  }
  {
#line 108
  tmp___4 = memcmp((void const   *)buffer___1, (void const   *)diff_buffer, bytes);
  }
#line 108
  if (tmp___4) {
    {
#line 110
    tmp___3 = gettext("Data differs");
#line 110
    report_difference((char const   *)tmp___3);
    }
#line 111
    return (0);
  }
#line 114
  return (1);
}
}
#line 123 "compare.c"
static char *dumpdir_cursor  ;
#line 125 "compare.c"
static int process_dumpdir(size_t bytes , char *buffer___1 ) 
{ 
  char *tmp ;
  int tmp___0 ;

  {
  {
#line 128
  tmp___0 = memcmp((void const   *)buffer___1, (void const   *)dumpdir_cursor, bytes);
  }
#line 128
  if (tmp___0) {
    {
#line 130
    tmp = gettext("Data differs");
#line 130
    report_difference((char const   *)tmp);
    }
#line 131
    return (0);
  }
#line 134
  dumpdir_cursor += bytes;
#line 135
  return (1);
}
}
#line 146 "compare.c"
static void read_and_process(size_t size , int (*processor)(size_t  , char * ) ) 
{ 
  union block *data_block ;
  size_t data_size ;
  char *tmp ;
  int tmp___0 ;

  {
#line 152
  if (multi_volume_option) {
#line 153
    save_sizeleft = (off_t )size;
  }
  {
#line 154
  while (1) {
    while_continue: /* CIL Label */ ;
#line 154
    if (! size) {
#line 154
      goto while_break;
    }
    {
#line 156
    data_block = find_next_block();
    }
#line 157
    if ((unsigned long )data_block == (unsigned long )((void *)0)) {
      {
#line 159
      tmp = gettext("Unexpected EOF on archive file");
#line 159
      error(0, 0, (char const   *)tmp);
#line 159
      exit_status = 2;
      }
#line 160
      return;
    }
    {
#line 163
    data_size = available_space_after(data_block);
    }
#line 164
    if (data_size > size) {
#line 165
      data_size = size;
    }
    {
#line 166
    tmp___0 = (*processor)(data_size, data_block->buffer);
    }
#line 166
    if (! tmp___0) {
#line 167
      processor = & process_noop;
    }
    {
#line 168
    set_next_block_after((union block *)((data_block->buffer + data_size) - 1));
#line 170
    size -= data_size;
    }
#line 171
    if (multi_volume_option) {
#line 172
      save_sizeleft -= (off_t )data_size;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 174
  return;
}
}
#line 218
static void fill_in_sparse_array(void) ;
#line 218 "compare.c"
static int so_far_ind  =    4;
#line 187 "compare.c"
static void fill_in_sparse_array(void) 
{ 
  int counter ;
  void *tmp ;
  union block *exhdr ;
  void *tmp___0 ;

  {
  {
#line 195
  sp_array_size = 10;
#line 196
  tmp = xmalloc((size_t )((unsigned long )sp_array_size * sizeof(struct sp_array )));
#line 196
  sparsearray = (struct sp_array *)tmp;
#line 201
  counter = 0;
  }
  {
#line 201
  while (1) {
    while_continue: /* CIL Label */ ;
#line 201
    if (! (counter < 4)) {
#line 201
      goto while_break;
    }
#line 204
    if ((unsigned long )(current_header->oldgnu_header.sp[counter].numbytes) == (unsigned long )((char *)0)) {
#line 205
      goto while_break;
    }
    {
#line 207
    (sparsearray + counter)->offset = off_from_oct((char const   *)(current_header->oldgnu_header.sp[counter].offset),
                                                   (size_t )sizeof(current_header->oldgnu_header.sp[counter].offset));
#line 209
    (sparsearray + counter)->numbytes = size_from_oct((char const   *)(current_header->oldgnu_header.sp[counter].numbytes),
                                                      (size_t )sizeof(current_header->oldgnu_header.sp[counter].numbytes));
#line 201
    counter ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 215
  if (current_header->oldgnu_header.isextended) {
    {
#line 221
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 223
      exhdr = find_next_block();
#line 224
      counter = 0;
      }
      {
#line 224
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 224
        if (! (counter < 21)) {
#line 224
          goto while_break___1;
        }
#line 226
        if (counter + so_far_ind > sp_array_size - 1) {
          {
#line 231
          sp_array_size *= 2;
#line 232
          tmp___0 = xrealloc((void *)sparsearray, (size_t )((unsigned long )sp_array_size * sizeof(struct sp_array )));
#line 232
          sparsearray = (struct sp_array *)tmp___0;
          }
        }
        {
#line 239
        (sparsearray + (counter + so_far_ind))->offset = off_from_oct((char const   *)(exhdr->sparse_header.sp[counter].offset),
                                                                      (size_t )sizeof(exhdr->sparse_header.sp[counter].offset));
#line 241
        (sparsearray + (counter + so_far_ind))->numbytes = size_from_oct((char const   *)(exhdr->sparse_header.sp[counter].numbytes),
                                                                         (size_t )sizeof(exhdr->sparse_header.sp[counter].numbytes));
#line 224
        counter ++;
        }
      }
      while_break___1: /* CIL Label */ ;
      }
#line 248
      if (! exhdr->sparse_header.isextended) {
#line 249
        goto while_break___0;
      }
      {
#line 251
      so_far_ind += 21;
#line 252
      set_next_block_after(exhdr);
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 257
    set_next_block_after(exhdr);
    }
  }
#line 259
  return;
}
}
#line 275 "compare.c"
static void diff_sparse_files(off_t size_of_file ) 
{ 
  off_t remaining_size ;
  char *buffer___1 ;
  void *tmp ;
  size_t buffer_size ;
  union block *data_block ;
  int counter ;
  int different ;
  ssize_t status ;
  size_t chunk_size ;
  off_t offset ;
  char buf[(((sizeof(uintmax_t ) * 8UL) * 302UL) / 1000UL + 1UL) + 1UL] ;
  char *tmp___0 ;
  char *tmp___1 ;
  int *tmp___2 ;
  __off64_t tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  void *tmp___6 ;
  char *tmp___7 ;
  int *tmp___8 ;
  char message[100] ;
  char *tmp___9 ;
  int tmp___10 ;
  char *tmp___11 ;
  int *tmp___12 ;
  char message___0[100] ;
  char *tmp___13 ;
  int tmp___14 ;
  char *tmp___15 ;

  {
  {
#line 278
  remaining_size = size_of_file;
#line 279
  tmp = xmalloc((size_t )(512UL * sizeof(char )));
#line 279
  buffer___1 = (char *)tmp;
#line 280
  buffer_size = (size_t )512;
#line 281
  data_block = (union block *)((void *)0);
#line 282
  counter = 0;
#line 283
  different = 0;
#line 285
  fill_in_sparse_array();
  }
  {
#line 287
  while (1) {
    while_continue: /* CIL Label */ ;
#line 287
    if (! (remaining_size > 0LL)) {
#line 287
      goto while_break;
    }
    {
#line 297
    data_block = find_next_block();
#line 298
    chunk_size = (sparsearray + counter)->numbytes;
    }
#line 299
    if (! chunk_size) {
#line 300
      goto while_break;
    }
    {
#line 302
    offset = (sparsearray + counter)->offset;
#line 303
    tmp___3 = lseek(diff_handle, offset, 0);
    }
#line 303
    if (tmp___3 < 0LL) {
      {
#line 306
      tmp___0 = stringify_uintmax_t_backwards((uintmax_t )offset, buf + sizeof(buf));
#line 306
      tmp___1 = gettext("Cannot seek to %s in file %s");
#line 306
      tmp___2 = __errno_location();
#line 306
      error(0, *tmp___2, (char const   *)tmp___1, tmp___0, current_file_name);
#line 308
      report_difference((char const   *)((void *)0));
      }
    }
    {
#line 313
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 313
      if (! (buffer_size < chunk_size)) {
#line 313
        goto while_break___0;
      }
#line 315
      if (buffer_size * 2U < buffer_size) {
        {
#line 316
        tmp___4 = gettext("Memory exhausted");
#line 316
        error(0, 0, (char const   *)tmp___4);
#line 316
        tmp___5 = gettext("Error is not recoverable: exiting now");
#line 316
        error(2, 0, (char const   *)tmp___5);
        }
      }
      {
#line 317
      buffer_size *= 2U;
#line 318
      tmp___6 = xrealloc((void *)buffer___1, (size_t )((unsigned long )buffer_size * sizeof(char )));
#line 318
      buffer___1 = (char *)tmp___6;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 321
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 321
      if (! (chunk_size > 512U)) {
#line 321
        goto while_break___1;
      }
      {
#line 323
      status = safe_read(diff_handle, (void *)buffer___1, (size_t )512);
      }
#line 323
      if (status != 512) {
#line 326
        if (status < 0) {
          {
#line 328
          tmp___7 = gettext("Cannot read %s");
#line 328
          tmp___8 = __errno_location();
#line 328
          error(0, *tmp___8, (char const   *)tmp___7, current_file_name);
#line 329
          report_difference((char const   *)((void *)0));
          }
        } else {
          {
#line 335
          tmp___9 = gettext("Could only read %lu of %lu bytes");
#line 335
          sprintf((char */* __restrict  */)(message), (char const   */* __restrict  */)tmp___9,
                  (unsigned long )status, (unsigned long )chunk_size);
#line 337
          report_difference((char const   *)(message));
          }
        }
#line 339
        goto while_break___1;
      }
      {
#line 342
      tmp___10 = memcmp((void const   *)buffer___1, (void const   *)(data_block->buffer),
                        (size_t )512);
      }
#line 342
      if (tmp___10) {
#line 344
        different = 1;
#line 345
        goto while_break___1;
      }
      {
#line 348
      chunk_size -= (size_t )status;
#line 349
      remaining_size -= (off_t )status;
#line 350
      set_next_block_after(data_block);
#line 351
      data_block = find_next_block();
      }
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 353
    status = safe_read(diff_handle, (void *)buffer___1, chunk_size);
    }
#line 353
    if ((size_t )status != chunk_size) {
#line 356
      if (status < 0) {
        {
#line 358
        tmp___11 = gettext("Cannot read %s");
#line 358
        tmp___12 = __errno_location();
#line 358
        error(0, *tmp___12, (char const   *)tmp___11, current_file_name);
#line 359
        report_difference((char const   *)((void *)0));
        }
      } else {
        {
#line 365
        tmp___13 = gettext("Could only read %lu of %lu bytes");
#line 365
        sprintf((char */* __restrict  */)(message___0), (char const   */* __restrict  */)tmp___13,
                (unsigned long )status, (unsigned long )chunk_size);
#line 367
        report_difference((char const   *)(message___0));
        }
      }
#line 369
      goto while_break;
    }
    {
#line 372
    tmp___14 = memcmp((void const   *)buffer___1, (void const   *)(data_block->buffer),
                      chunk_size);
    }
#line 372
    if (tmp___14) {
#line 374
      different = 1;
#line 375
      goto while_break;
    }
    {
#line 386
    set_next_block_after(data_block);
#line 387
    counter ++;
#line 388
    remaining_size -= (off_t )chunk_size;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 399
  set_next_block_after(data_block);
#line 400
  free((void *)sparsearray);
  }
#line 402
  if (different) {
    {
#line 403
    tmp___15 = gettext("Data differs");
#line 403
    report_difference((char const   *)tmp___15);
    }
  }
#line 404
  return;
}
}
#line 412 "compare.c"
static int get_stat_data(struct stat *stat_data ) 
{ 
  int status ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  int *tmp___4 ;
  int *tmp___5 ;

  {
#line 415
  if (dereference_option) {
    {
#line 415
    tmp = stat((char const   */* __restrict  */)current_file_name, (struct stat */* __restrict  */)stat_data);
#line 415
    tmp___1 = tmp;
    }
  } else {
    {
#line 415
    tmp___0 = lstat((char const   */* __restrict  */)current_file_name, (struct stat */* __restrict  */)stat_data);
#line 415
    tmp___1 = tmp___0;
    }
  }
#line 415
  status = tmp___1;
#line 419
  if (status < 0) {
    {
#line 421
    tmp___5 = __errno_location();
    }
#line 421
    if (*tmp___5 == 2) {
      {
#line 422
      tmp___2 = gettext("File does not exist");
#line 422
      report_difference((char const   *)tmp___2);
      }
    } else {
      {
#line 425
      tmp___3 = gettext("Cannot stat file %s");
#line 425
      tmp___4 = __errno_location();
#line 425
      error(0, *tmp___4, (char const   *)tmp___3, current_file_name);
#line 425
      exit_status = 2;
#line 426
      report_difference((char const   *)((void *)0));
      }
    }
#line 431
    return (0);
  }
#line 434
  return (1);
}
}
#line 441 "compare.c"
void diff_archive(void) 
{ 
  struct stat stat_data ;
  size_t name_length ;
  int status ;
  int *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  size_t tmp___2 ;
  int tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmpbuf ;
  size_t tmp___10 ;
  void *tmp___11 ;
  char *tmp___12 ;
  int *tmp___13 ;
  char *tmp___14 ;
  int *tmp___15 ;
  dev_t dev ;
  ino_t ino ;
  int tmp___16 ;
  char *tmp___17 ;
  char *tmp___18 ;
  int *tmp___19 ;
  int *tmp___20 ;
  char *message ;
  size_t tmp___21 ;
  void *tmp___22 ;
  char *tmp___23 ;
  char linkbuf[103] ;
  char *tmp___24 ;
  char *tmp___25 ;
  int *tmp___26 ;
  int *tmp___27 ;
  char *tmp___28 ;
  int tmp___29 ;
  int tmp___30 ;
  char *tmp___31 ;
  char *tmp___32 ;
  char *dumpdir_buffer ;
  char *tmp___33 ;
  size_t tmp___34 ;
  size_t tmp___35 ;
  int tmp___36 ;
  char *tmp___37 ;
  char *tmp___38 ;
  off_t offset ;
  size_t tmp___39 ;
  int tmp___40 ;
  char *tmp___41 ;
  char *tmp___42 ;
  char *tmp___43 ;
  int *tmp___44 ;
  char buf[(((sizeof(uintmax_t ) * 8UL) * 302UL) / 1000UL + 1UL) + 1UL] ;
  char *tmp___45 ;
  char *tmp___46 ;
  int *tmp___47 ;
  __off64_t tmp___48 ;
  char *tmp___49 ;
  int *tmp___50 ;

  {
  {
#line 448
  tmp = __errno_location();
#line 448
  *tmp = 32;
#line 451
  set_next_block_after(current_header);
#line 452
  decode_header(current_header, & current_stat, & current_format, 1);
  }
#line 456
  if (verbose_option) {
#line 458
    if (now_verifying) {
      {
#line 459
      tmp___0 = gettext("Verify ");
#line 459
      fprintf((FILE */* __restrict  */)stdlis, (char const   */* __restrict  */)tmp___0);
      }
    }
    {
#line 460
    print_header();
    }
  }
  {
#line 473
  if ((int )current_header->header.typeflag == 55) {
#line 473
    goto case_55;
  }
#line 473
  if ((int )current_header->header.typeflag == 83) {
#line 473
    goto case_55;
  }
#line 473
  if ((int )current_header->header.typeflag == 48) {
#line 473
    goto case_55;
  }
#line 473
  if ((int )current_header->header.typeflag == 0) {
#line 473
    goto case_55;
  }
#line 568
  if ((int )current_header->header.typeflag == 49) {
#line 568
    goto case_49;
  }
#line 607
  if ((int )current_header->header.typeflag == 50) {
#line 607
    goto case_50;
  }
#line 634
  if ((int )current_header->header.typeflag == 51) {
#line 634
    goto case_51;
  }
#line 642
  if ((int )current_header->header.typeflag == 52) {
#line 642
    goto case_52;
  }
#line 650
  if ((int )current_header->header.typeflag == 54) {
#line 650
    goto case_54;
  }
#line 686
  if ((int )current_header->header.typeflag == 68) {
#line 686
    goto case_68;
  }
#line 712
  if ((int )current_header->header.typeflag == 53) {
#line 712
    goto case_53;
  }
#line 734
  if ((int )current_header->header.typeflag == 86) {
#line 734
    goto case_86;
  }
#line 737
  if ((int )current_header->header.typeflag == 77) {
#line 737
    goto case_77;
  }
#line 465
  goto switch_default;
  switch_default: /* CIL Label */ 
  {
#line 466
  tmp___1 = gettext("Unknown file type \'%c\' for %s, diffed as normal file");
#line 466
  error(0, 0, (char const   *)tmp___1, (int )current_header->header.typeflag, current_file_name);
  }
  case_55: /* CIL Label */ 
  case_83: /* CIL Label */ 
  case_48: /* CIL Label */ 
  case_0: /* CIL Label */ 
  {
#line 477
  tmp___2 = strlen((char const   *)current_file_name);
#line 477
  name_length = tmp___2 - 1U;
  }
#line 478
  if ((int )*(current_file_name + name_length) == 47) {
#line 479
    goto really_dir;
  }
  {
#line 481
  tmp___3 = get_stat_data(& stat_data);
  }
#line 481
  if (! tmp___3) {
#line 483
    if (current_header->oldgnu_header.isextended) {
      {
#line 484
      skip_extended_headers();
      }
    }
    {
#line 485
    skip_file(current_stat.st_size);
    }
#line 486
    goto quit;
  }
#line 489
  if (! ((stat_data.st_mode & 61440U) == 32768U)) {
    {
#line 491
    tmp___4 = gettext("Not a regular file");
#line 491
    report_difference((char const   *)tmp___4);
#line 492
    skip_file(current_stat.st_size);
    }
#line 493
    goto quit;
  }
#line 496
  stat_data.st_mode &= (unsigned int )(3584 | (((64 | (64 >> 3)) | ((64 >> 3) >> 3)) | (((128 | (128 >> 3)) | ((128 >> 3) >> 3)) | ((256 | (256 >> 3)) | ((256 >> 3) >> 3)))));
#line 497
  if (stat_data.st_mode != current_stat.st_mode) {
    {
#line 498
    tmp___5 = gettext("Mode differs");
#line 498
    report_difference((char const   *)tmp___5);
    }
  }
#line 504
  if (stat_data.st_uid != current_stat.st_uid) {
    {
#line 505
    tmp___6 = gettext("Uid differs");
#line 505
    report_difference((char const   *)tmp___6);
    }
  }
#line 506
  if (stat_data.st_gid != current_stat.st_gid) {
    {
#line 507
    tmp___7 = gettext("Gid differs");
#line 507
    report_difference((char const   *)tmp___7);
    }
  }
#line 510
  if (stat_data.st_mtim.tv_sec != current_stat.st_mtim.tv_sec) {
    {
#line 511
    tmp___8 = gettext("Mod time differs");
#line 511
    report_difference((char const   *)tmp___8);
    }
  }
#line 512
  if ((int )current_header->header.typeflag != 83) {
#line 512
    if (stat_data.st_size != current_stat.st_size) {
      {
#line 515
      tmp___9 = gettext("Size differs");
#line 515
      report_difference((char const   *)tmp___9);
#line 516
      skip_file(current_stat.st_size);
      }
#line 517
      goto quit;
    }
  }
  {
#line 520
  diff_handle = open((char const   *)current_file_name, 2048);
  }
#line 522
  if (diff_handle < 0) {
#line 522
    if (! absolute_names_option) {
      {
#line 524
      tmp___10 = strlen((char const   *)current_file_name);
#line 524
      tmp___11 = xmalloc(tmp___10 + 2U);
#line 524
      tmpbuf = (char *)tmp___11;
#line 526
      *tmpbuf = (char )'/';
#line 527
      strcpy((char */* __restrict  */)(tmpbuf + 1), (char const   */* __restrict  */)current_file_name);
#line 528
      diff_handle = open((char const   *)tmpbuf, 2048);
#line 529
      free((void *)tmpbuf);
      }
    }
  }
#line 531
  if (diff_handle < 0) {
    {
#line 533
    tmp___12 = gettext("Cannot open %s");
#line 533
    tmp___13 = __errno_location();
#line 533
    error(0, *tmp___13, (char const   *)tmp___12, current_file_name);
#line 533
    exit_status = 2;
    }
#line 534
    if (current_header->oldgnu_header.isextended) {
      {
#line 535
      skip_extended_headers();
      }
    }
    {
#line 536
    skip_file(current_stat.st_size);
#line 537
    report_difference((char const   *)((void *)0));
    }
#line 538
    goto quit;
  }
#line 543
  if ((int )current_header->header.typeflag == 83) {
    {
#line 544
    diff_sparse_files(current_stat.st_size);
    }
  } else {
#line 547
    if (multi_volume_option) {
      {
#line 549
      assign_string(& save_name, (char const   *)current_file_name);
#line 550
      save_totsize = current_stat.st_size;
      }
    }
    {
#line 554
    read_and_process((size_t )current_stat.st_size, & process_rawdata);
    }
#line 556
    if (multi_volume_option) {
      {
#line 557
      assign_string(& save_name, (char const   *)((void *)0));
      }
    }
  }
  {
#line 560
  status = close(diff_handle);
  }
#line 561
  if (status < 0) {
    {
#line 562
    tmp___14 = gettext("Error while closing %s");
#line 562
    tmp___15 = __errno_location();
#line 562
    error(0, *tmp___15, (char const   *)tmp___14, current_file_name);
#line 562
    exit_status = 2;
    }
  }
  quit: 
#line 565
  goto switch_break;
  case_49: /* CIL Label */ 
  {
#line 573
  tmp___16 = get_stat_data(& stat_data);
  }
#line 573
  if (! tmp___16) {
#line 574
    goto switch_break;
  }
  {
#line 576
  dev = stat_data.st_dev;
#line 577
  ino = stat_data.st_ino;
#line 578
  status = stat((char const   */* __restrict  */)current_link_name, (struct stat */* __restrict  */)(& stat_data));
  }
#line 579
  if (status < 0) {
    {
#line 581
    tmp___20 = __errno_location();
    }
#line 581
    if (*tmp___20 == 2) {
      {
#line 582
      tmp___17 = gettext("Does not exist");
#line 582
      report_difference((char const   *)tmp___17);
      }
    } else {
      {
#line 585
      tmp___18 = gettext("Cannot stat file %s");
#line 585
      tmp___19 = __errno_location();
#line 585
      error(0, *tmp___19, (char const   *)tmp___18, current_file_name);
#line 586
      report_difference((char const   *)((void *)0));
      }
    }
#line 588
    goto switch_break;
  }
#line 591
  if (stat_data.st_dev != dev) {
#line 591
    goto _L;
  } else
#line 591
  if (stat_data.st_ino != ino) {
    _L: /* CIL Label */ 
    {
#line 593
    tmp___21 = strlen((char const   *)current_link_name);
#line 593
    tmp___22 = xmalloc(100U + tmp___21);
#line 593
    message = (char *)tmp___22;
#line 596
    tmp___23 = gettext("Not linked to %s");
#line 596
    sprintf((char */* __restrict  */)message, (char const   */* __restrict  */)tmp___23,
            current_link_name);
#line 597
    report_difference((char const   *)message);
#line 598
    free((void *)message);
    }
#line 599
    goto switch_break;
  }
#line 602
  goto switch_break;
  case_50: /* CIL Label */ 
  {
#line 611
  status = readlink((char const   */* __restrict  */)current_file_name, (char */* __restrict  */)(linkbuf),
                    (size_t )(sizeof(linkbuf) - 1UL));
  }
#line 613
  if (status < 0) {
    {
#line 615
    tmp___27 = __errno_location();
    }
#line 615
    if (*tmp___27 == 2) {
      {
#line 616
      tmp___24 = gettext("No such file or directory");
#line 616
      report_difference((char const   *)tmp___24);
      }
    } else {
      {
#line 619
      tmp___25 = gettext("Cannot read link %s");
#line 619
      tmp___26 = __errno_location();
#line 619
      error(0, *tmp___26, (char const   *)tmp___25, current_file_name);
#line 620
      report_difference((char const   *)((void *)0));
      }
    }
#line 622
    goto switch_break;
  }
  {
#line 625
  linkbuf[status] = (char )'\000';
#line 626
  tmp___29 = strncmp((char const   *)current_link_name, (char const   *)(linkbuf),
                     (size_t )status);
  }
#line 626
  if (tmp___29 != 0) {
    {
#line 627
    tmp___28 = gettext("Symlink differs");
#line 627
    report_difference((char const   *)tmp___28);
    }
  }
#line 629
  goto switch_break;
  case_51: /* CIL Label */ 
#line 635
  current_stat.st_mode |= 8192U;
#line 636
  goto check_node;
  case_52: /* CIL Label */ 
#line 643
  current_stat.st_mode |= 24576U;
#line 644
  goto check_node;
  case_54: /* CIL Label */ 
#line 652
  current_stat.st_mode |= 4096U;
#line 654
  current_stat.st_rdev = (__dev_t )0;
#line 655
  goto check_node;
  check_node: 
  {
#line 661
  tmp___30 = get_stat_data(& stat_data);
  }
#line 661
  if (! tmp___30) {
#line 662
    goto switch_break;
  }
#line 664
  if (current_stat.st_rdev != stat_data.st_rdev) {
    {
#line 666
    tmp___31 = gettext("Device numbers changed");
#line 666
    report_difference((char const   *)tmp___31);
    }
#line 667
    goto switch_break;
  }
#line 670
  if (current_stat.st_mode != stat_data.st_mode) {
    {
#line 680
    tmp___32 = gettext("Mode or device-type changed");
#line 680
    report_difference((char const   *)tmp___32);
    }
#line 681
    goto switch_break;
  }
#line 684
  goto switch_break;
  case_68: /* CIL Label */ 
  {
#line 688
  tmp___33 = get_directory_contents(current_file_name, (dev_t )0);
#line 688
  dumpdir_buffer = tmp___33;
  }
#line 691
  if (multi_volume_option) {
    {
#line 693
    assign_string(& save_name, (char const   *)current_file_name);
#line 694
    save_totsize = current_stat.st_size;
    }
  }
#line 698
  if (dumpdir_buffer) {
    {
#line 700
    dumpdir_cursor = dumpdir_buffer;
#line 701
    read_and_process((size_t )current_stat.st_size, & process_dumpdir);
#line 702
    free((void *)dumpdir_buffer);
    }
  } else {
    {
#line 705
    read_and_process((size_t )current_stat.st_size, & process_noop);
    }
  }
#line 707
  if (multi_volume_option) {
    {
#line 708
    assign_string(& save_name, (char const   *)((void *)0));
    }
  }
  case_53: /* CIL Label */ 
  {
#line 715
  tmp___34 = strlen((char const   *)current_file_name);
#line 715
  name_length = tmp___34 - 1U;
  }
  really_dir: 
  {
#line 718
  while (1) {
    while_continue: /* CIL Label */ ;
#line 718
    if (name_length) {
#line 718
      if (! ((int )*(current_file_name + name_length) == 47)) {
#line 718
        goto while_break;
      }
    } else {
#line 718
      goto while_break;
    }
#line 719
    tmp___35 = name_length;
#line 719
    name_length --;
#line 719
    *(current_file_name + tmp___35) = (char )'\000';
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 721
  tmp___36 = get_stat_data(& stat_data);
  }
#line 721
  if (! tmp___36) {
#line 722
    goto switch_break;
  }
#line 724
  if (! ((stat_data.st_mode & 61440U) == 16384U)) {
    {
#line 726
    tmp___37 = gettext("No longer a directory");
#line 726
    report_difference((char const   *)tmp___37);
    }
#line 727
    goto switch_break;
  }
#line 730
  if ((stat_data.st_mode & (unsigned int )(3584 | (((64 | (64 >> 3)) | ((64 >> 3) >> 3)) | (((128 | (128 >> 3)) | ((128 >> 3) >> 3)) | ((256 | (256 >> 3)) | ((256 >> 3) >> 3)))))) != (current_stat.st_mode & (unsigned int )(3584 | (((64 | (64 >> 3)) | ((64 >> 3) >> 3)) | (((128 | (128 >> 3)) | ((128 >> 3) >> 3)) | ((256 | (256 >> 3)) | ((256 >> 3) >> 3))))))) {
    {
#line 731
    tmp___38 = gettext("Mode differs");
#line 731
    report_difference((char const   *)tmp___38);
    }
  }
#line 732
  goto switch_break;
  case_86: /* CIL Label */ 
#line 735
  goto switch_break;
  case_77: /* CIL Label */ 
  {
#line 741
  tmp___39 = strlen((char const   *)current_file_name);
#line 741
  name_length = tmp___39 - 1U;
  }
#line 742
  if ((int )*(current_file_name + name_length) == 47) {
#line 743
    goto really_dir;
  }
  {
#line 745
  tmp___40 = get_stat_data(& stat_data);
  }
#line 745
  if (! tmp___40) {
#line 746
    goto switch_break;
  }
#line 748
  if (! ((stat_data.st_mode & 61440U) == 32768U)) {
    {
#line 750
    tmp___41 = gettext("Not a regular file");
#line 750
    report_difference((char const   *)tmp___41);
#line 751
    skip_file(current_stat.st_size);
    }
#line 752
    goto switch_break;
  }
  {
#line 755
  stat_data.st_mode &= (unsigned int )(3584 | (((64 | (64 >> 3)) | ((64 >> 3) >> 3)) | (((128 | (128 >> 3)) | ((128 >> 3) >> 3)) | ((256 | (256 >> 3)) | ((256 >> 3) >> 3)))));
#line 756
  offset = off_from_oct((char const   *)(current_header->oldgnu_header.offset), (size_t )sizeof(current_header->oldgnu_header.offset));
  }
#line 757
  if (stat_data.st_size != current_stat.st_size + offset) {
    {
#line 759
    tmp___42 = gettext("Size differs");
#line 759
    report_difference((char const   *)tmp___42);
#line 760
    skip_file(current_stat.st_size);
    }
#line 761
    goto switch_break;
  }
  {
#line 764
  diff_handle = open((char const   *)current_file_name, 2048);
  }
#line 766
  if (diff_handle < 0) {
    {
#line 768
    tmp___43 = gettext("Cannot open file %s");
#line 768
    tmp___44 = __errno_location();
#line 768
    error(0, *tmp___44, (char const   *)tmp___43, current_file_name);
#line 769
    report_difference((char const   *)((void *)0));
#line 770
    skip_file(current_stat.st_size);
    }
#line 771
    goto switch_break;
  }
  {
#line 774
  tmp___48 = lseek(diff_handle, offset, 0);
  }
#line 774
  if (tmp___48 < 0LL) {
    {
#line 777
    tmp___45 = stringify_uintmax_t_backwards((uintmax_t )offset, buf + sizeof(buf));
#line 777
    tmp___46 = gettext("Cannot seek to %s in file %s");
#line 777
    tmp___47 = __errno_location();
#line 777
    error(0, *tmp___47, (char const   *)tmp___46, tmp___45, current_file_name);
#line 779
    report_difference((char const   *)((void *)0));
    }
#line 780
    goto switch_break;
  }
#line 783
  if (multi_volume_option) {
    {
#line 785
    assign_string(& save_name, (char const   *)current_file_name);
#line 786
    save_totsize = stat_data.st_size;
    }
  }
  {
#line 790
  read_and_process((size_t )current_stat.st_size, & process_rawdata);
  }
#line 792
  if (multi_volume_option) {
    {
#line 793
    assign_string(& save_name, (char const   *)((void *)0));
    }
  }
  {
#line 795
  status = close(diff_handle);
  }
#line 796
  if (status < 0) {
    {
#line 797
    tmp___49 = gettext("Error while closing %s");
#line 797
    tmp___50 = __errno_location();
#line 797
    error(0, *tmp___50, (char const   *)tmp___49, current_file_name);
#line 797
    exit_status = 2;
    }
  }
#line 799
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 802
  return;
}
}
#line 808 "compare.c"
void verify_volume(void) 
{ 
  struct mtop operation ;
  int status ;
  char *tmp ;
  int *tmp___0 ;
  off_t tmp___1 ;
  __off64_t tmp___2 ;
  off_t tmp___3 ;
  int *tmp___4 ;
  unsigned long tmp___5 ;
  int tmp___6 ;
  unsigned long tmp___7 ;
  int tmp___8 ;
  unsigned long tmp___9 ;
  int tmp___10 ;
  unsigned long tmp___11 ;
  int tmp___12 ;
  enum read_header status___0 ;
  enum read_header tmp___13 ;
  int counter ;
  char *tmp___14 ;

  {
#line 811
  if (! diff_buffer) {
    {
#line 812
    diff_init();
    }
  }
  {
#line 825
  fsync(archive);
#line 828
  ioctl(archive, (unsigned long )((unsigned int )(2 << 8) | 75U));
#line 836
  operation.mt_op = (short)2;
#line 837
  operation.mt_count = 1;
  }
#line 838
  if (archive >= 128) {
#line 838
    if (sizeof(struct mtop ) == sizeof(struct mtop [1])) {
#line 838
      if (sizeof(struct mtop ) < (unsigned long )(1 << 14)) {
#line 838
        tmp___9 = sizeof(struct mtop );
      } else {
#line 838
        tmp___9 = (unsigned long )__invalid_size_argument_for_IOC;
      }
    } else {
#line 838
      tmp___9 = (unsigned long )__invalid_size_argument_for_IOC;
    }
    {
#line 838
    tmp___10 = rmt_ioctl__(archive - 128, (int )((unsigned long )(((1U << 30) | (unsigned int )(109 << 8)) | 1U) | (tmp___9 << 16)),
                           (char *)(& operation));
#line 838
    status = tmp___10;
    }
  } else {
#line 838
    if (sizeof(struct mtop ) == sizeof(struct mtop [1])) {
#line 838
      if (sizeof(struct mtop ) < (unsigned long )(1 << 14)) {
#line 838
        tmp___11 = sizeof(struct mtop );
      } else {
#line 838
        tmp___11 = (unsigned long )__invalid_size_argument_for_IOC;
      }
    } else {
#line 838
      tmp___11 = (unsigned long )__invalid_size_argument_for_IOC;
    }
    {
#line 838
    tmp___12 = ioctl(archive, (unsigned long )(((1U << 30) | (unsigned int )(109 << 8)) | 1U) | (tmp___11 << 16),
                     (char *)(& operation));
#line 838
    status = tmp___12;
    }
  }
#line 838
  if (status < 0) {
    {
#line 840
    tmp___4 = __errno_location();
    }
#line 840
    if (*tmp___4 != 5) {
#line 840
      goto _L;
    } else {
#line 840
      if (archive >= 128) {
#line 840
        if (sizeof(struct mtop ) == sizeof(struct mtop [1])) {
#line 840
          if (sizeof(struct mtop ) < (unsigned long )(1 << 14)) {
#line 840
            tmp___5 = sizeof(struct mtop );
          } else {
#line 840
            tmp___5 = (unsigned long )__invalid_size_argument_for_IOC;
          }
        } else {
#line 840
          tmp___5 = (unsigned long )__invalid_size_argument_for_IOC;
        }
        {
#line 840
        tmp___6 = rmt_ioctl__(archive - 128, (int )((unsigned long )(((1U << 30) | (unsigned int )(109 << 8)) | 1U) | (tmp___5 << 16)),
                              (char *)(& operation));
#line 840
        status = tmp___6;
        }
      } else {
#line 840
        if (sizeof(struct mtop ) == sizeof(struct mtop [1])) {
#line 840
          if (sizeof(struct mtop ) < (unsigned long )(1 << 14)) {
#line 840
            tmp___7 = sizeof(struct mtop );
          } else {
#line 840
            tmp___7 = (unsigned long )__invalid_size_argument_for_IOC;
          }
        } else {
#line 840
          tmp___7 = (unsigned long )__invalid_size_argument_for_IOC;
        }
        {
#line 840
        tmp___8 = ioctl(archive, (unsigned long )(((1U << 30) | (unsigned int )(109 << 8)) | 1U) | (tmp___7 << 16),
                        (char *)(& operation));
#line 840
        status = tmp___8;
        }
      }
#line 840
      if (status < 0) {
        _L: /* CIL Label */ 
#line 845
        if (archive >= 128) {
          {
#line 845
          tmp___1 = rmt_lseek__(archive - 128, (off_t )0, 0);
#line 845
          tmp___3 = tmp___1;
          }
        } else {
          {
#line 845
          tmp___2 = lseek(archive, (off_t )0, 0);
#line 845
          tmp___3 = tmp___2;
          }
        }
#line 845
        if (tmp___3 != 0LL) {
          {
#line 849
          tmp = gettext("Could not rewind archive file for verify");
#line 849
          tmp___0 = __errno_location();
#line 849
          error(0, *tmp___0, (char const   *)tmp);
          }
#line 851
          return;
        }
      }
    }
  }
  {
#line 859
  access_mode = (enum access_mode )0;
#line 860
  now_verifying = 1;
#line 862
  flush_read();
  }
  {
#line 863
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 865
    tmp___13 = read_header();
#line 865
    status___0 = tmp___13;
    }
#line 867
    if ((unsigned int )status___0 == 4U) {
#line 869
      counter = 0;
      {
#line 871
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 871
        if (! ((unsigned int )status___0 == 4U)) {
#line 871
          goto while_break___0;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 873
      counter ++;
#line 874
      status___0 = read_header();
#line 876
      tmp___14 = gettext("VERIFY FAILURE: %d invalid header(s) detected");
#line 876
      error(0, 0, (char const   *)tmp___14, counter);
#line 876
      exit_status = 2;
      }
    }
#line 879
    if ((unsigned int )status___0 == 2U) {
#line 880
      goto while_break;
    } else
#line 879
    if ((unsigned int )status___0 == 3U) {
#line 880
      goto while_break;
    }
    {
#line 882
    diff_archive();
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 885
  access_mode = (enum access_mode )1;
#line 886
  now_verifying = 0;
#line 887
  return;
}
}
#line 93 "/usr/include/fcntl.h"
extern int creat(char const   *__file , __mode_t __mode )  __asm__("creat64")  ;
#line 509 "/usr/include/unistd.h"
extern int execlp(char const   *__file , char const   *__arg  , ...) ;
#line 896
extern int ftruncate(int __fd , __off64_t __length )  __asm__("ftruncate64")  ;
#line 112 "/usr/include/sys/wait.h"
extern __pid_t wait(union wait *__stat_loc ) ;
#line 702 "/usr/include/stdlib.h"
extern int system(char const   *__command ) ;
#line 393 "/usr/include/stdio.h"
extern int fscanf(FILE * __restrict  __stream , char const   * __restrict  __format 
                  , ...) ;
#line 326 "common.h"
enum access_mode access_mode  ;
#line 330 "common.h"
FILE *stdlis  ;
#line 331 "common.h"
char *save_name  ;
#line 332 "common.h"
off_t save_sizeleft  ;
#line 333 "common.h"
off_t save_totsize  ;
#line 53 "buffer.c"
static tarlong total_written  ;
#line 54 "buffer.c"
static tarlong bytes_written  ;
#line 60 "buffer.c"
union block *record_start  ;
#line 61 "buffer.c"
union block *record_end  ;
#line 62 "buffer.c"
union block *current_block  ;
#line 64 "buffer.c"
static struct stat archive_stat  ;
#line 66 "buffer.c"
static off_t record_start_block  ;
#line 72
static void backspace_output(void) ;
#line 73
static int new_volume(enum access_mode access___0 ) ;
#line 74
static void write_error(ssize_t status ) ;
#line 75
static void read_error(void) ;
#line 79 "buffer.c"
dev_t ar_dev  ;
#line 80 "buffer.c"
ino_t ar_ino  ;
#line 84 "buffer.c"
static pid_t child_pid  ;
#line 87 "buffer.c"
static int read_error_count  ;
#line 90 "buffer.c"
static int hit_eof  ;
#line 93 "buffer.c"
static int checkpoint  ;
#line 99 "buffer.c"
int file_to_switch_to  =    -1;
#line 102 "buffer.c"
static int volno  =    1;
#line 104 "buffer.c"
static int global_volno  =    1;
#line 121 "buffer.c"
int write_archive_to_stdout  =    0;
#line 125 "buffer.c"
static char *real_s_name  =    (char *)((void *)0);
#line 126 "buffer.c"
static off_t real_s_totsize  ;
#line 127 "buffer.c"
static off_t real_s_sizeleft  ;
#line 147 "buffer.c"
void init_total_written(void) 
{ 


  {
#line 150
  total_written = (tarlong )0;
#line 151
  bytes_written = (tarlong )0;
#line 152
  return;
}
}
#line 154 "buffer.c"
void print_total_written(void) 
{ 
  char *tmp ;

  {
  {
#line 157
  tmp = gettext("Total bytes written: ");
#line 157
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp);
#line 158
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%llu",
          total_written);
#line 159
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
  }
#line 160
  return;
}
}
#line 166 "buffer.c"
off_t current_block_ordinal(void) 
{ 


  {
#line 169
  return (record_start_block + (off_t )(current_block - record_start));
}
}
#line 176 "buffer.c"
void reset_eof(void) 
{ 


  {
#line 179
  if (hit_eof) {
#line 181
    hit_eof = 0;
#line 182
    current_block = record_start;
#line 183
    record_end = record_start + blocking_factor;
#line 184
    access_mode = (enum access_mode )1;
  }
#line 186
  return;
}
}
#line 194 "buffer.c"
union block *find_next_block(void) 
{ 


  {
#line 197
  if ((unsigned long )current_block == (unsigned long )record_end) {
#line 199
    if (hit_eof) {
#line 200
      return ((union block *)((void *)0));
    }
    {
#line 201
    flush_archive();
    }
#line 202
    if ((unsigned long )current_block == (unsigned long )record_end) {
#line 204
      hit_eof = 1;
#line 205
      return ((union block *)((void *)0));
    }
  }
#line 208
  return (current_block);
}
}
#line 217 "buffer.c"
void set_next_block_after(union block *block ) 
{ 


  {
  {
#line 220
  while (1) {
    while_continue: /* CIL Label */ ;
#line 220
    if (! ((unsigned long )block >= (unsigned long )current_block)) {
#line 220
      goto while_break;
    }
#line 221
    current_block ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 227
  if ((unsigned long )current_block > (unsigned long )record_end) {
    {
#line 228
    abort();
    }
  }
#line 229
  return;
}
}
#line 238 "buffer.c"
size_t available_space_after(union block *pointer ) 
{ 


  {
#line 241
  return ((size_t )(record_end->buffer - pointer->buffer));
}
}
#line 248 "buffer.c"
static void xclose(int fd ) 
{ 
  char *tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;

  {
  {
#line 251
  tmp___2 = close(fd);
  }
#line 251
  if (tmp___2 < 0) {
    {
#line 252
    tmp = gettext("Cannot close file #%d");
#line 252
    tmp___0 = __errno_location();
#line 252
    error(0, *tmp___0, (char const   *)tmp, fd);
#line 252
    tmp___1 = gettext("Error is not recoverable: exiting now");
#line 252
    error(2, 0, (char const   *)tmp___1);
    }
  }
#line 253
  return;
}
}
#line 260 "buffer.c"
static void xdup2(int from , int into , char const   *message ) 
{ 
  int status ;
  int tmp ;
  char *tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  int *tmp___3 ;
  char *tmp___4 ;
  int *tmp___5 ;
  char *tmp___6 ;

  {
#line 263
  if (from != into) {
    {
#line 265
    tmp = close(into);
#line 265
    status = tmp;
    }
#line 267
    if (status < 0) {
      {
#line 267
      tmp___3 = __errno_location();
      }
#line 267
      if (*tmp___3 != 9) {
        {
#line 268
        tmp___0 = gettext("Cannot close descriptor %d");
#line 268
        tmp___1 = __errno_location();
#line 268
        error(0, *tmp___1, (char const   *)tmp___0, into);
#line 268
        tmp___2 = gettext("Error is not recoverable: exiting now");
#line 268
        error(2, 0, (char const   *)tmp___2);
        }
      }
    }
    {
#line 269
    status = dup(from);
    }
#line 270
    if (status != into) {
      {
#line 271
      tmp___4 = gettext("Cannot properly duplicate %s");
#line 271
      tmp___5 = __errno_location();
#line 271
      error(0, *tmp___5, (char const   *)tmp___4, message);
#line 271
      tmp___6 = gettext("Error is not recoverable: exiting now");
#line 271
      error(2, 0, (char const   *)tmp___6);
      }
    }
    {
#line 272
    xclose(from);
    }
  }
#line 274
  return;
}
}
#line 305 "buffer.c"
static int is_regular_file(char const   *name ) 
{ 
  struct stat stbuf ;
  int tmp ;

  {
  {
#line 310
  tmp = stat((char const   */* __restrict  */)name, (struct stat */* __restrict  */)(& stbuf));
  }
#line 310
  if (tmp < 0) {
#line 311
    return (1);
  }
#line 313
  if ((stbuf.st_mode & 61440U) == 32768U) {
#line 314
    return (1);
  }
#line 316
  return (0);
}
}
#line 319 "buffer.c"
static ssize_t write_archive_buffer(void) 
{ 
  ssize_t status ;
  ssize_t written ;
  ssize_t tmp ;
  ssize_t tmp___0 ;
  ssize_t tmp___1 ;

  {
#line 323
  written = 0;
  {
#line 325
  while (1) {
    while_continue: /* CIL Label */ ;
#line 325
    if (archive >= 128) {
      {
#line 325
      tmp = rmt_write__(archive - 128, record_start->buffer + written, record_size - (size_t )written);
#line 325
      status = tmp;
      }
    } else {
      {
#line 325
      tmp___0 = full_write(archive, (char const   *)(record_start->buffer + written),
                           record_size - (size_t )written);
#line 325
      status = tmp___0;
      }
    }
#line 325
    if (! (0 <= status)) {
#line 325
      goto while_break;
    }
#line 328
    written += status;
#line 329
    if ((size_t )written == record_size) {
#line 331
      goto while_break;
    } else
#line 329
    if (archive >= 128) {
#line 331
      goto while_break;
    } else
#line 329
    if (! ((archive_stat.st_mode & 61440U) == 4096U)) {
#line 331
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 334
  if (written) {
#line 334
    tmp___1 = written;
  } else {
#line 334
    tmp___1 = status;
  }
#line 334
  return (tmp___1);
}
}
#line 341 "buffer.c"
static void child_open_for_compress(void) 
{ 
  int parent_pipe[2] ;
  int child_pipe[2] ;
  pid_t grandchild_pid ;
  char *tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;
  int *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  int saved_errno ;
  int *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  int *tmp___13 ;
  char *tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  char *tmp___17 ;
  int *tmp___18 ;
  char *tmp___19 ;
  int tmp___20 ;
  char *tmp___21 ;
  int *tmp___22 ;
  char *tmp___23 ;
  char *tmp___24 ;
  char *tmp___25 ;
  int *tmp___26 ;
  char *tmp___27 ;
  char *tmp___28 ;
  char *tmp___29 ;
  int tmp___30 ;
  int tmp___31 ;
  int tmp___32 ;
  char *tmp___33 ;
  int *tmp___34 ;
  char *tmp___35 ;
  ssize_t status ;
  char *cursor ;
  size_t length ;
  size_t size ;
  char *tmp___36 ;
  int *tmp___37 ;
  char *tmp___38 ;

  {
  {
#line 348
  tmp___2 = pipe((int *)(parent_pipe));
  }
#line 348
  if (tmp___2 < 0) {
    {
#line 349
    tmp = gettext("Cannot open pipe");
#line 349
    tmp___0 = __errno_location();
#line 349
    error(0, *tmp___0, (char const   *)tmp);
#line 349
    tmp___1 = gettext("Error is not recoverable: exiting now");
#line 349
    error(2, 0, (char const   *)tmp___1);
    }
  }
  {
#line 351
  child_pid = fork();
  }
#line 352
  if (child_pid < 0) {
    {
#line 353
    tmp___3 = gettext("Cannot fork");
#line 353
    tmp___4 = __errno_location();
#line 353
    error(0, *tmp___4, (char const   *)tmp___3);
#line 353
    tmp___5 = gettext("Error is not recoverable: exiting now");
#line 353
    error(2, 0, (char const   *)tmp___5);
    }
  }
#line 355
  if (child_pid > 0) {
    {
#line 359
    archive = parent_pipe[1];
#line 360
    xclose(parent_pipe[0]);
    }
#line 361
    return;
  }
  {
#line 366
  tmp___6 = gettext("tar (child)");
#line 366
  program_name = (char const   *)tmp___6;
#line 368
  tmp___7 = gettext("(child) Pipe to stdin");
#line 368
  xdup2(parent_pipe[0], 0, (char const   *)tmp___7);
#line 369
  xclose(parent_pipe[1]);
#line 376
  tmp___15 = strcmp(*(archive_name_array + 0), "-");
  }
#line 376
  if (tmp___15 != 0) {
#line 376
    if (! force_local_option) {
      {
#line 376
      rmt_path__ = strchr(*(archive_name_array + 0), ':');
      }
#line 376
      if (rmt_path__) {
#line 376
        if ((unsigned long )rmt_path__ > (unsigned long )*(archive_name_array + 0)) {
#line 376
          if (! ((int )*(rmt_path__ + -1) != 47)) {
#line 376
            goto _L___1;
          }
        } else {
#line 376
          goto _L___1;
        }
      } else {
#line 376
        goto _L___1;
      }
    } else {
      _L___1: /* CIL Label */ 
      {
#line 376
      tmp___16 = is_regular_file(*(archive_name_array + 0));
      }
#line 376
      if (tmp___16) {
#line 380
        if (backup_option) {
          {
#line 381
          maybe_backup_file(*(archive_name_array + 0), 1);
          }
        }
        {
#line 386
        archive = creat(*(archive_name_array + 0), (__mode_t )(((128 | (128 >> 3)) | ((128 >> 3) >> 3)) | ((256 | (256 >> 3)) | ((256 >> 3) >> 3))));
        }
#line 387
        if (archive < 0) {
          {
#line 389
          tmp___8 = __errno_location();
#line 389
          saved_errno = *tmp___8;
          }
#line 391
          if (backup_option) {
            {
#line 392
            undo_last_backup();
            }
          }
          {
#line 393
          tmp___9 = gettext("Cannot open archive %s");
#line 393
          error(0, saved_errno, (char const   *)tmp___9, *(archive_name_array + 0));
#line 393
          tmp___10 = gettext("Error is not recoverable: exiting now");
#line 393
          error(2, 0, (char const   *)tmp___10);
          }
        }
        {
#line 396
        tmp___11 = gettext("Archive to stdout");
#line 396
        xdup2(archive, 1, (char const   *)tmp___11);
#line 397
        execlp(use_compress_program_option, use_compress_program_option, (char *)0);
#line 399
        tmp___12 = gettext("Cannot exec %s");
#line 399
        tmp___13 = __errno_location();
#line 399
        error(0, *tmp___13, (char const   *)tmp___12, use_compress_program_option);
#line 399
        tmp___14 = gettext("Error is not recoverable: exiting now");
#line 399
        error(2, 0, (char const   *)tmp___14);
        }
      }
    }
  }
  {
#line 405
  tmp___20 = pipe((int *)(child_pipe));
  }
#line 405
  if (tmp___20 < 0) {
    {
#line 406
    tmp___17 = gettext("Cannot open pipe");
#line 406
    tmp___18 = __errno_location();
#line 406
    error(0, *tmp___18, (char const   *)tmp___17);
#line 406
    tmp___19 = gettext("Error is not recoverable: exiting now");
#line 406
    error(2, 0, (char const   *)tmp___19);
    }
  }
  {
#line 408
  grandchild_pid = fork();
  }
#line 409
  if (grandchild_pid < 0) {
    {
#line 410
    tmp___21 = gettext("Child cannot fork");
#line 410
    tmp___22 = __errno_location();
#line 410
    error(0, *tmp___22, (char const   *)tmp___21);
#line 410
    tmp___23 = gettext("Error is not recoverable: exiting now");
#line 410
    error(2, 0, (char const   *)tmp___23);
    }
  }
#line 412
  if (grandchild_pid > 0) {
    {
#line 416
    tmp___24 = gettext("((child)) Pipe to stdout");
#line 416
    xdup2(child_pipe[1], 1, (char const   *)tmp___24);
#line 418
    xclose(child_pipe[0]);
#line 419
    execlp(use_compress_program_option, use_compress_program_option, (char *)0);
#line 421
    tmp___25 = gettext("Cannot exec %s");
#line 421
    tmp___26 = __errno_location();
#line 421
    error(0, *tmp___26, (char const   *)tmp___25, use_compress_program_option);
#line 421
    tmp___27 = gettext("Error is not recoverable: exiting now");
#line 421
    error(2, 0, (char const   *)tmp___27);
    }
  }
  {
#line 427
  tmp___28 = gettext("tar (grandchild)");
#line 427
  program_name = (char const   *)tmp___28;
#line 431
  tmp___29 = gettext("(grandchild) Pipe to stdin");
#line 431
  xdup2(child_pipe[0], 0, (char const   *)tmp___29);
#line 432
  xclose(child_pipe[1]);
#line 434
  tmp___32 = strcmp(*(archive_name_array + 0), "-");
  }
#line 434
  if (tmp___32 == 0) {
#line 435
    archive = 1;
  } else
#line 437
  if (! force_local_option) {
    {
#line 437
    rmt_path__ = strchr(*(archive_name_array + 0), ':');
    }
#line 437
    if (rmt_path__) {
#line 437
      if ((unsigned long )rmt_path__ > (unsigned long )*(archive_name_array + 0)) {
#line 437
        if ((int )*(rmt_path__ + -1) != 47) {
          {
#line 437
          tmp___30 = rmt_open__(*(archive_name_array + 0), 65, 128, rsh_command_option);
#line 437
          archive = tmp___30;
          }
        } else {
          {
#line 437
          tmp___31 = creat(*(archive_name_array + 0), (__mode_t )(((128 | (128 >> 3)) | ((128 >> 3) >> 3)) | ((256 | (256 >> 3)) | ((256 >> 3) >> 3))));
#line 437
          archive = tmp___31;
          }
        }
      } else {
        {
#line 437
        tmp___31 = creat(*(archive_name_array + 0), (__mode_t )(((128 | (128 >> 3)) | ((128 >> 3) >> 3)) | ((256 | (256 >> 3)) | ((256 >> 3) >> 3))));
#line 437
        archive = tmp___31;
        }
      }
    } else {
      {
#line 437
      tmp___31 = creat(*(archive_name_array + 0), (__mode_t )(((128 | (128 >> 3)) | ((128 >> 3) >> 3)) | ((256 | (256 >> 3)) | ((256 >> 3) >> 3))));
#line 437
      archive = tmp___31;
      }
    }
  } else {
    {
#line 437
    tmp___31 = creat(*(archive_name_array + 0), (__mode_t )(((128 | (128 >> 3)) | ((128 >> 3) >> 3)) | ((256 | (256 >> 3)) | ((256 >> 3) >> 3))));
#line 437
    archive = tmp___31;
    }
  }
#line 438
  if (archive < 0) {
    {
#line 439
    tmp___33 = gettext("Cannot open archive %s");
#line 439
    tmp___34 = __errno_location();
#line 439
    error(0, *tmp___34, (char const   *)tmp___33, *(archive_name_array + 0));
#line 439
    tmp___35 = gettext("Error is not recoverable: exiting now");
#line 439
    error(2, 0, (char const   *)tmp___35);
    }
  }
  {
#line 444
  while (1) {
    while_continue: /* CIL Label */ ;
#line 446
    status = 0;
#line 452
    length = (size_t )0;
#line 452
    cursor = record_start->buffer;
    {
#line 452
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 452
      if (! (length < record_size)) {
#line 452
        goto while_break___0;
      }
#line 456
      size = record_size - length;
#line 458
      if (size < 512U) {
#line 459
        size = (size_t )512;
      }
      {
#line 460
      status = safe_read(0, (void *)cursor, size);
      }
#line 461
      if (status <= 0) {
#line 462
        goto while_break___0;
      }
#line 452
      length += (size_t )status;
#line 452
      cursor += status;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 465
    if (status < 0) {
      {
#line 466
      tmp___36 = gettext("Cannot read from compression program");
#line 466
      tmp___37 = __errno_location();
#line 466
      error(0, *tmp___37, (char const   *)tmp___36);
#line 466
      tmp___38 = gettext("Error is not recoverable: exiting now");
#line 466
      error(2, 0, (char const   *)tmp___38);
      }
    }
#line 470
    if (status == 0) {
#line 476
      if (length > 0U) {
        {
#line 478
        memset((void *)(record_start->buffer + length), 0, record_size - length);
#line 479
        status = write_archive_buffer();
        }
#line 480
        if ((size_t )status != record_size) {
          {
#line 481
          write_error(status);
          }
        }
      }
#line 485
      goto while_break;
    }
    {
#line 488
    status = write_archive_buffer();
    }
#line 489
    if ((size_t )status != record_size) {
      {
#line 490
      write_error(status);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 496
  exit(exit_status);
  }
}
}
#line 503 "buffer.c"
static void child_open_for_uncompress(void) 
{ 
  int parent_pipe[2] ;
  int child_pipe[2] ;
  pid_t grandchild_pid ;
  char *tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;
  int *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  int *tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  int *tmp___13 ;
  char *tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  char *tmp___17 ;
  int *tmp___18 ;
  char *tmp___19 ;
  int tmp___20 ;
  char *tmp___21 ;
  int *tmp___22 ;
  char *tmp___23 ;
  char *tmp___24 ;
  char *tmp___25 ;
  int *tmp___26 ;
  char *tmp___27 ;
  char *tmp___28 ;
  char *tmp___29 ;
  int tmp___30 ;
  int tmp___31 ;
  int tmp___32 ;
  char *tmp___33 ;
  int *tmp___34 ;
  char *tmp___35 ;
  char *cursor ;
  size_t maximum ;
  size_t count ;
  ssize_t status ;
  ssize_t tmp___36 ;
  ssize_t tmp___37 ;
  char *tmp___38 ;
  int *tmp___39 ;
  char *tmp___40 ;
  char *tmp___41 ;

  {
  {
#line 510
  tmp___2 = pipe((int *)(parent_pipe));
  }
#line 510
  if (tmp___2 < 0) {
    {
#line 511
    tmp = gettext("Cannot open pipe");
#line 511
    tmp___0 = __errno_location();
#line 511
    error(0, *tmp___0, (char const   *)tmp);
#line 511
    tmp___1 = gettext("Error is not recoverable: exiting now");
#line 511
    error(2, 0, (char const   *)tmp___1);
    }
  }
  {
#line 513
  child_pid = fork();
  }
#line 514
  if (child_pid < 0) {
    {
#line 515
    tmp___3 = gettext("Cannot fork");
#line 515
    tmp___4 = __errno_location();
#line 515
    error(0, *tmp___4, (char const   *)tmp___3);
#line 515
    tmp___5 = gettext("Error is not recoverable: exiting now");
#line 515
    error(2, 0, (char const   *)tmp___5);
    }
  }
#line 517
  if (child_pid > 0) {
    {
#line 521
    read_full_records_option = 1;
#line 522
    archive = parent_pipe[0];
#line 523
    xclose(parent_pipe[1]);
    }
#line 524
    return;
  }
  {
#line 529
  tmp___6 = gettext("tar (child)");
#line 529
  program_name = (char const   *)tmp___6;
#line 531
  tmp___7 = gettext("(child) Pipe to stdout");
#line 531
  xdup2(parent_pipe[1], 1, (char const   *)tmp___7);
#line 532
  xclose(parent_pipe[0]);
#line 539
  tmp___15 = strcmp(*(archive_name_array + 0), "-");
  }
#line 539
  if (tmp___15 != 0) {
#line 539
    if (! force_local_option) {
      {
#line 539
      rmt_path__ = strchr(*(archive_name_array + 0), ':');
      }
#line 539
      if (rmt_path__) {
#line 539
        if ((unsigned long )rmt_path__ > (unsigned long )*(archive_name_array + 0)) {
#line 539
          if (! ((int )*(rmt_path__ + -1) != 47)) {
#line 539
            goto _L___1;
          }
        } else {
#line 539
          goto _L___1;
        }
      } else {
#line 539
        goto _L___1;
      }
    } else {
      _L___1: /* CIL Label */ 
      {
#line 539
      tmp___16 = is_regular_file(*(archive_name_array + 0));
      }
#line 539
      if (tmp___16) {
        {
#line 546
        archive = open(*(archive_name_array + 0), 0, ((128 | (128 >> 3)) | ((128 >> 3) >> 3)) | ((256 | (256 >> 3)) | ((256 >> 3) >> 3)));
        }
#line 547
        if (archive < 0) {
          {
#line 548
          tmp___8 = gettext("Cannot open archive %s");
#line 548
          tmp___9 = __errno_location();
#line 548
          error(0, *tmp___9, (char const   *)tmp___8, *(archive_name_array + 0));
#line 548
          tmp___10 = gettext("Error is not recoverable: exiting now");
#line 548
          error(2, 0, (char const   *)tmp___10);
          }
        }
        {
#line 550
        tmp___11 = gettext("Archive to stdin");
#line 550
        xdup2(archive, 0, (char const   *)tmp___11);
#line 551
        execlp(use_compress_program_option, use_compress_program_option, "-d", (char *)0);
#line 553
        tmp___12 = gettext("Cannot exec %s");
#line 553
        tmp___13 = __errno_location();
#line 553
        error(0, *tmp___13, (char const   *)tmp___12, use_compress_program_option);
#line 553
        tmp___14 = gettext("Error is not recoverable: exiting now");
#line 553
        error(2, 0, (char const   *)tmp___14);
        }
      }
    }
  }
  {
#line 559
  tmp___20 = pipe((int *)(child_pipe));
  }
#line 559
  if (tmp___20 < 0) {
    {
#line 560
    tmp___17 = gettext("Cannot open pipe");
#line 560
    tmp___18 = __errno_location();
#line 560
    error(0, *tmp___18, (char const   *)tmp___17);
#line 560
    tmp___19 = gettext("Error is not recoverable: exiting now");
#line 560
    error(2, 0, (char const   *)tmp___19);
    }
  }
  {
#line 562
  grandchild_pid = fork();
  }
#line 563
  if (grandchild_pid < 0) {
    {
#line 564
    tmp___21 = gettext("Child cannot fork");
#line 564
    tmp___22 = __errno_location();
#line 564
    error(0, *tmp___22, (char const   *)tmp___21);
#line 564
    tmp___23 = gettext("Error is not recoverable: exiting now");
#line 564
    error(2, 0, (char const   *)tmp___23);
    }
  }
#line 566
  if (grandchild_pid > 0) {
    {
#line 570
    tmp___24 = gettext("((child)) Pipe to stdin");
#line 570
    xdup2(child_pipe[0], 0, (char const   *)tmp___24);
#line 571
    xclose(child_pipe[1]);
#line 572
    execlp(use_compress_program_option, use_compress_program_option, "-d", (char *)0);
#line 574
    tmp___25 = gettext("Cannot exec %s");
#line 574
    tmp___26 = __errno_location();
#line 574
    error(0, *tmp___26, (char const   *)tmp___25, use_compress_program_option);
#line 574
    tmp___27 = gettext("Error is not recoverable: exiting now");
#line 574
    error(2, 0, (char const   *)tmp___27);
    }
  }
  {
#line 580
  tmp___28 = gettext("tar (grandchild)");
#line 580
  program_name = (char const   *)tmp___28;
#line 584
  tmp___29 = gettext("(grandchild) Pipe to stdout");
#line 584
  xdup2(child_pipe[1], 1, (char const   *)tmp___29);
#line 585
  xclose(child_pipe[0]);
#line 587
  tmp___32 = strcmp(*(archive_name_array + 0), "-");
  }
#line 587
  if (tmp___32 == 0) {
#line 588
    archive = 0;
  } else
#line 590
  if (! force_local_option) {
    {
#line 590
    rmt_path__ = strchr(*(archive_name_array + 0), ':');
    }
#line 590
    if (rmt_path__) {
#line 590
      if ((unsigned long )rmt_path__ > (unsigned long )*(archive_name_array + 0)) {
#line 590
        if ((int )*(rmt_path__ + -1) != 47) {
          {
#line 590
          tmp___30 = rmt_open__(*(archive_name_array + 0), 0, 128, rsh_command_option);
#line 590
          archive = tmp___30;
          }
        } else {
          {
#line 590
          tmp___31 = open(*(archive_name_array + 0), 0, ((128 | (128 >> 3)) | ((128 >> 3) >> 3)) | ((256 | (256 >> 3)) | ((256 >> 3) >> 3)));
#line 590
          archive = tmp___31;
          }
        }
      } else {
        {
#line 590
        tmp___31 = open(*(archive_name_array + 0), 0, ((128 | (128 >> 3)) | ((128 >> 3) >> 3)) | ((256 | (256 >> 3)) | ((256 >> 3) >> 3)));
#line 590
        archive = tmp___31;
        }
      }
    } else {
      {
#line 590
      tmp___31 = open(*(archive_name_array + 0), 0, ((128 | (128 >> 3)) | ((128 >> 3) >> 3)) | ((256 | (256 >> 3)) | ((256 >> 3) >> 3)));
#line 590
      archive = tmp___31;
      }
    }
  } else {
    {
#line 590
    tmp___31 = open(*(archive_name_array + 0), 0, ((128 | (128 >> 3)) | ((128 >> 3) >> 3)) | ((256 | (256 >> 3)) | ((256 >> 3) >> 3)));
#line 590
    archive = tmp___31;
    }
  }
#line 592
  if (archive < 0) {
    {
#line 593
    tmp___33 = gettext("Cannot open archive %s");
#line 593
    tmp___34 = __errno_location();
#line 593
    error(0, *tmp___34, (char const   *)tmp___33, *(archive_name_array + 0));
#line 593
    tmp___35 = gettext("Error is not recoverable: exiting now");
#line 593
    error(2, 0, (char const   *)tmp___35);
    }
  }
  {
#line 598
  while (1) {
    while_continue: /* CIL Label */ ;
#line 605
    read_error_count = 0;
    error_loop: 
#line 608
    if (archive >= 128) {
      {
#line 608
      tmp___36 = rmt_read__(archive - 128, record_start->buffer, record_size);
#line 608
      status = tmp___36;
      }
    } else {
      {
#line 608
      tmp___37 = safe_read(archive, (void *)(record_start->buffer), record_size);
#line 608
      status = tmp___37;
      }
    }
#line 609
    if (status < 0) {
      {
#line 611
      read_error();
      }
#line 612
      goto error_loop;
    }
#line 614
    if (status == 0) {
#line 615
      goto while_break;
    }
#line 616
    cursor = record_start->buffer;
#line 617
    maximum = (size_t )status;
    {
#line 618
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 618
      if (! maximum) {
#line 618
        goto while_break___0;
      }
#line 620
      if (maximum < 512U) {
#line 620
        count = maximum;
      } else {
#line 620
        count = (size_t )512;
      }
      {
#line 621
      status = full_write(1, (char const   *)cursor, count);
      }
#line 622
      if (status < 0) {
        {
#line 623
        tmp___38 = gettext("Cannot write to compression program");
#line 623
        tmp___39 = __errno_location();
#line 623
        error(0, *tmp___39, (char const   *)tmp___38);
#line 623
        tmp___40 = gettext("Error is not recoverable: exiting now");
#line 623
        error(2, 0, (char const   *)tmp___40);
        }
      }
#line 626
      if ((size_t )status != count) {
        {
#line 628
        tmp___41 = gettext("Write to compression program short %lu bytes");
#line 628
        error(0, 0, (char const   *)tmp___41, (unsigned long )(count - (size_t )status));
#line 628
        exit_status = 2;
#line 631
        count = (size_t )status;
        }
      }
#line 634
      cursor += count;
#line 635
      maximum -= count;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 642
  exit(exit_status);
  }
}
}
#line 653 "buffer.c"
static int check_label_pattern(union block *label ) 
{ 
  char *string ;
  int result ;
  int tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;

  {
  {
#line 659
  tmp = fnmatch(volume_label_option, (char const   *)(label->header.name), 0);
  }
#line 659
  if (tmp == 0) {
#line 660
    return (1);
  }
#line 662
  if (! multi_volume_option) {
#line 663
    return (0);
  }
  {
#line 665
  tmp___0 = strlen(volume_label_option);
#line 665
  tmp___1 = xmalloc((size_t )(((unsigned long )tmp___0 + sizeof(" Volume [1-9]*")) + 1UL));
#line 665
  string = (char *)tmp___1;
#line 667
  strcpy((char */* __restrict  */)string, (char const   */* __restrict  */)volume_label_option);
#line 668
  strcat((char */* __restrict  */)string, (char const   */* __restrict  */)" Volume [1-9]*");
#line 669
  tmp___2 = fnmatch((char const   *)string, (char const   *)(label->header.name),
                    0);
#line 669
  result = tmp___2 == 0;
#line 670
  free((void *)string);
  }
#line 671
  return (result);
}
}
#line 819 "buffer.c"
static char const   dev_null[10]  = 
#line 819
  {      (char const   )'/',      (char const   )'d',      (char const   )'e',      (char const   )'v', 
        (char const   )'/',      (char const   )'n',      (char const   )'u',      (char const   )'l', 
        (char const   )'l',      (char const   )'\000'};
#line 679 "buffer.c"
void open_archive(enum access_mode access___0 ) 
{ 
  int backed_up_flag ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;
  char *tmp___14 ;
  char *tmp___15 ;
  int tmp___16 ;
  char *tmp___17 ;
  char *tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  int tmp___27 ;
  int saved_errno ;
  int *tmp___28 ;
  char *tmp___29 ;
  char *tmp___30 ;
  int tmp___31 ;
  struct stat dev_null_stat ;
  int tmp___32 ;
  int tmp___33 ;
  int tmp___34 ;
  union block *label ;
  union block *tmp___35 ;
  char *tmp___36 ;
  char *tmp___37 ;
  char *tmp___38 ;
  char *tmp___39 ;
  int tmp___40 ;
  time_t tmp___41 ;

  {
#line 682
  backed_up_flag = 0;
#line 684
  if (to_stdout_option) {
#line 684
    stdlis = stderr;
  } else {
#line 684
    stdlis = stdout;
  }
#line 686
  if (record_size == 0U) {
    {
#line 687
    tmp = gettext("Invalid value for record_size");
#line 687
    error(0, 0, (char const   *)tmp);
#line 687
    tmp___0 = gettext("Error is not recoverable: exiting now");
#line 687
    error(2, 0, (char const   *)tmp___0);
    }
  }
#line 689
  if (archive_names == 0) {
    {
#line 690
    tmp___1 = gettext("No archive name given");
#line 690
    error(0, 0, (char const   *)tmp___1);
#line 690
    tmp___2 = gettext("Error is not recoverable: exiting now");
#line 690
    error(2, 0, (char const   *)tmp___2);
    }
  }
#line 692
  current_file_name = (char *)((void *)0);
#line 693
  current_link_name = (char *)((void *)0);
#line 701
  if (! real_s_name) {
    {
#line 702
    tmp___3 = xmalloc((size_t )4096);
#line 702
    real_s_name = (char *)tmp___3;
    }
  }
#line 705
  save_name = (char *)((void *)0);
#line 707
  if (multi_volume_option) {
    {
#line 709
    tmp___4 = malloc(record_size + 1024U);
#line 709
    record_start = (union block *)tmp___4;
    }
#line 711
    if (record_start) {
#line 712
      record_start += 2;
    }
  } else {
    {
#line 715
    tmp___5 = malloc(record_size);
#line 715
    record_start = (union block *)tmp___5;
    }
  }
#line 716
  if (! record_start) {
    {
#line 717
    tmp___6 = gettext("Could not allocate memory for blocking factor %d");
#line 717
    error(0, 0, (char const   *)tmp___6, blocking_factor);
#line 717
    tmp___7 = gettext("Error is not recoverable: exiting now");
#line 717
    error(2, 0, (char const   *)tmp___7);
    }
  }
#line 720
  current_block = record_start;
#line 721
  record_end = record_start + blocking_factor;
#line 723
  if ((unsigned int )access___0 == 2U) {
#line 723
    access_mode = (enum access_mode )0;
  } else {
#line 723
    access_mode = access___0;
  }
#line 725
  if (multi_volume_option) {
#line 725
    if (verify_option) {
      {
#line 726
      tmp___8 = gettext("Cannot verify multi-volume archives");
#line 726
      error(0, 0, (char const   *)tmp___8);
#line 726
      tmp___9 = gettext("Error is not recoverable: exiting now");
#line 726
      error(2, 0, (char const   *)tmp___9);
      }
    }
  }
#line 728
  if (use_compress_program_option) {
#line 730
    if (multi_volume_option) {
      {
#line 731
      tmp___10 = gettext("Cannot use multi-volume compressed archives");
#line 731
      error(0, 0, (char const   *)tmp___10);
#line 731
      tmp___11 = gettext("Error is not recoverable: exiting now");
#line 731
      error(2, 0, (char const   *)tmp___11);
      }
    }
#line 732
    if (verify_option) {
      {
#line 733
      tmp___12 = gettext("Cannot verify compressed archives");
#line 733
      error(0, 0, (char const   *)tmp___12);
#line 733
      tmp___13 = gettext("Error is not recoverable: exiting now");
#line 733
      error(2, 0, (char const   *)tmp___13);
      }
    }
    {
#line 737
    if ((unsigned int )access___0 == 0U) {
#line 737
      goto case_0;
    }
#line 741
    if ((unsigned int )access___0 == 1U) {
#line 741
      goto case_1;
    }
#line 745
    if ((unsigned int )access___0 == 2U) {
#line 745
      goto case_2;
    }
#line 735
    goto switch_break;
    case_0: /* CIL Label */ 
    {
#line 738
    child_open_for_uncompress();
    }
#line 739
    goto switch_break;
    case_1: /* CIL Label */ 
    {
#line 742
    child_open_for_compress();
    }
#line 743
    goto switch_break;
    case_2: /* CIL Label */ 
    {
#line 746
    tmp___14 = gettext("Cannot update compressed archives");
#line 746
    error(0, 0, (char const   *)tmp___14);
#line 746
    tmp___15 = gettext("Error is not recoverable: exiting now");
#line 746
    error(2, 0, (char const   *)tmp___15);
    }
#line 747
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 750
    if ((unsigned int )access___0 == 1U) {
      {
#line 750
      tmp___16 = strcmp(*(archive_name_array + 0), "-");
      }
#line 750
      if (tmp___16 == 0) {
#line 751
        stdlis = stderr;
      }
    }
  } else {
    {
#line 753
    tmp___27 = strcmp(*(archive_name_array + 0), "-");
    }
#line 753
    if (tmp___27 == 0) {
#line 755
      read_full_records_option = 1;
#line 756
      if (verify_option) {
        {
#line 757
        tmp___17 = gettext("Cannot verify stdin/stdout archive");
#line 757
        error(0, 0, (char const   *)tmp___17);
#line 757
        tmp___18 = gettext("Error is not recoverable: exiting now");
#line 757
        error(2, 0, (char const   *)tmp___18);
        }
      }
      {
#line 761
      if ((unsigned int )access___0 == 0U) {
#line 761
        goto case_0___0;
      }
#line 765
      if ((unsigned int )access___0 == 1U) {
#line 765
        goto case_1___0;
      }
#line 770
      if ((unsigned int )access___0 == 2U) {
#line 770
        goto case_2___0;
      }
#line 759
      goto switch_break___0;
      case_0___0: /* CIL Label */ 
#line 762
      archive = 0;
#line 763
      goto switch_break___0;
      case_1___0: /* CIL Label */ 
#line 766
      archive = 1;
#line 767
      stdlis = stderr;
#line 768
      goto switch_break___0;
      case_2___0: /* CIL Label */ 
#line 771
      archive = 0;
#line 772
      stdlis = stderr;
#line 773
      write_archive_to_stdout = 1;
#line 774
      goto switch_break___0;
      switch_break___0: /* CIL Label */ ;
      }
    } else
#line 777
    if (verify_option) {
#line 778
      if (! force_local_option) {
        {
#line 778
        rmt_path__ = strchr(*(archive_name_array + 0), ':');
        }
#line 778
        if (rmt_path__) {
#line 778
          if ((unsigned long )rmt_path__ > (unsigned long )*(archive_name_array + 0)) {
#line 778
            if ((int )*(rmt_path__ + -1) != 47) {
              {
#line 778
              tmp___19 = rmt_open__(*(archive_name_array + 0), 66, 128, rsh_command_option);
#line 778
              archive = tmp___19;
              }
            } else {
              {
#line 778
              tmp___20 = open(*(archive_name_array + 0), 66, ((128 | (128 >> 3)) | ((128 >> 3) >> 3)) | ((256 | (256 >> 3)) | ((256 >> 3) >> 3)));
#line 778
              archive = tmp___20;
              }
            }
          } else {
            {
#line 778
            tmp___20 = open(*(archive_name_array + 0), 66, ((128 | (128 >> 3)) | ((128 >> 3) >> 3)) | ((256 | (256 >> 3)) | ((256 >> 3) >> 3)));
#line 778
            archive = tmp___20;
            }
          }
        } else {
          {
#line 778
          tmp___20 = open(*(archive_name_array + 0), 66, ((128 | (128 >> 3)) | ((128 >> 3) >> 3)) | ((256 | (256 >> 3)) | ((256 >> 3) >> 3)));
#line 778
          archive = tmp___20;
          }
        }
      } else {
        {
#line 778
        tmp___20 = open(*(archive_name_array + 0), 66, ((128 | (128 >> 3)) | ((128 >> 3) >> 3)) | ((256 | (256 >> 3)) | ((256 >> 3) >> 3)));
#line 778
        archive = tmp___20;
        }
      }
    } else {
      {
#line 783
      if ((unsigned int )access___0 == 0U) {
#line 783
        goto case_0___1;
      }
#line 788
      if ((unsigned int )access___0 == 1U) {
#line 788
        goto case_1___1;
      }
#line 798
      if ((unsigned int )access___0 == 2U) {
#line 798
        goto case_2___1;
      }
#line 781
      goto switch_break___1;
      case_0___1: /* CIL Label */ 
#line 784
      if (! force_local_option) {
        {
#line 784
        rmt_path__ = strchr(*(archive_name_array + 0), ':');
        }
#line 784
        if (rmt_path__) {
#line 784
          if ((unsigned long )rmt_path__ > (unsigned long )*(archive_name_array + 0)) {
#line 784
            if ((int )*(rmt_path__ + -1) != 47) {
              {
#line 784
              tmp___21 = rmt_open__(*(archive_name_array + 0), 0, 128, rsh_command_option);
#line 784
              archive = tmp___21;
              }
            } else {
              {
#line 784
              tmp___22 = open(*(archive_name_array + 0), 0, ((128 | (128 >> 3)) | ((128 >> 3) >> 3)) | ((256 | (256 >> 3)) | ((256 >> 3) >> 3)));
#line 784
              archive = tmp___22;
              }
            }
          } else {
            {
#line 784
            tmp___22 = open(*(archive_name_array + 0), 0, ((128 | (128 >> 3)) | ((128 >> 3) >> 3)) | ((256 | (256 >> 3)) | ((256 >> 3) >> 3)));
#line 784
            archive = tmp___22;
            }
          }
        } else {
          {
#line 784
          tmp___22 = open(*(archive_name_array + 0), 0, ((128 | (128 >> 3)) | ((128 >> 3) >> 3)) | ((256 | (256 >> 3)) | ((256 >> 3) >> 3)));
#line 784
          archive = tmp___22;
          }
        }
      } else {
        {
#line 784
        tmp___22 = open(*(archive_name_array + 0), 0, ((128 | (128 >> 3)) | ((128 >> 3) >> 3)) | ((256 | (256 >> 3)) | ((256 >> 3) >> 3)));
#line 784
        archive = tmp___22;
        }
      }
#line 786
      goto switch_break___1;
      case_1___1: /* CIL Label */ 
#line 789
      if (backup_option) {
        {
#line 791
        maybe_backup_file(*(archive_name_array + 0), 1);
#line 792
        backed_up_flag = 1;
        }
      }
#line 794
      if (! force_local_option) {
        {
#line 794
        rmt_path__ = strchr(*(archive_name_array + 0), ':');
        }
#line 794
        if (rmt_path__) {
#line 794
          if ((unsigned long )rmt_path__ > (unsigned long )*(archive_name_array + 0)) {
#line 794
            if ((int )*(rmt_path__ + -1) != 47) {
              {
#line 794
              tmp___23 = rmt_open__(*(archive_name_array + 0), 65, 128, rsh_command_option);
#line 794
              archive = tmp___23;
              }
            } else {
              {
#line 794
              tmp___24 = creat(*(archive_name_array + 0), (__mode_t )(((128 | (128 >> 3)) | ((128 >> 3) >> 3)) | ((256 | (256 >> 3)) | ((256 >> 3) >> 3))));
#line 794
              archive = tmp___24;
              }
            }
          } else {
            {
#line 794
            tmp___24 = creat(*(archive_name_array + 0), (__mode_t )(((128 | (128 >> 3)) | ((128 >> 3) >> 3)) | ((256 | (256 >> 3)) | ((256 >> 3) >> 3))));
#line 794
            archive = tmp___24;
            }
          }
        } else {
          {
#line 794
          tmp___24 = creat(*(archive_name_array + 0), (__mode_t )(((128 | (128 >> 3)) | ((128 >> 3) >> 3)) | ((256 | (256 >> 3)) | ((256 >> 3) >> 3))));
#line 794
          archive = tmp___24;
          }
        }
      } else {
        {
#line 794
        tmp___24 = creat(*(archive_name_array + 0), (__mode_t )(((128 | (128 >> 3)) | ((128 >> 3) >> 3)) | ((256 | (256 >> 3)) | ((256 >> 3) >> 3))));
#line 794
        archive = tmp___24;
        }
      }
#line 796
      goto switch_break___1;
      case_2___1: /* CIL Label */ 
#line 799
      if (! force_local_option) {
        {
#line 799
        rmt_path__ = strchr(*(archive_name_array + 0), ':');
        }
#line 799
        if (rmt_path__) {
#line 799
          if ((unsigned long )rmt_path__ > (unsigned long )*(archive_name_array + 0)) {
#line 799
            if ((int )*(rmt_path__ + -1) != 47) {
              {
#line 799
              tmp___25 = rmt_open__(*(archive_name_array + 0), 66, 128, rsh_command_option);
#line 799
              archive = tmp___25;
              }
            } else {
              {
#line 799
              tmp___26 = open(*(archive_name_array + 0), 66, ((128 | (128 >> 3)) | ((128 >> 3) >> 3)) | ((256 | (256 >> 3)) | ((256 >> 3) >> 3)));
#line 799
              archive = tmp___26;
              }
            }
          } else {
            {
#line 799
            tmp___26 = open(*(archive_name_array + 0), 66, ((128 | (128 >> 3)) | ((128 >> 3) >> 3)) | ((256 | (256 >> 3)) | ((256 >> 3) >> 3)));
#line 799
            archive = tmp___26;
            }
          }
        } else {
          {
#line 799
          tmp___26 = open(*(archive_name_array + 0), 66, ((128 | (128 >> 3)) | ((128 >> 3) >> 3)) | ((256 | (256 >> 3)) | ((256 >> 3) >> 3)));
#line 799
          archive = tmp___26;
          }
        }
      } else {
        {
#line 799
        tmp___26 = open(*(archive_name_array + 0), 66, ((128 | (128 >> 3)) | ((128 >> 3) >> 3)) | ((256 | (256 >> 3)) | ((256 >> 3) >> 3)));
#line 799
        archive = tmp___26;
        }
      }
#line 801
      goto switch_break___1;
      switch_break___1: /* CIL Label */ ;
      }
    }
  }
#line 804
  if (archive < 0) {
#line 804
    goto _L;
  } else
#line 804
  if (! (archive >= 128)) {
    {
#line 804
    tmp___31 = fstat(archive, & archive_stat);
    }
#line 804
    if (tmp___31 < 0) {
      _L: /* CIL Label */ 
      {
#line 807
      tmp___28 = __errno_location();
#line 807
      saved_errno = *tmp___28;
      }
#line 809
      if (backed_up_flag) {
        {
#line 810
        undo_last_backup();
        }
      }
      {
#line 811
      tmp___29 = gettext("Cannot open %s");
#line 811
      error(0, saved_errno, (char const   *)tmp___29, *(archive_name_array + 0));
#line 811
      tmp___30 = gettext("Error is not recoverable: exiting now");
#line 811
      error(2, 0, (char const   *)tmp___30);
      }
    }
  }
  {
#line 822
  tmp___32 = strcmp(*(archive_name_array + 0), dev_null);
  }
#line 822
  if (tmp___32 == 0) {
#line 822
    tmp___34 = 1;
  } else
#line 822
  if (! (archive >= 128)) {
    {
#line 822
    tmp___33 = stat((char const   */* __restrict  */)(dev_null), (struct stat */* __restrict  */)(& dev_null_stat));
    }
#line 822
    if (tmp___33 == 0) {
#line 822
      if ((archive_stat.st_mode & 61440U) == 8192U) {
#line 822
        if (archive_stat.st_rdev == dev_null_stat.st_rdev) {
#line 822
          tmp___34 = 1;
        } else {
#line 822
          tmp___34 = 0;
        }
      } else {
#line 822
        tmp___34 = 0;
      }
    } else {
#line 822
      tmp___34 = 0;
    }
  } else {
#line 822
    tmp___34 = 0;
  }
#line 822
  dev_null_output = tmp___34;
#line 830
  if (! (archive >= 128)) {
#line 830
    if ((archive_stat.st_mode & 61440U) == 32768U) {
#line 832
      ar_dev = archive_stat.st_dev;
#line 833
      ar_ino = archive_stat.st_ino;
    } else {
#line 836
      ar_dev = (dev_t )0;
    }
  } else {
#line 836
    ar_dev = (dev_t )0;
  }
  {
#line 847
  if ((unsigned int )access___0 == 2U) {
#line 847
    goto case_2___2;
  }
#line 847
  if ((unsigned int )access___0 == 0U) {
#line 847
    goto case_2___2;
  }
#line 864
  if ((unsigned int )access___0 == 1U) {
#line 864
    goto case_1___2;
  }
#line 844
  goto switch_break___2;
  case_2___2: /* CIL Label */ 
  case_0___2: /* CIL Label */ 
  {
#line 848
  record_end = record_start;
#line 849
  find_next_block();
  }
#line 851
  if (volume_label_option) {
    {
#line 853
    tmp___35 = find_next_block();
#line 853
    label = tmp___35;
    }
#line 855
    if (! label) {
      {
#line 856
      tmp___36 = gettext("Archive not labelled to match `%s\'");
#line 856
      error(0, 0, (char const   *)tmp___36, volume_label_option);
#line 856
      tmp___37 = gettext("Error is not recoverable: exiting now");
#line 856
      error(2, 0, (char const   *)tmp___37);
      }
    }
    {
#line 858
    tmp___40 = check_label_pattern(label);
    }
#line 858
    if (! tmp___40) {
      {
#line 859
      tmp___38 = gettext("Volume `%s\' does not match `%s\'");
#line 859
      error(0, 0, (char const   *)tmp___38, label->header.name, volume_label_option);
#line 859
      tmp___39 = gettext("Error is not recoverable: exiting now");
#line 859
      error(2, 0, (char const   *)tmp___39);
      }
    }
  }
#line 862
  goto switch_break___2;
  case_1___2: /* CIL Label */ 
#line 865
  if (volume_label_option) {
    {
#line 867
    memset((void *)record_start, 0, (size_t )512);
    }
#line 868
    if (multi_volume_option) {
      {
#line 869
      sprintf((char */* __restrict  */)(record_start->header.name), (char const   */* __restrict  */)"%s Volume 1",
              volume_label_option);
      }
    } else {
      {
#line 872
      strcpy((char */* __restrict  */)(record_start->header.name), (char const   */* __restrict  */)volume_label_option);
      }
    }
    {
#line 874
    assign_string(& current_file_name, (char const   *)(record_start->header.name));
#line 876
    record_start->header.typeflag = (char )'V';
#line 877
    tmp___41 = time((time_t *)0);
#line 877
    time_to_oct(tmp___41, record_start->header.mtime, (size_t )sizeof(record_start->header.mtime));
#line 878
    finish_header(record_start);
    }
  }
#line 883
  goto switch_break___2;
  switch_break___2: /* CIL Label */ ;
  }
#line 885
  return;
}
}
#line 891 "buffer.c"
void flush_write(void) 
{ 
  int copy_back ;
  ssize_t status ;
  char *tmp ;
  int *tmp___0 ;
  char *cursor ;
  int *tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;
  int tmp___4 ;
  time_t tmp___5 ;
  int tmp___6 ;
  char *cursor___0 ;

  {
#line 897
  if (checkpoint_option) {
#line 897
    checkpoint ++;
#line 897
    if (! (checkpoint % 10)) {
      {
#line 898
      tmp = gettext("Write checkpoint %d");
#line 898
      error(0, 0, (char const   *)tmp, checkpoint);
      }
    }
  }
#line 900
  if (! (tape_length_option == 0ULL)) {
#line 900
    if (! (bytes_written < tape_length_option)) {
      {
#line 903
      tmp___0 = __errno_location();
#line 903
      *tmp___0 = 28;
#line 904
      status = 0;
      }
    } else {
#line 900
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 906
  if (dev_null_output) {
#line 907
    status = (ssize_t )record_size;
  } else {
    {
#line 909
    status = write_archive_buffer();
    }
  }
#line 910
  if ((size_t )status != record_size) {
#line 910
    if (! multi_volume_option) {
      {
#line 911
      write_error(status);
      }
    } else {
#line 910
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 912
  if (totals_option) {
#line 913
    total_written += (tarlong )record_size;
  }
#line 915
  if (status > 0) {
#line 916
    bytes_written += (tarlong )status;
  }
#line 918
  if ((size_t )status == record_size) {
#line 920
    if (multi_volume_option) {
#line 924
      if (! save_name) {
#line 926
        *(real_s_name + 0) = (char )'\000';
#line 927
        real_s_totsize = (off_t )0;
#line 928
        real_s_sizeleft = (off_t )0;
#line 929
        return;
      }
#line 932
      cursor = save_name;
      {
#line 937
      while (1) {
        while_continue: /* CIL Label */ ;
#line 937
        if (! ((int )*cursor == 47)) {
#line 937
          goto while_break;
        }
#line 938
        cursor ++;
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 940
      strcpy((char */* __restrict  */)real_s_name, (char const   */* __restrict  */)cursor);
#line 941
      real_s_totsize = save_totsize;
#line 942
      real_s_sizeleft = save_sizeleft;
      }
    }
#line 944
    return;
  }
#line 950
  if (status < 0) {
    {
#line 950
    tmp___1 = __errno_location();
    }
#line 950
    if (*tmp___1 != 28) {
      {
#line 950
      tmp___2 = __errno_location();
      }
#line 950
      if (*tmp___2 != 5) {
        {
#line 950
        tmp___3 = __errno_location();
        }
#line 950
        if (*tmp___3 != 6) {
          {
#line 951
          write_error(status);
          }
        }
      }
    }
  }
  {
#line 955
  tmp___4 = new_volume((enum access_mode )1);
  }
#line 955
  if (! tmp___4) {
#line 956
    return;
  }
#line 958
  bytes_written = (tarlong )0;
#line 960
  if (volume_label_option) {
#line 960
    if (*(real_s_name + 0)) {
#line 962
      copy_back = 2;
#line 963
      record_start -= 2;
    } else {
#line 960
      goto _L___1;
    }
  } else
  _L___1: /* CIL Label */ 
#line 965
  if (volume_label_option) {
#line 967
    copy_back = 1;
#line 968
    record_start --;
  } else
#line 965
  if (*(real_s_name + 0)) {
#line 967
    copy_back = 1;
#line 968
    record_start --;
  } else {
#line 971
    copy_back = 0;
  }
#line 973
  if (volume_label_option) {
    {
#line 975
    memset((void *)record_start, 0, (size_t )512);
#line 976
    sprintf((char */* __restrict  */)(record_start->header.name), (char const   */* __restrict  */)"%s Volume %d",
            volume_label_option, volno);
#line 977
    tmp___5 = time((time_t *)0);
#line 977
    time_to_oct(tmp___5, record_start->header.mtime, (size_t )sizeof(record_start->header.mtime));
#line 978
    record_start->header.typeflag = (char )'V';
#line 979
    finish_header(record_start);
    }
  }
#line 982
  if (*(real_s_name + 0)) {
#line 986
    if (volume_label_option) {
#line 987
      record_start ++;
    }
    {
#line 989
    memset((void *)record_start, 0, (size_t )512);
#line 995
    strcpy((char */* __restrict  */)(record_start->header.name), (char const   */* __restrict  */)real_s_name);
#line 996
    record_start->header.typeflag = (char )'M';
#line 997
    off_to_oct(real_s_sizeleft, record_start->header.size, (size_t )sizeof(record_start->header.size));
#line 998
    off_to_oct(real_s_totsize - real_s_sizeleft, record_start->oldgnu_header.offset,
               (size_t )sizeof(record_start->oldgnu_header.offset));
#line 1000
    tmp___6 = verbose_option;
#line 1001
    verbose_option = 0;
#line 1002
    finish_header(record_start);
#line 1003
    verbose_option = tmp___6;
    }
#line 1005
    if (volume_label_option) {
#line 1006
      record_start --;
    }
  }
  {
#line 1009
  status = write_archive_buffer();
  }
#line 1010
  if ((size_t )status != record_size) {
    {
#line 1011
    write_error(status);
    }
  } else
#line 1012
  if (totals_option) {
#line 1013
    total_written += (tarlong )record_size;
  }
#line 1015
  bytes_written += (tarlong )record_size;
#line 1016
  if (copy_back) {
    {
#line 1018
    record_start += copy_back;
#line 1019
    memcpy((void */* __restrict  */)((void *)current_block), (void const   */* __restrict  */)((void *)((record_start + blocking_factor) - copy_back)),
           (size_t )(copy_back * 512));
#line 1022
    current_block += copy_back;
    }
#line 1024
    if (real_s_sizeleft >= (off_t )(copy_back * 512)) {
#line 1025
      real_s_sizeleft -= (off_t )(copy_back * 512);
    } else
#line 1026
    if (((real_s_sizeleft + 512LL) - 1LL) / 512LL <= (off_t )copy_back) {
#line 1027
      *(real_s_name + 0) = (char )'\000';
    } else {
#line 1030
      cursor___0 = save_name;
      {
#line 1036
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1036
        if (! ((int )*cursor___0 == 47)) {
#line 1036
          goto while_break___0;
        }
#line 1037
        cursor___0 ++;
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 1039
      strcpy((char */* __restrict  */)real_s_name, (char const   */* __restrict  */)cursor___0);
#line 1040
      real_s_sizeleft = save_sizeleft;
#line 1041
      real_s_totsize = save_totsize;
      }
    }
#line 1043
    copy_back = 0;
  }
#line 1045
  return;
}
}
#line 1053 "buffer.c"
static void write_error(ssize_t status ) 
{ 
  int saved_errno ;
  int *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;

  {
  {
#line 1056
  tmp = __errno_location();
#line 1056
  saved_errno = *tmp;
  }
#line 1060
  if (totals_option) {
    {
#line 1061
    print_total_written();
    }
  }
#line 1063
  if (status < 0) {
    {
#line 1064
    tmp___0 = gettext("Cannot write to %s");
#line 1064
    error(0, saved_errno, (char const   *)tmp___0, *archive_name_cursor);
#line 1064
    tmp___1 = gettext("Error is not recoverable: exiting now");
#line 1064
    error(2, 0, (char const   *)tmp___1);
    }
  } else {
    {
#line 1067
    tmp___2 = gettext("Only wrote %lu of %lu bytes to %s");
#line 1067
    error(0, 0, (char const   *)tmp___2, (unsigned long )status, (unsigned long )record_size,
          *archive_name_cursor);
#line 1067
    tmp___3 = gettext("Error is not recoverable: exiting now");
#line 1067
    error(2, 0, (char const   *)tmp___3);
    }
  }
#line 1070
  return;
}
}
#line 1077 "buffer.c"
static void read_error(void) 
{ 
  char *tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;

  {
  {
#line 1080
  tmp = gettext("Read error on %s");
#line 1080
  tmp___0 = __errno_location();
#line 1080
  error(0, *tmp___0, (char const   *)tmp, *archive_name_cursor);
  }
#line 1082
  if (record_start_block == 0LL) {
    {
#line 1083
    tmp___1 = gettext("At beginning of tape, quitting now");
#line 1083
    error(0, 0, (char const   *)tmp___1);
#line 1083
    tmp___2 = gettext("Error is not recoverable: exiting now");
#line 1083
    error(2, 0, (char const   *)tmp___2);
    }
  }
#line 1088
  tmp___5 = read_error_count;
#line 1088
  read_error_count ++;
#line 1088
  if (tmp___5 > 10) {
    {
#line 1089
    tmp___3 = gettext("Too many errors, quitting");
#line 1089
    error(0, 0, (char const   *)tmp___3);
#line 1089
    tmp___4 = gettext("Error is not recoverable: exiting now");
#line 1089
    error(2, 0, (char const   *)tmp___4);
    }
  }
#line 1090
  return;
}
}
#line 1097 "buffer.c"
void flush_read(void) 
{ 
  ssize_t status ;
  size_t left ;
  char *more ;
  char *tmp ;
  char *cursor ;
  ssize_t tmp___0 ;
  ssize_t tmp___1 ;
  union block *cursor___0 ;
  int tmp___2 ;
  int tmp___3 ;
  ssize_t tmp___4 ;
  ssize_t tmp___5 ;
  char *tmp___6 ;
  int tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  uintmax_t s1 ;
  uintmax_t s2 ;
  char *tmp___10 ;
  int tmp___11 ;
  char totsizebuf[(((sizeof(uintmax_t ) * 8UL) * 302UL) / 1000UL + 1UL) + 1UL] ;
  char s1buf[(((sizeof(uintmax_t ) * 8UL) * 302UL) / 1000UL + 1UL) + 1UL] ;
  char s2buf[(((sizeof(uintmax_t ) * 8UL) * 302UL) / 1000UL + 1UL) + 1UL] ;
  char *tmp___12 ;
  char *tmp___13 ;
  char *tmp___14 ;
  char *tmp___15 ;
  char *tmp___16 ;
  off_t tmp___17 ;
  int *tmp___18 ;
  char *tmp___19 ;
  ssize_t tmp___20 ;
  ssize_t tmp___21 ;
  char *tmp___22 ;
  char *tmp___23 ;
  char *tmp___24 ;
  char *tmp___25 ;

  {
#line 1104
  if (checkpoint_option) {
#line 1104
    checkpoint ++;
#line 1104
    if (! (checkpoint % 10)) {
      {
#line 1105
      tmp = gettext("Read checkpoint %d");
#line 1105
      error(0, 0, (char const   *)tmp, checkpoint);
      }
    }
  }
#line 1110
  read_error_count = 0;
#line 1112
  if (write_archive_to_stdout) {
#line 1112
    if (record_start_block != 0LL) {
      {
#line 1114
      status = write_archive_buffer();
      }
#line 1115
      if ((size_t )status != record_size) {
        {
#line 1116
        write_error(status);
        }
      }
    }
  }
#line 1118
  if (multi_volume_option) {
#line 1120
    if (save_name) {
#line 1122
      cursor = save_name;
      {
#line 1128
      while (1) {
        while_continue: /* CIL Label */ ;
#line 1128
        if (! ((int )*cursor == 47)) {
#line 1128
          goto while_break;
        }
#line 1129
        cursor ++;
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 1131
      strcpy((char */* __restrict  */)real_s_name, (char const   */* __restrict  */)cursor);
#line 1132
      real_s_sizeleft = save_sizeleft;
#line 1133
      real_s_totsize = save_totsize;
      }
    } else {
#line 1137
      *(real_s_name + 0) = (char )'\000';
#line 1138
      real_s_totsize = (off_t )0;
#line 1139
      real_s_sizeleft = (off_t )0;
    }
  }
  error_loop: 
#line 1144
  if (archive >= 128) {
    {
#line 1144
    tmp___0 = rmt_read__(archive - 128, record_start->buffer, record_size);
#line 1144
    status = tmp___0;
    }
  } else {
    {
#line 1144
    tmp___1 = safe_read(archive, (void *)(record_start->buffer), record_size);
#line 1144
    status = tmp___1;
    }
  }
#line 1145
  if ((size_t )status == record_size) {
#line 1146
    return;
  }
#line 1148
  if (status == 0) {
#line 1148
    goto _L___1;
  } else
#line 1148
  if (status < 0) {
    {
#line 1148
    tmp___18 = __errno_location();
    }
#line 1148
    if (*tmp___18 == 28) {
#line 1148
      goto _L___1;
    } else {
#line 1148
      goto _L___3;
    }
  } else
  _L___3: /* CIL Label */ 
#line 1148
  if (status > 0) {
#line 1148
    if (! read_full_records_option) {
      _L___1: /* CIL Label */ 
#line 1148
      if (multi_volume_option) {
        try_volume: 
        {
#line 1160
        if ((unsigned int )subcommand_option == 8U) {
#line 1160
          goto case_8;
        }
#line 1160
        if ((unsigned int )subcommand_option == 2U) {
#line 1160
          goto case_8;
        }
#line 1160
        if ((unsigned int )subcommand_option == 1U) {
#line 1160
          goto case_8;
        }
#line 1165
        goto switch_default;
        case_8: /* CIL Label */ 
        case_2: /* CIL Label */ 
        case_1: /* CIL Label */ 
        {
#line 1161
        tmp___2 = new_volume((enum access_mode )2);
        }
#line 1161
        if (! tmp___2) {
#line 1162
          return;
        }
#line 1163
        goto switch_break;
        switch_default: /* CIL Label */ 
        {
#line 1166
        tmp___3 = new_volume((enum access_mode )0);
        }
#line 1166
        if (! tmp___3) {
#line 1167
          return;
        }
#line 1168
        goto switch_break;
        switch_break: /* CIL Label */ ;
        }
        vol_error: 
#line 1172
        if (archive >= 128) {
          {
#line 1172
          tmp___4 = rmt_read__(archive - 128, record_start->buffer, record_size);
#line 1172
          status = tmp___4;
          }
        } else {
          {
#line 1172
          tmp___5 = safe_read(archive, (void *)(record_start->buffer), record_size);
#line 1172
          status = tmp___5;
          }
        }
#line 1173
        if (status < 0) {
          {
#line 1175
          read_error();
          }
#line 1176
          goto vol_error;
        }
#line 1178
        if ((size_t )status != record_size) {
#line 1179
          goto short_read;
        }
#line 1181
        cursor___0 = record_start;
#line 1183
        if ((int )cursor___0->header.typeflag == 86) {
#line 1185
          if (volume_label_option) {
            {
#line 1187
            tmp___7 = check_label_pattern(cursor___0);
            }
#line 1187
            if (! tmp___7) {
              {
#line 1189
              tmp___6 = gettext("Volume `%s\' does not match `%s\'");
#line 1189
              error(0, 0, (char const   *)tmp___6, cursor___0->header.name, volume_label_option);
#line 1191
              volno --;
#line 1192
              global_volno --;
              }
#line 1193
              goto try_volume;
            }
          }
#line 1196
          if (verbose_option) {
            {
#line 1197
            tmp___8 = gettext("Reading %s\n");
#line 1197
            fprintf((FILE */* __restrict  */)stdlis, (char const   */* __restrict  */)tmp___8,
                    cursor___0->header.name);
            }
          }
#line 1198
          cursor___0 ++;
        } else
#line 1200
        if (volume_label_option) {
          {
#line 1201
          tmp___9 = gettext("WARNING: No volume header");
#line 1201
          error(0, 0, (char const   *)tmp___9);
          }
        }
#line 1203
        if (*(real_s_name + 0)) {
#line 1206
          if ((int )cursor___0->header.typeflag != 77) {
            {
#line 1209
            tmp___10 = gettext("%s is not continued on this volume");
#line 1209
            error(0, 0, (char const   *)tmp___10, real_s_name);
#line 1211
            volno --;
#line 1212
            global_volno --;
            }
#line 1213
            goto try_volume;
          } else {
            {
#line 1206
            tmp___11 = strcmp((char const   *)(cursor___0->header.name), (char const   *)real_s_name);
            }
#line 1206
            if (tmp___11) {
              {
#line 1209
              tmp___10 = gettext("%s is not continued on this volume");
#line 1209
              error(0, 0, (char const   *)tmp___10, real_s_name);
#line 1211
              volno --;
#line 1212
              global_volno --;
              }
#line 1213
              goto try_volume;
            }
          }
          {
#line 1215
          s1 = uintmax_from_oct((char const   *)(cursor___0->header.size), (size_t )sizeof(cursor___0->header.size));
#line 1216
          s2 = uintmax_from_oct((char const   *)(cursor___0->oldgnu_header.offset),
                                (size_t )sizeof(cursor___0->oldgnu_header.offset));
          }
#line 1217
          if ((uintmax_t )real_s_totsize != s1 + s2) {
#line 1217
            goto _L;
          } else
#line 1217
          if (s1 + s2 < s2) {
            _L: /* CIL Label */ 
            {
#line 1223
            tmp___12 = stringify_uintmax_t_backwards(s2, s2buf + sizeof(s2buf));
#line 1223
            tmp___13 = stringify_uintmax_t_backwards(s1, s1buf + sizeof(s1buf));
#line 1223
            tmp___14 = stringify_uintmax_t_backwards((uintmax_t )save_totsize, totsizebuf + sizeof(totsizebuf));
#line 1223
            tmp___15 = gettext("%s is the wrong size (%s != %s + %s)");
#line 1223
            error(0, 0, (char const   *)tmp___15, cursor___0->header.name, tmp___14,
                  tmp___13, tmp___12);
#line 1228
            volno --;
#line 1229
            global_volno --;
            }
#line 1230
            goto try_volume;
          }
          {
#line 1232
          tmp___17 = off_from_oct((char const   *)(cursor___0->oldgnu_header.offset),
                                  (size_t )sizeof(cursor___0->oldgnu_header.offset));
          }
#line 1232
          if (real_s_totsize - real_s_sizeleft != tmp___17) {
            {
#line 1235
            tmp___16 = gettext("This volume is out of sequence");
#line 1235
            error(0, 0, (char const   *)tmp___16);
#line 1236
            volno --;
#line 1237
            global_volno --;
            }
#line 1238
            goto try_volume;
          }
#line 1240
          cursor___0 ++;
        }
#line 1242
        current_block = cursor___0;
#line 1243
        return;
      } else {
#line 1148
        goto _L___2;
      }
    } else {
#line 1148
      goto _L___2;
    }
  } else
  _L___2: /* CIL Label */ 
#line 1245
  if (status < 0) {
    {
#line 1247
    read_error();
    }
#line 1248
    goto error_loop;
  }
  short_read: 
#line 1252
  more = record_start->buffer + status;
#line 1253
  left = record_size - (size_t )status;
  again: 
#line 1256
  if (left % 512U == 0U) {
#line 1261
    if (! read_full_records_option) {
#line 1261
      if (verbose_option) {
#line 1261
        if (record_start_block == 0LL) {
#line 1261
          if (status > 0) {
            {
#line 1263
            tmp___19 = gettext("Record size = %lu blocks");
#line 1263
            error(0, 0, (char const   *)tmp___19, (unsigned long )(status / 512));
            }
          }
        }
      }
    }
#line 1266
    record_end = record_start + (record_size - left) / 512U;
#line 1268
    return;
  }
#line 1270
  if (read_full_records_option) {
#line 1274
    if (left > 0U) {
      error2loop: 
#line 1277
      if (archive >= 128) {
        {
#line 1277
        tmp___20 = rmt_read__(archive - 128, more, left);
#line 1277
        status = tmp___20;
        }
      } else {
        {
#line 1277
        tmp___21 = safe_read(archive, (void *)more, left);
#line 1277
        status = tmp___21;
        }
      }
#line 1278
      if (status < 0) {
        {
#line 1280
        read_error();
        }
#line 1281
        goto error2loop;
      }
#line 1283
      if (status == 0) {
        {
#line 1284
        tmp___22 = gettext("Archive %s EOF not on block boundary");
#line 1284
        error(0, 0, (char const   *)tmp___22, *archive_name_cursor);
#line 1284
        tmp___23 = gettext("Error is not recoverable: exiting now");
#line 1284
        error(2, 0, (char const   *)tmp___23);
        }
      }
#line 1286
      left -= (size_t )status;
#line 1287
      more += status;
#line 1288
      goto again;
    }
  } else {
    {
#line 1292
    tmp___24 = gettext("Only read %lu bytes from archive %s");
#line 1292
    error(0, 0, (char const   *)tmp___24, (unsigned long )status, *archive_name_cursor);
#line 1292
    tmp___25 = gettext("Error is not recoverable: exiting now");
#line 1292
    error(2, 0, (char const   *)tmp___25);
    }
  }
#line 1294
  return;
}
}
#line 1300 "buffer.c"
void flush_archive(void) 
{ 
  int status ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  int *tmp___3 ;

  {
#line 1303
  record_start_block += (off_t )(record_end - record_start);
#line 1304
  current_block = record_start;
#line 1305
  record_end = record_start + blocking_factor;
#line 1307
  if ((unsigned int )access_mode == 0U) {
#line 1307
    if (time_to_start_writing) {
#line 1309
      access_mode = (enum access_mode )1;
#line 1310
      time_to_start_writing = 0;
#line 1312
      if (file_to_switch_to >= 0) {
#line 1314
        if (archive >= 128) {
          {
#line 1314
          tmp = rmt_close__(archive - 128);
#line 1314
          tmp___1 = tmp;
          }
        } else {
          {
#line 1314
          tmp___0 = close(archive);
#line 1314
          tmp___1 = tmp___0;
          }
        }
#line 1314
        status = tmp___1;
#line 1316
        if (status < 0) {
          {
#line 1317
          tmp___2 = gettext("WARNING: Cannot close %s (%d, %d)");
#line 1317
          tmp___3 = __errno_location();
#line 1317
          error(0, *tmp___3, (char const   *)tmp___2, *archive_name_cursor, archive,
                status);
          }
        }
#line 1320
        archive = file_to_switch_to;
      } else {
        {
#line 1323
        backspace_output();
        }
      }
    }
  }
  {
#line 1328
  if ((unsigned int )access_mode == 0U) {
#line 1328
    goto case_0;
  }
#line 1332
  if ((unsigned int )access_mode == 1U) {
#line 1332
    goto case_1;
  }
#line 1336
  if ((unsigned int )access_mode == 2U) {
#line 1336
    goto case_2;
  }
#line 1326
  goto switch_break;
  case_0: /* CIL Label */ 
  {
#line 1329
  flush_read();
  }
#line 1330
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 1333
  flush_write();
  }
#line 1334
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 1337
  abort();
  }
  switch_break: /* CIL Label */ ;
  }
#line 1339
  return;
}
}
#line 1347 "buffer.c"
static void backspace_output(void) 
{ 
  struct mtop operation ;
  unsigned long tmp ;
  int tmp___0 ;
  unsigned long tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int *tmp___4 ;
  unsigned long tmp___5 ;
  int tmp___6 ;
  unsigned long tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  off_t position ;
  off_t tmp___10 ;
  __off64_t tmp___11 ;
  off_t tmp___12 ;
  char *tmp___13 ;
  off_t tmp___14 ;
  __off64_t tmp___15 ;
  off_t tmp___16 ;

  {
#line 1354
  operation.mt_op = (short)4;
#line 1355
  operation.mt_count = 1;
#line 1356
  if (archive >= 128) {
#line 1356
    if (sizeof(struct mtop ) == sizeof(struct mtop [1])) {
#line 1356
      if (sizeof(struct mtop ) < (unsigned long )(1 << 14)) {
#line 1356
        tmp = sizeof(struct mtop );
      } else {
#line 1356
        tmp = (unsigned long )__invalid_size_argument_for_IOC;
      }
    } else {
#line 1356
      tmp = (unsigned long )__invalid_size_argument_for_IOC;
    }
    {
#line 1356
    tmp___0 = rmt_ioctl__(archive - 128, (int )((unsigned long )(((1U << 30) | (unsigned int )(109 << 8)) | 1U) | (tmp << 16)),
                          (char *)(& operation));
#line 1356
    tmp___3 = tmp___0;
    }
  } else {
#line 1356
    if (sizeof(struct mtop ) == sizeof(struct mtop [1])) {
#line 1356
      if (sizeof(struct mtop ) < (unsigned long )(1 << 14)) {
#line 1356
        tmp___1 = sizeof(struct mtop );
      } else {
#line 1356
        tmp___1 = (unsigned long )__invalid_size_argument_for_IOC;
      }
    } else {
#line 1356
      tmp___1 = (unsigned long )__invalid_size_argument_for_IOC;
    }
    {
#line 1356
    tmp___2 = ioctl(archive, (unsigned long )(((1U << 30) | (unsigned int )(109 << 8)) | 1U) | (tmp___1 << 16),
                    (char *)(& operation));
#line 1356
    tmp___3 = tmp___2;
    }
  }
#line 1356
  if (tmp___3 >= 0) {
#line 1357
    return;
  }
  {
#line 1358
  tmp___4 = __errno_location();
  }
#line 1358
  if (*tmp___4 == 5) {
#line 1358
    if (archive >= 128) {
#line 1358
      if (sizeof(struct mtop ) == sizeof(struct mtop [1])) {
#line 1358
        if (sizeof(struct mtop ) < (unsigned long )(1 << 14)) {
#line 1358
          tmp___5 = sizeof(struct mtop );
        } else {
#line 1358
          tmp___5 = (unsigned long )__invalid_size_argument_for_IOC;
        }
      } else {
#line 1358
        tmp___5 = (unsigned long )__invalid_size_argument_for_IOC;
      }
      {
#line 1358
      tmp___6 = rmt_ioctl__(archive - 128, (int )((unsigned long )(((1U << 30) | (unsigned int )(109 << 8)) | 1U) | (tmp___5 << 16)),
                            (char *)(& operation));
#line 1358
      tmp___9 = tmp___6;
      }
    } else {
#line 1358
      if (sizeof(struct mtop ) == sizeof(struct mtop [1])) {
#line 1358
        if (sizeof(struct mtop ) < (unsigned long )(1 << 14)) {
#line 1358
          tmp___7 = sizeof(struct mtop );
        } else {
#line 1358
          tmp___7 = (unsigned long )__invalid_size_argument_for_IOC;
        }
      } else {
#line 1358
        tmp___7 = (unsigned long )__invalid_size_argument_for_IOC;
      }
      {
#line 1358
      tmp___8 = ioctl(archive, (unsigned long )(((1U << 30) | (unsigned int )(109 << 8)) | 1U) | (tmp___7 << 16),
                      (char *)(& operation));
#line 1358
      tmp___9 = tmp___8;
      }
    }
#line 1358
    if (tmp___9 >= 0) {
#line 1359
      return;
    }
  }
#line 1364
  if (archive >= 128) {
    {
#line 1364
    tmp___10 = rmt_lseek__(archive - 128, (off_t )0, 1);
#line 1364
    tmp___12 = tmp___10;
    }
  } else {
    {
#line 1364
    tmp___11 = lseek(archive, (off_t )0, 1);
#line 1364
    tmp___12 = tmp___11;
    }
  }
#line 1364
  position = tmp___12;
#line 1368
  position -= (off_t )record_size;
#line 1369
  if (archive >= 128) {
    {
#line 1369
    tmp___14 = rmt_lseek__(archive - 128, position, 0);
#line 1369
    tmp___16 = tmp___14;
    }
  } else {
    {
#line 1369
    tmp___15 = lseek(archive, position, 0);
#line 1369
    tmp___16 = tmp___15;
    }
  }
#line 1369
  if (tmp___16 != position) {
    {
#line 1373
    tmp___13 = gettext("Could not backspace archive file; it may be unreadable without -i");
#line 1373
    error(0, 0, (char const   *)tmp___13);
    }
#line 1378
    if ((unsigned long )(record_start->buffer) != (unsigned long )output_start) {
      {
#line 1379
      memset((void *)(record_start->buffer), 0, (size_t )(output_start - record_start->buffer));
      }
    }
  }
#line 1383
  return;
}
}
#line 1389 "buffer.c"
void close_archive(void) 
{ 
  ssize_t tmp ;
  ssize_t tmp___0 ;
  ssize_t tmp___1 ;
  off_t pos ;
  __off64_t tmp___2 ;
  int status ;
  int tmp___3 ;
  int tmp___4 ;
  char *tmp___5 ;
  int *tmp___6 ;
  int status___0 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  char *tmp___10 ;
  int *tmp___11 ;
  int wait_status ;
  pid_t child ;
  char *tmp___12 ;
  char const   *tmp___13 ;
  union __anonunion___u_57 __u___0 ;
  union __anonunion___u_58 __u___1 ;
  char *tmp___14 ;
  union __anonunion___u_59 __u___2 ;
  union __anonunion___u_60 __u___3 ;
  char *tmp___15 ;
  union __anonunion___u_61 __u___4 ;
  union __anonunion___u_62 __u___5 ;
  int __status ;
  union __anonunion___u_63 __u___6 ;
  int tmp___16 ;
  union block *tmp___17 ;

  {
#line 1392
  if (time_to_start_writing) {
    {
#line 1393
    flush_archive();
    }
  } else
#line 1392
  if ((unsigned int )access_mode == 1U) {
    {
#line 1393
    flush_archive();
    }
  }
#line 1402
  if ((unsigned int )access_mode == 0U) {
#line 1402
    if (! (archive >= 128)) {
#line 1402
      if ((archive_stat.st_mode & 61440U) == 4096U) {
        {
#line 1405
        while (1) {
          while_continue: /* CIL Label */ ;
#line 1405
          if (archive >= 128) {
            {
#line 1405
            tmp = rmt_read__(archive - 128, record_start->buffer, record_size);
#line 1405
            tmp___1 = tmp;
            }
          } else {
            {
#line 1405
            tmp___0 = safe_read(archive, (void *)(record_start->buffer), record_size);
#line 1405
            tmp___1 = tmp___0;
            }
          }
#line 1405
          if (! (tmp___1 > 0)) {
#line 1405
            goto while_break;
          }
#line 1406
          goto while_continue;
        }
        while_break: /* CIL Label */ ;
        }
      }
    }
  }
#line 1409
  if (! (archive >= 128)) {
#line 1409
    if ((unsigned int )subcommand_option == 4U) {
      {
#line 1414
      tmp___2 = lseek(archive, (off_t )0, 1);
#line 1414
      pos = tmp___2;
      }
#line 1415
      if (pos < 0LL) {
#line 1415
        tmp___4 = -1;
      } else {
        {
#line 1415
        tmp___3 = ftruncate(archive, pos);
#line 1415
        tmp___4 = tmp___3;
        }
      }
#line 1415
      status = tmp___4;
#line 1417
      if (status != 0) {
        {
#line 1418
        tmp___5 = gettext("WARNING: Cannot truncate %s");
#line 1418
        tmp___6 = __errno_location();
#line 1418
        error(0, *tmp___6, (char const   *)tmp___5, *archive_name_cursor);
        }
      }
    }
  }
#line 1421
  if (verify_option) {
    {
#line 1422
    verify_volume();
    }
  }
#line 1425
  if (archive >= 128) {
    {
#line 1425
    tmp___7 = rmt_close__(archive - 128);
#line 1425
    tmp___9 = tmp___7;
    }
  } else {
    {
#line 1425
    tmp___8 = close(archive);
#line 1425
    tmp___9 = tmp___8;
    }
  }
#line 1425
  status___0 = tmp___9;
#line 1427
  if (status___0 < 0) {
    {
#line 1428
    tmp___10 = gettext("WARNING: Cannot close %s (%d, %d)");
#line 1428
    tmp___11 = __errno_location();
#line 1428
    error(0, *tmp___11, (char const   *)tmp___10, *archive_name_cursor, archive, status___0);
    }
  }
#line 1434
  if (child_pid) {
    {
#line 1441
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 1441
      child = wait((union wait *)(& wait_status));
      }
#line 1441
      if (child != child_pid) {
#line 1441
        if (! (child != -1)) {
#line 1441
          goto while_break___0;
        }
      } else {
#line 1441
        goto while_break___0;
      }
#line 1443
      goto while_continue___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1445
    if (child != -1) {
#line 1447
      __u___6.__in = wait_status;
#line 1447
      __status = __u___6.__i;
#line 1447
      if (! ((__status & 255) == 127)) {
#line 1447
        if (! ((__status & 127) == 0)) {
#line 1447
          tmp___16 = 1;
        } else {
#line 1447
          tmp___16 = 0;
        }
      } else {
#line 1447
        tmp___16 = 0;
      }
#line 1447
      if (tmp___16) {
#line 1455
        __u___2.__in = wait_status;
#line 1455
        if ((__u___2.__i & 127) != 13) {
#line 1456
          __u___0.__in = wait_status;
#line 1456
          if (__u___0.__i & 128) {
            {
#line 1456
            tmp___12 = gettext(" (core dumped)");
#line 1456
            tmp___13 = (char const   *)tmp___12;
            }
          } else {
#line 1456
            tmp___13 = "";
          }
          {
#line 1456
          __u___1.__in = wait_status;
#line 1456
          tmp___14 = gettext("Child died with signal %d%s");
#line 1456
          error(0, 0, (char const   *)tmp___14, __u___1.__i & 127, tmp___13);
#line 1456
          exit_status = 2;
          }
        }
      } else {
#line 1465
        __u___4.__in = wait_status;
#line 1466
        if ((__u___4.__i & 65280) >> 8 != 141) {
#line 1466
          __u___5.__in = wait_status;
#line 1466
          if ((__u___5.__i & 65280) >> 8) {
            {
#line 1467
            __u___3.__in = wait_status;
#line 1467
            tmp___15 = gettext("Child returned status %d");
#line 1467
            error(0, 0, (char const   *)tmp___15, (__u___3.__i & 65280) >> 8);
#line 1467
            exit_status = 2;
            }
          }
        }
      }
    }
  }
#line 1474
  if (current_file_name) {
    {
#line 1475
    free((void *)current_file_name);
    }
  }
#line 1476
  if (current_link_name) {
    {
#line 1477
    free((void *)current_link_name);
    }
  }
#line 1478
  if (save_name) {
    {
#line 1479
    free((void *)save_name);
    }
  }
#line 1480
  if (multi_volume_option) {
#line 1480
    tmp___17 = record_start - 2;
  } else {
#line 1480
    tmp___17 = record_start;
  }
  {
#line 1480
  free((void *)tmp___17);
  }
#line 1481
  return;
}
}
#line 1487 "buffer.c"
void init_volume_number(void) 
{ 
  FILE *file ;
  FILE *tmp ;
  int *tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;

  {
  {
#line 1490
  tmp = fopen((char const   */* __restrict  */)volno_file_option, (char const   */* __restrict  */)"r");
#line 1490
  file = tmp;
  }
#line 1492
  if (file) {
    {
#line 1494
    fscanf((FILE */* __restrict  */)file, (char const   */* __restrict  */)"%d", & global_volno);
#line 1495
    tmp___1 = fclose(file);
    }
#line 1495
    if (tmp___1 == -1) {
      {
#line 1496
      tmp___0 = __errno_location();
#line 1496
      error(0, *tmp___0, "%s", volno_file_option);
#line 1496
      exit_status = 2;
      }
    }
  } else {
    {
#line 1498
    tmp___3 = __errno_location();
    }
#line 1498
    if (*tmp___3 != 2) {
      {
#line 1499
      tmp___2 = __errno_location();
#line 1499
      error(0, *tmp___2, "%s", volno_file_option);
#line 1499
      exit_status = 2;
      }
    }
  }
#line 1500
  return;
}
}
#line 1506 "buffer.c"
void closeout_volume_number(void) 
{ 
  FILE *file ;
  FILE *tmp ;
  int *tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;

  {
  {
#line 1509
  tmp = fopen((char const   */* __restrict  */)volno_file_option, (char const   */* __restrict  */)"w");
#line 1509
  file = tmp;
  }
#line 1511
  if (file) {
    {
#line 1513
    fprintf((FILE */* __restrict  */)file, (char const   */* __restrict  */)"%d\n",
            global_volno);
#line 1514
    tmp___1 = fclose(file);
    }
#line 1514
    if (tmp___1 == -1) {
      {
#line 1515
      tmp___0 = __errno_location();
#line 1515
      error(0, *tmp___0, "%s", volno_file_option);
#line 1515
      exit_status = 2;
      }
    }
  } else {
    {
#line 1518
    tmp___2 = __errno_location();
#line 1518
    error(0, *tmp___2, "%s", volno_file_option);
#line 1518
    exit_status = 2;
    }
  }
#line 1519
  return;
}
}
#line 1529 "buffer.c"
static FILE *read_file  =    (FILE *)((void *)0);
#line 1530 "buffer.c"
static int looped  =    0;
#line 1526 "buffer.c"
static int new_volume(enum access_mode access___0 ) 
{ 
  int status ;
  FILE *tmp ;
  char *tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  char input_buffer[80] ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  char *name ;
  char *cursor ;
  char *tmp___11 ;
  __pid_t tmp___12 ;
  char *tmp___13 ;
  int *tmp___14 ;
  char const   *shell ;
  char *tmp___15 ;
  char *tmp___16 ;
  int *tmp___17 ;
  char *tmp___18 ;
  int wait_status ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  char *tmp___27 ;
  int *tmp___28 ;

  {
#line 1534
  if (! read_file) {
#line 1534
    if (! info_script_option) {
#line 1536
      if (archive == 0) {
        {
#line 1536
        tmp = fopen((char const   */* __restrict  */)"/dev/tty", (char const   */* __restrict  */)"r");
#line 1536
        read_file = tmp;
        }
      } else {
#line 1536
        read_file = stdin;
      }
    }
  }
#line 1538
  if (now_verifying) {
#line 1539
    return (0);
  }
#line 1540
  if (verify_option) {
    {
#line 1541
    verify_volume();
    }
  }
#line 1543
  if (archive >= 128) {
    {
#line 1543
    tmp___2 = rmt_close__(archive - 128);
#line 1543
    status = tmp___2;
    }
  } else {
    {
#line 1543
    tmp___3 = close(archive);
#line 1543
    status = tmp___3;
    }
  }
#line 1543
  if (status < 0) {
    {
#line 1544
    tmp___0 = gettext("WARNING: Cannot close %s (%d, %d)");
#line 1544
    tmp___1 = __errno_location();
#line 1544
    error(0, *tmp___1, (char const   *)tmp___0, *archive_name_cursor, archive, status);
    }
  }
#line 1547
  global_volno ++;
#line 1548
  volno ++;
#line 1549
  archive_name_cursor ++;
#line 1550
  if ((unsigned long )archive_name_cursor == (unsigned long )(archive_name_array + archive_names)) {
#line 1552
    archive_name_cursor = archive_name_array;
#line 1553
    looped = 1;
  }
  tryagain: 
#line 1557
  if (looped) {
#line 1561
    if (info_script_option) {
#line 1563
      if (volno_file_option) {
        {
#line 1564
        closeout_volume_number();
        }
      }
      {
#line 1565
      system(info_script_option);
      }
    } else {
      {
#line 1568
      while (1) {
        while_continue: /* CIL Label */ ;
        {
#line 1572
        fputc('\a', stderr);
#line 1573
        tmp___4 = gettext("Prepare volume #%d for %s and hit return: ");
#line 1573
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___4,
                global_volno, *archive_name_cursor);
#line 1576
        fflush(stderr);
#line 1578
        tmp___7 = fgets((char */* __restrict  */)(input_buffer), (int )sizeof(input_buffer),
                        (FILE */* __restrict  */)read_file);
        }
#line 1578
        if ((unsigned long )tmp___7 == (unsigned long )((char *)0)) {
          {
#line 1580
          tmp___5 = gettext("EOF where user reply was expected");
#line 1580
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___5);
          }
#line 1582
          if ((unsigned int )subcommand_option != 6U) {
#line 1582
            if ((unsigned int )subcommand_option != 7U) {
#line 1582
              if ((unsigned int )subcommand_option != 5U) {
                {
#line 1585
                tmp___6 = gettext("WARNING: Archive is incomplete");
#line 1585
                error(0, 0, (char const   *)tmp___6);
                }
              }
            }
          }
          {
#line 1587
          exit(2);
          }
        }
#line 1589
        if ((int )input_buffer[0] == 10) {
#line 1592
          goto while_break;
        } else
#line 1589
        if ((int )input_buffer[0] == 121) {
#line 1592
          goto while_break;
        } else
#line 1589
        if ((int )input_buffer[0] == 89) {
#line 1592
          goto while_break;
        }
        {
#line 1596
        if ((int )input_buffer[0] == 63) {
#line 1596
          goto case_63;
        }
#line 1606
        if ((int )input_buffer[0] == 113) {
#line 1606
          goto case_113;
        }
#line 1618
        if ((int )input_buffer[0] == 110) {
#line 1618
          goto case_110;
        }
#line 1637
        if ((int )input_buffer[0] == 33) {
#line 1637
          goto case_33;
        }
#line 1594
        goto switch_break;
        case_63: /* CIL Label */ 
        {
#line 1598
        tmp___8 = gettext(" n [name]   Give a new file name for the next (and subsequent) volume(s)\n q          Abort tar\n !          Spawn a subshell\n ?          Print this list\n");
#line 1598
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___8);
        }
#line 1604
        goto switch_break;
        case_113: /* CIL Label */ 
        {
#line 1609
        tmp___9 = gettext("No new volume; exiting.\n");
#line 1609
        fprintf((FILE */* __restrict  */)stdlis, (char const   */* __restrict  */)tmp___9);
        }
#line 1611
        if ((unsigned int )subcommand_option != 6U) {
#line 1611
          if ((unsigned int )subcommand_option != 7U) {
#line 1611
            if ((unsigned int )subcommand_option != 5U) {
              {
#line 1614
              tmp___10 = gettext("WARNING: Archive is incomplete");
#line 1614
              error(0, 0, (char const   *)tmp___10);
              }
            }
          }
        }
        {
#line 1616
        exit(2);
        }
        case_110: /* CIL Label */ 
#line 1622
        name = & input_buffer[1];
        {
#line 1625
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 1625
          if (! ((int )*name == 32)) {
#line 1625
            if (! ((int )*name == 9)) {
#line 1625
              goto while_break___0;
            }
          }
#line 1626
          name ++;
        }
        while_break___0: /* CIL Label */ ;
        }
#line 1627
        cursor = name;
        {
#line 1628
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 1628
          if (*cursor) {
#line 1628
            if (! ((int )*cursor != 10)) {
#line 1628
              goto while_break___1;
            }
          } else {
#line 1628
            goto while_break___1;
          }
#line 1629
          cursor ++;
        }
        while_break___1: /* CIL Label */ ;
        }
        {
#line 1630
        *cursor = (char )'\000';
#line 1633
        tmp___11 = xstrdup((char const   *)name);
#line 1633
        *archive_name_cursor = (char const   *)tmp___11;
        }
#line 1635
        goto switch_break;
        case_33: /* CIL Label */ 
        {
#line 1641
        tmp___12 = fork();
        }
        {
#line 1643
        if (tmp___12 == -1) {
#line 1643
          goto case_neg_1;
        }
#line 1647
        if (tmp___12 == 0) {
#line 1647
          goto case_0;
        }
#line 1658
        goto switch_default;
        case_neg_1: /* CIL Label */ 
        {
#line 1644
        tmp___13 = gettext("Cannot fork!");
#line 1644
        tmp___14 = __errno_location();
#line 1644
        error(0, *tmp___14, (char const   *)tmp___13);
        }
#line 1645
        goto switch_break___0;
        case_0: /* CIL Label */ 
        {
#line 1649
        tmp___15 = getenv("SHELL");
#line 1649
        shell = (char const   *)tmp___15;
        }
#line 1651
        if ((unsigned long )shell == (unsigned long )((void *)0)) {
#line 1652
          shell = "/bin/sh";
        }
        {
#line 1653
        execlp(shell, "-sh", "-i", 0);
#line 1654
        tmp___16 = gettext("Cannot exec a shell %s");
#line 1654
        tmp___17 = __errno_location();
#line 1654
        error(0, *tmp___17, (char const   *)tmp___16, shell);
#line 1654
        tmp___18 = gettext("Error is not recoverable: exiting now");
#line 1654
        error(2, 0, (char const   *)tmp___18);
        }
        switch_default: /* CIL Label */ 
        {
#line 1662
        wait((union wait *)(& wait_status));
        }
#line 1664
        goto switch_break___0;
        switch_break___0: /* CIL Label */ ;
        }
#line 1671
        goto switch_break;
        switch_break: /* CIL Label */ ;
        }
      }
      while_break: /* CIL Label */ ;
      }
    }
  }
#line 1676
  if (verify_option) {
#line 1677
    if (! force_local_option) {
      {
#line 1677
      rmt_path__ = strchr(*archive_name_cursor, ':');
      }
#line 1677
      if (rmt_path__) {
#line 1677
        if ((unsigned long )rmt_path__ > (unsigned long )*archive_name_cursor) {
#line 1677
          if ((int )*(rmt_path__ + -1) != 47) {
            {
#line 1677
            tmp___19 = rmt_open__(*archive_name_cursor, 66, 128, rsh_command_option);
#line 1677
            archive = tmp___19;
            }
          } else {
            {
#line 1677
            tmp___20 = open(*archive_name_cursor, 66, ((128 | (128 >> 3)) | ((128 >> 3) >> 3)) | ((256 | (256 >> 3)) | ((256 >> 3) >> 3)));
#line 1677
            archive = tmp___20;
            }
          }
        } else {
          {
#line 1677
          tmp___20 = open(*archive_name_cursor, 66, ((128 | (128 >> 3)) | ((128 >> 3) >> 3)) | ((256 | (256 >> 3)) | ((256 >> 3) >> 3)));
#line 1677
          archive = tmp___20;
          }
        }
      } else {
        {
#line 1677
        tmp___20 = open(*archive_name_cursor, 66, ((128 | (128 >> 3)) | ((128 >> 3) >> 3)) | ((256 | (256 >> 3)) | ((256 >> 3) >> 3)));
#line 1677
        archive = tmp___20;
        }
      }
    } else {
      {
#line 1677
      tmp___20 = open(*archive_name_cursor, 66, ((128 | (128 >> 3)) | ((128 >> 3) >> 3)) | ((256 | (256 >> 3)) | ((256 >> 3) >> 3)));
#line 1677
      archive = tmp___20;
      }
    }
  } else {
    {
#line 1682
    if ((unsigned int )access___0 == 0U) {
#line 1682
      goto case_0___0;
    }
#line 1687
    if ((unsigned int )access___0 == 1U) {
#line 1687
      goto case_1;
    }
#line 1694
    if ((unsigned int )access___0 == 2U) {
#line 1694
      goto case_2;
    }
#line 1680
    goto switch_break___1;
    case_0___0: /* CIL Label */ 
#line 1683
    if (! force_local_option) {
      {
#line 1683
      rmt_path__ = strchr(*archive_name_cursor, ':');
      }
#line 1683
      if (rmt_path__) {
#line 1683
        if ((unsigned long )rmt_path__ > (unsigned long )*archive_name_cursor) {
#line 1683
          if ((int )*(rmt_path__ + -1) != 47) {
            {
#line 1683
            tmp___21 = rmt_open__(*archive_name_cursor, 0, 128, rsh_command_option);
#line 1683
            archive = tmp___21;
            }
          } else {
            {
#line 1683
            tmp___22 = open(*archive_name_cursor, 0, ((128 | (128 >> 3)) | ((128 >> 3) >> 3)) | ((256 | (256 >> 3)) | ((256 >> 3) >> 3)));
#line 1683
            archive = tmp___22;
            }
          }
        } else {
          {
#line 1683
          tmp___22 = open(*archive_name_cursor, 0, ((128 | (128 >> 3)) | ((128 >> 3) >> 3)) | ((256 | (256 >> 3)) | ((256 >> 3) >> 3)));
#line 1683
          archive = tmp___22;
          }
        }
      } else {
        {
#line 1683
        tmp___22 = open(*archive_name_cursor, 0, ((128 | (128 >> 3)) | ((128 >> 3) >> 3)) | ((256 | (256 >> 3)) | ((256 >> 3) >> 3)));
#line 1683
        archive = tmp___22;
        }
      }
    } else {
      {
#line 1683
      tmp___22 = open(*archive_name_cursor, 0, ((128 | (128 >> 3)) | ((128 >> 3) >> 3)) | ((256 | (256 >> 3)) | ((256 >> 3) >> 3)));
#line 1683
      archive = tmp___22;
      }
    }
#line 1685
    goto switch_break___1;
    case_1: /* CIL Label */ 
#line 1688
    if (backup_option) {
      {
#line 1689
      maybe_backup_file(*archive_name_cursor, 1);
      }
    }
#line 1690
    if (! force_local_option) {
      {
#line 1690
      rmt_path__ = strchr(*archive_name_cursor, ':');
      }
#line 1690
      if (rmt_path__) {
#line 1690
        if ((unsigned long )rmt_path__ > (unsigned long )*archive_name_cursor) {
#line 1690
          if ((int )*(rmt_path__ + -1) != 47) {
            {
#line 1690
            tmp___23 = rmt_open__(*archive_name_cursor, 65, 128, rsh_command_option);
#line 1690
            archive = tmp___23;
            }
          } else {
            {
#line 1690
            tmp___24 = creat(*archive_name_cursor, (__mode_t )(((128 | (128 >> 3)) | ((128 >> 3) >> 3)) | ((256 | (256 >> 3)) | ((256 >> 3) >> 3))));
#line 1690
            archive = tmp___24;
            }
          }
        } else {
          {
#line 1690
          tmp___24 = creat(*archive_name_cursor, (__mode_t )(((128 | (128 >> 3)) | ((128 >> 3) >> 3)) | ((256 | (256 >> 3)) | ((256 >> 3) >> 3))));
#line 1690
          archive = tmp___24;
          }
        }
      } else {
        {
#line 1690
        tmp___24 = creat(*archive_name_cursor, (__mode_t )(((128 | (128 >> 3)) | ((128 >> 3) >> 3)) | ((256 | (256 >> 3)) | ((256 >> 3) >> 3))));
#line 1690
        archive = tmp___24;
        }
      }
    } else {
      {
#line 1690
      tmp___24 = creat(*archive_name_cursor, (__mode_t )(((128 | (128 >> 3)) | ((128 >> 3) >> 3)) | ((256 | (256 >> 3)) | ((256 >> 3) >> 3))));
#line 1690
      archive = tmp___24;
      }
    }
#line 1692
    goto switch_break___1;
    case_2: /* CIL Label */ 
#line 1695
    if (! force_local_option) {
      {
#line 1695
      rmt_path__ = strchr(*archive_name_cursor, ':');
      }
#line 1695
      if (rmt_path__) {
#line 1695
        if ((unsigned long )rmt_path__ > (unsigned long )*archive_name_cursor) {
#line 1695
          if ((int )*(rmt_path__ + -1) != 47) {
            {
#line 1695
            tmp___25 = rmt_open__(*archive_name_cursor, 66, 128, rsh_command_option);
#line 1695
            archive = tmp___25;
            }
          } else {
            {
#line 1695
            tmp___26 = open(*archive_name_cursor, 66, ((128 | (128 >> 3)) | ((128 >> 3) >> 3)) | ((256 | (256 >> 3)) | ((256 >> 3) >> 3)));
#line 1695
            archive = tmp___26;
            }
          }
        } else {
          {
#line 1695
          tmp___26 = open(*archive_name_cursor, 66, ((128 | (128 >> 3)) | ((128 >> 3) >> 3)) | ((256 | (256 >> 3)) | ((256 >> 3) >> 3)));
#line 1695
          archive = tmp___26;
          }
        }
      } else {
        {
#line 1695
        tmp___26 = open(*archive_name_cursor, 66, ((128 | (128 >> 3)) | ((128 >> 3) >> 3)) | ((256 | (256 >> 3)) | ((256 >> 3) >> 3)));
#line 1695
        archive = tmp___26;
        }
      }
    } else {
      {
#line 1695
      tmp___26 = open(*archive_name_cursor, 66, ((128 | (128 >> 3)) | ((128 >> 3) >> 3)) | ((256 | (256 >> 3)) | ((256 >> 3) >> 3)));
#line 1695
      archive = tmp___26;
      }
    }
#line 1697
    goto switch_break___1;
    switch_break___1: /* CIL Label */ ;
    }
  }
#line 1700
  if (archive < 0) {
    {
#line 1702
    tmp___27 = gettext("Cannot open %s");
#line 1702
    tmp___28 = __errno_location();
#line 1702
    error(0, *tmp___28, (char const   *)tmp___27, *archive_name_cursor);
    }
#line 1703
    if (! verify_option) {
#line 1703
      if ((unsigned int )access___0 == 1U) {
#line 1703
        if (backup_option) {
          {
#line 1704
          undo_last_backup();
          }
        }
      }
    }
#line 1705
    goto tryagain;
  }
#line 1712
  return (1);
}
}
