/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 127 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __ino_t;
#line 129 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __mode_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 133 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __pid_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 141 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __suseconds_t;
#line 172 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __ssize_t;
#line 189 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __socklen_t;
#line 22 "/usr/include/x86_64-linux-gnu/bits/dirent.h"
struct dirent {
   __ino_t d_ino ;
   __off_t d_off ;
   unsigned short d_reclen ;
   unsigned char d_type ;
   char d_name[256] ;
};
#line 127 "/usr/include/dirent.h"
struct __dirstream;
#line 127 "/usr/include/dirent.h"
typedef struct __dirstream DIR;
#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 49 "/usr/include/stdint.h"
typedef unsigned short uint16_t;
#line 51 "/usr/include/stdint.h"
typedef unsigned int uint32_t;
#line 70 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __mode_t mode_t;
#line 109 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __ssize_t ssize_t;
#line 30 "/usr/include/x86_64-linux-gnu/bits/time.h"
struct timeval {
   __time_t tv_sec ;
   __suseconds_t tv_usec ;
};
#line 54 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef long __fd_mask;
#line 64 "/usr/include/x86_64-linux-gnu/sys/select.h"
struct __anonstruct_fd_set_4 {
   __fd_mask __fds_bits[1024 / (8 * (int )sizeof(__fd_mask ))] ;
};
#line 64 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef struct __anonstruct_fd_set_4 fd_set;
#line 33 "/usr/include/x86_64-linux-gnu/bits/socket.h"
typedef __socklen_t socklen_t;
#line 28 "/usr/include/x86_64-linux-gnu/bits/sockaddr.h"
typedef unsigned short sa_family_t;
#line 149 "/usr/include/x86_64-linux-gnu/bits/socket.h"
struct sockaddr {
   sa_family_t sa_family ;
   char sa_data[14] ;
};
#line 30 "/usr/include/netinet/in.h"
typedef uint32_t in_addr_t;
#line 31 "/usr/include/netinet/in.h"
struct in_addr {
   in_addr_t s_addr ;
};
#line 117 "/usr/include/netinet/in.h"
typedef uint16_t in_port_t;
#line 237 "/usr/include/netinet/in.h"
struct sockaddr_in {
   sa_family_t sin_family ;
   in_port_t sin_port ;
   struct in_addr sin_addr ;
   unsigned char sin_zero[((sizeof(struct sockaddr ) - sizeof(unsigned short )) - sizeof(in_port_t )) - sizeof(struct in_addr )] ;
};
#line 257 "/usr/include/netdb.h"
struct servent {
   char *s_name ;
   char **s_aliases ;
   int s_port ;
   char *s_proto ;
};
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 44
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 144 "/usr/include/libio.h"
struct _IO_FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 29 "/usr/include/x86_64-linux-gnu/sys/un.h"
struct sockaddr_un {
   sa_family_t sun_family ;
   char sun_path[108] ;
};
#line 85 "/usr/include/signal.h"
typedef void (*__sighandler_t)(int  );
#line 35 "/usr/include/x86_64-linux-gnu/bits/fcntl.h"
struct flock {
   short l_type ;
   short l_whence ;
   __off_t l_start ;
   __off_t l_len ;
   __pid_t l_pid ;
};
#line 78 "/home/wheatley/newnew/temp/portreserve-0.0.4/src/portreserve.c"
struct map {
   struct map *next ;
   char *service ;
   int socket ;
};
/* compiler builtin: 
   int __builtin_va_arg_pack(void) ;  */
#line 134 "/usr/include/dirent.h"
extern DIR *( __attribute__((__nonnull__(1))) opendir)(char const   *__name ) ;
#line 149
extern int ( __attribute__((__nonnull__(1))) closedir)(DIR *__dirp ) ;
#line 162
extern struct dirent *( __attribute__((__nonnull__(1))) readdir)(DIR *__dirp ) ;
#line 50 "/usr/include/x86_64-linux-gnu/bits/errno.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
#line 31 "/usr/include/error.h"
__inline extern void __attribute__((__gnu_inline__))  ( /* format attribute */ __attribute__((__always_inline__)) error)(int __status ,
                                                                                                                         int __errnum ,
                                                                                                                         char const   *__format 
                                                                                                                         , ...) ;
#line 34
__inline extern void __attribute__((__gnu_inline__))  ( /* format attribute */ __attribute__((__always_inline__)) error_at_line)(int __status ,
                                                                                                                                 int __errnum ,
                                                                                                                                 char const   *__fname ,
                                                                                                                                 unsigned int __line ,
                                                                                                                                 char const   *__format 
                                                                                                                                 , ...) ;
#line 24 "/usr/include/x86_64-linux-gnu/bits/error.h"
extern void ( /* format attribute */  __error_alias)(int __status , int __errnum ,
                                                     char const   *__format  , ...)  __asm__("error")  ;
#line 36 "/usr/include/x86_64-linux-gnu/bits/error.h"
__inline extern void __attribute__((__gnu_inline__))  ( /* format attribute */ __attribute__((__always_inline__)) error)(int __status ,
                                                                                                                         int __errnum ,
                                                                                                                         char const   *__format 
                                                                                                                         , ...) 
{ 


  {
  {
#line 42
  __error_alias(__status, __errnum, __format, __builtin_va_arg_pack());
  }
#line 43
  return;
}
}
#line 46
extern void ( /* format attribute */  __error_at_line_alias)(int __status , int __errnum ,
                                                             char const   *__fname ,
                                                             unsigned int __line ,
                                                             char const   *__format 
                                                             , ...)  __asm__("error_at_line")  ;
#line 63 "/usr/include/x86_64-linux-gnu/bits/error.h"
__inline extern void __attribute__((__gnu_inline__))  ( /* format attribute */ __attribute__((__always_inline__)) error_at_line)(int __status ,
                                                                                                                                 int __errnum ,
                                                                                                                                 char const   *__fname ,
                                                                                                                                 unsigned int __line ,
                                                                                                                                 char const   *__format 
                                                                                                                                 , ...) 
{ 


  {
  {
#line 71
  __error_at_line_alias(__status, __errnum, __fname, __line, __format, __builtin_va_arg_pack());
  }
#line 73
  return;
}
}
#line 106 "/usr/include/x86_64-linux-gnu/sys/select.h"
extern int select(int __nfds , fd_set * __restrict  __readfds , fd_set * __restrict  __writefds ,
                  fd_set * __restrict  __exceptfds , struct timeval * __restrict  __timeout ) ;
#line 113 "/usr/include/x86_64-linux-gnu/sys/socket.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) socket)(int __domain ,
                                                                             int __type ,
                                                                             int __protocol ) ;
#line 123
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) bind)(int __fd ,
                                                                           struct sockaddr  const  *__addr ,
                                                                           socklen_t __len ) ;
#line 137
extern int connect(int __fd , struct sockaddr  const  *__addr , socklen_t __len ) ;
#line 149
extern ssize_t send(int __fd , void const   *__buf , size_t __n , int __flags ) ;
#line 156
extern ssize_t recv(int __fd , void *__buf , size_t __n , int __flags ) ;
#line 375 "/usr/include/netinet/in.h"
extern  __attribute__((__nothrow__)) uint16_t ( __attribute__((__leaf__)) ntohs)(uint16_t __netshort )  __attribute__((__const__)) ;
#line 379
extern  __attribute__((__nothrow__)) uint16_t ( __attribute__((__leaf__)) htons)(uint16_t __hostshort )  __attribute__((__const__)) ;
#line 290 "/usr/include/netdb.h"
extern struct servent *getservbyname(char const   *__name , char const   *__proto ) ;
#line 183 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) long ( __attribute__((__nonnull__(1), __leaf__)) strtol)(char const   * __restrict  __nptr ,
                                                                                              char ** __restrict  __endptr ,
                                                                                              int __base ) ;
#line 466
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 543
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 170 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 237
extern int fclose(FILE *__stream ) ;
#line 272
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 362
extern int printf(char const   * __restrict  __format  , ...) ;
#line 386
extern  __attribute__((__nothrow__)) int ( /* format attribute */  snprintf)(char * __restrict  __s ,
                                                                             size_t __maxlen ,
                                                                             char const   * __restrict  __format 
                                                                             , ...) ;
#line 622
extern char *fgets(char * __restrict  __s , int __n , FILE * __restrict  __stream ) ;
#line 129 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcpy)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 144
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 176
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strdup)(char const   *__s )  __attribute__((__malloc__)) ;
#line 236
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strchr)(char const   *__s ,
                                                                                               int __c )  __attribute__((__pure__)) ;
#line 263
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strrchr)(char const   *__s ,
                                                                                                int __c )  __attribute__((__pure__)) ;
#line 285
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1,2), __leaf__)) strcspn)(char const   *__s ,
                                                                                                   char const   *__reject )  __attribute__((__pure__)) ;
#line 342
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strstr)(char const   *__haystack ,
                                                                                                 char const   *__needle )  __attribute__((__pure__)) ;
#line 399
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 353 "/usr/include/unistd.h"
extern int close(int __fd ) ;
#line 366
extern ssize_t write(int __fd , void const   *__buf , size_t __n ) ;
#line 628
extern  __attribute__((__nothrow__)) __pid_t ( __attribute__((__leaf__)) getpid)(void) ;
#line 667
extern  __attribute__((__nothrow__)) __pid_t ( __attribute__((__leaf__)) setsid)(void) ;
#line 756
extern  __attribute__((__nothrow__)) __pid_t fork(void) ;
#line 826
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) unlink)(char const   *__name ) ;
#line 102 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) __sighandler_t ( __attribute__((__leaf__)) signal)(int __sig ,
                                                                                        void (*__handler)(int  ) ) ;
#line 137 "/usr/include/fcntl.h"
extern int fcntl(int __fd , int __cmd  , ...) ;
#line 146
extern int ( __attribute__((__nonnull__(1))) open)(char const   *__file , int __oflag 
                                                   , ...) ;
#line 84 "/home/wheatley/newnew/temp/portreserve-0.0.4/src/portreserve.c"
static int debug  =    0;
#line 86 "/home/wheatley/newnew/temp/portreserve-0.0.4/src/portreserve.c"
static int portrelease(char const   *service ) 
{ 
  struct sockaddr_un addr ;
  int s ;
  int tmp ;
  int tmp___0 ;
  size_t tmp___1 ;

  {
  {
#line 90
  tmp = socket(1, 2, 0);
#line 90
  s = tmp;
  }
#line 91
  if (s == -1) {
#line 92
    return (-1);
  }
  {
#line 93
  addr.sun_family = (sa_family_t )1;
#line 94
  strcpy((char */* __restrict  */)(addr.sun_path), (char const   */* __restrict  */)"/var/run/portreserve/socket");
#line 95
  tmp___0 = connect(s, (struct sockaddr  const  *)((struct sockaddr *)(& addr)), (socklen_t )sizeof(addr));
  }
#line 95
  if (tmp___0 == -1) {
#line 97
    return (0);
  }
  {
#line 98
  tmp___1 = strlen(service);
#line 98
  send(s, (void const   *)service, tmp___1, 0);
#line 99
  close(s);
  }
#line 100
  return (0);
}
}
#line 103 "/home/wheatley/newnew/temp/portreserve-0.0.4/src/portreserve.c"
static int real_file(char const   *name ) 
{ 
  char *tmp ;
  char *tmp___0 ;

  {
  {
#line 106
  tmp = strchr(name, '~');
  }
#line 106
  if (tmp) {
#line 107
    return (0);
  }
  {
#line 108
  tmp___0 = strchr(name, '.');
  }
#line 108
  if (tmp___0) {
#line 109
    return (0);
  }
#line 110
  return (1);
}
}
#line 113 "/home/wheatley/newnew/temp/portreserve-0.0.4/src/portreserve.c"
static void no_memory(void) 
{ 


  {
  {
#line 116
  exit(1);
  }
}
}
#line 119 "/home/wheatley/newnew/temp/portreserve-0.0.4/src/portreserve.c"
static struct map *reserve(char const   *file , char const   *client ) 
{ 
  struct map *maps ;
  FILE *f ;
  FILE *tmp ;
  char service[100] ;
  char *protocols[2] ;
  size_t num_protocols ;
  size_t i ;
  char *p ;
  char *tmp___0 ;
  size_t tmp___1 ;
  struct map *map ;
  struct sockaddr_in sin ;
  int sd ;
  int type ;
  char const   *protocol ;
  struct servent *serv ;
  struct servent *tmp___2 ;
  char *endptr ;
  int port ;
  long tmp___3 ;
  int tmp___4 ;
  int *tmp___5 ;
  int tmp___6 ;
  void *tmp___7 ;
  uint16_t tmp___8 ;

  {
  {
#line 122
  maps = (struct map *)((void *)0);
#line 123
  tmp = fopen((char const   */* __restrict  */)file, (char const   */* __restrict  */)"r");
#line 123
  f = tmp;
  }
#line 124
  if (! f) {
#line 125
    return ((struct map *)((void *)0));
  }
  {
#line 127
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 129
    protocols[0] = (char *)"tcp";
#line 129
    protocols[1] = (char *)"udp";
#line 130
    num_protocols = (size_t )2;
#line 133
    tmp___0 = fgets((char */* __restrict  */)(service), (int )sizeof(service), (FILE */* __restrict  */)f);
#line 133
    p = tmp___0;
    }
#line 134
    if (! p) {
      {
#line 135
      fclose(f);
      }
#line 136
      return (maps);
    }
    {
#line 139
    tmp___1 = strcspn((char const   *)(service), "/\n");
#line 139
    p += tmp___1;
    }
#line 140
    if ((int )*p == 47) {
      {
#line 141
      *p = (char )'\000';
#line 142
      protocols[0] = p + 1;
#line 143
      p = strchr((char const   *)protocols[0], '\n');
#line 144
      num_protocols = (size_t )1;
      }
    }
#line 147
    if (p) {
#line 148
      *p = (char )'\000';
    }
#line 150
    i = (size_t )0;
    {
#line 150
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 150
      if (! (i < num_protocols)) {
#line 150
        goto while_break___0;
      }
      {
#line 155
      protocol = (char const   *)protocols[i];
#line 156
      tmp___2 = getservbyname((char const   *)(service), protocol);
#line 156
      serv = tmp___2;
      }
#line 158
      if (serv) {
#line 159
        sin.sin_port = (in_port_t )serv->s_port;
      } else {
        {
#line 162
        tmp___3 = strtol((char const   */* __restrict  */)(service), (char **/* __restrict  */)(& endptr),
                         10);
#line 162
        port = (int )tmp___3;
        }
#line 163
        if ((unsigned long )(service) == (unsigned long )endptr) {
#line 165
          goto __Cont;
        }
        {
#line 168
        sin.sin_port = htons((uint16_t )port);
        }
      }
      {
#line 171
      sin.sin_family = (sa_family_t )2;
#line 172
      sin.sin_addr.s_addr = (in_addr_t )0;
#line 174
      tmp___4 = strcmp(protocol, "udp");
      }
#line 174
      if (tmp___4) {
#line 177
        type = 1;
      } else {
#line 175
        type = 2;
      }
      {
#line 179
      sd = socket(2, type, 0);
      }
#line 180
      if (sd == -1) {
#line 181
        if (debug) {
          {
#line 182
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Unable to create %s socket\n",
                  protocol);
          }
        }
#line 185
        goto __Cont;
      }
      {
#line 188
      tmp___6 = bind(sd, (struct sockaddr  const  *)((struct sockaddr *)(& sin)),
                     (socklen_t )sizeof(sin));
      }
#line 188
      if (tmp___6 == -1) {
        {
#line 190
        tmp___5 = __errno_location();
#line 190
        error(0, *tmp___5, "bind");
        }
#line 191
        goto __Cont;
      }
      {
#line 194
      tmp___7 = malloc(sizeof(*map));
#line 194
      map = (struct map *)tmp___7;
      }
#line 195
      if (! map) {
        {
#line 196
        no_memory();
        }
      }
      {
#line 197
      map->socket = sd;
#line 198
      map->next = maps;
#line 199
      map->service = strdup(client);
      }
#line 200
      if (! map->service) {
        {
#line 201
        no_memory();
        }
      }
#line 202
      maps = map;
#line 204
      if (debug) {
        {
#line 205
        tmp___8 = ntohs(sin.sin_port);
#line 205
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Reserved %d/%s for %s\n",
                (int )tmp___8, protocol, client);
        }
      }
      __Cont: /* CIL Label */ 
#line 150
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 211
  return (maps);
}
}
#line 214 "/home/wheatley/newnew/temp/portreserve-0.0.4/src/portreserve.c"
static int unix_socket(void) 
{ 
  struct sockaddr_un addr ;
  int s ;
  int tmp ;
  int tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  {
#line 218
  tmp = socket(1, 2, 0);
#line 218
  s = tmp;
  }
#line 219
  if (s == -1) {
#line 220
    return (s);
  }
  {
#line 221
  addr.sun_family = (sa_family_t )1;
#line 222
  strcpy((char */* __restrict  */)(addr.sun_path), (char const   */* __restrict  */)"/var/run/portreserve/socket");
#line 223
  tmp___3 = bind(s, (struct sockaddr  const  *)((struct sockaddr *)(& addr)), (socklen_t )sizeof(addr));
  }
#line 223
  if (tmp___3 == -1) {
    {
#line 224
    tmp___0 = connect(s, (struct sockaddr  const  *)((struct sockaddr *)(& addr)),
                      (socklen_t )sizeof(addr));
    }
#line 224
    if (tmp___0 == 0) {
      {
#line 226
      close(s);
#line 227
      error(1, 0, "already running");
      }
    }
    {
#line 229
    unlink("/var/run/portreserve/socket");
#line 230
    tmp___2 = bind(s, (struct sockaddr  const  *)((struct sockaddr *)(& addr)), (socklen_t )sizeof(addr));
    }
#line 230
    if (tmp___2 == -1) {
      {
#line 232
      close(s);
#line 233
      tmp___1 = __errno_location();
#line 233
      error(1, *tmp___1, "bind");
      }
    }
  }
#line 236
  return (s);
}
}
#line 239 "/home/wheatley/newnew/temp/portreserve-0.0.4/src/portreserve.c"
static int portreserve(void) 
{ 
  struct map *maps ;
  char const   *dir ;
  char *cfgfile ;
  size_t tmp ;
  void *tmp___0 ;
  char *cfgf ;
  size_t tmp___1 ;
  struct dirent *d ;
  int unfd ;
  int tmp___2 ;
  DIR *cfgdir ;
  struct map *newmaps ;
  struct map *p ;
  int tmp___3 ;
  fd_set fds ;
  int __d0 ;
  int __d1 ;
  char service[100] ;
  ssize_t got ;
  struct map *m ;
  struct map **prev ;
  struct map *next ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
  {
#line 242
  maps = (struct map *)((void *)0);
#line 243
  dir = "/etc/portreserve/";
#line 244
  tmp = strlen(dir);
#line 244
  tmp___0 = malloc((tmp + 255UL) + 1UL);
#line 244
  cfgfile = (char *)tmp___0;
#line 245
  tmp___1 = strlen(dir);
#line 245
  cfgf = cfgfile + tmp___1;
#line 247
  tmp___2 = unix_socket();
#line 247
  unfd = tmp___2;
  }
#line 249
  if (! cfgfile) {
#line 250
    return (-1);
  }
  {
#line 251
  strcpy((char */* __restrict  */)cfgfile, (char const   */* __restrict  */)dir);
#line 252
  cfgdir = opendir(dir);
  }
#line 253
  if (! cfgdir) {
#line 254
    return (-1);
  }
  {
#line 255
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 255
    d = readdir(cfgdir);
    }
#line 255
    if (! ((unsigned long )d != (unsigned long )((void *)0))) {
#line 255
      goto while_break;
    }
    {
#line 258
    tmp___3 = real_file((char const   *)(d->d_name));
    }
#line 258
    if (! tmp___3) {
#line 259
      goto while_continue;
    }
    {
#line 260
    strcpy((char */* __restrict  */)cfgf, (char const   */* __restrict  */)(d->d_name));
#line 261
    newmaps = reserve((char const   *)cfgfile, (char const   *)(d->d_name));
    }
#line 261
    if ((unsigned long )newmaps == (unsigned long )((void *)0)) {
#line 262
      goto while_continue;
    }
#line 264
    p = newmaps;
    {
#line 264
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 264
      if (p) {
#line 264
        if (! ((unsigned long )p->next != (unsigned long )((void *)0))) {
#line 264
          goto while_break___0;
        }
      } else {
#line 264
        goto while_break___0;
      }
#line 264
      p = newmaps->next;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 266
    if (p) {
#line 267
      p->next = maps;
    }
#line 269
    if (newmaps) {
#line 270
      maps = newmaps;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 272
  closedir(cfgdir);
  }
  {
#line 274
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 274
    if (! maps) {
#line 274
      goto while_break___1;
    }
    {
#line 276
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 276
      __asm__  volatile   ("cld; rep; "
                           "stosq": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                           "1" (& fds.__fds_bits[0]): "memory");
#line 276
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 277
    fds.__fds_bits[unfd / (8 * (int )sizeof(__fd_mask ))] |= 1L << unfd % (8 * (int )sizeof(__fd_mask ));
#line 278
    tmp___6 = select(unfd + 1, (fd_set */* __restrict  */)(& fds), (fd_set */* __restrict  */)((void *)0),
                     (fd_set */* __restrict  */)((void *)0), (struct timeval */* __restrict  */)((void *)0));
    }
#line 278
    if (tmp___6) {
#line 278
      if ((fds.__fds_bits[unfd / (8 * (int )sizeof(__fd_mask ))] & (1L << unfd % (8 * (int )sizeof(__fd_mask )))) != 0L) {
        {
#line 283
        got = recv(unfd, (void *)(service), sizeof(service) - 1UL, 0);
        }
#line 284
        if (got == -1L) {
#line 285
          goto while_continue___1;
        }
#line 286
        service[got] = (char )'\000';
#line 287
        prev = & maps;
#line 288
        m = maps;
        {
#line 289
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 289
          if (! m) {
#line 289
            goto while_break___3;
          }
          {
#line 290
          tmp___4 = strcmp((char const   *)(service), "*");
          }
#line 290
          if (tmp___4) {
            {
#line 290
            tmp___5 = strcmp((char const   *)m->service, (char const   *)(service));
            }
#line 290
            if (tmp___5) {
#line 304
              prev = & m->next;
#line 305
              m = *prev;
            } else {
              _L: /* CIL Label */ 
#line 292
              next = m->next;
#line 294
              if (debug) {
                {
#line 295
                fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Released service %s\n",
                        m->service);
                }
              }
              {
#line 298
              close(m->socket);
#line 299
              free((void *)m->service);
#line 300
              free((void *)m);
#line 301
              m = next;
#line 302
              maps = (struct map *)((void *)0);
              }
            }
          } else {
#line 290
            goto _L;
          }
        }
        while_break___3: /* CIL Label */ ;
        }
      }
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 311
  if (debug) {
    {
#line 312
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"All reservations taken.\n");
    }
  }
#line 314
  return (0);
}
}
#line 321 "/home/wheatley/newnew/temp/portreserve-0.0.4/src/portreserve.c"
int fcntl_lock(int fd , int cmd , int type , int whence , int start , int len ) 
{ 
  struct flock lock[1] ;
  int tmp ;

  {
  {
#line 326
  lock[0].l_type = (short )type;
#line 327
  lock[0].l_whence = (short )whence;
#line 328
  lock[0].l_start = (__off_t )start;
#line 329
  lock[0].l_len = (__off_t )len;
#line 331
  tmp = fcntl(fd, cmd, lock);
  }
#line 331
  return (tmp);
}
}
#line 334 "/home/wheatley/newnew/temp/portreserve-0.0.4/src/portreserve.c"
static int daemon_lock_pidfile(char *pidfile ) 
{ 
  mode_t mode ;
  int pid_fd ;
  int *tmp ;
  int tmp___0 ;

  {
  {
#line 337
  mode = (mode_t )((384 | (256 >> 3)) | ((256 >> 3) >> 3));
#line 342
  pid_fd = open((char const   *)pidfile, 194, mode);
  }
#line 342
  if (pid_fd == -1) {
    {
#line 344
    tmp = __errno_location();
    }
#line 344
    if (*tmp != 17) {
#line 345
      return (-1);
    }
    {
#line 354
    pid_fd = open((char const   *)pidfile, 2);
    }
#line 354
    if (pid_fd == -1) {
#line 355
      return (-1);
    }
  }
  {
#line 358
  tmp___0 = fcntl_lock(pid_fd, 6, 1, 0, 0, 0);
  }
#line 358
  if (tmp___0 == -1) {
#line 359
    return (-1);
  }
#line 361
  return (pid_fd);
}
}
#line 364 "/home/wheatley/newnew/temp/portreserve-0.0.4/src/portreserve.c"
int create_pidfile(char *pidfile ) 
{ 
  int fd ;
  char pid[32] ;
  __pid_t tmp ;
  size_t tmp___0 ;
  ssize_t tmp___1 ;
  size_t tmp___2 ;

  {
  {
#line 372
  fd = daemon_lock_pidfile(pidfile);
  }
#line 372
  if (fd == -1) {
#line 373
    return (-1);
  }
  {
#line 377
  tmp = getpid();
#line 377
  snprintf((char */* __restrict  */)(pid), sizeof(pid), (char const   */* __restrict  */)"%d\n",
           tmp);
#line 378
  tmp___0 = strlen((char const   *)(pid));
#line 378
  tmp___1 = write(fd, (void const   *)(pid), tmp___0);
#line 378
  tmp___2 = strlen((char const   *)(pid));
  }
#line 378
  if ((size_t )tmp___1 != tmp___2) {
#line 379
    return (-1);
  }
#line 382
  return (0);
}
}
#line 385 "/home/wheatley/newnew/temp/portreserve-0.0.4/src/portreserve.c"
void handle_signal(int sig ) 
{ 


  {
  {
#line 388
  printf((char const   */* __restrict  */)"Cleaning pidfile\n");
#line 389
  unlink("/var/run/portreserve.pid");
#line 390
  exit(0);
  }
}
}
#line 393 "/home/wheatley/newnew/temp/portreserve-0.0.4/src/portreserve.c"
int main(int argc , char **argv ) 
{ 
  int rv ;
  char const   *p ;
  char *tmp ;
  char const   *tmp___0 ;
  int i ;
  int r ;
  int tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  __pid_t tmp___4 ;
  int *tmp___5 ;
  int *tmp___6 ;
  int tmp___7 ;

  {
  {
#line 397
  tmp = strrchr((char const   *)*(argv + 0), '/');
#line 397
  p = (char const   *)tmp;
#line 398
  tmp___0 = p;
#line 398
  p ++;
  }
#line 398
  if (! tmp___0) {
#line 399
    p = (char const   *)*(argv + 0);
  }
  {
#line 401
  tmp___2 = strstr(p, "portrelease");
  }
#line 401
  if (tmp___2) {
#line 403
    r = 0;
#line 404
    i = 1;
    {
#line 404
    while (1) {
      while_continue: /* CIL Label */ ;
#line 404
      if (! (i < argc)) {
#line 404
        goto while_break;
      }
      {
#line 405
      tmp___1 = portrelease((char const   *)*(argv + i));
#line 405
      r += tmp___1;
#line 404
      i ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 406
    return (r);
  }
  {
#line 409
  signal(15, & handle_signal);
#line 410
  signal(2, & handle_signal);
#line 411
  signal(3, & handle_signal);
#line 412
  signal(9, & handle_signal);
  }
#line 414
  if (argc > 1) {
    {
#line 415
    tmp___3 = strcmp((char const   *)*(argv + 1), "-d");
    }
#line 415
    if (tmp___3) {
      {
#line 418
      error(1, 0, "See the man page to find out what this program does.");
      }
    } else {
#line 416
      debug = 1;
    }
  }
#line 423
  if (! debug) {
    {
#line 424
    tmp___4 = fork();
    }
    {
#line 425
    if (tmp___4 == 0) {
#line 425
      goto case_0;
    }
#line 427
    if (tmp___4 == -1) {
#line 427
      goto case_neg_1;
    }
#line 429
    goto switch_default;
    case_0: /* CIL Label */ 
#line 426
    goto switch_break;
    case_neg_1: /* CIL Label */ 
    {
#line 428
    tmp___5 = __errno_location();
#line 428
    error(1, *tmp___5, "fork");
    }
    switch_default: /* CIL Label */ 
#line 430
    return (0);
    switch_break: /* CIL Label */ ;
    }
    {
#line 433
    close(0);
#line 434
    close(1);
#line 435
    close(2);
#line 436
    setsid();
    }
  }
  {
#line 438
  tmp___7 = create_pidfile((char *)"/var/run/portreserve.pid");
  }
#line 438
  if (tmp___7 == -1) {
    {
#line 439
    tmp___6 = __errno_location();
#line 439
    error(1, *tmp___6, "Failed to write pidfile!");
    }
  }
  {
#line 442
  rv = portreserve();
#line 443
  unlink("/var/run/portreserve.pid");
  }
#line 444
  return (rv);
}
}
