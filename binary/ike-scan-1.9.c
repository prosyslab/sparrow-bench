/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 51 "/usr/include/stdint.h"
typedef unsigned int uint32_t;
#line 11 "/home/june/repo/benchmarks/collector/temp/ike-scan-1.9/sha1.h"
struct __anonstruct_SHA1_CTX_68 {
   uint32_t state[5] ;
   uint32_t count[2] ;
   unsigned char buffer[64] ;
};
#line 11 "/home/june/repo/benchmarks/collector/temp/ike-scan-1.9/sha1.h"
typedef struct __anonstruct_SHA1_CTX_68 SHA1_CTX;
#line 64 "/home/june/repo/benchmarks/collector/temp/ike-scan-1.9/sha1.c"
union __anonunion_CHAR64LONG16_76 {
   unsigned char c[64] ;
   uint32_t l[16] ;
};
#line 64 "/home/june/repo/benchmarks/collector/temp/ike-scan-1.9/sha1.c"
typedef union __anonunion_CHAR64LONG16_76 CHAR64LONG16;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 48 "/usr/include/stdint.h"
typedef unsigned char uint8_t;
#line 49 "/usr/include/stdint.h"
typedef unsigned short uint16_t;
#line 30 "/usr/include/netinet/in.h"
typedef uint32_t in_addr_t;
#line 31 "/usr/include/netinet/in.h"
struct in_addr {
   in_addr_t s_addr ;
};
#line 43 "/usr/include/regex.h"
typedef unsigned long reg_syntax_t;
#line 368 "/usr/include/regex.h"
struct re_pattern_buffer {
   unsigned char *__buffer ;
   unsigned long __allocated ;
   unsigned long __used ;
   reg_syntax_t __syntax ;
   char *__fastmap ;
   unsigned char *__translate ;
   size_t re_nsub ;
   unsigned int __can_be_null : 1 ;
   unsigned int __regs_allocated : 2 ;
   unsigned int __fastmap_accurate : 1 ;
   unsigned int __no_sub : 1 ;
   unsigned int __not_bol : 1 ;
   unsigned int __not_eol : 1 ;
   unsigned int __newline_anchor : 1 ;
};
#line 434 "/usr/include/regex.h"
typedef struct re_pattern_buffer regex_t;
#line 437 "/usr/include/regex.h"
typedef int regoff_t;
#line 463 "/usr/include/regex.h"
struct __anonstruct_regmatch_t_67 {
   regoff_t rm_so ;
   regoff_t rm_eo ;
};
#line 463 "/usr/include/regex.h"
typedef struct __anonstruct_regmatch_t_67 regmatch_t;
#line 257 "/home/june/repo/benchmarks/collector/temp/ike-scan-1.9/isakmp.h"
struct isakmp_hdr {
   uint32_t isa_icookie[2] ;
   uint32_t isa_rcookie[2] ;
   uint8_t isa_np ;
   uint8_t isa_version ;
   uint8_t isa_xchg ;
   uint8_t isa_flags ;
   uint32_t isa_msgid ;
   uint32_t isa_length ;
};
#line 282 "/home/june/repo/benchmarks/collector/temp/ike-scan-1.9/isakmp.h"
struct isakmp_generic {
   uint8_t isag_np ;
   uint8_t isag_reserved ;
   uint16_t isag_length ;
};
#line 305 "/home/june/repo/benchmarks/collector/temp/ike-scan-1.9/isakmp.h"
struct isakmp_attribute {
   uint16_t isaat_af_type ;
   uint16_t isaat_lv ;
};
#line 327 "/home/june/repo/benchmarks/collector/temp/ike-scan-1.9/isakmp.h"
struct isakmp_sa {
   uint8_t isasa_np ;
   uint8_t isasa_reserved ;
   uint16_t isasa_length ;
   uint32_t isasa_doi ;
   uint32_t isasa_situation ;
};
#line 353 "/home/june/repo/benchmarks/collector/temp/ike-scan-1.9/isakmp.h"
struct isakmp_sa2 {
   uint8_t isasa2_np ;
   uint8_t isasa2_reserved ;
   uint16_t isasa2_length ;
};
#line 376 "/home/june/repo/benchmarks/collector/temp/ike-scan-1.9/isakmp.h"
struct isakmp_proposal {
   uint8_t isap_np ;
   uint8_t isap_reserved ;
   uint16_t isap_length ;
   uint8_t isap_proposal ;
   uint8_t isap_protoid ;
   uint8_t isap_spisize ;
   uint8_t isap_notrans ;
};
#line 403 "/home/june/repo/benchmarks/collector/temp/ike-scan-1.9/isakmp.h"
struct isakmp_transform {
   uint8_t isat_np ;
   uint8_t isat_reserved ;
   uint16_t isat_length ;
   uint8_t isat_transnum ;
   uint8_t isat_transid ;
   uint16_t isat_reserved2 ;
};
#line 429 "/home/june/repo/benchmarks/collector/temp/ike-scan-1.9/isakmp.h"
struct isakmp_transform2 {
   uint8_t isat2_np ;
   uint8_t isat2_reserved ;
   uint16_t isat2_length ;
   uint8_t isat2_transtype ;
   uint8_t isat2_reserved2 ;
   uint16_t isat2_transid ;
};
#line 451 "/home/june/repo/benchmarks/collector/temp/ike-scan-1.9/isakmp.h"
struct isakmp_kx {
   uint8_t isakx_np ;
   uint8_t isakx_reserved ;
   uint16_t isakx_length ;
};
#line 473 "/home/june/repo/benchmarks/collector/temp/ike-scan-1.9/isakmp.h"
struct isakmp_kx2 {
   uint8_t isakx2_np ;
   uint8_t isakx2_reserved ;
   uint16_t isakx2_length ;
   uint16_t isakx2_dhgroup ;
   uint16_t isakx2_reserved2 ;
};
#line 482 "/home/june/repo/benchmarks/collector/temp/ike-scan-1.9/isakmp.h"
struct isakmp_nonce {
   uint8_t isanonce_np ;
   uint8_t isanonce_reserved ;
   uint16_t isanonce_length ;
};
#line 506 "/home/june/repo/benchmarks/collector/temp/ike-scan-1.9/isakmp.h"
struct isakmp_id {
   uint8_t isaid_np ;
   uint8_t isaid_reserved ;
   uint16_t isaid_length ;
   uint8_t isaid_idtype ;
   uint8_t isaid_doi_specific_a ;
   uint16_t isaid_doi_specific_b ;
};
#line 539 "/home/june/repo/benchmarks/collector/temp/ike-scan-1.9/isakmp.h"
struct isakmp_notification {
   uint8_t isan_np ;
   uint8_t isan_reserved ;
   uint16_t isan_length ;
   uint32_t isan_doi ;
   uint8_t isan_protoid ;
   uint8_t isan_spisize ;
   uint16_t isan_type ;
};
#line 573 "/home/june/repo/benchmarks/collector/temp/ike-scan-1.9/isakmp.h"
struct isakmp_notification2 {
   uint8_t isan2_np ;
   uint8_t isan2_reserved ;
   uint16_t isan2_length ;
   uint8_t isan2_protoid ;
   uint8_t isan2_spisize ;
   uint16_t isan2_type ;
};
#line 601 "/home/june/repo/benchmarks/collector/temp/ike-scan-1.9/isakmp.h"
struct isakmp_delete {
   uint8_t isad_np ;
   uint8_t isad_reserved ;
   uint16_t isad_length ;
   uint32_t isad_doi ;
   uint8_t isad_protoid ;
   uint8_t isad_spisize ;
   uint16_t isad_nospi ;
};
#line 615 "/home/june/repo/benchmarks/collector/temp/ike-scan-1.9/isakmp.h"
struct isakmp_vid {
   uint8_t isavid_np ;
   uint8_t isavid_reserved ;
   uint16_t isavid_length ;
};
#line 252 "/home/june/repo/benchmarks/collector/temp/ike-scan-1.9/ike-scan.h"
struct vid_pattern_list_ {
   char *name ;
   char *pattern ;
   regex_t *regex ;
   struct vid_pattern_list_ *next ;
};
#line 252 "/home/june/repo/benchmarks/collector/temp/ike-scan-1.9/ike-scan.h"
typedef struct vid_pattern_list_ vid_pattern_list;
#line 259 "/home/june/repo/benchmarks/collector/temp/ike-scan-1.9/ike-scan.h"
struct __anonstruct_psk_crack_72 {
   unsigned char *g_xr ;
   unsigned char *g_xi ;
   unsigned char *cky_r ;
   unsigned char *cky_i ;
   unsigned char *sai_b ;
   unsigned char *idir_b ;
   unsigned char *ni_b ;
   unsigned char *nr_b ;
   unsigned char *hash_r ;
   size_t g_xr_len ;
   size_t g_xi_len ;
   size_t cky_r_len ;
   size_t cky_i_len ;
   size_t sai_b_len ;
   size_t idir_b_len ;
   size_t ni_b_len ;
   size_t nr_b_len ;
   size_t hash_r_len ;
};
#line 259 "/home/june/repo/benchmarks/collector/temp/ike-scan-1.9/ike-scan.h"
typedef struct __anonstruct_psk_crack_72 psk_crack;
#line 280 "/home/june/repo/benchmarks/collector/temp/ike-scan-1.9/ike-scan.h"
struct __anonstruct_id_name_map_73 {
   int id ;
   char const   *name ;
};
#line 280 "/home/june/repo/benchmarks/collector/temp/ike-scan-1.9/ike-scan.h"
typedef struct __anonstruct_id_name_map_73 id_name_map;
#line 285 "/home/june/repo/benchmarks/collector/temp/ike-scan-1.9/ike-scan.h"
struct __anonstruct_ike_udphdr_74 {
   uint16_t source ;
   uint16_t dest ;
   uint16_t len ;
   uint16_t check ;
};
#line 285 "/home/june/repo/benchmarks/collector/temp/ike-scan-1.9/ike-scan.h"
typedef struct __anonstruct_ike_udphdr_74 ike_udphdr;
#line 40 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stdarg.h"
typedef __builtin_va_list __gnuc_va_list;
#line 79 "/usr/include/stdio.h"
typedef __gnuc_va_list va_list;
#line 75 "/home/june/repo/benchmarks/collector/temp/ike-scan-1.9/md5.h"
typedef unsigned char md5_byte_t;
#line 76 "/home/june/repo/benchmarks/collector/temp/ike-scan-1.9/md5.h"
typedef unsigned int md5_word_t;
#line 79 "/home/june/repo/benchmarks/collector/temp/ike-scan-1.9/md5.h"
struct md5_state_s {
   md5_word_t count[2] ;
   md5_word_t abcd[4] ;
   md5_byte_t buf[64] ;
};
#line 79 "/home/june/repo/benchmarks/collector/temp/ike-scan-1.9/md5.h"
typedef struct md5_state_s md5_state_t;
#line 30 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned char __u_char;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 141 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __suseconds_t;
#line 33 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __u_char u_char;
#line 30 "/usr/include/x86_64-linux-gnu/bits/time.h"
struct timeval {
   __time_t tv_sec ;
   __suseconds_t tv_usec ;
};
#line 703 "/home/june/repo/benchmarks/collector/temp/ike-scan-1.9/utils.c"
union __anonunion_random_data_76 {
   uint32_t longword ;
   uint8_t byte[4] ;
};
#line 55 "/usr/include/x86_64-linux-gnu/sys/time.h"
struct timezone {
   int tz_minuteswest ;
   int tz_dsttime ;
};
#line 61 "/usr/include/x86_64-linux-gnu/sys/time.h"
typedef struct timezone * __restrict  __timezone_ptr_t;
#line 125 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uid_t;
#line 133 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __pid_t;
#line 135 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __clock_t;
#line 172 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __ssize_t;
#line 189 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __socklen_t;
#line 102 "/usr/include/stdio.h"
typedef __ssize_t ssize_t;
#line 75 "/usr/include/time.h"
typedef __time_t time_t;
#line 27 "/usr/include/x86_64-linux-gnu/bits/sigset.h"
struct __anonstruct___sigset_t_13 {
   unsigned long __val[1024UL / (8UL * sizeof(unsigned long ))] ;
};
#line 27 "/usr/include/x86_64-linux-gnu/bits/sigset.h"
typedef struct __anonstruct___sigset_t_13 __sigset_t;
#line 37 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef __sigset_t sigset_t;
#line 54 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef long __fd_mask;
#line 64 "/usr/include/x86_64-linux-gnu/sys/select.h"
struct __anonstruct_fd_set_14 {
   __fd_mask __fds_bits[1024 / (8 * (int )sizeof(__fd_mask ))] ;
};
#line 64 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef struct __anonstruct_fd_set_14 fd_set;
#line 274 "/usr/include/unistd.h"
typedef __socklen_t socklen_t;
#line 28 "/usr/include/x86_64-linux-gnu/bits/sockaddr.h"
typedef unsigned short sa_family_t;
#line 149 "/usr/include/x86_64-linux-gnu/bits/socket.h"
struct sockaddr {
   sa_family_t sa_family ;
   char sa_data[14] ;
};
#line 117 "/usr/include/netinet/in.h"
typedef uint16_t in_port_t;
#line 237 "/usr/include/netinet/in.h"
struct sockaddr_in {
   sa_family_t sin_family ;
   in_port_t sin_port ;
   struct in_addr sin_addr ;
   unsigned char sin_zero[((sizeof(struct sockaddr ) - sizeof(unsigned short )) - sizeof(in_port_t )) - sizeof(struct in_addr )] ;
};
#line 100 "/usr/include/netdb.h"
struct hostent {
   char *h_name ;
   char **h_aliases ;
   int h_addrtype ;
   int h_length ;
   char **h_addr_list ;
};
#line 94 "./getopt.h"
struct option {
   char const   *name ;
   int has_arg ;
   int *flag ;
   int val ;
};
#line 133 "/usr/include/time.h"
struct tm {
   int tm_sec ;
   int tm_min ;
   int tm_hour ;
   int tm_mday ;
   int tm_mon ;
   int tm_year ;
   int tm_wday ;
   int tm_yday ;
   int tm_isdst ;
   long tm_gmtoff ;
   char const   *tm_zone ;
};
#line 32 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
union sigval {
   int sival_int ;
   void *sival_ptr ;
};
#line 32 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
typedef union sigval sigval_t;
#line 58 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
typedef __clock_t __sigchld_clock_t;
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__kill_44 {
   __pid_t si_pid ;
   __uid_t si_uid ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__timer_45 {
   int si_tid ;
   int si_overrun ;
   sigval_t si_sigval ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__rt_46 {
   __pid_t si_pid ;
   __uid_t si_uid ;
   sigval_t si_sigval ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__sigchld_47 {
   __pid_t si_pid ;
   __uid_t si_uid ;
   int si_status ;
   __sigchld_clock_t si_utime ;
   __sigchld_clock_t si_stime ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__sigfault_48 {
   void *si_addr ;
   short si_addr_lsb ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__sigpoll_49 {
   long si_band ;
   int si_fd ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__sigsys_50 {
   void *_call_addr ;
   int _syscall ;
   unsigned int _arch ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
union __anonunion__sifields_43 {
   int _pad[128UL / sizeof(int ) - 4UL] ;
   struct __anonstruct__kill_44 _kill ;
   struct __anonstruct__timer_45 _timer ;
   struct __anonstruct__rt_46 _rt ;
   struct __anonstruct__sigchld_47 _sigchld ;
   struct __anonstruct__sigfault_48 _sigfault ;
   struct __anonstruct__sigpoll_49 _sigpoll ;
   struct __anonstruct__sigsys_50 _sigsys ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct_siginfo_t_42 {
   int si_signo ;
   int si_errno ;
   int si_code ;
   union __anonunion__sifields_43 _sifields ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
typedef struct __anonstruct_siginfo_t_42 siginfo_t;
#line 24 "/usr/include/x86_64-linux-gnu/bits/sigaction.h"
union __anonunion___sigaction_handler_62 {
   void (*sa_handler)(int  ) ;
   void (*sa_sigaction)(int  , siginfo_t * , void * ) ;
};
#line 24 "/usr/include/x86_64-linux-gnu/bits/sigaction.h"
struct sigaction {
   union __anonunion___sigaction_handler_62 __sigaction_handler ;
   __sigset_t sa_mask ;
   int sa_flags ;
   void (*sa_restorer)(void) ;
};
#line 23 "/home/june/repo/benchmarks/collector/temp/ike-scan-1.9/ip.h"
struct iphdr {
   unsigned int ihl : 4 ;
   unsigned int version : 4 ;
   uint8_t tos ;
   uint16_t tot_len ;
   uint16_t id ;
   uint16_t frag_off ;
   uint8_t ttl ;
   uint8_t protocol ;
   uint16_t check ;
   uint32_t saddr ;
   uint32_t daddr ;
};
#line 25 "/home/june/repo/benchmarks/collector/temp/ike-scan-1.9/udp.h"
struct udphdr {
   uint16_t source ;
   uint16_t dest ;
   uint16_t len ;
   uint16_t check ;
};
#line 33 "/home/june/repo/benchmarks/collector/temp/ike-scan-1.9/udp.h"
struct pseudo_hdr {
   uint32_t src_addr ;
   uint32_t dst_addr ;
   uint8_t mbz ;
   uint8_t proto ;
   uint16_t length ;
};
#line 213 "/home/june/repo/benchmarks/collector/temp/ike-scan-1.9/ike-scan.h"
struct time_list_ {
   struct timeval time ;
   struct time_list_ *next ;
};
#line 213 "/home/june/repo/benchmarks/collector/temp/ike-scan-1.9/ike-scan.h"
typedef struct time_list_ time_list;
#line 218 "/home/june/repo/benchmarks/collector/temp/ike-scan-1.9/ike-scan.h"
union __anonunion_un_70 {
   void *ptr ;
   int val ;
};
#line 218 "/home/june/repo/benchmarks/collector/temp/ike-scan-1.9/ike-scan.h"
struct __anonstruct_misc_data_69 {
   int id ;
   union __anonunion_un_70 un ;
};
#line 218 "/home/june/repo/benchmarks/collector/temp/ike-scan-1.9/ike-scan.h"
typedef struct __anonstruct_misc_data_69 misc_data;
#line 226 "/home/june/repo/benchmarks/collector/temp/ike-scan-1.9/ike-scan.h"
struct __anonstruct_host_entry_71 {
   time_list *recv_times ;
   misc_data *extra ;
   unsigned int n ;
   unsigned int timeout ;
   uint32_t icookie[2] ;
   struct in_addr addr ;
   struct timeval last_send_time ;
   unsigned short num_sent ;
   unsigned short num_recv ;
   unsigned char live ;
};
#line 226 "/home/june/repo/benchmarks/collector/temp/ike-scan-1.9/ike-scan.h"
typedef struct __anonstruct_host_entry_71 host_entry;
#line 239 "/home/june/repo/benchmarks/collector/temp/ike-scan-1.9/ike-scan.h"
struct pattern_entry_list_ {
   struct timeval time ;
   unsigned int fuzz ;
   struct pattern_entry_list_ *next ;
};
#line 239 "/home/june/repo/benchmarks/collector/temp/ike-scan-1.9/ike-scan.h"
typedef struct pattern_entry_list_ pattern_entry_list;
#line 245 "/home/june/repo/benchmarks/collector/temp/ike-scan-1.9/ike-scan.h"
struct pattern_list_ {
   char *name ;
   unsigned int num_times ;
   pattern_entry_list *recv_times ;
   struct pattern_list_ *next ;
};
#line 245 "/home/june/repo/benchmarks/collector/temp/ike-scan-1.9/ike-scan.h"
typedef struct pattern_list_ pattern_list;
#line 297 "/home/june/repo/benchmarks/collector/temp/ike-scan-1.9/ike-scan.h"
struct __anonstruct_ike_packet_params_75 {
   unsigned char *lifetime_data ;
   size_t lifetime_data_len ;
   unsigned char *lifesize_data ;
   size_t lifesize_data_len ;
   unsigned int auth_method ;
   unsigned int dhgroup ;
   unsigned int idtype ;
   unsigned char *id_data ;
   size_t id_data_len ;
   int vendor_id_flag ;
   int trans_flag ;
   unsigned int exchange_type ;
   int gss_id_flag ;
   unsigned char *gss_data ;
   size_t gss_data_len ;
   size_t nonce_data_len ;
   char *header_length ;
   unsigned char *cr_data ;
   size_t cr_data_len ;
   int header_version ;
   unsigned int doi ;
   unsigned int situation ;
   unsigned int protocol ;
   unsigned int trans_id ;
   unsigned int spi_size ;
   int hdr_flags ;
   unsigned int hdr_msgid ;
   unsigned int hdr_next_payload ;
   int advanced_trans_flag ;
   int ike_version ;
   unsigned char *rcookie_data ;
   size_t rcookie_data_len ;
};
#line 297 "/home/june/repo/benchmarks/collector/temp/ike-scan-1.9/ike-scan.h"
typedef struct __anonstruct_ike_packet_params_75 ike_packet_params;
#line 119 "/home/june/repo/benchmarks/collector/temp/ike-scan-1.9/psk-crack.h"
struct __anonstruct_psk_entry_28 {
   unsigned char *skeyid_data ;
   unsigned char *hash_r_data ;
   unsigned char *hash_r ;
   char *hash_r_hex ;
   char const   *hash_name ;
   char const   *nortel_user ;
   size_t skeyid_data_len ;
   size_t hash_r_data_len ;
   size_t hash_r_len ;
   int hash_type ;
   int live ;
};
#line 119 "/home/june/repo/benchmarks/collector/temp/ike-scan-1.9/psk-crack.h"
typedef struct __anonstruct_psk_entry_28 psk_entry;
#line 703 "/home/june/repo/benchmarks/collector/temp/ike-scan-1.9/utils.c"
union __anonunion_random_data_76___0 {
   uint32_t longword ;
   uint8_t byte[4] ;
};
#line 46 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memcpy)(void * __restrict  __dest ,
                                                                                                 void const   * __restrict  __src ,
                                                                                                 size_t __n ) ;
#line 66
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memset)(void *__s ,
                                                                                               int __c ,
                                                                                               size_t __n ) ;
#line 17 "/home/june/repo/benchmarks/collector/temp/ike-scan-1.9/sha1.h"
void SHA1Transform(uint32_t *state , unsigned char *buffer ) ;
#line 18
void SHA1Init(SHA1_CTX *context ) ;
#line 19
void SHA1Update(SHA1_CTX *context , unsigned char *data , unsigned int len ) ;
#line 20
void SHA1Final(unsigned char *digest , SHA1_CTX *context ) ;
#line 70 "/home/june/repo/benchmarks/collector/temp/ike-scan-1.9/sha1.c"
static unsigned char workspace[64]  ;
#line 61 "/home/june/repo/benchmarks/collector/temp/ike-scan-1.9/sha1.c"
void SHA1Transform(uint32_t *state , unsigned char *buffer ) 
{ 
  uint32_t a ;
  uint32_t b ;
  uint32_t c ;
  uint32_t d ;
  uint32_t e ;
  CHAR64LONG16 *block ;
  uint32_t tmp ;
  uint32_t tmp___0 ;
  uint32_t tmp___1 ;
  uint32_t tmp___2 ;
  uint32_t tmp___3 ;
  uint32_t tmp___4 ;
  uint32_t tmp___5 ;
  uint32_t tmp___6 ;
  uint32_t tmp___7 ;
  uint32_t tmp___8 ;
  uint32_t tmp___9 ;
  uint32_t tmp___10 ;
  uint32_t tmp___11 ;
  uint32_t tmp___12 ;
  uint32_t tmp___13 ;
  uint32_t tmp___14 ;
  uint32_t tmp___15 ;
  uint32_t tmp___16 ;
  uint32_t tmp___17 ;
  uint32_t tmp___18 ;
  uint32_t tmp___19 ;
  uint32_t tmp___20 ;
  uint32_t tmp___21 ;
  uint32_t tmp___22 ;
  uint32_t tmp___23 ;
  uint32_t tmp___24 ;
  uint32_t tmp___25 ;
  uint32_t tmp___26 ;
  uint32_t tmp___27 ;
  uint32_t tmp___28 ;
  uint32_t tmp___29 ;
  uint32_t tmp___30 ;
  uint32_t tmp___31 ;
  uint32_t tmp___32 ;
  uint32_t tmp___33 ;
  uint32_t tmp___34 ;
  uint32_t tmp___35 ;
  uint32_t tmp___36 ;
  uint32_t tmp___37 ;
  uint32_t tmp___38 ;
  uint32_t tmp___39 ;
  uint32_t tmp___40 ;
  uint32_t tmp___41 ;
  uint32_t tmp___42 ;
  uint32_t tmp___43 ;
  uint32_t tmp___44 ;
  uint32_t tmp___45 ;
  uint32_t tmp___46 ;
  uint32_t tmp___47 ;
  uint32_t tmp___48 ;
  uint32_t tmp___49 ;
  uint32_t tmp___50 ;
  uint32_t tmp___51 ;
  uint32_t tmp___52 ;
  uint32_t tmp___53 ;
  uint32_t tmp___54 ;
  uint32_t tmp___55 ;
  uint32_t tmp___56 ;
  uint32_t tmp___57 ;
  uint32_t tmp___58 ;
  uint32_t tmp___59 ;
  uint32_t tmp___60 ;
  uint32_t tmp___61 ;
  uint32_t tmp___62 ;
  uint32_t tmp___63 ;
  uint32_t tmp___64 ;
  uint32_t tmp___65 ;
  uint32_t tmp___66 ;
  uint32_t tmp___67 ;
  uint32_t tmp___68 ;
  uint32_t tmp___69 ;
  uint32_t tmp___70 ;
  uint32_t tmp___71 ;
  uint32_t tmp___72 ;
  uint32_t tmp___73 ;
  uint32_t tmp___74 ;
  uint32_t tmp___75 ;
  uint32_t tmp___76 ;
  uint32_t tmp___77 ;
  uint32_t tmp___78 ;

  {
  {
#line 71
  block = (CHAR64LONG16 *)(workspace);
#line 72
  memcpy((void */* __restrict  */)block, (void const   */* __restrict  */)buffer,
         (size_t )64);
#line 77
  a = *(state + 0);
#line 78
  b = *(state + 1);
#line 79
  c = *(state + 2);
#line 80
  d = *(state + 3);
#line 81
  e = *(state + 4);
#line 83
  tmp = (((block->l[0] << 24) | (block->l[0] >> 8)) & 4278255360U) | (((block->l[0] << 8) | (block->l[0] >> 24)) & 16711935U);
#line 83
  block->l[0] = tmp;
#line 83
  e += ((((b & (c ^ d)) ^ d) + tmp) + 1518500249U) + ((a << 5) | (a >> 27));
#line 83
  b = (b << 30) | (b >> 2);
#line 83
  tmp___0 = (((block->l[1] << 24) | (block->l[1] >> 8)) & 4278255360U) | (((block->l[1] << 8) | (block->l[1] >> 24)) & 16711935U);
#line 83
  block->l[1] = tmp___0;
#line 83
  d += ((((a & (b ^ c)) ^ c) + tmp___0) + 1518500249U) + ((e << 5) | (e >> 27));
#line 83
  a = (a << 30) | (a >> 2);
#line 83
  tmp___1 = (((block->l[2] << 24) | (block->l[2] >> 8)) & 4278255360U) | (((block->l[2] << 8) | (block->l[2] >> 24)) & 16711935U);
#line 83
  block->l[2] = tmp___1;
#line 83
  c += ((((e & (a ^ b)) ^ b) + tmp___1) + 1518500249U) + ((d << 5) | (d >> 27));
#line 83
  e = (e << 30) | (e >> 2);
#line 83
  tmp___2 = (((block->l[3] << 24) | (block->l[3] >> 8)) & 4278255360U) | (((block->l[3] << 8) | (block->l[3] >> 24)) & 16711935U);
#line 83
  block->l[3] = tmp___2;
#line 83
  b += ((((d & (e ^ a)) ^ a) + tmp___2) + 1518500249U) + ((c << 5) | (c >> 27));
#line 83
  d = (d << 30) | (d >> 2);
#line 84
  tmp___3 = (((block->l[4] << 24) | (block->l[4] >> 8)) & 4278255360U) | (((block->l[4] << 8) | (block->l[4] >> 24)) & 16711935U);
#line 84
  block->l[4] = tmp___3;
#line 84
  a += ((((c & (d ^ e)) ^ e) + tmp___3) + 1518500249U) + ((b << 5) | (b >> 27));
#line 84
  c = (c << 30) | (c >> 2);
#line 84
  tmp___4 = (((block->l[5] << 24) | (block->l[5] >> 8)) & 4278255360U) | (((block->l[5] << 8) | (block->l[5] >> 24)) & 16711935U);
#line 84
  block->l[5] = tmp___4;
#line 84
  e += ((((b & (c ^ d)) ^ d) + tmp___4) + 1518500249U) + ((a << 5) | (a >> 27));
#line 84
  b = (b << 30) | (b >> 2);
#line 84
  tmp___5 = (((block->l[6] << 24) | (block->l[6] >> 8)) & 4278255360U) | (((block->l[6] << 8) | (block->l[6] >> 24)) & 16711935U);
#line 84
  block->l[6] = tmp___5;
#line 84
  d += ((((a & (b ^ c)) ^ c) + tmp___5) + 1518500249U) + ((e << 5) | (e >> 27));
#line 84
  a = (a << 30) | (a >> 2);
#line 84
  tmp___6 = (((block->l[7] << 24) | (block->l[7] >> 8)) & 4278255360U) | (((block->l[7] << 8) | (block->l[7] >> 24)) & 16711935U);
#line 84
  block->l[7] = tmp___6;
#line 84
  c += ((((e & (a ^ b)) ^ b) + tmp___6) + 1518500249U) + ((d << 5) | (d >> 27));
#line 84
  e = (e << 30) | (e >> 2);
#line 85
  tmp___7 = (((block->l[8] << 24) | (block->l[8] >> 8)) & 4278255360U) | (((block->l[8] << 8) | (block->l[8] >> 24)) & 16711935U);
#line 85
  block->l[8] = tmp___7;
#line 85
  b += ((((d & (e ^ a)) ^ a) + tmp___7) + 1518500249U) + ((c << 5) | (c >> 27));
#line 85
  d = (d << 30) | (d >> 2);
#line 85
  tmp___8 = (((block->l[9] << 24) | (block->l[9] >> 8)) & 4278255360U) | (((block->l[9] << 8) | (block->l[9] >> 24)) & 16711935U);
#line 85
  block->l[9] = tmp___8;
#line 85
  a += ((((c & (d ^ e)) ^ e) + tmp___8) + 1518500249U) + ((b << 5) | (b >> 27));
#line 85
  c = (c << 30) | (c >> 2);
#line 85
  tmp___9 = (((block->l[10] << 24) | (block->l[10] >> 8)) & 4278255360U) | (((block->l[10] << 8) | (block->l[10] >> 24)) & 16711935U);
#line 85
  block->l[10] = tmp___9;
#line 85
  e += ((((b & (c ^ d)) ^ d) + tmp___9) + 1518500249U) + ((a << 5) | (a >> 27));
#line 85
  b = (b << 30) | (b >> 2);
#line 85
  tmp___10 = (((block->l[11] << 24) | (block->l[11] >> 8)) & 4278255360U) | (((block->l[11] << 8) | (block->l[11] >> 24)) & 16711935U);
#line 85
  block->l[11] = tmp___10;
#line 85
  d += ((((a & (b ^ c)) ^ c) + tmp___10) + 1518500249U) + ((e << 5) | (e >> 27));
#line 85
  a = (a << 30) | (a >> 2);
#line 86
  tmp___11 = (((block->l[12] << 24) | (block->l[12] >> 8)) & 4278255360U) | (((block->l[12] << 8) | (block->l[12] >> 24)) & 16711935U);
#line 86
  block->l[12] = tmp___11;
#line 86
  c += ((((e & (a ^ b)) ^ b) + tmp___11) + 1518500249U) + ((d << 5) | (d >> 27));
#line 86
  e = (e << 30) | (e >> 2);
#line 86
  tmp___12 = (((block->l[13] << 24) | (block->l[13] >> 8)) & 4278255360U) | (((block->l[13] << 8) | (block->l[13] >> 24)) & 16711935U);
#line 86
  block->l[13] = tmp___12;
#line 86
  b += ((((d & (e ^ a)) ^ a) + tmp___12) + 1518500249U) + ((c << 5) | (c >> 27));
#line 86
  d = (d << 30) | (d >> 2);
#line 86
  tmp___13 = (((block->l[14] << 24) | (block->l[14] >> 8)) & 4278255360U) | (((block->l[14] << 8) | (block->l[14] >> 24)) & 16711935U);
#line 86
  block->l[14] = tmp___13;
#line 86
  a += ((((c & (d ^ e)) ^ e) + tmp___13) + 1518500249U) + ((b << 5) | (b >> 27));
#line 86
  c = (c << 30) | (c >> 2);
#line 86
  tmp___14 = (((block->l[15] << 24) | (block->l[15] >> 8)) & 4278255360U) | (((block->l[15] << 8) | (block->l[15] >> 24)) & 16711935U);
#line 86
  block->l[15] = tmp___14;
#line 86
  e += ((((b & (c ^ d)) ^ d) + tmp___14) + 1518500249U) + ((a << 5) | (a >> 27));
#line 86
  b = (b << 30) | (b >> 2);
#line 87
  tmp___15 = ((((block->l[13] ^ block->l[8]) ^ block->l[2]) ^ block->l[0]) << 1) | ((((block->l[13] ^ block->l[8]) ^ block->l[2]) ^ block->l[0]) >> 31);
#line 87
  block->l[0] = tmp___15;
#line 87
  d += ((((a & (b ^ c)) ^ c) + tmp___15) + 1518500249U) + ((e << 5) | (e >> 27));
#line 87
  a = (a << 30) | (a >> 2);
#line 87
  tmp___16 = ((((block->l[14] ^ block->l[9]) ^ block->l[3]) ^ block->l[1]) << 1) | ((((block->l[14] ^ block->l[9]) ^ block->l[3]) ^ block->l[1]) >> 31);
#line 87
  block->l[1] = tmp___16;
#line 87
  c += ((((e & (a ^ b)) ^ b) + tmp___16) + 1518500249U) + ((d << 5) | (d >> 27));
#line 87
  e = (e << 30) | (e >> 2);
#line 87
  tmp___17 = ((((block->l[15] ^ block->l[10]) ^ block->l[4]) ^ block->l[2]) << 1) | ((((block->l[15] ^ block->l[10]) ^ block->l[4]) ^ block->l[2]) >> 31);
#line 87
  block->l[2] = tmp___17;
#line 87
  b += ((((d & (e ^ a)) ^ a) + tmp___17) + 1518500249U) + ((c << 5) | (c >> 27));
#line 87
  d = (d << 30) | (d >> 2);
#line 87
  tmp___18 = ((((block->l[0] ^ block->l[11]) ^ block->l[5]) ^ block->l[3]) << 1) | ((((block->l[0] ^ block->l[11]) ^ block->l[5]) ^ block->l[3]) >> 31);
#line 87
  block->l[3] = tmp___18;
#line 87
  a += ((((c & (d ^ e)) ^ e) + tmp___18) + 1518500249U) + ((b << 5) | (b >> 27));
#line 87
  c = (c << 30) | (c >> 2);
#line 88
  tmp___19 = ((((block->l[1] ^ block->l[12]) ^ block->l[6]) ^ block->l[4]) << 1) | ((((block->l[1] ^ block->l[12]) ^ block->l[6]) ^ block->l[4]) >> 31);
#line 88
  block->l[4] = tmp___19;
#line 88
  e += ((((b ^ c) ^ d) + tmp___19) + 1859775393U) + ((a << 5) | (a >> 27));
#line 88
  b = (b << 30) | (b >> 2);
#line 88
  tmp___20 = ((((block->l[2] ^ block->l[13]) ^ block->l[7]) ^ block->l[5]) << 1) | ((((block->l[2] ^ block->l[13]) ^ block->l[7]) ^ block->l[5]) >> 31);
#line 88
  block->l[5] = tmp___20;
#line 88
  d += ((((a ^ b) ^ c) + tmp___20) + 1859775393U) + ((e << 5) | (e >> 27));
#line 88
  a = (a << 30) | (a >> 2);
#line 88
  tmp___21 = ((((block->l[3] ^ block->l[14]) ^ block->l[8]) ^ block->l[6]) << 1) | ((((block->l[3] ^ block->l[14]) ^ block->l[8]) ^ block->l[6]) >> 31);
#line 88
  block->l[6] = tmp___21;
#line 88
  c += ((((e ^ a) ^ b) + tmp___21) + 1859775393U) + ((d << 5) | (d >> 27));
#line 88
  e = (e << 30) | (e >> 2);
#line 88
  tmp___22 = ((((block->l[4] ^ block->l[15]) ^ block->l[9]) ^ block->l[7]) << 1) | ((((block->l[4] ^ block->l[15]) ^ block->l[9]) ^ block->l[7]) >> 31);
#line 88
  block->l[7] = tmp___22;
#line 88
  b += ((((d ^ e) ^ a) + tmp___22) + 1859775393U) + ((c << 5) | (c >> 27));
#line 88
  d = (d << 30) | (d >> 2);
#line 89
  tmp___23 = ((((block->l[5] ^ block->l[0]) ^ block->l[10]) ^ block->l[8]) << 1) | ((((block->l[5] ^ block->l[0]) ^ block->l[10]) ^ block->l[8]) >> 31);
#line 89
  block->l[8] = tmp___23;
#line 89
  a += ((((c ^ d) ^ e) + tmp___23) + 1859775393U) + ((b << 5) | (b >> 27));
#line 89
  c = (c << 30) | (c >> 2);
#line 89
  tmp___24 = ((((block->l[6] ^ block->l[1]) ^ block->l[11]) ^ block->l[9]) << 1) | ((((block->l[6] ^ block->l[1]) ^ block->l[11]) ^ block->l[9]) >> 31);
#line 89
  block->l[9] = tmp___24;
#line 89
  e += ((((b ^ c) ^ d) + tmp___24) + 1859775393U) + ((a << 5) | (a >> 27));
#line 89
  b = (b << 30) | (b >> 2);
#line 89
  tmp___25 = ((((block->l[7] ^ block->l[2]) ^ block->l[12]) ^ block->l[10]) << 1) | ((((block->l[7] ^ block->l[2]) ^ block->l[12]) ^ block->l[10]) >> 31);
#line 89
  block->l[10] = tmp___25;
#line 89
  d += ((((a ^ b) ^ c) + tmp___25) + 1859775393U) + ((e << 5) | (e >> 27));
#line 89
  a = (a << 30) | (a >> 2);
#line 89
  tmp___26 = ((((block->l[8] ^ block->l[3]) ^ block->l[13]) ^ block->l[11]) << 1) | ((((block->l[8] ^ block->l[3]) ^ block->l[13]) ^ block->l[11]) >> 31);
#line 89
  block->l[11] = tmp___26;
#line 89
  c += ((((e ^ a) ^ b) + tmp___26) + 1859775393U) + ((d << 5) | (d >> 27));
#line 89
  e = (e << 30) | (e >> 2);
#line 90
  tmp___27 = ((((block->l[9] ^ block->l[4]) ^ block->l[14]) ^ block->l[12]) << 1) | ((((block->l[9] ^ block->l[4]) ^ block->l[14]) ^ block->l[12]) >> 31);
#line 90
  block->l[12] = tmp___27;
#line 90
  b += ((((d ^ e) ^ a) + tmp___27) + 1859775393U) + ((c << 5) | (c >> 27));
#line 90
  d = (d << 30) | (d >> 2);
#line 90
  tmp___28 = ((((block->l[10] ^ block->l[5]) ^ block->l[15]) ^ block->l[13]) << 1) | ((((block->l[10] ^ block->l[5]) ^ block->l[15]) ^ block->l[13]) >> 31);
#line 90
  block->l[13] = tmp___28;
#line 90
  a += ((((c ^ d) ^ e) + tmp___28) + 1859775393U) + ((b << 5) | (b >> 27));
#line 90
  c = (c << 30) | (c >> 2);
#line 90
  tmp___29 = ((((block->l[11] ^ block->l[6]) ^ block->l[0]) ^ block->l[14]) << 1) | ((((block->l[11] ^ block->l[6]) ^ block->l[0]) ^ block->l[14]) >> 31);
#line 90
  block->l[14] = tmp___29;
#line 90
  e += ((((b ^ c) ^ d) + tmp___29) + 1859775393U) + ((a << 5) | (a >> 27));
#line 90
  b = (b << 30) | (b >> 2);
#line 90
  tmp___30 = ((((block->l[12] ^ block->l[7]) ^ block->l[1]) ^ block->l[15]) << 1) | ((((block->l[12] ^ block->l[7]) ^ block->l[1]) ^ block->l[15]) >> 31);
#line 90
  block->l[15] = tmp___30;
#line 90
  d += ((((a ^ b) ^ c) + tmp___30) + 1859775393U) + ((e << 5) | (e >> 27));
#line 90
  a = (a << 30) | (a >> 2);
#line 91
  tmp___31 = ((((block->l[13] ^ block->l[8]) ^ block->l[2]) ^ block->l[0]) << 1) | ((((block->l[13] ^ block->l[8]) ^ block->l[2]) ^ block->l[0]) >> 31);
#line 91
  block->l[0] = tmp___31;
#line 91
  c += ((((e ^ a) ^ b) + tmp___31) + 1859775393U) + ((d << 5) | (d >> 27));
#line 91
  e = (e << 30) | (e >> 2);
#line 91
  tmp___32 = ((((block->l[14] ^ block->l[9]) ^ block->l[3]) ^ block->l[1]) << 1) | ((((block->l[14] ^ block->l[9]) ^ block->l[3]) ^ block->l[1]) >> 31);
#line 91
  block->l[1] = tmp___32;
#line 91
  b += ((((d ^ e) ^ a) + tmp___32) + 1859775393U) + ((c << 5) | (c >> 27));
#line 91
  d = (d << 30) | (d >> 2);
#line 91
  tmp___33 = ((((block->l[15] ^ block->l[10]) ^ block->l[4]) ^ block->l[2]) << 1) | ((((block->l[15] ^ block->l[10]) ^ block->l[4]) ^ block->l[2]) >> 31);
#line 91
  block->l[2] = tmp___33;
#line 91
  a += ((((c ^ d) ^ e) + tmp___33) + 1859775393U) + ((b << 5) | (b >> 27));
#line 91
  c = (c << 30) | (c >> 2);
#line 91
  tmp___34 = ((((block->l[0] ^ block->l[11]) ^ block->l[5]) ^ block->l[3]) << 1) | ((((block->l[0] ^ block->l[11]) ^ block->l[5]) ^ block->l[3]) >> 31);
#line 91
  block->l[3] = tmp___34;
#line 91
  e += ((((b ^ c) ^ d) + tmp___34) + 1859775393U) + ((a << 5) | (a >> 27));
#line 91
  b = (b << 30) | (b >> 2);
#line 92
  tmp___35 = ((((block->l[1] ^ block->l[12]) ^ block->l[6]) ^ block->l[4]) << 1) | ((((block->l[1] ^ block->l[12]) ^ block->l[6]) ^ block->l[4]) >> 31);
#line 92
  block->l[4] = tmp___35;
#line 92
  d += ((((a ^ b) ^ c) + tmp___35) + 1859775393U) + ((e << 5) | (e >> 27));
#line 92
  a = (a << 30) | (a >> 2);
#line 92
  tmp___36 = ((((block->l[2] ^ block->l[13]) ^ block->l[7]) ^ block->l[5]) << 1) | ((((block->l[2] ^ block->l[13]) ^ block->l[7]) ^ block->l[5]) >> 31);
#line 92
  block->l[5] = tmp___36;
#line 92
  c += ((((e ^ a) ^ b) + tmp___36) + 1859775393U) + ((d << 5) | (d >> 27));
#line 92
  e = (e << 30) | (e >> 2);
#line 92
  tmp___37 = ((((block->l[3] ^ block->l[14]) ^ block->l[8]) ^ block->l[6]) << 1) | ((((block->l[3] ^ block->l[14]) ^ block->l[8]) ^ block->l[6]) >> 31);
#line 92
  block->l[6] = tmp___37;
#line 92
  b += ((((d ^ e) ^ a) + tmp___37) + 1859775393U) + ((c << 5) | (c >> 27));
#line 92
  d = (d << 30) | (d >> 2);
#line 92
  tmp___38 = ((((block->l[4] ^ block->l[15]) ^ block->l[9]) ^ block->l[7]) << 1) | ((((block->l[4] ^ block->l[15]) ^ block->l[9]) ^ block->l[7]) >> 31);
#line 92
  block->l[7] = tmp___38;
#line 92
  a += ((((c ^ d) ^ e) + tmp___38) + 1859775393U) + ((b << 5) | (b >> 27));
#line 92
  c = (c << 30) | (c >> 2);
#line 93
  tmp___39 = ((((block->l[5] ^ block->l[0]) ^ block->l[10]) ^ block->l[8]) << 1) | ((((block->l[5] ^ block->l[0]) ^ block->l[10]) ^ block->l[8]) >> 31);
#line 93
  block->l[8] = tmp___39;
#line 93
  e += (((((b | c) & d) | (b & c)) + tmp___39) + 2400959708U) + ((a << 5) | (a >> 27));
#line 93
  b = (b << 30) | (b >> 2);
#line 93
  tmp___40 = ((((block->l[6] ^ block->l[1]) ^ block->l[11]) ^ block->l[9]) << 1) | ((((block->l[6] ^ block->l[1]) ^ block->l[11]) ^ block->l[9]) >> 31);
#line 93
  block->l[9] = tmp___40;
#line 93
  d += (((((a | b) & c) | (a & b)) + tmp___40) + 2400959708U) + ((e << 5) | (e >> 27));
#line 93
  a = (a << 30) | (a >> 2);
#line 93
  tmp___41 = ((((block->l[7] ^ block->l[2]) ^ block->l[12]) ^ block->l[10]) << 1) | ((((block->l[7] ^ block->l[2]) ^ block->l[12]) ^ block->l[10]) >> 31);
#line 93
  block->l[10] = tmp___41;
#line 93
  c += (((((e | a) & b) | (e & a)) + tmp___41) + 2400959708U) + ((d << 5) | (d >> 27));
#line 93
  e = (e << 30) | (e >> 2);
#line 93
  tmp___42 = ((((block->l[8] ^ block->l[3]) ^ block->l[13]) ^ block->l[11]) << 1) | ((((block->l[8] ^ block->l[3]) ^ block->l[13]) ^ block->l[11]) >> 31);
#line 93
  block->l[11] = tmp___42;
#line 93
  b += (((((d | e) & a) | (d & e)) + tmp___42) + 2400959708U) + ((c << 5) | (c >> 27));
#line 93
  d = (d << 30) | (d >> 2);
#line 94
  tmp___43 = ((((block->l[9] ^ block->l[4]) ^ block->l[14]) ^ block->l[12]) << 1) | ((((block->l[9] ^ block->l[4]) ^ block->l[14]) ^ block->l[12]) >> 31);
#line 94
  block->l[12] = tmp___43;
#line 94
  a += (((((c | d) & e) | (c & d)) + tmp___43) + 2400959708U) + ((b << 5) | (b >> 27));
#line 94
  c = (c << 30) | (c >> 2);
#line 94
  tmp___44 = ((((block->l[10] ^ block->l[5]) ^ block->l[15]) ^ block->l[13]) << 1) | ((((block->l[10] ^ block->l[5]) ^ block->l[15]) ^ block->l[13]) >> 31);
#line 94
  block->l[13] = tmp___44;
#line 94
  e += (((((b | c) & d) | (b & c)) + tmp___44) + 2400959708U) + ((a << 5) | (a >> 27));
#line 94
  b = (b << 30) | (b >> 2);
#line 94
  tmp___45 = ((((block->l[11] ^ block->l[6]) ^ block->l[0]) ^ block->l[14]) << 1) | ((((block->l[11] ^ block->l[6]) ^ block->l[0]) ^ block->l[14]) >> 31);
#line 94
  block->l[14] = tmp___45;
#line 94
  d += (((((a | b) & c) | (a & b)) + tmp___45) + 2400959708U) + ((e << 5) | (e >> 27));
#line 94
  a = (a << 30) | (a >> 2);
#line 94
  tmp___46 = ((((block->l[12] ^ block->l[7]) ^ block->l[1]) ^ block->l[15]) << 1) | ((((block->l[12] ^ block->l[7]) ^ block->l[1]) ^ block->l[15]) >> 31);
#line 94
  block->l[15] = tmp___46;
#line 94
  c += (((((e | a) & b) | (e & a)) + tmp___46) + 2400959708U) + ((d << 5) | (d >> 27));
#line 94
  e = (e << 30) | (e >> 2);
#line 95
  tmp___47 = ((((block->l[13] ^ block->l[8]) ^ block->l[2]) ^ block->l[0]) << 1) | ((((block->l[13] ^ block->l[8]) ^ block->l[2]) ^ block->l[0]) >> 31);
#line 95
  block->l[0] = tmp___47;
#line 95
  b += (((((d | e) & a) | (d & e)) + tmp___47) + 2400959708U) + ((c << 5) | (c >> 27));
#line 95
  d = (d << 30) | (d >> 2);
#line 95
  tmp___48 = ((((block->l[14] ^ block->l[9]) ^ block->l[3]) ^ block->l[1]) << 1) | ((((block->l[14] ^ block->l[9]) ^ block->l[3]) ^ block->l[1]) >> 31);
#line 95
  block->l[1] = tmp___48;
#line 95
  a += (((((c | d) & e) | (c & d)) + tmp___48) + 2400959708U) + ((b << 5) | (b >> 27));
#line 95
  c = (c << 30) | (c >> 2);
#line 95
  tmp___49 = ((((block->l[15] ^ block->l[10]) ^ block->l[4]) ^ block->l[2]) << 1) | ((((block->l[15] ^ block->l[10]) ^ block->l[4]) ^ block->l[2]) >> 31);
#line 95
  block->l[2] = tmp___49;
#line 95
  e += (((((b | c) & d) | (b & c)) + tmp___49) + 2400959708U) + ((a << 5) | (a >> 27));
#line 95
  b = (b << 30) | (b >> 2);
#line 95
  tmp___50 = ((((block->l[0] ^ block->l[11]) ^ block->l[5]) ^ block->l[3]) << 1) | ((((block->l[0] ^ block->l[11]) ^ block->l[5]) ^ block->l[3]) >> 31);
#line 95
  block->l[3] = tmp___50;
#line 95
  d += (((((a | b) & c) | (a & b)) + tmp___50) + 2400959708U) + ((e << 5) | (e >> 27));
#line 95
  a = (a << 30) | (a >> 2);
#line 96
  tmp___51 = ((((block->l[1] ^ block->l[12]) ^ block->l[6]) ^ block->l[4]) << 1) | ((((block->l[1] ^ block->l[12]) ^ block->l[6]) ^ block->l[4]) >> 31);
#line 96
  block->l[4] = tmp___51;
#line 96
  c += (((((e | a) & b) | (e & a)) + tmp___51) + 2400959708U) + ((d << 5) | (d >> 27));
#line 96
  e = (e << 30) | (e >> 2);
#line 96
  tmp___52 = ((((block->l[2] ^ block->l[13]) ^ block->l[7]) ^ block->l[5]) << 1) | ((((block->l[2] ^ block->l[13]) ^ block->l[7]) ^ block->l[5]) >> 31);
#line 96
  block->l[5] = tmp___52;
#line 96
  b += (((((d | e) & a) | (d & e)) + tmp___52) + 2400959708U) + ((c << 5) | (c >> 27));
#line 96
  d = (d << 30) | (d >> 2);
#line 96
  tmp___53 = ((((block->l[3] ^ block->l[14]) ^ block->l[8]) ^ block->l[6]) << 1) | ((((block->l[3] ^ block->l[14]) ^ block->l[8]) ^ block->l[6]) >> 31);
#line 96
  block->l[6] = tmp___53;
#line 96
  a += (((((c | d) & e) | (c & d)) + tmp___53) + 2400959708U) + ((b << 5) | (b >> 27));
#line 96
  c = (c << 30) | (c >> 2);
#line 96
  tmp___54 = ((((block->l[4] ^ block->l[15]) ^ block->l[9]) ^ block->l[7]) << 1) | ((((block->l[4] ^ block->l[15]) ^ block->l[9]) ^ block->l[7]) >> 31);
#line 96
  block->l[7] = tmp___54;
#line 96
  e += (((((b | c) & d) | (b & c)) + tmp___54) + 2400959708U) + ((a << 5) | (a >> 27));
#line 96
  b = (b << 30) | (b >> 2);
#line 97
  tmp___55 = ((((block->l[5] ^ block->l[0]) ^ block->l[10]) ^ block->l[8]) << 1) | ((((block->l[5] ^ block->l[0]) ^ block->l[10]) ^ block->l[8]) >> 31);
#line 97
  block->l[8] = tmp___55;
#line 97
  d += (((((a | b) & c) | (a & b)) + tmp___55) + 2400959708U) + ((e << 5) | (e >> 27));
#line 97
  a = (a << 30) | (a >> 2);
#line 97
  tmp___56 = ((((block->l[6] ^ block->l[1]) ^ block->l[11]) ^ block->l[9]) << 1) | ((((block->l[6] ^ block->l[1]) ^ block->l[11]) ^ block->l[9]) >> 31);
#line 97
  block->l[9] = tmp___56;
#line 97
  c += (((((e | a) & b) | (e & a)) + tmp___56) + 2400959708U) + ((d << 5) | (d >> 27));
#line 97
  e = (e << 30) | (e >> 2);
#line 97
  tmp___57 = ((((block->l[7] ^ block->l[2]) ^ block->l[12]) ^ block->l[10]) << 1) | ((((block->l[7] ^ block->l[2]) ^ block->l[12]) ^ block->l[10]) >> 31);
#line 97
  block->l[10] = tmp___57;
#line 97
  b += (((((d | e) & a) | (d & e)) + tmp___57) + 2400959708U) + ((c << 5) | (c >> 27));
#line 97
  d = (d << 30) | (d >> 2);
#line 97
  tmp___58 = ((((block->l[8] ^ block->l[3]) ^ block->l[13]) ^ block->l[11]) << 1) | ((((block->l[8] ^ block->l[3]) ^ block->l[13]) ^ block->l[11]) >> 31);
#line 97
  block->l[11] = tmp___58;
#line 97
  a += (((((c | d) & e) | (c & d)) + tmp___58) + 2400959708U) + ((b << 5) | (b >> 27));
#line 97
  c = (c << 30) | (c >> 2);
#line 98
  tmp___59 = ((((block->l[9] ^ block->l[4]) ^ block->l[14]) ^ block->l[12]) << 1) | ((((block->l[9] ^ block->l[4]) ^ block->l[14]) ^ block->l[12]) >> 31);
#line 98
  block->l[12] = tmp___59;
#line 98
  e += ((((b ^ c) ^ d) + tmp___59) + 3395469782U) + ((a << 5) | (a >> 27));
#line 98
  b = (b << 30) | (b >> 2);
#line 98
  tmp___60 = ((((block->l[10] ^ block->l[5]) ^ block->l[15]) ^ block->l[13]) << 1) | ((((block->l[10] ^ block->l[5]) ^ block->l[15]) ^ block->l[13]) >> 31);
#line 98
  block->l[13] = tmp___60;
#line 98
  d += ((((a ^ b) ^ c) + tmp___60) + 3395469782U) + ((e << 5) | (e >> 27));
#line 98
  a = (a << 30) | (a >> 2);
#line 98
  tmp___61 = ((((block->l[11] ^ block->l[6]) ^ block->l[0]) ^ block->l[14]) << 1) | ((((block->l[11] ^ block->l[6]) ^ block->l[0]) ^ block->l[14]) >> 31);
#line 98
  block->l[14] = tmp___61;
#line 98
  c += ((((e ^ a) ^ b) + tmp___61) + 3395469782U) + ((d << 5) | (d >> 27));
#line 98
  e = (e << 30) | (e >> 2);
#line 98
  tmp___62 = ((((block->l[12] ^ block->l[7]) ^ block->l[1]) ^ block->l[15]) << 1) | ((((block->l[12] ^ block->l[7]) ^ block->l[1]) ^ block->l[15]) >> 31);
#line 98
  block->l[15] = tmp___62;
#line 98
  b += ((((d ^ e) ^ a) + tmp___62) + 3395469782U) + ((c << 5) | (c >> 27));
#line 98
  d = (d << 30) | (d >> 2);
#line 99
  tmp___63 = ((((block->l[13] ^ block->l[8]) ^ block->l[2]) ^ block->l[0]) << 1) | ((((block->l[13] ^ block->l[8]) ^ block->l[2]) ^ block->l[0]) >> 31);
#line 99
  block->l[0] = tmp___63;
#line 99
  a += ((((c ^ d) ^ e) + tmp___63) + 3395469782U) + ((b << 5) | (b >> 27));
#line 99
  c = (c << 30) | (c >> 2);
#line 99
  tmp___64 = ((((block->l[14] ^ block->l[9]) ^ block->l[3]) ^ block->l[1]) << 1) | ((((block->l[14] ^ block->l[9]) ^ block->l[3]) ^ block->l[1]) >> 31);
#line 99
  block->l[1] = tmp___64;
#line 99
  e += ((((b ^ c) ^ d) + tmp___64) + 3395469782U) + ((a << 5) | (a >> 27));
#line 99
  b = (b << 30) | (b >> 2);
#line 99
  tmp___65 = ((((block->l[15] ^ block->l[10]) ^ block->l[4]) ^ block->l[2]) << 1) | ((((block->l[15] ^ block->l[10]) ^ block->l[4]) ^ block->l[2]) >> 31);
#line 99
  block->l[2] = tmp___65;
#line 99
  d += ((((a ^ b) ^ c) + tmp___65) + 3395469782U) + ((e << 5) | (e >> 27));
#line 99
  a = (a << 30) | (a >> 2);
#line 99
  tmp___66 = ((((block->l[0] ^ block->l[11]) ^ block->l[5]) ^ block->l[3]) << 1) | ((((block->l[0] ^ block->l[11]) ^ block->l[5]) ^ block->l[3]) >> 31);
#line 99
  block->l[3] = tmp___66;
#line 99
  c += ((((e ^ a) ^ b) + tmp___66) + 3395469782U) + ((d << 5) | (d >> 27));
#line 99
  e = (e << 30) | (e >> 2);
#line 100
  tmp___67 = ((((block->l[1] ^ block->l[12]) ^ block->l[6]) ^ block->l[4]) << 1) | ((((block->l[1] ^ block->l[12]) ^ block->l[6]) ^ block->l[4]) >> 31);
#line 100
  block->l[4] = tmp___67;
#line 100
  b += ((((d ^ e) ^ a) + tmp___67) + 3395469782U) + ((c << 5) | (c >> 27));
#line 100
  d = (d << 30) | (d >> 2);
#line 100
  tmp___68 = ((((block->l[2] ^ block->l[13]) ^ block->l[7]) ^ block->l[5]) << 1) | ((((block->l[2] ^ block->l[13]) ^ block->l[7]) ^ block->l[5]) >> 31);
#line 100
  block->l[5] = tmp___68;
#line 100
  a += ((((c ^ d) ^ e) + tmp___68) + 3395469782U) + ((b << 5) | (b >> 27));
#line 100
  c = (c << 30) | (c >> 2);
#line 100
  tmp___69 = ((((block->l[3] ^ block->l[14]) ^ block->l[8]) ^ block->l[6]) << 1) | ((((block->l[3] ^ block->l[14]) ^ block->l[8]) ^ block->l[6]) >> 31);
#line 100
  block->l[6] = tmp___69;
#line 100
  e += ((((b ^ c) ^ d) + tmp___69) + 3395469782U) + ((a << 5) | (a >> 27));
#line 100
  b = (b << 30) | (b >> 2);
#line 100
  tmp___70 = ((((block->l[4] ^ block->l[15]) ^ block->l[9]) ^ block->l[7]) << 1) | ((((block->l[4] ^ block->l[15]) ^ block->l[9]) ^ block->l[7]) >> 31);
#line 100
  block->l[7] = tmp___70;
#line 100
  d += ((((a ^ b) ^ c) + tmp___70) + 3395469782U) + ((e << 5) | (e >> 27));
#line 100
  a = (a << 30) | (a >> 2);
#line 101
  tmp___71 = ((((block->l[5] ^ block->l[0]) ^ block->l[10]) ^ block->l[8]) << 1) | ((((block->l[5] ^ block->l[0]) ^ block->l[10]) ^ block->l[8]) >> 31);
#line 101
  block->l[8] = tmp___71;
#line 101
  c += ((((e ^ a) ^ b) + tmp___71) + 3395469782U) + ((d << 5) | (d >> 27));
#line 101
  e = (e << 30) | (e >> 2);
#line 101
  tmp___72 = ((((block->l[6] ^ block->l[1]) ^ block->l[11]) ^ block->l[9]) << 1) | ((((block->l[6] ^ block->l[1]) ^ block->l[11]) ^ block->l[9]) >> 31);
#line 101
  block->l[9] = tmp___72;
#line 101
  b += ((((d ^ e) ^ a) + tmp___72) + 3395469782U) + ((c << 5) | (c >> 27));
#line 101
  d = (d << 30) | (d >> 2);
#line 101
  tmp___73 = ((((block->l[7] ^ block->l[2]) ^ block->l[12]) ^ block->l[10]) << 1) | ((((block->l[7] ^ block->l[2]) ^ block->l[12]) ^ block->l[10]) >> 31);
#line 101
  block->l[10] = tmp___73;
#line 101
  a += ((((c ^ d) ^ e) + tmp___73) + 3395469782U) + ((b << 5) | (b >> 27));
#line 101
  c = (c << 30) | (c >> 2);
#line 101
  tmp___74 = ((((block->l[8] ^ block->l[3]) ^ block->l[13]) ^ block->l[11]) << 1) | ((((block->l[8] ^ block->l[3]) ^ block->l[13]) ^ block->l[11]) >> 31);
#line 101
  block->l[11] = tmp___74;
#line 101
  e += ((((b ^ c) ^ d) + tmp___74) + 3395469782U) + ((a << 5) | (a >> 27));
#line 101
  b = (b << 30) | (b >> 2);
#line 102
  tmp___75 = ((((block->l[9] ^ block->l[4]) ^ block->l[14]) ^ block->l[12]) << 1) | ((((block->l[9] ^ block->l[4]) ^ block->l[14]) ^ block->l[12]) >> 31);
#line 102
  block->l[12] = tmp___75;
#line 102
  d += ((((a ^ b) ^ c) + tmp___75) + 3395469782U) + ((e << 5) | (e >> 27));
#line 102
  a = (a << 30) | (a >> 2);
#line 102
  tmp___76 = ((((block->l[10] ^ block->l[5]) ^ block->l[15]) ^ block->l[13]) << 1) | ((((block->l[10] ^ block->l[5]) ^ block->l[15]) ^ block->l[13]) >> 31);
#line 102
  block->l[13] = tmp___76;
#line 102
  c += ((((e ^ a) ^ b) + tmp___76) + 3395469782U) + ((d << 5) | (d >> 27));
#line 102
  e = (e << 30) | (e >> 2);
#line 102
  tmp___77 = ((((block->l[11] ^ block->l[6]) ^ block->l[0]) ^ block->l[14]) << 1) | ((((block->l[11] ^ block->l[6]) ^ block->l[0]) ^ block->l[14]) >> 31);
#line 102
  block->l[14] = tmp___77;
#line 102
  b += ((((d ^ e) ^ a) + tmp___77) + 3395469782U) + ((c << 5) | (c >> 27));
#line 102
  d = (d << 30) | (d >> 2);
#line 102
  tmp___78 = ((((block->l[12] ^ block->l[7]) ^ block->l[1]) ^ block->l[15]) << 1) | ((((block->l[12] ^ block->l[7]) ^ block->l[1]) ^ block->l[15]) >> 31);
#line 102
  block->l[15] = tmp___78;
#line 102
  a += ((((c ^ d) ^ e) + tmp___78) + 3395469782U) + ((b << 5) | (b >> 27));
#line 102
  c = (c << 30) | (c >> 2);
#line 104
  *(state + 0) += a;
#line 105
  *(state + 1) += b;
#line 106
  *(state + 2) += c;
#line 107
  *(state + 3) += d;
#line 108
  *(state + 4) += e;
#line 110
  e = (uint32_t )0;
#line 110
  d = e;
#line 110
  c = d;
#line 110
  b = c;
#line 110
  a = b;
  }
#line 111
  return;
}
}
#line 116 "/home/june/repo/benchmarks/collector/temp/ike-scan-1.9/sha1.c"
void SHA1Init(SHA1_CTX *context ) 
{ 
  uint32_t tmp ;

  {
#line 119
  context->state[0] = (uint32_t )1732584193;
#line 120
  context->state[1] = 4023233417U;
#line 121
  context->state[2] = 2562383102U;
#line 122
  context->state[3] = (uint32_t )271733878;
#line 123
  context->state[4] = 3285377520U;
#line 124
  tmp = (uint32_t )0;
#line 124
  context->count[1] = tmp;
#line 124
  context->count[0] = tmp;
#line 125
  return;
}
}
#line 130 "/home/june/repo/benchmarks/collector/temp/ike-scan-1.9/sha1.c"
void SHA1Update(SHA1_CTX *context , unsigned char *data , unsigned int len ) 
{ 
  unsigned int i ;
  unsigned int j ;
  uint32_t tmp ;

  {
#line 134
  j = (context->count[0] >> 3) & 63U;
#line 135
  tmp = context->count[0] + (len << 3);
#line 135
  context->count[0] = tmp;
#line 135
  if (tmp < len << 3) {
#line 135
    (context->count[1]) ++;
  }
#line 136
  context->count[1] += len >> 29;
#line 137
  if (j + len > 63U) {
    {
#line 138
    i = 64U - j;
#line 138
    memcpy((void */* __restrict  */)(& context->buffer[j]), (void const   */* __restrict  */)data,
           (size_t )i);
#line 139
    SHA1Transform((uint32_t *)(context->state), (unsigned char *)(context->buffer));
    }
    {
#line 140
    while (1) {
      while_continue: /* CIL Label */ ;
#line 140
      if (! (i + 63U < len)) {
#line 140
        goto while_break;
      }
      {
#line 141
      SHA1Transform((uint32_t *)(context->state), (unsigned char *)(data + i));
#line 140
      i += 64U;
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 143
    j = 0U;
  } else {
#line 145
    i = 0U;
  }
  {
#line 146
  memcpy((void */* __restrict  */)(& context->buffer[j]), (void const   */* __restrict  */)(data + i),
         (size_t )(len - i));
  }
#line 147
  return;
}
}
#line 152 "/home/june/repo/benchmarks/collector/temp/ike-scan-1.9/sha1.c"
void SHA1Final(unsigned char *digest , SHA1_CTX *context ) 
{ 
  unsigned int i ;
  unsigned char finalcount[8] ;
  int tmp ;

  {
#line 157
  i = 0U;
  {
#line 157
  while (1) {
    while_continue: /* CIL Label */ ;
#line 157
    if (! (i < 8U)) {
#line 157
      goto while_break;
    }
#line 158
    if (i >= 4U) {
#line 158
      tmp = 0;
    } else {
#line 158
      tmp = 1;
    }
#line 158
    finalcount[i] = (unsigned char )((context->count[tmp] >> (3U - (i & 3U)) * 8U) & 255U);
#line 157
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 161
  SHA1Update(context, (unsigned char *)"\200", 1U);
  }
  {
#line 162
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 162
    if (! ((context->count[0] & 504U) != 448U)) {
#line 162
      goto while_break___0;
    }
    {
#line 163
    SHA1Update(context, (unsigned char *)"\000", 1U);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 165
  SHA1Update(context, finalcount, 8U);
#line 166
  i = 0U;
  }
  {
#line 166
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 166
    if (! (i < 20U)) {
#line 166
      goto while_break___1;
    }
#line 167
    *(digest + i) = (unsigned char )((context->state[i >> 2] >> (3U - (i & 3U)) * 8U) & 255U);
#line 166
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 171
  i = 0U;
#line 172
  memset((void *)(context->buffer), 0, (size_t )64);
#line 173
  memset((void *)(context->state), 0, (size_t )20);
#line 174
  memset((void *)(context->count), 0, (size_t )8);
#line 175
  memset((void *)(& finalcount), 0, (size_t )8);
#line 177
  SHA1Transform((uint32_t *)(context->state), (unsigned char *)(context->buffer));
  }
#line 179
  return;
}
}
#line 169 "/usr/include/stdio.h"
extern struct _IO_FILE *stdout ;
#line 170
extern struct _IO_FILE *stderr ;
#line 272
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 362
extern int printf(char const   * __restrict  __format  , ...) ;
#line 483 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 374 "/usr/include/netinet/in.h"
extern  __attribute__((__nothrow__)) uint32_t ( __attribute__((__leaf__)) ntohl)(uint32_t __netlong )  __attribute__((__const__)) ;
#line 375
extern  __attribute__((__nothrow__)) uint16_t ( __attribute__((__leaf__)) ntohs)(uint16_t __netshort )  __attribute__((__const__)) ;
#line 377
extern  __attribute__((__nothrow__)) uint32_t ( __attribute__((__leaf__)) htonl)(uint32_t __hostlong )  __attribute__((__const__)) ;
#line 379
extern  __attribute__((__nothrow__)) uint16_t ( __attribute__((__leaf__)) htons)(uint16_t __hostshort )  __attribute__((__const__)) ;
#line 53 "/usr/include/arpa/inet.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) inet_ntoa)(struct in_addr __in ) ;
#line 577 "/usr/include/regex.h"
extern int regexec(regex_t const   * __restrict  __preg , char const   * __restrict  __string ,
                   size_t __nmatch , regmatch_t * __restrict  __pmatch , int __eflags ) ;
#line 334 "/home/june/repo/benchmarks/collector/temp/ike-scan-1.9/ike-scan.h"
void err_sys(char const   *fmt  , ...) ;
#line 336
void err_msg(char const   *fmt  , ...) ;
#line 337
void warn_msg(char const   *fmt  , ...) ;
#line 373
unsigned char *make_isakmp_hdr(unsigned int xchg , unsigned int next , unsigned int length ,
                               int header_version , int hdr_flags , unsigned int hdr_msgid ,
                               unsigned char *rcookie_data , size_t rcookie_data_len ) ;
#line 375
unsigned char *make_sa(size_t *outlen , unsigned int next , unsigned int doi , unsigned int situation ,
                       unsigned char *proposals , size_t proposal_len ) ;
#line 377
unsigned char *make_sa2(size_t *outlen , unsigned int next , unsigned char *proposals ,
                        size_t proposal_len ) ;
#line 378
unsigned char *make_prop(size_t *outlen , unsigned int next , unsigned int number ,
                         unsigned int notrans , unsigned int protocol , unsigned int spi_size ,
                         unsigned char *transforms , size_t transform_len ) ;
#line 380
unsigned char *add_prop(int finished , size_t *outlen , unsigned int notrans , unsigned int protocol ,
                        unsigned int spi_size , unsigned char *transforms , size_t transform_len ) ;
#line 382
unsigned char *make_trans_simple(size_t *length , unsigned int next , unsigned int number ,
                                 unsigned int cipher , unsigned int keylen , unsigned int hash ,
                                 unsigned int auth , unsigned int group , unsigned char *lifetime_data ,
                                 size_t lifetime_data_len , unsigned char *lifesize_data ,
                                 size_t lifesize_data_len , int gss_id_flag , unsigned char *gss_data ,
                                 size_t gss_data_len , unsigned int trans_id ) ;
#line 387
unsigned char *add_trans_simple(int finished , size_t *length , unsigned int cipher ,
                                unsigned int keylen , unsigned int hash , unsigned int auth ,
                                unsigned int group , unsigned char *lifetime_data ,
                                size_t lifetime_data_len , unsigned char *lifesize_data ,
                                size_t lifesize_data_len , int gss_id_flag , unsigned char *gss_data ,
                                size_t gss_data_len , unsigned int trans_id ) ;
#line 391
unsigned char *make_attr(size_t *outlen , int type , unsigned int class , size_t length ,
                         unsigned int b_value , void *v_value ) ;
#line 392
unsigned char *add_attr(int finished , size_t *outlen , int type , unsigned int class ,
                        size_t length , unsigned int b_value , void *v_value ) ;
#line 394
unsigned char *make_vid(size_t *length , unsigned int next , unsigned char *vid_data ,
                        size_t vid_data_len ) ;
#line 395
unsigned char *add_vid(int finished , size_t *length , unsigned char *vid_data , size_t vid_data_len ,
                       unsigned int next ) ;
#line 396
unsigned char *make_ke(size_t *length , unsigned int next , size_t kx_data_len ) ;
#line 397
unsigned char *make_ke2(size_t *length , unsigned int next , unsigned int dh_group ,
                        size_t kx_data_len ) ;
#line 398
unsigned char *make_nonce(size_t *length , unsigned int next , size_t nonce_len ) ;
#line 399
unsigned char *make_id(size_t *length , unsigned int next , unsigned int idtype ,
                       unsigned char *id_data , size_t id_data_len ) ;
#line 400
unsigned char *make_cr(size_t *length , unsigned int next , unsigned char *cr_data ,
                       size_t cr_data_len ) ;
#line 401
unsigned char *make_udphdr(size_t *length , unsigned int sport , unsigned int dport ,
                           unsigned int udplen ) ;
#line 403
void *Malloc(size_t size ) ;
#line 404
void *Realloc(void *ptr , size_t size ) ;
#line 409
unsigned char *skip_payload(unsigned char *cp , size_t *len , unsigned int *next ) ;
#line 410
unsigned char *process_isakmp_hdr(unsigned char *cp , size_t *len , unsigned int *next ,
                                  unsigned int *type , char **hdr_descr ) ;
#line 412
char *process_sa(unsigned char *cp , size_t len , unsigned int type , int quiet ,
                 int multiline , char *hdr_descr ) ;
#line 413
char *process_sa2(unsigned char *cp , size_t len , unsigned int type , int quiet ,
                  int multiline , char *hdr_descr ) ;
#line 414
char *process_attr(unsigned char **cp , size_t *len ) ;
#line 415
char *process_transform2(unsigned char **cp , size_t *len ) ;
#line 416
char *process_vid(unsigned char *cp , size_t len , vid_pattern_list *vidlist___0 ) ;
#line 417
char *process_notify(unsigned char *cp , size_t len , int quiet , int multiline ,
                     char *hdr_descr ) ;
#line 418
char *process_notify2(unsigned char *cp , size_t len , int quiet , int multiline ,
                      char *hdr_descr ) ;
#line 419
char *process_id(unsigned char *cp , size_t len ) ;
#line 420
char *process_cert(unsigned char *cp , size_t len , unsigned int next ) ;
#line 421
char *process_delete(unsigned char *cp , size_t len ) ;
#line 422
char *process_notification(unsigned char *cp , size_t len ) ;
#line 423
char *process_generic(unsigned char *cp , size_t len , unsigned int next ) ;
#line 424
unsigned char *make_transform(size_t *length , unsigned int next , unsigned int number ,
                              unsigned int trans_id , unsigned char *attr , size_t attr_len ) ;
#line 426
unsigned char *add_transform(int finished , size_t *length , unsigned int trans_id ,
                             unsigned char *attr , size_t attr_len ) ;
#line 427
unsigned char *make_transform2(size_t *length , unsigned int next , unsigned int trans_type ,
                               unsigned int trans_id , unsigned char *attr , size_t attr_len ) ;
#line 429
unsigned char *add_transform2(int finished , size_t *length , unsigned int trans_type ,
                              unsigned int trans_id , unsigned char *attr , size_t attr_len ) ;
#line 431
unsigned char *add_isakmp_payload(unsigned char *payload , size_t payload_len , unsigned char **new_payload ) ;
#line 432
void print_payload(unsigned char *cp , unsigned int payload , int dir ) ;
#line 433
void add_psk_crack_payload(unsigned char *cp , unsigned int payload , int dir ) ;
#line 434
void print_psk_crack_values(char const   *psk_crack_file ) ;
#line 435
unsigned char *clone_payload(unsigned char const   *pkt_ptr , size_t bytes_left ) ;
#line 436
char *make_message(char const   *fmt  , ...) ;
#line 438
char *printable(unsigned char const   *string , size_t size ) ;
#line 439
char *hexstring(unsigned char const   *data , size_t size ) ;
#line 442
char const   *id_to_name(unsigned int id , id_name_map const   *map ) ;
#line 445
uint8_t random_byte(void) ;
#line 460
void isakmp_use_rcsid(void) ;
#line 47 "/home/june/repo/benchmarks/collector/temp/ike-scan-1.9/isakmp.c"
static char rcsid[46]  = 
#line 47 "/home/june/repo/benchmarks/collector/temp/ike-scan-1.9/isakmp.c"
  {      (char )'$',      (char )'I',      (char )'d',      (char )':', 
        (char )' ',      (char )'i',      (char )'s',      (char )'a', 
        (char )'k',      (char )'m',      (char )'p',      (char )'.', 
        (char )'c',      (char )' ',      (char )'9',      (char )'8', 
        (char )'8',      (char )'4',      (char )' ',      (char )'2', 
        (char )'0',      (char )'0',      (char )'7',      (char )'-', 
        (char )'0',      (char )'1',      (char )'-',      (char )'1', 
        (char )'4',      (char )' ',      (char )'1',      (char )'9', 
        (char )':',      (char )'0',      (char )'5',      (char )':', 
        (char )'3',      (char )'9',      (char )'Z',      (char )' ', 
        (char )'r',      (char )'s',      (char )'h',      (char )' ', 
        (char )'$',      (char )'\000'};
#line 49 "/home/june/repo/benchmarks/collector/temp/ike-scan-1.9/isakmp.c"
id_name_map const   notification_map[37]  = 
#line 49
  {      {0, "UNSPECIFIED"}, 
        {1, "INVALID-PAYLOAD-TYPE"}, 
        {2, "DOI-NOT-SUPPORTED"}, 
        {3, "SITUATION-NOT-SUPPORTED"}, 
        {4, "INVALID-COOKIE"}, 
        {5, "INVALID-MAJOR-VERSION"}, 
        {6, "INVALID-MINOR-VERSION"}, 
        {7, "INVALID-EXCHANGE-TYPE"}, 
        {8, "INVALID-FLAGS"}, 
        {9, "INVALID-MESSAGE-ID"}, 
        {10, "INVALID-PROTOCOL-ID"}, 
        {11, "INVALID-SPI"}, 
        {12, "INVALID-TRANSFORM-ID"}, 
        {13, "ATTRIBUTES-NOT-SUPPORTED"}, 
        {14, "NO-PROPOSAL-CHOSEN"}, 
        {15, "BAD-PROPOSAL-SYNTAX"}, 
        {16, "PAYLOAD-MALFORMED"}, 
        {17, "INVALID-KEY-INFORMATION"}, 
        {18, "INVALID-ID-INFORMATION"}, 
        {19, "INVALID-CERT-ENCODING"}, 
        {20, "INVALID-CERTIFICATE"}, 
        {21, "CERT-TYPE-UNSUPPORTED"}, 
        {22, "INVALID-CERT-AUTHORITY"}, 
        {23, "INVALID-HASH-INFORMATION"}, 
        {24, "AUTHENTICATION-FAILED"}, 
        {25, "INVALID-SIGNATURE"}, 
        {26, "ADDRESS-NOTIFICATION"}, 
        {27, "NOTIFY-SA-LIFETIME"}, 
        {28, "CERTIFICATE-UNAVAILABLE"}, 
        {29, "UNSUPPORTED-EXCHANGE-TYPE"}, 
        {30, "UNEQUAL-PAYLOAD-LENGTHS"}, 
        {9101, "Checkpoint-Firewall-1"}, 
        {9110, "Checkpoint-Firewall-1"}, 
        {24576, "RESPONDER-LIFETIME"}, 
        {24577, "REPLAY-STATUS"}, 
        {24578, "INITIAL-CONTACT"}, 
        {-1, (char const   *)((void *)0)}};
#line 88 "/home/june/repo/benchmarks/collector/temp/ike-scan-1.9/isakmp.c"
id_name_map const   notification_map2[31]  = 
#line 88
  {      {0, "RESERVED"}, 
        {1, "UNSUPPORTED_CRITICAL_PAYLOAD"}, 
        {4, "INVALID_IKE_SPI"}, 
        {5, "INVALID_MAJOR_VERSION"}, 
        {7, "INVALID_SYNTAX"}, 
        {9, "INVALID_MESSAGE_ID"}, 
        {11, "INVALID_SPI"}, 
        {14, "NO_PROPOSAL_CHOSEN"}, 
        {17, "INVALID_KE_PAYLOAD"}, 
        {24, "AUTHENTICATION_FAILED"}, 
        {34, "SINGLE_PAIR_REQUIRED"}, 
        {35, "NO_ADDITIONAL_SAS"}, 
        {36, "INTERNAL_ADDRESS_FAILURE"}, 
        {37, "FAILED_CP_REQUIRED"}, 
        {38, "TS_UNACCEPTABLE"}, 
        {39, "INVALID_SELECTORS"}, 
        {9101, "Checkpoint-Firewall-1"}, 
        {9110, "Checkpoint-Firewall-1"}, 
        {16384, "INITIAL_CONTACT"}, 
        {16385, "SET_WINDOW_SIZE"}, 
        {16386, "ADDITIONAL_TS_POSSIBLE"}, 
        {16387, "IPCOMP_SUPPORTED"}, 
        {16388, "NAT_DETECTION_SOURCE_IP"}, 
        {16389, "NAT_DETECTION_DESTINATION_IP"}, 
        {16390, "COOKIE"}, 
        {16391, "USE_TRANSPORT_MODE"}, 
        {16392, "HTTP_CERT_LOOKUP_SUPPORTED"}, 
        {16393, "REKEY_SA"}, 
        {16394, "ESP_TFC_PADDING_NOT_SUPPORTED"}, 
        {16395, "NON_FIRST_FRAGMENTS_ALSO"}, 
        {-1, (char const   *)((void *)0)}};
#line 121 "/home/june/repo/benchmarks/collector/temp/ike-scan-1.9/isakmp.c"
id_name_map const   attr_map[18]  = 
#line 121
  {      {1, "Enc"}, 
        {2, "Hash"}, 
        {3, "Auth"}, 
        {4, "Group"}, 
        {5, "GroupType"}, 
        {6, "GroupPrime/IrreduciblePolynomial"}, 
        {7, "GroupGeneratorOne"}, 
        {8, "GroupGeneratorTwo"}, 
        {9, "GroupCurve A"}, 
        {10, "GroupCurve B"}, 
        {11, "LifeType"}, 
        {12, "LifeDuration"}, 
        {13, "PRF"}, 
        {14, "KeyLength"}, 
        {15, "FieldSize"}, 
        {16, "GroupOrder"}, 
        {16384, "GSSIdentityName"}, 
        {-1, (char const   *)((void *)0)}};
#line 141 "/home/june/repo/benchmarks/collector/temp/ike-scan-1.9/isakmp.c"
id_name_map const   trans_type_map[6]  = {      {1, "Encr"}, 
        {2, "Prf"}, 
        {3, "Integ"}, 
        {4, "DH_Group"}, 
        {5, "ESN"}, 
        {-1, (char const   *)((void *)0)}};
#line 149 "/home/june/repo/benchmarks/collector/temp/ike-scan-1.9/isakmp.c"
id_name_map const   enc_map[14]  = 
#line 149
  {      {1, "DES"}, 
        {2, "IDEA"}, 
        {3, "Blowfish"}, 
        {4, "RC5"}, 
        {5, "3DES"}, 
        {6, "CAST"}, 
        {7, "AES"}, 
        {8, "Camellia"}, 
        {65001, "Mars"}, 
        {65002, "RC6"}, 
        {65003, "ID_65003"}, 
        {65004, "Serpent"}, 
        {65005, "Twofish"}, 
        {-1, (char const   *)((void *)0)}};
#line 165 "/home/june/repo/benchmarks/collector/temp/ike-scan-1.9/isakmp.c"
id_name_map const   encr_map[13]  = 
#line 165
  {      {1, "DES_IV64"}, 
        {2, "DES"}, 
        {3, "3DES"}, 
        {4, "RC5"}, 
        {5, "IDEA"}, 
        {6, "CAST"}, 
        {7, "Blowfish"}, 
        {8, "3IDEA"}, 
        {9, "DES_IV32"}, 
        {11, "NULL"}, 
        {12, "AES_CBC"}, 
        {13, "AES_CTR"}, 
        {-1, (char const   *)((void *)0)}};
#line 180 "/home/june/repo/benchmarks/collector/temp/ike-scan-1.9/isakmp.c"
id_name_map const   hash_map[7]  = {      {1, "MD5"}, 
        {2, "SHA1"}, 
        {3, "Tiger"}, 
        {4, "SHA2-256"}, 
        {5, "SHA2-384"}, 
        {6, "SHA2-512"}, 
        {-1, (char const   *)((void *)0)}};
#line 189 "/home/june/repo/benchmarks/collector/temp/ike-scan-1.9/isakmp.c"
id_name_map const   prf_map[5]  = {      {1, "HMAC_MD5"}, 
        {2, "HMAC_SHA1"}, 
        {3, "HMAC_TIGER"}, 
        {4, "AES128_XCBC"}, 
        {-1, (char const   *)((void *)0)}};
#line 196 "/home/june/repo/benchmarks/collector/temp/ike-scan-1.9/isakmp.c"
id_name_map const   auth_map[12]  = 
#line 196
  {      {1, "PSK"}, 
        {2, "DSS"}, 
        {3, "RSA_Sig"}, 
        {4, "RSA_Enc"}, 
        {5, "RSA_RevEnc"}, 
        {6, "ElGamel_Enc"}, 
        {7, "ElGamel_RevEnc"}, 
        {8, "ECDSA_Sig"}, 
        {128, "CRACK"}, 
        {64221, "Hybrid"}, 
        {65001, "XAUTH"}, 
        {-1, (char const   *)((void *)0)}};
#line 210 "/home/june/repo/benchmarks/collector/temp/ike-scan-1.9/isakmp.c"
id_name_map const   integ_map[6]  = {      {1, "HMAC_MD5_96"}, 
        {2, "HMAC_SHA1_96"}, 
        {3, "DES_MAC"}, 
        {4, "KPDK_MD5"}, 
        {5, "AES_XCBC_96"}, 
        {-1, (char const   *)((void *)0)}};
#line 218 "/home/june/repo/benchmarks/collector/temp/ike-scan-1.9/isakmp.c"
id_name_map const   dh_map[19]  = 
#line 218
  {      {1, "1:modp768"}, 
        {2, "2:modp1024"}, 
        {3, "3:ec2n155"}, 
        {4, "4:ec2n185"}, 
        {5, "5:modp1536"}, 
        {6, "6:ec2n163"}, 
        {7, "7:ec2n163"}, 
        {8, "8:ec2n283"}, 
        {9, "9:ec2n283"}, 
        {10, "10:ec2n409"}, 
        {11, "11:ec2n409"}, 
        {12, "12:ec2n571"}, 
        {13, "13:ec2n571"}, 
        {14, "14:modp2048"}, 
        {15, "15:modp3072"}, 
        {16, "16:modp4096"}, 
        {17, "17:modp6144"}, 
        {18, "18:modp8192"}, 
        {-1, (char const   *)((void *)0)}};
#line 239 "/home/june/repo/benchmarks/collector/temp/ike-scan-1.9/isakmp.c"
id_name_map const   life_map[3]  = {      {1, "Seconds"}, 
        {2, "Kilobytes"}, 
        {-1, (char const   *)((void *)0)}};
#line 244 "/home/june/repo/benchmarks/collector/temp/ike-scan-1.9/isakmp.c"
id_name_map const   payload_map[31]  = 
#line 244
  {      {1, "SecurityAssociation"}, 
        {2, "Proposal"}, 
        {3, "Transform"}, 
        {4, "KeyExchange"}, 
        {5, "Identification"}, 
        {6, "Certificate"}, 
        {7, "CertificateRequest"}, 
        {8, "Hash"}, 
        {9, "Signature"}, 
        {10, "Nonce"}, 
        {11, "Notification"}, 
        {12, "Delete"}, 
        {13, "VendorID"}, 
        {20, "NAT-D"}, 
        {33, "SecurityAssociation"}, 
        {34, "KeyExchange"}, 
        {35, "IDI"}, 
        {36, "IDR"}, 
        {37, "Certificate"}, 
        {38, "CertificateRequest"}, 
        {39, "AUTH"}, 
        {40, "Nonce"}, 
        {41, "Notification"}, 
        {42, "Delete"}, 
        {43, "VendorID"}, 
        {44, "TSI"}, 
        {45, "TSR"}, 
        {46, "Encrypted"}, 
        {47, "Configuration"}, 
        {48, "EAP"}, 
        {-1, (char const   *)((void *)0)}};
#line 277 "/home/june/repo/benchmarks/collector/temp/ike-scan-1.9/isakmp.c"
id_name_map const   doi_map[3]  = {      {0, "ISAKMP"}, 
        {1, "IPsec"}, 
        {-1, (char const   *)((void *)0)}};
#line 282 "/home/june/repo/benchmarks/collector/temp/ike-scan-1.9/isakmp.c"
id_name_map const   protocol_map[5]  = {      {1, "PROTO_ISAKMP"}, 
        {2, "PROTO_IPSEC_AH"}, 
        {3, "PROTO_IPSEC_ESP"}, 
        {4, "PROTO_IPSEC_COMP"}, 
        {-1, (char const   *)((void *)0)}};
#line 289 "/home/june/repo/benchmarks/collector/temp/ike-scan-1.9/isakmp.c"
id_name_map const   id_map[11]  = 
#line 289
  {      {1, "ID_IPV4_ADDR"}, 
        {2, "ID_FQDN"}, 
        {3, "ID_USER_FQDN"}, 
        {4, "ID_IPV4_ADDR_SUBNET"}, 
        {5, "ID_IPV6_ADDR"}, 
        {6, "ID_IPV6_ADDR_SUBNET"}, 
        {7, "ID_IPV4_ADDR_RANGE"}, 
        {8, "ID_IPV6_ADDR_RANGE"}, 
        {9, "ID_DER_ASN1_DN"}, 
        {10, "ID_DER_ASN1_GN"}, 
        {11, "ID_KEY_ID"}};
#line 302 "/home/june/repo/benchmarks/collector/temp/ike-scan-1.9/isakmp.c"
id_name_map const   cert_map[11]  = 
#line 302
  {      {1, "PKCS #7 wrapped X.509 certificate"}, 
        {2, "PGP Certificate"}, 
        {3, "DNS Signed Key"}, 
        {4, "X.509 Certificate - Signature"}, 
        {5, "X.509 Certificate - Key Exchange"}, 
        {6, "Kerberos Tokens"}, 
        {7, "Certificate Revocation List (CRL)"}, 
        {8, "Authority Revocation List (ARL)"}, 
        {9, "SPKI Certificate"}, 
        {10, "X.509 Certificate - Attribute"}, 
        {-1, (char const   *)((void *)0)}};
#line 316
psk_crack psk_values ;
#line 317
int mbz_value ;
#line 341 "/home/june/repo/benchmarks/collector/temp/ike-scan-1.9/isakmp.c"
unsigned char *make_isakmp_hdr(unsigned int xchg , unsigned int next , unsigned int length ,
                               int header_version , int hdr_flags , unsigned int hdr_msgid ,
                               unsigned char *rcookie_data , size_t rcookie_data_len ) 
{ 
  unsigned char *payload ;
  struct isakmp_hdr *hdr ;
  void *tmp ;

  {
  {
#line 348
  tmp = Malloc(sizeof(struct isakmp_hdr ));
#line 348
  payload = (unsigned char *)tmp;
#line 349
  hdr = (struct isakmp_hdr *)payload;
#line 350
  memset((void *)hdr, mbz_value, sizeof(struct isakmp_hdr ));
#line 352
  hdr->isa_icookie[0] = 3735928559U;
#line 353
  hdr->isa_icookie[1] = 3735928559U;
#line 354
  hdr->isa_rcookie[0] = (uint32_t )0;
#line 355
  hdr->isa_rcookie[1] = (uint32_t )0;
  }
#line 356
  if (rcookie_data) {
    {
#line 357
    memcpy((void */* __restrict  */)(hdr->isa_rcookie), (void const   */* __restrict  */)rcookie_data,
           rcookie_data_len);
    }
  }
  {
#line 359
  hdr->isa_np = (uint8_t )next;
#line 360
  hdr->isa_version = (uint8_t )header_version;
#line 361
  hdr->isa_xchg = (uint8_t )xchg;
#line 362
  hdr->isa_flags = (uint8_t )hdr_flags;
#line 363
  hdr->isa_msgid = htonl(hdr_msgid);
#line 364
  hdr->isa_length = htonl(length);
  }
#line 366
  return (payload);
}
}
#line 387 "/home/june/repo/benchmarks/collector/temp/ike-scan-1.9/isakmp.c"
unsigned char *make_sa(size_t *outlen , unsigned int next , unsigned int doi , unsigned int situation ,
                       unsigned char *proposals , size_t proposal_len ) 
{ 
  unsigned char *payload ;
  struct isakmp_sa *hdr ;
  unsigned char *cp ;
  size_t len ;
  void *tmp ;
  void *tmp___0 ;

  {
  {
#line 395
  tmp = Malloc(sizeof(struct isakmp_sa ));
#line 395
  hdr = (struct isakmp_sa *)tmp;
#line 396
  memset((void *)hdr, mbz_value, sizeof(struct isakmp_sa ));
#line 398
  hdr->isasa_np = (uint8_t )next;
#line 399
  hdr->isasa_doi = htonl(doi);
#line 400
  hdr->isasa_situation = htonl(situation);
#line 402
  len = sizeof(struct isakmp_sa ) + proposal_len;
#line 403
  hdr->isasa_length = htons((uint16_t )len);
#line 404
  tmp___0 = Malloc(len);
#line 404
  payload = (unsigned char *)tmp___0;
#line 405
  cp = payload;
#line 407
  memcpy((void */* __restrict  */)cp, (void const   */* __restrict  */)hdr, sizeof(struct isakmp_sa ));
#line 408
  cp += sizeof(struct isakmp_sa );
#line 409
  memcpy((void */* __restrict  */)cp, (void const   */* __restrict  */)proposals,
         proposal_len);
#line 411
  *outlen = len;
  }
#line 412
  return (payload);
}
}
#line 431 "/home/june/repo/benchmarks/collector/temp/ike-scan-1.9/isakmp.c"
unsigned char *make_sa2(size_t *outlen , unsigned int next , unsigned char *proposals ,
                        size_t proposal_len ) 
{ 
  unsigned char *payload ;
  struct isakmp_sa2 *hdr ;
  unsigned char *cp ;
  size_t len ;
  void *tmp ;
  void *tmp___0 ;

  {
  {
#line 439
  tmp = Malloc(sizeof(struct isakmp_sa2 ));
#line 439
  hdr = (struct isakmp_sa2 *)tmp;
#line 440
  memset((void *)hdr, mbz_value, sizeof(struct isakmp_sa2 ));
#line 442
  hdr->isasa2_np = (uint8_t )next;
#line 444
  len = sizeof(struct isakmp_sa2 ) + proposal_len;
#line 445
  hdr->isasa2_length = htons((uint16_t )len);
#line 446
  tmp___0 = Malloc(len);
#line 446
  payload = (unsigned char *)tmp___0;
#line 447
  cp = payload;
#line 449
  memcpy((void */* __restrict  */)cp, (void const   */* __restrict  */)hdr, sizeof(struct isakmp_sa2 ));
#line 450
  cp += sizeof(struct isakmp_sa2 );
#line 451
  memcpy((void */* __restrict  */)cp, (void const   */* __restrict  */)proposals,
         proposal_len);
#line 453
  *outlen = len;
  }
#line 454
  return (payload);
}
}
#line 494 "/home/june/repo/benchmarks/collector/temp/ike-scan-1.9/isakmp.c"
static int first_proposal  =    1;
#line 495 "/home/june/repo/benchmarks/collector/temp/ike-scan-1.9/isakmp.c"
static unsigned char *prop_start  =    (unsigned char *)((void *)0);
#line 496 "/home/june/repo/benchmarks/collector/temp/ike-scan-1.9/isakmp.c"
static size_t cur_offset  ;
#line 497 "/home/june/repo/benchmarks/collector/temp/ike-scan-1.9/isakmp.c"
static size_t end_offset  ;
#line 498 "/home/june/repo/benchmarks/collector/temp/ike-scan-1.9/isakmp.c"
static unsigned int prop_no  =    1U;
#line 489 "/home/june/repo/benchmarks/collector/temp/ike-scan-1.9/isakmp.c"
unsigned char *add_prop(int finished , size_t *outlen , unsigned int notrans , unsigned int protocol ,
                        unsigned int spi_size , unsigned char *transforms , size_t transform_len ) 
{ 
  unsigned char *prop ;
  size_t len ;
  void *tmp ;
  void *tmp___0 ;
  struct isakmp_proposal *hdr ;

  {
#line 506
  if (! finished) {
    {
#line 507
    prop = make_prop(& len, 2U, prop_no, notrans, protocol, spi_size, transforms,
                     transform_len);
#line 509
    prop_no ++;
    }
#line 510
    if (first_proposal) {
      {
#line 511
      cur_offset = (size_t )0;
#line 512
      end_offset = len;
#line 513
      tmp = Malloc(end_offset);
#line 513
      prop_start = (unsigned char *)tmp;
#line 514
      memcpy((void */* __restrict  */)prop_start, (void const   */* __restrict  */)prop,
             len);
#line 515
      first_proposal = 0;
      }
    } else {
      {
#line 517
      cur_offset = end_offset;
#line 518
      end_offset += len;
#line 519
      tmp___0 = Realloc((void *)prop_start, end_offset);
#line 519
      prop_start = (unsigned char *)tmp___0;
#line 520
      memcpy((void */* __restrict  */)(prop_start + cur_offset), (void const   */* __restrict  */)prop,
             len);
      }
    }
    {
#line 522
    free((void *)prop);
    }
#line 523
    return ((unsigned char *)((void *)0));
  } else {
#line 525
    hdr = (struct isakmp_proposal *)(prop_start + cur_offset);
#line 528
    first_proposal = 1;
#line 529
    hdr->isap_np = (uint8_t )0;
#line 530
    *outlen = end_offset;
#line 531
    return (prop_start);
  }
}
}
#line 555 "/home/june/repo/benchmarks/collector/temp/ike-scan-1.9/isakmp.c"
unsigned char *make_prop(size_t *outlen , unsigned int next , unsigned int number ,
                         unsigned int notrans , unsigned int protocol , unsigned int spi_size ,
                         unsigned char *transforms , size_t transform_len ) 
{ 
  unsigned char *payload ;
  struct isakmp_proposal *hdr ;
  unsigned char *cp ;
  size_t len ;
  void *tmp ;
  void *tmp___0 ;
  int i ;
  unsigned char *tmp___1 ;
  uint8_t tmp___2 ;

  {
  {
#line 566
  tmp = Malloc(sizeof(struct isakmp_proposal ));
#line 566
  hdr = (struct isakmp_proposal *)tmp;
#line 567
  memset((void *)hdr, mbz_value, sizeof(struct isakmp_proposal ));
#line 569
  hdr->isap_np = (uint8_t )next;
#line 570
  hdr->isap_proposal = (uint8_t )number;
#line 571
  hdr->isap_protoid = (uint8_t )protocol;
#line 572
  hdr->isap_spisize = (uint8_t )spi_size;
#line 573
  hdr->isap_notrans = (uint8_t )notrans;
#line 577
  len = (sizeof(struct isakmp_proposal ) + (unsigned long )spi_size) + transform_len;
#line 578
  hdr->isap_length = htons((uint16_t )len);
#line 579
  tmp___0 = Malloc(len);
#line 579
  payload = (unsigned char *)tmp___0;
#line 580
  cp = payload;
#line 584
  memcpy((void */* __restrict  */)cp, (void const   */* __restrict  */)hdr, sizeof(struct isakmp_proposal ));
#line 585
  cp += sizeof(struct isakmp_proposal );
#line 586
  free((void *)hdr);
  }
#line 590
  if (spi_size > 0U) {
#line 593
    i = 0;
    {
#line 593
    while (1) {
      while_continue: /* CIL Label */ ;
#line 593
      if (! ((unsigned int )i < spi_size)) {
#line 593
        goto while_break;
      }
      {
#line 594
      tmp___1 = cp;
#line 594
      cp ++;
#line 594
      tmp___2 = random_byte();
#line 594
      *tmp___1 = tmp___2;
#line 593
      i ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 599
  memcpy((void */* __restrict  */)cp, (void const   */* __restrict  */)transforms,
         transform_len);
#line 601
  *outlen = len;
  }
#line 602
  return (payload);
}
}
#line 633 "/home/june/repo/benchmarks/collector/temp/ike-scan-1.9/isakmp.c"
unsigned char *make_trans_simple(size_t *length , unsigned int next , unsigned int number ,
                                 unsigned int cipher , unsigned int keylen , unsigned int hash ,
                                 unsigned int auth , unsigned int group , unsigned char *lifetime_data ,
                                 size_t lifetime_data_len , unsigned char *lifesize_data ,
                                 size_t lifesize_data_len , int gss_id_flag , unsigned char *gss_data ,
                                 size_t gss_data_len , unsigned int trans_id ) 
{ 
  unsigned char *payload ;
  unsigned char *attr ;
  size_t attr_len ;

  {
  {
#line 647
  add_attr(0, (size_t *)((void *)0), 'B', 1U, (size_t )0, cipher, (void *)0);
#line 648
  add_attr(0, (size_t *)((void *)0), 'B', 2U, (size_t )0, hash, (void *)0);
#line 649
  add_attr(0, (size_t *)((void *)0), 'B', 3U, (size_t )0, auth, (void *)0);
#line 650
  add_attr(0, (size_t *)((void *)0), 'B', 4U, (size_t )0, group, (void *)0);
  }
#line 654
  if (keylen) {
    {
#line 655
    add_attr(0, (size_t *)((void *)0), 'B', 14U, (size_t )0, keylen, (void *)0);
    }
  }
#line 657
  if (lifetime_data_len) {
    {
#line 658
    add_attr(0, (size_t *)((void *)0), 'B', 11U, (size_t )0, 1U, (void *)0);
#line 659
    add_attr(0, (size_t *)((void *)0), 'V', 12U, lifetime_data_len, 0U, (void *)lifetime_data);
    }
  }
#line 663
  if (lifesize_data_len) {
    {
#line 664
    add_attr(0, (size_t *)((void *)0), 'B', 11U, (size_t )0, 2U, (void *)0);
#line 665
    add_attr(0, (size_t *)((void *)0), 'V', 12U, lifesize_data_len, 0U, (void *)lifesize_data);
    }
  }
#line 669
  if (gss_id_flag) {
    {
#line 670
    add_attr(0, (size_t *)((void *)0), 'V', 16384U, gss_data_len, 0U, (void *)gss_data);
    }
  }
  {
#line 674
  attr = add_attr(1, & attr_len, '\000', 0U, (size_t )0, 0U, (void *)0);
#line 678
  payload = make_transform(length, next, number, trans_id, attr, attr_len);
#line 679
  free((void *)attr);
  }
#line 681
  return (payload);
}
}
#line 723 "/home/june/repo/benchmarks/collector/temp/ike-scan-1.9/isakmp.c"
static int first_transform  =    1;
#line 724 "/home/june/repo/benchmarks/collector/temp/ike-scan-1.9/isakmp.c"
static unsigned char *trans_start  =    (unsigned char *)((void *)0);
#line 725 "/home/june/repo/benchmarks/collector/temp/ike-scan-1.9/isakmp.c"
static size_t cur_offset___0  ;
#line 726 "/home/june/repo/benchmarks/collector/temp/ike-scan-1.9/isakmp.c"
static size_t end_offset___0  ;
#line 727 "/home/june/repo/benchmarks/collector/temp/ike-scan-1.9/isakmp.c"
static unsigned int trans_no  =    1U;
#line 714 "/home/june/repo/benchmarks/collector/temp/ike-scan-1.9/isakmp.c"
unsigned char *add_trans_simple(int finished , size_t *length , unsigned int cipher ,
                                unsigned int keylen , unsigned int hash , unsigned int auth ,
                                unsigned int group , unsigned char *lifetime_data ,
                                size_t lifetime_data_len , unsigned char *lifesize_data ,
                                size_t lifesize_data_len , int gss_id_flag , unsigned char *gss_data ,
                                size_t gss_data_len , unsigned int trans_id ) 
{ 
  unsigned char *trans ;
  size_t len ;
  void *tmp ;
  void *tmp___0 ;
  struct isakmp_transform *hdr ;

  {
#line 735
  if (! finished) {
    {
#line 736
    trans = make_trans_simple(& len, 3U, trans_no, cipher, keylen, hash, auth, group,
                              lifetime_data, lifetime_data_len, lifesize_data, lifesize_data_len,
                              gss_id_flag, gss_data, gss_data_len, trans_id);
#line 741
    trans_no ++;
    }
#line 742
    if (first_transform) {
      {
#line 743
      cur_offset___0 = (size_t )0;
#line 744
      end_offset___0 = len;
#line 745
      tmp = Malloc(end_offset___0);
#line 745
      trans_start = (unsigned char *)tmp;
#line 746
      memcpy((void */* __restrict  */)trans_start, (void const   */* __restrict  */)trans,
             len);
#line 747
      first_transform = 0;
      }
    } else {
      {
#line 749
      cur_offset___0 = end_offset___0;
#line 750
      end_offset___0 += len;
#line 751
      tmp___0 = Realloc((void *)trans_start, end_offset___0);
#line 751
      trans_start = (unsigned char *)tmp___0;
#line 752
      memcpy((void */* __restrict  */)(trans_start + cur_offset___0), (void const   */* __restrict  */)trans,
             len);
      }
    }
    {
#line 754
    free((void *)trans);
    }
#line 755
    return ((unsigned char *)((void *)0));
  } else {
#line 757
    hdr = (struct isakmp_transform *)(trans_start + cur_offset___0);
#line 760
    first_transform = 1;
#line 761
    hdr->isat_np = (uint8_t )0;
#line 762
    *length = end_offset___0;
#line 763
    return (trans_start);
  }
}
}
#line 786 "/home/june/repo/benchmarks/collector/temp/ike-scan-1.9/isakmp.c"
unsigned char *make_transform(size_t *length , unsigned int next , unsigned int number ,
                              unsigned int trans_id , unsigned char *attr , size_t attr_len ) 
{ 
  struct isakmp_transform *hdr ;
  unsigned char *payload ;
  unsigned char *cp ;
  size_t len ;
  void *tmp ;
  void *tmp___0 ;

  {
  {
#line 797
  tmp = Malloc(sizeof(struct isakmp_transform ));
#line 797
  hdr = (struct isakmp_transform *)tmp;
#line 798
  memset((void *)hdr, mbz_value, sizeof(struct isakmp_transform ));
#line 800
  hdr->isat_np = (uint8_t )next;
#line 801
  hdr->isat_transnum = (uint8_t )number;
#line 802
  hdr->isat_transid = (uint8_t )trans_id;
#line 804
  len = attr_len + sizeof(struct isakmp_transform );
#line 805
  hdr->isat_length = htons((uint16_t )len);
#line 806
  *length = len;
#line 810
  tmp___0 = Malloc(len);
#line 810
  payload = (unsigned char *)tmp___0;
#line 812
  cp = payload;
#line 813
  memcpy((void */* __restrict  */)cp, (void const   */* __restrict  */)hdr, sizeof(struct isakmp_transform ));
#line 814
  free((void *)hdr);
#line 815
  cp += sizeof(struct isakmp_transform );
#line 816
  memcpy((void */* __restrict  */)cp, (void const   */* __restrict  */)attr, attr_len);
  }
#line 818
  return (payload);
}
}
#line 846 "/home/june/repo/benchmarks/collector/temp/ike-scan-1.9/isakmp.c"
static int first_transform___0  =    1;
#line 847 "/home/june/repo/benchmarks/collector/temp/ike-scan-1.9/isakmp.c"
static unsigned char *trans_start___0  =    (unsigned char *)((void *)0);
#line 848 "/home/june/repo/benchmarks/collector/temp/ike-scan-1.9/isakmp.c"
static size_t cur_offset___1  ;
#line 849 "/home/june/repo/benchmarks/collector/temp/ike-scan-1.9/isakmp.c"
static size_t end_offset___1  ;
#line 850 "/home/june/repo/benchmarks/collector/temp/ike-scan-1.9/isakmp.c"
static unsigned int trans_no___0  =    1U;
#line 842 "/home/june/repo/benchmarks/collector/temp/ike-scan-1.9/isakmp.c"
unsigned char *add_transform(int finished , size_t *length , unsigned int trans_id ,
                             unsigned char *attr , size_t attr_len ) 
{ 
  unsigned char *trans ;
  size_t len ;
  void *tmp ;
  void *tmp___0 ;
  struct isakmp_transform *hdr ;

  {
#line 858
  if (! finished) {
    {
#line 859
    trans = make_transform(& len, 3U, trans_no___0, trans_id, attr, attr_len);
#line 861
    trans_no___0 ++;
    }
#line 862
    if (first_transform___0) {
      {
#line 863
      cur_offset___1 = (size_t )0;
#line 864
      end_offset___1 = len;
#line 865
      tmp = Malloc(end_offset___1);
#line 865
      trans_start___0 = (unsigned char *)tmp;
#line 866
      memcpy((void */* __restrict  */)trans_start___0, (void const   */* __restrict  */)trans,
             len);
#line 867
      first_transform___0 = 0;
      }
    } else {
      {
#line 869
      cur_offset___1 = end_offset___1;
#line 870
      end_offset___1 += len;
#line 871
      tmp___0 = Realloc((void *)trans_start___0, end_offset___1);
#line 871
      trans_start___0 = (unsigned char *)tmp___0;
#line 872
      memcpy((void */* __restrict  */)(trans_start___0 + cur_offset___1), (void const   */* __restrict  */)trans,
             len);
      }
    }
    {
#line 874
    free((void *)trans);
    }
#line 875
    return ((unsigned char *)((void *)0));
  } else {
#line 877
    hdr = (struct isakmp_transform *)(trans_start___0 + cur_offset___1);
#line 880
    first_transform___0 = 1;
#line 881
    hdr->isat_np = (uint8_t )0;
#line 882
    *length = end_offset___1;
#line 883
    return (trans_start___0);
  }
}
}
#line 906 "/home/june/repo/benchmarks/collector/temp/ike-scan-1.9/isakmp.c"
unsigned char *make_transform2(size_t *length , unsigned int next , unsigned int trans_type ,
                               unsigned int trans_id , unsigned char *attr , size_t attr_len ) 
{ 
  struct isakmp_transform2 *hdr ;
  unsigned char *payload ;
  unsigned char *cp ;
  size_t len ;
  void *tmp ;
  void *tmp___0 ;

  {
  {
#line 917
  tmp = Malloc(sizeof(struct isakmp_transform2 ));
#line 917
  hdr = (struct isakmp_transform2 *)tmp;
#line 918
  memset((void *)hdr, mbz_value, sizeof(struct isakmp_transform2 ));
#line 920
  hdr->isat2_np = (uint8_t )next;
#line 921
  hdr->isat2_transtype = (uint8_t )trans_type;
#line 922
  hdr->isat2_transid = htons((uint16_t )trans_id);
#line 924
  len = attr_len + sizeof(struct isakmp_transform2 );
#line 925
  hdr->isat2_length = htons((uint16_t )len);
#line 926
  *length = len;
#line 930
  tmp___0 = Malloc(len);
#line 930
  payload = (unsigned char *)tmp___0;
#line 932
  cp = payload;
#line 933
  memcpy((void */* __restrict  */)cp, (void const   */* __restrict  */)hdr, sizeof(struct isakmp_transform2 ));
#line 934
  free((void *)hdr);
#line 935
  cp += sizeof(struct isakmp_transform2 );
#line 936
  memcpy((void */* __restrict  */)cp, (void const   */* __restrict  */)attr, attr_len);
  }
#line 938
  return (payload);
}
}
#line 967 "/home/june/repo/benchmarks/collector/temp/ike-scan-1.9/isakmp.c"
static int first_transform___1  =    1;
#line 968 "/home/june/repo/benchmarks/collector/temp/ike-scan-1.9/isakmp.c"
static unsigned char *trans_start___1  =    (unsigned char *)((void *)0);
#line 969 "/home/june/repo/benchmarks/collector/temp/ike-scan-1.9/isakmp.c"
static size_t cur_offset___2  ;
#line 970 "/home/june/repo/benchmarks/collector/temp/ike-scan-1.9/isakmp.c"
static size_t end_offset___2  ;
#line 963 "/home/june/repo/benchmarks/collector/temp/ike-scan-1.9/isakmp.c"
unsigned char *add_transform2(int finished , size_t *length , unsigned int trans_type ,
                              unsigned int trans_id , unsigned char *attr , size_t attr_len ) 
{ 
  unsigned char *trans ;
  size_t len ;
  void *tmp ;
  void *tmp___0 ;
  struct isakmp_transform2 *hdr ;

  {
#line 977
  if (! finished) {
    {
#line 978
    trans = make_transform2(& len, 3U, trans_type, trans_id, attr, attr_len);
    }
#line 980
    if (first_transform___1) {
      {
#line 981
      cur_offset___2 = (size_t )0;
#line 982
      end_offset___2 = len;
#line 983
      tmp = Malloc(end_offset___2);
#line 983
      trans_start___1 = (unsigned char *)tmp;
#line 984
      memcpy((void */* __restrict  */)trans_start___1, (void const   */* __restrict  */)trans,
             len);
#line 985
      first_transform___1 = 0;
      }
    } else {
      {
#line 987
      cur_offset___2 = end_offset___2;
#line 988
      end_offset___2 += len;
#line 989
      tmp___0 = Realloc((void *)trans_start___1, end_offset___2);
#line 989
      trans_start___1 = (unsigned char *)tmp___0;
#line 990
      memcpy((void */* __restrict  */)(trans_start___1 + cur_offset___2), (void const   */* __restrict  */)trans,
             len);
      }
    }
    {
#line 992
    free((void *)trans);
    }
#line 993
    return ((unsigned char *)((void *)0));
  } else {
#line 995
    hdr = (struct isakmp_transform2 *)(trans_start___1 + cur_offset___2);
#line 998
    first_transform___1 = 1;
#line 999
    hdr->isat2_np = (uint8_t )0;
#line 1000
    *length = end_offset___2;
#line 1001
    return (trans_start___1);
  }
}
}
#line 1028 "/home/june/repo/benchmarks/collector/temp/ike-scan-1.9/isakmp.c"
unsigned char *make_attr(size_t *outlen , int type , unsigned int class , size_t length ,
                         unsigned int b_value , void *v_value ) 
{ 
  struct isakmp_attribute *hdr ;
  unsigned char *cp ;
  size_t total_len ;
  void *tmp ;

  {
#line 1035
  total_len = sizeof(struct isakmp_attribute );
#line 1036
  if (type == 86) {
#line 1037
    total_len += length;
  }
  {
#line 1039
  tmp = Malloc(total_len);
#line 1039
  cp = (unsigned char *)tmp;
#line 1040
  hdr = (struct isakmp_attribute *)cp;
#line 1041
  memset((void *)hdr, mbz_value, sizeof(struct isakmp_attribute ));
  }
#line 1043
  if (type == 66) {
    {
#line 1044
    hdr->isaat_af_type = htons((uint16_t )(class | 32768U));
#line 1045
    hdr->isaat_lv = htons((uint16_t )b_value);
    }
  } else {
    {
#line 1047
    hdr->isaat_af_type = htons((uint16_t )class);
#line 1048
    hdr->isaat_lv = htons((uint16_t )length);
#line 1049
    memcpy((void */* __restrict  */)(cp + sizeof(struct isakmp_attribute )), (void const   */* __restrict  */)v_value,
           length);
    }
  }
#line 1052
  *outlen = total_len;
#line 1053
  return (cp);
}
}
#line 1085 "/home/june/repo/benchmarks/collector/temp/ike-scan-1.9/isakmp.c"
static int first_attr  =    1;
#line 1087 "/home/june/repo/benchmarks/collector/temp/ike-scan-1.9/isakmp.c"
static unsigned char *attr_start  =    (unsigned char *)((void *)0);
#line 1088 "/home/june/repo/benchmarks/collector/temp/ike-scan-1.9/isakmp.c"
static size_t cur_offset___3  ;
#line 1089 "/home/june/repo/benchmarks/collector/temp/ike-scan-1.9/isakmp.c"
static size_t end_offset___3  ;
#line 1081 "/home/june/repo/benchmarks/collector/temp/ike-scan-1.9/isakmp.c"
unsigned char *add_attr(int finished , size_t *outlen , int type , unsigned int class ,
                        size_t length , unsigned int b_value , void *v_value ) 
{ 
  unsigned char *attr ;
  size_t len ;
  void *tmp ;
  void *tmp___0 ;

  {
#line 1094
  if (! finished) {
    {
#line 1095
    attr = make_attr(& len, type, class, length, b_value, v_value);
    }
#line 1096
    if (first_attr) {
      {
#line 1097
      cur_offset___3 = (size_t )0;
#line 1098
      end_offset___3 = len;
#line 1099
      tmp = Malloc(end_offset___3);
#line 1099
      attr_start = (unsigned char *)tmp;
#line 1100
      memcpy((void */* __restrict  */)attr_start, (void const   */* __restrict  */)attr,
             len);
#line 1101
      first_attr = 0;
      }
    } else {
      {
#line 1103
      cur_offset___3 = end_offset___3;
#line 1104
      end_offset___3 += len;
#line 1105
      tmp___0 = Realloc((void *)attr_start, end_offset___3);
#line 1105
      attr_start = (unsigned char *)tmp___0;
#line 1106
      memcpy((void */* __restrict  */)(attr_start + cur_offset___3), (void const   */* __restrict  */)attr,
             len);
      }
    }
#line 1108
    return ((unsigned char *)((void *)0));
  } else {
#line 1110
    first_attr = 1;
#line 1111
    *outlen = end_offset___3;
#line 1112
    return (attr_start);
  }
}
}
#line 1133 "/home/june/repo/benchmarks/collector/temp/ike-scan-1.9/isakmp.c"
unsigned char *make_vid(size_t *length , unsigned int next , unsigned char *vid_data ,
                        size_t vid_data_len ) 
{ 
  unsigned char *payload ;
  struct isakmp_vid *hdr ;
  void *tmp ;

  {
  {
#line 1139
  tmp = Malloc(sizeof(struct isakmp_vid ) + vid_data_len);
#line 1139
  payload = (unsigned char *)tmp;
#line 1140
  hdr = (struct isakmp_vid *)payload;
#line 1141
  memset((void *)hdr, mbz_value, sizeof(struct isakmp_vid ));
#line 1143
  hdr->isavid_np = (uint8_t )next;
#line 1144
  hdr->isavid_length = htons((uint16_t )(sizeof(struct isakmp_vid ) + vid_data_len));
#line 1146
  memcpy((void */* __restrict  */)(payload + sizeof(struct isakmp_vid )), (void const   */* __restrict  */)vid_data,
         vid_data_len);
#line 1147
  *length = sizeof(struct isakmp_vid ) + vid_data_len;
  }
#line 1149
  return (payload);
}
}
#line 1177 "/home/june/repo/benchmarks/collector/temp/ike-scan-1.9/isakmp.c"
static int first_vid  =    1;
#line 1178 "/home/june/repo/benchmarks/collector/temp/ike-scan-1.9/isakmp.c"
static unsigned char *vid_start  =    (unsigned char *)((void *)0);
#line 1179 "/home/june/repo/benchmarks/collector/temp/ike-scan-1.9/isakmp.c"
static size_t cur_offset___4  ;
#line 1180 "/home/june/repo/benchmarks/collector/temp/ike-scan-1.9/isakmp.c"
static size_t end_offset___4  ;
#line 1174 "/home/june/repo/benchmarks/collector/temp/ike-scan-1.9/isakmp.c"
unsigned char *add_vid(int finished , size_t *length , unsigned char *vid_data , size_t vid_data_len ,
                       unsigned int next ) 
{ 
  unsigned char *vid ;
  size_t len ;
  void *tmp ;
  void *tmp___0 ;
  struct isakmp_vid *hdr ;

  {
#line 1186
  if (! finished) {
    {
#line 1187
    vid = make_vid(& len, 13U, vid_data, vid_data_len);
    }
#line 1188
    if (first_vid) {
      {
#line 1189
      cur_offset___4 = (size_t )0;
#line 1190
      end_offset___4 = len;
#line 1191
      tmp = Malloc(end_offset___4);
#line 1191
      vid_start = (unsigned char *)tmp;
#line 1192
      memcpy((void */* __restrict  */)vid_start, (void const   */* __restrict  */)vid,
             len);
#line 1193
      first_vid = 0;
      }
    } else {
      {
#line 1195
      cur_offset___4 = end_offset___4;
#line 1196
      end_offset___4 += len;
#line 1197
      tmp___0 = Realloc((void *)vid_start, end_offset___4);
#line 1197
      vid_start = (unsigned char *)tmp___0;
#line 1198
      memcpy((void */* __restrict  */)(vid_start + cur_offset___4), (void const   */* __restrict  */)vid,
             len);
      }
    }
#line 1200
    return ((unsigned char *)((void *)0));
  } else {
#line 1202
    hdr = (struct isakmp_vid *)(vid_start + cur_offset___4);
#line 1205
    hdr->isavid_np = (uint8_t )next;
#line 1206
    *length = end_offset___4;
#line 1207
    return (vid_start);
  }
}
}
#line 1227 "/home/june/repo/benchmarks/collector/temp/ike-scan-1.9/isakmp.c"
unsigned char *make_ke(size_t *length , unsigned int next , size_t kx_data_len ) 
{ 
  unsigned char *payload ;
  struct isakmp_kx *hdr ;
  unsigned char *kx_data ;
  unsigned int i ;
  void *tmp ;
  unsigned char *tmp___0 ;
  uint8_t tmp___1 ;

  {
#line 1234
  if (kx_data_len % 4UL) {
    {
#line 1235
    err_msg("Key exchange data length %d is not a multiple of 4", kx_data_len);
    }
  }
  {
#line 1238
  tmp = Malloc(sizeof(struct isakmp_kx ) + kx_data_len);
#line 1238
  payload = (unsigned char *)tmp;
#line 1239
  hdr = (struct isakmp_kx *)payload;
#line 1240
  memset((void *)hdr, mbz_value, sizeof(struct isakmp_kx ));
#line 1242
  kx_data = payload + sizeof(struct isakmp_kx );
#line 1243
  i = 0U;
  }
  {
#line 1243
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1243
    if (! ((size_t )i < kx_data_len)) {
#line 1243
      goto while_break;
    }
    {
#line 1244
    tmp___0 = kx_data;
#line 1244
    kx_data ++;
#line 1244
    tmp___1 = random_byte();
#line 1244
    *tmp___0 = tmp___1;
#line 1243
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1246
  hdr->isakx_np = (uint8_t )next;
#line 1247
  hdr->isakx_length = htons((uint16_t )(sizeof(struct isakmp_kx ) + kx_data_len));
#line 1249
  *length = sizeof(struct isakmp_kx ) + kx_data_len;
  }
#line 1251
  return (payload);
}
}
#line 1271 "/home/june/repo/benchmarks/collector/temp/ike-scan-1.9/isakmp.c"
unsigned char *make_ke2(size_t *length , unsigned int next , unsigned int dh_group ,
                        size_t kx_data_len ) 
{ 
  unsigned char *payload ;
  struct isakmp_kx2 *hdr ;
  unsigned char *kx_data ;
  unsigned int i ;
  void *tmp ;
  unsigned char *tmp___0 ;
  uint8_t tmp___1 ;

  {
#line 1278
  if (kx_data_len % 4UL) {
    {
#line 1279
    err_msg("Key exchange data length %d is not a multiple of 4", kx_data_len);
    }
  }
  {
#line 1282
  tmp = Malloc(sizeof(struct isakmp_kx2 ) + kx_data_len);
#line 1282
  payload = (unsigned char *)tmp;
#line 1283
  hdr = (struct isakmp_kx2 *)payload;
#line 1284
  memset((void *)hdr, mbz_value, sizeof(struct isakmp_kx2 ));
#line 1286
  kx_data = payload + sizeof(struct isakmp_kx2 );
#line 1287
  i = 0U;
  }
  {
#line 1287
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1287
    if (! ((size_t )i < kx_data_len)) {
#line 1287
      goto while_break;
    }
    {
#line 1288
    tmp___0 = kx_data;
#line 1288
    kx_data ++;
#line 1288
    tmp___1 = random_byte();
#line 1288
    *tmp___0 = tmp___1;
#line 1287
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1290
  hdr->isakx2_np = (uint8_t )next;
#line 1291
  hdr->isakx2_length = htons((uint16_t )(sizeof(struct isakmp_kx2 ) + kx_data_len));
#line 1292
  hdr->isakx2_dhgroup = htons((uint16_t )dh_group);
#line 1294
  *length = sizeof(struct isakmp_kx2 ) + kx_data_len;
  }
#line 1296
  return (payload);
}
}
#line 1316 "/home/june/repo/benchmarks/collector/temp/ike-scan-1.9/isakmp.c"
unsigned char *make_nonce(size_t *length , unsigned int next , size_t nonce_len ) 
{ 
  unsigned char *payload ;
  struct isakmp_nonce *hdr ;
  unsigned char *cp ;
  unsigned int i ;
  void *tmp ;
  unsigned char *tmp___0 ;
  uint8_t tmp___1 ;

  {
  {
#line 1323
  tmp = Malloc(sizeof(struct isakmp_nonce ) + nonce_len);
#line 1323
  payload = (unsigned char *)tmp;
#line 1324
  hdr = (struct isakmp_nonce *)payload;
#line 1325
  memset((void *)hdr, mbz_value, sizeof(struct isakmp_nonce ));
#line 1327
  hdr->isanonce_np = (uint8_t )next;
#line 1328
  hdr->isanonce_length = htons((uint16_t )(sizeof(struct isakmp_nonce ) + nonce_len));
#line 1330
  cp = payload + sizeof(struct isakmp_vid );
#line 1331
  i = 0U;
  }
  {
#line 1331
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1331
    if (! ((size_t )i < nonce_len)) {
#line 1331
      goto while_break;
    }
    {
#line 1332
    tmp___0 = cp;
#line 1332
    cp ++;
#line 1332
    tmp___1 = random_byte();
#line 1332
    *tmp___0 = tmp___1;
#line 1331
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1334
  *length = sizeof(struct isakmp_nonce ) + nonce_len;
#line 1335
  return (payload);
}
}
#line 1350 "/home/june/repo/benchmarks/collector/temp/ike-scan-1.9/isakmp.c"
unsigned char *make_id(size_t *length , unsigned int next , unsigned int idtype ,
                       unsigned char *id_data , size_t id_data_len ) 
{ 
  unsigned char *payload ;
  struct isakmp_id *hdr ;
  void *tmp ;

  {
  {
#line 1356
  tmp = Malloc(sizeof(struct isakmp_id ) + id_data_len);
#line 1356
  payload = (unsigned char *)tmp;
#line 1357
  hdr = (struct isakmp_id *)payload;
#line 1358
  memset((void *)hdr, mbz_value, sizeof(struct isakmp_id ));
#line 1360
  hdr->isaid_np = (uint8_t )next;
#line 1361
  hdr->isaid_length = htons((uint16_t )(sizeof(struct isakmp_id ) + id_data_len));
#line 1362
  hdr->isaid_idtype = (uint8_t )idtype;
#line 1367
  hdr->isaid_doi_specific_a = (uint8_t )17;
#line 1368
  hdr->isaid_doi_specific_b = htons((uint16_t )500);
#line 1370
  memcpy((void */* __restrict  */)(payload + sizeof(struct isakmp_id )), (void const   */* __restrict  */)id_data,
         id_data_len);
#line 1371
  *length = sizeof(struct isakmp_id ) + id_data_len;
  }
#line 1373
  return (payload);
}
}
#line 1393 "/home/june/repo/benchmarks/collector/temp/ike-scan-1.9/isakmp.c"
unsigned char *make_udphdr(size_t *length , unsigned int sport , unsigned int dport ,
                           unsigned int udplen ) 
{ 
  unsigned char *payload ;
  ike_udphdr *hdr ;
  void *tmp ;

  {
  {
#line 1398
  tmp = Malloc(sizeof(ike_udphdr ));
#line 1398
  payload = (unsigned char *)tmp;
#line 1399
  hdr = (ike_udphdr *)payload;
#line 1401
  hdr->source = htons((uint16_t )sport);
#line 1402
  hdr->dest = htons((uint16_t )dport);
#line 1403
  hdr->len = htons((uint16_t )udplen);
#line 1404
  hdr->check = (uint16_t )0;
#line 1406
  *length = sizeof(ike_udphdr );
  }
#line 1408
  return (payload);
}
}
#line 1427 "/home/june/repo/benchmarks/collector/temp/ike-scan-1.9/isakmp.c"
unsigned char *make_cr(size_t *length , unsigned int next , unsigned char *cr_data ,
                       size_t cr_data_len ) 
{ 
  unsigned char *payload ;
  struct isakmp_generic *hdr ;
  void *tmp ;

  {
  {
#line 1433
  tmp = Malloc(sizeof(struct isakmp_generic ) + cr_data_len);
#line 1433
  payload = (unsigned char *)tmp;
#line 1434
  hdr = (struct isakmp_generic *)payload;
#line 1435
  memset((void *)hdr, mbz_value, sizeof(struct isakmp_generic ));
#line 1437
  hdr->isag_np = (uint8_t )next;
#line 1438
  hdr->isag_length = htons((uint16_t )(sizeof(struct isakmp_generic ) + cr_data_len));
#line 1440
  memcpy((void */* __restrict  */)(payload + sizeof(struct isakmp_generic )), (void const   */* __restrict  */)cr_data,
         cr_data_len);
#line 1441
  *length = sizeof(struct isakmp_generic ) + cr_data_len;
  }
#line 1443
  return (payload);
}
}
#line 1459 "/home/june/repo/benchmarks/collector/temp/ike-scan-1.9/isakmp.c"
unsigned char *skip_payload(unsigned char *cp , size_t *len , unsigned int *next ) 
{ 
  struct isakmp_generic hdr ;
  uint16_t tmp ;
  uint16_t tmp___0 ;
  uint16_t tmp___1 ;
  uint16_t tmp___2 ;

  {
#line 1468
  if (*len < sizeof(struct isakmp_generic )) {
#line 1469
    *len = (size_t )0;
#line 1470
    *next = 0U;
#line 1471
    return ((unsigned char *)((void *)0));
  }
  {
#line 1478
  memcpy((void */* __restrict  */)(& hdr), (void const   */* __restrict  */)cp, sizeof(hdr));
#line 1488
  tmp = ntohs(hdr.isag_length);
  }
#line 1488
  if ((size_t )tmp >= *len) {
#line 1491
    *len = (size_t )0;
#line 1492
    *next = 0U;
#line 1493
    return ((unsigned char *)((void *)0));
  } else {
    {
#line 1488
    tmp___0 = ntohs(hdr.isag_length);
    }
#line 1488
    if ((unsigned long )tmp___0 < sizeof(struct isakmp_generic )) {
#line 1491
      *len = (size_t )0;
#line 1492
      *next = 0U;
#line 1493
      return ((unsigned char *)((void *)0));
    } else
#line 1488
    if ((int )hdr.isag_np == 0) {
#line 1491
      *len = (size_t )0;
#line 1492
      *next = 0U;
#line 1493
      return ((unsigned char *)((void *)0));
    }
  }
  {
#line 1499
  tmp___1 = ntohs(hdr.isag_length);
#line 1499
  *len -= (size_t )tmp___1;
#line 1500
  *next = (unsigned int )hdr.isag_np;
#line 1501
  tmp___2 = ntohs(hdr.isag_length);
  }
#line 1501
  return (cp + (int )tmp___2);
}
}
#line 1519 "/home/june/repo/benchmarks/collector/temp/ike-scan-1.9/isakmp.c"
unsigned char *process_isakmp_hdr(unsigned char *cp , size_t *len , unsigned int *next ,
                                  unsigned int *type , char **hdr_descr ) 
{ 
  struct isakmp_hdr *hdr ;
  char *msg ;
  char *msg2 ;
  uint32_t tmp ;
  uint32_t tmp___0 ;

  {
#line 1522
  hdr = (struct isakmp_hdr *)cp;
#line 1534
  if (*len < sizeof(struct isakmp_hdr )) {
#line 1537
    *hdr_descr = (char *)((void *)0);
#line 1538
    *len = (size_t )0;
#line 1539
    *next = 0U;
#line 1540
    *type = 0U;
#line 1541
    return ((unsigned char *)((void *)0));
  } else {
    {
#line 1534
    tmp = ntohl(hdr->isa_length);
    }
#line 1534
    if ((unsigned long )tmp < sizeof(struct isakmp_hdr )) {
#line 1537
      *hdr_descr = (char *)((void *)0);
#line 1538
      *len = (size_t )0;
#line 1539
      *next = 0U;
#line 1540
      *type = 0U;
#line 1541
      return ((unsigned char *)((void *)0));
    } else
#line 1534
    if ((int )hdr->isa_np == 0) {
#line 1537
      *hdr_descr = (char *)((void *)0);
#line 1538
      *len = (size_t )0;
#line 1539
      *next = 0U;
#line 1540
      *type = 0U;
#line 1541
      return ((unsigned char *)((void *)0));
    }
  }
  {
#line 1546
  msg2 = hexstring((unsigned char const   *)((unsigned char *)(hdr->isa_rcookie)),
                   (size_t )8);
#line 1547
  msg = make_message("HDR=(CKY-R=%s", msg2);
#line 1548
  free((void *)msg2);
  }
#line 1549
  if ((int )hdr->isa_version != 16) {
#line 1550
    msg2 = msg;
#line 1551
    if ((int )hdr->isa_version == 32) {
      {
#line 1552
      msg = make_message("%s, IKEv2", msg2);
      }
    } else {
      {
#line 1554
      msg = make_message("%s, version=0x%.2x", msg2, (int )hdr->isa_version);
      }
    }
    {
#line 1557
    free((void *)msg2);
    }
  }
#line 1559
  if ((int )hdr->isa_version == 16) {
#line 1559
    if ((int )hdr->isa_flags != 0) {
      {
#line 1561
      msg2 = msg;
#line 1562
      msg = make_message("%s, flags=0x%.2x", msg2, (int )hdr->isa_flags);
#line 1563
      free((void *)msg2);
      }
    } else {
#line 1559
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 1559
  if ((int )hdr->isa_version == 32) {
#line 1559
    if ((int )hdr->isa_flags != 32) {
      {
#line 1561
      msg2 = msg;
#line 1562
      msg = make_message("%s, flags=0x%.2x", msg2, (int )hdr->isa_flags);
#line 1563
      free((void *)msg2);
      }
    }
  }
#line 1565
  if (hdr->isa_msgid != 0U) {
    {
#line 1566
    msg2 = msg;
#line 1567
    tmp___0 = ntohl(hdr->isa_msgid);
#line 1567
    msg = make_message("%s, msgid=%.8x", msg2, tmp___0);
#line 1568
    free((void *)msg2);
    }
  }
  {
#line 1570
  msg2 = msg;
#line 1571
  msg = make_message("%s)", msg2);
#line 1572
  free((void *)msg2);
#line 1577
  *hdr_descr = msg;
#line 1578
  *len -= sizeof(struct isakmp_hdr );
#line 1579
  *next = (unsigned int )hdr->isa_np;
#line 1580
  *type = (unsigned int )hdr->isa_xchg;
  }
#line 1581
  return (cp + sizeof(struct isakmp_hdr ));
}
}
#line 1603 "/home/june/repo/benchmarks/collector/temp/ike-scan-1.9/isakmp.c"
char *process_sa(unsigned char *cp , size_t len , unsigned int type , int quiet ,
                 int multiline , char *hdr_descr ) 
{ 
  struct isakmp_sa *sa_hdr ;
  struct isakmp_proposal *prop_hdr ;
  char *msg ;
  char *msg2 ;
  char *msg3 ;
  unsigned char *attr_ptr ;
  size_t safelen ;
  uint16_t tmp___0 ;
  uint16_t tmp___1 ;
  char *tmp___2 ;
  char const   *tmp___3 ;
  int firstloop ;
  char const   *tmp___4 ;

  {
  {
#line 1606
  sa_hdr = (struct isakmp_sa *)cp;
#line 1607
  prop_hdr = (struct isakmp_proposal *)(cp + sizeof(struct isakmp_sa ));
#line 1615
  tmp___1 = ntohs(sa_hdr->isasa_length);
  }
#line 1615
  if ((size_t )tmp___1 < len) {
    {
#line 1615
    tmp___0 = ntohs(sa_hdr->isasa_length);
#line 1615
    safelen = (size_t )tmp___0;
    }
  } else {
#line 1615
    safelen = len;
  }
#line 1621
  if (safelen < (sizeof(struct isakmp_sa ) + sizeof(struct isakmp_proposal )) + sizeof(struct isakmp_transform )) {
    {
#line 1623
    tmp___2 = make_message("IKE Handshake returned (packet too short to decode)");
    }
#line 1623
    return (tmp___2);
  }
#line 1627
  if (type == 2U) {
    {
#line 1628
    msg = make_message("Main Mode Handshake returned");
    }
  } else
#line 1629
  if (type == 4U) {
    {
#line 1630
    msg = make_message("Aggressive Mode Handshake returned");
    }
  } else {
    {
#line 1632
    msg = make_message("UNKNOWN Mode Handshake returned (%u)", type);
    }
  }
#line 1637
  if (! quiet) {
#line 1638
    msg2 = msg;
#line 1639
    if (multiline) {
#line 1639
      tmp___3 = "\n\t";
    } else {
#line 1639
      tmp___3 = " ";
    }
    {
#line 1639
    msg = make_message("%s%s%s", msg2, tmp___3, hdr_descr);
#line 1640
    free((void *)msg2);
    }
  }
#line 1647
  if ((int )prop_hdr->isap_notrans != 1) {
    {
#line 1648
    msg2 = msg;
#line 1649
    msg = make_message("%s (%d transforms)", msg2, (int )prop_hdr->isap_notrans);
#line 1650
    free((void *)msg2);
    }
  }
#line 1656
  if (! quiet) {
#line 1656
    if ((int )prop_hdr->isap_notrans == 1) {
#line 1657
      firstloop = 1;
#line 1659
      msg2 = msg;
#line 1660
      if (multiline) {
#line 1660
        tmp___4 = "\n\t";
      } else {
#line 1660
        tmp___4 = " ";
      }
      {
#line 1660
      msg = make_message("%s%sSA=(", msg2, tmp___4);
#line 1661
      free((void *)msg2);
      }
#line 1662
      if ((int )prop_hdr->isap_spisize != 0) {
        {
#line 1663
        msg2 = msg;
#line 1664
        msg3 = hexstring((unsigned char const   *)((cp + sizeof(struct isakmp_sa )) + sizeof(struct isakmp_proposal )),
                         (size_t )prop_hdr->isap_spisize);
#line 1667
        msg = make_message("%sSPI=%s ", msg2, msg3);
#line 1668
        free((void *)msg2);
#line 1669
        free((void *)msg3);
        }
      }
#line 1671
      attr_ptr = (((cp + sizeof(struct isakmp_sa )) + sizeof(struct isakmp_proposal )) + (int )prop_hdr->isap_spisize) + sizeof(struct isakmp_transform );
#line 1674
      safelen -= ((sizeof(struct isakmp_sa ) + sizeof(struct isakmp_proposal )) + (unsigned long )prop_hdr->isap_spisize) + sizeof(struct isakmp_transform );
      {
#line 1678
      while (1) {
        while_continue: /* CIL Label */ ;
#line 1678
        if (! safelen) {
#line 1678
          goto while_break;
        }
        {
#line 1679
        msg2 = msg;
#line 1680
        msg3 = process_attr(& attr_ptr, & safelen);
        }
#line 1681
        if (firstloop) {
          {
#line 1682
          msg = make_message("%s%s", msg2, msg3);
#line 1683
          firstloop = 0;
          }
        } else {
          {
#line 1685
          msg = make_message("%s %s", msg2, msg3);
          }
        }
        {
#line 1687
        free((void *)msg2);
#line 1688
        free((void *)msg3);
        }
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 1690
      msg2 = msg;
#line 1691
      msg = make_message("%s)", msg2);
#line 1692
      free((void *)msg2);
      }
    }
  }
#line 1695
  return (msg);
}
}
#line 1717 "/home/june/repo/benchmarks/collector/temp/ike-scan-1.9/isakmp.c"
char *process_sa2(unsigned char *cp , size_t len , unsigned int type , int quiet ,
                  int multiline , char *hdr_descr ) 
{ 
  struct isakmp_sa2 *sa_hdr ;
  struct isakmp_proposal *prop_hdr ;
  char *msg ;
  char *msg2 ;
  char *msg3 ;
  unsigned char *trans_ptr ;
  size_t safelen ;
  uint16_t tmp___0 ;
  uint16_t tmp___1 ;
  char *tmp___2 ;
  char const   *tmp___3 ;
  int firstloop ;
  char const   *tmp___4 ;

  {
  {
#line 1720
  sa_hdr = (struct isakmp_sa2 *)cp;
#line 1721
  prop_hdr = (struct isakmp_proposal *)(cp + sizeof(struct isakmp_sa2 ));
#line 1729
  tmp___1 = ntohs(sa_hdr->isasa2_length);
  }
#line 1729
  if ((size_t )tmp___1 < len) {
    {
#line 1729
    tmp___0 = ntohs(sa_hdr->isasa2_length);
#line 1729
    safelen = (size_t )tmp___0;
    }
  } else {
#line 1729
    safelen = len;
  }
#line 1735
  if (safelen < (sizeof(struct isakmp_sa2 ) + sizeof(struct isakmp_proposal )) + sizeof(struct isakmp_transform2 )) {
    {
#line 1737
    tmp___2 = make_message("IKEv2 Handshake returned (packet too short to decode)");
    }
#line 1737
    return (tmp___2);
  }
#line 1741
  if (type == 34U) {
    {
#line 1742
    msg = make_message("IKEv2 SA_INIT Handshake returned");
    }
  } else {
    {
#line 1744
    msg = make_message("UNKNOWN Mode Handshake returned (%u)", type);
    }
  }
#line 1749
  if (! quiet) {
#line 1750
    msg2 = msg;
#line 1751
    if (multiline) {
#line 1751
      tmp___3 = "\n\t";
    } else {
#line 1751
      tmp___3 = " ";
    }
    {
#line 1751
    msg = make_message("%s%s%s", msg2, tmp___3, hdr_descr);
#line 1752
    free((void *)msg2);
    }
  }
#line 1759
  if ((int )prop_hdr->isap_np != 0) {
    {
#line 1760
    msg2 = msg;
#line 1761
    msg = make_message("%s (multiple proposals)", msg2);
#line 1762
    free((void *)msg2);
    }
  }
#line 1768
  if (! quiet) {
#line 1768
    if ((int )prop_hdr->isap_np == 0) {
#line 1769
      firstloop = 1;
#line 1771
      msg2 = msg;
#line 1772
      if (multiline) {
#line 1772
        tmp___4 = "\n\t";
      } else {
#line 1772
        tmp___4 = " ";
      }
      {
#line 1772
      msg = make_message("%s%sSA=(", msg2, tmp___4);
#line 1773
      free((void *)msg2);
      }
#line 1774
      if ((int )prop_hdr->isap_spisize != 0) {
        {
#line 1775
        msg2 = msg;
#line 1776
        msg3 = hexstring((unsigned char const   *)((cp + sizeof(struct isakmp_sa2 )) + sizeof(struct isakmp_proposal )),
                         (size_t )prop_hdr->isap_spisize);
#line 1779
        msg = make_message("%sSPI=%s ", msg2, msg3);
#line 1780
        free((void *)msg2);
#line 1781
        free((void *)msg3);
        }
      }
#line 1783
      trans_ptr = ((cp + sizeof(struct isakmp_sa2 )) + sizeof(struct isakmp_proposal )) + (int )prop_hdr->isap_spisize;
#line 1785
      safelen -= (sizeof(struct isakmp_sa2 ) + sizeof(struct isakmp_proposal )) + (unsigned long )prop_hdr->isap_spisize;
      {
#line 1788
      while (1) {
        while_continue: /* CIL Label */ ;
#line 1788
        if (! safelen) {
#line 1788
          goto while_break;
        }
        {
#line 1789
        msg2 = msg;
#line 1790
        msg3 = process_transform2(& trans_ptr, & safelen);
        }
#line 1791
        if (firstloop) {
          {
#line 1792
          msg = make_message("%s%s", msg2, msg3);
#line 1793
          firstloop = 0;
          }
        } else {
          {
#line 1795
          msg = make_message("%s %s", msg2, msg3);
          }
        }
        {
#line 1797
        free((void *)msg2);
#line 1798
        free((void *)msg3);
        }
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 1800
      msg2 = msg;
#line 1801
      msg = make_message("%s)", msg2);
#line 1802
      free((void *)msg2);
      }
    }
  }
#line 1805
  return (msg);
}
}
#line 1823 "/home/june/repo/benchmarks/collector/temp/ike-scan-1.9/isakmp.c"
char *process_attr(unsigned char **cp , size_t *len ) 
{ 
  char *msg ;
  struct isakmp_attribute *attr_hdr ;
  char attr_type ;
  unsigned int attr_class ;
  unsigned int attr_value ;
  char *attr_class_str ;
  char *attr_value_str ;
  size_t value_len ;
  size_t size ;
  uint16_t tmp ;
  uint16_t tmp___0 ;
  uint16_t tmp___1 ;
  uint16_t tmp___2 ;
  uint16_t tmp___3 ;
  char const   *tmp___4 ;
  char const   *tmp___5 ;
  char const   *tmp___6 ;
  char const   *tmp___7 ;
  char const   *tmp___8 ;
  char const   *tmp___9 ;

  {
  {
#line 1826
  attr_hdr = (struct isakmp_attribute *)*cp;
#line 1829
  attr_value = 0U;
#line 1835
  tmp___3 = ntohs(attr_hdr->isaat_af_type);
  }
#line 1835
  if ((int )tmp___3 & 32768) {
    {
#line 1836
    attr_type = (char )'B';
#line 1837
    tmp = ntohs(attr_hdr->isaat_af_type);
#line 1837
    attr_class = (unsigned int )((int )tmp & 32767);
#line 1838
    tmp___0 = ntohs(attr_hdr->isaat_lv);
#line 1838
    attr_value = (unsigned int )tmp___0;
#line 1839
    value_len = (size_t )0;
    }
  } else {
    {
#line 1841
    attr_type = (char )'V';
#line 1842
    tmp___1 = ntohs(attr_hdr->isaat_af_type);
#line 1842
    attr_class = (unsigned int )tmp___1;
#line 1843
    tmp___2 = ntohs(attr_hdr->isaat_lv);
#line 1843
    value_len = (size_t )tmp___2;
    }
  }
  {
#line 1846
  tmp___4 = id_to_name(attr_class, attr_map);
#line 1846
  attr_class_str = make_message("%s", tmp___4);
  }
#line 1848
  if ((int )attr_type == 66) {
    {
#line 1850
    if (attr_class == 1U) {
#line 1850
      goto case_1;
    }
#line 1853
    if (attr_class == 2U) {
#line 1853
      goto case_2;
    }
#line 1856
    if (attr_class == 3U) {
#line 1856
      goto case_3;
    }
#line 1859
    if (attr_class == 4U) {
#line 1859
      goto case_4;
    }
#line 1862
    if (attr_class == 11U) {
#line 1862
      goto case_11;
    }
#line 1865
    goto switch_default;
    case_1: /* CIL Label */ 
    {
#line 1851
    tmp___5 = id_to_name(attr_value, enc_map);
#line 1851
    attr_value_str = make_message("%s", tmp___5);
    }
#line 1852
    goto switch_break;
    case_2: /* CIL Label */ 
    {
#line 1854
    tmp___6 = id_to_name(attr_value, hash_map);
#line 1854
    attr_value_str = make_message("%s", tmp___6);
    }
#line 1855
    goto switch_break;
    case_3: /* CIL Label */ 
    {
#line 1857
    tmp___7 = id_to_name(attr_value, auth_map);
#line 1857
    attr_value_str = make_message("%s", tmp___7);
    }
#line 1858
    goto switch_break;
    case_4: /* CIL Label */ 
    {
#line 1860
    tmp___8 = id_to_name(attr_value, dh_map);
#line 1860
    attr_value_str = make_message("%s", tmp___8);
    }
#line 1861
    goto switch_break;
    case_11: /* CIL Label */ 
    {
#line 1863
    tmp___9 = id_to_name(attr_value, life_map);
#line 1863
    attr_value_str = make_message("%s", tmp___9);
    }
#line 1864
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 1866
    attr_value_str = make_message("%u", attr_value);
    }
#line 1867
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  } else {
    {
#line 1870
    attr_value_str = hexstring((unsigned char const   *)(*cp + sizeof(struct isakmp_attribute )),
                               value_len);
    }
  }
#line 1874
  if ((int )attr_type == 66) {
    {
#line 1875
    msg = make_message("%s=%s", attr_class_str, attr_value_str);
    }
  } else {
    {
#line 1877
    msg = make_message("%s(%u)=0x%s", attr_class_str, value_len, attr_value_str);
    }
  }
  {
#line 1880
  free((void *)attr_class_str);
#line 1881
  free((void *)attr_value_str);
#line 1883
  size = sizeof(struct isakmp_attribute ) + value_len;
  }
#line 1884
  if (size >= *len) {
#line 1885
    *len = (size_t )0;
  } else {
#line 1887
    *len -= size;
#line 1888
    *cp += size;
  }
#line 1891
  return (msg);
}
}
#line 1909 "/home/june/repo/benchmarks/collector/temp/ike-scan-1.9/isakmp.c"
char *process_transform2(unsigned char **cp , size_t *len ) 
{ 
  char *msg ;
  struct isakmp_transform2 *trans_hdr ;
  unsigned int trans_type ;
  unsigned int trans_id ;
  char *trans_type_str ;
  char *trans_id_str ;
  size_t size ;
  uint16_t tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;
  char const   *tmp___4 ;
  uint16_t tmp___5 ;
  unsigned char *attr_ptr ;
  struct isakmp_attribute *attr_hdr ;
  unsigned int attr_class ;
  unsigned int attr_value ;
  uint16_t tmp___6 ;
  uint16_t tmp___7 ;
  uint16_t tmp___8 ;
  char const   *tmp___9 ;

  {
  {
#line 1912
  trans_hdr = (struct isakmp_transform2 *)*cp;
#line 1919
  trans_type = (unsigned int )trans_hdr->isat2_transtype;
#line 1920
  tmp = ntohs(trans_hdr->isat2_transid);
#line 1920
  trans_id = (unsigned int )tmp;
#line 1922
  tmp___0 = id_to_name(trans_type, trans_type_map);
#line 1922
  trans_type_str = make_message("%s", tmp___0);
  }
  {
#line 1925
  if (trans_type == 1U) {
#line 1925
    goto case_1;
  }
#line 1928
  if (trans_type == 2U) {
#line 1928
    goto case_2;
  }
#line 1931
  if (trans_type == 3U) {
#line 1931
    goto case_3;
  }
#line 1934
  if (trans_type == 4U) {
#line 1934
    goto case_4;
  }
#line 1937
  goto switch_default;
  case_1: /* CIL Label */ 
  {
#line 1926
  tmp___1 = id_to_name(trans_id, encr_map);
#line 1926
  trans_id_str = make_message("%s", tmp___1);
  }
#line 1927
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 1929
  tmp___2 = id_to_name(trans_id, prf_map);
#line 1929
  trans_id_str = make_message("%s", tmp___2);
  }
#line 1930
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 1932
  tmp___3 = id_to_name(trans_id, integ_map);
#line 1932
  trans_id_str = make_message("%s", tmp___3);
  }
#line 1933
  goto switch_break;
  case_4: /* CIL Label */ 
  {
#line 1935
  tmp___4 = id_to_name(trans_id, dh_map);
#line 1935
  trans_id_str = make_message("%s", tmp___4);
  }
#line 1936
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 1938
  trans_id_str = make_message("%u", trans_id);
  }
#line 1939
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 1942
  tmp___5 = ntohs(trans_hdr->isat2_length);
#line 1942
  size = (size_t )tmp___5;
  }
#line 1943
  if (size > sizeof(struct isakmp_transform2 )) {
    {
#line 1944
    attr_ptr = *cp + sizeof(struct isakmp_transform2 );
#line 1945
    attr_hdr = (struct isakmp_attribute *)attr_ptr;
#line 1946
    attr_class = 0U;
#line 1947
    attr_value = 0U;
#line 1949
    tmp___8 = ntohs(attr_hdr->isaat_af_type);
    }
#line 1949
    if ((int )tmp___8 & 32768) {
      {
#line 1950
      tmp___6 = ntohs(attr_hdr->isaat_af_type);
#line 1950
      attr_class = (unsigned int )((int )tmp___6 & 32767);
#line 1951
      tmp___7 = ntohs(attr_hdr->isaat_lv);
#line 1951
      attr_value = (unsigned int )tmp___7;
      }
    } else {
      {
#line 1953
      warn_msg("WARNING: Ignoring IKEv2 variable length transform attribute");
      }
    }
    {
#line 1955
    tmp___9 = id_to_name(attr_class, attr_map);
#line 1955
    msg = make_message("%s=%s,%s=%u", trans_type_str, trans_id_str, tmp___9, attr_value);
    }
  } else {
    {
#line 1958
    msg = make_message("%s=%s", trans_type_str, trans_id_str);
    }
  }
  {
#line 1961
  free((void *)trans_type_str);
#line 1962
  free((void *)trans_id_str);
  }
#line 1964
  if (size >= *len) {
#line 1965
    *len = (size_t )0;
  } else {
#line 1967
    *len -= size;
#line 1968
    *cp += size;
  }
#line 1971
  return (msg);
}
}
#line 1990 "/home/june/repo/benchmarks/collector/temp/ike-scan-1.9/isakmp.c"
char *process_vid(unsigned char *cp , size_t len , vid_pattern_list *vidlist___0 ) 
{ 
  struct isakmp_vid *hdr ;
  char *msg ;
  char *hexvid ;
  char *p ;
  unsigned char *vid_data ;
  size_t data_len ;
  vid_pattern_list *ve ;
  char *tmp ;
  uint16_t tmp___0 ;
  uint16_t tmp___2 ;
  uint16_t tmp___3 ;
  int tmp___4 ;

  {
#line 1992
  hdr = (struct isakmp_vid *)cp;
#line 2000
  if (len < sizeof(struct isakmp_vid )) {
    {
#line 2002
    tmp = make_message("VID (packet too short to decode)");
    }
#line 2002
    return (tmp);
  } else {
    {
#line 2000
    tmp___0 = ntohs(hdr->isavid_length);
    }
#line 2000
    if ((unsigned long )tmp___0 < sizeof(struct isakmp_vid )) {
      {
#line 2002
      tmp = make_message("VID (packet too short to decode)");
      }
#line 2002
      return (tmp);
    }
  }
  {
#line 2004
  vid_data = cp + sizeof(struct isakmp_vid );
#line 2005
  tmp___3 = ntohs(hdr->isavid_length);
  }
#line 2005
  if ((size_t )tmp___3 < len) {
    {
#line 2005
    tmp___2 = ntohs(hdr->isavid_length);
#line 2005
    data_len = (size_t )tmp___2;
    }
  } else {
#line 2005
    data_len = len;
  }
  {
#line 2006
  data_len -= sizeof(struct isakmp_vid );
#line 2008
  hexvid = hexstring((unsigned char const   *)vid_data, data_len);
#line 2009
  msg = make_message("VID=%s", hexvid);
#line 2013
  ve = vidlist___0;
  }
  {
#line 2014
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2014
    if (! ((unsigned long )ve != (unsigned long )((void *)0))) {
#line 2014
      goto while_break;
    }
    {
#line 2015
    tmp___4 = regexec((regex_t const   */* __restrict  */)ve->regex, (char const   */* __restrict  */)hexvid,
                      (size_t )0, (regmatch_t */* __restrict  */)((void *)0), 0);
    }
#line 2015
    if (! tmp___4) {
      {
#line 2016
      p = msg;
#line 2017
      msg = make_message("%s (%s)", p, ve->name);
#line 2018
      free((void *)p);
      }
#line 2019
      goto while_break;
    }
#line 2021
    ve = ve->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2023
  free((void *)hexvid);
  }
#line 2024
  return (msg);
}
}
#line 2050 "/home/june/repo/benchmarks/collector/temp/ike-scan-1.9/isakmp.c"
char *process_notify(unsigned char *cp , size_t len , int quiet , int multiline ,
                     char *hdr_descr ) 
{ 
  struct isakmp_notification *hdr ;
  char *msg ;
  char *msg2 ;
  unsigned int msg_type ;
  size_t msg_len ;
  unsigned char *msg_data ;
  char *notify_msg ;
  char *tmp ;
  uint16_t tmp___0 ;
  uint16_t tmp___1 ;
  uint16_t tmp___2 ;
  char const   *tmp___3 ;
  char const   *tmp___4 ;

  {
#line 2053
  hdr = (struct isakmp_notification *)cp;
#line 2061
  if (len < sizeof(struct isakmp_notification )) {
    {
#line 2063
    tmp = make_message("Notify message (packet too short to decode)");
    }
#line 2063
    return (tmp);
  } else {
    {
#line 2061
    tmp___0 = ntohs(hdr->isan_length);
    }
#line 2061
    if ((unsigned long )tmp___0 < sizeof(struct isakmp_notification )) {
      {
#line 2063
      tmp = make_message("Notify message (packet too short to decode)");
      }
#line 2063
      return (tmp);
    }
  }
  {
#line 2065
  tmp___1 = ntohs(hdr->isan_type);
#line 2065
  msg_type = (unsigned int )tmp___1;
#line 2066
  tmp___2 = ntohs(hdr->isan_length);
#line 2066
  msg_len = (unsigned long )tmp___2 - sizeof(struct isakmp_notification );
#line 2067
  msg_data = cp + sizeof(struct isakmp_notification );
  }
#line 2069
  if (msg_type == 9101U) {
    {
#line 2070
    notify_msg = printable((unsigned char const   *)msg_data, msg_len);
#line 2071
    msg = make_message("Notify message %u (Firewall-1) Message=\"%s\"", msg_type,
                       notify_msg);
#line 2073
    free((void *)notify_msg);
    }
  } else
#line 2069
  if (msg_type == 9110U) {
    {
#line 2070
    notify_msg = printable((unsigned char const   *)msg_data, msg_len);
#line 2071
    msg = make_message("Notify message %u (Firewall-1) Message=\"%s\"", msg_type,
                       notify_msg);
#line 2073
    free((void *)notify_msg);
    }
  } else {
    {
#line 2075
    tmp___3 = id_to_name(msg_type, notification_map);
#line 2075
    msg = make_message("Notify message %u (%s)", msg_type, tmp___3);
    }
  }
#line 2081
  if (! quiet) {
#line 2082
    msg2 = msg;
#line 2083
    if (multiline) {
#line 2083
      tmp___4 = "\n\t";
    } else {
#line 2083
      tmp___4 = " ";
    }
    {
#line 2083
    msg = make_message("%s%s%s", msg2, tmp___4, hdr_descr);
#line 2084
    free((void *)msg2);
    }
  }
#line 2087
  return (msg);
}
}
#line 2113 "/home/june/repo/benchmarks/collector/temp/ike-scan-1.9/isakmp.c"
char *process_notify2(unsigned char *cp , size_t len , int quiet , int multiline ,
                      char *hdr_descr ) 
{ 
  struct isakmp_notification2 *hdr ;
  char *msg ;
  char *msg2 ;
  unsigned int msg_type ;
  size_t msg_len ;
  unsigned char *msg_data ;
  char *notify_msg ;
  char *tmp ;
  uint16_t tmp___0 ;
  uint16_t tmp___1 ;
  uint16_t tmp___2 ;
  char const   *tmp___3 ;
  char const   *tmp___4 ;

  {
#line 2116
  hdr = (struct isakmp_notification2 *)cp;
#line 2124
  if (len < sizeof(struct isakmp_notification2 )) {
    {
#line 2126
    tmp = make_message("Notify message (packet too short to decode)");
    }
#line 2126
    return (tmp);
  } else {
    {
#line 2124
    tmp___0 = ntohs(hdr->isan2_length);
    }
#line 2124
    if ((unsigned long )tmp___0 < sizeof(struct isakmp_notification2 )) {
      {
#line 2126
      tmp = make_message("Notify message (packet too short to decode)");
      }
#line 2126
      return (tmp);
    }
  }
  {
#line 2128
  tmp___1 = ntohs(hdr->isan2_type);
#line 2128
  msg_type = (unsigned int )tmp___1;
#line 2129
  tmp___2 = ntohs(hdr->isan2_length);
#line 2129
  msg_len = (unsigned long )tmp___2 - sizeof(struct isakmp_notification2 );
#line 2130
  msg_data = cp + sizeof(struct isakmp_notification2 );
  }
#line 2132
  if (msg_type == 9101U) {
    {
#line 2133
    notify_msg = printable((unsigned char const   *)msg_data, msg_len);
#line 2134
    msg = make_message("Notify message %u (Firewall-1) Message=\"%s\"", msg_type,
                       notify_msg);
#line 2136
    free((void *)notify_msg);
    }
  } else
#line 2132
  if (msg_type == 9110U) {
    {
#line 2133
    notify_msg = printable((unsigned char const   *)msg_data, msg_len);
#line 2134
    msg = make_message("Notify message %u (Firewall-1) Message=\"%s\"", msg_type,
                       notify_msg);
#line 2136
    free((void *)notify_msg);
    }
  } else {
    {
#line 2138
    tmp___3 = id_to_name(msg_type, notification_map2);
#line 2138
    msg = make_message("Notify message %u (%s)", msg_type, tmp___3);
    }
  }
#line 2144
  if (! quiet) {
#line 2145
    msg2 = msg;
#line 2146
    if (multiline) {
#line 2146
      tmp___4 = "\n\t";
    } else {
#line 2146
      tmp___4 = " ";
    }
    {
#line 2146
    msg = make_message("%s%s%s", msg2, tmp___4, hdr_descr);
#line 2147
    free((void *)msg2);
    }
  }
#line 2150
  return (msg);
}
}
#line 2168 "/home/june/repo/benchmarks/collector/temp/ike-scan-1.9/isakmp.c"
char *process_notification(unsigned char *cp , size_t len ) 
{ 
  struct isakmp_notification *hdr ;
  char *msg ;
  char *msg2 ;
  unsigned int msg_type ;
  size_t msg_len ;
  unsigned char *msg_data ;
  char *hex_spi ;
  unsigned char *notification_spi ;
  char *hex_data ;
  size_t spi_len ;
  uint32_t doi ;
  unsigned int proto_id ;
  char *tmp ;
  uint16_t tmp___0 ;
  uint16_t tmp___1 ;
  uint16_t tmp___2 ;
  char const   *tmp___3 ;
  char const   *tmp___4 ;
  char const   *tmp___5 ;

  {
#line 2170
  hdr = (struct isakmp_notification *)cp;
#line 2183
  if (len < sizeof(struct isakmp_notification )) {
    {
#line 2185
    tmp = make_message("Notification (packet too short to decode)");
    }
#line 2185
    return (tmp);
  } else {
    {
#line 2183
    tmp___0 = ntohs(hdr->isan_length);
    }
#line 2183
    if ((unsigned long )tmp___0 < sizeof(struct isakmp_notification )) {
      {
#line 2185
      tmp = make_message("Notification (packet too short to decode)");
      }
#line 2185
      return (tmp);
    }
  }
  {
#line 2187
  doi = ntohl(hdr->isan_doi);
#line 2188
  proto_id = (unsigned int )hdr->isan_protoid;
#line 2189
  tmp___1 = ntohs(hdr->isan_type);
#line 2189
  msg_type = (unsigned int )tmp___1;
#line 2190
  notification_spi = cp + sizeof(struct isakmp_notification );
#line 2191
  spi_len = (size_t )hdr->isan_spisize;
#line 2192
  hex_spi = hexstring((unsigned char const   *)notification_spi, spi_len);
#line 2193
  tmp___2 = ntohs(hdr->isan_length);
#line 2193
  msg_len = ((unsigned long )tmp___2 - sizeof(struct isakmp_notification )) - spi_len;
#line 2195
  msg_data = (cp + sizeof(struct isakmp_notification )) + spi_len;
#line 2196
  hex_data = hexstring((unsigned char const   *)msg_data, msg_len);
#line 2198
  msg = make_message("Notification=(");
  }
#line 2199
  if (doi != 1U) {
    {
#line 2200
    msg2 = msg;
#line 2201
    tmp___3 = id_to_name(doi, doi_map);
#line 2201
    msg = make_message("%sDOI=%s, ", msg2, tmp___3);
#line 2202
    free((void *)msg2);
    }
  }
#line 2204
  if (proto_id != 1U) {
    {
#line 2205
    msg2 = msg;
#line 2206
    tmp___4 = id_to_name(proto_id, protocol_map);
#line 2206
    msg = make_message("%sProto_ID=%s, ", msg2, tmp___4);
#line 2208
    free((void *)msg2);
    }
  }
  {
#line 2210
  msg2 = msg;
#line 2211
  tmp___5 = id_to_name(msg_type, notification_map);
#line 2211
  msg = make_message("%sType=%s, SPI=%s, Data=%s)", msg2, tmp___5, hex_spi, hex_data);
#line 2214
  free((void *)msg2);
#line 2215
  free((void *)hex_spi);
#line 2216
  free((void *)hex_data);
  }
#line 2218
  return (msg);
}
}
#line 2236 "/home/june/repo/benchmarks/collector/temp/ike-scan-1.9/isakmp.c"
char *process_id(unsigned char *cp , size_t len ) 
{ 
  struct isakmp_id *hdr ;
  unsigned int idtype ;
  char *msg ;
  char *msg2 ;
  unsigned char *id_data ;
  size_t data_len ;
  char *tmp ;
  uint16_t tmp___0 ;
  uint16_t tmp___2 ;
  uint16_t tmp___3 ;
  char *id ;
  struct in_addr in ;
  struct in_addr in2 ;
  unsigned char *mask ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char const   *tmp___8 ;

  {
#line 2238
  hdr = (struct isakmp_id *)cp;
#line 2245
  if (len < sizeof(struct isakmp_id )) {
    {
#line 2247
    tmp = make_message("ID (packet too short to decode)");
    }
#line 2247
    return (tmp);
  } else {
    {
#line 2245
    tmp___0 = ntohs(hdr->isaid_length);
    }
#line 2245
    if ((unsigned long )tmp___0 < sizeof(struct isakmp_id )) {
      {
#line 2247
      tmp = make_message("ID (packet too short to decode)");
      }
#line 2247
      return (tmp);
    }
  }
  {
#line 2249
  id_data = cp + sizeof(struct isakmp_id );
#line 2250
  tmp___3 = ntohs(hdr->isaid_length);
  }
#line 2250
  if ((size_t )tmp___3 < len) {
    {
#line 2250
    tmp___2 = ntohs(hdr->isaid_length);
#line 2250
    data_len = (size_t )tmp___2;
    }
  } else {
#line 2250
    data_len = len;
  }
#line 2251
  data_len -= sizeof(struct isakmp_id );
#line 2252
  idtype = (unsigned int )hdr->isaid_idtype;
  {
#line 2260
  if (idtype == 1U) {
#line 2260
    goto case_1;
  }
#line 2268
  if (idtype == 4U) {
#line 2268
    goto case_4;
  }
#line 2278
  if (idtype == 7U) {
#line 2278
    goto case_7;
  }
#line 2289
  if (idtype == 3U) {
#line 2289
    goto case_3;
  }
#line 2289
  if (idtype == 2U) {
#line 2289
    goto case_3;
  }
#line 2294
  if (idtype == 11U) {
#line 2294
    goto case_11;
  }
#line 2303
  if (idtype == 10U) {
#line 2303
    goto case_10;
  }
#line 2303
  if (idtype == 9U) {
#line 2303
    goto case_10;
  }
#line 2303
  if (idtype == 8U) {
#line 2303
    goto case_10;
  }
#line 2303
  if (idtype == 6U) {
#line 2303
    goto case_10;
  }
#line 2303
  if (idtype == 5U) {
#line 2303
    goto case_10;
  }
#line 2306
  goto switch_default;
  case_1: /* CIL Label */ 
#line 2261
  if (data_len >= sizeof(struct in_addr )) {
    {
#line 2262
    memcpy((void */* __restrict  */)(& in), (void const   */* __restrict  */)id_data,
           sizeof(struct in_addr ));
#line 2263
    tmp___4 = inet_ntoa(in);
#line 2263
    msg = make_message("Value=%s", tmp___4);
    }
  } else {
    {
#line 2265
    msg = make_message("Value too short to decode");
    }
  }
#line 2267
  goto switch_break;
  case_4: /* CIL Label */ 
#line 2269
  if (data_len >= sizeof(struct in_addr ) + 4UL) {
    {
#line 2270
    memcpy((void */* __restrict  */)(& in), (void const   */* __restrict  */)id_data,
           sizeof(struct in_addr ));
#line 2271
    mask = id_data + sizeof(struct in_addr );
#line 2272
    tmp___5 = inet_ntoa(in);
#line 2272
    msg = make_message("Value=%s/%u.%u.%u.%u", tmp___5, (int )*(mask + 0), (int )*(mask + 1),
                       (int )*(mask + 2), (int )*(mask + 3));
    }
  } else {
    {
#line 2275
    msg = make_message("Value too short to decode");
    }
  }
#line 2277
  goto switch_break;
  case_7: /* CIL Label */ 
#line 2279
  if (data_len >= 2UL * sizeof(struct in_addr )) {
    {
#line 2280
    memcpy((void */* __restrict  */)(& in), (void const   */* __restrict  */)id_data,
           sizeof(struct in_addr ));
#line 2281
    memcpy((void */* __restrict  */)(& in2), (void const   */* __restrict  */)(id_data + sizeof(struct in_addr )),
           sizeof(struct in_addr ));
#line 2283
    tmp___6 = inet_ntoa(in2);
#line 2283
    tmp___7 = inet_ntoa(in);
#line 2283
    msg = make_message("Value=%s-%s", tmp___7, tmp___6);
    }
  } else {
    {
#line 2285
    msg = make_message("Value too short to decode");
    }
  }
#line 2287
  goto switch_break;
  case_3: /* CIL Label */ 
  case_2: /* CIL Label */ 
  {
#line 2290
  id = printable((unsigned char const   *)id_data, data_len);
#line 2291
  msg = make_message("Value=%s", id);
#line 2292
  free((void *)id);
  }
#line 2293
  goto switch_break;
  case_11: /* CIL Label */ 
  {
#line 2295
  id = hexstring((unsigned char const   *)id_data, data_len);
#line 2296
  msg = make_message("Value=%s", id);
#line 2297
  free((void *)id);
  }
#line 2298
  goto switch_break;
  case_10: /* CIL Label */ 
  case_9: /* CIL Label */ 
  case_8: /* CIL Label */ 
  case_6: /* CIL Label */ 
  case_5: /* CIL Label */ 
  {
#line 2304
  msg = make_message("Decode not supported for this type");
  }
#line 2305
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 2307
  msg = make_message("Unknown ID Type");
  }
#line 2308
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 2311
  msg2 = msg;
#line 2312
  tmp___8 = id_to_name(idtype, id_map);
#line 2312
  msg = make_message("ID(Type=%s, %s)", tmp___8, msg2);
#line 2313
  free((void *)msg2);
  }
#line 2315
  return (msg);
}
}
#line 2334 "/home/june/repo/benchmarks/collector/temp/ike-scan-1.9/isakmp.c"
char *process_cert(unsigned char *cp , size_t len , unsigned int next ) 
{ 
  struct isakmp_generic *hdr ;
  char *msg ;
  unsigned char cert_type ;
  unsigned char *cert_data ;
  size_t data_len ;
  char *tmp ;
  uint16_t tmp___0 ;
  unsigned char *tmp___1 ;
  uint16_t tmp___3 ;
  uint16_t tmp___4 ;
  char const   *tmp___5 ;
  char const   *tmp___6 ;

  {
#line 2336
  hdr = (struct isakmp_generic *)cp;
#line 2342
  if (len < sizeof(struct isakmp_generic ) + 1UL) {
    {
#line 2344
    tmp = make_message("Certificate (packet too short to decode)");
    }
#line 2344
    return (tmp);
  } else {
    {
#line 2342
    tmp___0 = ntohs(hdr->isag_length);
    }
#line 2342
    if ((unsigned long )tmp___0 < sizeof(struct isakmp_generic ) + 1UL) {
      {
#line 2344
      tmp = make_message("Certificate (packet too short to decode)");
      }
#line 2344
      return (tmp);
    }
  }
  {
#line 2346
  cert_data = cp + sizeof(struct isakmp_generic );
#line 2347
  tmp___1 = cert_data;
#line 2347
  cert_data ++;
#line 2347
  cert_type = *tmp___1;
#line 2348
  tmp___4 = ntohs(hdr->isag_length);
  }
#line 2348
  if ((size_t )tmp___4 < len) {
    {
#line 2348
    tmp___3 = ntohs(hdr->isag_length);
#line 2348
    data_len = (size_t )tmp___3;
    }
  } else {
#line 2348
    data_len = len;
  }
  {
#line 2349
  data_len -= sizeof(struct isakmp_generic ) + 1UL;
#line 2351
  tmp___5 = id_to_name((unsigned int )cert_type, cert_map);
#line 2351
  tmp___6 = id_to_name(next, payload_map);
#line 2351
  msg = make_message("%s(Type=%s, Length=%u bytes)", tmp___6, tmp___5, data_len);
  }
#line 2355
  return (msg);
}
}
#line 2373 "/home/june/repo/benchmarks/collector/temp/ike-scan-1.9/isakmp.c"
char *process_delete(unsigned char *cp , size_t len ) 
{ 
  struct isakmp_delete *hdr ;
  char *msg ;
  char *hex_spi ;
  unsigned char *delete_spi ;
  size_t spi_len ;
  char *tmp ;
  uint16_t tmp___0 ;
  uint16_t tmp___2 ;
  uint16_t tmp___3 ;
  uint16_t tmp___4 ;

  {
#line 2375
  hdr = (struct isakmp_delete *)cp;
#line 2381
  if (len < sizeof(struct isakmp_delete )) {
    {
#line 2383
    tmp = make_message("Delete (packet too short to decode)");
    }
#line 2383
    return (tmp);
  } else {
    {
#line 2381
    tmp___0 = ntohs(hdr->isad_length);
    }
#line 2381
    if ((unsigned long )tmp___0 < sizeof(struct isakmp_delete )) {
      {
#line 2383
      tmp = make_message("Delete (packet too short to decode)");
      }
#line 2383
      return (tmp);
    }
  }
  {
#line 2385
  delete_spi = cp + sizeof(struct isakmp_delete );
#line 2386
  tmp___3 = ntohs(hdr->isad_length);
  }
#line 2386
  if ((size_t )tmp___3 < len) {
    {
#line 2386
    tmp___2 = ntohs(hdr->isad_length);
#line 2386
    spi_len = (size_t )tmp___2;
    }
  } else {
#line 2386
    spi_len = len;
  }
  {
#line 2387
  spi_len -= sizeof(struct isakmp_delete );
#line 2389
  hex_spi = hexstring((unsigned char const   *)delete_spi, spi_len);
#line 2390
  tmp___4 = ntohs(hdr->isad_nospi);
#line 2390
  msg = make_message("Delete=(SPI_Size=%u, SPI_Count=%u, SPI_Data=%s)", (int )hdr->isad_spisize,
                     (int )tmp___4, hex_spi);
#line 2392
  free((void *)hex_spi);
  }
#line 2394
  return (msg);
}
}
#line 2412 "/home/june/repo/benchmarks/collector/temp/ike-scan-1.9/isakmp.c"
char *process_generic(unsigned char *cp , size_t len , unsigned int next ) 
{ 
  struct isakmp_generic *hdr ;
  char *msg ;
  char const   *tmp ;
  uint16_t tmp___0 ;
  uint16_t tmp___1 ;
  char const   *tmp___2 ;

  {
#line 2414
  hdr = (struct isakmp_generic *)cp;
#line 2417
  if (len < sizeof(struct isakmp_generic )) {
    {
#line 2419
    tmp = id_to_name(next, payload_map);
#line 2419
    msg = make_message("%s (packet too short to decode)", tmp);
    }
#line 2421
    return (msg);
  } else {
    {
#line 2417
    tmp___0 = ntohs(hdr->isag_length);
    }
#line 2417
    if ((unsigned long )tmp___0 < sizeof(struct isakmp_generic )) {
      {
#line 2419
      tmp = id_to_name(next, payload_map);
#line 2419
      msg = make_message("%s (packet too short to decode)", tmp);
      }
#line 2421
      return (msg);
    }
  }
  {
#line 2424
  tmp___1 = ntohs(hdr->isag_length);
#line 2424
  tmp___2 = id_to_name(next, payload_map);
#line 2424
  msg = make_message("%s(%u bytes)", tmp___2, (unsigned long )tmp___1 - sizeof(struct isakmp_generic ));
  }
#line 2428
  return (msg);
}
}
#line 2451 "/home/june/repo/benchmarks/collector/temp/ike-scan-1.9/isakmp.c"
static unsigned char *isakmp_packet  =    (unsigned char *)((void *)0);
#line 2452 "/home/june/repo/benchmarks/collector/temp/ike-scan-1.9/isakmp.c"
static size_t offset  =    (size_t )0;
#line 2447 "/home/june/repo/benchmarks/collector/temp/ike-scan-1.9/isakmp.c"
unsigned char *add_isakmp_payload(unsigned char *payload , size_t payload_len , unsigned char **new_payload ) 
{ 
  unsigned char *payload_ptr ;
  void *tmp ;

  {
#line 2457
  if ((unsigned long )isakmp_packet == (unsigned long )((void *)0)) {
    {
#line 2458
    tmp = Malloc((size_t )65507);
#line 2458
    isakmp_packet = (unsigned char *)tmp;
    }
  }
  {
#line 2465
  payload_ptr = isakmp_packet + offset;
#line 2466
  memcpy((void */* __restrict  */)payload_ptr, (void const   */* __restrict  */)payload,
         payload_len);
#line 2467
  free((void *)payload);
#line 2473
  *new_payload = payload_ptr;
  }
#line 2474
  return (isakmp_packet);
}
}
#line 2493 "/home/june/repo/benchmarks/collector/temp/ike-scan-1.9/isakmp.c"
void print_payload(unsigned char *cp , unsigned int payload , int dir ) 
{ 
  struct isakmp_generic *hdr ;
  struct isakmp_hdr *ihdr ;
  char *hexdata ;
  unsigned char *data ;
  size_t data_len ;
  uint16_t tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 2495
  hdr = (struct isakmp_generic *)cp;
#line 2496
  ihdr = (struct isakmp_hdr *)cp;
#line 2501
  if (payload) {
    {
#line 2502
    data = cp + sizeof(struct isakmp_generic );
#line 2503
    tmp = ntohs(hdr->isag_length);
#line 2503
    data_len = (size_t )tmp;
#line 2504
    data_len -= sizeof(struct isakmp_generic );
#line 2505
    hexdata = hexstring((unsigned char const   *)data, data_len);
    }
    {
#line 2507
    if (payload == 1U) {
#line 2507
      goto case_1;
    }
#line 2510
    if (payload == 4U) {
#line 2510
      goto case_4;
    }
#line 2513
    if (payload == 5U) {
#line 2513
      goto case_5;
    }
#line 2516
    if (payload == 8U) {
#line 2516
      goto case_8;
    }
#line 2519
    if (payload == 10U) {
#line 2519
      goto case_10;
    }
#line 2522
    goto switch_default;
    case_1: /* CIL Label */ 
#line 2508
    if (dir == 73) {
#line 2508
      tmp___0 = 'i';
    } else {
#line 2508
      tmp___0 = 'r';
    }
    {
#line 2508
    printf((char const   */* __restrict  */)"sa%c_b_hex=\"%s\"\n", tmp___0, hexdata);
    }
#line 2509
    goto switch_break;
    case_4: /* CIL Label */ 
#line 2511
    if (dir == 73) {
#line 2511
      tmp___1 = 'i';
    } else {
#line 2511
      tmp___1 = 'r';
    }
    {
#line 2511
    printf((char const   */* __restrict  */)"g_x%c_hex=\"%s\"\n", tmp___1, hexdata);
    }
#line 2512
    goto switch_break;
    case_5: /* CIL Label */ 
#line 2514
    if (dir == 73) {
#line 2514
      tmp___2 = 'i';
    } else {
#line 2514
      tmp___2 = 'r';
    }
    {
#line 2514
    printf((char const   */* __restrict  */)"idi%c_b_hex=\"%s\"\n", tmp___2, hexdata);
    }
#line 2515
    goto switch_break;
    case_8: /* CIL Label */ 
#line 2517
    if (dir == 73) {
#line 2517
      tmp___3 = 'i';
    } else {
#line 2517
      tmp___3 = 'r';
    }
    {
#line 2517
    printf((char const   */* __restrict  */)"expected_hash_%c_hex=\"%s\"\n", tmp___3,
           hexdata);
    }
#line 2518
    goto switch_break;
    case_10: /* CIL Label */ 
#line 2520
    if (dir == 73) {
#line 2520
      tmp___4 = 'i';
    } else {
#line 2520
      tmp___4 = 'r';
    }
    {
#line 2520
    printf((char const   */* __restrict  */)"n%c_b_hex=\"%s\"\n", tmp___4, hexdata);
    }
#line 2521
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 2523
    printf((char const   */* __restrict  */)"UNKNOWN PAYLOAD TYPE: %d\n", payload);
    }
#line 2524
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
    {
#line 2526
    free((void *)hexdata);
    }
  } else {
    {
#line 2528
    hexdata = hexstring((unsigned char const   *)((unsigned char *)(ihdr->isa_icookie)),
                        (size_t )8);
#line 2529
    printf((char const   */* __restrict  */)"cky_i_hex=\"%s\"\n", hexdata);
#line 2530
    free((void *)hexdata);
#line 2531
    hexdata = hexstring((unsigned char const   *)((unsigned char *)(ihdr->isa_rcookie)),
                        (size_t )8);
#line 2532
    printf((char const   */* __restrict  */)"cky_r_hex=\"%s\"\n", hexdata);
#line 2533
    free((void *)hexdata);
    }
  }
#line 2535
  return;
}
}
#line 2553 "/home/june/repo/benchmarks/collector/temp/ike-scan-1.9/isakmp.c"
void add_psk_crack_payload(unsigned char *cp , unsigned int payload , int dir ) 
{ 
  struct isakmp_generic *hdr ;
  struct isakmp_hdr *ihdr ;
  unsigned char *data ;
  size_t data_len ;
  uint16_t tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;

  {
#line 2555
  hdr = (struct isakmp_generic *)cp;
#line 2556
  ihdr = (struct isakmp_hdr *)cp;
#line 2560
  if (payload) {
    {
#line 2561
    tmp = ntohs(hdr->isag_length);
#line 2561
    data_len = (unsigned long )tmp - sizeof(struct isakmp_generic );
#line 2562
    tmp___0 = Malloc(data_len);
#line 2562
    data = (unsigned char *)tmp___0;
#line 2563
    memcpy((void */* __restrict  */)data, (void const   */* __restrict  */)(cp + sizeof(struct isakmp_generic )),
           data_len);
    }
    {
#line 2566
    if (payload == 1U) {
#line 2566
      goto case_1;
    }
#line 2572
    if (payload == 4U) {
#line 2572
      goto case_4;
    }
#line 2581
    if (payload == 5U) {
#line 2581
      goto case_5;
    }
#line 2587
    if (payload == 8U) {
#line 2587
      goto case_8;
    }
#line 2593
    if (payload == 10U) {
#line 2593
      goto case_10;
    }
#line 2602
    goto switch_default;
    case_1: /* CIL Label */ 
#line 2567
    if (dir == 73) {
#line 2568
      psk_values.sai_b = data;
#line 2569
      psk_values.sai_b_len = data_len;
    }
#line 2571
    goto switch_break;
    case_4: /* CIL Label */ 
#line 2573
    if (dir == 73) {
#line 2574
      psk_values.g_xi = data;
#line 2575
      psk_values.g_xi_len = data_len;
    } else {
#line 2577
      psk_values.g_xr = data;
#line 2578
      psk_values.g_xr_len = data_len;
    }
#line 2580
    goto switch_break;
    case_5: /* CIL Label */ 
#line 2582
    if (dir == 82) {
#line 2583
      psk_values.idir_b = data;
#line 2584
      psk_values.idir_b_len = data_len;
    }
#line 2586
    goto switch_break;
    case_8: /* CIL Label */ 
#line 2588
    if (dir == 82) {
#line 2589
      psk_values.hash_r = data;
#line 2590
      psk_values.hash_r_len = data_len;
    }
#line 2592
    goto switch_break;
    case_10: /* CIL Label */ 
#line 2594
    if (dir == 73) {
#line 2595
      psk_values.ni_b = data;
#line 2596
      psk_values.ni_b_len = data_len;
    } else {
#line 2598
      psk_values.nr_b = data;
#line 2599
      psk_values.nr_b_len = data_len;
    }
#line 2601
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 2603
    warn_msg("add_psk_crack_payload: UNKNOWN PAYLOAD TYPE: %d\n", payload);
    }
#line 2605
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  } else {
    {
#line 2608
    data_len = (size_t )8;
#line 2609
    tmp___1 = Malloc(data_len);
#line 2609
    data = (unsigned char *)tmp___1;
#line 2610
    memcpy((void */* __restrict  */)data, (void const   */* __restrict  */)((unsigned char *)(ihdr->isa_rcookie)),
           (size_t )8);
#line 2611
    psk_values.cky_r = data;
#line 2612
    psk_values.cky_r_len = data_len;
#line 2614
    tmp___2 = Malloc(data_len);
#line 2614
    data = (unsigned char *)tmp___2;
#line 2615
    memcpy((void */* __restrict  */)data, (void const   */* __restrict  */)((unsigned char *)(ihdr->isa_icookie)),
           (size_t )8);
#line 2616
    psk_values.cky_i = data;
#line 2617
    psk_values.cky_i_len = data_len;
    }
  }
#line 2619
  return;
}
}
#line 2636 "/home/june/repo/benchmarks/collector/temp/ike-scan-1.9/isakmp.c"
void print_psk_crack_values(char const   *psk_crack_file ) 
{ 
  char *hexdata ;
  FILE *fp ;

  {
#line 2641
  if (*(psk_crack_file + 0)) {
    {
#line 2642
    fp = fopen((char const   */* __restrict  */)psk_crack_file, (char const   */* __restrict  */)"w");
    }
#line 2642
    if ((unsigned long )fp == (unsigned long )((void *)0)) {
      {
#line 2643
      err_sys("ERROR: fopen");
      }
    }
  } else {
    {
#line 2646
    fp = stdout;
#line 2647
    printf((char const   */* __restrict  */)"IKE PSK parameters (g_xr:g_xi:cky_r:cky_i:sai_b:idir_b:ni_b:nr_b:hash_r):\n");
    }
  }
  {
#line 2650
  hexdata = hexstring((unsigned char const   *)psk_values.g_xr, psk_values.g_xr_len);
#line 2651
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"%s:", hexdata);
#line 2652
  free((void *)hexdata);
#line 2653
  hexdata = hexstring((unsigned char const   *)psk_values.g_xi, psk_values.g_xi_len);
#line 2654
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"%s:", hexdata);
#line 2655
  free((void *)hexdata);
#line 2656
  hexdata = hexstring((unsigned char const   *)psk_values.cky_r, psk_values.cky_r_len);
#line 2657
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"%s:", hexdata);
#line 2658
  free((void *)hexdata);
#line 2659
  hexdata = hexstring((unsigned char const   *)psk_values.cky_i, psk_values.cky_i_len);
#line 2660
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"%s:", hexdata);
#line 2661
  free((void *)hexdata);
#line 2662
  hexdata = hexstring((unsigned char const   *)psk_values.sai_b, psk_values.sai_b_len);
#line 2663
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"%s:", hexdata);
#line 2664
  free((void *)hexdata);
#line 2665
  hexdata = hexstring((unsigned char const   *)psk_values.idir_b, psk_values.idir_b_len);
#line 2666
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"%s:", hexdata);
#line 2667
  free((void *)hexdata);
#line 2668
  hexdata = hexstring((unsigned char const   *)psk_values.ni_b, psk_values.ni_b_len);
#line 2669
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"%s:", hexdata);
#line 2670
  free((void *)hexdata);
#line 2671
  hexdata = hexstring((unsigned char const   *)psk_values.nr_b, psk_values.nr_b_len);
#line 2672
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"%s:", hexdata);
#line 2673
  free((void *)hexdata);
#line 2674
  hexdata = hexstring((unsigned char const   *)psk_values.hash_r, psk_values.hash_r_len);
#line 2675
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"%s\n", hexdata);
#line 2676
  free((void *)hexdata);
  }
#line 2677
  return;
}
}
#line 2699 "/home/june/repo/benchmarks/collector/temp/ike-scan-1.9/isakmp.c"
unsigned char *clone_payload(unsigned char const   *pkt_ptr , size_t bytes_left ) 
{ 
  struct isakmp_generic hdr ;
  unsigned char *clone_ptr ;
  size_t payload_len ;
  uint16_t tmp ;
  void *tmp___0 ;

  {
#line 2708
  if (bytes_left < sizeof(struct isakmp_generic )) {
#line 2709
    return ((unsigned char *)((void *)0));
  }
  {
#line 2716
  memcpy((void */* __restrict  */)(& hdr), (void const   */* __restrict  */)pkt_ptr,
         sizeof(hdr));
#line 2720
  tmp = ntohs(hdr.isag_length);
#line 2720
  payload_len = (size_t )tmp;
  }
#line 2721
  if (payload_len > bytes_left) {
#line 2722
    payload_len = bytes_left;
  }
  {
#line 2726
  tmp___0 = Malloc(payload_len);
#line 2726
  clone_ptr = (unsigned char *)tmp___0;
#line 2727
  memcpy((void */* __restrict  */)clone_ptr, (void const   */* __restrict  */)pkt_ptr,
         payload_len);
  }
#line 2729
  return (clone_ptr);
}
}
#line 2732 "/home/june/repo/benchmarks/collector/temp/ike-scan-1.9/isakmp.c"
void isakmp_use_rcsid(void) 
{ 


  {
  {
#line 2734
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s\n",
          rcsid);
  }
#line 2735
  return;
}
}
/* compiler builtin: 
   void __builtin_va_start(__builtin_va_list  ) ;  */
/* compiler builtin: 
   void __builtin_va_end(__builtin_va_list  ) ;  */
#line 242 "/usr/include/stdio.h"
extern int fflush(FILE *__stream ) ;
#line 386
extern  __attribute__((__nothrow__)) int ( /* format attribute */  snprintf)(char * __restrict  __s ,
                                                                             size_t __maxlen ,
                                                                             char const   * __restrict  __format 
                                                                             , ...) ;
#line 390
extern  __attribute__((__nothrow__)) int ( /* format attribute */  vsnprintf)(char * __restrict  __s ,
                                                                              size_t __maxlen ,
                                                                              char const   * __restrict  __format ,
                                                                              __gnuc_va_list __arg ) ;
#line 689
extern int fputs(char const   * __restrict  __s , FILE * __restrict  __stream ) ;
#line 137 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcat)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 399
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 413
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) strerror)(int __errnum ) ;
#line 543 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 50 "/usr/include/x86_64-linux-gnu/bits/errno.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
#line 190 "/usr/include/x86_64-linux-gnu/sys/syslog.h"
extern void ( /* format attribute */  syslog)(int __pri , char const   *__fmt  , ...) ;
#line 335 "/home/june/repo/benchmarks/collector/temp/ike-scan-1.9/ike-scan.h"
void warn_sys(char const   *fmt  , ...) ;
#line 338
void info_syslog(char const   *fmt  , ...) ;
#line 339
void err_print(int errnoflag , int level , char const   *fmt , va_list ap ) ;
#line 459
void error_use_rcsid(void) ;
#line 47 "/home/june/repo/benchmarks/collector/temp/ike-scan-1.9/error.c"
static char rcsid___0[45]  = 
#line 47 "/home/june/repo/benchmarks/collector/temp/ike-scan-1.9/error.c"
  {      (char )'$',      (char )'I',      (char )'d',      (char )':', 
        (char )' ',      (char )'e',      (char )'r',      (char )'r', 
        (char )'o',      (char )'r',      (char )'.',      (char )'c', 
        (char )' ',      (char )'9',      (char )'8',      (char )'8', 
        (char )'4',      (char )' ',      (char )'2',      (char )'0', 
        (char )'0',      (char )'7',      (char )'-',      (char )'0', 
        (char )'1',      (char )'-',      (char )'1',      (char )'4', 
        (char )' ',      (char )'1',      (char )'9',      (char )':', 
        (char )'0',      (char )'5',      (char )':',      (char )'3', 
        (char )'9',      (char )'Z',      (char )' ',      (char )'r', 
        (char )'s',      (char )'h',      (char )' ',      (char )'$', 
        (char )'\000'};
#line 49 "/home/june/repo/benchmarks/collector/temp/ike-scan-1.9/error.c"
int daemon_proc  ;
#line 54 "/home/june/repo/benchmarks/collector/temp/ike-scan-1.9/error.c"
void err_sys(char const   *fmt  , ...) 
{ 
  va_list ap ;

  {
  {
#line 58
  __builtin_va_start(ap, fmt);
#line 59
  err_print(1, 0, fmt, ap);
#line 60
  __builtin_va_end(ap);
#line 61
  exit(1);
  }
}
}
#line 67 "/home/june/repo/benchmarks/collector/temp/ike-scan-1.9/error.c"
void warn_sys(char const   *fmt  , ...) 
{ 
  va_list ap ;

  {
  {
#line 71
  __builtin_va_start(ap, fmt);
#line 72
  err_print(1, 0, fmt, ap);
#line 73
  __builtin_va_end(ap);
  }
#line 74
  return;
}
}
#line 79 "/home/june/repo/benchmarks/collector/temp/ike-scan-1.9/error.c"
void err_msg(char const   *fmt  , ...) 
{ 
  va_list ap ;

  {
  {
#line 83
  __builtin_va_start(ap, fmt);
#line 84
  err_print(0, 0, fmt, ap);
#line 85
  __builtin_va_end(ap);
#line 86
  exit(1);
  }
}
}
#line 92 "/home/june/repo/benchmarks/collector/temp/ike-scan-1.9/error.c"
void warn_msg(char const   *fmt  , ...) 
{ 
  va_list ap ;

  {
  {
#line 96
  __builtin_va_start(ap, fmt);
#line 97
  err_print(0, 0, fmt, ap);
#line 98
  __builtin_va_end(ap);
  }
#line 99
  return;
}
}
#line 104 "/home/june/repo/benchmarks/collector/temp/ike-scan-1.9/error.c"
void info_syslog(char const   *fmt  , ...) 
{ 
  va_list ap ;

  {
  {
#line 108
  __builtin_va_start(ap, fmt);
#line 109
  err_print(0, 6, fmt, ap);
#line 110
  __builtin_va_end(ap);
  }
#line 111
  return;
}
}
#line 117 "/home/june/repo/benchmarks/collector/temp/ike-scan-1.9/error.c"
void err_print(int errnoflag , int level , char const   *fmt , va_list ap ) 
{ 
  int errno_save ;
  size_t n ;
  char buf___1[255] ;
  int *tmp ;
  char *tmp___0 ;

  {
  {
#line 123
  tmp = __errno_location();
#line 123
  errno_save = *tmp;
#line 125
  vsnprintf((char */* __restrict  */)(buf___1), (size_t )255, (char const   */* __restrict  */)fmt,
            ap);
#line 126
  n = strlen((char const   *)(buf___1));
  }
#line 127
  if (errnoflag) {
    {
#line 128
    tmp___0 = strerror(errno_save);
#line 128
    snprintf((char */* __restrict  */)(buf___1 + n), 255UL - n, (char const   */* __restrict  */)": %s",
             tmp___0);
    }
  }
  {
#line 129
  strcat((char */* __restrict  */)(buf___1), (char const   */* __restrict  */)"\n");
  }
#line 131
  if (level != 0) {
    {
#line 132
    syslog(level, "%s", buf___1);
    }
  } else {
    {
#line 134
    fflush(stdout);
#line 135
    fputs((char const   */* __restrict  */)(buf___1), (FILE */* __restrict  */)stderr);
#line 136
    fflush(stderr);
    }
  }
#line 138
  return;
}
}
#line 140 "/home/june/repo/benchmarks/collector/temp/ike-scan-1.9/error.c"
void error_use_rcsid(void) 
{ 


  {
  {
#line 142
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s\n",
          rcsid___0);
  }
#line 143
  return;
}
}
#line 53 "/home/june/repo/benchmarks/collector/temp/ike-scan-1.9/mt19937ar.c"
static unsigned long mt[624]  ;
#line 54 "/home/june/repo/benchmarks/collector/temp/ike-scan-1.9/mt19937ar.c"
static int mti  =    625;
#line 57 "/home/june/repo/benchmarks/collector/temp/ike-scan-1.9/mt19937ar.c"
void init_genrand(unsigned long s ) 
{ 


  {
#line 59
  mt[0] = s & 4294967295UL;
#line 60
  mti = 1;
  {
#line 60
  while (1) {
    while_continue: /* CIL Label */ ;
#line 60
    if (! (mti < 624)) {
#line 60
      goto while_break;
    }
#line 61
    mt[mti] = 1812433253UL * (mt[mti - 1] ^ (mt[mti - 1] >> 30)) + (unsigned long )mti;
#line 67
    mt[mti] &= 4294967295UL;
#line 60
    mti ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 70
  return;
}
}
#line 76 "/home/june/repo/benchmarks/collector/temp/ike-scan-1.9/mt19937ar.c"
void init_by_array(unsigned long *init_key , int key_length ) 
{ 
  int i ;
  int j ;
  int k ;

  {
  {
#line 79
  init_genrand(19650218UL);
#line 80
  i = 1;
#line 80
  j = 0;
  }
#line 81
  if (624 > key_length) {
#line 81
    k = 624;
  } else {
#line 81
    k = key_length;
  }
  {
#line 82
  while (1) {
    while_continue: /* CIL Label */ ;
#line 82
    if (! k) {
#line 82
      goto while_break;
    }
#line 83
    mt[i] = ((mt[i] ^ (mt[i - 1] ^ (mt[i - 1] >> 30)) * 1664525UL) + *(init_key + j)) + (unsigned long )j;
#line 85
    mt[i] &= 4294967295UL;
#line 86
    i ++;
#line 86
    j ++;
#line 87
    if (i >= 624) {
#line 87
      mt[0] = mt[623];
#line 87
      i = 1;
    }
#line 88
    if (j >= key_length) {
#line 88
      j = 0;
    }
#line 82
    k --;
  }
  while_break: /* CIL Label */ ;
  }
#line 90
  k = 623;
  {
#line 90
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 90
    if (! k) {
#line 90
      goto while_break___0;
    }
#line 91
    mt[i] = (mt[i] ^ (mt[i - 1] ^ (mt[i - 1] >> 30)) * 1566083941UL) - (unsigned long )i;
#line 93
    mt[i] &= 4294967295UL;
#line 94
    i ++;
#line 95
    if (i >= 624) {
#line 95
      mt[0] = mt[623];
#line 95
      i = 1;
    }
#line 90
    k --;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 98
  mt[0] = 2147483648UL;
#line 99
  return;
}
}
#line 105
unsigned long genrand_int32(void) ;
#line 105 "/home/june/repo/benchmarks/collector/temp/ike-scan-1.9/mt19937ar.c"
static unsigned long mag01[2]  = {      0UL,      2567483615UL};
#line 102 "/home/june/repo/benchmarks/collector/temp/ike-scan-1.9/mt19937ar.c"
unsigned long genrand_int32(void) 
{ 
  unsigned long y ;
  int kk ;
  int tmp ;

  {
#line 108
  if (mti >= 624) {
#line 111
    if (mti == 625) {
      {
#line 112
      init_genrand(5489UL);
      }
    }
#line 114
    kk = 0;
    {
#line 114
    while (1) {
      while_continue: /* CIL Label */ ;
#line 114
      if (! (kk < 227)) {
#line 114
        goto while_break;
      }
#line 115
      y = (mt[kk] & 2147483648UL) | (mt[kk + 1] & 2147483647UL);
#line 116
      mt[kk] = (mt[kk + 397] ^ (y >> 1)) ^ mag01[y & 1UL];
#line 114
      kk ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 118
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 118
      if (! (kk < 623)) {
#line 118
        goto while_break___0;
      }
#line 119
      y = (mt[kk] & 2147483648UL) | (mt[kk + 1] & 2147483647UL);
#line 120
      mt[kk] = (mt[kk + -227] ^ (y >> 1)) ^ mag01[y & 1UL];
#line 118
      kk ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 122
    y = (mt[623] & 2147483648UL) | (mt[0] & 2147483647UL);
#line 123
    mt[623] = (mt[396] ^ (y >> 1)) ^ mag01[y & 1UL];
#line 125
    mti = 0;
  }
#line 128
  tmp = mti;
#line 128
  mti ++;
#line 128
  y = mt[tmp];
#line 131
  y ^= y >> 11;
#line 132
  y ^= (y << 7) & 2636928640UL;
#line 133
  y ^= (y << 15) & 4022730752UL;
#line 134
  y ^= y >> 18;
#line 136
  return (y);
}
}
#line 140 "/home/june/repo/benchmarks/collector/temp/ike-scan-1.9/mt19937ar.c"
long genrand_int31(void) 
{ 
  unsigned long tmp ;

  {
  {
#line 142
  tmp = genrand_int32();
  }
#line 142
  return ((long )(tmp >> 1));
}
}
#line 146 "/home/june/repo/benchmarks/collector/temp/ike-scan-1.9/mt19937ar.c"
double genrand_real1(void) 
{ 
  unsigned long tmp ;

  {
  {
#line 148
  tmp = genrand_int32();
  }
#line 148
  return ((double )tmp * (1.0 / 4294967295.0));
}
}
#line 153 "/home/june/repo/benchmarks/collector/temp/ike-scan-1.9/mt19937ar.c"
double genrand_real2(void) 
{ 
  unsigned long tmp ;

  {
  {
#line 155
  tmp = genrand_int32();
  }
#line 155
  return ((double )tmp * (1.0 / 4294967296.0));
}
}
#line 160 "/home/june/repo/benchmarks/collector/temp/ike-scan-1.9/mt19937ar.c"
double genrand_real3(void) 
{ 
  unsigned long tmp ;

  {
  {
#line 162
  tmp = genrand_int32();
  }
#line 162
  return (((double )tmp + 0.5) * (1.0 / 4294967296.0));
}
}
#line 167 "/home/june/repo/benchmarks/collector/temp/ike-scan-1.9/mt19937ar.c"
double genrand_res53(void) 
{ 
  unsigned long a ;
  unsigned long tmp ;
  unsigned long b ;
  unsigned long tmp___0 ;

  {
  {
#line 169
  tmp = genrand_int32();
#line 169
  a = tmp >> 5;
#line 169
  tmp___0 = genrand_int32();
#line 169
  b = tmp___0 >> 6;
  }
#line 170
  return (((double )a * 67108864.0 + (double )b) * (1.0 / 9007199254740992.0));
}
}
#line 91 "/home/june/repo/benchmarks/collector/temp/ike-scan-1.9/md5.h"
void md5_init(md5_state_t *pms ) ;
#line 94
void md5_append(md5_state_t *pms , md5_byte_t const   *data , int nbytes ) ;
#line 97
void md5_finish(md5_state_t *pms , md5_byte_t *digest ) ;
#line 131 "/home/june/repo/benchmarks/collector/temp/ike-scan-1.9/md5.c"
static void md5_process(md5_state_t *pms , md5_byte_t const   *data ) 
{ 
  md5_word_t a ;
  md5_word_t b ;
  md5_word_t c ;
  md5_word_t d ;
  md5_word_t t ;
  md5_word_t xbuf[16] ;
  md5_word_t const   *X ;

  {
#line 134
  a = pms->abcd[0];
#line 134
  b = pms->abcd[1];
#line 134
  c = pms->abcd[2];
#line 134
  d = pms->abcd[3];
#line 164
  if (! ((data - (md5_byte_t const   *)0) & 3L)) {
#line 166
    X = (md5_word_t const   *)data;
  } else {
    {
#line 169
    memcpy((void */* __restrict  */)(xbuf), (void const   */* __restrict  */)data,
           (size_t )64);
#line 170
    X = (md5_word_t const   *)(xbuf);
    }
  }
#line 207
  t = ((a + ((b & c) | (~ b & d))) + (md5_word_t )*(X + 0)) + 3614090360U;
#line 207
  a = ((t << 7) | (t >> 25)) + b;
#line 208
  t = ((d + ((a & b) | (~ a & c))) + (md5_word_t )*(X + 1)) + 3905402710U;
#line 208
  d = ((t << 12) | (t >> 20)) + a;
#line 209
  t = ((c + ((d & a) | (~ d & b))) + (md5_word_t )*(X + 2)) + 606105819U;
#line 209
  c = ((t << 17) | (t >> 15)) + d;
#line 210
  t = ((b + ((c & d) | (~ c & a))) + (md5_word_t )*(X + 3)) + 3250441966U;
#line 210
  b = ((t << 22) | (t >> 10)) + c;
#line 211
  t = ((a + ((b & c) | (~ b & d))) + (md5_word_t )*(X + 4)) + 4118548399U;
#line 211
  a = ((t << 7) | (t >> 25)) + b;
#line 212
  t = ((d + ((a & b) | (~ a & c))) + (md5_word_t )*(X + 5)) + 1200080426U;
#line 212
  d = ((t << 12) | (t >> 20)) + a;
#line 213
  t = ((c + ((d & a) | (~ d & b))) + (md5_word_t )*(X + 6)) + 2821735955U;
#line 213
  c = ((t << 17) | (t >> 15)) + d;
#line 214
  t = ((b + ((c & d) | (~ c & a))) + (md5_word_t )*(X + 7)) + 4249261313U;
#line 214
  b = ((t << 22) | (t >> 10)) + c;
#line 215
  t = ((a + ((b & c) | (~ b & d))) + (md5_word_t )*(X + 8)) + 1770035416U;
#line 215
  a = ((t << 7) | (t >> 25)) + b;
#line 216
  t = ((d + ((a & b) | (~ a & c))) + (md5_word_t )*(X + 9)) + 2336552879U;
#line 216
  d = ((t << 12) | (t >> 20)) + a;
#line 217
  t = ((c + ((d & a) | (~ d & b))) + (md5_word_t )*(X + 10)) + 4294925233U;
#line 217
  c = ((t << 17) | (t >> 15)) + d;
#line 218
  t = ((b + ((c & d) | (~ c & a))) + (md5_word_t )*(X + 11)) + 2304563134U;
#line 218
  b = ((t << 22) | (t >> 10)) + c;
#line 219
  t = ((a + ((b & c) | (~ b & d))) + (md5_word_t )*(X + 12)) + 1804603682U;
#line 219
  a = ((t << 7) | (t >> 25)) + b;
#line 220
  t = ((d + ((a & b) | (~ a & c))) + (md5_word_t )*(X + 13)) + 4254626195U;
#line 220
  d = ((t << 12) | (t >> 20)) + a;
#line 221
  t = ((c + ((d & a) | (~ d & b))) + (md5_word_t )*(X + 14)) + 2792965006U;
#line 221
  c = ((t << 17) | (t >> 15)) + d;
#line 222
  t = ((b + ((c & d) | (~ c & a))) + (md5_word_t )*(X + 15)) + 1236535329U;
#line 222
  b = ((t << 22) | (t >> 10)) + c;
#line 233
  t = ((a + ((b & d) | (c & ~ d))) + (md5_word_t )*(X + 1)) + 4129170786U;
#line 233
  a = ((t << 5) | (t >> 27)) + b;
#line 234
  t = ((d + ((a & c) | (b & ~ c))) + (md5_word_t )*(X + 6)) + 3225465664U;
#line 234
  d = ((t << 9) | (t >> 23)) + a;
#line 235
  t = ((c + ((d & b) | (a & ~ b))) + (md5_word_t )*(X + 11)) + 643717713U;
#line 235
  c = ((t << 14) | (t >> 18)) + d;
#line 236
  t = ((b + ((c & a) | (d & ~ a))) + (md5_word_t )*(X + 0)) + 3921069994U;
#line 236
  b = ((t << 20) | (t >> 12)) + c;
#line 237
  t = ((a + ((b & d) | (c & ~ d))) + (md5_word_t )*(X + 5)) + 3593408605U;
#line 237
  a = ((t << 5) | (t >> 27)) + b;
#line 238
  t = ((d + ((a & c) | (b & ~ c))) + (md5_word_t )*(X + 10)) + 38016083U;
#line 238
  d = ((t << 9) | (t >> 23)) + a;
#line 239
  t = ((c + ((d & b) | (a & ~ b))) + (md5_word_t )*(X + 15)) + 3634488961U;
#line 239
  c = ((t << 14) | (t >> 18)) + d;
#line 240
  t = ((b + ((c & a) | (d & ~ a))) + (md5_word_t )*(X + 4)) + 3889429448U;
#line 240
  b = ((t << 20) | (t >> 12)) + c;
#line 241
  t = ((a + ((b & d) | (c & ~ d))) + (md5_word_t )*(X + 9)) + 568446438U;
#line 241
  a = ((t << 5) | (t >> 27)) + b;
#line 242
  t = ((d + ((a & c) | (b & ~ c))) + (md5_word_t )*(X + 14)) + 3275163606U;
#line 242
  d = ((t << 9) | (t >> 23)) + a;
#line 243
  t = ((c + ((d & b) | (a & ~ b))) + (md5_word_t )*(X + 3)) + 4107603335U;
#line 243
  c = ((t << 14) | (t >> 18)) + d;
#line 244
  t = ((b + ((c & a) | (d & ~ a))) + (md5_word_t )*(X + 8)) + 1163531501U;
#line 244
  b = ((t << 20) | (t >> 12)) + c;
#line 245
  t = ((a + ((b & d) | (c & ~ d))) + (md5_word_t )*(X + 13)) + 2850285829U;
#line 245
  a = ((t << 5) | (t >> 27)) + b;
#line 246
  t = ((d + ((a & c) | (b & ~ c))) + (md5_word_t )*(X + 2)) + 4243563512U;
#line 246
  d = ((t << 9) | (t >> 23)) + a;
#line 247
  t = ((c + ((d & b) | (a & ~ b))) + (md5_word_t )*(X + 7)) + 1735328473U;
#line 247
  c = ((t << 14) | (t >> 18)) + d;
#line 248
  t = ((b + ((c & a) | (d & ~ a))) + (md5_word_t )*(X + 12)) + 2368359562U;
#line 248
  b = ((t << 20) | (t >> 12)) + c;
#line 259
  t = ((a + ((b ^ c) ^ d)) + (md5_word_t )*(X + 5)) + 4294588738U;
#line 259
  a = ((t << 4) | (t >> 28)) + b;
#line 260
  t = ((d + ((a ^ b) ^ c)) + (md5_word_t )*(X + 8)) + 2272392833U;
#line 260
  d = ((t << 11) | (t >> 21)) + a;
#line 261
  t = ((c + ((d ^ a) ^ b)) + (md5_word_t )*(X + 11)) + 1839030562U;
#line 261
  c = ((t << 16) | (t >> 16)) + d;
#line 262
  t = ((b + ((c ^ d) ^ a)) + (md5_word_t )*(X + 14)) + 4259657740U;
#line 262
  b = ((t << 23) | (t >> 9)) + c;
#line 263
  t = ((a + ((b ^ c) ^ d)) + (md5_word_t )*(X + 1)) + 2763975236U;
#line 263
  a = ((t << 4) | (t >> 28)) + b;
#line 264
  t = ((d + ((a ^ b) ^ c)) + (md5_word_t )*(X + 4)) + 1272893353U;
#line 264
  d = ((t << 11) | (t >> 21)) + a;
#line 265
  t = ((c + ((d ^ a) ^ b)) + (md5_word_t )*(X + 7)) + 4139469664U;
#line 265
  c = ((t << 16) | (t >> 16)) + d;
#line 266
  t = ((b + ((c ^ d) ^ a)) + (md5_word_t )*(X + 10)) + 3200236656U;
#line 266
  b = ((t << 23) | (t >> 9)) + c;
#line 267
  t = ((a + ((b ^ c) ^ d)) + (md5_word_t )*(X + 13)) + 681279174U;
#line 267
  a = ((t << 4) | (t >> 28)) + b;
#line 268
  t = ((d + ((a ^ b) ^ c)) + (md5_word_t )*(X + 0)) + 3936430074U;
#line 268
  d = ((t << 11) | (t >> 21)) + a;
#line 269
  t = ((c + ((d ^ a) ^ b)) + (md5_word_t )*(X + 3)) + 3572445317U;
#line 269
  c = ((t << 16) | (t >> 16)) + d;
#line 270
  t = ((b + ((c ^ d) ^ a)) + (md5_word_t )*(X + 6)) + 76029189U;
#line 270
  b = ((t << 23) | (t >> 9)) + c;
#line 271
  t = ((a + ((b ^ c) ^ d)) + (md5_word_t )*(X + 9)) + 3654602809U;
#line 271
  a = ((t << 4) | (t >> 28)) + b;
#line 272
  t = ((d + ((a ^ b) ^ c)) + (md5_word_t )*(X + 12)) + 3873151461U;
#line 272
  d = ((t << 11) | (t >> 21)) + a;
#line 273
  t = ((c + ((d ^ a) ^ b)) + (md5_word_t )*(X + 15)) + 530742520U;
#line 273
  c = ((t << 16) | (t >> 16)) + d;
#line 274
  t = ((b + ((c ^ d) ^ a)) + (md5_word_t )*(X + 2)) + 3299628645U;
#line 274
  b = ((t << 23) | (t >> 9)) + c;
#line 285
  t = ((a + (c ^ (b | ~ d))) + (md5_word_t )*(X + 0)) + 4096336452U;
#line 285
  a = ((t << 6) | (t >> 26)) + b;
#line 286
  t = ((d + (b ^ (a | ~ c))) + (md5_word_t )*(X + 7)) + 1126891415U;
#line 286
  d = ((t << 10) | (t >> 22)) + a;
#line 287
  t = ((c + (a ^ (d | ~ b))) + (md5_word_t )*(X + 14)) + 2878612391U;
#line 287
  c = ((t << 15) | (t >> 17)) + d;
#line 288
  t = ((b + (d ^ (c | ~ a))) + (md5_word_t )*(X + 5)) + 4237533241U;
#line 288
  b = ((t << 21) | (t >> 11)) + c;
#line 289
  t = ((a + (c ^ (b | ~ d))) + (md5_word_t )*(X + 12)) + 1700485571U;
#line 289
  a = ((t << 6) | (t >> 26)) + b;
#line 290
  t = ((d + (b ^ (a | ~ c))) + (md5_word_t )*(X + 3)) + 2399980690U;
#line 290
  d = ((t << 10) | (t >> 22)) + a;
#line 291
  t = ((c + (a ^ (d | ~ b))) + (md5_word_t )*(X + 10)) + 4293915773U;
#line 291
  c = ((t << 15) | (t >> 17)) + d;
#line 292
  t = ((b + (d ^ (c | ~ a))) + (md5_word_t )*(X + 1)) + 2240044497U;
#line 292
  b = ((t << 21) | (t >> 11)) + c;
#line 293
  t = ((a + (c ^ (b | ~ d))) + (md5_word_t )*(X + 8)) + 1873313359U;
#line 293
  a = ((t << 6) | (t >> 26)) + b;
#line 294
  t = ((d + (b ^ (a | ~ c))) + (md5_word_t )*(X + 15)) + 4264355552U;
#line 294
  d = ((t << 10) | (t >> 22)) + a;
#line 295
  t = ((c + (a ^ (d | ~ b))) + (md5_word_t )*(X + 6)) + 2734768916U;
#line 295
  c = ((t << 15) | (t >> 17)) + d;
#line 296
  t = ((b + (d ^ (c | ~ a))) + (md5_word_t )*(X + 13)) + 1309151649U;
#line 296
  b = ((t << 21) | (t >> 11)) + c;
#line 297
  t = ((a + (c ^ (b | ~ d))) + (md5_word_t )*(X + 4)) + 4149444226U;
#line 297
  a = ((t << 6) | (t >> 26)) + b;
#line 298
  t = ((d + (b ^ (a | ~ c))) + (md5_word_t )*(X + 11)) + 3174756917U;
#line 298
  d = ((t << 10) | (t >> 22)) + a;
#line 299
  t = ((c + (a ^ (d | ~ b))) + (md5_word_t )*(X + 2)) + 718787259U;
#line 299
  c = ((t << 15) | (t >> 17)) + d;
#line 300
  t = ((b + (d ^ (c | ~ a))) + (md5_word_t )*(X + 9)) + 3951481745U;
#line 300
  b = ((t << 21) | (t >> 11)) + c;
#line 306
  pms->abcd[0] += a;
#line 307
  pms->abcd[1] += b;
#line 308
  pms->abcd[2] += c;
#line 309
  pms->abcd[3] += d;
#line 310
  return;
}
}
#line 312 "/home/june/repo/benchmarks/collector/temp/ike-scan-1.9/md5.c"
void md5_init(md5_state_t *pms ) 
{ 
  md5_word_t tmp ;

  {
#line 315
  tmp = (md5_word_t )0;
#line 315
  pms->count[1] = tmp;
#line 315
  pms->count[0] = tmp;
#line 316
  pms->abcd[0] = (md5_word_t )1732584193;
#line 317
  pms->abcd[1] = 4023233417U;
#line 318
  pms->abcd[2] = 2562383102U;
#line 319
  pms->abcd[3] = (md5_word_t )271733878;
#line 320
  return;
}
}
#line 322 "/home/june/repo/benchmarks/collector/temp/ike-scan-1.9/md5.c"
void md5_append(md5_state_t *pms , md5_byte_t const   *data , int nbytes ) 
{ 
  md5_byte_t const   *p ;
  int left ;
  int offset___0 ;
  md5_word_t nbits ;
  int copy ;
  int tmp ;

  {
#line 325
  p = data;
#line 326
  left = nbytes;
#line 327
  offset___0 = (int )((pms->count[0] >> 3) & 63U);
#line 328
  nbits = (md5_word_t )(nbytes << 3);
#line 330
  if (nbytes <= 0) {
#line 331
    return;
  }
#line 334
  pms->count[1] += (md5_word_t )(nbytes >> 29);
#line 335
  pms->count[0] += nbits;
#line 336
  if (pms->count[0] < nbits) {
#line 337
    (pms->count[1]) ++;
  }
#line 340
  if (offset___0) {
#line 341
    if (offset___0 + nbytes > 64) {
#line 341
      tmp = 64 - offset___0;
    } else {
#line 341
      tmp = nbytes;
    }
    {
#line 341
    copy = tmp;
#line 343
    memcpy((void */* __restrict  */)(pms->buf + offset___0), (void const   */* __restrict  */)p,
           (size_t )copy);
    }
#line 344
    if (offset___0 + copy < 64) {
#line 345
      return;
    }
    {
#line 346
    p += copy;
#line 347
    left -= copy;
#line 348
    md5_process(pms, (md5_byte_t const   *)(pms->buf));
    }
  }
  {
#line 352
  while (1) {
    while_continue: /* CIL Label */ ;
#line 352
    if (! (left >= 64)) {
#line 352
      goto while_break;
    }
    {
#line 353
    md5_process(pms, p);
#line 352
    p += 64;
#line 352
    left -= 64;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 356
  if (left) {
    {
#line 357
    memcpy((void */* __restrict  */)(pms->buf), (void const   */* __restrict  */)p,
           (size_t )left);
    }
  }
#line 358
  return;
}
}
#line 363 "/home/june/repo/benchmarks/collector/temp/ike-scan-1.9/md5.c"
static md5_byte_t const   pad[64]  = 
#line 363
  {      (md5_byte_t const   )128,      (md5_byte_t const   )0,      (md5_byte_t const   )0,      (md5_byte_t const   )0, 
        (md5_byte_t const   )0,      (md5_byte_t const   )0,      (md5_byte_t const   )0,      (md5_byte_t const   )0, 
        (md5_byte_t const   )0,      (md5_byte_t const   )0,      (md5_byte_t const   )0,      (md5_byte_t const   )0, 
        (md5_byte_t const   )0,      (md5_byte_t const   )0,      (md5_byte_t const   )0,      (md5_byte_t const   )0, 
        (md5_byte_t const   )0,      (md5_byte_t const   )0,      (md5_byte_t const   )0,      (md5_byte_t const   )0, 
        (md5_byte_t const   )0,      (md5_byte_t const   )0,      (md5_byte_t const   )0,      (md5_byte_t const   )0, 
        (md5_byte_t const   )0,      (md5_byte_t const   )0,      (md5_byte_t const   )0,      (md5_byte_t const   )0, 
        (md5_byte_t const   )0,      (md5_byte_t const   )0,      (md5_byte_t const   )0,      (md5_byte_t const   )0, 
        (md5_byte_t const   )0,      (md5_byte_t const   )0,      (md5_byte_t const   )0,      (md5_byte_t const   )0, 
        (md5_byte_t const   )0,      (md5_byte_t const   )0,      (md5_byte_t const   )0,      (md5_byte_t const   )0, 
        (md5_byte_t const   )0,      (md5_byte_t const   )0,      (md5_byte_t const   )0,      (md5_byte_t const   )0, 
        (md5_byte_t const   )0,      (md5_byte_t const   )0,      (md5_byte_t const   )0,      (md5_byte_t const   )0, 
        (md5_byte_t const   )0,      (md5_byte_t const   )0,      (md5_byte_t const   )0,      (md5_byte_t const   )0, 
        (md5_byte_t const   )0,      (md5_byte_t const   )0,      (md5_byte_t const   )0,      (md5_byte_t const   )0, 
        (md5_byte_t const   )0,      (md5_byte_t const   )0,      (md5_byte_t const   )0,      (md5_byte_t const   )0, 
        (md5_byte_t const   )0,      (md5_byte_t const   )0,      (md5_byte_t const   )0,      (md5_byte_t const   )0};
#line 360 "/home/june/repo/benchmarks/collector/temp/ike-scan-1.9/md5.c"
void md5_finish(md5_state_t *pms , md5_byte_t *digest ) 
{ 
  md5_byte_t data[8] ;
  int i ;

  {
#line 373
  i = 0;
  {
#line 373
  while (1) {
    while_continue: /* CIL Label */ ;
#line 373
    if (! (i < 8)) {
#line 373
      goto while_break;
    }
#line 374
    data[i] = (md5_byte_t )(pms->count[i >> 2] >> ((i & 3) << 3));
#line 373
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 376
  md5_append(pms, pad, (int )(((55U - (pms->count[0] >> 3)) & 63U) + 1U));
#line 378
  md5_append(pms, (md5_byte_t const   *)(data), 8);
#line 379
  i = 0;
  }
  {
#line 379
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 379
    if (! (i < 16)) {
#line 379
      goto while_break___0;
    }
#line 380
    *(digest + i) = (md5_byte_t )(pms->abcd[i >> 2] >> ((i & 3) << 3));
#line 379
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 381
  return;
}
}
#line 364 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
#line 187 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) unsigned long ( __attribute__((__nonnull__(1),
__leaf__)) strtoul)(char const   * __restrict  __nptr , char ** __restrict  __endptr ,
                    int __base ) ;
#line 775
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) abs)(int __x )  __attribute__((__const__)) ;
#line 79 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) unsigned short const   **( __attribute__((__leaf__)) __ctype_b_loc)(void)  __attribute__((__const__)) ;
#line 124
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) tolower)(int __c ) ;
#line 349 "/home/june/repo/benchmarks/collector/temp/ike-scan-1.9/ike-scan.h"
void timeval_diff(struct timeval  const  *a , struct timeval  const  *b , struct timeval *diff ) ;
#line 366
int times_close_enough(struct timeval *t1 , struct timeval *t2 , unsigned int fuzz ) ;
#line 369
unsigned int hstr_i(char const   *cptr ) ;
#line 370
unsigned char *hex2data(char const   *string , size_t *data_len ) ;
#line 371
unsigned char *hex_or_str(char const   *string , size_t *data_len ) ;
#line 372
unsigned char *hex_or_num(char const   *string , size_t *data_len ) ;
#line 402
int Gettimeofday(struct timeval *tv ) ;
#line 405
unsigned long Strtoul(char const   *nptr , int base ) ;
#line 437
char *numstr(unsigned int num ) ;
#line 440
void print_times(void) ;
#line 441
void sig_alarm(int signo ) ;
#line 443
int name_to_id(char const   *name , id_name_map const   *map ) ;
#line 444
uint16_t in_cksum(uint16_t *ptr , size_t nbytes ) ;
#line 446
uint32_t random_ip(void) ;
#line 447
int str_ccmp(char const   *s1 , char const   *s2 ) ;
#line 448
unsigned int name_or_number(char const   *string , id_name_map const   *map ) ;
#line 462
void utils_use_rcsid(void) ;
#line 49 "/home/june/repo/benchmarks/collector/temp/ike-scan-1.9/utils.c"
static char rcsid___1[45]  = 
#line 49 "/home/june/repo/benchmarks/collector/temp/ike-scan-1.9/utils.c"
  {      (char )'$',      (char )'I',      (char )'d',      (char )':', 
        (char )' ',      (char )'u',      (char )'t',      (char )'i', 
        (char )'l',      (char )'s',      (char )'.',      (char )'c', 
        (char )' ',      (char )'9',      (char )'8',      (char )'8', 
        (char )'4',      (char )' ',      (char )'2',      (char )'0', 
        (char )'0',      (char )'7',      (char )'-',      (char )'0', 
        (char )'1',      (char )'-',      (char )'1',      (char )'4', 
        (char )' ',      (char )'1',      (char )'9',      (char )':', 
        (char )'0',      (char )'5',      (char )':',      (char )'3', 
        (char )'9',      (char )'Z',      (char )' ',      (char )'r', 
        (char )'s',      (char )'h',      (char )' ',      (char )'$', 
        (char )'\000'};
#line 66 "/home/june/repo/benchmarks/collector/temp/ike-scan-1.9/utils.c"
void timeval_diff(struct timeval  const  *a , struct timeval  const  *b , struct timeval *diff ) 
{ 
  struct timeval temp ;
  int nsec ;
  int nsec___0 ;

  {
#line 71
  temp.tv_sec = (__time_t )b->tv_sec;
#line 72
  temp.tv_usec = (__suseconds_t )b->tv_usec;
#line 75
  if (a->tv_usec < (__suseconds_t const   )temp.tv_usec) {
#line 76
    nsec = (int )((temp.tv_usec - (__suseconds_t )a->tv_usec) / 1000000L + 1L);
#line 77
    temp.tv_usec -= (__suseconds_t )(1000000 * nsec);
#line 78
    temp.tv_sec += (__time_t )nsec;
  }
#line 80
  if (a->tv_usec - (__suseconds_t const   )temp.tv_usec > 1000000L) {
#line 81
    nsec___0 = (int )((a->tv_usec - (__suseconds_t const   )temp.tv_usec) / 1000000L);
#line 82
    temp.tv_usec += (__suseconds_t )(1000000 * nsec___0);
#line 83
    temp.tv_sec -= (__time_t )nsec___0;
  }
#line 88
  diff->tv_sec = (__time_t )(a->tv_sec - (__time_t const   )temp.tv_sec);
#line 89
  diff->tv_usec = (__suseconds_t )(a->tv_usec - (__suseconds_t const   )temp.tv_usec);
#line 90
  return;
}
}
#line 105 "/home/june/repo/benchmarks/collector/temp/ike-scan-1.9/utils.c"
int times_close_enough(struct timeval *t1 , struct timeval *t2 , unsigned int fuzz ) 
{ 
  struct timeval diff ;
  int diff_ms ;

  {
  {
#line 110
  timeval_diff((struct timeval  const  *)t1, (struct timeval  const  *)t2, & diff);
#line 111
  diff_ms = abs((int )(1000L * diff.tv_sec + diff.tv_usec / 1000L));
  }
#line 112
  if ((unsigned int )diff_ms <= fuzz) {
#line 113
    return (1);
  } else {
#line 115
    return (0);
  }
}
}
#line 136 "/home/june/repo/benchmarks/collector/temp/ike-scan-1.9/utils.c"
unsigned int hstr_i(char const   *cptr ) 
{ 
  unsigned int i ;
  unsigned int j ;
  int k ;
  char const   *tmp ;

  {
#line 140
  j = 0U;
#line 143
  k = 0;
  {
#line 143
  while (1) {
    while_continue: /* CIL Label */ ;
#line 143
    if (! (k < 2)) {
#line 143
      goto while_break;
    }
#line 144
    tmp = cptr;
#line 144
    cptr ++;
#line 144
    i = (unsigned int )((int const   )*tmp - 48);
#line 145
    if (9U < i) {
#line 146
      i -= 7U;
    }
#line 147
    j <<= 4;
#line 148
    j |= i & 15U;
#line 143
    k ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 150
  return (j);
}
}
#line 170 "/home/june/repo/benchmarks/collector/temp/ike-scan-1.9/utils.c"
unsigned char *hex2data(char const   *string , size_t *data_len ) 
{ 
  unsigned char *data ;
  unsigned char *cp ;
  unsigned int i ;
  size_t len ;
  size_t tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;
  unsigned char *tmp___2 ;
  unsigned int tmp___3 ;

  {
  {
#line 177
  tmp = strlen(string);
  }
#line 177
  if (tmp % 2UL) {
#line 178
    *data_len = (size_t )0;
#line 179
    return ((unsigned char *)((void *)0));
  }
  {
#line 182
  tmp___0 = strlen(string);
#line 182
  len = tmp___0 / 2UL;
#line 183
  tmp___1 = Malloc(len);
#line 183
  data = (unsigned char *)tmp___1;
#line 184
  cp = data;
#line 185
  i = 0U;
  }
  {
#line 185
  while (1) {
    while_continue: /* CIL Label */ ;
#line 185
    if (! ((size_t )i < len)) {
#line 185
      goto while_break;
    }
    {
#line 186
    tmp___2 = cp;
#line 186
    cp ++;
#line 186
    tmp___3 = hstr_i(string + i * 2U);
#line 186
    *tmp___2 = (unsigned char )tmp___3;
#line 185
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 187
  *data_len = len;
#line 188
  return (data);
}
}
#line 213 "/home/june/repo/benchmarks/collector/temp/ike-scan-1.9/utils.c"
unsigned char *hex_or_str(char const   *string , size_t *data_len ) 
{ 
  size_t tmp ;
  unsigned char *tmp___0 ;
  unsigned char *data ;
  size_t len ;
  void *tmp___1 ;

  {
  {
#line 216
  tmp = strlen(string);
  }
#line 216
  if (tmp < 1UL) {
#line 217
    *data_len = (size_t )0;
#line 218
    return ((unsigned char *)((void *)0));
  }
#line 221
  if ((int const   )*(string + 0) == 48) {
#line 221
    if ((int const   )*(string + 1) == 120) {
      {
#line 222
      tmp___0 = hex2data(string + 2, data_len);
      }
#line 222
      return (tmp___0);
    } else {
#line 221
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
    {
#line 227
    len = strlen(string);
#line 228
    tmp___1 = Malloc(len);
#line 228
    data = (unsigned char *)tmp___1;
#line 229
    memcpy((void */* __restrict  */)data, (void const   */* __restrict  */)string,
           len);
#line 230
    *data_len = len;
    }
#line 231
    return (data);
  }
}
}
#line 260 "/home/june/repo/benchmarks/collector/temp/ike-scan-1.9/utils.c"
unsigned char *hex_or_num(char const   *string , size_t *data_len ) 
{ 
  size_t tmp ;
  unsigned char *tmp___0 ;
  unsigned char *data ;
  size_t len ;
  unsigned long value ;
  unsigned long value_be ;
  uint32_t tmp___1 ;
  void *tmp___2 ;

  {
  {
#line 263
  tmp = strlen(string);
  }
#line 263
  if (tmp < 1UL) {
#line 264
    *data_len = (size_t )0;
#line 265
    return ((unsigned char *)((void *)0));
  }
#line 268
  if ((int const   )*(string + 0) == 48) {
#line 268
    if ((int const   )*(string + 1) == 120) {
      {
#line 269
      tmp___0 = hex2data(string + 2, data_len);
      }
#line 269
      return (tmp___0);
    } else {
#line 268
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
    {
#line 272
    len = (size_t )4;
#line 276
    value = Strtoul(string, 10);
#line 277
    tmp___1 = htonl((uint32_t )value);
#line 277
    value_be = (unsigned long )tmp___1;
#line 278
    tmp___2 = Malloc(len);
#line 278
    data = (unsigned char *)tmp___2;
#line 279
    memcpy((void */* __restrict  */)data, (void const   */* __restrict  */)(& value_be),
           len);
#line 281
    *data_len = len;
    }
#line 282
    return (data);
  }
}
}
#line 300 "/home/june/repo/benchmarks/collector/temp/ike-scan-1.9/utils.c"
char *make_message(char const   *fmt  , ...) 
{ 
  int n ;
  size_t size ;
  char *p ;
  va_list ap ;
  void *tmp ;
  void *tmp___0 ;

  {
  {
#line 304
  size = (size_t )100;
#line 307
  tmp = Malloc(size);
#line 307
  p = (char *)tmp;
  }
  {
#line 308
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 310
    __builtin_va_start(ap, fmt);
#line 311
    n = vsnprintf((char */* __restrict  */)p, size, (char const   */* __restrict  */)fmt,
                  ap);
#line 312
    __builtin_va_end(ap);
    }
#line 314
    if (n > -1) {
#line 314
      if ((size_t )n < size) {
#line 315
        return (p);
      }
    }
#line 317
    if (n > -1) {
#line 318
      size = (size_t )(n + 1);
    } else {
#line 320
      size *= 2UL;
    }
    {
#line 321
    tmp___0 = Realloc((void *)p, size);
#line 321
    p = (char *)tmp___0;
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 340 "/home/june/repo/benchmarks/collector/temp/ike-scan-1.9/utils.c"
static char buf[21]  ;
#line 338 "/home/june/repo/benchmarks/collector/temp/ike-scan-1.9/utils.c"
char *numstr(unsigned int num ) 
{ 


  {
  {
#line 342
  snprintf((char */* __restrict  */)(buf), sizeof(buf), (char const   */* __restrict  */)"%d",
           num);
  }
#line 343
  return (buf);
}
}
#line 369 "/home/june/repo/benchmarks/collector/temp/ike-scan-1.9/utils.c"
char *printable(unsigned char const   *string , size_t size ) 
{ 
  char *result ;
  char *r ;
  unsigned char const   *cp ;
  size_t outlen ;
  unsigned int i ;
  void *tmp ;
  unsigned short const   **tmp___0 ;
  void *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;
  char *tmp___14 ;
  char *tmp___15 ;
  char *tmp___16 ;
  char *tmp___17 ;
  unsigned short const   **tmp___18 ;

  {
#line 379
  if ((unsigned long )string == (unsigned long )((void *)0)) {
    {
#line 380
    tmp = Malloc((size_t )1);
#line 380
    result = (char *)tmp;
#line 381
    *(result + 0) = (char )'\000';
    }
#line 382
    return (result);
  }
#line 387
  if (! size) {
    {
#line 388
    size = strlen((char const   *)string);
    }
  }
#line 390
  outlen = size;
#line 391
  cp = string;
#line 392
  i = 0U;
  {
#line 392
  while (1) {
    while_continue: /* CIL Label */ ;
#line 392
    if (! ((size_t )i < size)) {
#line 392
      goto while_break;
    }
    {
#line 400
    if ((int const   )*cp == 11) {
#line 400
      goto case_11;
    }
#line 400
    if ((int const   )*cp == 9) {
#line 400
      goto case_11;
    }
#line 400
    if ((int const   )*cp == 13) {
#line 400
      goto case_11;
    }
#line 400
    if ((int const   )*cp == 10) {
#line 400
      goto case_11;
    }
#line 400
    if ((int const   )*cp == 12) {
#line 400
      goto case_11;
    }
#line 400
    if ((int const   )*cp == 8) {
#line 400
      goto case_11;
    }
#line 400
    if ((int const   )*cp == 92) {
#line 400
      goto case_11;
    }
#line 403
    goto switch_default;
    case_11: /* CIL Label */ 
    case_9: /* CIL Label */ 
    case_13: /* CIL Label */ 
    case_10: /* CIL Label */ 
    case_12: /* CIL Label */ 
    case_8: /* CIL Label */ 
    case_92: /* CIL Label */ 
#line 401
    outlen ++;
#line 402
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 404
    tmp___0 = __ctype_b_loc();
    }
#line 404
    if (! ((int const   )*(*tmp___0 + (int )*cp) & 16384)) {
#line 405
      outlen += 3UL;
    }
    switch_break: /* CIL Label */ ;
    }
#line 407
    cp ++;
#line 392
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 409
  outlen ++;
#line 411
  tmp___1 = Malloc(outlen);
#line 411
  result = (char *)tmp___1;
#line 413
  cp = string;
#line 414
  r = result;
#line 415
  i = 0U;
  }
  {
#line 415
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 415
    if (! ((size_t )i < size)) {
#line 415
      goto while_break___0;
    }
    {
#line 417
    if ((int const   )*cp == 92) {
#line 417
      goto case_92___0;
    }
#line 421
    if ((int const   )*cp == 8) {
#line 421
      goto case_8___0;
    }
#line 425
    if ((int const   )*cp == 12) {
#line 425
      goto case_12___0;
    }
#line 429
    if ((int const   )*cp == 10) {
#line 429
      goto case_10___0;
    }
#line 433
    if ((int const   )*cp == 13) {
#line 433
      goto case_13___0;
    }
#line 437
    if ((int const   )*cp == 9) {
#line 437
      goto case_9___0;
    }
#line 441
    if ((int const   )*cp == 11) {
#line 441
      goto case_11___0;
    }
#line 445
    goto switch_default___0;
    case_92___0: /* CIL Label */ 
#line 418
    tmp___2 = r;
#line 418
    r ++;
#line 418
    *tmp___2 = (char )'\\';
#line 419
    tmp___3 = r;
#line 419
    r ++;
#line 419
    *tmp___3 = (char )'\\';
#line 420
    goto switch_break___0;
    case_8___0: /* CIL Label */ 
#line 422
    tmp___4 = r;
#line 422
    r ++;
#line 422
    *tmp___4 = (char )'\\';
#line 423
    tmp___5 = r;
#line 423
    r ++;
#line 423
    *tmp___5 = (char )'b';
#line 424
    goto switch_break___0;
    case_12___0: /* CIL Label */ 
#line 426
    tmp___6 = r;
#line 426
    r ++;
#line 426
    *tmp___6 = (char )'\\';
#line 427
    tmp___7 = r;
#line 427
    r ++;
#line 427
    *tmp___7 = (char )'f';
#line 428
    goto switch_break___0;
    case_10___0: /* CIL Label */ 
#line 430
    tmp___8 = r;
#line 430
    r ++;
#line 430
    *tmp___8 = (char )'\\';
#line 431
    tmp___9 = r;
#line 431
    r ++;
#line 431
    *tmp___9 = (char )'n';
#line 432
    goto switch_break___0;
    case_13___0: /* CIL Label */ 
#line 434
    tmp___10 = r;
#line 434
    r ++;
#line 434
    *tmp___10 = (char )'\\';
#line 435
    tmp___11 = r;
#line 435
    r ++;
#line 435
    *tmp___11 = (char )'r';
#line 436
    goto switch_break___0;
    case_9___0: /* CIL Label */ 
#line 438
    tmp___12 = r;
#line 438
    r ++;
#line 438
    *tmp___12 = (char )'\\';
#line 439
    tmp___13 = r;
#line 439
    r ++;
#line 439
    *tmp___13 = (char )'t';
#line 440
    goto switch_break___0;
    case_11___0: /* CIL Label */ 
#line 442
    tmp___14 = r;
#line 442
    r ++;
#line 442
    *tmp___14 = (char )'\\';
#line 443
    tmp___15 = r;
#line 443
    r ++;
#line 443
    *tmp___15 = (char )'v';
#line 444
    goto switch_break___0;
    switch_default___0: /* CIL Label */ 
    {
#line 446
    tmp___18 = __ctype_b_loc();
    }
#line 446
    if ((int const   )*(*tmp___18 + (int )*cp) & 16384) {
#line 447
      tmp___16 = r;
#line 447
      r ++;
#line 447
      *tmp___16 = (char )*cp;
    } else {
      {
#line 449
      tmp___17 = r;
#line 449
      r ++;
#line 449
      *tmp___17 = (char )'\\';
#line 450
      sprintf((char */* __restrict  */)r, (char const   */* __restrict  */)"%.3o",
              (int const   )*cp);
#line 451
      r += 3;
      }
    }
#line 453
    goto switch_break___0;
    switch_break___0: /* CIL Label */ ;
    }
#line 455
    cp ++;
#line 415
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 457
  *r = (char )'\000';
#line 459
  return (result);
}
}
#line 481 "/home/june/repo/benchmarks/collector/temp/ike-scan-1.9/utils.c"
char *hexstring(unsigned char const   *data , size_t size ) 
{ 
  char *result ;
  char *r ;
  unsigned char const   *cp ;
  unsigned int i ;
  void *tmp ;
  void *tmp___0 ;
  unsigned char const   *tmp___1 ;

  {
#line 490
  if ((unsigned long )data == (unsigned long )((void *)0)) {
    {
#line 491
    tmp = Malloc((size_t )1);
#line 491
    result = (char *)tmp;
#line 492
    *(result + 0) = (char )'\000';
    }
#line 493
    return (result);
  }
  {
#line 498
  tmp___0 = Malloc(2UL * size + 1UL);
#line 498
  result = (char *)tmp___0;
#line 499
  cp = data;
#line 500
  r = result;
#line 501
  i = 0U;
  }
  {
#line 501
  while (1) {
    while_continue: /* CIL Label */ ;
#line 501
    if (! ((size_t )i < size)) {
#line 501
      goto while_break;
    }
    {
#line 502
    tmp___1 = cp;
#line 502
    cp ++;
#line 502
    sprintf((char */* __restrict  */)r, (char const   */* __restrict  */)"%.2x", (int const   )*tmp___1);
#line 503
    r += 2;
#line 501
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 505
  *r = (char )'\000';
#line 507
  return (result);
}
}
#line 526 "/home/june/repo/benchmarks/collector/temp/ike-scan-1.9/utils.c"
static struct timeval time_first  ;
#line 527 "/home/june/repo/benchmarks/collector/temp/ike-scan-1.9/utils.c"
static struct timeval time_last  ;
#line 528 "/home/june/repo/benchmarks/collector/temp/ike-scan-1.9/utils.c"
static int first_call  =    1;
#line 524 "/home/june/repo/benchmarks/collector/temp/ike-scan-1.9/utils.c"
void print_times(void) 
{ 
  struct timeval time_now ;
  struct timeval time_delta1 ;
  struct timeval time_delta2 ;

  {
  {
#line 533
  Gettimeofday(& time_now);
  }
#line 535
  if (first_call) {
    {
#line 536
    first_call = 0;
#line 537
    time_first.tv_sec = time_now.tv_sec;
#line 538
    time_first.tv_usec = time_now.tv_usec;
#line 539
    printf((char const   */* __restrict  */)"%lu.%.6lu (0.000000) [0.000000]\n", (unsigned long )time_now.tv_sec,
           (unsigned long )time_now.tv_usec);
    }
  } else {
    {
#line 542
    timeval_diff((struct timeval  const  *)(& time_now), (struct timeval  const  *)(& time_last),
                 & time_delta1);
#line 543
    timeval_diff((struct timeval  const  *)(& time_now), (struct timeval  const  *)(& time_first),
                 & time_delta2);
#line 544
    printf((char const   */* __restrict  */)"%lu.%.6lu (%lu.%.6lu) [%lu.%.6lu]\n",
           (unsigned long )time_now.tv_sec, (unsigned long )time_now.tv_usec, (unsigned long )time_delta1.tv_sec,
           (unsigned long )time_delta1.tv_usec, (unsigned long )time_delta2.tv_sec,
           (unsigned long )time_delta2.tv_usec);
    }
  }
#line 552
  time_last.tv_sec = time_now.tv_sec;
#line 553
  time_last.tv_usec = time_now.tv_usec;
#line 554
  return;
}
}
#line 571 "/home/june/repo/benchmarks/collector/temp/ike-scan-1.9/utils.c"
void sig_alarm(int signo ) 
{ 


  {
#line 572
  return;
}
}
#line 593 "/home/june/repo/benchmarks/collector/temp/ike-scan-1.9/utils.c"
char const   *id_to_name(unsigned int id , id_name_map const   *map ) 
{ 
  int found ;
  int i ;
  char *tmp ;

  {
#line 595
  found = 0;
#line 596
  i = 0;
#line 598
  if ((unsigned long )map == (unsigned long )((void *)0)) {
#line 599
    return ((char const   *)((void *)0));
  }
  {
#line 601
  while (1) {
    while_continue: /* CIL Label */ ;
#line 601
    if (! ((map + i)->id != -1)) {
#line 601
      goto while_break;
    }
#line 602
    if (id == (unsigned int )(map + i)->id) {
#line 603
      found = 1;
#line 604
      goto while_break;
    }
#line 606
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 609
  if (found) {
#line 610
    return ((char const   *)(map + i)->name);
  } else {
    {
#line 612
    tmp = numstr(id);
    }
#line 612
    return ((char const   *)tmp);
  }
}
}
#line 635 "/home/june/repo/benchmarks/collector/temp/ike-scan-1.9/utils.c"
int name_to_id(char const   *name , id_name_map const   *map ) 
{ 
  int found ;
  int i ;
  int tmp ;

  {
#line 637
  found = 0;
#line 638
  i = 0;
#line 640
  if ((unsigned long )map == (unsigned long )((void *)0)) {
#line 641
    return (-1);
  }
  {
#line 643
  while (1) {
    while_continue: /* CIL Label */ ;
#line 643
    if (! ((map + i)->id != -1)) {
#line 643
      goto while_break;
    }
    {
#line 644
    tmp = str_ccmp(name, (char const   *)(map + i)->name);
    }
#line 644
    if (tmp == 0) {
#line 645
      found = 1;
#line 646
      goto while_break;
    }
#line 648
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 651
  if (found) {
#line 652
    return ((int )(map + i)->id);
  } else {
#line 654
    return (-1);
  }
}
}
#line 658 "/home/june/repo/benchmarks/collector/temp/ike-scan-1.9/utils.c"
uint16_t in_cksum(uint16_t *ptr , size_t nbytes ) 
{ 
  register uint32_t sum ;
  uint16_t oddbyte ;
  register uint16_t answer ;
  uint16_t *tmp ;

  {
#line 671
  sum = (uint32_t )0;
  {
#line 672
  while (1) {
    while_continue: /* CIL Label */ ;
#line 672
    if (! (nbytes > 1UL)) {
#line 672
      goto while_break;
    }
#line 673
    tmp = ptr;
#line 673
    ptr ++;
#line 673
    sum += (uint32_t )*tmp;
#line 674
    nbytes -= 2UL;
  }
  while_break: /* CIL Label */ ;
  }
#line 678
  if (nbytes == 1UL) {
#line 679
    oddbyte = (uint16_t )0;
#line 680
    *((u_char *)(& oddbyte)) = *((u_char *)ptr);
#line 681
    sum += (uint32_t )oddbyte;
  }
#line 688
  sum = (sum >> 16) + (sum & 65535U);
#line 689
  sum += sum >> 16;
#line 690
  answer = (uint16_t )(~ sum);
#line 691
  return (answer);
}
}
#line 703 "/home/june/repo/benchmarks/collector/temp/ike-scan-1.9/utils.c"
static union __anonunion_random_data_76 random_data  ;
#line 707 "/home/june/repo/benchmarks/collector/temp/ike-scan-1.9/utils.c"
static int num_bytes  =    0;
#line 701 "/home/june/repo/benchmarks/collector/temp/ike-scan-1.9/utils.c"
uint8_t random_byte(void) 
{ 
  uint32_t random_value ;
  unsigned long tmp ;

  {
#line 709
  if (num_bytes == 0) {
    {
#line 712
    tmp = genrand_int32();
#line 712
    random_value = (uint32_t )tmp;
#line 713
    random_data.longword = htonl(random_value);
#line 714
    num_bytes = 4;
    }
  }
#line 716
  num_bytes --;
#line 716
  return (random_data.byte[num_bytes]);
}
}
#line 736 "/home/june/repo/benchmarks/collector/temp/ike-scan-1.9/utils.c"
uint32_t random_ip(void) 
{ 
  uint32_t random_value ;
  int acceptable ;
  unsigned long tmp ;

  {
  {
#line 741
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 742
    tmp = genrand_int32();
#line 742
    random_value = (uint32_t )tmp;
    }
#line 743
    if ((random_value & 4278190080U) == 2130706432U) {
#line 746
      acceptable = 0;
    } else
#line 743
    if (random_value > 4026531839U) {
#line 746
      acceptable = 0;
    } else
#line 743
    if (random_value < 50331648U) {
#line 746
      acceptable = 0;
    } else {
#line 748
      acceptable = 1;
    }
#line 741
    if (! (! acceptable)) {
#line 741
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 752
  return (random_value);
}
}
#line 772 "/home/june/repo/benchmarks/collector/temp/ike-scan-1.9/utils.c"
int str_ccmp(char const   *s1 , char const   *s2 ) 
{ 
  int c1 ;
  int c2 ;

  {
  {
#line 776
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 777
    c1 = tolower((int )((unsigned char )*s1));
#line 778
    c2 = tolower((int )((unsigned char )*s2));
    }
#line 780
    if (c1 > c2) {
#line 780
      return (1);
    }
#line 781
    if (c1 < c2) {
#line 781
      return (-1);
    }
#line 782
    if (c1 == 0) {
#line 782
      if (c2 == 0) {
#line 782
        return (0);
      }
    }
#line 776
    s1 ++;
#line 776
    s2 ++;
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 795 "/home/june/repo/benchmarks/collector/temp/ike-scan-1.9/utils.c"
unsigned int name_or_number(char const   *string , id_name_map const   *map ) 
{ 
  int result ;
  char *endptr ;
  unsigned long tmp ;

  {
  {
#line 800
  tmp = strtoul((char const   */* __restrict  */)string, (char **/* __restrict  */)(& endptr),
                0);
#line 800
  result = (int )tmp;
  }
#line 801
  if ((unsigned long )endptr != (unsigned long )string) {
#line 802
    return ((unsigned int )result);
  }
  {
#line 804
  result = name_to_id(string, map);
  }
#line 805
  if (result == -1) {
    {
#line 806
    err_msg("Invalid value: %s", string);
    }
  }
#line 808
  return ((unsigned int )result);
}
}
#line 811 "/home/june/repo/benchmarks/collector/temp/ike-scan-1.9/utils.c"
void utils_use_rcsid(void) 
{ 


  {
  {
#line 812
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s\n",
          rcsid___1);
  }
#line 813
  return;
}
}
#line 466 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 480
extern  __attribute__((__nothrow__)) void *( __attribute__((__warn_unused_result__,
__leaf__)) realloc)(void *__ptr , size_t __size ) ;
#line 71 "/usr/include/x86_64-linux-gnu/sys/time.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) gettimeofday)(struct timeval * __restrict  __tv ,
                                                                                                   __timezone_ptr_t __tz ) ;
#line 461 "/home/june/repo/benchmarks/collector/temp/ike-scan-1.9/ike-scan.h"
void wrappers_use_rcsid(void) ;
#line 55 "/home/june/repo/benchmarks/collector/temp/ike-scan-1.9/wrappers.c"
static char rcsid___2[48]  = 
#line 55 "/home/june/repo/benchmarks/collector/temp/ike-scan-1.9/wrappers.c"
  {      (char )'$',      (char )'I',      (char )'d',      (char )':', 
        (char )' ',      (char )'w',      (char )'r',      (char )'a', 
        (char )'p',      (char )'p',      (char )'e',      (char )'r', 
        (char )'s',      (char )'.',      (char )'c',      (char )' ', 
        (char )'9',      (char )'8',      (char )'8',      (char )'4', 
        (char )' ',      (char )'2',      (char )'0',      (char )'0', 
        (char )'7',      (char )'-',      (char )'0',      (char )'1', 
        (char )'-',      (char )'1',      (char )'4',      (char )' ', 
        (char )'1',      (char )'9',      (char )':',      (char )'0', 
        (char )'5',      (char )':',      (char )'3',      (char )'9', 
        (char )'Z',      (char )' ',      (char )'r',      (char )'s', 
        (char )'h',      (char )' ',      (char )'$',      (char )'\000'};
#line 61 "/home/june/repo/benchmarks/collector/temp/ike-scan-1.9/wrappers.c"
int Gettimeofday(struct timeval *tv ) 
{ 
  int result ;

  {
  {
#line 64
  result = gettimeofday((struct timeval */* __restrict  */)tv, (__timezone_ptr_t )((void *)0));
  }
#line 66
  if (result != 0) {
    {
#line 67
    err_sys("gettimeofday");
    }
  }
#line 69
  return (result);
}
}
#line 72 "/home/june/repo/benchmarks/collector/temp/ike-scan-1.9/wrappers.c"
void *Malloc(size_t size ) 
{ 
  void *result ;

  {
  {
#line 75
  result = malloc(size);
  }
#line 77
  if ((unsigned long )result == (unsigned long )((void *)0)) {
    {
#line 78
    err_sys("malloc");
    }
  }
#line 80
  return (result);
}
}
#line 83 "/home/june/repo/benchmarks/collector/temp/ike-scan-1.9/wrappers.c"
void *Realloc(void *ptr , size_t size ) 
{ 
  void *result ;

  {
  {
#line 86
  result = realloc(ptr, size);
  }
#line 88
  if ((unsigned long )result == (unsigned long )((void *)0)) {
    {
#line 89
    err_sys("realloc");
    }
  }
#line 91
  return (result);
}
}
#line 94 "/home/june/repo/benchmarks/collector/temp/ike-scan-1.9/wrappers.c"
unsigned long Strtoul(char const   *nptr , int base ) 
{ 
  char *endptr ;
  unsigned long result ;

  {
  {
#line 98
  result = strtoul((char const   */* __restrict  */)nptr, (char **/* __restrict  */)(& endptr),
                   base);
  }
#line 99
  if ((unsigned long )endptr == (unsigned long )nptr) {
    {
#line 100
    err_msg("ERROR: \"%s\" is not a valid numeric value", nptr);
    }
  }
#line 102
  return (result);
}
}
#line 105 "/home/june/repo/benchmarks/collector/temp/ike-scan-1.9/wrappers.c"
void wrappers_use_rcsid(void) 
{ 


  {
  {
#line 106
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s\n",
          rcsid___2);
  }
#line 107
  return;
}
}
#line 168 "/usr/include/stdio.h"
extern struct _IO_FILE *stdin ;
#line 237
extern int fclose(FILE *__stream ) ;
#line 622
extern char *fgets(char * __restrict  __s , int __n , FILE * __restrict  __stream ) ;
#line 50 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memmove)(void *__dest ,
                                                                                                  void const   *__src ,
                                                                                                  size_t __n ) ;
#line 129
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcpy)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 132
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strncpy)(char * __restrict  __dest ,
                                                                                                  char const   * __restrict  __src ,
                                                                                                  size_t __n ) ;
#line 140
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strncat)(char * __restrict  __dest ,
                                                                                                  char const   * __restrict  __src ,
                                                                                                  size_t __n ) ;
#line 144
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 236
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strchr)(char const   *__s ,
                                                                                               int __c )  __attribute__((__pure__)) ;
#line 348
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(2), __leaf__)) strtok)(char * __restrict  __s ,
                                                                                               char const   * __restrict  __delim ) ;
#line 144 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) double ( __attribute__((__nonnull__(1), __leaf__)) atof)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 183
extern  __attribute__((__nothrow__)) long ( __attribute__((__nonnull__(1), __leaf__)) strtol)(char const   * __restrict  __nptr ,
                                                                                              char ** __restrict  __endptr ,
                                                                                              int __base ) ;
#line 106 "/usr/include/x86_64-linux-gnu/sys/select.h"
extern int select(int __nfds , fd_set * __restrict  __readfds , fd_set * __restrict  __writefds ,
                  fd_set * __restrict  __exceptfds , struct timeval * __restrict  __timeout ) ;
#line 353 "/usr/include/unistd.h"
extern int close(int __fd ) ;
#line 360
extern ssize_t read(int __fd , void *__buf , size_t __nbytes ) ;
#line 366
extern ssize_t write(int __fd , void const   *__buf , size_t __n ) ;
#line 432
extern  __attribute__((__nothrow__)) unsigned int ( __attribute__((__leaf__)) alarm)(unsigned int __seconds ) ;
#line 628
extern  __attribute__((__nothrow__)) __pid_t ( __attribute__((__leaf__)) getpid)(void) ;
#line 675
extern  __attribute__((__nothrow__)) __uid_t ( __attribute__((__leaf__)) getuid)(void) ;
#line 700
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) setuid)(__uid_t __uid ) ;
#line 47 "./getopt.h"
extern char *optarg ;
#line 61
extern int optind ;
#line 113 "/usr/include/x86_64-linux-gnu/sys/socket.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) socket)(int __domain ,
                                                                             int __type ,
                                                                             int __protocol ) ;
#line 123
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) bind)(int __fd ,
                                                                           struct sockaddr  const  *__addr ,
                                                                           socklen_t __len ) ;
#line 137
extern int connect(int __fd , struct sockaddr  const  *__addr , socklen_t __len ) ;
#line 163
extern ssize_t sendto(int __fd , void const   *__buf , size_t __n , int __flags ,
                      struct sockaddr  const  *__addr , socklen_t __addr_len ) ;
#line 174
extern ssize_t recvfrom(int __fd , void * __restrict  __buf , size_t __n , int __flags ,
                        struct sockaddr * __restrict  __addr , socklen_t * __restrict  __addr_len ) ;
#line 226
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) setsockopt)(int __fd ,
                                                                                 int __level ,
                                                                                 int __optname ,
                                                                                 void const   *__optval ,
                                                                                 socklen_t __optlen ) ;
#line 144 "/usr/include/netdb.h"
extern struct hostent *gethostbyname(char const   *__name ) ;
#line 181 "/usr/include/x86_64-linux-gnu/sys/syslog.h"
extern void openlog(char const   *__ident , int __option , int __facility ) ;
#line 154 "./getopt.h"
extern int getopt_long_only(int ___argc , char * const  *___argv , char const   *__shortopts ,
                            struct option  const  *__longopts , int *__longind ) ;
#line 243 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) struct tm *( __attribute__((__leaf__)) localtime)(time_t const   *__timer ) ;
#line 73 "/usr/include/arpa/inet.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) inet_aton)(char const   *__cp ,
                                                                                struct in_addr *__inp ) ;
#line 215 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) sigemptyset)(sigset_t *__set ) ;
#line 259
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) sigaction)(int __sig ,
                                                                                struct sigaction  const  * __restrict  __act ,
                                                                                struct sigaction * __restrict  __oact ) ;
#line 573 "/usr/include/regex.h"
extern int regcomp(regex_t * __restrict  __preg , char const   * __restrict  __pattern ,
                   int __cflags ) ;
#line 582
extern size_t regerror(int __errcode , regex_t const   * __restrict  __preg , char * __restrict  __errbuf ,
                       size_t __errbuf_size ) ;
#line 146 "/usr/include/fcntl.h"
extern int ( __attribute__((__nonnull__(1))) open)(char const   *__file , int __oflag 
                                                   , ...) ;
#line 340 "/home/june/repo/benchmarks/collector/temp/ike-scan-1.9/ike-scan.h"
void usage(int status , int detailed ) ;
#line 341
void add_host_pattern(char const   *pattern , unsigned int timeout , unsigned int *num_hosts ,
                      unsigned char *cookie_data , size_t cookie_data_len ) ;
#line 343
void add_host(char const   *name , unsigned int timeout , unsigned int *num_hosts ,
              unsigned char *cookie_data , size_t cookie_data_len ) ;
#line 345
void send_packet(int s , unsigned char *packet_out , size_t packet_out_len , host_entry *he ,
                 unsigned int source_port , unsigned int dest_port , struct timeval *last_packet_time ) ;
#line 347
int recvfrom_wto(int s , unsigned char *buf___1 , size_t len , struct sockaddr *saddr ,
                 int tmo ) ;
#line 348
void remove_host(host_entry **he , unsigned int *live_count , unsigned int num_hosts ) ;
#line 351
unsigned char *initialise_ike_packet(size_t *packet_out_len , ike_packet_params *params ) ;
#line 352
host_entry *find_host_by_cookie(host_entry **he , unsigned char *packet_in , int n ,
                                unsigned int num_hosts ) ;
#line 354
void display_packet(int n , unsigned char *packet_in , host_entry *he , struct in_addr *recv_addr ,
                    unsigned int *sa_responders , unsigned int *notify_responders ,
                    int quiet , int multiline ) ;
#line 356
void advance_cursor(unsigned int live_count , unsigned int num_hosts ) ;
#line 357
void dump_list(unsigned int num_hosts ) ;
#line 358
void dump_times(unsigned int num_hosts ) ;
#line 359
void add_recv_time(host_entry *he , struct timeval *last_recv_time ) ;
#line 360
void load_backoff_patterns(char const   *patfile , unsigned int pattern_fuzz ) ;
#line 361
void add_pattern(char *line , unsigned int pattern_fuzz ) ;
#line 362
void load_vid_patterns(char const   *vidfile ) ;
#line 363
void add_vid_pattern(char *line ) ;
#line 364
char **load_id_strings(char *filename ) ;
#line 365
char *match_pattern(host_entry *he ) ;
#line 367
void dump_backoff(unsigned int pattern_fuzz ) ;
#line 368
void dump_vid(void) ;
#line 406
void decode_trans_simple(char const   *trans_str , unsigned int *enc , unsigned int *keylen ,
                         unsigned int *hash , unsigned int *auth , unsigned int *group ) ;
#line 408
unsigned char *decode_transform(char const   *trans_str , size_t *attr_len ) ;
#line 68 "/home/june/repo/benchmarks/collector/temp/ike-scan-1.9/hash_functions.h"
static unsigned char m[16]  ;
#line 65 "/home/june/repo/benchmarks/collector/temp/ike-scan-1.9/hash_functions.h"
__inline static unsigned char *MD5(unsigned char const   *d , size_t n , unsigned char *md ) 
{ 
  md5_state_t context ;

  {
#line 70
  if ((unsigned long )md == (unsigned long )((void *)0)) {
#line 71
    md = m;
  }
  {
#line 73
  md5_init(& context);
#line 74
  md5_append(& context, d, (int )n);
#line 75
  md5_finish(& context, (md5_byte_t *)md);
  }
#line 77
  return (md);
}
}
#line 62 "/home/june/repo/benchmarks/collector/temp/ike-scan-1.9/ike-scan.c"
static char const   rcsid___3[48]  = 
#line 62 "/home/june/repo/benchmarks/collector/temp/ike-scan-1.9/ike-scan.c"
  {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )':', 
        (char const   )' ',      (char const   )'i',      (char const   )'k',      (char const   )'e', 
        (char const   )'-',      (char const   )'s',      (char const   )'c',      (char const   )'a', 
        (char const   )'n',      (char const   )'.',      (char const   )'c',      (char const   )' ', 
        (char const   )'9',      (char const   )'8',      (char const   )'8',      (char const   )'4', 
        (char const   )' ',      (char const   )'2',      (char const   )'0',      (char const   )'0', 
        (char const   )'7',      (char const   )'-',      (char const   )'0',      (char const   )'1', 
        (char const   )'-',      (char const   )'1',      (char const   )'4',      (char const   )' ', 
        (char const   )'1',      (char const   )'9',      (char const   )':',      (char const   )'0', 
        (char const   )'5',      (char const   )':',      (char const   )'3',      (char const   )'9', 
        (char const   )'Z',      (char const   )' ',      (char const   )'r',      (char const   )'s', 
        (char const   )'h',      (char const   )' ',      (char const   )'$',      (char const   )'\000'};
#line 65 "/home/june/repo/benchmarks/collector/temp/ike-scan-1.9/ike-scan.c"
host_entry *helist  =    (host_entry *)((void *)0);
#line 66 "/home/june/repo/benchmarks/collector/temp/ike-scan-1.9/ike-scan.c"
host_entry **helistptr  ;
#line 67 "/home/june/repo/benchmarks/collector/temp/ike-scan-1.9/ike-scan.c"
host_entry **cursor  ;
#line 68 "/home/june/repo/benchmarks/collector/temp/ike-scan-1.9/ike-scan.c"
pattern_list *patlist  =    (pattern_list *)((void *)0);
#line 69 "/home/june/repo/benchmarks/collector/temp/ike-scan-1.9/ike-scan.c"
vid_pattern_list *vidlist  =    (vid_pattern_list *)((void *)0);
#line 70 "/home/june/repo/benchmarks/collector/temp/ike-scan-1.9/ike-scan.c"
char **idlist  =    (char **)((void *)0);
#line 71 "/home/june/repo/benchmarks/collector/temp/ike-scan-1.9/ike-scan.c"
static int verbose  =    0;
#line 72 "/home/june/repo/benchmarks/collector/temp/ike-scan-1.9/ike-scan.c"
unsigned int experimental_value  =    0U;
#line 73 "/home/june/repo/benchmarks/collector/temp/ike-scan-1.9/ike-scan.c"
int tcp_flag  =    0;
#line 74 "/home/june/repo/benchmarks/collector/temp/ike-scan-1.9/ike-scan.c"
int psk_crack_flag  =    0;
#line 75 "/home/june/repo/benchmarks/collector/temp/ike-scan-1.9/ike-scan.c"
psk_crack psk_values  = 
#line 75
     {(unsigned char *)((void *)0), (unsigned char *)((void *)0), (unsigned char *)((void *)0),
    (unsigned char *)((void *)0), (unsigned char *)((void *)0), (unsigned char *)((void *)0),
    (unsigned char *)((void *)0), (unsigned char *)((void *)0), (unsigned char *)((void *)0),
    (size_t )0, (size_t )0, (size_t )0, (size_t )0, (size_t )0, (size_t )0, (size_t )0,
    (size_t )0, (size_t )0};
#line 79 "/home/june/repo/benchmarks/collector/temp/ike-scan-1.9/ike-scan.c"
int no_dns_flag  =    0;
#line 80 "/home/june/repo/benchmarks/collector/temp/ike-scan-1.9/ike-scan.c"
int mbz_value  =    0;
#line 81 "/home/june/repo/benchmarks/collector/temp/ike-scan-1.9/ike-scan.c"
uint32_t lifetime_be  ;
#line 82 "/home/june/repo/benchmarks/collector/temp/ike-scan-1.9/ike-scan.c"
uint32_t lifesize_be  ;
#line 83 "/home/june/repo/benchmarks/collector/temp/ike-scan-1.9/ike-scan.c"
int write_pkt_to_file  =    0;
#line 84 "/home/june/repo/benchmarks/collector/temp/ike-scan-1.9/ike-scan.c"
int read_pkt_from_file  =    0;
#line 85 "/home/june/repo/benchmarks/collector/temp/ike-scan-1.9/ike-scan.c"
int timestamp_flag  =    0;
#line 86 "/home/june/repo/benchmarks/collector/temp/ike-scan-1.9/ike-scan.c"
int randsrc_flag  =    0;
#line 87 "/home/june/repo/benchmarks/collector/temp/ike-scan-1.9/ike-scan.c"
int sourceip_flag  =    0;
#line 88 "/home/june/repo/benchmarks/collector/temp/ike-scan-1.9/ike-scan.c"
uint32_t src_ip_val  ;
#line 89 "/home/june/repo/benchmarks/collector/temp/ike-scan-1.9/ike-scan.c"
int shownum_flag  =    0;
#line 90 "/home/june/repo/benchmarks/collector/temp/ike-scan-1.9/ike-scan.c"
int nat_t_flag  =    0;
#line 249 "/home/june/repo/benchmarks/collector/temp/ike-scan-1.9/ike-scan.c"
static int reset_cum_err  ;
#line 105 "/home/june/repo/benchmarks/collector/temp/ike-scan-1.9/ike-scan.c"
int main(int argc , char **argv ) 
{ 
  struct option long_options[60] ;
  char const   *short_options ;
  int arg ;
  char arg_str[255] ;
  int options_index ;
  char filename[255] ;
  int filename_flag ;
  char pkt_filename[255] ;
  int pkt_filename_flag ;
  int pkt_read_filename_flag ;
  int random_flag ;
  int sockfd ;
  unsigned int source_port ;
  unsigned int dest_port ;
  unsigned int retry ;
  unsigned int interval ;
  double backoff_factor ;
  unsigned int end_wait ;
  unsigned int timeout ;
  ike_packet_params ike_params ;
  unsigned int pattern_fuzz ;
  unsigned int tcp_connect_timeout ;
  struct sockaddr_in sa_local ;
  struct sockaddr_in sa_peer ;
  struct timeval now ;
  unsigned char packet_in[65507] ;
  int n ;
  host_entry *temp_cursor ;
  struct timeval diff ;
  unsigned long loop_timediff ;
  unsigned long host_timediff ;
  unsigned long end_timediff ;
  int req_interval ;
  int select_timeout ;
  int cum_err ;
  struct timeval start_time ;
  struct timeval end_time ;
  struct timeval last_packet_time ;
  struct timeval elapsed_time ;
  double elapsed_seconds ;
  int arg_str_space ;
  char patfile[255] ;
  char vidfile[255] ;
  char idfile[255] ;
  char psk_crack_file[255] ;
  unsigned int pass_no ;
  int first_timeout ;
  unsigned char *vid_data ;
  size_t vid_data_len ;
  int showbackoff_flag ;
  struct timeval last_recv_time ;
  unsigned char *packet_out ;
  size_t packet_out_len ;
  unsigned int sa_responders ;
  unsigned int notify_responders ;
  unsigned int num_hosts ;
  unsigned int live_count ;
  int quiet ;
  int multiline ;
  int hostno ;
  unsigned int bandwidth ;
  unsigned char *cookie_data ;
  size_t cookie_data_len ;
  char **idstrings ;
  unsigned int random_seed ;
  size_t tmp ;
  unsigned int trans_enc ;
  unsigned int trans_keylen ;
  unsigned int trans_hash ;
  unsigned int trans_auth ;
  unsigned int trans_group ;
  char trans_str[255] ;
  char interval_str[255] ;
  size_t interval_len ;
  char bandwidth_str[255] ;
  size_t bandwidth_len ;
  struct in_addr src_ip_struct ;
  unsigned long tmp___0 ;
  unsigned long tmp___1 ;
  unsigned long tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  unsigned long tmp___5 ;
  unsigned long tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  size_t tmp___9 ;
  unsigned char *attr ;
  size_t attr_len ;
  unsigned long tmp___10 ;
  unsigned long tmp___11 ;
  unsigned long tmp___12 ;
  unsigned long tmp___13 ;
  size_t tmp___14 ;
  unsigned long tmp___15 ;
  unsigned long tmp___16 ;
  unsigned long tmp___17 ;
  unsigned long tmp___18 ;
  unsigned long tmp___19 ;
  size_t tmp___20 ;
  void *tmp___21 ;
  unsigned long tmp___22 ;
  unsigned long tmp___23 ;
  size_t tmp___24 ;
  unsigned long tmp___25 ;
  unsigned long tmp___26 ;
  unsigned long tmp___27 ;
  unsigned long tmp___28 ;
  unsigned long tmp___29 ;
  unsigned long tmp___30 ;
  unsigned long tmp___31 ;
  size_t tmp___32 ;
  unsigned long tmp___33 ;
  unsigned long tmp___34 ;
  unsigned long tmp___35 ;
  int tmp___36 ;
  int tmp___37 ;
  size_t tmp___38 ;
  unsigned long tmp___39 ;
  struct timeval tv ;
  __pid_t tmp___40 ;
  int on ;
  int tmp___41 ;
  int tmp___42 ;
  int on___0 ;
  int tmp___43 ;
  int tmp___44 ;
  int on___1 ;
  int tmp___45 ;
  int *tmp___46 ;
  int *tmp___47 ;
  int tmp___48 ;
  __uid_t tmp___49 ;
  int tmp___50 ;
  FILE *fp ;
  char line[255] ;
  char *cp ;
  int tmp___51 ;
  unsigned short const   **tmp___52 ;
  char *tmp___53 ;
  struct sockaddr_in sa_tcp ;
  socklen_t sa_tcp_len ;
  struct sigaction act ;
  struct sigaction oact ;
  int *tmp___54 ;
  int *tmp___55 ;
  int tmp___56 ;
  void *tmp___57 ;
  int i ;
  int r ;
  host_entry *temp ;
  double tmp___58 ;
  int s_err ;
  char *tmp___59 ;
  char *tmp___60 ;
  char *tmp___61 ;
  char *tmp___62 ;
  struct isakmp_hdr hdr_in ;
  char *cp___0 ;
  char *tmp___63 ;

  {
  {
#line 111
  long_options[0].name = "file";
#line 111
  long_options[0].has_arg = 1;
#line 111
  long_options[0].flag = (int *)0;
#line 111
  long_options[0].val = 'f';
#line 111
  long_options[1].name = "help";
#line 111
  long_options[1].has_arg = 0;
#line 111
  long_options[1].flag = (int *)0;
#line 111
  long_options[1].val = 'h';
#line 111
  long_options[2].name = "sport";
#line 111
  long_options[2].has_arg = 1;
#line 111
  long_options[2].flag = (int *)0;
#line 111
  long_options[2].val = 's';
#line 111
  long_options[3].name = "dport";
#line 111
  long_options[3].has_arg = 1;
#line 111
  long_options[3].flag = (int *)0;
#line 111
  long_options[3].val = 'd';
#line 111
  long_options[4].name = "retry";
#line 111
  long_options[4].has_arg = 1;
#line 111
  long_options[4].flag = (int *)0;
#line 111
  long_options[4].val = 'r';
#line 111
  long_options[5].name = "timeout";
#line 111
  long_options[5].has_arg = 1;
#line 111
  long_options[5].flag = (int *)0;
#line 111
  long_options[5].val = 't';
#line 111
  long_options[6].name = "interval";
#line 111
  long_options[6].has_arg = 1;
#line 111
  long_options[6].flag = (int *)0;
#line 111
  long_options[6].val = 'i';
#line 111
  long_options[7].name = "backoff";
#line 111
  long_options[7].has_arg = 1;
#line 111
  long_options[7].flag = (int *)0;
#line 111
  long_options[7].val = 'b';
#line 111
  long_options[8].name = "selectwait";
#line 111
  long_options[8].has_arg = 1;
#line 111
  long_options[8].flag = (int *)0;
#line 111
  long_options[8].val = 'w';
#line 111
  long_options[9].name = "verbose";
#line 111
  long_options[9].has_arg = 0;
#line 111
  long_options[9].flag = (int *)0;
#line 111
  long_options[9].val = 'v';
#line 111
  long_options[10].name = "lifetime";
#line 111
  long_options[10].has_arg = 1;
#line 111
  long_options[10].flag = (int *)0;
#line 111
  long_options[10].val = 'l';
#line 111
  long_options[11].name = "lifesize";
#line 111
  long_options[11].has_arg = 1;
#line 111
  long_options[11].flag = (int *)0;
#line 111
  long_options[11].val = 'z';
#line 111
  long_options[12].name = "auth";
#line 111
  long_options[12].has_arg = 1;
#line 111
  long_options[12].flag = (int *)0;
#line 111
  long_options[12].val = 'm';
#line 111
  long_options[13].name = "version";
#line 111
  long_options[13].has_arg = 0;
#line 111
  long_options[13].flag = (int *)0;
#line 111
  long_options[13].val = 'V';
#line 111
  long_options[14].name = "vendor";
#line 111
  long_options[14].has_arg = 1;
#line 111
  long_options[14].flag = (int *)0;
#line 111
  long_options[14].val = 'e';
#line 111
  long_options[15].name = "trans";
#line 111
  long_options[15].has_arg = 1;
#line 111
  long_options[15].flag = (int *)0;
#line 111
  long_options[15].val = 'a';
#line 111
  long_options[16].name = "showbackoff";
#line 111
  long_options[16].has_arg = 2;
#line 111
  long_options[16].flag = (int *)0;
#line 111
  long_options[16].val = 'o';
#line 111
  long_options[17].name = "fuzz";
#line 111
  long_options[17].has_arg = 1;
#line 111
  long_options[17].flag = (int *)0;
#line 111
  long_options[17].val = 'u';
#line 111
  long_options[18].name = "id";
#line 111
  long_options[18].has_arg = 1;
#line 111
  long_options[18].flag = (int *)0;
#line 111
  long_options[18].val = 'n';
#line 111
  long_options[19].name = "idtype";
#line 111
  long_options[19].has_arg = 1;
#line 111
  long_options[19].flag = (int *)0;
#line 111
  long_options[19].val = 'y';
#line 111
  long_options[20].name = "dhgroup";
#line 111
  long_options[20].has_arg = 1;
#line 111
  long_options[20].flag = (int *)0;
#line 111
  long_options[20].val = 'g';
#line 111
  long_options[21].name = "patterns";
#line 111
  long_options[21].has_arg = 1;
#line 111
  long_options[21].flag = (int *)0;
#line 111
  long_options[21].val = 'p';
#line 111
  long_options[22].name = "aggressive";
#line 111
  long_options[22].has_arg = 0;
#line 111
  long_options[22].flag = (int *)0;
#line 111
  long_options[22].val = 'A';
#line 111
  long_options[23].name = "gssid";
#line 111
  long_options[23].has_arg = 1;
#line 111
  long_options[23].flag = (int *)0;
#line 111
  long_options[23].val = 'G';
#line 111
  long_options[24].name = "vidpatterns";
#line 111
  long_options[24].has_arg = 1;
#line 111
  long_options[24].flag = (int *)0;
#line 111
  long_options[24].val = 'I';
#line 111
  long_options[25].name = "quiet";
#line 111
  long_options[25].has_arg = 0;
#line 111
  long_options[25].flag = (int *)0;
#line 111
  long_options[25].val = 'q';
#line 111
  long_options[26].name = "multiline";
#line 111
  long_options[26].has_arg = 0;
#line 111
  long_options[26].flag = (int *)0;
#line 111
  long_options[26].val = 'M';
#line 111
  long_options[27].name = "random";
#line 111
  long_options[27].has_arg = 0;
#line 111
  long_options[27].flag = (int *)0;
#line 111
  long_options[27].val = 'R';
#line 111
  long_options[28].name = "tcp";
#line 111
  long_options[28].has_arg = 2;
#line 111
  long_options[28].flag = (int *)0;
#line 111
  long_options[28].val = 'T';
#line 111
  long_options[29].name = "pskcrack";
#line 111
  long_options[29].has_arg = 2;
#line 111
  long_options[29].flag = (int *)0;
#line 111
  long_options[29].val = 'P';
#line 111
  long_options[30].name = "tcptimeout";
#line 111
  long_options[30].has_arg = 1;
#line 111
  long_options[30].flag = (int *)0;
#line 111
  long_options[30].val = 'O';
#line 111
  long_options[31].name = "nodns";
#line 111
  long_options[31].has_arg = 0;
#line 111
  long_options[31].flag = (int *)0;
#line 111
  long_options[31].val = 'N';
#line 111
  long_options[32].name = "noncelen";
#line 111
  long_options[32].has_arg = 1;
#line 111
  long_options[32].flag = (int *)0;
#line 111
  long_options[32].val = 'c';
#line 111
  long_options[33].name = "bandwidth";
#line 111
  long_options[33].has_arg = 1;
#line 111
  long_options[33].flag = (int *)0;
#line 111
  long_options[33].val = 'B';
#line 111
  long_options[34].name = "headerlen";
#line 111
  long_options[34].has_arg = 1;
#line 111
  long_options[34].flag = (int *)0;
#line 111
  long_options[34].val = 'L';
#line 111
  long_options[35].name = "mbz";
#line 111
  long_options[35].has_arg = 1;
#line 111
  long_options[35].flag = (int *)0;
#line 111
  long_options[35].val = 'Z';
#line 111
  long_options[36].name = "headerver";
#line 111
  long_options[36].has_arg = 1;
#line 111
  long_options[36].flag = (int *)0;
#line 111
  long_options[36].val = 'E';
#line 111
  long_options[37].name = "certreq";
#line 111
  long_options[37].has_arg = 1;
#line 111
  long_options[37].flag = (int *)0;
#line 111
  long_options[37].val = 'C';
#line 111
  long_options[38].name = "doi";
#line 111
  long_options[38].has_arg = 1;
#line 111
  long_options[38].flag = (int *)0;
#line 111
  long_options[38].val = 'D';
#line 111
  long_options[39].name = "situation";
#line 111
  long_options[39].has_arg = 1;
#line 111
  long_options[39].flag = (int *)0;
#line 111
  long_options[39].val = 'S';
#line 111
  long_options[40].name = "protocol";
#line 111
  long_options[40].has_arg = 1;
#line 111
  long_options[40].flag = (int *)0;
#line 111
  long_options[40].val = 'j';
#line 111
  long_options[41].name = "transid";
#line 111
  long_options[41].has_arg = 1;
#line 111
  long_options[41].flag = (int *)0;
#line 111
  long_options[41].val = 'k';
#line 111
  long_options[42].name = "idfile";
#line 111
  long_options[42].has_arg = 1;
#line 111
  long_options[42].flag = (int *)0;
#line 111
  long_options[42].val = 'F';
#line 111
  long_options[43].name = "spisize";
#line 111
  long_options[43].has_arg = 1;
#line 111
  long_options[43].flag = (int *)0;
#line 111
  long_options[43].val = 256;
#line 111
  long_options[44].name = "hdrflags";
#line 111
  long_options[44].has_arg = 1;
#line 111
  long_options[44].flag = (int *)0;
#line 111
  long_options[44].val = 257;
#line 111
  long_options[45].name = "hdrmsgid";
#line 111
  long_options[45].has_arg = 1;
#line 111
  long_options[45].flag = (int *)0;
#line 111
  long_options[45].val = 258;
#line 111
  long_options[46].name = "cookie";
#line 111
  long_options[46].has_arg = 1;
#line 111
  long_options[46].flag = (int *)0;
#line 111
  long_options[46].val = 259;
#line 111
  long_options[47].name = "exchange";
#line 111
  long_options[47].has_arg = 1;
#line 111
  long_options[47].flag = (int *)0;
#line 111
  long_options[47].val = 260;
#line 111
  long_options[48].name = "nextpayload";
#line 111
  long_options[48].has_arg = 1;
#line 111
  long_options[48].flag = (int *)0;
#line 111
  long_options[48].val = 261;
#line 111
  long_options[49].name = "writepkttofile";
#line 111
  long_options[49].has_arg = 1;
#line 111
  long_options[49].flag = (int *)0;
#line 111
  long_options[49].val = 262;
#line 111
  long_options[50].name = "randomseed";
#line 111
  long_options[50].has_arg = 1;
#line 111
  long_options[50].flag = (int *)0;
#line 111
  long_options[50].val = 263;
#line 111
  long_options[51].name = "timestamp";
#line 111
  long_options[51].has_arg = 0;
#line 111
  long_options[51].flag = (int *)0;
#line 111
  long_options[51].val = 264;
#line 111
  long_options[52].name = "sourceip";
#line 111
  long_options[52].has_arg = 1;
#line 111
  long_options[52].flag = (int *)0;
#line 111
  long_options[52].val = 265;
#line 111
  long_options[53].name = "shownum";
#line 111
  long_options[53].has_arg = 0;
#line 111
  long_options[53].flag = (int *)0;
#line 111
  long_options[53].val = 266;
#line 111
  long_options[54].name = "ikev2";
#line 111
  long_options[54].has_arg = 0;
#line 111
  long_options[54].flag = (int *)0;
#line 111
  long_options[54].val = '2';
#line 111
  long_options[55].name = "nat-t";
#line 111
  long_options[55].has_arg = 0;
#line 111
  long_options[55].flag = (int *)0;
#line 111
  long_options[55].val = 267;
#line 111
  long_options[56].name = "rcookie";
#line 111
  long_options[56].has_arg = 1;
#line 111
  long_options[56].flag = (int *)0;
#line 111
  long_options[56].val = 268;
#line 111
  long_options[57].name = "readpktfromfile";
#line 111
  long_options[57].has_arg = 1;
#line 111
  long_options[57].flag = (int *)0;
#line 111
  long_options[57].val = 269;
#line 111
  long_options[58].name = "experimental";
#line 111
  long_options[58].has_arg = 1;
#line 111
  long_options[58].flag = (int *)0;
#line 111
  long_options[58].val = 'X';
#line 111
  long_options[59].name = (char const   *)0;
#line 111
  long_options[59].has_arg = 0;
#line 111
  long_options[59].flag = (int *)0;
#line 111
  long_options[59].val = 0;
#line 180
  short_options = "f:hs:d:r:t:i:b:w:vl:z:m:Ve:a:o::u:n:y:g:p:AG:I:qMRT::P::O:Nc:B:L:Z:E:C:D:S:j:k:F:2X:";
#line 185
  options_index = 0;
#line 187
  filename_flag = 0;
#line 189
  pkt_filename_flag = 0;
#line 190
  pkt_read_filename_flag = 0;
#line 191
  random_flag = 0;
#line 193
  source_port = 500U;
#line 194
  dest_port = 500U;
#line 195
  retry = 3U;
#line 196
  interval = 0U;
#line 197
  backoff_factor = 1.5;
#line 198
  end_wait = 60000U;
#line 199
  timeout = 500U;
#line 200
  ike_params.lifetime_data = (unsigned char *)((void *)0);
#line 200
  ike_params.lifetime_data_len = (size_t )0;
#line 200
  ike_params.lifesize_data = (unsigned char *)((void *)0);
#line 200
  ike_params.lifesize_data_len = (size_t )0;
#line 200
  ike_params.auth_method = 1U;
#line 200
  ike_params.dhgroup = 2U;
#line 200
  ike_params.idtype = 3U;
#line 200
  ike_params.id_data = (unsigned char *)((void *)0);
#line 200
  ike_params.id_data_len = (size_t )0;
#line 200
  ike_params.vendor_id_flag = 0;
#line 200
  ike_params.trans_flag = 0;
#line 200
  ike_params.exchange_type = 2U;
#line 200
  ike_params.gss_id_flag = 0;
#line 200
  ike_params.gss_data = (unsigned char *)((void *)0);
#line 200
  ike_params.gss_data_len = (size_t )0;
#line 200
  ike_params.nonce_data_len = (size_t )20;
#line 200
  ike_params.header_length = (char *)((void *)0);
#line 200
  ike_params.cr_data = (unsigned char *)((void *)0);
#line 200
  ike_params.cr_data_len = (size_t )0;
#line 200
  ike_params.header_version = 16;
#line 200
  ike_params.doi = 1U;
#line 200
  ike_params.situation = 1U;
#line 200
  ike_params.protocol = 1U;
#line 200
  ike_params.trans_id = 1U;
#line 200
  ike_params.spi_size = 0U;
#line 200
  ike_params.hdr_flags = 0;
#line 200
  ike_params.hdr_msgid = 0U;
#line 200
  ike_params.hdr_next_payload = 0U;
#line 200
  ike_params.advanced_trans_flag = 0;
#line 200
  ike_params.ike_version = 1;
#line 200
  ike_params.rcookie_data = (unsigned char *)((void *)0);
#line 200
  ike_params.rcookie_data_len = (size_t )0;
#line 234
  pattern_fuzz = 500U;
#line 235
  tcp_connect_timeout = 10U;
#line 245
  end_timediff = 0UL;
#line 248
  cum_err = 0;
#line 260
  pass_no = 0U;
#line 261
  first_timeout = 1;
#line 264
  showbackoff_flag = 0;
#line 268
  sa_responders = 0U;
#line 269
  notify_responders = 0U;
#line 270
  num_hosts = 0U;
#line 272
  quiet = 0;
#line 273
  multiline = 0;
#line 275
  bandwidth = 56000U;
#line 276
  cookie_data = (unsigned char *)((void *)0);
#line 278
  idstrings = (char **)((void *)0);
#line 279
  random_seed = 0U;
#line 286
  openlog("ike-scan", 1, 1 << 3);
#line 287
  arg_str[0] = (char )'\000';
#line 288
  arg_str_space = 255;
#line 289
  arg = 0;
  }
  {
#line 289
  while (1) {
    while_continue: /* CIL Label */ ;
#line 289
    if (! (arg < argc)) {
#line 289
      goto while_break;
    }
    {
#line 290
    tmp = strlen((char const   *)*(argv + arg));
#line 290
    arg_str_space = (int )((size_t )arg_str_space - tmp);
    }
#line 291
    if (arg_str_space > 0) {
      {
#line 292
      strncat((char */* __restrict  */)(arg_str), (char const   */* __restrict  */)*(argv + arg),
              (size_t )arg_str_space);
      }
#line 293
      if (arg < argc - 1) {
#line 294
        arg_str_space --;
#line 294
        if (arg_str_space > 0) {
          {
#line 295
          strcat((char */* __restrict  */)(arg_str), (char const   */* __restrict  */)" ");
          }
        }
      }
    }
#line 289
    arg ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 300
  info_syslog("Starting: %s", arg_str);
#line 305
  Gettimeofday(& start_time);
#line 309
  patfile[0] = (char )'\000';
#line 310
  vidfile[0] = (char )'\000';
#line 311
  idfile[0] = (char )'\000';
#line 316
  lifetime_be = htonl((uint32_t )28800);
#line 317
  ike_params.lifetime_data = (unsigned char *)(& lifetime_be);
#line 318
  ike_params.lifetime_data_len = (size_t )4;
  }
  {
#line 328
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 328
    arg = getopt_long_only(argc, (char * const  *)argv, short_options, (struct option  const  *)(long_options),
                           & options_index);
    }
#line 328
    if (! (arg != -1)) {
#line 328
      goto while_break___0;
    }
    {
#line 341
    if (arg == 102) {
#line 341
      goto case_102;
    }
#line 345
    if (arg == 104) {
#line 345
      goto case_104;
    }
#line 348
    if (arg == 115) {
#line 348
      goto case_115;
    }
#line 351
    if (arg == 100) {
#line 351
      goto case_100;
    }
#line 354
    if (arg == 114) {
#line 354
      goto case_114;
    }
#line 357
    if (arg == 116) {
#line 357
      goto case_116;
    }
#line 360
    if (arg == 105) {
#line 360
      goto case_105;
    }
#line 371
    if (arg == 98) {
#line 371
      goto case_98;
    }
#line 374
    if (arg == 119) {
#line 374
      goto case_119;
    }
#line 377
    if (arg == 118) {
#line 377
      goto case_118;
    }
#line 380
    if (arg == 108) {
#line 380
      goto case_108;
    }
#line 389
    if (arg == 122) {
#line 389
      goto case_122;
    }
#line 398
    if (arg == 109) {
#line 398
      goto case_109;
    }
#line 401
    if (arg == 86) {
#line 401
      goto case_86;
    }
#line 417
    if (arg == 101) {
#line 417
      goto case_101;
    }
#line 425
    if (arg == 97) {
#line 425
      goto case_97;
    }
#line 449
    if (arg == 111) {
#line 449
      goto case_111;
    }
#line 457
    if (arg == 117) {
#line 457
      goto case_117;
    }
#line 460
    if (arg == 110) {
#line 460
      goto case_110;
    }
#line 465
    if (arg == 121) {
#line 465
      goto case_121;
    }
#line 468
    if (arg == 103) {
#line 468
      goto case_103;
    }
#line 471
    if (arg == 112) {
#line 471
      goto case_112;
    }
#line 474
    if (arg == 65) {
#line 474
      goto case_65;
    }
#line 477
    if (arg == 71) {
#line 477
      goto case_71;
    }
#line 484
    if (arg == 73) {
#line 484
      goto case_73;
    }
#line 487
    if (arg == 113) {
#line 487
      goto case_113;
    }
#line 490
    if (arg == 77) {
#line 490
      goto case_77;
    }
#line 493
    if (arg == 82) {
#line 493
      goto case_82;
    }
#line 496
    if (arg == 84) {
#line 496
      goto case_84;
    }
#line 503
    if (arg == 80) {
#line 503
      goto case_80;
    }
#line 511
    if (arg == 79) {
#line 511
      goto case_79;
    }
#line 514
    if (arg == 78) {
#line 514
      goto case_78;
    }
#line 517
    if (arg == 99) {
#line 517
      goto case_99;
    }
#line 520
    if (arg == 66) {
#line 520
      goto case_66;
    }
#line 531
    if (arg == 76) {
#line 531
      goto case_76;
    }
#line 535
    if (arg == 90) {
#line 535
      goto case_90;
    }
#line 538
    if (arg == 69) {
#line 538
      goto case_69;
    }
#line 541
    if (arg == 67) {
#line 541
      goto case_67;
    }
#line 546
    if (arg == 68) {
#line 546
      goto case_68;
    }
#line 549
    if (arg == 83) {
#line 549
      goto case_83;
    }
#line 552
    if (arg == 106) {
#line 552
      goto case_106;
    }
#line 555
    if (arg == 107) {
#line 555
      goto case_107;
    }
#line 558
    if (arg == 70) {
#line 558
      goto case_70;
    }
#line 561
    if (arg == 256) {
#line 561
      goto case_256;
    }
#line 564
    if (arg == 257) {
#line 564
      goto case_257;
    }
#line 567
    if (arg == 258) {
#line 567
      goto case_258;
    }
#line 570
    if (arg == 259) {
#line 570
      goto case_259;
    }
#line 577
    if (arg == 260) {
#line 577
      goto case_260;
    }
#line 580
    if (arg == 261) {
#line 580
      goto case_261;
    }
#line 583
    if (arg == 262) {
#line 583
      goto case_262;
    }
#line 587
    if (arg == 263) {
#line 587
      goto case_263;
    }
#line 590
    if (arg == 264) {
#line 590
      goto case_264;
    }
#line 593
    if (arg == 265) {
#line 593
      goto case_265;
    }
#line 603
    if (arg == 266) {
#line 603
      goto case_266;
    }
#line 606
    if (arg == 50) {
#line 606
      goto case_50;
    }
#line 612
    if (arg == 267) {
#line 612
      goto case_267;
    }
#line 617
    if (arg == 268) {
#line 617
      goto case_268;
    }
#line 625
    if (arg == 269) {
#line 625
      goto case_269;
    }
#line 629
    if (arg == 88) {
#line 629
      goto case_88;
    }
#line 632
    goto switch_default;
    case_102: /* CIL Label */ 
    {
#line 342
    strncpy((char */* __restrict  */)(filename), (char const   */* __restrict  */)optarg,
            (size_t )255);
#line 343
    filename_flag = 1;
    }
#line 344
    goto switch_break;
    case_104: /* CIL Label */ 
    {
#line 346
    usage(0, 1);
    }
#line 347
    goto switch_break;
    case_115: /* CIL Label */ 
    {
#line 349
    tmp___0 = Strtoul((char const   *)optarg, 10);
#line 349
    source_port = (unsigned int )tmp___0;
    }
#line 350
    goto switch_break;
    case_100: /* CIL Label */ 
    {
#line 352
    tmp___1 = Strtoul((char const   *)optarg, 10);
#line 352
    dest_port = (unsigned int )tmp___1;
    }
#line 353
    goto switch_break;
    case_114: /* CIL Label */ 
    {
#line 355
    tmp___2 = Strtoul((char const   *)optarg, 10);
#line 355
    retry = (unsigned int )tmp___2;
    }
#line 356
    goto switch_break;
    case_116: /* CIL Label */ 
    {
#line 358
    tmp___3 = Strtoul((char const   *)optarg, 10);
#line 358
    timeout = (unsigned int )tmp___3;
    }
#line 359
    goto switch_break;
    case_105: /* CIL Label */ 
    {
#line 361
    strncpy((char */* __restrict  */)(interval_str), (char const   */* __restrict  */)optarg,
            (size_t )255);
#line 362
    interval_len = strlen((char const   *)(interval_str));
    }
#line 363
    if ((int )interval_str[interval_len - 1UL] == 117) {
      {
#line 364
      tmp___4 = Strtoul((char const   *)(interval_str), 10);
#line 364
      interval = (unsigned int )tmp___4;
      }
    } else
#line 365
    if ((int )interval_str[interval_len - 1UL] == 115) {
      {
#line 366
      tmp___5 = Strtoul((char const   *)(interval_str), 10);
#line 366
      interval = (unsigned int )(1000000UL * tmp___5);
      }
    } else {
      {
#line 368
      tmp___6 = Strtoul((char const   *)(interval_str), 10);
#line 368
      interval = (unsigned int )(1000UL * tmp___6);
      }
    }
#line 370
    goto switch_break;
    case_98: /* CIL Label */ 
    {
#line 372
    backoff_factor = atof((char const   *)optarg);
    }
#line 373
    goto switch_break;
    case_119: /* CIL Label */ 
    {
#line 375
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"--selectwait option ignored - no longer needed\n");
    }
#line 376
    goto switch_break;
    case_118: /* CIL Label */ 
#line 378
    verbose ++;
#line 379
    goto switch_break;
    case_108: /* CIL Label */ 
    {
#line 381
    tmp___7 = strcmp((char const   *)optarg, "none");
    }
#line 381
    if (tmp___7 == 0) {
#line 382
      ike_params.lifetime_data = (unsigned char *)((void *)0);
#line 383
      ike_params.lifetime_data_len = (size_t )0;
    } else {
      {
#line 385
      ike_params.lifetime_data = hex_or_num((char const   *)optarg, & ike_params.lifetime_data_len);
      }
    }
#line 388
    goto switch_break;
    case_122: /* CIL Label */ 
    {
#line 390
    tmp___8 = strcmp((char const   *)optarg, "none");
    }
#line 390
    if (tmp___8 == 0) {
#line 391
      ike_params.lifesize_data = (unsigned char *)((void *)0);
#line 392
      ike_params.lifesize_data_len = (size_t )0;
    } else {
      {
#line 394
      ike_params.lifesize_data = hex_or_num((char const   *)optarg, & ike_params.lifesize_data_len);
      }
    }
#line 397
    goto switch_break;
    case_109: /* CIL Label */ 
    {
#line 399
    ike_params.auth_method = name_or_number((char const   *)optarg, auth_map);
    }
#line 400
    goto switch_break;
    case_86: /* CIL Label */ 
    {
#line 402
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s\n\n",
            "ike-scan 1.9");
#line 403
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Copyright (C) 2003-2007 Roy Hills, NTA Monitor Ltd.\n");
#line 404
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"ike-scan comes with NO WARRANTY to the extent permitted by law.\n");
#line 405
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"You may redistribute copies of ike-scan under the terms of the GNU\n");
#line 406
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"General Public License.\n");
#line 407
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"For more information about these matters, see the file named COPYING.\n");
#line 408
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
#line 410
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s\n",
            rcsid___3);
#line 411
    isakmp_use_rcsid();
#line 412
    error_use_rcsid();
#line 413
    utils_use_rcsid();
#line 414
    wrappers_use_rcsid();
#line 415
    exit(0);
    }
#line 416
    goto switch_break;
    case_101: /* CIL Label */ 
    {
#line 418
    tmp___9 = strlen((char const   *)optarg);
    }
#line 418
    if (tmp___9 % 2UL) {
      {
#line 419
      err_msg("ERROR: Length of --vendor argument must be even (multiple of 2).");
      }
    }
    {
#line 420
    ike_params.vendor_id_flag = 1;
#line 421
    vid_data = hex2data((char const   *)optarg, & vid_data_len);
#line 422
    add_vid(0, (size_t *)((void *)0), vid_data, vid_data_len, 0U);
#line 423
    free((void *)vid_data);
    }
#line 424
    goto switch_break;
    case_97: /* CIL Label */ 
    {
#line 426
    strncpy((char */* __restrict  */)(trans_str), (char const   */* __restrict  */)optarg,
            (size_t )255);
#line 427
    (ike_params.trans_flag) ++;
    }
#line 428
    if ((int )trans_str[0] == 40) {
      {
#line 429
      attr = (unsigned char *)((void *)0);
#line 432
      attr = decode_transform((char const   *)(trans_str), & attr_len);
#line 433
      add_transform(0, (size_t *)((void *)0), ike_params.trans_id, attr, attr_len);
#line 434
      ike_params.advanced_trans_flag = 1;
      }
    } else {
      {
#line 436
      decode_trans_simple((char const   *)(trans_str), & trans_enc, & trans_keylen,
                          & trans_hash, & trans_auth, & trans_group);
#line 438
      add_trans_simple(0, (size_t *)((void *)0), trans_enc, trans_keylen, trans_hash,
                       trans_auth, trans_group, ike_params.lifetime_data, ike_params.lifetime_data_len,
                       ike_params.lifesize_data, ike_params.lifesize_data_len, ike_params.gss_id_flag,
                       ike_params.gss_data, ike_params.gss_data_len, ike_params.trans_id);
      }
    }
#line 448
    goto switch_break;
    case_111: /* CIL Label */ 
#line 450
    showbackoff_flag = 1;
#line 451
    if ((unsigned long )optarg == (unsigned long )((void *)0)) {
#line 452
      end_wait = 60000U;
    } else
#line 451
    if ((int )*optarg == 0) {
#line 452
      end_wait = 60000U;
    } else {
      {
#line 454
      tmp___10 = Strtoul((char const   *)optarg, 10);
#line 454
      end_wait = (unsigned int )(1000UL * tmp___10);
      }
    }
#line 456
    goto switch_break;
    case_117: /* CIL Label */ 
    {
#line 458
    tmp___11 = Strtoul((char const   *)optarg, 10);
#line 458
    pattern_fuzz = (unsigned int )tmp___11;
    }
#line 459
    goto switch_break;
    case_110: /* CIL Label */ 
#line 461
    if (ike_params.id_data) {
      {
#line 462
      err_msg("ERROR: You may only specify one identity payload with --id");
      }
    }
    {
#line 463
    ike_params.id_data = hex_or_str((char const   *)optarg, & ike_params.id_data_len);
    }
#line 464
    goto switch_break;
    case_121: /* CIL Label */ 
    {
#line 466
    tmp___12 = Strtoul((char const   *)optarg, 10);
#line 466
    ike_params.idtype = (unsigned int )tmp___12;
    }
#line 467
    goto switch_break;
    case_103: /* CIL Label */ 
    {
#line 469
    tmp___13 = Strtoul((char const   *)optarg, 10);
#line 469
    ike_params.dhgroup = (unsigned int )tmp___13;
    }
#line 470
    goto switch_break;
    case_112: /* CIL Label */ 
    {
#line 472
    strncpy((char */* __restrict  */)(patfile), (char const   */* __restrict  */)optarg,
            (size_t )255);
    }
#line 473
    goto switch_break;
    case_65: /* CIL Label */ 
#line 475
    ike_params.exchange_type = 4U;
#line 476
    goto switch_break;
    case_71: /* CIL Label */ 
    {
#line 478
    tmp___14 = strlen((char const   *)optarg);
    }
#line 478
    if (tmp___14 % 2UL) {
      {
#line 479
      err_msg("ERROR: Length of --gssid argument must be even (multiple of 2).");
      }
    }
    {
#line 481
    ike_params.gss_id_flag = 1;
#line 482
    ike_params.gss_data = hex2data((char const   *)optarg, & ike_params.gss_data_len);
    }
#line 483
    goto switch_break;
    case_73: /* CIL Label */ 
    {
#line 485
    strncpy((char */* __restrict  */)(vidfile), (char const   */* __restrict  */)optarg,
            (size_t )255);
    }
#line 486
    goto switch_break;
    case_113: /* CIL Label */ 
#line 488
    quiet = 1;
#line 489
    goto switch_break;
    case_77: /* CIL Label */ 
#line 491
    multiline = 1;
#line 492
    goto switch_break;
    case_82: /* CIL Label */ 
#line 494
    random_flag = 1;
#line 495
    goto switch_break;
    case_84: /* CIL Label */ 
#line 497
    if ((unsigned long )optarg == (unsigned long )((void *)0)) {
#line 498
      tcp_flag = 1;
    } else
#line 497
    if ((int )*optarg == 0) {
#line 498
      tcp_flag = 1;
    } else {
      {
#line 500
      tmp___15 = Strtoul((char const   *)optarg, 10);
#line 500
      tcp_flag = (int )tmp___15;
      }
    }
#line 502
    goto switch_break;
    case_80: /* CIL Label */ 
#line 504
    psk_crack_flag = 1;
#line 505
    if ((unsigned long )optarg == (unsigned long )((void *)0)) {
#line 506
      psk_crack_file[0] = (char )'\000';
    } else
#line 505
    if ((int )*optarg == 0) {
#line 506
      psk_crack_file[0] = (char )'\000';
    } else {
      {
#line 508
      strncpy((char */* __restrict  */)(psk_crack_file), (char const   */* __restrict  */)optarg,
              (size_t )255);
      }
    }
#line 510
    goto switch_break;
    case_79: /* CIL Label */ 
    {
#line 512
    tmp___16 = Strtoul((char const   *)optarg, 10);
#line 512
    tcp_connect_timeout = (unsigned int )tmp___16;
    }
#line 513
    goto switch_break;
    case_78: /* CIL Label */ 
#line 515
    no_dns_flag = 1;
#line 516
    goto switch_break;
    case_99: /* CIL Label */ 
    {
#line 518
    ike_params.nonce_data_len = Strtoul((char const   *)optarg, 10);
    }
#line 519
    goto switch_break;
    case_66: /* CIL Label */ 
    {
#line 521
    strncpy((char */* __restrict  */)(bandwidth_str), (char const   */* __restrict  */)optarg,
            (size_t )255);
#line 522
    bandwidth_len = strlen((char const   *)(bandwidth_str));
    }
#line 523
    if ((int )bandwidth_str[bandwidth_len - 1UL] == 77) {
      {
#line 524
      tmp___17 = Strtoul((char const   *)(bandwidth_str), 10);
#line 524
      bandwidth = (unsigned int )(1000000UL * tmp___17);
      }
    } else
#line 525
    if ((int )bandwidth_str[bandwidth_len - 1UL] == 75) {
      {
#line 526
      tmp___18 = Strtoul((char const   *)(bandwidth_str), 10);
#line 526
      bandwidth = (unsigned int )(1000UL * tmp___18);
      }
    } else {
      {
#line 528
      tmp___19 = Strtoul((char const   *)(bandwidth_str), 10);
#line 528
      bandwidth = (unsigned int )tmp___19;
      }
    }
#line 530
    goto switch_break;
    case_76: /* CIL Label */ 
    {
#line 532
    tmp___20 = strlen((char const   *)optarg);
#line 532
    tmp___21 = Malloc(tmp___20 + 1UL);
#line 532
    ike_params.header_length = (char *)tmp___21;
#line 533
    strcpy((char */* __restrict  */)ike_params.header_length, (char const   */* __restrict  */)optarg);
    }
#line 534
    goto switch_break;
    case_90: /* CIL Label */ 
    {
#line 536
    tmp___22 = Strtoul((char const   *)optarg, 0);
#line 536
    mbz_value = (int )tmp___22;
    }
#line 537
    goto switch_break;
    case_69: /* CIL Label */ 
    {
#line 539
    tmp___23 = Strtoul((char const   *)optarg, 0);
#line 539
    ike_params.header_version = (int )tmp___23;
    }
#line 540
    goto switch_break;
    case_67: /* CIL Label */ 
    {
#line 542
    tmp___24 = strlen((char const   *)optarg);
    }
#line 542
    if (tmp___24 % 2UL) {
      {
#line 543
      err_msg("ERROR: Length of --certreq argument must be even (multiple of 2).");
      }
    }
    {
#line 544
    ike_params.cr_data = hex2data((char const   *)optarg, & ike_params.cr_data_len);
    }
#line 545
    goto switch_break;
    case_68: /* CIL Label */ 
    {
#line 547
    tmp___25 = Strtoul((char const   *)optarg, 0);
#line 547
    ike_params.doi = (unsigned int )tmp___25;
    }
#line 548
    goto switch_break;
    case_83: /* CIL Label */ 
    {
#line 550
    tmp___26 = Strtoul((char const   *)optarg, 0);
#line 550
    ike_params.situation = (unsigned int )tmp___26;
    }
#line 551
    goto switch_break;
    case_106: /* CIL Label */ 
    {
#line 553
    tmp___27 = Strtoul((char const   *)optarg, 0);
#line 553
    ike_params.protocol = (unsigned int )tmp___27;
    }
#line 554
    goto switch_break;
    case_107: /* CIL Label */ 
    {
#line 556
    tmp___28 = Strtoul((char const   *)optarg, 0);
#line 556
    ike_params.trans_id = (unsigned int )tmp___28;
    }
#line 557
    goto switch_break;
    case_70: /* CIL Label */ 
    {
#line 559
    strncpy((char */* __restrict  */)(idfile), (char const   */* __restrict  */)optarg,
            (size_t )255);
    }
#line 560
    goto switch_break;
    case_256: /* CIL Label */ 
    {
#line 562
    tmp___29 = Strtoul((char const   *)optarg, 0);
#line 562
    ike_params.spi_size = (unsigned int )tmp___29;
    }
#line 563
    goto switch_break;
    case_257: /* CIL Label */ 
    {
#line 565
    tmp___30 = Strtoul((char const   *)optarg, 0);
#line 565
    ike_params.hdr_flags = (int )tmp___30;
    }
#line 566
    goto switch_break;
    case_258: /* CIL Label */ 
    {
#line 568
    tmp___31 = Strtoul((char const   *)optarg, 0);
#line 568
    ike_params.hdr_msgid = (unsigned int )tmp___31;
    }
#line 569
    goto switch_break;
    case_259: /* CIL Label */ 
    {
#line 571
    tmp___32 = strlen((char const   *)optarg);
    }
#line 571
    if (tmp___32 % 2UL) {
      {
#line 572
      err_msg("ERROR: Length of --cookie argument must be even (multiple of 2).");
      }
    }
    {
#line 573
    cookie_data = hex2data((char const   *)optarg, & cookie_data_len);
    }
#line 574
    if (cookie_data_len > 8UL) {
#line 575
      cookie_data_len = (size_t )8;
    }
#line 576
    goto switch_break;
    case_260: /* CIL Label */ 
    {
#line 578
    tmp___33 = Strtoul((char const   *)optarg, 0);
#line 578
    ike_params.exchange_type = (unsigned int )tmp___33;
    }
#line 579
    goto switch_break;
    case_261: /* CIL Label */ 
    {
#line 581
    tmp___34 = Strtoul((char const   *)optarg, 0);
#line 581
    ike_params.hdr_next_payload = (unsigned int )tmp___34;
    }
#line 582
    goto switch_break;
    case_262: /* CIL Label */ 
    {
#line 584
    strncpy((char */* __restrict  */)(pkt_filename), (char const   */* __restrict  */)optarg,
            (size_t )255);
#line 585
    pkt_filename_flag = 1;
    }
#line 586
    goto switch_break;
    case_263: /* CIL Label */ 
    {
#line 588
    tmp___35 = Strtoul((char const   *)optarg, 0);
#line 588
    random_seed = (unsigned int )tmp___35;
    }
#line 589
    goto switch_break;
    case_264: /* CIL Label */ 
#line 591
    timestamp_flag = 1;
#line 592
    goto switch_break;
    case_265: /* CIL Label */ 
    {
#line 594
    sourceip_flag = 1;
#line 595
    tmp___37 = strcmp((char const   *)optarg, "random");
    }
#line 595
    if (tmp___37 == 0) {
#line 596
      randsrc_flag = 1;
    } else {
      {
#line 598
      tmp___36 = inet_aton((char const   *)optarg, & src_ip_struct);
      }
#line 598
      if (! tmp___36) {
        {
#line 599
        err_msg("ERROR: %s is not a valid IP address", optarg);
        }
      }
#line 600
      src_ip_val = src_ip_struct.s_addr;
    }
#line 602
    goto switch_break;
    case_266: /* CIL Label */ 
#line 604
    shownum_flag = 1;
#line 605
    goto switch_break;
    case_50: /* CIL Label */ 
#line 607
    ike_params.ike_version = 2;
#line 608
    ike_params.header_version = 32;
#line 609
    ike_params.hdr_flags = 8;
#line 610
    ike_params.exchange_type = 34U;
#line 611
    goto switch_break;
    case_267: /* CIL Label */ 
#line 613
    nat_t_flag = 1;
#line 614
    source_port = 4500U;
#line 615
    dest_port = 4500U;
#line 616
    goto switch_break;
    case_268: /* CIL Label */ 
    {
#line 618
    tmp___38 = strlen((char const   *)optarg);
    }
#line 618
    if (tmp___38 % 2UL) {
      {
#line 619
      err_msg("ERROR: Length of --rcookie argument must be even (multiple of 2).");
      }
    }
    {
#line 620
    ike_params.rcookie_data = hex2data((char const   *)optarg, & ike_params.rcookie_data_len);
    }
#line 622
    if (ike_params.rcookie_data_len > 8UL) {
#line 623
      ike_params.rcookie_data_len = (size_t )8;
    }
#line 624
    goto switch_break;
    case_269: /* CIL Label */ 
    {
#line 626
    strncpy((char */* __restrict  */)(pkt_filename), (char const   */* __restrict  */)optarg,
            (size_t )255);
#line 627
    pkt_read_filename_flag = 1;
    }
#line 628
    goto switch_break;
    case_88: /* CIL Label */ 
    {
#line 630
    tmp___39 = Strtoul((char const   *)optarg, 0);
#line 630
    experimental_value = (unsigned int )tmp___39;
    }
#line 631
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 633
    usage(1, 0);
    }
#line 634
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 642
  if (! random_seed) {
    {
#line 645
    Gettimeofday(& tv);
#line 646
    tmp___40 = getpid();
#line 646
    random_seed = (unsigned int )tv.tv_usec ^ (unsigned int )tmp___40;
    }
  }
  {
#line 648
  init_genrand((unsigned long )random_seed);
  }
#line 652
  if (tcp_flag) {
    {
#line 653
    on = 1;
#line 655
    sockfd = socket(2, 1, 0);
    }
#line 655
    if (sockfd < 0) {
      {
#line 656
      err_sys("ERROR: socket");
      }
    }
    {
#line 657
    tmp___41 = setsockopt(sockfd, 6, 1, (void const   *)(& on), (socklen_t )sizeof(on));
    }
#line 657
    if (tmp___41 < 0) {
      {
#line 658
      err_sys("ERROR: setsockopt() failed");
      }
    }
    {
#line 659
    tmp___42 = setsockopt(sockfd, 1, 2, (void const   *)(& on), (socklen_t )sizeof(on));
    }
#line 659
    if (tmp___42 < 0) {
      {
#line 660
      err_sys("ERROR: setsockopt() failed");
      }
    }
  } else
#line 661
  if (sourceip_flag) {
    {
#line 662
    on___0 = 1;
#line 664
    sockfd = socket(2, 3, 255);
    }
#line 664
    if (sockfd < 0) {
      {
#line 665
      err_sys("socket");
      }
    }
    {
#line 666
    tmp___43 = setsockopt(sockfd, 0, 3, (void const   *)(& on___0), (socklen_t )sizeof(on___0));
    }
#line 666
    if (tmp___43 != 0) {
      {
#line 667
      err_sys("setsockopt");
      }
    }
    {
#line 668
    tmp___44 = setsockopt(sockfd, 1, 6, (void const   *)(& on___0), (socklen_t )sizeof(on___0));
    }
#line 668
    if (tmp___44 != 0) {
      {
#line 669
      err_sys("setsockopt");
      }
    }
  } else {
    {
#line 671
    on___1 = 1;
#line 673
    sockfd = socket(2, 2, 0);
    }
#line 673
    if (sockfd < 0) {
      {
#line 674
      err_sys("ERROR: socket");
      }
    }
    {
#line 675
    tmp___45 = setsockopt(sockfd, 1, 6, (void const   *)(& on___1), (socklen_t )sizeof(on___1));
    }
#line 675
    if (tmp___45 != 0) {
      {
#line 676
      err_sys("setsockopt");
      }
    }
  }
  {
#line 679
  memset((void *)(& sa_local), '\000', sizeof(sa_local));
#line 680
  sa_local.sin_family = (sa_family_t )2;
#line 681
  sa_local.sin_addr.s_addr = htonl((in_addr_t )0);
#line 682
  sa_local.sin_port = htons((uint16_t )source_port);
#line 684
  tmp___48 = bind(sockfd, (struct sockaddr  const  *)((struct sockaddr *)(& sa_local)),
                  (socklen_t )sizeof(sa_local));
  }
#line 684
  if (tmp___48 < 0) {
    {
#line 685
    warn_msg("ERROR: Could not bind network socket to local port %u", source_port);
#line 686
    tmp___46 = __errno_location();
    }
#line 686
    if (*tmp___46 == 13) {
      {
#line 687
      warn_msg("You need to be root, or ike-scan must be suid root to bind to ports below 1024.");
      }
    }
    {
#line 688
    tmp___47 = __errno_location();
    }
#line 688
    if (*tmp___47 == 98) {
      {
#line 689
      warn_msg("Only one process may bind to the source port at any one time.");
      }
    }
    {
#line 690
    err_sys("ERROR: bind");
    }
  }
  {
#line 695
  tmp___49 = getuid();
#line 695
  tmp___50 = setuid(tmp___49);
  }
#line 695
  if (tmp___50 < 0) {
    {
#line 696
    err_sys("setuid");
    }
  }
#line 702
  if (! filename_flag) {
#line 703
    if (argc - optind < 1) {
      {
#line 704
      usage(1, 0);
      }
    }
  }
#line 709
  if ((int )idfile[0] != 0) {
    {
#line 710
    idstrings = load_id_strings(idfile);
    }
  }
#line 716
  if (filename_flag) {
    {
#line 721
    tmp___51 = strcmp((char const   *)(filename), "-");
    }
#line 721
    if (tmp___51 == 0) {
#line 722
      fp = stdin;
    } else {
      {
#line 724
      fp = fopen((char const   */* __restrict  */)(filename), (char const   */* __restrict  */)"r");
      }
#line 724
      if ((unsigned long )fp == (unsigned long )((void *)0)) {
        {
#line 725
        err_sys("ERROR: fopen");
        }
      }
    }
    {
#line 729
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 729
      tmp___53 = fgets((char */* __restrict  */)(line), 255, (FILE */* __restrict  */)fp);
      }
#line 729
      if (! tmp___53) {
#line 729
        goto while_break___1;
      }
#line 730
      cp = line;
      {
#line 730
      while (1) {
        while_continue___2: /* CIL Label */ ;
        {
#line 730
        tmp___52 = __ctype_b_loc();
        }
#line 730
        if ((int const   )*(*tmp___52 + (int )((unsigned char )*cp)) & 8192) {
#line 730
          goto while_break___2;
        } else
#line 730
        if (! ((int )*cp != 0)) {
#line 730
          goto while_break___2;
        }
#line 730
        cp ++;
      }
      while_break___2: /* CIL Label */ ;
      }
      {
#line 732
      *cp = (char )'\000';
#line 733
      add_host_pattern((char const   *)(line), timeout, & num_hosts, cookie_data,
                       cookie_data_len);
      }
    }
    while_break___1: /* CIL Label */ ;
    }
#line 736
    if ((unsigned long )fp != (unsigned long )stdin) {
      {
#line 737
      fclose(fp);
      }
    }
  } else {
#line 739
    argv += optind;
    {
#line 740
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 740
      if (! *argv) {
#line 740
        goto while_break___3;
      }
      {
#line 741
      add_host_pattern((char const   *)*argv, timeout, & num_hosts, cookie_data, cookie_data_len);
#line 743
      argv ++;
      }
    }
    while_break___3: /* CIL Label */ ;
    }
  }
#line 751
  if (tcp_flag) {
    {
#line 759
    act.__sigaction_handler.sa_handler = & sig_alarm;
#line 760
    sigemptyset(& act.sa_mask);
#line 761
    act.sa_flags = 0;
#line 762
    sigaction(14, (struct sigaction  const  */* __restrict  */)(& act), (struct sigaction */* __restrict  */)(& oact));
#line 766
    alarm(tcp_connect_timeout);
#line 770
    memset((void *)(& sa_tcp), '\000', sizeof(sa_tcp));
#line 771
    sa_tcp.sin_family = (sa_family_t )2;
#line 772
    sa_tcp.sin_addr.s_addr = helist->addr.s_addr;
#line 773
    sa_tcp.sin_port = htons((uint16_t )dest_port);
#line 774
    sa_tcp_len = (socklen_t )sizeof(sa_tcp);
#line 775
    tmp___56 = connect(sockfd, (struct sockaddr  const  *)((struct sockaddr *)(& sa_tcp)),
                       sa_tcp_len);
    }
#line 775
    if (tmp___56 != 0) {
      {
#line 776
      tmp___55 = __errno_location();
      }
#line 776
      if (*tmp___55 == 4) {
        {
#line 777
        tmp___54 = __errno_location();
#line 777
        *tmp___54 = 110;
        }
      }
      {
#line 778
      err_sys("ERROR: TCP connect");
      }
    }
    {
#line 783
    alarm(0U);
    }
  }
#line 789
  if (showbackoff_flag) {
    {
#line 790
    load_backoff_patterns((char const   *)(patfile), pattern_fuzz);
    }
  }
  {
#line 795
  load_vid_patterns((char const   *)(vidfile));
  }
#line 799
  if (! num_hosts) {
    {
#line 800
    err_msg("ERROR: No hosts to process.");
    }
  }
#line 804
  if (pkt_filename_flag) {
    {
#line 805
    write_pkt_to_file = open((char const   *)(pkt_filename), 577, 438);
    }
#line 806
    if (write_pkt_to_file == -1) {
      {
#line 807
      err_sys("open %s", pkt_filename);
      }
    }
  }
#line 812
  if (pkt_read_filename_flag) {
    {
#line 813
    read_pkt_from_file = open((char const   *)(pkt_filename), 0);
    }
#line 814
    if (read_pkt_from_file == -1) {
      {
#line 815
      err_sys("open %s", pkt_filename);
      }
    }
  }
#line 821
  if (cookie_data) {
#line 821
    if (num_hosts > 1U) {
      {
#line 822
      err_msg("ERROR: You can only specify one target host with the --cookie option.");
      }
    }
  }
#line 823
  if (tcp_flag) {
#line 823
    if (num_hosts > 1U) {
      {
#line 824
      err_msg("ERROR: You can only specify one target host with the --tcp option.");
      }
    }
  }
#line 825
  if ((int )patfile[0] != 0) {
#line 825
    if (! showbackoff_flag) {
      {
#line 826
      warn_msg("WARNING: Specifying a backoff pattern file with --patterns or -p does not\n         have any effect unless you also specify --showbackoff or -o\n");
      }
    }
  }
#line 828
  if (ike_params.id_data) {
#line 828
    if (ike_params.exchange_type != 4U) {
      {
#line 829
      warn_msg("WARNING: Specifying an identification payload with --id or -n does not have\n         any effect unless you also specify aggressive mode with --aggressive\n         or -A\n");
      }
    }
  }
#line 832
  if (ike_params.idtype != 3U) {
#line 832
    if (ike_params.exchange_type != 4U) {
      {
#line 834
      warn_msg("WARNING: Specifying an idtype payload with --idtype or -y does not have any\n         effect unless you also specify aggressive mode with --aggressive or -A\n");
      }
    }
  }
#line 836
  if (ike_params.nonce_data_len != 20UL) {
#line 836
    if (ike_params.exchange_type != 4U) {
#line 836
      if (ike_params.ike_version == 1) {
        {
#line 839
        warn_msg("WARNING: Specifying the nonce payload length with --noncelen or -c does not\n         have any effect unless you also specify aggressive mode with\n         --aggressive or -A, or IKEv2 with --ikev2 or -2\n");
        }
      }
    }
  }
#line 842
  if (ike_params.dhgroup != 2U) {
#line 842
    if (ike_params.exchange_type != 4U) {
#line 842
      if (ike_params.ike_version == 1) {
        {
#line 845
        warn_msg("WARNING: Specifying the DH Group with --dhgroup or -g does not have any effect\n         unless you also specify aggressive mode with --aggressive or -A, or\n         IKEv2 with --ikev2 or -2\n");
        }
      }
    }
  }
#line 848
  if (psk_crack_flag) {
#line 848
    if (ike_params.exchange_type != 4U) {
      {
#line 849
      warn_msg("WARNING: The --pskcrack (-P) option is only relevant for aggressive mode.\n");
#line 850
      psk_crack_flag = 0;
      }
    }
  }
#line 852
  if (psk_crack_flag) {
#line 852
    if (num_hosts > 1U) {
      {
#line 853
      err_msg("ERROR: You can only specify one target host with the --pskcrack (-P) option.");
      }
    }
  }
#line 854
  if (interval) {
#line 854
    if (bandwidth != 56000U) {
      {
#line 855
      err_msg("ERROR: You cannot specify both --bandwidth and --interval.");
      }
    }
  }
#line 856
  if (ike_params.trans_flag != 0) {
#line 856
    if (ike_params.ike_version == 2) {
      {
#line 857
      warn_msg("WARNING: IKEv2 does not support custom proposals.");
      }
    }
  }
  {
#line 861
  tmp___57 = Malloc((unsigned long )num_hosts * sizeof(host_entry *));
#line 861
  helistptr = (host_entry **)tmp___57;
#line 862
  hostno = 0;
  }
  {
#line 862
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 862
    if (! ((unsigned int )hostno < num_hosts)) {
#line 862
      goto while_break___4;
    }
#line 863
    *(helistptr + hostno) = helist + hostno;
#line 862
    hostno ++;
  }
  while_break___4: /* CIL Label */ ;
  }
#line 868
  if (random_flag) {
#line 873
    i = (int )(num_hosts - 1U);
    {
#line 873
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 873
      if (! (i > 0)) {
#line 873
        goto while_break___5;
      }
      {
#line 874
      tmp___58 = genrand_real2();
#line 874
      r = (int )(tmp___58 * (double )i);
#line 875
      temp = *(helistptr + i);
#line 876
      *(helistptr + i) = *(helistptr + r);
#line 877
      *(helistptr + r) = temp;
#line 873
      i --;
      }
    }
    while_break___5: /* CIL Label */ ;
    }
  }
  {
#line 885
  live_count = num_hosts;
#line 886
  cursor = helistptr;
#line 887
  last_packet_time.tv_sec = (__time_t )0;
#line 888
  last_packet_time.tv_usec = (__suseconds_t )0;
#line 889
  Gettimeofday(& last_recv_time);
#line 890
  packet_out = initialise_ike_packet(& packet_out_len, & ike_params);
  }
#line 895
  if (! interval) {
#line 896
    interval = (unsigned int )((((packet_out_len + 28UL) * 8UL) * 1000000UL) / (unsigned long )bandwidth);
#line 898
    if (verbose) {
      {
#line 899
      warn_msg("DEBUG: pkt len=%u bytes, bandwidth=%u bps, int=%u us", packet_out_len,
               bandwidth, interval);
      }
    }
  }
  {
#line 906
  printf((char const   */* __restrict  */)"Starting %s with %u hosts (http://www.nta-monitor.com/tools/ike-scan/)\n",
         "ike-scan 1.9", num_hosts);
  }
#line 910
  if (verbose > 2) {
    {
#line 911
    dump_list(num_hosts);
    }
#line 912
    if (showbackoff_flag) {
      {
#line 913
      dump_backoff(pattern_fuzz);
      }
    }
    {
#line 914
    dump_vid();
    }
  }
#line 925
  reset_cum_err = 1;
#line 926
  req_interval = (int )interval;
  {
#line 927
  while (1) {
    while_continue___6: /* CIL Label */ ;
#line 927
    if (! live_count) {
#line 927
      if (showbackoff_flag) {
#line 927
        if (sa_responders) {
#line 927
          if (! (end_timediff < (unsigned long )end_wait)) {
#line 927
            goto while_break___6;
          }
        } else {
#line 927
          goto while_break___6;
        }
      } else {
#line 927
        goto while_break___6;
      }
    }
    {
#line 929
    s_err = 0;
#line 934
    Gettimeofday(& now);
#line 935
    timeval_diff((struct timeval  const  *)(& now), (struct timeval  const  *)(& last_recv_time),
                 & diff);
#line 936
    end_timediff = (unsigned long )(1000L * diff.tv_sec + diff.tv_usec / 1000L);
#line 941
    timeval_diff((struct timeval  const  *)(& now), (struct timeval  const  *)(& last_packet_time),
                 & diff);
#line 942
    loop_timediff = 1000000UL * (unsigned long )diff.tv_sec + (unsigned long )diff.tv_usec;
    }
#line 943
    if (loop_timediff >= (unsigned long )req_interval) {
      {
#line 949
      timeval_diff((struct timeval  const  *)(& now), (struct timeval  const  *)(& (*cursor)->last_send_time),
                   & diff);
#line 950
      host_timediff = 1000000UL * (unsigned long )diff.tv_sec + (unsigned long )diff.tv_usec;
      }
#line 951
      if (host_timediff >= (unsigned long )(*cursor)->timeout) {
#line 951
        if ((*cursor)->live) {
#line 952
          if (reset_cum_err) {
#line 953
            s_err = 0;
#line 954
            cum_err = 0;
#line 955
            req_interval = (int )interval;
#line 956
            reset_cum_err = 0;
          } else {
#line 958
            cum_err = (int )((unsigned long )cum_err + (loop_timediff - (unsigned long )interval));
#line 959
            if (req_interval > cum_err) {
#line 960
              req_interval -= cum_err;
            } else {
#line 962
              req_interval = 0;
            }
          }
#line 965
          select_timeout = req_interval;
#line 974
          if (verbose) {
#line 974
            if ((unsigned int )(*cursor)->num_sent > pass_no) {
              {
#line 975
              pass_no ++;
#line 975
              warn_msg("---\tPass %d of %u completed", pass_no, retry);
              }
            }
          }
#line 976
          if ((unsigned int )(*cursor)->num_sent >= retry) {
#line 977
            if (verbose > 1) {
              {
#line 978
              tmp___59 = inet_ntoa((*cursor)->addr);
#line 978
              warn_msg("---\tRemoving host entry %u (%s) - Timeout", (*cursor)->n,
                       tmp___59);
              }
            }
            {
#line 979
            remove_host(cursor, & live_count, num_hosts);
            }
#line 980
            if (first_timeout) {
              {
#line 981
              timeval_diff((struct timeval  const  *)(& now), (struct timeval  const  *)(& (*cursor)->last_send_time),
                           & diff);
#line 982
              host_timediff = 1000000UL * (unsigned long )diff.tv_sec + (unsigned long )diff.tv_usec;
              }
              {
#line 984
              while (1) {
                while_continue___7: /* CIL Label */ ;
#line 984
                if (host_timediff >= (unsigned long )(*cursor)->timeout) {
#line 984
                  if (! live_count) {
#line 984
                    goto while_break___7;
                  }
                } else {
#line 984
                  goto while_break___7;
                }
#line 985
                if ((*cursor)->live) {
#line 986
                  if (verbose > 1) {
                    {
#line 987
                    tmp___60 = inet_ntoa((*cursor)->addr);
#line 987
                    warn_msg("---\tRemoving host %u (%s) - Timeout", (*cursor)->n,
                             tmp___60);
                    }
                  }
                  {
#line 989
                  remove_host(cursor, & live_count, num_hosts);
                  }
                } else {
                  {
#line 991
                  advance_cursor(live_count, num_hosts);
                  }
                }
                {
#line 993
                timeval_diff((struct timeval  const  *)(& now), (struct timeval  const  *)(& (*cursor)->last_send_time),
                             & diff);
#line 994
                host_timediff = 1000000UL * (unsigned long )diff.tv_sec + (unsigned long )diff.tv_usec;
                }
              }
              while_break___7: /* CIL Label */ ;
              }
#line 997
              first_timeout = 0;
            }
            {
#line 999
            Gettimeofday(& last_packet_time);
            }
          } else {
#line 1001
            if ((*cursor)->num_sent) {
#line 1002
              (*cursor)->timeout = (unsigned int )((double )(*cursor)->timeout * backoff_factor);
            }
            {
#line 1003
            send_packet(sockfd, packet_out, packet_out_len, *cursor, source_port,
                        dest_port, & last_packet_time);
#line 1005
            advance_cursor(live_count, num_hosts);
            }
          }
        } else {
#line 951
          goto _L;
        }
      } else {
        _L: /* CIL Label */ 
#line 1012
        if (live_count) {
#line 1013
          select_timeout = (int )((unsigned long )(*cursor)->timeout - host_timediff);
        } else {
#line 1015
          select_timeout = (int )interval;
        }
#line 1016
        reset_cum_err = 1;
      }
    } else {
#line 1019
      select_timeout = (int )((unsigned long )req_interval - loop_timediff);
    }
    {
#line 1026
    n = recvfrom_wto(sockfd, packet_in, (size_t )65507, (struct sockaddr *)(& sa_peer),
                     select_timeout);
    }
#line 1028
    if (n != -1) {
      {
#line 1035
      temp_cursor = find_host_by_cookie(cursor, packet_in, n, num_hosts);
      }
#line 1036
      if (temp_cursor) {
        {
#line 1040
        add_recv_time(temp_cursor, & last_recv_time);
        }
#line 1041
        if (verbose > 1) {
          {
#line 1042
          tmp___61 = inet_ntoa(sa_peer.sin_addr);
#line 1042
          warn_msg("---\tReceived packet #%u from %s", (int )temp_cursor->num_recv,
                   tmp___61);
          }
        }
#line 1043
        if (temp_cursor->live) {
          {
#line 1044
          display_packet(n, packet_in, temp_cursor, & sa_peer.sin_addr, & sa_responders,
                         & notify_responders, quiet, multiline);
          }
#line 1047
          if (verbose > 1) {
            {
#line 1048
            tmp___62 = inet_ntoa(sa_peer.sin_addr);
#line 1048
            warn_msg("---\tRemoving host entry %u (%s) - Received %d bytes", temp_cursor->n,
                     tmp___62, n);
            }
          }
          {
#line 1049
          remove_host(& temp_cursor, & live_count, num_hosts);
          }
        }
      } else
#line 1057
      if (verbose) {
#line 1057
        if ((unsigned long )n >= sizeof(hdr_in)) {
          {
#line 1059
          memcpy((void */* __restrict  */)(& hdr_in), (void const   */* __restrict  */)(packet_in),
                 sizeof(hdr_in));
#line 1060
          cp___0 = hexstring((unsigned char const   *)((unsigned char *)(hdr_in.isa_icookie)),
                             sizeof(hdr_in.isa_icookie));
#line 1062
          tmp___63 = inet_ntoa(sa_peer.sin_addr);
#line 1062
          warn_msg("---\tIgnoring %d bytes from %s with unknown cookie %s", n, tmp___63,
                   cp___0);
#line 1064
          free((void *)cp___0);
          }
        }
      }
    }
  }
  while_break___6: /* CIL Label */ ;
  }
  {
#line 1069
  close(sockfd);
  }
#line 1070
  if (write_pkt_to_file) {
    {
#line 1071
    close(write_pkt_to_file);
    }
  }
  {
#line 1073
  close(read_pkt_from_file);
#line 1078
  printf((char const   */* __restrict  */)"\n");
  }
#line 1079
  if (showbackoff_flag) {
#line 1079
    if (sa_responders) {
      {
#line 1080
      dump_times(num_hosts);
      }
    }
  }
#line 1085
  if (psk_crack_flag) {
#line 1085
    if ((unsigned long )psk_values.hash_r != (unsigned long )((void *)0)) {
      {
#line 1086
      print_psk_crack_values((char const   *)(psk_crack_file));
      }
    }
  }
  {
#line 1091
  Gettimeofday(& end_time);
#line 1092
  timeval_diff((struct timeval  const  *)(& end_time), (struct timeval  const  *)(& start_time),
               & elapsed_time);
#line 1093
  elapsed_seconds = ((double )(elapsed_time.tv_sec * 1000L) + (double )elapsed_time.tv_usec / 1000.0) / 1000.0;
#line 1097
  info_syslog("Ending: %u hosts scanned in %.3f seconds (%.2f hosts/sec). %u returned handshake; %u returned notify",
              num_hosts, elapsed_seconds, (double )num_hosts / elapsed_seconds, sa_responders,
              notify_responders);
#line 1101
  printf((char const   */* __restrict  */)"Ending %s: %u hosts scanned in %.3f seconds (%.2f hosts/sec).  %u returned handshake; %u returned notify\n",
         "ike-scan 1.9", num_hosts, elapsed_seconds, (double )num_hosts / elapsed_seconds,
         sa_responders, notify_responders);
  }
#line 1105
  return (0);
}
}
#line 1141 "/home/june/repo/benchmarks/collector/temp/ike-scan-1.9/ike-scan.c"
static int first_call___0  =    1;
#line 1142 "/home/june/repo/benchmarks/collector/temp/ike-scan-1.9/ike-scan.c"
static regex_t iprange_pat  ;
#line 1143 "/home/june/repo/benchmarks/collector/temp/ike-scan-1.9/ike-scan.c"
static regex_t ipslash_pat  ;
#line 1144 "/home/june/repo/benchmarks/collector/temp/ike-scan-1.9/ike-scan.c"
static char const   *iprange_pat_str  =    "[0-9]+\\.[0-9]+\\.[0-9]+\\.[0-9]+-[0-9]+\\.[0-9]+\\.[0-9]+\\.[0-9]+";
#line 1146 "/home/june/repo/benchmarks/collector/temp/ike-scan-1.9/ike-scan.c"
static char const   *ipslash_pat_str  =    "[0-9]+\\.[0-9]+\\.[0-9]+\\.[0-9]+/[0-9]+";
#line 1128 "/home/june/repo/benchmarks/collector/temp/ike-scan-1.9/ike-scan.c"
void add_host_pattern(char const   *pattern , unsigned int timeout , unsigned int *num_hosts ,
                      unsigned char *cookie_data , size_t cookie_data_len ) 
{ 
  char *patcopy ;
  struct in_addr in_val ;
  unsigned int numbits ;
  char *cp ;
  uint32_t ipnet_val ;
  uint32_t network ;
  uint32_t mask ;
  unsigned long hoststart ;
  unsigned long hostend ;
  unsigned int i ;
  int result ;
  char errbuf[255] ;
  size_t errlen ;
  char errbuf___0[255] ;
  size_t errlen___0 ;
  size_t tmp ;
  void *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  unsigned long tmp___3 ;
  uint32_t hostip ;
  int b1 ;
  int b2 ;
  int b3 ;
  int b4 ;
  char ipstr[16] ;
  char *tmp___4 ;
  int tmp___5 ;
  uint32_t tmp___6 ;
  int tmp___7 ;
  uint32_t tmp___8 ;
  int b1___0 ;
  int b2___0 ;
  int b3___0 ;
  int b4___0 ;
  char ipstr___0[16] ;
  int tmp___9 ;
  int tmp___10 ;

  {
#line 1151
  if (first_call___0) {
    {
#line 1154
    first_call___0 = 0;
#line 1155
    result = regcomp((regex_t */* __restrict  */)(& iprange_pat), (char const   */* __restrict  */)iprange_pat_str,
                     1 | (((1 << 1) << 1) << 1));
    }
#line 1155
    if (result) {
      {
#line 1159
      errlen = regerror(result, (regex_t const   */* __restrict  */)(& iprange_pat),
                        (char */* __restrict  */)(errbuf), (size_t )255);
#line 1160
      err_msg("ERROR: cannot compile regex pattern \"%s\": %s", iprange_pat_str, errbuf);
      }
    }
    {
#line 1163
    result = regcomp((regex_t */* __restrict  */)(& ipslash_pat), (char const   */* __restrict  */)ipslash_pat_str,
                     1 | (((1 << 1) << 1) << 1));
    }
#line 1163
    if (result) {
      {
#line 1167
      errlen___0 = regerror(result, (regex_t const   */* __restrict  */)(& ipslash_pat),
                            (char */* __restrict  */)(errbuf___0), (size_t )255);
#line 1168
      err_msg("ERROR: cannot compile regex pattern \"%s\": %s", ipslash_pat_str, errbuf___0);
      }
    }
  }
  {
#line 1175
  tmp = strlen(pattern);
#line 1175
  tmp___0 = Malloc(tmp + 1UL);
#line 1175
  patcopy = (char *)tmp___0;
#line 1176
  strcpy((char */* __restrict  */)patcopy, (char const   */* __restrict  */)pattern);
#line 1178
  tmp___10 = regexec((regex_t const   */* __restrict  */)(& ipslash_pat), (char const   */* __restrict  */)patcopy,
                     (size_t )0, (regmatch_t */* __restrict  */)((void *)0), 0);
  }
#line 1178
  if (tmp___10) {
    {
#line 1227
    tmp___9 = regexec((regex_t const   */* __restrict  */)(& iprange_pat), (char const   */* __restrict  */)patcopy,
                      (size_t )0, (regmatch_t */* __restrict  */)((void *)0), 0);
    }
#line 1227
    if (tmp___9) {
      {
#line 1255
      add_host((char const   *)patcopy, timeout, num_hosts, cookie_data, cookie_data_len);
      }
    } else {
      {
#line 1231
      cp = strchr((char const   *)patcopy, '-');
#line 1232
      tmp___4 = cp;
#line 1232
      cp ++;
#line 1232
      *tmp___4 = (char )'\000';
#line 1233
      tmp___5 = inet_aton((char const   *)patcopy, & in_val);
      }
#line 1233
      if (! tmp___5) {
        {
#line 1234
        err_msg("ERROR: %s is not a valid IP address", patcopy);
        }
      }
      {
#line 1235
      tmp___6 = ntohl(in_val.s_addr);
#line 1235
      hoststart = (unsigned long )tmp___6;
#line 1236
      tmp___7 = inet_aton((char const   *)cp, & in_val);
      }
#line 1236
      if (! tmp___7) {
        {
#line 1237
        err_msg("ERROR: %s is not a valid IP address", cp);
        }
      }
      {
#line 1238
      tmp___8 = ntohl(in_val.s_addr);
#line 1238
      hostend = (unsigned long )tmp___8;
#line 1243
      i = (unsigned int )hoststart;
      }
      {
#line 1243
      while (1) {
        while_continue: /* CIL Label */ ;
#line 1243
        if (! ((unsigned long )i <= hostend)) {
#line 1243
          goto while_break;
        }
        {
#line 1247
        b1___0 = (int )((i & 4278190080U) >> 24);
#line 1248
        b2___0 = (int )((i & 16711680U) >> 16);
#line 1249
        b3___0 = (int )((i & 65280U) >> 8);
#line 1250
        b4___0 = (int )(i & 255U);
#line 1251
        sprintf((char */* __restrict  */)(ipstr___0), (char const   */* __restrict  */)"%d.%d.%d.%d",
                b1___0, b2___0, b3___0, b4___0);
#line 1252
        add_host((char const   *)(ipstr___0), timeout, num_hosts, cookie_data, cookie_data_len);
#line 1243
        i ++;
        }
      }
      while_break: /* CIL Label */ ;
      }
    }
  } else {
    {
#line 1182
    cp = strchr((char const   *)patcopy, '/');
#line 1183
    tmp___1 = cp;
#line 1183
    cp ++;
#line 1183
    *tmp___1 = (char )'\000';
#line 1184
    tmp___2 = inet_aton((char const   *)patcopy, & in_val);
    }
#line 1184
    if (! tmp___2) {
      {
#line 1185
      err_msg("ERROR: %s is not a valid IP address", patcopy);
      }
    }
    {
#line 1186
    ipnet_val = ntohl(in_val.s_addr);
#line 1187
    tmp___3 = Strtoul((char const   *)cp, 10);
#line 1187
    numbits = (unsigned int )tmp___3;
    }
#line 1188
    if (numbits < 3U) {
      {
#line 1189
      err_msg("ERROR: Number of bits in %s must be between 3 and 32", pattern);
      }
    } else
#line 1188
    if (numbits > 32U) {
      {
#line 1189
      err_msg("ERROR: Number of bits in %s must be between 3 and 32", pattern);
      }
    }
#line 1194
    mask = (uint32_t )0;
#line 1195
    i = 0U;
    {
#line 1195
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1195
      if (! (i < numbits)) {
#line 1195
        goto while_break___0;
      }
#line 1196
      mask += (uint32_t )(1 << i);
#line 1195
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1197
    mask <<= 32U - i;
#line 1201
    network = ipnet_val & mask;
#line 1202
    if (network != ipnet_val) {
      {
#line 1203
      warn_msg("WARNING: host part of %s is non-zero", pattern);
      }
    }
#line 1208
    hoststart = 0UL;
#line 1209
    hostend = (unsigned long )((1 << (32U - numbits)) - 1);
#line 1214
    i = (unsigned int )hoststart;
    {
#line 1214
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1214
      if (! ((unsigned long )i <= hostend)) {
#line 1214
        goto while_break___1;
      }
      {
#line 1219
      hostip = network + i;
#line 1220
      b1 = (int )((hostip & 4278190080U) >> 24);
#line 1221
      b2 = (int )((hostip & 16711680U) >> 16);
#line 1222
      b3 = (int )((hostip & 65280U) >> 8);
#line 1223
      b4 = (int )(hostip & 255U);
#line 1224
      sprintf((char */* __restrict  */)(ipstr), (char const   */* __restrict  */)"%d.%d.%d.%d",
              b1, b2, b3, b4);
#line 1225
      add_host((char const   *)(ipstr), timeout, num_hosts, cookie_data, cookie_data_len);
#line 1214
      i ++;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
  }
  {
#line 1257
  free((void *)patcopy);
  }
#line 1258
  return;
}
}
#line 1281 "/home/june/repo/benchmarks/collector/temp/ike-scan-1.9/ike-scan.c"
static int num_left  =    0;
#line 1273 "/home/june/repo/benchmarks/collector/temp/ike-scan-1.9/ike-scan.c"
void add_host(char const   *name , unsigned int timeout , unsigned int *num_hosts ,
              unsigned char *cookie_data , size_t cookie_data_len ) 
{ 
  struct hostent *hp ;
  host_entry *he ;
  struct in_addr inp ;
  char str[255] ;
  struct timeval now ;
  int tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  char *tmp___2 ;
  size_t tmp___3 ;
  unsigned char *tmp___4 ;

  {
#line 1276
  hp = (struct hostent *)((void *)0);
#line 1283
  if (no_dns_flag) {
    {
#line 1284
    tmp = inet_aton(name, & inp);
    }
#line 1284
    if (! tmp) {
      {
#line 1285
      warn_msg("WARNING: inet_aton failed for \"%s\" - target ignored", name);
      }
#line 1287
      return;
    }
  } else {
    {
#line 1290
    hp = gethostbyname(name);
    }
#line 1290
    if ((unsigned long )hp == (unsigned long )((void *)0)) {
      {
#line 1291
      warn_sys("WARNING: gethostbyname failed for \"%s\" - target ignored", name);
      }
#line 1293
      return;
    }
  }
#line 1297
  if (! num_left) {
#line 1298
    if (helist) {
      {
#line 1299
      tmp___0 = Realloc((void *)helist, (unsigned long )*num_hosts * sizeof(host_entry ) + 1000UL * sizeof(host_entry ));
#line 1299
      helist = (host_entry *)tmp___0;
      }
    } else {
      {
#line 1302
      tmp___1 = Malloc(1000UL * sizeof(host_entry ));
#line 1302
      helist = (host_entry *)tmp___1;
      }
    }
#line 1303
    num_left = 1000;
  }
  {
#line 1306
  he = helist + *num_hosts;
#line 1308
  (*num_hosts) ++;
#line 1309
  num_left --;
#line 1311
  Gettimeofday(& now);
#line 1313
  he->n = *num_hosts;
  }
#line 1314
  if (no_dns_flag) {
    {
#line 1315
    memcpy((void */* __restrict  */)(& he->addr), (void const   */* __restrict  */)(& inp),
           sizeof(struct in_addr ));
    }
  } else {
    {
#line 1317
    memcpy((void */* __restrict  */)(& he->addr), (void const   */* __restrict  */)*(hp->h_addr_list + 0),
           sizeof(struct in_addr ));
    }
  }
#line 1318
  he->live = (unsigned char)1;
#line 1319
  he->timeout = timeout * 1000U;
#line 1320
  he->num_sent = (unsigned short)0;
#line 1321
  he->num_recv = (unsigned short)0;
#line 1322
  he->last_send_time.tv_sec = (__time_t )0;
#line 1323
  he->last_send_time.tv_usec = (__suseconds_t )0;
#line 1324
  he->recv_times = (time_list *)((void *)0);
#line 1325
  he->extra = (misc_data *)((void *)0);
#line 1327
  if (cookie_data) {
    {
#line 1328
    memset((void *)(he->icookie), '\000', sizeof(he->icookie));
#line 1329
    memcpy((void */* __restrict  */)(he->icookie), (void const   */* __restrict  */)cookie_data,
           cookie_data_len);
    }
  } else {
    {
#line 1337
    tmp___2 = inet_ntoa(he->addr);
#line 1337
    sprintf((char */* __restrict  */)(str), (char const   */* __restrict  */)"%lu %lu %u %s",
            (unsigned long )now.tv_sec, (unsigned long )now.tv_usec, *num_hosts, tmp___2);
#line 1339
    tmp___3 = strlen((char const   *)(str));
#line 1339
    tmp___4 = MD5((unsigned char const   *)((unsigned char *)(str)), tmp___3, (unsigned char *)((void *)0));
#line 1339
    memcpy((void */* __restrict  */)(he->icookie), (void const   */* __restrict  */)tmp___4,
           sizeof(he->icookie));
    }
  }
#line 1342
  return;
}
}
#line 1360 "/home/june/repo/benchmarks/collector/temp/ike-scan-1.9/ike-scan.c"
void remove_host(host_entry **he , unsigned int *live_count , unsigned int num_hosts ) 
{ 


  {
#line 1362
  (*he)->live = (unsigned char)0;
#line 1363
  (*live_count) --;
#line 1364
  if ((unsigned long )*he == (unsigned long )*cursor) {
    {
#line 1365
    advance_cursor(*live_count, num_hosts);
    }
  }
#line 1366
  return;
}
}
#line 1382 "/home/june/repo/benchmarks/collector/temp/ike-scan-1.9/ike-scan.c"
void advance_cursor(unsigned int live_count , unsigned int num_hosts ) 
{ 


  {
#line 1384
  if (live_count) {
    {
#line 1385
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1386
      if ((unsigned long )cursor == (unsigned long )(helistptr + (num_hosts - 1U))) {
#line 1387
        cursor = helistptr;
      } else {
#line 1389
        cursor ++;
      }
#line 1385
      if (! (! (*cursor)->live)) {
#line 1385
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 1392
  return;
}
}
#line 1410 "/home/june/repo/benchmarks/collector/temp/ike-scan-1.9/ike-scan.c"
host_entry *find_host_by_cookie(host_entry **he , unsigned char *packet_in , int n ,
                                unsigned int num_hosts ) 
{ 
  host_entry **p ;
  int found ;
  struct isakmp_hdr hdr_in ;

  {
#line 1414
  found = 0;
#line 1421
  if ((unsigned long )*he == (unsigned long )((void *)0)) {
#line 1422
    return ((host_entry *)((void *)0));
  }
#line 1427
  if ((unsigned long )n < sizeof(hdr_in)) {
#line 1428
    return ((host_entry *)((void *)0));
  }
  {
#line 1432
  memcpy((void */* __restrict  */)(& hdr_in), (void const   */* __restrict  */)packet_in,
         sizeof(hdr_in));
#line 1434
  p = he;
  }
  {
#line 1436
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1437
    if ((*p)->icookie[0] == hdr_in.isa_icookie[0]) {
#line 1437
      if ((*p)->icookie[1] == hdr_in.isa_icookie[1]) {
#line 1439
        found = 1;
      } else {
#line 1437
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 1441
    if ((unsigned long )p == (unsigned long )helistptr) {
#line 1442
      p = helistptr + (num_hosts - 1U);
    } else {
#line 1444
      p --;
    }
#line 1436
    if (! found) {
#line 1436
      if (! ((unsigned long )p != (unsigned long )he)) {
#line 1436
        goto while_break;
      }
    } else {
#line 1436
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1449
  if (found) {
#line 1450
    return (*p);
  } else {
#line 1452
    return ((host_entry *)((void *)0));
  }
}
}
#line 1477 "/home/june/repo/benchmarks/collector/temp/ike-scan-1.9/ike-scan.c"
void display_packet(int n , unsigned char *packet_in , host_entry *he , struct in_addr *recv_addr ,
                    unsigned int *sa_responders , unsigned int *notify_responders ,
                    int quiet , int multiline ) 
{ 
  char *cp ;
  size_t bytes_left ;
  unsigned int next ;
  unsigned int type ;
  char *msg ;
  char *msg2 ;
  unsigned char *pkt_ptr ;
  char *hdr_descr ;
  struct tm *time_tm ;
  struct timeval time_tv ;
  time_t clock_seconds ;
  char *tmp ;
  char *tmp___0 ;
  char const   *tmp___1 ;
  unsigned char *payload_ptr ;
  char const   *tmp___2 ;

  {
  {
#line 1492
  msg = make_message("");
  }
#line 1496
  if (shownum_flag) {
    {
#line 1497
    cp = msg;
#line 1498
    msg = make_message("%s%u ", cp, he->n);
#line 1499
    free((void *)cp);
    }
  }
#line 1504
  if (timestamp_flag) {
    {
#line 1509
    Gettimeofday(& time_tv);
#line 1510
    clock_seconds = time_tv.tv_sec;
#line 1511
    time_tm = localtime((time_t const   *)(& clock_seconds));
#line 1512
    cp = msg;
#line 1513
    msg = make_message("%s%02d:%02d:%02d.%06u ", cp, time_tm->tm_hour, time_tm->tm_min,
                       time_tm->tm_sec, time_tv.tv_usec);
#line 1516
    free((void *)cp);
    }
  }
  {
#line 1522
  cp = msg;
#line 1523
  tmp = inet_ntoa(he->addr);
#line 1523
  msg = make_message("%s%s\t", cp, tmp);
#line 1524
  free((void *)cp);
  }
#line 1525
  if (he->addr.s_addr != recv_addr->s_addr) {
#line 1525
    if (! tcp_flag) {
      {
#line 1526
      cp = msg;
#line 1527
      tmp___0 = inet_ntoa(*recv_addr);
#line 1527
      msg = make_message("%s(%s) ", cp, tmp___0);
#line 1528
      free((void *)cp);
      }
    }
  }
#line 1536
  bytes_left = (size_t )n;
#line 1537
  if (psk_crack_flag) {
    {
#line 1538
    add_psk_crack_payload(packet_in, 0U, 'X');
    }
  }
  {
#line 1539
  pkt_ptr = process_isakmp_hdr(packet_in, & bytes_left, & next, & type, & hdr_descr);
  }
#line 1541
  if (! bytes_left) {
    {
#line 1542
    printf((char const   */* __restrict  */)"%sShort or malformed ISAKMP packet returned: %d bytes\n",
           msg, n);
#line 1544
    free((void *)msg);
    }
#line 1545
    return;
  }
  {
#line 1553
  if (next == 1U) {
#line 1553
    goto case_1;
  }
#line 1560
  if (next == 33U) {
#line 1560
    goto case_33;
  }
#line 1565
  if (next == 11U) {
#line 1565
    goto case_11;
  }
#line 1570
  if (next == 41U) {
#line 1570
    goto case_41;
  }
#line 1575
  goto switch_default;
  case_1: /* CIL Label */ 
#line 1554
  if (psk_crack_flag) {
    {
#line 1555
    add_psk_crack_payload(pkt_ptr, next, 'R');
    }
  }
  {
#line 1556
  (*sa_responders) ++;
#line 1557
  cp = process_sa(pkt_ptr, bytes_left, type, quiet, multiline, hdr_descr);
  }
#line 1559
  goto switch_break;
  case_33: /* CIL Label */ 
  {
#line 1561
  (*sa_responders) ++;
#line 1562
  cp = process_sa2(pkt_ptr, bytes_left, type, quiet, multiline, hdr_descr);
  }
#line 1564
  goto switch_break;
  case_11: /* CIL Label */ 
  {
#line 1566
  (*notify_responders) ++;
#line 1567
  cp = process_notify(pkt_ptr, bytes_left, quiet, multiline, hdr_descr);
  }
#line 1569
  goto switch_break;
  case_41: /* CIL Label */ 
  {
#line 1571
  (*notify_responders) ++;
#line 1572
  cp = process_notify2(pkt_ptr, bytes_left, quiet, multiline, hdr_descr);
  }
#line 1574
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 1576
  tmp___1 = id_to_name(next, payload_map);
#line 1576
  cp = make_message("Unexpected IKE payload returned: %s", tmp___1);
  }
#line 1578
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 1580
  free((void *)hdr_descr);
#line 1581
  pkt_ptr = skip_payload(pkt_ptr, & bytes_left, & next);
#line 1582
  msg2 = msg;
#line 1583
  msg = make_message("%s%s", msg, cp);
#line 1584
  free((void *)msg2);
#line 1585
  free((void *)cp);
  }
#line 1589
  if (! quiet) {
    {
#line 1592
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1592
      if (! bytes_left) {
#line 1592
        goto while_break;
      }
      {
#line 1593
      payload_ptr = clone_payload((unsigned char const   *)pkt_ptr, bytes_left);
#line 1594
      msg2 = msg;
      }
      {
#line 1596
      if (next == 13U) {
#line 1596
        goto case_13;
      }
#line 1599
      if (next == 5U) {
#line 1599
        goto case_5;
      }
#line 1605
      if (next == 7U) {
#line 1605
        goto case_7;
      }
#line 1605
      if (next == 6U) {
#line 1605
        goto case_7;
      }
#line 1608
      if (next == 12U) {
#line 1608
        goto case_12;
      }
#line 1611
      if (next == 11U) {
#line 1611
        goto case_11___0;
      }
#line 1614
      goto switch_default___0;
      case_13: /* CIL Label */ 
      {
#line 1597
      cp = process_vid(payload_ptr, bytes_left, vidlist);
      }
#line 1598
      goto switch_break___0;
      case_5: /* CIL Label */ 
#line 1600
      if (psk_crack_flag) {
        {
#line 1601
        add_psk_crack_payload(payload_ptr, next, 'R');
        }
      }
      {
#line 1602
      cp = process_id(payload_ptr, bytes_left);
      }
#line 1603
      goto switch_break___0;
      case_7: /* CIL Label */ 
      case_6: /* CIL Label */ 
      {
#line 1606
      cp = process_cert(payload_ptr, bytes_left, next);
      }
#line 1607
      goto switch_break___0;
      case_12: /* CIL Label */ 
      {
#line 1609
      cp = process_delete(payload_ptr, bytes_left);
      }
#line 1610
      goto switch_break___0;
      case_11___0: /* CIL Label */ 
      {
#line 1612
      cp = process_notification(payload_ptr, bytes_left);
      }
#line 1613
      goto switch_break___0;
      switch_default___0: /* CIL Label */ 
#line 1615
      if (psk_crack_flag) {
        {
#line 1616
        add_psk_crack_payload(payload_ptr, next, 'R');
        }
      }
      {
#line 1617
      cp = process_generic(payload_ptr, bytes_left, next);
      }
#line 1618
      goto switch_break___0;
      switch_break___0: /* CIL Label */ ;
      }
      {
#line 1620
      free((void *)payload_ptr);
      }
#line 1621
      if (multiline) {
#line 1621
        tmp___2 = "\n\t";
      } else {
#line 1621
        tmp___2 = " ";
      }
      {
#line 1621
      msg = make_message("%s%s%s", msg2, tmp___2, cp);
#line 1622
      free((void *)msg2);
#line 1623
      free((void *)cp);
#line 1624
      pkt_ptr = skip_payload(pkt_ptr, & bytes_left, & next);
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 1630
  printf((char const   */* __restrict  */)"%s\n", msg);
#line 1631
  free((void *)msg);
  }
#line 1632
  return;
}
}
#line 1655 "/home/june/repo/benchmarks/collector/temp/ike-scan-1.9/ike-scan.c"
void send_packet(int s , unsigned char *packet_out , size_t packet_out_len , host_entry *he ,
                 unsigned int source_port , unsigned int dest_port , struct timeval *last_packet_time ) 
{ 
  struct sockaddr_in sa_peer ;
  socklen_t sa_peer_len ;
  int nsent ;
  struct isakmp_hdr *hdr ;
  unsigned char *orig_packet_out ;
  unsigned char *udphdr ;
  size_t udphdr_len ;
  unsigned char *cp ;
  unsigned char udpextra[16] ;
  unsigned char tcpextra[16] ;
  void *tmp ;
  unsigned char *orig_packet_out___0 ;
  size_t orig_packet_out_len ;
  struct iphdr *iph ;
  struct udphdr *udph ;
  struct pseudo_hdr *pseudo ;
  uint32_t source_address_host ;
  uint32_t source_address ;
  void *tmp___0 ;
  unsigned char *orig_packet_out___1 ;
  unsigned char *cp___0 ;
  void *tmp___1 ;
  char *tmp___2 ;
  ssize_t tmp___3 ;
  ssize_t tmp___4 ;

  {
  {
#line 1662
  hdr = (struct isakmp_hdr *)packet_out;
#line 1666
  memset((void *)(& sa_peer), '\000', sizeof(sa_peer));
#line 1667
  sa_peer.sin_family = (sa_family_t )2;
#line 1668
  sa_peer.sin_addr.s_addr = he->addr.s_addr;
#line 1669
  sa_peer.sin_port = htons((uint16_t )dest_port);
#line 1670
  sa_peer_len = (socklen_t )sizeof(sa_peer);
#line 1674
  hdr->isa_icookie[0] = he->icookie[0];
#line 1675
  hdr->isa_icookie[1] = he->icookie[1];
#line 1679
  Gettimeofday(last_packet_time);
#line 1680
  he->last_send_time.tv_sec = last_packet_time->tv_sec;
#line 1681
  he->last_send_time.tv_usec = last_packet_time->tv_usec;
#line 1682
  he->num_sent = (unsigned short )((int )he->num_sent + 1);
  }
#line 1686
  if (tcp_flag == 2) {
    {
#line 1687
    orig_packet_out = packet_out;
#line 1693
    udpextra[0] = (unsigned char)0;
#line 1693
    udpextra[1] = (unsigned char)0;
#line 1693
    udpextra[2] = (unsigned char)0;
#line 1693
    udpextra[3] = (unsigned char)0;
#line 1693
    udpextra[4] = (unsigned char)0;
#line 1693
    udpextra[5] = (unsigned char)0;
#line 1693
    udpextra[6] = (unsigned char)0;
#line 1693
    udpextra[7] = (unsigned char)0;
#line 1693
    udpextra[8] = (unsigned char)0;
#line 1693
    udpextra[9] = (unsigned char)0;
#line 1693
    udpextra[10] = (unsigned char)0;
#line 1693
    udpextra[11] = (unsigned char)0;
#line 1693
    udpextra[12] = (unsigned char)0;
#line 1693
    udpextra[13] = (unsigned char)0;
#line 1693
    udpextra[14] = (unsigned char)0;
#line 1693
    udpextra[15] = (unsigned char)0;
#line 1697
    tcpextra[0] = (unsigned char)0;
#line 1697
    tcpextra[1] = (unsigned char)0;
#line 1697
    tcpextra[2] = (unsigned char)0;
#line 1697
    tcpextra[3] = (unsigned char)0;
#line 1697
    tcpextra[4] = (unsigned char)0;
#line 1697
    tcpextra[5] = (unsigned char)0;
#line 1697
    tcpextra[6] = (unsigned char)0;
#line 1697
    tcpextra[7] = (unsigned char)0;
#line 1697
    tcpextra[8] = (unsigned char)33;
#line 1697
    tcpextra[9] = (unsigned char)69;
#line 1697
    tcpextra[10] = (unsigned char)108;
#line 1697
    tcpextra[11] = (unsigned char)105;
#line 1697
    tcpextra[12] = (unsigned char)16;
#line 1697
    tcpextra[13] = (unsigned char)17;
#line 1697
    tcpextra[14] = (unsigned char)1;
#line 1697
    tcpextra[15] = (unsigned char)0;
#line 1702
    tmp = Malloc(packet_out_len + 40UL);
#line 1702
    packet_out = (unsigned char *)tmp;
#line 1703
    cp = packet_out;
#line 1705
    udphdr = make_udphdr(& udphdr_len, source_port, dest_port, (unsigned int )((packet_out_len + 8UL) + 16UL));
#line 1707
    memcpy((void */* __restrict  */)cp, (void const   */* __restrict  */)udphdr, udphdr_len);
#line 1708
    cp += udphdr_len;
#line 1710
    memcpy((void */* __restrict  */)cp, (void const   */* __restrict  */)orig_packet_out,
           packet_out_len);
#line 1711
    cp += packet_out_len;
#line 1713
    memcpy((void */* __restrict  */)cp, (void const   */* __restrict  */)(udpextra),
           (size_t )16);
#line 1714
    cp += 16;
#line 1716
    memcpy((void */* __restrict  */)cp, (void const   */* __restrict  */)(tcpextra),
           (size_t )16);
#line 1717
    cp += 16;
#line 1719
    packet_out_len += 40UL;
    }
  }
#line 1724
  if (sourceip_flag != 0) {
#line 1725
    orig_packet_out___0 = packet_out;
#line 1726
    orig_packet_out_len = packet_out_len;
#line 1733
    if (randsrc_flag) {
      {
#line 1734
      source_address_host = random_ip();
#line 1735
      source_address = htonl(source_address_host);
      }
    } else {
#line 1737
      source_address = src_ip_val;
    }
    {
#line 1739
    tmp___0 = Malloc((sizeof(struct iphdr ) + sizeof(struct udphdr )) + packet_out_len);
#line 1739
    packet_out = (unsigned char *)tmp___0;
#line 1741
    iph = (struct iphdr *)packet_out;
#line 1742
    udph = (struct udphdr *)(packet_out + sizeof(struct iphdr ));
#line 1743
    pseudo = (struct pseudo_hdr *)((packet_out + sizeof(struct iphdr )) - sizeof(struct pseudo_hdr ));
#line 1749
    memcpy((void */* __restrict  */)((packet_out + sizeof(struct iphdr )) + sizeof(struct udphdr )),
           (void const   */* __restrict  */)orig_packet_out___0, packet_out_len);
#line 1751
    packet_out_len += sizeof(struct iphdr ) + sizeof(struct udphdr );
#line 1756
    memset((void *)pseudo, '\000', sizeof(struct pseudo_hdr ));
#line 1757
    pseudo->src_addr = source_address;
#line 1758
    pseudo->dst_addr = he->addr.s_addr;
#line 1759
    pseudo->proto = (uint8_t )17;
#line 1760
    pseudo->length = htons((uint16_t )(sizeof(struct udphdr ) + orig_packet_out_len));
#line 1764
    memset((void *)udph, '\000', sizeof(struct udphdr ));
#line 1765
    udph->source = htons((uint16_t )source_port);
#line 1766
    udph->dest = htons((uint16_t )dest_port);
#line 1767
    udph->len = htons((uint16_t )(sizeof(struct udphdr ) + orig_packet_out_len));
#line 1768
    udph->check = in_cksum((uint16_t *)pseudo, (sizeof(struct pseudo_hdr ) + sizeof(struct udphdr )) + orig_packet_out_len);
#line 1774
    memset((void *)iph, '\000', sizeof(struct iphdr ));
#line 1775
    iph->ihl = 5U;
#line 1776
    iph->version = 4U;
#line 1777
    iph->tos = (uint8_t )0;
#line 1778
    iph->tot_len = (uint16_t )packet_out_len;
#line 1779
    iph->id = (uint16_t )0;
#line 1780
    iph->frag_off = htons((uint16_t )0);
#line 1781
    iph->ttl = (uint8_t )128;
#line 1782
    iph->protocol = (uint8_t )17;
#line 1783
    iph->check = (uint16_t )0;
#line 1784
    iph->saddr = source_address;
#line 1785
    iph->daddr = he->addr.s_addr;
    }
  }
#line 1790
  if (nat_t_flag) {
    {
#line 1791
    orig_packet_out___1 = packet_out;
#line 1794
    tmp___1 = Malloc(packet_out_len + 4UL);
#line 1794
    packet_out = (unsigned char *)tmp___1;
#line 1795
    cp___0 = packet_out;
#line 1796
    memset((void *)cp___0, '\000', (size_t )4);
#line 1797
    cp___0 += 4;
#line 1798
    memcpy((void */* __restrict  */)cp___0, (void const   */* __restrict  */)orig_packet_out___1,
           packet_out_len);
#line 1799
    packet_out_len += 4UL;
    }
  }
#line 1804
  if (verbose > 1) {
    {
#line 1805
    tmp___2 = inet_ntoa(he->addr);
#line 1805
    warn_msg("---\tSending packet #%u to host entry %u (%s) tmo %d us", (int )he->num_sent,
             he->n, tmp___2, he->timeout);
    }
  }
#line 1807
  if (write_pkt_to_file) {
    {
#line 1808
    tmp___3 = write(write_pkt_to_file, (void const   *)packet_out, packet_out_len);
#line 1808
    nsent = (int )tmp___3;
    }
  } else {
    {
#line 1810
    tmp___4 = sendto(s, (void const   *)packet_out, packet_out_len, 0, (struct sockaddr  const  *)((struct sockaddr *)(& sa_peer)),
                     sa_peer_len);
#line 1810
    nsent = (int )tmp___4;
    }
  }
#line 1813
  if (nsent < 0) {
    {
#line 1814
    err_sys("ERROR: sendto");
    }
  } else
#line 1815
  if ((size_t )nsent != packet_out_len) {
    {
#line 1816
    warn_msg("WARNING: sendto: only %d bytes sent, but %u requested", nsent, packet_out_len);
    }
  }
#line 1822
  if (tcp_flag == 2) {
    {
#line 1823
    free((void *)packet_out);
    }
  }
#line 1825
  return;
}
}
#line 1840 "/home/june/repo/benchmarks/collector/temp/ike-scan-1.9/ike-scan.c"
int recvfrom_wto(int s , unsigned char *buf___1 , size_t len , struct sockaddr *saddr ,
                 int tmo ) 
{ 
  fd_set readset ;
  struct timeval to ;
  int n ;
  socklen_t saddr_len ;
  int __d0 ;
  int __d1 ;
  int *tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  ssize_t tmp___2 ;
  ssize_t tmp___3 ;
  ike_udphdr *udphdr ;
  unsigned char *tmpbuf ;
  size_t tmpbuf_len ;
  void *tmp___4 ;
  uint16_t tmp___5 ;
  uint16_t tmp___6 ;

  {
#line 1848
  if (tmo < 0) {
#line 1849
    tmo = 0;
  }
#line 1850
  to.tv_sec = (__time_t )(tmo / 1000000);
#line 1851
  to.tv_usec = (__time_t )tmo - 1000000L * to.tv_sec;
#line 1852
  if (sourceip_flag) {
    {
#line 1853
    n = select(0, (fd_set */* __restrict  */)((void *)0), (fd_set */* __restrict  */)((void *)0),
               (fd_set */* __restrict  */)((void *)0), (struct timeval */* __restrict  */)(& to));
    }
  } else {
    {
#line 1855
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1855
      __asm__  volatile   ("cld; rep; "
                           "stosq": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                           "1" (& readset.__fds_bits[0]): "memory");
#line 1855
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 1856
    readset.__fds_bits[s / (8 * (int )sizeof(__fd_mask ))] |= 1L << s % (8 * (int )sizeof(__fd_mask ));
#line 1857
    n = select(s + 1, (fd_set */* __restrict  */)(& readset), (fd_set */* __restrict  */)((void *)0),
               (fd_set */* __restrict  */)((void *)0), (struct timeval */* __restrict  */)(& to));
    }
  }
#line 1859
  if (n < 0) {
    {
#line 1860
    tmp = __errno_location();
    }
#line 1860
    if (*tmp == 4) {
#line 1861
      return (-1);
    } else {
      {
#line 1863
      err_sys("ERROR: select");
      }
    }
  } else
#line 1865
  if (n == 0) {
#line 1865
    if (read_pkt_from_file == 0) {
#line 1866
      return (-1);
    }
  }
#line 1868
  if (read_pkt_from_file == 0) {
    {
#line 1869
    saddr_len = (socklen_t )sizeof(struct sockaddr );
#line 1870
    tmp___2 = recvfrom(s, (void */* __restrict  */)buf___1, len, 0, (struct sockaddr */* __restrict  */)saddr,
                       (socklen_t */* __restrict  */)(& saddr_len));
#line 1870
    n = (int )tmp___2;
    }
#line 1870
    if (n < 0) {
      {
#line 1871
      tmp___0 = __errno_location();
      }
#line 1871
      if (*tmp___0 == 111) {
#line 1877
        return (-1);
      } else {
        {
#line 1871
        tmp___1 = __errno_location();
        }
#line 1871
        if (*tmp___1 == 104) {
#line 1877
          return (-1);
        } else {
          {
#line 1879
          err_sys("ERROR: recvfrom");
          }
        }
      }
    }
  } else {
    {
#line 1895
    tmp___3 = read(read_pkt_from_file, (void *)buf___1, len);
#line 1895
    n = (int )tmp___3;
    }
#line 1895
    if (n < 0) {
      {
#line 1896
      err_sys("ERROR: read");
      }
    }
    {
#line 1898
    memset((void *)saddr, '\000', sizeof(struct sockaddr_in ));
    }
  }
#line 1904
  if (tcp_flag == 2) {
#line 1904
    if (n > 8) {
      {
#line 1909
      udphdr = (ike_udphdr *)buf___1;
#line 1910
      tmp___5 = ntohs(udphdr->source);
      }
#line 1910
      if ((int )tmp___5 == 500) {
        {
#line 1910
        tmp___6 = ntohs(udphdr->dest);
        }
#line 1910
        if ((int )tmp___6 == 500) {
          {
#line 1912
          tmpbuf_len = (size_t )(n - 8);
#line 1913
          tmp___4 = Malloc(tmpbuf_len);
#line 1913
          tmpbuf = (unsigned char *)tmp___4;
#line 1914
          memcpy((void */* __restrict  */)tmpbuf, (void const   */* __restrict  */)(buf___1 + 8),
                 tmpbuf_len);
#line 1915
          memcpy((void */* __restrict  */)buf___1, (void const   */* __restrict  */)tmpbuf,
                 tmpbuf_len);
#line 1916
          free((void *)tmpbuf);
          }
        }
      }
    }
  }
#line 1923
  if (nat_t_flag) {
#line 1923
    if (n > 4) {
      {
#line 1924
      memmove((void *)buf___1, (void const   *)(buf___1 + 4), (size_t )(n - 4));
      }
    }
  }
#line 1927
  return (n);
}
}
#line 1946 "/home/june/repo/benchmarks/collector/temp/ike-scan-1.9/ike-scan.c"
unsigned char *initialise_ike_packet(size_t *packet_out_len , ike_packet_params *params ) 
{ 
  unsigned char *hdr ;
  unsigned char *sa ;
  unsigned char *prop ;
  unsigned char *transforms ;
  unsigned char *certreq ;
  unsigned char *vid ;
  unsigned char *id ;
  unsigned char *nonce ;
  unsigned char *ke ;
  unsigned char *cp ;
  unsigned char *packet_out ;
  unsigned char *sa_cp ;
  size_t sa_len ;
  size_t prop_len ;
  size_t certreq_len ;
  size_t vid_len ;
  size_t trans_len ;
  size_t id_len ;
  size_t nonce_len ;
  size_t ke_len ;
  size_t kx_data_len ;
  unsigned int no_trans ;
  unsigned int next_payload ;
  unsigned int header_len ;
  unsigned char *attr ;
  size_t attr_len ;
  char *temp_cp ;
  unsigned long tmp ;
  unsigned long tmp___0 ;
  unsigned long tmp___1 ;
  void *tmp___2 ;

  {
#line 1952
  certreq = (unsigned char *)((void *)0);
#line 1953
  vid = (unsigned char *)((void *)0);
#line 1954
  id = (unsigned char *)((void *)0);
#line 1955
  nonce = (unsigned char *)((void *)0);
#line 1956
  ke = (unsigned char *)((void *)0);
#line 1959
  sa_cp = (unsigned char *)((void *)0);
#line 1968
  kx_data_len = (size_t )0;
#line 1969
  no_trans = 0U;
#line 1973
  *packet_out_len = (size_t )0;
#line 1974
  next_payload = 0U;
#line 1978
  if (params->cr_data) {
    {
#line 1979
    certreq = make_cr(& certreq_len, next_payload, params->cr_data, params->cr_data_len);
#line 1981
    *packet_out_len += certreq_len;
#line 1982
    next_payload = 7U;
    }
  }
#line 1987
  if (params->vendor_id_flag) {
    {
#line 1988
    vid = add_vid(1, & vid_len, (unsigned char *)((void *)0), (size_t )0, next_payload);
#line 1989
    *packet_out_len += vid_len;
#line 1990
    next_payload = 13U;
    }
  }
#line 1995
  if (params->exchange_type == 4U) {
    {
#line 1996
    id = make_id(& id_len, next_payload, params->idtype, params->id_data, params->id_data_len);
    }
#line 1998
    if (params->id_data) {
      {
#line 1999
      free((void *)params->id_data);
      }
    }
    {
#line 2000
    *packet_out_len += id_len;
#line 2001
    next_payload = 5U;
#line 2002
    nonce = make_nonce(& nonce_len, next_payload, params->nonce_data_len);
    }
#line 2003
    if (psk_crack_flag) {
      {
#line 2004
      add_psk_crack_payload(nonce, 10U, 'I');
      }
    }
#line 2005
    *packet_out_len += nonce_len;
#line 2006
    next_payload = 10U;
    {
#line 2008
    if (params->dhgroup == 1U) {
#line 2008
      goto case_1;
    }
#line 2011
    if (params->dhgroup == 2U) {
#line 2011
      goto case_2;
    }
#line 2014
    if (params->dhgroup == 5U) {
#line 2014
      goto case_5;
    }
#line 2017
    if (params->dhgroup == 14U) {
#line 2017
      goto case_14;
    }
#line 2020
    if (params->dhgroup == 15U) {
#line 2020
      goto case_15;
    }
#line 2023
    if (params->dhgroup == 16U) {
#line 2023
      goto case_16;
    }
#line 2026
    if (params->dhgroup == 17U) {
#line 2026
      goto case_17;
    }
#line 2029
    if (params->dhgroup == 18U) {
#line 2029
      goto case_18;
    }
#line 2032
    goto switch_default;
    case_1: /* CIL Label */ 
#line 2009
    kx_data_len = (size_t )96;
#line 2010
    goto switch_break;
    case_2: /* CIL Label */ 
#line 2012
    kx_data_len = (size_t )128;
#line 2013
    goto switch_break;
    case_5: /* CIL Label */ 
#line 2015
    kx_data_len = (size_t )192;
#line 2016
    goto switch_break;
    case_14: /* CIL Label */ 
#line 2018
    kx_data_len = (size_t )256;
#line 2019
    goto switch_break;
    case_15: /* CIL Label */ 
#line 2021
    kx_data_len = (size_t )384;
#line 2022
    goto switch_break;
    case_16: /* CIL Label */ 
#line 2024
    kx_data_len = (size_t )512;
#line 2025
    goto switch_break;
    case_17: /* CIL Label */ 
#line 2027
    kx_data_len = (size_t )768;
#line 2028
    goto switch_break;
    case_18: /* CIL Label */ 
#line 2030
    kx_data_len = (size_t )1024;
#line 2031
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 2033
    err_msg("ERROR: Bad Diffie Hellman group: %u, should be 1,2,5,14,15,16,17 or 18",
            params->dhgroup);
    }
#line 2036
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
    {
#line 2038
    ke = make_ke(& ke_len, next_payload, kx_data_len);
    }
#line 2039
    if (psk_crack_flag) {
      {
#line 2040
      add_psk_crack_payload(ke, 4U, 'I');
      }
    }
#line 2041
    *packet_out_len += ke_len;
#line 2042
    next_payload = 4U;
  }
#line 2047
  if (params->ike_version == 2) {
    {
#line 2048
    nonce = make_nonce(& nonce_len, next_payload, params->nonce_data_len);
#line 2049
    *packet_out_len += nonce_len;
#line 2050
    next_payload = 40U;
    }
    {
#line 2052
    if (params->dhgroup == 1U) {
#line 2052
      goto case_1___0;
    }
#line 2055
    if (params->dhgroup == 2U) {
#line 2055
      goto case_2___0;
    }
#line 2058
    if (params->dhgroup == 5U) {
#line 2058
      goto case_5___0;
    }
#line 2061
    if (params->dhgroup == 14U) {
#line 2061
      goto case_14___0;
    }
#line 2064
    if (params->dhgroup == 15U) {
#line 2064
      goto case_15___0;
    }
#line 2067
    if (params->dhgroup == 16U) {
#line 2067
      goto case_16___0;
    }
#line 2070
    if (params->dhgroup == 17U) {
#line 2070
      goto case_17___0;
    }
#line 2073
    if (params->dhgroup == 18U) {
#line 2073
      goto case_18___0;
    }
#line 2076
    goto switch_default___0;
    case_1___0: /* CIL Label */ 
#line 2053
    kx_data_len = (size_t )96;
#line 2054
    goto switch_break___0;
    case_2___0: /* CIL Label */ 
#line 2056
    kx_data_len = (size_t )128;
#line 2057
    goto switch_break___0;
    case_5___0: /* CIL Label */ 
#line 2059
    kx_data_len = (size_t )192;
#line 2060
    goto switch_break___0;
    case_14___0: /* CIL Label */ 
#line 2062
    kx_data_len = (size_t )256;
#line 2063
    goto switch_break___0;
    case_15___0: /* CIL Label */ 
#line 2065
    kx_data_len = (size_t )384;
#line 2066
    goto switch_break___0;
    case_16___0: /* CIL Label */ 
#line 2068
    kx_data_len = (size_t )512;
#line 2069
    goto switch_break___0;
    case_17___0: /* CIL Label */ 
#line 2071
    kx_data_len = (size_t )768;
#line 2072
    goto switch_break___0;
    case_18___0: /* CIL Label */ 
#line 2074
    kx_data_len = (size_t )1024;
#line 2075
    goto switch_break___0;
    switch_default___0: /* CIL Label */ 
    {
#line 2077
    err_msg("ERROR: Bad Diffie Hellman group: %u, should be 1,2,5,14,15,16,17 or 18",
            params->dhgroup);
    }
#line 2080
    goto switch_break___0;
    switch_break___0: /* CIL Label */ ;
    }
    {
#line 2082
    ke = make_ke2(& ke_len, next_payload, params->dhgroup, kx_data_len);
#line 2083
    *packet_out_len += ke_len;
#line 2084
    next_payload = 34U;
    }
  }
#line 2089
  if (! params->trans_flag) {
#line 2089
    if (params->ike_version == 1) {
#line 2090
      if (params->exchange_type != 4U) {
        {
#line 2091
        add_trans_simple(0, (size_t *)((void *)0), 5U, 0U, 2U, params->auth_method,
                         2U, params->lifetime_data, params->lifetime_data_len, params->lifesize_data,
                         params->lifesize_data_len, params->gss_id_flag, params->gss_data,
                         params->gss_data_len, params->trans_id);
#line 2097
        add_trans_simple(0, (size_t *)((void *)0), 5U, 0U, 1U, params->auth_method,
                         2U, params->lifetime_data, params->lifetime_data_len, params->lifesize_data,
                         params->lifesize_data_len, params->gss_id_flag, params->gss_data,
                         params->gss_data_len, params->trans_id);
#line 2103
        add_trans_simple(0, (size_t *)((void *)0), 1U, 0U, 2U, params->auth_method,
                         2U, params->lifetime_data, params->lifetime_data_len, params->lifesize_data,
                         params->lifesize_data_len, params->gss_id_flag, params->gss_data,
                         params->gss_data_len, params->trans_id);
#line 2109
        add_trans_simple(0, (size_t *)((void *)0), 1U, 0U, 1U, params->auth_method,
                         2U, params->lifetime_data, params->lifetime_data_len, params->lifesize_data,
                         params->lifesize_data_len, params->gss_id_flag, params->gss_data,
                         params->gss_data_len, params->trans_id);
#line 2115
        add_trans_simple(0, (size_t *)((void *)0), 5U, 0U, 2U, params->auth_method,
                         1U, params->lifetime_data, params->lifetime_data_len, params->lifesize_data,
                         params->lifesize_data_len, params->gss_id_flag, params->gss_data,
                         params->gss_data_len, params->trans_id);
#line 2121
        add_trans_simple(0, (size_t *)((void *)0), 5U, 0U, 1U, params->auth_method,
                         1U, params->lifetime_data, params->lifetime_data_len, params->lifesize_data,
                         params->lifesize_data_len, params->gss_id_flag, params->gss_data,
                         params->gss_data_len, params->trans_id);
#line 2127
        add_trans_simple(0, (size_t *)((void *)0), 1U, 0U, 2U, params->auth_method,
                         1U, params->lifetime_data, params->lifetime_data_len, params->lifesize_data,
                         params->lifesize_data_len, params->gss_id_flag, params->gss_data,
                         params->gss_data_len, params->trans_id);
#line 2133
        add_trans_simple(0, (size_t *)((void *)0), 1U, 0U, 1U, params->auth_method,
                         1U, params->lifetime_data, params->lifetime_data_len, params->lifesize_data,
                         params->lifesize_data_len, params->gss_id_flag, params->gss_data,
                         params->gss_data_len, params->trans_id);
#line 2139
        no_trans = 8U;
        }
      } else {
        {
#line 2141
        add_trans_simple(0, (size_t *)((void *)0), 5U, 0U, 2U, params->auth_method,
                         params->dhgroup, params->lifetime_data, params->lifetime_data_len,
                         params->lifesize_data, params->lifesize_data_len, params->gss_id_flag,
                         params->gss_data, params->gss_data_len, params->trans_id);
#line 2146
        add_trans_simple(0, (size_t *)((void *)0), 5U, 0U, 1U, params->auth_method,
                         params->dhgroup, params->lifetime_data, params->lifetime_data_len,
                         params->lifesize_data, params->lifesize_data_len, params->gss_id_flag,
                         params->gss_data, params->gss_data_len, params->trans_id);
#line 2151
        add_trans_simple(0, (size_t *)((void *)0), 1U, 0U, 2U, params->auth_method,
                         params->dhgroup, params->lifetime_data, params->lifetime_data_len,
                         params->lifesize_data, params->lifesize_data_len, params->gss_id_flag,
                         params->gss_data, params->gss_data_len, params->trans_id);
#line 2156
        add_trans_simple(0, (size_t *)((void *)0), 1U, 0U, 1U, params->auth_method,
                         params->dhgroup, params->lifetime_data, params->lifetime_data_len,
                         params->lifesize_data, params->lifesize_data_len, params->gss_id_flag,
                         params->gss_data, params->gss_data_len, params->trans_id);
#line 2161
        no_trans = 4U;
        }
      }
#line 2163
      if (params->gss_data) {
        {
#line 2164
        free((void *)params->gss_data);
        }
      }
    } else {
#line 2089
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 2165
  if (params->ike_version == 1) {
#line 2166
    no_trans = (unsigned int )params->trans_flag;
  }
#line 2168
  if (params->advanced_trans_flag) {
#line 2168
    if (params->ike_version == 1) {
      {
#line 2169
      transforms = add_transform(1, & trans_len, 0U, (unsigned char *)((void *)0),
                                 (size_t )0);
      }
    } else {
#line 2168
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 2170
  if (params->ike_version == 1) {
    {
#line 2171
    transforms = add_trans_simple(1, & trans_len, 0U, 0U, 0U, 0U, 0U, (unsigned char *)((void *)0),
                                  (size_t )0, (unsigned char *)((void *)0), (size_t )0,
                                  0, (unsigned char *)((void *)0), (size_t )0, 0U);
    }
  }
#line 2175
  if (params->ike_version != 1) {
    {
#line 2179
    add_attr(0, (size_t *)((void *)0), 'B', 14U, (size_t )0, 256U, (void *)0);
#line 2180
    attr = add_attr(1, & attr_len, '\000', 0U, (size_t )0, 0U, (void *)0);
#line 2181
    add_transform2(0, (size_t *)((void *)0), 1U, 12U, attr, attr_len);
#line 2182
    free((void *)attr);
#line 2183
    add_attr(0, (size_t *)((void *)0), 'B', 14U, (size_t )0, 128U, (void *)0);
#line 2184
    attr = add_attr(1, & attr_len, '\000', 0U, (size_t )0, 0U, (void *)0);
#line 2185
    add_transform2(0, (size_t *)((void *)0), 1U, 12U, attr, attr_len);
#line 2186
    free((void *)attr);
#line 2187
    add_transform2(0, (size_t *)((void *)0), 1U, 3U, (unsigned char *)((void *)0),
                   (size_t )0);
#line 2188
    add_transform2(0, (size_t *)((void *)0), 1U, 2U, (unsigned char *)((void *)0),
                   (size_t )0);
#line 2189
    add_transform2(0, (size_t *)((void *)0), 2U, 2U, (unsigned char *)((void *)0),
                   (size_t )0);
#line 2190
    add_transform2(0, (size_t *)((void *)0), 2U, 1U, (unsigned char *)((void *)0),
                   (size_t )0);
#line 2191
    add_transform2(0, (size_t *)((void *)0), 3U, 2U, (unsigned char *)((void *)0),
                   (size_t )0);
#line 2192
    add_transform2(0, (size_t *)((void *)0), 3U, 1U, (unsigned char *)((void *)0),
                   (size_t )0);
#line 2193
    add_transform2(0, (size_t *)((void *)0), 4U, 2U, (unsigned char *)((void *)0),
                   (size_t )0);
#line 2194
    add_transform2(0, (size_t *)((void *)0), 4U, 5U, (unsigned char *)((void *)0),
                   (size_t )0);
#line 2195
    add_transform2(0, (size_t *)((void *)0), 4U, 14U, (unsigned char *)((void *)0),
                   (size_t )0);
#line 2196
    transforms = add_transform2(1, & trans_len, 0U, 0U, (unsigned char *)((void *)0),
                                (size_t )0);
#line 2197
    no_trans = 11U;
    }
  }
  {
#line 2202
  add_prop(0, (size_t *)((void *)0), no_trans, params->protocol, params->spi_size,
           transforms, trans_len);
#line 2204
  prop = add_prop(1, & prop_len, 0U, 0U, 0U, (unsigned char *)((void *)0), (size_t )0);
#line 2205
  free((void *)transforms);
  }
#line 2209
  if (params->ike_version == 1) {
    {
#line 2210
    sa = make_sa(& sa_len, next_payload, params->doi, params->situation, prop, prop_len);
#line 2212
    next_payload = 1U;
    }
  } else {
    {
#line 2214
    sa = make_sa2(& sa_len, next_payload, prop, prop_len);
#line 2215
    next_payload = 33U;
    }
  }
  {
#line 2217
  *packet_out_len += sa_len;
#line 2218
  free((void *)prop);
#line 2222
  *packet_out_len += sizeof(struct isakmp_hdr );
#line 2223
  header_len = (unsigned int )*packet_out_len;
  }
#line 2224
  if (params->header_length) {
#line 2227
    temp_cp = params->header_length;
#line 2228
    if ((int )*temp_cp == 43) {
      {
#line 2229
      temp_cp ++;
#line 2229
      tmp = Strtoul((char const   *)temp_cp, 0);
#line 2229
      header_len = (unsigned int )((unsigned long )header_len + tmp);
      }
    } else
#line 2230
    if ((int )*temp_cp == 45) {
      {
#line 2231
      temp_cp ++;
#line 2231
      tmp___0 = Strtoul((char const   *)temp_cp, 0);
#line 2231
      header_len = (unsigned int )((unsigned long )header_len - tmp___0);
      }
    } else {
      {
#line 2233
      tmp___1 = Strtoul((char const   *)temp_cp, 0);
#line 2233
      header_len = (unsigned int )tmp___1;
      }
    }
  }
#line 2236
  if (params->hdr_next_payload) {
#line 2237
    next_payload = params->hdr_next_payload;
  }
  {
#line 2239
  hdr = make_isakmp_hdr(params->exchange_type, next_payload, header_len, params->header_version,
                        params->hdr_flags, params->hdr_msgid, params->rcookie_data,
                        params->rcookie_data_len);
#line 2246
  tmp___2 = Malloc(*packet_out_len);
#line 2246
  packet_out = (unsigned char *)tmp___2;
#line 2247
  cp = packet_out;
#line 2248
  memcpy((void */* __restrict  */)cp, (void const   */* __restrict  */)hdr, sizeof(struct isakmp_hdr ));
#line 2249
  free((void *)hdr);
#line 2250
  cp += sizeof(struct isakmp_hdr );
  }
#line 2251
  if (psk_crack_flag) {
#line 2252
    sa_cp = cp;
  }
  {
#line 2253
  memcpy((void */* __restrict  */)cp, (void const   */* __restrict  */)sa, sa_len);
#line 2254
  free((void *)sa);
#line 2255
  cp += sa_len;
  }
#line 2256
  if (params->exchange_type == 4U) {
    {
#line 2257
    memcpy((void */* __restrict  */)cp, (void const   */* __restrict  */)ke, ke_len);
#line 2258
    free((void *)ke);
#line 2259
    cp += ke_len;
#line 2260
    memcpy((void */* __restrict  */)cp, (void const   */* __restrict  */)nonce, nonce_len);
#line 2261
    free((void *)nonce);
#line 2262
    cp += nonce_len;
#line 2263
    memcpy((void */* __restrict  */)cp, (void const   */* __restrict  */)id, id_len);
#line 2264
    free((void *)id);
#line 2265
    cp += id_len;
    }
  }
#line 2267
  if (params->ike_version == 2) {
    {
#line 2268
    memcpy((void */* __restrict  */)cp, (void const   */* __restrict  */)ke, ke_len);
#line 2269
    free((void *)ke);
#line 2270
    cp += ke_len;
#line 2271
    memcpy((void */* __restrict  */)cp, (void const   */* __restrict  */)nonce, nonce_len);
#line 2272
    free((void *)nonce);
#line 2273
    cp += nonce_len;
    }
  }
#line 2275
  if (params->vendor_id_flag) {
    {
#line 2276
    memcpy((void */* __restrict  */)cp, (void const   */* __restrict  */)vid, vid_len);
#line 2277
    free((void *)vid);
#line 2278
    cp += vid_len;
    }
  }
#line 2280
  if (params->cr_data) {
    {
#line 2281
    memcpy((void */* __restrict  */)cp, (void const   */* __restrict  */)certreq,
           certreq_len);
#line 2282
    free((void *)certreq);
#line 2283
    cp += certreq_len;
    }
  }
#line 2285
  if (psk_crack_flag) {
    {
#line 2286
    add_psk_crack_payload(sa_cp, 1U, 'I');
    }
  }
#line 2288
  return (packet_out);
}
}
#line 2302 "/home/june/repo/benchmarks/collector/temp/ike-scan-1.9/ike-scan.c"
void dump_list(unsigned int num_hosts ) 
{ 
  char *cp ;
  int i ;
  char *tmp ;

  {
  {
#line 2307
  printf((char const   */* __restrict  */)"Host List:\n\n");
#line 2308
  printf((char const   */* __restrict  */)"Entry\tIP Address\tCookie\n");
#line 2309
  i = 0;
  }
  {
#line 2309
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2309
    if (! ((unsigned int )i < num_hosts)) {
#line 2309
      goto while_break;
    }
    {
#line 2310
    cp = hexstring((unsigned char const   *)((unsigned char *)((*(helistptr + i))->icookie)),
                   sizeof((*(helistptr + i))->icookie));
#line 2312
    tmp = inet_ntoa((*(helistptr + i))->addr);
#line 2312
    printf((char const   */* __restrict  */)"%u\t%s\t%s\n", (*(helistptr + i))->n,
           tmp, cp);
#line 2314
    free((void *)cp);
#line 2309
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2316
  printf((char const   */* __restrict  */)"\nTotal of %u host entries.\n\n", num_hosts);
  }
#line 2317
  return;
}
}
#line 2334 "/home/june/repo/benchmarks/collector/temp/ike-scan-1.9/ike-scan.c"
void dump_backoff(unsigned int pattern_fuzz ) 
{ 
  pattern_list *pl ;
  pattern_entry_list *pp ;
  int i ;

  {
  {
#line 2340
  printf((char const   */* __restrict  */)"Backoff Pattern List:\n\n");
#line 2341
  printf((char const   */* __restrict  */)"Entry\tName\tCount\tBackoff Pattern\n");
#line 2342
  pl = patlist;
#line 2343
  i = 1;
  }
  {
#line 2344
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2344
    if (! ((unsigned long )pl != (unsigned long )((void *)0))) {
#line 2344
      goto while_break;
    }
    {
#line 2345
    printf((char const   */* __restrict  */)"%d\t%s\t%u\t", i, pl->name, pl->num_times);
#line 2346
    pp = pl->recv_times;
    }
    {
#line 2347
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 2347
      if (! ((unsigned long )pp != (unsigned long )((void *)0))) {
#line 2347
        goto while_break___0;
      }
#line 2353
      if (pp->time.tv_usec) {
        {
#line 2354
        printf((char const   */* __restrict  */)"%lu.%.6lu", (unsigned long )pp->time.tv_sec,
               (unsigned long )pp->time.tv_usec);
        }
      } else {
        {
#line 2357
        printf((char const   */* __restrict  */)"%lu", (unsigned long )pp->time.tv_sec);
        }
      }
#line 2362
      if (pp->fuzz != pattern_fuzz) {
        {
#line 2363
        printf((char const   */* __restrict  */)"/%d", pp->fuzz);
        }
      }
#line 2368
      pp = pp->next;
#line 2369
      if ((unsigned long )pp == (unsigned long )((void *)0)) {
        {
#line 2370
        printf((char const   */* __restrict  */)"\n");
        }
      } else {
        {
#line 2372
        printf((char const   */* __restrict  */)", ");
        }
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 2375
    pl = pl->next;
#line 2376
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2378
  printf((char const   */* __restrict  */)"\nTotal of %d backoff pattern entries.\n\n",
         i - 1);
  }
#line 2379
  return;
}
}
#line 2396 "/home/june/repo/benchmarks/collector/temp/ike-scan-1.9/ike-scan.c"
void dump_vid(void) 
{ 
  vid_pattern_list *pl ;
  int i ;
  int tmp ;

  {
  {
#line 2401
  printf((char const   */* __restrict  */)"Vendor ID Pattern List:\n\n");
#line 2402
  printf((char const   */* __restrict  */)"Entry\tName\tVendor ID Pattern\n");
#line 2403
  pl = vidlist;
#line 2404
  i = 1;
  }
  {
#line 2405
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2405
    if (! ((unsigned long )pl != (unsigned long )((void *)0))) {
#line 2405
      goto while_break;
    }
    {
#line 2406
    tmp = i;
#line 2406
    i ++;
#line 2406
    printf((char const   */* __restrict  */)"%d\t%s\t%s\n", tmp, pl->name, pl->pattern);
#line 2407
    pl = pl->next;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2409
  printf((char const   */* __restrict  */)"\nTotal of %d Vendor ID pattern entries.\n\n",
         i - 1);
  }
#line 2410
  return;
}
}
#line 2423 "/home/june/repo/benchmarks/collector/temp/ike-scan-1.9/ike-scan.c"
void dump_times(unsigned int num_hosts ) 
{ 
  time_list *te ;
  int i ;
  int time_no ;
  struct timeval prev_time ;
  struct timeval diff ;
  char *patname ;
  int unknown_patterns ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;

  {
  {
#line 2431
  unknown_patterns = 0;
#line 2433
  printf((char const   */* __restrict  */)"IKE Backoff Patterns:\n");
#line 2434
  printf((char const   */* __restrict  */)"\nIP Address\tNo.\tRecv time\t\tDelta Time\n");
#line 2435
  i = 0;
  }
  {
#line 2435
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2435
    if (! ((unsigned int )i < num_hosts)) {
#line 2435
      goto while_break;
    }
#line 2436
    if ((unsigned long )(*(helistptr + i))->recv_times != (unsigned long )((void *)0)) {
#line 2436
      if ((int )(*(helistptr + i))->num_recv > 0) {
#line 2437
        te = (*(helistptr + i))->recv_times;
#line 2438
        time_no = 1;
#line 2439
        diff.tv_sec = (__time_t )0;
#line 2440
        diff.tv_usec = (__suseconds_t )0;
        {
#line 2441
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 2441
          if (! ((unsigned long )te != (unsigned long )((void *)0))) {
#line 2441
            goto while_break___0;
          }
#line 2442
          if (time_no > 1) {
            {
#line 2443
            timeval_diff((struct timeval  const  *)(& te->time), (struct timeval  const  *)(& prev_time),
                         & diff);
            }
          }
          {
#line 2444
          tmp = inet_ntoa((*(helistptr + i))->addr);
#line 2444
          printf((char const   */* __restrict  */)"%s\t%d\t%lu.%.6lu\t%lu.%.6lu\n",
                 tmp, time_no, (unsigned long )te->time.tv_sec, (unsigned long )te->time.tv_usec,
                 (unsigned long )diff.tv_sec, (unsigned long )diff.tv_usec);
#line 2449
          prev_time = te->time;
#line 2450
          te = te->next;
#line 2451
          time_no ++;
          }
        }
        while_break___0: /* CIL Label */ ;
        }
        {
#line 2453
        patname = match_pattern(*(helistptr + i));
        }
#line 2453
        if ((unsigned long )patname != (unsigned long )((void *)0)) {
          {
#line 2454
          tmp___0 = inet_ntoa((*(helistptr + i))->addr);
#line 2454
          printf((char const   */* __restrict  */)"%s\tImplementation guess: %s\n",
                 tmp___0, patname);
          }
        } else {
#line 2457
          if (patlist) {
            {
#line 2458
            tmp___1 = inet_ntoa((*(helistptr + i))->addr);
#line 2458
            printf((char const   */* __restrict  */)"%s\tImplementation guess: %s\n",
                   tmp___1, "UNKNOWN");
            }
          } else {
            {
#line 2461
            tmp___2 = inet_ntoa((*(helistptr + i))->addr);
#line 2461
            printf((char const   */* __restrict  */)"%s\tImplementation guess: %s\n",
                   tmp___2, "UNKNOWN - No patterns available");
            }
          }
#line 2465
          unknown_patterns ++;
        }
        {
#line 2467
        printf((char const   */* __restrict  */)"\n");
        }
      }
    }
#line 2435
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2470
  if (unknown_patterns) {
#line 2470
    if (patlist) {
      {
#line 2471
      printf((char const   */* __restrict  */)"Some IKE implementations found have unknown backoff fingerprints\n");
#line 2472
      printf((char const   */* __restrict  */)"If you know the implementation name, and the pattern is reproducible, you\n");
#line 2473
      printf((char const   */* __restrict  */)"are encouraged to submit the pattern and implementation details for\n");
#line 2474
      printf((char const   */* __restrict  */)"inclusion in future versions of ike-scan.  See:\n");
#line 2475
      printf((char const   */* __restrict  */)"http://www.nta-monitor.com/tools/ike-scan/submit-patterns.html\n");
      }
    }
  }
#line 2477
  return;
}
}
#line 2492 "/home/june/repo/benchmarks/collector/temp/ike-scan-1.9/ike-scan.c"
char *match_pattern(host_entry *he ) 
{ 
  pattern_list *pl ;
  time_list *hp ;
  pattern_entry_list *pp ;
  struct timeval diff ;
  struct timeval prev_time ;
  int match ;
  int i ;
  int tmp ;

  {
#line 2498
  if ((unsigned long )he == (unsigned long )((void *)0)) {
#line 2499
    return ((char *)((void *)0));
  } else
#line 2498
  if ((unsigned long )patlist == (unsigned long )((void *)0)) {
#line 2499
    return ((char *)((void *)0));
  }
#line 2500
  if ((unsigned long )he->recv_times == (unsigned long )((void *)0)) {
#line 2501
    return ((char *)((void *)0));
  } else
#line 2500
  if ((int )he->num_recv < 1) {
#line 2501
    return ((char *)((void *)0));
  }
#line 2505
  pl = patlist;
  {
#line 2506
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2506
    if (! ((unsigned long )pl != (unsigned long )((void *)0))) {
#line 2506
      goto while_break;
    }
#line 2507
    if ((unsigned int )he->num_recv == pl->num_times) {
#line 2507
      if ((unsigned long )pl->recv_times != (unsigned long )((void *)0)) {
#line 2515
        hp = he->recv_times;
#line 2516
        pp = pl->recv_times;
#line 2517
        match = 1;
#line 2518
        i = 1;
#line 2519
        diff.tv_sec = (__time_t )0;
#line 2520
        diff.tv_usec = (__suseconds_t )0;
        {
#line 2521
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 2521
          if ((unsigned long )pp != (unsigned long )((void *)0)) {
#line 2521
            if (! ((unsigned long )hp != (unsigned long )((void *)0))) {
#line 2521
              goto while_break___0;
            }
          } else {
#line 2521
            goto while_break___0;
          }
#line 2522
          if (i > 1) {
            {
#line 2523
            timeval_diff((struct timeval  const  *)(& hp->time), (struct timeval  const  *)(& prev_time),
                         & diff);
            }
          }
          {
#line 2524
          tmp = times_close_enough(& pp->time, & diff, pp->fuzz);
          }
#line 2524
          if (! tmp) {
#line 2525
            match = 0;
#line 2526
            goto while_break___0;
          }
#line 2528
          prev_time = hp->time;
#line 2529
          pp = pp->next;
#line 2530
          hp = hp->next;
#line 2531
          i ++;
        }
        while_break___0: /* CIL Label */ ;
        }
#line 2533
        if (match) {
#line 2534
          return (pl->name);
        }
      }
    }
#line 2536
    pl = pl->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 2541
  return ((char *)((void *)0));
}
}
#line 2556 "/home/june/repo/benchmarks/collector/temp/ike-scan-1.9/ike-scan.c"
void add_recv_time(host_entry *he , struct timeval *last_recv_time ) 
{ 
  time_list *p ;
  time_list *te ;
  void *tmp ;

  {
  {
#line 2563
  tmp = Malloc(sizeof(time_list ));
#line 2563
  te = (time_list *)tmp;
#line 2564
  Gettimeofday(& te->time);
#line 2565
  last_recv_time->tv_sec = te->time.tv_sec;
#line 2566
  last_recv_time->tv_usec = te->time.tv_usec;
#line 2567
  te->next = (struct time_list_ *)((void *)0);
#line 2571
  p = he->recv_times;
  }
#line 2572
  if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 2573
    he->recv_times = te;
  } else {
    {
#line 2575
    while (1) {
      while_continue: /* CIL Label */ ;
#line 2575
      if (! ((unsigned long )p->next != (unsigned long )((void *)0))) {
#line 2575
        goto while_break;
      }
#line 2576
      p = p->next;
    }
    while_break: /* CIL Label */ ;
    }
#line 2577
    p->next = te;
  }
#line 2582
  he->num_recv = (unsigned short )((int )he->num_recv + 1);
#line 2583
  return;
}
}
#line 2597 "/home/june/repo/benchmarks/collector/temp/ike-scan-1.9/ike-scan.c"
void load_backoff_patterns(char const   *patfile , unsigned int pattern_fuzz ) 
{ 
  FILE *fp ;
  char line[255] ;
  int line_no ;
  char *fn ;
  char *tmp ;

  {
#line 2609
  if ((int const   )*patfile == 0) {
    {
#line 2621
    fn = make_message("%s/%s", "/usr/local/share/ike-scan", "ike-backoff-patterns");
    }
  } else {
    {
#line 2624
    fn = make_message("%s", patfile);
    }
  }
  {
#line 2627
  fp = fopen((char const   */* __restrict  */)fn, (char const   */* __restrict  */)"r");
  }
#line 2627
  if ((unsigned long )fp == (unsigned long )((void *)0)) {
    {
#line 2628
    warn_msg("WARNING: Cannot open IKE backoff patterns file.  ike-scan will still display");
#line 2629
    warn_msg("the backoff patterns, but it will not be able to identify the fingerprints.");
#line 2630
    warn_sys("fopen: %s", fn);
    }
  } else {
#line 2632
    line_no = 0;
    {
#line 2633
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 2633
      tmp = fgets((char */* __restrict  */)(line), 255, (FILE */* __restrict  */)fp);
      }
#line 2633
      if (! tmp) {
#line 2633
        goto while_break;
      }
#line 2634
      line_no ++;
#line 2635
      if ((int )line[0] != 35) {
#line 2635
        if ((int )line[0] != 10) {
#line 2635
          if ((int )line[0] != 13) {
            {
#line 2636
            add_pattern(line, pattern_fuzz);
            }
          }
        }
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 2638
    fclose(fp);
    }
  }
  {
#line 2640
  free((void *)fn);
  }
#line 2641
  return;
}
}
#line 2671 "/home/june/repo/benchmarks/collector/temp/ike-scan-1.9/ike-scan.c"
static char const   *backoff_pat_str  =    "([^\t]+)\t[\t ]*([^\t\r\n]+)";
#line 2672 "/home/june/repo/benchmarks/collector/temp/ike-scan-1.9/ike-scan.c"
static regex_t backoff_pat  ;
#line 2673 "/home/june/repo/benchmarks/collector/temp/ike-scan-1.9/ike-scan.c"
static int first_call___1  =    1;
#line 2655 "/home/june/repo/benchmarks/collector/temp/ike-scan-1.9/ike-scan.c"
void add_pattern(char *line , unsigned int pattern_fuzz ) 
{ 
  char *cp ;
  char name[255] ;
  char pat[255] ;
  pattern_list *pe ;
  pattern_list *p ;
  pattern_entry_list *te ;
  pattern_entry_list *tp ;
  char *endp ;
  unsigned int i ;
  long back_sec ;
  long back_usec ;
  char back_usec_str[7] ;
  int len ;
  unsigned int fuzz ;
  regmatch_t pmatch[3] ;
  int result ;
  size_t name_len ;
  size_t pat_len ;
  char errbuf[255] ;
  size_t errlen ;
  char errbuf___0[255] ;
  size_t errlen___0 ;
  void *tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;
  unsigned short const   **tmp___2 ;
  unsigned short const   **tmp___3 ;
  long tmp___4 ;
  void *tmp___5 ;

  {
#line 2682
  if (first_call___1) {
    {
#line 2683
    first_call___1 = 0;
#line 2684
    result = regcomp((regex_t */* __restrict  */)(& backoff_pat), (char const   */* __restrict  */)backoff_pat_str,
                     1);
    }
#line 2684
    if (result) {
      {
#line 2687
      errlen = regerror(result, (regex_t const   */* __restrict  */)(& backoff_pat),
                        (char */* __restrict  */)(errbuf), (size_t )255);
#line 2688
      err_msg("ERROR: cannot compile regex pattern \"%s\": %s", backoff_pat_str, errbuf);
      }
    }
  }
  {
#line 2698
  result = regexec((regex_t const   */* __restrict  */)(& backoff_pat), (char const   */* __restrict  */)line,
                   (size_t )3, (regmatch_t */* __restrict  */)(pmatch), 0);
  }
#line 2699
  if (result == 1) {
    {
#line 2700
    warn_msg("WARNING: Could not parse backoff pattern: %s", line);
    }
#line 2701
    return;
  } else
#line 2699
  if (pmatch[1].rm_so < 0) {
    {
#line 2700
    warn_msg("WARNING: Could not parse backoff pattern: %s", line);
    }
#line 2701
    return;
  } else
#line 2699
  if (pmatch[2].rm_so < 0) {
    {
#line 2700
    warn_msg("WARNING: Could not parse backoff pattern: %s", line);
    }
#line 2701
    return;
  } else
#line 2702
  if (result != 0) {
    {
#line 2705
    errlen___0 = regerror(result, (regex_t const   */* __restrict  */)(& backoff_pat),
                          (char */* __restrict  */)(errbuf___0), (size_t )255);
#line 2706
    err_msg("ERROR: backoff pattern match regexec failed: %s", errbuf___0);
    }
  }
  {
#line 2708
  name_len = (size_t )(pmatch[1].rm_eo - pmatch[1].rm_so);
#line 2709
  pat_len = (size_t )(pmatch[2].rm_eo - pmatch[2].rm_so);
#line 2710
  strncpy((char */* __restrict  */)(name), (char const   */* __restrict  */)(line + pmatch[1].rm_so),
          name_len);
#line 2711
  name[name_len] = (char )'\000';
#line 2712
  strncpy((char */* __restrict  */)(pat), (char const   */* __restrict  */)(line + pmatch[2].rm_so),
          pat_len);
#line 2713
  pat[pat_len] = (char )'\000';
#line 2717
  tmp = Malloc(sizeof(pattern_list ));
#line 2717
  pe = (pattern_list *)tmp;
#line 2718
  pe->next = (struct pattern_list_ *)((void *)0);
#line 2719
  pe->recv_times = (pattern_entry_list *)((void *)0);
#line 2720
  p = patlist;
  }
#line 2721
  if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 2722
    patlist = pe;
  } else {
    {
#line 2724
    while (1) {
      while_continue: /* CIL Label */ ;
#line 2724
      if (! ((unsigned long )p->next != (unsigned long )((void *)0))) {
#line 2724
        goto while_break;
      }
#line 2725
      p = p->next;
    }
    while_break: /* CIL Label */ ;
    }
#line 2726
    p->next = pe;
  }
  {
#line 2731
  tmp___0 = strlen((char const   *)(name));
#line 2731
  tmp___1 = Malloc(tmp___0 + 1UL);
#line 2731
  cp = (char *)tmp___1;
#line 2732
  strcpy((char */* __restrict  */)cp, (char const   */* __restrict  */)(name));
#line 2733
  pe->name = cp;
#line 2737
  i = 0U;
#line 2738
  endp = pat;
  }
  {
#line 2739
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 2739
    if (! ((int )*endp != 0)) {
#line 2739
      goto while_break___0;
    }
    {
#line 2743
    back_sec = strtol((char const   */* __restrict  */)endp, (char **/* __restrict  */)(& endp),
                      10);
    }
#line 2750
    if ((int )*endp == 46) {
#line 2751
      endp ++;
#line 2752
      len = 0;
#line 2753
      len = 0;
      {
#line 2753
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 2753
        if (! (len < 6)) {
#line 2753
          goto while_break___1;
        }
        {
#line 2754
        tmp___2 = __ctype_b_loc();
        }
#line 2754
        if ((int const   )*(*tmp___2 + (int )((unsigned char )*endp)) & 2048) {
#line 2755
          back_usec_str[len] = *endp;
#line 2756
          endp ++;
        } else {
#line 2758
          back_usec_str[len] = (char )'0';
        }
#line 2753
        len ++;
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 2761
      while (1) {
        while_continue___2: /* CIL Label */ ;
        {
#line 2761
        tmp___3 = __ctype_b_loc();
        }
#line 2761
        if (! ((int const   )*(*tmp___3 + (int )((unsigned char )*endp)) & 2048)) {
#line 2761
          goto while_break___2;
        }
#line 2762
        endp ++;
      }
      while_break___2: /* CIL Label */ ;
      }
      {
#line 2763
      back_usec_str[len] = (char )'\000';
#line 2764
      back_usec = strtol((char const   */* __restrict  */)(back_usec_str), (char **/* __restrict  */)((void *)0),
                         10);
      }
    } else {
#line 2766
      back_usec = 0L;
    }
#line 2772
    if ((int )*endp == 47) {
      {
#line 2773
      endp ++;
#line 2774
      tmp___4 = strtol((char const   */* __restrict  */)endp, (char **/* __restrict  */)(& endp),
                       10);
#line 2774
      fuzz = (unsigned int )tmp___4;
      }
    } else {
#line 2776
      fuzz = pattern_fuzz;
    }
    {
#line 2782
    tmp___5 = Malloc(sizeof(pattern_entry_list ));
#line 2782
    te = (pattern_entry_list *)tmp___5;
#line 2783
    te->next = (struct pattern_entry_list_ *)((void *)0);
#line 2784
    te->time.tv_sec = back_sec;
#line 2785
    te->time.tv_usec = back_usec;
#line 2786
    te->fuzz = fuzz;
#line 2787
    tp = pe->recv_times;
    }
#line 2788
    if ((unsigned long )tp == (unsigned long )((void *)0)) {
#line 2789
      pe->recv_times = te;
    } else {
      {
#line 2791
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 2791
        if (! ((unsigned long )tp->next != (unsigned long )((void *)0))) {
#line 2791
          goto while_break___3;
        }
#line 2792
        tp = tp->next;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 2793
      tp->next = te;
    }
#line 2798
    if ((int )*endp == 44) {
#line 2799
      endp ++;
    }
#line 2800
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 2802
  pe->num_times = i;
#line 2803
  return;
}
}
#line 2816 "/home/june/repo/benchmarks/collector/temp/ike-scan-1.9/ike-scan.c"
void load_vid_patterns(char const   *vidfile ) 
{ 
  FILE *fp ;
  char line[255] ;
  int line_no ;
  char *fn ;
  char *tmp ;

  {
#line 2828
  if ((int const   )*vidfile == 0) {
    {
#line 2840
    fn = make_message("%s/%s", "/usr/local/share/ike-scan", "ike-vendor-ids");
    }
  } else {
    {
#line 2843
    fn = make_message("%s", vidfile);
    }
  }
  {
#line 2846
  fp = fopen((char const   */* __restrict  */)fn, (char const   */* __restrict  */)"r");
  }
#line 2846
  if ((unsigned long )fp == (unsigned long )((void *)0)) {
    {
#line 2847
    warn_msg("WARNING: Cannot open Vendor ID patterns file.  ike-scan will still display");
#line 2848
    warn_msg("the raw Vendor ID data in hex, but it will not be able to display the");
#line 2849
    warn_msg("associated Vendor ID names.");
#line 2850
    warn_sys("fopen: %s", fn);
    }
  } else {
#line 2852
    line_no = 0;
    {
#line 2853
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 2853
      tmp = fgets((char */* __restrict  */)(line), 255, (FILE */* __restrict  */)fp);
      }
#line 2853
      if (! tmp) {
#line 2853
        goto while_break;
      }
#line 2854
      line_no ++;
#line 2855
      if ((int )line[0] != 35) {
#line 2855
        if ((int )line[0] != 10) {
#line 2855
          if ((int )line[0] != 13) {
            {
#line 2856
            add_vid_pattern(line);
            }
          }
        }
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 2858
    fclose(fp);
    }
  }
  {
#line 2860
  free((void *)fn);
  }
#line 2861
  return;
}
}
#line 2883 "/home/june/repo/benchmarks/collector/temp/ike-scan-1.9/ike-scan.c"
static char const   *vid_pat_str  =    "([^\t]+)\t[\t ]*([^\t\n\r]+)";
#line 2884 "/home/june/repo/benchmarks/collector/temp/ike-scan-1.9/ike-scan.c"
static regex_t vid_pat  ;
#line 2885 "/home/june/repo/benchmarks/collector/temp/ike-scan-1.9/ike-scan.c"
static int first_call___2  =    1;
#line 2874 "/home/june/repo/benchmarks/collector/temp/ike-scan-1.9/ike-scan.c"
void add_vid_pattern(char *line ) 
{ 
  char *cp ;
  regex_t *rep ;
  char name[255] ;
  char pat[255] ;
  vid_pattern_list *pe ;
  vid_pattern_list *p ;
  int result ;
  regmatch_t pmatch[3] ;
  size_t name_len ;
  size_t pat_len ;
  char errbuf[255] ;
  size_t errlen ;
  char errbuf___0[255] ;
  size_t errlen___0 ;
  void *tmp ;
  char errbuf___1[255] ;
  size_t errlen___1 ;
  void *tmp___0 ;
  size_t tmp___1 ;
  void *tmp___2 ;
  size_t tmp___3 ;
  void *tmp___4 ;

  {
#line 2893
  if (first_call___2) {
    {
#line 2894
    first_call___2 = 0;
#line 2895
    result = regcomp((regex_t */* __restrict  */)(& vid_pat), (char const   */* __restrict  */)vid_pat_str,
                     1);
    }
#line 2895
    if (result) {
      {
#line 2898
      errlen = regerror(result, (regex_t const   */* __restrict  */)(& vid_pat), (char */* __restrict  */)(errbuf),
                        (size_t )255);
#line 2899
      err_msg("ERROR: cannot compile regex pattern \"%s\": %s", vid_pat_str, errbuf);
      }
    }
  }
  {
#line 2906
  result = regexec((regex_t const   */* __restrict  */)(& vid_pat), (char const   */* __restrict  */)line,
                   (size_t )3, (regmatch_t */* __restrict  */)(pmatch), 0);
  }
#line 2907
  if (result == 1) {
    {
#line 2908
    warn_msg("WARNING: Could not parse vendor id pattern: %s", line);
    }
#line 2909
    return;
  } else
#line 2907
  if (pmatch[1].rm_so < 0) {
    {
#line 2908
    warn_msg("WARNING: Could not parse vendor id pattern: %s", line);
    }
#line 2909
    return;
  } else
#line 2907
  if (pmatch[2].rm_so < 0) {
    {
#line 2908
    warn_msg("WARNING: Could not parse vendor id pattern: %s", line);
    }
#line 2909
    return;
  } else
#line 2910
  if (result != 0) {
    {
#line 2913
    errlen___0 = regerror(result, (regex_t const   */* __restrict  */)(& vid_pat),
                          (char */* __restrict  */)(errbuf___0), (size_t )255);
#line 2914
    err_msg("ERROR: vendor id pattern match regexec failed: %s", errbuf___0);
    }
  }
  {
#line 2916
  name_len = (size_t )(pmatch[1].rm_eo - pmatch[1].rm_so);
#line 2917
  pat_len = (size_t )(pmatch[2].rm_eo - pmatch[2].rm_so);
#line 2918
  strncpy((char */* __restrict  */)(name), (char const   */* __restrict  */)(line + pmatch[1].rm_so),
          name_len);
#line 2919
  name[name_len] = (char )'\000';
#line 2920
  strncpy((char */* __restrict  */)(pat), (char const   */* __restrict  */)(line + pmatch[2].rm_so),
          pat_len);
#line 2921
  pat[pat_len] = (char )'\000';
#line 2929
  tmp = Malloc(sizeof(regex_t ));
#line 2929
  rep = (regex_t *)tmp;
#line 2930
  result = regcomp((regex_t */* __restrict  */)rep, (char const   */* __restrict  */)(pat),
                   (1 | (1 << 1)) | (((1 << 1) << 1) << 1));
  }
#line 2930
  if (result) {
    {
#line 2933
    errlen___1 = regerror(result, (regex_t const   */* __restrict  */)rep, (char */* __restrict  */)(errbuf___1),
                          (size_t )255);
#line 2934
    warn_msg("WARNING: Ignoring invalid Vendor ID pattern \"%s\": %s", pat, errbuf___1);
#line 2936
    free((void *)rep);
    }
  } else {
    {
#line 2942
    tmp___0 = Malloc(sizeof(vid_pattern_list ));
#line 2942
    pe = (vid_pattern_list *)tmp___0;
#line 2943
    pe->next = (struct vid_pattern_list_ *)((void *)0);
#line 2944
    p = vidlist;
    }
#line 2945
    if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 2946
      vidlist = pe;
    } else {
      {
#line 2948
      while (1) {
        while_continue: /* CIL Label */ ;
#line 2948
        if (! ((unsigned long )p->next != (unsigned long )((void *)0))) {
#line 2948
          goto while_break;
        }
#line 2949
        p = p->next;
      }
      while_break: /* CIL Label */ ;
      }
#line 2950
      p->next = pe;
    }
    {
#line 2955
    pe->regex = rep;
#line 2959
    tmp___1 = strlen((char const   *)(pat));
#line 2959
    tmp___2 = Malloc(tmp___1 + 1UL);
#line 2959
    cp = (char *)tmp___2;
#line 2960
    strcpy((char */* __restrict  */)cp, (char const   */* __restrict  */)(pat));
#line 2961
    pe->pattern = cp;
#line 2965
    tmp___3 = strlen((char const   *)(name));
#line 2965
    tmp___4 = Malloc(tmp___3 + 1UL);
#line 2965
    cp = (char *)tmp___4;
#line 2966
    strcpy((char */* __restrict  */)cp, (char const   */* __restrict  */)(name));
#line 2967
    pe->name = cp;
    }
  }
#line 2969
  return;
}
}
#line 2982 "/home/june/repo/benchmarks/collector/temp/ike-scan-1.9/ike-scan.c"
char **load_id_strings(char *filename ) 
{ 
  FILE *fp ;
  char line[255] ;
  char *cp ;
  int i ;
  size_t idstringlist_len ;
  size_t old_idstringlist_len ;
  int line_count ;
  char *idstringlist ;
  char **idstringlist_ptr ;
  size_t tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  char *tmp___2 ;
  void *tmp___3 ;
  size_t tmp___4 ;

  {
  {
#line 2988
  idstringlist_len = (size_t )0;
#line 2989
  old_idstringlist_len = (size_t )0;
#line 2990
  line_count = 0;
#line 2991
  idstringlist = (char *)((void *)0);
#line 2992
  idstringlist_ptr = (char **)((void *)0);
#line 2994
  fp = fopen((char const   */* __restrict  */)filename, (char const   */* __restrict  */)"r");
  }
#line 2994
  if ((unsigned long )fp == (unsigned long )((void *)0)) {
    {
#line 2995
    err_sys("ERROR: Cannot open ID file %s", filename);
    }
  }
  {
#line 3000
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 3000
    tmp___2 = fgets((char */* __restrict  */)(line), 255, (FILE */* __restrict  */)fp);
    }
#line 3000
    if (! tmp___2) {
#line 3000
      goto while_break;
    }
#line 3001
    line_count ++;
#line 3002
    cp = line;
    {
#line 3002
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 3002
      if (! ((int )*cp != 0)) {
#line 3002
        goto while_break___0;
      }
#line 3003
      if ((int )*cp == 13) {
#line 3004
        *cp = (char )'\000';
      } else
#line 3003
      if ((int )*cp == 10) {
#line 3004
        *cp = (char )'\000';
      }
#line 3002
      cp ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 3006
    old_idstringlist_len = idstringlist_len;
#line 3007
    tmp = strlen((char const   *)(line));
#line 3007
    idstringlist_len += tmp + 1UL;
    }
#line 3008
    if (idstringlist) {
      {
#line 3009
      tmp___0 = Realloc((void *)idstringlist, idstringlist_len);
#line 3009
      idstringlist = (char *)tmp___0;
      }
    } else {
      {
#line 3011
      tmp___1 = Malloc(idstringlist_len);
#line 3011
      idstringlist = (char *)tmp___1;
      }
    }
    {
#line 3013
    strcpy((char */* __restrict  */)(idstringlist + old_idstringlist_len), (char const   */* __restrict  */)(line));
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 3015
  fclose(fp);
#line 3019
  tmp___3 = Malloc(sizeof(char *) * (unsigned long )(line_count + 1));
#line 3019
  idstringlist_ptr = (char **)tmp___3;
#line 3020
  cp = idstringlist;
#line 3021
  i = 0;
  }
  {
#line 3021
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 3021
    if (! (i < line_count)) {
#line 3021
      goto while_break___1;
    }
    {
#line 3022
    *(idstringlist_ptr + i) = cp;
#line 3023
    tmp___4 = strlen((char const   *)cp);
#line 3023
    cp += tmp___4 + 1UL;
#line 3021
    i ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 3025
  *(idstringlist_ptr + line_count) = (char *)((void *)0);
#line 3027
  return (idstringlist_ptr);
}
}
#line 3045 "/home/june/repo/benchmarks/collector/temp/ike-scan-1.9/ike-scan.c"
void decode_trans_simple(char const   *trans_str , unsigned int *enc , unsigned int *keylen ,
                         unsigned int *hash , unsigned int *auth , unsigned int *group ) 
{ 
  char *cp ;
  char *str ;
  char *tok ;
  int pos ;
  size_t tmp ;
  void *tmp___0 ;
  unsigned long tmp___1 ;
  unsigned long tmp___2 ;

  {
  {
#line 3057
  tmp = strlen(trans_str);
#line 3057
  tmp___0 = Malloc(tmp + 1UL);
#line 3057
  str = (char *)tmp___0;
#line 3058
  strcpy((char */* __restrict  */)str, (char const   */* __restrict  */)trans_str);
#line 3063
  pos = 1;
#line 3064
  tok = strtok((char */* __restrict  */)str, (char const   */* __restrict  */)",");
  }
  {
#line 3065
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3065
    if (! ((unsigned long )tok != (unsigned long )((void *)0))) {
#line 3065
      goto while_break;
    }
    {
#line 3070
    if (pos == 1) {
#line 3070
      goto case_1;
    }
#line 3080
    if (pos == 2) {
#line 3080
      goto case_2;
    }
#line 3083
    if (pos == 3) {
#line 3083
      goto case_3;
    }
#line 3086
    if (pos == 4) {
#line 3086
      goto case_4;
    }
#line 3089
    goto switch_default;
    case_1: /* CIL Label */ 
    {
#line 3071
    cp = strchr((char const   *)tok, '/');
    }
#line 3072
    if ((unsigned long )cp != (unsigned long )((void *)0)) {
      {
#line 3073
      tmp___1 = Strtoul((char const   *)(cp + 1), 0);
#line 3073
      *keylen = (unsigned int )tmp___1;
#line 3074
      *cp = (char )'\000';
      }
    } else {
#line 3076
      *keylen = 0U;
    }
    {
#line 3078
    *enc = name_or_number((char const   *)tok, enc_map);
    }
#line 3079
    goto switch_break;
    case_2: /* CIL Label */ 
    {
#line 3081
    *hash = name_or_number((char const   *)tok, hash_map);
    }
#line 3082
    goto switch_break;
    case_3: /* CIL Label */ 
    {
#line 3084
    *auth = name_or_number((char const   *)tok, auth_map);
    }
#line 3085
    goto switch_break;
    case_4: /* CIL Label */ 
    {
#line 3087
    tmp___2 = Strtoul((char const   *)tok, 0);
#line 3087
    *group = (unsigned int )tmp___2;
    }
#line 3088
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 3090
    warn_msg("WARNING: Ignoring extra transform specifications past 4th");
    }
#line 3091
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
    {
#line 3096
    pos ++;
#line 3097
    tok = strtok((char */* __restrict  */)((void *)0), (char const   */* __restrict  */)"(),");
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 3099
  free((void *)str);
  }
#line 3100
  return;
}
}
#line 3113 "/home/june/repo/benchmarks/collector/temp/ike-scan-1.9/ike-scan.c"
unsigned char *decode_transform(char const   *trans_str , size_t *attr_len ) 
{ 
  char *str ;
  char *tok ;
  char *key_str ;
  char *value_str ;
  char *cp ;
  unsigned int key ;
  unsigned int b_value ;
  unsigned char *v_value ;
  size_t v_len ;
  unsigned char *attr ;
  size_t tmp ;
  void *tmp___0 ;
  unsigned long tmp___1 ;
  size_t tmp___2 ;
  unsigned long tmp___3 ;

  {
  {
#line 3129
  tmp = strlen(trans_str);
#line 3129
  tmp___0 = Malloc(tmp + 1UL);
#line 3129
  str = (char *)tmp___0;
#line 3130
  strcpy((char */* __restrict  */)str, (char const   */* __restrict  */)trans_str);
#line 3135
  tok = strtok((char */* __restrict  */)str, (char const   */* __restrict  */)"(),");
  }
  {
#line 3136
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3136
    if (! ((unsigned long )tok != (unsigned long )((void *)0))) {
#line 3136
      goto while_break;
    }
    {
#line 3140
    cp = strchr((char const   *)tok, '=');
    }
#line 3141
    if ((unsigned long )cp == (unsigned long )((void *)0)) {
      {
#line 3142
      err_msg("Error in transform attribute specification: %s", tok);
      }
    }
    {
#line 3143
    key_str = tok;
#line 3144
    value_str = cp + 1;
#line 3145
    *cp = (char )'\000';
#line 3151
    tmp___1 = Strtoul((char const   *)key_str, 10);
#line 3151
    key = (unsigned int )tmp___1;
    }
#line 3152
    if ((int )*(value_str + 0) == 48) {
#line 3152
      if ((int )*(value_str + 1) == 120) {
        {
#line 3153
        tmp___2 = strlen((char const   *)value_str);
        }
#line 3153
        if (tmp___2 % 2UL) {
          {
#line 3154
          err_msg("Length of variable attribute value must be even");
          }
        }
        {
#line 3155
        v_value = hex2data((char const   *)(value_str + 2), & v_len);
#line 3156
        add_attr(0, (size_t *)((void *)0), 'V', key, v_len, 0U, (void *)v_value);
        }
      } else {
        {
#line 3158
        tmp___3 = Strtoul((char const   *)value_str, 10);
#line 3158
        b_value = (unsigned int )tmp___3;
#line 3159
        add_attr(0, (size_t *)((void *)0), 'B', key, (size_t )0, b_value, (void *)0);
        }
      }
    } else {
      {
#line 3158
      tmp___3 = Strtoul((char const   *)value_str, 10);
#line 3158
      b_value = (unsigned int )tmp___3;
#line 3159
      add_attr(0, (size_t *)((void *)0), 'B', key, (size_t )0, b_value, (void *)0);
      }
    }
    {
#line 3164
    tok = strtok((char */* __restrict  */)((void *)0), (char const   */* __restrict  */)"(),");
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 3169
  free((void *)str);
#line 3170
  attr = add_attr(1, attr_len, '\000', 0U, (size_t )0, 0U, (void *)0);
  }
#line 3171
  return (attr);
}
}
#line 3186 "/home/june/repo/benchmarks/collector/temp/ike-scan-1.9/ike-scan.c"
void usage(int status , int detailed ) 
{ 
  char const   *tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;

  {
  {
#line 3188
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Usage: ike-scan [options] [hosts...]\n");
#line 3189
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
#line 3190
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Target hosts must be specified on the command line unless the --file option is\n");
#line 3191
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"given, in which case the targets are read from the specified file instead.\n");
#line 3192
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
#line 3193
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"The target hosts can be specified as IP addresses or hostnames.  You can also\n");
#line 3194
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"specify IPnetwork/bits (e.g. 192.168.1.0/24) to specify all hosts in the given\n");
#line 3195
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"network (network and broadcast addresses included), and IPstart-IPend\n");
#line 3196
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"(e.g. 192.168.1.3-192.168.1.27) to specify all hosts in the inclusive range.\n");
#line 3197
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
#line 3198
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"These different options for specifying target hosts may be used both on the\n");
#line 3199
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"command line, and also in the file specified with the --file option.\n");
#line 3200
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
  }
#line 3201
  if (detailed) {
    {
#line 3202
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"In the options below a letter or word in angle brackets like <f> denotes a\n");
#line 3203
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"value or string that should be supplied. The corresponding text should\n");
#line 3204
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"indicate the meaning of this value or string. When supplying the value or\n");
#line 3205
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"string, do not include the angle brackets. Text in square brackets like [<f>]\n");
#line 3206
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"mean that the enclosed text is optional. This is used for options which take\n");
#line 3207
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"an optional argument.\n");
#line 3208
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
#line 3209
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Options:\n");
#line 3210
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
#line 3211
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"--help or -h\t\tDisplay this usage message and exit.\n");
#line 3212
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n--file=<fn> or -f <fn>\tRead hostnames or addresses from the specified file\n");
#line 3213
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t\t\tinstead of from the command line. One name or IP\n");
#line 3214
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t\t\taddress per line.  Use \"-\" for standard input.\n");
#line 3215
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n--sport=<p> or -s <p>\tSet UDP source port to <p>, default=%u, 0=random.\n",
            500);
#line 3216
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t\t\tSome IKE implementations require the client to use\n");
#line 3217
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t\t\tUDP source port 500 and will not talk to other ports.\n");
#line 3218
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t\t\tNote that superuser privileges are normally required\n");
#line 3219
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t\t\tto use non-zero source ports below 1024.  Also only\n");
#line 3220
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t\t\tone process on a system may bind to a given source port\n");
#line 3221
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t\t\tat any one time. Use of the --nat-t option changes\n");
#line 3222
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t\t\tthe default source port to %u\n",
            4500);
#line 3223
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n--dport=<p> or -d <p>\tSet UDP destination port to <p>, default=%u.\n",
            500);
#line 3224
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t\t\tUDP port 500 is the assigned port number for ISAKMP\n");
#line 3225
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t\t\tand this is the port used by most if not all IKE\n");
#line 3226
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t\t\timplementations. Use of the --nat-t option changes\n");
#line 3227
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t\t\tthe default destination port to %u\n",
            4500);
#line 3228
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n--retry=<n> or -r <n>\tSet total number of attempts per host to <n>,\n");
#line 3229
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t\t\tdefault=%d.\n",
            3);
#line 3230
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n--timeout=<n> or -t <n>\tSet initial per host timeout to <n> ms, default=%d.\n",
            500);
#line 3231
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t\t\tThis timeout is for the first packet sent to each host.\n");
#line 3232
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t\t\tsubsequent timeouts are multiplied by the backoff\n");
#line 3233
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t\t\tfactor which is set with --backoff.\n");
#line 3234
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n--bandwidth=<n> or -B <n> Set desired outbound bandwidth to <n>, default=%u\n",
            56000);
#line 3235
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t\t\tThe value is in bits per second by default.  If you\n");
#line 3236
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t\t\tappend \"K\" to the value, then the units are kilobits\n");
#line 3237
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t\t\tper second; and if you append \"M\" to the value,\n");
#line 3238
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t\t\tthe units are megabits per second.\n");
#line 3239
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t\t\tThe \"K\" and \"M\" suffixes represent the decimal, not\n");
#line 3240
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t\t\tbinary, multiples.  So 64K is 64000, not 65536.\n");
#line 3241
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n--interval=<n> or -i <n> Set minimum packet interval to <n> ms.\n");
#line 3242
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t\t\tThe packet interval will be no smaller than this number.\n");
#line 3243
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t\t\tThe interval specified is in milliseconds by default.\n");
#line 3244
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t\t\tif \"u\" is appended to the value, then the interval\n");
#line 3245
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t\t\tis in microseconds, and if \"s\" is appended, the\n");
#line 3246
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t\t\tinterval is in seconds.\n");
#line 3247
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t\t\tIf you want to use up to a given bandwidth, then it is\n");
#line 3248
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t\t\teasier to use the --bandwidth option instead.\n");
#line 3249
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t\t\tYou cannot specify both --interval and --bandwidth\n");
#line 3250
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t\t\tbecause they are just different ways to change the\n");
#line 3251
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t\t\tsame underlying variable.\n");
#line 3252
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n--backoff=<b> or -b <b>\tSet timeout backoff factor to <b>, default=%.2f.\n",
            1.5);
#line 3253
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t\t\tThe per-host timeout is multiplied by this factor\n");
#line 3254
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t\t\tafter each timeout.  So, if the number of retries\n");
#line 3255
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t\t\tis 3, the initial per-host timeout is 500ms and the\n");
#line 3256
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t\t\tbackoff factor is 1.5, then the first timeout will be\n");
#line 3257
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t\t\t500ms, the second 750ms and the third 1125ms.\n");
#line 3258
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n--verbose or -v\t\tDisplay verbose progress messages.\n");
#line 3259
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t\t\tUse more than once for greater effect:\n");
#line 3260
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t\t\t1 - Show when each pass is completed and when\n");
#line 3261
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t\t\t    packets with invalid cookies are received.\n");
#line 3262
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t\t\t2 - Show each packet sent and received and when\n");
#line 3263
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t\t\t    hosts are removed from the list.\n");
#line 3264
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t\t\t3 - Display the host, Vendor ID and backoff lists\n");
#line 3265
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t\t\t    before scanning starts.\n");
#line 3266
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n--quiet or -q\t\tDon\'t decode the returned packet.\n");
#line 3267
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t\t\tThis prints less protocol information so the\n");
#line 3268
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t\t\toutput lines are shorter.\n");
#line 3269
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n--multiline or -M\tSplit the payload decode across multiple lines.\n");
#line 3270
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t\t\tWith this option, the decode for each payload is\n");
#line 3271
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t\t\tprinted on a separate line starting with a TAB.\n");
#line 3272
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t\t\tThis option makes the output easier to read, especially\n");
#line 3273
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t\t\twhen there are many payloads.\n");
#line 3274
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n--lifetime=<s> or -l <s> Set IKE lifetime to <s> seconds, default=%d.\n",
            28800);
#line 3275
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t\t\tRFC 2407 specifies 28800 as the default, but some\n");
#line 3276
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t\t\timplementations may require different values.\n");
#line 3277
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t\t\tIf you specify this as a a decimal integer, e.g.\n");
#line 3278
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t\t\t86400, then the attribute will use a 4-byte value.\n");
#line 3279
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t\t\tIf you specify it as a hex number, e.g. 0xFF, then\n");
#line 3280
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t\t\tthe attribute will use the appropriate size value\n");
#line 3281
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t\t\t(one byte for this example).\n");
#line 3282
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t\t\tIf you specify the string \"none\" then no lifetime\n");
#line 3283
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t\t\tattribute will be added at all.\n");
#line 3284
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t\t\tYou can use this option more than once in conjunction\n");
#line 3285
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t\t\twith the --trans options to produce multiple transform\n");
#line 3286
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t\t\tpayloads with different lifetimes.  Each --trans option\n");
#line 3287
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t\t\twill use the previously specified lifetime value.\n");
#line 3288
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n--lifesize=<s> or -z <s> Set IKE lifesize to <s> Kilobytes, default=%d.\n",
            0);
#line 3289
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t\t\tIf you specify this as a a decimal integer, e.g.\n");
#line 3290
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t\t\t86400, then the attribute will use a 4-byte value.\n");
#line 3291
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t\t\tIf you specify it as a hex number, e.g. 0xFF, then\n");
#line 3292
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t\t\tthe attribute will use the appropriate size value\n");
#line 3293
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t\t\t(one byte for this example).\n");
#line 3294
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t\t\tYou can use this option more than once in conjunction\n");
#line 3295
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t\t\twith the --trans options to produce multiple transform\n");
#line 3296
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t\t\tpayloads with different lifesizes.  Each --trans option\n");
#line 3297
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t\t\twill use the previously specified lifesize value.\n");
#line 3298
    tmp = id_to_name(1U, auth_map);
#line 3298
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n--auth=<n> or -m <n>\tSet auth. method to <n>, default=%u (%s).\n",
            1, tmp);
#line 3299
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t\t\tRFC defined values are 1 to 5.  See RFC 2409 Appendix A.\n");
#line 3300
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t\t\tCheckpoint hybrid mode is 64221.\n");
#line 3301
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t\t\tGSS (Windows \"Kerberos\") is 65001.\n");
#line 3302
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t\t\tXAUTH uses 65001 to 65010.\n");
#line 3303
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t\t\tThis is not applicable to IKEv2.\n");
#line 3304
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n--version or -V\t\tDisplay program version and exit.\n");
#line 3305
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n--vendor=<v> or -e <v>\tSet vendor id string to hex value <v>.\n");
#line 3306
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t\t\tYou can use this option more than once to send\n");
#line 3307
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t\t\tmultiple vendor ID payloads.\n");
#line 3308
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n--trans=<t> or -a <t>\tUse custom transform <t> instead of default set.\n");
#line 3309
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t\t\tYou can use this option more than once to send\n");
#line 3310
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t\t\tan arbitrary number of custom transforms.\n");
#line 3311
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t\t\tThere are two ways to specify the transform:\n");
#line 3312
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t\t\tThe new way, where you specify the attribute/value\n");
#line 3313
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t\t\tpairs, and the old way where you specify the values\n");
#line 3314
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t\t\tfor a fixed list of attributes.\n");
#line 3315
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t\t\tFor the new method, the transform <t> is specified as\n");
#line 3316
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t\t\t(attr=value, attr=value, ...)\n");
#line 3317
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t\t\tWhere \"attr\" is the attribute number, and \"value\" is\n");
#line 3318
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t\t\tthe value to assign to that attribute.  You can specify\n");
#line 3319
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t\t\tan arbitary number of attribute/value pairs.\n");
#line 3320
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t\t\tSee RFC 2409 Appendix A for details of the attributes\n");
#line 3321
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t\t\tand values.\n");
#line 3322
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t\t\tNote that brackets are special to some shells, so you\n");
#line 3323
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t\t\tmay need to quote them, e.g.\n");
#line 3324
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t\t\t--trans=\"(1=1,2=2,3=3,4=4)\". For example,\n");
#line 3325
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t\t\t--trans=(1=1,2=2,3=1,4=2) specifies\n");
#line 3326
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t\t\tEnc=3DES-CBC, Hash=SHA1, Auth=shared key, DH Group=2;\n");
#line 3327
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t\t\tand --trans=(1=7,14=128,2=1,3=3,4=5) specifies\n");
#line 3328
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t\t\tEnc=AES/128, Hash=MD5, Auth=RSA sig, DH Group=5.\n");
#line 3329
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t\t\tFor the old method, the transform <t> is specified as\n");
#line 3330
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t\t\tenc[/len],hash,auth,group.\n");
#line 3331
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t\t\tWhere enc is the encryption algorithm,\n");
#line 3332
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t\t\tlen is the key length for variable length ciphers,\n");
#line 3333
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t\t\thash is the hash algorithm, and group is the DH Group.\n");
#line 3334
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t\t\tFor example, --trans=5,2,1,2 specifies\n");
#line 3335
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t\t\tEnc=3DES-CBC, Hash=SHA1, Auth=shared key, DH Group=2;\n");
#line 3336
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t\t\tand --trans=7/256,1,1,5 specifies\n");
#line 3337
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t\t\tEnc=AES-256, Hash=MD5, Auth=shared key, DH Group=5.\n");
#line 3338
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t\t\tThis option is not yet supported for IKEv2.\n");
#line 3339
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n--showbackoff[=<n>] or -o[<n>]\tDisplay the backoff fingerprint table.\n");
#line 3340
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t\t\tDisplay the backoff table to fingerprint the IKE\n");
#line 3341
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t\t\timplementation on the remote hosts.\n");
#line 3342
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t\t\tThe optional argument specifies time to wait in seconds\n");
#line 3343
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t\t\tafter receiving the last packet, default=%d.\n",
            60);
#line 3344
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t\t\tIf you are using the short form of the option (-o)\n");
#line 3345
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t\t\tthen the value must immediately follow the option\n");
#line 3346
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t\t\tletter with no spaces, e.g. -o25 not -o 25.\n");
#line 3347
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n--fuzz=<n> or -u <n>\tSet pattern matching fuzz to <n> ms, default=%d.\n",
            500);
#line 3348
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t\t\tThis sets the maximum acceptable difference between\n");
#line 3349
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t\t\tthe observed backoff times and the reference times in\n");
#line 3350
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t\t\tthe backoff patterns file.  Larger values allow for\n");
#line 3351
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t\t\thigher variance but also increase the risk of\n");
#line 3352
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t\t\tfalse positive identifications.\n");
#line 3353
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t\t\tAny per-pattern-entry fuzz specifications in the\n");
#line 3354
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t\t\tpatterns file will override the value set here.\n");
#line 3359
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n--patterns=<f> or -p <f> Use IKE backoff patterns file <f>,\n");
#line 3360
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t\t\tdefault=%s/%s.\n",
            "/usr/local/share/ike-scan", "ike-backoff-patterns");
#line 3362
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t\t\tThis specifies the name of the file containing\n");
#line 3363
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t\t\tIKE backoff patterns.  This file is only used when\n");
#line 3364
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t\t\t--showbackoff is specified.\n");
#line 3369
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n--vidpatterns=<f> or -I <f> Use Vendor ID patterns file <f>,\n");
#line 3370
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t\t\tdefault=%s/%s.\n",
            "/usr/local/share/ike-scan", "ike-vendor-ids");
#line 3372
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t\t\tThis specifies the name of the file containing\n");
#line 3373
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t\t\tVendor ID patterns.  These patterns are used for\n");
#line 3374
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t\t\tVendor ID fingerprinting.\n");
#line 3375
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n--aggressive or -A\tUse IKE Aggressive Mode (The default is Main Mode)\n");
#line 3376
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t\t\tIf you specify --aggressive, then you may also\n");
#line 3377
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t\t\tspecify --dhgroup, --id and --idtype.  If you use\n");
#line 3378
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t\t\tcustom transforms with aggressive mode with the --trans\n");
#line 3379
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t\t\toption, note that all transforms should have the same\n");
#line 3380
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t\t\tDH Group and this should match the group specified\n");
#line 3381
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t\t\twith --dhgroup or the default if --dhgroup is not used.\n");
#line 3382
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n--id=<id> or -n <id>\tUse <id> as the identification value.\n");
#line 3383
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t\t\tThis option is only applicable to Aggressive Mode.\n");
#line 3384
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t\t\t<id> can be specified as a string, e.g. --id=test or as\n");
#line 3385
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t\t\ta hex value with a leading \"0x\", e.g. --id=0xdeadbeef.\n");
#line 3386
    tmp___0 = id_to_name(3U, id_map);
#line 3386
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n--idtype=<n> or -y <n>\tUse identification type <n>.  Default %u (%s).\n",
            3, tmp___0);
#line 3387
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t\t\tThis option is only applicable to Aggressive Mode.\n");
#line 3388
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t\t\tSee RFC 2407 4.6.2 for details of Identification types.\n");
#line 3389
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n--dhgroup=<n> or -g <n>\tUse Diffie Hellman Group <n>.  Default %u.\n",
            2);
#line 3390
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t\t\tThis option is only applicable to Aggressive Mode and\n");
#line 3391
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t\t\tIKEv2.  For both of these, it is used to determine the\n");
#line 3392
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t\t\tsize of the key exchange payload.\n");
#line 3393
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t\t\tIf you use Aggressive Mode with custom transforms, then\n");
#line 3394
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t\t\tyou will normally need to use the --dhgroup option\n");
#line 3395
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t\t\tunless you are using the default DH group.\n");
#line 3396
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t\t\tAcceptable values are 1,2,5,14,15,16,17,18 (MODP only).\n");
#line 3397
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n--gssid=<n> or -G <n>\tUse GSS ID <n> where <n> is a hex string.\n");
#line 3398
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t\t\tThis uses transform attribute type 16384 as specified\n");
#line 3399
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t\t\tin draft-ietf-ipsec-isakmp-gss-auth-07.txt, although\n");
#line 3400
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t\t\tWindows-2000 has been observed to use 32001 as well.\n");
#line 3401
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t\t\tFor Windows 2000, you\'ll need to use --auth=65001 to\n");
#line 3402
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t\t\tspecify Kerberos (GSS) authentication.\n");
#line 3403
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n--random or -R\t\tRandomise the host list.\n");
#line 3404
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t\t\tThis option randomises the order of the hosts in the\n");
#line 3405
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t\t\thost list, so the IKE probes are sent to the hosts in\n");
#line 3406
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t\t\ta random order.  It uses the Knuth shuffle algorithm.\n");
#line 3407
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n--tcp[=<n>] or -T[<n>]\tUse TCP transport instead of UDP.\n");
#line 3408
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t\t\tThis allows you to test a host running IKE over TCP.\n");
#line 3409
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t\t\tYou won\'t normally need this option because the vast\n");
#line 3410
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t\t\tmajority of IPsec systems only support IKE over UDP.\n");
#line 3411
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t\t\tThe optional value <n> specifies the type of IKE over\n");
#line 3412
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t\t\tTCP.  There are currently two possible values:\n");
#line 3413
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t\t\t1 = RAW IKE over TCP as used by Checkpoint (default);\n");
#line 3414
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t\t\t2 = Encapsulated IKE over TCP as used by Cisco.\n");
#line 3415
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t\t\tIf you are using the short form of the option (-T)\n");
#line 3416
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t\t\tthen the value must immediately follow the option\n");
#line 3417
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t\t\tletter with no spaces, e.g. -T2 not -T 2.\n");
#line 3418
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t\t\tYou can only specify a single target host if you use\n");
#line 3419
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t\t\tthis option.\n");
#line 3420
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n--tcptimeout=<n> or -O <n> Set TCP connect timeout to <n> seconds (default=%u).\n",
            10);
#line 3421
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t\t\tThis is only applicable to TCP transport mode.\n");
#line 3422
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n--pskcrack[=<f>] or -P[<f>] Crack aggressive mode pre-shared keys.\n");
#line 3423
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t\t\tThis option outputs the aggressive mode pre-shared key\n");
#line 3424
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t\t\t(PSK) parameters for offline cracking using the\n");
#line 3425
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t\t\t\"psk-crack\" program that is supplied with ike-scan.\n");
#line 3426
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t\t\tYou can optionally specify a filename, <f>, to write\n");
#line 3427
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t\t\tthe PSK parameters to.  If you do not specify a filename\n");
#line 3428
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t\t\tthen the PSK parameters are written to standard output.\n");
#line 3429
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t\t\tIf you are using the short form of the option (-P)\n");
#line 3430
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t\t\tthen the value must immediately follow the option\n");
#line 3431
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t\t\tletter with no spaces, e.g. -Pfile not -P file.\n");
#line 3432
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t\t\tYou can only specify a single target host if you use\n");
#line 3433
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t\t\tthis option.\n");
#line 3434
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t\t\tThis option is only applicable to IKE aggressive mode.\n");
#line 3435
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n--nodns or -N\t\tDo not use DNS to resolve names.\n");
#line 3436
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t\t\tIf you use this option, then all hosts must be\n");
#line 3437
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t\t\tspecified as IP addresses.\n");
#line 3438
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n--noncelen=<n> or -c <n> Set the nonce length to <n> bytes. Default=%u\n",
            20);
#line 3439
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t\t\tThis option controls the length of the nonce payload\n");
#line 3440
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t\t\tthat is sent in an aggressive mode or IKEv2 request.\n");
#line 3441
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t\t\tNormally there is no need to use this option unless you\n");
#line 3442
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t\t\twant to reduce the nonce size to speed up pre-shared\n");
#line 3443
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t\t\tkey cracking, or if you want to see how a particular\n");
#line 3444
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t\t\tserver handles different length nonce payloads.\n");
#line 3445
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t\t\tRFC 2409 states that the length of nonce payload\n");
#line 3446
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t\t\tmust be between 8 and 256 bytes, but ike-scan does\n");
#line 3447
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t\t\tnot enforce this.\n");
#line 3448
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t\t\tSpecifying a large nonce length will increase the\n");
#line 3449
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t\t\tsize of the packet sent by ike-scan. A very large nonce\n");
#line 3450
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t\t\tlength may cause fragmentation, or exceed the maximum\n");
#line 3451
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t\t\tIP packet size.\n");
#line 3452
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t\t\tThis option is only applicable to IKE aggressive mode.\n");
#line 3453
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n--headerlen=<n> or -L <n> Set the length in the ISAKMP header to <n> bytes.\n");
#line 3454
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t\t\tYou can use this option to manually specify the value\n");
#line 3455
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t\t\tto be used for the ISAKMP header length.\n");
#line 3456
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t\t\tBy default, ike-scan will fill in the correct value.\n");
#line 3457
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t\t\tUse this option to manually specify an incorrect\n");
#line 3458
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t\t\tlength.\n");
#line 3459
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t\t\t<n> can be specified as \"+n\" which sets the length\n");
#line 3460
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t\t\tto n bytes more than it should be, \"-n\" which sets\n");
#line 3461
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t\t\tit to n bytes less, or \"n\" which sets it to exactly\n");
#line 3462
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t\t\tbytes.\n");
#line 3463
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t\t\tChanging the header length to an incorrect value can\n");
#line 3464
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t\t\tsometimes disrupt VPN servers.\n");
#line 3465
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n--mbz=<n> or -Z <n>\tUse the value <n> for reserved (MBZ) fields, default=0.\n");
#line 3466
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t\t\tSpecifying this option makes the outgoing packet\n");
#line 3467
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t\t\tnon-RFC compliant, and should only be used if you want\n");
#line 3468
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t\t\tto see how a VPN server will respond to invalid packets.\n");
#line 3469
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t\t\tThe value of <n> should be in the range 0-255.\n");
#line 3470
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n--headerver=<n> or -E <n> Specify the ISAKMP header version.\n");
#line 3471
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t\t\tThe default is 0x10 (16) which corresponds to v1.0.\n");
#line 3472
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t\t\tSpecifying a non-default value will make the outgoing\n");
#line 3473
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t\t\tpacket non-RFC compliant, and should only be used if\n");
#line 3474
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t\t\tyou want to see how the VPN server reacts to strange\n");
#line 3475
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t\t\tversions.\n");
#line 3476
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t\t\tThe value should be in the range 0-255.\n");
#line 3477
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n--certreq=<c> or -C <c> Add the CertificateRequest payload <c>.\n");
#line 3478
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t\t\t<c> should be specified as a hex value.\n");
#line 3479
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t\t\tThe first byte of the hex value will be interpreted as\n");
#line 3480
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t\t\tthe certificate type; the remaining bytes as the\n");
#line 3481
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t\t\tcertificate authority as described in RFC 2408 3.10.\n");
#line 3482
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t\t\tThe certificate types are listed in RFC 2408 sec 3.9.\n");
#line 3483
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t\t\tRFC 2048 states \"The Certificate Request payload MUST\n");
#line 3484
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t\t\tbe accepted at any point during the exchange\"\n");
#line 3485
    tmp___1 = id_to_name(1U, doi_map);
#line 3485
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n--doi=<d> or -D <d>\tSet the SA DOI to <d>, default %u (%s).\n",
            1, tmp___1);
#line 3486
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t\t\tYou will not normally want to change this unless you\n");
#line 3487
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t\t\twant to see how the VPN server responds to a\n");
#line 3488
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t\t\tnon-standard DOI.\n");
#line 3489
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n--situation=<s> or -S <s> Set the SA Situation to <d>, default %u.\n",
            1);
#line 3490
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t\t\tThe meaning of the situation depends on the DOI, and\n");
#line 3491
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t\t\tis detailed in the appropriate DOI document.  For the\n");
#line 3492
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t\t\tIPsec DOI, the default Situation of %u represents\n",
            1);
#line 3493
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t\t\tSIT_IDENTITY_ONLY.\n");
#line 3494
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t\t\tYou will not normally want to change this unless you\n");
#line 3495
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t\t\twant to see how the VPN server responds to a\n");
#line 3496
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t\t\tnon-standard situation.\n");
#line 3497
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n--protocol=<p> or -j <p> Set the Proposal protocol ID to <p>, default %u.\n",
            1);
#line 3498
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t\t\tThe meaning of the proposal protocol ID depends on\n");
#line 3499
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t\t\tthe DOI, and is detailed in the appropriate DOI\n");
#line 3500
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t\t\tdocument.  For the IPsec DOI, the default proposal\n");
#line 3501
    tmp___2 = id_to_name(1U, protocol_map);
#line 3501
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t\t\tprotocol id of %u represents %s.\n",
            1, tmp___2);
#line 3502
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t\t\tYou will not normally want to change this unless you\n");
#line 3503
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t\t\twant to see how the VPN server responds to a\n");
#line 3504
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t\t\tnon-standard protocol ID.\n");
#line 3505
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n--transid=<t> or -k <t> Set the Transform ID to <t>, default %u.\n",
            1);
#line 3506
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t\t\tThe meaning of the transform ID depends on the\n");
#line 3507
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t\t\tDOI, and is detailed in the appropriate DOI\n");
#line 3508
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t\t\tdocument.  For the IPsec DOI, the default\n");
#line 3509
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t\t\ttransform id of %u represents KEY_IKE.\n",
            1);
#line 3510
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t\t\tYou will not normally want to change this unless you\n");
#line 3511
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t\t\twant to see how the VPN server responds to a\n");
#line 3512
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t\t\tnon-standard transform ID.\n");
#line 3513
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n--spisize=<n>\t\tSet the proposal SPI size to <n>.  Default=0\n");
#line 3514
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t\t\tIf this is non-zero, then a random SPI of the\n");
#line 3515
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t\t\tspecified size will be added to the proposal payload.\n");
#line 3516
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t\t\tThe default of zero means no SPI.\n");
#line 3517
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n--hdrflags=<n>\t\tSet the ISAKMP header flags to <n>.  Default=0\n");
#line 3518
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t\t\tThe flags are detailed in RFC 2408 section 3.1\n");
#line 3519
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n--hdrmsgid=<n>\t\tSet the ISAKMP header message ID to <n>.  Default=0\n");
#line 3520
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t\t\tThis should be zero for IKE Phase-1.\n");
#line 3521
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n--cookie=<n>\t\tSet the ISAKMP initiator cookie to <n>\n");
#line 3522
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t\t\tThe cookie value should be specified in hex.\n");
#line 3523
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t\t\tBy default, the cookies are automatically generated\n");
#line 3524
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t\t\tand have unique values.  If you specify this option,\n");
#line 3525
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t\t\tthen you can only specify a single target, because\n");
#line 3526
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t\t\tike-scan requires unique cookie values to match up\n");
#line 3527
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t\t\tthe response packets.\n");
#line 3528
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n--exchange=<n>\t\tSet the exchange type to <n>\n");
#line 3529
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t\t\tThis option allows you to change the exchange type in\n");
#line 3530
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t\t\tthe ISAKMP header to an arbitrary value.\n");
#line 3531
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t\t\tNote that ike-scan only supports Main and Aggressive\n");
#line 3532
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t\t\tmodes (values 2 and 4 respectively).  Specifying\n");
#line 3533
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t\t\tother values will change the exchange type value in\n");
#line 3534
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t\t\tthe ISAKMP header, but will not adjust the other\n");
#line 3535
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t\t\tpayloads.\n");
#line 3536
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t\t\tThe exchange types are defined in RFC 2408 sec 3.1.\n");
#line 3537
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n--nextpayload=<n>\tSet the next payload in the ISAKMP header to <n>\n");
#line 3538
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t\t\tNormally, the next payload is automatically set to the\n");
#line 3539
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t\t\tcorrect value.\n");
#line 3540
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n--randomseed=<n>\tUse <n> to seed the pseudo random number generator.\n");
#line 3541
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t\t\tThis option seeds the PRNG with the specified number,\n");
#line 3542
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t\t\twhich can be useful if you want to ensure that the\n");
#line 3543
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t\t\tpacket data is exactly repeatable when it includes\n");
#line 3544
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t\t\tpayloads with random data such as key exchange or nonce.\n");
#line 3545
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t\t\tBy default, the PRNG is seeded with an unpredictable\n");
#line 3546
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t\t\tvalue.\n");
#line 3547
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n--timestamp\t\tDisplay timestamps for received packets.\n");
#line 3548
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t\t\tThis option causes a timestamp to be displayed for\n");
#line 3549
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t\t\teach received packet.\n");
#line 3550
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n--sourceip=<s>\t\tSet source IP address for outgoing packets to <s>.\n");
#line 3551
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t\t\tThis option causes the outgoing IKE packets to have\n");
#line 3552
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t\t\tthe specified source IP address.\n");
#line 3553
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t\t\tThe address can either be an IP address in dotted\n");
#line 3554
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t\t\tquad format, or the string \"random\" which will use\n");
#line 3555
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t\t\ta different random source address for each packet that\n");
#line 3556
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t\t\tis sent.\n");
#line 3557
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t\t\tIf this option is used, no packets will be received\n");
#line 3558
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t\t\tThis option requires raw socket support, and you\n");
#line 3559
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t\t\twill need superuser privileges to use this option,\n");
#line 3560
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t\t\teven if you specify a high source port.\n");
#line 3561
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t\t\tThis option does not work on all operating systems.\n");
#line 3562
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n--shownum\t\tDisplay the host number for received packets.\n");
#line 3563
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t\t\tThis displays the ordinal host number of the\n");
#line 3564
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t\t\tresponding host before the IP address. It can be useful\n");
#line 3565
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t\t\twhen sending many packets to the same target IP, to\n");
#line 3566
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t\t\tsee if any probes are being ignored.\n");
#line 3567
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n--nat-t\t\t\tUse RFC 3947 NAT-Traversal encapsulation.\n");
#line 3568
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t\t\tThis option adds the non-ESP marker to the beginning\n");
#line 3569
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t\t\tof outgoing packets and strips it from received\n");
#line 3570
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t\t\tpackets, as described in RFC 3947. It also changes the\n");
#line 3571
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t\t\tdefault source port to %u and the default destination\n",
            4500);
#line 3572
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t\t\tport to %u, which are the ports for NAT-T IKE.\n",
            4500);
#line 3573
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t\t\tThese port numbers can be changed with the --sport and\n");
#line 3574
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t\t\t--dport options, providing they are used after the\n");
#line 3575
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t\t\t--nat-t option.\n");
#line 3576
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n--rcookie=<n>\t\tSet the ISAKMP responder cookie to <n>.\n");
#line 3577
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t\t\tThis sets the responder cookie to the specified hex\n");
#line 3578
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t\t\tvalue.  By default, the responder cookie is set to zero.\n");
#line 3579
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n--ikev2 or -2\t\tUse IKE version 2\n");
#line 3580
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t\t\tThis causes the outgoing packets to use IKEv2 format\n");
#line 3581
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t\t\tas defined in RFC 4306 instead of the default IKEv1\n");
#line 3582
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t\t\tformat. Any packets returned are automatically decoded\n");
#line 3583
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t\t\tas IKE or IKEv2 depending on their payloads irrespective\n");
#line 3584
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t\t\tof this option.\n");
#line 3585
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t\t\tThe --ikev2 option is currently experimental. It has not\n");
#line 3586
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t\t\tbeen extensively tested, and it only supports sending\n");
#line 3587
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t\t\tthe default proposal.\n");
    }
  } else {
    {
#line 3589
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"use \"ike-scan --help\" for detailed information on the available options.\n");
    }
  }
  {
#line 3591
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
#line 3592
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Report bugs or send suggestions to %s\n",
          "ike-scan@nta-monitor.com");
#line 3593
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"See the ike-scan homepage at http://www.nta-monitor.com/tools/ike-scan/\n");
#line 3594
  exit(status);
  }
}
}
#line 70 "/home/june/repo/benchmarks/collector/temp/ike-scan-1.9/sha1.c"
static unsigned char workspace___0[64]  ;
#line 55 "/home/june/repo/benchmarks/collector/temp/ike-scan-1.9/wrappers.c"
static char rcsid___4[48]  = 
#line 55 "/home/june/repo/benchmarks/collector/temp/ike-scan-1.9/wrappers.c"
  {      (char )'$',      (char )'I',      (char )'d',      (char )':', 
        (char )' ',      (char )'w',      (char )'r',      (char )'a', 
        (char )'p',      (char )'p',      (char )'e',      (char )'r', 
        (char )'s',      (char )'.',      (char )'c',      (char )' ', 
        (char )'9',      (char )'8',      (char )'8',      (char )'4', 
        (char )' ',      (char )'2',      (char )'0',      (char )'0', 
        (char )'7',      (char )'-',      (char )'0',      (char )'1', 
        (char )'-',      (char )'1',      (char )'4',      (char )' ', 
        (char )'1',      (char )'9',      (char )':',      (char )'0', 
        (char )'5',      (char )':',      (char )'3',      (char )'9', 
        (char )'Z',      (char )' ',      (char )'r',      (char )'s', 
        (char )'h',      (char )' ',      (char )'$',      (char )'\000'};
#line 433 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) sscanf)(char const   * __restrict  __s ,
                                                                             char const   * __restrict  __format 
                                                                             , ...)  __asm__("__isoc99_sscanf")  ;
#line 69 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) memcmp)(void const   *__s1 ,
                                                                                               void const   *__s2 ,
                                                                                               size_t __n )  __attribute__((__pure__)) ;
#line 136 "/home/june/repo/benchmarks/collector/temp/ike-scan-1.9/psk-crack.h"
static unsigned int load_psk_params(char const   *filename , char const   *nortel_user ) ;
#line 137
__inline static unsigned char *compute_hash(psk_entry const   *psk_params , char const   *password ) ;
#line 138
static FILE *open_dict_file(char const   *dict_file_name ) ;
#line 145
static void psk_crack_usage(int status ) ;
#line 102 "/home/june/repo/benchmarks/collector/temp/ike-scan-1.9/hash_functions.h"
static unsigned char m___0[20]  ;
#line 99 "/home/june/repo/benchmarks/collector/temp/ike-scan-1.9/hash_functions.h"
__inline static unsigned char *SHA1(unsigned char const   *d , size_t n , unsigned char *md ) 
{ 
  SHA1_CTX context ;

  {
#line 104
  if ((unsigned long )md == (unsigned long )((void *)0)) {
#line 105
    md = m___0;
  }
  {
#line 107
  SHA1Init(& context);
#line 113
  SHA1Update(& context, (unsigned char *)d, (unsigned int )n);
#line 114
  SHA1Final((unsigned char *)md, & context);
  }
#line 116
  return (md);
}
}
#line 144 "/home/june/repo/benchmarks/collector/temp/ike-scan-1.9/hash_functions.h"
static unsigned char m___1[16]  ;
#line 141 "/home/june/repo/benchmarks/collector/temp/ike-scan-1.9/hash_functions.h"
__inline static unsigned char *hmac_md5(unsigned char const   *text , size_t text_len ,
                                        unsigned char const   *key , size_t key_len ,
                                        unsigned char *md ) 
{ 
  md5_state_t context ;
  unsigned char k_ipad[65] ;
  unsigned char k_opad[65] ;
  unsigned char tk[16] ;
  int i ;
  md5_state_t tctx ;

  {
#line 155
  if ((unsigned long )md == (unsigned long )((void *)0)) {
#line 156
    md = m___1;
  }
#line 159
  if (key_len > 64UL) {
    {
#line 169
    md5_init(& tctx);
#line 170
    md5_append(& tctx, key, (int )key_len);
#line 171
    md5_finish(& tctx, (md5_byte_t *)(tk));
#line 174
    key = (unsigned char const   *)(tk);
#line 175
    key_len = (size_t )16;
    }
  }
  {
#line 189
  memset((void *)(k_ipad), '\000', sizeof(k_ipad));
#line 190
  memset((void *)(k_opad), '\000', sizeof(k_opad));
#line 191
  memcpy((void */* __restrict  */)(k_ipad), (void const   */* __restrict  */)key,
         key_len);
#line 192
  memcpy((void */* __restrict  */)(k_opad), (void const   */* __restrict  */)key,
         key_len);
#line 195
  i = 0;
  }
  {
#line 195
  while (1) {
    while_continue: /* CIL Label */ ;
#line 195
    if (! (i < 64)) {
#line 195
      goto while_break;
    }
#line 196
    k_ipad[i] = (unsigned char )((int )k_ipad[i] ^ 54);
#line 197
    k_opad[i] = (unsigned char )((int )k_opad[i] ^ 92);
#line 195
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 218
  md5_init(& context);
#line 219
  md5_append(& context, (md5_byte_t const   *)(k_ipad), 64);
#line 220
  md5_append(& context, text, (int )text_len);
#line 221
  md5_finish(& context, (md5_byte_t *)md);
#line 225
  md5_init(& context);
#line 226
  md5_append(& context, (md5_byte_t const   *)(k_opad), 64);
#line 227
  md5_append(& context, (md5_byte_t const   *)md, 16);
#line 228
  md5_finish(& context, (md5_byte_t *)md);
  }
#line 231
  return (md);
}
}
#line 258 "/home/june/repo/benchmarks/collector/temp/ike-scan-1.9/hash_functions.h"
static unsigned char m___2[20]  ;
#line 255 "/home/june/repo/benchmarks/collector/temp/ike-scan-1.9/hash_functions.h"
__inline static unsigned char *hmac_sha1(unsigned char const   *text , size_t text_len ,
                                         unsigned char const   *key , size_t key_len ,
                                         unsigned char *md ) 
{ 
  SHA1_CTX context ;
  unsigned char k_ipad[65] ;
  unsigned char k_opad[65] ;
  unsigned char tk[20] ;
  int i ;
  SHA1_CTX tctx ;

  {
#line 269
  if ((unsigned long )md == (unsigned long )((void *)0)) {
#line 270
    md = m___2;
  }
#line 273
  if (key_len > 64UL) {
    {
#line 283
    SHA1Init(& tctx);
#line 284
    SHA1Update(& tctx, (unsigned char *)key, (unsigned int )key_len);
#line 285
    SHA1Final((unsigned char *)(tk), & tctx);
#line 288
    key = (unsigned char const   *)(tk);
#line 289
    key_len = (size_t )20;
    }
  }
  {
#line 303
  memset((void *)(k_ipad), '\000', sizeof(k_ipad));
#line 304
  memset((void *)(k_opad), '\000', sizeof(k_opad));
#line 305
  memcpy((void */* __restrict  */)(k_ipad), (void const   */* __restrict  */)key,
         key_len);
#line 306
  memcpy((void */* __restrict  */)(k_opad), (void const   */* __restrict  */)key,
         key_len);
#line 309
  i = 0;
  }
  {
#line 309
  while (1) {
    while_continue: /* CIL Label */ ;
#line 309
    if (! (i < 64)) {
#line 309
      goto while_break;
    }
#line 310
    k_ipad[i] = (unsigned char )((int )k_ipad[i] ^ 54);
#line 311
    k_opad[i] = (unsigned char )((int )k_opad[i] ^ 92);
#line 309
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 332
  SHA1Init(& context);
#line 333
  SHA1Update(& context, k_ipad, 64U);
#line 334
  SHA1Update(& context, (unsigned char *)text, (unsigned int )text_len);
#line 335
  SHA1Final((unsigned char *)md, & context);
#line 339
  SHA1Init(& context);
#line 340
  SHA1Update(& context, k_opad, 64U);
#line 341
  SHA1Update(& context, md, 20U);
#line 342
  SHA1Final((unsigned char *)md, & context);
  }
#line 345
  return (md);
}
}
#line 50 "/home/june/repo/benchmarks/collector/temp/ike-scan-1.9/psk-crack.c"
static char const   rcsid___5[49]  = 
#line 50 "/home/june/repo/benchmarks/collector/temp/ike-scan-1.9/psk-crack.c"
  {      (char const   )'$',      (char const   )'I',      (char const   )'d',      (char const   )':', 
        (char const   )' ',      (char const   )'p',      (char const   )'s',      (char const   )'k', 
        (char const   )'-',      (char const   )'c',      (char const   )'r',      (char const   )'a', 
        (char const   )'c',      (char const   )'k',      (char const   )'.',      (char const   )'c', 
        (char const   )' ',      (char const   )'9',      (char const   )'9',      (char const   )'1', 
        (char const   )'9',      (char const   )' ',      (char const   )'2',      (char const   )'0', 
        (char const   )'0',      (char const   )'7',      (char const   )'-',      (char const   )'0', 
        (char const   )'1',      (char const   )'-',      (char const   )'2',      (char const   )'2', 
        (char const   )' ',      (char const   )'2',      (char const   )'2',      (char const   )':', 
        (char const   )'5',      (char const   )'2',      (char const   )':',      (char const   )'3', 
        (char const   )'6',      (char const   )'Z',      (char const   )' ',      (char const   )'r', 
        (char const   )'s',      (char const   )'h',      (char const   )' ',      (char const   )'$', 
        (char const   )'\000'};
#line 52 "/home/june/repo/benchmarks/collector/temp/ike-scan-1.9/psk-crack.c"
static char const   *default_charset  =    "0123456789abcdefghijklmnopqrstuvwxyz";
#line 55 "/home/june/repo/benchmarks/collector/temp/ike-scan-1.9/psk-crack.c"
static psk_entry *psk_list  ;
#line 296 "/home/june/repo/benchmarks/collector/temp/ike-scan-1.9/psk-crack.c"
static int num_left___0  =    0;
#line 291 "/home/june/repo/benchmarks/collector/temp/ike-scan-1.9/psk-crack.c"
static unsigned int load_psk_params(char const   *filename , char const   *nortel_user ) 
{ 
  FILE *data_file ;
  char psk_data[4096] ;
  int n ;
  unsigned int count ;
  psk_entry *pe ;
  unsigned char *cp ;
  unsigned char *skeyid_data ;
  size_t skeyid_data_len ;
  unsigned char *hash_r_data ;
  size_t hash_r_data_len ;
  char g_xr_hex[4096] ;
  char g_xi_hex[4096] ;
  char cky_r_hex[4096] ;
  char cky_i_hex[4096] ;
  char sai_b_hex[4096] ;
  char idir_b_hex[4096] ;
  char ni_b_hex[4096] ;
  char nr_b_hex[4096] ;
  char hash_r_hex[4096] ;
  unsigned char *g_xr ;
  unsigned char *g_xi ;
  unsigned char *cky_r ;
  unsigned char *cky_i ;
  unsigned char *sai_b ;
  unsigned char *idir_b ;
  unsigned char *ni_b ;
  unsigned char *nr_b ;
  size_t g_xr_len ;
  size_t g_xi_len ;
  size_t cky_r_len ;
  size_t cky_i_len ;
  size_t sai_b_len ;
  size_t idir_b_len ;
  size_t ni_b_len ;
  size_t nr_b_len ;
  size_t hash_r_hex_len ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  size_t tmp___3 ;
  void *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;

  {
  {
#line 297
  count = 0U;
#line 333
  data_file = fopen((char const   */* __restrict  */)filename, (char const   */* __restrict  */)"r");
  }
#line 333
  if ((unsigned long )data_file == (unsigned long )((void *)0)) {
    {
#line 334
    err_sys("error opening data file %s", filename);
    }
  }
  {
#line 340
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 340
    tmp___7 = fgets((char */* __restrict  */)(psk_data), 4096, (FILE */* __restrict  */)data_file);
    }
#line 340
    if (! ((unsigned long )tmp___7 != (unsigned long )((void *)0))) {
#line 340
      goto while_break;
    }
#line 341
    if ((int )psk_data[0] == 35) {
#line 342
      goto while_continue;
    } else
#line 341
    if ((int )psk_data[0] == 10) {
#line 342
      goto while_continue;
    } else
#line 341
    if ((int )psk_data[0] == 13) {
#line 342
      goto while_continue;
    }
    {
#line 343
    n = sscanf((char const   */* __restrict  */)(psk_data), (char const   */* __restrict  */)"%[^:]:%[^:]:%[^:]:%[^:]:%[^:]:%[^:]:%[^:]:%[^:]:%[^:\r\n]",
               g_xr_hex, g_xi_hex, cky_r_hex, cky_i_hex, sai_b_hex, idir_b_hex, ni_b_hex,
               nr_b_hex, hash_r_hex);
    }
#line 347
    if (n != 9) {
      {
#line 348
      warn_msg("ERROR: Format error in PSK data file %s, line %u", filename, count + 1U);
#line 350
      err_msg("ERROR: Expected 9 colon-separated fields, found %d", n);
      }
    }
#line 356
    if (! num_left___0) {
#line 357
      if (psk_list) {
        {
#line 358
        tmp = Realloc((void *)psk_list, (unsigned long )count * sizeof(psk_entry ) + 10UL * sizeof(psk_entry ));
#line 358
        psk_list = (psk_entry *)tmp;
        }
      } else {
        {
#line 361
        tmp___0 = Malloc(10UL * sizeof(psk_entry ));
#line 361
        psk_list = (psk_entry *)tmp___0;
        }
      }
#line 362
      num_left___0 = 10;
    }
    {
#line 365
    pe = psk_list + count;
#line 366
    count ++;
#line 367
    num_left___0 --;
#line 372
    g_xr = hex2data((char const   *)(g_xr_hex), & g_xr_len);
#line 373
    g_xi = hex2data((char const   *)(g_xi_hex), & g_xi_len);
#line 374
    cky_r = hex2data((char const   *)(cky_r_hex), & cky_r_len);
#line 375
    cky_i = hex2data((char const   *)(cky_i_hex), & cky_i_len);
#line 376
    sai_b = hex2data((char const   *)(sai_b_hex), & sai_b_len);
#line 377
    idir_b = hex2data((char const   *)(idir_b_hex), & idir_b_len);
#line 378
    ni_b = hex2data((char const   *)(ni_b_hex), & ni_b_len);
#line 379
    nr_b = hex2data((char const   *)(nr_b_hex), & nr_b_len);
#line 382
    skeyid_data_len = ni_b_len + nr_b_len;
#line 383
    tmp___1 = Malloc(skeyid_data_len);
#line 383
    skeyid_data = (unsigned char *)tmp___1;
#line 384
    cp = skeyid_data;
#line 385
    memcpy((void */* __restrict  */)cp, (void const   */* __restrict  */)ni_b, ni_b_len);
#line 386
    cp += ni_b_len;
#line 387
    memcpy((void */* __restrict  */)cp, (void const   */* __restrict  */)nr_b, nr_b_len);
#line 388
    free((void *)ni_b);
#line 389
    free((void *)nr_b);
#line 392
    hash_r_data_len = ((((g_xr_len + g_xi_len) + cky_r_len) + cky_i_len) + sai_b_len) + idir_b_len;
#line 394
    tmp___2 = Malloc(hash_r_data_len);
#line 394
    hash_r_data = (unsigned char *)tmp___2;
#line 395
    cp = hash_r_data;
#line 396
    memcpy((void */* __restrict  */)cp, (void const   */* __restrict  */)g_xr, g_xr_len);
#line 397
    cp += g_xr_len;
#line 398
    memcpy((void */* __restrict  */)cp, (void const   */* __restrict  */)g_xi, g_xi_len);
#line 399
    cp += g_xi_len;
#line 400
    memcpy((void */* __restrict  */)cp, (void const   */* __restrict  */)cky_r, cky_r_len);
#line 401
    cp += cky_r_len;
#line 402
    memcpy((void */* __restrict  */)cp, (void const   */* __restrict  */)cky_i, cky_i_len);
#line 403
    cp += cky_i_len;
#line 404
    memcpy((void */* __restrict  */)cp, (void const   */* __restrict  */)sai_b, sai_b_len);
#line 405
    cp += sai_b_len;
#line 406
    memcpy((void */* __restrict  */)cp, (void const   */* __restrict  */)idir_b, idir_b_len);
#line 407
    free((void *)g_xr);
#line 408
    free((void *)g_xi);
#line 409
    free((void *)cky_r);
#line 410
    free((void *)cky_i);
#line 411
    free((void *)sai_b);
#line 412
    free((void *)idir_b);
#line 416
    pe->skeyid_data = skeyid_data;
#line 417
    pe->skeyid_data_len = skeyid_data_len;
#line 418
    pe->hash_r_data = hash_r_data;
#line 419
    pe->hash_r_data_len = hash_r_data_len;
#line 420
    pe->hash_r = hex2data((char const   *)(hash_r_hex), & pe->hash_r_len);
#line 421
    tmp___3 = strlen((char const   *)(hash_r_hex));
#line 421
    hash_r_hex_len = tmp___3 + 1UL;
#line 422
    tmp___4 = Malloc(hash_r_hex_len);
#line 422
    pe->hash_r_hex = (char *)tmp___4;
#line 423
    strncpy((char */* __restrict  */)pe->hash_r_hex, (char const   */* __restrict  */)(hash_r_hex),
            hash_r_hex_len);
#line 424
    pe->nortel_user = nortel_user;
    }
#line 429
    if (pe->hash_r_len == 16UL) {
      {
#line 430
      pe->hash_type = 1;
#line 431
      tmp___5 = make_message("MD5");
#line 431
      pe->hash_name = (char const   *)tmp___5;
      }
    } else
#line 432
    if (pe->hash_r_len == 20UL) {
      {
#line 433
      pe->hash_type = 2;
#line 434
      tmp___6 = make_message("SHA1");
#line 434
      pe->hash_name = (char const   *)tmp___6;
      }
    } else {
      {
#line 436
      err_msg("Cannot determine hash type from %u byte HASH_R", pe->hash_r_len);
      }
    }
#line 439
    pe->live = 1;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 445
  fclose(data_file);
  }
#line 446
  return (count);
}
}
#line 478 "/home/june/repo/benchmarks/collector/temp/ike-scan-1.9/psk-crack.c"
static unsigned char hash_r[20]  ;
#line 474 "/home/june/repo/benchmarks/collector/temp/ike-scan-1.9/psk-crack.c"
__inline static unsigned char *compute_hash(psk_entry const   *psk_params , char const   *password ) 
{ 
  size_t password_len ;
  size_t tmp ;
  unsigned char skeyid[20] ;
  unsigned char nortel_psk[20] ;
  unsigned char nortel_pwd_hash[20] ;
  size_t tmp___0 ;

  {
  {
#line 476
  tmp = strlen(password);
#line 476
  password_len = tmp;
  }
#line 482
  if ((unsigned long )psk_params->nortel_user == (unsigned long )((void *)0)) {
#line 483
    if (psk_params->hash_type == 1) {
      {
#line 484
      hmac_md5((unsigned char const   *)psk_params->skeyid_data, (size_t )psk_params->skeyid_data_len,
               (unsigned char const   *)password, password_len, skeyid);
      }
    } else {
      {
#line 487
      hmac_sha1((unsigned char const   *)psk_params->skeyid_data, (size_t )psk_params->skeyid_data_len,
                (unsigned char const   *)password, password_len, skeyid);
      }
    }
  } else {
    {
#line 494
    SHA1((unsigned char const   *)password, password_len, nortel_pwd_hash);
#line 495
    tmp___0 = strlen((char const   *)psk_params->nortel_user);
#line 495
    hmac_sha1((unsigned char const   *)psk_params->nortel_user, tmp___0, (unsigned char const   *)(nortel_pwd_hash),
              (size_t )20, nortel_psk);
    }
#line 498
    if (psk_params->hash_type == 1) {
      {
#line 499
      hmac_md5((unsigned char const   *)psk_params->skeyid_data, (size_t )psk_params->skeyid_data_len,
               (unsigned char const   *)(nortel_psk), (size_t )20, skeyid);
      }
    } else {
      {
#line 502
      hmac_sha1((unsigned char const   *)psk_params->skeyid_data, (size_t )psk_params->skeyid_data_len,
                (unsigned char const   *)(nortel_psk), (size_t )20, skeyid);
      }
    }
  }
#line 509
  if (psk_params->hash_type == 1) {
    {
#line 510
    hmac_md5((unsigned char const   *)psk_params->hash_r_data, (size_t )psk_params->hash_r_data_len,
             (unsigned char const   *)(skeyid), (size_t )psk_params->hash_r_len, hash_r);
    }
  } else {
    {
#line 513
    hmac_sha1((unsigned char const   *)psk_params->hash_r_data, (size_t )psk_params->hash_r_data_len,
              (unsigned char const   *)(skeyid), (size_t )psk_params->hash_r_len,
              hash_r);
    }
  }
#line 516
  return (hash_r);
}
}
#line 530 "/home/june/repo/benchmarks/collector/temp/ike-scan-1.9/psk-crack.c"
static FILE *open_dict_file(char const   *dict_file_name ) 
{ 
  char *fn ;
  FILE *fp ;
  int tmp ;

  {
#line 540
  if ((int const   )*(dict_file_name + 0) == 0) {
    {
#line 553
    fn = make_message("%s/%s", "/usr/local/share/ike-scan", "psk-crack-dictionary");
    }
  } else {
    {
#line 556
    fn = make_message("%s", dict_file_name);
    }
  }
  {
#line 559
  tmp = strcmp((char const   *)fn, "-");
  }
#line 559
  if (tmp == 0) {
#line 560
    fp = stdin;
  } else {
    {
#line 562
    fp = fopen((char const   */* __restrict  */)fn, (char const   */* __restrict  */)"r");
    }
#line 562
    if ((unsigned long )fp == (unsigned long )((void *)0)) {
      {
#line 563
      err_sys("error opening dictionary file %s", fn);
      }
    }
  }
  {
#line 566
  free((void *)fn);
  }
#line 568
  return (fp);
}
}
#line 582 "/home/june/repo/benchmarks/collector/temp/ike-scan-1.9/psk-crack.c"
static void psk_crack_usage(int status ) 
{ 


  {
  {
#line 584
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Usage: psk-crack [options] <psk-parameters-file>\n");
#line 585
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
#line 586
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"<psk-parameters-file> is a file containing the parameters for the pre-shared\n");
#line 587
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"key cracking process in the format generated by ike-scan with the --pskcrack\n");
#line 588
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"(-P) option.  This file can contain one or more entries.  For multiple entries,\n");
#line 589
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"each one must be on a separate line.\n");
#line 590
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
#line 591
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Two SKEYID computation methods are supported: the standard method for pre-\n");
#line 592
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"shared keys as described in RFC 2409, and the proprietary method used by\n");
#line 593
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Nortel Contivity / VPN Router systems.  The standard method is used by default,\n");
#line 594
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"and the Nortel method can be selected with the --norteluser option.\n");
#line 595
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
#line 596
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"The program can crack either MD5 or SHA1-based hashes.  The type of hash is\n");
#line 597
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"automatically determined from the length of the hash (16 bytes for MD5 or\n");
#line 598
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"20 bytes for SHA1).  Each entry in the <psk-parameters-file> is handled\n");
#line 599
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"separately, so it is possible to crack a mixture of MD5 and SHA1 hashes.\n");
#line 600
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
#line 601
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"By default, psk-crack will perform dictionary cracking using the default\n");
#line 602
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"dictionary.  The dictionary can be changed with the --dictionary (-d) option,\n");
#line 603
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"or brute-force cracking can be selected with the --bruteforce (-B) option.\n");
#line 604
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
#line 605
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Options:\n");
#line 606
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n--help or -h\t\tDisplay this usage message and exit.\n");
#line 607
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n--version or -V\t\tDisplay program version and exit.\n");
#line 608
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n--verbose or -v\t\tDisplay verbose progress messages.\n");
#line 609
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t\t\tUse more than once for increased verbosity.\n");
#line 610
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n--dictionary=<f> or -d <f> Set dictionary file to <f>\n");
#line 614
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t\t\tdefault=%s/%s.\n",
          "/usr/local/share/ike-scan", "psk-crack-dictionary");
#line 616
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t\t\tUse \"-\" for standard input.\n");
#line 617
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n--norteluser=<u> or -u <u> Specify username for Nortel Contivity PSK cracking.\n");
#line 618
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t\t\tThis option is required when cracking pre-shared keys\n");
#line 619
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t\t\ton Nortel Contivity / VPN Router systems.  These\n");
#line 620
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t\t\tsystems use a proprietary method to calculate the hash\n");
#line 621
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t\t\tthat includes a hash of the username.\n");
#line 622
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t\t\tThis option is only needed when cracking Nortel format\n");
#line 623
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t\t\thashes, and should not be used for standard format\n");
#line 624
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t\t\thashes.\n");
#line 625
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t\t\tWhen this option is used, all the PSK entries in the\n");
#line 626
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t\t\tpsk parameters file are assumed to be in Nortel format\n");
#line 627
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t\t\tusing the supplied username. There is currently no way\n");
#line 628
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t\t\tto crack a mixture of Nortel and standard format PSK\n");
#line 629
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t\t\tentries, or Nortel entries with different usernames in\n");
#line 630
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t\t\ta single psk-crack run.\n");
#line 631
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n--bruteforce=<n> or -B <n> Select bruteforce cracking up to <n> characters.\n");
#line 632
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n--charset=<s> or -c <s>\tSet bruteforce character set to <s>\n");
#line 633
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t\t\tDefault is \"%s\"\n",
          default_charset);
#line 634
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
#line 635
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Report bugs or send suggestions to %s\n",
          "ike-scan@nta-monitor.com");
#line 636
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"See the ike-scan homepage at http://www.nta-monitor.com/tools/ike-scan/\n");
#line 637
  exit(status);
  }
}
}
#line 47 "/home/june/repo/benchmarks/collector/temp/ike-scan-1.9/error.c"
static char rcsid___6[45]  = 
#line 47 "/home/june/repo/benchmarks/collector/temp/ike-scan-1.9/error.c"
  {      (char )'$',      (char )'I',      (char )'d',      (char )':', 
        (char )' ',      (char )'e',      (char )'r',      (char )'r', 
        (char )'o',      (char )'r',      (char )'.',      (char )'c', 
        (char )' ',      (char )'9',      (char )'8',      (char )'8', 
        (char )'4',      (char )' ',      (char )'2',      (char )'0', 
        (char )'0',      (char )'7',      (char )'-',      (char )'0', 
        (char )'1',      (char )'-',      (char )'1',      (char )'4', 
        (char )' ',      (char )'1',      (char )'9',      (char )':', 
        (char )'0',      (char )'5',      (char )':',      (char )'3', 
        (char )'9',      (char )'Z',      (char )' ',      (char )'r', 
        (char )'s',      (char )'h',      (char )' ',      (char )'$', 
        (char )'\000'};
#line 49 "/home/june/repo/benchmarks/collector/temp/ike-scan-1.9/utils.c"
static char rcsid___7[45]  = 
#line 49 "/home/june/repo/benchmarks/collector/temp/ike-scan-1.9/utils.c"
  {      (char )'$',      (char )'I',      (char )'d',      (char )':', 
        (char )' ',      (char )'u',      (char )'t',      (char )'i', 
        (char )'l',      (char )'s',      (char )'.',      (char )'c', 
        (char )' ',      (char )'9',      (char )'8',      (char )'8', 
        (char )'4',      (char )' ',      (char )'2',      (char )'0', 
        (char )'0',      (char )'7',      (char )'-',      (char )'0', 
        (char )'1',      (char )'-',      (char )'1',      (char )'4', 
        (char )' ',      (char )'1',      (char )'9',      (char )':', 
        (char )'0',      (char )'5',      (char )':',      (char )'3', 
        (char )'9',      (char )'Z',      (char )' ',      (char )'r', 
        (char )'s',      (char )'h',      (char )' ',      (char )'$', 
        (char )'\000'};
#line 340 "/home/june/repo/benchmarks/collector/temp/ike-scan-1.9/utils.c"
static char buf___0[21]  ;
#line 526 "/home/june/repo/benchmarks/collector/temp/ike-scan-1.9/utils.c"
static struct timeval time_first___0  ;
#line 527 "/home/june/repo/benchmarks/collector/temp/ike-scan-1.9/utils.c"
static struct timeval time_last___0  ;
#line 528 "/home/june/repo/benchmarks/collector/temp/ike-scan-1.9/utils.c"
static int first_call___3  =    1;
#line 703 "/home/june/repo/benchmarks/collector/temp/ike-scan-1.9/utils.c"
static union __anonunion_random_data_76___0 random_data___0  ;
#line 707 "/home/june/repo/benchmarks/collector/temp/ike-scan-1.9/utils.c"
static int num_bytes___0  =    0;
#line 53 "/home/june/repo/benchmarks/collector/temp/ike-scan-1.9/mt19937ar.c"
static unsigned long mt___0[624]  ;
#line 54 "/home/june/repo/benchmarks/collector/temp/ike-scan-1.9/mt19937ar.c"
static int mti___0  =    625;
#line 105 "/home/june/repo/benchmarks/collector/temp/ike-scan-1.9/mt19937ar.c"
static unsigned long mag01___0[2]  = {      0UL,      2567483615UL};
#line 131 "/home/june/repo/benchmarks/collector/temp/ike-scan-1.9/md5.c"
static void md5_process___0(md5_state_t *pms , md5_byte_t const   *data ) 
{ 
  md5_word_t a ;
  md5_word_t b ;
  md5_word_t c ;
  md5_word_t d ;
  md5_word_t t ;
  md5_word_t xbuf[16] ;
  md5_word_t const   *X ;

  {
#line 134
  a = pms->abcd[0];
#line 134
  b = pms->abcd[1];
#line 134
  c = pms->abcd[2];
#line 134
  d = pms->abcd[3];
#line 164
  if (! ((data - (md5_byte_t const   *)0) & 3L)) {
#line 166
    X = (md5_word_t const   *)data;
  } else {
    {
#line 169
    memcpy((void */* __restrict  */)(xbuf), (void const   */* __restrict  */)data,
           (size_t )64);
#line 170
    X = (md5_word_t const   *)(xbuf);
    }
  }
#line 207
  t = ((a + ((b & c) | (~ b & d))) + (md5_word_t )*(X + 0)) + 3614090360U;
#line 207
  a = ((t << 7) | (t >> 25)) + b;
#line 208
  t = ((d + ((a & b) | (~ a & c))) + (md5_word_t )*(X + 1)) + 3905402710U;
#line 208
  d = ((t << 12) | (t >> 20)) + a;
#line 209
  t = ((c + ((d & a) | (~ d & b))) + (md5_word_t )*(X + 2)) + 606105819U;
#line 209
  c = ((t << 17) | (t >> 15)) + d;
#line 210
  t = ((b + ((c & d) | (~ c & a))) + (md5_word_t )*(X + 3)) + 3250441966U;
#line 210
  b = ((t << 22) | (t >> 10)) + c;
#line 211
  t = ((a + ((b & c) | (~ b & d))) + (md5_word_t )*(X + 4)) + 4118548399U;
#line 211
  a = ((t << 7) | (t >> 25)) + b;
#line 212
  t = ((d + ((a & b) | (~ a & c))) + (md5_word_t )*(X + 5)) + 1200080426U;
#line 212
  d = ((t << 12) | (t >> 20)) + a;
#line 213
  t = ((c + ((d & a) | (~ d & b))) + (md5_word_t )*(X + 6)) + 2821735955U;
#line 213
  c = ((t << 17) | (t >> 15)) + d;
#line 214
  t = ((b + ((c & d) | (~ c & a))) + (md5_word_t )*(X + 7)) + 4249261313U;
#line 214
  b = ((t << 22) | (t >> 10)) + c;
#line 215
  t = ((a + ((b & c) | (~ b & d))) + (md5_word_t )*(X + 8)) + 1770035416U;
#line 215
  a = ((t << 7) | (t >> 25)) + b;
#line 216
  t = ((d + ((a & b) | (~ a & c))) + (md5_word_t )*(X + 9)) + 2336552879U;
#line 216
  d = ((t << 12) | (t >> 20)) + a;
#line 217
  t = ((c + ((d & a) | (~ d & b))) + (md5_word_t )*(X + 10)) + 4294925233U;
#line 217
  c = ((t << 17) | (t >> 15)) + d;
#line 218
  t = ((b + ((c & d) | (~ c & a))) + (md5_word_t )*(X + 11)) + 2304563134U;
#line 218
  b = ((t << 22) | (t >> 10)) + c;
#line 219
  t = ((a + ((b & c) | (~ b & d))) + (md5_word_t )*(X + 12)) + 1804603682U;
#line 219
  a = ((t << 7) | (t >> 25)) + b;
#line 220
  t = ((d + ((a & b) | (~ a & c))) + (md5_word_t )*(X + 13)) + 4254626195U;
#line 220
  d = ((t << 12) | (t >> 20)) + a;
#line 221
  t = ((c + ((d & a) | (~ d & b))) + (md5_word_t )*(X + 14)) + 2792965006U;
#line 221
  c = ((t << 17) | (t >> 15)) + d;
#line 222
  t = ((b + ((c & d) | (~ c & a))) + (md5_word_t )*(X + 15)) + 1236535329U;
#line 222
  b = ((t << 22) | (t >> 10)) + c;
#line 233
  t = ((a + ((b & d) | (c & ~ d))) + (md5_word_t )*(X + 1)) + 4129170786U;
#line 233
  a = ((t << 5) | (t >> 27)) + b;
#line 234
  t = ((d + ((a & c) | (b & ~ c))) + (md5_word_t )*(X + 6)) + 3225465664U;
#line 234
  d = ((t << 9) | (t >> 23)) + a;
#line 235
  t = ((c + ((d & b) | (a & ~ b))) + (md5_word_t )*(X + 11)) + 643717713U;
#line 235
  c = ((t << 14) | (t >> 18)) + d;
#line 236
  t = ((b + ((c & a) | (d & ~ a))) + (md5_word_t )*(X + 0)) + 3921069994U;
#line 236
  b = ((t << 20) | (t >> 12)) + c;
#line 237
  t = ((a + ((b & d) | (c & ~ d))) + (md5_word_t )*(X + 5)) + 3593408605U;
#line 237
  a = ((t << 5) | (t >> 27)) + b;
#line 238
  t = ((d + ((a & c) | (b & ~ c))) + (md5_word_t )*(X + 10)) + 38016083U;
#line 238
  d = ((t << 9) | (t >> 23)) + a;
#line 239
  t = ((c + ((d & b) | (a & ~ b))) + (md5_word_t )*(X + 15)) + 3634488961U;
#line 239
  c = ((t << 14) | (t >> 18)) + d;
#line 240
  t = ((b + ((c & a) | (d & ~ a))) + (md5_word_t )*(X + 4)) + 3889429448U;
#line 240
  b = ((t << 20) | (t >> 12)) + c;
#line 241
  t = ((a + ((b & d) | (c & ~ d))) + (md5_word_t )*(X + 9)) + 568446438U;
#line 241
  a = ((t << 5) | (t >> 27)) + b;
#line 242
  t = ((d + ((a & c) | (b & ~ c))) + (md5_word_t )*(X + 14)) + 3275163606U;
#line 242
  d = ((t << 9) | (t >> 23)) + a;
#line 243
  t = ((c + ((d & b) | (a & ~ b))) + (md5_word_t )*(X + 3)) + 4107603335U;
#line 243
  c = ((t << 14) | (t >> 18)) + d;
#line 244
  t = ((b + ((c & a) | (d & ~ a))) + (md5_word_t )*(X + 8)) + 1163531501U;
#line 244
  b = ((t << 20) | (t >> 12)) + c;
#line 245
  t = ((a + ((b & d) | (c & ~ d))) + (md5_word_t )*(X + 13)) + 2850285829U;
#line 245
  a = ((t << 5) | (t >> 27)) + b;
#line 246
  t = ((d + ((a & c) | (b & ~ c))) + (md5_word_t )*(X + 2)) + 4243563512U;
#line 246
  d = ((t << 9) | (t >> 23)) + a;
#line 247
  t = ((c + ((d & b) | (a & ~ b))) + (md5_word_t )*(X + 7)) + 1735328473U;
#line 247
  c = ((t << 14) | (t >> 18)) + d;
#line 248
  t = ((b + ((c & a) | (d & ~ a))) + (md5_word_t )*(X + 12)) + 2368359562U;
#line 248
  b = ((t << 20) | (t >> 12)) + c;
#line 259
  t = ((a + ((b ^ c) ^ d)) + (md5_word_t )*(X + 5)) + 4294588738U;
#line 259
  a = ((t << 4) | (t >> 28)) + b;
#line 260
  t = ((d + ((a ^ b) ^ c)) + (md5_word_t )*(X + 8)) + 2272392833U;
#line 260
  d = ((t << 11) | (t >> 21)) + a;
#line 261
  t = ((c + ((d ^ a) ^ b)) + (md5_word_t )*(X + 11)) + 1839030562U;
#line 261
  c = ((t << 16) | (t >> 16)) + d;
#line 262
  t = ((b + ((c ^ d) ^ a)) + (md5_word_t )*(X + 14)) + 4259657740U;
#line 262
  b = ((t << 23) | (t >> 9)) + c;
#line 263
  t = ((a + ((b ^ c) ^ d)) + (md5_word_t )*(X + 1)) + 2763975236U;
#line 263
  a = ((t << 4) | (t >> 28)) + b;
#line 264
  t = ((d + ((a ^ b) ^ c)) + (md5_word_t )*(X + 4)) + 1272893353U;
#line 264
  d = ((t << 11) | (t >> 21)) + a;
#line 265
  t = ((c + ((d ^ a) ^ b)) + (md5_word_t )*(X + 7)) + 4139469664U;
#line 265
  c = ((t << 16) | (t >> 16)) + d;
#line 266
  t = ((b + ((c ^ d) ^ a)) + (md5_word_t )*(X + 10)) + 3200236656U;
#line 266
  b = ((t << 23) | (t >> 9)) + c;
#line 267
  t = ((a + ((b ^ c) ^ d)) + (md5_word_t )*(X + 13)) + 681279174U;
#line 267
  a = ((t << 4) | (t >> 28)) + b;
#line 268
  t = ((d + ((a ^ b) ^ c)) + (md5_word_t )*(X + 0)) + 3936430074U;
#line 268
  d = ((t << 11) | (t >> 21)) + a;
#line 269
  t = ((c + ((d ^ a) ^ b)) + (md5_word_t )*(X + 3)) + 3572445317U;
#line 269
  c = ((t << 16) | (t >> 16)) + d;
#line 270
  t = ((b + ((c ^ d) ^ a)) + (md5_word_t )*(X + 6)) + 76029189U;
#line 270
  b = ((t << 23) | (t >> 9)) + c;
#line 271
  t = ((a + ((b ^ c) ^ d)) + (md5_word_t )*(X + 9)) + 3654602809U;
#line 271
  a = ((t << 4) | (t >> 28)) + b;
#line 272
  t = ((d + ((a ^ b) ^ c)) + (md5_word_t )*(X + 12)) + 3873151461U;
#line 272
  d = ((t << 11) | (t >> 21)) + a;
#line 273
  t = ((c + ((d ^ a) ^ b)) + (md5_word_t )*(X + 15)) + 530742520U;
#line 273
  c = ((t << 16) | (t >> 16)) + d;
#line 274
  t = ((b + ((c ^ d) ^ a)) + (md5_word_t )*(X + 2)) + 3299628645U;
#line 274
  b = ((t << 23) | (t >> 9)) + c;
#line 285
  t = ((a + (c ^ (b | ~ d))) + (md5_word_t )*(X + 0)) + 4096336452U;
#line 285
  a = ((t << 6) | (t >> 26)) + b;
#line 286
  t = ((d + (b ^ (a | ~ c))) + (md5_word_t )*(X + 7)) + 1126891415U;
#line 286
  d = ((t << 10) | (t >> 22)) + a;
#line 287
  t = ((c + (a ^ (d | ~ b))) + (md5_word_t )*(X + 14)) + 2878612391U;
#line 287
  c = ((t << 15) | (t >> 17)) + d;
#line 288
  t = ((b + (d ^ (c | ~ a))) + (md5_word_t )*(X + 5)) + 4237533241U;
#line 288
  b = ((t << 21) | (t >> 11)) + c;
#line 289
  t = ((a + (c ^ (b | ~ d))) + (md5_word_t )*(X + 12)) + 1700485571U;
#line 289
  a = ((t << 6) | (t >> 26)) + b;
#line 290
  t = ((d + (b ^ (a | ~ c))) + (md5_word_t )*(X + 3)) + 2399980690U;
#line 290
  d = ((t << 10) | (t >> 22)) + a;
#line 291
  t = ((c + (a ^ (d | ~ b))) + (md5_word_t )*(X + 10)) + 4293915773U;
#line 291
  c = ((t << 15) | (t >> 17)) + d;
#line 292
  t = ((b + (d ^ (c | ~ a))) + (md5_word_t )*(X + 1)) + 2240044497U;
#line 292
  b = ((t << 21) | (t >> 11)) + c;
#line 293
  t = ((a + (c ^ (b | ~ d))) + (md5_word_t )*(X + 8)) + 1873313359U;
#line 293
  a = ((t << 6) | (t >> 26)) + b;
#line 294
  t = ((d + (b ^ (a | ~ c))) + (md5_word_t )*(X + 15)) + 4264355552U;
#line 294
  d = ((t << 10) | (t >> 22)) + a;
#line 295
  t = ((c + (a ^ (d | ~ b))) + (md5_word_t )*(X + 6)) + 2734768916U;
#line 295
  c = ((t << 15) | (t >> 17)) + d;
#line 296
  t = ((b + (d ^ (c | ~ a))) + (md5_word_t )*(X + 13)) + 1309151649U;
#line 296
  b = ((t << 21) | (t >> 11)) + c;
#line 297
  t = ((a + (c ^ (b | ~ d))) + (md5_word_t )*(X + 4)) + 4149444226U;
#line 297
  a = ((t << 6) | (t >> 26)) + b;
#line 298
  t = ((d + (b ^ (a | ~ c))) + (md5_word_t )*(X + 11)) + 3174756917U;
#line 298
  d = ((t << 10) | (t >> 22)) + a;
#line 299
  t = ((c + (a ^ (d | ~ b))) + (md5_word_t )*(X + 2)) + 718787259U;
#line 299
  c = ((t << 15) | (t >> 17)) + d;
#line 300
  t = ((b + (d ^ (c | ~ a))) + (md5_word_t )*(X + 9)) + 3951481745U;
#line 300
  b = ((t << 21) | (t >> 11)) + c;
#line 306
  pms->abcd[0] += a;
#line 307
  pms->abcd[1] += b;
#line 308
  pms->abcd[2] += c;
#line 309
  pms->abcd[3] += d;
#line 310
  return;
}
}
#line 363 "/home/june/repo/benchmarks/collector/temp/ike-scan-1.9/md5.c"
static md5_byte_t const   pad___0[64]  = 
#line 363
  {      (md5_byte_t const   )128,      (md5_byte_t const   )0,      (md5_byte_t const   )0,      (md5_byte_t const   )0, 
        (md5_byte_t const   )0,      (md5_byte_t const   )0,      (md5_byte_t const   )0,      (md5_byte_t const   )0, 
        (md5_byte_t const   )0,      (md5_byte_t const   )0,      (md5_byte_t const   )0,      (md5_byte_t const   )0, 
        (md5_byte_t const   )0,      (md5_byte_t const   )0,      (md5_byte_t const   )0,      (md5_byte_t const   )0, 
        (md5_byte_t const   )0,      (md5_byte_t const   )0,      (md5_byte_t const   )0,      (md5_byte_t const   )0, 
        (md5_byte_t const   )0,      (md5_byte_t const   )0,      (md5_byte_t const   )0,      (md5_byte_t const   )0, 
        (md5_byte_t const   )0,      (md5_byte_t const   )0,      (md5_byte_t const   )0,      (md5_byte_t const   )0, 
        (md5_byte_t const   )0,      (md5_byte_t const   )0,      (md5_byte_t const   )0,      (md5_byte_t const   )0, 
        (md5_byte_t const   )0,      (md5_byte_t const   )0,      (md5_byte_t const   )0,      (md5_byte_t const   )0, 
        (md5_byte_t const   )0,      (md5_byte_t const   )0,      (md5_byte_t const   )0,      (md5_byte_t const   )0, 
        (md5_byte_t const   )0,      (md5_byte_t const   )0,      (md5_byte_t const   )0,      (md5_byte_t const   )0, 
        (md5_byte_t const   )0,      (md5_byte_t const   )0,      (md5_byte_t const   )0,      (md5_byte_t const   )0, 
        (md5_byte_t const   )0,      (md5_byte_t const   )0,      (md5_byte_t const   )0,      (md5_byte_t const   )0, 
        (md5_byte_t const   )0,      (md5_byte_t const   )0,      (md5_byte_t const   )0,      (md5_byte_t const   )0, 
        (md5_byte_t const   )0,      (md5_byte_t const   )0,      (md5_byte_t const   )0,      (md5_byte_t const   )0, 
        (md5_byte_t const   )0,      (md5_byte_t const   )0,      (md5_byte_t const   )0,      (md5_byte_t const   )0};
