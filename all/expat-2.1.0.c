/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 108 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/expat_external.h"
typedef unsigned long XML_Size;
#line 112 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmltok.h"
struct position {
   XML_Size lineNumber ;
   XML_Size columnNumber ;
};
#line 112 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmltok.h"
typedef struct position POSITION;
#line 118 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmltok.h"
struct __anonstruct_ATTRIBUTE_1 {
   char const   *name ;
   char const   *valuePtr ;
   char const   *valueEnd ;
   char normalized ;
};
#line 118 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmltok.h"
typedef struct __anonstruct_ATTRIBUTE_1 ATTRIBUTE;
#line 125
struct encoding;
#line 126 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmltok.h"
typedef struct encoding ENCODING;
#line 128 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmltok.h"
typedef int (*SCANNER)(ENCODING const   * , char const   * , char const   * , char const   ** );
#line 133 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmltok.h"
struct encoding {
   SCANNER scanners[4] ;
   SCANNER literalScanners[2] ;
   int (*sameName)(ENCODING const   * , char const   * , char const   * ) ;
   int (*nameMatchesAscii)(ENCODING const   * , char const   * , char const   * ,
                           char const   * ) ;
   int (*nameLength)(ENCODING const   * , char const   * ) ;
   char const   *(*skipS)(ENCODING const   * , char const   * ) ;
   int (*getAtts)(ENCODING const   *enc , char const   *ptr , int attsMax , ATTRIBUTE *atts ) ;
   int (*charRefNumber)(ENCODING const   *enc , char const   *ptr ) ;
   int (*predefinedEntityName)(ENCODING const   * , char const   * , char const   * ) ;
   void (*updatePosition)(ENCODING const   * , char const   *ptr , char const   *end ,
                          POSITION * ) ;
   int (*isPublicId)(ENCODING const   *enc , char const   *ptr , char const   *end ,
                     char const   **badPtr ) ;
   void (*utf8Convert)(ENCODING const   *enc , char const   **fromP , char const   *fromLim ,
                       char **toP , char const   *toLim ) ;
   void (*utf16Convert)(ENCODING const   *enc , char const   **fromP , char const   *fromLim ,
                        unsigned short **toP , unsigned short const   *toLim ) ;
   int minBytesPerChar ;
   char isUtf8 ;
   char isUtf16 ;
};
#line 261 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmltok.h"
struct __anonstruct_INIT_ENCODING_2 {
   ENCODING initEnc ;
   ENCODING const   **encPtr ;
};
#line 261 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmltok.h"
typedef struct __anonstruct_INIT_ENCODING_2 INIT_ENCODING;
#line 176 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmltok.c"
struct normal_encoding {
   ENCODING enc ;
   unsigned char type[256] ;
   int (*isName2)(ENCODING const   * , char const   * ) ;
   int (*isName3)(ENCODING const   * , char const   * ) ;
   int (*isName4)(ENCODING const   * , char const   * ) ;
   int (*isNmstrt2)(ENCODING const   * , char const   * ) ;
   int (*isNmstrt3)(ENCODING const   * , char const   * ) ;
   int (*isNmstrt4)(ENCODING const   * , char const   * ) ;
   int (*isInvalid2)(ENCODING const   * , char const   * ) ;
   int (*isInvalid3)(ENCODING const   * , char const   * ) ;
   int (*isInvalid4)(ENCODING const   * , char const   * ) ;
};
#line 1434 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmltok_impl.c"
enum __anonenum_state_4 {
    other = 0,
    inName = 1,
    inValue = 2
} ;
#line 1434
enum __anonenum_state_6 {
    other___0 = 0,
    inName___0 = 1,
    inValue___0 = 2
} ;
#line 1434
enum __anonenum_state_7 {
    other___1 = 0,
    inName___1 = 1,
    inValue___1 = 2
} ;
#line 1247 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmltok.c"
struct unknown_encoding {
   struct normal_encoding normal ;
   int (*convert)(void *userData , char const   *p ) ;
   void *userData ;
   unsigned short utf16[256] ;
   char utf8[256][4] ;
};
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 315 "/usr/include/libio.h"
typedef struct _IO_FILE _IO_FILE;
#line 94 "./lib/expat_external.h"
typedef char XML_Char;
#line 95 "./lib/expat_external.h"
typedef char XML_LChar;
#line 107 "./lib/expat_external.h"
typedef long XML_Index;
#line 24 "./lib/expat.h"
struct XML_ParserStruct;
#line 25 "./lib/expat.h"
typedef struct XML_ParserStruct *XML_Parser;
#line 506 "./lib/expat.h"
struct __anonstruct_XML_Encoding_26 {
   int map[256] ;
   void *data ;
   int (*convert)(void *data , char const   *s ) ;
   void (*release)(void *data ) ;
};
#line 506 "./lib/expat.h"
typedef struct __anonstruct_XML_Encoding_26 XML_Encoding;
#line 876
enum XML_ParamEntityParsing {
    XML_PARAM_ENTITY_PARSING_NEVER = 0,
    XML_PARAM_ENTITY_PARSING_UNLESS_STANDALONE = 1,
    XML_PARAM_ENTITY_PARSING_ALWAYS = 2
} ;
#line 1009
enum XML_FeatureEnum {
    XML_FEATURE_END = 0,
    XML_FEATURE_UNICODE = 1,
    XML_FEATURE_UNICODE_WCHAR_T = 2,
    XML_FEATURE_DTD = 3,
    XML_FEATURE_CONTEXT_BYTES = 4,
    XML_FEATURE_MIN_SIZE = 5,
    XML_FEATURE_SIZEOF_XML_CHAR = 6,
    XML_FEATURE_SIZEOF_XML_LCHAR = 7,
    XML_FEATURE_NS = 8,
    XML_FEATURE_LARGE_SIZE = 9,
    XML_FEATURE_ATTR_INFO = 10
} ;
#line 1024 "./lib/expat.h"
struct __anonstruct_XML_Feature_29 {
   enum XML_FeatureEnum feature ;
   XML_LChar const   *name ;
   long value ;
};
#line 1024 "./lib/expat.h"
typedef struct __anonstruct_XML_Feature_29 XML_Feature;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 75 "/usr/include/time.h"
typedef __time_t time_t;
#line 28 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/expat.h"
typedef unsigned char XML_Bool;
#line 45
enum XML_Status {
    XML_STATUS_ERROR = 0,
    XML_STATUS_OK = 1,
    XML_STATUS_SUSPENDED = 2
} ;
#line 54
enum XML_Error {
    XML_ERROR_NONE = 0,
    XML_ERROR_NO_MEMORY = 1,
    XML_ERROR_SYNTAX = 2,
    XML_ERROR_NO_ELEMENTS = 3,
    XML_ERROR_INVALID_TOKEN = 4,
    XML_ERROR_UNCLOSED_TOKEN = 5,
    XML_ERROR_PARTIAL_CHAR = 6,
    XML_ERROR_TAG_MISMATCH = 7,
    XML_ERROR_DUPLICATE_ATTRIBUTE = 8,
    XML_ERROR_JUNK_AFTER_DOC_ELEMENT = 9,
    XML_ERROR_PARAM_ENTITY_REF = 10,
    XML_ERROR_UNDEFINED_ENTITY = 11,
    XML_ERROR_RECURSIVE_ENTITY_REF = 12,
    XML_ERROR_ASYNC_ENTITY = 13,
    XML_ERROR_BAD_CHAR_REF = 14,
    XML_ERROR_BINARY_ENTITY_REF = 15,
    XML_ERROR_ATTRIBUTE_EXTERNAL_ENTITY_REF = 16,
    XML_ERROR_MISPLACED_XML_PI = 17,
    XML_ERROR_UNKNOWN_ENCODING = 18,
    XML_ERROR_INCORRECT_ENCODING = 19,
    XML_ERROR_UNCLOSED_CDATA_SECTION = 20,
    XML_ERROR_EXTERNAL_ENTITY_HANDLING = 21,
    XML_ERROR_NOT_STANDALONE = 22,
    XML_ERROR_UNEXPECTED_STATE = 23,
    XML_ERROR_ENTITY_DECLARED_IN_PE = 24,
    XML_ERROR_FEATURE_REQUIRES_XML_DTD = 25,
    XML_ERROR_CANT_CHANGE_FEATURE_ONCE_PARSING = 26,
    XML_ERROR_UNBOUND_PREFIX = 27,
    XML_ERROR_UNDECLARING_PREFIX = 28,
    XML_ERROR_INCOMPLETE_PE = 29,
    XML_ERROR_XML_DECL = 30,
    XML_ERROR_TEXT_DECL = 31,
    XML_ERROR_PUBLICID = 32,
    XML_ERROR_SUSPENDED = 33,
    XML_ERROR_NOT_SUSPENDED = 34,
    XML_ERROR_ABORTED = 35,
    XML_ERROR_FINISHED = 36,
    XML_ERROR_SUSPEND_PE = 37,
    XML_ERROR_RESERVED_PREFIX_XML = 38,
    XML_ERROR_RESERVED_PREFIX_XMLNS = 39,
    XML_ERROR_RESERVED_NAMESPACE_URI = 40
} ;
#line 101
enum XML_Content_Type {
    XML_CTYPE_EMPTY = 1,
    XML_CTYPE_ANY = 2,
    XML_CTYPE_MIXED = 3,
    XML_CTYPE_NAME = 4,
    XML_CTYPE_CHOICE = 5,
    XML_CTYPE_SEQ = 6
} ;
#line 110
enum XML_Content_Quant {
    XML_CQUANT_NONE = 0,
    XML_CQUANT_OPT = 1,
    XML_CQUANT_REP = 2,
    XML_CQUANT_PLUS = 3
} ;
#line 135
struct XML_cp;
#line 135 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/expat.h"
typedef struct XML_cp XML_Content;
#line 137 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/expat.h"
struct XML_cp {
   enum XML_Content_Type type ;
   enum XML_Content_Quant quant ;
   XML_Char *name ;
   unsigned int numchildren ;
   XML_Content *children ;
};
#line 196 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/expat.h"
struct __anonstruct_XML_Memory_Handling_Suite_21 {
   void *(*malloc_fcn)(size_t size ) ;
   void *(*realloc_fcn)(void *ptr , size_t size ) ;
   void (*free_fcn)(void *ptr ) ;
};
#line 196 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/expat.h"
typedef struct __anonstruct_XML_Memory_Handling_Suite_21 XML_Memory_Handling_Suite;
#line 835
enum XML_Parsing {
    XML_INITIALIZED = 0,
    XML_PARSING = 1,
    XML_FINISHED = 2,
    XML_SUSPENDED = 3
} ;
#line 842 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/expat.h"
struct __anonstruct_XML_ParsingStatus_23 {
   enum XML_Parsing parsing ;
   XML_Bool finalBuffer ;
};
#line 842 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/expat.h"
typedef struct __anonstruct_XML_ParsingStatus_23 XML_ParsingStatus;
#line 996 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/expat.h"
struct __anonstruct_XML_Expat_Version_24 {
   int major ;
   int minor ;
   int micro ;
};
#line 996 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/expat.h"
typedef struct __anonstruct_XML_Expat_Version_24 XML_Expat_Version;
#line 44 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlparse.c"
typedef char ICHAR;
#line 87 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlrole.h"
struct prolog_state {
   int (*handler)(struct prolog_state *state , int tok , char const   *ptr , char const   *end ,
                  ENCODING const   *enc ) ;
   unsigned int level ;
   int role_none ;
   unsigned int includeLevel ;
   int documentEntity ;
   int inEntityValue ;
};
#line 87 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlrole.h"
typedef struct prolog_state PROLOG_STATE;
#line 91 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlparse.c"
typedef XML_Char const   *KEY;
#line 93 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlparse.c"
struct __anonstruct_NAMED_29 {
   KEY name ;
};
#line 93 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlparse.c"
typedef struct __anonstruct_NAMED_29 NAMED;
#line 97 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlparse.c"
struct __anonstruct_HASH_TABLE_30 {
   NAMED **v ;
   unsigned char power ;
   size_t size ;
   size_t used ;
   XML_Memory_Handling_Suite const   *mem ;
};
#line 97 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlparse.c"
typedef struct __anonstruct_HASH_TABLE_30 HASH_TABLE;
#line 130 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlparse.c"
struct __anonstruct_HASH_TABLE_ITER_31 {
   NAMED **p ;
   NAMED **end ;
};
#line 130 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlparse.c"
typedef struct __anonstruct_HASH_TABLE_ITER_31 HASH_TABLE_ITER;
#line 144
struct prefix;
#line 144
struct attribute_id;
#line 144 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlparse.c"
struct binding {
   struct prefix *prefix ;
   struct binding *nextTagBinding ;
   struct binding *prevPrefixBinding ;
   struct attribute_id  const  *attId ;
   XML_Char *uri ;
   int uriLen ;
   int uriAlloc ;
};
#line 144 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlparse.c"
typedef struct binding BINDING;
#line 154 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlparse.c"
struct prefix {
   XML_Char const   *name ;
   BINDING *binding ;
};
#line 154 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlparse.c"
typedef struct prefix PREFIX;
#line 159 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlparse.c"
struct __anonstruct_TAG_NAME_32 {
   XML_Char const   *str ;
   XML_Char const   *localPart ;
   XML_Char const   *prefix ;
   int strLen ;
   int uriLen ;
   int prefixLen ;
};
#line 159 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlparse.c"
typedef struct __anonstruct_TAG_NAME_32 TAG_NAME;
#line 181 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlparse.c"
struct tag {
   struct tag *parent ;
   char const   *rawName ;
   int rawNameLength ;
   TAG_NAME name ;
   char *buf ;
   char *bufEnd ;
   BINDING *bindings ;
};
#line 181 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlparse.c"
typedef struct tag TAG;
#line 191 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlparse.c"
struct __anonstruct_ENTITY_33 {
   XML_Char const   *name ;
   XML_Char const   *textPtr ;
   int textLen ;
   int processed ;
   XML_Char const   *systemId ;
   XML_Char const   *base ;
   XML_Char const   *publicId ;
   XML_Char const   *notation ;
   XML_Bool open ;
   XML_Bool is_param ;
   XML_Bool is_internal ;
};
#line 191 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlparse.c"
typedef struct __anonstruct_ENTITY_33 ENTITY;
#line 205 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlparse.c"
struct __anonstruct_CONTENT_SCAFFOLD_34 {
   enum XML_Content_Type type ;
   enum XML_Content_Quant quant ;
   XML_Char const   *name ;
   int firstchild ;
   int lastchild ;
   int childcnt ;
   int nextsib ;
};
#line 205 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlparse.c"
typedef struct __anonstruct_CONTENT_SCAFFOLD_34 CONTENT_SCAFFOLD;
#line 217 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlparse.c"
struct block {
   struct block *next ;
   int size ;
   XML_Char s[1] ;
};
#line 217 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlparse.c"
typedef struct block BLOCK;
#line 223 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlparse.c"
struct __anonstruct_STRING_POOL_35 {
   BLOCK *blocks ;
   BLOCK *freeBlocks ;
   XML_Char const   *end ;
   XML_Char *ptr ;
   XML_Char *start ;
   XML_Memory_Handling_Suite const   *mem ;
};
#line 223 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlparse.c"
typedef struct __anonstruct_STRING_POOL_35 STRING_POOL;
#line 234 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlparse.c"
struct attribute_id {
   XML_Char *name ;
   PREFIX *prefix ;
   XML_Bool maybeTokenized ;
   XML_Bool xmlns ;
};
#line 234 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlparse.c"
typedef struct attribute_id ATTRIBUTE_ID;
#line 241 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlparse.c"
struct __anonstruct_DEFAULT_ATTRIBUTE_36 {
   ATTRIBUTE_ID const   *id ;
   XML_Bool isCdata ;
   XML_Char const   *value ;
};
#line 241 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlparse.c"
typedef struct __anonstruct_DEFAULT_ATTRIBUTE_36 DEFAULT_ATTRIBUTE;
#line 247 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlparse.c"
struct __anonstruct_NS_ATT_37 {
   unsigned long version ;
   unsigned long hash ;
   XML_Char const   *uriName ;
};
#line 247 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlparse.c"
typedef struct __anonstruct_NS_ATT_37 NS_ATT;
#line 253 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlparse.c"
struct __anonstruct_ELEMENT_TYPE_38 {
   XML_Char const   *name ;
   PREFIX *prefix ;
   ATTRIBUTE_ID const   *idAtt ;
   int nDefaultAtts ;
   int allocDefaultAtts ;
   DEFAULT_ATTRIBUTE *defaultAtts ;
};
#line 253 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlparse.c"
typedef struct __anonstruct_ELEMENT_TYPE_38 ELEMENT_TYPE;
#line 262 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlparse.c"
struct __anonstruct_DTD_39 {
   HASH_TABLE generalEntities ;
   HASH_TABLE elementTypes ;
   HASH_TABLE attributeIds ;
   HASH_TABLE prefixes ;
   STRING_POOL pool ;
   STRING_POOL entityValuePool ;
   XML_Bool keepProcessing ;
   XML_Bool hasParamEntityRefs ;
   XML_Bool standalone ;
   XML_Bool paramEntityRead ;
   HASH_TABLE paramEntities ;
   PREFIX defaultPrefix ;
   XML_Bool in_eldecl ;
   CONTENT_SCAFFOLD *scaffold ;
   unsigned int contentStringLen ;
   unsigned int scaffSize ;
   unsigned int scaffCount ;
   int scaffLevel ;
   int *scaffIndex ;
};
#line 262 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlparse.c"
typedef struct __anonstruct_DTD_39 DTD;
#line 291 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlparse.c"
struct open_internal_entity {
   char const   *internalEventPtr ;
   char const   *internalEventEndPtr ;
   struct open_internal_entity *next ;
   ENTITY *entity ;
   int startTagLevel ;
   XML_Bool betweenDecl ;
};
#line 291 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlparse.c"
typedef struct open_internal_entity OPEN_INTERNAL_ENTITY;
#line 300 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlparse.c"
typedef enum XML_Error Processor(XML_Parser parser , char const   *start , char const   *end ,
                                 char const   **endPtr );
#line 459 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlparse.c"
struct XML_ParserStruct {
   void *m_userData ;
   void *m_handlerArg ;
   char *m_buffer ;
   XML_Memory_Handling_Suite const   m_mem ;
   char const   *m_bufferPtr ;
   char *m_bufferEnd ;
   char const   *m_bufferLim ;
   XML_Index m_parseEndByteIndex ;
   char const   *m_parseEndPtr ;
   XML_Char *m_dataBuf ;
   XML_Char *m_dataBufEnd ;
   void (*m_startElementHandler)(void *userData , XML_Char const   *name , XML_Char const   **atts ) ;
   void (*m_endElementHandler)(void *userData , XML_Char const   *name ) ;
   void (*m_characterDataHandler)(void *userData , XML_Char const   *s , int len ) ;
   void (*m_processingInstructionHandler)(void *userData , XML_Char const   *target ,
                                          XML_Char const   *data ) ;
   void (*m_commentHandler)(void *userData , XML_Char const   *data ) ;
   void (*m_startCdataSectionHandler)(void *userData ) ;
   void (*m_endCdataSectionHandler)(void *userData ) ;
   void (*m_defaultHandler)(void *userData , XML_Char const   *s , int len ) ;
   void (*m_startDoctypeDeclHandler)(void *userData , XML_Char const   *doctypeName ,
                                     XML_Char const   *sysid , XML_Char const   *pubid ,
                                     int has_internal_subset ) ;
   void (*m_endDoctypeDeclHandler)(void *userData ) ;
   void (*m_unparsedEntityDeclHandler)(void *userData , XML_Char const   *entityName ,
                                       XML_Char const   *base , XML_Char const   *systemId ,
                                       XML_Char const   *publicId , XML_Char const   *notationName ) ;
   void (*m_notationDeclHandler)(void *userData , XML_Char const   *notationName ,
                                 XML_Char const   *base , XML_Char const   *systemId ,
                                 XML_Char const   *publicId ) ;
   void (*m_startNamespaceDeclHandler)(void *userData , XML_Char const   *prefix ,
                                       XML_Char const   *uri ) ;
   void (*m_endNamespaceDeclHandler)(void *userData , XML_Char const   *prefix ) ;
   int (*m_notStandaloneHandler)(void *userData ) ;
   int (*m_externalEntityRefHandler)(XML_Parser parser , XML_Char const   *context ,
                                     XML_Char const   *base , XML_Char const   *systemId ,
                                     XML_Char const   *publicId ) ;
   XML_Parser m_externalEntityRefHandlerArg ;
   void (*m_skippedEntityHandler)(void *userData , XML_Char const   *entityName ,
                                  int is_parameter_entity ) ;
   int (*m_unknownEncodingHandler)(void *encodingHandlerData , XML_Char const   *name ,
                                   XML_Encoding *info ) ;
   void (*m_elementDeclHandler)(void *userData , XML_Char const   *name , XML_Content *model ) ;
   void (*m_attlistDeclHandler)(void *userData , XML_Char const   *elname , XML_Char const   *attname ,
                                XML_Char const   *att_type , XML_Char const   *dflt ,
                                int isrequired ) ;
   void (*m_entityDeclHandler)(void *userData , XML_Char const   *entityName , int is_parameter_entity ,
                               XML_Char const   *value , int value_length , XML_Char const   *base ,
                               XML_Char const   *systemId , XML_Char const   *publicId ,
                               XML_Char const   *notationName ) ;
   void (*m_xmlDeclHandler)(void *userData , XML_Char const   *version , XML_Char const   *encoding ,
                            int standalone ) ;
   ENCODING const   *m_encoding ;
   INIT_ENCODING m_initEncoding ;
   ENCODING const   *m_internalEncoding ;
   XML_Char const   *m_protocolEncodingName ;
   XML_Bool m_ns ;
   XML_Bool m_ns_triplets ;
   void *m_unknownEncodingMem ;
   void *m_unknownEncodingData ;
   void *m_unknownEncodingHandlerData ;
   void (*m_unknownEncodingRelease)(void * ) ;
   PROLOG_STATE m_prologState ;
   Processor *m_processor ;
   enum XML_Error m_errorCode ;
   char const   *m_eventPtr ;
   char const   *m_eventEndPtr ;
   char const   *m_positionPtr ;
   OPEN_INTERNAL_ENTITY *m_openInternalEntities ;
   OPEN_INTERNAL_ENTITY *m_freeInternalEntities ;
   XML_Bool m_defaultExpandInternalEntities ;
   int m_tagLevel ;
   ENTITY *m_declEntity ;
   XML_Char const   *m_doctypeName ;
   XML_Char const   *m_doctypeSysid ;
   XML_Char const   *m_doctypePubid ;
   XML_Char const   *m_declAttributeType ;
   XML_Char const   *m_declNotationName ;
   XML_Char const   *m_declNotationPublicId ;
   ELEMENT_TYPE *m_declElementType ;
   ATTRIBUTE_ID *m_declAttributeId ;
   XML_Bool m_declAttributeIsCdata ;
   XML_Bool m_declAttributeIsId ;
   DTD *m_dtd ;
   XML_Char const   *m_curBase ;
   TAG *m_tagStack ;
   TAG *m_freeTagList ;
   BINDING *m_inheritedBindings ;
   BINDING *m_freeBindingList ;
   int m_attsSize ;
   int m_nSpecifiedAtts ;
   int m_idAttIndex ;
   ATTRIBUTE *m_atts ;
   NS_ATT *m_nsAtts ;
   unsigned long m_nsAttsVersion ;
   unsigned char m_nsAttsPower ;
   POSITION m_position ;
   STRING_POOL m_tempPool ;
   STRING_POOL m_temp2Pool ;
   char *m_groupConnector ;
   unsigned int m_groupSize ;
   XML_Char m_namespaceSeparator ;
   XML_Parser m_parentParser ;
   XML_ParsingStatus m_parsingStatus ;
   XML_Bool m_isParamEntity ;
   XML_Bool m_useForeignDTD ;
   enum XML_ParamEntityParsing m_paramEntityParsing ;
   unsigned long m_hash_secret_salt ;
};
#line 172 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __ssize_t;
#line 102 "/usr/include/stdio.h"
typedef __ssize_t ssize_t;
#line 55 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/xmlwf/xmlfile.c"
struct __anonstruct_PROCESS_ARGS_33 {
   XML_Parser parser ;
   int *retPtr ;
};
#line 55 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/xmlwf/xmlfile.c"
typedef struct __anonstruct_PROCESS_ARGS_33 PROCESS_ARGS;
#line 124 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __dev_t;
#line 125 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uid_t;
#line 126 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __gid_t;
#line 127 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __ino_t;
#line 129 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __mode_t;
#line 130 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __nlink_t;
#line 153 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blksize_t;
#line 158 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blkcnt_t;
#line 175 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __syscall_slong_t;
#line 183 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef char *__caddr_t;
#line 86 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __off_t off_t;
#line 116 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __caddr_t caddr_t;
#line 120 "/usr/include/time.h"
struct timespec {
   __time_t tv_sec ;
   __syscall_slong_t tv_nsec ;
};
#line 46 "/usr/include/x86_64-linux-gnu/bits/stat.h"
struct stat {
   __dev_t st_dev ;
   __ino_t st_ino ;
   __nlink_t st_nlink ;
   __mode_t st_mode ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   int __pad0 ;
   __dev_t st_rdev ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   __syscall_slong_t __glibc_reserved[3] ;
};
#line 1434 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmltok_impl.c"
enum __anonenum_state_4___0 {
    other___2 = 0,
    inName___2 = 1,
    inValue___2 = 2
} ;
#line 1434
enum __anonenum_state_6___0 {
    other___3 = 0,
    inName___3 = 1,
    inValue___3 = 2
} ;
#line 1434
enum __anonenum_state_7___0 {
    other___4 = 0,
    inName___4 = 1,
    inValue___4 = 2
} ;
#line 266 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmltok.h"
int XmlParseXmlDecl(int isGeneralTextEntity , ENCODING const   *enc , char const   *ptr ,
                    char const   *end , char const   **badPtr , char const   **versionPtr ,
                    char const   **versionEndPtr , char const   **encodingName , ENCODING const   **encoding ,
                    int *standalone ) ;
#line 277
int XmlInitEncoding(INIT_ENCODING *p , ENCODING const   **encPtr , char const   *name ) ;
#line 278
ENCODING const   *XmlGetUtf8InternalEncoding(void) ;
#line 279
ENCODING const   *XmlGetUtf16InternalEncoding(void) ;
#line 280
int XmlUtf8Encode(int c___0 , char *buf ) ;
#line 281
int XmlUtf16Encode(int charNum , unsigned short *buf ) ;
#line 282
int XmlSizeOfUnknownEncoding(void) ;
#line 287
ENCODING *XmlInitUnknownEncoding(void *mem , int *table , int (*convert)(void *userData ,
                                                                         char const   *p ) ,
                                 void *userData ) ;
#line 293
int XmlParseXmlDeclNS(int isGeneralTextEntity , ENCODING const   *enc , char const   *ptr ,
                      char const   *end , char const   **badPtr , char const   **versionPtr ,
                      char const   **versionEndPtr , char const   **encodingName ,
                      ENCODING const   **encoding , int *standalone ) ;
#line 304
int XmlInitEncodingNS(INIT_ENCODING *p , ENCODING const   **encPtr , char const   *name ) ;
#line 305
ENCODING const   *XmlGetUtf8InternalEncodingNS(void) ;
#line 306
ENCODING const   *XmlGetUtf16InternalEncodingNS(void) ;
#line 307
ENCODING *XmlInitUnknownEncodingNS(void *mem , int *table , int (*convert)(void *userData ,
                                                                           char const   *p ) ,
                                   void *userData ) ;
#line 1 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/nametab.h"
static unsigned int const   namingBitmap[320]  = 
#line 1 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/nametab.h"
  {      (unsigned int const   )0,      (unsigned int const   )0,      (unsigned int const   )0,      (unsigned int const   )0, 
        (unsigned int const   )0,      (unsigned int const   )0,      (unsigned int const   )0,      (unsigned int const   )0, 
        (unsigned int const   )4294967295U,      (unsigned int const   )4294967295U,      (unsigned int const   )4294967295U,      (unsigned int const   )4294967295U, 
        (unsigned int const   )4294967295U,      (unsigned int const   )4294967295U,      (unsigned int const   )4294967295U,      (unsigned int const   )4294967295U, 
        (unsigned int const   )0,      (unsigned int const   )67108864,      (unsigned int const   )2281701374U,      (unsigned int const   )134217726, 
        (unsigned int const   )0,      (unsigned int const   )0,      (unsigned int const   )4286578687U,      (unsigned int const   )4286578687U, 
        (unsigned int const   )4294967295U,      (unsigned int const   )2146697215,      (unsigned int const   )4294966782U,      (unsigned int const   )2147483647, 
        (unsigned int const   )4294967295U,      (unsigned int const   )4294967295U,      (unsigned int const   )4294959119U,      (unsigned int const   )4231135231U, 
        (unsigned int const   )16777215,      (unsigned int const   )0,      (unsigned int const   )4294901760U,      (unsigned int const   )4294967295U, 
        (unsigned int const   )4294967295U,      (unsigned int const   )4160750079U,      (unsigned int const   )3,      (unsigned int const   )0, 
        (unsigned int const   )0,      (unsigned int const   )0,      (unsigned int const   )0,      (unsigned int const   )0, 
        (unsigned int const   )4294956864U,      (unsigned int const   )4294967291U,      (unsigned int const   )1417641983,      (unsigned int const   )1048573, 
        (unsigned int const   )4294959102U,      (unsigned int const   )4294967295U,      (unsigned int const   )3758030847U,      (unsigned int const   )4294967295U, 
        (unsigned int const   )4294901763U,      (unsigned int const   )4294967295U,      (unsigned int const   )4294908319U,      (unsigned int const   )54513663, 
        (unsigned int const   )0,      (unsigned int const   )4294836224U,      (unsigned int const   )41943039,      (unsigned int const   )4294967294U, 
        (unsigned int const   )127,      (unsigned int const   )0,      (unsigned int const   )4294901760U,      (unsigned int const   )460799, 
        (unsigned int const   )0,      (unsigned int const   )134217726,      (unsigned int const   )2046,      (unsigned int const   )4294836224U, 
        (unsigned int const   )4294967295U,      (unsigned int const   )2097151999,      (unsigned int const   )3112959,      (unsigned int const   )96, 
        (unsigned int const   )4294967264U,      (unsigned int const   )603979775,      (unsigned int const   )4278190080U,      (unsigned int const   )3, 
        (unsigned int const   )4294549472U,      (unsigned int const   )63307263,      (unsigned int const   )2952790016U,      (unsigned int const   )196611, 
        (unsigned int const   )4294543328U,      (unsigned int const   )57540095,      (unsigned int const   )1577058304,      (unsigned int const   )1835008, 
        (unsigned int const   )4294684640U,      (unsigned int const   )602799615,      (unsigned int const   )0,      (unsigned int const   )1, 
        (unsigned int const   )4294549472U,      (unsigned int const   )600702463,      (unsigned int const   )2952790016U,      (unsigned int const   )3, 
        (unsigned int const   )3594373088U,      (unsigned int const   )62899992,      (unsigned int const   )0,      (unsigned int const   )0, 
        (unsigned int const   )4294828000U,      (unsigned int const   )66059775,      (unsigned int const   )0,      (unsigned int const   )3, 
        (unsigned int const   )4294828000U,      (unsigned int const   )66059775,      (unsigned int const   )1073741824,      (unsigned int const   )3, 
        (unsigned int const   )4294828000U,      (unsigned int const   )67108351,      (unsigned int const   )0,      (unsigned int const   )3, 
        (unsigned int const   )0,      (unsigned int const   )0,      (unsigned int const   )0,      (unsigned int const   )0, 
        (unsigned int const   )4294967294U,      (unsigned int const   )884735,      (unsigned int const   )63,      (unsigned int const   )0, 
        (unsigned int const   )4277151126U,      (unsigned int const   )537750702,      (unsigned int const   )31,      (unsigned int const   )0, 
        (unsigned int const   )0,      (unsigned int const   )0,      (unsigned int const   )4294967039U,      (unsigned int const   )1023, 
        (unsigned int const   )0,      (unsigned int const   )0,      (unsigned int const   )0,      (unsigned int const   )0, 
        (unsigned int const   )0,      (unsigned int const   )0,      (unsigned int const   )0,      (unsigned int const   )0, 
        (unsigned int const   )0,      (unsigned int const   )4294967295U,      (unsigned int const   )4294901823U,      (unsigned int const   )8388607, 
        (unsigned int const   )514797,      (unsigned int const   )1342177280,      (unsigned int const   )2184269825U,      (unsigned int const   )2908843, 
        (unsigned int const   )1073741824,      (unsigned int const   )4118857984U,      (unsigned int const   )7,      (unsigned int const   )33622016, 
        (unsigned int const   )4294967295U,      (unsigned int const   )4294967295U,      (unsigned int const   )4294967295U,      (unsigned int const   )4294967295U, 
        (unsigned int const   )268435455,      (unsigned int const   )4294967295U,      (unsigned int const   )4294967295U,      (unsigned int const   )67108863, 
        (unsigned int const   )1061158911,      (unsigned int const   )4294967295U,      (unsigned int const   )2868854591U,      (unsigned int const   )1073741823, 
        (unsigned int const   )4294967295U,      (unsigned int const   )1608515583,      (unsigned int const   )265232348,      (unsigned int const   )534519807, 
        (unsigned int const   )0,      (unsigned int const   )19520,      (unsigned int const   )0,      (unsigned int const   )0, 
        (unsigned int const   )7,      (unsigned int const   )0,      (unsigned int const   )0,      (unsigned int const   )0, 
        (unsigned int const   )128,      (unsigned int const   )1022,      (unsigned int const   )4294967294U,      (unsigned int const   )4294967295U, 
        (unsigned int const   )2097151,      (unsigned int const   )4294967294U,      (unsigned int const   )4294967295U,      (unsigned int const   )134217727, 
        (unsigned int const   )4294967264U,      (unsigned int const   )8191,      (unsigned int const   )0,      (unsigned int const   )0, 
        (unsigned int const   )0,      (unsigned int const   )0,      (unsigned int const   )0,      (unsigned int const   )0, 
        (unsigned int const   )4294967295U,      (unsigned int const   )4294967295U,      (unsigned int const   )4294967295U,      (unsigned int const   )4294967295U, 
        (unsigned int const   )4294967295U,      (unsigned int const   )63,      (unsigned int const   )0,      (unsigned int const   )0, 
        (unsigned int const   )4294967295U,      (unsigned int const   )4294967295U,      (unsigned int const   )4294967295U,      (unsigned int const   )4294967295U, 
        (unsigned int const   )4294967295U,      (unsigned int const   )15,      (unsigned int const   )0,      (unsigned int const   )0, 
        (unsigned int const   )0,      (unsigned int const   )134176768,      (unsigned int const   )2281701374U,      (unsigned int const   )134217726, 
        (unsigned int const   )0,      (unsigned int const   )8388608,      (unsigned int const   )4286578687U,      (unsigned int const   )4286578687U, 
        (unsigned int const   )16777215,      (unsigned int const   )0,      (unsigned int const   )4294901760U,      (unsigned int const   )4294967295U, 
        (unsigned int const   )4294967295U,      (unsigned int const   )4160750079U,      (unsigned int const   )196611,      (unsigned int const   )0, 
        (unsigned int const   )4294967295U,      (unsigned int const   )4294967295U,      (unsigned int const   )63,      (unsigned int const   )3, 
        (unsigned int const   )4294956992U,      (unsigned int const   )4294967291U,      (unsigned int const   )1417641983,      (unsigned int const   )1048573, 
        (unsigned int const   )4294959102U,      (unsigned int const   )4294967295U,      (unsigned int const   )3758030847U,      (unsigned int const   )4294967295U, 
        (unsigned int const   )4294901883U,      (unsigned int const   )4294967295U,      (unsigned int const   )4294908319U,      (unsigned int const   )54513663, 
        (unsigned int const   )0,      (unsigned int const   )4294836224U,      (unsigned int const   )41943039,      (unsigned int const   )4294967294U, 
        (unsigned int const   )4294836351U,      (unsigned int const   )3154116603U,      (unsigned int const   )4294901782U,      (unsigned int const   )460799, 
        (unsigned int const   )0,      (unsigned int const   )134217726,      (unsigned int const   )524287,      (unsigned int const   )4294902783U, 
        (unsigned int const   )4294967295U,      (unsigned int const   )2097151999,      (unsigned int const   )4293885951U,      (unsigned int const   )67059199, 
        (unsigned int const   )4294967278U,      (unsigned int const   )4093640703U,      (unsigned int const   )4280172543U,      (unsigned int const   )65487, 
        (unsigned int const   )4294549486U,      (unsigned int const   )3552968191U,      (unsigned int const   )2961193375U,      (unsigned int const   )262095, 
        (unsigned int const   )4294543332U,      (unsigned int const   )3547201023U,      (unsigned int const   )1577073031,      (unsigned int const   )2097088, 
        (unsigned int const   )4294684654U,      (unsigned int const   )4092460543U,      (unsigned int const   )15295,      (unsigned int const   )65473, 
        (unsigned int const   )4294549486U,      (unsigned int const   )4090363391U,      (unsigned int const   )2965387663U,      (unsigned int const   )65475, 
        (unsigned int const   )3594373100U,      (unsigned int const   )3284125464U,      (unsigned int const   )8404423,      (unsigned int const   )65408, 
        (unsigned int const   )4294828014U,      (unsigned int const   )3287285247U,      (unsigned int const   )6307295,      (unsigned int const   )65475, 
        (unsigned int const   )4294828012U,      (unsigned int const   )3287285247U,      (unsigned int const   )1080049119,      (unsigned int const   )65475, 
        (unsigned int const   )4294828012U,      (unsigned int const   )3288333823U,      (unsigned int const   )8404431,      (unsigned int const   )65475, 
        (unsigned int const   )0,      (unsigned int const   )0,      (unsigned int const   )0,      (unsigned int const   )0, 
        (unsigned int const   )4294967294U,      (unsigned int const   )134184959,      (unsigned int const   )67076095,      (unsigned int const   )0, 
        (unsigned int const   )4277151126U,      (unsigned int const   )1006595246,      (unsigned int const   )67059551,      (unsigned int const   )0, 
        (unsigned int const   )50331648,      (unsigned int const   )3265266687U,      (unsigned int const   )4294967039U,      (unsigned int const   )4294837247U, 
        (unsigned int const   )4273934303U,      (unsigned int const   )50216959,      (unsigned int const   )0,      (unsigned int const   )0, 
        (unsigned int const   )0,      (unsigned int const   )0,      (unsigned int const   )0,      (unsigned int const   )0, 
        (unsigned int const   )0,      (unsigned int const   )0,      (unsigned int const   )536805376,      (unsigned int const   )2, 
        (unsigned int const   )160,      (unsigned int const   )4128766,      (unsigned int const   )4294967294U,      (unsigned int const   )4294967295U, 
        (unsigned int const   )1713373183,      (unsigned int const   )4294967294U,      (unsigned int const   )4294967295U,      (unsigned int const   )2013265919};
#line 83 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/nametab.h"
static unsigned char const   nmstrtPages[256]  = 
#line 83
  {      (unsigned char const   )2,      (unsigned char const   )3,      (unsigned char const   )4,      (unsigned char const   )5, 
        (unsigned char const   )6,      (unsigned char const   )7,      (unsigned char const   )8,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )9,      (unsigned char const   )10,      (unsigned char const   )11, 
        (unsigned char const   )12,      (unsigned char const   )13,      (unsigned char const   )14,      (unsigned char const   )15, 
        (unsigned char const   )16,      (unsigned char const   )17,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )18,      (unsigned char const   )19, 
        (unsigned char const   )0,      (unsigned char const   )20,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )21,      (unsigned char const   )22,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )1,      (unsigned char const   )1, 
        (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1, 
        (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1, 
        (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1, 
        (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1, 
        (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1, 
        (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1, 
        (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1, 
        (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1, 
        (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1, 
        (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1, 
        (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1, 
        (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1, 
        (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1, 
        (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1, 
        (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1, 
        (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1, 
        (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1, 
        (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1, 
        (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1, 
        (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )23, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1, 
        (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1, 
        (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1, 
        (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1, 
        (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1, 
        (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1, 
        (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1, 
        (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1, 
        (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1, 
        (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1, 
        (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )24, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0};
#line 117 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/nametab.h"
static unsigned char const   namePages[256]  = 
#line 117
  {      (unsigned char const   )25,      (unsigned char const   )3,      (unsigned char const   )26,      (unsigned char const   )27, 
        (unsigned char const   )28,      (unsigned char const   )29,      (unsigned char const   )30,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )31,      (unsigned char const   )32,      (unsigned char const   )33, 
        (unsigned char const   )34,      (unsigned char const   )35,      (unsigned char const   )36,      (unsigned char const   )37, 
        (unsigned char const   )16,      (unsigned char const   )17,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )18,      (unsigned char const   )19, 
        (unsigned char const   )38,      (unsigned char const   )20,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )39,      (unsigned char const   )22,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )1,      (unsigned char const   )1, 
        (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1, 
        (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1, 
        (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1, 
        (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1, 
        (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1, 
        (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1, 
        (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1, 
        (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1, 
        (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1, 
        (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1, 
        (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1, 
        (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1, 
        (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1, 
        (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1, 
        (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1, 
        (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1, 
        (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1, 
        (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1, 
        (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1, 
        (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )23, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1, 
        (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1, 
        (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1, 
        (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1, 
        (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1, 
        (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1, 
        (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1, 
        (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1, 
        (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1, 
        (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1, 
        (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )24, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0};
#line 124 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmltok.c"
static int isNever(ENCODING const   *enc , char const   *p ) 
{ 


  {
#line 127
  return (0);
}
}
#line 130 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmltok.c"
static int utf8_isName2(ENCODING const   *enc , char const   *p ) 
{ 


  {
#line 133
  return ((int )(namingBitmap[(((int const   )namePages[((int const   )*((unsigned char const   *)p + 0) >> 2) & 7] << 3) + (((int const   )*((unsigned char const   *)p + 0) & 3) << 1)) + (((int const   )*((unsigned char const   *)p + 1) >> 5) & 1)] & (unsigned int const   )(1 << ((int const   )*((unsigned char const   *)p + 1) & 31))));
}
}
#line 136 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmltok.c"
static int utf8_isName3(ENCODING const   *enc , char const   *p ) 
{ 


  {
#line 139
  return ((int )(namingBitmap[(((int const   )namePages[(((int const   )*((unsigned char const   *)p + 0) & 15) << 4) + (((int const   )*((unsigned char const   *)p + 1) >> 2) & 15)] << 3) + (((int const   )*((unsigned char const   *)p + 1) & 3) << 1)) + (((int const   )*((unsigned char const   *)p + 2) >> 5) & 1)] & (unsigned int const   )(1 << ((int const   )*((unsigned char const   *)p + 2) & 31))));
}
}
#line 144 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmltok.c"
static int utf8_isNmstrt2(ENCODING const   *enc , char const   *p ) 
{ 


  {
#line 147
  return ((int )(namingBitmap[(((int const   )nmstrtPages[((int const   )*((unsigned char const   *)p + 0) >> 2) & 7] << 3) + (((int const   )*((unsigned char const   *)p + 0) & 3) << 1)) + (((int const   )*((unsigned char const   *)p + 1) >> 5) & 1)] & (unsigned int const   )(1 << ((int const   )*((unsigned char const   *)p + 1) & 31))));
}
}
#line 150 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmltok.c"
static int utf8_isNmstrt3(ENCODING const   *enc , char const   *p ) 
{ 


  {
#line 153
  return ((int )(namingBitmap[(((int const   )nmstrtPages[(((int const   )*((unsigned char const   *)p + 0) & 15) << 4) + (((int const   )*((unsigned char const   *)p + 1) >> 2) & 15)] << 3) + (((int const   )*((unsigned char const   *)p + 1) & 3) << 1)) + (((int const   )*((unsigned char const   *)p + 2) >> 5) & 1)] & (unsigned int const   )(1 << ((int const   )*((unsigned char const   *)p + 2) & 31))));
}
}
#line 158 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmltok.c"
static int utf8_isInvalid2(ENCODING const   *enc , char const   *p ) 
{ 
  int tmp ;

  {
#line 161
  if ((int const   )*((unsigned char const   *)p) < 194) {
#line 161
    tmp = 1;
  } else
#line 161
  if (((int const   )*((unsigned char const   *)p + 1) & 128) == 0) {
#line 161
    tmp = 1;
  } else
#line 161
  if (((int const   )*((unsigned char const   *)p + 1) & 192) == 192) {
#line 161
    tmp = 1;
  } else {
#line 161
    tmp = 0;
  }
#line 161
  return (tmp);
}
}
#line 164 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmltok.c"
static int utf8_isInvalid3(ENCODING const   *enc , char const   *p ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 167
  if (((int const   )*((unsigned char const   *)p + 2) & 128) == 0) {
#line 167
    tmp___4 = 1;
  } else {
#line 167
    if ((int const   )*((unsigned char const   *)p) == 239) {
#line 167
      if ((int const   )*((unsigned char const   *)p + 1) == 191) {
#line 167
        tmp = (int const   )*((unsigned char const   *)p + 2) > 189;
      } else {
#line 167
        tmp = ((int const   )*((unsigned char const   *)p + 2) & 192) == 192;
      }
    } else {
#line 167
      tmp = ((int const   )*((unsigned char const   *)p + 2) & 192) == 192;
    }
#line 167
    if (tmp) {
#line 167
      tmp___4 = 1;
    } else {
#line 167
      if ((int const   )*((unsigned char const   *)p) == 224) {
#line 167
        if ((int const   )*((unsigned char const   *)p + 1) < 160) {
#line 167
          tmp___0 = 1;
        } else
#line 167
        if (((int const   )*((unsigned char const   *)p + 1) & 192) == 192) {
#line 167
          tmp___0 = 1;
        } else {
#line 167
          tmp___0 = 0;
        }
#line 167
        tmp___3 = tmp___0;
      } else {
#line 167
        if (((int const   )*((unsigned char const   *)p + 1) & 128) == 0) {
#line 167
          tmp___2 = 1;
        } else {
#line 167
          if ((int const   )*((unsigned char const   *)p) == 237) {
#line 167
            tmp___1 = (int const   )*((unsigned char const   *)p + 1) > 159;
          } else {
#line 167
            tmp___1 = ((int const   )*((unsigned char const   *)p + 1) & 192) == 192;
          }
#line 167
          if (tmp___1) {
#line 167
            tmp___2 = 1;
          } else {
#line 167
            tmp___2 = 0;
          }
        }
#line 167
        tmp___3 = tmp___2;
      }
#line 167
      if (tmp___3) {
#line 167
        tmp___4 = 1;
      } else {
#line 167
        tmp___4 = 0;
      }
    }
  }
#line 167
  return (tmp___4);
}
}
#line 170 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmltok.c"
static int utf8_isInvalid4(ENCODING const   *enc , char const   *p ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 173
  if (((int const   )*((unsigned char const   *)p + 3) & 128) == 0) {
#line 173
    tmp___3 = 1;
  } else
#line 173
  if (((int const   )*((unsigned char const   *)p + 3) & 192) == 192) {
#line 173
    tmp___3 = 1;
  } else
#line 173
  if (((int const   )*((unsigned char const   *)p + 2) & 128) == 0) {
#line 173
    tmp___3 = 1;
  } else
#line 173
  if (((int const   )*((unsigned char const   *)p + 2) & 192) == 192) {
#line 173
    tmp___3 = 1;
  } else {
#line 173
    if ((int const   )*((unsigned char const   *)p) == 240) {
#line 173
      if ((int const   )*((unsigned char const   *)p + 1) < 144) {
#line 173
        tmp = 1;
      } else
#line 173
      if (((int const   )*((unsigned char const   *)p + 1) & 192) == 192) {
#line 173
        tmp = 1;
      } else {
#line 173
        tmp = 0;
      }
#line 173
      tmp___2 = tmp;
    } else {
#line 173
      if (((int const   )*((unsigned char const   *)p + 1) & 128) == 0) {
#line 173
        tmp___1 = 1;
      } else {
#line 173
        if ((int const   )*((unsigned char const   *)p) == 244) {
#line 173
          tmp___0 = (int const   )*((unsigned char const   *)p + 1) > 143;
        } else {
#line 173
          tmp___0 = ((int const   )*((unsigned char const   *)p + 1) & 192) == 192;
        }
#line 173
        if (tmp___0) {
#line 173
          tmp___1 = 1;
        } else {
#line 173
          tmp___1 = 0;
        }
      }
#line 173
      tmp___2 = tmp___1;
    }
#line 173
    if (tmp___2) {
#line 173
      tmp___3 = 1;
    } else {
#line 173
      tmp___3 = 0;
    }
  }
#line 173
  return (tmp___3);
}
}
#line 225
static int checkCharRefNumber(int result ) ;
#line 92 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmltok_impl.c"
static int normal_scanComment(ENCODING const   *enc , char const   *ptr , char const   *end ,
                              char const   **nextTokPtr ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 96
  if ((unsigned long )ptr != (unsigned long )end) {
#line 97
    if (! ((int const   )*ptr == 45)) {
#line 98
      *nextTokPtr = ptr;
#line 99
      return (0);
    }
#line 101
    ptr ++;
    {
#line 102
    while (1) {
      while_continue: /* CIL Label */ ;
#line 102
      if (! ((unsigned long )ptr != (unsigned long )end)) {
#line 102
        goto while_break;
      }
      {
#line 104
      if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 5) {
#line 104
        goto case_5;
      }
#line 104
      if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 6) {
#line 104
        goto case_6;
      }
#line 104
      if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 7) {
#line 104
        goto case_7;
      }
#line 104
      if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 8) {
#line 104
        goto case_8;
      }
#line 104
      if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 1) {
#line 104
        goto case_8;
      }
#line 104
      if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 0) {
#line 104
        goto case_8;
      }
#line 105
      if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 27) {
#line 105
        goto case_27;
      }
#line 119
      goto switch_default;
      case_5: /* CIL Label */ 
#line 104
      if (end - ptr < 2L) {
#line 104
        return (-2);
      }
      {
#line 104
      tmp = (*(((struct normal_encoding  const  *)enc)->isInvalid2))(enc, ptr);
      }
#line 104
      if (tmp) {
#line 104
        *nextTokPtr = ptr;
#line 104
        return (0);
      }
#line 104
      ptr += 2;
#line 104
      goto switch_break;
      case_6: /* CIL Label */ 
#line 104
      if (end - ptr < 3L) {
#line 104
        return (-2);
      }
      {
#line 104
      tmp___0 = (*(((struct normal_encoding  const  *)enc)->isInvalid3))(enc, ptr);
      }
#line 104
      if (tmp___0) {
#line 104
        *nextTokPtr = ptr;
#line 104
        return (0);
      }
#line 104
      ptr += 3;
#line 104
      goto switch_break;
      case_7: /* CIL Label */ 
#line 104
      if (end - ptr < 4L) {
#line 104
        return (-2);
      }
      {
#line 104
      tmp___1 = (*(((struct normal_encoding  const  *)enc)->isInvalid4))(enc, ptr);
      }
#line 104
      if (tmp___1) {
#line 104
        *nextTokPtr = ptr;
#line 104
        return (0);
      }
#line 104
      ptr += 4;
#line 104
      goto switch_break;
      case_8: /* CIL Label */ 
      case_1: /* CIL Label */ 
      case_0: /* CIL Label */ 
#line 104
      *nextTokPtr = ptr;
#line 104
      return (0);
      case_27: /* CIL Label */ 
#line 106
      ptr ++;
#line 106
      if ((unsigned long )ptr == (unsigned long )end) {
#line 107
        return (-1);
      }
#line 108
      if ((int const   )*ptr == 45) {
#line 109
        ptr ++;
#line 109
        if ((unsigned long )ptr == (unsigned long )end) {
#line 110
          return (-1);
        }
#line 111
        if (! ((int const   )*ptr == 62)) {
#line 112
          *nextTokPtr = ptr;
#line 113
          return (0);
        }
#line 115
        *nextTokPtr = ptr + 1;
#line 116
        return (13);
      }
#line 118
      goto switch_break;
      switch_default: /* CIL Label */ 
#line 120
      ptr ++;
#line 121
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 125
  return (-1);
}
}
#line 130 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmltok_impl.c"
static int normal_scanDecl(ENCODING const   *enc , char const   *ptr , char const   *end ,
                           char const   **nextTokPtr ) 
{ 
  int tmp ;

  {
#line 134
  if ((unsigned long )ptr == (unsigned long )end) {
#line 135
    return (-1);
  }
  {
#line 137
  if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 27) {
#line 137
    goto case_27;
  }
#line 139
  if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 20) {
#line 139
    goto case_20;
  }
#line 143
  if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 24) {
#line 143
    goto case_24;
  }
#line 143
  if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 22) {
#line 143
    goto case_24;
  }
#line 146
  goto switch_default;
  case_27: /* CIL Label */ 
  {
#line 138
  tmp = normal_scanComment(enc, ptr + 1, end, nextTokPtr);
  }
#line 138
  return (tmp);
  case_20: /* CIL Label */ 
#line 140
  *nextTokPtr = ptr + 1;
#line 141
  return (33);
  case_24: /* CIL Label */ 
  case_22: /* CIL Label */ 
#line 144
  ptr ++;
#line 145
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 147
  *nextTokPtr = ptr;
#line 148
  return (0);
  switch_break: /* CIL Label */ ;
  }
  {
#line 150
  while (1) {
    while_continue: /* CIL Label */ ;
#line 150
    if (! ((unsigned long )ptr != (unsigned long )end)) {
#line 150
      goto while_break;
    }
    {
#line 152
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 30) {
#line 152
      goto case_30;
    }
#line 162
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 10) {
#line 162
      goto case_10___0;
    }
#line 162
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 9) {
#line 162
      goto case_10___0;
    }
#line 162
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 21) {
#line 162
      goto case_10___0;
    }
#line 166
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 24) {
#line 166
      goto case_24___0;
    }
#line 166
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 22) {
#line 166
      goto case_24___0;
    }
#line 169
    goto switch_default___0;
    case_30: /* CIL Label */ 
#line 153
    if ((unsigned long )(ptr + 1) == (unsigned long )end) {
#line 154
      return (-1);
    }
    {
#line 157
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*(ptr + 1)] == 30) {
#line 157
      goto case_30___0;
    }
#line 157
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*(ptr + 1)] == 10) {
#line 157
      goto case_30___0;
    }
#line 157
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*(ptr + 1)] == 9) {
#line 157
      goto case_30___0;
    }
#line 157
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*(ptr + 1)] == 21) {
#line 157
      goto case_30___0;
    }
#line 156
    goto switch_break___1;
    case_30___0: /* CIL Label */ 
    case_10: /* CIL Label */ 
    case_9: /* CIL Label */ 
    case_21: /* CIL Label */ 
#line 158
    *nextTokPtr = ptr;
#line 159
    return (0);
    switch_break___1: /* CIL Label */ ;
    }
    case_10___0: /* CIL Label */ 
    case_9___0: /* CIL Label */ 
    case_21___0: /* CIL Label */ 
#line 163
    *nextTokPtr = ptr;
#line 164
    return (16);
    case_24___0: /* CIL Label */ 
    case_22___0: /* CIL Label */ 
#line 167
    ptr ++;
#line 168
    goto switch_break___0;
    switch_default___0: /* CIL Label */ 
#line 170
    *nextTokPtr = ptr;
#line 171
    return (0);
    switch_break___0: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 174
  return (-1);
}
}
#line 177 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmltok_impl.c"
static int normal_checkPiTarget(ENCODING const   *enc , char const   *ptr , char const   *end ,
                                int *tokPtr ) 
{ 
  int upper ;

  {
#line 181
  upper = 0;
#line 182
  *tokPtr = 11;
#line 183
  if (end - ptr != 3L) {
#line 184
    return (1);
  }
  {
#line 186
  if ((int const   )*ptr == 120) {
#line 186
    goto case_120;
  }
#line 188
  if ((int const   )*ptr == 88) {
#line 188
    goto case_88;
  }
#line 191
  goto switch_default;
  case_120: /* CIL Label */ 
#line 187
  goto switch_break;
  case_88: /* CIL Label */ 
#line 189
  upper = 1;
#line 190
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 192
  return (1);
  switch_break: /* CIL Label */ ;
  }
#line 194
  ptr ++;
  {
#line 196
  if ((int const   )*ptr == 109) {
#line 196
    goto case_109;
  }
#line 198
  if ((int const   )*ptr == 77) {
#line 198
    goto case_77;
  }
#line 201
  goto switch_default___0;
  case_109: /* CIL Label */ 
#line 197
  goto switch_break___0;
  case_77: /* CIL Label */ 
#line 199
  upper = 1;
#line 200
  goto switch_break___0;
  switch_default___0: /* CIL Label */ 
#line 202
  return (1);
  switch_break___0: /* CIL Label */ ;
  }
#line 204
  ptr ++;
  {
#line 206
  if ((int const   )*ptr == 108) {
#line 206
    goto case_108;
  }
#line 208
  if ((int const   )*ptr == 76) {
#line 208
    goto case_76;
  }
#line 211
  goto switch_default___1;
  case_108: /* CIL Label */ 
#line 207
  goto switch_break___1;
  case_76: /* CIL Label */ 
#line 209
  upper = 1;
#line 210
  goto switch_break___1;
  switch_default___1: /* CIL Label */ 
#line 212
  return (1);
  switch_break___1: /* CIL Label */ ;
  }
#line 214
  if (upper) {
#line 215
    return (0);
  }
#line 216
  *tokPtr = 12;
#line 217
  return (1);
}
}
#line 222 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmltok_impl.c"
static int normal_scanPi(ENCODING const   *enc , char const   *ptr , char const   *end ,
                         char const   **nextTokPtr ) 
{ 
  int tok ;
  char const   *target ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;

  {
#line 227
  target = ptr;
#line 228
  if ((unsigned long )ptr == (unsigned long )end) {
#line 229
    return (-1);
  }
  {
#line 231
  if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 29) {
#line 231
    goto case_29;
  }
#line 231
  if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 24) {
#line 231
    goto case_24;
  }
#line 231
  if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 22) {
#line 231
    goto case_24;
  }
#line 231
  if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 5) {
#line 231
    goto case_5;
  }
#line 231
  if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 6) {
#line 231
    goto case_6;
  }
#line 231
  if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 7) {
#line 231
    goto case_7;
  }
#line 232
  goto switch_default;
  case_29: /* CIL Label */ 
#line 231
  *nextTokPtr = ptr;
#line 231
  return (0);
  case_24: /* CIL Label */ 
  case_22: /* CIL Label */ 
#line 231
  ptr ++;
#line 231
  goto switch_break;
  case_5: /* CIL Label */ 
#line 231
  if (end - ptr < 2L) {
#line 231
    return (-2);
  }
  {
#line 231
  tmp = (*(((struct normal_encoding  const  *)enc)->isNmstrt2))(enc, ptr);
  }
#line 231
  if (! tmp) {
#line 231
    *nextTokPtr = ptr;
#line 231
    return (0);
  }
#line 231
  ptr += 2;
#line 231
  goto switch_break;
  case_6: /* CIL Label */ 
#line 231
  if (end - ptr < 3L) {
#line 231
    return (-2);
  }
  {
#line 231
  tmp___0 = (*(((struct normal_encoding  const  *)enc)->isNmstrt3))(enc, ptr);
  }
#line 231
  if (! tmp___0) {
#line 231
    *nextTokPtr = ptr;
#line 231
    return (0);
  }
#line 231
  ptr += 3;
#line 231
  goto switch_break;
  case_7: /* CIL Label */ 
#line 231
  if (end - ptr < 4L) {
#line 231
    return (-2);
  }
  {
#line 231
  tmp___1 = (*(((struct normal_encoding  const  *)enc)->isNmstrt4))(enc, ptr);
  }
#line 231
  if (! tmp___1) {
#line 231
    *nextTokPtr = ptr;
#line 231
    return (0);
  }
#line 231
  ptr += 4;
#line 231
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 233
  *nextTokPtr = ptr;
#line 234
  return (0);
  switch_break: /* CIL Label */ ;
  }
  {
#line 236
  while (1) {
    while_continue: /* CIL Label */ ;
#line 236
    if (! ((unsigned long )ptr != (unsigned long )end)) {
#line 236
      goto while_break;
    }
    {
#line 238
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 29) {
#line 238
      goto case_29___0;
    }
#line 238
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 27) {
#line 238
      goto case_27;
    }
#line 238
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 26) {
#line 238
      goto case_27;
    }
#line 238
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 25) {
#line 238
      goto case_27;
    }
#line 238
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 24) {
#line 238
      goto case_27;
    }
#line 238
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 22) {
#line 238
      goto case_27;
    }
#line 238
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 5) {
#line 238
      goto case_5___0;
    }
#line 238
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 6) {
#line 238
      goto case_6___0;
    }
#line 238
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 7) {
#line 238
      goto case_7___0;
    }
#line 239
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 10) {
#line 239
      goto case_10;
    }
#line 239
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 9) {
#line 239
      goto case_10;
    }
#line 239
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 21) {
#line 239
      goto case_10;
    }
#line 263
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 15) {
#line 263
      goto case_15___0;
    }
#line 276
    goto switch_default___1;
    case_29___0: /* CIL Label */ 
#line 238
    *nextTokPtr = ptr;
#line 238
    return (0);
    case_27: /* CIL Label */ 
    case_26: /* CIL Label */ 
    case_25: /* CIL Label */ 
    case_24___0: /* CIL Label */ 
    case_22___0: /* CIL Label */ 
#line 238
    ptr ++;
#line 238
    goto switch_break___0;
    case_5___0: /* CIL Label */ 
#line 238
    if (end - ptr < 2L) {
#line 238
      return (-2);
    }
    {
#line 238
    tmp___2 = (*(((struct normal_encoding  const  *)enc)->isName2))(enc, ptr);
    }
#line 238
    if (! tmp___2) {
#line 238
      *nextTokPtr = ptr;
#line 238
      return (0);
    }
#line 238
    ptr += 2;
#line 238
    goto switch_break___0;
    case_6___0: /* CIL Label */ 
#line 238
    if (end - ptr < 3L) {
#line 238
      return (-2);
    }
    {
#line 238
    tmp___3 = (*(((struct normal_encoding  const  *)enc)->isName3))(enc, ptr);
    }
#line 238
    if (! tmp___3) {
#line 238
      *nextTokPtr = ptr;
#line 238
      return (0);
    }
#line 238
    ptr += 3;
#line 238
    goto switch_break___0;
    case_7___0: /* CIL Label */ 
#line 238
    if (end - ptr < 4L) {
#line 238
      return (-2);
    }
    {
#line 238
    tmp___4 = (*(((struct normal_encoding  const  *)enc)->isName4))(enc, ptr);
    }
#line 238
    if (! tmp___4) {
#line 238
      *nextTokPtr = ptr;
#line 238
      return (0);
    }
#line 238
    ptr += 4;
#line 238
    goto switch_break___0;
    case_10: /* CIL Label */ 
    case_9: /* CIL Label */ 
    case_21: /* CIL Label */ 
    {
#line 240
    tmp___5 = normal_checkPiTarget(enc, target, ptr, & tok);
    }
#line 240
    if (! tmp___5) {
#line 241
      *nextTokPtr = ptr;
#line 242
      return (0);
    }
#line 244
    ptr ++;
    {
#line 245
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 245
      if (! ((unsigned long )ptr != (unsigned long )end)) {
#line 245
        goto while_break___0;
      }
      {
#line 247
      if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 5) {
#line 247
        goto case_5___1;
      }
#line 247
      if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 6) {
#line 247
        goto case_6___1;
      }
#line 247
      if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 7) {
#line 247
        goto case_7___1;
      }
#line 247
      if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 8) {
#line 247
        goto case_8;
      }
#line 247
      if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 1) {
#line 247
        goto case_8;
      }
#line 247
      if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 0) {
#line 247
        goto case_8;
      }
#line 248
      if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 15) {
#line 248
        goto case_15;
      }
#line 257
      goto switch_default___0;
      case_5___1: /* CIL Label */ 
#line 247
      if (end - ptr < 2L) {
#line 247
        return (-2);
      }
      {
#line 247
      tmp___6 = (*(((struct normal_encoding  const  *)enc)->isInvalid2))(enc, ptr);
      }
#line 247
      if (tmp___6) {
#line 247
        *nextTokPtr = ptr;
#line 247
        return (0);
      }
#line 247
      ptr += 2;
#line 247
      goto switch_break___1;
      case_6___1: /* CIL Label */ 
#line 247
      if (end - ptr < 3L) {
#line 247
        return (-2);
      }
      {
#line 247
      tmp___7 = (*(((struct normal_encoding  const  *)enc)->isInvalid3))(enc, ptr);
      }
#line 247
      if (tmp___7) {
#line 247
        *nextTokPtr = ptr;
#line 247
        return (0);
      }
#line 247
      ptr += 3;
#line 247
      goto switch_break___1;
      case_7___1: /* CIL Label */ 
#line 247
      if (end - ptr < 4L) {
#line 247
        return (-2);
      }
      {
#line 247
      tmp___8 = (*(((struct normal_encoding  const  *)enc)->isInvalid4))(enc, ptr);
      }
#line 247
      if (tmp___8) {
#line 247
        *nextTokPtr = ptr;
#line 247
        return (0);
      }
#line 247
      ptr += 4;
#line 247
      goto switch_break___1;
      case_8: /* CIL Label */ 
      case_1: /* CIL Label */ 
      case_0: /* CIL Label */ 
#line 247
      *nextTokPtr = ptr;
#line 247
      return (0);
      case_15: /* CIL Label */ 
#line 249
      ptr ++;
#line 250
      if ((unsigned long )ptr == (unsigned long )end) {
#line 251
        return (-1);
      }
#line 252
      if ((int const   )*ptr == 62) {
#line 253
        *nextTokPtr = ptr + 1;
#line 254
        return (tok);
      }
#line 256
      goto switch_break___1;
      switch_default___0: /* CIL Label */ 
#line 258
      ptr ++;
#line 259
      goto switch_break___1;
      switch_break___1: /* CIL Label */ ;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 262
    return (-1);
    case_15___0: /* CIL Label */ 
    {
#line 264
    tmp___9 = normal_checkPiTarget(enc, target, ptr, & tok);
    }
#line 264
    if (! tmp___9) {
#line 265
      *nextTokPtr = ptr;
#line 266
      return (0);
    }
#line 268
    ptr ++;
#line 269
    if ((unsigned long )ptr == (unsigned long )end) {
#line 270
      return (-1);
    }
#line 271
    if ((int const   )*ptr == 62) {
#line 272
      *nextTokPtr = ptr + 1;
#line 273
      return (tok);
    }
    switch_default___1: /* CIL Label */ 
#line 277
    *nextTokPtr = ptr;
#line 278
    return (0);
    switch_break___0: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 281
  return (-1);
}
}
#line 288
static int normal_scanCdataSection(ENCODING const   *enc , char const   *ptr , char const   *end ,
                                   char const   **nextTokPtr ) ;
#line 288 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmltok_impl.c"
static char const   CDATA_LSQB[6]  = {      (char const   )67,      (char const   )68,      (char const   )65,      (char const   )84, 
        (char const   )65,      (char const   )91};
#line 284 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmltok_impl.c"
static int normal_scanCdataSection(ENCODING const   *enc , char const   *ptr , char const   *end ,
                                   char const   **nextTokPtr ) 
{ 
  int i ;

  {
#line 292
  if (end - ptr < 6L) {
#line 293
    return (-1);
  }
#line 294
  i = 0;
  {
#line 294
  while (1) {
    while_continue: /* CIL Label */ ;
#line 294
    if (! (i < 6)) {
#line 294
      goto while_break;
    }
#line 295
    if (! ((int const   )*ptr == (int const   )CDATA_LSQB[i])) {
#line 296
      *nextTokPtr = ptr;
#line 297
      return (0);
    }
#line 294
    i ++;
#line 294
    ptr ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 300
  *nextTokPtr = ptr;
#line 301
  return (8);
}
}
#line 304 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmltok_impl.c"
static int normal_cdataSectionTok(ENCODING const   *enc , char const   *ptr , char const   *end ,
                                  char const   **nextTokPtr ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 308
  if ((unsigned long )ptr == (unsigned long )end) {
#line 309
    return (-4);
  }
  {
#line 320
  if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 4) {
#line 320
    goto case_4;
  }
#line 335
  if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 9) {
#line 335
    goto case_9;
  }
#line 343
  if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 10) {
#line 343
    goto case_10;
  }
#line 346
  if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 5) {
#line 346
    goto case_5;
  }
#line 346
  if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 6) {
#line 346
    goto case_6;
  }
#line 346
  if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 7) {
#line 346
    goto case_7;
  }
#line 346
  if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 8) {
#line 346
    goto case_8;
  }
#line 346
  if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 1) {
#line 346
    goto case_8;
  }
#line 346
  if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 0) {
#line 346
    goto case_8;
  }
#line 347
  goto switch_default;
  case_4: /* CIL Label */ 
#line 321
  ptr ++;
#line 322
  if ((unsigned long )ptr == (unsigned long )end) {
#line 323
    return (-1);
  }
#line 324
  if (! ((int const   )*ptr == 93)) {
#line 325
    goto switch_break;
  }
#line 326
  ptr ++;
#line 327
  if ((unsigned long )ptr == (unsigned long )end) {
#line 328
    return (-1);
  }
#line 329
  if (! ((int const   )*ptr == 62)) {
#line 330
    ptr --;
#line 331
    goto switch_break;
  }
#line 333
  *nextTokPtr = ptr + 1;
#line 334
  return (40);
  case_9: /* CIL Label */ 
#line 336
  ptr ++;
#line 337
  if ((unsigned long )ptr == (unsigned long )end) {
#line 338
    return (-1);
  }
#line 339
  if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 10) {
#line 340
    ptr ++;
  }
#line 341
  *nextTokPtr = ptr;
#line 342
  return (7);
  case_10: /* CIL Label */ 
#line 344
  *nextTokPtr = ptr + 1;
#line 345
  return (7);
  case_5: /* CIL Label */ 
#line 346
  if (end - ptr < 2L) {
#line 346
    return (-2);
  }
  {
#line 346
  tmp = (*(((struct normal_encoding  const  *)enc)->isInvalid2))(enc, ptr);
  }
#line 346
  if (tmp) {
#line 346
    *nextTokPtr = ptr;
#line 346
    return (0);
  }
#line 346
  ptr += 2;
#line 346
  goto switch_break;
  case_6: /* CIL Label */ 
#line 346
  if (end - ptr < 3L) {
#line 346
    return (-2);
  }
  {
#line 346
  tmp___0 = (*(((struct normal_encoding  const  *)enc)->isInvalid3))(enc, ptr);
  }
#line 346
  if (tmp___0) {
#line 346
    *nextTokPtr = ptr;
#line 346
    return (0);
  }
#line 346
  ptr += 3;
#line 346
  goto switch_break;
  case_7: /* CIL Label */ 
#line 346
  if (end - ptr < 4L) {
#line 346
    return (-2);
  }
  {
#line 346
  tmp___1 = (*(((struct normal_encoding  const  *)enc)->isInvalid4))(enc, ptr);
  }
#line 346
  if (tmp___1) {
#line 346
    *nextTokPtr = ptr;
#line 346
    return (0);
  }
#line 346
  ptr += 4;
#line 346
  goto switch_break;
  case_8: /* CIL Label */ 
  case_1: /* CIL Label */ 
  case_0: /* CIL Label */ 
#line 346
  *nextTokPtr = ptr;
#line 346
  return (0);
  switch_default: /* CIL Label */ 
#line 348
  ptr ++;
#line 349
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 351
  while (1) {
    while_continue: /* CIL Label */ ;
#line 351
    if (! ((unsigned long )ptr != (unsigned long )end)) {
#line 351
      goto while_break;
    }
    {
#line 361
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 5) {
#line 361
      goto case_5___0;
    }
#line 361
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 6) {
#line 361
      goto case_6___0;
    }
#line 361
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 7) {
#line 361
      goto case_7___0;
    }
#line 368
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 4) {
#line 368
      goto case_4___0;
    }
#line 368
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 10) {
#line 368
      goto case_4___0;
    }
#line 368
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 9) {
#line 368
      goto case_4___0;
    }
#line 368
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 8) {
#line 368
      goto case_4___0;
    }
#line 368
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 1) {
#line 368
      goto case_4___0;
    }
#line 368
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 0) {
#line 368
      goto case_4___0;
    }
#line 371
    goto switch_default___0;
    case_5___0: /* CIL Label */ 
#line 361
    if (end - ptr < 2L) {
#line 361
      *nextTokPtr = ptr;
#line 361
      return (6);
    } else {
      {
#line 361
      tmp___2 = (*(((struct normal_encoding  const  *)enc)->isInvalid2))(enc, ptr);
      }
#line 361
      if (tmp___2) {
#line 361
        *nextTokPtr = ptr;
#line 361
        return (6);
      }
    }
#line 361
    ptr += 2;
#line 361
    goto switch_break___0;
    case_6___0: /* CIL Label */ 
#line 361
    if (end - ptr < 3L) {
#line 361
      *nextTokPtr = ptr;
#line 361
      return (6);
    } else {
      {
#line 361
      tmp___3 = (*(((struct normal_encoding  const  *)enc)->isInvalid3))(enc, ptr);
      }
#line 361
      if (tmp___3) {
#line 361
        *nextTokPtr = ptr;
#line 361
        return (6);
      }
    }
#line 361
    ptr += 3;
#line 361
    goto switch_break___0;
    case_7___0: /* CIL Label */ 
#line 361
    if (end - ptr < 4L) {
#line 361
      *nextTokPtr = ptr;
#line 361
      return (6);
    } else {
      {
#line 361
      tmp___4 = (*(((struct normal_encoding  const  *)enc)->isInvalid4))(enc, ptr);
      }
#line 361
      if (tmp___4) {
#line 361
        *nextTokPtr = ptr;
#line 361
        return (6);
      }
    }
#line 361
    ptr += 4;
#line 361
    goto switch_break___0;
    case_4___0: /* CIL Label */ 
    case_10___0: /* CIL Label */ 
    case_9___0: /* CIL Label */ 
    case_8___0: /* CIL Label */ 
    case_1___0: /* CIL Label */ 
    case_0___0: /* CIL Label */ 
#line 369
    *nextTokPtr = ptr;
#line 370
    return (6);
    switch_default___0: /* CIL Label */ 
#line 372
    ptr ++;
#line 373
    goto switch_break___0;
    switch_break___0: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 376
  *nextTokPtr = ptr;
#line 377
  return (6);
}
}
#line 382 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmltok_impl.c"
static int normal_scanEndTag(ENCODING const   *enc , char const   *ptr , char const   *end ,
                             char const   **nextTokPtr ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 386
  if ((unsigned long )ptr == (unsigned long )end) {
#line 387
    return (-1);
  }
  {
#line 389
  if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 29) {
#line 389
    goto case_29;
  }
#line 389
  if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 24) {
#line 389
    goto case_24;
  }
#line 389
  if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 22) {
#line 389
    goto case_24;
  }
#line 389
  if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 5) {
#line 389
    goto case_5;
  }
#line 389
  if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 6) {
#line 389
    goto case_6;
  }
#line 389
  if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 7) {
#line 389
    goto case_7;
  }
#line 390
  goto switch_default;
  case_29: /* CIL Label */ 
#line 389
  *nextTokPtr = ptr;
#line 389
  return (0);
  case_24: /* CIL Label */ 
  case_22: /* CIL Label */ 
#line 389
  ptr ++;
#line 389
  goto switch_break;
  case_5: /* CIL Label */ 
#line 389
  if (end - ptr < 2L) {
#line 389
    return (-2);
  }
  {
#line 389
  tmp = (*(((struct normal_encoding  const  *)enc)->isNmstrt2))(enc, ptr);
  }
#line 389
  if (! tmp) {
#line 389
    *nextTokPtr = ptr;
#line 389
    return (0);
  }
#line 389
  ptr += 2;
#line 389
  goto switch_break;
  case_6: /* CIL Label */ 
#line 389
  if (end - ptr < 3L) {
#line 389
    return (-2);
  }
  {
#line 389
  tmp___0 = (*(((struct normal_encoding  const  *)enc)->isNmstrt3))(enc, ptr);
  }
#line 389
  if (! tmp___0) {
#line 389
    *nextTokPtr = ptr;
#line 389
    return (0);
  }
#line 389
  ptr += 3;
#line 389
  goto switch_break;
  case_7: /* CIL Label */ 
#line 389
  if (end - ptr < 4L) {
#line 389
    return (-2);
  }
  {
#line 389
  tmp___1 = (*(((struct normal_encoding  const  *)enc)->isNmstrt4))(enc, ptr);
  }
#line 389
  if (! tmp___1) {
#line 389
    *nextTokPtr = ptr;
#line 389
    return (0);
  }
#line 389
  ptr += 4;
#line 389
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 391
  *nextTokPtr = ptr;
#line 392
  return (0);
  switch_break: /* CIL Label */ ;
  }
  {
#line 394
  while (1) {
    while_continue: /* CIL Label */ ;
#line 394
    if (! ((unsigned long )ptr != (unsigned long )end)) {
#line 394
      goto while_break;
    }
    {
#line 396
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 29) {
#line 396
      goto case_29___0;
    }
#line 396
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 27) {
#line 396
      goto case_27;
    }
#line 396
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 26) {
#line 396
      goto case_27;
    }
#line 396
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 25) {
#line 396
      goto case_27;
    }
#line 396
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 24) {
#line 396
      goto case_27;
    }
#line 396
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 22) {
#line 396
      goto case_27;
    }
#line 396
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 5) {
#line 396
      goto case_5___0;
    }
#line 396
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 6) {
#line 396
      goto case_6___0;
    }
#line 396
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 7) {
#line 396
      goto case_7___0;
    }
#line 397
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 10) {
#line 397
      goto case_10;
    }
#line 397
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 9) {
#line 397
      goto case_10;
    }
#line 397
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 21) {
#line 397
      goto case_10;
    }
#line 412
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 23) {
#line 412
      goto case_23;
    }
#line 418
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 11) {
#line 418
      goto case_11___0;
    }
#line 421
    goto switch_default___1;
    case_29___0: /* CIL Label */ 
#line 396
    *nextTokPtr = ptr;
#line 396
    return (0);
    case_27: /* CIL Label */ 
    case_26: /* CIL Label */ 
    case_25: /* CIL Label */ 
    case_24___0: /* CIL Label */ 
    case_22___0: /* CIL Label */ 
#line 396
    ptr ++;
#line 396
    goto switch_break___0;
    case_5___0: /* CIL Label */ 
#line 396
    if (end - ptr < 2L) {
#line 396
      return (-2);
    }
    {
#line 396
    tmp___2 = (*(((struct normal_encoding  const  *)enc)->isName2))(enc, ptr);
    }
#line 396
    if (! tmp___2) {
#line 396
      *nextTokPtr = ptr;
#line 396
      return (0);
    }
#line 396
    ptr += 2;
#line 396
    goto switch_break___0;
    case_6___0: /* CIL Label */ 
#line 396
    if (end - ptr < 3L) {
#line 396
      return (-2);
    }
    {
#line 396
    tmp___3 = (*(((struct normal_encoding  const  *)enc)->isName3))(enc, ptr);
    }
#line 396
    if (! tmp___3) {
#line 396
      *nextTokPtr = ptr;
#line 396
      return (0);
    }
#line 396
    ptr += 3;
#line 396
    goto switch_break___0;
    case_7___0: /* CIL Label */ 
#line 396
    if (end - ptr < 4L) {
#line 396
      return (-2);
    }
    {
#line 396
    tmp___4 = (*(((struct normal_encoding  const  *)enc)->isName4))(enc, ptr);
    }
#line 396
    if (! tmp___4) {
#line 396
      *nextTokPtr = ptr;
#line 396
      return (0);
    }
#line 396
    ptr += 4;
#line 396
    goto switch_break___0;
    case_10: /* CIL Label */ 
    case_9: /* CIL Label */ 
    case_21: /* CIL Label */ 
#line 398
    ptr ++;
    {
#line 398
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 398
      if (! ((unsigned long )ptr != (unsigned long )end)) {
#line 398
        goto while_break___0;
      }
      {
#line 400
      if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 10) {
#line 400
        goto case_10___0;
      }
#line 400
      if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 9) {
#line 400
        goto case_10___0;
      }
#line 400
      if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 21) {
#line 400
        goto case_10___0;
      }
#line 402
      if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 11) {
#line 402
        goto case_11;
      }
#line 405
      goto switch_default___0;
      case_10___0: /* CIL Label */ 
      case_9___0: /* CIL Label */ 
      case_21___0: /* CIL Label */ 
#line 401
      goto switch_break___1;
      case_11: /* CIL Label */ 
#line 403
      *nextTokPtr = ptr + 1;
#line 404
      return (5);
      switch_default___0: /* CIL Label */ 
#line 406
      *nextTokPtr = ptr;
#line 407
      return (0);
      switch_break___1: /* CIL Label */ ;
      }
#line 398
      ptr ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 410
    return (-1);
    case_23: /* CIL Label */ 
#line 415
    ptr ++;
#line 416
    goto switch_break___0;
    case_11___0: /* CIL Label */ 
#line 419
    *nextTokPtr = ptr + 1;
#line 420
    return (5);
    switch_default___1: /* CIL Label */ 
#line 422
    *nextTokPtr = ptr;
#line 423
    return (0);
    switch_break___0: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 426
  return (-1);
}
}
#line 431 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmltok_impl.c"
static int normal_scanHexCharRef(ENCODING const   *enc , char const   *ptr , char const   *end ,
                                 char const   **nextTokPtr ) 
{ 


  {
#line 435
  if ((unsigned long )ptr != (unsigned long )end) {
    {
#line 438
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 24) {
#line 438
      goto case_24;
    }
#line 438
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 25) {
#line 438
      goto case_24;
    }
#line 440
    goto switch_default;
    case_24: /* CIL Label */ 
    case_25: /* CIL Label */ 
#line 439
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 441
    *nextTokPtr = ptr;
#line 442
    return (0);
    switch_break: /* CIL Label */ ;
    }
#line 444
    ptr ++;
    {
#line 444
    while (1) {
      while_continue: /* CIL Label */ ;
#line 444
      if (! ((unsigned long )ptr != (unsigned long )end)) {
#line 444
        goto while_break;
      }
      {
#line 447
      if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 24) {
#line 447
        goto case_24___0;
      }
#line 447
      if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 25) {
#line 447
        goto case_24___0;
      }
#line 449
      if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 18) {
#line 449
        goto case_18;
      }
#line 452
      goto switch_default___0;
      case_24___0: /* CIL Label */ 
      case_25___0: /* CIL Label */ 
#line 448
      goto switch_break___0;
      case_18: /* CIL Label */ 
#line 450
      *nextTokPtr = ptr + 1;
#line 451
      return (10);
      switch_default___0: /* CIL Label */ 
#line 453
      *nextTokPtr = ptr;
#line 454
      return (0);
      switch_break___0: /* CIL Label */ ;
      }
#line 444
      ptr ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 458
  return (-1);
}
}
#line 463 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmltok_impl.c"
static int normal_scanCharRef(ENCODING const   *enc , char const   *ptr , char const   *end ,
                              char const   **nextTokPtr ) 
{ 
  int tmp ;

  {
#line 467
  if ((unsigned long )ptr != (unsigned long )end) {
#line 468
    if ((int const   )*ptr == 120) {
      {
#line 469
      tmp = normal_scanHexCharRef(enc, ptr + 1, end, nextTokPtr);
      }
#line 469
      return (tmp);
    }
    {
#line 471
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 25) {
#line 471
      goto case_25;
    }
#line 473
    goto switch_default;
    case_25: /* CIL Label */ 
#line 472
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 474
    *nextTokPtr = ptr;
#line 475
    return (0);
    switch_break: /* CIL Label */ ;
    }
#line 477
    ptr ++;
    {
#line 477
    while (1) {
      while_continue: /* CIL Label */ ;
#line 477
      if (! ((unsigned long )ptr != (unsigned long )end)) {
#line 477
        goto while_break;
      }
      {
#line 479
      if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 25) {
#line 479
        goto case_25___0;
      }
#line 481
      if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 18) {
#line 481
        goto case_18;
      }
#line 484
      goto switch_default___0;
      case_25___0: /* CIL Label */ 
#line 480
      goto switch_break___0;
      case_18: /* CIL Label */ 
#line 482
      *nextTokPtr = ptr + 1;
#line 483
      return (10);
      switch_default___0: /* CIL Label */ 
#line 485
      *nextTokPtr = ptr;
#line 486
      return (0);
      switch_break___0: /* CIL Label */ ;
      }
#line 477
      ptr ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 490
  return (-1);
}
}
#line 495 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmltok_impl.c"
static int normal_scanRef(ENCODING const   *enc , char const   *ptr , char const   *end ,
                          char const   **nextTokPtr ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 499
  if ((unsigned long )ptr == (unsigned long )end) {
#line 500
    return (-1);
  }
  {
#line 502
  if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 29) {
#line 502
    goto case_29;
  }
#line 502
  if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 24) {
#line 502
    goto case_24;
  }
#line 502
  if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 22) {
#line 502
    goto case_24;
  }
#line 502
  if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 5) {
#line 502
    goto case_5;
  }
#line 502
  if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 6) {
#line 502
    goto case_6;
  }
#line 502
  if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 7) {
#line 502
    goto case_7;
  }
#line 503
  if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 19) {
#line 503
    goto case_19;
  }
#line 505
  goto switch_default;
  case_29: /* CIL Label */ 
#line 502
  *nextTokPtr = ptr;
#line 502
  return (0);
  case_24: /* CIL Label */ 
  case_22: /* CIL Label */ 
#line 502
  ptr ++;
#line 502
  goto switch_break;
  case_5: /* CIL Label */ 
#line 502
  if (end - ptr < 2L) {
#line 502
    return (-2);
  }
  {
#line 502
  tmp = (*(((struct normal_encoding  const  *)enc)->isNmstrt2))(enc, ptr);
  }
#line 502
  if (! tmp) {
#line 502
    *nextTokPtr = ptr;
#line 502
    return (0);
  }
#line 502
  ptr += 2;
#line 502
  goto switch_break;
  case_6: /* CIL Label */ 
#line 502
  if (end - ptr < 3L) {
#line 502
    return (-2);
  }
  {
#line 502
  tmp___0 = (*(((struct normal_encoding  const  *)enc)->isNmstrt3))(enc, ptr);
  }
#line 502
  if (! tmp___0) {
#line 502
    *nextTokPtr = ptr;
#line 502
    return (0);
  }
#line 502
  ptr += 3;
#line 502
  goto switch_break;
  case_7: /* CIL Label */ 
#line 502
  if (end - ptr < 4L) {
#line 502
    return (-2);
  }
  {
#line 502
  tmp___1 = (*(((struct normal_encoding  const  *)enc)->isNmstrt4))(enc, ptr);
  }
#line 502
  if (! tmp___1) {
#line 502
    *nextTokPtr = ptr;
#line 502
    return (0);
  }
#line 502
  ptr += 4;
#line 502
  goto switch_break;
  case_19: /* CIL Label */ 
  {
#line 504
  tmp___2 = normal_scanCharRef(enc, ptr + 1, end, nextTokPtr);
  }
#line 504
  return (tmp___2);
  switch_default: /* CIL Label */ 
#line 506
  *nextTokPtr = ptr;
#line 507
  return (0);
  switch_break: /* CIL Label */ ;
  }
  {
#line 509
  while (1) {
    while_continue: /* CIL Label */ ;
#line 509
    if (! ((unsigned long )ptr != (unsigned long )end)) {
#line 509
      goto while_break;
    }
    {
#line 511
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 29) {
#line 511
      goto case_29___0;
    }
#line 511
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 27) {
#line 511
      goto case_27;
    }
#line 511
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 26) {
#line 511
      goto case_27;
    }
#line 511
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 25) {
#line 511
      goto case_27;
    }
#line 511
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 24) {
#line 511
      goto case_27;
    }
#line 511
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 22) {
#line 511
      goto case_27;
    }
#line 511
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 5) {
#line 511
      goto case_5___0;
    }
#line 511
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 6) {
#line 511
      goto case_6___0;
    }
#line 511
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 7) {
#line 511
      goto case_7___0;
    }
#line 512
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 18) {
#line 512
      goto case_18;
    }
#line 515
    goto switch_default___0;
    case_29___0: /* CIL Label */ 
#line 511
    *nextTokPtr = ptr;
#line 511
    return (0);
    case_27: /* CIL Label */ 
    case_26: /* CIL Label */ 
    case_25: /* CIL Label */ 
    case_24___0: /* CIL Label */ 
    case_22___0: /* CIL Label */ 
#line 511
    ptr ++;
#line 511
    goto switch_break___0;
    case_5___0: /* CIL Label */ 
#line 511
    if (end - ptr < 2L) {
#line 511
      return (-2);
    }
    {
#line 511
    tmp___3 = (*(((struct normal_encoding  const  *)enc)->isName2))(enc, ptr);
    }
#line 511
    if (! tmp___3) {
#line 511
      *nextTokPtr = ptr;
#line 511
      return (0);
    }
#line 511
    ptr += 2;
#line 511
    goto switch_break___0;
    case_6___0: /* CIL Label */ 
#line 511
    if (end - ptr < 3L) {
#line 511
      return (-2);
    }
    {
#line 511
    tmp___4 = (*(((struct normal_encoding  const  *)enc)->isName3))(enc, ptr);
    }
#line 511
    if (! tmp___4) {
#line 511
      *nextTokPtr = ptr;
#line 511
      return (0);
    }
#line 511
    ptr += 3;
#line 511
    goto switch_break___0;
    case_7___0: /* CIL Label */ 
#line 511
    if (end - ptr < 4L) {
#line 511
      return (-2);
    }
    {
#line 511
    tmp___5 = (*(((struct normal_encoding  const  *)enc)->isName4))(enc, ptr);
    }
#line 511
    if (! tmp___5) {
#line 511
      *nextTokPtr = ptr;
#line 511
      return (0);
    }
#line 511
    ptr += 4;
#line 511
    goto switch_break___0;
    case_18: /* CIL Label */ 
#line 513
    *nextTokPtr = ptr + 1;
#line 514
    return (9);
    switch_default___0: /* CIL Label */ 
#line 516
    *nextTokPtr = ptr;
#line 517
    return (0);
    switch_break___0: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 520
  return (-1);
}
}
#line 525 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmltok_impl.c"
static int normal_scanAtts(ENCODING const   *enc , char const   *ptr , char const   *end ,
                           char const   **nextTokPtr ) 
{ 
  int hadColon ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int t ;
  int open___0 ;
  int t___0 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tok ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;

  {
#line 530
  hadColon = 0;
  {
#line 532
  while (1) {
    while_continue: /* CIL Label */ ;
#line 532
    if (! ((unsigned long )ptr != (unsigned long )end)) {
#line 532
      goto while_break;
    }
    {
#line 534
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 29) {
#line 534
      goto case_29;
    }
#line 534
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 27) {
#line 534
      goto case_27;
    }
#line 534
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 26) {
#line 534
      goto case_27;
    }
#line 534
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 25) {
#line 534
      goto case_27;
    }
#line 534
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 24) {
#line 534
      goto case_27;
    }
#line 534
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 22) {
#line 534
      goto case_27;
    }
#line 534
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 5) {
#line 534
      goto case_5;
    }
#line 534
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 6) {
#line 534
      goto case_6;
    }
#line 534
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 7) {
#line 534
      goto case_7;
    }
#line 536
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 23) {
#line 536
      goto case_23;
    }
#line 553
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 10) {
#line 553
      goto case_10;
    }
#line 553
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 9) {
#line 553
      goto case_10;
    }
#line 553
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 21) {
#line 553
      goto case_10;
    }
#line 574
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 14) {
#line 574
      goto case_14;
    }
#line 674
    goto switch_default___5;
    case_29: /* CIL Label */ 
#line 534
    *nextTokPtr = ptr;
#line 534
    return (0);
    case_27: /* CIL Label */ 
    case_26: /* CIL Label */ 
    case_25: /* CIL Label */ 
    case_24: /* CIL Label */ 
    case_22: /* CIL Label */ 
#line 534
    ptr ++;
#line 534
    goto switch_break;
    case_5: /* CIL Label */ 
#line 534
    if (end - ptr < 2L) {
#line 534
      return (-2);
    }
    {
#line 534
    tmp = (*(((struct normal_encoding  const  *)enc)->isName2))(enc, ptr);
    }
#line 534
    if (! tmp) {
#line 534
      *nextTokPtr = ptr;
#line 534
      return (0);
    }
#line 534
    ptr += 2;
#line 534
    goto switch_break;
    case_6: /* CIL Label */ 
#line 534
    if (end - ptr < 3L) {
#line 534
      return (-2);
    }
    {
#line 534
    tmp___0 = (*(((struct normal_encoding  const  *)enc)->isName3))(enc, ptr);
    }
#line 534
    if (! tmp___0) {
#line 534
      *nextTokPtr = ptr;
#line 534
      return (0);
    }
#line 534
    ptr += 3;
#line 534
    goto switch_break;
    case_7: /* CIL Label */ 
#line 534
    if (end - ptr < 4L) {
#line 534
      return (-2);
    }
    {
#line 534
    tmp___1 = (*(((struct normal_encoding  const  *)enc)->isName4))(enc, ptr);
    }
#line 534
    if (! tmp___1) {
#line 534
      *nextTokPtr = ptr;
#line 534
      return (0);
    }
#line 534
    ptr += 4;
#line 534
    goto switch_break;
    case_23: /* CIL Label */ 
#line 537
    if (hadColon) {
#line 538
      *nextTokPtr = ptr;
#line 539
      return (0);
    }
#line 541
    hadColon = 1;
#line 542
    ptr ++;
#line 543
    if ((unsigned long )ptr == (unsigned long )end) {
#line 544
      return (-1);
    }
    {
#line 546
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 29) {
#line 546
      goto case_29___0;
    }
#line 546
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 24) {
#line 546
      goto case_24___0;
    }
#line 546
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 22) {
#line 546
      goto case_24___0;
    }
#line 546
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 5) {
#line 546
      goto case_5___0;
    }
#line 546
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 6) {
#line 546
      goto case_6___0;
    }
#line 546
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 7) {
#line 546
      goto case_7___0;
    }
#line 547
    goto switch_default;
    case_29___0: /* CIL Label */ 
#line 546
    *nextTokPtr = ptr;
#line 546
    return (0);
    case_24___0: /* CIL Label */ 
    case_22___0: /* CIL Label */ 
#line 546
    ptr ++;
#line 546
    goto switch_break___0;
    case_5___0: /* CIL Label */ 
#line 546
    if (end - ptr < 2L) {
#line 546
      return (-2);
    }
    {
#line 546
    tmp___2 = (*(((struct normal_encoding  const  *)enc)->isNmstrt2))(enc, ptr);
    }
#line 546
    if (! tmp___2) {
#line 546
      *nextTokPtr = ptr;
#line 546
      return (0);
    }
#line 546
    ptr += 2;
#line 546
    goto switch_break___0;
    case_6___0: /* CIL Label */ 
#line 546
    if (end - ptr < 3L) {
#line 546
      return (-2);
    }
    {
#line 546
    tmp___3 = (*(((struct normal_encoding  const  *)enc)->isNmstrt3))(enc, ptr);
    }
#line 546
    if (! tmp___3) {
#line 546
      *nextTokPtr = ptr;
#line 546
      return (0);
    }
#line 546
    ptr += 3;
#line 546
    goto switch_break___0;
    case_7___0: /* CIL Label */ 
#line 546
    if (end - ptr < 4L) {
#line 546
      return (-2);
    }
    {
#line 546
    tmp___4 = (*(((struct normal_encoding  const  *)enc)->isNmstrt4))(enc, ptr);
    }
#line 546
    if (! tmp___4) {
#line 546
      *nextTokPtr = ptr;
#line 546
      return (0);
    }
#line 546
    ptr += 4;
#line 546
    goto switch_break___0;
    switch_default: /* CIL Label */ 
#line 548
    *nextTokPtr = ptr;
#line 549
    return (0);
    switch_break___0: /* CIL Label */ ;
    }
#line 551
    goto switch_break;
    case_10: /* CIL Label */ 
    case_9: /* CIL Label */ 
    case_21: /* CIL Label */ 
    {
#line 554
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 557
      ptr ++;
#line 558
      if ((unsigned long )ptr == (unsigned long )end) {
#line 559
        return (-1);
      }
#line 560
      t = (int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr];
#line 561
      if (t == 14) {
#line 562
        goto while_break___0;
      }
      {
#line 566
      if (t == 9) {
#line 566
        goto case_9___0;
      }
#line 566
      if (t == 10) {
#line 566
        goto case_9___0;
      }
#line 566
      if (t == 21) {
#line 566
        goto case_9___0;
      }
#line 568
      goto switch_default___0;
      case_9___0: /* CIL Label */ 
      case_10___0: /* CIL Label */ 
      case_21___0: /* CIL Label */ 
#line 567
      goto switch_break___1;
      switch_default___0: /* CIL Label */ 
#line 569
      *nextTokPtr = ptr;
#line 570
      return (0);
      switch_break___1: /* CIL Label */ ;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    case_14: /* CIL Label */ 
#line 578
    hadColon = 0;
    {
#line 580
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 581
      ptr ++;
#line 582
      if ((unsigned long )ptr == (unsigned long )end) {
#line 583
        return (-1);
      }
#line 584
      open___0 = (int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr];
#line 585
      if (open___0 == 12) {
#line 586
        goto while_break___1;
      } else
#line 585
      if (open___0 == 13) {
#line 586
        goto while_break___1;
      }
      {
#line 590
      if (open___0 == 9) {
#line 590
        goto case_9___1;
      }
#line 590
      if (open___0 == 10) {
#line 590
        goto case_9___1;
      }
#line 590
      if (open___0 == 21) {
#line 590
        goto case_9___1;
      }
#line 592
      goto switch_default___1;
      case_9___1: /* CIL Label */ 
      case_10___1: /* CIL Label */ 
      case_21___1: /* CIL Label */ 
#line 591
      goto switch_break___2;
      switch_default___1: /* CIL Label */ 
#line 593
      *nextTokPtr = ptr;
#line 594
      return (0);
      switch_break___2: /* CIL Label */ ;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
#line 597
    ptr ++;
    {
#line 599
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 601
      if ((unsigned long )ptr == (unsigned long )end) {
#line 602
        return (-1);
      }
#line 603
      t___0 = (int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr];
#line 604
      if (t___0 == open___0) {
#line 605
        goto while_break___2;
      }
      {
#line 607
      if (t___0 == 5) {
#line 607
        goto case_5___1;
      }
#line 607
      if (t___0 == 6) {
#line 607
        goto case_6___1;
      }
#line 607
      if (t___0 == 7) {
#line 607
        goto case_7___1;
      }
#line 607
      if (t___0 == 8) {
#line 607
        goto case_8;
      }
#line 607
      if (t___0 == 1) {
#line 607
        goto case_8;
      }
#line 607
      if (t___0 == 0) {
#line 607
        goto case_8;
      }
#line 608
      if (t___0 == 3) {
#line 608
        goto case_3;
      }
#line 618
      if (t___0 == 2) {
#line 618
        goto case_2;
      }
#line 621
      goto switch_default___2;
      case_5___1: /* CIL Label */ 
#line 607
      if (end - ptr < 2L) {
#line 607
        return (-2);
      }
      {
#line 607
      tmp___5 = (*(((struct normal_encoding  const  *)enc)->isInvalid2))(enc, ptr);
      }
#line 607
      if (tmp___5) {
#line 607
        *nextTokPtr = ptr;
#line 607
        return (0);
      }
#line 607
      ptr += 2;
#line 607
      goto switch_break___3;
      case_6___1: /* CIL Label */ 
#line 607
      if (end - ptr < 3L) {
#line 607
        return (-2);
      }
      {
#line 607
      tmp___6 = (*(((struct normal_encoding  const  *)enc)->isInvalid3))(enc, ptr);
      }
#line 607
      if (tmp___6) {
#line 607
        *nextTokPtr = ptr;
#line 607
        return (0);
      }
#line 607
      ptr += 3;
#line 607
      goto switch_break___3;
      case_7___1: /* CIL Label */ 
#line 607
      if (end - ptr < 4L) {
#line 607
        return (-2);
      }
      {
#line 607
      tmp___7 = (*(((struct normal_encoding  const  *)enc)->isInvalid4))(enc, ptr);
      }
#line 607
      if (tmp___7) {
#line 607
        *nextTokPtr = ptr;
#line 607
        return (0);
      }
#line 607
      ptr += 4;
#line 607
      goto switch_break___3;
      case_8: /* CIL Label */ 
      case_1: /* CIL Label */ 
      case_0: /* CIL Label */ 
#line 607
      *nextTokPtr = ptr;
#line 607
      return (0);
      case_3: /* CIL Label */ 
      {
#line 610
      tmp___8 = normal_scanRef(enc, ptr + 1, end, & ptr);
#line 610
      tok = tmp___8;
      }
#line 611
      if (tok <= 0) {
#line 612
        if (tok == 0) {
#line 613
          *nextTokPtr = ptr;
        }
#line 614
        return (tok);
      }
#line 616
      goto switch_break___3;
      case_2: /* CIL Label */ 
#line 619
      *nextTokPtr = ptr;
#line 620
      return (0);
      switch_default___2: /* CIL Label */ 
#line 622
      ptr ++;
#line 623
      goto switch_break___3;
      switch_break___3: /* CIL Label */ ;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
#line 626
    ptr ++;
#line 627
    if ((unsigned long )ptr == (unsigned long )end) {
#line 628
      return (-1);
    }
    {
#line 632
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 10) {
#line 632
      goto case_10___2;
    }
#line 632
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 9) {
#line 632
      goto case_10___2;
    }
#line 632
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 21) {
#line 632
      goto case_10___2;
    }
#line 634
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 17) {
#line 634
      goto case_17;
    }
#line 636
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 11) {
#line 636
      goto case_11;
    }
#line 638
    goto switch_default___3;
    case_10___2: /* CIL Label */ 
    case_9___2: /* CIL Label */ 
    case_21___2: /* CIL Label */ 
#line 633
    goto switch_break___4;
    case_17: /* CIL Label */ 
#line 635
    goto sol;
    case_11: /* CIL Label */ 
#line 637
    goto gt;
    switch_default___3: /* CIL Label */ 
#line 639
    *nextTokPtr = ptr;
#line 640
    return (0);
    switch_break___4: /* CIL Label */ ;
    }
    {
#line 643
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 644
      ptr ++;
#line 645
      if ((unsigned long )ptr == (unsigned long )end) {
#line 646
        return (-1);
      }
      {
#line 648
      if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 29) {
#line 648
        goto case_29___1;
      }
#line 648
      if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 24) {
#line 648
        goto case_24___1;
      }
#line 648
      if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 22) {
#line 648
        goto case_24___1;
      }
#line 648
      if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 5) {
#line 648
        goto case_5___2;
      }
#line 648
      if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 6) {
#line 648
        goto case_6___2;
      }
#line 648
      if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 7) {
#line 648
        goto case_7___2;
      }
#line 649
      if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 10) {
#line 649
        goto case_10___3;
      }
#line 649
      if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 9) {
#line 649
        goto case_10___3;
      }
#line 649
      if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 21) {
#line 649
        goto case_10___3;
      }
#line 651
      if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 11) {
#line 651
        goto gt;
      }
#line 655
      if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 17) {
#line 655
        goto sol;
      }
#line 666
      goto switch_default___4;
      case_29___1: /* CIL Label */ 
#line 648
      *nextTokPtr = ptr;
#line 648
      return (0);
      case_24___1: /* CIL Label */ 
      case_22___1: /* CIL Label */ 
#line 648
      ptr ++;
#line 648
      goto switch_break___5;
      case_5___2: /* CIL Label */ 
#line 648
      if (end - ptr < 2L) {
#line 648
        return (-2);
      }
      {
#line 648
      tmp___9 = (*(((struct normal_encoding  const  *)enc)->isNmstrt2))(enc, ptr);
      }
#line 648
      if (! tmp___9) {
#line 648
        *nextTokPtr = ptr;
#line 648
        return (0);
      }
#line 648
      ptr += 2;
#line 648
      goto switch_break___5;
      case_6___2: /* CIL Label */ 
#line 648
      if (end - ptr < 3L) {
#line 648
        return (-2);
      }
      {
#line 648
      tmp___10 = (*(((struct normal_encoding  const  *)enc)->isNmstrt3))(enc, ptr);
      }
#line 648
      if (! tmp___10) {
#line 648
        *nextTokPtr = ptr;
#line 648
        return (0);
      }
#line 648
      ptr += 3;
#line 648
      goto switch_break___5;
      case_7___2: /* CIL Label */ 
#line 648
      if (end - ptr < 4L) {
#line 648
        return (-2);
      }
      {
#line 648
      tmp___11 = (*(((struct normal_encoding  const  *)enc)->isNmstrt4))(enc, ptr);
      }
#line 648
      if (! tmp___11) {
#line 648
        *nextTokPtr = ptr;
#line 648
        return (0);
      }
#line 648
      ptr += 4;
#line 648
      goto switch_break___5;
      case_10___3: /* CIL Label */ 
      case_9___3: /* CIL Label */ 
      case_21___3: /* CIL Label */ 
#line 650
      goto __Cont;
      gt: 
      case_11___0: /* CIL Label */ 
#line 653
      *nextTokPtr = ptr + 1;
#line 654
      return (1);
      sol: 
      case_17___0: /* CIL Label */ 
#line 657
      ptr ++;
#line 658
      if ((unsigned long )ptr == (unsigned long )end) {
#line 659
        return (-1);
      }
#line 660
      if (! ((int const   )*ptr == 62)) {
#line 661
        *nextTokPtr = ptr;
#line 662
        return (0);
      }
#line 664
      *nextTokPtr = ptr + 1;
#line 665
      return (3);
      switch_default___4: /* CIL Label */ 
#line 667
      *nextTokPtr = ptr;
#line 668
      return (0);
      switch_break___5: /* CIL Label */ ;
      }
#line 670
      goto while_break___3;
      __Cont: /* CIL Label */ ;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 672
    goto switch_break;
    switch_default___5: /* CIL Label */ 
#line 675
    *nextTokPtr = ptr;
#line 676
    return (0);
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 679
  return (-1);
}
}
#line 684 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmltok_impl.c"
static int normal_scanLt(ENCODING const   *enc , char const   *ptr , char const   *end ,
                         char const   **nextTokPtr ) 
{ 
  int hadColon ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;

  {
#line 691
  if ((unsigned long )ptr == (unsigned long )end) {
#line 692
    return (-1);
  }
  {
#line 694
  if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 29) {
#line 694
    goto case_29;
  }
#line 694
  if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 24) {
#line 694
    goto case_24;
  }
#line 694
  if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 22) {
#line 694
    goto case_24;
  }
#line 694
  if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 5) {
#line 694
    goto case_5;
  }
#line 694
  if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 6) {
#line 694
    goto case_6;
  }
#line 694
  if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 7) {
#line 694
    goto case_7;
  }
#line 695
  if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 16) {
#line 695
    goto case_16;
  }
#line 707
  if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 15) {
#line 707
    goto case_15;
  }
#line 709
  if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 17) {
#line 709
    goto case_17;
  }
#line 711
  goto switch_default;
  case_29: /* CIL Label */ 
#line 694
  *nextTokPtr = ptr;
#line 694
  return (0);
  case_24: /* CIL Label */ 
  case_22: /* CIL Label */ 
#line 694
  ptr ++;
#line 694
  goto switch_break;
  case_5: /* CIL Label */ 
#line 694
  if (end - ptr < 2L) {
#line 694
    return (-2);
  }
  {
#line 694
  tmp = (*(((struct normal_encoding  const  *)enc)->isNmstrt2))(enc, ptr);
  }
#line 694
  if (! tmp) {
#line 694
    *nextTokPtr = ptr;
#line 694
    return (0);
  }
#line 694
  ptr += 2;
#line 694
  goto switch_break;
  case_6: /* CIL Label */ 
#line 694
  if (end - ptr < 3L) {
#line 694
    return (-2);
  }
  {
#line 694
  tmp___0 = (*(((struct normal_encoding  const  *)enc)->isNmstrt3))(enc, ptr);
  }
#line 694
  if (! tmp___0) {
#line 694
    *nextTokPtr = ptr;
#line 694
    return (0);
  }
#line 694
  ptr += 3;
#line 694
  goto switch_break;
  case_7: /* CIL Label */ 
#line 694
  if (end - ptr < 4L) {
#line 694
    return (-2);
  }
  {
#line 694
  tmp___1 = (*(((struct normal_encoding  const  *)enc)->isNmstrt4))(enc, ptr);
  }
#line 694
  if (! tmp___1) {
#line 694
    *nextTokPtr = ptr;
#line 694
    return (0);
  }
#line 694
  ptr += 4;
#line 694
  goto switch_break;
  case_16: /* CIL Label */ 
#line 696
  ptr ++;
#line 696
  if ((unsigned long )ptr == (unsigned long )end) {
#line 697
    return (-1);
  }
  {
#line 699
  if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 27) {
#line 699
    goto case_27;
  }
#line 701
  if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 20) {
#line 701
    goto case_20;
  }
#line 698
  goto switch_break___0;
  case_27: /* CIL Label */ 
  {
#line 700
  tmp___2 = normal_scanComment(enc, ptr + 1, end, nextTokPtr);
  }
#line 700
  return (tmp___2);
  case_20: /* CIL Label */ 
  {
#line 702
  tmp___3 = normal_scanCdataSection(enc, ptr + 1, end, nextTokPtr);
  }
#line 702
  return (tmp___3);
  switch_break___0: /* CIL Label */ ;
  }
#line 705
  *nextTokPtr = ptr;
#line 706
  return (0);
  case_15: /* CIL Label */ 
  {
#line 708
  tmp___4 = normal_scanPi(enc, ptr + 1, end, nextTokPtr);
  }
#line 708
  return (tmp___4);
  case_17: /* CIL Label */ 
  {
#line 710
  tmp___5 = normal_scanEndTag(enc, ptr + 1, end, nextTokPtr);
  }
#line 710
  return (tmp___5);
  switch_default: /* CIL Label */ 
#line 712
  *nextTokPtr = ptr;
#line 713
  return (0);
  switch_break: /* CIL Label */ ;
  }
#line 716
  hadColon = 0;
  {
#line 719
  while (1) {
    while_continue: /* CIL Label */ ;
#line 719
    if (! ((unsigned long )ptr != (unsigned long )end)) {
#line 719
      goto while_break;
    }
    {
#line 721
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 29) {
#line 721
      goto case_29___0;
    }
#line 721
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 27) {
#line 721
      goto case_27___0;
    }
#line 721
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 26) {
#line 721
      goto case_27___0;
    }
#line 721
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 25) {
#line 721
      goto case_27___0;
    }
#line 721
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 24) {
#line 721
      goto case_27___0;
    }
#line 721
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 22) {
#line 721
      goto case_27___0;
    }
#line 721
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 5) {
#line 721
      goto case_5___0;
    }
#line 721
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 6) {
#line 721
      goto case_6___0;
    }
#line 721
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 7) {
#line 721
      goto case_7___0;
    }
#line 723
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 23) {
#line 723
      goto case_23;
    }
#line 740
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 10) {
#line 740
      goto case_10;
    }
#line 740
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 9) {
#line 740
      goto case_10;
    }
#line 740
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 21) {
#line 740
      goto case_10;
    }
#line 761
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 11) {
#line 761
      goto gt;
    }
#line 765
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 17) {
#line 765
      goto sol;
    }
#line 776
    goto switch_default___2;
    case_29___0: /* CIL Label */ 
#line 721
    *nextTokPtr = ptr;
#line 721
    return (0);
    case_27___0: /* CIL Label */ 
    case_26: /* CIL Label */ 
    case_25: /* CIL Label */ 
    case_24___0: /* CIL Label */ 
    case_22___0: /* CIL Label */ 
#line 721
    ptr ++;
#line 721
    goto switch_break___1;
    case_5___0: /* CIL Label */ 
#line 721
    if (end - ptr < 2L) {
#line 721
      return (-2);
    }
    {
#line 721
    tmp___6 = (*(((struct normal_encoding  const  *)enc)->isName2))(enc, ptr);
    }
#line 721
    if (! tmp___6) {
#line 721
      *nextTokPtr = ptr;
#line 721
      return (0);
    }
#line 721
    ptr += 2;
#line 721
    goto switch_break___1;
    case_6___0: /* CIL Label */ 
#line 721
    if (end - ptr < 3L) {
#line 721
      return (-2);
    }
    {
#line 721
    tmp___7 = (*(((struct normal_encoding  const  *)enc)->isName3))(enc, ptr);
    }
#line 721
    if (! tmp___7) {
#line 721
      *nextTokPtr = ptr;
#line 721
      return (0);
    }
#line 721
    ptr += 3;
#line 721
    goto switch_break___1;
    case_7___0: /* CIL Label */ 
#line 721
    if (end - ptr < 4L) {
#line 721
      return (-2);
    }
    {
#line 721
    tmp___8 = (*(((struct normal_encoding  const  *)enc)->isName4))(enc, ptr);
    }
#line 721
    if (! tmp___8) {
#line 721
      *nextTokPtr = ptr;
#line 721
      return (0);
    }
#line 721
    ptr += 4;
#line 721
    goto switch_break___1;
    case_23: /* CIL Label */ 
#line 724
    if (hadColon) {
#line 725
      *nextTokPtr = ptr;
#line 726
      return (0);
    }
#line 728
    hadColon = 1;
#line 729
    ptr ++;
#line 730
    if ((unsigned long )ptr == (unsigned long )end) {
#line 731
      return (-1);
    }
    {
#line 733
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 29) {
#line 733
      goto case_29___1;
    }
#line 733
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 24) {
#line 733
      goto case_24___1;
    }
#line 733
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 22) {
#line 733
      goto case_24___1;
    }
#line 733
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 5) {
#line 733
      goto case_5___1;
    }
#line 733
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 6) {
#line 733
      goto case_6___1;
    }
#line 733
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 7) {
#line 733
      goto case_7___1;
    }
#line 734
    goto switch_default___0;
    case_29___1: /* CIL Label */ 
#line 733
    *nextTokPtr = ptr;
#line 733
    return (0);
    case_24___1: /* CIL Label */ 
    case_22___1: /* CIL Label */ 
#line 733
    ptr ++;
#line 733
    goto switch_break___2;
    case_5___1: /* CIL Label */ 
#line 733
    if (end - ptr < 2L) {
#line 733
      return (-2);
    }
    {
#line 733
    tmp___9 = (*(((struct normal_encoding  const  *)enc)->isNmstrt2))(enc, ptr);
    }
#line 733
    if (! tmp___9) {
#line 733
      *nextTokPtr = ptr;
#line 733
      return (0);
    }
#line 733
    ptr += 2;
#line 733
    goto switch_break___2;
    case_6___1: /* CIL Label */ 
#line 733
    if (end - ptr < 3L) {
#line 733
      return (-2);
    }
    {
#line 733
    tmp___10 = (*(((struct normal_encoding  const  *)enc)->isNmstrt3))(enc, ptr);
    }
#line 733
    if (! tmp___10) {
#line 733
      *nextTokPtr = ptr;
#line 733
      return (0);
    }
#line 733
    ptr += 3;
#line 733
    goto switch_break___2;
    case_7___1: /* CIL Label */ 
#line 733
    if (end - ptr < 4L) {
#line 733
      return (-2);
    }
    {
#line 733
    tmp___11 = (*(((struct normal_encoding  const  *)enc)->isNmstrt4))(enc, ptr);
    }
#line 733
    if (! tmp___11) {
#line 733
      *nextTokPtr = ptr;
#line 733
      return (0);
    }
#line 733
    ptr += 4;
#line 733
    goto switch_break___2;
    switch_default___0: /* CIL Label */ 
#line 735
    *nextTokPtr = ptr;
#line 736
    return (0);
    switch_break___2: /* CIL Label */ ;
    }
#line 738
    goto switch_break___1;
    case_10: /* CIL Label */ 
    case_9: /* CIL Label */ 
    case_21: /* CIL Label */ 
#line 742
    ptr ++;
    {
#line 743
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 743
      if (! ((unsigned long )ptr != (unsigned long )end)) {
#line 743
        goto while_break___0;
      }
      {
#line 745
      if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 29) {
#line 745
        goto case_29___2;
      }
#line 745
      if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 24) {
#line 745
        goto case_24___2;
      }
#line 745
      if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 22) {
#line 745
        goto case_24___2;
      }
#line 745
      if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 5) {
#line 745
        goto case_5___2;
      }
#line 745
      if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 6) {
#line 745
        goto case_6___2;
      }
#line 745
      if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 7) {
#line 745
        goto case_7___2;
      }
#line 746
      if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 11) {
#line 746
        goto case_11;
      }
#line 748
      if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 17) {
#line 748
        goto case_17___0;
      }
#line 750
      if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 10) {
#line 750
        goto case_10___0;
      }
#line 750
      if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 9) {
#line 750
        goto case_10___0;
      }
#line 750
      if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 21) {
#line 750
        goto case_10___0;
      }
#line 753
      goto switch_default___1;
      case_29___2: /* CIL Label */ 
#line 745
      *nextTokPtr = ptr;
#line 745
      return (0);
      case_24___2: /* CIL Label */ 
      case_22___2: /* CIL Label */ 
#line 745
      ptr ++;
#line 745
      goto switch_break___3;
      case_5___2: /* CIL Label */ 
#line 745
      if (end - ptr < 2L) {
#line 745
        return (-2);
      }
      {
#line 745
      tmp___12 = (*(((struct normal_encoding  const  *)enc)->isNmstrt2))(enc, ptr);
      }
#line 745
      if (! tmp___12) {
#line 745
        *nextTokPtr = ptr;
#line 745
        return (0);
      }
#line 745
      ptr += 2;
#line 745
      goto switch_break___3;
      case_6___2: /* CIL Label */ 
#line 745
      if (end - ptr < 3L) {
#line 745
        return (-2);
      }
      {
#line 745
      tmp___13 = (*(((struct normal_encoding  const  *)enc)->isNmstrt3))(enc, ptr);
      }
#line 745
      if (! tmp___13) {
#line 745
        *nextTokPtr = ptr;
#line 745
        return (0);
      }
#line 745
      ptr += 3;
#line 745
      goto switch_break___3;
      case_7___2: /* CIL Label */ 
#line 745
      if (end - ptr < 4L) {
#line 745
        return (-2);
      }
      {
#line 745
      tmp___14 = (*(((struct normal_encoding  const  *)enc)->isNmstrt4))(enc, ptr);
      }
#line 745
      if (! tmp___14) {
#line 745
        *nextTokPtr = ptr;
#line 745
        return (0);
      }
#line 745
      ptr += 4;
#line 745
      goto switch_break___3;
      case_11: /* CIL Label */ 
#line 747
      goto gt;
      case_17___0: /* CIL Label */ 
#line 749
      goto sol;
      case_10___0: /* CIL Label */ 
      case_9___0: /* CIL Label */ 
      case_21___0: /* CIL Label */ 
#line 751
      ptr ++;
#line 752
      goto while_continue___0;
      switch_default___1: /* CIL Label */ 
#line 754
      *nextTokPtr = ptr;
#line 755
      return (0);
      switch_break___3: /* CIL Label */ ;
      }
      {
#line 757
      tmp___15 = normal_scanAtts(enc, ptr, end, nextTokPtr);
      }
#line 757
      return (tmp___15);
    }
    while_break___0: /* CIL Label */ ;
    }
#line 759
    return (-1);
    gt: 
    case_11___0: /* CIL Label */ 
#line 763
    *nextTokPtr = ptr + 1;
#line 764
    return (2);
    sol: 
    case_17___1: /* CIL Label */ 
#line 767
    ptr ++;
#line 768
    if ((unsigned long )ptr == (unsigned long )end) {
#line 769
      return (-1);
    }
#line 770
    if (! ((int const   )*ptr == 62)) {
#line 771
      *nextTokPtr = ptr;
#line 772
      return (0);
    }
#line 774
    *nextTokPtr = ptr + 1;
#line 775
    return (4);
    switch_default___2: /* CIL Label */ 
#line 777
    *nextTokPtr = ptr;
#line 778
    return (0);
    switch_break___1: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 781
  return (-1);
}
}
#line 784 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmltok_impl.c"
static int normal_contentTok(ENCODING const   *enc , char const   *ptr , char const   *end ,
                             char const   **nextTokPtr ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
#line 788
  if ((unsigned long )ptr == (unsigned long )end) {
#line 789
    return (-4);
  }
  {
#line 800
  if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 2) {
#line 800
    goto case_2;
  }
#line 802
  if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 3) {
#line 802
    goto case_3;
  }
#line 804
  if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 9) {
#line 804
    goto case_9;
  }
#line 812
  if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 10) {
#line 812
    goto case_10;
  }
#line 815
  if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 4) {
#line 815
    goto case_4;
  }
#line 830
  if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 5) {
#line 830
    goto case_5;
  }
#line 830
  if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 6) {
#line 830
    goto case_6;
  }
#line 830
  if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 7) {
#line 830
    goto case_7;
  }
#line 830
  if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 8) {
#line 830
    goto case_8;
  }
#line 830
  if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 1) {
#line 830
    goto case_8;
  }
#line 830
  if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 0) {
#line 830
    goto case_8;
  }
#line 831
  goto switch_default;
  case_2: /* CIL Label */ 
  {
#line 801
  tmp = normal_scanLt(enc, ptr + 1, end, nextTokPtr);
  }
#line 801
  return (tmp);
  case_3: /* CIL Label */ 
  {
#line 803
  tmp___0 = normal_scanRef(enc, ptr + 1, end, nextTokPtr);
  }
#line 803
  return (tmp___0);
  case_9: /* CIL Label */ 
#line 805
  ptr ++;
#line 806
  if ((unsigned long )ptr == (unsigned long )end) {
#line 807
    return (-3);
  }
#line 808
  if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 10) {
#line 809
    ptr ++;
  }
#line 810
  *nextTokPtr = ptr;
#line 811
  return (7);
  case_10: /* CIL Label */ 
#line 813
  *nextTokPtr = ptr + 1;
#line 814
  return (7);
  case_4: /* CIL Label */ 
#line 816
  ptr ++;
#line 817
  if ((unsigned long )ptr == (unsigned long )end) {
#line 818
    return (-5);
  }
#line 819
  if (! ((int const   )*ptr == 93)) {
#line 820
    goto switch_break;
  }
#line 821
  ptr ++;
#line 822
  if ((unsigned long )ptr == (unsigned long )end) {
#line 823
    return (-5);
  }
#line 824
  if (! ((int const   )*ptr == 62)) {
#line 825
    ptr --;
#line 826
    goto switch_break;
  }
#line 828
  *nextTokPtr = ptr;
#line 829
  return (0);
  case_5: /* CIL Label */ 
#line 830
  if (end - ptr < 2L) {
#line 830
    return (-2);
  }
  {
#line 830
  tmp___1 = (*(((struct normal_encoding  const  *)enc)->isInvalid2))(enc, ptr);
  }
#line 830
  if (tmp___1) {
#line 830
    *nextTokPtr = ptr;
#line 830
    return (0);
  }
#line 830
  ptr += 2;
#line 830
  goto switch_break;
  case_6: /* CIL Label */ 
#line 830
  if (end - ptr < 3L) {
#line 830
    return (-2);
  }
  {
#line 830
  tmp___2 = (*(((struct normal_encoding  const  *)enc)->isInvalid3))(enc, ptr);
  }
#line 830
  if (tmp___2) {
#line 830
    *nextTokPtr = ptr;
#line 830
    return (0);
  }
#line 830
  ptr += 3;
#line 830
  goto switch_break;
  case_7: /* CIL Label */ 
#line 830
  if (end - ptr < 4L) {
#line 830
    return (-2);
  }
  {
#line 830
  tmp___3 = (*(((struct normal_encoding  const  *)enc)->isInvalid4))(enc, ptr);
  }
#line 830
  if (tmp___3) {
#line 830
    *nextTokPtr = ptr;
#line 830
    return (0);
  }
#line 830
  ptr += 4;
#line 830
  goto switch_break;
  case_8: /* CIL Label */ 
  case_1: /* CIL Label */ 
  case_0: /* CIL Label */ 
#line 830
  *nextTokPtr = ptr;
#line 830
  return (0);
  switch_default: /* CIL Label */ 
#line 832
  ptr ++;
#line 833
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 835
  while (1) {
    while_continue: /* CIL Label */ ;
#line 835
    if (! ((unsigned long )ptr != (unsigned long )end)) {
#line 835
      goto while_break;
    }
    {
#line 845
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 5) {
#line 845
      goto case_5___0;
    }
#line 845
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 6) {
#line 845
      goto case_6___0;
    }
#line 845
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 7) {
#line 845
      goto case_7___0;
    }
#line 847
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 4) {
#line 847
      goto case_4___0;
    }
#line 869
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 10) {
#line 869
      goto case_10___0;
    }
#line 869
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 9) {
#line 869
      goto case_10___0;
    }
#line 869
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 8) {
#line 869
      goto case_10___0;
    }
#line 869
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 1) {
#line 869
      goto case_10___0;
    }
#line 869
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 0) {
#line 869
      goto case_10___0;
    }
#line 869
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 2) {
#line 869
      goto case_10___0;
    }
#line 869
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 3) {
#line 869
      goto case_10___0;
    }
#line 872
    goto switch_default___0;
    case_5___0: /* CIL Label */ 
#line 845
    if (end - ptr < 2L) {
#line 845
      *nextTokPtr = ptr;
#line 845
      return (6);
    } else {
      {
#line 845
      tmp___4 = (*(((struct normal_encoding  const  *)enc)->isInvalid2))(enc, ptr);
      }
#line 845
      if (tmp___4) {
#line 845
        *nextTokPtr = ptr;
#line 845
        return (6);
      }
    }
#line 845
    ptr += 2;
#line 845
    goto switch_break___0;
    case_6___0: /* CIL Label */ 
#line 845
    if (end - ptr < 3L) {
#line 845
      *nextTokPtr = ptr;
#line 845
      return (6);
    } else {
      {
#line 845
      tmp___5 = (*(((struct normal_encoding  const  *)enc)->isInvalid3))(enc, ptr);
      }
#line 845
      if (tmp___5) {
#line 845
        *nextTokPtr = ptr;
#line 845
        return (6);
      }
    }
#line 845
    ptr += 3;
#line 845
    goto switch_break___0;
    case_7___0: /* CIL Label */ 
#line 845
    if (end - ptr < 4L) {
#line 845
      *nextTokPtr = ptr;
#line 845
      return (6);
    } else {
      {
#line 845
      tmp___6 = (*(((struct normal_encoding  const  *)enc)->isInvalid4))(enc, ptr);
      }
#line 845
      if (tmp___6) {
#line 845
        *nextTokPtr = ptr;
#line 845
        return (6);
      }
    }
#line 845
    ptr += 4;
#line 845
    goto switch_break___0;
    case_4___0: /* CIL Label */ 
#line 848
    if ((unsigned long )(ptr + 1) != (unsigned long )end) {
#line 849
      if (! ((int const   )*(ptr + 1) == 93)) {
#line 850
        ptr ++;
#line 851
        goto switch_break___0;
      }
#line 853
      if ((unsigned long )(ptr + 2) != (unsigned long )end) {
#line 854
        if (! ((int const   )*(ptr + 2) == 62)) {
#line 855
          ptr ++;
#line 856
          goto switch_break___0;
        }
#line 858
        *nextTokPtr = ptr + 2;
#line 859
        return (0);
      }
    }
    case_10___0: /* CIL Label */ 
    case_9___0: /* CIL Label */ 
    case_8___0: /* CIL Label */ 
    case_1___0: /* CIL Label */ 
    case_0___0: /* CIL Label */ 
    case_2___0: /* CIL Label */ 
    case_3___0: /* CIL Label */ 
#line 870
    *nextTokPtr = ptr;
#line 871
    return (6);
    switch_default___0: /* CIL Label */ 
#line 873
    ptr ++;
#line 874
    goto switch_break___0;
    switch_break___0: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 877
  *nextTokPtr = ptr;
#line 878
  return (6);
}
}
#line 883 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmltok_impl.c"
static int normal_scanPercent(ENCODING const   *enc , char const   *ptr , char const   *end ,
                              char const   **nextTokPtr ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 887
  if ((unsigned long )ptr == (unsigned long )end) {
#line 888
    return (-1);
  }
  {
#line 890
  if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 29) {
#line 890
    goto case_29;
  }
#line 890
  if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 24) {
#line 890
    goto case_24;
  }
#line 890
  if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 22) {
#line 890
    goto case_24;
  }
#line 890
  if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 5) {
#line 890
    goto case_5;
  }
#line 890
  if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 6) {
#line 890
    goto case_6;
  }
#line 890
  if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 7) {
#line 890
    goto case_7;
  }
#line 891
  if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 30) {
#line 891
    goto case_30;
  }
#line 891
  if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 9) {
#line 891
    goto case_30;
  }
#line 891
  if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 10) {
#line 891
    goto case_30;
  }
#line 891
  if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 21) {
#line 891
    goto case_30;
  }
#line 894
  goto switch_default;
  case_29: /* CIL Label */ 
#line 890
  *nextTokPtr = ptr;
#line 890
  return (0);
  case_24: /* CIL Label */ 
  case_22: /* CIL Label */ 
#line 890
  ptr ++;
#line 890
  goto switch_break;
  case_5: /* CIL Label */ 
#line 890
  if (end - ptr < 2L) {
#line 890
    return (-2);
  }
  {
#line 890
  tmp = (*(((struct normal_encoding  const  *)enc)->isNmstrt2))(enc, ptr);
  }
#line 890
  if (! tmp) {
#line 890
    *nextTokPtr = ptr;
#line 890
    return (0);
  }
#line 890
  ptr += 2;
#line 890
  goto switch_break;
  case_6: /* CIL Label */ 
#line 890
  if (end - ptr < 3L) {
#line 890
    return (-2);
  }
  {
#line 890
  tmp___0 = (*(((struct normal_encoding  const  *)enc)->isNmstrt3))(enc, ptr);
  }
#line 890
  if (! tmp___0) {
#line 890
    *nextTokPtr = ptr;
#line 890
    return (0);
  }
#line 890
  ptr += 3;
#line 890
  goto switch_break;
  case_7: /* CIL Label */ 
#line 890
  if (end - ptr < 4L) {
#line 890
    return (-2);
  }
  {
#line 890
  tmp___1 = (*(((struct normal_encoding  const  *)enc)->isNmstrt4))(enc, ptr);
  }
#line 890
  if (! tmp___1) {
#line 890
    *nextTokPtr = ptr;
#line 890
    return (0);
  }
#line 890
  ptr += 4;
#line 890
  goto switch_break;
  case_30: /* CIL Label */ 
  case_9: /* CIL Label */ 
  case_10: /* CIL Label */ 
  case_21: /* CIL Label */ 
#line 892
  *nextTokPtr = ptr;
#line 893
  return (22);
  switch_default: /* CIL Label */ 
#line 895
  *nextTokPtr = ptr;
#line 896
  return (0);
  switch_break: /* CIL Label */ ;
  }
  {
#line 898
  while (1) {
    while_continue: /* CIL Label */ ;
#line 898
    if (! ((unsigned long )ptr != (unsigned long )end)) {
#line 898
      goto while_break;
    }
    {
#line 900
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 29) {
#line 900
      goto case_29___0;
    }
#line 900
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 27) {
#line 900
      goto case_27;
    }
#line 900
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 26) {
#line 900
      goto case_27;
    }
#line 900
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 25) {
#line 900
      goto case_27;
    }
#line 900
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 24) {
#line 900
      goto case_27;
    }
#line 900
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 22) {
#line 900
      goto case_27;
    }
#line 900
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 5) {
#line 900
      goto case_5___0;
    }
#line 900
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 6) {
#line 900
      goto case_6___0;
    }
#line 900
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 7) {
#line 900
      goto case_7___0;
    }
#line 901
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 18) {
#line 901
      goto case_18;
    }
#line 904
    goto switch_default___0;
    case_29___0: /* CIL Label */ 
#line 900
    *nextTokPtr = ptr;
#line 900
    return (0);
    case_27: /* CIL Label */ 
    case_26: /* CIL Label */ 
    case_25: /* CIL Label */ 
    case_24___0: /* CIL Label */ 
    case_22___0: /* CIL Label */ 
#line 900
    ptr ++;
#line 900
    goto switch_break___0;
    case_5___0: /* CIL Label */ 
#line 900
    if (end - ptr < 2L) {
#line 900
      return (-2);
    }
    {
#line 900
    tmp___2 = (*(((struct normal_encoding  const  *)enc)->isName2))(enc, ptr);
    }
#line 900
    if (! tmp___2) {
#line 900
      *nextTokPtr = ptr;
#line 900
      return (0);
    }
#line 900
    ptr += 2;
#line 900
    goto switch_break___0;
    case_6___0: /* CIL Label */ 
#line 900
    if (end - ptr < 3L) {
#line 900
      return (-2);
    }
    {
#line 900
    tmp___3 = (*(((struct normal_encoding  const  *)enc)->isName3))(enc, ptr);
    }
#line 900
    if (! tmp___3) {
#line 900
      *nextTokPtr = ptr;
#line 900
      return (0);
    }
#line 900
    ptr += 3;
#line 900
    goto switch_break___0;
    case_7___0: /* CIL Label */ 
#line 900
    if (end - ptr < 4L) {
#line 900
      return (-2);
    }
    {
#line 900
    tmp___4 = (*(((struct normal_encoding  const  *)enc)->isName4))(enc, ptr);
    }
#line 900
    if (! tmp___4) {
#line 900
      *nextTokPtr = ptr;
#line 900
      return (0);
    }
#line 900
    ptr += 4;
#line 900
    goto switch_break___0;
    case_18: /* CIL Label */ 
#line 902
    *nextTokPtr = ptr + 1;
#line 903
    return (28);
    switch_default___0: /* CIL Label */ 
#line 905
    *nextTokPtr = ptr;
#line 906
    return (0);
    switch_break___0: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 909
  return (-1);
}
}
#line 912 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmltok_impl.c"
static int normal_scanPoundName(ENCODING const   *enc , char const   *ptr , char const   *end ,
                                char const   **nextTokPtr ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 916
  if ((unsigned long )ptr == (unsigned long )end) {
#line 917
    return (-1);
  }
  {
#line 919
  if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 29) {
#line 919
    goto case_29;
  }
#line 919
  if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 24) {
#line 919
    goto case_24;
  }
#line 919
  if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 22) {
#line 919
    goto case_24;
  }
#line 919
  if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 5) {
#line 919
    goto case_5;
  }
#line 919
  if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 6) {
#line 919
    goto case_6;
  }
#line 919
  if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 7) {
#line 919
    goto case_7;
  }
#line 920
  goto switch_default;
  case_29: /* CIL Label */ 
#line 919
  *nextTokPtr = ptr;
#line 919
  return (0);
  case_24: /* CIL Label */ 
  case_22: /* CIL Label */ 
#line 919
  ptr ++;
#line 919
  goto switch_break;
  case_5: /* CIL Label */ 
#line 919
  if (end - ptr < 2L) {
#line 919
    return (-2);
  }
  {
#line 919
  tmp = (*(((struct normal_encoding  const  *)enc)->isNmstrt2))(enc, ptr);
  }
#line 919
  if (! tmp) {
#line 919
    *nextTokPtr = ptr;
#line 919
    return (0);
  }
#line 919
  ptr += 2;
#line 919
  goto switch_break;
  case_6: /* CIL Label */ 
#line 919
  if (end - ptr < 3L) {
#line 919
    return (-2);
  }
  {
#line 919
  tmp___0 = (*(((struct normal_encoding  const  *)enc)->isNmstrt3))(enc, ptr);
  }
#line 919
  if (! tmp___0) {
#line 919
    *nextTokPtr = ptr;
#line 919
    return (0);
  }
#line 919
  ptr += 3;
#line 919
  goto switch_break;
  case_7: /* CIL Label */ 
#line 919
  if (end - ptr < 4L) {
#line 919
    return (-2);
  }
  {
#line 919
  tmp___1 = (*(((struct normal_encoding  const  *)enc)->isNmstrt4))(enc, ptr);
  }
#line 919
  if (! tmp___1) {
#line 919
    *nextTokPtr = ptr;
#line 919
    return (0);
  }
#line 919
  ptr += 4;
#line 919
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 921
  *nextTokPtr = ptr;
#line 922
  return (0);
  switch_break: /* CIL Label */ ;
  }
  {
#line 924
  while (1) {
    while_continue: /* CIL Label */ ;
#line 924
    if (! ((unsigned long )ptr != (unsigned long )end)) {
#line 924
      goto while_break;
    }
    {
#line 926
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 29) {
#line 926
      goto case_29___0;
    }
#line 926
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 27) {
#line 926
      goto case_27;
    }
#line 926
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 26) {
#line 926
      goto case_27;
    }
#line 926
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 25) {
#line 926
      goto case_27;
    }
#line 926
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 24) {
#line 926
      goto case_27;
    }
#line 926
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 22) {
#line 926
      goto case_27;
    }
#line 926
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 5) {
#line 926
      goto case_5___0;
    }
#line 926
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 6) {
#line 926
      goto case_6___0;
    }
#line 926
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 7) {
#line 926
      goto case_7___0;
    }
#line 928
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 36) {
#line 928
      goto case_36;
    }
#line 928
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 30) {
#line 928
      goto case_36;
    }
#line 928
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 11) {
#line 928
      goto case_36;
    }
#line 928
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 32) {
#line 928
      goto case_36;
    }
#line 928
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 21) {
#line 928
      goto case_36;
    }
#line 928
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 10) {
#line 928
      goto case_36;
    }
#line 928
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 9) {
#line 928
      goto case_36;
    }
#line 931
    goto switch_default___0;
    case_29___0: /* CIL Label */ 
#line 926
    *nextTokPtr = ptr;
#line 926
    return (0);
    case_27: /* CIL Label */ 
    case_26: /* CIL Label */ 
    case_25: /* CIL Label */ 
    case_24___0: /* CIL Label */ 
    case_22___0: /* CIL Label */ 
#line 926
    ptr ++;
#line 926
    goto switch_break___0;
    case_5___0: /* CIL Label */ 
#line 926
    if (end - ptr < 2L) {
#line 926
      return (-2);
    }
    {
#line 926
    tmp___2 = (*(((struct normal_encoding  const  *)enc)->isName2))(enc, ptr);
    }
#line 926
    if (! tmp___2) {
#line 926
      *nextTokPtr = ptr;
#line 926
      return (0);
    }
#line 926
    ptr += 2;
#line 926
    goto switch_break___0;
    case_6___0: /* CIL Label */ 
#line 926
    if (end - ptr < 3L) {
#line 926
      return (-2);
    }
    {
#line 926
    tmp___3 = (*(((struct normal_encoding  const  *)enc)->isName3))(enc, ptr);
    }
#line 926
    if (! tmp___3) {
#line 926
      *nextTokPtr = ptr;
#line 926
      return (0);
    }
#line 926
    ptr += 3;
#line 926
    goto switch_break___0;
    case_7___0: /* CIL Label */ 
#line 926
    if (end - ptr < 4L) {
#line 926
      return (-2);
    }
    {
#line 926
    tmp___4 = (*(((struct normal_encoding  const  *)enc)->isName4))(enc, ptr);
    }
#line 926
    if (! tmp___4) {
#line 926
      *nextTokPtr = ptr;
#line 926
      return (0);
    }
#line 926
    ptr += 4;
#line 926
    goto switch_break___0;
    case_36: /* CIL Label */ 
    case_30: /* CIL Label */ 
    case_11: /* CIL Label */ 
    case_32: /* CIL Label */ 
    case_21: /* CIL Label */ 
    case_10: /* CIL Label */ 
    case_9: /* CIL Label */ 
#line 929
    *nextTokPtr = ptr;
#line 930
    return (20);
    switch_default___0: /* CIL Label */ 
#line 932
    *nextTokPtr = ptr;
#line 933
    return (0);
    switch_break___0: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 936
  return (-20);
}
}
#line 939 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmltok_impl.c"
static int normal_scanLit(int open___0 , ENCODING const   *enc , char const   *ptr ,
                          char const   *end , char const   **nextTokPtr ) 
{ 
  int t ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 944
  while (1) {
    while_continue: /* CIL Label */ ;
#line 944
    if (! ((unsigned long )ptr != (unsigned long )end)) {
#line 944
      goto while_break;
    }
#line 945
    t = (int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr];
    {
#line 947
    if (t == 5) {
#line 947
      goto case_5;
    }
#line 947
    if (t == 6) {
#line 947
      goto case_6;
    }
#line 947
    if (t == 7) {
#line 947
      goto case_7;
    }
#line 947
    if (t == 8) {
#line 947
      goto case_8;
    }
#line 947
    if (t == 1) {
#line 947
      goto case_8;
    }
#line 947
    if (t == 0) {
#line 947
      goto case_8;
    }
#line 949
    if (t == 13) {
#line 949
      goto case_13;
    }
#line 949
    if (t == 12) {
#line 949
      goto case_13;
    }
#line 963
    goto switch_default___0;
    case_5: /* CIL Label */ 
#line 947
    if (end - ptr < 2L) {
#line 947
      return (-2);
    }
    {
#line 947
    tmp = (*(((struct normal_encoding  const  *)enc)->isInvalid2))(enc, ptr);
    }
#line 947
    if (tmp) {
#line 947
      *nextTokPtr = ptr;
#line 947
      return (0);
    }
#line 947
    ptr += 2;
#line 947
    goto switch_break;
    case_6: /* CIL Label */ 
#line 947
    if (end - ptr < 3L) {
#line 947
      return (-2);
    }
    {
#line 947
    tmp___0 = (*(((struct normal_encoding  const  *)enc)->isInvalid3))(enc, ptr);
    }
#line 947
    if (tmp___0) {
#line 947
      *nextTokPtr = ptr;
#line 947
      return (0);
    }
#line 947
    ptr += 3;
#line 947
    goto switch_break;
    case_7: /* CIL Label */ 
#line 947
    if (end - ptr < 4L) {
#line 947
      return (-2);
    }
    {
#line 947
    tmp___1 = (*(((struct normal_encoding  const  *)enc)->isInvalid4))(enc, ptr);
    }
#line 947
    if (tmp___1) {
#line 947
      *nextTokPtr = ptr;
#line 947
      return (0);
    }
#line 947
    ptr += 4;
#line 947
    goto switch_break;
    case_8: /* CIL Label */ 
    case_1: /* CIL Label */ 
    case_0: /* CIL Label */ 
#line 947
    *nextTokPtr = ptr;
#line 947
    return (0);
    case_13: /* CIL Label */ 
    case_12: /* CIL Label */ 
#line 950
    ptr ++;
#line 951
    if (t != open___0) {
#line 952
      goto switch_break;
    }
#line 953
    if ((unsigned long )ptr == (unsigned long )end) {
#line 954
      return (-27);
    }
#line 955
    *nextTokPtr = ptr;
    {
#line 958
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 20) {
#line 958
      goto case_20;
    }
#line 958
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 30) {
#line 958
      goto case_20;
    }
#line 958
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 11) {
#line 958
      goto case_20;
    }
#line 958
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 10) {
#line 958
      goto case_20;
    }
#line 958
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 9) {
#line 958
      goto case_20;
    }
#line 958
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 21) {
#line 958
      goto case_20;
    }
#line 960
    goto switch_default;
    case_20: /* CIL Label */ 
    case_30: /* CIL Label */ 
    case_11: /* CIL Label */ 
    case_10: /* CIL Label */ 
    case_9: /* CIL Label */ 
    case_21: /* CIL Label */ 
#line 959
    return (27);
    switch_default: /* CIL Label */ 
#line 961
    return (0);
    switch_break___0: /* CIL Label */ ;
    }
    switch_default___0: /* CIL Label */ 
#line 964
    ptr ++;
#line 965
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 968
  return (-1);
}
}
#line 971 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmltok_impl.c"
static int normal_prologTok(ENCODING const   *enc , char const   *ptr , char const   *end ,
                            char const   **nextTokPtr ) 
{ 
  int tok ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;

  {
#line 976
  if ((unsigned long )ptr == (unsigned long )end) {
#line 977
    return (-4);
  }
  {
#line 988
  if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 12) {
#line 988
    goto case_12;
  }
#line 990
  if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 13) {
#line 990
    goto case_13;
  }
#line 992
  if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 2) {
#line 992
    goto case_2;
  }
#line 1014
  if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 9) {
#line 1014
    goto case_9;
  }
#line 1021
  if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 10) {
#line 1021
    goto case_10;
  }
#line 1021
  if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 21) {
#line 1021
    goto case_10;
  }
#line 1041
  if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 30) {
#line 1041
    goto case_30;
  }
#line 1043
  if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 35) {
#line 1043
    goto case_35;
  }
#line 1046
  if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 20) {
#line 1046
    goto case_20;
  }
#line 1049
  if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 4) {
#line 1049
    goto case_4;
  }
#line 1063
  if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 31) {
#line 1063
    goto case_31;
  }
#line 1066
  if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 32) {
#line 1066
    goto case_32;
  }
#line 1088
  if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 36) {
#line 1088
    goto case_36___0;
  }
#line 1091
  if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 11) {
#line 1091
    goto case_11___0;
  }
#line 1094
  if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 19) {
#line 1094
    goto case_19;
  }
#line 1112
  if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 5) {
#line 1112
    goto case_5___0;
  }
#line 1112
  if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 6) {
#line 1112
    goto case_6___0;
  }
#line 1112
  if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 7) {
#line 1112
    goto case_7___0;
  }
#line 1115
  if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 24) {
#line 1115
    goto case_24___0;
  }
#line 1115
  if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 22) {
#line 1115
    goto case_24___0;
  }
#line 1123
  if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 23) {
#line 1123
    goto case_23;
  }
#line 1123
  if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 27) {
#line 1123
    goto case_23;
  }
#line 1123
  if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 26) {
#line 1123
    goto case_23;
  }
#line 1123
  if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 25) {
#line 1123
    goto case_23;
  }
#line 1128
  if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 29) {
#line 1128
    goto case_29___0;
  }
#line 1140
  goto switch_default___0;
  case_12: /* CIL Label */ 
  {
#line 989
  tmp = normal_scanLit(12, enc, ptr + 1, end, nextTokPtr);
  }
#line 989
  return (tmp);
  case_13: /* CIL Label */ 
  {
#line 991
  tmp___0 = normal_scanLit(13, enc, ptr + 1, end, nextTokPtr);
  }
#line 991
  return (tmp___0);
  case_2: /* CIL Label */ 
#line 994
  ptr ++;
#line 995
  if ((unsigned long )ptr == (unsigned long )end) {
#line 996
    return (-1);
  }
  {
#line 998
  if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 16) {
#line 998
    goto case_16;
  }
#line 1000
  if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 15) {
#line 1000
    goto case_15;
  }
#line 1007
  if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 7) {
#line 1007
    goto case_7;
  }
#line 1007
  if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 6) {
#line 1007
    goto case_7;
  }
#line 1007
  if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 5) {
#line 1007
    goto case_7;
  }
#line 1007
  if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 29) {
#line 1007
    goto case_7;
  }
#line 1007
  if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 24) {
#line 1007
    goto case_7;
  }
#line 1007
  if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 22) {
#line 1007
    goto case_7;
  }
#line 997
  goto switch_break___0;
  case_16: /* CIL Label */ 
  {
#line 999
  tmp___1 = normal_scanDecl(enc, ptr + 1, end, nextTokPtr);
  }
#line 999
  return (tmp___1);
  case_15: /* CIL Label */ 
  {
#line 1001
  tmp___2 = normal_scanPi(enc, ptr + 1, end, nextTokPtr);
  }
#line 1001
  return (tmp___2);
  case_7: /* CIL Label */ 
  case_6: /* CIL Label */ 
  case_5: /* CIL Label */ 
  case_29: /* CIL Label */ 
  case_24: /* CIL Label */ 
  case_22: /* CIL Label */ 
#line 1008
  *nextTokPtr = ptr - 1;
#line 1009
  return (29);
  switch_break___0: /* CIL Label */ ;
  }
#line 1011
  *nextTokPtr = ptr;
#line 1012
  return (0);
  case_9: /* CIL Label */ 
#line 1015
  if ((unsigned long )(ptr + 1) == (unsigned long )end) {
#line 1016
    *nextTokPtr = end;
#line 1018
    return (-15);
  }
  case_10: /* CIL Label */ 
  case_21: /* CIL Label */ 
  {
#line 1022
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1023
    ptr ++;
#line 1024
    if ((unsigned long )ptr == (unsigned long )end) {
#line 1025
      goto while_break;
    }
    {
#line 1027
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 10) {
#line 1027
      goto case_10___0;
    }
#line 1027
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 21) {
#line 1027
      goto case_10___0;
    }
#line 1029
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 9) {
#line 1029
      goto case_9___0;
    }
#line 1034
    goto switch_default;
    case_10___0: /* CIL Label */ 
    case_21___0: /* CIL Label */ 
#line 1028
    goto switch_break___1;
    case_9___0: /* CIL Label */ 
#line 1031
    if ((unsigned long )(ptr + 1) != (unsigned long )end) {
#line 1032
      goto switch_break___1;
    }
    switch_default: /* CIL Label */ 
#line 1035
    *nextTokPtr = ptr;
#line 1036
    return (15);
    switch_break___1: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1039
  *nextTokPtr = ptr;
#line 1040
  return (15);
  case_30: /* CIL Label */ 
  {
#line 1042
  tmp___3 = normal_scanPercent(enc, ptr + 1, end, nextTokPtr);
  }
#line 1042
  return (tmp___3);
  case_35: /* CIL Label */ 
#line 1044
  *nextTokPtr = ptr + 1;
#line 1045
  return (38);
  case_20: /* CIL Label */ 
#line 1047
  *nextTokPtr = ptr + 1;
#line 1048
  return (25);
  case_4: /* CIL Label */ 
#line 1050
  ptr ++;
#line 1051
  if ((unsigned long )ptr == (unsigned long )end) {
#line 1052
    return (-26);
  }
#line 1053
  if ((int const   )*ptr == 93) {
#line 1054
    if ((unsigned long )(ptr + 1) == (unsigned long )end) {
#line 1055
      return (-1);
    }
#line 1056
    if ((int const   )*(ptr + 1) == 62) {
#line 1057
      *nextTokPtr = ptr + 2;
#line 1058
      return (34);
    }
  }
#line 1061
  *nextTokPtr = ptr;
#line 1062
  return (26);
  case_31: /* CIL Label */ 
#line 1064
  *nextTokPtr = ptr + 1;
#line 1065
  return (23);
  case_32: /* CIL Label */ 
#line 1067
  ptr ++;
#line 1068
  if ((unsigned long )ptr == (unsigned long )end) {
#line 1069
    return (-24);
  }
  {
#line 1071
  if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 33) {
#line 1071
    goto case_33;
  }
#line 1074
  if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 15) {
#line 1074
    goto case_15___0;
  }
#line 1077
  if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 34) {
#line 1077
    goto case_34;
  }
#line 1082
  if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 32) {
#line 1082
    goto case_32___0;
  }
#line 1082
  if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 36) {
#line 1082
    goto case_32___0;
  }
#line 1082
  if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 35) {
#line 1082
    goto case_32___0;
  }
#line 1082
  if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 11) {
#line 1082
    goto case_32___0;
  }
#line 1082
  if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 21) {
#line 1082
    goto case_32___0;
  }
#line 1082
  if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 10) {
#line 1082
    goto case_32___0;
  }
#line 1082
  if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 9) {
#line 1082
    goto case_32___0;
  }
#line 1070
  goto switch_break___2;
  case_33: /* CIL Label */ 
#line 1072
  *nextTokPtr = ptr + 1;
#line 1073
  return (36);
  case_15___0: /* CIL Label */ 
#line 1075
  *nextTokPtr = ptr + 1;
#line 1076
  return (35);
  case_34: /* CIL Label */ 
#line 1078
  *nextTokPtr = ptr + 1;
#line 1079
  return (37);
  case_32___0: /* CIL Label */ 
  case_36: /* CIL Label */ 
  case_35___0: /* CIL Label */ 
  case_11: /* CIL Label */ 
  case_21___1: /* CIL Label */ 
  case_10___1: /* CIL Label */ 
  case_9___1: /* CIL Label */ 
#line 1083
  *nextTokPtr = ptr;
#line 1084
  return (24);
  switch_break___2: /* CIL Label */ ;
  }
#line 1086
  *nextTokPtr = ptr;
#line 1087
  return (0);
  case_36___0: /* CIL Label */ 
#line 1089
  *nextTokPtr = ptr + 1;
#line 1090
  return (21);
  case_11___0: /* CIL Label */ 
#line 1092
  *nextTokPtr = ptr + 1;
#line 1093
  return (17);
  case_19: /* CIL Label */ 
  {
#line 1095
  tmp___4 = normal_scanPoundName(enc, ptr + 1, end, nextTokPtr);
  }
#line 1095
  return (tmp___4);
  case_5___0: /* CIL Label */ 
#line 1112
  if (end - ptr < 2L) {
#line 1112
    return (-2);
  }
  {
#line 1112
  tmp___5 = (*(((struct normal_encoding  const  *)enc)->isNmstrt2))(enc, ptr);
  }
#line 1112
  if (tmp___5) {
#line 1112
    ptr += 2;
#line 1112
    tok = 18;
#line 1112
    goto switch_break;
  }
  {
#line 1112
  tmp___6 = (*(((struct normal_encoding  const  *)enc)->isName2))(enc, ptr);
  }
#line 1112
  if (tmp___6) {
#line 1112
    ptr += 2;
#line 1112
    tok = 19;
#line 1112
    goto switch_break;
  }
#line 1112
  *nextTokPtr = ptr;
#line 1112
  return (0);
  case_6___0: /* CIL Label */ 
#line 1112
  if (end - ptr < 3L) {
#line 1112
    return (-2);
  }
  {
#line 1112
  tmp___7 = (*(((struct normal_encoding  const  *)enc)->isNmstrt3))(enc, ptr);
  }
#line 1112
  if (tmp___7) {
#line 1112
    ptr += 3;
#line 1112
    tok = 18;
#line 1112
    goto switch_break;
  }
  {
#line 1112
  tmp___8 = (*(((struct normal_encoding  const  *)enc)->isName3))(enc, ptr);
  }
#line 1112
  if (tmp___8) {
#line 1112
    ptr += 3;
#line 1112
    tok = 19;
#line 1112
    goto switch_break;
  }
#line 1112
  *nextTokPtr = ptr;
#line 1112
  return (0);
  case_7___0: /* CIL Label */ 
#line 1112
  if (end - ptr < 4L) {
#line 1112
    return (-2);
  }
  {
#line 1112
  tmp___9 = (*(((struct normal_encoding  const  *)enc)->isNmstrt4))(enc, ptr);
  }
#line 1112
  if (tmp___9) {
#line 1112
    ptr += 4;
#line 1112
    tok = 18;
#line 1112
    goto switch_break;
  }
  {
#line 1112
  tmp___10 = (*(((struct normal_encoding  const  *)enc)->isName4))(enc, ptr);
  }
#line 1112
  if (tmp___10) {
#line 1112
    ptr += 4;
#line 1112
    tok = 19;
#line 1112
    goto switch_break;
  }
#line 1112
  *nextTokPtr = ptr;
#line 1112
  return (0);
  case_24___0: /* CIL Label */ 
  case_22___0: /* CIL Label */ 
#line 1116
  tok = 18;
#line 1117
  ptr ++;
#line 1118
  goto switch_break;
  case_23: /* CIL Label */ 
  case_27: /* CIL Label */ 
  case_26: /* CIL Label */ 
  case_25: /* CIL Label */ 
#line 1125
  tok = 19;
#line 1126
  ptr ++;
#line 1127
  goto switch_break;
  case_29___0: /* CIL Label */ ;
  switch_default___0: /* CIL Label */ 
#line 1141
  *nextTokPtr = ptr;
#line 1142
  return (0);
  switch_break: /* CIL Label */ ;
  }
  {
#line 1144
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1144
    if (! ((unsigned long )ptr != (unsigned long )end)) {
#line 1144
      goto while_break___0;
    }
    {
#line 1146
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 29) {
#line 1146
      goto case_29___1;
    }
#line 1146
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 27) {
#line 1146
      goto case_27___0;
    }
#line 1146
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 26) {
#line 1146
      goto case_27___0;
    }
#line 1146
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 25) {
#line 1146
      goto case_27___0;
    }
#line 1146
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 24) {
#line 1146
      goto case_27___0;
    }
#line 1146
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 22) {
#line 1146
      goto case_27___0;
    }
#line 1146
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 5) {
#line 1146
      goto case_5___1;
    }
#line 1146
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 6) {
#line 1146
      goto case_6___1;
    }
#line 1146
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 7) {
#line 1146
      goto case_7___1;
    }
#line 1149
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 10) {
#line 1149
      goto case_10___2;
    }
#line 1149
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 9) {
#line 1149
      goto case_10___2;
    }
#line 1149
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 21) {
#line 1149
      goto case_10___2;
    }
#line 1149
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 30) {
#line 1149
      goto case_10___2;
    }
#line 1149
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 20) {
#line 1149
      goto case_10___2;
    }
#line 1149
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 36) {
#line 1149
      goto case_10___2;
    }
#line 1149
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 35) {
#line 1149
      goto case_10___2;
    }
#line 1149
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 32) {
#line 1149
      goto case_10___2;
    }
#line 1149
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 11) {
#line 1149
      goto case_10___2;
    }
#line 1153
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 23) {
#line 1153
      goto case_23___0;
    }
#line 1173
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 34) {
#line 1173
      goto case_34___0;
    }
#line 1180
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 33) {
#line 1180
      goto case_33___0;
    }
#line 1187
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 15) {
#line 1187
      goto case_15___1;
    }
#line 1194
    goto switch_default___2;
    case_29___1: /* CIL Label */ 
#line 1146
    *nextTokPtr = ptr;
#line 1146
    return (0);
    case_27___0: /* CIL Label */ 
    case_26___0: /* CIL Label */ 
    case_25___0: /* CIL Label */ 
    case_24___1: /* CIL Label */ 
    case_22___1: /* CIL Label */ 
#line 1146
    ptr ++;
#line 1146
    goto switch_break___3;
    case_5___1: /* CIL Label */ 
#line 1146
    if (end - ptr < 2L) {
#line 1146
      return (-2);
    }
    {
#line 1146
    tmp___11 = (*(((struct normal_encoding  const  *)enc)->isName2))(enc, ptr);
    }
#line 1146
    if (! tmp___11) {
#line 1146
      *nextTokPtr = ptr;
#line 1146
      return (0);
    }
#line 1146
    ptr += 2;
#line 1146
    goto switch_break___3;
    case_6___1: /* CIL Label */ 
#line 1146
    if (end - ptr < 3L) {
#line 1146
      return (-2);
    }
    {
#line 1146
    tmp___12 = (*(((struct normal_encoding  const  *)enc)->isName3))(enc, ptr);
    }
#line 1146
    if (! tmp___12) {
#line 1146
      *nextTokPtr = ptr;
#line 1146
      return (0);
    }
#line 1146
    ptr += 3;
#line 1146
    goto switch_break___3;
    case_7___1: /* CIL Label */ 
#line 1146
    if (end - ptr < 4L) {
#line 1146
      return (-2);
    }
    {
#line 1146
    tmp___13 = (*(((struct normal_encoding  const  *)enc)->isName4))(enc, ptr);
    }
#line 1146
    if (! tmp___13) {
#line 1146
      *nextTokPtr = ptr;
#line 1146
      return (0);
    }
#line 1146
    ptr += 4;
#line 1146
    goto switch_break___3;
    case_10___2: /* CIL Label */ 
    case_9___2: /* CIL Label */ 
    case_21___2: /* CIL Label */ 
    case_30___0: /* CIL Label */ 
    case_20___0: /* CIL Label */ 
    case_36___1: /* CIL Label */ 
    case_35___1: /* CIL Label */ 
    case_32___1: /* CIL Label */ 
    case_11___1: /* CIL Label */ 
#line 1150
    *nextTokPtr = ptr;
#line 1151
    return (tok);
    case_23___0: /* CIL Label */ 
#line 1154
    ptr ++;
    {
#line 1156
    if (tok == 18) {
#line 1156
      goto case_18;
    }
#line 1167
    if (tok == 41) {
#line 1167
      goto case_41;
    }
#line 1155
    goto switch_break___4;
    case_18: /* CIL Label */ 
#line 1157
    if ((unsigned long )ptr == (unsigned long )end) {
#line 1158
      return (-1);
    }
#line 1159
    tok = 41;
    {
#line 1161
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 29) {
#line 1161
      goto case_29___2;
    }
#line 1161
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 27) {
#line 1161
      goto case_27___1;
    }
#line 1161
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 26) {
#line 1161
      goto case_27___1;
    }
#line 1161
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 25) {
#line 1161
      goto case_27___1;
    }
#line 1161
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 24) {
#line 1161
      goto case_27___1;
    }
#line 1161
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 22) {
#line 1161
      goto case_27___1;
    }
#line 1161
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 5) {
#line 1161
      goto case_5___2;
    }
#line 1161
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 6) {
#line 1161
      goto case_6___2;
    }
#line 1161
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 7) {
#line 1161
      goto case_7___2;
    }
#line 1162
    goto switch_default___1;
    case_29___2: /* CIL Label */ 
#line 1161
    *nextTokPtr = ptr;
#line 1161
    return (0);
    case_27___1: /* CIL Label */ 
    case_26___1: /* CIL Label */ 
    case_25___1: /* CIL Label */ 
    case_24___2: /* CIL Label */ 
    case_22___2: /* CIL Label */ 
#line 1161
    ptr ++;
#line 1161
    goto switch_break___5;
    case_5___2: /* CIL Label */ 
#line 1161
    if (end - ptr < 2L) {
#line 1161
      return (-2);
    }
    {
#line 1161
    tmp___14 = (*(((struct normal_encoding  const  *)enc)->isName2))(enc, ptr);
    }
#line 1161
    if (! tmp___14) {
#line 1161
      *nextTokPtr = ptr;
#line 1161
      return (0);
    }
#line 1161
    ptr += 2;
#line 1161
    goto switch_break___5;
    case_6___2: /* CIL Label */ 
#line 1161
    if (end - ptr < 3L) {
#line 1161
      return (-2);
    }
    {
#line 1161
    tmp___15 = (*(((struct normal_encoding  const  *)enc)->isName3))(enc, ptr);
    }
#line 1161
    if (! tmp___15) {
#line 1161
      *nextTokPtr = ptr;
#line 1161
      return (0);
    }
#line 1161
    ptr += 3;
#line 1161
    goto switch_break___5;
    case_7___2: /* CIL Label */ 
#line 1161
    if (end - ptr < 4L) {
#line 1161
      return (-2);
    }
    {
#line 1161
    tmp___16 = (*(((struct normal_encoding  const  *)enc)->isName4))(enc, ptr);
    }
#line 1161
    if (! tmp___16) {
#line 1161
      *nextTokPtr = ptr;
#line 1161
      return (0);
    }
#line 1161
    ptr += 4;
#line 1161
    goto switch_break___5;
    switch_default___1: /* CIL Label */ 
#line 1163
    tok = 19;
#line 1164
    goto switch_break___5;
    switch_break___5: /* CIL Label */ ;
    }
#line 1166
    goto switch_break___4;
    case_41: /* CIL Label */ 
#line 1168
    tok = 19;
#line 1169
    goto switch_break___4;
    switch_break___4: /* CIL Label */ ;
    }
#line 1171
    goto switch_break___3;
    case_34___0: /* CIL Label */ 
#line 1174
    if (tok == 19) {
#line 1175
      *nextTokPtr = ptr;
#line 1176
      return (0);
    }
#line 1178
    *nextTokPtr = ptr + 1;
#line 1179
    return (32);
    case_33___0: /* CIL Label */ 
#line 1181
    if (tok == 19) {
#line 1182
      *nextTokPtr = ptr;
#line 1183
      return (0);
    }
#line 1185
    *nextTokPtr = ptr + 1;
#line 1186
    return (31);
    case_15___1: /* CIL Label */ 
#line 1188
    if (tok == 19) {
#line 1189
      *nextTokPtr = ptr;
#line 1190
      return (0);
    }
#line 1192
    *nextTokPtr = ptr + 1;
#line 1193
    return (30);
    switch_default___2: /* CIL Label */ 
#line 1195
    *nextTokPtr = ptr;
#line 1196
    return (0);
    switch_break___3: /* CIL Label */ ;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1199
  return (- tok);
}
}
#line 1202 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmltok_impl.c"
static int normal_attributeValueTok(ENCODING const   *enc , char const   *ptr , char const   *end ,
                                    char const   **nextTokPtr ) 
{ 
  char const   *start ;
  int tmp ;

  {
#line 1207
  if ((unsigned long )ptr == (unsigned long )end) {
#line 1208
    return (-4);
  }
#line 1209
  start = ptr;
  {
#line 1210
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1210
    if (! ((unsigned long )ptr != (unsigned long )end)) {
#line 1210
      goto while_break;
    }
    {
#line 1214
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 5) {
#line 1214
      goto case_5;
    }
#line 1214
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 6) {
#line 1214
      goto case_6;
    }
#line 1214
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 7) {
#line 1214
      goto case_7;
    }
#line 1216
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 3) {
#line 1216
      goto case_3;
    }
#line 1221
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 2) {
#line 1221
      goto case_2;
    }
#line 1225
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 10) {
#line 1225
      goto case_10;
    }
#line 1232
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 9) {
#line 1232
      goto case_9;
    }
#line 1244
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 21) {
#line 1244
      goto case_21;
    }
#line 1251
    goto switch_default;
    case_5: /* CIL Label */ 
#line 1214
    ptr += 2;
#line 1214
    goto switch_break;
    case_6: /* CIL Label */ 
#line 1214
    ptr += 3;
#line 1214
    goto switch_break;
    case_7: /* CIL Label */ 
#line 1214
    ptr += 4;
#line 1214
    goto switch_break;
    case_3: /* CIL Label */ 
#line 1217
    if ((unsigned long )ptr == (unsigned long )start) {
      {
#line 1218
      tmp = normal_scanRef(enc, ptr + 1, end, nextTokPtr);
      }
#line 1218
      return (tmp);
    }
#line 1219
    *nextTokPtr = ptr;
#line 1220
    return (6);
    case_2: /* CIL Label */ 
#line 1223
    *nextTokPtr = ptr;
#line 1224
    return (0);
    case_10: /* CIL Label */ 
#line 1226
    if ((unsigned long )ptr == (unsigned long )start) {
#line 1227
      *nextTokPtr = ptr + 1;
#line 1228
      return (7);
    }
#line 1230
    *nextTokPtr = ptr;
#line 1231
    return (6);
    case_9: /* CIL Label */ 
#line 1233
    if ((unsigned long )ptr == (unsigned long )start) {
#line 1234
      ptr ++;
#line 1235
      if ((unsigned long )ptr == (unsigned long )end) {
#line 1236
        return (-3);
      }
#line 1237
      if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 10) {
#line 1238
        ptr ++;
      }
#line 1239
      *nextTokPtr = ptr;
#line 1240
      return (7);
    }
#line 1242
    *nextTokPtr = ptr;
#line 1243
    return (6);
    case_21: /* CIL Label */ 
#line 1245
    if ((unsigned long )ptr == (unsigned long )start) {
#line 1246
      *nextTokPtr = ptr + 1;
#line 1247
      return (39);
    }
#line 1249
    *nextTokPtr = ptr;
#line 1250
    return (6);
    switch_default: /* CIL Label */ 
#line 1252
    ptr ++;
#line 1253
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1256
  *nextTokPtr = ptr;
#line 1257
  return (6);
}
}
#line 1260 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmltok_impl.c"
static int normal_entityValueTok(ENCODING const   *enc , char const   *ptr , char const   *end ,
                                 char const   **nextTokPtr ) 
{ 
  char const   *start ;
  int tmp ;
  int tok ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 1265
  if ((unsigned long )ptr == (unsigned long )end) {
#line 1266
    return (-4);
  }
#line 1267
  start = ptr;
  {
#line 1268
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1268
    if (! ((unsigned long )ptr != (unsigned long )end)) {
#line 1268
      goto while_break;
    }
    {
#line 1272
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 5) {
#line 1272
      goto case_5;
    }
#line 1272
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 6) {
#line 1272
      goto case_6;
    }
#line 1272
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 7) {
#line 1272
      goto case_7;
    }
#line 1274
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 3) {
#line 1274
      goto case_3;
    }
#line 1279
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 30) {
#line 1279
      goto case_30;
    }
#line 1287
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 10) {
#line 1287
      goto case_10;
    }
#line 1294
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 9) {
#line 1294
      goto case_9;
    }
#line 1306
    goto switch_default;
    case_5: /* CIL Label */ 
#line 1272
    ptr += 2;
#line 1272
    goto switch_break;
    case_6: /* CIL Label */ 
#line 1272
    ptr += 3;
#line 1272
    goto switch_break;
    case_7: /* CIL Label */ 
#line 1272
    ptr += 4;
#line 1272
    goto switch_break;
    case_3: /* CIL Label */ 
#line 1275
    if ((unsigned long )ptr == (unsigned long )start) {
      {
#line 1276
      tmp = normal_scanRef(enc, ptr + 1, end, nextTokPtr);
      }
#line 1276
      return (tmp);
    }
#line 1277
    *nextTokPtr = ptr;
#line 1278
    return (6);
    case_30: /* CIL Label */ 
#line 1280
    if ((unsigned long )ptr == (unsigned long )start) {
      {
#line 1281
      tmp___0 = normal_scanPercent(enc, ptr + 1, end, nextTokPtr);
#line 1281
      tok = tmp___0;
      }
#line 1283
      if (tok == 22) {
#line 1283
        tmp___1 = 0;
      } else {
#line 1283
        tmp___1 = tok;
      }
#line 1283
      return (tmp___1);
    }
#line 1285
    *nextTokPtr = ptr;
#line 1286
    return (6);
    case_10: /* CIL Label */ 
#line 1288
    if ((unsigned long )ptr == (unsigned long )start) {
#line 1289
      *nextTokPtr = ptr + 1;
#line 1290
      return (7);
    }
#line 1292
    *nextTokPtr = ptr;
#line 1293
    return (6);
    case_9: /* CIL Label */ 
#line 1295
    if ((unsigned long )ptr == (unsigned long )start) {
#line 1296
      ptr ++;
#line 1297
      if ((unsigned long )ptr == (unsigned long )end) {
#line 1298
        return (-3);
      }
#line 1299
      if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 10) {
#line 1300
        ptr ++;
      }
#line 1301
      *nextTokPtr = ptr;
#line 1302
      return (7);
    }
#line 1304
    *nextTokPtr = ptr;
#line 1305
    return (6);
    switch_default: /* CIL Label */ 
#line 1307
    ptr ++;
#line 1308
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1311
  *nextTokPtr = ptr;
#line 1312
  return (6);
}
}
#line 1317 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmltok_impl.c"
static int normal_ignoreSectionTok(ENCODING const   *enc , char const   *ptr , char const   *end ,
                                   char const   **nextTokPtr ) 
{ 
  int level ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 1321
  level = 0;
  {
#line 1329
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1329
    if (! ((unsigned long )ptr != (unsigned long )end)) {
#line 1329
      goto while_break;
    }
    {
#line 1331
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 5) {
#line 1331
      goto case_5;
    }
#line 1331
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 6) {
#line 1331
      goto case_6;
    }
#line 1331
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 7) {
#line 1331
      goto case_7;
    }
#line 1331
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 8) {
#line 1331
      goto case_8;
    }
#line 1331
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 1) {
#line 1331
      goto case_8;
    }
#line 1331
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 0) {
#line 1331
      goto case_8;
    }
#line 1332
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 2) {
#line 1332
      goto case_2;
    }
#line 1344
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 4) {
#line 1344
      goto case_4;
    }
#line 1360
    goto switch_default;
    case_5: /* CIL Label */ 
#line 1331
    if (end - ptr < 2L) {
#line 1331
      return (-2);
    }
    {
#line 1331
    tmp = (*(((struct normal_encoding  const  *)enc)->isInvalid2))(enc, ptr);
    }
#line 1331
    if (tmp) {
#line 1331
      *nextTokPtr = ptr;
#line 1331
      return (0);
    }
#line 1331
    ptr += 2;
#line 1331
    goto switch_break;
    case_6: /* CIL Label */ 
#line 1331
    if (end - ptr < 3L) {
#line 1331
      return (-2);
    }
    {
#line 1331
    tmp___0 = (*(((struct normal_encoding  const  *)enc)->isInvalid3))(enc, ptr);
    }
#line 1331
    if (tmp___0) {
#line 1331
      *nextTokPtr = ptr;
#line 1331
      return (0);
    }
#line 1331
    ptr += 3;
#line 1331
    goto switch_break;
    case_7: /* CIL Label */ 
#line 1331
    if (end - ptr < 4L) {
#line 1331
      return (-2);
    }
    {
#line 1331
    tmp___1 = (*(((struct normal_encoding  const  *)enc)->isInvalid4))(enc, ptr);
    }
#line 1331
    if (tmp___1) {
#line 1331
      *nextTokPtr = ptr;
#line 1331
      return (0);
    }
#line 1331
    ptr += 4;
#line 1331
    goto switch_break;
    case_8: /* CIL Label */ 
    case_1: /* CIL Label */ 
    case_0: /* CIL Label */ 
#line 1331
    *nextTokPtr = ptr;
#line 1331
    return (0);
    case_2: /* CIL Label */ 
#line 1333
    ptr ++;
#line 1333
    if ((unsigned long )ptr == (unsigned long )end) {
#line 1334
      return (-1);
    }
#line 1335
    if ((int const   )*ptr == 33) {
#line 1336
      ptr ++;
#line 1336
      if ((unsigned long )ptr == (unsigned long )end) {
#line 1337
        return (-1);
      }
#line 1338
      if ((int const   )*ptr == 91) {
#line 1339
        level ++;
#line 1340
        ptr ++;
      }
    }
#line 1343
    goto switch_break;
    case_4: /* CIL Label */ 
#line 1345
    ptr ++;
#line 1345
    if ((unsigned long )ptr == (unsigned long )end) {
#line 1346
      return (-1);
    }
#line 1347
    if ((int const   )*ptr == 93) {
#line 1348
      ptr ++;
#line 1348
      if ((unsigned long )ptr == (unsigned long )end) {
#line 1349
        return (-1);
      }
#line 1350
      if ((int const   )*ptr == 62) {
#line 1351
        ptr ++;
#line 1352
        if (level == 0) {
#line 1353
          *nextTokPtr = ptr;
#line 1354
          return (42);
        }
#line 1356
        level --;
      }
    }
#line 1359
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 1361
    ptr ++;
#line 1362
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1365
  return (-1);
}
}
#line 1370 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmltok_impl.c"
static int normal_isPublicId(ENCODING const   *enc , char const   *ptr , char const   *end ,
                             char const   **badPtr ) 
{ 


  {
#line 1374
  ptr ++;
#line 1375
  end --;
  {
#line 1376
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1376
    if (! ((unsigned long )ptr != (unsigned long )end)) {
#line 1376
      goto while_break;
    }
    {
#line 1397
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 23) {
#line 1397
      goto case_23;
    }
#line 1397
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 19) {
#line 1397
      goto case_23;
    }
#line 1397
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 30) {
#line 1397
      goto case_23;
    }
#line 1397
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 33) {
#line 1397
      goto case_23;
    }
#line 1397
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 16) {
#line 1397
      goto case_23;
    }
#line 1397
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 18) {
#line 1397
      goto case_23;
    }
#line 1397
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 10) {
#line 1397
      goto case_23;
    }
#line 1397
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 9) {
#line 1397
      goto case_23;
    }
#line 1397
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 15) {
#line 1397
      goto case_23;
    }
#line 1397
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 14) {
#line 1397
      goto case_23;
    }
#line 1397
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 17) {
#line 1397
      goto case_23;
    }
#line 1397
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 35) {
#line 1397
      goto case_23;
    }
#line 1397
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 34) {
#line 1397
      goto case_23;
    }
#line 1397
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 32) {
#line 1397
      goto case_23;
    }
#line 1397
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 31) {
#line 1397
      goto case_23;
    }
#line 1397
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 13) {
#line 1397
      goto case_23;
    }
#line 1397
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 27) {
#line 1397
      goto case_23;
    }
#line 1397
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 24) {
#line 1397
      goto case_23;
    }
#line 1397
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 25) {
#line 1397
      goto case_23;
    }
#line 1400
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 21) {
#line 1400
      goto case_21;
    }
#line 1407
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 22) {
#line 1407
      goto case_22;
    }
#line 1407
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 26) {
#line 1407
      goto case_22;
    }
#line 1410
    goto switch_default;
    case_23: /* CIL Label */ 
    case_19: /* CIL Label */ 
    case_30: /* CIL Label */ 
    case_33: /* CIL Label */ 
    case_16: /* CIL Label */ 
    case_18: /* CIL Label */ 
    case_10: /* CIL Label */ 
    case_9: /* CIL Label */ 
    case_15: /* CIL Label */ 
    case_14: /* CIL Label */ 
    case_17: /* CIL Label */ 
    case_35: /* CIL Label */ 
    case_34: /* CIL Label */ 
    case_32: /* CIL Label */ 
    case_31: /* CIL Label */ 
    case_13: /* CIL Label */ 
    case_27: /* CIL Label */ 
    case_24: /* CIL Label */ 
    case_25: /* CIL Label */ 
#line 1399
    goto switch_break;
    case_21: /* CIL Label */ 
#line 1401
    if ((int const   )*ptr == 9) {
#line 1402
      *badPtr = ptr;
#line 1403
      return (0);
    }
#line 1405
    goto switch_break;
    case_22: /* CIL Label */ 
    case_26: /* CIL Label */ 
#line 1408
    if (! ((int const   )*ptr & -128)) {
#line 1409
      goto switch_break;
    }
    switch_default: /* CIL Label */ 
    {
#line 1413
    if ((int const   )*ptr == 64) {
#line 1413
      goto case_64;
    }
#line 1413
    if ((int const   )*ptr == 36) {
#line 1413
      goto case_64;
    }
#line 1415
    goto switch_default___0;
    case_64: /* CIL Label */ 
    case_36: /* CIL Label */ 
#line 1414
    goto switch_break___0;
    switch_default___0: /* CIL Label */ 
#line 1416
    *badPtr = ptr;
#line 1417
    return (0);
    switch_break___0: /* CIL Label */ ;
    }
#line 1419
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 1376
    ptr ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1422
  return (1);
}
}
#line 1430 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmltok_impl.c"
static int normal_getAtts(ENCODING const   *enc , char const   *ptr , int attsMax ,
                          ATTRIBUTE *atts ) 
{ 
  enum __anonenum_state_4 state ;
  int nAtts ;
  int open___0 ;

  {
#line 1434
  state = (enum __anonenum_state_4 )1;
#line 1435
  nAtts = 0;
#line 1436
  open___0 = 0;
#line 1439
  ptr ++;
  {
#line 1439
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1451
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 5) {
#line 1451
      goto case_5;
    }
#line 1451
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 6) {
#line 1451
      goto case_6;
    }
#line 1451
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 7) {
#line 1451
      goto case_7;
    }
#line 1455
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 24) {
#line 1455
      goto case_24;
    }
#line 1455
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 22) {
#line 1455
      goto case_24;
    }
#line 1455
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 29) {
#line 1455
      goto case_24;
    }
#line 1459
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 12) {
#line 1459
      goto case_12;
    }
#line 1473
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 13) {
#line 1473
      goto case_13;
    }
#line 1487
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 3) {
#line 1487
      goto case_3;
    }
#line 1491
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 21) {
#line 1491
      goto case_21;
    }
#line 1503
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 10) {
#line 1503
      goto case_10;
    }
#line 1503
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 9) {
#line 1503
      goto case_10;
    }
#line 1512
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 17) {
#line 1512
      goto case_17;
    }
#line 1512
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 11) {
#line 1512
      goto case_17;
    }
#line 1516
    goto switch_default;
    case_5: /* CIL Label */ 
#line 1451
    if ((unsigned int )state == 0U) {
#line 1451
      if (nAtts < attsMax) {
#line 1451
        (atts + nAtts)->name = ptr;
#line 1451
        (atts + nAtts)->normalized = (char)1;
      }
#line 1451
      state = (enum __anonenum_state_4 )1;
    }
#line 1451
    ptr ++;
#line 1451
    goto switch_break;
    case_6: /* CIL Label */ 
#line 1451
    if ((unsigned int )state == 0U) {
#line 1451
      if (nAtts < attsMax) {
#line 1451
        (atts + nAtts)->name = ptr;
#line 1451
        (atts + nAtts)->normalized = (char)1;
      }
#line 1451
      state = (enum __anonenum_state_4 )1;
    }
#line 1451
    ptr += 2;
#line 1451
    goto switch_break;
    case_7: /* CIL Label */ 
#line 1451
    if ((unsigned int )state == 0U) {
#line 1451
      if (nAtts < attsMax) {
#line 1451
        (atts + nAtts)->name = ptr;
#line 1451
        (atts + nAtts)->normalized = (char)1;
      }
#line 1451
      state = (enum __anonenum_state_4 )1;
    }
#line 1451
    ptr += 3;
#line 1451
    goto switch_break;
    case_24: /* CIL Label */ 
    case_22: /* CIL Label */ 
    case_29: /* CIL Label */ 
#line 1456
    if ((unsigned int )state == 0U) {
#line 1456
      if (nAtts < attsMax) {
#line 1456
        (atts + nAtts)->name = ptr;
#line 1456
        (atts + nAtts)->normalized = (char)1;
      }
#line 1456
      state = (enum __anonenum_state_4 )1;
    }
#line 1457
    goto switch_break;
    case_12: /* CIL Label */ 
#line 1460
    if ((unsigned int )state != 2U) {
#line 1461
      if (nAtts < attsMax) {
#line 1462
        (atts + nAtts)->valuePtr = ptr + 1;
      }
#line 1463
      state = (enum __anonenum_state_4 )2;
#line 1464
      open___0 = 12;
    } else
#line 1466
    if (open___0 == 12) {
#line 1467
      state = (enum __anonenum_state_4 )0;
#line 1468
      if (nAtts < attsMax) {
#line 1469
        (atts + nAtts)->valueEnd = ptr;
      }
#line 1470
      nAtts ++;
    }
#line 1472
    goto switch_break;
    case_13: /* CIL Label */ 
#line 1474
    if ((unsigned int )state != 2U) {
#line 1475
      if (nAtts < attsMax) {
#line 1476
        (atts + nAtts)->valuePtr = ptr + 1;
      }
#line 1477
      state = (enum __anonenum_state_4 )2;
#line 1478
      open___0 = 13;
    } else
#line 1480
    if (open___0 == 13) {
#line 1481
      state = (enum __anonenum_state_4 )0;
#line 1482
      if (nAtts < attsMax) {
#line 1483
        (atts + nAtts)->valueEnd = ptr;
      }
#line 1484
      nAtts ++;
    }
#line 1486
    goto switch_break;
    case_3: /* CIL Label */ 
#line 1488
    if (nAtts < attsMax) {
#line 1489
      (atts + nAtts)->normalized = (char)0;
    }
#line 1490
    goto switch_break;
    case_21: /* CIL Label */ 
#line 1492
    if ((unsigned int )state == 1U) {
#line 1493
      state = (enum __anonenum_state_4 )0;
    } else
#line 1494
    if ((unsigned int )state == 2U) {
#line 1494
      if (nAtts < attsMax) {
#line 1494
        if ((atts + nAtts)->normalized) {
#line 1494
          if ((unsigned long )ptr == (unsigned long )(atts + nAtts)->valuePtr) {
#line 1501
            (atts + nAtts)->normalized = (char)0;
          } else
#line 1494
          if ((int const   )*ptr != 32) {
#line 1501
            (atts + nAtts)->normalized = (char)0;
          } else
#line 1494
          if ((int const   )*(ptr + 1) == 32) {
#line 1501
            (atts + nAtts)->normalized = (char)0;
          } else
#line 1494
          if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*(ptr + 1)] == open___0) {
#line 1501
            (atts + nAtts)->normalized = (char)0;
          }
        }
      }
    }
#line 1502
    goto switch_break;
    case_10: /* CIL Label */ 
    case_9: /* CIL Label */ 
#line 1506
    if ((unsigned int )state == 1U) {
#line 1507
      state = (enum __anonenum_state_4 )0;
    } else
#line 1508
    if ((unsigned int )state == 2U) {
#line 1508
      if (nAtts < attsMax) {
#line 1509
        (atts + nAtts)->normalized = (char)0;
      }
    }
#line 1510
    goto switch_break;
    case_17: /* CIL Label */ 
    case_11: /* CIL Label */ 
#line 1513
    if ((unsigned int )state != 2U) {
#line 1514
      return (nAtts);
    }
#line 1515
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 1517
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 1439
    ptr ++;
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 1523 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmltok_impl.c"
static int normal_charRefNumber(ENCODING const   *enc , char const   *ptr ) 
{ 
  int result ;
  int c___0 ;
  int c___1 ;
  int tmp ;

  {
#line 1526
  result = 0;
#line 1528
  ptr += 2;
#line 1529
  if ((int const   )*ptr == 120) {
#line 1530
    ptr ++;
    {
#line 1530
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1530
      if (! (! ((int const   )*ptr == 59))) {
#line 1530
        goto while_break;
      }
#line 1533
      c___0 = (int )*ptr;
      {
#line 1536
      if (c___0 == 57) {
#line 1536
        goto case_57;
      }
#line 1536
      if (c___0 == 56) {
#line 1536
        goto case_57;
      }
#line 1536
      if (c___0 == 55) {
#line 1536
        goto case_57;
      }
#line 1536
      if (c___0 == 54) {
#line 1536
        goto case_57;
      }
#line 1536
      if (c___0 == 53) {
#line 1536
        goto case_57;
      }
#line 1536
      if (c___0 == 52) {
#line 1536
        goto case_57;
      }
#line 1536
      if (c___0 == 51) {
#line 1536
        goto case_57;
      }
#line 1536
      if (c___0 == 50) {
#line 1536
        goto case_57;
      }
#line 1536
      if (c___0 == 49) {
#line 1536
        goto case_57;
      }
#line 1536
      if (c___0 == 48) {
#line 1536
        goto case_57;
      }
#line 1541
      if (c___0 == 70) {
#line 1541
        goto case_70;
      }
#line 1541
      if (c___0 == 69) {
#line 1541
        goto case_70;
      }
#line 1541
      if (c___0 == 68) {
#line 1541
        goto case_70;
      }
#line 1541
      if (c___0 == 67) {
#line 1541
        goto case_70;
      }
#line 1541
      if (c___0 == 66) {
#line 1541
        goto case_70;
      }
#line 1541
      if (c___0 == 65) {
#line 1541
        goto case_70;
      }
#line 1546
      if (c___0 == 102) {
#line 1546
        goto case_102;
      }
#line 1546
      if (c___0 == 101) {
#line 1546
        goto case_102;
      }
#line 1546
      if (c___0 == 100) {
#line 1546
        goto case_102;
      }
#line 1546
      if (c___0 == 99) {
#line 1546
        goto case_102;
      }
#line 1546
      if (c___0 == 98) {
#line 1546
        goto case_102;
      }
#line 1546
      if (c___0 == 97) {
#line 1546
        goto case_102;
      }
#line 1534
      goto switch_break;
      case_57: /* CIL Label */ 
      case_56: /* CIL Label */ 
      case_55: /* CIL Label */ 
      case_54: /* CIL Label */ 
      case_53: /* CIL Label */ 
      case_52: /* CIL Label */ 
      case_51: /* CIL Label */ 
      case_50: /* CIL Label */ 
      case_49: /* CIL Label */ 
      case_48: /* CIL Label */ 
#line 1537
      result <<= 4;
#line 1538
      result |= c___0 - 48;
#line 1539
      goto switch_break;
      case_70: /* CIL Label */ 
      case_69: /* CIL Label */ 
      case_68: /* CIL Label */ 
      case_67: /* CIL Label */ 
      case_66: /* CIL Label */ 
      case_65: /* CIL Label */ 
#line 1542
      result <<= 4;
#line 1543
      result += 10 + (c___0 - 65);
#line 1544
      goto switch_break;
      case_102: /* CIL Label */ 
      case_101: /* CIL Label */ 
      case_100: /* CIL Label */ 
      case_99: /* CIL Label */ 
      case_98: /* CIL Label */ 
      case_97: /* CIL Label */ 
#line 1547
      result <<= 4;
#line 1548
      result += 10 + (c___0 - 97);
#line 1549
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
#line 1551
      if (result >= 1114112) {
#line 1552
        return (-1);
      }
#line 1530
      ptr ++;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
    {
#line 1556
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1556
      if (! (! ((int const   )*ptr == 59))) {
#line 1556
        goto while_break___0;
      }
#line 1557
      c___1 = (int )*ptr;
#line 1558
      result *= 10;
#line 1559
      result += c___1 - 48;
#line 1560
      if (result >= 1114112) {
#line 1561
        return (-1);
      }
#line 1556
      ptr ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  {
#line 1564
  tmp = checkCharRefNumber(result);
  }
#line 1564
  return (tmp);
}
}
#line 1567 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmltok_impl.c"
static int normal_predefinedEntityName(ENCODING const   *enc , char const   *ptr ,
                                       char const   *end ) 
{ 


  {
  {
#line 1572
  if (end - ptr == 2L) {
#line 1572
    goto case_2;
  }
#line 1582
  if (end - ptr == 3L) {
#line 1582
    goto case_3;
  }
#line 1592
  if (end - ptr == 4L) {
#line 1592
    goto case_4;
  }
#line 1571
  goto switch_break;
  case_2: /* CIL Label */ 
#line 1573
  if ((int const   )*(ptr + 1) == 116) {
    {
#line 1575
    if ((int const   )*ptr == 108) {
#line 1575
      goto case_108;
    }
#line 1577
    if ((int const   )*ptr == 103) {
#line 1577
      goto case_103;
    }
#line 1574
    goto switch_break___0;
    case_108: /* CIL Label */ 
#line 1576
    return (60);
    case_103: /* CIL Label */ 
#line 1578
    return (62);
    switch_break___0: /* CIL Label */ ;
    }
  }
#line 1581
  goto switch_break;
  case_3: /* CIL Label */ 
#line 1583
  if ((int const   )*ptr == 97) {
#line 1584
    ptr ++;
#line 1585
    if ((int const   )*ptr == 109) {
#line 1586
      ptr ++;
#line 1587
      if ((int const   )*ptr == 112) {
#line 1588
        return (38);
      }
    }
  }
#line 1591
  goto switch_break;
  case_4: /* CIL Label */ 
  {
#line 1594
  if ((int const   )*ptr == 113) {
#line 1594
    goto case_113;
  }
#line 1605
  if ((int const   )*ptr == 97) {
#line 1605
    goto case_97;
  }
#line 1593
  goto switch_break___1;
  case_113: /* CIL Label */ 
#line 1595
  ptr ++;
#line 1596
  if ((int const   )*ptr == 117) {
#line 1597
    ptr ++;
#line 1598
    if ((int const   )*ptr == 111) {
#line 1599
      ptr ++;
#line 1600
      if ((int const   )*ptr == 116) {
#line 1601
        return (34);
      }
    }
  }
#line 1604
  goto switch_break___1;
  case_97: /* CIL Label */ 
#line 1606
  ptr ++;
#line 1607
  if ((int const   )*ptr == 112) {
#line 1608
    ptr ++;
#line 1609
    if ((int const   )*ptr == 111) {
#line 1610
      ptr ++;
#line 1611
      if ((int const   )*ptr == 115) {
#line 1612
        return (39);
      }
    }
  }
#line 1615
  goto switch_break___1;
  switch_break___1: /* CIL Label */ ;
  }
  switch_break: /* CIL Label */ ;
  }
#line 1618
  return (0);
}
}
#line 1621 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmltok_impl.c"
static int normal_sameName(ENCODING const   *enc , char const   *ptr1 , char const   *ptr2 ) 
{ 
  char const   *tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;
  char const   *tmp___4 ;
  char const   *tmp___5 ;
  char const   *tmp___6 ;
  char const   *tmp___7 ;
  char const   *tmp___8 ;

  {
  {
#line 1624
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1630
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr1] == 7) {
#line 1630
      goto case_7;
    }
#line 1630
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr1] == 6) {
#line 1630
      goto case_6;
    }
#line 1630
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr1] == 5) {
#line 1630
      goto case_5;
    }
#line 1644
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr1] == 27) {
#line 1644
      goto case_27;
    }
#line 1644
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr1] == 26) {
#line 1644
      goto case_27;
    }
#line 1644
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr1] == 25) {
#line 1644
      goto case_27;
    }
#line 1644
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr1] == 24) {
#line 1644
      goto case_27;
    }
#line 1644
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr1] == 23) {
#line 1644
      goto case_27;
    }
#line 1644
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr1] == 22) {
#line 1644
      goto case_27;
    }
#line 1644
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr1] == 29) {
#line 1644
      goto case_27;
    }
#line 1660
    goto switch_default;
    case_7: /* CIL Label */ 
#line 1630
    tmp = ptr1;
#line 1630
    ptr1 ++;
#line 1630
    tmp___0 = ptr2;
#line 1630
    ptr2 ++;
#line 1630
    if ((int const   )*tmp != (int const   )*tmp___0) {
#line 1630
      return (0);
    }
    case_6: /* CIL Label */ 
#line 1630
    tmp___1 = ptr1;
#line 1630
    ptr1 ++;
#line 1630
    tmp___2 = ptr2;
#line 1630
    ptr2 ++;
#line 1630
    if ((int const   )*tmp___1 != (int const   )*tmp___2) {
#line 1630
      return (0);
    }
    case_5: /* CIL Label */ 
#line 1630
    tmp___3 = ptr1;
#line 1630
    ptr1 ++;
#line 1630
    tmp___4 = ptr2;
#line 1630
    ptr2 ++;
#line 1630
    if ((int const   )*tmp___3 != (int const   )*tmp___4) {
#line 1630
      return (0);
    }
#line 1633
    tmp___5 = ptr1;
#line 1633
    ptr1 ++;
#line 1633
    tmp___6 = ptr2;
#line 1633
    ptr2 ++;
#line 1633
    if ((int const   )*tmp___5 != (int const   )*tmp___6) {
#line 1634
      return (0);
    }
#line 1635
    goto switch_break;
    case_27: /* CIL Label */ 
    case_26: /* CIL Label */ 
    case_25: /* CIL Label */ 
    case_24: /* CIL Label */ 
    case_23: /* CIL Label */ 
    case_22: /* CIL Label */ 
    case_29: /* CIL Label */ 
#line 1645
    tmp___7 = ptr2;
#line 1645
    ptr2 ++;
#line 1645
    tmp___8 = ptr1;
#line 1645
    ptr1 ++;
#line 1645
    if ((int const   )*tmp___7 != (int const   )*tmp___8) {
#line 1646
      return (0);
    }
#line 1659
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 1661
    if ((int const   )*ptr1 == (int const   )*ptr2) {
#line 1662
      return (1);
    }
    {
#line 1675
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr2] == 27) {
#line 1675
      goto case_27___0;
    }
#line 1675
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr2] == 26) {
#line 1675
      goto case_27___0;
    }
#line 1675
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr2] == 25) {
#line 1675
      goto case_27___0;
    }
#line 1675
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr2] == 24) {
#line 1675
      goto case_27___0;
    }
#line 1675
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr2] == 23) {
#line 1675
      goto case_27___0;
    }
#line 1675
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr2] == 22) {
#line 1675
      goto case_27___0;
    }
#line 1675
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr2] == 29) {
#line 1675
      goto case_27___0;
    }
#line 1675
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr2] == 7) {
#line 1675
      goto case_27___0;
    }
#line 1675
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr2] == 6) {
#line 1675
      goto case_27___0;
    }
#line 1675
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr2] == 5) {
#line 1675
      goto case_27___0;
    }
#line 1677
    goto switch_default___0;
    case_27___0: /* CIL Label */ 
    case_26___0: /* CIL Label */ 
    case_25___0: /* CIL Label */ 
    case_24___0: /* CIL Label */ 
    case_23___0: /* CIL Label */ 
    case_22___0: /* CIL Label */ 
    case_29___0: /* CIL Label */ 
    case_7___0: /* CIL Label */ 
    case_6___0: /* CIL Label */ 
    case_5___0: /* CIL Label */ 
#line 1676
    return (0);
    switch_default___0: /* CIL Label */ 
#line 1678
    return (1);
    switch_break___0: /* CIL Label */ ;
    }
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 1685 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmltok_impl.c"
static int normal_nameMatchesAscii(ENCODING const   *enc , char const   *ptr1 , char const   *end1 ,
                                   char const   *ptr2 ) 
{ 


  {
  {
#line 1689
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1689
    if (! *ptr2) {
#line 1689
      goto while_break;
    }
#line 1690
    if ((unsigned long )ptr1 == (unsigned long )end1) {
#line 1691
      return (0);
    }
#line 1692
    if (! ((int const   )*ptr1 == (int const   )*ptr2)) {
#line 1693
      return (0);
    }
#line 1689
    ptr1 ++;
#line 1689
    ptr2 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1695
  return ((unsigned long )ptr1 == (unsigned long )end1);
}
}
#line 1698 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmltok_impl.c"
static int normal_nameLength(ENCODING const   *enc , char const   *ptr ) 
{ 
  char const   *start ;

  {
#line 1701
  start = ptr;
  {
#line 1702
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1706
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 5) {
#line 1706
      goto case_5;
    }
#line 1706
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 6) {
#line 1706
      goto case_6;
    }
#line 1706
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 7) {
#line 1706
      goto case_7;
    }
#line 1716
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 27) {
#line 1716
      goto case_27;
    }
#line 1716
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 26) {
#line 1716
      goto case_27;
    }
#line 1716
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 25) {
#line 1716
      goto case_27;
    }
#line 1716
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 24) {
#line 1716
      goto case_27;
    }
#line 1716
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 23) {
#line 1716
      goto case_27;
    }
#line 1716
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 22) {
#line 1716
      goto case_27;
    }
#line 1716
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 29) {
#line 1716
      goto case_27;
    }
#line 1719
    goto switch_default;
    case_5: /* CIL Label */ 
#line 1706
    ptr += 2;
#line 1706
    goto switch_break;
    case_6: /* CIL Label */ 
#line 1706
    ptr += 3;
#line 1706
    goto switch_break;
    case_7: /* CIL Label */ 
#line 1706
    ptr += 4;
#line 1706
    goto switch_break;
    case_27: /* CIL Label */ 
    case_26: /* CIL Label */ 
    case_25: /* CIL Label */ 
    case_24: /* CIL Label */ 
    case_23: /* CIL Label */ 
    case_22: /* CIL Label */ 
    case_29: /* CIL Label */ 
#line 1717
    ptr ++;
#line 1718
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 1720
    return ((int )(ptr - start));
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 1725 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmltok_impl.c"
static char const   *normal_skipS(ENCODING const   *enc , char const   *ptr ) 
{ 


  {
  {
#line 1728
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1732
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 21) {
#line 1732
      goto case_21;
    }
#line 1732
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 9) {
#line 1732
      goto case_21;
    }
#line 1732
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 10) {
#line 1732
      goto case_21;
    }
#line 1735
    goto switch_default;
    case_21: /* CIL Label */ 
    case_9: /* CIL Label */ 
    case_10: /* CIL Label */ 
#line 1733
    ptr ++;
#line 1734
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 1736
    return (ptr);
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 1741 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmltok_impl.c"
static void normal_updatePosition(ENCODING const   *enc , char const   *ptr , char const   *end ,
                                  POSITION *pos ) 
{ 


  {
  {
#line 1747
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1747
    if (! ((unsigned long )ptr < (unsigned long )end)) {
#line 1747
      goto while_break;
    }
    {
#line 1753
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 5) {
#line 1753
      goto case_5;
    }
#line 1753
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 6) {
#line 1753
      goto case_6;
    }
#line 1753
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 7) {
#line 1753
      goto case_7;
    }
#line 1755
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 10) {
#line 1755
      goto case_10;
    }
#line 1760
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 9) {
#line 1760
      goto case_9;
    }
#line 1767
    goto switch_default;
    case_5: /* CIL Label */ 
#line 1753
    ptr += 2;
#line 1753
    goto switch_break;
    case_6: /* CIL Label */ 
#line 1753
    ptr += 3;
#line 1753
    goto switch_break;
    case_7: /* CIL Label */ 
#line 1753
    ptr += 4;
#line 1753
    goto switch_break;
    case_10: /* CIL Label */ 
#line 1756
    pos->columnNumber = (XML_Size )-1;
#line 1757
    (pos->lineNumber) ++;
#line 1758
    ptr ++;
#line 1759
    goto switch_break;
    case_9: /* CIL Label */ 
#line 1761
    (pos->lineNumber) ++;
#line 1762
    ptr ++;
#line 1763
    if ((unsigned long )ptr != (unsigned long )end) {
#line 1763
      if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 10) {
#line 1764
        ptr ++;
      }
    }
#line 1765
    pos->columnNumber = (XML_Size )-1;
#line 1766
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 1768
    ptr ++;
#line 1769
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 1771
    (pos->columnNumber) ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1773
  return;
}
}
#line 321 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmltok.c"
static void utf8_toUtf8(ENCODING const   *enc , char const   **fromP , char const   *fromLim ,
                        char **toP , char const   *toLim ) 
{ 
  char *to ;
  char const   *from ;

  {
#line 328
  if (fromLim - *fromP > toLim - (char const   *)*toP) {
#line 330
    fromLim = *fromP + (toLim - (char const   *)*toP);
    {
#line 330
    while (1) {
      while_continue: /* CIL Label */ ;
#line 330
      if (! ((unsigned long )fromLim > (unsigned long )*fromP)) {
#line 330
        goto while_break;
      }
#line 331
      if (((int )((unsigned char )*(fromLim + -1)) & 192) != 128) {
#line 332
        goto while_break;
      }
#line 330
      fromLim --;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 334
  to = *toP;
#line 334
  from = *fromP;
  {
#line 334
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 334
    if (! ((unsigned long )from != (unsigned long )fromLim)) {
#line 334
      goto while_break___0;
    }
#line 335
    *to = (char )*from;
#line 334
    from ++;
#line 334
    to ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 336
  *fromP = from;
#line 337
  *toP = to;
#line 338
  return;
}
}
#line 340 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmltok.c"
static void utf8_toUtf16(ENCODING const   *enc , char const   **fromP , char const   *fromLim ,
                         unsigned short **toP , unsigned short const   *toLim ) 
{ 
  unsigned short *to ;
  char const   *from ;
  unsigned short *tmp ;
  unsigned short *tmp___0 ;
  unsigned long n ;
  unsigned short *tmp___1 ;
  char const   *tmp___2 ;

  {
#line 345
  to = *toP;
#line 346
  from = *fromP;
  {
#line 347
  while (1) {
    while_continue: /* CIL Label */ ;
#line 347
    if ((unsigned long )from != (unsigned long )fromLim) {
#line 347
      if (! ((unsigned long )to != (unsigned long )toLim)) {
#line 347
        goto while_break;
      }
    } else {
#line 347
      goto while_break;
    }
    {
#line 349
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*from] == 5) {
#line 349
      goto case_5;
    }
#line 353
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*from] == 6) {
#line 353
      goto case_6;
    }
#line 358
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*from] == 7) {
#line 358
      goto case_7;
    }
#line 372
    goto switch_default;
    case_5: /* CIL Label */ 
#line 350
    tmp = to;
#line 350
    to ++;
#line 350
    *tmp = (unsigned short )((((int const   )*(from + 0) & 31) << 6) | ((int const   )*(from + 1) & 63));
#line 351
    from += 2;
#line 352
    goto switch_break;
    case_6: /* CIL Label */ 
#line 354
    tmp___0 = to;
#line 354
    to ++;
#line 354
    *tmp___0 = (unsigned short )(((((int const   )*(from + 0) & 15) << 12) | (((int const   )*(from + 1) & 63) << 6)) | ((int const   )*(from + 2) & 63));
#line 356
    from += 3;
#line 357
    goto switch_break;
    case_7: /* CIL Label */ 
#line 361
    if ((unsigned long )(to + 1) == (unsigned long )toLim) {
#line 362
      goto after;
    }
#line 363
    n = (unsigned long )((((((int const   )*(from + 0) & 7) << 18) | (((int const   )*(from + 1) & 63) << 12)) | (((int const   )*(from + 2) & 63) << 6)) | ((int const   )*(from + 3) & 63));
#line 365
    n -= 65536UL;
#line 366
    *(to + 0) = (unsigned short )((n >> 10) | 55296UL);
#line 367
    *(to + 1) = (unsigned short )((n & 1023UL) | 56320UL);
#line 368
    to += 2;
#line 369
    from += 4;
#line 371
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 373
    tmp___1 = to;
#line 373
    to ++;
#line 373
    tmp___2 = from;
#line 373
    from ++;
#line 373
    *tmp___1 = (unsigned short )*tmp___2;
#line 374
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
  after: 
#line 378
  *fromP = from;
#line 379
  *toP = to;
#line 380
  return;
}
}
#line 383 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmltok.c"
static struct normal_encoding  const  utf8_encoding_ns  = 
#line 383
     {{{& normal_prologTok, & normal_contentTok, & normal_cdataSectionTok, & normal_ignoreSectionTok},
     {& normal_attributeValueTok, & normal_entityValueTok}, & normal_sameName, & normal_nameMatchesAscii,
     & normal_nameLength, & normal_skipS, & normal_getAtts, & normal_charRefNumber,
     & normal_predefinedEntityName, & normal_updatePosition, & normal_isPublicId,
     & utf8_toUtf8, & utf8_toUtf16, 1, (char)1, (char)0}, {(unsigned char)0, (unsigned char)0,
                                                           (unsigned char)0, (unsigned char)0,
                                                           (unsigned char)0, (unsigned char)0,
                                                           (unsigned char)0, (unsigned char)0,
                                                           (unsigned char)0, (unsigned char)21,
                                                           (unsigned char)10, (unsigned char)0,
                                                           (unsigned char)0, (unsigned char)9,
                                                           (unsigned char)0, (unsigned char)0,
                                                           (unsigned char)0, (unsigned char)0,
                                                           (unsigned char)0, (unsigned char)0,
                                                           (unsigned char)0, (unsigned char)0,
                                                           (unsigned char)0, (unsigned char)0,
                                                           (unsigned char)0, (unsigned char)0,
                                                           (unsigned char)0, (unsigned char)0,
                                                           (unsigned char)0, (unsigned char)0,
                                                           (unsigned char)0, (unsigned char)0,
                                                           (unsigned char)21, (unsigned char)16,
                                                           (unsigned char)12, (unsigned char)19,
                                                           (unsigned char)28, (unsigned char)30,
                                                           (unsigned char)3, (unsigned char)13,
                                                           (unsigned char)31, (unsigned char)32,
                                                           (unsigned char)33, (unsigned char)34,
                                                           (unsigned char)35, (unsigned char)27,
                                                           (unsigned char)26, (unsigned char)17,
                                                           (unsigned char)25, (unsigned char)25,
                                                           (unsigned char)25, (unsigned char)25,
                                                           (unsigned char)25, (unsigned char)25,
                                                           (unsigned char)25, (unsigned char)25,
                                                           (unsigned char)25, (unsigned char)25,
                                                           (unsigned char)23, (unsigned char)18,
                                                           (unsigned char)2, (unsigned char)14,
                                                           (unsigned char)11, (unsigned char)15,
                                                           (unsigned char)28, (unsigned char)24,
                                                           (unsigned char)24, (unsigned char)24,
                                                           (unsigned char)24, (unsigned char)24,
                                                           (unsigned char)24, (unsigned char)22,
                                                           (unsigned char)22, (unsigned char)22,
                                                           (unsigned char)22, (unsigned char)22,
                                                           (unsigned char)22, (unsigned char)22,
                                                           (unsigned char)22, (unsigned char)22,
                                                           (unsigned char)22, (unsigned char)22,
                                                           (unsigned char)22, (unsigned char)22,
                                                           (unsigned char)22, (unsigned char)22,
                                                           (unsigned char)22, (unsigned char)22,
                                                           (unsigned char)22, (unsigned char)22,
                                                           (unsigned char)22, (unsigned char)20,
                                                           (unsigned char)28, (unsigned char)4,
                                                           (unsigned char)28, (unsigned char)22,
                                                           (unsigned char)28, (unsigned char)24,
                                                           (unsigned char)24, (unsigned char)24,
                                                           (unsigned char)24, (unsigned char)24,
                                                           (unsigned char)24, (unsigned char)22,
                                                           (unsigned char)22, (unsigned char)22,
                                                           (unsigned char)22, (unsigned char)22,
                                                           (unsigned char)22, (unsigned char)22,
                                                           (unsigned char)22, (unsigned char)22,
                                                           (unsigned char)22, (unsigned char)22,
                                                           (unsigned char)22, (unsigned char)22,
                                                           (unsigned char)22, (unsigned char)22,
                                                           (unsigned char)22, (unsigned char)22,
                                                           (unsigned char)22, (unsigned char)22,
                                                           (unsigned char)22, (unsigned char)28,
                                                           (unsigned char)36, (unsigned char)28,
                                                           (unsigned char)28, (unsigned char)28,
                                                           (unsigned char)8, (unsigned char)8,
                                                           (unsigned char)8, (unsigned char)8,
                                                           (unsigned char)8, (unsigned char)8,
                                                           (unsigned char)8, (unsigned char)8,
                                                           (unsigned char)8, (unsigned char)8,
                                                           (unsigned char)8, (unsigned char)8,
                                                           (unsigned char)8, (unsigned char)8,
                                                           (unsigned char)8, (unsigned char)8,
                                                           (unsigned char)8, (unsigned char)8,
                                                           (unsigned char)8, (unsigned char)8,
                                                           (unsigned char)8, (unsigned char)8,
                                                           (unsigned char)8, (unsigned char)8,
                                                           (unsigned char)8, (unsigned char)8,
                                                           (unsigned char)8, (unsigned char)8,
                                                           (unsigned char)8, (unsigned char)8,
                                                           (unsigned char)8, (unsigned char)8,
                                                           (unsigned char)8, (unsigned char)8,
                                                           (unsigned char)8, (unsigned char)8,
                                                           (unsigned char)8, (unsigned char)8,
                                                           (unsigned char)8, (unsigned char)8,
                                                           (unsigned char)8, (unsigned char)8,
                                                           (unsigned char)8, (unsigned char)8,
                                                           (unsigned char)8, (unsigned char)8,
                                                           (unsigned char)8, (unsigned char)8,
                                                           (unsigned char)8, (unsigned char)8,
                                                           (unsigned char)8, (unsigned char)8,
                                                           (unsigned char)8, (unsigned char)8,
                                                           (unsigned char)8, (unsigned char)8,
                                                           (unsigned char)8, (unsigned char)8,
                                                           (unsigned char)8, (unsigned char)8,
                                                           (unsigned char)8, (unsigned char)8,
                                                           (unsigned char)8, (unsigned char)8,
                                                           (unsigned char)5, (unsigned char)5,
                                                           (unsigned char)5, (unsigned char)5,
                                                           (unsigned char)5, (unsigned char)5,
                                                           (unsigned char)5, (unsigned char)5,
                                                           (unsigned char)5, (unsigned char)5,
                                                           (unsigned char)5, (unsigned char)5,
                                                           (unsigned char)5, (unsigned char)5,
                                                           (unsigned char)5, (unsigned char)5,
                                                           (unsigned char)5, (unsigned char)5,
                                                           (unsigned char)5, (unsigned char)5,
                                                           (unsigned char)5, (unsigned char)5,
                                                           (unsigned char)5, (unsigned char)5,
                                                           (unsigned char)5, (unsigned char)5,
                                                           (unsigned char)5, (unsigned char)5,
                                                           (unsigned char)5, (unsigned char)5,
                                                           (unsigned char)5, (unsigned char)5,
                                                           (unsigned char)6, (unsigned char)6,
                                                           (unsigned char)6, (unsigned char)6,
                                                           (unsigned char)6, (unsigned char)6,
                                                           (unsigned char)6, (unsigned char)6,
                                                           (unsigned char)6, (unsigned char)6,
                                                           (unsigned char)6, (unsigned char)6,
                                                           (unsigned char)6, (unsigned char)6,
                                                           (unsigned char)6, (unsigned char)6,
                                                           (unsigned char)7, (unsigned char)7,
                                                           (unsigned char)7, (unsigned char)7,
                                                           (unsigned char)7, (unsigned char)0,
                                                           (unsigned char)0, (unsigned char)0,
                                                           (unsigned char)0, (unsigned char)0,
                                                           (unsigned char)0, (unsigned char)0,
                                                           (unsigned char)0, (unsigned char)0,
                                                           (unsigned char)1, (unsigned char)1},
    & utf8_isName2, & utf8_isName3, & isNever, & utf8_isNmstrt2, & utf8_isNmstrt3,
    & isNever, & utf8_isInvalid2, & utf8_isInvalid3, & utf8_isInvalid4};
#line 393 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmltok.c"
static struct normal_encoding  const  utf8_encoding  = 
#line 393
     {{{& normal_prologTok, & normal_contentTok, & normal_cdataSectionTok, & normal_ignoreSectionTok},
     {& normal_attributeValueTok, & normal_entityValueTok}, & normal_sameName, & normal_nameMatchesAscii,
     & normal_nameLength, & normal_skipS, & normal_getAtts, & normal_charRefNumber,
     & normal_predefinedEntityName, & normal_updatePosition, & normal_isPublicId,
     & utf8_toUtf8, & utf8_toUtf16, 1, (char)1, (char)0}, {(unsigned char)0, (unsigned char)0,
                                                           (unsigned char)0, (unsigned char)0,
                                                           (unsigned char)0, (unsigned char)0,
                                                           (unsigned char)0, (unsigned char)0,
                                                           (unsigned char)0, (unsigned char)21,
                                                           (unsigned char)10, (unsigned char)0,
                                                           (unsigned char)0, (unsigned char)9,
                                                           (unsigned char)0, (unsigned char)0,
                                                           (unsigned char)0, (unsigned char)0,
                                                           (unsigned char)0, (unsigned char)0,
                                                           (unsigned char)0, (unsigned char)0,
                                                           (unsigned char)0, (unsigned char)0,
                                                           (unsigned char)0, (unsigned char)0,
                                                           (unsigned char)0, (unsigned char)0,
                                                           (unsigned char)0, (unsigned char)0,
                                                           (unsigned char)0, (unsigned char)0,
                                                           (unsigned char)21, (unsigned char)16,
                                                           (unsigned char)12, (unsigned char)19,
                                                           (unsigned char)28, (unsigned char)30,
                                                           (unsigned char)3, (unsigned char)13,
                                                           (unsigned char)31, (unsigned char)32,
                                                           (unsigned char)33, (unsigned char)34,
                                                           (unsigned char)35, (unsigned char)27,
                                                           (unsigned char)26, (unsigned char)17,
                                                           (unsigned char)25, (unsigned char)25,
                                                           (unsigned char)25, (unsigned char)25,
                                                           (unsigned char)25, (unsigned char)25,
                                                           (unsigned char)25, (unsigned char)25,
                                                           (unsigned char)25, (unsigned char)25,
                                                           (unsigned char)22, (unsigned char)18,
                                                           (unsigned char)2, (unsigned char)14,
                                                           (unsigned char)11, (unsigned char)15,
                                                           (unsigned char)28, (unsigned char)24,
                                                           (unsigned char)24, (unsigned char)24,
                                                           (unsigned char)24, (unsigned char)24,
                                                           (unsigned char)24, (unsigned char)22,
                                                           (unsigned char)22, (unsigned char)22,
                                                           (unsigned char)22, (unsigned char)22,
                                                           (unsigned char)22, (unsigned char)22,
                                                           (unsigned char)22, (unsigned char)22,
                                                           (unsigned char)22, (unsigned char)22,
                                                           (unsigned char)22, (unsigned char)22,
                                                           (unsigned char)22, (unsigned char)22,
                                                           (unsigned char)22, (unsigned char)22,
                                                           (unsigned char)22, (unsigned char)22,
                                                           (unsigned char)22, (unsigned char)20,
                                                           (unsigned char)28, (unsigned char)4,
                                                           (unsigned char)28, (unsigned char)22,
                                                           (unsigned char)28, (unsigned char)24,
                                                           (unsigned char)24, (unsigned char)24,
                                                           (unsigned char)24, (unsigned char)24,
                                                           (unsigned char)24, (unsigned char)22,
                                                           (unsigned char)22, (unsigned char)22,
                                                           (unsigned char)22, (unsigned char)22,
                                                           (unsigned char)22, (unsigned char)22,
                                                           (unsigned char)22, (unsigned char)22,
                                                           (unsigned char)22, (unsigned char)22,
                                                           (unsigned char)22, (unsigned char)22,
                                                           (unsigned char)22, (unsigned char)22,
                                                           (unsigned char)22, (unsigned char)22,
                                                           (unsigned char)22, (unsigned char)22,
                                                           (unsigned char)22, (unsigned char)28,
                                                           (unsigned char)36, (unsigned char)28,
                                                           (unsigned char)28, (unsigned char)28,
                                                           (unsigned char)8, (unsigned char)8,
                                                           (unsigned char)8, (unsigned char)8,
                                                           (unsigned char)8, (unsigned char)8,
                                                           (unsigned char)8, (unsigned char)8,
                                                           (unsigned char)8, (unsigned char)8,
                                                           (unsigned char)8, (unsigned char)8,
                                                           (unsigned char)8, (unsigned char)8,
                                                           (unsigned char)8, (unsigned char)8,
                                                           (unsigned char)8, (unsigned char)8,
                                                           (unsigned char)8, (unsigned char)8,
                                                           (unsigned char)8, (unsigned char)8,
                                                           (unsigned char)8, (unsigned char)8,
                                                           (unsigned char)8, (unsigned char)8,
                                                           (unsigned char)8, (unsigned char)8,
                                                           (unsigned char)8, (unsigned char)8,
                                                           (unsigned char)8, (unsigned char)8,
                                                           (unsigned char)8, (unsigned char)8,
                                                           (unsigned char)8, (unsigned char)8,
                                                           (unsigned char)8, (unsigned char)8,
                                                           (unsigned char)8, (unsigned char)8,
                                                           (unsigned char)8, (unsigned char)8,
                                                           (unsigned char)8, (unsigned char)8,
                                                           (unsigned char)8, (unsigned char)8,
                                                           (unsigned char)8, (unsigned char)8,
                                                           (unsigned char)8, (unsigned char)8,
                                                           (unsigned char)8, (unsigned char)8,
                                                           (unsigned char)8, (unsigned char)8,
                                                           (unsigned char)8, (unsigned char)8,
                                                           (unsigned char)8, (unsigned char)8,
                                                           (unsigned char)8, (unsigned char)8,
                                                           (unsigned char)8, (unsigned char)8,
                                                           (unsigned char)8, (unsigned char)8,
                                                           (unsigned char)5, (unsigned char)5,
                                                           (unsigned char)5, (unsigned char)5,
                                                           (unsigned char)5, (unsigned char)5,
                                                           (unsigned char)5, (unsigned char)5,
                                                           (unsigned char)5, (unsigned char)5,
                                                           (unsigned char)5, (unsigned char)5,
                                                           (unsigned char)5, (unsigned char)5,
                                                           (unsigned char)5, (unsigned char)5,
                                                           (unsigned char)5, (unsigned char)5,
                                                           (unsigned char)5, (unsigned char)5,
                                                           (unsigned char)5, (unsigned char)5,
                                                           (unsigned char)5, (unsigned char)5,
                                                           (unsigned char)5, (unsigned char)5,
                                                           (unsigned char)5, (unsigned char)5,
                                                           (unsigned char)5, (unsigned char)5,
                                                           (unsigned char)5, (unsigned char)5,
                                                           (unsigned char)6, (unsigned char)6,
                                                           (unsigned char)6, (unsigned char)6,
                                                           (unsigned char)6, (unsigned char)6,
                                                           (unsigned char)6, (unsigned char)6,
                                                           (unsigned char)6, (unsigned char)6,
                                                           (unsigned char)6, (unsigned char)6,
                                                           (unsigned char)6, (unsigned char)6,
                                                           (unsigned char)6, (unsigned char)6,
                                                           (unsigned char)7, (unsigned char)7,
                                                           (unsigned char)7, (unsigned char)7,
                                                           (unsigned char)7, (unsigned char)0,
                                                           (unsigned char)0, (unsigned char)0,
                                                           (unsigned char)0, (unsigned char)0,
                                                           (unsigned char)0, (unsigned char)0,
                                                           (unsigned char)0, (unsigned char)0,
                                                           (unsigned char)1, (unsigned char)1},
    & utf8_isName2, & utf8_isName3, & isNever, & utf8_isNmstrt2, & utf8_isNmstrt3,
    & isNever, & utf8_isInvalid2, & utf8_isInvalid3, & utf8_isInvalid4};
#line 406 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmltok.c"
static struct normal_encoding  const  internal_utf8_encoding_ns  = 
#line 406
     {{{& normal_prologTok, & normal_contentTok, & normal_cdataSectionTok, & normal_ignoreSectionTok},
     {& normal_attributeValueTok, & normal_entityValueTok}, & normal_sameName, & normal_nameMatchesAscii,
     & normal_nameLength, & normal_skipS, & normal_getAtts, & normal_charRefNumber,
     & normal_predefinedEntityName, & normal_updatePosition, & normal_isPublicId,
     & utf8_toUtf8, & utf8_toUtf16, 1, (char)1, (char)0}, {(unsigned char)0, (unsigned char)0,
                                                           (unsigned char)0, (unsigned char)0,
                                                           (unsigned char)0, (unsigned char)0,
                                                           (unsigned char)0, (unsigned char)0,
                                                           (unsigned char)0, (unsigned char)21,
                                                           (unsigned char)10, (unsigned char)0,
                                                           (unsigned char)0, (unsigned char)21,
                                                           (unsigned char)0, (unsigned char)0,
                                                           (unsigned char)0, (unsigned char)0,
                                                           (unsigned char)0, (unsigned char)0,
                                                           (unsigned char)0, (unsigned char)0,
                                                           (unsigned char)0, (unsigned char)0,
                                                           (unsigned char)0, (unsigned char)0,
                                                           (unsigned char)0, (unsigned char)0,
                                                           (unsigned char)0, (unsigned char)0,
                                                           (unsigned char)0, (unsigned char)0,
                                                           (unsigned char)21, (unsigned char)16,
                                                           (unsigned char)12, (unsigned char)19,
                                                           (unsigned char)28, (unsigned char)30,
                                                           (unsigned char)3, (unsigned char)13,
                                                           (unsigned char)31, (unsigned char)32,
                                                           (unsigned char)33, (unsigned char)34,
                                                           (unsigned char)35, (unsigned char)27,
                                                           (unsigned char)26, (unsigned char)17,
                                                           (unsigned char)25, (unsigned char)25,
                                                           (unsigned char)25, (unsigned char)25,
                                                           (unsigned char)25, (unsigned char)25,
                                                           (unsigned char)25, (unsigned char)25,
                                                           (unsigned char)25, (unsigned char)25,
                                                           (unsigned char)23, (unsigned char)18,
                                                           (unsigned char)2, (unsigned char)14,
                                                           (unsigned char)11, (unsigned char)15,
                                                           (unsigned char)28, (unsigned char)24,
                                                           (unsigned char)24, (unsigned char)24,
                                                           (unsigned char)24, (unsigned char)24,
                                                           (unsigned char)24, (unsigned char)22,
                                                           (unsigned char)22, (unsigned char)22,
                                                           (unsigned char)22, (unsigned char)22,
                                                           (unsigned char)22, (unsigned char)22,
                                                           (unsigned char)22, (unsigned char)22,
                                                           (unsigned char)22, (unsigned char)22,
                                                           (unsigned char)22, (unsigned char)22,
                                                           (unsigned char)22, (unsigned char)22,
                                                           (unsigned char)22, (unsigned char)22,
                                                           (unsigned char)22, (unsigned char)22,
                                                           (unsigned char)22, (unsigned char)20,
                                                           (unsigned char)28, (unsigned char)4,
                                                           (unsigned char)28, (unsigned char)22,
                                                           (unsigned char)28, (unsigned char)24,
                                                           (unsigned char)24, (unsigned char)24,
                                                           (unsigned char)24, (unsigned char)24,
                                                           (unsigned char)24, (unsigned char)22,
                                                           (unsigned char)22, (unsigned char)22,
                                                           (unsigned char)22, (unsigned char)22,
                                                           (unsigned char)22, (unsigned char)22,
                                                           (unsigned char)22, (unsigned char)22,
                                                           (unsigned char)22, (unsigned char)22,
                                                           (unsigned char)22, (unsigned char)22,
                                                           (unsigned char)22, (unsigned char)22,
                                                           (unsigned char)22, (unsigned char)22,
                                                           (unsigned char)22, (unsigned char)22,
                                                           (unsigned char)22, (unsigned char)28,
                                                           (unsigned char)36, (unsigned char)28,
                                                           (unsigned char)28, (unsigned char)28,
                                                           (unsigned char)8, (unsigned char)8,
                                                           (unsigned char)8, (unsigned char)8,
                                                           (unsigned char)8, (unsigned char)8,
                                                           (unsigned char)8, (unsigned char)8,
                                                           (unsigned char)8, (unsigned char)8,
                                                           (unsigned char)8, (unsigned char)8,
                                                           (unsigned char)8, (unsigned char)8,
                                                           (unsigned char)8, (unsigned char)8,
                                                           (unsigned char)8, (unsigned char)8,
                                                           (unsigned char)8, (unsigned char)8,
                                                           (unsigned char)8, (unsigned char)8,
                                                           (unsigned char)8, (unsigned char)8,
                                                           (unsigned char)8, (unsigned char)8,
                                                           (unsigned char)8, (unsigned char)8,
                                                           (unsigned char)8, (unsigned char)8,
                                                           (unsigned char)8, (unsigned char)8,
                                                           (unsigned char)8, (unsigned char)8,
                                                           (unsigned char)8, (unsigned char)8,
                                                           (unsigned char)8, (unsigned char)8,
                                                           (unsigned char)8, (unsigned char)8,
                                                           (unsigned char)8, (unsigned char)8,
                                                           (unsigned char)8, (unsigned char)8,
                                                           (unsigned char)8, (unsigned char)8,
                                                           (unsigned char)8, (unsigned char)8,
                                                           (unsigned char)8, (unsigned char)8,
                                                           (unsigned char)8, (unsigned char)8,
                                                           (unsigned char)8, (unsigned char)8,
                                                           (unsigned char)8, (unsigned char)8,
                                                           (unsigned char)8, (unsigned char)8,
                                                           (unsigned char)8, (unsigned char)8,
                                                           (unsigned char)8, (unsigned char)8,
                                                           (unsigned char)8, (unsigned char)8,
                                                           (unsigned char)5, (unsigned char)5,
                                                           (unsigned char)5, (unsigned char)5,
                                                           (unsigned char)5, (unsigned char)5,
                                                           (unsigned char)5, (unsigned char)5,
                                                           (unsigned char)5, (unsigned char)5,
                                                           (unsigned char)5, (unsigned char)5,
                                                           (unsigned char)5, (unsigned char)5,
                                                           (unsigned char)5, (unsigned char)5,
                                                           (unsigned char)5, (unsigned char)5,
                                                           (unsigned char)5, (unsigned char)5,
                                                           (unsigned char)5, (unsigned char)5,
                                                           (unsigned char)5, (unsigned char)5,
                                                           (unsigned char)5, (unsigned char)5,
                                                           (unsigned char)5, (unsigned char)5,
                                                           (unsigned char)5, (unsigned char)5,
                                                           (unsigned char)5, (unsigned char)5,
                                                           (unsigned char)6, (unsigned char)6,
                                                           (unsigned char)6, (unsigned char)6,
                                                           (unsigned char)6, (unsigned char)6,
                                                           (unsigned char)6, (unsigned char)6,
                                                           (unsigned char)6, (unsigned char)6,
                                                           (unsigned char)6, (unsigned char)6,
                                                           (unsigned char)6, (unsigned char)6,
                                                           (unsigned char)6, (unsigned char)6,
                                                           (unsigned char)7, (unsigned char)7,
                                                           (unsigned char)7, (unsigned char)7,
                                                           (unsigned char)7, (unsigned char)0,
                                                           (unsigned char)0, (unsigned char)0,
                                                           (unsigned char)0, (unsigned char)0,
                                                           (unsigned char)0, (unsigned char)0,
                                                           (unsigned char)0, (unsigned char)0,
                                                           (unsigned char)1, (unsigned char)1},
    & utf8_isName2, & utf8_isName3, & isNever, & utf8_isNmstrt2, & utf8_isNmstrt3,
    & isNever, & utf8_isInvalid2, & utf8_isInvalid3, & utf8_isInvalid4};
#line 417 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmltok.c"
static struct normal_encoding  const  internal_utf8_encoding  = 
#line 417
     {{{& normal_prologTok, & normal_contentTok, & normal_cdataSectionTok, & normal_ignoreSectionTok},
     {& normal_attributeValueTok, & normal_entityValueTok}, & normal_sameName, & normal_nameMatchesAscii,
     & normal_nameLength, & normal_skipS, & normal_getAtts, & normal_charRefNumber,
     & normal_predefinedEntityName, & normal_updatePosition, & normal_isPublicId,
     & utf8_toUtf8, & utf8_toUtf16, 1, (char)1, (char)0}, {(unsigned char)0, (unsigned char)0,
                                                           (unsigned char)0, (unsigned char)0,
                                                           (unsigned char)0, (unsigned char)0,
                                                           (unsigned char)0, (unsigned char)0,
                                                           (unsigned char)0, (unsigned char)21,
                                                           (unsigned char)10, (unsigned char)0,
                                                           (unsigned char)0, (unsigned char)21,
                                                           (unsigned char)0, (unsigned char)0,
                                                           (unsigned char)0, (unsigned char)0,
                                                           (unsigned char)0, (unsigned char)0,
                                                           (unsigned char)0, (unsigned char)0,
                                                           (unsigned char)0, (unsigned char)0,
                                                           (unsigned char)0, (unsigned char)0,
                                                           (unsigned char)0, (unsigned char)0,
                                                           (unsigned char)0, (unsigned char)0,
                                                           (unsigned char)0, (unsigned char)0,
                                                           (unsigned char)21, (unsigned char)16,
                                                           (unsigned char)12, (unsigned char)19,
                                                           (unsigned char)28, (unsigned char)30,
                                                           (unsigned char)3, (unsigned char)13,
                                                           (unsigned char)31, (unsigned char)32,
                                                           (unsigned char)33, (unsigned char)34,
                                                           (unsigned char)35, (unsigned char)27,
                                                           (unsigned char)26, (unsigned char)17,
                                                           (unsigned char)25, (unsigned char)25,
                                                           (unsigned char)25, (unsigned char)25,
                                                           (unsigned char)25, (unsigned char)25,
                                                           (unsigned char)25, (unsigned char)25,
                                                           (unsigned char)25, (unsigned char)25,
                                                           (unsigned char)22, (unsigned char)18,
                                                           (unsigned char)2, (unsigned char)14,
                                                           (unsigned char)11, (unsigned char)15,
                                                           (unsigned char)28, (unsigned char)24,
                                                           (unsigned char)24, (unsigned char)24,
                                                           (unsigned char)24, (unsigned char)24,
                                                           (unsigned char)24, (unsigned char)22,
                                                           (unsigned char)22, (unsigned char)22,
                                                           (unsigned char)22, (unsigned char)22,
                                                           (unsigned char)22, (unsigned char)22,
                                                           (unsigned char)22, (unsigned char)22,
                                                           (unsigned char)22, (unsigned char)22,
                                                           (unsigned char)22, (unsigned char)22,
                                                           (unsigned char)22, (unsigned char)22,
                                                           (unsigned char)22, (unsigned char)22,
                                                           (unsigned char)22, (unsigned char)22,
                                                           (unsigned char)22, (unsigned char)20,
                                                           (unsigned char)28, (unsigned char)4,
                                                           (unsigned char)28, (unsigned char)22,
                                                           (unsigned char)28, (unsigned char)24,
                                                           (unsigned char)24, (unsigned char)24,
                                                           (unsigned char)24, (unsigned char)24,
                                                           (unsigned char)24, (unsigned char)22,
                                                           (unsigned char)22, (unsigned char)22,
                                                           (unsigned char)22, (unsigned char)22,
                                                           (unsigned char)22, (unsigned char)22,
                                                           (unsigned char)22, (unsigned char)22,
                                                           (unsigned char)22, (unsigned char)22,
                                                           (unsigned char)22, (unsigned char)22,
                                                           (unsigned char)22, (unsigned char)22,
                                                           (unsigned char)22, (unsigned char)22,
                                                           (unsigned char)22, (unsigned char)22,
                                                           (unsigned char)22, (unsigned char)28,
                                                           (unsigned char)36, (unsigned char)28,
                                                           (unsigned char)28, (unsigned char)28,
                                                           (unsigned char)8, (unsigned char)8,
                                                           (unsigned char)8, (unsigned char)8,
                                                           (unsigned char)8, (unsigned char)8,
                                                           (unsigned char)8, (unsigned char)8,
                                                           (unsigned char)8, (unsigned char)8,
                                                           (unsigned char)8, (unsigned char)8,
                                                           (unsigned char)8, (unsigned char)8,
                                                           (unsigned char)8, (unsigned char)8,
                                                           (unsigned char)8, (unsigned char)8,
                                                           (unsigned char)8, (unsigned char)8,
                                                           (unsigned char)8, (unsigned char)8,
                                                           (unsigned char)8, (unsigned char)8,
                                                           (unsigned char)8, (unsigned char)8,
                                                           (unsigned char)8, (unsigned char)8,
                                                           (unsigned char)8, (unsigned char)8,
                                                           (unsigned char)8, (unsigned char)8,
                                                           (unsigned char)8, (unsigned char)8,
                                                           (unsigned char)8, (unsigned char)8,
                                                           (unsigned char)8, (unsigned char)8,
                                                           (unsigned char)8, (unsigned char)8,
                                                           (unsigned char)8, (unsigned char)8,
                                                           (unsigned char)8, (unsigned char)8,
                                                           (unsigned char)8, (unsigned char)8,
                                                           (unsigned char)8, (unsigned char)8,
                                                           (unsigned char)8, (unsigned char)8,
                                                           (unsigned char)8, (unsigned char)8,
                                                           (unsigned char)8, (unsigned char)8,
                                                           (unsigned char)8, (unsigned char)8,
                                                           (unsigned char)8, (unsigned char)8,
                                                           (unsigned char)8, (unsigned char)8,
                                                           (unsigned char)8, (unsigned char)8,
                                                           (unsigned char)8, (unsigned char)8,
                                                           (unsigned char)5, (unsigned char)5,
                                                           (unsigned char)5, (unsigned char)5,
                                                           (unsigned char)5, (unsigned char)5,
                                                           (unsigned char)5, (unsigned char)5,
                                                           (unsigned char)5, (unsigned char)5,
                                                           (unsigned char)5, (unsigned char)5,
                                                           (unsigned char)5, (unsigned char)5,
                                                           (unsigned char)5, (unsigned char)5,
                                                           (unsigned char)5, (unsigned char)5,
                                                           (unsigned char)5, (unsigned char)5,
                                                           (unsigned char)5, (unsigned char)5,
                                                           (unsigned char)5, (unsigned char)5,
                                                           (unsigned char)5, (unsigned char)5,
                                                           (unsigned char)5, (unsigned char)5,
                                                           (unsigned char)5, (unsigned char)5,
                                                           (unsigned char)5, (unsigned char)5,
                                                           (unsigned char)6, (unsigned char)6,
                                                           (unsigned char)6, (unsigned char)6,
                                                           (unsigned char)6, (unsigned char)6,
                                                           (unsigned char)6, (unsigned char)6,
                                                           (unsigned char)6, (unsigned char)6,
                                                           (unsigned char)6, (unsigned char)6,
                                                           (unsigned char)6, (unsigned char)6,
                                                           (unsigned char)6, (unsigned char)6,
                                                           (unsigned char)7, (unsigned char)7,
                                                           (unsigned char)7, (unsigned char)7,
                                                           (unsigned char)7, (unsigned char)0,
                                                           (unsigned char)0, (unsigned char)0,
                                                           (unsigned char)0, (unsigned char)0,
                                                           (unsigned char)0, (unsigned char)0,
                                                           (unsigned char)0, (unsigned char)0,
                                                           (unsigned char)1, (unsigned char)1},
    & utf8_isName2, & utf8_isName3, & isNever, & utf8_isNmstrt2, & utf8_isNmstrt3,
    & isNever, & utf8_isInvalid2, & utf8_isInvalid3, & utf8_isInvalid4};
#line 428 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmltok.c"
static void latin1_toUtf8(ENCODING const   *enc , char const   **fromP , char const   *fromLim ,
                          char **toP , char const   *toLim ) 
{ 
  unsigned char c___0 ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char const   *tmp___2 ;

  {
  {
#line 433
  while (1) {
    while_continue: /* CIL Label */ ;
#line 435
    if ((unsigned long )*fromP == (unsigned long )fromLim) {
#line 436
      goto while_break;
    }
#line 437
    c___0 = (unsigned char )*(*fromP);
#line 438
    if ((int )c___0 & 128) {
#line 439
      if (toLim - (char const   *)*toP < 2L) {
#line 440
        goto while_break;
      }
#line 441
      tmp = *toP;
#line 441
      (*toP) ++;
#line 441
      *tmp = (char )(((int )c___0 >> 6) | 192);
#line 442
      tmp___0 = *toP;
#line 442
      (*toP) ++;
#line 442
      *tmp___0 = (char )(((int )c___0 & 63) | 128);
#line 443
      (*fromP) ++;
    } else {
#line 446
      if ((unsigned long )*toP == (unsigned long )toLim) {
#line 447
        goto while_break;
      }
#line 448
      tmp___1 = *toP;
#line 448
      (*toP) ++;
#line 448
      tmp___2 = *fromP;
#line 448
      (*fromP) ++;
#line 448
      *tmp___1 = (char )*tmp___2;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 451
  return;
}
}
#line 453 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmltok.c"
static void latin1_toUtf16(ENCODING const   *enc , char const   **fromP , char const   *fromLim ,
                           unsigned short **toP , unsigned short const   *toLim ) 
{ 
  unsigned short *tmp ;
  char const   *tmp___0 ;

  {
  {
#line 458
  while (1) {
    while_continue: /* CIL Label */ ;
#line 458
    if ((unsigned long )*fromP != (unsigned long )fromLim) {
#line 458
      if (! ((unsigned long )*toP != (unsigned long )toLim)) {
#line 458
        goto while_break;
      }
    } else {
#line 458
      goto while_break;
    }
#line 459
    tmp = *toP;
#line 459
    (*toP) ++;
#line 459
    tmp___0 = *fromP;
#line 459
    (*fromP) ++;
#line 459
    *tmp = (unsigned short )((unsigned char )*tmp___0);
  }
  while_break: /* CIL Label */ ;
  }
#line 460
  return;
}
}
#line 464 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmltok.c"
static struct normal_encoding  const  latin1_encoding_ns  = 
#line 464
     {{{& normal_prologTok, & normal_contentTok, & normal_cdataSectionTok, & normal_ignoreSectionTok},
     {& normal_attributeValueTok, & normal_entityValueTok}, & normal_sameName, & normal_nameMatchesAscii,
     & normal_nameLength, & normal_skipS, & normal_getAtts, & normal_charRefNumber,
     & normal_predefinedEntityName, & normal_updatePosition, & normal_isPublicId,
     & latin1_toUtf8, & latin1_toUtf16, 1, (char)0, (char)0}, {(unsigned char)0, (unsigned char)0,
                                                               (unsigned char)0, (unsigned char)0,
                                                               (unsigned char)0, (unsigned char)0,
                                                               (unsigned char)0, (unsigned char)0,
                                                               (unsigned char)0, (unsigned char)21,
                                                               (unsigned char)10,
                                                               (unsigned char)0, (unsigned char)0,
                                                               (unsigned char)9, (unsigned char)0,
                                                               (unsigned char)0, (unsigned char)0,
                                                               (unsigned char)0, (unsigned char)0,
                                                               (unsigned char)0, (unsigned char)0,
                                                               (unsigned char)0, (unsigned char)0,
                                                               (unsigned char)0, (unsigned char)0,
                                                               (unsigned char)0, (unsigned char)0,
                                                               (unsigned char)0, (unsigned char)0,
                                                               (unsigned char)0, (unsigned char)0,
                                                               (unsigned char)0, (unsigned char)21,
                                                               (unsigned char)16,
                                                               (unsigned char)12,
                                                               (unsigned char)19,
                                                               (unsigned char)28,
                                                               (unsigned char)30,
                                                               (unsigned char)3, (unsigned char)13,
                                                               (unsigned char)31,
                                                               (unsigned char)32,
                                                               (unsigned char)33,
                                                               (unsigned char)34,
                                                               (unsigned char)35,
                                                               (unsigned char)27,
                                                               (unsigned char)26,
                                                               (unsigned char)17,
                                                               (unsigned char)25,
                                                               (unsigned char)25,
                                                               (unsigned char)25,
                                                               (unsigned char)25,
                                                               (unsigned char)25,
                                                               (unsigned char)25,
                                                               (unsigned char)25,
                                                               (unsigned char)25,
                                                               (unsigned char)25,
                                                               (unsigned char)25,
                                                               (unsigned char)23,
                                                               (unsigned char)18,
                                                               (unsigned char)2, (unsigned char)14,
                                                               (unsigned char)11,
                                                               (unsigned char)15,
                                                               (unsigned char)28,
                                                               (unsigned char)24,
                                                               (unsigned char)24,
                                                               (unsigned char)24,
                                                               (unsigned char)24,
                                                               (unsigned char)24,
                                                               (unsigned char)24,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)20,
                                                               (unsigned char)28,
                                                               (unsigned char)4, (unsigned char)28,
                                                               (unsigned char)22,
                                                               (unsigned char)28,
                                                               (unsigned char)24,
                                                               (unsigned char)24,
                                                               (unsigned char)24,
                                                               (unsigned char)24,
                                                               (unsigned char)24,
                                                               (unsigned char)24,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)28,
                                                               (unsigned char)36,
                                                               (unsigned char)28,
                                                               (unsigned char)28,
                                                               (unsigned char)28,
                                                               (unsigned char)28,
                                                               (unsigned char)28,
                                                               (unsigned char)28,
                                                               (unsigned char)28,
                                                               (unsigned char)28,
                                                               (unsigned char)28,
                                                               (unsigned char)28,
                                                               (unsigned char)28,
                                                               (unsigned char)28,
                                                               (unsigned char)28,
                                                               (unsigned char)28,
                                                               (unsigned char)28,
                                                               (unsigned char)28,
                                                               (unsigned char)28,
                                                               (unsigned char)28,
                                                               (unsigned char)28,
                                                               (unsigned char)28,
                                                               (unsigned char)28,
                                                               (unsigned char)28,
                                                               (unsigned char)28,
                                                               (unsigned char)28,
                                                               (unsigned char)28,
                                                               (unsigned char)28,
                                                               (unsigned char)28,
                                                               (unsigned char)28,
                                                               (unsigned char)28,
                                                               (unsigned char)28,
                                                               (unsigned char)28,
                                                               (unsigned char)28,
                                                               (unsigned char)28,
                                                               (unsigned char)28,
                                                               (unsigned char)28,
                                                               (unsigned char)28,
                                                               (unsigned char)28,
                                                               (unsigned char)28,
                                                               (unsigned char)28,
                                                               (unsigned char)28,
                                                               (unsigned char)28,
                                                               (unsigned char)28,
                                                               (unsigned char)28,
                                                               (unsigned char)28,
                                                               (unsigned char)28,
                                                               (unsigned char)22,
                                                               (unsigned char)28,
                                                               (unsigned char)28,
                                                               (unsigned char)28,
                                                               (unsigned char)28,
                                                               (unsigned char)28,
                                                               (unsigned char)28,
                                                               (unsigned char)28,
                                                               (unsigned char)28,
                                                               (unsigned char)28,
                                                               (unsigned char)28,
                                                               (unsigned char)22,
                                                               (unsigned char)28,
                                                               (unsigned char)26,
                                                               (unsigned char)28,
                                                               (unsigned char)28,
                                                               (unsigned char)22,
                                                               (unsigned char)28,
                                                               (unsigned char)28,
                                                               (unsigned char)28,
                                                               (unsigned char)28,
                                                               (unsigned char)28,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)28,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)28,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22},
    (int (*)(ENCODING const   * , char const   * ))0, (int (*)(ENCODING const   * ,
                                                               char const   * ))0,
    (int (*)(ENCODING const   * , char const   * ))0, (int (*)(ENCODING const   * ,
                                                               char const   * ))0,
    (int (*)(ENCODING const   * , char const   * ))0, (int (*)(ENCODING const   * ,
                                                               char const   * ))0,
    (int (*)(ENCODING const   * , char const   * ))0, (int (*)(ENCODING const   * ,
                                                               char const   * ))0,
    (int (*)(ENCODING const   * , char const   * ))0};
#line 475 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmltok.c"
static struct normal_encoding  const  latin1_encoding  = 
#line 475
     {{{& normal_prologTok, & normal_contentTok, & normal_cdataSectionTok, & normal_ignoreSectionTok},
     {& normal_attributeValueTok, & normal_entityValueTok}, & normal_sameName, & normal_nameMatchesAscii,
     & normal_nameLength, & normal_skipS, & normal_getAtts, & normal_charRefNumber,
     & normal_predefinedEntityName, & normal_updatePosition, & normal_isPublicId,
     & latin1_toUtf8, & latin1_toUtf16, 1, (char)0, (char)0}, {(unsigned char)0, (unsigned char)0,
                                                               (unsigned char)0, (unsigned char)0,
                                                               (unsigned char)0, (unsigned char)0,
                                                               (unsigned char)0, (unsigned char)0,
                                                               (unsigned char)0, (unsigned char)21,
                                                               (unsigned char)10,
                                                               (unsigned char)0, (unsigned char)0,
                                                               (unsigned char)9, (unsigned char)0,
                                                               (unsigned char)0, (unsigned char)0,
                                                               (unsigned char)0, (unsigned char)0,
                                                               (unsigned char)0, (unsigned char)0,
                                                               (unsigned char)0, (unsigned char)0,
                                                               (unsigned char)0, (unsigned char)0,
                                                               (unsigned char)0, (unsigned char)0,
                                                               (unsigned char)0, (unsigned char)0,
                                                               (unsigned char)0, (unsigned char)0,
                                                               (unsigned char)0, (unsigned char)21,
                                                               (unsigned char)16,
                                                               (unsigned char)12,
                                                               (unsigned char)19,
                                                               (unsigned char)28,
                                                               (unsigned char)30,
                                                               (unsigned char)3, (unsigned char)13,
                                                               (unsigned char)31,
                                                               (unsigned char)32,
                                                               (unsigned char)33,
                                                               (unsigned char)34,
                                                               (unsigned char)35,
                                                               (unsigned char)27,
                                                               (unsigned char)26,
                                                               (unsigned char)17,
                                                               (unsigned char)25,
                                                               (unsigned char)25,
                                                               (unsigned char)25,
                                                               (unsigned char)25,
                                                               (unsigned char)25,
                                                               (unsigned char)25,
                                                               (unsigned char)25,
                                                               (unsigned char)25,
                                                               (unsigned char)25,
                                                               (unsigned char)25,
                                                               (unsigned char)22,
                                                               (unsigned char)18,
                                                               (unsigned char)2, (unsigned char)14,
                                                               (unsigned char)11,
                                                               (unsigned char)15,
                                                               (unsigned char)28,
                                                               (unsigned char)24,
                                                               (unsigned char)24,
                                                               (unsigned char)24,
                                                               (unsigned char)24,
                                                               (unsigned char)24,
                                                               (unsigned char)24,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)20,
                                                               (unsigned char)28,
                                                               (unsigned char)4, (unsigned char)28,
                                                               (unsigned char)22,
                                                               (unsigned char)28,
                                                               (unsigned char)24,
                                                               (unsigned char)24,
                                                               (unsigned char)24,
                                                               (unsigned char)24,
                                                               (unsigned char)24,
                                                               (unsigned char)24,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)28,
                                                               (unsigned char)36,
                                                               (unsigned char)28,
                                                               (unsigned char)28,
                                                               (unsigned char)28,
                                                               (unsigned char)28,
                                                               (unsigned char)28,
                                                               (unsigned char)28,
                                                               (unsigned char)28,
                                                               (unsigned char)28,
                                                               (unsigned char)28,
                                                               (unsigned char)28,
                                                               (unsigned char)28,
                                                               (unsigned char)28,
                                                               (unsigned char)28,
                                                               (unsigned char)28,
                                                               (unsigned char)28,
                                                               (unsigned char)28,
                                                               (unsigned char)28,
                                                               (unsigned char)28,
                                                               (unsigned char)28,
                                                               (unsigned char)28,
                                                               (unsigned char)28,
                                                               (unsigned char)28,
                                                               (unsigned char)28,
                                                               (unsigned char)28,
                                                               (unsigned char)28,
                                                               (unsigned char)28,
                                                               (unsigned char)28,
                                                               (unsigned char)28,
                                                               (unsigned char)28,
                                                               (unsigned char)28,
                                                               (unsigned char)28,
                                                               (unsigned char)28,
                                                               (unsigned char)28,
                                                               (unsigned char)28,
                                                               (unsigned char)28,
                                                               (unsigned char)28,
                                                               (unsigned char)28,
                                                               (unsigned char)28,
                                                               (unsigned char)28,
                                                               (unsigned char)28,
                                                               (unsigned char)28,
                                                               (unsigned char)28,
                                                               (unsigned char)28,
                                                               (unsigned char)28,
                                                               (unsigned char)28,
                                                               (unsigned char)22,
                                                               (unsigned char)28,
                                                               (unsigned char)28,
                                                               (unsigned char)28,
                                                               (unsigned char)28,
                                                               (unsigned char)28,
                                                               (unsigned char)28,
                                                               (unsigned char)28,
                                                               (unsigned char)28,
                                                               (unsigned char)28,
                                                               (unsigned char)28,
                                                               (unsigned char)22,
                                                               (unsigned char)28,
                                                               (unsigned char)26,
                                                               (unsigned char)28,
                                                               (unsigned char)28,
                                                               (unsigned char)22,
                                                               (unsigned char)28,
                                                               (unsigned char)28,
                                                               (unsigned char)28,
                                                               (unsigned char)28,
                                                               (unsigned char)28,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)28,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)28,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22,
                                                               (unsigned char)22},
    (int (*)(ENCODING const   * , char const   * ))0, (int (*)(ENCODING const   * ,
                                                               char const   * ))0,
    (int (*)(ENCODING const   * , char const   * ))0, (int (*)(ENCODING const   * ,
                                                               char const   * ))0,
    (int (*)(ENCODING const   * , char const   * ))0, (int (*)(ENCODING const   * ,
                                                               char const   * ))0,
    (int (*)(ENCODING const   * , char const   * ))0, (int (*)(ENCODING const   * ,
                                                               char const   * ))0,
    (int (*)(ENCODING const   * , char const   * ))0};
#line 486 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmltok.c"
static void ascii_toUtf8(ENCODING const   *enc , char const   **fromP , char const   *fromLim ,
                         char **toP , char const   *toLim ) 
{ 
  char *tmp ;
  char const   *tmp___0 ;

  {
  {
#line 491
  while (1) {
    while_continue: /* CIL Label */ ;
#line 491
    if ((unsigned long )*fromP != (unsigned long )fromLim) {
#line 491
      if (! ((unsigned long )*toP != (unsigned long )toLim)) {
#line 491
        goto while_break;
      }
    } else {
#line 491
      goto while_break;
    }
#line 492
    tmp = *toP;
#line 492
    (*toP) ++;
#line 492
    tmp___0 = *fromP;
#line 492
    (*fromP) ++;
#line 492
    *tmp = (char )*tmp___0;
  }
  while_break: /* CIL Label */ ;
  }
#line 493
  return;
}
}
#line 497 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmltok.c"
static struct normal_encoding  const  ascii_encoding_ns  = 
#line 497
     {{{& normal_prologTok, & normal_contentTok, & normal_cdataSectionTok, & normal_ignoreSectionTok},
     {& normal_attributeValueTok, & normal_entityValueTok}, & normal_sameName, & normal_nameMatchesAscii,
     & normal_nameLength, & normal_skipS, & normal_getAtts, & normal_charRefNumber,
     & normal_predefinedEntityName, & normal_updatePosition, & normal_isPublicId,
     & ascii_toUtf8, & latin1_toUtf16, 1, (char)1, (char)0}, {(unsigned char)0, (unsigned char)0,
                                                              (unsigned char)0, (unsigned char)0,
                                                              (unsigned char)0, (unsigned char)0,
                                                              (unsigned char)0, (unsigned char)0,
                                                              (unsigned char)0, (unsigned char)21,
                                                              (unsigned char)10, (unsigned char)0,
                                                              (unsigned char)0, (unsigned char)9,
                                                              (unsigned char)0, (unsigned char)0,
                                                              (unsigned char)0, (unsigned char)0,
                                                              (unsigned char)0, (unsigned char)0,
                                                              (unsigned char)0, (unsigned char)0,
                                                              (unsigned char)0, (unsigned char)0,
                                                              (unsigned char)0, (unsigned char)0,
                                                              (unsigned char)0, (unsigned char)0,
                                                              (unsigned char)0, (unsigned char)0,
                                                              (unsigned char)0, (unsigned char)0,
                                                              (unsigned char)21, (unsigned char)16,
                                                              (unsigned char)12, (unsigned char)19,
                                                              (unsigned char)28, (unsigned char)30,
                                                              (unsigned char)3, (unsigned char)13,
                                                              (unsigned char)31, (unsigned char)32,
                                                              (unsigned char)33, (unsigned char)34,
                                                              (unsigned char)35, (unsigned char)27,
                                                              (unsigned char)26, (unsigned char)17,
                                                              (unsigned char)25, (unsigned char)25,
                                                              (unsigned char)25, (unsigned char)25,
                                                              (unsigned char)25, (unsigned char)25,
                                                              (unsigned char)25, (unsigned char)25,
                                                              (unsigned char)25, (unsigned char)25,
                                                              (unsigned char)23, (unsigned char)18,
                                                              (unsigned char)2, (unsigned char)14,
                                                              (unsigned char)11, (unsigned char)15,
                                                              (unsigned char)28, (unsigned char)24,
                                                              (unsigned char)24, (unsigned char)24,
                                                              (unsigned char)24, (unsigned char)24,
                                                              (unsigned char)24, (unsigned char)22,
                                                              (unsigned char)22, (unsigned char)22,
                                                              (unsigned char)22, (unsigned char)22,
                                                              (unsigned char)22, (unsigned char)22,
                                                              (unsigned char)22, (unsigned char)22,
                                                              (unsigned char)22, (unsigned char)22,
                                                              (unsigned char)22, (unsigned char)22,
                                                              (unsigned char)22, (unsigned char)22,
                                                              (unsigned char)22, (unsigned char)22,
                                                              (unsigned char)22, (unsigned char)22,
                                                              (unsigned char)22, (unsigned char)20,
                                                              (unsigned char)28, (unsigned char)4,
                                                              (unsigned char)28, (unsigned char)22,
                                                              (unsigned char)28, (unsigned char)24,
                                                              (unsigned char)24, (unsigned char)24,
                                                              (unsigned char)24, (unsigned char)24,
                                                              (unsigned char)24, (unsigned char)22,
                                                              (unsigned char)22, (unsigned char)22,
                                                              (unsigned char)22, (unsigned char)22,
                                                              (unsigned char)22, (unsigned char)22,
                                                              (unsigned char)22, (unsigned char)22,
                                                              (unsigned char)22, (unsigned char)22,
                                                              (unsigned char)22, (unsigned char)22,
                                                              (unsigned char)22, (unsigned char)22,
                                                              (unsigned char)22, (unsigned char)22,
                                                              (unsigned char)22, (unsigned char)22,
                                                              (unsigned char)22, (unsigned char)28,
                                                              (unsigned char)36, (unsigned char)28,
                                                              (unsigned char)28, (unsigned char)28},
    (int (*)(ENCODING const   * , char const   * ))0, (int (*)(ENCODING const   * ,
                                                               char const   * ))0,
    (int (*)(ENCODING const   * , char const   * ))0, (int (*)(ENCODING const   * ,
                                                               char const   * ))0,
    (int (*)(ENCODING const   * , char const   * ))0, (int (*)(ENCODING const   * ,
                                                               char const   * ))0,
    (int (*)(ENCODING const   * , char const   * ))0, (int (*)(ENCODING const   * ,
                                                               char const   * ))0,
    (int (*)(ENCODING const   * , char const   * ))0};
#line 508 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmltok.c"
static struct normal_encoding  const  ascii_encoding  = 
#line 508
     {{{& normal_prologTok, & normal_contentTok, & normal_cdataSectionTok, & normal_ignoreSectionTok},
     {& normal_attributeValueTok, & normal_entityValueTok}, & normal_sameName, & normal_nameMatchesAscii,
     & normal_nameLength, & normal_skipS, & normal_getAtts, & normal_charRefNumber,
     & normal_predefinedEntityName, & normal_updatePosition, & normal_isPublicId,
     & ascii_toUtf8, & latin1_toUtf16, 1, (char)1, (char)0}, {(unsigned char)0, (unsigned char)0,
                                                              (unsigned char)0, (unsigned char)0,
                                                              (unsigned char)0, (unsigned char)0,
                                                              (unsigned char)0, (unsigned char)0,
                                                              (unsigned char)0, (unsigned char)21,
                                                              (unsigned char)10, (unsigned char)0,
                                                              (unsigned char)0, (unsigned char)9,
                                                              (unsigned char)0, (unsigned char)0,
                                                              (unsigned char)0, (unsigned char)0,
                                                              (unsigned char)0, (unsigned char)0,
                                                              (unsigned char)0, (unsigned char)0,
                                                              (unsigned char)0, (unsigned char)0,
                                                              (unsigned char)0, (unsigned char)0,
                                                              (unsigned char)0, (unsigned char)0,
                                                              (unsigned char)0, (unsigned char)0,
                                                              (unsigned char)0, (unsigned char)0,
                                                              (unsigned char)21, (unsigned char)16,
                                                              (unsigned char)12, (unsigned char)19,
                                                              (unsigned char)28, (unsigned char)30,
                                                              (unsigned char)3, (unsigned char)13,
                                                              (unsigned char)31, (unsigned char)32,
                                                              (unsigned char)33, (unsigned char)34,
                                                              (unsigned char)35, (unsigned char)27,
                                                              (unsigned char)26, (unsigned char)17,
                                                              (unsigned char)25, (unsigned char)25,
                                                              (unsigned char)25, (unsigned char)25,
                                                              (unsigned char)25, (unsigned char)25,
                                                              (unsigned char)25, (unsigned char)25,
                                                              (unsigned char)25, (unsigned char)25,
                                                              (unsigned char)22, (unsigned char)18,
                                                              (unsigned char)2, (unsigned char)14,
                                                              (unsigned char)11, (unsigned char)15,
                                                              (unsigned char)28, (unsigned char)24,
                                                              (unsigned char)24, (unsigned char)24,
                                                              (unsigned char)24, (unsigned char)24,
                                                              (unsigned char)24, (unsigned char)22,
                                                              (unsigned char)22, (unsigned char)22,
                                                              (unsigned char)22, (unsigned char)22,
                                                              (unsigned char)22, (unsigned char)22,
                                                              (unsigned char)22, (unsigned char)22,
                                                              (unsigned char)22, (unsigned char)22,
                                                              (unsigned char)22, (unsigned char)22,
                                                              (unsigned char)22, (unsigned char)22,
                                                              (unsigned char)22, (unsigned char)22,
                                                              (unsigned char)22, (unsigned char)22,
                                                              (unsigned char)22, (unsigned char)20,
                                                              (unsigned char)28, (unsigned char)4,
                                                              (unsigned char)28, (unsigned char)22,
                                                              (unsigned char)28, (unsigned char)24,
                                                              (unsigned char)24, (unsigned char)24,
                                                              (unsigned char)24, (unsigned char)24,
                                                              (unsigned char)24, (unsigned char)22,
                                                              (unsigned char)22, (unsigned char)22,
                                                              (unsigned char)22, (unsigned char)22,
                                                              (unsigned char)22, (unsigned char)22,
                                                              (unsigned char)22, (unsigned char)22,
                                                              (unsigned char)22, (unsigned char)22,
                                                              (unsigned char)22, (unsigned char)22,
                                                              (unsigned char)22, (unsigned char)22,
                                                              (unsigned char)22, (unsigned char)22,
                                                              (unsigned char)22, (unsigned char)22,
                                                              (unsigned char)22, (unsigned char)28,
                                                              (unsigned char)36, (unsigned char)28,
                                                              (unsigned char)28, (unsigned char)28},
    (int (*)(ENCODING const   * , char const   * ))0, (int (*)(ENCODING const   * ,
                                                               char const   * ))0,
    (int (*)(ENCODING const   * , char const   * ))0, (int (*)(ENCODING const   * ,
                                                               char const   * ))0,
    (int (*)(ENCODING const   * , char const   * ))0, (int (*)(ENCODING const   * ,
                                                               char const   * ))0,
    (int (*)(ENCODING const   * , char const   * ))0, (int (*)(ENCODING const   * ,
                                                               char const   * ))0,
    (int (*)(ENCODING const   * , char const   * ))0};
#line 519 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmltok.c"
static int unicode_byte_type(char hi , char lo ) 
{ 


  {
  {
#line 523
  if ((int )((unsigned char )hi) == 219) {
#line 523
    goto case_219;
  }
#line 523
  if ((int )((unsigned char )hi) == 218) {
#line 523
    goto case_219;
  }
#line 523
  if ((int )((unsigned char )hi) == 217) {
#line 523
    goto case_219;
  }
#line 523
  if ((int )((unsigned char )hi) == 216) {
#line 523
    goto case_219;
  }
#line 525
  if ((int )((unsigned char )hi) == 223) {
#line 525
    goto case_223;
  }
#line 525
  if ((int )((unsigned char )hi) == 222) {
#line 525
    goto case_223;
  }
#line 525
  if ((int )((unsigned char )hi) == 221) {
#line 525
    goto case_223;
  }
#line 525
  if ((int )((unsigned char )hi) == 220) {
#line 525
    goto case_223;
  }
#line 527
  if ((int )((unsigned char )hi) == 255) {
#line 527
    goto case_255;
  }
#line 522
  goto switch_break;
  case_219: /* CIL Label */ 
  case_218: /* CIL Label */ 
  case_217: /* CIL Label */ 
  case_216: /* CIL Label */ 
#line 524
  return (7);
  case_223: /* CIL Label */ 
  case_222: /* CIL Label */ 
  case_221: /* CIL Label */ 
  case_220: /* CIL Label */ 
#line 526
  return (8);
  case_255: /* CIL Label */ 
  {
#line 530
  if ((int )((unsigned char )lo) == 254) {
#line 530
    goto case_254;
  }
#line 530
  if ((int )((unsigned char )lo) == 255) {
#line 530
    goto case_254;
  }
#line 528
  goto switch_break___0;
  case_254: /* CIL Label */ 
  case_255___0: /* CIL Label */ 
#line 531
  return (0);
  switch_break___0: /* CIL Label */ ;
  }
#line 533
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 535
  return (29);
}
}
#line 620 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmltok.c"
static void little2_toUtf8(ENCODING const   *enc , char const   **fromP , char const   *fromLim ,
                           char **toP , char const   *toLim ) 
{ 
  char const   *from ;
  int plane ;
  unsigned char lo2 ;
  unsigned char lo ;
  unsigned char hi ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;

  {
#line 620
  from = *fromP;
  {
#line 620
  while (1) {
    while_continue: /* CIL Label */ ;
#line 620
    if (! ((unsigned long )from != (unsigned long )fromLim)) {
#line 620
      goto while_break;
    }
#line 620
    lo = (unsigned char )*(from + 0);
#line 620
    hi = (unsigned char )*(from + 1);
    {
#line 620
    if ((int )hi == 0) {
#line 620
      goto case_0;
    }
#line 620
    if ((int )hi == 7) {
#line 620
      goto case_7;
    }
#line 620
    if ((int )hi == 6) {
#line 620
      goto case_7;
    }
#line 620
    if ((int )hi == 5) {
#line 620
      goto case_7;
    }
#line 620
    if ((int )hi == 4) {
#line 620
      goto case_7;
    }
#line 620
    if ((int )hi == 3) {
#line 620
      goto case_7;
    }
#line 620
    if ((int )hi == 2) {
#line 620
      goto case_7;
    }
#line 620
    if ((int )hi == 1) {
#line 620
      goto case_7;
    }
#line 620
    if ((int )hi == 219) {
#line 620
      goto case_219;
    }
#line 620
    if ((int )hi == 218) {
#line 620
      goto case_219;
    }
#line 620
    if ((int )hi == 217) {
#line 620
      goto case_219;
    }
#line 620
    if ((int )hi == 216) {
#line 620
      goto case_219;
    }
#line 620
    goto switch_default;
    case_0: /* CIL Label */ 
#line 620
    if ((int )lo < 128) {
#line 620
      if ((unsigned long )*toP == (unsigned long )toLim) {
#line 620
        *fromP = from;
#line 620
        return;
      }
#line 620
      tmp = *toP;
#line 620
      (*toP) ++;
#line 620
      *tmp = (char )lo;
#line 620
      goto switch_break;
    }
    case_7: /* CIL Label */ 
    case_6: /* CIL Label */ 
    case_5: /* CIL Label */ 
    case_4: /* CIL Label */ 
    case_3: /* CIL Label */ 
    case_2: /* CIL Label */ 
    case_1: /* CIL Label */ 
#line 620
    if (toLim - (char const   *)*toP < 2L) {
#line 620
      *fromP = from;
#line 620
      return;
    }
#line 620
    tmp___0 = *toP;
#line 620
    (*toP) ++;
#line 620
    *tmp___0 = (char )((((int )lo >> 6) | ((int )hi << 2)) | 192);
#line 620
    tmp___1 = *toP;
#line 620
    (*toP) ++;
#line 620
    *tmp___1 = (char )(((int )lo & 63) | 128);
#line 620
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 620
    if (toLim - (char const   *)*toP < 3L) {
#line 620
      *fromP = from;
#line 620
      return;
    }
#line 620
    tmp___2 = *toP;
#line 620
    (*toP) ++;
#line 620
    *tmp___2 = (char )(((int )hi >> 4) | 224);
#line 620
    tmp___3 = *toP;
#line 620
    (*toP) ++;
#line 620
    *tmp___3 = (char )(((((int )hi & 15) << 2) | ((int )lo >> 6)) | 128);
#line 620
    tmp___4 = *toP;
#line 620
    (*toP) ++;
#line 620
    *tmp___4 = (char )(((int )lo & 63) | 128);
#line 620
    goto switch_break;
    case_219: /* CIL Label */ 
    case_218: /* CIL Label */ 
    case_217: /* CIL Label */ 
    case_216: /* CIL Label */ 
#line 620
    if (toLim - (char const   *)*toP < 4L) {
#line 620
      *fromP = from;
#line 620
      return;
    }
#line 620
    plane = ((((int )hi & 3) << 2) | (((int )lo >> 6) & 3)) + 1;
#line 620
    tmp___5 = *toP;
#line 620
    (*toP) ++;
#line 620
    *tmp___5 = (char )((plane >> 2) | 240);
#line 620
    tmp___6 = *toP;
#line 620
    (*toP) ++;
#line 620
    *tmp___6 = (char )(((((int )lo >> 2) & 15) | ((plane & 3) << 4)) | 128);
#line 620
    from += 2;
#line 620
    lo2 = (unsigned char )*(from + 0);
#line 620
    tmp___7 = *toP;
#line 620
    (*toP) ++;
#line 620
    *tmp___7 = (char )((((((int )lo & 3) << 4) | (((int )((unsigned char )*(from + 1)) & 3) << 2)) | ((int )lo2 >> 6)) | 128);
#line 620
    tmp___8 = *toP;
#line 620
    (*toP) ++;
#line 620
    *tmp___8 = (char )(((int )lo2 & 63) | 128);
#line 620
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 620
    from += 2;
  }
  while_break: /* CIL Label */ ;
  }
#line 620
  *fromP = from;
#line 620
  return;
}
}
#line 621 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmltok.c"
static void little2_toUtf16(ENCODING const   *enc , char const   **fromP , char const   *fromLim ,
                            unsigned short **toP , unsigned short const   *toLim ) 
{ 
  unsigned short *tmp ;

  {
#line 621
  if (fromLim - *fromP > (toLim - (unsigned short const   *)*toP) << 1) {
#line 621
    if (((int )((unsigned char )*((fromLim - 2) + 1)) & 248) == 216) {
#line 621
      fromLim -= 2;
    }
  }
  {
#line 621
  while (1) {
    while_continue: /* CIL Label */ ;
#line 621
    if ((unsigned long )*fromP != (unsigned long )fromLim) {
#line 621
      if (! ((unsigned long )*toP != (unsigned long )toLim)) {
#line 621
        goto while_break;
      }
    } else {
#line 621
      goto while_break;
    }
#line 621
    tmp = *toP;
#line 621
    (*toP) ++;
#line 621
    *tmp = (unsigned short )(((int )((unsigned char )*(*fromP + 1)) << 8) | (int )((unsigned char )*(*fromP + 0)));
#line 621
    *fromP += 2;
  }
  while_break: /* CIL Label */ ;
  }
#line 621
  return;
}
}
#line 632 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmltok.c"
static void big2_toUtf8(ENCODING const   *enc , char const   **fromP , char const   *fromLim ,
                        char **toP , char const   *toLim ) 
{ 
  char const   *from ;
  int plane ;
  unsigned char lo2 ;
  unsigned char lo ;
  unsigned char hi ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;

  {
#line 632
  from = *fromP;
  {
#line 632
  while (1) {
    while_continue: /* CIL Label */ ;
#line 632
    if (! ((unsigned long )from != (unsigned long )fromLim)) {
#line 632
      goto while_break;
    }
#line 632
    lo = (unsigned char )*(from + 1);
#line 632
    hi = (unsigned char )*(from + 0);
    {
#line 632
    if ((int )hi == 0) {
#line 632
      goto case_0;
    }
#line 632
    if ((int )hi == 7) {
#line 632
      goto case_7;
    }
#line 632
    if ((int )hi == 6) {
#line 632
      goto case_7;
    }
#line 632
    if ((int )hi == 5) {
#line 632
      goto case_7;
    }
#line 632
    if ((int )hi == 4) {
#line 632
      goto case_7;
    }
#line 632
    if ((int )hi == 3) {
#line 632
      goto case_7;
    }
#line 632
    if ((int )hi == 2) {
#line 632
      goto case_7;
    }
#line 632
    if ((int )hi == 1) {
#line 632
      goto case_7;
    }
#line 632
    if ((int )hi == 219) {
#line 632
      goto case_219;
    }
#line 632
    if ((int )hi == 218) {
#line 632
      goto case_219;
    }
#line 632
    if ((int )hi == 217) {
#line 632
      goto case_219;
    }
#line 632
    if ((int )hi == 216) {
#line 632
      goto case_219;
    }
#line 632
    goto switch_default;
    case_0: /* CIL Label */ 
#line 632
    if ((int )lo < 128) {
#line 632
      if ((unsigned long )*toP == (unsigned long )toLim) {
#line 632
        *fromP = from;
#line 632
        return;
      }
#line 632
      tmp = *toP;
#line 632
      (*toP) ++;
#line 632
      *tmp = (char )lo;
#line 632
      goto switch_break;
    }
    case_7: /* CIL Label */ 
    case_6: /* CIL Label */ 
    case_5: /* CIL Label */ 
    case_4: /* CIL Label */ 
    case_3: /* CIL Label */ 
    case_2: /* CIL Label */ 
    case_1: /* CIL Label */ 
#line 632
    if (toLim - (char const   *)*toP < 2L) {
#line 632
      *fromP = from;
#line 632
      return;
    }
#line 632
    tmp___0 = *toP;
#line 632
    (*toP) ++;
#line 632
    *tmp___0 = (char )((((int )lo >> 6) | ((int )hi << 2)) | 192);
#line 632
    tmp___1 = *toP;
#line 632
    (*toP) ++;
#line 632
    *tmp___1 = (char )(((int )lo & 63) | 128);
#line 632
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 632
    if (toLim - (char const   *)*toP < 3L) {
#line 632
      *fromP = from;
#line 632
      return;
    }
#line 632
    tmp___2 = *toP;
#line 632
    (*toP) ++;
#line 632
    *tmp___2 = (char )(((int )hi >> 4) | 224);
#line 632
    tmp___3 = *toP;
#line 632
    (*toP) ++;
#line 632
    *tmp___3 = (char )(((((int )hi & 15) << 2) | ((int )lo >> 6)) | 128);
#line 632
    tmp___4 = *toP;
#line 632
    (*toP) ++;
#line 632
    *tmp___4 = (char )(((int )lo & 63) | 128);
#line 632
    goto switch_break;
    case_219: /* CIL Label */ 
    case_218: /* CIL Label */ 
    case_217: /* CIL Label */ 
    case_216: /* CIL Label */ 
#line 632
    if (toLim - (char const   *)*toP < 4L) {
#line 632
      *fromP = from;
#line 632
      return;
    }
#line 632
    plane = ((((int )hi & 3) << 2) | (((int )lo >> 6) & 3)) + 1;
#line 632
    tmp___5 = *toP;
#line 632
    (*toP) ++;
#line 632
    *tmp___5 = (char )((plane >> 2) | 240);
#line 632
    tmp___6 = *toP;
#line 632
    (*toP) ++;
#line 632
    *tmp___6 = (char )(((((int )lo >> 2) & 15) | ((plane & 3) << 4)) | 128);
#line 632
    from += 2;
#line 632
    lo2 = (unsigned char )*(from + 1);
#line 632
    tmp___7 = *toP;
#line 632
    (*toP) ++;
#line 632
    *tmp___7 = (char )((((((int )lo & 3) << 4) | (((int )((unsigned char )*(from + 0)) & 3) << 2)) | ((int )lo2 >> 6)) | 128);
#line 632
    tmp___8 = *toP;
#line 632
    (*toP) ++;
#line 632
    *tmp___8 = (char )(((int )lo2 & 63) | 128);
#line 632
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 632
    from += 2;
  }
  while_break: /* CIL Label */ ;
  }
#line 632
  *fromP = from;
#line 632
  return;
}
}
#line 633 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmltok.c"
static void big2_toUtf16(ENCODING const   *enc , char const   **fromP , char const   *fromLim ,
                         unsigned short **toP , unsigned short const   *toLim ) 
{ 
  unsigned short *tmp ;

  {
#line 633
  if (fromLim - *fromP > (toLim - (unsigned short const   *)*toP) << 1) {
#line 633
    if (((int )((unsigned char )*((fromLim - 2) + 0)) & 248) == 216) {
#line 633
      fromLim -= 2;
    }
  }
  {
#line 633
  while (1) {
    while_continue: /* CIL Label */ ;
#line 633
    if ((unsigned long )*fromP != (unsigned long )fromLim) {
#line 633
      if (! ((unsigned long )*toP != (unsigned long )toLim)) {
#line 633
        goto while_break;
      }
    } else {
#line 633
      goto while_break;
    }
#line 633
    tmp = *toP;
#line 633
    (*toP) ++;
#line 633
    *tmp = (unsigned short )(((int )((unsigned char )*(*fromP + 0)) << 8) | (int )((unsigned char )*(*fromP + 1)));
#line 633
    *fromP += 2;
  }
  while_break: /* CIL Label */ ;
  }
#line 633
  return;
}
}
#line 92 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmltok_impl.c"
static int little2_scanComment(ENCODING const   *enc , char const   *ptr , char const   *end ,
                               char const   **nextTokPtr ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 96
  if ((unsigned long )ptr != (unsigned long )end) {
#line 97
    if ((int const   )*(ptr + 1) == 0) {
#line 97
      if (! ((int const   )*(ptr + 0) == 45)) {
#line 98
        *nextTokPtr = ptr;
#line 99
        return (0);
      }
    } else {
#line 98
      *nextTokPtr = ptr;
#line 99
      return (0);
    }
#line 101
    ptr += 2;
    {
#line 102
    while (1) {
      while_continue: /* CIL Label */ ;
#line 102
      if (! ((unsigned long )ptr != (unsigned long )end)) {
#line 102
        goto while_break;
      }
#line 103
      if ((int const   )*(ptr + 1) == 0) {
#line 103
        tmp___0 = (int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr];
      } else {
        {
#line 103
        tmp = unicode_byte_type((char )*(ptr + 1), (char )*(ptr + 0));
#line 103
        tmp___0 = tmp;
        }
      }
      {
#line 104
      if (tmp___0 == 5) {
#line 104
        goto case_5;
      }
#line 104
      if (tmp___0 == 6) {
#line 104
        goto case_6;
      }
#line 104
      if (tmp___0 == 7) {
#line 104
        goto case_7;
      }
#line 104
      if (tmp___0 == 8) {
#line 104
        goto case_8;
      }
#line 104
      if (tmp___0 == 1) {
#line 104
        goto case_8;
      }
#line 104
      if (tmp___0 == 0) {
#line 104
        goto case_8;
      }
#line 105
      if (tmp___0 == 27) {
#line 105
        goto case_27;
      }
#line 119
      goto switch_default;
      case_5: /* CIL Label */ 
#line 104
      if (end - ptr < 2L) {
#line 104
        return (-2);
      }
#line 104
      ptr += 2;
#line 104
      goto switch_break;
      case_6: /* CIL Label */ 
#line 104
      if (end - ptr < 3L) {
#line 104
        return (-2);
      }
#line 104
      ptr += 3;
#line 104
      goto switch_break;
      case_7: /* CIL Label */ 
#line 104
      if (end - ptr < 4L) {
#line 104
        return (-2);
      }
#line 104
      ptr += 4;
#line 104
      goto switch_break;
      case_8: /* CIL Label */ 
      case_1: /* CIL Label */ 
      case_0: /* CIL Label */ 
#line 104
      *nextTokPtr = ptr;
#line 104
      return (0);
      case_27: /* CIL Label */ 
#line 106
      ptr += 2;
#line 106
      if ((unsigned long )ptr == (unsigned long )end) {
#line 107
        return (-1);
      }
#line 108
      if ((int const   )*(ptr + 1) == 0) {
#line 108
        if ((int const   )*(ptr + 0) == 45) {
#line 109
          ptr += 2;
#line 109
          if ((unsigned long )ptr == (unsigned long )end) {
#line 110
            return (-1);
          }
#line 111
          if ((int const   )*(ptr + 1) == 0) {
#line 111
            if (! ((int const   )*(ptr + 0) == 62)) {
#line 112
              *nextTokPtr = ptr;
#line 113
              return (0);
            }
          } else {
#line 112
            *nextTokPtr = ptr;
#line 113
            return (0);
          }
#line 115
          *nextTokPtr = ptr + 2;
#line 116
          return (13);
        }
      }
#line 118
      goto switch_break;
      switch_default: /* CIL Label */ 
#line 120
      ptr += 2;
#line 121
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 125
  return (-1);
}
}
#line 130 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmltok_impl.c"
static int little2_scanDecl(ENCODING const   *enc , char const   *ptr , char const   *end ,
                            char const   **nextTokPtr ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 134
  if ((unsigned long )ptr == (unsigned long )end) {
#line 135
    return (-1);
  }
#line 136
  if ((int const   )*(ptr + 1) == 0) {
#line 136
    tmp___0 = (int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr];
  } else {
    {
#line 136
    tmp = unicode_byte_type((char )*(ptr + 1), (char )*(ptr + 0));
#line 136
    tmp___0 = tmp;
    }
  }
  {
#line 137
  if (tmp___0 == 27) {
#line 137
    goto case_27;
  }
#line 139
  if (tmp___0 == 20) {
#line 139
    goto case_20;
  }
#line 143
  if (tmp___0 == 24) {
#line 143
    goto case_24;
  }
#line 143
  if (tmp___0 == 22) {
#line 143
    goto case_24;
  }
#line 146
  goto switch_default;
  case_27: /* CIL Label */ 
  {
#line 138
  tmp___1 = little2_scanComment(enc, ptr + 2, end, nextTokPtr);
  }
#line 138
  return (tmp___1);
  case_20: /* CIL Label */ 
#line 140
  *nextTokPtr = ptr + 2;
#line 141
  return (33);
  case_24: /* CIL Label */ 
  case_22: /* CIL Label */ 
#line 144
  ptr += 2;
#line 145
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 147
  *nextTokPtr = ptr;
#line 148
  return (0);
  switch_break: /* CIL Label */ ;
  }
  {
#line 150
  while (1) {
    while_continue: /* CIL Label */ ;
#line 150
    if (! ((unsigned long )ptr != (unsigned long )end)) {
#line 150
      goto while_break;
    }
#line 151
    if ((int const   )*(ptr + 1) == 0) {
#line 151
      tmp___3 = (int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr];
    } else {
      {
#line 151
      tmp___2 = unicode_byte_type((char )*(ptr + 1), (char )*(ptr + 0));
#line 151
      tmp___3 = tmp___2;
      }
    }
    {
#line 152
    if (tmp___3 == 30) {
#line 152
      goto case_30;
    }
#line 162
    if (tmp___3 == 10) {
#line 162
      goto case_10___0;
    }
#line 162
    if (tmp___3 == 9) {
#line 162
      goto case_10___0;
    }
#line 162
    if (tmp___3 == 21) {
#line 162
      goto case_10___0;
    }
#line 166
    if (tmp___3 == 24) {
#line 166
      goto case_24___0;
    }
#line 166
    if (tmp___3 == 22) {
#line 166
      goto case_24___0;
    }
#line 169
    goto switch_default___0;
    case_30: /* CIL Label */ 
#line 153
    if ((unsigned long )(ptr + 2) == (unsigned long )end) {
#line 154
      return (-1);
    }
#line 156
    if ((int const   )*((ptr + 2) + 1) == 0) {
#line 156
      tmp___5 = (int )((struct normal_encoding *)enc)->type[(unsigned char )*(ptr + 2)];
    } else {
      {
#line 156
      tmp___4 = unicode_byte_type((char )*((ptr + 2) + 1), (char )*((ptr + 2) + 0));
#line 156
      tmp___5 = tmp___4;
      }
    }
    {
#line 157
    if (tmp___5 == 30) {
#line 157
      goto case_30___0;
    }
#line 157
    if (tmp___5 == 10) {
#line 157
      goto case_30___0;
    }
#line 157
    if (tmp___5 == 9) {
#line 157
      goto case_30___0;
    }
#line 157
    if (tmp___5 == 21) {
#line 157
      goto case_30___0;
    }
#line 156
    goto switch_break___1;
    case_30___0: /* CIL Label */ 
    case_10: /* CIL Label */ 
    case_9: /* CIL Label */ 
    case_21: /* CIL Label */ 
#line 158
    *nextTokPtr = ptr;
#line 159
    return (0);
    switch_break___1: /* CIL Label */ ;
    }
    case_10___0: /* CIL Label */ 
    case_9___0: /* CIL Label */ 
    case_21___0: /* CIL Label */ 
#line 163
    *nextTokPtr = ptr;
#line 164
    return (16);
    case_24___0: /* CIL Label */ 
    case_22___0: /* CIL Label */ 
#line 167
    ptr += 2;
#line 168
    goto switch_break___0;
    switch_default___0: /* CIL Label */ 
#line 170
    *nextTokPtr = ptr;
#line 171
    return (0);
    switch_break___0: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 174
  return (-1);
}
}
#line 177 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmltok_impl.c"
static int little2_checkPiTarget(ENCODING const   *enc , char const   *ptr , char const   *end ,
                                 int *tokPtr ) 
{ 
  int upper ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 181
  upper = 0;
#line 182
  *tokPtr = 11;
#line 183
  if (end - ptr != 6L) {
#line 184
    return (1);
  }
#line 185
  if ((int const   )*(ptr + 1) == 0) {
#line 185
    tmp = (int const   )*(ptr + 0);
  } else {
#line 185
    tmp = (int const   )-1;
  }
  {
#line 186
  if (tmp == 120) {
#line 186
    goto case_120;
  }
#line 188
  if (tmp == 88) {
#line 188
    goto case_88;
  }
#line 191
  goto switch_default;
  case_120: /* CIL Label */ 
#line 187
  goto switch_break;
  case_88: /* CIL Label */ 
#line 189
  upper = 1;
#line 190
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 192
  return (1);
  switch_break: /* CIL Label */ ;
  }
#line 194
  ptr += 2;
#line 195
  if ((int const   )*(ptr + 1) == 0) {
#line 195
    tmp___0 = (int const   )*(ptr + 0);
  } else {
#line 195
    tmp___0 = (int const   )-1;
  }
  {
#line 196
  if (tmp___0 == 109) {
#line 196
    goto case_109;
  }
#line 198
  if (tmp___0 == 77) {
#line 198
    goto case_77;
  }
#line 201
  goto switch_default___0;
  case_109: /* CIL Label */ 
#line 197
  goto switch_break___0;
  case_77: /* CIL Label */ 
#line 199
  upper = 1;
#line 200
  goto switch_break___0;
  switch_default___0: /* CIL Label */ 
#line 202
  return (1);
  switch_break___0: /* CIL Label */ ;
  }
#line 204
  ptr += 2;
#line 205
  if ((int const   )*(ptr + 1) == 0) {
#line 205
    tmp___1 = (int const   )*(ptr + 0);
  } else {
#line 205
    tmp___1 = (int const   )-1;
  }
  {
#line 206
  if (tmp___1 == 108) {
#line 206
    goto case_108;
  }
#line 208
  if (tmp___1 == 76) {
#line 208
    goto case_76;
  }
#line 211
  goto switch_default___1;
  case_108: /* CIL Label */ 
#line 207
  goto switch_break___1;
  case_76: /* CIL Label */ 
#line 209
  upper = 1;
#line 210
  goto switch_break___1;
  switch_default___1: /* CIL Label */ 
#line 212
  return (1);
  switch_break___1: /* CIL Label */ ;
  }
#line 214
  if (upper) {
#line 215
    return (0);
  }
#line 216
  *tokPtr = 12;
#line 217
  return (1);
}
}
#line 222 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmltok_impl.c"
static int little2_scanPi(ENCODING const   *enc , char const   *ptr , char const   *end ,
                          char const   **nextTokPtr ) 
{ 
  int tok ;
  char const   *target ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
#line 227
  target = ptr;
#line 228
  if ((unsigned long )ptr == (unsigned long )end) {
#line 229
    return (-1);
  }
#line 230
  if ((int const   )*(ptr + 1) == 0) {
#line 230
    tmp___0 = (int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr];
  } else {
    {
#line 230
    tmp = unicode_byte_type((char )*(ptr + 1), (char )*(ptr + 0));
#line 230
    tmp___0 = tmp;
    }
  }
  {
#line 231
  if (tmp___0 == 29) {
#line 231
    goto case_29;
  }
#line 231
  if (tmp___0 == 24) {
#line 231
    goto case_24;
  }
#line 231
  if (tmp___0 == 22) {
#line 231
    goto case_24;
  }
#line 231
  if (tmp___0 == 5) {
#line 231
    goto case_5;
  }
#line 231
  if (tmp___0 == 6) {
#line 231
    goto case_6;
  }
#line 231
  if (tmp___0 == 7) {
#line 231
    goto case_7;
  }
#line 232
  goto switch_default;
  case_29: /* CIL Label */ 
#line 231
  if (! (namingBitmap[((int const   )nmstrtPages[(unsigned char )*(ptr + 1)] << 3) + (int const   )((int )((unsigned char )*(ptr + 0)) >> 5)] & (unsigned int const   )(1 << ((int )((unsigned char )*(ptr + 0)) & 31)))) {
#line 231
    *nextTokPtr = ptr;
#line 231
    return (0);
  }
  case_24: /* CIL Label */ 
  case_22: /* CIL Label */ 
#line 231
  ptr += 2;
#line 231
  goto switch_break;
  case_5: /* CIL Label */ 
#line 231
  if (end - ptr < 2L) {
#line 231
    return (-2);
  }
#line 231
  *nextTokPtr = ptr;
#line 231
  return (0);
#line 231
  ptr += 2;
#line 231
  goto switch_break;
  case_6: /* CIL Label */ 
#line 231
  if (end - ptr < 3L) {
#line 231
    return (-2);
  }
#line 231
  *nextTokPtr = ptr;
#line 231
  return (0);
#line 231
  ptr += 3;
#line 231
  goto switch_break;
  case_7: /* CIL Label */ 
#line 231
  if (end - ptr < 4L) {
#line 231
    return (-2);
  }
#line 231
  *nextTokPtr = ptr;
#line 231
  return (0);
#line 231
  ptr += 4;
#line 231
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 233
  *nextTokPtr = ptr;
#line 234
  return (0);
  switch_break: /* CIL Label */ ;
  }
  {
#line 236
  while (1) {
    while_continue: /* CIL Label */ ;
#line 236
    if (! ((unsigned long )ptr != (unsigned long )end)) {
#line 236
      goto while_break;
    }
#line 237
    if ((int const   )*(ptr + 1) == 0) {
#line 237
      tmp___2 = (int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr];
    } else {
      {
#line 237
      tmp___1 = unicode_byte_type((char )*(ptr + 1), (char )*(ptr + 0));
#line 237
      tmp___2 = tmp___1;
      }
    }
    {
#line 238
    if (tmp___2 == 29) {
#line 238
      goto case_29___0;
    }
#line 238
    if (tmp___2 == 27) {
#line 238
      goto case_27;
    }
#line 238
    if (tmp___2 == 26) {
#line 238
      goto case_27;
    }
#line 238
    if (tmp___2 == 25) {
#line 238
      goto case_27;
    }
#line 238
    if (tmp___2 == 24) {
#line 238
      goto case_27;
    }
#line 238
    if (tmp___2 == 22) {
#line 238
      goto case_27;
    }
#line 238
    if (tmp___2 == 5) {
#line 238
      goto case_5___0;
    }
#line 238
    if (tmp___2 == 6) {
#line 238
      goto case_6___0;
    }
#line 238
    if (tmp___2 == 7) {
#line 238
      goto case_7___0;
    }
#line 239
    if (tmp___2 == 10) {
#line 239
      goto case_10;
    }
#line 239
    if (tmp___2 == 9) {
#line 239
      goto case_10;
    }
#line 239
    if (tmp___2 == 21) {
#line 239
      goto case_10;
    }
#line 263
    if (tmp___2 == 15) {
#line 263
      goto case_15___0;
    }
#line 276
    goto switch_default___1;
    case_29___0: /* CIL Label */ 
#line 238
    if (! (namingBitmap[((int const   )namePages[(unsigned char )*(ptr + 1)] << 3) + (int const   )((int )((unsigned char )*(ptr + 0)) >> 5)] & (unsigned int const   )(1 << ((int )((unsigned char )*(ptr + 0)) & 31)))) {
#line 238
      *nextTokPtr = ptr;
#line 238
      return (0);
    }
    case_27: /* CIL Label */ 
    case_26: /* CIL Label */ 
    case_25: /* CIL Label */ 
    case_24___0: /* CIL Label */ 
    case_22___0: /* CIL Label */ 
#line 238
    ptr += 2;
#line 238
    goto switch_break___0;
    case_5___0: /* CIL Label */ 
#line 238
    if (end - ptr < 2L) {
#line 238
      return (-2);
    }
#line 238
    *nextTokPtr = ptr;
#line 238
    return (0);
#line 238
    ptr += 2;
#line 238
    goto switch_break___0;
    case_6___0: /* CIL Label */ 
#line 238
    if (end - ptr < 3L) {
#line 238
      return (-2);
    }
#line 238
    *nextTokPtr = ptr;
#line 238
    return (0);
#line 238
    ptr += 3;
#line 238
    goto switch_break___0;
    case_7___0: /* CIL Label */ 
#line 238
    if (end - ptr < 4L) {
#line 238
      return (-2);
    }
#line 238
    *nextTokPtr = ptr;
#line 238
    return (0);
#line 238
    ptr += 4;
#line 238
    goto switch_break___0;
    case_10: /* CIL Label */ 
    case_9: /* CIL Label */ 
    case_21: /* CIL Label */ 
    {
#line 240
    tmp___3 = little2_checkPiTarget(enc, target, ptr, & tok);
    }
#line 240
    if (! tmp___3) {
#line 241
      *nextTokPtr = ptr;
#line 242
      return (0);
    }
#line 244
    ptr += 2;
    {
#line 245
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 245
      if (! ((unsigned long )ptr != (unsigned long )end)) {
#line 245
        goto while_break___0;
      }
#line 246
      if ((int const   )*(ptr + 1) == 0) {
#line 246
        tmp___5 = (int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr];
      } else {
        {
#line 246
        tmp___4 = unicode_byte_type((char )*(ptr + 1), (char )*(ptr + 0));
#line 246
        tmp___5 = tmp___4;
        }
      }
      {
#line 247
      if (tmp___5 == 5) {
#line 247
        goto case_5___1;
      }
#line 247
      if (tmp___5 == 6) {
#line 247
        goto case_6___1;
      }
#line 247
      if (tmp___5 == 7) {
#line 247
        goto case_7___1;
      }
#line 247
      if (tmp___5 == 8) {
#line 247
        goto case_8;
      }
#line 247
      if (tmp___5 == 1) {
#line 247
        goto case_8;
      }
#line 247
      if (tmp___5 == 0) {
#line 247
        goto case_8;
      }
#line 248
      if (tmp___5 == 15) {
#line 248
        goto case_15;
      }
#line 257
      goto switch_default___0;
      case_5___1: /* CIL Label */ 
#line 247
      if (end - ptr < 2L) {
#line 247
        return (-2);
      }
#line 247
      ptr += 2;
#line 247
      goto switch_break___1;
      case_6___1: /* CIL Label */ 
#line 247
      if (end - ptr < 3L) {
#line 247
        return (-2);
      }
#line 247
      ptr += 3;
#line 247
      goto switch_break___1;
      case_7___1: /* CIL Label */ 
#line 247
      if (end - ptr < 4L) {
#line 247
        return (-2);
      }
#line 247
      ptr += 4;
#line 247
      goto switch_break___1;
      case_8: /* CIL Label */ 
      case_1: /* CIL Label */ 
      case_0: /* CIL Label */ 
#line 247
      *nextTokPtr = ptr;
#line 247
      return (0);
      case_15: /* CIL Label */ 
#line 249
      ptr += 2;
#line 250
      if ((unsigned long )ptr == (unsigned long )end) {
#line 251
        return (-1);
      }
#line 252
      if ((int const   )*(ptr + 1) == 0) {
#line 252
        if ((int const   )*(ptr + 0) == 62) {
#line 253
          *nextTokPtr = ptr + 2;
#line 254
          return (tok);
        }
      }
#line 256
      goto switch_break___1;
      switch_default___0: /* CIL Label */ 
#line 258
      ptr += 2;
#line 259
      goto switch_break___1;
      switch_break___1: /* CIL Label */ ;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 262
    return (-1);
    case_15___0: /* CIL Label */ 
    {
#line 264
    tmp___6 = little2_checkPiTarget(enc, target, ptr, & tok);
    }
#line 264
    if (! tmp___6) {
#line 265
      *nextTokPtr = ptr;
#line 266
      return (0);
    }
#line 268
    ptr += 2;
#line 269
    if ((unsigned long )ptr == (unsigned long )end) {
#line 270
      return (-1);
    }
#line 271
    if ((int const   )*(ptr + 1) == 0) {
#line 271
      if ((int const   )*(ptr + 0) == 62) {
#line 272
        *nextTokPtr = ptr + 2;
#line 273
        return (tok);
      }
    }
    switch_default___1: /* CIL Label */ 
#line 277
    *nextTokPtr = ptr;
#line 278
    return (0);
    switch_break___0: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 281
  return (-1);
}
}
#line 288
static int little2_scanCdataSection(ENCODING const   *enc , char const   *ptr , char const   *end ,
                                    char const   **nextTokPtr ) ;
#line 288 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmltok_impl.c"
static char const   CDATA_LSQB___0[6]  = {      (char const   )67,      (char const   )68,      (char const   )65,      (char const   )84, 
        (char const   )65,      (char const   )91};
#line 284 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmltok_impl.c"
static int little2_scanCdataSection(ENCODING const   *enc , char const   *ptr , char const   *end ,
                                    char const   **nextTokPtr ) 
{ 
  int i ;

  {
#line 292
  if (end - ptr < 12L) {
#line 293
    return (-1);
  }
#line 294
  i = 0;
  {
#line 294
  while (1) {
    while_continue: /* CIL Label */ ;
#line 294
    if (! (i < 6)) {
#line 294
      goto while_break;
    }
#line 295
    if ((int const   )*(ptr + 1) == 0) {
#line 295
      if (! ((int const   )*(ptr + 0) == (int const   )CDATA_LSQB___0[i])) {
#line 296
        *nextTokPtr = ptr;
#line 297
        return (0);
      }
    } else {
#line 296
      *nextTokPtr = ptr;
#line 297
      return (0);
    }
#line 294
    i ++;
#line 294
    ptr += 2;
  }
  while_break: /* CIL Label */ ;
  }
#line 300
  *nextTokPtr = ptr;
#line 301
  return (8);
}
}
#line 304 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmltok_impl.c"
static int little2_cdataSectionTok(ENCODING const   *enc , char const   *ptr , char const   *end ,
                                   char const   **nextTokPtr ) 
{ 
  size_t n ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 308
  if ((unsigned long )ptr == (unsigned long )end) {
#line 309
    return (-4);
  }
#line 311
  n = (size_t )(end - ptr);
#line 312
  if (n & 1UL) {
#line 313
    n &= 0xfffffffffffffffeUL;
#line 314
    if (n == 0UL) {
#line 315
      return (-1);
    }
#line 316
    end = ptr + n;
  }
#line 319
  if ((int const   )*(ptr + 1) == 0) {
#line 319
    tmp___0 = (int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr];
  } else {
    {
#line 319
    tmp = unicode_byte_type((char )*(ptr + 1), (char )*(ptr + 0));
#line 319
    tmp___0 = tmp;
    }
  }
  {
#line 320
  if (tmp___0 == 4) {
#line 320
    goto case_4;
  }
#line 335
  if (tmp___0 == 9) {
#line 335
    goto case_9;
  }
#line 343
  if (tmp___0 == 10) {
#line 343
    goto case_10;
  }
#line 346
  if (tmp___0 == 5) {
#line 346
    goto case_5;
  }
#line 346
  if (tmp___0 == 6) {
#line 346
    goto case_6;
  }
#line 346
  if (tmp___0 == 7) {
#line 346
    goto case_7;
  }
#line 346
  if (tmp___0 == 8) {
#line 346
    goto case_8;
  }
#line 346
  if (tmp___0 == 1) {
#line 346
    goto case_8;
  }
#line 346
  if (tmp___0 == 0) {
#line 346
    goto case_8;
  }
#line 347
  goto switch_default;
  case_4: /* CIL Label */ 
#line 321
  ptr += 2;
#line 322
  if ((unsigned long )ptr == (unsigned long )end) {
#line 323
    return (-1);
  }
#line 324
  if ((int const   )*(ptr + 1) == 0) {
#line 324
    if (! ((int const   )*(ptr + 0) == 93)) {
#line 325
      goto switch_break;
    }
  } else {
#line 325
    goto switch_break;
  }
#line 326
  ptr += 2;
#line 327
  if ((unsigned long )ptr == (unsigned long )end) {
#line 328
    return (-1);
  }
#line 329
  if ((int const   )*(ptr + 1) == 0) {
#line 329
    if (! ((int const   )*(ptr + 0) == 62)) {
#line 330
      ptr -= 2;
#line 331
      goto switch_break;
    }
  } else {
#line 330
    ptr -= 2;
#line 331
    goto switch_break;
  }
#line 333
  *nextTokPtr = ptr + 2;
#line 334
  return (40);
  case_9: /* CIL Label */ 
#line 336
  ptr += 2;
#line 337
  if ((unsigned long )ptr == (unsigned long )end) {
#line 338
    return (-1);
  }
#line 339
  if ((int const   )*(ptr + 1) == 0) {
#line 339
    tmp___2 = (int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr];
  } else {
    {
#line 339
    tmp___1 = unicode_byte_type((char )*(ptr + 1), (char )*(ptr + 0));
#line 339
    tmp___2 = tmp___1;
    }
  }
#line 339
  if (tmp___2 == 10) {
#line 340
    ptr += 2;
  }
#line 341
  *nextTokPtr = ptr;
#line 342
  return (7);
  case_10: /* CIL Label */ 
#line 344
  *nextTokPtr = ptr + 2;
#line 345
  return (7);
  case_5: /* CIL Label */ 
#line 346
  if (end - ptr < 2L) {
#line 346
    return (-2);
  }
#line 346
  ptr += 2;
#line 346
  goto switch_break;
  case_6: /* CIL Label */ 
#line 346
  if (end - ptr < 3L) {
#line 346
    return (-2);
  }
#line 346
  ptr += 3;
#line 346
  goto switch_break;
  case_7: /* CIL Label */ 
#line 346
  if (end - ptr < 4L) {
#line 346
    return (-2);
  }
#line 346
  ptr += 4;
#line 346
  goto switch_break;
  case_8: /* CIL Label */ 
  case_1: /* CIL Label */ 
  case_0: /* CIL Label */ 
#line 346
  *nextTokPtr = ptr;
#line 346
  return (0);
  switch_default: /* CIL Label */ 
#line 348
  ptr += 2;
#line 349
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 351
  while (1) {
    while_continue: /* CIL Label */ ;
#line 351
    if (! ((unsigned long )ptr != (unsigned long )end)) {
#line 351
      goto while_break;
    }
#line 352
    if ((int const   )*(ptr + 1) == 0) {
#line 352
      tmp___4 = (int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr];
    } else {
      {
#line 352
      tmp___3 = unicode_byte_type((char )*(ptr + 1), (char )*(ptr + 0));
#line 352
      tmp___4 = tmp___3;
      }
    }
    {
#line 361
    if (tmp___4 == 5) {
#line 361
      goto case_5___0;
    }
#line 361
    if (tmp___4 == 6) {
#line 361
      goto case_6___0;
    }
#line 361
    if (tmp___4 == 7) {
#line 361
      goto case_7___0;
    }
#line 368
    if (tmp___4 == 4) {
#line 368
      goto case_4___0;
    }
#line 368
    if (tmp___4 == 10) {
#line 368
      goto case_4___0;
    }
#line 368
    if (tmp___4 == 9) {
#line 368
      goto case_4___0;
    }
#line 368
    if (tmp___4 == 8) {
#line 368
      goto case_4___0;
    }
#line 368
    if (tmp___4 == 1) {
#line 368
      goto case_4___0;
    }
#line 368
    if (tmp___4 == 0) {
#line 368
      goto case_4___0;
    }
#line 371
    goto switch_default___0;
    case_5___0: /* CIL Label */ 
#line 361
    if (end - ptr < 2L) {
#line 361
      *nextTokPtr = ptr;
#line 361
      return (6);
    }
#line 361
    ptr += 2;
#line 361
    goto switch_break___0;
    case_6___0: /* CIL Label */ 
#line 361
    if (end - ptr < 3L) {
#line 361
      *nextTokPtr = ptr;
#line 361
      return (6);
    }
#line 361
    ptr += 3;
#line 361
    goto switch_break___0;
    case_7___0: /* CIL Label */ 
#line 361
    if (end - ptr < 4L) {
#line 361
      *nextTokPtr = ptr;
#line 361
      return (6);
    }
#line 361
    ptr += 4;
#line 361
    goto switch_break___0;
    case_4___0: /* CIL Label */ 
    case_10___0: /* CIL Label */ 
    case_9___0: /* CIL Label */ 
    case_8___0: /* CIL Label */ 
    case_1___0: /* CIL Label */ 
    case_0___0: /* CIL Label */ 
#line 369
    *nextTokPtr = ptr;
#line 370
    return (6);
    switch_default___0: /* CIL Label */ 
#line 372
    ptr += 2;
#line 373
    goto switch_break___0;
    switch_break___0: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 376
  *nextTokPtr = ptr;
#line 377
  return (6);
}
}
#line 382 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmltok_impl.c"
static int little2_scanEndTag(ENCODING const   *enc , char const   *ptr , char const   *end ,
                              char const   **nextTokPtr ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 386
  if ((unsigned long )ptr == (unsigned long )end) {
#line 387
    return (-1);
  }
#line 388
  if ((int const   )*(ptr + 1) == 0) {
#line 388
    tmp___0 = (int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr];
  } else {
    {
#line 388
    tmp = unicode_byte_type((char )*(ptr + 1), (char )*(ptr + 0));
#line 388
    tmp___0 = tmp;
    }
  }
  {
#line 389
  if (tmp___0 == 29) {
#line 389
    goto case_29;
  }
#line 389
  if (tmp___0 == 24) {
#line 389
    goto case_24;
  }
#line 389
  if (tmp___0 == 22) {
#line 389
    goto case_24;
  }
#line 389
  if (tmp___0 == 5) {
#line 389
    goto case_5;
  }
#line 389
  if (tmp___0 == 6) {
#line 389
    goto case_6;
  }
#line 389
  if (tmp___0 == 7) {
#line 389
    goto case_7;
  }
#line 390
  goto switch_default;
  case_29: /* CIL Label */ 
#line 389
  if (! (namingBitmap[((int const   )nmstrtPages[(unsigned char )*(ptr + 1)] << 3) + (int const   )((int )((unsigned char )*(ptr + 0)) >> 5)] & (unsigned int const   )(1 << ((int )((unsigned char )*(ptr + 0)) & 31)))) {
#line 389
    *nextTokPtr = ptr;
#line 389
    return (0);
  }
  case_24: /* CIL Label */ 
  case_22: /* CIL Label */ 
#line 389
  ptr += 2;
#line 389
  goto switch_break;
  case_5: /* CIL Label */ 
#line 389
  if (end - ptr < 2L) {
#line 389
    return (-2);
  }
#line 389
  *nextTokPtr = ptr;
#line 389
  return (0);
#line 389
  ptr += 2;
#line 389
  goto switch_break;
  case_6: /* CIL Label */ 
#line 389
  if (end - ptr < 3L) {
#line 389
    return (-2);
  }
#line 389
  *nextTokPtr = ptr;
#line 389
  return (0);
#line 389
  ptr += 3;
#line 389
  goto switch_break;
  case_7: /* CIL Label */ 
#line 389
  if (end - ptr < 4L) {
#line 389
    return (-2);
  }
#line 389
  *nextTokPtr = ptr;
#line 389
  return (0);
#line 389
  ptr += 4;
#line 389
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 391
  *nextTokPtr = ptr;
#line 392
  return (0);
  switch_break: /* CIL Label */ ;
  }
  {
#line 394
  while (1) {
    while_continue: /* CIL Label */ ;
#line 394
    if (! ((unsigned long )ptr != (unsigned long )end)) {
#line 394
      goto while_break;
    }
#line 395
    if ((int const   )*(ptr + 1) == 0) {
#line 395
      tmp___2 = (int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr];
    } else {
      {
#line 395
      tmp___1 = unicode_byte_type((char )*(ptr + 1), (char )*(ptr + 0));
#line 395
      tmp___2 = tmp___1;
      }
    }
    {
#line 396
    if (tmp___2 == 29) {
#line 396
      goto case_29___0;
    }
#line 396
    if (tmp___2 == 27) {
#line 396
      goto case_27;
    }
#line 396
    if (tmp___2 == 26) {
#line 396
      goto case_27;
    }
#line 396
    if (tmp___2 == 25) {
#line 396
      goto case_27;
    }
#line 396
    if (tmp___2 == 24) {
#line 396
      goto case_27;
    }
#line 396
    if (tmp___2 == 22) {
#line 396
      goto case_27;
    }
#line 396
    if (tmp___2 == 5) {
#line 396
      goto case_5___0;
    }
#line 396
    if (tmp___2 == 6) {
#line 396
      goto case_6___0;
    }
#line 396
    if (tmp___2 == 7) {
#line 396
      goto case_7___0;
    }
#line 397
    if (tmp___2 == 10) {
#line 397
      goto case_10;
    }
#line 397
    if (tmp___2 == 9) {
#line 397
      goto case_10;
    }
#line 397
    if (tmp___2 == 21) {
#line 397
      goto case_10;
    }
#line 412
    if (tmp___2 == 23) {
#line 412
      goto case_23;
    }
#line 418
    if (tmp___2 == 11) {
#line 418
      goto case_11___0;
    }
#line 421
    goto switch_default___1;
    case_29___0: /* CIL Label */ 
#line 396
    if (! (namingBitmap[((int const   )namePages[(unsigned char )*(ptr + 1)] << 3) + (int const   )((int )((unsigned char )*(ptr + 0)) >> 5)] & (unsigned int const   )(1 << ((int )((unsigned char )*(ptr + 0)) & 31)))) {
#line 396
      *nextTokPtr = ptr;
#line 396
      return (0);
    }
    case_27: /* CIL Label */ 
    case_26: /* CIL Label */ 
    case_25: /* CIL Label */ 
    case_24___0: /* CIL Label */ 
    case_22___0: /* CIL Label */ 
#line 396
    ptr += 2;
#line 396
    goto switch_break___0;
    case_5___0: /* CIL Label */ 
#line 396
    if (end - ptr < 2L) {
#line 396
      return (-2);
    }
#line 396
    *nextTokPtr = ptr;
#line 396
    return (0);
#line 396
    ptr += 2;
#line 396
    goto switch_break___0;
    case_6___0: /* CIL Label */ 
#line 396
    if (end - ptr < 3L) {
#line 396
      return (-2);
    }
#line 396
    *nextTokPtr = ptr;
#line 396
    return (0);
#line 396
    ptr += 3;
#line 396
    goto switch_break___0;
    case_7___0: /* CIL Label */ 
#line 396
    if (end - ptr < 4L) {
#line 396
      return (-2);
    }
#line 396
    *nextTokPtr = ptr;
#line 396
    return (0);
#line 396
    ptr += 4;
#line 396
    goto switch_break___0;
    case_10: /* CIL Label */ 
    case_9: /* CIL Label */ 
    case_21: /* CIL Label */ 
#line 398
    ptr += 2;
    {
#line 398
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 398
      if (! ((unsigned long )ptr != (unsigned long )end)) {
#line 398
        goto while_break___0;
      }
#line 399
      if ((int const   )*(ptr + 1) == 0) {
#line 399
        tmp___4 = (int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr];
      } else {
        {
#line 399
        tmp___3 = unicode_byte_type((char )*(ptr + 1), (char )*(ptr + 0));
#line 399
        tmp___4 = tmp___3;
        }
      }
      {
#line 400
      if (tmp___4 == 10) {
#line 400
        goto case_10___0;
      }
#line 400
      if (tmp___4 == 9) {
#line 400
        goto case_10___0;
      }
#line 400
      if (tmp___4 == 21) {
#line 400
        goto case_10___0;
      }
#line 402
      if (tmp___4 == 11) {
#line 402
        goto case_11;
      }
#line 405
      goto switch_default___0;
      case_10___0: /* CIL Label */ 
      case_9___0: /* CIL Label */ 
      case_21___0: /* CIL Label */ 
#line 401
      goto switch_break___1;
      case_11: /* CIL Label */ 
#line 403
      *nextTokPtr = ptr + 2;
#line 404
      return (5);
      switch_default___0: /* CIL Label */ 
#line 406
      *nextTokPtr = ptr;
#line 407
      return (0);
      switch_break___1: /* CIL Label */ ;
      }
#line 398
      ptr += 2;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 410
    return (-1);
    case_23: /* CIL Label */ 
#line 415
    ptr += 2;
#line 416
    goto switch_break___0;
    case_11___0: /* CIL Label */ 
#line 419
    *nextTokPtr = ptr + 2;
#line 420
    return (5);
    switch_default___1: /* CIL Label */ 
#line 422
    *nextTokPtr = ptr;
#line 423
    return (0);
    switch_break___0: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 426
  return (-1);
}
}
#line 431 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmltok_impl.c"
static int little2_scanHexCharRef(ENCODING const   *enc , char const   *ptr , char const   *end ,
                                  char const   **nextTokPtr ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 435
  if ((unsigned long )ptr != (unsigned long )end) {
#line 436
    if ((int const   )*(ptr + 1) == 0) {
#line 436
      tmp___0 = (int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr];
    } else {
      {
#line 436
      tmp = unicode_byte_type((char )*(ptr + 1), (char )*(ptr + 0));
#line 436
      tmp___0 = tmp;
      }
    }
    {
#line 438
    if (tmp___0 == 24) {
#line 438
      goto case_24;
    }
#line 438
    if (tmp___0 == 25) {
#line 438
      goto case_24;
    }
#line 440
    goto switch_default;
    case_24: /* CIL Label */ 
    case_25: /* CIL Label */ 
#line 439
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 441
    *nextTokPtr = ptr;
#line 442
    return (0);
    switch_break: /* CIL Label */ ;
    }
#line 444
    ptr += 2;
    {
#line 444
    while (1) {
      while_continue: /* CIL Label */ ;
#line 444
      if (! ((unsigned long )ptr != (unsigned long )end)) {
#line 444
        goto while_break;
      }
#line 445
      if ((int const   )*(ptr + 1) == 0) {
#line 445
        tmp___2 = (int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr];
      } else {
        {
#line 445
        tmp___1 = unicode_byte_type((char )*(ptr + 1), (char )*(ptr + 0));
#line 445
        tmp___2 = tmp___1;
        }
      }
      {
#line 447
      if (tmp___2 == 24) {
#line 447
        goto case_24___0;
      }
#line 447
      if (tmp___2 == 25) {
#line 447
        goto case_24___0;
      }
#line 449
      if (tmp___2 == 18) {
#line 449
        goto case_18;
      }
#line 452
      goto switch_default___0;
      case_24___0: /* CIL Label */ 
      case_25___0: /* CIL Label */ 
#line 448
      goto switch_break___0;
      case_18: /* CIL Label */ 
#line 450
      *nextTokPtr = ptr + 2;
#line 451
      return (10);
      switch_default___0: /* CIL Label */ 
#line 453
      *nextTokPtr = ptr;
#line 454
      return (0);
      switch_break___0: /* CIL Label */ ;
      }
#line 444
      ptr += 2;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 458
  return (-1);
}
}
#line 463 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmltok_impl.c"
static int little2_scanCharRef(ENCODING const   *enc , char const   *ptr , char const   *end ,
                               char const   **nextTokPtr ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 467
  if ((unsigned long )ptr != (unsigned long )end) {
#line 468
    if ((int const   )*(ptr + 1) == 0) {
#line 468
      if ((int const   )*(ptr + 0) == 120) {
        {
#line 469
        tmp = little2_scanHexCharRef(enc, ptr + 2, end, nextTokPtr);
        }
#line 469
        return (tmp);
      }
    }
#line 470
    if ((int const   )*(ptr + 1) == 0) {
#line 470
      tmp___1 = (int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr];
    } else {
      {
#line 470
      tmp___0 = unicode_byte_type((char )*(ptr + 1), (char )*(ptr + 0));
#line 470
      tmp___1 = tmp___0;
      }
    }
    {
#line 471
    if (tmp___1 == 25) {
#line 471
      goto case_25;
    }
#line 473
    goto switch_default;
    case_25: /* CIL Label */ 
#line 472
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 474
    *nextTokPtr = ptr;
#line 475
    return (0);
    switch_break: /* CIL Label */ ;
    }
#line 477
    ptr += 2;
    {
#line 477
    while (1) {
      while_continue: /* CIL Label */ ;
#line 477
      if (! ((unsigned long )ptr != (unsigned long )end)) {
#line 477
        goto while_break;
      }
#line 478
      if ((int const   )*(ptr + 1) == 0) {
#line 478
        tmp___3 = (int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr];
      } else {
        {
#line 478
        tmp___2 = unicode_byte_type((char )*(ptr + 1), (char )*(ptr + 0));
#line 478
        tmp___3 = tmp___2;
        }
      }
      {
#line 479
      if (tmp___3 == 25) {
#line 479
        goto case_25___0;
      }
#line 481
      if (tmp___3 == 18) {
#line 481
        goto case_18;
      }
#line 484
      goto switch_default___0;
      case_25___0: /* CIL Label */ 
#line 480
      goto switch_break___0;
      case_18: /* CIL Label */ 
#line 482
      *nextTokPtr = ptr + 2;
#line 483
      return (10);
      switch_default___0: /* CIL Label */ 
#line 485
      *nextTokPtr = ptr;
#line 486
      return (0);
      switch_break___0: /* CIL Label */ ;
      }
#line 477
      ptr += 2;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 490
  return (-1);
}
}
#line 495 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmltok_impl.c"
static int little2_scanRef(ENCODING const   *enc , char const   *ptr , char const   *end ,
                           char const   **nextTokPtr ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 499
  if ((unsigned long )ptr == (unsigned long )end) {
#line 500
    return (-1);
  }
#line 501
  if ((int const   )*(ptr + 1) == 0) {
#line 501
    tmp___0 = (int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr];
  } else {
    {
#line 501
    tmp = unicode_byte_type((char )*(ptr + 1), (char )*(ptr + 0));
#line 501
    tmp___0 = tmp;
    }
  }
  {
#line 502
  if (tmp___0 == 29) {
#line 502
    goto case_29;
  }
#line 502
  if (tmp___0 == 24) {
#line 502
    goto case_24;
  }
#line 502
  if (tmp___0 == 22) {
#line 502
    goto case_24;
  }
#line 502
  if (tmp___0 == 5) {
#line 502
    goto case_5;
  }
#line 502
  if (tmp___0 == 6) {
#line 502
    goto case_6;
  }
#line 502
  if (tmp___0 == 7) {
#line 502
    goto case_7;
  }
#line 503
  if (tmp___0 == 19) {
#line 503
    goto case_19;
  }
#line 505
  goto switch_default;
  case_29: /* CIL Label */ 
#line 502
  if (! (namingBitmap[((int const   )nmstrtPages[(unsigned char )*(ptr + 1)] << 3) + (int const   )((int )((unsigned char )*(ptr + 0)) >> 5)] & (unsigned int const   )(1 << ((int )((unsigned char )*(ptr + 0)) & 31)))) {
#line 502
    *nextTokPtr = ptr;
#line 502
    return (0);
  }
  case_24: /* CIL Label */ 
  case_22: /* CIL Label */ 
#line 502
  ptr += 2;
#line 502
  goto switch_break;
  case_5: /* CIL Label */ 
#line 502
  if (end - ptr < 2L) {
#line 502
    return (-2);
  }
#line 502
  *nextTokPtr = ptr;
#line 502
  return (0);
#line 502
  ptr += 2;
#line 502
  goto switch_break;
  case_6: /* CIL Label */ 
#line 502
  if (end - ptr < 3L) {
#line 502
    return (-2);
  }
#line 502
  *nextTokPtr = ptr;
#line 502
  return (0);
#line 502
  ptr += 3;
#line 502
  goto switch_break;
  case_7: /* CIL Label */ 
#line 502
  if (end - ptr < 4L) {
#line 502
    return (-2);
  }
#line 502
  *nextTokPtr = ptr;
#line 502
  return (0);
#line 502
  ptr += 4;
#line 502
  goto switch_break;
  case_19: /* CIL Label */ 
  {
#line 504
  tmp___1 = little2_scanCharRef(enc, ptr + 2, end, nextTokPtr);
  }
#line 504
  return (tmp___1);
  switch_default: /* CIL Label */ 
#line 506
  *nextTokPtr = ptr;
#line 507
  return (0);
  switch_break: /* CIL Label */ ;
  }
  {
#line 509
  while (1) {
    while_continue: /* CIL Label */ ;
#line 509
    if (! ((unsigned long )ptr != (unsigned long )end)) {
#line 509
      goto while_break;
    }
#line 510
    if ((int const   )*(ptr + 1) == 0) {
#line 510
      tmp___3 = (int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr];
    } else {
      {
#line 510
      tmp___2 = unicode_byte_type((char )*(ptr + 1), (char )*(ptr + 0));
#line 510
      tmp___3 = tmp___2;
      }
    }
    {
#line 511
    if (tmp___3 == 29) {
#line 511
      goto case_29___0;
    }
#line 511
    if (tmp___3 == 27) {
#line 511
      goto case_27;
    }
#line 511
    if (tmp___3 == 26) {
#line 511
      goto case_27;
    }
#line 511
    if (tmp___3 == 25) {
#line 511
      goto case_27;
    }
#line 511
    if (tmp___3 == 24) {
#line 511
      goto case_27;
    }
#line 511
    if (tmp___3 == 22) {
#line 511
      goto case_27;
    }
#line 511
    if (tmp___3 == 5) {
#line 511
      goto case_5___0;
    }
#line 511
    if (tmp___3 == 6) {
#line 511
      goto case_6___0;
    }
#line 511
    if (tmp___3 == 7) {
#line 511
      goto case_7___0;
    }
#line 512
    if (tmp___3 == 18) {
#line 512
      goto case_18;
    }
#line 515
    goto switch_default___0;
    case_29___0: /* CIL Label */ 
#line 511
    if (! (namingBitmap[((int const   )namePages[(unsigned char )*(ptr + 1)] << 3) + (int const   )((int )((unsigned char )*(ptr + 0)) >> 5)] & (unsigned int const   )(1 << ((int )((unsigned char )*(ptr + 0)) & 31)))) {
#line 511
      *nextTokPtr = ptr;
#line 511
      return (0);
    }
    case_27: /* CIL Label */ 
    case_26: /* CIL Label */ 
    case_25: /* CIL Label */ 
    case_24___0: /* CIL Label */ 
    case_22___0: /* CIL Label */ 
#line 511
    ptr += 2;
#line 511
    goto switch_break___0;
    case_5___0: /* CIL Label */ 
#line 511
    if (end - ptr < 2L) {
#line 511
      return (-2);
    }
#line 511
    *nextTokPtr = ptr;
#line 511
    return (0);
#line 511
    ptr += 2;
#line 511
    goto switch_break___0;
    case_6___0: /* CIL Label */ 
#line 511
    if (end - ptr < 3L) {
#line 511
      return (-2);
    }
#line 511
    *nextTokPtr = ptr;
#line 511
    return (0);
#line 511
    ptr += 3;
#line 511
    goto switch_break___0;
    case_7___0: /* CIL Label */ 
#line 511
    if (end - ptr < 4L) {
#line 511
      return (-2);
    }
#line 511
    *nextTokPtr = ptr;
#line 511
    return (0);
#line 511
    ptr += 4;
#line 511
    goto switch_break___0;
    case_18: /* CIL Label */ 
#line 513
    *nextTokPtr = ptr + 2;
#line 514
    return (9);
    switch_default___0: /* CIL Label */ 
#line 516
    *nextTokPtr = ptr;
#line 517
    return (0);
    switch_break___0: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 520
  return (-1);
}
}
#line 525 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmltok_impl.c"
static int little2_scanAtts(ENCODING const   *enc , char const   *ptr , char const   *end ,
                            char const   **nextTokPtr ) 
{ 
  int hadColon ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int t ;
  int tmp___3 ;
  int open___0 ;
  int tmp___4 ;
  int t___0 ;
  int tmp___5 ;
  int tok ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;

  {
#line 530
  hadColon = 0;
  {
#line 532
  while (1) {
    while_continue: /* CIL Label */ ;
#line 532
    if (! ((unsigned long )ptr != (unsigned long )end)) {
#line 532
      goto while_break;
    }
#line 533
    if ((int const   )*(ptr + 1) == 0) {
#line 533
      tmp___0 = (int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr];
    } else {
      {
#line 533
      tmp = unicode_byte_type((char )*(ptr + 1), (char )*(ptr + 0));
#line 533
      tmp___0 = tmp;
      }
    }
    {
#line 534
    if (tmp___0 == 29) {
#line 534
      goto case_29;
    }
#line 534
    if (tmp___0 == 27) {
#line 534
      goto case_27;
    }
#line 534
    if (tmp___0 == 26) {
#line 534
      goto case_27;
    }
#line 534
    if (tmp___0 == 25) {
#line 534
      goto case_27;
    }
#line 534
    if (tmp___0 == 24) {
#line 534
      goto case_27;
    }
#line 534
    if (tmp___0 == 22) {
#line 534
      goto case_27;
    }
#line 534
    if (tmp___0 == 5) {
#line 534
      goto case_5;
    }
#line 534
    if (tmp___0 == 6) {
#line 534
      goto case_6;
    }
#line 534
    if (tmp___0 == 7) {
#line 534
      goto case_7;
    }
#line 536
    if (tmp___0 == 23) {
#line 536
      goto case_23;
    }
#line 553
    if (tmp___0 == 10) {
#line 553
      goto case_10;
    }
#line 553
    if (tmp___0 == 9) {
#line 553
      goto case_10;
    }
#line 553
    if (tmp___0 == 21) {
#line 553
      goto case_10;
    }
#line 574
    if (tmp___0 == 14) {
#line 574
      goto case_14;
    }
#line 674
    goto switch_default___5;
    case_29: /* CIL Label */ 
#line 534
    if (! (namingBitmap[((int const   )namePages[(unsigned char )*(ptr + 1)] << 3) + (int const   )((int )((unsigned char )*(ptr + 0)) >> 5)] & (unsigned int const   )(1 << ((int )((unsigned char )*(ptr + 0)) & 31)))) {
#line 534
      *nextTokPtr = ptr;
#line 534
      return (0);
    }
    case_27: /* CIL Label */ 
    case_26: /* CIL Label */ 
    case_25: /* CIL Label */ 
    case_24: /* CIL Label */ 
    case_22: /* CIL Label */ 
#line 534
    ptr += 2;
#line 534
    goto switch_break;
    case_5: /* CIL Label */ 
#line 534
    if (end - ptr < 2L) {
#line 534
      return (-2);
    }
#line 534
    *nextTokPtr = ptr;
#line 534
    return (0);
#line 534
    ptr += 2;
#line 534
    goto switch_break;
    case_6: /* CIL Label */ 
#line 534
    if (end - ptr < 3L) {
#line 534
      return (-2);
    }
#line 534
    *nextTokPtr = ptr;
#line 534
    return (0);
#line 534
    ptr += 3;
#line 534
    goto switch_break;
    case_7: /* CIL Label */ 
#line 534
    if (end - ptr < 4L) {
#line 534
      return (-2);
    }
#line 534
    *nextTokPtr = ptr;
#line 534
    return (0);
#line 534
    ptr += 4;
#line 534
    goto switch_break;
    case_23: /* CIL Label */ 
#line 537
    if (hadColon) {
#line 538
      *nextTokPtr = ptr;
#line 539
      return (0);
    }
#line 541
    hadColon = 1;
#line 542
    ptr += 2;
#line 543
    if ((unsigned long )ptr == (unsigned long )end) {
#line 544
      return (-1);
    }
#line 545
    if ((int const   )*(ptr + 1) == 0) {
#line 545
      tmp___2 = (int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr];
    } else {
      {
#line 545
      tmp___1 = unicode_byte_type((char )*(ptr + 1), (char )*(ptr + 0));
#line 545
      tmp___2 = tmp___1;
      }
    }
    {
#line 546
    if (tmp___2 == 29) {
#line 546
      goto case_29___0;
    }
#line 546
    if (tmp___2 == 24) {
#line 546
      goto case_24___0;
    }
#line 546
    if (tmp___2 == 22) {
#line 546
      goto case_24___0;
    }
#line 546
    if (tmp___2 == 5) {
#line 546
      goto case_5___0;
    }
#line 546
    if (tmp___2 == 6) {
#line 546
      goto case_6___0;
    }
#line 546
    if (tmp___2 == 7) {
#line 546
      goto case_7___0;
    }
#line 547
    goto switch_default;
    case_29___0: /* CIL Label */ 
#line 546
    if (! (namingBitmap[((int const   )nmstrtPages[(unsigned char )*(ptr + 1)] << 3) + (int const   )((int )((unsigned char )*(ptr + 0)) >> 5)] & (unsigned int const   )(1 << ((int )((unsigned char )*(ptr + 0)) & 31)))) {
#line 546
      *nextTokPtr = ptr;
#line 546
      return (0);
    }
    case_24___0: /* CIL Label */ 
    case_22___0: /* CIL Label */ 
#line 546
    ptr += 2;
#line 546
    goto switch_break___0;
    case_5___0: /* CIL Label */ 
#line 546
    if (end - ptr < 2L) {
#line 546
      return (-2);
    }
#line 546
    *nextTokPtr = ptr;
#line 546
    return (0);
#line 546
    ptr += 2;
#line 546
    goto switch_break___0;
    case_6___0: /* CIL Label */ 
#line 546
    if (end - ptr < 3L) {
#line 546
      return (-2);
    }
#line 546
    *nextTokPtr = ptr;
#line 546
    return (0);
#line 546
    ptr += 3;
#line 546
    goto switch_break___0;
    case_7___0: /* CIL Label */ 
#line 546
    if (end - ptr < 4L) {
#line 546
      return (-2);
    }
#line 546
    *nextTokPtr = ptr;
#line 546
    return (0);
#line 546
    ptr += 4;
#line 546
    goto switch_break___0;
    switch_default: /* CIL Label */ 
#line 548
    *nextTokPtr = ptr;
#line 549
    return (0);
    switch_break___0: /* CIL Label */ ;
    }
#line 551
    goto switch_break;
    case_10: /* CIL Label */ 
    case_9: /* CIL Label */ 
    case_21: /* CIL Label */ 
    {
#line 554
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 557
      ptr += 2;
#line 558
      if ((unsigned long )ptr == (unsigned long )end) {
#line 559
        return (-1);
      }
#line 560
      if ((int const   )*(ptr + 1) == 0) {
#line 560
        t = (int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr];
      } else {
        {
#line 560
        tmp___3 = unicode_byte_type((char )*(ptr + 1), (char )*(ptr + 0));
#line 560
        t = tmp___3;
        }
      }
#line 561
      if (t == 14) {
#line 562
        goto while_break___0;
      }
      {
#line 566
      if (t == 9) {
#line 566
        goto case_9___0;
      }
#line 566
      if (t == 10) {
#line 566
        goto case_9___0;
      }
#line 566
      if (t == 21) {
#line 566
        goto case_9___0;
      }
#line 568
      goto switch_default___0;
      case_9___0: /* CIL Label */ 
      case_10___0: /* CIL Label */ 
      case_21___0: /* CIL Label */ 
#line 567
      goto switch_break___1;
      switch_default___0: /* CIL Label */ 
#line 569
      *nextTokPtr = ptr;
#line 570
      return (0);
      switch_break___1: /* CIL Label */ ;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    case_14: /* CIL Label */ 
#line 578
    hadColon = 0;
    {
#line 580
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 581
      ptr += 2;
#line 582
      if ((unsigned long )ptr == (unsigned long )end) {
#line 583
        return (-1);
      }
#line 584
      if ((int const   )*(ptr + 1) == 0) {
#line 584
        open___0 = (int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr];
      } else {
        {
#line 584
        tmp___4 = unicode_byte_type((char )*(ptr + 1), (char )*(ptr + 0));
#line 584
        open___0 = tmp___4;
        }
      }
#line 585
      if (open___0 == 12) {
#line 586
        goto while_break___1;
      } else
#line 585
      if (open___0 == 13) {
#line 586
        goto while_break___1;
      }
      {
#line 590
      if (open___0 == 9) {
#line 590
        goto case_9___1;
      }
#line 590
      if (open___0 == 10) {
#line 590
        goto case_9___1;
      }
#line 590
      if (open___0 == 21) {
#line 590
        goto case_9___1;
      }
#line 592
      goto switch_default___1;
      case_9___1: /* CIL Label */ 
      case_10___1: /* CIL Label */ 
      case_21___1: /* CIL Label */ 
#line 591
      goto switch_break___2;
      switch_default___1: /* CIL Label */ 
#line 593
      *nextTokPtr = ptr;
#line 594
      return (0);
      switch_break___2: /* CIL Label */ ;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
#line 597
    ptr += 2;
    {
#line 599
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 601
      if ((unsigned long )ptr == (unsigned long )end) {
#line 602
        return (-1);
      }
#line 603
      if ((int const   )*(ptr + 1) == 0) {
#line 603
        t___0 = (int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr];
      } else {
        {
#line 603
        tmp___5 = unicode_byte_type((char )*(ptr + 1), (char )*(ptr + 0));
#line 603
        t___0 = tmp___5;
        }
      }
#line 604
      if (t___0 == open___0) {
#line 605
        goto while_break___2;
      }
      {
#line 607
      if (t___0 == 5) {
#line 607
        goto case_5___1;
      }
#line 607
      if (t___0 == 6) {
#line 607
        goto case_6___1;
      }
#line 607
      if (t___0 == 7) {
#line 607
        goto case_7___1;
      }
#line 607
      if (t___0 == 8) {
#line 607
        goto case_8;
      }
#line 607
      if (t___0 == 1) {
#line 607
        goto case_8;
      }
#line 607
      if (t___0 == 0) {
#line 607
        goto case_8;
      }
#line 608
      if (t___0 == 3) {
#line 608
        goto case_3;
      }
#line 618
      if (t___0 == 2) {
#line 618
        goto case_2;
      }
#line 621
      goto switch_default___2;
      case_5___1: /* CIL Label */ 
#line 607
      if (end - ptr < 2L) {
#line 607
        return (-2);
      }
#line 607
      ptr += 2;
#line 607
      goto switch_break___3;
      case_6___1: /* CIL Label */ 
#line 607
      if (end - ptr < 3L) {
#line 607
        return (-2);
      }
#line 607
      ptr += 3;
#line 607
      goto switch_break___3;
      case_7___1: /* CIL Label */ 
#line 607
      if (end - ptr < 4L) {
#line 607
        return (-2);
      }
#line 607
      ptr += 4;
#line 607
      goto switch_break___3;
      case_8: /* CIL Label */ 
      case_1: /* CIL Label */ 
      case_0: /* CIL Label */ 
#line 607
      *nextTokPtr = ptr;
#line 607
      return (0);
      case_3: /* CIL Label */ 
      {
#line 610
      tmp___6 = little2_scanRef(enc, ptr + 2, end, & ptr);
#line 610
      tok = tmp___6;
      }
#line 611
      if (tok <= 0) {
#line 612
        if (tok == 0) {
#line 613
          *nextTokPtr = ptr;
        }
#line 614
        return (tok);
      }
#line 616
      goto switch_break___3;
      case_2: /* CIL Label */ 
#line 619
      *nextTokPtr = ptr;
#line 620
      return (0);
      switch_default___2: /* CIL Label */ 
#line 622
      ptr += 2;
#line 623
      goto switch_break___3;
      switch_break___3: /* CIL Label */ ;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
#line 626
    ptr += 2;
#line 627
    if ((unsigned long )ptr == (unsigned long )end) {
#line 628
      return (-1);
    }
#line 629
    if ((int const   )*(ptr + 1) == 0) {
#line 629
      tmp___8 = (int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr];
    } else {
      {
#line 629
      tmp___7 = unicode_byte_type((char )*(ptr + 1), (char )*(ptr + 0));
#line 629
      tmp___8 = tmp___7;
      }
    }
    {
#line 632
    if (tmp___8 == 10) {
#line 632
      goto case_10___2;
    }
#line 632
    if (tmp___8 == 9) {
#line 632
      goto case_10___2;
    }
#line 632
    if (tmp___8 == 21) {
#line 632
      goto case_10___2;
    }
#line 634
    if (tmp___8 == 17) {
#line 634
      goto case_17;
    }
#line 636
    if (tmp___8 == 11) {
#line 636
      goto case_11;
    }
#line 638
    goto switch_default___3;
    case_10___2: /* CIL Label */ 
    case_9___2: /* CIL Label */ 
    case_21___2: /* CIL Label */ 
#line 633
    goto switch_break___4;
    case_17: /* CIL Label */ 
#line 635
    goto sol;
    case_11: /* CIL Label */ 
#line 637
    goto gt;
    switch_default___3: /* CIL Label */ 
#line 639
    *nextTokPtr = ptr;
#line 640
    return (0);
    switch_break___4: /* CIL Label */ ;
    }
    {
#line 643
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 644
      ptr += 2;
#line 645
      if ((unsigned long )ptr == (unsigned long )end) {
#line 646
        return (-1);
      }
#line 647
      if ((int const   )*(ptr + 1) == 0) {
#line 647
        tmp___10 = (int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr];
      } else {
        {
#line 647
        tmp___9 = unicode_byte_type((char )*(ptr + 1), (char )*(ptr + 0));
#line 647
        tmp___10 = tmp___9;
        }
      }
      {
#line 648
      if (tmp___10 == 29) {
#line 648
        goto case_29___1;
      }
#line 648
      if (tmp___10 == 24) {
#line 648
        goto case_24___1;
      }
#line 648
      if (tmp___10 == 22) {
#line 648
        goto case_24___1;
      }
#line 648
      if (tmp___10 == 5) {
#line 648
        goto case_5___2;
      }
#line 648
      if (tmp___10 == 6) {
#line 648
        goto case_6___2;
      }
#line 648
      if (tmp___10 == 7) {
#line 648
        goto case_7___2;
      }
#line 649
      if (tmp___10 == 10) {
#line 649
        goto case_10___3;
      }
#line 649
      if (tmp___10 == 9) {
#line 649
        goto case_10___3;
      }
#line 649
      if (tmp___10 == 21) {
#line 649
        goto case_10___3;
      }
#line 651
      if (tmp___10 == 11) {
#line 651
        goto gt;
      }
#line 655
      if (tmp___10 == 17) {
#line 655
        goto sol;
      }
#line 666
      goto switch_default___4;
      case_29___1: /* CIL Label */ 
#line 648
      if (! (namingBitmap[((int const   )nmstrtPages[(unsigned char )*(ptr + 1)] << 3) + (int const   )((int )((unsigned char )*(ptr + 0)) >> 5)] & (unsigned int const   )(1 << ((int )((unsigned char )*(ptr + 0)) & 31)))) {
#line 648
        *nextTokPtr = ptr;
#line 648
        return (0);
      }
      case_24___1: /* CIL Label */ 
      case_22___1: /* CIL Label */ 
#line 648
      ptr += 2;
#line 648
      goto switch_break___5;
      case_5___2: /* CIL Label */ 
#line 648
      if (end - ptr < 2L) {
#line 648
        return (-2);
      }
#line 648
      *nextTokPtr = ptr;
#line 648
      return (0);
#line 648
      ptr += 2;
#line 648
      goto switch_break___5;
      case_6___2: /* CIL Label */ 
#line 648
      if (end - ptr < 3L) {
#line 648
        return (-2);
      }
#line 648
      *nextTokPtr = ptr;
#line 648
      return (0);
#line 648
      ptr += 3;
#line 648
      goto switch_break___5;
      case_7___2: /* CIL Label */ 
#line 648
      if (end - ptr < 4L) {
#line 648
        return (-2);
      }
#line 648
      *nextTokPtr = ptr;
#line 648
      return (0);
#line 648
      ptr += 4;
#line 648
      goto switch_break___5;
      case_10___3: /* CIL Label */ 
      case_9___3: /* CIL Label */ 
      case_21___3: /* CIL Label */ 
#line 650
      goto __Cont;
      gt: 
      case_11___0: /* CIL Label */ 
#line 653
      *nextTokPtr = ptr + 2;
#line 654
      return (1);
      sol: 
      case_17___0: /* CIL Label */ 
#line 657
      ptr += 2;
#line 658
      if ((unsigned long )ptr == (unsigned long )end) {
#line 659
        return (-1);
      }
#line 660
      if ((int const   )*(ptr + 1) == 0) {
#line 660
        if (! ((int const   )*(ptr + 0) == 62)) {
#line 661
          *nextTokPtr = ptr;
#line 662
          return (0);
        }
      } else {
#line 661
        *nextTokPtr = ptr;
#line 662
        return (0);
      }
#line 664
      *nextTokPtr = ptr + 2;
#line 665
      return (3);
      switch_default___4: /* CIL Label */ 
#line 667
      *nextTokPtr = ptr;
#line 668
      return (0);
      switch_break___5: /* CIL Label */ ;
      }
#line 670
      goto while_break___3;
      __Cont: /* CIL Label */ ;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 672
    goto switch_break;
    switch_default___5: /* CIL Label */ 
#line 675
    *nextTokPtr = ptr;
#line 676
    return (0);
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 679
  return (-1);
}
}
#line 684 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmltok_impl.c"
static int little2_scanLt(ENCODING const   *enc , char const   *ptr , char const   *end ,
                          char const   **nextTokPtr ) 
{ 
  int hadColon ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;

  {
#line 691
  if ((unsigned long )ptr == (unsigned long )end) {
#line 692
    return (-1);
  }
#line 693
  if ((int const   )*(ptr + 1) == 0) {
#line 693
    tmp___0 = (int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr];
  } else {
    {
#line 693
    tmp = unicode_byte_type((char )*(ptr + 1), (char )*(ptr + 0));
#line 693
    tmp___0 = tmp;
    }
  }
  {
#line 694
  if (tmp___0 == 29) {
#line 694
    goto case_29;
  }
#line 694
  if (tmp___0 == 24) {
#line 694
    goto case_24;
  }
#line 694
  if (tmp___0 == 22) {
#line 694
    goto case_24;
  }
#line 694
  if (tmp___0 == 5) {
#line 694
    goto case_5;
  }
#line 694
  if (tmp___0 == 6) {
#line 694
    goto case_6;
  }
#line 694
  if (tmp___0 == 7) {
#line 694
    goto case_7;
  }
#line 695
  if (tmp___0 == 16) {
#line 695
    goto case_16;
  }
#line 707
  if (tmp___0 == 15) {
#line 707
    goto case_15;
  }
#line 709
  if (tmp___0 == 17) {
#line 709
    goto case_17;
  }
#line 711
  goto switch_default;
  case_29: /* CIL Label */ 
#line 694
  if (! (namingBitmap[((int const   )nmstrtPages[(unsigned char )*(ptr + 1)] << 3) + (int const   )((int )((unsigned char )*(ptr + 0)) >> 5)] & (unsigned int const   )(1 << ((int )((unsigned char )*(ptr + 0)) & 31)))) {
#line 694
    *nextTokPtr = ptr;
#line 694
    return (0);
  }
  case_24: /* CIL Label */ 
  case_22: /* CIL Label */ 
#line 694
  ptr += 2;
#line 694
  goto switch_break;
  case_5: /* CIL Label */ 
#line 694
  if (end - ptr < 2L) {
#line 694
    return (-2);
  }
#line 694
  *nextTokPtr = ptr;
#line 694
  return (0);
#line 694
  ptr += 2;
#line 694
  goto switch_break;
  case_6: /* CIL Label */ 
#line 694
  if (end - ptr < 3L) {
#line 694
    return (-2);
  }
#line 694
  *nextTokPtr = ptr;
#line 694
  return (0);
#line 694
  ptr += 3;
#line 694
  goto switch_break;
  case_7: /* CIL Label */ 
#line 694
  if (end - ptr < 4L) {
#line 694
    return (-2);
  }
#line 694
  *nextTokPtr = ptr;
#line 694
  return (0);
#line 694
  ptr += 4;
#line 694
  goto switch_break;
  case_16: /* CIL Label */ 
#line 696
  ptr += 2;
#line 696
  if ((unsigned long )ptr == (unsigned long )end) {
#line 697
    return (-1);
  }
#line 698
  if ((int const   )*(ptr + 1) == 0) {
#line 698
    tmp___2 = (int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr];
  } else {
    {
#line 698
    tmp___1 = unicode_byte_type((char )*(ptr + 1), (char )*(ptr + 0));
#line 698
    tmp___2 = tmp___1;
    }
  }
  {
#line 699
  if (tmp___2 == 27) {
#line 699
    goto case_27;
  }
#line 701
  if (tmp___2 == 20) {
#line 701
    goto case_20;
  }
#line 698
  goto switch_break___0;
  case_27: /* CIL Label */ 
  {
#line 700
  tmp___3 = little2_scanComment(enc, ptr + 2, end, nextTokPtr);
  }
#line 700
  return (tmp___3);
  case_20: /* CIL Label */ 
  {
#line 702
  tmp___4 = little2_scanCdataSection(enc, ptr + 2, end, nextTokPtr);
  }
#line 702
  return (tmp___4);
  switch_break___0: /* CIL Label */ ;
  }
#line 705
  *nextTokPtr = ptr;
#line 706
  return (0);
  case_15: /* CIL Label */ 
  {
#line 708
  tmp___5 = little2_scanPi(enc, ptr + 2, end, nextTokPtr);
  }
#line 708
  return (tmp___5);
  case_17: /* CIL Label */ 
  {
#line 710
  tmp___6 = little2_scanEndTag(enc, ptr + 2, end, nextTokPtr);
  }
#line 710
  return (tmp___6);
  switch_default: /* CIL Label */ 
#line 712
  *nextTokPtr = ptr;
#line 713
  return (0);
  switch_break: /* CIL Label */ ;
  }
#line 716
  hadColon = 0;
  {
#line 719
  while (1) {
    while_continue: /* CIL Label */ ;
#line 719
    if (! ((unsigned long )ptr != (unsigned long )end)) {
#line 719
      goto while_break;
    }
#line 720
    if ((int const   )*(ptr + 1) == 0) {
#line 720
      tmp___8 = (int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr];
    } else {
      {
#line 720
      tmp___7 = unicode_byte_type((char )*(ptr + 1), (char )*(ptr + 0));
#line 720
      tmp___8 = tmp___7;
      }
    }
    {
#line 721
    if (tmp___8 == 29) {
#line 721
      goto case_29___0;
    }
#line 721
    if (tmp___8 == 27) {
#line 721
      goto case_27___0;
    }
#line 721
    if (tmp___8 == 26) {
#line 721
      goto case_27___0;
    }
#line 721
    if (tmp___8 == 25) {
#line 721
      goto case_27___0;
    }
#line 721
    if (tmp___8 == 24) {
#line 721
      goto case_27___0;
    }
#line 721
    if (tmp___8 == 22) {
#line 721
      goto case_27___0;
    }
#line 721
    if (tmp___8 == 5) {
#line 721
      goto case_5___0;
    }
#line 721
    if (tmp___8 == 6) {
#line 721
      goto case_6___0;
    }
#line 721
    if (tmp___8 == 7) {
#line 721
      goto case_7___0;
    }
#line 723
    if (tmp___8 == 23) {
#line 723
      goto case_23;
    }
#line 740
    if (tmp___8 == 10) {
#line 740
      goto case_10;
    }
#line 740
    if (tmp___8 == 9) {
#line 740
      goto case_10;
    }
#line 740
    if (tmp___8 == 21) {
#line 740
      goto case_10;
    }
#line 761
    if (tmp___8 == 11) {
#line 761
      goto gt;
    }
#line 765
    if (tmp___8 == 17) {
#line 765
      goto sol;
    }
#line 776
    goto switch_default___2;
    case_29___0: /* CIL Label */ 
#line 721
    if (! (namingBitmap[((int const   )namePages[(unsigned char )*(ptr + 1)] << 3) + (int const   )((int )((unsigned char )*(ptr + 0)) >> 5)] & (unsigned int const   )(1 << ((int )((unsigned char )*(ptr + 0)) & 31)))) {
#line 721
      *nextTokPtr = ptr;
#line 721
      return (0);
    }
    case_27___0: /* CIL Label */ 
    case_26: /* CIL Label */ 
    case_25: /* CIL Label */ 
    case_24___0: /* CIL Label */ 
    case_22___0: /* CIL Label */ 
#line 721
    ptr += 2;
#line 721
    goto switch_break___1;
    case_5___0: /* CIL Label */ 
#line 721
    if (end - ptr < 2L) {
#line 721
      return (-2);
    }
#line 721
    *nextTokPtr = ptr;
#line 721
    return (0);
#line 721
    ptr += 2;
#line 721
    goto switch_break___1;
    case_6___0: /* CIL Label */ 
#line 721
    if (end - ptr < 3L) {
#line 721
      return (-2);
    }
#line 721
    *nextTokPtr = ptr;
#line 721
    return (0);
#line 721
    ptr += 3;
#line 721
    goto switch_break___1;
    case_7___0: /* CIL Label */ 
#line 721
    if (end - ptr < 4L) {
#line 721
      return (-2);
    }
#line 721
    *nextTokPtr = ptr;
#line 721
    return (0);
#line 721
    ptr += 4;
#line 721
    goto switch_break___1;
    case_23: /* CIL Label */ 
#line 724
    if (hadColon) {
#line 725
      *nextTokPtr = ptr;
#line 726
      return (0);
    }
#line 728
    hadColon = 1;
#line 729
    ptr += 2;
#line 730
    if ((unsigned long )ptr == (unsigned long )end) {
#line 731
      return (-1);
    }
#line 732
    if ((int const   )*(ptr + 1) == 0) {
#line 732
      tmp___10 = (int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr];
    } else {
      {
#line 732
      tmp___9 = unicode_byte_type((char )*(ptr + 1), (char )*(ptr + 0));
#line 732
      tmp___10 = tmp___9;
      }
    }
    {
#line 733
    if (tmp___10 == 29) {
#line 733
      goto case_29___1;
    }
#line 733
    if (tmp___10 == 24) {
#line 733
      goto case_24___1;
    }
#line 733
    if (tmp___10 == 22) {
#line 733
      goto case_24___1;
    }
#line 733
    if (tmp___10 == 5) {
#line 733
      goto case_5___1;
    }
#line 733
    if (tmp___10 == 6) {
#line 733
      goto case_6___1;
    }
#line 733
    if (tmp___10 == 7) {
#line 733
      goto case_7___1;
    }
#line 734
    goto switch_default___0;
    case_29___1: /* CIL Label */ 
#line 733
    if (! (namingBitmap[((int const   )nmstrtPages[(unsigned char )*(ptr + 1)] << 3) + (int const   )((int )((unsigned char )*(ptr + 0)) >> 5)] & (unsigned int const   )(1 << ((int )((unsigned char )*(ptr + 0)) & 31)))) {
#line 733
      *nextTokPtr = ptr;
#line 733
      return (0);
    }
    case_24___1: /* CIL Label */ 
    case_22___1: /* CIL Label */ 
#line 733
    ptr += 2;
#line 733
    goto switch_break___2;
    case_5___1: /* CIL Label */ 
#line 733
    if (end - ptr < 2L) {
#line 733
      return (-2);
    }
#line 733
    *nextTokPtr = ptr;
#line 733
    return (0);
#line 733
    ptr += 2;
#line 733
    goto switch_break___2;
    case_6___1: /* CIL Label */ 
#line 733
    if (end - ptr < 3L) {
#line 733
      return (-2);
    }
#line 733
    *nextTokPtr = ptr;
#line 733
    return (0);
#line 733
    ptr += 3;
#line 733
    goto switch_break___2;
    case_7___1: /* CIL Label */ 
#line 733
    if (end - ptr < 4L) {
#line 733
      return (-2);
    }
#line 733
    *nextTokPtr = ptr;
#line 733
    return (0);
#line 733
    ptr += 4;
#line 733
    goto switch_break___2;
    switch_default___0: /* CIL Label */ 
#line 735
    *nextTokPtr = ptr;
#line 736
    return (0);
    switch_break___2: /* CIL Label */ ;
    }
#line 738
    goto switch_break___1;
    case_10: /* CIL Label */ 
    case_9: /* CIL Label */ 
    case_21: /* CIL Label */ 
#line 742
    ptr += 2;
    {
#line 743
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 743
      if (! ((unsigned long )ptr != (unsigned long )end)) {
#line 743
        goto while_break___0;
      }
#line 744
      if ((int const   )*(ptr + 1) == 0) {
#line 744
        tmp___12 = (int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr];
      } else {
        {
#line 744
        tmp___11 = unicode_byte_type((char )*(ptr + 1), (char )*(ptr + 0));
#line 744
        tmp___12 = tmp___11;
        }
      }
      {
#line 745
      if (tmp___12 == 29) {
#line 745
        goto case_29___2;
      }
#line 745
      if (tmp___12 == 24) {
#line 745
        goto case_24___2;
      }
#line 745
      if (tmp___12 == 22) {
#line 745
        goto case_24___2;
      }
#line 745
      if (tmp___12 == 5) {
#line 745
        goto case_5___2;
      }
#line 745
      if (tmp___12 == 6) {
#line 745
        goto case_6___2;
      }
#line 745
      if (tmp___12 == 7) {
#line 745
        goto case_7___2;
      }
#line 746
      if (tmp___12 == 11) {
#line 746
        goto case_11;
      }
#line 748
      if (tmp___12 == 17) {
#line 748
        goto case_17___0;
      }
#line 750
      if (tmp___12 == 10) {
#line 750
        goto case_10___0;
      }
#line 750
      if (tmp___12 == 9) {
#line 750
        goto case_10___0;
      }
#line 750
      if (tmp___12 == 21) {
#line 750
        goto case_10___0;
      }
#line 753
      goto switch_default___1;
      case_29___2: /* CIL Label */ 
#line 745
      if (! (namingBitmap[((int const   )nmstrtPages[(unsigned char )*(ptr + 1)] << 3) + (int const   )((int )((unsigned char )*(ptr + 0)) >> 5)] & (unsigned int const   )(1 << ((int )((unsigned char )*(ptr + 0)) & 31)))) {
#line 745
        *nextTokPtr = ptr;
#line 745
        return (0);
      }
      case_24___2: /* CIL Label */ 
      case_22___2: /* CIL Label */ 
#line 745
      ptr += 2;
#line 745
      goto switch_break___3;
      case_5___2: /* CIL Label */ 
#line 745
      if (end - ptr < 2L) {
#line 745
        return (-2);
      }
#line 745
      *nextTokPtr = ptr;
#line 745
      return (0);
#line 745
      ptr += 2;
#line 745
      goto switch_break___3;
      case_6___2: /* CIL Label */ 
#line 745
      if (end - ptr < 3L) {
#line 745
        return (-2);
      }
#line 745
      *nextTokPtr = ptr;
#line 745
      return (0);
#line 745
      ptr += 3;
#line 745
      goto switch_break___3;
      case_7___2: /* CIL Label */ 
#line 745
      if (end - ptr < 4L) {
#line 745
        return (-2);
      }
#line 745
      *nextTokPtr = ptr;
#line 745
      return (0);
#line 745
      ptr += 4;
#line 745
      goto switch_break___3;
      case_11: /* CIL Label */ 
#line 747
      goto gt;
      case_17___0: /* CIL Label */ 
#line 749
      goto sol;
      case_10___0: /* CIL Label */ 
      case_9___0: /* CIL Label */ 
      case_21___0: /* CIL Label */ 
#line 751
      ptr += 2;
#line 752
      goto while_continue___0;
      switch_default___1: /* CIL Label */ 
#line 754
      *nextTokPtr = ptr;
#line 755
      return (0);
      switch_break___3: /* CIL Label */ ;
      }
      {
#line 757
      tmp___13 = little2_scanAtts(enc, ptr, end, nextTokPtr);
      }
#line 757
      return (tmp___13);
    }
    while_break___0: /* CIL Label */ ;
    }
#line 759
    return (-1);
    gt: 
    case_11___0: /* CIL Label */ 
#line 763
    *nextTokPtr = ptr + 2;
#line 764
    return (2);
    sol: 
    case_17___1: /* CIL Label */ 
#line 767
    ptr += 2;
#line 768
    if ((unsigned long )ptr == (unsigned long )end) {
#line 769
      return (-1);
    }
#line 770
    if ((int const   )*(ptr + 1) == 0) {
#line 770
      if (! ((int const   )*(ptr + 0) == 62)) {
#line 771
        *nextTokPtr = ptr;
#line 772
        return (0);
      }
    } else {
#line 771
      *nextTokPtr = ptr;
#line 772
      return (0);
    }
#line 774
    *nextTokPtr = ptr + 2;
#line 775
    return (4);
    switch_default___2: /* CIL Label */ 
#line 777
    *nextTokPtr = ptr;
#line 778
    return (0);
    switch_break___1: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 781
  return (-1);
}
}
#line 784 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmltok_impl.c"
static int little2_contentTok(ENCODING const   *enc , char const   *ptr , char const   *end ,
                              char const   **nextTokPtr ) 
{ 
  size_t n ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
#line 788
  if ((unsigned long )ptr == (unsigned long )end) {
#line 789
    return (-4);
  }
#line 791
  n = (size_t )(end - ptr);
#line 792
  if (n & 1UL) {
#line 793
    n &= 0xfffffffffffffffeUL;
#line 794
    if (n == 0UL) {
#line 795
      return (-1);
    }
#line 796
    end = ptr + n;
  }
#line 799
  if ((int const   )*(ptr + 1) == 0) {
#line 799
    tmp___0 = (int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr];
  } else {
    {
#line 799
    tmp = unicode_byte_type((char )*(ptr + 1), (char )*(ptr + 0));
#line 799
    tmp___0 = tmp;
    }
  }
  {
#line 800
  if (tmp___0 == 2) {
#line 800
    goto case_2;
  }
#line 802
  if (tmp___0 == 3) {
#line 802
    goto case_3;
  }
#line 804
  if (tmp___0 == 9) {
#line 804
    goto case_9;
  }
#line 812
  if (tmp___0 == 10) {
#line 812
    goto case_10;
  }
#line 815
  if (tmp___0 == 4) {
#line 815
    goto case_4;
  }
#line 830
  if (tmp___0 == 5) {
#line 830
    goto case_5;
  }
#line 830
  if (tmp___0 == 6) {
#line 830
    goto case_6;
  }
#line 830
  if (tmp___0 == 7) {
#line 830
    goto case_7;
  }
#line 830
  if (tmp___0 == 8) {
#line 830
    goto case_8;
  }
#line 830
  if (tmp___0 == 1) {
#line 830
    goto case_8;
  }
#line 830
  if (tmp___0 == 0) {
#line 830
    goto case_8;
  }
#line 831
  goto switch_default;
  case_2: /* CIL Label */ 
  {
#line 801
  tmp___1 = little2_scanLt(enc, ptr + 2, end, nextTokPtr);
  }
#line 801
  return (tmp___1);
  case_3: /* CIL Label */ 
  {
#line 803
  tmp___2 = little2_scanRef(enc, ptr + 2, end, nextTokPtr);
  }
#line 803
  return (tmp___2);
  case_9: /* CIL Label */ 
#line 805
  ptr += 2;
#line 806
  if ((unsigned long )ptr == (unsigned long )end) {
#line 807
    return (-3);
  }
#line 808
  if ((int const   )*(ptr + 1) == 0) {
#line 808
    tmp___4 = (int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr];
  } else {
    {
#line 808
    tmp___3 = unicode_byte_type((char )*(ptr + 1), (char )*(ptr + 0));
#line 808
    tmp___4 = tmp___3;
    }
  }
#line 808
  if (tmp___4 == 10) {
#line 809
    ptr += 2;
  }
#line 810
  *nextTokPtr = ptr;
#line 811
  return (7);
  case_10: /* CIL Label */ 
#line 813
  *nextTokPtr = ptr + 2;
#line 814
  return (7);
  case_4: /* CIL Label */ 
#line 816
  ptr += 2;
#line 817
  if ((unsigned long )ptr == (unsigned long )end) {
#line 818
    return (-5);
  }
#line 819
  if ((int const   )*(ptr + 1) == 0) {
#line 819
    if (! ((int const   )*(ptr + 0) == 93)) {
#line 820
      goto switch_break;
    }
  } else {
#line 820
    goto switch_break;
  }
#line 821
  ptr += 2;
#line 822
  if ((unsigned long )ptr == (unsigned long )end) {
#line 823
    return (-5);
  }
#line 824
  if ((int const   )*(ptr + 1) == 0) {
#line 824
    if (! ((int const   )*(ptr + 0) == 62)) {
#line 825
      ptr -= 2;
#line 826
      goto switch_break;
    }
  } else {
#line 825
    ptr -= 2;
#line 826
    goto switch_break;
  }
#line 828
  *nextTokPtr = ptr;
#line 829
  return (0);
  case_5: /* CIL Label */ 
#line 830
  if (end - ptr < 2L) {
#line 830
    return (-2);
  }
#line 830
  ptr += 2;
#line 830
  goto switch_break;
  case_6: /* CIL Label */ 
#line 830
  if (end - ptr < 3L) {
#line 830
    return (-2);
  }
#line 830
  ptr += 3;
#line 830
  goto switch_break;
  case_7: /* CIL Label */ 
#line 830
  if (end - ptr < 4L) {
#line 830
    return (-2);
  }
#line 830
  ptr += 4;
#line 830
  goto switch_break;
  case_8: /* CIL Label */ 
  case_1: /* CIL Label */ 
  case_0: /* CIL Label */ 
#line 830
  *nextTokPtr = ptr;
#line 830
  return (0);
  switch_default: /* CIL Label */ 
#line 832
  ptr += 2;
#line 833
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 835
  while (1) {
    while_continue: /* CIL Label */ ;
#line 835
    if (! ((unsigned long )ptr != (unsigned long )end)) {
#line 835
      goto while_break;
    }
#line 836
    if ((int const   )*(ptr + 1) == 0) {
#line 836
      tmp___6 = (int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr];
    } else {
      {
#line 836
      tmp___5 = unicode_byte_type((char )*(ptr + 1), (char )*(ptr + 0));
#line 836
      tmp___6 = tmp___5;
      }
    }
    {
#line 845
    if (tmp___6 == 5) {
#line 845
      goto case_5___0;
    }
#line 845
    if (tmp___6 == 6) {
#line 845
      goto case_6___0;
    }
#line 845
    if (tmp___6 == 7) {
#line 845
      goto case_7___0;
    }
#line 847
    if (tmp___6 == 4) {
#line 847
      goto case_4___0;
    }
#line 869
    if (tmp___6 == 10) {
#line 869
      goto case_10___0;
    }
#line 869
    if (tmp___6 == 9) {
#line 869
      goto case_10___0;
    }
#line 869
    if (tmp___6 == 8) {
#line 869
      goto case_10___0;
    }
#line 869
    if (tmp___6 == 1) {
#line 869
      goto case_10___0;
    }
#line 869
    if (tmp___6 == 0) {
#line 869
      goto case_10___0;
    }
#line 869
    if (tmp___6 == 2) {
#line 869
      goto case_10___0;
    }
#line 869
    if (tmp___6 == 3) {
#line 869
      goto case_10___0;
    }
#line 872
    goto switch_default___0;
    case_5___0: /* CIL Label */ 
#line 845
    if (end - ptr < 2L) {
#line 845
      *nextTokPtr = ptr;
#line 845
      return (6);
    }
#line 845
    ptr += 2;
#line 845
    goto switch_break___0;
    case_6___0: /* CIL Label */ 
#line 845
    if (end - ptr < 3L) {
#line 845
      *nextTokPtr = ptr;
#line 845
      return (6);
    }
#line 845
    ptr += 3;
#line 845
    goto switch_break___0;
    case_7___0: /* CIL Label */ 
#line 845
    if (end - ptr < 4L) {
#line 845
      *nextTokPtr = ptr;
#line 845
      return (6);
    }
#line 845
    ptr += 4;
#line 845
    goto switch_break___0;
    case_4___0: /* CIL Label */ 
#line 848
    if ((unsigned long )(ptr + 2) != (unsigned long )end) {
#line 849
      if ((int const   )*((ptr + 2) + 1) == 0) {
#line 849
        if (! ((int const   )*((ptr + 2) + 0) == 93)) {
#line 850
          ptr += 2;
#line 851
          goto switch_break___0;
        }
      } else {
#line 850
        ptr += 2;
#line 851
        goto switch_break___0;
      }
#line 853
      if ((unsigned long )(ptr + 4) != (unsigned long )end) {
#line 854
        if ((int const   )*((ptr + 4) + 1) == 0) {
#line 854
          if (! ((int const   )*((ptr + 4) + 0) == 62)) {
#line 855
            ptr += 2;
#line 856
            goto switch_break___0;
          }
        } else {
#line 855
          ptr += 2;
#line 856
          goto switch_break___0;
        }
#line 858
        *nextTokPtr = ptr + 4;
#line 859
        return (0);
      }
    }
    case_10___0: /* CIL Label */ 
    case_9___0: /* CIL Label */ 
    case_8___0: /* CIL Label */ 
    case_1___0: /* CIL Label */ 
    case_0___0: /* CIL Label */ 
    case_2___0: /* CIL Label */ 
    case_3___0: /* CIL Label */ 
#line 870
    *nextTokPtr = ptr;
#line 871
    return (6);
    switch_default___0: /* CIL Label */ 
#line 873
    ptr += 2;
#line 874
    goto switch_break___0;
    switch_break___0: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 877
  *nextTokPtr = ptr;
#line 878
  return (6);
}
}
#line 883 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmltok_impl.c"
static int little2_scanPercent(ENCODING const   *enc , char const   *ptr , char const   *end ,
                               char const   **nextTokPtr ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 887
  if ((unsigned long )ptr == (unsigned long )end) {
#line 888
    return (-1);
  }
#line 889
  if ((int const   )*(ptr + 1) == 0) {
#line 889
    tmp___0 = (int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr];
  } else {
    {
#line 889
    tmp = unicode_byte_type((char )*(ptr + 1), (char )*(ptr + 0));
#line 889
    tmp___0 = tmp;
    }
  }
  {
#line 890
  if (tmp___0 == 29) {
#line 890
    goto case_29;
  }
#line 890
  if (tmp___0 == 24) {
#line 890
    goto case_24;
  }
#line 890
  if (tmp___0 == 22) {
#line 890
    goto case_24;
  }
#line 890
  if (tmp___0 == 5) {
#line 890
    goto case_5;
  }
#line 890
  if (tmp___0 == 6) {
#line 890
    goto case_6;
  }
#line 890
  if (tmp___0 == 7) {
#line 890
    goto case_7;
  }
#line 891
  if (tmp___0 == 30) {
#line 891
    goto case_30;
  }
#line 891
  if (tmp___0 == 9) {
#line 891
    goto case_30;
  }
#line 891
  if (tmp___0 == 10) {
#line 891
    goto case_30;
  }
#line 891
  if (tmp___0 == 21) {
#line 891
    goto case_30;
  }
#line 894
  goto switch_default;
  case_29: /* CIL Label */ 
#line 890
  if (! (namingBitmap[((int const   )nmstrtPages[(unsigned char )*(ptr + 1)] << 3) + (int const   )((int )((unsigned char )*(ptr + 0)) >> 5)] & (unsigned int const   )(1 << ((int )((unsigned char )*(ptr + 0)) & 31)))) {
#line 890
    *nextTokPtr = ptr;
#line 890
    return (0);
  }
  case_24: /* CIL Label */ 
  case_22: /* CIL Label */ 
#line 890
  ptr += 2;
#line 890
  goto switch_break;
  case_5: /* CIL Label */ 
#line 890
  if (end - ptr < 2L) {
#line 890
    return (-2);
  }
#line 890
  *nextTokPtr = ptr;
#line 890
  return (0);
#line 890
  ptr += 2;
#line 890
  goto switch_break;
  case_6: /* CIL Label */ 
#line 890
  if (end - ptr < 3L) {
#line 890
    return (-2);
  }
#line 890
  *nextTokPtr = ptr;
#line 890
  return (0);
#line 890
  ptr += 3;
#line 890
  goto switch_break;
  case_7: /* CIL Label */ 
#line 890
  if (end - ptr < 4L) {
#line 890
    return (-2);
  }
#line 890
  *nextTokPtr = ptr;
#line 890
  return (0);
#line 890
  ptr += 4;
#line 890
  goto switch_break;
  case_30: /* CIL Label */ 
  case_9: /* CIL Label */ 
  case_10: /* CIL Label */ 
  case_21: /* CIL Label */ 
#line 892
  *nextTokPtr = ptr;
#line 893
  return (22);
  switch_default: /* CIL Label */ 
#line 895
  *nextTokPtr = ptr;
#line 896
  return (0);
  switch_break: /* CIL Label */ ;
  }
  {
#line 898
  while (1) {
    while_continue: /* CIL Label */ ;
#line 898
    if (! ((unsigned long )ptr != (unsigned long )end)) {
#line 898
      goto while_break;
    }
#line 899
    if ((int const   )*(ptr + 1) == 0) {
#line 899
      tmp___2 = (int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr];
    } else {
      {
#line 899
      tmp___1 = unicode_byte_type((char )*(ptr + 1), (char )*(ptr + 0));
#line 899
      tmp___2 = tmp___1;
      }
    }
    {
#line 900
    if (tmp___2 == 29) {
#line 900
      goto case_29___0;
    }
#line 900
    if (tmp___2 == 27) {
#line 900
      goto case_27;
    }
#line 900
    if (tmp___2 == 26) {
#line 900
      goto case_27;
    }
#line 900
    if (tmp___2 == 25) {
#line 900
      goto case_27;
    }
#line 900
    if (tmp___2 == 24) {
#line 900
      goto case_27;
    }
#line 900
    if (tmp___2 == 22) {
#line 900
      goto case_27;
    }
#line 900
    if (tmp___2 == 5) {
#line 900
      goto case_5___0;
    }
#line 900
    if (tmp___2 == 6) {
#line 900
      goto case_6___0;
    }
#line 900
    if (tmp___2 == 7) {
#line 900
      goto case_7___0;
    }
#line 901
    if (tmp___2 == 18) {
#line 901
      goto case_18;
    }
#line 904
    goto switch_default___0;
    case_29___0: /* CIL Label */ 
#line 900
    if (! (namingBitmap[((int const   )namePages[(unsigned char )*(ptr + 1)] << 3) + (int const   )((int )((unsigned char )*(ptr + 0)) >> 5)] & (unsigned int const   )(1 << ((int )((unsigned char )*(ptr + 0)) & 31)))) {
#line 900
      *nextTokPtr = ptr;
#line 900
      return (0);
    }
    case_27: /* CIL Label */ 
    case_26: /* CIL Label */ 
    case_25: /* CIL Label */ 
    case_24___0: /* CIL Label */ 
    case_22___0: /* CIL Label */ 
#line 900
    ptr += 2;
#line 900
    goto switch_break___0;
    case_5___0: /* CIL Label */ 
#line 900
    if (end - ptr < 2L) {
#line 900
      return (-2);
    }
#line 900
    *nextTokPtr = ptr;
#line 900
    return (0);
#line 900
    ptr += 2;
#line 900
    goto switch_break___0;
    case_6___0: /* CIL Label */ 
#line 900
    if (end - ptr < 3L) {
#line 900
      return (-2);
    }
#line 900
    *nextTokPtr = ptr;
#line 900
    return (0);
#line 900
    ptr += 3;
#line 900
    goto switch_break___0;
    case_7___0: /* CIL Label */ 
#line 900
    if (end - ptr < 4L) {
#line 900
      return (-2);
    }
#line 900
    *nextTokPtr = ptr;
#line 900
    return (0);
#line 900
    ptr += 4;
#line 900
    goto switch_break___0;
    case_18: /* CIL Label */ 
#line 902
    *nextTokPtr = ptr + 2;
#line 903
    return (28);
    switch_default___0: /* CIL Label */ 
#line 905
    *nextTokPtr = ptr;
#line 906
    return (0);
    switch_break___0: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 909
  return (-1);
}
}
#line 912 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmltok_impl.c"
static int little2_scanPoundName(ENCODING const   *enc , char const   *ptr , char const   *end ,
                                 char const   **nextTokPtr ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 916
  if ((unsigned long )ptr == (unsigned long )end) {
#line 917
    return (-1);
  }
#line 918
  if ((int const   )*(ptr + 1) == 0) {
#line 918
    tmp___0 = (int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr];
  } else {
    {
#line 918
    tmp = unicode_byte_type((char )*(ptr + 1), (char )*(ptr + 0));
#line 918
    tmp___0 = tmp;
    }
  }
  {
#line 919
  if (tmp___0 == 29) {
#line 919
    goto case_29;
  }
#line 919
  if (tmp___0 == 24) {
#line 919
    goto case_24;
  }
#line 919
  if (tmp___0 == 22) {
#line 919
    goto case_24;
  }
#line 919
  if (tmp___0 == 5) {
#line 919
    goto case_5;
  }
#line 919
  if (tmp___0 == 6) {
#line 919
    goto case_6;
  }
#line 919
  if (tmp___0 == 7) {
#line 919
    goto case_7;
  }
#line 920
  goto switch_default;
  case_29: /* CIL Label */ 
#line 919
  if (! (namingBitmap[((int const   )nmstrtPages[(unsigned char )*(ptr + 1)] << 3) + (int const   )((int )((unsigned char )*(ptr + 0)) >> 5)] & (unsigned int const   )(1 << ((int )((unsigned char )*(ptr + 0)) & 31)))) {
#line 919
    *nextTokPtr = ptr;
#line 919
    return (0);
  }
  case_24: /* CIL Label */ 
  case_22: /* CIL Label */ 
#line 919
  ptr += 2;
#line 919
  goto switch_break;
  case_5: /* CIL Label */ 
#line 919
  if (end - ptr < 2L) {
#line 919
    return (-2);
  }
#line 919
  *nextTokPtr = ptr;
#line 919
  return (0);
#line 919
  ptr += 2;
#line 919
  goto switch_break;
  case_6: /* CIL Label */ 
#line 919
  if (end - ptr < 3L) {
#line 919
    return (-2);
  }
#line 919
  *nextTokPtr = ptr;
#line 919
  return (0);
#line 919
  ptr += 3;
#line 919
  goto switch_break;
  case_7: /* CIL Label */ 
#line 919
  if (end - ptr < 4L) {
#line 919
    return (-2);
  }
#line 919
  *nextTokPtr = ptr;
#line 919
  return (0);
#line 919
  ptr += 4;
#line 919
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 921
  *nextTokPtr = ptr;
#line 922
  return (0);
  switch_break: /* CIL Label */ ;
  }
  {
#line 924
  while (1) {
    while_continue: /* CIL Label */ ;
#line 924
    if (! ((unsigned long )ptr != (unsigned long )end)) {
#line 924
      goto while_break;
    }
#line 925
    if ((int const   )*(ptr + 1) == 0) {
#line 925
      tmp___2 = (int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr];
    } else {
      {
#line 925
      tmp___1 = unicode_byte_type((char )*(ptr + 1), (char )*(ptr + 0));
#line 925
      tmp___2 = tmp___1;
      }
    }
    {
#line 926
    if (tmp___2 == 29) {
#line 926
      goto case_29___0;
    }
#line 926
    if (tmp___2 == 27) {
#line 926
      goto case_27;
    }
#line 926
    if (tmp___2 == 26) {
#line 926
      goto case_27;
    }
#line 926
    if (tmp___2 == 25) {
#line 926
      goto case_27;
    }
#line 926
    if (tmp___2 == 24) {
#line 926
      goto case_27;
    }
#line 926
    if (tmp___2 == 22) {
#line 926
      goto case_27;
    }
#line 926
    if (tmp___2 == 5) {
#line 926
      goto case_5___0;
    }
#line 926
    if (tmp___2 == 6) {
#line 926
      goto case_6___0;
    }
#line 926
    if (tmp___2 == 7) {
#line 926
      goto case_7___0;
    }
#line 928
    if (tmp___2 == 36) {
#line 928
      goto case_36;
    }
#line 928
    if (tmp___2 == 30) {
#line 928
      goto case_36;
    }
#line 928
    if (tmp___2 == 11) {
#line 928
      goto case_36;
    }
#line 928
    if (tmp___2 == 32) {
#line 928
      goto case_36;
    }
#line 928
    if (tmp___2 == 21) {
#line 928
      goto case_36;
    }
#line 928
    if (tmp___2 == 10) {
#line 928
      goto case_36;
    }
#line 928
    if (tmp___2 == 9) {
#line 928
      goto case_36;
    }
#line 931
    goto switch_default___0;
    case_29___0: /* CIL Label */ 
#line 926
    if (! (namingBitmap[((int const   )namePages[(unsigned char )*(ptr + 1)] << 3) + (int const   )((int )((unsigned char )*(ptr + 0)) >> 5)] & (unsigned int const   )(1 << ((int )((unsigned char )*(ptr + 0)) & 31)))) {
#line 926
      *nextTokPtr = ptr;
#line 926
      return (0);
    }
    case_27: /* CIL Label */ 
    case_26: /* CIL Label */ 
    case_25: /* CIL Label */ 
    case_24___0: /* CIL Label */ 
    case_22___0: /* CIL Label */ 
#line 926
    ptr += 2;
#line 926
    goto switch_break___0;
    case_5___0: /* CIL Label */ 
#line 926
    if (end - ptr < 2L) {
#line 926
      return (-2);
    }
#line 926
    *nextTokPtr = ptr;
#line 926
    return (0);
#line 926
    ptr += 2;
#line 926
    goto switch_break___0;
    case_6___0: /* CIL Label */ 
#line 926
    if (end - ptr < 3L) {
#line 926
      return (-2);
    }
#line 926
    *nextTokPtr = ptr;
#line 926
    return (0);
#line 926
    ptr += 3;
#line 926
    goto switch_break___0;
    case_7___0: /* CIL Label */ 
#line 926
    if (end - ptr < 4L) {
#line 926
      return (-2);
    }
#line 926
    *nextTokPtr = ptr;
#line 926
    return (0);
#line 926
    ptr += 4;
#line 926
    goto switch_break___0;
    case_36: /* CIL Label */ 
    case_30: /* CIL Label */ 
    case_11: /* CIL Label */ 
    case_32: /* CIL Label */ 
    case_21: /* CIL Label */ 
    case_10: /* CIL Label */ 
    case_9: /* CIL Label */ 
#line 929
    *nextTokPtr = ptr;
#line 930
    return (20);
    switch_default___0: /* CIL Label */ 
#line 932
    *nextTokPtr = ptr;
#line 933
    return (0);
    switch_break___0: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 936
  return (-20);
}
}
#line 939 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmltok_impl.c"
static int little2_scanLit(int open___0 , ENCODING const   *enc , char const   *ptr ,
                           char const   *end , char const   **nextTokPtr ) 
{ 
  int t ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 944
  while (1) {
    while_continue: /* CIL Label */ ;
#line 944
    if (! ((unsigned long )ptr != (unsigned long )end)) {
#line 944
      goto while_break;
    }
#line 945
    if ((int const   )*(ptr + 1) == 0) {
#line 945
      tmp___0 = (int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr];
    } else {
      {
#line 945
      tmp = unicode_byte_type((char )*(ptr + 1), (char )*(ptr + 0));
#line 945
      tmp___0 = tmp;
      }
    }
#line 945
    t = tmp___0;
    {
#line 947
    if (t == 5) {
#line 947
      goto case_5;
    }
#line 947
    if (t == 6) {
#line 947
      goto case_6;
    }
#line 947
    if (t == 7) {
#line 947
      goto case_7;
    }
#line 947
    if (t == 8) {
#line 947
      goto case_8;
    }
#line 947
    if (t == 1) {
#line 947
      goto case_8;
    }
#line 947
    if (t == 0) {
#line 947
      goto case_8;
    }
#line 949
    if (t == 13) {
#line 949
      goto case_13;
    }
#line 949
    if (t == 12) {
#line 949
      goto case_13;
    }
#line 963
    goto switch_default___0;
    case_5: /* CIL Label */ 
#line 947
    if (end - ptr < 2L) {
#line 947
      return (-2);
    }
#line 947
    ptr += 2;
#line 947
    goto switch_break;
    case_6: /* CIL Label */ 
#line 947
    if (end - ptr < 3L) {
#line 947
      return (-2);
    }
#line 947
    ptr += 3;
#line 947
    goto switch_break;
    case_7: /* CIL Label */ 
#line 947
    if (end - ptr < 4L) {
#line 947
      return (-2);
    }
#line 947
    ptr += 4;
#line 947
    goto switch_break;
    case_8: /* CIL Label */ 
    case_1: /* CIL Label */ 
    case_0: /* CIL Label */ 
#line 947
    *nextTokPtr = ptr;
#line 947
    return (0);
    case_13: /* CIL Label */ 
    case_12: /* CIL Label */ 
#line 950
    ptr += 2;
#line 951
    if (t != open___0) {
#line 952
      goto switch_break;
    }
#line 953
    if ((unsigned long )ptr == (unsigned long )end) {
#line 954
      return (-27);
    }
#line 955
    *nextTokPtr = ptr;
#line 956
    if ((int const   )*(ptr + 1) == 0) {
#line 956
      tmp___2 = (int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr];
    } else {
      {
#line 956
      tmp___1 = unicode_byte_type((char )*(ptr + 1), (char )*(ptr + 0));
#line 956
      tmp___2 = tmp___1;
      }
    }
    {
#line 958
    if (tmp___2 == 20) {
#line 958
      goto case_20;
    }
#line 958
    if (tmp___2 == 30) {
#line 958
      goto case_20;
    }
#line 958
    if (tmp___2 == 11) {
#line 958
      goto case_20;
    }
#line 958
    if (tmp___2 == 10) {
#line 958
      goto case_20;
    }
#line 958
    if (tmp___2 == 9) {
#line 958
      goto case_20;
    }
#line 958
    if (tmp___2 == 21) {
#line 958
      goto case_20;
    }
#line 960
    goto switch_default;
    case_20: /* CIL Label */ 
    case_30: /* CIL Label */ 
    case_11: /* CIL Label */ 
    case_10: /* CIL Label */ 
    case_9: /* CIL Label */ 
    case_21: /* CIL Label */ 
#line 959
    return (27);
    switch_default: /* CIL Label */ 
#line 961
    return (0);
    switch_break___0: /* CIL Label */ ;
    }
    switch_default___0: /* CIL Label */ 
#line 964
    ptr += 2;
#line 965
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 968
  return (-1);
}
}
#line 971 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmltok_impl.c"
static int little2_prologTok(ENCODING const   *enc , char const   *ptr , char const   *end ,
                             char const   **nextTokPtr ) 
{ 
  int tok ;
  size_t n ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;

  {
#line 976
  if ((unsigned long )ptr == (unsigned long )end) {
#line 977
    return (-4);
  }
#line 979
  n = (size_t )(end - ptr);
#line 980
  if (n & 1UL) {
#line 981
    n &= 0xfffffffffffffffeUL;
#line 982
    if (n == 0UL) {
#line 983
      return (-1);
    }
#line 984
    end = ptr + n;
  }
#line 987
  if ((int const   )*(ptr + 1) == 0) {
#line 987
    tmp___0 = (int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr];
  } else {
    {
#line 987
    tmp = unicode_byte_type((char )*(ptr + 1), (char )*(ptr + 0));
#line 987
    tmp___0 = tmp;
    }
  }
  {
#line 988
  if (tmp___0 == 12) {
#line 988
    goto case_12;
  }
#line 990
  if (tmp___0 == 13) {
#line 990
    goto case_13;
  }
#line 992
  if (tmp___0 == 2) {
#line 992
    goto case_2;
  }
#line 1014
  if (tmp___0 == 9) {
#line 1014
    goto case_9;
  }
#line 1021
  if (tmp___0 == 10) {
#line 1021
    goto case_10;
  }
#line 1021
  if (tmp___0 == 21) {
#line 1021
    goto case_10;
  }
#line 1041
  if (tmp___0 == 30) {
#line 1041
    goto case_30;
  }
#line 1043
  if (tmp___0 == 35) {
#line 1043
    goto case_35;
  }
#line 1046
  if (tmp___0 == 20) {
#line 1046
    goto case_20;
  }
#line 1049
  if (tmp___0 == 4) {
#line 1049
    goto case_4;
  }
#line 1063
  if (tmp___0 == 31) {
#line 1063
    goto case_31;
  }
#line 1066
  if (tmp___0 == 32) {
#line 1066
    goto case_32;
  }
#line 1088
  if (tmp___0 == 36) {
#line 1088
    goto case_36___0;
  }
#line 1091
  if (tmp___0 == 11) {
#line 1091
    goto case_11___0;
  }
#line 1094
  if (tmp___0 == 19) {
#line 1094
    goto case_19;
  }
#line 1112
  if (tmp___0 == 5) {
#line 1112
    goto case_5___0;
  }
#line 1112
  if (tmp___0 == 6) {
#line 1112
    goto case_6___0;
  }
#line 1112
  if (tmp___0 == 7) {
#line 1112
    goto case_7___0;
  }
#line 1115
  if (tmp___0 == 24) {
#line 1115
    goto case_24___0;
  }
#line 1115
  if (tmp___0 == 22) {
#line 1115
    goto case_24___0;
  }
#line 1123
  if (tmp___0 == 23) {
#line 1123
    goto case_23;
  }
#line 1123
  if (tmp___0 == 27) {
#line 1123
    goto case_23;
  }
#line 1123
  if (tmp___0 == 26) {
#line 1123
    goto case_23;
  }
#line 1123
  if (tmp___0 == 25) {
#line 1123
    goto case_23;
  }
#line 1128
  if (tmp___0 == 29) {
#line 1128
    goto case_29___0;
  }
#line 1140
  goto switch_default___0;
  case_12: /* CIL Label */ 
  {
#line 989
  tmp___1 = little2_scanLit(12, enc, ptr + 2, end, nextTokPtr);
  }
#line 989
  return (tmp___1);
  case_13: /* CIL Label */ 
  {
#line 991
  tmp___2 = little2_scanLit(13, enc, ptr + 2, end, nextTokPtr);
  }
#line 991
  return (tmp___2);
  case_2: /* CIL Label */ 
#line 994
  ptr += 2;
#line 995
  if ((unsigned long )ptr == (unsigned long )end) {
#line 996
    return (-1);
  }
#line 997
  if ((int const   )*(ptr + 1) == 0) {
#line 997
    tmp___4 = (int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr];
  } else {
    {
#line 997
    tmp___3 = unicode_byte_type((char )*(ptr + 1), (char )*(ptr + 0));
#line 997
    tmp___4 = tmp___3;
    }
  }
  {
#line 998
  if (tmp___4 == 16) {
#line 998
    goto case_16;
  }
#line 1000
  if (tmp___4 == 15) {
#line 1000
    goto case_15;
  }
#line 1007
  if (tmp___4 == 7) {
#line 1007
    goto case_7;
  }
#line 1007
  if (tmp___4 == 6) {
#line 1007
    goto case_7;
  }
#line 1007
  if (tmp___4 == 5) {
#line 1007
    goto case_7;
  }
#line 1007
  if (tmp___4 == 29) {
#line 1007
    goto case_7;
  }
#line 1007
  if (tmp___4 == 24) {
#line 1007
    goto case_7;
  }
#line 1007
  if (tmp___4 == 22) {
#line 1007
    goto case_7;
  }
#line 997
  goto switch_break___0;
  case_16: /* CIL Label */ 
  {
#line 999
  tmp___5 = little2_scanDecl(enc, ptr + 2, end, nextTokPtr);
  }
#line 999
  return (tmp___5);
  case_15: /* CIL Label */ 
  {
#line 1001
  tmp___6 = little2_scanPi(enc, ptr + 2, end, nextTokPtr);
  }
#line 1001
  return (tmp___6);
  case_7: /* CIL Label */ 
  case_6: /* CIL Label */ 
  case_5: /* CIL Label */ 
  case_29: /* CIL Label */ 
  case_24: /* CIL Label */ 
  case_22: /* CIL Label */ 
#line 1008
  *nextTokPtr = ptr - 2;
#line 1009
  return (29);
  switch_break___0: /* CIL Label */ ;
  }
#line 1011
  *nextTokPtr = ptr;
#line 1012
  return (0);
  case_9: /* CIL Label */ 
#line 1015
  if ((unsigned long )(ptr + 2) == (unsigned long )end) {
#line 1016
    *nextTokPtr = end;
#line 1018
    return (-15);
  }
  case_10: /* CIL Label */ 
  case_21: /* CIL Label */ 
  {
#line 1022
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1023
    ptr += 2;
#line 1024
    if ((unsigned long )ptr == (unsigned long )end) {
#line 1025
      goto while_break;
    }
#line 1026
    if ((int const   )*(ptr + 1) == 0) {
#line 1026
      tmp___8 = (int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr];
    } else {
      {
#line 1026
      tmp___7 = unicode_byte_type((char )*(ptr + 1), (char )*(ptr + 0));
#line 1026
      tmp___8 = tmp___7;
      }
    }
    {
#line 1027
    if (tmp___8 == 10) {
#line 1027
      goto case_10___0;
    }
#line 1027
    if (tmp___8 == 21) {
#line 1027
      goto case_10___0;
    }
#line 1029
    if (tmp___8 == 9) {
#line 1029
      goto case_9___0;
    }
#line 1034
    goto switch_default;
    case_10___0: /* CIL Label */ 
    case_21___0: /* CIL Label */ 
#line 1028
    goto switch_break___1;
    case_9___0: /* CIL Label */ 
#line 1031
    if ((unsigned long )(ptr + 2) != (unsigned long )end) {
#line 1032
      goto switch_break___1;
    }
    switch_default: /* CIL Label */ 
#line 1035
    *nextTokPtr = ptr;
#line 1036
    return (15);
    switch_break___1: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1039
  *nextTokPtr = ptr;
#line 1040
  return (15);
  case_30: /* CIL Label */ 
  {
#line 1042
  tmp___9 = little2_scanPercent(enc, ptr + 2, end, nextTokPtr);
  }
#line 1042
  return (tmp___9);
  case_35: /* CIL Label */ 
#line 1044
  *nextTokPtr = ptr + 2;
#line 1045
  return (38);
  case_20: /* CIL Label */ 
#line 1047
  *nextTokPtr = ptr + 2;
#line 1048
  return (25);
  case_4: /* CIL Label */ 
#line 1050
  ptr += 2;
#line 1051
  if ((unsigned long )ptr == (unsigned long )end) {
#line 1052
    return (-26);
  }
#line 1053
  if ((int const   )*(ptr + 1) == 0) {
#line 1053
    if ((int const   )*(ptr + 0) == 93) {
#line 1054
      if ((unsigned long )(ptr + 2) == (unsigned long )end) {
#line 1055
        return (-1);
      }
#line 1056
      if ((int const   )*((ptr + 2) + 1) == 0) {
#line 1056
        if ((int const   )*((ptr + 2) + 0) == 62) {
#line 1057
          *nextTokPtr = ptr + 4;
#line 1058
          return (34);
        }
      }
    }
  }
#line 1061
  *nextTokPtr = ptr;
#line 1062
  return (26);
  case_31: /* CIL Label */ 
#line 1064
  *nextTokPtr = ptr + 2;
#line 1065
  return (23);
  case_32: /* CIL Label */ 
#line 1067
  ptr += 2;
#line 1068
  if ((unsigned long )ptr == (unsigned long )end) {
#line 1069
    return (-24);
  }
#line 1070
  if ((int const   )*(ptr + 1) == 0) {
#line 1070
    tmp___11 = (int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr];
  } else {
    {
#line 1070
    tmp___10 = unicode_byte_type((char )*(ptr + 1), (char )*(ptr + 0));
#line 1070
    tmp___11 = tmp___10;
    }
  }
  {
#line 1071
  if (tmp___11 == 33) {
#line 1071
    goto case_33;
  }
#line 1074
  if (tmp___11 == 15) {
#line 1074
    goto case_15___0;
  }
#line 1077
  if (tmp___11 == 34) {
#line 1077
    goto case_34;
  }
#line 1082
  if (tmp___11 == 32) {
#line 1082
    goto case_32___0;
  }
#line 1082
  if (tmp___11 == 36) {
#line 1082
    goto case_32___0;
  }
#line 1082
  if (tmp___11 == 35) {
#line 1082
    goto case_32___0;
  }
#line 1082
  if (tmp___11 == 11) {
#line 1082
    goto case_32___0;
  }
#line 1082
  if (tmp___11 == 21) {
#line 1082
    goto case_32___0;
  }
#line 1082
  if (tmp___11 == 10) {
#line 1082
    goto case_32___0;
  }
#line 1082
  if (tmp___11 == 9) {
#line 1082
    goto case_32___0;
  }
#line 1070
  goto switch_break___2;
  case_33: /* CIL Label */ 
#line 1072
  *nextTokPtr = ptr + 2;
#line 1073
  return (36);
  case_15___0: /* CIL Label */ 
#line 1075
  *nextTokPtr = ptr + 2;
#line 1076
  return (35);
  case_34: /* CIL Label */ 
#line 1078
  *nextTokPtr = ptr + 2;
#line 1079
  return (37);
  case_32___0: /* CIL Label */ 
  case_36: /* CIL Label */ 
  case_35___0: /* CIL Label */ 
  case_11: /* CIL Label */ 
  case_21___1: /* CIL Label */ 
  case_10___1: /* CIL Label */ 
  case_9___1: /* CIL Label */ 
#line 1083
  *nextTokPtr = ptr;
#line 1084
  return (24);
  switch_break___2: /* CIL Label */ ;
  }
#line 1086
  *nextTokPtr = ptr;
#line 1087
  return (0);
  case_36___0: /* CIL Label */ 
#line 1089
  *nextTokPtr = ptr + 2;
#line 1090
  return (21);
  case_11___0: /* CIL Label */ 
#line 1092
  *nextTokPtr = ptr + 2;
#line 1093
  return (17);
  case_19: /* CIL Label */ 
  {
#line 1095
  tmp___12 = little2_scanPoundName(enc, ptr + 2, end, nextTokPtr);
  }
#line 1095
  return (tmp___12);
  case_5___0: /* CIL Label */ 
#line 1112
  if (end - ptr < 2L) {
#line 1112
    return (-2);
  }
#line 1112
  *nextTokPtr = ptr;
#line 1112
  return (0);
  case_6___0: /* CIL Label */ 
#line 1112
  if (end - ptr < 3L) {
#line 1112
    return (-2);
  }
#line 1112
  *nextTokPtr = ptr;
#line 1112
  return (0);
  case_7___0: /* CIL Label */ 
#line 1112
  if (end - ptr < 4L) {
#line 1112
    return (-2);
  }
#line 1112
  *nextTokPtr = ptr;
#line 1112
  return (0);
  case_24___0: /* CIL Label */ 
  case_22___0: /* CIL Label */ 
#line 1116
  tok = 18;
#line 1117
  ptr += 2;
#line 1118
  goto switch_break;
  case_23: /* CIL Label */ 
  case_27: /* CIL Label */ 
  case_26: /* CIL Label */ 
  case_25: /* CIL Label */ 
#line 1125
  tok = 19;
#line 1126
  ptr += 2;
#line 1127
  goto switch_break;
  case_29___0: /* CIL Label */ 
#line 1129
  if (namingBitmap[((int const   )nmstrtPages[(unsigned char )*(ptr + 1)] << 3) + (int const   )((int )((unsigned char )*(ptr + 0)) >> 5)] & (unsigned int const   )(1 << ((int )((unsigned char )*(ptr + 0)) & 31))) {
#line 1130
    ptr += 2;
#line 1131
    tok = 18;
#line 1132
    goto switch_break;
  }
#line 1134
  if (namingBitmap[((int const   )namePages[(unsigned char )*(ptr + 1)] << 3) + (int const   )((int )((unsigned char )*(ptr + 0)) >> 5)] & (unsigned int const   )(1 << ((int )((unsigned char )*(ptr + 0)) & 31))) {
#line 1135
    ptr += 2;
#line 1136
    tok = 19;
#line 1137
    goto switch_break;
  }
  switch_default___0: /* CIL Label */ 
#line 1141
  *nextTokPtr = ptr;
#line 1142
  return (0);
  switch_break: /* CIL Label */ ;
  }
  {
#line 1144
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1144
    if (! ((unsigned long )ptr != (unsigned long )end)) {
#line 1144
      goto while_break___0;
    }
#line 1145
    if ((int const   )*(ptr + 1) == 0) {
#line 1145
      tmp___14 = (int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr];
    } else {
      {
#line 1145
      tmp___13 = unicode_byte_type((char )*(ptr + 1), (char )*(ptr + 0));
#line 1145
      tmp___14 = tmp___13;
      }
    }
    {
#line 1146
    if (tmp___14 == 29) {
#line 1146
      goto case_29___1;
    }
#line 1146
    if (tmp___14 == 27) {
#line 1146
      goto case_27___0;
    }
#line 1146
    if (tmp___14 == 26) {
#line 1146
      goto case_27___0;
    }
#line 1146
    if (tmp___14 == 25) {
#line 1146
      goto case_27___0;
    }
#line 1146
    if (tmp___14 == 24) {
#line 1146
      goto case_27___0;
    }
#line 1146
    if (tmp___14 == 22) {
#line 1146
      goto case_27___0;
    }
#line 1146
    if (tmp___14 == 5) {
#line 1146
      goto case_5___1;
    }
#line 1146
    if (tmp___14 == 6) {
#line 1146
      goto case_6___1;
    }
#line 1146
    if (tmp___14 == 7) {
#line 1146
      goto case_7___1;
    }
#line 1149
    if (tmp___14 == 10) {
#line 1149
      goto case_10___2;
    }
#line 1149
    if (tmp___14 == 9) {
#line 1149
      goto case_10___2;
    }
#line 1149
    if (tmp___14 == 21) {
#line 1149
      goto case_10___2;
    }
#line 1149
    if (tmp___14 == 30) {
#line 1149
      goto case_10___2;
    }
#line 1149
    if (tmp___14 == 20) {
#line 1149
      goto case_10___2;
    }
#line 1149
    if (tmp___14 == 36) {
#line 1149
      goto case_10___2;
    }
#line 1149
    if (tmp___14 == 35) {
#line 1149
      goto case_10___2;
    }
#line 1149
    if (tmp___14 == 32) {
#line 1149
      goto case_10___2;
    }
#line 1149
    if (tmp___14 == 11) {
#line 1149
      goto case_10___2;
    }
#line 1153
    if (tmp___14 == 23) {
#line 1153
      goto case_23___0;
    }
#line 1173
    if (tmp___14 == 34) {
#line 1173
      goto case_34___0;
    }
#line 1180
    if (tmp___14 == 33) {
#line 1180
      goto case_33___0;
    }
#line 1187
    if (tmp___14 == 15) {
#line 1187
      goto case_15___1;
    }
#line 1194
    goto switch_default___2;
    case_29___1: /* CIL Label */ 
#line 1146
    if (! (namingBitmap[((int const   )namePages[(unsigned char )*(ptr + 1)] << 3) + (int const   )((int )((unsigned char )*(ptr + 0)) >> 5)] & (unsigned int const   )(1 << ((int )((unsigned char )*(ptr + 0)) & 31)))) {
#line 1146
      *nextTokPtr = ptr;
#line 1146
      return (0);
    }
    case_27___0: /* CIL Label */ 
    case_26___0: /* CIL Label */ 
    case_25___0: /* CIL Label */ 
    case_24___1: /* CIL Label */ 
    case_22___1: /* CIL Label */ 
#line 1146
    ptr += 2;
#line 1146
    goto switch_break___3;
    case_5___1: /* CIL Label */ 
#line 1146
    if (end - ptr < 2L) {
#line 1146
      return (-2);
    }
#line 1146
    *nextTokPtr = ptr;
#line 1146
    return (0);
#line 1146
    ptr += 2;
#line 1146
    goto switch_break___3;
    case_6___1: /* CIL Label */ 
#line 1146
    if (end - ptr < 3L) {
#line 1146
      return (-2);
    }
#line 1146
    *nextTokPtr = ptr;
#line 1146
    return (0);
#line 1146
    ptr += 3;
#line 1146
    goto switch_break___3;
    case_7___1: /* CIL Label */ 
#line 1146
    if (end - ptr < 4L) {
#line 1146
      return (-2);
    }
#line 1146
    *nextTokPtr = ptr;
#line 1146
    return (0);
#line 1146
    ptr += 4;
#line 1146
    goto switch_break___3;
    case_10___2: /* CIL Label */ 
    case_9___2: /* CIL Label */ 
    case_21___2: /* CIL Label */ 
    case_30___0: /* CIL Label */ 
    case_20___0: /* CIL Label */ 
    case_36___1: /* CIL Label */ 
    case_35___1: /* CIL Label */ 
    case_32___1: /* CIL Label */ 
    case_11___1: /* CIL Label */ 
#line 1150
    *nextTokPtr = ptr;
#line 1151
    return (tok);
    case_23___0: /* CIL Label */ 
#line 1154
    ptr += 2;
    {
#line 1156
    if (tok == 18) {
#line 1156
      goto case_18;
    }
#line 1167
    if (tok == 41) {
#line 1167
      goto case_41;
    }
#line 1155
    goto switch_break___4;
    case_18: /* CIL Label */ 
#line 1157
    if ((unsigned long )ptr == (unsigned long )end) {
#line 1158
      return (-1);
    }
#line 1159
    tok = 41;
#line 1160
    if ((int const   )*(ptr + 1) == 0) {
#line 1160
      tmp___16 = (int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr];
    } else {
      {
#line 1160
      tmp___15 = unicode_byte_type((char )*(ptr + 1), (char )*(ptr + 0));
#line 1160
      tmp___16 = tmp___15;
      }
    }
    {
#line 1161
    if (tmp___16 == 29) {
#line 1161
      goto case_29___2;
    }
#line 1161
    if (tmp___16 == 27) {
#line 1161
      goto case_27___1;
    }
#line 1161
    if (tmp___16 == 26) {
#line 1161
      goto case_27___1;
    }
#line 1161
    if (tmp___16 == 25) {
#line 1161
      goto case_27___1;
    }
#line 1161
    if (tmp___16 == 24) {
#line 1161
      goto case_27___1;
    }
#line 1161
    if (tmp___16 == 22) {
#line 1161
      goto case_27___1;
    }
#line 1161
    if (tmp___16 == 5) {
#line 1161
      goto case_5___2;
    }
#line 1161
    if (tmp___16 == 6) {
#line 1161
      goto case_6___2;
    }
#line 1161
    if (tmp___16 == 7) {
#line 1161
      goto case_7___2;
    }
#line 1162
    goto switch_default___1;
    case_29___2: /* CIL Label */ 
#line 1161
    if (! (namingBitmap[((int const   )namePages[(unsigned char )*(ptr + 1)] << 3) + (int const   )((int )((unsigned char )*(ptr + 0)) >> 5)] & (unsigned int const   )(1 << ((int )((unsigned char )*(ptr + 0)) & 31)))) {
#line 1161
      *nextTokPtr = ptr;
#line 1161
      return (0);
    }
    case_27___1: /* CIL Label */ 
    case_26___1: /* CIL Label */ 
    case_25___1: /* CIL Label */ 
    case_24___2: /* CIL Label */ 
    case_22___2: /* CIL Label */ 
#line 1161
    ptr += 2;
#line 1161
    goto switch_break___5;
    case_5___2: /* CIL Label */ 
#line 1161
    if (end - ptr < 2L) {
#line 1161
      return (-2);
    }
#line 1161
    *nextTokPtr = ptr;
#line 1161
    return (0);
#line 1161
    ptr += 2;
#line 1161
    goto switch_break___5;
    case_6___2: /* CIL Label */ 
#line 1161
    if (end - ptr < 3L) {
#line 1161
      return (-2);
    }
#line 1161
    *nextTokPtr = ptr;
#line 1161
    return (0);
#line 1161
    ptr += 3;
#line 1161
    goto switch_break___5;
    case_7___2: /* CIL Label */ 
#line 1161
    if (end - ptr < 4L) {
#line 1161
      return (-2);
    }
#line 1161
    *nextTokPtr = ptr;
#line 1161
    return (0);
#line 1161
    ptr += 4;
#line 1161
    goto switch_break___5;
    switch_default___1: /* CIL Label */ 
#line 1163
    tok = 19;
#line 1164
    goto switch_break___5;
    switch_break___5: /* CIL Label */ ;
    }
#line 1166
    goto switch_break___4;
    case_41: /* CIL Label */ 
#line 1168
    tok = 19;
#line 1169
    goto switch_break___4;
    switch_break___4: /* CIL Label */ ;
    }
#line 1171
    goto switch_break___3;
    case_34___0: /* CIL Label */ 
#line 1174
    if (tok == 19) {
#line 1175
      *nextTokPtr = ptr;
#line 1176
      return (0);
    }
#line 1178
    *nextTokPtr = ptr + 2;
#line 1179
    return (32);
    case_33___0: /* CIL Label */ 
#line 1181
    if (tok == 19) {
#line 1182
      *nextTokPtr = ptr;
#line 1183
      return (0);
    }
#line 1185
    *nextTokPtr = ptr + 2;
#line 1186
    return (31);
    case_15___1: /* CIL Label */ 
#line 1188
    if (tok == 19) {
#line 1189
      *nextTokPtr = ptr;
#line 1190
      return (0);
    }
#line 1192
    *nextTokPtr = ptr + 2;
#line 1193
    return (30);
    switch_default___2: /* CIL Label */ 
#line 1195
    *nextTokPtr = ptr;
#line 1196
    return (0);
    switch_break___3: /* CIL Label */ ;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1199
  return (- tok);
}
}
#line 1202 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmltok_impl.c"
static int little2_attributeValueTok(ENCODING const   *enc , char const   *ptr , char const   *end ,
                                     char const   **nextTokPtr ) 
{ 
  char const   *start ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 1207
  if ((unsigned long )ptr == (unsigned long )end) {
#line 1208
    return (-4);
  }
#line 1209
  start = ptr;
  {
#line 1210
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1210
    if (! ((unsigned long )ptr != (unsigned long )end)) {
#line 1210
      goto while_break;
    }
#line 1211
    if ((int const   )*(ptr + 1) == 0) {
#line 1211
      tmp___0 = (int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr];
    } else {
      {
#line 1211
      tmp = unicode_byte_type((char )*(ptr + 1), (char )*(ptr + 0));
#line 1211
      tmp___0 = tmp;
      }
    }
    {
#line 1214
    if (tmp___0 == 5) {
#line 1214
      goto case_5;
    }
#line 1214
    if (tmp___0 == 6) {
#line 1214
      goto case_6;
    }
#line 1214
    if (tmp___0 == 7) {
#line 1214
      goto case_7;
    }
#line 1216
    if (tmp___0 == 3) {
#line 1216
      goto case_3;
    }
#line 1221
    if (tmp___0 == 2) {
#line 1221
      goto case_2;
    }
#line 1225
    if (tmp___0 == 10) {
#line 1225
      goto case_10;
    }
#line 1232
    if (tmp___0 == 9) {
#line 1232
      goto case_9;
    }
#line 1244
    if (tmp___0 == 21) {
#line 1244
      goto case_21;
    }
#line 1251
    goto switch_default;
    case_5: /* CIL Label */ 
#line 1214
    ptr += 2;
#line 1214
    goto switch_break;
    case_6: /* CIL Label */ 
#line 1214
    ptr += 3;
#line 1214
    goto switch_break;
    case_7: /* CIL Label */ 
#line 1214
    ptr += 4;
#line 1214
    goto switch_break;
    case_3: /* CIL Label */ 
#line 1217
    if ((unsigned long )ptr == (unsigned long )start) {
      {
#line 1218
      tmp___1 = little2_scanRef(enc, ptr + 2, end, nextTokPtr);
      }
#line 1218
      return (tmp___1);
    }
#line 1219
    *nextTokPtr = ptr;
#line 1220
    return (6);
    case_2: /* CIL Label */ 
#line 1223
    *nextTokPtr = ptr;
#line 1224
    return (0);
    case_10: /* CIL Label */ 
#line 1226
    if ((unsigned long )ptr == (unsigned long )start) {
#line 1227
      *nextTokPtr = ptr + 2;
#line 1228
      return (7);
    }
#line 1230
    *nextTokPtr = ptr;
#line 1231
    return (6);
    case_9: /* CIL Label */ 
#line 1233
    if ((unsigned long )ptr == (unsigned long )start) {
#line 1234
      ptr += 2;
#line 1235
      if ((unsigned long )ptr == (unsigned long )end) {
#line 1236
        return (-3);
      }
#line 1237
      if ((int const   )*(ptr + 1) == 0) {
#line 1237
        tmp___3 = (int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr];
      } else {
        {
#line 1237
        tmp___2 = unicode_byte_type((char )*(ptr + 1), (char )*(ptr + 0));
#line 1237
        tmp___3 = tmp___2;
        }
      }
#line 1237
      if (tmp___3 == 10) {
#line 1238
        ptr += 2;
      }
#line 1239
      *nextTokPtr = ptr;
#line 1240
      return (7);
    }
#line 1242
    *nextTokPtr = ptr;
#line 1243
    return (6);
    case_21: /* CIL Label */ 
#line 1245
    if ((unsigned long )ptr == (unsigned long )start) {
#line 1246
      *nextTokPtr = ptr + 2;
#line 1247
      return (39);
    }
#line 1249
    *nextTokPtr = ptr;
#line 1250
    return (6);
    switch_default: /* CIL Label */ 
#line 1252
    ptr += 2;
#line 1253
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1256
  *nextTokPtr = ptr;
#line 1257
  return (6);
}
}
#line 1260 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmltok_impl.c"
static int little2_entityValueTok(ENCODING const   *enc , char const   *ptr , char const   *end ,
                                  char const   **nextTokPtr ) 
{ 
  char const   *start ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tok ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 1265
  if ((unsigned long )ptr == (unsigned long )end) {
#line 1266
    return (-4);
  }
#line 1267
  start = ptr;
  {
#line 1268
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1268
    if (! ((unsigned long )ptr != (unsigned long )end)) {
#line 1268
      goto while_break;
    }
#line 1269
    if ((int const   )*(ptr + 1) == 0) {
#line 1269
      tmp___0 = (int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr];
    } else {
      {
#line 1269
      tmp = unicode_byte_type((char )*(ptr + 1), (char )*(ptr + 0));
#line 1269
      tmp___0 = tmp;
      }
    }
    {
#line 1272
    if (tmp___0 == 5) {
#line 1272
      goto case_5;
    }
#line 1272
    if (tmp___0 == 6) {
#line 1272
      goto case_6;
    }
#line 1272
    if (tmp___0 == 7) {
#line 1272
      goto case_7;
    }
#line 1274
    if (tmp___0 == 3) {
#line 1274
      goto case_3;
    }
#line 1279
    if (tmp___0 == 30) {
#line 1279
      goto case_30;
    }
#line 1287
    if (tmp___0 == 10) {
#line 1287
      goto case_10;
    }
#line 1294
    if (tmp___0 == 9) {
#line 1294
      goto case_9;
    }
#line 1306
    goto switch_default;
    case_5: /* CIL Label */ 
#line 1272
    ptr += 2;
#line 1272
    goto switch_break;
    case_6: /* CIL Label */ 
#line 1272
    ptr += 3;
#line 1272
    goto switch_break;
    case_7: /* CIL Label */ 
#line 1272
    ptr += 4;
#line 1272
    goto switch_break;
    case_3: /* CIL Label */ 
#line 1275
    if ((unsigned long )ptr == (unsigned long )start) {
      {
#line 1276
      tmp___1 = little2_scanRef(enc, ptr + 2, end, nextTokPtr);
      }
#line 1276
      return (tmp___1);
    }
#line 1277
    *nextTokPtr = ptr;
#line 1278
    return (6);
    case_30: /* CIL Label */ 
#line 1280
    if ((unsigned long )ptr == (unsigned long )start) {
      {
#line 1281
      tmp___2 = little2_scanPercent(enc, ptr + 2, end, nextTokPtr);
#line 1281
      tok = tmp___2;
      }
#line 1283
      if (tok == 22) {
#line 1283
        tmp___3 = 0;
      } else {
#line 1283
        tmp___3 = tok;
      }
#line 1283
      return (tmp___3);
    }
#line 1285
    *nextTokPtr = ptr;
#line 1286
    return (6);
    case_10: /* CIL Label */ 
#line 1288
    if ((unsigned long )ptr == (unsigned long )start) {
#line 1289
      *nextTokPtr = ptr + 2;
#line 1290
      return (7);
    }
#line 1292
    *nextTokPtr = ptr;
#line 1293
    return (6);
    case_9: /* CIL Label */ 
#line 1295
    if ((unsigned long )ptr == (unsigned long )start) {
#line 1296
      ptr += 2;
#line 1297
      if ((unsigned long )ptr == (unsigned long )end) {
#line 1298
        return (-3);
      }
#line 1299
      if ((int const   )*(ptr + 1) == 0) {
#line 1299
        tmp___5 = (int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr];
      } else {
        {
#line 1299
        tmp___4 = unicode_byte_type((char )*(ptr + 1), (char )*(ptr + 0));
#line 1299
        tmp___5 = tmp___4;
        }
      }
#line 1299
      if (tmp___5 == 10) {
#line 1300
        ptr += 2;
      }
#line 1301
      *nextTokPtr = ptr;
#line 1302
      return (7);
    }
#line 1304
    *nextTokPtr = ptr;
#line 1305
    return (6);
    switch_default: /* CIL Label */ 
#line 1307
    ptr += 2;
#line 1308
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1311
  *nextTokPtr = ptr;
#line 1312
  return (6);
}
}
#line 1317 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmltok_impl.c"
static int little2_ignoreSectionTok(ENCODING const   *enc , char const   *ptr , char const   *end ,
                                    char const   **nextTokPtr ) 
{ 
  int level ;
  size_t n ;
  int tmp ;
  int tmp___0 ;

  {
#line 1321
  level = 0;
#line 1323
  n = (size_t )(end - ptr);
#line 1324
  if (n & 1UL) {
#line 1325
    n &= 0xfffffffffffffffeUL;
#line 1326
    end = ptr + n;
  }
  {
#line 1329
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1329
    if (! ((unsigned long )ptr != (unsigned long )end)) {
#line 1329
      goto while_break;
    }
#line 1330
    if ((int const   )*(ptr + 1) == 0) {
#line 1330
      tmp___0 = (int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr];
    } else {
      {
#line 1330
      tmp = unicode_byte_type((char )*(ptr + 1), (char )*(ptr + 0));
#line 1330
      tmp___0 = tmp;
      }
    }
    {
#line 1331
    if (tmp___0 == 5) {
#line 1331
      goto case_5;
    }
#line 1331
    if (tmp___0 == 6) {
#line 1331
      goto case_6;
    }
#line 1331
    if (tmp___0 == 7) {
#line 1331
      goto case_7;
    }
#line 1331
    if (tmp___0 == 8) {
#line 1331
      goto case_8;
    }
#line 1331
    if (tmp___0 == 1) {
#line 1331
      goto case_8;
    }
#line 1331
    if (tmp___0 == 0) {
#line 1331
      goto case_8;
    }
#line 1332
    if (tmp___0 == 2) {
#line 1332
      goto case_2;
    }
#line 1344
    if (tmp___0 == 4) {
#line 1344
      goto case_4;
    }
#line 1360
    goto switch_default;
    case_5: /* CIL Label */ 
#line 1331
    if (end - ptr < 2L) {
#line 1331
      return (-2);
    }
#line 1331
    ptr += 2;
#line 1331
    goto switch_break;
    case_6: /* CIL Label */ 
#line 1331
    if (end - ptr < 3L) {
#line 1331
      return (-2);
    }
#line 1331
    ptr += 3;
#line 1331
    goto switch_break;
    case_7: /* CIL Label */ 
#line 1331
    if (end - ptr < 4L) {
#line 1331
      return (-2);
    }
#line 1331
    ptr += 4;
#line 1331
    goto switch_break;
    case_8: /* CIL Label */ 
    case_1: /* CIL Label */ 
    case_0: /* CIL Label */ 
#line 1331
    *nextTokPtr = ptr;
#line 1331
    return (0);
    case_2: /* CIL Label */ 
#line 1333
    ptr += 2;
#line 1333
    if ((unsigned long )ptr == (unsigned long )end) {
#line 1334
      return (-1);
    }
#line 1335
    if ((int const   )*(ptr + 1) == 0) {
#line 1335
      if ((int const   )*(ptr + 0) == 33) {
#line 1336
        ptr += 2;
#line 1336
        if ((unsigned long )ptr == (unsigned long )end) {
#line 1337
          return (-1);
        }
#line 1338
        if ((int const   )*(ptr + 1) == 0) {
#line 1338
          if ((int const   )*(ptr + 0) == 91) {
#line 1339
            level ++;
#line 1340
            ptr += 2;
          }
        }
      }
    }
#line 1343
    goto switch_break;
    case_4: /* CIL Label */ 
#line 1345
    ptr += 2;
#line 1345
    if ((unsigned long )ptr == (unsigned long )end) {
#line 1346
      return (-1);
    }
#line 1347
    if ((int const   )*(ptr + 1) == 0) {
#line 1347
      if ((int const   )*(ptr + 0) == 93) {
#line 1348
        ptr += 2;
#line 1348
        if ((unsigned long )ptr == (unsigned long )end) {
#line 1349
          return (-1);
        }
#line 1350
        if ((int const   )*(ptr + 1) == 0) {
#line 1350
          if ((int const   )*(ptr + 0) == 62) {
#line 1351
            ptr += 2;
#line 1352
            if (level == 0) {
#line 1353
              *nextTokPtr = ptr;
#line 1354
              return (42);
            }
#line 1356
            level --;
          }
        }
      }
    }
#line 1359
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 1361
    ptr += 2;
#line 1362
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1365
  return (-1);
}
}
#line 1370 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmltok_impl.c"
static int little2_isPublicId(ENCODING const   *enc , char const   *ptr , char const   *end ,
                              char const   **badPtr ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 1374
  ptr += 2;
#line 1375
  end -= 2;
  {
#line 1376
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1376
    if (! ((unsigned long )ptr != (unsigned long )end)) {
#line 1376
      goto while_break;
    }
#line 1377
    if ((int const   )*(ptr + 1) == 0) {
#line 1377
      tmp___0 = (int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr];
    } else {
      {
#line 1377
      tmp = unicode_byte_type((char )*(ptr + 1), (char )*(ptr + 0));
#line 1377
      tmp___0 = tmp;
      }
    }
    {
#line 1397
    if (tmp___0 == 23) {
#line 1397
      goto case_23;
    }
#line 1397
    if (tmp___0 == 19) {
#line 1397
      goto case_23;
    }
#line 1397
    if (tmp___0 == 30) {
#line 1397
      goto case_23;
    }
#line 1397
    if (tmp___0 == 33) {
#line 1397
      goto case_23;
    }
#line 1397
    if (tmp___0 == 16) {
#line 1397
      goto case_23;
    }
#line 1397
    if (tmp___0 == 18) {
#line 1397
      goto case_23;
    }
#line 1397
    if (tmp___0 == 10) {
#line 1397
      goto case_23;
    }
#line 1397
    if (tmp___0 == 9) {
#line 1397
      goto case_23;
    }
#line 1397
    if (tmp___0 == 15) {
#line 1397
      goto case_23;
    }
#line 1397
    if (tmp___0 == 14) {
#line 1397
      goto case_23;
    }
#line 1397
    if (tmp___0 == 17) {
#line 1397
      goto case_23;
    }
#line 1397
    if (tmp___0 == 35) {
#line 1397
      goto case_23;
    }
#line 1397
    if (tmp___0 == 34) {
#line 1397
      goto case_23;
    }
#line 1397
    if (tmp___0 == 32) {
#line 1397
      goto case_23;
    }
#line 1397
    if (tmp___0 == 31) {
#line 1397
      goto case_23;
    }
#line 1397
    if (tmp___0 == 13) {
#line 1397
      goto case_23;
    }
#line 1397
    if (tmp___0 == 27) {
#line 1397
      goto case_23;
    }
#line 1397
    if (tmp___0 == 24) {
#line 1397
      goto case_23;
    }
#line 1397
    if (tmp___0 == 25) {
#line 1397
      goto case_23;
    }
#line 1400
    if (tmp___0 == 21) {
#line 1400
      goto case_21;
    }
#line 1407
    if (tmp___0 == 22) {
#line 1407
      goto case_22;
    }
#line 1407
    if (tmp___0 == 26) {
#line 1407
      goto case_22;
    }
#line 1410
    goto switch_default;
    case_23: /* CIL Label */ 
    case_19: /* CIL Label */ 
    case_30: /* CIL Label */ 
    case_33: /* CIL Label */ 
    case_16: /* CIL Label */ 
    case_18: /* CIL Label */ 
    case_10: /* CIL Label */ 
    case_9: /* CIL Label */ 
    case_15: /* CIL Label */ 
    case_14: /* CIL Label */ 
    case_17: /* CIL Label */ 
    case_35: /* CIL Label */ 
    case_34: /* CIL Label */ 
    case_32: /* CIL Label */ 
    case_31: /* CIL Label */ 
    case_13: /* CIL Label */ 
    case_27: /* CIL Label */ 
    case_24: /* CIL Label */ 
    case_25: /* CIL Label */ 
#line 1399
    goto switch_break;
    case_21: /* CIL Label */ 
#line 1401
    if ((int const   )*(ptr + 1) == 0) {
#line 1401
      if ((int const   )*(ptr + 0) == 9) {
#line 1402
        *badPtr = ptr;
#line 1403
        return (0);
      }
    }
#line 1405
    goto switch_break;
    case_22: /* CIL Label */ 
    case_26: /* CIL Label */ 
#line 1408
    if ((int const   )*(ptr + 1) == 0) {
#line 1408
      tmp___1 = (int const   )*(ptr + 0);
    } else {
#line 1408
      tmp___1 = (int const   )-1;
    }
#line 1408
    if (! (tmp___1 & -128)) {
#line 1409
      goto switch_break;
    }
    switch_default: /* CIL Label */ 
#line 1411
    if ((int const   )*(ptr + 1) == 0) {
#line 1411
      tmp___2 = (int const   )*(ptr + 0);
    } else {
#line 1411
      tmp___2 = (int const   )-1;
    }
    {
#line 1413
    if (tmp___2 == 64) {
#line 1413
      goto case_64;
    }
#line 1413
    if (tmp___2 == 36) {
#line 1413
      goto case_64;
    }
#line 1415
    goto switch_default___0;
    case_64: /* CIL Label */ 
    case_36: /* CIL Label */ 
#line 1414
    goto switch_break___0;
    switch_default___0: /* CIL Label */ 
#line 1416
    *badPtr = ptr;
#line 1417
    return (0);
    switch_break___0: /* CIL Label */ ;
    }
#line 1419
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 1376
    ptr += 2;
  }
  while_break: /* CIL Label */ ;
  }
#line 1422
  return (1);
}
}
#line 1430 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmltok_impl.c"
static int little2_getAtts(ENCODING const   *enc , char const   *ptr , int attsMax ,
                           ATTRIBUTE *atts ) 
{ 
  enum __anonenum_state_6 state ;
  int nAtts ;
  int open___0 ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 1434
  state = (enum __anonenum_state_6 )1;
#line 1435
  nAtts = 0;
#line 1436
  open___0 = 0;
#line 1439
  ptr += 2;
  {
#line 1439
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1440
    if ((int const   )*(ptr + 1) == 0) {
#line 1440
      tmp___0 = (int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr];
    } else {
      {
#line 1440
      tmp = unicode_byte_type((char )*(ptr + 1), (char )*(ptr + 0));
#line 1440
      tmp___0 = tmp;
      }
    }
    {
#line 1451
    if (tmp___0 == 5) {
#line 1451
      goto case_5;
    }
#line 1451
    if (tmp___0 == 6) {
#line 1451
      goto case_6;
    }
#line 1451
    if (tmp___0 == 7) {
#line 1451
      goto case_7;
    }
#line 1455
    if (tmp___0 == 24) {
#line 1455
      goto case_24;
    }
#line 1455
    if (tmp___0 == 22) {
#line 1455
      goto case_24;
    }
#line 1455
    if (tmp___0 == 29) {
#line 1455
      goto case_24;
    }
#line 1459
    if (tmp___0 == 12) {
#line 1459
      goto case_12;
    }
#line 1473
    if (tmp___0 == 13) {
#line 1473
      goto case_13;
    }
#line 1487
    if (tmp___0 == 3) {
#line 1487
      goto case_3;
    }
#line 1491
    if (tmp___0 == 21) {
#line 1491
      goto case_21;
    }
#line 1503
    if (tmp___0 == 10) {
#line 1503
      goto case_10;
    }
#line 1503
    if (tmp___0 == 9) {
#line 1503
      goto case_10;
    }
#line 1512
    if (tmp___0 == 17) {
#line 1512
      goto case_17;
    }
#line 1512
    if (tmp___0 == 11) {
#line 1512
      goto case_17;
    }
#line 1516
    goto switch_default;
    case_5: /* CIL Label */ 
#line 1451
    if ((unsigned int )state == 0U) {
#line 1451
      if (nAtts < attsMax) {
#line 1451
        (atts + nAtts)->name = ptr;
#line 1451
        (atts + nAtts)->normalized = (char)1;
      }
#line 1451
      state = (enum __anonenum_state_6 )1;
    }
#line 1451
    ptr += 0;
#line 1451
    goto switch_break;
    case_6: /* CIL Label */ 
#line 1451
    if ((unsigned int )state == 0U) {
#line 1451
      if (nAtts < attsMax) {
#line 1451
        (atts + nAtts)->name = ptr;
#line 1451
        (atts + nAtts)->normalized = (char)1;
      }
#line 1451
      state = (enum __anonenum_state_6 )1;
    }
#line 1451
    ptr ++;
#line 1451
    goto switch_break;
    case_7: /* CIL Label */ 
#line 1451
    if ((unsigned int )state == 0U) {
#line 1451
      if (nAtts < attsMax) {
#line 1451
        (atts + nAtts)->name = ptr;
#line 1451
        (atts + nAtts)->normalized = (char)1;
      }
#line 1451
      state = (enum __anonenum_state_6 )1;
    }
#line 1451
    ptr += 2;
#line 1451
    goto switch_break;
    case_24: /* CIL Label */ 
    case_22: /* CIL Label */ 
    case_29: /* CIL Label */ 
#line 1456
    if ((unsigned int )state == 0U) {
#line 1456
      if (nAtts < attsMax) {
#line 1456
        (atts + nAtts)->name = ptr;
#line 1456
        (atts + nAtts)->normalized = (char)1;
      }
#line 1456
      state = (enum __anonenum_state_6 )1;
    }
#line 1457
    goto switch_break;
    case_12: /* CIL Label */ 
#line 1460
    if ((unsigned int )state != 2U) {
#line 1461
      if (nAtts < attsMax) {
#line 1462
        (atts + nAtts)->valuePtr = ptr + 2;
      }
#line 1463
      state = (enum __anonenum_state_6 )2;
#line 1464
      open___0 = 12;
    } else
#line 1466
    if (open___0 == 12) {
#line 1467
      state = (enum __anonenum_state_6 )0;
#line 1468
      if (nAtts < attsMax) {
#line 1469
        (atts + nAtts)->valueEnd = ptr;
      }
#line 1470
      nAtts ++;
    }
#line 1472
    goto switch_break;
    case_13: /* CIL Label */ 
#line 1474
    if ((unsigned int )state != 2U) {
#line 1475
      if (nAtts < attsMax) {
#line 1476
        (atts + nAtts)->valuePtr = ptr + 2;
      }
#line 1477
      state = (enum __anonenum_state_6 )2;
#line 1478
      open___0 = 13;
    } else
#line 1480
    if (open___0 == 13) {
#line 1481
      state = (enum __anonenum_state_6 )0;
#line 1482
      if (nAtts < attsMax) {
#line 1483
        (atts + nAtts)->valueEnd = ptr;
      }
#line 1484
      nAtts ++;
    }
#line 1486
    goto switch_break;
    case_3: /* CIL Label */ 
#line 1488
    if (nAtts < attsMax) {
#line 1489
      (atts + nAtts)->normalized = (char)0;
    }
#line 1490
    goto switch_break;
    case_21: /* CIL Label */ 
#line 1492
    if ((unsigned int )state == 1U) {
#line 1493
      state = (enum __anonenum_state_6 )0;
    } else
#line 1494
    if ((unsigned int )state == 2U) {
#line 1494
      if (nAtts < attsMax) {
#line 1494
        if ((atts + nAtts)->normalized) {
#line 1494
          if ((unsigned long )ptr == (unsigned long )(atts + nAtts)->valuePtr) {
#line 1501
            (atts + nAtts)->normalized = (char)0;
          } else {
#line 1494
            if ((int const   )*(ptr + 1) == 0) {
#line 1494
              tmp___1 = (int const   )*(ptr + 0);
            } else {
#line 1494
              tmp___1 = (int const   )-1;
            }
#line 1494
            if (tmp___1 != 32) {
#line 1501
              (atts + nAtts)->normalized = (char)0;
            } else {
#line 1494
              if ((int const   )*((ptr + 2) + 1) == 0) {
#line 1494
                tmp___2 = (int const   )*((ptr + 2) + 0);
              } else {
#line 1494
                tmp___2 = (int const   )-1;
              }
#line 1494
              if (tmp___2 == 32) {
#line 1501
                (atts + nAtts)->normalized = (char)0;
              } else {
#line 1494
                if ((int const   )*((ptr + 2) + 1) == 0) {
#line 1494
                  tmp___4 = (int )((struct normal_encoding *)enc)->type[(unsigned char )*(ptr + 2)];
                } else {
                  {
#line 1494
                  tmp___3 = unicode_byte_type((char )*((ptr + 2) + 1), (char )*((ptr + 2) + 0));
#line 1494
                  tmp___4 = tmp___3;
                  }
                }
#line 1494
                if (tmp___4 == open___0) {
#line 1501
                  (atts + nAtts)->normalized = (char)0;
                }
              }
            }
          }
        }
      }
    }
#line 1502
    goto switch_break;
    case_10: /* CIL Label */ 
    case_9: /* CIL Label */ 
#line 1506
    if ((unsigned int )state == 1U) {
#line 1507
      state = (enum __anonenum_state_6 )0;
    } else
#line 1508
    if ((unsigned int )state == 2U) {
#line 1508
      if (nAtts < attsMax) {
#line 1509
        (atts + nAtts)->normalized = (char)0;
      }
    }
#line 1510
    goto switch_break;
    case_17: /* CIL Label */ 
    case_11: /* CIL Label */ 
#line 1513
    if ((unsigned int )state != 2U) {
#line 1514
      return (nAtts);
    }
#line 1515
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 1517
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 1439
    ptr += 2;
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 1523 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmltok_impl.c"
static int little2_charRefNumber(ENCODING const   *enc , char const   *ptr ) 
{ 
  int result ;
  int c___0 ;
  int tmp ;
  int c___1 ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 1526
  result = 0;
#line 1528
  ptr += 4;
#line 1529
  if ((int const   )*(ptr + 1) == 0) {
#line 1529
    if ((int const   )*(ptr + 0) == 120) {
#line 1530
      ptr += 2;
      {
#line 1530
      while (1) {
        while_continue: /* CIL Label */ ;
#line 1530
        if ((int const   )*(ptr + 1) == 0) {
#line 1530
          if ((int const   )*(ptr + 0) == 59) {
#line 1530
            goto while_break;
          }
        }
#line 1533
        if ((int const   )*(ptr + 1) == 0) {
#line 1533
          tmp = (int const   )*(ptr + 0);
        } else {
#line 1533
          tmp = (int const   )-1;
        }
#line 1533
        c___0 = (int )tmp;
        {
#line 1536
        if (c___0 == 57) {
#line 1536
          goto case_57;
        }
#line 1536
        if (c___0 == 56) {
#line 1536
          goto case_57;
        }
#line 1536
        if (c___0 == 55) {
#line 1536
          goto case_57;
        }
#line 1536
        if (c___0 == 54) {
#line 1536
          goto case_57;
        }
#line 1536
        if (c___0 == 53) {
#line 1536
          goto case_57;
        }
#line 1536
        if (c___0 == 52) {
#line 1536
          goto case_57;
        }
#line 1536
        if (c___0 == 51) {
#line 1536
          goto case_57;
        }
#line 1536
        if (c___0 == 50) {
#line 1536
          goto case_57;
        }
#line 1536
        if (c___0 == 49) {
#line 1536
          goto case_57;
        }
#line 1536
        if (c___0 == 48) {
#line 1536
          goto case_57;
        }
#line 1541
        if (c___0 == 70) {
#line 1541
          goto case_70;
        }
#line 1541
        if (c___0 == 69) {
#line 1541
          goto case_70;
        }
#line 1541
        if (c___0 == 68) {
#line 1541
          goto case_70;
        }
#line 1541
        if (c___0 == 67) {
#line 1541
          goto case_70;
        }
#line 1541
        if (c___0 == 66) {
#line 1541
          goto case_70;
        }
#line 1541
        if (c___0 == 65) {
#line 1541
          goto case_70;
        }
#line 1546
        if (c___0 == 102) {
#line 1546
          goto case_102;
        }
#line 1546
        if (c___0 == 101) {
#line 1546
          goto case_102;
        }
#line 1546
        if (c___0 == 100) {
#line 1546
          goto case_102;
        }
#line 1546
        if (c___0 == 99) {
#line 1546
          goto case_102;
        }
#line 1546
        if (c___0 == 98) {
#line 1546
          goto case_102;
        }
#line 1546
        if (c___0 == 97) {
#line 1546
          goto case_102;
        }
#line 1534
        goto switch_break;
        case_57: /* CIL Label */ 
        case_56: /* CIL Label */ 
        case_55: /* CIL Label */ 
        case_54: /* CIL Label */ 
        case_53: /* CIL Label */ 
        case_52: /* CIL Label */ 
        case_51: /* CIL Label */ 
        case_50: /* CIL Label */ 
        case_49: /* CIL Label */ 
        case_48: /* CIL Label */ 
#line 1537
        result <<= 4;
#line 1538
        result |= c___0 - 48;
#line 1539
        goto switch_break;
        case_70: /* CIL Label */ 
        case_69: /* CIL Label */ 
        case_68: /* CIL Label */ 
        case_67: /* CIL Label */ 
        case_66: /* CIL Label */ 
        case_65: /* CIL Label */ 
#line 1542
        result <<= 4;
#line 1543
        result += 10 + (c___0 - 65);
#line 1544
        goto switch_break;
        case_102: /* CIL Label */ 
        case_101: /* CIL Label */ 
        case_100: /* CIL Label */ 
        case_99: /* CIL Label */ 
        case_98: /* CIL Label */ 
        case_97: /* CIL Label */ 
#line 1547
        result <<= 4;
#line 1548
        result += 10 + (c___0 - 97);
#line 1549
        goto switch_break;
        switch_break: /* CIL Label */ ;
        }
#line 1551
        if (result >= 1114112) {
#line 1552
          return (-1);
        }
#line 1530
        ptr += 2;
      }
      while_break: /* CIL Label */ ;
      }
    } else {
#line 1529
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
    {
#line 1556
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1556
      if ((int const   )*(ptr + 1) == 0) {
#line 1556
        if ((int const   )*(ptr + 0) == 59) {
#line 1556
          goto while_break___0;
        }
      }
#line 1557
      if ((int const   )*(ptr + 1) == 0) {
#line 1557
        tmp___0 = (int const   )*(ptr + 0);
      } else {
#line 1557
        tmp___0 = (int const   )-1;
      }
#line 1557
      c___1 = (int )tmp___0;
#line 1558
      result *= 10;
#line 1559
      result += c___1 - 48;
#line 1560
      if (result >= 1114112) {
#line 1561
        return (-1);
      }
#line 1556
      ptr += 2;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  {
#line 1564
  tmp___1 = checkCharRefNumber(result);
  }
#line 1564
  return (tmp___1);
}
}
#line 1567 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmltok_impl.c"
static int little2_predefinedEntityName(ENCODING const   *enc , char const   *ptr ,
                                        char const   *end ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  {
#line 1572
  if ((end - ptr) / 2L == 2L) {
#line 1572
    goto case_2;
  }
#line 1582
  if ((end - ptr) / 2L == 3L) {
#line 1582
    goto case_3;
  }
#line 1592
  if ((end - ptr) / 2L == 4L) {
#line 1592
    goto case_4;
  }
#line 1571
  goto switch_break;
  case_2: /* CIL Label */ 
#line 1573
  if ((int const   )*((ptr + 2) + 1) == 0) {
#line 1573
    if ((int const   )*((ptr + 2) + 0) == 116) {
#line 1574
      if ((int const   )*(ptr + 1) == 0) {
#line 1574
        tmp = (int const   )*(ptr + 0);
      } else {
#line 1574
        tmp = (int const   )-1;
      }
      {
#line 1575
      if (tmp == 108) {
#line 1575
        goto case_108;
      }
#line 1577
      if (tmp == 103) {
#line 1577
        goto case_103;
      }
#line 1574
      goto switch_break___0;
      case_108: /* CIL Label */ 
#line 1576
      return (60);
      case_103: /* CIL Label */ 
#line 1578
      return (62);
      switch_break___0: /* CIL Label */ ;
      }
    }
  }
#line 1581
  goto switch_break;
  case_3: /* CIL Label */ 
#line 1583
  if ((int const   )*(ptr + 1) == 0) {
#line 1583
    if ((int const   )*(ptr + 0) == 97) {
#line 1584
      ptr += 2;
#line 1585
      if ((int const   )*(ptr + 1) == 0) {
#line 1585
        if ((int const   )*(ptr + 0) == 109) {
#line 1586
          ptr += 2;
#line 1587
          if ((int const   )*(ptr + 1) == 0) {
#line 1587
            if ((int const   )*(ptr + 0) == 112) {
#line 1588
              return (38);
            }
          }
        }
      }
    }
  }
#line 1591
  goto switch_break;
  case_4: /* CIL Label */ 
#line 1593
  if ((int const   )*(ptr + 1) == 0) {
#line 1593
    tmp___0 = (int const   )*(ptr + 0);
  } else {
#line 1593
    tmp___0 = (int const   )-1;
  }
  {
#line 1594
  if (tmp___0 == 113) {
#line 1594
    goto case_113;
  }
#line 1605
  if (tmp___0 == 97) {
#line 1605
    goto case_97;
  }
#line 1593
  goto switch_break___1;
  case_113: /* CIL Label */ 
#line 1595
  ptr += 2;
#line 1596
  if ((int const   )*(ptr + 1) == 0) {
#line 1596
    if ((int const   )*(ptr + 0) == 117) {
#line 1597
      ptr += 2;
#line 1598
      if ((int const   )*(ptr + 1) == 0) {
#line 1598
        if ((int const   )*(ptr + 0) == 111) {
#line 1599
          ptr += 2;
#line 1600
          if ((int const   )*(ptr + 1) == 0) {
#line 1600
            if ((int const   )*(ptr + 0) == 116) {
#line 1601
              return (34);
            }
          }
        }
      }
    }
  }
#line 1604
  goto switch_break___1;
  case_97: /* CIL Label */ 
#line 1606
  ptr += 2;
#line 1607
  if ((int const   )*(ptr + 1) == 0) {
#line 1607
    if ((int const   )*(ptr + 0) == 112) {
#line 1608
      ptr += 2;
#line 1609
      if ((int const   )*(ptr + 1) == 0) {
#line 1609
        if ((int const   )*(ptr + 0) == 111) {
#line 1610
          ptr += 2;
#line 1611
          if ((int const   )*(ptr + 1) == 0) {
#line 1611
            if ((int const   )*(ptr + 0) == 115) {
#line 1612
              return (39);
            }
          }
        }
      }
    }
  }
#line 1615
  goto switch_break___1;
  switch_break___1: /* CIL Label */ ;
  }
  switch_break: /* CIL Label */ ;
  }
#line 1618
  return (0);
}
}
#line 1621 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmltok_impl.c"
static int little2_sameName(ENCODING const   *enc , char const   *ptr1 , char const   *ptr2 ) 
{ 
  int tmp ;
  int tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;
  char const   *tmp___4 ;
  char const   *tmp___5 ;
  char const   *tmp___6 ;
  char const   *tmp___7 ;
  char const   *tmp___8 ;
  char const   *tmp___9 ;
  char const   *tmp___10 ;
  char const   *tmp___11 ;
  char const   *tmp___12 ;
  int tmp___17 ;
  int tmp___18 ;

  {
  {
#line 1624
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1625
    if ((int const   )*(ptr1 + 1) == 0) {
#line 1625
      tmp___0 = (int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr1];
    } else {
      {
#line 1625
      tmp = unicode_byte_type((char )*(ptr1 + 1), (char )*(ptr1 + 0));
#line 1625
      tmp___0 = tmp;
      }
    }
    {
#line 1630
    if (tmp___0 == 7) {
#line 1630
      goto case_7;
    }
#line 1630
    if (tmp___0 == 6) {
#line 1630
      goto case_6;
    }
#line 1630
    if (tmp___0 == 5) {
#line 1630
      goto case_5;
    }
#line 1644
    if (tmp___0 == 27) {
#line 1644
      goto case_27;
    }
#line 1644
    if (tmp___0 == 26) {
#line 1644
      goto case_27;
    }
#line 1644
    if (tmp___0 == 25) {
#line 1644
      goto case_27;
    }
#line 1644
    if (tmp___0 == 24) {
#line 1644
      goto case_27;
    }
#line 1644
    if (tmp___0 == 23) {
#line 1644
      goto case_27;
    }
#line 1644
    if (tmp___0 == 22) {
#line 1644
      goto case_27;
    }
#line 1644
    if (tmp___0 == 29) {
#line 1644
      goto case_27;
    }
#line 1660
    goto switch_default;
    case_7: /* CIL Label */ 
#line 1630
    tmp___1 = ptr1;
#line 1630
    ptr1 ++;
#line 1630
    tmp___2 = ptr2;
#line 1630
    ptr2 ++;
#line 1630
    if ((int const   )*tmp___1 != (int const   )*tmp___2) {
#line 1630
      return (0);
    }
    case_6: /* CIL Label */ 
#line 1630
    tmp___3 = ptr1;
#line 1630
    ptr1 ++;
#line 1630
    tmp___4 = ptr2;
#line 1630
    ptr2 ++;
#line 1630
    if ((int const   )*tmp___3 != (int const   )*tmp___4) {
#line 1630
      return (0);
    }
    case_5: /* CIL Label */ 
#line 1630
    tmp___5 = ptr1;
#line 1630
    ptr1 ++;
#line 1630
    tmp___6 = ptr2;
#line 1630
    ptr2 ++;
#line 1630
    if ((int const   )*tmp___5 != (int const   )*tmp___6) {
#line 1630
      return (0);
    }
#line 1633
    tmp___7 = ptr1;
#line 1633
    ptr1 ++;
#line 1633
    tmp___8 = ptr2;
#line 1633
    ptr2 ++;
#line 1633
    if ((int const   )*tmp___7 != (int const   )*tmp___8) {
#line 1634
      return (0);
    }
#line 1635
    goto switch_break;
    case_27: /* CIL Label */ 
    case_26: /* CIL Label */ 
    case_25: /* CIL Label */ 
    case_24: /* CIL Label */ 
    case_23: /* CIL Label */ 
    case_22: /* CIL Label */ 
    case_29: /* CIL Label */ 
#line 1645
    tmp___9 = ptr2;
#line 1645
    ptr2 ++;
#line 1645
    tmp___10 = ptr1;
#line 1645
    ptr1 ++;
#line 1645
    if ((int const   )*tmp___9 != (int const   )*tmp___10) {
#line 1646
      return (0);
    }
#line 1648
    tmp___11 = ptr2;
#line 1648
    ptr2 ++;
#line 1648
    tmp___12 = ptr1;
#line 1648
    ptr1 ++;
#line 1648
    if ((int const   )*tmp___11 != (int const   )*tmp___12) {
#line 1649
      return (0);
    }
#line 1659
    goto switch_break;
    switch_default: /* CIL Label */ ;
#line 1663
    if ((int const   )*(ptr2 + 1) == 0) {
#line 1663
      tmp___18 = (int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr2];
    } else {
      {
#line 1663
      tmp___17 = unicode_byte_type((char )*(ptr2 + 1), (char )*(ptr2 + 0));
#line 1663
      tmp___18 = tmp___17;
      }
    }
    {
#line 1675
    if (tmp___18 == 27) {
#line 1675
      goto case_27___0;
    }
#line 1675
    if (tmp___18 == 26) {
#line 1675
      goto case_27___0;
    }
#line 1675
    if (tmp___18 == 25) {
#line 1675
      goto case_27___0;
    }
#line 1675
    if (tmp___18 == 24) {
#line 1675
      goto case_27___0;
    }
#line 1675
    if (tmp___18 == 23) {
#line 1675
      goto case_27___0;
    }
#line 1675
    if (tmp___18 == 22) {
#line 1675
      goto case_27___0;
    }
#line 1675
    if (tmp___18 == 29) {
#line 1675
      goto case_27___0;
    }
#line 1675
    if (tmp___18 == 7) {
#line 1675
      goto case_27___0;
    }
#line 1675
    if (tmp___18 == 6) {
#line 1675
      goto case_27___0;
    }
#line 1675
    if (tmp___18 == 5) {
#line 1675
      goto case_27___0;
    }
#line 1677
    goto switch_default___0;
    case_27___0: /* CIL Label */ 
    case_26___0: /* CIL Label */ 
    case_25___0: /* CIL Label */ 
    case_24___0: /* CIL Label */ 
    case_23___0: /* CIL Label */ 
    case_22___0: /* CIL Label */ 
    case_29___0: /* CIL Label */ 
    case_7___0: /* CIL Label */ 
    case_6___0: /* CIL Label */ 
    case_5___0: /* CIL Label */ 
#line 1676
    return (0);
    switch_default___0: /* CIL Label */ 
#line 1678
    return (1);
    switch_break___0: /* CIL Label */ ;
    }
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 1685 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmltok_impl.c"
static int little2_nameMatchesAscii(ENCODING const   *enc , char const   *ptr1 , char const   *end1 ,
                                    char const   *ptr2 ) 
{ 


  {
  {
#line 1689
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1689
    if (! *ptr2) {
#line 1689
      goto while_break;
    }
#line 1690
    if ((unsigned long )ptr1 == (unsigned long )end1) {
#line 1691
      return (0);
    }
#line 1692
    if ((int const   )*(ptr1 + 1) == 0) {
#line 1692
      if (! ((int const   )*(ptr1 + 0) == (int const   )*ptr2)) {
#line 1693
        return (0);
      }
    } else {
#line 1693
      return (0);
    }
#line 1689
    ptr1 += 2;
#line 1689
    ptr2 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1695
  return ((unsigned long )ptr1 == (unsigned long )end1);
}
}
#line 1698 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmltok_impl.c"
static int little2_nameLength(ENCODING const   *enc , char const   *ptr ) 
{ 
  char const   *start ;
  int tmp ;
  int tmp___0 ;

  {
#line 1701
  start = ptr;
  {
#line 1702
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1703
    if ((int const   )*(ptr + 1) == 0) {
#line 1703
      tmp___0 = (int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr];
    } else {
      {
#line 1703
      tmp = unicode_byte_type((char )*(ptr + 1), (char )*(ptr + 0));
#line 1703
      tmp___0 = tmp;
      }
    }
    {
#line 1706
    if (tmp___0 == 5) {
#line 1706
      goto case_5;
    }
#line 1706
    if (tmp___0 == 6) {
#line 1706
      goto case_6;
    }
#line 1706
    if (tmp___0 == 7) {
#line 1706
      goto case_7;
    }
#line 1716
    if (tmp___0 == 27) {
#line 1716
      goto case_27;
    }
#line 1716
    if (tmp___0 == 26) {
#line 1716
      goto case_27;
    }
#line 1716
    if (tmp___0 == 25) {
#line 1716
      goto case_27;
    }
#line 1716
    if (tmp___0 == 24) {
#line 1716
      goto case_27;
    }
#line 1716
    if (tmp___0 == 23) {
#line 1716
      goto case_27;
    }
#line 1716
    if (tmp___0 == 22) {
#line 1716
      goto case_27;
    }
#line 1716
    if (tmp___0 == 29) {
#line 1716
      goto case_27;
    }
#line 1719
    goto switch_default;
    case_5: /* CIL Label */ 
#line 1706
    ptr += 2;
#line 1706
    goto switch_break;
    case_6: /* CIL Label */ 
#line 1706
    ptr += 3;
#line 1706
    goto switch_break;
    case_7: /* CIL Label */ 
#line 1706
    ptr += 4;
#line 1706
    goto switch_break;
    case_27: /* CIL Label */ 
    case_26: /* CIL Label */ 
    case_25: /* CIL Label */ 
    case_24: /* CIL Label */ 
    case_23: /* CIL Label */ 
    case_22: /* CIL Label */ 
    case_29: /* CIL Label */ 
#line 1717
    ptr += 2;
#line 1718
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 1720
    return ((int )(ptr - start));
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 1725 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmltok_impl.c"
static char const   *little2_skipS(ENCODING const   *enc , char const   *ptr ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  {
#line 1728
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1729
    if ((int const   )*(ptr + 1) == 0) {
#line 1729
      tmp___0 = (int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr];
    } else {
      {
#line 1729
      tmp = unicode_byte_type((char )*(ptr + 1), (char )*(ptr + 0));
#line 1729
      tmp___0 = tmp;
      }
    }
    {
#line 1732
    if (tmp___0 == 21) {
#line 1732
      goto case_21;
    }
#line 1732
    if (tmp___0 == 9) {
#line 1732
      goto case_21;
    }
#line 1732
    if (tmp___0 == 10) {
#line 1732
      goto case_21;
    }
#line 1735
    goto switch_default;
    case_21: /* CIL Label */ 
    case_9: /* CIL Label */ 
    case_10: /* CIL Label */ 
#line 1733
    ptr += 2;
#line 1734
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 1736
    return (ptr);
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 1741 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmltok_impl.c"
static void little2_updatePosition(ENCODING const   *enc , char const   *ptr , char const   *end ,
                                   POSITION *pos ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 1747
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1747
    if (! ((unsigned long )ptr < (unsigned long )end)) {
#line 1747
      goto while_break;
    }
#line 1748
    if ((int const   )*(ptr + 1) == 0) {
#line 1748
      tmp___0 = (int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr];
    } else {
      {
#line 1748
      tmp = unicode_byte_type((char )*(ptr + 1), (char )*(ptr + 0));
#line 1748
      tmp___0 = tmp;
      }
    }
    {
#line 1753
    if (tmp___0 == 5) {
#line 1753
      goto case_5;
    }
#line 1753
    if (tmp___0 == 6) {
#line 1753
      goto case_6;
    }
#line 1753
    if (tmp___0 == 7) {
#line 1753
      goto case_7;
    }
#line 1755
    if (tmp___0 == 10) {
#line 1755
      goto case_10;
    }
#line 1760
    if (tmp___0 == 9) {
#line 1760
      goto case_9;
    }
#line 1767
    goto switch_default;
    case_5: /* CIL Label */ 
#line 1753
    ptr += 2;
#line 1753
    goto switch_break;
    case_6: /* CIL Label */ 
#line 1753
    ptr += 3;
#line 1753
    goto switch_break;
    case_7: /* CIL Label */ 
#line 1753
    ptr += 4;
#line 1753
    goto switch_break;
    case_10: /* CIL Label */ 
#line 1756
    pos->columnNumber = (XML_Size )-1;
#line 1757
    (pos->lineNumber) ++;
#line 1758
    ptr += 2;
#line 1759
    goto switch_break;
    case_9: /* CIL Label */ 
#line 1761
    (pos->lineNumber) ++;
#line 1762
    ptr += 2;
#line 1763
    if ((unsigned long )ptr != (unsigned long )end) {
#line 1763
      if ((int const   )*(ptr + 1) == 0) {
#line 1763
        tmp___2 = (int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr];
      } else {
        {
#line 1763
        tmp___1 = unicode_byte_type((char )*(ptr + 1), (char )*(ptr + 0));
#line 1763
        tmp___2 = tmp___1;
        }
      }
#line 1763
      if (tmp___2 == 10) {
#line 1764
        ptr += 2;
      }
    }
#line 1765
    pos->columnNumber = (XML_Size )-1;
#line 1766
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 1768
    ptr += 2;
#line 1769
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 1771
    (pos->columnNumber) ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1773
  return;
}
}
#line 717 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmltok.c"
static struct normal_encoding  const  little2_encoding_ns  = 
#line 717 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmltok.c"
     {{{& little2_prologTok, & little2_contentTok, & little2_cdataSectionTok, & little2_ignoreSectionTok},
     {& little2_attributeValueTok, & little2_entityValueTok}, & little2_sameName,
     & little2_nameMatchesAscii, & little2_nameLength, & little2_skipS, & little2_getAtts,
     & little2_charRefNumber, & little2_predefinedEntityName, & little2_updatePosition,
     & little2_isPublicId, & little2_toUtf8, & little2_toUtf16, 2, (char)0, (char)1},
    {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
     (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)21,
     (unsigned char)10, (unsigned char)0, (unsigned char)0, (unsigned char)9, (unsigned char)0,
     (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
     (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
     (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
     (unsigned char)0, (unsigned char)0, (unsigned char)21, (unsigned char)16, (unsigned char)12,
     (unsigned char)19, (unsigned char)28, (unsigned char)30, (unsigned char)3, (unsigned char)13,
     (unsigned char)31, (unsigned char)32, (unsigned char)33, (unsigned char)34, (unsigned char)35,
     (unsigned char)27, (unsigned char)26, (unsigned char)17, (unsigned char)25, (unsigned char)25,
     (unsigned char)25, (unsigned char)25, (unsigned char)25, (unsigned char)25, (unsigned char)25,
     (unsigned char)25, (unsigned char)25, (unsigned char)25, (unsigned char)23, (unsigned char)18,
     (unsigned char)2, (unsigned char)14, (unsigned char)11, (unsigned char)15, (unsigned char)28,
     (unsigned char)24, (unsigned char)24, (unsigned char)24, (unsigned char)24, (unsigned char)24,
     (unsigned char)24, (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22,
     (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22,
     (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22,
     (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22,
     (unsigned char)22, (unsigned char)20, (unsigned char)28, (unsigned char)4, (unsigned char)28,
     (unsigned char)22, (unsigned char)28, (unsigned char)24, (unsigned char)24, (unsigned char)24,
     (unsigned char)24, (unsigned char)24, (unsigned char)24, (unsigned char)22, (unsigned char)22,
     (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22,
     (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22,
     (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22,
     (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)28, (unsigned char)36,
     (unsigned char)28, (unsigned char)28, (unsigned char)28, (unsigned char)28, (unsigned char)28,
     (unsigned char)28, (unsigned char)28, (unsigned char)28, (unsigned char)28, (unsigned char)28,
     (unsigned char)28, (unsigned char)28, (unsigned char)28, (unsigned char)28, (unsigned char)28,
     (unsigned char)28, (unsigned char)28, (unsigned char)28, (unsigned char)28, (unsigned char)28,
     (unsigned char)28, (unsigned char)28, (unsigned char)28, (unsigned char)28, (unsigned char)28,
     (unsigned char)28, (unsigned char)28, (unsigned char)28, (unsigned char)28, (unsigned char)28,
     (unsigned char)28, (unsigned char)28, (unsigned char)28, (unsigned char)28, (unsigned char)28,
     (unsigned char)28, (unsigned char)28, (unsigned char)28, (unsigned char)28, (unsigned char)28,
     (unsigned char)28, (unsigned char)28, (unsigned char)28, (unsigned char)28, (unsigned char)28,
     (unsigned char)22, (unsigned char)28, (unsigned char)28, (unsigned char)28, (unsigned char)28,
     (unsigned char)28, (unsigned char)28, (unsigned char)28, (unsigned char)28, (unsigned char)28,
     (unsigned char)28, (unsigned char)22, (unsigned char)28, (unsigned char)26, (unsigned char)28,
     (unsigned char)28, (unsigned char)22, (unsigned char)28, (unsigned char)28, (unsigned char)28,
     (unsigned char)28, (unsigned char)28, (unsigned char)22, (unsigned char)22, (unsigned char)22,
     (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22,
     (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22,
     (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22,
     (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22,
     (unsigned char)28, (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22,
     (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22,
     (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22,
     (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22,
     (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22,
     (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22,
     (unsigned char)22, (unsigned char)22, (unsigned char)28, (unsigned char)22, (unsigned char)22,
     (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22,
     (unsigned char)22}, (int (*)(ENCODING const   * , char const   * ))0, (int (*)(ENCODING const   * ,
                                                                                    char const   * ))0,
    (int (*)(ENCODING const   * , char const   * ))0, (int (*)(ENCODING const   * ,
                                                               char const   * ))0,
    (int (*)(ENCODING const   * , char const   * ))0, (int (*)(ENCODING const   * ,
                                                               char const   * ))0,
    (int (*)(ENCODING const   * , char const   * ))0, (int (*)(ENCODING const   * ,
                                                               char const   * ))0,
    (int (*)(ENCODING const   * , char const   * ))0};
#line 734 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmltok.c"
static struct normal_encoding  const  little2_encoding  = 
#line 734
     {{{& little2_prologTok, & little2_contentTok, & little2_cdataSectionTok, & little2_ignoreSectionTok},
     {& little2_attributeValueTok, & little2_entityValueTok}, & little2_sameName,
     & little2_nameMatchesAscii, & little2_nameLength, & little2_skipS, & little2_getAtts,
     & little2_charRefNumber, & little2_predefinedEntityName, & little2_updatePosition,
     & little2_isPublicId, & little2_toUtf8, & little2_toUtf16, 2, (char)0, (char)1},
    {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
     (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)21,
     (unsigned char)10, (unsigned char)0, (unsigned char)0, (unsigned char)9, (unsigned char)0,
     (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
     (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
     (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
     (unsigned char)0, (unsigned char)0, (unsigned char)21, (unsigned char)16, (unsigned char)12,
     (unsigned char)19, (unsigned char)28, (unsigned char)30, (unsigned char)3, (unsigned char)13,
     (unsigned char)31, (unsigned char)32, (unsigned char)33, (unsigned char)34, (unsigned char)35,
     (unsigned char)27, (unsigned char)26, (unsigned char)17, (unsigned char)25, (unsigned char)25,
     (unsigned char)25, (unsigned char)25, (unsigned char)25, (unsigned char)25, (unsigned char)25,
     (unsigned char)25, (unsigned char)25, (unsigned char)25, (unsigned char)22, (unsigned char)18,
     (unsigned char)2, (unsigned char)14, (unsigned char)11, (unsigned char)15, (unsigned char)28,
     (unsigned char)24, (unsigned char)24, (unsigned char)24, (unsigned char)24, (unsigned char)24,
     (unsigned char)24, (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22,
     (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22,
     (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22,
     (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22,
     (unsigned char)22, (unsigned char)20, (unsigned char)28, (unsigned char)4, (unsigned char)28,
     (unsigned char)22, (unsigned char)28, (unsigned char)24, (unsigned char)24, (unsigned char)24,
     (unsigned char)24, (unsigned char)24, (unsigned char)24, (unsigned char)22, (unsigned char)22,
     (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22,
     (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22,
     (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22,
     (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)28, (unsigned char)36,
     (unsigned char)28, (unsigned char)28, (unsigned char)28, (unsigned char)28, (unsigned char)28,
     (unsigned char)28, (unsigned char)28, (unsigned char)28, (unsigned char)28, (unsigned char)28,
     (unsigned char)28, (unsigned char)28, (unsigned char)28, (unsigned char)28, (unsigned char)28,
     (unsigned char)28, (unsigned char)28, (unsigned char)28, (unsigned char)28, (unsigned char)28,
     (unsigned char)28, (unsigned char)28, (unsigned char)28, (unsigned char)28, (unsigned char)28,
     (unsigned char)28, (unsigned char)28, (unsigned char)28, (unsigned char)28, (unsigned char)28,
     (unsigned char)28, (unsigned char)28, (unsigned char)28, (unsigned char)28, (unsigned char)28,
     (unsigned char)28, (unsigned char)28, (unsigned char)28, (unsigned char)28, (unsigned char)28,
     (unsigned char)28, (unsigned char)28, (unsigned char)28, (unsigned char)28, (unsigned char)28,
     (unsigned char)22, (unsigned char)28, (unsigned char)28, (unsigned char)28, (unsigned char)28,
     (unsigned char)28, (unsigned char)28, (unsigned char)28, (unsigned char)28, (unsigned char)28,
     (unsigned char)28, (unsigned char)22, (unsigned char)28, (unsigned char)26, (unsigned char)28,
     (unsigned char)28, (unsigned char)22, (unsigned char)28, (unsigned char)28, (unsigned char)28,
     (unsigned char)28, (unsigned char)28, (unsigned char)22, (unsigned char)22, (unsigned char)22,
     (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22,
     (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22,
     (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22,
     (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22,
     (unsigned char)28, (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22,
     (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22,
     (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22,
     (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22,
     (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22,
     (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22,
     (unsigned char)22, (unsigned char)22, (unsigned char)28, (unsigned char)22, (unsigned char)22,
     (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22,
     (unsigned char)22}, (int (*)(ENCODING const   * , char const   * ))0, (int (*)(ENCODING const   * ,
                                                                                    char const   * ))0,
    (int (*)(ENCODING const   * , char const   * ))0, (int (*)(ENCODING const   * ,
                                                               char const   * ))0,
    (int (*)(ENCODING const   * , char const   * ))0, (int (*)(ENCODING const   * ,
                                                               char const   * ))0,
    (int (*)(ENCODING const   * , char const   * ))0, (int (*)(ENCODING const   * ,
                                                               char const   * ))0,
    (int (*)(ENCODING const   * , char const   * ))0};
#line 755 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmltok.c"
static struct normal_encoding  const  internal_little2_encoding_ns  = 
#line 755
     {{{& little2_prologTok, & little2_contentTok, & little2_cdataSectionTok, & little2_ignoreSectionTok},
     {& little2_attributeValueTok, & little2_entityValueTok}, & little2_sameName,
     & little2_nameMatchesAscii, & little2_nameLength, & little2_skipS, & little2_getAtts,
     & little2_charRefNumber, & little2_predefinedEntityName, & little2_updatePosition,
     & little2_isPublicId, & little2_toUtf8, & little2_toUtf16, 2, (char)0, (char)1},
    {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
     (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)21,
     (unsigned char)10, (unsigned char)0, (unsigned char)0, (unsigned char)21, (unsigned char)0,
     (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
     (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
     (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
     (unsigned char)0, (unsigned char)0, (unsigned char)21, (unsigned char)16, (unsigned char)12,
     (unsigned char)19, (unsigned char)28, (unsigned char)30, (unsigned char)3, (unsigned char)13,
     (unsigned char)31, (unsigned char)32, (unsigned char)33, (unsigned char)34, (unsigned char)35,
     (unsigned char)27, (unsigned char)26, (unsigned char)17, (unsigned char)25, (unsigned char)25,
     (unsigned char)25, (unsigned char)25, (unsigned char)25, (unsigned char)25, (unsigned char)25,
     (unsigned char)25, (unsigned char)25, (unsigned char)25, (unsigned char)23, (unsigned char)18,
     (unsigned char)2, (unsigned char)14, (unsigned char)11, (unsigned char)15, (unsigned char)28,
     (unsigned char)24, (unsigned char)24, (unsigned char)24, (unsigned char)24, (unsigned char)24,
     (unsigned char)24, (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22,
     (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22,
     (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22,
     (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22,
     (unsigned char)22, (unsigned char)20, (unsigned char)28, (unsigned char)4, (unsigned char)28,
     (unsigned char)22, (unsigned char)28, (unsigned char)24, (unsigned char)24, (unsigned char)24,
     (unsigned char)24, (unsigned char)24, (unsigned char)24, (unsigned char)22, (unsigned char)22,
     (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22,
     (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22,
     (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22,
     (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)28, (unsigned char)36,
     (unsigned char)28, (unsigned char)28, (unsigned char)28, (unsigned char)28, (unsigned char)28,
     (unsigned char)28, (unsigned char)28, (unsigned char)28, (unsigned char)28, (unsigned char)28,
     (unsigned char)28, (unsigned char)28, (unsigned char)28, (unsigned char)28, (unsigned char)28,
     (unsigned char)28, (unsigned char)28, (unsigned char)28, (unsigned char)28, (unsigned char)28,
     (unsigned char)28, (unsigned char)28, (unsigned char)28, (unsigned char)28, (unsigned char)28,
     (unsigned char)28, (unsigned char)28, (unsigned char)28, (unsigned char)28, (unsigned char)28,
     (unsigned char)28, (unsigned char)28, (unsigned char)28, (unsigned char)28, (unsigned char)28,
     (unsigned char)28, (unsigned char)28, (unsigned char)28, (unsigned char)28, (unsigned char)28,
     (unsigned char)28, (unsigned char)28, (unsigned char)28, (unsigned char)28, (unsigned char)28,
     (unsigned char)22, (unsigned char)28, (unsigned char)28, (unsigned char)28, (unsigned char)28,
     (unsigned char)28, (unsigned char)28, (unsigned char)28, (unsigned char)28, (unsigned char)28,
     (unsigned char)28, (unsigned char)22, (unsigned char)28, (unsigned char)26, (unsigned char)28,
     (unsigned char)28, (unsigned char)22, (unsigned char)28, (unsigned char)28, (unsigned char)28,
     (unsigned char)28, (unsigned char)28, (unsigned char)22, (unsigned char)22, (unsigned char)22,
     (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22,
     (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22,
     (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22,
     (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22,
     (unsigned char)28, (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22,
     (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22,
     (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22,
     (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22,
     (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22,
     (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22,
     (unsigned char)22, (unsigned char)22, (unsigned char)28, (unsigned char)22, (unsigned char)22,
     (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22,
     (unsigned char)22}, (int (*)(ENCODING const   * , char const   * ))0, (int (*)(ENCODING const   * ,
                                                                                    char const   * ))0,
    (int (*)(ENCODING const   * , char const   * ))0, (int (*)(ENCODING const   * ,
                                                               char const   * ))0,
    (int (*)(ENCODING const   * , char const   * ))0, (int (*)(ENCODING const   * ,
                                                               char const   * ))0,
    (int (*)(ENCODING const   * , char const   * ))0, (int (*)(ENCODING const   * ,
                                                               char const   * ))0,
    (int (*)(ENCODING const   * , char const   * ))0};
#line 766 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmltok.c"
static struct normal_encoding  const  internal_little2_encoding  = 
#line 766
     {{{& little2_prologTok, & little2_contentTok, & little2_cdataSectionTok, & little2_ignoreSectionTok},
     {& little2_attributeValueTok, & little2_entityValueTok}, & little2_sameName,
     & little2_nameMatchesAscii, & little2_nameLength, & little2_skipS, & little2_getAtts,
     & little2_charRefNumber, & little2_predefinedEntityName, & little2_updatePosition,
     & little2_isPublicId, & little2_toUtf8, & little2_toUtf16, 2, (char)0, (char)1},
    {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
     (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)21,
     (unsigned char)10, (unsigned char)0, (unsigned char)0, (unsigned char)21, (unsigned char)0,
     (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
     (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
     (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
     (unsigned char)0, (unsigned char)0, (unsigned char)21, (unsigned char)16, (unsigned char)12,
     (unsigned char)19, (unsigned char)28, (unsigned char)30, (unsigned char)3, (unsigned char)13,
     (unsigned char)31, (unsigned char)32, (unsigned char)33, (unsigned char)34, (unsigned char)35,
     (unsigned char)27, (unsigned char)26, (unsigned char)17, (unsigned char)25, (unsigned char)25,
     (unsigned char)25, (unsigned char)25, (unsigned char)25, (unsigned char)25, (unsigned char)25,
     (unsigned char)25, (unsigned char)25, (unsigned char)25, (unsigned char)22, (unsigned char)18,
     (unsigned char)2, (unsigned char)14, (unsigned char)11, (unsigned char)15, (unsigned char)28,
     (unsigned char)24, (unsigned char)24, (unsigned char)24, (unsigned char)24, (unsigned char)24,
     (unsigned char)24, (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22,
     (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22,
     (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22,
     (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22,
     (unsigned char)22, (unsigned char)20, (unsigned char)28, (unsigned char)4, (unsigned char)28,
     (unsigned char)22, (unsigned char)28, (unsigned char)24, (unsigned char)24, (unsigned char)24,
     (unsigned char)24, (unsigned char)24, (unsigned char)24, (unsigned char)22, (unsigned char)22,
     (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22,
     (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22,
     (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22,
     (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)28, (unsigned char)36,
     (unsigned char)28, (unsigned char)28, (unsigned char)28, (unsigned char)28, (unsigned char)28,
     (unsigned char)28, (unsigned char)28, (unsigned char)28, (unsigned char)28, (unsigned char)28,
     (unsigned char)28, (unsigned char)28, (unsigned char)28, (unsigned char)28, (unsigned char)28,
     (unsigned char)28, (unsigned char)28, (unsigned char)28, (unsigned char)28, (unsigned char)28,
     (unsigned char)28, (unsigned char)28, (unsigned char)28, (unsigned char)28, (unsigned char)28,
     (unsigned char)28, (unsigned char)28, (unsigned char)28, (unsigned char)28, (unsigned char)28,
     (unsigned char)28, (unsigned char)28, (unsigned char)28, (unsigned char)28, (unsigned char)28,
     (unsigned char)28, (unsigned char)28, (unsigned char)28, (unsigned char)28, (unsigned char)28,
     (unsigned char)28, (unsigned char)28, (unsigned char)28, (unsigned char)28, (unsigned char)28,
     (unsigned char)22, (unsigned char)28, (unsigned char)28, (unsigned char)28, (unsigned char)28,
     (unsigned char)28, (unsigned char)28, (unsigned char)28, (unsigned char)28, (unsigned char)28,
     (unsigned char)28, (unsigned char)22, (unsigned char)28, (unsigned char)26, (unsigned char)28,
     (unsigned char)28, (unsigned char)22, (unsigned char)28, (unsigned char)28, (unsigned char)28,
     (unsigned char)28, (unsigned char)28, (unsigned char)22, (unsigned char)22, (unsigned char)22,
     (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22,
     (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22,
     (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22,
     (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22,
     (unsigned char)28, (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22,
     (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22,
     (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22,
     (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22,
     (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22,
     (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22,
     (unsigned char)22, (unsigned char)22, (unsigned char)28, (unsigned char)22, (unsigned char)22,
     (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22,
     (unsigned char)22}, (int (*)(ENCODING const   * , char const   * ))0, (int (*)(ENCODING const   * ,
                                                                                    char const   * ))0,
    (int (*)(ENCODING const   * , char const   * ))0, (int (*)(ENCODING const   * ,
                                                               char const   * ))0,
    (int (*)(ENCODING const   * , char const   * ))0, (int (*)(ENCODING const   * ,
                                                               char const   * ))0,
    (int (*)(ENCODING const   * , char const   * ))0, (int (*)(ENCODING const   * ,
                                                               char const   * ))0,
    (int (*)(ENCODING const   * , char const   * ))0};
#line 92 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmltok_impl.c"
static int big2_scanComment(ENCODING const   *enc , char const   *ptr , char const   *end ,
                            char const   **nextTokPtr ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 96
  if ((unsigned long )ptr != (unsigned long )end) {
#line 97
    if ((int const   )*(ptr + 0) == 0) {
#line 97
      if (! ((int const   )*(ptr + 1) == 45)) {
#line 98
        *nextTokPtr = ptr;
#line 99
        return (0);
      }
    } else {
#line 98
      *nextTokPtr = ptr;
#line 99
      return (0);
    }
#line 101
    ptr += 2;
    {
#line 102
    while (1) {
      while_continue: /* CIL Label */ ;
#line 102
      if (! ((unsigned long )ptr != (unsigned long )end)) {
#line 102
        goto while_break;
      }
#line 103
      if ((int const   )*(ptr + 0) == 0) {
#line 103
        tmp___0 = (int )((struct normal_encoding *)enc)->type[(unsigned char )*(ptr + 1)];
      } else {
        {
#line 103
        tmp = unicode_byte_type((char )*(ptr + 0), (char )*(ptr + 1));
#line 103
        tmp___0 = tmp;
        }
      }
      {
#line 104
      if (tmp___0 == 5) {
#line 104
        goto case_5;
      }
#line 104
      if (tmp___0 == 6) {
#line 104
        goto case_6;
      }
#line 104
      if (tmp___0 == 7) {
#line 104
        goto case_7;
      }
#line 104
      if (tmp___0 == 8) {
#line 104
        goto case_8;
      }
#line 104
      if (tmp___0 == 1) {
#line 104
        goto case_8;
      }
#line 104
      if (tmp___0 == 0) {
#line 104
        goto case_8;
      }
#line 105
      if (tmp___0 == 27) {
#line 105
        goto case_27;
      }
#line 119
      goto switch_default;
      case_5: /* CIL Label */ 
#line 104
      if (end - ptr < 2L) {
#line 104
        return (-2);
      }
#line 104
      ptr += 2;
#line 104
      goto switch_break;
      case_6: /* CIL Label */ 
#line 104
      if (end - ptr < 3L) {
#line 104
        return (-2);
      }
#line 104
      ptr += 3;
#line 104
      goto switch_break;
      case_7: /* CIL Label */ 
#line 104
      if (end - ptr < 4L) {
#line 104
        return (-2);
      }
#line 104
      ptr += 4;
#line 104
      goto switch_break;
      case_8: /* CIL Label */ 
      case_1: /* CIL Label */ 
      case_0: /* CIL Label */ 
#line 104
      *nextTokPtr = ptr;
#line 104
      return (0);
      case_27: /* CIL Label */ 
#line 106
      ptr += 2;
#line 106
      if ((unsigned long )ptr == (unsigned long )end) {
#line 107
        return (-1);
      }
#line 108
      if ((int const   )*(ptr + 0) == 0) {
#line 108
        if ((int const   )*(ptr + 1) == 45) {
#line 109
          ptr += 2;
#line 109
          if ((unsigned long )ptr == (unsigned long )end) {
#line 110
            return (-1);
          }
#line 111
          if ((int const   )*(ptr + 0) == 0) {
#line 111
            if (! ((int const   )*(ptr + 1) == 62)) {
#line 112
              *nextTokPtr = ptr;
#line 113
              return (0);
            }
          } else {
#line 112
            *nextTokPtr = ptr;
#line 113
            return (0);
          }
#line 115
          *nextTokPtr = ptr + 2;
#line 116
          return (13);
        }
      }
#line 118
      goto switch_break;
      switch_default: /* CIL Label */ 
#line 120
      ptr += 2;
#line 121
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 125
  return (-1);
}
}
#line 130 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmltok_impl.c"
static int big2_scanDecl(ENCODING const   *enc , char const   *ptr , char const   *end ,
                         char const   **nextTokPtr ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 134
  if ((unsigned long )ptr == (unsigned long )end) {
#line 135
    return (-1);
  }
#line 136
  if ((int const   )*(ptr + 0) == 0) {
#line 136
    tmp___0 = (int )((struct normal_encoding *)enc)->type[(unsigned char )*(ptr + 1)];
  } else {
    {
#line 136
    tmp = unicode_byte_type((char )*(ptr + 0), (char )*(ptr + 1));
#line 136
    tmp___0 = tmp;
    }
  }
  {
#line 137
  if (tmp___0 == 27) {
#line 137
    goto case_27;
  }
#line 139
  if (tmp___0 == 20) {
#line 139
    goto case_20;
  }
#line 143
  if (tmp___0 == 24) {
#line 143
    goto case_24;
  }
#line 143
  if (tmp___0 == 22) {
#line 143
    goto case_24;
  }
#line 146
  goto switch_default;
  case_27: /* CIL Label */ 
  {
#line 138
  tmp___1 = big2_scanComment(enc, ptr + 2, end, nextTokPtr);
  }
#line 138
  return (tmp___1);
  case_20: /* CIL Label */ 
#line 140
  *nextTokPtr = ptr + 2;
#line 141
  return (33);
  case_24: /* CIL Label */ 
  case_22: /* CIL Label */ 
#line 144
  ptr += 2;
#line 145
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 147
  *nextTokPtr = ptr;
#line 148
  return (0);
  switch_break: /* CIL Label */ ;
  }
  {
#line 150
  while (1) {
    while_continue: /* CIL Label */ ;
#line 150
    if (! ((unsigned long )ptr != (unsigned long )end)) {
#line 150
      goto while_break;
    }
#line 151
    if ((int const   )*(ptr + 0) == 0) {
#line 151
      tmp___3 = (int )((struct normal_encoding *)enc)->type[(unsigned char )*(ptr + 1)];
    } else {
      {
#line 151
      tmp___2 = unicode_byte_type((char )*(ptr + 0), (char )*(ptr + 1));
#line 151
      tmp___3 = tmp___2;
      }
    }
    {
#line 152
    if (tmp___3 == 30) {
#line 152
      goto case_30;
    }
#line 162
    if (tmp___3 == 10) {
#line 162
      goto case_10___0;
    }
#line 162
    if (tmp___3 == 9) {
#line 162
      goto case_10___0;
    }
#line 162
    if (tmp___3 == 21) {
#line 162
      goto case_10___0;
    }
#line 166
    if (tmp___3 == 24) {
#line 166
      goto case_24___0;
    }
#line 166
    if (tmp___3 == 22) {
#line 166
      goto case_24___0;
    }
#line 169
    goto switch_default___0;
    case_30: /* CIL Label */ 
#line 153
    if ((unsigned long )(ptr + 2) == (unsigned long )end) {
#line 154
      return (-1);
    }
#line 156
    if ((int const   )*((ptr + 2) + 0) == 0) {
#line 156
      tmp___5 = (int )((struct normal_encoding *)enc)->type[(unsigned char )*((ptr + 2) + 1)];
    } else {
      {
#line 156
      tmp___4 = unicode_byte_type((char )*((ptr + 2) + 0), (char )*((ptr + 2) + 1));
#line 156
      tmp___5 = tmp___4;
      }
    }
    {
#line 157
    if (tmp___5 == 30) {
#line 157
      goto case_30___0;
    }
#line 157
    if (tmp___5 == 10) {
#line 157
      goto case_30___0;
    }
#line 157
    if (tmp___5 == 9) {
#line 157
      goto case_30___0;
    }
#line 157
    if (tmp___5 == 21) {
#line 157
      goto case_30___0;
    }
#line 156
    goto switch_break___1;
    case_30___0: /* CIL Label */ 
    case_10: /* CIL Label */ 
    case_9: /* CIL Label */ 
    case_21: /* CIL Label */ 
#line 158
    *nextTokPtr = ptr;
#line 159
    return (0);
    switch_break___1: /* CIL Label */ ;
    }
    case_10___0: /* CIL Label */ 
    case_9___0: /* CIL Label */ 
    case_21___0: /* CIL Label */ 
#line 163
    *nextTokPtr = ptr;
#line 164
    return (16);
    case_24___0: /* CIL Label */ 
    case_22___0: /* CIL Label */ 
#line 167
    ptr += 2;
#line 168
    goto switch_break___0;
    switch_default___0: /* CIL Label */ 
#line 170
    *nextTokPtr = ptr;
#line 171
    return (0);
    switch_break___0: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 174
  return (-1);
}
}
#line 177 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmltok_impl.c"
static int big2_checkPiTarget(ENCODING const   *enc , char const   *ptr , char const   *end ,
                              int *tokPtr ) 
{ 
  int upper ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 181
  upper = 0;
#line 182
  *tokPtr = 11;
#line 183
  if (end - ptr != 6L) {
#line 184
    return (1);
  }
#line 185
  if ((int const   )*(ptr + 0) == 0) {
#line 185
    tmp = (int const   )*(ptr + 1);
  } else {
#line 185
    tmp = (int const   )-1;
  }
  {
#line 186
  if (tmp == 120) {
#line 186
    goto case_120;
  }
#line 188
  if (tmp == 88) {
#line 188
    goto case_88;
  }
#line 191
  goto switch_default;
  case_120: /* CIL Label */ 
#line 187
  goto switch_break;
  case_88: /* CIL Label */ 
#line 189
  upper = 1;
#line 190
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 192
  return (1);
  switch_break: /* CIL Label */ ;
  }
#line 194
  ptr += 2;
#line 195
  if ((int const   )*(ptr + 0) == 0) {
#line 195
    tmp___0 = (int const   )*(ptr + 1);
  } else {
#line 195
    tmp___0 = (int const   )-1;
  }
  {
#line 196
  if (tmp___0 == 109) {
#line 196
    goto case_109;
  }
#line 198
  if (tmp___0 == 77) {
#line 198
    goto case_77;
  }
#line 201
  goto switch_default___0;
  case_109: /* CIL Label */ 
#line 197
  goto switch_break___0;
  case_77: /* CIL Label */ 
#line 199
  upper = 1;
#line 200
  goto switch_break___0;
  switch_default___0: /* CIL Label */ 
#line 202
  return (1);
  switch_break___0: /* CIL Label */ ;
  }
#line 204
  ptr += 2;
#line 205
  if ((int const   )*(ptr + 0) == 0) {
#line 205
    tmp___1 = (int const   )*(ptr + 1);
  } else {
#line 205
    tmp___1 = (int const   )-1;
  }
  {
#line 206
  if (tmp___1 == 108) {
#line 206
    goto case_108;
  }
#line 208
  if (tmp___1 == 76) {
#line 208
    goto case_76;
  }
#line 211
  goto switch_default___1;
  case_108: /* CIL Label */ 
#line 207
  goto switch_break___1;
  case_76: /* CIL Label */ 
#line 209
  upper = 1;
#line 210
  goto switch_break___1;
  switch_default___1: /* CIL Label */ 
#line 212
  return (1);
  switch_break___1: /* CIL Label */ ;
  }
#line 214
  if (upper) {
#line 215
    return (0);
  }
#line 216
  *tokPtr = 12;
#line 217
  return (1);
}
}
#line 222 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmltok_impl.c"
static int big2_scanPi(ENCODING const   *enc , char const   *ptr , char const   *end ,
                       char const   **nextTokPtr ) 
{ 
  int tok ;
  char const   *target ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
#line 227
  target = ptr;
#line 228
  if ((unsigned long )ptr == (unsigned long )end) {
#line 229
    return (-1);
  }
#line 230
  if ((int const   )*(ptr + 0) == 0) {
#line 230
    tmp___0 = (int )((struct normal_encoding *)enc)->type[(unsigned char )*(ptr + 1)];
  } else {
    {
#line 230
    tmp = unicode_byte_type((char )*(ptr + 0), (char )*(ptr + 1));
#line 230
    tmp___0 = tmp;
    }
  }
  {
#line 231
  if (tmp___0 == 29) {
#line 231
    goto case_29;
  }
#line 231
  if (tmp___0 == 24) {
#line 231
    goto case_24;
  }
#line 231
  if (tmp___0 == 22) {
#line 231
    goto case_24;
  }
#line 231
  if (tmp___0 == 5) {
#line 231
    goto case_5;
  }
#line 231
  if (tmp___0 == 6) {
#line 231
    goto case_6;
  }
#line 231
  if (tmp___0 == 7) {
#line 231
    goto case_7;
  }
#line 232
  goto switch_default;
  case_29: /* CIL Label */ 
#line 231
  if (! (namingBitmap[((int const   )nmstrtPages[(unsigned char )*(ptr + 0)] << 3) + (int const   )((int )((unsigned char )*(ptr + 1)) >> 5)] & (unsigned int const   )(1 << ((int )((unsigned char )*(ptr + 1)) & 31)))) {
#line 231
    *nextTokPtr = ptr;
#line 231
    return (0);
  }
  case_24: /* CIL Label */ 
  case_22: /* CIL Label */ 
#line 231
  ptr += 2;
#line 231
  goto switch_break;
  case_5: /* CIL Label */ 
#line 231
  if (end - ptr < 2L) {
#line 231
    return (-2);
  }
#line 231
  *nextTokPtr = ptr;
#line 231
  return (0);
#line 231
  ptr += 2;
#line 231
  goto switch_break;
  case_6: /* CIL Label */ 
#line 231
  if (end - ptr < 3L) {
#line 231
    return (-2);
  }
#line 231
  *nextTokPtr = ptr;
#line 231
  return (0);
#line 231
  ptr += 3;
#line 231
  goto switch_break;
  case_7: /* CIL Label */ 
#line 231
  if (end - ptr < 4L) {
#line 231
    return (-2);
  }
#line 231
  *nextTokPtr = ptr;
#line 231
  return (0);
#line 231
  ptr += 4;
#line 231
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 233
  *nextTokPtr = ptr;
#line 234
  return (0);
  switch_break: /* CIL Label */ ;
  }
  {
#line 236
  while (1) {
    while_continue: /* CIL Label */ ;
#line 236
    if (! ((unsigned long )ptr != (unsigned long )end)) {
#line 236
      goto while_break;
    }
#line 237
    if ((int const   )*(ptr + 0) == 0) {
#line 237
      tmp___2 = (int )((struct normal_encoding *)enc)->type[(unsigned char )*(ptr + 1)];
    } else {
      {
#line 237
      tmp___1 = unicode_byte_type((char )*(ptr + 0), (char )*(ptr + 1));
#line 237
      tmp___2 = tmp___1;
      }
    }
    {
#line 238
    if (tmp___2 == 29) {
#line 238
      goto case_29___0;
    }
#line 238
    if (tmp___2 == 27) {
#line 238
      goto case_27;
    }
#line 238
    if (tmp___2 == 26) {
#line 238
      goto case_27;
    }
#line 238
    if (tmp___2 == 25) {
#line 238
      goto case_27;
    }
#line 238
    if (tmp___2 == 24) {
#line 238
      goto case_27;
    }
#line 238
    if (tmp___2 == 22) {
#line 238
      goto case_27;
    }
#line 238
    if (tmp___2 == 5) {
#line 238
      goto case_5___0;
    }
#line 238
    if (tmp___2 == 6) {
#line 238
      goto case_6___0;
    }
#line 238
    if (tmp___2 == 7) {
#line 238
      goto case_7___0;
    }
#line 239
    if (tmp___2 == 10) {
#line 239
      goto case_10;
    }
#line 239
    if (tmp___2 == 9) {
#line 239
      goto case_10;
    }
#line 239
    if (tmp___2 == 21) {
#line 239
      goto case_10;
    }
#line 263
    if (tmp___2 == 15) {
#line 263
      goto case_15___0;
    }
#line 276
    goto switch_default___1;
    case_29___0: /* CIL Label */ 
#line 238
    if (! (namingBitmap[((int const   )namePages[(unsigned char )*(ptr + 0)] << 3) + (int const   )((int )((unsigned char )*(ptr + 1)) >> 5)] & (unsigned int const   )(1 << ((int )((unsigned char )*(ptr + 1)) & 31)))) {
#line 238
      *nextTokPtr = ptr;
#line 238
      return (0);
    }
    case_27: /* CIL Label */ 
    case_26: /* CIL Label */ 
    case_25: /* CIL Label */ 
    case_24___0: /* CIL Label */ 
    case_22___0: /* CIL Label */ 
#line 238
    ptr += 2;
#line 238
    goto switch_break___0;
    case_5___0: /* CIL Label */ 
#line 238
    if (end - ptr < 2L) {
#line 238
      return (-2);
    }
#line 238
    *nextTokPtr = ptr;
#line 238
    return (0);
#line 238
    ptr += 2;
#line 238
    goto switch_break___0;
    case_6___0: /* CIL Label */ 
#line 238
    if (end - ptr < 3L) {
#line 238
      return (-2);
    }
#line 238
    *nextTokPtr = ptr;
#line 238
    return (0);
#line 238
    ptr += 3;
#line 238
    goto switch_break___0;
    case_7___0: /* CIL Label */ 
#line 238
    if (end - ptr < 4L) {
#line 238
      return (-2);
    }
#line 238
    *nextTokPtr = ptr;
#line 238
    return (0);
#line 238
    ptr += 4;
#line 238
    goto switch_break___0;
    case_10: /* CIL Label */ 
    case_9: /* CIL Label */ 
    case_21: /* CIL Label */ 
    {
#line 240
    tmp___3 = big2_checkPiTarget(enc, target, ptr, & tok);
    }
#line 240
    if (! tmp___3) {
#line 241
      *nextTokPtr = ptr;
#line 242
      return (0);
    }
#line 244
    ptr += 2;
    {
#line 245
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 245
      if (! ((unsigned long )ptr != (unsigned long )end)) {
#line 245
        goto while_break___0;
      }
#line 246
      if ((int const   )*(ptr + 0) == 0) {
#line 246
        tmp___5 = (int )((struct normal_encoding *)enc)->type[(unsigned char )*(ptr + 1)];
      } else {
        {
#line 246
        tmp___4 = unicode_byte_type((char )*(ptr + 0), (char )*(ptr + 1));
#line 246
        tmp___5 = tmp___4;
        }
      }
      {
#line 247
      if (tmp___5 == 5) {
#line 247
        goto case_5___1;
      }
#line 247
      if (tmp___5 == 6) {
#line 247
        goto case_6___1;
      }
#line 247
      if (tmp___5 == 7) {
#line 247
        goto case_7___1;
      }
#line 247
      if (tmp___5 == 8) {
#line 247
        goto case_8;
      }
#line 247
      if (tmp___5 == 1) {
#line 247
        goto case_8;
      }
#line 247
      if (tmp___5 == 0) {
#line 247
        goto case_8;
      }
#line 248
      if (tmp___5 == 15) {
#line 248
        goto case_15;
      }
#line 257
      goto switch_default___0;
      case_5___1: /* CIL Label */ 
#line 247
      if (end - ptr < 2L) {
#line 247
        return (-2);
      }
#line 247
      ptr += 2;
#line 247
      goto switch_break___1;
      case_6___1: /* CIL Label */ 
#line 247
      if (end - ptr < 3L) {
#line 247
        return (-2);
      }
#line 247
      ptr += 3;
#line 247
      goto switch_break___1;
      case_7___1: /* CIL Label */ 
#line 247
      if (end - ptr < 4L) {
#line 247
        return (-2);
      }
#line 247
      ptr += 4;
#line 247
      goto switch_break___1;
      case_8: /* CIL Label */ 
      case_1: /* CIL Label */ 
      case_0: /* CIL Label */ 
#line 247
      *nextTokPtr = ptr;
#line 247
      return (0);
      case_15: /* CIL Label */ 
#line 249
      ptr += 2;
#line 250
      if ((unsigned long )ptr == (unsigned long )end) {
#line 251
        return (-1);
      }
#line 252
      if ((int const   )*(ptr + 0) == 0) {
#line 252
        if ((int const   )*(ptr + 1) == 62) {
#line 253
          *nextTokPtr = ptr + 2;
#line 254
          return (tok);
        }
      }
#line 256
      goto switch_break___1;
      switch_default___0: /* CIL Label */ 
#line 258
      ptr += 2;
#line 259
      goto switch_break___1;
      switch_break___1: /* CIL Label */ ;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 262
    return (-1);
    case_15___0: /* CIL Label */ 
    {
#line 264
    tmp___6 = big2_checkPiTarget(enc, target, ptr, & tok);
    }
#line 264
    if (! tmp___6) {
#line 265
      *nextTokPtr = ptr;
#line 266
      return (0);
    }
#line 268
    ptr += 2;
#line 269
    if ((unsigned long )ptr == (unsigned long )end) {
#line 270
      return (-1);
    }
#line 271
    if ((int const   )*(ptr + 0) == 0) {
#line 271
      if ((int const   )*(ptr + 1) == 62) {
#line 272
        *nextTokPtr = ptr + 2;
#line 273
        return (tok);
      }
    }
    switch_default___1: /* CIL Label */ 
#line 277
    *nextTokPtr = ptr;
#line 278
    return (0);
    switch_break___0: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 281
  return (-1);
}
}
#line 288
static int big2_scanCdataSection(ENCODING const   *enc , char const   *ptr , char const   *end ,
                                 char const   **nextTokPtr ) ;
#line 288 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmltok_impl.c"
static char const   CDATA_LSQB___1[6]  = {      (char const   )67,      (char const   )68,      (char const   )65,      (char const   )84, 
        (char const   )65,      (char const   )91};
#line 284 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmltok_impl.c"
static int big2_scanCdataSection(ENCODING const   *enc , char const   *ptr , char const   *end ,
                                 char const   **nextTokPtr ) 
{ 
  int i ;

  {
#line 292
  if (end - ptr < 12L) {
#line 293
    return (-1);
  }
#line 294
  i = 0;
  {
#line 294
  while (1) {
    while_continue: /* CIL Label */ ;
#line 294
    if (! (i < 6)) {
#line 294
      goto while_break;
    }
#line 295
    if ((int const   )*(ptr + 0) == 0) {
#line 295
      if (! ((int const   )*(ptr + 1) == (int const   )CDATA_LSQB___1[i])) {
#line 296
        *nextTokPtr = ptr;
#line 297
        return (0);
      }
    } else {
#line 296
      *nextTokPtr = ptr;
#line 297
      return (0);
    }
#line 294
    i ++;
#line 294
    ptr += 2;
  }
  while_break: /* CIL Label */ ;
  }
#line 300
  *nextTokPtr = ptr;
#line 301
  return (8);
}
}
#line 304 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmltok_impl.c"
static int big2_cdataSectionTok(ENCODING const   *enc , char const   *ptr , char const   *end ,
                                char const   **nextTokPtr ) 
{ 
  size_t n ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 308
  if ((unsigned long )ptr == (unsigned long )end) {
#line 309
    return (-4);
  }
#line 311
  n = (size_t )(end - ptr);
#line 312
  if (n & 1UL) {
#line 313
    n &= 0xfffffffffffffffeUL;
#line 314
    if (n == 0UL) {
#line 315
      return (-1);
    }
#line 316
    end = ptr + n;
  }
#line 319
  if ((int const   )*(ptr + 0) == 0) {
#line 319
    tmp___0 = (int )((struct normal_encoding *)enc)->type[(unsigned char )*(ptr + 1)];
  } else {
    {
#line 319
    tmp = unicode_byte_type((char )*(ptr + 0), (char )*(ptr + 1));
#line 319
    tmp___0 = tmp;
    }
  }
  {
#line 320
  if (tmp___0 == 4) {
#line 320
    goto case_4;
  }
#line 335
  if (tmp___0 == 9) {
#line 335
    goto case_9;
  }
#line 343
  if (tmp___0 == 10) {
#line 343
    goto case_10;
  }
#line 346
  if (tmp___0 == 5) {
#line 346
    goto case_5;
  }
#line 346
  if (tmp___0 == 6) {
#line 346
    goto case_6;
  }
#line 346
  if (tmp___0 == 7) {
#line 346
    goto case_7;
  }
#line 346
  if (tmp___0 == 8) {
#line 346
    goto case_8;
  }
#line 346
  if (tmp___0 == 1) {
#line 346
    goto case_8;
  }
#line 346
  if (tmp___0 == 0) {
#line 346
    goto case_8;
  }
#line 347
  goto switch_default;
  case_4: /* CIL Label */ 
#line 321
  ptr += 2;
#line 322
  if ((unsigned long )ptr == (unsigned long )end) {
#line 323
    return (-1);
  }
#line 324
  if ((int const   )*(ptr + 0) == 0) {
#line 324
    if (! ((int const   )*(ptr + 1) == 93)) {
#line 325
      goto switch_break;
    }
  } else {
#line 325
    goto switch_break;
  }
#line 326
  ptr += 2;
#line 327
  if ((unsigned long )ptr == (unsigned long )end) {
#line 328
    return (-1);
  }
#line 329
  if ((int const   )*(ptr + 0) == 0) {
#line 329
    if (! ((int const   )*(ptr + 1) == 62)) {
#line 330
      ptr -= 2;
#line 331
      goto switch_break;
    }
  } else {
#line 330
    ptr -= 2;
#line 331
    goto switch_break;
  }
#line 333
  *nextTokPtr = ptr + 2;
#line 334
  return (40);
  case_9: /* CIL Label */ 
#line 336
  ptr += 2;
#line 337
  if ((unsigned long )ptr == (unsigned long )end) {
#line 338
    return (-1);
  }
#line 339
  if ((int const   )*(ptr + 0) == 0) {
#line 339
    tmp___2 = (int )((struct normal_encoding *)enc)->type[(unsigned char )*(ptr + 1)];
  } else {
    {
#line 339
    tmp___1 = unicode_byte_type((char )*(ptr + 0), (char )*(ptr + 1));
#line 339
    tmp___2 = tmp___1;
    }
  }
#line 339
  if (tmp___2 == 10) {
#line 340
    ptr += 2;
  }
#line 341
  *nextTokPtr = ptr;
#line 342
  return (7);
  case_10: /* CIL Label */ 
#line 344
  *nextTokPtr = ptr + 2;
#line 345
  return (7);
  case_5: /* CIL Label */ 
#line 346
  if (end - ptr < 2L) {
#line 346
    return (-2);
  }
#line 346
  ptr += 2;
#line 346
  goto switch_break;
  case_6: /* CIL Label */ 
#line 346
  if (end - ptr < 3L) {
#line 346
    return (-2);
  }
#line 346
  ptr += 3;
#line 346
  goto switch_break;
  case_7: /* CIL Label */ 
#line 346
  if (end - ptr < 4L) {
#line 346
    return (-2);
  }
#line 346
  ptr += 4;
#line 346
  goto switch_break;
  case_8: /* CIL Label */ 
  case_1: /* CIL Label */ 
  case_0: /* CIL Label */ 
#line 346
  *nextTokPtr = ptr;
#line 346
  return (0);
  switch_default: /* CIL Label */ 
#line 348
  ptr += 2;
#line 349
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 351
  while (1) {
    while_continue: /* CIL Label */ ;
#line 351
    if (! ((unsigned long )ptr != (unsigned long )end)) {
#line 351
      goto while_break;
    }
#line 352
    if ((int const   )*(ptr + 0) == 0) {
#line 352
      tmp___4 = (int )((struct normal_encoding *)enc)->type[(unsigned char )*(ptr + 1)];
    } else {
      {
#line 352
      tmp___3 = unicode_byte_type((char )*(ptr + 0), (char )*(ptr + 1));
#line 352
      tmp___4 = tmp___3;
      }
    }
    {
#line 361
    if (tmp___4 == 5) {
#line 361
      goto case_5___0;
    }
#line 361
    if (tmp___4 == 6) {
#line 361
      goto case_6___0;
    }
#line 361
    if (tmp___4 == 7) {
#line 361
      goto case_7___0;
    }
#line 368
    if (tmp___4 == 4) {
#line 368
      goto case_4___0;
    }
#line 368
    if (tmp___4 == 10) {
#line 368
      goto case_4___0;
    }
#line 368
    if (tmp___4 == 9) {
#line 368
      goto case_4___0;
    }
#line 368
    if (tmp___4 == 8) {
#line 368
      goto case_4___0;
    }
#line 368
    if (tmp___4 == 1) {
#line 368
      goto case_4___0;
    }
#line 368
    if (tmp___4 == 0) {
#line 368
      goto case_4___0;
    }
#line 371
    goto switch_default___0;
    case_5___0: /* CIL Label */ 
#line 361
    if (end - ptr < 2L) {
#line 361
      *nextTokPtr = ptr;
#line 361
      return (6);
    }
#line 361
    ptr += 2;
#line 361
    goto switch_break___0;
    case_6___0: /* CIL Label */ 
#line 361
    if (end - ptr < 3L) {
#line 361
      *nextTokPtr = ptr;
#line 361
      return (6);
    }
#line 361
    ptr += 3;
#line 361
    goto switch_break___0;
    case_7___0: /* CIL Label */ 
#line 361
    if (end - ptr < 4L) {
#line 361
      *nextTokPtr = ptr;
#line 361
      return (6);
    }
#line 361
    ptr += 4;
#line 361
    goto switch_break___0;
    case_4___0: /* CIL Label */ 
    case_10___0: /* CIL Label */ 
    case_9___0: /* CIL Label */ 
    case_8___0: /* CIL Label */ 
    case_1___0: /* CIL Label */ 
    case_0___0: /* CIL Label */ 
#line 369
    *nextTokPtr = ptr;
#line 370
    return (6);
    switch_default___0: /* CIL Label */ 
#line 372
    ptr += 2;
#line 373
    goto switch_break___0;
    switch_break___0: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 376
  *nextTokPtr = ptr;
#line 377
  return (6);
}
}
#line 382 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmltok_impl.c"
static int big2_scanEndTag(ENCODING const   *enc , char const   *ptr , char const   *end ,
                           char const   **nextTokPtr ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 386
  if ((unsigned long )ptr == (unsigned long )end) {
#line 387
    return (-1);
  }
#line 388
  if ((int const   )*(ptr + 0) == 0) {
#line 388
    tmp___0 = (int )((struct normal_encoding *)enc)->type[(unsigned char )*(ptr + 1)];
  } else {
    {
#line 388
    tmp = unicode_byte_type((char )*(ptr + 0), (char )*(ptr + 1));
#line 388
    tmp___0 = tmp;
    }
  }
  {
#line 389
  if (tmp___0 == 29) {
#line 389
    goto case_29;
  }
#line 389
  if (tmp___0 == 24) {
#line 389
    goto case_24;
  }
#line 389
  if (tmp___0 == 22) {
#line 389
    goto case_24;
  }
#line 389
  if (tmp___0 == 5) {
#line 389
    goto case_5;
  }
#line 389
  if (tmp___0 == 6) {
#line 389
    goto case_6;
  }
#line 389
  if (tmp___0 == 7) {
#line 389
    goto case_7;
  }
#line 390
  goto switch_default;
  case_29: /* CIL Label */ 
#line 389
  if (! (namingBitmap[((int const   )nmstrtPages[(unsigned char )*(ptr + 0)] << 3) + (int const   )((int )((unsigned char )*(ptr + 1)) >> 5)] & (unsigned int const   )(1 << ((int )((unsigned char )*(ptr + 1)) & 31)))) {
#line 389
    *nextTokPtr = ptr;
#line 389
    return (0);
  }
  case_24: /* CIL Label */ 
  case_22: /* CIL Label */ 
#line 389
  ptr += 2;
#line 389
  goto switch_break;
  case_5: /* CIL Label */ 
#line 389
  if (end - ptr < 2L) {
#line 389
    return (-2);
  }
#line 389
  *nextTokPtr = ptr;
#line 389
  return (0);
#line 389
  ptr += 2;
#line 389
  goto switch_break;
  case_6: /* CIL Label */ 
#line 389
  if (end - ptr < 3L) {
#line 389
    return (-2);
  }
#line 389
  *nextTokPtr = ptr;
#line 389
  return (0);
#line 389
  ptr += 3;
#line 389
  goto switch_break;
  case_7: /* CIL Label */ 
#line 389
  if (end - ptr < 4L) {
#line 389
    return (-2);
  }
#line 389
  *nextTokPtr = ptr;
#line 389
  return (0);
#line 389
  ptr += 4;
#line 389
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 391
  *nextTokPtr = ptr;
#line 392
  return (0);
  switch_break: /* CIL Label */ ;
  }
  {
#line 394
  while (1) {
    while_continue: /* CIL Label */ ;
#line 394
    if (! ((unsigned long )ptr != (unsigned long )end)) {
#line 394
      goto while_break;
    }
#line 395
    if ((int const   )*(ptr + 0) == 0) {
#line 395
      tmp___2 = (int )((struct normal_encoding *)enc)->type[(unsigned char )*(ptr + 1)];
    } else {
      {
#line 395
      tmp___1 = unicode_byte_type((char )*(ptr + 0), (char )*(ptr + 1));
#line 395
      tmp___2 = tmp___1;
      }
    }
    {
#line 396
    if (tmp___2 == 29) {
#line 396
      goto case_29___0;
    }
#line 396
    if (tmp___2 == 27) {
#line 396
      goto case_27;
    }
#line 396
    if (tmp___2 == 26) {
#line 396
      goto case_27;
    }
#line 396
    if (tmp___2 == 25) {
#line 396
      goto case_27;
    }
#line 396
    if (tmp___2 == 24) {
#line 396
      goto case_27;
    }
#line 396
    if (tmp___2 == 22) {
#line 396
      goto case_27;
    }
#line 396
    if (tmp___2 == 5) {
#line 396
      goto case_5___0;
    }
#line 396
    if (tmp___2 == 6) {
#line 396
      goto case_6___0;
    }
#line 396
    if (tmp___2 == 7) {
#line 396
      goto case_7___0;
    }
#line 397
    if (tmp___2 == 10) {
#line 397
      goto case_10;
    }
#line 397
    if (tmp___2 == 9) {
#line 397
      goto case_10;
    }
#line 397
    if (tmp___2 == 21) {
#line 397
      goto case_10;
    }
#line 412
    if (tmp___2 == 23) {
#line 412
      goto case_23;
    }
#line 418
    if (tmp___2 == 11) {
#line 418
      goto case_11___0;
    }
#line 421
    goto switch_default___1;
    case_29___0: /* CIL Label */ 
#line 396
    if (! (namingBitmap[((int const   )namePages[(unsigned char )*(ptr + 0)] << 3) + (int const   )((int )((unsigned char )*(ptr + 1)) >> 5)] & (unsigned int const   )(1 << ((int )((unsigned char )*(ptr + 1)) & 31)))) {
#line 396
      *nextTokPtr = ptr;
#line 396
      return (0);
    }
    case_27: /* CIL Label */ 
    case_26: /* CIL Label */ 
    case_25: /* CIL Label */ 
    case_24___0: /* CIL Label */ 
    case_22___0: /* CIL Label */ 
#line 396
    ptr += 2;
#line 396
    goto switch_break___0;
    case_5___0: /* CIL Label */ 
#line 396
    if (end - ptr < 2L) {
#line 396
      return (-2);
    }
#line 396
    *nextTokPtr = ptr;
#line 396
    return (0);
#line 396
    ptr += 2;
#line 396
    goto switch_break___0;
    case_6___0: /* CIL Label */ 
#line 396
    if (end - ptr < 3L) {
#line 396
      return (-2);
    }
#line 396
    *nextTokPtr = ptr;
#line 396
    return (0);
#line 396
    ptr += 3;
#line 396
    goto switch_break___0;
    case_7___0: /* CIL Label */ 
#line 396
    if (end - ptr < 4L) {
#line 396
      return (-2);
    }
#line 396
    *nextTokPtr = ptr;
#line 396
    return (0);
#line 396
    ptr += 4;
#line 396
    goto switch_break___0;
    case_10: /* CIL Label */ 
    case_9: /* CIL Label */ 
    case_21: /* CIL Label */ 
#line 398
    ptr += 2;
    {
#line 398
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 398
      if (! ((unsigned long )ptr != (unsigned long )end)) {
#line 398
        goto while_break___0;
      }
#line 399
      if ((int const   )*(ptr + 0) == 0) {
#line 399
        tmp___4 = (int )((struct normal_encoding *)enc)->type[(unsigned char )*(ptr + 1)];
      } else {
        {
#line 399
        tmp___3 = unicode_byte_type((char )*(ptr + 0), (char )*(ptr + 1));
#line 399
        tmp___4 = tmp___3;
        }
      }
      {
#line 400
      if (tmp___4 == 10) {
#line 400
        goto case_10___0;
      }
#line 400
      if (tmp___4 == 9) {
#line 400
        goto case_10___0;
      }
#line 400
      if (tmp___4 == 21) {
#line 400
        goto case_10___0;
      }
#line 402
      if (tmp___4 == 11) {
#line 402
        goto case_11;
      }
#line 405
      goto switch_default___0;
      case_10___0: /* CIL Label */ 
      case_9___0: /* CIL Label */ 
      case_21___0: /* CIL Label */ 
#line 401
      goto switch_break___1;
      case_11: /* CIL Label */ 
#line 403
      *nextTokPtr = ptr + 2;
#line 404
      return (5);
      switch_default___0: /* CIL Label */ 
#line 406
      *nextTokPtr = ptr;
#line 407
      return (0);
      switch_break___1: /* CIL Label */ ;
      }
#line 398
      ptr += 2;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 410
    return (-1);
    case_23: /* CIL Label */ 
#line 415
    ptr += 2;
#line 416
    goto switch_break___0;
    case_11___0: /* CIL Label */ 
#line 419
    *nextTokPtr = ptr + 2;
#line 420
    return (5);
    switch_default___1: /* CIL Label */ 
#line 422
    *nextTokPtr = ptr;
#line 423
    return (0);
    switch_break___0: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 426
  return (-1);
}
}
#line 431 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmltok_impl.c"
static int big2_scanHexCharRef(ENCODING const   *enc , char const   *ptr , char const   *end ,
                               char const   **nextTokPtr ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 435
  if ((unsigned long )ptr != (unsigned long )end) {
#line 436
    if ((int const   )*(ptr + 0) == 0) {
#line 436
      tmp___0 = (int )((struct normal_encoding *)enc)->type[(unsigned char )*(ptr + 1)];
    } else {
      {
#line 436
      tmp = unicode_byte_type((char )*(ptr + 0), (char )*(ptr + 1));
#line 436
      tmp___0 = tmp;
      }
    }
    {
#line 438
    if (tmp___0 == 24) {
#line 438
      goto case_24;
    }
#line 438
    if (tmp___0 == 25) {
#line 438
      goto case_24;
    }
#line 440
    goto switch_default;
    case_24: /* CIL Label */ 
    case_25: /* CIL Label */ 
#line 439
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 441
    *nextTokPtr = ptr;
#line 442
    return (0);
    switch_break: /* CIL Label */ ;
    }
#line 444
    ptr += 2;
    {
#line 444
    while (1) {
      while_continue: /* CIL Label */ ;
#line 444
      if (! ((unsigned long )ptr != (unsigned long )end)) {
#line 444
        goto while_break;
      }
#line 445
      if ((int const   )*(ptr + 0) == 0) {
#line 445
        tmp___2 = (int )((struct normal_encoding *)enc)->type[(unsigned char )*(ptr + 1)];
      } else {
        {
#line 445
        tmp___1 = unicode_byte_type((char )*(ptr + 0), (char )*(ptr + 1));
#line 445
        tmp___2 = tmp___1;
        }
      }
      {
#line 447
      if (tmp___2 == 24) {
#line 447
        goto case_24___0;
      }
#line 447
      if (tmp___2 == 25) {
#line 447
        goto case_24___0;
      }
#line 449
      if (tmp___2 == 18) {
#line 449
        goto case_18;
      }
#line 452
      goto switch_default___0;
      case_24___0: /* CIL Label */ 
      case_25___0: /* CIL Label */ 
#line 448
      goto switch_break___0;
      case_18: /* CIL Label */ 
#line 450
      *nextTokPtr = ptr + 2;
#line 451
      return (10);
      switch_default___0: /* CIL Label */ 
#line 453
      *nextTokPtr = ptr;
#line 454
      return (0);
      switch_break___0: /* CIL Label */ ;
      }
#line 444
      ptr += 2;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 458
  return (-1);
}
}
#line 463 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmltok_impl.c"
static int big2_scanCharRef(ENCODING const   *enc , char const   *ptr , char const   *end ,
                            char const   **nextTokPtr ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 467
  if ((unsigned long )ptr != (unsigned long )end) {
#line 468
    if ((int const   )*(ptr + 0) == 0) {
#line 468
      if ((int const   )*(ptr + 1) == 120) {
        {
#line 469
        tmp = big2_scanHexCharRef(enc, ptr + 2, end, nextTokPtr);
        }
#line 469
        return (tmp);
      }
    }
#line 470
    if ((int const   )*(ptr + 0) == 0) {
#line 470
      tmp___1 = (int )((struct normal_encoding *)enc)->type[(unsigned char )*(ptr + 1)];
    } else {
      {
#line 470
      tmp___0 = unicode_byte_type((char )*(ptr + 0), (char )*(ptr + 1));
#line 470
      tmp___1 = tmp___0;
      }
    }
    {
#line 471
    if (tmp___1 == 25) {
#line 471
      goto case_25;
    }
#line 473
    goto switch_default;
    case_25: /* CIL Label */ 
#line 472
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 474
    *nextTokPtr = ptr;
#line 475
    return (0);
    switch_break: /* CIL Label */ ;
    }
#line 477
    ptr += 2;
    {
#line 477
    while (1) {
      while_continue: /* CIL Label */ ;
#line 477
      if (! ((unsigned long )ptr != (unsigned long )end)) {
#line 477
        goto while_break;
      }
#line 478
      if ((int const   )*(ptr + 0) == 0) {
#line 478
        tmp___3 = (int )((struct normal_encoding *)enc)->type[(unsigned char )*(ptr + 1)];
      } else {
        {
#line 478
        tmp___2 = unicode_byte_type((char )*(ptr + 0), (char )*(ptr + 1));
#line 478
        tmp___3 = tmp___2;
        }
      }
      {
#line 479
      if (tmp___3 == 25) {
#line 479
        goto case_25___0;
      }
#line 481
      if (tmp___3 == 18) {
#line 481
        goto case_18;
      }
#line 484
      goto switch_default___0;
      case_25___0: /* CIL Label */ 
#line 480
      goto switch_break___0;
      case_18: /* CIL Label */ 
#line 482
      *nextTokPtr = ptr + 2;
#line 483
      return (10);
      switch_default___0: /* CIL Label */ 
#line 485
      *nextTokPtr = ptr;
#line 486
      return (0);
      switch_break___0: /* CIL Label */ ;
      }
#line 477
      ptr += 2;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 490
  return (-1);
}
}
#line 495 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmltok_impl.c"
static int big2_scanRef(ENCODING const   *enc , char const   *ptr , char const   *end ,
                        char const   **nextTokPtr ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 499
  if ((unsigned long )ptr == (unsigned long )end) {
#line 500
    return (-1);
  }
#line 501
  if ((int const   )*(ptr + 0) == 0) {
#line 501
    tmp___0 = (int )((struct normal_encoding *)enc)->type[(unsigned char )*(ptr + 1)];
  } else {
    {
#line 501
    tmp = unicode_byte_type((char )*(ptr + 0), (char )*(ptr + 1));
#line 501
    tmp___0 = tmp;
    }
  }
  {
#line 502
  if (tmp___0 == 29) {
#line 502
    goto case_29;
  }
#line 502
  if (tmp___0 == 24) {
#line 502
    goto case_24;
  }
#line 502
  if (tmp___0 == 22) {
#line 502
    goto case_24;
  }
#line 502
  if (tmp___0 == 5) {
#line 502
    goto case_5;
  }
#line 502
  if (tmp___0 == 6) {
#line 502
    goto case_6;
  }
#line 502
  if (tmp___0 == 7) {
#line 502
    goto case_7;
  }
#line 503
  if (tmp___0 == 19) {
#line 503
    goto case_19;
  }
#line 505
  goto switch_default;
  case_29: /* CIL Label */ 
#line 502
  if (! (namingBitmap[((int const   )nmstrtPages[(unsigned char )*(ptr + 0)] << 3) + (int const   )((int )((unsigned char )*(ptr + 1)) >> 5)] & (unsigned int const   )(1 << ((int )((unsigned char )*(ptr + 1)) & 31)))) {
#line 502
    *nextTokPtr = ptr;
#line 502
    return (0);
  }
  case_24: /* CIL Label */ 
  case_22: /* CIL Label */ 
#line 502
  ptr += 2;
#line 502
  goto switch_break;
  case_5: /* CIL Label */ 
#line 502
  if (end - ptr < 2L) {
#line 502
    return (-2);
  }
#line 502
  *nextTokPtr = ptr;
#line 502
  return (0);
#line 502
  ptr += 2;
#line 502
  goto switch_break;
  case_6: /* CIL Label */ 
#line 502
  if (end - ptr < 3L) {
#line 502
    return (-2);
  }
#line 502
  *nextTokPtr = ptr;
#line 502
  return (0);
#line 502
  ptr += 3;
#line 502
  goto switch_break;
  case_7: /* CIL Label */ 
#line 502
  if (end - ptr < 4L) {
#line 502
    return (-2);
  }
#line 502
  *nextTokPtr = ptr;
#line 502
  return (0);
#line 502
  ptr += 4;
#line 502
  goto switch_break;
  case_19: /* CIL Label */ 
  {
#line 504
  tmp___1 = big2_scanCharRef(enc, ptr + 2, end, nextTokPtr);
  }
#line 504
  return (tmp___1);
  switch_default: /* CIL Label */ 
#line 506
  *nextTokPtr = ptr;
#line 507
  return (0);
  switch_break: /* CIL Label */ ;
  }
  {
#line 509
  while (1) {
    while_continue: /* CIL Label */ ;
#line 509
    if (! ((unsigned long )ptr != (unsigned long )end)) {
#line 509
      goto while_break;
    }
#line 510
    if ((int const   )*(ptr + 0) == 0) {
#line 510
      tmp___3 = (int )((struct normal_encoding *)enc)->type[(unsigned char )*(ptr + 1)];
    } else {
      {
#line 510
      tmp___2 = unicode_byte_type((char )*(ptr + 0), (char )*(ptr + 1));
#line 510
      tmp___3 = tmp___2;
      }
    }
    {
#line 511
    if (tmp___3 == 29) {
#line 511
      goto case_29___0;
    }
#line 511
    if (tmp___3 == 27) {
#line 511
      goto case_27;
    }
#line 511
    if (tmp___3 == 26) {
#line 511
      goto case_27;
    }
#line 511
    if (tmp___3 == 25) {
#line 511
      goto case_27;
    }
#line 511
    if (tmp___3 == 24) {
#line 511
      goto case_27;
    }
#line 511
    if (tmp___3 == 22) {
#line 511
      goto case_27;
    }
#line 511
    if (tmp___3 == 5) {
#line 511
      goto case_5___0;
    }
#line 511
    if (tmp___3 == 6) {
#line 511
      goto case_6___0;
    }
#line 511
    if (tmp___3 == 7) {
#line 511
      goto case_7___0;
    }
#line 512
    if (tmp___3 == 18) {
#line 512
      goto case_18;
    }
#line 515
    goto switch_default___0;
    case_29___0: /* CIL Label */ 
#line 511
    if (! (namingBitmap[((int const   )namePages[(unsigned char )*(ptr + 0)] << 3) + (int const   )((int )((unsigned char )*(ptr + 1)) >> 5)] & (unsigned int const   )(1 << ((int )((unsigned char )*(ptr + 1)) & 31)))) {
#line 511
      *nextTokPtr = ptr;
#line 511
      return (0);
    }
    case_27: /* CIL Label */ 
    case_26: /* CIL Label */ 
    case_25: /* CIL Label */ 
    case_24___0: /* CIL Label */ 
    case_22___0: /* CIL Label */ 
#line 511
    ptr += 2;
#line 511
    goto switch_break___0;
    case_5___0: /* CIL Label */ 
#line 511
    if (end - ptr < 2L) {
#line 511
      return (-2);
    }
#line 511
    *nextTokPtr = ptr;
#line 511
    return (0);
#line 511
    ptr += 2;
#line 511
    goto switch_break___0;
    case_6___0: /* CIL Label */ 
#line 511
    if (end - ptr < 3L) {
#line 511
      return (-2);
    }
#line 511
    *nextTokPtr = ptr;
#line 511
    return (0);
#line 511
    ptr += 3;
#line 511
    goto switch_break___0;
    case_7___0: /* CIL Label */ 
#line 511
    if (end - ptr < 4L) {
#line 511
      return (-2);
    }
#line 511
    *nextTokPtr = ptr;
#line 511
    return (0);
#line 511
    ptr += 4;
#line 511
    goto switch_break___0;
    case_18: /* CIL Label */ 
#line 513
    *nextTokPtr = ptr + 2;
#line 514
    return (9);
    switch_default___0: /* CIL Label */ 
#line 516
    *nextTokPtr = ptr;
#line 517
    return (0);
    switch_break___0: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 520
  return (-1);
}
}
#line 525 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmltok_impl.c"
static int big2_scanAtts(ENCODING const   *enc , char const   *ptr , char const   *end ,
                         char const   **nextTokPtr ) 
{ 
  int hadColon ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int t ;
  int tmp___3 ;
  int open___0 ;
  int tmp___4 ;
  int t___0 ;
  int tmp___5 ;
  int tok ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;

  {
#line 530
  hadColon = 0;
  {
#line 532
  while (1) {
    while_continue: /* CIL Label */ ;
#line 532
    if (! ((unsigned long )ptr != (unsigned long )end)) {
#line 532
      goto while_break;
    }
#line 533
    if ((int const   )*(ptr + 0) == 0) {
#line 533
      tmp___0 = (int )((struct normal_encoding *)enc)->type[(unsigned char )*(ptr + 1)];
    } else {
      {
#line 533
      tmp = unicode_byte_type((char )*(ptr + 0), (char )*(ptr + 1));
#line 533
      tmp___0 = tmp;
      }
    }
    {
#line 534
    if (tmp___0 == 29) {
#line 534
      goto case_29;
    }
#line 534
    if (tmp___0 == 27) {
#line 534
      goto case_27;
    }
#line 534
    if (tmp___0 == 26) {
#line 534
      goto case_27;
    }
#line 534
    if (tmp___0 == 25) {
#line 534
      goto case_27;
    }
#line 534
    if (tmp___0 == 24) {
#line 534
      goto case_27;
    }
#line 534
    if (tmp___0 == 22) {
#line 534
      goto case_27;
    }
#line 534
    if (tmp___0 == 5) {
#line 534
      goto case_5;
    }
#line 534
    if (tmp___0 == 6) {
#line 534
      goto case_6;
    }
#line 534
    if (tmp___0 == 7) {
#line 534
      goto case_7;
    }
#line 536
    if (tmp___0 == 23) {
#line 536
      goto case_23;
    }
#line 553
    if (tmp___0 == 10) {
#line 553
      goto case_10;
    }
#line 553
    if (tmp___0 == 9) {
#line 553
      goto case_10;
    }
#line 553
    if (tmp___0 == 21) {
#line 553
      goto case_10;
    }
#line 574
    if (tmp___0 == 14) {
#line 574
      goto case_14;
    }
#line 674
    goto switch_default___5;
    case_29: /* CIL Label */ 
#line 534
    if (! (namingBitmap[((int const   )namePages[(unsigned char )*(ptr + 0)] << 3) + (int const   )((int )((unsigned char )*(ptr + 1)) >> 5)] & (unsigned int const   )(1 << ((int )((unsigned char )*(ptr + 1)) & 31)))) {
#line 534
      *nextTokPtr = ptr;
#line 534
      return (0);
    }
    case_27: /* CIL Label */ 
    case_26: /* CIL Label */ 
    case_25: /* CIL Label */ 
    case_24: /* CIL Label */ 
    case_22: /* CIL Label */ 
#line 534
    ptr += 2;
#line 534
    goto switch_break;
    case_5: /* CIL Label */ 
#line 534
    if (end - ptr < 2L) {
#line 534
      return (-2);
    }
#line 534
    *nextTokPtr = ptr;
#line 534
    return (0);
#line 534
    ptr += 2;
#line 534
    goto switch_break;
    case_6: /* CIL Label */ 
#line 534
    if (end - ptr < 3L) {
#line 534
      return (-2);
    }
#line 534
    *nextTokPtr = ptr;
#line 534
    return (0);
#line 534
    ptr += 3;
#line 534
    goto switch_break;
    case_7: /* CIL Label */ 
#line 534
    if (end - ptr < 4L) {
#line 534
      return (-2);
    }
#line 534
    *nextTokPtr = ptr;
#line 534
    return (0);
#line 534
    ptr += 4;
#line 534
    goto switch_break;
    case_23: /* CIL Label */ 
#line 537
    if (hadColon) {
#line 538
      *nextTokPtr = ptr;
#line 539
      return (0);
    }
#line 541
    hadColon = 1;
#line 542
    ptr += 2;
#line 543
    if ((unsigned long )ptr == (unsigned long )end) {
#line 544
      return (-1);
    }
#line 545
    if ((int const   )*(ptr + 0) == 0) {
#line 545
      tmp___2 = (int )((struct normal_encoding *)enc)->type[(unsigned char )*(ptr + 1)];
    } else {
      {
#line 545
      tmp___1 = unicode_byte_type((char )*(ptr + 0), (char )*(ptr + 1));
#line 545
      tmp___2 = tmp___1;
      }
    }
    {
#line 546
    if (tmp___2 == 29) {
#line 546
      goto case_29___0;
    }
#line 546
    if (tmp___2 == 24) {
#line 546
      goto case_24___0;
    }
#line 546
    if (tmp___2 == 22) {
#line 546
      goto case_24___0;
    }
#line 546
    if (tmp___2 == 5) {
#line 546
      goto case_5___0;
    }
#line 546
    if (tmp___2 == 6) {
#line 546
      goto case_6___0;
    }
#line 546
    if (tmp___2 == 7) {
#line 546
      goto case_7___0;
    }
#line 547
    goto switch_default;
    case_29___0: /* CIL Label */ 
#line 546
    if (! (namingBitmap[((int const   )nmstrtPages[(unsigned char )*(ptr + 0)] << 3) + (int const   )((int )((unsigned char )*(ptr + 1)) >> 5)] & (unsigned int const   )(1 << ((int )((unsigned char )*(ptr + 1)) & 31)))) {
#line 546
      *nextTokPtr = ptr;
#line 546
      return (0);
    }
    case_24___0: /* CIL Label */ 
    case_22___0: /* CIL Label */ 
#line 546
    ptr += 2;
#line 546
    goto switch_break___0;
    case_5___0: /* CIL Label */ 
#line 546
    if (end - ptr < 2L) {
#line 546
      return (-2);
    }
#line 546
    *nextTokPtr = ptr;
#line 546
    return (0);
#line 546
    ptr += 2;
#line 546
    goto switch_break___0;
    case_6___0: /* CIL Label */ 
#line 546
    if (end - ptr < 3L) {
#line 546
      return (-2);
    }
#line 546
    *nextTokPtr = ptr;
#line 546
    return (0);
#line 546
    ptr += 3;
#line 546
    goto switch_break___0;
    case_7___0: /* CIL Label */ 
#line 546
    if (end - ptr < 4L) {
#line 546
      return (-2);
    }
#line 546
    *nextTokPtr = ptr;
#line 546
    return (0);
#line 546
    ptr += 4;
#line 546
    goto switch_break___0;
    switch_default: /* CIL Label */ 
#line 548
    *nextTokPtr = ptr;
#line 549
    return (0);
    switch_break___0: /* CIL Label */ ;
    }
#line 551
    goto switch_break;
    case_10: /* CIL Label */ 
    case_9: /* CIL Label */ 
    case_21: /* CIL Label */ 
    {
#line 554
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 557
      ptr += 2;
#line 558
      if ((unsigned long )ptr == (unsigned long )end) {
#line 559
        return (-1);
      }
#line 560
      if ((int const   )*(ptr + 0) == 0) {
#line 560
        t = (int )((struct normal_encoding *)enc)->type[(unsigned char )*(ptr + 1)];
      } else {
        {
#line 560
        tmp___3 = unicode_byte_type((char )*(ptr + 0), (char )*(ptr + 1));
#line 560
        t = tmp___3;
        }
      }
#line 561
      if (t == 14) {
#line 562
        goto while_break___0;
      }
      {
#line 566
      if (t == 9) {
#line 566
        goto case_9___0;
      }
#line 566
      if (t == 10) {
#line 566
        goto case_9___0;
      }
#line 566
      if (t == 21) {
#line 566
        goto case_9___0;
      }
#line 568
      goto switch_default___0;
      case_9___0: /* CIL Label */ 
      case_10___0: /* CIL Label */ 
      case_21___0: /* CIL Label */ 
#line 567
      goto switch_break___1;
      switch_default___0: /* CIL Label */ 
#line 569
      *nextTokPtr = ptr;
#line 570
      return (0);
      switch_break___1: /* CIL Label */ ;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    case_14: /* CIL Label */ 
#line 578
    hadColon = 0;
    {
#line 580
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 581
      ptr += 2;
#line 582
      if ((unsigned long )ptr == (unsigned long )end) {
#line 583
        return (-1);
      }
#line 584
      if ((int const   )*(ptr + 0) == 0) {
#line 584
        open___0 = (int )((struct normal_encoding *)enc)->type[(unsigned char )*(ptr + 1)];
      } else {
        {
#line 584
        tmp___4 = unicode_byte_type((char )*(ptr + 0), (char )*(ptr + 1));
#line 584
        open___0 = tmp___4;
        }
      }
#line 585
      if (open___0 == 12) {
#line 586
        goto while_break___1;
      } else
#line 585
      if (open___0 == 13) {
#line 586
        goto while_break___1;
      }
      {
#line 590
      if (open___0 == 9) {
#line 590
        goto case_9___1;
      }
#line 590
      if (open___0 == 10) {
#line 590
        goto case_9___1;
      }
#line 590
      if (open___0 == 21) {
#line 590
        goto case_9___1;
      }
#line 592
      goto switch_default___1;
      case_9___1: /* CIL Label */ 
      case_10___1: /* CIL Label */ 
      case_21___1: /* CIL Label */ 
#line 591
      goto switch_break___2;
      switch_default___1: /* CIL Label */ 
#line 593
      *nextTokPtr = ptr;
#line 594
      return (0);
      switch_break___2: /* CIL Label */ ;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
#line 597
    ptr += 2;
    {
#line 599
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 601
      if ((unsigned long )ptr == (unsigned long )end) {
#line 602
        return (-1);
      }
#line 603
      if ((int const   )*(ptr + 0) == 0) {
#line 603
        t___0 = (int )((struct normal_encoding *)enc)->type[(unsigned char )*(ptr + 1)];
      } else {
        {
#line 603
        tmp___5 = unicode_byte_type((char )*(ptr + 0), (char )*(ptr + 1));
#line 603
        t___0 = tmp___5;
        }
      }
#line 604
      if (t___0 == open___0) {
#line 605
        goto while_break___2;
      }
      {
#line 607
      if (t___0 == 5) {
#line 607
        goto case_5___1;
      }
#line 607
      if (t___0 == 6) {
#line 607
        goto case_6___1;
      }
#line 607
      if (t___0 == 7) {
#line 607
        goto case_7___1;
      }
#line 607
      if (t___0 == 8) {
#line 607
        goto case_8;
      }
#line 607
      if (t___0 == 1) {
#line 607
        goto case_8;
      }
#line 607
      if (t___0 == 0) {
#line 607
        goto case_8;
      }
#line 608
      if (t___0 == 3) {
#line 608
        goto case_3;
      }
#line 618
      if (t___0 == 2) {
#line 618
        goto case_2;
      }
#line 621
      goto switch_default___2;
      case_5___1: /* CIL Label */ 
#line 607
      if (end - ptr < 2L) {
#line 607
        return (-2);
      }
#line 607
      ptr += 2;
#line 607
      goto switch_break___3;
      case_6___1: /* CIL Label */ 
#line 607
      if (end - ptr < 3L) {
#line 607
        return (-2);
      }
#line 607
      ptr += 3;
#line 607
      goto switch_break___3;
      case_7___1: /* CIL Label */ 
#line 607
      if (end - ptr < 4L) {
#line 607
        return (-2);
      }
#line 607
      ptr += 4;
#line 607
      goto switch_break___3;
      case_8: /* CIL Label */ 
      case_1: /* CIL Label */ 
      case_0: /* CIL Label */ 
#line 607
      *nextTokPtr = ptr;
#line 607
      return (0);
      case_3: /* CIL Label */ 
      {
#line 610
      tmp___6 = big2_scanRef(enc, ptr + 2, end, & ptr);
#line 610
      tok = tmp___6;
      }
#line 611
      if (tok <= 0) {
#line 612
        if (tok == 0) {
#line 613
          *nextTokPtr = ptr;
        }
#line 614
        return (tok);
      }
#line 616
      goto switch_break___3;
      case_2: /* CIL Label */ 
#line 619
      *nextTokPtr = ptr;
#line 620
      return (0);
      switch_default___2: /* CIL Label */ 
#line 622
      ptr += 2;
#line 623
      goto switch_break___3;
      switch_break___3: /* CIL Label */ ;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
#line 626
    ptr += 2;
#line 627
    if ((unsigned long )ptr == (unsigned long )end) {
#line 628
      return (-1);
    }
#line 629
    if ((int const   )*(ptr + 0) == 0) {
#line 629
      tmp___8 = (int )((struct normal_encoding *)enc)->type[(unsigned char )*(ptr + 1)];
    } else {
      {
#line 629
      tmp___7 = unicode_byte_type((char )*(ptr + 0), (char )*(ptr + 1));
#line 629
      tmp___8 = tmp___7;
      }
    }
    {
#line 632
    if (tmp___8 == 10) {
#line 632
      goto case_10___2;
    }
#line 632
    if (tmp___8 == 9) {
#line 632
      goto case_10___2;
    }
#line 632
    if (tmp___8 == 21) {
#line 632
      goto case_10___2;
    }
#line 634
    if (tmp___8 == 17) {
#line 634
      goto case_17;
    }
#line 636
    if (tmp___8 == 11) {
#line 636
      goto case_11;
    }
#line 638
    goto switch_default___3;
    case_10___2: /* CIL Label */ 
    case_9___2: /* CIL Label */ 
    case_21___2: /* CIL Label */ 
#line 633
    goto switch_break___4;
    case_17: /* CIL Label */ 
#line 635
    goto sol;
    case_11: /* CIL Label */ 
#line 637
    goto gt;
    switch_default___3: /* CIL Label */ 
#line 639
    *nextTokPtr = ptr;
#line 640
    return (0);
    switch_break___4: /* CIL Label */ ;
    }
    {
#line 643
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 644
      ptr += 2;
#line 645
      if ((unsigned long )ptr == (unsigned long )end) {
#line 646
        return (-1);
      }
#line 647
      if ((int const   )*(ptr + 0) == 0) {
#line 647
        tmp___10 = (int )((struct normal_encoding *)enc)->type[(unsigned char )*(ptr + 1)];
      } else {
        {
#line 647
        tmp___9 = unicode_byte_type((char )*(ptr + 0), (char )*(ptr + 1));
#line 647
        tmp___10 = tmp___9;
        }
      }
      {
#line 648
      if (tmp___10 == 29) {
#line 648
        goto case_29___1;
      }
#line 648
      if (tmp___10 == 24) {
#line 648
        goto case_24___1;
      }
#line 648
      if (tmp___10 == 22) {
#line 648
        goto case_24___1;
      }
#line 648
      if (tmp___10 == 5) {
#line 648
        goto case_5___2;
      }
#line 648
      if (tmp___10 == 6) {
#line 648
        goto case_6___2;
      }
#line 648
      if (tmp___10 == 7) {
#line 648
        goto case_7___2;
      }
#line 649
      if (tmp___10 == 10) {
#line 649
        goto case_10___3;
      }
#line 649
      if (tmp___10 == 9) {
#line 649
        goto case_10___3;
      }
#line 649
      if (tmp___10 == 21) {
#line 649
        goto case_10___3;
      }
#line 651
      if (tmp___10 == 11) {
#line 651
        goto gt;
      }
#line 655
      if (tmp___10 == 17) {
#line 655
        goto sol;
      }
#line 666
      goto switch_default___4;
      case_29___1: /* CIL Label */ 
#line 648
      if (! (namingBitmap[((int const   )nmstrtPages[(unsigned char )*(ptr + 0)] << 3) + (int const   )((int )((unsigned char )*(ptr + 1)) >> 5)] & (unsigned int const   )(1 << ((int )((unsigned char )*(ptr + 1)) & 31)))) {
#line 648
        *nextTokPtr = ptr;
#line 648
        return (0);
      }
      case_24___1: /* CIL Label */ 
      case_22___1: /* CIL Label */ 
#line 648
      ptr += 2;
#line 648
      goto switch_break___5;
      case_5___2: /* CIL Label */ 
#line 648
      if (end - ptr < 2L) {
#line 648
        return (-2);
      }
#line 648
      *nextTokPtr = ptr;
#line 648
      return (0);
#line 648
      ptr += 2;
#line 648
      goto switch_break___5;
      case_6___2: /* CIL Label */ 
#line 648
      if (end - ptr < 3L) {
#line 648
        return (-2);
      }
#line 648
      *nextTokPtr = ptr;
#line 648
      return (0);
#line 648
      ptr += 3;
#line 648
      goto switch_break___5;
      case_7___2: /* CIL Label */ 
#line 648
      if (end - ptr < 4L) {
#line 648
        return (-2);
      }
#line 648
      *nextTokPtr = ptr;
#line 648
      return (0);
#line 648
      ptr += 4;
#line 648
      goto switch_break___5;
      case_10___3: /* CIL Label */ 
      case_9___3: /* CIL Label */ 
      case_21___3: /* CIL Label */ 
#line 650
      goto __Cont;
      gt: 
      case_11___0: /* CIL Label */ 
#line 653
      *nextTokPtr = ptr + 2;
#line 654
      return (1);
      sol: 
      case_17___0: /* CIL Label */ 
#line 657
      ptr += 2;
#line 658
      if ((unsigned long )ptr == (unsigned long )end) {
#line 659
        return (-1);
      }
#line 660
      if ((int const   )*(ptr + 0) == 0) {
#line 660
        if (! ((int const   )*(ptr + 1) == 62)) {
#line 661
          *nextTokPtr = ptr;
#line 662
          return (0);
        }
      } else {
#line 661
        *nextTokPtr = ptr;
#line 662
        return (0);
      }
#line 664
      *nextTokPtr = ptr + 2;
#line 665
      return (3);
      switch_default___4: /* CIL Label */ 
#line 667
      *nextTokPtr = ptr;
#line 668
      return (0);
      switch_break___5: /* CIL Label */ ;
      }
#line 670
      goto while_break___3;
      __Cont: /* CIL Label */ ;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 672
    goto switch_break;
    switch_default___5: /* CIL Label */ 
#line 675
    *nextTokPtr = ptr;
#line 676
    return (0);
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 679
  return (-1);
}
}
#line 684 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmltok_impl.c"
static int big2_scanLt(ENCODING const   *enc , char const   *ptr , char const   *end ,
                       char const   **nextTokPtr ) 
{ 
  int hadColon ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;

  {
#line 691
  if ((unsigned long )ptr == (unsigned long )end) {
#line 692
    return (-1);
  }
#line 693
  if ((int const   )*(ptr + 0) == 0) {
#line 693
    tmp___0 = (int )((struct normal_encoding *)enc)->type[(unsigned char )*(ptr + 1)];
  } else {
    {
#line 693
    tmp = unicode_byte_type((char )*(ptr + 0), (char )*(ptr + 1));
#line 693
    tmp___0 = tmp;
    }
  }
  {
#line 694
  if (tmp___0 == 29) {
#line 694
    goto case_29;
  }
#line 694
  if (tmp___0 == 24) {
#line 694
    goto case_24;
  }
#line 694
  if (tmp___0 == 22) {
#line 694
    goto case_24;
  }
#line 694
  if (tmp___0 == 5) {
#line 694
    goto case_5;
  }
#line 694
  if (tmp___0 == 6) {
#line 694
    goto case_6;
  }
#line 694
  if (tmp___0 == 7) {
#line 694
    goto case_7;
  }
#line 695
  if (tmp___0 == 16) {
#line 695
    goto case_16;
  }
#line 707
  if (tmp___0 == 15) {
#line 707
    goto case_15;
  }
#line 709
  if (tmp___0 == 17) {
#line 709
    goto case_17;
  }
#line 711
  goto switch_default;
  case_29: /* CIL Label */ 
#line 694
  if (! (namingBitmap[((int const   )nmstrtPages[(unsigned char )*(ptr + 0)] << 3) + (int const   )((int )((unsigned char )*(ptr + 1)) >> 5)] & (unsigned int const   )(1 << ((int )((unsigned char )*(ptr + 1)) & 31)))) {
#line 694
    *nextTokPtr = ptr;
#line 694
    return (0);
  }
  case_24: /* CIL Label */ 
  case_22: /* CIL Label */ 
#line 694
  ptr += 2;
#line 694
  goto switch_break;
  case_5: /* CIL Label */ 
#line 694
  if (end - ptr < 2L) {
#line 694
    return (-2);
  }
#line 694
  *nextTokPtr = ptr;
#line 694
  return (0);
#line 694
  ptr += 2;
#line 694
  goto switch_break;
  case_6: /* CIL Label */ 
#line 694
  if (end - ptr < 3L) {
#line 694
    return (-2);
  }
#line 694
  *nextTokPtr = ptr;
#line 694
  return (0);
#line 694
  ptr += 3;
#line 694
  goto switch_break;
  case_7: /* CIL Label */ 
#line 694
  if (end - ptr < 4L) {
#line 694
    return (-2);
  }
#line 694
  *nextTokPtr = ptr;
#line 694
  return (0);
#line 694
  ptr += 4;
#line 694
  goto switch_break;
  case_16: /* CIL Label */ 
#line 696
  ptr += 2;
#line 696
  if ((unsigned long )ptr == (unsigned long )end) {
#line 697
    return (-1);
  }
#line 698
  if ((int const   )*(ptr + 0) == 0) {
#line 698
    tmp___2 = (int )((struct normal_encoding *)enc)->type[(unsigned char )*(ptr + 1)];
  } else {
    {
#line 698
    tmp___1 = unicode_byte_type((char )*(ptr + 0), (char )*(ptr + 1));
#line 698
    tmp___2 = tmp___1;
    }
  }
  {
#line 699
  if (tmp___2 == 27) {
#line 699
    goto case_27;
  }
#line 701
  if (tmp___2 == 20) {
#line 701
    goto case_20;
  }
#line 698
  goto switch_break___0;
  case_27: /* CIL Label */ 
  {
#line 700
  tmp___3 = big2_scanComment(enc, ptr + 2, end, nextTokPtr);
  }
#line 700
  return (tmp___3);
  case_20: /* CIL Label */ 
  {
#line 702
  tmp___4 = big2_scanCdataSection(enc, ptr + 2, end, nextTokPtr);
  }
#line 702
  return (tmp___4);
  switch_break___0: /* CIL Label */ ;
  }
#line 705
  *nextTokPtr = ptr;
#line 706
  return (0);
  case_15: /* CIL Label */ 
  {
#line 708
  tmp___5 = big2_scanPi(enc, ptr + 2, end, nextTokPtr);
  }
#line 708
  return (tmp___5);
  case_17: /* CIL Label */ 
  {
#line 710
  tmp___6 = big2_scanEndTag(enc, ptr + 2, end, nextTokPtr);
  }
#line 710
  return (tmp___6);
  switch_default: /* CIL Label */ 
#line 712
  *nextTokPtr = ptr;
#line 713
  return (0);
  switch_break: /* CIL Label */ ;
  }
#line 716
  hadColon = 0;
  {
#line 719
  while (1) {
    while_continue: /* CIL Label */ ;
#line 719
    if (! ((unsigned long )ptr != (unsigned long )end)) {
#line 719
      goto while_break;
    }
#line 720
    if ((int const   )*(ptr + 0) == 0) {
#line 720
      tmp___8 = (int )((struct normal_encoding *)enc)->type[(unsigned char )*(ptr + 1)];
    } else {
      {
#line 720
      tmp___7 = unicode_byte_type((char )*(ptr + 0), (char )*(ptr + 1));
#line 720
      tmp___8 = tmp___7;
      }
    }
    {
#line 721
    if (tmp___8 == 29) {
#line 721
      goto case_29___0;
    }
#line 721
    if (tmp___8 == 27) {
#line 721
      goto case_27___0;
    }
#line 721
    if (tmp___8 == 26) {
#line 721
      goto case_27___0;
    }
#line 721
    if (tmp___8 == 25) {
#line 721
      goto case_27___0;
    }
#line 721
    if (tmp___8 == 24) {
#line 721
      goto case_27___0;
    }
#line 721
    if (tmp___8 == 22) {
#line 721
      goto case_27___0;
    }
#line 721
    if (tmp___8 == 5) {
#line 721
      goto case_5___0;
    }
#line 721
    if (tmp___8 == 6) {
#line 721
      goto case_6___0;
    }
#line 721
    if (tmp___8 == 7) {
#line 721
      goto case_7___0;
    }
#line 723
    if (tmp___8 == 23) {
#line 723
      goto case_23;
    }
#line 740
    if (tmp___8 == 10) {
#line 740
      goto case_10;
    }
#line 740
    if (tmp___8 == 9) {
#line 740
      goto case_10;
    }
#line 740
    if (tmp___8 == 21) {
#line 740
      goto case_10;
    }
#line 761
    if (tmp___8 == 11) {
#line 761
      goto gt;
    }
#line 765
    if (tmp___8 == 17) {
#line 765
      goto sol;
    }
#line 776
    goto switch_default___2;
    case_29___0: /* CIL Label */ 
#line 721
    if (! (namingBitmap[((int const   )namePages[(unsigned char )*(ptr + 0)] << 3) + (int const   )((int )((unsigned char )*(ptr + 1)) >> 5)] & (unsigned int const   )(1 << ((int )((unsigned char )*(ptr + 1)) & 31)))) {
#line 721
      *nextTokPtr = ptr;
#line 721
      return (0);
    }
    case_27___0: /* CIL Label */ 
    case_26: /* CIL Label */ 
    case_25: /* CIL Label */ 
    case_24___0: /* CIL Label */ 
    case_22___0: /* CIL Label */ 
#line 721
    ptr += 2;
#line 721
    goto switch_break___1;
    case_5___0: /* CIL Label */ 
#line 721
    if (end - ptr < 2L) {
#line 721
      return (-2);
    }
#line 721
    *nextTokPtr = ptr;
#line 721
    return (0);
#line 721
    ptr += 2;
#line 721
    goto switch_break___1;
    case_6___0: /* CIL Label */ 
#line 721
    if (end - ptr < 3L) {
#line 721
      return (-2);
    }
#line 721
    *nextTokPtr = ptr;
#line 721
    return (0);
#line 721
    ptr += 3;
#line 721
    goto switch_break___1;
    case_7___0: /* CIL Label */ 
#line 721
    if (end - ptr < 4L) {
#line 721
      return (-2);
    }
#line 721
    *nextTokPtr = ptr;
#line 721
    return (0);
#line 721
    ptr += 4;
#line 721
    goto switch_break___1;
    case_23: /* CIL Label */ 
#line 724
    if (hadColon) {
#line 725
      *nextTokPtr = ptr;
#line 726
      return (0);
    }
#line 728
    hadColon = 1;
#line 729
    ptr += 2;
#line 730
    if ((unsigned long )ptr == (unsigned long )end) {
#line 731
      return (-1);
    }
#line 732
    if ((int const   )*(ptr + 0) == 0) {
#line 732
      tmp___10 = (int )((struct normal_encoding *)enc)->type[(unsigned char )*(ptr + 1)];
    } else {
      {
#line 732
      tmp___9 = unicode_byte_type((char )*(ptr + 0), (char )*(ptr + 1));
#line 732
      tmp___10 = tmp___9;
      }
    }
    {
#line 733
    if (tmp___10 == 29) {
#line 733
      goto case_29___1;
    }
#line 733
    if (tmp___10 == 24) {
#line 733
      goto case_24___1;
    }
#line 733
    if (tmp___10 == 22) {
#line 733
      goto case_24___1;
    }
#line 733
    if (tmp___10 == 5) {
#line 733
      goto case_5___1;
    }
#line 733
    if (tmp___10 == 6) {
#line 733
      goto case_6___1;
    }
#line 733
    if (tmp___10 == 7) {
#line 733
      goto case_7___1;
    }
#line 734
    goto switch_default___0;
    case_29___1: /* CIL Label */ 
#line 733
    if (! (namingBitmap[((int const   )nmstrtPages[(unsigned char )*(ptr + 0)] << 3) + (int const   )((int )((unsigned char )*(ptr + 1)) >> 5)] & (unsigned int const   )(1 << ((int )((unsigned char )*(ptr + 1)) & 31)))) {
#line 733
      *nextTokPtr = ptr;
#line 733
      return (0);
    }
    case_24___1: /* CIL Label */ 
    case_22___1: /* CIL Label */ 
#line 733
    ptr += 2;
#line 733
    goto switch_break___2;
    case_5___1: /* CIL Label */ 
#line 733
    if (end - ptr < 2L) {
#line 733
      return (-2);
    }
#line 733
    *nextTokPtr = ptr;
#line 733
    return (0);
#line 733
    ptr += 2;
#line 733
    goto switch_break___2;
    case_6___1: /* CIL Label */ 
#line 733
    if (end - ptr < 3L) {
#line 733
      return (-2);
    }
#line 733
    *nextTokPtr = ptr;
#line 733
    return (0);
#line 733
    ptr += 3;
#line 733
    goto switch_break___2;
    case_7___1: /* CIL Label */ 
#line 733
    if (end - ptr < 4L) {
#line 733
      return (-2);
    }
#line 733
    *nextTokPtr = ptr;
#line 733
    return (0);
#line 733
    ptr += 4;
#line 733
    goto switch_break___2;
    switch_default___0: /* CIL Label */ 
#line 735
    *nextTokPtr = ptr;
#line 736
    return (0);
    switch_break___2: /* CIL Label */ ;
    }
#line 738
    goto switch_break___1;
    case_10: /* CIL Label */ 
    case_9: /* CIL Label */ 
    case_21: /* CIL Label */ 
#line 742
    ptr += 2;
    {
#line 743
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 743
      if (! ((unsigned long )ptr != (unsigned long )end)) {
#line 743
        goto while_break___0;
      }
#line 744
      if ((int const   )*(ptr + 0) == 0) {
#line 744
        tmp___12 = (int )((struct normal_encoding *)enc)->type[(unsigned char )*(ptr + 1)];
      } else {
        {
#line 744
        tmp___11 = unicode_byte_type((char )*(ptr + 0), (char )*(ptr + 1));
#line 744
        tmp___12 = tmp___11;
        }
      }
      {
#line 745
      if (tmp___12 == 29) {
#line 745
        goto case_29___2;
      }
#line 745
      if (tmp___12 == 24) {
#line 745
        goto case_24___2;
      }
#line 745
      if (tmp___12 == 22) {
#line 745
        goto case_24___2;
      }
#line 745
      if (tmp___12 == 5) {
#line 745
        goto case_5___2;
      }
#line 745
      if (tmp___12 == 6) {
#line 745
        goto case_6___2;
      }
#line 745
      if (tmp___12 == 7) {
#line 745
        goto case_7___2;
      }
#line 746
      if (tmp___12 == 11) {
#line 746
        goto case_11;
      }
#line 748
      if (tmp___12 == 17) {
#line 748
        goto case_17___0;
      }
#line 750
      if (tmp___12 == 10) {
#line 750
        goto case_10___0;
      }
#line 750
      if (tmp___12 == 9) {
#line 750
        goto case_10___0;
      }
#line 750
      if (tmp___12 == 21) {
#line 750
        goto case_10___0;
      }
#line 753
      goto switch_default___1;
      case_29___2: /* CIL Label */ 
#line 745
      if (! (namingBitmap[((int const   )nmstrtPages[(unsigned char )*(ptr + 0)] << 3) + (int const   )((int )((unsigned char )*(ptr + 1)) >> 5)] & (unsigned int const   )(1 << ((int )((unsigned char )*(ptr + 1)) & 31)))) {
#line 745
        *nextTokPtr = ptr;
#line 745
        return (0);
      }
      case_24___2: /* CIL Label */ 
      case_22___2: /* CIL Label */ 
#line 745
      ptr += 2;
#line 745
      goto switch_break___3;
      case_5___2: /* CIL Label */ 
#line 745
      if (end - ptr < 2L) {
#line 745
        return (-2);
      }
#line 745
      *nextTokPtr = ptr;
#line 745
      return (0);
#line 745
      ptr += 2;
#line 745
      goto switch_break___3;
      case_6___2: /* CIL Label */ 
#line 745
      if (end - ptr < 3L) {
#line 745
        return (-2);
      }
#line 745
      *nextTokPtr = ptr;
#line 745
      return (0);
#line 745
      ptr += 3;
#line 745
      goto switch_break___3;
      case_7___2: /* CIL Label */ 
#line 745
      if (end - ptr < 4L) {
#line 745
        return (-2);
      }
#line 745
      *nextTokPtr = ptr;
#line 745
      return (0);
#line 745
      ptr += 4;
#line 745
      goto switch_break___3;
      case_11: /* CIL Label */ 
#line 747
      goto gt;
      case_17___0: /* CIL Label */ 
#line 749
      goto sol;
      case_10___0: /* CIL Label */ 
      case_9___0: /* CIL Label */ 
      case_21___0: /* CIL Label */ 
#line 751
      ptr += 2;
#line 752
      goto while_continue___0;
      switch_default___1: /* CIL Label */ 
#line 754
      *nextTokPtr = ptr;
#line 755
      return (0);
      switch_break___3: /* CIL Label */ ;
      }
      {
#line 757
      tmp___13 = big2_scanAtts(enc, ptr, end, nextTokPtr);
      }
#line 757
      return (tmp___13);
    }
    while_break___0: /* CIL Label */ ;
    }
#line 759
    return (-1);
    gt: 
    case_11___0: /* CIL Label */ 
#line 763
    *nextTokPtr = ptr + 2;
#line 764
    return (2);
    sol: 
    case_17___1: /* CIL Label */ 
#line 767
    ptr += 2;
#line 768
    if ((unsigned long )ptr == (unsigned long )end) {
#line 769
      return (-1);
    }
#line 770
    if ((int const   )*(ptr + 0) == 0) {
#line 770
      if (! ((int const   )*(ptr + 1) == 62)) {
#line 771
        *nextTokPtr = ptr;
#line 772
        return (0);
      }
    } else {
#line 771
      *nextTokPtr = ptr;
#line 772
      return (0);
    }
#line 774
    *nextTokPtr = ptr + 2;
#line 775
    return (4);
    switch_default___2: /* CIL Label */ 
#line 777
    *nextTokPtr = ptr;
#line 778
    return (0);
    switch_break___1: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 781
  return (-1);
}
}
#line 784 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmltok_impl.c"
static int big2_contentTok(ENCODING const   *enc , char const   *ptr , char const   *end ,
                           char const   **nextTokPtr ) 
{ 
  size_t n ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
#line 788
  if ((unsigned long )ptr == (unsigned long )end) {
#line 789
    return (-4);
  }
#line 791
  n = (size_t )(end - ptr);
#line 792
  if (n & 1UL) {
#line 793
    n &= 0xfffffffffffffffeUL;
#line 794
    if (n == 0UL) {
#line 795
      return (-1);
    }
#line 796
    end = ptr + n;
  }
#line 799
  if ((int const   )*(ptr + 0) == 0) {
#line 799
    tmp___0 = (int )((struct normal_encoding *)enc)->type[(unsigned char )*(ptr + 1)];
  } else {
    {
#line 799
    tmp = unicode_byte_type((char )*(ptr + 0), (char )*(ptr + 1));
#line 799
    tmp___0 = tmp;
    }
  }
  {
#line 800
  if (tmp___0 == 2) {
#line 800
    goto case_2;
  }
#line 802
  if (tmp___0 == 3) {
#line 802
    goto case_3;
  }
#line 804
  if (tmp___0 == 9) {
#line 804
    goto case_9;
  }
#line 812
  if (tmp___0 == 10) {
#line 812
    goto case_10;
  }
#line 815
  if (tmp___0 == 4) {
#line 815
    goto case_4;
  }
#line 830
  if (tmp___0 == 5) {
#line 830
    goto case_5;
  }
#line 830
  if (tmp___0 == 6) {
#line 830
    goto case_6;
  }
#line 830
  if (tmp___0 == 7) {
#line 830
    goto case_7;
  }
#line 830
  if (tmp___0 == 8) {
#line 830
    goto case_8;
  }
#line 830
  if (tmp___0 == 1) {
#line 830
    goto case_8;
  }
#line 830
  if (tmp___0 == 0) {
#line 830
    goto case_8;
  }
#line 831
  goto switch_default;
  case_2: /* CIL Label */ 
  {
#line 801
  tmp___1 = big2_scanLt(enc, ptr + 2, end, nextTokPtr);
  }
#line 801
  return (tmp___1);
  case_3: /* CIL Label */ 
  {
#line 803
  tmp___2 = big2_scanRef(enc, ptr + 2, end, nextTokPtr);
  }
#line 803
  return (tmp___2);
  case_9: /* CIL Label */ 
#line 805
  ptr += 2;
#line 806
  if ((unsigned long )ptr == (unsigned long )end) {
#line 807
    return (-3);
  }
#line 808
  if ((int const   )*(ptr + 0) == 0) {
#line 808
    tmp___4 = (int )((struct normal_encoding *)enc)->type[(unsigned char )*(ptr + 1)];
  } else {
    {
#line 808
    tmp___3 = unicode_byte_type((char )*(ptr + 0), (char )*(ptr + 1));
#line 808
    tmp___4 = tmp___3;
    }
  }
#line 808
  if (tmp___4 == 10) {
#line 809
    ptr += 2;
  }
#line 810
  *nextTokPtr = ptr;
#line 811
  return (7);
  case_10: /* CIL Label */ 
#line 813
  *nextTokPtr = ptr + 2;
#line 814
  return (7);
  case_4: /* CIL Label */ 
#line 816
  ptr += 2;
#line 817
  if ((unsigned long )ptr == (unsigned long )end) {
#line 818
    return (-5);
  }
#line 819
  if ((int const   )*(ptr + 0) == 0) {
#line 819
    if (! ((int const   )*(ptr + 1) == 93)) {
#line 820
      goto switch_break;
    }
  } else {
#line 820
    goto switch_break;
  }
#line 821
  ptr += 2;
#line 822
  if ((unsigned long )ptr == (unsigned long )end) {
#line 823
    return (-5);
  }
#line 824
  if ((int const   )*(ptr + 0) == 0) {
#line 824
    if (! ((int const   )*(ptr + 1) == 62)) {
#line 825
      ptr -= 2;
#line 826
      goto switch_break;
    }
  } else {
#line 825
    ptr -= 2;
#line 826
    goto switch_break;
  }
#line 828
  *nextTokPtr = ptr;
#line 829
  return (0);
  case_5: /* CIL Label */ 
#line 830
  if (end - ptr < 2L) {
#line 830
    return (-2);
  }
#line 830
  ptr += 2;
#line 830
  goto switch_break;
  case_6: /* CIL Label */ 
#line 830
  if (end - ptr < 3L) {
#line 830
    return (-2);
  }
#line 830
  ptr += 3;
#line 830
  goto switch_break;
  case_7: /* CIL Label */ 
#line 830
  if (end - ptr < 4L) {
#line 830
    return (-2);
  }
#line 830
  ptr += 4;
#line 830
  goto switch_break;
  case_8: /* CIL Label */ 
  case_1: /* CIL Label */ 
  case_0: /* CIL Label */ 
#line 830
  *nextTokPtr = ptr;
#line 830
  return (0);
  switch_default: /* CIL Label */ 
#line 832
  ptr += 2;
#line 833
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 835
  while (1) {
    while_continue: /* CIL Label */ ;
#line 835
    if (! ((unsigned long )ptr != (unsigned long )end)) {
#line 835
      goto while_break;
    }
#line 836
    if ((int const   )*(ptr + 0) == 0) {
#line 836
      tmp___6 = (int )((struct normal_encoding *)enc)->type[(unsigned char )*(ptr + 1)];
    } else {
      {
#line 836
      tmp___5 = unicode_byte_type((char )*(ptr + 0), (char )*(ptr + 1));
#line 836
      tmp___6 = tmp___5;
      }
    }
    {
#line 845
    if (tmp___6 == 5) {
#line 845
      goto case_5___0;
    }
#line 845
    if (tmp___6 == 6) {
#line 845
      goto case_6___0;
    }
#line 845
    if (tmp___6 == 7) {
#line 845
      goto case_7___0;
    }
#line 847
    if (tmp___6 == 4) {
#line 847
      goto case_4___0;
    }
#line 869
    if (tmp___6 == 10) {
#line 869
      goto case_10___0;
    }
#line 869
    if (tmp___6 == 9) {
#line 869
      goto case_10___0;
    }
#line 869
    if (tmp___6 == 8) {
#line 869
      goto case_10___0;
    }
#line 869
    if (tmp___6 == 1) {
#line 869
      goto case_10___0;
    }
#line 869
    if (tmp___6 == 0) {
#line 869
      goto case_10___0;
    }
#line 869
    if (tmp___6 == 2) {
#line 869
      goto case_10___0;
    }
#line 869
    if (tmp___6 == 3) {
#line 869
      goto case_10___0;
    }
#line 872
    goto switch_default___0;
    case_5___0: /* CIL Label */ 
#line 845
    if (end - ptr < 2L) {
#line 845
      *nextTokPtr = ptr;
#line 845
      return (6);
    }
#line 845
    ptr += 2;
#line 845
    goto switch_break___0;
    case_6___0: /* CIL Label */ 
#line 845
    if (end - ptr < 3L) {
#line 845
      *nextTokPtr = ptr;
#line 845
      return (6);
    }
#line 845
    ptr += 3;
#line 845
    goto switch_break___0;
    case_7___0: /* CIL Label */ 
#line 845
    if (end - ptr < 4L) {
#line 845
      *nextTokPtr = ptr;
#line 845
      return (6);
    }
#line 845
    ptr += 4;
#line 845
    goto switch_break___0;
    case_4___0: /* CIL Label */ 
#line 848
    if ((unsigned long )(ptr + 2) != (unsigned long )end) {
#line 849
      if ((int const   )*((ptr + 2) + 0) == 0) {
#line 849
        if (! ((int const   )*((ptr + 2) + 1) == 93)) {
#line 850
          ptr += 2;
#line 851
          goto switch_break___0;
        }
      } else {
#line 850
        ptr += 2;
#line 851
        goto switch_break___0;
      }
#line 853
      if ((unsigned long )(ptr + 4) != (unsigned long )end) {
#line 854
        if ((int const   )*((ptr + 4) + 0) == 0) {
#line 854
          if (! ((int const   )*((ptr + 4) + 1) == 62)) {
#line 855
            ptr += 2;
#line 856
            goto switch_break___0;
          }
        } else {
#line 855
          ptr += 2;
#line 856
          goto switch_break___0;
        }
#line 858
        *nextTokPtr = ptr + 4;
#line 859
        return (0);
      }
    }
    case_10___0: /* CIL Label */ 
    case_9___0: /* CIL Label */ 
    case_8___0: /* CIL Label */ 
    case_1___0: /* CIL Label */ 
    case_0___0: /* CIL Label */ 
    case_2___0: /* CIL Label */ 
    case_3___0: /* CIL Label */ 
#line 870
    *nextTokPtr = ptr;
#line 871
    return (6);
    switch_default___0: /* CIL Label */ 
#line 873
    ptr += 2;
#line 874
    goto switch_break___0;
    switch_break___0: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 877
  *nextTokPtr = ptr;
#line 878
  return (6);
}
}
#line 883 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmltok_impl.c"
static int big2_scanPercent(ENCODING const   *enc , char const   *ptr , char const   *end ,
                            char const   **nextTokPtr ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 887
  if ((unsigned long )ptr == (unsigned long )end) {
#line 888
    return (-1);
  }
#line 889
  if ((int const   )*(ptr + 0) == 0) {
#line 889
    tmp___0 = (int )((struct normal_encoding *)enc)->type[(unsigned char )*(ptr + 1)];
  } else {
    {
#line 889
    tmp = unicode_byte_type((char )*(ptr + 0), (char )*(ptr + 1));
#line 889
    tmp___0 = tmp;
    }
  }
  {
#line 890
  if (tmp___0 == 29) {
#line 890
    goto case_29;
  }
#line 890
  if (tmp___0 == 24) {
#line 890
    goto case_24;
  }
#line 890
  if (tmp___0 == 22) {
#line 890
    goto case_24;
  }
#line 890
  if (tmp___0 == 5) {
#line 890
    goto case_5;
  }
#line 890
  if (tmp___0 == 6) {
#line 890
    goto case_6;
  }
#line 890
  if (tmp___0 == 7) {
#line 890
    goto case_7;
  }
#line 891
  if (tmp___0 == 30) {
#line 891
    goto case_30;
  }
#line 891
  if (tmp___0 == 9) {
#line 891
    goto case_30;
  }
#line 891
  if (tmp___0 == 10) {
#line 891
    goto case_30;
  }
#line 891
  if (tmp___0 == 21) {
#line 891
    goto case_30;
  }
#line 894
  goto switch_default;
  case_29: /* CIL Label */ 
#line 890
  if (! (namingBitmap[((int const   )nmstrtPages[(unsigned char )*(ptr + 0)] << 3) + (int const   )((int )((unsigned char )*(ptr + 1)) >> 5)] & (unsigned int const   )(1 << ((int )((unsigned char )*(ptr + 1)) & 31)))) {
#line 890
    *nextTokPtr = ptr;
#line 890
    return (0);
  }
  case_24: /* CIL Label */ 
  case_22: /* CIL Label */ 
#line 890
  ptr += 2;
#line 890
  goto switch_break;
  case_5: /* CIL Label */ 
#line 890
  if (end - ptr < 2L) {
#line 890
    return (-2);
  }
#line 890
  *nextTokPtr = ptr;
#line 890
  return (0);
#line 890
  ptr += 2;
#line 890
  goto switch_break;
  case_6: /* CIL Label */ 
#line 890
  if (end - ptr < 3L) {
#line 890
    return (-2);
  }
#line 890
  *nextTokPtr = ptr;
#line 890
  return (0);
#line 890
  ptr += 3;
#line 890
  goto switch_break;
  case_7: /* CIL Label */ 
#line 890
  if (end - ptr < 4L) {
#line 890
    return (-2);
  }
#line 890
  *nextTokPtr = ptr;
#line 890
  return (0);
#line 890
  ptr += 4;
#line 890
  goto switch_break;
  case_30: /* CIL Label */ 
  case_9: /* CIL Label */ 
  case_10: /* CIL Label */ 
  case_21: /* CIL Label */ 
#line 892
  *nextTokPtr = ptr;
#line 893
  return (22);
  switch_default: /* CIL Label */ 
#line 895
  *nextTokPtr = ptr;
#line 896
  return (0);
  switch_break: /* CIL Label */ ;
  }
  {
#line 898
  while (1) {
    while_continue: /* CIL Label */ ;
#line 898
    if (! ((unsigned long )ptr != (unsigned long )end)) {
#line 898
      goto while_break;
    }
#line 899
    if ((int const   )*(ptr + 0) == 0) {
#line 899
      tmp___2 = (int )((struct normal_encoding *)enc)->type[(unsigned char )*(ptr + 1)];
    } else {
      {
#line 899
      tmp___1 = unicode_byte_type((char )*(ptr + 0), (char )*(ptr + 1));
#line 899
      tmp___2 = tmp___1;
      }
    }
    {
#line 900
    if (tmp___2 == 29) {
#line 900
      goto case_29___0;
    }
#line 900
    if (tmp___2 == 27) {
#line 900
      goto case_27;
    }
#line 900
    if (tmp___2 == 26) {
#line 900
      goto case_27;
    }
#line 900
    if (tmp___2 == 25) {
#line 900
      goto case_27;
    }
#line 900
    if (tmp___2 == 24) {
#line 900
      goto case_27;
    }
#line 900
    if (tmp___2 == 22) {
#line 900
      goto case_27;
    }
#line 900
    if (tmp___2 == 5) {
#line 900
      goto case_5___0;
    }
#line 900
    if (tmp___2 == 6) {
#line 900
      goto case_6___0;
    }
#line 900
    if (tmp___2 == 7) {
#line 900
      goto case_7___0;
    }
#line 901
    if (tmp___2 == 18) {
#line 901
      goto case_18;
    }
#line 904
    goto switch_default___0;
    case_29___0: /* CIL Label */ 
#line 900
    if (! (namingBitmap[((int const   )namePages[(unsigned char )*(ptr + 0)] << 3) + (int const   )((int )((unsigned char )*(ptr + 1)) >> 5)] & (unsigned int const   )(1 << ((int )((unsigned char )*(ptr + 1)) & 31)))) {
#line 900
      *nextTokPtr = ptr;
#line 900
      return (0);
    }
    case_27: /* CIL Label */ 
    case_26: /* CIL Label */ 
    case_25: /* CIL Label */ 
    case_24___0: /* CIL Label */ 
    case_22___0: /* CIL Label */ 
#line 900
    ptr += 2;
#line 900
    goto switch_break___0;
    case_5___0: /* CIL Label */ 
#line 900
    if (end - ptr < 2L) {
#line 900
      return (-2);
    }
#line 900
    *nextTokPtr = ptr;
#line 900
    return (0);
#line 900
    ptr += 2;
#line 900
    goto switch_break___0;
    case_6___0: /* CIL Label */ 
#line 900
    if (end - ptr < 3L) {
#line 900
      return (-2);
    }
#line 900
    *nextTokPtr = ptr;
#line 900
    return (0);
#line 900
    ptr += 3;
#line 900
    goto switch_break___0;
    case_7___0: /* CIL Label */ 
#line 900
    if (end - ptr < 4L) {
#line 900
      return (-2);
    }
#line 900
    *nextTokPtr = ptr;
#line 900
    return (0);
#line 900
    ptr += 4;
#line 900
    goto switch_break___0;
    case_18: /* CIL Label */ 
#line 902
    *nextTokPtr = ptr + 2;
#line 903
    return (28);
    switch_default___0: /* CIL Label */ 
#line 905
    *nextTokPtr = ptr;
#line 906
    return (0);
    switch_break___0: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 909
  return (-1);
}
}
#line 912 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmltok_impl.c"
static int big2_scanPoundName(ENCODING const   *enc , char const   *ptr , char const   *end ,
                              char const   **nextTokPtr ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 916
  if ((unsigned long )ptr == (unsigned long )end) {
#line 917
    return (-1);
  }
#line 918
  if ((int const   )*(ptr + 0) == 0) {
#line 918
    tmp___0 = (int )((struct normal_encoding *)enc)->type[(unsigned char )*(ptr + 1)];
  } else {
    {
#line 918
    tmp = unicode_byte_type((char )*(ptr + 0), (char )*(ptr + 1));
#line 918
    tmp___0 = tmp;
    }
  }
  {
#line 919
  if (tmp___0 == 29) {
#line 919
    goto case_29;
  }
#line 919
  if (tmp___0 == 24) {
#line 919
    goto case_24;
  }
#line 919
  if (tmp___0 == 22) {
#line 919
    goto case_24;
  }
#line 919
  if (tmp___0 == 5) {
#line 919
    goto case_5;
  }
#line 919
  if (tmp___0 == 6) {
#line 919
    goto case_6;
  }
#line 919
  if (tmp___0 == 7) {
#line 919
    goto case_7;
  }
#line 920
  goto switch_default;
  case_29: /* CIL Label */ 
#line 919
  if (! (namingBitmap[((int const   )nmstrtPages[(unsigned char )*(ptr + 0)] << 3) + (int const   )((int )((unsigned char )*(ptr + 1)) >> 5)] & (unsigned int const   )(1 << ((int )((unsigned char )*(ptr + 1)) & 31)))) {
#line 919
    *nextTokPtr = ptr;
#line 919
    return (0);
  }
  case_24: /* CIL Label */ 
  case_22: /* CIL Label */ 
#line 919
  ptr += 2;
#line 919
  goto switch_break;
  case_5: /* CIL Label */ 
#line 919
  if (end - ptr < 2L) {
#line 919
    return (-2);
  }
#line 919
  *nextTokPtr = ptr;
#line 919
  return (0);
#line 919
  ptr += 2;
#line 919
  goto switch_break;
  case_6: /* CIL Label */ 
#line 919
  if (end - ptr < 3L) {
#line 919
    return (-2);
  }
#line 919
  *nextTokPtr = ptr;
#line 919
  return (0);
#line 919
  ptr += 3;
#line 919
  goto switch_break;
  case_7: /* CIL Label */ 
#line 919
  if (end - ptr < 4L) {
#line 919
    return (-2);
  }
#line 919
  *nextTokPtr = ptr;
#line 919
  return (0);
#line 919
  ptr += 4;
#line 919
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 921
  *nextTokPtr = ptr;
#line 922
  return (0);
  switch_break: /* CIL Label */ ;
  }
  {
#line 924
  while (1) {
    while_continue: /* CIL Label */ ;
#line 924
    if (! ((unsigned long )ptr != (unsigned long )end)) {
#line 924
      goto while_break;
    }
#line 925
    if ((int const   )*(ptr + 0) == 0) {
#line 925
      tmp___2 = (int )((struct normal_encoding *)enc)->type[(unsigned char )*(ptr + 1)];
    } else {
      {
#line 925
      tmp___1 = unicode_byte_type((char )*(ptr + 0), (char )*(ptr + 1));
#line 925
      tmp___2 = tmp___1;
      }
    }
    {
#line 926
    if (tmp___2 == 29) {
#line 926
      goto case_29___0;
    }
#line 926
    if (tmp___2 == 27) {
#line 926
      goto case_27;
    }
#line 926
    if (tmp___2 == 26) {
#line 926
      goto case_27;
    }
#line 926
    if (tmp___2 == 25) {
#line 926
      goto case_27;
    }
#line 926
    if (tmp___2 == 24) {
#line 926
      goto case_27;
    }
#line 926
    if (tmp___2 == 22) {
#line 926
      goto case_27;
    }
#line 926
    if (tmp___2 == 5) {
#line 926
      goto case_5___0;
    }
#line 926
    if (tmp___2 == 6) {
#line 926
      goto case_6___0;
    }
#line 926
    if (tmp___2 == 7) {
#line 926
      goto case_7___0;
    }
#line 928
    if (tmp___2 == 36) {
#line 928
      goto case_36;
    }
#line 928
    if (tmp___2 == 30) {
#line 928
      goto case_36;
    }
#line 928
    if (tmp___2 == 11) {
#line 928
      goto case_36;
    }
#line 928
    if (tmp___2 == 32) {
#line 928
      goto case_36;
    }
#line 928
    if (tmp___2 == 21) {
#line 928
      goto case_36;
    }
#line 928
    if (tmp___2 == 10) {
#line 928
      goto case_36;
    }
#line 928
    if (tmp___2 == 9) {
#line 928
      goto case_36;
    }
#line 931
    goto switch_default___0;
    case_29___0: /* CIL Label */ 
#line 926
    if (! (namingBitmap[((int const   )namePages[(unsigned char )*(ptr + 0)] << 3) + (int const   )((int )((unsigned char )*(ptr + 1)) >> 5)] & (unsigned int const   )(1 << ((int )((unsigned char )*(ptr + 1)) & 31)))) {
#line 926
      *nextTokPtr = ptr;
#line 926
      return (0);
    }
    case_27: /* CIL Label */ 
    case_26: /* CIL Label */ 
    case_25: /* CIL Label */ 
    case_24___0: /* CIL Label */ 
    case_22___0: /* CIL Label */ 
#line 926
    ptr += 2;
#line 926
    goto switch_break___0;
    case_5___0: /* CIL Label */ 
#line 926
    if (end - ptr < 2L) {
#line 926
      return (-2);
    }
#line 926
    *nextTokPtr = ptr;
#line 926
    return (0);
#line 926
    ptr += 2;
#line 926
    goto switch_break___0;
    case_6___0: /* CIL Label */ 
#line 926
    if (end - ptr < 3L) {
#line 926
      return (-2);
    }
#line 926
    *nextTokPtr = ptr;
#line 926
    return (0);
#line 926
    ptr += 3;
#line 926
    goto switch_break___0;
    case_7___0: /* CIL Label */ 
#line 926
    if (end - ptr < 4L) {
#line 926
      return (-2);
    }
#line 926
    *nextTokPtr = ptr;
#line 926
    return (0);
#line 926
    ptr += 4;
#line 926
    goto switch_break___0;
    case_36: /* CIL Label */ 
    case_30: /* CIL Label */ 
    case_11: /* CIL Label */ 
    case_32: /* CIL Label */ 
    case_21: /* CIL Label */ 
    case_10: /* CIL Label */ 
    case_9: /* CIL Label */ 
#line 929
    *nextTokPtr = ptr;
#line 930
    return (20);
    switch_default___0: /* CIL Label */ 
#line 932
    *nextTokPtr = ptr;
#line 933
    return (0);
    switch_break___0: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 936
  return (-20);
}
}
#line 939 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmltok_impl.c"
static int big2_scanLit(int open___0 , ENCODING const   *enc , char const   *ptr ,
                        char const   *end , char const   **nextTokPtr ) 
{ 
  int t ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 944
  while (1) {
    while_continue: /* CIL Label */ ;
#line 944
    if (! ((unsigned long )ptr != (unsigned long )end)) {
#line 944
      goto while_break;
    }
#line 945
    if ((int const   )*(ptr + 0) == 0) {
#line 945
      tmp___0 = (int )((struct normal_encoding *)enc)->type[(unsigned char )*(ptr + 1)];
    } else {
      {
#line 945
      tmp = unicode_byte_type((char )*(ptr + 0), (char )*(ptr + 1));
#line 945
      tmp___0 = tmp;
      }
    }
#line 945
    t = tmp___0;
    {
#line 947
    if (t == 5) {
#line 947
      goto case_5;
    }
#line 947
    if (t == 6) {
#line 947
      goto case_6;
    }
#line 947
    if (t == 7) {
#line 947
      goto case_7;
    }
#line 947
    if (t == 8) {
#line 947
      goto case_8;
    }
#line 947
    if (t == 1) {
#line 947
      goto case_8;
    }
#line 947
    if (t == 0) {
#line 947
      goto case_8;
    }
#line 949
    if (t == 13) {
#line 949
      goto case_13;
    }
#line 949
    if (t == 12) {
#line 949
      goto case_13;
    }
#line 963
    goto switch_default___0;
    case_5: /* CIL Label */ 
#line 947
    if (end - ptr < 2L) {
#line 947
      return (-2);
    }
#line 947
    ptr += 2;
#line 947
    goto switch_break;
    case_6: /* CIL Label */ 
#line 947
    if (end - ptr < 3L) {
#line 947
      return (-2);
    }
#line 947
    ptr += 3;
#line 947
    goto switch_break;
    case_7: /* CIL Label */ 
#line 947
    if (end - ptr < 4L) {
#line 947
      return (-2);
    }
#line 947
    ptr += 4;
#line 947
    goto switch_break;
    case_8: /* CIL Label */ 
    case_1: /* CIL Label */ 
    case_0: /* CIL Label */ 
#line 947
    *nextTokPtr = ptr;
#line 947
    return (0);
    case_13: /* CIL Label */ 
    case_12: /* CIL Label */ 
#line 950
    ptr += 2;
#line 951
    if (t != open___0) {
#line 952
      goto switch_break;
    }
#line 953
    if ((unsigned long )ptr == (unsigned long )end) {
#line 954
      return (-27);
    }
#line 955
    *nextTokPtr = ptr;
#line 956
    if ((int const   )*(ptr + 0) == 0) {
#line 956
      tmp___2 = (int )((struct normal_encoding *)enc)->type[(unsigned char )*(ptr + 1)];
    } else {
      {
#line 956
      tmp___1 = unicode_byte_type((char )*(ptr + 0), (char )*(ptr + 1));
#line 956
      tmp___2 = tmp___1;
      }
    }
    {
#line 958
    if (tmp___2 == 20) {
#line 958
      goto case_20;
    }
#line 958
    if (tmp___2 == 30) {
#line 958
      goto case_20;
    }
#line 958
    if (tmp___2 == 11) {
#line 958
      goto case_20;
    }
#line 958
    if (tmp___2 == 10) {
#line 958
      goto case_20;
    }
#line 958
    if (tmp___2 == 9) {
#line 958
      goto case_20;
    }
#line 958
    if (tmp___2 == 21) {
#line 958
      goto case_20;
    }
#line 960
    goto switch_default;
    case_20: /* CIL Label */ 
    case_30: /* CIL Label */ 
    case_11: /* CIL Label */ 
    case_10: /* CIL Label */ 
    case_9: /* CIL Label */ 
    case_21: /* CIL Label */ 
#line 959
    return (27);
    switch_default: /* CIL Label */ 
#line 961
    return (0);
    switch_break___0: /* CIL Label */ ;
    }
    switch_default___0: /* CIL Label */ 
#line 964
    ptr += 2;
#line 965
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 968
  return (-1);
}
}
#line 971 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmltok_impl.c"
static int big2_prologTok(ENCODING const   *enc , char const   *ptr , char const   *end ,
                          char const   **nextTokPtr ) 
{ 
  int tok ;
  size_t n ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;

  {
#line 976
  if ((unsigned long )ptr == (unsigned long )end) {
#line 977
    return (-4);
  }
#line 979
  n = (size_t )(end - ptr);
#line 980
  if (n & 1UL) {
#line 981
    n &= 0xfffffffffffffffeUL;
#line 982
    if (n == 0UL) {
#line 983
      return (-1);
    }
#line 984
    end = ptr + n;
  }
#line 987
  if ((int const   )*(ptr + 0) == 0) {
#line 987
    tmp___0 = (int )((struct normal_encoding *)enc)->type[(unsigned char )*(ptr + 1)];
  } else {
    {
#line 987
    tmp = unicode_byte_type((char )*(ptr + 0), (char )*(ptr + 1));
#line 987
    tmp___0 = tmp;
    }
  }
  {
#line 988
  if (tmp___0 == 12) {
#line 988
    goto case_12;
  }
#line 990
  if (tmp___0 == 13) {
#line 990
    goto case_13;
  }
#line 992
  if (tmp___0 == 2) {
#line 992
    goto case_2;
  }
#line 1014
  if (tmp___0 == 9) {
#line 1014
    goto case_9;
  }
#line 1021
  if (tmp___0 == 10) {
#line 1021
    goto case_10;
  }
#line 1021
  if (tmp___0 == 21) {
#line 1021
    goto case_10;
  }
#line 1041
  if (tmp___0 == 30) {
#line 1041
    goto case_30;
  }
#line 1043
  if (tmp___0 == 35) {
#line 1043
    goto case_35;
  }
#line 1046
  if (tmp___0 == 20) {
#line 1046
    goto case_20;
  }
#line 1049
  if (tmp___0 == 4) {
#line 1049
    goto case_4;
  }
#line 1063
  if (tmp___0 == 31) {
#line 1063
    goto case_31;
  }
#line 1066
  if (tmp___0 == 32) {
#line 1066
    goto case_32;
  }
#line 1088
  if (tmp___0 == 36) {
#line 1088
    goto case_36___0;
  }
#line 1091
  if (tmp___0 == 11) {
#line 1091
    goto case_11___0;
  }
#line 1094
  if (tmp___0 == 19) {
#line 1094
    goto case_19;
  }
#line 1112
  if (tmp___0 == 5) {
#line 1112
    goto case_5___0;
  }
#line 1112
  if (tmp___0 == 6) {
#line 1112
    goto case_6___0;
  }
#line 1112
  if (tmp___0 == 7) {
#line 1112
    goto case_7___0;
  }
#line 1115
  if (tmp___0 == 24) {
#line 1115
    goto case_24___0;
  }
#line 1115
  if (tmp___0 == 22) {
#line 1115
    goto case_24___0;
  }
#line 1123
  if (tmp___0 == 23) {
#line 1123
    goto case_23;
  }
#line 1123
  if (tmp___0 == 27) {
#line 1123
    goto case_23;
  }
#line 1123
  if (tmp___0 == 26) {
#line 1123
    goto case_23;
  }
#line 1123
  if (tmp___0 == 25) {
#line 1123
    goto case_23;
  }
#line 1128
  if (tmp___0 == 29) {
#line 1128
    goto case_29___0;
  }
#line 1140
  goto switch_default___0;
  case_12: /* CIL Label */ 
  {
#line 989
  tmp___1 = big2_scanLit(12, enc, ptr + 2, end, nextTokPtr);
  }
#line 989
  return (tmp___1);
  case_13: /* CIL Label */ 
  {
#line 991
  tmp___2 = big2_scanLit(13, enc, ptr + 2, end, nextTokPtr);
  }
#line 991
  return (tmp___2);
  case_2: /* CIL Label */ 
#line 994
  ptr += 2;
#line 995
  if ((unsigned long )ptr == (unsigned long )end) {
#line 996
    return (-1);
  }
#line 997
  if ((int const   )*(ptr + 0) == 0) {
#line 997
    tmp___4 = (int )((struct normal_encoding *)enc)->type[(unsigned char )*(ptr + 1)];
  } else {
    {
#line 997
    tmp___3 = unicode_byte_type((char )*(ptr + 0), (char )*(ptr + 1));
#line 997
    tmp___4 = tmp___3;
    }
  }
  {
#line 998
  if (tmp___4 == 16) {
#line 998
    goto case_16;
  }
#line 1000
  if (tmp___4 == 15) {
#line 1000
    goto case_15;
  }
#line 1007
  if (tmp___4 == 7) {
#line 1007
    goto case_7;
  }
#line 1007
  if (tmp___4 == 6) {
#line 1007
    goto case_7;
  }
#line 1007
  if (tmp___4 == 5) {
#line 1007
    goto case_7;
  }
#line 1007
  if (tmp___4 == 29) {
#line 1007
    goto case_7;
  }
#line 1007
  if (tmp___4 == 24) {
#line 1007
    goto case_7;
  }
#line 1007
  if (tmp___4 == 22) {
#line 1007
    goto case_7;
  }
#line 997
  goto switch_break___0;
  case_16: /* CIL Label */ 
  {
#line 999
  tmp___5 = big2_scanDecl(enc, ptr + 2, end, nextTokPtr);
  }
#line 999
  return (tmp___5);
  case_15: /* CIL Label */ 
  {
#line 1001
  tmp___6 = big2_scanPi(enc, ptr + 2, end, nextTokPtr);
  }
#line 1001
  return (tmp___6);
  case_7: /* CIL Label */ 
  case_6: /* CIL Label */ 
  case_5: /* CIL Label */ 
  case_29: /* CIL Label */ 
  case_24: /* CIL Label */ 
  case_22: /* CIL Label */ 
#line 1008
  *nextTokPtr = ptr - 2;
#line 1009
  return (29);
  switch_break___0: /* CIL Label */ ;
  }
#line 1011
  *nextTokPtr = ptr;
#line 1012
  return (0);
  case_9: /* CIL Label */ 
#line 1015
  if ((unsigned long )(ptr + 2) == (unsigned long )end) {
#line 1016
    *nextTokPtr = end;
#line 1018
    return (-15);
  }
  case_10: /* CIL Label */ 
  case_21: /* CIL Label */ 
  {
#line 1022
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1023
    ptr += 2;
#line 1024
    if ((unsigned long )ptr == (unsigned long )end) {
#line 1025
      goto while_break;
    }
#line 1026
    if ((int const   )*(ptr + 0) == 0) {
#line 1026
      tmp___8 = (int )((struct normal_encoding *)enc)->type[(unsigned char )*(ptr + 1)];
    } else {
      {
#line 1026
      tmp___7 = unicode_byte_type((char )*(ptr + 0), (char )*(ptr + 1));
#line 1026
      tmp___8 = tmp___7;
      }
    }
    {
#line 1027
    if (tmp___8 == 10) {
#line 1027
      goto case_10___0;
    }
#line 1027
    if (tmp___8 == 21) {
#line 1027
      goto case_10___0;
    }
#line 1029
    if (tmp___8 == 9) {
#line 1029
      goto case_9___0;
    }
#line 1034
    goto switch_default;
    case_10___0: /* CIL Label */ 
    case_21___0: /* CIL Label */ 
#line 1028
    goto switch_break___1;
    case_9___0: /* CIL Label */ 
#line 1031
    if ((unsigned long )(ptr + 2) != (unsigned long )end) {
#line 1032
      goto switch_break___1;
    }
    switch_default: /* CIL Label */ 
#line 1035
    *nextTokPtr = ptr;
#line 1036
    return (15);
    switch_break___1: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1039
  *nextTokPtr = ptr;
#line 1040
  return (15);
  case_30: /* CIL Label */ 
  {
#line 1042
  tmp___9 = big2_scanPercent(enc, ptr + 2, end, nextTokPtr);
  }
#line 1042
  return (tmp___9);
  case_35: /* CIL Label */ 
#line 1044
  *nextTokPtr = ptr + 2;
#line 1045
  return (38);
  case_20: /* CIL Label */ 
#line 1047
  *nextTokPtr = ptr + 2;
#line 1048
  return (25);
  case_4: /* CIL Label */ 
#line 1050
  ptr += 2;
#line 1051
  if ((unsigned long )ptr == (unsigned long )end) {
#line 1052
    return (-26);
  }
#line 1053
  if ((int const   )*(ptr + 0) == 0) {
#line 1053
    if ((int const   )*(ptr + 1) == 93) {
#line 1054
      if ((unsigned long )(ptr + 2) == (unsigned long )end) {
#line 1055
        return (-1);
      }
#line 1056
      if ((int const   )*((ptr + 2) + 0) == 0) {
#line 1056
        if ((int const   )*((ptr + 2) + 1) == 62) {
#line 1057
          *nextTokPtr = ptr + 4;
#line 1058
          return (34);
        }
      }
    }
  }
#line 1061
  *nextTokPtr = ptr;
#line 1062
  return (26);
  case_31: /* CIL Label */ 
#line 1064
  *nextTokPtr = ptr + 2;
#line 1065
  return (23);
  case_32: /* CIL Label */ 
#line 1067
  ptr += 2;
#line 1068
  if ((unsigned long )ptr == (unsigned long )end) {
#line 1069
    return (-24);
  }
#line 1070
  if ((int const   )*(ptr + 0) == 0) {
#line 1070
    tmp___11 = (int )((struct normal_encoding *)enc)->type[(unsigned char )*(ptr + 1)];
  } else {
    {
#line 1070
    tmp___10 = unicode_byte_type((char )*(ptr + 0), (char )*(ptr + 1));
#line 1070
    tmp___11 = tmp___10;
    }
  }
  {
#line 1071
  if (tmp___11 == 33) {
#line 1071
    goto case_33;
  }
#line 1074
  if (tmp___11 == 15) {
#line 1074
    goto case_15___0;
  }
#line 1077
  if (tmp___11 == 34) {
#line 1077
    goto case_34;
  }
#line 1082
  if (tmp___11 == 32) {
#line 1082
    goto case_32___0;
  }
#line 1082
  if (tmp___11 == 36) {
#line 1082
    goto case_32___0;
  }
#line 1082
  if (tmp___11 == 35) {
#line 1082
    goto case_32___0;
  }
#line 1082
  if (tmp___11 == 11) {
#line 1082
    goto case_32___0;
  }
#line 1082
  if (tmp___11 == 21) {
#line 1082
    goto case_32___0;
  }
#line 1082
  if (tmp___11 == 10) {
#line 1082
    goto case_32___0;
  }
#line 1082
  if (tmp___11 == 9) {
#line 1082
    goto case_32___0;
  }
#line 1070
  goto switch_break___2;
  case_33: /* CIL Label */ 
#line 1072
  *nextTokPtr = ptr + 2;
#line 1073
  return (36);
  case_15___0: /* CIL Label */ 
#line 1075
  *nextTokPtr = ptr + 2;
#line 1076
  return (35);
  case_34: /* CIL Label */ 
#line 1078
  *nextTokPtr = ptr + 2;
#line 1079
  return (37);
  case_32___0: /* CIL Label */ 
  case_36: /* CIL Label */ 
  case_35___0: /* CIL Label */ 
  case_11: /* CIL Label */ 
  case_21___1: /* CIL Label */ 
  case_10___1: /* CIL Label */ 
  case_9___1: /* CIL Label */ 
#line 1083
  *nextTokPtr = ptr;
#line 1084
  return (24);
  switch_break___2: /* CIL Label */ ;
  }
#line 1086
  *nextTokPtr = ptr;
#line 1087
  return (0);
  case_36___0: /* CIL Label */ 
#line 1089
  *nextTokPtr = ptr + 2;
#line 1090
  return (21);
  case_11___0: /* CIL Label */ 
#line 1092
  *nextTokPtr = ptr + 2;
#line 1093
  return (17);
  case_19: /* CIL Label */ 
  {
#line 1095
  tmp___12 = big2_scanPoundName(enc, ptr + 2, end, nextTokPtr);
  }
#line 1095
  return (tmp___12);
  case_5___0: /* CIL Label */ 
#line 1112
  if (end - ptr < 2L) {
#line 1112
    return (-2);
  }
#line 1112
  *nextTokPtr = ptr;
#line 1112
  return (0);
  case_6___0: /* CIL Label */ 
#line 1112
  if (end - ptr < 3L) {
#line 1112
    return (-2);
  }
#line 1112
  *nextTokPtr = ptr;
#line 1112
  return (0);
  case_7___0: /* CIL Label */ 
#line 1112
  if (end - ptr < 4L) {
#line 1112
    return (-2);
  }
#line 1112
  *nextTokPtr = ptr;
#line 1112
  return (0);
  case_24___0: /* CIL Label */ 
  case_22___0: /* CIL Label */ 
#line 1116
  tok = 18;
#line 1117
  ptr += 2;
#line 1118
  goto switch_break;
  case_23: /* CIL Label */ 
  case_27: /* CIL Label */ 
  case_26: /* CIL Label */ 
  case_25: /* CIL Label */ 
#line 1125
  tok = 19;
#line 1126
  ptr += 2;
#line 1127
  goto switch_break;
  case_29___0: /* CIL Label */ 
#line 1129
  if (namingBitmap[((int const   )nmstrtPages[(unsigned char )*(ptr + 0)] << 3) + (int const   )((int )((unsigned char )*(ptr + 1)) >> 5)] & (unsigned int const   )(1 << ((int )((unsigned char )*(ptr + 1)) & 31))) {
#line 1130
    ptr += 2;
#line 1131
    tok = 18;
#line 1132
    goto switch_break;
  }
#line 1134
  if (namingBitmap[((int const   )namePages[(unsigned char )*(ptr + 0)] << 3) + (int const   )((int )((unsigned char )*(ptr + 1)) >> 5)] & (unsigned int const   )(1 << ((int )((unsigned char )*(ptr + 1)) & 31))) {
#line 1135
    ptr += 2;
#line 1136
    tok = 19;
#line 1137
    goto switch_break;
  }
  switch_default___0: /* CIL Label */ 
#line 1141
  *nextTokPtr = ptr;
#line 1142
  return (0);
  switch_break: /* CIL Label */ ;
  }
  {
#line 1144
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1144
    if (! ((unsigned long )ptr != (unsigned long )end)) {
#line 1144
      goto while_break___0;
    }
#line 1145
    if ((int const   )*(ptr + 0) == 0) {
#line 1145
      tmp___14 = (int )((struct normal_encoding *)enc)->type[(unsigned char )*(ptr + 1)];
    } else {
      {
#line 1145
      tmp___13 = unicode_byte_type((char )*(ptr + 0), (char )*(ptr + 1));
#line 1145
      tmp___14 = tmp___13;
      }
    }
    {
#line 1146
    if (tmp___14 == 29) {
#line 1146
      goto case_29___1;
    }
#line 1146
    if (tmp___14 == 27) {
#line 1146
      goto case_27___0;
    }
#line 1146
    if (tmp___14 == 26) {
#line 1146
      goto case_27___0;
    }
#line 1146
    if (tmp___14 == 25) {
#line 1146
      goto case_27___0;
    }
#line 1146
    if (tmp___14 == 24) {
#line 1146
      goto case_27___0;
    }
#line 1146
    if (tmp___14 == 22) {
#line 1146
      goto case_27___0;
    }
#line 1146
    if (tmp___14 == 5) {
#line 1146
      goto case_5___1;
    }
#line 1146
    if (tmp___14 == 6) {
#line 1146
      goto case_6___1;
    }
#line 1146
    if (tmp___14 == 7) {
#line 1146
      goto case_7___1;
    }
#line 1149
    if (tmp___14 == 10) {
#line 1149
      goto case_10___2;
    }
#line 1149
    if (tmp___14 == 9) {
#line 1149
      goto case_10___2;
    }
#line 1149
    if (tmp___14 == 21) {
#line 1149
      goto case_10___2;
    }
#line 1149
    if (tmp___14 == 30) {
#line 1149
      goto case_10___2;
    }
#line 1149
    if (tmp___14 == 20) {
#line 1149
      goto case_10___2;
    }
#line 1149
    if (tmp___14 == 36) {
#line 1149
      goto case_10___2;
    }
#line 1149
    if (tmp___14 == 35) {
#line 1149
      goto case_10___2;
    }
#line 1149
    if (tmp___14 == 32) {
#line 1149
      goto case_10___2;
    }
#line 1149
    if (tmp___14 == 11) {
#line 1149
      goto case_10___2;
    }
#line 1153
    if (tmp___14 == 23) {
#line 1153
      goto case_23___0;
    }
#line 1173
    if (tmp___14 == 34) {
#line 1173
      goto case_34___0;
    }
#line 1180
    if (tmp___14 == 33) {
#line 1180
      goto case_33___0;
    }
#line 1187
    if (tmp___14 == 15) {
#line 1187
      goto case_15___1;
    }
#line 1194
    goto switch_default___2;
    case_29___1: /* CIL Label */ 
#line 1146
    if (! (namingBitmap[((int const   )namePages[(unsigned char )*(ptr + 0)] << 3) + (int const   )((int )((unsigned char )*(ptr + 1)) >> 5)] & (unsigned int const   )(1 << ((int )((unsigned char )*(ptr + 1)) & 31)))) {
#line 1146
      *nextTokPtr = ptr;
#line 1146
      return (0);
    }
    case_27___0: /* CIL Label */ 
    case_26___0: /* CIL Label */ 
    case_25___0: /* CIL Label */ 
    case_24___1: /* CIL Label */ 
    case_22___1: /* CIL Label */ 
#line 1146
    ptr += 2;
#line 1146
    goto switch_break___3;
    case_5___1: /* CIL Label */ 
#line 1146
    if (end - ptr < 2L) {
#line 1146
      return (-2);
    }
#line 1146
    *nextTokPtr = ptr;
#line 1146
    return (0);
#line 1146
    ptr += 2;
#line 1146
    goto switch_break___3;
    case_6___1: /* CIL Label */ 
#line 1146
    if (end - ptr < 3L) {
#line 1146
      return (-2);
    }
#line 1146
    *nextTokPtr = ptr;
#line 1146
    return (0);
#line 1146
    ptr += 3;
#line 1146
    goto switch_break___3;
    case_7___1: /* CIL Label */ 
#line 1146
    if (end - ptr < 4L) {
#line 1146
      return (-2);
    }
#line 1146
    *nextTokPtr = ptr;
#line 1146
    return (0);
#line 1146
    ptr += 4;
#line 1146
    goto switch_break___3;
    case_10___2: /* CIL Label */ 
    case_9___2: /* CIL Label */ 
    case_21___2: /* CIL Label */ 
    case_30___0: /* CIL Label */ 
    case_20___0: /* CIL Label */ 
    case_36___1: /* CIL Label */ 
    case_35___1: /* CIL Label */ 
    case_32___1: /* CIL Label */ 
    case_11___1: /* CIL Label */ 
#line 1150
    *nextTokPtr = ptr;
#line 1151
    return (tok);
    case_23___0: /* CIL Label */ 
#line 1154
    ptr += 2;
    {
#line 1156
    if (tok == 18) {
#line 1156
      goto case_18;
    }
#line 1167
    if (tok == 41) {
#line 1167
      goto case_41;
    }
#line 1155
    goto switch_break___4;
    case_18: /* CIL Label */ 
#line 1157
    if ((unsigned long )ptr == (unsigned long )end) {
#line 1158
      return (-1);
    }
#line 1159
    tok = 41;
#line 1160
    if ((int const   )*(ptr + 0) == 0) {
#line 1160
      tmp___16 = (int )((struct normal_encoding *)enc)->type[(unsigned char )*(ptr + 1)];
    } else {
      {
#line 1160
      tmp___15 = unicode_byte_type((char )*(ptr + 0), (char )*(ptr + 1));
#line 1160
      tmp___16 = tmp___15;
      }
    }
    {
#line 1161
    if (tmp___16 == 29) {
#line 1161
      goto case_29___2;
    }
#line 1161
    if (tmp___16 == 27) {
#line 1161
      goto case_27___1;
    }
#line 1161
    if (tmp___16 == 26) {
#line 1161
      goto case_27___1;
    }
#line 1161
    if (tmp___16 == 25) {
#line 1161
      goto case_27___1;
    }
#line 1161
    if (tmp___16 == 24) {
#line 1161
      goto case_27___1;
    }
#line 1161
    if (tmp___16 == 22) {
#line 1161
      goto case_27___1;
    }
#line 1161
    if (tmp___16 == 5) {
#line 1161
      goto case_5___2;
    }
#line 1161
    if (tmp___16 == 6) {
#line 1161
      goto case_6___2;
    }
#line 1161
    if (tmp___16 == 7) {
#line 1161
      goto case_7___2;
    }
#line 1162
    goto switch_default___1;
    case_29___2: /* CIL Label */ 
#line 1161
    if (! (namingBitmap[((int const   )namePages[(unsigned char )*(ptr + 0)] << 3) + (int const   )((int )((unsigned char )*(ptr + 1)) >> 5)] & (unsigned int const   )(1 << ((int )((unsigned char )*(ptr + 1)) & 31)))) {
#line 1161
      *nextTokPtr = ptr;
#line 1161
      return (0);
    }
    case_27___1: /* CIL Label */ 
    case_26___1: /* CIL Label */ 
    case_25___1: /* CIL Label */ 
    case_24___2: /* CIL Label */ 
    case_22___2: /* CIL Label */ 
#line 1161
    ptr += 2;
#line 1161
    goto switch_break___5;
    case_5___2: /* CIL Label */ 
#line 1161
    if (end - ptr < 2L) {
#line 1161
      return (-2);
    }
#line 1161
    *nextTokPtr = ptr;
#line 1161
    return (0);
#line 1161
    ptr += 2;
#line 1161
    goto switch_break___5;
    case_6___2: /* CIL Label */ 
#line 1161
    if (end - ptr < 3L) {
#line 1161
      return (-2);
    }
#line 1161
    *nextTokPtr = ptr;
#line 1161
    return (0);
#line 1161
    ptr += 3;
#line 1161
    goto switch_break___5;
    case_7___2: /* CIL Label */ 
#line 1161
    if (end - ptr < 4L) {
#line 1161
      return (-2);
    }
#line 1161
    *nextTokPtr = ptr;
#line 1161
    return (0);
#line 1161
    ptr += 4;
#line 1161
    goto switch_break___5;
    switch_default___1: /* CIL Label */ 
#line 1163
    tok = 19;
#line 1164
    goto switch_break___5;
    switch_break___5: /* CIL Label */ ;
    }
#line 1166
    goto switch_break___4;
    case_41: /* CIL Label */ 
#line 1168
    tok = 19;
#line 1169
    goto switch_break___4;
    switch_break___4: /* CIL Label */ ;
    }
#line 1171
    goto switch_break___3;
    case_34___0: /* CIL Label */ 
#line 1174
    if (tok == 19) {
#line 1175
      *nextTokPtr = ptr;
#line 1176
      return (0);
    }
#line 1178
    *nextTokPtr = ptr + 2;
#line 1179
    return (32);
    case_33___0: /* CIL Label */ 
#line 1181
    if (tok == 19) {
#line 1182
      *nextTokPtr = ptr;
#line 1183
      return (0);
    }
#line 1185
    *nextTokPtr = ptr + 2;
#line 1186
    return (31);
    case_15___1: /* CIL Label */ 
#line 1188
    if (tok == 19) {
#line 1189
      *nextTokPtr = ptr;
#line 1190
      return (0);
    }
#line 1192
    *nextTokPtr = ptr + 2;
#line 1193
    return (30);
    switch_default___2: /* CIL Label */ 
#line 1195
    *nextTokPtr = ptr;
#line 1196
    return (0);
    switch_break___3: /* CIL Label */ ;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1199
  return (- tok);
}
}
#line 1202 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmltok_impl.c"
static int big2_attributeValueTok(ENCODING const   *enc , char const   *ptr , char const   *end ,
                                  char const   **nextTokPtr ) 
{ 
  char const   *start ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 1207
  if ((unsigned long )ptr == (unsigned long )end) {
#line 1208
    return (-4);
  }
#line 1209
  start = ptr;
  {
#line 1210
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1210
    if (! ((unsigned long )ptr != (unsigned long )end)) {
#line 1210
      goto while_break;
    }
#line 1211
    if ((int const   )*(ptr + 0) == 0) {
#line 1211
      tmp___0 = (int )((struct normal_encoding *)enc)->type[(unsigned char )*(ptr + 1)];
    } else {
      {
#line 1211
      tmp = unicode_byte_type((char )*(ptr + 0), (char )*(ptr + 1));
#line 1211
      tmp___0 = tmp;
      }
    }
    {
#line 1214
    if (tmp___0 == 5) {
#line 1214
      goto case_5;
    }
#line 1214
    if (tmp___0 == 6) {
#line 1214
      goto case_6;
    }
#line 1214
    if (tmp___0 == 7) {
#line 1214
      goto case_7;
    }
#line 1216
    if (tmp___0 == 3) {
#line 1216
      goto case_3;
    }
#line 1221
    if (tmp___0 == 2) {
#line 1221
      goto case_2;
    }
#line 1225
    if (tmp___0 == 10) {
#line 1225
      goto case_10;
    }
#line 1232
    if (tmp___0 == 9) {
#line 1232
      goto case_9;
    }
#line 1244
    if (tmp___0 == 21) {
#line 1244
      goto case_21;
    }
#line 1251
    goto switch_default;
    case_5: /* CIL Label */ 
#line 1214
    ptr += 2;
#line 1214
    goto switch_break;
    case_6: /* CIL Label */ 
#line 1214
    ptr += 3;
#line 1214
    goto switch_break;
    case_7: /* CIL Label */ 
#line 1214
    ptr += 4;
#line 1214
    goto switch_break;
    case_3: /* CIL Label */ 
#line 1217
    if ((unsigned long )ptr == (unsigned long )start) {
      {
#line 1218
      tmp___1 = big2_scanRef(enc, ptr + 2, end, nextTokPtr);
      }
#line 1218
      return (tmp___1);
    }
#line 1219
    *nextTokPtr = ptr;
#line 1220
    return (6);
    case_2: /* CIL Label */ 
#line 1223
    *nextTokPtr = ptr;
#line 1224
    return (0);
    case_10: /* CIL Label */ 
#line 1226
    if ((unsigned long )ptr == (unsigned long )start) {
#line 1227
      *nextTokPtr = ptr + 2;
#line 1228
      return (7);
    }
#line 1230
    *nextTokPtr = ptr;
#line 1231
    return (6);
    case_9: /* CIL Label */ 
#line 1233
    if ((unsigned long )ptr == (unsigned long )start) {
#line 1234
      ptr += 2;
#line 1235
      if ((unsigned long )ptr == (unsigned long )end) {
#line 1236
        return (-3);
      }
#line 1237
      if ((int const   )*(ptr + 0) == 0) {
#line 1237
        tmp___3 = (int )((struct normal_encoding *)enc)->type[(unsigned char )*(ptr + 1)];
      } else {
        {
#line 1237
        tmp___2 = unicode_byte_type((char )*(ptr + 0), (char )*(ptr + 1));
#line 1237
        tmp___3 = tmp___2;
        }
      }
#line 1237
      if (tmp___3 == 10) {
#line 1238
        ptr += 2;
      }
#line 1239
      *nextTokPtr = ptr;
#line 1240
      return (7);
    }
#line 1242
    *nextTokPtr = ptr;
#line 1243
    return (6);
    case_21: /* CIL Label */ 
#line 1245
    if ((unsigned long )ptr == (unsigned long )start) {
#line 1246
      *nextTokPtr = ptr + 2;
#line 1247
      return (39);
    }
#line 1249
    *nextTokPtr = ptr;
#line 1250
    return (6);
    switch_default: /* CIL Label */ 
#line 1252
    ptr += 2;
#line 1253
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1256
  *nextTokPtr = ptr;
#line 1257
  return (6);
}
}
#line 1260 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmltok_impl.c"
static int big2_entityValueTok(ENCODING const   *enc , char const   *ptr , char const   *end ,
                               char const   **nextTokPtr ) 
{ 
  char const   *start ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tok ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 1265
  if ((unsigned long )ptr == (unsigned long )end) {
#line 1266
    return (-4);
  }
#line 1267
  start = ptr;
  {
#line 1268
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1268
    if (! ((unsigned long )ptr != (unsigned long )end)) {
#line 1268
      goto while_break;
    }
#line 1269
    if ((int const   )*(ptr + 0) == 0) {
#line 1269
      tmp___0 = (int )((struct normal_encoding *)enc)->type[(unsigned char )*(ptr + 1)];
    } else {
      {
#line 1269
      tmp = unicode_byte_type((char )*(ptr + 0), (char )*(ptr + 1));
#line 1269
      tmp___0 = tmp;
      }
    }
    {
#line 1272
    if (tmp___0 == 5) {
#line 1272
      goto case_5;
    }
#line 1272
    if (tmp___0 == 6) {
#line 1272
      goto case_6;
    }
#line 1272
    if (tmp___0 == 7) {
#line 1272
      goto case_7;
    }
#line 1274
    if (tmp___0 == 3) {
#line 1274
      goto case_3;
    }
#line 1279
    if (tmp___0 == 30) {
#line 1279
      goto case_30;
    }
#line 1287
    if (tmp___0 == 10) {
#line 1287
      goto case_10;
    }
#line 1294
    if (tmp___0 == 9) {
#line 1294
      goto case_9;
    }
#line 1306
    goto switch_default;
    case_5: /* CIL Label */ 
#line 1272
    ptr += 2;
#line 1272
    goto switch_break;
    case_6: /* CIL Label */ 
#line 1272
    ptr += 3;
#line 1272
    goto switch_break;
    case_7: /* CIL Label */ 
#line 1272
    ptr += 4;
#line 1272
    goto switch_break;
    case_3: /* CIL Label */ 
#line 1275
    if ((unsigned long )ptr == (unsigned long )start) {
      {
#line 1276
      tmp___1 = big2_scanRef(enc, ptr + 2, end, nextTokPtr);
      }
#line 1276
      return (tmp___1);
    }
#line 1277
    *nextTokPtr = ptr;
#line 1278
    return (6);
    case_30: /* CIL Label */ 
#line 1280
    if ((unsigned long )ptr == (unsigned long )start) {
      {
#line 1281
      tmp___2 = big2_scanPercent(enc, ptr + 2, end, nextTokPtr);
#line 1281
      tok = tmp___2;
      }
#line 1283
      if (tok == 22) {
#line 1283
        tmp___3 = 0;
      } else {
#line 1283
        tmp___3 = tok;
      }
#line 1283
      return (tmp___3);
    }
#line 1285
    *nextTokPtr = ptr;
#line 1286
    return (6);
    case_10: /* CIL Label */ 
#line 1288
    if ((unsigned long )ptr == (unsigned long )start) {
#line 1289
      *nextTokPtr = ptr + 2;
#line 1290
      return (7);
    }
#line 1292
    *nextTokPtr = ptr;
#line 1293
    return (6);
    case_9: /* CIL Label */ 
#line 1295
    if ((unsigned long )ptr == (unsigned long )start) {
#line 1296
      ptr += 2;
#line 1297
      if ((unsigned long )ptr == (unsigned long )end) {
#line 1298
        return (-3);
      }
#line 1299
      if ((int const   )*(ptr + 0) == 0) {
#line 1299
        tmp___5 = (int )((struct normal_encoding *)enc)->type[(unsigned char )*(ptr + 1)];
      } else {
        {
#line 1299
        tmp___4 = unicode_byte_type((char )*(ptr + 0), (char )*(ptr + 1));
#line 1299
        tmp___5 = tmp___4;
        }
      }
#line 1299
      if (tmp___5 == 10) {
#line 1300
        ptr += 2;
      }
#line 1301
      *nextTokPtr = ptr;
#line 1302
      return (7);
    }
#line 1304
    *nextTokPtr = ptr;
#line 1305
    return (6);
    switch_default: /* CIL Label */ 
#line 1307
    ptr += 2;
#line 1308
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1311
  *nextTokPtr = ptr;
#line 1312
  return (6);
}
}
#line 1317 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmltok_impl.c"
static int big2_ignoreSectionTok(ENCODING const   *enc , char const   *ptr , char const   *end ,
                                 char const   **nextTokPtr ) 
{ 
  int level ;
  size_t n ;
  int tmp ;
  int tmp___0 ;

  {
#line 1321
  level = 0;
#line 1323
  n = (size_t )(end - ptr);
#line 1324
  if (n & 1UL) {
#line 1325
    n &= 0xfffffffffffffffeUL;
#line 1326
    end = ptr + n;
  }
  {
#line 1329
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1329
    if (! ((unsigned long )ptr != (unsigned long )end)) {
#line 1329
      goto while_break;
    }
#line 1330
    if ((int const   )*(ptr + 0) == 0) {
#line 1330
      tmp___0 = (int )((struct normal_encoding *)enc)->type[(unsigned char )*(ptr + 1)];
    } else {
      {
#line 1330
      tmp = unicode_byte_type((char )*(ptr + 0), (char )*(ptr + 1));
#line 1330
      tmp___0 = tmp;
      }
    }
    {
#line 1331
    if (tmp___0 == 5) {
#line 1331
      goto case_5;
    }
#line 1331
    if (tmp___0 == 6) {
#line 1331
      goto case_6;
    }
#line 1331
    if (tmp___0 == 7) {
#line 1331
      goto case_7;
    }
#line 1331
    if (tmp___0 == 8) {
#line 1331
      goto case_8;
    }
#line 1331
    if (tmp___0 == 1) {
#line 1331
      goto case_8;
    }
#line 1331
    if (tmp___0 == 0) {
#line 1331
      goto case_8;
    }
#line 1332
    if (tmp___0 == 2) {
#line 1332
      goto case_2;
    }
#line 1344
    if (tmp___0 == 4) {
#line 1344
      goto case_4;
    }
#line 1360
    goto switch_default;
    case_5: /* CIL Label */ 
#line 1331
    if (end - ptr < 2L) {
#line 1331
      return (-2);
    }
#line 1331
    ptr += 2;
#line 1331
    goto switch_break;
    case_6: /* CIL Label */ 
#line 1331
    if (end - ptr < 3L) {
#line 1331
      return (-2);
    }
#line 1331
    ptr += 3;
#line 1331
    goto switch_break;
    case_7: /* CIL Label */ 
#line 1331
    if (end - ptr < 4L) {
#line 1331
      return (-2);
    }
#line 1331
    ptr += 4;
#line 1331
    goto switch_break;
    case_8: /* CIL Label */ 
    case_1: /* CIL Label */ 
    case_0: /* CIL Label */ 
#line 1331
    *nextTokPtr = ptr;
#line 1331
    return (0);
    case_2: /* CIL Label */ 
#line 1333
    ptr += 2;
#line 1333
    if ((unsigned long )ptr == (unsigned long )end) {
#line 1334
      return (-1);
    }
#line 1335
    if ((int const   )*(ptr + 0) == 0) {
#line 1335
      if ((int const   )*(ptr + 1) == 33) {
#line 1336
        ptr += 2;
#line 1336
        if ((unsigned long )ptr == (unsigned long )end) {
#line 1337
          return (-1);
        }
#line 1338
        if ((int const   )*(ptr + 0) == 0) {
#line 1338
          if ((int const   )*(ptr + 1) == 91) {
#line 1339
            level ++;
#line 1340
            ptr += 2;
          }
        }
      }
    }
#line 1343
    goto switch_break;
    case_4: /* CIL Label */ 
#line 1345
    ptr += 2;
#line 1345
    if ((unsigned long )ptr == (unsigned long )end) {
#line 1346
      return (-1);
    }
#line 1347
    if ((int const   )*(ptr + 0) == 0) {
#line 1347
      if ((int const   )*(ptr + 1) == 93) {
#line 1348
        ptr += 2;
#line 1348
        if ((unsigned long )ptr == (unsigned long )end) {
#line 1349
          return (-1);
        }
#line 1350
        if ((int const   )*(ptr + 0) == 0) {
#line 1350
          if ((int const   )*(ptr + 1) == 62) {
#line 1351
            ptr += 2;
#line 1352
            if (level == 0) {
#line 1353
              *nextTokPtr = ptr;
#line 1354
              return (42);
            }
#line 1356
            level --;
          }
        }
      }
    }
#line 1359
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 1361
    ptr += 2;
#line 1362
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1365
  return (-1);
}
}
#line 1370 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmltok_impl.c"
static int big2_isPublicId(ENCODING const   *enc , char const   *ptr , char const   *end ,
                           char const   **badPtr ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 1374
  ptr += 2;
#line 1375
  end -= 2;
  {
#line 1376
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1376
    if (! ((unsigned long )ptr != (unsigned long )end)) {
#line 1376
      goto while_break;
    }
#line 1377
    if ((int const   )*(ptr + 0) == 0) {
#line 1377
      tmp___0 = (int )((struct normal_encoding *)enc)->type[(unsigned char )*(ptr + 1)];
    } else {
      {
#line 1377
      tmp = unicode_byte_type((char )*(ptr + 0), (char )*(ptr + 1));
#line 1377
      tmp___0 = tmp;
      }
    }
    {
#line 1397
    if (tmp___0 == 23) {
#line 1397
      goto case_23;
    }
#line 1397
    if (tmp___0 == 19) {
#line 1397
      goto case_23;
    }
#line 1397
    if (tmp___0 == 30) {
#line 1397
      goto case_23;
    }
#line 1397
    if (tmp___0 == 33) {
#line 1397
      goto case_23;
    }
#line 1397
    if (tmp___0 == 16) {
#line 1397
      goto case_23;
    }
#line 1397
    if (tmp___0 == 18) {
#line 1397
      goto case_23;
    }
#line 1397
    if (tmp___0 == 10) {
#line 1397
      goto case_23;
    }
#line 1397
    if (tmp___0 == 9) {
#line 1397
      goto case_23;
    }
#line 1397
    if (tmp___0 == 15) {
#line 1397
      goto case_23;
    }
#line 1397
    if (tmp___0 == 14) {
#line 1397
      goto case_23;
    }
#line 1397
    if (tmp___0 == 17) {
#line 1397
      goto case_23;
    }
#line 1397
    if (tmp___0 == 35) {
#line 1397
      goto case_23;
    }
#line 1397
    if (tmp___0 == 34) {
#line 1397
      goto case_23;
    }
#line 1397
    if (tmp___0 == 32) {
#line 1397
      goto case_23;
    }
#line 1397
    if (tmp___0 == 31) {
#line 1397
      goto case_23;
    }
#line 1397
    if (tmp___0 == 13) {
#line 1397
      goto case_23;
    }
#line 1397
    if (tmp___0 == 27) {
#line 1397
      goto case_23;
    }
#line 1397
    if (tmp___0 == 24) {
#line 1397
      goto case_23;
    }
#line 1397
    if (tmp___0 == 25) {
#line 1397
      goto case_23;
    }
#line 1400
    if (tmp___0 == 21) {
#line 1400
      goto case_21;
    }
#line 1407
    if (tmp___0 == 22) {
#line 1407
      goto case_22;
    }
#line 1407
    if (tmp___0 == 26) {
#line 1407
      goto case_22;
    }
#line 1410
    goto switch_default;
    case_23: /* CIL Label */ 
    case_19: /* CIL Label */ 
    case_30: /* CIL Label */ 
    case_33: /* CIL Label */ 
    case_16: /* CIL Label */ 
    case_18: /* CIL Label */ 
    case_10: /* CIL Label */ 
    case_9: /* CIL Label */ 
    case_15: /* CIL Label */ 
    case_14: /* CIL Label */ 
    case_17: /* CIL Label */ 
    case_35: /* CIL Label */ 
    case_34: /* CIL Label */ 
    case_32: /* CIL Label */ 
    case_31: /* CIL Label */ 
    case_13: /* CIL Label */ 
    case_27: /* CIL Label */ 
    case_24: /* CIL Label */ 
    case_25: /* CIL Label */ 
#line 1399
    goto switch_break;
    case_21: /* CIL Label */ 
#line 1401
    if ((int const   )*(ptr + 0) == 0) {
#line 1401
      if ((int const   )*(ptr + 1) == 9) {
#line 1402
        *badPtr = ptr;
#line 1403
        return (0);
      }
    }
#line 1405
    goto switch_break;
    case_22: /* CIL Label */ 
    case_26: /* CIL Label */ 
#line 1408
    if ((int const   )*(ptr + 0) == 0) {
#line 1408
      tmp___1 = (int const   )*(ptr + 1);
    } else {
#line 1408
      tmp___1 = (int const   )-1;
    }
#line 1408
    if (! (tmp___1 & -128)) {
#line 1409
      goto switch_break;
    }
    switch_default: /* CIL Label */ 
#line 1411
    if ((int const   )*(ptr + 0) == 0) {
#line 1411
      tmp___2 = (int const   )*(ptr + 1);
    } else {
#line 1411
      tmp___2 = (int const   )-1;
    }
    {
#line 1413
    if (tmp___2 == 64) {
#line 1413
      goto case_64;
    }
#line 1413
    if (tmp___2 == 36) {
#line 1413
      goto case_64;
    }
#line 1415
    goto switch_default___0;
    case_64: /* CIL Label */ 
    case_36: /* CIL Label */ 
#line 1414
    goto switch_break___0;
    switch_default___0: /* CIL Label */ 
#line 1416
    *badPtr = ptr;
#line 1417
    return (0);
    switch_break___0: /* CIL Label */ ;
    }
#line 1419
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 1376
    ptr += 2;
  }
  while_break: /* CIL Label */ ;
  }
#line 1422
  return (1);
}
}
#line 1430 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmltok_impl.c"
static int big2_getAtts(ENCODING const   *enc , char const   *ptr , int attsMax ,
                        ATTRIBUTE *atts ) 
{ 
  enum __anonenum_state_7 state ;
  int nAtts ;
  int open___0 ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 1434
  state = (enum __anonenum_state_7 )1;
#line 1435
  nAtts = 0;
#line 1436
  open___0 = 0;
#line 1439
  ptr += 2;
  {
#line 1439
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1440
    if ((int const   )*(ptr + 0) == 0) {
#line 1440
      tmp___0 = (int )((struct normal_encoding *)enc)->type[(unsigned char )*(ptr + 1)];
    } else {
      {
#line 1440
      tmp = unicode_byte_type((char )*(ptr + 0), (char )*(ptr + 1));
#line 1440
      tmp___0 = tmp;
      }
    }
    {
#line 1451
    if (tmp___0 == 5) {
#line 1451
      goto case_5;
    }
#line 1451
    if (tmp___0 == 6) {
#line 1451
      goto case_6;
    }
#line 1451
    if (tmp___0 == 7) {
#line 1451
      goto case_7;
    }
#line 1455
    if (tmp___0 == 24) {
#line 1455
      goto case_24;
    }
#line 1455
    if (tmp___0 == 22) {
#line 1455
      goto case_24;
    }
#line 1455
    if (tmp___0 == 29) {
#line 1455
      goto case_24;
    }
#line 1459
    if (tmp___0 == 12) {
#line 1459
      goto case_12;
    }
#line 1473
    if (tmp___0 == 13) {
#line 1473
      goto case_13;
    }
#line 1487
    if (tmp___0 == 3) {
#line 1487
      goto case_3;
    }
#line 1491
    if (tmp___0 == 21) {
#line 1491
      goto case_21;
    }
#line 1503
    if (tmp___0 == 10) {
#line 1503
      goto case_10;
    }
#line 1503
    if (tmp___0 == 9) {
#line 1503
      goto case_10;
    }
#line 1512
    if (tmp___0 == 17) {
#line 1512
      goto case_17;
    }
#line 1512
    if (tmp___0 == 11) {
#line 1512
      goto case_17;
    }
#line 1516
    goto switch_default;
    case_5: /* CIL Label */ 
#line 1451
    if ((unsigned int )state == 0U) {
#line 1451
      if (nAtts < attsMax) {
#line 1451
        (atts + nAtts)->name = ptr;
#line 1451
        (atts + nAtts)->normalized = (char)1;
      }
#line 1451
      state = (enum __anonenum_state_7 )1;
    }
#line 1451
    ptr += 0;
#line 1451
    goto switch_break;
    case_6: /* CIL Label */ 
#line 1451
    if ((unsigned int )state == 0U) {
#line 1451
      if (nAtts < attsMax) {
#line 1451
        (atts + nAtts)->name = ptr;
#line 1451
        (atts + nAtts)->normalized = (char)1;
      }
#line 1451
      state = (enum __anonenum_state_7 )1;
    }
#line 1451
    ptr ++;
#line 1451
    goto switch_break;
    case_7: /* CIL Label */ 
#line 1451
    if ((unsigned int )state == 0U) {
#line 1451
      if (nAtts < attsMax) {
#line 1451
        (atts + nAtts)->name = ptr;
#line 1451
        (atts + nAtts)->normalized = (char)1;
      }
#line 1451
      state = (enum __anonenum_state_7 )1;
    }
#line 1451
    ptr += 2;
#line 1451
    goto switch_break;
    case_24: /* CIL Label */ 
    case_22: /* CIL Label */ 
    case_29: /* CIL Label */ 
#line 1456
    if ((unsigned int )state == 0U) {
#line 1456
      if (nAtts < attsMax) {
#line 1456
        (atts + nAtts)->name = ptr;
#line 1456
        (atts + nAtts)->normalized = (char)1;
      }
#line 1456
      state = (enum __anonenum_state_7 )1;
    }
#line 1457
    goto switch_break;
    case_12: /* CIL Label */ 
#line 1460
    if ((unsigned int )state != 2U) {
#line 1461
      if (nAtts < attsMax) {
#line 1462
        (atts + nAtts)->valuePtr = ptr + 2;
      }
#line 1463
      state = (enum __anonenum_state_7 )2;
#line 1464
      open___0 = 12;
    } else
#line 1466
    if (open___0 == 12) {
#line 1467
      state = (enum __anonenum_state_7 )0;
#line 1468
      if (nAtts < attsMax) {
#line 1469
        (atts + nAtts)->valueEnd = ptr;
      }
#line 1470
      nAtts ++;
    }
#line 1472
    goto switch_break;
    case_13: /* CIL Label */ 
#line 1474
    if ((unsigned int )state != 2U) {
#line 1475
      if (nAtts < attsMax) {
#line 1476
        (atts + nAtts)->valuePtr = ptr + 2;
      }
#line 1477
      state = (enum __anonenum_state_7 )2;
#line 1478
      open___0 = 13;
    } else
#line 1480
    if (open___0 == 13) {
#line 1481
      state = (enum __anonenum_state_7 )0;
#line 1482
      if (nAtts < attsMax) {
#line 1483
        (atts + nAtts)->valueEnd = ptr;
      }
#line 1484
      nAtts ++;
    }
#line 1486
    goto switch_break;
    case_3: /* CIL Label */ 
#line 1488
    if (nAtts < attsMax) {
#line 1489
      (atts + nAtts)->normalized = (char)0;
    }
#line 1490
    goto switch_break;
    case_21: /* CIL Label */ 
#line 1492
    if ((unsigned int )state == 1U) {
#line 1493
      state = (enum __anonenum_state_7 )0;
    } else
#line 1494
    if ((unsigned int )state == 2U) {
#line 1494
      if (nAtts < attsMax) {
#line 1494
        if ((atts + nAtts)->normalized) {
#line 1494
          if ((unsigned long )ptr == (unsigned long )(atts + nAtts)->valuePtr) {
#line 1501
            (atts + nAtts)->normalized = (char)0;
          } else {
#line 1494
            if ((int const   )*(ptr + 0) == 0) {
#line 1494
              tmp___1 = (int const   )*(ptr + 1);
            } else {
#line 1494
              tmp___1 = (int const   )-1;
            }
#line 1494
            if (tmp___1 != 32) {
#line 1501
              (atts + nAtts)->normalized = (char)0;
            } else {
#line 1494
              if ((int const   )*((ptr + 2) + 0) == 0) {
#line 1494
                tmp___2 = (int const   )*((ptr + 2) + 1);
              } else {
#line 1494
                tmp___2 = (int const   )-1;
              }
#line 1494
              if (tmp___2 == 32) {
#line 1501
                (atts + nAtts)->normalized = (char)0;
              } else {
#line 1494
                if ((int const   )*((ptr + 2) + 0) == 0) {
#line 1494
                  tmp___4 = (int )((struct normal_encoding *)enc)->type[(unsigned char )*((ptr + 2) + 1)];
                } else {
                  {
#line 1494
                  tmp___3 = unicode_byte_type((char )*((ptr + 2) + 0), (char )*((ptr + 2) + 1));
#line 1494
                  tmp___4 = tmp___3;
                  }
                }
#line 1494
                if (tmp___4 == open___0) {
#line 1501
                  (atts + nAtts)->normalized = (char)0;
                }
              }
            }
          }
        }
      }
    }
#line 1502
    goto switch_break;
    case_10: /* CIL Label */ 
    case_9: /* CIL Label */ 
#line 1506
    if ((unsigned int )state == 1U) {
#line 1507
      state = (enum __anonenum_state_7 )0;
    } else
#line 1508
    if ((unsigned int )state == 2U) {
#line 1508
      if (nAtts < attsMax) {
#line 1509
        (atts + nAtts)->normalized = (char)0;
      }
    }
#line 1510
    goto switch_break;
    case_17: /* CIL Label */ 
    case_11: /* CIL Label */ 
#line 1513
    if ((unsigned int )state != 2U) {
#line 1514
      return (nAtts);
    }
#line 1515
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 1517
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 1439
    ptr += 2;
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 1523 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmltok_impl.c"
static int big2_charRefNumber(ENCODING const   *enc , char const   *ptr ) 
{ 
  int result ;
  int c___0 ;
  int tmp ;
  int c___1 ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 1526
  result = 0;
#line 1528
  ptr += 4;
#line 1529
  if ((int const   )*(ptr + 0) == 0) {
#line 1529
    if ((int const   )*(ptr + 1) == 120) {
#line 1530
      ptr += 2;
      {
#line 1530
      while (1) {
        while_continue: /* CIL Label */ ;
#line 1530
        if ((int const   )*(ptr + 0) == 0) {
#line 1530
          if ((int const   )*(ptr + 1) == 59) {
#line 1530
            goto while_break;
          }
        }
#line 1533
        if ((int const   )*(ptr + 0) == 0) {
#line 1533
          tmp = (int const   )*(ptr + 1);
        } else {
#line 1533
          tmp = (int const   )-1;
        }
#line 1533
        c___0 = (int )tmp;
        {
#line 1536
        if (c___0 == 57) {
#line 1536
          goto case_57;
        }
#line 1536
        if (c___0 == 56) {
#line 1536
          goto case_57;
        }
#line 1536
        if (c___0 == 55) {
#line 1536
          goto case_57;
        }
#line 1536
        if (c___0 == 54) {
#line 1536
          goto case_57;
        }
#line 1536
        if (c___0 == 53) {
#line 1536
          goto case_57;
        }
#line 1536
        if (c___0 == 52) {
#line 1536
          goto case_57;
        }
#line 1536
        if (c___0 == 51) {
#line 1536
          goto case_57;
        }
#line 1536
        if (c___0 == 50) {
#line 1536
          goto case_57;
        }
#line 1536
        if (c___0 == 49) {
#line 1536
          goto case_57;
        }
#line 1536
        if (c___0 == 48) {
#line 1536
          goto case_57;
        }
#line 1541
        if (c___0 == 70) {
#line 1541
          goto case_70;
        }
#line 1541
        if (c___0 == 69) {
#line 1541
          goto case_70;
        }
#line 1541
        if (c___0 == 68) {
#line 1541
          goto case_70;
        }
#line 1541
        if (c___0 == 67) {
#line 1541
          goto case_70;
        }
#line 1541
        if (c___0 == 66) {
#line 1541
          goto case_70;
        }
#line 1541
        if (c___0 == 65) {
#line 1541
          goto case_70;
        }
#line 1546
        if (c___0 == 102) {
#line 1546
          goto case_102;
        }
#line 1546
        if (c___0 == 101) {
#line 1546
          goto case_102;
        }
#line 1546
        if (c___0 == 100) {
#line 1546
          goto case_102;
        }
#line 1546
        if (c___0 == 99) {
#line 1546
          goto case_102;
        }
#line 1546
        if (c___0 == 98) {
#line 1546
          goto case_102;
        }
#line 1546
        if (c___0 == 97) {
#line 1546
          goto case_102;
        }
#line 1534
        goto switch_break;
        case_57: /* CIL Label */ 
        case_56: /* CIL Label */ 
        case_55: /* CIL Label */ 
        case_54: /* CIL Label */ 
        case_53: /* CIL Label */ 
        case_52: /* CIL Label */ 
        case_51: /* CIL Label */ 
        case_50: /* CIL Label */ 
        case_49: /* CIL Label */ 
        case_48: /* CIL Label */ 
#line 1537
        result <<= 4;
#line 1538
        result |= c___0 - 48;
#line 1539
        goto switch_break;
        case_70: /* CIL Label */ 
        case_69: /* CIL Label */ 
        case_68: /* CIL Label */ 
        case_67: /* CIL Label */ 
        case_66: /* CIL Label */ 
        case_65: /* CIL Label */ 
#line 1542
        result <<= 4;
#line 1543
        result += 10 + (c___0 - 65);
#line 1544
        goto switch_break;
        case_102: /* CIL Label */ 
        case_101: /* CIL Label */ 
        case_100: /* CIL Label */ 
        case_99: /* CIL Label */ 
        case_98: /* CIL Label */ 
        case_97: /* CIL Label */ 
#line 1547
        result <<= 4;
#line 1548
        result += 10 + (c___0 - 97);
#line 1549
        goto switch_break;
        switch_break: /* CIL Label */ ;
        }
#line 1551
        if (result >= 1114112) {
#line 1552
          return (-1);
        }
#line 1530
        ptr += 2;
      }
      while_break: /* CIL Label */ ;
      }
    } else {
#line 1529
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
    {
#line 1556
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1556
      if ((int const   )*(ptr + 0) == 0) {
#line 1556
        if ((int const   )*(ptr + 1) == 59) {
#line 1556
          goto while_break___0;
        }
      }
#line 1557
      if ((int const   )*(ptr + 0) == 0) {
#line 1557
        tmp___0 = (int const   )*(ptr + 1);
      } else {
#line 1557
        tmp___0 = (int const   )-1;
      }
#line 1557
      c___1 = (int )tmp___0;
#line 1558
      result *= 10;
#line 1559
      result += c___1 - 48;
#line 1560
      if (result >= 1114112) {
#line 1561
        return (-1);
      }
#line 1556
      ptr += 2;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  {
#line 1564
  tmp___1 = checkCharRefNumber(result);
  }
#line 1564
  return (tmp___1);
}
}
#line 1567 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmltok_impl.c"
static int big2_predefinedEntityName(ENCODING const   *enc , char const   *ptr , char const   *end ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  {
#line 1572
  if ((end - ptr) / 2L == 2L) {
#line 1572
    goto case_2;
  }
#line 1582
  if ((end - ptr) / 2L == 3L) {
#line 1582
    goto case_3;
  }
#line 1592
  if ((end - ptr) / 2L == 4L) {
#line 1592
    goto case_4;
  }
#line 1571
  goto switch_break;
  case_2: /* CIL Label */ 
#line 1573
  if ((int const   )*((ptr + 2) + 0) == 0) {
#line 1573
    if ((int const   )*((ptr + 2) + 1) == 116) {
#line 1574
      if ((int const   )*(ptr + 0) == 0) {
#line 1574
        tmp = (int const   )*(ptr + 1);
      } else {
#line 1574
        tmp = (int const   )-1;
      }
      {
#line 1575
      if (tmp == 108) {
#line 1575
        goto case_108;
      }
#line 1577
      if (tmp == 103) {
#line 1577
        goto case_103;
      }
#line 1574
      goto switch_break___0;
      case_108: /* CIL Label */ 
#line 1576
      return (60);
      case_103: /* CIL Label */ 
#line 1578
      return (62);
      switch_break___0: /* CIL Label */ ;
      }
    }
  }
#line 1581
  goto switch_break;
  case_3: /* CIL Label */ 
#line 1583
  if ((int const   )*(ptr + 0) == 0) {
#line 1583
    if ((int const   )*(ptr + 1) == 97) {
#line 1584
      ptr += 2;
#line 1585
      if ((int const   )*(ptr + 0) == 0) {
#line 1585
        if ((int const   )*(ptr + 1) == 109) {
#line 1586
          ptr += 2;
#line 1587
          if ((int const   )*(ptr + 0) == 0) {
#line 1587
            if ((int const   )*(ptr + 1) == 112) {
#line 1588
              return (38);
            }
          }
        }
      }
    }
  }
#line 1591
  goto switch_break;
  case_4: /* CIL Label */ 
#line 1593
  if ((int const   )*(ptr + 0) == 0) {
#line 1593
    tmp___0 = (int const   )*(ptr + 1);
  } else {
#line 1593
    tmp___0 = (int const   )-1;
  }
  {
#line 1594
  if (tmp___0 == 113) {
#line 1594
    goto case_113;
  }
#line 1605
  if (tmp___0 == 97) {
#line 1605
    goto case_97;
  }
#line 1593
  goto switch_break___1;
  case_113: /* CIL Label */ 
#line 1595
  ptr += 2;
#line 1596
  if ((int const   )*(ptr + 0) == 0) {
#line 1596
    if ((int const   )*(ptr + 1) == 117) {
#line 1597
      ptr += 2;
#line 1598
      if ((int const   )*(ptr + 0) == 0) {
#line 1598
        if ((int const   )*(ptr + 1) == 111) {
#line 1599
          ptr += 2;
#line 1600
          if ((int const   )*(ptr + 0) == 0) {
#line 1600
            if ((int const   )*(ptr + 1) == 116) {
#line 1601
              return (34);
            }
          }
        }
      }
    }
  }
#line 1604
  goto switch_break___1;
  case_97: /* CIL Label */ 
#line 1606
  ptr += 2;
#line 1607
  if ((int const   )*(ptr + 0) == 0) {
#line 1607
    if ((int const   )*(ptr + 1) == 112) {
#line 1608
      ptr += 2;
#line 1609
      if ((int const   )*(ptr + 0) == 0) {
#line 1609
        if ((int const   )*(ptr + 1) == 111) {
#line 1610
          ptr += 2;
#line 1611
          if ((int const   )*(ptr + 0) == 0) {
#line 1611
            if ((int const   )*(ptr + 1) == 115) {
#line 1612
              return (39);
            }
          }
        }
      }
    }
  }
#line 1615
  goto switch_break___1;
  switch_break___1: /* CIL Label */ ;
  }
  switch_break: /* CIL Label */ ;
  }
#line 1618
  return (0);
}
}
#line 1621 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmltok_impl.c"
static int big2_sameName(ENCODING const   *enc , char const   *ptr1 , char const   *ptr2 ) 
{ 
  int tmp ;
  int tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;
  char const   *tmp___4 ;
  char const   *tmp___5 ;
  char const   *tmp___6 ;
  char const   *tmp___7 ;
  char const   *tmp___8 ;
  char const   *tmp___9 ;
  char const   *tmp___10 ;
  char const   *tmp___11 ;
  char const   *tmp___12 ;
  int tmp___17 ;
  int tmp___18 ;

  {
  {
#line 1624
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1625
    if ((int const   )*(ptr1 + 0) == 0) {
#line 1625
      tmp___0 = (int )((struct normal_encoding *)enc)->type[(unsigned char )*(ptr1 + 1)];
    } else {
      {
#line 1625
      tmp = unicode_byte_type((char )*(ptr1 + 0), (char )*(ptr1 + 1));
#line 1625
      tmp___0 = tmp;
      }
    }
    {
#line 1630
    if (tmp___0 == 7) {
#line 1630
      goto case_7;
    }
#line 1630
    if (tmp___0 == 6) {
#line 1630
      goto case_6;
    }
#line 1630
    if (tmp___0 == 5) {
#line 1630
      goto case_5;
    }
#line 1644
    if (tmp___0 == 27) {
#line 1644
      goto case_27;
    }
#line 1644
    if (tmp___0 == 26) {
#line 1644
      goto case_27;
    }
#line 1644
    if (tmp___0 == 25) {
#line 1644
      goto case_27;
    }
#line 1644
    if (tmp___0 == 24) {
#line 1644
      goto case_27;
    }
#line 1644
    if (tmp___0 == 23) {
#line 1644
      goto case_27;
    }
#line 1644
    if (tmp___0 == 22) {
#line 1644
      goto case_27;
    }
#line 1644
    if (tmp___0 == 29) {
#line 1644
      goto case_27;
    }
#line 1660
    goto switch_default;
    case_7: /* CIL Label */ 
#line 1630
    tmp___1 = ptr1;
#line 1630
    ptr1 ++;
#line 1630
    tmp___2 = ptr2;
#line 1630
    ptr2 ++;
#line 1630
    if ((int const   )*tmp___1 != (int const   )*tmp___2) {
#line 1630
      return (0);
    }
    case_6: /* CIL Label */ 
#line 1630
    tmp___3 = ptr1;
#line 1630
    ptr1 ++;
#line 1630
    tmp___4 = ptr2;
#line 1630
    ptr2 ++;
#line 1630
    if ((int const   )*tmp___3 != (int const   )*tmp___4) {
#line 1630
      return (0);
    }
    case_5: /* CIL Label */ 
#line 1630
    tmp___5 = ptr1;
#line 1630
    ptr1 ++;
#line 1630
    tmp___6 = ptr2;
#line 1630
    ptr2 ++;
#line 1630
    if ((int const   )*tmp___5 != (int const   )*tmp___6) {
#line 1630
      return (0);
    }
#line 1633
    tmp___7 = ptr1;
#line 1633
    ptr1 ++;
#line 1633
    tmp___8 = ptr2;
#line 1633
    ptr2 ++;
#line 1633
    if ((int const   )*tmp___7 != (int const   )*tmp___8) {
#line 1634
      return (0);
    }
#line 1635
    goto switch_break;
    case_27: /* CIL Label */ 
    case_26: /* CIL Label */ 
    case_25: /* CIL Label */ 
    case_24: /* CIL Label */ 
    case_23: /* CIL Label */ 
    case_22: /* CIL Label */ 
    case_29: /* CIL Label */ 
#line 1645
    tmp___9 = ptr2;
#line 1645
    ptr2 ++;
#line 1645
    tmp___10 = ptr1;
#line 1645
    ptr1 ++;
#line 1645
    if ((int const   )*tmp___9 != (int const   )*tmp___10) {
#line 1646
      return (0);
    }
#line 1648
    tmp___11 = ptr2;
#line 1648
    ptr2 ++;
#line 1648
    tmp___12 = ptr1;
#line 1648
    ptr1 ++;
#line 1648
    if ((int const   )*tmp___11 != (int const   )*tmp___12) {
#line 1649
      return (0);
    }
#line 1659
    goto switch_break;
    switch_default: /* CIL Label */ ;
#line 1663
    if ((int const   )*(ptr2 + 0) == 0) {
#line 1663
      tmp___18 = (int )((struct normal_encoding *)enc)->type[(unsigned char )*(ptr2 + 1)];
    } else {
      {
#line 1663
      tmp___17 = unicode_byte_type((char )*(ptr2 + 0), (char )*(ptr2 + 1));
#line 1663
      tmp___18 = tmp___17;
      }
    }
    {
#line 1675
    if (tmp___18 == 27) {
#line 1675
      goto case_27___0;
    }
#line 1675
    if (tmp___18 == 26) {
#line 1675
      goto case_27___0;
    }
#line 1675
    if (tmp___18 == 25) {
#line 1675
      goto case_27___0;
    }
#line 1675
    if (tmp___18 == 24) {
#line 1675
      goto case_27___0;
    }
#line 1675
    if (tmp___18 == 23) {
#line 1675
      goto case_27___0;
    }
#line 1675
    if (tmp___18 == 22) {
#line 1675
      goto case_27___0;
    }
#line 1675
    if (tmp___18 == 29) {
#line 1675
      goto case_27___0;
    }
#line 1675
    if (tmp___18 == 7) {
#line 1675
      goto case_27___0;
    }
#line 1675
    if (tmp___18 == 6) {
#line 1675
      goto case_27___0;
    }
#line 1675
    if (tmp___18 == 5) {
#line 1675
      goto case_27___0;
    }
#line 1677
    goto switch_default___0;
    case_27___0: /* CIL Label */ 
    case_26___0: /* CIL Label */ 
    case_25___0: /* CIL Label */ 
    case_24___0: /* CIL Label */ 
    case_23___0: /* CIL Label */ 
    case_22___0: /* CIL Label */ 
    case_29___0: /* CIL Label */ 
    case_7___0: /* CIL Label */ 
    case_6___0: /* CIL Label */ 
    case_5___0: /* CIL Label */ 
#line 1676
    return (0);
    switch_default___0: /* CIL Label */ 
#line 1678
    return (1);
    switch_break___0: /* CIL Label */ ;
    }
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 1685 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmltok_impl.c"
static int big2_nameMatchesAscii(ENCODING const   *enc , char const   *ptr1 , char const   *end1 ,
                                 char const   *ptr2 ) 
{ 


  {
  {
#line 1689
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1689
    if (! *ptr2) {
#line 1689
      goto while_break;
    }
#line 1690
    if ((unsigned long )ptr1 == (unsigned long )end1) {
#line 1691
      return (0);
    }
#line 1692
    if ((int const   )*(ptr1 + 0) == 0) {
#line 1692
      if (! ((int const   )*(ptr1 + 1) == (int const   )*ptr2)) {
#line 1693
        return (0);
      }
    } else {
#line 1693
      return (0);
    }
#line 1689
    ptr1 += 2;
#line 1689
    ptr2 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1695
  return ((unsigned long )ptr1 == (unsigned long )end1);
}
}
#line 1698 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmltok_impl.c"
static int big2_nameLength(ENCODING const   *enc , char const   *ptr ) 
{ 
  char const   *start ;
  int tmp ;
  int tmp___0 ;

  {
#line 1701
  start = ptr;
  {
#line 1702
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1703
    if ((int const   )*(ptr + 0) == 0) {
#line 1703
      tmp___0 = (int )((struct normal_encoding *)enc)->type[(unsigned char )*(ptr + 1)];
    } else {
      {
#line 1703
      tmp = unicode_byte_type((char )*(ptr + 0), (char )*(ptr + 1));
#line 1703
      tmp___0 = tmp;
      }
    }
    {
#line 1706
    if (tmp___0 == 5) {
#line 1706
      goto case_5;
    }
#line 1706
    if (tmp___0 == 6) {
#line 1706
      goto case_6;
    }
#line 1706
    if (tmp___0 == 7) {
#line 1706
      goto case_7;
    }
#line 1716
    if (tmp___0 == 27) {
#line 1716
      goto case_27;
    }
#line 1716
    if (tmp___0 == 26) {
#line 1716
      goto case_27;
    }
#line 1716
    if (tmp___0 == 25) {
#line 1716
      goto case_27;
    }
#line 1716
    if (tmp___0 == 24) {
#line 1716
      goto case_27;
    }
#line 1716
    if (tmp___0 == 23) {
#line 1716
      goto case_27;
    }
#line 1716
    if (tmp___0 == 22) {
#line 1716
      goto case_27;
    }
#line 1716
    if (tmp___0 == 29) {
#line 1716
      goto case_27;
    }
#line 1719
    goto switch_default;
    case_5: /* CIL Label */ 
#line 1706
    ptr += 2;
#line 1706
    goto switch_break;
    case_6: /* CIL Label */ 
#line 1706
    ptr += 3;
#line 1706
    goto switch_break;
    case_7: /* CIL Label */ 
#line 1706
    ptr += 4;
#line 1706
    goto switch_break;
    case_27: /* CIL Label */ 
    case_26: /* CIL Label */ 
    case_25: /* CIL Label */ 
    case_24: /* CIL Label */ 
    case_23: /* CIL Label */ 
    case_22: /* CIL Label */ 
    case_29: /* CIL Label */ 
#line 1717
    ptr += 2;
#line 1718
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 1720
    return ((int )(ptr - start));
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 1725 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmltok_impl.c"
static char const   *big2_skipS(ENCODING const   *enc , char const   *ptr ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  {
#line 1728
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1729
    if ((int const   )*(ptr + 0) == 0) {
#line 1729
      tmp___0 = (int )((struct normal_encoding *)enc)->type[(unsigned char )*(ptr + 1)];
    } else {
      {
#line 1729
      tmp = unicode_byte_type((char )*(ptr + 0), (char )*(ptr + 1));
#line 1729
      tmp___0 = tmp;
      }
    }
    {
#line 1732
    if (tmp___0 == 21) {
#line 1732
      goto case_21;
    }
#line 1732
    if (tmp___0 == 9) {
#line 1732
      goto case_21;
    }
#line 1732
    if (tmp___0 == 10) {
#line 1732
      goto case_21;
    }
#line 1735
    goto switch_default;
    case_21: /* CIL Label */ 
    case_9: /* CIL Label */ 
    case_10: /* CIL Label */ 
#line 1733
    ptr += 2;
#line 1734
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 1736
    return (ptr);
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 1741 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmltok_impl.c"
static void big2_updatePosition(ENCODING const   *enc , char const   *ptr , char const   *end ,
                                POSITION *pos ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 1747
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1747
    if (! ((unsigned long )ptr < (unsigned long )end)) {
#line 1747
      goto while_break;
    }
#line 1748
    if ((int const   )*(ptr + 0) == 0) {
#line 1748
      tmp___0 = (int )((struct normal_encoding *)enc)->type[(unsigned char )*(ptr + 1)];
    } else {
      {
#line 1748
      tmp = unicode_byte_type((char )*(ptr + 0), (char )*(ptr + 1));
#line 1748
      tmp___0 = tmp;
      }
    }
    {
#line 1753
    if (tmp___0 == 5) {
#line 1753
      goto case_5;
    }
#line 1753
    if (tmp___0 == 6) {
#line 1753
      goto case_6;
    }
#line 1753
    if (tmp___0 == 7) {
#line 1753
      goto case_7;
    }
#line 1755
    if (tmp___0 == 10) {
#line 1755
      goto case_10;
    }
#line 1760
    if (tmp___0 == 9) {
#line 1760
      goto case_9;
    }
#line 1767
    goto switch_default;
    case_5: /* CIL Label */ 
#line 1753
    ptr += 2;
#line 1753
    goto switch_break;
    case_6: /* CIL Label */ 
#line 1753
    ptr += 3;
#line 1753
    goto switch_break;
    case_7: /* CIL Label */ 
#line 1753
    ptr += 4;
#line 1753
    goto switch_break;
    case_10: /* CIL Label */ 
#line 1756
    pos->columnNumber = (XML_Size )-1;
#line 1757
    (pos->lineNumber) ++;
#line 1758
    ptr += 2;
#line 1759
    goto switch_break;
    case_9: /* CIL Label */ 
#line 1761
    (pos->lineNumber) ++;
#line 1762
    ptr += 2;
#line 1763
    if ((unsigned long )ptr != (unsigned long )end) {
#line 1763
      if ((int const   )*(ptr + 0) == 0) {
#line 1763
        tmp___2 = (int )((struct normal_encoding *)enc)->type[(unsigned char )*(ptr + 1)];
      } else {
        {
#line 1763
        tmp___1 = unicode_byte_type((char )*(ptr + 0), (char )*(ptr + 1));
#line 1763
        tmp___2 = tmp___1;
        }
      }
#line 1763
      if (tmp___2 == 10) {
#line 1764
        ptr += 2;
      }
    }
#line 1765
    pos->columnNumber = (XML_Size )-1;
#line 1766
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 1768
    ptr += 2;
#line 1769
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 1771
    (pos->columnNumber) ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1773
  return;
}
}
#line 858 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmltok.c"
static struct normal_encoding  const  big2_encoding_ns  = 
#line 858 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmltok.c"
     {{{& big2_prologTok, & big2_contentTok, & big2_cdataSectionTok, & big2_ignoreSectionTok},
     {& big2_attributeValueTok, & big2_entityValueTok}, & big2_sameName, & big2_nameMatchesAscii,
     & big2_nameLength, & big2_skipS, & big2_getAtts, & big2_charRefNumber, & big2_predefinedEntityName,
     & big2_updatePosition, & big2_isPublicId, & big2_toUtf8, & big2_toUtf16, 2, (char)0,
     (char)0}, {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                (unsigned char)0, (unsigned char)21, (unsigned char)10, (unsigned char)0,
                (unsigned char)0, (unsigned char)9, (unsigned char)0, (unsigned char)0,
                (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                (unsigned char)21, (unsigned char)16, (unsigned char)12, (unsigned char)19,
                (unsigned char)28, (unsigned char)30, (unsigned char)3, (unsigned char)13,
                (unsigned char)31, (unsigned char)32, (unsigned char)33, (unsigned char)34,
                (unsigned char)35, (unsigned char)27, (unsigned char)26, (unsigned char)17,
                (unsigned char)25, (unsigned char)25, (unsigned char)25, (unsigned char)25,
                (unsigned char)25, (unsigned char)25, (unsigned char)25, (unsigned char)25,
                (unsigned char)25, (unsigned char)25, (unsigned char)23, (unsigned char)18,
                (unsigned char)2, (unsigned char)14, (unsigned char)11, (unsigned char)15,
                (unsigned char)28, (unsigned char)24, (unsigned char)24, (unsigned char)24,
                (unsigned char)24, (unsigned char)24, (unsigned char)24, (unsigned char)22,
                (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22,
                (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22,
                (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22,
                (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22,
                (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)20,
                (unsigned char)28, (unsigned char)4, (unsigned char)28, (unsigned char)22,
                (unsigned char)28, (unsigned char)24, (unsigned char)24, (unsigned char)24,
                (unsigned char)24, (unsigned char)24, (unsigned char)24, (unsigned char)22,
                (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22,
                (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22,
                (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22,
                (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22,
                (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)28,
                (unsigned char)36, (unsigned char)28, (unsigned char)28, (unsigned char)28,
                (unsigned char)28, (unsigned char)28, (unsigned char)28, (unsigned char)28,
                (unsigned char)28, (unsigned char)28, (unsigned char)28, (unsigned char)28,
                (unsigned char)28, (unsigned char)28, (unsigned char)28, (unsigned char)28,
                (unsigned char)28, (unsigned char)28, (unsigned char)28, (unsigned char)28,
                (unsigned char)28, (unsigned char)28, (unsigned char)28, (unsigned char)28,
                (unsigned char)28, (unsigned char)28, (unsigned char)28, (unsigned char)28,
                (unsigned char)28, (unsigned char)28, (unsigned char)28, (unsigned char)28,
                (unsigned char)28, (unsigned char)28, (unsigned char)28, (unsigned char)28,
                (unsigned char)28, (unsigned char)28, (unsigned char)28, (unsigned char)28,
                (unsigned char)28, (unsigned char)28, (unsigned char)28, (unsigned char)28,
                (unsigned char)28, (unsigned char)28, (unsigned char)22, (unsigned char)28,
                (unsigned char)28, (unsigned char)28, (unsigned char)28, (unsigned char)28,
                (unsigned char)28, (unsigned char)28, (unsigned char)28, (unsigned char)28,
                (unsigned char)28, (unsigned char)22, (unsigned char)28, (unsigned char)26,
                (unsigned char)28, (unsigned char)28, (unsigned char)22, (unsigned char)28,
                (unsigned char)28, (unsigned char)28, (unsigned char)28, (unsigned char)28,
                (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22,
                (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22,
                (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22,
                (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22,
                (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22,
                (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)28,
                (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22,
                (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22,
                (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22,
                (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22,
                (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22,
                (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22,
                (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22,
                (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)28,
                (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22,
                (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22},
    (int (*)(ENCODING const   * , char const   * ))0, (int (*)(ENCODING const   * ,
                                                               char const   * ))0,
    (int (*)(ENCODING const   * , char const   * ))0, (int (*)(ENCODING const   * ,
                                                               char const   * ))0,
    (int (*)(ENCODING const   * , char const   * ))0, (int (*)(ENCODING const   * ,
                                                               char const   * ))0,
    (int (*)(ENCODING const   * , char const   * ))0, (int (*)(ENCODING const   * ,
                                                               char const   * ))0,
    (int (*)(ENCODING const   * , char const   * ))0};
#line 875 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmltok.c"
static struct normal_encoding  const  big2_encoding  = 
#line 875
     {{{& big2_prologTok, & big2_contentTok, & big2_cdataSectionTok, & big2_ignoreSectionTok},
     {& big2_attributeValueTok, & big2_entityValueTok}, & big2_sameName, & big2_nameMatchesAscii,
     & big2_nameLength, & big2_skipS, & big2_getAtts, & big2_charRefNumber, & big2_predefinedEntityName,
     & big2_updatePosition, & big2_isPublicId, & big2_toUtf8, & big2_toUtf16, 2, (char)0,
     (char)0}, {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                (unsigned char)0, (unsigned char)21, (unsigned char)10, (unsigned char)0,
                (unsigned char)0, (unsigned char)9, (unsigned char)0, (unsigned char)0,
                (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                (unsigned char)21, (unsigned char)16, (unsigned char)12, (unsigned char)19,
                (unsigned char)28, (unsigned char)30, (unsigned char)3, (unsigned char)13,
                (unsigned char)31, (unsigned char)32, (unsigned char)33, (unsigned char)34,
                (unsigned char)35, (unsigned char)27, (unsigned char)26, (unsigned char)17,
                (unsigned char)25, (unsigned char)25, (unsigned char)25, (unsigned char)25,
                (unsigned char)25, (unsigned char)25, (unsigned char)25, (unsigned char)25,
                (unsigned char)25, (unsigned char)25, (unsigned char)22, (unsigned char)18,
                (unsigned char)2, (unsigned char)14, (unsigned char)11, (unsigned char)15,
                (unsigned char)28, (unsigned char)24, (unsigned char)24, (unsigned char)24,
                (unsigned char)24, (unsigned char)24, (unsigned char)24, (unsigned char)22,
                (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22,
                (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22,
                (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22,
                (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22,
                (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)20,
                (unsigned char)28, (unsigned char)4, (unsigned char)28, (unsigned char)22,
                (unsigned char)28, (unsigned char)24, (unsigned char)24, (unsigned char)24,
                (unsigned char)24, (unsigned char)24, (unsigned char)24, (unsigned char)22,
                (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22,
                (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22,
                (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22,
                (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22,
                (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)28,
                (unsigned char)36, (unsigned char)28, (unsigned char)28, (unsigned char)28,
                (unsigned char)28, (unsigned char)28, (unsigned char)28, (unsigned char)28,
                (unsigned char)28, (unsigned char)28, (unsigned char)28, (unsigned char)28,
                (unsigned char)28, (unsigned char)28, (unsigned char)28, (unsigned char)28,
                (unsigned char)28, (unsigned char)28, (unsigned char)28, (unsigned char)28,
                (unsigned char)28, (unsigned char)28, (unsigned char)28, (unsigned char)28,
                (unsigned char)28, (unsigned char)28, (unsigned char)28, (unsigned char)28,
                (unsigned char)28, (unsigned char)28, (unsigned char)28, (unsigned char)28,
                (unsigned char)28, (unsigned char)28, (unsigned char)28, (unsigned char)28,
                (unsigned char)28, (unsigned char)28, (unsigned char)28, (unsigned char)28,
                (unsigned char)28, (unsigned char)28, (unsigned char)28, (unsigned char)28,
                (unsigned char)28, (unsigned char)28, (unsigned char)22, (unsigned char)28,
                (unsigned char)28, (unsigned char)28, (unsigned char)28, (unsigned char)28,
                (unsigned char)28, (unsigned char)28, (unsigned char)28, (unsigned char)28,
                (unsigned char)28, (unsigned char)22, (unsigned char)28, (unsigned char)26,
                (unsigned char)28, (unsigned char)28, (unsigned char)22, (unsigned char)28,
                (unsigned char)28, (unsigned char)28, (unsigned char)28, (unsigned char)28,
                (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22,
                (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22,
                (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22,
                (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22,
                (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22,
                (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)28,
                (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22,
                (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22,
                (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22,
                (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22,
                (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22,
                (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22,
                (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22,
                (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)28,
                (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22,
                (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22},
    (int (*)(ENCODING const   * , char const   * ))0, (int (*)(ENCODING const   * ,
                                                               char const   * ))0,
    (int (*)(ENCODING const   * , char const   * ))0, (int (*)(ENCODING const   * ,
                                                               char const   * ))0,
    (int (*)(ENCODING const   * , char const   * ))0, (int (*)(ENCODING const   * ,
                                                               char const   * ))0,
    (int (*)(ENCODING const   * , char const   * ))0, (int (*)(ENCODING const   * ,
                                                               char const   * ))0,
    (int (*)(ENCODING const   * , char const   * ))0};
#line 922 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmltok.c"
static int streqci(char const   *s1 , char const   *s2 ) 
{ 
  char c1 ;
  char const   *tmp ;
  char c2 ;
  char const   *tmp___0 ;

  {
  {
#line 925
  while (1) {
    while_continue: /* CIL Label */ ;
#line 926
    tmp = s1;
#line 926
    s1 ++;
#line 926
    c1 = (char )*tmp;
#line 927
    tmp___0 = s2;
#line 927
    s2 ++;
#line 927
    c2 = (char )*tmp___0;
#line 928
    if (97 <= (int )c1) {
#line 928
      if ((int )c1 <= 122) {
#line 929
        c1 = (char )((int )c1 + -32);
      }
    }
#line 930
    if (97 <= (int )c2) {
#line 930
      if ((int )c2 <= 122) {
#line 931
        c2 = (char )((int )c2 + -32);
      }
    }
#line 932
    if ((int )c1 != (int )c2) {
#line 933
      return (0);
    }
#line 934
    if (! c1) {
#line 935
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 937
  return (1);
}
}
#line 940 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmltok.c"
static void initUpdatePosition(ENCODING const   *enc , char const   *ptr , char const   *end ,
                               POSITION *pos ) 
{ 


  {
  {
#line 944
  normal_updatePosition(& utf8_encoding.enc, ptr, end, pos);
  }
#line 945
  return;
}
}
#line 947 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmltok.c"
static int toAscii(ENCODING const   *enc , char const   *ptr , char const   *end ) 
{ 
  char buf[1] ;
  char *p ;

  {
  {
#line 951
  p = buf;
#line 952
  (*(enc->utf8Convert))(enc, & ptr, end, & p, (char const   *)(p + 1));
  }
#line 953
  if ((unsigned long )p == (unsigned long )(buf)) {
#line 954
    return (-1);
  } else {
#line 956
    return ((int )buf[0]);
  }
}
}
#line 959 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmltok.c"
static int isSpace(int c___0 ) 
{ 


  {
  {
#line 966
  if (c___0 == 9) {
#line 966
    goto case_9;
  }
#line 966
  if (c___0 == 10) {
#line 966
    goto case_9;
  }
#line 966
  if (c___0 == 13) {
#line 966
    goto case_9;
  }
#line 966
  if (c___0 == 32) {
#line 966
    goto case_9;
  }
#line 962
  goto switch_break;
  case_9: /* CIL Label */ 
  case_10: /* CIL Label */ 
  case_13: /* CIL Label */ 
  case_32: /* CIL Label */ 
#line 967
  return (1);
  switch_break: /* CIL Label */ ;
  }
#line 969
  return (0);
}
}
#line 975 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmltok.c"
static int parsePseudoAttribute(ENCODING const   *enc , char const   *ptr , char const   *end ,
                                char const   **namePtr , char const   **nameEndPtr ,
                                char const   **valPtr , char const   **nextTokPtr ) 
{ 
  int c___0 ;
  char open___0 ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 986
  if ((unsigned long )ptr == (unsigned long )end) {
#line 987
    *namePtr = (char const   *)((void *)0);
#line 988
    return (1);
  }
  {
#line 990
  tmp = toAscii(enc, ptr, end);
#line 990
  tmp___0 = isSpace(tmp);
  }
#line 990
  if (! tmp___0) {
#line 991
    *nextTokPtr = ptr;
#line 992
    return (0);
  }
  {
#line 994
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 995
    ptr += enc->minBytesPerChar;
#line 994
    tmp___1 = toAscii(enc, ptr, end);
#line 994
    tmp___2 = isSpace(tmp___1);
    }
#line 994
    if (! tmp___2) {
#line 994
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 997
  if ((unsigned long )ptr == (unsigned long )end) {
#line 998
    *namePtr = (char const   *)((void *)0);
#line 999
    return (1);
  }
#line 1001
  *namePtr = ptr;
  {
#line 1002
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 1003
    c___0 = toAscii(enc, ptr, end);
    }
#line 1004
    if (c___0 == -1) {
#line 1005
      *nextTokPtr = ptr;
#line 1006
      return (0);
    }
#line 1008
    if (c___0 == 61) {
#line 1009
      *nameEndPtr = ptr;
#line 1010
      goto while_break___0;
    }
    {
#line 1012
    tmp___4 = isSpace(c___0);
    }
#line 1012
    if (tmp___4) {
#line 1013
      *nameEndPtr = ptr;
      {
#line 1014
      while (1) {
        while_continue___1: /* CIL Label */ ;
        {
#line 1015
        ptr += enc->minBytesPerChar;
#line 1014
        c___0 = toAscii(enc, ptr, end);
#line 1014
        tmp___3 = isSpace(c___0);
        }
#line 1014
        if (! tmp___3) {
#line 1014
          goto while_break___1;
        }
      }
      while_break___1: /* CIL Label */ ;
      }
#line 1017
      if (c___0 != 61) {
#line 1018
        *nextTokPtr = ptr;
#line 1019
        return (0);
      }
#line 1021
      goto while_break___0;
    }
#line 1023
    ptr += enc->minBytesPerChar;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1025
  if ((unsigned long )ptr == (unsigned long )*namePtr) {
#line 1026
    *nextTokPtr = ptr;
#line 1027
    return (0);
  }
  {
#line 1029
  ptr += enc->minBytesPerChar;
#line 1030
  c___0 = toAscii(enc, ptr, end);
  }
  {
#line 1031
  while (1) {
    while_continue___2: /* CIL Label */ ;
    {
#line 1031
    tmp___5 = isSpace(c___0);
    }
#line 1031
    if (! tmp___5) {
#line 1031
      goto while_break___2;
    }
    {
#line 1032
    ptr += enc->minBytesPerChar;
#line 1033
    c___0 = toAscii(enc, ptr, end);
    }
  }
  while_break___2: /* CIL Label */ ;
  }
#line 1035
  if (c___0 != 34) {
#line 1035
    if (c___0 != 39) {
#line 1036
      *nextTokPtr = ptr;
#line 1037
      return (0);
    }
  }
#line 1039
  open___0 = (char )c___0;
#line 1040
  ptr += enc->minBytesPerChar;
#line 1041
  *valPtr = ptr;
  {
#line 1042
  while (1) {
    while_continue___3: /* CIL Label */ ;
    {
#line 1043
    c___0 = toAscii(enc, ptr, end);
    }
#line 1044
    if (c___0 == (int )open___0) {
#line 1045
      goto while_break___3;
    }
#line 1046
    if (97 <= c___0) {
#line 1046
      if (! (c___0 <= 122)) {
#line 1046
        goto _L___1;
      }
    } else
    _L___1: /* CIL Label */ 
#line 1046
    if (65 <= c___0) {
#line 1046
      if (! (c___0 <= 90)) {
#line 1046
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 1046
    if (48 <= c___0) {
#line 1046
      if (! (c___0 <= 57)) {
#line 1046
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 1046
    if (c___0 != 46) {
#line 1046
      if (c___0 != 45) {
#line 1046
        if (c___0 != 95) {
#line 1052
          *nextTokPtr = ptr;
#line 1053
          return (0);
        }
      }
    }
#line 1042
    ptr += enc->minBytesPerChar;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 1056
  *nextTokPtr = ptr + enc->minBytesPerChar;
#line 1057
  return (1);
}
}
#line 1060 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmltok.c"
static char const   KW_version[8]  = 
#line 1060
  {      (char const   )118,      (char const   )101,      (char const   )114,      (char const   )115, 
        (char const   )105,      (char const   )111,      (char const   )110,      (char const   )'\000'};
#line 1064 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmltok.c"
static char const   KW_encoding[9]  = 
#line 1064
  {      (char const   )101,      (char const   )110,      (char const   )99,      (char const   )111, 
        (char const   )100,      (char const   )105,      (char const   )110,      (char const   )103, 
        (char const   )'\000'};
#line 1068 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmltok.c"
static char const   KW_standalone[11]  = 
#line 1068
  {      (char const   )115,      (char const   )116,      (char const   )97,      (char const   )110, 
        (char const   )100,      (char const   )97,      (char const   )108,      (char const   )111, 
        (char const   )110,      (char const   )101,      (char const   )'\000'};
#line 1073 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmltok.c"
static char const   KW_yes[4]  = {      (char const   )121,      (char const   )101,      (char const   )115,      (char const   )'\000'};
#line 1077 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmltok.c"
static char const   KW_no[3]  = {      (char const   )110,      (char const   )111,      (char const   )'\000'};
#line 1081 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmltok.c"
static int doParseXmlDecl(ENCODING const   *(*encodingFinder)(ENCODING const   * ,
                                                              char const   * , char const   * ) ,
                          int isGeneralTextEntity , ENCODING const   *enc , char const   *ptr ,
                          char const   *end , char const   **badPtr , char const   **versionPtr ,
                          char const   **versionEndPtr , char const   **encodingName ,
                          ENCODING const   **encoding , int *standalone ) 
{ 
  char const   *val ;
  char const   *name ;
  char const   *nameEnd ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int c___0 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;

  {
  {
#line 1096
  val = (char const   *)((void *)0);
#line 1097
  name = (char const   *)((void *)0);
#line 1098
  nameEnd = (char const   *)((void *)0);
#line 1099
  ptr += 5 * (int )enc->minBytesPerChar;
#line 1100
  end -= 2 * (int )enc->minBytesPerChar;
#line 1101
  tmp = parsePseudoAttribute(enc, ptr, end, & name, & nameEnd, & val, & ptr);
  }
#line 1101
  if (tmp) {
#line 1101
    if (! name) {
#line 1103
      *badPtr = ptr;
#line 1104
      return (0);
    }
  } else {
#line 1103
    *badPtr = ptr;
#line 1104
    return (0);
  }
  {
#line 1106
  tmp___1 = (*(enc->nameMatchesAscii))(enc, name, nameEnd, KW_version);
  }
#line 1106
  if (tmp___1) {
#line 1113
    if (versionPtr) {
#line 1114
      *versionPtr = val;
    }
#line 1115
    if (versionEndPtr) {
#line 1116
      *versionEndPtr = ptr;
    }
    {
#line 1117
    tmp___0 = parsePseudoAttribute(enc, ptr, end, & name, & nameEnd, & val, & ptr);
    }
#line 1117
    if (! tmp___0) {
#line 1118
      *badPtr = ptr;
#line 1119
      return (0);
    }
#line 1121
    if (! name) {
#line 1122
      if (isGeneralTextEntity) {
#line 1124
        *badPtr = ptr;
#line 1125
        return (0);
      }
#line 1127
      return (1);
    }
  } else
#line 1107
  if (! isGeneralTextEntity) {
#line 1108
    *badPtr = name;
#line 1109
    return (0);
  }
  {
#line 1130
  tmp___4 = (*(enc->nameMatchesAscii))(enc, name, nameEnd, KW_encoding);
  }
#line 1130
  if (tmp___4) {
    {
#line 1131
    tmp___2 = toAscii(enc, val, end);
#line 1131
    c___0 = tmp___2;
    }
#line 1132
    if (97 <= c___0) {
#line 1132
      if (! (c___0 <= 122)) {
#line 1132
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 1132
    if (65 <= c___0) {
#line 1132
      if (! (c___0 <= 90)) {
#line 1133
        *badPtr = val;
#line 1134
        return (0);
      }
    } else {
#line 1133
      *badPtr = val;
#line 1134
      return (0);
    }
#line 1136
    if (encodingName) {
#line 1137
      *encodingName = val;
    }
#line 1138
    if (encoding) {
      {
#line 1139
      *encoding = (*encodingFinder)(enc, val, ptr - enc->minBytesPerChar);
      }
    }
    {
#line 1140
    tmp___3 = parsePseudoAttribute(enc, ptr, end, & name, & nameEnd, & val, & ptr);
    }
#line 1140
    if (! tmp___3) {
#line 1141
      *badPtr = ptr;
#line 1142
      return (0);
    }
#line 1144
    if (! name) {
#line 1145
      return (1);
    }
  }
  {
#line 1147
  tmp___5 = (*(enc->nameMatchesAscii))(enc, name, nameEnd, KW_standalone);
  }
#line 1147
  if (tmp___5) {
#line 1147
    if (isGeneralTextEntity) {
#line 1149
      *badPtr = name;
#line 1150
      return (0);
    }
  } else {
#line 1149
    *badPtr = name;
#line 1150
    return (0);
  }
  {
#line 1152
  tmp___7 = (*(enc->nameMatchesAscii))(enc, val, ptr - enc->minBytesPerChar, KW_yes);
  }
#line 1152
  if (tmp___7) {
#line 1153
    if (standalone) {
#line 1154
      *standalone = 1;
    }
  } else {
    {
#line 1156
    tmp___6 = (*(enc->nameMatchesAscii))(enc, val, ptr - enc->minBytesPerChar, KW_no);
    }
#line 1156
    if (tmp___6) {
#line 1157
      if (standalone) {
#line 1158
        *standalone = 0;
      }
    } else {
#line 1161
      *badPtr = val;
#line 1162
      return (0);
    }
  }
  {
#line 1164
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1164
    tmp___8 = toAscii(enc, ptr, end);
#line 1164
    tmp___9 = isSpace(tmp___8);
    }
#line 1164
    if (! tmp___9) {
#line 1164
      goto while_break;
    }
#line 1165
    ptr += enc->minBytesPerChar;
  }
  while_break: /* CIL Label */ ;
  }
#line 1166
  if ((unsigned long )ptr != (unsigned long )end) {
#line 1167
    *badPtr = ptr;
#line 1168
    return (0);
  }
#line 1170
  return (1);
}
}
#line 1173 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmltok.c"
static int checkCharRefNumber(int result ) 
{ 


  {
  {
#line 1178
  if (result >> 8 == 223) {
#line 1178
    goto case_223;
  }
#line 1178
  if (result >> 8 == 222) {
#line 1178
    goto case_223;
  }
#line 1178
  if (result >> 8 == 221) {
#line 1178
    goto case_223;
  }
#line 1178
  if (result >> 8 == 220) {
#line 1178
    goto case_223;
  }
#line 1178
  if (result >> 8 == 219) {
#line 1178
    goto case_223;
  }
#line 1178
  if (result >> 8 == 218) {
#line 1178
    goto case_223;
  }
#line 1178
  if (result >> 8 == 217) {
#line 1178
    goto case_223;
  }
#line 1178
  if (result >> 8 == 216) {
#line 1178
    goto case_223;
  }
#line 1180
  if (result >> 8 == 0) {
#line 1180
    goto case_0;
  }
#line 1184
  if (result >> 8 == 255) {
#line 1184
    goto case_255;
  }
#line 1176
  goto switch_break;
  case_223: /* CIL Label */ 
  case_222: /* CIL Label */ 
  case_221: /* CIL Label */ 
  case_220: /* CIL Label */ 
  case_219: /* CIL Label */ 
  case_218: /* CIL Label */ 
  case_217: /* CIL Label */ 
  case_216: /* CIL Label */ 
#line 1179
  return (-1);
  case_0: /* CIL Label */ 
#line 1181
  if ((int )latin1_encoding.type[result] == 0) {
#line 1182
    return (-1);
  }
#line 1183
  goto switch_break;
  case_255: /* CIL Label */ 
#line 1185
  if (result == 65534) {
#line 1186
    return (-1);
  } else
#line 1185
  if (result == 65535) {
#line 1186
    return (-1);
  }
#line 1187
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 1189
  return (result);
}
}
#line 1192 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmltok.c"
int XmlUtf8Encode(int c___0 , char *buf ) 
{ 


  {
#line 1202
  if (c___0 < 0) {
#line 1203
    return (0);
  }
#line 1204
  if (c___0 < 128) {
#line 1205
    *(buf + 0) = (char )c___0;
#line 1206
    return (1);
  }
#line 1208
  if (c___0 < 2048) {
#line 1209
    *(buf + 0) = (char )((c___0 >> 6) | 192);
#line 1210
    *(buf + 1) = (char )((c___0 & 63) | 128);
#line 1211
    return (2);
  }
#line 1213
  if (c___0 < 65536) {
#line 1214
    *(buf + 0) = (char )((c___0 >> 12) | 224);
#line 1215
    *(buf + 1) = (char )(((c___0 >> 6) & 63) | 128);
#line 1216
    *(buf + 2) = (char )((c___0 & 63) | 128);
#line 1217
    return (3);
  }
#line 1219
  if (c___0 < 1114112) {
#line 1220
    *(buf + 0) = (char )((c___0 >> 18) | 240);
#line 1221
    *(buf + 1) = (char )(((c___0 >> 12) & 63) | 128);
#line 1222
    *(buf + 2) = (char )(((c___0 >> 6) & 63) | 128);
#line 1223
    *(buf + 3) = (char )((c___0 & 63) | 128);
#line 1224
    return (4);
  }
#line 1226
  return (0);
}
}
#line 1229 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmltok.c"
int XmlUtf16Encode(int charNum , unsigned short *buf ) 
{ 


  {
#line 1232
  if (charNum < 0) {
#line 1233
    return (0);
  }
#line 1234
  if (charNum < 65536) {
#line 1235
    *(buf + 0) = (unsigned short )charNum;
#line 1236
    return (1);
  }
#line 1238
  if (charNum < 1114112) {
#line 1239
    charNum -= 65536;
#line 1240
    *(buf + 0) = (unsigned short )((charNum >> 10) + 55296);
#line 1241
    *(buf + 1) = (unsigned short )((charNum & 1023) + 56320);
#line 1242
    return (2);
  }
#line 1244
  return (0);
}
}
#line 1257 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmltok.c"
int XmlSizeOfUnknownEncoding(void) 
{ 


  {
#line 1260
  return ((int )sizeof(struct unknown_encoding ));
}
}
#line 1263 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmltok.c"
static int unknown_isName(ENCODING const   *enc , char const   *p ) 
{ 
  struct unknown_encoding  const  *uenc ;
  int c___0 ;
  int tmp ;

  {
  {
#line 1266
  uenc = (struct unknown_encoding  const  *)enc;
#line 1267
  tmp = (*(uenc->convert))((void *)uenc->userData, p);
#line 1267
  c___0 = tmp;
  }
#line 1268
  if (c___0 & -65536) {
#line 1269
    return (0);
  }
#line 1270
  return ((int )(namingBitmap[((int const   )namePages[c___0 >> 8] << 3) + (int const   )((c___0 & 255) >> 5)] & (unsigned int const   )(1 << ((c___0 & 255) & 31))));
}
}
#line 1273 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmltok.c"
static int unknown_isNmstrt(ENCODING const   *enc , char const   *p ) 
{ 
  struct unknown_encoding  const  *uenc ;
  int c___0 ;
  int tmp ;

  {
  {
#line 1276
  uenc = (struct unknown_encoding  const  *)enc;
#line 1277
  tmp = (*(uenc->convert))((void *)uenc->userData, p);
#line 1277
  c___0 = tmp;
  }
#line 1278
  if (c___0 & -65536) {
#line 1279
    return (0);
  }
#line 1280
  return ((int )(namingBitmap[((int const   )nmstrtPages[c___0 >> 8] << 3) + (int const   )((c___0 & 255) >> 5)] & (unsigned int const   )(1 << ((c___0 & 255) & 31))));
}
}
#line 1283 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmltok.c"
static int unknown_isInvalid(ENCODING const   *enc , char const   *p ) 
{ 
  struct unknown_encoding  const  *uenc ;
  int c___0 ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 1286
  uenc = (struct unknown_encoding  const  *)enc;
#line 1287
  tmp = (*(uenc->convert))((void *)uenc->userData, p);
#line 1287
  c___0 = tmp;
  }
#line 1288
  if (c___0 & -65536) {
#line 1288
    tmp___1 = 1;
  } else {
    {
#line 1288
    tmp___0 = checkCharRefNumber(c___0);
    }
#line 1288
    if (tmp___0 < 0) {
#line 1288
      tmp___1 = 1;
    } else {
#line 1288
      tmp___1 = 0;
    }
  }
#line 1288
  return (tmp___1);
}
}
#line 1291 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmltok.c"
static void unknown_toUtf8(ENCODING const   *enc , char const   **fromP , char const   *fromLim ,
                           char **toP , char const   *toLim ) 
{ 
  struct unknown_encoding  const  *uenc ;
  char buf[4] ;
  char const   *utf8 ;
  int n ;
  char const   *tmp ;
  int c___0 ;
  int tmp___0 ;
  char *tmp___1 ;
  char const   *tmp___2 ;

  {
#line 1296
  uenc = (struct unknown_encoding  const  *)enc;
  {
#line 1298
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1301
    if ((unsigned long )*fromP == (unsigned long )fromLim) {
#line 1302
      goto while_break;
    }
#line 1303
    utf8 = (char const   *)(uenc->utf8[(unsigned char )*(*fromP)]);
#line 1304
    tmp = utf8;
#line 1304
    utf8 ++;
#line 1304
    n = (int )*tmp;
#line 1305
    if (n == 0) {
      {
#line 1306
      tmp___0 = (*(uenc->convert))((void *)uenc->userData, *fromP);
#line 1306
      c___0 = tmp___0;
#line 1307
      n = XmlUtf8Encode(c___0, buf);
      }
#line 1308
      if ((long )n > toLim - (char const   *)*toP) {
#line 1309
        goto while_break;
      }
#line 1310
      utf8 = (char const   *)(buf);
#line 1311
      *fromP += (int )((struct normal_encoding  const  *)enc)->type[(unsigned char )*(*fromP)] - 3;
    } else {
#line 1315
      if ((long )n > toLim - (char const   *)*toP) {
#line 1316
        goto while_break;
      }
#line 1317
      (*fromP) ++;
    }
    {
#line 1319
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1320
      tmp___1 = *toP;
#line 1320
      (*toP) ++;
#line 1320
      tmp___2 = utf8;
#line 1320
      utf8 ++;
#line 1320
      *tmp___1 = (char )*tmp___2;
#line 1319
      n --;
#line 1319
      if (! (n != 0)) {
#line 1319
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1323
  return;
}
}
#line 1325 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmltok.c"
static void unknown_toUtf16(ENCODING const   *enc , char const   **fromP , char const   *fromLim ,
                            unsigned short **toP , unsigned short const   *toLim ) 
{ 
  struct unknown_encoding  const  *uenc ;
  unsigned short c___0 ;
  int tmp ;
  unsigned short *tmp___0 ;

  {
#line 1330
  uenc = (struct unknown_encoding  const  *)enc;
  {
#line 1331
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1331
    if ((unsigned long )*fromP != (unsigned long )fromLim) {
#line 1331
      if (! ((unsigned long )*toP != (unsigned long )toLim)) {
#line 1331
        goto while_break;
      }
    } else {
#line 1331
      goto while_break;
    }
#line 1332
    c___0 = uenc->utf16[(unsigned char )*(*fromP)];
#line 1333
    if ((int )c___0 == 0) {
      {
#line 1334
      tmp = (*(uenc->convert))((void *)uenc->userData, *fromP);
#line 1334
      c___0 = (unsigned short )tmp;
#line 1336
      *fromP += (int )((struct normal_encoding  const  *)enc)->type[(unsigned char )*(*fromP)] - 3;
      }
    } else {
#line 1340
      (*fromP) ++;
    }
#line 1341
    tmp___0 = *toP;
#line 1341
    (*toP) ++;
#line 1341
    *tmp___0 = c___0;
  }
  while_break: /* CIL Label */ ;
  }
#line 1343
  return;
}
}
#line 1345 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmltok.c"
ENCODING *XmlInitUnknownEncoding(void *mem , int *table , int (*convert)(void *userData ,
                                                                         char const   *p ) ,
                                 void *userData ) 
{ 
  int i ;
  struct unknown_encoding *e ;
  int c___0 ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 1352
  e = (struct unknown_encoding *)mem;
#line 1353
  i = 0;
  {
#line 1353
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1353
    if (! (i < (int )sizeof(struct normal_encoding ))) {
#line 1353
      goto while_break;
    }
#line 1354
    *((char *)mem + i) = *((char *)(& latin1_encoding) + i);
#line 1353
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1355
  i = 0;
  {
#line 1355
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1355
    if (! (i < 128)) {
#line 1355
      goto while_break___0;
    }
#line 1356
    if ((int )latin1_encoding.type[i] != 28) {
#line 1356
      if ((int )latin1_encoding.type[i] != 0) {
#line 1356
        if (*(table + i) != i) {
#line 1359
          return ((ENCODING *)0);
        }
      }
    }
#line 1355
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1360
  i = 0;
  {
#line 1360
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1360
    if (! (i < 256)) {
#line 1360
      goto while_break___1;
    }
#line 1361
    c___0 = *(table + i);
#line 1362
    if (c___0 == -1) {
#line 1363
      e->normal.type[i] = (unsigned char)1;
#line 1365
      e->utf16[i] = (unsigned short)65535;
#line 1366
      e->utf8[i][0] = (char)1;
#line 1367
      e->utf8[i][1] = (char)0;
    } else
#line 1369
    if (c___0 < 0) {
#line 1370
      if (c___0 < -4) {
#line 1371
        return ((ENCODING *)0);
      }
#line 1372
      e->normal.type[i] = (unsigned char )(5 - (c___0 + 2));
#line 1373
      e->utf8[i][0] = (char)0;
#line 1374
      e->utf16[i] = (unsigned short)0;
    } else
#line 1376
    if (c___0 < 128) {
#line 1377
      if ((int )latin1_encoding.type[c___0] != 28) {
#line 1377
        if ((int )latin1_encoding.type[c___0] != 0) {
#line 1377
          if (c___0 != i) {
#line 1380
            return ((ENCODING *)0);
          }
        }
      }
#line 1381
      e->normal.type[i] = latin1_encoding.type[c___0];
#line 1382
      e->utf8[i][0] = (char)1;
#line 1383
      e->utf8[i][1] = (char )c___0;
#line 1384
      if (c___0 == 0) {
#line 1384
        tmp = 65535;
      } else {
#line 1384
        tmp = c___0;
      }
#line 1384
      e->utf16[i] = (unsigned short )tmp;
    } else {
      {
#line 1386
      tmp___1 = checkCharRefNumber(c___0);
      }
#line 1386
      if (tmp___1 < 0) {
#line 1387
        e->normal.type[i] = (unsigned char)0;
#line 1389
        e->utf16[i] = (unsigned short)65535;
#line 1390
        e->utf8[i][0] = (char)1;
#line 1391
        e->utf8[i][1] = (char)0;
      } else {
#line 1394
        if (c___0 > 65535) {
#line 1395
          return ((ENCODING *)0);
        }
#line 1396
        if (namingBitmap[((int const   )nmstrtPages[c___0 >> 8] << 3) + (int const   )((c___0 & 255) >> 5)] & (unsigned int const   )(1 << ((c___0 & 255) & 31))) {
#line 1397
          e->normal.type[i] = (unsigned char)22;
        } else
#line 1398
        if (namingBitmap[((int const   )namePages[c___0 >> 8] << 3) + (int const   )((c___0 & 255) >> 5)] & (unsigned int const   )(1 << ((c___0 & 255) & 31))) {
#line 1399
          e->normal.type[i] = (unsigned char)26;
        } else {
#line 1401
          e->normal.type[i] = (unsigned char)28;
        }
        {
#line 1402
        tmp___0 = XmlUtf8Encode(c___0, e->utf8[i] + 1);
#line 1402
        e->utf8[i][0] = (char )tmp___0;
#line 1403
        e->utf16[i] = (unsigned short )c___0;
        }
      }
    }
#line 1360
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 1406
  e->userData = userData;
#line 1407
  e->convert = convert;
#line 1408
  if (convert) {
#line 1409
    e->normal.isName2 = & unknown_isName;
#line 1410
    e->normal.isName3 = & unknown_isName;
#line 1411
    e->normal.isName4 = & unknown_isName;
#line 1412
    e->normal.isNmstrt2 = & unknown_isNmstrt;
#line 1413
    e->normal.isNmstrt3 = & unknown_isNmstrt;
#line 1414
    e->normal.isNmstrt4 = & unknown_isNmstrt;
#line 1415
    e->normal.isInvalid2 = & unknown_isInvalid;
#line 1416
    e->normal.isInvalid3 = & unknown_isInvalid;
#line 1417
    e->normal.isInvalid4 = & unknown_isInvalid;
  }
#line 1419
  e->normal.enc.utf8Convert = & unknown_toUtf8;
#line 1420
  e->normal.enc.utf16Convert = & unknown_toUtf16;
#line 1421
  return (& e->normal.enc);
}
}
#line 1438 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmltok.c"
static char const   KW_ISO_8859_1[11]  = 
#line 1438
  {      (char const   )73,      (char const   )83,      (char const   )79,      (char const   )45, 
        (char const   )56,      (char const   )56,      (char const   )53,      (char const   )57, 
        (char const   )45,      (char const   )49,      (char const   )'\000'};
#line 1442 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmltok.c"
static char const   KW_US_ASCII[9]  = 
#line 1442
  {      (char const   )85,      (char const   )83,      (char const   )45,      (char const   )65, 
        (char const   )83,      (char const   )67,      (char const   )73,      (char const   )73, 
        (char const   )'\000'};
#line 1446 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmltok.c"
static char const   KW_UTF_8[6]  = {      (char const   )85,      (char const   )84,      (char const   )70,      (char const   )45, 
        (char const   )56,      (char const   )'\000'};
#line 1449 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmltok.c"
static char const   KW_UTF_16[7]  = {      (char const   )85,      (char const   )84,      (char const   )70,      (char const   )45, 
        (char const   )49,      (char const   )54,      (char const   )'\000'};
#line 1452 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmltok.c"
static char const   KW_UTF_16BE[9]  = 
#line 1452
  {      (char const   )85,      (char const   )84,      (char const   )70,      (char const   )45, 
        (char const   )49,      (char const   )54,      (char const   )66,      (char const   )69, 
        (char const   )'\000'};
#line 1456 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmltok.c"
static char const   KW_UTF_16LE[9]  = 
#line 1456
  {      (char const   )85,      (char const   )84,      (char const   )70,      (char const   )45, 
        (char const   )49,      (char const   )54,      (char const   )76,      (char const   )69, 
        (char const   )'\000'};
#line 1464
static int getEncodingIndex(char const   *name ) ;
#line 1464 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmltok.c"
static char const   * const  encodingNames[6]  = {      (char const   */* const  */)(KW_ISO_8859_1),      (char const   */* const  */)(KW_US_ASCII),      (char const   */* const  */)(KW_UTF_8),      (char const   */* const  */)(KW_UTF_16), 
        (char const   */* const  */)(KW_UTF_16BE),      (char const   */* const  */)(KW_UTF_16LE)};
#line 1461 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmltok.c"
static int getEncodingIndex(char const   *name ) 
{ 
  int i ;
  int tmp ;

  {
#line 1473
  if ((unsigned long )name == (unsigned long )((void *)0)) {
#line 1474
    return (6);
  }
#line 1475
  i = 0;
  {
#line 1475
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1475
    if (! (i < (int )(sizeof(encodingNames) / sizeof(encodingNames[0])))) {
#line 1475
      goto while_break;
    }
    {
#line 1476
    tmp = streqci(name, (char const   *)encodingNames[i]);
    }
#line 1476
    if (tmp) {
#line 1477
      return (i);
    }
#line 1475
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1478
  return (-1);
}
}
#line 1496 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmltok.c"
static int initScan(ENCODING const   * const  *encodingTable , INIT_ENCODING const   *enc ,
                    int state , char const   *ptr , char const   *end , char const   **nextTokPtr ) 
{ 
  ENCODING const   **encPtr ;
  int tmp ;
  int e ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 1506
  if ((unsigned long )ptr == (unsigned long )end) {
#line 1507
    return (-4);
  }
#line 1508
  encPtr = (ENCODING const   **)enc->encPtr;
#line 1509
  if ((unsigned long )(ptr + 1) == (unsigned long )end) {
    {
#line 1521
    if ((int )enc->initEnc.isUtf16 == 4) {
#line 1521
      goto case_4;
    }
#line 1521
    if ((int )enc->initEnc.isUtf16 == 5) {
#line 1521
      goto case_4;
    }
#line 1521
    if ((int )enc->initEnc.isUtf16 == 3) {
#line 1521
      goto case_4;
    }
#line 1518
    goto switch_break;
    case_4: /* CIL Label */ 
    case_5: /* CIL Label */ 
    case_3: /* CIL Label */ 
#line 1522
    return (-1);
    switch_break: /* CIL Label */ ;
    }
    {
#line 1527
    if ((int )((unsigned char )*ptr) == 239) {
#line 1527
      goto case_239;
    }
#line 1527
    if ((int )((unsigned char )*ptr) == 255) {
#line 1527
      goto case_239;
    }
#line 1527
    if ((int )((unsigned char )*ptr) == 254) {
#line 1527
      goto case_239;
    }
#line 1533
    if ((int )((unsigned char )*ptr) == 60) {
#line 1533
      goto case_60;
    }
#line 1533
    if ((int )((unsigned char )*ptr) == 0) {
#line 1533
      goto case_60;
    }
#line 1524
    goto switch_break___0;
    case_239: /* CIL Label */ 
    case_255: /* CIL Label */ 
    case_254: /* CIL Label */ 
#line 1528
    if ((int )enc->initEnc.isUtf16 == 0) {
#line 1528
      if (state == 1) {
#line 1530
        goto switch_break___0;
      }
    }
    case_60: /* CIL Label */ 
    case_0: /* CIL Label */ 
#line 1534
    return (-1);
    switch_break___0: /* CIL Label */ ;
    }
  } else {
    {
#line 1539
    if ((((int )((unsigned char )*(ptr + 0)) << 8) | (int )((unsigned char )*(ptr + 1))) == 65279) {
#line 1539
      goto case_65279;
    }
#line 1547
    if ((((int )((unsigned char )*(ptr + 0)) << 8) | (int )((unsigned char )*(ptr + 1))) == 15360) {
#line 1547
      goto case_15360;
    }
#line 1554
    if ((((int )((unsigned char )*(ptr + 0)) << 8) | (int )((unsigned char )*(ptr + 1))) == 65534) {
#line 1554
      goto case_65534;
    }
#line 1561
    if ((((int )((unsigned char )*(ptr + 0)) << 8) | (int )((unsigned char )*(ptr + 1))) == 61371) {
#line 1561
      goto case_61371;
    }
#line 1583
    goto switch_default;
    case_65279: /* CIL Label */ 
#line 1540
    if ((int )enc->initEnc.isUtf16 == 0) {
#line 1540
      if (state == 1) {
#line 1542
        goto switch_break___1;
      }
    }
#line 1543
    *nextTokPtr = ptr + 2;
#line 1544
    *encPtr = (ENCODING const   *)*(encodingTable + 4);
#line 1545
    return (14);
    case_15360: /* CIL Label */ 
#line 1548
    if ((int )enc->initEnc.isUtf16 == 4) {
#line 1548
      goto _L;
    } else
#line 1548
    if ((int )enc->initEnc.isUtf16 == 3) {
      _L: /* CIL Label */ 
#line 1548
      if (state == 1) {
#line 1551
        goto switch_break___1;
      }
    }
    {
#line 1552
    *encPtr = (ENCODING const   *)*(encodingTable + 5);
#line 1553
    tmp = (*((*encPtr)->scanners[state]))(*encPtr, ptr, end, nextTokPtr);
    }
#line 1553
    return (tmp);
    case_65534: /* CIL Label */ 
#line 1555
    if ((int )enc->initEnc.isUtf16 == 0) {
#line 1555
      if (state == 1) {
#line 1557
        goto switch_break___1;
      }
    }
#line 1558
    *nextTokPtr = ptr + 2;
#line 1559
    *encPtr = (ENCODING const   *)*(encodingTable + 5);
#line 1560
    return (14);
    case_61371: /* CIL Label */ 
#line 1569
    if (state == 1) {
#line 1570
      e = (int )enc->initEnc.isUtf16;
#line 1571
      if (e == 0) {
#line 1573
        goto switch_break___1;
      } else
#line 1571
      if (e == 4) {
#line 1573
        goto switch_break___1;
      } else
#line 1571
      if (e == 5) {
#line 1573
        goto switch_break___1;
      } else
#line 1571
      if (e == 3) {
#line 1573
        goto switch_break___1;
      }
    }
#line 1575
    if ((unsigned long )(ptr + 2) == (unsigned long )end) {
#line 1576
      return (-1);
    }
#line 1577
    if ((int )((unsigned char )*(ptr + 2)) == 191) {
#line 1578
      *nextTokPtr = ptr + 3;
#line 1579
      *encPtr = (ENCODING const   *)*(encodingTable + 2);
#line 1580
      return (14);
    }
#line 1582
    goto switch_break___1;
    switch_default: /* CIL Label */ 
#line 1584
    if ((int const   )*(ptr + 0) == 0) {
#line 1591
      if (state == 1) {
#line 1591
        if ((int )enc->initEnc.isUtf16 == 5) {
#line 1592
          goto switch_break___1;
        }
      }
      {
#line 1593
      *encPtr = (ENCODING const   *)*(encodingTable + 4);
#line 1594
      tmp___0 = (*((*encPtr)->scanners[state]))(*encPtr, ptr, end, nextTokPtr);
      }
#line 1594
      return (tmp___0);
    } else
#line 1596
    if ((int const   )*(ptr + 1) == 0) {
#line 1606
      if (state == 1) {
#line 1607
        goto switch_break___1;
      }
      {
#line 1608
      *encPtr = (ENCODING const   *)*(encodingTable + 5);
#line 1609
      tmp___1 = (*((*encPtr)->scanners[state]))(*encPtr, ptr, end, nextTokPtr);
      }
#line 1609
      return (tmp___1);
    }
#line 1611
    goto switch_break___1;
    switch_break___1: /* CIL Label */ ;
    }
  }
  {
#line 1614
  *encPtr = (ENCODING const   *)*(encodingTable + (int )enc->initEnc.isUtf16);
#line 1615
  tmp___2 = (*((*encPtr)->scanners[state]))(*encPtr, ptr, end, nextTokPtr);
  }
#line 1615
  return (tmp___2);
}
}
#line 8 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmltok_ns.c"
ENCODING const   *XmlGetUtf8InternalEncoding(void) 
{ 


  {
#line 11
  return (& internal_utf8_encoding.enc);
}
}
#line 14 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmltok_ns.c"
ENCODING const   *XmlGetUtf16InternalEncoding(void) 
{ 


  {
#line 18
  return (& internal_little2_encoding.enc);
}
}
#line 29 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmltok_ns.c"
static ENCODING const   * const  encodings[7]  = {      (ENCODING const   */* const  */)(& latin1_encoding.enc),      (ENCODING const   */* const  */)(& ascii_encoding.enc),      (ENCODING const   */* const  */)(& utf8_encoding.enc),      (ENCODING const   */* const  */)(& big2_encoding.enc), 
        (ENCODING const   */* const  */)(& big2_encoding.enc),      (ENCODING const   */* const  */)(& little2_encoding.enc),      (ENCODING const   */* const  */)(& utf8_encoding.enc)};
#line 39 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmltok_ns.c"
static int initScanProlog(ENCODING const   *enc , char const   *ptr , char const   *end ,
                          char const   **nextTokPtr ) 
{ 
  int tmp ;

  {
  {
#line 43
  tmp = initScan(encodings, (INIT_ENCODING const   *)enc, 0, ptr, end, nextTokPtr);
  }
#line 43
  return (tmp);
}
}
#line 47 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmltok_ns.c"
static int initScanContent(ENCODING const   *enc , char const   *ptr , char const   *end ,
                           char const   **nextTokPtr ) 
{ 
  int tmp ;

  {
  {
#line 51
  tmp = initScan(encodings, (INIT_ENCODING const   *)enc, 1, ptr, end, nextTokPtr);
  }
#line 51
  return (tmp);
}
}
#line 55 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmltok_ns.c"
int XmlInitEncoding(INIT_ENCODING *p , ENCODING const   **encPtr , char const   *name ) 
{ 
  int i ;
  int tmp ;

  {
  {
#line 59
  tmp = getEncodingIndex(name);
#line 59
  i = tmp;
  }
#line 60
  if (i == -1) {
#line 61
    return (0);
  }
#line 62
  p->initEnc.isUtf16 = (char )i;
#line 63
  p->initEnc.scanners[0] = & initScanProlog;
#line 64
  p->initEnc.scanners[1] = & initScanContent;
#line 65
  p->initEnc.updatePosition = & initUpdatePosition;
#line 66
  p->encPtr = encPtr;
#line 67
  *encPtr = (ENCODING const   *)(& p->initEnc);
#line 68
  return (1);
}
}
#line 71 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmltok_ns.c"
static ENCODING const   *findEncoding(ENCODING const   *enc , char const   *ptr ,
                                      char const   *end ) 
{ 
  char buf[128] ;
  char *p ;
  int i ;
  int tmp ;

  {
  {
#line 76
  p = buf;
#line 78
  (*(enc->utf8Convert))(enc, & ptr, end, & p, (char const   *)((p + 128) - 1));
  }
#line 79
  if ((unsigned long )ptr != (unsigned long )end) {
#line 80
    return ((ENCODING const   *)0);
  }
  {
#line 81
  *p = (char)0;
#line 82
  tmp = streqci((char const   *)(buf), KW_UTF_16);
  }
#line 82
  if (tmp) {
#line 82
    if (enc->minBytesPerChar == 2) {
#line 83
      return (enc);
    }
  }
  {
#line 84
  i = getEncodingIndex((char const   *)(buf));
  }
#line 85
  if (i == -1) {
#line 86
    return ((ENCODING const   *)0);
  }
#line 87
  return ((ENCODING const   *)encodings[i]);
}
}
#line 90 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmltok_ns.c"
int XmlParseXmlDecl(int isGeneralTextEntity , ENCODING const   *enc , char const   *ptr ,
                    char const   *end , char const   **badPtr , char const   **versionPtr ,
                    char const   **versionEndPtr , char const   **encodingName , ENCODING const   **encoding ,
                    int *standalone ) 
{ 
  int tmp ;

  {
  {
#line 102
  tmp = doParseXmlDecl(& findEncoding, isGeneralTextEntity, enc, ptr, end, badPtr,
                       versionPtr, versionEndPtr, encodingName, encoding, standalone);
  }
#line 102
  return (tmp);
}
}
#line 8 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmltok_ns.c"
ENCODING const   *XmlGetUtf8InternalEncodingNS(void) 
{ 


  {
#line 11
  return (& internal_utf8_encoding_ns.enc);
}
}
#line 14 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmltok_ns.c"
ENCODING const   *XmlGetUtf16InternalEncodingNS(void) 
{ 


  {
#line 18
  return (& internal_little2_encoding_ns.enc);
}
}
#line 29 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmltok_ns.c"
static ENCODING const   * const  encodingsNS[7]  = {      (ENCODING const   */* const  */)(& latin1_encoding_ns.enc),      (ENCODING const   */* const  */)(& ascii_encoding_ns.enc),      (ENCODING const   */* const  */)(& utf8_encoding_ns.enc),      (ENCODING const   */* const  */)(& big2_encoding_ns.enc), 
        (ENCODING const   */* const  */)(& big2_encoding_ns.enc),      (ENCODING const   */* const  */)(& little2_encoding_ns.enc),      (ENCODING const   */* const  */)(& utf8_encoding_ns.enc)};
#line 39 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmltok_ns.c"
static int initScanPrologNS(ENCODING const   *enc , char const   *ptr , char const   *end ,
                            char const   **nextTokPtr ) 
{ 
  int tmp ;

  {
  {
#line 43
  tmp = initScan(encodingsNS, (INIT_ENCODING const   *)enc, 0, ptr, end, nextTokPtr);
  }
#line 43
  return (tmp);
}
}
#line 47 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmltok_ns.c"
static int initScanContentNS(ENCODING const   *enc , char const   *ptr , char const   *end ,
                             char const   **nextTokPtr ) 
{ 
  int tmp ;

  {
  {
#line 51
  tmp = initScan(encodingsNS, (INIT_ENCODING const   *)enc, 1, ptr, end, nextTokPtr);
  }
#line 51
  return (tmp);
}
}
#line 55 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmltok_ns.c"
int XmlInitEncodingNS(INIT_ENCODING *p , ENCODING const   **encPtr , char const   *name ) 
{ 
  int i ;
  int tmp ;

  {
  {
#line 59
  tmp = getEncodingIndex(name);
#line 59
  i = tmp;
  }
#line 60
  if (i == -1) {
#line 61
    return (0);
  }
#line 62
  p->initEnc.isUtf16 = (char )i;
#line 63
  p->initEnc.scanners[0] = & initScanPrologNS;
#line 64
  p->initEnc.scanners[1] = & initScanContentNS;
#line 65
  p->initEnc.updatePosition = & initUpdatePosition;
#line 66
  p->encPtr = encPtr;
#line 67
  *encPtr = (ENCODING const   *)(& p->initEnc);
#line 68
  return (1);
}
}
#line 71 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmltok_ns.c"
static ENCODING const   *findEncodingNS(ENCODING const   *enc , char const   *ptr ,
                                        char const   *end ) 
{ 
  char buf[128] ;
  char *p ;
  int i ;
  int tmp ;

  {
  {
#line 76
  p = buf;
#line 78
  (*(enc->utf8Convert))(enc, & ptr, end, & p, (char const   *)((p + 128) - 1));
  }
#line 79
  if ((unsigned long )ptr != (unsigned long )end) {
#line 80
    return ((ENCODING const   *)0);
  }
  {
#line 81
  *p = (char)0;
#line 82
  tmp = streqci((char const   *)(buf), KW_UTF_16);
  }
#line 82
  if (tmp) {
#line 82
    if (enc->minBytesPerChar == 2) {
#line 83
      return (enc);
    }
  }
  {
#line 84
  i = getEncodingIndex((char const   *)(buf));
  }
#line 85
  if (i == -1) {
#line 86
    return ((ENCODING const   *)0);
  }
#line 87
  return ((ENCODING const   *)encodingsNS[i]);
}
}
#line 90 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmltok_ns.c"
int XmlParseXmlDeclNS(int isGeneralTextEntity , ENCODING const   *enc , char const   *ptr ,
                      char const   *end , char const   **badPtr , char const   **versionPtr ,
                      char const   **versionEndPtr , char const   **encodingName ,
                      ENCODING const   **encoding , int *standalone ) 
{ 
  int tmp ;

  {
  {
#line 102
  tmp = doParseXmlDecl(& findEncodingNS, isGeneralTextEntity, enc, ptr, end, badPtr,
                       versionPtr, versionEndPtr, encodingName, encoding, standalone);
  }
#line 102
  return (tmp);
}
}
#line 1639 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmltok.c"
ENCODING *XmlInitUnknownEncodingNS(void *mem , int *table , int (*convert)(void *userData ,
                                                                           char const   *p ) ,
                                   void *userData ) 
{ 
  ENCODING *enc ;
  ENCODING *tmp ;

  {
  {
#line 1645
  tmp = XmlInitUnknownEncoding(mem, table, convert, userData);
#line 1645
  enc = tmp;
  }
#line 1646
  if (enc) {
#line 1647
    ((struct normal_encoding *)enc)->type[58] = (unsigned char)23;
  }
#line 1648
  return (enc);
}
}
#line 435 "/usr/include/libio.h"
extern int _IO_putc(int __c , _IO_FILE *__fp ) ;
#line 169 "/usr/include/stdio.h"
extern struct _IO_FILE *stdout ;
#line 170
extern struct _IO_FILE *stderr ;
#line 178
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) remove)(char const   *__filename ) ;
#line 237
extern int fclose(FILE *__stream ) ;
#line 272
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 336
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) setvbuf)(FILE * __restrict  __stream ,
                                                                              char * __restrict  __buf ,
                                                                              int __modes ,
                                                                              size_t __n ) ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 689
extern int fputs(char const   * __restrict  __s , FILE * __restrict  __stream ) ;
#line 846
extern void perror(char const   *__s ) ;
#line 466 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 543
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 765
extern void ( __attribute__((__nonnull__(1,4))) qsort)(void *__base , size_t __nmemb ,
                                                       size_t __size , int (*__compar)(void const   * ,
                                                                                       void const   * ) ) ;
#line 129 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcpy)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 137
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcat)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 144
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 236
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strchr)(char const   *__s ,
                                                                                               int __c )  __attribute__((__pure__)) ;
#line 263
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strrchr)(char const   *__s ,
                                                                                                int __c )  __attribute__((__pure__)) ;
#line 399
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 205 "./lib/expat.h"
XML_Parser XML_ParserCreate(XML_Char const   *encodingName ) ;
#line 219
XML_Parser XML_ParserCreateNS(XML_Char const   *encodingName , XML_Char nsSep ) ;
#line 340
void XML_SetEntityDeclHandler(XML_Parser parser , void (*handler)(void *userData ,
                                                                  XML_Char const   *entityName ,
                                                                  int is_parameter_entity ,
                                                                  XML_Char const   *value ,
                                                                  int value_length ,
                                                                  XML_Char const   *base ,
                                                                  XML_Char const   *systemId ,
                                                                  XML_Char const   *publicId ,
                                                                  XML_Char const   *notationName ) ) ;
#line 533
void XML_SetElementHandler(XML_Parser parser , void (*start)(void *userData , XML_Char const   *name ,
                                                             XML_Char const   **atts ) ,
                           void (*end)(void *userData , XML_Char const   *name ) ) ;
#line 546
void XML_SetCharacterDataHandler(XML_Parser parser , void (*handler)(void *userData ,
                                                                     XML_Char const   *s ,
                                                                     int len ) ) ;
#line 550
void XML_SetProcessingInstructionHandler(XML_Parser parser , void (*handler)(void *userData ,
                                                                             XML_Char const   *target ,
                                                                             XML_Char const   *data ) ) ;
#line 553
void XML_SetCommentHandler(XML_Parser parser , void (*handler)(void *userData , XML_Char const   *data ) ) ;
#line 557
void XML_SetCdataSectionHandler(XML_Parser parser , void (*start)(void *userData ) ,
                                void (*end)(void *userData ) ) ;
#line 574
void XML_SetDefaultHandler(XML_Parser parser , void (*handler)(void *userData , XML_Char const   *s ,
                                                               int len ) ) ;
#line 586
void XML_SetDoctypeDeclHandler(XML_Parser parser , void (*start)(void *userData ,
                                                                 XML_Char const   *doctypeName ,
                                                                 XML_Char const   *sysid ,
                                                                 XML_Char const   *pubid ,
                                                                 int has_internal_subset ) ,
                               void (*end)(void *userData ) ) ;
#line 603
void XML_SetNotationDeclHandler(XML_Parser parser , void (*handler)(void *userData ,
                                                                    XML_Char const   *notationName ,
                                                                    XML_Char const   *base ,
                                                                    XML_Char const   *systemId ,
                                                                    XML_Char const   *publicId ) ) ;
#line 607
void XML_SetNamespaceDeclHandler(XML_Parser parser , void (*start)(void *userData ,
                                                                   XML_Char const   *prefix ,
                                                                   XML_Char const   *uri ) ,
                                 void (*end)(void *userData , XML_Char const   *prefix ) ) ;
#line 620
void XML_SetNotStandaloneHandler(XML_Parser parser , int (*handler)(void *userData ) ) ;
#line 640
void XML_SetUnknownEncodingHandler(XML_Parser parser , int (*handler)(void *encodingHandlerData ,
                                                                      XML_Char const   *name ,
                                                                      XML_Encoding *info ) ,
                                   void *data ) ;
#line 649
void XML_DefaultCurrent(XML_Parser parser ) ;
#line 670
void XML_SetUserData(XML_Parser parser , void *p ) ;
#line 689
void XML_UseParserAsHandlerArg(XML_Parser parser ) ;
#line 725
XML_Char const   *XML_GetBase(XML_Parser parser ) ;
#line 734
int XML_GetSpecifiedAttributeCount(XML_Parser parser ) ;
#line 742
int XML_GetIdAttributeIndex(XML_Parser parser ) ;
#line 905
int XML_SetParamEntityParsing(XML_Parser parser , enum XML_ParamEntityParsing peParsing ) ;
#line 940
XML_Size XML_GetCurrentLineNumber(XML_Parser parser ) ;
#line 941
XML_Size XML_GetCurrentColumnNumber(XML_Parser parser ) ;
#line 942
XML_Index XML_GetCurrentByteIndex(XML_Parser parser ) ;
#line 947
int XML_GetCurrentByteCount(XML_Parser parser ) ;
#line 985
void XML_ParserFree(XML_Parser parser ) ;
#line 993
XML_LChar const   *XML_ExpatVersion(void) ;
#line 1030
XML_Feature const   *XML_GetFeatureList(void) ;
#line 5 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/xmlwf/codepage.h"
int codepageMap(int cp , int *map ) ;
#line 6
int codepageConvert(int cp , char const   *p ) ;
#line 18 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/xmlwf/xmlfile.h"
int XML_ProcessFile(XML_Parser parser , XML_Char const   *filename , unsigned int flags ) ;
#line 27 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/xmlwf/xmlwf.c"
static void characterData(void *userData , XML_Char const   *s , int len ) 
{ 
  FILE *fp ;

  {
#line 30
  fp = (FILE *)userData;
  {
#line 31
  while (1) {
    while_continue: /* CIL Label */ ;
#line 31
    if (! (len > 0)) {
#line 31
      goto while_break;
    }
    {
#line 33
    if ((int const   )*s == 38) {
#line 33
      goto case_38;
    }
#line 36
    if ((int const   )*s == 60) {
#line 36
      goto case_60;
    }
#line 39
    if ((int const   )*s == 62) {
#line 39
      goto case_62;
    }
#line 47
    if ((int const   )*s == 34) {
#line 47
      goto case_34;
    }
#line 52
    if ((int const   )*s == 13) {
#line 52
      goto case_13;
    }
#line 52
    if ((int const   )*s == 10) {
#line 52
      goto case_13;
    }
#line 52
    if ((int const   )*s == 9) {
#line 52
      goto case_13;
    }
#line 56
    goto switch_default;
    case_38: /* CIL Label */ 
    {
#line 34
    fputs((char const   */* __restrict  */)"&amp;", (FILE */* __restrict  */)fp);
    }
#line 35
    goto switch_break;
    case_60: /* CIL Label */ 
    {
#line 37
    fputs((char const   */* __restrict  */)"&lt;", (FILE */* __restrict  */)fp);
    }
#line 38
    goto switch_break;
    case_62: /* CIL Label */ 
    {
#line 40
    fputs((char const   */* __restrict  */)"&gt;", (FILE */* __restrict  */)fp);
    }
#line 41
    goto switch_break;
    case_34: /* CIL Label */ 
    {
#line 48
    fputs((char const   */* __restrict  */)"&quot;", (FILE */* __restrict  */)fp);
    }
#line 49
    goto switch_break;
    case_13: /* CIL Label */ 
    case_10: /* CIL Label */ 
    case_9: /* CIL Label */ 
    {
#line 53
    fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"&#%d;",
            (int const   )*s);
    }
#line 54
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 57
    _IO_putc((int )*s, fp);
    }
#line 58
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 31
    len --;
#line 31
    s ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 61
  return;
}
}
#line 63 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/xmlwf/xmlwf.c"
static void attributeValue(FILE *fp , XML_Char const   *s ) 
{ 


  {
  {
#line 66
  _IO_putc('=', fp);
#line 67
  _IO_putc('\"', fp);
  }
  {
#line 68
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 71
    if ((int const   )*s == 1) {
#line 71
      goto case_1;
    }
#line 71
    if ((int const   )*s == 0) {
#line 71
      goto case_1;
    }
#line 74
    if ((int const   )*s == 38) {
#line 74
      goto case_38;
    }
#line 77
    if ((int const   )*s == 60) {
#line 77
      goto case_60;
    }
#line 80
    if ((int const   )*s == 34) {
#line 80
      goto case_34;
    }
#line 94
    if ((int const   )*s == 62) {
#line 94
      goto case_62;
    }
#line 99
    if ((int const   )*s == 13) {
#line 99
      goto case_13;
    }
#line 99
    if ((int const   )*s == 10) {
#line 99
      goto case_13;
    }
#line 99
    if ((int const   )*s == 9) {
#line 99
      goto case_13;
    }
#line 103
    goto switch_default;
    case_1: /* CIL Label */ 
    case_0: /* CIL Label */ 
    {
#line 72
    _IO_putc('\"', fp);
    }
#line 73
    return;
    case_38: /* CIL Label */ 
    {
#line 75
    fputs((char const   */* __restrict  */)"&amp;", (FILE */* __restrict  */)fp);
    }
#line 76
    goto switch_break;
    case_60: /* CIL Label */ 
    {
#line 78
    fputs((char const   */* __restrict  */)"&lt;", (FILE */* __restrict  */)fp);
    }
#line 79
    goto switch_break;
    case_34: /* CIL Label */ 
    {
#line 81
    fputs((char const   */* __restrict  */)"&quot;", (FILE */* __restrict  */)fp);
    }
#line 82
    goto switch_break;
    case_62: /* CIL Label */ 
    {
#line 95
    fputs((char const   */* __restrict  */)"&gt;", (FILE */* __restrict  */)fp);
    }
#line 96
    goto switch_break;
    case_13: /* CIL Label */ 
    case_10: /* CIL Label */ 
    case_9: /* CIL Label */ 
    {
#line 100
    fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"&#%d;",
            (int const   )*s);
    }
#line 101
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 104
    _IO_putc((int )*s, fp);
    }
#line 105
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 107
    s ++;
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 114 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/xmlwf/xmlwf.c"
static int attcmp(void const   *att1 , void const   *att2 ) 
{ 
  int tmp ;

  {
  {
#line 117
  tmp = strcmp(*((XML_Char const   **)att1), *((XML_Char const   **)att2));
  }
#line 117
  return (tmp);
}
}
#line 120 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/xmlwf/xmlwf.c"
static void startElement(void *userData , XML_Char const   *name , XML_Char const   **atts ) 
{ 
  int nAtts ;
  XML_Char const   **p ;
  FILE *fp ;
  XML_Char const   **tmp ;

  {
  {
#line 125
  fp = (FILE *)userData;
#line 126
  _IO_putc('<', fp);
#line 127
  fputs((char const   */* __restrict  */)name, (FILE */* __restrict  */)fp);
#line 129
  p = atts;
  }
  {
#line 130
  while (1) {
    while_continue: /* CIL Label */ ;
#line 130
    if (! *p) {
#line 130
      goto while_break;
    }
#line 131
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 132
  nAtts = (int )((p - atts) >> 1);
#line 133
  if (nAtts > 1) {
    {
#line 134
    qsort((void *)atts, (size_t )nAtts, sizeof(XML_Char *) * 2UL, & attcmp);
    }
  }
  {
#line 135
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 135
    if (! *atts) {
#line 135
      goto while_break___0;
    }
    {
#line 136
    _IO_putc(' ', fp);
#line 137
    tmp = atts;
#line 137
    atts ++;
#line 137
    fputs((char const   */* __restrict  */)*tmp, (FILE */* __restrict  */)fp);
#line 138
    attributeValue(fp, *atts);
#line 139
    atts ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 141
  _IO_putc('>', fp);
  }
#line 142
  return;
}
}
#line 144 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/xmlwf/xmlwf.c"
static void endElement(void *userData , XML_Char const   *name ) 
{ 
  FILE *fp ;

  {
  {
#line 147
  fp = (FILE *)userData;
#line 148
  _IO_putc('<', fp);
#line 149
  _IO_putc('/', fp);
#line 150
  fputs((char const   */* __restrict  */)name, (FILE */* __restrict  */)fp);
#line 151
  _IO_putc('>', fp);
  }
#line 152
  return;
}
}
#line 154 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/xmlwf/xmlwf.c"
static int nsattcmp(void const   *p1 , void const   *p2 ) 
{ 
  XML_Char const   *att1 ;
  XML_Char const   *att2 ;
  int sep1 ;
  char *tmp ;
  int sep2 ;
  char *tmp___0 ;
  int tmp___1 ;

  {
  {
#line 157
  att1 = *((XML_Char const   **)p1);
#line 158
  att2 = *((XML_Char const   **)p2);
#line 159
  tmp = strrchr(att1, '\001');
#line 159
  sep1 = (unsigned long )tmp != (unsigned long )((char *)0);
#line 160
  tmp___0 = strrchr(att1, '\001');
#line 160
  sep2 = (unsigned long )tmp___0 != (unsigned long )((char *)0);
  }
#line 161
  if (sep1 != sep2) {
#line 162
    return (sep1 - sep2);
  }
  {
#line 163
  tmp___1 = strcmp(att1, att2);
  }
#line 163
  return (tmp___1);
}
}
#line 166 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/xmlwf/xmlwf.c"
static void startElementNS(void *userData , XML_Char const   *name , XML_Char const   **atts ) 
{ 
  int nAtts ;
  int nsi ;
  XML_Char const   **p ;
  FILE *fp ;
  XML_Char const   *sep ;
  char *tmp ;
  XML_Char const   **tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;

  {
  {
#line 172
  fp = (FILE *)userData;
#line 174
  _IO_putc('<', fp);
#line 176
  tmp = strrchr(name, '\001');
#line 176
  sep = (XML_Char const   *)tmp;
  }
#line 177
  if (sep) {
    {
#line 178
    fputs((char const   */* __restrict  */)"n1:", (FILE */* __restrict  */)fp);
#line 179
    fputs((char const   */* __restrict  */)(sep + 1), (FILE */* __restrict  */)fp);
#line 180
    fputs((char const   */* __restrict  */)" xmlns:n1", (FILE */* __restrict  */)fp);
#line 181
    attributeValue(fp, name);
#line 182
    nsi = 2;
    }
  } else {
    {
#line 185
    fputs((char const   */* __restrict  */)name, (FILE */* __restrict  */)fp);
#line 186
    nsi = 1;
    }
  }
#line 189
  p = atts;
  {
#line 190
  while (1) {
    while_continue: /* CIL Label */ ;
#line 190
    if (! *p) {
#line 190
      goto while_break;
    }
#line 191
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 192
  nAtts = (int )((p - atts) >> 1);
#line 193
  if (nAtts > 1) {
    {
#line 194
    qsort((void *)atts, (size_t )nAtts, sizeof(XML_Char *) * 2UL, & nsattcmp);
    }
  }
  {
#line 195
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 195
    if (! *atts) {
#line 195
      goto while_break___0;
    }
    {
#line 196
    tmp___0 = atts;
#line 196
    atts ++;
#line 196
    name = *tmp___0;
#line 197
    tmp___1 = strrchr(name, '\001');
#line 197
    sep = (XML_Char const   *)tmp___1;
#line 198
    _IO_putc(' ', fp);
    }
#line 199
    if (sep) {
      {
#line 200
      fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"n%d:",
              nsi);
#line 201
      fputs((char const   */* __restrict  */)(sep + 1), (FILE */* __restrict  */)fp);
      }
    } else {
      {
#line 204
      fputs((char const   */* __restrict  */)name, (FILE */* __restrict  */)fp);
      }
    }
    {
#line 205
    attributeValue(fp, *atts);
    }
#line 206
    if (sep) {
      {
#line 207
      tmp___2 = nsi;
#line 207
      nsi ++;
#line 207
      fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)" xmlns:n%d",
              tmp___2);
#line 208
      attributeValue(fp, name);
      }
    }
#line 210
    atts ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 212
  _IO_putc('>', fp);
  }
#line 213
  return;
}
}
#line 215 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/xmlwf/xmlwf.c"
static void endElementNS(void *userData , XML_Char const   *name ) 
{ 
  FILE *fp ;
  XML_Char const   *sep ;
  char *tmp ;

  {
  {
#line 218
  fp = (FILE *)userData;
#line 220
  _IO_putc('<', fp);
#line 221
  _IO_putc('/', fp);
#line 222
  tmp = strrchr(name, '\001');
#line 222
  sep = (XML_Char const   *)tmp;
  }
#line 223
  if (sep) {
    {
#line 224
    fputs((char const   */* __restrict  */)"n1:", (FILE */* __restrict  */)fp);
#line 225
    fputs((char const   */* __restrict  */)(sep + 1), (FILE */* __restrict  */)fp);
    }
  } else {
    {
#line 228
    fputs((char const   */* __restrict  */)name, (FILE */* __restrict  */)fp);
    }
  }
  {
#line 229
  _IO_putc('>', fp);
  }
#line 230
  return;
}
}
#line 234 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/xmlwf/xmlwf.c"
static void processingInstruction(void *userData , XML_Char const   *target , XML_Char const   *data ) 
{ 
  FILE *fp ;

  {
  {
#line 238
  fp = (FILE *)userData;
#line 239
  _IO_putc('<', fp);
#line 240
  _IO_putc('?', fp);
#line 241
  fputs((char const   */* __restrict  */)target, (FILE */* __restrict  */)fp);
#line 242
  _IO_putc(' ', fp);
#line 243
  fputs((char const   */* __restrict  */)data, (FILE */* __restrict  */)fp);
#line 244
  _IO_putc('?', fp);
#line 245
  _IO_putc('>', fp);
  }
#line 246
  return;
}
}
#line 250 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/xmlwf/xmlwf.c"
static void defaultCharacterData(void *userData , XML_Char const   *s , int len ) 
{ 


  {
  {
#line 253
  XML_DefaultCurrent((XML_Parser )userData);
  }
#line 254
  return;
}
}
#line 256 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/xmlwf/xmlwf.c"
static void defaultStartElement(void *userData , XML_Char const   *name , XML_Char const   **atts ) 
{ 


  {
  {
#line 260
  XML_DefaultCurrent((XML_Parser )userData);
  }
#line 261
  return;
}
}
#line 263 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/xmlwf/xmlwf.c"
static void defaultEndElement(void *userData , XML_Char const   *name ) 
{ 


  {
  {
#line 266
  XML_DefaultCurrent((XML_Parser )userData);
  }
#line 267
  return;
}
}
#line 269 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/xmlwf/xmlwf.c"
static void defaultProcessingInstruction(void *userData , XML_Char const   *target ,
                                         XML_Char const   *data ) 
{ 


  {
  {
#line 273
  XML_DefaultCurrent((XML_Parser )userData);
  }
#line 274
  return;
}
}
#line 276 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/xmlwf/xmlwf.c"
static void nopCharacterData(void *userData , XML_Char const   *s , int len ) 
{ 


  {
#line 279
  return;
}
}
#line 281 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/xmlwf/xmlwf.c"
static void nopStartElement(void *userData , XML_Char const   *name , XML_Char const   **atts ) 
{ 


  {
#line 284
  return;
}
}
#line 286 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/xmlwf/xmlwf.c"
static void nopEndElement(void *userData , XML_Char const   *name ) 
{ 


  {
#line 289
  return;
}
}
#line 291 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/xmlwf/xmlwf.c"
static void nopProcessingInstruction(void *userData , XML_Char const   *target , XML_Char const   *data ) 
{ 


  {
#line 295
  return;
}
}
#line 297 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/xmlwf/xmlwf.c"
static void markup(void *userData , XML_Char const   *s , int len ) 
{ 
  FILE *fp ;

  {
#line 300
  fp = (FILE *)*((void **)((XML_Parser )userData));
  {
#line 301
  while (1) {
    while_continue: /* CIL Label */ ;
#line 301
    if (! (len > 0)) {
#line 301
      goto while_break;
    }
    {
#line 302
    _IO_putc((int )*s, fp);
#line 301
    len --;
#line 301
    s ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 303
  return;
}
}
#line 305 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/xmlwf/xmlwf.c"
static void metaLocation(XML_Parser parser ) 
{ 
  XML_Char const   *uri ;
  XML_Char const   *tmp ;
  XML_Size tmp___0 ;
  XML_Size tmp___1 ;
  int tmp___2 ;
  XML_Index tmp___3 ;

  {
  {
#line 308
  tmp = XML_GetBase(parser);
#line 308
  uri = tmp;
  }
#line 309
  if (uri) {
    {
#line 310
    fprintf((FILE */* __restrict  */)((FILE *)*((void **)parser)), (char const   */* __restrict  */)" uri=\"%s\"",
            uri);
    }
  }
  {
#line 311
  tmp___0 = XML_GetCurrentColumnNumber(parser);
#line 311
  tmp___1 = XML_GetCurrentLineNumber(parser);
#line 311
  tmp___2 = XML_GetCurrentByteCount(parser);
#line 311
  tmp___3 = XML_GetCurrentByteIndex(parser);
#line 311
  fprintf((FILE */* __restrict  */)((FILE *)*((void **)parser)), (char const   */* __restrict  */)" byte=\"%ld\" nbytes=\"%d\" \t\t\t line=\"%lu\" col=\"%lu\"",
          tmp___3, tmp___2, tmp___1, tmp___0);
  }
#line 318
  return;
}
}
#line 320 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/xmlwf/xmlwf.c"
static void metaStartDocument(void *userData ) 
{ 


  {
  {
#line 323
  fputs((char const   */* __restrict  */)"<document>\n", (FILE */* __restrict  */)((FILE *)*((void **)((XML_Parser )userData))));
  }
#line 324
  return;
}
}
#line 326 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/xmlwf/xmlwf.c"
static void metaEndDocument(void *userData ) 
{ 


  {
  {
#line 329
  fputs((char const   */* __restrict  */)"</document>\n", (FILE */* __restrict  */)((FILE *)*((void **)((XML_Parser )userData))));
  }
#line 330
  return;
}
}
#line 332 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/xmlwf/xmlwf.c"
static void metaStartElement(void *userData , XML_Char const   *name , XML_Char const   **atts ) 
{ 
  XML_Parser parser ;
  FILE *fp ;
  XML_Char const   **specifiedAttsEnd ;
  int tmp ;
  XML_Char const   **idAttPtr ;
  int idAttIndex ;
  int tmp___0 ;
  size_t tmp___1 ;

  {
  {
#line 336
  parser = (XML_Parser )userData;
#line 337
  fp = (FILE *)*((void **)parser);
#line 338
  tmp = XML_GetSpecifiedAttributeCount(parser);
#line 338
  specifiedAttsEnd = atts + tmp;
#line 341
  tmp___0 = XML_GetIdAttributeIndex(parser);
#line 341
  idAttIndex = tmp___0;
  }
#line 342
  if (idAttIndex < 0) {
#line 343
    idAttPtr = (XML_Char const   **)0;
  } else {
#line 345
    idAttPtr = atts + idAttIndex;
  }
  {
#line 347
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"<starttag name=\"%s\"",
          name);
#line 348
  metaLocation(parser);
  }
#line 349
  if (*atts) {
    {
#line 350
    fputs((char const   */* __restrict  */)">\n", (FILE */* __restrict  */)fp);
    }
    {
#line 351
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 352
      fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"<attribute name=\"%s\" value=\"",
              *(atts + 0));
#line 353
      tmp___1 = strlen(*(atts + 1));
#line 353
      characterData((void *)fp, *(atts + 1), (int )tmp___1);
      }
#line 354
      if ((unsigned long )atts >= (unsigned long )specifiedAttsEnd) {
        {
#line 355
        fputs((char const   */* __restrict  */)"\" defaulted=\"yes\"/>\n", (FILE */* __restrict  */)fp);
        }
      } else
#line 356
      if ((unsigned long )atts == (unsigned long )idAttPtr) {
        {
#line 357
        fputs((char const   */* __restrict  */)"\" id=\"yes\"/>\n", (FILE */* __restrict  */)fp);
        }
      } else {
        {
#line 359
        fputs((char const   */* __restrict  */)"\"/>\n", (FILE */* __restrict  */)fp);
        }
      }
#line 351
      atts += 2;
#line 351
      if (! *atts) {
#line 351
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 361
    fputs((char const   */* __restrict  */)"</starttag>\n", (FILE */* __restrict  */)fp);
    }
  } else {
    {
#line 364
    fputs((char const   */* __restrict  */)"/>\n", (FILE */* __restrict  */)fp);
    }
  }
#line 365
  return;
}
}
#line 367 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/xmlwf/xmlwf.c"
static void metaEndElement(void *userData , XML_Char const   *name ) 
{ 
  XML_Parser parser ;
  FILE *fp ;

  {
  {
#line 370
  parser = (XML_Parser )userData;
#line 371
  fp = (FILE *)*((void **)parser);
#line 372
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"<endtag name=\"%s\"",
          name);
#line 373
  metaLocation(parser);
#line 374
  fputs((char const   */* __restrict  */)"/>\n", (FILE */* __restrict  */)fp);
  }
#line 375
  return;
}
}
#line 377 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/xmlwf/xmlwf.c"
static void metaProcessingInstruction(void *userData , XML_Char const   *target ,
                                      XML_Char const   *data ) 
{ 
  XML_Parser parser ;
  FILE *fp ;
  size_t tmp ;

  {
  {
#line 381
  parser = (XML_Parser )userData;
#line 382
  fp = (FILE *)*((void **)parser);
#line 383
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"<pi target=\"%s\" data=\"",
          target);
#line 384
  tmp = strlen(data);
#line 384
  characterData((void *)fp, data, (int )tmp);
#line 385
  _IO_putc('\"', fp);
#line 386
  metaLocation(parser);
#line 387
  fputs((char const   */* __restrict  */)"/>\n", (FILE */* __restrict  */)fp);
  }
#line 388
  return;
}
}
#line 390 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/xmlwf/xmlwf.c"
static void metaComment(void *userData , XML_Char const   *data ) 
{ 
  XML_Parser parser ;
  FILE *fp ;
  size_t tmp ;

  {
  {
#line 393
  parser = (XML_Parser )userData;
#line 394
  fp = (FILE *)*((void **)parser);
#line 395
  fputs((char const   */* __restrict  */)"<comment data=\"", (FILE */* __restrict  */)fp);
#line 396
  tmp = strlen(data);
#line 396
  characterData((void *)fp, data, (int )tmp);
#line 397
  _IO_putc('\"', fp);
#line 398
  metaLocation(parser);
#line 399
  fputs((char const   */* __restrict  */)"/>\n", (FILE */* __restrict  */)fp);
  }
#line 400
  return;
}
}
#line 402 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/xmlwf/xmlwf.c"
static void metaStartCdataSection(void *userData ) 
{ 
  XML_Parser parser ;
  FILE *fp ;

  {
  {
#line 405
  parser = (XML_Parser )userData;
#line 406
  fp = (FILE *)*((void **)parser);
#line 407
  fputs((char const   */* __restrict  */)"<startcdata", (FILE */* __restrict  */)fp);
#line 408
  metaLocation(parser);
#line 409
  fputs((char const   */* __restrict  */)"/>\n", (FILE */* __restrict  */)fp);
  }
#line 410
  return;
}
}
#line 412 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/xmlwf/xmlwf.c"
static void metaEndCdataSection(void *userData ) 
{ 
  XML_Parser parser ;
  FILE *fp ;

  {
  {
#line 415
  parser = (XML_Parser )userData;
#line 416
  fp = (FILE *)*((void **)parser);
#line 417
  fputs((char const   */* __restrict  */)"<endcdata", (FILE */* __restrict  */)fp);
#line 418
  metaLocation(parser);
#line 419
  fputs((char const   */* __restrict  */)"/>\n", (FILE */* __restrict  */)fp);
  }
#line 420
  return;
}
}
#line 422 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/xmlwf/xmlwf.c"
static void metaCharacterData(void *userData , XML_Char const   *s , int len ) 
{ 
  XML_Parser parser ;
  FILE *fp ;

  {
  {
#line 425
  parser = (XML_Parser )userData;
#line 426
  fp = (FILE *)*((void **)parser);
#line 427
  fputs((char const   */* __restrict  */)"<chars str=\"", (FILE */* __restrict  */)fp);
#line 428
  characterData((void *)fp, s, len);
#line 429
  _IO_putc('\"', fp);
#line 430
  metaLocation(parser);
#line 431
  fputs((char const   */* __restrict  */)"/>\n", (FILE */* __restrict  */)fp);
  }
#line 432
  return;
}
}
#line 434 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/xmlwf/xmlwf.c"
static void metaStartDoctypeDecl(void *userData , XML_Char const   *doctypeName ,
                                 XML_Char const   *sysid , XML_Char const   *pubid ,
                                 int has_internal_subset ) 
{ 
  XML_Parser parser ;
  FILE *fp ;

  {
  {
#line 441
  parser = (XML_Parser )userData;
#line 442
  fp = (FILE *)*((void **)parser);
#line 443
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"<startdoctype name=\"%s\"",
          doctypeName);
#line 444
  metaLocation(parser);
#line 445
  fputs((char const   */* __restrict  */)"/>\n", (FILE */* __restrict  */)fp);
  }
#line 446
  return;
}
}
#line 448 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/xmlwf/xmlwf.c"
static void metaEndDoctypeDecl(void *userData ) 
{ 
  XML_Parser parser ;
  FILE *fp ;

  {
  {
#line 451
  parser = (XML_Parser )userData;
#line 452
  fp = (FILE *)*((void **)parser);
#line 453
  fputs((char const   */* __restrict  */)"<enddoctype", (FILE */* __restrict  */)fp);
#line 454
  metaLocation(parser);
#line 455
  fputs((char const   */* __restrict  */)"/>\n", (FILE */* __restrict  */)fp);
  }
#line 456
  return;
}
}
#line 458 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/xmlwf/xmlwf.c"
static void metaNotationDecl(void *userData , XML_Char const   *notationName , XML_Char const   *base ,
                             XML_Char const   *systemId , XML_Char const   *publicId ) 
{ 
  XML_Parser parser ;
  FILE *fp ;
  size_t tmp ;

  {
  {
#line 465
  parser = (XML_Parser )userData;
#line 466
  fp = (FILE *)*((void **)parser);
#line 467
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"<notation name=\"%s\"",
          notationName);
  }
#line 468
  if (publicId) {
    {
#line 469
    fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)" public=\"%s\"",
            publicId);
    }
  }
#line 470
  if (systemId) {
    {
#line 471
    fputs((char const   */* __restrict  */)" system=\"", (FILE */* __restrict  */)fp);
#line 472
    tmp = strlen(systemId);
#line 472
    characterData((void *)fp, systemId, (int )tmp);
#line 473
    _IO_putc('\"', fp);
    }
  }
  {
#line 475
  metaLocation(parser);
#line 476
  fputs((char const   */* __restrict  */)"/>\n", (FILE */* __restrict  */)fp);
  }
#line 477
  return;
}
}
#line 480 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/xmlwf/xmlwf.c"
static void metaEntityDecl(void *userData , XML_Char const   *entityName , int is_param ,
                           XML_Char const   *value , int value_length , XML_Char const   *base ,
                           XML_Char const   *systemId , XML_Char const   *publicId ,
                           XML_Char const   *notationName ) 
{ 
  XML_Parser parser ;
  FILE *fp ;
  size_t tmp ;
  size_t tmp___0 ;

  {
#line 491
  parser = (XML_Parser )userData;
#line 492
  fp = (FILE *)*((void **)parser);
#line 494
  if (value) {
    {
#line 495
    fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"<entity name=\"%s\"",
            entityName);
#line 496
    metaLocation(parser);
#line 497
    _IO_putc('>', fp);
#line 498
    characterData((void *)fp, value, value_length);
#line 499
    fputs((char const   */* __restrict  */)"</entity/>\n", (FILE */* __restrict  */)fp);
    }
  } else
#line 501
  if (notationName) {
    {
#line 502
    fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"<entity name=\"%s\"",
            entityName);
    }
#line 503
    if (publicId) {
      {
#line 504
      fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)" public=\"%s\"",
              publicId);
      }
    }
    {
#line 505
    fputs((char const   */* __restrict  */)" system=\"", (FILE */* __restrict  */)fp);
#line 506
    tmp = strlen(systemId);
#line 506
    characterData((void *)fp, systemId, (int )tmp);
#line 507
    _IO_putc('\"', fp);
#line 508
    fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)" notation=\"%s\"",
            notationName);
#line 509
    metaLocation(parser);
#line 510
    fputs((char const   */* __restrict  */)"/>\n", (FILE */* __restrict  */)fp);
    }
  } else {
    {
#line 513
    fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"<entity name=\"%s\"",
            entityName);
    }
#line 514
    if (publicId) {
      {
#line 515
      fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)" public=\"%s\"",
              publicId);
      }
    }
    {
#line 516
    fputs((char const   */* __restrict  */)" system=\"", (FILE */* __restrict  */)fp);
#line 517
    tmp___0 = strlen(systemId);
#line 517
    characterData((void *)fp, systemId, (int )tmp___0);
#line 518
    _IO_putc('\"', fp);
#line 519
    metaLocation(parser);
#line 520
    fputs((char const   */* __restrict  */)"/>\n", (FILE */* __restrict  */)fp);
    }
  }
#line 522
  return;
}
}
#line 524 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/xmlwf/xmlwf.c"
static void metaStartNamespaceDecl(void *userData , XML_Char const   *prefix , XML_Char const   *uri ) 
{ 
  XML_Parser parser ;
  FILE *fp ;
  size_t tmp ;

  {
  {
#line 529
  parser = (XML_Parser )userData;
#line 530
  fp = (FILE *)*((void **)parser);
#line 531
  fputs((char const   */* __restrict  */)"<startns", (FILE */* __restrict  */)fp);
  }
#line 532
  if (prefix) {
    {
#line 533
    fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)" prefix=\"%s\"",
            prefix);
    }
  }
#line 534
  if (uri) {
    {
#line 535
    fputs((char const   */* __restrict  */)" ns=\"", (FILE */* __restrict  */)fp);
#line 536
    tmp = strlen(uri);
#line 536
    characterData((void *)fp, uri, (int )tmp);
#line 537
    fputs((char const   */* __restrict  */)"\"/>\n", (FILE */* __restrict  */)fp);
    }
  } else {
    {
#line 540
    fputs((char const   */* __restrict  */)"/>\n", (FILE */* __restrict  */)fp);
    }
  }
#line 541
  return;
}
}
#line 543 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/xmlwf/xmlwf.c"
static void metaEndNamespaceDecl(void *userData , XML_Char const   *prefix ) 
{ 
  XML_Parser parser ;
  FILE *fp ;

  {
#line 546
  parser = (XML_Parser )userData;
#line 547
  fp = (FILE *)*((void **)parser);
#line 548
  if (! prefix) {
    {
#line 549
    fputs((char const   */* __restrict  */)"<endns/>\n", (FILE */* __restrict  */)fp);
    }
  } else {
    {
#line 551
    fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"<endns prefix=\"%s\"/>\n",
            prefix);
    }
  }
#line 552
  return;
}
}
#line 554 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/xmlwf/xmlwf.c"
static int unknownEncodingConvert(void *data , char const   *p ) 
{ 
  int tmp ;

  {
  {
#line 557
  tmp = codepageConvert(*((int *)data), p);
  }
#line 557
  return (tmp);
}
}
#line 564
static int unknownEncoding(void *userData , XML_Char const   *name , XML_Encoding *info ) ;
#line 564 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/xmlwf/xmlwf.c"
static XML_Char const   prefixL[9]  = 
#line 564
  {      (XML_Char const   )'w',      (XML_Char const   )'i',      (XML_Char const   )'n',      (XML_Char const   )'d', 
        (XML_Char const   )'o',      (XML_Char const   )'w',      (XML_Char const   )'s',      (XML_Char const   )'-', 
        (XML_Char const   )'\000'};
#line 565 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/xmlwf/xmlwf.c"
static XML_Char const   prefixU[9]  = 
#line 565
  {      (XML_Char const   )'W',      (XML_Char const   )'I',      (XML_Char const   )'N',      (XML_Char const   )'D', 
        (XML_Char const   )'O',      (XML_Char const   )'W',      (XML_Char const   )'S',      (XML_Char const   )'-', 
        (XML_Char const   )'\000'};
#line 574 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/xmlwf/xmlwf.c"
static XML_Char const   digits[11]  = 
#line 574
  {      (XML_Char const   )'0',      (XML_Char const   )'1',      (XML_Char const   )'2',      (XML_Char const   )'3', 
        (XML_Char const   )'4',      (XML_Char const   )'5',      (XML_Char const   )'6',      (XML_Char const   )'7', 
        (XML_Char const   )'8',      (XML_Char const   )'9',      (XML_Char const   )'\000'};
#line 560 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/xmlwf/xmlwf.c"
static int unknownEncoding(void *userData , XML_Char const   *name , XML_Encoding *info ) 
{ 
  int cp ;
  int i ;
  XML_Char const   *s ;
  char *tmp ;
  int tmp___0 ;

  {
#line 568
  i = 0;
  {
#line 568
  while (1) {
    while_continue: /* CIL Label */ ;
#line 568
    if (! prefixU[i]) {
#line 568
      goto while_break;
    }
#line 569
    if ((int const   )*(name + i) != (int const   )prefixU[i]) {
#line 569
      if ((int const   )*(name + i) != (int const   )prefixL[i]) {
#line 570
        return (0);
      }
    }
#line 568
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 572
  cp = 0;
  {
#line 573
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 573
    if (! *(name + i)) {
#line 573
      goto while_break___0;
    }
    {
#line 575
    tmp = strchr(digits, (int )*(name + i));
#line 575
    s = (XML_Char const   *)tmp;
    }
#line 576
    if (! s) {
#line 577
      return (0);
    }
#line 578
    cp *= 10;
#line 579
    cp += (int )(s - digits);
#line 580
    if (cp >= 65536) {
#line 581
      return (0);
    }
#line 573
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 583
  tmp___0 = codepageMap(cp, info->map);
  }
#line 583
  if (! tmp___0) {
#line 584
    return (0);
  }
  {
#line 585
  info->convert = & unknownEncodingConvert;
#line 588
  info->release = (void (*)(void *data ))(& free);
#line 589
  info->data = malloc(sizeof(int ));
  }
#line 590
  if (! info->data) {
#line 591
    return (0);
  }
#line 592
  *((int *)info->data) = cp;
#line 593
  return (1);
}
}
#line 596 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/xmlwf/xmlwf.c"
static int notStandalone(void *userData ) 
{ 


  {
#line 599
  return (0);
}
}
#line 602 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/xmlwf/xmlwf.c"
static void showVersion(XML_Char *prog ) 
{ 
  XML_Char *s ;
  XML_Char ch ;
  XML_Feature const   *features___1 ;
  XML_Feature const   *tmp ;
  XML_LChar const   *tmp___0 ;
  int i ;

  {
  {
#line 605
  s = prog;
#line 607
  tmp = XML_GetFeatureList();
#line 607
  features___1 = tmp;
  }
  {
#line 608
  while (1) {
    while_continue: /* CIL Label */ ;
#line 608
    ch = *s;
#line 608
    if (! ((int )ch != 0)) {
#line 608
      goto while_break;
    }
#line 609
    if ((int )ch == 47) {
#line 614
      prog = s + 1;
    }
#line 615
    s ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 617
  tmp___0 = XML_ExpatVersion();
#line 617
  fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"%s using %s\n",
          prog, tmp___0);
  }
#line 618
  if ((unsigned long )features___1 != (unsigned long )((void *)0)) {
#line 618
    if ((unsigned int const   )(features___1 + 0)->feature != 0U) {
      {
#line 619
      i = 1;
#line 620
      fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"%s",
              (features___1 + 0)->name);
      }
#line 621
      if ((features___1 + 0)->value) {
        {
#line 622
        fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"=%ld",
                (features___1 + 0)->value);
        }
      }
      {
#line 623
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 623
        if (! ((unsigned int const   )(features___1 + i)->feature != 0U)) {
#line 623
          goto while_break___0;
        }
        {
#line 624
        fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)", %s",
                (features___1 + i)->name);
        }
#line 625
        if ((features___1 + i)->value) {
          {
#line 626
          fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"=%ld",
                  (features___1 + i)->value);
          }
        }
#line 627
        i ++;
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 629
      fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"\n");
      }
    }
  }
#line 631
  return;
}
}
#line 633 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/xmlwf/xmlwf.c"
static void usage(XML_Char const   *prog , int rc ) 
{ 


  {
  {
#line 636
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"usage: %s [-n] [-p] [-r] [-s] [-w] [-x] [-d output-dir] [-e encoding] file ...\n",
          prog);
#line 639
  exit(rc);
  }
}
}
#line 642 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/xmlwf/xmlwf.c"
int main(int argc , XML_Char **argv ) 
{ 
  int i ;
  int j ;
  XML_Char const   *outputDir ;
  XML_Char const   *encoding ;
  unsigned int processFlags ;
  int windowsCodePages ;
  int outputType ;
  int useNamespaces ;
  int requireStandalone ;
  enum XML_ParamEntityParsing paramEntityParsing ;
  int useStdin ;
  FILE *fp ;
  XML_Char *outName ;
  int result ;
  XML_Parser parser ;
  XML_Char const   *delim ;
  XML_Char const   *file ;
  char const   *tmp ;
  XML_Char const   *lastDelim ;
  char *tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  void *tmp___3 ;
  XML_Char *tmp___4 ;

  {
#line 646
  outputDir = (XML_Char const   *)((void *)0);
#line 647
  encoding = (XML_Char const   *)((void *)0);
#line 648
  processFlags = 1U;
#line 649
  windowsCodePages = 0;
#line 650
  outputType = 0;
#line 651
  useNamespaces = 0;
#line 652
  requireStandalone = 0;
#line 653
  paramEntityParsing = (enum XML_ParamEntityParsing )0;
#line 655
  useStdin = 0;
#line 661
  i = 1;
#line 662
  j = 0;
  {
#line 663
  while (1) {
    while_continue: /* CIL Label */ ;
#line 663
    if (! (i < argc)) {
#line 663
      goto while_break;
    }
#line 664
    if (j == 0) {
#line 665
      if ((int )*(*(argv + i) + 0) != 45) {
#line 666
        goto while_break;
      }
#line 667
      if ((int )*(*(argv + i) + 1) == 45) {
#line 667
        if ((int )*(*(argv + i) + 2) == 0) {
#line 668
          i ++;
#line 669
          goto while_break;
        }
      }
#line 671
      j ++;
    }
    {
#line 674
    if ((int )*(*(argv + i) + j) == 114) {
#line 674
      goto case_114;
    }
#line 678
    if ((int )*(*(argv + i) + j) == 115) {
#line 678
      goto case_115;
    }
#line 682
    if ((int )*(*(argv + i) + j) == 110) {
#line 682
      goto case_110;
    }
#line 686
    if ((int )*(*(argv + i) + j) == 112) {
#line 686
      goto case_112;
    }
#line 689
    if ((int )*(*(argv + i) + j) == 120) {
#line 689
      goto case_120;
    }
#line 693
    if ((int )*(*(argv + i) + j) == 119) {
#line 693
      goto case_119;
    }
#line 697
    if ((int )*(*(argv + i) + j) == 109) {
#line 697
      goto case_109;
    }
#line 701
    if ((int )*(*(argv + i) + j) == 99) {
#line 701
      goto case_99;
    }
#line 706
    if ((int )*(*(argv + i) + j) == 116) {
#line 706
      goto case_116;
    }
#line 710
    if ((int )*(*(argv + i) + j) == 100) {
#line 710
      goto case_100;
    }
#line 721
    if ((int )*(*(argv + i) + j) == 101) {
#line 721
      goto case_101;
    }
#line 732
    if ((int )*(*(argv + i) + j) == 104) {
#line 732
      goto case_104;
    }
#line 735
    if ((int )*(*(argv + i) + j) == 118) {
#line 735
      goto case_118;
    }
#line 738
    if ((int )*(*(argv + i) + j) == 0) {
#line 738
      goto case_0;
    }
#line 745
    goto switch_default;
    case_114: /* CIL Label */ 
#line 675
    processFlags &= 4294967294U;
#line 676
    j ++;
#line 677
    goto switch_break;
    case_115: /* CIL Label */ 
#line 679
    requireStandalone = 1;
#line 680
    j ++;
#line 681
    goto switch_break;
    case_110: /* CIL Label */ 
#line 683
    useNamespaces = 1;
#line 684
    j ++;
#line 685
    goto switch_break;
    case_112: /* CIL Label */ 
#line 687
    paramEntityParsing = (enum XML_ParamEntityParsing )2;
    case_120: /* CIL Label */ 
#line 690
    processFlags |= 2U;
#line 691
    j ++;
#line 692
    goto switch_break;
    case_119: /* CIL Label */ 
#line 694
    windowsCodePages = 1;
#line 695
    j ++;
#line 696
    goto switch_break;
    case_109: /* CIL Label */ 
#line 698
    outputType = 'm';
#line 699
    j ++;
#line 700
    goto switch_break;
    case_99: /* CIL Label */ 
#line 702
    outputType = 'c';
#line 703
    useNamespaces = 0;
#line 704
    j ++;
#line 705
    goto switch_break;
    case_116: /* CIL Label */ 
#line 707
    outputType = 't';
#line 708
    j ++;
#line 709
    goto switch_break;
    case_100: /* CIL Label */ 
#line 711
    if ((int )*(*(argv + i) + (j + 1)) == 0) {
#line 712
      i ++;
#line 712
      if (i == argc) {
        {
#line 713
        usage((XML_Char const   *)*(argv + 0), 2);
        }
      }
#line 714
      outputDir = (XML_Char const   *)*(argv + i);
    } else {
#line 717
      outputDir = (XML_Char const   *)((*(argv + i) + j) + 1);
    }
#line 718
    i ++;
#line 719
    j = 0;
#line 720
    goto switch_break;
    case_101: /* CIL Label */ 
#line 722
    if ((int )*(*(argv + i) + (j + 1)) == 0) {
#line 723
      i ++;
#line 723
      if (i == argc) {
        {
#line 724
        usage((XML_Char const   *)*(argv + 0), 2);
        }
      }
#line 725
      encoding = (XML_Char const   *)*(argv + i);
    } else {
#line 728
      encoding = (XML_Char const   *)((*(argv + i) + j) + 1);
    }
#line 729
    i ++;
#line 730
    j = 0;
#line 731
    goto switch_break;
    case_104: /* CIL Label */ 
    {
#line 733
    usage((XML_Char const   *)*(argv + 0), 0);
    }
#line 734
    return (0);
    case_118: /* CIL Label */ 
    {
#line 736
    showVersion(*(argv + 0));
    }
#line 737
    return (0);
    case_0: /* CIL Label */ 
#line 739
    if (j > 1) {
#line 740
      i ++;
#line 741
      j = 0;
#line 742
      goto switch_break;
    }
    switch_default: /* CIL Label */ 
    {
#line 746
    usage((XML_Char const   *)*(argv + 0), 2);
    }
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 749
  if (i == argc) {
#line 750
    useStdin = 1;
#line 751
    processFlags &= 4294967294U;
#line 752
    i --;
  }
  {
#line 754
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 754
    if (! (i < argc)) {
#line 754
      goto while_break___0;
    }
#line 755
    fp = (FILE *)0;
#line 756
    outName = (XML_Char *)0;
#line 759
    if (useNamespaces) {
      {
#line 760
      parser = XML_ParserCreateNS(encoding, (XML_Char )'\001');
      }
    } else {
      {
#line 762
      parser = XML_ParserCreate(encoding);
      }
    }
#line 763
    if (requireStandalone) {
      {
#line 764
      XML_SetNotStandaloneHandler(parser, & notStandalone);
      }
    }
    {
#line 765
    XML_SetParamEntityParsing(parser, paramEntityParsing);
    }
#line 766
    if (outputType == 116) {
      {
#line 769
      outputDir = (XML_Char const   *)0;
#line 770
      XML_SetElementHandler(parser, & nopStartElement, & nopEndElement);
#line 771
      XML_SetCharacterDataHandler(parser, & nopCharacterData);
#line 772
      XML_SetProcessingInstructionHandler(parser, & nopProcessingInstruction);
      }
    } else
#line 774
    if (outputDir) {
#line 775
      delim = "/";
#line 776
      if (useStdin) {
#line 776
        tmp = "STDIN";
      } else {
#line 776
        tmp = (char const   *)*(argv + i);
      }
#line 776
      file = tmp;
#line 777
      if (! useStdin) {
        {
#line 779
        tmp___0 = strrchr(file, (int )*(delim + 0));
#line 779
        lastDelim = (XML_Char const   *)tmp___0;
        }
#line 780
        if (lastDelim) {
#line 781
          file = lastDelim + 1;
        }
      }
      {
#line 793
      tmp___1 = strlen(outputDir);
#line 793
      tmp___2 = strlen(file);
#line 793
      tmp___3 = malloc(((tmp___1 + tmp___2) + 2UL) * sizeof(XML_Char ));
#line 793
      outName = (XML_Char *)tmp___3;
#line 795
      strcpy((char */* __restrict  */)outName, (char const   */* __restrict  */)outputDir);
#line 796
      strcat((char */* __restrict  */)outName, (char const   */* __restrict  */)delim);
#line 797
      strcat((char */* __restrict  */)outName, (char const   */* __restrict  */)file);
#line 798
      fp = fopen((char const   */* __restrict  */)outName, (char const   */* __restrict  */)"wb");
      }
#line 799
      if (! fp) {
        {
#line 800
        perror((char const   *)outName);
#line 801
        exit(1);
        }
      }
      {
#line 803
      setvbuf((FILE */* __restrict  */)fp, (char */* __restrict  */)((void *)0), 0,
              (size_t )16384);
#line 807
      XML_SetUserData(parser, (void *)fp);
      }
      {
#line 809
      if (outputType == 109) {
#line 809
        goto case_109___0;
      }
#line 825
      if (outputType == 99) {
#line 825
        goto case_99___0;
      }
#line 833
      goto switch_default___0;
      case_109___0: /* CIL Label */ 
      {
#line 810
      XML_UseParserAsHandlerArg(parser);
#line 811
      XML_SetElementHandler(parser, & metaStartElement, & metaEndElement);
#line 812
      XML_SetProcessingInstructionHandler(parser, & metaProcessingInstruction);
#line 813
      XML_SetCommentHandler(parser, & metaComment);
#line 814
      XML_SetCdataSectionHandler(parser, & metaStartCdataSection, & metaEndCdataSection);
#line 816
      XML_SetCharacterDataHandler(parser, & metaCharacterData);
#line 817
      XML_SetDoctypeDeclHandler(parser, & metaStartDoctypeDecl, & metaEndDoctypeDecl);
#line 819
      XML_SetEntityDeclHandler(parser, & metaEntityDecl);
#line 820
      XML_SetNotationDeclHandler(parser, & metaNotationDecl);
#line 821
      XML_SetNamespaceDeclHandler(parser, & metaStartNamespaceDecl, & metaEndNamespaceDecl);
#line 823
      metaStartDocument((void *)parser);
      }
#line 824
      goto switch_break___0;
      case_99___0: /* CIL Label */ 
      {
#line 826
      XML_UseParserAsHandlerArg(parser);
#line 827
      XML_SetDefaultHandler(parser, & markup);
#line 828
      XML_SetElementHandler(parser, & defaultStartElement, & defaultEndElement);
#line 829
      XML_SetCharacterDataHandler(parser, & defaultCharacterData);
#line 830
      XML_SetProcessingInstructionHandler(parser, & defaultProcessingInstruction);
      }
#line 832
      goto switch_break___0;
      switch_default___0: /* CIL Label */ 
#line 834
      if (useNamespaces) {
        {
#line 835
        XML_SetElementHandler(parser, & startElementNS, & endElementNS);
        }
      } else {
        {
#line 837
        XML_SetElementHandler(parser, & startElement, & endElement);
        }
      }
      {
#line 838
      XML_SetCharacterDataHandler(parser, & characterData);
#line 840
      XML_SetProcessingInstructionHandler(parser, & processingInstruction);
      }
#line 842
      goto switch_break___0;
      switch_break___0: /* CIL Label */ ;
      }
    }
#line 845
    if (windowsCodePages) {
      {
#line 846
      XML_SetUnknownEncodingHandler(parser, & unknownEncoding, (void *)0);
      }
    }
#line 847
    if (useStdin) {
#line 847
      tmp___4 = (XML_Char *)((void *)0);
    } else {
#line 847
      tmp___4 = *(argv + i);
    }
    {
#line 847
    result = XML_ProcessFile(parser, (XML_Char const   *)tmp___4, processFlags);
    }
#line 848
    if (outputDir) {
#line 849
      if (outputType == 109) {
        {
#line 850
        metaEndDocument((void *)parser);
        }
      }
      {
#line 851
      fclose(fp);
      }
#line 852
      if (! result) {
        {
#line 853
        remove((char const   *)outName);
#line 854
        exit(2);
        }
      }
      {
#line 856
      free((void *)outName);
      }
    }
    {
#line 858
    XML_ParserFree(parser);
#line 754
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 860
  return (0);
}
}
#line 46 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memcpy)(void * __restrict  __dest ,
                                                                                                 void const   * __restrict  __src ,
                                                                                                 size_t __n ) ;
#line 50
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memmove)(void *__dest ,
                                                                                                  void const   *__src ,
                                                                                                  size_t __n ) ;
#line 66
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memset)(void *__s ,
                                                                                               int __c ,
                                                                                               size_t __n ) ;
#line 69
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) memcmp)(void const   *__s1 ,
                                                                                               void const   *__s2 ,
                                                                                               size_t __n )  __attribute__((__pure__)) ;
#line 69 "/usr/include/assert.h"
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) __assert_fail)(char const   *__assertion ,
                                                                                                   char const   *__file ,
                                                                                                   unsigned int __line ,
                                                                                                   char const   *__function ) ;
#line 192 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) time_t ( __attribute__((__leaf__)) time)(time_t *__timer ) ;
#line 374 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) rand)(void) ;
#line 376
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) srand)(unsigned int __seed ) ;
#line 480
extern  __attribute__((__nothrow__)) void *( __attribute__((__warn_unused_result__,
__leaf__)) realloc)(void *__ptr , size_t __size ) ;
#line 154 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/expat.h"
void XML_SetElementDeclHandler(XML_Parser parser , void (*eldecl)(void *userData ,
                                                                  XML_Char const   *name ,
                                                                  XML_Content *model ) ) ;
#line 174
void XML_SetAttlistDeclHandler(XML_Parser parser , void (*attdecl)(void *userData ,
                                                                   XML_Char const   *elname ,
                                                                   XML_Char const   *attname ,
                                                                   XML_Char const   *att_type ,
                                                                   XML_Char const   *dflt ,
                                                                   int isrequired ) ) ;
#line 191
void XML_SetXmlDeclHandler(XML_Parser parser , void (*handler)(void *userData , XML_Char const   *version ,
                                                               XML_Char const   *encoding ,
                                                               int standalone ) ) ;
#line 232
XML_Parser XML_ParserCreate_MM(XML_Char const   *encodingName , XML_Memory_Handling_Suite const   *memsuite ,
                               XML_Char const   *nameSep ) ;
#line 246
XML_Bool XML_ParserReset(XML_Parser parser , XML_Char const   *encodingName ) ;
#line 538
void XML_SetStartElementHandler(XML_Parser parser , void (*start)(void *userData ,
                                                                  XML_Char const   *name ,
                                                                  XML_Char const   **atts ) ) ;
#line 542
void XML_SetEndElementHandler(XML_Parser parser , void (*end)(void *userData , XML_Char const   *name ) ) ;
#line 562
void XML_SetStartCdataSectionHandler(XML_Parser parser , void (*start)(void *userData ) ) ;
#line 566
void XML_SetEndCdataSectionHandler(XML_Parser parser , void (*end)(void *userData ) ) ;
#line 582
void XML_SetDefaultHandlerExpand(XML_Parser parser , void (*handler)(void *userData ,
                                                                     XML_Char const   *s ,
                                                                     int len ) ) ;
#line 591
void XML_SetStartDoctypeDeclHandler(XML_Parser parser , void (*start)(void *userData ,
                                                                      XML_Char const   *doctypeName ,
                                                                      XML_Char const   *sysid ,
                                                                      XML_Char const   *pubid ,
                                                                      int has_internal_subset ) ) ;
#line 595
void XML_SetEndDoctypeDeclHandler(XML_Parser parser , void (*end)(void *userData ) ) ;
#line 599
void XML_SetUnparsedEntityDeclHandler(XML_Parser parser , void (*handler)(void *userData ,
                                                                          XML_Char const   *entityName ,
                                                                          XML_Char const   *base ,
                                                                          XML_Char const   *systemId ,
                                                                          XML_Char const   *publicId ,
                                                                          XML_Char const   *notationName ) ) ;
#line 612
void XML_SetStartNamespaceDeclHandler(XML_Parser parser , void (*start)(void *userData ,
                                                                        XML_Char const   *prefix ,
                                                                        XML_Char const   *uri ) ) ;
#line 616
void XML_SetEndNamespaceDeclHandler(XML_Parser parser , void (*end)(void *userData ,
                                                                    XML_Char const   *prefix ) ) ;
#line 624
void XML_SetExternalEntityRefHandler(XML_Parser parser , int (*handler)(XML_Parser parser ,
                                                                        XML_Char const   *context ,
                                                                        XML_Char const   *base ,
                                                                        XML_Char const   *systemId ,
                                                                        XML_Char const   *publicId ) ) ;
#line 632
void XML_SetExternalEntityRefHandlerArg(XML_Parser parser , void *arg ) ;
#line 636
void XML_SetSkippedEntityHandler(XML_Parser parser , void (*handler)(void *userData ,
                                                                     XML_Char const   *entityName ,
                                                                     int is_parameter_entity ) ) ;
#line 666
void XML_SetReturnNSTriplet(XML_Parser parser , int do_nst ) ;
#line 682
enum XML_Status XML_SetEncoding(XML_Parser parser , XML_Char const   *encodingName ) ;
#line 710
enum XML_Error XML_UseForeignDTD(XML_Parser parser , XML_Bool useDTD ) ;
#line 722
enum XML_Status XML_SetBase(XML_Parser parser , XML_Char const   *p ) ;
#line 777
enum XML_Status XML_Parse(XML_Parser parser , char const   *s , int len , int isFinal ) ;
#line 780
void *XML_GetBuffer(XML_Parser parser , int len ) ;
#line 783
enum XML_Status XML_ParseBuffer(XML_Parser parser , int len , int isFinal ) ;
#line 817
enum XML_Status XML_StopParser(XML_Parser parser , XML_Bool resumable ) ;
#line 832
enum XML_Status XML_ResumeParser(XML_Parser parser ) ;
#line 852
void XML_GetParsingStatus(XML_Parser parser , XML_ParsingStatus *status ) ;
#line 871
XML_Parser XML_ExternalEntityParserCreate(XML_Parser oldParser , XML_Char const   *context ,
                                          XML_Char const   *encodingName ) ;
#line 914
int XML_SetHashSalt(XML_Parser parser , unsigned long hash_salt ) ;
#line 921
enum XML_Error XML_GetErrorCode(XML_Parser parser ) ;
#line 960
char const   *XML_GetInputContext(XML_Parser parser , int *offset , int *size ) ;
#line 971
void XML_FreeContentModel(XML_Parser parser , XML_Content *model ) ;
#line 975
void *XML_MemMalloc(XML_Parser parser , size_t size ) ;
#line 978
void *XML_MemRealloc(XML_Parser parser , void *ptr , size_t size ) ;
#line 981
void XML_MemFree(XML_Parser parser , void *ptr ) ;
#line 989
XML_LChar const   *XML_ErrorString(enum XML_Error code ) ;
#line 1005
XML_Expat_Version XML_ExpatVersionInfo(void) ;
#line 102 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlrole.h"
void XmlPrologStateInit(PROLOG_STATE *state ) ;
#line 104
void XmlPrologStateInitExternalEntity(PROLOG_STATE *state ) ;
#line 305 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlparse.c"
static enum XML_Error prologProcessor(XML_Parser parser , char const   *s , char const   *end ,
                                      char const   **nextPtr ) ;
#line 306
static enum XML_Error prologInitProcessor(XML_Parser parser , char const   *s , char const   *end ,
                                          char const   **nextPtr ) ;
#line 307
static enum XML_Error contentProcessor(XML_Parser parser , char const   *start , char const   *end ,
                                       char const   **endPtr ) ;
#line 308
static enum XML_Error cdataSectionProcessor(XML_Parser parser , char const   *start ,
                                            char const   *end , char const   **endPtr ) ;
#line 310
static enum XML_Error ignoreSectionProcessor(XML_Parser parser , char const   *start ,
                                             char const   *end , char const   **endPtr ) ;
#line 311
static enum XML_Error externalParEntProcessor(XML_Parser parser , char const   *s ,
                                              char const   *end , char const   **nextPtr ) ;
#line 312
static enum XML_Error externalParEntInitProcessor(XML_Parser parser , char const   *s ,
                                                  char const   *end , char const   **nextPtr ) ;
#line 313
static enum XML_Error entityValueProcessor(XML_Parser parser , char const   *s , char const   *end ,
                                           char const   **nextPtr ) ;
#line 314
static enum XML_Error entityValueInitProcessor(XML_Parser parser , char const   *s ,
                                               char const   *end , char const   **nextPtr ) ;
#line 316
static enum XML_Error epilogProcessor(XML_Parser parser , char const   *s , char const   *end ,
                                      char const   **nextPtr ) ;
#line 317
static enum XML_Error errorProcessor(XML_Parser parser , char const   *s , char const   *end ,
                                     char const   **nextPtr ) ;
#line 318
static enum XML_Error externalEntityInitProcessor(XML_Parser parser , char const   *start ,
                                                  char const   *end , char const   **endPtr ) ;
#line 319
static enum XML_Error externalEntityInitProcessor2(XML_Parser parser , char const   *start ,
                                                   char const   *end , char const   **endPtr ) ;
#line 320
static enum XML_Error externalEntityInitProcessor3(XML_Parser parser , char const   *start ,
                                                   char const   *end , char const   **endPtr ) ;
#line 321
static enum XML_Error externalEntityContentProcessor(XML_Parser parser , char const   *start ,
                                                     char const   *end , char const   **endPtr ) ;
#line 322
static enum XML_Error internalEntityProcessor(XML_Parser parser , char const   *s ,
                                              char const   *end , char const   **nextPtr ) ;
#line 324
static enum XML_Error handleUnknownEncoding(XML_Parser parser , XML_Char const   *encodingName ) ;
#line 326
static enum XML_Error processXmlDecl(XML_Parser parser , int isGeneralTextEntity ,
                                     char const   *s , char const   *next ) ;
#line 329
static enum XML_Error initializeEncoding(XML_Parser parser ) ;
#line 331
static enum XML_Error doProlog(XML_Parser parser , ENCODING const   *enc , char const   *s ,
                               char const   *end , int tok , char const   *next ,
                               char const   **nextPtr , XML_Bool haveMore ) ;
#line 335
static enum XML_Error processInternalEntity(XML_Parser parser , ENTITY *entity , XML_Bool betweenDecl ) ;
#line 338
static enum XML_Error doContent(XML_Parser parser , int startTagLevel , ENCODING const   *enc ,
                                char const   *s , char const   *end , char const   **nextPtr ,
                                XML_Bool haveMore ) ;
#line 342
static enum XML_Error doCdataSection(XML_Parser parser , ENCODING const   *enc , char const   **startPtr ,
                                     char const   *end , char const   **nextPtr ,
                                     XML_Bool haveMore ) ;
#line 346
static enum XML_Error doIgnoreSection(XML_Parser parser , ENCODING const   *enc ,
                                      char const   **startPtr , char const   *end ,
                                      char const   **nextPtr , XML_Bool haveMore ) ;
#line 351
static enum XML_Error storeAtts(XML_Parser parser , ENCODING const   *enc , char const   *attStr ,
                                TAG_NAME *tagNamePtr , BINDING **bindingsPtr ) ;
#line 354
static enum XML_Error addBinding(XML_Parser parser , PREFIX *prefix , ATTRIBUTE_ID const   *attId ,
                                 XML_Char const   *uri , BINDING **bindingsPtr ) ;
#line 357
static int defineAttribute(ELEMENT_TYPE *type , ATTRIBUTE_ID *attId , XML_Bool isCdata ,
                           XML_Bool isId , XML_Char const   *value , XML_Parser parser ) ;
#line 360
static enum XML_Error storeAttributeValue(XML_Parser parser , ENCODING const   *enc ,
                                          XML_Bool isCdata , char const   *ptr , char const   *end ,
                                          STRING_POOL *pool ) ;
#line 363
static enum XML_Error appendAttributeValue(XML_Parser parser , ENCODING const   *enc ,
                                           XML_Bool isCdata , char const   *ptr ,
                                           char const   *end , STRING_POOL *pool ) ;
#line 366
static ATTRIBUTE_ID *getAttributeId(XML_Parser parser , ENCODING const   *enc , char const   *start ,
                                    char const   *end ) ;
#line 369
static int setElementTypePrefix(XML_Parser parser , ELEMENT_TYPE *elementType ) ;
#line 371
static enum XML_Error storeEntityValue(XML_Parser parser , ENCODING const   *enc ,
                                       char const   *entityTextPtr , char const   *entityTextEnd ) ;
#line 374
static int reportProcessingInstruction(XML_Parser parser , ENCODING const   *enc ,
                                       char const   *start , char const   *end ) ;
#line 377
static int reportComment(XML_Parser parser , ENCODING const   *enc , char const   *start ,
                         char const   *end ) ;
#line 380
static void reportDefault(XML_Parser parser , ENCODING const   *enc , char const   *s ,
                          char const   *end ) ;
#line 384
static XML_Char const   *getContext(XML_Parser parser ) ;
#line 385
static XML_Bool setContext(XML_Parser parser , XML_Char const   *context ) ;
#line 388
static void normalizePublicId(XML_Char *publicId ) ;
#line 390
static DTD *dtdCreate(XML_Memory_Handling_Suite const   *ms ) ;
#line 392
static void dtdReset(DTD *p , XML_Memory_Handling_Suite const   *ms ) ;
#line 393
static void dtdDestroy(DTD *p , XML_Bool isDocEntity , XML_Memory_Handling_Suite const   *ms ) ;
#line 395
static int dtdCopy(XML_Parser oldParser , DTD *newDtd , DTD const   *oldDtd , XML_Memory_Handling_Suite const   *ms ) ;
#line 398
static int copyEntityTable(XML_Parser oldParser , HASH_TABLE *newTable , STRING_POOL *newPool ,
                           HASH_TABLE const   *oldTable ) ;
#line 401
static NAMED *lookup(XML_Parser parser , HASH_TABLE *table , KEY name , size_t createSize ) ;
#line 403
static void hashTableInit(HASH_TABLE *p , XML_Memory_Handling_Suite const   *ms ) ;
#line 405
static void hashTableClear(HASH_TABLE *table ) ;
#line 406
static void hashTableDestroy(HASH_TABLE *table ) ;
#line 407
static void hashTableIterInit(HASH_TABLE_ITER *iter , HASH_TABLE const   *table ) ;
#line 409
static NAMED *hashTableIterNext(HASH_TABLE_ITER *iter ) ;
#line 411
static void poolInit(STRING_POOL *pool , XML_Memory_Handling_Suite const   *ms ) ;
#line 413
static void poolClear(STRING_POOL *pool ) ;
#line 414
static void poolDestroy(STRING_POOL *pool ) ;
#line 415
static XML_Char *poolAppend(STRING_POOL *pool , ENCODING const   *enc , char const   *ptr ,
                            char const   *end ) ;
#line 418
static XML_Char *poolStoreString(STRING_POOL *pool , ENCODING const   *enc , char const   *ptr ,
                                 char const   *end ) ;
#line 421
static XML_Bool poolGrow(STRING_POOL *pool ) ;
#line 422
static XML_Char const   *poolCopyString(STRING_POOL *pool , XML_Char const   *s ) ;
#line 424
static XML_Char const   *poolCopyStringN(STRING_POOL *pool , XML_Char const   *s ,
                                         int n ) ;
#line 426
static XML_Char const   *poolAppendString(STRING_POOL *pool , XML_Char const   *s ) ;
#line 429
static int nextScaffoldPart(XML_Parser parser ) ;
#line 430
static XML_Content *build_model(XML_Parser parser ) ;
#line 431
static ELEMENT_TYPE *getElementType(XML_Parser parser , ENCODING const   *enc , char const   *ptr ,
                                    char const   *end ) ;
#line 435
static unsigned long generate_hash_secret_salt(void) ;
#line 436
static XML_Bool startParsing(XML_Parser parser ) ;
#line 438
static XML_Parser parserCreate(XML_Char const   *encodingName , XML_Memory_Handling_Suite const   *memsuite ,
                               XML_Char const   *nameSep , DTD *dtd ) ;
#line 444
static void parserInit(XML_Parser parser , XML_Char const   *encodingName ) ;
#line 670 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlparse.c"
XML_Parser XML_ParserCreate(XML_Char const   *encodingName ) 
{ 
  XML_Parser tmp ;

  {
  {
#line 673
  tmp = XML_ParserCreate_MM(encodingName, (XML_Memory_Handling_Suite const   *)((void *)0),
                            (XML_Char const   *)((void *)0));
  }
#line 673
  return (tmp);
}
}
#line 676 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlparse.c"
XML_Parser XML_ParserCreateNS(XML_Char const   *encodingName , XML_Char nsSep ) 
{ 
  XML_Char tmp[2] ;
  XML_Parser tmp___0 ;

  {
  {
#line 680
  tmp[0] = nsSep;
#line 681
  tmp___0 = XML_ParserCreate_MM(encodingName, (XML_Memory_Handling_Suite const   *)((void *)0),
                                (XML_Char const   *)(tmp));
  }
#line 681
  return (tmp___0);
}
}
#line 684 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlparse.c"
static XML_Char const   implicitContext[41]  = 
#line 684
  {      (XML_Char const   )120,      (XML_Char const   )109,      (XML_Char const   )108,      (XML_Char const   )61, 
        (XML_Char const   )104,      (XML_Char const   )116,      (XML_Char const   )116,      (XML_Char const   )112, 
        (XML_Char const   )58,      (XML_Char const   )47,      (XML_Char const   )47,      (XML_Char const   )119, 
        (XML_Char const   )119,      (XML_Char const   )119,      (XML_Char const   )46,      (XML_Char const   )119, 
        (XML_Char const   )51,      (XML_Char const   )46,      (XML_Char const   )111,      (XML_Char const   )114, 
        (XML_Char const   )103,      (XML_Char const   )47,      (XML_Char const   )88,      (XML_Char const   )77, 
        (XML_Char const   )76,      (XML_Char const   )47,      (XML_Char const   )49,      (XML_Char const   )57, 
        (XML_Char const   )57,      (XML_Char const   )56,      (XML_Char const   )47,      (XML_Char const   )110, 
        (XML_Char const   )97,      (XML_Char const   )109,      (XML_Char const   )101,      (XML_Char const   )115, 
        (XML_Char const   )112,      (XML_Char const   )97,      (XML_Char const   )99,      (XML_Char const   )101, 
        (XML_Char const   )'\000'};
#line 693 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlparse.c"
static unsigned long generate_hash_secret_salt(void) 
{ 
  unsigned int seed ;
  time_t tmp ;
  int tmp___0 ;

  {
  {
#line 696
  tmp = time((time_t *)((void *)0));
#line 696
  seed = (unsigned int )(tmp % 4294967295L);
#line 697
  srand(seed);
#line 698
  tmp___0 = rand();
  }
#line 698
  return ((unsigned long )tmp___0);
}
}
#line 701 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlparse.c"
static XML_Bool startParsing(XML_Parser parser ) 
{ 
  XML_Bool tmp ;

  {
#line 705
  if (parser->m_hash_secret_salt == 0UL) {
    {
#line 706
    parser->m_hash_secret_salt = generate_hash_secret_salt();
    }
  }
#line 707
  if (parser->m_ns) {
    {
#line 711
    tmp = setContext(parser, implicitContext);
    }
#line 711
    return (tmp);
  }
#line 713
  return ((XML_Bool )1);
}
}
#line 716 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlparse.c"
XML_Parser XML_ParserCreate_MM(XML_Char const   *encodingName , XML_Memory_Handling_Suite const   *memsuite ,
                               XML_Char const   *nameSep ) 
{ 
  XML_Parser tmp ;

  {
  {
#line 721
  tmp = parserCreate(encodingName, memsuite, nameSep, (DTD *)((void *)0));
  }
#line 721
  return (tmp);
}
}
#line 724 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlparse.c"
static XML_Parser parserCreate(XML_Char const   *encodingName , XML_Memory_Handling_Suite const   *memsuite ,
                               XML_Char const   *nameSep , DTD *dtd ) 
{ 
  XML_Parser parser ;
  XML_Memory_Handling_Suite *mtemp ;
  void *tmp ;
  XML_Memory_Handling_Suite *mtemp___0 ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;

  {
#line 732
  if (memsuite) {
    {
#line 734
    tmp = (*(memsuite->malloc_fcn))(sizeof(struct XML_ParserStruct ));
#line 734
    parser = (XML_Parser )tmp;
    }
#line 736
    if ((unsigned long )parser != (unsigned long )((void *)0)) {
#line 737
      mtemp = (XML_Memory_Handling_Suite *)(& parser->m_mem);
#line 738
      mtemp->malloc_fcn = (void *(*)(size_t size ))memsuite->malloc_fcn;
#line 739
      mtemp->realloc_fcn = (void *(*)(void *ptr , size_t size ))memsuite->realloc_fcn;
#line 740
      mtemp->free_fcn = (void (*)(void *ptr ))memsuite->free_fcn;
    }
  } else {
    {
#line 745
    tmp___0 = malloc(sizeof(struct XML_ParserStruct ));
#line 745
    parser = (XML_Parser )tmp___0;
    }
#line 746
    if ((unsigned long )parser != (unsigned long )((void *)0)) {
#line 747
      mtemp___0 = (XML_Memory_Handling_Suite *)(& parser->m_mem);
#line 748
      mtemp___0->malloc_fcn = (void *(*)(size_t size ))(& malloc);
#line 749
      mtemp___0->realloc_fcn = (void *(*)(void *ptr , size_t size ))(& realloc);
#line 750
      mtemp___0->free_fcn = (void (*)(void *ptr ))(& free);
    }
  }
#line 754
  if (! parser) {
#line 755
    return (parser);
  }
  {
#line 757
  parser->m_buffer = (char *)((void *)0);
#line 758
  parser->m_bufferLim = (char const   *)((void *)0);
#line 760
  parser->m_attsSize = 16;
#line 761
  tmp___1 = (*(parser->m_mem.malloc_fcn))((unsigned long )parser->m_attsSize * sizeof(ATTRIBUTE ));
#line 761
  parser->m_atts = (ATTRIBUTE *)tmp___1;
  }
#line 762
  if ((unsigned long )parser->m_atts == (unsigned long )((void *)0)) {
    {
#line 763
    (*(parser->m_mem.free_fcn))((void *)parser);
    }
#line 764
    return ((XML_Parser )((void *)0));
  }
  {
#line 774
  tmp___2 = (*(parser->m_mem.malloc_fcn))(1024UL * sizeof(XML_Char ));
#line 774
  parser->m_dataBuf = (XML_Char *)tmp___2;
  }
#line 775
  if ((unsigned long )parser->m_dataBuf == (unsigned long )((void *)0)) {
    {
#line 776
    (*(parser->m_mem.free_fcn))((void *)parser->m_atts);
#line 780
    (*(parser->m_mem.free_fcn))((void *)parser);
    }
#line 781
    return ((XML_Parser )((void *)0));
  }
#line 783
  parser->m_dataBufEnd = parser->m_dataBuf + 1024;
#line 785
  if (dtd) {
#line 786
    parser->m_dtd = dtd;
  } else {
    {
#line 788
    parser->m_dtd = dtdCreate(& parser->m_mem);
    }
#line 789
    if ((unsigned long )parser->m_dtd == (unsigned long )((void *)0)) {
      {
#line 790
      (*(parser->m_mem.free_fcn))((void *)parser->m_dataBuf);
#line 791
      (*(parser->m_mem.free_fcn))((void *)parser->m_atts);
#line 795
      (*(parser->m_mem.free_fcn))((void *)parser);
      }
#line 796
      return ((XML_Parser )((void *)0));
    }
  }
  {
#line 800
  parser->m_freeBindingList = (BINDING *)((void *)0);
#line 801
  parser->m_freeTagList = (TAG *)((void *)0);
#line 802
  parser->m_freeInternalEntities = (OPEN_INTERNAL_ENTITY *)((void *)0);
#line 804
  parser->m_groupSize = 0U;
#line 805
  parser->m_groupConnector = (char *)((void *)0);
#line 807
  parser->m_unknownEncodingHandler = (int (*)(void *encodingHandlerData , XML_Char const   *name ,
                                              XML_Encoding *info ))((void *)0);
#line 808
  parser->m_unknownEncodingHandlerData = (void *)0;
#line 810
  parser->m_namespaceSeparator = (XML_Char )33;
#line 811
  parser->m_ns = (XML_Bool )0;
#line 812
  parser->m_ns_triplets = (XML_Bool )0;
#line 814
  parser->m_nsAtts = (NS_ATT *)((void *)0);
#line 815
  parser->m_nsAttsVersion = 0UL;
#line 816
  parser->m_nsAttsPower = (unsigned char)0;
#line 818
  poolInit(& parser->m_tempPool, & parser->m_mem);
#line 819
  poolInit(& parser->m_temp2Pool, & parser->m_mem);
#line 820
  parserInit(parser, encodingName);
  }
#line 822
  if (encodingName) {
#line 822
    if (! parser->m_protocolEncodingName) {
      {
#line 823
      XML_ParserFree(parser);
      }
#line 824
      return ((XML_Parser )((void *)0));
    }
  }
#line 827
  if (nameSep) {
    {
#line 828
    parser->m_ns = (XML_Bool )1;
#line 829
    parser->m_internalEncoding = XmlGetUtf8InternalEncodingNS();
#line 830
    parser->m_namespaceSeparator = (XML_Char )*nameSep;
    }
  } else {
    {
#line 833
    parser->m_internalEncoding = XmlGetUtf8InternalEncoding();
    }
  }
#line 836
  return (parser);
}
}
#line 839 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlparse.c"
static void parserInit(XML_Parser parser , XML_Char const   *encodingName ) 
{ 
  XML_Char const   *tmp ;

  {
  {
#line 842
  parser->m_processor = & prologInitProcessor;
#line 843
  XmlPrologStateInit(& parser->m_prologState);
  }
#line 844
  if ((unsigned long )encodingName != (unsigned long )((void *)0)) {
    {
#line 844
    tmp = poolCopyString(& parser->m_tempPool, encodingName);
#line 844
    parser->m_protocolEncodingName = tmp;
    }
  } else {
#line 844
    parser->m_protocolEncodingName = (XML_Char const   *)((void *)0);
  }
  {
#line 847
  parser->m_curBase = (XML_Char const   *)((void *)0);
#line 848
  XmlInitEncoding(& parser->m_initEncoding, & parser->m_encoding, (char const   *)0);
#line 849
  parser->m_userData = (void *)0;
#line 850
  parser->m_handlerArg = (void *)0;
#line 851
  parser->m_startElementHandler = (void (*)(void *userData , XML_Char const   *name ,
                                            XML_Char const   **atts ))((void *)0);
#line 852
  parser->m_endElementHandler = (void (*)(void *userData , XML_Char const   *name ))((void *)0);
#line 853
  parser->m_characterDataHandler = (void (*)(void *userData , XML_Char const   *s ,
                                             int len ))((void *)0);
#line 854
  parser->m_processingInstructionHandler = (void (*)(void *userData , XML_Char const   *target ,
                                                     XML_Char const   *data ))((void *)0);
#line 855
  parser->m_commentHandler = (void (*)(void *userData , XML_Char const   *data ))((void *)0);
#line 856
  parser->m_startCdataSectionHandler = (void (*)(void *userData ))((void *)0);
#line 857
  parser->m_endCdataSectionHandler = (void (*)(void *userData ))((void *)0);
#line 858
  parser->m_defaultHandler = (void (*)(void *userData , XML_Char const   *s , int len ))((void *)0);
#line 859
  parser->m_startDoctypeDeclHandler = (void (*)(void *userData , XML_Char const   *doctypeName ,
                                                XML_Char const   *sysid , XML_Char const   *pubid ,
                                                int has_internal_subset ))((void *)0);
#line 860
  parser->m_endDoctypeDeclHandler = (void (*)(void *userData ))((void *)0);
#line 861
  parser->m_unparsedEntityDeclHandler = (void (*)(void *userData , XML_Char const   *entityName ,
                                                  XML_Char const   *base , XML_Char const   *systemId ,
                                                  XML_Char const   *publicId , XML_Char const   *notationName ))((void *)0);
#line 862
  parser->m_notationDeclHandler = (void (*)(void *userData , XML_Char const   *notationName ,
                                            XML_Char const   *base , XML_Char const   *systemId ,
                                            XML_Char const   *publicId ))((void *)0);
#line 863
  parser->m_startNamespaceDeclHandler = (void (*)(void *userData , XML_Char const   *prefix ,
                                                  XML_Char const   *uri ))((void *)0);
#line 864
  parser->m_endNamespaceDeclHandler = (void (*)(void *userData , XML_Char const   *prefix ))((void *)0);
#line 865
  parser->m_notStandaloneHandler = (int (*)(void *userData ))((void *)0);
#line 866
  parser->m_externalEntityRefHandler = (int (*)(XML_Parser parser , XML_Char const   *context ,
                                                XML_Char const   *base , XML_Char const   *systemId ,
                                                XML_Char const   *publicId ))((void *)0);
#line 867
  parser->m_externalEntityRefHandlerArg = parser;
#line 868
  parser->m_skippedEntityHandler = (void (*)(void *userData , XML_Char const   *entityName ,
                                             int is_parameter_entity ))((void *)0);
#line 869
  parser->m_elementDeclHandler = (void (*)(void *userData , XML_Char const   *name ,
                                           XML_Content *model ))((void *)0);
#line 870
  parser->m_attlistDeclHandler = (void (*)(void *userData , XML_Char const   *elname ,
                                           XML_Char const   *attname , XML_Char const   *att_type ,
                                           XML_Char const   *dflt , int isrequired ))((void *)0);
#line 871
  parser->m_entityDeclHandler = (void (*)(void *userData , XML_Char const   *entityName ,
                                          int is_parameter_entity , XML_Char const   *value ,
                                          int value_length , XML_Char const   *base ,
                                          XML_Char const   *systemId , XML_Char const   *publicId ,
                                          XML_Char const   *notationName ))((void *)0);
#line 872
  parser->m_xmlDeclHandler = (void (*)(void *userData , XML_Char const   *version ,
                                       XML_Char const   *encoding , int standalone ))((void *)0);
#line 873
  parser->m_bufferPtr = (char const   *)parser->m_buffer;
#line 874
  parser->m_bufferEnd = parser->m_buffer;
#line 875
  parser->m_parseEndByteIndex = (XML_Index )0;
#line 876
  parser->m_parseEndPtr = (char const   *)((void *)0);
#line 877
  parser->m_declElementType = (ELEMENT_TYPE *)((void *)0);
#line 878
  parser->m_declAttributeId = (ATTRIBUTE_ID *)((void *)0);
#line 879
  parser->m_declEntity = (ENTITY *)((void *)0);
#line 880
  parser->m_doctypeName = (XML_Char const   *)((void *)0);
#line 881
  parser->m_doctypeSysid = (XML_Char const   *)((void *)0);
#line 882
  parser->m_doctypePubid = (XML_Char const   *)((void *)0);
#line 883
  parser->m_declAttributeType = (XML_Char const   *)((void *)0);
#line 884
  parser->m_declNotationName = (XML_Char const   *)((void *)0);
#line 885
  parser->m_declNotationPublicId = (XML_Char const   *)((void *)0);
#line 886
  parser->m_declAttributeIsCdata = (XML_Bool )0;
#line 887
  parser->m_declAttributeIsId = (XML_Bool )0;
#line 888
  memset((void *)(& parser->m_position), 0, sizeof(POSITION ));
#line 889
  parser->m_errorCode = (enum XML_Error )0;
#line 890
  parser->m_eventPtr = (char const   *)((void *)0);
#line 891
  parser->m_eventEndPtr = (char const   *)((void *)0);
#line 892
  parser->m_positionPtr = (char const   *)((void *)0);
#line 893
  parser->m_openInternalEntities = (OPEN_INTERNAL_ENTITY *)((void *)0);
#line 894
  parser->m_defaultExpandInternalEntities = (XML_Bool )1;
#line 895
  parser->m_tagLevel = 0;
#line 896
  parser->m_tagStack = (TAG *)((void *)0);
#line 897
  parser->m_inheritedBindings = (BINDING *)((void *)0);
#line 898
  parser->m_nSpecifiedAtts = 0;
#line 899
  parser->m_unknownEncodingMem = (void *)0;
#line 900
  parser->m_unknownEncodingRelease = (void (*)(void * ))((void *)0);
#line 901
  parser->m_unknownEncodingData = (void *)0;
#line 902
  parser->m_parentParser = (XML_Parser )((void *)0);
#line 903
  parser->m_parsingStatus.parsing = (enum XML_Parsing )0;
#line 905
  parser->m_isParamEntity = (XML_Bool )0;
#line 906
  parser->m_useForeignDTD = (XML_Bool )0;
#line 907
  parser->m_paramEntityParsing = (enum XML_ParamEntityParsing )0;
#line 909
  parser->m_hash_secret_salt = 0UL;
  }
#line 910
  return;
}
}
#line 913 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlparse.c"
static void moveToFreeBindingList(XML_Parser parser , BINDING *bindings ) 
{ 
  BINDING *b ;

  {
  {
#line 916
  while (1) {
    while_continue: /* CIL Label */ ;
#line 916
    if (! bindings) {
#line 916
      goto while_break;
    }
#line 917
    b = bindings;
#line 918
    bindings = bindings->nextTagBinding;
#line 919
    b->nextTagBinding = parser->m_freeBindingList;
#line 920
    parser->m_freeBindingList = b;
  }
  while_break: /* CIL Label */ ;
  }
#line 922
  return;
}
}
#line 924 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlparse.c"
XML_Bool XML_ParserReset(XML_Parser parser , XML_Char const   *encodingName ) 
{ 
  TAG *tStk ;
  OPEN_INTERNAL_ENTITY *openEntityList ;
  TAG *tag ;
  OPEN_INTERNAL_ENTITY *openEntity ;

  {
#line 929
  if (parser->m_parentParser) {
#line 930
    return ((XML_Bool )0);
  }
#line 932
  tStk = parser->m_tagStack;
  {
#line 933
  while (1) {
    while_continue: /* CIL Label */ ;
#line 933
    if (! tStk) {
#line 933
      goto while_break;
    }
    {
#line 934
    tag = tStk;
#line 935
    tStk = tStk->parent;
#line 936
    tag->parent = parser->m_freeTagList;
#line 937
    moveToFreeBindingList(parser, tag->bindings);
#line 938
    tag->bindings = (BINDING *)((void *)0);
#line 939
    parser->m_freeTagList = tag;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 942
  openEntityList = parser->m_openInternalEntities;
  {
#line 943
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 943
    if (! openEntityList) {
#line 943
      goto while_break___0;
    }
#line 944
    openEntity = openEntityList;
#line 945
    openEntityList = openEntity->next;
#line 946
    openEntity->next = parser->m_freeInternalEntities;
#line 947
    parser->m_freeInternalEntities = openEntity;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 949
  moveToFreeBindingList(parser, parser->m_inheritedBindings);
#line 950
  (*(parser->m_mem.free_fcn))(parser->m_unknownEncodingMem);
  }
#line 951
  if (parser->m_unknownEncodingRelease) {
    {
#line 952
    (*(parser->m_unknownEncodingRelease))(parser->m_unknownEncodingData);
    }
  }
  {
#line 953
  poolClear(& parser->m_tempPool);
#line 954
  poolClear(& parser->m_temp2Pool);
#line 955
  parserInit(parser, encodingName);
#line 956
  dtdReset(parser->m_dtd, & parser->m_mem);
  }
#line 957
  return ((XML_Bool )1);
}
}
#line 960 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlparse.c"
enum XML_Status XML_SetEncoding(XML_Parser parser , XML_Char const   *encodingName ) 
{ 


  {
#line 967
  if ((unsigned int )parser->m_parsingStatus.parsing == 1U) {
#line 968
    return ((enum XML_Status )0);
  } else
#line 967
  if ((unsigned int )parser->m_parsingStatus.parsing == 3U) {
#line 968
    return ((enum XML_Status )0);
  }
#line 969
  if ((unsigned long )encodingName == (unsigned long )((void *)0)) {
#line 970
    parser->m_protocolEncodingName = (XML_Char const   *)((void *)0);
  } else {
    {
#line 972
    parser->m_protocolEncodingName = poolCopyString(& parser->m_tempPool, encodingName);
    }
#line 973
    if (! parser->m_protocolEncodingName) {
#line 974
      return ((enum XML_Status )0);
    }
  }
#line 976
  return ((enum XML_Status )1);
}
}
#line 979 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlparse.c"
XML_Parser XML_ExternalEntityParserCreate(XML_Parser oldParser , XML_Char const   *context ,
                                          XML_Char const   *encodingName ) 
{ 
  XML_Parser parser ;
  DTD *newDtd ;
  DTD *oldDtd ;
  void (*oldStartElementHandler)(void *userData , XML_Char const   *name , XML_Char const   **atts ) ;
  void (*oldEndElementHandler)(void *userData , XML_Char const   *name ) ;
  void (*oldCharacterDataHandler)(void *userData , XML_Char const   *s , int len ) ;
  void (*oldProcessingInstructionHandler)(void *userData , XML_Char const   *target ,
                                          XML_Char const   *data ) ;
  void (*oldCommentHandler)(void *userData , XML_Char const   *data ) ;
  void (*oldStartCdataSectionHandler)(void *userData ) ;
  void (*oldEndCdataSectionHandler)(void *userData ) ;
  void (*oldDefaultHandler)(void *userData , XML_Char const   *s , int len ) ;
  void (*oldUnparsedEntityDeclHandler)(void *userData , XML_Char const   *entityName ,
                                       XML_Char const   *base , XML_Char const   *systemId ,
                                       XML_Char const   *publicId , XML_Char const   *notationName ) ;
  void (*oldNotationDeclHandler)(void *userData , XML_Char const   *notationName ,
                                 XML_Char const   *base , XML_Char const   *systemId ,
                                 XML_Char const   *publicId ) ;
  void (*oldStartNamespaceDeclHandler)(void *userData , XML_Char const   *prefix ,
                                       XML_Char const   *uri ) ;
  void (*oldEndNamespaceDeclHandler)(void *userData , XML_Char const   *prefix ) ;
  int (*oldNotStandaloneHandler)(void *userData ) ;
  int (*oldExternalEntityRefHandler)(XML_Parser parser , XML_Char const   *context ,
                                     XML_Char const   *base , XML_Char const   *systemId ,
                                     XML_Char const   *publicId ) ;
  void (*oldSkippedEntityHandler)(void *userData , XML_Char const   *entityName ,
                                  int is_parameter_entity ) ;
  int (*oldUnknownEncodingHandler)(void *encodingHandlerData , XML_Char const   *name ,
                                   XML_Encoding *info ) ;
  void (*oldElementDeclHandler)(void *userData , XML_Char const   *name , XML_Content *model ) ;
  void (*oldAttlistDeclHandler)(void *userData , XML_Char const   *elname , XML_Char const   *attname ,
                                XML_Char const   *att_type , XML_Char const   *dflt ,
                                int isrequired ) ;
  void (*oldEntityDeclHandler)(void *userData , XML_Char const   *entityName , int is_parameter_entity ,
                               XML_Char const   *value , int value_length , XML_Char const   *base ,
                               XML_Char const   *systemId , XML_Char const   *publicId ,
                               XML_Char const   *notationName ) ;
  void (*oldXmlDeclHandler)(void *userData , XML_Char const   *version , XML_Char const   *encoding ,
                            int standalone ) ;
  ELEMENT_TYPE *oldDeclElementType ;
  void *oldUserData ;
  void *oldHandlerArg ;
  XML_Bool oldDefaultExpandInternalEntities ;
  XML_Parser oldExternalEntityRefHandlerArg ;
  enum XML_ParamEntityParsing oldParamEntityParsing ;
  int oldInEntityValue ;
  XML_Bool oldns_triplets ;
  unsigned long oldhash_secret_salt ;
  XML_Char tmp[2] ;
  int tmp___0 ;
  XML_Bool tmp___1 ;

  {
#line 984
  parser = oldParser;
#line 985
  newDtd = (DTD *)((void *)0);
#line 986
  oldDtd = parser->m_dtd;
#line 987
  oldStartElementHandler = parser->m_startElementHandler;
#line 988
  oldEndElementHandler = parser->m_endElementHandler;
#line 989
  oldCharacterDataHandler = parser->m_characterDataHandler;
#line 990
  oldProcessingInstructionHandler = parser->m_processingInstructionHandler;
#line 992
  oldCommentHandler = parser->m_commentHandler;
#line 993
  oldStartCdataSectionHandler = parser->m_startCdataSectionHandler;
#line 995
  oldEndCdataSectionHandler = parser->m_endCdataSectionHandler;
#line 997
  oldDefaultHandler = parser->m_defaultHandler;
#line 998
  oldUnparsedEntityDeclHandler = parser->m_unparsedEntityDeclHandler;
#line 1000
  oldNotationDeclHandler = parser->m_notationDeclHandler;
#line 1001
  oldStartNamespaceDeclHandler = parser->m_startNamespaceDeclHandler;
#line 1003
  oldEndNamespaceDeclHandler = parser->m_endNamespaceDeclHandler;
#line 1005
  oldNotStandaloneHandler = parser->m_notStandaloneHandler;
#line 1006
  oldExternalEntityRefHandler = parser->m_externalEntityRefHandler;
#line 1008
  oldSkippedEntityHandler = parser->m_skippedEntityHandler;
#line 1009
  oldUnknownEncodingHandler = parser->m_unknownEncodingHandler;
#line 1011
  oldElementDeclHandler = parser->m_elementDeclHandler;
#line 1012
  oldAttlistDeclHandler = parser->m_attlistDeclHandler;
#line 1013
  oldEntityDeclHandler = parser->m_entityDeclHandler;
#line 1014
  oldXmlDeclHandler = parser->m_xmlDeclHandler;
#line 1015
  oldDeclElementType = parser->m_declElementType;
#line 1017
  oldUserData = parser->m_userData;
#line 1018
  oldHandlerArg = parser->m_handlerArg;
#line 1019
  oldDefaultExpandInternalEntities = parser->m_defaultExpandInternalEntities;
#line 1020
  oldExternalEntityRefHandlerArg = parser->m_externalEntityRefHandlerArg;
#line 1022
  oldParamEntityParsing = parser->m_paramEntityParsing;
#line 1023
  oldInEntityValue = parser->m_prologState.inEntityValue;
#line 1025
  oldns_triplets = parser->m_ns_triplets;
#line 1031
  oldhash_secret_salt = parser->m_hash_secret_salt;
#line 1034
  if (! context) {
#line 1035
    newDtd = oldDtd;
  }
#line 1043
  if (parser->m_ns) {
    {
#line 1045
    tmp[0] = parser->m_namespaceSeparator;
#line 1046
    parser = parserCreate(encodingName, & parser->m_mem, (XML_Char const   *)(tmp),
                          newDtd);
    }
  } else {
    {
#line 1049
    parser = parserCreate(encodingName, & parser->m_mem, (XML_Char const   *)((void *)0),
                          newDtd);
    }
  }
#line 1052
  if (! parser) {
#line 1053
    return ((XML_Parser )((void *)0));
  }
#line 1055
  parser->m_startElementHandler = oldStartElementHandler;
#line 1056
  parser->m_endElementHandler = oldEndElementHandler;
#line 1057
  parser->m_characterDataHandler = oldCharacterDataHandler;
#line 1058
  parser->m_processingInstructionHandler = oldProcessingInstructionHandler;
#line 1059
  parser->m_commentHandler = oldCommentHandler;
#line 1060
  parser->m_startCdataSectionHandler = oldStartCdataSectionHandler;
#line 1061
  parser->m_endCdataSectionHandler = oldEndCdataSectionHandler;
#line 1062
  parser->m_defaultHandler = oldDefaultHandler;
#line 1063
  parser->m_unparsedEntityDeclHandler = oldUnparsedEntityDeclHandler;
#line 1064
  parser->m_notationDeclHandler = oldNotationDeclHandler;
#line 1065
  parser->m_startNamespaceDeclHandler = oldStartNamespaceDeclHandler;
#line 1066
  parser->m_endNamespaceDeclHandler = oldEndNamespaceDeclHandler;
#line 1067
  parser->m_notStandaloneHandler = oldNotStandaloneHandler;
#line 1068
  parser->m_externalEntityRefHandler = oldExternalEntityRefHandler;
#line 1069
  parser->m_skippedEntityHandler = oldSkippedEntityHandler;
#line 1070
  parser->m_unknownEncodingHandler = oldUnknownEncodingHandler;
#line 1071
  parser->m_elementDeclHandler = oldElementDeclHandler;
#line 1072
  parser->m_attlistDeclHandler = oldAttlistDeclHandler;
#line 1073
  parser->m_entityDeclHandler = oldEntityDeclHandler;
#line 1074
  parser->m_xmlDeclHandler = oldXmlDeclHandler;
#line 1075
  parser->m_declElementType = oldDeclElementType;
#line 1076
  parser->m_userData = oldUserData;
#line 1077
  if ((unsigned long )oldUserData == (unsigned long )oldHandlerArg) {
#line 1078
    parser->m_handlerArg = parser->m_userData;
  } else {
#line 1080
    parser->m_handlerArg = (void *)parser;
  }
#line 1081
  if ((unsigned long )oldExternalEntityRefHandlerArg != (unsigned long )oldParser) {
#line 1082
    parser->m_externalEntityRefHandlerArg = oldExternalEntityRefHandlerArg;
  }
#line 1083
  parser->m_defaultExpandInternalEntities = oldDefaultExpandInternalEntities;
#line 1084
  parser->m_ns_triplets = oldns_triplets;
#line 1085
  parser->m_hash_secret_salt = oldhash_secret_salt;
#line 1086
  parser->m_parentParser = oldParser;
#line 1088
  parser->m_paramEntityParsing = oldParamEntityParsing;
#line 1089
  parser->m_prologState.inEntityValue = oldInEntityValue;
#line 1090
  if (context) {
    {
#line 1092
    tmp___0 = dtdCopy(oldParser, parser->m_dtd, (DTD const   *)oldDtd, & parser->m_mem);
    }
#line 1092
    if (tmp___0) {
      {
#line 1092
      tmp___1 = setContext(parser, context);
      }
#line 1092
      if (! tmp___1) {
        {
#line 1094
        XML_ParserFree(parser);
        }
#line 1095
        return ((XML_Parser )((void *)0));
      }
    } else {
      {
#line 1094
      XML_ParserFree(parser);
      }
#line 1095
      return ((XML_Parser )((void *)0));
    }
#line 1097
    parser->m_processor = & externalEntityInitProcessor;
  } else {
    {
#line 1108
    parser->m_isParamEntity = (XML_Bool )1;
#line 1109
    XmlPrologStateInitExternalEntity(& parser->m_prologState);
#line 1110
    parser->m_processor = & externalParEntInitProcessor;
    }
  }
#line 1113
  return (parser);
}
}
#line 1116 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlparse.c"
static void destroyBindings(BINDING *bindings , XML_Parser parser ) 
{ 
  BINDING *b ;

  {
  {
#line 1119
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1120
    b = bindings;
#line 1121
    if (! b) {
#line 1122
      goto while_break;
    }
    {
#line 1123
    bindings = b->nextTagBinding;
#line 1124
    (*(parser->m_mem.free_fcn))((void *)b->uri);
#line 1125
    (*(parser->m_mem.free_fcn))((void *)b);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1127
  return;
}
}
#line 1129 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlparse.c"
void XML_ParserFree(XML_Parser parser ) 
{ 
  TAG *tagList ;
  OPEN_INTERNAL_ENTITY *entityList ;
  TAG *p ;
  OPEN_INTERNAL_ENTITY *openEntity ;

  {
#line 1134
  if ((unsigned long )parser == (unsigned long )((void *)0)) {
#line 1135
    return;
  }
#line 1137
  tagList = parser->m_tagStack;
  {
#line 1138
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1140
    if ((unsigned long )tagList == (unsigned long )((void *)0)) {
#line 1141
      if ((unsigned long )parser->m_freeTagList == (unsigned long )((void *)0)) {
#line 1142
        goto while_break;
      }
#line 1143
      tagList = parser->m_freeTagList;
#line 1144
      parser->m_freeTagList = (TAG *)((void *)0);
    }
    {
#line 1146
    p = tagList;
#line 1147
    tagList = tagList->parent;
#line 1148
    (*(parser->m_mem.free_fcn))((void *)p->buf);
#line 1149
    destroyBindings(p->bindings, parser);
#line 1150
    (*(parser->m_mem.free_fcn))((void *)p);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1153
  entityList = parser->m_openInternalEntities;
  {
#line 1154
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1156
    if ((unsigned long )entityList == (unsigned long )((void *)0)) {
#line 1157
      if ((unsigned long )parser->m_freeInternalEntities == (unsigned long )((void *)0)) {
#line 1158
        goto while_break___0;
      }
#line 1159
      entityList = parser->m_freeInternalEntities;
#line 1160
      parser->m_freeInternalEntities = (OPEN_INTERNAL_ENTITY *)((void *)0);
    }
    {
#line 1162
    openEntity = entityList;
#line 1163
    entityList = entityList->next;
#line 1164
    (*(parser->m_mem.free_fcn))((void *)openEntity);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 1167
  destroyBindings(parser->m_freeBindingList, parser);
#line 1168
  destroyBindings(parser->m_inheritedBindings, parser);
#line 1169
  poolDestroy(& parser->m_tempPool);
#line 1170
  poolDestroy(& parser->m_temp2Pool);
  }
#line 1175
  if (! parser->m_isParamEntity) {
#line 1175
    if (parser->m_dtd) {
      {
#line 1179
      dtdDestroy(parser->m_dtd, (XML_Bool )(! parser->m_parentParser), & parser->m_mem);
      }
    }
  }
  {
#line 1180
  (*(parser->m_mem.free_fcn))((void *)parser->m_atts);
#line 1184
  (*(parser->m_mem.free_fcn))((void *)parser->m_groupConnector);
#line 1185
  (*(parser->m_mem.free_fcn))((void *)parser->m_buffer);
#line 1186
  (*(parser->m_mem.free_fcn))((void *)parser->m_dataBuf);
#line 1187
  (*(parser->m_mem.free_fcn))((void *)parser->m_nsAtts);
#line 1188
  (*(parser->m_mem.free_fcn))(parser->m_unknownEncodingMem);
  }
#line 1189
  if (parser->m_unknownEncodingRelease) {
    {
#line 1190
    (*(parser->m_unknownEncodingRelease))(parser->m_unknownEncodingData);
    }
  }
  {
#line 1191
  (*(parser->m_mem.free_fcn))((void *)parser);
  }
#line 1192
  return;
}
}
#line 1194 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlparse.c"
void XML_UseParserAsHandlerArg(XML_Parser parser ) 
{ 


  {
#line 1197
  parser->m_handlerArg = (void *)parser;
#line 1198
  return;
}
}
#line 1200 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlparse.c"
enum XML_Error XML_UseForeignDTD(XML_Parser parser , XML_Bool useDTD ) 
{ 


  {
#line 1205
  if ((unsigned int )parser->m_parsingStatus.parsing == 1U) {
#line 1206
    return ((enum XML_Error )26);
  } else
#line 1205
  if ((unsigned int )parser->m_parsingStatus.parsing == 3U) {
#line 1206
    return ((enum XML_Error )26);
  }
#line 1207
  parser->m_useForeignDTD = useDTD;
#line 1208
  return ((enum XML_Error )0);
}
}
#line 1214 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlparse.c"
void XML_SetReturnNSTriplet(XML_Parser parser , int do_nst ) 
{ 


  {
#line 1218
  if ((unsigned int )parser->m_parsingStatus.parsing == 1U) {
#line 1219
    return;
  } else
#line 1218
  if ((unsigned int )parser->m_parsingStatus.parsing == 3U) {
#line 1219
    return;
  }
#line 1220
  if (do_nst) {
#line 1220
    parser->m_ns_triplets = (XML_Bool )1;
  } else {
#line 1220
    parser->m_ns_triplets = (XML_Bool )0;
  }
#line 1221
  return;
}
}
#line 1223 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlparse.c"
void XML_SetUserData(XML_Parser parser , void *p ) 
{ 
  void *tmp ;

  {
#line 1226
  if ((unsigned long )parser->m_handlerArg == (unsigned long )parser->m_userData) {
#line 1227
    tmp = p;
#line 1227
    parser->m_userData = tmp;
#line 1227
    parser->m_handlerArg = tmp;
  } else {
#line 1229
    parser->m_userData = p;
  }
#line 1230
  return;
}
}
#line 1232 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlparse.c"
enum XML_Status XML_SetBase(XML_Parser parser , XML_Char const   *p ) 
{ 


  {
#line 1235
  if (p) {
    {
#line 1236
    p = poolCopyString(& (parser->m_dtd)->pool, p);
    }
#line 1237
    if (! p) {
#line 1238
      return ((enum XML_Status )0);
    }
#line 1239
    parser->m_curBase = p;
  } else {
#line 1242
    parser->m_curBase = (XML_Char const   *)((void *)0);
  }
#line 1243
  return ((enum XML_Status )1);
}
}
#line 1246 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlparse.c"
XML_Char const   *XML_GetBase(XML_Parser parser ) 
{ 


  {
#line 1249
  return (parser->m_curBase);
}
}
#line 1252 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlparse.c"
int XML_GetSpecifiedAttributeCount(XML_Parser parser ) 
{ 


  {
#line 1255
  return (parser->m_nSpecifiedAtts);
}
}
#line 1258 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlparse.c"
int XML_GetIdAttributeIndex(XML_Parser parser ) 
{ 


  {
#line 1261
  return (parser->m_idAttIndex);
}
}
#line 1272 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlparse.c"
void XML_SetElementHandler(XML_Parser parser , void (*start)(void *userData , XML_Char const   *name ,
                                                             XML_Char const   **atts ) ,
                           void (*end)(void *userData , XML_Char const   *name ) ) 
{ 


  {
#line 1277
  parser->m_startElementHandler = start;
#line 1278
  parser->m_endElementHandler = end;
#line 1279
  return;
}
}
#line 1281 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlparse.c"
void XML_SetStartElementHandler(XML_Parser parser , void (*start)(void *userData ,
                                                                  XML_Char const   *name ,
                                                                  XML_Char const   **atts ) ) 
{ 


  {
#line 1284
  parser->m_startElementHandler = start;
#line 1285
  return;
}
}
#line 1287 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlparse.c"
void XML_SetEndElementHandler(XML_Parser parser , void (*end)(void *userData , XML_Char const   *name ) ) 
{ 


  {
#line 1290
  parser->m_endElementHandler = end;
#line 1291
  return;
}
}
#line 1293 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlparse.c"
void XML_SetCharacterDataHandler(XML_Parser parser , void (*handler)(void *userData ,
                                                                     XML_Char const   *s ,
                                                                     int len ) ) 
{ 


  {
#line 1297
  parser->m_characterDataHandler = handler;
#line 1298
  return;
}
}
#line 1300 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlparse.c"
void XML_SetProcessingInstructionHandler(XML_Parser parser , void (*handler)(void *userData ,
                                                                             XML_Char const   *target ,
                                                                             XML_Char const   *data ) ) 
{ 


  {
#line 1304
  parser->m_processingInstructionHandler = handler;
#line 1305
  return;
}
}
#line 1307 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlparse.c"
void XML_SetCommentHandler(XML_Parser parser , void (*handler)(void *userData , XML_Char const   *data ) ) 
{ 


  {
#line 1311
  parser->m_commentHandler = handler;
#line 1312
  return;
}
}
#line 1314 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlparse.c"
void XML_SetCdataSectionHandler(XML_Parser parser , void (*start)(void *userData ) ,
                                void (*end)(void *userData ) ) 
{ 


  {
#line 1319
  parser->m_startCdataSectionHandler = start;
#line 1320
  parser->m_endCdataSectionHandler = end;
#line 1321
  return;
}
}
#line 1323 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlparse.c"
void XML_SetStartCdataSectionHandler(XML_Parser parser , void (*start)(void *userData ) ) 
{ 


  {
#line 1326
  parser->m_startCdataSectionHandler = start;
#line 1327
  return;
}
}
#line 1329 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlparse.c"
void XML_SetEndCdataSectionHandler(XML_Parser parser , void (*end)(void *userData ) ) 
{ 


  {
#line 1332
  parser->m_endCdataSectionHandler = end;
#line 1333
  return;
}
}
#line 1335 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlparse.c"
void XML_SetDefaultHandler(XML_Parser parser , void (*handler)(void *userData , XML_Char const   *s ,
                                                               int len ) ) 
{ 


  {
#line 1339
  parser->m_defaultHandler = handler;
#line 1340
  parser->m_defaultExpandInternalEntities = (XML_Bool )0;
#line 1341
  return;
}
}
#line 1343 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlparse.c"
void XML_SetDefaultHandlerExpand(XML_Parser parser , void (*handler)(void *userData ,
                                                                     XML_Char const   *s ,
                                                                     int len ) ) 
{ 


  {
#line 1347
  parser->m_defaultHandler = handler;
#line 1348
  parser->m_defaultExpandInternalEntities = (XML_Bool )1;
#line 1349
  return;
}
}
#line 1351 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlparse.c"
void XML_SetDoctypeDeclHandler(XML_Parser parser , void (*start)(void *userData ,
                                                                 XML_Char const   *doctypeName ,
                                                                 XML_Char const   *sysid ,
                                                                 XML_Char const   *pubid ,
                                                                 int has_internal_subset ) ,
                               void (*end)(void *userData ) ) 
{ 


  {
#line 1356
  parser->m_startDoctypeDeclHandler = start;
#line 1357
  parser->m_endDoctypeDeclHandler = end;
#line 1358
  return;
}
}
#line 1360 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlparse.c"
void XML_SetStartDoctypeDeclHandler(XML_Parser parser , void (*start)(void *userData ,
                                                                      XML_Char const   *doctypeName ,
                                                                      XML_Char const   *sysid ,
                                                                      XML_Char const   *pubid ,
                                                                      int has_internal_subset ) ) 
{ 


  {
#line 1363
  parser->m_startDoctypeDeclHandler = start;
#line 1364
  return;
}
}
#line 1366 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlparse.c"
void XML_SetEndDoctypeDeclHandler(XML_Parser parser , void (*end)(void *userData ) ) 
{ 


  {
#line 1369
  parser->m_endDoctypeDeclHandler = end;
#line 1370
  return;
}
}
#line 1372 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlparse.c"
void XML_SetUnparsedEntityDeclHandler(XML_Parser parser , void (*handler)(void *userData ,
                                                                          XML_Char const   *entityName ,
                                                                          XML_Char const   *base ,
                                                                          XML_Char const   *systemId ,
                                                                          XML_Char const   *publicId ,
                                                                          XML_Char const   *notationName ) ) 
{ 


  {
#line 1376
  parser->m_unparsedEntityDeclHandler = handler;
#line 1377
  return;
}
}
#line 1379 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlparse.c"
void XML_SetNotationDeclHandler(XML_Parser parser , void (*handler)(void *userData ,
                                                                    XML_Char const   *notationName ,
                                                                    XML_Char const   *base ,
                                                                    XML_Char const   *systemId ,
                                                                    XML_Char const   *publicId ) ) 
{ 


  {
#line 1383
  parser->m_notationDeclHandler = handler;
#line 1384
  return;
}
}
#line 1386 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlparse.c"
void XML_SetNamespaceDeclHandler(XML_Parser parser , void (*start)(void *userData ,
                                                                   XML_Char const   *prefix ,
                                                                   XML_Char const   *uri ) ,
                                 void (*end)(void *userData , XML_Char const   *prefix ) ) 
{ 


  {
#line 1391
  parser->m_startNamespaceDeclHandler = start;
#line 1392
  parser->m_endNamespaceDeclHandler = end;
#line 1393
  return;
}
}
#line 1395 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlparse.c"
void XML_SetStartNamespaceDeclHandler(XML_Parser parser , void (*start)(void *userData ,
                                                                        XML_Char const   *prefix ,
                                                                        XML_Char const   *uri ) ) 
{ 


  {
#line 1398
  parser->m_startNamespaceDeclHandler = start;
#line 1399
  return;
}
}
#line 1401 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlparse.c"
void XML_SetEndNamespaceDeclHandler(XML_Parser parser , void (*end)(void *userData ,
                                                                    XML_Char const   *prefix ) ) 
{ 


  {
#line 1404
  parser->m_endNamespaceDeclHandler = end;
#line 1405
  return;
}
}
#line 1407 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlparse.c"
void XML_SetNotStandaloneHandler(XML_Parser parser , int (*handler)(void *userData ) ) 
{ 


  {
#line 1411
  parser->m_notStandaloneHandler = handler;
#line 1412
  return;
}
}
#line 1414 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlparse.c"
void XML_SetExternalEntityRefHandler(XML_Parser parser , int (*handler)(XML_Parser parser ,
                                                                        XML_Char const   *context ,
                                                                        XML_Char const   *base ,
                                                                        XML_Char const   *systemId ,
                                                                        XML_Char const   *publicId ) ) 
{ 


  {
#line 1418
  parser->m_externalEntityRefHandler = handler;
#line 1419
  return;
}
}
#line 1421 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlparse.c"
void XML_SetExternalEntityRefHandlerArg(XML_Parser parser , void *arg ) 
{ 


  {
#line 1424
  if (arg) {
#line 1425
    parser->m_externalEntityRefHandlerArg = (XML_Parser )arg;
  } else {
#line 1427
    parser->m_externalEntityRefHandlerArg = parser;
  }
#line 1428
  return;
}
}
#line 1430 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlparse.c"
void XML_SetSkippedEntityHandler(XML_Parser parser , void (*handler)(void *userData ,
                                                                     XML_Char const   *entityName ,
                                                                     int is_parameter_entity ) ) 
{ 


  {
#line 1434
  parser->m_skippedEntityHandler = handler;
#line 1435
  return;
}
}
#line 1437 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlparse.c"
void XML_SetUnknownEncodingHandler(XML_Parser parser , int (*handler)(void *encodingHandlerData ,
                                                                      XML_Char const   *name ,
                                                                      XML_Encoding *info ) ,
                                   void *data ) 
{ 


  {
#line 1442
  parser->m_unknownEncodingHandler = handler;
#line 1443
  parser->m_unknownEncodingHandlerData = data;
#line 1444
  return;
}
}
#line 1446 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlparse.c"
void XML_SetElementDeclHandler(XML_Parser parser , void (*eldecl)(void *userData ,
                                                                  XML_Char const   *name ,
                                                                  XML_Content *model ) ) 
{ 


  {
#line 1450
  parser->m_elementDeclHandler = eldecl;
#line 1451
  return;
}
}
#line 1453 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlparse.c"
void XML_SetAttlistDeclHandler(XML_Parser parser , void (*attdecl)(void *userData ,
                                                                   XML_Char const   *elname ,
                                                                   XML_Char const   *attname ,
                                                                   XML_Char const   *att_type ,
                                                                   XML_Char const   *dflt ,
                                                                   int isrequired ) ) 
{ 


  {
#line 1457
  parser->m_attlistDeclHandler = attdecl;
#line 1458
  return;
}
}
#line 1460 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlparse.c"
void XML_SetEntityDeclHandler(XML_Parser parser , void (*handler)(void *userData ,
                                                                  XML_Char const   *entityName ,
                                                                  int is_parameter_entity ,
                                                                  XML_Char const   *value ,
                                                                  int value_length ,
                                                                  XML_Char const   *base ,
                                                                  XML_Char const   *systemId ,
                                                                  XML_Char const   *publicId ,
                                                                  XML_Char const   *notationName ) ) 
{ 


  {
#line 1464
  parser->m_entityDeclHandler = handler;
#line 1465
  return;
}
}
#line 1467 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlparse.c"
void XML_SetXmlDeclHandler(XML_Parser parser , void (*handler)(void *userData , XML_Char const   *version ,
                                                               XML_Char const   *encoding ,
                                                               int standalone ) ) 
{ 


  {
#line 1470
  parser->m_xmlDeclHandler = handler;
#line 1471
  return;
}
}
#line 1473 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlparse.c"
int XML_SetParamEntityParsing(XML_Parser parser , enum XML_ParamEntityParsing peParsing ) 
{ 


  {
#line 1478
  if ((unsigned int )parser->m_parsingStatus.parsing == 1U) {
#line 1479
    return (0);
  } else
#line 1478
  if ((unsigned int )parser->m_parsingStatus.parsing == 3U) {
#line 1479
    return (0);
  }
#line 1481
  parser->m_paramEntityParsing = peParsing;
#line 1482
  return (1);
}
}
#line 1488 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlparse.c"
int XML_SetHashSalt(XML_Parser parser , unsigned long hash_salt ) 
{ 


  {
#line 1493
  if ((unsigned int )parser->m_parsingStatus.parsing == 1U) {
#line 1494
    return (0);
  } else
#line 1493
  if ((unsigned int )parser->m_parsingStatus.parsing == 3U) {
#line 1494
    return (0);
  }
#line 1495
  parser->m_hash_secret_salt = hash_salt;
#line 1496
  return (1);
}
}
#line 1499 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlparse.c"
enum XML_Status XML_Parse(XML_Parser parser , char const   *s , int len , int isFinal ) 
{ 
  XML_Bool tmp ;
  void *buff ;
  void *tmp___0 ;
  enum XML_Status tmp___1 ;

  {
  {
#line 1503
  if ((unsigned int )parser->m_parsingStatus.parsing == 3U) {
#line 1503
    goto case_3;
  }
#line 1506
  if ((unsigned int )parser->m_parsingStatus.parsing == 2U) {
#line 1506
    goto case_2;
  }
#line 1509
  if ((unsigned int )parser->m_parsingStatus.parsing == 0U) {
#line 1509
    goto case_0;
  }
#line 1514
  goto switch_default;
  case_3: /* CIL Label */ 
#line 1504
  parser->m_errorCode = (enum XML_Error )33;
#line 1505
  return ((enum XML_Status )0);
  case_2: /* CIL Label */ 
#line 1507
  parser->m_errorCode = (enum XML_Error )36;
#line 1508
  return ((enum XML_Status )0);
  case_0: /* CIL Label */ 
#line 1510
  if ((unsigned long )parser->m_parentParser == (unsigned long )((void *)0)) {
    {
#line 1510
    tmp = startParsing(parser);
    }
#line 1510
    if (! tmp) {
#line 1511
      parser->m_errorCode = (enum XML_Error )1;
#line 1512
      return ((enum XML_Status )0);
    }
  }
  switch_default: /* CIL Label */ 
#line 1515
  parser->m_parsingStatus.parsing = (enum XML_Parsing )1;
  switch_break: /* CIL Label */ ;
  }
#line 1518
  if (len == 0) {
#line 1519
    parser->m_parsingStatus.finalBuffer = (XML_Bool )isFinal;
#line 1520
    if (! isFinal) {
#line 1521
      return ((enum XML_Status )1);
    }
    {
#line 1522
    parser->m_positionPtr = parser->m_bufferPtr;
#line 1523
    parser->m_parseEndPtr = (char const   *)parser->m_bufferEnd;
#line 1529
    parser->m_errorCode = (*(parser->m_processor))(parser, parser->m_bufferPtr, parser->m_parseEndPtr,
                                                   & parser->m_bufferPtr);
    }
#line 1531
    if ((unsigned int )parser->m_errorCode == 0U) {
      {
#line 1533
      if ((unsigned int )parser->m_parsingStatus.parsing == 3U) {
#line 1533
        goto case_3___0;
      }
#line 1538
      if ((unsigned int )parser->m_parsingStatus.parsing == 1U) {
#line 1538
        goto case_1;
      }
#line 1538
      if ((unsigned int )parser->m_parsingStatus.parsing == 0U) {
#line 1538
        goto case_1;
      }
#line 1541
      goto switch_default___0;
      case_3___0: /* CIL Label */ 
      {
#line 1534
      (*((parser->m_encoding)->updatePosition))(parser->m_encoding, parser->m_positionPtr,
                                                parser->m_bufferPtr, & parser->m_position);
#line 1535
      parser->m_positionPtr = parser->m_bufferPtr;
      }
#line 1536
      return ((enum XML_Status )2);
      case_1: /* CIL Label */ 
      case_0___0: /* CIL Label */ 
#line 1539
      parser->m_parsingStatus.parsing = (enum XML_Parsing )2;
      switch_default___0: /* CIL Label */ 
#line 1542
      return ((enum XML_Status )1);
      switch_break___0: /* CIL Label */ ;
      }
    }
#line 1545
    parser->m_eventEndPtr = parser->m_eventPtr;
#line 1546
    parser->m_processor = & errorProcessor;
#line 1547
    return ((enum XML_Status )0);
  } else {
    {
#line 1612
    tmp___0 = XML_GetBuffer(parser, len);
#line 1612
    buff = tmp___0;
    }
#line 1613
    if ((unsigned long )buff == (unsigned long )((void *)0)) {
#line 1614
      return ((enum XML_Status )0);
    } else {
      {
#line 1616
      memcpy((void */* __restrict  */)buff, (void const   */* __restrict  */)s, (size_t )len);
#line 1617
      tmp___1 = XML_ParseBuffer(parser, len, isFinal);
      }
#line 1617
      return (tmp___1);
    }
  }
}
}
#line 1622 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlparse.c"
enum XML_Status XML_ParseBuffer(XML_Parser parser , int len , int isFinal ) 
{ 
  char const   *start ;
  enum XML_Status result ;
  XML_Bool tmp ;

  {
#line 1626
  result = (enum XML_Status )1;
  {
#line 1629
  if ((unsigned int )parser->m_parsingStatus.parsing == 3U) {
#line 1629
    goto case_3;
  }
#line 1632
  if ((unsigned int )parser->m_parsingStatus.parsing == 2U) {
#line 1632
    goto case_2;
  }
#line 1635
  if ((unsigned int )parser->m_parsingStatus.parsing == 0U) {
#line 1635
    goto case_0;
  }
#line 1640
  goto switch_default;
  case_3: /* CIL Label */ 
#line 1630
  parser->m_errorCode = (enum XML_Error )33;
#line 1631
  return ((enum XML_Status )0);
  case_2: /* CIL Label */ 
#line 1633
  parser->m_errorCode = (enum XML_Error )36;
#line 1634
  return ((enum XML_Status )0);
  case_0: /* CIL Label */ 
#line 1636
  if ((unsigned long )parser->m_parentParser == (unsigned long )((void *)0)) {
    {
#line 1636
    tmp = startParsing(parser);
    }
#line 1636
    if (! tmp) {
#line 1637
      parser->m_errorCode = (enum XML_Error )1;
#line 1638
      return ((enum XML_Status )0);
    }
  }
  switch_default: /* CIL Label */ 
#line 1641
  parser->m_parsingStatus.parsing = (enum XML_Parsing )1;
  switch_break: /* CIL Label */ ;
  }
  {
#line 1644
  start = parser->m_bufferPtr;
#line 1645
  parser->m_positionPtr = start;
#line 1646
  parser->m_bufferEnd += len;
#line 1647
  parser->m_parseEndPtr = (char const   *)parser->m_bufferEnd;
#line 1648
  parser->m_parseEndByteIndex += (XML_Index )len;
#line 1649
  parser->m_parsingStatus.finalBuffer = (XML_Bool )isFinal;
#line 1651
  parser->m_errorCode = (*(parser->m_processor))(parser, start, parser->m_parseEndPtr,
                                                 & parser->m_bufferPtr);
  }
#line 1653
  if ((unsigned int )parser->m_errorCode != 0U) {
#line 1654
    parser->m_eventEndPtr = parser->m_eventPtr;
#line 1655
    parser->m_processor = & errorProcessor;
#line 1656
    return ((enum XML_Status )0);
  } else {
    {
#line 1660
    if ((unsigned int )parser->m_parsingStatus.parsing == 3U) {
#line 1660
      goto case_3___0;
    }
#line 1664
    if ((unsigned int )parser->m_parsingStatus.parsing == 1U) {
#line 1664
      goto case_1;
    }
#line 1664
    if ((unsigned int )parser->m_parsingStatus.parsing == 0U) {
#line 1664
      goto case_1;
    }
#line 1669
    goto switch_default___0;
    case_3___0: /* CIL Label */ 
#line 1661
    result = (enum XML_Status )2;
#line 1662
    goto switch_break___0;
    case_1: /* CIL Label */ 
    case_0___0: /* CIL Label */ 
#line 1665
    if (isFinal) {
#line 1666
      parser->m_parsingStatus.parsing = (enum XML_Parsing )2;
#line 1667
      return (result);
    }
    switch_default___0: /* CIL Label */ ;
    switch_break___0: /* CIL Label */ ;
    }
  }
  {
#line 1673
  (*((parser->m_encoding)->updatePosition))(parser->m_encoding, parser->m_positionPtr,
                                            parser->m_bufferPtr, & parser->m_position);
#line 1674
  parser->m_positionPtr = parser->m_bufferPtr;
  }
#line 1675
  return (result);
}
}
#line 1678 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlparse.c"
void *XML_GetBuffer(XML_Parser parser , int len ) 
{ 
  int neededSize ;
  int keep ;
  int offset ;
  char *newBuf ;
  int bufferSize ;
  void *tmp ;
  int keep___0 ;
  char *tmp___0 ;
  char const   *tmp___1 ;

  {
#line 1682
  if (len < 0) {
#line 1683
    parser->m_errorCode = (enum XML_Error )1;
#line 1684
    return ((void *)0);
  }
  {
#line 1688
  if ((unsigned int )parser->m_parsingStatus.parsing == 3U) {
#line 1688
    goto case_3;
  }
#line 1691
  if ((unsigned int )parser->m_parsingStatus.parsing == 2U) {
#line 1691
    goto case_2;
  }
#line 1694
  goto switch_default;
  case_3: /* CIL Label */ 
#line 1689
  parser->m_errorCode = (enum XML_Error )33;
#line 1690
  return ((void *)0);
  case_2: /* CIL Label */ 
#line 1692
  parser->m_errorCode = (enum XML_Error )36;
#line 1693
  return ((void *)0);
  switch_default: /* CIL Label */ ;
  switch_break: /* CIL Label */ ;
  }
#line 1697
  if ((long )len > parser->m_bufferLim - (char const   *)parser->m_bufferEnd) {
#line 1698
    neededSize = len + (int )(parser->m_bufferEnd - (char *)parser->m_bufferPtr);
#line 1700
    if (neededSize < 0) {
#line 1701
      parser->m_errorCode = (enum XML_Error )1;
#line 1702
      return ((void *)0);
    }
#line 1706
    keep = (int )(parser->m_bufferPtr - (char const   *)parser->m_buffer);
#line 1708
    if (keep > 1024) {
#line 1709
      keep = 1024;
    }
#line 1710
    neededSize += keep;
#line 1712
    if ((long )neededSize <= parser->m_bufferLim - (char const   *)parser->m_buffer) {
#line 1714
      if ((long )keep < parser->m_bufferPtr - (char const   *)parser->m_buffer) {
        {
#line 1715
        offset = (int )(parser->m_bufferPtr - (char const   *)parser->m_buffer) - keep;
#line 1716
        memmove((void *)parser->m_buffer, (void const   *)(parser->m_buffer + offset),
                (size_t )((parser->m_bufferEnd - (char *)parser->m_bufferPtr) + (long )keep));
#line 1717
        parser->m_bufferEnd -= offset;
#line 1718
        parser->m_bufferPtr -= offset;
        }
      }
    } else {
#line 1728
      bufferSize = (int )(parser->m_bufferLim - parser->m_bufferPtr);
#line 1729
      if (bufferSize == 0) {
#line 1730
        bufferSize = 1024;
      }
      {
#line 1731
      while (1) {
        while_continue: /* CIL Label */ ;
#line 1732
        bufferSize *= 2;
#line 1731
        if (bufferSize < neededSize) {
#line 1731
          if (! (bufferSize > 0)) {
#line 1731
            goto while_break;
          }
        } else {
#line 1731
          goto while_break;
        }
      }
      while_break: /* CIL Label */ ;
      }
#line 1737
      if (bufferSize <= 0) {
#line 1738
        parser->m_errorCode = (enum XML_Error )1;
#line 1739
        return ((void *)0);
      }
      {
#line 1742
      tmp = (*(parser->m_mem.malloc_fcn))((size_t )bufferSize);
#line 1742
      newBuf = (char *)tmp;
      }
#line 1743
      if ((unsigned long )newBuf == (unsigned long )((char *)0)) {
#line 1744
        parser->m_errorCode = (enum XML_Error )1;
#line 1745
        return ((void *)0);
      }
#line 1747
      parser->m_bufferLim = (char const   *)(newBuf + bufferSize);
#line 1749
      if (parser->m_bufferPtr) {
#line 1750
        keep___0 = (int )(parser->m_bufferPtr - (char const   *)parser->m_buffer);
#line 1751
        if (keep___0 > 1024) {
#line 1752
          keep___0 = 1024;
        }
        {
#line 1753
        memcpy((void */* __restrict  */)newBuf, (void const   */* __restrict  */)(parser->m_bufferPtr + - keep___0),
               (size_t )((parser->m_bufferEnd - (char *)parser->m_bufferPtr) + (long )keep___0));
#line 1754
        (*(parser->m_mem.free_fcn))((void *)parser->m_buffer);
#line 1755
        parser->m_buffer = newBuf;
#line 1756
        parser->m_bufferEnd = (parser->m_buffer + (parser->m_bufferEnd - (char *)parser->m_bufferPtr)) + keep___0;
#line 1757
        parser->m_bufferPtr = (char const   *)(parser->m_buffer + keep___0);
        }
      } else {
#line 1760
        parser->m_bufferEnd = newBuf + (parser->m_bufferEnd - (char *)parser->m_bufferPtr);
#line 1761
        tmp___0 = newBuf;
#line 1761
        parser->m_buffer = tmp___0;
#line 1761
        parser->m_bufferPtr = (char const   *)tmp___0;
      }
    }
#line 1772
    tmp___1 = (char const   *)((void *)0);
#line 1772
    parser->m_eventEndPtr = tmp___1;
#line 1772
    parser->m_eventPtr = tmp___1;
#line 1773
    parser->m_positionPtr = (char const   *)((void *)0);
  }
#line 1775
  return ((void *)parser->m_bufferEnd);
}
}
#line 1778 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlparse.c"
enum XML_Status XML_StopParser(XML_Parser parser , XML_Bool resumable ) 
{ 


  {
  {
#line 1782
  if ((unsigned int )parser->m_parsingStatus.parsing == 3U) {
#line 1782
    goto case_3;
  }
#line 1789
  if ((unsigned int )parser->m_parsingStatus.parsing == 2U) {
#line 1789
    goto case_2;
  }
#line 1792
  goto switch_default;
  case_3: /* CIL Label */ 
#line 1783
  if (resumable) {
#line 1784
    parser->m_errorCode = (enum XML_Error )33;
#line 1785
    return ((enum XML_Status )0);
  }
#line 1787
  parser->m_parsingStatus.parsing = (enum XML_Parsing )2;
#line 1788
  goto switch_break;
  case_2: /* CIL Label */ 
#line 1790
  parser->m_errorCode = (enum XML_Error )36;
#line 1791
  return ((enum XML_Status )0);
  switch_default: /* CIL Label */ 
#line 1793
  if (resumable) {
#line 1795
    if (parser->m_isParamEntity) {
#line 1796
      parser->m_errorCode = (enum XML_Error )37;
#line 1797
      return ((enum XML_Status )0);
    }
#line 1800
    parser->m_parsingStatus.parsing = (enum XML_Parsing )3;
  } else {
#line 1803
    parser->m_parsingStatus.parsing = (enum XML_Parsing )2;
  }
  switch_break: /* CIL Label */ ;
  }
#line 1805
  return ((enum XML_Status )1);
}
}
#line 1808 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlparse.c"
enum XML_Status XML_ResumeParser(XML_Parser parser ) 
{ 
  enum XML_Status result ;

  {
#line 1811
  result = (enum XML_Status )1;
#line 1813
  if ((unsigned int )parser->m_parsingStatus.parsing != 3U) {
#line 1814
    parser->m_errorCode = (enum XML_Error )34;
#line 1815
    return ((enum XML_Status )0);
  }
  {
#line 1817
  parser->m_parsingStatus.parsing = (enum XML_Parsing )1;
#line 1819
  parser->m_errorCode = (*(parser->m_processor))(parser, parser->m_bufferPtr, parser->m_parseEndPtr,
                                                 & parser->m_bufferPtr);
  }
#line 1821
  if ((unsigned int )parser->m_errorCode != 0U) {
#line 1822
    parser->m_eventEndPtr = parser->m_eventPtr;
#line 1823
    parser->m_processor = & errorProcessor;
#line 1824
    return ((enum XML_Status )0);
  } else {
    {
#line 1828
    if ((unsigned int )parser->m_parsingStatus.parsing == 3U) {
#line 1828
      goto case_3;
    }
#line 1832
    if ((unsigned int )parser->m_parsingStatus.parsing == 1U) {
#line 1832
      goto case_1;
    }
#line 1832
    if ((unsigned int )parser->m_parsingStatus.parsing == 0U) {
#line 1832
      goto case_1;
    }
#line 1837
    goto switch_default;
    case_3: /* CIL Label */ 
#line 1829
    result = (enum XML_Status )2;
#line 1830
    goto switch_break;
    case_1: /* CIL Label */ 
    case_0: /* CIL Label */ 
#line 1833
    if (parser->m_parsingStatus.finalBuffer) {
#line 1834
      parser->m_parsingStatus.parsing = (enum XML_Parsing )2;
#line 1835
      return (result);
    }
    switch_default: /* CIL Label */ ;
    switch_break: /* CIL Label */ ;
    }
  }
  {
#line 1841
  (*((parser->m_encoding)->updatePosition))(parser->m_encoding, parser->m_positionPtr,
                                            parser->m_bufferPtr, & parser->m_position);
#line 1842
  parser->m_positionPtr = parser->m_bufferPtr;
  }
#line 1843
  return (result);
}
}
#line 1846 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlparse.c"
void XML_GetParsingStatus(XML_Parser parser , XML_ParsingStatus *status ) 
{ 


  {
#line 1849
  if (! ((unsigned long )status != (unsigned long )((void *)0))) {
    {
#line 1849
    __assert_fail("status != ((void *)0)", "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlparse.c",
                  1849U, "XML_GetParsingStatus");
    }
  }
#line 1850
  *status = parser->m_parsingStatus;
#line 1851
  return;
}
}
#line 1853 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlparse.c"
enum XML_Error XML_GetErrorCode(XML_Parser parser ) 
{ 


  {
#line 1856
  return (parser->m_errorCode);
}
}
#line 1859 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlparse.c"
XML_Index XML_GetCurrentByteIndex(XML_Parser parser ) 
{ 


  {
#line 1862
  if (parser->m_eventPtr) {
#line 1863
    return (parser->m_parseEndByteIndex - (parser->m_parseEndPtr - parser->m_eventPtr));
  }
#line 1864
  return ((XML_Index )-1);
}
}
#line 1867 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlparse.c"
int XML_GetCurrentByteCount(XML_Parser parser ) 
{ 


  {
#line 1870
  if (parser->m_eventEndPtr) {
#line 1870
    if (parser->m_eventPtr) {
#line 1871
      return ((int )(parser->m_eventEndPtr - parser->m_eventPtr));
    }
  }
#line 1872
  return (0);
}
}
#line 1875 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlparse.c"
char const   *XML_GetInputContext(XML_Parser parser , int *offset , int *size ) 
{ 


  {
#line 1879
  if (parser->m_eventPtr) {
#line 1879
    if (parser->m_buffer) {
#line 1880
      *offset = (int )(parser->m_eventPtr - (char const   *)parser->m_buffer);
#line 1881
      *size = (int )(parser->m_bufferEnd - parser->m_buffer);
#line 1882
      return ((char const   *)parser->m_buffer);
    }
  }
#line 1885
  return ((char const   *)((char *)0));
}
}
#line 1888 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlparse.c"
XML_Size XML_GetCurrentLineNumber(XML_Parser parser ) 
{ 


  {
#line 1891
  if (parser->m_eventPtr) {
#line 1891
    if ((unsigned long )parser->m_eventPtr >= (unsigned long )parser->m_positionPtr) {
      {
#line 1892
      (*((parser->m_encoding)->updatePosition))(parser->m_encoding, parser->m_positionPtr,
                                                parser->m_eventPtr, & parser->m_position);
#line 1893
      parser->m_positionPtr = parser->m_eventPtr;
      }
    }
  }
#line 1895
  return (parser->m_position.lineNumber + 1UL);
}
}
#line 1898 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlparse.c"
XML_Size XML_GetCurrentColumnNumber(XML_Parser parser ) 
{ 


  {
#line 1901
  if (parser->m_eventPtr) {
#line 1901
    if ((unsigned long )parser->m_eventPtr >= (unsigned long )parser->m_positionPtr) {
      {
#line 1902
      (*((parser->m_encoding)->updatePosition))(parser->m_encoding, parser->m_positionPtr,
                                                parser->m_eventPtr, & parser->m_position);
#line 1903
      parser->m_positionPtr = parser->m_eventPtr;
      }
    }
  }
#line 1905
  return (parser->m_position.columnNumber);
}
}
#line 1908 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlparse.c"
void XML_FreeContentModel(XML_Parser parser , XML_Content *model ) 
{ 


  {
  {
#line 1911
  (*(parser->m_mem.free_fcn))((void *)model);
  }
#line 1912
  return;
}
}
#line 1914 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlparse.c"
void *XML_MemMalloc(XML_Parser parser , size_t size ) 
{ 
  void *tmp ;

  {
  {
#line 1917
  tmp = (*(parser->m_mem.malloc_fcn))(size);
  }
#line 1917
  return (tmp);
}
}
#line 1920 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlparse.c"
void *XML_MemRealloc(XML_Parser parser , void *ptr , size_t size ) 
{ 
  void *tmp ;

  {
  {
#line 1923
  tmp = (*(parser->m_mem.realloc_fcn))(ptr, size);
  }
#line 1923
  return (tmp);
}
}
#line 1926 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlparse.c"
void XML_MemFree(XML_Parser parser , void *ptr ) 
{ 


  {
  {
#line 1929
  (*(parser->m_mem.free_fcn))(ptr);
  }
#line 1930
  return;
}
}
#line 1932 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlparse.c"
void XML_DefaultCurrent(XML_Parser parser ) 
{ 


  {
#line 1935
  if (parser->m_defaultHandler) {
#line 1936
    if (parser->m_openInternalEntities) {
      {
#line 1937
      reportDefault(parser, parser->m_internalEncoding, (parser->m_openInternalEntities)->internalEventPtr,
                    (parser->m_openInternalEntities)->internalEventEndPtr);
      }
    } else {
      {
#line 1942
      reportDefault(parser, parser->m_encoding, parser->m_eventPtr, parser->m_eventEndPtr);
      }
    }
  }
#line 1944
  return;
}
}
#line 1949 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlparse.c"
static XML_LChar const   * const  message[41]  = 
#line 1949
  {      (XML_LChar const   */* const  */)0,      (XML_LChar const   */* const  */)"out of memory",      (XML_LChar const   */* const  */)"syntax error",      (XML_LChar const   */* const  */)"no element found", 
        (XML_LChar const   */* const  */)"not well-formed (invalid token)",      (XML_LChar const   */* const  */)"unclosed token",      (XML_LChar const   */* const  */)"partial character",      (XML_LChar const   */* const  */)"mismatched tag", 
        (XML_LChar const   */* const  */)"duplicate attribute",      (XML_LChar const   */* const  */)"junk after document element",      (XML_LChar const   */* const  */)"illegal parameter entity reference",      (XML_LChar const   */* const  */)"undefined entity", 
        (XML_LChar const   */* const  */)"recursive entity reference",      (XML_LChar const   */* const  */)"asynchronous entity",      (XML_LChar const   */* const  */)"reference to invalid character number",      (XML_LChar const   */* const  */)"reference to binary entity", 
        (XML_LChar const   */* const  */)"reference to external entity in attribute",      (XML_LChar const   */* const  */)"XML or text declaration not at start of entity",      (XML_LChar const   */* const  */)"unknown encoding",      (XML_LChar const   */* const  */)"encoding specified in XML declaration is incorrect", 
        (XML_LChar const   */* const  */)"unclosed CDATA section",      (XML_LChar const   */* const  */)"error in processing external entity reference",      (XML_LChar const   */* const  */)"document is not standalone",      (XML_LChar const   */* const  */)"unexpected parser state - please send a bug report", 
        (XML_LChar const   */* const  */)"entity declared in parameter entity",      (XML_LChar const   */* const  */)"requested feature requires XML_DTD support in Expat",      (XML_LChar const   */* const  */)"cannot change setting once parsing has begun",      (XML_LChar const   */* const  */)"unbound prefix", 
        (XML_LChar const   */* const  */)"must not undeclare prefix",      (XML_LChar const   */* const  */)"incomplete markup in parameter entity",      (XML_LChar const   */* const  */)"XML declaration not well-formed",      (XML_LChar const   */* const  */)"text declaration not well-formed", 
        (XML_LChar const   */* const  */)"illegal character(s) in public id",      (XML_LChar const   */* const  */)"parser suspended",      (XML_LChar const   */* const  */)"parser not suspended",      (XML_LChar const   */* const  */)"parsing aborted", 
        (XML_LChar const   */* const  */)"parsing finished",      (XML_LChar const   */* const  */)"cannot suspend in external parameter entity",      (XML_LChar const   */* const  */)"reserved prefix (xml) must not be undeclared or bound to another namespace name",      (XML_LChar const   */* const  */)"reserved prefix (xmlns) must not be declared or undeclared", 
        (XML_LChar const   */* const  */)"prefix must not be bound to one of the reserved namespace names"};
#line 1946 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlparse.c"
XML_LChar const   *XML_ErrorString(enum XML_Error code ) 
{ 


  {
#line 1992
  if ((unsigned int )code > 0U) {
#line 1992
    if ((unsigned long )code < sizeof(message) / sizeof(message[0])) {
#line 1993
      return ((XML_LChar const   *)message[code]);
    }
  }
#line 1994
  return ((XML_LChar const   *)((void *)0));
}
}
#line 1997 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlparse.c"
XML_LChar const   *XML_ExpatVersion(void) 
{ 


  {
#line 2011
  return ("expat_2.1.0");
}
}
#line 2017 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlparse.c"
XML_Expat_Version XML_ExpatVersionInfo(void) 
{ 
  XML_Expat_Version version ;

  {
#line 2022
  version.major = 2;
#line 2023
  version.minor = 1;
#line 2024
  version.micro = 0;
#line 2026
  return (version);
}
}
#line 2032 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlparse.c"
static XML_Feature const   features[6]  = {      {(enum XML_FeatureEnum )6, "sizeof(XML_Char)", (long )sizeof(XML_Char )}, 
        {(enum XML_FeatureEnum )7, "sizeof(XML_LChar)", (long )sizeof(XML_LChar )}, 
        {(enum XML_FeatureEnum )3, "XML_DTD", 0L}, 
        {(enum XML_FeatureEnum )4, "XML_CONTEXT_BYTES", 1024L}, 
        {(enum XML_FeatureEnum )8, "XML_NS", 0L}, 
        {(enum XML_FeatureEnum )0, (XML_LChar const   *)((void *)0), 0L}};
#line 2029 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlparse.c"
XML_Feature const   *XML_GetFeatureList(void) 
{ 


  {
#line 2065
  return (features);
}
}
#line 2073 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlparse.c"
static XML_Bool storeRawNames(XML_Parser parser ) 
{ 
  TAG *tag ;
  int bufSize ;
  int nameLen ;
  char *rawNameBuf ;
  char *temp ;
  void *tmp ;

  {
#line 2076
  tag = parser->m_tagStack;
  {
#line 2077
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2077
    if (! tag) {
#line 2077
      goto while_break;
    }
#line 2079
    nameLen = (int )(sizeof(XML_Char ) * (unsigned long )(tag->name.strLen + 1));
#line 2080
    rawNameBuf = tag->buf + nameLen;
#line 2086
    if ((unsigned long )tag->rawName == (unsigned long )rawNameBuf) {
#line 2087
      goto while_break;
    }
#line 2091
    bufSize = (int )((unsigned long )nameLen + (((unsigned long )tag->rawNameLength + (sizeof(XML_Char ) - 1UL)) & ~ (sizeof(XML_Char ) - 1UL)));
#line 2092
    if ((long )bufSize > tag->bufEnd - tag->buf) {
      {
#line 2093
      tmp = (*(parser->m_mem.realloc_fcn))((void *)tag->buf, (size_t )bufSize);
#line 2093
      temp = (char *)tmp;
      }
#line 2094
      if ((unsigned long )temp == (unsigned long )((void *)0)) {
#line 2095
        return ((XML_Bool )0);
      }
#line 2099
      if ((unsigned long )tag->name.str == (unsigned long )tag->buf) {
#line 2100
        tag->name.str = (XML_Char const   *)temp;
      }
#line 2104
      if (tag->name.localPart) {
#line 2105
        tag->name.localPart = (XML_Char const   *)(temp + (tag->name.localPart - (XML_Char const   *)tag->buf));
      }
#line 2107
      tag->buf = temp;
#line 2108
      tag->bufEnd = temp + bufSize;
#line 2109
      rawNameBuf = temp + nameLen;
    }
    {
#line 2111
    memcpy((void */* __restrict  */)rawNameBuf, (void const   */* __restrict  */)tag->rawName,
           (size_t )tag->rawNameLength);
#line 2112
    tag->rawName = (char const   *)rawNameBuf;
#line 2113
    tag = tag->parent;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 2115
  return ((XML_Bool )1);
}
}
#line 2118 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlparse.c"
static enum XML_Error contentProcessor(XML_Parser parser , char const   *start , char const   *end ,
                                       char const   **endPtr ) 
{ 
  enum XML_Error result ;
  enum XML_Error tmp ;
  XML_Bool tmp___0 ;

  {
  {
#line 2124
  tmp = doContent(parser, 0, parser->m_encoding, start, end, endPtr, (XML_Bool )(! parser->m_parsingStatus.finalBuffer));
#line 2124
  result = tmp;
  }
#line 2126
  if ((unsigned int )result == 0U) {
    {
#line 2127
    tmp___0 = storeRawNames(parser);
    }
#line 2127
    if (! tmp___0) {
#line 2128
      return ((enum XML_Error )1);
    }
  }
#line 2130
  return (result);
}
}
#line 2133 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlparse.c"
static enum XML_Error externalEntityInitProcessor(XML_Parser parser , char const   *start ,
                                                  char const   *end , char const   **endPtr ) 
{ 
  enum XML_Error result ;
  enum XML_Error tmp ;
  enum XML_Error tmp___0 ;

  {
  {
#line 2139
  tmp = initializeEncoding(parser);
#line 2139
  result = tmp;
  }
#line 2140
  if ((unsigned int )result != 0U) {
#line 2141
    return (result);
  }
  {
#line 2142
  parser->m_processor = & externalEntityInitProcessor2;
#line 2143
  tmp___0 = externalEntityInitProcessor2(parser, start, end, endPtr);
  }
#line 2143
  return (tmp___0);
}
}
#line 2146 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlparse.c"
static enum XML_Error externalEntityInitProcessor2(XML_Parser parser , char const   *start ,
                                                   char const   *end , char const   **endPtr ) 
{ 
  char const   *next ;
  int tok ;
  int tmp ;
  enum XML_Error tmp___0 ;

  {
  {
#line 2152
  next = start;
#line 2153
  tmp = (*((parser->m_encoding)->scanners[1]))(parser->m_encoding, start, end, & next);
#line 2153
  tok = tmp;
  }
  {
#line 2155
  if (tok == 14) {
#line 2155
    goto case_14;
  }
#line 2167
  if (tok == -1) {
#line 2167
    goto case_neg_1;
  }
#line 2174
  if (tok == -2) {
#line 2174
    goto case_neg_2;
  }
#line 2154
  goto switch_break;
  case_14: /* CIL Label */ 
#line 2161
  if ((unsigned long )next == (unsigned long )end) {
#line 2161
    if (! parser->m_parsingStatus.finalBuffer) {
#line 2162
      *endPtr = next;
#line 2163
      return ((enum XML_Error )0);
    }
  }
#line 2165
  start = next;
#line 2166
  goto switch_break;
  case_neg_1: /* CIL Label */ 
#line 2168
  if (! parser->m_parsingStatus.finalBuffer) {
#line 2169
    *endPtr = start;
#line 2170
    return ((enum XML_Error )0);
  }
#line 2172
  parser->m_eventPtr = start;
#line 2173
  return ((enum XML_Error )5);
  case_neg_2: /* CIL Label */ 
#line 2175
  if (! parser->m_parsingStatus.finalBuffer) {
#line 2176
    *endPtr = start;
#line 2177
    return ((enum XML_Error )0);
  }
#line 2179
  parser->m_eventPtr = start;
#line 2180
  return ((enum XML_Error )6);
  switch_break: /* CIL Label */ ;
  }
  {
#line 2182
  parser->m_processor = & externalEntityInitProcessor3;
#line 2183
  tmp___0 = externalEntityInitProcessor3(parser, start, end, endPtr);
  }
#line 2183
  return (tmp___0);
}
}
#line 2186 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlparse.c"
static enum XML_Error externalEntityInitProcessor3(XML_Parser parser , char const   *start ,
                                                   char const   *end , char const   **endPtr ) 
{ 
  int tok ;
  char const   *next ;
  enum XML_Error result ;
  enum XML_Error tmp ;

  {
  {
#line 2193
  next = start;
#line 2194
  parser->m_eventPtr = start;
#line 2195
  tok = (*((parser->m_encoding)->scanners[1]))(parser->m_encoding, start, end, & next);
#line 2196
  parser->m_eventEndPtr = next;
  }
  {
#line 2199
  if (tok == 12) {
#line 2199
    goto case_12;
  }
#line 2216
  if (tok == -1) {
#line 2216
    goto case_neg_1;
  }
#line 2222
  if (tok == -2) {
#line 2222
    goto case_neg_2;
  }
#line 2198
  goto switch_break;
  case_12: /* CIL Label */ 
  {
#line 2202
  result = processXmlDecl(parser, 1, start, next);
  }
#line 2203
  if ((unsigned int )result != 0U) {
#line 2204
    return (result);
  }
  {
#line 2206
  if ((unsigned int )parser->m_parsingStatus.parsing == 3U) {
#line 2206
    goto case_3;
  }
#line 2209
  if ((unsigned int )parser->m_parsingStatus.parsing == 2U) {
#line 2209
    goto case_2;
  }
#line 2211
  goto switch_default;
  case_3: /* CIL Label */ 
#line 2207
  *endPtr = next;
#line 2208
  return ((enum XML_Error )0);
  case_2: /* CIL Label */ 
#line 2210
  return ((enum XML_Error )35);
  switch_default: /* CIL Label */ 
#line 2212
  start = next;
  switch_break___0: /* CIL Label */ ;
  }
#line 2215
  goto switch_break;
  case_neg_1: /* CIL Label */ 
#line 2217
  if (! parser->m_parsingStatus.finalBuffer) {
#line 2218
    *endPtr = start;
#line 2219
    return ((enum XML_Error )0);
  }
#line 2221
  return ((enum XML_Error )5);
  case_neg_2: /* CIL Label */ 
#line 2223
  if (! parser->m_parsingStatus.finalBuffer) {
#line 2224
    *endPtr = start;
#line 2225
    return ((enum XML_Error )0);
  }
#line 2227
  return ((enum XML_Error )6);
  switch_break: /* CIL Label */ ;
  }
  {
#line 2229
  parser->m_processor = & externalEntityContentProcessor;
#line 2230
  parser->m_tagLevel = 1;
#line 2231
  tmp = externalEntityContentProcessor(parser, start, end, endPtr);
  }
#line 2231
  return (tmp);
}
}
#line 2234 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlparse.c"
static enum XML_Error externalEntityContentProcessor(XML_Parser parser , char const   *start ,
                                                     char const   *end , char const   **endPtr ) 
{ 
  enum XML_Error result ;
  enum XML_Error tmp ;
  XML_Bool tmp___0 ;

  {
  {
#line 2240
  tmp = doContent(parser, 1, parser->m_encoding, start, end, endPtr, (XML_Bool )(! parser->m_parsingStatus.finalBuffer));
#line 2240
  result = tmp;
  }
#line 2242
  if ((unsigned int )result == 0U) {
    {
#line 2243
    tmp___0 = storeRawNames(parser);
    }
#line 2243
    if (! tmp___0) {
#line 2244
      return ((enum XML_Error )1);
    }
  }
#line 2246
  return (result);
}
}
#line 2249 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlparse.c"
static enum XML_Error doContent(XML_Parser parser , int startTagLevel , ENCODING const   *enc ,
                                char const   *s , char const   *end , char const   **nextPtr ,
                                XML_Bool haveMore ) 
{ 
  DTD *dtd ;
  char const   **eventPP ;
  char const   **eventEndPP ;
  char const   *next ;
  int tok ;
  int tmp ;
  XML_Char c___0 ;
  XML_Char const   *name ;
  ENTITY *entity ;
  XML_Char ch ;
  int tmp___0 ;
  XML_Char *tmp___1 ;
  NAMED *tmp___2 ;
  enum XML_Error result ;
  XML_Char const   *context ;
  int tmp___3 ;
  TAG *tag ;
  enum XML_Error result___0 ;
  XML_Char *toPtr ;
  void *tmp___4 ;
  void *tmp___5 ;
  char const   *rawNameEnd ;
  char const   *fromPtr ;
  int bufSize ;
  int convLen ;
  char *temp ;
  void *tmp___6 ;
  char const   *rawName ;
  enum XML_Error result___1 ;
  BINDING *bindings ;
  XML_Bool noElmHandlers ;
  TAG_NAME name___0 ;
  int tmp___7 ;
  XML_Char *tmp___8 ;
  BINDING *b ;
  enum XML_Error tmp___9 ;
  int len ;
  char const   *rawName___0 ;
  TAG *tag___0 ;
  int tmp___10 ;
  XML_Char const   *localPart ;
  XML_Char const   *prefix ;
  XML_Char *uri ;
  XML_Char *tmp___11 ;
  XML_Char const   *tmp___12 ;
  XML_Char *tmp___13 ;
  XML_Char *tmp___14 ;
  XML_Char const   *tmp___15 ;
  BINDING *b___0 ;
  enum XML_Error tmp___16 ;
  int n ;
  int tmp___17 ;
  XML_Char buf[4] ;
  int tmp___18 ;
  XML_Char c___1 ;
  enum XML_Error result___2 ;
  ICHAR *dataPtr ;
  void (*charDataHandler)(void *userData , XML_Char const   *s , int len ) ;
  ICHAR *dataPtr___0 ;
  int tmp___19 ;
  int tmp___20 ;

  {
#line 2259
  dtd = parser->m_dtd;
#line 2263
  if ((unsigned long )enc == (unsigned long )parser->m_encoding) {
#line 2264
    eventPP = & parser->m_eventPtr;
#line 2265
    eventEndPP = & parser->m_eventEndPtr;
  } else {
#line 2268
    eventPP = & (parser->m_openInternalEntities)->internalEventPtr;
#line 2269
    eventEndPP = & (parser->m_openInternalEntities)->internalEventEndPtr;
  }
#line 2271
  *eventPP = s;
  {
#line 2273
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 2274
    next = s;
#line 2275
    tmp = (*(enc->scanners[1]))(enc, s, end, & next);
#line 2275
    tok = tmp;
#line 2276
    *eventEndPP = next;
    }
    {
#line 2278
    if (tok == -3) {
#line 2278
      goto case_neg_3;
    }
#line 2299
    if (tok == -4) {
#line 2299
      goto case_neg_4;
    }
#line 2311
    if (tok == 0) {
#line 2311
      goto case_0;
    }
#line 2314
    if (tok == -1) {
#line 2314
      goto case_neg_1;
    }
#line 2320
    if (tok == -2) {
#line 2320
      goto case_neg_2;
    }
#line 2326
    if (tok == 9) {
#line 2326
      goto case_9;
    }
#line 2402
    if (tok == 1) {
#line 2402
      goto case_1;
    }
#line 2402
    if (tok == 2) {
#line 2402
      goto case_1;
    }
#line 2471
    if (tok == 3) {
#line 2471
      goto case_3;
    }
#line 2471
    if (tok == 4) {
#line 2471
      goto case_3;
    }
#line 2513
    if (tok == 5) {
#line 2513
      goto case_5;
    }
#line 2568
    if (tok == 10) {
#line 2568
      goto case_10;
    }
#line 2581
    if (tok == 12) {
#line 2581
      goto case_12;
    }
#line 2583
    if (tok == 7) {
#line 2583
      goto case_7;
    }
#line 2591
    if (tok == 8) {
#line 2591
      goto case_8;
    }
#line 2623
    if (tok == -5) {
#line 2623
      goto case_neg_5;
    }
#line 2655
    if (tok == 6) {
#line 2655
      goto case_6;
    }
#line 2680
    if (tok == 11) {
#line 2680
      goto case_11;
    }
#line 2684
    if (tok == 13) {
#line 2684
      goto case_13;
    }
#line 2688
    goto switch_default;
    case_neg_3: /* CIL Label */ 
#line 2279
    if (haveMore) {
#line 2280
      *nextPtr = s;
#line 2281
      return ((enum XML_Error )0);
    }
#line 2283
    *eventEndPP = end;
#line 2284
    if (parser->m_characterDataHandler) {
      {
#line 2285
      c___0 = (XML_Char )10;
#line 2286
      (*(parser->m_characterDataHandler))(parser->m_handlerArg, (XML_Char const   *)(& c___0),
                                          1);
      }
    } else
#line 2288
    if (parser->m_defaultHandler) {
      {
#line 2289
      reportDefault(parser, enc, s, end);
      }
    }
#line 2293
    if (startTagLevel == 0) {
#line 2294
      return ((enum XML_Error )3);
    }
#line 2295
    if (parser->m_tagLevel != startTagLevel) {
#line 2296
      return ((enum XML_Error )13);
    }
#line 2297
    *nextPtr = end;
#line 2298
    return ((enum XML_Error )0);
    case_neg_4: /* CIL Label */ 
#line 2300
    if (haveMore) {
#line 2301
      *nextPtr = s;
#line 2302
      return ((enum XML_Error )0);
    }
#line 2304
    if (startTagLevel > 0) {
#line 2305
      if (parser->m_tagLevel != startTagLevel) {
#line 2306
        return ((enum XML_Error )13);
      }
#line 2307
      *nextPtr = s;
#line 2308
      return ((enum XML_Error )0);
    }
#line 2310
    return ((enum XML_Error )3);
    case_0: /* CIL Label */ 
#line 2312
    *eventPP = next;
#line 2313
    return ((enum XML_Error )4);
    case_neg_1: /* CIL Label */ 
#line 2315
    if (haveMore) {
#line 2316
      *nextPtr = s;
#line 2317
      return ((enum XML_Error )0);
    }
#line 2319
    return ((enum XML_Error )5);
    case_neg_2: /* CIL Label */ 
#line 2321
    if (haveMore) {
#line 2322
      *nextPtr = s;
#line 2323
      return ((enum XML_Error )0);
    }
#line 2325
    return ((enum XML_Error )6);
    case_9: /* CIL Label */ 
    {
#line 2330
    tmp___0 = (*(enc->predefinedEntityName))(enc, s + enc->minBytesPerChar, next - enc->minBytesPerChar);
#line 2330
    ch = (XML_Char )tmp___0;
    }
#line 2333
    if (ch) {
#line 2334
      if (parser->m_characterDataHandler) {
        {
#line 2335
        (*(parser->m_characterDataHandler))(parser->m_handlerArg, (XML_Char const   *)(& ch),
                                            1);
        }
      } else
#line 2336
      if (parser->m_defaultHandler) {
        {
#line 2337
        reportDefault(parser, enc, s, next);
        }
      }
#line 2338
      goto switch_break;
    }
    {
#line 2340
    tmp___1 = poolStoreString(& dtd->pool, enc, s + enc->minBytesPerChar, next - enc->minBytesPerChar);
#line 2340
    name = (XML_Char const   *)tmp___1;
    }
#line 2343
    if (! name) {
#line 2344
      return ((enum XML_Error )1);
    }
    {
#line 2345
    tmp___2 = lookup(parser, & dtd->generalEntities, name, (size_t )0);
#line 2345
    entity = (ENTITY *)tmp___2;
#line 2346
    dtd->pool.ptr = dtd->pool.start;
    }
#line 2351
    if (! dtd->hasParamEntityRefs) {
#line 2351
      goto _L;
    } else
#line 2351
    if (dtd->standalone) {
      _L: /* CIL Label */ 
#line 2352
      if (! entity) {
#line 2353
        return ((enum XML_Error )11);
      } else
#line 2354
      if (! entity->is_internal) {
#line 2355
        return ((enum XML_Error )24);
      }
    } else
#line 2357
    if (! entity) {
#line 2358
      if (parser->m_skippedEntityHandler) {
        {
#line 2359
        (*(parser->m_skippedEntityHandler))(parser->m_handlerArg, name, 0);
        }
      } else
#line 2360
      if (parser->m_defaultHandler) {
        {
#line 2361
        reportDefault(parser, enc, s, next);
        }
      }
#line 2362
      goto switch_break;
    }
#line 2364
    if (entity->open) {
#line 2365
      return ((enum XML_Error )12);
    }
#line 2366
    if (entity->notation) {
#line 2367
      return ((enum XML_Error )15);
    }
#line 2368
    if (entity->textPtr) {
#line 2370
      if (! parser->m_defaultExpandInternalEntities) {
#line 2371
        if (parser->m_skippedEntityHandler) {
          {
#line 2372
          (*(parser->m_skippedEntityHandler))(parser->m_handlerArg, entity->name,
                                              0);
          }
        } else
#line 2373
        if (parser->m_defaultHandler) {
          {
#line 2374
          reportDefault(parser, enc, s, next);
          }
        }
#line 2375
        goto switch_break;
      }
      {
#line 2377
      result = processInternalEntity(parser, entity, (XML_Bool )0);
      }
#line 2378
      if ((unsigned int )result != 0U) {
#line 2379
        return (result);
      }
    } else
#line 2381
    if (parser->m_externalEntityRefHandler) {
      {
#line 2383
      entity->open = (XML_Bool )1;
#line 2384
      context = getContext(parser);
#line 2385
      entity->open = (XML_Bool )0;
      }
#line 2386
      if (! context) {
#line 2387
        return ((enum XML_Error )1);
      }
      {
#line 2388
      tmp___3 = (*(parser->m_externalEntityRefHandler))(parser->m_externalEntityRefHandlerArg,
                                                        context, entity->base, entity->systemId,
                                                        entity->publicId);
      }
#line 2388
      if (! tmp___3) {
#line 2393
        return ((enum XML_Error )21);
      }
#line 2394
      parser->m_tempPool.ptr = parser->m_tempPool.start;
    } else
#line 2396
    if (parser->m_defaultHandler) {
      {
#line 2397
      reportDefault(parser, enc, s, next);
      }
    }
#line 2398
    goto switch_break;
    case_1: /* CIL Label */ 
    case_2: /* CIL Label */ 
#line 2407
    if (parser->m_freeTagList) {
#line 2408
      tag = parser->m_freeTagList;
#line 2409
      parser->m_freeTagList = (parser->m_freeTagList)->parent;
    } else {
      {
#line 2412
      tmp___4 = (*(parser->m_mem.malloc_fcn))(sizeof(TAG ));
#line 2412
      tag = (TAG *)tmp___4;
      }
#line 2413
      if (! tag) {
#line 2414
        return ((enum XML_Error )1);
      }
      {
#line 2415
      tmp___5 = (*(parser->m_mem.malloc_fcn))((size_t )32);
#line 2415
      tag->buf = (char *)tmp___5;
      }
#line 2416
      if (! tag->buf) {
        {
#line 2417
        (*(parser->m_mem.free_fcn))((void *)tag);
        }
#line 2418
        return ((enum XML_Error )1);
      }
#line 2420
      tag->bufEnd = tag->buf + 32;
    }
    {
#line 2422
    tag->bindings = (BINDING *)((void *)0);
#line 2423
    tag->parent = parser->m_tagStack;
#line 2424
    parser->m_tagStack = tag;
#line 2425
    tag->name.localPart = (XML_Char const   *)((void *)0);
#line 2426
    tag->name.prefix = (XML_Char const   *)((void *)0);
#line 2427
    tag->rawName = s + enc->minBytesPerChar;
#line 2428
    tag->rawNameLength = (*(enc->nameLength))(enc, tag->rawName);
#line 2429
    (parser->m_tagLevel) ++;
#line 2431
    rawNameEnd = tag->rawName + tag->rawNameLength;
#line 2432
    fromPtr = tag->rawName;
#line 2433
    toPtr = tag->buf;
    }
    {
#line 2434
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 2437
      (*(enc->utf8Convert))(enc, & fromPtr, rawNameEnd, & toPtr, (char const   *)(tag->bufEnd - 1));
#line 2440
      convLen = (int )(toPtr - tag->buf);
      }
#line 2441
      if ((unsigned long )fromPtr == (unsigned long )rawNameEnd) {
#line 2442
        tag->name.strLen = convLen;
#line 2443
        goto while_break___0;
      }
      {
#line 2445
      bufSize = (int )(tag->bufEnd - tag->buf) << 1;
#line 2447
      tmp___6 = (*(parser->m_mem.realloc_fcn))((void *)tag->buf, (size_t )bufSize);
#line 2447
      temp = (char *)tmp___6;
      }
#line 2448
      if ((unsigned long )temp == (unsigned long )((void *)0)) {
#line 2449
        return ((enum XML_Error )1);
      }
#line 2450
      tag->buf = temp;
#line 2451
      tag->bufEnd = temp + bufSize;
#line 2452
      toPtr = temp + convLen;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 2456
    tag->name.str = (XML_Char const   *)tag->buf;
#line 2457
    *toPtr = (XML_Char )'\000';
#line 2458
    result___0 = storeAtts(parser, enc, s, & tag->name, & tag->bindings);
    }
#line 2459
    if (result___0) {
#line 2460
      return (result___0);
    }
#line 2461
    if (parser->m_startElementHandler) {
      {
#line 2462
      (*(parser->m_startElementHandler))(parser->m_handlerArg, tag->name.str, (XML_Char const   **)parser->m_atts);
      }
    } else
#line 2464
    if (parser->m_defaultHandler) {
      {
#line 2465
      reportDefault(parser, enc, s, next);
      }
    }
    {
#line 2466
    poolClear(& parser->m_tempPool);
    }
#line 2467
    goto switch_break;
    case_3: /* CIL Label */ 
    case_4: /* CIL Label */ 
    {
#line 2473
    rawName = s + enc->minBytesPerChar;
#line 2475
    bindings = (BINDING *)((void *)0);
#line 2476
    noElmHandlers = (XML_Bool )1;
#line 2478
    tmp___7 = (*(enc->nameLength))(enc, rawName);
#line 2478
    tmp___8 = poolStoreString(& parser->m_tempPool, enc, rawName, rawName + tmp___7);
#line 2478
    name___0.str = (XML_Char const   *)tmp___8;
    }
#line 2480
    if (! name___0.str) {
#line 2481
      return ((enum XML_Error )1);
    }
    {
#line 2482
    parser->m_tempPool.start = parser->m_tempPool.ptr;
#line 2483
    result___1 = storeAtts(parser, enc, s, & name___0, & bindings);
    }
#line 2484
    if (result___1) {
#line 2485
      return (result___1);
    }
#line 2486
    parser->m_tempPool.start = parser->m_tempPool.ptr;
#line 2487
    if (parser->m_startElementHandler) {
      {
#line 2488
      (*(parser->m_startElementHandler))(parser->m_handlerArg, name___0.str, (XML_Char const   **)parser->m_atts);
#line 2489
      noElmHandlers = (XML_Bool )0;
      }
    }
#line 2491
    if (parser->m_endElementHandler) {
#line 2492
      if (parser->m_startElementHandler) {
#line 2493
        *eventPP = *eventEndPP;
      }
      {
#line 2494
      (*(parser->m_endElementHandler))(parser->m_handlerArg, name___0.str);
#line 2495
      noElmHandlers = (XML_Bool )0;
      }
    }
#line 2497
    if (noElmHandlers) {
#line 2497
      if (parser->m_defaultHandler) {
        {
#line 2498
        reportDefault(parser, enc, s, next);
        }
      }
    }
    {
#line 2499
    poolClear(& parser->m_tempPool);
    }
    {
#line 2500
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 2500
      if (! bindings) {
#line 2500
        goto while_break___1;
      }
#line 2501
      b = bindings;
#line 2502
      if (parser->m_endNamespaceDeclHandler) {
        {
#line 2503
        (*(parser->m_endNamespaceDeclHandler))(parser->m_handlerArg, (b->prefix)->name);
        }
      }
#line 2504
      bindings = bindings->nextTagBinding;
#line 2505
      b->nextTagBinding = parser->m_freeBindingList;
#line 2506
      parser->m_freeBindingList = b;
#line 2507
      (b->prefix)->binding = b->prevPrefixBinding;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 2510
    if (parser->m_tagLevel == 0) {
      {
#line 2511
      tmp___9 = epilogProcessor(parser, next, end, nextPtr);
      }
#line 2511
      return (tmp___9);
    }
#line 2512
    goto switch_break;
    case_5: /* CIL Label */ 
#line 2514
    if (parser->m_tagLevel == startTagLevel) {
#line 2515
      return ((enum XML_Error )13);
    } else {
      {
#line 2519
      tag___0 = parser->m_tagStack;
#line 2520
      parser->m_tagStack = tag___0->parent;
#line 2521
      tag___0->parent = parser->m_freeTagList;
#line 2522
      parser->m_freeTagList = tag___0;
#line 2523
      rawName___0 = s + enc->minBytesPerChar * 2;
#line 2524
      len = (*(enc->nameLength))(enc, rawName___0);
      }
#line 2525
      if (len != tag___0->rawNameLength) {
#line 2527
        *eventPP = rawName___0;
#line 2528
        return ((enum XML_Error )7);
      } else {
        {
#line 2525
        tmp___10 = memcmp((void const   *)tag___0->rawName, (void const   *)rawName___0,
                          (size_t )len);
        }
#line 2525
        if (tmp___10 != 0) {
#line 2527
          *eventPP = rawName___0;
#line 2528
          return ((enum XML_Error )7);
        }
      }
#line 2530
      (parser->m_tagLevel) --;
#line 2531
      if (parser->m_endElementHandler) {
#line 2535
        localPart = tag___0->name.localPart;
#line 2536
        if (parser->m_ns) {
#line 2536
          if (localPart) {
#line 2541
            uri = (XML_Char *)tag___0->name.str + tag___0->name.uriLen;
            {
#line 2543
            while (1) {
              while_continue___2: /* CIL Label */ ;
#line 2543
              if (! *localPart) {
#line 2543
                goto while_break___2;
              }
#line 2543
              tmp___11 = uri;
#line 2543
              uri ++;
#line 2543
              tmp___12 = localPart;
#line 2543
              localPart ++;
#line 2543
              *tmp___11 = (XML_Char )*tmp___12;
            }
            while_break___2: /* CIL Label */ ;
            }
#line 2544
            prefix = (XML_Char const   *)((XML_Char *)tag___0->name.prefix);
#line 2545
            if (parser->m_ns_triplets) {
#line 2545
              if (prefix) {
#line 2546
                tmp___13 = uri;
#line 2546
                uri ++;
#line 2546
                *tmp___13 = parser->m_namespaceSeparator;
                {
#line 2547
                while (1) {
                  while_continue___3: /* CIL Label */ ;
#line 2547
                  if (! *prefix) {
#line 2547
                    goto while_break___3;
                  }
#line 2547
                  tmp___14 = uri;
#line 2547
                  uri ++;
#line 2547
                  tmp___15 = prefix;
#line 2547
                  prefix ++;
#line 2547
                  *tmp___14 = (XML_Char )*tmp___15;
                }
                while_break___3: /* CIL Label */ ;
                }
              }
            }
#line 2549
            *uri = (XML_Char )'\000';
          }
        }
        {
#line 2551
        (*(parser->m_endElementHandler))(parser->m_handlerArg, tag___0->name.str);
        }
      } else
#line 2553
      if (parser->m_defaultHandler) {
        {
#line 2554
        reportDefault(parser, enc, s, next);
        }
      }
      {
#line 2555
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 2555
        if (! tag___0->bindings) {
#line 2555
          goto while_break___4;
        }
#line 2556
        b___0 = tag___0->bindings;
#line 2557
        if (parser->m_endNamespaceDeclHandler) {
          {
#line 2558
          (*(parser->m_endNamespaceDeclHandler))(parser->m_handlerArg, (b___0->prefix)->name);
          }
        }
#line 2559
        tag___0->bindings = (tag___0->bindings)->nextTagBinding;
#line 2560
        b___0->nextTagBinding = parser->m_freeBindingList;
#line 2561
        parser->m_freeBindingList = b___0;
#line 2562
        (b___0->prefix)->binding = b___0->prevPrefixBinding;
      }
      while_break___4: /* CIL Label */ ;
      }
#line 2564
      if (parser->m_tagLevel == 0) {
        {
#line 2565
        tmp___16 = epilogProcessor(parser, next, end, nextPtr);
        }
#line 2565
        return (tmp___16);
      }
    }
#line 2567
    goto switch_break;
    case_10: /* CIL Label */ 
    {
#line 2570
    tmp___17 = (*(enc->charRefNumber))(enc, s);
#line 2570
    n = tmp___17;
    }
#line 2571
    if (n < 0) {
#line 2572
      return ((enum XML_Error )14);
    }
#line 2573
    if (parser->m_characterDataHandler) {
      {
#line 2575
      tmp___18 = XmlUtf8Encode(n, buf);
#line 2575
      (*(parser->m_characterDataHandler))(parser->m_handlerArg, (XML_Char const   *)(buf),
                                          tmp___18);
      }
    } else
#line 2577
    if (parser->m_defaultHandler) {
      {
#line 2578
      reportDefault(parser, enc, s, next);
      }
    }
#line 2580
    goto switch_break;
    case_12: /* CIL Label */ 
#line 2582
    return ((enum XML_Error )17);
    case_7: /* CIL Label */ 
#line 2584
    if (parser->m_characterDataHandler) {
      {
#line 2585
      c___1 = (XML_Char )10;
#line 2586
      (*(parser->m_characterDataHandler))(parser->m_handlerArg, (XML_Char const   *)(& c___1),
                                          1);
      }
    } else
#line 2588
    if (parser->m_defaultHandler) {
      {
#line 2589
      reportDefault(parser, enc, s, next);
      }
    }
#line 2590
    goto switch_break;
    case_8: /* CIL Label */ 
#line 2594
    if (parser->m_startCdataSectionHandler) {
      {
#line 2595
      (*(parser->m_startCdataSectionHandler))(parser->m_handlerArg);
      }
    } else
#line 2612
    if (parser->m_defaultHandler) {
      {
#line 2613
      reportDefault(parser, enc, s, next);
      }
    }
    {
#line 2614
    result___2 = doCdataSection(parser, enc, & next, end, nextPtr, haveMore);
    }
#line 2615
    if ((unsigned int )result___2 != 0U) {
#line 2616
      return (result___2);
    } else
#line 2617
    if (! next) {
#line 2618
      parser->m_processor = & cdataSectionProcessor;
#line 2619
      return (result___2);
    }
#line 2622
    goto switch_break;
    case_neg_5: /* CIL Label */ 
#line 2624
    if (haveMore) {
#line 2625
      *nextPtr = s;
#line 2626
      return ((enum XML_Error )0);
    }
#line 2628
    if (parser->m_characterDataHandler) {
#line 2629
      if (! enc->isUtf8) {
        {
#line 2630
        dataPtr = parser->m_dataBuf;
#line 2631
        (*(enc->utf8Convert))(enc, & s, end, & dataPtr, (char const   *)parser->m_dataBufEnd);
#line 2632
        (*(parser->m_characterDataHandler))(parser->m_handlerArg, (XML_Char const   *)parser->m_dataBuf,
                                            (int )(dataPtr - parser->m_dataBuf));
        }
      } else {
        {
#line 2636
        (*(parser->m_characterDataHandler))(parser->m_handlerArg, (XML_Char const   *)((XML_Char *)s),
                                            (int )((XML_Char *)end - (XML_Char *)s));
        }
      }
    } else
#line 2640
    if (parser->m_defaultHandler) {
      {
#line 2641
      reportDefault(parser, enc, s, end);
      }
    }
#line 2645
    if (startTagLevel == 0) {
#line 2646
      *eventPP = end;
#line 2647
      return ((enum XML_Error )3);
    }
#line 2649
    if (parser->m_tagLevel != startTagLevel) {
#line 2650
      *eventPP = end;
#line 2651
      return ((enum XML_Error )13);
    }
#line 2653
    *nextPtr = end;
#line 2654
    return ((enum XML_Error )0);
    case_6: /* CIL Label */ 
#line 2657
    charDataHandler = parser->m_characterDataHandler;
#line 2658
    if (charDataHandler) {
#line 2659
      if (! enc->isUtf8) {
        {
#line 2660
        while (1) {
          while_continue___5: /* CIL Label */ ;
          {
#line 2661
          dataPtr___0 = parser->m_dataBuf;
#line 2662
          (*(enc->utf8Convert))(enc, & s, next, & dataPtr___0, (char const   *)parser->m_dataBufEnd);
#line 2663
          *eventEndPP = s;
#line 2664
          (*charDataHandler)(parser->m_handlerArg, (XML_Char const   *)parser->m_dataBuf,
                             (int )(dataPtr___0 - parser->m_dataBuf));
          }
#line 2666
          if ((unsigned long )s == (unsigned long )next) {
#line 2667
            goto while_break___5;
          }
#line 2668
          *eventPP = s;
        }
        while_break___5: /* CIL Label */ ;
        }
      } else {
        {
#line 2672
        (*charDataHandler)(parser->m_handlerArg, (XML_Char const   *)((XML_Char *)s),
                           (int )((XML_Char *)next - (XML_Char *)s));
        }
      }
    } else
#line 2676
    if (parser->m_defaultHandler) {
      {
#line 2677
      reportDefault(parser, enc, s, next);
      }
    }
#line 2679
    goto switch_break;
    case_11: /* CIL Label */ 
    {
#line 2681
    tmp___19 = reportProcessingInstruction(parser, enc, s, next);
    }
#line 2681
    if (! tmp___19) {
#line 2682
      return ((enum XML_Error )1);
    }
#line 2683
    goto switch_break;
    case_13: /* CIL Label */ 
    {
#line 2685
    tmp___20 = reportComment(parser, enc, s, next);
    }
#line 2685
    if (! tmp___20) {
#line 2686
      return ((enum XML_Error )1);
    }
#line 2687
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 2689
    if (parser->m_defaultHandler) {
      {
#line 2690
      reportDefault(parser, enc, s, next);
      }
    }
#line 2691
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 2693
    s = next;
#line 2693
    *eventPP = s;
    {
#line 2695
    if ((unsigned int )parser->m_parsingStatus.parsing == 3U) {
#line 2695
      goto case_3___0;
    }
#line 2698
    if ((unsigned int )parser->m_parsingStatus.parsing == 2U) {
#line 2698
      goto case_2___0;
    }
#line 2700
    goto switch_default___0;
    case_3___0: /* CIL Label */ 
#line 2696
    *nextPtr = next;
#line 2697
    return ((enum XML_Error )0);
    case_2___0: /* CIL Label */ 
#line 2699
    return ((enum XML_Error )35);
    switch_default___0: /* CIL Label */ ;
    switch_break___0: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 2716 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlparse.c"
static enum XML_Error storeAtts(XML_Parser parser , ENCODING const   *enc , char const   *attStr ,
                                TAG_NAME *tagNamePtr , BINDING **bindingsPtr ) 
{ 
  DTD *dtd ;
  ELEMENT_TYPE *elementType ;
  int nDefaultAtts ;
  XML_Char const   **appAtts ;
  int attIndex ;
  int prefixLen ;
  int i ;
  int n ;
  XML_Char *uri ;
  int nPrefixes ;
  BINDING *binding ;
  XML_Char const   *localPart ;
  NAMED *tmp ;
  XML_Char const   *name ;
  XML_Char const   *tmp___0 ;
  NAMED *tmp___1 ;
  int tmp___2 ;
  int oldAttsSize ;
  ATTRIBUTE *temp ;
  void *tmp___3 ;
  ATTRIBUTE *currAtt ;
  ATTRIBUTE_ID *attId ;
  int tmp___4 ;
  ATTRIBUTE_ID *tmp___5 ;
  int tmp___6 ;
  enum XML_Error result ;
  XML_Bool isCdata ;
  int j ;
  XML_Char *tmp___7 ;
  enum XML_Error result___0 ;
  enum XML_Error tmp___8 ;
  DEFAULT_ATTRIBUTE const   *da ;
  enum XML_Error result___1 ;
  enum XML_Error tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int j___0 ;
  unsigned long version ;
  int nsAttsSize ;
  NS_ATT *temp___0 ;
  unsigned char tmp___14 ;
  void *tmp___15 ;
  XML_Char const   *s ;
  ATTRIBUTE_ID *id ;
  BINDING const   *b ;
  unsigned long uriHash ;
  NAMED *tmp___16 ;
  XML_Char c___0 ;
  XML_Char *tmp___18 ;
  int tmp___19 ;
  XML_Bool tmp___20 ;
  XML_Char const   *tmp___21 ;
  XML_Char c___1 ;
  XML_Char *tmp___23 ;
  int tmp___24 ;
  XML_Bool tmp___25 ;
  XML_Char const   *tmp___26 ;
  unsigned char step ;
  unsigned long mask ;
  XML_Char const   *s1 ;
  XML_Char const   *s2 ;
  XML_Char *tmp___28 ;
  int tmp___29 ;
  XML_Bool tmp___30 ;
  XML_Char const   *tmp___31 ;
  XML_Char const   *tmp___32 ;
  int tmp___33 ;
  int tmp___34 ;
  TAG *p ;
  void *tmp___35 ;

  {
  {
#line 2721
  dtd = parser->m_dtd;
#line 2725
  attIndex = 0;
#line 2730
  nPrefixes = 0;
#line 2735
  tmp = lookup(parser, & dtd->elementTypes, tagNamePtr->str, (size_t )0);
#line 2735
  elementType = (ELEMENT_TYPE *)tmp;
  }
#line 2736
  if (! elementType) {
    {
#line 2737
    tmp___0 = poolCopyString(& dtd->pool, tagNamePtr->str);
#line 2737
    name = tmp___0;
    }
#line 2738
    if (! name) {
#line 2739
      return ((enum XML_Error )1);
    }
    {
#line 2740
    tmp___1 = lookup(parser, & dtd->elementTypes, name, sizeof(ELEMENT_TYPE ));
#line 2740
    elementType = (ELEMENT_TYPE *)tmp___1;
    }
#line 2742
    if (! elementType) {
#line 2743
      return ((enum XML_Error )1);
    }
#line 2744
    if (parser->m_ns) {
      {
#line 2744
      tmp___2 = setElementTypePrefix(parser, elementType);
      }
#line 2744
      if (! tmp___2) {
#line 2745
        return ((enum XML_Error )1);
      }
    }
  }
  {
#line 2747
  nDefaultAtts = elementType->nDefaultAtts;
#line 2750
  n = (*(enc->getAtts))(enc, attStr, parser->m_attsSize, parser->m_atts);
  }
#line 2751
  if (n + nDefaultAtts > parser->m_attsSize) {
    {
#line 2752
    oldAttsSize = parser->m_attsSize;
#line 2757
    parser->m_attsSize = (n + nDefaultAtts) + 16;
#line 2758
    tmp___3 = (*(parser->m_mem.realloc_fcn))((void *)parser->m_atts, (unsigned long )parser->m_attsSize * sizeof(ATTRIBUTE ));
#line 2758
    temp = (ATTRIBUTE *)tmp___3;
    }
#line 2759
    if ((unsigned long )temp == (unsigned long )((void *)0)) {
#line 2760
      return ((enum XML_Error )1);
    }
#line 2761
    parser->m_atts = temp;
#line 2768
    if (n > oldAttsSize) {
      {
#line 2769
      (*(enc->getAtts))(enc, attStr, n, parser->m_atts);
      }
    }
  }
#line 2772
  appAtts = (XML_Char const   **)parser->m_atts;
#line 2773
  i = 0;
  {
#line 2773
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2773
    if (! (i < n)) {
#line 2773
      goto while_break;
    }
    {
#line 2774
    currAtt = parser->m_atts + i;
#line 2779
    tmp___4 = (*(enc->nameLength))(enc, currAtt->name);
#line 2779
    tmp___5 = getAttributeId(parser, enc, currAtt->name, currAtt->name + tmp___4);
#line 2779
    attId = tmp___5;
    }
#line 2782
    if (! attId) {
#line 2783
      return ((enum XML_Error )1);
    }
#line 2796
    if (*(attId->name + -1)) {
#line 2797
      if ((unsigned long )enc == (unsigned long )parser->m_encoding) {
#line 2798
        parser->m_eventPtr = (parser->m_atts + i)->name;
      }
#line 2799
      return ((enum XML_Error )8);
    }
#line 2801
    *(attId->name + -1) = (XML_Char )1;
#line 2802
    tmp___6 = attIndex;
#line 2802
    attIndex ++;
#line 2802
    *(appAtts + tmp___6) = (XML_Char const   *)attId->name;
#line 2803
    if (! (parser->m_atts + i)->normalized) {
#line 2805
      isCdata = (XML_Bool )1;
#line 2808
      if (attId->maybeTokenized) {
#line 2810
        j = 0;
        {
#line 2810
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 2810
          if (! (j < nDefaultAtts)) {
#line 2810
            goto while_break___0;
          }
#line 2811
          if ((unsigned long )attId == (unsigned long )(elementType->defaultAtts + j)->id) {
#line 2812
            isCdata = (elementType->defaultAtts + j)->isCdata;
#line 2813
            goto while_break___0;
          }
#line 2810
          j ++;
        }
        while_break___0: /* CIL Label */ ;
        }
      }
      {
#line 2819
      result = storeAttributeValue(parser, enc, isCdata, (parser->m_atts + i)->valuePtr,
                                   (parser->m_atts + i)->valueEnd, & parser->m_tempPool);
      }
#line 2822
      if (result) {
#line 2823
        return (result);
      }
#line 2824
      *(appAtts + attIndex) = (XML_Char const   *)parser->m_tempPool.start;
#line 2825
      parser->m_tempPool.start = parser->m_tempPool.ptr;
    } else {
      {
#line 2829
      tmp___7 = poolStoreString(& parser->m_tempPool, enc, (parser->m_atts + i)->valuePtr,
                                (parser->m_atts + i)->valueEnd);
#line 2829
      *(appAtts + attIndex) = (XML_Char const   *)tmp___7;
      }
#line 2831
      if ((unsigned long )*(appAtts + attIndex) == (unsigned long )((XML_Char const   *)0)) {
#line 2832
        return ((enum XML_Error )1);
      }
#line 2833
      parser->m_tempPool.start = parser->m_tempPool.ptr;
    }
#line 2836
    if (attId->prefix) {
#line 2837
      if (attId->xmlns) {
        {
#line 2839
        tmp___8 = addBinding(parser, attId->prefix, (ATTRIBUTE_ID const   *)attId,
                             *(appAtts + attIndex), bindingsPtr);
#line 2839
        result___0 = tmp___8;
        }
#line 2841
        if (result___0) {
#line 2842
          return (result___0);
        }
#line 2843
        attIndex --;
      } else {
#line 2847
        attIndex ++;
#line 2848
        nPrefixes ++;
#line 2849
        *(attId->name + -1) = (XML_Char )2;
      }
    } else {
#line 2853
      attIndex ++;
    }
#line 2773
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2857
  parser->m_nSpecifiedAtts = attIndex;
#line 2858
  if (elementType->idAtt) {
#line 2858
    if (*((elementType->idAtt)->name + -1)) {
#line 2859
      i = 0;
      {
#line 2859
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 2859
        if (! (i < attIndex)) {
#line 2859
          goto while_break___1;
        }
#line 2860
        if ((unsigned long )*(appAtts + i) == (unsigned long )(elementType->idAtt)->name) {
#line 2861
          parser->m_idAttIndex = i;
#line 2862
          goto while_break___1;
        }
#line 2859
        i += 2;
      }
      while_break___1: /* CIL Label */ ;
      }
    } else {
#line 2866
      parser->m_idAttIndex = -1;
    }
  } else {
#line 2866
    parser->m_idAttIndex = -1;
  }
#line 2869
  i = 0;
  {
#line 2869
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 2869
    if (! (i < nDefaultAtts)) {
#line 2869
      goto while_break___2;
    }
#line 2870
    da = (DEFAULT_ATTRIBUTE const   *)(elementType->defaultAtts + i);
#line 2871
    if (! *((da->id)->name + -1)) {
#line 2871
      if (da->value) {
#line 2872
        if ((da->id)->prefix) {
#line 2873
          if ((da->id)->xmlns) {
            {
#line 2874
            tmp___9 = addBinding(parser, (PREFIX *)(da->id)->prefix, (ATTRIBUTE_ID const   *)da->id,
                                 (XML_Char const   *)da->value, bindingsPtr);
#line 2874
            result___1 = tmp___9;
            }
#line 2876
            if (result___1) {
#line 2877
              return (result___1);
            }
          } else {
#line 2880
            *((da->id)->name + -1) = (XML_Char )2;
#line 2881
            nPrefixes ++;
#line 2882
            tmp___10 = attIndex;
#line 2882
            attIndex ++;
#line 2882
            *(appAtts + tmp___10) = (XML_Char const   *)(da->id)->name;
#line 2883
            tmp___11 = attIndex;
#line 2883
            attIndex ++;
#line 2883
            *(appAtts + tmp___11) = (XML_Char const   *)da->value;
          }
        } else {
#line 2887
          *((da->id)->name + -1) = (XML_Char )1;
#line 2888
          tmp___12 = attIndex;
#line 2888
          attIndex ++;
#line 2888
          *(appAtts + tmp___12) = (XML_Char const   *)(da->id)->name;
#line 2889
          tmp___13 = attIndex;
#line 2889
          attIndex ++;
#line 2889
          *(appAtts + tmp___13) = (XML_Char const   *)da->value;
        }
      }
    }
#line 2869
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 2893
  *(appAtts + attIndex) = (XML_Char const   *)0;
#line 2897
  i = 0;
#line 2898
  if (nPrefixes) {
#line 2900
    version = parser->m_nsAttsVersion;
#line 2901
    nsAttsSize = 1 << (int )parser->m_nsAttsPower;
#line 2903
    if ((nPrefixes << 1) >> (int )parser->m_nsAttsPower) {
      {
#line 2906
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 2906
        tmp___14 = parser->m_nsAttsPower;
#line 2906
        parser->m_nsAttsPower = (unsigned char )((int )parser->m_nsAttsPower + 1);
#line 2906
        if (! (nPrefixes >> (int )tmp___14)) {
#line 2906
          goto while_break___3;
        }
      }
      while_break___3: /* CIL Label */ ;
      }
#line 2907
      if ((int )parser->m_nsAttsPower < 3) {
#line 2908
        parser->m_nsAttsPower = (unsigned char)3;
      }
      {
#line 2909
      nsAttsSize = 1 << (int )parser->m_nsAttsPower;
#line 2910
      tmp___15 = (*(parser->m_mem.realloc_fcn))((void *)parser->m_nsAtts, (unsigned long )nsAttsSize * sizeof(NS_ATT ));
#line 2910
      temp___0 = (NS_ATT *)tmp___15;
      }
#line 2911
      if (! temp___0) {
#line 2912
        return ((enum XML_Error )1);
      }
#line 2913
      parser->m_nsAtts = temp___0;
#line 2914
      version = 0UL;
    }
#line 2917
    if (! version) {
#line 2918
      version = 4294967295UL;
#line 2919
      j___0 = nsAttsSize;
      {
#line 2919
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 2919
        if (! (j___0 != 0)) {
#line 2919
          goto while_break___4;
        }
#line 2920
        j___0 --;
#line 2920
        (parser->m_nsAtts + j___0)->version = version;
      }
      while_break___4: /* CIL Label */ ;
      }
    }
#line 2922
    version --;
#line 2922
    parser->m_nsAttsVersion = version;
    {
#line 2925
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 2925
      if (! (i < attIndex)) {
#line 2925
        goto while_break___5;
      }
#line 2926
      s = *(appAtts + i);
#line 2927
      if ((int const   )*(s + -1) == 2) {
        {
#line 2930
        uriHash = parser->m_hash_secret_salt;
#line 2931
        *((XML_Char *)s + -1) = (XML_Char )0;
#line 2932
        tmp___16 = lookup(parser, & dtd->attributeIds, s, (size_t )0);
#line 2932
        id = (ATTRIBUTE_ID *)tmp___16;
#line 2933
        b = (BINDING const   *)(id->prefix)->binding;
        }
#line 2934
        if (! b) {
#line 2935
          return ((enum XML_Error )27);
        }
#line 2938
        j___0 = 0;
        {
#line 2938
        while (1) {
          while_continue___6: /* CIL Label */ ;
#line 2938
          if (! (j___0 < (int )b->uriLen)) {
#line 2938
            goto while_break___6;
          }
#line 2939
          c___0 = *(b->uri + j___0);
#line 2940
          if ((unsigned long )parser->m_tempPool.ptr == (unsigned long )parser->m_tempPool.end) {
            {
#line 2940
            tmp___20 = poolGrow(& parser->m_tempPool);
            }
#line 2940
            if (tmp___20) {
#line 2940
              tmp___18 = parser->m_tempPool.ptr;
#line 2940
              (parser->m_tempPool.ptr) ++;
#line 2940
              *tmp___18 = c___0;
#line 2940
              tmp___19 = 1;
            } else {
#line 2940
              tmp___19 = 0;
            }
          } else {
#line 2940
            tmp___18 = parser->m_tempPool.ptr;
#line 2940
            (parser->m_tempPool.ptr) ++;
#line 2940
            *tmp___18 = c___0;
#line 2940
            tmp___19 = 1;
          }
#line 2940
          if (! tmp___19) {
#line 2941
            return ((enum XML_Error )1);
          }
#line 2942
          uriHash = uriHash * 1000003UL ^ (unsigned long )((unsigned char )c___0);
#line 2938
          j___0 ++;
        }
        while_break___6: /* CIL Label */ ;
        }
        {
#line 2944
        while (1) {
          while_continue___7: /* CIL Label */ ;
#line 2944
          tmp___21 = s;
#line 2944
          s ++;
#line 2944
          if (! ((int const   )*tmp___21 != 58)) {
#line 2944
            goto while_break___7;
          }
        }
        while_break___7: /* CIL Label */ ;
        }
        {
#line 2946
        while (1) {
          while_continue___8: /* CIL Label */ ;
#line 2947
          c___1 = (XML_Char )*s;
#line 2948
          if ((unsigned long )parser->m_tempPool.ptr == (unsigned long )parser->m_tempPool.end) {
            {
#line 2948
            tmp___25 = poolGrow(& parser->m_tempPool);
            }
#line 2948
            if (tmp___25) {
#line 2948
              tmp___23 = parser->m_tempPool.ptr;
#line 2948
              (parser->m_tempPool.ptr) ++;
#line 2948
              *tmp___23 = (XML_Char )*s;
#line 2948
              tmp___24 = 1;
            } else {
#line 2948
              tmp___24 = 0;
            }
          } else {
#line 2948
            tmp___23 = parser->m_tempPool.ptr;
#line 2948
            (parser->m_tempPool.ptr) ++;
#line 2948
            *tmp___23 = (XML_Char )*s;
#line 2948
            tmp___24 = 1;
          }
#line 2948
          if (! tmp___24) {
#line 2949
            return ((enum XML_Error )1);
          }
#line 2950
          uriHash = uriHash * 1000003UL ^ (unsigned long )((unsigned char )c___1);
#line 2946
          tmp___26 = s;
#line 2946
          s ++;
#line 2946
          if (! *tmp___26) {
#line 2946
            goto while_break___8;
          }
        }
        while_break___8: /* CIL Label */ ;
        }
#line 2956
        step = (unsigned char)0;
#line 2957
        mask = (unsigned long )(nsAttsSize - 1);
#line 2958
        j___0 = (int )(uriHash & mask);
        {
#line 2959
        while (1) {
          while_continue___9: /* CIL Label */ ;
#line 2959
          if (! ((parser->m_nsAtts + j___0)->version == version)) {
#line 2959
            goto while_break___9;
          }
#line 2961
          if (uriHash == (parser->m_nsAtts + j___0)->hash) {
#line 2962
            s1 = (XML_Char const   *)parser->m_tempPool.start;
#line 2963
            s2 = (parser->m_nsAtts + j___0)->uriName;
            {
#line 2965
            while (1) {
              while_continue___10: /* CIL Label */ ;
#line 2965
              if ((int const   )*s1 == (int const   )*s2) {
#line 2965
                if (! ((int const   )*s1 != 0)) {
#line 2965
                  goto while_break___10;
                }
              } else {
#line 2965
                goto while_break___10;
              }
#line 2965
              s1 ++;
#line 2965
              s2 ++;
            }
            while_break___10: /* CIL Label */ ;
            }
#line 2966
            if ((int const   )*s1 == 0) {
#line 2967
              return ((enum XML_Error )8);
            }
          }
#line 2969
          if (! step) {
#line 2970
            step = (unsigned char )((((uriHash & ~ mask) >> ((int )parser->m_nsAttsPower - 1)) & (mask >> 2)) | 1UL);
          }
#line 2971
          if (j___0 < (int )step) {
#line 2971
            j___0 += nsAttsSize - (int )step;
          } else {
#line 2971
            j___0 -= (int )step;
          }
        }
        while_break___9: /* CIL Label */ ;
        }
#line 2975
        if (parser->m_ns_triplets) {
#line 2976
          *(parser->m_tempPool.ptr + -1) = parser->m_namespaceSeparator;
#line 2977
          s = (b->prefix)->name;
          {
#line 2978
          while (1) {
            while_continue___11: /* CIL Label */ ;
#line 2979
            if ((unsigned long )parser->m_tempPool.ptr == (unsigned long )parser->m_tempPool.end) {
              {
#line 2979
              tmp___30 = poolGrow(& parser->m_tempPool);
              }
#line 2979
              if (tmp___30) {
#line 2979
                tmp___28 = parser->m_tempPool.ptr;
#line 2979
                (parser->m_tempPool.ptr) ++;
#line 2979
                *tmp___28 = (XML_Char )*s;
#line 2979
                tmp___29 = 1;
              } else {
#line 2979
                tmp___29 = 0;
              }
            } else {
#line 2979
              tmp___28 = parser->m_tempPool.ptr;
#line 2979
              (parser->m_tempPool.ptr) ++;
#line 2979
              *tmp___28 = (XML_Char )*s;
#line 2979
              tmp___29 = 1;
            }
#line 2979
            if (! tmp___29) {
#line 2980
              return ((enum XML_Error )1);
            }
#line 2978
            tmp___31 = s;
#line 2978
            s ++;
#line 2978
            if (! *tmp___31) {
#line 2978
              goto while_break___11;
            }
          }
          while_break___11: /* CIL Label */ ;
          }
        }
#line 2985
        s = (XML_Char const   *)parser->m_tempPool.start;
#line 2986
        parser->m_tempPool.start = parser->m_tempPool.ptr;
#line 2987
        *(appAtts + i) = s;
#line 2990
        (parser->m_nsAtts + j___0)->version = version;
#line 2991
        (parser->m_nsAtts + j___0)->hash = uriHash;
#line 2992
        (parser->m_nsAtts + j___0)->uriName = s;
#line 2994
        nPrefixes --;
#line 2994
        if (! nPrefixes) {
#line 2995
          i += 2;
#line 2996
          goto while_break___5;
        }
      } else {
#line 3000
        *((XML_Char *)s + -1) = (XML_Char )0;
      }
#line 2925
      i += 2;
    }
    while_break___5: /* CIL Label */ ;
    }
  }
  {
#line 3004
  while (1) {
    while_continue___12: /* CIL Label */ ;
#line 3004
    if (! (i < attIndex)) {
#line 3004
      goto while_break___12;
    }
#line 3005
    *((XML_Char *)*(appAtts + i) + -1) = (XML_Char )0;
#line 3004
    i += 2;
  }
  while_break___12: /* CIL Label */ ;
  }
#line 3006
  binding = *bindingsPtr;
  {
#line 3006
  while (1) {
    while_continue___13: /* CIL Label */ ;
#line 3006
    if (! binding) {
#line 3006
      goto while_break___13;
    }
#line 3007
    *((binding->attId)->name + -1) = (XML_Char )0;
#line 3006
    binding = binding->nextTagBinding;
  }
  while_break___13: /* CIL Label */ ;
  }
#line 3009
  if (! parser->m_ns) {
#line 3010
    return ((enum XML_Error )0);
  }
#line 3013
  if (elementType->prefix) {
#line 3014
    binding = (elementType->prefix)->binding;
#line 3015
    if (! binding) {
#line 3016
      return ((enum XML_Error )27);
    }
#line 3017
    localPart = tagNamePtr->str;
    {
#line 3018
    while (1) {
      while_continue___14: /* CIL Label */ ;
#line 3018
      tmp___32 = localPart;
#line 3018
      localPart ++;
#line 3018
      if (! ((int const   )*tmp___32 != 58)) {
#line 3018
        goto while_break___14;
      }
    }
    while_break___14: /* CIL Label */ ;
    }
  } else
#line 3021
  if (dtd->defaultPrefix.binding) {
#line 3022
    binding = dtd->defaultPrefix.binding;
#line 3023
    localPart = tagNamePtr->str;
  } else {
#line 3026
    return ((enum XML_Error )0);
  }
#line 3027
  prefixLen = 0;
#line 3028
  if (parser->m_ns_triplets) {
#line 3028
    if ((binding->prefix)->name) {
      {
#line 3029
      while (1) {
        while_continue___15: /* CIL Label */ ;
#line 3029
        tmp___33 = prefixLen;
#line 3029
        prefixLen ++;
#line 3029
        if (! *((binding->prefix)->name + tmp___33)) {
#line 3029
          goto while_break___15;
        }
      }
      while_break___15: /* CIL Label */ ;
      }
    }
  }
#line 3032
  tagNamePtr->localPart = localPart;
#line 3033
  tagNamePtr->uriLen = binding->uriLen;
#line 3034
  tagNamePtr->prefix = (binding->prefix)->name;
#line 3035
  tagNamePtr->prefixLen = prefixLen;
#line 3036
  i = 0;
  {
#line 3036
  while (1) {
    while_continue___16: /* CIL Label */ ;
#line 3036
    tmp___34 = i;
#line 3036
    i ++;
#line 3036
    if (! *(localPart + tmp___34)) {
#line 3036
      goto while_break___16;
    }
  }
  while_break___16: /* CIL Label */ ;
  }
#line 3038
  n = (i + binding->uriLen) + prefixLen;
#line 3039
  if (n > binding->uriAlloc) {
    {
#line 3041
    tmp___35 = (*(parser->m_mem.malloc_fcn))((unsigned long )(n + 24) * sizeof(XML_Char ));
#line 3041
    uri = (XML_Char *)tmp___35;
    }
#line 3042
    if (! uri) {
#line 3043
      return ((enum XML_Error )1);
    }
    {
#line 3044
    binding->uriAlloc = n + 24;
#line 3045
    memcpy((void */* __restrict  */)uri, (void const   */* __restrict  */)binding->uri,
           (unsigned long )binding->uriLen * sizeof(XML_Char ));
#line 3046
    p = parser->m_tagStack;
    }
    {
#line 3046
    while (1) {
      while_continue___17: /* CIL Label */ ;
#line 3046
      if (! p) {
#line 3046
        goto while_break___17;
      }
#line 3047
      if ((unsigned long )p->name.str == (unsigned long )binding->uri) {
#line 3048
        p->name.str = (XML_Char const   *)uri;
      }
#line 3046
      p = p->parent;
    }
    while_break___17: /* CIL Label */ ;
    }
    {
#line 3049
    (*(parser->m_mem.free_fcn))((void *)binding->uri);
#line 3050
    binding->uri = uri;
    }
  }
  {
#line 3053
  uri = binding->uri + binding->uriLen;
#line 3054
  memcpy((void */* __restrict  */)uri, (void const   */* __restrict  */)localPart,
         (unsigned long )i * sizeof(XML_Char ));
  }
#line 3056
  if (prefixLen) {
    {
#line 3057
    uri += i - 1;
#line 3058
    *uri = parser->m_namespaceSeparator;
#line 3059
    memcpy((void */* __restrict  */)(uri + 1), (void const   */* __restrict  */)(binding->prefix)->name,
           (unsigned long )prefixLen * sizeof(XML_Char ));
    }
  }
#line 3061
  tagNamePtr->str = (XML_Char const   *)binding->uri;
#line 3062
  return ((enum XML_Error )0);
}
}
#line 3072 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlparse.c"
static XML_Char const   xmlNamespace[37]  = 
#line 3072
  {      (XML_Char const   )104,      (XML_Char const   )116,      (XML_Char const   )116,      (XML_Char const   )112, 
        (XML_Char const   )58,      (XML_Char const   )47,      (XML_Char const   )47,      (XML_Char const   )119, 
        (XML_Char const   )119,      (XML_Char const   )119,      (XML_Char const   )46,      (XML_Char const   )119, 
        (XML_Char const   )51,      (XML_Char const   )46,      (XML_Char const   )111,      (XML_Char const   )114, 
        (XML_Char const   )103,      (XML_Char const   )47,      (XML_Char const   )88,      (XML_Char const   )77, 
        (XML_Char const   )76,      (XML_Char const   )47,      (XML_Char const   )49,      (XML_Char const   )57, 
        (XML_Char const   )57,      (XML_Char const   )56,      (XML_Char const   )47,      (XML_Char const   )110, 
        (XML_Char const   )97,      (XML_Char const   )109,      (XML_Char const   )101,      (XML_Char const   )115, 
        (XML_Char const   )112,      (XML_Char const   )97,      (XML_Char const   )99,      (XML_Char const   )101, 
        (XML_Char const   )'\000'};
#line 3080 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlparse.c"
static int const   xmlLen  =    (int const   )((unsigned long )((int )sizeof(xmlNamespace)) / sizeof(XML_Char ) - 1UL);
#line 3082 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlparse.c"
static XML_Char const   xmlnsNamespace[30]  = 
#line 3082
  {      (XML_Char const   )104,      (XML_Char const   )116,      (XML_Char const   )116,      (XML_Char const   )112, 
        (XML_Char const   )58,      (XML_Char const   )47,      (XML_Char const   )47,      (XML_Char const   )119, 
        (XML_Char const   )119,      (XML_Char const   )119,      (XML_Char const   )46,      (XML_Char const   )119, 
        (XML_Char const   )51,      (XML_Char const   )46,      (XML_Char const   )111,      (XML_Char const   )114, 
        (XML_Char const   )103,      (XML_Char const   )47,      (XML_Char const   )50,      (XML_Char const   )48, 
        (XML_Char const   )48,      (XML_Char const   )48,      (XML_Char const   )47,      (XML_Char const   )120, 
        (XML_Char const   )109,      (XML_Char const   )108,      (XML_Char const   )110,      (XML_Char const   )115, 
        (XML_Char const   )47,      (XML_Char const   )'\000'};
#line 3089 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlparse.c"
static int const   xmlnsLen  =    (int const   )((unsigned long )((int )sizeof(xmlnsNamespace)) / sizeof(XML_Char ) - 1UL);
#line 3068 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlparse.c"
static enum XML_Error addBinding(XML_Parser parser , PREFIX *prefix , ATTRIBUTE_ID const   *attId ,
                                 XML_Char const   *uri , BINDING **bindingsPtr ) 
{ 
  XML_Bool mustBeXML ;
  XML_Bool isXML ;
  XML_Bool isXMLNS ;
  BINDING *b ;
  int len ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  XML_Char *temp ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  XML_Char const   *tmp___5 ;

  {
#line 3092
  mustBeXML = (XML_Bool )0;
#line 3093
  isXML = (XML_Bool )1;
#line 3094
  isXMLNS = (XML_Bool )1;
#line 3100
  if ((int const   )*uri == 0) {
#line 3100
    if (prefix->name) {
#line 3101
      return ((enum XML_Error )28);
    }
  }
#line 3103
  if (prefix->name) {
#line 3103
    if ((int const   )*(prefix->name + 0) == 120) {
#line 3103
      if ((int const   )*(prefix->name + 1) == 109) {
#line 3103
        if ((int const   )*(prefix->name + 2) == 108) {
#line 3109
          if ((int const   )*(prefix->name + 3) == 110) {
#line 3109
            if ((int const   )*(prefix->name + 4) == 115) {
#line 3109
              if ((int const   )*(prefix->name + 5) == 0) {
#line 3112
                return ((enum XML_Error )39);
              }
            }
          }
#line 3114
          if ((int const   )*(prefix->name + 3) == 0) {
#line 3115
            mustBeXML = (XML_Bool )1;
          }
        }
      }
    }
  }
#line 3118
  len = 0;
  {
#line 3118
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3118
    if (! *(uri + len)) {
#line 3118
      goto while_break;
    }
#line 3119
    if (isXML) {
#line 3119
      if (len > (int )xmlLen) {
#line 3120
        isXML = (XML_Bool )0;
      } else
#line 3119
      if ((int const   )*(uri + len) != (int const   )xmlNamespace[len]) {
#line 3120
        isXML = (XML_Bool )0;
      }
    }
#line 3122
    if (! mustBeXML) {
#line 3122
      if (isXMLNS) {
#line 3122
        if (len > (int )xmlnsLen) {
#line 3124
          isXMLNS = (XML_Bool )0;
        } else
#line 3122
        if ((int const   )*(uri + len) != (int const   )xmlnsNamespace[len]) {
#line 3124
          isXMLNS = (XML_Bool )0;
        }
      }
    }
#line 3118
    len ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 3126
  if (isXML) {
#line 3126
    if (len == (int )xmlLen) {
#line 3126
      tmp = 1;
    } else {
#line 3126
      tmp = 0;
    }
  } else {
#line 3126
    tmp = 0;
  }
#line 3126
  isXML = (XML_Bool )tmp;
#line 3127
  if (isXMLNS) {
#line 3127
    if (len == (int )xmlnsLen) {
#line 3127
      tmp___0 = 1;
    } else {
#line 3127
      tmp___0 = 0;
    }
  } else {
#line 3127
    tmp___0 = 0;
  }
#line 3127
  isXMLNS = (XML_Bool )tmp___0;
#line 3129
  if ((int )mustBeXML != (int )isXML) {
#line 3130
    if (mustBeXML) {
#line 3130
      tmp___1 = 38;
    } else {
#line 3130
      tmp___1 = 40;
    }
#line 3130
    return ((enum XML_Error )tmp___1);
  }
#line 3133
  if (isXMLNS) {
#line 3134
    return ((enum XML_Error )40);
  }
#line 3136
  if (parser->m_namespaceSeparator) {
#line 3137
    len ++;
  }
#line 3138
  if (parser->m_freeBindingList) {
#line 3139
    b = parser->m_freeBindingList;
#line 3140
    if (len > b->uriAlloc) {
      {
#line 3141
      tmp___2 = (*(parser->m_mem.realloc_fcn))((void *)b->uri, sizeof(XML_Char ) * (unsigned long )(len + 24));
#line 3141
      temp = (XML_Char *)tmp___2;
      }
#line 3143
      if ((unsigned long )temp == (unsigned long )((void *)0)) {
#line 3144
        return ((enum XML_Error )1);
      }
#line 3145
      b->uri = temp;
#line 3146
      b->uriAlloc = len + 24;
    }
#line 3148
    parser->m_freeBindingList = b->nextTagBinding;
  } else {
    {
#line 3151
    tmp___3 = (*(parser->m_mem.malloc_fcn))(sizeof(BINDING ));
#line 3151
    b = (BINDING *)tmp___3;
    }
#line 3152
    if (! b) {
#line 3153
      return ((enum XML_Error )1);
    }
    {
#line 3154
    tmp___4 = (*(parser->m_mem.malloc_fcn))(sizeof(XML_Char ) * (unsigned long )(len + 24));
#line 3154
    b->uri = (XML_Char *)tmp___4;
    }
#line 3155
    if (! b->uri) {
      {
#line 3156
      (*(parser->m_mem.free_fcn))((void *)b);
      }
#line 3157
      return ((enum XML_Error )1);
    }
#line 3159
    b->uriAlloc = len + 24;
  }
  {
#line 3161
  b->uriLen = len;
#line 3162
  memcpy((void */* __restrict  */)b->uri, (void const   */* __restrict  */)uri, (unsigned long )len * sizeof(XML_Char ));
  }
#line 3163
  if (parser->m_namespaceSeparator) {
#line 3164
    *(b->uri + (len - 1)) = parser->m_namespaceSeparator;
  }
#line 3165
  b->prefix = prefix;
#line 3166
  b->attId = attId;
#line 3167
  b->prevPrefixBinding = prefix->binding;
#line 3169
  if ((int const   )*uri == 0) {
#line 3169
    if ((unsigned long )prefix == (unsigned long )(& (parser->m_dtd)->defaultPrefix)) {
#line 3170
      prefix->binding = (BINDING *)((void *)0);
    } else {
#line 3172
      prefix->binding = b;
    }
  } else {
#line 3172
    prefix->binding = b;
  }
#line 3173
  b->nextTagBinding = *bindingsPtr;
#line 3174
  *bindingsPtr = b;
#line 3176
  if (attId) {
#line 3176
    if (parser->m_startNamespaceDeclHandler) {
#line 3177
      if (prefix->binding) {
#line 3177
        tmp___5 = uri;
      } else {
#line 3177
        tmp___5 = (XML_Char const   *)0;
      }
      {
#line 3177
      (*(parser->m_startNamespaceDeclHandler))(parser->m_handlerArg, prefix->name,
                                               tmp___5);
      }
    }
  }
#line 3179
  return ((enum XML_Error )0);
}
}
#line 3185 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlparse.c"
static enum XML_Error cdataSectionProcessor(XML_Parser parser , char const   *start ,
                                            char const   *end , char const   **endPtr ) 
{ 
  enum XML_Error result ;
  enum XML_Error tmp ;
  enum XML_Error tmp___0 ;
  enum XML_Error tmp___1 ;

  {
  {
#line 3191
  tmp = doCdataSection(parser, parser->m_encoding, & start, end, endPtr, (XML_Bool )(! parser->m_parsingStatus.finalBuffer));
#line 3191
  result = tmp;
  }
#line 3193
  if ((unsigned int )result != 0U) {
#line 3194
    return (result);
  }
#line 3195
  if (start) {
#line 3196
    if (parser->m_parentParser) {
      {
#line 3197
      parser->m_processor = & externalEntityContentProcessor;
#line 3198
      tmp___0 = externalEntityContentProcessor(parser, start, end, endPtr);
      }
#line 3198
      return (tmp___0);
    } else {
      {
#line 3201
      parser->m_processor = & contentProcessor;
#line 3202
      tmp___1 = contentProcessor(parser, start, end, endPtr);
      }
#line 3202
      return (tmp___1);
    }
  }
#line 3205
  return (result);
}
}
#line 3211 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlparse.c"
static enum XML_Error doCdataSection(XML_Parser parser , ENCODING const   *enc , char const   **startPtr ,
                                     char const   *end , char const   **nextPtr ,
                                     XML_Bool haveMore ) 
{ 
  char const   *s ;
  char const   **eventPP ;
  char const   **eventEndPP ;
  char const   *next ;
  int tok ;
  int tmp ;
  XML_Char c___0 ;
  void (*charDataHandler)(void *userData , XML_Char const   *s , int len ) ;
  ICHAR *dataPtr ;

  {
#line 3219
  s = *startPtr;
#line 3222
  if ((unsigned long )enc == (unsigned long )parser->m_encoding) {
#line 3223
    eventPP = & parser->m_eventPtr;
#line 3224
    *eventPP = s;
#line 3225
    eventEndPP = & parser->m_eventEndPtr;
  } else {
#line 3228
    eventPP = & (parser->m_openInternalEntities)->internalEventPtr;
#line 3229
    eventEndPP = & (parser->m_openInternalEntities)->internalEventEndPtr;
  }
#line 3231
  *eventPP = s;
#line 3232
  *startPtr = (char const   *)((void *)0);
  {
#line 3234
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 3236
    tmp = (*(enc->scanners[2]))(enc, s, end, & next);
#line 3236
    tok = tmp;
#line 3237
    *eventEndPP = next;
    }
    {
#line 3239
    if (tok == 40) {
#line 3239
      goto case_40;
    }
#line 3255
    if (tok == 7) {
#line 3255
      goto case_7;
    }
#line 3263
    if (tok == 6) {
#line 3263
      goto case_6;
    }
#line 3288
    if (tok == 0) {
#line 3288
      goto case_0;
    }
#line 3291
    if (tok == -2) {
#line 3291
      goto case_neg_2;
    }
#line 3298
    if (tok == -4) {
#line 3298
      goto case_neg_4;
    }
#line 3298
    if (tok == -1) {
#line 3298
      goto case_neg_4;
    }
#line 3304
    goto switch_default;
    case_40: /* CIL Label */ 
#line 3240
    if (parser->m_endCdataSectionHandler) {
      {
#line 3241
      (*(parser->m_endCdataSectionHandler))(parser->m_handlerArg);
      }
    } else
#line 3247
    if (parser->m_defaultHandler) {
      {
#line 3248
      reportDefault(parser, enc, s, next);
      }
    }
#line 3249
    *startPtr = next;
#line 3250
    *nextPtr = next;
#line 3251
    if ((unsigned int )parser->m_parsingStatus.parsing == 2U) {
#line 3252
      return ((enum XML_Error )35);
    } else {
#line 3254
      return ((enum XML_Error )0);
    }
    case_7: /* CIL Label */ 
#line 3256
    if (parser->m_characterDataHandler) {
      {
#line 3257
      c___0 = (XML_Char )10;
#line 3258
      (*(parser->m_characterDataHandler))(parser->m_handlerArg, (XML_Char const   *)(& c___0),
                                          1);
      }
    } else
#line 3260
    if (parser->m_defaultHandler) {
      {
#line 3261
      reportDefault(parser, enc, s, next);
      }
    }
#line 3262
    goto switch_break;
    case_6: /* CIL Label */ 
#line 3265
    charDataHandler = parser->m_characterDataHandler;
#line 3266
    if (charDataHandler) {
#line 3267
      if (! enc->isUtf8) {
        {
#line 3268
        while (1) {
          while_continue___0: /* CIL Label */ ;
          {
#line 3269
          dataPtr = parser->m_dataBuf;
#line 3270
          (*(enc->utf8Convert))(enc, & s, next, & dataPtr, (char const   *)parser->m_dataBufEnd);
#line 3271
          *eventEndPP = next;
#line 3272
          (*charDataHandler)(parser->m_handlerArg, (XML_Char const   *)parser->m_dataBuf,
                             (int )(dataPtr - parser->m_dataBuf));
          }
#line 3274
          if ((unsigned long )s == (unsigned long )next) {
#line 3275
            goto while_break___0;
          }
#line 3276
          *eventPP = s;
        }
        while_break___0: /* CIL Label */ ;
        }
      } else {
        {
#line 3280
        (*charDataHandler)(parser->m_handlerArg, (XML_Char const   *)((XML_Char *)s),
                           (int )((XML_Char *)next - (XML_Char *)s));
        }
      }
    } else
#line 3284
    if (parser->m_defaultHandler) {
      {
#line 3285
      reportDefault(parser, enc, s, next);
      }
    }
#line 3287
    goto switch_break;
    case_0: /* CIL Label */ 
#line 3289
    *eventPP = next;
#line 3290
    return ((enum XML_Error )4);
    case_neg_2: /* CIL Label */ 
#line 3292
    if (haveMore) {
#line 3293
      *nextPtr = s;
#line 3294
      return ((enum XML_Error )0);
    }
#line 3296
    return ((enum XML_Error )6);
    case_neg_4: /* CIL Label */ 
    case_neg_1: /* CIL Label */ 
#line 3299
    if (haveMore) {
#line 3300
      *nextPtr = s;
#line 3301
      return ((enum XML_Error )0);
    }
#line 3303
    return ((enum XML_Error )20);
    switch_default: /* CIL Label */ 
#line 3305
    *eventPP = next;
#line 3306
    return ((enum XML_Error )23);
    switch_break: /* CIL Label */ ;
    }
#line 3309
    s = next;
#line 3309
    *eventPP = s;
    {
#line 3311
    if ((unsigned int )parser->m_parsingStatus.parsing == 3U) {
#line 3311
      goto case_3;
    }
#line 3314
    if ((unsigned int )parser->m_parsingStatus.parsing == 2U) {
#line 3314
      goto case_2;
    }
#line 3316
    goto switch_default___0;
    case_3: /* CIL Label */ 
#line 3312
    *nextPtr = next;
#line 3313
    return ((enum XML_Error )0);
    case_2: /* CIL Label */ 
#line 3315
    return ((enum XML_Error )35);
    switch_default___0: /* CIL Label */ ;
    switch_break___0: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 3327 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlparse.c"
static enum XML_Error ignoreSectionProcessor(XML_Parser parser , char const   *start ,
                                             char const   *end , char const   **endPtr ) 
{ 
  enum XML_Error result ;
  enum XML_Error tmp ;
  enum XML_Error tmp___0 ;

  {
  {
#line 3333
  tmp = doIgnoreSection(parser, parser->m_encoding, & start, end, endPtr, (XML_Bool )(! parser->m_parsingStatus.finalBuffer));
#line 3333
  result = tmp;
  }
#line 3335
  if ((unsigned int )result != 0U) {
#line 3336
    return (result);
  }
#line 3337
  if (start) {
    {
#line 3338
    parser->m_processor = & prologProcessor;
#line 3339
    tmp___0 = prologProcessor(parser, start, end, endPtr);
    }
#line 3339
    return (tmp___0);
  }
#line 3341
  return (result);
}
}
#line 3347 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlparse.c"
static enum XML_Error doIgnoreSection(XML_Parser parser , ENCODING const   *enc ,
                                      char const   **startPtr , char const   *end ,
                                      char const   **nextPtr , XML_Bool haveMore ) 
{ 
  char const   *next ;
  int tok ;
  char const   *s ;
  char const   **eventPP ;
  char const   **eventEndPP ;

  {
#line 3357
  s = *startPtr;
#line 3360
  if ((unsigned long )enc == (unsigned long )parser->m_encoding) {
#line 3361
    eventPP = & parser->m_eventPtr;
#line 3362
    *eventPP = s;
#line 3363
    eventEndPP = & parser->m_eventEndPtr;
  } else {
#line 3366
    eventPP = & (parser->m_openInternalEntities)->internalEventPtr;
#line 3367
    eventEndPP = & (parser->m_openInternalEntities)->internalEventEndPtr;
  }
  {
#line 3369
  *eventPP = s;
#line 3370
  *startPtr = (char const   *)((void *)0);
#line 3371
  tok = (*(enc->scanners[3]))(enc, s, end, & next);
#line 3372
  *eventEndPP = next;
  }
  {
#line 3374
  if (tok == 42) {
#line 3374
    goto case_42;
  }
#line 3383
  if (tok == 0) {
#line 3383
    goto case_0;
  }
#line 3386
  if (tok == -2) {
#line 3386
    goto case_neg_2;
  }
#line 3393
  if (tok == -4) {
#line 3393
    goto case_neg_4;
  }
#line 3393
  if (tok == -1) {
#line 3393
    goto case_neg_4;
  }
#line 3399
  goto switch_default;
  case_42: /* CIL Label */ 
#line 3375
  if (parser->m_defaultHandler) {
    {
#line 3376
    reportDefault(parser, enc, s, next);
    }
  }
#line 3377
  *startPtr = next;
#line 3378
  *nextPtr = next;
#line 3379
  if ((unsigned int )parser->m_parsingStatus.parsing == 2U) {
#line 3380
    return ((enum XML_Error )35);
  } else {
#line 3382
    return ((enum XML_Error )0);
  }
  case_0: /* CIL Label */ 
#line 3384
  *eventPP = next;
#line 3385
  return ((enum XML_Error )4);
  case_neg_2: /* CIL Label */ 
#line 3387
  if (haveMore) {
#line 3388
    *nextPtr = s;
#line 3389
    return ((enum XML_Error )0);
  }
#line 3391
  return ((enum XML_Error )6);
  case_neg_4: /* CIL Label */ 
  case_neg_1: /* CIL Label */ 
#line 3394
  if (haveMore) {
#line 3395
    *nextPtr = s;
#line 3396
    return ((enum XML_Error )0);
  }
#line 3398
  return ((enum XML_Error )2);
  switch_default: /* CIL Label */ 
#line 3400
  *eventPP = next;
#line 3401
  return ((enum XML_Error )23);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 3408 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlparse.c"
static enum XML_Error initializeEncoding(XML_Parser parser ) 
{ 
  char const   *s ;
  int (*tmp)(INIT_ENCODING * , ENCODING const   ** , char const   *name ) ;
  int tmp___0 ;
  enum XML_Error tmp___1 ;

  {
#line 3430
  s = parser->m_protocolEncodingName;
#line 3432
  if (parser->m_ns) {
#line 3432
    tmp = & XmlInitEncodingNS;
  } else {
#line 3432
    tmp = & XmlInitEncoding;
  }
  {
#line 3432
  tmp___0 = (*tmp)(& parser->m_initEncoding, & parser->m_encoding, s);
  }
#line 3432
  if (tmp___0) {
#line 3433
    return ((enum XML_Error )0);
  }
  {
#line 3434
  tmp___1 = handleUnknownEncoding(parser, parser->m_protocolEncodingName);
  }
#line 3434
  return (tmp___1);
}
}
#line 3437 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlparse.c"
static enum XML_Error processXmlDecl(XML_Parser parser , int isGeneralTextEntity ,
                                     char const   *s , char const   *next ) 
{ 
  char const   *encodingName ;
  XML_Char const   *storedEncName ;
  ENCODING const   *newEncoding ;
  char const   *version ;
  char const   *versionend ;
  XML_Char const   *storedversion ;
  int standalone ;
  int (*tmp)(int isGeneralTextEntity , ENCODING const   *enc , char const   *ptr ,
             char const   *end , char const   **badPtr , char const   **versionPtr ,
             char const   **versionEndPtr , char const   **encodingNamePtr , ENCODING const   **namedEncodingPtr ,
             int *standalonePtr ) ;
  int tmp___0 ;
  int tmp___1 ;
  XML_Char *tmp___2 ;
  XML_Char *tmp___3 ;
  enum XML_Error result ;
  int tmp___4 ;
  XML_Char *tmp___5 ;

  {
#line 3441
  encodingName = (char const   *)((void *)0);
#line 3442
  storedEncName = (XML_Char const   *)((void *)0);
#line 3443
  newEncoding = (ENCODING const   *)((void *)0);
#line 3444
  version = (char const   *)((void *)0);
#line 3446
  storedversion = (XML_Char const   *)((void *)0);
#line 3447
  standalone = -1;
#line 3448
  if (parser->m_ns) {
#line 3448
    tmp = & XmlParseXmlDeclNS;
  } else {
#line 3448
    tmp = & XmlParseXmlDecl;
  }
  {
#line 3448
  tmp___0 = (*tmp)(isGeneralTextEntity, parser->m_encoding, s, next, & parser->m_eventPtr,
                   & version, & versionend, & encodingName, & newEncoding, & standalone);
  }
#line 3448
  if (! tmp___0) {
#line 3460
    if (isGeneralTextEntity) {
#line 3461
      return ((enum XML_Error )31);
    } else {
#line 3463
      return ((enum XML_Error )30);
    }
  }
#line 3465
  if (! isGeneralTextEntity) {
#line 3465
    if (standalone == 1) {
#line 3466
      (parser->m_dtd)->standalone = (XML_Bool )1;
#line 3468
      if ((unsigned int )parser->m_paramEntityParsing == 1U) {
#line 3469
        parser->m_paramEntityParsing = (enum XML_ParamEntityParsing )0;
      }
    }
  }
#line 3472
  if (parser->m_xmlDeclHandler) {
#line 3473
    if ((unsigned long )encodingName != (unsigned long )((void *)0)) {
      {
#line 3474
      tmp___1 = (*((parser->m_encoding)->nameLength))(parser->m_encoding, encodingName);
#line 3474
      tmp___2 = poolStoreString(& parser->m_temp2Pool, parser->m_encoding, encodingName,
                                encodingName + tmp___1);
#line 3474
      storedEncName = (XML_Char const   *)tmp___2;
      }
#line 3479
      if (! storedEncName) {
#line 3480
        return ((enum XML_Error )1);
      }
#line 3481
      parser->m_temp2Pool.start = parser->m_temp2Pool.ptr;
    }
#line 3483
    if (version) {
      {
#line 3484
      tmp___3 = poolStoreString(& parser->m_temp2Pool, parser->m_encoding, version,
                                versionend - (parser->m_encoding)->minBytesPerChar);
#line 3484
      storedversion = (XML_Char const   *)tmp___3;
      }
#line 3488
      if (! storedversion) {
#line 3489
        return ((enum XML_Error )1);
      }
    }
    {
#line 3491
    (*(parser->m_xmlDeclHandler))(parser->m_handlerArg, storedversion, storedEncName,
                                  standalone);
    }
  } else
#line 3493
  if (parser->m_defaultHandler) {
    {
#line 3494
    reportDefault(parser, parser->m_encoding, s, next);
    }
  }
#line 3495
  if ((unsigned long )parser->m_protocolEncodingName == (unsigned long )((void *)0)) {
#line 3496
    if (newEncoding) {
#line 3497
      if (newEncoding->minBytesPerChar != (parser->m_encoding)->minBytesPerChar) {
#line 3498
        parser->m_eventPtr = encodingName;
#line 3499
        return ((enum XML_Error )19);
      }
#line 3501
      parser->m_encoding = newEncoding;
    } else
#line 3503
    if (encodingName) {
#line 3505
      if (! storedEncName) {
        {
#line 3506
        tmp___4 = (*((parser->m_encoding)->nameLength))(parser->m_encoding, encodingName);
#line 3506
        tmp___5 = poolStoreString(& parser->m_temp2Pool, parser->m_encoding, encodingName,
                                  encodingName + tmp___4);
#line 3506
        storedEncName = (XML_Char const   *)tmp___5;
        }
#line 3509
        if (! storedEncName) {
#line 3510
          return ((enum XML_Error )1);
        }
      }
      {
#line 3512
      result = handleUnknownEncoding(parser, storedEncName);
#line 3513
      poolClear(& parser->m_temp2Pool);
      }
#line 3514
      if ((unsigned int )result == 18U) {
#line 3515
        parser->m_eventPtr = encodingName;
      }
#line 3516
      return (result);
    }
  }
#line 3520
  if (storedEncName) {
    {
#line 3521
    poolClear(& parser->m_temp2Pool);
    }
  } else
#line 3520
  if (storedversion) {
    {
#line 3521
    poolClear(& parser->m_temp2Pool);
    }
  }
#line 3523
  return ((enum XML_Error )0);
}
}
#line 3526 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlparse.c"
static enum XML_Error handleUnknownEncoding(XML_Parser parser , XML_Char const   *encodingName ) 
{ 
  XML_Encoding info ;
  int i ;
  ENCODING *enc ;
  int tmp ;
  ENCODING *(*tmp___0)(void *mem , int *table , int (*convert)(void *userData , char const   *p ) ,
                       void *userData ) ;
  int tmp___1 ;

  {
#line 3529
  if (parser->m_unknownEncodingHandler) {
#line 3532
    i = 0;
    {
#line 3532
    while (1) {
      while_continue: /* CIL Label */ ;
#line 3532
      if (! (i < 256)) {
#line 3532
        goto while_break;
      }
#line 3533
      info.map[i] = -1;
#line 3532
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 3534
    info.convert = (int (*)(void *data , char const   *s ))((void *)0);
#line 3535
    info.data = (void *)0;
#line 3536
    info.release = (void (*)(void *data ))((void *)0);
#line 3537
    tmp___1 = (*(parser->m_unknownEncodingHandler))(parser->m_unknownEncodingHandlerData,
                                                    encodingName, & info);
    }
#line 3537
    if (tmp___1) {
      {
#line 3540
      tmp = XmlSizeOfUnknownEncoding();
#line 3540
      parser->m_unknownEncodingMem = (*(parser->m_mem.malloc_fcn))((size_t )tmp);
      }
#line 3541
      if (! parser->m_unknownEncodingMem) {
#line 3542
        if (info.release) {
          {
#line 3543
          (*(info.release))(info.data);
          }
        }
#line 3544
        return ((enum XML_Error )1);
      }
#line 3546
      if (parser->m_ns) {
#line 3546
        tmp___0 = & XmlInitUnknownEncodingNS;
      } else {
#line 3546
        tmp___0 = & XmlInitUnknownEncoding;
      }
      {
#line 3546
      enc = (*tmp___0)(parser->m_unknownEncodingMem, info.map, info.convert, info.data);
      }
#line 3552
      if (enc) {
#line 3553
        parser->m_unknownEncodingData = info.data;
#line 3554
        parser->m_unknownEncodingRelease = info.release;
#line 3555
        parser->m_encoding = (ENCODING const   *)enc;
#line 3556
        return ((enum XML_Error )0);
      }
    }
#line 3559
    if ((unsigned long )info.release != (unsigned long )((void *)0)) {
      {
#line 3560
      (*(info.release))(info.data);
      }
    }
  }
#line 3562
  return ((enum XML_Error )18);
}
}
#line 3565 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlparse.c"
static enum XML_Error prologInitProcessor(XML_Parser parser , char const   *s , char const   *end ,
                                          char const   **nextPtr ) 
{ 
  enum XML_Error result ;
  enum XML_Error tmp ;
  enum XML_Error tmp___0 ;

  {
  {
#line 3571
  tmp = initializeEncoding(parser);
#line 3571
  result = tmp;
  }
#line 3572
  if ((unsigned int )result != 0U) {
#line 3573
    return (result);
  }
  {
#line 3574
  parser->m_processor = & prologProcessor;
#line 3575
  tmp___0 = prologProcessor(parser, s, end, nextPtr);
  }
#line 3575
  return (tmp___0);
}
}
#line 3580 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlparse.c"
static enum XML_Error externalParEntInitProcessor(XML_Parser parser , char const   *s ,
                                                  char const   *end , char const   **nextPtr ) 
{ 
  enum XML_Error result ;
  enum XML_Error tmp ;
  enum XML_Error tmp___0 ;
  enum XML_Error tmp___1 ;

  {
  {
#line 3586
  tmp = initializeEncoding(parser);
#line 3586
  result = tmp;
  }
#line 3587
  if ((unsigned int )result != 0U) {
#line 3588
    return (result);
  }
#line 3592
  (parser->m_dtd)->paramEntityRead = (XML_Bool )1;
#line 3594
  if (parser->m_prologState.inEntityValue) {
    {
#line 3595
    parser->m_processor = & entityValueInitProcessor;
#line 3596
    tmp___0 = entityValueInitProcessor(parser, s, end, nextPtr);
    }
#line 3596
    return (tmp___0);
  } else {
    {
#line 3599
    parser->m_processor = & externalParEntProcessor;
#line 3600
    tmp___1 = externalParEntProcessor(parser, s, end, nextPtr);
    }
#line 3600
    return (tmp___1);
  }
}
}
#line 3604 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlparse.c"
static enum XML_Error entityValueInitProcessor(XML_Parser parser , char const   *s ,
                                               char const   *end , char const   **nextPtr ) 
{ 
  int tok ;
  char const   *start ;
  char const   *next ;
  enum XML_Error tmp ;
  enum XML_Error result ;
  enum XML_Error tmp___0 ;

  {
#line 3611
  start = s;
#line 3612
  next = start;
#line 3613
  parser->m_eventPtr = start;
  {
#line 3615
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 3616
    tok = (*((parser->m_encoding)->scanners[0]))(parser->m_encoding, start, end, & next);
#line 3617
    parser->m_eventEndPtr = next;
    }
#line 3618
    if (tok <= 0) {
#line 3619
      if (! parser->m_parsingStatus.finalBuffer) {
#line 3619
        if (tok != 0) {
#line 3620
          *nextPtr = s;
#line 3621
          return ((enum XML_Error )0);
        }
      }
      {
#line 3624
      if (tok == 0) {
#line 3624
        goto case_0;
      }
#line 3626
      if (tok == -1) {
#line 3626
        goto case_neg_1;
      }
#line 3628
      if (tok == -2) {
#line 3628
        goto case_neg_2;
      }
#line 3631
      goto switch_default;
      case_0: /* CIL Label */ 
#line 3625
      return ((enum XML_Error )4);
      case_neg_1: /* CIL Label */ 
#line 3627
      return ((enum XML_Error )5);
      case_neg_2: /* CIL Label */ 
#line 3629
      return ((enum XML_Error )6);
      switch_default: /* CIL Label */ 
#line 3632
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
      {
#line 3635
      tmp = storeEntityValue(parser, parser->m_encoding, s, end);
      }
#line 3635
      return (tmp);
    } else
#line 3637
    if (tok == 12) {
      {
#line 3639
      result = processXmlDecl(parser, 0, start, next);
      }
#line 3640
      if ((unsigned int )result != 0U) {
#line 3641
        return (result);
      }
      {
#line 3643
      if ((unsigned int )parser->m_parsingStatus.parsing == 3U) {
#line 3643
        goto case_3;
      }
#line 3646
      if ((unsigned int )parser->m_parsingStatus.parsing == 2U) {
#line 3646
        goto case_2;
      }
#line 3648
      goto switch_default___0;
      case_3: /* CIL Label */ 
#line 3644
      *nextPtr = next;
#line 3645
      return ((enum XML_Error )0);
      case_2: /* CIL Label */ 
#line 3647
      return ((enum XML_Error )35);
      switch_default___0: /* CIL Label */ 
#line 3649
      *nextPtr = next;
      switch_break___0: /* CIL Label */ ;
      }
      {
#line 3652
      parser->m_processor = & entityValueProcessor;
#line 3653
      tmp___0 = entityValueProcessor(parser, next, end, nextPtr);
      }
#line 3653
      return (tmp___0);
    } else
#line 3662
    if (tok == 14) {
#line 3662
      if ((unsigned long )next == (unsigned long )end) {
#line 3662
        if (! parser->m_parsingStatus.finalBuffer) {
#line 3663
          *nextPtr = next;
#line 3664
          return ((enum XML_Error )0);
        }
      }
    }
#line 3666
    start = next;
#line 3667
    parser->m_eventPtr = start;
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 3671 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlparse.c"
static enum XML_Error externalParEntProcessor(XML_Parser parser , char const   *s ,
                                              char const   *end , char const   **nextPtr ) 
{ 
  char const   *next ;
  int tok ;
  enum XML_Error tmp ;

  {
  {
#line 3677
  next = s;
#line 3680
  tok = (*((parser->m_encoding)->scanners[0]))(parser->m_encoding, s, end, & next);
  }
#line 3681
  if (tok <= 0) {
#line 3682
    if (! parser->m_parsingStatus.finalBuffer) {
#line 3682
      if (tok != 0) {
#line 3683
        *nextPtr = s;
#line 3684
        return ((enum XML_Error )0);
      }
    }
    {
#line 3687
    if (tok == 0) {
#line 3687
      goto case_0;
    }
#line 3689
    if (tok == -1) {
#line 3689
      goto case_neg_1;
    }
#line 3691
    if (tok == -2) {
#line 3691
      goto case_neg_2;
    }
#line 3694
    goto switch_default;
    case_0: /* CIL Label */ 
#line 3688
    return ((enum XML_Error )4);
    case_neg_1: /* CIL Label */ 
#line 3690
    return ((enum XML_Error )5);
    case_neg_2: /* CIL Label */ 
#line 3692
    return ((enum XML_Error )6);
    switch_default: /* CIL Label */ 
#line 3695
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  } else
#line 3702
  if (tok == 14) {
    {
#line 3703
    s = next;
#line 3704
    tok = (*((parser->m_encoding)->scanners[0]))(parser->m_encoding, s, end, & next);
    }
  }
  {
#line 3707
  parser->m_processor = & prologProcessor;
#line 3708
  tmp = doProlog(parser, parser->m_encoding, s, end, tok, next, nextPtr, (XML_Bool )(! parser->m_parsingStatus.finalBuffer));
  }
#line 3708
  return (tmp);
}
}
#line 3712 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlparse.c"
static enum XML_Error entityValueProcessor(XML_Parser parser , char const   *s , char const   *end ,
                                           char const   **nextPtr ) 
{ 
  char const   *start ;
  char const   *next ;
  ENCODING const   *enc ;
  int tok ;
  enum XML_Error tmp ;

  {
#line 3718
  start = s;
#line 3719
  next = s;
#line 3720
  enc = parser->m_encoding;
  {
#line 3723
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 3724
    tok = (*(enc->scanners[0]))(enc, start, end, & next);
    }
#line 3725
    if (tok <= 0) {
#line 3726
      if (! parser->m_parsingStatus.finalBuffer) {
#line 3726
        if (tok != 0) {
#line 3727
          *nextPtr = s;
#line 3728
          return ((enum XML_Error )0);
        }
      }
      {
#line 3731
      if (tok == 0) {
#line 3731
        goto case_0;
      }
#line 3733
      if (tok == -1) {
#line 3733
        goto case_neg_1;
      }
#line 3735
      if (tok == -2) {
#line 3735
        goto case_neg_2;
      }
#line 3738
      goto switch_default;
      case_0: /* CIL Label */ 
#line 3732
      return ((enum XML_Error )4);
      case_neg_1: /* CIL Label */ 
#line 3734
      return ((enum XML_Error )5);
      case_neg_2: /* CIL Label */ 
#line 3736
      return ((enum XML_Error )6);
      switch_default: /* CIL Label */ 
#line 3739
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
      {
#line 3742
      tmp = storeEntityValue(parser, enc, s, end);
      }
#line 3742
      return (tmp);
    }
#line 3744
    start = next;
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 3750 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlparse.c"
static enum XML_Error prologProcessor(XML_Parser parser , char const   *s , char const   *end ,
                                      char const   **nextPtr ) 
{ 
  char const   *next ;
  int tok ;
  int tmp ;
  enum XML_Error tmp___0 ;

  {
  {
#line 3756
  next = s;
#line 3757
  tmp = (*((parser->m_encoding)->scanners[0]))(parser->m_encoding, s, end, & next);
#line 3757
  tok = tmp;
#line 3758
  tmp___0 = doProlog(parser, parser->m_encoding, s, end, tok, next, nextPtr, (XML_Bool )(! parser->m_parsingStatus.finalBuffer));
  }
#line 3758
  return (tmp___0);
}
}
#line 3773 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlparse.c"
static XML_Char const   externalSubsetName[2]  = {      (XML_Char const   )35,      (XML_Char const   )'\000'};
#line 3775 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlparse.c"
static XML_Char const   atypeCDATA[6]  = {      (XML_Char const   )67,      (XML_Char const   )68,      (XML_Char const   )65,      (XML_Char const   )84, 
        (XML_Char const   )65,      (XML_Char const   )'\000'};
#line 3777 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlparse.c"
static XML_Char const   atypeID[3]  = {      (XML_Char const   )73,      (XML_Char const   )68,      (XML_Char const   )'\000'};
#line 3778 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlparse.c"
static XML_Char const   atypeIDREF[6]  = {      (XML_Char const   )73,      (XML_Char const   )68,      (XML_Char const   )82,      (XML_Char const   )69, 
        (XML_Char const   )70,      (XML_Char const   )'\000'};
#line 3780 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlparse.c"
static XML_Char const   atypeIDREFS[7]  = {      (XML_Char const   )73,      (XML_Char const   )68,      (XML_Char const   )82,      (XML_Char const   )69, 
        (XML_Char const   )70,      (XML_Char const   )83,      (XML_Char const   )'\000'};
#line 3782 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlparse.c"
static XML_Char const   atypeENTITY[7]  = {      (XML_Char const   )69,      (XML_Char const   )78,      (XML_Char const   )84,      (XML_Char const   )73, 
        (XML_Char const   )84,      (XML_Char const   )89,      (XML_Char const   )'\000'};
#line 3784 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlparse.c"
static XML_Char const   atypeENTITIES[9]  = 
#line 3784
  {      (XML_Char const   )69,      (XML_Char const   )78,      (XML_Char const   )84,      (XML_Char const   )73, 
        (XML_Char const   )84,      (XML_Char const   )73,      (XML_Char const   )69,      (XML_Char const   )83, 
        (XML_Char const   )'\000'};
#line 3786 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlparse.c"
static XML_Char const   atypeNMTOKEN[8]  = 
#line 3786
  {      (XML_Char const   )78,      (XML_Char const   )77,      (XML_Char const   )84,      (XML_Char const   )79, 
        (XML_Char const   )75,      (XML_Char const   )69,      (XML_Char const   )78,      (XML_Char const   )'\000'};
#line 3788 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlparse.c"
static XML_Char const   atypeNMTOKENS[9]  = 
#line 3788
  {      (XML_Char const   )78,      (XML_Char const   )77,      (XML_Char const   )84,      (XML_Char const   )79, 
        (XML_Char const   )75,      (XML_Char const   )69,      (XML_Char const   )78,      (XML_Char const   )83, 
        (XML_Char const   )'\000'};
#line 3790 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlparse.c"
static XML_Char const   notationPrefix[10]  = 
#line 3790
  {      (XML_Char const   )78,      (XML_Char const   )79,      (XML_Char const   )84,      (XML_Char const   )65, 
        (XML_Char const   )84,      (XML_Char const   )73,      (XML_Char const   )79,      (XML_Char const   )78, 
        (XML_Char const   )40,      (XML_Char const   )'\000'};
#line 3792 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlparse.c"
static XML_Char const   enumValueSep[2]  = {      (XML_Char const   )124,      (XML_Char const   )'\000'};
#line 3793 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlparse.c"
static XML_Char const   enumValueStart[2]  = {      (XML_Char const   )40,      (XML_Char const   )'\000'};
#line 3762 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlparse.c"
static enum XML_Error doProlog(XML_Parser parser , ENCODING const   *enc , char const   *s ,
                               char const   *end , int tok , char const   *next ,
                               char const   **nextPtr , XML_Bool haveMore ) 
{ 
  DTD *dtd ;
  char const   **eventPP ;
  char const   **eventEndPP ;
  enum XML_Content_Quant quant ;
  int role ;
  XML_Bool handleDefault ;
  int tmp ;
  enum XML_Error result ;
  enum XML_Error tmp___0 ;
  XML_Char *tmp___1 ;
  enum XML_Error result___0 ;
  enum XML_Error tmp___2 ;
  NAMED *tmp___3 ;
  XML_Char *pubId ;
  int tmp___4 ;
  int tmp___5 ;
  XML_Char *tem ;
  XML_Char *tmp___6 ;
  XML_Bool hadParamEntityRefs ;
  ENTITY *entity ;
  NAMED *tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  XML_Bool hadParamEntityRefs___0 ;
  ENTITY *entity___0 ;
  NAMED *tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  enum XML_Error tmp___13 ;
  XML_Char const   *prefix ;
  XML_Char const   *tmp___14 ;
  XML_Char *tmp___15 ;
  int tmp___16 ;
  XML_Char *tmp___18 ;
  int tmp___19 ;
  XML_Bool tmp___20 ;
  XML_Char *tmp___22 ;
  int tmp___23 ;
  XML_Bool tmp___24 ;
  XML_Char const   *attVal ;
  enum XML_Error result___1 ;
  enum XML_Error tmp___25 ;
  int tmp___26 ;
  XML_Char *tmp___28 ;
  int tmp___29 ;
  XML_Bool tmp___30 ;
  XML_Char *tmp___32 ;
  int tmp___33 ;
  XML_Bool tmp___34 ;
  enum XML_Error result___2 ;
  enum XML_Error tmp___35 ;
  XML_Char *tmp___36 ;
  int tmp___37 ;
  NAMED *tmp___38 ;
  XML_Char *tmp___39 ;
  XML_Char *tmp___40 ;
  int tmp___41 ;
  XML_Char const   *name ;
  XML_Char *tmp___42 ;
  NAMED *tmp___43 ;
  int tmp___44 ;
  XML_Char const   *name___0 ;
  XML_Char *tmp___45 ;
  NAMED *tmp___46 ;
  int tmp___47 ;
  XML_Char *tmp___48 ;
  int tmp___49 ;
  XML_Char *tem___0 ;
  XML_Char *tmp___50 ;
  XML_Char const   *systemId ;
  XML_Char *tmp___51 ;
  enum XML_Error result___3 ;
  char *temp ;
  unsigned int tmp___52 ;
  void *tmp___53 ;
  int *temp___0 ;
  void *tmp___54 ;
  unsigned int tmp___55 ;
  void *tmp___56 ;
  int myindex ;
  int tmp___57 ;
  XML_Char const   *name___1 ;
  ENTITY *entity___1 ;
  XML_Char *tmp___58 ;
  NAMED *tmp___59 ;
  int tmp___60 ;
  enum XML_Error result___4 ;
  XML_Bool betweenDecl ;
  int tmp___61 ;
  int tmp___62 ;
  int tmp___63 ;
  XML_Content *content ;
  void *tmp___64 ;
  ELEMENT_TYPE *el ;
  XML_Char const   *name___2 ;
  int nameLen ;
  char const   *nxt ;
  char const   *tmp___65 ;
  int myindex___0 ;
  int tmp___66 ;
  int tmp___67 ;
  XML_Content *model ;
  XML_Content *tmp___68 ;
  int tmp___69 ;
  int tmp___70 ;

  {
#line 3796
  dtd = parser->m_dtd;
#line 3802
  if ((unsigned long )enc == (unsigned long )parser->m_encoding) {
#line 3803
    eventPP = & parser->m_eventPtr;
#line 3804
    eventEndPP = & parser->m_eventEndPtr;
  } else {
#line 3807
    eventPP = & (parser->m_openInternalEntities)->internalEventPtr;
#line 3808
    eventEndPP = & (parser->m_openInternalEntities)->internalEventEndPtr;
  }
  {
#line 3811
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3813
    handleDefault = (XML_Bool )1;
#line 3814
    *eventPP = s;
#line 3815
    *eventEndPP = next;
#line 3816
    if (tok <= 0) {
#line 3817
      if (haveMore) {
#line 3817
        if (tok != 0) {
#line 3818
          *nextPtr = s;
#line 3819
          return ((enum XML_Error )0);
        }
      }
      {
#line 3822
      if (tok == 0) {
#line 3822
        goto case_0;
      }
#line 3825
      if (tok == -1) {
#line 3825
        goto case_neg_1;
      }
#line 3827
      if (tok == -2) {
#line 3827
        goto case_neg_2;
      }
#line 3829
      if (tok == -15) {
#line 3829
        goto case_neg_15;
      }
#line 3832
      if (tok == -4) {
#line 3832
        goto case_neg_4;
      }
#line 3852
      goto switch_default;
      case_0: /* CIL Label */ 
#line 3823
      *eventPP = next;
#line 3824
      return ((enum XML_Error )4);
      case_neg_1: /* CIL Label */ 
#line 3826
      return ((enum XML_Error )5);
      case_neg_2: /* CIL Label */ 
#line 3828
      return ((enum XML_Error )6);
      case_neg_15: /* CIL Label */ 
#line 3830
      tok = - tok;
#line 3831
      goto switch_break;
      case_neg_4: /* CIL Label */ 
#line 3835
      if ((unsigned long )enc != (unsigned long )parser->m_encoding) {
#line 3835
        if (! (parser->m_openInternalEntities)->betweenDecl) {
#line 3836
          *nextPtr = s;
#line 3837
          return ((enum XML_Error )0);
        }
      }
#line 3843
      if (parser->m_isParamEntity) {
#line 3843
        goto _L;
      } else
#line 3843
      if ((unsigned long )enc != (unsigned long )parser->m_encoding) {
        _L: /* CIL Label */ 
        {
#line 3844
        tmp = (*(parser->m_prologState.handler))(& parser->m_prologState, -4, end,
                                                 end, enc);
        }
#line 3844
        if (tmp == -1) {
#line 3846
          return ((enum XML_Error )29);
        }
#line 3847
        *nextPtr = s;
#line 3848
        return ((enum XML_Error )0);
      }
#line 3851
      return ((enum XML_Error )3);
      switch_default: /* CIL Label */ 
#line 3853
      tok = - tok;
#line 3854
      next = end;
#line 3855
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    }
    {
#line 3858
    role = (*(parser->m_prologState.handler))(& parser->m_prologState, tok, s, next,
                                              enc);
    }
    {
#line 3860
    if (role == 1) {
#line 3860
      goto case_1;
    }
#line 3869
    if (role == 4) {
#line 3869
      goto case_4;
    }
#line 3880
    if (role == 7) {
#line 3880
      goto case_7;
    }
#line 3890
    if (role == 57) {
#line 3890
      goto case_57;
    }
#line 3900
    if (role == 6) {
#line 3900
      goto case_6;
    }
#line 3927
    if (role == 14) {
#line 3927
      goto case_14;
    }
#line 3945
    if (role == 8) {
#line 3945
      goto case_8;
    }
#line 3997
    if (role == 2) {
#line 3997
      goto case_2;
    }
#line 4036
    if (role == 34) {
#line 4036
      goto case_34;
    }
#line 4041
    if (role == 22) {
#line 4041
      goto case_22;
    }
#line 4049
    if (role == 23) {
#line 4049
      goto case_23;
    }
#line 4053
    if (role == 24) {
#line 4053
      goto case_24;
    }
#line 4057
    if (role == 25) {
#line 4057
      goto case_25;
    }
#line 4060
    if (role == 26) {
#line 4060
      goto case_26;
    }
#line 4063
    if (role == 27) {
#line 4063
      goto case_27;
    }
#line 4066
    if (role == 28) {
#line 4066
      goto case_28;
    }
#line 4069
    if (role == 29) {
#line 4069
      goto case_29;
    }
#line 4072
    if (role == 30) {
#line 4072
      goto case_30;
    }
#line 4079
    if (role == 32) {
#line 4079
      goto case_32;
    }
#line 4079
    if (role == 31) {
#line 4079
      goto case_32;
    }
#line 4099
    if (role == 36) {
#line 4099
      goto case_36;
    }
#line 4099
    if (role == 35) {
#line 4099
      goto case_36;
    }
#line 4126
    if (role == 38) {
#line 4126
      goto case_38;
    }
#line 4126
    if (role == 37) {
#line 4126
      goto case_38;
    }
#line 4163
    if (role == 12) {
#line 4163
      goto case_12;
    }
#line 4189
    if (role == 5) {
#line 4189
      goto case_5;
    }
#line 4230
    if (role == 13) {
#line 4230
      goto case_13;
    }
#line 4243
    if (role == 15) {
#line 4243
      goto case_15;
    }
#line 4257
    if (role == 16) {
#line 4257
      goto case_16;
    }
#line 4286
    if (role == 9) {
#line 4286
      goto case_9;
    }
#line 4322
    if (role == 10) {
#line 4322
      goto case_10;
    }
#line 4356
    if (role == 18) {
#line 4356
      goto case_18;
    }
#line 4367
    if (role == 21) {
#line 4367
      goto case_21;
    }
#line 4383
    if (role == 19) {
#line 4383
      goto case_19;
    }
#line 4401
    if (role == 20) {
#line 4401
      goto case_20;
    }
#line 4413
    if (role == -1) {
#line 4413
      goto case_neg_1___0;
    }
#line 4425
    if (role == 58) {
#line 4425
      goto case_58;
    }
#line 4441
    if (role == 44) {
#line 4441
      goto case_44;
    }
#line 4474
    if (role == 50) {
#line 4474
      goto case_50;
    }
#line 4481
    if (role == 49) {
#line 4481
      goto case_49;
    }
#line 4498
    if (role == 59) {
#line 4498
      goto case_59;
    }
#line 4498
    if (role == 60) {
#line 4498
      goto case_59;
    }
#line 4578
    if (role == 40) {
#line 4578
      goto case_40;
    }
#line 4591
    if (role == 42) {
#line 4591
      goto case_42;
    }
#line 4591
    if (role == 41) {
#line 4591
      goto case_42;
    }
#line 4612
    if (role == 43) {
#line 4612
      goto case_43;
    }
#line 4621
    if (role == 51) {
#line 4621
      goto case_51;
    }
#line 4624
    if (role == 53) {
#line 4624
      goto case_53;
    }
#line 4627
    if (role == 52) {
#line 4627
      goto case_52;
    }
#line 4630
    if (role == 54) {
#line 4630
      goto case_54;
    }
#line 4658
    if (role == 45) {
#line 4658
      goto case_45;
    }
#line 4661
    if (role == 47) {
#line 4661
      goto case_47;
    }
#line 4664
    if (role == 46) {
#line 4664
      goto case_46;
    }
#line 4667
    if (role == 48) {
#line 4667
      goto case_48;
    }
#line 4690
    if (role == 55) {
#line 4690
      goto case_55;
    }
#line 4695
    if (role == 56) {
#line 4695
      goto case_56;
    }
#line 4700
    if (role == 0) {
#line 4700
      goto case_0___0;
    }
#line 4707
    if (role == 3) {
#line 4707
      goto case_3;
    }
#line 4711
    if (role == 11) {
#line 4711
      goto case_11;
    }
#line 4715
    if (role == 17) {
#line 4715
      goto case_17;
    }
#line 4719
    if (role == 33) {
#line 4719
      goto case_33;
    }
#line 4723
    if (role == 39) {
#line 4723
      goto case_39;
    }
#line 3859
    goto switch_break___0;
    case_1: /* CIL Label */ 
    {
#line 3862
    tmp___0 = processXmlDecl(parser, 0, s, next);
#line 3862
    result = tmp___0;
    }
#line 3863
    if ((unsigned int )result != 0U) {
#line 3864
      return (result);
    }
#line 3865
    enc = parser->m_encoding;
#line 3866
    handleDefault = (XML_Bool )0;
#line 3868
    goto switch_break___0;
    case_4: /* CIL Label */ 
#line 3870
    if (parser->m_startDoctypeDeclHandler) {
      {
#line 3871
      tmp___1 = poolStoreString(& parser->m_tempPool, enc, s, next);
#line 3871
      parser->m_doctypeName = (XML_Char const   *)tmp___1;
      }
#line 3872
      if (! parser->m_doctypeName) {
#line 3873
        return ((enum XML_Error )1);
      }
#line 3874
      parser->m_tempPool.start = parser->m_tempPool.ptr;
#line 3875
      parser->m_doctypePubid = (XML_Char const   *)((void *)0);
#line 3876
      handleDefault = (XML_Bool )0;
    }
#line 3878
    parser->m_doctypeSysid = (XML_Char const   *)((void *)0);
#line 3879
    goto switch_break___0;
    case_7: /* CIL Label */ 
#line 3881
    if (parser->m_startDoctypeDeclHandler) {
      {
#line 3882
      (*(parser->m_startDoctypeDeclHandler))(parser->m_handlerArg, parser->m_doctypeName,
                                             parser->m_doctypeSysid, parser->m_doctypePubid,
                                             1);
#line 3884
      parser->m_doctypeName = (XML_Char const   *)((void *)0);
#line 3885
      poolClear(& parser->m_tempPool);
#line 3886
      handleDefault = (XML_Bool )0;
      }
    }
#line 3888
    goto switch_break___0;
    case_57: /* CIL Label */ 
    {
#line 3892
    tmp___2 = processXmlDecl(parser, 1, s, next);
#line 3892
    result___0 = tmp___2;
    }
#line 3893
    if ((unsigned int )result___0 != 0U) {
#line 3894
      return (result___0);
    }
#line 3895
    enc = parser->m_encoding;
#line 3896
    handleDefault = (XML_Bool )0;
#line 3898
    goto switch_break___0;
    case_6: /* CIL Label */ 
    {
#line 3902
    parser->m_useForeignDTD = (XML_Bool )0;
#line 3903
    tmp___3 = lookup(parser, & dtd->paramEntities, externalSubsetName, sizeof(ENTITY ));
#line 3903
    parser->m_declEntity = (ENTITY *)tmp___3;
    }
#line 3907
    if (! parser->m_declEntity) {
#line 3908
      return ((enum XML_Error )1);
    }
#line 3910
    dtd->hasParamEntityRefs = (XML_Bool )1;
#line 3911
    if (parser->m_startDoctypeDeclHandler) {
      {
#line 3913
      tmp___4 = (*(enc->isPublicId))(enc, s, next, eventPP);
      }
#line 3913
      if (! tmp___4) {
#line 3914
        return ((enum XML_Error )32);
      }
      {
#line 3915
      pubId = poolStoreString(& parser->m_tempPool, enc, s + enc->minBytesPerChar,
                              next - enc->minBytesPerChar);
      }
#line 3918
      if (! pubId) {
#line 3919
        return ((enum XML_Error )1);
      }
      {
#line 3920
      normalizePublicId(pubId);
#line 3921
      parser->m_tempPool.start = parser->m_tempPool.ptr;
#line 3922
      parser->m_doctypePubid = (XML_Char const   *)pubId;
#line 3923
      handleDefault = (XML_Bool )0;
      }
#line 3924
      goto alreadyChecked;
    }
    case_14: /* CIL Label */ 
    {
#line 3928
    tmp___5 = (*(enc->isPublicId))(enc, s, next, eventPP);
    }
#line 3928
    if (! tmp___5) {
#line 3929
      return ((enum XML_Error )32);
    }
    alreadyChecked: 
#line 3931
    if (dtd->keepProcessing) {
#line 3931
      if (parser->m_declEntity) {
        {
#line 3932
        tmp___6 = poolStoreString(& dtd->pool, enc, s + enc->minBytesPerChar, next - enc->minBytesPerChar);
#line 3932
        tem = tmp___6;
        }
#line 3936
        if (! tem) {
#line 3937
          return ((enum XML_Error )1);
        }
        {
#line 3938
        normalizePublicId(tem);
#line 3939
        (parser->m_declEntity)->publicId = (XML_Char const   *)tem;
#line 3940
        dtd->pool.start = dtd->pool.ptr;
        }
#line 3941
        if (parser->m_entityDeclHandler) {
#line 3942
          handleDefault = (XML_Bool )0;
        }
      }
    }
#line 3944
    goto switch_break___0;
    case_8: /* CIL Label */ 
#line 3946
    if (parser->m_doctypeName) {
      {
#line 3947
      (*(parser->m_startDoctypeDeclHandler))(parser->m_handlerArg, parser->m_doctypeName,
                                             parser->m_doctypeSysid, parser->m_doctypePubid,
                                             0);
#line 3949
      poolClear(& parser->m_tempPool);
#line 3950
      handleDefault = (XML_Bool )0;
      }
    }
#line 3957
    if (parser->m_doctypeSysid) {
#line 3957
      goto _L___0;
    } else
#line 3957
    if (parser->m_useForeignDTD) {
      _L___0: /* CIL Label */ 
#line 3958
      hadParamEntityRefs = dtd->hasParamEntityRefs;
#line 3959
      dtd->hasParamEntityRefs = (XML_Bool )1;
#line 3960
      if (parser->m_paramEntityParsing) {
#line 3960
        if (parser->m_externalEntityRefHandler) {
          {
#line 3961
          tmp___7 = lookup(parser, & dtd->paramEntities, externalSubsetName, sizeof(ENTITY ));
#line 3961
          entity = (ENTITY *)tmp___7;
          }
#line 3965
          if (! entity) {
#line 3966
            return ((enum XML_Error )1);
          }
#line 3967
          if (parser->m_useForeignDTD) {
#line 3968
            entity->base = parser->m_curBase;
          }
          {
#line 3969
          dtd->paramEntityRead = (XML_Bool )0;
#line 3970
          tmp___8 = (*(parser->m_externalEntityRefHandler))(parser->m_externalEntityRefHandlerArg,
                                                            (XML_Char const   *)0,
                                                            entity->base, entity->systemId,
                                                            entity->publicId);
          }
#line 3970
          if (! tmp___8) {
#line 3975
            return ((enum XML_Error )21);
          }
#line 3976
          if (dtd->paramEntityRead) {
#line 3977
            if (! dtd->standalone) {
#line 3977
              if (parser->m_notStandaloneHandler) {
                {
#line 3977
                tmp___9 = (*(parser->m_notStandaloneHandler))(parser->m_handlerArg);
                }
#line 3977
                if (! tmp___9) {
#line 3980
                  return ((enum XML_Error )22);
                }
              }
            }
          } else
#line 3985
          if (! parser->m_doctypeSysid) {
#line 3986
            dtd->hasParamEntityRefs = hadParamEntityRefs;
          }
        }
      }
#line 3989
      parser->m_useForeignDTD = (XML_Bool )0;
    }
#line 3992
    if (parser->m_endDoctypeDeclHandler) {
      {
#line 3993
      (*(parser->m_endDoctypeDeclHandler))(parser->m_handlerArg);
#line 3994
      handleDefault = (XML_Bool )0;
      }
    }
#line 3996
    goto switch_break___0;
    case_2: /* CIL Label */ 
#line 4002
    if (parser->m_useForeignDTD) {
#line 4003
      hadParamEntityRefs___0 = dtd->hasParamEntityRefs;
#line 4004
      dtd->hasParamEntityRefs = (XML_Bool )1;
#line 4005
      if (parser->m_paramEntityParsing) {
#line 4005
        if (parser->m_externalEntityRefHandler) {
          {
#line 4006
          tmp___10 = lookup(parser, & dtd->paramEntities, externalSubsetName, sizeof(ENTITY ));
#line 4006
          entity___0 = (ENTITY *)tmp___10;
          }
#line 4009
          if (! entity___0) {
#line 4010
            return ((enum XML_Error )1);
          }
          {
#line 4011
          entity___0->base = parser->m_curBase;
#line 4012
          dtd->paramEntityRead = (XML_Bool )0;
#line 4013
          tmp___11 = (*(parser->m_externalEntityRefHandler))(parser->m_externalEntityRefHandlerArg,
                                                             (XML_Char const   *)0,
                                                             entity___0->base, entity___0->systemId,
                                                             entity___0->publicId);
          }
#line 4013
          if (! tmp___11) {
#line 4018
            return ((enum XML_Error )21);
          }
#line 4019
          if (dtd->paramEntityRead) {
#line 4020
            if (! dtd->standalone) {
#line 4020
              if (parser->m_notStandaloneHandler) {
                {
#line 4020
                tmp___12 = (*(parser->m_notStandaloneHandler))(parser->m_handlerArg);
                }
#line 4020
                if (! tmp___12) {
#line 4023
                  return ((enum XML_Error )22);
                }
              }
            }
          } else {
#line 4029
            dtd->hasParamEntityRefs = hadParamEntityRefs___0;
          }
        }
      }
    }
    {
#line 4034
    parser->m_processor = & contentProcessor;
#line 4035
    tmp___13 = contentProcessor(parser, s, end, nextPtr);
    }
#line 4035
    return (tmp___13);
    case_34: /* CIL Label */ 
    {
#line 4037
    parser->m_declElementType = getElementType(parser, enc, s, next);
    }
#line 4038
    if (! parser->m_declElementType) {
#line 4039
      return ((enum XML_Error )1);
    }
#line 4040
    goto checkAttListDeclHandler;
    case_22: /* CIL Label */ 
    {
#line 4042
    parser->m_declAttributeId = getAttributeId(parser, enc, s, next);
    }
#line 4043
    if (! parser->m_declAttributeId) {
#line 4044
      return ((enum XML_Error )1);
    }
#line 4045
    parser->m_declAttributeIsCdata = (XML_Bool )0;
#line 4046
    parser->m_declAttributeType = (XML_Char const   *)((void *)0);
#line 4047
    parser->m_declAttributeIsId = (XML_Bool )0;
#line 4048
    goto checkAttListDeclHandler;
    case_23: /* CIL Label */ 
#line 4050
    parser->m_declAttributeIsCdata = (XML_Bool )1;
#line 4051
    parser->m_declAttributeType = atypeCDATA;
#line 4052
    goto checkAttListDeclHandler;
    case_24: /* CIL Label */ 
#line 4054
    parser->m_declAttributeIsId = (XML_Bool )1;
#line 4055
    parser->m_declAttributeType = atypeID;
#line 4056
    goto checkAttListDeclHandler;
    case_25: /* CIL Label */ 
#line 4058
    parser->m_declAttributeType = atypeIDREF;
#line 4059
    goto checkAttListDeclHandler;
    case_26: /* CIL Label */ 
#line 4061
    parser->m_declAttributeType = atypeIDREFS;
#line 4062
    goto checkAttListDeclHandler;
    case_27: /* CIL Label */ 
#line 4064
    parser->m_declAttributeType = atypeENTITY;
#line 4065
    goto checkAttListDeclHandler;
    case_28: /* CIL Label */ 
#line 4067
    parser->m_declAttributeType = atypeENTITIES;
#line 4068
    goto checkAttListDeclHandler;
    case_29: /* CIL Label */ 
#line 4070
    parser->m_declAttributeType = atypeNMTOKEN;
#line 4071
    goto checkAttListDeclHandler;
    case_30: /* CIL Label */ 
#line 4073
    parser->m_declAttributeType = atypeNMTOKENS;
    checkAttListDeclHandler: 
#line 4075
    if (dtd->keepProcessing) {
#line 4075
      if (parser->m_attlistDeclHandler) {
#line 4076
        handleDefault = (XML_Bool )0;
      }
    }
#line 4077
    goto switch_break___0;
    case_32: /* CIL Label */ 
    case_31: /* CIL Label */ 
#line 4080
    if (dtd->keepProcessing) {
#line 4080
      if (parser->m_attlistDeclHandler) {
#line 4082
        if (parser->m_declAttributeType) {
#line 4083
          prefix = enumValueSep;
        } else
#line 4086
        if (role == 32) {
#line 4086
          prefix = notationPrefix;
        } else {
#line 4086
          prefix = enumValueStart;
        }
        {
#line 4090
        tmp___14 = poolAppendString(& parser->m_tempPool, prefix);
        }
#line 4090
        if (! tmp___14) {
#line 4091
          return ((enum XML_Error )1);
        }
        {
#line 4092
        tmp___15 = poolAppend(& parser->m_tempPool, enc, s, next);
        }
#line 4092
        if (! tmp___15) {
#line 4093
          return ((enum XML_Error )1);
        }
#line 4094
        parser->m_declAttributeType = (XML_Char const   *)parser->m_tempPool.start;
#line 4095
        handleDefault = (XML_Bool )0;
      }
    }
#line 4097
    goto switch_break___0;
    case_36: /* CIL Label */ 
    case_35: /* CIL Label */ 
#line 4100
    if (dtd->keepProcessing) {
      {
#line 4101
      tmp___16 = defineAttribute(parser->m_declElementType, parser->m_declAttributeId,
                                 parser->m_declAttributeIsCdata, parser->m_declAttributeIsId,
                                 (XML_Char const   *)0, parser);
      }
#line 4101
      if (! tmp___16) {
#line 4104
        return ((enum XML_Error )1);
      }
#line 4105
      if (parser->m_attlistDeclHandler) {
#line 4105
        if (parser->m_declAttributeType) {
#line 4106
          if ((int const   )*(parser->m_declAttributeType) == 40) {
#line 4106
            goto _L___1;
          } else
#line 4106
          if ((int const   )*(parser->m_declAttributeType) == 78) {
#line 4106
            if ((int const   )*(parser->m_declAttributeType + 1) == 79) {
              _L___1: /* CIL Label */ 
#line 4110
              if ((unsigned long )parser->m_tempPool.ptr == (unsigned long )parser->m_tempPool.end) {
                {
#line 4110
                tmp___20 = poolGrow(& parser->m_tempPool);
                }
#line 4110
                if (tmp___20) {
#line 4110
                  tmp___18 = parser->m_tempPool.ptr;
#line 4110
                  (parser->m_tempPool.ptr) ++;
#line 4110
                  *tmp___18 = (XML_Char )41;
#line 4110
                  tmp___19 = 1;
                } else {
#line 4110
                  tmp___19 = 0;
                }
              } else {
#line 4110
                tmp___18 = parser->m_tempPool.ptr;
#line 4110
                (parser->m_tempPool.ptr) ++;
#line 4110
                *tmp___18 = (XML_Char )41;
#line 4110
                tmp___19 = 1;
              }
#line 4110
              if (tmp___19) {
#line 4110
                if ((unsigned long )parser->m_tempPool.ptr == (unsigned long )parser->m_tempPool.end) {
                  {
#line 4110
                  tmp___24 = poolGrow(& parser->m_tempPool);
                  }
#line 4110
                  if (tmp___24) {
#line 4110
                    tmp___22 = parser->m_tempPool.ptr;
#line 4110
                    (parser->m_tempPool.ptr) ++;
#line 4110
                    *tmp___22 = (XML_Char )'\000';
#line 4110
                    tmp___23 = 1;
                  } else {
#line 4110
                    tmp___23 = 0;
                  }
                } else {
#line 4110
                  tmp___22 = parser->m_tempPool.ptr;
#line 4110
                  (parser->m_tempPool.ptr) ++;
#line 4110
                  *tmp___22 = (XML_Char )'\000';
#line 4110
                  tmp___23 = 1;
                }
#line 4110
                if (! tmp___23) {
#line 4112
                  return ((enum XML_Error )1);
                }
              } else {
#line 4112
                return ((enum XML_Error )1);
              }
#line 4113
              parser->m_declAttributeType = (XML_Char const   *)parser->m_tempPool.start;
#line 4114
              parser->m_tempPool.start = parser->m_tempPool.ptr;
            }
          }
          {
#line 4116
          *eventEndPP = s;
#line 4117
          (*(parser->m_attlistDeclHandler))(parser->m_handlerArg, (parser->m_declElementType)->name,
                                            (XML_Char const   *)(parser->m_declAttributeId)->name,
                                            parser->m_declAttributeType, (XML_Char const   *)0,
                                            role == 36);
#line 4120
          poolClear(& parser->m_tempPool);
#line 4121
          handleDefault = (XML_Bool )0;
          }
        }
      }
    }
#line 4124
    goto switch_break___0;
    case_38: /* CIL Label */ 
    case_37: /* CIL Label */ 
#line 4127
    if (dtd->keepProcessing) {
      {
#line 4129
      tmp___25 = storeAttributeValue(parser, enc, parser->m_declAttributeIsCdata,
                                     s + enc->minBytesPerChar, next - enc->minBytesPerChar,
                                     & dtd->pool);
#line 4129
      result___1 = tmp___25;
      }
#line 4134
      if (result___1) {
#line 4135
        return (result___1);
      }
      {
#line 4136
      attVal = (XML_Char const   *)dtd->pool.start;
#line 4137
      dtd->pool.start = dtd->pool.ptr;
#line 4139
      tmp___26 = defineAttribute(parser->m_declElementType, parser->m_declAttributeId,
                                 parser->m_declAttributeIsCdata, (XML_Bool )0, attVal,
                                 parser);
      }
#line 4139
      if (! tmp___26) {
#line 4141
        return ((enum XML_Error )1);
      }
#line 4142
      if (parser->m_attlistDeclHandler) {
#line 4142
        if (parser->m_declAttributeType) {
#line 4143
          if ((int const   )*(parser->m_declAttributeType) == 40) {
#line 4143
            goto _L___2;
          } else
#line 4143
          if ((int const   )*(parser->m_declAttributeType) == 78) {
#line 4143
            if ((int const   )*(parser->m_declAttributeType + 1) == 79) {
              _L___2: /* CIL Label */ 
#line 4147
              if ((unsigned long )parser->m_tempPool.ptr == (unsigned long )parser->m_tempPool.end) {
                {
#line 4147
                tmp___30 = poolGrow(& parser->m_tempPool);
                }
#line 4147
                if (tmp___30) {
#line 4147
                  tmp___28 = parser->m_tempPool.ptr;
#line 4147
                  (parser->m_tempPool.ptr) ++;
#line 4147
                  *tmp___28 = (XML_Char )41;
#line 4147
                  tmp___29 = 1;
                } else {
#line 4147
                  tmp___29 = 0;
                }
              } else {
#line 4147
                tmp___28 = parser->m_tempPool.ptr;
#line 4147
                (parser->m_tempPool.ptr) ++;
#line 4147
                *tmp___28 = (XML_Char )41;
#line 4147
                tmp___29 = 1;
              }
#line 4147
              if (tmp___29) {
#line 4147
                if ((unsigned long )parser->m_tempPool.ptr == (unsigned long )parser->m_tempPool.end) {
                  {
#line 4147
                  tmp___34 = poolGrow(& parser->m_tempPool);
                  }
#line 4147
                  if (tmp___34) {
#line 4147
                    tmp___32 = parser->m_tempPool.ptr;
#line 4147
                    (parser->m_tempPool.ptr) ++;
#line 4147
                    *tmp___32 = (XML_Char )'\000';
#line 4147
                    tmp___33 = 1;
                  } else {
#line 4147
                    tmp___33 = 0;
                  }
                } else {
#line 4147
                  tmp___32 = parser->m_tempPool.ptr;
#line 4147
                  (parser->m_tempPool.ptr) ++;
#line 4147
                  *tmp___32 = (XML_Char )'\000';
#line 4147
                  tmp___33 = 1;
                }
#line 4147
                if (! tmp___33) {
#line 4149
                  return ((enum XML_Error )1);
                }
              } else {
#line 4149
                return ((enum XML_Error )1);
              }
#line 4150
              parser->m_declAttributeType = (XML_Char const   *)parser->m_tempPool.start;
#line 4151
              parser->m_tempPool.start = parser->m_tempPool.ptr;
            }
          }
          {
#line 4153
          *eventEndPP = s;
#line 4154
          (*(parser->m_attlistDeclHandler))(parser->m_handlerArg, (parser->m_declElementType)->name,
                                            (XML_Char const   *)(parser->m_declAttributeId)->name,
                                            parser->m_declAttributeType, attVal, role == 38);
#line 4158
          poolClear(& parser->m_tempPool);
#line 4159
          handleDefault = (XML_Bool )0;
          }
        }
      }
    }
#line 4162
    goto switch_break___0;
    case_12: /* CIL Label */ 
#line 4164
    if (dtd->keepProcessing) {
      {
#line 4165
      tmp___35 = storeEntityValue(parser, enc, s + enc->minBytesPerChar, next - enc->minBytesPerChar);
#line 4165
      result___2 = tmp___35;
      }
#line 4168
      if (parser->m_declEntity) {
#line 4169
        (parser->m_declEntity)->textPtr = (XML_Char const   *)dtd->entityValuePool.start;
#line 4170
        (parser->m_declEntity)->textLen = (int )(dtd->entityValuePool.ptr - dtd->entityValuePool.start);
#line 4171
        dtd->entityValuePool.start = dtd->entityValuePool.ptr;
#line 4172
        if (parser->m_entityDeclHandler) {
          {
#line 4173
          *eventEndPP = s;
#line 4174
          (*(parser->m_entityDeclHandler))(parser->m_handlerArg, (parser->m_declEntity)->name,
                                           (int )(parser->m_declEntity)->is_param,
                                           (parser->m_declEntity)->textPtr, (parser->m_declEntity)->textLen,
                                           parser->m_curBase, (XML_Char const   *)0,
                                           (XML_Char const   *)0, (XML_Char const   *)0);
#line 4180
          handleDefault = (XML_Bool )0;
          }
        }
      } else {
#line 4184
        dtd->entityValuePool.ptr = dtd->entityValuePool.start;
      }
#line 4185
      if ((unsigned int )result___2 != 0U) {
#line 4186
        return (result___2);
      }
    }
#line 4188
    goto switch_break___0;
    case_5: /* CIL Label */ 
#line 4191
    parser->m_useForeignDTD = (XML_Bool )0;
#line 4193
    dtd->hasParamEntityRefs = (XML_Bool )1;
#line 4194
    if (parser->m_startDoctypeDeclHandler) {
      {
#line 4195
      tmp___36 = poolStoreString(& parser->m_tempPool, enc, s + enc->minBytesPerChar,
                                 next - enc->minBytesPerChar);
#line 4195
      parser->m_doctypeSysid = (XML_Char const   *)tmp___36;
      }
#line 4198
      if ((unsigned long )parser->m_doctypeSysid == (unsigned long )((void *)0)) {
#line 4199
        return ((enum XML_Error )1);
      }
#line 4200
      parser->m_tempPool.start = parser->m_tempPool.ptr;
#line 4201
      handleDefault = (XML_Bool )0;
    } else {
#line 4207
      parser->m_doctypeSysid = externalSubsetName;
    }
#line 4209
    if (! dtd->standalone) {
#line 4209
      if (! parser->m_paramEntityParsing) {
#line 4209
        if (parser->m_notStandaloneHandler) {
          {
#line 4209
          tmp___37 = (*(parser->m_notStandaloneHandler))(parser->m_handlerArg);
          }
#line 4209
          if (! tmp___37) {
#line 4215
            return ((enum XML_Error )22);
          }
        }
      }
    }
#line 4219
    if (! parser->m_declEntity) {
      {
#line 4220
      tmp___38 = lookup(parser, & dtd->paramEntities, externalSubsetName, sizeof(ENTITY ));
#line 4220
      parser->m_declEntity = (ENTITY *)tmp___38;
      }
#line 4224
      if (! parser->m_declEntity) {
#line 4225
        return ((enum XML_Error )1);
      }
#line 4226
      (parser->m_declEntity)->publicId = (XML_Char const   *)((void *)0);
    }
    case_13: /* CIL Label */ 
#line 4231
    if (dtd->keepProcessing) {
#line 4231
      if (parser->m_declEntity) {
        {
#line 4232
        tmp___39 = poolStoreString(& dtd->pool, enc, s + enc->minBytesPerChar, next - enc->minBytesPerChar);
#line 4232
        (parser->m_declEntity)->systemId = (XML_Char const   *)tmp___39;
        }
#line 4235
        if (! (parser->m_declEntity)->systemId) {
#line 4236
          return ((enum XML_Error )1);
        }
#line 4237
        (parser->m_declEntity)->base = parser->m_curBase;
#line 4238
        dtd->pool.start = dtd->pool.ptr;
#line 4239
        if (parser->m_entityDeclHandler) {
#line 4240
          handleDefault = (XML_Bool )0;
        }
      }
    }
#line 4242
    goto switch_break___0;
    case_15: /* CIL Label */ 
#line 4244
    if (dtd->keepProcessing) {
#line 4244
      if (parser->m_declEntity) {
#line 4244
        if (parser->m_entityDeclHandler) {
          {
#line 4245
          *eventEndPP = s;
#line 4246
          (*(parser->m_entityDeclHandler))(parser->m_handlerArg, (parser->m_declEntity)->name,
                                           (int )(parser->m_declEntity)->is_param,
                                           (XML_Char const   *)0, 0, (parser->m_declEntity)->base,
                                           (parser->m_declEntity)->systemId, (parser->m_declEntity)->publicId,
                                           (XML_Char const   *)0);
#line 4254
          handleDefault = (XML_Bool )0;
          }
        }
      }
    }
#line 4256
    goto switch_break___0;
    case_16: /* CIL Label */ 
#line 4258
    if (dtd->keepProcessing) {
#line 4258
      if (parser->m_declEntity) {
        {
#line 4259
        tmp___40 = poolStoreString(& dtd->pool, enc, s, next);
#line 4259
        (parser->m_declEntity)->notation = (XML_Char const   *)tmp___40;
        }
#line 4260
        if (! (parser->m_declEntity)->notation) {
#line 4261
          return ((enum XML_Error )1);
        }
#line 4262
        dtd->pool.start = dtd->pool.ptr;
#line 4263
        if (parser->m_unparsedEntityDeclHandler) {
          {
#line 4264
          *eventEndPP = s;
#line 4265
          (*(parser->m_unparsedEntityDeclHandler))(parser->m_handlerArg, (parser->m_declEntity)->name,
                                                   (parser->m_declEntity)->base, (parser->m_declEntity)->systemId,
                                                   (parser->m_declEntity)->publicId,
                                                   (parser->m_declEntity)->notation);
#line 4271
          handleDefault = (XML_Bool )0;
          }
        } else
#line 4273
        if (parser->m_entityDeclHandler) {
          {
#line 4274
          *eventEndPP = s;
#line 4275
          (*(parser->m_entityDeclHandler))(parser->m_handlerArg, (parser->m_declEntity)->name,
                                           0, (XML_Char const   *)0, 0, (parser->m_declEntity)->base,
                                           (parser->m_declEntity)->systemId, (parser->m_declEntity)->publicId,
                                           (parser->m_declEntity)->notation);
#line 4282
          handleDefault = (XML_Bool )0;
          }
        }
      }
    }
#line 4285
    goto switch_break___0;
    case_9: /* CIL Label */ 
    {
#line 4288
    tmp___41 = (*(enc->predefinedEntityName))(enc, s, next);
    }
#line 4288
    if (tmp___41) {
#line 4289
      parser->m_declEntity = (ENTITY *)((void *)0);
#line 4290
      goto switch_break___0;
    }
#line 4292
    if (dtd->keepProcessing) {
      {
#line 4293
      tmp___42 = poolStoreString(& dtd->pool, enc, s, next);
#line 4293
      name = (XML_Char const   *)tmp___42;
      }
#line 4294
      if (! name) {
#line 4295
        return ((enum XML_Error )1);
      }
      {
#line 4296
      tmp___43 = lookup(parser, & dtd->generalEntities, name, sizeof(ENTITY ));
#line 4296
      parser->m_declEntity = (ENTITY *)tmp___43;
      }
#line 4298
      if (! parser->m_declEntity) {
#line 4299
        return ((enum XML_Error )1);
      }
#line 4300
      if ((unsigned long )(parser->m_declEntity)->name != (unsigned long )name) {
#line 4301
        dtd->pool.ptr = dtd->pool.start;
#line 4302
        parser->m_declEntity = (ENTITY *)((void *)0);
      } else {
#line 4305
        dtd->pool.start = dtd->pool.ptr;
#line 4306
        (parser->m_declEntity)->publicId = (XML_Char const   *)((void *)0);
#line 4307
        (parser->m_declEntity)->is_param = (XML_Bool )0;
#line 4311
        if (parser->m_parentParser) {
#line 4311
          tmp___44 = 0;
        } else
#line 4311
        if (parser->m_openInternalEntities) {
#line 4311
          tmp___44 = 0;
        } else {
#line 4311
          tmp___44 = 1;
        }
#line 4311
        (parser->m_declEntity)->is_internal = (XML_Bool )tmp___44;
#line 4312
        if (parser->m_entityDeclHandler) {
#line 4313
          handleDefault = (XML_Bool )0;
        }
      }
    } else {
#line 4317
      dtd->pool.ptr = dtd->pool.start;
#line 4318
      parser->m_declEntity = (ENTITY *)((void *)0);
    }
#line 4321
    goto switch_break___0;
    case_10: /* CIL Label */ 
#line 4324
    if (dtd->keepProcessing) {
      {
#line 4325
      tmp___45 = poolStoreString(& dtd->pool, enc, s, next);
#line 4325
      name___0 = (XML_Char const   *)tmp___45;
      }
#line 4326
      if (! name___0) {
#line 4327
        return ((enum XML_Error )1);
      }
      {
#line 4328
      tmp___46 = lookup(parser, & dtd->paramEntities, name___0, sizeof(ENTITY ));
#line 4328
      parser->m_declEntity = (ENTITY *)tmp___46;
      }
#line 4330
      if (! parser->m_declEntity) {
#line 4331
        return ((enum XML_Error )1);
      }
#line 4332
      if ((unsigned long )(parser->m_declEntity)->name != (unsigned long )name___0) {
#line 4333
        dtd->pool.ptr = dtd->pool.start;
#line 4334
        parser->m_declEntity = (ENTITY *)((void *)0);
      } else {
#line 4337
        dtd->pool.start = dtd->pool.ptr;
#line 4338
        (parser->m_declEntity)->publicId = (XML_Char const   *)((void *)0);
#line 4339
        (parser->m_declEntity)->is_param = (XML_Bool )1;
#line 4343
        if (parser->m_parentParser) {
#line 4343
          tmp___47 = 0;
        } else
#line 4343
        if (parser->m_openInternalEntities) {
#line 4343
          tmp___47 = 0;
        } else {
#line 4343
          tmp___47 = 1;
        }
#line 4343
        (parser->m_declEntity)->is_internal = (XML_Bool )tmp___47;
#line 4344
        if (parser->m_entityDeclHandler) {
#line 4345
          handleDefault = (XML_Bool )0;
        }
      }
    } else {
#line 4349
      dtd->pool.ptr = dtd->pool.start;
#line 4350
      parser->m_declEntity = (ENTITY *)((void *)0);
    }
#line 4355
    goto switch_break___0;
    case_18: /* CIL Label */ 
#line 4357
    parser->m_declNotationPublicId = (XML_Char const   *)((void *)0);
#line 4358
    parser->m_declNotationName = (XML_Char const   *)((void *)0);
#line 4359
    if (parser->m_notationDeclHandler) {
      {
#line 4360
      tmp___48 = poolStoreString(& parser->m_tempPool, enc, s, next);
#line 4360
      parser->m_declNotationName = (XML_Char const   *)tmp___48;
      }
#line 4361
      if (! parser->m_declNotationName) {
#line 4362
        return ((enum XML_Error )1);
      }
#line 4363
      parser->m_tempPool.start = parser->m_tempPool.ptr;
#line 4364
      handleDefault = (XML_Bool )0;
    }
#line 4366
    goto switch_break___0;
    case_21: /* CIL Label */ 
    {
#line 4368
    tmp___49 = (*(enc->isPublicId))(enc, s, next, eventPP);
    }
#line 4368
    if (! tmp___49) {
#line 4369
      return ((enum XML_Error )32);
    }
#line 4370
    if (parser->m_declNotationName) {
      {
#line 4371
      tmp___50 = poolStoreString(& parser->m_tempPool, enc, s + enc->minBytesPerChar,
                                 next - enc->minBytesPerChar);
#line 4371
      tem___0 = tmp___50;
      }
#line 4375
      if (! tem___0) {
#line 4376
        return ((enum XML_Error )1);
      }
      {
#line 4377
      normalizePublicId(tem___0);
#line 4378
      parser->m_declNotationPublicId = (XML_Char const   *)tem___0;
#line 4379
      parser->m_tempPool.start = parser->m_tempPool.ptr;
#line 4380
      handleDefault = (XML_Bool )0;
      }
    }
#line 4382
    goto switch_break___0;
    case_19: /* CIL Label */ 
#line 4384
    if (parser->m_declNotationName) {
#line 4384
      if (parser->m_notationDeclHandler) {
        {
#line 4385
        tmp___51 = poolStoreString(& parser->m_tempPool, enc, s + enc->minBytesPerChar,
                                   next - enc->minBytesPerChar);
#line 4385
        systemId = (XML_Char const   *)tmp___51;
        }
#line 4389
        if (! systemId) {
#line 4390
          return ((enum XML_Error )1);
        }
        {
#line 4391
        *eventEndPP = s;
#line 4392
        (*(parser->m_notationDeclHandler))(parser->m_handlerArg, parser->m_declNotationName,
                                           parser->m_curBase, systemId, parser->m_declNotationPublicId);
#line 4397
        handleDefault = (XML_Bool )0;
        }
      }
    }
    {
#line 4399
    poolClear(& parser->m_tempPool);
    }
#line 4400
    goto switch_break___0;
    case_20: /* CIL Label */ 
#line 4402
    if (parser->m_declNotationPublicId) {
#line 4402
      if (parser->m_notationDeclHandler) {
        {
#line 4403
        *eventEndPP = s;
#line 4404
        (*(parser->m_notationDeclHandler))(parser->m_handlerArg, parser->m_declNotationName,
                                           parser->m_curBase, (XML_Char const   *)0,
                                           parser->m_declNotationPublicId);
#line 4409
        handleDefault = (XML_Bool )0;
        }
      }
    }
    {
#line 4411
    poolClear(& parser->m_tempPool);
    }
#line 4412
    goto switch_break___0;
    case_neg_1___0: /* CIL Label */ 
    {
#line 4415
    if (tok == 28) {
#line 4415
      goto case_28___0;
    }
#line 4419
    if (tok == 12) {
#line 4419
      goto case_12___0;
    }
#line 4421
    goto switch_default___0;
    case_28___0: /* CIL Label */ 
#line 4418
    return ((enum XML_Error )10);
    case_12___0: /* CIL Label */ 
#line 4420
    return ((enum XML_Error )17);
    switch_default___0: /* CIL Label */ 
#line 4422
    return ((enum XML_Error )2);
    switch_break___1: /* CIL Label */ ;
    }
    case_58: /* CIL Label */ 
#line 4428
    if (parser->m_defaultHandler) {
      {
#line 4429
      reportDefault(parser, enc, s, next);
      }
    }
    {
#line 4430
    handleDefault = (XML_Bool )0;
#line 4431
    result___3 = doIgnoreSection(parser, enc, & next, end, nextPtr, haveMore);
    }
#line 4432
    if ((unsigned int )result___3 != 0U) {
#line 4433
      return (result___3);
    } else
#line 4434
    if (! next) {
#line 4435
      parser->m_processor = & ignoreSectionProcessor;
#line 4436
      return (result___3);
    }
#line 4439
    goto switch_break___0;
    case_44: /* CIL Label */ 
#line 4442
    if (parser->m_prologState.level >= parser->m_groupSize) {
#line 4443
      if (parser->m_groupSize) {
        {
#line 4444
        tmp___52 = parser->m_groupSize * 2U;
#line 4444
        parser->m_groupSize = tmp___52;
#line 4444
        tmp___53 = (*(parser->m_mem.realloc_fcn))((void *)parser->m_groupConnector,
                                                  (size_t )tmp___52);
#line 4444
        temp = (char *)tmp___53;
        }
#line 4445
        if ((unsigned long )temp == (unsigned long )((void *)0)) {
#line 4446
          return ((enum XML_Error )1);
        }
#line 4447
        parser->m_groupConnector = temp;
#line 4448
        if (dtd->scaffIndex) {
          {
#line 4449
          tmp___54 = (*(parser->m_mem.realloc_fcn))((void *)dtd->scaffIndex, (unsigned long )parser->m_groupSize * sizeof(int ));
#line 4449
          temp___0 = (int *)tmp___54;
          }
#line 4451
          if ((unsigned long )temp___0 == (unsigned long )((void *)0)) {
#line 4452
            return ((enum XML_Error )1);
          }
#line 4453
          dtd->scaffIndex = temp___0;
        }
      } else {
        {
#line 4457
        tmp___55 = 32U;
#line 4457
        parser->m_groupSize = tmp___55;
#line 4457
        tmp___56 = (*(parser->m_mem.malloc_fcn))((size_t )tmp___55);
#line 4457
        parser->m_groupConnector = (char *)tmp___56;
        }
#line 4458
        if (! parser->m_groupConnector) {
#line 4459
          return ((enum XML_Error )1);
        }
      }
    }
#line 4462
    *(parser->m_groupConnector + parser->m_prologState.level) = (char)0;
#line 4463
    if (dtd->in_eldecl) {
      {
#line 4464
      tmp___57 = nextScaffoldPart(parser);
#line 4464
      myindex = tmp___57;
      }
#line 4465
      if (myindex < 0) {
#line 4466
        return ((enum XML_Error )1);
      }
#line 4467
      *(dtd->scaffIndex + dtd->scaffLevel) = myindex;
#line 4468
      (dtd->scaffLevel) ++;
#line 4469
      (dtd->scaffold + myindex)->type = (enum XML_Content_Type )6;
#line 4470
      if (parser->m_elementDeclHandler) {
#line 4471
        handleDefault = (XML_Bool )0;
      }
    }
#line 4473
    goto switch_break___0;
    case_50: /* CIL Label */ 
#line 4475
    if ((int )*(parser->m_groupConnector + parser->m_prologState.level) == 124) {
#line 4476
      return ((enum XML_Error )2);
    }
#line 4477
    *(parser->m_groupConnector + parser->m_prologState.level) = (char)44;
#line 4478
    if (dtd->in_eldecl) {
#line 4478
      if (parser->m_elementDeclHandler) {
#line 4479
        handleDefault = (XML_Bool )0;
      }
    }
#line 4480
    goto switch_break___0;
    case_49: /* CIL Label */ 
#line 4482
    if ((int )*(parser->m_groupConnector + parser->m_prologState.level) == 44) {
#line 4483
      return ((enum XML_Error )2);
    }
#line 4484
    if (dtd->in_eldecl) {
#line 4484
      if (! *(parser->m_groupConnector + parser->m_prologState.level)) {
#line 4484
        if ((unsigned int )(dtd->scaffold + *(dtd->scaffIndex + (dtd->scaffLevel - 1)))->type != 3U) {
#line 4489
          (dtd->scaffold + *(dtd->scaffIndex + (dtd->scaffLevel - 1)))->type = (enum XML_Content_Type )5;
#line 4491
          if (parser->m_elementDeclHandler) {
#line 4492
            handleDefault = (XML_Bool )0;
          }
        }
      }
    }
#line 4494
    *(parser->m_groupConnector + parser->m_prologState.level) = (char)124;
#line 4495
    goto switch_break___0;
    case_59: /* CIL Label */ 
    case_60: /* CIL Label */ 
#line 4499
    dtd->hasParamEntityRefs = (XML_Bool )1;
#line 4500
    if (! parser->m_paramEntityParsing) {
#line 4501
      dtd->keepProcessing = dtd->standalone;
    } else {
      {
#line 4505
      tmp___58 = poolStoreString(& dtd->pool, enc, s + enc->minBytesPerChar, next - enc->minBytesPerChar);
#line 4505
      name___1 = (XML_Char const   *)tmp___58;
      }
#line 4508
      if (! name___1) {
#line 4509
        return ((enum XML_Error )1);
      }
      {
#line 4510
      tmp___59 = lookup(parser, & dtd->paramEntities, name___1, (size_t )0);
#line 4510
      entity___1 = (ENTITY *)tmp___59;
#line 4511
      dtd->pool.ptr = dtd->pool.start;
      }
#line 4516
      if (parser->m_prologState.documentEntity) {
#line 4516
        if (dtd->standalone) {
#line 4516
          tmp___60 = ! parser->m_openInternalEntities;
        } else {
#line 4516
          tmp___60 = ! dtd->hasParamEntityRefs;
        }
#line 4516
        if (tmp___60) {
#line 4520
          if (! entity___1) {
#line 4521
            return ((enum XML_Error )11);
          } else
#line 4522
          if (! entity___1->is_internal) {
#line 4523
            return ((enum XML_Error )24);
          }
        } else {
#line 4516
          goto _L___3;
        }
      } else
      _L___3: /* CIL Label */ 
#line 4525
      if (! entity___1) {
#line 4526
        dtd->keepProcessing = dtd->standalone;
#line 4528
        if (role == 60) {
#line 4528
          if (parser->m_skippedEntityHandler) {
            {
#line 4529
            (*(parser->m_skippedEntityHandler))(parser->m_handlerArg, name___1, 1);
#line 4530
            handleDefault = (XML_Bool )0;
            }
          }
        }
#line 4532
        goto switch_break___0;
      }
#line 4534
      if (entity___1->open) {
#line 4535
        return ((enum XML_Error )12);
      }
#line 4536
      if (entity___1->textPtr) {
#line 4538
        if (role == 60) {
#line 4538
          tmp___61 = (int )((XML_Bool )1);
        } else {
#line 4538
          tmp___61 = (int )((XML_Bool )0);
        }
        {
#line 4538
        betweenDecl = (XML_Bool )tmp___61;
#line 4540
        result___4 = processInternalEntity(parser, entity___1, betweenDecl);
        }
#line 4541
        if ((unsigned int )result___4 != 0U) {
#line 4542
          return (result___4);
        }
#line 4543
        handleDefault = (XML_Bool )0;
#line 4544
        goto switch_break___0;
      }
#line 4546
      if (parser->m_externalEntityRefHandler) {
        {
#line 4547
        dtd->paramEntityRead = (XML_Bool )0;
#line 4548
        entity___1->open = (XML_Bool )1;
#line 4549
        tmp___62 = (*(parser->m_externalEntityRefHandler))(parser->m_externalEntityRefHandlerArg,
                                                           (XML_Char const   *)0,
                                                           entity___1->base, entity___1->systemId,
                                                           entity___1->publicId);
        }
#line 4549
        if (! tmp___62) {
#line 4554
          entity___1->open = (XML_Bool )0;
#line 4555
          return ((enum XML_Error )21);
        }
#line 4557
        entity___1->open = (XML_Bool )0;
#line 4558
        handleDefault = (XML_Bool )0;
#line 4559
        if (! dtd->paramEntityRead) {
#line 4560
          dtd->keepProcessing = dtd->standalone;
#line 4561
          goto switch_break___0;
        }
      } else {
#line 4565
        dtd->keepProcessing = dtd->standalone;
#line 4566
        goto switch_break___0;
      }
    }
#line 4570
    if (! dtd->standalone) {
#line 4570
      if (parser->m_notStandaloneHandler) {
        {
#line 4570
        tmp___63 = (*(parser->m_notStandaloneHandler))(parser->m_handlerArg);
        }
#line 4570
        if (! tmp___63) {
#line 4573
          return ((enum XML_Error )22);
        }
      }
    }
#line 4574
    goto switch_break___0;
    case_40: /* CIL Label */ 
#line 4579
    if (parser->m_elementDeclHandler) {
      {
#line 4580
      parser->m_declElementType = getElementType(parser, enc, s, next);
      }
#line 4581
      if (! parser->m_declElementType) {
#line 4582
        return ((enum XML_Error )1);
      }
#line 4583
      dtd->scaffLevel = 0;
#line 4584
      dtd->scaffCount = 0U;
#line 4585
      dtd->in_eldecl = (XML_Bool )1;
#line 4586
      handleDefault = (XML_Bool )0;
    }
#line 4588
    goto switch_break___0;
    case_42: /* CIL Label */ 
    case_41: /* CIL Label */ 
#line 4592
    if (dtd->in_eldecl) {
#line 4593
      if (parser->m_elementDeclHandler) {
        {
#line 4594
        tmp___64 = (*(parser->m_mem.malloc_fcn))(sizeof(XML_Content ));
#line 4594
        content = (XML_Content *)tmp___64;
        }
#line 4595
        if (! content) {
#line 4596
          return ((enum XML_Error )1);
        }
#line 4597
        content->quant = (enum XML_Content_Quant )0;
#line 4598
        content->name = (XML_Char *)((void *)0);
#line 4599
        content->numchildren = 0U;
#line 4600
        content->children = (XML_Content *)((void *)0);
#line 4601
        if (role == 41) {
#line 4601
          content->type = (enum XML_Content_Type )2;
        } else {
#line 4601
          content->type = (enum XML_Content_Type )1;
        }
        {
#line 4604
        *eventEndPP = s;
#line 4605
        (*(parser->m_elementDeclHandler))(parser->m_handlerArg, (parser->m_declElementType)->name,
                                          content);
#line 4606
        handleDefault = (XML_Bool )0;
        }
      }
#line 4608
      dtd->in_eldecl = (XML_Bool )0;
    }
#line 4610
    goto switch_break___0;
    case_43: /* CIL Label */ 
#line 4613
    if (dtd->in_eldecl) {
#line 4614
      (dtd->scaffold + *(dtd->scaffIndex + (dtd->scaffLevel - 1)))->type = (enum XML_Content_Type )3;
#line 4616
      if (parser->m_elementDeclHandler) {
#line 4617
        handleDefault = (XML_Bool )0;
      }
    }
#line 4619
    goto switch_break___0;
    case_51: /* CIL Label */ 
#line 4622
    quant = (enum XML_Content_Quant )0;
#line 4623
    goto elementContent;
    case_53: /* CIL Label */ 
#line 4625
    quant = (enum XML_Content_Quant )1;
#line 4626
    goto elementContent;
    case_52: /* CIL Label */ 
#line 4628
    quant = (enum XML_Content_Quant )2;
#line 4629
    goto elementContent;
    case_54: /* CIL Label */ 
#line 4631
    quant = (enum XML_Content_Quant )3;
    elementContent: 
#line 4633
    if (dtd->in_eldecl) {
#line 4637
      if ((unsigned int )quant == 0U) {
#line 4637
        tmp___65 = next;
      } else {
#line 4637
        tmp___65 = next - enc->minBytesPerChar;
      }
      {
#line 4637
      nxt = tmp___65;
#line 4640
      tmp___66 = nextScaffoldPart(parser);
#line 4640
      myindex___0 = tmp___66;
      }
#line 4641
      if (myindex___0 < 0) {
#line 4642
        return ((enum XML_Error )1);
      }
      {
#line 4643
      (dtd->scaffold + myindex___0)->type = (enum XML_Content_Type )4;
#line 4644
      (dtd->scaffold + myindex___0)->quant = quant;
#line 4645
      el = getElementType(parser, enc, s, nxt);
      }
#line 4646
      if (! el) {
#line 4647
        return ((enum XML_Error )1);
      }
#line 4648
      name___2 = el->name;
#line 4649
      (dtd->scaffold + myindex___0)->name = name___2;
#line 4650
      nameLen = 0;
      {
#line 4651
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 4651
        tmp___67 = nameLen;
#line 4651
        nameLen ++;
#line 4651
        if (! *(name___2 + tmp___67)) {
#line 4651
          goto while_break___0;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
#line 4652
      dtd->contentStringLen += (unsigned int )nameLen;
#line 4653
      if (parser->m_elementDeclHandler) {
#line 4654
        handleDefault = (XML_Bool )0;
      }
    }
#line 4656
    goto switch_break___0;
    case_45: /* CIL Label */ 
#line 4659
    quant = (enum XML_Content_Quant )0;
#line 4660
    goto closeGroup;
    case_47: /* CIL Label */ 
#line 4662
    quant = (enum XML_Content_Quant )1;
#line 4663
    goto closeGroup;
    case_46: /* CIL Label */ 
#line 4665
    quant = (enum XML_Content_Quant )2;
#line 4666
    goto closeGroup;
    case_48: /* CIL Label */ 
#line 4668
    quant = (enum XML_Content_Quant )3;
    closeGroup: 
#line 4670
    if (dtd->in_eldecl) {
#line 4671
      if (parser->m_elementDeclHandler) {
#line 4672
        handleDefault = (XML_Bool )0;
      }
#line 4673
      (dtd->scaffLevel) --;
#line 4674
      (dtd->scaffold + *(dtd->scaffIndex + dtd->scaffLevel))->quant = quant;
#line 4675
      if (dtd->scaffLevel == 0) {
#line 4676
        if (! handleDefault) {
          {
#line 4677
          tmp___68 = build_model(parser);
#line 4677
          model = tmp___68;
          }
#line 4678
          if (! model) {
#line 4679
            return ((enum XML_Error )1);
          }
          {
#line 4680
          *eventEndPP = s;
#line 4681
          (*(parser->m_elementDeclHandler))(parser->m_handlerArg, (parser->m_declElementType)->name,
                                            model);
          }
        }
#line 4683
        dtd->in_eldecl = (XML_Bool )0;
#line 4684
        dtd->contentStringLen = 0U;
      }
    }
#line 4687
    goto switch_break___0;
    case_55: /* CIL Label */ 
    {
#line 4691
    tmp___69 = reportProcessingInstruction(parser, enc, s, next);
    }
#line 4691
    if (! tmp___69) {
#line 4692
      return ((enum XML_Error )1);
    }
#line 4693
    handleDefault = (XML_Bool )0;
#line 4694
    goto switch_break___0;
    case_56: /* CIL Label */ 
    {
#line 4696
    tmp___70 = reportComment(parser, enc, s, next);
    }
#line 4696
    if (! tmp___70) {
#line 4697
      return ((enum XML_Error )1);
    }
#line 4698
    handleDefault = (XML_Bool )0;
#line 4699
    goto switch_break___0;
    case_0___0: /* CIL Label */ 
    {
#line 4702
    if (tok == 14) {
#line 4702
      goto case_14___0;
    }
#line 4701
    goto switch_break___2;
    case_14___0: /* CIL Label */ 
#line 4703
    handleDefault = (XML_Bool )0;
#line 4704
    goto switch_break___2;
    switch_break___2: /* CIL Label */ ;
    }
#line 4706
    goto switch_break___0;
    case_3: /* CIL Label */ 
#line 4708
    if (parser->m_startDoctypeDeclHandler) {
#line 4709
      handleDefault = (XML_Bool )0;
    }
#line 4710
    goto switch_break___0;
    case_11: /* CIL Label */ 
#line 4712
    if (dtd->keepProcessing) {
#line 4712
      if (parser->m_entityDeclHandler) {
#line 4713
        handleDefault = (XML_Bool )0;
      }
    }
#line 4714
    goto switch_break___0;
    case_17: /* CIL Label */ 
#line 4716
    if (parser->m_notationDeclHandler) {
#line 4717
      handleDefault = (XML_Bool )0;
    }
#line 4718
    goto switch_break___0;
    case_33: /* CIL Label */ 
#line 4720
    if (dtd->keepProcessing) {
#line 4720
      if (parser->m_attlistDeclHandler) {
#line 4721
        handleDefault = (XML_Bool )0;
      }
    }
#line 4722
    goto switch_break___0;
    case_39: /* CIL Label */ 
#line 4724
    if (parser->m_elementDeclHandler) {
#line 4725
      handleDefault = (XML_Bool )0;
    }
#line 4726
    goto switch_break___0;
    switch_break___0: /* CIL Label */ ;
    }
#line 4729
    if (handleDefault) {
#line 4729
      if (parser->m_defaultHandler) {
        {
#line 4730
        reportDefault(parser, enc, s, next);
        }
      }
    }
    {
#line 4733
    if ((unsigned int )parser->m_parsingStatus.parsing == 3U) {
#line 4733
      goto case_3___0;
    }
#line 4736
    if ((unsigned int )parser->m_parsingStatus.parsing == 2U) {
#line 4736
      goto case_2___0;
    }
#line 4738
    goto switch_default___1;
    case_3___0: /* CIL Label */ 
#line 4734
    *nextPtr = next;
#line 4735
    return ((enum XML_Error )0);
    case_2___0: /* CIL Label */ 
#line 4737
    return ((enum XML_Error )35);
    switch_default___1: /* CIL Label */ 
    {
#line 4739
    s = next;
#line 4740
    tok = (*(enc->scanners[0]))(enc, s, end, & next);
    }
    switch_break___3: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 4746 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlparse.c"
static enum XML_Error epilogProcessor(XML_Parser parser , char const   *s , char const   *end ,
                                      char const   **nextPtr ) 
{ 
  char const   *next ;
  int tok ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 4752
  parser->m_processor = & epilogProcessor;
#line 4753
  parser->m_eventPtr = s;
  {
#line 4754
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 4755
    next = (char const   *)((void *)0);
#line 4756
    tmp = (*((parser->m_encoding)->scanners[0]))(parser->m_encoding, s, end, & next);
#line 4756
    tok = tmp;
#line 4757
    parser->m_eventEndPtr = next;
    }
    {
#line 4760
    if (tok == -15) {
#line 4760
      goto case_neg_15;
    }
#line 4768
    if (tok == -4) {
#line 4768
      goto case_neg_4;
    }
#line 4771
    if (tok == 15) {
#line 4771
      goto case_15;
    }
#line 4775
    if (tok == 11) {
#line 4775
      goto case_11;
    }
#line 4779
    if (tok == 13) {
#line 4779
      goto case_13;
    }
#line 4783
    if (tok == 0) {
#line 4783
      goto case_0;
    }
#line 4786
    if (tok == -1) {
#line 4786
      goto case_neg_1;
    }
#line 4792
    if (tok == -2) {
#line 4792
      goto case_neg_2;
    }
#line 4798
    goto switch_default;
    case_neg_15: /* CIL Label */ 
#line 4761
    if (parser->m_defaultHandler) {
      {
#line 4762
      reportDefault(parser, parser->m_encoding, s, next);
      }
#line 4763
      if ((unsigned int )parser->m_parsingStatus.parsing == 2U) {
#line 4764
        return ((enum XML_Error )35);
      }
    }
#line 4766
    *nextPtr = next;
#line 4767
    return ((enum XML_Error )0);
    case_neg_4: /* CIL Label */ 
#line 4769
    *nextPtr = s;
#line 4770
    return ((enum XML_Error )0);
    case_15: /* CIL Label */ 
#line 4772
    if (parser->m_defaultHandler) {
      {
#line 4773
      reportDefault(parser, parser->m_encoding, s, next);
      }
    }
#line 4774
    goto switch_break;
    case_11: /* CIL Label */ 
    {
#line 4776
    tmp___0 = reportProcessingInstruction(parser, parser->m_encoding, s, next);
    }
#line 4776
    if (! tmp___0) {
#line 4777
      return ((enum XML_Error )1);
    }
#line 4778
    goto switch_break;
    case_13: /* CIL Label */ 
    {
#line 4780
    tmp___1 = reportComment(parser, parser->m_encoding, s, next);
    }
#line 4780
    if (! tmp___1) {
#line 4781
      return ((enum XML_Error )1);
    }
#line 4782
    goto switch_break;
    case_0: /* CIL Label */ 
#line 4784
    parser->m_eventPtr = next;
#line 4785
    return ((enum XML_Error )4);
    case_neg_1: /* CIL Label */ 
#line 4787
    if (! parser->m_parsingStatus.finalBuffer) {
#line 4788
      *nextPtr = s;
#line 4789
      return ((enum XML_Error )0);
    }
#line 4791
    return ((enum XML_Error )5);
    case_neg_2: /* CIL Label */ 
#line 4793
    if (! parser->m_parsingStatus.finalBuffer) {
#line 4794
      *nextPtr = s;
#line 4795
      return ((enum XML_Error )0);
    }
#line 4797
    return ((enum XML_Error )6);
    switch_default: /* CIL Label */ 
#line 4799
    return ((enum XML_Error )9);
    switch_break: /* CIL Label */ ;
    }
#line 4801
    s = next;
#line 4801
    parser->m_eventPtr = s;
    {
#line 4803
    if ((unsigned int )parser->m_parsingStatus.parsing == 3U) {
#line 4803
      goto case_3;
    }
#line 4806
    if ((unsigned int )parser->m_parsingStatus.parsing == 2U) {
#line 4806
      goto case_2;
    }
#line 4808
    goto switch_default___0;
    case_3: /* CIL Label */ 
#line 4804
    *nextPtr = next;
#line 4805
    return ((enum XML_Error )0);
    case_2: /* CIL Label */ 
#line 4807
    return ((enum XML_Error )35);
    switch_default___0: /* CIL Label */ ;
    switch_break___0: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 4813 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlparse.c"
static enum XML_Error processInternalEntity(XML_Parser parser , ENTITY *entity , XML_Bool betweenDecl ) 
{ 
  char const   *textStart ;
  char const   *textEnd ;
  char const   *next ;
  enum XML_Error result ;
  OPEN_INTERNAL_ENTITY *openEntity ;
  void *tmp ;
  int tok ;
  int tmp___0 ;

  {
#line 4822
  if (parser->m_freeInternalEntities) {
#line 4823
    openEntity = parser->m_freeInternalEntities;
#line 4824
    parser->m_freeInternalEntities = openEntity->next;
  } else {
    {
#line 4827
    tmp = (*(parser->m_mem.malloc_fcn))(sizeof(OPEN_INTERNAL_ENTITY ));
#line 4827
    openEntity = (OPEN_INTERNAL_ENTITY *)tmp;
    }
#line 4828
    if (! openEntity) {
#line 4829
      return ((enum XML_Error )1);
    }
  }
#line 4831
  entity->open = (XML_Bool )1;
#line 4832
  entity->processed = 0;
#line 4833
  openEntity->next = parser->m_openInternalEntities;
#line 4834
  parser->m_openInternalEntities = openEntity;
#line 4835
  openEntity->entity = entity;
#line 4836
  openEntity->startTagLevel = parser->m_tagLevel;
#line 4837
  openEntity->betweenDecl = betweenDecl;
#line 4838
  openEntity->internalEventPtr = (char const   *)((void *)0);
#line 4839
  openEntity->internalEventEndPtr = (char const   *)((void *)0);
#line 4840
  textStart = (char const   *)((char *)entity->textPtr);
#line 4841
  textEnd = (char const   *)((char *)(entity->textPtr + entity->textLen));
#line 4844
  if (entity->is_param) {
    {
#line 4845
    tmp___0 = (*((parser->m_internalEncoding)->scanners[0]))(parser->m_internalEncoding,
                                                             textStart, textEnd, & next);
#line 4845
    tok = tmp___0;
#line 4846
    result = doProlog(parser, parser->m_internalEncoding, textStart, textEnd, tok,
                      next, & next, (XML_Bool )0);
    }
  } else {
    {
#line 4851
    result = doContent(parser, parser->m_tagLevel, parser->m_internalEncoding, textStart,
                       textEnd, & next, (XML_Bool )0);
    }
  }
#line 4854
  if ((unsigned int )result == 0U) {
#line 4855
    if ((unsigned long )textEnd != (unsigned long )next) {
#line 4855
      if ((unsigned int )parser->m_parsingStatus.parsing == 3U) {
#line 4856
        entity->processed = (int )(next - textStart);
#line 4857
        parser->m_processor = & internalEntityProcessor;
      } else {
#line 4860
        entity->open = (XML_Bool )0;
#line 4861
        parser->m_openInternalEntities = openEntity->next;
#line 4863
        openEntity->next = parser->m_freeInternalEntities;
#line 4864
        parser->m_freeInternalEntities = openEntity;
      }
    } else {
#line 4860
      entity->open = (XML_Bool )0;
#line 4861
      parser->m_openInternalEntities = openEntity->next;
#line 4863
      openEntity->next = parser->m_freeInternalEntities;
#line 4864
      parser->m_freeInternalEntities = openEntity;
    }
  }
#line 4867
  return (result);
}
}
#line 4870 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlparse.c"
static enum XML_Error internalEntityProcessor(XML_Parser parser , char const   *s ,
                                              char const   *end , char const   **nextPtr ) 
{ 
  ENTITY *entity ;
  char const   *textStart ;
  char const   *textEnd ;
  char const   *next ;
  enum XML_Error result ;
  OPEN_INTERNAL_ENTITY *openEntity ;
  int tok ;
  int tmp ;
  int tok___0 ;
  enum XML_Error tmp___0 ;
  int tmp___1 ;
  enum XML_Error tmp___2 ;

  {
#line 4880
  openEntity = parser->m_openInternalEntities;
#line 4881
  if (! openEntity) {
#line 4882
    return ((enum XML_Error )23);
  }
#line 4884
  entity = openEntity->entity;
#line 4885
  textStart = (char const   *)((char *)entity->textPtr + entity->processed);
#line 4886
  textEnd = (char const   *)((char *)(entity->textPtr + entity->textLen));
#line 4889
  if (entity->is_param) {
    {
#line 4890
    tmp = (*((parser->m_internalEncoding)->scanners[0]))(parser->m_internalEncoding,
                                                         textStart, textEnd, & next);
#line 4890
    tok = tmp;
#line 4891
    result = doProlog(parser, parser->m_internalEncoding, textStart, textEnd, tok,
                      next, & next, (XML_Bool )0);
    }
  } else {
    {
#line 4896
    result = doContent(parser, openEntity->startTagLevel, parser->m_internalEncoding,
                       textStart, textEnd, & next, (XML_Bool )0);
    }
  }
#line 4899
  if ((unsigned int )result != 0U) {
#line 4900
    return (result);
  } else
#line 4901
  if ((unsigned long )textEnd != (unsigned long )next) {
#line 4901
    if ((unsigned int )parser->m_parsingStatus.parsing == 3U) {
#line 4902
      entity->processed = (int )(next - (char const   *)((char *)entity->textPtr));
#line 4903
      return (result);
    } else {
#line 4906
      entity->open = (XML_Bool )0;
#line 4907
      parser->m_openInternalEntities = openEntity->next;
#line 4909
      openEntity->next = parser->m_freeInternalEntities;
#line 4910
      parser->m_freeInternalEntities = openEntity;
    }
  } else {
#line 4906
    entity->open = (XML_Bool )0;
#line 4907
    parser->m_openInternalEntities = openEntity->next;
#line 4909
    openEntity->next = parser->m_freeInternalEntities;
#line 4910
    parser->m_freeInternalEntities = openEntity;
  }
#line 4914
  if (entity->is_param) {
    {
#line 4916
    parser->m_processor = & prologProcessor;
#line 4917
    tok___0 = (*((parser->m_encoding)->scanners[0]))(parser->m_encoding, s, end, & next);
#line 4918
    tmp___0 = doProlog(parser, parser->m_encoding, s, end, tok___0, next, nextPtr,
                       (XML_Bool )(! parser->m_parsingStatus.finalBuffer));
    }
#line 4918
    return (tmp___0);
  } else {
#line 4924
    parser->m_processor = & contentProcessor;
#line 4926
    if (parser->m_parentParser) {
#line 4926
      tmp___1 = 1;
    } else {
#line 4926
      tmp___1 = 0;
    }
    {
#line 4926
    tmp___2 = doContent(parser, tmp___1, parser->m_encoding, s, end, nextPtr, (XML_Bool )(! parser->m_parsingStatus.finalBuffer));
    }
#line 4926
    return (tmp___2);
  }
}
}
#line 4931 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlparse.c"
static enum XML_Error errorProcessor(XML_Parser parser , char const   *s , char const   *end ,
                                     char const   **nextPtr ) 
{ 


  {
#line 4937
  return (parser->m_errorCode);
}
}
#line 4940 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlparse.c"
static enum XML_Error storeAttributeValue(XML_Parser parser , ENCODING const   *enc ,
                                          XML_Bool isCdata , char const   *ptr , char const   *end ,
                                          STRING_POOL *pool ) 
{ 
  enum XML_Error result ;
  enum XML_Error tmp ;
  XML_Char *tmp___1 ;
  int tmp___2 ;
  XML_Bool tmp___3 ;

  {
  {
#line 4945
  tmp = appendAttributeValue(parser, enc, isCdata, ptr, end, pool);
#line 4945
  result = tmp;
  }
#line 4947
  if (result) {
#line 4948
    return (result);
  }
#line 4949
  if (! isCdata) {
#line 4949
    if (pool->ptr - pool->start) {
#line 4949
      if ((int )*(pool->ptr + -1) == 32) {
#line 4950
        (pool->ptr) --;
      }
    }
  }
#line 4951
  if ((unsigned long )pool->ptr == (unsigned long )pool->end) {
    {
#line 4951
    tmp___3 = poolGrow(pool);
    }
#line 4951
    if (tmp___3) {
#line 4951
      tmp___1 = pool->ptr;
#line 4951
      (pool->ptr) ++;
#line 4951
      *tmp___1 = (XML_Char )'\000';
#line 4951
      tmp___2 = 1;
    } else {
#line 4951
      tmp___2 = 0;
    }
  } else {
#line 4951
    tmp___1 = pool->ptr;
#line 4951
    (pool->ptr) ++;
#line 4951
    *tmp___1 = (XML_Char )'\000';
#line 4951
    tmp___2 = 1;
  }
#line 4951
  if (! tmp___2) {
#line 4952
    return ((enum XML_Error )1);
  }
#line 4953
  return ((enum XML_Error )0);
}
}
#line 4956 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlparse.c"
static enum XML_Error appendAttributeValue(XML_Parser parser , ENCODING const   *enc ,
                                           XML_Bool isCdata , char const   *ptr ,
                                           char const   *end , STRING_POOL *pool ) 
{ 
  DTD *dtd ;
  char const   *next ;
  int tok ;
  int tmp ;
  XML_Char buf[4] ;
  int i ;
  int n ;
  int tmp___0 ;
  XML_Char *tmp___2 ;
  int tmp___3 ;
  XML_Bool tmp___4 ;
  XML_Char *tmp___5 ;
  XML_Char *tmp___7 ;
  int tmp___8 ;
  XML_Bool tmp___9 ;
  XML_Char const   *name ;
  ENTITY *entity ;
  char checkEntityDecl ;
  XML_Char ch ;
  int tmp___10 ;
  XML_Char *tmp___12 ;
  int tmp___13 ;
  XML_Bool tmp___14 ;
  XML_Char *tmp___15 ;
  NAMED *tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  enum XML_Error result ;
  XML_Char const   *textEnd ;

  {
#line 4961
  dtd = parser->m_dtd;
  {
#line 4962
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 4964
    tmp = (*(enc->literalScanners[0]))(enc, ptr, end, & next);
#line 4964
    tok = tmp;
    }
    {
#line 4966
    if (tok == -4) {
#line 4966
      goto case_neg_4;
    }
#line 4968
    if (tok == 0) {
#line 4968
      goto case_0;
    }
#line 4972
    if (tok == -1) {
#line 4972
      goto case_neg_1;
    }
#line 4976
    if (tok == 10) {
#line 4976
      goto case_10;
    }
#line 5002
    if (tok == 6) {
#line 5002
      goto case_6;
    }
#line 5006
    if (tok == -3) {
#line 5006
      goto case_neg_3;
    }
#line 5010
    if (tok == 7) {
#line 5010
      goto case_7;
    }
#line 5010
    if (tok == 39) {
#line 5010
      goto case_7;
    }
#line 5016
    if (tok == 9) {
#line 5016
      goto case_9;
    }
#line 5096
    goto switch_default;
    case_neg_4: /* CIL Label */ 
#line 4967
    return ((enum XML_Error )0);
    case_0: /* CIL Label */ 
#line 4969
    if ((unsigned long )enc == (unsigned long )parser->m_encoding) {
#line 4970
      parser->m_eventPtr = next;
    }
#line 4971
    return ((enum XML_Error )4);
    case_neg_1: /* CIL Label */ 
#line 4973
    if ((unsigned long )enc == (unsigned long )parser->m_encoding) {
#line 4974
      parser->m_eventPtr = ptr;
    }
#line 4975
    return ((enum XML_Error )4);
    case_10: /* CIL Label */ 
    {
#line 4980
    tmp___0 = (*(enc->charRefNumber))(enc, ptr);
#line 4980
    n = tmp___0;
    }
#line 4981
    if (n < 0) {
#line 4982
      if ((unsigned long )enc == (unsigned long )parser->m_encoding) {
#line 4983
        parser->m_eventPtr = ptr;
      }
#line 4984
      return ((enum XML_Error )14);
    }
#line 4986
    if (! isCdata) {
#line 4986
      if (n == 32) {
#line 4986
        if (pool->ptr - pool->start == 0L) {
#line 4989
          goto switch_break;
        } else
#line 4986
        if ((int )*(pool->ptr + -1) == 32) {
#line 4989
          goto switch_break;
        }
      }
    }
    {
#line 4990
    n = XmlUtf8Encode(n, buf);
    }
#line 4991
    if (! n) {
#line 4992
      if ((unsigned long )enc == (unsigned long )parser->m_encoding) {
#line 4993
        parser->m_eventPtr = ptr;
      }
#line 4994
      return ((enum XML_Error )14);
    }
#line 4996
    i = 0;
    {
#line 4996
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 4996
      if (! (i < n)) {
#line 4996
        goto while_break___0;
      }
#line 4997
      if ((unsigned long )pool->ptr == (unsigned long )pool->end) {
        {
#line 4997
        tmp___4 = poolGrow(pool);
        }
#line 4997
        if (tmp___4) {
#line 4997
          tmp___2 = pool->ptr;
#line 4997
          (pool->ptr) ++;
#line 4997
          *tmp___2 = buf[i];
#line 4997
          tmp___3 = 1;
        } else {
#line 4997
          tmp___3 = 0;
        }
      } else {
#line 4997
        tmp___2 = pool->ptr;
#line 4997
        (pool->ptr) ++;
#line 4997
        *tmp___2 = buf[i];
#line 4997
        tmp___3 = 1;
      }
#line 4997
      if (! tmp___3) {
#line 4998
        return ((enum XML_Error )1);
      }
#line 4996
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 5001
    goto switch_break;
    case_6: /* CIL Label */ 
    {
#line 5003
    tmp___5 = poolAppend(pool, enc, ptr, next);
    }
#line 5003
    if (! tmp___5) {
#line 5004
      return ((enum XML_Error )1);
    }
#line 5005
    goto switch_break;
    case_neg_3: /* CIL Label */ 
#line 5007
    next = ptr + enc->minBytesPerChar;
    case_7: /* CIL Label */ 
    case_39: /* CIL Label */ 
#line 5011
    if (! isCdata) {
#line 5011
      if (pool->ptr - pool->start == 0L) {
#line 5012
        goto switch_break;
      } else
#line 5011
      if ((int )*(pool->ptr + -1) == 32) {
#line 5012
        goto switch_break;
      }
    }
#line 5013
    if ((unsigned long )pool->ptr == (unsigned long )pool->end) {
      {
#line 5013
      tmp___9 = poolGrow(pool);
      }
#line 5013
      if (tmp___9) {
#line 5013
        tmp___7 = pool->ptr;
#line 5013
        (pool->ptr) ++;
#line 5013
        *tmp___7 = (XML_Char )32;
#line 5013
        tmp___8 = 1;
      } else {
#line 5013
        tmp___8 = 0;
      }
    } else {
#line 5013
      tmp___7 = pool->ptr;
#line 5013
      (pool->ptr) ++;
#line 5013
      *tmp___7 = (XML_Char )32;
#line 5013
      tmp___8 = 1;
    }
#line 5013
    if (! tmp___8) {
#line 5014
      return ((enum XML_Error )1);
    }
#line 5015
    goto switch_break;
    case_9: /* CIL Label */ 
    {
#line 5021
    tmp___10 = (*(enc->predefinedEntityName))(enc, ptr + enc->minBytesPerChar, next - enc->minBytesPerChar);
#line 5021
    ch = (XML_Char )tmp___10;
    }
#line 5024
    if (ch) {
#line 5025
      if ((unsigned long )pool->ptr == (unsigned long )pool->end) {
        {
#line 5025
        tmp___14 = poolGrow(pool);
        }
#line 5025
        if (tmp___14) {
#line 5025
          tmp___12 = pool->ptr;
#line 5025
          (pool->ptr) ++;
#line 5025
          *tmp___12 = ch;
#line 5025
          tmp___13 = 1;
        } else {
#line 5025
          tmp___13 = 0;
        }
      } else {
#line 5025
        tmp___12 = pool->ptr;
#line 5025
        (pool->ptr) ++;
#line 5025
        *tmp___12 = ch;
#line 5025
        tmp___13 = 1;
      }
#line 5025
      if (! tmp___13) {
#line 5026
        return ((enum XML_Error )1);
      }
#line 5027
      goto switch_break;
    }
    {
#line 5029
    tmp___15 = poolStoreString(& parser->m_temp2Pool, enc, ptr + enc->minBytesPerChar,
                               next - enc->minBytesPerChar);
#line 5029
    name = (XML_Char const   *)tmp___15;
    }
#line 5032
    if (! name) {
#line 5033
      return ((enum XML_Error )1);
    }
    {
#line 5034
    tmp___16 = lookup(parser, & dtd->generalEntities, name, (size_t )0);
#line 5034
    entity = (ENTITY *)tmp___16;
#line 5035
    parser->m_temp2Pool.ptr = parser->m_temp2Pool.start;
    }
#line 5039
    if ((unsigned long )pool == (unsigned long )(& dtd->pool)) {
#line 5040
      if (parser->m_prologState.documentEntity) {
#line 5040
        if (dtd->standalone) {
#line 5040
          tmp___17 = ! parser->m_openInternalEntities;
        } else {
#line 5040
          tmp___17 = ! dtd->hasParamEntityRefs;
        }
#line 5040
        if (tmp___17) {
#line 5040
          tmp___18 = 1;
        } else {
#line 5040
          tmp___18 = 0;
        }
      } else {
#line 5040
        tmp___18 = 0;
      }
#line 5040
      checkEntityDecl = (char )tmp___18;
    } else {
#line 5048
      if (! dtd->hasParamEntityRefs) {
#line 5048
        tmp___19 = 1;
      } else
#line 5048
      if (dtd->standalone) {
#line 5048
        tmp___19 = 1;
      } else {
#line 5048
        tmp___19 = 0;
      }
#line 5048
      checkEntityDecl = (char )tmp___19;
    }
#line 5049
    if (checkEntityDecl) {
#line 5050
      if (! entity) {
#line 5051
        return ((enum XML_Error )11);
      } else
#line 5052
      if (! entity->is_internal) {
#line 5053
        return ((enum XML_Error )24);
      }
    } else
#line 5055
    if (! entity) {
#line 5066
      goto switch_break;
    }
#line 5068
    if (entity->open) {
#line 5069
      if ((unsigned long )enc == (unsigned long )parser->m_encoding) {
#line 5070
        parser->m_eventPtr = ptr;
      }
#line 5071
      return ((enum XML_Error )12);
    }
#line 5073
    if (entity->notation) {
#line 5074
      if ((unsigned long )enc == (unsigned long )parser->m_encoding) {
#line 5075
        parser->m_eventPtr = ptr;
      }
#line 5076
      return ((enum XML_Error )15);
    }
#line 5078
    if (! entity->textPtr) {
#line 5079
      if ((unsigned long )enc == (unsigned long )parser->m_encoding) {
#line 5080
        parser->m_eventPtr = ptr;
      }
#line 5081
      return ((enum XML_Error )16);
    } else {
      {
#line 5085
      textEnd = entity->textPtr + entity->textLen;
#line 5086
      entity->open = (XML_Bool )1;
#line 5087
      result = appendAttributeValue(parser, parser->m_internalEncoding, isCdata, (char const   *)((char *)entity->textPtr),
                                    (char const   *)((char *)textEnd), pool);
#line 5090
      entity->open = (XML_Bool )0;
      }
#line 5091
      if (result) {
#line 5092
        return (result);
      }
    }
#line 5095
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 5097
    if ((unsigned long )enc == (unsigned long )parser->m_encoding) {
#line 5098
      parser->m_eventPtr = ptr;
    }
#line 5099
    return ((enum XML_Error )23);
    switch_break: /* CIL Label */ ;
    }
#line 5101
    ptr = next;
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 5106 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlparse.c"
static enum XML_Error storeEntityValue(XML_Parser parser , ENCODING const   *enc ,
                                       char const   *entityTextPtr , char const   *entityTextEnd ) 
{ 
  DTD *dtd ;
  STRING_POOL *pool ;
  enum XML_Error result ;
  int oldInEntityValue ;
  XML_Bool tmp ;
  char const   *next ;
  int tok ;
  int tmp___0 ;
  XML_Char const   *name ;
  ENTITY *entity ;
  XML_Char *tmp___1 ;
  NAMED *tmp___2 ;
  int tmp___3 ;
  XML_Char *tmp___4 ;
  XML_Bool tmp___5 ;
  XML_Char *tmp___6 ;
  XML_Char buf[4] ;
  int i ;
  int n ;
  int tmp___7 ;
  XML_Bool tmp___8 ;
  XML_Char *tmp___9 ;

  {
#line 5112
  dtd = parser->m_dtd;
#line 5113
  pool = & dtd->entityValuePool;
#line 5114
  result = (enum XML_Error )0;
#line 5116
  oldInEntityValue = parser->m_prologState.inEntityValue;
#line 5117
  parser->m_prologState.inEntityValue = 1;
#line 5122
  if (! pool->blocks) {
    {
#line 5123
    tmp = poolGrow(pool);
    }
#line 5123
    if (! tmp) {
#line 5124
      return ((enum XML_Error )1);
    }
  }
  {
#line 5127
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 5129
    tmp___0 = (*(enc->literalScanners[1]))(enc, entityTextPtr, entityTextEnd, & next);
#line 5129
    tok = tmp___0;
    }
    {
#line 5131
    if (tok == 28) {
#line 5131
      goto case_28;
    }
#line 5200
    if (tok == -4) {
#line 5200
      goto case_neg_4;
    }
#line 5204
    if (tok == 6) {
#line 5204
      goto case_6;
    }
#line 5204
    if (tok == 9) {
#line 5204
      goto case_6;
    }
#line 5210
    if (tok == -3) {
#line 5210
      goto case_neg_3;
    }
#line 5213
    if (tok == 7) {
#line 5213
      goto case_7;
    }
#line 5220
    if (tok == 10) {
#line 5220
      goto case_10;
    }
#line 5247
    if (tok == -1) {
#line 5247
      goto case_neg_1;
    }
#line 5252
    if (tok == 0) {
#line 5252
      goto case_0;
    }
#line 5257
    goto switch_default;
    case_28: /* CIL Label */ 
#line 5133
    if (parser->m_isParamEntity) {
#line 5133
      goto _L;
    } else
#line 5133
    if ((unsigned long )enc != (unsigned long )parser->m_encoding) {
      _L: /* CIL Label */ 
      {
#line 5136
      tmp___1 = poolStoreString(& parser->m_tempPool, enc, entityTextPtr + enc->minBytesPerChar,
                                next - enc->minBytesPerChar);
#line 5136
      name = (XML_Char const   *)tmp___1;
      }
#line 5139
      if (! name) {
#line 5140
        result = (enum XML_Error )1;
#line 5141
        goto endEntityValue;
      }
      {
#line 5143
      tmp___2 = lookup(parser, & dtd->paramEntities, name, (size_t )0);
#line 5143
      entity = (ENTITY *)tmp___2;
#line 5144
      parser->m_tempPool.ptr = parser->m_tempPool.start;
      }
#line 5145
      if (! entity) {
#line 5152
        dtd->keepProcessing = dtd->standalone;
#line 5153
        goto endEntityValue;
      }
#line 5155
      if (entity->open) {
#line 5156
        if ((unsigned long )enc == (unsigned long )parser->m_encoding) {
#line 5157
          parser->m_eventPtr = entityTextPtr;
        }
#line 5158
        result = (enum XML_Error )12;
#line 5159
        goto endEntityValue;
      }
#line 5161
      if (entity->systemId) {
#line 5162
        if (parser->m_externalEntityRefHandler) {
          {
#line 5163
          dtd->paramEntityRead = (XML_Bool )0;
#line 5164
          entity->open = (XML_Bool )1;
#line 5165
          tmp___3 = (*(parser->m_externalEntityRefHandler))(parser->m_externalEntityRefHandlerArg,
                                                            (XML_Char const   *)0,
                                                            entity->base, entity->systemId,
                                                            entity->publicId);
          }
#line 5165
          if (! tmp___3) {
#line 5170
            entity->open = (XML_Bool )0;
#line 5171
            result = (enum XML_Error )21;
#line 5172
            goto endEntityValue;
          }
#line 5174
          entity->open = (XML_Bool )0;
#line 5175
          if (! dtd->paramEntityRead) {
#line 5176
            dtd->keepProcessing = dtd->standalone;
          }
        } else {
#line 5179
          dtd->keepProcessing = dtd->standalone;
        }
      } else {
        {
#line 5182
        entity->open = (XML_Bool )1;
#line 5183
        result = storeEntityValue(parser, parser->m_internalEncoding, (char const   *)((char *)entity->textPtr),
                                  (char const   *)((char *)(entity->textPtr + entity->textLen)));
#line 5188
        entity->open = (XML_Bool )0;
        }
#line 5189
        if (result) {
#line 5190
          goto endEntityValue;
        }
      }
#line 5192
      goto switch_break;
    }
#line 5197
    parser->m_eventPtr = entityTextPtr;
#line 5198
    result = (enum XML_Error )10;
#line 5199
    goto endEntityValue;
    case_neg_4: /* CIL Label */ 
#line 5201
    result = (enum XML_Error )0;
#line 5202
    goto endEntityValue;
    case_6: /* CIL Label */ 
    case_9: /* CIL Label */ 
    {
#line 5205
    tmp___4 = poolAppend(pool, enc, entityTextPtr, next);
    }
#line 5205
    if (! tmp___4) {
#line 5206
      result = (enum XML_Error )1;
#line 5207
      goto endEntityValue;
    }
#line 5209
    goto switch_break;
    case_neg_3: /* CIL Label */ 
#line 5211
    next = entityTextPtr + enc->minBytesPerChar;
    case_7: /* CIL Label */ 
#line 5214
    if ((unsigned long )pool->end == (unsigned long )pool->ptr) {
      {
#line 5214
      tmp___5 = poolGrow(pool);
      }
#line 5214
      if (! tmp___5) {
#line 5215
        result = (enum XML_Error )1;
#line 5216
        goto endEntityValue;
      }
    }
#line 5218
    tmp___6 = pool->ptr;
#line 5218
    (pool->ptr) ++;
#line 5218
    *tmp___6 = (XML_Char )10;
#line 5219
    goto switch_break;
    case_10: /* CIL Label */ 
    {
#line 5224
    tmp___7 = (*(enc->charRefNumber))(enc, entityTextPtr);
#line 5224
    n = tmp___7;
    }
#line 5225
    if (n < 0) {
#line 5226
      if ((unsigned long )enc == (unsigned long )parser->m_encoding) {
#line 5227
        parser->m_eventPtr = entityTextPtr;
      }
#line 5228
      result = (enum XML_Error )14;
#line 5229
      goto endEntityValue;
    }
    {
#line 5231
    n = XmlUtf8Encode(n, buf);
    }
#line 5232
    if (! n) {
#line 5233
      if ((unsigned long )enc == (unsigned long )parser->m_encoding) {
#line 5234
        parser->m_eventPtr = entityTextPtr;
      }
#line 5235
      result = (enum XML_Error )14;
#line 5236
      goto endEntityValue;
    }
#line 5238
    i = 0;
    {
#line 5238
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 5238
      if (! (i < n)) {
#line 5238
        goto while_break___0;
      }
#line 5239
      if ((unsigned long )pool->end == (unsigned long )pool->ptr) {
        {
#line 5239
        tmp___8 = poolGrow(pool);
        }
#line 5239
        if (! tmp___8) {
#line 5240
          result = (enum XML_Error )1;
#line 5241
          goto endEntityValue;
        }
      }
#line 5243
      tmp___9 = pool->ptr;
#line 5243
      (pool->ptr) ++;
#line 5243
      *tmp___9 = buf[i];
#line 5238
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 5246
    goto switch_break;
    case_neg_1: /* CIL Label */ 
#line 5248
    if ((unsigned long )enc == (unsigned long )parser->m_encoding) {
#line 5249
      parser->m_eventPtr = entityTextPtr;
    }
#line 5250
    result = (enum XML_Error )4;
#line 5251
    goto endEntityValue;
    case_0: /* CIL Label */ 
#line 5253
    if ((unsigned long )enc == (unsigned long )parser->m_encoding) {
#line 5254
      parser->m_eventPtr = next;
    }
#line 5255
    result = (enum XML_Error )4;
#line 5256
    goto endEntityValue;
    switch_default: /* CIL Label */ 
#line 5258
    if ((unsigned long )enc == (unsigned long )parser->m_encoding) {
#line 5259
      parser->m_eventPtr = entityTextPtr;
    }
#line 5260
    result = (enum XML_Error )23;
#line 5261
    goto endEntityValue;
    switch_break: /* CIL Label */ ;
    }
#line 5263
    entityTextPtr = next;
  }
  while_break: /* CIL Label */ ;
  }
  endEntityValue: 
#line 5267
  parser->m_prologState.inEntityValue = oldInEntityValue;
#line 5269
  return (result);
}
}
#line 5272 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlparse.c"
static void normalizeLines(XML_Char *s ) 
{ 
  XML_Char *p ;
  XML_Char *tmp ;
  XML_Char *tmp___0 ;
  XML_Char *tmp___1 ;

  {
  {
#line 5276
  while (1) {
    while_continue: /* CIL Label */ ;
#line 5277
    if ((int )*s == 0) {
#line 5278
      return;
    }
#line 5279
    if ((int )*s == 13) {
#line 5280
      goto while_break;
    }
#line 5276
    s ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 5282
  p = s;
  {
#line 5283
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 5284
    if ((int )*s == 13) {
#line 5285
      tmp = p;
#line 5285
      p ++;
#line 5285
      *tmp = (XML_Char )10;
#line 5286
      s ++;
#line 5286
      if ((int )*s == 10) {
#line 5287
        s ++;
      }
    } else {
#line 5290
      tmp___0 = p;
#line 5290
      p ++;
#line 5290
      tmp___1 = s;
#line 5290
      s ++;
#line 5290
      *tmp___0 = *tmp___1;
    }
#line 5283
    if (! *s) {
#line 5283
      goto while_break___0;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 5292
  *p = (XML_Char )'\000';
#line 5293
  return;
}
}
#line 5295 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlparse.c"
static int reportProcessingInstruction(XML_Parser parser , ENCODING const   *enc ,
                                       char const   *start , char const   *end ) 
{ 
  XML_Char const   *target ;
  XML_Char *data ;
  char const   *tem ;
  int tmp ;
  XML_Char *tmp___0 ;
  char const   *tmp___1 ;

  {
#line 5302
  if (! parser->m_processingInstructionHandler) {
#line 5303
    if (parser->m_defaultHandler) {
      {
#line 5304
      reportDefault(parser, enc, start, end);
      }
    }
#line 5305
    return (1);
  }
  {
#line 5307
  start += enc->minBytesPerChar * 2;
#line 5308
  tmp = (*(enc->nameLength))(enc, start);
#line 5308
  tem = start + tmp;
#line 5309
  tmp___0 = poolStoreString(& parser->m_tempPool, enc, start, tem);
#line 5309
  target = (XML_Char const   *)tmp___0;
  }
#line 5310
  if (! target) {
#line 5311
    return (0);
  }
  {
#line 5312
  parser->m_tempPool.start = parser->m_tempPool.ptr;
#line 5313
  tmp___1 = (*(enc->skipS))(enc, tem);
#line 5313
  data = poolStoreString(& parser->m_tempPool, enc, tmp___1, end - enc->minBytesPerChar * 2);
  }
#line 5316
  if (! data) {
#line 5317
    return (0);
  }
  {
#line 5318
  normalizeLines(data);
#line 5319
  (*(parser->m_processingInstructionHandler))(parser->m_handlerArg, target, (XML_Char const   *)data);
#line 5320
  poolClear(& parser->m_tempPool);
  }
#line 5321
  return (1);
}
}
#line 5324 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlparse.c"
static int reportComment(XML_Parser parser , ENCODING const   *enc , char const   *start ,
                         char const   *end ) 
{ 
  XML_Char *data ;

  {
#line 5329
  if (! parser->m_commentHandler) {
#line 5330
    if (parser->m_defaultHandler) {
      {
#line 5331
      reportDefault(parser, enc, start, end);
      }
    }
#line 5332
    return (1);
  }
  {
#line 5334
  data = poolStoreString(& parser->m_tempPool, enc, start + enc->minBytesPerChar * 4,
                         end - enc->minBytesPerChar * 3);
  }
#line 5338
  if (! data) {
#line 5339
    return (0);
  }
  {
#line 5340
  normalizeLines(data);
#line 5341
  (*(parser->m_commentHandler))(parser->m_handlerArg, (XML_Char const   *)data);
#line 5342
  poolClear(& parser->m_tempPool);
  }
#line 5343
  return (1);
}
}
#line 5346 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlparse.c"
static void reportDefault(XML_Parser parser , ENCODING const   *enc , char const   *s ,
                          char const   *end ) 
{ 
  char const   **eventPP ;
  char const   **eventEndPP ;
  ICHAR *dataPtr ;

  {
#line 5350
  if (! enc->isUtf8) {
#line 5353
    if ((unsigned long )enc == (unsigned long )parser->m_encoding) {
#line 5354
      eventPP = & parser->m_eventPtr;
#line 5355
      eventEndPP = & parser->m_eventEndPtr;
    } else {
#line 5358
      eventPP = & (parser->m_openInternalEntities)->internalEventPtr;
#line 5359
      eventEndPP = & (parser->m_openInternalEntities)->internalEventEndPtr;
    }
    {
#line 5361
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 5362
      dataPtr = parser->m_dataBuf;
#line 5363
      (*(enc->utf8Convert))(enc, & s, end, & dataPtr, (char const   *)parser->m_dataBufEnd);
#line 5364
      *eventEndPP = s;
#line 5365
      (*(parser->m_defaultHandler))(parser->m_handlerArg, (XML_Char const   *)parser->m_dataBuf,
                                    (int )(dataPtr - parser->m_dataBuf));
#line 5366
      *eventPP = s;
      }
#line 5361
      if (! ((unsigned long )s != (unsigned long )end)) {
#line 5361
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
  } else {
    {
#line 5370
    (*(parser->m_defaultHandler))(parser->m_handlerArg, (XML_Char const   *)((XML_Char *)s),
                                  (int )((XML_Char *)end - (XML_Char *)s));
    }
  }
#line 5371
  return;
}
}
#line 5374 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlparse.c"
static int defineAttribute(ELEMENT_TYPE *type , ATTRIBUTE_ID *attId , XML_Bool isCdata ,
                           XML_Bool isId , XML_Char const   *value , XML_Parser parser ) 
{ 
  DEFAULT_ATTRIBUTE *att ;
  int i ;
  void *tmp ;
  DEFAULT_ATTRIBUTE *temp ;
  int count ;
  void *tmp___0 ;

  {
#line 5379
  if (value) {
#line 5379
    goto _L;
  } else
#line 5379
  if (isId) {
    _L: /* CIL Label */ 
#line 5383
    i = 0;
    {
#line 5383
    while (1) {
      while_continue: /* CIL Label */ ;
#line 5383
      if (! (i < type->nDefaultAtts)) {
#line 5383
        goto while_break;
      }
#line 5384
      if ((unsigned long )attId == (unsigned long )(type->defaultAtts + i)->id) {
#line 5385
        return (1);
      }
#line 5383
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 5386
    if (isId) {
#line 5386
      if (! type->idAtt) {
#line 5386
        if (! attId->xmlns) {
#line 5387
          type->idAtt = (ATTRIBUTE_ID const   *)attId;
        }
      }
    }
  }
#line 5389
  if (type->nDefaultAtts == type->allocDefaultAtts) {
#line 5390
    if (type->allocDefaultAtts == 0) {
      {
#line 5391
      type->allocDefaultAtts = 8;
#line 5392
      tmp = (*(parser->m_mem.malloc_fcn))((unsigned long )type->allocDefaultAtts * sizeof(DEFAULT_ATTRIBUTE ));
#line 5392
      type->defaultAtts = (DEFAULT_ATTRIBUTE *)tmp;
      }
#line 5394
      if (! type->defaultAtts) {
#line 5395
        return (0);
      }
    } else {
      {
#line 5399
      count = type->allocDefaultAtts * 2;
#line 5400
      tmp___0 = (*(parser->m_mem.realloc_fcn))((void *)type->defaultAtts, (unsigned long )count * sizeof(DEFAULT_ATTRIBUTE ));
#line 5400
      temp = (DEFAULT_ATTRIBUTE *)tmp___0;
      }
#line 5402
      if ((unsigned long )temp == (unsigned long )((void *)0)) {
#line 5403
        return (0);
      }
#line 5404
      type->allocDefaultAtts = count;
#line 5405
      type->defaultAtts = temp;
    }
  }
#line 5408
  att = type->defaultAtts + type->nDefaultAtts;
#line 5409
  att->id = (ATTRIBUTE_ID const   *)attId;
#line 5410
  att->value = value;
#line 5411
  att->isCdata = isCdata;
#line 5412
  if (! isCdata) {
#line 5413
    attId->maybeTokenized = (XML_Bool )1;
  }
#line 5414
  (type->nDefaultAtts) ++;
#line 5415
  return (1);
}
}
#line 5418 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlparse.c"
static int setElementTypePrefix(XML_Parser parser , ELEMENT_TYPE *elementType ) 
{ 
  DTD *dtd ;
  XML_Char const   *name ;
  PREFIX *prefix ;
  XML_Char const   *s ;
  XML_Char *tmp___0 ;
  int tmp___1 ;
  XML_Bool tmp___2 ;
  XML_Char *tmp___4 ;
  int tmp___5 ;
  XML_Bool tmp___6 ;
  NAMED *tmp___7 ;

  {
#line 5421
  dtd = parser->m_dtd;
#line 5423
  name = elementType->name;
  {
#line 5423
  while (1) {
    while_continue: /* CIL Label */ ;
#line 5423
    if (! *name) {
#line 5423
      goto while_break;
    }
#line 5424
    if ((int const   )*name == 58) {
#line 5427
      s = elementType->name;
      {
#line 5427
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 5427
        if (! ((unsigned long )s != (unsigned long )name)) {
#line 5427
          goto while_break___0;
        }
#line 5428
        if ((unsigned long )dtd->pool.ptr == (unsigned long )dtd->pool.end) {
          {
#line 5428
          tmp___2 = poolGrow(& dtd->pool);
          }
#line 5428
          if (tmp___2) {
#line 5428
            tmp___0 = dtd->pool.ptr;
#line 5428
            (dtd->pool.ptr) ++;
#line 5428
            *tmp___0 = (XML_Char )*s;
#line 5428
            tmp___1 = 1;
          } else {
#line 5428
            tmp___1 = 0;
          }
        } else {
#line 5428
          tmp___0 = dtd->pool.ptr;
#line 5428
          (dtd->pool.ptr) ++;
#line 5428
          *tmp___0 = (XML_Char )*s;
#line 5428
          tmp___1 = 1;
        }
#line 5428
        if (! tmp___1) {
#line 5429
          return (0);
        }
#line 5427
        s ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 5431
      if ((unsigned long )dtd->pool.ptr == (unsigned long )dtd->pool.end) {
        {
#line 5431
        tmp___6 = poolGrow(& dtd->pool);
        }
#line 5431
        if (tmp___6) {
#line 5431
          tmp___4 = dtd->pool.ptr;
#line 5431
          (dtd->pool.ptr) ++;
#line 5431
          *tmp___4 = (XML_Char )'\000';
#line 5431
          tmp___5 = 1;
        } else {
#line 5431
          tmp___5 = 0;
        }
      } else {
#line 5431
        tmp___4 = dtd->pool.ptr;
#line 5431
        (dtd->pool.ptr) ++;
#line 5431
        *tmp___4 = (XML_Char )'\000';
#line 5431
        tmp___5 = 1;
      }
#line 5431
      if (! tmp___5) {
#line 5432
        return (0);
      }
      {
#line 5433
      tmp___7 = lookup(parser, & dtd->prefixes, (KEY )dtd->pool.start, sizeof(PREFIX ));
#line 5433
      prefix = (PREFIX *)tmp___7;
      }
#line 5435
      if (! prefix) {
#line 5436
        return (0);
      }
#line 5437
      if ((unsigned long )prefix->name == (unsigned long )dtd->pool.start) {
#line 5438
        dtd->pool.start = dtd->pool.ptr;
      } else {
#line 5440
        dtd->pool.ptr = dtd->pool.start;
      }
#line 5441
      elementType->prefix = prefix;
    }
#line 5423
    name ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 5445
  return (1);
}
}
#line 5448 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlparse.c"
static ATTRIBUTE_ID *getAttributeId(XML_Parser parser , ENCODING const   *enc , char const   *start ,
                                    char const   *end ) 
{ 
  DTD *dtd ;
  ATTRIBUTE_ID *id ;
  XML_Char const   *name ;
  XML_Char *tmp___0 ;
  int tmp___1 ;
  XML_Bool tmp___2 ;
  XML_Char *tmp___3 ;
  NAMED *tmp___4 ;
  NAMED *tmp___5 ;
  int i ;
  int j ;
  XML_Char *tmp___7 ;
  int tmp___8 ;
  XML_Bool tmp___9 ;
  XML_Char *tmp___11 ;
  int tmp___12 ;
  XML_Bool tmp___13 ;
  NAMED *tmp___14 ;

  {
#line 5452
  dtd = parser->m_dtd;
#line 5455
  if ((unsigned long )dtd->pool.ptr == (unsigned long )dtd->pool.end) {
    {
#line 5455
    tmp___2 = poolGrow(& dtd->pool);
    }
#line 5455
    if (tmp___2) {
#line 5455
      tmp___0 = dtd->pool.ptr;
#line 5455
      (dtd->pool.ptr) ++;
#line 5455
      *tmp___0 = (XML_Char )'\000';
#line 5455
      tmp___1 = 1;
    } else {
#line 5455
      tmp___1 = 0;
    }
  } else {
#line 5455
    tmp___0 = dtd->pool.ptr;
#line 5455
    (dtd->pool.ptr) ++;
#line 5455
    *tmp___0 = (XML_Char )'\000';
#line 5455
    tmp___1 = 1;
  }
#line 5455
  if (! tmp___1) {
#line 5456
    return ((ATTRIBUTE_ID *)((void *)0));
  }
  {
#line 5457
  tmp___3 = poolStoreString(& dtd->pool, enc, start, end);
#line 5457
  name = (XML_Char const   *)tmp___3;
  }
#line 5458
  if (! name) {
#line 5459
    return ((ATTRIBUTE_ID *)((void *)0));
  }
  {
#line 5461
  name ++;
#line 5462
  tmp___4 = lookup(parser, & dtd->attributeIds, name, sizeof(ATTRIBUTE_ID ));
#line 5462
  id = (ATTRIBUTE_ID *)tmp___4;
  }
#line 5463
  if (! id) {
#line 5464
    return ((ATTRIBUTE_ID *)((void *)0));
  }
#line 5465
  if ((unsigned long )id->name != (unsigned long )name) {
#line 5466
    dtd->pool.ptr = dtd->pool.start;
  } else {
#line 5468
    dtd->pool.start = dtd->pool.ptr;
#line 5469
    if (! (! parser->m_ns)) {
#line 5471
      if ((int const   )*(name + 0) == 120) {
#line 5471
        if ((int const   )*(name + 1) == 109) {
#line 5471
          if ((int const   )*(name + 2) == 108) {
#line 5471
            if ((int const   )*(name + 3) == 110) {
#line 5471
              if ((int const   )*(name + 4) == 115) {
#line 5471
                if ((int const   )*(name + 5) == 0) {
#line 5471
                  goto _L___0;
                } else
#line 5471
                if ((int const   )*(name + 5) == 58) {
                  _L___0: /* CIL Label */ 
#line 5477
                  if ((int const   )*(name + 5) == 0) {
#line 5478
                    id->prefix = & dtd->defaultPrefix;
                  } else {
                    {
#line 5480
                    tmp___5 = lookup(parser, & dtd->prefixes, name + 6, sizeof(PREFIX ));
#line 5480
                    id->prefix = (PREFIX *)tmp___5;
                    }
                  }
#line 5481
                  id->xmlns = (XML_Bool )1;
                } else {
#line 5471
                  goto _L___4;
                }
              } else {
#line 5471
                goto _L___4;
              }
            } else {
#line 5471
              goto _L___4;
            }
          } else {
#line 5471
            goto _L___4;
          }
        } else {
#line 5471
          goto _L___4;
        }
      } else {
        _L___4: /* CIL Label */ 
#line 5485
        i = 0;
        {
#line 5485
        while (1) {
          while_continue: /* CIL Label */ ;
#line 5485
          if (! *(name + i)) {
#line 5485
            goto while_break;
          }
#line 5487
          if ((int const   )*(name + i) == 58) {
#line 5489
            j = 0;
            {
#line 5489
            while (1) {
              while_continue___0: /* CIL Label */ ;
#line 5489
              if (! (j < i)) {
#line 5489
                goto while_break___0;
              }
#line 5490
              if ((unsigned long )dtd->pool.ptr == (unsigned long )dtd->pool.end) {
                {
#line 5490
                tmp___9 = poolGrow(& dtd->pool);
                }
#line 5490
                if (tmp___9) {
#line 5490
                  tmp___7 = dtd->pool.ptr;
#line 5490
                  (dtd->pool.ptr) ++;
#line 5490
                  *tmp___7 = (XML_Char )*(name + j);
#line 5490
                  tmp___8 = 1;
                } else {
#line 5490
                  tmp___8 = 0;
                }
              } else {
#line 5490
                tmp___7 = dtd->pool.ptr;
#line 5490
                (dtd->pool.ptr) ++;
#line 5490
                *tmp___7 = (XML_Char )*(name + j);
#line 5490
                tmp___8 = 1;
              }
#line 5490
              if (! tmp___8) {
#line 5491
                return ((ATTRIBUTE_ID *)((void *)0));
              }
#line 5489
              j ++;
            }
            while_break___0: /* CIL Label */ ;
            }
#line 5493
            if ((unsigned long )dtd->pool.ptr == (unsigned long )dtd->pool.end) {
              {
#line 5493
              tmp___13 = poolGrow(& dtd->pool);
              }
#line 5493
              if (tmp___13) {
#line 5493
                tmp___11 = dtd->pool.ptr;
#line 5493
                (dtd->pool.ptr) ++;
#line 5493
                *tmp___11 = (XML_Char )'\000';
#line 5493
                tmp___12 = 1;
              } else {
#line 5493
                tmp___12 = 0;
              }
            } else {
#line 5493
              tmp___11 = dtd->pool.ptr;
#line 5493
              (dtd->pool.ptr) ++;
#line 5493
              *tmp___11 = (XML_Char )'\000';
#line 5493
              tmp___12 = 1;
            }
#line 5493
            if (! tmp___12) {
#line 5494
              return ((ATTRIBUTE_ID *)((void *)0));
            }
            {
#line 5495
            tmp___14 = lookup(parser, & dtd->prefixes, (KEY )dtd->pool.start, sizeof(PREFIX ));
#line 5495
            id->prefix = (PREFIX *)tmp___14;
            }
#line 5497
            if ((unsigned long )(id->prefix)->name == (unsigned long )dtd->pool.start) {
#line 5498
              dtd->pool.start = dtd->pool.ptr;
            } else {
#line 5500
              dtd->pool.ptr = dtd->pool.start;
            }
#line 5501
            goto while_break;
          }
#line 5485
          i ++;
        }
        while_break: /* CIL Label */ ;
        }
      }
    }
  }
#line 5506
  return (id);
}
}
#line 5511 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlparse.c"
static XML_Char const   *getContext(XML_Parser parser ) 
{ 
  DTD *dtd ;
  HASH_TABLE_ITER iter ;
  XML_Bool needSep ;
  int i ;
  int len ;
  XML_Char *tmp___0 ;
  int tmp___1 ;
  XML_Bool tmp___2 ;
  XML_Char *tmp___4 ;
  int tmp___5 ;
  XML_Bool tmp___6 ;
  int i___0 ;
  int len___0 ;
  XML_Char const   *s ;
  PREFIX *prefix ;
  NAMED *tmp___7 ;
  XML_Char *tmp___9 ;
  int tmp___10 ;
  XML_Bool tmp___11 ;
  XML_Char *tmp___13 ;
  int tmp___14 ;
  XML_Bool tmp___15 ;
  XML_Char *tmp___17 ;
  int tmp___18 ;
  XML_Bool tmp___19 ;
  XML_Char *tmp___21 ;
  int tmp___22 ;
  XML_Bool tmp___23 ;
  XML_Char const   *s___0 ;
  ENTITY *e ;
  NAMED *tmp___24 ;
  XML_Char *tmp___26 ;
  int tmp___27 ;
  XML_Bool tmp___28 ;
  XML_Char *tmp___30 ;
  int tmp___31 ;
  XML_Bool tmp___32 ;
  XML_Char *tmp___34 ;
  int tmp___35 ;
  XML_Bool tmp___36 ;

  {
#line 5514
  dtd = parser->m_dtd;
#line 5516
  needSep = (XML_Bool )0;
#line 5518
  if (dtd->defaultPrefix.binding) {
#line 5521
    if ((unsigned long )parser->m_tempPool.ptr == (unsigned long )parser->m_tempPool.end) {
      {
#line 5521
      tmp___2 = poolGrow(& parser->m_tempPool);
      }
#line 5521
      if (tmp___2) {
#line 5521
        tmp___0 = parser->m_tempPool.ptr;
#line 5521
        (parser->m_tempPool.ptr) ++;
#line 5521
        *tmp___0 = (XML_Char )61;
#line 5521
        tmp___1 = 1;
      } else {
#line 5521
        tmp___1 = 0;
      }
    } else {
#line 5521
      tmp___0 = parser->m_tempPool.ptr;
#line 5521
      (parser->m_tempPool.ptr) ++;
#line 5521
      *tmp___0 = (XML_Char )61;
#line 5521
      tmp___1 = 1;
    }
#line 5521
    if (! tmp___1) {
#line 5522
      return ((XML_Char const   *)((void *)0));
    }
#line 5523
    len = (dtd->defaultPrefix.binding)->uriLen;
#line 5524
    if (parser->m_namespaceSeparator) {
#line 5525
      len --;
    }
#line 5526
    i = 0;
    {
#line 5526
    while (1) {
      while_continue: /* CIL Label */ ;
#line 5526
      if (! (i < len)) {
#line 5526
        goto while_break;
      }
#line 5527
      if ((unsigned long )parser->m_tempPool.ptr == (unsigned long )parser->m_tempPool.end) {
        {
#line 5527
        tmp___6 = poolGrow(& parser->m_tempPool);
        }
#line 5527
        if (tmp___6) {
#line 5527
          tmp___4 = parser->m_tempPool.ptr;
#line 5527
          (parser->m_tempPool.ptr) ++;
#line 5527
          *tmp___4 = *((dtd->defaultPrefix.binding)->uri + i);
#line 5527
          tmp___5 = 1;
        } else {
#line 5527
          tmp___5 = 0;
        }
      } else {
#line 5527
        tmp___4 = parser->m_tempPool.ptr;
#line 5527
        (parser->m_tempPool.ptr) ++;
#line 5527
        *tmp___4 = *((dtd->defaultPrefix.binding)->uri + i);
#line 5527
        tmp___5 = 1;
      }
#line 5527
      if (! tmp___5) {
#line 5528
        return ((XML_Char const   *)((void *)0));
      }
#line 5526
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 5529
    needSep = (XML_Bool )1;
  }
  {
#line 5532
  hashTableIterInit(& iter, (HASH_TABLE const   *)(& dtd->prefixes));
  }
  {
#line 5533
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 5537
    tmp___7 = hashTableIterNext(& iter);
#line 5537
    prefix = (PREFIX *)tmp___7;
    }
#line 5538
    if (! prefix) {
#line 5539
      goto while_break___0;
    }
#line 5540
    if (! prefix->binding) {
#line 5541
      goto __Cont;
    }
#line 5542
    if (needSep) {
#line 5542
      if ((unsigned long )parser->m_tempPool.ptr == (unsigned long )parser->m_tempPool.end) {
        {
#line 5542
        tmp___11 = poolGrow(& parser->m_tempPool);
        }
#line 5542
        if (tmp___11) {
#line 5542
          tmp___9 = parser->m_tempPool.ptr;
#line 5542
          (parser->m_tempPool.ptr) ++;
#line 5542
          *tmp___9 = (XML_Char )12;
#line 5542
          tmp___10 = 1;
        } else {
#line 5542
          tmp___10 = 0;
        }
      } else {
#line 5542
        tmp___9 = parser->m_tempPool.ptr;
#line 5542
        (parser->m_tempPool.ptr) ++;
#line 5542
        *tmp___9 = (XML_Char )12;
#line 5542
        tmp___10 = 1;
      }
#line 5542
      if (! tmp___10) {
#line 5543
        return ((XML_Char const   *)((void *)0));
      }
    }
#line 5544
    s = prefix->name;
    {
#line 5544
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 5544
      if (! *s) {
#line 5544
        goto while_break___1;
      }
#line 5545
      if ((unsigned long )parser->m_tempPool.ptr == (unsigned long )parser->m_tempPool.end) {
        {
#line 5545
        tmp___15 = poolGrow(& parser->m_tempPool);
        }
#line 5545
        if (tmp___15) {
#line 5545
          tmp___13 = parser->m_tempPool.ptr;
#line 5545
          (parser->m_tempPool.ptr) ++;
#line 5545
          *tmp___13 = (XML_Char )*s;
#line 5545
          tmp___14 = 1;
        } else {
#line 5545
          tmp___14 = 0;
        }
      } else {
#line 5545
        tmp___13 = parser->m_tempPool.ptr;
#line 5545
        (parser->m_tempPool.ptr) ++;
#line 5545
        *tmp___13 = (XML_Char )*s;
#line 5545
        tmp___14 = 1;
      }
#line 5545
      if (! tmp___14) {
#line 5546
        return ((XML_Char const   *)((void *)0));
      }
#line 5544
      s ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 5547
    if ((unsigned long )parser->m_tempPool.ptr == (unsigned long )parser->m_tempPool.end) {
      {
#line 5547
      tmp___19 = poolGrow(& parser->m_tempPool);
      }
#line 5547
      if (tmp___19) {
#line 5547
        tmp___17 = parser->m_tempPool.ptr;
#line 5547
        (parser->m_tempPool.ptr) ++;
#line 5547
        *tmp___17 = (XML_Char )61;
#line 5547
        tmp___18 = 1;
      } else {
#line 5547
        tmp___18 = 0;
      }
    } else {
#line 5547
      tmp___17 = parser->m_tempPool.ptr;
#line 5547
      (parser->m_tempPool.ptr) ++;
#line 5547
      *tmp___17 = (XML_Char )61;
#line 5547
      tmp___18 = 1;
    }
#line 5547
    if (! tmp___18) {
#line 5548
      return ((XML_Char const   *)((void *)0));
    }
#line 5549
    len___0 = (prefix->binding)->uriLen;
#line 5550
    if (parser->m_namespaceSeparator) {
#line 5551
      len___0 --;
    }
#line 5552
    i___0 = 0;
    {
#line 5552
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 5552
      if (! (i___0 < len___0)) {
#line 5552
        goto while_break___2;
      }
#line 5553
      if ((unsigned long )parser->m_tempPool.ptr == (unsigned long )parser->m_tempPool.end) {
        {
#line 5553
        tmp___23 = poolGrow(& parser->m_tempPool);
        }
#line 5553
        if (tmp___23) {
#line 5553
          tmp___21 = parser->m_tempPool.ptr;
#line 5553
          (parser->m_tempPool.ptr) ++;
#line 5553
          *tmp___21 = *((prefix->binding)->uri + i___0);
#line 5553
          tmp___22 = 1;
        } else {
#line 5553
          tmp___22 = 0;
        }
      } else {
#line 5553
        tmp___21 = parser->m_tempPool.ptr;
#line 5553
        (parser->m_tempPool.ptr) ++;
#line 5553
        *tmp___21 = *((prefix->binding)->uri + i___0);
#line 5553
        tmp___22 = 1;
      }
#line 5553
      if (! tmp___22) {
#line 5554
        return ((XML_Char const   *)((void *)0));
      }
#line 5552
      i___0 ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 5555
    needSep = (XML_Bool )1;
    __Cont: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 5559
  hashTableIterInit(& iter, (HASH_TABLE const   *)(& dtd->generalEntities));
  }
  {
#line 5560
  while (1) {
    while_continue___3: /* CIL Label */ ;
    {
#line 5562
    tmp___24 = hashTableIterNext(& iter);
#line 5562
    e = (ENTITY *)tmp___24;
    }
#line 5563
    if (! e) {
#line 5564
      goto while_break___3;
    }
#line 5565
    if (! e->open) {
#line 5566
      goto __Cont___0;
    }
#line 5567
    if (needSep) {
#line 5567
      if ((unsigned long )parser->m_tempPool.ptr == (unsigned long )parser->m_tempPool.end) {
        {
#line 5567
        tmp___28 = poolGrow(& parser->m_tempPool);
        }
#line 5567
        if (tmp___28) {
#line 5567
          tmp___26 = parser->m_tempPool.ptr;
#line 5567
          (parser->m_tempPool.ptr) ++;
#line 5567
          *tmp___26 = (XML_Char )12;
#line 5567
          tmp___27 = 1;
        } else {
#line 5567
          tmp___27 = 0;
        }
      } else {
#line 5567
        tmp___26 = parser->m_tempPool.ptr;
#line 5567
        (parser->m_tempPool.ptr) ++;
#line 5567
        *tmp___26 = (XML_Char )12;
#line 5567
        tmp___27 = 1;
      }
#line 5567
      if (! tmp___27) {
#line 5568
        return ((XML_Char const   *)((void *)0));
      }
    }
#line 5569
    s___0 = e->name;
    {
#line 5569
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 5569
      if (! *s___0) {
#line 5569
        goto while_break___4;
      }
#line 5570
      if ((unsigned long )parser->m_tempPool.ptr == (unsigned long )parser->m_tempPool.end) {
        {
#line 5570
        tmp___32 = poolGrow(& parser->m_tempPool);
        }
#line 5570
        if (tmp___32) {
#line 5570
          tmp___30 = parser->m_tempPool.ptr;
#line 5570
          (parser->m_tempPool.ptr) ++;
#line 5570
          *tmp___30 = (XML_Char )*s___0;
#line 5570
          tmp___31 = 1;
        } else {
#line 5570
          tmp___31 = 0;
        }
      } else {
#line 5570
        tmp___30 = parser->m_tempPool.ptr;
#line 5570
        (parser->m_tempPool.ptr) ++;
#line 5570
        *tmp___30 = (XML_Char )*s___0;
#line 5570
        tmp___31 = 1;
      }
#line 5570
      if (! tmp___31) {
#line 5571
        return ((XML_Char const   *)0);
      }
#line 5569
      s___0 ++;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 5572
    needSep = (XML_Bool )1;
    __Cont___0: /* CIL Label */ ;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 5575
  if ((unsigned long )parser->m_tempPool.ptr == (unsigned long )parser->m_tempPool.end) {
    {
#line 5575
    tmp___36 = poolGrow(& parser->m_tempPool);
    }
#line 5575
    if (tmp___36) {
#line 5575
      tmp___34 = parser->m_tempPool.ptr;
#line 5575
      (parser->m_tempPool.ptr) ++;
#line 5575
      *tmp___34 = (XML_Char )'\000';
#line 5575
      tmp___35 = 1;
    } else {
#line 5575
      tmp___35 = 0;
    }
  } else {
#line 5575
    tmp___34 = parser->m_tempPool.ptr;
#line 5575
    (parser->m_tempPool.ptr) ++;
#line 5575
    *tmp___34 = (XML_Char )'\000';
#line 5575
    tmp___35 = 1;
  }
#line 5575
  if (! tmp___35) {
#line 5576
    return ((XML_Char const   *)((void *)0));
  }
#line 5577
  return ((XML_Char const   *)parser->m_tempPool.start);
}
}
#line 5580 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlparse.c"
static XML_Bool setContext(XML_Parser parser , XML_Char const   *context ) 
{ 
  DTD *dtd ;
  XML_Char const   *s ;
  ENTITY *e ;
  XML_Char *tmp___0 ;
  int tmp___1 ;
  XML_Bool tmp___2 ;
  NAMED *tmp___3 ;
  PREFIX *prefix ;
  XML_Char *tmp___5 ;
  int tmp___6 ;
  XML_Bool tmp___7 ;
  NAMED *tmp___8 ;
  XML_Char *tmp___10 ;
  int tmp___11 ;
  XML_Bool tmp___12 ;
  XML_Char *tmp___14 ;
  int tmp___15 ;
  XML_Bool tmp___16 ;
  enum XML_Error tmp___17 ;
  XML_Char *tmp___19 ;
  int tmp___20 ;
  XML_Bool tmp___21 ;

  {
#line 5583
  dtd = parser->m_dtd;
#line 5584
  s = context;
  {
#line 5586
  while (1) {
    while_continue: /* CIL Label */ ;
#line 5586
    if (! ((int const   )*context != 0)) {
#line 5586
      goto while_break;
    }
#line 5587
    if ((int const   )*s == 12) {
#line 5587
      goto _L;
    } else
#line 5587
    if ((int const   )*s == 0) {
      _L: /* CIL Label */ 
#line 5589
      if ((unsigned long )parser->m_tempPool.ptr == (unsigned long )parser->m_tempPool.end) {
        {
#line 5589
        tmp___2 = poolGrow(& parser->m_tempPool);
        }
#line 5589
        if (tmp___2) {
#line 5589
          tmp___0 = parser->m_tempPool.ptr;
#line 5589
          (parser->m_tempPool.ptr) ++;
#line 5589
          *tmp___0 = (XML_Char )'\000';
#line 5589
          tmp___1 = 1;
        } else {
#line 5589
          tmp___1 = 0;
        }
      } else {
#line 5589
        tmp___0 = parser->m_tempPool.ptr;
#line 5589
        (parser->m_tempPool.ptr) ++;
#line 5589
        *tmp___0 = (XML_Char )'\000';
#line 5589
        tmp___1 = 1;
      }
#line 5589
      if (! tmp___1) {
#line 5590
        return ((XML_Bool )0);
      }
      {
#line 5591
      tmp___3 = lookup(parser, & dtd->generalEntities, (KEY )parser->m_tempPool.start,
                       (size_t )0);
#line 5591
      e = (ENTITY *)tmp___3;
      }
#line 5592
      if (e) {
#line 5593
        e->open = (XML_Bool )1;
      }
#line 5594
      if ((int const   )*s != 0) {
#line 5595
        s ++;
      }
#line 5596
      context = s;
#line 5597
      parser->m_tempPool.ptr = parser->m_tempPool.start;
    } else
#line 5599
    if ((int const   )*s == 61) {
#line 5601
      if (parser->m_tempPool.ptr - parser->m_tempPool.start == 0L) {
#line 5602
        prefix = & dtd->defaultPrefix;
      } else {
#line 5604
        if ((unsigned long )parser->m_tempPool.ptr == (unsigned long )parser->m_tempPool.end) {
          {
#line 5604
          tmp___7 = poolGrow(& parser->m_tempPool);
          }
#line 5604
          if (tmp___7) {
#line 5604
            tmp___5 = parser->m_tempPool.ptr;
#line 5604
            (parser->m_tempPool.ptr) ++;
#line 5604
            *tmp___5 = (XML_Char )'\000';
#line 5604
            tmp___6 = 1;
          } else {
#line 5604
            tmp___6 = 0;
          }
        } else {
#line 5604
          tmp___5 = parser->m_tempPool.ptr;
#line 5604
          (parser->m_tempPool.ptr) ++;
#line 5604
          *tmp___5 = (XML_Char )'\000';
#line 5604
          tmp___6 = 1;
        }
#line 5604
        if (! tmp___6) {
#line 5605
          return ((XML_Bool )0);
        }
        {
#line 5606
        tmp___8 = lookup(parser, & dtd->prefixes, (KEY )parser->m_tempPool.start,
                         sizeof(PREFIX ));
#line 5606
        prefix = (PREFIX *)tmp___8;
        }
#line 5608
        if (! prefix) {
#line 5609
          return ((XML_Bool )0);
        }
#line 5610
        if ((unsigned long )prefix->name == (unsigned long )parser->m_tempPool.start) {
          {
#line 5611
          prefix->name = poolCopyString(& dtd->pool, prefix->name);
          }
#line 5612
          if (! prefix->name) {
#line 5613
            return ((XML_Bool )0);
          }
        }
#line 5615
        parser->m_tempPool.ptr = parser->m_tempPool.start;
      }
#line 5617
      context = s + 1;
      {
#line 5617
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 5617
        if ((int const   )*context != 12) {
#line 5617
          if (! ((int const   )*context != 0)) {
#line 5617
            goto while_break___0;
          }
        } else {
#line 5617
          goto while_break___0;
        }
#line 5620
        if ((unsigned long )parser->m_tempPool.ptr == (unsigned long )parser->m_tempPool.end) {
          {
#line 5620
          tmp___12 = poolGrow(& parser->m_tempPool);
          }
#line 5620
          if (tmp___12) {
#line 5620
            tmp___10 = parser->m_tempPool.ptr;
#line 5620
            (parser->m_tempPool.ptr) ++;
#line 5620
            *tmp___10 = (XML_Char )*context;
#line 5620
            tmp___11 = 1;
          } else {
#line 5620
            tmp___11 = 0;
          }
        } else {
#line 5620
          tmp___10 = parser->m_tempPool.ptr;
#line 5620
          (parser->m_tempPool.ptr) ++;
#line 5620
          *tmp___10 = (XML_Char )*context;
#line 5620
          tmp___11 = 1;
        }
#line 5620
        if (! tmp___11) {
#line 5621
          return ((XML_Bool )0);
        }
#line 5617
        context ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 5622
      if ((unsigned long )parser->m_tempPool.ptr == (unsigned long )parser->m_tempPool.end) {
        {
#line 5622
        tmp___16 = poolGrow(& parser->m_tempPool);
        }
#line 5622
        if (tmp___16) {
#line 5622
          tmp___14 = parser->m_tempPool.ptr;
#line 5622
          (parser->m_tempPool.ptr) ++;
#line 5622
          *tmp___14 = (XML_Char )'\000';
#line 5622
          tmp___15 = 1;
        } else {
#line 5622
          tmp___15 = 0;
        }
      } else {
#line 5622
        tmp___14 = parser->m_tempPool.ptr;
#line 5622
        (parser->m_tempPool.ptr) ++;
#line 5622
        *tmp___14 = (XML_Char )'\000';
#line 5622
        tmp___15 = 1;
      }
#line 5622
      if (! tmp___15) {
#line 5623
        return ((XML_Bool )0);
      }
      {
#line 5624
      tmp___17 = addBinding(parser, prefix, (ATTRIBUTE_ID const   *)((void *)0), (XML_Char const   *)parser->m_tempPool.start,
                            & parser->m_inheritedBindings);
      }
#line 5624
      if ((unsigned int )tmp___17 != 0U) {
#line 5626
        return ((XML_Bool )0);
      }
#line 5627
      parser->m_tempPool.ptr = parser->m_tempPool.start;
#line 5628
      if ((int const   )*context != 0) {
#line 5629
        context ++;
      }
#line 5630
      s = context;
    } else {
#line 5633
      if ((unsigned long )parser->m_tempPool.ptr == (unsigned long )parser->m_tempPool.end) {
        {
#line 5633
        tmp___21 = poolGrow(& parser->m_tempPool);
        }
#line 5633
        if (tmp___21) {
#line 5633
          tmp___19 = parser->m_tempPool.ptr;
#line 5633
          (parser->m_tempPool.ptr) ++;
#line 5633
          *tmp___19 = (XML_Char )*s;
#line 5633
          tmp___20 = 1;
        } else {
#line 5633
          tmp___20 = 0;
        }
      } else {
#line 5633
        tmp___19 = parser->m_tempPool.ptr;
#line 5633
        (parser->m_tempPool.ptr) ++;
#line 5633
        *tmp___19 = (XML_Char )*s;
#line 5633
        tmp___20 = 1;
      }
#line 5633
      if (! tmp___20) {
#line 5634
        return ((XML_Bool )0);
      }
#line 5635
      s ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 5638
  return ((XML_Bool )1);
}
}
#line 5641 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlparse.c"
static void normalizePublicId(XML_Char *publicId ) 
{ 
  XML_Char *p ;
  XML_Char *s ;
  XML_Char *tmp ;
  XML_Char *tmp___0 ;

  {
#line 5644
  p = publicId;
#line 5646
  s = publicId;
  {
#line 5646
  while (1) {
    while_continue: /* CIL Label */ ;
#line 5646
    if (! *s) {
#line 5646
      goto while_break;
    }
    {
#line 5650
    if ((int )*s == 10) {
#line 5650
      goto case_10;
    }
#line 5650
    if ((int )*s == 13) {
#line 5650
      goto case_10;
    }
#line 5650
    if ((int )*s == 32) {
#line 5650
      goto case_10;
    }
#line 5654
    goto switch_default;
    case_10: /* CIL Label */ 
    case_13: /* CIL Label */ 
    case_32: /* CIL Label */ 
#line 5651
    if ((unsigned long )p != (unsigned long )publicId) {
#line 5651
      if ((int )*(p + -1) != 32) {
#line 5652
        tmp = p;
#line 5652
        p ++;
#line 5652
        *tmp = (XML_Char )32;
      }
    }
#line 5653
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 5655
    tmp___0 = p;
#line 5655
    p ++;
#line 5655
    *tmp___0 = *s;
    switch_break: /* CIL Label */ ;
    }
#line 5646
    s ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 5658
  if ((unsigned long )p != (unsigned long )publicId) {
#line 5658
    if ((int )*(p + -1) == 32) {
#line 5659
      p --;
    }
  }
#line 5660
  *p = (XML_Char )'\000';
#line 5661
  return;
}
}
#line 5663 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlparse.c"
static DTD *dtdCreate(XML_Memory_Handling_Suite const   *ms ) 
{ 
  DTD *p ;
  void *tmp ;

  {
  {
#line 5666
  tmp = (*(ms->malloc_fcn))(sizeof(DTD ));
#line 5666
  p = (DTD *)tmp;
  }
#line 5667
  if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 5668
    return (p);
  }
  {
#line 5669
  poolInit(& p->pool, ms);
#line 5670
  poolInit(& p->entityValuePool, ms);
#line 5671
  hashTableInit(& p->generalEntities, ms);
#line 5672
  hashTableInit(& p->elementTypes, ms);
#line 5673
  hashTableInit(& p->attributeIds, ms);
#line 5674
  hashTableInit(& p->prefixes, ms);
#line 5676
  p->paramEntityRead = (XML_Bool )0;
#line 5677
  hashTableInit(& p->paramEntities, ms);
#line 5679
  p->defaultPrefix.name = (XML_Char const   *)((void *)0);
#line 5680
  p->defaultPrefix.binding = (BINDING *)((void *)0);
#line 5682
  p->in_eldecl = (XML_Bool )0;
#line 5683
  p->scaffIndex = (int *)((void *)0);
#line 5684
  p->scaffold = (CONTENT_SCAFFOLD *)((void *)0);
#line 5685
  p->scaffLevel = 0;
#line 5686
  p->scaffSize = 0U;
#line 5687
  p->scaffCount = 0U;
#line 5688
  p->contentStringLen = 0U;
#line 5690
  p->keepProcessing = (XML_Bool )1;
#line 5691
  p->hasParamEntityRefs = (XML_Bool )0;
#line 5692
  p->standalone = (XML_Bool )0;
  }
#line 5693
  return (p);
}
}
#line 5696 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlparse.c"
static void dtdReset(DTD *p , XML_Memory_Handling_Suite const   *ms ) 
{ 
  HASH_TABLE_ITER iter ;
  ELEMENT_TYPE *e ;
  NAMED *tmp ;

  {
  {
#line 5700
  hashTableIterInit(& iter, (HASH_TABLE const   *)(& p->elementTypes));
  }
  {
#line 5701
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 5702
    tmp = hashTableIterNext(& iter);
#line 5702
    e = (ELEMENT_TYPE *)tmp;
    }
#line 5703
    if (! e) {
#line 5704
      goto while_break;
    }
#line 5705
    if (e->allocDefaultAtts != 0) {
      {
#line 5706
      (*(ms->free_fcn))((void *)e->defaultAtts);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 5708
  hashTableClear(& p->generalEntities);
#line 5710
  p->paramEntityRead = (XML_Bool )0;
#line 5711
  hashTableClear(& p->paramEntities);
#line 5713
  hashTableClear(& p->elementTypes);
#line 5714
  hashTableClear(& p->attributeIds);
#line 5715
  hashTableClear(& p->prefixes);
#line 5716
  poolClear(& p->pool);
#line 5717
  poolClear(& p->entityValuePool);
#line 5718
  p->defaultPrefix.name = (XML_Char const   *)((void *)0);
#line 5719
  p->defaultPrefix.binding = (BINDING *)((void *)0);
#line 5721
  p->in_eldecl = (XML_Bool )0;
#line 5723
  (*(ms->free_fcn))((void *)p->scaffIndex);
#line 5724
  p->scaffIndex = (int *)((void *)0);
#line 5725
  (*(ms->free_fcn))((void *)p->scaffold);
#line 5726
  p->scaffold = (CONTENT_SCAFFOLD *)((void *)0);
#line 5728
  p->scaffLevel = 0;
#line 5729
  p->scaffSize = 0U;
#line 5730
  p->scaffCount = 0U;
#line 5731
  p->contentStringLen = 0U;
#line 5733
  p->keepProcessing = (XML_Bool )1;
#line 5734
  p->hasParamEntityRefs = (XML_Bool )0;
#line 5735
  p->standalone = (XML_Bool )0;
  }
#line 5736
  return;
}
}
#line 5738 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlparse.c"
static void dtdDestroy(DTD *p , XML_Bool isDocEntity , XML_Memory_Handling_Suite const   *ms ) 
{ 
  HASH_TABLE_ITER iter ;
  ELEMENT_TYPE *e ;
  NAMED *tmp ;

  {
  {
#line 5742
  hashTableIterInit(& iter, (HASH_TABLE const   *)(& p->elementTypes));
  }
  {
#line 5743
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 5744
    tmp = hashTableIterNext(& iter);
#line 5744
    e = (ELEMENT_TYPE *)tmp;
    }
#line 5745
    if (! e) {
#line 5746
      goto while_break;
    }
#line 5747
    if (e->allocDefaultAtts != 0) {
      {
#line 5748
      (*(ms->free_fcn))((void *)e->defaultAtts);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 5750
  hashTableDestroy(& p->generalEntities);
#line 5752
  hashTableDestroy(& p->paramEntities);
#line 5754
  hashTableDestroy(& p->elementTypes);
#line 5755
  hashTableDestroy(& p->attributeIds);
#line 5756
  hashTableDestroy(& p->prefixes);
#line 5757
  poolDestroy(& p->pool);
#line 5758
  poolDestroy(& p->entityValuePool);
  }
#line 5759
  if (isDocEntity) {
    {
#line 5760
    (*(ms->free_fcn))((void *)p->scaffIndex);
#line 5761
    (*(ms->free_fcn))((void *)p->scaffold);
    }
  }
  {
#line 5763
  (*(ms->free_fcn))((void *)p);
  }
#line 5764
  return;
}
}
#line 5769 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlparse.c"
static int dtdCopy(XML_Parser oldParser , DTD *newDtd , DTD const   *oldDtd , XML_Memory_Handling_Suite const   *ms ) 
{ 
  HASH_TABLE_ITER iter ;
  XML_Char const   *name ;
  PREFIX const   *oldP ;
  NAMED *tmp ;
  NAMED *tmp___0 ;
  ATTRIBUTE_ID *newA ;
  XML_Char const   *name___0 ;
  ATTRIBUTE_ID const   *oldA ;
  NAMED *tmp___1 ;
  XML_Char *tmp___3 ;
  int tmp___4 ;
  XML_Bool tmp___5 ;
  NAMED *tmp___6 ;
  NAMED *tmp___7 ;
  int i ;
  ELEMENT_TYPE *newE ;
  XML_Char const   *name___1 ;
  ELEMENT_TYPE const   *oldE ;
  NAMED *tmp___8 ;
  NAMED *tmp___9 ;
  void *tmp___10 ;
  NAMED *tmp___11 ;
  int tmp___12 ;
  NAMED *tmp___13 ;
  NAMED *tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;

  {
  {
#line 5776
  hashTableIterInit(& iter, & oldDtd->prefixes);
  }
  {
#line 5777
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 5779
    tmp = hashTableIterNext(& iter);
#line 5779
    oldP = (PREFIX const   *)((PREFIX *)tmp);
    }
#line 5780
    if (! oldP) {
#line 5781
      goto while_break;
    }
    {
#line 5782
    name = poolCopyString(& newDtd->pool, (XML_Char const   *)oldP->name);
    }
#line 5783
    if (! name) {
#line 5784
      return (0);
    }
    {
#line 5785
    tmp___0 = lookup(oldParser, & newDtd->prefixes, name, sizeof(PREFIX ));
    }
#line 5785
    if (! tmp___0) {
#line 5786
      return (0);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 5789
  hashTableIterInit(& iter, & oldDtd->attributeIds);
  }
  {
#line 5793
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 5796
    tmp___1 = hashTableIterNext(& iter);
#line 5796
    oldA = (ATTRIBUTE_ID const   *)((ATTRIBUTE_ID *)tmp___1);
    }
#line 5798
    if (! oldA) {
#line 5799
      goto while_break___0;
    }
#line 5801
    if ((unsigned long )newDtd->pool.ptr == (unsigned long )newDtd->pool.end) {
      {
#line 5801
      tmp___5 = poolGrow(& newDtd->pool);
      }
#line 5801
      if (tmp___5) {
#line 5801
        tmp___3 = newDtd->pool.ptr;
#line 5801
        (newDtd->pool.ptr) ++;
#line 5801
        *tmp___3 = (XML_Char )'\000';
#line 5801
        tmp___4 = 1;
      } else {
#line 5801
        tmp___4 = 0;
      }
    } else {
#line 5801
      tmp___3 = newDtd->pool.ptr;
#line 5801
      (newDtd->pool.ptr) ++;
#line 5801
      *tmp___3 = (XML_Char )'\000';
#line 5801
      tmp___4 = 1;
    }
#line 5801
    if (! tmp___4) {
#line 5802
      return (0);
    }
    {
#line 5803
    name___0 = poolCopyString(& newDtd->pool, (XML_Char const   *)oldA->name);
    }
#line 5804
    if (! name___0) {
#line 5805
      return (0);
    }
    {
#line 5806
    name___0 ++;
#line 5807
    tmp___6 = lookup(oldParser, & newDtd->attributeIds, name___0, sizeof(ATTRIBUTE_ID ));
#line 5807
    newA = (ATTRIBUTE_ID *)tmp___6;
    }
#line 5809
    if (! newA) {
#line 5810
      return (0);
    }
#line 5811
    newA->maybeTokenized = (XML_Bool )oldA->maybeTokenized;
#line 5812
    if (oldA->prefix) {
#line 5813
      newA->xmlns = (XML_Bool )oldA->xmlns;
#line 5814
      if ((unsigned long )oldA->prefix == (unsigned long )(& oldDtd->defaultPrefix)) {
#line 5815
        newA->prefix = & newDtd->defaultPrefix;
      } else {
        {
#line 5817
        tmp___7 = lookup(oldParser, & newDtd->prefixes, (oldA->prefix)->name, (size_t )0);
#line 5817
        newA->prefix = (PREFIX *)tmp___7;
        }
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 5824
  hashTableIterInit(& iter, & oldDtd->elementTypes);
  }
  {
#line 5826
  while (1) {
    while_continue___1: /* CIL Label */ ;
    {
#line 5830
    tmp___8 = hashTableIterNext(& iter);
#line 5830
    oldE = (ELEMENT_TYPE const   *)((ELEMENT_TYPE *)tmp___8);
    }
#line 5831
    if (! oldE) {
#line 5832
      goto while_break___1;
    }
    {
#line 5833
    name___1 = poolCopyString(& newDtd->pool, (XML_Char const   *)oldE->name);
    }
#line 5834
    if (! name___1) {
#line 5835
      return (0);
    }
    {
#line 5836
    tmp___9 = lookup(oldParser, & newDtd->elementTypes, name___1, sizeof(ELEMENT_TYPE ));
#line 5836
    newE = (ELEMENT_TYPE *)tmp___9;
    }
#line 5838
    if (! newE) {
#line 5839
      return (0);
    }
#line 5840
    if (oldE->nDefaultAtts) {
      {
#line 5841
      tmp___10 = (*(ms->malloc_fcn))((unsigned long )oldE->nDefaultAtts * sizeof(DEFAULT_ATTRIBUTE ));
#line 5841
      newE->defaultAtts = (DEFAULT_ATTRIBUTE *)tmp___10;
      }
#line 5843
      if (! newE->defaultAtts) {
        {
#line 5844
        (*(ms->free_fcn))((void *)newE);
        }
#line 5845
        return (0);
      }
    }
#line 5848
    if (oldE->idAtt) {
      {
#line 5849
      tmp___11 = lookup(oldParser, & newDtd->attributeIds, (KEY )(oldE->idAtt)->name,
                        (size_t )0);
#line 5849
      newE->idAtt = (ATTRIBUTE_ID const   *)((ATTRIBUTE_ID *)tmp___11);
      }
    }
#line 5851
    tmp___12 = (int )oldE->nDefaultAtts;
#line 5851
    newE->nDefaultAtts = tmp___12;
#line 5851
    newE->allocDefaultAtts = tmp___12;
#line 5852
    if (oldE->prefix) {
      {
#line 5853
      tmp___13 = lookup(oldParser, & newDtd->prefixes, (oldE->prefix)->name, (size_t )0);
#line 5853
      newE->prefix = (PREFIX *)tmp___13;
      }
    }
#line 5855
    i = 0;
    {
#line 5855
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 5855
      if (! (i < newE->nDefaultAtts)) {
#line 5855
        goto while_break___2;
      }
      {
#line 5856
      tmp___14 = lookup(oldParser, & newDtd->attributeIds, (KEY )((oldE->defaultAtts + i)->id)->name,
                        (size_t )0);
#line 5856
      (newE->defaultAtts + i)->id = (ATTRIBUTE_ID const   *)((ATTRIBUTE_ID *)tmp___14);
#line 5858
      (newE->defaultAtts + i)->isCdata = (oldE->defaultAtts + i)->isCdata;
      }
#line 5859
      if ((oldE->defaultAtts + i)->value) {
        {
#line 5860
        (newE->defaultAtts + i)->value = poolCopyString(& newDtd->pool, (oldE->defaultAtts + i)->value);
        }
#line 5862
        if (! (newE->defaultAtts + i)->value) {
#line 5863
          return (0);
        }
      } else {
#line 5866
        (newE->defaultAtts + i)->value = (XML_Char const   *)((void *)0);
      }
#line 5855
      i ++;
    }
    while_break___2: /* CIL Label */ ;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 5871
  tmp___15 = copyEntityTable(oldParser, & newDtd->generalEntities, & newDtd->pool,
                             & oldDtd->generalEntities);
  }
#line 5871
  if (! tmp___15) {
#line 5875
    return (0);
  }
  {
#line 5878
  tmp___16 = copyEntityTable(oldParser, & newDtd->paramEntities, & newDtd->pool, & oldDtd->paramEntities);
  }
#line 5878
  if (! tmp___16) {
#line 5882
    return (0);
  }
#line 5883
  newDtd->paramEntityRead = (XML_Bool )oldDtd->paramEntityRead;
#line 5886
  newDtd->keepProcessing = (XML_Bool )oldDtd->keepProcessing;
#line 5887
  newDtd->hasParamEntityRefs = (XML_Bool )oldDtd->hasParamEntityRefs;
#line 5888
  newDtd->standalone = (XML_Bool )oldDtd->standalone;
#line 5891
  newDtd->in_eldecl = (XML_Bool )oldDtd->in_eldecl;
#line 5892
  newDtd->scaffold = (CONTENT_SCAFFOLD *)oldDtd->scaffold;
#line 5893
  newDtd->contentStringLen = (unsigned int )oldDtd->contentStringLen;
#line 5894
  newDtd->scaffSize = (unsigned int )oldDtd->scaffSize;
#line 5895
  newDtd->scaffLevel = (int )oldDtd->scaffLevel;
#line 5896
  newDtd->scaffIndex = (int *)oldDtd->scaffIndex;
#line 5898
  return (1);
}
}
#line 5901 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlparse.c"
static int copyEntityTable(XML_Parser oldParser , HASH_TABLE *newTable , STRING_POOL *newPool ,
                           HASH_TABLE const   *oldTable ) 
{ 
  HASH_TABLE_ITER iter ;
  XML_Char const   *cachedOldBase ;
  XML_Char const   *cachedNewBase ;
  ENTITY *newE ;
  XML_Char const   *name ;
  ENTITY const   *oldE ;
  NAMED *tmp ;
  NAMED *tmp___0 ;
  XML_Char const   *tem ;
  XML_Char const   *tmp___1 ;
  XML_Char const   *tmp___2 ;
  XML_Char const   *tem___0 ;
  XML_Char const   *tmp___3 ;
  XML_Char const   *tem___1 ;
  XML_Char const   *tmp___4 ;

  {
  {
#line 5908
  cachedOldBase = (XML_Char const   *)((void *)0);
#line 5909
  cachedNewBase = (XML_Char const   *)((void *)0);
#line 5911
  hashTableIterInit(& iter, oldTable);
  }
  {
#line 5913
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 5916
    tmp = hashTableIterNext(& iter);
#line 5916
    oldE = (ENTITY const   *)((ENTITY *)tmp);
    }
#line 5917
    if (! oldE) {
#line 5918
      goto while_break;
    }
    {
#line 5919
    name = poolCopyString(newPool, (XML_Char const   *)oldE->name);
    }
#line 5920
    if (! name) {
#line 5921
      return (0);
    }
    {
#line 5922
    tmp___0 = lookup(oldParser, newTable, name, sizeof(ENTITY ));
#line 5922
    newE = (ENTITY *)tmp___0;
    }
#line 5923
    if (! newE) {
#line 5924
      return (0);
    }
#line 5925
    if (oldE->systemId) {
      {
#line 5926
      tmp___1 = poolCopyString(newPool, (XML_Char const   *)oldE->systemId);
#line 5926
      tem = tmp___1;
      }
#line 5927
      if (! tem) {
#line 5928
        return (0);
      }
#line 5929
      newE->systemId = tem;
#line 5930
      if (oldE->base) {
#line 5931
        if ((unsigned long )oldE->base == (unsigned long )cachedOldBase) {
#line 5932
          newE->base = cachedNewBase;
        } else {
          {
#line 5934
          cachedOldBase = (XML_Char const   *)oldE->base;
#line 5935
          tem = poolCopyString(newPool, cachedOldBase);
          }
#line 5936
          if (! tem) {
#line 5937
            return (0);
          }
#line 5938
          tmp___2 = tem;
#line 5938
          newE->base = tmp___2;
#line 5938
          cachedNewBase = tmp___2;
        }
      }
#line 5941
      if (oldE->publicId) {
        {
#line 5942
        tem = poolCopyString(newPool, (XML_Char const   *)oldE->publicId);
        }
#line 5943
        if (! tem) {
#line 5944
          return (0);
        }
#line 5945
        newE->publicId = tem;
      }
    } else {
      {
#line 5949
      tmp___3 = poolCopyStringN(newPool, (XML_Char const   *)oldE->textPtr, (int )oldE->textLen);
#line 5949
      tem___0 = tmp___3;
      }
#line 5951
      if (! tem___0) {
#line 5952
        return (0);
      }
#line 5953
      newE->textPtr = tem___0;
#line 5954
      newE->textLen = (int )oldE->textLen;
    }
#line 5956
    if (oldE->notation) {
      {
#line 5957
      tmp___4 = poolCopyString(newPool, (XML_Char const   *)oldE->notation);
#line 5957
      tem___1 = tmp___4;
      }
#line 5958
      if (! tem___1) {
#line 5959
        return (0);
      }
#line 5960
      newE->notation = tem___1;
    }
#line 5962
    newE->is_param = (XML_Bool )oldE->is_param;
#line 5963
    newE->is_internal = (XML_Bool )oldE->is_internal;
  }
  while_break: /* CIL Label */ ;
  }
#line 5965
  return (1);
}
}
#line 5970 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlparse.c"
static XML_Bool keyeq(KEY s1 , KEY s2 ) 
{ 


  {
  {
#line 5973
  while (1) {
    while_continue: /* CIL Label */ ;
#line 5973
    if (! ((int const   )*s1 == (int const   )*s2)) {
#line 5973
      goto while_break;
    }
#line 5974
    if ((int const   )*s1 == 0) {
#line 5975
      return ((XML_Bool )1);
    }
#line 5973
    s1 ++;
#line 5973
    s2 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 5976
  return ((XML_Bool )0);
}
}
#line 5979 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlparse.c"
static unsigned long hash(XML_Parser parser , KEY s ) 
{ 
  unsigned long h ;
  KEY tmp ;

  {
#line 5982
  h = parser->m_hash_secret_salt;
  {
#line 5983
  while (1) {
    while_continue: /* CIL Label */ ;
#line 5983
    if (! *s) {
#line 5983
      goto while_break;
    }
#line 5984
    tmp = s;
#line 5984
    s ++;
#line 5984
    h = h * 1000003UL ^ (unsigned long )((unsigned char )*tmp);
  }
  while_break: /* CIL Label */ ;
  }
#line 5985
  return (h);
}
}
#line 5988 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlparse.c"
static NAMED *lookup(XML_Parser parser , HASH_TABLE *table , KEY name , size_t createSize ) 
{ 
  size_t i ;
  size_t tsize ;
  void *tmp ;
  unsigned long tmp___0 ;
  unsigned long h ;
  unsigned long tmp___1 ;
  unsigned long mask ;
  unsigned char step ;
  XML_Bool tmp___2 ;
  unsigned char newPower ;
  size_t newSize ;
  unsigned long newMask ;
  size_t tsize___0 ;
  NAMED **newV ;
  void *tmp___3 ;
  unsigned long newHash ;
  unsigned long tmp___4 ;
  size_t j ;
  void *tmp___5 ;

  {
#line 5992
  if (table->size == 0UL) {
#line 5994
    if (! createSize) {
#line 5995
      return ((NAMED *)((void *)0));
    }
    {
#line 5996
    table->power = (unsigned char)6;
#line 5998
    table->size = 1UL << 6;
#line 5999
    tsize = table->size * sizeof(NAMED *);
#line 6000
    tmp = (*((table->mem)->malloc_fcn))(tsize);
#line 6000
    table->v = (NAMED **)tmp;
    }
#line 6001
    if (! table->v) {
#line 6002
      table->size = (size_t )0;
#line 6003
      return ((NAMED *)((void *)0));
    }
    {
#line 6005
    memset((void *)table->v, 0, tsize);
#line 6006
    tmp___0 = hash(parser, name);
#line 6006
    i = tmp___0 & (table->size - 1UL);
    }
  } else {
    {
#line 6009
    tmp___1 = hash(parser, name);
#line 6009
    h = tmp___1;
#line 6010
    mask = table->size - 1UL;
#line 6011
    step = (unsigned char)0;
#line 6012
    i = h & mask;
    }
    {
#line 6013
    while (1) {
      while_continue: /* CIL Label */ ;
#line 6013
      if (! *(table->v + i)) {
#line 6013
        goto while_break;
      }
      {
#line 6014
      tmp___2 = keyeq(name, (*(table->v + i))->name);
      }
#line 6014
      if (tmp___2) {
#line 6015
        return (*(table->v + i));
      }
#line 6016
      if (! step) {
#line 6017
        step = (unsigned char )((((h & ~ mask) >> ((int )table->power - 1)) & (mask >> 2)) | 1UL);
      }
#line 6018
      if (i < (size_t )step) {
#line 6018
        i += table->size - (size_t )step;
      } else {
#line 6018
        i -= (size_t )step;
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 6020
    if (! createSize) {
#line 6021
      return ((NAMED *)((void *)0));
    }
#line 6024
    if (table->used >> ((int )table->power - 1)) {
      {
#line 6025
      newPower = (unsigned char )((int )table->power + 1);
#line 6026
      newSize = 1UL << (int )newPower;
#line 6027
      newMask = newSize - 1UL;
#line 6028
      tsize___0 = newSize * sizeof(NAMED *);
#line 6029
      tmp___3 = (*((table->mem)->malloc_fcn))(tsize___0);
#line 6029
      newV = (NAMED **)tmp___3;
      }
#line 6030
      if (! newV) {
#line 6031
        return ((NAMED *)((void *)0));
      }
      {
#line 6032
      memset((void *)newV, 0, tsize___0);
#line 6033
      i = (size_t )0;
      }
      {
#line 6033
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 6033
        if (! (i < table->size)) {
#line 6033
          goto while_break___0;
        }
#line 6034
        if (*(table->v + i)) {
          {
#line 6035
          tmp___4 = hash(parser, (*(table->v + i))->name);
#line 6035
          newHash = tmp___4;
#line 6036
          j = newHash & newMask;
#line 6037
          step = (unsigned char)0;
          }
          {
#line 6038
          while (1) {
            while_continue___1: /* CIL Label */ ;
#line 6038
            if (! *(newV + j)) {
#line 6038
              goto while_break___1;
            }
#line 6039
            if (! step) {
#line 6040
              step = (unsigned char )((((newHash & ~ newMask) >> ((int )newPower - 1)) & (newMask >> 2)) | 1UL);
            }
#line 6041
            if (j < (size_t )step) {
#line 6041
              j += newSize - (size_t )step;
            } else {
#line 6041
              j -= (size_t )step;
            }
          }
          while_break___1: /* CIL Label */ ;
          }
#line 6043
          *(newV + j) = *(table->v + i);
        }
#line 6033
        i ++;
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 6045
      (*((table->mem)->free_fcn))((void *)table->v);
#line 6046
      table->v = newV;
#line 6047
      table->power = newPower;
#line 6048
      table->size = newSize;
#line 6049
      i = h & newMask;
#line 6050
      step = (unsigned char)0;
      }
      {
#line 6051
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 6051
        if (! *(table->v + i)) {
#line 6051
          goto while_break___2;
        }
#line 6052
        if (! step) {
#line 6053
          step = (unsigned char )((((h & ~ newMask) >> ((int )newPower - 1)) & (newMask >> 2)) | 1UL);
        }
#line 6054
        if (i < (size_t )step) {
#line 6054
          i += newSize - (size_t )step;
        } else {
#line 6054
          i -= (size_t )step;
        }
      }
      while_break___2: /* CIL Label */ ;
      }
    }
  }
  {
#line 6058
  tmp___5 = (*((table->mem)->malloc_fcn))(createSize);
#line 6058
  *(table->v + i) = (NAMED *)tmp___5;
  }
#line 6059
  if (! *(table->v + i)) {
#line 6060
    return ((NAMED *)((void *)0));
  }
  {
#line 6061
  memset((void *)*(table->v + i), 0, createSize);
#line 6062
  (*(table->v + i))->name = name;
#line 6063
  (table->used) ++;
  }
#line 6064
  return (*(table->v + i));
}
}
#line 6067 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlparse.c"
static void hashTableClear(HASH_TABLE *table ) 
{ 
  size_t i ;

  {
#line 6071
  i = (size_t )0;
  {
#line 6071
  while (1) {
    while_continue: /* CIL Label */ ;
#line 6071
    if (! (i < table->size)) {
#line 6071
      goto while_break;
    }
    {
#line 6072
    (*((table->mem)->free_fcn))((void *)*(table->v + i));
#line 6073
    *(table->v + i) = (NAMED *)((void *)0);
#line 6071
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 6075
  table->used = (size_t )0;
#line 6076
  return;
}
}
#line 6078 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlparse.c"
static void hashTableDestroy(HASH_TABLE *table ) 
{ 
  size_t i ;

  {
#line 6082
  i = (size_t )0;
  {
#line 6082
  while (1) {
    while_continue: /* CIL Label */ ;
#line 6082
    if (! (i < table->size)) {
#line 6082
      goto while_break;
    }
    {
#line 6083
    (*((table->mem)->free_fcn))((void *)*(table->v + i));
#line 6082
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 6084
  (*((table->mem)->free_fcn))((void *)table->v);
  }
#line 6085
  return;
}
}
#line 6087 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlparse.c"
static void hashTableInit(HASH_TABLE *p , XML_Memory_Handling_Suite const   *ms ) 
{ 


  {
#line 6090
  p->power = (unsigned char)0;
#line 6091
  p->size = (size_t )0;
#line 6092
  p->used = (size_t )0;
#line 6093
  p->v = (NAMED **)((void *)0);
#line 6094
  p->mem = ms;
#line 6095
  return;
}
}
#line 6097 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlparse.c"
static void hashTableIterInit(HASH_TABLE_ITER *iter , HASH_TABLE const   *table ) 
{ 


  {
#line 6100
  iter->p = (NAMED **)table->v;
#line 6101
  iter->end = iter->p + table->size;
#line 6102
  return;
}
}
#line 6104 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlparse.c"
static NAMED *hashTableIterNext(HASH_TABLE_ITER *iter ) 
{ 
  NAMED *tem ;
  NAMED **tmp ;

  {
  {
#line 6107
  while (1) {
    while_continue: /* CIL Label */ ;
#line 6107
    if (! ((unsigned long )iter->p != (unsigned long )iter->end)) {
#line 6107
      goto while_break;
    }
#line 6108
    tmp = iter->p;
#line 6108
    (iter->p) ++;
#line 6108
    tem = *tmp;
#line 6109
    if (tem) {
#line 6110
      return (tem);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 6112
  return ((NAMED *)((void *)0));
}
}
#line 6115 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlparse.c"
static void poolInit(STRING_POOL *pool , XML_Memory_Handling_Suite const   *ms ) 
{ 


  {
#line 6118
  pool->blocks = (BLOCK *)((void *)0);
#line 6119
  pool->freeBlocks = (BLOCK *)((void *)0);
#line 6120
  pool->start = (XML_Char *)((void *)0);
#line 6121
  pool->ptr = (XML_Char *)((void *)0);
#line 6122
  pool->end = (XML_Char const   *)((void *)0);
#line 6123
  pool->mem = ms;
#line 6124
  return;
}
}
#line 6126 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlparse.c"
static void poolClear(STRING_POOL *pool ) 
{ 
  BLOCK *p ;
  BLOCK *tem ;

  {
#line 6129
  if (! pool->freeBlocks) {
#line 6130
    pool->freeBlocks = pool->blocks;
  } else {
#line 6132
    p = pool->blocks;
    {
#line 6133
    while (1) {
      while_continue: /* CIL Label */ ;
#line 6133
      if (! p) {
#line 6133
        goto while_break;
      }
#line 6134
      tem = p->next;
#line 6135
      p->next = pool->freeBlocks;
#line 6136
      pool->freeBlocks = p;
#line 6137
      p = tem;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 6140
  pool->blocks = (BLOCK *)((void *)0);
#line 6141
  pool->start = (XML_Char *)((void *)0);
#line 6142
  pool->ptr = (XML_Char *)((void *)0);
#line 6143
  pool->end = (XML_Char const   *)((void *)0);
#line 6144
  return;
}
}
#line 6146 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlparse.c"
static void poolDestroy(STRING_POOL *pool ) 
{ 
  BLOCK *p ;
  BLOCK *tem ;
  BLOCK *tem___0 ;

  {
#line 6149
  p = pool->blocks;
  {
#line 6150
  while (1) {
    while_continue: /* CIL Label */ ;
#line 6150
    if (! p) {
#line 6150
      goto while_break;
    }
    {
#line 6151
    tem = p->next;
#line 6152
    (*((pool->mem)->free_fcn))((void *)p);
#line 6153
    p = tem;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 6155
  p = pool->freeBlocks;
  {
#line 6156
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 6156
    if (! p) {
#line 6156
      goto while_break___0;
    }
    {
#line 6157
    tem___0 = p->next;
#line 6158
    (*((pool->mem)->free_fcn))((void *)p);
#line 6159
    p = tem___0;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 6161
  return;
}
}
#line 6163 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlparse.c"
static XML_Char *poolAppend(STRING_POOL *pool , ENCODING const   *enc , char const   *ptr ,
                            char const   *end ) 
{ 
  XML_Bool tmp ;
  XML_Bool tmp___0 ;

  {
#line 6167
  if (! pool->ptr) {
    {
#line 6167
    tmp = poolGrow(pool);
    }
#line 6167
    if (! tmp) {
#line 6168
      return ((XML_Char *)((void *)0));
    }
  }
  {
#line 6169
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 6170
    (*(enc->utf8Convert))(enc, & ptr, end, & pool->ptr, (char const   *)((ICHAR *)pool->end));
    }
#line 6171
    if ((unsigned long )ptr == (unsigned long )end) {
#line 6172
      goto while_break;
    }
    {
#line 6173
    tmp___0 = poolGrow(pool);
    }
#line 6173
    if (! tmp___0) {
#line 6174
      return ((XML_Char *)((void *)0));
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 6176
  return (pool->start);
}
}
#line 6179 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlparse.c"
static XML_Char const   *poolCopyString(STRING_POOL *pool , XML_Char const   *s ) 
{ 
  XML_Char *tmp___0 ;
  int tmp___1 ;
  XML_Bool tmp___2 ;
  XML_Char const   *tmp___3 ;

  {
  {
#line 6182
  while (1) {
    while_continue: /* CIL Label */ ;
#line 6183
    if ((unsigned long )pool->ptr == (unsigned long )pool->end) {
      {
#line 6183
      tmp___2 = poolGrow(pool);
      }
#line 6183
      if (tmp___2) {
#line 6183
        tmp___0 = pool->ptr;
#line 6183
        (pool->ptr) ++;
#line 6183
        *tmp___0 = (XML_Char )*s;
#line 6183
        tmp___1 = 1;
      } else {
#line 6183
        tmp___1 = 0;
      }
    } else {
#line 6183
      tmp___0 = pool->ptr;
#line 6183
      (pool->ptr) ++;
#line 6183
      *tmp___0 = (XML_Char )*s;
#line 6183
      tmp___1 = 1;
    }
#line 6183
    if (! tmp___1) {
#line 6184
      return ((XML_Char const   *)((void *)0));
    }
#line 6182
    tmp___3 = s;
#line 6182
    s ++;
#line 6182
    if (! *tmp___3) {
#line 6182
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 6186
  s = (XML_Char const   *)pool->start;
#line 6187
  pool->start = pool->ptr;
#line 6188
  return (s);
}
}
#line 6191 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlparse.c"
static XML_Char const   *poolCopyStringN(STRING_POOL *pool , XML_Char const   *s ,
                                         int n ) 
{ 
  XML_Bool tmp ;
  XML_Char *tmp___1 ;
  int tmp___2 ;
  XML_Bool tmp___3 ;

  {
#line 6194
  if (! pool->ptr) {
    {
#line 6194
    tmp = poolGrow(pool);
    }
#line 6194
    if (! tmp) {
#line 6195
      return ((XML_Char const   *)((void *)0));
    }
  }
  {
#line 6196
  while (1) {
    while_continue: /* CIL Label */ ;
#line 6196
    if (! (n > 0)) {
#line 6196
      goto while_break;
    }
#line 6197
    if ((unsigned long )pool->ptr == (unsigned long )pool->end) {
      {
#line 6197
      tmp___3 = poolGrow(pool);
      }
#line 6197
      if (tmp___3) {
#line 6197
        tmp___1 = pool->ptr;
#line 6197
        (pool->ptr) ++;
#line 6197
        *tmp___1 = (XML_Char )*s;
#line 6197
        tmp___2 = 1;
      } else {
#line 6197
        tmp___2 = 0;
      }
    } else {
#line 6197
      tmp___1 = pool->ptr;
#line 6197
      (pool->ptr) ++;
#line 6197
      *tmp___1 = (XML_Char )*s;
#line 6197
      tmp___2 = 1;
    }
#line 6197
    if (! tmp___2) {
#line 6198
      return ((XML_Char const   *)((void *)0));
    }
#line 6196
    n --;
#line 6196
    s ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 6200
  s = (XML_Char const   *)pool->start;
#line 6201
  pool->start = pool->ptr;
#line 6202
  return (s);
}
}
#line 6205 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlparse.c"
static XML_Char const   *poolAppendString(STRING_POOL *pool , XML_Char const   *s ) 
{ 
  XML_Char *tmp___0 ;
  int tmp___1 ;
  XML_Bool tmp___2 ;

  {
  {
#line 6208
  while (1) {
    while_continue: /* CIL Label */ ;
#line 6208
    if (! *s) {
#line 6208
      goto while_break;
    }
#line 6209
    if ((unsigned long )pool->ptr == (unsigned long )pool->end) {
      {
#line 6209
      tmp___2 = poolGrow(pool);
      }
#line 6209
      if (tmp___2) {
#line 6209
        tmp___0 = pool->ptr;
#line 6209
        (pool->ptr) ++;
#line 6209
        *tmp___0 = (XML_Char )*s;
#line 6209
        tmp___1 = 1;
      } else {
#line 6209
        tmp___1 = 0;
      }
    } else {
#line 6209
      tmp___0 = pool->ptr;
#line 6209
      (pool->ptr) ++;
#line 6209
      *tmp___0 = (XML_Char )*s;
#line 6209
      tmp___1 = 1;
    }
#line 6209
    if (! tmp___1) {
#line 6210
      return ((XML_Char const   *)((void *)0));
    }
#line 6211
    s ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 6213
  return ((XML_Char const   *)pool->start);
}
}
#line 6216 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlparse.c"
static XML_Char *poolStoreString(STRING_POOL *pool , ENCODING const   *enc , char const   *ptr ,
                                 char const   *end ) 
{ 
  XML_Char *tmp ;
  XML_Bool tmp___0 ;
  XML_Char *tmp___1 ;

  {
  {
#line 6220
  tmp = poolAppend(pool, enc, ptr, end);
  }
#line 6220
  if (! tmp) {
#line 6221
    return ((XML_Char *)((void *)0));
  }
#line 6222
  if ((unsigned long )pool->ptr == (unsigned long )pool->end) {
    {
#line 6222
    tmp___0 = poolGrow(pool);
    }
#line 6222
    if (! tmp___0) {
#line 6223
      return ((XML_Char *)((void *)0));
    }
  }
#line 6224
  tmp___1 = pool->ptr;
#line 6224
  (pool->ptr) ++;
#line 6224
  *tmp___1 = (XML_Char )0;
#line 6225
  return (pool->start);
}
}
#line 6228 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlparse.c"
static XML_Bool poolGrow(STRING_POOL *pool ) 
{ 
  BLOCK *tem ;
  int blockSize ;
  BLOCK *temp ;
  void *tmp ;
  BLOCK *tem___0 ;
  int blockSize___0 ;
  void *tmp___0 ;

  {
#line 6231
  if (pool->freeBlocks) {
#line 6232
    if ((unsigned long )pool->start == (unsigned long )((XML_Char *)0)) {
#line 6233
      pool->blocks = pool->freeBlocks;
#line 6234
      pool->freeBlocks = (pool->freeBlocks)->next;
#line 6235
      (pool->blocks)->next = (struct block *)((void *)0);
#line 6236
      pool->start = (pool->blocks)->s;
#line 6237
      pool->end = (XML_Char const   *)(pool->start + (pool->blocks)->size);
#line 6238
      pool->ptr = pool->start;
#line 6239
      return ((XML_Bool )1);
    }
#line 6241
    if (pool->end - (XML_Char const   *)pool->start < (long )(pool->freeBlocks)->size) {
      {
#line 6242
      tem = (pool->freeBlocks)->next;
#line 6243
      (pool->freeBlocks)->next = pool->blocks;
#line 6244
      pool->blocks = pool->freeBlocks;
#line 6245
      pool->freeBlocks = tem;
#line 6246
      memcpy((void */* __restrict  */)((pool->blocks)->s), (void const   */* __restrict  */)pool->start,
             (unsigned long )(pool->end - (XML_Char const   *)pool->start) * sizeof(XML_Char ));
#line 6248
      pool->ptr = (pool->blocks)->s + (pool->ptr - pool->start);
#line 6249
      pool->start = (pool->blocks)->s;
#line 6250
      pool->end = (XML_Char const   *)(pool->start + (pool->blocks)->size);
      }
#line 6251
      return ((XML_Bool )1);
    }
  }
#line 6254
  if (pool->blocks) {
#line 6254
    if ((unsigned long )pool->start == (unsigned long )((pool->blocks)->s)) {
      {
#line 6255
      blockSize = (int )(pool->end - (XML_Char const   *)pool->start) * 2;
#line 6256
      tmp = (*((pool->mem)->realloc_fcn))((void *)pool->blocks, (unsigned long )(& ((BLOCK *)0)->s) + (unsigned long )blockSize * sizeof(XML_Char ));
#line 6256
      temp = (BLOCK *)tmp;
      }
#line 6260
      if ((unsigned long )temp == (unsigned long )((void *)0)) {
#line 6261
        return ((XML_Bool )0);
      }
#line 6262
      pool->blocks = temp;
#line 6263
      (pool->blocks)->size = blockSize;
#line 6264
      pool->ptr = (pool->blocks)->s + (pool->ptr - pool->start);
#line 6265
      pool->start = (pool->blocks)->s;
#line 6266
      pool->end = (XML_Char const   *)(pool->start + blockSize);
    } else {
#line 6254
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
#line 6270
    blockSize___0 = (int )(pool->end - (XML_Char const   *)pool->start);
#line 6271
    if (blockSize___0 < 1024) {
#line 6272
      blockSize___0 = 1024;
    } else {
#line 6274
      blockSize___0 *= 2;
    }
    {
#line 6275
    tmp___0 = (*((pool->mem)->malloc_fcn))((unsigned long )(& ((BLOCK *)0)->s) + (unsigned long )blockSize___0 * sizeof(XML_Char ));
#line 6275
    tem___0 = (BLOCK *)tmp___0;
    }
#line 6277
    if (! tem___0) {
#line 6278
      return ((XML_Bool )0);
    }
#line 6279
    tem___0->size = blockSize___0;
#line 6280
    tem___0->next = pool->blocks;
#line 6281
    pool->blocks = tem___0;
#line 6282
    if ((unsigned long )pool->ptr != (unsigned long )pool->start) {
      {
#line 6283
      memcpy((void */* __restrict  */)(tem___0->s), (void const   */* __restrict  */)pool->start,
             (unsigned long )(pool->ptr - pool->start) * sizeof(XML_Char ));
      }
    }
#line 6285
    pool->ptr = tem___0->s + (pool->ptr - pool->start);
#line 6286
    pool->start = tem___0->s;
#line 6287
    pool->end = (XML_Char const   *)(tem___0->s + blockSize___0);
  }
#line 6289
  return ((XML_Bool )1);
}
}
#line 6292 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlparse.c"
static int nextScaffoldPart(XML_Parser parser ) 
{ 
  DTD *dtd ;
  CONTENT_SCAFFOLD *me ;
  int next ;
  void *tmp ;
  CONTENT_SCAFFOLD *temp ;
  void *tmp___0 ;
  void *tmp___1 ;
  unsigned int tmp___2 ;
  CONTENT_SCAFFOLD *parent ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 6295
  dtd = parser->m_dtd;
#line 6299
  if (! dtd->scaffIndex) {
    {
#line 6300
    tmp = (*(parser->m_mem.malloc_fcn))((unsigned long )parser->m_groupSize * sizeof(int ));
#line 6300
    dtd->scaffIndex = (int *)tmp;
    }
#line 6301
    if (! dtd->scaffIndex) {
#line 6302
      return (-1);
    }
#line 6303
    *(dtd->scaffIndex + 0) = 0;
  }
#line 6306
  if (dtd->scaffCount >= dtd->scaffSize) {
#line 6308
    if (dtd->scaffold) {
      {
#line 6309
      tmp___0 = (*(parser->m_mem.realloc_fcn))((void *)dtd->scaffold, (unsigned long )(dtd->scaffSize * 2U) * sizeof(CONTENT_SCAFFOLD ));
#line 6309
      temp = (CONTENT_SCAFFOLD *)tmp___0;
      }
#line 6311
      if ((unsigned long )temp == (unsigned long )((void *)0)) {
#line 6312
        return (-1);
      }
#line 6313
      dtd->scaffSize *= 2U;
    } else {
      {
#line 6316
      tmp___1 = (*(parser->m_mem.malloc_fcn))(32UL * sizeof(CONTENT_SCAFFOLD ));
#line 6316
      temp = (CONTENT_SCAFFOLD *)tmp___1;
      }
#line 6318
      if ((unsigned long )temp == (unsigned long )((void *)0)) {
#line 6319
        return (-1);
      }
#line 6320
      dtd->scaffSize = 32U;
    }
#line 6322
    dtd->scaffold = temp;
  }
#line 6324
  tmp___2 = dtd->scaffCount;
#line 6324
  (dtd->scaffCount) ++;
#line 6324
  next = (int )tmp___2;
#line 6325
  me = dtd->scaffold + next;
#line 6326
  if (dtd->scaffLevel) {
#line 6327
    parent = dtd->scaffold + *(dtd->scaffIndex + (dtd->scaffLevel - 1));
#line 6328
    if (parent->lastchild) {
#line 6329
      (dtd->scaffold + parent->lastchild)->nextsib = next;
    }
#line 6331
    if (! parent->childcnt) {
#line 6332
      parent->firstchild = next;
    }
#line 6333
    parent->lastchild = next;
#line 6334
    (parent->childcnt) ++;
  }
#line 6336
  tmp___5 = 0;
#line 6336
  me->nextsib = tmp___5;
#line 6336
  tmp___4 = tmp___5;
#line 6336
  me->childcnt = tmp___4;
#line 6336
  tmp___3 = tmp___4;
#line 6336
  me->lastchild = tmp___3;
#line 6336
  me->firstchild = tmp___3;
#line 6337
  return (next);
}
}
#line 6340 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlparse.c"
static void build_node(XML_Parser parser , int src_node , XML_Content *dest , XML_Content **contpos ,
                       XML_Char **strpos ) 
{ 
  DTD *dtd ;
  XML_Char const   *src ;
  XML_Char *tmp ;
  unsigned int i ;
  int cn ;

  {
#line 6347
  dtd = parser->m_dtd;
#line 6348
  dest->type = (dtd->scaffold + src_node)->type;
#line 6349
  dest->quant = (dtd->scaffold + src_node)->quant;
#line 6350
  if ((unsigned int )dest->type == 4U) {
#line 6352
    dest->name = *strpos;
#line 6353
    src = (dtd->scaffold + src_node)->name;
    {
#line 6354
    while (1) {
      while_continue: /* CIL Label */ ;
#line 6355
      tmp = *strpos;
#line 6355
      (*strpos) ++;
#line 6355
      *tmp = (XML_Char )*src;
#line 6356
      if (! *src) {
#line 6357
        goto while_break;
      }
#line 6358
      src ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 6360
    dest->numchildren = 0U;
#line 6361
    dest->children = (XML_Content *)((void *)0);
  } else {
#line 6366
    dest->numchildren = (unsigned int )(dtd->scaffold + src_node)->childcnt;
#line 6367
    dest->children = *contpos;
#line 6368
    *contpos += dest->numchildren;
#line 6369
    i = 0U;
#line 6369
    cn = (dtd->scaffold + src_node)->firstchild;
    {
#line 6369
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 6369
      if (! (i < dest->numchildren)) {
#line 6369
        goto while_break___0;
      }
      {
#line 6372
      build_node(parser, cn, dest->children + i, contpos, strpos);
#line 6369
      i ++;
#line 6369
      cn = (dtd->scaffold + cn)->nextsib;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 6374
    dest->name = (XML_Char *)((void *)0);
  }
#line 6376
  return;
}
}
#line 6378 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlparse.c"
static XML_Content *build_model(XML_Parser parser ) 
{ 
  DTD *dtd ;
  XML_Content *ret ;
  XML_Content *cpos ;
  XML_Char *str ;
  int allocsize ;
  void *tmp ;

  {
  {
#line 6381
  dtd = parser->m_dtd;
#line 6385
  allocsize = (int )((unsigned long )dtd->scaffCount * sizeof(XML_Content ) + (unsigned long )dtd->contentStringLen * sizeof(XML_Char ));
#line 6388
  tmp = (*(parser->m_mem.malloc_fcn))((size_t )allocsize);
#line 6388
  ret = (XML_Content *)tmp;
  }
#line 6389
  if (! ret) {
#line 6390
    return ((XML_Content *)((void *)0));
  }
  {
#line 6392
  str = (XML_Char *)(ret + dtd->scaffCount);
#line 6393
  cpos = ret + 1;
#line 6395
  build_node(parser, 0, ret, & cpos, & str);
  }
#line 6396
  return (ret);
}
}
#line 6399 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlparse.c"
static ELEMENT_TYPE *getElementType(XML_Parser parser , ENCODING const   *enc , char const   *ptr ,
                                    char const   *end ) 
{ 
  DTD *dtd ;
  XML_Char const   *name ;
  XML_Char *tmp ;
  ELEMENT_TYPE *ret ;
  NAMED *tmp___0 ;
  int tmp___1 ;

  {
  {
#line 6405
  dtd = parser->m_dtd;
#line 6406
  tmp = poolStoreString(& dtd->pool, enc, ptr, end);
#line 6406
  name = (XML_Char const   *)tmp;
  }
#line 6409
  if (! name) {
#line 6410
    return ((ELEMENT_TYPE *)((void *)0));
  }
  {
#line 6411
  tmp___0 = lookup(parser, & dtd->elementTypes, name, sizeof(ELEMENT_TYPE ));
#line 6411
  ret = (ELEMENT_TYPE *)tmp___0;
  }
#line 6412
  if (! ret) {
#line 6413
    return ((ELEMENT_TYPE *)((void *)0));
  }
#line 6414
  if ((unsigned long )ret->name != (unsigned long )name) {
#line 6415
    dtd->pool.ptr = dtd->pool.start;
  } else {
    {
#line 6417
    dtd->pool.start = dtd->pool.ptr;
#line 6418
    tmp___1 = setElementTypePrefix(parser, ret);
    }
#line 6418
    if (! tmp___1) {
#line 6419
      return ((ELEMENT_TYPE *)((void *)0));
    }
  }
#line 6421
  return (ret);
}
}
#line 33 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlrole.c"
static char const   KW_ANY[4]  = {      (char const   )65,      (char const   )78,      (char const   )89,      (char const   )'\000'};
#line 35 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlrole.c"
static char const   KW_ATTLIST[8]  = 
#line 35
  {      (char const   )65,      (char const   )84,      (char const   )84,      (char const   )76, 
        (char const   )73,      (char const   )83,      (char const   )84,      (char const   )'\000'};
#line 37 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlrole.c"
static char const   KW_CDATA[6]  = {      (char const   )67,      (char const   )68,      (char const   )65,      (char const   )84, 
        (char const   )65,      (char const   )'\000'};
#line 39 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlrole.c"
static char const   KW_DOCTYPE[8]  = 
#line 39
  {      (char const   )68,      (char const   )79,      (char const   )67,      (char const   )84, 
        (char const   )89,      (char const   )80,      (char const   )69,      (char const   )'\000'};
#line 41 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlrole.c"
static char const   KW_ELEMENT[8]  = 
#line 41
  {      (char const   )69,      (char const   )76,      (char const   )69,      (char const   )77, 
        (char const   )69,      (char const   )78,      (char const   )84,      (char const   )'\000'};
#line 43 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlrole.c"
static char const   KW_EMPTY[6]  = {      (char const   )69,      (char const   )77,      (char const   )80,      (char const   )84, 
        (char const   )89,      (char const   )'\000'};
#line 45 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlrole.c"
static char const   KW_ENTITIES[9]  = 
#line 45
  {      (char const   )69,      (char const   )78,      (char const   )84,      (char const   )73, 
        (char const   )84,      (char const   )73,      (char const   )69,      (char const   )83, 
        (char const   )'\000'};
#line 48 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlrole.c"
static char const   KW_ENTITY[7]  = {      (char const   )69,      (char const   )78,      (char const   )84,      (char const   )73, 
        (char const   )84,      (char const   )89,      (char const   )'\000'};
#line 50 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlrole.c"
static char const   KW_FIXED[6]  = {      (char const   )70,      (char const   )73,      (char const   )88,      (char const   )69, 
        (char const   )68,      (char const   )'\000'};
#line 52 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlrole.c"
static char const   KW_ID[3]  = {      (char const   )73,      (char const   )68,      (char const   )'\000'};
#line 54 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlrole.c"
static char const   KW_IDREF[6]  = {      (char const   )73,      (char const   )68,      (char const   )82,      (char const   )69, 
        (char const   )70,      (char const   )'\000'};
#line 56 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlrole.c"
static char const   KW_IDREFS[7]  = {      (char const   )73,      (char const   )68,      (char const   )82,      (char const   )69, 
        (char const   )70,      (char const   )83,      (char const   )'\000'};
#line 59 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlrole.c"
static char const   KW_IGNORE[7]  = {      (char const   )73,      (char const   )71,      (char const   )78,      (char const   )79, 
        (char const   )82,      (char const   )69,      (char const   )'\000'};
#line 62 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlrole.c"
static char const   KW_IMPLIED[8]  = 
#line 62
  {      (char const   )73,      (char const   )77,      (char const   )80,      (char const   )76, 
        (char const   )73,      (char const   )69,      (char const   )68,      (char const   )'\000'};
#line 65 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlrole.c"
static char const   KW_INCLUDE[8]  = 
#line 65
  {      (char const   )73,      (char const   )78,      (char const   )67,      (char const   )76, 
        (char const   )85,      (char const   )68,      (char const   )69,      (char const   )'\000'};
#line 68 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlrole.c"
static char const   KW_NDATA[6]  = {      (char const   )78,      (char const   )68,      (char const   )65,      (char const   )84, 
        (char const   )65,      (char const   )'\000'};
#line 70 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlrole.c"
static char const   KW_NMTOKEN[8]  = 
#line 70
  {      (char const   )78,      (char const   )77,      (char const   )84,      (char const   )79, 
        (char const   )75,      (char const   )69,      (char const   )78,      (char const   )'\000'};
#line 72 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlrole.c"
static char const   KW_NMTOKENS[9]  = 
#line 72
  {      (char const   )78,      (char const   )77,      (char const   )84,      (char const   )79, 
        (char const   )75,      (char const   )69,      (char const   )78,      (char const   )83, 
        (char const   )'\000'};
#line 75 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlrole.c"
static char const   KW_NOTATION[9]  = 
#line 75
  {      (char const   )78,      (char const   )79,      (char const   )84,      (char const   )65, 
        (char const   )84,      (char const   )73,      (char const   )79,      (char const   )78, 
        (char const   )'\000'};
#line 78 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlrole.c"
static char const   KW_PCDATA[7]  = {      (char const   )80,      (char const   )67,      (char const   )68,      (char const   )65, 
        (char const   )84,      (char const   )65,      (char const   )'\000'};
#line 80 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlrole.c"
static char const   KW_PUBLIC[7]  = {      (char const   )80,      (char const   )85,      (char const   )66,      (char const   )76, 
        (char const   )73,      (char const   )67,      (char const   )'\000'};
#line 82 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlrole.c"
static char const   KW_REQUIRED[9]  = 
#line 82
  {      (char const   )82,      (char const   )69,      (char const   )81,      (char const   )85, 
        (char const   )73,      (char const   )82,      (char const   )69,      (char const   )68, 
        (char const   )'\000'};
#line 85 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlrole.c"
static char const   KW_SYSTEM[7]  = {      (char const   )83,      (char const   )89,      (char const   )83,      (char const   )84, 
        (char const   )69,      (char const   )77,      (char const   )'\000'};
#line 107
static int prolog0(PROLOG_STATE *state , int tok , char const   *ptr , char const   *end ,
                   ENCODING const   *enc ) ;
#line 107
static int prolog1(PROLOG_STATE *state , int tok , char const   *ptr , char const   *end ,
                   ENCODING const   *enc ) ;
#line 107
static int prolog2(PROLOG_STATE *state , int tok , char const   *ptr , char const   *end ,
                   ENCODING const   *enc ) ;
#line 107
static int doctype0(PROLOG_STATE *state , int tok , char const   *ptr , char const   *end ,
                    ENCODING const   *enc ) ;
#line 107
static int doctype1(PROLOG_STATE *state , int tok , char const   *ptr , char const   *end ,
                    ENCODING const   *enc ) ;
#line 107
static int doctype2(PROLOG_STATE *state , int tok , char const   *ptr , char const   *end ,
                    ENCODING const   *enc ) ;
#line 107
static int doctype3(PROLOG_STATE *state , int tok , char const   *ptr , char const   *end ,
                    ENCODING const   *enc ) ;
#line 107
static int doctype4(PROLOG_STATE *state , int tok , char const   *ptr , char const   *end ,
                    ENCODING const   *enc ) ;
#line 107
static int doctype5(PROLOG_STATE *state , int tok , char const   *ptr , char const   *end ,
                    ENCODING const   *enc ) ;
#line 107
static int internalSubset(PROLOG_STATE *state , int tok , char const   *ptr , char const   *end ,
                          ENCODING const   *enc ) ;
#line 107
static int entity0(PROLOG_STATE *state , int tok , char const   *ptr , char const   *end ,
                   ENCODING const   *enc ) ;
#line 107
static int entity1(PROLOG_STATE *state , int tok , char const   *ptr , char const   *end ,
                   ENCODING const   *enc ) ;
#line 107
static int entity2(PROLOG_STATE *state , int tok , char const   *ptr , char const   *end ,
                   ENCODING const   *enc ) ;
#line 107
static int entity3(PROLOG_STATE *state , int tok , char const   *ptr , char const   *end ,
                   ENCODING const   *enc ) ;
#line 107
static int entity4(PROLOG_STATE *state , int tok , char const   *ptr , char const   *end ,
                   ENCODING const   *enc ) ;
#line 107
static int entity5(PROLOG_STATE *state , int tok , char const   *ptr , char const   *end ,
                   ENCODING const   *enc ) ;
#line 107
static int entity6(PROLOG_STATE *state , int tok , char const   *ptr , char const   *end ,
                   ENCODING const   *enc ) ;
#line 107
static int entity7(PROLOG_STATE *state , int tok , char const   *ptr , char const   *end ,
                   ENCODING const   *enc ) ;
#line 107
static int entity8(PROLOG_STATE *state , int tok , char const   *ptr , char const   *end ,
                   ENCODING const   *enc ) ;
#line 107
static int entity9(PROLOG_STATE *state , int tok , char const   *ptr , char const   *end ,
                   ENCODING const   *enc ) ;
#line 107
static int entity10(PROLOG_STATE *state , int tok , char const   *ptr , char const   *end ,
                    ENCODING const   *enc ) ;
#line 107
static int notation0(PROLOG_STATE *state , int tok , char const   *ptr , char const   *end ,
                     ENCODING const   *enc ) ;
#line 107
static int notation1(PROLOG_STATE *state , int tok , char const   *ptr , char const   *end ,
                     ENCODING const   *enc ) ;
#line 107
static int notation2(PROLOG_STATE *state , int tok , char const   *ptr , char const   *end ,
                     ENCODING const   *enc ) ;
#line 107
static int notation3(PROLOG_STATE *state , int tok , char const   *ptr , char const   *end ,
                     ENCODING const   *enc ) ;
#line 107
static int notation4(PROLOG_STATE *state , int tok , char const   *ptr , char const   *end ,
                     ENCODING const   *enc ) ;
#line 107
static int attlist0(PROLOG_STATE *state , int tok , char const   *ptr , char const   *end ,
                    ENCODING const   *enc ) ;
#line 107
static int attlist1(PROLOG_STATE *state , int tok , char const   *ptr , char const   *end ,
                    ENCODING const   *enc ) ;
#line 107
static int attlist2(PROLOG_STATE *state , int tok , char const   *ptr , char const   *end ,
                    ENCODING const   *enc ) ;
#line 107
static int attlist3(PROLOG_STATE *state , int tok , char const   *ptr , char const   *end ,
                    ENCODING const   *enc ) ;
#line 107
static int attlist4(PROLOG_STATE *state , int tok , char const   *ptr , char const   *end ,
                    ENCODING const   *enc ) ;
#line 107
static int attlist5(PROLOG_STATE *state , int tok , char const   *ptr , char const   *end ,
                    ENCODING const   *enc ) ;
#line 107
static int attlist6(PROLOG_STATE *state , int tok , char const   *ptr , char const   *end ,
                    ENCODING const   *enc ) ;
#line 107
static int attlist7(PROLOG_STATE *state , int tok , char const   *ptr , char const   *end ,
                    ENCODING const   *enc ) ;
#line 107
static int attlist8(PROLOG_STATE *state , int tok , char const   *ptr , char const   *end ,
                    ENCODING const   *enc ) ;
#line 107
static int attlist9(PROLOG_STATE *state , int tok , char const   *ptr , char const   *end ,
                    ENCODING const   *enc ) ;
#line 107
static int element0(PROLOG_STATE *state , int tok , char const   *ptr , char const   *end ,
                    ENCODING const   *enc ) ;
#line 107
static int element1(PROLOG_STATE *state , int tok , char const   *ptr , char const   *end ,
                    ENCODING const   *enc ) ;
#line 107
static int element2(PROLOG_STATE *state , int tok , char const   *ptr , char const   *end ,
                    ENCODING const   *enc ) ;
#line 107
static int element3(PROLOG_STATE *state , int tok , char const   *ptr , char const   *end ,
                    ENCODING const   *enc ) ;
#line 107
static int element4(PROLOG_STATE *state , int tok , char const   *ptr , char const   *end ,
                    ENCODING const   *enc ) ;
#line 107
static int element5(PROLOG_STATE *state , int tok , char const   *ptr , char const   *end ,
                    ENCODING const   *enc ) ;
#line 107
static int element6(PROLOG_STATE *state , int tok , char const   *ptr , char const   *end ,
                    ENCODING const   *enc ) ;
#line 107
static int element7(PROLOG_STATE *state , int tok , char const   *ptr , char const   *end ,
                    ENCODING const   *enc ) ;
#line 107
static int externalSubset0(PROLOG_STATE *state , int tok , char const   *ptr , char const   *end ,
                           ENCODING const   *enc ) ;
#line 107
static int externalSubset1(PROLOG_STATE *state , int tok , char const   *ptr , char const   *end ,
                           ENCODING const   *enc ) ;
#line 107
static int condSect0(PROLOG_STATE *state , int tok , char const   *ptr , char const   *end ,
                     ENCODING const   *enc ) ;
#line 107
static int condSect1(PROLOG_STATE *state , int tok , char const   *ptr , char const   *end ,
                     ENCODING const   *enc ) ;
#line 107
static int condSect2(PROLOG_STATE *state , int tok , char const   *ptr , char const   *end ,
                     ENCODING const   *enc ) ;
#line 107
static int declClose(PROLOG_STATE *state , int tok , char const   *ptr , char const   *end ,
                     ENCODING const   *enc ) ;
#line 107
static int error(PROLOG_STATE *state , int tok , char const   *ptr , char const   *end ,
                 ENCODING const   *enc ) ;
#line 125
static int common(PROLOG_STATE *state , int tok ) ;
#line 127 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlrole.c"
static int prolog0(PROLOG_STATE *state , int tok , char const   *ptr , char const   *end ,
                   ENCODING const   *enc ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  {
#line 135
  if (tok == 15) {
#line 135
    goto case_15;
  }
#line 138
  if (tok == 12) {
#line 138
    goto case_12;
  }
#line 141
  if (tok == 11) {
#line 141
    goto case_11;
  }
#line 144
  if (tok == 13) {
#line 144
    goto case_13;
  }
#line 147
  if (tok == 14) {
#line 147
    goto case_14;
  }
#line 149
  if (tok == 16) {
#line 149
    goto case_16;
  }
#line 157
  if (tok == 29) {
#line 157
    goto case_29;
  }
#line 134
  goto switch_break;
  case_15: /* CIL Label */ 
#line 136
  state->handler = & prolog1;
#line 137
  return (0);
  case_12: /* CIL Label */ 
#line 139
  state->handler = & prolog1;
#line 140
  return (1);
  case_11: /* CIL Label */ 
#line 142
  state->handler = & prolog1;
#line 143
  return (55);
  case_13: /* CIL Label */ 
#line 145
  state->handler = & prolog1;
#line 146
  return (56);
  case_14: /* CIL Label */ 
#line 148
  return (0);
  case_16: /* CIL Label */ 
  {
#line 150
  tmp = (*(enc->nameMatchesAscii))(enc, ptr + 2 * (int )enc->minBytesPerChar, end,
                                   KW_DOCTYPE);
  }
#line 150
  if (! tmp) {
#line 154
    goto switch_break;
  }
#line 155
  state->handler = & doctype0;
#line 156
  return (3);
  case_29: /* CIL Label */ 
#line 158
  state->handler = & error;
#line 159
  return (2);
  switch_break: /* CIL Label */ ;
  }
  {
#line 161
  tmp___0 = common(state, tok);
  }
#line 161
  return (tmp___0);
}
}
#line 164 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlrole.c"
static int prolog1(PROLOG_STATE *state , int tok , char const   *ptr , char const   *end ,
                   ENCODING const   *enc ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  {
#line 172
  if (tok == 15) {
#line 172
    goto case_15;
  }
#line 174
  if (tok == 11) {
#line 174
    goto case_11;
  }
#line 176
  if (tok == 13) {
#line 176
    goto case_13;
  }
#line 178
  if (tok == 14) {
#line 178
    goto case_14;
  }
#line 180
  if (tok == 16) {
#line 180
    goto case_16;
  }
#line 188
  if (tok == 29) {
#line 188
    goto case_29;
  }
#line 171
  goto switch_break;
  case_15: /* CIL Label */ 
#line 173
  return (0);
  case_11: /* CIL Label */ 
#line 175
  return (55);
  case_13: /* CIL Label */ 
#line 177
  return (56);
  case_14: /* CIL Label */ 
#line 179
  return (0);
  case_16: /* CIL Label */ 
  {
#line 181
  tmp = (*(enc->nameMatchesAscii))(enc, ptr + 2 * (int )enc->minBytesPerChar, end,
                                   KW_DOCTYPE);
  }
#line 181
  if (! tmp) {
#line 185
    goto switch_break;
  }
#line 186
  state->handler = & doctype0;
#line 187
  return (3);
  case_29: /* CIL Label */ 
#line 189
  state->handler = & error;
#line 190
  return (2);
  switch_break: /* CIL Label */ ;
  }
  {
#line 192
  tmp___0 = common(state, tok);
  }
#line 192
  return (tmp___0);
}
}
#line 195 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlrole.c"
static int prolog2(PROLOG_STATE *state , int tok , char const   *ptr , char const   *end ,
                   ENCODING const   *enc ) 
{ 
  int tmp ;

  {
  {
#line 203
  if (tok == 15) {
#line 203
    goto case_15;
  }
#line 205
  if (tok == 11) {
#line 205
    goto case_11;
  }
#line 207
  if (tok == 13) {
#line 207
    goto case_13;
  }
#line 209
  if (tok == 29) {
#line 209
    goto case_29;
  }
#line 202
  goto switch_break;
  case_15: /* CIL Label */ 
#line 204
  return (0);
  case_11: /* CIL Label */ 
#line 206
  return (55);
  case_13: /* CIL Label */ 
#line 208
  return (56);
  case_29: /* CIL Label */ 
#line 210
  state->handler = & error;
#line 211
  return (2);
  switch_break: /* CIL Label */ ;
  }
  {
#line 213
  tmp = common(state, tok);
  }
#line 213
  return (tmp);
}
}
#line 216 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlrole.c"
static int doctype0(PROLOG_STATE *state , int tok , char const   *ptr , char const   *end ,
                    ENCODING const   *enc ) 
{ 
  int tmp ;

  {
  {
#line 224
  if (tok == 15) {
#line 224
    goto case_15;
  }
#line 227
  if (tok == 41) {
#line 227
    goto case_41;
  }
#line 227
  if (tok == 18) {
#line 227
    goto case_41;
  }
#line 223
  goto switch_break;
  case_15: /* CIL Label */ 
#line 225
  return (3);
  case_41: /* CIL Label */ 
  case_18: /* CIL Label */ 
#line 228
  state->handler = & doctype1;
#line 229
  return (4);
  switch_break: /* CIL Label */ ;
  }
  {
#line 231
  tmp = common(state, tok);
  }
#line 231
  return (tmp);
}
}
#line 234 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlrole.c"
static int doctype1(PROLOG_STATE *state , int tok , char const   *ptr , char const   *end ,
                    ENCODING const   *enc ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 242
  if (tok == 15) {
#line 242
    goto case_15;
  }
#line 244
  if (tok == 25) {
#line 244
    goto case_25;
  }
#line 247
  if (tok == 17) {
#line 247
    goto case_17;
  }
#line 250
  if (tok == 18) {
#line 250
    goto case_18;
  }
#line 241
  goto switch_break;
  case_15: /* CIL Label */ 
#line 243
  return (3);
  case_25: /* CIL Label */ 
#line 245
  state->handler = & internalSubset;
#line 246
  return (7);
  case_17: /* CIL Label */ 
#line 248
  state->handler = & prolog2;
#line 249
  return (8);
  case_18: /* CIL Label */ 
  {
#line 251
  tmp = (*(enc->nameMatchesAscii))(enc, ptr, end, KW_SYSTEM);
  }
#line 251
  if (tmp) {
#line 252
    state->handler = & doctype3;
#line 253
    return (3);
  }
  {
#line 255
  tmp___0 = (*(enc->nameMatchesAscii))(enc, ptr, end, KW_PUBLIC);
  }
#line 255
  if (tmp___0) {
#line 256
    state->handler = & doctype2;
#line 257
    return (3);
  }
#line 259
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 261
  tmp___1 = common(state, tok);
  }
#line 261
  return (tmp___1);
}
}
#line 264 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlrole.c"
static int doctype2(PROLOG_STATE *state , int tok , char const   *ptr , char const   *end ,
                    ENCODING const   *enc ) 
{ 
  int tmp ;

  {
  {
#line 272
  if (tok == 15) {
#line 272
    goto case_15;
  }
#line 274
  if (tok == 27) {
#line 274
    goto case_27;
  }
#line 271
  goto switch_break;
  case_15: /* CIL Label */ 
#line 273
  return (3);
  case_27: /* CIL Label */ 
#line 275
  state->handler = & doctype3;
#line 276
  return (6);
  switch_break: /* CIL Label */ ;
  }
  {
#line 278
  tmp = common(state, tok);
  }
#line 278
  return (tmp);
}
}
#line 281 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlrole.c"
static int doctype3(PROLOG_STATE *state , int tok , char const   *ptr , char const   *end ,
                    ENCODING const   *enc ) 
{ 
  int tmp ;

  {
  {
#line 289
  if (tok == 15) {
#line 289
    goto case_15;
  }
#line 291
  if (tok == 27) {
#line 291
    goto case_27;
  }
#line 288
  goto switch_break;
  case_15: /* CIL Label */ 
#line 290
  return (3);
  case_27: /* CIL Label */ 
#line 292
  state->handler = & doctype4;
#line 293
  return (5);
  switch_break: /* CIL Label */ ;
  }
  {
#line 295
  tmp = common(state, tok);
  }
#line 295
  return (tmp);
}
}
#line 298 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlrole.c"
static int doctype4(PROLOG_STATE *state , int tok , char const   *ptr , char const   *end ,
                    ENCODING const   *enc ) 
{ 
  int tmp ;

  {
  {
#line 306
  if (tok == 15) {
#line 306
    goto case_15;
  }
#line 308
  if (tok == 25) {
#line 308
    goto case_25;
  }
#line 311
  if (tok == 17) {
#line 311
    goto case_17;
  }
#line 305
  goto switch_break;
  case_15: /* CIL Label */ 
#line 307
  return (3);
  case_25: /* CIL Label */ 
#line 309
  state->handler = & internalSubset;
#line 310
  return (7);
  case_17: /* CIL Label */ 
#line 312
  state->handler = & prolog2;
#line 313
  return (8);
  switch_break: /* CIL Label */ ;
  }
  {
#line 315
  tmp = common(state, tok);
  }
#line 315
  return (tmp);
}
}
#line 318 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlrole.c"
static int doctype5(PROLOG_STATE *state , int tok , char const   *ptr , char const   *end ,
                    ENCODING const   *enc ) 
{ 
  int tmp ;

  {
  {
#line 326
  if (tok == 15) {
#line 326
    goto case_15;
  }
#line 328
  if (tok == 17) {
#line 328
    goto case_17;
  }
#line 325
  goto switch_break;
  case_15: /* CIL Label */ 
#line 327
  return (3);
  case_17: /* CIL Label */ 
#line 329
  state->handler = & prolog2;
#line 330
  return (8);
  switch_break: /* CIL Label */ ;
  }
  {
#line 332
  tmp = common(state, tok);
  }
#line 332
  return (tmp);
}
}
#line 335 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlrole.c"
static int internalSubset(PROLOG_STATE *state , int tok , char const   *ptr , char const   *end ,
                          ENCODING const   *enc ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  {
#line 343
  if (tok == 15) {
#line 343
    goto case_15;
  }
#line 345
  if (tok == 16) {
#line 345
    goto case_16;
  }
#line 375
  if (tok == 11) {
#line 375
    goto case_11;
  }
#line 377
  if (tok == 13) {
#line 377
    goto case_13;
  }
#line 379
  if (tok == 28) {
#line 379
    goto case_28;
  }
#line 381
  if (tok == 26) {
#line 381
    goto case_26;
  }
#line 384
  if (tok == -4) {
#line 384
    goto case_neg_4;
  }
#line 342
  goto switch_break;
  case_15: /* CIL Label */ 
#line 344
  return (0);
  case_16: /* CIL Label */ 
  {
#line 346
  tmp = (*(enc->nameMatchesAscii))(enc, ptr + 2 * (int )enc->minBytesPerChar, end,
                                   KW_ENTITY);
  }
#line 346
  if (tmp) {
#line 350
    state->handler = & entity0;
#line 351
    return (11);
  }
  {
#line 353
  tmp___0 = (*(enc->nameMatchesAscii))(enc, ptr + 2 * (int )enc->minBytesPerChar,
                                       end, KW_ATTLIST);
  }
#line 353
  if (tmp___0) {
#line 357
    state->handler = & attlist0;
#line 358
    return (33);
  }
  {
#line 360
  tmp___1 = (*(enc->nameMatchesAscii))(enc, ptr + 2 * (int )enc->minBytesPerChar,
                                       end, KW_ELEMENT);
  }
#line 360
  if (tmp___1) {
#line 364
    state->handler = & element0;
#line 365
    return (39);
  }
  {
#line 367
  tmp___2 = (*(enc->nameMatchesAscii))(enc, ptr + 2 * (int )enc->minBytesPerChar,
                                       end, KW_NOTATION);
  }
#line 367
  if (tmp___2) {
#line 371
    state->handler = & notation0;
#line 372
    return (17);
  }
#line 374
  goto switch_break;
  case_11: /* CIL Label */ 
#line 376
  return (55);
  case_13: /* CIL Label */ 
#line 378
  return (56);
  case_28: /* CIL Label */ 
#line 380
  return (60);
  case_26: /* CIL Label */ 
#line 382
  state->handler = & doctype5;
#line 383
  return (3);
  case_neg_4: /* CIL Label */ 
#line 385
  return (0);
  switch_break: /* CIL Label */ ;
  }
  {
#line 387
  tmp___3 = common(state, tok);
  }
#line 387
  return (tmp___3);
}
}
#line 392 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlrole.c"
static int externalSubset0(PROLOG_STATE *state , int tok , char const   *ptr , char const   *end ,
                           ENCODING const   *enc ) 
{ 
  int tmp ;

  {
#line 399
  state->handler = & externalSubset1;
#line 400
  if (tok == 12) {
#line 401
    return (57);
  }
  {
#line 402
  tmp = externalSubset1(state, tok, ptr, end, enc);
  }
#line 402
  return (tmp);
}
}
#line 405 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlrole.c"
static int externalSubset1(PROLOG_STATE *state , int tok , char const   *ptr , char const   *end ,
                           ENCODING const   *enc ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  {
#line 413
  if (tok == 33) {
#line 413
    goto case_33;
  }
#line 416
  if (tok == 34) {
#line 416
    goto case_34;
  }
#line 421
  if (tok == 15) {
#line 421
    goto case_15;
  }
#line 423
  if (tok == 26) {
#line 423
    goto case_26;
  }
#line 425
  if (tok == -4) {
#line 425
    goto case_neg_4;
  }
#line 429
  goto switch_default;
  case_33: /* CIL Label */ 
#line 414
  state->handler = & condSect0;
#line 415
  return (0);
  case_34: /* CIL Label */ 
#line 417
  if (state->includeLevel == 0U) {
#line 418
    goto switch_break;
  }
#line 419
  (state->includeLevel) --;
#line 420
  return (0);
  case_15: /* CIL Label */ 
#line 422
  return (0);
  case_26: /* CIL Label */ 
#line 424
  goto switch_break;
  case_neg_4: /* CIL Label */ 
#line 426
  if (state->includeLevel) {
#line 427
    goto switch_break;
  }
#line 428
  return (0);
  switch_default: /* CIL Label */ 
  {
#line 430
  tmp = internalSubset(state, tok, ptr, end, enc);
  }
#line 430
  return (tmp);
  switch_break: /* CIL Label */ ;
  }
  {
#line 432
  tmp___0 = common(state, tok);
  }
#line 432
  return (tmp___0);
}
}
#line 437 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlrole.c"
static int entity0(PROLOG_STATE *state , int tok , char const   *ptr , char const   *end ,
                   ENCODING const   *enc ) 
{ 
  int tmp ;

  {
  {
#line 445
  if (tok == 15) {
#line 445
    goto case_15;
  }
#line 447
  if (tok == 22) {
#line 447
    goto case_22;
  }
#line 450
  if (tok == 18) {
#line 450
    goto case_18;
  }
#line 444
  goto switch_break;
  case_15: /* CIL Label */ 
#line 446
  return (11);
  case_22: /* CIL Label */ 
#line 448
  state->handler = & entity1;
#line 449
  return (11);
  case_18: /* CIL Label */ 
#line 451
  state->handler = & entity2;
#line 452
  return (9);
  switch_break: /* CIL Label */ ;
  }
  {
#line 454
  tmp = common(state, tok);
  }
#line 454
  return (tmp);
}
}
#line 457 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlrole.c"
static int entity1(PROLOG_STATE *state , int tok , char const   *ptr , char const   *end ,
                   ENCODING const   *enc ) 
{ 
  int tmp ;

  {
  {
#line 465
  if (tok == 15) {
#line 465
    goto case_15;
  }
#line 467
  if (tok == 18) {
#line 467
    goto case_18;
  }
#line 464
  goto switch_break;
  case_15: /* CIL Label */ 
#line 466
  return (11);
  case_18: /* CIL Label */ 
#line 468
  state->handler = & entity7;
#line 469
  return (10);
  switch_break: /* CIL Label */ ;
  }
  {
#line 471
  tmp = common(state, tok);
  }
#line 471
  return (tmp);
}
}
#line 474 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlrole.c"
static int entity2(PROLOG_STATE *state , int tok , char const   *ptr , char const   *end ,
                   ENCODING const   *enc ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 482
  if (tok == 15) {
#line 482
    goto case_15;
  }
#line 484
  if (tok == 18) {
#line 484
    goto case_18;
  }
#line 494
  if (tok == 27) {
#line 494
    goto case_27;
  }
#line 481
  goto switch_break;
  case_15: /* CIL Label */ 
#line 483
  return (11);
  case_18: /* CIL Label */ 
  {
#line 485
  tmp = (*(enc->nameMatchesAscii))(enc, ptr, end, KW_SYSTEM);
  }
#line 485
  if (tmp) {
#line 486
    state->handler = & entity4;
#line 487
    return (11);
  }
  {
#line 489
  tmp___0 = (*(enc->nameMatchesAscii))(enc, ptr, end, KW_PUBLIC);
  }
#line 489
  if (tmp___0) {
#line 490
    state->handler = & entity3;
#line 491
    return (11);
  }
#line 493
  goto switch_break;
  case_27: /* CIL Label */ 
#line 495
  state->handler = & declClose;
#line 496
  state->role_none = 11;
#line 497
  return (12);
  switch_break: /* CIL Label */ ;
  }
  {
#line 499
  tmp___1 = common(state, tok);
  }
#line 499
  return (tmp___1);
}
}
#line 502 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlrole.c"
static int entity3(PROLOG_STATE *state , int tok , char const   *ptr , char const   *end ,
                   ENCODING const   *enc ) 
{ 
  int tmp ;

  {
  {
#line 510
  if (tok == 15) {
#line 510
    goto case_15;
  }
#line 512
  if (tok == 27) {
#line 512
    goto case_27;
  }
#line 509
  goto switch_break;
  case_15: /* CIL Label */ 
#line 511
  return (11);
  case_27: /* CIL Label */ 
#line 513
  state->handler = & entity4;
#line 514
  return (14);
  switch_break: /* CIL Label */ ;
  }
  {
#line 516
  tmp = common(state, tok);
  }
#line 516
  return (tmp);
}
}
#line 519 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlrole.c"
static int entity4(PROLOG_STATE *state , int tok , char const   *ptr , char const   *end ,
                   ENCODING const   *enc ) 
{ 
  int tmp ;

  {
  {
#line 527
  if (tok == 15) {
#line 527
    goto case_15;
  }
#line 529
  if (tok == 27) {
#line 529
    goto case_27;
  }
#line 526
  goto switch_break;
  case_15: /* CIL Label */ 
#line 528
  return (11);
  case_27: /* CIL Label */ 
#line 530
  state->handler = & entity5;
#line 531
  return (13);
  switch_break: /* CIL Label */ ;
  }
  {
#line 533
  tmp = common(state, tok);
  }
#line 533
  return (tmp);
}
}
#line 536 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlrole.c"
static int entity5(PROLOG_STATE *state , int tok , char const   *ptr , char const   *end ,
                   ENCODING const   *enc ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  {
#line 544
  if (tok == 15) {
#line 544
    goto case_15;
  }
#line 546
  if (tok == 17) {
#line 546
    goto case_17;
  }
#line 549
  if (tok == 18) {
#line 549
    goto case_18;
  }
#line 543
  goto switch_break;
  case_15: /* CIL Label */ 
#line 545
  return (11);
  case_17: /* CIL Label */ 
#line 547
  if (state->documentEntity) {
#line 547
    state->handler = & internalSubset;
  } else {
#line 547
    state->handler = & externalSubset1;
  }
#line 548
  return (15);
  case_18: /* CIL Label */ 
  {
#line 550
  tmp = (*(enc->nameMatchesAscii))(enc, ptr, end, KW_NDATA);
  }
#line 550
  if (tmp) {
#line 551
    state->handler = & entity6;
#line 552
    return (11);
  }
#line 554
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 556
  tmp___0 = common(state, tok);
  }
#line 556
  return (tmp___0);
}
}
#line 559 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlrole.c"
static int entity6(PROLOG_STATE *state , int tok , char const   *ptr , char const   *end ,
                   ENCODING const   *enc ) 
{ 
  int tmp ;

  {
  {
#line 567
  if (tok == 15) {
#line 567
    goto case_15;
  }
#line 569
  if (tok == 18) {
#line 569
    goto case_18;
  }
#line 566
  goto switch_break;
  case_15: /* CIL Label */ 
#line 568
  return (11);
  case_18: /* CIL Label */ 
#line 570
  state->handler = & declClose;
#line 571
  state->role_none = 11;
#line 572
  return (16);
  switch_break: /* CIL Label */ ;
  }
  {
#line 574
  tmp = common(state, tok);
  }
#line 574
  return (tmp);
}
}
#line 577 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlrole.c"
static int entity7(PROLOG_STATE *state , int tok , char const   *ptr , char const   *end ,
                   ENCODING const   *enc ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 585
  if (tok == 15) {
#line 585
    goto case_15;
  }
#line 587
  if (tok == 18) {
#line 587
    goto case_18;
  }
#line 597
  if (tok == 27) {
#line 597
    goto case_27;
  }
#line 584
  goto switch_break;
  case_15: /* CIL Label */ 
#line 586
  return (11);
  case_18: /* CIL Label */ 
  {
#line 588
  tmp = (*(enc->nameMatchesAscii))(enc, ptr, end, KW_SYSTEM);
  }
#line 588
  if (tmp) {
#line 589
    state->handler = & entity9;
#line 590
    return (11);
  }
  {
#line 592
  tmp___0 = (*(enc->nameMatchesAscii))(enc, ptr, end, KW_PUBLIC);
  }
#line 592
  if (tmp___0) {
#line 593
    state->handler = & entity8;
#line 594
    return (11);
  }
#line 596
  goto switch_break;
  case_27: /* CIL Label */ 
#line 598
  state->handler = & declClose;
#line 599
  state->role_none = 11;
#line 600
  return (12);
  switch_break: /* CIL Label */ ;
  }
  {
#line 602
  tmp___1 = common(state, tok);
  }
#line 602
  return (tmp___1);
}
}
#line 605 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlrole.c"
static int entity8(PROLOG_STATE *state , int tok , char const   *ptr , char const   *end ,
                   ENCODING const   *enc ) 
{ 
  int tmp ;

  {
  {
#line 613
  if (tok == 15) {
#line 613
    goto case_15;
  }
#line 615
  if (tok == 27) {
#line 615
    goto case_27;
  }
#line 612
  goto switch_break;
  case_15: /* CIL Label */ 
#line 614
  return (11);
  case_27: /* CIL Label */ 
#line 616
  state->handler = & entity9;
#line 617
  return (14);
  switch_break: /* CIL Label */ ;
  }
  {
#line 619
  tmp = common(state, tok);
  }
#line 619
  return (tmp);
}
}
#line 622 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlrole.c"
static int entity9(PROLOG_STATE *state , int tok , char const   *ptr , char const   *end ,
                   ENCODING const   *enc ) 
{ 
  int tmp ;

  {
  {
#line 630
  if (tok == 15) {
#line 630
    goto case_15;
  }
#line 632
  if (tok == 27) {
#line 632
    goto case_27;
  }
#line 629
  goto switch_break;
  case_15: /* CIL Label */ 
#line 631
  return (11);
  case_27: /* CIL Label */ 
#line 633
  state->handler = & entity10;
#line 634
  return (13);
  switch_break: /* CIL Label */ ;
  }
  {
#line 636
  tmp = common(state, tok);
  }
#line 636
  return (tmp);
}
}
#line 639 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlrole.c"
static int entity10(PROLOG_STATE *state , int tok , char const   *ptr , char const   *end ,
                    ENCODING const   *enc ) 
{ 
  int tmp ;

  {
  {
#line 647
  if (tok == 15) {
#line 647
    goto case_15;
  }
#line 649
  if (tok == 17) {
#line 649
    goto case_17;
  }
#line 646
  goto switch_break;
  case_15: /* CIL Label */ 
#line 648
  return (11);
  case_17: /* CIL Label */ 
#line 650
  if (state->documentEntity) {
#line 650
    state->handler = & internalSubset;
  } else {
#line 650
    state->handler = & externalSubset1;
  }
#line 651
  return (15);
  switch_break: /* CIL Label */ ;
  }
  {
#line 653
  tmp = common(state, tok);
  }
#line 653
  return (tmp);
}
}
#line 656 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlrole.c"
static int notation0(PROLOG_STATE *state , int tok , char const   *ptr , char const   *end ,
                     ENCODING const   *enc ) 
{ 
  int tmp ;

  {
  {
#line 664
  if (tok == 15) {
#line 664
    goto case_15;
  }
#line 666
  if (tok == 18) {
#line 666
    goto case_18;
  }
#line 663
  goto switch_break;
  case_15: /* CIL Label */ 
#line 665
  return (17);
  case_18: /* CIL Label */ 
#line 667
  state->handler = & notation1;
#line 668
  return (18);
  switch_break: /* CIL Label */ ;
  }
  {
#line 670
  tmp = common(state, tok);
  }
#line 670
  return (tmp);
}
}
#line 673 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlrole.c"
static int notation1(PROLOG_STATE *state , int tok , char const   *ptr , char const   *end ,
                     ENCODING const   *enc ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 681
  if (tok == 15) {
#line 681
    goto case_15;
  }
#line 683
  if (tok == 18) {
#line 683
    goto case_18;
  }
#line 680
  goto switch_break;
  case_15: /* CIL Label */ 
#line 682
  return (17);
  case_18: /* CIL Label */ 
  {
#line 684
  tmp = (*(enc->nameMatchesAscii))(enc, ptr, end, KW_SYSTEM);
  }
#line 684
  if (tmp) {
#line 685
    state->handler = & notation3;
#line 686
    return (17);
  }
  {
#line 688
  tmp___0 = (*(enc->nameMatchesAscii))(enc, ptr, end, KW_PUBLIC);
  }
#line 688
  if (tmp___0) {
#line 689
    state->handler = & notation2;
#line 690
    return (17);
  }
#line 692
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 694
  tmp___1 = common(state, tok);
  }
#line 694
  return (tmp___1);
}
}
#line 697 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlrole.c"
static int notation2(PROLOG_STATE *state , int tok , char const   *ptr , char const   *end ,
                     ENCODING const   *enc ) 
{ 
  int tmp ;

  {
  {
#line 705
  if (tok == 15) {
#line 705
    goto case_15;
  }
#line 707
  if (tok == 27) {
#line 707
    goto case_27;
  }
#line 704
  goto switch_break;
  case_15: /* CIL Label */ 
#line 706
  return (17);
  case_27: /* CIL Label */ 
#line 708
  state->handler = & notation4;
#line 709
  return (21);
  switch_break: /* CIL Label */ ;
  }
  {
#line 711
  tmp = common(state, tok);
  }
#line 711
  return (tmp);
}
}
#line 714 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlrole.c"
static int notation3(PROLOG_STATE *state , int tok , char const   *ptr , char const   *end ,
                     ENCODING const   *enc ) 
{ 
  int tmp ;

  {
  {
#line 722
  if (tok == 15) {
#line 722
    goto case_15;
  }
#line 724
  if (tok == 27) {
#line 724
    goto case_27;
  }
#line 721
  goto switch_break;
  case_15: /* CIL Label */ 
#line 723
  return (17);
  case_27: /* CIL Label */ 
#line 725
  state->handler = & declClose;
#line 726
  state->role_none = 17;
#line 727
  return (19);
  switch_break: /* CIL Label */ ;
  }
  {
#line 729
  tmp = common(state, tok);
  }
#line 729
  return (tmp);
}
}
#line 732 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlrole.c"
static int notation4(PROLOG_STATE *state , int tok , char const   *ptr , char const   *end ,
                     ENCODING const   *enc ) 
{ 
  int tmp ;

  {
  {
#line 740
  if (tok == 15) {
#line 740
    goto case_15;
  }
#line 742
  if (tok == 27) {
#line 742
    goto case_27;
  }
#line 746
  if (tok == 17) {
#line 746
    goto case_17;
  }
#line 739
  goto switch_break;
  case_15: /* CIL Label */ 
#line 741
  return (17);
  case_27: /* CIL Label */ 
#line 743
  state->handler = & declClose;
#line 744
  state->role_none = 17;
#line 745
  return (19);
  case_17: /* CIL Label */ 
#line 747
  if (state->documentEntity) {
#line 747
    state->handler = & internalSubset;
  } else {
#line 747
    state->handler = & externalSubset1;
  }
#line 748
  return (20);
  switch_break: /* CIL Label */ ;
  }
  {
#line 750
  tmp = common(state, tok);
  }
#line 750
  return (tmp);
}
}
#line 753 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlrole.c"
static int attlist0(PROLOG_STATE *state , int tok , char const   *ptr , char const   *end ,
                    ENCODING const   *enc ) 
{ 
  int tmp ;

  {
  {
#line 761
  if (tok == 15) {
#line 761
    goto case_15;
  }
#line 764
  if (tok == 41) {
#line 764
    goto case_41;
  }
#line 764
  if (tok == 18) {
#line 764
    goto case_41;
  }
#line 760
  goto switch_break;
  case_15: /* CIL Label */ 
#line 762
  return (33);
  case_41: /* CIL Label */ 
  case_18: /* CIL Label */ 
#line 765
  state->handler = & attlist1;
#line 766
  return (34);
  switch_break: /* CIL Label */ ;
  }
  {
#line 768
  tmp = common(state, tok);
  }
#line 768
  return (tmp);
}
}
#line 771 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlrole.c"
static int attlist1(PROLOG_STATE *state , int tok , char const   *ptr , char const   *end ,
                    ENCODING const   *enc ) 
{ 
  int tmp ;

  {
  {
#line 779
  if (tok == 15) {
#line 779
    goto case_15;
  }
#line 781
  if (tok == 17) {
#line 781
    goto case_17;
  }
#line 785
  if (tok == 41) {
#line 785
    goto case_41;
  }
#line 785
  if (tok == 18) {
#line 785
    goto case_41;
  }
#line 778
  goto switch_break;
  case_15: /* CIL Label */ 
#line 780
  return (33);
  case_17: /* CIL Label */ 
#line 782
  if (state->documentEntity) {
#line 782
    state->handler = & internalSubset;
  } else {
#line 782
    state->handler = & externalSubset1;
  }
#line 783
  return (33);
  case_41: /* CIL Label */ 
  case_18: /* CIL Label */ 
#line 786
  state->handler = & attlist2;
#line 787
  return (22);
  switch_break: /* CIL Label */ ;
  }
  {
#line 789
  tmp = common(state, tok);
  }
#line 789
  return (tmp);
}
}
#line 804 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlrole.c"
static char const   * const  types[8]  = 
#line 804
  {      (char const   */* const  */)(KW_CDATA),      (char const   */* const  */)(KW_ID),      (char const   */* const  */)(KW_IDREF),      (char const   */* const  */)(KW_IDREFS), 
        (char const   */* const  */)(KW_ENTITY),      (char const   */* const  */)(KW_ENTITIES),      (char const   */* const  */)(KW_NMTOKEN),      (char const   */* const  */)(KW_NMTOKENS)};
#line 792 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlrole.c"
static int attlist2(PROLOG_STATE *state , int tok , char const   *ptr , char const   *end ,
                    ENCODING const   *enc ) 
{ 
  int i ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 800
  if (tok == 15) {
#line 800
    goto case_15;
  }
#line 802
  if (tok == 18) {
#line 802
    goto case_18;
  }
#line 826
  if (tok == 23) {
#line 826
    goto case_23;
  }
#line 799
  goto switch_break;
  case_15: /* CIL Label */ 
#line 801
  return (33);
  case_18: /* CIL Label */ 
#line 815
  i = 0;
  {
#line 815
  while (1) {
    while_continue: /* CIL Label */ ;
#line 815
    if (! (i < (int )(sizeof(types) / sizeof(types[0])))) {
#line 815
      goto while_break;
    }
    {
#line 816
    tmp = (*(enc->nameMatchesAscii))(enc, ptr, end, (char const   *)types[i]);
    }
#line 816
    if (tmp) {
#line 817
      state->handler = & attlist8;
#line 818
      return (23 + i);
    }
#line 815
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 821
  tmp___0 = (*(enc->nameMatchesAscii))(enc, ptr, end, KW_NOTATION);
  }
#line 821
  if (tmp___0) {
#line 822
    state->handler = & attlist5;
#line 823
    return (33);
  }
#line 825
  goto switch_break;
  case_23: /* CIL Label */ 
#line 827
  state->handler = & attlist3;
#line 828
  return (33);
  switch_break: /* CIL Label */ ;
  }
  {
#line 830
  tmp___1 = common(state, tok);
  }
#line 830
  return (tmp___1);
}
}
#line 833 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlrole.c"
static int attlist3(PROLOG_STATE *state , int tok , char const   *ptr , char const   *end ,
                    ENCODING const   *enc ) 
{ 
  int tmp ;

  {
  {
#line 841
  if (tok == 15) {
#line 841
    goto case_15;
  }
#line 845
  if (tok == 41) {
#line 845
    goto case_41;
  }
#line 845
  if (tok == 18) {
#line 845
    goto case_41;
  }
#line 845
  if (tok == 19) {
#line 845
    goto case_41;
  }
#line 840
  goto switch_break;
  case_15: /* CIL Label */ 
#line 842
  return (33);
  case_41: /* CIL Label */ 
  case_18: /* CIL Label */ 
  case_19: /* CIL Label */ 
#line 846
  state->handler = & attlist4;
#line 847
  return (31);
  switch_break: /* CIL Label */ ;
  }
  {
#line 849
  tmp = common(state, tok);
  }
#line 849
  return (tmp);
}
}
#line 852 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlrole.c"
static int attlist4(PROLOG_STATE *state , int tok , char const   *ptr , char const   *end ,
                    ENCODING const   *enc ) 
{ 
  int tmp ;

  {
  {
#line 860
  if (tok == 15) {
#line 860
    goto case_15;
  }
#line 862
  if (tok == 24) {
#line 862
    goto case_24;
  }
#line 865
  if (tok == 21) {
#line 865
    goto case_21;
  }
#line 859
  goto switch_break;
  case_15: /* CIL Label */ 
#line 861
  return (33);
  case_24: /* CIL Label */ 
#line 863
  state->handler = & attlist8;
#line 864
  return (33);
  case_21: /* CIL Label */ 
#line 866
  state->handler = & attlist3;
#line 867
  return (33);
  switch_break: /* CIL Label */ ;
  }
  {
#line 869
  tmp = common(state, tok);
  }
#line 869
  return (tmp);
}
}
#line 872 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlrole.c"
static int attlist5(PROLOG_STATE *state , int tok , char const   *ptr , char const   *end ,
                    ENCODING const   *enc ) 
{ 
  int tmp ;

  {
  {
#line 880
  if (tok == 15) {
#line 880
    goto case_15;
  }
#line 882
  if (tok == 23) {
#line 882
    goto case_23;
  }
#line 879
  goto switch_break;
  case_15: /* CIL Label */ 
#line 881
  return (33);
  case_23: /* CIL Label */ 
#line 883
  state->handler = & attlist6;
#line 884
  return (33);
  switch_break: /* CIL Label */ ;
  }
  {
#line 886
  tmp = common(state, tok);
  }
#line 886
  return (tmp);
}
}
#line 889 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlrole.c"
static int attlist6(PROLOG_STATE *state , int tok , char const   *ptr , char const   *end ,
                    ENCODING const   *enc ) 
{ 
  int tmp ;

  {
  {
#line 897
  if (tok == 15) {
#line 897
    goto case_15;
  }
#line 899
  if (tok == 18) {
#line 899
    goto case_18;
  }
#line 896
  goto switch_break;
  case_15: /* CIL Label */ 
#line 898
  return (33);
  case_18: /* CIL Label */ 
#line 900
  state->handler = & attlist7;
#line 901
  return (32);
  switch_break: /* CIL Label */ ;
  }
  {
#line 903
  tmp = common(state, tok);
  }
#line 903
  return (tmp);
}
}
#line 906 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlrole.c"
static int attlist7(PROLOG_STATE *state , int tok , char const   *ptr , char const   *end ,
                    ENCODING const   *enc ) 
{ 
  int tmp ;

  {
  {
#line 914
  if (tok == 15) {
#line 914
    goto case_15;
  }
#line 916
  if (tok == 24) {
#line 916
    goto case_24;
  }
#line 919
  if (tok == 21) {
#line 919
    goto case_21;
  }
#line 913
  goto switch_break;
  case_15: /* CIL Label */ 
#line 915
  return (33);
  case_24: /* CIL Label */ 
#line 917
  state->handler = & attlist8;
#line 918
  return (33);
  case_21: /* CIL Label */ 
#line 920
  state->handler = & attlist6;
#line 921
  return (33);
  switch_break: /* CIL Label */ ;
  }
  {
#line 923
  tmp = common(state, tok);
  }
#line 923
  return (tmp);
}
}
#line 927 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlrole.c"
static int attlist8(PROLOG_STATE *state , int tok , char const   *ptr , char const   *end ,
                    ENCODING const   *enc ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 935
  if (tok == 15) {
#line 935
    goto case_15;
  }
#line 937
  if (tok == 20) {
#line 937
    goto case_20;
  }
#line 960
  if (tok == 27) {
#line 960
    goto case_27;
  }
#line 934
  goto switch_break;
  case_15: /* CIL Label */ 
#line 936
  return (33);
  case_20: /* CIL Label */ 
  {
#line 938
  tmp = (*(enc->nameMatchesAscii))(enc, ptr + enc->minBytesPerChar, end, KW_IMPLIED);
  }
#line 938
  if (tmp) {
#line 942
    state->handler = & attlist1;
#line 943
    return (35);
  }
  {
#line 945
  tmp___0 = (*(enc->nameMatchesAscii))(enc, ptr + enc->minBytesPerChar, end, KW_REQUIRED);
  }
#line 945
  if (tmp___0) {
#line 949
    state->handler = & attlist1;
#line 950
    return (36);
  }
  {
#line 952
  tmp___1 = (*(enc->nameMatchesAscii))(enc, ptr + enc->minBytesPerChar, end, KW_FIXED);
  }
#line 952
  if (tmp___1) {
#line 956
    state->handler = & attlist9;
#line 957
    return (33);
  }
#line 959
  goto switch_break;
  case_27: /* CIL Label */ 
#line 961
  state->handler = & attlist1;
#line 962
  return (37);
  switch_break: /* CIL Label */ ;
  }
  {
#line 964
  tmp___2 = common(state, tok);
  }
#line 964
  return (tmp___2);
}
}
#line 967 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlrole.c"
static int attlist9(PROLOG_STATE *state , int tok , char const   *ptr , char const   *end ,
                    ENCODING const   *enc ) 
{ 
  int tmp ;

  {
  {
#line 975
  if (tok == 15) {
#line 975
    goto case_15;
  }
#line 977
  if (tok == 27) {
#line 977
    goto case_27;
  }
#line 974
  goto switch_break;
  case_15: /* CIL Label */ 
#line 976
  return (33);
  case_27: /* CIL Label */ 
#line 978
  state->handler = & attlist1;
#line 979
  return (38);
  switch_break: /* CIL Label */ ;
  }
  {
#line 981
  tmp = common(state, tok);
  }
#line 981
  return (tmp);
}
}
#line 984 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlrole.c"
static int element0(PROLOG_STATE *state , int tok , char const   *ptr , char const   *end ,
                    ENCODING const   *enc ) 
{ 
  int tmp ;

  {
  {
#line 992
  if (tok == 15) {
#line 992
    goto case_15;
  }
#line 995
  if (tok == 41) {
#line 995
    goto case_41;
  }
#line 995
  if (tok == 18) {
#line 995
    goto case_41;
  }
#line 991
  goto switch_break;
  case_15: /* CIL Label */ 
#line 993
  return (39);
  case_41: /* CIL Label */ 
  case_18: /* CIL Label */ 
#line 996
  state->handler = & element1;
#line 997
  return (40);
  switch_break: /* CIL Label */ ;
  }
  {
#line 999
  tmp = common(state, tok);
  }
#line 999
  return (tmp);
}
}
#line 1002 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlrole.c"
static int element1(PROLOG_STATE *state , int tok , char const   *ptr , char const   *end ,
                    ENCODING const   *enc ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 1010
  if (tok == 15) {
#line 1010
    goto case_15;
  }
#line 1012
  if (tok == 18) {
#line 1012
    goto case_18;
  }
#line 1024
  if (tok == 23) {
#line 1024
    goto case_23;
  }
#line 1009
  goto switch_break;
  case_15: /* CIL Label */ 
#line 1011
  return (39);
  case_18: /* CIL Label */ 
  {
#line 1013
  tmp = (*(enc->nameMatchesAscii))(enc, ptr, end, KW_EMPTY);
  }
#line 1013
  if (tmp) {
#line 1014
    state->handler = & declClose;
#line 1015
    state->role_none = 39;
#line 1016
    return (42);
  }
  {
#line 1018
  tmp___0 = (*(enc->nameMatchesAscii))(enc, ptr, end, KW_ANY);
  }
#line 1018
  if (tmp___0) {
#line 1019
    state->handler = & declClose;
#line 1020
    state->role_none = 39;
#line 1021
    return (41);
  }
#line 1023
  goto switch_break;
  case_23: /* CIL Label */ 
#line 1025
  state->handler = & element2;
#line 1026
  state->level = 1U;
#line 1027
  return (44);
  switch_break: /* CIL Label */ ;
  }
  {
#line 1029
  tmp___1 = common(state, tok);
  }
#line 1029
  return (tmp___1);
}
}
#line 1032 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlrole.c"
static int element2(PROLOG_STATE *state , int tok , char const   *ptr , char const   *end ,
                    ENCODING const   *enc ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  {
#line 1040
  if (tok == 15) {
#line 1040
    goto case_15;
  }
#line 1042
  if (tok == 20) {
#line 1042
    goto case_20;
  }
#line 1051
  if (tok == 23) {
#line 1051
    goto case_23;
  }
#line 1056
  if (tok == 41) {
#line 1056
    goto case_41;
  }
#line 1056
  if (tok == 18) {
#line 1056
    goto case_41;
  }
#line 1059
  if (tok == 30) {
#line 1059
    goto case_30;
  }
#line 1062
  if (tok == 31) {
#line 1062
    goto case_31;
  }
#line 1065
  if (tok == 32) {
#line 1065
    goto case_32;
  }
#line 1039
  goto switch_break;
  case_15: /* CIL Label */ 
#line 1041
  return (39);
  case_20: /* CIL Label */ 
  {
#line 1043
  tmp = (*(enc->nameMatchesAscii))(enc, ptr + enc->minBytesPerChar, end, KW_PCDATA);
  }
#line 1043
  if (tmp) {
#line 1047
    state->handler = & element3;
#line 1048
    return (43);
  }
#line 1050
  goto switch_break;
  case_23: /* CIL Label */ 
#line 1052
  state->level = 2U;
#line 1053
  state->handler = & element6;
#line 1054
  return (44);
  case_41: /* CIL Label */ 
  case_18: /* CIL Label */ 
#line 1057
  state->handler = & element7;
#line 1058
  return (51);
  case_30: /* CIL Label */ 
#line 1060
  state->handler = & element7;
#line 1061
  return (53);
  case_31: /* CIL Label */ 
#line 1063
  state->handler = & element7;
#line 1064
  return (52);
  case_32: /* CIL Label */ 
#line 1066
  state->handler = & element7;
#line 1067
  return (54);
  switch_break: /* CIL Label */ ;
  }
  {
#line 1069
  tmp___0 = common(state, tok);
  }
#line 1069
  return (tmp___0);
}
}
#line 1072 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlrole.c"
static int element3(PROLOG_STATE *state , int tok , char const   *ptr , char const   *end ,
                    ENCODING const   *enc ) 
{ 
  int tmp ;

  {
  {
#line 1080
  if (tok == 15) {
#line 1080
    goto case_15;
  }
#line 1082
  if (tok == 24) {
#line 1082
    goto case_24;
  }
#line 1086
  if (tok == 36) {
#line 1086
    goto case_36;
  }
#line 1090
  if (tok == 21) {
#line 1090
    goto case_21;
  }
#line 1079
  goto switch_break;
  case_15: /* CIL Label */ 
#line 1081
  return (39);
  case_24: /* CIL Label */ 
#line 1083
  state->handler = & declClose;
#line 1084
  state->role_none = 39;
#line 1085
  return (45);
  case_36: /* CIL Label */ 
#line 1087
  state->handler = & declClose;
#line 1088
  state->role_none = 39;
#line 1089
  return (46);
  case_21: /* CIL Label */ 
#line 1091
  state->handler = & element4;
#line 1092
  return (39);
  switch_break: /* CIL Label */ ;
  }
  {
#line 1094
  tmp = common(state, tok);
  }
#line 1094
  return (tmp);
}
}
#line 1097 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlrole.c"
static int element4(PROLOG_STATE *state , int tok , char const   *ptr , char const   *end ,
                    ENCODING const   *enc ) 
{ 
  int tmp ;

  {
  {
#line 1105
  if (tok == 15) {
#line 1105
    goto case_15;
  }
#line 1108
  if (tok == 41) {
#line 1108
    goto case_41;
  }
#line 1108
  if (tok == 18) {
#line 1108
    goto case_41;
  }
#line 1104
  goto switch_break;
  case_15: /* CIL Label */ 
#line 1106
  return (39);
  case_41: /* CIL Label */ 
  case_18: /* CIL Label */ 
#line 1109
  state->handler = & element5;
#line 1110
  return (51);
  switch_break: /* CIL Label */ ;
  }
  {
#line 1112
  tmp = common(state, tok);
  }
#line 1112
  return (tmp);
}
}
#line 1115 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlrole.c"
static int element5(PROLOG_STATE *state , int tok , char const   *ptr , char const   *end ,
                    ENCODING const   *enc ) 
{ 
  int tmp ;

  {
  {
#line 1123
  if (tok == 15) {
#line 1123
    goto case_15;
  }
#line 1125
  if (tok == 36) {
#line 1125
    goto case_36;
  }
#line 1129
  if (tok == 21) {
#line 1129
    goto case_21;
  }
#line 1122
  goto switch_break;
  case_15: /* CIL Label */ 
#line 1124
  return (39);
  case_36: /* CIL Label */ 
#line 1126
  state->handler = & declClose;
#line 1127
  state->role_none = 39;
#line 1128
  return (46);
  case_21: /* CIL Label */ 
#line 1130
  state->handler = & element4;
#line 1131
  return (39);
  switch_break: /* CIL Label */ ;
  }
  {
#line 1133
  tmp = common(state, tok);
  }
#line 1133
  return (tmp);
}
}
#line 1136 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlrole.c"
static int element6(PROLOG_STATE *state , int tok , char const   *ptr , char const   *end ,
                    ENCODING const   *enc ) 
{ 
  int tmp ;

  {
  {
#line 1144
  if (tok == 15) {
#line 1144
    goto case_15;
  }
#line 1146
  if (tok == 23) {
#line 1146
    goto case_23;
  }
#line 1150
  if (tok == 41) {
#line 1150
    goto case_41;
  }
#line 1150
  if (tok == 18) {
#line 1150
    goto case_41;
  }
#line 1153
  if (tok == 30) {
#line 1153
    goto case_30;
  }
#line 1156
  if (tok == 31) {
#line 1156
    goto case_31;
  }
#line 1159
  if (tok == 32) {
#line 1159
    goto case_32;
  }
#line 1143
  goto switch_break;
  case_15: /* CIL Label */ 
#line 1145
  return (39);
  case_23: /* CIL Label */ 
#line 1147
  (state->level) ++;
#line 1148
  return (44);
  case_41: /* CIL Label */ 
  case_18: /* CIL Label */ 
#line 1151
  state->handler = & element7;
#line 1152
  return (51);
  case_30: /* CIL Label */ 
#line 1154
  state->handler = & element7;
#line 1155
  return (53);
  case_31: /* CIL Label */ 
#line 1157
  state->handler = & element7;
#line 1158
  return (52);
  case_32: /* CIL Label */ 
#line 1160
  state->handler = & element7;
#line 1161
  return (54);
  switch_break: /* CIL Label */ ;
  }
  {
#line 1163
  tmp = common(state, tok);
  }
#line 1163
  return (tmp);
}
}
#line 1166 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlrole.c"
static int element7(PROLOG_STATE *state , int tok , char const   *ptr , char const   *end ,
                    ENCODING const   *enc ) 
{ 
  int tmp ;

  {
  {
#line 1174
  if (tok == 15) {
#line 1174
    goto case_15;
  }
#line 1176
  if (tok == 24) {
#line 1176
    goto case_24;
  }
#line 1183
  if (tok == 36) {
#line 1183
    goto case_36;
  }
#line 1190
  if (tok == 35) {
#line 1190
    goto case_35;
  }
#line 1197
  if (tok == 37) {
#line 1197
    goto case_37;
  }
#line 1204
  if (tok == 38) {
#line 1204
    goto case_38;
  }
#line 1207
  if (tok == 21) {
#line 1207
    goto case_21;
  }
#line 1173
  goto switch_break;
  case_15: /* CIL Label */ 
#line 1175
  return (39);
  case_24: /* CIL Label */ 
#line 1177
  (state->level) --;
#line 1178
  if (state->level == 0U) {
#line 1179
    state->handler = & declClose;
#line 1180
    state->role_none = 39;
  }
#line 1182
  return (45);
  case_36: /* CIL Label */ 
#line 1184
  (state->level) --;
#line 1185
  if (state->level == 0U) {
#line 1186
    state->handler = & declClose;
#line 1187
    state->role_none = 39;
  }
#line 1189
  return (46);
  case_35: /* CIL Label */ 
#line 1191
  (state->level) --;
#line 1192
  if (state->level == 0U) {
#line 1193
    state->handler = & declClose;
#line 1194
    state->role_none = 39;
  }
#line 1196
  return (47);
  case_37: /* CIL Label */ 
#line 1198
  (state->level) --;
#line 1199
  if (state->level == 0U) {
#line 1200
    state->handler = & declClose;
#line 1201
    state->role_none = 39;
  }
#line 1203
  return (48);
  case_38: /* CIL Label */ 
#line 1205
  state->handler = & element6;
#line 1206
  return (50);
  case_21: /* CIL Label */ 
#line 1208
  state->handler = & element6;
#line 1209
  return (49);
  switch_break: /* CIL Label */ ;
  }
  {
#line 1211
  tmp = common(state, tok);
  }
#line 1211
  return (tmp);
}
}
#line 1216 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlrole.c"
static int condSect0(PROLOG_STATE *state , int tok , char const   *ptr , char const   *end ,
                     ENCODING const   *enc ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 1224
  if (tok == 15) {
#line 1224
    goto case_15;
  }
#line 1226
  if (tok == 18) {
#line 1226
    goto case_18;
  }
#line 1223
  goto switch_break;
  case_15: /* CIL Label */ 
#line 1225
  return (0);
  case_18: /* CIL Label */ 
  {
#line 1227
  tmp = (*(enc->nameMatchesAscii))(enc, ptr, end, KW_INCLUDE);
  }
#line 1227
  if (tmp) {
#line 1228
    state->handler = & condSect1;
#line 1229
    return (0);
  }
  {
#line 1231
  tmp___0 = (*(enc->nameMatchesAscii))(enc, ptr, end, KW_IGNORE);
  }
#line 1231
  if (tmp___0) {
#line 1232
    state->handler = & condSect2;
#line 1233
    return (0);
  }
#line 1235
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 1237
  tmp___1 = common(state, tok);
  }
#line 1237
  return (tmp___1);
}
}
#line 1240 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlrole.c"
static int condSect1(PROLOG_STATE *state , int tok , char const   *ptr , char const   *end ,
                     ENCODING const   *enc ) 
{ 
  int tmp ;

  {
  {
#line 1248
  if (tok == 15) {
#line 1248
    goto case_15;
  }
#line 1250
  if (tok == 25) {
#line 1250
    goto case_25;
  }
#line 1247
  goto switch_break;
  case_15: /* CIL Label */ 
#line 1249
  return (0);
  case_25: /* CIL Label */ 
#line 1251
  state->handler = & externalSubset1;
#line 1252
  (state->includeLevel) ++;
#line 1253
  return (0);
  switch_break: /* CIL Label */ ;
  }
  {
#line 1255
  tmp = common(state, tok);
  }
#line 1255
  return (tmp);
}
}
#line 1258 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlrole.c"
static int condSect2(PROLOG_STATE *state , int tok , char const   *ptr , char const   *end ,
                     ENCODING const   *enc ) 
{ 
  int tmp ;

  {
  {
#line 1266
  if (tok == 15) {
#line 1266
    goto case_15;
  }
#line 1268
  if (tok == 25) {
#line 1268
    goto case_25;
  }
#line 1265
  goto switch_break;
  case_15: /* CIL Label */ 
#line 1267
  return (0);
  case_25: /* CIL Label */ 
#line 1269
  state->handler = & externalSubset1;
#line 1270
  return (58);
  switch_break: /* CIL Label */ ;
  }
  {
#line 1272
  tmp = common(state, tok);
  }
#line 1272
  return (tmp);
}
}
#line 1277 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlrole.c"
static int declClose(PROLOG_STATE *state , int tok , char const   *ptr , char const   *end ,
                     ENCODING const   *enc ) 
{ 
  int tmp ;

  {
  {
#line 1285
  if (tok == 15) {
#line 1285
    goto case_15;
  }
#line 1287
  if (tok == 17) {
#line 1287
    goto case_17;
  }
#line 1284
  goto switch_break;
  case_15: /* CIL Label */ 
#line 1286
  return (state->role_none);
  case_17: /* CIL Label */ 
#line 1288
  if (state->documentEntity) {
#line 1288
    state->handler = & internalSubset;
  } else {
#line 1288
    state->handler = & externalSubset1;
  }
#line 1289
  return (state->role_none);
  switch_break: /* CIL Label */ ;
  }
  {
#line 1291
  tmp = common(state, tok);
  }
#line 1291
  return (tmp);
}
}
#line 1294 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlrole.c"
static int error(PROLOG_STATE *state , int tok , char const   *ptr , char const   *end ,
                 ENCODING const   *enc ) 
{ 


  {
#line 1301
  return (0);
}
}
#line 1304 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlrole.c"
static int common(PROLOG_STATE *state , int tok ) 
{ 


  {
#line 1308
  if (! state->documentEntity) {
#line 1308
    if (tok == 28) {
#line 1309
      return (59);
    }
  }
#line 1311
  state->handler = & error;
#line 1312
  return (-1);
}
}
#line 1315 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlrole.c"
void XmlPrologStateInit(PROLOG_STATE *state ) 
{ 


  {
#line 1318
  state->handler = & prolog0;
#line 1320
  state->documentEntity = 1;
#line 1321
  state->includeLevel = 0U;
#line 1322
  state->inEntityValue = 0;
#line 1324
  return;
}
}
#line 1328 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlrole.c"
void XmlPrologStateInitExternalEntity(PROLOG_STATE *state ) 
{ 


  {
#line 1331
  state->handler = & externalSubset0;
#line 1332
  state->documentEntity = 0;
#line 1333
  state->includeLevel = 0U;
#line 1334
  return;
}
}
#line 146 "/usr/include/fcntl.h"
extern int ( __attribute__((__nonnull__(1))) open)(char const   *__file , int __oflag 
                                                   , ...) ;
#line 13 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/xmlwf/filemap.h"
int filemap(char const   *name , void (*processor)(void const   * , size_t  , char const   * ,
                                                   void *arg ) , void *arg ) ;
#line 353 "/usr/include/unistd.h"
extern int close(int __fd ) ;
#line 360
extern ssize_t read(int __fd , void *__buf , size_t __nbytes ) ;
#line 60 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/xmlwf/xmlfile.c"
static void reportError(XML_Parser parser , XML_Char const   *filename ) 
{ 
  enum XML_Error code ;
  enum XML_Error tmp ;
  XML_Char const   *message___1 ;
  XML_LChar const   *tmp___0 ;
  XML_Size tmp___1 ;
  XML_Size tmp___2 ;

  {
  {
#line 63
  tmp = XML_GetErrorCode(parser);
#line 63
  code = tmp;
#line 64
  tmp___0 = XML_ErrorString(code);
#line 64
  message___1 = tmp___0;
  }
#line 65
  if (message___1) {
    {
#line 66
    tmp___1 = XML_GetCurrentColumnNumber(parser);
#line 66
    tmp___2 = XML_GetCurrentLineNumber(parser);
#line 66
    fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"%s:%lu:%lu: %s\n",
            filename, tmp___2, tmp___1, message___1);
    }
  } else {
    {
#line 72
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: (unknown message %d)\n",
            filename, (unsigned int )code);
    }
  }
#line 73
  return;
}
}
#line 76 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/xmlwf/xmlfile.c"
static void processFile(void const   *data , size_t size , XML_Char const   *filename ,
                        void *args ) 
{ 
  XML_Parser parser ;
  int *retPtr ;
  enum XML_Status tmp ;

  {
  {
#line 80
  parser = ((PROCESS_ARGS *)args)->parser;
#line 81
  retPtr = ((PROCESS_ARGS *)args)->retPtr;
#line 82
  tmp = XML_Parse(parser, (char const   *)data, (int )size, 1);
  }
#line 82
  if ((unsigned int )tmp == 0U) {
    {
#line 83
    reportError(parser, filename);
#line 84
    *retPtr = 0;
    }
  } else {
#line 87
    *retPtr = 1;
  }
#line 88
  return;
}
}
#line 100 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/xmlwf/xmlfile.c"
static XML_Char const   *resolveSystemId(XML_Char const   *base , XML_Char const   *systemId ,
                                         XML_Char **toFree ) 
{ 
  XML_Char *s ;
  size_t tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;

  {
#line 105
  *toFree = (XML_Char *)0;
#line 106
  if (! base) {
#line 113
    return (systemId);
  } else
#line 106
  if ((int const   )*systemId == 47) {
#line 113
    return (systemId);
  }
  {
#line 114
  tmp = strlen(base);
#line 114
  tmp___0 = strlen(systemId);
#line 114
  tmp___1 = malloc(((tmp + tmp___0) + 2UL) * sizeof(XML_Char ));
#line 114
  *toFree = (XML_Char *)tmp___1;
  }
#line 116
  if (! *toFree) {
#line 117
    return (systemId);
  }
  {
#line 118
  strcpy((char */* __restrict  */)*toFree, (char const   */* __restrict  */)base);
#line 119
  s = *toFree;
#line 120
  tmp___3 = strrchr((char const   *)s, '/');
  }
#line 120
  if (tmp___3) {
    {
#line 121
    tmp___2 = strrchr((char const   *)s, '/');
#line 121
    s = tmp___2 + 1;
    }
  }
  {
#line 126
  strcpy((char */* __restrict  */)s, (char const   */* __restrict  */)systemId);
  }
#line 127
  return ((XML_Char const   *)*toFree);
}
}
#line 130 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/xmlwf/xmlfile.c"
static int externalEntityRefFilemap(XML_Parser parser , XML_Char const   *context ,
                                    XML_Char const   *base , XML_Char const   *systemId ,
                                    XML_Char const   *publicId ) 
{ 
  int result ;
  XML_Char *s ;
  XML_Char const   *filename ;
  XML_Parser entParser ;
  XML_Parser tmp ;
  PROCESS_ARGS args ;
  int tmp___0 ;

  {
  {
#line 140
  tmp = XML_ExternalEntityParserCreate(parser, context, (XML_Char const   *)0);
#line 140
  entParser = tmp;
#line 142
  args.retPtr = & result;
#line 143
  args.parser = entParser;
#line 144
  filename = resolveSystemId(base, systemId, & s);
#line 145
  XML_SetBase(entParser, filename);
#line 146
  tmp___0 = filemap(filename, & processFile, (void *)(& args));
  }
#line 146
  if (! tmp___0) {
#line 147
    result = 0;
  }
  {
#line 148
  free((void *)s);
#line 149
  XML_ParserFree(entParser);
  }
#line 150
  return (result);
}
}
#line 153 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/xmlwf/xmlfile.c"
static int processStream(XML_Char const   *filename , XML_Parser parser ) 
{ 
  int fd ;
  int nread ;
  char *buf ;
  void *tmp ;
  XML_Char const   *tmp___0 ;
  ssize_t tmp___1 ;
  XML_Char const   *tmp___2 ;
  XML_Char const   *tmp___3 ;
  enum XML_Status tmp___4 ;

  {
#line 157
  fd = 0;
#line 159
  if ((unsigned long )filename != (unsigned long )((void *)0)) {
    {
#line 160
    fd = open(filename, 0);
    }
#line 161
    if (fd < 0) {
      {
#line 162
      perror(filename);
      }
#line 163
      return (0);
    }
  }
  {
#line 166
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 168
    tmp = XML_GetBuffer(parser, 8192);
#line 168
    buf = (char *)tmp;
    }
#line 169
    if (! buf) {
#line 170
      if ((unsigned long )filename != (unsigned long )((void *)0)) {
        {
#line 171
        close(fd);
        }
      }
#line 172
      if ((unsigned long )filename != (unsigned long )((void *)0)) {
#line 172
        tmp___0 = filename;
      } else {
#line 172
        tmp___0 = "xmlwf";
      }
      {
#line 172
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: out of memory\n",
              tmp___0);
      }
#line 174
      return (0);
    }
    {
#line 176
    tmp___1 = read(fd, (void *)buf, (size_t )8192);
#line 176
    nread = (int )tmp___1;
    }
#line 177
    if (nread < 0) {
#line 178
      if ((unsigned long )filename != (unsigned long )((void *)0)) {
#line 178
        tmp___2 = filename;
      } else {
#line 178
        tmp___2 = "STDIN";
      }
      {
#line 178
      perror(tmp___2);
      }
#line 179
      if ((unsigned long )filename != (unsigned long )((void *)0)) {
        {
#line 180
        close(fd);
        }
      }
#line 181
      return (0);
    }
    {
#line 183
    tmp___4 = XML_ParseBuffer(parser, nread, nread == 0);
    }
#line 183
    if ((unsigned int )tmp___4 == 0U) {
#line 184
      if ((unsigned long )filename != (unsigned long )((void *)0)) {
#line 184
        tmp___3 = filename;
      } else {
#line 184
        tmp___3 = "STDIN";
      }
      {
#line 184
      reportError(parser, tmp___3);
      }
#line 185
      if ((unsigned long )filename != (unsigned long )((void *)0)) {
        {
#line 186
        close(fd);
        }
      }
#line 187
      return (0);
    }
#line 189
    if (nread == 0) {
#line 190
      if ((unsigned long )filename != (unsigned long )((void *)0)) {
        {
#line 191
        close(fd);
        }
      }
#line 192
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 195
  return (1);
}
}
#line 198 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/xmlwf/xmlfile.c"
static int externalEntityRefStream(XML_Parser parser , XML_Char const   *context ,
                                   XML_Char const   *base , XML_Char const   *systemId ,
                                   XML_Char const   *publicId ) 
{ 
  XML_Char *s ;
  XML_Char const   *filename ;
  int ret ;
  XML_Parser entParser ;
  XML_Parser tmp ;

  {
  {
#line 208
  tmp = XML_ExternalEntityParserCreate(parser, context, (XML_Char const   *)0);
#line 208
  entParser = tmp;
#line 209
  filename = resolveSystemId(base, systemId, & s);
#line 210
  XML_SetBase(entParser, filename);
#line 211
  ret = processStream(filename, entParser);
#line 212
  free((void *)s);
#line 213
  XML_ParserFree(entParser);
  }
#line 214
  return (ret);
}
}
#line 217 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/xmlwf/xmlfile.c"
int XML_ProcessFile(XML_Parser parser , XML_Char const   *filename , unsigned int flags ) 
{ 
  int result ;
  enum XML_Status tmp ;
  int (*tmp___0)(XML_Parser parser , XML_Char const   *context , XML_Char const   *base ,
                 XML_Char const   *systemId , XML_Char const   *publicId ) ;
  PROCESS_ARGS args ;
  int tmp___1 ;

  {
  {
#line 224
  tmp = XML_SetBase(parser, filename);
  }
#line 224
  if (! tmp) {
    {
#line 225
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: out of memory",
            filename);
#line 226
    exit(1);
    }
  }
#line 229
  if (flags & 2U) {
#line 230
    if (flags & 1U) {
#line 230
      tmp___0 = & externalEntityRefFilemap;
    } else {
#line 230
      tmp___0 = & externalEntityRefStream;
    }
    {
#line 230
    XML_SetExternalEntityRefHandler(parser, tmp___0);
    }
  }
#line 234
  if (flags & 1U) {
    {
#line 236
    args.retPtr = & result;
#line 237
    args.parser = parser;
#line 238
    tmp___1 = filemap(filename, & processFile, (void *)(& args));
    }
#line 238
    if (! tmp___1) {
#line 239
      result = 0;
    }
  } else {
    {
#line 242
    result = processStream(filename, parser);
    }
  }
#line 243
  return (result);
}
}
#line 56 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/xmlwf/codepage.c"
int codepageMap(int cp , int *map ) 
{ 


  {
#line 59
  return (0);
}
}
#line 62 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/xmlwf/codepage.c"
int codepageConvert(int cp , char const   *p ) 
{ 


  {
#line 65
  return (-1);
}
}
#line 57 "/usr/include/x86_64-linux-gnu/sys/mman.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) mmap)(void *__addr ,
                                                                             size_t __len ,
                                                                             int __prot ,
                                                                             int __flags ,
                                                                             int __fd ,
                                                                             __off_t __offset ) ;
#line 76
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) munmap)(void *__addr ,
                                                                             size_t __len ) ;
#line 214 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2), __leaf__)) fstat)(int __fd ,
                                                                                            struct stat *__buf ) ;
#line 49 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/xmlwf/unixfilemap.c"
static char const   c  =    (char const   )'\000';
#line 20 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/xmlwf/unixfilemap.c"
int filemap(char const   *name , void (*processor)(void const   * , size_t  , char const   * ,
                                                   void *arg ) , void *arg ) 
{ 
  int fd ;
  size_t nbytes ;
  struct stat sb ;
  void *p ;
  int tmp ;
  void *tmp___0 ;

  {
  {
#line 30
  fd = open(name, 0);
  }
#line 31
  if (fd < 0) {
    {
#line 32
    perror(name);
    }
#line 33
    return (0);
  }
  {
#line 35
  tmp = fstat(fd, & sb);
  }
#line 35
  if (tmp < 0) {
    {
#line 36
    perror(name);
#line 37
    close(fd);
    }
#line 38
    return (0);
  }
#line 40
  if (! ((sb.st_mode & 61440U) == 32768U)) {
    {
#line 41
    close(fd);
#line 42
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: not a regular file\n",
            name);
    }
#line 43
    return (0);
  }
#line 46
  nbytes = (size_t )sb.st_size;
#line 48
  if (nbytes == 0UL) {
    {
#line 50
    (*processor)((void const   *)(& c), (size_t )0, name, arg);
#line 51
    close(fd);
    }
#line 52
    return (1);
  }
  {
#line 54
  tmp___0 = mmap((void *)((caddr_t )0), nbytes, 1, 2, fd, (off_t )0);
#line 54
  p = tmp___0;
  }
#line 56
  if ((unsigned long )p == (unsigned long )((void *)-1)) {
    {
#line 57
    perror(name);
#line 58
    close(fd);
    }
#line 59
    return (0);
  }
  {
#line 61
  (*processor)((void const   *)p, nbytes, name, arg);
#line 62
  munmap((void *)((caddr_t )p), nbytes);
#line 63
  close(fd);
  }
#line 64
  return (1);
}
}
#line 305 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlparse.c"
static enum XML_Error prologProcessor___0(XML_Parser parser , char const   *s , char const   *end ,
                                          char const   **nextPtr ) ;
#line 306
static enum XML_Error prologInitProcessor___0(XML_Parser parser , char const   *s ,
                                              char const   *end , char const   **nextPtr ) ;
#line 307
static enum XML_Error contentProcessor___0(XML_Parser parser , char const   *start ,
                                           char const   *end , char const   **endPtr ) ;
#line 308
static enum XML_Error cdataSectionProcessor___0(XML_Parser parser , char const   *start ,
                                                char const   *end , char const   **endPtr ) ;
#line 310
static enum XML_Error ignoreSectionProcessor___0(XML_Parser parser , char const   *start ,
                                                 char const   *end , char const   **endPtr ) ;
#line 311
static enum XML_Error externalParEntProcessor___0(XML_Parser parser , char const   *s ,
                                                  char const   *end , char const   **nextPtr ) ;
#line 312
static enum XML_Error externalParEntInitProcessor___0(XML_Parser parser , char const   *s ,
                                                      char const   *end , char const   **nextPtr ) ;
#line 313
static enum XML_Error entityValueProcessor___0(XML_Parser parser , char const   *s ,
                                               char const   *end , char const   **nextPtr ) ;
#line 314
static enum XML_Error entityValueInitProcessor___0(XML_Parser parser , char const   *s ,
                                                   char const   *end , char const   **nextPtr ) ;
#line 316
static enum XML_Error epilogProcessor___0(XML_Parser parser , char const   *s , char const   *end ,
                                          char const   **nextPtr ) ;
#line 317
static enum XML_Error errorProcessor___0(XML_Parser parser , char const   *s , char const   *end ,
                                         char const   **nextPtr ) ;
#line 318
static enum XML_Error externalEntityInitProcessor___0(XML_Parser parser , char const   *start ,
                                                      char const   *end , char const   **endPtr ) ;
#line 319
static enum XML_Error externalEntityInitProcessor2___0(XML_Parser parser , char const   *start ,
                                                       char const   *end , char const   **endPtr ) ;
#line 320
static enum XML_Error externalEntityInitProcessor3___0(XML_Parser parser , char const   *start ,
                                                       char const   *end , char const   **endPtr ) ;
#line 321
static enum XML_Error externalEntityContentProcessor___0(XML_Parser parser , char const   *start ,
                                                         char const   *end , char const   **endPtr ) ;
#line 322
static enum XML_Error internalEntityProcessor___0(XML_Parser parser , char const   *s ,
                                                  char const   *end , char const   **nextPtr ) ;
#line 324
static enum XML_Error handleUnknownEncoding___0(XML_Parser parser , XML_Char const   *encodingName ) ;
#line 326
static enum XML_Error processXmlDecl___0(XML_Parser parser , int isGeneralTextEntity ,
                                         char const   *s , char const   *next ) ;
#line 329
static enum XML_Error initializeEncoding___0(XML_Parser parser ) ;
#line 331
static enum XML_Error doProlog___0(XML_Parser parser , ENCODING const   *enc , char const   *s ,
                                   char const   *end , int tok , char const   *next ,
                                   char const   **nextPtr , XML_Bool haveMore ) ;
#line 335
static enum XML_Error processInternalEntity___0(XML_Parser parser , ENTITY *entity ,
                                                XML_Bool betweenDecl ) ;
#line 338
static enum XML_Error doContent___0(XML_Parser parser , int startTagLevel , ENCODING const   *enc ,
                                    char const   *s , char const   *end , char const   **nextPtr ,
                                    XML_Bool haveMore ) ;
#line 342
static enum XML_Error doCdataSection___0(XML_Parser parser , ENCODING const   *enc ,
                                         char const   **startPtr , char const   *end ,
                                         char const   **nextPtr , XML_Bool haveMore ) ;
#line 346
static enum XML_Error doIgnoreSection___0(XML_Parser parser , ENCODING const   *enc ,
                                          char const   **startPtr , char const   *end ,
                                          char const   **nextPtr , XML_Bool haveMore ) ;
#line 351
static enum XML_Error storeAtts___0(XML_Parser parser , ENCODING const   *enc , char const   *attStr ,
                                    TAG_NAME *tagNamePtr , BINDING **bindingsPtr ) ;
#line 354
static enum XML_Error addBinding___0(XML_Parser parser , PREFIX *prefix , ATTRIBUTE_ID const   *attId ,
                                     XML_Char const   *uri , BINDING **bindingsPtr ) ;
#line 357
static int defineAttribute___0(ELEMENT_TYPE *type , ATTRIBUTE_ID *attId , XML_Bool isCdata ,
                               XML_Bool isId , XML_Char const   *value , XML_Parser parser ) ;
#line 360
static enum XML_Error storeAttributeValue___0(XML_Parser parser , ENCODING const   *enc ,
                                              XML_Bool isCdata , char const   *ptr ,
                                              char const   *end , STRING_POOL *pool ) ;
#line 363
static enum XML_Error appendAttributeValue___0(XML_Parser parser , ENCODING const   *enc ,
                                               XML_Bool isCdata , char const   *ptr ,
                                               char const   *end , STRING_POOL *pool ) ;
#line 366
static ATTRIBUTE_ID *getAttributeId___0(XML_Parser parser , ENCODING const   *enc ,
                                        char const   *start , char const   *end ) ;
#line 369
static int setElementTypePrefix___0(XML_Parser parser , ELEMENT_TYPE *elementType ) ;
#line 371
static enum XML_Error storeEntityValue___0(XML_Parser parser , ENCODING const   *enc ,
                                           char const   *entityTextPtr , char const   *entityTextEnd ) ;
#line 374
static int reportProcessingInstruction___0(XML_Parser parser , ENCODING const   *enc ,
                                           char const   *start , char const   *end ) ;
#line 377
static int reportComment___0(XML_Parser parser , ENCODING const   *enc , char const   *start ,
                             char const   *end ) ;
#line 380
static void reportDefault___0(XML_Parser parser , ENCODING const   *enc , char const   *s ,
                              char const   *end ) ;
#line 384
static XML_Char const   *getContext___0(XML_Parser parser ) ;
#line 385
static XML_Bool setContext___0(XML_Parser parser , XML_Char const   *context ) ;
#line 388
static void normalizePublicId___0(XML_Char *publicId ) ;
#line 390
static DTD *dtdCreate___0(XML_Memory_Handling_Suite const   *ms ) ;
#line 392
static void dtdReset___0(DTD *p , XML_Memory_Handling_Suite const   *ms ) ;
#line 393
static void dtdDestroy___0(DTD *p , XML_Bool isDocEntity , XML_Memory_Handling_Suite const   *ms ) ;
#line 395
static int dtdCopy___0(XML_Parser oldParser , DTD *newDtd , DTD const   *oldDtd ,
                       XML_Memory_Handling_Suite const   *ms ) ;
#line 398
static int copyEntityTable___0(XML_Parser oldParser , HASH_TABLE *newTable , STRING_POOL *newPool ,
                               HASH_TABLE const   *oldTable ) ;
#line 401
static NAMED *lookup___0(XML_Parser parser , HASH_TABLE *table , KEY name , size_t createSize ) ;
#line 403
static void hashTableInit___0(HASH_TABLE *p , XML_Memory_Handling_Suite const   *ms ) ;
#line 405
static void hashTableClear___0(HASH_TABLE *table ) ;
#line 406
static void hashTableDestroy___0(HASH_TABLE *table ) ;
#line 407
static void hashTableIterInit___0(HASH_TABLE_ITER *iter , HASH_TABLE const   *table ) ;
#line 409
static NAMED *hashTableIterNext___0(HASH_TABLE_ITER *iter ) ;
#line 411
static void poolInit___0(STRING_POOL *pool , XML_Memory_Handling_Suite const   *ms ) ;
#line 413
static void poolClear___0(STRING_POOL *pool ) ;
#line 414
static void poolDestroy___0(STRING_POOL *pool ) ;
#line 415
static XML_Char *poolAppend___0(STRING_POOL *pool , ENCODING const   *enc , char const   *ptr ,
                                char const   *end ) ;
#line 418
static XML_Char *poolStoreString___0(STRING_POOL *pool , ENCODING const   *enc , char const   *ptr ,
                                     char const   *end ) ;
#line 421
static XML_Bool poolGrow___0(STRING_POOL *pool ) ;
#line 422
static XML_Char const   *poolCopyString___0(STRING_POOL *pool , XML_Char const   *s ) ;
#line 424
static XML_Char const   *poolCopyStringN___0(STRING_POOL *pool , XML_Char const   *s ,
                                             int n ) ;
#line 426
static XML_Char const   *poolAppendString___0(STRING_POOL *pool , XML_Char const   *s ) ;
#line 429
static int nextScaffoldPart___0(XML_Parser parser ) ;
#line 430
static XML_Content *build_model___0(XML_Parser parser ) ;
#line 431
static ELEMENT_TYPE *getElementType___0(XML_Parser parser , ENCODING const   *enc ,
                                        char const   *ptr , char const   *end ) ;
#line 435
static unsigned long generate_hash_secret_salt___0(void) ;
#line 436
static XML_Bool startParsing___0(XML_Parser parser ) ;
#line 438
static XML_Parser parserCreate___0(XML_Char const   *encodingName , XML_Memory_Handling_Suite const   *memsuite ,
                                   XML_Char const   *nameSep , DTD *dtd ) ;
#line 444
static void parserInit___0(XML_Parser parser , XML_Char const   *encodingName ) ;
#line 684 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlparse.c"
static XML_Char const   implicitContext___0[41]  = 
#line 684
  {      (XML_Char const   )120,      (XML_Char const   )109,      (XML_Char const   )108,      (XML_Char const   )61, 
        (XML_Char const   )104,      (XML_Char const   )116,      (XML_Char const   )116,      (XML_Char const   )112, 
        (XML_Char const   )58,      (XML_Char const   )47,      (XML_Char const   )47,      (XML_Char const   )119, 
        (XML_Char const   )119,      (XML_Char const   )119,      (XML_Char const   )46,      (XML_Char const   )119, 
        (XML_Char const   )51,      (XML_Char const   )46,      (XML_Char const   )111,      (XML_Char const   )114, 
        (XML_Char const   )103,      (XML_Char const   )47,      (XML_Char const   )88,      (XML_Char const   )77, 
        (XML_Char const   )76,      (XML_Char const   )47,      (XML_Char const   )49,      (XML_Char const   )57, 
        (XML_Char const   )57,      (XML_Char const   )56,      (XML_Char const   )47,      (XML_Char const   )110, 
        (XML_Char const   )97,      (XML_Char const   )109,      (XML_Char const   )101,      (XML_Char const   )115, 
        (XML_Char const   )112,      (XML_Char const   )97,      (XML_Char const   )99,      (XML_Char const   )101, 
        (XML_Char const   )'\000'};
#line 693 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlparse.c"
static unsigned long generate_hash_secret_salt___0(void) 
{ 
  unsigned int seed ;
  time_t tmp ;
  int tmp___0 ;

  {
  {
#line 696
  tmp = time((time_t *)((void *)0));
#line 696
  seed = (unsigned int )(tmp % 4294967295L);
#line 697
  srand(seed);
#line 698
  tmp___0 = rand();
  }
#line 698
  return ((unsigned long )tmp___0);
}
}
#line 701 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlparse.c"
static XML_Bool startParsing___0(XML_Parser parser ) 
{ 
  XML_Bool tmp ;

  {
#line 705
  if (parser->m_hash_secret_salt == 0UL) {
    {
#line 706
    parser->m_hash_secret_salt = generate_hash_secret_salt___0();
    }
  }
#line 707
  if (parser->m_ns) {
    {
#line 711
    tmp = setContext___0(parser, implicitContext___0);
    }
#line 711
    return (tmp);
  }
#line 713
  return ((XML_Bool )1);
}
}
#line 724 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlparse.c"
static XML_Parser parserCreate___0(XML_Char const   *encodingName , XML_Memory_Handling_Suite const   *memsuite ,
                                   XML_Char const   *nameSep , DTD *dtd ) 
{ 
  XML_Parser parser ;
  XML_Memory_Handling_Suite *mtemp ;
  void *tmp ;
  XML_Memory_Handling_Suite *mtemp___0 ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;

  {
#line 732
  if (memsuite) {
    {
#line 734
    tmp = (*(memsuite->malloc_fcn))(sizeof(struct XML_ParserStruct ));
#line 734
    parser = (XML_Parser )tmp;
    }
#line 736
    if ((unsigned long )parser != (unsigned long )((void *)0)) {
#line 737
      mtemp = (XML_Memory_Handling_Suite *)(& parser->m_mem);
#line 738
      mtemp->malloc_fcn = (void *(*)(size_t size ))memsuite->malloc_fcn;
#line 739
      mtemp->realloc_fcn = (void *(*)(void *ptr , size_t size ))memsuite->realloc_fcn;
#line 740
      mtemp->free_fcn = (void (*)(void *ptr ))memsuite->free_fcn;
    }
  } else {
    {
#line 745
    tmp___0 = malloc(sizeof(struct XML_ParserStruct ));
#line 745
    parser = (XML_Parser )tmp___0;
    }
#line 746
    if ((unsigned long )parser != (unsigned long )((void *)0)) {
#line 747
      mtemp___0 = (XML_Memory_Handling_Suite *)(& parser->m_mem);
#line 748
      mtemp___0->malloc_fcn = (void *(*)(size_t size ))(& malloc);
#line 749
      mtemp___0->realloc_fcn = (void *(*)(void *ptr , size_t size ))(& realloc);
#line 750
      mtemp___0->free_fcn = (void (*)(void *ptr ))(& free);
    }
  }
#line 754
  if (! parser) {
#line 755
    return (parser);
  }
  {
#line 757
  parser->m_buffer = (char *)((void *)0);
#line 758
  parser->m_bufferLim = (char const   *)((void *)0);
#line 760
  parser->m_attsSize = 16;
#line 761
  tmp___1 = (*(parser->m_mem.malloc_fcn))((unsigned long )parser->m_attsSize * sizeof(ATTRIBUTE ));
#line 761
  parser->m_atts = (ATTRIBUTE *)tmp___1;
  }
#line 762
  if ((unsigned long )parser->m_atts == (unsigned long )((void *)0)) {
    {
#line 763
    (*(parser->m_mem.free_fcn))((void *)parser);
    }
#line 764
    return ((XML_Parser )((void *)0));
  }
  {
#line 774
  tmp___2 = (*(parser->m_mem.malloc_fcn))(1024UL * sizeof(XML_Char ));
#line 774
  parser->m_dataBuf = (XML_Char *)tmp___2;
  }
#line 775
  if ((unsigned long )parser->m_dataBuf == (unsigned long )((void *)0)) {
    {
#line 776
    (*(parser->m_mem.free_fcn))((void *)parser->m_atts);
#line 780
    (*(parser->m_mem.free_fcn))((void *)parser);
    }
#line 781
    return ((XML_Parser )((void *)0));
  }
#line 783
  parser->m_dataBufEnd = parser->m_dataBuf + 1024;
#line 785
  if (dtd) {
#line 786
    parser->m_dtd = dtd;
  } else {
    {
#line 788
    parser->m_dtd = dtdCreate___0(& parser->m_mem);
    }
#line 789
    if ((unsigned long )parser->m_dtd == (unsigned long )((void *)0)) {
      {
#line 790
      (*(parser->m_mem.free_fcn))((void *)parser->m_dataBuf);
#line 791
      (*(parser->m_mem.free_fcn))((void *)parser->m_atts);
#line 795
      (*(parser->m_mem.free_fcn))((void *)parser);
      }
#line 796
      return ((XML_Parser )((void *)0));
    }
  }
  {
#line 800
  parser->m_freeBindingList = (BINDING *)((void *)0);
#line 801
  parser->m_freeTagList = (TAG *)((void *)0);
#line 802
  parser->m_freeInternalEntities = (OPEN_INTERNAL_ENTITY *)((void *)0);
#line 804
  parser->m_groupSize = 0U;
#line 805
  parser->m_groupConnector = (char *)((void *)0);
#line 807
  parser->m_unknownEncodingHandler = (int (*)(void *encodingHandlerData , XML_Char const   *name ,
                                              XML_Encoding *info ))((void *)0);
#line 808
  parser->m_unknownEncodingHandlerData = (void *)0;
#line 810
  parser->m_namespaceSeparator = (XML_Char )33;
#line 811
  parser->m_ns = (XML_Bool )0;
#line 812
  parser->m_ns_triplets = (XML_Bool )0;
#line 814
  parser->m_nsAtts = (NS_ATT *)((void *)0);
#line 815
  parser->m_nsAttsVersion = 0UL;
#line 816
  parser->m_nsAttsPower = (unsigned char)0;
#line 818
  poolInit___0(& parser->m_tempPool, & parser->m_mem);
#line 819
  poolInit___0(& parser->m_temp2Pool, & parser->m_mem);
#line 820
  parserInit___0(parser, encodingName);
  }
#line 822
  if (encodingName) {
#line 822
    if (! parser->m_protocolEncodingName) {
      {
#line 823
      XML_ParserFree(parser);
      }
#line 824
      return ((XML_Parser )((void *)0));
    }
  }
#line 827
  if (nameSep) {
    {
#line 828
    parser->m_ns = (XML_Bool )1;
#line 829
    parser->m_internalEncoding = XmlGetUtf8InternalEncodingNS();
#line 830
    parser->m_namespaceSeparator = (XML_Char )*nameSep;
    }
  } else {
    {
#line 833
    parser->m_internalEncoding = XmlGetUtf8InternalEncoding();
    }
  }
#line 836
  return (parser);
}
}
#line 839 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlparse.c"
static void parserInit___0(XML_Parser parser , XML_Char const   *encodingName ) 
{ 
  XML_Char const   *tmp ;

  {
  {
#line 842
  parser->m_processor = & prologInitProcessor___0;
#line 843
  XmlPrologStateInit(& parser->m_prologState);
  }
#line 844
  if ((unsigned long )encodingName != (unsigned long )((void *)0)) {
    {
#line 844
    tmp = poolCopyString___0(& parser->m_tempPool, encodingName);
#line 844
    parser->m_protocolEncodingName = tmp;
    }
  } else {
#line 844
    parser->m_protocolEncodingName = (XML_Char const   *)((void *)0);
  }
  {
#line 847
  parser->m_curBase = (XML_Char const   *)((void *)0);
#line 848
  XmlInitEncoding(& parser->m_initEncoding, & parser->m_encoding, (char const   *)0);
#line 849
  parser->m_userData = (void *)0;
#line 850
  parser->m_handlerArg = (void *)0;
#line 851
  parser->m_startElementHandler = (void (*)(void *userData , XML_Char const   *name ,
                                            XML_Char const   **atts ))((void *)0);
#line 852
  parser->m_endElementHandler = (void (*)(void *userData , XML_Char const   *name ))((void *)0);
#line 853
  parser->m_characterDataHandler = (void (*)(void *userData , XML_Char const   *s ,
                                             int len ))((void *)0);
#line 854
  parser->m_processingInstructionHandler = (void (*)(void *userData , XML_Char const   *target ,
                                                     XML_Char const   *data ))((void *)0);
#line 855
  parser->m_commentHandler = (void (*)(void *userData , XML_Char const   *data ))((void *)0);
#line 856
  parser->m_startCdataSectionHandler = (void (*)(void *userData ))((void *)0);
#line 857
  parser->m_endCdataSectionHandler = (void (*)(void *userData ))((void *)0);
#line 858
  parser->m_defaultHandler = (void (*)(void *userData , XML_Char const   *s , int len ))((void *)0);
#line 859
  parser->m_startDoctypeDeclHandler = (void (*)(void *userData , XML_Char const   *doctypeName ,
                                                XML_Char const   *sysid , XML_Char const   *pubid ,
                                                int has_internal_subset ))((void *)0);
#line 860
  parser->m_endDoctypeDeclHandler = (void (*)(void *userData ))((void *)0);
#line 861
  parser->m_unparsedEntityDeclHandler = (void (*)(void *userData , XML_Char const   *entityName ,
                                                  XML_Char const   *base , XML_Char const   *systemId ,
                                                  XML_Char const   *publicId , XML_Char const   *notationName ))((void *)0);
#line 862
  parser->m_notationDeclHandler = (void (*)(void *userData , XML_Char const   *notationName ,
                                            XML_Char const   *base , XML_Char const   *systemId ,
                                            XML_Char const   *publicId ))((void *)0);
#line 863
  parser->m_startNamespaceDeclHandler = (void (*)(void *userData , XML_Char const   *prefix ,
                                                  XML_Char const   *uri ))((void *)0);
#line 864
  parser->m_endNamespaceDeclHandler = (void (*)(void *userData , XML_Char const   *prefix ))((void *)0);
#line 865
  parser->m_notStandaloneHandler = (int (*)(void *userData ))((void *)0);
#line 866
  parser->m_externalEntityRefHandler = (int (*)(XML_Parser parser , XML_Char const   *context ,
                                                XML_Char const   *base , XML_Char const   *systemId ,
                                                XML_Char const   *publicId ))((void *)0);
#line 867
  parser->m_externalEntityRefHandlerArg = parser;
#line 868
  parser->m_skippedEntityHandler = (void (*)(void *userData , XML_Char const   *entityName ,
                                             int is_parameter_entity ))((void *)0);
#line 869
  parser->m_elementDeclHandler = (void (*)(void *userData , XML_Char const   *name ,
                                           XML_Content *model ))((void *)0);
#line 870
  parser->m_attlistDeclHandler = (void (*)(void *userData , XML_Char const   *elname ,
                                           XML_Char const   *attname , XML_Char const   *att_type ,
                                           XML_Char const   *dflt , int isrequired ))((void *)0);
#line 871
  parser->m_entityDeclHandler = (void (*)(void *userData , XML_Char const   *entityName ,
                                          int is_parameter_entity , XML_Char const   *value ,
                                          int value_length , XML_Char const   *base ,
                                          XML_Char const   *systemId , XML_Char const   *publicId ,
                                          XML_Char const   *notationName ))((void *)0);
#line 872
  parser->m_xmlDeclHandler = (void (*)(void *userData , XML_Char const   *version ,
                                       XML_Char const   *encoding , int standalone ))((void *)0);
#line 873
  parser->m_bufferPtr = (char const   *)parser->m_buffer;
#line 874
  parser->m_bufferEnd = parser->m_buffer;
#line 875
  parser->m_parseEndByteIndex = (XML_Index )0;
#line 876
  parser->m_parseEndPtr = (char const   *)((void *)0);
#line 877
  parser->m_declElementType = (ELEMENT_TYPE *)((void *)0);
#line 878
  parser->m_declAttributeId = (ATTRIBUTE_ID *)((void *)0);
#line 879
  parser->m_declEntity = (ENTITY *)((void *)0);
#line 880
  parser->m_doctypeName = (XML_Char const   *)((void *)0);
#line 881
  parser->m_doctypeSysid = (XML_Char const   *)((void *)0);
#line 882
  parser->m_doctypePubid = (XML_Char const   *)((void *)0);
#line 883
  parser->m_declAttributeType = (XML_Char const   *)((void *)0);
#line 884
  parser->m_declNotationName = (XML_Char const   *)((void *)0);
#line 885
  parser->m_declNotationPublicId = (XML_Char const   *)((void *)0);
#line 886
  parser->m_declAttributeIsCdata = (XML_Bool )0;
#line 887
  parser->m_declAttributeIsId = (XML_Bool )0;
#line 888
  memset((void *)(& parser->m_position), 0, sizeof(POSITION ));
#line 889
  parser->m_errorCode = (enum XML_Error )0;
#line 890
  parser->m_eventPtr = (char const   *)((void *)0);
#line 891
  parser->m_eventEndPtr = (char const   *)((void *)0);
#line 892
  parser->m_positionPtr = (char const   *)((void *)0);
#line 893
  parser->m_openInternalEntities = (OPEN_INTERNAL_ENTITY *)((void *)0);
#line 894
  parser->m_defaultExpandInternalEntities = (XML_Bool )1;
#line 895
  parser->m_tagLevel = 0;
#line 896
  parser->m_tagStack = (TAG *)((void *)0);
#line 897
  parser->m_inheritedBindings = (BINDING *)((void *)0);
#line 898
  parser->m_nSpecifiedAtts = 0;
#line 899
  parser->m_unknownEncodingMem = (void *)0;
#line 900
  parser->m_unknownEncodingRelease = (void (*)(void * ))((void *)0);
#line 901
  parser->m_unknownEncodingData = (void *)0;
#line 902
  parser->m_parentParser = (XML_Parser )((void *)0);
#line 903
  parser->m_parsingStatus.parsing = (enum XML_Parsing )0;
#line 905
  parser->m_isParamEntity = (XML_Bool )0;
#line 906
  parser->m_useForeignDTD = (XML_Bool )0;
#line 907
  parser->m_paramEntityParsing = (enum XML_ParamEntityParsing )0;
#line 909
  parser->m_hash_secret_salt = 0UL;
  }
#line 910
  return;
}
}
#line 913 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlparse.c"
static void moveToFreeBindingList___0(XML_Parser parser , BINDING *bindings ) 
{ 
  BINDING *b ;

  {
  {
#line 916
  while (1) {
    while_continue: /* CIL Label */ ;
#line 916
    if (! bindings) {
#line 916
      goto while_break;
    }
#line 917
    b = bindings;
#line 918
    bindings = bindings->nextTagBinding;
#line 919
    b->nextTagBinding = parser->m_freeBindingList;
#line 920
    parser->m_freeBindingList = b;
  }
  while_break: /* CIL Label */ ;
  }
#line 922
  return;
}
}
#line 1116 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlparse.c"
static void destroyBindings___0(BINDING *bindings , XML_Parser parser ) 
{ 
  BINDING *b ;

  {
  {
#line 1119
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1120
    b = bindings;
#line 1121
    if (! b) {
#line 1122
      goto while_break;
    }
    {
#line 1123
    bindings = b->nextTagBinding;
#line 1124
    (*(parser->m_mem.free_fcn))((void *)b->uri);
#line 1125
    (*(parser->m_mem.free_fcn))((void *)b);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1127
  return;
}
}
#line 1949 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlparse.c"
static XML_LChar const   * const  message___0[41]  = 
#line 1949
  {      (XML_LChar const   */* const  */)0,      (XML_LChar const   */* const  */)"out of memory",      (XML_LChar const   */* const  */)"syntax error",      (XML_LChar const   */* const  */)"no element found", 
        (XML_LChar const   */* const  */)"not well-formed (invalid token)",      (XML_LChar const   */* const  */)"unclosed token",      (XML_LChar const   */* const  */)"partial character",      (XML_LChar const   */* const  */)"mismatched tag", 
        (XML_LChar const   */* const  */)"duplicate attribute",      (XML_LChar const   */* const  */)"junk after document element",      (XML_LChar const   */* const  */)"illegal parameter entity reference",      (XML_LChar const   */* const  */)"undefined entity", 
        (XML_LChar const   */* const  */)"recursive entity reference",      (XML_LChar const   */* const  */)"asynchronous entity",      (XML_LChar const   */* const  */)"reference to invalid character number",      (XML_LChar const   */* const  */)"reference to binary entity", 
        (XML_LChar const   */* const  */)"reference to external entity in attribute",      (XML_LChar const   */* const  */)"XML or text declaration not at start of entity",      (XML_LChar const   */* const  */)"unknown encoding",      (XML_LChar const   */* const  */)"encoding specified in XML declaration is incorrect", 
        (XML_LChar const   */* const  */)"unclosed CDATA section",      (XML_LChar const   */* const  */)"error in processing external entity reference",      (XML_LChar const   */* const  */)"document is not standalone",      (XML_LChar const   */* const  */)"unexpected parser state - please send a bug report", 
        (XML_LChar const   */* const  */)"entity declared in parameter entity",      (XML_LChar const   */* const  */)"requested feature requires XML_DTD support in Expat",      (XML_LChar const   */* const  */)"cannot change setting once parsing has begun",      (XML_LChar const   */* const  */)"unbound prefix", 
        (XML_LChar const   */* const  */)"must not undeclare prefix",      (XML_LChar const   */* const  */)"incomplete markup in parameter entity",      (XML_LChar const   */* const  */)"XML declaration not well-formed",      (XML_LChar const   */* const  */)"text declaration not well-formed", 
        (XML_LChar const   */* const  */)"illegal character(s) in public id",      (XML_LChar const   */* const  */)"parser suspended",      (XML_LChar const   */* const  */)"parser not suspended",      (XML_LChar const   */* const  */)"parsing aborted", 
        (XML_LChar const   */* const  */)"parsing finished",      (XML_LChar const   */* const  */)"cannot suspend in external parameter entity",      (XML_LChar const   */* const  */)"reserved prefix (xml) must not be undeclared or bound to another namespace name",      (XML_LChar const   */* const  */)"reserved prefix (xmlns) must not be declared or undeclared", 
        (XML_LChar const   */* const  */)"prefix must not be bound to one of the reserved namespace names"};
#line 2032 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlparse.c"
static XML_Feature const   features___0[6]  = {      {(enum XML_FeatureEnum )6, "sizeof(XML_Char)", (long )sizeof(XML_Char )}, 
        {(enum XML_FeatureEnum )7, "sizeof(XML_LChar)", (long )sizeof(XML_LChar )}, 
        {(enum XML_FeatureEnum )3, "XML_DTD", 0L}, 
        {(enum XML_FeatureEnum )4, "XML_CONTEXT_BYTES", 1024L}, 
        {(enum XML_FeatureEnum )8, "XML_NS", 0L}, 
        {(enum XML_FeatureEnum )0, (XML_LChar const   *)((void *)0), 0L}};
#line 2073 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlparse.c"
static XML_Bool storeRawNames___0(XML_Parser parser ) 
{ 
  TAG *tag ;
  int bufSize ;
  int nameLen ;
  char *rawNameBuf ;
  char *temp ;
  void *tmp ;

  {
#line 2076
  tag = parser->m_tagStack;
  {
#line 2077
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2077
    if (! tag) {
#line 2077
      goto while_break;
    }
#line 2079
    nameLen = (int )(sizeof(XML_Char ) * (unsigned long )(tag->name.strLen + 1));
#line 2080
    rawNameBuf = tag->buf + nameLen;
#line 2086
    if ((unsigned long )tag->rawName == (unsigned long )rawNameBuf) {
#line 2087
      goto while_break;
    }
#line 2091
    bufSize = (int )((unsigned long )nameLen + (((unsigned long )tag->rawNameLength + (sizeof(XML_Char ) - 1UL)) & ~ (sizeof(XML_Char ) - 1UL)));
#line 2092
    if ((long )bufSize > tag->bufEnd - tag->buf) {
      {
#line 2093
      tmp = (*(parser->m_mem.realloc_fcn))((void *)tag->buf, (size_t )bufSize);
#line 2093
      temp = (char *)tmp;
      }
#line 2094
      if ((unsigned long )temp == (unsigned long )((void *)0)) {
#line 2095
        return ((XML_Bool )0);
      }
#line 2099
      if ((unsigned long )tag->name.str == (unsigned long )tag->buf) {
#line 2100
        tag->name.str = (XML_Char const   *)temp;
      }
#line 2104
      if (tag->name.localPart) {
#line 2105
        tag->name.localPart = (XML_Char const   *)(temp + (tag->name.localPart - (XML_Char const   *)tag->buf));
      }
#line 2107
      tag->buf = temp;
#line 2108
      tag->bufEnd = temp + bufSize;
#line 2109
      rawNameBuf = temp + nameLen;
    }
    {
#line 2111
    memcpy((void */* __restrict  */)rawNameBuf, (void const   */* __restrict  */)tag->rawName,
           (size_t )tag->rawNameLength);
#line 2112
    tag->rawName = (char const   *)rawNameBuf;
#line 2113
    tag = tag->parent;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 2115
  return ((XML_Bool )1);
}
}
#line 2118 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlparse.c"
static enum XML_Error contentProcessor___0(XML_Parser parser , char const   *start ,
                                           char const   *end , char const   **endPtr ) 
{ 
  enum XML_Error result ;
  enum XML_Error tmp ;
  XML_Bool tmp___0 ;

  {
  {
#line 2124
  tmp = doContent___0(parser, 0, parser->m_encoding, start, end, endPtr, (XML_Bool )(! parser->m_parsingStatus.finalBuffer));
#line 2124
  result = tmp;
  }
#line 2126
  if ((unsigned int )result == 0U) {
    {
#line 2127
    tmp___0 = storeRawNames___0(parser);
    }
#line 2127
    if (! tmp___0) {
#line 2128
      return ((enum XML_Error )1);
    }
  }
#line 2130
  return (result);
}
}
#line 2133 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlparse.c"
static enum XML_Error externalEntityInitProcessor___0(XML_Parser parser , char const   *start ,
                                                      char const   *end , char const   **endPtr ) 
{ 
  enum XML_Error result ;
  enum XML_Error tmp ;
  enum XML_Error tmp___0 ;

  {
  {
#line 2139
  tmp = initializeEncoding___0(parser);
#line 2139
  result = tmp;
  }
#line 2140
  if ((unsigned int )result != 0U) {
#line 2141
    return (result);
  }
  {
#line 2142
  parser->m_processor = & externalEntityInitProcessor2___0;
#line 2143
  tmp___0 = externalEntityInitProcessor2___0(parser, start, end, endPtr);
  }
#line 2143
  return (tmp___0);
}
}
#line 2146 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlparse.c"
static enum XML_Error externalEntityInitProcessor2___0(XML_Parser parser , char const   *start ,
                                                       char const   *end , char const   **endPtr ) 
{ 
  char const   *next ;
  int tok ;
  int tmp ;
  enum XML_Error tmp___0 ;

  {
  {
#line 2152
  next = start;
#line 2153
  tmp = (*((parser->m_encoding)->scanners[1]))(parser->m_encoding, start, end, & next);
#line 2153
  tok = tmp;
  }
  {
#line 2155
  if (tok == 14) {
#line 2155
    goto case_14;
  }
#line 2167
  if (tok == -1) {
#line 2167
    goto case_neg_1;
  }
#line 2174
  if (tok == -2) {
#line 2174
    goto case_neg_2;
  }
#line 2154
  goto switch_break;
  case_14: /* CIL Label */ 
#line 2161
  if ((unsigned long )next == (unsigned long )end) {
#line 2161
    if (! parser->m_parsingStatus.finalBuffer) {
#line 2162
      *endPtr = next;
#line 2163
      return ((enum XML_Error )0);
    }
  }
#line 2165
  start = next;
#line 2166
  goto switch_break;
  case_neg_1: /* CIL Label */ 
#line 2168
  if (! parser->m_parsingStatus.finalBuffer) {
#line 2169
    *endPtr = start;
#line 2170
    return ((enum XML_Error )0);
  }
#line 2172
  parser->m_eventPtr = start;
#line 2173
  return ((enum XML_Error )5);
  case_neg_2: /* CIL Label */ 
#line 2175
  if (! parser->m_parsingStatus.finalBuffer) {
#line 2176
    *endPtr = start;
#line 2177
    return ((enum XML_Error )0);
  }
#line 2179
  parser->m_eventPtr = start;
#line 2180
  return ((enum XML_Error )6);
  switch_break: /* CIL Label */ ;
  }
  {
#line 2182
  parser->m_processor = & externalEntityInitProcessor3___0;
#line 2183
  tmp___0 = externalEntityInitProcessor3___0(parser, start, end, endPtr);
  }
#line 2183
  return (tmp___0);
}
}
#line 2186 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlparse.c"
static enum XML_Error externalEntityInitProcessor3___0(XML_Parser parser , char const   *start ,
                                                       char const   *end , char const   **endPtr ) 
{ 
  int tok ;
  char const   *next ;
  enum XML_Error result ;
  enum XML_Error tmp ;

  {
  {
#line 2193
  next = start;
#line 2194
  parser->m_eventPtr = start;
#line 2195
  tok = (*((parser->m_encoding)->scanners[1]))(parser->m_encoding, start, end, & next);
#line 2196
  parser->m_eventEndPtr = next;
  }
  {
#line 2199
  if (tok == 12) {
#line 2199
    goto case_12;
  }
#line 2216
  if (tok == -1) {
#line 2216
    goto case_neg_1;
  }
#line 2222
  if (tok == -2) {
#line 2222
    goto case_neg_2;
  }
#line 2198
  goto switch_break;
  case_12: /* CIL Label */ 
  {
#line 2202
  result = processXmlDecl___0(parser, 1, start, next);
  }
#line 2203
  if ((unsigned int )result != 0U) {
#line 2204
    return (result);
  }
  {
#line 2206
  if ((unsigned int )parser->m_parsingStatus.parsing == 3U) {
#line 2206
    goto case_3;
  }
#line 2209
  if ((unsigned int )parser->m_parsingStatus.parsing == 2U) {
#line 2209
    goto case_2;
  }
#line 2211
  goto switch_default;
  case_3: /* CIL Label */ 
#line 2207
  *endPtr = next;
#line 2208
  return ((enum XML_Error )0);
  case_2: /* CIL Label */ 
#line 2210
  return ((enum XML_Error )35);
  switch_default: /* CIL Label */ 
#line 2212
  start = next;
  switch_break___0: /* CIL Label */ ;
  }
#line 2215
  goto switch_break;
  case_neg_1: /* CIL Label */ 
#line 2217
  if (! parser->m_parsingStatus.finalBuffer) {
#line 2218
    *endPtr = start;
#line 2219
    return ((enum XML_Error )0);
  }
#line 2221
  return ((enum XML_Error )5);
  case_neg_2: /* CIL Label */ 
#line 2223
  if (! parser->m_parsingStatus.finalBuffer) {
#line 2224
    *endPtr = start;
#line 2225
    return ((enum XML_Error )0);
  }
#line 2227
  return ((enum XML_Error )6);
  switch_break: /* CIL Label */ ;
  }
  {
#line 2229
  parser->m_processor = & externalEntityContentProcessor___0;
#line 2230
  parser->m_tagLevel = 1;
#line 2231
  tmp = externalEntityContentProcessor___0(parser, start, end, endPtr);
  }
#line 2231
  return (tmp);
}
}
#line 2234 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlparse.c"
static enum XML_Error externalEntityContentProcessor___0(XML_Parser parser , char const   *start ,
                                                         char const   *end , char const   **endPtr ) 
{ 
  enum XML_Error result ;
  enum XML_Error tmp ;
  XML_Bool tmp___0 ;

  {
  {
#line 2240
  tmp = doContent___0(parser, 1, parser->m_encoding, start, end, endPtr, (XML_Bool )(! parser->m_parsingStatus.finalBuffer));
#line 2240
  result = tmp;
  }
#line 2242
  if ((unsigned int )result == 0U) {
    {
#line 2243
    tmp___0 = storeRawNames___0(parser);
    }
#line 2243
    if (! tmp___0) {
#line 2244
      return ((enum XML_Error )1);
    }
  }
#line 2246
  return (result);
}
}
#line 2249 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlparse.c"
static enum XML_Error doContent___0(XML_Parser parser , int startTagLevel , ENCODING const   *enc ,
                                    char const   *s , char const   *end , char const   **nextPtr ,
                                    XML_Bool haveMore ) 
{ 
  DTD *dtd ;
  char const   **eventPP ;
  char const   **eventEndPP ;
  char const   *next ;
  int tok ;
  int tmp ;
  XML_Char c___0 ;
  XML_Char const   *name ;
  ENTITY *entity ;
  XML_Char ch ;
  int tmp___0 ;
  XML_Char *tmp___1 ;
  NAMED *tmp___2 ;
  enum XML_Error result ;
  XML_Char const   *context ;
  int tmp___3 ;
  TAG *tag ;
  enum XML_Error result___0 ;
  XML_Char *toPtr ;
  void *tmp___4 ;
  void *tmp___5 ;
  char const   *rawNameEnd ;
  char const   *fromPtr ;
  int bufSize ;
  int convLen ;
  char *temp ;
  void *tmp___6 ;
  char const   *rawName ;
  enum XML_Error result___1 ;
  BINDING *bindings ;
  XML_Bool noElmHandlers ;
  TAG_NAME name___0 ;
  int tmp___7 ;
  XML_Char *tmp___8 ;
  BINDING *b ;
  enum XML_Error tmp___9 ;
  int len ;
  char const   *rawName___0 ;
  TAG *tag___0 ;
  int tmp___10 ;
  XML_Char const   *localPart ;
  XML_Char const   *prefix ;
  XML_Char *uri ;
  XML_Char *tmp___11 ;
  XML_Char const   *tmp___12 ;
  XML_Char *tmp___13 ;
  XML_Char *tmp___14 ;
  XML_Char const   *tmp___15 ;
  BINDING *b___0 ;
  enum XML_Error tmp___16 ;
  int n ;
  int tmp___17 ;
  XML_Char buf[4] ;
  int tmp___18 ;
  XML_Char c___1 ;
  enum XML_Error result___2 ;
  ICHAR *dataPtr ;
  void (*charDataHandler)(void *userData , XML_Char const   *s , int len ) ;
  ICHAR *dataPtr___0 ;
  int tmp___19 ;
  int tmp___20 ;

  {
#line 2259
  dtd = parser->m_dtd;
#line 2263
  if ((unsigned long )enc == (unsigned long )parser->m_encoding) {
#line 2264
    eventPP = & parser->m_eventPtr;
#line 2265
    eventEndPP = & parser->m_eventEndPtr;
  } else {
#line 2268
    eventPP = & (parser->m_openInternalEntities)->internalEventPtr;
#line 2269
    eventEndPP = & (parser->m_openInternalEntities)->internalEventEndPtr;
  }
#line 2271
  *eventPP = s;
  {
#line 2273
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 2274
    next = s;
#line 2275
    tmp = (*(enc->scanners[1]))(enc, s, end, & next);
#line 2275
    tok = tmp;
#line 2276
    *eventEndPP = next;
    }
    {
#line 2278
    if (tok == -3) {
#line 2278
      goto case_neg_3;
    }
#line 2299
    if (tok == -4) {
#line 2299
      goto case_neg_4;
    }
#line 2311
    if (tok == 0) {
#line 2311
      goto case_0;
    }
#line 2314
    if (tok == -1) {
#line 2314
      goto case_neg_1;
    }
#line 2320
    if (tok == -2) {
#line 2320
      goto case_neg_2;
    }
#line 2326
    if (tok == 9) {
#line 2326
      goto case_9;
    }
#line 2402
    if (tok == 1) {
#line 2402
      goto case_1;
    }
#line 2402
    if (tok == 2) {
#line 2402
      goto case_1;
    }
#line 2471
    if (tok == 3) {
#line 2471
      goto case_3;
    }
#line 2471
    if (tok == 4) {
#line 2471
      goto case_3;
    }
#line 2513
    if (tok == 5) {
#line 2513
      goto case_5;
    }
#line 2568
    if (tok == 10) {
#line 2568
      goto case_10;
    }
#line 2581
    if (tok == 12) {
#line 2581
      goto case_12;
    }
#line 2583
    if (tok == 7) {
#line 2583
      goto case_7;
    }
#line 2591
    if (tok == 8) {
#line 2591
      goto case_8;
    }
#line 2623
    if (tok == -5) {
#line 2623
      goto case_neg_5;
    }
#line 2655
    if (tok == 6) {
#line 2655
      goto case_6;
    }
#line 2680
    if (tok == 11) {
#line 2680
      goto case_11;
    }
#line 2684
    if (tok == 13) {
#line 2684
      goto case_13;
    }
#line 2688
    goto switch_default;
    case_neg_3: /* CIL Label */ 
#line 2279
    if (haveMore) {
#line 2280
      *nextPtr = s;
#line 2281
      return ((enum XML_Error )0);
    }
#line 2283
    *eventEndPP = end;
#line 2284
    if (parser->m_characterDataHandler) {
      {
#line 2285
      c___0 = (XML_Char )10;
#line 2286
      (*(parser->m_characterDataHandler))(parser->m_handlerArg, (XML_Char const   *)(& c___0),
                                          1);
      }
    } else
#line 2288
    if (parser->m_defaultHandler) {
      {
#line 2289
      reportDefault___0(parser, enc, s, end);
      }
    }
#line 2293
    if (startTagLevel == 0) {
#line 2294
      return ((enum XML_Error )3);
    }
#line 2295
    if (parser->m_tagLevel != startTagLevel) {
#line 2296
      return ((enum XML_Error )13);
    }
#line 2297
    *nextPtr = end;
#line 2298
    return ((enum XML_Error )0);
    case_neg_4: /* CIL Label */ 
#line 2300
    if (haveMore) {
#line 2301
      *nextPtr = s;
#line 2302
      return ((enum XML_Error )0);
    }
#line 2304
    if (startTagLevel > 0) {
#line 2305
      if (parser->m_tagLevel != startTagLevel) {
#line 2306
        return ((enum XML_Error )13);
      }
#line 2307
      *nextPtr = s;
#line 2308
      return ((enum XML_Error )0);
    }
#line 2310
    return ((enum XML_Error )3);
    case_0: /* CIL Label */ 
#line 2312
    *eventPP = next;
#line 2313
    return ((enum XML_Error )4);
    case_neg_1: /* CIL Label */ 
#line 2315
    if (haveMore) {
#line 2316
      *nextPtr = s;
#line 2317
      return ((enum XML_Error )0);
    }
#line 2319
    return ((enum XML_Error )5);
    case_neg_2: /* CIL Label */ 
#line 2321
    if (haveMore) {
#line 2322
      *nextPtr = s;
#line 2323
      return ((enum XML_Error )0);
    }
#line 2325
    return ((enum XML_Error )6);
    case_9: /* CIL Label */ 
    {
#line 2330
    tmp___0 = (*(enc->predefinedEntityName))(enc, s + enc->minBytesPerChar, next - enc->minBytesPerChar);
#line 2330
    ch = (XML_Char )tmp___0;
    }
#line 2333
    if (ch) {
#line 2334
      if (parser->m_characterDataHandler) {
        {
#line 2335
        (*(parser->m_characterDataHandler))(parser->m_handlerArg, (XML_Char const   *)(& ch),
                                            1);
        }
      } else
#line 2336
      if (parser->m_defaultHandler) {
        {
#line 2337
        reportDefault___0(parser, enc, s, next);
        }
      }
#line 2338
      goto switch_break;
    }
    {
#line 2340
    tmp___1 = poolStoreString___0(& dtd->pool, enc, s + enc->minBytesPerChar, next - enc->minBytesPerChar);
#line 2340
    name = (XML_Char const   *)tmp___1;
    }
#line 2343
    if (! name) {
#line 2344
      return ((enum XML_Error )1);
    }
    {
#line 2345
    tmp___2 = lookup___0(parser, & dtd->generalEntities, name, (size_t )0);
#line 2345
    entity = (ENTITY *)tmp___2;
#line 2346
    dtd->pool.ptr = dtd->pool.start;
    }
#line 2351
    if (! dtd->hasParamEntityRefs) {
#line 2351
      goto _L;
    } else
#line 2351
    if (dtd->standalone) {
      _L: /* CIL Label */ 
#line 2352
      if (! entity) {
#line 2353
        return ((enum XML_Error )11);
      } else
#line 2354
      if (! entity->is_internal) {
#line 2355
        return ((enum XML_Error )24);
      }
    } else
#line 2357
    if (! entity) {
#line 2358
      if (parser->m_skippedEntityHandler) {
        {
#line 2359
        (*(parser->m_skippedEntityHandler))(parser->m_handlerArg, name, 0);
        }
      } else
#line 2360
      if (parser->m_defaultHandler) {
        {
#line 2361
        reportDefault___0(parser, enc, s, next);
        }
      }
#line 2362
      goto switch_break;
    }
#line 2364
    if (entity->open) {
#line 2365
      return ((enum XML_Error )12);
    }
#line 2366
    if (entity->notation) {
#line 2367
      return ((enum XML_Error )15);
    }
#line 2368
    if (entity->textPtr) {
#line 2370
      if (! parser->m_defaultExpandInternalEntities) {
#line 2371
        if (parser->m_skippedEntityHandler) {
          {
#line 2372
          (*(parser->m_skippedEntityHandler))(parser->m_handlerArg, entity->name,
                                              0);
          }
        } else
#line 2373
        if (parser->m_defaultHandler) {
          {
#line 2374
          reportDefault___0(parser, enc, s, next);
          }
        }
#line 2375
        goto switch_break;
      }
      {
#line 2377
      result = processInternalEntity___0(parser, entity, (XML_Bool )0);
      }
#line 2378
      if ((unsigned int )result != 0U) {
#line 2379
        return (result);
      }
    } else
#line 2381
    if (parser->m_externalEntityRefHandler) {
      {
#line 2383
      entity->open = (XML_Bool )1;
#line 2384
      context = getContext___0(parser);
#line 2385
      entity->open = (XML_Bool )0;
      }
#line 2386
      if (! context) {
#line 2387
        return ((enum XML_Error )1);
      }
      {
#line 2388
      tmp___3 = (*(parser->m_externalEntityRefHandler))(parser->m_externalEntityRefHandlerArg,
                                                        context, entity->base, entity->systemId,
                                                        entity->publicId);
      }
#line 2388
      if (! tmp___3) {
#line 2393
        return ((enum XML_Error )21);
      }
#line 2394
      parser->m_tempPool.ptr = parser->m_tempPool.start;
    } else
#line 2396
    if (parser->m_defaultHandler) {
      {
#line 2397
      reportDefault___0(parser, enc, s, next);
      }
    }
#line 2398
    goto switch_break;
    case_1: /* CIL Label */ 
    case_2: /* CIL Label */ 
#line 2407
    if (parser->m_freeTagList) {
#line 2408
      tag = parser->m_freeTagList;
#line 2409
      parser->m_freeTagList = (parser->m_freeTagList)->parent;
    } else {
      {
#line 2412
      tmp___4 = (*(parser->m_mem.malloc_fcn))(sizeof(TAG ));
#line 2412
      tag = (TAG *)tmp___4;
      }
#line 2413
      if (! tag) {
#line 2414
        return ((enum XML_Error )1);
      }
      {
#line 2415
      tmp___5 = (*(parser->m_mem.malloc_fcn))((size_t )32);
#line 2415
      tag->buf = (char *)tmp___5;
      }
#line 2416
      if (! tag->buf) {
        {
#line 2417
        (*(parser->m_mem.free_fcn))((void *)tag);
        }
#line 2418
        return ((enum XML_Error )1);
      }
#line 2420
      tag->bufEnd = tag->buf + 32;
    }
    {
#line 2422
    tag->bindings = (BINDING *)((void *)0);
#line 2423
    tag->parent = parser->m_tagStack;
#line 2424
    parser->m_tagStack = tag;
#line 2425
    tag->name.localPart = (XML_Char const   *)((void *)0);
#line 2426
    tag->name.prefix = (XML_Char const   *)((void *)0);
#line 2427
    tag->rawName = s + enc->minBytesPerChar;
#line 2428
    tag->rawNameLength = (*(enc->nameLength))(enc, tag->rawName);
#line 2429
    (parser->m_tagLevel) ++;
#line 2431
    rawNameEnd = tag->rawName + tag->rawNameLength;
#line 2432
    fromPtr = tag->rawName;
#line 2433
    toPtr = tag->buf;
    }
    {
#line 2434
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 2437
      (*(enc->utf8Convert))(enc, & fromPtr, rawNameEnd, & toPtr, (char const   *)(tag->bufEnd - 1));
#line 2440
      convLen = (int )(toPtr - tag->buf);
      }
#line 2441
      if ((unsigned long )fromPtr == (unsigned long )rawNameEnd) {
#line 2442
        tag->name.strLen = convLen;
#line 2443
        goto while_break___0;
      }
      {
#line 2445
      bufSize = (int )(tag->bufEnd - tag->buf) << 1;
#line 2447
      tmp___6 = (*(parser->m_mem.realloc_fcn))((void *)tag->buf, (size_t )bufSize);
#line 2447
      temp = (char *)tmp___6;
      }
#line 2448
      if ((unsigned long )temp == (unsigned long )((void *)0)) {
#line 2449
        return ((enum XML_Error )1);
      }
#line 2450
      tag->buf = temp;
#line 2451
      tag->bufEnd = temp + bufSize;
#line 2452
      toPtr = temp + convLen;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 2456
    tag->name.str = (XML_Char const   *)tag->buf;
#line 2457
    *toPtr = (XML_Char )'\000';
#line 2458
    result___0 = storeAtts___0(parser, enc, s, & tag->name, & tag->bindings);
    }
#line 2459
    if (result___0) {
#line 2460
      return (result___0);
    }
#line 2461
    if (parser->m_startElementHandler) {
      {
#line 2462
      (*(parser->m_startElementHandler))(parser->m_handlerArg, tag->name.str, (XML_Char const   **)parser->m_atts);
      }
    } else
#line 2464
    if (parser->m_defaultHandler) {
      {
#line 2465
      reportDefault___0(parser, enc, s, next);
      }
    }
    {
#line 2466
    poolClear___0(& parser->m_tempPool);
    }
#line 2467
    goto switch_break;
    case_3: /* CIL Label */ 
    case_4: /* CIL Label */ 
    {
#line 2473
    rawName = s + enc->minBytesPerChar;
#line 2475
    bindings = (BINDING *)((void *)0);
#line 2476
    noElmHandlers = (XML_Bool )1;
#line 2478
    tmp___7 = (*(enc->nameLength))(enc, rawName);
#line 2478
    tmp___8 = poolStoreString___0(& parser->m_tempPool, enc, rawName, rawName + tmp___7);
#line 2478
    name___0.str = (XML_Char const   *)tmp___8;
    }
#line 2480
    if (! name___0.str) {
#line 2481
      return ((enum XML_Error )1);
    }
    {
#line 2482
    parser->m_tempPool.start = parser->m_tempPool.ptr;
#line 2483
    result___1 = storeAtts___0(parser, enc, s, & name___0, & bindings);
    }
#line 2484
    if (result___1) {
#line 2485
      return (result___1);
    }
#line 2486
    parser->m_tempPool.start = parser->m_tempPool.ptr;
#line 2487
    if (parser->m_startElementHandler) {
      {
#line 2488
      (*(parser->m_startElementHandler))(parser->m_handlerArg, name___0.str, (XML_Char const   **)parser->m_atts);
#line 2489
      noElmHandlers = (XML_Bool )0;
      }
    }
#line 2491
    if (parser->m_endElementHandler) {
#line 2492
      if (parser->m_startElementHandler) {
#line 2493
        *eventPP = *eventEndPP;
      }
      {
#line 2494
      (*(parser->m_endElementHandler))(parser->m_handlerArg, name___0.str);
#line 2495
      noElmHandlers = (XML_Bool )0;
      }
    }
#line 2497
    if (noElmHandlers) {
#line 2497
      if (parser->m_defaultHandler) {
        {
#line 2498
        reportDefault___0(parser, enc, s, next);
        }
      }
    }
    {
#line 2499
    poolClear___0(& parser->m_tempPool);
    }
    {
#line 2500
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 2500
      if (! bindings) {
#line 2500
        goto while_break___1;
      }
#line 2501
      b = bindings;
#line 2502
      if (parser->m_endNamespaceDeclHandler) {
        {
#line 2503
        (*(parser->m_endNamespaceDeclHandler))(parser->m_handlerArg, (b->prefix)->name);
        }
      }
#line 2504
      bindings = bindings->nextTagBinding;
#line 2505
      b->nextTagBinding = parser->m_freeBindingList;
#line 2506
      parser->m_freeBindingList = b;
#line 2507
      (b->prefix)->binding = b->prevPrefixBinding;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 2510
    if (parser->m_tagLevel == 0) {
      {
#line 2511
      tmp___9 = epilogProcessor___0(parser, next, end, nextPtr);
      }
#line 2511
      return (tmp___9);
    }
#line 2512
    goto switch_break;
    case_5: /* CIL Label */ 
#line 2514
    if (parser->m_tagLevel == startTagLevel) {
#line 2515
      return ((enum XML_Error )13);
    } else {
      {
#line 2519
      tag___0 = parser->m_tagStack;
#line 2520
      parser->m_tagStack = tag___0->parent;
#line 2521
      tag___0->parent = parser->m_freeTagList;
#line 2522
      parser->m_freeTagList = tag___0;
#line 2523
      rawName___0 = s + enc->minBytesPerChar * 2;
#line 2524
      len = (*(enc->nameLength))(enc, rawName___0);
      }
#line 2525
      if (len != tag___0->rawNameLength) {
#line 2527
        *eventPP = rawName___0;
#line 2528
        return ((enum XML_Error )7);
      } else {
        {
#line 2525
        tmp___10 = memcmp((void const   *)tag___0->rawName, (void const   *)rawName___0,
                          (size_t )len);
        }
#line 2525
        if (tmp___10 != 0) {
#line 2527
          *eventPP = rawName___0;
#line 2528
          return ((enum XML_Error )7);
        }
      }
#line 2530
      (parser->m_tagLevel) --;
#line 2531
      if (parser->m_endElementHandler) {
#line 2535
        localPart = tag___0->name.localPart;
#line 2536
        if (parser->m_ns) {
#line 2536
          if (localPart) {
#line 2541
            uri = (XML_Char *)tag___0->name.str + tag___0->name.uriLen;
            {
#line 2543
            while (1) {
              while_continue___2: /* CIL Label */ ;
#line 2543
              if (! *localPart) {
#line 2543
                goto while_break___2;
              }
#line 2543
              tmp___11 = uri;
#line 2543
              uri ++;
#line 2543
              tmp___12 = localPart;
#line 2543
              localPart ++;
#line 2543
              *tmp___11 = (XML_Char )*tmp___12;
            }
            while_break___2: /* CIL Label */ ;
            }
#line 2544
            prefix = (XML_Char const   *)((XML_Char *)tag___0->name.prefix);
#line 2545
            if (parser->m_ns_triplets) {
#line 2545
              if (prefix) {
#line 2546
                tmp___13 = uri;
#line 2546
                uri ++;
#line 2546
                *tmp___13 = parser->m_namespaceSeparator;
                {
#line 2547
                while (1) {
                  while_continue___3: /* CIL Label */ ;
#line 2547
                  if (! *prefix) {
#line 2547
                    goto while_break___3;
                  }
#line 2547
                  tmp___14 = uri;
#line 2547
                  uri ++;
#line 2547
                  tmp___15 = prefix;
#line 2547
                  prefix ++;
#line 2547
                  *tmp___14 = (XML_Char )*tmp___15;
                }
                while_break___3: /* CIL Label */ ;
                }
              }
            }
#line 2549
            *uri = (XML_Char )'\000';
          }
        }
        {
#line 2551
        (*(parser->m_endElementHandler))(parser->m_handlerArg, tag___0->name.str);
        }
      } else
#line 2553
      if (parser->m_defaultHandler) {
        {
#line 2554
        reportDefault___0(parser, enc, s, next);
        }
      }
      {
#line 2555
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 2555
        if (! tag___0->bindings) {
#line 2555
          goto while_break___4;
        }
#line 2556
        b___0 = tag___0->bindings;
#line 2557
        if (parser->m_endNamespaceDeclHandler) {
          {
#line 2558
          (*(parser->m_endNamespaceDeclHandler))(parser->m_handlerArg, (b___0->prefix)->name);
          }
        }
#line 2559
        tag___0->bindings = (tag___0->bindings)->nextTagBinding;
#line 2560
        b___0->nextTagBinding = parser->m_freeBindingList;
#line 2561
        parser->m_freeBindingList = b___0;
#line 2562
        (b___0->prefix)->binding = b___0->prevPrefixBinding;
      }
      while_break___4: /* CIL Label */ ;
      }
#line 2564
      if (parser->m_tagLevel == 0) {
        {
#line 2565
        tmp___16 = epilogProcessor___0(parser, next, end, nextPtr);
        }
#line 2565
        return (tmp___16);
      }
    }
#line 2567
    goto switch_break;
    case_10: /* CIL Label */ 
    {
#line 2570
    tmp___17 = (*(enc->charRefNumber))(enc, s);
#line 2570
    n = tmp___17;
    }
#line 2571
    if (n < 0) {
#line 2572
      return ((enum XML_Error )14);
    }
#line 2573
    if (parser->m_characterDataHandler) {
      {
#line 2575
      tmp___18 = XmlUtf8Encode(n, buf);
#line 2575
      (*(parser->m_characterDataHandler))(parser->m_handlerArg, (XML_Char const   *)(buf),
                                          tmp___18);
      }
    } else
#line 2577
    if (parser->m_defaultHandler) {
      {
#line 2578
      reportDefault___0(parser, enc, s, next);
      }
    }
#line 2580
    goto switch_break;
    case_12: /* CIL Label */ 
#line 2582
    return ((enum XML_Error )17);
    case_7: /* CIL Label */ 
#line 2584
    if (parser->m_characterDataHandler) {
      {
#line 2585
      c___1 = (XML_Char )10;
#line 2586
      (*(parser->m_characterDataHandler))(parser->m_handlerArg, (XML_Char const   *)(& c___1),
                                          1);
      }
    } else
#line 2588
    if (parser->m_defaultHandler) {
      {
#line 2589
      reportDefault___0(parser, enc, s, next);
      }
    }
#line 2590
    goto switch_break;
    case_8: /* CIL Label */ 
#line 2594
    if (parser->m_startCdataSectionHandler) {
      {
#line 2595
      (*(parser->m_startCdataSectionHandler))(parser->m_handlerArg);
      }
    } else
#line 2612
    if (parser->m_defaultHandler) {
      {
#line 2613
      reportDefault___0(parser, enc, s, next);
      }
    }
    {
#line 2614
    result___2 = doCdataSection___0(parser, enc, & next, end, nextPtr, haveMore);
    }
#line 2615
    if ((unsigned int )result___2 != 0U) {
#line 2616
      return (result___2);
    } else
#line 2617
    if (! next) {
#line 2618
      parser->m_processor = & cdataSectionProcessor___0;
#line 2619
      return (result___2);
    }
#line 2622
    goto switch_break;
    case_neg_5: /* CIL Label */ 
#line 2624
    if (haveMore) {
#line 2625
      *nextPtr = s;
#line 2626
      return ((enum XML_Error )0);
    }
#line 2628
    if (parser->m_characterDataHandler) {
#line 2629
      if (! enc->isUtf8) {
        {
#line 2630
        dataPtr = parser->m_dataBuf;
#line 2631
        (*(enc->utf8Convert))(enc, & s, end, & dataPtr, (char const   *)parser->m_dataBufEnd);
#line 2632
        (*(parser->m_characterDataHandler))(parser->m_handlerArg, (XML_Char const   *)parser->m_dataBuf,
                                            (int )(dataPtr - parser->m_dataBuf));
        }
      } else {
        {
#line 2636
        (*(parser->m_characterDataHandler))(parser->m_handlerArg, (XML_Char const   *)((XML_Char *)s),
                                            (int )((XML_Char *)end - (XML_Char *)s));
        }
      }
    } else
#line 2640
    if (parser->m_defaultHandler) {
      {
#line 2641
      reportDefault___0(parser, enc, s, end);
      }
    }
#line 2645
    if (startTagLevel == 0) {
#line 2646
      *eventPP = end;
#line 2647
      return ((enum XML_Error )3);
    }
#line 2649
    if (parser->m_tagLevel != startTagLevel) {
#line 2650
      *eventPP = end;
#line 2651
      return ((enum XML_Error )13);
    }
#line 2653
    *nextPtr = end;
#line 2654
    return ((enum XML_Error )0);
    case_6: /* CIL Label */ 
#line 2657
    charDataHandler = parser->m_characterDataHandler;
#line 2658
    if (charDataHandler) {
#line 2659
      if (! enc->isUtf8) {
        {
#line 2660
        while (1) {
          while_continue___5: /* CIL Label */ ;
          {
#line 2661
          dataPtr___0 = parser->m_dataBuf;
#line 2662
          (*(enc->utf8Convert))(enc, & s, next, & dataPtr___0, (char const   *)parser->m_dataBufEnd);
#line 2663
          *eventEndPP = s;
#line 2664
          (*charDataHandler)(parser->m_handlerArg, (XML_Char const   *)parser->m_dataBuf,
                             (int )(dataPtr___0 - parser->m_dataBuf));
          }
#line 2666
          if ((unsigned long )s == (unsigned long )next) {
#line 2667
            goto while_break___5;
          }
#line 2668
          *eventPP = s;
        }
        while_break___5: /* CIL Label */ ;
        }
      } else {
        {
#line 2672
        (*charDataHandler)(parser->m_handlerArg, (XML_Char const   *)((XML_Char *)s),
                           (int )((XML_Char *)next - (XML_Char *)s));
        }
      }
    } else
#line 2676
    if (parser->m_defaultHandler) {
      {
#line 2677
      reportDefault___0(parser, enc, s, next);
      }
    }
#line 2679
    goto switch_break;
    case_11: /* CIL Label */ 
    {
#line 2681
    tmp___19 = reportProcessingInstruction___0(parser, enc, s, next);
    }
#line 2681
    if (! tmp___19) {
#line 2682
      return ((enum XML_Error )1);
    }
#line 2683
    goto switch_break;
    case_13: /* CIL Label */ 
    {
#line 2685
    tmp___20 = reportComment___0(parser, enc, s, next);
    }
#line 2685
    if (! tmp___20) {
#line 2686
      return ((enum XML_Error )1);
    }
#line 2687
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 2689
    if (parser->m_defaultHandler) {
      {
#line 2690
      reportDefault___0(parser, enc, s, next);
      }
    }
#line 2691
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 2693
    s = next;
#line 2693
    *eventPP = s;
    {
#line 2695
    if ((unsigned int )parser->m_parsingStatus.parsing == 3U) {
#line 2695
      goto case_3___0;
    }
#line 2698
    if ((unsigned int )parser->m_parsingStatus.parsing == 2U) {
#line 2698
      goto case_2___0;
    }
#line 2700
    goto switch_default___0;
    case_3___0: /* CIL Label */ 
#line 2696
    *nextPtr = next;
#line 2697
    return ((enum XML_Error )0);
    case_2___0: /* CIL Label */ 
#line 2699
    return ((enum XML_Error )35);
    switch_default___0: /* CIL Label */ ;
    switch_break___0: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 2716 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlparse.c"
static enum XML_Error storeAtts___0(XML_Parser parser , ENCODING const   *enc , char const   *attStr ,
                                    TAG_NAME *tagNamePtr , BINDING **bindingsPtr ) 
{ 
  DTD *dtd ;
  ELEMENT_TYPE *elementType ;
  int nDefaultAtts ;
  XML_Char const   **appAtts ;
  int attIndex ;
  int prefixLen ;
  int i ;
  int n ;
  XML_Char *uri ;
  int nPrefixes ;
  BINDING *binding ;
  XML_Char const   *localPart ;
  NAMED *tmp ;
  XML_Char const   *name ;
  XML_Char const   *tmp___0 ;
  NAMED *tmp___1 ;
  int tmp___2 ;
  int oldAttsSize ;
  ATTRIBUTE *temp ;
  void *tmp___3 ;
  ATTRIBUTE *currAtt ;
  ATTRIBUTE_ID *attId ;
  int tmp___4 ;
  ATTRIBUTE_ID *tmp___5 ;
  int tmp___6 ;
  enum XML_Error result ;
  XML_Bool isCdata ;
  int j ;
  XML_Char *tmp___7 ;
  enum XML_Error result___0 ;
  enum XML_Error tmp___8 ;
  DEFAULT_ATTRIBUTE const   *da ;
  enum XML_Error result___1 ;
  enum XML_Error tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int j___0 ;
  unsigned long version ;
  int nsAttsSize ;
  NS_ATT *temp___0 ;
  unsigned char tmp___14 ;
  void *tmp___15 ;
  XML_Char const   *s ;
  ATTRIBUTE_ID *id ;
  BINDING const   *b ;
  unsigned long uriHash ;
  NAMED *tmp___16 ;
  XML_Char c___0 ;
  XML_Char *tmp___18 ;
  int tmp___19 ;
  XML_Bool tmp___20 ;
  XML_Char const   *tmp___21 ;
  XML_Char c___1 ;
  XML_Char *tmp___23 ;
  int tmp___24 ;
  XML_Bool tmp___25 ;
  XML_Char const   *tmp___26 ;
  unsigned char step ;
  unsigned long mask ;
  XML_Char const   *s1 ;
  XML_Char const   *s2 ;
  XML_Char *tmp___28 ;
  int tmp___29 ;
  XML_Bool tmp___30 ;
  XML_Char const   *tmp___31 ;
  XML_Char const   *tmp___32 ;
  int tmp___33 ;
  int tmp___34 ;
  TAG *p ;
  void *tmp___35 ;

  {
  {
#line 2721
  dtd = parser->m_dtd;
#line 2725
  attIndex = 0;
#line 2730
  nPrefixes = 0;
#line 2735
  tmp = lookup___0(parser, & dtd->elementTypes, tagNamePtr->str, (size_t )0);
#line 2735
  elementType = (ELEMENT_TYPE *)tmp;
  }
#line 2736
  if (! elementType) {
    {
#line 2737
    tmp___0 = poolCopyString___0(& dtd->pool, tagNamePtr->str);
#line 2737
    name = tmp___0;
    }
#line 2738
    if (! name) {
#line 2739
      return ((enum XML_Error )1);
    }
    {
#line 2740
    tmp___1 = lookup___0(parser, & dtd->elementTypes, name, sizeof(ELEMENT_TYPE ));
#line 2740
    elementType = (ELEMENT_TYPE *)tmp___1;
    }
#line 2742
    if (! elementType) {
#line 2743
      return ((enum XML_Error )1);
    }
#line 2744
    if (parser->m_ns) {
      {
#line 2744
      tmp___2 = setElementTypePrefix___0(parser, elementType);
      }
#line 2744
      if (! tmp___2) {
#line 2745
        return ((enum XML_Error )1);
      }
    }
  }
  {
#line 2747
  nDefaultAtts = elementType->nDefaultAtts;
#line 2750
  n = (*(enc->getAtts))(enc, attStr, parser->m_attsSize, parser->m_atts);
  }
#line 2751
  if (n + nDefaultAtts > parser->m_attsSize) {
    {
#line 2752
    oldAttsSize = parser->m_attsSize;
#line 2757
    parser->m_attsSize = (n + nDefaultAtts) + 16;
#line 2758
    tmp___3 = (*(parser->m_mem.realloc_fcn))((void *)parser->m_atts, (unsigned long )parser->m_attsSize * sizeof(ATTRIBUTE ));
#line 2758
    temp = (ATTRIBUTE *)tmp___3;
    }
#line 2759
    if ((unsigned long )temp == (unsigned long )((void *)0)) {
#line 2760
      return ((enum XML_Error )1);
    }
#line 2761
    parser->m_atts = temp;
#line 2768
    if (n > oldAttsSize) {
      {
#line 2769
      (*(enc->getAtts))(enc, attStr, n, parser->m_atts);
      }
    }
  }
#line 2772
  appAtts = (XML_Char const   **)parser->m_atts;
#line 2773
  i = 0;
  {
#line 2773
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2773
    if (! (i < n)) {
#line 2773
      goto while_break;
    }
    {
#line 2774
    currAtt = parser->m_atts + i;
#line 2779
    tmp___4 = (*(enc->nameLength))(enc, currAtt->name);
#line 2779
    tmp___5 = getAttributeId___0(parser, enc, currAtt->name, currAtt->name + tmp___4);
#line 2779
    attId = tmp___5;
    }
#line 2782
    if (! attId) {
#line 2783
      return ((enum XML_Error )1);
    }
#line 2796
    if (*(attId->name + -1)) {
#line 2797
      if ((unsigned long )enc == (unsigned long )parser->m_encoding) {
#line 2798
        parser->m_eventPtr = (parser->m_atts + i)->name;
      }
#line 2799
      return ((enum XML_Error )8);
    }
#line 2801
    *(attId->name + -1) = (XML_Char )1;
#line 2802
    tmp___6 = attIndex;
#line 2802
    attIndex ++;
#line 2802
    *(appAtts + tmp___6) = (XML_Char const   *)attId->name;
#line 2803
    if (! (parser->m_atts + i)->normalized) {
#line 2805
      isCdata = (XML_Bool )1;
#line 2808
      if (attId->maybeTokenized) {
#line 2810
        j = 0;
        {
#line 2810
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 2810
          if (! (j < nDefaultAtts)) {
#line 2810
            goto while_break___0;
          }
#line 2811
          if ((unsigned long )attId == (unsigned long )(elementType->defaultAtts + j)->id) {
#line 2812
            isCdata = (elementType->defaultAtts + j)->isCdata;
#line 2813
            goto while_break___0;
          }
#line 2810
          j ++;
        }
        while_break___0: /* CIL Label */ ;
        }
      }
      {
#line 2819
      result = storeAttributeValue___0(parser, enc, isCdata, (parser->m_atts + i)->valuePtr,
                                       (parser->m_atts + i)->valueEnd, & parser->m_tempPool);
      }
#line 2822
      if (result) {
#line 2823
        return (result);
      }
#line 2824
      *(appAtts + attIndex) = (XML_Char const   *)parser->m_tempPool.start;
#line 2825
      parser->m_tempPool.start = parser->m_tempPool.ptr;
    } else {
      {
#line 2829
      tmp___7 = poolStoreString___0(& parser->m_tempPool, enc, (parser->m_atts + i)->valuePtr,
                                    (parser->m_atts + i)->valueEnd);
#line 2829
      *(appAtts + attIndex) = (XML_Char const   *)tmp___7;
      }
#line 2831
      if ((unsigned long )*(appAtts + attIndex) == (unsigned long )((XML_Char const   *)0)) {
#line 2832
        return ((enum XML_Error )1);
      }
#line 2833
      parser->m_tempPool.start = parser->m_tempPool.ptr;
    }
#line 2836
    if (attId->prefix) {
#line 2837
      if (attId->xmlns) {
        {
#line 2839
        tmp___8 = addBinding___0(parser, attId->prefix, (ATTRIBUTE_ID const   *)attId,
                                 *(appAtts + attIndex), bindingsPtr);
#line 2839
        result___0 = tmp___8;
        }
#line 2841
        if (result___0) {
#line 2842
          return (result___0);
        }
#line 2843
        attIndex --;
      } else {
#line 2847
        attIndex ++;
#line 2848
        nPrefixes ++;
#line 2849
        *(attId->name + -1) = (XML_Char )2;
      }
    } else {
#line 2853
      attIndex ++;
    }
#line 2773
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2857
  parser->m_nSpecifiedAtts = attIndex;
#line 2858
  if (elementType->idAtt) {
#line 2858
    if (*((elementType->idAtt)->name + -1)) {
#line 2859
      i = 0;
      {
#line 2859
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 2859
        if (! (i < attIndex)) {
#line 2859
          goto while_break___1;
        }
#line 2860
        if ((unsigned long )*(appAtts + i) == (unsigned long )(elementType->idAtt)->name) {
#line 2861
          parser->m_idAttIndex = i;
#line 2862
          goto while_break___1;
        }
#line 2859
        i += 2;
      }
      while_break___1: /* CIL Label */ ;
      }
    } else {
#line 2866
      parser->m_idAttIndex = -1;
    }
  } else {
#line 2866
    parser->m_idAttIndex = -1;
  }
#line 2869
  i = 0;
  {
#line 2869
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 2869
    if (! (i < nDefaultAtts)) {
#line 2869
      goto while_break___2;
    }
#line 2870
    da = (DEFAULT_ATTRIBUTE const   *)(elementType->defaultAtts + i);
#line 2871
    if (! *((da->id)->name + -1)) {
#line 2871
      if (da->value) {
#line 2872
        if ((da->id)->prefix) {
#line 2873
          if ((da->id)->xmlns) {
            {
#line 2874
            tmp___9 = addBinding___0(parser, (PREFIX *)(da->id)->prefix, (ATTRIBUTE_ID const   *)da->id,
                                     (XML_Char const   *)da->value, bindingsPtr);
#line 2874
            result___1 = tmp___9;
            }
#line 2876
            if (result___1) {
#line 2877
              return (result___1);
            }
          } else {
#line 2880
            *((da->id)->name + -1) = (XML_Char )2;
#line 2881
            nPrefixes ++;
#line 2882
            tmp___10 = attIndex;
#line 2882
            attIndex ++;
#line 2882
            *(appAtts + tmp___10) = (XML_Char const   *)(da->id)->name;
#line 2883
            tmp___11 = attIndex;
#line 2883
            attIndex ++;
#line 2883
            *(appAtts + tmp___11) = (XML_Char const   *)da->value;
          }
        } else {
#line 2887
          *((da->id)->name + -1) = (XML_Char )1;
#line 2888
          tmp___12 = attIndex;
#line 2888
          attIndex ++;
#line 2888
          *(appAtts + tmp___12) = (XML_Char const   *)(da->id)->name;
#line 2889
          tmp___13 = attIndex;
#line 2889
          attIndex ++;
#line 2889
          *(appAtts + tmp___13) = (XML_Char const   *)da->value;
        }
      }
    }
#line 2869
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 2893
  *(appAtts + attIndex) = (XML_Char const   *)0;
#line 2897
  i = 0;
#line 2898
  if (nPrefixes) {
#line 2900
    version = parser->m_nsAttsVersion;
#line 2901
    nsAttsSize = 1 << (int )parser->m_nsAttsPower;
#line 2903
    if ((nPrefixes << 1) >> (int )parser->m_nsAttsPower) {
      {
#line 2906
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 2906
        tmp___14 = parser->m_nsAttsPower;
#line 2906
        parser->m_nsAttsPower = (unsigned char )((int )parser->m_nsAttsPower + 1);
#line 2906
        if (! (nPrefixes >> (int )tmp___14)) {
#line 2906
          goto while_break___3;
        }
      }
      while_break___3: /* CIL Label */ ;
      }
#line 2907
      if ((int )parser->m_nsAttsPower < 3) {
#line 2908
        parser->m_nsAttsPower = (unsigned char)3;
      }
      {
#line 2909
      nsAttsSize = 1 << (int )parser->m_nsAttsPower;
#line 2910
      tmp___15 = (*(parser->m_mem.realloc_fcn))((void *)parser->m_nsAtts, (unsigned long )nsAttsSize * sizeof(NS_ATT ));
#line 2910
      temp___0 = (NS_ATT *)tmp___15;
      }
#line 2911
      if (! temp___0) {
#line 2912
        return ((enum XML_Error )1);
      }
#line 2913
      parser->m_nsAtts = temp___0;
#line 2914
      version = 0UL;
    }
#line 2917
    if (! version) {
#line 2918
      version = 4294967295UL;
#line 2919
      j___0 = nsAttsSize;
      {
#line 2919
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 2919
        if (! (j___0 != 0)) {
#line 2919
          goto while_break___4;
        }
#line 2920
        j___0 --;
#line 2920
        (parser->m_nsAtts + j___0)->version = version;
      }
      while_break___4: /* CIL Label */ ;
      }
    }
#line 2922
    version --;
#line 2922
    parser->m_nsAttsVersion = version;
    {
#line 2925
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 2925
      if (! (i < attIndex)) {
#line 2925
        goto while_break___5;
      }
#line 2926
      s = *(appAtts + i);
#line 2927
      if ((int const   )*(s + -1) == 2) {
        {
#line 2930
        uriHash = parser->m_hash_secret_salt;
#line 2931
        *((XML_Char *)s + -1) = (XML_Char )0;
#line 2932
        tmp___16 = lookup___0(parser, & dtd->attributeIds, s, (size_t )0);
#line 2932
        id = (ATTRIBUTE_ID *)tmp___16;
#line 2933
        b = (BINDING const   *)(id->prefix)->binding;
        }
#line 2934
        if (! b) {
#line 2935
          return ((enum XML_Error )27);
        }
#line 2938
        j___0 = 0;
        {
#line 2938
        while (1) {
          while_continue___6: /* CIL Label */ ;
#line 2938
          if (! (j___0 < (int )b->uriLen)) {
#line 2938
            goto while_break___6;
          }
#line 2939
          c___0 = *(b->uri + j___0);
#line 2940
          if ((unsigned long )parser->m_tempPool.ptr == (unsigned long )parser->m_tempPool.end) {
            {
#line 2940
            tmp___20 = poolGrow___0(& parser->m_tempPool);
            }
#line 2940
            if (tmp___20) {
#line 2940
              tmp___18 = parser->m_tempPool.ptr;
#line 2940
              (parser->m_tempPool.ptr) ++;
#line 2940
              *tmp___18 = c___0;
#line 2940
              tmp___19 = 1;
            } else {
#line 2940
              tmp___19 = 0;
            }
          } else {
#line 2940
            tmp___18 = parser->m_tempPool.ptr;
#line 2940
            (parser->m_tempPool.ptr) ++;
#line 2940
            *tmp___18 = c___0;
#line 2940
            tmp___19 = 1;
          }
#line 2940
          if (! tmp___19) {
#line 2941
            return ((enum XML_Error )1);
          }
#line 2942
          uriHash = uriHash * 1000003UL ^ (unsigned long )((unsigned char )c___0);
#line 2938
          j___0 ++;
        }
        while_break___6: /* CIL Label */ ;
        }
        {
#line 2944
        while (1) {
          while_continue___7: /* CIL Label */ ;
#line 2944
          tmp___21 = s;
#line 2944
          s ++;
#line 2944
          if (! ((int const   )*tmp___21 != 58)) {
#line 2944
            goto while_break___7;
          }
        }
        while_break___7: /* CIL Label */ ;
        }
        {
#line 2946
        while (1) {
          while_continue___8: /* CIL Label */ ;
#line 2947
          c___1 = (XML_Char )*s;
#line 2948
          if ((unsigned long )parser->m_tempPool.ptr == (unsigned long )parser->m_tempPool.end) {
            {
#line 2948
            tmp___25 = poolGrow___0(& parser->m_tempPool);
            }
#line 2948
            if (tmp___25) {
#line 2948
              tmp___23 = parser->m_tempPool.ptr;
#line 2948
              (parser->m_tempPool.ptr) ++;
#line 2948
              *tmp___23 = (XML_Char )*s;
#line 2948
              tmp___24 = 1;
            } else {
#line 2948
              tmp___24 = 0;
            }
          } else {
#line 2948
            tmp___23 = parser->m_tempPool.ptr;
#line 2948
            (parser->m_tempPool.ptr) ++;
#line 2948
            *tmp___23 = (XML_Char )*s;
#line 2948
            tmp___24 = 1;
          }
#line 2948
          if (! tmp___24) {
#line 2949
            return ((enum XML_Error )1);
          }
#line 2950
          uriHash = uriHash * 1000003UL ^ (unsigned long )((unsigned char )c___1);
#line 2946
          tmp___26 = s;
#line 2946
          s ++;
#line 2946
          if (! *tmp___26) {
#line 2946
            goto while_break___8;
          }
        }
        while_break___8: /* CIL Label */ ;
        }
#line 2956
        step = (unsigned char)0;
#line 2957
        mask = (unsigned long )(nsAttsSize - 1);
#line 2958
        j___0 = (int )(uriHash & mask);
        {
#line 2959
        while (1) {
          while_continue___9: /* CIL Label */ ;
#line 2959
          if (! ((parser->m_nsAtts + j___0)->version == version)) {
#line 2959
            goto while_break___9;
          }
#line 2961
          if (uriHash == (parser->m_nsAtts + j___0)->hash) {
#line 2962
            s1 = (XML_Char const   *)parser->m_tempPool.start;
#line 2963
            s2 = (parser->m_nsAtts + j___0)->uriName;
            {
#line 2965
            while (1) {
              while_continue___10: /* CIL Label */ ;
#line 2965
              if ((int const   )*s1 == (int const   )*s2) {
#line 2965
                if (! ((int const   )*s1 != 0)) {
#line 2965
                  goto while_break___10;
                }
              } else {
#line 2965
                goto while_break___10;
              }
#line 2965
              s1 ++;
#line 2965
              s2 ++;
            }
            while_break___10: /* CIL Label */ ;
            }
#line 2966
            if ((int const   )*s1 == 0) {
#line 2967
              return ((enum XML_Error )8);
            }
          }
#line 2969
          if (! step) {
#line 2970
            step = (unsigned char )((((uriHash & ~ mask) >> ((int )parser->m_nsAttsPower - 1)) & (mask >> 2)) | 1UL);
          }
#line 2971
          if (j___0 < (int )step) {
#line 2971
            j___0 += nsAttsSize - (int )step;
          } else {
#line 2971
            j___0 -= (int )step;
          }
        }
        while_break___9: /* CIL Label */ ;
        }
#line 2975
        if (parser->m_ns_triplets) {
#line 2976
          *(parser->m_tempPool.ptr + -1) = parser->m_namespaceSeparator;
#line 2977
          s = (b->prefix)->name;
          {
#line 2978
          while (1) {
            while_continue___11: /* CIL Label */ ;
#line 2979
            if ((unsigned long )parser->m_tempPool.ptr == (unsigned long )parser->m_tempPool.end) {
              {
#line 2979
              tmp___30 = poolGrow___0(& parser->m_tempPool);
              }
#line 2979
              if (tmp___30) {
#line 2979
                tmp___28 = parser->m_tempPool.ptr;
#line 2979
                (parser->m_tempPool.ptr) ++;
#line 2979
                *tmp___28 = (XML_Char )*s;
#line 2979
                tmp___29 = 1;
              } else {
#line 2979
                tmp___29 = 0;
              }
            } else {
#line 2979
              tmp___28 = parser->m_tempPool.ptr;
#line 2979
              (parser->m_tempPool.ptr) ++;
#line 2979
              *tmp___28 = (XML_Char )*s;
#line 2979
              tmp___29 = 1;
            }
#line 2979
            if (! tmp___29) {
#line 2980
              return ((enum XML_Error )1);
            }
#line 2978
            tmp___31 = s;
#line 2978
            s ++;
#line 2978
            if (! *tmp___31) {
#line 2978
              goto while_break___11;
            }
          }
          while_break___11: /* CIL Label */ ;
          }
        }
#line 2985
        s = (XML_Char const   *)parser->m_tempPool.start;
#line 2986
        parser->m_tempPool.start = parser->m_tempPool.ptr;
#line 2987
        *(appAtts + i) = s;
#line 2990
        (parser->m_nsAtts + j___0)->version = version;
#line 2991
        (parser->m_nsAtts + j___0)->hash = uriHash;
#line 2992
        (parser->m_nsAtts + j___0)->uriName = s;
#line 2994
        nPrefixes --;
#line 2994
        if (! nPrefixes) {
#line 2995
          i += 2;
#line 2996
          goto while_break___5;
        }
      } else {
#line 3000
        *((XML_Char *)s + -1) = (XML_Char )0;
      }
#line 2925
      i += 2;
    }
    while_break___5: /* CIL Label */ ;
    }
  }
  {
#line 3004
  while (1) {
    while_continue___12: /* CIL Label */ ;
#line 3004
    if (! (i < attIndex)) {
#line 3004
      goto while_break___12;
    }
#line 3005
    *((XML_Char *)*(appAtts + i) + -1) = (XML_Char )0;
#line 3004
    i += 2;
  }
  while_break___12: /* CIL Label */ ;
  }
#line 3006
  binding = *bindingsPtr;
  {
#line 3006
  while (1) {
    while_continue___13: /* CIL Label */ ;
#line 3006
    if (! binding) {
#line 3006
      goto while_break___13;
    }
#line 3007
    *((binding->attId)->name + -1) = (XML_Char )0;
#line 3006
    binding = binding->nextTagBinding;
  }
  while_break___13: /* CIL Label */ ;
  }
#line 3009
  if (! parser->m_ns) {
#line 3010
    return ((enum XML_Error )0);
  }
#line 3013
  if (elementType->prefix) {
#line 3014
    binding = (elementType->prefix)->binding;
#line 3015
    if (! binding) {
#line 3016
      return ((enum XML_Error )27);
    }
#line 3017
    localPart = tagNamePtr->str;
    {
#line 3018
    while (1) {
      while_continue___14: /* CIL Label */ ;
#line 3018
      tmp___32 = localPart;
#line 3018
      localPart ++;
#line 3018
      if (! ((int const   )*tmp___32 != 58)) {
#line 3018
        goto while_break___14;
      }
    }
    while_break___14: /* CIL Label */ ;
    }
  } else
#line 3021
  if (dtd->defaultPrefix.binding) {
#line 3022
    binding = dtd->defaultPrefix.binding;
#line 3023
    localPart = tagNamePtr->str;
  } else {
#line 3026
    return ((enum XML_Error )0);
  }
#line 3027
  prefixLen = 0;
#line 3028
  if (parser->m_ns_triplets) {
#line 3028
    if ((binding->prefix)->name) {
      {
#line 3029
      while (1) {
        while_continue___15: /* CIL Label */ ;
#line 3029
        tmp___33 = prefixLen;
#line 3029
        prefixLen ++;
#line 3029
        if (! *((binding->prefix)->name + tmp___33)) {
#line 3029
          goto while_break___15;
        }
      }
      while_break___15: /* CIL Label */ ;
      }
    }
  }
#line 3032
  tagNamePtr->localPart = localPart;
#line 3033
  tagNamePtr->uriLen = binding->uriLen;
#line 3034
  tagNamePtr->prefix = (binding->prefix)->name;
#line 3035
  tagNamePtr->prefixLen = prefixLen;
#line 3036
  i = 0;
  {
#line 3036
  while (1) {
    while_continue___16: /* CIL Label */ ;
#line 3036
    tmp___34 = i;
#line 3036
    i ++;
#line 3036
    if (! *(localPart + tmp___34)) {
#line 3036
      goto while_break___16;
    }
  }
  while_break___16: /* CIL Label */ ;
  }
#line 3038
  n = (i + binding->uriLen) + prefixLen;
#line 3039
  if (n > binding->uriAlloc) {
    {
#line 3041
    tmp___35 = (*(parser->m_mem.malloc_fcn))((unsigned long )(n + 24) * sizeof(XML_Char ));
#line 3041
    uri = (XML_Char *)tmp___35;
    }
#line 3042
    if (! uri) {
#line 3043
      return ((enum XML_Error )1);
    }
    {
#line 3044
    binding->uriAlloc = n + 24;
#line 3045
    memcpy((void */* __restrict  */)uri, (void const   */* __restrict  */)binding->uri,
           (unsigned long )binding->uriLen * sizeof(XML_Char ));
#line 3046
    p = parser->m_tagStack;
    }
    {
#line 3046
    while (1) {
      while_continue___17: /* CIL Label */ ;
#line 3046
      if (! p) {
#line 3046
        goto while_break___17;
      }
#line 3047
      if ((unsigned long )p->name.str == (unsigned long )binding->uri) {
#line 3048
        p->name.str = (XML_Char const   *)uri;
      }
#line 3046
      p = p->parent;
    }
    while_break___17: /* CIL Label */ ;
    }
    {
#line 3049
    (*(parser->m_mem.free_fcn))((void *)binding->uri);
#line 3050
    binding->uri = uri;
    }
  }
  {
#line 3053
  uri = binding->uri + binding->uriLen;
#line 3054
  memcpy((void */* __restrict  */)uri, (void const   */* __restrict  */)localPart,
         (unsigned long )i * sizeof(XML_Char ));
  }
#line 3056
  if (prefixLen) {
    {
#line 3057
    uri += i - 1;
#line 3058
    *uri = parser->m_namespaceSeparator;
#line 3059
    memcpy((void */* __restrict  */)(uri + 1), (void const   */* __restrict  */)(binding->prefix)->name,
           (unsigned long )prefixLen * sizeof(XML_Char ));
    }
  }
#line 3061
  tagNamePtr->str = (XML_Char const   *)binding->uri;
#line 3062
  return ((enum XML_Error )0);
}
}
#line 3072 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlparse.c"
static XML_Char const   xmlNamespace___0[37]  = 
#line 3072
  {      (XML_Char const   )104,      (XML_Char const   )116,      (XML_Char const   )116,      (XML_Char const   )112, 
        (XML_Char const   )58,      (XML_Char const   )47,      (XML_Char const   )47,      (XML_Char const   )119, 
        (XML_Char const   )119,      (XML_Char const   )119,      (XML_Char const   )46,      (XML_Char const   )119, 
        (XML_Char const   )51,      (XML_Char const   )46,      (XML_Char const   )111,      (XML_Char const   )114, 
        (XML_Char const   )103,      (XML_Char const   )47,      (XML_Char const   )88,      (XML_Char const   )77, 
        (XML_Char const   )76,      (XML_Char const   )47,      (XML_Char const   )49,      (XML_Char const   )57, 
        (XML_Char const   )57,      (XML_Char const   )56,      (XML_Char const   )47,      (XML_Char const   )110, 
        (XML_Char const   )97,      (XML_Char const   )109,      (XML_Char const   )101,      (XML_Char const   )115, 
        (XML_Char const   )112,      (XML_Char const   )97,      (XML_Char const   )99,      (XML_Char const   )101, 
        (XML_Char const   )'\000'};
#line 3080 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlparse.c"
static int const   xmlLen___0  =    (int const   )((unsigned long )((int )sizeof(xmlNamespace___0)) / sizeof(XML_Char ) - 1UL);
#line 3082 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlparse.c"
static XML_Char const   xmlnsNamespace___0[30]  = 
#line 3082
  {      (XML_Char const   )104,      (XML_Char const   )116,      (XML_Char const   )116,      (XML_Char const   )112, 
        (XML_Char const   )58,      (XML_Char const   )47,      (XML_Char const   )47,      (XML_Char const   )119, 
        (XML_Char const   )119,      (XML_Char const   )119,      (XML_Char const   )46,      (XML_Char const   )119, 
        (XML_Char const   )51,      (XML_Char const   )46,      (XML_Char const   )111,      (XML_Char const   )114, 
        (XML_Char const   )103,      (XML_Char const   )47,      (XML_Char const   )50,      (XML_Char const   )48, 
        (XML_Char const   )48,      (XML_Char const   )48,      (XML_Char const   )47,      (XML_Char const   )120, 
        (XML_Char const   )109,      (XML_Char const   )108,      (XML_Char const   )110,      (XML_Char const   )115, 
        (XML_Char const   )47,      (XML_Char const   )'\000'};
#line 3089 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlparse.c"
static int const   xmlnsLen___0  =    (int const   )((unsigned long )((int )sizeof(xmlnsNamespace___0)) / sizeof(XML_Char ) - 1UL);
#line 3068 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlparse.c"
static enum XML_Error addBinding___0(XML_Parser parser , PREFIX *prefix , ATTRIBUTE_ID const   *attId ,
                                     XML_Char const   *uri , BINDING **bindingsPtr ) 
{ 
  XML_Bool mustBeXML ;
  XML_Bool isXML ;
  XML_Bool isXMLNS ;
  BINDING *b ;
  int len ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  XML_Char *temp ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  XML_Char const   *tmp___5 ;

  {
#line 3092
  mustBeXML = (XML_Bool )0;
#line 3093
  isXML = (XML_Bool )1;
#line 3094
  isXMLNS = (XML_Bool )1;
#line 3100
  if ((int const   )*uri == 0) {
#line 3100
    if (prefix->name) {
#line 3101
      return ((enum XML_Error )28);
    }
  }
#line 3103
  if (prefix->name) {
#line 3103
    if ((int const   )*(prefix->name + 0) == 120) {
#line 3103
      if ((int const   )*(prefix->name + 1) == 109) {
#line 3103
        if ((int const   )*(prefix->name + 2) == 108) {
#line 3109
          if ((int const   )*(prefix->name + 3) == 110) {
#line 3109
            if ((int const   )*(prefix->name + 4) == 115) {
#line 3109
              if ((int const   )*(prefix->name + 5) == 0) {
#line 3112
                return ((enum XML_Error )39);
              }
            }
          }
#line 3114
          if ((int const   )*(prefix->name + 3) == 0) {
#line 3115
            mustBeXML = (XML_Bool )1;
          }
        }
      }
    }
  }
#line 3118
  len = 0;
  {
#line 3118
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3118
    if (! *(uri + len)) {
#line 3118
      goto while_break;
    }
#line 3119
    if (isXML) {
#line 3119
      if (len > (int )xmlLen___0) {
#line 3120
        isXML = (XML_Bool )0;
      } else
#line 3119
      if ((int const   )*(uri + len) != (int const   )xmlNamespace___0[len]) {
#line 3120
        isXML = (XML_Bool )0;
      }
    }
#line 3122
    if (! mustBeXML) {
#line 3122
      if (isXMLNS) {
#line 3122
        if (len > (int )xmlnsLen___0) {
#line 3124
          isXMLNS = (XML_Bool )0;
        } else
#line 3122
        if ((int const   )*(uri + len) != (int const   )xmlnsNamespace___0[len]) {
#line 3124
          isXMLNS = (XML_Bool )0;
        }
      }
    }
#line 3118
    len ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 3126
  if (isXML) {
#line 3126
    if (len == (int )xmlLen___0) {
#line 3126
      tmp = 1;
    } else {
#line 3126
      tmp = 0;
    }
  } else {
#line 3126
    tmp = 0;
  }
#line 3126
  isXML = (XML_Bool )tmp;
#line 3127
  if (isXMLNS) {
#line 3127
    if (len == (int )xmlnsLen___0) {
#line 3127
      tmp___0 = 1;
    } else {
#line 3127
      tmp___0 = 0;
    }
  } else {
#line 3127
    tmp___0 = 0;
  }
#line 3127
  isXMLNS = (XML_Bool )tmp___0;
#line 3129
  if ((int )mustBeXML != (int )isXML) {
#line 3130
    if (mustBeXML) {
#line 3130
      tmp___1 = 38;
    } else {
#line 3130
      tmp___1 = 40;
    }
#line 3130
    return ((enum XML_Error )tmp___1);
  }
#line 3133
  if (isXMLNS) {
#line 3134
    return ((enum XML_Error )40);
  }
#line 3136
  if (parser->m_namespaceSeparator) {
#line 3137
    len ++;
  }
#line 3138
  if (parser->m_freeBindingList) {
#line 3139
    b = parser->m_freeBindingList;
#line 3140
    if (len > b->uriAlloc) {
      {
#line 3141
      tmp___2 = (*(parser->m_mem.realloc_fcn))((void *)b->uri, sizeof(XML_Char ) * (unsigned long )(len + 24));
#line 3141
      temp = (XML_Char *)tmp___2;
      }
#line 3143
      if ((unsigned long )temp == (unsigned long )((void *)0)) {
#line 3144
        return ((enum XML_Error )1);
      }
#line 3145
      b->uri = temp;
#line 3146
      b->uriAlloc = len + 24;
    }
#line 3148
    parser->m_freeBindingList = b->nextTagBinding;
  } else {
    {
#line 3151
    tmp___3 = (*(parser->m_mem.malloc_fcn))(sizeof(BINDING ));
#line 3151
    b = (BINDING *)tmp___3;
    }
#line 3152
    if (! b) {
#line 3153
      return ((enum XML_Error )1);
    }
    {
#line 3154
    tmp___4 = (*(parser->m_mem.malloc_fcn))(sizeof(XML_Char ) * (unsigned long )(len + 24));
#line 3154
    b->uri = (XML_Char *)tmp___4;
    }
#line 3155
    if (! b->uri) {
      {
#line 3156
      (*(parser->m_mem.free_fcn))((void *)b);
      }
#line 3157
      return ((enum XML_Error )1);
    }
#line 3159
    b->uriAlloc = len + 24;
  }
  {
#line 3161
  b->uriLen = len;
#line 3162
  memcpy((void */* __restrict  */)b->uri, (void const   */* __restrict  */)uri, (unsigned long )len * sizeof(XML_Char ));
  }
#line 3163
  if (parser->m_namespaceSeparator) {
#line 3164
    *(b->uri + (len - 1)) = parser->m_namespaceSeparator;
  }
#line 3165
  b->prefix = prefix;
#line 3166
  b->attId = attId;
#line 3167
  b->prevPrefixBinding = prefix->binding;
#line 3169
  if ((int const   )*uri == 0) {
#line 3169
    if ((unsigned long )prefix == (unsigned long )(& (parser->m_dtd)->defaultPrefix)) {
#line 3170
      prefix->binding = (BINDING *)((void *)0);
    } else {
#line 3172
      prefix->binding = b;
    }
  } else {
#line 3172
    prefix->binding = b;
  }
#line 3173
  b->nextTagBinding = *bindingsPtr;
#line 3174
  *bindingsPtr = b;
#line 3176
  if (attId) {
#line 3176
    if (parser->m_startNamespaceDeclHandler) {
#line 3177
      if (prefix->binding) {
#line 3177
        tmp___5 = uri;
      } else {
#line 3177
        tmp___5 = (XML_Char const   *)0;
      }
      {
#line 3177
      (*(parser->m_startNamespaceDeclHandler))(parser->m_handlerArg, prefix->name,
                                               tmp___5);
      }
    }
  }
#line 3179
  return ((enum XML_Error )0);
}
}
#line 3185 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlparse.c"
static enum XML_Error cdataSectionProcessor___0(XML_Parser parser , char const   *start ,
                                                char const   *end , char const   **endPtr ) 
{ 
  enum XML_Error result ;
  enum XML_Error tmp ;
  enum XML_Error tmp___0 ;
  enum XML_Error tmp___1 ;

  {
  {
#line 3191
  tmp = doCdataSection___0(parser, parser->m_encoding, & start, end, endPtr, (XML_Bool )(! parser->m_parsingStatus.finalBuffer));
#line 3191
  result = tmp;
  }
#line 3193
  if ((unsigned int )result != 0U) {
#line 3194
    return (result);
  }
#line 3195
  if (start) {
#line 3196
    if (parser->m_parentParser) {
      {
#line 3197
      parser->m_processor = & externalEntityContentProcessor___0;
#line 3198
      tmp___0 = externalEntityContentProcessor___0(parser, start, end, endPtr);
      }
#line 3198
      return (tmp___0);
    } else {
      {
#line 3201
      parser->m_processor = & contentProcessor___0;
#line 3202
      tmp___1 = contentProcessor___0(parser, start, end, endPtr);
      }
#line 3202
      return (tmp___1);
    }
  }
#line 3205
  return (result);
}
}
#line 3211 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlparse.c"
static enum XML_Error doCdataSection___0(XML_Parser parser , ENCODING const   *enc ,
                                         char const   **startPtr , char const   *end ,
                                         char const   **nextPtr , XML_Bool haveMore ) 
{ 
  char const   *s ;
  char const   **eventPP ;
  char const   **eventEndPP ;
  char const   *next ;
  int tok ;
  int tmp ;
  XML_Char c___0 ;
  void (*charDataHandler)(void *userData , XML_Char const   *s , int len ) ;
  ICHAR *dataPtr ;

  {
#line 3219
  s = *startPtr;
#line 3222
  if ((unsigned long )enc == (unsigned long )parser->m_encoding) {
#line 3223
    eventPP = & parser->m_eventPtr;
#line 3224
    *eventPP = s;
#line 3225
    eventEndPP = & parser->m_eventEndPtr;
  } else {
#line 3228
    eventPP = & (parser->m_openInternalEntities)->internalEventPtr;
#line 3229
    eventEndPP = & (parser->m_openInternalEntities)->internalEventEndPtr;
  }
#line 3231
  *eventPP = s;
#line 3232
  *startPtr = (char const   *)((void *)0);
  {
#line 3234
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 3236
    tmp = (*(enc->scanners[2]))(enc, s, end, & next);
#line 3236
    tok = tmp;
#line 3237
    *eventEndPP = next;
    }
    {
#line 3239
    if (tok == 40) {
#line 3239
      goto case_40;
    }
#line 3255
    if (tok == 7) {
#line 3255
      goto case_7;
    }
#line 3263
    if (tok == 6) {
#line 3263
      goto case_6;
    }
#line 3288
    if (tok == 0) {
#line 3288
      goto case_0;
    }
#line 3291
    if (tok == -2) {
#line 3291
      goto case_neg_2;
    }
#line 3298
    if (tok == -4) {
#line 3298
      goto case_neg_4;
    }
#line 3298
    if (tok == -1) {
#line 3298
      goto case_neg_4;
    }
#line 3304
    goto switch_default;
    case_40: /* CIL Label */ 
#line 3240
    if (parser->m_endCdataSectionHandler) {
      {
#line 3241
      (*(parser->m_endCdataSectionHandler))(parser->m_handlerArg);
      }
    } else
#line 3247
    if (parser->m_defaultHandler) {
      {
#line 3248
      reportDefault___0(parser, enc, s, next);
      }
    }
#line 3249
    *startPtr = next;
#line 3250
    *nextPtr = next;
#line 3251
    if ((unsigned int )parser->m_parsingStatus.parsing == 2U) {
#line 3252
      return ((enum XML_Error )35);
    } else {
#line 3254
      return ((enum XML_Error )0);
    }
    case_7: /* CIL Label */ 
#line 3256
    if (parser->m_characterDataHandler) {
      {
#line 3257
      c___0 = (XML_Char )10;
#line 3258
      (*(parser->m_characterDataHandler))(parser->m_handlerArg, (XML_Char const   *)(& c___0),
                                          1);
      }
    } else
#line 3260
    if (parser->m_defaultHandler) {
      {
#line 3261
      reportDefault___0(parser, enc, s, next);
      }
    }
#line 3262
    goto switch_break;
    case_6: /* CIL Label */ 
#line 3265
    charDataHandler = parser->m_characterDataHandler;
#line 3266
    if (charDataHandler) {
#line 3267
      if (! enc->isUtf8) {
        {
#line 3268
        while (1) {
          while_continue___0: /* CIL Label */ ;
          {
#line 3269
          dataPtr = parser->m_dataBuf;
#line 3270
          (*(enc->utf8Convert))(enc, & s, next, & dataPtr, (char const   *)parser->m_dataBufEnd);
#line 3271
          *eventEndPP = next;
#line 3272
          (*charDataHandler)(parser->m_handlerArg, (XML_Char const   *)parser->m_dataBuf,
                             (int )(dataPtr - parser->m_dataBuf));
          }
#line 3274
          if ((unsigned long )s == (unsigned long )next) {
#line 3275
            goto while_break___0;
          }
#line 3276
          *eventPP = s;
        }
        while_break___0: /* CIL Label */ ;
        }
      } else {
        {
#line 3280
        (*charDataHandler)(parser->m_handlerArg, (XML_Char const   *)((XML_Char *)s),
                           (int )((XML_Char *)next - (XML_Char *)s));
        }
      }
    } else
#line 3284
    if (parser->m_defaultHandler) {
      {
#line 3285
      reportDefault___0(parser, enc, s, next);
      }
    }
#line 3287
    goto switch_break;
    case_0: /* CIL Label */ 
#line 3289
    *eventPP = next;
#line 3290
    return ((enum XML_Error )4);
    case_neg_2: /* CIL Label */ 
#line 3292
    if (haveMore) {
#line 3293
      *nextPtr = s;
#line 3294
      return ((enum XML_Error )0);
    }
#line 3296
    return ((enum XML_Error )6);
    case_neg_4: /* CIL Label */ 
    case_neg_1: /* CIL Label */ 
#line 3299
    if (haveMore) {
#line 3300
      *nextPtr = s;
#line 3301
      return ((enum XML_Error )0);
    }
#line 3303
    return ((enum XML_Error )20);
    switch_default: /* CIL Label */ 
#line 3305
    *eventPP = next;
#line 3306
    return ((enum XML_Error )23);
    switch_break: /* CIL Label */ ;
    }
#line 3309
    s = next;
#line 3309
    *eventPP = s;
    {
#line 3311
    if ((unsigned int )parser->m_parsingStatus.parsing == 3U) {
#line 3311
      goto case_3;
    }
#line 3314
    if ((unsigned int )parser->m_parsingStatus.parsing == 2U) {
#line 3314
      goto case_2;
    }
#line 3316
    goto switch_default___0;
    case_3: /* CIL Label */ 
#line 3312
    *nextPtr = next;
#line 3313
    return ((enum XML_Error )0);
    case_2: /* CIL Label */ 
#line 3315
    return ((enum XML_Error )35);
    switch_default___0: /* CIL Label */ ;
    switch_break___0: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 3327 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlparse.c"
static enum XML_Error ignoreSectionProcessor___0(XML_Parser parser , char const   *start ,
                                                 char const   *end , char const   **endPtr ) 
{ 
  enum XML_Error result ;
  enum XML_Error tmp ;
  enum XML_Error tmp___0 ;

  {
  {
#line 3333
  tmp = doIgnoreSection___0(parser, parser->m_encoding, & start, end, endPtr, (XML_Bool )(! parser->m_parsingStatus.finalBuffer));
#line 3333
  result = tmp;
  }
#line 3335
  if ((unsigned int )result != 0U) {
#line 3336
    return (result);
  }
#line 3337
  if (start) {
    {
#line 3338
    parser->m_processor = & prologProcessor___0;
#line 3339
    tmp___0 = prologProcessor___0(parser, start, end, endPtr);
    }
#line 3339
    return (tmp___0);
  }
#line 3341
  return (result);
}
}
#line 3347 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlparse.c"
static enum XML_Error doIgnoreSection___0(XML_Parser parser , ENCODING const   *enc ,
                                          char const   **startPtr , char const   *end ,
                                          char const   **nextPtr , XML_Bool haveMore ) 
{ 
  char const   *next ;
  int tok ;
  char const   *s ;
  char const   **eventPP ;
  char const   **eventEndPP ;

  {
#line 3357
  s = *startPtr;
#line 3360
  if ((unsigned long )enc == (unsigned long )parser->m_encoding) {
#line 3361
    eventPP = & parser->m_eventPtr;
#line 3362
    *eventPP = s;
#line 3363
    eventEndPP = & parser->m_eventEndPtr;
  } else {
#line 3366
    eventPP = & (parser->m_openInternalEntities)->internalEventPtr;
#line 3367
    eventEndPP = & (parser->m_openInternalEntities)->internalEventEndPtr;
  }
  {
#line 3369
  *eventPP = s;
#line 3370
  *startPtr = (char const   *)((void *)0);
#line 3371
  tok = (*(enc->scanners[3]))(enc, s, end, & next);
#line 3372
  *eventEndPP = next;
  }
  {
#line 3374
  if (tok == 42) {
#line 3374
    goto case_42;
  }
#line 3383
  if (tok == 0) {
#line 3383
    goto case_0;
  }
#line 3386
  if (tok == -2) {
#line 3386
    goto case_neg_2;
  }
#line 3393
  if (tok == -4) {
#line 3393
    goto case_neg_4;
  }
#line 3393
  if (tok == -1) {
#line 3393
    goto case_neg_4;
  }
#line 3399
  goto switch_default;
  case_42: /* CIL Label */ 
#line 3375
  if (parser->m_defaultHandler) {
    {
#line 3376
    reportDefault___0(parser, enc, s, next);
    }
  }
#line 3377
  *startPtr = next;
#line 3378
  *nextPtr = next;
#line 3379
  if ((unsigned int )parser->m_parsingStatus.parsing == 2U) {
#line 3380
    return ((enum XML_Error )35);
  } else {
#line 3382
    return ((enum XML_Error )0);
  }
  case_0: /* CIL Label */ 
#line 3384
  *eventPP = next;
#line 3385
  return ((enum XML_Error )4);
  case_neg_2: /* CIL Label */ 
#line 3387
  if (haveMore) {
#line 3388
    *nextPtr = s;
#line 3389
    return ((enum XML_Error )0);
  }
#line 3391
  return ((enum XML_Error )6);
  case_neg_4: /* CIL Label */ 
  case_neg_1: /* CIL Label */ 
#line 3394
  if (haveMore) {
#line 3395
    *nextPtr = s;
#line 3396
    return ((enum XML_Error )0);
  }
#line 3398
  return ((enum XML_Error )2);
  switch_default: /* CIL Label */ 
#line 3400
  *eventPP = next;
#line 3401
  return ((enum XML_Error )23);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 3408 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlparse.c"
static enum XML_Error initializeEncoding___0(XML_Parser parser ) 
{ 
  char const   *s ;
  int (*tmp)(INIT_ENCODING * , ENCODING const   ** , char const   *name ) ;
  int tmp___0 ;
  enum XML_Error tmp___1 ;

  {
#line 3430
  s = parser->m_protocolEncodingName;
#line 3432
  if (parser->m_ns) {
#line 3432
    tmp = & XmlInitEncodingNS;
  } else {
#line 3432
    tmp = & XmlInitEncoding;
  }
  {
#line 3432
  tmp___0 = (*tmp)(& parser->m_initEncoding, & parser->m_encoding, s);
  }
#line 3432
  if (tmp___0) {
#line 3433
    return ((enum XML_Error )0);
  }
  {
#line 3434
  tmp___1 = handleUnknownEncoding___0(parser, parser->m_protocolEncodingName);
  }
#line 3434
  return (tmp___1);
}
}
#line 3437 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlparse.c"
static enum XML_Error processXmlDecl___0(XML_Parser parser , int isGeneralTextEntity ,
                                         char const   *s , char const   *next ) 
{ 
  char const   *encodingName ;
  XML_Char const   *storedEncName ;
  ENCODING const   *newEncoding ;
  char const   *version ;
  char const   *versionend ;
  XML_Char const   *storedversion ;
  int standalone ;
  int (*tmp)(int isGeneralTextEntity , ENCODING const   *enc , char const   *ptr ,
             char const   *end , char const   **badPtr , char const   **versionPtr ,
             char const   **versionEndPtr , char const   **encodingNamePtr , ENCODING const   **namedEncodingPtr ,
             int *standalonePtr ) ;
  int tmp___0 ;
  int tmp___1 ;
  XML_Char *tmp___2 ;
  XML_Char *tmp___3 ;
  enum XML_Error result ;
  int tmp___4 ;
  XML_Char *tmp___5 ;

  {
#line 3441
  encodingName = (char const   *)((void *)0);
#line 3442
  storedEncName = (XML_Char const   *)((void *)0);
#line 3443
  newEncoding = (ENCODING const   *)((void *)0);
#line 3444
  version = (char const   *)((void *)0);
#line 3446
  storedversion = (XML_Char const   *)((void *)0);
#line 3447
  standalone = -1;
#line 3448
  if (parser->m_ns) {
#line 3448
    tmp = & XmlParseXmlDeclNS;
  } else {
#line 3448
    tmp = & XmlParseXmlDecl;
  }
  {
#line 3448
  tmp___0 = (*tmp)(isGeneralTextEntity, parser->m_encoding, s, next, & parser->m_eventPtr,
                   & version, & versionend, & encodingName, & newEncoding, & standalone);
  }
#line 3448
  if (! tmp___0) {
#line 3460
    if (isGeneralTextEntity) {
#line 3461
      return ((enum XML_Error )31);
    } else {
#line 3463
      return ((enum XML_Error )30);
    }
  }
#line 3465
  if (! isGeneralTextEntity) {
#line 3465
    if (standalone == 1) {
#line 3466
      (parser->m_dtd)->standalone = (XML_Bool )1;
#line 3468
      if ((unsigned int )parser->m_paramEntityParsing == 1U) {
#line 3469
        parser->m_paramEntityParsing = (enum XML_ParamEntityParsing )0;
      }
    }
  }
#line 3472
  if (parser->m_xmlDeclHandler) {
#line 3473
    if ((unsigned long )encodingName != (unsigned long )((void *)0)) {
      {
#line 3474
      tmp___1 = (*((parser->m_encoding)->nameLength))(parser->m_encoding, encodingName);
#line 3474
      tmp___2 = poolStoreString___0(& parser->m_temp2Pool, parser->m_encoding, encodingName,
                                    encodingName + tmp___1);
#line 3474
      storedEncName = (XML_Char const   *)tmp___2;
      }
#line 3479
      if (! storedEncName) {
#line 3480
        return ((enum XML_Error )1);
      }
#line 3481
      parser->m_temp2Pool.start = parser->m_temp2Pool.ptr;
    }
#line 3483
    if (version) {
      {
#line 3484
      tmp___3 = poolStoreString___0(& parser->m_temp2Pool, parser->m_encoding, version,
                                    versionend - (parser->m_encoding)->minBytesPerChar);
#line 3484
      storedversion = (XML_Char const   *)tmp___3;
      }
#line 3488
      if (! storedversion) {
#line 3489
        return ((enum XML_Error )1);
      }
    }
    {
#line 3491
    (*(parser->m_xmlDeclHandler))(parser->m_handlerArg, storedversion, storedEncName,
                                  standalone);
    }
  } else
#line 3493
  if (parser->m_defaultHandler) {
    {
#line 3494
    reportDefault___0(parser, parser->m_encoding, s, next);
    }
  }
#line 3495
  if ((unsigned long )parser->m_protocolEncodingName == (unsigned long )((void *)0)) {
#line 3496
    if (newEncoding) {
#line 3497
      if (newEncoding->minBytesPerChar != (parser->m_encoding)->minBytesPerChar) {
#line 3498
        parser->m_eventPtr = encodingName;
#line 3499
        return ((enum XML_Error )19);
      }
#line 3501
      parser->m_encoding = newEncoding;
    } else
#line 3503
    if (encodingName) {
#line 3505
      if (! storedEncName) {
        {
#line 3506
        tmp___4 = (*((parser->m_encoding)->nameLength))(parser->m_encoding, encodingName);
#line 3506
        tmp___5 = poolStoreString___0(& parser->m_temp2Pool, parser->m_encoding, encodingName,
                                      encodingName + tmp___4);
#line 3506
        storedEncName = (XML_Char const   *)tmp___5;
        }
#line 3509
        if (! storedEncName) {
#line 3510
          return ((enum XML_Error )1);
        }
      }
      {
#line 3512
      result = handleUnknownEncoding___0(parser, storedEncName);
#line 3513
      poolClear___0(& parser->m_temp2Pool);
      }
#line 3514
      if ((unsigned int )result == 18U) {
#line 3515
        parser->m_eventPtr = encodingName;
      }
#line 3516
      return (result);
    }
  }
#line 3520
  if (storedEncName) {
    {
#line 3521
    poolClear___0(& parser->m_temp2Pool);
    }
  } else
#line 3520
  if (storedversion) {
    {
#line 3521
    poolClear___0(& parser->m_temp2Pool);
    }
  }
#line 3523
  return ((enum XML_Error )0);
}
}
#line 3526 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlparse.c"
static enum XML_Error handleUnknownEncoding___0(XML_Parser parser , XML_Char const   *encodingName ) 
{ 
  XML_Encoding info ;
  int i ;
  ENCODING *enc ;
  int tmp ;
  ENCODING *(*tmp___0)(void *mem , int *table , int (*convert)(void *userData , char const   *p ) ,
                       void *userData ) ;
  int tmp___1 ;

  {
#line 3529
  if (parser->m_unknownEncodingHandler) {
#line 3532
    i = 0;
    {
#line 3532
    while (1) {
      while_continue: /* CIL Label */ ;
#line 3532
      if (! (i < 256)) {
#line 3532
        goto while_break;
      }
#line 3533
      info.map[i] = -1;
#line 3532
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 3534
    info.convert = (int (*)(void *data , char const   *s ))((void *)0);
#line 3535
    info.data = (void *)0;
#line 3536
    info.release = (void (*)(void *data ))((void *)0);
#line 3537
    tmp___1 = (*(parser->m_unknownEncodingHandler))(parser->m_unknownEncodingHandlerData,
                                                    encodingName, & info);
    }
#line 3537
    if (tmp___1) {
      {
#line 3540
      tmp = XmlSizeOfUnknownEncoding();
#line 3540
      parser->m_unknownEncodingMem = (*(parser->m_mem.malloc_fcn))((size_t )tmp);
      }
#line 3541
      if (! parser->m_unknownEncodingMem) {
#line 3542
        if (info.release) {
          {
#line 3543
          (*(info.release))(info.data);
          }
        }
#line 3544
        return ((enum XML_Error )1);
      }
#line 3546
      if (parser->m_ns) {
#line 3546
        tmp___0 = & XmlInitUnknownEncodingNS;
      } else {
#line 3546
        tmp___0 = & XmlInitUnknownEncoding;
      }
      {
#line 3546
      enc = (*tmp___0)(parser->m_unknownEncodingMem, info.map, info.convert, info.data);
      }
#line 3552
      if (enc) {
#line 3553
        parser->m_unknownEncodingData = info.data;
#line 3554
        parser->m_unknownEncodingRelease = info.release;
#line 3555
        parser->m_encoding = (ENCODING const   *)enc;
#line 3556
        return ((enum XML_Error )0);
      }
    }
#line 3559
    if ((unsigned long )info.release != (unsigned long )((void *)0)) {
      {
#line 3560
      (*(info.release))(info.data);
      }
    }
  }
#line 3562
  return ((enum XML_Error )18);
}
}
#line 3565 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlparse.c"
static enum XML_Error prologInitProcessor___0(XML_Parser parser , char const   *s ,
                                              char const   *end , char const   **nextPtr ) 
{ 
  enum XML_Error result ;
  enum XML_Error tmp ;
  enum XML_Error tmp___0 ;

  {
  {
#line 3571
  tmp = initializeEncoding___0(parser);
#line 3571
  result = tmp;
  }
#line 3572
  if ((unsigned int )result != 0U) {
#line 3573
    return (result);
  }
  {
#line 3574
  parser->m_processor = & prologProcessor___0;
#line 3575
  tmp___0 = prologProcessor___0(parser, s, end, nextPtr);
  }
#line 3575
  return (tmp___0);
}
}
#line 3580 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlparse.c"
static enum XML_Error externalParEntInitProcessor___0(XML_Parser parser , char const   *s ,
                                                      char const   *end , char const   **nextPtr ) 
{ 
  enum XML_Error result ;
  enum XML_Error tmp ;
  enum XML_Error tmp___0 ;
  enum XML_Error tmp___1 ;

  {
  {
#line 3586
  tmp = initializeEncoding___0(parser);
#line 3586
  result = tmp;
  }
#line 3587
  if ((unsigned int )result != 0U) {
#line 3588
    return (result);
  }
#line 3592
  (parser->m_dtd)->paramEntityRead = (XML_Bool )1;
#line 3594
  if (parser->m_prologState.inEntityValue) {
    {
#line 3595
    parser->m_processor = & entityValueInitProcessor___0;
#line 3596
    tmp___0 = entityValueInitProcessor___0(parser, s, end, nextPtr);
    }
#line 3596
    return (tmp___0);
  } else {
    {
#line 3599
    parser->m_processor = & externalParEntProcessor___0;
#line 3600
    tmp___1 = externalParEntProcessor___0(parser, s, end, nextPtr);
    }
#line 3600
    return (tmp___1);
  }
}
}
#line 3604 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlparse.c"
static enum XML_Error entityValueInitProcessor___0(XML_Parser parser , char const   *s ,
                                                   char const   *end , char const   **nextPtr ) 
{ 
  int tok ;
  char const   *start ;
  char const   *next ;
  enum XML_Error tmp ;
  enum XML_Error result ;
  enum XML_Error tmp___0 ;

  {
#line 3611
  start = s;
#line 3612
  next = start;
#line 3613
  parser->m_eventPtr = start;
  {
#line 3615
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 3616
    tok = (*((parser->m_encoding)->scanners[0]))(parser->m_encoding, start, end, & next);
#line 3617
    parser->m_eventEndPtr = next;
    }
#line 3618
    if (tok <= 0) {
#line 3619
      if (! parser->m_parsingStatus.finalBuffer) {
#line 3619
        if (tok != 0) {
#line 3620
          *nextPtr = s;
#line 3621
          return ((enum XML_Error )0);
        }
      }
      {
#line 3624
      if (tok == 0) {
#line 3624
        goto case_0;
      }
#line 3626
      if (tok == -1) {
#line 3626
        goto case_neg_1;
      }
#line 3628
      if (tok == -2) {
#line 3628
        goto case_neg_2;
      }
#line 3631
      goto switch_default;
      case_0: /* CIL Label */ 
#line 3625
      return ((enum XML_Error )4);
      case_neg_1: /* CIL Label */ 
#line 3627
      return ((enum XML_Error )5);
      case_neg_2: /* CIL Label */ 
#line 3629
      return ((enum XML_Error )6);
      switch_default: /* CIL Label */ 
#line 3632
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
      {
#line 3635
      tmp = storeEntityValue___0(parser, parser->m_encoding, s, end);
      }
#line 3635
      return (tmp);
    } else
#line 3637
    if (tok == 12) {
      {
#line 3639
      result = processXmlDecl___0(parser, 0, start, next);
      }
#line 3640
      if ((unsigned int )result != 0U) {
#line 3641
        return (result);
      }
      {
#line 3643
      if ((unsigned int )parser->m_parsingStatus.parsing == 3U) {
#line 3643
        goto case_3;
      }
#line 3646
      if ((unsigned int )parser->m_parsingStatus.parsing == 2U) {
#line 3646
        goto case_2;
      }
#line 3648
      goto switch_default___0;
      case_3: /* CIL Label */ 
#line 3644
      *nextPtr = next;
#line 3645
      return ((enum XML_Error )0);
      case_2: /* CIL Label */ 
#line 3647
      return ((enum XML_Error )35);
      switch_default___0: /* CIL Label */ 
#line 3649
      *nextPtr = next;
      switch_break___0: /* CIL Label */ ;
      }
      {
#line 3652
      parser->m_processor = & entityValueProcessor___0;
#line 3653
      tmp___0 = entityValueProcessor___0(parser, next, end, nextPtr);
      }
#line 3653
      return (tmp___0);
    } else
#line 3662
    if (tok == 14) {
#line 3662
      if ((unsigned long )next == (unsigned long )end) {
#line 3662
        if (! parser->m_parsingStatus.finalBuffer) {
#line 3663
          *nextPtr = next;
#line 3664
          return ((enum XML_Error )0);
        }
      }
    }
#line 3666
    start = next;
#line 3667
    parser->m_eventPtr = start;
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 3671 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlparse.c"
static enum XML_Error externalParEntProcessor___0(XML_Parser parser , char const   *s ,
                                                  char const   *end , char const   **nextPtr ) 
{ 
  char const   *next ;
  int tok ;
  enum XML_Error tmp ;

  {
  {
#line 3677
  next = s;
#line 3680
  tok = (*((parser->m_encoding)->scanners[0]))(parser->m_encoding, s, end, & next);
  }
#line 3681
  if (tok <= 0) {
#line 3682
    if (! parser->m_parsingStatus.finalBuffer) {
#line 3682
      if (tok != 0) {
#line 3683
        *nextPtr = s;
#line 3684
        return ((enum XML_Error )0);
      }
    }
    {
#line 3687
    if (tok == 0) {
#line 3687
      goto case_0;
    }
#line 3689
    if (tok == -1) {
#line 3689
      goto case_neg_1;
    }
#line 3691
    if (tok == -2) {
#line 3691
      goto case_neg_2;
    }
#line 3694
    goto switch_default;
    case_0: /* CIL Label */ 
#line 3688
    return ((enum XML_Error )4);
    case_neg_1: /* CIL Label */ 
#line 3690
    return ((enum XML_Error )5);
    case_neg_2: /* CIL Label */ 
#line 3692
    return ((enum XML_Error )6);
    switch_default: /* CIL Label */ 
#line 3695
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  } else
#line 3702
  if (tok == 14) {
    {
#line 3703
    s = next;
#line 3704
    tok = (*((parser->m_encoding)->scanners[0]))(parser->m_encoding, s, end, & next);
    }
  }
  {
#line 3707
  parser->m_processor = & prologProcessor___0;
#line 3708
  tmp = doProlog___0(parser, parser->m_encoding, s, end, tok, next, nextPtr, (XML_Bool )(! parser->m_parsingStatus.finalBuffer));
  }
#line 3708
  return (tmp);
}
}
#line 3712 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlparse.c"
static enum XML_Error entityValueProcessor___0(XML_Parser parser , char const   *s ,
                                               char const   *end , char const   **nextPtr ) 
{ 
  char const   *start ;
  char const   *next ;
  ENCODING const   *enc ;
  int tok ;
  enum XML_Error tmp ;

  {
#line 3718
  start = s;
#line 3719
  next = s;
#line 3720
  enc = parser->m_encoding;
  {
#line 3723
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 3724
    tok = (*(enc->scanners[0]))(enc, start, end, & next);
    }
#line 3725
    if (tok <= 0) {
#line 3726
      if (! parser->m_parsingStatus.finalBuffer) {
#line 3726
        if (tok != 0) {
#line 3727
          *nextPtr = s;
#line 3728
          return ((enum XML_Error )0);
        }
      }
      {
#line 3731
      if (tok == 0) {
#line 3731
        goto case_0;
      }
#line 3733
      if (tok == -1) {
#line 3733
        goto case_neg_1;
      }
#line 3735
      if (tok == -2) {
#line 3735
        goto case_neg_2;
      }
#line 3738
      goto switch_default;
      case_0: /* CIL Label */ 
#line 3732
      return ((enum XML_Error )4);
      case_neg_1: /* CIL Label */ 
#line 3734
      return ((enum XML_Error )5);
      case_neg_2: /* CIL Label */ 
#line 3736
      return ((enum XML_Error )6);
      switch_default: /* CIL Label */ 
#line 3739
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
      {
#line 3742
      tmp = storeEntityValue___0(parser, enc, s, end);
      }
#line 3742
      return (tmp);
    }
#line 3744
    start = next;
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 3750 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlparse.c"
static enum XML_Error prologProcessor___0(XML_Parser parser , char const   *s , char const   *end ,
                                          char const   **nextPtr ) 
{ 
  char const   *next ;
  int tok ;
  int tmp ;
  enum XML_Error tmp___0 ;

  {
  {
#line 3756
  next = s;
#line 3757
  tmp = (*((parser->m_encoding)->scanners[0]))(parser->m_encoding, s, end, & next);
#line 3757
  tok = tmp;
#line 3758
  tmp___0 = doProlog___0(parser, parser->m_encoding, s, end, tok, next, nextPtr, (XML_Bool )(! parser->m_parsingStatus.finalBuffer));
  }
#line 3758
  return (tmp___0);
}
}
#line 3773 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlparse.c"
static XML_Char const   externalSubsetName___0[2]  = {      (XML_Char const   )35,      (XML_Char const   )'\000'};
#line 3775 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlparse.c"
static XML_Char const   atypeCDATA___0[6]  = {      (XML_Char const   )67,      (XML_Char const   )68,      (XML_Char const   )65,      (XML_Char const   )84, 
        (XML_Char const   )65,      (XML_Char const   )'\000'};
#line 3777 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlparse.c"
static XML_Char const   atypeID___0[3]  = {      (XML_Char const   )73,      (XML_Char const   )68,      (XML_Char const   )'\000'};
#line 3778 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlparse.c"
static XML_Char const   atypeIDREF___0[6]  = {      (XML_Char const   )73,      (XML_Char const   )68,      (XML_Char const   )82,      (XML_Char const   )69, 
        (XML_Char const   )70,      (XML_Char const   )'\000'};
#line 3780 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlparse.c"
static XML_Char const   atypeIDREFS___0[7]  = {      (XML_Char const   )73,      (XML_Char const   )68,      (XML_Char const   )82,      (XML_Char const   )69, 
        (XML_Char const   )70,      (XML_Char const   )83,      (XML_Char const   )'\000'};
#line 3782 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlparse.c"
static XML_Char const   atypeENTITY___0[7]  = {      (XML_Char const   )69,      (XML_Char const   )78,      (XML_Char const   )84,      (XML_Char const   )73, 
        (XML_Char const   )84,      (XML_Char const   )89,      (XML_Char const   )'\000'};
#line 3784 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlparse.c"
static XML_Char const   atypeENTITIES___0[9]  = 
#line 3784
  {      (XML_Char const   )69,      (XML_Char const   )78,      (XML_Char const   )84,      (XML_Char const   )73, 
        (XML_Char const   )84,      (XML_Char const   )73,      (XML_Char const   )69,      (XML_Char const   )83, 
        (XML_Char const   )'\000'};
#line 3786 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlparse.c"
static XML_Char const   atypeNMTOKEN___0[8]  = 
#line 3786
  {      (XML_Char const   )78,      (XML_Char const   )77,      (XML_Char const   )84,      (XML_Char const   )79, 
        (XML_Char const   )75,      (XML_Char const   )69,      (XML_Char const   )78,      (XML_Char const   )'\000'};
#line 3788 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlparse.c"
static XML_Char const   atypeNMTOKENS___0[9]  = 
#line 3788
  {      (XML_Char const   )78,      (XML_Char const   )77,      (XML_Char const   )84,      (XML_Char const   )79, 
        (XML_Char const   )75,      (XML_Char const   )69,      (XML_Char const   )78,      (XML_Char const   )83, 
        (XML_Char const   )'\000'};
#line 3790 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlparse.c"
static XML_Char const   notationPrefix___0[10]  = 
#line 3790
  {      (XML_Char const   )78,      (XML_Char const   )79,      (XML_Char const   )84,      (XML_Char const   )65, 
        (XML_Char const   )84,      (XML_Char const   )73,      (XML_Char const   )79,      (XML_Char const   )78, 
        (XML_Char const   )40,      (XML_Char const   )'\000'};
#line 3792 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlparse.c"
static XML_Char const   enumValueSep___0[2]  = {      (XML_Char const   )124,      (XML_Char const   )'\000'};
#line 3793 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlparse.c"
static XML_Char const   enumValueStart___0[2]  = {      (XML_Char const   )40,      (XML_Char const   )'\000'};
#line 3762 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlparse.c"
static enum XML_Error doProlog___0(XML_Parser parser , ENCODING const   *enc , char const   *s ,
                                   char const   *end , int tok , char const   *next ,
                                   char const   **nextPtr , XML_Bool haveMore ) 
{ 
  DTD *dtd ;
  char const   **eventPP ;
  char const   **eventEndPP ;
  enum XML_Content_Quant quant ;
  int role ;
  XML_Bool handleDefault ;
  int tmp ;
  enum XML_Error result ;
  enum XML_Error tmp___0 ;
  XML_Char *tmp___1 ;
  enum XML_Error result___0 ;
  enum XML_Error tmp___2 ;
  NAMED *tmp___3 ;
  XML_Char *pubId ;
  int tmp___4 ;
  int tmp___5 ;
  XML_Char *tem ;
  XML_Char *tmp___6 ;
  XML_Bool hadParamEntityRefs ;
  ENTITY *entity ;
  NAMED *tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  XML_Bool hadParamEntityRefs___0 ;
  ENTITY *entity___0 ;
  NAMED *tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  enum XML_Error tmp___13 ;
  XML_Char const   *prefix ;
  XML_Char const   *tmp___14 ;
  XML_Char *tmp___15 ;
  int tmp___16 ;
  XML_Char *tmp___18 ;
  int tmp___19 ;
  XML_Bool tmp___20 ;
  XML_Char *tmp___22 ;
  int tmp___23 ;
  XML_Bool tmp___24 ;
  XML_Char const   *attVal ;
  enum XML_Error result___1 ;
  enum XML_Error tmp___25 ;
  int tmp___26 ;
  XML_Char *tmp___28 ;
  int tmp___29 ;
  XML_Bool tmp___30 ;
  XML_Char *tmp___32 ;
  int tmp___33 ;
  XML_Bool tmp___34 ;
  enum XML_Error result___2 ;
  enum XML_Error tmp___35 ;
  XML_Char *tmp___36 ;
  int tmp___37 ;
  NAMED *tmp___38 ;
  XML_Char *tmp___39 ;
  XML_Char *tmp___40 ;
  int tmp___41 ;
  XML_Char const   *name ;
  XML_Char *tmp___42 ;
  NAMED *tmp___43 ;
  int tmp___44 ;
  XML_Char const   *name___0 ;
  XML_Char *tmp___45 ;
  NAMED *tmp___46 ;
  int tmp___47 ;
  XML_Char *tmp___48 ;
  int tmp___49 ;
  XML_Char *tem___0 ;
  XML_Char *tmp___50 ;
  XML_Char const   *systemId ;
  XML_Char *tmp___51 ;
  enum XML_Error result___3 ;
  char *temp ;
  unsigned int tmp___52 ;
  void *tmp___53 ;
  int *temp___0 ;
  void *tmp___54 ;
  unsigned int tmp___55 ;
  void *tmp___56 ;
  int myindex ;
  int tmp___57 ;
  XML_Char const   *name___1 ;
  ENTITY *entity___1 ;
  XML_Char *tmp___58 ;
  NAMED *tmp___59 ;
  int tmp___60 ;
  enum XML_Error result___4 ;
  XML_Bool betweenDecl ;
  int tmp___61 ;
  int tmp___62 ;
  int tmp___63 ;
  XML_Content *content ;
  void *tmp___64 ;
  ELEMENT_TYPE *el ;
  XML_Char const   *name___2 ;
  int nameLen ;
  char const   *nxt ;
  char const   *tmp___65 ;
  int myindex___0 ;
  int tmp___66 ;
  int tmp___67 ;
  XML_Content *model ;
  XML_Content *tmp___68 ;
  int tmp___69 ;
  int tmp___70 ;

  {
#line 3796
  dtd = parser->m_dtd;
#line 3802
  if ((unsigned long )enc == (unsigned long )parser->m_encoding) {
#line 3803
    eventPP = & parser->m_eventPtr;
#line 3804
    eventEndPP = & parser->m_eventEndPtr;
  } else {
#line 3807
    eventPP = & (parser->m_openInternalEntities)->internalEventPtr;
#line 3808
    eventEndPP = & (parser->m_openInternalEntities)->internalEventEndPtr;
  }
  {
#line 3811
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3813
    handleDefault = (XML_Bool )1;
#line 3814
    *eventPP = s;
#line 3815
    *eventEndPP = next;
#line 3816
    if (tok <= 0) {
#line 3817
      if (haveMore) {
#line 3817
        if (tok != 0) {
#line 3818
          *nextPtr = s;
#line 3819
          return ((enum XML_Error )0);
        }
      }
      {
#line 3822
      if (tok == 0) {
#line 3822
        goto case_0;
      }
#line 3825
      if (tok == -1) {
#line 3825
        goto case_neg_1;
      }
#line 3827
      if (tok == -2) {
#line 3827
        goto case_neg_2;
      }
#line 3829
      if (tok == -15) {
#line 3829
        goto case_neg_15;
      }
#line 3832
      if (tok == -4) {
#line 3832
        goto case_neg_4;
      }
#line 3852
      goto switch_default;
      case_0: /* CIL Label */ 
#line 3823
      *eventPP = next;
#line 3824
      return ((enum XML_Error )4);
      case_neg_1: /* CIL Label */ 
#line 3826
      return ((enum XML_Error )5);
      case_neg_2: /* CIL Label */ 
#line 3828
      return ((enum XML_Error )6);
      case_neg_15: /* CIL Label */ 
#line 3830
      tok = - tok;
#line 3831
      goto switch_break;
      case_neg_4: /* CIL Label */ 
#line 3835
      if ((unsigned long )enc != (unsigned long )parser->m_encoding) {
#line 3835
        if (! (parser->m_openInternalEntities)->betweenDecl) {
#line 3836
          *nextPtr = s;
#line 3837
          return ((enum XML_Error )0);
        }
      }
#line 3843
      if (parser->m_isParamEntity) {
#line 3843
        goto _L;
      } else
#line 3843
      if ((unsigned long )enc != (unsigned long )parser->m_encoding) {
        _L: /* CIL Label */ 
        {
#line 3844
        tmp = (*(parser->m_prologState.handler))(& parser->m_prologState, -4, end,
                                                 end, enc);
        }
#line 3844
        if (tmp == -1) {
#line 3846
          return ((enum XML_Error )29);
        }
#line 3847
        *nextPtr = s;
#line 3848
        return ((enum XML_Error )0);
      }
#line 3851
      return ((enum XML_Error )3);
      switch_default: /* CIL Label */ 
#line 3853
      tok = - tok;
#line 3854
      next = end;
#line 3855
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    }
    {
#line 3858
    role = (*(parser->m_prologState.handler))(& parser->m_prologState, tok, s, next,
                                              enc);
    }
    {
#line 3860
    if (role == 1) {
#line 3860
      goto case_1;
    }
#line 3869
    if (role == 4) {
#line 3869
      goto case_4;
    }
#line 3880
    if (role == 7) {
#line 3880
      goto case_7;
    }
#line 3890
    if (role == 57) {
#line 3890
      goto case_57;
    }
#line 3900
    if (role == 6) {
#line 3900
      goto case_6;
    }
#line 3927
    if (role == 14) {
#line 3927
      goto case_14;
    }
#line 3945
    if (role == 8) {
#line 3945
      goto case_8;
    }
#line 3997
    if (role == 2) {
#line 3997
      goto case_2;
    }
#line 4036
    if (role == 34) {
#line 4036
      goto case_34;
    }
#line 4041
    if (role == 22) {
#line 4041
      goto case_22;
    }
#line 4049
    if (role == 23) {
#line 4049
      goto case_23;
    }
#line 4053
    if (role == 24) {
#line 4053
      goto case_24;
    }
#line 4057
    if (role == 25) {
#line 4057
      goto case_25;
    }
#line 4060
    if (role == 26) {
#line 4060
      goto case_26;
    }
#line 4063
    if (role == 27) {
#line 4063
      goto case_27;
    }
#line 4066
    if (role == 28) {
#line 4066
      goto case_28;
    }
#line 4069
    if (role == 29) {
#line 4069
      goto case_29;
    }
#line 4072
    if (role == 30) {
#line 4072
      goto case_30;
    }
#line 4079
    if (role == 32) {
#line 4079
      goto case_32;
    }
#line 4079
    if (role == 31) {
#line 4079
      goto case_32;
    }
#line 4099
    if (role == 36) {
#line 4099
      goto case_36;
    }
#line 4099
    if (role == 35) {
#line 4099
      goto case_36;
    }
#line 4126
    if (role == 38) {
#line 4126
      goto case_38;
    }
#line 4126
    if (role == 37) {
#line 4126
      goto case_38;
    }
#line 4163
    if (role == 12) {
#line 4163
      goto case_12;
    }
#line 4189
    if (role == 5) {
#line 4189
      goto case_5;
    }
#line 4230
    if (role == 13) {
#line 4230
      goto case_13;
    }
#line 4243
    if (role == 15) {
#line 4243
      goto case_15;
    }
#line 4257
    if (role == 16) {
#line 4257
      goto case_16;
    }
#line 4286
    if (role == 9) {
#line 4286
      goto case_9;
    }
#line 4322
    if (role == 10) {
#line 4322
      goto case_10;
    }
#line 4356
    if (role == 18) {
#line 4356
      goto case_18;
    }
#line 4367
    if (role == 21) {
#line 4367
      goto case_21;
    }
#line 4383
    if (role == 19) {
#line 4383
      goto case_19;
    }
#line 4401
    if (role == 20) {
#line 4401
      goto case_20;
    }
#line 4413
    if (role == -1) {
#line 4413
      goto case_neg_1___0;
    }
#line 4425
    if (role == 58) {
#line 4425
      goto case_58;
    }
#line 4441
    if (role == 44) {
#line 4441
      goto case_44;
    }
#line 4474
    if (role == 50) {
#line 4474
      goto case_50;
    }
#line 4481
    if (role == 49) {
#line 4481
      goto case_49;
    }
#line 4498
    if (role == 59) {
#line 4498
      goto case_59;
    }
#line 4498
    if (role == 60) {
#line 4498
      goto case_59;
    }
#line 4578
    if (role == 40) {
#line 4578
      goto case_40;
    }
#line 4591
    if (role == 42) {
#line 4591
      goto case_42;
    }
#line 4591
    if (role == 41) {
#line 4591
      goto case_42;
    }
#line 4612
    if (role == 43) {
#line 4612
      goto case_43;
    }
#line 4621
    if (role == 51) {
#line 4621
      goto case_51;
    }
#line 4624
    if (role == 53) {
#line 4624
      goto case_53;
    }
#line 4627
    if (role == 52) {
#line 4627
      goto case_52;
    }
#line 4630
    if (role == 54) {
#line 4630
      goto case_54;
    }
#line 4658
    if (role == 45) {
#line 4658
      goto case_45;
    }
#line 4661
    if (role == 47) {
#line 4661
      goto case_47;
    }
#line 4664
    if (role == 46) {
#line 4664
      goto case_46;
    }
#line 4667
    if (role == 48) {
#line 4667
      goto case_48;
    }
#line 4690
    if (role == 55) {
#line 4690
      goto case_55;
    }
#line 4695
    if (role == 56) {
#line 4695
      goto case_56;
    }
#line 4700
    if (role == 0) {
#line 4700
      goto case_0___0;
    }
#line 4707
    if (role == 3) {
#line 4707
      goto case_3;
    }
#line 4711
    if (role == 11) {
#line 4711
      goto case_11;
    }
#line 4715
    if (role == 17) {
#line 4715
      goto case_17;
    }
#line 4719
    if (role == 33) {
#line 4719
      goto case_33;
    }
#line 4723
    if (role == 39) {
#line 4723
      goto case_39;
    }
#line 3859
    goto switch_break___0;
    case_1: /* CIL Label */ 
    {
#line 3862
    tmp___0 = processXmlDecl___0(parser, 0, s, next);
#line 3862
    result = tmp___0;
    }
#line 3863
    if ((unsigned int )result != 0U) {
#line 3864
      return (result);
    }
#line 3865
    enc = parser->m_encoding;
#line 3866
    handleDefault = (XML_Bool )0;
#line 3868
    goto switch_break___0;
    case_4: /* CIL Label */ 
#line 3870
    if (parser->m_startDoctypeDeclHandler) {
      {
#line 3871
      tmp___1 = poolStoreString___0(& parser->m_tempPool, enc, s, next);
#line 3871
      parser->m_doctypeName = (XML_Char const   *)tmp___1;
      }
#line 3872
      if (! parser->m_doctypeName) {
#line 3873
        return ((enum XML_Error )1);
      }
#line 3874
      parser->m_tempPool.start = parser->m_tempPool.ptr;
#line 3875
      parser->m_doctypePubid = (XML_Char const   *)((void *)0);
#line 3876
      handleDefault = (XML_Bool )0;
    }
#line 3878
    parser->m_doctypeSysid = (XML_Char const   *)((void *)0);
#line 3879
    goto switch_break___0;
    case_7: /* CIL Label */ 
#line 3881
    if (parser->m_startDoctypeDeclHandler) {
      {
#line 3882
      (*(parser->m_startDoctypeDeclHandler))(parser->m_handlerArg, parser->m_doctypeName,
                                             parser->m_doctypeSysid, parser->m_doctypePubid,
                                             1);
#line 3884
      parser->m_doctypeName = (XML_Char const   *)((void *)0);
#line 3885
      poolClear___0(& parser->m_tempPool);
#line 3886
      handleDefault = (XML_Bool )0;
      }
    }
#line 3888
    goto switch_break___0;
    case_57: /* CIL Label */ 
    {
#line 3892
    tmp___2 = processXmlDecl___0(parser, 1, s, next);
#line 3892
    result___0 = tmp___2;
    }
#line 3893
    if ((unsigned int )result___0 != 0U) {
#line 3894
      return (result___0);
    }
#line 3895
    enc = parser->m_encoding;
#line 3896
    handleDefault = (XML_Bool )0;
#line 3898
    goto switch_break___0;
    case_6: /* CIL Label */ 
    {
#line 3902
    parser->m_useForeignDTD = (XML_Bool )0;
#line 3903
    tmp___3 = lookup___0(parser, & dtd->paramEntities, externalSubsetName___0, sizeof(ENTITY ));
#line 3903
    parser->m_declEntity = (ENTITY *)tmp___3;
    }
#line 3907
    if (! parser->m_declEntity) {
#line 3908
      return ((enum XML_Error )1);
    }
#line 3910
    dtd->hasParamEntityRefs = (XML_Bool )1;
#line 3911
    if (parser->m_startDoctypeDeclHandler) {
      {
#line 3913
      tmp___4 = (*(enc->isPublicId))(enc, s, next, eventPP);
      }
#line 3913
      if (! tmp___4) {
#line 3914
        return ((enum XML_Error )32);
      }
      {
#line 3915
      pubId = poolStoreString___0(& parser->m_tempPool, enc, s + enc->minBytesPerChar,
                                  next - enc->minBytesPerChar);
      }
#line 3918
      if (! pubId) {
#line 3919
        return ((enum XML_Error )1);
      }
      {
#line 3920
      normalizePublicId___0(pubId);
#line 3921
      parser->m_tempPool.start = parser->m_tempPool.ptr;
#line 3922
      parser->m_doctypePubid = (XML_Char const   *)pubId;
#line 3923
      handleDefault = (XML_Bool )0;
      }
#line 3924
      goto alreadyChecked;
    }
    case_14: /* CIL Label */ 
    {
#line 3928
    tmp___5 = (*(enc->isPublicId))(enc, s, next, eventPP);
    }
#line 3928
    if (! tmp___5) {
#line 3929
      return ((enum XML_Error )32);
    }
    alreadyChecked: 
#line 3931
    if (dtd->keepProcessing) {
#line 3931
      if (parser->m_declEntity) {
        {
#line 3932
        tmp___6 = poolStoreString___0(& dtd->pool, enc, s + enc->minBytesPerChar,
                                      next - enc->minBytesPerChar);
#line 3932
        tem = tmp___6;
        }
#line 3936
        if (! tem) {
#line 3937
          return ((enum XML_Error )1);
        }
        {
#line 3938
        normalizePublicId___0(tem);
#line 3939
        (parser->m_declEntity)->publicId = (XML_Char const   *)tem;
#line 3940
        dtd->pool.start = dtd->pool.ptr;
        }
#line 3941
        if (parser->m_entityDeclHandler) {
#line 3942
          handleDefault = (XML_Bool )0;
        }
      }
    }
#line 3944
    goto switch_break___0;
    case_8: /* CIL Label */ 
#line 3946
    if (parser->m_doctypeName) {
      {
#line 3947
      (*(parser->m_startDoctypeDeclHandler))(parser->m_handlerArg, parser->m_doctypeName,
                                             parser->m_doctypeSysid, parser->m_doctypePubid,
                                             0);
#line 3949
      poolClear___0(& parser->m_tempPool);
#line 3950
      handleDefault = (XML_Bool )0;
      }
    }
#line 3957
    if (parser->m_doctypeSysid) {
#line 3957
      goto _L___0;
    } else
#line 3957
    if (parser->m_useForeignDTD) {
      _L___0: /* CIL Label */ 
#line 3958
      hadParamEntityRefs = dtd->hasParamEntityRefs;
#line 3959
      dtd->hasParamEntityRefs = (XML_Bool )1;
#line 3960
      if (parser->m_paramEntityParsing) {
#line 3960
        if (parser->m_externalEntityRefHandler) {
          {
#line 3961
          tmp___7 = lookup___0(parser, & dtd->paramEntities, externalSubsetName___0,
                               sizeof(ENTITY ));
#line 3961
          entity = (ENTITY *)tmp___7;
          }
#line 3965
          if (! entity) {
#line 3966
            return ((enum XML_Error )1);
          }
#line 3967
          if (parser->m_useForeignDTD) {
#line 3968
            entity->base = parser->m_curBase;
          }
          {
#line 3969
          dtd->paramEntityRead = (XML_Bool )0;
#line 3970
          tmp___8 = (*(parser->m_externalEntityRefHandler))(parser->m_externalEntityRefHandlerArg,
                                                            (XML_Char const   *)0,
                                                            entity->base, entity->systemId,
                                                            entity->publicId);
          }
#line 3970
          if (! tmp___8) {
#line 3975
            return ((enum XML_Error )21);
          }
#line 3976
          if (dtd->paramEntityRead) {
#line 3977
            if (! dtd->standalone) {
#line 3977
              if (parser->m_notStandaloneHandler) {
                {
#line 3977
                tmp___9 = (*(parser->m_notStandaloneHandler))(parser->m_handlerArg);
                }
#line 3977
                if (! tmp___9) {
#line 3980
                  return ((enum XML_Error )22);
                }
              }
            }
          } else
#line 3985
          if (! parser->m_doctypeSysid) {
#line 3986
            dtd->hasParamEntityRefs = hadParamEntityRefs;
          }
        }
      }
#line 3989
      parser->m_useForeignDTD = (XML_Bool )0;
    }
#line 3992
    if (parser->m_endDoctypeDeclHandler) {
      {
#line 3993
      (*(parser->m_endDoctypeDeclHandler))(parser->m_handlerArg);
#line 3994
      handleDefault = (XML_Bool )0;
      }
    }
#line 3996
    goto switch_break___0;
    case_2: /* CIL Label */ 
#line 4002
    if (parser->m_useForeignDTD) {
#line 4003
      hadParamEntityRefs___0 = dtd->hasParamEntityRefs;
#line 4004
      dtd->hasParamEntityRefs = (XML_Bool )1;
#line 4005
      if (parser->m_paramEntityParsing) {
#line 4005
        if (parser->m_externalEntityRefHandler) {
          {
#line 4006
          tmp___10 = lookup___0(parser, & dtd->paramEntities, externalSubsetName___0,
                                sizeof(ENTITY ));
#line 4006
          entity___0 = (ENTITY *)tmp___10;
          }
#line 4009
          if (! entity___0) {
#line 4010
            return ((enum XML_Error )1);
          }
          {
#line 4011
          entity___0->base = parser->m_curBase;
#line 4012
          dtd->paramEntityRead = (XML_Bool )0;
#line 4013
          tmp___11 = (*(parser->m_externalEntityRefHandler))(parser->m_externalEntityRefHandlerArg,
                                                             (XML_Char const   *)0,
                                                             entity___0->base, entity___0->systemId,
                                                             entity___0->publicId);
          }
#line 4013
          if (! tmp___11) {
#line 4018
            return ((enum XML_Error )21);
          }
#line 4019
          if (dtd->paramEntityRead) {
#line 4020
            if (! dtd->standalone) {
#line 4020
              if (parser->m_notStandaloneHandler) {
                {
#line 4020
                tmp___12 = (*(parser->m_notStandaloneHandler))(parser->m_handlerArg);
                }
#line 4020
                if (! tmp___12) {
#line 4023
                  return ((enum XML_Error )22);
                }
              }
            }
          } else {
#line 4029
            dtd->hasParamEntityRefs = hadParamEntityRefs___0;
          }
        }
      }
    }
    {
#line 4034
    parser->m_processor = & contentProcessor___0;
#line 4035
    tmp___13 = contentProcessor___0(parser, s, end, nextPtr);
    }
#line 4035
    return (tmp___13);
    case_34: /* CIL Label */ 
    {
#line 4037
    parser->m_declElementType = getElementType___0(parser, enc, s, next);
    }
#line 4038
    if (! parser->m_declElementType) {
#line 4039
      return ((enum XML_Error )1);
    }
#line 4040
    goto checkAttListDeclHandler;
    case_22: /* CIL Label */ 
    {
#line 4042
    parser->m_declAttributeId = getAttributeId___0(parser, enc, s, next);
    }
#line 4043
    if (! parser->m_declAttributeId) {
#line 4044
      return ((enum XML_Error )1);
    }
#line 4045
    parser->m_declAttributeIsCdata = (XML_Bool )0;
#line 4046
    parser->m_declAttributeType = (XML_Char const   *)((void *)0);
#line 4047
    parser->m_declAttributeIsId = (XML_Bool )0;
#line 4048
    goto checkAttListDeclHandler;
    case_23: /* CIL Label */ 
#line 4050
    parser->m_declAttributeIsCdata = (XML_Bool )1;
#line 4051
    parser->m_declAttributeType = atypeCDATA___0;
#line 4052
    goto checkAttListDeclHandler;
    case_24: /* CIL Label */ 
#line 4054
    parser->m_declAttributeIsId = (XML_Bool )1;
#line 4055
    parser->m_declAttributeType = atypeID___0;
#line 4056
    goto checkAttListDeclHandler;
    case_25: /* CIL Label */ 
#line 4058
    parser->m_declAttributeType = atypeIDREF___0;
#line 4059
    goto checkAttListDeclHandler;
    case_26: /* CIL Label */ 
#line 4061
    parser->m_declAttributeType = atypeIDREFS___0;
#line 4062
    goto checkAttListDeclHandler;
    case_27: /* CIL Label */ 
#line 4064
    parser->m_declAttributeType = atypeENTITY___0;
#line 4065
    goto checkAttListDeclHandler;
    case_28: /* CIL Label */ 
#line 4067
    parser->m_declAttributeType = atypeENTITIES___0;
#line 4068
    goto checkAttListDeclHandler;
    case_29: /* CIL Label */ 
#line 4070
    parser->m_declAttributeType = atypeNMTOKEN___0;
#line 4071
    goto checkAttListDeclHandler;
    case_30: /* CIL Label */ 
#line 4073
    parser->m_declAttributeType = atypeNMTOKENS___0;
    checkAttListDeclHandler: 
#line 4075
    if (dtd->keepProcessing) {
#line 4075
      if (parser->m_attlistDeclHandler) {
#line 4076
        handleDefault = (XML_Bool )0;
      }
    }
#line 4077
    goto switch_break___0;
    case_32: /* CIL Label */ 
    case_31: /* CIL Label */ 
#line 4080
    if (dtd->keepProcessing) {
#line 4080
      if (parser->m_attlistDeclHandler) {
#line 4082
        if (parser->m_declAttributeType) {
#line 4083
          prefix = enumValueSep___0;
        } else
#line 4086
        if (role == 32) {
#line 4086
          prefix = notationPrefix___0;
        } else {
#line 4086
          prefix = enumValueStart___0;
        }
        {
#line 4090
        tmp___14 = poolAppendString___0(& parser->m_tempPool, prefix);
        }
#line 4090
        if (! tmp___14) {
#line 4091
          return ((enum XML_Error )1);
        }
        {
#line 4092
        tmp___15 = poolAppend___0(& parser->m_tempPool, enc, s, next);
        }
#line 4092
        if (! tmp___15) {
#line 4093
          return ((enum XML_Error )1);
        }
#line 4094
        parser->m_declAttributeType = (XML_Char const   *)parser->m_tempPool.start;
#line 4095
        handleDefault = (XML_Bool )0;
      }
    }
#line 4097
    goto switch_break___0;
    case_36: /* CIL Label */ 
    case_35: /* CIL Label */ 
#line 4100
    if (dtd->keepProcessing) {
      {
#line 4101
      tmp___16 = defineAttribute___0(parser->m_declElementType, parser->m_declAttributeId,
                                     parser->m_declAttributeIsCdata, parser->m_declAttributeIsId,
                                     (XML_Char const   *)0, parser);
      }
#line 4101
      if (! tmp___16) {
#line 4104
        return ((enum XML_Error )1);
      }
#line 4105
      if (parser->m_attlistDeclHandler) {
#line 4105
        if (parser->m_declAttributeType) {
#line 4106
          if ((int const   )*(parser->m_declAttributeType) == 40) {
#line 4106
            goto _L___1;
          } else
#line 4106
          if ((int const   )*(parser->m_declAttributeType) == 78) {
#line 4106
            if ((int const   )*(parser->m_declAttributeType + 1) == 79) {
              _L___1: /* CIL Label */ 
#line 4110
              if ((unsigned long )parser->m_tempPool.ptr == (unsigned long )parser->m_tempPool.end) {
                {
#line 4110
                tmp___20 = poolGrow___0(& parser->m_tempPool);
                }
#line 4110
                if (tmp___20) {
#line 4110
                  tmp___18 = parser->m_tempPool.ptr;
#line 4110
                  (parser->m_tempPool.ptr) ++;
#line 4110
                  *tmp___18 = (XML_Char )41;
#line 4110
                  tmp___19 = 1;
                } else {
#line 4110
                  tmp___19 = 0;
                }
              } else {
#line 4110
                tmp___18 = parser->m_tempPool.ptr;
#line 4110
                (parser->m_tempPool.ptr) ++;
#line 4110
                *tmp___18 = (XML_Char )41;
#line 4110
                tmp___19 = 1;
              }
#line 4110
              if (tmp___19) {
#line 4110
                if ((unsigned long )parser->m_tempPool.ptr == (unsigned long )parser->m_tempPool.end) {
                  {
#line 4110
                  tmp___24 = poolGrow___0(& parser->m_tempPool);
                  }
#line 4110
                  if (tmp___24) {
#line 4110
                    tmp___22 = parser->m_tempPool.ptr;
#line 4110
                    (parser->m_tempPool.ptr) ++;
#line 4110
                    *tmp___22 = (XML_Char )'\000';
#line 4110
                    tmp___23 = 1;
                  } else {
#line 4110
                    tmp___23 = 0;
                  }
                } else {
#line 4110
                  tmp___22 = parser->m_tempPool.ptr;
#line 4110
                  (parser->m_tempPool.ptr) ++;
#line 4110
                  *tmp___22 = (XML_Char )'\000';
#line 4110
                  tmp___23 = 1;
                }
#line 4110
                if (! tmp___23) {
#line 4112
                  return ((enum XML_Error )1);
                }
              } else {
#line 4112
                return ((enum XML_Error )1);
              }
#line 4113
              parser->m_declAttributeType = (XML_Char const   *)parser->m_tempPool.start;
#line 4114
              parser->m_tempPool.start = parser->m_tempPool.ptr;
            }
          }
          {
#line 4116
          *eventEndPP = s;
#line 4117
          (*(parser->m_attlistDeclHandler))(parser->m_handlerArg, (parser->m_declElementType)->name,
                                            (XML_Char const   *)(parser->m_declAttributeId)->name,
                                            parser->m_declAttributeType, (XML_Char const   *)0,
                                            role == 36);
#line 4120
          poolClear___0(& parser->m_tempPool);
#line 4121
          handleDefault = (XML_Bool )0;
          }
        }
      }
    }
#line 4124
    goto switch_break___0;
    case_38: /* CIL Label */ 
    case_37: /* CIL Label */ 
#line 4127
    if (dtd->keepProcessing) {
      {
#line 4129
      tmp___25 = storeAttributeValue___0(parser, enc, parser->m_declAttributeIsCdata,
                                         s + enc->minBytesPerChar, next - enc->minBytesPerChar,
                                         & dtd->pool);
#line 4129
      result___1 = tmp___25;
      }
#line 4134
      if (result___1) {
#line 4135
        return (result___1);
      }
      {
#line 4136
      attVal = (XML_Char const   *)dtd->pool.start;
#line 4137
      dtd->pool.start = dtd->pool.ptr;
#line 4139
      tmp___26 = defineAttribute___0(parser->m_declElementType, parser->m_declAttributeId,
                                     parser->m_declAttributeIsCdata, (XML_Bool )0,
                                     attVal, parser);
      }
#line 4139
      if (! tmp___26) {
#line 4141
        return ((enum XML_Error )1);
      }
#line 4142
      if (parser->m_attlistDeclHandler) {
#line 4142
        if (parser->m_declAttributeType) {
#line 4143
          if ((int const   )*(parser->m_declAttributeType) == 40) {
#line 4143
            goto _L___2;
          } else
#line 4143
          if ((int const   )*(parser->m_declAttributeType) == 78) {
#line 4143
            if ((int const   )*(parser->m_declAttributeType + 1) == 79) {
              _L___2: /* CIL Label */ 
#line 4147
              if ((unsigned long )parser->m_tempPool.ptr == (unsigned long )parser->m_tempPool.end) {
                {
#line 4147
                tmp___30 = poolGrow___0(& parser->m_tempPool);
                }
#line 4147
                if (tmp___30) {
#line 4147
                  tmp___28 = parser->m_tempPool.ptr;
#line 4147
                  (parser->m_tempPool.ptr) ++;
#line 4147
                  *tmp___28 = (XML_Char )41;
#line 4147
                  tmp___29 = 1;
                } else {
#line 4147
                  tmp___29 = 0;
                }
              } else {
#line 4147
                tmp___28 = parser->m_tempPool.ptr;
#line 4147
                (parser->m_tempPool.ptr) ++;
#line 4147
                *tmp___28 = (XML_Char )41;
#line 4147
                tmp___29 = 1;
              }
#line 4147
              if (tmp___29) {
#line 4147
                if ((unsigned long )parser->m_tempPool.ptr == (unsigned long )parser->m_tempPool.end) {
                  {
#line 4147
                  tmp___34 = poolGrow___0(& parser->m_tempPool);
                  }
#line 4147
                  if (tmp___34) {
#line 4147
                    tmp___32 = parser->m_tempPool.ptr;
#line 4147
                    (parser->m_tempPool.ptr) ++;
#line 4147
                    *tmp___32 = (XML_Char )'\000';
#line 4147
                    tmp___33 = 1;
                  } else {
#line 4147
                    tmp___33 = 0;
                  }
                } else {
#line 4147
                  tmp___32 = parser->m_tempPool.ptr;
#line 4147
                  (parser->m_tempPool.ptr) ++;
#line 4147
                  *tmp___32 = (XML_Char )'\000';
#line 4147
                  tmp___33 = 1;
                }
#line 4147
                if (! tmp___33) {
#line 4149
                  return ((enum XML_Error )1);
                }
              } else {
#line 4149
                return ((enum XML_Error )1);
              }
#line 4150
              parser->m_declAttributeType = (XML_Char const   *)parser->m_tempPool.start;
#line 4151
              parser->m_tempPool.start = parser->m_tempPool.ptr;
            }
          }
          {
#line 4153
          *eventEndPP = s;
#line 4154
          (*(parser->m_attlistDeclHandler))(parser->m_handlerArg, (parser->m_declElementType)->name,
                                            (XML_Char const   *)(parser->m_declAttributeId)->name,
                                            parser->m_declAttributeType, attVal, role == 38);
#line 4158
          poolClear___0(& parser->m_tempPool);
#line 4159
          handleDefault = (XML_Bool )0;
          }
        }
      }
    }
#line 4162
    goto switch_break___0;
    case_12: /* CIL Label */ 
#line 4164
    if (dtd->keepProcessing) {
      {
#line 4165
      tmp___35 = storeEntityValue___0(parser, enc, s + enc->minBytesPerChar, next - enc->minBytesPerChar);
#line 4165
      result___2 = tmp___35;
      }
#line 4168
      if (parser->m_declEntity) {
#line 4169
        (parser->m_declEntity)->textPtr = (XML_Char const   *)dtd->entityValuePool.start;
#line 4170
        (parser->m_declEntity)->textLen = (int )(dtd->entityValuePool.ptr - dtd->entityValuePool.start);
#line 4171
        dtd->entityValuePool.start = dtd->entityValuePool.ptr;
#line 4172
        if (parser->m_entityDeclHandler) {
          {
#line 4173
          *eventEndPP = s;
#line 4174
          (*(parser->m_entityDeclHandler))(parser->m_handlerArg, (parser->m_declEntity)->name,
                                           (int )(parser->m_declEntity)->is_param,
                                           (parser->m_declEntity)->textPtr, (parser->m_declEntity)->textLen,
                                           parser->m_curBase, (XML_Char const   *)0,
                                           (XML_Char const   *)0, (XML_Char const   *)0);
#line 4180
          handleDefault = (XML_Bool )0;
          }
        }
      } else {
#line 4184
        dtd->entityValuePool.ptr = dtd->entityValuePool.start;
      }
#line 4185
      if ((unsigned int )result___2 != 0U) {
#line 4186
        return (result___2);
      }
    }
#line 4188
    goto switch_break___0;
    case_5: /* CIL Label */ 
#line 4191
    parser->m_useForeignDTD = (XML_Bool )0;
#line 4193
    dtd->hasParamEntityRefs = (XML_Bool )1;
#line 4194
    if (parser->m_startDoctypeDeclHandler) {
      {
#line 4195
      tmp___36 = poolStoreString___0(& parser->m_tempPool, enc, s + enc->minBytesPerChar,
                                     next - enc->minBytesPerChar);
#line 4195
      parser->m_doctypeSysid = (XML_Char const   *)tmp___36;
      }
#line 4198
      if ((unsigned long )parser->m_doctypeSysid == (unsigned long )((void *)0)) {
#line 4199
        return ((enum XML_Error )1);
      }
#line 4200
      parser->m_tempPool.start = parser->m_tempPool.ptr;
#line 4201
      handleDefault = (XML_Bool )0;
    } else {
#line 4207
      parser->m_doctypeSysid = externalSubsetName___0;
    }
#line 4209
    if (! dtd->standalone) {
#line 4209
      if (! parser->m_paramEntityParsing) {
#line 4209
        if (parser->m_notStandaloneHandler) {
          {
#line 4209
          tmp___37 = (*(parser->m_notStandaloneHandler))(parser->m_handlerArg);
          }
#line 4209
          if (! tmp___37) {
#line 4215
            return ((enum XML_Error )22);
          }
        }
      }
    }
#line 4219
    if (! parser->m_declEntity) {
      {
#line 4220
      tmp___38 = lookup___0(parser, & dtd->paramEntities, externalSubsetName___0,
                            sizeof(ENTITY ));
#line 4220
      parser->m_declEntity = (ENTITY *)tmp___38;
      }
#line 4224
      if (! parser->m_declEntity) {
#line 4225
        return ((enum XML_Error )1);
      }
#line 4226
      (parser->m_declEntity)->publicId = (XML_Char const   *)((void *)0);
    }
    case_13: /* CIL Label */ 
#line 4231
    if (dtd->keepProcessing) {
#line 4231
      if (parser->m_declEntity) {
        {
#line 4232
        tmp___39 = poolStoreString___0(& dtd->pool, enc, s + enc->minBytesPerChar,
                                       next - enc->minBytesPerChar);
#line 4232
        (parser->m_declEntity)->systemId = (XML_Char const   *)tmp___39;
        }
#line 4235
        if (! (parser->m_declEntity)->systemId) {
#line 4236
          return ((enum XML_Error )1);
        }
#line 4237
        (parser->m_declEntity)->base = parser->m_curBase;
#line 4238
        dtd->pool.start = dtd->pool.ptr;
#line 4239
        if (parser->m_entityDeclHandler) {
#line 4240
          handleDefault = (XML_Bool )0;
        }
      }
    }
#line 4242
    goto switch_break___0;
    case_15: /* CIL Label */ 
#line 4244
    if (dtd->keepProcessing) {
#line 4244
      if (parser->m_declEntity) {
#line 4244
        if (parser->m_entityDeclHandler) {
          {
#line 4245
          *eventEndPP = s;
#line 4246
          (*(parser->m_entityDeclHandler))(parser->m_handlerArg, (parser->m_declEntity)->name,
                                           (int )(parser->m_declEntity)->is_param,
                                           (XML_Char const   *)0, 0, (parser->m_declEntity)->base,
                                           (parser->m_declEntity)->systemId, (parser->m_declEntity)->publicId,
                                           (XML_Char const   *)0);
#line 4254
          handleDefault = (XML_Bool )0;
          }
        }
      }
    }
#line 4256
    goto switch_break___0;
    case_16: /* CIL Label */ 
#line 4258
    if (dtd->keepProcessing) {
#line 4258
      if (parser->m_declEntity) {
        {
#line 4259
        tmp___40 = poolStoreString___0(& dtd->pool, enc, s, next);
#line 4259
        (parser->m_declEntity)->notation = (XML_Char const   *)tmp___40;
        }
#line 4260
        if (! (parser->m_declEntity)->notation) {
#line 4261
          return ((enum XML_Error )1);
        }
#line 4262
        dtd->pool.start = dtd->pool.ptr;
#line 4263
        if (parser->m_unparsedEntityDeclHandler) {
          {
#line 4264
          *eventEndPP = s;
#line 4265
          (*(parser->m_unparsedEntityDeclHandler))(parser->m_handlerArg, (parser->m_declEntity)->name,
                                                   (parser->m_declEntity)->base, (parser->m_declEntity)->systemId,
                                                   (parser->m_declEntity)->publicId,
                                                   (parser->m_declEntity)->notation);
#line 4271
          handleDefault = (XML_Bool )0;
          }
        } else
#line 4273
        if (parser->m_entityDeclHandler) {
          {
#line 4274
          *eventEndPP = s;
#line 4275
          (*(parser->m_entityDeclHandler))(parser->m_handlerArg, (parser->m_declEntity)->name,
                                           0, (XML_Char const   *)0, 0, (parser->m_declEntity)->base,
                                           (parser->m_declEntity)->systemId, (parser->m_declEntity)->publicId,
                                           (parser->m_declEntity)->notation);
#line 4282
          handleDefault = (XML_Bool )0;
          }
        }
      }
    }
#line 4285
    goto switch_break___0;
    case_9: /* CIL Label */ 
    {
#line 4288
    tmp___41 = (*(enc->predefinedEntityName))(enc, s, next);
    }
#line 4288
    if (tmp___41) {
#line 4289
      parser->m_declEntity = (ENTITY *)((void *)0);
#line 4290
      goto switch_break___0;
    }
#line 4292
    if (dtd->keepProcessing) {
      {
#line 4293
      tmp___42 = poolStoreString___0(& dtd->pool, enc, s, next);
#line 4293
      name = (XML_Char const   *)tmp___42;
      }
#line 4294
      if (! name) {
#line 4295
        return ((enum XML_Error )1);
      }
      {
#line 4296
      tmp___43 = lookup___0(parser, & dtd->generalEntities, name, sizeof(ENTITY ));
#line 4296
      parser->m_declEntity = (ENTITY *)tmp___43;
      }
#line 4298
      if (! parser->m_declEntity) {
#line 4299
        return ((enum XML_Error )1);
      }
#line 4300
      if ((unsigned long )(parser->m_declEntity)->name != (unsigned long )name) {
#line 4301
        dtd->pool.ptr = dtd->pool.start;
#line 4302
        parser->m_declEntity = (ENTITY *)((void *)0);
      } else {
#line 4305
        dtd->pool.start = dtd->pool.ptr;
#line 4306
        (parser->m_declEntity)->publicId = (XML_Char const   *)((void *)0);
#line 4307
        (parser->m_declEntity)->is_param = (XML_Bool )0;
#line 4311
        if (parser->m_parentParser) {
#line 4311
          tmp___44 = 0;
        } else
#line 4311
        if (parser->m_openInternalEntities) {
#line 4311
          tmp___44 = 0;
        } else {
#line 4311
          tmp___44 = 1;
        }
#line 4311
        (parser->m_declEntity)->is_internal = (XML_Bool )tmp___44;
#line 4312
        if (parser->m_entityDeclHandler) {
#line 4313
          handleDefault = (XML_Bool )0;
        }
      }
    } else {
#line 4317
      dtd->pool.ptr = dtd->pool.start;
#line 4318
      parser->m_declEntity = (ENTITY *)((void *)0);
    }
#line 4321
    goto switch_break___0;
    case_10: /* CIL Label */ 
#line 4324
    if (dtd->keepProcessing) {
      {
#line 4325
      tmp___45 = poolStoreString___0(& dtd->pool, enc, s, next);
#line 4325
      name___0 = (XML_Char const   *)tmp___45;
      }
#line 4326
      if (! name___0) {
#line 4327
        return ((enum XML_Error )1);
      }
      {
#line 4328
      tmp___46 = lookup___0(parser, & dtd->paramEntities, name___0, sizeof(ENTITY ));
#line 4328
      parser->m_declEntity = (ENTITY *)tmp___46;
      }
#line 4330
      if (! parser->m_declEntity) {
#line 4331
        return ((enum XML_Error )1);
      }
#line 4332
      if ((unsigned long )(parser->m_declEntity)->name != (unsigned long )name___0) {
#line 4333
        dtd->pool.ptr = dtd->pool.start;
#line 4334
        parser->m_declEntity = (ENTITY *)((void *)0);
      } else {
#line 4337
        dtd->pool.start = dtd->pool.ptr;
#line 4338
        (parser->m_declEntity)->publicId = (XML_Char const   *)((void *)0);
#line 4339
        (parser->m_declEntity)->is_param = (XML_Bool )1;
#line 4343
        if (parser->m_parentParser) {
#line 4343
          tmp___47 = 0;
        } else
#line 4343
        if (parser->m_openInternalEntities) {
#line 4343
          tmp___47 = 0;
        } else {
#line 4343
          tmp___47 = 1;
        }
#line 4343
        (parser->m_declEntity)->is_internal = (XML_Bool )tmp___47;
#line 4344
        if (parser->m_entityDeclHandler) {
#line 4345
          handleDefault = (XML_Bool )0;
        }
      }
    } else {
#line 4349
      dtd->pool.ptr = dtd->pool.start;
#line 4350
      parser->m_declEntity = (ENTITY *)((void *)0);
    }
#line 4355
    goto switch_break___0;
    case_18: /* CIL Label */ 
#line 4357
    parser->m_declNotationPublicId = (XML_Char const   *)((void *)0);
#line 4358
    parser->m_declNotationName = (XML_Char const   *)((void *)0);
#line 4359
    if (parser->m_notationDeclHandler) {
      {
#line 4360
      tmp___48 = poolStoreString___0(& parser->m_tempPool, enc, s, next);
#line 4360
      parser->m_declNotationName = (XML_Char const   *)tmp___48;
      }
#line 4361
      if (! parser->m_declNotationName) {
#line 4362
        return ((enum XML_Error )1);
      }
#line 4363
      parser->m_tempPool.start = parser->m_tempPool.ptr;
#line 4364
      handleDefault = (XML_Bool )0;
    }
#line 4366
    goto switch_break___0;
    case_21: /* CIL Label */ 
    {
#line 4368
    tmp___49 = (*(enc->isPublicId))(enc, s, next, eventPP);
    }
#line 4368
    if (! tmp___49) {
#line 4369
      return ((enum XML_Error )32);
    }
#line 4370
    if (parser->m_declNotationName) {
      {
#line 4371
      tmp___50 = poolStoreString___0(& parser->m_tempPool, enc, s + enc->minBytesPerChar,
                                     next - enc->minBytesPerChar);
#line 4371
      tem___0 = tmp___50;
      }
#line 4375
      if (! tem___0) {
#line 4376
        return ((enum XML_Error )1);
      }
      {
#line 4377
      normalizePublicId___0(tem___0);
#line 4378
      parser->m_declNotationPublicId = (XML_Char const   *)tem___0;
#line 4379
      parser->m_tempPool.start = parser->m_tempPool.ptr;
#line 4380
      handleDefault = (XML_Bool )0;
      }
    }
#line 4382
    goto switch_break___0;
    case_19: /* CIL Label */ 
#line 4384
    if (parser->m_declNotationName) {
#line 4384
      if (parser->m_notationDeclHandler) {
        {
#line 4385
        tmp___51 = poolStoreString___0(& parser->m_tempPool, enc, s + enc->minBytesPerChar,
                                       next - enc->minBytesPerChar);
#line 4385
        systemId = (XML_Char const   *)tmp___51;
        }
#line 4389
        if (! systemId) {
#line 4390
          return ((enum XML_Error )1);
        }
        {
#line 4391
        *eventEndPP = s;
#line 4392
        (*(parser->m_notationDeclHandler))(parser->m_handlerArg, parser->m_declNotationName,
                                           parser->m_curBase, systemId, parser->m_declNotationPublicId);
#line 4397
        handleDefault = (XML_Bool )0;
        }
      }
    }
    {
#line 4399
    poolClear___0(& parser->m_tempPool);
    }
#line 4400
    goto switch_break___0;
    case_20: /* CIL Label */ 
#line 4402
    if (parser->m_declNotationPublicId) {
#line 4402
      if (parser->m_notationDeclHandler) {
        {
#line 4403
        *eventEndPP = s;
#line 4404
        (*(parser->m_notationDeclHandler))(parser->m_handlerArg, parser->m_declNotationName,
                                           parser->m_curBase, (XML_Char const   *)0,
                                           parser->m_declNotationPublicId);
#line 4409
        handleDefault = (XML_Bool )0;
        }
      }
    }
    {
#line 4411
    poolClear___0(& parser->m_tempPool);
    }
#line 4412
    goto switch_break___0;
    case_neg_1___0: /* CIL Label */ 
    {
#line 4415
    if (tok == 28) {
#line 4415
      goto case_28___0;
    }
#line 4419
    if (tok == 12) {
#line 4419
      goto case_12___0;
    }
#line 4421
    goto switch_default___0;
    case_28___0: /* CIL Label */ 
#line 4418
    return ((enum XML_Error )10);
    case_12___0: /* CIL Label */ 
#line 4420
    return ((enum XML_Error )17);
    switch_default___0: /* CIL Label */ 
#line 4422
    return ((enum XML_Error )2);
    switch_break___1: /* CIL Label */ ;
    }
    case_58: /* CIL Label */ 
#line 4428
    if (parser->m_defaultHandler) {
      {
#line 4429
      reportDefault___0(parser, enc, s, next);
      }
    }
    {
#line 4430
    handleDefault = (XML_Bool )0;
#line 4431
    result___3 = doIgnoreSection___0(parser, enc, & next, end, nextPtr, haveMore);
    }
#line 4432
    if ((unsigned int )result___3 != 0U) {
#line 4433
      return (result___3);
    } else
#line 4434
    if (! next) {
#line 4435
      parser->m_processor = & ignoreSectionProcessor___0;
#line 4436
      return (result___3);
    }
#line 4439
    goto switch_break___0;
    case_44: /* CIL Label */ 
#line 4442
    if (parser->m_prologState.level >= parser->m_groupSize) {
#line 4443
      if (parser->m_groupSize) {
        {
#line 4444
        tmp___52 = parser->m_groupSize * 2U;
#line 4444
        parser->m_groupSize = tmp___52;
#line 4444
        tmp___53 = (*(parser->m_mem.realloc_fcn))((void *)parser->m_groupConnector,
                                                  (size_t )tmp___52);
#line 4444
        temp = (char *)tmp___53;
        }
#line 4445
        if ((unsigned long )temp == (unsigned long )((void *)0)) {
#line 4446
          return ((enum XML_Error )1);
        }
#line 4447
        parser->m_groupConnector = temp;
#line 4448
        if (dtd->scaffIndex) {
          {
#line 4449
          tmp___54 = (*(parser->m_mem.realloc_fcn))((void *)dtd->scaffIndex, (unsigned long )parser->m_groupSize * sizeof(int ));
#line 4449
          temp___0 = (int *)tmp___54;
          }
#line 4451
          if ((unsigned long )temp___0 == (unsigned long )((void *)0)) {
#line 4452
            return ((enum XML_Error )1);
          }
#line 4453
          dtd->scaffIndex = temp___0;
        }
      } else {
        {
#line 4457
        tmp___55 = 32U;
#line 4457
        parser->m_groupSize = tmp___55;
#line 4457
        tmp___56 = (*(parser->m_mem.malloc_fcn))((size_t )tmp___55);
#line 4457
        parser->m_groupConnector = (char *)tmp___56;
        }
#line 4458
        if (! parser->m_groupConnector) {
#line 4459
          return ((enum XML_Error )1);
        }
      }
    }
#line 4462
    *(parser->m_groupConnector + parser->m_prologState.level) = (char)0;
#line 4463
    if (dtd->in_eldecl) {
      {
#line 4464
      tmp___57 = nextScaffoldPart___0(parser);
#line 4464
      myindex = tmp___57;
      }
#line 4465
      if (myindex < 0) {
#line 4466
        return ((enum XML_Error )1);
      }
#line 4467
      *(dtd->scaffIndex + dtd->scaffLevel) = myindex;
#line 4468
      (dtd->scaffLevel) ++;
#line 4469
      (dtd->scaffold + myindex)->type = (enum XML_Content_Type )6;
#line 4470
      if (parser->m_elementDeclHandler) {
#line 4471
        handleDefault = (XML_Bool )0;
      }
    }
#line 4473
    goto switch_break___0;
    case_50: /* CIL Label */ 
#line 4475
    if ((int )*(parser->m_groupConnector + parser->m_prologState.level) == 124) {
#line 4476
      return ((enum XML_Error )2);
    }
#line 4477
    *(parser->m_groupConnector + parser->m_prologState.level) = (char)44;
#line 4478
    if (dtd->in_eldecl) {
#line 4478
      if (parser->m_elementDeclHandler) {
#line 4479
        handleDefault = (XML_Bool )0;
      }
    }
#line 4480
    goto switch_break___0;
    case_49: /* CIL Label */ 
#line 4482
    if ((int )*(parser->m_groupConnector + parser->m_prologState.level) == 44) {
#line 4483
      return ((enum XML_Error )2);
    }
#line 4484
    if (dtd->in_eldecl) {
#line 4484
      if (! *(parser->m_groupConnector + parser->m_prologState.level)) {
#line 4484
        if ((unsigned int )(dtd->scaffold + *(dtd->scaffIndex + (dtd->scaffLevel - 1)))->type != 3U) {
#line 4489
          (dtd->scaffold + *(dtd->scaffIndex + (dtd->scaffLevel - 1)))->type = (enum XML_Content_Type )5;
#line 4491
          if (parser->m_elementDeclHandler) {
#line 4492
            handleDefault = (XML_Bool )0;
          }
        }
      }
    }
#line 4494
    *(parser->m_groupConnector + parser->m_prologState.level) = (char)124;
#line 4495
    goto switch_break___0;
    case_59: /* CIL Label */ 
    case_60: /* CIL Label */ 
#line 4499
    dtd->hasParamEntityRefs = (XML_Bool )1;
#line 4500
    if (! parser->m_paramEntityParsing) {
#line 4501
      dtd->keepProcessing = dtd->standalone;
    } else {
      {
#line 4505
      tmp___58 = poolStoreString___0(& dtd->pool, enc, s + enc->minBytesPerChar, next - enc->minBytesPerChar);
#line 4505
      name___1 = (XML_Char const   *)tmp___58;
      }
#line 4508
      if (! name___1) {
#line 4509
        return ((enum XML_Error )1);
      }
      {
#line 4510
      tmp___59 = lookup___0(parser, & dtd->paramEntities, name___1, (size_t )0);
#line 4510
      entity___1 = (ENTITY *)tmp___59;
#line 4511
      dtd->pool.ptr = dtd->pool.start;
      }
#line 4516
      if (parser->m_prologState.documentEntity) {
#line 4516
        if (dtd->standalone) {
#line 4516
          tmp___60 = ! parser->m_openInternalEntities;
        } else {
#line 4516
          tmp___60 = ! dtd->hasParamEntityRefs;
        }
#line 4516
        if (tmp___60) {
#line 4520
          if (! entity___1) {
#line 4521
            return ((enum XML_Error )11);
          } else
#line 4522
          if (! entity___1->is_internal) {
#line 4523
            return ((enum XML_Error )24);
          }
        } else {
#line 4516
          goto _L___3;
        }
      } else
      _L___3: /* CIL Label */ 
#line 4525
      if (! entity___1) {
#line 4526
        dtd->keepProcessing = dtd->standalone;
#line 4528
        if (role == 60) {
#line 4528
          if (parser->m_skippedEntityHandler) {
            {
#line 4529
            (*(parser->m_skippedEntityHandler))(parser->m_handlerArg, name___1, 1);
#line 4530
            handleDefault = (XML_Bool )0;
            }
          }
        }
#line 4532
        goto switch_break___0;
      }
#line 4534
      if (entity___1->open) {
#line 4535
        return ((enum XML_Error )12);
      }
#line 4536
      if (entity___1->textPtr) {
#line 4538
        if (role == 60) {
#line 4538
          tmp___61 = (int )((XML_Bool )1);
        } else {
#line 4538
          tmp___61 = (int )((XML_Bool )0);
        }
        {
#line 4538
        betweenDecl = (XML_Bool )tmp___61;
#line 4540
        result___4 = processInternalEntity___0(parser, entity___1, betweenDecl);
        }
#line 4541
        if ((unsigned int )result___4 != 0U) {
#line 4542
          return (result___4);
        }
#line 4543
        handleDefault = (XML_Bool )0;
#line 4544
        goto switch_break___0;
      }
#line 4546
      if (parser->m_externalEntityRefHandler) {
        {
#line 4547
        dtd->paramEntityRead = (XML_Bool )0;
#line 4548
        entity___1->open = (XML_Bool )1;
#line 4549
        tmp___62 = (*(parser->m_externalEntityRefHandler))(parser->m_externalEntityRefHandlerArg,
                                                           (XML_Char const   *)0,
                                                           entity___1->base, entity___1->systemId,
                                                           entity___1->publicId);
        }
#line 4549
        if (! tmp___62) {
#line 4554
          entity___1->open = (XML_Bool )0;
#line 4555
          return ((enum XML_Error )21);
        }
#line 4557
        entity___1->open = (XML_Bool )0;
#line 4558
        handleDefault = (XML_Bool )0;
#line 4559
        if (! dtd->paramEntityRead) {
#line 4560
          dtd->keepProcessing = dtd->standalone;
#line 4561
          goto switch_break___0;
        }
      } else {
#line 4565
        dtd->keepProcessing = dtd->standalone;
#line 4566
        goto switch_break___0;
      }
    }
#line 4570
    if (! dtd->standalone) {
#line 4570
      if (parser->m_notStandaloneHandler) {
        {
#line 4570
        tmp___63 = (*(parser->m_notStandaloneHandler))(parser->m_handlerArg);
        }
#line 4570
        if (! tmp___63) {
#line 4573
          return ((enum XML_Error )22);
        }
      }
    }
#line 4574
    goto switch_break___0;
    case_40: /* CIL Label */ 
#line 4579
    if (parser->m_elementDeclHandler) {
      {
#line 4580
      parser->m_declElementType = getElementType___0(parser, enc, s, next);
      }
#line 4581
      if (! parser->m_declElementType) {
#line 4582
        return ((enum XML_Error )1);
      }
#line 4583
      dtd->scaffLevel = 0;
#line 4584
      dtd->scaffCount = 0U;
#line 4585
      dtd->in_eldecl = (XML_Bool )1;
#line 4586
      handleDefault = (XML_Bool )0;
    }
#line 4588
    goto switch_break___0;
    case_42: /* CIL Label */ 
    case_41: /* CIL Label */ 
#line 4592
    if (dtd->in_eldecl) {
#line 4593
      if (parser->m_elementDeclHandler) {
        {
#line 4594
        tmp___64 = (*(parser->m_mem.malloc_fcn))(sizeof(XML_Content ));
#line 4594
        content = (XML_Content *)tmp___64;
        }
#line 4595
        if (! content) {
#line 4596
          return ((enum XML_Error )1);
        }
#line 4597
        content->quant = (enum XML_Content_Quant )0;
#line 4598
        content->name = (XML_Char *)((void *)0);
#line 4599
        content->numchildren = 0U;
#line 4600
        content->children = (XML_Content *)((void *)0);
#line 4601
        if (role == 41) {
#line 4601
          content->type = (enum XML_Content_Type )2;
        } else {
#line 4601
          content->type = (enum XML_Content_Type )1;
        }
        {
#line 4604
        *eventEndPP = s;
#line 4605
        (*(parser->m_elementDeclHandler))(parser->m_handlerArg, (parser->m_declElementType)->name,
                                          content);
#line 4606
        handleDefault = (XML_Bool )0;
        }
      }
#line 4608
      dtd->in_eldecl = (XML_Bool )0;
    }
#line 4610
    goto switch_break___0;
    case_43: /* CIL Label */ 
#line 4613
    if (dtd->in_eldecl) {
#line 4614
      (dtd->scaffold + *(dtd->scaffIndex + (dtd->scaffLevel - 1)))->type = (enum XML_Content_Type )3;
#line 4616
      if (parser->m_elementDeclHandler) {
#line 4617
        handleDefault = (XML_Bool )0;
      }
    }
#line 4619
    goto switch_break___0;
    case_51: /* CIL Label */ 
#line 4622
    quant = (enum XML_Content_Quant )0;
#line 4623
    goto elementContent;
    case_53: /* CIL Label */ 
#line 4625
    quant = (enum XML_Content_Quant )1;
#line 4626
    goto elementContent;
    case_52: /* CIL Label */ 
#line 4628
    quant = (enum XML_Content_Quant )2;
#line 4629
    goto elementContent;
    case_54: /* CIL Label */ 
#line 4631
    quant = (enum XML_Content_Quant )3;
    elementContent: 
#line 4633
    if (dtd->in_eldecl) {
#line 4637
      if ((unsigned int )quant == 0U) {
#line 4637
        tmp___65 = next;
      } else {
#line 4637
        tmp___65 = next - enc->minBytesPerChar;
      }
      {
#line 4637
      nxt = tmp___65;
#line 4640
      tmp___66 = nextScaffoldPart___0(parser);
#line 4640
      myindex___0 = tmp___66;
      }
#line 4641
      if (myindex___0 < 0) {
#line 4642
        return ((enum XML_Error )1);
      }
      {
#line 4643
      (dtd->scaffold + myindex___0)->type = (enum XML_Content_Type )4;
#line 4644
      (dtd->scaffold + myindex___0)->quant = quant;
#line 4645
      el = getElementType___0(parser, enc, s, nxt);
      }
#line 4646
      if (! el) {
#line 4647
        return ((enum XML_Error )1);
      }
#line 4648
      name___2 = el->name;
#line 4649
      (dtd->scaffold + myindex___0)->name = name___2;
#line 4650
      nameLen = 0;
      {
#line 4651
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 4651
        tmp___67 = nameLen;
#line 4651
        nameLen ++;
#line 4651
        if (! *(name___2 + tmp___67)) {
#line 4651
          goto while_break___0;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
#line 4652
      dtd->contentStringLen += (unsigned int )nameLen;
#line 4653
      if (parser->m_elementDeclHandler) {
#line 4654
        handleDefault = (XML_Bool )0;
      }
    }
#line 4656
    goto switch_break___0;
    case_45: /* CIL Label */ 
#line 4659
    quant = (enum XML_Content_Quant )0;
#line 4660
    goto closeGroup;
    case_47: /* CIL Label */ 
#line 4662
    quant = (enum XML_Content_Quant )1;
#line 4663
    goto closeGroup;
    case_46: /* CIL Label */ 
#line 4665
    quant = (enum XML_Content_Quant )2;
#line 4666
    goto closeGroup;
    case_48: /* CIL Label */ 
#line 4668
    quant = (enum XML_Content_Quant )3;
    closeGroup: 
#line 4670
    if (dtd->in_eldecl) {
#line 4671
      if (parser->m_elementDeclHandler) {
#line 4672
        handleDefault = (XML_Bool )0;
      }
#line 4673
      (dtd->scaffLevel) --;
#line 4674
      (dtd->scaffold + *(dtd->scaffIndex + dtd->scaffLevel))->quant = quant;
#line 4675
      if (dtd->scaffLevel == 0) {
#line 4676
        if (! handleDefault) {
          {
#line 4677
          tmp___68 = build_model___0(parser);
#line 4677
          model = tmp___68;
          }
#line 4678
          if (! model) {
#line 4679
            return ((enum XML_Error )1);
          }
          {
#line 4680
          *eventEndPP = s;
#line 4681
          (*(parser->m_elementDeclHandler))(parser->m_handlerArg, (parser->m_declElementType)->name,
                                            model);
          }
        }
#line 4683
        dtd->in_eldecl = (XML_Bool )0;
#line 4684
        dtd->contentStringLen = 0U;
      }
    }
#line 4687
    goto switch_break___0;
    case_55: /* CIL Label */ 
    {
#line 4691
    tmp___69 = reportProcessingInstruction___0(parser, enc, s, next);
    }
#line 4691
    if (! tmp___69) {
#line 4692
      return ((enum XML_Error )1);
    }
#line 4693
    handleDefault = (XML_Bool )0;
#line 4694
    goto switch_break___0;
    case_56: /* CIL Label */ 
    {
#line 4696
    tmp___70 = reportComment___0(parser, enc, s, next);
    }
#line 4696
    if (! tmp___70) {
#line 4697
      return ((enum XML_Error )1);
    }
#line 4698
    handleDefault = (XML_Bool )0;
#line 4699
    goto switch_break___0;
    case_0___0: /* CIL Label */ 
    {
#line 4702
    if (tok == 14) {
#line 4702
      goto case_14___0;
    }
#line 4701
    goto switch_break___2;
    case_14___0: /* CIL Label */ 
#line 4703
    handleDefault = (XML_Bool )0;
#line 4704
    goto switch_break___2;
    switch_break___2: /* CIL Label */ ;
    }
#line 4706
    goto switch_break___0;
    case_3: /* CIL Label */ 
#line 4708
    if (parser->m_startDoctypeDeclHandler) {
#line 4709
      handleDefault = (XML_Bool )0;
    }
#line 4710
    goto switch_break___0;
    case_11: /* CIL Label */ 
#line 4712
    if (dtd->keepProcessing) {
#line 4712
      if (parser->m_entityDeclHandler) {
#line 4713
        handleDefault = (XML_Bool )0;
      }
    }
#line 4714
    goto switch_break___0;
    case_17: /* CIL Label */ 
#line 4716
    if (parser->m_notationDeclHandler) {
#line 4717
      handleDefault = (XML_Bool )0;
    }
#line 4718
    goto switch_break___0;
    case_33: /* CIL Label */ 
#line 4720
    if (dtd->keepProcessing) {
#line 4720
      if (parser->m_attlistDeclHandler) {
#line 4721
        handleDefault = (XML_Bool )0;
      }
    }
#line 4722
    goto switch_break___0;
    case_39: /* CIL Label */ 
#line 4724
    if (parser->m_elementDeclHandler) {
#line 4725
      handleDefault = (XML_Bool )0;
    }
#line 4726
    goto switch_break___0;
    switch_break___0: /* CIL Label */ ;
    }
#line 4729
    if (handleDefault) {
#line 4729
      if (parser->m_defaultHandler) {
        {
#line 4730
        reportDefault___0(parser, enc, s, next);
        }
      }
    }
    {
#line 4733
    if ((unsigned int )parser->m_parsingStatus.parsing == 3U) {
#line 4733
      goto case_3___0;
    }
#line 4736
    if ((unsigned int )parser->m_parsingStatus.parsing == 2U) {
#line 4736
      goto case_2___0;
    }
#line 4738
    goto switch_default___1;
    case_3___0: /* CIL Label */ 
#line 4734
    *nextPtr = next;
#line 4735
    return ((enum XML_Error )0);
    case_2___0: /* CIL Label */ 
#line 4737
    return ((enum XML_Error )35);
    switch_default___1: /* CIL Label */ 
    {
#line 4739
    s = next;
#line 4740
    tok = (*(enc->scanners[0]))(enc, s, end, & next);
    }
    switch_break___3: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 4746 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlparse.c"
static enum XML_Error epilogProcessor___0(XML_Parser parser , char const   *s , char const   *end ,
                                          char const   **nextPtr ) 
{ 
  char const   *next ;
  int tok ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 4752
  parser->m_processor = & epilogProcessor___0;
#line 4753
  parser->m_eventPtr = s;
  {
#line 4754
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 4755
    next = (char const   *)((void *)0);
#line 4756
    tmp = (*((parser->m_encoding)->scanners[0]))(parser->m_encoding, s, end, & next);
#line 4756
    tok = tmp;
#line 4757
    parser->m_eventEndPtr = next;
    }
    {
#line 4760
    if (tok == -15) {
#line 4760
      goto case_neg_15;
    }
#line 4768
    if (tok == -4) {
#line 4768
      goto case_neg_4;
    }
#line 4771
    if (tok == 15) {
#line 4771
      goto case_15;
    }
#line 4775
    if (tok == 11) {
#line 4775
      goto case_11;
    }
#line 4779
    if (tok == 13) {
#line 4779
      goto case_13;
    }
#line 4783
    if (tok == 0) {
#line 4783
      goto case_0;
    }
#line 4786
    if (tok == -1) {
#line 4786
      goto case_neg_1;
    }
#line 4792
    if (tok == -2) {
#line 4792
      goto case_neg_2;
    }
#line 4798
    goto switch_default;
    case_neg_15: /* CIL Label */ 
#line 4761
    if (parser->m_defaultHandler) {
      {
#line 4762
      reportDefault___0(parser, parser->m_encoding, s, next);
      }
#line 4763
      if ((unsigned int )parser->m_parsingStatus.parsing == 2U) {
#line 4764
        return ((enum XML_Error )35);
      }
    }
#line 4766
    *nextPtr = next;
#line 4767
    return ((enum XML_Error )0);
    case_neg_4: /* CIL Label */ 
#line 4769
    *nextPtr = s;
#line 4770
    return ((enum XML_Error )0);
    case_15: /* CIL Label */ 
#line 4772
    if (parser->m_defaultHandler) {
      {
#line 4773
      reportDefault___0(parser, parser->m_encoding, s, next);
      }
    }
#line 4774
    goto switch_break;
    case_11: /* CIL Label */ 
    {
#line 4776
    tmp___0 = reportProcessingInstruction___0(parser, parser->m_encoding, s, next);
    }
#line 4776
    if (! tmp___0) {
#line 4777
      return ((enum XML_Error )1);
    }
#line 4778
    goto switch_break;
    case_13: /* CIL Label */ 
    {
#line 4780
    tmp___1 = reportComment___0(parser, parser->m_encoding, s, next);
    }
#line 4780
    if (! tmp___1) {
#line 4781
      return ((enum XML_Error )1);
    }
#line 4782
    goto switch_break;
    case_0: /* CIL Label */ 
#line 4784
    parser->m_eventPtr = next;
#line 4785
    return ((enum XML_Error )4);
    case_neg_1: /* CIL Label */ 
#line 4787
    if (! parser->m_parsingStatus.finalBuffer) {
#line 4788
      *nextPtr = s;
#line 4789
      return ((enum XML_Error )0);
    }
#line 4791
    return ((enum XML_Error )5);
    case_neg_2: /* CIL Label */ 
#line 4793
    if (! parser->m_parsingStatus.finalBuffer) {
#line 4794
      *nextPtr = s;
#line 4795
      return ((enum XML_Error )0);
    }
#line 4797
    return ((enum XML_Error )6);
    switch_default: /* CIL Label */ 
#line 4799
    return ((enum XML_Error )9);
    switch_break: /* CIL Label */ ;
    }
#line 4801
    s = next;
#line 4801
    parser->m_eventPtr = s;
    {
#line 4803
    if ((unsigned int )parser->m_parsingStatus.parsing == 3U) {
#line 4803
      goto case_3;
    }
#line 4806
    if ((unsigned int )parser->m_parsingStatus.parsing == 2U) {
#line 4806
      goto case_2;
    }
#line 4808
    goto switch_default___0;
    case_3: /* CIL Label */ 
#line 4804
    *nextPtr = next;
#line 4805
    return ((enum XML_Error )0);
    case_2: /* CIL Label */ 
#line 4807
    return ((enum XML_Error )35);
    switch_default___0: /* CIL Label */ ;
    switch_break___0: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 4813 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlparse.c"
static enum XML_Error processInternalEntity___0(XML_Parser parser , ENTITY *entity ,
                                                XML_Bool betweenDecl ) 
{ 
  char const   *textStart ;
  char const   *textEnd ;
  char const   *next ;
  enum XML_Error result ;
  OPEN_INTERNAL_ENTITY *openEntity ;
  void *tmp ;
  int tok ;
  int tmp___0 ;

  {
#line 4822
  if (parser->m_freeInternalEntities) {
#line 4823
    openEntity = parser->m_freeInternalEntities;
#line 4824
    parser->m_freeInternalEntities = openEntity->next;
  } else {
    {
#line 4827
    tmp = (*(parser->m_mem.malloc_fcn))(sizeof(OPEN_INTERNAL_ENTITY ));
#line 4827
    openEntity = (OPEN_INTERNAL_ENTITY *)tmp;
    }
#line 4828
    if (! openEntity) {
#line 4829
      return ((enum XML_Error )1);
    }
  }
#line 4831
  entity->open = (XML_Bool )1;
#line 4832
  entity->processed = 0;
#line 4833
  openEntity->next = parser->m_openInternalEntities;
#line 4834
  parser->m_openInternalEntities = openEntity;
#line 4835
  openEntity->entity = entity;
#line 4836
  openEntity->startTagLevel = parser->m_tagLevel;
#line 4837
  openEntity->betweenDecl = betweenDecl;
#line 4838
  openEntity->internalEventPtr = (char const   *)((void *)0);
#line 4839
  openEntity->internalEventEndPtr = (char const   *)((void *)0);
#line 4840
  textStart = (char const   *)((char *)entity->textPtr);
#line 4841
  textEnd = (char const   *)((char *)(entity->textPtr + entity->textLen));
#line 4844
  if (entity->is_param) {
    {
#line 4845
    tmp___0 = (*((parser->m_internalEncoding)->scanners[0]))(parser->m_internalEncoding,
                                                             textStart, textEnd, & next);
#line 4845
    tok = tmp___0;
#line 4846
    result = doProlog___0(parser, parser->m_internalEncoding, textStart, textEnd,
                          tok, next, & next, (XML_Bool )0);
    }
  } else {
    {
#line 4851
    result = doContent___0(parser, parser->m_tagLevel, parser->m_internalEncoding,
                           textStart, textEnd, & next, (XML_Bool )0);
    }
  }
#line 4854
  if ((unsigned int )result == 0U) {
#line 4855
    if ((unsigned long )textEnd != (unsigned long )next) {
#line 4855
      if ((unsigned int )parser->m_parsingStatus.parsing == 3U) {
#line 4856
        entity->processed = (int )(next - textStart);
#line 4857
        parser->m_processor = & internalEntityProcessor___0;
      } else {
#line 4860
        entity->open = (XML_Bool )0;
#line 4861
        parser->m_openInternalEntities = openEntity->next;
#line 4863
        openEntity->next = parser->m_freeInternalEntities;
#line 4864
        parser->m_freeInternalEntities = openEntity;
      }
    } else {
#line 4860
      entity->open = (XML_Bool )0;
#line 4861
      parser->m_openInternalEntities = openEntity->next;
#line 4863
      openEntity->next = parser->m_freeInternalEntities;
#line 4864
      parser->m_freeInternalEntities = openEntity;
    }
  }
#line 4867
  return (result);
}
}
#line 4870 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlparse.c"
static enum XML_Error internalEntityProcessor___0(XML_Parser parser , char const   *s ,
                                                  char const   *end , char const   **nextPtr ) 
{ 
  ENTITY *entity ;
  char const   *textStart ;
  char const   *textEnd ;
  char const   *next ;
  enum XML_Error result ;
  OPEN_INTERNAL_ENTITY *openEntity ;
  int tok ;
  int tmp ;
  int tok___0 ;
  enum XML_Error tmp___0 ;
  int tmp___1 ;
  enum XML_Error tmp___2 ;

  {
#line 4880
  openEntity = parser->m_openInternalEntities;
#line 4881
  if (! openEntity) {
#line 4882
    return ((enum XML_Error )23);
  }
#line 4884
  entity = openEntity->entity;
#line 4885
  textStart = (char const   *)((char *)entity->textPtr + entity->processed);
#line 4886
  textEnd = (char const   *)((char *)(entity->textPtr + entity->textLen));
#line 4889
  if (entity->is_param) {
    {
#line 4890
    tmp = (*((parser->m_internalEncoding)->scanners[0]))(parser->m_internalEncoding,
                                                         textStart, textEnd, & next);
#line 4890
    tok = tmp;
#line 4891
    result = doProlog___0(parser, parser->m_internalEncoding, textStart, textEnd,
                          tok, next, & next, (XML_Bool )0);
    }
  } else {
    {
#line 4896
    result = doContent___0(parser, openEntity->startTagLevel, parser->m_internalEncoding,
                           textStart, textEnd, & next, (XML_Bool )0);
    }
  }
#line 4899
  if ((unsigned int )result != 0U) {
#line 4900
    return (result);
  } else
#line 4901
  if ((unsigned long )textEnd != (unsigned long )next) {
#line 4901
    if ((unsigned int )parser->m_parsingStatus.parsing == 3U) {
#line 4902
      entity->processed = (int )(next - (char const   *)((char *)entity->textPtr));
#line 4903
      return (result);
    } else {
#line 4906
      entity->open = (XML_Bool )0;
#line 4907
      parser->m_openInternalEntities = openEntity->next;
#line 4909
      openEntity->next = parser->m_freeInternalEntities;
#line 4910
      parser->m_freeInternalEntities = openEntity;
    }
  } else {
#line 4906
    entity->open = (XML_Bool )0;
#line 4907
    parser->m_openInternalEntities = openEntity->next;
#line 4909
    openEntity->next = parser->m_freeInternalEntities;
#line 4910
    parser->m_freeInternalEntities = openEntity;
  }
#line 4914
  if (entity->is_param) {
    {
#line 4916
    parser->m_processor = & prologProcessor___0;
#line 4917
    tok___0 = (*((parser->m_encoding)->scanners[0]))(parser->m_encoding, s, end, & next);
#line 4918
    tmp___0 = doProlog___0(parser, parser->m_encoding, s, end, tok___0, next, nextPtr,
                           (XML_Bool )(! parser->m_parsingStatus.finalBuffer));
    }
#line 4918
    return (tmp___0);
  } else {
#line 4924
    parser->m_processor = & contentProcessor___0;
#line 4926
    if (parser->m_parentParser) {
#line 4926
      tmp___1 = 1;
    } else {
#line 4926
      tmp___1 = 0;
    }
    {
#line 4926
    tmp___2 = doContent___0(parser, tmp___1, parser->m_encoding, s, end, nextPtr,
                            (XML_Bool )(! parser->m_parsingStatus.finalBuffer));
    }
#line 4926
    return (tmp___2);
  }
}
}
#line 4931 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlparse.c"
static enum XML_Error errorProcessor___0(XML_Parser parser , char const   *s , char const   *end ,
                                         char const   **nextPtr ) 
{ 


  {
#line 4937
  return (parser->m_errorCode);
}
}
#line 4940 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlparse.c"
static enum XML_Error storeAttributeValue___0(XML_Parser parser , ENCODING const   *enc ,
                                              XML_Bool isCdata , char const   *ptr ,
                                              char const   *end , STRING_POOL *pool ) 
{ 
  enum XML_Error result ;
  enum XML_Error tmp ;
  XML_Char *tmp___1 ;
  int tmp___2 ;
  XML_Bool tmp___3 ;

  {
  {
#line 4945
  tmp = appendAttributeValue___0(parser, enc, isCdata, ptr, end, pool);
#line 4945
  result = tmp;
  }
#line 4947
  if (result) {
#line 4948
    return (result);
  }
#line 4949
  if (! isCdata) {
#line 4949
    if (pool->ptr - pool->start) {
#line 4949
      if ((int )*(pool->ptr + -1) == 32) {
#line 4950
        (pool->ptr) --;
      }
    }
  }
#line 4951
  if ((unsigned long )pool->ptr == (unsigned long )pool->end) {
    {
#line 4951
    tmp___3 = poolGrow___0(pool);
    }
#line 4951
    if (tmp___3) {
#line 4951
      tmp___1 = pool->ptr;
#line 4951
      (pool->ptr) ++;
#line 4951
      *tmp___1 = (XML_Char )'\000';
#line 4951
      tmp___2 = 1;
    } else {
#line 4951
      tmp___2 = 0;
    }
  } else {
#line 4951
    tmp___1 = pool->ptr;
#line 4951
    (pool->ptr) ++;
#line 4951
    *tmp___1 = (XML_Char )'\000';
#line 4951
    tmp___2 = 1;
  }
#line 4951
  if (! tmp___2) {
#line 4952
    return ((enum XML_Error )1);
  }
#line 4953
  return ((enum XML_Error )0);
}
}
#line 4956 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlparse.c"
static enum XML_Error appendAttributeValue___0(XML_Parser parser , ENCODING const   *enc ,
                                               XML_Bool isCdata , char const   *ptr ,
                                               char const   *end , STRING_POOL *pool ) 
{ 
  DTD *dtd ;
  char const   *next ;
  int tok ;
  int tmp ;
  XML_Char buf[4] ;
  int i ;
  int n ;
  int tmp___0 ;
  XML_Char *tmp___2 ;
  int tmp___3 ;
  XML_Bool tmp___4 ;
  XML_Char *tmp___5 ;
  XML_Char *tmp___7 ;
  int tmp___8 ;
  XML_Bool tmp___9 ;
  XML_Char const   *name ;
  ENTITY *entity ;
  char checkEntityDecl ;
  XML_Char ch ;
  int tmp___10 ;
  XML_Char *tmp___12 ;
  int tmp___13 ;
  XML_Bool tmp___14 ;
  XML_Char *tmp___15 ;
  NAMED *tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  enum XML_Error result ;
  XML_Char const   *textEnd ;

  {
#line 4961
  dtd = parser->m_dtd;
  {
#line 4962
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 4964
    tmp = (*(enc->literalScanners[0]))(enc, ptr, end, & next);
#line 4964
    tok = tmp;
    }
    {
#line 4966
    if (tok == -4) {
#line 4966
      goto case_neg_4;
    }
#line 4968
    if (tok == 0) {
#line 4968
      goto case_0;
    }
#line 4972
    if (tok == -1) {
#line 4972
      goto case_neg_1;
    }
#line 4976
    if (tok == 10) {
#line 4976
      goto case_10;
    }
#line 5002
    if (tok == 6) {
#line 5002
      goto case_6;
    }
#line 5006
    if (tok == -3) {
#line 5006
      goto case_neg_3;
    }
#line 5010
    if (tok == 7) {
#line 5010
      goto case_7;
    }
#line 5010
    if (tok == 39) {
#line 5010
      goto case_7;
    }
#line 5016
    if (tok == 9) {
#line 5016
      goto case_9;
    }
#line 5096
    goto switch_default;
    case_neg_4: /* CIL Label */ 
#line 4967
    return ((enum XML_Error )0);
    case_0: /* CIL Label */ 
#line 4969
    if ((unsigned long )enc == (unsigned long )parser->m_encoding) {
#line 4970
      parser->m_eventPtr = next;
    }
#line 4971
    return ((enum XML_Error )4);
    case_neg_1: /* CIL Label */ 
#line 4973
    if ((unsigned long )enc == (unsigned long )parser->m_encoding) {
#line 4974
      parser->m_eventPtr = ptr;
    }
#line 4975
    return ((enum XML_Error )4);
    case_10: /* CIL Label */ 
    {
#line 4980
    tmp___0 = (*(enc->charRefNumber))(enc, ptr);
#line 4980
    n = tmp___0;
    }
#line 4981
    if (n < 0) {
#line 4982
      if ((unsigned long )enc == (unsigned long )parser->m_encoding) {
#line 4983
        parser->m_eventPtr = ptr;
      }
#line 4984
      return ((enum XML_Error )14);
    }
#line 4986
    if (! isCdata) {
#line 4986
      if (n == 32) {
#line 4986
        if (pool->ptr - pool->start == 0L) {
#line 4989
          goto switch_break;
        } else
#line 4986
        if ((int )*(pool->ptr + -1) == 32) {
#line 4989
          goto switch_break;
        }
      }
    }
    {
#line 4990
    n = XmlUtf8Encode(n, buf);
    }
#line 4991
    if (! n) {
#line 4992
      if ((unsigned long )enc == (unsigned long )parser->m_encoding) {
#line 4993
        parser->m_eventPtr = ptr;
      }
#line 4994
      return ((enum XML_Error )14);
    }
#line 4996
    i = 0;
    {
#line 4996
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 4996
      if (! (i < n)) {
#line 4996
        goto while_break___0;
      }
#line 4997
      if ((unsigned long )pool->ptr == (unsigned long )pool->end) {
        {
#line 4997
        tmp___4 = poolGrow___0(pool);
        }
#line 4997
        if (tmp___4) {
#line 4997
          tmp___2 = pool->ptr;
#line 4997
          (pool->ptr) ++;
#line 4997
          *tmp___2 = buf[i];
#line 4997
          tmp___3 = 1;
        } else {
#line 4997
          tmp___3 = 0;
        }
      } else {
#line 4997
        tmp___2 = pool->ptr;
#line 4997
        (pool->ptr) ++;
#line 4997
        *tmp___2 = buf[i];
#line 4997
        tmp___3 = 1;
      }
#line 4997
      if (! tmp___3) {
#line 4998
        return ((enum XML_Error )1);
      }
#line 4996
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 5001
    goto switch_break;
    case_6: /* CIL Label */ 
    {
#line 5003
    tmp___5 = poolAppend___0(pool, enc, ptr, next);
    }
#line 5003
    if (! tmp___5) {
#line 5004
      return ((enum XML_Error )1);
    }
#line 5005
    goto switch_break;
    case_neg_3: /* CIL Label */ 
#line 5007
    next = ptr + enc->minBytesPerChar;
    case_7: /* CIL Label */ 
    case_39: /* CIL Label */ 
#line 5011
    if (! isCdata) {
#line 5011
      if (pool->ptr - pool->start == 0L) {
#line 5012
        goto switch_break;
      } else
#line 5011
      if ((int )*(pool->ptr + -1) == 32) {
#line 5012
        goto switch_break;
      }
    }
#line 5013
    if ((unsigned long )pool->ptr == (unsigned long )pool->end) {
      {
#line 5013
      tmp___9 = poolGrow___0(pool);
      }
#line 5013
      if (tmp___9) {
#line 5013
        tmp___7 = pool->ptr;
#line 5013
        (pool->ptr) ++;
#line 5013
        *tmp___7 = (XML_Char )32;
#line 5013
        tmp___8 = 1;
      } else {
#line 5013
        tmp___8 = 0;
      }
    } else {
#line 5013
      tmp___7 = pool->ptr;
#line 5013
      (pool->ptr) ++;
#line 5013
      *tmp___7 = (XML_Char )32;
#line 5013
      tmp___8 = 1;
    }
#line 5013
    if (! tmp___8) {
#line 5014
      return ((enum XML_Error )1);
    }
#line 5015
    goto switch_break;
    case_9: /* CIL Label */ 
    {
#line 5021
    tmp___10 = (*(enc->predefinedEntityName))(enc, ptr + enc->minBytesPerChar, next - enc->minBytesPerChar);
#line 5021
    ch = (XML_Char )tmp___10;
    }
#line 5024
    if (ch) {
#line 5025
      if ((unsigned long )pool->ptr == (unsigned long )pool->end) {
        {
#line 5025
        tmp___14 = poolGrow___0(pool);
        }
#line 5025
        if (tmp___14) {
#line 5025
          tmp___12 = pool->ptr;
#line 5025
          (pool->ptr) ++;
#line 5025
          *tmp___12 = ch;
#line 5025
          tmp___13 = 1;
        } else {
#line 5025
          tmp___13 = 0;
        }
      } else {
#line 5025
        tmp___12 = pool->ptr;
#line 5025
        (pool->ptr) ++;
#line 5025
        *tmp___12 = ch;
#line 5025
        tmp___13 = 1;
      }
#line 5025
      if (! tmp___13) {
#line 5026
        return ((enum XML_Error )1);
      }
#line 5027
      goto switch_break;
    }
    {
#line 5029
    tmp___15 = poolStoreString___0(& parser->m_temp2Pool, enc, ptr + enc->minBytesPerChar,
                                   next - enc->minBytesPerChar);
#line 5029
    name = (XML_Char const   *)tmp___15;
    }
#line 5032
    if (! name) {
#line 5033
      return ((enum XML_Error )1);
    }
    {
#line 5034
    tmp___16 = lookup___0(parser, & dtd->generalEntities, name, (size_t )0);
#line 5034
    entity = (ENTITY *)tmp___16;
#line 5035
    parser->m_temp2Pool.ptr = parser->m_temp2Pool.start;
    }
#line 5039
    if ((unsigned long )pool == (unsigned long )(& dtd->pool)) {
#line 5040
      if (parser->m_prologState.documentEntity) {
#line 5040
        if (dtd->standalone) {
#line 5040
          tmp___17 = ! parser->m_openInternalEntities;
        } else {
#line 5040
          tmp___17 = ! dtd->hasParamEntityRefs;
        }
#line 5040
        if (tmp___17) {
#line 5040
          tmp___18 = 1;
        } else {
#line 5040
          tmp___18 = 0;
        }
      } else {
#line 5040
        tmp___18 = 0;
      }
#line 5040
      checkEntityDecl = (char )tmp___18;
    } else {
#line 5048
      if (! dtd->hasParamEntityRefs) {
#line 5048
        tmp___19 = 1;
      } else
#line 5048
      if (dtd->standalone) {
#line 5048
        tmp___19 = 1;
      } else {
#line 5048
        tmp___19 = 0;
      }
#line 5048
      checkEntityDecl = (char )tmp___19;
    }
#line 5049
    if (checkEntityDecl) {
#line 5050
      if (! entity) {
#line 5051
        return ((enum XML_Error )11);
      } else
#line 5052
      if (! entity->is_internal) {
#line 5053
        return ((enum XML_Error )24);
      }
    } else
#line 5055
    if (! entity) {
#line 5066
      goto switch_break;
    }
#line 5068
    if (entity->open) {
#line 5069
      if ((unsigned long )enc == (unsigned long )parser->m_encoding) {
#line 5070
        parser->m_eventPtr = ptr;
      }
#line 5071
      return ((enum XML_Error )12);
    }
#line 5073
    if (entity->notation) {
#line 5074
      if ((unsigned long )enc == (unsigned long )parser->m_encoding) {
#line 5075
        parser->m_eventPtr = ptr;
      }
#line 5076
      return ((enum XML_Error )15);
    }
#line 5078
    if (! entity->textPtr) {
#line 5079
      if ((unsigned long )enc == (unsigned long )parser->m_encoding) {
#line 5080
        parser->m_eventPtr = ptr;
      }
#line 5081
      return ((enum XML_Error )16);
    } else {
      {
#line 5085
      textEnd = entity->textPtr + entity->textLen;
#line 5086
      entity->open = (XML_Bool )1;
#line 5087
      result = appendAttributeValue___0(parser, parser->m_internalEncoding, isCdata,
                                        (char const   *)((char *)entity->textPtr),
                                        (char const   *)((char *)textEnd), pool);
#line 5090
      entity->open = (XML_Bool )0;
      }
#line 5091
      if (result) {
#line 5092
        return (result);
      }
    }
#line 5095
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 5097
    if ((unsigned long )enc == (unsigned long )parser->m_encoding) {
#line 5098
      parser->m_eventPtr = ptr;
    }
#line 5099
    return ((enum XML_Error )23);
    switch_break: /* CIL Label */ ;
    }
#line 5101
    ptr = next;
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 5106 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlparse.c"
static enum XML_Error storeEntityValue___0(XML_Parser parser , ENCODING const   *enc ,
                                           char const   *entityTextPtr , char const   *entityTextEnd ) 
{ 
  DTD *dtd ;
  STRING_POOL *pool ;
  enum XML_Error result ;
  int oldInEntityValue ;
  XML_Bool tmp ;
  char const   *next ;
  int tok ;
  int tmp___0 ;
  XML_Char const   *name ;
  ENTITY *entity ;
  XML_Char *tmp___1 ;
  NAMED *tmp___2 ;
  int tmp___3 ;
  XML_Char *tmp___4 ;
  XML_Bool tmp___5 ;
  XML_Char *tmp___6 ;
  XML_Char buf[4] ;
  int i ;
  int n ;
  int tmp___7 ;
  XML_Bool tmp___8 ;
  XML_Char *tmp___9 ;

  {
#line 5112
  dtd = parser->m_dtd;
#line 5113
  pool = & dtd->entityValuePool;
#line 5114
  result = (enum XML_Error )0;
#line 5116
  oldInEntityValue = parser->m_prologState.inEntityValue;
#line 5117
  parser->m_prologState.inEntityValue = 1;
#line 5122
  if (! pool->blocks) {
    {
#line 5123
    tmp = poolGrow___0(pool);
    }
#line 5123
    if (! tmp) {
#line 5124
      return ((enum XML_Error )1);
    }
  }
  {
#line 5127
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 5129
    tmp___0 = (*(enc->literalScanners[1]))(enc, entityTextPtr, entityTextEnd, & next);
#line 5129
    tok = tmp___0;
    }
    {
#line 5131
    if (tok == 28) {
#line 5131
      goto case_28;
    }
#line 5200
    if (tok == -4) {
#line 5200
      goto case_neg_4;
    }
#line 5204
    if (tok == 6) {
#line 5204
      goto case_6;
    }
#line 5204
    if (tok == 9) {
#line 5204
      goto case_6;
    }
#line 5210
    if (tok == -3) {
#line 5210
      goto case_neg_3;
    }
#line 5213
    if (tok == 7) {
#line 5213
      goto case_7;
    }
#line 5220
    if (tok == 10) {
#line 5220
      goto case_10;
    }
#line 5247
    if (tok == -1) {
#line 5247
      goto case_neg_1;
    }
#line 5252
    if (tok == 0) {
#line 5252
      goto case_0;
    }
#line 5257
    goto switch_default;
    case_28: /* CIL Label */ 
#line 5133
    if (parser->m_isParamEntity) {
#line 5133
      goto _L;
    } else
#line 5133
    if ((unsigned long )enc != (unsigned long )parser->m_encoding) {
      _L: /* CIL Label */ 
      {
#line 5136
      tmp___1 = poolStoreString___0(& parser->m_tempPool, enc, entityTextPtr + enc->minBytesPerChar,
                                    next - enc->minBytesPerChar);
#line 5136
      name = (XML_Char const   *)tmp___1;
      }
#line 5139
      if (! name) {
#line 5140
        result = (enum XML_Error )1;
#line 5141
        goto endEntityValue;
      }
      {
#line 5143
      tmp___2 = lookup___0(parser, & dtd->paramEntities, name, (size_t )0);
#line 5143
      entity = (ENTITY *)tmp___2;
#line 5144
      parser->m_tempPool.ptr = parser->m_tempPool.start;
      }
#line 5145
      if (! entity) {
#line 5152
        dtd->keepProcessing = dtd->standalone;
#line 5153
        goto endEntityValue;
      }
#line 5155
      if (entity->open) {
#line 5156
        if ((unsigned long )enc == (unsigned long )parser->m_encoding) {
#line 5157
          parser->m_eventPtr = entityTextPtr;
        }
#line 5158
        result = (enum XML_Error )12;
#line 5159
        goto endEntityValue;
      }
#line 5161
      if (entity->systemId) {
#line 5162
        if (parser->m_externalEntityRefHandler) {
          {
#line 5163
          dtd->paramEntityRead = (XML_Bool )0;
#line 5164
          entity->open = (XML_Bool )1;
#line 5165
          tmp___3 = (*(parser->m_externalEntityRefHandler))(parser->m_externalEntityRefHandlerArg,
                                                            (XML_Char const   *)0,
                                                            entity->base, entity->systemId,
                                                            entity->publicId);
          }
#line 5165
          if (! tmp___3) {
#line 5170
            entity->open = (XML_Bool )0;
#line 5171
            result = (enum XML_Error )21;
#line 5172
            goto endEntityValue;
          }
#line 5174
          entity->open = (XML_Bool )0;
#line 5175
          if (! dtd->paramEntityRead) {
#line 5176
            dtd->keepProcessing = dtd->standalone;
          }
        } else {
#line 5179
          dtd->keepProcessing = dtd->standalone;
        }
      } else {
        {
#line 5182
        entity->open = (XML_Bool )1;
#line 5183
        result = storeEntityValue___0(parser, parser->m_internalEncoding, (char const   *)((char *)entity->textPtr),
                                      (char const   *)((char *)(entity->textPtr + entity->textLen)));
#line 5188
        entity->open = (XML_Bool )0;
        }
#line 5189
        if (result) {
#line 5190
          goto endEntityValue;
        }
      }
#line 5192
      goto switch_break;
    }
#line 5197
    parser->m_eventPtr = entityTextPtr;
#line 5198
    result = (enum XML_Error )10;
#line 5199
    goto endEntityValue;
    case_neg_4: /* CIL Label */ 
#line 5201
    result = (enum XML_Error )0;
#line 5202
    goto endEntityValue;
    case_6: /* CIL Label */ 
    case_9: /* CIL Label */ 
    {
#line 5205
    tmp___4 = poolAppend___0(pool, enc, entityTextPtr, next);
    }
#line 5205
    if (! tmp___4) {
#line 5206
      result = (enum XML_Error )1;
#line 5207
      goto endEntityValue;
    }
#line 5209
    goto switch_break;
    case_neg_3: /* CIL Label */ 
#line 5211
    next = entityTextPtr + enc->minBytesPerChar;
    case_7: /* CIL Label */ 
#line 5214
    if ((unsigned long )pool->end == (unsigned long )pool->ptr) {
      {
#line 5214
      tmp___5 = poolGrow___0(pool);
      }
#line 5214
      if (! tmp___5) {
#line 5215
        result = (enum XML_Error )1;
#line 5216
        goto endEntityValue;
      }
    }
#line 5218
    tmp___6 = pool->ptr;
#line 5218
    (pool->ptr) ++;
#line 5218
    *tmp___6 = (XML_Char )10;
#line 5219
    goto switch_break;
    case_10: /* CIL Label */ 
    {
#line 5224
    tmp___7 = (*(enc->charRefNumber))(enc, entityTextPtr);
#line 5224
    n = tmp___7;
    }
#line 5225
    if (n < 0) {
#line 5226
      if ((unsigned long )enc == (unsigned long )parser->m_encoding) {
#line 5227
        parser->m_eventPtr = entityTextPtr;
      }
#line 5228
      result = (enum XML_Error )14;
#line 5229
      goto endEntityValue;
    }
    {
#line 5231
    n = XmlUtf8Encode(n, buf);
    }
#line 5232
    if (! n) {
#line 5233
      if ((unsigned long )enc == (unsigned long )parser->m_encoding) {
#line 5234
        parser->m_eventPtr = entityTextPtr;
      }
#line 5235
      result = (enum XML_Error )14;
#line 5236
      goto endEntityValue;
    }
#line 5238
    i = 0;
    {
#line 5238
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 5238
      if (! (i < n)) {
#line 5238
        goto while_break___0;
      }
#line 5239
      if ((unsigned long )pool->end == (unsigned long )pool->ptr) {
        {
#line 5239
        tmp___8 = poolGrow___0(pool);
        }
#line 5239
        if (! tmp___8) {
#line 5240
          result = (enum XML_Error )1;
#line 5241
          goto endEntityValue;
        }
      }
#line 5243
      tmp___9 = pool->ptr;
#line 5243
      (pool->ptr) ++;
#line 5243
      *tmp___9 = buf[i];
#line 5238
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 5246
    goto switch_break;
    case_neg_1: /* CIL Label */ 
#line 5248
    if ((unsigned long )enc == (unsigned long )parser->m_encoding) {
#line 5249
      parser->m_eventPtr = entityTextPtr;
    }
#line 5250
    result = (enum XML_Error )4;
#line 5251
    goto endEntityValue;
    case_0: /* CIL Label */ 
#line 5253
    if ((unsigned long )enc == (unsigned long )parser->m_encoding) {
#line 5254
      parser->m_eventPtr = next;
    }
#line 5255
    result = (enum XML_Error )4;
#line 5256
    goto endEntityValue;
    switch_default: /* CIL Label */ 
#line 5258
    if ((unsigned long )enc == (unsigned long )parser->m_encoding) {
#line 5259
      parser->m_eventPtr = entityTextPtr;
    }
#line 5260
    result = (enum XML_Error )23;
#line 5261
    goto endEntityValue;
    switch_break: /* CIL Label */ ;
    }
#line 5263
    entityTextPtr = next;
  }
  while_break: /* CIL Label */ ;
  }
  endEntityValue: 
#line 5267
  parser->m_prologState.inEntityValue = oldInEntityValue;
#line 5269
  return (result);
}
}
#line 5272 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlparse.c"
static void normalizeLines___0(XML_Char *s ) 
{ 
  XML_Char *p ;
  XML_Char *tmp ;
  XML_Char *tmp___0 ;
  XML_Char *tmp___1 ;

  {
  {
#line 5276
  while (1) {
    while_continue: /* CIL Label */ ;
#line 5277
    if ((int )*s == 0) {
#line 5278
      return;
    }
#line 5279
    if ((int )*s == 13) {
#line 5280
      goto while_break;
    }
#line 5276
    s ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 5282
  p = s;
  {
#line 5283
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 5284
    if ((int )*s == 13) {
#line 5285
      tmp = p;
#line 5285
      p ++;
#line 5285
      *tmp = (XML_Char )10;
#line 5286
      s ++;
#line 5286
      if ((int )*s == 10) {
#line 5287
        s ++;
      }
    } else {
#line 5290
      tmp___0 = p;
#line 5290
      p ++;
#line 5290
      tmp___1 = s;
#line 5290
      s ++;
#line 5290
      *tmp___0 = *tmp___1;
    }
#line 5283
    if (! *s) {
#line 5283
      goto while_break___0;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 5292
  *p = (XML_Char )'\000';
#line 5293
  return;
}
}
#line 5295 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlparse.c"
static int reportProcessingInstruction___0(XML_Parser parser , ENCODING const   *enc ,
                                           char const   *start , char const   *end ) 
{ 
  XML_Char const   *target ;
  XML_Char *data ;
  char const   *tem ;
  int tmp ;
  XML_Char *tmp___0 ;
  char const   *tmp___1 ;

  {
#line 5302
  if (! parser->m_processingInstructionHandler) {
#line 5303
    if (parser->m_defaultHandler) {
      {
#line 5304
      reportDefault___0(parser, enc, start, end);
      }
    }
#line 5305
    return (1);
  }
  {
#line 5307
  start += enc->minBytesPerChar * 2;
#line 5308
  tmp = (*(enc->nameLength))(enc, start);
#line 5308
  tem = start + tmp;
#line 5309
  tmp___0 = poolStoreString___0(& parser->m_tempPool, enc, start, tem);
#line 5309
  target = (XML_Char const   *)tmp___0;
  }
#line 5310
  if (! target) {
#line 5311
    return (0);
  }
  {
#line 5312
  parser->m_tempPool.start = parser->m_tempPool.ptr;
#line 5313
  tmp___1 = (*(enc->skipS))(enc, tem);
#line 5313
  data = poolStoreString___0(& parser->m_tempPool, enc, tmp___1, end - enc->minBytesPerChar * 2);
  }
#line 5316
  if (! data) {
#line 5317
    return (0);
  }
  {
#line 5318
  normalizeLines___0(data);
#line 5319
  (*(parser->m_processingInstructionHandler))(parser->m_handlerArg, target, (XML_Char const   *)data);
#line 5320
  poolClear___0(& parser->m_tempPool);
  }
#line 5321
  return (1);
}
}
#line 5324 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlparse.c"
static int reportComment___0(XML_Parser parser , ENCODING const   *enc , char const   *start ,
                             char const   *end ) 
{ 
  XML_Char *data ;

  {
#line 5329
  if (! parser->m_commentHandler) {
#line 5330
    if (parser->m_defaultHandler) {
      {
#line 5331
      reportDefault___0(parser, enc, start, end);
      }
    }
#line 5332
    return (1);
  }
  {
#line 5334
  data = poolStoreString___0(& parser->m_tempPool, enc, start + enc->minBytesPerChar * 4,
                             end - enc->minBytesPerChar * 3);
  }
#line 5338
  if (! data) {
#line 5339
    return (0);
  }
  {
#line 5340
  normalizeLines___0(data);
#line 5341
  (*(parser->m_commentHandler))(parser->m_handlerArg, (XML_Char const   *)data);
#line 5342
  poolClear___0(& parser->m_tempPool);
  }
#line 5343
  return (1);
}
}
#line 5346 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlparse.c"
static void reportDefault___0(XML_Parser parser , ENCODING const   *enc , char const   *s ,
                              char const   *end ) 
{ 
  char const   **eventPP ;
  char const   **eventEndPP ;
  ICHAR *dataPtr ;

  {
#line 5350
  if (! enc->isUtf8) {
#line 5353
    if ((unsigned long )enc == (unsigned long )parser->m_encoding) {
#line 5354
      eventPP = & parser->m_eventPtr;
#line 5355
      eventEndPP = & parser->m_eventEndPtr;
    } else {
#line 5358
      eventPP = & (parser->m_openInternalEntities)->internalEventPtr;
#line 5359
      eventEndPP = & (parser->m_openInternalEntities)->internalEventEndPtr;
    }
    {
#line 5361
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 5362
      dataPtr = parser->m_dataBuf;
#line 5363
      (*(enc->utf8Convert))(enc, & s, end, & dataPtr, (char const   *)parser->m_dataBufEnd);
#line 5364
      *eventEndPP = s;
#line 5365
      (*(parser->m_defaultHandler))(parser->m_handlerArg, (XML_Char const   *)parser->m_dataBuf,
                                    (int )(dataPtr - parser->m_dataBuf));
#line 5366
      *eventPP = s;
      }
#line 5361
      if (! ((unsigned long )s != (unsigned long )end)) {
#line 5361
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
  } else {
    {
#line 5370
    (*(parser->m_defaultHandler))(parser->m_handlerArg, (XML_Char const   *)((XML_Char *)s),
                                  (int )((XML_Char *)end - (XML_Char *)s));
    }
  }
#line 5371
  return;
}
}
#line 5374 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlparse.c"
static int defineAttribute___0(ELEMENT_TYPE *type , ATTRIBUTE_ID *attId , XML_Bool isCdata ,
                               XML_Bool isId , XML_Char const   *value , XML_Parser parser ) 
{ 
  DEFAULT_ATTRIBUTE *att ;
  int i ;
  void *tmp ;
  DEFAULT_ATTRIBUTE *temp ;
  int count ;
  void *tmp___0 ;

  {
#line 5379
  if (value) {
#line 5379
    goto _L;
  } else
#line 5379
  if (isId) {
    _L: /* CIL Label */ 
#line 5383
    i = 0;
    {
#line 5383
    while (1) {
      while_continue: /* CIL Label */ ;
#line 5383
      if (! (i < type->nDefaultAtts)) {
#line 5383
        goto while_break;
      }
#line 5384
      if ((unsigned long )attId == (unsigned long )(type->defaultAtts + i)->id) {
#line 5385
        return (1);
      }
#line 5383
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 5386
    if (isId) {
#line 5386
      if (! type->idAtt) {
#line 5386
        if (! attId->xmlns) {
#line 5387
          type->idAtt = (ATTRIBUTE_ID const   *)attId;
        }
      }
    }
  }
#line 5389
  if (type->nDefaultAtts == type->allocDefaultAtts) {
#line 5390
    if (type->allocDefaultAtts == 0) {
      {
#line 5391
      type->allocDefaultAtts = 8;
#line 5392
      tmp = (*(parser->m_mem.malloc_fcn))((unsigned long )type->allocDefaultAtts * sizeof(DEFAULT_ATTRIBUTE ));
#line 5392
      type->defaultAtts = (DEFAULT_ATTRIBUTE *)tmp;
      }
#line 5394
      if (! type->defaultAtts) {
#line 5395
        return (0);
      }
    } else {
      {
#line 5399
      count = type->allocDefaultAtts * 2;
#line 5400
      tmp___0 = (*(parser->m_mem.realloc_fcn))((void *)type->defaultAtts, (unsigned long )count * sizeof(DEFAULT_ATTRIBUTE ));
#line 5400
      temp = (DEFAULT_ATTRIBUTE *)tmp___0;
      }
#line 5402
      if ((unsigned long )temp == (unsigned long )((void *)0)) {
#line 5403
        return (0);
      }
#line 5404
      type->allocDefaultAtts = count;
#line 5405
      type->defaultAtts = temp;
    }
  }
#line 5408
  att = type->defaultAtts + type->nDefaultAtts;
#line 5409
  att->id = (ATTRIBUTE_ID const   *)attId;
#line 5410
  att->value = value;
#line 5411
  att->isCdata = isCdata;
#line 5412
  if (! isCdata) {
#line 5413
    attId->maybeTokenized = (XML_Bool )1;
  }
#line 5414
  (type->nDefaultAtts) ++;
#line 5415
  return (1);
}
}
#line 5418 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlparse.c"
static int setElementTypePrefix___0(XML_Parser parser , ELEMENT_TYPE *elementType ) 
{ 
  DTD *dtd ;
  XML_Char const   *name ;
  PREFIX *prefix ;
  XML_Char const   *s ;
  XML_Char *tmp___0 ;
  int tmp___1 ;
  XML_Bool tmp___2 ;
  XML_Char *tmp___4 ;
  int tmp___5 ;
  XML_Bool tmp___6 ;
  NAMED *tmp___7 ;

  {
#line 5421
  dtd = parser->m_dtd;
#line 5423
  name = elementType->name;
  {
#line 5423
  while (1) {
    while_continue: /* CIL Label */ ;
#line 5423
    if (! *name) {
#line 5423
      goto while_break;
    }
#line 5424
    if ((int const   )*name == 58) {
#line 5427
      s = elementType->name;
      {
#line 5427
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 5427
        if (! ((unsigned long )s != (unsigned long )name)) {
#line 5427
          goto while_break___0;
        }
#line 5428
        if ((unsigned long )dtd->pool.ptr == (unsigned long )dtd->pool.end) {
          {
#line 5428
          tmp___2 = poolGrow___0(& dtd->pool);
          }
#line 5428
          if (tmp___2) {
#line 5428
            tmp___0 = dtd->pool.ptr;
#line 5428
            (dtd->pool.ptr) ++;
#line 5428
            *tmp___0 = (XML_Char )*s;
#line 5428
            tmp___1 = 1;
          } else {
#line 5428
            tmp___1 = 0;
          }
        } else {
#line 5428
          tmp___0 = dtd->pool.ptr;
#line 5428
          (dtd->pool.ptr) ++;
#line 5428
          *tmp___0 = (XML_Char )*s;
#line 5428
          tmp___1 = 1;
        }
#line 5428
        if (! tmp___1) {
#line 5429
          return (0);
        }
#line 5427
        s ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 5431
      if ((unsigned long )dtd->pool.ptr == (unsigned long )dtd->pool.end) {
        {
#line 5431
        tmp___6 = poolGrow___0(& dtd->pool);
        }
#line 5431
        if (tmp___6) {
#line 5431
          tmp___4 = dtd->pool.ptr;
#line 5431
          (dtd->pool.ptr) ++;
#line 5431
          *tmp___4 = (XML_Char )'\000';
#line 5431
          tmp___5 = 1;
        } else {
#line 5431
          tmp___5 = 0;
        }
      } else {
#line 5431
        tmp___4 = dtd->pool.ptr;
#line 5431
        (dtd->pool.ptr) ++;
#line 5431
        *tmp___4 = (XML_Char )'\000';
#line 5431
        tmp___5 = 1;
      }
#line 5431
      if (! tmp___5) {
#line 5432
        return (0);
      }
      {
#line 5433
      tmp___7 = lookup___0(parser, & dtd->prefixes, (KEY )dtd->pool.start, sizeof(PREFIX ));
#line 5433
      prefix = (PREFIX *)tmp___7;
      }
#line 5435
      if (! prefix) {
#line 5436
        return (0);
      }
#line 5437
      if ((unsigned long )prefix->name == (unsigned long )dtd->pool.start) {
#line 5438
        dtd->pool.start = dtd->pool.ptr;
      } else {
#line 5440
        dtd->pool.ptr = dtd->pool.start;
      }
#line 5441
      elementType->prefix = prefix;
    }
#line 5423
    name ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 5445
  return (1);
}
}
#line 5448 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlparse.c"
static ATTRIBUTE_ID *getAttributeId___0(XML_Parser parser , ENCODING const   *enc ,
                                        char const   *start , char const   *end ) 
{ 
  DTD *dtd ;
  ATTRIBUTE_ID *id ;
  XML_Char const   *name ;
  XML_Char *tmp___0 ;
  int tmp___1 ;
  XML_Bool tmp___2 ;
  XML_Char *tmp___3 ;
  NAMED *tmp___4 ;
  NAMED *tmp___5 ;
  int i ;
  int j ;
  XML_Char *tmp___7 ;
  int tmp___8 ;
  XML_Bool tmp___9 ;
  XML_Char *tmp___11 ;
  int tmp___12 ;
  XML_Bool tmp___13 ;
  NAMED *tmp___14 ;

  {
#line 5452
  dtd = parser->m_dtd;
#line 5455
  if ((unsigned long )dtd->pool.ptr == (unsigned long )dtd->pool.end) {
    {
#line 5455
    tmp___2 = poolGrow___0(& dtd->pool);
    }
#line 5455
    if (tmp___2) {
#line 5455
      tmp___0 = dtd->pool.ptr;
#line 5455
      (dtd->pool.ptr) ++;
#line 5455
      *tmp___0 = (XML_Char )'\000';
#line 5455
      tmp___1 = 1;
    } else {
#line 5455
      tmp___1 = 0;
    }
  } else {
#line 5455
    tmp___0 = dtd->pool.ptr;
#line 5455
    (dtd->pool.ptr) ++;
#line 5455
    *tmp___0 = (XML_Char )'\000';
#line 5455
    tmp___1 = 1;
  }
#line 5455
  if (! tmp___1) {
#line 5456
    return ((ATTRIBUTE_ID *)((void *)0));
  }
  {
#line 5457
  tmp___3 = poolStoreString___0(& dtd->pool, enc, start, end);
#line 5457
  name = (XML_Char const   *)tmp___3;
  }
#line 5458
  if (! name) {
#line 5459
    return ((ATTRIBUTE_ID *)((void *)0));
  }
  {
#line 5461
  name ++;
#line 5462
  tmp___4 = lookup___0(parser, & dtd->attributeIds, name, sizeof(ATTRIBUTE_ID ));
#line 5462
  id = (ATTRIBUTE_ID *)tmp___4;
  }
#line 5463
  if (! id) {
#line 5464
    return ((ATTRIBUTE_ID *)((void *)0));
  }
#line 5465
  if ((unsigned long )id->name != (unsigned long )name) {
#line 5466
    dtd->pool.ptr = dtd->pool.start;
  } else {
#line 5468
    dtd->pool.start = dtd->pool.ptr;
#line 5469
    if (! (! parser->m_ns)) {
#line 5471
      if ((int const   )*(name + 0) == 120) {
#line 5471
        if ((int const   )*(name + 1) == 109) {
#line 5471
          if ((int const   )*(name + 2) == 108) {
#line 5471
            if ((int const   )*(name + 3) == 110) {
#line 5471
              if ((int const   )*(name + 4) == 115) {
#line 5471
                if ((int const   )*(name + 5) == 0) {
#line 5471
                  goto _L___0;
                } else
#line 5471
                if ((int const   )*(name + 5) == 58) {
                  _L___0: /* CIL Label */ 
#line 5477
                  if ((int const   )*(name + 5) == 0) {
#line 5478
                    id->prefix = & dtd->defaultPrefix;
                  } else {
                    {
#line 5480
                    tmp___5 = lookup___0(parser, & dtd->prefixes, name + 6, sizeof(PREFIX ));
#line 5480
                    id->prefix = (PREFIX *)tmp___5;
                    }
                  }
#line 5481
                  id->xmlns = (XML_Bool )1;
                } else {
#line 5471
                  goto _L___4;
                }
              } else {
#line 5471
                goto _L___4;
              }
            } else {
#line 5471
              goto _L___4;
            }
          } else {
#line 5471
            goto _L___4;
          }
        } else {
#line 5471
          goto _L___4;
        }
      } else {
        _L___4: /* CIL Label */ 
#line 5485
        i = 0;
        {
#line 5485
        while (1) {
          while_continue: /* CIL Label */ ;
#line 5485
          if (! *(name + i)) {
#line 5485
            goto while_break;
          }
#line 5487
          if ((int const   )*(name + i) == 58) {
#line 5489
            j = 0;
            {
#line 5489
            while (1) {
              while_continue___0: /* CIL Label */ ;
#line 5489
              if (! (j < i)) {
#line 5489
                goto while_break___0;
              }
#line 5490
              if ((unsigned long )dtd->pool.ptr == (unsigned long )dtd->pool.end) {
                {
#line 5490
                tmp___9 = poolGrow___0(& dtd->pool);
                }
#line 5490
                if (tmp___9) {
#line 5490
                  tmp___7 = dtd->pool.ptr;
#line 5490
                  (dtd->pool.ptr) ++;
#line 5490
                  *tmp___7 = (XML_Char )*(name + j);
#line 5490
                  tmp___8 = 1;
                } else {
#line 5490
                  tmp___8 = 0;
                }
              } else {
#line 5490
                tmp___7 = dtd->pool.ptr;
#line 5490
                (dtd->pool.ptr) ++;
#line 5490
                *tmp___7 = (XML_Char )*(name + j);
#line 5490
                tmp___8 = 1;
              }
#line 5490
              if (! tmp___8) {
#line 5491
                return ((ATTRIBUTE_ID *)((void *)0));
              }
#line 5489
              j ++;
            }
            while_break___0: /* CIL Label */ ;
            }
#line 5493
            if ((unsigned long )dtd->pool.ptr == (unsigned long )dtd->pool.end) {
              {
#line 5493
              tmp___13 = poolGrow___0(& dtd->pool);
              }
#line 5493
              if (tmp___13) {
#line 5493
                tmp___11 = dtd->pool.ptr;
#line 5493
                (dtd->pool.ptr) ++;
#line 5493
                *tmp___11 = (XML_Char )'\000';
#line 5493
                tmp___12 = 1;
              } else {
#line 5493
                tmp___12 = 0;
              }
            } else {
#line 5493
              tmp___11 = dtd->pool.ptr;
#line 5493
              (dtd->pool.ptr) ++;
#line 5493
              *tmp___11 = (XML_Char )'\000';
#line 5493
              tmp___12 = 1;
            }
#line 5493
            if (! tmp___12) {
#line 5494
              return ((ATTRIBUTE_ID *)((void *)0));
            }
            {
#line 5495
            tmp___14 = lookup___0(parser, & dtd->prefixes, (KEY )dtd->pool.start,
                                  sizeof(PREFIX ));
#line 5495
            id->prefix = (PREFIX *)tmp___14;
            }
#line 5497
            if ((unsigned long )(id->prefix)->name == (unsigned long )dtd->pool.start) {
#line 5498
              dtd->pool.start = dtd->pool.ptr;
            } else {
#line 5500
              dtd->pool.ptr = dtd->pool.start;
            }
#line 5501
            goto while_break;
          }
#line 5485
          i ++;
        }
        while_break: /* CIL Label */ ;
        }
      }
    }
  }
#line 5506
  return (id);
}
}
#line 5511 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlparse.c"
static XML_Char const   *getContext___0(XML_Parser parser ) 
{ 
  DTD *dtd ;
  HASH_TABLE_ITER iter ;
  XML_Bool needSep ;
  int i ;
  int len ;
  XML_Char *tmp___0 ;
  int tmp___1 ;
  XML_Bool tmp___2 ;
  XML_Char *tmp___4 ;
  int tmp___5 ;
  XML_Bool tmp___6 ;
  int i___0 ;
  int len___0 ;
  XML_Char const   *s ;
  PREFIX *prefix ;
  NAMED *tmp___7 ;
  XML_Char *tmp___9 ;
  int tmp___10 ;
  XML_Bool tmp___11 ;
  XML_Char *tmp___13 ;
  int tmp___14 ;
  XML_Bool tmp___15 ;
  XML_Char *tmp___17 ;
  int tmp___18 ;
  XML_Bool tmp___19 ;
  XML_Char *tmp___21 ;
  int tmp___22 ;
  XML_Bool tmp___23 ;
  XML_Char const   *s___0 ;
  ENTITY *e ;
  NAMED *tmp___24 ;
  XML_Char *tmp___26 ;
  int tmp___27 ;
  XML_Bool tmp___28 ;
  XML_Char *tmp___30 ;
  int tmp___31 ;
  XML_Bool tmp___32 ;
  XML_Char *tmp___34 ;
  int tmp___35 ;
  XML_Bool tmp___36 ;

  {
#line 5514
  dtd = parser->m_dtd;
#line 5516
  needSep = (XML_Bool )0;
#line 5518
  if (dtd->defaultPrefix.binding) {
#line 5521
    if ((unsigned long )parser->m_tempPool.ptr == (unsigned long )parser->m_tempPool.end) {
      {
#line 5521
      tmp___2 = poolGrow___0(& parser->m_tempPool);
      }
#line 5521
      if (tmp___2) {
#line 5521
        tmp___0 = parser->m_tempPool.ptr;
#line 5521
        (parser->m_tempPool.ptr) ++;
#line 5521
        *tmp___0 = (XML_Char )61;
#line 5521
        tmp___1 = 1;
      } else {
#line 5521
        tmp___1 = 0;
      }
    } else {
#line 5521
      tmp___0 = parser->m_tempPool.ptr;
#line 5521
      (parser->m_tempPool.ptr) ++;
#line 5521
      *tmp___0 = (XML_Char )61;
#line 5521
      tmp___1 = 1;
    }
#line 5521
    if (! tmp___1) {
#line 5522
      return ((XML_Char const   *)((void *)0));
    }
#line 5523
    len = (dtd->defaultPrefix.binding)->uriLen;
#line 5524
    if (parser->m_namespaceSeparator) {
#line 5525
      len --;
    }
#line 5526
    i = 0;
    {
#line 5526
    while (1) {
      while_continue: /* CIL Label */ ;
#line 5526
      if (! (i < len)) {
#line 5526
        goto while_break;
      }
#line 5527
      if ((unsigned long )parser->m_tempPool.ptr == (unsigned long )parser->m_tempPool.end) {
        {
#line 5527
        tmp___6 = poolGrow___0(& parser->m_tempPool);
        }
#line 5527
        if (tmp___6) {
#line 5527
          tmp___4 = parser->m_tempPool.ptr;
#line 5527
          (parser->m_tempPool.ptr) ++;
#line 5527
          *tmp___4 = *((dtd->defaultPrefix.binding)->uri + i);
#line 5527
          tmp___5 = 1;
        } else {
#line 5527
          tmp___5 = 0;
        }
      } else {
#line 5527
        tmp___4 = parser->m_tempPool.ptr;
#line 5527
        (parser->m_tempPool.ptr) ++;
#line 5527
        *tmp___4 = *((dtd->defaultPrefix.binding)->uri + i);
#line 5527
        tmp___5 = 1;
      }
#line 5527
      if (! tmp___5) {
#line 5528
        return ((XML_Char const   *)((void *)0));
      }
#line 5526
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 5529
    needSep = (XML_Bool )1;
  }
  {
#line 5532
  hashTableIterInit___0(& iter, (HASH_TABLE const   *)(& dtd->prefixes));
  }
  {
#line 5533
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 5537
    tmp___7 = hashTableIterNext___0(& iter);
#line 5537
    prefix = (PREFIX *)tmp___7;
    }
#line 5538
    if (! prefix) {
#line 5539
      goto while_break___0;
    }
#line 5540
    if (! prefix->binding) {
#line 5541
      goto __Cont;
    }
#line 5542
    if (needSep) {
#line 5542
      if ((unsigned long )parser->m_tempPool.ptr == (unsigned long )parser->m_tempPool.end) {
        {
#line 5542
        tmp___11 = poolGrow___0(& parser->m_tempPool);
        }
#line 5542
        if (tmp___11) {
#line 5542
          tmp___9 = parser->m_tempPool.ptr;
#line 5542
          (parser->m_tempPool.ptr) ++;
#line 5542
          *tmp___9 = (XML_Char )12;
#line 5542
          tmp___10 = 1;
        } else {
#line 5542
          tmp___10 = 0;
        }
      } else {
#line 5542
        tmp___9 = parser->m_tempPool.ptr;
#line 5542
        (parser->m_tempPool.ptr) ++;
#line 5542
        *tmp___9 = (XML_Char )12;
#line 5542
        tmp___10 = 1;
      }
#line 5542
      if (! tmp___10) {
#line 5543
        return ((XML_Char const   *)((void *)0));
      }
    }
#line 5544
    s = prefix->name;
    {
#line 5544
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 5544
      if (! *s) {
#line 5544
        goto while_break___1;
      }
#line 5545
      if ((unsigned long )parser->m_tempPool.ptr == (unsigned long )parser->m_tempPool.end) {
        {
#line 5545
        tmp___15 = poolGrow___0(& parser->m_tempPool);
        }
#line 5545
        if (tmp___15) {
#line 5545
          tmp___13 = parser->m_tempPool.ptr;
#line 5545
          (parser->m_tempPool.ptr) ++;
#line 5545
          *tmp___13 = (XML_Char )*s;
#line 5545
          tmp___14 = 1;
        } else {
#line 5545
          tmp___14 = 0;
        }
      } else {
#line 5545
        tmp___13 = parser->m_tempPool.ptr;
#line 5545
        (parser->m_tempPool.ptr) ++;
#line 5545
        *tmp___13 = (XML_Char )*s;
#line 5545
        tmp___14 = 1;
      }
#line 5545
      if (! tmp___14) {
#line 5546
        return ((XML_Char const   *)((void *)0));
      }
#line 5544
      s ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 5547
    if ((unsigned long )parser->m_tempPool.ptr == (unsigned long )parser->m_tempPool.end) {
      {
#line 5547
      tmp___19 = poolGrow___0(& parser->m_tempPool);
      }
#line 5547
      if (tmp___19) {
#line 5547
        tmp___17 = parser->m_tempPool.ptr;
#line 5547
        (parser->m_tempPool.ptr) ++;
#line 5547
        *tmp___17 = (XML_Char )61;
#line 5547
        tmp___18 = 1;
      } else {
#line 5547
        tmp___18 = 0;
      }
    } else {
#line 5547
      tmp___17 = parser->m_tempPool.ptr;
#line 5547
      (parser->m_tempPool.ptr) ++;
#line 5547
      *tmp___17 = (XML_Char )61;
#line 5547
      tmp___18 = 1;
    }
#line 5547
    if (! tmp___18) {
#line 5548
      return ((XML_Char const   *)((void *)0));
    }
#line 5549
    len___0 = (prefix->binding)->uriLen;
#line 5550
    if (parser->m_namespaceSeparator) {
#line 5551
      len___0 --;
    }
#line 5552
    i___0 = 0;
    {
#line 5552
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 5552
      if (! (i___0 < len___0)) {
#line 5552
        goto while_break___2;
      }
#line 5553
      if ((unsigned long )parser->m_tempPool.ptr == (unsigned long )parser->m_tempPool.end) {
        {
#line 5553
        tmp___23 = poolGrow___0(& parser->m_tempPool);
        }
#line 5553
        if (tmp___23) {
#line 5553
          tmp___21 = parser->m_tempPool.ptr;
#line 5553
          (parser->m_tempPool.ptr) ++;
#line 5553
          *tmp___21 = *((prefix->binding)->uri + i___0);
#line 5553
          tmp___22 = 1;
        } else {
#line 5553
          tmp___22 = 0;
        }
      } else {
#line 5553
        tmp___21 = parser->m_tempPool.ptr;
#line 5553
        (parser->m_tempPool.ptr) ++;
#line 5553
        *tmp___21 = *((prefix->binding)->uri + i___0);
#line 5553
        tmp___22 = 1;
      }
#line 5553
      if (! tmp___22) {
#line 5554
        return ((XML_Char const   *)((void *)0));
      }
#line 5552
      i___0 ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 5555
    needSep = (XML_Bool )1;
    __Cont: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 5559
  hashTableIterInit___0(& iter, (HASH_TABLE const   *)(& dtd->generalEntities));
  }
  {
#line 5560
  while (1) {
    while_continue___3: /* CIL Label */ ;
    {
#line 5562
    tmp___24 = hashTableIterNext___0(& iter);
#line 5562
    e = (ENTITY *)tmp___24;
    }
#line 5563
    if (! e) {
#line 5564
      goto while_break___3;
    }
#line 5565
    if (! e->open) {
#line 5566
      goto __Cont___0;
    }
#line 5567
    if (needSep) {
#line 5567
      if ((unsigned long )parser->m_tempPool.ptr == (unsigned long )parser->m_tempPool.end) {
        {
#line 5567
        tmp___28 = poolGrow___0(& parser->m_tempPool);
        }
#line 5567
        if (tmp___28) {
#line 5567
          tmp___26 = parser->m_tempPool.ptr;
#line 5567
          (parser->m_tempPool.ptr) ++;
#line 5567
          *tmp___26 = (XML_Char )12;
#line 5567
          tmp___27 = 1;
        } else {
#line 5567
          tmp___27 = 0;
        }
      } else {
#line 5567
        tmp___26 = parser->m_tempPool.ptr;
#line 5567
        (parser->m_tempPool.ptr) ++;
#line 5567
        *tmp___26 = (XML_Char )12;
#line 5567
        tmp___27 = 1;
      }
#line 5567
      if (! tmp___27) {
#line 5568
        return ((XML_Char const   *)((void *)0));
      }
    }
#line 5569
    s___0 = e->name;
    {
#line 5569
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 5569
      if (! *s___0) {
#line 5569
        goto while_break___4;
      }
#line 5570
      if ((unsigned long )parser->m_tempPool.ptr == (unsigned long )parser->m_tempPool.end) {
        {
#line 5570
        tmp___32 = poolGrow___0(& parser->m_tempPool);
        }
#line 5570
        if (tmp___32) {
#line 5570
          tmp___30 = parser->m_tempPool.ptr;
#line 5570
          (parser->m_tempPool.ptr) ++;
#line 5570
          *tmp___30 = (XML_Char )*s___0;
#line 5570
          tmp___31 = 1;
        } else {
#line 5570
          tmp___31 = 0;
        }
      } else {
#line 5570
        tmp___30 = parser->m_tempPool.ptr;
#line 5570
        (parser->m_tempPool.ptr) ++;
#line 5570
        *tmp___30 = (XML_Char )*s___0;
#line 5570
        tmp___31 = 1;
      }
#line 5570
      if (! tmp___31) {
#line 5571
        return ((XML_Char const   *)0);
      }
#line 5569
      s___0 ++;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 5572
    needSep = (XML_Bool )1;
    __Cont___0: /* CIL Label */ ;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 5575
  if ((unsigned long )parser->m_tempPool.ptr == (unsigned long )parser->m_tempPool.end) {
    {
#line 5575
    tmp___36 = poolGrow___0(& parser->m_tempPool);
    }
#line 5575
    if (tmp___36) {
#line 5575
      tmp___34 = parser->m_tempPool.ptr;
#line 5575
      (parser->m_tempPool.ptr) ++;
#line 5575
      *tmp___34 = (XML_Char )'\000';
#line 5575
      tmp___35 = 1;
    } else {
#line 5575
      tmp___35 = 0;
    }
  } else {
#line 5575
    tmp___34 = parser->m_tempPool.ptr;
#line 5575
    (parser->m_tempPool.ptr) ++;
#line 5575
    *tmp___34 = (XML_Char )'\000';
#line 5575
    tmp___35 = 1;
  }
#line 5575
  if (! tmp___35) {
#line 5576
    return ((XML_Char const   *)((void *)0));
  }
#line 5577
  return ((XML_Char const   *)parser->m_tempPool.start);
}
}
#line 5580 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlparse.c"
static XML_Bool setContext___0(XML_Parser parser , XML_Char const   *context ) 
{ 
  DTD *dtd ;
  XML_Char const   *s ;
  ENTITY *e ;
  XML_Char *tmp___0 ;
  int tmp___1 ;
  XML_Bool tmp___2 ;
  NAMED *tmp___3 ;
  PREFIX *prefix ;
  XML_Char *tmp___5 ;
  int tmp___6 ;
  XML_Bool tmp___7 ;
  NAMED *tmp___8 ;
  XML_Char *tmp___10 ;
  int tmp___11 ;
  XML_Bool tmp___12 ;
  XML_Char *tmp___14 ;
  int tmp___15 ;
  XML_Bool tmp___16 ;
  enum XML_Error tmp___17 ;
  XML_Char *tmp___19 ;
  int tmp___20 ;
  XML_Bool tmp___21 ;

  {
#line 5583
  dtd = parser->m_dtd;
#line 5584
  s = context;
  {
#line 5586
  while (1) {
    while_continue: /* CIL Label */ ;
#line 5586
    if (! ((int const   )*context != 0)) {
#line 5586
      goto while_break;
    }
#line 5587
    if ((int const   )*s == 12) {
#line 5587
      goto _L;
    } else
#line 5587
    if ((int const   )*s == 0) {
      _L: /* CIL Label */ 
#line 5589
      if ((unsigned long )parser->m_tempPool.ptr == (unsigned long )parser->m_tempPool.end) {
        {
#line 5589
        tmp___2 = poolGrow___0(& parser->m_tempPool);
        }
#line 5589
        if (tmp___2) {
#line 5589
          tmp___0 = parser->m_tempPool.ptr;
#line 5589
          (parser->m_tempPool.ptr) ++;
#line 5589
          *tmp___0 = (XML_Char )'\000';
#line 5589
          tmp___1 = 1;
        } else {
#line 5589
          tmp___1 = 0;
        }
      } else {
#line 5589
        tmp___0 = parser->m_tempPool.ptr;
#line 5589
        (parser->m_tempPool.ptr) ++;
#line 5589
        *tmp___0 = (XML_Char )'\000';
#line 5589
        tmp___1 = 1;
      }
#line 5589
      if (! tmp___1) {
#line 5590
        return ((XML_Bool )0);
      }
      {
#line 5591
      tmp___3 = lookup___0(parser, & dtd->generalEntities, (KEY )parser->m_tempPool.start,
                           (size_t )0);
#line 5591
      e = (ENTITY *)tmp___3;
      }
#line 5592
      if (e) {
#line 5593
        e->open = (XML_Bool )1;
      }
#line 5594
      if ((int const   )*s != 0) {
#line 5595
        s ++;
      }
#line 5596
      context = s;
#line 5597
      parser->m_tempPool.ptr = parser->m_tempPool.start;
    } else
#line 5599
    if ((int const   )*s == 61) {
#line 5601
      if (parser->m_tempPool.ptr - parser->m_tempPool.start == 0L) {
#line 5602
        prefix = & dtd->defaultPrefix;
      } else {
#line 5604
        if ((unsigned long )parser->m_tempPool.ptr == (unsigned long )parser->m_tempPool.end) {
          {
#line 5604
          tmp___7 = poolGrow___0(& parser->m_tempPool);
          }
#line 5604
          if (tmp___7) {
#line 5604
            tmp___5 = parser->m_tempPool.ptr;
#line 5604
            (parser->m_tempPool.ptr) ++;
#line 5604
            *tmp___5 = (XML_Char )'\000';
#line 5604
            tmp___6 = 1;
          } else {
#line 5604
            tmp___6 = 0;
          }
        } else {
#line 5604
          tmp___5 = parser->m_tempPool.ptr;
#line 5604
          (parser->m_tempPool.ptr) ++;
#line 5604
          *tmp___5 = (XML_Char )'\000';
#line 5604
          tmp___6 = 1;
        }
#line 5604
        if (! tmp___6) {
#line 5605
          return ((XML_Bool )0);
        }
        {
#line 5606
        tmp___8 = lookup___0(parser, & dtd->prefixes, (KEY )parser->m_tempPool.start,
                             sizeof(PREFIX ));
#line 5606
        prefix = (PREFIX *)tmp___8;
        }
#line 5608
        if (! prefix) {
#line 5609
          return ((XML_Bool )0);
        }
#line 5610
        if ((unsigned long )prefix->name == (unsigned long )parser->m_tempPool.start) {
          {
#line 5611
          prefix->name = poolCopyString___0(& dtd->pool, prefix->name);
          }
#line 5612
          if (! prefix->name) {
#line 5613
            return ((XML_Bool )0);
          }
        }
#line 5615
        parser->m_tempPool.ptr = parser->m_tempPool.start;
      }
#line 5617
      context = s + 1;
      {
#line 5617
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 5617
        if ((int const   )*context != 12) {
#line 5617
          if (! ((int const   )*context != 0)) {
#line 5617
            goto while_break___0;
          }
        } else {
#line 5617
          goto while_break___0;
        }
#line 5620
        if ((unsigned long )parser->m_tempPool.ptr == (unsigned long )parser->m_tempPool.end) {
          {
#line 5620
          tmp___12 = poolGrow___0(& parser->m_tempPool);
          }
#line 5620
          if (tmp___12) {
#line 5620
            tmp___10 = parser->m_tempPool.ptr;
#line 5620
            (parser->m_tempPool.ptr) ++;
#line 5620
            *tmp___10 = (XML_Char )*context;
#line 5620
            tmp___11 = 1;
          } else {
#line 5620
            tmp___11 = 0;
          }
        } else {
#line 5620
          tmp___10 = parser->m_tempPool.ptr;
#line 5620
          (parser->m_tempPool.ptr) ++;
#line 5620
          *tmp___10 = (XML_Char )*context;
#line 5620
          tmp___11 = 1;
        }
#line 5620
        if (! tmp___11) {
#line 5621
          return ((XML_Bool )0);
        }
#line 5617
        context ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 5622
      if ((unsigned long )parser->m_tempPool.ptr == (unsigned long )parser->m_tempPool.end) {
        {
#line 5622
        tmp___16 = poolGrow___0(& parser->m_tempPool);
        }
#line 5622
        if (tmp___16) {
#line 5622
          tmp___14 = parser->m_tempPool.ptr;
#line 5622
          (parser->m_tempPool.ptr) ++;
#line 5622
          *tmp___14 = (XML_Char )'\000';
#line 5622
          tmp___15 = 1;
        } else {
#line 5622
          tmp___15 = 0;
        }
      } else {
#line 5622
        tmp___14 = parser->m_tempPool.ptr;
#line 5622
        (parser->m_tempPool.ptr) ++;
#line 5622
        *tmp___14 = (XML_Char )'\000';
#line 5622
        tmp___15 = 1;
      }
#line 5622
      if (! tmp___15) {
#line 5623
        return ((XML_Bool )0);
      }
      {
#line 5624
      tmp___17 = addBinding___0(parser, prefix, (ATTRIBUTE_ID const   *)((void *)0),
                                (XML_Char const   *)parser->m_tempPool.start, & parser->m_inheritedBindings);
      }
#line 5624
      if ((unsigned int )tmp___17 != 0U) {
#line 5626
        return ((XML_Bool )0);
      }
#line 5627
      parser->m_tempPool.ptr = parser->m_tempPool.start;
#line 5628
      if ((int const   )*context != 0) {
#line 5629
        context ++;
      }
#line 5630
      s = context;
    } else {
#line 5633
      if ((unsigned long )parser->m_tempPool.ptr == (unsigned long )parser->m_tempPool.end) {
        {
#line 5633
        tmp___21 = poolGrow___0(& parser->m_tempPool);
        }
#line 5633
        if (tmp___21) {
#line 5633
          tmp___19 = parser->m_tempPool.ptr;
#line 5633
          (parser->m_tempPool.ptr) ++;
#line 5633
          *tmp___19 = (XML_Char )*s;
#line 5633
          tmp___20 = 1;
        } else {
#line 5633
          tmp___20 = 0;
        }
      } else {
#line 5633
        tmp___19 = parser->m_tempPool.ptr;
#line 5633
        (parser->m_tempPool.ptr) ++;
#line 5633
        *tmp___19 = (XML_Char )*s;
#line 5633
        tmp___20 = 1;
      }
#line 5633
      if (! tmp___20) {
#line 5634
        return ((XML_Bool )0);
      }
#line 5635
      s ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 5638
  return ((XML_Bool )1);
}
}
#line 5641 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlparse.c"
static void normalizePublicId___0(XML_Char *publicId ) 
{ 
  XML_Char *p ;
  XML_Char *s ;
  XML_Char *tmp ;
  XML_Char *tmp___0 ;

  {
#line 5644
  p = publicId;
#line 5646
  s = publicId;
  {
#line 5646
  while (1) {
    while_continue: /* CIL Label */ ;
#line 5646
    if (! *s) {
#line 5646
      goto while_break;
    }
    {
#line 5650
    if ((int )*s == 10) {
#line 5650
      goto case_10;
    }
#line 5650
    if ((int )*s == 13) {
#line 5650
      goto case_10;
    }
#line 5650
    if ((int )*s == 32) {
#line 5650
      goto case_10;
    }
#line 5654
    goto switch_default;
    case_10: /* CIL Label */ 
    case_13: /* CIL Label */ 
    case_32: /* CIL Label */ 
#line 5651
    if ((unsigned long )p != (unsigned long )publicId) {
#line 5651
      if ((int )*(p + -1) != 32) {
#line 5652
        tmp = p;
#line 5652
        p ++;
#line 5652
        *tmp = (XML_Char )32;
      }
    }
#line 5653
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 5655
    tmp___0 = p;
#line 5655
    p ++;
#line 5655
    *tmp___0 = *s;
    switch_break: /* CIL Label */ ;
    }
#line 5646
    s ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 5658
  if ((unsigned long )p != (unsigned long )publicId) {
#line 5658
    if ((int )*(p + -1) == 32) {
#line 5659
      p --;
    }
  }
#line 5660
  *p = (XML_Char )'\000';
#line 5661
  return;
}
}
#line 5663 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlparse.c"
static DTD *dtdCreate___0(XML_Memory_Handling_Suite const   *ms ) 
{ 
  DTD *p ;
  void *tmp ;

  {
  {
#line 5666
  tmp = (*(ms->malloc_fcn))(sizeof(DTD ));
#line 5666
  p = (DTD *)tmp;
  }
#line 5667
  if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 5668
    return (p);
  }
  {
#line 5669
  poolInit___0(& p->pool, ms);
#line 5670
  poolInit___0(& p->entityValuePool, ms);
#line 5671
  hashTableInit___0(& p->generalEntities, ms);
#line 5672
  hashTableInit___0(& p->elementTypes, ms);
#line 5673
  hashTableInit___0(& p->attributeIds, ms);
#line 5674
  hashTableInit___0(& p->prefixes, ms);
#line 5676
  p->paramEntityRead = (XML_Bool )0;
#line 5677
  hashTableInit___0(& p->paramEntities, ms);
#line 5679
  p->defaultPrefix.name = (XML_Char const   *)((void *)0);
#line 5680
  p->defaultPrefix.binding = (BINDING *)((void *)0);
#line 5682
  p->in_eldecl = (XML_Bool )0;
#line 5683
  p->scaffIndex = (int *)((void *)0);
#line 5684
  p->scaffold = (CONTENT_SCAFFOLD *)((void *)0);
#line 5685
  p->scaffLevel = 0;
#line 5686
  p->scaffSize = 0U;
#line 5687
  p->scaffCount = 0U;
#line 5688
  p->contentStringLen = 0U;
#line 5690
  p->keepProcessing = (XML_Bool )1;
#line 5691
  p->hasParamEntityRefs = (XML_Bool )0;
#line 5692
  p->standalone = (XML_Bool )0;
  }
#line 5693
  return (p);
}
}
#line 5696 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlparse.c"
static void dtdReset___0(DTD *p , XML_Memory_Handling_Suite const   *ms ) 
{ 
  HASH_TABLE_ITER iter ;
  ELEMENT_TYPE *e ;
  NAMED *tmp ;

  {
  {
#line 5700
  hashTableIterInit___0(& iter, (HASH_TABLE const   *)(& p->elementTypes));
  }
  {
#line 5701
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 5702
    tmp = hashTableIterNext___0(& iter);
#line 5702
    e = (ELEMENT_TYPE *)tmp;
    }
#line 5703
    if (! e) {
#line 5704
      goto while_break;
    }
#line 5705
    if (e->allocDefaultAtts != 0) {
      {
#line 5706
      (*(ms->free_fcn))((void *)e->defaultAtts);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 5708
  hashTableClear___0(& p->generalEntities);
#line 5710
  p->paramEntityRead = (XML_Bool )0;
#line 5711
  hashTableClear___0(& p->paramEntities);
#line 5713
  hashTableClear___0(& p->elementTypes);
#line 5714
  hashTableClear___0(& p->attributeIds);
#line 5715
  hashTableClear___0(& p->prefixes);
#line 5716
  poolClear___0(& p->pool);
#line 5717
  poolClear___0(& p->entityValuePool);
#line 5718
  p->defaultPrefix.name = (XML_Char const   *)((void *)0);
#line 5719
  p->defaultPrefix.binding = (BINDING *)((void *)0);
#line 5721
  p->in_eldecl = (XML_Bool )0;
#line 5723
  (*(ms->free_fcn))((void *)p->scaffIndex);
#line 5724
  p->scaffIndex = (int *)((void *)0);
#line 5725
  (*(ms->free_fcn))((void *)p->scaffold);
#line 5726
  p->scaffold = (CONTENT_SCAFFOLD *)((void *)0);
#line 5728
  p->scaffLevel = 0;
#line 5729
  p->scaffSize = 0U;
#line 5730
  p->scaffCount = 0U;
#line 5731
  p->contentStringLen = 0U;
#line 5733
  p->keepProcessing = (XML_Bool )1;
#line 5734
  p->hasParamEntityRefs = (XML_Bool )0;
#line 5735
  p->standalone = (XML_Bool )0;
  }
#line 5736
  return;
}
}
#line 5738 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlparse.c"
static void dtdDestroy___0(DTD *p , XML_Bool isDocEntity , XML_Memory_Handling_Suite const   *ms ) 
{ 
  HASH_TABLE_ITER iter ;
  ELEMENT_TYPE *e ;
  NAMED *tmp ;

  {
  {
#line 5742
  hashTableIterInit___0(& iter, (HASH_TABLE const   *)(& p->elementTypes));
  }
  {
#line 5743
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 5744
    tmp = hashTableIterNext___0(& iter);
#line 5744
    e = (ELEMENT_TYPE *)tmp;
    }
#line 5745
    if (! e) {
#line 5746
      goto while_break;
    }
#line 5747
    if (e->allocDefaultAtts != 0) {
      {
#line 5748
      (*(ms->free_fcn))((void *)e->defaultAtts);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 5750
  hashTableDestroy___0(& p->generalEntities);
#line 5752
  hashTableDestroy___0(& p->paramEntities);
#line 5754
  hashTableDestroy___0(& p->elementTypes);
#line 5755
  hashTableDestroy___0(& p->attributeIds);
#line 5756
  hashTableDestroy___0(& p->prefixes);
#line 5757
  poolDestroy___0(& p->pool);
#line 5758
  poolDestroy___0(& p->entityValuePool);
  }
#line 5759
  if (isDocEntity) {
    {
#line 5760
    (*(ms->free_fcn))((void *)p->scaffIndex);
#line 5761
    (*(ms->free_fcn))((void *)p->scaffold);
    }
  }
  {
#line 5763
  (*(ms->free_fcn))((void *)p);
  }
#line 5764
  return;
}
}
#line 5769 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlparse.c"
static int dtdCopy___0(XML_Parser oldParser , DTD *newDtd , DTD const   *oldDtd ,
                       XML_Memory_Handling_Suite const   *ms ) 
{ 
  HASH_TABLE_ITER iter ;
  XML_Char const   *name ;
  PREFIX const   *oldP ;
  NAMED *tmp ;
  NAMED *tmp___0 ;
  ATTRIBUTE_ID *newA ;
  XML_Char const   *name___0 ;
  ATTRIBUTE_ID const   *oldA ;
  NAMED *tmp___1 ;
  XML_Char *tmp___3 ;
  int tmp___4 ;
  XML_Bool tmp___5 ;
  NAMED *tmp___6 ;
  NAMED *tmp___7 ;
  int i ;
  ELEMENT_TYPE *newE ;
  XML_Char const   *name___1 ;
  ELEMENT_TYPE const   *oldE ;
  NAMED *tmp___8 ;
  NAMED *tmp___9 ;
  void *tmp___10 ;
  NAMED *tmp___11 ;
  int tmp___12 ;
  NAMED *tmp___13 ;
  NAMED *tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;

  {
  {
#line 5776
  hashTableIterInit___0(& iter, & oldDtd->prefixes);
  }
  {
#line 5777
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 5779
    tmp = hashTableIterNext___0(& iter);
#line 5779
    oldP = (PREFIX const   *)((PREFIX *)tmp);
    }
#line 5780
    if (! oldP) {
#line 5781
      goto while_break;
    }
    {
#line 5782
    name = poolCopyString___0(& newDtd->pool, (XML_Char const   *)oldP->name);
    }
#line 5783
    if (! name) {
#line 5784
      return (0);
    }
    {
#line 5785
    tmp___0 = lookup___0(oldParser, & newDtd->prefixes, name, sizeof(PREFIX ));
    }
#line 5785
    if (! tmp___0) {
#line 5786
      return (0);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 5789
  hashTableIterInit___0(& iter, & oldDtd->attributeIds);
  }
  {
#line 5793
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 5796
    tmp___1 = hashTableIterNext___0(& iter);
#line 5796
    oldA = (ATTRIBUTE_ID const   *)((ATTRIBUTE_ID *)tmp___1);
    }
#line 5798
    if (! oldA) {
#line 5799
      goto while_break___0;
    }
#line 5801
    if ((unsigned long )newDtd->pool.ptr == (unsigned long )newDtd->pool.end) {
      {
#line 5801
      tmp___5 = poolGrow___0(& newDtd->pool);
      }
#line 5801
      if (tmp___5) {
#line 5801
        tmp___3 = newDtd->pool.ptr;
#line 5801
        (newDtd->pool.ptr) ++;
#line 5801
        *tmp___3 = (XML_Char )'\000';
#line 5801
        tmp___4 = 1;
      } else {
#line 5801
        tmp___4 = 0;
      }
    } else {
#line 5801
      tmp___3 = newDtd->pool.ptr;
#line 5801
      (newDtd->pool.ptr) ++;
#line 5801
      *tmp___3 = (XML_Char )'\000';
#line 5801
      tmp___4 = 1;
    }
#line 5801
    if (! tmp___4) {
#line 5802
      return (0);
    }
    {
#line 5803
    name___0 = poolCopyString___0(& newDtd->pool, (XML_Char const   *)oldA->name);
    }
#line 5804
    if (! name___0) {
#line 5805
      return (0);
    }
    {
#line 5806
    name___0 ++;
#line 5807
    tmp___6 = lookup___0(oldParser, & newDtd->attributeIds, name___0, sizeof(ATTRIBUTE_ID ));
#line 5807
    newA = (ATTRIBUTE_ID *)tmp___6;
    }
#line 5809
    if (! newA) {
#line 5810
      return (0);
    }
#line 5811
    newA->maybeTokenized = (XML_Bool )oldA->maybeTokenized;
#line 5812
    if (oldA->prefix) {
#line 5813
      newA->xmlns = (XML_Bool )oldA->xmlns;
#line 5814
      if ((unsigned long )oldA->prefix == (unsigned long )(& oldDtd->defaultPrefix)) {
#line 5815
        newA->prefix = & newDtd->defaultPrefix;
      } else {
        {
#line 5817
        tmp___7 = lookup___0(oldParser, & newDtd->prefixes, (oldA->prefix)->name,
                             (size_t )0);
#line 5817
        newA->prefix = (PREFIX *)tmp___7;
        }
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 5824
  hashTableIterInit___0(& iter, & oldDtd->elementTypes);
  }
  {
#line 5826
  while (1) {
    while_continue___1: /* CIL Label */ ;
    {
#line 5830
    tmp___8 = hashTableIterNext___0(& iter);
#line 5830
    oldE = (ELEMENT_TYPE const   *)((ELEMENT_TYPE *)tmp___8);
    }
#line 5831
    if (! oldE) {
#line 5832
      goto while_break___1;
    }
    {
#line 5833
    name___1 = poolCopyString___0(& newDtd->pool, (XML_Char const   *)oldE->name);
    }
#line 5834
    if (! name___1) {
#line 5835
      return (0);
    }
    {
#line 5836
    tmp___9 = lookup___0(oldParser, & newDtd->elementTypes, name___1, sizeof(ELEMENT_TYPE ));
#line 5836
    newE = (ELEMENT_TYPE *)tmp___9;
    }
#line 5838
    if (! newE) {
#line 5839
      return (0);
    }
#line 5840
    if (oldE->nDefaultAtts) {
      {
#line 5841
      tmp___10 = (*(ms->malloc_fcn))((unsigned long )oldE->nDefaultAtts * sizeof(DEFAULT_ATTRIBUTE ));
#line 5841
      newE->defaultAtts = (DEFAULT_ATTRIBUTE *)tmp___10;
      }
#line 5843
      if (! newE->defaultAtts) {
        {
#line 5844
        (*(ms->free_fcn))((void *)newE);
        }
#line 5845
        return (0);
      }
    }
#line 5848
    if (oldE->idAtt) {
      {
#line 5849
      tmp___11 = lookup___0(oldParser, & newDtd->attributeIds, (KEY )(oldE->idAtt)->name,
                            (size_t )0);
#line 5849
      newE->idAtt = (ATTRIBUTE_ID const   *)((ATTRIBUTE_ID *)tmp___11);
      }
    }
#line 5851
    tmp___12 = (int )oldE->nDefaultAtts;
#line 5851
    newE->nDefaultAtts = tmp___12;
#line 5851
    newE->allocDefaultAtts = tmp___12;
#line 5852
    if (oldE->prefix) {
      {
#line 5853
      tmp___13 = lookup___0(oldParser, & newDtd->prefixes, (oldE->prefix)->name, (size_t )0);
#line 5853
      newE->prefix = (PREFIX *)tmp___13;
      }
    }
#line 5855
    i = 0;
    {
#line 5855
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 5855
      if (! (i < newE->nDefaultAtts)) {
#line 5855
        goto while_break___2;
      }
      {
#line 5856
      tmp___14 = lookup___0(oldParser, & newDtd->attributeIds, (KEY )((oldE->defaultAtts + i)->id)->name,
                            (size_t )0);
#line 5856
      (newE->defaultAtts + i)->id = (ATTRIBUTE_ID const   *)((ATTRIBUTE_ID *)tmp___14);
#line 5858
      (newE->defaultAtts + i)->isCdata = (oldE->defaultAtts + i)->isCdata;
      }
#line 5859
      if ((oldE->defaultAtts + i)->value) {
        {
#line 5860
        (newE->defaultAtts + i)->value = poolCopyString___0(& newDtd->pool, (oldE->defaultAtts + i)->value);
        }
#line 5862
        if (! (newE->defaultAtts + i)->value) {
#line 5863
          return (0);
        }
      } else {
#line 5866
        (newE->defaultAtts + i)->value = (XML_Char const   *)((void *)0);
      }
#line 5855
      i ++;
    }
    while_break___2: /* CIL Label */ ;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 5871
  tmp___15 = copyEntityTable___0(oldParser, & newDtd->generalEntities, & newDtd->pool,
                                 & oldDtd->generalEntities);
  }
#line 5871
  if (! tmp___15) {
#line 5875
    return (0);
  }
  {
#line 5878
  tmp___16 = copyEntityTable___0(oldParser, & newDtd->paramEntities, & newDtd->pool,
                                 & oldDtd->paramEntities);
  }
#line 5878
  if (! tmp___16) {
#line 5882
    return (0);
  }
#line 5883
  newDtd->paramEntityRead = (XML_Bool )oldDtd->paramEntityRead;
#line 5886
  newDtd->keepProcessing = (XML_Bool )oldDtd->keepProcessing;
#line 5887
  newDtd->hasParamEntityRefs = (XML_Bool )oldDtd->hasParamEntityRefs;
#line 5888
  newDtd->standalone = (XML_Bool )oldDtd->standalone;
#line 5891
  newDtd->in_eldecl = (XML_Bool )oldDtd->in_eldecl;
#line 5892
  newDtd->scaffold = (CONTENT_SCAFFOLD *)oldDtd->scaffold;
#line 5893
  newDtd->contentStringLen = (unsigned int )oldDtd->contentStringLen;
#line 5894
  newDtd->scaffSize = (unsigned int )oldDtd->scaffSize;
#line 5895
  newDtd->scaffLevel = (int )oldDtd->scaffLevel;
#line 5896
  newDtd->scaffIndex = (int *)oldDtd->scaffIndex;
#line 5898
  return (1);
}
}
#line 5901 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlparse.c"
static int copyEntityTable___0(XML_Parser oldParser , HASH_TABLE *newTable , STRING_POOL *newPool ,
                               HASH_TABLE const   *oldTable ) 
{ 
  HASH_TABLE_ITER iter ;
  XML_Char const   *cachedOldBase ;
  XML_Char const   *cachedNewBase ;
  ENTITY *newE ;
  XML_Char const   *name ;
  ENTITY const   *oldE ;
  NAMED *tmp ;
  NAMED *tmp___0 ;
  XML_Char const   *tem ;
  XML_Char const   *tmp___1 ;
  XML_Char const   *tmp___2 ;
  XML_Char const   *tem___0 ;
  XML_Char const   *tmp___3 ;
  XML_Char const   *tem___1 ;
  XML_Char const   *tmp___4 ;

  {
  {
#line 5908
  cachedOldBase = (XML_Char const   *)((void *)0);
#line 5909
  cachedNewBase = (XML_Char const   *)((void *)0);
#line 5911
  hashTableIterInit___0(& iter, oldTable);
  }
  {
#line 5913
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 5916
    tmp = hashTableIterNext___0(& iter);
#line 5916
    oldE = (ENTITY const   *)((ENTITY *)tmp);
    }
#line 5917
    if (! oldE) {
#line 5918
      goto while_break;
    }
    {
#line 5919
    name = poolCopyString___0(newPool, (XML_Char const   *)oldE->name);
    }
#line 5920
    if (! name) {
#line 5921
      return (0);
    }
    {
#line 5922
    tmp___0 = lookup___0(oldParser, newTable, name, sizeof(ENTITY ));
#line 5922
    newE = (ENTITY *)tmp___0;
    }
#line 5923
    if (! newE) {
#line 5924
      return (0);
    }
#line 5925
    if (oldE->systemId) {
      {
#line 5926
      tmp___1 = poolCopyString___0(newPool, (XML_Char const   *)oldE->systemId);
#line 5926
      tem = tmp___1;
      }
#line 5927
      if (! tem) {
#line 5928
        return (0);
      }
#line 5929
      newE->systemId = tem;
#line 5930
      if (oldE->base) {
#line 5931
        if ((unsigned long )oldE->base == (unsigned long )cachedOldBase) {
#line 5932
          newE->base = cachedNewBase;
        } else {
          {
#line 5934
          cachedOldBase = (XML_Char const   *)oldE->base;
#line 5935
          tem = poolCopyString___0(newPool, cachedOldBase);
          }
#line 5936
          if (! tem) {
#line 5937
            return (0);
          }
#line 5938
          tmp___2 = tem;
#line 5938
          newE->base = tmp___2;
#line 5938
          cachedNewBase = tmp___2;
        }
      }
#line 5941
      if (oldE->publicId) {
        {
#line 5942
        tem = poolCopyString___0(newPool, (XML_Char const   *)oldE->publicId);
        }
#line 5943
        if (! tem) {
#line 5944
          return (0);
        }
#line 5945
        newE->publicId = tem;
      }
    } else {
      {
#line 5949
      tmp___3 = poolCopyStringN___0(newPool, (XML_Char const   *)oldE->textPtr, (int )oldE->textLen);
#line 5949
      tem___0 = tmp___3;
      }
#line 5951
      if (! tem___0) {
#line 5952
        return (0);
      }
#line 5953
      newE->textPtr = tem___0;
#line 5954
      newE->textLen = (int )oldE->textLen;
    }
#line 5956
    if (oldE->notation) {
      {
#line 5957
      tmp___4 = poolCopyString___0(newPool, (XML_Char const   *)oldE->notation);
#line 5957
      tem___1 = tmp___4;
      }
#line 5958
      if (! tem___1) {
#line 5959
        return (0);
      }
#line 5960
      newE->notation = tem___1;
    }
#line 5962
    newE->is_param = (XML_Bool )oldE->is_param;
#line 5963
    newE->is_internal = (XML_Bool )oldE->is_internal;
  }
  while_break: /* CIL Label */ ;
  }
#line 5965
  return (1);
}
}
#line 5970 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlparse.c"
static XML_Bool keyeq___0(KEY s1 , KEY s2 ) 
{ 


  {
  {
#line 5973
  while (1) {
    while_continue: /* CIL Label */ ;
#line 5973
    if (! ((int const   )*s1 == (int const   )*s2)) {
#line 5973
      goto while_break;
    }
#line 5974
    if ((int const   )*s1 == 0) {
#line 5975
      return ((XML_Bool )1);
    }
#line 5973
    s1 ++;
#line 5973
    s2 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 5976
  return ((XML_Bool )0);
}
}
#line 5979 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlparse.c"
static unsigned long hash___0(XML_Parser parser , KEY s ) 
{ 
  unsigned long h ;
  KEY tmp ;

  {
#line 5982
  h = parser->m_hash_secret_salt;
  {
#line 5983
  while (1) {
    while_continue: /* CIL Label */ ;
#line 5983
    if (! *s) {
#line 5983
      goto while_break;
    }
#line 5984
    tmp = s;
#line 5984
    s ++;
#line 5984
    h = h * 1000003UL ^ (unsigned long )((unsigned char )*tmp);
  }
  while_break: /* CIL Label */ ;
  }
#line 5985
  return (h);
}
}
#line 5988 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlparse.c"
static NAMED *lookup___0(XML_Parser parser , HASH_TABLE *table , KEY name , size_t createSize ) 
{ 
  size_t i ;
  size_t tsize ;
  void *tmp ;
  unsigned long tmp___0 ;
  unsigned long h ;
  unsigned long tmp___1 ;
  unsigned long mask ;
  unsigned char step ;
  XML_Bool tmp___2 ;
  unsigned char newPower ;
  size_t newSize ;
  unsigned long newMask ;
  size_t tsize___0 ;
  NAMED **newV ;
  void *tmp___3 ;
  unsigned long newHash ;
  unsigned long tmp___4 ;
  size_t j ;
  void *tmp___5 ;

  {
#line 5992
  if (table->size == 0UL) {
#line 5994
    if (! createSize) {
#line 5995
      return ((NAMED *)((void *)0));
    }
    {
#line 5996
    table->power = (unsigned char)6;
#line 5998
    table->size = 1UL << 6;
#line 5999
    tsize = table->size * sizeof(NAMED *);
#line 6000
    tmp = (*((table->mem)->malloc_fcn))(tsize);
#line 6000
    table->v = (NAMED **)tmp;
    }
#line 6001
    if (! table->v) {
#line 6002
      table->size = (size_t )0;
#line 6003
      return ((NAMED *)((void *)0));
    }
    {
#line 6005
    memset((void *)table->v, 0, tsize);
#line 6006
    tmp___0 = hash___0(parser, name);
#line 6006
    i = tmp___0 & (table->size - 1UL);
    }
  } else {
    {
#line 6009
    tmp___1 = hash___0(parser, name);
#line 6009
    h = tmp___1;
#line 6010
    mask = table->size - 1UL;
#line 6011
    step = (unsigned char)0;
#line 6012
    i = h & mask;
    }
    {
#line 6013
    while (1) {
      while_continue: /* CIL Label */ ;
#line 6013
      if (! *(table->v + i)) {
#line 6013
        goto while_break;
      }
      {
#line 6014
      tmp___2 = keyeq___0(name, (*(table->v + i))->name);
      }
#line 6014
      if (tmp___2) {
#line 6015
        return (*(table->v + i));
      }
#line 6016
      if (! step) {
#line 6017
        step = (unsigned char )((((h & ~ mask) >> ((int )table->power - 1)) & (mask >> 2)) | 1UL);
      }
#line 6018
      if (i < (size_t )step) {
#line 6018
        i += table->size - (size_t )step;
      } else {
#line 6018
        i -= (size_t )step;
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 6020
    if (! createSize) {
#line 6021
      return ((NAMED *)((void *)0));
    }
#line 6024
    if (table->used >> ((int )table->power - 1)) {
      {
#line 6025
      newPower = (unsigned char )((int )table->power + 1);
#line 6026
      newSize = 1UL << (int )newPower;
#line 6027
      newMask = newSize - 1UL;
#line 6028
      tsize___0 = newSize * sizeof(NAMED *);
#line 6029
      tmp___3 = (*((table->mem)->malloc_fcn))(tsize___0);
#line 6029
      newV = (NAMED **)tmp___3;
      }
#line 6030
      if (! newV) {
#line 6031
        return ((NAMED *)((void *)0));
      }
      {
#line 6032
      memset((void *)newV, 0, tsize___0);
#line 6033
      i = (size_t )0;
      }
      {
#line 6033
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 6033
        if (! (i < table->size)) {
#line 6033
          goto while_break___0;
        }
#line 6034
        if (*(table->v + i)) {
          {
#line 6035
          tmp___4 = hash___0(parser, (*(table->v + i))->name);
#line 6035
          newHash = tmp___4;
#line 6036
          j = newHash & newMask;
#line 6037
          step = (unsigned char)0;
          }
          {
#line 6038
          while (1) {
            while_continue___1: /* CIL Label */ ;
#line 6038
            if (! *(newV + j)) {
#line 6038
              goto while_break___1;
            }
#line 6039
            if (! step) {
#line 6040
              step = (unsigned char )((((newHash & ~ newMask) >> ((int )newPower - 1)) & (newMask >> 2)) | 1UL);
            }
#line 6041
            if (j < (size_t )step) {
#line 6041
              j += newSize - (size_t )step;
            } else {
#line 6041
              j -= (size_t )step;
            }
          }
          while_break___1: /* CIL Label */ ;
          }
#line 6043
          *(newV + j) = *(table->v + i);
        }
#line 6033
        i ++;
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 6045
      (*((table->mem)->free_fcn))((void *)table->v);
#line 6046
      table->v = newV;
#line 6047
      table->power = newPower;
#line 6048
      table->size = newSize;
#line 6049
      i = h & newMask;
#line 6050
      step = (unsigned char)0;
      }
      {
#line 6051
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 6051
        if (! *(table->v + i)) {
#line 6051
          goto while_break___2;
        }
#line 6052
        if (! step) {
#line 6053
          step = (unsigned char )((((h & ~ newMask) >> ((int )newPower - 1)) & (newMask >> 2)) | 1UL);
        }
#line 6054
        if (i < (size_t )step) {
#line 6054
          i += newSize - (size_t )step;
        } else {
#line 6054
          i -= (size_t )step;
        }
      }
      while_break___2: /* CIL Label */ ;
      }
    }
  }
  {
#line 6058
  tmp___5 = (*((table->mem)->malloc_fcn))(createSize);
#line 6058
  *(table->v + i) = (NAMED *)tmp___5;
  }
#line 6059
  if (! *(table->v + i)) {
#line 6060
    return ((NAMED *)((void *)0));
  }
  {
#line 6061
  memset((void *)*(table->v + i), 0, createSize);
#line 6062
  (*(table->v + i))->name = name;
#line 6063
  (table->used) ++;
  }
#line 6064
  return (*(table->v + i));
}
}
#line 6067 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlparse.c"
static void hashTableClear___0(HASH_TABLE *table ) 
{ 
  size_t i ;

  {
#line 6071
  i = (size_t )0;
  {
#line 6071
  while (1) {
    while_continue: /* CIL Label */ ;
#line 6071
    if (! (i < table->size)) {
#line 6071
      goto while_break;
    }
    {
#line 6072
    (*((table->mem)->free_fcn))((void *)*(table->v + i));
#line 6073
    *(table->v + i) = (NAMED *)((void *)0);
#line 6071
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 6075
  table->used = (size_t )0;
#line 6076
  return;
}
}
#line 6078 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlparse.c"
static void hashTableDestroy___0(HASH_TABLE *table ) 
{ 
  size_t i ;

  {
#line 6082
  i = (size_t )0;
  {
#line 6082
  while (1) {
    while_continue: /* CIL Label */ ;
#line 6082
    if (! (i < table->size)) {
#line 6082
      goto while_break;
    }
    {
#line 6083
    (*((table->mem)->free_fcn))((void *)*(table->v + i));
#line 6082
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 6084
  (*((table->mem)->free_fcn))((void *)table->v);
  }
#line 6085
  return;
}
}
#line 6087 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlparse.c"
static void hashTableInit___0(HASH_TABLE *p , XML_Memory_Handling_Suite const   *ms ) 
{ 


  {
#line 6090
  p->power = (unsigned char)0;
#line 6091
  p->size = (size_t )0;
#line 6092
  p->used = (size_t )0;
#line 6093
  p->v = (NAMED **)((void *)0);
#line 6094
  p->mem = ms;
#line 6095
  return;
}
}
#line 6097 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlparse.c"
static void hashTableIterInit___0(HASH_TABLE_ITER *iter , HASH_TABLE const   *table ) 
{ 


  {
#line 6100
  iter->p = (NAMED **)table->v;
#line 6101
  iter->end = iter->p + table->size;
#line 6102
  return;
}
}
#line 6104 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlparse.c"
static NAMED *hashTableIterNext___0(HASH_TABLE_ITER *iter ) 
{ 
  NAMED *tem ;
  NAMED **tmp ;

  {
  {
#line 6107
  while (1) {
    while_continue: /* CIL Label */ ;
#line 6107
    if (! ((unsigned long )iter->p != (unsigned long )iter->end)) {
#line 6107
      goto while_break;
    }
#line 6108
    tmp = iter->p;
#line 6108
    (iter->p) ++;
#line 6108
    tem = *tmp;
#line 6109
    if (tem) {
#line 6110
      return (tem);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 6112
  return ((NAMED *)((void *)0));
}
}
#line 6115 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlparse.c"
static void poolInit___0(STRING_POOL *pool , XML_Memory_Handling_Suite const   *ms ) 
{ 


  {
#line 6118
  pool->blocks = (BLOCK *)((void *)0);
#line 6119
  pool->freeBlocks = (BLOCK *)((void *)0);
#line 6120
  pool->start = (XML_Char *)((void *)0);
#line 6121
  pool->ptr = (XML_Char *)((void *)0);
#line 6122
  pool->end = (XML_Char const   *)((void *)0);
#line 6123
  pool->mem = ms;
#line 6124
  return;
}
}
#line 6126 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlparse.c"
static void poolClear___0(STRING_POOL *pool ) 
{ 
  BLOCK *p ;
  BLOCK *tem ;

  {
#line 6129
  if (! pool->freeBlocks) {
#line 6130
    pool->freeBlocks = pool->blocks;
  } else {
#line 6132
    p = pool->blocks;
    {
#line 6133
    while (1) {
      while_continue: /* CIL Label */ ;
#line 6133
      if (! p) {
#line 6133
        goto while_break;
      }
#line 6134
      tem = p->next;
#line 6135
      p->next = pool->freeBlocks;
#line 6136
      pool->freeBlocks = p;
#line 6137
      p = tem;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 6140
  pool->blocks = (BLOCK *)((void *)0);
#line 6141
  pool->start = (XML_Char *)((void *)0);
#line 6142
  pool->ptr = (XML_Char *)((void *)0);
#line 6143
  pool->end = (XML_Char const   *)((void *)0);
#line 6144
  return;
}
}
#line 6146 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlparse.c"
static void poolDestroy___0(STRING_POOL *pool ) 
{ 
  BLOCK *p ;
  BLOCK *tem ;
  BLOCK *tem___0 ;

  {
#line 6149
  p = pool->blocks;
  {
#line 6150
  while (1) {
    while_continue: /* CIL Label */ ;
#line 6150
    if (! p) {
#line 6150
      goto while_break;
    }
    {
#line 6151
    tem = p->next;
#line 6152
    (*((pool->mem)->free_fcn))((void *)p);
#line 6153
    p = tem;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 6155
  p = pool->freeBlocks;
  {
#line 6156
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 6156
    if (! p) {
#line 6156
      goto while_break___0;
    }
    {
#line 6157
    tem___0 = p->next;
#line 6158
    (*((pool->mem)->free_fcn))((void *)p);
#line 6159
    p = tem___0;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 6161
  return;
}
}
#line 6163 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlparse.c"
static XML_Char *poolAppend___0(STRING_POOL *pool , ENCODING const   *enc , char const   *ptr ,
                                char const   *end ) 
{ 
  XML_Bool tmp ;
  XML_Bool tmp___0 ;

  {
#line 6167
  if (! pool->ptr) {
    {
#line 6167
    tmp = poolGrow___0(pool);
    }
#line 6167
    if (! tmp) {
#line 6168
      return ((XML_Char *)((void *)0));
    }
  }
  {
#line 6169
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 6170
    (*(enc->utf8Convert))(enc, & ptr, end, & pool->ptr, (char const   *)((ICHAR *)pool->end));
    }
#line 6171
    if ((unsigned long )ptr == (unsigned long )end) {
#line 6172
      goto while_break;
    }
    {
#line 6173
    tmp___0 = poolGrow___0(pool);
    }
#line 6173
    if (! tmp___0) {
#line 6174
      return ((XML_Char *)((void *)0));
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 6176
  return (pool->start);
}
}
#line 6179 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlparse.c"
static XML_Char const   *poolCopyString___0(STRING_POOL *pool , XML_Char const   *s ) 
{ 
  XML_Char *tmp___0 ;
  int tmp___1 ;
  XML_Bool tmp___2 ;
  XML_Char const   *tmp___3 ;

  {
  {
#line 6182
  while (1) {
    while_continue: /* CIL Label */ ;
#line 6183
    if ((unsigned long )pool->ptr == (unsigned long )pool->end) {
      {
#line 6183
      tmp___2 = poolGrow___0(pool);
      }
#line 6183
      if (tmp___2) {
#line 6183
        tmp___0 = pool->ptr;
#line 6183
        (pool->ptr) ++;
#line 6183
        *tmp___0 = (XML_Char )*s;
#line 6183
        tmp___1 = 1;
      } else {
#line 6183
        tmp___1 = 0;
      }
    } else {
#line 6183
      tmp___0 = pool->ptr;
#line 6183
      (pool->ptr) ++;
#line 6183
      *tmp___0 = (XML_Char )*s;
#line 6183
      tmp___1 = 1;
    }
#line 6183
    if (! tmp___1) {
#line 6184
      return ((XML_Char const   *)((void *)0));
    }
#line 6182
    tmp___3 = s;
#line 6182
    s ++;
#line 6182
    if (! *tmp___3) {
#line 6182
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 6186
  s = (XML_Char const   *)pool->start;
#line 6187
  pool->start = pool->ptr;
#line 6188
  return (s);
}
}
#line 6191 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlparse.c"
static XML_Char const   *poolCopyStringN___0(STRING_POOL *pool , XML_Char const   *s ,
                                             int n ) 
{ 
  XML_Bool tmp ;
  XML_Char *tmp___1 ;
  int tmp___2 ;
  XML_Bool tmp___3 ;

  {
#line 6194
  if (! pool->ptr) {
    {
#line 6194
    tmp = poolGrow___0(pool);
    }
#line 6194
    if (! tmp) {
#line 6195
      return ((XML_Char const   *)((void *)0));
    }
  }
  {
#line 6196
  while (1) {
    while_continue: /* CIL Label */ ;
#line 6196
    if (! (n > 0)) {
#line 6196
      goto while_break;
    }
#line 6197
    if ((unsigned long )pool->ptr == (unsigned long )pool->end) {
      {
#line 6197
      tmp___3 = poolGrow___0(pool);
      }
#line 6197
      if (tmp___3) {
#line 6197
        tmp___1 = pool->ptr;
#line 6197
        (pool->ptr) ++;
#line 6197
        *tmp___1 = (XML_Char )*s;
#line 6197
        tmp___2 = 1;
      } else {
#line 6197
        tmp___2 = 0;
      }
    } else {
#line 6197
      tmp___1 = pool->ptr;
#line 6197
      (pool->ptr) ++;
#line 6197
      *tmp___1 = (XML_Char )*s;
#line 6197
      tmp___2 = 1;
    }
#line 6197
    if (! tmp___2) {
#line 6198
      return ((XML_Char const   *)((void *)0));
    }
#line 6196
    n --;
#line 6196
    s ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 6200
  s = (XML_Char const   *)pool->start;
#line 6201
  pool->start = pool->ptr;
#line 6202
  return (s);
}
}
#line 6205 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlparse.c"
static XML_Char const   *poolAppendString___0(STRING_POOL *pool , XML_Char const   *s ) 
{ 
  XML_Char *tmp___0 ;
  int tmp___1 ;
  XML_Bool tmp___2 ;

  {
  {
#line 6208
  while (1) {
    while_continue: /* CIL Label */ ;
#line 6208
    if (! *s) {
#line 6208
      goto while_break;
    }
#line 6209
    if ((unsigned long )pool->ptr == (unsigned long )pool->end) {
      {
#line 6209
      tmp___2 = poolGrow___0(pool);
      }
#line 6209
      if (tmp___2) {
#line 6209
        tmp___0 = pool->ptr;
#line 6209
        (pool->ptr) ++;
#line 6209
        *tmp___0 = (XML_Char )*s;
#line 6209
        tmp___1 = 1;
      } else {
#line 6209
        tmp___1 = 0;
      }
    } else {
#line 6209
      tmp___0 = pool->ptr;
#line 6209
      (pool->ptr) ++;
#line 6209
      *tmp___0 = (XML_Char )*s;
#line 6209
      tmp___1 = 1;
    }
#line 6209
    if (! tmp___1) {
#line 6210
      return ((XML_Char const   *)((void *)0));
    }
#line 6211
    s ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 6213
  return ((XML_Char const   *)pool->start);
}
}
#line 6216 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlparse.c"
static XML_Char *poolStoreString___0(STRING_POOL *pool , ENCODING const   *enc , char const   *ptr ,
                                     char const   *end ) 
{ 
  XML_Char *tmp ;
  XML_Bool tmp___0 ;
  XML_Char *tmp___1 ;

  {
  {
#line 6220
  tmp = poolAppend___0(pool, enc, ptr, end);
  }
#line 6220
  if (! tmp) {
#line 6221
    return ((XML_Char *)((void *)0));
  }
#line 6222
  if ((unsigned long )pool->ptr == (unsigned long )pool->end) {
    {
#line 6222
    tmp___0 = poolGrow___0(pool);
    }
#line 6222
    if (! tmp___0) {
#line 6223
      return ((XML_Char *)((void *)0));
    }
  }
#line 6224
  tmp___1 = pool->ptr;
#line 6224
  (pool->ptr) ++;
#line 6224
  *tmp___1 = (XML_Char )0;
#line 6225
  return (pool->start);
}
}
#line 6228 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlparse.c"
static XML_Bool poolGrow___0(STRING_POOL *pool ) 
{ 
  BLOCK *tem ;
  int blockSize ;
  BLOCK *temp ;
  void *tmp ;
  BLOCK *tem___0 ;
  int blockSize___0 ;
  void *tmp___0 ;

  {
#line 6231
  if (pool->freeBlocks) {
#line 6232
    if ((unsigned long )pool->start == (unsigned long )((XML_Char *)0)) {
#line 6233
      pool->blocks = pool->freeBlocks;
#line 6234
      pool->freeBlocks = (pool->freeBlocks)->next;
#line 6235
      (pool->blocks)->next = (struct block *)((void *)0);
#line 6236
      pool->start = (pool->blocks)->s;
#line 6237
      pool->end = (XML_Char const   *)(pool->start + (pool->blocks)->size);
#line 6238
      pool->ptr = pool->start;
#line 6239
      return ((XML_Bool )1);
    }
#line 6241
    if (pool->end - (XML_Char const   *)pool->start < (long )(pool->freeBlocks)->size) {
      {
#line 6242
      tem = (pool->freeBlocks)->next;
#line 6243
      (pool->freeBlocks)->next = pool->blocks;
#line 6244
      pool->blocks = pool->freeBlocks;
#line 6245
      pool->freeBlocks = tem;
#line 6246
      memcpy((void */* __restrict  */)((pool->blocks)->s), (void const   */* __restrict  */)pool->start,
             (unsigned long )(pool->end - (XML_Char const   *)pool->start) * sizeof(XML_Char ));
#line 6248
      pool->ptr = (pool->blocks)->s + (pool->ptr - pool->start);
#line 6249
      pool->start = (pool->blocks)->s;
#line 6250
      pool->end = (XML_Char const   *)(pool->start + (pool->blocks)->size);
      }
#line 6251
      return ((XML_Bool )1);
    }
  }
#line 6254
  if (pool->blocks) {
#line 6254
    if ((unsigned long )pool->start == (unsigned long )((pool->blocks)->s)) {
      {
#line 6255
      blockSize = (int )(pool->end - (XML_Char const   *)pool->start) * 2;
#line 6256
      tmp = (*((pool->mem)->realloc_fcn))((void *)pool->blocks, (unsigned long )(& ((BLOCK *)0)->s) + (unsigned long )blockSize * sizeof(XML_Char ));
#line 6256
      temp = (BLOCK *)tmp;
      }
#line 6260
      if ((unsigned long )temp == (unsigned long )((void *)0)) {
#line 6261
        return ((XML_Bool )0);
      }
#line 6262
      pool->blocks = temp;
#line 6263
      (pool->blocks)->size = blockSize;
#line 6264
      pool->ptr = (pool->blocks)->s + (pool->ptr - pool->start);
#line 6265
      pool->start = (pool->blocks)->s;
#line 6266
      pool->end = (XML_Char const   *)(pool->start + blockSize);
    } else {
#line 6254
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
#line 6270
    blockSize___0 = (int )(pool->end - (XML_Char const   *)pool->start);
#line 6271
    if (blockSize___0 < 1024) {
#line 6272
      blockSize___0 = 1024;
    } else {
#line 6274
      blockSize___0 *= 2;
    }
    {
#line 6275
    tmp___0 = (*((pool->mem)->malloc_fcn))((unsigned long )(& ((BLOCK *)0)->s) + (unsigned long )blockSize___0 * sizeof(XML_Char ));
#line 6275
    tem___0 = (BLOCK *)tmp___0;
    }
#line 6277
    if (! tem___0) {
#line 6278
      return ((XML_Bool )0);
    }
#line 6279
    tem___0->size = blockSize___0;
#line 6280
    tem___0->next = pool->blocks;
#line 6281
    pool->blocks = tem___0;
#line 6282
    if ((unsigned long )pool->ptr != (unsigned long )pool->start) {
      {
#line 6283
      memcpy((void */* __restrict  */)(tem___0->s), (void const   */* __restrict  */)pool->start,
             (unsigned long )(pool->ptr - pool->start) * sizeof(XML_Char ));
      }
    }
#line 6285
    pool->ptr = tem___0->s + (pool->ptr - pool->start);
#line 6286
    pool->start = tem___0->s;
#line 6287
    pool->end = (XML_Char const   *)(tem___0->s + blockSize___0);
  }
#line 6289
  return ((XML_Bool )1);
}
}
#line 6292 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlparse.c"
static int nextScaffoldPart___0(XML_Parser parser ) 
{ 
  DTD *dtd ;
  CONTENT_SCAFFOLD *me ;
  int next ;
  void *tmp ;
  CONTENT_SCAFFOLD *temp ;
  void *tmp___0 ;
  void *tmp___1 ;
  unsigned int tmp___2 ;
  CONTENT_SCAFFOLD *parent ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 6295
  dtd = parser->m_dtd;
#line 6299
  if (! dtd->scaffIndex) {
    {
#line 6300
    tmp = (*(parser->m_mem.malloc_fcn))((unsigned long )parser->m_groupSize * sizeof(int ));
#line 6300
    dtd->scaffIndex = (int *)tmp;
    }
#line 6301
    if (! dtd->scaffIndex) {
#line 6302
      return (-1);
    }
#line 6303
    *(dtd->scaffIndex + 0) = 0;
  }
#line 6306
  if (dtd->scaffCount >= dtd->scaffSize) {
#line 6308
    if (dtd->scaffold) {
      {
#line 6309
      tmp___0 = (*(parser->m_mem.realloc_fcn))((void *)dtd->scaffold, (unsigned long )(dtd->scaffSize * 2U) * sizeof(CONTENT_SCAFFOLD ));
#line 6309
      temp = (CONTENT_SCAFFOLD *)tmp___0;
      }
#line 6311
      if ((unsigned long )temp == (unsigned long )((void *)0)) {
#line 6312
        return (-1);
      }
#line 6313
      dtd->scaffSize *= 2U;
    } else {
      {
#line 6316
      tmp___1 = (*(parser->m_mem.malloc_fcn))(32UL * sizeof(CONTENT_SCAFFOLD ));
#line 6316
      temp = (CONTENT_SCAFFOLD *)tmp___1;
      }
#line 6318
      if ((unsigned long )temp == (unsigned long )((void *)0)) {
#line 6319
        return (-1);
      }
#line 6320
      dtd->scaffSize = 32U;
    }
#line 6322
    dtd->scaffold = temp;
  }
#line 6324
  tmp___2 = dtd->scaffCount;
#line 6324
  (dtd->scaffCount) ++;
#line 6324
  next = (int )tmp___2;
#line 6325
  me = dtd->scaffold + next;
#line 6326
  if (dtd->scaffLevel) {
#line 6327
    parent = dtd->scaffold + *(dtd->scaffIndex + (dtd->scaffLevel - 1));
#line 6328
    if (parent->lastchild) {
#line 6329
      (dtd->scaffold + parent->lastchild)->nextsib = next;
    }
#line 6331
    if (! parent->childcnt) {
#line 6332
      parent->firstchild = next;
    }
#line 6333
    parent->lastchild = next;
#line 6334
    (parent->childcnt) ++;
  }
#line 6336
  tmp___5 = 0;
#line 6336
  me->nextsib = tmp___5;
#line 6336
  tmp___4 = tmp___5;
#line 6336
  me->childcnt = tmp___4;
#line 6336
  tmp___3 = tmp___4;
#line 6336
  me->lastchild = tmp___3;
#line 6336
  me->firstchild = tmp___3;
#line 6337
  return (next);
}
}
#line 6340 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlparse.c"
static void build_node___0(XML_Parser parser , int src_node , XML_Content *dest ,
                           XML_Content **contpos , XML_Char **strpos ) 
{ 
  DTD *dtd ;
  XML_Char const   *src ;
  XML_Char *tmp ;
  unsigned int i ;
  int cn ;

  {
#line 6347
  dtd = parser->m_dtd;
#line 6348
  dest->type = (dtd->scaffold + src_node)->type;
#line 6349
  dest->quant = (dtd->scaffold + src_node)->quant;
#line 6350
  if ((unsigned int )dest->type == 4U) {
#line 6352
    dest->name = *strpos;
#line 6353
    src = (dtd->scaffold + src_node)->name;
    {
#line 6354
    while (1) {
      while_continue: /* CIL Label */ ;
#line 6355
      tmp = *strpos;
#line 6355
      (*strpos) ++;
#line 6355
      *tmp = (XML_Char )*src;
#line 6356
      if (! *src) {
#line 6357
        goto while_break;
      }
#line 6358
      src ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 6360
    dest->numchildren = 0U;
#line 6361
    dest->children = (XML_Content *)((void *)0);
  } else {
#line 6366
    dest->numchildren = (unsigned int )(dtd->scaffold + src_node)->childcnt;
#line 6367
    dest->children = *contpos;
#line 6368
    *contpos += dest->numchildren;
#line 6369
    i = 0U;
#line 6369
    cn = (dtd->scaffold + src_node)->firstchild;
    {
#line 6369
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 6369
      if (! (i < dest->numchildren)) {
#line 6369
        goto while_break___0;
      }
      {
#line 6372
      build_node___0(parser, cn, dest->children + i, contpos, strpos);
#line 6369
      i ++;
#line 6369
      cn = (dtd->scaffold + cn)->nextsib;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 6374
    dest->name = (XML_Char *)((void *)0);
  }
#line 6376
  return;
}
}
#line 6378 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlparse.c"
static XML_Content *build_model___0(XML_Parser parser ) 
{ 
  DTD *dtd ;
  XML_Content *ret ;
  XML_Content *cpos ;
  XML_Char *str ;
  int allocsize ;
  void *tmp ;

  {
  {
#line 6381
  dtd = parser->m_dtd;
#line 6385
  allocsize = (int )((unsigned long )dtd->scaffCount * sizeof(XML_Content ) + (unsigned long )dtd->contentStringLen * sizeof(XML_Char ));
#line 6388
  tmp = (*(parser->m_mem.malloc_fcn))((size_t )allocsize);
#line 6388
  ret = (XML_Content *)tmp;
  }
#line 6389
  if (! ret) {
#line 6390
    return ((XML_Content *)((void *)0));
  }
  {
#line 6392
  str = (XML_Char *)(ret + dtd->scaffCount);
#line 6393
  cpos = ret + 1;
#line 6395
  build_node___0(parser, 0, ret, & cpos, & str);
  }
#line 6396
  return (ret);
}
}
#line 6399 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlparse.c"
static ELEMENT_TYPE *getElementType___0(XML_Parser parser , ENCODING const   *enc ,
                                        char const   *ptr , char const   *end ) 
{ 
  DTD *dtd ;
  XML_Char const   *name ;
  XML_Char *tmp ;
  ELEMENT_TYPE *ret ;
  NAMED *tmp___0 ;
  int tmp___1 ;

  {
  {
#line 6405
  dtd = parser->m_dtd;
#line 6406
  tmp = poolStoreString___0(& dtd->pool, enc, ptr, end);
#line 6406
  name = (XML_Char const   *)tmp;
  }
#line 6409
  if (! name) {
#line 6410
    return ((ELEMENT_TYPE *)((void *)0));
  }
  {
#line 6411
  tmp___0 = lookup___0(parser, & dtd->elementTypes, name, sizeof(ELEMENT_TYPE ));
#line 6411
  ret = (ELEMENT_TYPE *)tmp___0;
  }
#line 6412
  if (! ret) {
#line 6413
    return ((ELEMENT_TYPE *)((void *)0));
  }
#line 6414
  if ((unsigned long )ret->name != (unsigned long )name) {
#line 6415
    dtd->pool.ptr = dtd->pool.start;
  } else {
    {
#line 6417
    dtd->pool.start = dtd->pool.ptr;
#line 6418
    tmp___1 = setElementTypePrefix___0(parser, ret);
    }
#line 6418
    if (! tmp___1) {
#line 6419
      return ((ELEMENT_TYPE *)((void *)0));
    }
  }
#line 6421
  return (ret);
}
}
#line 1 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/nametab.h"
static unsigned int const   namingBitmap___0[320]  = 
#line 1 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/nametab.h"
  {      (unsigned int const   )0,      (unsigned int const   )0,      (unsigned int const   )0,      (unsigned int const   )0, 
        (unsigned int const   )0,      (unsigned int const   )0,      (unsigned int const   )0,      (unsigned int const   )0, 
        (unsigned int const   )4294967295U,      (unsigned int const   )4294967295U,      (unsigned int const   )4294967295U,      (unsigned int const   )4294967295U, 
        (unsigned int const   )4294967295U,      (unsigned int const   )4294967295U,      (unsigned int const   )4294967295U,      (unsigned int const   )4294967295U, 
        (unsigned int const   )0,      (unsigned int const   )67108864,      (unsigned int const   )2281701374U,      (unsigned int const   )134217726, 
        (unsigned int const   )0,      (unsigned int const   )0,      (unsigned int const   )4286578687U,      (unsigned int const   )4286578687U, 
        (unsigned int const   )4294967295U,      (unsigned int const   )2146697215,      (unsigned int const   )4294966782U,      (unsigned int const   )2147483647, 
        (unsigned int const   )4294967295U,      (unsigned int const   )4294967295U,      (unsigned int const   )4294959119U,      (unsigned int const   )4231135231U, 
        (unsigned int const   )16777215,      (unsigned int const   )0,      (unsigned int const   )4294901760U,      (unsigned int const   )4294967295U, 
        (unsigned int const   )4294967295U,      (unsigned int const   )4160750079U,      (unsigned int const   )3,      (unsigned int const   )0, 
        (unsigned int const   )0,      (unsigned int const   )0,      (unsigned int const   )0,      (unsigned int const   )0, 
        (unsigned int const   )4294956864U,      (unsigned int const   )4294967291U,      (unsigned int const   )1417641983,      (unsigned int const   )1048573, 
        (unsigned int const   )4294959102U,      (unsigned int const   )4294967295U,      (unsigned int const   )3758030847U,      (unsigned int const   )4294967295U, 
        (unsigned int const   )4294901763U,      (unsigned int const   )4294967295U,      (unsigned int const   )4294908319U,      (unsigned int const   )54513663, 
        (unsigned int const   )0,      (unsigned int const   )4294836224U,      (unsigned int const   )41943039,      (unsigned int const   )4294967294U, 
        (unsigned int const   )127,      (unsigned int const   )0,      (unsigned int const   )4294901760U,      (unsigned int const   )460799, 
        (unsigned int const   )0,      (unsigned int const   )134217726,      (unsigned int const   )2046,      (unsigned int const   )4294836224U, 
        (unsigned int const   )4294967295U,      (unsigned int const   )2097151999,      (unsigned int const   )3112959,      (unsigned int const   )96, 
        (unsigned int const   )4294967264U,      (unsigned int const   )603979775,      (unsigned int const   )4278190080U,      (unsigned int const   )3, 
        (unsigned int const   )4294549472U,      (unsigned int const   )63307263,      (unsigned int const   )2952790016U,      (unsigned int const   )196611, 
        (unsigned int const   )4294543328U,      (unsigned int const   )57540095,      (unsigned int const   )1577058304,      (unsigned int const   )1835008, 
        (unsigned int const   )4294684640U,      (unsigned int const   )602799615,      (unsigned int const   )0,      (unsigned int const   )1, 
        (unsigned int const   )4294549472U,      (unsigned int const   )600702463,      (unsigned int const   )2952790016U,      (unsigned int const   )3, 
        (unsigned int const   )3594373088U,      (unsigned int const   )62899992,      (unsigned int const   )0,      (unsigned int const   )0, 
        (unsigned int const   )4294828000U,      (unsigned int const   )66059775,      (unsigned int const   )0,      (unsigned int const   )3, 
        (unsigned int const   )4294828000U,      (unsigned int const   )66059775,      (unsigned int const   )1073741824,      (unsigned int const   )3, 
        (unsigned int const   )4294828000U,      (unsigned int const   )67108351,      (unsigned int const   )0,      (unsigned int const   )3, 
        (unsigned int const   )0,      (unsigned int const   )0,      (unsigned int const   )0,      (unsigned int const   )0, 
        (unsigned int const   )4294967294U,      (unsigned int const   )884735,      (unsigned int const   )63,      (unsigned int const   )0, 
        (unsigned int const   )4277151126U,      (unsigned int const   )537750702,      (unsigned int const   )31,      (unsigned int const   )0, 
        (unsigned int const   )0,      (unsigned int const   )0,      (unsigned int const   )4294967039U,      (unsigned int const   )1023, 
        (unsigned int const   )0,      (unsigned int const   )0,      (unsigned int const   )0,      (unsigned int const   )0, 
        (unsigned int const   )0,      (unsigned int const   )0,      (unsigned int const   )0,      (unsigned int const   )0, 
        (unsigned int const   )0,      (unsigned int const   )4294967295U,      (unsigned int const   )4294901823U,      (unsigned int const   )8388607, 
        (unsigned int const   )514797,      (unsigned int const   )1342177280,      (unsigned int const   )2184269825U,      (unsigned int const   )2908843, 
        (unsigned int const   )1073741824,      (unsigned int const   )4118857984U,      (unsigned int const   )7,      (unsigned int const   )33622016, 
        (unsigned int const   )4294967295U,      (unsigned int const   )4294967295U,      (unsigned int const   )4294967295U,      (unsigned int const   )4294967295U, 
        (unsigned int const   )268435455,      (unsigned int const   )4294967295U,      (unsigned int const   )4294967295U,      (unsigned int const   )67108863, 
        (unsigned int const   )1061158911,      (unsigned int const   )4294967295U,      (unsigned int const   )2868854591U,      (unsigned int const   )1073741823, 
        (unsigned int const   )4294967295U,      (unsigned int const   )1608515583,      (unsigned int const   )265232348,      (unsigned int const   )534519807, 
        (unsigned int const   )0,      (unsigned int const   )19520,      (unsigned int const   )0,      (unsigned int const   )0, 
        (unsigned int const   )7,      (unsigned int const   )0,      (unsigned int const   )0,      (unsigned int const   )0, 
        (unsigned int const   )128,      (unsigned int const   )1022,      (unsigned int const   )4294967294U,      (unsigned int const   )4294967295U, 
        (unsigned int const   )2097151,      (unsigned int const   )4294967294U,      (unsigned int const   )4294967295U,      (unsigned int const   )134217727, 
        (unsigned int const   )4294967264U,      (unsigned int const   )8191,      (unsigned int const   )0,      (unsigned int const   )0, 
        (unsigned int const   )0,      (unsigned int const   )0,      (unsigned int const   )0,      (unsigned int const   )0, 
        (unsigned int const   )4294967295U,      (unsigned int const   )4294967295U,      (unsigned int const   )4294967295U,      (unsigned int const   )4294967295U, 
        (unsigned int const   )4294967295U,      (unsigned int const   )63,      (unsigned int const   )0,      (unsigned int const   )0, 
        (unsigned int const   )4294967295U,      (unsigned int const   )4294967295U,      (unsigned int const   )4294967295U,      (unsigned int const   )4294967295U, 
        (unsigned int const   )4294967295U,      (unsigned int const   )15,      (unsigned int const   )0,      (unsigned int const   )0, 
        (unsigned int const   )0,      (unsigned int const   )134176768,      (unsigned int const   )2281701374U,      (unsigned int const   )134217726, 
        (unsigned int const   )0,      (unsigned int const   )8388608,      (unsigned int const   )4286578687U,      (unsigned int const   )4286578687U, 
        (unsigned int const   )16777215,      (unsigned int const   )0,      (unsigned int const   )4294901760U,      (unsigned int const   )4294967295U, 
        (unsigned int const   )4294967295U,      (unsigned int const   )4160750079U,      (unsigned int const   )196611,      (unsigned int const   )0, 
        (unsigned int const   )4294967295U,      (unsigned int const   )4294967295U,      (unsigned int const   )63,      (unsigned int const   )3, 
        (unsigned int const   )4294956992U,      (unsigned int const   )4294967291U,      (unsigned int const   )1417641983,      (unsigned int const   )1048573, 
        (unsigned int const   )4294959102U,      (unsigned int const   )4294967295U,      (unsigned int const   )3758030847U,      (unsigned int const   )4294967295U, 
        (unsigned int const   )4294901883U,      (unsigned int const   )4294967295U,      (unsigned int const   )4294908319U,      (unsigned int const   )54513663, 
        (unsigned int const   )0,      (unsigned int const   )4294836224U,      (unsigned int const   )41943039,      (unsigned int const   )4294967294U, 
        (unsigned int const   )4294836351U,      (unsigned int const   )3154116603U,      (unsigned int const   )4294901782U,      (unsigned int const   )460799, 
        (unsigned int const   )0,      (unsigned int const   )134217726,      (unsigned int const   )524287,      (unsigned int const   )4294902783U, 
        (unsigned int const   )4294967295U,      (unsigned int const   )2097151999,      (unsigned int const   )4293885951U,      (unsigned int const   )67059199, 
        (unsigned int const   )4294967278U,      (unsigned int const   )4093640703U,      (unsigned int const   )4280172543U,      (unsigned int const   )65487, 
        (unsigned int const   )4294549486U,      (unsigned int const   )3552968191U,      (unsigned int const   )2961193375U,      (unsigned int const   )262095, 
        (unsigned int const   )4294543332U,      (unsigned int const   )3547201023U,      (unsigned int const   )1577073031,      (unsigned int const   )2097088, 
        (unsigned int const   )4294684654U,      (unsigned int const   )4092460543U,      (unsigned int const   )15295,      (unsigned int const   )65473, 
        (unsigned int const   )4294549486U,      (unsigned int const   )4090363391U,      (unsigned int const   )2965387663U,      (unsigned int const   )65475, 
        (unsigned int const   )3594373100U,      (unsigned int const   )3284125464U,      (unsigned int const   )8404423,      (unsigned int const   )65408, 
        (unsigned int const   )4294828014U,      (unsigned int const   )3287285247U,      (unsigned int const   )6307295,      (unsigned int const   )65475, 
        (unsigned int const   )4294828012U,      (unsigned int const   )3287285247U,      (unsigned int const   )1080049119,      (unsigned int const   )65475, 
        (unsigned int const   )4294828012U,      (unsigned int const   )3288333823U,      (unsigned int const   )8404431,      (unsigned int const   )65475, 
        (unsigned int const   )0,      (unsigned int const   )0,      (unsigned int const   )0,      (unsigned int const   )0, 
        (unsigned int const   )4294967294U,      (unsigned int const   )134184959,      (unsigned int const   )67076095,      (unsigned int const   )0, 
        (unsigned int const   )4277151126U,      (unsigned int const   )1006595246,      (unsigned int const   )67059551,      (unsigned int const   )0, 
        (unsigned int const   )50331648,      (unsigned int const   )3265266687U,      (unsigned int const   )4294967039U,      (unsigned int const   )4294837247U, 
        (unsigned int const   )4273934303U,      (unsigned int const   )50216959,      (unsigned int const   )0,      (unsigned int const   )0, 
        (unsigned int const   )0,      (unsigned int const   )0,      (unsigned int const   )0,      (unsigned int const   )0, 
        (unsigned int const   )0,      (unsigned int const   )0,      (unsigned int const   )536805376,      (unsigned int const   )2, 
        (unsigned int const   )160,      (unsigned int const   )4128766,      (unsigned int const   )4294967294U,      (unsigned int const   )4294967295U, 
        (unsigned int const   )1713373183,      (unsigned int const   )4294967294U,      (unsigned int const   )4294967295U,      (unsigned int const   )2013265919};
#line 83 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/nametab.h"
static unsigned char const   nmstrtPages___0[256]  = 
#line 83
  {      (unsigned char const   )2,      (unsigned char const   )3,      (unsigned char const   )4,      (unsigned char const   )5, 
        (unsigned char const   )6,      (unsigned char const   )7,      (unsigned char const   )8,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )9,      (unsigned char const   )10,      (unsigned char const   )11, 
        (unsigned char const   )12,      (unsigned char const   )13,      (unsigned char const   )14,      (unsigned char const   )15, 
        (unsigned char const   )16,      (unsigned char const   )17,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )18,      (unsigned char const   )19, 
        (unsigned char const   )0,      (unsigned char const   )20,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )21,      (unsigned char const   )22,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )1,      (unsigned char const   )1, 
        (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1, 
        (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1, 
        (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1, 
        (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1, 
        (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1, 
        (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1, 
        (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1, 
        (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1, 
        (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1, 
        (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1, 
        (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1, 
        (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1, 
        (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1, 
        (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1, 
        (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1, 
        (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1, 
        (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1, 
        (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1, 
        (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1, 
        (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )23, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1, 
        (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1, 
        (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1, 
        (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1, 
        (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1, 
        (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1, 
        (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1, 
        (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1, 
        (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1, 
        (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1, 
        (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )24, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0};
#line 117 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/nametab.h"
static unsigned char const   namePages___0[256]  = 
#line 117
  {      (unsigned char const   )25,      (unsigned char const   )3,      (unsigned char const   )26,      (unsigned char const   )27, 
        (unsigned char const   )28,      (unsigned char const   )29,      (unsigned char const   )30,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )31,      (unsigned char const   )32,      (unsigned char const   )33, 
        (unsigned char const   )34,      (unsigned char const   )35,      (unsigned char const   )36,      (unsigned char const   )37, 
        (unsigned char const   )16,      (unsigned char const   )17,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )18,      (unsigned char const   )19, 
        (unsigned char const   )38,      (unsigned char const   )20,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )39,      (unsigned char const   )22,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )1,      (unsigned char const   )1, 
        (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1, 
        (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1, 
        (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1, 
        (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1, 
        (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1, 
        (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1, 
        (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1, 
        (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1, 
        (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1, 
        (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1, 
        (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1, 
        (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1, 
        (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1, 
        (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1, 
        (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1, 
        (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1, 
        (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1, 
        (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1, 
        (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1, 
        (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )23, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1, 
        (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1, 
        (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1, 
        (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1, 
        (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1, 
        (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1, 
        (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1, 
        (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1, 
        (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1, 
        (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1, 
        (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )24, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0};
#line 124 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmltok.c"
static int isNever___0(ENCODING const   *enc , char const   *p ) 
{ 


  {
#line 127
  return (0);
}
}
#line 130 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmltok.c"
static int utf8_isName2___0(ENCODING const   *enc , char const   *p ) 
{ 


  {
#line 133
  return ((int )(namingBitmap___0[(((int const   )namePages___0[((int const   )*((unsigned char const   *)p + 0) >> 2) & 7] << 3) + (((int const   )*((unsigned char const   *)p + 0) & 3) << 1)) + (((int const   )*((unsigned char const   *)p + 1) >> 5) & 1)] & (unsigned int const   )(1 << ((int const   )*((unsigned char const   *)p + 1) & 31))));
}
}
#line 136 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmltok.c"
static int utf8_isName3___0(ENCODING const   *enc , char const   *p ) 
{ 


  {
#line 139
  return ((int )(namingBitmap___0[(((int const   )namePages___0[(((int const   )*((unsigned char const   *)p + 0) & 15) << 4) + (((int const   )*((unsigned char const   *)p + 1) >> 2) & 15)] << 3) + (((int const   )*((unsigned char const   *)p + 1) & 3) << 1)) + (((int const   )*((unsigned char const   *)p + 2) >> 5) & 1)] & (unsigned int const   )(1 << ((int const   )*((unsigned char const   *)p + 2) & 31))));
}
}
#line 144 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmltok.c"
static int utf8_isNmstrt2___0(ENCODING const   *enc , char const   *p ) 
{ 


  {
#line 147
  return ((int )(namingBitmap___0[(((int const   )nmstrtPages___0[((int const   )*((unsigned char const   *)p + 0) >> 2) & 7] << 3) + (((int const   )*((unsigned char const   *)p + 0) & 3) << 1)) + (((int const   )*((unsigned char const   *)p + 1) >> 5) & 1)] & (unsigned int const   )(1 << ((int const   )*((unsigned char const   *)p + 1) & 31))));
}
}
#line 150 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmltok.c"
static int utf8_isNmstrt3___0(ENCODING const   *enc , char const   *p ) 
{ 


  {
#line 153
  return ((int )(namingBitmap___0[(((int const   )nmstrtPages___0[(((int const   )*((unsigned char const   *)p + 0) & 15) << 4) + (((int const   )*((unsigned char const   *)p + 1) >> 2) & 15)] << 3) + (((int const   )*((unsigned char const   *)p + 1) & 3) << 1)) + (((int const   )*((unsigned char const   *)p + 2) >> 5) & 1)] & (unsigned int const   )(1 << ((int const   )*((unsigned char const   *)p + 2) & 31))));
}
}
#line 158 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmltok.c"
static int utf8_isInvalid2___0(ENCODING const   *enc , char const   *p ) 
{ 
  int tmp ;

  {
#line 161
  if ((int const   )*((unsigned char const   *)p) < 194) {
#line 161
    tmp = 1;
  } else
#line 161
  if (((int const   )*((unsigned char const   *)p + 1) & 128) == 0) {
#line 161
    tmp = 1;
  } else
#line 161
  if (((int const   )*((unsigned char const   *)p + 1) & 192) == 192) {
#line 161
    tmp = 1;
  } else {
#line 161
    tmp = 0;
  }
#line 161
  return (tmp);
}
}
#line 164 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmltok.c"
static int utf8_isInvalid3___0(ENCODING const   *enc , char const   *p ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 167
  if (((int const   )*((unsigned char const   *)p + 2) & 128) == 0) {
#line 167
    tmp___4 = 1;
  } else {
#line 167
    if ((int const   )*((unsigned char const   *)p) == 239) {
#line 167
      if ((int const   )*((unsigned char const   *)p + 1) == 191) {
#line 167
        tmp = (int const   )*((unsigned char const   *)p + 2) > 189;
      } else {
#line 167
        tmp = ((int const   )*((unsigned char const   *)p + 2) & 192) == 192;
      }
    } else {
#line 167
      tmp = ((int const   )*((unsigned char const   *)p + 2) & 192) == 192;
    }
#line 167
    if (tmp) {
#line 167
      tmp___4 = 1;
    } else {
#line 167
      if ((int const   )*((unsigned char const   *)p) == 224) {
#line 167
        if ((int const   )*((unsigned char const   *)p + 1) < 160) {
#line 167
          tmp___0 = 1;
        } else
#line 167
        if (((int const   )*((unsigned char const   *)p + 1) & 192) == 192) {
#line 167
          tmp___0 = 1;
        } else {
#line 167
          tmp___0 = 0;
        }
#line 167
        tmp___3 = tmp___0;
      } else {
#line 167
        if (((int const   )*((unsigned char const   *)p + 1) & 128) == 0) {
#line 167
          tmp___2 = 1;
        } else {
#line 167
          if ((int const   )*((unsigned char const   *)p) == 237) {
#line 167
            tmp___1 = (int const   )*((unsigned char const   *)p + 1) > 159;
          } else {
#line 167
            tmp___1 = ((int const   )*((unsigned char const   *)p + 1) & 192) == 192;
          }
#line 167
          if (tmp___1) {
#line 167
            tmp___2 = 1;
          } else {
#line 167
            tmp___2 = 0;
          }
        }
#line 167
        tmp___3 = tmp___2;
      }
#line 167
      if (tmp___3) {
#line 167
        tmp___4 = 1;
      } else {
#line 167
        tmp___4 = 0;
      }
    }
  }
#line 167
  return (tmp___4);
}
}
#line 170 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmltok.c"
static int utf8_isInvalid4___0(ENCODING const   *enc , char const   *p ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 173
  if (((int const   )*((unsigned char const   *)p + 3) & 128) == 0) {
#line 173
    tmp___3 = 1;
  } else
#line 173
  if (((int const   )*((unsigned char const   *)p + 3) & 192) == 192) {
#line 173
    tmp___3 = 1;
  } else
#line 173
  if (((int const   )*((unsigned char const   *)p + 2) & 128) == 0) {
#line 173
    tmp___3 = 1;
  } else
#line 173
  if (((int const   )*((unsigned char const   *)p + 2) & 192) == 192) {
#line 173
    tmp___3 = 1;
  } else {
#line 173
    if ((int const   )*((unsigned char const   *)p) == 240) {
#line 173
      if ((int const   )*((unsigned char const   *)p + 1) < 144) {
#line 173
        tmp = 1;
      } else
#line 173
      if (((int const   )*((unsigned char const   *)p + 1) & 192) == 192) {
#line 173
        tmp = 1;
      } else {
#line 173
        tmp = 0;
      }
#line 173
      tmp___2 = tmp;
    } else {
#line 173
      if (((int const   )*((unsigned char const   *)p + 1) & 128) == 0) {
#line 173
        tmp___1 = 1;
      } else {
#line 173
        if ((int const   )*((unsigned char const   *)p) == 244) {
#line 173
          tmp___0 = (int const   )*((unsigned char const   *)p + 1) > 143;
        } else {
#line 173
          tmp___0 = ((int const   )*((unsigned char const   *)p + 1) & 192) == 192;
        }
#line 173
        if (tmp___0) {
#line 173
          tmp___1 = 1;
        } else {
#line 173
          tmp___1 = 0;
        }
      }
#line 173
      tmp___2 = tmp___1;
    }
#line 173
    if (tmp___2) {
#line 173
      tmp___3 = 1;
    } else {
#line 173
      tmp___3 = 0;
    }
  }
#line 173
  return (tmp___3);
}
}
#line 225
static int checkCharRefNumber___0(int result ) ;
#line 92 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmltok_impl.c"
static int normal_scanComment___0(ENCODING const   *enc , char const   *ptr , char const   *end ,
                                  char const   **nextTokPtr ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 96
  if ((unsigned long )ptr != (unsigned long )end) {
#line 97
    if (! ((int const   )*ptr == 45)) {
#line 98
      *nextTokPtr = ptr;
#line 99
      return (0);
    }
#line 101
    ptr ++;
    {
#line 102
    while (1) {
      while_continue: /* CIL Label */ ;
#line 102
      if (! ((unsigned long )ptr != (unsigned long )end)) {
#line 102
        goto while_break;
      }
      {
#line 104
      if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 5) {
#line 104
        goto case_5;
      }
#line 104
      if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 6) {
#line 104
        goto case_6;
      }
#line 104
      if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 7) {
#line 104
        goto case_7;
      }
#line 104
      if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 8) {
#line 104
        goto case_8;
      }
#line 104
      if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 1) {
#line 104
        goto case_8;
      }
#line 104
      if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 0) {
#line 104
        goto case_8;
      }
#line 105
      if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 27) {
#line 105
        goto case_27;
      }
#line 119
      goto switch_default;
      case_5: /* CIL Label */ 
#line 104
      if (end - ptr < 2L) {
#line 104
        return (-2);
      }
      {
#line 104
      tmp = (*(((struct normal_encoding  const  *)enc)->isInvalid2))(enc, ptr);
      }
#line 104
      if (tmp) {
#line 104
        *nextTokPtr = ptr;
#line 104
        return (0);
      }
#line 104
      ptr += 2;
#line 104
      goto switch_break;
      case_6: /* CIL Label */ 
#line 104
      if (end - ptr < 3L) {
#line 104
        return (-2);
      }
      {
#line 104
      tmp___0 = (*(((struct normal_encoding  const  *)enc)->isInvalid3))(enc, ptr);
      }
#line 104
      if (tmp___0) {
#line 104
        *nextTokPtr = ptr;
#line 104
        return (0);
      }
#line 104
      ptr += 3;
#line 104
      goto switch_break;
      case_7: /* CIL Label */ 
#line 104
      if (end - ptr < 4L) {
#line 104
        return (-2);
      }
      {
#line 104
      tmp___1 = (*(((struct normal_encoding  const  *)enc)->isInvalid4))(enc, ptr);
      }
#line 104
      if (tmp___1) {
#line 104
        *nextTokPtr = ptr;
#line 104
        return (0);
      }
#line 104
      ptr += 4;
#line 104
      goto switch_break;
      case_8: /* CIL Label */ 
      case_1: /* CIL Label */ 
      case_0: /* CIL Label */ 
#line 104
      *nextTokPtr = ptr;
#line 104
      return (0);
      case_27: /* CIL Label */ 
#line 106
      ptr ++;
#line 106
      if ((unsigned long )ptr == (unsigned long )end) {
#line 107
        return (-1);
      }
#line 108
      if ((int const   )*ptr == 45) {
#line 109
        ptr ++;
#line 109
        if ((unsigned long )ptr == (unsigned long )end) {
#line 110
          return (-1);
        }
#line 111
        if (! ((int const   )*ptr == 62)) {
#line 112
          *nextTokPtr = ptr;
#line 113
          return (0);
        }
#line 115
        *nextTokPtr = ptr + 1;
#line 116
        return (13);
      }
#line 118
      goto switch_break;
      switch_default: /* CIL Label */ 
#line 120
      ptr ++;
#line 121
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 125
  return (-1);
}
}
#line 130 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmltok_impl.c"
static int normal_scanDecl___0(ENCODING const   *enc , char const   *ptr , char const   *end ,
                               char const   **nextTokPtr ) 
{ 
  int tmp ;

  {
#line 134
  if ((unsigned long )ptr == (unsigned long )end) {
#line 135
    return (-1);
  }
  {
#line 137
  if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 27) {
#line 137
    goto case_27;
  }
#line 139
  if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 20) {
#line 139
    goto case_20;
  }
#line 143
  if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 24) {
#line 143
    goto case_24;
  }
#line 143
  if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 22) {
#line 143
    goto case_24;
  }
#line 146
  goto switch_default;
  case_27: /* CIL Label */ 
  {
#line 138
  tmp = normal_scanComment___0(enc, ptr + 1, end, nextTokPtr);
  }
#line 138
  return (tmp);
  case_20: /* CIL Label */ 
#line 140
  *nextTokPtr = ptr + 1;
#line 141
  return (33);
  case_24: /* CIL Label */ 
  case_22: /* CIL Label */ 
#line 144
  ptr ++;
#line 145
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 147
  *nextTokPtr = ptr;
#line 148
  return (0);
  switch_break: /* CIL Label */ ;
  }
  {
#line 150
  while (1) {
    while_continue: /* CIL Label */ ;
#line 150
    if (! ((unsigned long )ptr != (unsigned long )end)) {
#line 150
      goto while_break;
    }
    {
#line 152
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 30) {
#line 152
      goto case_30;
    }
#line 162
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 10) {
#line 162
      goto case_10___0;
    }
#line 162
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 9) {
#line 162
      goto case_10___0;
    }
#line 162
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 21) {
#line 162
      goto case_10___0;
    }
#line 166
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 24) {
#line 166
      goto case_24___0;
    }
#line 166
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 22) {
#line 166
      goto case_24___0;
    }
#line 169
    goto switch_default___0;
    case_30: /* CIL Label */ 
#line 153
    if ((unsigned long )(ptr + 1) == (unsigned long )end) {
#line 154
      return (-1);
    }
    {
#line 157
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*(ptr + 1)] == 30) {
#line 157
      goto case_30___0;
    }
#line 157
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*(ptr + 1)] == 10) {
#line 157
      goto case_30___0;
    }
#line 157
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*(ptr + 1)] == 9) {
#line 157
      goto case_30___0;
    }
#line 157
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*(ptr + 1)] == 21) {
#line 157
      goto case_30___0;
    }
#line 156
    goto switch_break___1;
    case_30___0: /* CIL Label */ 
    case_10: /* CIL Label */ 
    case_9: /* CIL Label */ 
    case_21: /* CIL Label */ 
#line 158
    *nextTokPtr = ptr;
#line 159
    return (0);
    switch_break___1: /* CIL Label */ ;
    }
    case_10___0: /* CIL Label */ 
    case_9___0: /* CIL Label */ 
    case_21___0: /* CIL Label */ 
#line 163
    *nextTokPtr = ptr;
#line 164
    return (16);
    case_24___0: /* CIL Label */ 
    case_22___0: /* CIL Label */ 
#line 167
    ptr ++;
#line 168
    goto switch_break___0;
    switch_default___0: /* CIL Label */ 
#line 170
    *nextTokPtr = ptr;
#line 171
    return (0);
    switch_break___0: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 174
  return (-1);
}
}
#line 177 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmltok_impl.c"
static int normal_checkPiTarget___0(ENCODING const   *enc , char const   *ptr , char const   *end ,
                                    int *tokPtr ) 
{ 
  int upper ;

  {
#line 181
  upper = 0;
#line 182
  *tokPtr = 11;
#line 183
  if (end - ptr != 3L) {
#line 184
    return (1);
  }
  {
#line 186
  if ((int const   )*ptr == 120) {
#line 186
    goto case_120;
  }
#line 188
  if ((int const   )*ptr == 88) {
#line 188
    goto case_88;
  }
#line 191
  goto switch_default;
  case_120: /* CIL Label */ 
#line 187
  goto switch_break;
  case_88: /* CIL Label */ 
#line 189
  upper = 1;
#line 190
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 192
  return (1);
  switch_break: /* CIL Label */ ;
  }
#line 194
  ptr ++;
  {
#line 196
  if ((int const   )*ptr == 109) {
#line 196
    goto case_109;
  }
#line 198
  if ((int const   )*ptr == 77) {
#line 198
    goto case_77;
  }
#line 201
  goto switch_default___0;
  case_109: /* CIL Label */ 
#line 197
  goto switch_break___0;
  case_77: /* CIL Label */ 
#line 199
  upper = 1;
#line 200
  goto switch_break___0;
  switch_default___0: /* CIL Label */ 
#line 202
  return (1);
  switch_break___0: /* CIL Label */ ;
  }
#line 204
  ptr ++;
  {
#line 206
  if ((int const   )*ptr == 108) {
#line 206
    goto case_108;
  }
#line 208
  if ((int const   )*ptr == 76) {
#line 208
    goto case_76;
  }
#line 211
  goto switch_default___1;
  case_108: /* CIL Label */ 
#line 207
  goto switch_break___1;
  case_76: /* CIL Label */ 
#line 209
  upper = 1;
#line 210
  goto switch_break___1;
  switch_default___1: /* CIL Label */ 
#line 212
  return (1);
  switch_break___1: /* CIL Label */ ;
  }
#line 214
  if (upper) {
#line 215
    return (0);
  }
#line 216
  *tokPtr = 12;
#line 217
  return (1);
}
}
#line 222 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmltok_impl.c"
static int normal_scanPi___0(ENCODING const   *enc , char const   *ptr , char const   *end ,
                             char const   **nextTokPtr ) 
{ 
  int tok ;
  char const   *target ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;

  {
#line 227
  target = ptr;
#line 228
  if ((unsigned long )ptr == (unsigned long )end) {
#line 229
    return (-1);
  }
  {
#line 231
  if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 29) {
#line 231
    goto case_29;
  }
#line 231
  if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 24) {
#line 231
    goto case_24;
  }
#line 231
  if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 22) {
#line 231
    goto case_24;
  }
#line 231
  if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 5) {
#line 231
    goto case_5;
  }
#line 231
  if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 6) {
#line 231
    goto case_6;
  }
#line 231
  if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 7) {
#line 231
    goto case_7;
  }
#line 232
  goto switch_default;
  case_29: /* CIL Label */ 
#line 231
  *nextTokPtr = ptr;
#line 231
  return (0);
  case_24: /* CIL Label */ 
  case_22: /* CIL Label */ 
#line 231
  ptr ++;
#line 231
  goto switch_break;
  case_5: /* CIL Label */ 
#line 231
  if (end - ptr < 2L) {
#line 231
    return (-2);
  }
  {
#line 231
  tmp = (*(((struct normal_encoding  const  *)enc)->isNmstrt2))(enc, ptr);
  }
#line 231
  if (! tmp) {
#line 231
    *nextTokPtr = ptr;
#line 231
    return (0);
  }
#line 231
  ptr += 2;
#line 231
  goto switch_break;
  case_6: /* CIL Label */ 
#line 231
  if (end - ptr < 3L) {
#line 231
    return (-2);
  }
  {
#line 231
  tmp___0 = (*(((struct normal_encoding  const  *)enc)->isNmstrt3))(enc, ptr);
  }
#line 231
  if (! tmp___0) {
#line 231
    *nextTokPtr = ptr;
#line 231
    return (0);
  }
#line 231
  ptr += 3;
#line 231
  goto switch_break;
  case_7: /* CIL Label */ 
#line 231
  if (end - ptr < 4L) {
#line 231
    return (-2);
  }
  {
#line 231
  tmp___1 = (*(((struct normal_encoding  const  *)enc)->isNmstrt4))(enc, ptr);
  }
#line 231
  if (! tmp___1) {
#line 231
    *nextTokPtr = ptr;
#line 231
    return (0);
  }
#line 231
  ptr += 4;
#line 231
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 233
  *nextTokPtr = ptr;
#line 234
  return (0);
  switch_break: /* CIL Label */ ;
  }
  {
#line 236
  while (1) {
    while_continue: /* CIL Label */ ;
#line 236
    if (! ((unsigned long )ptr != (unsigned long )end)) {
#line 236
      goto while_break;
    }
    {
#line 238
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 29) {
#line 238
      goto case_29___0;
    }
#line 238
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 27) {
#line 238
      goto case_27;
    }
#line 238
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 26) {
#line 238
      goto case_27;
    }
#line 238
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 25) {
#line 238
      goto case_27;
    }
#line 238
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 24) {
#line 238
      goto case_27;
    }
#line 238
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 22) {
#line 238
      goto case_27;
    }
#line 238
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 5) {
#line 238
      goto case_5___0;
    }
#line 238
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 6) {
#line 238
      goto case_6___0;
    }
#line 238
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 7) {
#line 238
      goto case_7___0;
    }
#line 239
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 10) {
#line 239
      goto case_10;
    }
#line 239
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 9) {
#line 239
      goto case_10;
    }
#line 239
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 21) {
#line 239
      goto case_10;
    }
#line 263
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 15) {
#line 263
      goto case_15___0;
    }
#line 276
    goto switch_default___1;
    case_29___0: /* CIL Label */ 
#line 238
    *nextTokPtr = ptr;
#line 238
    return (0);
    case_27: /* CIL Label */ 
    case_26: /* CIL Label */ 
    case_25: /* CIL Label */ 
    case_24___0: /* CIL Label */ 
    case_22___0: /* CIL Label */ 
#line 238
    ptr ++;
#line 238
    goto switch_break___0;
    case_5___0: /* CIL Label */ 
#line 238
    if (end - ptr < 2L) {
#line 238
      return (-2);
    }
    {
#line 238
    tmp___2 = (*(((struct normal_encoding  const  *)enc)->isName2))(enc, ptr);
    }
#line 238
    if (! tmp___2) {
#line 238
      *nextTokPtr = ptr;
#line 238
      return (0);
    }
#line 238
    ptr += 2;
#line 238
    goto switch_break___0;
    case_6___0: /* CIL Label */ 
#line 238
    if (end - ptr < 3L) {
#line 238
      return (-2);
    }
    {
#line 238
    tmp___3 = (*(((struct normal_encoding  const  *)enc)->isName3))(enc, ptr);
    }
#line 238
    if (! tmp___3) {
#line 238
      *nextTokPtr = ptr;
#line 238
      return (0);
    }
#line 238
    ptr += 3;
#line 238
    goto switch_break___0;
    case_7___0: /* CIL Label */ 
#line 238
    if (end - ptr < 4L) {
#line 238
      return (-2);
    }
    {
#line 238
    tmp___4 = (*(((struct normal_encoding  const  *)enc)->isName4))(enc, ptr);
    }
#line 238
    if (! tmp___4) {
#line 238
      *nextTokPtr = ptr;
#line 238
      return (0);
    }
#line 238
    ptr += 4;
#line 238
    goto switch_break___0;
    case_10: /* CIL Label */ 
    case_9: /* CIL Label */ 
    case_21: /* CIL Label */ 
    {
#line 240
    tmp___5 = normal_checkPiTarget___0(enc, target, ptr, & tok);
    }
#line 240
    if (! tmp___5) {
#line 241
      *nextTokPtr = ptr;
#line 242
      return (0);
    }
#line 244
    ptr ++;
    {
#line 245
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 245
      if (! ((unsigned long )ptr != (unsigned long )end)) {
#line 245
        goto while_break___0;
      }
      {
#line 247
      if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 5) {
#line 247
        goto case_5___1;
      }
#line 247
      if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 6) {
#line 247
        goto case_6___1;
      }
#line 247
      if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 7) {
#line 247
        goto case_7___1;
      }
#line 247
      if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 8) {
#line 247
        goto case_8;
      }
#line 247
      if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 1) {
#line 247
        goto case_8;
      }
#line 247
      if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 0) {
#line 247
        goto case_8;
      }
#line 248
      if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 15) {
#line 248
        goto case_15;
      }
#line 257
      goto switch_default___0;
      case_5___1: /* CIL Label */ 
#line 247
      if (end - ptr < 2L) {
#line 247
        return (-2);
      }
      {
#line 247
      tmp___6 = (*(((struct normal_encoding  const  *)enc)->isInvalid2))(enc, ptr);
      }
#line 247
      if (tmp___6) {
#line 247
        *nextTokPtr = ptr;
#line 247
        return (0);
      }
#line 247
      ptr += 2;
#line 247
      goto switch_break___1;
      case_6___1: /* CIL Label */ 
#line 247
      if (end - ptr < 3L) {
#line 247
        return (-2);
      }
      {
#line 247
      tmp___7 = (*(((struct normal_encoding  const  *)enc)->isInvalid3))(enc, ptr);
      }
#line 247
      if (tmp___7) {
#line 247
        *nextTokPtr = ptr;
#line 247
        return (0);
      }
#line 247
      ptr += 3;
#line 247
      goto switch_break___1;
      case_7___1: /* CIL Label */ 
#line 247
      if (end - ptr < 4L) {
#line 247
        return (-2);
      }
      {
#line 247
      tmp___8 = (*(((struct normal_encoding  const  *)enc)->isInvalid4))(enc, ptr);
      }
#line 247
      if (tmp___8) {
#line 247
        *nextTokPtr = ptr;
#line 247
        return (0);
      }
#line 247
      ptr += 4;
#line 247
      goto switch_break___1;
      case_8: /* CIL Label */ 
      case_1: /* CIL Label */ 
      case_0: /* CIL Label */ 
#line 247
      *nextTokPtr = ptr;
#line 247
      return (0);
      case_15: /* CIL Label */ 
#line 249
      ptr ++;
#line 250
      if ((unsigned long )ptr == (unsigned long )end) {
#line 251
        return (-1);
      }
#line 252
      if ((int const   )*ptr == 62) {
#line 253
        *nextTokPtr = ptr + 1;
#line 254
        return (tok);
      }
#line 256
      goto switch_break___1;
      switch_default___0: /* CIL Label */ 
#line 258
      ptr ++;
#line 259
      goto switch_break___1;
      switch_break___1: /* CIL Label */ ;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 262
    return (-1);
    case_15___0: /* CIL Label */ 
    {
#line 264
    tmp___9 = normal_checkPiTarget___0(enc, target, ptr, & tok);
    }
#line 264
    if (! tmp___9) {
#line 265
      *nextTokPtr = ptr;
#line 266
      return (0);
    }
#line 268
    ptr ++;
#line 269
    if ((unsigned long )ptr == (unsigned long )end) {
#line 270
      return (-1);
    }
#line 271
    if ((int const   )*ptr == 62) {
#line 272
      *nextTokPtr = ptr + 1;
#line 273
      return (tok);
    }
    switch_default___1: /* CIL Label */ 
#line 277
    *nextTokPtr = ptr;
#line 278
    return (0);
    switch_break___0: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 281
  return (-1);
}
}
#line 288
static int normal_scanCdataSection___0(ENCODING const   *enc , char const   *ptr ,
                                       char const   *end , char const   **nextTokPtr ) ;
#line 288 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmltok_impl.c"
static char const   CDATA_LSQB___2[6]  = {      (char const   )67,      (char const   )68,      (char const   )65,      (char const   )84, 
        (char const   )65,      (char const   )91};
#line 284 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmltok_impl.c"
static int normal_scanCdataSection___0(ENCODING const   *enc , char const   *ptr ,
                                       char const   *end , char const   **nextTokPtr ) 
{ 
  int i ;

  {
#line 292
  if (end - ptr < 6L) {
#line 293
    return (-1);
  }
#line 294
  i = 0;
  {
#line 294
  while (1) {
    while_continue: /* CIL Label */ ;
#line 294
    if (! (i < 6)) {
#line 294
      goto while_break;
    }
#line 295
    if (! ((int const   )*ptr == (int const   )CDATA_LSQB___2[i])) {
#line 296
      *nextTokPtr = ptr;
#line 297
      return (0);
    }
#line 294
    i ++;
#line 294
    ptr ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 300
  *nextTokPtr = ptr;
#line 301
  return (8);
}
}
#line 304 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmltok_impl.c"
static int normal_cdataSectionTok___0(ENCODING const   *enc , char const   *ptr ,
                                      char const   *end , char const   **nextTokPtr ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 308
  if ((unsigned long )ptr == (unsigned long )end) {
#line 309
    return (-4);
  }
  {
#line 320
  if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 4) {
#line 320
    goto case_4;
  }
#line 335
  if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 9) {
#line 335
    goto case_9;
  }
#line 343
  if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 10) {
#line 343
    goto case_10;
  }
#line 346
  if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 5) {
#line 346
    goto case_5;
  }
#line 346
  if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 6) {
#line 346
    goto case_6;
  }
#line 346
  if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 7) {
#line 346
    goto case_7;
  }
#line 346
  if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 8) {
#line 346
    goto case_8;
  }
#line 346
  if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 1) {
#line 346
    goto case_8;
  }
#line 346
  if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 0) {
#line 346
    goto case_8;
  }
#line 347
  goto switch_default;
  case_4: /* CIL Label */ 
#line 321
  ptr ++;
#line 322
  if ((unsigned long )ptr == (unsigned long )end) {
#line 323
    return (-1);
  }
#line 324
  if (! ((int const   )*ptr == 93)) {
#line 325
    goto switch_break;
  }
#line 326
  ptr ++;
#line 327
  if ((unsigned long )ptr == (unsigned long )end) {
#line 328
    return (-1);
  }
#line 329
  if (! ((int const   )*ptr == 62)) {
#line 330
    ptr --;
#line 331
    goto switch_break;
  }
#line 333
  *nextTokPtr = ptr + 1;
#line 334
  return (40);
  case_9: /* CIL Label */ 
#line 336
  ptr ++;
#line 337
  if ((unsigned long )ptr == (unsigned long )end) {
#line 338
    return (-1);
  }
#line 339
  if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 10) {
#line 340
    ptr ++;
  }
#line 341
  *nextTokPtr = ptr;
#line 342
  return (7);
  case_10: /* CIL Label */ 
#line 344
  *nextTokPtr = ptr + 1;
#line 345
  return (7);
  case_5: /* CIL Label */ 
#line 346
  if (end - ptr < 2L) {
#line 346
    return (-2);
  }
  {
#line 346
  tmp = (*(((struct normal_encoding  const  *)enc)->isInvalid2))(enc, ptr);
  }
#line 346
  if (tmp) {
#line 346
    *nextTokPtr = ptr;
#line 346
    return (0);
  }
#line 346
  ptr += 2;
#line 346
  goto switch_break;
  case_6: /* CIL Label */ 
#line 346
  if (end - ptr < 3L) {
#line 346
    return (-2);
  }
  {
#line 346
  tmp___0 = (*(((struct normal_encoding  const  *)enc)->isInvalid3))(enc, ptr);
  }
#line 346
  if (tmp___0) {
#line 346
    *nextTokPtr = ptr;
#line 346
    return (0);
  }
#line 346
  ptr += 3;
#line 346
  goto switch_break;
  case_7: /* CIL Label */ 
#line 346
  if (end - ptr < 4L) {
#line 346
    return (-2);
  }
  {
#line 346
  tmp___1 = (*(((struct normal_encoding  const  *)enc)->isInvalid4))(enc, ptr);
  }
#line 346
  if (tmp___1) {
#line 346
    *nextTokPtr = ptr;
#line 346
    return (0);
  }
#line 346
  ptr += 4;
#line 346
  goto switch_break;
  case_8: /* CIL Label */ 
  case_1: /* CIL Label */ 
  case_0: /* CIL Label */ 
#line 346
  *nextTokPtr = ptr;
#line 346
  return (0);
  switch_default: /* CIL Label */ 
#line 348
  ptr ++;
#line 349
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 351
  while (1) {
    while_continue: /* CIL Label */ ;
#line 351
    if (! ((unsigned long )ptr != (unsigned long )end)) {
#line 351
      goto while_break;
    }
    {
#line 361
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 5) {
#line 361
      goto case_5___0;
    }
#line 361
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 6) {
#line 361
      goto case_6___0;
    }
#line 361
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 7) {
#line 361
      goto case_7___0;
    }
#line 368
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 4) {
#line 368
      goto case_4___0;
    }
#line 368
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 10) {
#line 368
      goto case_4___0;
    }
#line 368
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 9) {
#line 368
      goto case_4___0;
    }
#line 368
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 8) {
#line 368
      goto case_4___0;
    }
#line 368
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 1) {
#line 368
      goto case_4___0;
    }
#line 368
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 0) {
#line 368
      goto case_4___0;
    }
#line 371
    goto switch_default___0;
    case_5___0: /* CIL Label */ 
#line 361
    if (end - ptr < 2L) {
#line 361
      *nextTokPtr = ptr;
#line 361
      return (6);
    } else {
      {
#line 361
      tmp___2 = (*(((struct normal_encoding  const  *)enc)->isInvalid2))(enc, ptr);
      }
#line 361
      if (tmp___2) {
#line 361
        *nextTokPtr = ptr;
#line 361
        return (6);
      }
    }
#line 361
    ptr += 2;
#line 361
    goto switch_break___0;
    case_6___0: /* CIL Label */ 
#line 361
    if (end - ptr < 3L) {
#line 361
      *nextTokPtr = ptr;
#line 361
      return (6);
    } else {
      {
#line 361
      tmp___3 = (*(((struct normal_encoding  const  *)enc)->isInvalid3))(enc, ptr);
      }
#line 361
      if (tmp___3) {
#line 361
        *nextTokPtr = ptr;
#line 361
        return (6);
      }
    }
#line 361
    ptr += 3;
#line 361
    goto switch_break___0;
    case_7___0: /* CIL Label */ 
#line 361
    if (end - ptr < 4L) {
#line 361
      *nextTokPtr = ptr;
#line 361
      return (6);
    } else {
      {
#line 361
      tmp___4 = (*(((struct normal_encoding  const  *)enc)->isInvalid4))(enc, ptr);
      }
#line 361
      if (tmp___4) {
#line 361
        *nextTokPtr = ptr;
#line 361
        return (6);
      }
    }
#line 361
    ptr += 4;
#line 361
    goto switch_break___0;
    case_4___0: /* CIL Label */ 
    case_10___0: /* CIL Label */ 
    case_9___0: /* CIL Label */ 
    case_8___0: /* CIL Label */ 
    case_1___0: /* CIL Label */ 
    case_0___0: /* CIL Label */ 
#line 369
    *nextTokPtr = ptr;
#line 370
    return (6);
    switch_default___0: /* CIL Label */ 
#line 372
    ptr ++;
#line 373
    goto switch_break___0;
    switch_break___0: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 376
  *nextTokPtr = ptr;
#line 377
  return (6);
}
}
#line 382 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmltok_impl.c"
static int normal_scanEndTag___0(ENCODING const   *enc , char const   *ptr , char const   *end ,
                                 char const   **nextTokPtr ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 386
  if ((unsigned long )ptr == (unsigned long )end) {
#line 387
    return (-1);
  }
  {
#line 389
  if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 29) {
#line 389
    goto case_29;
  }
#line 389
  if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 24) {
#line 389
    goto case_24;
  }
#line 389
  if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 22) {
#line 389
    goto case_24;
  }
#line 389
  if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 5) {
#line 389
    goto case_5;
  }
#line 389
  if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 6) {
#line 389
    goto case_6;
  }
#line 389
  if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 7) {
#line 389
    goto case_7;
  }
#line 390
  goto switch_default;
  case_29: /* CIL Label */ 
#line 389
  *nextTokPtr = ptr;
#line 389
  return (0);
  case_24: /* CIL Label */ 
  case_22: /* CIL Label */ 
#line 389
  ptr ++;
#line 389
  goto switch_break;
  case_5: /* CIL Label */ 
#line 389
  if (end - ptr < 2L) {
#line 389
    return (-2);
  }
  {
#line 389
  tmp = (*(((struct normal_encoding  const  *)enc)->isNmstrt2))(enc, ptr);
  }
#line 389
  if (! tmp) {
#line 389
    *nextTokPtr = ptr;
#line 389
    return (0);
  }
#line 389
  ptr += 2;
#line 389
  goto switch_break;
  case_6: /* CIL Label */ 
#line 389
  if (end - ptr < 3L) {
#line 389
    return (-2);
  }
  {
#line 389
  tmp___0 = (*(((struct normal_encoding  const  *)enc)->isNmstrt3))(enc, ptr);
  }
#line 389
  if (! tmp___0) {
#line 389
    *nextTokPtr = ptr;
#line 389
    return (0);
  }
#line 389
  ptr += 3;
#line 389
  goto switch_break;
  case_7: /* CIL Label */ 
#line 389
  if (end - ptr < 4L) {
#line 389
    return (-2);
  }
  {
#line 389
  tmp___1 = (*(((struct normal_encoding  const  *)enc)->isNmstrt4))(enc, ptr);
  }
#line 389
  if (! tmp___1) {
#line 389
    *nextTokPtr = ptr;
#line 389
    return (0);
  }
#line 389
  ptr += 4;
#line 389
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 391
  *nextTokPtr = ptr;
#line 392
  return (0);
  switch_break: /* CIL Label */ ;
  }
  {
#line 394
  while (1) {
    while_continue: /* CIL Label */ ;
#line 394
    if (! ((unsigned long )ptr != (unsigned long )end)) {
#line 394
      goto while_break;
    }
    {
#line 396
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 29) {
#line 396
      goto case_29___0;
    }
#line 396
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 27) {
#line 396
      goto case_27;
    }
#line 396
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 26) {
#line 396
      goto case_27;
    }
#line 396
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 25) {
#line 396
      goto case_27;
    }
#line 396
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 24) {
#line 396
      goto case_27;
    }
#line 396
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 22) {
#line 396
      goto case_27;
    }
#line 396
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 5) {
#line 396
      goto case_5___0;
    }
#line 396
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 6) {
#line 396
      goto case_6___0;
    }
#line 396
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 7) {
#line 396
      goto case_7___0;
    }
#line 397
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 10) {
#line 397
      goto case_10;
    }
#line 397
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 9) {
#line 397
      goto case_10;
    }
#line 397
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 21) {
#line 397
      goto case_10;
    }
#line 412
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 23) {
#line 412
      goto case_23;
    }
#line 418
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 11) {
#line 418
      goto case_11___0;
    }
#line 421
    goto switch_default___1;
    case_29___0: /* CIL Label */ 
#line 396
    *nextTokPtr = ptr;
#line 396
    return (0);
    case_27: /* CIL Label */ 
    case_26: /* CIL Label */ 
    case_25: /* CIL Label */ 
    case_24___0: /* CIL Label */ 
    case_22___0: /* CIL Label */ 
#line 396
    ptr ++;
#line 396
    goto switch_break___0;
    case_5___0: /* CIL Label */ 
#line 396
    if (end - ptr < 2L) {
#line 396
      return (-2);
    }
    {
#line 396
    tmp___2 = (*(((struct normal_encoding  const  *)enc)->isName2))(enc, ptr);
    }
#line 396
    if (! tmp___2) {
#line 396
      *nextTokPtr = ptr;
#line 396
      return (0);
    }
#line 396
    ptr += 2;
#line 396
    goto switch_break___0;
    case_6___0: /* CIL Label */ 
#line 396
    if (end - ptr < 3L) {
#line 396
      return (-2);
    }
    {
#line 396
    tmp___3 = (*(((struct normal_encoding  const  *)enc)->isName3))(enc, ptr);
    }
#line 396
    if (! tmp___3) {
#line 396
      *nextTokPtr = ptr;
#line 396
      return (0);
    }
#line 396
    ptr += 3;
#line 396
    goto switch_break___0;
    case_7___0: /* CIL Label */ 
#line 396
    if (end - ptr < 4L) {
#line 396
      return (-2);
    }
    {
#line 396
    tmp___4 = (*(((struct normal_encoding  const  *)enc)->isName4))(enc, ptr);
    }
#line 396
    if (! tmp___4) {
#line 396
      *nextTokPtr = ptr;
#line 396
      return (0);
    }
#line 396
    ptr += 4;
#line 396
    goto switch_break___0;
    case_10: /* CIL Label */ 
    case_9: /* CIL Label */ 
    case_21: /* CIL Label */ 
#line 398
    ptr ++;
    {
#line 398
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 398
      if (! ((unsigned long )ptr != (unsigned long )end)) {
#line 398
        goto while_break___0;
      }
      {
#line 400
      if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 10) {
#line 400
        goto case_10___0;
      }
#line 400
      if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 9) {
#line 400
        goto case_10___0;
      }
#line 400
      if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 21) {
#line 400
        goto case_10___0;
      }
#line 402
      if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 11) {
#line 402
        goto case_11;
      }
#line 405
      goto switch_default___0;
      case_10___0: /* CIL Label */ 
      case_9___0: /* CIL Label */ 
      case_21___0: /* CIL Label */ 
#line 401
      goto switch_break___1;
      case_11: /* CIL Label */ 
#line 403
      *nextTokPtr = ptr + 1;
#line 404
      return (5);
      switch_default___0: /* CIL Label */ 
#line 406
      *nextTokPtr = ptr;
#line 407
      return (0);
      switch_break___1: /* CIL Label */ ;
      }
#line 398
      ptr ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 410
    return (-1);
    case_23: /* CIL Label */ 
#line 415
    ptr ++;
#line 416
    goto switch_break___0;
    case_11___0: /* CIL Label */ 
#line 419
    *nextTokPtr = ptr + 1;
#line 420
    return (5);
    switch_default___1: /* CIL Label */ 
#line 422
    *nextTokPtr = ptr;
#line 423
    return (0);
    switch_break___0: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 426
  return (-1);
}
}
#line 431 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmltok_impl.c"
static int normal_scanHexCharRef___0(ENCODING const   *enc , char const   *ptr , char const   *end ,
                                     char const   **nextTokPtr ) 
{ 


  {
#line 435
  if ((unsigned long )ptr != (unsigned long )end) {
    {
#line 438
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 24) {
#line 438
      goto case_24;
    }
#line 438
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 25) {
#line 438
      goto case_24;
    }
#line 440
    goto switch_default;
    case_24: /* CIL Label */ 
    case_25: /* CIL Label */ 
#line 439
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 441
    *nextTokPtr = ptr;
#line 442
    return (0);
    switch_break: /* CIL Label */ ;
    }
#line 444
    ptr ++;
    {
#line 444
    while (1) {
      while_continue: /* CIL Label */ ;
#line 444
      if (! ((unsigned long )ptr != (unsigned long )end)) {
#line 444
        goto while_break;
      }
      {
#line 447
      if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 24) {
#line 447
        goto case_24___0;
      }
#line 447
      if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 25) {
#line 447
        goto case_24___0;
      }
#line 449
      if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 18) {
#line 449
        goto case_18;
      }
#line 452
      goto switch_default___0;
      case_24___0: /* CIL Label */ 
      case_25___0: /* CIL Label */ 
#line 448
      goto switch_break___0;
      case_18: /* CIL Label */ 
#line 450
      *nextTokPtr = ptr + 1;
#line 451
      return (10);
      switch_default___0: /* CIL Label */ 
#line 453
      *nextTokPtr = ptr;
#line 454
      return (0);
      switch_break___0: /* CIL Label */ ;
      }
#line 444
      ptr ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 458
  return (-1);
}
}
#line 463 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmltok_impl.c"
static int normal_scanCharRef___0(ENCODING const   *enc , char const   *ptr , char const   *end ,
                                  char const   **nextTokPtr ) 
{ 
  int tmp ;

  {
#line 467
  if ((unsigned long )ptr != (unsigned long )end) {
#line 468
    if ((int const   )*ptr == 120) {
      {
#line 469
      tmp = normal_scanHexCharRef___0(enc, ptr + 1, end, nextTokPtr);
      }
#line 469
      return (tmp);
    }
    {
#line 471
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 25) {
#line 471
      goto case_25;
    }
#line 473
    goto switch_default;
    case_25: /* CIL Label */ 
#line 472
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 474
    *nextTokPtr = ptr;
#line 475
    return (0);
    switch_break: /* CIL Label */ ;
    }
#line 477
    ptr ++;
    {
#line 477
    while (1) {
      while_continue: /* CIL Label */ ;
#line 477
      if (! ((unsigned long )ptr != (unsigned long )end)) {
#line 477
        goto while_break;
      }
      {
#line 479
      if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 25) {
#line 479
        goto case_25___0;
      }
#line 481
      if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 18) {
#line 481
        goto case_18;
      }
#line 484
      goto switch_default___0;
      case_25___0: /* CIL Label */ 
#line 480
      goto switch_break___0;
      case_18: /* CIL Label */ 
#line 482
      *nextTokPtr = ptr + 1;
#line 483
      return (10);
      switch_default___0: /* CIL Label */ 
#line 485
      *nextTokPtr = ptr;
#line 486
      return (0);
      switch_break___0: /* CIL Label */ ;
      }
#line 477
      ptr ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 490
  return (-1);
}
}
#line 495 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmltok_impl.c"
static int normal_scanRef___0(ENCODING const   *enc , char const   *ptr , char const   *end ,
                              char const   **nextTokPtr ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 499
  if ((unsigned long )ptr == (unsigned long )end) {
#line 500
    return (-1);
  }
  {
#line 502
  if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 29) {
#line 502
    goto case_29;
  }
#line 502
  if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 24) {
#line 502
    goto case_24;
  }
#line 502
  if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 22) {
#line 502
    goto case_24;
  }
#line 502
  if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 5) {
#line 502
    goto case_5;
  }
#line 502
  if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 6) {
#line 502
    goto case_6;
  }
#line 502
  if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 7) {
#line 502
    goto case_7;
  }
#line 503
  if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 19) {
#line 503
    goto case_19;
  }
#line 505
  goto switch_default;
  case_29: /* CIL Label */ 
#line 502
  *nextTokPtr = ptr;
#line 502
  return (0);
  case_24: /* CIL Label */ 
  case_22: /* CIL Label */ 
#line 502
  ptr ++;
#line 502
  goto switch_break;
  case_5: /* CIL Label */ 
#line 502
  if (end - ptr < 2L) {
#line 502
    return (-2);
  }
  {
#line 502
  tmp = (*(((struct normal_encoding  const  *)enc)->isNmstrt2))(enc, ptr);
  }
#line 502
  if (! tmp) {
#line 502
    *nextTokPtr = ptr;
#line 502
    return (0);
  }
#line 502
  ptr += 2;
#line 502
  goto switch_break;
  case_6: /* CIL Label */ 
#line 502
  if (end - ptr < 3L) {
#line 502
    return (-2);
  }
  {
#line 502
  tmp___0 = (*(((struct normal_encoding  const  *)enc)->isNmstrt3))(enc, ptr);
  }
#line 502
  if (! tmp___0) {
#line 502
    *nextTokPtr = ptr;
#line 502
    return (0);
  }
#line 502
  ptr += 3;
#line 502
  goto switch_break;
  case_7: /* CIL Label */ 
#line 502
  if (end - ptr < 4L) {
#line 502
    return (-2);
  }
  {
#line 502
  tmp___1 = (*(((struct normal_encoding  const  *)enc)->isNmstrt4))(enc, ptr);
  }
#line 502
  if (! tmp___1) {
#line 502
    *nextTokPtr = ptr;
#line 502
    return (0);
  }
#line 502
  ptr += 4;
#line 502
  goto switch_break;
  case_19: /* CIL Label */ 
  {
#line 504
  tmp___2 = normal_scanCharRef___0(enc, ptr + 1, end, nextTokPtr);
  }
#line 504
  return (tmp___2);
  switch_default: /* CIL Label */ 
#line 506
  *nextTokPtr = ptr;
#line 507
  return (0);
  switch_break: /* CIL Label */ ;
  }
  {
#line 509
  while (1) {
    while_continue: /* CIL Label */ ;
#line 509
    if (! ((unsigned long )ptr != (unsigned long )end)) {
#line 509
      goto while_break;
    }
    {
#line 511
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 29) {
#line 511
      goto case_29___0;
    }
#line 511
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 27) {
#line 511
      goto case_27;
    }
#line 511
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 26) {
#line 511
      goto case_27;
    }
#line 511
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 25) {
#line 511
      goto case_27;
    }
#line 511
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 24) {
#line 511
      goto case_27;
    }
#line 511
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 22) {
#line 511
      goto case_27;
    }
#line 511
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 5) {
#line 511
      goto case_5___0;
    }
#line 511
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 6) {
#line 511
      goto case_6___0;
    }
#line 511
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 7) {
#line 511
      goto case_7___0;
    }
#line 512
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 18) {
#line 512
      goto case_18;
    }
#line 515
    goto switch_default___0;
    case_29___0: /* CIL Label */ 
#line 511
    *nextTokPtr = ptr;
#line 511
    return (0);
    case_27: /* CIL Label */ 
    case_26: /* CIL Label */ 
    case_25: /* CIL Label */ 
    case_24___0: /* CIL Label */ 
    case_22___0: /* CIL Label */ 
#line 511
    ptr ++;
#line 511
    goto switch_break___0;
    case_5___0: /* CIL Label */ 
#line 511
    if (end - ptr < 2L) {
#line 511
      return (-2);
    }
    {
#line 511
    tmp___3 = (*(((struct normal_encoding  const  *)enc)->isName2))(enc, ptr);
    }
#line 511
    if (! tmp___3) {
#line 511
      *nextTokPtr = ptr;
#line 511
      return (0);
    }
#line 511
    ptr += 2;
#line 511
    goto switch_break___0;
    case_6___0: /* CIL Label */ 
#line 511
    if (end - ptr < 3L) {
#line 511
      return (-2);
    }
    {
#line 511
    tmp___4 = (*(((struct normal_encoding  const  *)enc)->isName3))(enc, ptr);
    }
#line 511
    if (! tmp___4) {
#line 511
      *nextTokPtr = ptr;
#line 511
      return (0);
    }
#line 511
    ptr += 3;
#line 511
    goto switch_break___0;
    case_7___0: /* CIL Label */ 
#line 511
    if (end - ptr < 4L) {
#line 511
      return (-2);
    }
    {
#line 511
    tmp___5 = (*(((struct normal_encoding  const  *)enc)->isName4))(enc, ptr);
    }
#line 511
    if (! tmp___5) {
#line 511
      *nextTokPtr = ptr;
#line 511
      return (0);
    }
#line 511
    ptr += 4;
#line 511
    goto switch_break___0;
    case_18: /* CIL Label */ 
#line 513
    *nextTokPtr = ptr + 1;
#line 514
    return (9);
    switch_default___0: /* CIL Label */ 
#line 516
    *nextTokPtr = ptr;
#line 517
    return (0);
    switch_break___0: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 520
  return (-1);
}
}
#line 525 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmltok_impl.c"
static int normal_scanAtts___0(ENCODING const   *enc , char const   *ptr , char const   *end ,
                               char const   **nextTokPtr ) 
{ 
  int hadColon ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int t ;
  int open___0 ;
  int t___0 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tok ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;

  {
#line 530
  hadColon = 0;
  {
#line 532
  while (1) {
    while_continue: /* CIL Label */ ;
#line 532
    if (! ((unsigned long )ptr != (unsigned long )end)) {
#line 532
      goto while_break;
    }
    {
#line 534
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 29) {
#line 534
      goto case_29;
    }
#line 534
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 27) {
#line 534
      goto case_27;
    }
#line 534
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 26) {
#line 534
      goto case_27;
    }
#line 534
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 25) {
#line 534
      goto case_27;
    }
#line 534
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 24) {
#line 534
      goto case_27;
    }
#line 534
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 22) {
#line 534
      goto case_27;
    }
#line 534
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 5) {
#line 534
      goto case_5;
    }
#line 534
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 6) {
#line 534
      goto case_6;
    }
#line 534
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 7) {
#line 534
      goto case_7;
    }
#line 536
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 23) {
#line 536
      goto case_23;
    }
#line 553
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 10) {
#line 553
      goto case_10;
    }
#line 553
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 9) {
#line 553
      goto case_10;
    }
#line 553
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 21) {
#line 553
      goto case_10;
    }
#line 574
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 14) {
#line 574
      goto case_14;
    }
#line 674
    goto switch_default___5;
    case_29: /* CIL Label */ 
#line 534
    *nextTokPtr = ptr;
#line 534
    return (0);
    case_27: /* CIL Label */ 
    case_26: /* CIL Label */ 
    case_25: /* CIL Label */ 
    case_24: /* CIL Label */ 
    case_22: /* CIL Label */ 
#line 534
    ptr ++;
#line 534
    goto switch_break;
    case_5: /* CIL Label */ 
#line 534
    if (end - ptr < 2L) {
#line 534
      return (-2);
    }
    {
#line 534
    tmp = (*(((struct normal_encoding  const  *)enc)->isName2))(enc, ptr);
    }
#line 534
    if (! tmp) {
#line 534
      *nextTokPtr = ptr;
#line 534
      return (0);
    }
#line 534
    ptr += 2;
#line 534
    goto switch_break;
    case_6: /* CIL Label */ 
#line 534
    if (end - ptr < 3L) {
#line 534
      return (-2);
    }
    {
#line 534
    tmp___0 = (*(((struct normal_encoding  const  *)enc)->isName3))(enc, ptr);
    }
#line 534
    if (! tmp___0) {
#line 534
      *nextTokPtr = ptr;
#line 534
      return (0);
    }
#line 534
    ptr += 3;
#line 534
    goto switch_break;
    case_7: /* CIL Label */ 
#line 534
    if (end - ptr < 4L) {
#line 534
      return (-2);
    }
    {
#line 534
    tmp___1 = (*(((struct normal_encoding  const  *)enc)->isName4))(enc, ptr);
    }
#line 534
    if (! tmp___1) {
#line 534
      *nextTokPtr = ptr;
#line 534
      return (0);
    }
#line 534
    ptr += 4;
#line 534
    goto switch_break;
    case_23: /* CIL Label */ 
#line 537
    if (hadColon) {
#line 538
      *nextTokPtr = ptr;
#line 539
      return (0);
    }
#line 541
    hadColon = 1;
#line 542
    ptr ++;
#line 543
    if ((unsigned long )ptr == (unsigned long )end) {
#line 544
      return (-1);
    }
    {
#line 546
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 29) {
#line 546
      goto case_29___0;
    }
#line 546
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 24) {
#line 546
      goto case_24___0;
    }
#line 546
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 22) {
#line 546
      goto case_24___0;
    }
#line 546
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 5) {
#line 546
      goto case_5___0;
    }
#line 546
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 6) {
#line 546
      goto case_6___0;
    }
#line 546
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 7) {
#line 546
      goto case_7___0;
    }
#line 547
    goto switch_default;
    case_29___0: /* CIL Label */ 
#line 546
    *nextTokPtr = ptr;
#line 546
    return (0);
    case_24___0: /* CIL Label */ 
    case_22___0: /* CIL Label */ 
#line 546
    ptr ++;
#line 546
    goto switch_break___0;
    case_5___0: /* CIL Label */ 
#line 546
    if (end - ptr < 2L) {
#line 546
      return (-2);
    }
    {
#line 546
    tmp___2 = (*(((struct normal_encoding  const  *)enc)->isNmstrt2))(enc, ptr);
    }
#line 546
    if (! tmp___2) {
#line 546
      *nextTokPtr = ptr;
#line 546
      return (0);
    }
#line 546
    ptr += 2;
#line 546
    goto switch_break___0;
    case_6___0: /* CIL Label */ 
#line 546
    if (end - ptr < 3L) {
#line 546
      return (-2);
    }
    {
#line 546
    tmp___3 = (*(((struct normal_encoding  const  *)enc)->isNmstrt3))(enc, ptr);
    }
#line 546
    if (! tmp___3) {
#line 546
      *nextTokPtr = ptr;
#line 546
      return (0);
    }
#line 546
    ptr += 3;
#line 546
    goto switch_break___0;
    case_7___0: /* CIL Label */ 
#line 546
    if (end - ptr < 4L) {
#line 546
      return (-2);
    }
    {
#line 546
    tmp___4 = (*(((struct normal_encoding  const  *)enc)->isNmstrt4))(enc, ptr);
    }
#line 546
    if (! tmp___4) {
#line 546
      *nextTokPtr = ptr;
#line 546
      return (0);
    }
#line 546
    ptr += 4;
#line 546
    goto switch_break___0;
    switch_default: /* CIL Label */ 
#line 548
    *nextTokPtr = ptr;
#line 549
    return (0);
    switch_break___0: /* CIL Label */ ;
    }
#line 551
    goto switch_break;
    case_10: /* CIL Label */ 
    case_9: /* CIL Label */ 
    case_21: /* CIL Label */ 
    {
#line 554
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 557
      ptr ++;
#line 558
      if ((unsigned long )ptr == (unsigned long )end) {
#line 559
        return (-1);
      }
#line 560
      t = (int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr];
#line 561
      if (t == 14) {
#line 562
        goto while_break___0;
      }
      {
#line 566
      if (t == 9) {
#line 566
        goto case_9___0;
      }
#line 566
      if (t == 10) {
#line 566
        goto case_9___0;
      }
#line 566
      if (t == 21) {
#line 566
        goto case_9___0;
      }
#line 568
      goto switch_default___0;
      case_9___0: /* CIL Label */ 
      case_10___0: /* CIL Label */ 
      case_21___0: /* CIL Label */ 
#line 567
      goto switch_break___1;
      switch_default___0: /* CIL Label */ 
#line 569
      *nextTokPtr = ptr;
#line 570
      return (0);
      switch_break___1: /* CIL Label */ ;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    case_14: /* CIL Label */ 
#line 578
    hadColon = 0;
    {
#line 580
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 581
      ptr ++;
#line 582
      if ((unsigned long )ptr == (unsigned long )end) {
#line 583
        return (-1);
      }
#line 584
      open___0 = (int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr];
#line 585
      if (open___0 == 12) {
#line 586
        goto while_break___1;
      } else
#line 585
      if (open___0 == 13) {
#line 586
        goto while_break___1;
      }
      {
#line 590
      if (open___0 == 9) {
#line 590
        goto case_9___1;
      }
#line 590
      if (open___0 == 10) {
#line 590
        goto case_9___1;
      }
#line 590
      if (open___0 == 21) {
#line 590
        goto case_9___1;
      }
#line 592
      goto switch_default___1;
      case_9___1: /* CIL Label */ 
      case_10___1: /* CIL Label */ 
      case_21___1: /* CIL Label */ 
#line 591
      goto switch_break___2;
      switch_default___1: /* CIL Label */ 
#line 593
      *nextTokPtr = ptr;
#line 594
      return (0);
      switch_break___2: /* CIL Label */ ;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
#line 597
    ptr ++;
    {
#line 599
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 601
      if ((unsigned long )ptr == (unsigned long )end) {
#line 602
        return (-1);
      }
#line 603
      t___0 = (int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr];
#line 604
      if (t___0 == open___0) {
#line 605
        goto while_break___2;
      }
      {
#line 607
      if (t___0 == 5) {
#line 607
        goto case_5___1;
      }
#line 607
      if (t___0 == 6) {
#line 607
        goto case_6___1;
      }
#line 607
      if (t___0 == 7) {
#line 607
        goto case_7___1;
      }
#line 607
      if (t___0 == 8) {
#line 607
        goto case_8;
      }
#line 607
      if (t___0 == 1) {
#line 607
        goto case_8;
      }
#line 607
      if (t___0 == 0) {
#line 607
        goto case_8;
      }
#line 608
      if (t___0 == 3) {
#line 608
        goto case_3;
      }
#line 618
      if (t___0 == 2) {
#line 618
        goto case_2;
      }
#line 621
      goto switch_default___2;
      case_5___1: /* CIL Label */ 
#line 607
      if (end - ptr < 2L) {
#line 607
        return (-2);
      }
      {
#line 607
      tmp___5 = (*(((struct normal_encoding  const  *)enc)->isInvalid2))(enc, ptr);
      }
#line 607
      if (tmp___5) {
#line 607
        *nextTokPtr = ptr;
#line 607
        return (0);
      }
#line 607
      ptr += 2;
#line 607
      goto switch_break___3;
      case_6___1: /* CIL Label */ 
#line 607
      if (end - ptr < 3L) {
#line 607
        return (-2);
      }
      {
#line 607
      tmp___6 = (*(((struct normal_encoding  const  *)enc)->isInvalid3))(enc, ptr);
      }
#line 607
      if (tmp___6) {
#line 607
        *nextTokPtr = ptr;
#line 607
        return (0);
      }
#line 607
      ptr += 3;
#line 607
      goto switch_break___3;
      case_7___1: /* CIL Label */ 
#line 607
      if (end - ptr < 4L) {
#line 607
        return (-2);
      }
      {
#line 607
      tmp___7 = (*(((struct normal_encoding  const  *)enc)->isInvalid4))(enc, ptr);
      }
#line 607
      if (tmp___7) {
#line 607
        *nextTokPtr = ptr;
#line 607
        return (0);
      }
#line 607
      ptr += 4;
#line 607
      goto switch_break___3;
      case_8: /* CIL Label */ 
      case_1: /* CIL Label */ 
      case_0: /* CIL Label */ 
#line 607
      *nextTokPtr = ptr;
#line 607
      return (0);
      case_3: /* CIL Label */ 
      {
#line 610
      tmp___8 = normal_scanRef___0(enc, ptr + 1, end, & ptr);
#line 610
      tok = tmp___8;
      }
#line 611
      if (tok <= 0) {
#line 612
        if (tok == 0) {
#line 613
          *nextTokPtr = ptr;
        }
#line 614
        return (tok);
      }
#line 616
      goto switch_break___3;
      case_2: /* CIL Label */ 
#line 619
      *nextTokPtr = ptr;
#line 620
      return (0);
      switch_default___2: /* CIL Label */ 
#line 622
      ptr ++;
#line 623
      goto switch_break___3;
      switch_break___3: /* CIL Label */ ;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
#line 626
    ptr ++;
#line 627
    if ((unsigned long )ptr == (unsigned long )end) {
#line 628
      return (-1);
    }
    {
#line 632
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 10) {
#line 632
      goto case_10___2;
    }
#line 632
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 9) {
#line 632
      goto case_10___2;
    }
#line 632
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 21) {
#line 632
      goto case_10___2;
    }
#line 634
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 17) {
#line 634
      goto case_17;
    }
#line 636
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 11) {
#line 636
      goto case_11;
    }
#line 638
    goto switch_default___3;
    case_10___2: /* CIL Label */ 
    case_9___2: /* CIL Label */ 
    case_21___2: /* CIL Label */ 
#line 633
    goto switch_break___4;
    case_17: /* CIL Label */ 
#line 635
    goto sol;
    case_11: /* CIL Label */ 
#line 637
    goto gt;
    switch_default___3: /* CIL Label */ 
#line 639
    *nextTokPtr = ptr;
#line 640
    return (0);
    switch_break___4: /* CIL Label */ ;
    }
    {
#line 643
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 644
      ptr ++;
#line 645
      if ((unsigned long )ptr == (unsigned long )end) {
#line 646
        return (-1);
      }
      {
#line 648
      if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 29) {
#line 648
        goto case_29___1;
      }
#line 648
      if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 24) {
#line 648
        goto case_24___1;
      }
#line 648
      if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 22) {
#line 648
        goto case_24___1;
      }
#line 648
      if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 5) {
#line 648
        goto case_5___2;
      }
#line 648
      if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 6) {
#line 648
        goto case_6___2;
      }
#line 648
      if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 7) {
#line 648
        goto case_7___2;
      }
#line 649
      if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 10) {
#line 649
        goto case_10___3;
      }
#line 649
      if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 9) {
#line 649
        goto case_10___3;
      }
#line 649
      if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 21) {
#line 649
        goto case_10___3;
      }
#line 651
      if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 11) {
#line 651
        goto gt;
      }
#line 655
      if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 17) {
#line 655
        goto sol;
      }
#line 666
      goto switch_default___4;
      case_29___1: /* CIL Label */ 
#line 648
      *nextTokPtr = ptr;
#line 648
      return (0);
      case_24___1: /* CIL Label */ 
      case_22___1: /* CIL Label */ 
#line 648
      ptr ++;
#line 648
      goto switch_break___5;
      case_5___2: /* CIL Label */ 
#line 648
      if (end - ptr < 2L) {
#line 648
        return (-2);
      }
      {
#line 648
      tmp___9 = (*(((struct normal_encoding  const  *)enc)->isNmstrt2))(enc, ptr);
      }
#line 648
      if (! tmp___9) {
#line 648
        *nextTokPtr = ptr;
#line 648
        return (0);
      }
#line 648
      ptr += 2;
#line 648
      goto switch_break___5;
      case_6___2: /* CIL Label */ 
#line 648
      if (end - ptr < 3L) {
#line 648
        return (-2);
      }
      {
#line 648
      tmp___10 = (*(((struct normal_encoding  const  *)enc)->isNmstrt3))(enc, ptr);
      }
#line 648
      if (! tmp___10) {
#line 648
        *nextTokPtr = ptr;
#line 648
        return (0);
      }
#line 648
      ptr += 3;
#line 648
      goto switch_break___5;
      case_7___2: /* CIL Label */ 
#line 648
      if (end - ptr < 4L) {
#line 648
        return (-2);
      }
      {
#line 648
      tmp___11 = (*(((struct normal_encoding  const  *)enc)->isNmstrt4))(enc, ptr);
      }
#line 648
      if (! tmp___11) {
#line 648
        *nextTokPtr = ptr;
#line 648
        return (0);
      }
#line 648
      ptr += 4;
#line 648
      goto switch_break___5;
      case_10___3: /* CIL Label */ 
      case_9___3: /* CIL Label */ 
      case_21___3: /* CIL Label */ 
#line 650
      goto __Cont;
      gt: 
      case_11___0: /* CIL Label */ 
#line 653
      *nextTokPtr = ptr + 1;
#line 654
      return (1);
      sol: 
      case_17___0: /* CIL Label */ 
#line 657
      ptr ++;
#line 658
      if ((unsigned long )ptr == (unsigned long )end) {
#line 659
        return (-1);
      }
#line 660
      if (! ((int const   )*ptr == 62)) {
#line 661
        *nextTokPtr = ptr;
#line 662
        return (0);
      }
#line 664
      *nextTokPtr = ptr + 1;
#line 665
      return (3);
      switch_default___4: /* CIL Label */ 
#line 667
      *nextTokPtr = ptr;
#line 668
      return (0);
      switch_break___5: /* CIL Label */ ;
      }
#line 670
      goto while_break___3;
      __Cont: /* CIL Label */ ;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 672
    goto switch_break;
    switch_default___5: /* CIL Label */ 
#line 675
    *nextTokPtr = ptr;
#line 676
    return (0);
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 679
  return (-1);
}
}
#line 684 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmltok_impl.c"
static int normal_scanLt___0(ENCODING const   *enc , char const   *ptr , char const   *end ,
                             char const   **nextTokPtr ) 
{ 
  int hadColon ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;

  {
#line 691
  if ((unsigned long )ptr == (unsigned long )end) {
#line 692
    return (-1);
  }
  {
#line 694
  if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 29) {
#line 694
    goto case_29;
  }
#line 694
  if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 24) {
#line 694
    goto case_24;
  }
#line 694
  if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 22) {
#line 694
    goto case_24;
  }
#line 694
  if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 5) {
#line 694
    goto case_5;
  }
#line 694
  if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 6) {
#line 694
    goto case_6;
  }
#line 694
  if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 7) {
#line 694
    goto case_7;
  }
#line 695
  if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 16) {
#line 695
    goto case_16;
  }
#line 707
  if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 15) {
#line 707
    goto case_15;
  }
#line 709
  if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 17) {
#line 709
    goto case_17;
  }
#line 711
  goto switch_default;
  case_29: /* CIL Label */ 
#line 694
  *nextTokPtr = ptr;
#line 694
  return (0);
  case_24: /* CIL Label */ 
  case_22: /* CIL Label */ 
#line 694
  ptr ++;
#line 694
  goto switch_break;
  case_5: /* CIL Label */ 
#line 694
  if (end - ptr < 2L) {
#line 694
    return (-2);
  }
  {
#line 694
  tmp = (*(((struct normal_encoding  const  *)enc)->isNmstrt2))(enc, ptr);
  }
#line 694
  if (! tmp) {
#line 694
    *nextTokPtr = ptr;
#line 694
    return (0);
  }
#line 694
  ptr += 2;
#line 694
  goto switch_break;
  case_6: /* CIL Label */ 
#line 694
  if (end - ptr < 3L) {
#line 694
    return (-2);
  }
  {
#line 694
  tmp___0 = (*(((struct normal_encoding  const  *)enc)->isNmstrt3))(enc, ptr);
  }
#line 694
  if (! tmp___0) {
#line 694
    *nextTokPtr = ptr;
#line 694
    return (0);
  }
#line 694
  ptr += 3;
#line 694
  goto switch_break;
  case_7: /* CIL Label */ 
#line 694
  if (end - ptr < 4L) {
#line 694
    return (-2);
  }
  {
#line 694
  tmp___1 = (*(((struct normal_encoding  const  *)enc)->isNmstrt4))(enc, ptr);
  }
#line 694
  if (! tmp___1) {
#line 694
    *nextTokPtr = ptr;
#line 694
    return (0);
  }
#line 694
  ptr += 4;
#line 694
  goto switch_break;
  case_16: /* CIL Label */ 
#line 696
  ptr ++;
#line 696
  if ((unsigned long )ptr == (unsigned long )end) {
#line 697
    return (-1);
  }
  {
#line 699
  if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 27) {
#line 699
    goto case_27;
  }
#line 701
  if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 20) {
#line 701
    goto case_20;
  }
#line 698
  goto switch_break___0;
  case_27: /* CIL Label */ 
  {
#line 700
  tmp___2 = normal_scanComment___0(enc, ptr + 1, end, nextTokPtr);
  }
#line 700
  return (tmp___2);
  case_20: /* CIL Label */ 
  {
#line 702
  tmp___3 = normal_scanCdataSection___0(enc, ptr + 1, end, nextTokPtr);
  }
#line 702
  return (tmp___3);
  switch_break___0: /* CIL Label */ ;
  }
#line 705
  *nextTokPtr = ptr;
#line 706
  return (0);
  case_15: /* CIL Label */ 
  {
#line 708
  tmp___4 = normal_scanPi___0(enc, ptr + 1, end, nextTokPtr);
  }
#line 708
  return (tmp___4);
  case_17: /* CIL Label */ 
  {
#line 710
  tmp___5 = normal_scanEndTag___0(enc, ptr + 1, end, nextTokPtr);
  }
#line 710
  return (tmp___5);
  switch_default: /* CIL Label */ 
#line 712
  *nextTokPtr = ptr;
#line 713
  return (0);
  switch_break: /* CIL Label */ ;
  }
#line 716
  hadColon = 0;
  {
#line 719
  while (1) {
    while_continue: /* CIL Label */ ;
#line 719
    if (! ((unsigned long )ptr != (unsigned long )end)) {
#line 719
      goto while_break;
    }
    {
#line 721
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 29) {
#line 721
      goto case_29___0;
    }
#line 721
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 27) {
#line 721
      goto case_27___0;
    }
#line 721
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 26) {
#line 721
      goto case_27___0;
    }
#line 721
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 25) {
#line 721
      goto case_27___0;
    }
#line 721
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 24) {
#line 721
      goto case_27___0;
    }
#line 721
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 22) {
#line 721
      goto case_27___0;
    }
#line 721
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 5) {
#line 721
      goto case_5___0;
    }
#line 721
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 6) {
#line 721
      goto case_6___0;
    }
#line 721
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 7) {
#line 721
      goto case_7___0;
    }
#line 723
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 23) {
#line 723
      goto case_23;
    }
#line 740
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 10) {
#line 740
      goto case_10;
    }
#line 740
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 9) {
#line 740
      goto case_10;
    }
#line 740
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 21) {
#line 740
      goto case_10;
    }
#line 761
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 11) {
#line 761
      goto gt;
    }
#line 765
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 17) {
#line 765
      goto sol;
    }
#line 776
    goto switch_default___2;
    case_29___0: /* CIL Label */ 
#line 721
    *nextTokPtr = ptr;
#line 721
    return (0);
    case_27___0: /* CIL Label */ 
    case_26: /* CIL Label */ 
    case_25: /* CIL Label */ 
    case_24___0: /* CIL Label */ 
    case_22___0: /* CIL Label */ 
#line 721
    ptr ++;
#line 721
    goto switch_break___1;
    case_5___0: /* CIL Label */ 
#line 721
    if (end - ptr < 2L) {
#line 721
      return (-2);
    }
    {
#line 721
    tmp___6 = (*(((struct normal_encoding  const  *)enc)->isName2))(enc, ptr);
    }
#line 721
    if (! tmp___6) {
#line 721
      *nextTokPtr = ptr;
#line 721
      return (0);
    }
#line 721
    ptr += 2;
#line 721
    goto switch_break___1;
    case_6___0: /* CIL Label */ 
#line 721
    if (end - ptr < 3L) {
#line 721
      return (-2);
    }
    {
#line 721
    tmp___7 = (*(((struct normal_encoding  const  *)enc)->isName3))(enc, ptr);
    }
#line 721
    if (! tmp___7) {
#line 721
      *nextTokPtr = ptr;
#line 721
      return (0);
    }
#line 721
    ptr += 3;
#line 721
    goto switch_break___1;
    case_7___0: /* CIL Label */ 
#line 721
    if (end - ptr < 4L) {
#line 721
      return (-2);
    }
    {
#line 721
    tmp___8 = (*(((struct normal_encoding  const  *)enc)->isName4))(enc, ptr);
    }
#line 721
    if (! tmp___8) {
#line 721
      *nextTokPtr = ptr;
#line 721
      return (0);
    }
#line 721
    ptr += 4;
#line 721
    goto switch_break___1;
    case_23: /* CIL Label */ 
#line 724
    if (hadColon) {
#line 725
      *nextTokPtr = ptr;
#line 726
      return (0);
    }
#line 728
    hadColon = 1;
#line 729
    ptr ++;
#line 730
    if ((unsigned long )ptr == (unsigned long )end) {
#line 731
      return (-1);
    }
    {
#line 733
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 29) {
#line 733
      goto case_29___1;
    }
#line 733
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 24) {
#line 733
      goto case_24___1;
    }
#line 733
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 22) {
#line 733
      goto case_24___1;
    }
#line 733
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 5) {
#line 733
      goto case_5___1;
    }
#line 733
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 6) {
#line 733
      goto case_6___1;
    }
#line 733
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 7) {
#line 733
      goto case_7___1;
    }
#line 734
    goto switch_default___0;
    case_29___1: /* CIL Label */ 
#line 733
    *nextTokPtr = ptr;
#line 733
    return (0);
    case_24___1: /* CIL Label */ 
    case_22___1: /* CIL Label */ 
#line 733
    ptr ++;
#line 733
    goto switch_break___2;
    case_5___1: /* CIL Label */ 
#line 733
    if (end - ptr < 2L) {
#line 733
      return (-2);
    }
    {
#line 733
    tmp___9 = (*(((struct normal_encoding  const  *)enc)->isNmstrt2))(enc, ptr);
    }
#line 733
    if (! tmp___9) {
#line 733
      *nextTokPtr = ptr;
#line 733
      return (0);
    }
#line 733
    ptr += 2;
#line 733
    goto switch_break___2;
    case_6___1: /* CIL Label */ 
#line 733
    if (end - ptr < 3L) {
#line 733
      return (-2);
    }
    {
#line 733
    tmp___10 = (*(((struct normal_encoding  const  *)enc)->isNmstrt3))(enc, ptr);
    }
#line 733
    if (! tmp___10) {
#line 733
      *nextTokPtr = ptr;
#line 733
      return (0);
    }
#line 733
    ptr += 3;
#line 733
    goto switch_break___2;
    case_7___1: /* CIL Label */ 
#line 733
    if (end - ptr < 4L) {
#line 733
      return (-2);
    }
    {
#line 733
    tmp___11 = (*(((struct normal_encoding  const  *)enc)->isNmstrt4))(enc, ptr);
    }
#line 733
    if (! tmp___11) {
#line 733
      *nextTokPtr = ptr;
#line 733
      return (0);
    }
#line 733
    ptr += 4;
#line 733
    goto switch_break___2;
    switch_default___0: /* CIL Label */ 
#line 735
    *nextTokPtr = ptr;
#line 736
    return (0);
    switch_break___2: /* CIL Label */ ;
    }
#line 738
    goto switch_break___1;
    case_10: /* CIL Label */ 
    case_9: /* CIL Label */ 
    case_21: /* CIL Label */ 
#line 742
    ptr ++;
    {
#line 743
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 743
      if (! ((unsigned long )ptr != (unsigned long )end)) {
#line 743
        goto while_break___0;
      }
      {
#line 745
      if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 29) {
#line 745
        goto case_29___2;
      }
#line 745
      if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 24) {
#line 745
        goto case_24___2;
      }
#line 745
      if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 22) {
#line 745
        goto case_24___2;
      }
#line 745
      if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 5) {
#line 745
        goto case_5___2;
      }
#line 745
      if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 6) {
#line 745
        goto case_6___2;
      }
#line 745
      if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 7) {
#line 745
        goto case_7___2;
      }
#line 746
      if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 11) {
#line 746
        goto case_11;
      }
#line 748
      if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 17) {
#line 748
        goto case_17___0;
      }
#line 750
      if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 10) {
#line 750
        goto case_10___0;
      }
#line 750
      if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 9) {
#line 750
        goto case_10___0;
      }
#line 750
      if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 21) {
#line 750
        goto case_10___0;
      }
#line 753
      goto switch_default___1;
      case_29___2: /* CIL Label */ 
#line 745
      *nextTokPtr = ptr;
#line 745
      return (0);
      case_24___2: /* CIL Label */ 
      case_22___2: /* CIL Label */ 
#line 745
      ptr ++;
#line 745
      goto switch_break___3;
      case_5___2: /* CIL Label */ 
#line 745
      if (end - ptr < 2L) {
#line 745
        return (-2);
      }
      {
#line 745
      tmp___12 = (*(((struct normal_encoding  const  *)enc)->isNmstrt2))(enc, ptr);
      }
#line 745
      if (! tmp___12) {
#line 745
        *nextTokPtr = ptr;
#line 745
        return (0);
      }
#line 745
      ptr += 2;
#line 745
      goto switch_break___3;
      case_6___2: /* CIL Label */ 
#line 745
      if (end - ptr < 3L) {
#line 745
        return (-2);
      }
      {
#line 745
      tmp___13 = (*(((struct normal_encoding  const  *)enc)->isNmstrt3))(enc, ptr);
      }
#line 745
      if (! tmp___13) {
#line 745
        *nextTokPtr = ptr;
#line 745
        return (0);
      }
#line 745
      ptr += 3;
#line 745
      goto switch_break___3;
      case_7___2: /* CIL Label */ 
#line 745
      if (end - ptr < 4L) {
#line 745
        return (-2);
      }
      {
#line 745
      tmp___14 = (*(((struct normal_encoding  const  *)enc)->isNmstrt4))(enc, ptr);
      }
#line 745
      if (! tmp___14) {
#line 745
        *nextTokPtr = ptr;
#line 745
        return (0);
      }
#line 745
      ptr += 4;
#line 745
      goto switch_break___3;
      case_11: /* CIL Label */ 
#line 747
      goto gt;
      case_17___0: /* CIL Label */ 
#line 749
      goto sol;
      case_10___0: /* CIL Label */ 
      case_9___0: /* CIL Label */ 
      case_21___0: /* CIL Label */ 
#line 751
      ptr ++;
#line 752
      goto while_continue___0;
      switch_default___1: /* CIL Label */ 
#line 754
      *nextTokPtr = ptr;
#line 755
      return (0);
      switch_break___3: /* CIL Label */ ;
      }
      {
#line 757
      tmp___15 = normal_scanAtts___0(enc, ptr, end, nextTokPtr);
      }
#line 757
      return (tmp___15);
    }
    while_break___0: /* CIL Label */ ;
    }
#line 759
    return (-1);
    gt: 
    case_11___0: /* CIL Label */ 
#line 763
    *nextTokPtr = ptr + 1;
#line 764
    return (2);
    sol: 
    case_17___1: /* CIL Label */ 
#line 767
    ptr ++;
#line 768
    if ((unsigned long )ptr == (unsigned long )end) {
#line 769
      return (-1);
    }
#line 770
    if (! ((int const   )*ptr == 62)) {
#line 771
      *nextTokPtr = ptr;
#line 772
      return (0);
    }
#line 774
    *nextTokPtr = ptr + 1;
#line 775
    return (4);
    switch_default___2: /* CIL Label */ 
#line 777
    *nextTokPtr = ptr;
#line 778
    return (0);
    switch_break___1: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 781
  return (-1);
}
}
#line 784 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmltok_impl.c"
static int normal_contentTok___0(ENCODING const   *enc , char const   *ptr , char const   *end ,
                                 char const   **nextTokPtr ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
#line 788
  if ((unsigned long )ptr == (unsigned long )end) {
#line 789
    return (-4);
  }
  {
#line 800
  if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 2) {
#line 800
    goto case_2;
  }
#line 802
  if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 3) {
#line 802
    goto case_3;
  }
#line 804
  if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 9) {
#line 804
    goto case_9;
  }
#line 812
  if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 10) {
#line 812
    goto case_10;
  }
#line 815
  if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 4) {
#line 815
    goto case_4;
  }
#line 830
  if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 5) {
#line 830
    goto case_5;
  }
#line 830
  if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 6) {
#line 830
    goto case_6;
  }
#line 830
  if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 7) {
#line 830
    goto case_7;
  }
#line 830
  if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 8) {
#line 830
    goto case_8;
  }
#line 830
  if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 1) {
#line 830
    goto case_8;
  }
#line 830
  if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 0) {
#line 830
    goto case_8;
  }
#line 831
  goto switch_default;
  case_2: /* CIL Label */ 
  {
#line 801
  tmp = normal_scanLt___0(enc, ptr + 1, end, nextTokPtr);
  }
#line 801
  return (tmp);
  case_3: /* CIL Label */ 
  {
#line 803
  tmp___0 = normal_scanRef___0(enc, ptr + 1, end, nextTokPtr);
  }
#line 803
  return (tmp___0);
  case_9: /* CIL Label */ 
#line 805
  ptr ++;
#line 806
  if ((unsigned long )ptr == (unsigned long )end) {
#line 807
    return (-3);
  }
#line 808
  if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 10) {
#line 809
    ptr ++;
  }
#line 810
  *nextTokPtr = ptr;
#line 811
  return (7);
  case_10: /* CIL Label */ 
#line 813
  *nextTokPtr = ptr + 1;
#line 814
  return (7);
  case_4: /* CIL Label */ 
#line 816
  ptr ++;
#line 817
  if ((unsigned long )ptr == (unsigned long )end) {
#line 818
    return (-5);
  }
#line 819
  if (! ((int const   )*ptr == 93)) {
#line 820
    goto switch_break;
  }
#line 821
  ptr ++;
#line 822
  if ((unsigned long )ptr == (unsigned long )end) {
#line 823
    return (-5);
  }
#line 824
  if (! ((int const   )*ptr == 62)) {
#line 825
    ptr --;
#line 826
    goto switch_break;
  }
#line 828
  *nextTokPtr = ptr;
#line 829
  return (0);
  case_5: /* CIL Label */ 
#line 830
  if (end - ptr < 2L) {
#line 830
    return (-2);
  }
  {
#line 830
  tmp___1 = (*(((struct normal_encoding  const  *)enc)->isInvalid2))(enc, ptr);
  }
#line 830
  if (tmp___1) {
#line 830
    *nextTokPtr = ptr;
#line 830
    return (0);
  }
#line 830
  ptr += 2;
#line 830
  goto switch_break;
  case_6: /* CIL Label */ 
#line 830
  if (end - ptr < 3L) {
#line 830
    return (-2);
  }
  {
#line 830
  tmp___2 = (*(((struct normal_encoding  const  *)enc)->isInvalid3))(enc, ptr);
  }
#line 830
  if (tmp___2) {
#line 830
    *nextTokPtr = ptr;
#line 830
    return (0);
  }
#line 830
  ptr += 3;
#line 830
  goto switch_break;
  case_7: /* CIL Label */ 
#line 830
  if (end - ptr < 4L) {
#line 830
    return (-2);
  }
  {
#line 830
  tmp___3 = (*(((struct normal_encoding  const  *)enc)->isInvalid4))(enc, ptr);
  }
#line 830
  if (tmp___3) {
#line 830
    *nextTokPtr = ptr;
#line 830
    return (0);
  }
#line 830
  ptr += 4;
#line 830
  goto switch_break;
  case_8: /* CIL Label */ 
  case_1: /* CIL Label */ 
  case_0: /* CIL Label */ 
#line 830
  *nextTokPtr = ptr;
#line 830
  return (0);
  switch_default: /* CIL Label */ 
#line 832
  ptr ++;
#line 833
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 835
  while (1) {
    while_continue: /* CIL Label */ ;
#line 835
    if (! ((unsigned long )ptr != (unsigned long )end)) {
#line 835
      goto while_break;
    }
    {
#line 845
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 5) {
#line 845
      goto case_5___0;
    }
#line 845
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 6) {
#line 845
      goto case_6___0;
    }
#line 845
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 7) {
#line 845
      goto case_7___0;
    }
#line 847
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 4) {
#line 847
      goto case_4___0;
    }
#line 869
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 10) {
#line 869
      goto case_10___0;
    }
#line 869
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 9) {
#line 869
      goto case_10___0;
    }
#line 869
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 8) {
#line 869
      goto case_10___0;
    }
#line 869
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 1) {
#line 869
      goto case_10___0;
    }
#line 869
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 0) {
#line 869
      goto case_10___0;
    }
#line 869
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 2) {
#line 869
      goto case_10___0;
    }
#line 869
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 3) {
#line 869
      goto case_10___0;
    }
#line 872
    goto switch_default___0;
    case_5___0: /* CIL Label */ 
#line 845
    if (end - ptr < 2L) {
#line 845
      *nextTokPtr = ptr;
#line 845
      return (6);
    } else {
      {
#line 845
      tmp___4 = (*(((struct normal_encoding  const  *)enc)->isInvalid2))(enc, ptr);
      }
#line 845
      if (tmp___4) {
#line 845
        *nextTokPtr = ptr;
#line 845
        return (6);
      }
    }
#line 845
    ptr += 2;
#line 845
    goto switch_break___0;
    case_6___0: /* CIL Label */ 
#line 845
    if (end - ptr < 3L) {
#line 845
      *nextTokPtr = ptr;
#line 845
      return (6);
    } else {
      {
#line 845
      tmp___5 = (*(((struct normal_encoding  const  *)enc)->isInvalid3))(enc, ptr);
      }
#line 845
      if (tmp___5) {
#line 845
        *nextTokPtr = ptr;
#line 845
        return (6);
      }
    }
#line 845
    ptr += 3;
#line 845
    goto switch_break___0;
    case_7___0: /* CIL Label */ 
#line 845
    if (end - ptr < 4L) {
#line 845
      *nextTokPtr = ptr;
#line 845
      return (6);
    } else {
      {
#line 845
      tmp___6 = (*(((struct normal_encoding  const  *)enc)->isInvalid4))(enc, ptr);
      }
#line 845
      if (tmp___6) {
#line 845
        *nextTokPtr = ptr;
#line 845
        return (6);
      }
    }
#line 845
    ptr += 4;
#line 845
    goto switch_break___0;
    case_4___0: /* CIL Label */ 
#line 848
    if ((unsigned long )(ptr + 1) != (unsigned long )end) {
#line 849
      if (! ((int const   )*(ptr + 1) == 93)) {
#line 850
        ptr ++;
#line 851
        goto switch_break___0;
      }
#line 853
      if ((unsigned long )(ptr + 2) != (unsigned long )end) {
#line 854
        if (! ((int const   )*(ptr + 2) == 62)) {
#line 855
          ptr ++;
#line 856
          goto switch_break___0;
        }
#line 858
        *nextTokPtr = ptr + 2;
#line 859
        return (0);
      }
    }
    case_10___0: /* CIL Label */ 
    case_9___0: /* CIL Label */ 
    case_8___0: /* CIL Label */ 
    case_1___0: /* CIL Label */ 
    case_0___0: /* CIL Label */ 
    case_2___0: /* CIL Label */ 
    case_3___0: /* CIL Label */ 
#line 870
    *nextTokPtr = ptr;
#line 871
    return (6);
    switch_default___0: /* CIL Label */ 
#line 873
    ptr ++;
#line 874
    goto switch_break___0;
    switch_break___0: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 877
  *nextTokPtr = ptr;
#line 878
  return (6);
}
}
#line 883 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmltok_impl.c"
static int normal_scanPercent___0(ENCODING const   *enc , char const   *ptr , char const   *end ,
                                  char const   **nextTokPtr ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 887
  if ((unsigned long )ptr == (unsigned long )end) {
#line 888
    return (-1);
  }
  {
#line 890
  if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 29) {
#line 890
    goto case_29;
  }
#line 890
  if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 24) {
#line 890
    goto case_24;
  }
#line 890
  if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 22) {
#line 890
    goto case_24;
  }
#line 890
  if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 5) {
#line 890
    goto case_5;
  }
#line 890
  if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 6) {
#line 890
    goto case_6;
  }
#line 890
  if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 7) {
#line 890
    goto case_7;
  }
#line 891
  if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 30) {
#line 891
    goto case_30;
  }
#line 891
  if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 9) {
#line 891
    goto case_30;
  }
#line 891
  if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 10) {
#line 891
    goto case_30;
  }
#line 891
  if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 21) {
#line 891
    goto case_30;
  }
#line 894
  goto switch_default;
  case_29: /* CIL Label */ 
#line 890
  *nextTokPtr = ptr;
#line 890
  return (0);
  case_24: /* CIL Label */ 
  case_22: /* CIL Label */ 
#line 890
  ptr ++;
#line 890
  goto switch_break;
  case_5: /* CIL Label */ 
#line 890
  if (end - ptr < 2L) {
#line 890
    return (-2);
  }
  {
#line 890
  tmp = (*(((struct normal_encoding  const  *)enc)->isNmstrt2))(enc, ptr);
  }
#line 890
  if (! tmp) {
#line 890
    *nextTokPtr = ptr;
#line 890
    return (0);
  }
#line 890
  ptr += 2;
#line 890
  goto switch_break;
  case_6: /* CIL Label */ 
#line 890
  if (end - ptr < 3L) {
#line 890
    return (-2);
  }
  {
#line 890
  tmp___0 = (*(((struct normal_encoding  const  *)enc)->isNmstrt3))(enc, ptr);
  }
#line 890
  if (! tmp___0) {
#line 890
    *nextTokPtr = ptr;
#line 890
    return (0);
  }
#line 890
  ptr += 3;
#line 890
  goto switch_break;
  case_7: /* CIL Label */ 
#line 890
  if (end - ptr < 4L) {
#line 890
    return (-2);
  }
  {
#line 890
  tmp___1 = (*(((struct normal_encoding  const  *)enc)->isNmstrt4))(enc, ptr);
  }
#line 890
  if (! tmp___1) {
#line 890
    *nextTokPtr = ptr;
#line 890
    return (0);
  }
#line 890
  ptr += 4;
#line 890
  goto switch_break;
  case_30: /* CIL Label */ 
  case_9: /* CIL Label */ 
  case_10: /* CIL Label */ 
  case_21: /* CIL Label */ 
#line 892
  *nextTokPtr = ptr;
#line 893
  return (22);
  switch_default: /* CIL Label */ 
#line 895
  *nextTokPtr = ptr;
#line 896
  return (0);
  switch_break: /* CIL Label */ ;
  }
  {
#line 898
  while (1) {
    while_continue: /* CIL Label */ ;
#line 898
    if (! ((unsigned long )ptr != (unsigned long )end)) {
#line 898
      goto while_break;
    }
    {
#line 900
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 29) {
#line 900
      goto case_29___0;
    }
#line 900
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 27) {
#line 900
      goto case_27;
    }
#line 900
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 26) {
#line 900
      goto case_27;
    }
#line 900
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 25) {
#line 900
      goto case_27;
    }
#line 900
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 24) {
#line 900
      goto case_27;
    }
#line 900
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 22) {
#line 900
      goto case_27;
    }
#line 900
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 5) {
#line 900
      goto case_5___0;
    }
#line 900
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 6) {
#line 900
      goto case_6___0;
    }
#line 900
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 7) {
#line 900
      goto case_7___0;
    }
#line 901
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 18) {
#line 901
      goto case_18;
    }
#line 904
    goto switch_default___0;
    case_29___0: /* CIL Label */ 
#line 900
    *nextTokPtr = ptr;
#line 900
    return (0);
    case_27: /* CIL Label */ 
    case_26: /* CIL Label */ 
    case_25: /* CIL Label */ 
    case_24___0: /* CIL Label */ 
    case_22___0: /* CIL Label */ 
#line 900
    ptr ++;
#line 900
    goto switch_break___0;
    case_5___0: /* CIL Label */ 
#line 900
    if (end - ptr < 2L) {
#line 900
      return (-2);
    }
    {
#line 900
    tmp___2 = (*(((struct normal_encoding  const  *)enc)->isName2))(enc, ptr);
    }
#line 900
    if (! tmp___2) {
#line 900
      *nextTokPtr = ptr;
#line 900
      return (0);
    }
#line 900
    ptr += 2;
#line 900
    goto switch_break___0;
    case_6___0: /* CIL Label */ 
#line 900
    if (end - ptr < 3L) {
#line 900
      return (-2);
    }
    {
#line 900
    tmp___3 = (*(((struct normal_encoding  const  *)enc)->isName3))(enc, ptr);
    }
#line 900
    if (! tmp___3) {
#line 900
      *nextTokPtr = ptr;
#line 900
      return (0);
    }
#line 900
    ptr += 3;
#line 900
    goto switch_break___0;
    case_7___0: /* CIL Label */ 
#line 900
    if (end - ptr < 4L) {
#line 900
      return (-2);
    }
    {
#line 900
    tmp___4 = (*(((struct normal_encoding  const  *)enc)->isName4))(enc, ptr);
    }
#line 900
    if (! tmp___4) {
#line 900
      *nextTokPtr = ptr;
#line 900
      return (0);
    }
#line 900
    ptr += 4;
#line 900
    goto switch_break___0;
    case_18: /* CIL Label */ 
#line 902
    *nextTokPtr = ptr + 1;
#line 903
    return (28);
    switch_default___0: /* CIL Label */ 
#line 905
    *nextTokPtr = ptr;
#line 906
    return (0);
    switch_break___0: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 909
  return (-1);
}
}
#line 912 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmltok_impl.c"
static int normal_scanPoundName___0(ENCODING const   *enc , char const   *ptr , char const   *end ,
                                    char const   **nextTokPtr ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 916
  if ((unsigned long )ptr == (unsigned long )end) {
#line 917
    return (-1);
  }
  {
#line 919
  if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 29) {
#line 919
    goto case_29;
  }
#line 919
  if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 24) {
#line 919
    goto case_24;
  }
#line 919
  if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 22) {
#line 919
    goto case_24;
  }
#line 919
  if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 5) {
#line 919
    goto case_5;
  }
#line 919
  if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 6) {
#line 919
    goto case_6;
  }
#line 919
  if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 7) {
#line 919
    goto case_7;
  }
#line 920
  goto switch_default;
  case_29: /* CIL Label */ 
#line 919
  *nextTokPtr = ptr;
#line 919
  return (0);
  case_24: /* CIL Label */ 
  case_22: /* CIL Label */ 
#line 919
  ptr ++;
#line 919
  goto switch_break;
  case_5: /* CIL Label */ 
#line 919
  if (end - ptr < 2L) {
#line 919
    return (-2);
  }
  {
#line 919
  tmp = (*(((struct normal_encoding  const  *)enc)->isNmstrt2))(enc, ptr);
  }
#line 919
  if (! tmp) {
#line 919
    *nextTokPtr = ptr;
#line 919
    return (0);
  }
#line 919
  ptr += 2;
#line 919
  goto switch_break;
  case_6: /* CIL Label */ 
#line 919
  if (end - ptr < 3L) {
#line 919
    return (-2);
  }
  {
#line 919
  tmp___0 = (*(((struct normal_encoding  const  *)enc)->isNmstrt3))(enc, ptr);
  }
#line 919
  if (! tmp___0) {
#line 919
    *nextTokPtr = ptr;
#line 919
    return (0);
  }
#line 919
  ptr += 3;
#line 919
  goto switch_break;
  case_7: /* CIL Label */ 
#line 919
  if (end - ptr < 4L) {
#line 919
    return (-2);
  }
  {
#line 919
  tmp___1 = (*(((struct normal_encoding  const  *)enc)->isNmstrt4))(enc, ptr);
  }
#line 919
  if (! tmp___1) {
#line 919
    *nextTokPtr = ptr;
#line 919
    return (0);
  }
#line 919
  ptr += 4;
#line 919
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 921
  *nextTokPtr = ptr;
#line 922
  return (0);
  switch_break: /* CIL Label */ ;
  }
  {
#line 924
  while (1) {
    while_continue: /* CIL Label */ ;
#line 924
    if (! ((unsigned long )ptr != (unsigned long )end)) {
#line 924
      goto while_break;
    }
    {
#line 926
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 29) {
#line 926
      goto case_29___0;
    }
#line 926
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 27) {
#line 926
      goto case_27;
    }
#line 926
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 26) {
#line 926
      goto case_27;
    }
#line 926
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 25) {
#line 926
      goto case_27;
    }
#line 926
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 24) {
#line 926
      goto case_27;
    }
#line 926
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 22) {
#line 926
      goto case_27;
    }
#line 926
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 5) {
#line 926
      goto case_5___0;
    }
#line 926
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 6) {
#line 926
      goto case_6___0;
    }
#line 926
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 7) {
#line 926
      goto case_7___0;
    }
#line 928
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 36) {
#line 928
      goto case_36;
    }
#line 928
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 30) {
#line 928
      goto case_36;
    }
#line 928
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 11) {
#line 928
      goto case_36;
    }
#line 928
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 32) {
#line 928
      goto case_36;
    }
#line 928
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 21) {
#line 928
      goto case_36;
    }
#line 928
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 10) {
#line 928
      goto case_36;
    }
#line 928
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 9) {
#line 928
      goto case_36;
    }
#line 931
    goto switch_default___0;
    case_29___0: /* CIL Label */ 
#line 926
    *nextTokPtr = ptr;
#line 926
    return (0);
    case_27: /* CIL Label */ 
    case_26: /* CIL Label */ 
    case_25: /* CIL Label */ 
    case_24___0: /* CIL Label */ 
    case_22___0: /* CIL Label */ 
#line 926
    ptr ++;
#line 926
    goto switch_break___0;
    case_5___0: /* CIL Label */ 
#line 926
    if (end - ptr < 2L) {
#line 926
      return (-2);
    }
    {
#line 926
    tmp___2 = (*(((struct normal_encoding  const  *)enc)->isName2))(enc, ptr);
    }
#line 926
    if (! tmp___2) {
#line 926
      *nextTokPtr = ptr;
#line 926
      return (0);
    }
#line 926
    ptr += 2;
#line 926
    goto switch_break___0;
    case_6___0: /* CIL Label */ 
#line 926
    if (end - ptr < 3L) {
#line 926
      return (-2);
    }
    {
#line 926
    tmp___3 = (*(((struct normal_encoding  const  *)enc)->isName3))(enc, ptr);
    }
#line 926
    if (! tmp___3) {
#line 926
      *nextTokPtr = ptr;
#line 926
      return (0);
    }
#line 926
    ptr += 3;
#line 926
    goto switch_break___0;
    case_7___0: /* CIL Label */ 
#line 926
    if (end - ptr < 4L) {
#line 926
      return (-2);
    }
    {
#line 926
    tmp___4 = (*(((struct normal_encoding  const  *)enc)->isName4))(enc, ptr);
    }
#line 926
    if (! tmp___4) {
#line 926
      *nextTokPtr = ptr;
#line 926
      return (0);
    }
#line 926
    ptr += 4;
#line 926
    goto switch_break___0;
    case_36: /* CIL Label */ 
    case_30: /* CIL Label */ 
    case_11: /* CIL Label */ 
    case_32: /* CIL Label */ 
    case_21: /* CIL Label */ 
    case_10: /* CIL Label */ 
    case_9: /* CIL Label */ 
#line 929
    *nextTokPtr = ptr;
#line 930
    return (20);
    switch_default___0: /* CIL Label */ 
#line 932
    *nextTokPtr = ptr;
#line 933
    return (0);
    switch_break___0: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 936
  return (-20);
}
}
#line 939 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmltok_impl.c"
static int normal_scanLit___0(int open___0 , ENCODING const   *enc , char const   *ptr ,
                              char const   *end , char const   **nextTokPtr ) 
{ 
  int t ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 944
  while (1) {
    while_continue: /* CIL Label */ ;
#line 944
    if (! ((unsigned long )ptr != (unsigned long )end)) {
#line 944
      goto while_break;
    }
#line 945
    t = (int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr];
    {
#line 947
    if (t == 5) {
#line 947
      goto case_5;
    }
#line 947
    if (t == 6) {
#line 947
      goto case_6;
    }
#line 947
    if (t == 7) {
#line 947
      goto case_7;
    }
#line 947
    if (t == 8) {
#line 947
      goto case_8;
    }
#line 947
    if (t == 1) {
#line 947
      goto case_8;
    }
#line 947
    if (t == 0) {
#line 947
      goto case_8;
    }
#line 949
    if (t == 13) {
#line 949
      goto case_13;
    }
#line 949
    if (t == 12) {
#line 949
      goto case_13;
    }
#line 963
    goto switch_default___0;
    case_5: /* CIL Label */ 
#line 947
    if (end - ptr < 2L) {
#line 947
      return (-2);
    }
    {
#line 947
    tmp = (*(((struct normal_encoding  const  *)enc)->isInvalid2))(enc, ptr);
    }
#line 947
    if (tmp) {
#line 947
      *nextTokPtr = ptr;
#line 947
      return (0);
    }
#line 947
    ptr += 2;
#line 947
    goto switch_break;
    case_6: /* CIL Label */ 
#line 947
    if (end - ptr < 3L) {
#line 947
      return (-2);
    }
    {
#line 947
    tmp___0 = (*(((struct normal_encoding  const  *)enc)->isInvalid3))(enc, ptr);
    }
#line 947
    if (tmp___0) {
#line 947
      *nextTokPtr = ptr;
#line 947
      return (0);
    }
#line 947
    ptr += 3;
#line 947
    goto switch_break;
    case_7: /* CIL Label */ 
#line 947
    if (end - ptr < 4L) {
#line 947
      return (-2);
    }
    {
#line 947
    tmp___1 = (*(((struct normal_encoding  const  *)enc)->isInvalid4))(enc, ptr);
    }
#line 947
    if (tmp___1) {
#line 947
      *nextTokPtr = ptr;
#line 947
      return (0);
    }
#line 947
    ptr += 4;
#line 947
    goto switch_break;
    case_8: /* CIL Label */ 
    case_1: /* CIL Label */ 
    case_0: /* CIL Label */ 
#line 947
    *nextTokPtr = ptr;
#line 947
    return (0);
    case_13: /* CIL Label */ 
    case_12: /* CIL Label */ 
#line 950
    ptr ++;
#line 951
    if (t != open___0) {
#line 952
      goto switch_break;
    }
#line 953
    if ((unsigned long )ptr == (unsigned long )end) {
#line 954
      return (-27);
    }
#line 955
    *nextTokPtr = ptr;
    {
#line 958
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 20) {
#line 958
      goto case_20;
    }
#line 958
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 30) {
#line 958
      goto case_20;
    }
#line 958
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 11) {
#line 958
      goto case_20;
    }
#line 958
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 10) {
#line 958
      goto case_20;
    }
#line 958
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 9) {
#line 958
      goto case_20;
    }
#line 958
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 21) {
#line 958
      goto case_20;
    }
#line 960
    goto switch_default;
    case_20: /* CIL Label */ 
    case_30: /* CIL Label */ 
    case_11: /* CIL Label */ 
    case_10: /* CIL Label */ 
    case_9: /* CIL Label */ 
    case_21: /* CIL Label */ 
#line 959
    return (27);
    switch_default: /* CIL Label */ 
#line 961
    return (0);
    switch_break___0: /* CIL Label */ ;
    }
    switch_default___0: /* CIL Label */ 
#line 964
    ptr ++;
#line 965
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 968
  return (-1);
}
}
#line 971 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmltok_impl.c"
static int normal_prologTok___0(ENCODING const   *enc , char const   *ptr , char const   *end ,
                                char const   **nextTokPtr ) 
{ 
  int tok ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;

  {
#line 976
  if ((unsigned long )ptr == (unsigned long )end) {
#line 977
    return (-4);
  }
  {
#line 988
  if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 12) {
#line 988
    goto case_12;
  }
#line 990
  if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 13) {
#line 990
    goto case_13;
  }
#line 992
  if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 2) {
#line 992
    goto case_2;
  }
#line 1014
  if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 9) {
#line 1014
    goto case_9;
  }
#line 1021
  if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 10) {
#line 1021
    goto case_10;
  }
#line 1021
  if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 21) {
#line 1021
    goto case_10;
  }
#line 1041
  if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 30) {
#line 1041
    goto case_30;
  }
#line 1043
  if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 35) {
#line 1043
    goto case_35;
  }
#line 1046
  if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 20) {
#line 1046
    goto case_20;
  }
#line 1049
  if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 4) {
#line 1049
    goto case_4;
  }
#line 1063
  if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 31) {
#line 1063
    goto case_31;
  }
#line 1066
  if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 32) {
#line 1066
    goto case_32;
  }
#line 1088
  if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 36) {
#line 1088
    goto case_36___0;
  }
#line 1091
  if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 11) {
#line 1091
    goto case_11___0;
  }
#line 1094
  if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 19) {
#line 1094
    goto case_19;
  }
#line 1112
  if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 5) {
#line 1112
    goto case_5___0;
  }
#line 1112
  if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 6) {
#line 1112
    goto case_6___0;
  }
#line 1112
  if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 7) {
#line 1112
    goto case_7___0;
  }
#line 1115
  if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 24) {
#line 1115
    goto case_24___0;
  }
#line 1115
  if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 22) {
#line 1115
    goto case_24___0;
  }
#line 1123
  if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 23) {
#line 1123
    goto case_23;
  }
#line 1123
  if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 27) {
#line 1123
    goto case_23;
  }
#line 1123
  if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 26) {
#line 1123
    goto case_23;
  }
#line 1123
  if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 25) {
#line 1123
    goto case_23;
  }
#line 1128
  if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 29) {
#line 1128
    goto case_29___0;
  }
#line 1140
  goto switch_default___0;
  case_12: /* CIL Label */ 
  {
#line 989
  tmp = normal_scanLit___0(12, enc, ptr + 1, end, nextTokPtr);
  }
#line 989
  return (tmp);
  case_13: /* CIL Label */ 
  {
#line 991
  tmp___0 = normal_scanLit___0(13, enc, ptr + 1, end, nextTokPtr);
  }
#line 991
  return (tmp___0);
  case_2: /* CIL Label */ 
#line 994
  ptr ++;
#line 995
  if ((unsigned long )ptr == (unsigned long )end) {
#line 996
    return (-1);
  }
  {
#line 998
  if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 16) {
#line 998
    goto case_16;
  }
#line 1000
  if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 15) {
#line 1000
    goto case_15;
  }
#line 1007
  if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 7) {
#line 1007
    goto case_7;
  }
#line 1007
  if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 6) {
#line 1007
    goto case_7;
  }
#line 1007
  if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 5) {
#line 1007
    goto case_7;
  }
#line 1007
  if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 29) {
#line 1007
    goto case_7;
  }
#line 1007
  if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 24) {
#line 1007
    goto case_7;
  }
#line 1007
  if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 22) {
#line 1007
    goto case_7;
  }
#line 997
  goto switch_break___0;
  case_16: /* CIL Label */ 
  {
#line 999
  tmp___1 = normal_scanDecl___0(enc, ptr + 1, end, nextTokPtr);
  }
#line 999
  return (tmp___1);
  case_15: /* CIL Label */ 
  {
#line 1001
  tmp___2 = normal_scanPi___0(enc, ptr + 1, end, nextTokPtr);
  }
#line 1001
  return (tmp___2);
  case_7: /* CIL Label */ 
  case_6: /* CIL Label */ 
  case_5: /* CIL Label */ 
  case_29: /* CIL Label */ 
  case_24: /* CIL Label */ 
  case_22: /* CIL Label */ 
#line 1008
  *nextTokPtr = ptr - 1;
#line 1009
  return (29);
  switch_break___0: /* CIL Label */ ;
  }
#line 1011
  *nextTokPtr = ptr;
#line 1012
  return (0);
  case_9: /* CIL Label */ 
#line 1015
  if ((unsigned long )(ptr + 1) == (unsigned long )end) {
#line 1016
    *nextTokPtr = end;
#line 1018
    return (-15);
  }
  case_10: /* CIL Label */ 
  case_21: /* CIL Label */ 
  {
#line 1022
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1023
    ptr ++;
#line 1024
    if ((unsigned long )ptr == (unsigned long )end) {
#line 1025
      goto while_break;
    }
    {
#line 1027
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 10) {
#line 1027
      goto case_10___0;
    }
#line 1027
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 21) {
#line 1027
      goto case_10___0;
    }
#line 1029
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 9) {
#line 1029
      goto case_9___0;
    }
#line 1034
    goto switch_default;
    case_10___0: /* CIL Label */ 
    case_21___0: /* CIL Label */ 
#line 1028
    goto switch_break___1;
    case_9___0: /* CIL Label */ 
#line 1031
    if ((unsigned long )(ptr + 1) != (unsigned long )end) {
#line 1032
      goto switch_break___1;
    }
    switch_default: /* CIL Label */ 
#line 1035
    *nextTokPtr = ptr;
#line 1036
    return (15);
    switch_break___1: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1039
  *nextTokPtr = ptr;
#line 1040
  return (15);
  case_30: /* CIL Label */ 
  {
#line 1042
  tmp___3 = normal_scanPercent___0(enc, ptr + 1, end, nextTokPtr);
  }
#line 1042
  return (tmp___3);
  case_35: /* CIL Label */ 
#line 1044
  *nextTokPtr = ptr + 1;
#line 1045
  return (38);
  case_20: /* CIL Label */ 
#line 1047
  *nextTokPtr = ptr + 1;
#line 1048
  return (25);
  case_4: /* CIL Label */ 
#line 1050
  ptr ++;
#line 1051
  if ((unsigned long )ptr == (unsigned long )end) {
#line 1052
    return (-26);
  }
#line 1053
  if ((int const   )*ptr == 93) {
#line 1054
    if ((unsigned long )(ptr + 1) == (unsigned long )end) {
#line 1055
      return (-1);
    }
#line 1056
    if ((int const   )*(ptr + 1) == 62) {
#line 1057
      *nextTokPtr = ptr + 2;
#line 1058
      return (34);
    }
  }
#line 1061
  *nextTokPtr = ptr;
#line 1062
  return (26);
  case_31: /* CIL Label */ 
#line 1064
  *nextTokPtr = ptr + 1;
#line 1065
  return (23);
  case_32: /* CIL Label */ 
#line 1067
  ptr ++;
#line 1068
  if ((unsigned long )ptr == (unsigned long )end) {
#line 1069
    return (-24);
  }
  {
#line 1071
  if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 33) {
#line 1071
    goto case_33;
  }
#line 1074
  if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 15) {
#line 1074
    goto case_15___0;
  }
#line 1077
  if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 34) {
#line 1077
    goto case_34;
  }
#line 1082
  if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 32) {
#line 1082
    goto case_32___0;
  }
#line 1082
  if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 36) {
#line 1082
    goto case_32___0;
  }
#line 1082
  if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 35) {
#line 1082
    goto case_32___0;
  }
#line 1082
  if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 11) {
#line 1082
    goto case_32___0;
  }
#line 1082
  if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 21) {
#line 1082
    goto case_32___0;
  }
#line 1082
  if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 10) {
#line 1082
    goto case_32___0;
  }
#line 1082
  if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 9) {
#line 1082
    goto case_32___0;
  }
#line 1070
  goto switch_break___2;
  case_33: /* CIL Label */ 
#line 1072
  *nextTokPtr = ptr + 1;
#line 1073
  return (36);
  case_15___0: /* CIL Label */ 
#line 1075
  *nextTokPtr = ptr + 1;
#line 1076
  return (35);
  case_34: /* CIL Label */ 
#line 1078
  *nextTokPtr = ptr + 1;
#line 1079
  return (37);
  case_32___0: /* CIL Label */ 
  case_36: /* CIL Label */ 
  case_35___0: /* CIL Label */ 
  case_11: /* CIL Label */ 
  case_21___1: /* CIL Label */ 
  case_10___1: /* CIL Label */ 
  case_9___1: /* CIL Label */ 
#line 1083
  *nextTokPtr = ptr;
#line 1084
  return (24);
  switch_break___2: /* CIL Label */ ;
  }
#line 1086
  *nextTokPtr = ptr;
#line 1087
  return (0);
  case_36___0: /* CIL Label */ 
#line 1089
  *nextTokPtr = ptr + 1;
#line 1090
  return (21);
  case_11___0: /* CIL Label */ 
#line 1092
  *nextTokPtr = ptr + 1;
#line 1093
  return (17);
  case_19: /* CIL Label */ 
  {
#line 1095
  tmp___4 = normal_scanPoundName___0(enc, ptr + 1, end, nextTokPtr);
  }
#line 1095
  return (tmp___4);
  case_5___0: /* CIL Label */ 
#line 1112
  if (end - ptr < 2L) {
#line 1112
    return (-2);
  }
  {
#line 1112
  tmp___5 = (*(((struct normal_encoding  const  *)enc)->isNmstrt2))(enc, ptr);
  }
#line 1112
  if (tmp___5) {
#line 1112
    ptr += 2;
#line 1112
    tok = 18;
#line 1112
    goto switch_break;
  }
  {
#line 1112
  tmp___6 = (*(((struct normal_encoding  const  *)enc)->isName2))(enc, ptr);
  }
#line 1112
  if (tmp___6) {
#line 1112
    ptr += 2;
#line 1112
    tok = 19;
#line 1112
    goto switch_break;
  }
#line 1112
  *nextTokPtr = ptr;
#line 1112
  return (0);
  case_6___0: /* CIL Label */ 
#line 1112
  if (end - ptr < 3L) {
#line 1112
    return (-2);
  }
  {
#line 1112
  tmp___7 = (*(((struct normal_encoding  const  *)enc)->isNmstrt3))(enc, ptr);
  }
#line 1112
  if (tmp___7) {
#line 1112
    ptr += 3;
#line 1112
    tok = 18;
#line 1112
    goto switch_break;
  }
  {
#line 1112
  tmp___8 = (*(((struct normal_encoding  const  *)enc)->isName3))(enc, ptr);
  }
#line 1112
  if (tmp___8) {
#line 1112
    ptr += 3;
#line 1112
    tok = 19;
#line 1112
    goto switch_break;
  }
#line 1112
  *nextTokPtr = ptr;
#line 1112
  return (0);
  case_7___0: /* CIL Label */ 
#line 1112
  if (end - ptr < 4L) {
#line 1112
    return (-2);
  }
  {
#line 1112
  tmp___9 = (*(((struct normal_encoding  const  *)enc)->isNmstrt4))(enc, ptr);
  }
#line 1112
  if (tmp___9) {
#line 1112
    ptr += 4;
#line 1112
    tok = 18;
#line 1112
    goto switch_break;
  }
  {
#line 1112
  tmp___10 = (*(((struct normal_encoding  const  *)enc)->isName4))(enc, ptr);
  }
#line 1112
  if (tmp___10) {
#line 1112
    ptr += 4;
#line 1112
    tok = 19;
#line 1112
    goto switch_break;
  }
#line 1112
  *nextTokPtr = ptr;
#line 1112
  return (0);
  case_24___0: /* CIL Label */ 
  case_22___0: /* CIL Label */ 
#line 1116
  tok = 18;
#line 1117
  ptr ++;
#line 1118
  goto switch_break;
  case_23: /* CIL Label */ 
  case_27: /* CIL Label */ 
  case_26: /* CIL Label */ 
  case_25: /* CIL Label */ 
#line 1125
  tok = 19;
#line 1126
  ptr ++;
#line 1127
  goto switch_break;
  case_29___0: /* CIL Label */ ;
  switch_default___0: /* CIL Label */ 
#line 1141
  *nextTokPtr = ptr;
#line 1142
  return (0);
  switch_break: /* CIL Label */ ;
  }
  {
#line 1144
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1144
    if (! ((unsigned long )ptr != (unsigned long )end)) {
#line 1144
      goto while_break___0;
    }
    {
#line 1146
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 29) {
#line 1146
      goto case_29___1;
    }
#line 1146
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 27) {
#line 1146
      goto case_27___0;
    }
#line 1146
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 26) {
#line 1146
      goto case_27___0;
    }
#line 1146
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 25) {
#line 1146
      goto case_27___0;
    }
#line 1146
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 24) {
#line 1146
      goto case_27___0;
    }
#line 1146
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 22) {
#line 1146
      goto case_27___0;
    }
#line 1146
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 5) {
#line 1146
      goto case_5___1;
    }
#line 1146
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 6) {
#line 1146
      goto case_6___1;
    }
#line 1146
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 7) {
#line 1146
      goto case_7___1;
    }
#line 1149
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 10) {
#line 1149
      goto case_10___2;
    }
#line 1149
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 9) {
#line 1149
      goto case_10___2;
    }
#line 1149
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 21) {
#line 1149
      goto case_10___2;
    }
#line 1149
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 30) {
#line 1149
      goto case_10___2;
    }
#line 1149
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 20) {
#line 1149
      goto case_10___2;
    }
#line 1149
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 36) {
#line 1149
      goto case_10___2;
    }
#line 1149
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 35) {
#line 1149
      goto case_10___2;
    }
#line 1149
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 32) {
#line 1149
      goto case_10___2;
    }
#line 1149
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 11) {
#line 1149
      goto case_10___2;
    }
#line 1153
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 23) {
#line 1153
      goto case_23___0;
    }
#line 1173
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 34) {
#line 1173
      goto case_34___0;
    }
#line 1180
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 33) {
#line 1180
      goto case_33___0;
    }
#line 1187
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 15) {
#line 1187
      goto case_15___1;
    }
#line 1194
    goto switch_default___2;
    case_29___1: /* CIL Label */ 
#line 1146
    *nextTokPtr = ptr;
#line 1146
    return (0);
    case_27___0: /* CIL Label */ 
    case_26___0: /* CIL Label */ 
    case_25___0: /* CIL Label */ 
    case_24___1: /* CIL Label */ 
    case_22___1: /* CIL Label */ 
#line 1146
    ptr ++;
#line 1146
    goto switch_break___3;
    case_5___1: /* CIL Label */ 
#line 1146
    if (end - ptr < 2L) {
#line 1146
      return (-2);
    }
    {
#line 1146
    tmp___11 = (*(((struct normal_encoding  const  *)enc)->isName2))(enc, ptr);
    }
#line 1146
    if (! tmp___11) {
#line 1146
      *nextTokPtr = ptr;
#line 1146
      return (0);
    }
#line 1146
    ptr += 2;
#line 1146
    goto switch_break___3;
    case_6___1: /* CIL Label */ 
#line 1146
    if (end - ptr < 3L) {
#line 1146
      return (-2);
    }
    {
#line 1146
    tmp___12 = (*(((struct normal_encoding  const  *)enc)->isName3))(enc, ptr);
    }
#line 1146
    if (! tmp___12) {
#line 1146
      *nextTokPtr = ptr;
#line 1146
      return (0);
    }
#line 1146
    ptr += 3;
#line 1146
    goto switch_break___3;
    case_7___1: /* CIL Label */ 
#line 1146
    if (end - ptr < 4L) {
#line 1146
      return (-2);
    }
    {
#line 1146
    tmp___13 = (*(((struct normal_encoding  const  *)enc)->isName4))(enc, ptr);
    }
#line 1146
    if (! tmp___13) {
#line 1146
      *nextTokPtr = ptr;
#line 1146
      return (0);
    }
#line 1146
    ptr += 4;
#line 1146
    goto switch_break___3;
    case_10___2: /* CIL Label */ 
    case_9___2: /* CIL Label */ 
    case_21___2: /* CIL Label */ 
    case_30___0: /* CIL Label */ 
    case_20___0: /* CIL Label */ 
    case_36___1: /* CIL Label */ 
    case_35___1: /* CIL Label */ 
    case_32___1: /* CIL Label */ 
    case_11___1: /* CIL Label */ 
#line 1150
    *nextTokPtr = ptr;
#line 1151
    return (tok);
    case_23___0: /* CIL Label */ 
#line 1154
    ptr ++;
    {
#line 1156
    if (tok == 18) {
#line 1156
      goto case_18;
    }
#line 1167
    if (tok == 41) {
#line 1167
      goto case_41;
    }
#line 1155
    goto switch_break___4;
    case_18: /* CIL Label */ 
#line 1157
    if ((unsigned long )ptr == (unsigned long )end) {
#line 1158
      return (-1);
    }
#line 1159
    tok = 41;
    {
#line 1161
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 29) {
#line 1161
      goto case_29___2;
    }
#line 1161
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 27) {
#line 1161
      goto case_27___1;
    }
#line 1161
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 26) {
#line 1161
      goto case_27___1;
    }
#line 1161
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 25) {
#line 1161
      goto case_27___1;
    }
#line 1161
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 24) {
#line 1161
      goto case_27___1;
    }
#line 1161
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 22) {
#line 1161
      goto case_27___1;
    }
#line 1161
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 5) {
#line 1161
      goto case_5___2;
    }
#line 1161
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 6) {
#line 1161
      goto case_6___2;
    }
#line 1161
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 7) {
#line 1161
      goto case_7___2;
    }
#line 1162
    goto switch_default___1;
    case_29___2: /* CIL Label */ 
#line 1161
    *nextTokPtr = ptr;
#line 1161
    return (0);
    case_27___1: /* CIL Label */ 
    case_26___1: /* CIL Label */ 
    case_25___1: /* CIL Label */ 
    case_24___2: /* CIL Label */ 
    case_22___2: /* CIL Label */ 
#line 1161
    ptr ++;
#line 1161
    goto switch_break___5;
    case_5___2: /* CIL Label */ 
#line 1161
    if (end - ptr < 2L) {
#line 1161
      return (-2);
    }
    {
#line 1161
    tmp___14 = (*(((struct normal_encoding  const  *)enc)->isName2))(enc, ptr);
    }
#line 1161
    if (! tmp___14) {
#line 1161
      *nextTokPtr = ptr;
#line 1161
      return (0);
    }
#line 1161
    ptr += 2;
#line 1161
    goto switch_break___5;
    case_6___2: /* CIL Label */ 
#line 1161
    if (end - ptr < 3L) {
#line 1161
      return (-2);
    }
    {
#line 1161
    tmp___15 = (*(((struct normal_encoding  const  *)enc)->isName3))(enc, ptr);
    }
#line 1161
    if (! tmp___15) {
#line 1161
      *nextTokPtr = ptr;
#line 1161
      return (0);
    }
#line 1161
    ptr += 3;
#line 1161
    goto switch_break___5;
    case_7___2: /* CIL Label */ 
#line 1161
    if (end - ptr < 4L) {
#line 1161
      return (-2);
    }
    {
#line 1161
    tmp___16 = (*(((struct normal_encoding  const  *)enc)->isName4))(enc, ptr);
    }
#line 1161
    if (! tmp___16) {
#line 1161
      *nextTokPtr = ptr;
#line 1161
      return (0);
    }
#line 1161
    ptr += 4;
#line 1161
    goto switch_break___5;
    switch_default___1: /* CIL Label */ 
#line 1163
    tok = 19;
#line 1164
    goto switch_break___5;
    switch_break___5: /* CIL Label */ ;
    }
#line 1166
    goto switch_break___4;
    case_41: /* CIL Label */ 
#line 1168
    tok = 19;
#line 1169
    goto switch_break___4;
    switch_break___4: /* CIL Label */ ;
    }
#line 1171
    goto switch_break___3;
    case_34___0: /* CIL Label */ 
#line 1174
    if (tok == 19) {
#line 1175
      *nextTokPtr = ptr;
#line 1176
      return (0);
    }
#line 1178
    *nextTokPtr = ptr + 1;
#line 1179
    return (32);
    case_33___0: /* CIL Label */ 
#line 1181
    if (tok == 19) {
#line 1182
      *nextTokPtr = ptr;
#line 1183
      return (0);
    }
#line 1185
    *nextTokPtr = ptr + 1;
#line 1186
    return (31);
    case_15___1: /* CIL Label */ 
#line 1188
    if (tok == 19) {
#line 1189
      *nextTokPtr = ptr;
#line 1190
      return (0);
    }
#line 1192
    *nextTokPtr = ptr + 1;
#line 1193
    return (30);
    switch_default___2: /* CIL Label */ 
#line 1195
    *nextTokPtr = ptr;
#line 1196
    return (0);
    switch_break___3: /* CIL Label */ ;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1199
  return (- tok);
}
}
#line 1202 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmltok_impl.c"
static int normal_attributeValueTok___0(ENCODING const   *enc , char const   *ptr ,
                                        char const   *end , char const   **nextTokPtr ) 
{ 
  char const   *start ;
  int tmp ;

  {
#line 1207
  if ((unsigned long )ptr == (unsigned long )end) {
#line 1208
    return (-4);
  }
#line 1209
  start = ptr;
  {
#line 1210
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1210
    if (! ((unsigned long )ptr != (unsigned long )end)) {
#line 1210
      goto while_break;
    }
    {
#line 1214
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 5) {
#line 1214
      goto case_5;
    }
#line 1214
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 6) {
#line 1214
      goto case_6;
    }
#line 1214
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 7) {
#line 1214
      goto case_7;
    }
#line 1216
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 3) {
#line 1216
      goto case_3;
    }
#line 1221
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 2) {
#line 1221
      goto case_2;
    }
#line 1225
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 10) {
#line 1225
      goto case_10;
    }
#line 1232
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 9) {
#line 1232
      goto case_9;
    }
#line 1244
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 21) {
#line 1244
      goto case_21;
    }
#line 1251
    goto switch_default;
    case_5: /* CIL Label */ 
#line 1214
    ptr += 2;
#line 1214
    goto switch_break;
    case_6: /* CIL Label */ 
#line 1214
    ptr += 3;
#line 1214
    goto switch_break;
    case_7: /* CIL Label */ 
#line 1214
    ptr += 4;
#line 1214
    goto switch_break;
    case_3: /* CIL Label */ 
#line 1217
    if ((unsigned long )ptr == (unsigned long )start) {
      {
#line 1218
      tmp = normal_scanRef___0(enc, ptr + 1, end, nextTokPtr);
      }
#line 1218
      return (tmp);
    }
#line 1219
    *nextTokPtr = ptr;
#line 1220
    return (6);
    case_2: /* CIL Label */ 
#line 1223
    *nextTokPtr = ptr;
#line 1224
    return (0);
    case_10: /* CIL Label */ 
#line 1226
    if ((unsigned long )ptr == (unsigned long )start) {
#line 1227
      *nextTokPtr = ptr + 1;
#line 1228
      return (7);
    }
#line 1230
    *nextTokPtr = ptr;
#line 1231
    return (6);
    case_9: /* CIL Label */ 
#line 1233
    if ((unsigned long )ptr == (unsigned long )start) {
#line 1234
      ptr ++;
#line 1235
      if ((unsigned long )ptr == (unsigned long )end) {
#line 1236
        return (-3);
      }
#line 1237
      if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 10) {
#line 1238
        ptr ++;
      }
#line 1239
      *nextTokPtr = ptr;
#line 1240
      return (7);
    }
#line 1242
    *nextTokPtr = ptr;
#line 1243
    return (6);
    case_21: /* CIL Label */ 
#line 1245
    if ((unsigned long )ptr == (unsigned long )start) {
#line 1246
      *nextTokPtr = ptr + 1;
#line 1247
      return (39);
    }
#line 1249
    *nextTokPtr = ptr;
#line 1250
    return (6);
    switch_default: /* CIL Label */ 
#line 1252
    ptr ++;
#line 1253
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1256
  *nextTokPtr = ptr;
#line 1257
  return (6);
}
}
#line 1260 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmltok_impl.c"
static int normal_entityValueTok___0(ENCODING const   *enc , char const   *ptr , char const   *end ,
                                     char const   **nextTokPtr ) 
{ 
  char const   *start ;
  int tmp ;
  int tok ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 1265
  if ((unsigned long )ptr == (unsigned long )end) {
#line 1266
    return (-4);
  }
#line 1267
  start = ptr;
  {
#line 1268
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1268
    if (! ((unsigned long )ptr != (unsigned long )end)) {
#line 1268
      goto while_break;
    }
    {
#line 1272
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 5) {
#line 1272
      goto case_5;
    }
#line 1272
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 6) {
#line 1272
      goto case_6;
    }
#line 1272
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 7) {
#line 1272
      goto case_7;
    }
#line 1274
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 3) {
#line 1274
      goto case_3;
    }
#line 1279
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 30) {
#line 1279
      goto case_30;
    }
#line 1287
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 10) {
#line 1287
      goto case_10;
    }
#line 1294
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 9) {
#line 1294
      goto case_9;
    }
#line 1306
    goto switch_default;
    case_5: /* CIL Label */ 
#line 1272
    ptr += 2;
#line 1272
    goto switch_break;
    case_6: /* CIL Label */ 
#line 1272
    ptr += 3;
#line 1272
    goto switch_break;
    case_7: /* CIL Label */ 
#line 1272
    ptr += 4;
#line 1272
    goto switch_break;
    case_3: /* CIL Label */ 
#line 1275
    if ((unsigned long )ptr == (unsigned long )start) {
      {
#line 1276
      tmp = normal_scanRef___0(enc, ptr + 1, end, nextTokPtr);
      }
#line 1276
      return (tmp);
    }
#line 1277
    *nextTokPtr = ptr;
#line 1278
    return (6);
    case_30: /* CIL Label */ 
#line 1280
    if ((unsigned long )ptr == (unsigned long )start) {
      {
#line 1281
      tmp___0 = normal_scanPercent___0(enc, ptr + 1, end, nextTokPtr);
#line 1281
      tok = tmp___0;
      }
#line 1283
      if (tok == 22) {
#line 1283
        tmp___1 = 0;
      } else {
#line 1283
        tmp___1 = tok;
      }
#line 1283
      return (tmp___1);
    }
#line 1285
    *nextTokPtr = ptr;
#line 1286
    return (6);
    case_10: /* CIL Label */ 
#line 1288
    if ((unsigned long )ptr == (unsigned long )start) {
#line 1289
      *nextTokPtr = ptr + 1;
#line 1290
      return (7);
    }
#line 1292
    *nextTokPtr = ptr;
#line 1293
    return (6);
    case_9: /* CIL Label */ 
#line 1295
    if ((unsigned long )ptr == (unsigned long )start) {
#line 1296
      ptr ++;
#line 1297
      if ((unsigned long )ptr == (unsigned long )end) {
#line 1298
        return (-3);
      }
#line 1299
      if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 10) {
#line 1300
        ptr ++;
      }
#line 1301
      *nextTokPtr = ptr;
#line 1302
      return (7);
    }
#line 1304
    *nextTokPtr = ptr;
#line 1305
    return (6);
    switch_default: /* CIL Label */ 
#line 1307
    ptr ++;
#line 1308
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1311
  *nextTokPtr = ptr;
#line 1312
  return (6);
}
}
#line 1317 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmltok_impl.c"
static int normal_ignoreSectionTok___0(ENCODING const   *enc , char const   *ptr ,
                                       char const   *end , char const   **nextTokPtr ) 
{ 
  int level ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 1321
  level = 0;
  {
#line 1329
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1329
    if (! ((unsigned long )ptr != (unsigned long )end)) {
#line 1329
      goto while_break;
    }
    {
#line 1331
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 5) {
#line 1331
      goto case_5;
    }
#line 1331
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 6) {
#line 1331
      goto case_6;
    }
#line 1331
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 7) {
#line 1331
      goto case_7;
    }
#line 1331
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 8) {
#line 1331
      goto case_8;
    }
#line 1331
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 1) {
#line 1331
      goto case_8;
    }
#line 1331
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 0) {
#line 1331
      goto case_8;
    }
#line 1332
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 2) {
#line 1332
      goto case_2;
    }
#line 1344
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 4) {
#line 1344
      goto case_4;
    }
#line 1360
    goto switch_default;
    case_5: /* CIL Label */ 
#line 1331
    if (end - ptr < 2L) {
#line 1331
      return (-2);
    }
    {
#line 1331
    tmp = (*(((struct normal_encoding  const  *)enc)->isInvalid2))(enc, ptr);
    }
#line 1331
    if (tmp) {
#line 1331
      *nextTokPtr = ptr;
#line 1331
      return (0);
    }
#line 1331
    ptr += 2;
#line 1331
    goto switch_break;
    case_6: /* CIL Label */ 
#line 1331
    if (end - ptr < 3L) {
#line 1331
      return (-2);
    }
    {
#line 1331
    tmp___0 = (*(((struct normal_encoding  const  *)enc)->isInvalid3))(enc, ptr);
    }
#line 1331
    if (tmp___0) {
#line 1331
      *nextTokPtr = ptr;
#line 1331
      return (0);
    }
#line 1331
    ptr += 3;
#line 1331
    goto switch_break;
    case_7: /* CIL Label */ 
#line 1331
    if (end - ptr < 4L) {
#line 1331
      return (-2);
    }
    {
#line 1331
    tmp___1 = (*(((struct normal_encoding  const  *)enc)->isInvalid4))(enc, ptr);
    }
#line 1331
    if (tmp___1) {
#line 1331
      *nextTokPtr = ptr;
#line 1331
      return (0);
    }
#line 1331
    ptr += 4;
#line 1331
    goto switch_break;
    case_8: /* CIL Label */ 
    case_1: /* CIL Label */ 
    case_0: /* CIL Label */ 
#line 1331
    *nextTokPtr = ptr;
#line 1331
    return (0);
    case_2: /* CIL Label */ 
#line 1333
    ptr ++;
#line 1333
    if ((unsigned long )ptr == (unsigned long )end) {
#line 1334
      return (-1);
    }
#line 1335
    if ((int const   )*ptr == 33) {
#line 1336
      ptr ++;
#line 1336
      if ((unsigned long )ptr == (unsigned long )end) {
#line 1337
        return (-1);
      }
#line 1338
      if ((int const   )*ptr == 91) {
#line 1339
        level ++;
#line 1340
        ptr ++;
      }
    }
#line 1343
    goto switch_break;
    case_4: /* CIL Label */ 
#line 1345
    ptr ++;
#line 1345
    if ((unsigned long )ptr == (unsigned long )end) {
#line 1346
      return (-1);
    }
#line 1347
    if ((int const   )*ptr == 93) {
#line 1348
      ptr ++;
#line 1348
      if ((unsigned long )ptr == (unsigned long )end) {
#line 1349
        return (-1);
      }
#line 1350
      if ((int const   )*ptr == 62) {
#line 1351
        ptr ++;
#line 1352
        if (level == 0) {
#line 1353
          *nextTokPtr = ptr;
#line 1354
          return (42);
        }
#line 1356
        level --;
      }
    }
#line 1359
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 1361
    ptr ++;
#line 1362
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1365
  return (-1);
}
}
#line 1370 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmltok_impl.c"
static int normal_isPublicId___0(ENCODING const   *enc , char const   *ptr , char const   *end ,
                                 char const   **badPtr ) 
{ 


  {
#line 1374
  ptr ++;
#line 1375
  end --;
  {
#line 1376
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1376
    if (! ((unsigned long )ptr != (unsigned long )end)) {
#line 1376
      goto while_break;
    }
    {
#line 1397
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 23) {
#line 1397
      goto case_23;
    }
#line 1397
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 19) {
#line 1397
      goto case_23;
    }
#line 1397
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 30) {
#line 1397
      goto case_23;
    }
#line 1397
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 33) {
#line 1397
      goto case_23;
    }
#line 1397
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 16) {
#line 1397
      goto case_23;
    }
#line 1397
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 18) {
#line 1397
      goto case_23;
    }
#line 1397
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 10) {
#line 1397
      goto case_23;
    }
#line 1397
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 9) {
#line 1397
      goto case_23;
    }
#line 1397
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 15) {
#line 1397
      goto case_23;
    }
#line 1397
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 14) {
#line 1397
      goto case_23;
    }
#line 1397
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 17) {
#line 1397
      goto case_23;
    }
#line 1397
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 35) {
#line 1397
      goto case_23;
    }
#line 1397
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 34) {
#line 1397
      goto case_23;
    }
#line 1397
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 32) {
#line 1397
      goto case_23;
    }
#line 1397
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 31) {
#line 1397
      goto case_23;
    }
#line 1397
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 13) {
#line 1397
      goto case_23;
    }
#line 1397
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 27) {
#line 1397
      goto case_23;
    }
#line 1397
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 24) {
#line 1397
      goto case_23;
    }
#line 1397
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 25) {
#line 1397
      goto case_23;
    }
#line 1400
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 21) {
#line 1400
      goto case_21;
    }
#line 1407
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 22) {
#line 1407
      goto case_22;
    }
#line 1407
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 26) {
#line 1407
      goto case_22;
    }
#line 1410
    goto switch_default;
    case_23: /* CIL Label */ 
    case_19: /* CIL Label */ 
    case_30: /* CIL Label */ 
    case_33: /* CIL Label */ 
    case_16: /* CIL Label */ 
    case_18: /* CIL Label */ 
    case_10: /* CIL Label */ 
    case_9: /* CIL Label */ 
    case_15: /* CIL Label */ 
    case_14: /* CIL Label */ 
    case_17: /* CIL Label */ 
    case_35: /* CIL Label */ 
    case_34: /* CIL Label */ 
    case_32: /* CIL Label */ 
    case_31: /* CIL Label */ 
    case_13: /* CIL Label */ 
    case_27: /* CIL Label */ 
    case_24: /* CIL Label */ 
    case_25: /* CIL Label */ 
#line 1399
    goto switch_break;
    case_21: /* CIL Label */ 
#line 1401
    if ((int const   )*ptr == 9) {
#line 1402
      *badPtr = ptr;
#line 1403
      return (0);
    }
#line 1405
    goto switch_break;
    case_22: /* CIL Label */ 
    case_26: /* CIL Label */ 
#line 1408
    if (! ((int const   )*ptr & -128)) {
#line 1409
      goto switch_break;
    }
    switch_default: /* CIL Label */ 
    {
#line 1413
    if ((int const   )*ptr == 64) {
#line 1413
      goto case_64;
    }
#line 1413
    if ((int const   )*ptr == 36) {
#line 1413
      goto case_64;
    }
#line 1415
    goto switch_default___0;
    case_64: /* CIL Label */ 
    case_36: /* CIL Label */ 
#line 1414
    goto switch_break___0;
    switch_default___0: /* CIL Label */ 
#line 1416
    *badPtr = ptr;
#line 1417
    return (0);
    switch_break___0: /* CIL Label */ ;
    }
#line 1419
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 1376
    ptr ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1422
  return (1);
}
}
#line 1430 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmltok_impl.c"
static int normal_getAtts___0(ENCODING const   *enc , char const   *ptr , int attsMax ,
                              ATTRIBUTE *atts ) 
{ 
  enum __anonenum_state_4___0 state ;
  int nAtts ;
  int open___0 ;

  {
#line 1434
  state = (enum __anonenum_state_4___0 )1;
#line 1435
  nAtts = 0;
#line 1436
  open___0 = 0;
#line 1439
  ptr ++;
  {
#line 1439
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1451
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 5) {
#line 1451
      goto case_5;
    }
#line 1451
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 6) {
#line 1451
      goto case_6;
    }
#line 1451
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 7) {
#line 1451
      goto case_7;
    }
#line 1455
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 24) {
#line 1455
      goto case_24;
    }
#line 1455
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 22) {
#line 1455
      goto case_24;
    }
#line 1455
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 29) {
#line 1455
      goto case_24;
    }
#line 1459
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 12) {
#line 1459
      goto case_12;
    }
#line 1473
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 13) {
#line 1473
      goto case_13;
    }
#line 1487
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 3) {
#line 1487
      goto case_3;
    }
#line 1491
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 21) {
#line 1491
      goto case_21;
    }
#line 1503
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 10) {
#line 1503
      goto case_10;
    }
#line 1503
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 9) {
#line 1503
      goto case_10;
    }
#line 1512
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 17) {
#line 1512
      goto case_17;
    }
#line 1512
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 11) {
#line 1512
      goto case_17;
    }
#line 1516
    goto switch_default;
    case_5: /* CIL Label */ 
#line 1451
    if ((unsigned int )state == 0U) {
#line 1451
      if (nAtts < attsMax) {
#line 1451
        (atts + nAtts)->name = ptr;
#line 1451
        (atts + nAtts)->normalized = (char)1;
      }
#line 1451
      state = (enum __anonenum_state_4___0 )1;
    }
#line 1451
    ptr ++;
#line 1451
    goto switch_break;
    case_6: /* CIL Label */ 
#line 1451
    if ((unsigned int )state == 0U) {
#line 1451
      if (nAtts < attsMax) {
#line 1451
        (atts + nAtts)->name = ptr;
#line 1451
        (atts + nAtts)->normalized = (char)1;
      }
#line 1451
      state = (enum __anonenum_state_4___0 )1;
    }
#line 1451
    ptr += 2;
#line 1451
    goto switch_break;
    case_7: /* CIL Label */ 
#line 1451
    if ((unsigned int )state == 0U) {
#line 1451
      if (nAtts < attsMax) {
#line 1451
        (atts + nAtts)->name = ptr;
#line 1451
        (atts + nAtts)->normalized = (char)1;
      }
#line 1451
      state = (enum __anonenum_state_4___0 )1;
    }
#line 1451
    ptr += 3;
#line 1451
    goto switch_break;
    case_24: /* CIL Label */ 
    case_22: /* CIL Label */ 
    case_29: /* CIL Label */ 
#line 1456
    if ((unsigned int )state == 0U) {
#line 1456
      if (nAtts < attsMax) {
#line 1456
        (atts + nAtts)->name = ptr;
#line 1456
        (atts + nAtts)->normalized = (char)1;
      }
#line 1456
      state = (enum __anonenum_state_4___0 )1;
    }
#line 1457
    goto switch_break;
    case_12: /* CIL Label */ 
#line 1460
    if ((unsigned int )state != 2U) {
#line 1461
      if (nAtts < attsMax) {
#line 1462
        (atts + nAtts)->valuePtr = ptr + 1;
      }
#line 1463
      state = (enum __anonenum_state_4___0 )2;
#line 1464
      open___0 = 12;
    } else
#line 1466
    if (open___0 == 12) {
#line 1467
      state = (enum __anonenum_state_4___0 )0;
#line 1468
      if (nAtts < attsMax) {
#line 1469
        (atts + nAtts)->valueEnd = ptr;
      }
#line 1470
      nAtts ++;
    }
#line 1472
    goto switch_break;
    case_13: /* CIL Label */ 
#line 1474
    if ((unsigned int )state != 2U) {
#line 1475
      if (nAtts < attsMax) {
#line 1476
        (atts + nAtts)->valuePtr = ptr + 1;
      }
#line 1477
      state = (enum __anonenum_state_4___0 )2;
#line 1478
      open___0 = 13;
    } else
#line 1480
    if (open___0 == 13) {
#line 1481
      state = (enum __anonenum_state_4___0 )0;
#line 1482
      if (nAtts < attsMax) {
#line 1483
        (atts + nAtts)->valueEnd = ptr;
      }
#line 1484
      nAtts ++;
    }
#line 1486
    goto switch_break;
    case_3: /* CIL Label */ 
#line 1488
    if (nAtts < attsMax) {
#line 1489
      (atts + nAtts)->normalized = (char)0;
    }
#line 1490
    goto switch_break;
    case_21: /* CIL Label */ 
#line 1492
    if ((unsigned int )state == 1U) {
#line 1493
      state = (enum __anonenum_state_4___0 )0;
    } else
#line 1494
    if ((unsigned int )state == 2U) {
#line 1494
      if (nAtts < attsMax) {
#line 1494
        if ((atts + nAtts)->normalized) {
#line 1494
          if ((unsigned long )ptr == (unsigned long )(atts + nAtts)->valuePtr) {
#line 1501
            (atts + nAtts)->normalized = (char)0;
          } else
#line 1494
          if ((int const   )*ptr != 32) {
#line 1501
            (atts + nAtts)->normalized = (char)0;
          } else
#line 1494
          if ((int const   )*(ptr + 1) == 32) {
#line 1501
            (atts + nAtts)->normalized = (char)0;
          } else
#line 1494
          if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*(ptr + 1)] == open___0) {
#line 1501
            (atts + nAtts)->normalized = (char)0;
          }
        }
      }
    }
#line 1502
    goto switch_break;
    case_10: /* CIL Label */ 
    case_9: /* CIL Label */ 
#line 1506
    if ((unsigned int )state == 1U) {
#line 1507
      state = (enum __anonenum_state_4___0 )0;
    } else
#line 1508
    if ((unsigned int )state == 2U) {
#line 1508
      if (nAtts < attsMax) {
#line 1509
        (atts + nAtts)->normalized = (char)0;
      }
    }
#line 1510
    goto switch_break;
    case_17: /* CIL Label */ 
    case_11: /* CIL Label */ 
#line 1513
    if ((unsigned int )state != 2U) {
#line 1514
      return (nAtts);
    }
#line 1515
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 1517
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 1439
    ptr ++;
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 1523 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmltok_impl.c"
static int normal_charRefNumber___0(ENCODING const   *enc , char const   *ptr ) 
{ 
  int result ;
  int c___0 ;
  int c___1 ;
  int tmp ;

  {
#line 1526
  result = 0;
#line 1528
  ptr += 2;
#line 1529
  if ((int const   )*ptr == 120) {
#line 1530
    ptr ++;
    {
#line 1530
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1530
      if (! (! ((int const   )*ptr == 59))) {
#line 1530
        goto while_break;
      }
#line 1533
      c___0 = (int )*ptr;
      {
#line 1536
      if (c___0 == 57) {
#line 1536
        goto case_57;
      }
#line 1536
      if (c___0 == 56) {
#line 1536
        goto case_57;
      }
#line 1536
      if (c___0 == 55) {
#line 1536
        goto case_57;
      }
#line 1536
      if (c___0 == 54) {
#line 1536
        goto case_57;
      }
#line 1536
      if (c___0 == 53) {
#line 1536
        goto case_57;
      }
#line 1536
      if (c___0 == 52) {
#line 1536
        goto case_57;
      }
#line 1536
      if (c___0 == 51) {
#line 1536
        goto case_57;
      }
#line 1536
      if (c___0 == 50) {
#line 1536
        goto case_57;
      }
#line 1536
      if (c___0 == 49) {
#line 1536
        goto case_57;
      }
#line 1536
      if (c___0 == 48) {
#line 1536
        goto case_57;
      }
#line 1541
      if (c___0 == 70) {
#line 1541
        goto case_70;
      }
#line 1541
      if (c___0 == 69) {
#line 1541
        goto case_70;
      }
#line 1541
      if (c___0 == 68) {
#line 1541
        goto case_70;
      }
#line 1541
      if (c___0 == 67) {
#line 1541
        goto case_70;
      }
#line 1541
      if (c___0 == 66) {
#line 1541
        goto case_70;
      }
#line 1541
      if (c___0 == 65) {
#line 1541
        goto case_70;
      }
#line 1546
      if (c___0 == 102) {
#line 1546
        goto case_102;
      }
#line 1546
      if (c___0 == 101) {
#line 1546
        goto case_102;
      }
#line 1546
      if (c___0 == 100) {
#line 1546
        goto case_102;
      }
#line 1546
      if (c___0 == 99) {
#line 1546
        goto case_102;
      }
#line 1546
      if (c___0 == 98) {
#line 1546
        goto case_102;
      }
#line 1546
      if (c___0 == 97) {
#line 1546
        goto case_102;
      }
#line 1534
      goto switch_break;
      case_57: /* CIL Label */ 
      case_56: /* CIL Label */ 
      case_55: /* CIL Label */ 
      case_54: /* CIL Label */ 
      case_53: /* CIL Label */ 
      case_52: /* CIL Label */ 
      case_51: /* CIL Label */ 
      case_50: /* CIL Label */ 
      case_49: /* CIL Label */ 
      case_48: /* CIL Label */ 
#line 1537
      result <<= 4;
#line 1538
      result |= c___0 - 48;
#line 1539
      goto switch_break;
      case_70: /* CIL Label */ 
      case_69: /* CIL Label */ 
      case_68: /* CIL Label */ 
      case_67: /* CIL Label */ 
      case_66: /* CIL Label */ 
      case_65: /* CIL Label */ 
#line 1542
      result <<= 4;
#line 1543
      result += 10 + (c___0 - 65);
#line 1544
      goto switch_break;
      case_102: /* CIL Label */ 
      case_101: /* CIL Label */ 
      case_100: /* CIL Label */ 
      case_99: /* CIL Label */ 
      case_98: /* CIL Label */ 
      case_97: /* CIL Label */ 
#line 1547
      result <<= 4;
#line 1548
      result += 10 + (c___0 - 97);
#line 1549
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
#line 1551
      if (result >= 1114112) {
#line 1552
        return (-1);
      }
#line 1530
      ptr ++;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
    {
#line 1556
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1556
      if (! (! ((int const   )*ptr == 59))) {
#line 1556
        goto while_break___0;
      }
#line 1557
      c___1 = (int )*ptr;
#line 1558
      result *= 10;
#line 1559
      result += c___1 - 48;
#line 1560
      if (result >= 1114112) {
#line 1561
        return (-1);
      }
#line 1556
      ptr ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  {
#line 1564
  tmp = checkCharRefNumber___0(result);
  }
#line 1564
  return (tmp);
}
}
#line 1567 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmltok_impl.c"
static int normal_predefinedEntityName___0(ENCODING const   *enc , char const   *ptr ,
                                           char const   *end ) 
{ 


  {
  {
#line 1572
  if (end - ptr == 2L) {
#line 1572
    goto case_2;
  }
#line 1582
  if (end - ptr == 3L) {
#line 1582
    goto case_3;
  }
#line 1592
  if (end - ptr == 4L) {
#line 1592
    goto case_4;
  }
#line 1571
  goto switch_break;
  case_2: /* CIL Label */ 
#line 1573
  if ((int const   )*(ptr + 1) == 116) {
    {
#line 1575
    if ((int const   )*ptr == 108) {
#line 1575
      goto case_108;
    }
#line 1577
    if ((int const   )*ptr == 103) {
#line 1577
      goto case_103;
    }
#line 1574
    goto switch_break___0;
    case_108: /* CIL Label */ 
#line 1576
    return (60);
    case_103: /* CIL Label */ 
#line 1578
    return (62);
    switch_break___0: /* CIL Label */ ;
    }
  }
#line 1581
  goto switch_break;
  case_3: /* CIL Label */ 
#line 1583
  if ((int const   )*ptr == 97) {
#line 1584
    ptr ++;
#line 1585
    if ((int const   )*ptr == 109) {
#line 1586
      ptr ++;
#line 1587
      if ((int const   )*ptr == 112) {
#line 1588
        return (38);
      }
    }
  }
#line 1591
  goto switch_break;
  case_4: /* CIL Label */ 
  {
#line 1594
  if ((int const   )*ptr == 113) {
#line 1594
    goto case_113;
  }
#line 1605
  if ((int const   )*ptr == 97) {
#line 1605
    goto case_97;
  }
#line 1593
  goto switch_break___1;
  case_113: /* CIL Label */ 
#line 1595
  ptr ++;
#line 1596
  if ((int const   )*ptr == 117) {
#line 1597
    ptr ++;
#line 1598
    if ((int const   )*ptr == 111) {
#line 1599
      ptr ++;
#line 1600
      if ((int const   )*ptr == 116) {
#line 1601
        return (34);
      }
    }
  }
#line 1604
  goto switch_break___1;
  case_97: /* CIL Label */ 
#line 1606
  ptr ++;
#line 1607
  if ((int const   )*ptr == 112) {
#line 1608
    ptr ++;
#line 1609
    if ((int const   )*ptr == 111) {
#line 1610
      ptr ++;
#line 1611
      if ((int const   )*ptr == 115) {
#line 1612
        return (39);
      }
    }
  }
#line 1615
  goto switch_break___1;
  switch_break___1: /* CIL Label */ ;
  }
  switch_break: /* CIL Label */ ;
  }
#line 1618
  return (0);
}
}
#line 1621 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmltok_impl.c"
static int normal_sameName___0(ENCODING const   *enc , char const   *ptr1 , char const   *ptr2 ) 
{ 
  char const   *tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;
  char const   *tmp___4 ;
  char const   *tmp___5 ;
  char const   *tmp___6 ;
  char const   *tmp___7 ;
  char const   *tmp___8 ;

  {
  {
#line 1624
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1630
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr1] == 7) {
#line 1630
      goto case_7;
    }
#line 1630
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr1] == 6) {
#line 1630
      goto case_6;
    }
#line 1630
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr1] == 5) {
#line 1630
      goto case_5;
    }
#line 1644
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr1] == 27) {
#line 1644
      goto case_27;
    }
#line 1644
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr1] == 26) {
#line 1644
      goto case_27;
    }
#line 1644
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr1] == 25) {
#line 1644
      goto case_27;
    }
#line 1644
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr1] == 24) {
#line 1644
      goto case_27;
    }
#line 1644
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr1] == 23) {
#line 1644
      goto case_27;
    }
#line 1644
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr1] == 22) {
#line 1644
      goto case_27;
    }
#line 1644
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr1] == 29) {
#line 1644
      goto case_27;
    }
#line 1660
    goto switch_default;
    case_7: /* CIL Label */ 
#line 1630
    tmp = ptr1;
#line 1630
    ptr1 ++;
#line 1630
    tmp___0 = ptr2;
#line 1630
    ptr2 ++;
#line 1630
    if ((int const   )*tmp != (int const   )*tmp___0) {
#line 1630
      return (0);
    }
    case_6: /* CIL Label */ 
#line 1630
    tmp___1 = ptr1;
#line 1630
    ptr1 ++;
#line 1630
    tmp___2 = ptr2;
#line 1630
    ptr2 ++;
#line 1630
    if ((int const   )*tmp___1 != (int const   )*tmp___2) {
#line 1630
      return (0);
    }
    case_5: /* CIL Label */ 
#line 1630
    tmp___3 = ptr1;
#line 1630
    ptr1 ++;
#line 1630
    tmp___4 = ptr2;
#line 1630
    ptr2 ++;
#line 1630
    if ((int const   )*tmp___3 != (int const   )*tmp___4) {
#line 1630
      return (0);
    }
#line 1633
    tmp___5 = ptr1;
#line 1633
    ptr1 ++;
#line 1633
    tmp___6 = ptr2;
#line 1633
    ptr2 ++;
#line 1633
    if ((int const   )*tmp___5 != (int const   )*tmp___6) {
#line 1634
      return (0);
    }
#line 1635
    goto switch_break;
    case_27: /* CIL Label */ 
    case_26: /* CIL Label */ 
    case_25: /* CIL Label */ 
    case_24: /* CIL Label */ 
    case_23: /* CIL Label */ 
    case_22: /* CIL Label */ 
    case_29: /* CIL Label */ 
#line 1645
    tmp___7 = ptr2;
#line 1645
    ptr2 ++;
#line 1645
    tmp___8 = ptr1;
#line 1645
    ptr1 ++;
#line 1645
    if ((int const   )*tmp___7 != (int const   )*tmp___8) {
#line 1646
      return (0);
    }
#line 1659
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 1661
    if ((int const   )*ptr1 == (int const   )*ptr2) {
#line 1662
      return (1);
    }
    {
#line 1675
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr2] == 27) {
#line 1675
      goto case_27___0;
    }
#line 1675
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr2] == 26) {
#line 1675
      goto case_27___0;
    }
#line 1675
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr2] == 25) {
#line 1675
      goto case_27___0;
    }
#line 1675
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr2] == 24) {
#line 1675
      goto case_27___0;
    }
#line 1675
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr2] == 23) {
#line 1675
      goto case_27___0;
    }
#line 1675
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr2] == 22) {
#line 1675
      goto case_27___0;
    }
#line 1675
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr2] == 29) {
#line 1675
      goto case_27___0;
    }
#line 1675
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr2] == 7) {
#line 1675
      goto case_27___0;
    }
#line 1675
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr2] == 6) {
#line 1675
      goto case_27___0;
    }
#line 1675
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr2] == 5) {
#line 1675
      goto case_27___0;
    }
#line 1677
    goto switch_default___0;
    case_27___0: /* CIL Label */ 
    case_26___0: /* CIL Label */ 
    case_25___0: /* CIL Label */ 
    case_24___0: /* CIL Label */ 
    case_23___0: /* CIL Label */ 
    case_22___0: /* CIL Label */ 
    case_29___0: /* CIL Label */ 
    case_7___0: /* CIL Label */ 
    case_6___0: /* CIL Label */ 
    case_5___0: /* CIL Label */ 
#line 1676
    return (0);
    switch_default___0: /* CIL Label */ 
#line 1678
    return (1);
    switch_break___0: /* CIL Label */ ;
    }
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 1685 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmltok_impl.c"
static int normal_nameMatchesAscii___0(ENCODING const   *enc , char const   *ptr1 ,
                                       char const   *end1 , char const   *ptr2 ) 
{ 


  {
  {
#line 1689
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1689
    if (! *ptr2) {
#line 1689
      goto while_break;
    }
#line 1690
    if ((unsigned long )ptr1 == (unsigned long )end1) {
#line 1691
      return (0);
    }
#line 1692
    if (! ((int const   )*ptr1 == (int const   )*ptr2)) {
#line 1693
      return (0);
    }
#line 1689
    ptr1 ++;
#line 1689
    ptr2 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1695
  return ((unsigned long )ptr1 == (unsigned long )end1);
}
}
#line 1698 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmltok_impl.c"
static int normal_nameLength___0(ENCODING const   *enc , char const   *ptr ) 
{ 
  char const   *start ;

  {
#line 1701
  start = ptr;
  {
#line 1702
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1706
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 5) {
#line 1706
      goto case_5;
    }
#line 1706
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 6) {
#line 1706
      goto case_6;
    }
#line 1706
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 7) {
#line 1706
      goto case_7;
    }
#line 1716
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 27) {
#line 1716
      goto case_27;
    }
#line 1716
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 26) {
#line 1716
      goto case_27;
    }
#line 1716
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 25) {
#line 1716
      goto case_27;
    }
#line 1716
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 24) {
#line 1716
      goto case_27;
    }
#line 1716
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 23) {
#line 1716
      goto case_27;
    }
#line 1716
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 22) {
#line 1716
      goto case_27;
    }
#line 1716
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 29) {
#line 1716
      goto case_27;
    }
#line 1719
    goto switch_default;
    case_5: /* CIL Label */ 
#line 1706
    ptr += 2;
#line 1706
    goto switch_break;
    case_6: /* CIL Label */ 
#line 1706
    ptr += 3;
#line 1706
    goto switch_break;
    case_7: /* CIL Label */ 
#line 1706
    ptr += 4;
#line 1706
    goto switch_break;
    case_27: /* CIL Label */ 
    case_26: /* CIL Label */ 
    case_25: /* CIL Label */ 
    case_24: /* CIL Label */ 
    case_23: /* CIL Label */ 
    case_22: /* CIL Label */ 
    case_29: /* CIL Label */ 
#line 1717
    ptr ++;
#line 1718
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 1720
    return ((int )(ptr - start));
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 1725 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmltok_impl.c"
static char const   *normal_skipS___0(ENCODING const   *enc , char const   *ptr ) 
{ 


  {
  {
#line 1728
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1732
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 21) {
#line 1732
      goto case_21;
    }
#line 1732
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 9) {
#line 1732
      goto case_21;
    }
#line 1732
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 10) {
#line 1732
      goto case_21;
    }
#line 1735
    goto switch_default;
    case_21: /* CIL Label */ 
    case_9: /* CIL Label */ 
    case_10: /* CIL Label */ 
#line 1733
    ptr ++;
#line 1734
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 1736
    return (ptr);
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 1741 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmltok_impl.c"
static void normal_updatePosition___0(ENCODING const   *enc , char const   *ptr ,
                                      char const   *end , POSITION *pos ) 
{ 


  {
  {
#line 1747
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1747
    if (! ((unsigned long )ptr < (unsigned long )end)) {
#line 1747
      goto while_break;
    }
    {
#line 1753
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 5) {
#line 1753
      goto case_5;
    }
#line 1753
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 6) {
#line 1753
      goto case_6;
    }
#line 1753
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 7) {
#line 1753
      goto case_7;
    }
#line 1755
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 10) {
#line 1755
      goto case_10;
    }
#line 1760
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 9) {
#line 1760
      goto case_9;
    }
#line 1767
    goto switch_default;
    case_5: /* CIL Label */ 
#line 1753
    ptr += 2;
#line 1753
    goto switch_break;
    case_6: /* CIL Label */ 
#line 1753
    ptr += 3;
#line 1753
    goto switch_break;
    case_7: /* CIL Label */ 
#line 1753
    ptr += 4;
#line 1753
    goto switch_break;
    case_10: /* CIL Label */ 
#line 1756
    pos->columnNumber = (XML_Size )-1;
#line 1757
    (pos->lineNumber) ++;
#line 1758
    ptr ++;
#line 1759
    goto switch_break;
    case_9: /* CIL Label */ 
#line 1761
    (pos->lineNumber) ++;
#line 1762
    ptr ++;
#line 1763
    if ((unsigned long )ptr != (unsigned long )end) {
#line 1763
      if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr] == 10) {
#line 1764
        ptr ++;
      }
    }
#line 1765
    pos->columnNumber = (XML_Size )-1;
#line 1766
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 1768
    ptr ++;
#line 1769
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 1771
    (pos->columnNumber) ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1773
  return;
}
}
#line 321 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmltok.c"
static void utf8_toUtf8___0(ENCODING const   *enc , char const   **fromP , char const   *fromLim ,
                            char **toP , char const   *toLim ) 
{ 
  char *to ;
  char const   *from ;

  {
#line 328
  if (fromLim - *fromP > toLim - (char const   *)*toP) {
#line 330
    fromLim = *fromP + (toLim - (char const   *)*toP);
    {
#line 330
    while (1) {
      while_continue: /* CIL Label */ ;
#line 330
      if (! ((unsigned long )fromLim > (unsigned long )*fromP)) {
#line 330
        goto while_break;
      }
#line 331
      if (((int )((unsigned char )*(fromLim + -1)) & 192) != 128) {
#line 332
        goto while_break;
      }
#line 330
      fromLim --;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 334
  to = *toP;
#line 334
  from = *fromP;
  {
#line 334
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 334
    if (! ((unsigned long )from != (unsigned long )fromLim)) {
#line 334
      goto while_break___0;
    }
#line 335
    *to = (char )*from;
#line 334
    from ++;
#line 334
    to ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 336
  *fromP = from;
#line 337
  *toP = to;
#line 338
  return;
}
}
#line 340 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmltok.c"
static void utf8_toUtf16___0(ENCODING const   *enc , char const   **fromP , char const   *fromLim ,
                             unsigned short **toP , unsigned short const   *toLim ) 
{ 
  unsigned short *to ;
  char const   *from ;
  unsigned short *tmp ;
  unsigned short *tmp___0 ;
  unsigned long n ;
  unsigned short *tmp___1 ;
  char const   *tmp___2 ;

  {
#line 345
  to = *toP;
#line 346
  from = *fromP;
  {
#line 347
  while (1) {
    while_continue: /* CIL Label */ ;
#line 347
    if ((unsigned long )from != (unsigned long )fromLim) {
#line 347
      if (! ((unsigned long )to != (unsigned long )toLim)) {
#line 347
        goto while_break;
      }
    } else {
#line 347
      goto while_break;
    }
    {
#line 349
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*from] == 5) {
#line 349
      goto case_5;
    }
#line 353
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*from] == 6) {
#line 353
      goto case_6;
    }
#line 358
    if ((int )((struct normal_encoding *)enc)->type[(unsigned char )*from] == 7) {
#line 358
      goto case_7;
    }
#line 372
    goto switch_default;
    case_5: /* CIL Label */ 
#line 350
    tmp = to;
#line 350
    to ++;
#line 350
    *tmp = (unsigned short )((((int const   )*(from + 0) & 31) << 6) | ((int const   )*(from + 1) & 63));
#line 351
    from += 2;
#line 352
    goto switch_break;
    case_6: /* CIL Label */ 
#line 354
    tmp___0 = to;
#line 354
    to ++;
#line 354
    *tmp___0 = (unsigned short )(((((int const   )*(from + 0) & 15) << 12) | (((int const   )*(from + 1) & 63) << 6)) | ((int const   )*(from + 2) & 63));
#line 356
    from += 3;
#line 357
    goto switch_break;
    case_7: /* CIL Label */ 
#line 361
    if ((unsigned long )(to + 1) == (unsigned long )toLim) {
#line 362
      goto after;
    }
#line 363
    n = (unsigned long )((((((int const   )*(from + 0) & 7) << 18) | (((int const   )*(from + 1) & 63) << 12)) | (((int const   )*(from + 2) & 63) << 6)) | ((int const   )*(from + 3) & 63));
#line 365
    n -= 65536UL;
#line 366
    *(to + 0) = (unsigned short )((n >> 10) | 55296UL);
#line 367
    *(to + 1) = (unsigned short )((n & 1023UL) | 56320UL);
#line 368
    to += 2;
#line 369
    from += 4;
#line 371
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 373
    tmp___1 = to;
#line 373
    to ++;
#line 373
    tmp___2 = from;
#line 373
    from ++;
#line 373
    *tmp___1 = (unsigned short )*tmp___2;
#line 374
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
  after: 
#line 378
  *fromP = from;
#line 379
  *toP = to;
#line 380
  return;
}
}
#line 383 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmltok.c"
static struct normal_encoding  const  utf8_encoding_ns___0  = 
#line 383
     {{{& normal_prologTok___0, & normal_contentTok___0, & normal_cdataSectionTok___0,
      & normal_ignoreSectionTok___0}, {& normal_attributeValueTok___0, & normal_entityValueTok___0},
     & normal_sameName___0, & normal_nameMatchesAscii___0, & normal_nameLength___0,
     & normal_skipS___0, & normal_getAtts___0, & normal_charRefNumber___0, & normal_predefinedEntityName___0,
     & normal_updatePosition___0, & normal_isPublicId___0, & utf8_toUtf8___0, & utf8_toUtf16___0,
     1, (char)1, (char)0}, {(unsigned char)0, (unsigned char)0, (unsigned char)0,
                            (unsigned char)0, (unsigned char)0, (unsigned char)0,
                            (unsigned char)0, (unsigned char)0, (unsigned char)0,
                            (unsigned char)21, (unsigned char)10, (unsigned char)0,
                            (unsigned char)0, (unsigned char)9, (unsigned char)0,
                            (unsigned char)0, (unsigned char)0, (unsigned char)0,
                            (unsigned char)0, (unsigned char)0, (unsigned char)0,
                            (unsigned char)0, (unsigned char)0, (unsigned char)0,
                            (unsigned char)0, (unsigned char)0, (unsigned char)0,
                            (unsigned char)0, (unsigned char)0, (unsigned char)0,
                            (unsigned char)0, (unsigned char)0, (unsigned char)21,
                            (unsigned char)16, (unsigned char)12, (unsigned char)19,
                            (unsigned char)28, (unsigned char)30, (unsigned char)3,
                            (unsigned char)13, (unsigned char)31, (unsigned char)32,
                            (unsigned char)33, (unsigned char)34, (unsigned char)35,
                            (unsigned char)27, (unsigned char)26, (unsigned char)17,
                            (unsigned char)25, (unsigned char)25, (unsigned char)25,
                            (unsigned char)25, (unsigned char)25, (unsigned char)25,
                            (unsigned char)25, (unsigned char)25, (unsigned char)25,
                            (unsigned char)25, (unsigned char)23, (unsigned char)18,
                            (unsigned char)2, (unsigned char)14, (unsigned char)11,
                            (unsigned char)15, (unsigned char)28, (unsigned char)24,
                            (unsigned char)24, (unsigned char)24, (unsigned char)24,
                            (unsigned char)24, (unsigned char)24, (unsigned char)22,
                            (unsigned char)22, (unsigned char)22, (unsigned char)22,
                            (unsigned char)22, (unsigned char)22, (unsigned char)22,
                            (unsigned char)22, (unsigned char)22, (unsigned char)22,
                            (unsigned char)22, (unsigned char)22, (unsigned char)22,
                            (unsigned char)22, (unsigned char)22, (unsigned char)22,
                            (unsigned char)22, (unsigned char)22, (unsigned char)22,
                            (unsigned char)22, (unsigned char)20, (unsigned char)28,
                            (unsigned char)4, (unsigned char)28, (unsigned char)22,
                            (unsigned char)28, (unsigned char)24, (unsigned char)24,
                            (unsigned char)24, (unsigned char)24, (unsigned char)24,
                            (unsigned char)24, (unsigned char)22, (unsigned char)22,
                            (unsigned char)22, (unsigned char)22, (unsigned char)22,
                            (unsigned char)22, (unsigned char)22, (unsigned char)22,
                            (unsigned char)22, (unsigned char)22, (unsigned char)22,
                            (unsigned char)22, (unsigned char)22, (unsigned char)22,
                            (unsigned char)22, (unsigned char)22, (unsigned char)22,
                            (unsigned char)22, (unsigned char)22, (unsigned char)22,
                            (unsigned char)28, (unsigned char)36, (unsigned char)28,
                            (unsigned char)28, (unsigned char)28, (unsigned char)8,
                            (unsigned char)8, (unsigned char)8, (unsigned char)8,
                            (unsigned char)8, (unsigned char)8, (unsigned char)8,
                            (unsigned char)8, (unsigned char)8, (unsigned char)8,
                            (unsigned char)8, (unsigned char)8, (unsigned char)8,
                            (unsigned char)8, (unsigned char)8, (unsigned char)8,
                            (unsigned char)8, (unsigned char)8, (unsigned char)8,
                            (unsigned char)8, (unsigned char)8, (unsigned char)8,
                            (unsigned char)8, (unsigned char)8, (unsigned char)8,
                            (unsigned char)8, (unsigned char)8, (unsigned char)8,
                            (unsigned char)8, (unsigned char)8, (unsigned char)8,
                            (unsigned char)8, (unsigned char)8, (unsigned char)8,
                            (unsigned char)8, (unsigned char)8, (unsigned char)8,
                            (unsigned char)8, (unsigned char)8, (unsigned char)8,
                            (unsigned char)8, (unsigned char)8, (unsigned char)8,
                            (unsigned char)8, (unsigned char)8, (unsigned char)8,
                            (unsigned char)8, (unsigned char)8, (unsigned char)8,
                            (unsigned char)8, (unsigned char)8, (unsigned char)8,
                            (unsigned char)8, (unsigned char)8, (unsigned char)8,
                            (unsigned char)8, (unsigned char)8, (unsigned char)8,
                            (unsigned char)8, (unsigned char)8, (unsigned char)8,
                            (unsigned char)8, (unsigned char)8, (unsigned char)8,
                            (unsigned char)5, (unsigned char)5, (unsigned char)5,
                            (unsigned char)5, (unsigned char)5, (unsigned char)5,
                            (unsigned char)5, (unsigned char)5, (unsigned char)5,
                            (unsigned char)5, (unsigned char)5, (unsigned char)5,
                            (unsigned char)5, (unsigned char)5, (unsigned char)5,
                            (unsigned char)5, (unsigned char)5, (unsigned char)5,
                            (unsigned char)5, (unsigned char)5, (unsigned char)5,
                            (unsigned char)5, (unsigned char)5, (unsigned char)5,
                            (unsigned char)5, (unsigned char)5, (unsigned char)5,
                            (unsigned char)5, (unsigned char)5, (unsigned char)5,
                            (unsigned char)5, (unsigned char)5, (unsigned char)6,
                            (unsigned char)6, (unsigned char)6, (unsigned char)6,
                            (unsigned char)6, (unsigned char)6, (unsigned char)6,
                            (unsigned char)6, (unsigned char)6, (unsigned char)6,
                            (unsigned char)6, (unsigned char)6, (unsigned char)6,
                            (unsigned char)6, (unsigned char)6, (unsigned char)6,
                            (unsigned char)7, (unsigned char)7, (unsigned char)7,
                            (unsigned char)7, (unsigned char)7, (unsigned char)0,
                            (unsigned char)0, (unsigned char)0, (unsigned char)0,
                            (unsigned char)0, (unsigned char)0, (unsigned char)0,
                            (unsigned char)0, (unsigned char)0, (unsigned char)1,
                            (unsigned char)1}, & utf8_isName2___0, & utf8_isName3___0,
    & isNever___0, & utf8_isNmstrt2___0, & utf8_isNmstrt3___0, & isNever___0, & utf8_isInvalid2___0,
    & utf8_isInvalid3___0, & utf8_isInvalid4___0};
#line 393 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmltok.c"
static struct normal_encoding  const  utf8_encoding___0  = 
#line 393
     {{{& normal_prologTok___0, & normal_contentTok___0, & normal_cdataSectionTok___0,
      & normal_ignoreSectionTok___0}, {& normal_attributeValueTok___0, & normal_entityValueTok___0},
     & normal_sameName___0, & normal_nameMatchesAscii___0, & normal_nameLength___0,
     & normal_skipS___0, & normal_getAtts___0, & normal_charRefNumber___0, & normal_predefinedEntityName___0,
     & normal_updatePosition___0, & normal_isPublicId___0, & utf8_toUtf8___0, & utf8_toUtf16___0,
     1, (char)1, (char)0}, {(unsigned char)0, (unsigned char)0, (unsigned char)0,
                            (unsigned char)0, (unsigned char)0, (unsigned char)0,
                            (unsigned char)0, (unsigned char)0, (unsigned char)0,
                            (unsigned char)21, (unsigned char)10, (unsigned char)0,
                            (unsigned char)0, (unsigned char)9, (unsigned char)0,
                            (unsigned char)0, (unsigned char)0, (unsigned char)0,
                            (unsigned char)0, (unsigned char)0, (unsigned char)0,
                            (unsigned char)0, (unsigned char)0, (unsigned char)0,
                            (unsigned char)0, (unsigned char)0, (unsigned char)0,
                            (unsigned char)0, (unsigned char)0, (unsigned char)0,
                            (unsigned char)0, (unsigned char)0, (unsigned char)21,
                            (unsigned char)16, (unsigned char)12, (unsigned char)19,
                            (unsigned char)28, (unsigned char)30, (unsigned char)3,
                            (unsigned char)13, (unsigned char)31, (unsigned char)32,
                            (unsigned char)33, (unsigned char)34, (unsigned char)35,
                            (unsigned char)27, (unsigned char)26, (unsigned char)17,
                            (unsigned char)25, (unsigned char)25, (unsigned char)25,
                            (unsigned char)25, (unsigned char)25, (unsigned char)25,
                            (unsigned char)25, (unsigned char)25, (unsigned char)25,
                            (unsigned char)25, (unsigned char)22, (unsigned char)18,
                            (unsigned char)2, (unsigned char)14, (unsigned char)11,
                            (unsigned char)15, (unsigned char)28, (unsigned char)24,
                            (unsigned char)24, (unsigned char)24, (unsigned char)24,
                            (unsigned char)24, (unsigned char)24, (unsigned char)22,
                            (unsigned char)22, (unsigned char)22, (unsigned char)22,
                            (unsigned char)22, (unsigned char)22, (unsigned char)22,
                            (unsigned char)22, (unsigned char)22, (unsigned char)22,
                            (unsigned char)22, (unsigned char)22, (unsigned char)22,
                            (unsigned char)22, (unsigned char)22, (unsigned char)22,
                            (unsigned char)22, (unsigned char)22, (unsigned char)22,
                            (unsigned char)22, (unsigned char)20, (unsigned char)28,
                            (unsigned char)4, (unsigned char)28, (unsigned char)22,
                            (unsigned char)28, (unsigned char)24, (unsigned char)24,
                            (unsigned char)24, (unsigned char)24, (unsigned char)24,
                            (unsigned char)24, (unsigned char)22, (unsigned char)22,
                            (unsigned char)22, (unsigned char)22, (unsigned char)22,
                            (unsigned char)22, (unsigned char)22, (unsigned char)22,
                            (unsigned char)22, (unsigned char)22, (unsigned char)22,
                            (unsigned char)22, (unsigned char)22, (unsigned char)22,
                            (unsigned char)22, (unsigned char)22, (unsigned char)22,
                            (unsigned char)22, (unsigned char)22, (unsigned char)22,
                            (unsigned char)28, (unsigned char)36, (unsigned char)28,
                            (unsigned char)28, (unsigned char)28, (unsigned char)8,
                            (unsigned char)8, (unsigned char)8, (unsigned char)8,
                            (unsigned char)8, (unsigned char)8, (unsigned char)8,
                            (unsigned char)8, (unsigned char)8, (unsigned char)8,
                            (unsigned char)8, (unsigned char)8, (unsigned char)8,
                            (unsigned char)8, (unsigned char)8, (unsigned char)8,
                            (unsigned char)8, (unsigned char)8, (unsigned char)8,
                            (unsigned char)8, (unsigned char)8, (unsigned char)8,
                            (unsigned char)8, (unsigned char)8, (unsigned char)8,
                            (unsigned char)8, (unsigned char)8, (unsigned char)8,
                            (unsigned char)8, (unsigned char)8, (unsigned char)8,
                            (unsigned char)8, (unsigned char)8, (unsigned char)8,
                            (unsigned char)8, (unsigned char)8, (unsigned char)8,
                            (unsigned char)8, (unsigned char)8, (unsigned char)8,
                            (unsigned char)8, (unsigned char)8, (unsigned char)8,
                            (unsigned char)8, (unsigned char)8, (unsigned char)8,
                            (unsigned char)8, (unsigned char)8, (unsigned char)8,
                            (unsigned char)8, (unsigned char)8, (unsigned char)8,
                            (unsigned char)8, (unsigned char)8, (unsigned char)8,
                            (unsigned char)8, (unsigned char)8, (unsigned char)8,
                            (unsigned char)8, (unsigned char)8, (unsigned char)8,
                            (unsigned char)8, (unsigned char)8, (unsigned char)8,
                            (unsigned char)5, (unsigned char)5, (unsigned char)5,
                            (unsigned char)5, (unsigned char)5, (unsigned char)5,
                            (unsigned char)5, (unsigned char)5, (unsigned char)5,
                            (unsigned char)5, (unsigned char)5, (unsigned char)5,
                            (unsigned char)5, (unsigned char)5, (unsigned char)5,
                            (unsigned char)5, (unsigned char)5, (unsigned char)5,
                            (unsigned char)5, (unsigned char)5, (unsigned char)5,
                            (unsigned char)5, (unsigned char)5, (unsigned char)5,
                            (unsigned char)5, (unsigned char)5, (unsigned char)5,
                            (unsigned char)5, (unsigned char)5, (unsigned char)5,
                            (unsigned char)5, (unsigned char)5, (unsigned char)6,
                            (unsigned char)6, (unsigned char)6, (unsigned char)6,
                            (unsigned char)6, (unsigned char)6, (unsigned char)6,
                            (unsigned char)6, (unsigned char)6, (unsigned char)6,
                            (unsigned char)6, (unsigned char)6, (unsigned char)6,
                            (unsigned char)6, (unsigned char)6, (unsigned char)6,
                            (unsigned char)7, (unsigned char)7, (unsigned char)7,
                            (unsigned char)7, (unsigned char)7, (unsigned char)0,
                            (unsigned char)0, (unsigned char)0, (unsigned char)0,
                            (unsigned char)0, (unsigned char)0, (unsigned char)0,
                            (unsigned char)0, (unsigned char)0, (unsigned char)1,
                            (unsigned char)1}, & utf8_isName2___0, & utf8_isName3___0,
    & isNever___0, & utf8_isNmstrt2___0, & utf8_isNmstrt3___0, & isNever___0, & utf8_isInvalid2___0,
    & utf8_isInvalid3___0, & utf8_isInvalid4___0};
#line 406 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmltok.c"
static struct normal_encoding  const  internal_utf8_encoding_ns___0  = 
#line 406
     {{{& normal_prologTok___0, & normal_contentTok___0, & normal_cdataSectionTok___0,
      & normal_ignoreSectionTok___0}, {& normal_attributeValueTok___0, & normal_entityValueTok___0},
     & normal_sameName___0, & normal_nameMatchesAscii___0, & normal_nameLength___0,
     & normal_skipS___0, & normal_getAtts___0, & normal_charRefNumber___0, & normal_predefinedEntityName___0,
     & normal_updatePosition___0, & normal_isPublicId___0, & utf8_toUtf8___0, & utf8_toUtf16___0,
     1, (char)1, (char)0}, {(unsigned char)0, (unsigned char)0, (unsigned char)0,
                            (unsigned char)0, (unsigned char)0, (unsigned char)0,
                            (unsigned char)0, (unsigned char)0, (unsigned char)0,
                            (unsigned char)21, (unsigned char)10, (unsigned char)0,
                            (unsigned char)0, (unsigned char)21, (unsigned char)0,
                            (unsigned char)0, (unsigned char)0, (unsigned char)0,
                            (unsigned char)0, (unsigned char)0, (unsigned char)0,
                            (unsigned char)0, (unsigned char)0, (unsigned char)0,
                            (unsigned char)0, (unsigned char)0, (unsigned char)0,
                            (unsigned char)0, (unsigned char)0, (unsigned char)0,
                            (unsigned char)0, (unsigned char)0, (unsigned char)21,
                            (unsigned char)16, (unsigned char)12, (unsigned char)19,
                            (unsigned char)28, (unsigned char)30, (unsigned char)3,
                            (unsigned char)13, (unsigned char)31, (unsigned char)32,
                            (unsigned char)33, (unsigned char)34, (unsigned char)35,
                            (unsigned char)27, (unsigned char)26, (unsigned char)17,
                            (unsigned char)25, (unsigned char)25, (unsigned char)25,
                            (unsigned char)25, (unsigned char)25, (unsigned char)25,
                            (unsigned char)25, (unsigned char)25, (unsigned char)25,
                            (unsigned char)25, (unsigned char)23, (unsigned char)18,
                            (unsigned char)2, (unsigned char)14, (unsigned char)11,
                            (unsigned char)15, (unsigned char)28, (unsigned char)24,
                            (unsigned char)24, (unsigned char)24, (unsigned char)24,
                            (unsigned char)24, (unsigned char)24, (unsigned char)22,
                            (unsigned char)22, (unsigned char)22, (unsigned char)22,
                            (unsigned char)22, (unsigned char)22, (unsigned char)22,
                            (unsigned char)22, (unsigned char)22, (unsigned char)22,
                            (unsigned char)22, (unsigned char)22, (unsigned char)22,
                            (unsigned char)22, (unsigned char)22, (unsigned char)22,
                            (unsigned char)22, (unsigned char)22, (unsigned char)22,
                            (unsigned char)22, (unsigned char)20, (unsigned char)28,
                            (unsigned char)4, (unsigned char)28, (unsigned char)22,
                            (unsigned char)28, (unsigned char)24, (unsigned char)24,
                            (unsigned char)24, (unsigned char)24, (unsigned char)24,
                            (unsigned char)24, (unsigned char)22, (unsigned char)22,
                            (unsigned char)22, (unsigned char)22, (unsigned char)22,
                            (unsigned char)22, (unsigned char)22, (unsigned char)22,
                            (unsigned char)22, (unsigned char)22, (unsigned char)22,
                            (unsigned char)22, (unsigned char)22, (unsigned char)22,
                            (unsigned char)22, (unsigned char)22, (unsigned char)22,
                            (unsigned char)22, (unsigned char)22, (unsigned char)22,
                            (unsigned char)28, (unsigned char)36, (unsigned char)28,
                            (unsigned char)28, (unsigned char)28, (unsigned char)8,
                            (unsigned char)8, (unsigned char)8, (unsigned char)8,
                            (unsigned char)8, (unsigned char)8, (unsigned char)8,
                            (unsigned char)8, (unsigned char)8, (unsigned char)8,
                            (unsigned char)8, (unsigned char)8, (unsigned char)8,
                            (unsigned char)8, (unsigned char)8, (unsigned char)8,
                            (unsigned char)8, (unsigned char)8, (unsigned char)8,
                            (unsigned char)8, (unsigned char)8, (unsigned char)8,
                            (unsigned char)8, (unsigned char)8, (unsigned char)8,
                            (unsigned char)8, (unsigned char)8, (unsigned char)8,
                            (unsigned char)8, (unsigned char)8, (unsigned char)8,
                            (unsigned char)8, (unsigned char)8, (unsigned char)8,
                            (unsigned char)8, (unsigned char)8, (unsigned char)8,
                            (unsigned char)8, (unsigned char)8, (unsigned char)8,
                            (unsigned char)8, (unsigned char)8, (unsigned char)8,
                            (unsigned char)8, (unsigned char)8, (unsigned char)8,
                            (unsigned char)8, (unsigned char)8, (unsigned char)8,
                            (unsigned char)8, (unsigned char)8, (unsigned char)8,
                            (unsigned char)8, (unsigned char)8, (unsigned char)8,
                            (unsigned char)8, (unsigned char)8, (unsigned char)8,
                            (unsigned char)8, (unsigned char)8, (unsigned char)8,
                            (unsigned char)8, (unsigned char)8, (unsigned char)8,
                            (unsigned char)5, (unsigned char)5, (unsigned char)5,
                            (unsigned char)5, (unsigned char)5, (unsigned char)5,
                            (unsigned char)5, (unsigned char)5, (unsigned char)5,
                            (unsigned char)5, (unsigned char)5, (unsigned char)5,
                            (unsigned char)5, (unsigned char)5, (unsigned char)5,
                            (unsigned char)5, (unsigned char)5, (unsigned char)5,
                            (unsigned char)5, (unsigned char)5, (unsigned char)5,
                            (unsigned char)5, (unsigned char)5, (unsigned char)5,
                            (unsigned char)5, (unsigned char)5, (unsigned char)5,
                            (unsigned char)5, (unsigned char)5, (unsigned char)5,
                            (unsigned char)5, (unsigned char)5, (unsigned char)6,
                            (unsigned char)6, (unsigned char)6, (unsigned char)6,
                            (unsigned char)6, (unsigned char)6, (unsigned char)6,
                            (unsigned char)6, (unsigned char)6, (unsigned char)6,
                            (unsigned char)6, (unsigned char)6, (unsigned char)6,
                            (unsigned char)6, (unsigned char)6, (unsigned char)6,
                            (unsigned char)7, (unsigned char)7, (unsigned char)7,
                            (unsigned char)7, (unsigned char)7, (unsigned char)0,
                            (unsigned char)0, (unsigned char)0, (unsigned char)0,
                            (unsigned char)0, (unsigned char)0, (unsigned char)0,
                            (unsigned char)0, (unsigned char)0, (unsigned char)1,
                            (unsigned char)1}, & utf8_isName2___0, & utf8_isName3___0,
    & isNever___0, & utf8_isNmstrt2___0, & utf8_isNmstrt3___0, & isNever___0, & utf8_isInvalid2___0,
    & utf8_isInvalid3___0, & utf8_isInvalid4___0};
#line 417 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmltok.c"
static struct normal_encoding  const  internal_utf8_encoding___0  = 
#line 417
     {{{& normal_prologTok___0, & normal_contentTok___0, & normal_cdataSectionTok___0,
      & normal_ignoreSectionTok___0}, {& normal_attributeValueTok___0, & normal_entityValueTok___0},
     & normal_sameName___0, & normal_nameMatchesAscii___0, & normal_nameLength___0,
     & normal_skipS___0, & normal_getAtts___0, & normal_charRefNumber___0, & normal_predefinedEntityName___0,
     & normal_updatePosition___0, & normal_isPublicId___0, & utf8_toUtf8___0, & utf8_toUtf16___0,
     1, (char)1, (char)0}, {(unsigned char)0, (unsigned char)0, (unsigned char)0,
                            (unsigned char)0, (unsigned char)0, (unsigned char)0,
                            (unsigned char)0, (unsigned char)0, (unsigned char)0,
                            (unsigned char)21, (unsigned char)10, (unsigned char)0,
                            (unsigned char)0, (unsigned char)21, (unsigned char)0,
                            (unsigned char)0, (unsigned char)0, (unsigned char)0,
                            (unsigned char)0, (unsigned char)0, (unsigned char)0,
                            (unsigned char)0, (unsigned char)0, (unsigned char)0,
                            (unsigned char)0, (unsigned char)0, (unsigned char)0,
                            (unsigned char)0, (unsigned char)0, (unsigned char)0,
                            (unsigned char)0, (unsigned char)0, (unsigned char)21,
                            (unsigned char)16, (unsigned char)12, (unsigned char)19,
                            (unsigned char)28, (unsigned char)30, (unsigned char)3,
                            (unsigned char)13, (unsigned char)31, (unsigned char)32,
                            (unsigned char)33, (unsigned char)34, (unsigned char)35,
                            (unsigned char)27, (unsigned char)26, (unsigned char)17,
                            (unsigned char)25, (unsigned char)25, (unsigned char)25,
                            (unsigned char)25, (unsigned char)25, (unsigned char)25,
                            (unsigned char)25, (unsigned char)25, (unsigned char)25,
                            (unsigned char)25, (unsigned char)22, (unsigned char)18,
                            (unsigned char)2, (unsigned char)14, (unsigned char)11,
                            (unsigned char)15, (unsigned char)28, (unsigned char)24,
                            (unsigned char)24, (unsigned char)24, (unsigned char)24,
                            (unsigned char)24, (unsigned char)24, (unsigned char)22,
                            (unsigned char)22, (unsigned char)22, (unsigned char)22,
                            (unsigned char)22, (unsigned char)22, (unsigned char)22,
                            (unsigned char)22, (unsigned char)22, (unsigned char)22,
                            (unsigned char)22, (unsigned char)22, (unsigned char)22,
                            (unsigned char)22, (unsigned char)22, (unsigned char)22,
                            (unsigned char)22, (unsigned char)22, (unsigned char)22,
                            (unsigned char)22, (unsigned char)20, (unsigned char)28,
                            (unsigned char)4, (unsigned char)28, (unsigned char)22,
                            (unsigned char)28, (unsigned char)24, (unsigned char)24,
                            (unsigned char)24, (unsigned char)24, (unsigned char)24,
                            (unsigned char)24, (unsigned char)22, (unsigned char)22,
                            (unsigned char)22, (unsigned char)22, (unsigned char)22,
                            (unsigned char)22, (unsigned char)22, (unsigned char)22,
                            (unsigned char)22, (unsigned char)22, (unsigned char)22,
                            (unsigned char)22, (unsigned char)22, (unsigned char)22,
                            (unsigned char)22, (unsigned char)22, (unsigned char)22,
                            (unsigned char)22, (unsigned char)22, (unsigned char)22,
                            (unsigned char)28, (unsigned char)36, (unsigned char)28,
                            (unsigned char)28, (unsigned char)28, (unsigned char)8,
                            (unsigned char)8, (unsigned char)8, (unsigned char)8,
                            (unsigned char)8, (unsigned char)8, (unsigned char)8,
                            (unsigned char)8, (unsigned char)8, (unsigned char)8,
                            (unsigned char)8, (unsigned char)8, (unsigned char)8,
                            (unsigned char)8, (unsigned char)8, (unsigned char)8,
                            (unsigned char)8, (unsigned char)8, (unsigned char)8,
                            (unsigned char)8, (unsigned char)8, (unsigned char)8,
                            (unsigned char)8, (unsigned char)8, (unsigned char)8,
                            (unsigned char)8, (unsigned char)8, (unsigned char)8,
                            (unsigned char)8, (unsigned char)8, (unsigned char)8,
                            (unsigned char)8, (unsigned char)8, (unsigned char)8,
                            (unsigned char)8, (unsigned char)8, (unsigned char)8,
                            (unsigned char)8, (unsigned char)8, (unsigned char)8,
                            (unsigned char)8, (unsigned char)8, (unsigned char)8,
                            (unsigned char)8, (unsigned char)8, (unsigned char)8,
                            (unsigned char)8, (unsigned char)8, (unsigned char)8,
                            (unsigned char)8, (unsigned char)8, (unsigned char)8,
                            (unsigned char)8, (unsigned char)8, (unsigned char)8,
                            (unsigned char)8, (unsigned char)8, (unsigned char)8,
                            (unsigned char)8, (unsigned char)8, (unsigned char)8,
                            (unsigned char)8, (unsigned char)8, (unsigned char)8,
                            (unsigned char)5, (unsigned char)5, (unsigned char)5,
                            (unsigned char)5, (unsigned char)5, (unsigned char)5,
                            (unsigned char)5, (unsigned char)5, (unsigned char)5,
                            (unsigned char)5, (unsigned char)5, (unsigned char)5,
                            (unsigned char)5, (unsigned char)5, (unsigned char)5,
                            (unsigned char)5, (unsigned char)5, (unsigned char)5,
                            (unsigned char)5, (unsigned char)5, (unsigned char)5,
                            (unsigned char)5, (unsigned char)5, (unsigned char)5,
                            (unsigned char)5, (unsigned char)5, (unsigned char)5,
                            (unsigned char)5, (unsigned char)5, (unsigned char)5,
                            (unsigned char)5, (unsigned char)5, (unsigned char)6,
                            (unsigned char)6, (unsigned char)6, (unsigned char)6,
                            (unsigned char)6, (unsigned char)6, (unsigned char)6,
                            (unsigned char)6, (unsigned char)6, (unsigned char)6,
                            (unsigned char)6, (unsigned char)6, (unsigned char)6,
                            (unsigned char)6, (unsigned char)6, (unsigned char)6,
                            (unsigned char)7, (unsigned char)7, (unsigned char)7,
                            (unsigned char)7, (unsigned char)7, (unsigned char)0,
                            (unsigned char)0, (unsigned char)0, (unsigned char)0,
                            (unsigned char)0, (unsigned char)0, (unsigned char)0,
                            (unsigned char)0, (unsigned char)0, (unsigned char)1,
                            (unsigned char)1}, & utf8_isName2___0, & utf8_isName3___0,
    & isNever___0, & utf8_isNmstrt2___0, & utf8_isNmstrt3___0, & isNever___0, & utf8_isInvalid2___0,
    & utf8_isInvalid3___0, & utf8_isInvalid4___0};
#line 428 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmltok.c"
static void latin1_toUtf8___0(ENCODING const   *enc , char const   **fromP , char const   *fromLim ,
                              char **toP , char const   *toLim ) 
{ 
  unsigned char c___0 ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char const   *tmp___2 ;

  {
  {
#line 433
  while (1) {
    while_continue: /* CIL Label */ ;
#line 435
    if ((unsigned long )*fromP == (unsigned long )fromLim) {
#line 436
      goto while_break;
    }
#line 437
    c___0 = (unsigned char )*(*fromP);
#line 438
    if ((int )c___0 & 128) {
#line 439
      if (toLim - (char const   *)*toP < 2L) {
#line 440
        goto while_break;
      }
#line 441
      tmp = *toP;
#line 441
      (*toP) ++;
#line 441
      *tmp = (char )(((int )c___0 >> 6) | 192);
#line 442
      tmp___0 = *toP;
#line 442
      (*toP) ++;
#line 442
      *tmp___0 = (char )(((int )c___0 & 63) | 128);
#line 443
      (*fromP) ++;
    } else {
#line 446
      if ((unsigned long )*toP == (unsigned long )toLim) {
#line 447
        goto while_break;
      }
#line 448
      tmp___1 = *toP;
#line 448
      (*toP) ++;
#line 448
      tmp___2 = *fromP;
#line 448
      (*fromP) ++;
#line 448
      *tmp___1 = (char )*tmp___2;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 451
  return;
}
}
#line 453 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmltok.c"
static void latin1_toUtf16___0(ENCODING const   *enc , char const   **fromP , char const   *fromLim ,
                               unsigned short **toP , unsigned short const   *toLim ) 
{ 
  unsigned short *tmp ;
  char const   *tmp___0 ;

  {
  {
#line 458
  while (1) {
    while_continue: /* CIL Label */ ;
#line 458
    if ((unsigned long )*fromP != (unsigned long )fromLim) {
#line 458
      if (! ((unsigned long )*toP != (unsigned long )toLim)) {
#line 458
        goto while_break;
      }
    } else {
#line 458
      goto while_break;
    }
#line 459
    tmp = *toP;
#line 459
    (*toP) ++;
#line 459
    tmp___0 = *fromP;
#line 459
    (*fromP) ++;
#line 459
    *tmp = (unsigned short )((unsigned char )*tmp___0);
  }
  while_break: /* CIL Label */ ;
  }
#line 460
  return;
}
}
#line 464 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmltok.c"
static struct normal_encoding  const  latin1_encoding_ns___0  = 
#line 464
     {{{& normal_prologTok___0, & normal_contentTok___0, & normal_cdataSectionTok___0,
      & normal_ignoreSectionTok___0}, {& normal_attributeValueTok___0, & normal_entityValueTok___0},
     & normal_sameName___0, & normal_nameMatchesAscii___0, & normal_nameLength___0,
     & normal_skipS___0, & normal_getAtts___0, & normal_charRefNumber___0, & normal_predefinedEntityName___0,
     & normal_updatePosition___0, & normal_isPublicId___0, & latin1_toUtf8___0, & latin1_toUtf16___0,
     1, (char)0, (char)0}, {(unsigned char)0, (unsigned char)0, (unsigned char)0,
                            (unsigned char)0, (unsigned char)0, (unsigned char)0,
                            (unsigned char)0, (unsigned char)0, (unsigned char)0,
                            (unsigned char)21, (unsigned char)10, (unsigned char)0,
                            (unsigned char)0, (unsigned char)9, (unsigned char)0,
                            (unsigned char)0, (unsigned char)0, (unsigned char)0,
                            (unsigned char)0, (unsigned char)0, (unsigned char)0,
                            (unsigned char)0, (unsigned char)0, (unsigned char)0,
                            (unsigned char)0, (unsigned char)0, (unsigned char)0,
                            (unsigned char)0, (unsigned char)0, (unsigned char)0,
                            (unsigned char)0, (unsigned char)0, (unsigned char)21,
                            (unsigned char)16, (unsigned char)12, (unsigned char)19,
                            (unsigned char)28, (unsigned char)30, (unsigned char)3,
                            (unsigned char)13, (unsigned char)31, (unsigned char)32,
                            (unsigned char)33, (unsigned char)34, (unsigned char)35,
                            (unsigned char)27, (unsigned char)26, (unsigned char)17,
                            (unsigned char)25, (unsigned char)25, (unsigned char)25,
                            (unsigned char)25, (unsigned char)25, (unsigned char)25,
                            (unsigned char)25, (unsigned char)25, (unsigned char)25,
                            (unsigned char)25, (unsigned char)23, (unsigned char)18,
                            (unsigned char)2, (unsigned char)14, (unsigned char)11,
                            (unsigned char)15, (unsigned char)28, (unsigned char)24,
                            (unsigned char)24, (unsigned char)24, (unsigned char)24,
                            (unsigned char)24, (unsigned char)24, (unsigned char)22,
                            (unsigned char)22, (unsigned char)22, (unsigned char)22,
                            (unsigned char)22, (unsigned char)22, (unsigned char)22,
                            (unsigned char)22, (unsigned char)22, (unsigned char)22,
                            (unsigned char)22, (unsigned char)22, (unsigned char)22,
                            (unsigned char)22, (unsigned char)22, (unsigned char)22,
                            (unsigned char)22, (unsigned char)22, (unsigned char)22,
                            (unsigned char)22, (unsigned char)20, (unsigned char)28,
                            (unsigned char)4, (unsigned char)28, (unsigned char)22,
                            (unsigned char)28, (unsigned char)24, (unsigned char)24,
                            (unsigned char)24, (unsigned char)24, (unsigned char)24,
                            (unsigned char)24, (unsigned char)22, (unsigned char)22,
                            (unsigned char)22, (unsigned char)22, (unsigned char)22,
                            (unsigned char)22, (unsigned char)22, (unsigned char)22,
                            (unsigned char)22, (unsigned char)22, (unsigned char)22,
                            (unsigned char)22, (unsigned char)22, (unsigned char)22,
                            (unsigned char)22, (unsigned char)22, (unsigned char)22,
                            (unsigned char)22, (unsigned char)22, (unsigned char)22,
                            (unsigned char)28, (unsigned char)36, (unsigned char)28,
                            (unsigned char)28, (unsigned char)28, (unsigned char)28,
                            (unsigned char)28, (unsigned char)28, (unsigned char)28,
                            (unsigned char)28, (unsigned char)28, (unsigned char)28,
                            (unsigned char)28, (unsigned char)28, (unsigned char)28,
                            (unsigned char)28, (unsigned char)28, (unsigned char)28,
                            (unsigned char)28, (unsigned char)28, (unsigned char)28,
                            (unsigned char)28, (unsigned char)28, (unsigned char)28,
                            (unsigned char)28, (unsigned char)28, (unsigned char)28,
                            (unsigned char)28, (unsigned char)28, (unsigned char)28,
                            (unsigned char)28, (unsigned char)28, (unsigned char)28,
                            (unsigned char)28, (unsigned char)28, (unsigned char)28,
                            (unsigned char)28, (unsigned char)28, (unsigned char)28,
                            (unsigned char)28, (unsigned char)28, (unsigned char)28,
                            (unsigned char)28, (unsigned char)28, (unsigned char)28,
                            (unsigned char)28, (unsigned char)28, (unsigned char)22,
                            (unsigned char)28, (unsigned char)28, (unsigned char)28,
                            (unsigned char)28, (unsigned char)28, (unsigned char)28,
                            (unsigned char)28, (unsigned char)28, (unsigned char)28,
                            (unsigned char)28, (unsigned char)22, (unsigned char)28,
                            (unsigned char)26, (unsigned char)28, (unsigned char)28,
                            (unsigned char)22, (unsigned char)28, (unsigned char)28,
                            (unsigned char)28, (unsigned char)28, (unsigned char)28,
                            (unsigned char)22, (unsigned char)22, (unsigned char)22,
                            (unsigned char)22, (unsigned char)22, (unsigned char)22,
                            (unsigned char)22, (unsigned char)22, (unsigned char)22,
                            (unsigned char)22, (unsigned char)22, (unsigned char)22,
                            (unsigned char)22, (unsigned char)22, (unsigned char)22,
                            (unsigned char)22, (unsigned char)22, (unsigned char)22,
                            (unsigned char)22, (unsigned char)22, (unsigned char)22,
                            (unsigned char)22, (unsigned char)22, (unsigned char)28,
                            (unsigned char)22, (unsigned char)22, (unsigned char)22,
                            (unsigned char)22, (unsigned char)22, (unsigned char)22,
                            (unsigned char)22, (unsigned char)22, (unsigned char)22,
                            (unsigned char)22, (unsigned char)22, (unsigned char)22,
                            (unsigned char)22, (unsigned char)22, (unsigned char)22,
                            (unsigned char)22, (unsigned char)22, (unsigned char)22,
                            (unsigned char)22, (unsigned char)22, (unsigned char)22,
                            (unsigned char)22, (unsigned char)22, (unsigned char)22,
                            (unsigned char)22, (unsigned char)22, (unsigned char)22,
                            (unsigned char)22, (unsigned char)22, (unsigned char)22,
                            (unsigned char)22, (unsigned char)28, (unsigned char)22,
                            (unsigned char)22, (unsigned char)22, (unsigned char)22,
                            (unsigned char)22, (unsigned char)22, (unsigned char)22,
                            (unsigned char)22}, (int (*)(ENCODING const   * , char const   * ))0,
    (int (*)(ENCODING const   * , char const   * ))0, (int (*)(ENCODING const   * ,
                                                               char const   * ))0,
    (int (*)(ENCODING const   * , char const   * ))0, (int (*)(ENCODING const   * ,
                                                               char const   * ))0,
    (int (*)(ENCODING const   * , char const   * ))0, (int (*)(ENCODING const   * ,
                                                               char const   * ))0,
    (int (*)(ENCODING const   * , char const   * ))0, (int (*)(ENCODING const   * ,
                                                               char const   * ))0};
#line 475 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmltok.c"
static struct normal_encoding  const  latin1_encoding___0  = 
#line 475
     {{{& normal_prologTok___0, & normal_contentTok___0, & normal_cdataSectionTok___0,
      & normal_ignoreSectionTok___0}, {& normal_attributeValueTok___0, & normal_entityValueTok___0},
     & normal_sameName___0, & normal_nameMatchesAscii___0, & normal_nameLength___0,
     & normal_skipS___0, & normal_getAtts___0, & normal_charRefNumber___0, & normal_predefinedEntityName___0,
     & normal_updatePosition___0, & normal_isPublicId___0, & latin1_toUtf8___0, & latin1_toUtf16___0,
     1, (char)0, (char)0}, {(unsigned char)0, (unsigned char)0, (unsigned char)0,
                            (unsigned char)0, (unsigned char)0, (unsigned char)0,
                            (unsigned char)0, (unsigned char)0, (unsigned char)0,
                            (unsigned char)21, (unsigned char)10, (unsigned char)0,
                            (unsigned char)0, (unsigned char)9, (unsigned char)0,
                            (unsigned char)0, (unsigned char)0, (unsigned char)0,
                            (unsigned char)0, (unsigned char)0, (unsigned char)0,
                            (unsigned char)0, (unsigned char)0, (unsigned char)0,
                            (unsigned char)0, (unsigned char)0, (unsigned char)0,
                            (unsigned char)0, (unsigned char)0, (unsigned char)0,
                            (unsigned char)0, (unsigned char)0, (unsigned char)21,
                            (unsigned char)16, (unsigned char)12, (unsigned char)19,
                            (unsigned char)28, (unsigned char)30, (unsigned char)3,
                            (unsigned char)13, (unsigned char)31, (unsigned char)32,
                            (unsigned char)33, (unsigned char)34, (unsigned char)35,
                            (unsigned char)27, (unsigned char)26, (unsigned char)17,
                            (unsigned char)25, (unsigned char)25, (unsigned char)25,
                            (unsigned char)25, (unsigned char)25, (unsigned char)25,
                            (unsigned char)25, (unsigned char)25, (unsigned char)25,
                            (unsigned char)25, (unsigned char)22, (unsigned char)18,
                            (unsigned char)2, (unsigned char)14, (unsigned char)11,
                            (unsigned char)15, (unsigned char)28, (unsigned char)24,
                            (unsigned char)24, (unsigned char)24, (unsigned char)24,
                            (unsigned char)24, (unsigned char)24, (unsigned char)22,
                            (unsigned char)22, (unsigned char)22, (unsigned char)22,
                            (unsigned char)22, (unsigned char)22, (unsigned char)22,
                            (unsigned char)22, (unsigned char)22, (unsigned char)22,
                            (unsigned char)22, (unsigned char)22, (unsigned char)22,
                            (unsigned char)22, (unsigned char)22, (unsigned char)22,
                            (unsigned char)22, (unsigned char)22, (unsigned char)22,
                            (unsigned char)22, (unsigned char)20, (unsigned char)28,
                            (unsigned char)4, (unsigned char)28, (unsigned char)22,
                            (unsigned char)28, (unsigned char)24, (unsigned char)24,
                            (unsigned char)24, (unsigned char)24, (unsigned char)24,
                            (unsigned char)24, (unsigned char)22, (unsigned char)22,
                            (unsigned char)22, (unsigned char)22, (unsigned char)22,
                            (unsigned char)22, (unsigned char)22, (unsigned char)22,
                            (unsigned char)22, (unsigned char)22, (unsigned char)22,
                            (unsigned char)22, (unsigned char)22, (unsigned char)22,
                            (unsigned char)22, (unsigned char)22, (unsigned char)22,
                            (unsigned char)22, (unsigned char)22, (unsigned char)22,
                            (unsigned char)28, (unsigned char)36, (unsigned char)28,
                            (unsigned char)28, (unsigned char)28, (unsigned char)28,
                            (unsigned char)28, (unsigned char)28, (unsigned char)28,
                            (unsigned char)28, (unsigned char)28, (unsigned char)28,
                            (unsigned char)28, (unsigned char)28, (unsigned char)28,
                            (unsigned char)28, (unsigned char)28, (unsigned char)28,
                            (unsigned char)28, (unsigned char)28, (unsigned char)28,
                            (unsigned char)28, (unsigned char)28, (unsigned char)28,
                            (unsigned char)28, (unsigned char)28, (unsigned char)28,
                            (unsigned char)28, (unsigned char)28, (unsigned char)28,
                            (unsigned char)28, (unsigned char)28, (unsigned char)28,
                            (unsigned char)28, (unsigned char)28, (unsigned char)28,
                            (unsigned char)28, (unsigned char)28, (unsigned char)28,
                            (unsigned char)28, (unsigned char)28, (unsigned char)28,
                            (unsigned char)28, (unsigned char)28, (unsigned char)28,
                            (unsigned char)28, (unsigned char)28, (unsigned char)22,
                            (unsigned char)28, (unsigned char)28, (unsigned char)28,
                            (unsigned char)28, (unsigned char)28, (unsigned char)28,
                            (unsigned char)28, (unsigned char)28, (unsigned char)28,
                            (unsigned char)28, (unsigned char)22, (unsigned char)28,
                            (unsigned char)26, (unsigned char)28, (unsigned char)28,
                            (unsigned char)22, (unsigned char)28, (unsigned char)28,
                            (unsigned char)28, (unsigned char)28, (unsigned char)28,
                            (unsigned char)22, (unsigned char)22, (unsigned char)22,
                            (unsigned char)22, (unsigned char)22, (unsigned char)22,
                            (unsigned char)22, (unsigned char)22, (unsigned char)22,
                            (unsigned char)22, (unsigned char)22, (unsigned char)22,
                            (unsigned char)22, (unsigned char)22, (unsigned char)22,
                            (unsigned char)22, (unsigned char)22, (unsigned char)22,
                            (unsigned char)22, (unsigned char)22, (unsigned char)22,
                            (unsigned char)22, (unsigned char)22, (unsigned char)28,
                            (unsigned char)22, (unsigned char)22, (unsigned char)22,
                            (unsigned char)22, (unsigned char)22, (unsigned char)22,
                            (unsigned char)22, (unsigned char)22, (unsigned char)22,
                            (unsigned char)22, (unsigned char)22, (unsigned char)22,
                            (unsigned char)22, (unsigned char)22, (unsigned char)22,
                            (unsigned char)22, (unsigned char)22, (unsigned char)22,
                            (unsigned char)22, (unsigned char)22, (unsigned char)22,
                            (unsigned char)22, (unsigned char)22, (unsigned char)22,
                            (unsigned char)22, (unsigned char)22, (unsigned char)22,
                            (unsigned char)22, (unsigned char)22, (unsigned char)22,
                            (unsigned char)22, (unsigned char)28, (unsigned char)22,
                            (unsigned char)22, (unsigned char)22, (unsigned char)22,
                            (unsigned char)22, (unsigned char)22, (unsigned char)22,
                            (unsigned char)22}, (int (*)(ENCODING const   * , char const   * ))0,
    (int (*)(ENCODING const   * , char const   * ))0, (int (*)(ENCODING const   * ,
                                                               char const   * ))0,
    (int (*)(ENCODING const   * , char const   * ))0, (int (*)(ENCODING const   * ,
                                                               char const   * ))0,
    (int (*)(ENCODING const   * , char const   * ))0, (int (*)(ENCODING const   * ,
                                                               char const   * ))0,
    (int (*)(ENCODING const   * , char const   * ))0, (int (*)(ENCODING const   * ,
                                                               char const   * ))0};
#line 486 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmltok.c"
static void ascii_toUtf8___0(ENCODING const   *enc , char const   **fromP , char const   *fromLim ,
                             char **toP , char const   *toLim ) 
{ 
  char *tmp ;
  char const   *tmp___0 ;

  {
  {
#line 491
  while (1) {
    while_continue: /* CIL Label */ ;
#line 491
    if ((unsigned long )*fromP != (unsigned long )fromLim) {
#line 491
      if (! ((unsigned long )*toP != (unsigned long )toLim)) {
#line 491
        goto while_break;
      }
    } else {
#line 491
      goto while_break;
    }
#line 492
    tmp = *toP;
#line 492
    (*toP) ++;
#line 492
    tmp___0 = *fromP;
#line 492
    (*fromP) ++;
#line 492
    *tmp = (char )*tmp___0;
  }
  while_break: /* CIL Label */ ;
  }
#line 493
  return;
}
}
#line 497 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmltok.c"
static struct normal_encoding  const  ascii_encoding_ns___0  = 
#line 497
     {{{& normal_prologTok___0, & normal_contentTok___0, & normal_cdataSectionTok___0,
      & normal_ignoreSectionTok___0}, {& normal_attributeValueTok___0, & normal_entityValueTok___0},
     & normal_sameName___0, & normal_nameMatchesAscii___0, & normal_nameLength___0,
     & normal_skipS___0, & normal_getAtts___0, & normal_charRefNumber___0, & normal_predefinedEntityName___0,
     & normal_updatePosition___0, & normal_isPublicId___0, & ascii_toUtf8___0, & latin1_toUtf16___0,
     1, (char)1, (char)0}, {(unsigned char)0, (unsigned char)0, (unsigned char)0,
                            (unsigned char)0, (unsigned char)0, (unsigned char)0,
                            (unsigned char)0, (unsigned char)0, (unsigned char)0,
                            (unsigned char)21, (unsigned char)10, (unsigned char)0,
                            (unsigned char)0, (unsigned char)9, (unsigned char)0,
                            (unsigned char)0, (unsigned char)0, (unsigned char)0,
                            (unsigned char)0, (unsigned char)0, (unsigned char)0,
                            (unsigned char)0, (unsigned char)0, (unsigned char)0,
                            (unsigned char)0, (unsigned char)0, (unsigned char)0,
                            (unsigned char)0, (unsigned char)0, (unsigned char)0,
                            (unsigned char)0, (unsigned char)0, (unsigned char)21,
                            (unsigned char)16, (unsigned char)12, (unsigned char)19,
                            (unsigned char)28, (unsigned char)30, (unsigned char)3,
                            (unsigned char)13, (unsigned char)31, (unsigned char)32,
                            (unsigned char)33, (unsigned char)34, (unsigned char)35,
                            (unsigned char)27, (unsigned char)26, (unsigned char)17,
                            (unsigned char)25, (unsigned char)25, (unsigned char)25,
                            (unsigned char)25, (unsigned char)25, (unsigned char)25,
                            (unsigned char)25, (unsigned char)25, (unsigned char)25,
                            (unsigned char)25, (unsigned char)23, (unsigned char)18,
                            (unsigned char)2, (unsigned char)14, (unsigned char)11,
                            (unsigned char)15, (unsigned char)28, (unsigned char)24,
                            (unsigned char)24, (unsigned char)24, (unsigned char)24,
                            (unsigned char)24, (unsigned char)24, (unsigned char)22,
                            (unsigned char)22, (unsigned char)22, (unsigned char)22,
                            (unsigned char)22, (unsigned char)22, (unsigned char)22,
                            (unsigned char)22, (unsigned char)22, (unsigned char)22,
                            (unsigned char)22, (unsigned char)22, (unsigned char)22,
                            (unsigned char)22, (unsigned char)22, (unsigned char)22,
                            (unsigned char)22, (unsigned char)22, (unsigned char)22,
                            (unsigned char)22, (unsigned char)20, (unsigned char)28,
                            (unsigned char)4, (unsigned char)28, (unsigned char)22,
                            (unsigned char)28, (unsigned char)24, (unsigned char)24,
                            (unsigned char)24, (unsigned char)24, (unsigned char)24,
                            (unsigned char)24, (unsigned char)22, (unsigned char)22,
                            (unsigned char)22, (unsigned char)22, (unsigned char)22,
                            (unsigned char)22, (unsigned char)22, (unsigned char)22,
                            (unsigned char)22, (unsigned char)22, (unsigned char)22,
                            (unsigned char)22, (unsigned char)22, (unsigned char)22,
                            (unsigned char)22, (unsigned char)22, (unsigned char)22,
                            (unsigned char)22, (unsigned char)22, (unsigned char)22,
                            (unsigned char)28, (unsigned char)36, (unsigned char)28,
                            (unsigned char)28, (unsigned char)28}, (int (*)(ENCODING const   * ,
                                                                            char const   * ))0,
    (int (*)(ENCODING const   * , char const   * ))0, (int (*)(ENCODING const   * ,
                                                               char const   * ))0,
    (int (*)(ENCODING const   * , char const   * ))0, (int (*)(ENCODING const   * ,
                                                               char const   * ))0,
    (int (*)(ENCODING const   * , char const   * ))0, (int (*)(ENCODING const   * ,
                                                               char const   * ))0,
    (int (*)(ENCODING const   * , char const   * ))0, (int (*)(ENCODING const   * ,
                                                               char const   * ))0};
#line 508 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmltok.c"
static struct normal_encoding  const  ascii_encoding___0  = 
#line 508
     {{{& normal_prologTok___0, & normal_contentTok___0, & normal_cdataSectionTok___0,
      & normal_ignoreSectionTok___0}, {& normal_attributeValueTok___0, & normal_entityValueTok___0},
     & normal_sameName___0, & normal_nameMatchesAscii___0, & normal_nameLength___0,
     & normal_skipS___0, & normal_getAtts___0, & normal_charRefNumber___0, & normal_predefinedEntityName___0,
     & normal_updatePosition___0, & normal_isPublicId___0, & ascii_toUtf8___0, & latin1_toUtf16___0,
     1, (char)1, (char)0}, {(unsigned char)0, (unsigned char)0, (unsigned char)0,
                            (unsigned char)0, (unsigned char)0, (unsigned char)0,
                            (unsigned char)0, (unsigned char)0, (unsigned char)0,
                            (unsigned char)21, (unsigned char)10, (unsigned char)0,
                            (unsigned char)0, (unsigned char)9, (unsigned char)0,
                            (unsigned char)0, (unsigned char)0, (unsigned char)0,
                            (unsigned char)0, (unsigned char)0, (unsigned char)0,
                            (unsigned char)0, (unsigned char)0, (unsigned char)0,
                            (unsigned char)0, (unsigned char)0, (unsigned char)0,
                            (unsigned char)0, (unsigned char)0, (unsigned char)0,
                            (unsigned char)0, (unsigned char)0, (unsigned char)21,
                            (unsigned char)16, (unsigned char)12, (unsigned char)19,
                            (unsigned char)28, (unsigned char)30, (unsigned char)3,
                            (unsigned char)13, (unsigned char)31, (unsigned char)32,
                            (unsigned char)33, (unsigned char)34, (unsigned char)35,
                            (unsigned char)27, (unsigned char)26, (unsigned char)17,
                            (unsigned char)25, (unsigned char)25, (unsigned char)25,
                            (unsigned char)25, (unsigned char)25, (unsigned char)25,
                            (unsigned char)25, (unsigned char)25, (unsigned char)25,
                            (unsigned char)25, (unsigned char)22, (unsigned char)18,
                            (unsigned char)2, (unsigned char)14, (unsigned char)11,
                            (unsigned char)15, (unsigned char)28, (unsigned char)24,
                            (unsigned char)24, (unsigned char)24, (unsigned char)24,
                            (unsigned char)24, (unsigned char)24, (unsigned char)22,
                            (unsigned char)22, (unsigned char)22, (unsigned char)22,
                            (unsigned char)22, (unsigned char)22, (unsigned char)22,
                            (unsigned char)22, (unsigned char)22, (unsigned char)22,
                            (unsigned char)22, (unsigned char)22, (unsigned char)22,
                            (unsigned char)22, (unsigned char)22, (unsigned char)22,
                            (unsigned char)22, (unsigned char)22, (unsigned char)22,
                            (unsigned char)22, (unsigned char)20, (unsigned char)28,
                            (unsigned char)4, (unsigned char)28, (unsigned char)22,
                            (unsigned char)28, (unsigned char)24, (unsigned char)24,
                            (unsigned char)24, (unsigned char)24, (unsigned char)24,
                            (unsigned char)24, (unsigned char)22, (unsigned char)22,
                            (unsigned char)22, (unsigned char)22, (unsigned char)22,
                            (unsigned char)22, (unsigned char)22, (unsigned char)22,
                            (unsigned char)22, (unsigned char)22, (unsigned char)22,
                            (unsigned char)22, (unsigned char)22, (unsigned char)22,
                            (unsigned char)22, (unsigned char)22, (unsigned char)22,
                            (unsigned char)22, (unsigned char)22, (unsigned char)22,
                            (unsigned char)28, (unsigned char)36, (unsigned char)28,
                            (unsigned char)28, (unsigned char)28}, (int (*)(ENCODING const   * ,
                                                                            char const   * ))0,
    (int (*)(ENCODING const   * , char const   * ))0, (int (*)(ENCODING const   * ,
                                                               char const   * ))0,
    (int (*)(ENCODING const   * , char const   * ))0, (int (*)(ENCODING const   * ,
                                                               char const   * ))0,
    (int (*)(ENCODING const   * , char const   * ))0, (int (*)(ENCODING const   * ,
                                                               char const   * ))0,
    (int (*)(ENCODING const   * , char const   * ))0, (int (*)(ENCODING const   * ,
                                                               char const   * ))0};
#line 519 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmltok.c"
static int unicode_byte_type___0(char hi , char lo ) 
{ 


  {
  {
#line 523
  if ((int )((unsigned char )hi) == 219) {
#line 523
    goto case_219;
  }
#line 523
  if ((int )((unsigned char )hi) == 218) {
#line 523
    goto case_219;
  }
#line 523
  if ((int )((unsigned char )hi) == 217) {
#line 523
    goto case_219;
  }
#line 523
  if ((int )((unsigned char )hi) == 216) {
#line 523
    goto case_219;
  }
#line 525
  if ((int )((unsigned char )hi) == 223) {
#line 525
    goto case_223;
  }
#line 525
  if ((int )((unsigned char )hi) == 222) {
#line 525
    goto case_223;
  }
#line 525
  if ((int )((unsigned char )hi) == 221) {
#line 525
    goto case_223;
  }
#line 525
  if ((int )((unsigned char )hi) == 220) {
#line 525
    goto case_223;
  }
#line 527
  if ((int )((unsigned char )hi) == 255) {
#line 527
    goto case_255;
  }
#line 522
  goto switch_break;
  case_219: /* CIL Label */ 
  case_218: /* CIL Label */ 
  case_217: /* CIL Label */ 
  case_216: /* CIL Label */ 
#line 524
  return (7);
  case_223: /* CIL Label */ 
  case_222: /* CIL Label */ 
  case_221: /* CIL Label */ 
  case_220: /* CIL Label */ 
#line 526
  return (8);
  case_255: /* CIL Label */ 
  {
#line 530
  if ((int )((unsigned char )lo) == 254) {
#line 530
    goto case_254;
  }
#line 530
  if ((int )((unsigned char )lo) == 255) {
#line 530
    goto case_254;
  }
#line 528
  goto switch_break___0;
  case_254: /* CIL Label */ 
  case_255___0: /* CIL Label */ 
#line 531
  return (0);
  switch_break___0: /* CIL Label */ ;
  }
#line 533
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 535
  return (29);
}
}
#line 620 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmltok.c"
static void little2_toUtf8___0(ENCODING const   *enc , char const   **fromP , char const   *fromLim ,
                               char **toP , char const   *toLim ) 
{ 
  char const   *from ;
  int plane ;
  unsigned char lo2 ;
  unsigned char lo ;
  unsigned char hi ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;

  {
#line 620
  from = *fromP;
  {
#line 620
  while (1) {
    while_continue: /* CIL Label */ ;
#line 620
    if (! ((unsigned long )from != (unsigned long )fromLim)) {
#line 620
      goto while_break;
    }
#line 620
    lo = (unsigned char )*(from + 0);
#line 620
    hi = (unsigned char )*(from + 1);
    {
#line 620
    if ((int )hi == 0) {
#line 620
      goto case_0;
    }
#line 620
    if ((int )hi == 7) {
#line 620
      goto case_7;
    }
#line 620
    if ((int )hi == 6) {
#line 620
      goto case_7;
    }
#line 620
    if ((int )hi == 5) {
#line 620
      goto case_7;
    }
#line 620
    if ((int )hi == 4) {
#line 620
      goto case_7;
    }
#line 620
    if ((int )hi == 3) {
#line 620
      goto case_7;
    }
#line 620
    if ((int )hi == 2) {
#line 620
      goto case_7;
    }
#line 620
    if ((int )hi == 1) {
#line 620
      goto case_7;
    }
#line 620
    if ((int )hi == 219) {
#line 620
      goto case_219;
    }
#line 620
    if ((int )hi == 218) {
#line 620
      goto case_219;
    }
#line 620
    if ((int )hi == 217) {
#line 620
      goto case_219;
    }
#line 620
    if ((int )hi == 216) {
#line 620
      goto case_219;
    }
#line 620
    goto switch_default;
    case_0: /* CIL Label */ 
#line 620
    if ((int )lo < 128) {
#line 620
      if ((unsigned long )*toP == (unsigned long )toLim) {
#line 620
        *fromP = from;
#line 620
        return;
      }
#line 620
      tmp = *toP;
#line 620
      (*toP) ++;
#line 620
      *tmp = (char )lo;
#line 620
      goto switch_break;
    }
    case_7: /* CIL Label */ 
    case_6: /* CIL Label */ 
    case_5: /* CIL Label */ 
    case_4: /* CIL Label */ 
    case_3: /* CIL Label */ 
    case_2: /* CIL Label */ 
    case_1: /* CIL Label */ 
#line 620
    if (toLim - (char const   *)*toP < 2L) {
#line 620
      *fromP = from;
#line 620
      return;
    }
#line 620
    tmp___0 = *toP;
#line 620
    (*toP) ++;
#line 620
    *tmp___0 = (char )((((int )lo >> 6) | ((int )hi << 2)) | 192);
#line 620
    tmp___1 = *toP;
#line 620
    (*toP) ++;
#line 620
    *tmp___1 = (char )(((int )lo & 63) | 128);
#line 620
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 620
    if (toLim - (char const   *)*toP < 3L) {
#line 620
      *fromP = from;
#line 620
      return;
    }
#line 620
    tmp___2 = *toP;
#line 620
    (*toP) ++;
#line 620
    *tmp___2 = (char )(((int )hi >> 4) | 224);
#line 620
    tmp___3 = *toP;
#line 620
    (*toP) ++;
#line 620
    *tmp___3 = (char )(((((int )hi & 15) << 2) | ((int )lo >> 6)) | 128);
#line 620
    tmp___4 = *toP;
#line 620
    (*toP) ++;
#line 620
    *tmp___4 = (char )(((int )lo & 63) | 128);
#line 620
    goto switch_break;
    case_219: /* CIL Label */ 
    case_218: /* CIL Label */ 
    case_217: /* CIL Label */ 
    case_216: /* CIL Label */ 
#line 620
    if (toLim - (char const   *)*toP < 4L) {
#line 620
      *fromP = from;
#line 620
      return;
    }
#line 620
    plane = ((((int )hi & 3) << 2) | (((int )lo >> 6) & 3)) + 1;
#line 620
    tmp___5 = *toP;
#line 620
    (*toP) ++;
#line 620
    *tmp___5 = (char )((plane >> 2) | 240);
#line 620
    tmp___6 = *toP;
#line 620
    (*toP) ++;
#line 620
    *tmp___6 = (char )(((((int )lo >> 2) & 15) | ((plane & 3) << 4)) | 128);
#line 620
    from += 2;
#line 620
    lo2 = (unsigned char )*(from + 0);
#line 620
    tmp___7 = *toP;
#line 620
    (*toP) ++;
#line 620
    *tmp___7 = (char )((((((int )lo & 3) << 4) | (((int )((unsigned char )*(from + 1)) & 3) << 2)) | ((int )lo2 >> 6)) | 128);
#line 620
    tmp___8 = *toP;
#line 620
    (*toP) ++;
#line 620
    *tmp___8 = (char )(((int )lo2 & 63) | 128);
#line 620
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 620
    from += 2;
  }
  while_break: /* CIL Label */ ;
  }
#line 620
  *fromP = from;
#line 620
  return;
}
}
#line 621 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmltok.c"
static void little2_toUtf16___0(ENCODING const   *enc , char const   **fromP , char const   *fromLim ,
                                unsigned short **toP , unsigned short const   *toLim ) 
{ 
  unsigned short *tmp ;

  {
#line 621
  if (fromLim - *fromP > (toLim - (unsigned short const   *)*toP) << 1) {
#line 621
    if (((int )((unsigned char )*((fromLim - 2) + 1)) & 248) == 216) {
#line 621
      fromLim -= 2;
    }
  }
  {
#line 621
  while (1) {
    while_continue: /* CIL Label */ ;
#line 621
    if ((unsigned long )*fromP != (unsigned long )fromLim) {
#line 621
      if (! ((unsigned long )*toP != (unsigned long )toLim)) {
#line 621
        goto while_break;
      }
    } else {
#line 621
      goto while_break;
    }
#line 621
    tmp = *toP;
#line 621
    (*toP) ++;
#line 621
    *tmp = (unsigned short )(((int )((unsigned char )*(*fromP + 1)) << 8) | (int )((unsigned char )*(*fromP + 0)));
#line 621
    *fromP += 2;
  }
  while_break: /* CIL Label */ ;
  }
#line 621
  return;
}
}
#line 632 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmltok.c"
static void big2_toUtf8___0(ENCODING const   *enc , char const   **fromP , char const   *fromLim ,
                            char **toP , char const   *toLim ) 
{ 
  char const   *from ;
  int plane ;
  unsigned char lo2 ;
  unsigned char lo ;
  unsigned char hi ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;

  {
#line 632
  from = *fromP;
  {
#line 632
  while (1) {
    while_continue: /* CIL Label */ ;
#line 632
    if (! ((unsigned long )from != (unsigned long )fromLim)) {
#line 632
      goto while_break;
    }
#line 632
    lo = (unsigned char )*(from + 1);
#line 632
    hi = (unsigned char )*(from + 0);
    {
#line 632
    if ((int )hi == 0) {
#line 632
      goto case_0;
    }
#line 632
    if ((int )hi == 7) {
#line 632
      goto case_7;
    }
#line 632
    if ((int )hi == 6) {
#line 632
      goto case_7;
    }
#line 632
    if ((int )hi == 5) {
#line 632
      goto case_7;
    }
#line 632
    if ((int )hi == 4) {
#line 632
      goto case_7;
    }
#line 632
    if ((int )hi == 3) {
#line 632
      goto case_7;
    }
#line 632
    if ((int )hi == 2) {
#line 632
      goto case_7;
    }
#line 632
    if ((int )hi == 1) {
#line 632
      goto case_7;
    }
#line 632
    if ((int )hi == 219) {
#line 632
      goto case_219;
    }
#line 632
    if ((int )hi == 218) {
#line 632
      goto case_219;
    }
#line 632
    if ((int )hi == 217) {
#line 632
      goto case_219;
    }
#line 632
    if ((int )hi == 216) {
#line 632
      goto case_219;
    }
#line 632
    goto switch_default;
    case_0: /* CIL Label */ 
#line 632
    if ((int )lo < 128) {
#line 632
      if ((unsigned long )*toP == (unsigned long )toLim) {
#line 632
        *fromP = from;
#line 632
        return;
      }
#line 632
      tmp = *toP;
#line 632
      (*toP) ++;
#line 632
      *tmp = (char )lo;
#line 632
      goto switch_break;
    }
    case_7: /* CIL Label */ 
    case_6: /* CIL Label */ 
    case_5: /* CIL Label */ 
    case_4: /* CIL Label */ 
    case_3: /* CIL Label */ 
    case_2: /* CIL Label */ 
    case_1: /* CIL Label */ 
#line 632
    if (toLim - (char const   *)*toP < 2L) {
#line 632
      *fromP = from;
#line 632
      return;
    }
#line 632
    tmp___0 = *toP;
#line 632
    (*toP) ++;
#line 632
    *tmp___0 = (char )((((int )lo >> 6) | ((int )hi << 2)) | 192);
#line 632
    tmp___1 = *toP;
#line 632
    (*toP) ++;
#line 632
    *tmp___1 = (char )(((int )lo & 63) | 128);
#line 632
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 632
    if (toLim - (char const   *)*toP < 3L) {
#line 632
      *fromP = from;
#line 632
      return;
    }
#line 632
    tmp___2 = *toP;
#line 632
    (*toP) ++;
#line 632
    *tmp___2 = (char )(((int )hi >> 4) | 224);
#line 632
    tmp___3 = *toP;
#line 632
    (*toP) ++;
#line 632
    *tmp___3 = (char )(((((int )hi & 15) << 2) | ((int )lo >> 6)) | 128);
#line 632
    tmp___4 = *toP;
#line 632
    (*toP) ++;
#line 632
    *tmp___4 = (char )(((int )lo & 63) | 128);
#line 632
    goto switch_break;
    case_219: /* CIL Label */ 
    case_218: /* CIL Label */ 
    case_217: /* CIL Label */ 
    case_216: /* CIL Label */ 
#line 632
    if (toLim - (char const   *)*toP < 4L) {
#line 632
      *fromP = from;
#line 632
      return;
    }
#line 632
    plane = ((((int )hi & 3) << 2) | (((int )lo >> 6) & 3)) + 1;
#line 632
    tmp___5 = *toP;
#line 632
    (*toP) ++;
#line 632
    *tmp___5 = (char )((plane >> 2) | 240);
#line 632
    tmp___6 = *toP;
#line 632
    (*toP) ++;
#line 632
    *tmp___6 = (char )(((((int )lo >> 2) & 15) | ((plane & 3) << 4)) | 128);
#line 632
    from += 2;
#line 632
    lo2 = (unsigned char )*(from + 1);
#line 632
    tmp___7 = *toP;
#line 632
    (*toP) ++;
#line 632
    *tmp___7 = (char )((((((int )lo & 3) << 4) | (((int )((unsigned char )*(from + 0)) & 3) << 2)) | ((int )lo2 >> 6)) | 128);
#line 632
    tmp___8 = *toP;
#line 632
    (*toP) ++;
#line 632
    *tmp___8 = (char )(((int )lo2 & 63) | 128);
#line 632
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 632
    from += 2;
  }
  while_break: /* CIL Label */ ;
  }
#line 632
  *fromP = from;
#line 632
  return;
}
}
#line 633 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmltok.c"
static void big2_toUtf16___0(ENCODING const   *enc , char const   **fromP , char const   *fromLim ,
                             unsigned short **toP , unsigned short const   *toLim ) 
{ 
  unsigned short *tmp ;

  {
#line 633
  if (fromLim - *fromP > (toLim - (unsigned short const   *)*toP) << 1) {
#line 633
    if (((int )((unsigned char )*((fromLim - 2) + 0)) & 248) == 216) {
#line 633
      fromLim -= 2;
    }
  }
  {
#line 633
  while (1) {
    while_continue: /* CIL Label */ ;
#line 633
    if ((unsigned long )*fromP != (unsigned long )fromLim) {
#line 633
      if (! ((unsigned long )*toP != (unsigned long )toLim)) {
#line 633
        goto while_break;
      }
    } else {
#line 633
      goto while_break;
    }
#line 633
    tmp = *toP;
#line 633
    (*toP) ++;
#line 633
    *tmp = (unsigned short )(((int )((unsigned char )*(*fromP + 0)) << 8) | (int )((unsigned char )*(*fromP + 1)));
#line 633
    *fromP += 2;
  }
  while_break: /* CIL Label */ ;
  }
#line 633
  return;
}
}
#line 92 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmltok_impl.c"
static int little2_scanComment___0(ENCODING const   *enc , char const   *ptr , char const   *end ,
                                   char const   **nextTokPtr ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 96
  if ((unsigned long )ptr != (unsigned long )end) {
#line 97
    if ((int const   )*(ptr + 1) == 0) {
#line 97
      if (! ((int const   )*(ptr + 0) == 45)) {
#line 98
        *nextTokPtr = ptr;
#line 99
        return (0);
      }
    } else {
#line 98
      *nextTokPtr = ptr;
#line 99
      return (0);
    }
#line 101
    ptr += 2;
    {
#line 102
    while (1) {
      while_continue: /* CIL Label */ ;
#line 102
      if (! ((unsigned long )ptr != (unsigned long )end)) {
#line 102
        goto while_break;
      }
#line 103
      if ((int const   )*(ptr + 1) == 0) {
#line 103
        tmp___0 = (int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr];
      } else {
        {
#line 103
        tmp = unicode_byte_type___0((char )*(ptr + 1), (char )*(ptr + 0));
#line 103
        tmp___0 = tmp;
        }
      }
      {
#line 104
      if (tmp___0 == 5) {
#line 104
        goto case_5;
      }
#line 104
      if (tmp___0 == 6) {
#line 104
        goto case_6;
      }
#line 104
      if (tmp___0 == 7) {
#line 104
        goto case_7;
      }
#line 104
      if (tmp___0 == 8) {
#line 104
        goto case_8;
      }
#line 104
      if (tmp___0 == 1) {
#line 104
        goto case_8;
      }
#line 104
      if (tmp___0 == 0) {
#line 104
        goto case_8;
      }
#line 105
      if (tmp___0 == 27) {
#line 105
        goto case_27;
      }
#line 119
      goto switch_default;
      case_5: /* CIL Label */ 
#line 104
      if (end - ptr < 2L) {
#line 104
        return (-2);
      }
#line 104
      ptr += 2;
#line 104
      goto switch_break;
      case_6: /* CIL Label */ 
#line 104
      if (end - ptr < 3L) {
#line 104
        return (-2);
      }
#line 104
      ptr += 3;
#line 104
      goto switch_break;
      case_7: /* CIL Label */ 
#line 104
      if (end - ptr < 4L) {
#line 104
        return (-2);
      }
#line 104
      ptr += 4;
#line 104
      goto switch_break;
      case_8: /* CIL Label */ 
      case_1: /* CIL Label */ 
      case_0: /* CIL Label */ 
#line 104
      *nextTokPtr = ptr;
#line 104
      return (0);
      case_27: /* CIL Label */ 
#line 106
      ptr += 2;
#line 106
      if ((unsigned long )ptr == (unsigned long )end) {
#line 107
        return (-1);
      }
#line 108
      if ((int const   )*(ptr + 1) == 0) {
#line 108
        if ((int const   )*(ptr + 0) == 45) {
#line 109
          ptr += 2;
#line 109
          if ((unsigned long )ptr == (unsigned long )end) {
#line 110
            return (-1);
          }
#line 111
          if ((int const   )*(ptr + 1) == 0) {
#line 111
            if (! ((int const   )*(ptr + 0) == 62)) {
#line 112
              *nextTokPtr = ptr;
#line 113
              return (0);
            }
          } else {
#line 112
            *nextTokPtr = ptr;
#line 113
            return (0);
          }
#line 115
          *nextTokPtr = ptr + 2;
#line 116
          return (13);
        }
      }
#line 118
      goto switch_break;
      switch_default: /* CIL Label */ 
#line 120
      ptr += 2;
#line 121
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 125
  return (-1);
}
}
#line 130 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmltok_impl.c"
static int little2_scanDecl___0(ENCODING const   *enc , char const   *ptr , char const   *end ,
                                char const   **nextTokPtr ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 134
  if ((unsigned long )ptr == (unsigned long )end) {
#line 135
    return (-1);
  }
#line 136
  if ((int const   )*(ptr + 1) == 0) {
#line 136
    tmp___0 = (int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr];
  } else {
    {
#line 136
    tmp = unicode_byte_type___0((char )*(ptr + 1), (char )*(ptr + 0));
#line 136
    tmp___0 = tmp;
    }
  }
  {
#line 137
  if (tmp___0 == 27) {
#line 137
    goto case_27;
  }
#line 139
  if (tmp___0 == 20) {
#line 139
    goto case_20;
  }
#line 143
  if (tmp___0 == 24) {
#line 143
    goto case_24;
  }
#line 143
  if (tmp___0 == 22) {
#line 143
    goto case_24;
  }
#line 146
  goto switch_default;
  case_27: /* CIL Label */ 
  {
#line 138
  tmp___1 = little2_scanComment___0(enc, ptr + 2, end, nextTokPtr);
  }
#line 138
  return (tmp___1);
  case_20: /* CIL Label */ 
#line 140
  *nextTokPtr = ptr + 2;
#line 141
  return (33);
  case_24: /* CIL Label */ 
  case_22: /* CIL Label */ 
#line 144
  ptr += 2;
#line 145
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 147
  *nextTokPtr = ptr;
#line 148
  return (0);
  switch_break: /* CIL Label */ ;
  }
  {
#line 150
  while (1) {
    while_continue: /* CIL Label */ ;
#line 150
    if (! ((unsigned long )ptr != (unsigned long )end)) {
#line 150
      goto while_break;
    }
#line 151
    if ((int const   )*(ptr + 1) == 0) {
#line 151
      tmp___3 = (int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr];
    } else {
      {
#line 151
      tmp___2 = unicode_byte_type___0((char )*(ptr + 1), (char )*(ptr + 0));
#line 151
      tmp___3 = tmp___2;
      }
    }
    {
#line 152
    if (tmp___3 == 30) {
#line 152
      goto case_30;
    }
#line 162
    if (tmp___3 == 10) {
#line 162
      goto case_10___0;
    }
#line 162
    if (tmp___3 == 9) {
#line 162
      goto case_10___0;
    }
#line 162
    if (tmp___3 == 21) {
#line 162
      goto case_10___0;
    }
#line 166
    if (tmp___3 == 24) {
#line 166
      goto case_24___0;
    }
#line 166
    if (tmp___3 == 22) {
#line 166
      goto case_24___0;
    }
#line 169
    goto switch_default___0;
    case_30: /* CIL Label */ 
#line 153
    if ((unsigned long )(ptr + 2) == (unsigned long )end) {
#line 154
      return (-1);
    }
#line 156
    if ((int const   )*((ptr + 2) + 1) == 0) {
#line 156
      tmp___5 = (int )((struct normal_encoding *)enc)->type[(unsigned char )*(ptr + 2)];
    } else {
      {
#line 156
      tmp___4 = unicode_byte_type___0((char )*((ptr + 2) + 1), (char )*((ptr + 2) + 0));
#line 156
      tmp___5 = tmp___4;
      }
    }
    {
#line 157
    if (tmp___5 == 30) {
#line 157
      goto case_30___0;
    }
#line 157
    if (tmp___5 == 10) {
#line 157
      goto case_30___0;
    }
#line 157
    if (tmp___5 == 9) {
#line 157
      goto case_30___0;
    }
#line 157
    if (tmp___5 == 21) {
#line 157
      goto case_30___0;
    }
#line 156
    goto switch_break___1;
    case_30___0: /* CIL Label */ 
    case_10: /* CIL Label */ 
    case_9: /* CIL Label */ 
    case_21: /* CIL Label */ 
#line 158
    *nextTokPtr = ptr;
#line 159
    return (0);
    switch_break___1: /* CIL Label */ ;
    }
    case_10___0: /* CIL Label */ 
    case_9___0: /* CIL Label */ 
    case_21___0: /* CIL Label */ 
#line 163
    *nextTokPtr = ptr;
#line 164
    return (16);
    case_24___0: /* CIL Label */ 
    case_22___0: /* CIL Label */ 
#line 167
    ptr += 2;
#line 168
    goto switch_break___0;
    switch_default___0: /* CIL Label */ 
#line 170
    *nextTokPtr = ptr;
#line 171
    return (0);
    switch_break___0: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 174
  return (-1);
}
}
#line 177 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmltok_impl.c"
static int little2_checkPiTarget___0(ENCODING const   *enc , char const   *ptr , char const   *end ,
                                     int *tokPtr ) 
{ 
  int upper ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 181
  upper = 0;
#line 182
  *tokPtr = 11;
#line 183
  if (end - ptr != 6L) {
#line 184
    return (1);
  }
#line 185
  if ((int const   )*(ptr + 1) == 0) {
#line 185
    tmp = (int const   )*(ptr + 0);
  } else {
#line 185
    tmp = (int const   )-1;
  }
  {
#line 186
  if (tmp == 120) {
#line 186
    goto case_120;
  }
#line 188
  if (tmp == 88) {
#line 188
    goto case_88;
  }
#line 191
  goto switch_default;
  case_120: /* CIL Label */ 
#line 187
  goto switch_break;
  case_88: /* CIL Label */ 
#line 189
  upper = 1;
#line 190
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 192
  return (1);
  switch_break: /* CIL Label */ ;
  }
#line 194
  ptr += 2;
#line 195
  if ((int const   )*(ptr + 1) == 0) {
#line 195
    tmp___0 = (int const   )*(ptr + 0);
  } else {
#line 195
    tmp___0 = (int const   )-1;
  }
  {
#line 196
  if (tmp___0 == 109) {
#line 196
    goto case_109;
  }
#line 198
  if (tmp___0 == 77) {
#line 198
    goto case_77;
  }
#line 201
  goto switch_default___0;
  case_109: /* CIL Label */ 
#line 197
  goto switch_break___0;
  case_77: /* CIL Label */ 
#line 199
  upper = 1;
#line 200
  goto switch_break___0;
  switch_default___0: /* CIL Label */ 
#line 202
  return (1);
  switch_break___0: /* CIL Label */ ;
  }
#line 204
  ptr += 2;
#line 205
  if ((int const   )*(ptr + 1) == 0) {
#line 205
    tmp___1 = (int const   )*(ptr + 0);
  } else {
#line 205
    tmp___1 = (int const   )-1;
  }
  {
#line 206
  if (tmp___1 == 108) {
#line 206
    goto case_108;
  }
#line 208
  if (tmp___1 == 76) {
#line 208
    goto case_76;
  }
#line 211
  goto switch_default___1;
  case_108: /* CIL Label */ 
#line 207
  goto switch_break___1;
  case_76: /* CIL Label */ 
#line 209
  upper = 1;
#line 210
  goto switch_break___1;
  switch_default___1: /* CIL Label */ 
#line 212
  return (1);
  switch_break___1: /* CIL Label */ ;
  }
#line 214
  if (upper) {
#line 215
    return (0);
  }
#line 216
  *tokPtr = 12;
#line 217
  return (1);
}
}
#line 222 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmltok_impl.c"
static int little2_scanPi___0(ENCODING const   *enc , char const   *ptr , char const   *end ,
                              char const   **nextTokPtr ) 
{ 
  int tok ;
  char const   *target ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
#line 227
  target = ptr;
#line 228
  if ((unsigned long )ptr == (unsigned long )end) {
#line 229
    return (-1);
  }
#line 230
  if ((int const   )*(ptr + 1) == 0) {
#line 230
    tmp___0 = (int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr];
  } else {
    {
#line 230
    tmp = unicode_byte_type___0((char )*(ptr + 1), (char )*(ptr + 0));
#line 230
    tmp___0 = tmp;
    }
  }
  {
#line 231
  if (tmp___0 == 29) {
#line 231
    goto case_29;
  }
#line 231
  if (tmp___0 == 24) {
#line 231
    goto case_24;
  }
#line 231
  if (tmp___0 == 22) {
#line 231
    goto case_24;
  }
#line 231
  if (tmp___0 == 5) {
#line 231
    goto case_5;
  }
#line 231
  if (tmp___0 == 6) {
#line 231
    goto case_6;
  }
#line 231
  if (tmp___0 == 7) {
#line 231
    goto case_7;
  }
#line 232
  goto switch_default;
  case_29: /* CIL Label */ 
#line 231
  if (! (namingBitmap___0[((int const   )nmstrtPages___0[(unsigned char )*(ptr + 1)] << 3) + (int const   )((int )((unsigned char )*(ptr + 0)) >> 5)] & (unsigned int const   )(1 << ((int )((unsigned char )*(ptr + 0)) & 31)))) {
#line 231
    *nextTokPtr = ptr;
#line 231
    return (0);
  }
  case_24: /* CIL Label */ 
  case_22: /* CIL Label */ 
#line 231
  ptr += 2;
#line 231
  goto switch_break;
  case_5: /* CIL Label */ 
#line 231
  if (end - ptr < 2L) {
#line 231
    return (-2);
  }
#line 231
  *nextTokPtr = ptr;
#line 231
  return (0);
#line 231
  ptr += 2;
#line 231
  goto switch_break;
  case_6: /* CIL Label */ 
#line 231
  if (end - ptr < 3L) {
#line 231
    return (-2);
  }
#line 231
  *nextTokPtr = ptr;
#line 231
  return (0);
#line 231
  ptr += 3;
#line 231
  goto switch_break;
  case_7: /* CIL Label */ 
#line 231
  if (end - ptr < 4L) {
#line 231
    return (-2);
  }
#line 231
  *nextTokPtr = ptr;
#line 231
  return (0);
#line 231
  ptr += 4;
#line 231
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 233
  *nextTokPtr = ptr;
#line 234
  return (0);
  switch_break: /* CIL Label */ ;
  }
  {
#line 236
  while (1) {
    while_continue: /* CIL Label */ ;
#line 236
    if (! ((unsigned long )ptr != (unsigned long )end)) {
#line 236
      goto while_break;
    }
#line 237
    if ((int const   )*(ptr + 1) == 0) {
#line 237
      tmp___2 = (int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr];
    } else {
      {
#line 237
      tmp___1 = unicode_byte_type___0((char )*(ptr + 1), (char )*(ptr + 0));
#line 237
      tmp___2 = tmp___1;
      }
    }
    {
#line 238
    if (tmp___2 == 29) {
#line 238
      goto case_29___0;
    }
#line 238
    if (tmp___2 == 27) {
#line 238
      goto case_27;
    }
#line 238
    if (tmp___2 == 26) {
#line 238
      goto case_27;
    }
#line 238
    if (tmp___2 == 25) {
#line 238
      goto case_27;
    }
#line 238
    if (tmp___2 == 24) {
#line 238
      goto case_27;
    }
#line 238
    if (tmp___2 == 22) {
#line 238
      goto case_27;
    }
#line 238
    if (tmp___2 == 5) {
#line 238
      goto case_5___0;
    }
#line 238
    if (tmp___2 == 6) {
#line 238
      goto case_6___0;
    }
#line 238
    if (tmp___2 == 7) {
#line 238
      goto case_7___0;
    }
#line 239
    if (tmp___2 == 10) {
#line 239
      goto case_10;
    }
#line 239
    if (tmp___2 == 9) {
#line 239
      goto case_10;
    }
#line 239
    if (tmp___2 == 21) {
#line 239
      goto case_10;
    }
#line 263
    if (tmp___2 == 15) {
#line 263
      goto case_15___0;
    }
#line 276
    goto switch_default___1;
    case_29___0: /* CIL Label */ 
#line 238
    if (! (namingBitmap___0[((int const   )namePages___0[(unsigned char )*(ptr + 1)] << 3) + (int const   )((int )((unsigned char )*(ptr + 0)) >> 5)] & (unsigned int const   )(1 << ((int )((unsigned char )*(ptr + 0)) & 31)))) {
#line 238
      *nextTokPtr = ptr;
#line 238
      return (0);
    }
    case_27: /* CIL Label */ 
    case_26: /* CIL Label */ 
    case_25: /* CIL Label */ 
    case_24___0: /* CIL Label */ 
    case_22___0: /* CIL Label */ 
#line 238
    ptr += 2;
#line 238
    goto switch_break___0;
    case_5___0: /* CIL Label */ 
#line 238
    if (end - ptr < 2L) {
#line 238
      return (-2);
    }
#line 238
    *nextTokPtr = ptr;
#line 238
    return (0);
#line 238
    ptr += 2;
#line 238
    goto switch_break___0;
    case_6___0: /* CIL Label */ 
#line 238
    if (end - ptr < 3L) {
#line 238
      return (-2);
    }
#line 238
    *nextTokPtr = ptr;
#line 238
    return (0);
#line 238
    ptr += 3;
#line 238
    goto switch_break___0;
    case_7___0: /* CIL Label */ 
#line 238
    if (end - ptr < 4L) {
#line 238
      return (-2);
    }
#line 238
    *nextTokPtr = ptr;
#line 238
    return (0);
#line 238
    ptr += 4;
#line 238
    goto switch_break___0;
    case_10: /* CIL Label */ 
    case_9: /* CIL Label */ 
    case_21: /* CIL Label */ 
    {
#line 240
    tmp___3 = little2_checkPiTarget___0(enc, target, ptr, & tok);
    }
#line 240
    if (! tmp___3) {
#line 241
      *nextTokPtr = ptr;
#line 242
      return (0);
    }
#line 244
    ptr += 2;
    {
#line 245
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 245
      if (! ((unsigned long )ptr != (unsigned long )end)) {
#line 245
        goto while_break___0;
      }
#line 246
      if ((int const   )*(ptr + 1) == 0) {
#line 246
        tmp___5 = (int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr];
      } else {
        {
#line 246
        tmp___4 = unicode_byte_type___0((char )*(ptr + 1), (char )*(ptr + 0));
#line 246
        tmp___5 = tmp___4;
        }
      }
      {
#line 247
      if (tmp___5 == 5) {
#line 247
        goto case_5___1;
      }
#line 247
      if (tmp___5 == 6) {
#line 247
        goto case_6___1;
      }
#line 247
      if (tmp___5 == 7) {
#line 247
        goto case_7___1;
      }
#line 247
      if (tmp___5 == 8) {
#line 247
        goto case_8;
      }
#line 247
      if (tmp___5 == 1) {
#line 247
        goto case_8;
      }
#line 247
      if (tmp___5 == 0) {
#line 247
        goto case_8;
      }
#line 248
      if (tmp___5 == 15) {
#line 248
        goto case_15;
      }
#line 257
      goto switch_default___0;
      case_5___1: /* CIL Label */ 
#line 247
      if (end - ptr < 2L) {
#line 247
        return (-2);
      }
#line 247
      ptr += 2;
#line 247
      goto switch_break___1;
      case_6___1: /* CIL Label */ 
#line 247
      if (end - ptr < 3L) {
#line 247
        return (-2);
      }
#line 247
      ptr += 3;
#line 247
      goto switch_break___1;
      case_7___1: /* CIL Label */ 
#line 247
      if (end - ptr < 4L) {
#line 247
        return (-2);
      }
#line 247
      ptr += 4;
#line 247
      goto switch_break___1;
      case_8: /* CIL Label */ 
      case_1: /* CIL Label */ 
      case_0: /* CIL Label */ 
#line 247
      *nextTokPtr = ptr;
#line 247
      return (0);
      case_15: /* CIL Label */ 
#line 249
      ptr += 2;
#line 250
      if ((unsigned long )ptr == (unsigned long )end) {
#line 251
        return (-1);
      }
#line 252
      if ((int const   )*(ptr + 1) == 0) {
#line 252
        if ((int const   )*(ptr + 0) == 62) {
#line 253
          *nextTokPtr = ptr + 2;
#line 254
          return (tok);
        }
      }
#line 256
      goto switch_break___1;
      switch_default___0: /* CIL Label */ 
#line 258
      ptr += 2;
#line 259
      goto switch_break___1;
      switch_break___1: /* CIL Label */ ;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 262
    return (-1);
    case_15___0: /* CIL Label */ 
    {
#line 264
    tmp___6 = little2_checkPiTarget___0(enc, target, ptr, & tok);
    }
#line 264
    if (! tmp___6) {
#line 265
      *nextTokPtr = ptr;
#line 266
      return (0);
    }
#line 268
    ptr += 2;
#line 269
    if ((unsigned long )ptr == (unsigned long )end) {
#line 270
      return (-1);
    }
#line 271
    if ((int const   )*(ptr + 1) == 0) {
#line 271
      if ((int const   )*(ptr + 0) == 62) {
#line 272
        *nextTokPtr = ptr + 2;
#line 273
        return (tok);
      }
    }
    switch_default___1: /* CIL Label */ 
#line 277
    *nextTokPtr = ptr;
#line 278
    return (0);
    switch_break___0: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 281
  return (-1);
}
}
#line 288
static int little2_scanCdataSection___0(ENCODING const   *enc , char const   *ptr ,
                                        char const   *end , char const   **nextTokPtr ) ;
#line 288 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmltok_impl.c"
static char const   CDATA_LSQB___3[6]  = {      (char const   )67,      (char const   )68,      (char const   )65,      (char const   )84, 
        (char const   )65,      (char const   )91};
#line 284 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmltok_impl.c"
static int little2_scanCdataSection___0(ENCODING const   *enc , char const   *ptr ,
                                        char const   *end , char const   **nextTokPtr ) 
{ 
  int i ;

  {
#line 292
  if (end - ptr < 12L) {
#line 293
    return (-1);
  }
#line 294
  i = 0;
  {
#line 294
  while (1) {
    while_continue: /* CIL Label */ ;
#line 294
    if (! (i < 6)) {
#line 294
      goto while_break;
    }
#line 295
    if ((int const   )*(ptr + 1) == 0) {
#line 295
      if (! ((int const   )*(ptr + 0) == (int const   )CDATA_LSQB___3[i])) {
#line 296
        *nextTokPtr = ptr;
#line 297
        return (0);
      }
    } else {
#line 296
      *nextTokPtr = ptr;
#line 297
      return (0);
    }
#line 294
    i ++;
#line 294
    ptr += 2;
  }
  while_break: /* CIL Label */ ;
  }
#line 300
  *nextTokPtr = ptr;
#line 301
  return (8);
}
}
#line 304 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmltok_impl.c"
static int little2_cdataSectionTok___0(ENCODING const   *enc , char const   *ptr ,
                                       char const   *end , char const   **nextTokPtr ) 
{ 
  size_t n ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 308
  if ((unsigned long )ptr == (unsigned long )end) {
#line 309
    return (-4);
  }
#line 311
  n = (size_t )(end - ptr);
#line 312
  if (n & 1UL) {
#line 313
    n &= 0xfffffffffffffffeUL;
#line 314
    if (n == 0UL) {
#line 315
      return (-1);
    }
#line 316
    end = ptr + n;
  }
#line 319
  if ((int const   )*(ptr + 1) == 0) {
#line 319
    tmp___0 = (int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr];
  } else {
    {
#line 319
    tmp = unicode_byte_type___0((char )*(ptr + 1), (char )*(ptr + 0));
#line 319
    tmp___0 = tmp;
    }
  }
  {
#line 320
  if (tmp___0 == 4) {
#line 320
    goto case_4;
  }
#line 335
  if (tmp___0 == 9) {
#line 335
    goto case_9;
  }
#line 343
  if (tmp___0 == 10) {
#line 343
    goto case_10;
  }
#line 346
  if (tmp___0 == 5) {
#line 346
    goto case_5;
  }
#line 346
  if (tmp___0 == 6) {
#line 346
    goto case_6;
  }
#line 346
  if (tmp___0 == 7) {
#line 346
    goto case_7;
  }
#line 346
  if (tmp___0 == 8) {
#line 346
    goto case_8;
  }
#line 346
  if (tmp___0 == 1) {
#line 346
    goto case_8;
  }
#line 346
  if (tmp___0 == 0) {
#line 346
    goto case_8;
  }
#line 347
  goto switch_default;
  case_4: /* CIL Label */ 
#line 321
  ptr += 2;
#line 322
  if ((unsigned long )ptr == (unsigned long )end) {
#line 323
    return (-1);
  }
#line 324
  if ((int const   )*(ptr + 1) == 0) {
#line 324
    if (! ((int const   )*(ptr + 0) == 93)) {
#line 325
      goto switch_break;
    }
  } else {
#line 325
    goto switch_break;
  }
#line 326
  ptr += 2;
#line 327
  if ((unsigned long )ptr == (unsigned long )end) {
#line 328
    return (-1);
  }
#line 329
  if ((int const   )*(ptr + 1) == 0) {
#line 329
    if (! ((int const   )*(ptr + 0) == 62)) {
#line 330
      ptr -= 2;
#line 331
      goto switch_break;
    }
  } else {
#line 330
    ptr -= 2;
#line 331
    goto switch_break;
  }
#line 333
  *nextTokPtr = ptr + 2;
#line 334
  return (40);
  case_9: /* CIL Label */ 
#line 336
  ptr += 2;
#line 337
  if ((unsigned long )ptr == (unsigned long )end) {
#line 338
    return (-1);
  }
#line 339
  if ((int const   )*(ptr + 1) == 0) {
#line 339
    tmp___2 = (int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr];
  } else {
    {
#line 339
    tmp___1 = unicode_byte_type___0((char )*(ptr + 1), (char )*(ptr + 0));
#line 339
    tmp___2 = tmp___1;
    }
  }
#line 339
  if (tmp___2 == 10) {
#line 340
    ptr += 2;
  }
#line 341
  *nextTokPtr = ptr;
#line 342
  return (7);
  case_10: /* CIL Label */ 
#line 344
  *nextTokPtr = ptr + 2;
#line 345
  return (7);
  case_5: /* CIL Label */ 
#line 346
  if (end - ptr < 2L) {
#line 346
    return (-2);
  }
#line 346
  ptr += 2;
#line 346
  goto switch_break;
  case_6: /* CIL Label */ 
#line 346
  if (end - ptr < 3L) {
#line 346
    return (-2);
  }
#line 346
  ptr += 3;
#line 346
  goto switch_break;
  case_7: /* CIL Label */ 
#line 346
  if (end - ptr < 4L) {
#line 346
    return (-2);
  }
#line 346
  ptr += 4;
#line 346
  goto switch_break;
  case_8: /* CIL Label */ 
  case_1: /* CIL Label */ 
  case_0: /* CIL Label */ 
#line 346
  *nextTokPtr = ptr;
#line 346
  return (0);
  switch_default: /* CIL Label */ 
#line 348
  ptr += 2;
#line 349
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 351
  while (1) {
    while_continue: /* CIL Label */ ;
#line 351
    if (! ((unsigned long )ptr != (unsigned long )end)) {
#line 351
      goto while_break;
    }
#line 352
    if ((int const   )*(ptr + 1) == 0) {
#line 352
      tmp___4 = (int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr];
    } else {
      {
#line 352
      tmp___3 = unicode_byte_type___0((char )*(ptr + 1), (char )*(ptr + 0));
#line 352
      tmp___4 = tmp___3;
      }
    }
    {
#line 361
    if (tmp___4 == 5) {
#line 361
      goto case_5___0;
    }
#line 361
    if (tmp___4 == 6) {
#line 361
      goto case_6___0;
    }
#line 361
    if (tmp___4 == 7) {
#line 361
      goto case_7___0;
    }
#line 368
    if (tmp___4 == 4) {
#line 368
      goto case_4___0;
    }
#line 368
    if (tmp___4 == 10) {
#line 368
      goto case_4___0;
    }
#line 368
    if (tmp___4 == 9) {
#line 368
      goto case_4___0;
    }
#line 368
    if (tmp___4 == 8) {
#line 368
      goto case_4___0;
    }
#line 368
    if (tmp___4 == 1) {
#line 368
      goto case_4___0;
    }
#line 368
    if (tmp___4 == 0) {
#line 368
      goto case_4___0;
    }
#line 371
    goto switch_default___0;
    case_5___0: /* CIL Label */ 
#line 361
    if (end - ptr < 2L) {
#line 361
      *nextTokPtr = ptr;
#line 361
      return (6);
    }
#line 361
    ptr += 2;
#line 361
    goto switch_break___0;
    case_6___0: /* CIL Label */ 
#line 361
    if (end - ptr < 3L) {
#line 361
      *nextTokPtr = ptr;
#line 361
      return (6);
    }
#line 361
    ptr += 3;
#line 361
    goto switch_break___0;
    case_7___0: /* CIL Label */ 
#line 361
    if (end - ptr < 4L) {
#line 361
      *nextTokPtr = ptr;
#line 361
      return (6);
    }
#line 361
    ptr += 4;
#line 361
    goto switch_break___0;
    case_4___0: /* CIL Label */ 
    case_10___0: /* CIL Label */ 
    case_9___0: /* CIL Label */ 
    case_8___0: /* CIL Label */ 
    case_1___0: /* CIL Label */ 
    case_0___0: /* CIL Label */ 
#line 369
    *nextTokPtr = ptr;
#line 370
    return (6);
    switch_default___0: /* CIL Label */ 
#line 372
    ptr += 2;
#line 373
    goto switch_break___0;
    switch_break___0: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 376
  *nextTokPtr = ptr;
#line 377
  return (6);
}
}
#line 382 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmltok_impl.c"
static int little2_scanEndTag___0(ENCODING const   *enc , char const   *ptr , char const   *end ,
                                  char const   **nextTokPtr ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 386
  if ((unsigned long )ptr == (unsigned long )end) {
#line 387
    return (-1);
  }
#line 388
  if ((int const   )*(ptr + 1) == 0) {
#line 388
    tmp___0 = (int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr];
  } else {
    {
#line 388
    tmp = unicode_byte_type___0((char )*(ptr + 1), (char )*(ptr + 0));
#line 388
    tmp___0 = tmp;
    }
  }
  {
#line 389
  if (tmp___0 == 29) {
#line 389
    goto case_29;
  }
#line 389
  if (tmp___0 == 24) {
#line 389
    goto case_24;
  }
#line 389
  if (tmp___0 == 22) {
#line 389
    goto case_24;
  }
#line 389
  if (tmp___0 == 5) {
#line 389
    goto case_5;
  }
#line 389
  if (tmp___0 == 6) {
#line 389
    goto case_6;
  }
#line 389
  if (tmp___0 == 7) {
#line 389
    goto case_7;
  }
#line 390
  goto switch_default;
  case_29: /* CIL Label */ 
#line 389
  if (! (namingBitmap___0[((int const   )nmstrtPages___0[(unsigned char )*(ptr + 1)] << 3) + (int const   )((int )((unsigned char )*(ptr + 0)) >> 5)] & (unsigned int const   )(1 << ((int )((unsigned char )*(ptr + 0)) & 31)))) {
#line 389
    *nextTokPtr = ptr;
#line 389
    return (0);
  }
  case_24: /* CIL Label */ 
  case_22: /* CIL Label */ 
#line 389
  ptr += 2;
#line 389
  goto switch_break;
  case_5: /* CIL Label */ 
#line 389
  if (end - ptr < 2L) {
#line 389
    return (-2);
  }
#line 389
  *nextTokPtr = ptr;
#line 389
  return (0);
#line 389
  ptr += 2;
#line 389
  goto switch_break;
  case_6: /* CIL Label */ 
#line 389
  if (end - ptr < 3L) {
#line 389
    return (-2);
  }
#line 389
  *nextTokPtr = ptr;
#line 389
  return (0);
#line 389
  ptr += 3;
#line 389
  goto switch_break;
  case_7: /* CIL Label */ 
#line 389
  if (end - ptr < 4L) {
#line 389
    return (-2);
  }
#line 389
  *nextTokPtr = ptr;
#line 389
  return (0);
#line 389
  ptr += 4;
#line 389
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 391
  *nextTokPtr = ptr;
#line 392
  return (0);
  switch_break: /* CIL Label */ ;
  }
  {
#line 394
  while (1) {
    while_continue: /* CIL Label */ ;
#line 394
    if (! ((unsigned long )ptr != (unsigned long )end)) {
#line 394
      goto while_break;
    }
#line 395
    if ((int const   )*(ptr + 1) == 0) {
#line 395
      tmp___2 = (int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr];
    } else {
      {
#line 395
      tmp___1 = unicode_byte_type___0((char )*(ptr + 1), (char )*(ptr + 0));
#line 395
      tmp___2 = tmp___1;
      }
    }
    {
#line 396
    if (tmp___2 == 29) {
#line 396
      goto case_29___0;
    }
#line 396
    if (tmp___2 == 27) {
#line 396
      goto case_27;
    }
#line 396
    if (tmp___2 == 26) {
#line 396
      goto case_27;
    }
#line 396
    if (tmp___2 == 25) {
#line 396
      goto case_27;
    }
#line 396
    if (tmp___2 == 24) {
#line 396
      goto case_27;
    }
#line 396
    if (tmp___2 == 22) {
#line 396
      goto case_27;
    }
#line 396
    if (tmp___2 == 5) {
#line 396
      goto case_5___0;
    }
#line 396
    if (tmp___2 == 6) {
#line 396
      goto case_6___0;
    }
#line 396
    if (tmp___2 == 7) {
#line 396
      goto case_7___0;
    }
#line 397
    if (tmp___2 == 10) {
#line 397
      goto case_10;
    }
#line 397
    if (tmp___2 == 9) {
#line 397
      goto case_10;
    }
#line 397
    if (tmp___2 == 21) {
#line 397
      goto case_10;
    }
#line 412
    if (tmp___2 == 23) {
#line 412
      goto case_23;
    }
#line 418
    if (tmp___2 == 11) {
#line 418
      goto case_11___0;
    }
#line 421
    goto switch_default___1;
    case_29___0: /* CIL Label */ 
#line 396
    if (! (namingBitmap___0[((int const   )namePages___0[(unsigned char )*(ptr + 1)] << 3) + (int const   )((int )((unsigned char )*(ptr + 0)) >> 5)] & (unsigned int const   )(1 << ((int )((unsigned char )*(ptr + 0)) & 31)))) {
#line 396
      *nextTokPtr = ptr;
#line 396
      return (0);
    }
    case_27: /* CIL Label */ 
    case_26: /* CIL Label */ 
    case_25: /* CIL Label */ 
    case_24___0: /* CIL Label */ 
    case_22___0: /* CIL Label */ 
#line 396
    ptr += 2;
#line 396
    goto switch_break___0;
    case_5___0: /* CIL Label */ 
#line 396
    if (end - ptr < 2L) {
#line 396
      return (-2);
    }
#line 396
    *nextTokPtr = ptr;
#line 396
    return (0);
#line 396
    ptr += 2;
#line 396
    goto switch_break___0;
    case_6___0: /* CIL Label */ 
#line 396
    if (end - ptr < 3L) {
#line 396
      return (-2);
    }
#line 396
    *nextTokPtr = ptr;
#line 396
    return (0);
#line 396
    ptr += 3;
#line 396
    goto switch_break___0;
    case_7___0: /* CIL Label */ 
#line 396
    if (end - ptr < 4L) {
#line 396
      return (-2);
    }
#line 396
    *nextTokPtr = ptr;
#line 396
    return (0);
#line 396
    ptr += 4;
#line 396
    goto switch_break___0;
    case_10: /* CIL Label */ 
    case_9: /* CIL Label */ 
    case_21: /* CIL Label */ 
#line 398
    ptr += 2;
    {
#line 398
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 398
      if (! ((unsigned long )ptr != (unsigned long )end)) {
#line 398
        goto while_break___0;
      }
#line 399
      if ((int const   )*(ptr + 1) == 0) {
#line 399
        tmp___4 = (int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr];
      } else {
        {
#line 399
        tmp___3 = unicode_byte_type___0((char )*(ptr + 1), (char )*(ptr + 0));
#line 399
        tmp___4 = tmp___3;
        }
      }
      {
#line 400
      if (tmp___4 == 10) {
#line 400
        goto case_10___0;
      }
#line 400
      if (tmp___4 == 9) {
#line 400
        goto case_10___0;
      }
#line 400
      if (tmp___4 == 21) {
#line 400
        goto case_10___0;
      }
#line 402
      if (tmp___4 == 11) {
#line 402
        goto case_11;
      }
#line 405
      goto switch_default___0;
      case_10___0: /* CIL Label */ 
      case_9___0: /* CIL Label */ 
      case_21___0: /* CIL Label */ 
#line 401
      goto switch_break___1;
      case_11: /* CIL Label */ 
#line 403
      *nextTokPtr = ptr + 2;
#line 404
      return (5);
      switch_default___0: /* CIL Label */ 
#line 406
      *nextTokPtr = ptr;
#line 407
      return (0);
      switch_break___1: /* CIL Label */ ;
      }
#line 398
      ptr += 2;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 410
    return (-1);
    case_23: /* CIL Label */ 
#line 415
    ptr += 2;
#line 416
    goto switch_break___0;
    case_11___0: /* CIL Label */ 
#line 419
    *nextTokPtr = ptr + 2;
#line 420
    return (5);
    switch_default___1: /* CIL Label */ 
#line 422
    *nextTokPtr = ptr;
#line 423
    return (0);
    switch_break___0: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 426
  return (-1);
}
}
#line 431 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmltok_impl.c"
static int little2_scanHexCharRef___0(ENCODING const   *enc , char const   *ptr ,
                                      char const   *end , char const   **nextTokPtr ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 435
  if ((unsigned long )ptr != (unsigned long )end) {
#line 436
    if ((int const   )*(ptr + 1) == 0) {
#line 436
      tmp___0 = (int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr];
    } else {
      {
#line 436
      tmp = unicode_byte_type___0((char )*(ptr + 1), (char )*(ptr + 0));
#line 436
      tmp___0 = tmp;
      }
    }
    {
#line 438
    if (tmp___0 == 24) {
#line 438
      goto case_24;
    }
#line 438
    if (tmp___0 == 25) {
#line 438
      goto case_24;
    }
#line 440
    goto switch_default;
    case_24: /* CIL Label */ 
    case_25: /* CIL Label */ 
#line 439
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 441
    *nextTokPtr = ptr;
#line 442
    return (0);
    switch_break: /* CIL Label */ ;
    }
#line 444
    ptr += 2;
    {
#line 444
    while (1) {
      while_continue: /* CIL Label */ ;
#line 444
      if (! ((unsigned long )ptr != (unsigned long )end)) {
#line 444
        goto while_break;
      }
#line 445
      if ((int const   )*(ptr + 1) == 0) {
#line 445
        tmp___2 = (int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr];
      } else {
        {
#line 445
        tmp___1 = unicode_byte_type___0((char )*(ptr + 1), (char )*(ptr + 0));
#line 445
        tmp___2 = tmp___1;
        }
      }
      {
#line 447
      if (tmp___2 == 24) {
#line 447
        goto case_24___0;
      }
#line 447
      if (tmp___2 == 25) {
#line 447
        goto case_24___0;
      }
#line 449
      if (tmp___2 == 18) {
#line 449
        goto case_18;
      }
#line 452
      goto switch_default___0;
      case_24___0: /* CIL Label */ 
      case_25___0: /* CIL Label */ 
#line 448
      goto switch_break___0;
      case_18: /* CIL Label */ 
#line 450
      *nextTokPtr = ptr + 2;
#line 451
      return (10);
      switch_default___0: /* CIL Label */ 
#line 453
      *nextTokPtr = ptr;
#line 454
      return (0);
      switch_break___0: /* CIL Label */ ;
      }
#line 444
      ptr += 2;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 458
  return (-1);
}
}
#line 463 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmltok_impl.c"
static int little2_scanCharRef___0(ENCODING const   *enc , char const   *ptr , char const   *end ,
                                   char const   **nextTokPtr ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 467
  if ((unsigned long )ptr != (unsigned long )end) {
#line 468
    if ((int const   )*(ptr + 1) == 0) {
#line 468
      if ((int const   )*(ptr + 0) == 120) {
        {
#line 469
        tmp = little2_scanHexCharRef___0(enc, ptr + 2, end, nextTokPtr);
        }
#line 469
        return (tmp);
      }
    }
#line 470
    if ((int const   )*(ptr + 1) == 0) {
#line 470
      tmp___1 = (int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr];
    } else {
      {
#line 470
      tmp___0 = unicode_byte_type___0((char )*(ptr + 1), (char )*(ptr + 0));
#line 470
      tmp___1 = tmp___0;
      }
    }
    {
#line 471
    if (tmp___1 == 25) {
#line 471
      goto case_25;
    }
#line 473
    goto switch_default;
    case_25: /* CIL Label */ 
#line 472
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 474
    *nextTokPtr = ptr;
#line 475
    return (0);
    switch_break: /* CIL Label */ ;
    }
#line 477
    ptr += 2;
    {
#line 477
    while (1) {
      while_continue: /* CIL Label */ ;
#line 477
      if (! ((unsigned long )ptr != (unsigned long )end)) {
#line 477
        goto while_break;
      }
#line 478
      if ((int const   )*(ptr + 1) == 0) {
#line 478
        tmp___3 = (int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr];
      } else {
        {
#line 478
        tmp___2 = unicode_byte_type___0((char )*(ptr + 1), (char )*(ptr + 0));
#line 478
        tmp___3 = tmp___2;
        }
      }
      {
#line 479
      if (tmp___3 == 25) {
#line 479
        goto case_25___0;
      }
#line 481
      if (tmp___3 == 18) {
#line 481
        goto case_18;
      }
#line 484
      goto switch_default___0;
      case_25___0: /* CIL Label */ 
#line 480
      goto switch_break___0;
      case_18: /* CIL Label */ 
#line 482
      *nextTokPtr = ptr + 2;
#line 483
      return (10);
      switch_default___0: /* CIL Label */ 
#line 485
      *nextTokPtr = ptr;
#line 486
      return (0);
      switch_break___0: /* CIL Label */ ;
      }
#line 477
      ptr += 2;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 490
  return (-1);
}
}
#line 495 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmltok_impl.c"
static int little2_scanRef___0(ENCODING const   *enc , char const   *ptr , char const   *end ,
                               char const   **nextTokPtr ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 499
  if ((unsigned long )ptr == (unsigned long )end) {
#line 500
    return (-1);
  }
#line 501
  if ((int const   )*(ptr + 1) == 0) {
#line 501
    tmp___0 = (int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr];
  } else {
    {
#line 501
    tmp = unicode_byte_type___0((char )*(ptr + 1), (char )*(ptr + 0));
#line 501
    tmp___0 = tmp;
    }
  }
  {
#line 502
  if (tmp___0 == 29) {
#line 502
    goto case_29;
  }
#line 502
  if (tmp___0 == 24) {
#line 502
    goto case_24;
  }
#line 502
  if (tmp___0 == 22) {
#line 502
    goto case_24;
  }
#line 502
  if (tmp___0 == 5) {
#line 502
    goto case_5;
  }
#line 502
  if (tmp___0 == 6) {
#line 502
    goto case_6;
  }
#line 502
  if (tmp___0 == 7) {
#line 502
    goto case_7;
  }
#line 503
  if (tmp___0 == 19) {
#line 503
    goto case_19;
  }
#line 505
  goto switch_default;
  case_29: /* CIL Label */ 
#line 502
  if (! (namingBitmap___0[((int const   )nmstrtPages___0[(unsigned char )*(ptr + 1)] << 3) + (int const   )((int )((unsigned char )*(ptr + 0)) >> 5)] & (unsigned int const   )(1 << ((int )((unsigned char )*(ptr + 0)) & 31)))) {
#line 502
    *nextTokPtr = ptr;
#line 502
    return (0);
  }
  case_24: /* CIL Label */ 
  case_22: /* CIL Label */ 
#line 502
  ptr += 2;
#line 502
  goto switch_break;
  case_5: /* CIL Label */ 
#line 502
  if (end - ptr < 2L) {
#line 502
    return (-2);
  }
#line 502
  *nextTokPtr = ptr;
#line 502
  return (0);
#line 502
  ptr += 2;
#line 502
  goto switch_break;
  case_6: /* CIL Label */ 
#line 502
  if (end - ptr < 3L) {
#line 502
    return (-2);
  }
#line 502
  *nextTokPtr = ptr;
#line 502
  return (0);
#line 502
  ptr += 3;
#line 502
  goto switch_break;
  case_7: /* CIL Label */ 
#line 502
  if (end - ptr < 4L) {
#line 502
    return (-2);
  }
#line 502
  *nextTokPtr = ptr;
#line 502
  return (0);
#line 502
  ptr += 4;
#line 502
  goto switch_break;
  case_19: /* CIL Label */ 
  {
#line 504
  tmp___1 = little2_scanCharRef___0(enc, ptr + 2, end, nextTokPtr);
  }
#line 504
  return (tmp___1);
  switch_default: /* CIL Label */ 
#line 506
  *nextTokPtr = ptr;
#line 507
  return (0);
  switch_break: /* CIL Label */ ;
  }
  {
#line 509
  while (1) {
    while_continue: /* CIL Label */ ;
#line 509
    if (! ((unsigned long )ptr != (unsigned long )end)) {
#line 509
      goto while_break;
    }
#line 510
    if ((int const   )*(ptr + 1) == 0) {
#line 510
      tmp___3 = (int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr];
    } else {
      {
#line 510
      tmp___2 = unicode_byte_type___0((char )*(ptr + 1), (char )*(ptr + 0));
#line 510
      tmp___3 = tmp___2;
      }
    }
    {
#line 511
    if (tmp___3 == 29) {
#line 511
      goto case_29___0;
    }
#line 511
    if (tmp___3 == 27) {
#line 511
      goto case_27;
    }
#line 511
    if (tmp___3 == 26) {
#line 511
      goto case_27;
    }
#line 511
    if (tmp___3 == 25) {
#line 511
      goto case_27;
    }
#line 511
    if (tmp___3 == 24) {
#line 511
      goto case_27;
    }
#line 511
    if (tmp___3 == 22) {
#line 511
      goto case_27;
    }
#line 511
    if (tmp___3 == 5) {
#line 511
      goto case_5___0;
    }
#line 511
    if (tmp___3 == 6) {
#line 511
      goto case_6___0;
    }
#line 511
    if (tmp___3 == 7) {
#line 511
      goto case_7___0;
    }
#line 512
    if (tmp___3 == 18) {
#line 512
      goto case_18;
    }
#line 515
    goto switch_default___0;
    case_29___0: /* CIL Label */ 
#line 511
    if (! (namingBitmap___0[((int const   )namePages___0[(unsigned char )*(ptr + 1)] << 3) + (int const   )((int )((unsigned char )*(ptr + 0)) >> 5)] & (unsigned int const   )(1 << ((int )((unsigned char )*(ptr + 0)) & 31)))) {
#line 511
      *nextTokPtr = ptr;
#line 511
      return (0);
    }
    case_27: /* CIL Label */ 
    case_26: /* CIL Label */ 
    case_25: /* CIL Label */ 
    case_24___0: /* CIL Label */ 
    case_22___0: /* CIL Label */ 
#line 511
    ptr += 2;
#line 511
    goto switch_break___0;
    case_5___0: /* CIL Label */ 
#line 511
    if (end - ptr < 2L) {
#line 511
      return (-2);
    }
#line 511
    *nextTokPtr = ptr;
#line 511
    return (0);
#line 511
    ptr += 2;
#line 511
    goto switch_break___0;
    case_6___0: /* CIL Label */ 
#line 511
    if (end - ptr < 3L) {
#line 511
      return (-2);
    }
#line 511
    *nextTokPtr = ptr;
#line 511
    return (0);
#line 511
    ptr += 3;
#line 511
    goto switch_break___0;
    case_7___0: /* CIL Label */ 
#line 511
    if (end - ptr < 4L) {
#line 511
      return (-2);
    }
#line 511
    *nextTokPtr = ptr;
#line 511
    return (0);
#line 511
    ptr += 4;
#line 511
    goto switch_break___0;
    case_18: /* CIL Label */ 
#line 513
    *nextTokPtr = ptr + 2;
#line 514
    return (9);
    switch_default___0: /* CIL Label */ 
#line 516
    *nextTokPtr = ptr;
#line 517
    return (0);
    switch_break___0: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 520
  return (-1);
}
}
#line 525 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmltok_impl.c"
static int little2_scanAtts___0(ENCODING const   *enc , char const   *ptr , char const   *end ,
                                char const   **nextTokPtr ) 
{ 
  int hadColon ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int t ;
  int tmp___3 ;
  int open___0 ;
  int tmp___4 ;
  int t___0 ;
  int tmp___5 ;
  int tok ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;

  {
#line 530
  hadColon = 0;
  {
#line 532
  while (1) {
    while_continue: /* CIL Label */ ;
#line 532
    if (! ((unsigned long )ptr != (unsigned long )end)) {
#line 532
      goto while_break;
    }
#line 533
    if ((int const   )*(ptr + 1) == 0) {
#line 533
      tmp___0 = (int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr];
    } else {
      {
#line 533
      tmp = unicode_byte_type___0((char )*(ptr + 1), (char )*(ptr + 0));
#line 533
      tmp___0 = tmp;
      }
    }
    {
#line 534
    if (tmp___0 == 29) {
#line 534
      goto case_29;
    }
#line 534
    if (tmp___0 == 27) {
#line 534
      goto case_27;
    }
#line 534
    if (tmp___0 == 26) {
#line 534
      goto case_27;
    }
#line 534
    if (tmp___0 == 25) {
#line 534
      goto case_27;
    }
#line 534
    if (tmp___0 == 24) {
#line 534
      goto case_27;
    }
#line 534
    if (tmp___0 == 22) {
#line 534
      goto case_27;
    }
#line 534
    if (tmp___0 == 5) {
#line 534
      goto case_5;
    }
#line 534
    if (tmp___0 == 6) {
#line 534
      goto case_6;
    }
#line 534
    if (tmp___0 == 7) {
#line 534
      goto case_7;
    }
#line 536
    if (tmp___0 == 23) {
#line 536
      goto case_23;
    }
#line 553
    if (tmp___0 == 10) {
#line 553
      goto case_10;
    }
#line 553
    if (tmp___0 == 9) {
#line 553
      goto case_10;
    }
#line 553
    if (tmp___0 == 21) {
#line 553
      goto case_10;
    }
#line 574
    if (tmp___0 == 14) {
#line 574
      goto case_14;
    }
#line 674
    goto switch_default___5;
    case_29: /* CIL Label */ 
#line 534
    if (! (namingBitmap___0[((int const   )namePages___0[(unsigned char )*(ptr + 1)] << 3) + (int const   )((int )((unsigned char )*(ptr + 0)) >> 5)] & (unsigned int const   )(1 << ((int )((unsigned char )*(ptr + 0)) & 31)))) {
#line 534
      *nextTokPtr = ptr;
#line 534
      return (0);
    }
    case_27: /* CIL Label */ 
    case_26: /* CIL Label */ 
    case_25: /* CIL Label */ 
    case_24: /* CIL Label */ 
    case_22: /* CIL Label */ 
#line 534
    ptr += 2;
#line 534
    goto switch_break;
    case_5: /* CIL Label */ 
#line 534
    if (end - ptr < 2L) {
#line 534
      return (-2);
    }
#line 534
    *nextTokPtr = ptr;
#line 534
    return (0);
#line 534
    ptr += 2;
#line 534
    goto switch_break;
    case_6: /* CIL Label */ 
#line 534
    if (end - ptr < 3L) {
#line 534
      return (-2);
    }
#line 534
    *nextTokPtr = ptr;
#line 534
    return (0);
#line 534
    ptr += 3;
#line 534
    goto switch_break;
    case_7: /* CIL Label */ 
#line 534
    if (end - ptr < 4L) {
#line 534
      return (-2);
    }
#line 534
    *nextTokPtr = ptr;
#line 534
    return (0);
#line 534
    ptr += 4;
#line 534
    goto switch_break;
    case_23: /* CIL Label */ 
#line 537
    if (hadColon) {
#line 538
      *nextTokPtr = ptr;
#line 539
      return (0);
    }
#line 541
    hadColon = 1;
#line 542
    ptr += 2;
#line 543
    if ((unsigned long )ptr == (unsigned long )end) {
#line 544
      return (-1);
    }
#line 545
    if ((int const   )*(ptr + 1) == 0) {
#line 545
      tmp___2 = (int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr];
    } else {
      {
#line 545
      tmp___1 = unicode_byte_type___0((char )*(ptr + 1), (char )*(ptr + 0));
#line 545
      tmp___2 = tmp___1;
      }
    }
    {
#line 546
    if (tmp___2 == 29) {
#line 546
      goto case_29___0;
    }
#line 546
    if (tmp___2 == 24) {
#line 546
      goto case_24___0;
    }
#line 546
    if (tmp___2 == 22) {
#line 546
      goto case_24___0;
    }
#line 546
    if (tmp___2 == 5) {
#line 546
      goto case_5___0;
    }
#line 546
    if (tmp___2 == 6) {
#line 546
      goto case_6___0;
    }
#line 546
    if (tmp___2 == 7) {
#line 546
      goto case_7___0;
    }
#line 547
    goto switch_default;
    case_29___0: /* CIL Label */ 
#line 546
    if (! (namingBitmap___0[((int const   )nmstrtPages___0[(unsigned char )*(ptr + 1)] << 3) + (int const   )((int )((unsigned char )*(ptr + 0)) >> 5)] & (unsigned int const   )(1 << ((int )((unsigned char )*(ptr + 0)) & 31)))) {
#line 546
      *nextTokPtr = ptr;
#line 546
      return (0);
    }
    case_24___0: /* CIL Label */ 
    case_22___0: /* CIL Label */ 
#line 546
    ptr += 2;
#line 546
    goto switch_break___0;
    case_5___0: /* CIL Label */ 
#line 546
    if (end - ptr < 2L) {
#line 546
      return (-2);
    }
#line 546
    *nextTokPtr = ptr;
#line 546
    return (0);
#line 546
    ptr += 2;
#line 546
    goto switch_break___0;
    case_6___0: /* CIL Label */ 
#line 546
    if (end - ptr < 3L) {
#line 546
      return (-2);
    }
#line 546
    *nextTokPtr = ptr;
#line 546
    return (0);
#line 546
    ptr += 3;
#line 546
    goto switch_break___0;
    case_7___0: /* CIL Label */ 
#line 546
    if (end - ptr < 4L) {
#line 546
      return (-2);
    }
#line 546
    *nextTokPtr = ptr;
#line 546
    return (0);
#line 546
    ptr += 4;
#line 546
    goto switch_break___0;
    switch_default: /* CIL Label */ 
#line 548
    *nextTokPtr = ptr;
#line 549
    return (0);
    switch_break___0: /* CIL Label */ ;
    }
#line 551
    goto switch_break;
    case_10: /* CIL Label */ 
    case_9: /* CIL Label */ 
    case_21: /* CIL Label */ 
    {
#line 554
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 557
      ptr += 2;
#line 558
      if ((unsigned long )ptr == (unsigned long )end) {
#line 559
        return (-1);
      }
#line 560
      if ((int const   )*(ptr + 1) == 0) {
#line 560
        t = (int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr];
      } else {
        {
#line 560
        tmp___3 = unicode_byte_type___0((char )*(ptr + 1), (char )*(ptr + 0));
#line 560
        t = tmp___3;
        }
      }
#line 561
      if (t == 14) {
#line 562
        goto while_break___0;
      }
      {
#line 566
      if (t == 9) {
#line 566
        goto case_9___0;
      }
#line 566
      if (t == 10) {
#line 566
        goto case_9___0;
      }
#line 566
      if (t == 21) {
#line 566
        goto case_9___0;
      }
#line 568
      goto switch_default___0;
      case_9___0: /* CIL Label */ 
      case_10___0: /* CIL Label */ 
      case_21___0: /* CIL Label */ 
#line 567
      goto switch_break___1;
      switch_default___0: /* CIL Label */ 
#line 569
      *nextTokPtr = ptr;
#line 570
      return (0);
      switch_break___1: /* CIL Label */ ;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    case_14: /* CIL Label */ 
#line 578
    hadColon = 0;
    {
#line 580
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 581
      ptr += 2;
#line 582
      if ((unsigned long )ptr == (unsigned long )end) {
#line 583
        return (-1);
      }
#line 584
      if ((int const   )*(ptr + 1) == 0) {
#line 584
        open___0 = (int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr];
      } else {
        {
#line 584
        tmp___4 = unicode_byte_type___0((char )*(ptr + 1), (char )*(ptr + 0));
#line 584
        open___0 = tmp___4;
        }
      }
#line 585
      if (open___0 == 12) {
#line 586
        goto while_break___1;
      } else
#line 585
      if (open___0 == 13) {
#line 586
        goto while_break___1;
      }
      {
#line 590
      if (open___0 == 9) {
#line 590
        goto case_9___1;
      }
#line 590
      if (open___0 == 10) {
#line 590
        goto case_9___1;
      }
#line 590
      if (open___0 == 21) {
#line 590
        goto case_9___1;
      }
#line 592
      goto switch_default___1;
      case_9___1: /* CIL Label */ 
      case_10___1: /* CIL Label */ 
      case_21___1: /* CIL Label */ 
#line 591
      goto switch_break___2;
      switch_default___1: /* CIL Label */ 
#line 593
      *nextTokPtr = ptr;
#line 594
      return (0);
      switch_break___2: /* CIL Label */ ;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
#line 597
    ptr += 2;
    {
#line 599
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 601
      if ((unsigned long )ptr == (unsigned long )end) {
#line 602
        return (-1);
      }
#line 603
      if ((int const   )*(ptr + 1) == 0) {
#line 603
        t___0 = (int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr];
      } else {
        {
#line 603
        tmp___5 = unicode_byte_type___0((char )*(ptr + 1), (char )*(ptr + 0));
#line 603
        t___0 = tmp___5;
        }
      }
#line 604
      if (t___0 == open___0) {
#line 605
        goto while_break___2;
      }
      {
#line 607
      if (t___0 == 5) {
#line 607
        goto case_5___1;
      }
#line 607
      if (t___0 == 6) {
#line 607
        goto case_6___1;
      }
#line 607
      if (t___0 == 7) {
#line 607
        goto case_7___1;
      }
#line 607
      if (t___0 == 8) {
#line 607
        goto case_8;
      }
#line 607
      if (t___0 == 1) {
#line 607
        goto case_8;
      }
#line 607
      if (t___0 == 0) {
#line 607
        goto case_8;
      }
#line 608
      if (t___0 == 3) {
#line 608
        goto case_3;
      }
#line 618
      if (t___0 == 2) {
#line 618
        goto case_2;
      }
#line 621
      goto switch_default___2;
      case_5___1: /* CIL Label */ 
#line 607
      if (end - ptr < 2L) {
#line 607
        return (-2);
      }
#line 607
      ptr += 2;
#line 607
      goto switch_break___3;
      case_6___1: /* CIL Label */ 
#line 607
      if (end - ptr < 3L) {
#line 607
        return (-2);
      }
#line 607
      ptr += 3;
#line 607
      goto switch_break___3;
      case_7___1: /* CIL Label */ 
#line 607
      if (end - ptr < 4L) {
#line 607
        return (-2);
      }
#line 607
      ptr += 4;
#line 607
      goto switch_break___3;
      case_8: /* CIL Label */ 
      case_1: /* CIL Label */ 
      case_0: /* CIL Label */ 
#line 607
      *nextTokPtr = ptr;
#line 607
      return (0);
      case_3: /* CIL Label */ 
      {
#line 610
      tmp___6 = little2_scanRef___0(enc, ptr + 2, end, & ptr);
#line 610
      tok = tmp___6;
      }
#line 611
      if (tok <= 0) {
#line 612
        if (tok == 0) {
#line 613
          *nextTokPtr = ptr;
        }
#line 614
        return (tok);
      }
#line 616
      goto switch_break___3;
      case_2: /* CIL Label */ 
#line 619
      *nextTokPtr = ptr;
#line 620
      return (0);
      switch_default___2: /* CIL Label */ 
#line 622
      ptr += 2;
#line 623
      goto switch_break___3;
      switch_break___3: /* CIL Label */ ;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
#line 626
    ptr += 2;
#line 627
    if ((unsigned long )ptr == (unsigned long )end) {
#line 628
      return (-1);
    }
#line 629
    if ((int const   )*(ptr + 1) == 0) {
#line 629
      tmp___8 = (int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr];
    } else {
      {
#line 629
      tmp___7 = unicode_byte_type___0((char )*(ptr + 1), (char )*(ptr + 0));
#line 629
      tmp___8 = tmp___7;
      }
    }
    {
#line 632
    if (tmp___8 == 10) {
#line 632
      goto case_10___2;
    }
#line 632
    if (tmp___8 == 9) {
#line 632
      goto case_10___2;
    }
#line 632
    if (tmp___8 == 21) {
#line 632
      goto case_10___2;
    }
#line 634
    if (tmp___8 == 17) {
#line 634
      goto case_17;
    }
#line 636
    if (tmp___8 == 11) {
#line 636
      goto case_11;
    }
#line 638
    goto switch_default___3;
    case_10___2: /* CIL Label */ 
    case_9___2: /* CIL Label */ 
    case_21___2: /* CIL Label */ 
#line 633
    goto switch_break___4;
    case_17: /* CIL Label */ 
#line 635
    goto sol;
    case_11: /* CIL Label */ 
#line 637
    goto gt;
    switch_default___3: /* CIL Label */ 
#line 639
    *nextTokPtr = ptr;
#line 640
    return (0);
    switch_break___4: /* CIL Label */ ;
    }
    {
#line 643
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 644
      ptr += 2;
#line 645
      if ((unsigned long )ptr == (unsigned long )end) {
#line 646
        return (-1);
      }
#line 647
      if ((int const   )*(ptr + 1) == 0) {
#line 647
        tmp___10 = (int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr];
      } else {
        {
#line 647
        tmp___9 = unicode_byte_type___0((char )*(ptr + 1), (char )*(ptr + 0));
#line 647
        tmp___10 = tmp___9;
        }
      }
      {
#line 648
      if (tmp___10 == 29) {
#line 648
        goto case_29___1;
      }
#line 648
      if (tmp___10 == 24) {
#line 648
        goto case_24___1;
      }
#line 648
      if (tmp___10 == 22) {
#line 648
        goto case_24___1;
      }
#line 648
      if (tmp___10 == 5) {
#line 648
        goto case_5___2;
      }
#line 648
      if (tmp___10 == 6) {
#line 648
        goto case_6___2;
      }
#line 648
      if (tmp___10 == 7) {
#line 648
        goto case_7___2;
      }
#line 649
      if (tmp___10 == 10) {
#line 649
        goto case_10___3;
      }
#line 649
      if (tmp___10 == 9) {
#line 649
        goto case_10___3;
      }
#line 649
      if (tmp___10 == 21) {
#line 649
        goto case_10___3;
      }
#line 651
      if (tmp___10 == 11) {
#line 651
        goto gt;
      }
#line 655
      if (tmp___10 == 17) {
#line 655
        goto sol;
      }
#line 666
      goto switch_default___4;
      case_29___1: /* CIL Label */ 
#line 648
      if (! (namingBitmap___0[((int const   )nmstrtPages___0[(unsigned char )*(ptr + 1)] << 3) + (int const   )((int )((unsigned char )*(ptr + 0)) >> 5)] & (unsigned int const   )(1 << ((int )((unsigned char )*(ptr + 0)) & 31)))) {
#line 648
        *nextTokPtr = ptr;
#line 648
        return (0);
      }
      case_24___1: /* CIL Label */ 
      case_22___1: /* CIL Label */ 
#line 648
      ptr += 2;
#line 648
      goto switch_break___5;
      case_5___2: /* CIL Label */ 
#line 648
      if (end - ptr < 2L) {
#line 648
        return (-2);
      }
#line 648
      *nextTokPtr = ptr;
#line 648
      return (0);
#line 648
      ptr += 2;
#line 648
      goto switch_break___5;
      case_6___2: /* CIL Label */ 
#line 648
      if (end - ptr < 3L) {
#line 648
        return (-2);
      }
#line 648
      *nextTokPtr = ptr;
#line 648
      return (0);
#line 648
      ptr += 3;
#line 648
      goto switch_break___5;
      case_7___2: /* CIL Label */ 
#line 648
      if (end - ptr < 4L) {
#line 648
        return (-2);
      }
#line 648
      *nextTokPtr = ptr;
#line 648
      return (0);
#line 648
      ptr += 4;
#line 648
      goto switch_break___5;
      case_10___3: /* CIL Label */ 
      case_9___3: /* CIL Label */ 
      case_21___3: /* CIL Label */ 
#line 650
      goto __Cont;
      gt: 
      case_11___0: /* CIL Label */ 
#line 653
      *nextTokPtr = ptr + 2;
#line 654
      return (1);
      sol: 
      case_17___0: /* CIL Label */ 
#line 657
      ptr += 2;
#line 658
      if ((unsigned long )ptr == (unsigned long )end) {
#line 659
        return (-1);
      }
#line 660
      if ((int const   )*(ptr + 1) == 0) {
#line 660
        if (! ((int const   )*(ptr + 0) == 62)) {
#line 661
          *nextTokPtr = ptr;
#line 662
          return (0);
        }
      } else {
#line 661
        *nextTokPtr = ptr;
#line 662
        return (0);
      }
#line 664
      *nextTokPtr = ptr + 2;
#line 665
      return (3);
      switch_default___4: /* CIL Label */ 
#line 667
      *nextTokPtr = ptr;
#line 668
      return (0);
      switch_break___5: /* CIL Label */ ;
      }
#line 670
      goto while_break___3;
      __Cont: /* CIL Label */ ;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 672
    goto switch_break;
    switch_default___5: /* CIL Label */ 
#line 675
    *nextTokPtr = ptr;
#line 676
    return (0);
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 679
  return (-1);
}
}
#line 684 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmltok_impl.c"
static int little2_scanLt___0(ENCODING const   *enc , char const   *ptr , char const   *end ,
                              char const   **nextTokPtr ) 
{ 
  int hadColon ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;

  {
#line 691
  if ((unsigned long )ptr == (unsigned long )end) {
#line 692
    return (-1);
  }
#line 693
  if ((int const   )*(ptr + 1) == 0) {
#line 693
    tmp___0 = (int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr];
  } else {
    {
#line 693
    tmp = unicode_byte_type___0((char )*(ptr + 1), (char )*(ptr + 0));
#line 693
    tmp___0 = tmp;
    }
  }
  {
#line 694
  if (tmp___0 == 29) {
#line 694
    goto case_29;
  }
#line 694
  if (tmp___0 == 24) {
#line 694
    goto case_24;
  }
#line 694
  if (tmp___0 == 22) {
#line 694
    goto case_24;
  }
#line 694
  if (tmp___0 == 5) {
#line 694
    goto case_5;
  }
#line 694
  if (tmp___0 == 6) {
#line 694
    goto case_6;
  }
#line 694
  if (tmp___0 == 7) {
#line 694
    goto case_7;
  }
#line 695
  if (tmp___0 == 16) {
#line 695
    goto case_16;
  }
#line 707
  if (tmp___0 == 15) {
#line 707
    goto case_15;
  }
#line 709
  if (tmp___0 == 17) {
#line 709
    goto case_17;
  }
#line 711
  goto switch_default;
  case_29: /* CIL Label */ 
#line 694
  if (! (namingBitmap___0[((int const   )nmstrtPages___0[(unsigned char )*(ptr + 1)] << 3) + (int const   )((int )((unsigned char )*(ptr + 0)) >> 5)] & (unsigned int const   )(1 << ((int )((unsigned char )*(ptr + 0)) & 31)))) {
#line 694
    *nextTokPtr = ptr;
#line 694
    return (0);
  }
  case_24: /* CIL Label */ 
  case_22: /* CIL Label */ 
#line 694
  ptr += 2;
#line 694
  goto switch_break;
  case_5: /* CIL Label */ 
#line 694
  if (end - ptr < 2L) {
#line 694
    return (-2);
  }
#line 694
  *nextTokPtr = ptr;
#line 694
  return (0);
#line 694
  ptr += 2;
#line 694
  goto switch_break;
  case_6: /* CIL Label */ 
#line 694
  if (end - ptr < 3L) {
#line 694
    return (-2);
  }
#line 694
  *nextTokPtr = ptr;
#line 694
  return (0);
#line 694
  ptr += 3;
#line 694
  goto switch_break;
  case_7: /* CIL Label */ 
#line 694
  if (end - ptr < 4L) {
#line 694
    return (-2);
  }
#line 694
  *nextTokPtr = ptr;
#line 694
  return (0);
#line 694
  ptr += 4;
#line 694
  goto switch_break;
  case_16: /* CIL Label */ 
#line 696
  ptr += 2;
#line 696
  if ((unsigned long )ptr == (unsigned long )end) {
#line 697
    return (-1);
  }
#line 698
  if ((int const   )*(ptr + 1) == 0) {
#line 698
    tmp___2 = (int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr];
  } else {
    {
#line 698
    tmp___1 = unicode_byte_type___0((char )*(ptr + 1), (char )*(ptr + 0));
#line 698
    tmp___2 = tmp___1;
    }
  }
  {
#line 699
  if (tmp___2 == 27) {
#line 699
    goto case_27;
  }
#line 701
  if (tmp___2 == 20) {
#line 701
    goto case_20;
  }
#line 698
  goto switch_break___0;
  case_27: /* CIL Label */ 
  {
#line 700
  tmp___3 = little2_scanComment___0(enc, ptr + 2, end, nextTokPtr);
  }
#line 700
  return (tmp___3);
  case_20: /* CIL Label */ 
  {
#line 702
  tmp___4 = little2_scanCdataSection___0(enc, ptr + 2, end, nextTokPtr);
  }
#line 702
  return (tmp___4);
  switch_break___0: /* CIL Label */ ;
  }
#line 705
  *nextTokPtr = ptr;
#line 706
  return (0);
  case_15: /* CIL Label */ 
  {
#line 708
  tmp___5 = little2_scanPi___0(enc, ptr + 2, end, nextTokPtr);
  }
#line 708
  return (tmp___5);
  case_17: /* CIL Label */ 
  {
#line 710
  tmp___6 = little2_scanEndTag___0(enc, ptr + 2, end, nextTokPtr);
  }
#line 710
  return (tmp___6);
  switch_default: /* CIL Label */ 
#line 712
  *nextTokPtr = ptr;
#line 713
  return (0);
  switch_break: /* CIL Label */ ;
  }
#line 716
  hadColon = 0;
  {
#line 719
  while (1) {
    while_continue: /* CIL Label */ ;
#line 719
    if (! ((unsigned long )ptr != (unsigned long )end)) {
#line 719
      goto while_break;
    }
#line 720
    if ((int const   )*(ptr + 1) == 0) {
#line 720
      tmp___8 = (int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr];
    } else {
      {
#line 720
      tmp___7 = unicode_byte_type___0((char )*(ptr + 1), (char )*(ptr + 0));
#line 720
      tmp___8 = tmp___7;
      }
    }
    {
#line 721
    if (tmp___8 == 29) {
#line 721
      goto case_29___0;
    }
#line 721
    if (tmp___8 == 27) {
#line 721
      goto case_27___0;
    }
#line 721
    if (tmp___8 == 26) {
#line 721
      goto case_27___0;
    }
#line 721
    if (tmp___8 == 25) {
#line 721
      goto case_27___0;
    }
#line 721
    if (tmp___8 == 24) {
#line 721
      goto case_27___0;
    }
#line 721
    if (tmp___8 == 22) {
#line 721
      goto case_27___0;
    }
#line 721
    if (tmp___8 == 5) {
#line 721
      goto case_5___0;
    }
#line 721
    if (tmp___8 == 6) {
#line 721
      goto case_6___0;
    }
#line 721
    if (tmp___8 == 7) {
#line 721
      goto case_7___0;
    }
#line 723
    if (tmp___8 == 23) {
#line 723
      goto case_23;
    }
#line 740
    if (tmp___8 == 10) {
#line 740
      goto case_10;
    }
#line 740
    if (tmp___8 == 9) {
#line 740
      goto case_10;
    }
#line 740
    if (tmp___8 == 21) {
#line 740
      goto case_10;
    }
#line 761
    if (tmp___8 == 11) {
#line 761
      goto gt;
    }
#line 765
    if (tmp___8 == 17) {
#line 765
      goto sol;
    }
#line 776
    goto switch_default___2;
    case_29___0: /* CIL Label */ 
#line 721
    if (! (namingBitmap___0[((int const   )namePages___0[(unsigned char )*(ptr + 1)] << 3) + (int const   )((int )((unsigned char )*(ptr + 0)) >> 5)] & (unsigned int const   )(1 << ((int )((unsigned char )*(ptr + 0)) & 31)))) {
#line 721
      *nextTokPtr = ptr;
#line 721
      return (0);
    }
    case_27___0: /* CIL Label */ 
    case_26: /* CIL Label */ 
    case_25: /* CIL Label */ 
    case_24___0: /* CIL Label */ 
    case_22___0: /* CIL Label */ 
#line 721
    ptr += 2;
#line 721
    goto switch_break___1;
    case_5___0: /* CIL Label */ 
#line 721
    if (end - ptr < 2L) {
#line 721
      return (-2);
    }
#line 721
    *nextTokPtr = ptr;
#line 721
    return (0);
#line 721
    ptr += 2;
#line 721
    goto switch_break___1;
    case_6___0: /* CIL Label */ 
#line 721
    if (end - ptr < 3L) {
#line 721
      return (-2);
    }
#line 721
    *nextTokPtr = ptr;
#line 721
    return (0);
#line 721
    ptr += 3;
#line 721
    goto switch_break___1;
    case_7___0: /* CIL Label */ 
#line 721
    if (end - ptr < 4L) {
#line 721
      return (-2);
    }
#line 721
    *nextTokPtr = ptr;
#line 721
    return (0);
#line 721
    ptr += 4;
#line 721
    goto switch_break___1;
    case_23: /* CIL Label */ 
#line 724
    if (hadColon) {
#line 725
      *nextTokPtr = ptr;
#line 726
      return (0);
    }
#line 728
    hadColon = 1;
#line 729
    ptr += 2;
#line 730
    if ((unsigned long )ptr == (unsigned long )end) {
#line 731
      return (-1);
    }
#line 732
    if ((int const   )*(ptr + 1) == 0) {
#line 732
      tmp___10 = (int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr];
    } else {
      {
#line 732
      tmp___9 = unicode_byte_type___0((char )*(ptr + 1), (char )*(ptr + 0));
#line 732
      tmp___10 = tmp___9;
      }
    }
    {
#line 733
    if (tmp___10 == 29) {
#line 733
      goto case_29___1;
    }
#line 733
    if (tmp___10 == 24) {
#line 733
      goto case_24___1;
    }
#line 733
    if (tmp___10 == 22) {
#line 733
      goto case_24___1;
    }
#line 733
    if (tmp___10 == 5) {
#line 733
      goto case_5___1;
    }
#line 733
    if (tmp___10 == 6) {
#line 733
      goto case_6___1;
    }
#line 733
    if (tmp___10 == 7) {
#line 733
      goto case_7___1;
    }
#line 734
    goto switch_default___0;
    case_29___1: /* CIL Label */ 
#line 733
    if (! (namingBitmap___0[((int const   )nmstrtPages___0[(unsigned char )*(ptr + 1)] << 3) + (int const   )((int )((unsigned char )*(ptr + 0)) >> 5)] & (unsigned int const   )(1 << ((int )((unsigned char )*(ptr + 0)) & 31)))) {
#line 733
      *nextTokPtr = ptr;
#line 733
      return (0);
    }
    case_24___1: /* CIL Label */ 
    case_22___1: /* CIL Label */ 
#line 733
    ptr += 2;
#line 733
    goto switch_break___2;
    case_5___1: /* CIL Label */ 
#line 733
    if (end - ptr < 2L) {
#line 733
      return (-2);
    }
#line 733
    *nextTokPtr = ptr;
#line 733
    return (0);
#line 733
    ptr += 2;
#line 733
    goto switch_break___2;
    case_6___1: /* CIL Label */ 
#line 733
    if (end - ptr < 3L) {
#line 733
      return (-2);
    }
#line 733
    *nextTokPtr = ptr;
#line 733
    return (0);
#line 733
    ptr += 3;
#line 733
    goto switch_break___2;
    case_7___1: /* CIL Label */ 
#line 733
    if (end - ptr < 4L) {
#line 733
      return (-2);
    }
#line 733
    *nextTokPtr = ptr;
#line 733
    return (0);
#line 733
    ptr += 4;
#line 733
    goto switch_break___2;
    switch_default___0: /* CIL Label */ 
#line 735
    *nextTokPtr = ptr;
#line 736
    return (0);
    switch_break___2: /* CIL Label */ ;
    }
#line 738
    goto switch_break___1;
    case_10: /* CIL Label */ 
    case_9: /* CIL Label */ 
    case_21: /* CIL Label */ 
#line 742
    ptr += 2;
    {
#line 743
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 743
      if (! ((unsigned long )ptr != (unsigned long )end)) {
#line 743
        goto while_break___0;
      }
#line 744
      if ((int const   )*(ptr + 1) == 0) {
#line 744
        tmp___12 = (int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr];
      } else {
        {
#line 744
        tmp___11 = unicode_byte_type___0((char )*(ptr + 1), (char )*(ptr + 0));
#line 744
        tmp___12 = tmp___11;
        }
      }
      {
#line 745
      if (tmp___12 == 29) {
#line 745
        goto case_29___2;
      }
#line 745
      if (tmp___12 == 24) {
#line 745
        goto case_24___2;
      }
#line 745
      if (tmp___12 == 22) {
#line 745
        goto case_24___2;
      }
#line 745
      if (tmp___12 == 5) {
#line 745
        goto case_5___2;
      }
#line 745
      if (tmp___12 == 6) {
#line 745
        goto case_6___2;
      }
#line 745
      if (tmp___12 == 7) {
#line 745
        goto case_7___2;
      }
#line 746
      if (tmp___12 == 11) {
#line 746
        goto case_11;
      }
#line 748
      if (tmp___12 == 17) {
#line 748
        goto case_17___0;
      }
#line 750
      if (tmp___12 == 10) {
#line 750
        goto case_10___0;
      }
#line 750
      if (tmp___12 == 9) {
#line 750
        goto case_10___0;
      }
#line 750
      if (tmp___12 == 21) {
#line 750
        goto case_10___0;
      }
#line 753
      goto switch_default___1;
      case_29___2: /* CIL Label */ 
#line 745
      if (! (namingBitmap___0[((int const   )nmstrtPages___0[(unsigned char )*(ptr + 1)] << 3) + (int const   )((int )((unsigned char )*(ptr + 0)) >> 5)] & (unsigned int const   )(1 << ((int )((unsigned char )*(ptr + 0)) & 31)))) {
#line 745
        *nextTokPtr = ptr;
#line 745
        return (0);
      }
      case_24___2: /* CIL Label */ 
      case_22___2: /* CIL Label */ 
#line 745
      ptr += 2;
#line 745
      goto switch_break___3;
      case_5___2: /* CIL Label */ 
#line 745
      if (end - ptr < 2L) {
#line 745
        return (-2);
      }
#line 745
      *nextTokPtr = ptr;
#line 745
      return (0);
#line 745
      ptr += 2;
#line 745
      goto switch_break___3;
      case_6___2: /* CIL Label */ 
#line 745
      if (end - ptr < 3L) {
#line 745
        return (-2);
      }
#line 745
      *nextTokPtr = ptr;
#line 745
      return (0);
#line 745
      ptr += 3;
#line 745
      goto switch_break___3;
      case_7___2: /* CIL Label */ 
#line 745
      if (end - ptr < 4L) {
#line 745
        return (-2);
      }
#line 745
      *nextTokPtr = ptr;
#line 745
      return (0);
#line 745
      ptr += 4;
#line 745
      goto switch_break___3;
      case_11: /* CIL Label */ 
#line 747
      goto gt;
      case_17___0: /* CIL Label */ 
#line 749
      goto sol;
      case_10___0: /* CIL Label */ 
      case_9___0: /* CIL Label */ 
      case_21___0: /* CIL Label */ 
#line 751
      ptr += 2;
#line 752
      goto while_continue___0;
      switch_default___1: /* CIL Label */ 
#line 754
      *nextTokPtr = ptr;
#line 755
      return (0);
      switch_break___3: /* CIL Label */ ;
      }
      {
#line 757
      tmp___13 = little2_scanAtts___0(enc, ptr, end, nextTokPtr);
      }
#line 757
      return (tmp___13);
    }
    while_break___0: /* CIL Label */ ;
    }
#line 759
    return (-1);
    gt: 
    case_11___0: /* CIL Label */ 
#line 763
    *nextTokPtr = ptr + 2;
#line 764
    return (2);
    sol: 
    case_17___1: /* CIL Label */ 
#line 767
    ptr += 2;
#line 768
    if ((unsigned long )ptr == (unsigned long )end) {
#line 769
      return (-1);
    }
#line 770
    if ((int const   )*(ptr + 1) == 0) {
#line 770
      if (! ((int const   )*(ptr + 0) == 62)) {
#line 771
        *nextTokPtr = ptr;
#line 772
        return (0);
      }
    } else {
#line 771
      *nextTokPtr = ptr;
#line 772
      return (0);
    }
#line 774
    *nextTokPtr = ptr + 2;
#line 775
    return (4);
    switch_default___2: /* CIL Label */ 
#line 777
    *nextTokPtr = ptr;
#line 778
    return (0);
    switch_break___1: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 781
  return (-1);
}
}
#line 784 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmltok_impl.c"
static int little2_contentTok___0(ENCODING const   *enc , char const   *ptr , char const   *end ,
                                  char const   **nextTokPtr ) 
{ 
  size_t n ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
#line 788
  if ((unsigned long )ptr == (unsigned long )end) {
#line 789
    return (-4);
  }
#line 791
  n = (size_t )(end - ptr);
#line 792
  if (n & 1UL) {
#line 793
    n &= 0xfffffffffffffffeUL;
#line 794
    if (n == 0UL) {
#line 795
      return (-1);
    }
#line 796
    end = ptr + n;
  }
#line 799
  if ((int const   )*(ptr + 1) == 0) {
#line 799
    tmp___0 = (int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr];
  } else {
    {
#line 799
    tmp = unicode_byte_type___0((char )*(ptr + 1), (char )*(ptr + 0));
#line 799
    tmp___0 = tmp;
    }
  }
  {
#line 800
  if (tmp___0 == 2) {
#line 800
    goto case_2;
  }
#line 802
  if (tmp___0 == 3) {
#line 802
    goto case_3;
  }
#line 804
  if (tmp___0 == 9) {
#line 804
    goto case_9;
  }
#line 812
  if (tmp___0 == 10) {
#line 812
    goto case_10;
  }
#line 815
  if (tmp___0 == 4) {
#line 815
    goto case_4;
  }
#line 830
  if (tmp___0 == 5) {
#line 830
    goto case_5;
  }
#line 830
  if (tmp___0 == 6) {
#line 830
    goto case_6;
  }
#line 830
  if (tmp___0 == 7) {
#line 830
    goto case_7;
  }
#line 830
  if (tmp___0 == 8) {
#line 830
    goto case_8;
  }
#line 830
  if (tmp___0 == 1) {
#line 830
    goto case_8;
  }
#line 830
  if (tmp___0 == 0) {
#line 830
    goto case_8;
  }
#line 831
  goto switch_default;
  case_2: /* CIL Label */ 
  {
#line 801
  tmp___1 = little2_scanLt___0(enc, ptr + 2, end, nextTokPtr);
  }
#line 801
  return (tmp___1);
  case_3: /* CIL Label */ 
  {
#line 803
  tmp___2 = little2_scanRef___0(enc, ptr + 2, end, nextTokPtr);
  }
#line 803
  return (tmp___2);
  case_9: /* CIL Label */ 
#line 805
  ptr += 2;
#line 806
  if ((unsigned long )ptr == (unsigned long )end) {
#line 807
    return (-3);
  }
#line 808
  if ((int const   )*(ptr + 1) == 0) {
#line 808
    tmp___4 = (int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr];
  } else {
    {
#line 808
    tmp___3 = unicode_byte_type___0((char )*(ptr + 1), (char )*(ptr + 0));
#line 808
    tmp___4 = tmp___3;
    }
  }
#line 808
  if (tmp___4 == 10) {
#line 809
    ptr += 2;
  }
#line 810
  *nextTokPtr = ptr;
#line 811
  return (7);
  case_10: /* CIL Label */ 
#line 813
  *nextTokPtr = ptr + 2;
#line 814
  return (7);
  case_4: /* CIL Label */ 
#line 816
  ptr += 2;
#line 817
  if ((unsigned long )ptr == (unsigned long )end) {
#line 818
    return (-5);
  }
#line 819
  if ((int const   )*(ptr + 1) == 0) {
#line 819
    if (! ((int const   )*(ptr + 0) == 93)) {
#line 820
      goto switch_break;
    }
  } else {
#line 820
    goto switch_break;
  }
#line 821
  ptr += 2;
#line 822
  if ((unsigned long )ptr == (unsigned long )end) {
#line 823
    return (-5);
  }
#line 824
  if ((int const   )*(ptr + 1) == 0) {
#line 824
    if (! ((int const   )*(ptr + 0) == 62)) {
#line 825
      ptr -= 2;
#line 826
      goto switch_break;
    }
  } else {
#line 825
    ptr -= 2;
#line 826
    goto switch_break;
  }
#line 828
  *nextTokPtr = ptr;
#line 829
  return (0);
  case_5: /* CIL Label */ 
#line 830
  if (end - ptr < 2L) {
#line 830
    return (-2);
  }
#line 830
  ptr += 2;
#line 830
  goto switch_break;
  case_6: /* CIL Label */ 
#line 830
  if (end - ptr < 3L) {
#line 830
    return (-2);
  }
#line 830
  ptr += 3;
#line 830
  goto switch_break;
  case_7: /* CIL Label */ 
#line 830
  if (end - ptr < 4L) {
#line 830
    return (-2);
  }
#line 830
  ptr += 4;
#line 830
  goto switch_break;
  case_8: /* CIL Label */ 
  case_1: /* CIL Label */ 
  case_0: /* CIL Label */ 
#line 830
  *nextTokPtr = ptr;
#line 830
  return (0);
  switch_default: /* CIL Label */ 
#line 832
  ptr += 2;
#line 833
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 835
  while (1) {
    while_continue: /* CIL Label */ ;
#line 835
    if (! ((unsigned long )ptr != (unsigned long )end)) {
#line 835
      goto while_break;
    }
#line 836
    if ((int const   )*(ptr + 1) == 0) {
#line 836
      tmp___6 = (int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr];
    } else {
      {
#line 836
      tmp___5 = unicode_byte_type___0((char )*(ptr + 1), (char )*(ptr + 0));
#line 836
      tmp___6 = tmp___5;
      }
    }
    {
#line 845
    if (tmp___6 == 5) {
#line 845
      goto case_5___0;
    }
#line 845
    if (tmp___6 == 6) {
#line 845
      goto case_6___0;
    }
#line 845
    if (tmp___6 == 7) {
#line 845
      goto case_7___0;
    }
#line 847
    if (tmp___6 == 4) {
#line 847
      goto case_4___0;
    }
#line 869
    if (tmp___6 == 10) {
#line 869
      goto case_10___0;
    }
#line 869
    if (tmp___6 == 9) {
#line 869
      goto case_10___0;
    }
#line 869
    if (tmp___6 == 8) {
#line 869
      goto case_10___0;
    }
#line 869
    if (tmp___6 == 1) {
#line 869
      goto case_10___0;
    }
#line 869
    if (tmp___6 == 0) {
#line 869
      goto case_10___0;
    }
#line 869
    if (tmp___6 == 2) {
#line 869
      goto case_10___0;
    }
#line 869
    if (tmp___6 == 3) {
#line 869
      goto case_10___0;
    }
#line 872
    goto switch_default___0;
    case_5___0: /* CIL Label */ 
#line 845
    if (end - ptr < 2L) {
#line 845
      *nextTokPtr = ptr;
#line 845
      return (6);
    }
#line 845
    ptr += 2;
#line 845
    goto switch_break___0;
    case_6___0: /* CIL Label */ 
#line 845
    if (end - ptr < 3L) {
#line 845
      *nextTokPtr = ptr;
#line 845
      return (6);
    }
#line 845
    ptr += 3;
#line 845
    goto switch_break___0;
    case_7___0: /* CIL Label */ 
#line 845
    if (end - ptr < 4L) {
#line 845
      *nextTokPtr = ptr;
#line 845
      return (6);
    }
#line 845
    ptr += 4;
#line 845
    goto switch_break___0;
    case_4___0: /* CIL Label */ 
#line 848
    if ((unsigned long )(ptr + 2) != (unsigned long )end) {
#line 849
      if ((int const   )*((ptr + 2) + 1) == 0) {
#line 849
        if (! ((int const   )*((ptr + 2) + 0) == 93)) {
#line 850
          ptr += 2;
#line 851
          goto switch_break___0;
        }
      } else {
#line 850
        ptr += 2;
#line 851
        goto switch_break___0;
      }
#line 853
      if ((unsigned long )(ptr + 4) != (unsigned long )end) {
#line 854
        if ((int const   )*((ptr + 4) + 1) == 0) {
#line 854
          if (! ((int const   )*((ptr + 4) + 0) == 62)) {
#line 855
            ptr += 2;
#line 856
            goto switch_break___0;
          }
        } else {
#line 855
          ptr += 2;
#line 856
          goto switch_break___0;
        }
#line 858
        *nextTokPtr = ptr + 4;
#line 859
        return (0);
      }
    }
    case_10___0: /* CIL Label */ 
    case_9___0: /* CIL Label */ 
    case_8___0: /* CIL Label */ 
    case_1___0: /* CIL Label */ 
    case_0___0: /* CIL Label */ 
    case_2___0: /* CIL Label */ 
    case_3___0: /* CIL Label */ 
#line 870
    *nextTokPtr = ptr;
#line 871
    return (6);
    switch_default___0: /* CIL Label */ 
#line 873
    ptr += 2;
#line 874
    goto switch_break___0;
    switch_break___0: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 877
  *nextTokPtr = ptr;
#line 878
  return (6);
}
}
#line 883 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmltok_impl.c"
static int little2_scanPercent___0(ENCODING const   *enc , char const   *ptr , char const   *end ,
                                   char const   **nextTokPtr ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 887
  if ((unsigned long )ptr == (unsigned long )end) {
#line 888
    return (-1);
  }
#line 889
  if ((int const   )*(ptr + 1) == 0) {
#line 889
    tmp___0 = (int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr];
  } else {
    {
#line 889
    tmp = unicode_byte_type___0((char )*(ptr + 1), (char )*(ptr + 0));
#line 889
    tmp___0 = tmp;
    }
  }
  {
#line 890
  if (tmp___0 == 29) {
#line 890
    goto case_29;
  }
#line 890
  if (tmp___0 == 24) {
#line 890
    goto case_24;
  }
#line 890
  if (tmp___0 == 22) {
#line 890
    goto case_24;
  }
#line 890
  if (tmp___0 == 5) {
#line 890
    goto case_5;
  }
#line 890
  if (tmp___0 == 6) {
#line 890
    goto case_6;
  }
#line 890
  if (tmp___0 == 7) {
#line 890
    goto case_7;
  }
#line 891
  if (tmp___0 == 30) {
#line 891
    goto case_30;
  }
#line 891
  if (tmp___0 == 9) {
#line 891
    goto case_30;
  }
#line 891
  if (tmp___0 == 10) {
#line 891
    goto case_30;
  }
#line 891
  if (tmp___0 == 21) {
#line 891
    goto case_30;
  }
#line 894
  goto switch_default;
  case_29: /* CIL Label */ 
#line 890
  if (! (namingBitmap___0[((int const   )nmstrtPages___0[(unsigned char )*(ptr + 1)] << 3) + (int const   )((int )((unsigned char )*(ptr + 0)) >> 5)] & (unsigned int const   )(1 << ((int )((unsigned char )*(ptr + 0)) & 31)))) {
#line 890
    *nextTokPtr = ptr;
#line 890
    return (0);
  }
  case_24: /* CIL Label */ 
  case_22: /* CIL Label */ 
#line 890
  ptr += 2;
#line 890
  goto switch_break;
  case_5: /* CIL Label */ 
#line 890
  if (end - ptr < 2L) {
#line 890
    return (-2);
  }
#line 890
  *nextTokPtr = ptr;
#line 890
  return (0);
#line 890
  ptr += 2;
#line 890
  goto switch_break;
  case_6: /* CIL Label */ 
#line 890
  if (end - ptr < 3L) {
#line 890
    return (-2);
  }
#line 890
  *nextTokPtr = ptr;
#line 890
  return (0);
#line 890
  ptr += 3;
#line 890
  goto switch_break;
  case_7: /* CIL Label */ 
#line 890
  if (end - ptr < 4L) {
#line 890
    return (-2);
  }
#line 890
  *nextTokPtr = ptr;
#line 890
  return (0);
#line 890
  ptr += 4;
#line 890
  goto switch_break;
  case_30: /* CIL Label */ 
  case_9: /* CIL Label */ 
  case_10: /* CIL Label */ 
  case_21: /* CIL Label */ 
#line 892
  *nextTokPtr = ptr;
#line 893
  return (22);
  switch_default: /* CIL Label */ 
#line 895
  *nextTokPtr = ptr;
#line 896
  return (0);
  switch_break: /* CIL Label */ ;
  }
  {
#line 898
  while (1) {
    while_continue: /* CIL Label */ ;
#line 898
    if (! ((unsigned long )ptr != (unsigned long )end)) {
#line 898
      goto while_break;
    }
#line 899
    if ((int const   )*(ptr + 1) == 0) {
#line 899
      tmp___2 = (int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr];
    } else {
      {
#line 899
      tmp___1 = unicode_byte_type___0((char )*(ptr + 1), (char )*(ptr + 0));
#line 899
      tmp___2 = tmp___1;
      }
    }
    {
#line 900
    if (tmp___2 == 29) {
#line 900
      goto case_29___0;
    }
#line 900
    if (tmp___2 == 27) {
#line 900
      goto case_27;
    }
#line 900
    if (tmp___2 == 26) {
#line 900
      goto case_27;
    }
#line 900
    if (tmp___2 == 25) {
#line 900
      goto case_27;
    }
#line 900
    if (tmp___2 == 24) {
#line 900
      goto case_27;
    }
#line 900
    if (tmp___2 == 22) {
#line 900
      goto case_27;
    }
#line 900
    if (tmp___2 == 5) {
#line 900
      goto case_5___0;
    }
#line 900
    if (tmp___2 == 6) {
#line 900
      goto case_6___0;
    }
#line 900
    if (tmp___2 == 7) {
#line 900
      goto case_7___0;
    }
#line 901
    if (tmp___2 == 18) {
#line 901
      goto case_18;
    }
#line 904
    goto switch_default___0;
    case_29___0: /* CIL Label */ 
#line 900
    if (! (namingBitmap___0[((int const   )namePages___0[(unsigned char )*(ptr + 1)] << 3) + (int const   )((int )((unsigned char )*(ptr + 0)) >> 5)] & (unsigned int const   )(1 << ((int )((unsigned char )*(ptr + 0)) & 31)))) {
#line 900
      *nextTokPtr = ptr;
#line 900
      return (0);
    }
    case_27: /* CIL Label */ 
    case_26: /* CIL Label */ 
    case_25: /* CIL Label */ 
    case_24___0: /* CIL Label */ 
    case_22___0: /* CIL Label */ 
#line 900
    ptr += 2;
#line 900
    goto switch_break___0;
    case_5___0: /* CIL Label */ 
#line 900
    if (end - ptr < 2L) {
#line 900
      return (-2);
    }
#line 900
    *nextTokPtr = ptr;
#line 900
    return (0);
#line 900
    ptr += 2;
#line 900
    goto switch_break___0;
    case_6___0: /* CIL Label */ 
#line 900
    if (end - ptr < 3L) {
#line 900
      return (-2);
    }
#line 900
    *nextTokPtr = ptr;
#line 900
    return (0);
#line 900
    ptr += 3;
#line 900
    goto switch_break___0;
    case_7___0: /* CIL Label */ 
#line 900
    if (end - ptr < 4L) {
#line 900
      return (-2);
    }
#line 900
    *nextTokPtr = ptr;
#line 900
    return (0);
#line 900
    ptr += 4;
#line 900
    goto switch_break___0;
    case_18: /* CIL Label */ 
#line 902
    *nextTokPtr = ptr + 2;
#line 903
    return (28);
    switch_default___0: /* CIL Label */ 
#line 905
    *nextTokPtr = ptr;
#line 906
    return (0);
    switch_break___0: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 909
  return (-1);
}
}
#line 912 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmltok_impl.c"
static int little2_scanPoundName___0(ENCODING const   *enc , char const   *ptr , char const   *end ,
                                     char const   **nextTokPtr ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 916
  if ((unsigned long )ptr == (unsigned long )end) {
#line 917
    return (-1);
  }
#line 918
  if ((int const   )*(ptr + 1) == 0) {
#line 918
    tmp___0 = (int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr];
  } else {
    {
#line 918
    tmp = unicode_byte_type___0((char )*(ptr + 1), (char )*(ptr + 0));
#line 918
    tmp___0 = tmp;
    }
  }
  {
#line 919
  if (tmp___0 == 29) {
#line 919
    goto case_29;
  }
#line 919
  if (tmp___0 == 24) {
#line 919
    goto case_24;
  }
#line 919
  if (tmp___0 == 22) {
#line 919
    goto case_24;
  }
#line 919
  if (tmp___0 == 5) {
#line 919
    goto case_5;
  }
#line 919
  if (tmp___0 == 6) {
#line 919
    goto case_6;
  }
#line 919
  if (tmp___0 == 7) {
#line 919
    goto case_7;
  }
#line 920
  goto switch_default;
  case_29: /* CIL Label */ 
#line 919
  if (! (namingBitmap___0[((int const   )nmstrtPages___0[(unsigned char )*(ptr + 1)] << 3) + (int const   )((int )((unsigned char )*(ptr + 0)) >> 5)] & (unsigned int const   )(1 << ((int )((unsigned char )*(ptr + 0)) & 31)))) {
#line 919
    *nextTokPtr = ptr;
#line 919
    return (0);
  }
  case_24: /* CIL Label */ 
  case_22: /* CIL Label */ 
#line 919
  ptr += 2;
#line 919
  goto switch_break;
  case_5: /* CIL Label */ 
#line 919
  if (end - ptr < 2L) {
#line 919
    return (-2);
  }
#line 919
  *nextTokPtr = ptr;
#line 919
  return (0);
#line 919
  ptr += 2;
#line 919
  goto switch_break;
  case_6: /* CIL Label */ 
#line 919
  if (end - ptr < 3L) {
#line 919
    return (-2);
  }
#line 919
  *nextTokPtr = ptr;
#line 919
  return (0);
#line 919
  ptr += 3;
#line 919
  goto switch_break;
  case_7: /* CIL Label */ 
#line 919
  if (end - ptr < 4L) {
#line 919
    return (-2);
  }
#line 919
  *nextTokPtr = ptr;
#line 919
  return (0);
#line 919
  ptr += 4;
#line 919
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 921
  *nextTokPtr = ptr;
#line 922
  return (0);
  switch_break: /* CIL Label */ ;
  }
  {
#line 924
  while (1) {
    while_continue: /* CIL Label */ ;
#line 924
    if (! ((unsigned long )ptr != (unsigned long )end)) {
#line 924
      goto while_break;
    }
#line 925
    if ((int const   )*(ptr + 1) == 0) {
#line 925
      tmp___2 = (int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr];
    } else {
      {
#line 925
      tmp___1 = unicode_byte_type___0((char )*(ptr + 1), (char )*(ptr + 0));
#line 925
      tmp___2 = tmp___1;
      }
    }
    {
#line 926
    if (tmp___2 == 29) {
#line 926
      goto case_29___0;
    }
#line 926
    if (tmp___2 == 27) {
#line 926
      goto case_27;
    }
#line 926
    if (tmp___2 == 26) {
#line 926
      goto case_27;
    }
#line 926
    if (tmp___2 == 25) {
#line 926
      goto case_27;
    }
#line 926
    if (tmp___2 == 24) {
#line 926
      goto case_27;
    }
#line 926
    if (tmp___2 == 22) {
#line 926
      goto case_27;
    }
#line 926
    if (tmp___2 == 5) {
#line 926
      goto case_5___0;
    }
#line 926
    if (tmp___2 == 6) {
#line 926
      goto case_6___0;
    }
#line 926
    if (tmp___2 == 7) {
#line 926
      goto case_7___0;
    }
#line 928
    if (tmp___2 == 36) {
#line 928
      goto case_36;
    }
#line 928
    if (tmp___2 == 30) {
#line 928
      goto case_36;
    }
#line 928
    if (tmp___2 == 11) {
#line 928
      goto case_36;
    }
#line 928
    if (tmp___2 == 32) {
#line 928
      goto case_36;
    }
#line 928
    if (tmp___2 == 21) {
#line 928
      goto case_36;
    }
#line 928
    if (tmp___2 == 10) {
#line 928
      goto case_36;
    }
#line 928
    if (tmp___2 == 9) {
#line 928
      goto case_36;
    }
#line 931
    goto switch_default___0;
    case_29___0: /* CIL Label */ 
#line 926
    if (! (namingBitmap___0[((int const   )namePages___0[(unsigned char )*(ptr + 1)] << 3) + (int const   )((int )((unsigned char )*(ptr + 0)) >> 5)] & (unsigned int const   )(1 << ((int )((unsigned char )*(ptr + 0)) & 31)))) {
#line 926
      *nextTokPtr = ptr;
#line 926
      return (0);
    }
    case_27: /* CIL Label */ 
    case_26: /* CIL Label */ 
    case_25: /* CIL Label */ 
    case_24___0: /* CIL Label */ 
    case_22___0: /* CIL Label */ 
#line 926
    ptr += 2;
#line 926
    goto switch_break___0;
    case_5___0: /* CIL Label */ 
#line 926
    if (end - ptr < 2L) {
#line 926
      return (-2);
    }
#line 926
    *nextTokPtr = ptr;
#line 926
    return (0);
#line 926
    ptr += 2;
#line 926
    goto switch_break___0;
    case_6___0: /* CIL Label */ 
#line 926
    if (end - ptr < 3L) {
#line 926
      return (-2);
    }
#line 926
    *nextTokPtr = ptr;
#line 926
    return (0);
#line 926
    ptr += 3;
#line 926
    goto switch_break___0;
    case_7___0: /* CIL Label */ 
#line 926
    if (end - ptr < 4L) {
#line 926
      return (-2);
    }
#line 926
    *nextTokPtr = ptr;
#line 926
    return (0);
#line 926
    ptr += 4;
#line 926
    goto switch_break___0;
    case_36: /* CIL Label */ 
    case_30: /* CIL Label */ 
    case_11: /* CIL Label */ 
    case_32: /* CIL Label */ 
    case_21: /* CIL Label */ 
    case_10: /* CIL Label */ 
    case_9: /* CIL Label */ 
#line 929
    *nextTokPtr = ptr;
#line 930
    return (20);
    switch_default___0: /* CIL Label */ 
#line 932
    *nextTokPtr = ptr;
#line 933
    return (0);
    switch_break___0: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 936
  return (-20);
}
}
#line 939 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmltok_impl.c"
static int little2_scanLit___0(int open___0 , ENCODING const   *enc , char const   *ptr ,
                               char const   *end , char const   **nextTokPtr ) 
{ 
  int t ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 944
  while (1) {
    while_continue: /* CIL Label */ ;
#line 944
    if (! ((unsigned long )ptr != (unsigned long )end)) {
#line 944
      goto while_break;
    }
#line 945
    if ((int const   )*(ptr + 1) == 0) {
#line 945
      tmp___0 = (int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr];
    } else {
      {
#line 945
      tmp = unicode_byte_type___0((char )*(ptr + 1), (char )*(ptr + 0));
#line 945
      tmp___0 = tmp;
      }
    }
#line 945
    t = tmp___0;
    {
#line 947
    if (t == 5) {
#line 947
      goto case_5;
    }
#line 947
    if (t == 6) {
#line 947
      goto case_6;
    }
#line 947
    if (t == 7) {
#line 947
      goto case_7;
    }
#line 947
    if (t == 8) {
#line 947
      goto case_8;
    }
#line 947
    if (t == 1) {
#line 947
      goto case_8;
    }
#line 947
    if (t == 0) {
#line 947
      goto case_8;
    }
#line 949
    if (t == 13) {
#line 949
      goto case_13;
    }
#line 949
    if (t == 12) {
#line 949
      goto case_13;
    }
#line 963
    goto switch_default___0;
    case_5: /* CIL Label */ 
#line 947
    if (end - ptr < 2L) {
#line 947
      return (-2);
    }
#line 947
    ptr += 2;
#line 947
    goto switch_break;
    case_6: /* CIL Label */ 
#line 947
    if (end - ptr < 3L) {
#line 947
      return (-2);
    }
#line 947
    ptr += 3;
#line 947
    goto switch_break;
    case_7: /* CIL Label */ 
#line 947
    if (end - ptr < 4L) {
#line 947
      return (-2);
    }
#line 947
    ptr += 4;
#line 947
    goto switch_break;
    case_8: /* CIL Label */ 
    case_1: /* CIL Label */ 
    case_0: /* CIL Label */ 
#line 947
    *nextTokPtr = ptr;
#line 947
    return (0);
    case_13: /* CIL Label */ 
    case_12: /* CIL Label */ 
#line 950
    ptr += 2;
#line 951
    if (t != open___0) {
#line 952
      goto switch_break;
    }
#line 953
    if ((unsigned long )ptr == (unsigned long )end) {
#line 954
      return (-27);
    }
#line 955
    *nextTokPtr = ptr;
#line 956
    if ((int const   )*(ptr + 1) == 0) {
#line 956
      tmp___2 = (int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr];
    } else {
      {
#line 956
      tmp___1 = unicode_byte_type___0((char )*(ptr + 1), (char )*(ptr + 0));
#line 956
      tmp___2 = tmp___1;
      }
    }
    {
#line 958
    if (tmp___2 == 20) {
#line 958
      goto case_20;
    }
#line 958
    if (tmp___2 == 30) {
#line 958
      goto case_20;
    }
#line 958
    if (tmp___2 == 11) {
#line 958
      goto case_20;
    }
#line 958
    if (tmp___2 == 10) {
#line 958
      goto case_20;
    }
#line 958
    if (tmp___2 == 9) {
#line 958
      goto case_20;
    }
#line 958
    if (tmp___2 == 21) {
#line 958
      goto case_20;
    }
#line 960
    goto switch_default;
    case_20: /* CIL Label */ 
    case_30: /* CIL Label */ 
    case_11: /* CIL Label */ 
    case_10: /* CIL Label */ 
    case_9: /* CIL Label */ 
    case_21: /* CIL Label */ 
#line 959
    return (27);
    switch_default: /* CIL Label */ 
#line 961
    return (0);
    switch_break___0: /* CIL Label */ ;
    }
    switch_default___0: /* CIL Label */ 
#line 964
    ptr += 2;
#line 965
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 968
  return (-1);
}
}
#line 971 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmltok_impl.c"
static int little2_prologTok___0(ENCODING const   *enc , char const   *ptr , char const   *end ,
                                 char const   **nextTokPtr ) 
{ 
  int tok ;
  size_t n ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;

  {
#line 976
  if ((unsigned long )ptr == (unsigned long )end) {
#line 977
    return (-4);
  }
#line 979
  n = (size_t )(end - ptr);
#line 980
  if (n & 1UL) {
#line 981
    n &= 0xfffffffffffffffeUL;
#line 982
    if (n == 0UL) {
#line 983
      return (-1);
    }
#line 984
    end = ptr + n;
  }
#line 987
  if ((int const   )*(ptr + 1) == 0) {
#line 987
    tmp___0 = (int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr];
  } else {
    {
#line 987
    tmp = unicode_byte_type___0((char )*(ptr + 1), (char )*(ptr + 0));
#line 987
    tmp___0 = tmp;
    }
  }
  {
#line 988
  if (tmp___0 == 12) {
#line 988
    goto case_12;
  }
#line 990
  if (tmp___0 == 13) {
#line 990
    goto case_13;
  }
#line 992
  if (tmp___0 == 2) {
#line 992
    goto case_2;
  }
#line 1014
  if (tmp___0 == 9) {
#line 1014
    goto case_9;
  }
#line 1021
  if (tmp___0 == 10) {
#line 1021
    goto case_10;
  }
#line 1021
  if (tmp___0 == 21) {
#line 1021
    goto case_10;
  }
#line 1041
  if (tmp___0 == 30) {
#line 1041
    goto case_30;
  }
#line 1043
  if (tmp___0 == 35) {
#line 1043
    goto case_35;
  }
#line 1046
  if (tmp___0 == 20) {
#line 1046
    goto case_20;
  }
#line 1049
  if (tmp___0 == 4) {
#line 1049
    goto case_4;
  }
#line 1063
  if (tmp___0 == 31) {
#line 1063
    goto case_31;
  }
#line 1066
  if (tmp___0 == 32) {
#line 1066
    goto case_32;
  }
#line 1088
  if (tmp___0 == 36) {
#line 1088
    goto case_36___0;
  }
#line 1091
  if (tmp___0 == 11) {
#line 1091
    goto case_11___0;
  }
#line 1094
  if (tmp___0 == 19) {
#line 1094
    goto case_19;
  }
#line 1112
  if (tmp___0 == 5) {
#line 1112
    goto case_5___0;
  }
#line 1112
  if (tmp___0 == 6) {
#line 1112
    goto case_6___0;
  }
#line 1112
  if (tmp___0 == 7) {
#line 1112
    goto case_7___0;
  }
#line 1115
  if (tmp___0 == 24) {
#line 1115
    goto case_24___0;
  }
#line 1115
  if (tmp___0 == 22) {
#line 1115
    goto case_24___0;
  }
#line 1123
  if (tmp___0 == 23) {
#line 1123
    goto case_23;
  }
#line 1123
  if (tmp___0 == 27) {
#line 1123
    goto case_23;
  }
#line 1123
  if (tmp___0 == 26) {
#line 1123
    goto case_23;
  }
#line 1123
  if (tmp___0 == 25) {
#line 1123
    goto case_23;
  }
#line 1128
  if (tmp___0 == 29) {
#line 1128
    goto case_29___0;
  }
#line 1140
  goto switch_default___0;
  case_12: /* CIL Label */ 
  {
#line 989
  tmp___1 = little2_scanLit___0(12, enc, ptr + 2, end, nextTokPtr);
  }
#line 989
  return (tmp___1);
  case_13: /* CIL Label */ 
  {
#line 991
  tmp___2 = little2_scanLit___0(13, enc, ptr + 2, end, nextTokPtr);
  }
#line 991
  return (tmp___2);
  case_2: /* CIL Label */ 
#line 994
  ptr += 2;
#line 995
  if ((unsigned long )ptr == (unsigned long )end) {
#line 996
    return (-1);
  }
#line 997
  if ((int const   )*(ptr + 1) == 0) {
#line 997
    tmp___4 = (int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr];
  } else {
    {
#line 997
    tmp___3 = unicode_byte_type___0((char )*(ptr + 1), (char )*(ptr + 0));
#line 997
    tmp___4 = tmp___3;
    }
  }
  {
#line 998
  if (tmp___4 == 16) {
#line 998
    goto case_16;
  }
#line 1000
  if (tmp___4 == 15) {
#line 1000
    goto case_15;
  }
#line 1007
  if (tmp___4 == 7) {
#line 1007
    goto case_7;
  }
#line 1007
  if (tmp___4 == 6) {
#line 1007
    goto case_7;
  }
#line 1007
  if (tmp___4 == 5) {
#line 1007
    goto case_7;
  }
#line 1007
  if (tmp___4 == 29) {
#line 1007
    goto case_7;
  }
#line 1007
  if (tmp___4 == 24) {
#line 1007
    goto case_7;
  }
#line 1007
  if (tmp___4 == 22) {
#line 1007
    goto case_7;
  }
#line 997
  goto switch_break___0;
  case_16: /* CIL Label */ 
  {
#line 999
  tmp___5 = little2_scanDecl___0(enc, ptr + 2, end, nextTokPtr);
  }
#line 999
  return (tmp___5);
  case_15: /* CIL Label */ 
  {
#line 1001
  tmp___6 = little2_scanPi___0(enc, ptr + 2, end, nextTokPtr);
  }
#line 1001
  return (tmp___6);
  case_7: /* CIL Label */ 
  case_6: /* CIL Label */ 
  case_5: /* CIL Label */ 
  case_29: /* CIL Label */ 
  case_24: /* CIL Label */ 
  case_22: /* CIL Label */ 
#line 1008
  *nextTokPtr = ptr - 2;
#line 1009
  return (29);
  switch_break___0: /* CIL Label */ ;
  }
#line 1011
  *nextTokPtr = ptr;
#line 1012
  return (0);
  case_9: /* CIL Label */ 
#line 1015
  if ((unsigned long )(ptr + 2) == (unsigned long )end) {
#line 1016
    *nextTokPtr = end;
#line 1018
    return (-15);
  }
  case_10: /* CIL Label */ 
  case_21: /* CIL Label */ 
  {
#line 1022
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1023
    ptr += 2;
#line 1024
    if ((unsigned long )ptr == (unsigned long )end) {
#line 1025
      goto while_break;
    }
#line 1026
    if ((int const   )*(ptr + 1) == 0) {
#line 1026
      tmp___8 = (int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr];
    } else {
      {
#line 1026
      tmp___7 = unicode_byte_type___0((char )*(ptr + 1), (char )*(ptr + 0));
#line 1026
      tmp___8 = tmp___7;
      }
    }
    {
#line 1027
    if (tmp___8 == 10) {
#line 1027
      goto case_10___0;
    }
#line 1027
    if (tmp___8 == 21) {
#line 1027
      goto case_10___0;
    }
#line 1029
    if (tmp___8 == 9) {
#line 1029
      goto case_9___0;
    }
#line 1034
    goto switch_default;
    case_10___0: /* CIL Label */ 
    case_21___0: /* CIL Label */ 
#line 1028
    goto switch_break___1;
    case_9___0: /* CIL Label */ 
#line 1031
    if ((unsigned long )(ptr + 2) != (unsigned long )end) {
#line 1032
      goto switch_break___1;
    }
    switch_default: /* CIL Label */ 
#line 1035
    *nextTokPtr = ptr;
#line 1036
    return (15);
    switch_break___1: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1039
  *nextTokPtr = ptr;
#line 1040
  return (15);
  case_30: /* CIL Label */ 
  {
#line 1042
  tmp___9 = little2_scanPercent___0(enc, ptr + 2, end, nextTokPtr);
  }
#line 1042
  return (tmp___9);
  case_35: /* CIL Label */ 
#line 1044
  *nextTokPtr = ptr + 2;
#line 1045
  return (38);
  case_20: /* CIL Label */ 
#line 1047
  *nextTokPtr = ptr + 2;
#line 1048
  return (25);
  case_4: /* CIL Label */ 
#line 1050
  ptr += 2;
#line 1051
  if ((unsigned long )ptr == (unsigned long )end) {
#line 1052
    return (-26);
  }
#line 1053
  if ((int const   )*(ptr + 1) == 0) {
#line 1053
    if ((int const   )*(ptr + 0) == 93) {
#line 1054
      if ((unsigned long )(ptr + 2) == (unsigned long )end) {
#line 1055
        return (-1);
      }
#line 1056
      if ((int const   )*((ptr + 2) + 1) == 0) {
#line 1056
        if ((int const   )*((ptr + 2) + 0) == 62) {
#line 1057
          *nextTokPtr = ptr + 4;
#line 1058
          return (34);
        }
      }
    }
  }
#line 1061
  *nextTokPtr = ptr;
#line 1062
  return (26);
  case_31: /* CIL Label */ 
#line 1064
  *nextTokPtr = ptr + 2;
#line 1065
  return (23);
  case_32: /* CIL Label */ 
#line 1067
  ptr += 2;
#line 1068
  if ((unsigned long )ptr == (unsigned long )end) {
#line 1069
    return (-24);
  }
#line 1070
  if ((int const   )*(ptr + 1) == 0) {
#line 1070
    tmp___11 = (int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr];
  } else {
    {
#line 1070
    tmp___10 = unicode_byte_type___0((char )*(ptr + 1), (char )*(ptr + 0));
#line 1070
    tmp___11 = tmp___10;
    }
  }
  {
#line 1071
  if (tmp___11 == 33) {
#line 1071
    goto case_33;
  }
#line 1074
  if (tmp___11 == 15) {
#line 1074
    goto case_15___0;
  }
#line 1077
  if (tmp___11 == 34) {
#line 1077
    goto case_34;
  }
#line 1082
  if (tmp___11 == 32) {
#line 1082
    goto case_32___0;
  }
#line 1082
  if (tmp___11 == 36) {
#line 1082
    goto case_32___0;
  }
#line 1082
  if (tmp___11 == 35) {
#line 1082
    goto case_32___0;
  }
#line 1082
  if (tmp___11 == 11) {
#line 1082
    goto case_32___0;
  }
#line 1082
  if (tmp___11 == 21) {
#line 1082
    goto case_32___0;
  }
#line 1082
  if (tmp___11 == 10) {
#line 1082
    goto case_32___0;
  }
#line 1082
  if (tmp___11 == 9) {
#line 1082
    goto case_32___0;
  }
#line 1070
  goto switch_break___2;
  case_33: /* CIL Label */ 
#line 1072
  *nextTokPtr = ptr + 2;
#line 1073
  return (36);
  case_15___0: /* CIL Label */ 
#line 1075
  *nextTokPtr = ptr + 2;
#line 1076
  return (35);
  case_34: /* CIL Label */ 
#line 1078
  *nextTokPtr = ptr + 2;
#line 1079
  return (37);
  case_32___0: /* CIL Label */ 
  case_36: /* CIL Label */ 
  case_35___0: /* CIL Label */ 
  case_11: /* CIL Label */ 
  case_21___1: /* CIL Label */ 
  case_10___1: /* CIL Label */ 
  case_9___1: /* CIL Label */ 
#line 1083
  *nextTokPtr = ptr;
#line 1084
  return (24);
  switch_break___2: /* CIL Label */ ;
  }
#line 1086
  *nextTokPtr = ptr;
#line 1087
  return (0);
  case_36___0: /* CIL Label */ 
#line 1089
  *nextTokPtr = ptr + 2;
#line 1090
  return (21);
  case_11___0: /* CIL Label */ 
#line 1092
  *nextTokPtr = ptr + 2;
#line 1093
  return (17);
  case_19: /* CIL Label */ 
  {
#line 1095
  tmp___12 = little2_scanPoundName___0(enc, ptr + 2, end, nextTokPtr);
  }
#line 1095
  return (tmp___12);
  case_5___0: /* CIL Label */ 
#line 1112
  if (end - ptr < 2L) {
#line 1112
    return (-2);
  }
#line 1112
  *nextTokPtr = ptr;
#line 1112
  return (0);
  case_6___0: /* CIL Label */ 
#line 1112
  if (end - ptr < 3L) {
#line 1112
    return (-2);
  }
#line 1112
  *nextTokPtr = ptr;
#line 1112
  return (0);
  case_7___0: /* CIL Label */ 
#line 1112
  if (end - ptr < 4L) {
#line 1112
    return (-2);
  }
#line 1112
  *nextTokPtr = ptr;
#line 1112
  return (0);
  case_24___0: /* CIL Label */ 
  case_22___0: /* CIL Label */ 
#line 1116
  tok = 18;
#line 1117
  ptr += 2;
#line 1118
  goto switch_break;
  case_23: /* CIL Label */ 
  case_27: /* CIL Label */ 
  case_26: /* CIL Label */ 
  case_25: /* CIL Label */ 
#line 1125
  tok = 19;
#line 1126
  ptr += 2;
#line 1127
  goto switch_break;
  case_29___0: /* CIL Label */ 
#line 1129
  if (namingBitmap___0[((int const   )nmstrtPages___0[(unsigned char )*(ptr + 1)] << 3) + (int const   )((int )((unsigned char )*(ptr + 0)) >> 5)] & (unsigned int const   )(1 << ((int )((unsigned char )*(ptr + 0)) & 31))) {
#line 1130
    ptr += 2;
#line 1131
    tok = 18;
#line 1132
    goto switch_break;
  }
#line 1134
  if (namingBitmap___0[((int const   )namePages___0[(unsigned char )*(ptr + 1)] << 3) + (int const   )((int )((unsigned char )*(ptr + 0)) >> 5)] & (unsigned int const   )(1 << ((int )((unsigned char )*(ptr + 0)) & 31))) {
#line 1135
    ptr += 2;
#line 1136
    tok = 19;
#line 1137
    goto switch_break;
  }
  switch_default___0: /* CIL Label */ 
#line 1141
  *nextTokPtr = ptr;
#line 1142
  return (0);
  switch_break: /* CIL Label */ ;
  }
  {
#line 1144
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1144
    if (! ((unsigned long )ptr != (unsigned long )end)) {
#line 1144
      goto while_break___0;
    }
#line 1145
    if ((int const   )*(ptr + 1) == 0) {
#line 1145
      tmp___14 = (int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr];
    } else {
      {
#line 1145
      tmp___13 = unicode_byte_type___0((char )*(ptr + 1), (char )*(ptr + 0));
#line 1145
      tmp___14 = tmp___13;
      }
    }
    {
#line 1146
    if (tmp___14 == 29) {
#line 1146
      goto case_29___1;
    }
#line 1146
    if (tmp___14 == 27) {
#line 1146
      goto case_27___0;
    }
#line 1146
    if (tmp___14 == 26) {
#line 1146
      goto case_27___0;
    }
#line 1146
    if (tmp___14 == 25) {
#line 1146
      goto case_27___0;
    }
#line 1146
    if (tmp___14 == 24) {
#line 1146
      goto case_27___0;
    }
#line 1146
    if (tmp___14 == 22) {
#line 1146
      goto case_27___0;
    }
#line 1146
    if (tmp___14 == 5) {
#line 1146
      goto case_5___1;
    }
#line 1146
    if (tmp___14 == 6) {
#line 1146
      goto case_6___1;
    }
#line 1146
    if (tmp___14 == 7) {
#line 1146
      goto case_7___1;
    }
#line 1149
    if (tmp___14 == 10) {
#line 1149
      goto case_10___2;
    }
#line 1149
    if (tmp___14 == 9) {
#line 1149
      goto case_10___2;
    }
#line 1149
    if (tmp___14 == 21) {
#line 1149
      goto case_10___2;
    }
#line 1149
    if (tmp___14 == 30) {
#line 1149
      goto case_10___2;
    }
#line 1149
    if (tmp___14 == 20) {
#line 1149
      goto case_10___2;
    }
#line 1149
    if (tmp___14 == 36) {
#line 1149
      goto case_10___2;
    }
#line 1149
    if (tmp___14 == 35) {
#line 1149
      goto case_10___2;
    }
#line 1149
    if (tmp___14 == 32) {
#line 1149
      goto case_10___2;
    }
#line 1149
    if (tmp___14 == 11) {
#line 1149
      goto case_10___2;
    }
#line 1153
    if (tmp___14 == 23) {
#line 1153
      goto case_23___0;
    }
#line 1173
    if (tmp___14 == 34) {
#line 1173
      goto case_34___0;
    }
#line 1180
    if (tmp___14 == 33) {
#line 1180
      goto case_33___0;
    }
#line 1187
    if (tmp___14 == 15) {
#line 1187
      goto case_15___1;
    }
#line 1194
    goto switch_default___2;
    case_29___1: /* CIL Label */ 
#line 1146
    if (! (namingBitmap___0[((int const   )namePages___0[(unsigned char )*(ptr + 1)] << 3) + (int const   )((int )((unsigned char )*(ptr + 0)) >> 5)] & (unsigned int const   )(1 << ((int )((unsigned char )*(ptr + 0)) & 31)))) {
#line 1146
      *nextTokPtr = ptr;
#line 1146
      return (0);
    }
    case_27___0: /* CIL Label */ 
    case_26___0: /* CIL Label */ 
    case_25___0: /* CIL Label */ 
    case_24___1: /* CIL Label */ 
    case_22___1: /* CIL Label */ 
#line 1146
    ptr += 2;
#line 1146
    goto switch_break___3;
    case_5___1: /* CIL Label */ 
#line 1146
    if (end - ptr < 2L) {
#line 1146
      return (-2);
    }
#line 1146
    *nextTokPtr = ptr;
#line 1146
    return (0);
#line 1146
    ptr += 2;
#line 1146
    goto switch_break___3;
    case_6___1: /* CIL Label */ 
#line 1146
    if (end - ptr < 3L) {
#line 1146
      return (-2);
    }
#line 1146
    *nextTokPtr = ptr;
#line 1146
    return (0);
#line 1146
    ptr += 3;
#line 1146
    goto switch_break___3;
    case_7___1: /* CIL Label */ 
#line 1146
    if (end - ptr < 4L) {
#line 1146
      return (-2);
    }
#line 1146
    *nextTokPtr = ptr;
#line 1146
    return (0);
#line 1146
    ptr += 4;
#line 1146
    goto switch_break___3;
    case_10___2: /* CIL Label */ 
    case_9___2: /* CIL Label */ 
    case_21___2: /* CIL Label */ 
    case_30___0: /* CIL Label */ 
    case_20___0: /* CIL Label */ 
    case_36___1: /* CIL Label */ 
    case_35___1: /* CIL Label */ 
    case_32___1: /* CIL Label */ 
    case_11___1: /* CIL Label */ 
#line 1150
    *nextTokPtr = ptr;
#line 1151
    return (tok);
    case_23___0: /* CIL Label */ 
#line 1154
    ptr += 2;
    {
#line 1156
    if (tok == 18) {
#line 1156
      goto case_18;
    }
#line 1167
    if (tok == 41) {
#line 1167
      goto case_41;
    }
#line 1155
    goto switch_break___4;
    case_18: /* CIL Label */ 
#line 1157
    if ((unsigned long )ptr == (unsigned long )end) {
#line 1158
      return (-1);
    }
#line 1159
    tok = 41;
#line 1160
    if ((int const   )*(ptr + 1) == 0) {
#line 1160
      tmp___16 = (int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr];
    } else {
      {
#line 1160
      tmp___15 = unicode_byte_type___0((char )*(ptr + 1), (char )*(ptr + 0));
#line 1160
      tmp___16 = tmp___15;
      }
    }
    {
#line 1161
    if (tmp___16 == 29) {
#line 1161
      goto case_29___2;
    }
#line 1161
    if (tmp___16 == 27) {
#line 1161
      goto case_27___1;
    }
#line 1161
    if (tmp___16 == 26) {
#line 1161
      goto case_27___1;
    }
#line 1161
    if (tmp___16 == 25) {
#line 1161
      goto case_27___1;
    }
#line 1161
    if (tmp___16 == 24) {
#line 1161
      goto case_27___1;
    }
#line 1161
    if (tmp___16 == 22) {
#line 1161
      goto case_27___1;
    }
#line 1161
    if (tmp___16 == 5) {
#line 1161
      goto case_5___2;
    }
#line 1161
    if (tmp___16 == 6) {
#line 1161
      goto case_6___2;
    }
#line 1161
    if (tmp___16 == 7) {
#line 1161
      goto case_7___2;
    }
#line 1162
    goto switch_default___1;
    case_29___2: /* CIL Label */ 
#line 1161
    if (! (namingBitmap___0[((int const   )namePages___0[(unsigned char )*(ptr + 1)] << 3) + (int const   )((int )((unsigned char )*(ptr + 0)) >> 5)] & (unsigned int const   )(1 << ((int )((unsigned char )*(ptr + 0)) & 31)))) {
#line 1161
      *nextTokPtr = ptr;
#line 1161
      return (0);
    }
    case_27___1: /* CIL Label */ 
    case_26___1: /* CIL Label */ 
    case_25___1: /* CIL Label */ 
    case_24___2: /* CIL Label */ 
    case_22___2: /* CIL Label */ 
#line 1161
    ptr += 2;
#line 1161
    goto switch_break___5;
    case_5___2: /* CIL Label */ 
#line 1161
    if (end - ptr < 2L) {
#line 1161
      return (-2);
    }
#line 1161
    *nextTokPtr = ptr;
#line 1161
    return (0);
#line 1161
    ptr += 2;
#line 1161
    goto switch_break___5;
    case_6___2: /* CIL Label */ 
#line 1161
    if (end - ptr < 3L) {
#line 1161
      return (-2);
    }
#line 1161
    *nextTokPtr = ptr;
#line 1161
    return (0);
#line 1161
    ptr += 3;
#line 1161
    goto switch_break___5;
    case_7___2: /* CIL Label */ 
#line 1161
    if (end - ptr < 4L) {
#line 1161
      return (-2);
    }
#line 1161
    *nextTokPtr = ptr;
#line 1161
    return (0);
#line 1161
    ptr += 4;
#line 1161
    goto switch_break___5;
    switch_default___1: /* CIL Label */ 
#line 1163
    tok = 19;
#line 1164
    goto switch_break___5;
    switch_break___5: /* CIL Label */ ;
    }
#line 1166
    goto switch_break___4;
    case_41: /* CIL Label */ 
#line 1168
    tok = 19;
#line 1169
    goto switch_break___4;
    switch_break___4: /* CIL Label */ ;
    }
#line 1171
    goto switch_break___3;
    case_34___0: /* CIL Label */ 
#line 1174
    if (tok == 19) {
#line 1175
      *nextTokPtr = ptr;
#line 1176
      return (0);
    }
#line 1178
    *nextTokPtr = ptr + 2;
#line 1179
    return (32);
    case_33___0: /* CIL Label */ 
#line 1181
    if (tok == 19) {
#line 1182
      *nextTokPtr = ptr;
#line 1183
      return (0);
    }
#line 1185
    *nextTokPtr = ptr + 2;
#line 1186
    return (31);
    case_15___1: /* CIL Label */ 
#line 1188
    if (tok == 19) {
#line 1189
      *nextTokPtr = ptr;
#line 1190
      return (0);
    }
#line 1192
    *nextTokPtr = ptr + 2;
#line 1193
    return (30);
    switch_default___2: /* CIL Label */ 
#line 1195
    *nextTokPtr = ptr;
#line 1196
    return (0);
    switch_break___3: /* CIL Label */ ;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1199
  return (- tok);
}
}
#line 1202 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmltok_impl.c"
static int little2_attributeValueTok___0(ENCODING const   *enc , char const   *ptr ,
                                         char const   *end , char const   **nextTokPtr ) 
{ 
  char const   *start ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 1207
  if ((unsigned long )ptr == (unsigned long )end) {
#line 1208
    return (-4);
  }
#line 1209
  start = ptr;
  {
#line 1210
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1210
    if (! ((unsigned long )ptr != (unsigned long )end)) {
#line 1210
      goto while_break;
    }
#line 1211
    if ((int const   )*(ptr + 1) == 0) {
#line 1211
      tmp___0 = (int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr];
    } else {
      {
#line 1211
      tmp = unicode_byte_type___0((char )*(ptr + 1), (char )*(ptr + 0));
#line 1211
      tmp___0 = tmp;
      }
    }
    {
#line 1214
    if (tmp___0 == 5) {
#line 1214
      goto case_5;
    }
#line 1214
    if (tmp___0 == 6) {
#line 1214
      goto case_6;
    }
#line 1214
    if (tmp___0 == 7) {
#line 1214
      goto case_7;
    }
#line 1216
    if (tmp___0 == 3) {
#line 1216
      goto case_3;
    }
#line 1221
    if (tmp___0 == 2) {
#line 1221
      goto case_2;
    }
#line 1225
    if (tmp___0 == 10) {
#line 1225
      goto case_10;
    }
#line 1232
    if (tmp___0 == 9) {
#line 1232
      goto case_9;
    }
#line 1244
    if (tmp___0 == 21) {
#line 1244
      goto case_21;
    }
#line 1251
    goto switch_default;
    case_5: /* CIL Label */ 
#line 1214
    ptr += 2;
#line 1214
    goto switch_break;
    case_6: /* CIL Label */ 
#line 1214
    ptr += 3;
#line 1214
    goto switch_break;
    case_7: /* CIL Label */ 
#line 1214
    ptr += 4;
#line 1214
    goto switch_break;
    case_3: /* CIL Label */ 
#line 1217
    if ((unsigned long )ptr == (unsigned long )start) {
      {
#line 1218
      tmp___1 = little2_scanRef___0(enc, ptr + 2, end, nextTokPtr);
      }
#line 1218
      return (tmp___1);
    }
#line 1219
    *nextTokPtr = ptr;
#line 1220
    return (6);
    case_2: /* CIL Label */ 
#line 1223
    *nextTokPtr = ptr;
#line 1224
    return (0);
    case_10: /* CIL Label */ 
#line 1226
    if ((unsigned long )ptr == (unsigned long )start) {
#line 1227
      *nextTokPtr = ptr + 2;
#line 1228
      return (7);
    }
#line 1230
    *nextTokPtr = ptr;
#line 1231
    return (6);
    case_9: /* CIL Label */ 
#line 1233
    if ((unsigned long )ptr == (unsigned long )start) {
#line 1234
      ptr += 2;
#line 1235
      if ((unsigned long )ptr == (unsigned long )end) {
#line 1236
        return (-3);
      }
#line 1237
      if ((int const   )*(ptr + 1) == 0) {
#line 1237
        tmp___3 = (int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr];
      } else {
        {
#line 1237
        tmp___2 = unicode_byte_type___0((char )*(ptr + 1), (char )*(ptr + 0));
#line 1237
        tmp___3 = tmp___2;
        }
      }
#line 1237
      if (tmp___3 == 10) {
#line 1238
        ptr += 2;
      }
#line 1239
      *nextTokPtr = ptr;
#line 1240
      return (7);
    }
#line 1242
    *nextTokPtr = ptr;
#line 1243
    return (6);
    case_21: /* CIL Label */ 
#line 1245
    if ((unsigned long )ptr == (unsigned long )start) {
#line 1246
      *nextTokPtr = ptr + 2;
#line 1247
      return (39);
    }
#line 1249
    *nextTokPtr = ptr;
#line 1250
    return (6);
    switch_default: /* CIL Label */ 
#line 1252
    ptr += 2;
#line 1253
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1256
  *nextTokPtr = ptr;
#line 1257
  return (6);
}
}
#line 1260 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmltok_impl.c"
static int little2_entityValueTok___0(ENCODING const   *enc , char const   *ptr ,
                                      char const   *end , char const   **nextTokPtr ) 
{ 
  char const   *start ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tok ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 1265
  if ((unsigned long )ptr == (unsigned long )end) {
#line 1266
    return (-4);
  }
#line 1267
  start = ptr;
  {
#line 1268
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1268
    if (! ((unsigned long )ptr != (unsigned long )end)) {
#line 1268
      goto while_break;
    }
#line 1269
    if ((int const   )*(ptr + 1) == 0) {
#line 1269
      tmp___0 = (int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr];
    } else {
      {
#line 1269
      tmp = unicode_byte_type___0((char )*(ptr + 1), (char )*(ptr + 0));
#line 1269
      tmp___0 = tmp;
      }
    }
    {
#line 1272
    if (tmp___0 == 5) {
#line 1272
      goto case_5;
    }
#line 1272
    if (tmp___0 == 6) {
#line 1272
      goto case_6;
    }
#line 1272
    if (tmp___0 == 7) {
#line 1272
      goto case_7;
    }
#line 1274
    if (tmp___0 == 3) {
#line 1274
      goto case_3;
    }
#line 1279
    if (tmp___0 == 30) {
#line 1279
      goto case_30;
    }
#line 1287
    if (tmp___0 == 10) {
#line 1287
      goto case_10;
    }
#line 1294
    if (tmp___0 == 9) {
#line 1294
      goto case_9;
    }
#line 1306
    goto switch_default;
    case_5: /* CIL Label */ 
#line 1272
    ptr += 2;
#line 1272
    goto switch_break;
    case_6: /* CIL Label */ 
#line 1272
    ptr += 3;
#line 1272
    goto switch_break;
    case_7: /* CIL Label */ 
#line 1272
    ptr += 4;
#line 1272
    goto switch_break;
    case_3: /* CIL Label */ 
#line 1275
    if ((unsigned long )ptr == (unsigned long )start) {
      {
#line 1276
      tmp___1 = little2_scanRef___0(enc, ptr + 2, end, nextTokPtr);
      }
#line 1276
      return (tmp___1);
    }
#line 1277
    *nextTokPtr = ptr;
#line 1278
    return (6);
    case_30: /* CIL Label */ 
#line 1280
    if ((unsigned long )ptr == (unsigned long )start) {
      {
#line 1281
      tmp___2 = little2_scanPercent___0(enc, ptr + 2, end, nextTokPtr);
#line 1281
      tok = tmp___2;
      }
#line 1283
      if (tok == 22) {
#line 1283
        tmp___3 = 0;
      } else {
#line 1283
        tmp___3 = tok;
      }
#line 1283
      return (tmp___3);
    }
#line 1285
    *nextTokPtr = ptr;
#line 1286
    return (6);
    case_10: /* CIL Label */ 
#line 1288
    if ((unsigned long )ptr == (unsigned long )start) {
#line 1289
      *nextTokPtr = ptr + 2;
#line 1290
      return (7);
    }
#line 1292
    *nextTokPtr = ptr;
#line 1293
    return (6);
    case_9: /* CIL Label */ 
#line 1295
    if ((unsigned long )ptr == (unsigned long )start) {
#line 1296
      ptr += 2;
#line 1297
      if ((unsigned long )ptr == (unsigned long )end) {
#line 1298
        return (-3);
      }
#line 1299
      if ((int const   )*(ptr + 1) == 0) {
#line 1299
        tmp___5 = (int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr];
      } else {
        {
#line 1299
        tmp___4 = unicode_byte_type___0((char )*(ptr + 1), (char )*(ptr + 0));
#line 1299
        tmp___5 = tmp___4;
        }
      }
#line 1299
      if (tmp___5 == 10) {
#line 1300
        ptr += 2;
      }
#line 1301
      *nextTokPtr = ptr;
#line 1302
      return (7);
    }
#line 1304
    *nextTokPtr = ptr;
#line 1305
    return (6);
    switch_default: /* CIL Label */ 
#line 1307
    ptr += 2;
#line 1308
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1311
  *nextTokPtr = ptr;
#line 1312
  return (6);
}
}
#line 1317 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmltok_impl.c"
static int little2_ignoreSectionTok___0(ENCODING const   *enc , char const   *ptr ,
                                        char const   *end , char const   **nextTokPtr ) 
{ 
  int level ;
  size_t n ;
  int tmp ;
  int tmp___0 ;

  {
#line 1321
  level = 0;
#line 1323
  n = (size_t )(end - ptr);
#line 1324
  if (n & 1UL) {
#line 1325
    n &= 0xfffffffffffffffeUL;
#line 1326
    end = ptr + n;
  }
  {
#line 1329
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1329
    if (! ((unsigned long )ptr != (unsigned long )end)) {
#line 1329
      goto while_break;
    }
#line 1330
    if ((int const   )*(ptr + 1) == 0) {
#line 1330
      tmp___0 = (int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr];
    } else {
      {
#line 1330
      tmp = unicode_byte_type___0((char )*(ptr + 1), (char )*(ptr + 0));
#line 1330
      tmp___0 = tmp;
      }
    }
    {
#line 1331
    if (tmp___0 == 5) {
#line 1331
      goto case_5;
    }
#line 1331
    if (tmp___0 == 6) {
#line 1331
      goto case_6;
    }
#line 1331
    if (tmp___0 == 7) {
#line 1331
      goto case_7;
    }
#line 1331
    if (tmp___0 == 8) {
#line 1331
      goto case_8;
    }
#line 1331
    if (tmp___0 == 1) {
#line 1331
      goto case_8;
    }
#line 1331
    if (tmp___0 == 0) {
#line 1331
      goto case_8;
    }
#line 1332
    if (tmp___0 == 2) {
#line 1332
      goto case_2;
    }
#line 1344
    if (tmp___0 == 4) {
#line 1344
      goto case_4;
    }
#line 1360
    goto switch_default;
    case_5: /* CIL Label */ 
#line 1331
    if (end - ptr < 2L) {
#line 1331
      return (-2);
    }
#line 1331
    ptr += 2;
#line 1331
    goto switch_break;
    case_6: /* CIL Label */ 
#line 1331
    if (end - ptr < 3L) {
#line 1331
      return (-2);
    }
#line 1331
    ptr += 3;
#line 1331
    goto switch_break;
    case_7: /* CIL Label */ 
#line 1331
    if (end - ptr < 4L) {
#line 1331
      return (-2);
    }
#line 1331
    ptr += 4;
#line 1331
    goto switch_break;
    case_8: /* CIL Label */ 
    case_1: /* CIL Label */ 
    case_0: /* CIL Label */ 
#line 1331
    *nextTokPtr = ptr;
#line 1331
    return (0);
    case_2: /* CIL Label */ 
#line 1333
    ptr += 2;
#line 1333
    if ((unsigned long )ptr == (unsigned long )end) {
#line 1334
      return (-1);
    }
#line 1335
    if ((int const   )*(ptr + 1) == 0) {
#line 1335
      if ((int const   )*(ptr + 0) == 33) {
#line 1336
        ptr += 2;
#line 1336
        if ((unsigned long )ptr == (unsigned long )end) {
#line 1337
          return (-1);
        }
#line 1338
        if ((int const   )*(ptr + 1) == 0) {
#line 1338
          if ((int const   )*(ptr + 0) == 91) {
#line 1339
            level ++;
#line 1340
            ptr += 2;
          }
        }
      }
    }
#line 1343
    goto switch_break;
    case_4: /* CIL Label */ 
#line 1345
    ptr += 2;
#line 1345
    if ((unsigned long )ptr == (unsigned long )end) {
#line 1346
      return (-1);
    }
#line 1347
    if ((int const   )*(ptr + 1) == 0) {
#line 1347
      if ((int const   )*(ptr + 0) == 93) {
#line 1348
        ptr += 2;
#line 1348
        if ((unsigned long )ptr == (unsigned long )end) {
#line 1349
          return (-1);
        }
#line 1350
        if ((int const   )*(ptr + 1) == 0) {
#line 1350
          if ((int const   )*(ptr + 0) == 62) {
#line 1351
            ptr += 2;
#line 1352
            if (level == 0) {
#line 1353
              *nextTokPtr = ptr;
#line 1354
              return (42);
            }
#line 1356
            level --;
          }
        }
      }
    }
#line 1359
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 1361
    ptr += 2;
#line 1362
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1365
  return (-1);
}
}
#line 1370 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmltok_impl.c"
static int little2_isPublicId___0(ENCODING const   *enc , char const   *ptr , char const   *end ,
                                  char const   **badPtr ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 1374
  ptr += 2;
#line 1375
  end -= 2;
  {
#line 1376
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1376
    if (! ((unsigned long )ptr != (unsigned long )end)) {
#line 1376
      goto while_break;
    }
#line 1377
    if ((int const   )*(ptr + 1) == 0) {
#line 1377
      tmp___0 = (int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr];
    } else {
      {
#line 1377
      tmp = unicode_byte_type___0((char )*(ptr + 1), (char )*(ptr + 0));
#line 1377
      tmp___0 = tmp;
      }
    }
    {
#line 1397
    if (tmp___0 == 23) {
#line 1397
      goto case_23;
    }
#line 1397
    if (tmp___0 == 19) {
#line 1397
      goto case_23;
    }
#line 1397
    if (tmp___0 == 30) {
#line 1397
      goto case_23;
    }
#line 1397
    if (tmp___0 == 33) {
#line 1397
      goto case_23;
    }
#line 1397
    if (tmp___0 == 16) {
#line 1397
      goto case_23;
    }
#line 1397
    if (tmp___0 == 18) {
#line 1397
      goto case_23;
    }
#line 1397
    if (tmp___0 == 10) {
#line 1397
      goto case_23;
    }
#line 1397
    if (tmp___0 == 9) {
#line 1397
      goto case_23;
    }
#line 1397
    if (tmp___0 == 15) {
#line 1397
      goto case_23;
    }
#line 1397
    if (tmp___0 == 14) {
#line 1397
      goto case_23;
    }
#line 1397
    if (tmp___0 == 17) {
#line 1397
      goto case_23;
    }
#line 1397
    if (tmp___0 == 35) {
#line 1397
      goto case_23;
    }
#line 1397
    if (tmp___0 == 34) {
#line 1397
      goto case_23;
    }
#line 1397
    if (tmp___0 == 32) {
#line 1397
      goto case_23;
    }
#line 1397
    if (tmp___0 == 31) {
#line 1397
      goto case_23;
    }
#line 1397
    if (tmp___0 == 13) {
#line 1397
      goto case_23;
    }
#line 1397
    if (tmp___0 == 27) {
#line 1397
      goto case_23;
    }
#line 1397
    if (tmp___0 == 24) {
#line 1397
      goto case_23;
    }
#line 1397
    if (tmp___0 == 25) {
#line 1397
      goto case_23;
    }
#line 1400
    if (tmp___0 == 21) {
#line 1400
      goto case_21;
    }
#line 1407
    if (tmp___0 == 22) {
#line 1407
      goto case_22;
    }
#line 1407
    if (tmp___0 == 26) {
#line 1407
      goto case_22;
    }
#line 1410
    goto switch_default;
    case_23: /* CIL Label */ 
    case_19: /* CIL Label */ 
    case_30: /* CIL Label */ 
    case_33: /* CIL Label */ 
    case_16: /* CIL Label */ 
    case_18: /* CIL Label */ 
    case_10: /* CIL Label */ 
    case_9: /* CIL Label */ 
    case_15: /* CIL Label */ 
    case_14: /* CIL Label */ 
    case_17: /* CIL Label */ 
    case_35: /* CIL Label */ 
    case_34: /* CIL Label */ 
    case_32: /* CIL Label */ 
    case_31: /* CIL Label */ 
    case_13: /* CIL Label */ 
    case_27: /* CIL Label */ 
    case_24: /* CIL Label */ 
    case_25: /* CIL Label */ 
#line 1399
    goto switch_break;
    case_21: /* CIL Label */ 
#line 1401
    if ((int const   )*(ptr + 1) == 0) {
#line 1401
      if ((int const   )*(ptr + 0) == 9) {
#line 1402
        *badPtr = ptr;
#line 1403
        return (0);
      }
    }
#line 1405
    goto switch_break;
    case_22: /* CIL Label */ 
    case_26: /* CIL Label */ 
#line 1408
    if ((int const   )*(ptr + 1) == 0) {
#line 1408
      tmp___1 = (int const   )*(ptr + 0);
    } else {
#line 1408
      tmp___1 = (int const   )-1;
    }
#line 1408
    if (! (tmp___1 & -128)) {
#line 1409
      goto switch_break;
    }
    switch_default: /* CIL Label */ 
#line 1411
    if ((int const   )*(ptr + 1) == 0) {
#line 1411
      tmp___2 = (int const   )*(ptr + 0);
    } else {
#line 1411
      tmp___2 = (int const   )-1;
    }
    {
#line 1413
    if (tmp___2 == 64) {
#line 1413
      goto case_64;
    }
#line 1413
    if (tmp___2 == 36) {
#line 1413
      goto case_64;
    }
#line 1415
    goto switch_default___0;
    case_64: /* CIL Label */ 
    case_36: /* CIL Label */ 
#line 1414
    goto switch_break___0;
    switch_default___0: /* CIL Label */ 
#line 1416
    *badPtr = ptr;
#line 1417
    return (0);
    switch_break___0: /* CIL Label */ ;
    }
#line 1419
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 1376
    ptr += 2;
  }
  while_break: /* CIL Label */ ;
  }
#line 1422
  return (1);
}
}
#line 1430 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmltok_impl.c"
static int little2_getAtts___0(ENCODING const   *enc , char const   *ptr , int attsMax ,
                               ATTRIBUTE *atts ) 
{ 
  enum __anonenum_state_6___0 state ;
  int nAtts ;
  int open___0 ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 1434
  state = (enum __anonenum_state_6___0 )1;
#line 1435
  nAtts = 0;
#line 1436
  open___0 = 0;
#line 1439
  ptr += 2;
  {
#line 1439
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1440
    if ((int const   )*(ptr + 1) == 0) {
#line 1440
      tmp___0 = (int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr];
    } else {
      {
#line 1440
      tmp = unicode_byte_type___0((char )*(ptr + 1), (char )*(ptr + 0));
#line 1440
      tmp___0 = tmp;
      }
    }
    {
#line 1451
    if (tmp___0 == 5) {
#line 1451
      goto case_5;
    }
#line 1451
    if (tmp___0 == 6) {
#line 1451
      goto case_6;
    }
#line 1451
    if (tmp___0 == 7) {
#line 1451
      goto case_7;
    }
#line 1455
    if (tmp___0 == 24) {
#line 1455
      goto case_24;
    }
#line 1455
    if (tmp___0 == 22) {
#line 1455
      goto case_24;
    }
#line 1455
    if (tmp___0 == 29) {
#line 1455
      goto case_24;
    }
#line 1459
    if (tmp___0 == 12) {
#line 1459
      goto case_12;
    }
#line 1473
    if (tmp___0 == 13) {
#line 1473
      goto case_13;
    }
#line 1487
    if (tmp___0 == 3) {
#line 1487
      goto case_3;
    }
#line 1491
    if (tmp___0 == 21) {
#line 1491
      goto case_21;
    }
#line 1503
    if (tmp___0 == 10) {
#line 1503
      goto case_10;
    }
#line 1503
    if (tmp___0 == 9) {
#line 1503
      goto case_10;
    }
#line 1512
    if (tmp___0 == 17) {
#line 1512
      goto case_17;
    }
#line 1512
    if (tmp___0 == 11) {
#line 1512
      goto case_17;
    }
#line 1516
    goto switch_default;
    case_5: /* CIL Label */ 
#line 1451
    if ((unsigned int )state == 0U) {
#line 1451
      if (nAtts < attsMax) {
#line 1451
        (atts + nAtts)->name = ptr;
#line 1451
        (atts + nAtts)->normalized = (char)1;
      }
#line 1451
      state = (enum __anonenum_state_6___0 )1;
    }
#line 1451
    ptr += 0;
#line 1451
    goto switch_break;
    case_6: /* CIL Label */ 
#line 1451
    if ((unsigned int )state == 0U) {
#line 1451
      if (nAtts < attsMax) {
#line 1451
        (atts + nAtts)->name = ptr;
#line 1451
        (atts + nAtts)->normalized = (char)1;
      }
#line 1451
      state = (enum __anonenum_state_6___0 )1;
    }
#line 1451
    ptr ++;
#line 1451
    goto switch_break;
    case_7: /* CIL Label */ 
#line 1451
    if ((unsigned int )state == 0U) {
#line 1451
      if (nAtts < attsMax) {
#line 1451
        (atts + nAtts)->name = ptr;
#line 1451
        (atts + nAtts)->normalized = (char)1;
      }
#line 1451
      state = (enum __anonenum_state_6___0 )1;
    }
#line 1451
    ptr += 2;
#line 1451
    goto switch_break;
    case_24: /* CIL Label */ 
    case_22: /* CIL Label */ 
    case_29: /* CIL Label */ 
#line 1456
    if ((unsigned int )state == 0U) {
#line 1456
      if (nAtts < attsMax) {
#line 1456
        (atts + nAtts)->name = ptr;
#line 1456
        (atts + nAtts)->normalized = (char)1;
      }
#line 1456
      state = (enum __anonenum_state_6___0 )1;
    }
#line 1457
    goto switch_break;
    case_12: /* CIL Label */ 
#line 1460
    if ((unsigned int )state != 2U) {
#line 1461
      if (nAtts < attsMax) {
#line 1462
        (atts + nAtts)->valuePtr = ptr + 2;
      }
#line 1463
      state = (enum __anonenum_state_6___0 )2;
#line 1464
      open___0 = 12;
    } else
#line 1466
    if (open___0 == 12) {
#line 1467
      state = (enum __anonenum_state_6___0 )0;
#line 1468
      if (nAtts < attsMax) {
#line 1469
        (atts + nAtts)->valueEnd = ptr;
      }
#line 1470
      nAtts ++;
    }
#line 1472
    goto switch_break;
    case_13: /* CIL Label */ 
#line 1474
    if ((unsigned int )state != 2U) {
#line 1475
      if (nAtts < attsMax) {
#line 1476
        (atts + nAtts)->valuePtr = ptr + 2;
      }
#line 1477
      state = (enum __anonenum_state_6___0 )2;
#line 1478
      open___0 = 13;
    } else
#line 1480
    if (open___0 == 13) {
#line 1481
      state = (enum __anonenum_state_6___0 )0;
#line 1482
      if (nAtts < attsMax) {
#line 1483
        (atts + nAtts)->valueEnd = ptr;
      }
#line 1484
      nAtts ++;
    }
#line 1486
    goto switch_break;
    case_3: /* CIL Label */ 
#line 1488
    if (nAtts < attsMax) {
#line 1489
      (atts + nAtts)->normalized = (char)0;
    }
#line 1490
    goto switch_break;
    case_21: /* CIL Label */ 
#line 1492
    if ((unsigned int )state == 1U) {
#line 1493
      state = (enum __anonenum_state_6___0 )0;
    } else
#line 1494
    if ((unsigned int )state == 2U) {
#line 1494
      if (nAtts < attsMax) {
#line 1494
        if ((atts + nAtts)->normalized) {
#line 1494
          if ((unsigned long )ptr == (unsigned long )(atts + nAtts)->valuePtr) {
#line 1501
            (atts + nAtts)->normalized = (char)0;
          } else {
#line 1494
            if ((int const   )*(ptr + 1) == 0) {
#line 1494
              tmp___1 = (int const   )*(ptr + 0);
            } else {
#line 1494
              tmp___1 = (int const   )-1;
            }
#line 1494
            if (tmp___1 != 32) {
#line 1501
              (atts + nAtts)->normalized = (char)0;
            } else {
#line 1494
              if ((int const   )*((ptr + 2) + 1) == 0) {
#line 1494
                tmp___2 = (int const   )*((ptr + 2) + 0);
              } else {
#line 1494
                tmp___2 = (int const   )-1;
              }
#line 1494
              if (tmp___2 == 32) {
#line 1501
                (atts + nAtts)->normalized = (char)0;
              } else {
#line 1494
                if ((int const   )*((ptr + 2) + 1) == 0) {
#line 1494
                  tmp___4 = (int )((struct normal_encoding *)enc)->type[(unsigned char )*(ptr + 2)];
                } else {
                  {
#line 1494
                  tmp___3 = unicode_byte_type___0((char )*((ptr + 2) + 1), (char )*((ptr + 2) + 0));
#line 1494
                  tmp___4 = tmp___3;
                  }
                }
#line 1494
                if (tmp___4 == open___0) {
#line 1501
                  (atts + nAtts)->normalized = (char)0;
                }
              }
            }
          }
        }
      }
    }
#line 1502
    goto switch_break;
    case_10: /* CIL Label */ 
    case_9: /* CIL Label */ 
#line 1506
    if ((unsigned int )state == 1U) {
#line 1507
      state = (enum __anonenum_state_6___0 )0;
    } else
#line 1508
    if ((unsigned int )state == 2U) {
#line 1508
      if (nAtts < attsMax) {
#line 1509
        (atts + nAtts)->normalized = (char)0;
      }
    }
#line 1510
    goto switch_break;
    case_17: /* CIL Label */ 
    case_11: /* CIL Label */ 
#line 1513
    if ((unsigned int )state != 2U) {
#line 1514
      return (nAtts);
    }
#line 1515
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 1517
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 1439
    ptr += 2;
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 1523 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmltok_impl.c"
static int little2_charRefNumber___0(ENCODING const   *enc , char const   *ptr ) 
{ 
  int result ;
  int c___0 ;
  int tmp ;
  int c___1 ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 1526
  result = 0;
#line 1528
  ptr += 4;
#line 1529
  if ((int const   )*(ptr + 1) == 0) {
#line 1529
    if ((int const   )*(ptr + 0) == 120) {
#line 1530
      ptr += 2;
      {
#line 1530
      while (1) {
        while_continue: /* CIL Label */ ;
#line 1530
        if ((int const   )*(ptr + 1) == 0) {
#line 1530
          if ((int const   )*(ptr + 0) == 59) {
#line 1530
            goto while_break;
          }
        }
#line 1533
        if ((int const   )*(ptr + 1) == 0) {
#line 1533
          tmp = (int const   )*(ptr + 0);
        } else {
#line 1533
          tmp = (int const   )-1;
        }
#line 1533
        c___0 = (int )tmp;
        {
#line 1536
        if (c___0 == 57) {
#line 1536
          goto case_57;
        }
#line 1536
        if (c___0 == 56) {
#line 1536
          goto case_57;
        }
#line 1536
        if (c___0 == 55) {
#line 1536
          goto case_57;
        }
#line 1536
        if (c___0 == 54) {
#line 1536
          goto case_57;
        }
#line 1536
        if (c___0 == 53) {
#line 1536
          goto case_57;
        }
#line 1536
        if (c___0 == 52) {
#line 1536
          goto case_57;
        }
#line 1536
        if (c___0 == 51) {
#line 1536
          goto case_57;
        }
#line 1536
        if (c___0 == 50) {
#line 1536
          goto case_57;
        }
#line 1536
        if (c___0 == 49) {
#line 1536
          goto case_57;
        }
#line 1536
        if (c___0 == 48) {
#line 1536
          goto case_57;
        }
#line 1541
        if (c___0 == 70) {
#line 1541
          goto case_70;
        }
#line 1541
        if (c___0 == 69) {
#line 1541
          goto case_70;
        }
#line 1541
        if (c___0 == 68) {
#line 1541
          goto case_70;
        }
#line 1541
        if (c___0 == 67) {
#line 1541
          goto case_70;
        }
#line 1541
        if (c___0 == 66) {
#line 1541
          goto case_70;
        }
#line 1541
        if (c___0 == 65) {
#line 1541
          goto case_70;
        }
#line 1546
        if (c___0 == 102) {
#line 1546
          goto case_102;
        }
#line 1546
        if (c___0 == 101) {
#line 1546
          goto case_102;
        }
#line 1546
        if (c___0 == 100) {
#line 1546
          goto case_102;
        }
#line 1546
        if (c___0 == 99) {
#line 1546
          goto case_102;
        }
#line 1546
        if (c___0 == 98) {
#line 1546
          goto case_102;
        }
#line 1546
        if (c___0 == 97) {
#line 1546
          goto case_102;
        }
#line 1534
        goto switch_break;
        case_57: /* CIL Label */ 
        case_56: /* CIL Label */ 
        case_55: /* CIL Label */ 
        case_54: /* CIL Label */ 
        case_53: /* CIL Label */ 
        case_52: /* CIL Label */ 
        case_51: /* CIL Label */ 
        case_50: /* CIL Label */ 
        case_49: /* CIL Label */ 
        case_48: /* CIL Label */ 
#line 1537
        result <<= 4;
#line 1538
        result |= c___0 - 48;
#line 1539
        goto switch_break;
        case_70: /* CIL Label */ 
        case_69: /* CIL Label */ 
        case_68: /* CIL Label */ 
        case_67: /* CIL Label */ 
        case_66: /* CIL Label */ 
        case_65: /* CIL Label */ 
#line 1542
        result <<= 4;
#line 1543
        result += 10 + (c___0 - 65);
#line 1544
        goto switch_break;
        case_102: /* CIL Label */ 
        case_101: /* CIL Label */ 
        case_100: /* CIL Label */ 
        case_99: /* CIL Label */ 
        case_98: /* CIL Label */ 
        case_97: /* CIL Label */ 
#line 1547
        result <<= 4;
#line 1548
        result += 10 + (c___0 - 97);
#line 1549
        goto switch_break;
        switch_break: /* CIL Label */ ;
        }
#line 1551
        if (result >= 1114112) {
#line 1552
          return (-1);
        }
#line 1530
        ptr += 2;
      }
      while_break: /* CIL Label */ ;
      }
    } else {
#line 1529
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
    {
#line 1556
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1556
      if ((int const   )*(ptr + 1) == 0) {
#line 1556
        if ((int const   )*(ptr + 0) == 59) {
#line 1556
          goto while_break___0;
        }
      }
#line 1557
      if ((int const   )*(ptr + 1) == 0) {
#line 1557
        tmp___0 = (int const   )*(ptr + 0);
      } else {
#line 1557
        tmp___0 = (int const   )-1;
      }
#line 1557
      c___1 = (int )tmp___0;
#line 1558
      result *= 10;
#line 1559
      result += c___1 - 48;
#line 1560
      if (result >= 1114112) {
#line 1561
        return (-1);
      }
#line 1556
      ptr += 2;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  {
#line 1564
  tmp___1 = checkCharRefNumber___0(result);
  }
#line 1564
  return (tmp___1);
}
}
#line 1567 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmltok_impl.c"
static int little2_predefinedEntityName___0(ENCODING const   *enc , char const   *ptr ,
                                            char const   *end ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  {
#line 1572
  if ((end - ptr) / 2L == 2L) {
#line 1572
    goto case_2;
  }
#line 1582
  if ((end - ptr) / 2L == 3L) {
#line 1582
    goto case_3;
  }
#line 1592
  if ((end - ptr) / 2L == 4L) {
#line 1592
    goto case_4;
  }
#line 1571
  goto switch_break;
  case_2: /* CIL Label */ 
#line 1573
  if ((int const   )*((ptr + 2) + 1) == 0) {
#line 1573
    if ((int const   )*((ptr + 2) + 0) == 116) {
#line 1574
      if ((int const   )*(ptr + 1) == 0) {
#line 1574
        tmp = (int const   )*(ptr + 0);
      } else {
#line 1574
        tmp = (int const   )-1;
      }
      {
#line 1575
      if (tmp == 108) {
#line 1575
        goto case_108;
      }
#line 1577
      if (tmp == 103) {
#line 1577
        goto case_103;
      }
#line 1574
      goto switch_break___0;
      case_108: /* CIL Label */ 
#line 1576
      return (60);
      case_103: /* CIL Label */ 
#line 1578
      return (62);
      switch_break___0: /* CIL Label */ ;
      }
    }
  }
#line 1581
  goto switch_break;
  case_3: /* CIL Label */ 
#line 1583
  if ((int const   )*(ptr + 1) == 0) {
#line 1583
    if ((int const   )*(ptr + 0) == 97) {
#line 1584
      ptr += 2;
#line 1585
      if ((int const   )*(ptr + 1) == 0) {
#line 1585
        if ((int const   )*(ptr + 0) == 109) {
#line 1586
          ptr += 2;
#line 1587
          if ((int const   )*(ptr + 1) == 0) {
#line 1587
            if ((int const   )*(ptr + 0) == 112) {
#line 1588
              return (38);
            }
          }
        }
      }
    }
  }
#line 1591
  goto switch_break;
  case_4: /* CIL Label */ 
#line 1593
  if ((int const   )*(ptr + 1) == 0) {
#line 1593
    tmp___0 = (int const   )*(ptr + 0);
  } else {
#line 1593
    tmp___0 = (int const   )-1;
  }
  {
#line 1594
  if (tmp___0 == 113) {
#line 1594
    goto case_113;
  }
#line 1605
  if (tmp___0 == 97) {
#line 1605
    goto case_97;
  }
#line 1593
  goto switch_break___1;
  case_113: /* CIL Label */ 
#line 1595
  ptr += 2;
#line 1596
  if ((int const   )*(ptr + 1) == 0) {
#line 1596
    if ((int const   )*(ptr + 0) == 117) {
#line 1597
      ptr += 2;
#line 1598
      if ((int const   )*(ptr + 1) == 0) {
#line 1598
        if ((int const   )*(ptr + 0) == 111) {
#line 1599
          ptr += 2;
#line 1600
          if ((int const   )*(ptr + 1) == 0) {
#line 1600
            if ((int const   )*(ptr + 0) == 116) {
#line 1601
              return (34);
            }
          }
        }
      }
    }
  }
#line 1604
  goto switch_break___1;
  case_97: /* CIL Label */ 
#line 1606
  ptr += 2;
#line 1607
  if ((int const   )*(ptr + 1) == 0) {
#line 1607
    if ((int const   )*(ptr + 0) == 112) {
#line 1608
      ptr += 2;
#line 1609
      if ((int const   )*(ptr + 1) == 0) {
#line 1609
        if ((int const   )*(ptr + 0) == 111) {
#line 1610
          ptr += 2;
#line 1611
          if ((int const   )*(ptr + 1) == 0) {
#line 1611
            if ((int const   )*(ptr + 0) == 115) {
#line 1612
              return (39);
            }
          }
        }
      }
    }
  }
#line 1615
  goto switch_break___1;
  switch_break___1: /* CIL Label */ ;
  }
  switch_break: /* CIL Label */ ;
  }
#line 1618
  return (0);
}
}
#line 1621 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmltok_impl.c"
static int little2_sameName___0(ENCODING const   *enc , char const   *ptr1 , char const   *ptr2 ) 
{ 
  int tmp ;
  int tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;
  char const   *tmp___4 ;
  char const   *tmp___5 ;
  char const   *tmp___6 ;
  char const   *tmp___7 ;
  char const   *tmp___8 ;
  char const   *tmp___9 ;
  char const   *tmp___10 ;
  char const   *tmp___11 ;
  char const   *tmp___12 ;
  int tmp___17 ;
  int tmp___18 ;

  {
  {
#line 1624
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1625
    if ((int const   )*(ptr1 + 1) == 0) {
#line 1625
      tmp___0 = (int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr1];
    } else {
      {
#line 1625
      tmp = unicode_byte_type___0((char )*(ptr1 + 1), (char )*(ptr1 + 0));
#line 1625
      tmp___0 = tmp;
      }
    }
    {
#line 1630
    if (tmp___0 == 7) {
#line 1630
      goto case_7;
    }
#line 1630
    if (tmp___0 == 6) {
#line 1630
      goto case_6;
    }
#line 1630
    if (tmp___0 == 5) {
#line 1630
      goto case_5;
    }
#line 1644
    if (tmp___0 == 27) {
#line 1644
      goto case_27;
    }
#line 1644
    if (tmp___0 == 26) {
#line 1644
      goto case_27;
    }
#line 1644
    if (tmp___0 == 25) {
#line 1644
      goto case_27;
    }
#line 1644
    if (tmp___0 == 24) {
#line 1644
      goto case_27;
    }
#line 1644
    if (tmp___0 == 23) {
#line 1644
      goto case_27;
    }
#line 1644
    if (tmp___0 == 22) {
#line 1644
      goto case_27;
    }
#line 1644
    if (tmp___0 == 29) {
#line 1644
      goto case_27;
    }
#line 1660
    goto switch_default;
    case_7: /* CIL Label */ 
#line 1630
    tmp___1 = ptr1;
#line 1630
    ptr1 ++;
#line 1630
    tmp___2 = ptr2;
#line 1630
    ptr2 ++;
#line 1630
    if ((int const   )*tmp___1 != (int const   )*tmp___2) {
#line 1630
      return (0);
    }
    case_6: /* CIL Label */ 
#line 1630
    tmp___3 = ptr1;
#line 1630
    ptr1 ++;
#line 1630
    tmp___4 = ptr2;
#line 1630
    ptr2 ++;
#line 1630
    if ((int const   )*tmp___3 != (int const   )*tmp___4) {
#line 1630
      return (0);
    }
    case_5: /* CIL Label */ 
#line 1630
    tmp___5 = ptr1;
#line 1630
    ptr1 ++;
#line 1630
    tmp___6 = ptr2;
#line 1630
    ptr2 ++;
#line 1630
    if ((int const   )*tmp___5 != (int const   )*tmp___6) {
#line 1630
      return (0);
    }
#line 1633
    tmp___7 = ptr1;
#line 1633
    ptr1 ++;
#line 1633
    tmp___8 = ptr2;
#line 1633
    ptr2 ++;
#line 1633
    if ((int const   )*tmp___7 != (int const   )*tmp___8) {
#line 1634
      return (0);
    }
#line 1635
    goto switch_break;
    case_27: /* CIL Label */ 
    case_26: /* CIL Label */ 
    case_25: /* CIL Label */ 
    case_24: /* CIL Label */ 
    case_23: /* CIL Label */ 
    case_22: /* CIL Label */ 
    case_29: /* CIL Label */ 
#line 1645
    tmp___9 = ptr2;
#line 1645
    ptr2 ++;
#line 1645
    tmp___10 = ptr1;
#line 1645
    ptr1 ++;
#line 1645
    if ((int const   )*tmp___9 != (int const   )*tmp___10) {
#line 1646
      return (0);
    }
#line 1648
    tmp___11 = ptr2;
#line 1648
    ptr2 ++;
#line 1648
    tmp___12 = ptr1;
#line 1648
    ptr1 ++;
#line 1648
    if ((int const   )*tmp___11 != (int const   )*tmp___12) {
#line 1649
      return (0);
    }
#line 1659
    goto switch_break;
    switch_default: /* CIL Label */ ;
#line 1663
    if ((int const   )*(ptr2 + 1) == 0) {
#line 1663
      tmp___18 = (int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr2];
    } else {
      {
#line 1663
      tmp___17 = unicode_byte_type___0((char )*(ptr2 + 1), (char )*(ptr2 + 0));
#line 1663
      tmp___18 = tmp___17;
      }
    }
    {
#line 1675
    if (tmp___18 == 27) {
#line 1675
      goto case_27___0;
    }
#line 1675
    if (tmp___18 == 26) {
#line 1675
      goto case_27___0;
    }
#line 1675
    if (tmp___18 == 25) {
#line 1675
      goto case_27___0;
    }
#line 1675
    if (tmp___18 == 24) {
#line 1675
      goto case_27___0;
    }
#line 1675
    if (tmp___18 == 23) {
#line 1675
      goto case_27___0;
    }
#line 1675
    if (tmp___18 == 22) {
#line 1675
      goto case_27___0;
    }
#line 1675
    if (tmp___18 == 29) {
#line 1675
      goto case_27___0;
    }
#line 1675
    if (tmp___18 == 7) {
#line 1675
      goto case_27___0;
    }
#line 1675
    if (tmp___18 == 6) {
#line 1675
      goto case_27___0;
    }
#line 1675
    if (tmp___18 == 5) {
#line 1675
      goto case_27___0;
    }
#line 1677
    goto switch_default___0;
    case_27___0: /* CIL Label */ 
    case_26___0: /* CIL Label */ 
    case_25___0: /* CIL Label */ 
    case_24___0: /* CIL Label */ 
    case_23___0: /* CIL Label */ 
    case_22___0: /* CIL Label */ 
    case_29___0: /* CIL Label */ 
    case_7___0: /* CIL Label */ 
    case_6___0: /* CIL Label */ 
    case_5___0: /* CIL Label */ 
#line 1676
    return (0);
    switch_default___0: /* CIL Label */ 
#line 1678
    return (1);
    switch_break___0: /* CIL Label */ ;
    }
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 1685 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmltok_impl.c"
static int little2_nameMatchesAscii___0(ENCODING const   *enc , char const   *ptr1 ,
                                        char const   *end1 , char const   *ptr2 ) 
{ 


  {
  {
#line 1689
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1689
    if (! *ptr2) {
#line 1689
      goto while_break;
    }
#line 1690
    if ((unsigned long )ptr1 == (unsigned long )end1) {
#line 1691
      return (0);
    }
#line 1692
    if ((int const   )*(ptr1 + 1) == 0) {
#line 1692
      if (! ((int const   )*(ptr1 + 0) == (int const   )*ptr2)) {
#line 1693
        return (0);
      }
    } else {
#line 1693
      return (0);
    }
#line 1689
    ptr1 += 2;
#line 1689
    ptr2 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1695
  return ((unsigned long )ptr1 == (unsigned long )end1);
}
}
#line 1698 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmltok_impl.c"
static int little2_nameLength___0(ENCODING const   *enc , char const   *ptr ) 
{ 
  char const   *start ;
  int tmp ;
  int tmp___0 ;

  {
#line 1701
  start = ptr;
  {
#line 1702
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1703
    if ((int const   )*(ptr + 1) == 0) {
#line 1703
      tmp___0 = (int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr];
    } else {
      {
#line 1703
      tmp = unicode_byte_type___0((char )*(ptr + 1), (char )*(ptr + 0));
#line 1703
      tmp___0 = tmp;
      }
    }
    {
#line 1706
    if (tmp___0 == 5) {
#line 1706
      goto case_5;
    }
#line 1706
    if (tmp___0 == 6) {
#line 1706
      goto case_6;
    }
#line 1706
    if (tmp___0 == 7) {
#line 1706
      goto case_7;
    }
#line 1716
    if (tmp___0 == 27) {
#line 1716
      goto case_27;
    }
#line 1716
    if (tmp___0 == 26) {
#line 1716
      goto case_27;
    }
#line 1716
    if (tmp___0 == 25) {
#line 1716
      goto case_27;
    }
#line 1716
    if (tmp___0 == 24) {
#line 1716
      goto case_27;
    }
#line 1716
    if (tmp___0 == 23) {
#line 1716
      goto case_27;
    }
#line 1716
    if (tmp___0 == 22) {
#line 1716
      goto case_27;
    }
#line 1716
    if (tmp___0 == 29) {
#line 1716
      goto case_27;
    }
#line 1719
    goto switch_default;
    case_5: /* CIL Label */ 
#line 1706
    ptr += 2;
#line 1706
    goto switch_break;
    case_6: /* CIL Label */ 
#line 1706
    ptr += 3;
#line 1706
    goto switch_break;
    case_7: /* CIL Label */ 
#line 1706
    ptr += 4;
#line 1706
    goto switch_break;
    case_27: /* CIL Label */ 
    case_26: /* CIL Label */ 
    case_25: /* CIL Label */ 
    case_24: /* CIL Label */ 
    case_23: /* CIL Label */ 
    case_22: /* CIL Label */ 
    case_29: /* CIL Label */ 
#line 1717
    ptr += 2;
#line 1718
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 1720
    return ((int )(ptr - start));
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 1725 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmltok_impl.c"
static char const   *little2_skipS___0(ENCODING const   *enc , char const   *ptr ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  {
#line 1728
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1729
    if ((int const   )*(ptr + 1) == 0) {
#line 1729
      tmp___0 = (int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr];
    } else {
      {
#line 1729
      tmp = unicode_byte_type___0((char )*(ptr + 1), (char )*(ptr + 0));
#line 1729
      tmp___0 = tmp;
      }
    }
    {
#line 1732
    if (tmp___0 == 21) {
#line 1732
      goto case_21;
    }
#line 1732
    if (tmp___0 == 9) {
#line 1732
      goto case_21;
    }
#line 1732
    if (tmp___0 == 10) {
#line 1732
      goto case_21;
    }
#line 1735
    goto switch_default;
    case_21: /* CIL Label */ 
    case_9: /* CIL Label */ 
    case_10: /* CIL Label */ 
#line 1733
    ptr += 2;
#line 1734
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 1736
    return (ptr);
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 1741 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmltok_impl.c"
static void little2_updatePosition___0(ENCODING const   *enc , char const   *ptr ,
                                       char const   *end , POSITION *pos ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 1747
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1747
    if (! ((unsigned long )ptr < (unsigned long )end)) {
#line 1747
      goto while_break;
    }
#line 1748
    if ((int const   )*(ptr + 1) == 0) {
#line 1748
      tmp___0 = (int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr];
    } else {
      {
#line 1748
      tmp = unicode_byte_type___0((char )*(ptr + 1), (char )*(ptr + 0));
#line 1748
      tmp___0 = tmp;
      }
    }
    {
#line 1753
    if (tmp___0 == 5) {
#line 1753
      goto case_5;
    }
#line 1753
    if (tmp___0 == 6) {
#line 1753
      goto case_6;
    }
#line 1753
    if (tmp___0 == 7) {
#line 1753
      goto case_7;
    }
#line 1755
    if (tmp___0 == 10) {
#line 1755
      goto case_10;
    }
#line 1760
    if (tmp___0 == 9) {
#line 1760
      goto case_9;
    }
#line 1767
    goto switch_default;
    case_5: /* CIL Label */ 
#line 1753
    ptr += 2;
#line 1753
    goto switch_break;
    case_6: /* CIL Label */ 
#line 1753
    ptr += 3;
#line 1753
    goto switch_break;
    case_7: /* CIL Label */ 
#line 1753
    ptr += 4;
#line 1753
    goto switch_break;
    case_10: /* CIL Label */ 
#line 1756
    pos->columnNumber = (XML_Size )-1;
#line 1757
    (pos->lineNumber) ++;
#line 1758
    ptr += 2;
#line 1759
    goto switch_break;
    case_9: /* CIL Label */ 
#line 1761
    (pos->lineNumber) ++;
#line 1762
    ptr += 2;
#line 1763
    if ((unsigned long )ptr != (unsigned long )end) {
#line 1763
      if ((int const   )*(ptr + 1) == 0) {
#line 1763
        tmp___2 = (int )((struct normal_encoding *)enc)->type[(unsigned char )*ptr];
      } else {
        {
#line 1763
        tmp___1 = unicode_byte_type___0((char )*(ptr + 1), (char )*(ptr + 0));
#line 1763
        tmp___2 = tmp___1;
        }
      }
#line 1763
      if (tmp___2 == 10) {
#line 1764
        ptr += 2;
      }
    }
#line 1765
    pos->columnNumber = (XML_Size )-1;
#line 1766
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 1768
    ptr += 2;
#line 1769
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 1771
    (pos->columnNumber) ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1773
  return;
}
}
#line 717 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmltok.c"
static struct normal_encoding  const  little2_encoding_ns___0  = 
#line 717 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmltok.c"
     {{{& little2_prologTok___0, & little2_contentTok___0, & little2_cdataSectionTok___0,
      & little2_ignoreSectionTok___0}, {& little2_attributeValueTok___0, & little2_entityValueTok___0},
     & little2_sameName___0, & little2_nameMatchesAscii___0, & little2_nameLength___0,
     & little2_skipS___0, & little2_getAtts___0, & little2_charRefNumber___0, & little2_predefinedEntityName___0,
     & little2_updatePosition___0, & little2_isPublicId___0, & little2_toUtf8___0,
     & little2_toUtf16___0, 2, (char)0, (char)1}, {(unsigned char)0, (unsigned char)0,
                                                   (unsigned char)0, (unsigned char)0,
                                                   (unsigned char)0, (unsigned char)0,
                                                   (unsigned char)0, (unsigned char)0,
                                                   (unsigned char)0, (unsigned char)21,
                                                   (unsigned char)10, (unsigned char)0,
                                                   (unsigned char)0, (unsigned char)9,
                                                   (unsigned char)0, (unsigned char)0,
                                                   (unsigned char)0, (unsigned char)0,
                                                   (unsigned char)0, (unsigned char)0,
                                                   (unsigned char)0, (unsigned char)0,
                                                   (unsigned char)0, (unsigned char)0,
                                                   (unsigned char)0, (unsigned char)0,
                                                   (unsigned char)0, (unsigned char)0,
                                                   (unsigned char)0, (unsigned char)0,
                                                   (unsigned char)0, (unsigned char)0,
                                                   (unsigned char)21, (unsigned char)16,
                                                   (unsigned char)12, (unsigned char)19,
                                                   (unsigned char)28, (unsigned char)30,
                                                   (unsigned char)3, (unsigned char)13,
                                                   (unsigned char)31, (unsigned char)32,
                                                   (unsigned char)33, (unsigned char)34,
                                                   (unsigned char)35, (unsigned char)27,
                                                   (unsigned char)26, (unsigned char)17,
                                                   (unsigned char)25, (unsigned char)25,
                                                   (unsigned char)25, (unsigned char)25,
                                                   (unsigned char)25, (unsigned char)25,
                                                   (unsigned char)25, (unsigned char)25,
                                                   (unsigned char)25, (unsigned char)25,
                                                   (unsigned char)23, (unsigned char)18,
                                                   (unsigned char)2, (unsigned char)14,
                                                   (unsigned char)11, (unsigned char)15,
                                                   (unsigned char)28, (unsigned char)24,
                                                   (unsigned char)24, (unsigned char)24,
                                                   (unsigned char)24, (unsigned char)24,
                                                   (unsigned char)24, (unsigned char)22,
                                                   (unsigned char)22, (unsigned char)22,
                                                   (unsigned char)22, (unsigned char)22,
                                                   (unsigned char)22, (unsigned char)22,
                                                   (unsigned char)22, (unsigned char)22,
                                                   (unsigned char)22, (unsigned char)22,
                                                   (unsigned char)22, (unsigned char)22,
                                                   (unsigned char)22, (unsigned char)22,
                                                   (unsigned char)22, (unsigned char)22,
                                                   (unsigned char)22, (unsigned char)22,
                                                   (unsigned char)22, (unsigned char)20,
                                                   (unsigned char)28, (unsigned char)4,
                                                   (unsigned char)28, (unsigned char)22,
                                                   (unsigned char)28, (unsigned char)24,
                                                   (unsigned char)24, (unsigned char)24,
                                                   (unsigned char)24, (unsigned char)24,
                                                   (unsigned char)24, (unsigned char)22,
                                                   (unsigned char)22, (unsigned char)22,
                                                   (unsigned char)22, (unsigned char)22,
                                                   (unsigned char)22, (unsigned char)22,
                                                   (unsigned char)22, (unsigned char)22,
                                                   (unsigned char)22, (unsigned char)22,
                                                   (unsigned char)22, (unsigned char)22,
                                                   (unsigned char)22, (unsigned char)22,
                                                   (unsigned char)22, (unsigned char)22,
                                                   (unsigned char)22, (unsigned char)22,
                                                   (unsigned char)22, (unsigned char)28,
                                                   (unsigned char)36, (unsigned char)28,
                                                   (unsigned char)28, (unsigned char)28,
                                                   (unsigned char)28, (unsigned char)28,
                                                   (unsigned char)28, (unsigned char)28,
                                                   (unsigned char)28, (unsigned char)28,
                                                   (unsigned char)28, (unsigned char)28,
                                                   (unsigned char)28, (unsigned char)28,
                                                   (unsigned char)28, (unsigned char)28,
                                                   (unsigned char)28, (unsigned char)28,
                                                   (unsigned char)28, (unsigned char)28,
                                                   (unsigned char)28, (unsigned char)28,
                                                   (unsigned char)28, (unsigned char)28,
                                                   (unsigned char)28, (unsigned char)28,
                                                   (unsigned char)28, (unsigned char)28,
                                                   (unsigned char)28, (unsigned char)28,
                                                   (unsigned char)28, (unsigned char)28,
                                                   (unsigned char)28, (unsigned char)28,
                                                   (unsigned char)28, (unsigned char)28,
                                                   (unsigned char)28, (unsigned char)28,
                                                   (unsigned char)28, (unsigned char)28,
                                                   (unsigned char)28, (unsigned char)28,
                                                   (unsigned char)28, (unsigned char)28,
                                                   (unsigned char)28, (unsigned char)28,
                                                   (unsigned char)22, (unsigned char)28,
                                                   (unsigned char)28, (unsigned char)28,
                                                   (unsigned char)28, (unsigned char)28,
                                                   (unsigned char)28, (unsigned char)28,
                                                   (unsigned char)28, (unsigned char)28,
                                                   (unsigned char)28, (unsigned char)22,
                                                   (unsigned char)28, (unsigned char)26,
                                                   (unsigned char)28, (unsigned char)28,
                                                   (unsigned char)22, (unsigned char)28,
                                                   (unsigned char)28, (unsigned char)28,
                                                   (unsigned char)28, (unsigned char)28,
                                                   (unsigned char)22, (unsigned char)22,
                                                   (unsigned char)22, (unsigned char)22,
                                                   (unsigned char)22, (unsigned char)22,
                                                   (unsigned char)22, (unsigned char)22,
                                                   (unsigned char)22, (unsigned char)22,
                                                   (unsigned char)22, (unsigned char)22,
                                                   (unsigned char)22, (unsigned char)22,
                                                   (unsigned char)22, (unsigned char)22,
                                                   (unsigned char)22, (unsigned char)22,
                                                   (unsigned char)22, (unsigned char)22,
                                                   (unsigned char)22, (unsigned char)22,
                                                   (unsigned char)22, (unsigned char)28,
                                                   (unsigned char)22, (unsigned char)22,
                                                   (unsigned char)22, (unsigned char)22,
                                                   (unsigned char)22, (unsigned char)22,
                                                   (unsigned char)22, (unsigned char)22,
                                                   (unsigned char)22, (unsigned char)22,
                                                   (unsigned char)22, (unsigned char)22,
                                                   (unsigned char)22, (unsigned char)22,
                                                   (unsigned char)22, (unsigned char)22,
                                                   (unsigned char)22, (unsigned char)22,
                                                   (unsigned char)22, (unsigned char)22,
                                                   (unsigned char)22, (unsigned char)22,
                                                   (unsigned char)22, (unsigned char)22,
                                                   (unsigned char)22, (unsigned char)22,
                                                   (unsigned char)22, (unsigned char)22,
                                                   (unsigned char)22, (unsigned char)22,
                                                   (unsigned char)22, (unsigned char)28,
                                                   (unsigned char)22, (unsigned char)22,
                                                   (unsigned char)22, (unsigned char)22,
                                                   (unsigned char)22, (unsigned char)22,
                                                   (unsigned char)22, (unsigned char)22},
    (int (*)(ENCODING const   * , char const   * ))0, (int (*)(ENCODING const   * ,
                                                               char const   * ))0,
    (int (*)(ENCODING const   * , char const   * ))0, (int (*)(ENCODING const   * ,
                                                               char const   * ))0,
    (int (*)(ENCODING const   * , char const   * ))0, (int (*)(ENCODING const   * ,
                                                               char const   * ))0,
    (int (*)(ENCODING const   * , char const   * ))0, (int (*)(ENCODING const   * ,
                                                               char const   * ))0,
    (int (*)(ENCODING const   * , char const   * ))0};
#line 734 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmltok.c"
static struct normal_encoding  const  little2_encoding___0  = 
#line 734
     {{{& little2_prologTok___0, & little2_contentTok___0, & little2_cdataSectionTok___0,
      & little2_ignoreSectionTok___0}, {& little2_attributeValueTok___0, & little2_entityValueTok___0},
     & little2_sameName___0, & little2_nameMatchesAscii___0, & little2_nameLength___0,
     & little2_skipS___0, & little2_getAtts___0, & little2_charRefNumber___0, & little2_predefinedEntityName___0,
     & little2_updatePosition___0, & little2_isPublicId___0, & little2_toUtf8___0,
     & little2_toUtf16___0, 2, (char)0, (char)1}, {(unsigned char)0, (unsigned char)0,
                                                   (unsigned char)0, (unsigned char)0,
                                                   (unsigned char)0, (unsigned char)0,
                                                   (unsigned char)0, (unsigned char)0,
                                                   (unsigned char)0, (unsigned char)21,
                                                   (unsigned char)10, (unsigned char)0,
                                                   (unsigned char)0, (unsigned char)9,
                                                   (unsigned char)0, (unsigned char)0,
                                                   (unsigned char)0, (unsigned char)0,
                                                   (unsigned char)0, (unsigned char)0,
                                                   (unsigned char)0, (unsigned char)0,
                                                   (unsigned char)0, (unsigned char)0,
                                                   (unsigned char)0, (unsigned char)0,
                                                   (unsigned char)0, (unsigned char)0,
                                                   (unsigned char)0, (unsigned char)0,
                                                   (unsigned char)0, (unsigned char)0,
                                                   (unsigned char)21, (unsigned char)16,
                                                   (unsigned char)12, (unsigned char)19,
                                                   (unsigned char)28, (unsigned char)30,
                                                   (unsigned char)3, (unsigned char)13,
                                                   (unsigned char)31, (unsigned char)32,
                                                   (unsigned char)33, (unsigned char)34,
                                                   (unsigned char)35, (unsigned char)27,
                                                   (unsigned char)26, (unsigned char)17,
                                                   (unsigned char)25, (unsigned char)25,
                                                   (unsigned char)25, (unsigned char)25,
                                                   (unsigned char)25, (unsigned char)25,
                                                   (unsigned char)25, (unsigned char)25,
                                                   (unsigned char)25, (unsigned char)25,
                                                   (unsigned char)22, (unsigned char)18,
                                                   (unsigned char)2, (unsigned char)14,
                                                   (unsigned char)11, (unsigned char)15,
                                                   (unsigned char)28, (unsigned char)24,
                                                   (unsigned char)24, (unsigned char)24,
                                                   (unsigned char)24, (unsigned char)24,
                                                   (unsigned char)24, (unsigned char)22,
                                                   (unsigned char)22, (unsigned char)22,
                                                   (unsigned char)22, (unsigned char)22,
                                                   (unsigned char)22, (unsigned char)22,
                                                   (unsigned char)22, (unsigned char)22,
                                                   (unsigned char)22, (unsigned char)22,
                                                   (unsigned char)22, (unsigned char)22,
                                                   (unsigned char)22, (unsigned char)22,
                                                   (unsigned char)22, (unsigned char)22,
                                                   (unsigned char)22, (unsigned char)22,
                                                   (unsigned char)22, (unsigned char)20,
                                                   (unsigned char)28, (unsigned char)4,
                                                   (unsigned char)28, (unsigned char)22,
                                                   (unsigned char)28, (unsigned char)24,
                                                   (unsigned char)24, (unsigned char)24,
                                                   (unsigned char)24, (unsigned char)24,
                                                   (unsigned char)24, (unsigned char)22,
                                                   (unsigned char)22, (unsigned char)22,
                                                   (unsigned char)22, (unsigned char)22,
                                                   (unsigned char)22, (unsigned char)22,
                                                   (unsigned char)22, (unsigned char)22,
                                                   (unsigned char)22, (unsigned char)22,
                                                   (unsigned char)22, (unsigned char)22,
                                                   (unsigned char)22, (unsigned char)22,
                                                   (unsigned char)22, (unsigned char)22,
                                                   (unsigned char)22, (unsigned char)22,
                                                   (unsigned char)22, (unsigned char)28,
                                                   (unsigned char)36, (unsigned char)28,
                                                   (unsigned char)28, (unsigned char)28,
                                                   (unsigned char)28, (unsigned char)28,
                                                   (unsigned char)28, (unsigned char)28,
                                                   (unsigned char)28, (unsigned char)28,
                                                   (unsigned char)28, (unsigned char)28,
                                                   (unsigned char)28, (unsigned char)28,
                                                   (unsigned char)28, (unsigned char)28,
                                                   (unsigned char)28, (unsigned char)28,
                                                   (unsigned char)28, (unsigned char)28,
                                                   (unsigned char)28, (unsigned char)28,
                                                   (unsigned char)28, (unsigned char)28,
                                                   (unsigned char)28, (unsigned char)28,
                                                   (unsigned char)28, (unsigned char)28,
                                                   (unsigned char)28, (unsigned char)28,
                                                   (unsigned char)28, (unsigned char)28,
                                                   (unsigned char)28, (unsigned char)28,
                                                   (unsigned char)28, (unsigned char)28,
                                                   (unsigned char)28, (unsigned char)28,
                                                   (unsigned char)28, (unsigned char)28,
                                                   (unsigned char)28, (unsigned char)28,
                                                   (unsigned char)28, (unsigned char)28,
                                                   (unsigned char)28, (unsigned char)28,
                                                   (unsigned char)22, (unsigned char)28,
                                                   (unsigned char)28, (unsigned char)28,
                                                   (unsigned char)28, (unsigned char)28,
                                                   (unsigned char)28, (unsigned char)28,
                                                   (unsigned char)28, (unsigned char)28,
                                                   (unsigned char)28, (unsigned char)22,
                                                   (unsigned char)28, (unsigned char)26,
                                                   (unsigned char)28, (unsigned char)28,
                                                   (unsigned char)22, (unsigned char)28,
                                                   (unsigned char)28, (unsigned char)28,
                                                   (unsigned char)28, (unsigned char)28,
                                                   (unsigned char)22, (unsigned char)22,
                                                   (unsigned char)22, (unsigned char)22,
                                                   (unsigned char)22, (unsigned char)22,
                                                   (unsigned char)22, (unsigned char)22,
                                                   (unsigned char)22, (unsigned char)22,
                                                   (unsigned char)22, (unsigned char)22,
                                                   (unsigned char)22, (unsigned char)22,
                                                   (unsigned char)22, (unsigned char)22,
                                                   (unsigned char)22, (unsigned char)22,
                                                   (unsigned char)22, (unsigned char)22,
                                                   (unsigned char)22, (unsigned char)22,
                                                   (unsigned char)22, (unsigned char)28,
                                                   (unsigned char)22, (unsigned char)22,
                                                   (unsigned char)22, (unsigned char)22,
                                                   (unsigned char)22, (unsigned char)22,
                                                   (unsigned char)22, (unsigned char)22,
                                                   (unsigned char)22, (unsigned char)22,
                                                   (unsigned char)22, (unsigned char)22,
                                                   (unsigned char)22, (unsigned char)22,
                                                   (unsigned char)22, (unsigned char)22,
                                                   (unsigned char)22, (unsigned char)22,
                                                   (unsigned char)22, (unsigned char)22,
                                                   (unsigned char)22, (unsigned char)22,
                                                   (unsigned char)22, (unsigned char)22,
                                                   (unsigned char)22, (unsigned char)22,
                                                   (unsigned char)22, (unsigned char)22,
                                                   (unsigned char)22, (unsigned char)22,
                                                   (unsigned char)22, (unsigned char)28,
                                                   (unsigned char)22, (unsigned char)22,
                                                   (unsigned char)22, (unsigned char)22,
                                                   (unsigned char)22, (unsigned char)22,
                                                   (unsigned char)22, (unsigned char)22},
    (int (*)(ENCODING const   * , char const   * ))0, (int (*)(ENCODING const   * ,
                                                               char const   * ))0,
    (int (*)(ENCODING const   * , char const   * ))0, (int (*)(ENCODING const   * ,
                                                               char const   * ))0,
    (int (*)(ENCODING const   * , char const   * ))0, (int (*)(ENCODING const   * ,
                                                               char const   * ))0,
    (int (*)(ENCODING const   * , char const   * ))0, (int (*)(ENCODING const   * ,
                                                               char const   * ))0,
    (int (*)(ENCODING const   * , char const   * ))0};
#line 755 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmltok.c"
static struct normal_encoding  const  internal_little2_encoding_ns___0  = 
#line 755
     {{{& little2_prologTok___0, & little2_contentTok___0, & little2_cdataSectionTok___0,
      & little2_ignoreSectionTok___0}, {& little2_attributeValueTok___0, & little2_entityValueTok___0},
     & little2_sameName___0, & little2_nameMatchesAscii___0, & little2_nameLength___0,
     & little2_skipS___0, & little2_getAtts___0, & little2_charRefNumber___0, & little2_predefinedEntityName___0,
     & little2_updatePosition___0, & little2_isPublicId___0, & little2_toUtf8___0,
     & little2_toUtf16___0, 2, (char)0, (char)1}, {(unsigned char)0, (unsigned char)0,
                                                   (unsigned char)0, (unsigned char)0,
                                                   (unsigned char)0, (unsigned char)0,
                                                   (unsigned char)0, (unsigned char)0,
                                                   (unsigned char)0, (unsigned char)21,
                                                   (unsigned char)10, (unsigned char)0,
                                                   (unsigned char)0, (unsigned char)21,
                                                   (unsigned char)0, (unsigned char)0,
                                                   (unsigned char)0, (unsigned char)0,
                                                   (unsigned char)0, (unsigned char)0,
                                                   (unsigned char)0, (unsigned char)0,
                                                   (unsigned char)0, (unsigned char)0,
                                                   (unsigned char)0, (unsigned char)0,
                                                   (unsigned char)0, (unsigned char)0,
                                                   (unsigned char)0, (unsigned char)0,
                                                   (unsigned char)0, (unsigned char)0,
                                                   (unsigned char)21, (unsigned char)16,
                                                   (unsigned char)12, (unsigned char)19,
                                                   (unsigned char)28, (unsigned char)30,
                                                   (unsigned char)3, (unsigned char)13,
                                                   (unsigned char)31, (unsigned char)32,
                                                   (unsigned char)33, (unsigned char)34,
                                                   (unsigned char)35, (unsigned char)27,
                                                   (unsigned char)26, (unsigned char)17,
                                                   (unsigned char)25, (unsigned char)25,
                                                   (unsigned char)25, (unsigned char)25,
                                                   (unsigned char)25, (unsigned char)25,
                                                   (unsigned char)25, (unsigned char)25,
                                                   (unsigned char)25, (unsigned char)25,
                                                   (unsigned char)23, (unsigned char)18,
                                                   (unsigned char)2, (unsigned char)14,
                                                   (unsigned char)11, (unsigned char)15,
                                                   (unsigned char)28, (unsigned char)24,
                                                   (unsigned char)24, (unsigned char)24,
                                                   (unsigned char)24, (unsigned char)24,
                                                   (unsigned char)24, (unsigned char)22,
                                                   (unsigned char)22, (unsigned char)22,
                                                   (unsigned char)22, (unsigned char)22,
                                                   (unsigned char)22, (unsigned char)22,
                                                   (unsigned char)22, (unsigned char)22,
                                                   (unsigned char)22, (unsigned char)22,
                                                   (unsigned char)22, (unsigned char)22,
                                                   (unsigned char)22, (unsigned char)22,
                                                   (unsigned char)22, (unsigned char)22,
                                                   (unsigned char)22, (unsigned char)22,
                                                   (unsigned char)22, (unsigned char)20,
                                                   (unsigned char)28, (unsigned char)4,
                                                   (unsigned char)28, (unsigned char)22,
                                                   (unsigned char)28, (unsigned char)24,
                                                   (unsigned char)24, (unsigned char)24,
                                                   (unsigned char)24, (unsigned char)24,
                                                   (unsigned char)24, (unsigned char)22,
                                                   (unsigned char)22, (unsigned char)22,
                                                   (unsigned char)22, (unsigned char)22,
                                                   (unsigned char)22, (unsigned char)22,
                                                   (unsigned char)22, (unsigned char)22,
                                                   (unsigned char)22, (unsigned char)22,
                                                   (unsigned char)22, (unsigned char)22,
                                                   (unsigned char)22, (unsigned char)22,
                                                   (unsigned char)22, (unsigned char)22,
                                                   (unsigned char)22, (unsigned char)22,
                                                   (unsigned char)22, (unsigned char)28,
                                                   (unsigned char)36, (unsigned char)28,
                                                   (unsigned char)28, (unsigned char)28,
                                                   (unsigned char)28, (unsigned char)28,
                                                   (unsigned char)28, (unsigned char)28,
                                                   (unsigned char)28, (unsigned char)28,
                                                   (unsigned char)28, (unsigned char)28,
                                                   (unsigned char)28, (unsigned char)28,
                                                   (unsigned char)28, (unsigned char)28,
                                                   (unsigned char)28, (unsigned char)28,
                                                   (unsigned char)28, (unsigned char)28,
                                                   (unsigned char)28, (unsigned char)28,
                                                   (unsigned char)28, (unsigned char)28,
                                                   (unsigned char)28, (unsigned char)28,
                                                   (unsigned char)28, (unsigned char)28,
                                                   (unsigned char)28, (unsigned char)28,
                                                   (unsigned char)28, (unsigned char)28,
                                                   (unsigned char)28, (unsigned char)28,
                                                   (unsigned char)28, (unsigned char)28,
                                                   (unsigned char)28, (unsigned char)28,
                                                   (unsigned char)28, (unsigned char)28,
                                                   (unsigned char)28, (unsigned char)28,
                                                   (unsigned char)28, (unsigned char)28,
                                                   (unsigned char)28, (unsigned char)28,
                                                   (unsigned char)22, (unsigned char)28,
                                                   (unsigned char)28, (unsigned char)28,
                                                   (unsigned char)28, (unsigned char)28,
                                                   (unsigned char)28, (unsigned char)28,
                                                   (unsigned char)28, (unsigned char)28,
                                                   (unsigned char)28, (unsigned char)22,
                                                   (unsigned char)28, (unsigned char)26,
                                                   (unsigned char)28, (unsigned char)28,
                                                   (unsigned char)22, (unsigned char)28,
                                                   (unsigned char)28, (unsigned char)28,
                                                   (unsigned char)28, (unsigned char)28,
                                                   (unsigned char)22, (unsigned char)22,
                                                   (unsigned char)22, (unsigned char)22,
                                                   (unsigned char)22, (unsigned char)22,
                                                   (unsigned char)22, (unsigned char)22,
                                                   (unsigned char)22, (unsigned char)22,
                                                   (unsigned char)22, (unsigned char)22,
                                                   (unsigned char)22, (unsigned char)22,
                                                   (unsigned char)22, (unsigned char)22,
                                                   (unsigned char)22, (unsigned char)22,
                                                   (unsigned char)22, (unsigned char)22,
                                                   (unsigned char)22, (unsigned char)22,
                                                   (unsigned char)22, (unsigned char)28,
                                                   (unsigned char)22, (unsigned char)22,
                                                   (unsigned char)22, (unsigned char)22,
                                                   (unsigned char)22, (unsigned char)22,
                                                   (unsigned char)22, (unsigned char)22,
                                                   (unsigned char)22, (unsigned char)22,
                                                   (unsigned char)22, (unsigned char)22,
                                                   (unsigned char)22, (unsigned char)22,
                                                   (unsigned char)22, (unsigned char)22,
                                                   (unsigned char)22, (unsigned char)22,
                                                   (unsigned char)22, (unsigned char)22,
                                                   (unsigned char)22, (unsigned char)22,
                                                   (unsigned char)22, (unsigned char)22,
                                                   (unsigned char)22, (unsigned char)22,
                                                   (unsigned char)22, (unsigned char)22,
                                                   (unsigned char)22, (unsigned char)22,
                                                   (unsigned char)22, (unsigned char)28,
                                                   (unsigned char)22, (unsigned char)22,
                                                   (unsigned char)22, (unsigned char)22,
                                                   (unsigned char)22, (unsigned char)22,
                                                   (unsigned char)22, (unsigned char)22},
    (int (*)(ENCODING const   * , char const   * ))0, (int (*)(ENCODING const   * ,
                                                               char const   * ))0,
    (int (*)(ENCODING const   * , char const   * ))0, (int (*)(ENCODING const   * ,
                                                               char const   * ))0,
    (int (*)(ENCODING const   * , char const   * ))0, (int (*)(ENCODING const   * ,
                                                               char const   * ))0,
    (int (*)(ENCODING const   * , char const   * ))0, (int (*)(ENCODING const   * ,
                                                               char const   * ))0,
    (int (*)(ENCODING const   * , char const   * ))0};
#line 766 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmltok.c"
static struct normal_encoding  const  internal_little2_encoding___0  = 
#line 766
     {{{& little2_prologTok___0, & little2_contentTok___0, & little2_cdataSectionTok___0,
      & little2_ignoreSectionTok___0}, {& little2_attributeValueTok___0, & little2_entityValueTok___0},
     & little2_sameName___0, & little2_nameMatchesAscii___0, & little2_nameLength___0,
     & little2_skipS___0, & little2_getAtts___0, & little2_charRefNumber___0, & little2_predefinedEntityName___0,
     & little2_updatePosition___0, & little2_isPublicId___0, & little2_toUtf8___0,
     & little2_toUtf16___0, 2, (char)0, (char)1}, {(unsigned char)0, (unsigned char)0,
                                                   (unsigned char)0, (unsigned char)0,
                                                   (unsigned char)0, (unsigned char)0,
                                                   (unsigned char)0, (unsigned char)0,
                                                   (unsigned char)0, (unsigned char)21,
                                                   (unsigned char)10, (unsigned char)0,
                                                   (unsigned char)0, (unsigned char)21,
                                                   (unsigned char)0, (unsigned char)0,
                                                   (unsigned char)0, (unsigned char)0,
                                                   (unsigned char)0, (unsigned char)0,
                                                   (unsigned char)0, (unsigned char)0,
                                                   (unsigned char)0, (unsigned char)0,
                                                   (unsigned char)0, (unsigned char)0,
                                                   (unsigned char)0, (unsigned char)0,
                                                   (unsigned char)0, (unsigned char)0,
                                                   (unsigned char)0, (unsigned char)0,
                                                   (unsigned char)21, (unsigned char)16,
                                                   (unsigned char)12, (unsigned char)19,
                                                   (unsigned char)28, (unsigned char)30,
                                                   (unsigned char)3, (unsigned char)13,
                                                   (unsigned char)31, (unsigned char)32,
                                                   (unsigned char)33, (unsigned char)34,
                                                   (unsigned char)35, (unsigned char)27,
                                                   (unsigned char)26, (unsigned char)17,
                                                   (unsigned char)25, (unsigned char)25,
                                                   (unsigned char)25, (unsigned char)25,
                                                   (unsigned char)25, (unsigned char)25,
                                                   (unsigned char)25, (unsigned char)25,
                                                   (unsigned char)25, (unsigned char)25,
                                                   (unsigned char)22, (unsigned char)18,
                                                   (unsigned char)2, (unsigned char)14,
                                                   (unsigned char)11, (unsigned char)15,
                                                   (unsigned char)28, (unsigned char)24,
                                                   (unsigned char)24, (unsigned char)24,
                                                   (unsigned char)24, (unsigned char)24,
                                                   (unsigned char)24, (unsigned char)22,
                                                   (unsigned char)22, (unsigned char)22,
                                                   (unsigned char)22, (unsigned char)22,
                                                   (unsigned char)22, (unsigned char)22,
                                                   (unsigned char)22, (unsigned char)22,
                                                   (unsigned char)22, (unsigned char)22,
                                                   (unsigned char)22, (unsigned char)22,
                                                   (unsigned char)22, (unsigned char)22,
                                                   (unsigned char)22, (unsigned char)22,
                                                   (unsigned char)22, (unsigned char)22,
                                                   (unsigned char)22, (unsigned char)20,
                                                   (unsigned char)28, (unsigned char)4,
                                                   (unsigned char)28, (unsigned char)22,
                                                   (unsigned char)28, (unsigned char)24,
                                                   (unsigned char)24, (unsigned char)24,
                                                   (unsigned char)24, (unsigned char)24,
                                                   (unsigned char)24, (unsigned char)22,
                                                   (unsigned char)22, (unsigned char)22,
                                                   (unsigned char)22, (unsigned char)22,
                                                   (unsigned char)22, (unsigned char)22,
                                                   (unsigned char)22, (unsigned char)22,
                                                   (unsigned char)22, (unsigned char)22,
                                                   (unsigned char)22, (unsigned char)22,
                                                   (unsigned char)22, (unsigned char)22,
                                                   (unsigned char)22, (unsigned char)22,
                                                   (unsigned char)22, (unsigned char)22,
                                                   (unsigned char)22, (unsigned char)28,
                                                   (unsigned char)36, (unsigned char)28,
                                                   (unsigned char)28, (unsigned char)28,
                                                   (unsigned char)28, (unsigned char)28,
                                                   (unsigned char)28, (unsigned char)28,
                                                   (unsigned char)28, (unsigned char)28,
                                                   (unsigned char)28, (unsigned char)28,
                                                   (unsigned char)28, (unsigned char)28,
                                                   (unsigned char)28, (unsigned char)28,
                                                   (unsigned char)28, (unsigned char)28,
                                                   (unsigned char)28, (unsigned char)28,
                                                   (unsigned char)28, (unsigned char)28,
                                                   (unsigned char)28, (unsigned char)28,
                                                   (unsigned char)28, (unsigned char)28,
                                                   (unsigned char)28, (unsigned char)28,
                                                   (unsigned char)28, (unsigned char)28,
                                                   (unsigned char)28, (unsigned char)28,
                                                   (unsigned char)28, (unsigned char)28,
                                                   (unsigned char)28, (unsigned char)28,
                                                   (unsigned char)28, (unsigned char)28,
                                                   (unsigned char)28, (unsigned char)28,
                                                   (unsigned char)28, (unsigned char)28,
                                                   (unsigned char)28, (unsigned char)28,
                                                   (unsigned char)28, (unsigned char)28,
                                                   (unsigned char)22, (unsigned char)28,
                                                   (unsigned char)28, (unsigned char)28,
                                                   (unsigned char)28, (unsigned char)28,
                                                   (unsigned char)28, (unsigned char)28,
                                                   (unsigned char)28, (unsigned char)28,
                                                   (unsigned char)28, (unsigned char)22,
                                                   (unsigned char)28, (unsigned char)26,
                                                   (unsigned char)28, (unsigned char)28,
                                                   (unsigned char)22, (unsigned char)28,
                                                   (unsigned char)28, (unsigned char)28,
                                                   (unsigned char)28, (unsigned char)28,
                                                   (unsigned char)22, (unsigned char)22,
                                                   (unsigned char)22, (unsigned char)22,
                                                   (unsigned char)22, (unsigned char)22,
                                                   (unsigned char)22, (unsigned char)22,
                                                   (unsigned char)22, (unsigned char)22,
                                                   (unsigned char)22, (unsigned char)22,
                                                   (unsigned char)22, (unsigned char)22,
                                                   (unsigned char)22, (unsigned char)22,
                                                   (unsigned char)22, (unsigned char)22,
                                                   (unsigned char)22, (unsigned char)22,
                                                   (unsigned char)22, (unsigned char)22,
                                                   (unsigned char)22, (unsigned char)28,
                                                   (unsigned char)22, (unsigned char)22,
                                                   (unsigned char)22, (unsigned char)22,
                                                   (unsigned char)22, (unsigned char)22,
                                                   (unsigned char)22, (unsigned char)22,
                                                   (unsigned char)22, (unsigned char)22,
                                                   (unsigned char)22, (unsigned char)22,
                                                   (unsigned char)22, (unsigned char)22,
                                                   (unsigned char)22, (unsigned char)22,
                                                   (unsigned char)22, (unsigned char)22,
                                                   (unsigned char)22, (unsigned char)22,
                                                   (unsigned char)22, (unsigned char)22,
                                                   (unsigned char)22, (unsigned char)22,
                                                   (unsigned char)22, (unsigned char)22,
                                                   (unsigned char)22, (unsigned char)22,
                                                   (unsigned char)22, (unsigned char)22,
                                                   (unsigned char)22, (unsigned char)28,
                                                   (unsigned char)22, (unsigned char)22,
                                                   (unsigned char)22, (unsigned char)22,
                                                   (unsigned char)22, (unsigned char)22,
                                                   (unsigned char)22, (unsigned char)22},
    (int (*)(ENCODING const   * , char const   * ))0, (int (*)(ENCODING const   * ,
                                                               char const   * ))0,
    (int (*)(ENCODING const   * , char const   * ))0, (int (*)(ENCODING const   * ,
                                                               char const   * ))0,
    (int (*)(ENCODING const   * , char const   * ))0, (int (*)(ENCODING const   * ,
                                                               char const   * ))0,
    (int (*)(ENCODING const   * , char const   * ))0, (int (*)(ENCODING const   * ,
                                                               char const   * ))0,
    (int (*)(ENCODING const   * , char const   * ))0};
#line 92 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmltok_impl.c"
static int big2_scanComment___0(ENCODING const   *enc , char const   *ptr , char const   *end ,
                                char const   **nextTokPtr ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 96
  if ((unsigned long )ptr != (unsigned long )end) {
#line 97
    if ((int const   )*(ptr + 0) == 0) {
#line 97
      if (! ((int const   )*(ptr + 1) == 45)) {
#line 98
        *nextTokPtr = ptr;
#line 99
        return (0);
      }
    } else {
#line 98
      *nextTokPtr = ptr;
#line 99
      return (0);
    }
#line 101
    ptr += 2;
    {
#line 102
    while (1) {
      while_continue: /* CIL Label */ ;
#line 102
      if (! ((unsigned long )ptr != (unsigned long )end)) {
#line 102
        goto while_break;
      }
#line 103
      if ((int const   )*(ptr + 0) == 0) {
#line 103
        tmp___0 = (int )((struct normal_encoding *)enc)->type[(unsigned char )*(ptr + 1)];
      } else {
        {
#line 103
        tmp = unicode_byte_type___0((char )*(ptr + 0), (char )*(ptr + 1));
#line 103
        tmp___0 = tmp;
        }
      }
      {
#line 104
      if (tmp___0 == 5) {
#line 104
        goto case_5;
      }
#line 104
      if (tmp___0 == 6) {
#line 104
        goto case_6;
      }
#line 104
      if (tmp___0 == 7) {
#line 104
        goto case_7;
      }
#line 104
      if (tmp___0 == 8) {
#line 104
        goto case_8;
      }
#line 104
      if (tmp___0 == 1) {
#line 104
        goto case_8;
      }
#line 104
      if (tmp___0 == 0) {
#line 104
        goto case_8;
      }
#line 105
      if (tmp___0 == 27) {
#line 105
        goto case_27;
      }
#line 119
      goto switch_default;
      case_5: /* CIL Label */ 
#line 104
      if (end - ptr < 2L) {
#line 104
        return (-2);
      }
#line 104
      ptr += 2;
#line 104
      goto switch_break;
      case_6: /* CIL Label */ 
#line 104
      if (end - ptr < 3L) {
#line 104
        return (-2);
      }
#line 104
      ptr += 3;
#line 104
      goto switch_break;
      case_7: /* CIL Label */ 
#line 104
      if (end - ptr < 4L) {
#line 104
        return (-2);
      }
#line 104
      ptr += 4;
#line 104
      goto switch_break;
      case_8: /* CIL Label */ 
      case_1: /* CIL Label */ 
      case_0: /* CIL Label */ 
#line 104
      *nextTokPtr = ptr;
#line 104
      return (0);
      case_27: /* CIL Label */ 
#line 106
      ptr += 2;
#line 106
      if ((unsigned long )ptr == (unsigned long )end) {
#line 107
        return (-1);
      }
#line 108
      if ((int const   )*(ptr + 0) == 0) {
#line 108
        if ((int const   )*(ptr + 1) == 45) {
#line 109
          ptr += 2;
#line 109
          if ((unsigned long )ptr == (unsigned long )end) {
#line 110
            return (-1);
          }
#line 111
          if ((int const   )*(ptr + 0) == 0) {
#line 111
            if (! ((int const   )*(ptr + 1) == 62)) {
#line 112
              *nextTokPtr = ptr;
#line 113
              return (0);
            }
          } else {
#line 112
            *nextTokPtr = ptr;
#line 113
            return (0);
          }
#line 115
          *nextTokPtr = ptr + 2;
#line 116
          return (13);
        }
      }
#line 118
      goto switch_break;
      switch_default: /* CIL Label */ 
#line 120
      ptr += 2;
#line 121
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 125
  return (-1);
}
}
#line 130 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmltok_impl.c"
static int big2_scanDecl___0(ENCODING const   *enc , char const   *ptr , char const   *end ,
                             char const   **nextTokPtr ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 134
  if ((unsigned long )ptr == (unsigned long )end) {
#line 135
    return (-1);
  }
#line 136
  if ((int const   )*(ptr + 0) == 0) {
#line 136
    tmp___0 = (int )((struct normal_encoding *)enc)->type[(unsigned char )*(ptr + 1)];
  } else {
    {
#line 136
    tmp = unicode_byte_type___0((char )*(ptr + 0), (char )*(ptr + 1));
#line 136
    tmp___0 = tmp;
    }
  }
  {
#line 137
  if (tmp___0 == 27) {
#line 137
    goto case_27;
  }
#line 139
  if (tmp___0 == 20) {
#line 139
    goto case_20;
  }
#line 143
  if (tmp___0 == 24) {
#line 143
    goto case_24;
  }
#line 143
  if (tmp___0 == 22) {
#line 143
    goto case_24;
  }
#line 146
  goto switch_default;
  case_27: /* CIL Label */ 
  {
#line 138
  tmp___1 = big2_scanComment___0(enc, ptr + 2, end, nextTokPtr);
  }
#line 138
  return (tmp___1);
  case_20: /* CIL Label */ 
#line 140
  *nextTokPtr = ptr + 2;
#line 141
  return (33);
  case_24: /* CIL Label */ 
  case_22: /* CIL Label */ 
#line 144
  ptr += 2;
#line 145
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 147
  *nextTokPtr = ptr;
#line 148
  return (0);
  switch_break: /* CIL Label */ ;
  }
  {
#line 150
  while (1) {
    while_continue: /* CIL Label */ ;
#line 150
    if (! ((unsigned long )ptr != (unsigned long )end)) {
#line 150
      goto while_break;
    }
#line 151
    if ((int const   )*(ptr + 0) == 0) {
#line 151
      tmp___3 = (int )((struct normal_encoding *)enc)->type[(unsigned char )*(ptr + 1)];
    } else {
      {
#line 151
      tmp___2 = unicode_byte_type___0((char )*(ptr + 0), (char )*(ptr + 1));
#line 151
      tmp___3 = tmp___2;
      }
    }
    {
#line 152
    if (tmp___3 == 30) {
#line 152
      goto case_30;
    }
#line 162
    if (tmp___3 == 10) {
#line 162
      goto case_10___0;
    }
#line 162
    if (tmp___3 == 9) {
#line 162
      goto case_10___0;
    }
#line 162
    if (tmp___3 == 21) {
#line 162
      goto case_10___0;
    }
#line 166
    if (tmp___3 == 24) {
#line 166
      goto case_24___0;
    }
#line 166
    if (tmp___3 == 22) {
#line 166
      goto case_24___0;
    }
#line 169
    goto switch_default___0;
    case_30: /* CIL Label */ 
#line 153
    if ((unsigned long )(ptr + 2) == (unsigned long )end) {
#line 154
      return (-1);
    }
#line 156
    if ((int const   )*((ptr + 2) + 0) == 0) {
#line 156
      tmp___5 = (int )((struct normal_encoding *)enc)->type[(unsigned char )*((ptr + 2) + 1)];
    } else {
      {
#line 156
      tmp___4 = unicode_byte_type___0((char )*((ptr + 2) + 0), (char )*((ptr + 2) + 1));
#line 156
      tmp___5 = tmp___4;
      }
    }
    {
#line 157
    if (tmp___5 == 30) {
#line 157
      goto case_30___0;
    }
#line 157
    if (tmp___5 == 10) {
#line 157
      goto case_30___0;
    }
#line 157
    if (tmp___5 == 9) {
#line 157
      goto case_30___0;
    }
#line 157
    if (tmp___5 == 21) {
#line 157
      goto case_30___0;
    }
#line 156
    goto switch_break___1;
    case_30___0: /* CIL Label */ 
    case_10: /* CIL Label */ 
    case_9: /* CIL Label */ 
    case_21: /* CIL Label */ 
#line 158
    *nextTokPtr = ptr;
#line 159
    return (0);
    switch_break___1: /* CIL Label */ ;
    }
    case_10___0: /* CIL Label */ 
    case_9___0: /* CIL Label */ 
    case_21___0: /* CIL Label */ 
#line 163
    *nextTokPtr = ptr;
#line 164
    return (16);
    case_24___0: /* CIL Label */ 
    case_22___0: /* CIL Label */ 
#line 167
    ptr += 2;
#line 168
    goto switch_break___0;
    switch_default___0: /* CIL Label */ 
#line 170
    *nextTokPtr = ptr;
#line 171
    return (0);
    switch_break___0: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 174
  return (-1);
}
}
#line 177 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmltok_impl.c"
static int big2_checkPiTarget___0(ENCODING const   *enc , char const   *ptr , char const   *end ,
                                  int *tokPtr ) 
{ 
  int upper ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 181
  upper = 0;
#line 182
  *tokPtr = 11;
#line 183
  if (end - ptr != 6L) {
#line 184
    return (1);
  }
#line 185
  if ((int const   )*(ptr + 0) == 0) {
#line 185
    tmp = (int const   )*(ptr + 1);
  } else {
#line 185
    tmp = (int const   )-1;
  }
  {
#line 186
  if (tmp == 120) {
#line 186
    goto case_120;
  }
#line 188
  if (tmp == 88) {
#line 188
    goto case_88;
  }
#line 191
  goto switch_default;
  case_120: /* CIL Label */ 
#line 187
  goto switch_break;
  case_88: /* CIL Label */ 
#line 189
  upper = 1;
#line 190
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 192
  return (1);
  switch_break: /* CIL Label */ ;
  }
#line 194
  ptr += 2;
#line 195
  if ((int const   )*(ptr + 0) == 0) {
#line 195
    tmp___0 = (int const   )*(ptr + 1);
  } else {
#line 195
    tmp___0 = (int const   )-1;
  }
  {
#line 196
  if (tmp___0 == 109) {
#line 196
    goto case_109;
  }
#line 198
  if (tmp___0 == 77) {
#line 198
    goto case_77;
  }
#line 201
  goto switch_default___0;
  case_109: /* CIL Label */ 
#line 197
  goto switch_break___0;
  case_77: /* CIL Label */ 
#line 199
  upper = 1;
#line 200
  goto switch_break___0;
  switch_default___0: /* CIL Label */ 
#line 202
  return (1);
  switch_break___0: /* CIL Label */ ;
  }
#line 204
  ptr += 2;
#line 205
  if ((int const   )*(ptr + 0) == 0) {
#line 205
    tmp___1 = (int const   )*(ptr + 1);
  } else {
#line 205
    tmp___1 = (int const   )-1;
  }
  {
#line 206
  if (tmp___1 == 108) {
#line 206
    goto case_108;
  }
#line 208
  if (tmp___1 == 76) {
#line 208
    goto case_76;
  }
#line 211
  goto switch_default___1;
  case_108: /* CIL Label */ 
#line 207
  goto switch_break___1;
  case_76: /* CIL Label */ 
#line 209
  upper = 1;
#line 210
  goto switch_break___1;
  switch_default___1: /* CIL Label */ 
#line 212
  return (1);
  switch_break___1: /* CIL Label */ ;
  }
#line 214
  if (upper) {
#line 215
    return (0);
  }
#line 216
  *tokPtr = 12;
#line 217
  return (1);
}
}
#line 222 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmltok_impl.c"
static int big2_scanPi___0(ENCODING const   *enc , char const   *ptr , char const   *end ,
                           char const   **nextTokPtr ) 
{ 
  int tok ;
  char const   *target ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
#line 227
  target = ptr;
#line 228
  if ((unsigned long )ptr == (unsigned long )end) {
#line 229
    return (-1);
  }
#line 230
  if ((int const   )*(ptr + 0) == 0) {
#line 230
    tmp___0 = (int )((struct normal_encoding *)enc)->type[(unsigned char )*(ptr + 1)];
  } else {
    {
#line 230
    tmp = unicode_byte_type___0((char )*(ptr + 0), (char )*(ptr + 1));
#line 230
    tmp___0 = tmp;
    }
  }
  {
#line 231
  if (tmp___0 == 29) {
#line 231
    goto case_29;
  }
#line 231
  if (tmp___0 == 24) {
#line 231
    goto case_24;
  }
#line 231
  if (tmp___0 == 22) {
#line 231
    goto case_24;
  }
#line 231
  if (tmp___0 == 5) {
#line 231
    goto case_5;
  }
#line 231
  if (tmp___0 == 6) {
#line 231
    goto case_6;
  }
#line 231
  if (tmp___0 == 7) {
#line 231
    goto case_7;
  }
#line 232
  goto switch_default;
  case_29: /* CIL Label */ 
#line 231
  if (! (namingBitmap___0[((int const   )nmstrtPages___0[(unsigned char )*(ptr + 0)] << 3) + (int const   )((int )((unsigned char )*(ptr + 1)) >> 5)] & (unsigned int const   )(1 << ((int )((unsigned char )*(ptr + 1)) & 31)))) {
#line 231
    *nextTokPtr = ptr;
#line 231
    return (0);
  }
  case_24: /* CIL Label */ 
  case_22: /* CIL Label */ 
#line 231
  ptr += 2;
#line 231
  goto switch_break;
  case_5: /* CIL Label */ 
#line 231
  if (end - ptr < 2L) {
#line 231
    return (-2);
  }
#line 231
  *nextTokPtr = ptr;
#line 231
  return (0);
#line 231
  ptr += 2;
#line 231
  goto switch_break;
  case_6: /* CIL Label */ 
#line 231
  if (end - ptr < 3L) {
#line 231
    return (-2);
  }
#line 231
  *nextTokPtr = ptr;
#line 231
  return (0);
#line 231
  ptr += 3;
#line 231
  goto switch_break;
  case_7: /* CIL Label */ 
#line 231
  if (end - ptr < 4L) {
#line 231
    return (-2);
  }
#line 231
  *nextTokPtr = ptr;
#line 231
  return (0);
#line 231
  ptr += 4;
#line 231
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 233
  *nextTokPtr = ptr;
#line 234
  return (0);
  switch_break: /* CIL Label */ ;
  }
  {
#line 236
  while (1) {
    while_continue: /* CIL Label */ ;
#line 236
    if (! ((unsigned long )ptr != (unsigned long )end)) {
#line 236
      goto while_break;
    }
#line 237
    if ((int const   )*(ptr + 0) == 0) {
#line 237
      tmp___2 = (int )((struct normal_encoding *)enc)->type[(unsigned char )*(ptr + 1)];
    } else {
      {
#line 237
      tmp___1 = unicode_byte_type___0((char )*(ptr + 0), (char )*(ptr + 1));
#line 237
      tmp___2 = tmp___1;
      }
    }
    {
#line 238
    if (tmp___2 == 29) {
#line 238
      goto case_29___0;
    }
#line 238
    if (tmp___2 == 27) {
#line 238
      goto case_27;
    }
#line 238
    if (tmp___2 == 26) {
#line 238
      goto case_27;
    }
#line 238
    if (tmp___2 == 25) {
#line 238
      goto case_27;
    }
#line 238
    if (tmp___2 == 24) {
#line 238
      goto case_27;
    }
#line 238
    if (tmp___2 == 22) {
#line 238
      goto case_27;
    }
#line 238
    if (tmp___2 == 5) {
#line 238
      goto case_5___0;
    }
#line 238
    if (tmp___2 == 6) {
#line 238
      goto case_6___0;
    }
#line 238
    if (tmp___2 == 7) {
#line 238
      goto case_7___0;
    }
#line 239
    if (tmp___2 == 10) {
#line 239
      goto case_10;
    }
#line 239
    if (tmp___2 == 9) {
#line 239
      goto case_10;
    }
#line 239
    if (tmp___2 == 21) {
#line 239
      goto case_10;
    }
#line 263
    if (tmp___2 == 15) {
#line 263
      goto case_15___0;
    }
#line 276
    goto switch_default___1;
    case_29___0: /* CIL Label */ 
#line 238
    if (! (namingBitmap___0[((int const   )namePages___0[(unsigned char )*(ptr + 0)] << 3) + (int const   )((int )((unsigned char )*(ptr + 1)) >> 5)] & (unsigned int const   )(1 << ((int )((unsigned char )*(ptr + 1)) & 31)))) {
#line 238
      *nextTokPtr = ptr;
#line 238
      return (0);
    }
    case_27: /* CIL Label */ 
    case_26: /* CIL Label */ 
    case_25: /* CIL Label */ 
    case_24___0: /* CIL Label */ 
    case_22___0: /* CIL Label */ 
#line 238
    ptr += 2;
#line 238
    goto switch_break___0;
    case_5___0: /* CIL Label */ 
#line 238
    if (end - ptr < 2L) {
#line 238
      return (-2);
    }
#line 238
    *nextTokPtr = ptr;
#line 238
    return (0);
#line 238
    ptr += 2;
#line 238
    goto switch_break___0;
    case_6___0: /* CIL Label */ 
#line 238
    if (end - ptr < 3L) {
#line 238
      return (-2);
    }
#line 238
    *nextTokPtr = ptr;
#line 238
    return (0);
#line 238
    ptr += 3;
#line 238
    goto switch_break___0;
    case_7___0: /* CIL Label */ 
#line 238
    if (end - ptr < 4L) {
#line 238
      return (-2);
    }
#line 238
    *nextTokPtr = ptr;
#line 238
    return (0);
#line 238
    ptr += 4;
#line 238
    goto switch_break___0;
    case_10: /* CIL Label */ 
    case_9: /* CIL Label */ 
    case_21: /* CIL Label */ 
    {
#line 240
    tmp___3 = big2_checkPiTarget___0(enc, target, ptr, & tok);
    }
#line 240
    if (! tmp___3) {
#line 241
      *nextTokPtr = ptr;
#line 242
      return (0);
    }
#line 244
    ptr += 2;
    {
#line 245
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 245
      if (! ((unsigned long )ptr != (unsigned long )end)) {
#line 245
        goto while_break___0;
      }
#line 246
      if ((int const   )*(ptr + 0) == 0) {
#line 246
        tmp___5 = (int )((struct normal_encoding *)enc)->type[(unsigned char )*(ptr + 1)];
      } else {
        {
#line 246
        tmp___4 = unicode_byte_type___0((char )*(ptr + 0), (char )*(ptr + 1));
#line 246
        tmp___5 = tmp___4;
        }
      }
      {
#line 247
      if (tmp___5 == 5) {
#line 247
        goto case_5___1;
      }
#line 247
      if (tmp___5 == 6) {
#line 247
        goto case_6___1;
      }
#line 247
      if (tmp___5 == 7) {
#line 247
        goto case_7___1;
      }
#line 247
      if (tmp___5 == 8) {
#line 247
        goto case_8;
      }
#line 247
      if (tmp___5 == 1) {
#line 247
        goto case_8;
      }
#line 247
      if (tmp___5 == 0) {
#line 247
        goto case_8;
      }
#line 248
      if (tmp___5 == 15) {
#line 248
        goto case_15;
      }
#line 257
      goto switch_default___0;
      case_5___1: /* CIL Label */ 
#line 247
      if (end - ptr < 2L) {
#line 247
        return (-2);
      }
#line 247
      ptr += 2;
#line 247
      goto switch_break___1;
      case_6___1: /* CIL Label */ 
#line 247
      if (end - ptr < 3L) {
#line 247
        return (-2);
      }
#line 247
      ptr += 3;
#line 247
      goto switch_break___1;
      case_7___1: /* CIL Label */ 
#line 247
      if (end - ptr < 4L) {
#line 247
        return (-2);
      }
#line 247
      ptr += 4;
#line 247
      goto switch_break___1;
      case_8: /* CIL Label */ 
      case_1: /* CIL Label */ 
      case_0: /* CIL Label */ 
#line 247
      *nextTokPtr = ptr;
#line 247
      return (0);
      case_15: /* CIL Label */ 
#line 249
      ptr += 2;
#line 250
      if ((unsigned long )ptr == (unsigned long )end) {
#line 251
        return (-1);
      }
#line 252
      if ((int const   )*(ptr + 0) == 0) {
#line 252
        if ((int const   )*(ptr + 1) == 62) {
#line 253
          *nextTokPtr = ptr + 2;
#line 254
          return (tok);
        }
      }
#line 256
      goto switch_break___1;
      switch_default___0: /* CIL Label */ 
#line 258
      ptr += 2;
#line 259
      goto switch_break___1;
      switch_break___1: /* CIL Label */ ;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 262
    return (-1);
    case_15___0: /* CIL Label */ 
    {
#line 264
    tmp___6 = big2_checkPiTarget___0(enc, target, ptr, & tok);
    }
#line 264
    if (! tmp___6) {
#line 265
      *nextTokPtr = ptr;
#line 266
      return (0);
    }
#line 268
    ptr += 2;
#line 269
    if ((unsigned long )ptr == (unsigned long )end) {
#line 270
      return (-1);
    }
#line 271
    if ((int const   )*(ptr + 0) == 0) {
#line 271
      if ((int const   )*(ptr + 1) == 62) {
#line 272
        *nextTokPtr = ptr + 2;
#line 273
        return (tok);
      }
    }
    switch_default___1: /* CIL Label */ 
#line 277
    *nextTokPtr = ptr;
#line 278
    return (0);
    switch_break___0: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 281
  return (-1);
}
}
#line 288
static int big2_scanCdataSection___0(ENCODING const   *enc , char const   *ptr , char const   *end ,
                                     char const   **nextTokPtr ) ;
#line 288 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmltok_impl.c"
static char const   CDATA_LSQB___4[6]  = {      (char const   )67,      (char const   )68,      (char const   )65,      (char const   )84, 
        (char const   )65,      (char const   )91};
#line 284 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmltok_impl.c"
static int big2_scanCdataSection___0(ENCODING const   *enc , char const   *ptr , char const   *end ,
                                     char const   **nextTokPtr ) 
{ 
  int i ;

  {
#line 292
  if (end - ptr < 12L) {
#line 293
    return (-1);
  }
#line 294
  i = 0;
  {
#line 294
  while (1) {
    while_continue: /* CIL Label */ ;
#line 294
    if (! (i < 6)) {
#line 294
      goto while_break;
    }
#line 295
    if ((int const   )*(ptr + 0) == 0) {
#line 295
      if (! ((int const   )*(ptr + 1) == (int const   )CDATA_LSQB___4[i])) {
#line 296
        *nextTokPtr = ptr;
#line 297
        return (0);
      }
    } else {
#line 296
      *nextTokPtr = ptr;
#line 297
      return (0);
    }
#line 294
    i ++;
#line 294
    ptr += 2;
  }
  while_break: /* CIL Label */ ;
  }
#line 300
  *nextTokPtr = ptr;
#line 301
  return (8);
}
}
#line 304 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmltok_impl.c"
static int big2_cdataSectionTok___0(ENCODING const   *enc , char const   *ptr , char const   *end ,
                                    char const   **nextTokPtr ) 
{ 
  size_t n ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 308
  if ((unsigned long )ptr == (unsigned long )end) {
#line 309
    return (-4);
  }
#line 311
  n = (size_t )(end - ptr);
#line 312
  if (n & 1UL) {
#line 313
    n &= 0xfffffffffffffffeUL;
#line 314
    if (n == 0UL) {
#line 315
      return (-1);
    }
#line 316
    end = ptr + n;
  }
#line 319
  if ((int const   )*(ptr + 0) == 0) {
#line 319
    tmp___0 = (int )((struct normal_encoding *)enc)->type[(unsigned char )*(ptr + 1)];
  } else {
    {
#line 319
    tmp = unicode_byte_type___0((char )*(ptr + 0), (char )*(ptr + 1));
#line 319
    tmp___0 = tmp;
    }
  }
  {
#line 320
  if (tmp___0 == 4) {
#line 320
    goto case_4;
  }
#line 335
  if (tmp___0 == 9) {
#line 335
    goto case_9;
  }
#line 343
  if (tmp___0 == 10) {
#line 343
    goto case_10;
  }
#line 346
  if (tmp___0 == 5) {
#line 346
    goto case_5;
  }
#line 346
  if (tmp___0 == 6) {
#line 346
    goto case_6;
  }
#line 346
  if (tmp___0 == 7) {
#line 346
    goto case_7;
  }
#line 346
  if (tmp___0 == 8) {
#line 346
    goto case_8;
  }
#line 346
  if (tmp___0 == 1) {
#line 346
    goto case_8;
  }
#line 346
  if (tmp___0 == 0) {
#line 346
    goto case_8;
  }
#line 347
  goto switch_default;
  case_4: /* CIL Label */ 
#line 321
  ptr += 2;
#line 322
  if ((unsigned long )ptr == (unsigned long )end) {
#line 323
    return (-1);
  }
#line 324
  if ((int const   )*(ptr + 0) == 0) {
#line 324
    if (! ((int const   )*(ptr + 1) == 93)) {
#line 325
      goto switch_break;
    }
  } else {
#line 325
    goto switch_break;
  }
#line 326
  ptr += 2;
#line 327
  if ((unsigned long )ptr == (unsigned long )end) {
#line 328
    return (-1);
  }
#line 329
  if ((int const   )*(ptr + 0) == 0) {
#line 329
    if (! ((int const   )*(ptr + 1) == 62)) {
#line 330
      ptr -= 2;
#line 331
      goto switch_break;
    }
  } else {
#line 330
    ptr -= 2;
#line 331
    goto switch_break;
  }
#line 333
  *nextTokPtr = ptr + 2;
#line 334
  return (40);
  case_9: /* CIL Label */ 
#line 336
  ptr += 2;
#line 337
  if ((unsigned long )ptr == (unsigned long )end) {
#line 338
    return (-1);
  }
#line 339
  if ((int const   )*(ptr + 0) == 0) {
#line 339
    tmp___2 = (int )((struct normal_encoding *)enc)->type[(unsigned char )*(ptr + 1)];
  } else {
    {
#line 339
    tmp___1 = unicode_byte_type___0((char )*(ptr + 0), (char )*(ptr + 1));
#line 339
    tmp___2 = tmp___1;
    }
  }
#line 339
  if (tmp___2 == 10) {
#line 340
    ptr += 2;
  }
#line 341
  *nextTokPtr = ptr;
#line 342
  return (7);
  case_10: /* CIL Label */ 
#line 344
  *nextTokPtr = ptr + 2;
#line 345
  return (7);
  case_5: /* CIL Label */ 
#line 346
  if (end - ptr < 2L) {
#line 346
    return (-2);
  }
#line 346
  ptr += 2;
#line 346
  goto switch_break;
  case_6: /* CIL Label */ 
#line 346
  if (end - ptr < 3L) {
#line 346
    return (-2);
  }
#line 346
  ptr += 3;
#line 346
  goto switch_break;
  case_7: /* CIL Label */ 
#line 346
  if (end - ptr < 4L) {
#line 346
    return (-2);
  }
#line 346
  ptr += 4;
#line 346
  goto switch_break;
  case_8: /* CIL Label */ 
  case_1: /* CIL Label */ 
  case_0: /* CIL Label */ 
#line 346
  *nextTokPtr = ptr;
#line 346
  return (0);
  switch_default: /* CIL Label */ 
#line 348
  ptr += 2;
#line 349
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 351
  while (1) {
    while_continue: /* CIL Label */ ;
#line 351
    if (! ((unsigned long )ptr != (unsigned long )end)) {
#line 351
      goto while_break;
    }
#line 352
    if ((int const   )*(ptr + 0) == 0) {
#line 352
      tmp___4 = (int )((struct normal_encoding *)enc)->type[(unsigned char )*(ptr + 1)];
    } else {
      {
#line 352
      tmp___3 = unicode_byte_type___0((char )*(ptr + 0), (char )*(ptr + 1));
#line 352
      tmp___4 = tmp___3;
      }
    }
    {
#line 361
    if (tmp___4 == 5) {
#line 361
      goto case_5___0;
    }
#line 361
    if (tmp___4 == 6) {
#line 361
      goto case_6___0;
    }
#line 361
    if (tmp___4 == 7) {
#line 361
      goto case_7___0;
    }
#line 368
    if (tmp___4 == 4) {
#line 368
      goto case_4___0;
    }
#line 368
    if (tmp___4 == 10) {
#line 368
      goto case_4___0;
    }
#line 368
    if (tmp___4 == 9) {
#line 368
      goto case_4___0;
    }
#line 368
    if (tmp___4 == 8) {
#line 368
      goto case_4___0;
    }
#line 368
    if (tmp___4 == 1) {
#line 368
      goto case_4___0;
    }
#line 368
    if (tmp___4 == 0) {
#line 368
      goto case_4___0;
    }
#line 371
    goto switch_default___0;
    case_5___0: /* CIL Label */ 
#line 361
    if (end - ptr < 2L) {
#line 361
      *nextTokPtr = ptr;
#line 361
      return (6);
    }
#line 361
    ptr += 2;
#line 361
    goto switch_break___0;
    case_6___0: /* CIL Label */ 
#line 361
    if (end - ptr < 3L) {
#line 361
      *nextTokPtr = ptr;
#line 361
      return (6);
    }
#line 361
    ptr += 3;
#line 361
    goto switch_break___0;
    case_7___0: /* CIL Label */ 
#line 361
    if (end - ptr < 4L) {
#line 361
      *nextTokPtr = ptr;
#line 361
      return (6);
    }
#line 361
    ptr += 4;
#line 361
    goto switch_break___0;
    case_4___0: /* CIL Label */ 
    case_10___0: /* CIL Label */ 
    case_9___0: /* CIL Label */ 
    case_8___0: /* CIL Label */ 
    case_1___0: /* CIL Label */ 
    case_0___0: /* CIL Label */ 
#line 369
    *nextTokPtr = ptr;
#line 370
    return (6);
    switch_default___0: /* CIL Label */ 
#line 372
    ptr += 2;
#line 373
    goto switch_break___0;
    switch_break___0: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 376
  *nextTokPtr = ptr;
#line 377
  return (6);
}
}
#line 382 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmltok_impl.c"
static int big2_scanEndTag___0(ENCODING const   *enc , char const   *ptr , char const   *end ,
                               char const   **nextTokPtr ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 386
  if ((unsigned long )ptr == (unsigned long )end) {
#line 387
    return (-1);
  }
#line 388
  if ((int const   )*(ptr + 0) == 0) {
#line 388
    tmp___0 = (int )((struct normal_encoding *)enc)->type[(unsigned char )*(ptr + 1)];
  } else {
    {
#line 388
    tmp = unicode_byte_type___0((char )*(ptr + 0), (char )*(ptr + 1));
#line 388
    tmp___0 = tmp;
    }
  }
  {
#line 389
  if (tmp___0 == 29) {
#line 389
    goto case_29;
  }
#line 389
  if (tmp___0 == 24) {
#line 389
    goto case_24;
  }
#line 389
  if (tmp___0 == 22) {
#line 389
    goto case_24;
  }
#line 389
  if (tmp___0 == 5) {
#line 389
    goto case_5;
  }
#line 389
  if (tmp___0 == 6) {
#line 389
    goto case_6;
  }
#line 389
  if (tmp___0 == 7) {
#line 389
    goto case_7;
  }
#line 390
  goto switch_default;
  case_29: /* CIL Label */ 
#line 389
  if (! (namingBitmap___0[((int const   )nmstrtPages___0[(unsigned char )*(ptr + 0)] << 3) + (int const   )((int )((unsigned char )*(ptr + 1)) >> 5)] & (unsigned int const   )(1 << ((int )((unsigned char )*(ptr + 1)) & 31)))) {
#line 389
    *nextTokPtr = ptr;
#line 389
    return (0);
  }
  case_24: /* CIL Label */ 
  case_22: /* CIL Label */ 
#line 389
  ptr += 2;
#line 389
  goto switch_break;
  case_5: /* CIL Label */ 
#line 389
  if (end - ptr < 2L) {
#line 389
    return (-2);
  }
#line 389
  *nextTokPtr = ptr;
#line 389
  return (0);
#line 389
  ptr += 2;
#line 389
  goto switch_break;
  case_6: /* CIL Label */ 
#line 389
  if (end - ptr < 3L) {
#line 389
    return (-2);
  }
#line 389
  *nextTokPtr = ptr;
#line 389
  return (0);
#line 389
  ptr += 3;
#line 389
  goto switch_break;
  case_7: /* CIL Label */ 
#line 389
  if (end - ptr < 4L) {
#line 389
    return (-2);
  }
#line 389
  *nextTokPtr = ptr;
#line 389
  return (0);
#line 389
  ptr += 4;
#line 389
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 391
  *nextTokPtr = ptr;
#line 392
  return (0);
  switch_break: /* CIL Label */ ;
  }
  {
#line 394
  while (1) {
    while_continue: /* CIL Label */ ;
#line 394
    if (! ((unsigned long )ptr != (unsigned long )end)) {
#line 394
      goto while_break;
    }
#line 395
    if ((int const   )*(ptr + 0) == 0) {
#line 395
      tmp___2 = (int )((struct normal_encoding *)enc)->type[(unsigned char )*(ptr + 1)];
    } else {
      {
#line 395
      tmp___1 = unicode_byte_type___0((char )*(ptr + 0), (char )*(ptr + 1));
#line 395
      tmp___2 = tmp___1;
      }
    }
    {
#line 396
    if (tmp___2 == 29) {
#line 396
      goto case_29___0;
    }
#line 396
    if (tmp___2 == 27) {
#line 396
      goto case_27;
    }
#line 396
    if (tmp___2 == 26) {
#line 396
      goto case_27;
    }
#line 396
    if (tmp___2 == 25) {
#line 396
      goto case_27;
    }
#line 396
    if (tmp___2 == 24) {
#line 396
      goto case_27;
    }
#line 396
    if (tmp___2 == 22) {
#line 396
      goto case_27;
    }
#line 396
    if (tmp___2 == 5) {
#line 396
      goto case_5___0;
    }
#line 396
    if (tmp___2 == 6) {
#line 396
      goto case_6___0;
    }
#line 396
    if (tmp___2 == 7) {
#line 396
      goto case_7___0;
    }
#line 397
    if (tmp___2 == 10) {
#line 397
      goto case_10;
    }
#line 397
    if (tmp___2 == 9) {
#line 397
      goto case_10;
    }
#line 397
    if (tmp___2 == 21) {
#line 397
      goto case_10;
    }
#line 412
    if (tmp___2 == 23) {
#line 412
      goto case_23;
    }
#line 418
    if (tmp___2 == 11) {
#line 418
      goto case_11___0;
    }
#line 421
    goto switch_default___1;
    case_29___0: /* CIL Label */ 
#line 396
    if (! (namingBitmap___0[((int const   )namePages___0[(unsigned char )*(ptr + 0)] << 3) + (int const   )((int )((unsigned char )*(ptr + 1)) >> 5)] & (unsigned int const   )(1 << ((int )((unsigned char )*(ptr + 1)) & 31)))) {
#line 396
      *nextTokPtr = ptr;
#line 396
      return (0);
    }
    case_27: /* CIL Label */ 
    case_26: /* CIL Label */ 
    case_25: /* CIL Label */ 
    case_24___0: /* CIL Label */ 
    case_22___0: /* CIL Label */ 
#line 396
    ptr += 2;
#line 396
    goto switch_break___0;
    case_5___0: /* CIL Label */ 
#line 396
    if (end - ptr < 2L) {
#line 396
      return (-2);
    }
#line 396
    *nextTokPtr = ptr;
#line 396
    return (0);
#line 396
    ptr += 2;
#line 396
    goto switch_break___0;
    case_6___0: /* CIL Label */ 
#line 396
    if (end - ptr < 3L) {
#line 396
      return (-2);
    }
#line 396
    *nextTokPtr = ptr;
#line 396
    return (0);
#line 396
    ptr += 3;
#line 396
    goto switch_break___0;
    case_7___0: /* CIL Label */ 
#line 396
    if (end - ptr < 4L) {
#line 396
      return (-2);
    }
#line 396
    *nextTokPtr = ptr;
#line 396
    return (0);
#line 396
    ptr += 4;
#line 396
    goto switch_break___0;
    case_10: /* CIL Label */ 
    case_9: /* CIL Label */ 
    case_21: /* CIL Label */ 
#line 398
    ptr += 2;
    {
#line 398
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 398
      if (! ((unsigned long )ptr != (unsigned long )end)) {
#line 398
        goto while_break___0;
      }
#line 399
      if ((int const   )*(ptr + 0) == 0) {
#line 399
        tmp___4 = (int )((struct normal_encoding *)enc)->type[(unsigned char )*(ptr + 1)];
      } else {
        {
#line 399
        tmp___3 = unicode_byte_type___0((char )*(ptr + 0), (char )*(ptr + 1));
#line 399
        tmp___4 = tmp___3;
        }
      }
      {
#line 400
      if (tmp___4 == 10) {
#line 400
        goto case_10___0;
      }
#line 400
      if (tmp___4 == 9) {
#line 400
        goto case_10___0;
      }
#line 400
      if (tmp___4 == 21) {
#line 400
        goto case_10___0;
      }
#line 402
      if (tmp___4 == 11) {
#line 402
        goto case_11;
      }
#line 405
      goto switch_default___0;
      case_10___0: /* CIL Label */ 
      case_9___0: /* CIL Label */ 
      case_21___0: /* CIL Label */ 
#line 401
      goto switch_break___1;
      case_11: /* CIL Label */ 
#line 403
      *nextTokPtr = ptr + 2;
#line 404
      return (5);
      switch_default___0: /* CIL Label */ 
#line 406
      *nextTokPtr = ptr;
#line 407
      return (0);
      switch_break___1: /* CIL Label */ ;
      }
#line 398
      ptr += 2;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 410
    return (-1);
    case_23: /* CIL Label */ 
#line 415
    ptr += 2;
#line 416
    goto switch_break___0;
    case_11___0: /* CIL Label */ 
#line 419
    *nextTokPtr = ptr + 2;
#line 420
    return (5);
    switch_default___1: /* CIL Label */ 
#line 422
    *nextTokPtr = ptr;
#line 423
    return (0);
    switch_break___0: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 426
  return (-1);
}
}
#line 431 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmltok_impl.c"
static int big2_scanHexCharRef___0(ENCODING const   *enc , char const   *ptr , char const   *end ,
                                   char const   **nextTokPtr ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 435
  if ((unsigned long )ptr != (unsigned long )end) {
#line 436
    if ((int const   )*(ptr + 0) == 0) {
#line 436
      tmp___0 = (int )((struct normal_encoding *)enc)->type[(unsigned char )*(ptr + 1)];
    } else {
      {
#line 436
      tmp = unicode_byte_type___0((char )*(ptr + 0), (char )*(ptr + 1));
#line 436
      tmp___0 = tmp;
      }
    }
    {
#line 438
    if (tmp___0 == 24) {
#line 438
      goto case_24;
    }
#line 438
    if (tmp___0 == 25) {
#line 438
      goto case_24;
    }
#line 440
    goto switch_default;
    case_24: /* CIL Label */ 
    case_25: /* CIL Label */ 
#line 439
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 441
    *nextTokPtr = ptr;
#line 442
    return (0);
    switch_break: /* CIL Label */ ;
    }
#line 444
    ptr += 2;
    {
#line 444
    while (1) {
      while_continue: /* CIL Label */ ;
#line 444
      if (! ((unsigned long )ptr != (unsigned long )end)) {
#line 444
        goto while_break;
      }
#line 445
      if ((int const   )*(ptr + 0) == 0) {
#line 445
        tmp___2 = (int )((struct normal_encoding *)enc)->type[(unsigned char )*(ptr + 1)];
      } else {
        {
#line 445
        tmp___1 = unicode_byte_type___0((char )*(ptr + 0), (char )*(ptr + 1));
#line 445
        tmp___2 = tmp___1;
        }
      }
      {
#line 447
      if (tmp___2 == 24) {
#line 447
        goto case_24___0;
      }
#line 447
      if (tmp___2 == 25) {
#line 447
        goto case_24___0;
      }
#line 449
      if (tmp___2 == 18) {
#line 449
        goto case_18;
      }
#line 452
      goto switch_default___0;
      case_24___0: /* CIL Label */ 
      case_25___0: /* CIL Label */ 
#line 448
      goto switch_break___0;
      case_18: /* CIL Label */ 
#line 450
      *nextTokPtr = ptr + 2;
#line 451
      return (10);
      switch_default___0: /* CIL Label */ 
#line 453
      *nextTokPtr = ptr;
#line 454
      return (0);
      switch_break___0: /* CIL Label */ ;
      }
#line 444
      ptr += 2;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 458
  return (-1);
}
}
#line 463 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmltok_impl.c"
static int big2_scanCharRef___0(ENCODING const   *enc , char const   *ptr , char const   *end ,
                                char const   **nextTokPtr ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 467
  if ((unsigned long )ptr != (unsigned long )end) {
#line 468
    if ((int const   )*(ptr + 0) == 0) {
#line 468
      if ((int const   )*(ptr + 1) == 120) {
        {
#line 469
        tmp = big2_scanHexCharRef___0(enc, ptr + 2, end, nextTokPtr);
        }
#line 469
        return (tmp);
      }
    }
#line 470
    if ((int const   )*(ptr + 0) == 0) {
#line 470
      tmp___1 = (int )((struct normal_encoding *)enc)->type[(unsigned char )*(ptr + 1)];
    } else {
      {
#line 470
      tmp___0 = unicode_byte_type___0((char )*(ptr + 0), (char )*(ptr + 1));
#line 470
      tmp___1 = tmp___0;
      }
    }
    {
#line 471
    if (tmp___1 == 25) {
#line 471
      goto case_25;
    }
#line 473
    goto switch_default;
    case_25: /* CIL Label */ 
#line 472
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 474
    *nextTokPtr = ptr;
#line 475
    return (0);
    switch_break: /* CIL Label */ ;
    }
#line 477
    ptr += 2;
    {
#line 477
    while (1) {
      while_continue: /* CIL Label */ ;
#line 477
      if (! ((unsigned long )ptr != (unsigned long )end)) {
#line 477
        goto while_break;
      }
#line 478
      if ((int const   )*(ptr + 0) == 0) {
#line 478
        tmp___3 = (int )((struct normal_encoding *)enc)->type[(unsigned char )*(ptr + 1)];
      } else {
        {
#line 478
        tmp___2 = unicode_byte_type___0((char )*(ptr + 0), (char )*(ptr + 1));
#line 478
        tmp___3 = tmp___2;
        }
      }
      {
#line 479
      if (tmp___3 == 25) {
#line 479
        goto case_25___0;
      }
#line 481
      if (tmp___3 == 18) {
#line 481
        goto case_18;
      }
#line 484
      goto switch_default___0;
      case_25___0: /* CIL Label */ 
#line 480
      goto switch_break___0;
      case_18: /* CIL Label */ 
#line 482
      *nextTokPtr = ptr + 2;
#line 483
      return (10);
      switch_default___0: /* CIL Label */ 
#line 485
      *nextTokPtr = ptr;
#line 486
      return (0);
      switch_break___0: /* CIL Label */ ;
      }
#line 477
      ptr += 2;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 490
  return (-1);
}
}
#line 495 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmltok_impl.c"
static int big2_scanRef___0(ENCODING const   *enc , char const   *ptr , char const   *end ,
                            char const   **nextTokPtr ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 499
  if ((unsigned long )ptr == (unsigned long )end) {
#line 500
    return (-1);
  }
#line 501
  if ((int const   )*(ptr + 0) == 0) {
#line 501
    tmp___0 = (int )((struct normal_encoding *)enc)->type[(unsigned char )*(ptr + 1)];
  } else {
    {
#line 501
    tmp = unicode_byte_type___0((char )*(ptr + 0), (char )*(ptr + 1));
#line 501
    tmp___0 = tmp;
    }
  }
  {
#line 502
  if (tmp___0 == 29) {
#line 502
    goto case_29;
  }
#line 502
  if (tmp___0 == 24) {
#line 502
    goto case_24;
  }
#line 502
  if (tmp___0 == 22) {
#line 502
    goto case_24;
  }
#line 502
  if (tmp___0 == 5) {
#line 502
    goto case_5;
  }
#line 502
  if (tmp___0 == 6) {
#line 502
    goto case_6;
  }
#line 502
  if (tmp___0 == 7) {
#line 502
    goto case_7;
  }
#line 503
  if (tmp___0 == 19) {
#line 503
    goto case_19;
  }
#line 505
  goto switch_default;
  case_29: /* CIL Label */ 
#line 502
  if (! (namingBitmap___0[((int const   )nmstrtPages___0[(unsigned char )*(ptr + 0)] << 3) + (int const   )((int )((unsigned char )*(ptr + 1)) >> 5)] & (unsigned int const   )(1 << ((int )((unsigned char )*(ptr + 1)) & 31)))) {
#line 502
    *nextTokPtr = ptr;
#line 502
    return (0);
  }
  case_24: /* CIL Label */ 
  case_22: /* CIL Label */ 
#line 502
  ptr += 2;
#line 502
  goto switch_break;
  case_5: /* CIL Label */ 
#line 502
  if (end - ptr < 2L) {
#line 502
    return (-2);
  }
#line 502
  *nextTokPtr = ptr;
#line 502
  return (0);
#line 502
  ptr += 2;
#line 502
  goto switch_break;
  case_6: /* CIL Label */ 
#line 502
  if (end - ptr < 3L) {
#line 502
    return (-2);
  }
#line 502
  *nextTokPtr = ptr;
#line 502
  return (0);
#line 502
  ptr += 3;
#line 502
  goto switch_break;
  case_7: /* CIL Label */ 
#line 502
  if (end - ptr < 4L) {
#line 502
    return (-2);
  }
#line 502
  *nextTokPtr = ptr;
#line 502
  return (0);
#line 502
  ptr += 4;
#line 502
  goto switch_break;
  case_19: /* CIL Label */ 
  {
#line 504
  tmp___1 = big2_scanCharRef___0(enc, ptr + 2, end, nextTokPtr);
  }
#line 504
  return (tmp___1);
  switch_default: /* CIL Label */ 
#line 506
  *nextTokPtr = ptr;
#line 507
  return (0);
  switch_break: /* CIL Label */ ;
  }
  {
#line 509
  while (1) {
    while_continue: /* CIL Label */ ;
#line 509
    if (! ((unsigned long )ptr != (unsigned long )end)) {
#line 509
      goto while_break;
    }
#line 510
    if ((int const   )*(ptr + 0) == 0) {
#line 510
      tmp___3 = (int )((struct normal_encoding *)enc)->type[(unsigned char )*(ptr + 1)];
    } else {
      {
#line 510
      tmp___2 = unicode_byte_type___0((char )*(ptr + 0), (char )*(ptr + 1));
#line 510
      tmp___3 = tmp___2;
      }
    }
    {
#line 511
    if (tmp___3 == 29) {
#line 511
      goto case_29___0;
    }
#line 511
    if (tmp___3 == 27) {
#line 511
      goto case_27;
    }
#line 511
    if (tmp___3 == 26) {
#line 511
      goto case_27;
    }
#line 511
    if (tmp___3 == 25) {
#line 511
      goto case_27;
    }
#line 511
    if (tmp___3 == 24) {
#line 511
      goto case_27;
    }
#line 511
    if (tmp___3 == 22) {
#line 511
      goto case_27;
    }
#line 511
    if (tmp___3 == 5) {
#line 511
      goto case_5___0;
    }
#line 511
    if (tmp___3 == 6) {
#line 511
      goto case_6___0;
    }
#line 511
    if (tmp___3 == 7) {
#line 511
      goto case_7___0;
    }
#line 512
    if (tmp___3 == 18) {
#line 512
      goto case_18;
    }
#line 515
    goto switch_default___0;
    case_29___0: /* CIL Label */ 
#line 511
    if (! (namingBitmap___0[((int const   )namePages___0[(unsigned char )*(ptr + 0)] << 3) + (int const   )((int )((unsigned char )*(ptr + 1)) >> 5)] & (unsigned int const   )(1 << ((int )((unsigned char )*(ptr + 1)) & 31)))) {
#line 511
      *nextTokPtr = ptr;
#line 511
      return (0);
    }
    case_27: /* CIL Label */ 
    case_26: /* CIL Label */ 
    case_25: /* CIL Label */ 
    case_24___0: /* CIL Label */ 
    case_22___0: /* CIL Label */ 
#line 511
    ptr += 2;
#line 511
    goto switch_break___0;
    case_5___0: /* CIL Label */ 
#line 511
    if (end - ptr < 2L) {
#line 511
      return (-2);
    }
#line 511
    *nextTokPtr = ptr;
#line 511
    return (0);
#line 511
    ptr += 2;
#line 511
    goto switch_break___0;
    case_6___0: /* CIL Label */ 
#line 511
    if (end - ptr < 3L) {
#line 511
      return (-2);
    }
#line 511
    *nextTokPtr = ptr;
#line 511
    return (0);
#line 511
    ptr += 3;
#line 511
    goto switch_break___0;
    case_7___0: /* CIL Label */ 
#line 511
    if (end - ptr < 4L) {
#line 511
      return (-2);
    }
#line 511
    *nextTokPtr = ptr;
#line 511
    return (0);
#line 511
    ptr += 4;
#line 511
    goto switch_break___0;
    case_18: /* CIL Label */ 
#line 513
    *nextTokPtr = ptr + 2;
#line 514
    return (9);
    switch_default___0: /* CIL Label */ 
#line 516
    *nextTokPtr = ptr;
#line 517
    return (0);
    switch_break___0: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 520
  return (-1);
}
}
#line 525 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmltok_impl.c"
static int big2_scanAtts___0(ENCODING const   *enc , char const   *ptr , char const   *end ,
                             char const   **nextTokPtr ) 
{ 
  int hadColon ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int t ;
  int tmp___3 ;
  int open___0 ;
  int tmp___4 ;
  int t___0 ;
  int tmp___5 ;
  int tok ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;

  {
#line 530
  hadColon = 0;
  {
#line 532
  while (1) {
    while_continue: /* CIL Label */ ;
#line 532
    if (! ((unsigned long )ptr != (unsigned long )end)) {
#line 532
      goto while_break;
    }
#line 533
    if ((int const   )*(ptr + 0) == 0) {
#line 533
      tmp___0 = (int )((struct normal_encoding *)enc)->type[(unsigned char )*(ptr + 1)];
    } else {
      {
#line 533
      tmp = unicode_byte_type___0((char )*(ptr + 0), (char )*(ptr + 1));
#line 533
      tmp___0 = tmp;
      }
    }
    {
#line 534
    if (tmp___0 == 29) {
#line 534
      goto case_29;
    }
#line 534
    if (tmp___0 == 27) {
#line 534
      goto case_27;
    }
#line 534
    if (tmp___0 == 26) {
#line 534
      goto case_27;
    }
#line 534
    if (tmp___0 == 25) {
#line 534
      goto case_27;
    }
#line 534
    if (tmp___0 == 24) {
#line 534
      goto case_27;
    }
#line 534
    if (tmp___0 == 22) {
#line 534
      goto case_27;
    }
#line 534
    if (tmp___0 == 5) {
#line 534
      goto case_5;
    }
#line 534
    if (tmp___0 == 6) {
#line 534
      goto case_6;
    }
#line 534
    if (tmp___0 == 7) {
#line 534
      goto case_7;
    }
#line 536
    if (tmp___0 == 23) {
#line 536
      goto case_23;
    }
#line 553
    if (tmp___0 == 10) {
#line 553
      goto case_10;
    }
#line 553
    if (tmp___0 == 9) {
#line 553
      goto case_10;
    }
#line 553
    if (tmp___0 == 21) {
#line 553
      goto case_10;
    }
#line 574
    if (tmp___0 == 14) {
#line 574
      goto case_14;
    }
#line 674
    goto switch_default___5;
    case_29: /* CIL Label */ 
#line 534
    if (! (namingBitmap___0[((int const   )namePages___0[(unsigned char )*(ptr + 0)] << 3) + (int const   )((int )((unsigned char )*(ptr + 1)) >> 5)] & (unsigned int const   )(1 << ((int )((unsigned char )*(ptr + 1)) & 31)))) {
#line 534
      *nextTokPtr = ptr;
#line 534
      return (0);
    }
    case_27: /* CIL Label */ 
    case_26: /* CIL Label */ 
    case_25: /* CIL Label */ 
    case_24: /* CIL Label */ 
    case_22: /* CIL Label */ 
#line 534
    ptr += 2;
#line 534
    goto switch_break;
    case_5: /* CIL Label */ 
#line 534
    if (end - ptr < 2L) {
#line 534
      return (-2);
    }
#line 534
    *nextTokPtr = ptr;
#line 534
    return (0);
#line 534
    ptr += 2;
#line 534
    goto switch_break;
    case_6: /* CIL Label */ 
#line 534
    if (end - ptr < 3L) {
#line 534
      return (-2);
    }
#line 534
    *nextTokPtr = ptr;
#line 534
    return (0);
#line 534
    ptr += 3;
#line 534
    goto switch_break;
    case_7: /* CIL Label */ 
#line 534
    if (end - ptr < 4L) {
#line 534
      return (-2);
    }
#line 534
    *nextTokPtr = ptr;
#line 534
    return (0);
#line 534
    ptr += 4;
#line 534
    goto switch_break;
    case_23: /* CIL Label */ 
#line 537
    if (hadColon) {
#line 538
      *nextTokPtr = ptr;
#line 539
      return (0);
    }
#line 541
    hadColon = 1;
#line 542
    ptr += 2;
#line 543
    if ((unsigned long )ptr == (unsigned long )end) {
#line 544
      return (-1);
    }
#line 545
    if ((int const   )*(ptr + 0) == 0) {
#line 545
      tmp___2 = (int )((struct normal_encoding *)enc)->type[(unsigned char )*(ptr + 1)];
    } else {
      {
#line 545
      tmp___1 = unicode_byte_type___0((char )*(ptr + 0), (char )*(ptr + 1));
#line 545
      tmp___2 = tmp___1;
      }
    }
    {
#line 546
    if (tmp___2 == 29) {
#line 546
      goto case_29___0;
    }
#line 546
    if (tmp___2 == 24) {
#line 546
      goto case_24___0;
    }
#line 546
    if (tmp___2 == 22) {
#line 546
      goto case_24___0;
    }
#line 546
    if (tmp___2 == 5) {
#line 546
      goto case_5___0;
    }
#line 546
    if (tmp___2 == 6) {
#line 546
      goto case_6___0;
    }
#line 546
    if (tmp___2 == 7) {
#line 546
      goto case_7___0;
    }
#line 547
    goto switch_default;
    case_29___0: /* CIL Label */ 
#line 546
    if (! (namingBitmap___0[((int const   )nmstrtPages___0[(unsigned char )*(ptr + 0)] << 3) + (int const   )((int )((unsigned char )*(ptr + 1)) >> 5)] & (unsigned int const   )(1 << ((int )((unsigned char )*(ptr + 1)) & 31)))) {
#line 546
      *nextTokPtr = ptr;
#line 546
      return (0);
    }
    case_24___0: /* CIL Label */ 
    case_22___0: /* CIL Label */ 
#line 546
    ptr += 2;
#line 546
    goto switch_break___0;
    case_5___0: /* CIL Label */ 
#line 546
    if (end - ptr < 2L) {
#line 546
      return (-2);
    }
#line 546
    *nextTokPtr = ptr;
#line 546
    return (0);
#line 546
    ptr += 2;
#line 546
    goto switch_break___0;
    case_6___0: /* CIL Label */ 
#line 546
    if (end - ptr < 3L) {
#line 546
      return (-2);
    }
#line 546
    *nextTokPtr = ptr;
#line 546
    return (0);
#line 546
    ptr += 3;
#line 546
    goto switch_break___0;
    case_7___0: /* CIL Label */ 
#line 546
    if (end - ptr < 4L) {
#line 546
      return (-2);
    }
#line 546
    *nextTokPtr = ptr;
#line 546
    return (0);
#line 546
    ptr += 4;
#line 546
    goto switch_break___0;
    switch_default: /* CIL Label */ 
#line 548
    *nextTokPtr = ptr;
#line 549
    return (0);
    switch_break___0: /* CIL Label */ ;
    }
#line 551
    goto switch_break;
    case_10: /* CIL Label */ 
    case_9: /* CIL Label */ 
    case_21: /* CIL Label */ 
    {
#line 554
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 557
      ptr += 2;
#line 558
      if ((unsigned long )ptr == (unsigned long )end) {
#line 559
        return (-1);
      }
#line 560
      if ((int const   )*(ptr + 0) == 0) {
#line 560
        t = (int )((struct normal_encoding *)enc)->type[(unsigned char )*(ptr + 1)];
      } else {
        {
#line 560
        tmp___3 = unicode_byte_type___0((char )*(ptr + 0), (char )*(ptr + 1));
#line 560
        t = tmp___3;
        }
      }
#line 561
      if (t == 14) {
#line 562
        goto while_break___0;
      }
      {
#line 566
      if (t == 9) {
#line 566
        goto case_9___0;
      }
#line 566
      if (t == 10) {
#line 566
        goto case_9___0;
      }
#line 566
      if (t == 21) {
#line 566
        goto case_9___0;
      }
#line 568
      goto switch_default___0;
      case_9___0: /* CIL Label */ 
      case_10___0: /* CIL Label */ 
      case_21___0: /* CIL Label */ 
#line 567
      goto switch_break___1;
      switch_default___0: /* CIL Label */ 
#line 569
      *nextTokPtr = ptr;
#line 570
      return (0);
      switch_break___1: /* CIL Label */ ;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    case_14: /* CIL Label */ 
#line 578
    hadColon = 0;
    {
#line 580
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 581
      ptr += 2;
#line 582
      if ((unsigned long )ptr == (unsigned long )end) {
#line 583
        return (-1);
      }
#line 584
      if ((int const   )*(ptr + 0) == 0) {
#line 584
        open___0 = (int )((struct normal_encoding *)enc)->type[(unsigned char )*(ptr + 1)];
      } else {
        {
#line 584
        tmp___4 = unicode_byte_type___0((char )*(ptr + 0), (char )*(ptr + 1));
#line 584
        open___0 = tmp___4;
        }
      }
#line 585
      if (open___0 == 12) {
#line 586
        goto while_break___1;
      } else
#line 585
      if (open___0 == 13) {
#line 586
        goto while_break___1;
      }
      {
#line 590
      if (open___0 == 9) {
#line 590
        goto case_9___1;
      }
#line 590
      if (open___0 == 10) {
#line 590
        goto case_9___1;
      }
#line 590
      if (open___0 == 21) {
#line 590
        goto case_9___1;
      }
#line 592
      goto switch_default___1;
      case_9___1: /* CIL Label */ 
      case_10___1: /* CIL Label */ 
      case_21___1: /* CIL Label */ 
#line 591
      goto switch_break___2;
      switch_default___1: /* CIL Label */ 
#line 593
      *nextTokPtr = ptr;
#line 594
      return (0);
      switch_break___2: /* CIL Label */ ;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
#line 597
    ptr += 2;
    {
#line 599
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 601
      if ((unsigned long )ptr == (unsigned long )end) {
#line 602
        return (-1);
      }
#line 603
      if ((int const   )*(ptr + 0) == 0) {
#line 603
        t___0 = (int )((struct normal_encoding *)enc)->type[(unsigned char )*(ptr + 1)];
      } else {
        {
#line 603
        tmp___5 = unicode_byte_type___0((char )*(ptr + 0), (char )*(ptr + 1));
#line 603
        t___0 = tmp___5;
        }
      }
#line 604
      if (t___0 == open___0) {
#line 605
        goto while_break___2;
      }
      {
#line 607
      if (t___0 == 5) {
#line 607
        goto case_5___1;
      }
#line 607
      if (t___0 == 6) {
#line 607
        goto case_6___1;
      }
#line 607
      if (t___0 == 7) {
#line 607
        goto case_7___1;
      }
#line 607
      if (t___0 == 8) {
#line 607
        goto case_8;
      }
#line 607
      if (t___0 == 1) {
#line 607
        goto case_8;
      }
#line 607
      if (t___0 == 0) {
#line 607
        goto case_8;
      }
#line 608
      if (t___0 == 3) {
#line 608
        goto case_3;
      }
#line 618
      if (t___0 == 2) {
#line 618
        goto case_2;
      }
#line 621
      goto switch_default___2;
      case_5___1: /* CIL Label */ 
#line 607
      if (end - ptr < 2L) {
#line 607
        return (-2);
      }
#line 607
      ptr += 2;
#line 607
      goto switch_break___3;
      case_6___1: /* CIL Label */ 
#line 607
      if (end - ptr < 3L) {
#line 607
        return (-2);
      }
#line 607
      ptr += 3;
#line 607
      goto switch_break___3;
      case_7___1: /* CIL Label */ 
#line 607
      if (end - ptr < 4L) {
#line 607
        return (-2);
      }
#line 607
      ptr += 4;
#line 607
      goto switch_break___3;
      case_8: /* CIL Label */ 
      case_1: /* CIL Label */ 
      case_0: /* CIL Label */ 
#line 607
      *nextTokPtr = ptr;
#line 607
      return (0);
      case_3: /* CIL Label */ 
      {
#line 610
      tmp___6 = big2_scanRef___0(enc, ptr + 2, end, & ptr);
#line 610
      tok = tmp___6;
      }
#line 611
      if (tok <= 0) {
#line 612
        if (tok == 0) {
#line 613
          *nextTokPtr = ptr;
        }
#line 614
        return (tok);
      }
#line 616
      goto switch_break___3;
      case_2: /* CIL Label */ 
#line 619
      *nextTokPtr = ptr;
#line 620
      return (0);
      switch_default___2: /* CIL Label */ 
#line 622
      ptr += 2;
#line 623
      goto switch_break___3;
      switch_break___3: /* CIL Label */ ;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
#line 626
    ptr += 2;
#line 627
    if ((unsigned long )ptr == (unsigned long )end) {
#line 628
      return (-1);
    }
#line 629
    if ((int const   )*(ptr + 0) == 0) {
#line 629
      tmp___8 = (int )((struct normal_encoding *)enc)->type[(unsigned char )*(ptr + 1)];
    } else {
      {
#line 629
      tmp___7 = unicode_byte_type___0((char )*(ptr + 0), (char )*(ptr + 1));
#line 629
      tmp___8 = tmp___7;
      }
    }
    {
#line 632
    if (tmp___8 == 10) {
#line 632
      goto case_10___2;
    }
#line 632
    if (tmp___8 == 9) {
#line 632
      goto case_10___2;
    }
#line 632
    if (tmp___8 == 21) {
#line 632
      goto case_10___2;
    }
#line 634
    if (tmp___8 == 17) {
#line 634
      goto case_17;
    }
#line 636
    if (tmp___8 == 11) {
#line 636
      goto case_11;
    }
#line 638
    goto switch_default___3;
    case_10___2: /* CIL Label */ 
    case_9___2: /* CIL Label */ 
    case_21___2: /* CIL Label */ 
#line 633
    goto switch_break___4;
    case_17: /* CIL Label */ 
#line 635
    goto sol;
    case_11: /* CIL Label */ 
#line 637
    goto gt;
    switch_default___3: /* CIL Label */ 
#line 639
    *nextTokPtr = ptr;
#line 640
    return (0);
    switch_break___4: /* CIL Label */ ;
    }
    {
#line 643
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 644
      ptr += 2;
#line 645
      if ((unsigned long )ptr == (unsigned long )end) {
#line 646
        return (-1);
      }
#line 647
      if ((int const   )*(ptr + 0) == 0) {
#line 647
        tmp___10 = (int )((struct normal_encoding *)enc)->type[(unsigned char )*(ptr + 1)];
      } else {
        {
#line 647
        tmp___9 = unicode_byte_type___0((char )*(ptr + 0), (char )*(ptr + 1));
#line 647
        tmp___10 = tmp___9;
        }
      }
      {
#line 648
      if (tmp___10 == 29) {
#line 648
        goto case_29___1;
      }
#line 648
      if (tmp___10 == 24) {
#line 648
        goto case_24___1;
      }
#line 648
      if (tmp___10 == 22) {
#line 648
        goto case_24___1;
      }
#line 648
      if (tmp___10 == 5) {
#line 648
        goto case_5___2;
      }
#line 648
      if (tmp___10 == 6) {
#line 648
        goto case_6___2;
      }
#line 648
      if (tmp___10 == 7) {
#line 648
        goto case_7___2;
      }
#line 649
      if (tmp___10 == 10) {
#line 649
        goto case_10___3;
      }
#line 649
      if (tmp___10 == 9) {
#line 649
        goto case_10___3;
      }
#line 649
      if (tmp___10 == 21) {
#line 649
        goto case_10___3;
      }
#line 651
      if (tmp___10 == 11) {
#line 651
        goto gt;
      }
#line 655
      if (tmp___10 == 17) {
#line 655
        goto sol;
      }
#line 666
      goto switch_default___4;
      case_29___1: /* CIL Label */ 
#line 648
      if (! (namingBitmap___0[((int const   )nmstrtPages___0[(unsigned char )*(ptr + 0)] << 3) + (int const   )((int )((unsigned char )*(ptr + 1)) >> 5)] & (unsigned int const   )(1 << ((int )((unsigned char )*(ptr + 1)) & 31)))) {
#line 648
        *nextTokPtr = ptr;
#line 648
        return (0);
      }
      case_24___1: /* CIL Label */ 
      case_22___1: /* CIL Label */ 
#line 648
      ptr += 2;
#line 648
      goto switch_break___5;
      case_5___2: /* CIL Label */ 
#line 648
      if (end - ptr < 2L) {
#line 648
        return (-2);
      }
#line 648
      *nextTokPtr = ptr;
#line 648
      return (0);
#line 648
      ptr += 2;
#line 648
      goto switch_break___5;
      case_6___2: /* CIL Label */ 
#line 648
      if (end - ptr < 3L) {
#line 648
        return (-2);
      }
#line 648
      *nextTokPtr = ptr;
#line 648
      return (0);
#line 648
      ptr += 3;
#line 648
      goto switch_break___5;
      case_7___2: /* CIL Label */ 
#line 648
      if (end - ptr < 4L) {
#line 648
        return (-2);
      }
#line 648
      *nextTokPtr = ptr;
#line 648
      return (0);
#line 648
      ptr += 4;
#line 648
      goto switch_break___5;
      case_10___3: /* CIL Label */ 
      case_9___3: /* CIL Label */ 
      case_21___3: /* CIL Label */ 
#line 650
      goto __Cont;
      gt: 
      case_11___0: /* CIL Label */ 
#line 653
      *nextTokPtr = ptr + 2;
#line 654
      return (1);
      sol: 
      case_17___0: /* CIL Label */ 
#line 657
      ptr += 2;
#line 658
      if ((unsigned long )ptr == (unsigned long )end) {
#line 659
        return (-1);
      }
#line 660
      if ((int const   )*(ptr + 0) == 0) {
#line 660
        if (! ((int const   )*(ptr + 1) == 62)) {
#line 661
          *nextTokPtr = ptr;
#line 662
          return (0);
        }
      } else {
#line 661
        *nextTokPtr = ptr;
#line 662
        return (0);
      }
#line 664
      *nextTokPtr = ptr + 2;
#line 665
      return (3);
      switch_default___4: /* CIL Label */ 
#line 667
      *nextTokPtr = ptr;
#line 668
      return (0);
      switch_break___5: /* CIL Label */ ;
      }
#line 670
      goto while_break___3;
      __Cont: /* CIL Label */ ;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 672
    goto switch_break;
    switch_default___5: /* CIL Label */ 
#line 675
    *nextTokPtr = ptr;
#line 676
    return (0);
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 679
  return (-1);
}
}
#line 684 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmltok_impl.c"
static int big2_scanLt___0(ENCODING const   *enc , char const   *ptr , char const   *end ,
                           char const   **nextTokPtr ) 
{ 
  int hadColon ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;

  {
#line 691
  if ((unsigned long )ptr == (unsigned long )end) {
#line 692
    return (-1);
  }
#line 693
  if ((int const   )*(ptr + 0) == 0) {
#line 693
    tmp___0 = (int )((struct normal_encoding *)enc)->type[(unsigned char )*(ptr + 1)];
  } else {
    {
#line 693
    tmp = unicode_byte_type___0((char )*(ptr + 0), (char )*(ptr + 1));
#line 693
    tmp___0 = tmp;
    }
  }
  {
#line 694
  if (tmp___0 == 29) {
#line 694
    goto case_29;
  }
#line 694
  if (tmp___0 == 24) {
#line 694
    goto case_24;
  }
#line 694
  if (tmp___0 == 22) {
#line 694
    goto case_24;
  }
#line 694
  if (tmp___0 == 5) {
#line 694
    goto case_5;
  }
#line 694
  if (tmp___0 == 6) {
#line 694
    goto case_6;
  }
#line 694
  if (tmp___0 == 7) {
#line 694
    goto case_7;
  }
#line 695
  if (tmp___0 == 16) {
#line 695
    goto case_16;
  }
#line 707
  if (tmp___0 == 15) {
#line 707
    goto case_15;
  }
#line 709
  if (tmp___0 == 17) {
#line 709
    goto case_17;
  }
#line 711
  goto switch_default;
  case_29: /* CIL Label */ 
#line 694
  if (! (namingBitmap___0[((int const   )nmstrtPages___0[(unsigned char )*(ptr + 0)] << 3) + (int const   )((int )((unsigned char )*(ptr + 1)) >> 5)] & (unsigned int const   )(1 << ((int )((unsigned char )*(ptr + 1)) & 31)))) {
#line 694
    *nextTokPtr = ptr;
#line 694
    return (0);
  }
  case_24: /* CIL Label */ 
  case_22: /* CIL Label */ 
#line 694
  ptr += 2;
#line 694
  goto switch_break;
  case_5: /* CIL Label */ 
#line 694
  if (end - ptr < 2L) {
#line 694
    return (-2);
  }
#line 694
  *nextTokPtr = ptr;
#line 694
  return (0);
#line 694
  ptr += 2;
#line 694
  goto switch_break;
  case_6: /* CIL Label */ 
#line 694
  if (end - ptr < 3L) {
#line 694
    return (-2);
  }
#line 694
  *nextTokPtr = ptr;
#line 694
  return (0);
#line 694
  ptr += 3;
#line 694
  goto switch_break;
  case_7: /* CIL Label */ 
#line 694
  if (end - ptr < 4L) {
#line 694
    return (-2);
  }
#line 694
  *nextTokPtr = ptr;
#line 694
  return (0);
#line 694
  ptr += 4;
#line 694
  goto switch_break;
  case_16: /* CIL Label */ 
#line 696
  ptr += 2;
#line 696
  if ((unsigned long )ptr == (unsigned long )end) {
#line 697
    return (-1);
  }
#line 698
  if ((int const   )*(ptr + 0) == 0) {
#line 698
    tmp___2 = (int )((struct normal_encoding *)enc)->type[(unsigned char )*(ptr + 1)];
  } else {
    {
#line 698
    tmp___1 = unicode_byte_type___0((char )*(ptr + 0), (char )*(ptr + 1));
#line 698
    tmp___2 = tmp___1;
    }
  }
  {
#line 699
  if (tmp___2 == 27) {
#line 699
    goto case_27;
  }
#line 701
  if (tmp___2 == 20) {
#line 701
    goto case_20;
  }
#line 698
  goto switch_break___0;
  case_27: /* CIL Label */ 
  {
#line 700
  tmp___3 = big2_scanComment___0(enc, ptr + 2, end, nextTokPtr);
  }
#line 700
  return (tmp___3);
  case_20: /* CIL Label */ 
  {
#line 702
  tmp___4 = big2_scanCdataSection___0(enc, ptr + 2, end, nextTokPtr);
  }
#line 702
  return (tmp___4);
  switch_break___0: /* CIL Label */ ;
  }
#line 705
  *nextTokPtr = ptr;
#line 706
  return (0);
  case_15: /* CIL Label */ 
  {
#line 708
  tmp___5 = big2_scanPi___0(enc, ptr + 2, end, nextTokPtr);
  }
#line 708
  return (tmp___5);
  case_17: /* CIL Label */ 
  {
#line 710
  tmp___6 = big2_scanEndTag___0(enc, ptr + 2, end, nextTokPtr);
  }
#line 710
  return (tmp___6);
  switch_default: /* CIL Label */ 
#line 712
  *nextTokPtr = ptr;
#line 713
  return (0);
  switch_break: /* CIL Label */ ;
  }
#line 716
  hadColon = 0;
  {
#line 719
  while (1) {
    while_continue: /* CIL Label */ ;
#line 719
    if (! ((unsigned long )ptr != (unsigned long )end)) {
#line 719
      goto while_break;
    }
#line 720
    if ((int const   )*(ptr + 0) == 0) {
#line 720
      tmp___8 = (int )((struct normal_encoding *)enc)->type[(unsigned char )*(ptr + 1)];
    } else {
      {
#line 720
      tmp___7 = unicode_byte_type___0((char )*(ptr + 0), (char )*(ptr + 1));
#line 720
      tmp___8 = tmp___7;
      }
    }
    {
#line 721
    if (tmp___8 == 29) {
#line 721
      goto case_29___0;
    }
#line 721
    if (tmp___8 == 27) {
#line 721
      goto case_27___0;
    }
#line 721
    if (tmp___8 == 26) {
#line 721
      goto case_27___0;
    }
#line 721
    if (tmp___8 == 25) {
#line 721
      goto case_27___0;
    }
#line 721
    if (tmp___8 == 24) {
#line 721
      goto case_27___0;
    }
#line 721
    if (tmp___8 == 22) {
#line 721
      goto case_27___0;
    }
#line 721
    if (tmp___8 == 5) {
#line 721
      goto case_5___0;
    }
#line 721
    if (tmp___8 == 6) {
#line 721
      goto case_6___0;
    }
#line 721
    if (tmp___8 == 7) {
#line 721
      goto case_7___0;
    }
#line 723
    if (tmp___8 == 23) {
#line 723
      goto case_23;
    }
#line 740
    if (tmp___8 == 10) {
#line 740
      goto case_10;
    }
#line 740
    if (tmp___8 == 9) {
#line 740
      goto case_10;
    }
#line 740
    if (tmp___8 == 21) {
#line 740
      goto case_10;
    }
#line 761
    if (tmp___8 == 11) {
#line 761
      goto gt;
    }
#line 765
    if (tmp___8 == 17) {
#line 765
      goto sol;
    }
#line 776
    goto switch_default___2;
    case_29___0: /* CIL Label */ 
#line 721
    if (! (namingBitmap___0[((int const   )namePages___0[(unsigned char )*(ptr + 0)] << 3) + (int const   )((int )((unsigned char )*(ptr + 1)) >> 5)] & (unsigned int const   )(1 << ((int )((unsigned char )*(ptr + 1)) & 31)))) {
#line 721
      *nextTokPtr = ptr;
#line 721
      return (0);
    }
    case_27___0: /* CIL Label */ 
    case_26: /* CIL Label */ 
    case_25: /* CIL Label */ 
    case_24___0: /* CIL Label */ 
    case_22___0: /* CIL Label */ 
#line 721
    ptr += 2;
#line 721
    goto switch_break___1;
    case_5___0: /* CIL Label */ 
#line 721
    if (end - ptr < 2L) {
#line 721
      return (-2);
    }
#line 721
    *nextTokPtr = ptr;
#line 721
    return (0);
#line 721
    ptr += 2;
#line 721
    goto switch_break___1;
    case_6___0: /* CIL Label */ 
#line 721
    if (end - ptr < 3L) {
#line 721
      return (-2);
    }
#line 721
    *nextTokPtr = ptr;
#line 721
    return (0);
#line 721
    ptr += 3;
#line 721
    goto switch_break___1;
    case_7___0: /* CIL Label */ 
#line 721
    if (end - ptr < 4L) {
#line 721
      return (-2);
    }
#line 721
    *nextTokPtr = ptr;
#line 721
    return (0);
#line 721
    ptr += 4;
#line 721
    goto switch_break___1;
    case_23: /* CIL Label */ 
#line 724
    if (hadColon) {
#line 725
      *nextTokPtr = ptr;
#line 726
      return (0);
    }
#line 728
    hadColon = 1;
#line 729
    ptr += 2;
#line 730
    if ((unsigned long )ptr == (unsigned long )end) {
#line 731
      return (-1);
    }
#line 732
    if ((int const   )*(ptr + 0) == 0) {
#line 732
      tmp___10 = (int )((struct normal_encoding *)enc)->type[(unsigned char )*(ptr + 1)];
    } else {
      {
#line 732
      tmp___9 = unicode_byte_type___0((char )*(ptr + 0), (char )*(ptr + 1));
#line 732
      tmp___10 = tmp___9;
      }
    }
    {
#line 733
    if (tmp___10 == 29) {
#line 733
      goto case_29___1;
    }
#line 733
    if (tmp___10 == 24) {
#line 733
      goto case_24___1;
    }
#line 733
    if (tmp___10 == 22) {
#line 733
      goto case_24___1;
    }
#line 733
    if (tmp___10 == 5) {
#line 733
      goto case_5___1;
    }
#line 733
    if (tmp___10 == 6) {
#line 733
      goto case_6___1;
    }
#line 733
    if (tmp___10 == 7) {
#line 733
      goto case_7___1;
    }
#line 734
    goto switch_default___0;
    case_29___1: /* CIL Label */ 
#line 733
    if (! (namingBitmap___0[((int const   )nmstrtPages___0[(unsigned char )*(ptr + 0)] << 3) + (int const   )((int )((unsigned char )*(ptr + 1)) >> 5)] & (unsigned int const   )(1 << ((int )((unsigned char )*(ptr + 1)) & 31)))) {
#line 733
      *nextTokPtr = ptr;
#line 733
      return (0);
    }
    case_24___1: /* CIL Label */ 
    case_22___1: /* CIL Label */ 
#line 733
    ptr += 2;
#line 733
    goto switch_break___2;
    case_5___1: /* CIL Label */ 
#line 733
    if (end - ptr < 2L) {
#line 733
      return (-2);
    }
#line 733
    *nextTokPtr = ptr;
#line 733
    return (0);
#line 733
    ptr += 2;
#line 733
    goto switch_break___2;
    case_6___1: /* CIL Label */ 
#line 733
    if (end - ptr < 3L) {
#line 733
      return (-2);
    }
#line 733
    *nextTokPtr = ptr;
#line 733
    return (0);
#line 733
    ptr += 3;
#line 733
    goto switch_break___2;
    case_7___1: /* CIL Label */ 
#line 733
    if (end - ptr < 4L) {
#line 733
      return (-2);
    }
#line 733
    *nextTokPtr = ptr;
#line 733
    return (0);
#line 733
    ptr += 4;
#line 733
    goto switch_break___2;
    switch_default___0: /* CIL Label */ 
#line 735
    *nextTokPtr = ptr;
#line 736
    return (0);
    switch_break___2: /* CIL Label */ ;
    }
#line 738
    goto switch_break___1;
    case_10: /* CIL Label */ 
    case_9: /* CIL Label */ 
    case_21: /* CIL Label */ 
#line 742
    ptr += 2;
    {
#line 743
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 743
      if (! ((unsigned long )ptr != (unsigned long )end)) {
#line 743
        goto while_break___0;
      }
#line 744
      if ((int const   )*(ptr + 0) == 0) {
#line 744
        tmp___12 = (int )((struct normal_encoding *)enc)->type[(unsigned char )*(ptr + 1)];
      } else {
        {
#line 744
        tmp___11 = unicode_byte_type___0((char )*(ptr + 0), (char )*(ptr + 1));
#line 744
        tmp___12 = tmp___11;
        }
      }
      {
#line 745
      if (tmp___12 == 29) {
#line 745
        goto case_29___2;
      }
#line 745
      if (tmp___12 == 24) {
#line 745
        goto case_24___2;
      }
#line 745
      if (tmp___12 == 22) {
#line 745
        goto case_24___2;
      }
#line 745
      if (tmp___12 == 5) {
#line 745
        goto case_5___2;
      }
#line 745
      if (tmp___12 == 6) {
#line 745
        goto case_6___2;
      }
#line 745
      if (tmp___12 == 7) {
#line 745
        goto case_7___2;
      }
#line 746
      if (tmp___12 == 11) {
#line 746
        goto case_11;
      }
#line 748
      if (tmp___12 == 17) {
#line 748
        goto case_17___0;
      }
#line 750
      if (tmp___12 == 10) {
#line 750
        goto case_10___0;
      }
#line 750
      if (tmp___12 == 9) {
#line 750
        goto case_10___0;
      }
#line 750
      if (tmp___12 == 21) {
#line 750
        goto case_10___0;
      }
#line 753
      goto switch_default___1;
      case_29___2: /* CIL Label */ 
#line 745
      if (! (namingBitmap___0[((int const   )nmstrtPages___0[(unsigned char )*(ptr + 0)] << 3) + (int const   )((int )((unsigned char )*(ptr + 1)) >> 5)] & (unsigned int const   )(1 << ((int )((unsigned char )*(ptr + 1)) & 31)))) {
#line 745
        *nextTokPtr = ptr;
#line 745
        return (0);
      }
      case_24___2: /* CIL Label */ 
      case_22___2: /* CIL Label */ 
#line 745
      ptr += 2;
#line 745
      goto switch_break___3;
      case_5___2: /* CIL Label */ 
#line 745
      if (end - ptr < 2L) {
#line 745
        return (-2);
      }
#line 745
      *nextTokPtr = ptr;
#line 745
      return (0);
#line 745
      ptr += 2;
#line 745
      goto switch_break___3;
      case_6___2: /* CIL Label */ 
#line 745
      if (end - ptr < 3L) {
#line 745
        return (-2);
      }
#line 745
      *nextTokPtr = ptr;
#line 745
      return (0);
#line 745
      ptr += 3;
#line 745
      goto switch_break___3;
      case_7___2: /* CIL Label */ 
#line 745
      if (end - ptr < 4L) {
#line 745
        return (-2);
      }
#line 745
      *nextTokPtr = ptr;
#line 745
      return (0);
#line 745
      ptr += 4;
#line 745
      goto switch_break___3;
      case_11: /* CIL Label */ 
#line 747
      goto gt;
      case_17___0: /* CIL Label */ 
#line 749
      goto sol;
      case_10___0: /* CIL Label */ 
      case_9___0: /* CIL Label */ 
      case_21___0: /* CIL Label */ 
#line 751
      ptr += 2;
#line 752
      goto while_continue___0;
      switch_default___1: /* CIL Label */ 
#line 754
      *nextTokPtr = ptr;
#line 755
      return (0);
      switch_break___3: /* CIL Label */ ;
      }
      {
#line 757
      tmp___13 = big2_scanAtts___0(enc, ptr, end, nextTokPtr);
      }
#line 757
      return (tmp___13);
    }
    while_break___0: /* CIL Label */ ;
    }
#line 759
    return (-1);
    gt: 
    case_11___0: /* CIL Label */ 
#line 763
    *nextTokPtr = ptr + 2;
#line 764
    return (2);
    sol: 
    case_17___1: /* CIL Label */ 
#line 767
    ptr += 2;
#line 768
    if ((unsigned long )ptr == (unsigned long )end) {
#line 769
      return (-1);
    }
#line 770
    if ((int const   )*(ptr + 0) == 0) {
#line 770
      if (! ((int const   )*(ptr + 1) == 62)) {
#line 771
        *nextTokPtr = ptr;
#line 772
        return (0);
      }
    } else {
#line 771
      *nextTokPtr = ptr;
#line 772
      return (0);
    }
#line 774
    *nextTokPtr = ptr + 2;
#line 775
    return (4);
    switch_default___2: /* CIL Label */ 
#line 777
    *nextTokPtr = ptr;
#line 778
    return (0);
    switch_break___1: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 781
  return (-1);
}
}
#line 784 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmltok_impl.c"
static int big2_contentTok___0(ENCODING const   *enc , char const   *ptr , char const   *end ,
                               char const   **nextTokPtr ) 
{ 
  size_t n ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
#line 788
  if ((unsigned long )ptr == (unsigned long )end) {
#line 789
    return (-4);
  }
#line 791
  n = (size_t )(end - ptr);
#line 792
  if (n & 1UL) {
#line 793
    n &= 0xfffffffffffffffeUL;
#line 794
    if (n == 0UL) {
#line 795
      return (-1);
    }
#line 796
    end = ptr + n;
  }
#line 799
  if ((int const   )*(ptr + 0) == 0) {
#line 799
    tmp___0 = (int )((struct normal_encoding *)enc)->type[(unsigned char )*(ptr + 1)];
  } else {
    {
#line 799
    tmp = unicode_byte_type___0((char )*(ptr + 0), (char )*(ptr + 1));
#line 799
    tmp___0 = tmp;
    }
  }
  {
#line 800
  if (tmp___0 == 2) {
#line 800
    goto case_2;
  }
#line 802
  if (tmp___0 == 3) {
#line 802
    goto case_3;
  }
#line 804
  if (tmp___0 == 9) {
#line 804
    goto case_9;
  }
#line 812
  if (tmp___0 == 10) {
#line 812
    goto case_10;
  }
#line 815
  if (tmp___0 == 4) {
#line 815
    goto case_4;
  }
#line 830
  if (tmp___0 == 5) {
#line 830
    goto case_5;
  }
#line 830
  if (tmp___0 == 6) {
#line 830
    goto case_6;
  }
#line 830
  if (tmp___0 == 7) {
#line 830
    goto case_7;
  }
#line 830
  if (tmp___0 == 8) {
#line 830
    goto case_8;
  }
#line 830
  if (tmp___0 == 1) {
#line 830
    goto case_8;
  }
#line 830
  if (tmp___0 == 0) {
#line 830
    goto case_8;
  }
#line 831
  goto switch_default;
  case_2: /* CIL Label */ 
  {
#line 801
  tmp___1 = big2_scanLt___0(enc, ptr + 2, end, nextTokPtr);
  }
#line 801
  return (tmp___1);
  case_3: /* CIL Label */ 
  {
#line 803
  tmp___2 = big2_scanRef___0(enc, ptr + 2, end, nextTokPtr);
  }
#line 803
  return (tmp___2);
  case_9: /* CIL Label */ 
#line 805
  ptr += 2;
#line 806
  if ((unsigned long )ptr == (unsigned long )end) {
#line 807
    return (-3);
  }
#line 808
  if ((int const   )*(ptr + 0) == 0) {
#line 808
    tmp___4 = (int )((struct normal_encoding *)enc)->type[(unsigned char )*(ptr + 1)];
  } else {
    {
#line 808
    tmp___3 = unicode_byte_type___0((char )*(ptr + 0), (char )*(ptr + 1));
#line 808
    tmp___4 = tmp___3;
    }
  }
#line 808
  if (tmp___4 == 10) {
#line 809
    ptr += 2;
  }
#line 810
  *nextTokPtr = ptr;
#line 811
  return (7);
  case_10: /* CIL Label */ 
#line 813
  *nextTokPtr = ptr + 2;
#line 814
  return (7);
  case_4: /* CIL Label */ 
#line 816
  ptr += 2;
#line 817
  if ((unsigned long )ptr == (unsigned long )end) {
#line 818
    return (-5);
  }
#line 819
  if ((int const   )*(ptr + 0) == 0) {
#line 819
    if (! ((int const   )*(ptr + 1) == 93)) {
#line 820
      goto switch_break;
    }
  } else {
#line 820
    goto switch_break;
  }
#line 821
  ptr += 2;
#line 822
  if ((unsigned long )ptr == (unsigned long )end) {
#line 823
    return (-5);
  }
#line 824
  if ((int const   )*(ptr + 0) == 0) {
#line 824
    if (! ((int const   )*(ptr + 1) == 62)) {
#line 825
      ptr -= 2;
#line 826
      goto switch_break;
    }
  } else {
#line 825
    ptr -= 2;
#line 826
    goto switch_break;
  }
#line 828
  *nextTokPtr = ptr;
#line 829
  return (0);
  case_5: /* CIL Label */ 
#line 830
  if (end - ptr < 2L) {
#line 830
    return (-2);
  }
#line 830
  ptr += 2;
#line 830
  goto switch_break;
  case_6: /* CIL Label */ 
#line 830
  if (end - ptr < 3L) {
#line 830
    return (-2);
  }
#line 830
  ptr += 3;
#line 830
  goto switch_break;
  case_7: /* CIL Label */ 
#line 830
  if (end - ptr < 4L) {
#line 830
    return (-2);
  }
#line 830
  ptr += 4;
#line 830
  goto switch_break;
  case_8: /* CIL Label */ 
  case_1: /* CIL Label */ 
  case_0: /* CIL Label */ 
#line 830
  *nextTokPtr = ptr;
#line 830
  return (0);
  switch_default: /* CIL Label */ 
#line 832
  ptr += 2;
#line 833
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 835
  while (1) {
    while_continue: /* CIL Label */ ;
#line 835
    if (! ((unsigned long )ptr != (unsigned long )end)) {
#line 835
      goto while_break;
    }
#line 836
    if ((int const   )*(ptr + 0) == 0) {
#line 836
      tmp___6 = (int )((struct normal_encoding *)enc)->type[(unsigned char )*(ptr + 1)];
    } else {
      {
#line 836
      tmp___5 = unicode_byte_type___0((char )*(ptr + 0), (char )*(ptr + 1));
#line 836
      tmp___6 = tmp___5;
      }
    }
    {
#line 845
    if (tmp___6 == 5) {
#line 845
      goto case_5___0;
    }
#line 845
    if (tmp___6 == 6) {
#line 845
      goto case_6___0;
    }
#line 845
    if (tmp___6 == 7) {
#line 845
      goto case_7___0;
    }
#line 847
    if (tmp___6 == 4) {
#line 847
      goto case_4___0;
    }
#line 869
    if (tmp___6 == 10) {
#line 869
      goto case_10___0;
    }
#line 869
    if (tmp___6 == 9) {
#line 869
      goto case_10___0;
    }
#line 869
    if (tmp___6 == 8) {
#line 869
      goto case_10___0;
    }
#line 869
    if (tmp___6 == 1) {
#line 869
      goto case_10___0;
    }
#line 869
    if (tmp___6 == 0) {
#line 869
      goto case_10___0;
    }
#line 869
    if (tmp___6 == 2) {
#line 869
      goto case_10___0;
    }
#line 869
    if (tmp___6 == 3) {
#line 869
      goto case_10___0;
    }
#line 872
    goto switch_default___0;
    case_5___0: /* CIL Label */ 
#line 845
    if (end - ptr < 2L) {
#line 845
      *nextTokPtr = ptr;
#line 845
      return (6);
    }
#line 845
    ptr += 2;
#line 845
    goto switch_break___0;
    case_6___0: /* CIL Label */ 
#line 845
    if (end - ptr < 3L) {
#line 845
      *nextTokPtr = ptr;
#line 845
      return (6);
    }
#line 845
    ptr += 3;
#line 845
    goto switch_break___0;
    case_7___0: /* CIL Label */ 
#line 845
    if (end - ptr < 4L) {
#line 845
      *nextTokPtr = ptr;
#line 845
      return (6);
    }
#line 845
    ptr += 4;
#line 845
    goto switch_break___0;
    case_4___0: /* CIL Label */ 
#line 848
    if ((unsigned long )(ptr + 2) != (unsigned long )end) {
#line 849
      if ((int const   )*((ptr + 2) + 0) == 0) {
#line 849
        if (! ((int const   )*((ptr + 2) + 1) == 93)) {
#line 850
          ptr += 2;
#line 851
          goto switch_break___0;
        }
      } else {
#line 850
        ptr += 2;
#line 851
        goto switch_break___0;
      }
#line 853
      if ((unsigned long )(ptr + 4) != (unsigned long )end) {
#line 854
        if ((int const   )*((ptr + 4) + 0) == 0) {
#line 854
          if (! ((int const   )*((ptr + 4) + 1) == 62)) {
#line 855
            ptr += 2;
#line 856
            goto switch_break___0;
          }
        } else {
#line 855
          ptr += 2;
#line 856
          goto switch_break___0;
        }
#line 858
        *nextTokPtr = ptr + 4;
#line 859
        return (0);
      }
    }
    case_10___0: /* CIL Label */ 
    case_9___0: /* CIL Label */ 
    case_8___0: /* CIL Label */ 
    case_1___0: /* CIL Label */ 
    case_0___0: /* CIL Label */ 
    case_2___0: /* CIL Label */ 
    case_3___0: /* CIL Label */ 
#line 870
    *nextTokPtr = ptr;
#line 871
    return (6);
    switch_default___0: /* CIL Label */ 
#line 873
    ptr += 2;
#line 874
    goto switch_break___0;
    switch_break___0: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 877
  *nextTokPtr = ptr;
#line 878
  return (6);
}
}
#line 883 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmltok_impl.c"
static int big2_scanPercent___0(ENCODING const   *enc , char const   *ptr , char const   *end ,
                                char const   **nextTokPtr ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 887
  if ((unsigned long )ptr == (unsigned long )end) {
#line 888
    return (-1);
  }
#line 889
  if ((int const   )*(ptr + 0) == 0) {
#line 889
    tmp___0 = (int )((struct normal_encoding *)enc)->type[(unsigned char )*(ptr + 1)];
  } else {
    {
#line 889
    tmp = unicode_byte_type___0((char )*(ptr + 0), (char )*(ptr + 1));
#line 889
    tmp___0 = tmp;
    }
  }
  {
#line 890
  if (tmp___0 == 29) {
#line 890
    goto case_29;
  }
#line 890
  if (tmp___0 == 24) {
#line 890
    goto case_24;
  }
#line 890
  if (tmp___0 == 22) {
#line 890
    goto case_24;
  }
#line 890
  if (tmp___0 == 5) {
#line 890
    goto case_5;
  }
#line 890
  if (tmp___0 == 6) {
#line 890
    goto case_6;
  }
#line 890
  if (tmp___0 == 7) {
#line 890
    goto case_7;
  }
#line 891
  if (tmp___0 == 30) {
#line 891
    goto case_30;
  }
#line 891
  if (tmp___0 == 9) {
#line 891
    goto case_30;
  }
#line 891
  if (tmp___0 == 10) {
#line 891
    goto case_30;
  }
#line 891
  if (tmp___0 == 21) {
#line 891
    goto case_30;
  }
#line 894
  goto switch_default;
  case_29: /* CIL Label */ 
#line 890
  if (! (namingBitmap___0[((int const   )nmstrtPages___0[(unsigned char )*(ptr + 0)] << 3) + (int const   )((int )((unsigned char )*(ptr + 1)) >> 5)] & (unsigned int const   )(1 << ((int )((unsigned char )*(ptr + 1)) & 31)))) {
#line 890
    *nextTokPtr = ptr;
#line 890
    return (0);
  }
  case_24: /* CIL Label */ 
  case_22: /* CIL Label */ 
#line 890
  ptr += 2;
#line 890
  goto switch_break;
  case_5: /* CIL Label */ 
#line 890
  if (end - ptr < 2L) {
#line 890
    return (-2);
  }
#line 890
  *nextTokPtr = ptr;
#line 890
  return (0);
#line 890
  ptr += 2;
#line 890
  goto switch_break;
  case_6: /* CIL Label */ 
#line 890
  if (end - ptr < 3L) {
#line 890
    return (-2);
  }
#line 890
  *nextTokPtr = ptr;
#line 890
  return (0);
#line 890
  ptr += 3;
#line 890
  goto switch_break;
  case_7: /* CIL Label */ 
#line 890
  if (end - ptr < 4L) {
#line 890
    return (-2);
  }
#line 890
  *nextTokPtr = ptr;
#line 890
  return (0);
#line 890
  ptr += 4;
#line 890
  goto switch_break;
  case_30: /* CIL Label */ 
  case_9: /* CIL Label */ 
  case_10: /* CIL Label */ 
  case_21: /* CIL Label */ 
#line 892
  *nextTokPtr = ptr;
#line 893
  return (22);
  switch_default: /* CIL Label */ 
#line 895
  *nextTokPtr = ptr;
#line 896
  return (0);
  switch_break: /* CIL Label */ ;
  }
  {
#line 898
  while (1) {
    while_continue: /* CIL Label */ ;
#line 898
    if (! ((unsigned long )ptr != (unsigned long )end)) {
#line 898
      goto while_break;
    }
#line 899
    if ((int const   )*(ptr + 0) == 0) {
#line 899
      tmp___2 = (int )((struct normal_encoding *)enc)->type[(unsigned char )*(ptr + 1)];
    } else {
      {
#line 899
      tmp___1 = unicode_byte_type___0((char )*(ptr + 0), (char )*(ptr + 1));
#line 899
      tmp___2 = tmp___1;
      }
    }
    {
#line 900
    if (tmp___2 == 29) {
#line 900
      goto case_29___0;
    }
#line 900
    if (tmp___2 == 27) {
#line 900
      goto case_27;
    }
#line 900
    if (tmp___2 == 26) {
#line 900
      goto case_27;
    }
#line 900
    if (tmp___2 == 25) {
#line 900
      goto case_27;
    }
#line 900
    if (tmp___2 == 24) {
#line 900
      goto case_27;
    }
#line 900
    if (tmp___2 == 22) {
#line 900
      goto case_27;
    }
#line 900
    if (tmp___2 == 5) {
#line 900
      goto case_5___0;
    }
#line 900
    if (tmp___2 == 6) {
#line 900
      goto case_6___0;
    }
#line 900
    if (tmp___2 == 7) {
#line 900
      goto case_7___0;
    }
#line 901
    if (tmp___2 == 18) {
#line 901
      goto case_18;
    }
#line 904
    goto switch_default___0;
    case_29___0: /* CIL Label */ 
#line 900
    if (! (namingBitmap___0[((int const   )namePages___0[(unsigned char )*(ptr + 0)] << 3) + (int const   )((int )((unsigned char )*(ptr + 1)) >> 5)] & (unsigned int const   )(1 << ((int )((unsigned char )*(ptr + 1)) & 31)))) {
#line 900
      *nextTokPtr = ptr;
#line 900
      return (0);
    }
    case_27: /* CIL Label */ 
    case_26: /* CIL Label */ 
    case_25: /* CIL Label */ 
    case_24___0: /* CIL Label */ 
    case_22___0: /* CIL Label */ 
#line 900
    ptr += 2;
#line 900
    goto switch_break___0;
    case_5___0: /* CIL Label */ 
#line 900
    if (end - ptr < 2L) {
#line 900
      return (-2);
    }
#line 900
    *nextTokPtr = ptr;
#line 900
    return (0);
#line 900
    ptr += 2;
#line 900
    goto switch_break___0;
    case_6___0: /* CIL Label */ 
#line 900
    if (end - ptr < 3L) {
#line 900
      return (-2);
    }
#line 900
    *nextTokPtr = ptr;
#line 900
    return (0);
#line 900
    ptr += 3;
#line 900
    goto switch_break___0;
    case_7___0: /* CIL Label */ 
#line 900
    if (end - ptr < 4L) {
#line 900
      return (-2);
    }
#line 900
    *nextTokPtr = ptr;
#line 900
    return (0);
#line 900
    ptr += 4;
#line 900
    goto switch_break___0;
    case_18: /* CIL Label */ 
#line 902
    *nextTokPtr = ptr + 2;
#line 903
    return (28);
    switch_default___0: /* CIL Label */ 
#line 905
    *nextTokPtr = ptr;
#line 906
    return (0);
    switch_break___0: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 909
  return (-1);
}
}
#line 912 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmltok_impl.c"
static int big2_scanPoundName___0(ENCODING const   *enc , char const   *ptr , char const   *end ,
                                  char const   **nextTokPtr ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 916
  if ((unsigned long )ptr == (unsigned long )end) {
#line 917
    return (-1);
  }
#line 918
  if ((int const   )*(ptr + 0) == 0) {
#line 918
    tmp___0 = (int )((struct normal_encoding *)enc)->type[(unsigned char )*(ptr + 1)];
  } else {
    {
#line 918
    tmp = unicode_byte_type___0((char )*(ptr + 0), (char )*(ptr + 1));
#line 918
    tmp___0 = tmp;
    }
  }
  {
#line 919
  if (tmp___0 == 29) {
#line 919
    goto case_29;
  }
#line 919
  if (tmp___0 == 24) {
#line 919
    goto case_24;
  }
#line 919
  if (tmp___0 == 22) {
#line 919
    goto case_24;
  }
#line 919
  if (tmp___0 == 5) {
#line 919
    goto case_5;
  }
#line 919
  if (tmp___0 == 6) {
#line 919
    goto case_6;
  }
#line 919
  if (tmp___0 == 7) {
#line 919
    goto case_7;
  }
#line 920
  goto switch_default;
  case_29: /* CIL Label */ 
#line 919
  if (! (namingBitmap___0[((int const   )nmstrtPages___0[(unsigned char )*(ptr + 0)] << 3) + (int const   )((int )((unsigned char )*(ptr + 1)) >> 5)] & (unsigned int const   )(1 << ((int )((unsigned char )*(ptr + 1)) & 31)))) {
#line 919
    *nextTokPtr = ptr;
#line 919
    return (0);
  }
  case_24: /* CIL Label */ 
  case_22: /* CIL Label */ 
#line 919
  ptr += 2;
#line 919
  goto switch_break;
  case_5: /* CIL Label */ 
#line 919
  if (end - ptr < 2L) {
#line 919
    return (-2);
  }
#line 919
  *nextTokPtr = ptr;
#line 919
  return (0);
#line 919
  ptr += 2;
#line 919
  goto switch_break;
  case_6: /* CIL Label */ 
#line 919
  if (end - ptr < 3L) {
#line 919
    return (-2);
  }
#line 919
  *nextTokPtr = ptr;
#line 919
  return (0);
#line 919
  ptr += 3;
#line 919
  goto switch_break;
  case_7: /* CIL Label */ 
#line 919
  if (end - ptr < 4L) {
#line 919
    return (-2);
  }
#line 919
  *nextTokPtr = ptr;
#line 919
  return (0);
#line 919
  ptr += 4;
#line 919
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 921
  *nextTokPtr = ptr;
#line 922
  return (0);
  switch_break: /* CIL Label */ ;
  }
  {
#line 924
  while (1) {
    while_continue: /* CIL Label */ ;
#line 924
    if (! ((unsigned long )ptr != (unsigned long )end)) {
#line 924
      goto while_break;
    }
#line 925
    if ((int const   )*(ptr + 0) == 0) {
#line 925
      tmp___2 = (int )((struct normal_encoding *)enc)->type[(unsigned char )*(ptr + 1)];
    } else {
      {
#line 925
      tmp___1 = unicode_byte_type___0((char )*(ptr + 0), (char )*(ptr + 1));
#line 925
      tmp___2 = tmp___1;
      }
    }
    {
#line 926
    if (tmp___2 == 29) {
#line 926
      goto case_29___0;
    }
#line 926
    if (tmp___2 == 27) {
#line 926
      goto case_27;
    }
#line 926
    if (tmp___2 == 26) {
#line 926
      goto case_27;
    }
#line 926
    if (tmp___2 == 25) {
#line 926
      goto case_27;
    }
#line 926
    if (tmp___2 == 24) {
#line 926
      goto case_27;
    }
#line 926
    if (tmp___2 == 22) {
#line 926
      goto case_27;
    }
#line 926
    if (tmp___2 == 5) {
#line 926
      goto case_5___0;
    }
#line 926
    if (tmp___2 == 6) {
#line 926
      goto case_6___0;
    }
#line 926
    if (tmp___2 == 7) {
#line 926
      goto case_7___0;
    }
#line 928
    if (tmp___2 == 36) {
#line 928
      goto case_36;
    }
#line 928
    if (tmp___2 == 30) {
#line 928
      goto case_36;
    }
#line 928
    if (tmp___2 == 11) {
#line 928
      goto case_36;
    }
#line 928
    if (tmp___2 == 32) {
#line 928
      goto case_36;
    }
#line 928
    if (tmp___2 == 21) {
#line 928
      goto case_36;
    }
#line 928
    if (tmp___2 == 10) {
#line 928
      goto case_36;
    }
#line 928
    if (tmp___2 == 9) {
#line 928
      goto case_36;
    }
#line 931
    goto switch_default___0;
    case_29___0: /* CIL Label */ 
#line 926
    if (! (namingBitmap___0[((int const   )namePages___0[(unsigned char )*(ptr + 0)] << 3) + (int const   )((int )((unsigned char )*(ptr + 1)) >> 5)] & (unsigned int const   )(1 << ((int )((unsigned char )*(ptr + 1)) & 31)))) {
#line 926
      *nextTokPtr = ptr;
#line 926
      return (0);
    }
    case_27: /* CIL Label */ 
    case_26: /* CIL Label */ 
    case_25: /* CIL Label */ 
    case_24___0: /* CIL Label */ 
    case_22___0: /* CIL Label */ 
#line 926
    ptr += 2;
#line 926
    goto switch_break___0;
    case_5___0: /* CIL Label */ 
#line 926
    if (end - ptr < 2L) {
#line 926
      return (-2);
    }
#line 926
    *nextTokPtr = ptr;
#line 926
    return (0);
#line 926
    ptr += 2;
#line 926
    goto switch_break___0;
    case_6___0: /* CIL Label */ 
#line 926
    if (end - ptr < 3L) {
#line 926
      return (-2);
    }
#line 926
    *nextTokPtr = ptr;
#line 926
    return (0);
#line 926
    ptr += 3;
#line 926
    goto switch_break___0;
    case_7___0: /* CIL Label */ 
#line 926
    if (end - ptr < 4L) {
#line 926
      return (-2);
    }
#line 926
    *nextTokPtr = ptr;
#line 926
    return (0);
#line 926
    ptr += 4;
#line 926
    goto switch_break___0;
    case_36: /* CIL Label */ 
    case_30: /* CIL Label */ 
    case_11: /* CIL Label */ 
    case_32: /* CIL Label */ 
    case_21: /* CIL Label */ 
    case_10: /* CIL Label */ 
    case_9: /* CIL Label */ 
#line 929
    *nextTokPtr = ptr;
#line 930
    return (20);
    switch_default___0: /* CIL Label */ 
#line 932
    *nextTokPtr = ptr;
#line 933
    return (0);
    switch_break___0: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 936
  return (-20);
}
}
#line 939 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmltok_impl.c"
static int big2_scanLit___0(int open___0 , ENCODING const   *enc , char const   *ptr ,
                            char const   *end , char const   **nextTokPtr ) 
{ 
  int t ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 944
  while (1) {
    while_continue: /* CIL Label */ ;
#line 944
    if (! ((unsigned long )ptr != (unsigned long )end)) {
#line 944
      goto while_break;
    }
#line 945
    if ((int const   )*(ptr + 0) == 0) {
#line 945
      tmp___0 = (int )((struct normal_encoding *)enc)->type[(unsigned char )*(ptr + 1)];
    } else {
      {
#line 945
      tmp = unicode_byte_type___0((char )*(ptr + 0), (char )*(ptr + 1));
#line 945
      tmp___0 = tmp;
      }
    }
#line 945
    t = tmp___0;
    {
#line 947
    if (t == 5) {
#line 947
      goto case_5;
    }
#line 947
    if (t == 6) {
#line 947
      goto case_6;
    }
#line 947
    if (t == 7) {
#line 947
      goto case_7;
    }
#line 947
    if (t == 8) {
#line 947
      goto case_8;
    }
#line 947
    if (t == 1) {
#line 947
      goto case_8;
    }
#line 947
    if (t == 0) {
#line 947
      goto case_8;
    }
#line 949
    if (t == 13) {
#line 949
      goto case_13;
    }
#line 949
    if (t == 12) {
#line 949
      goto case_13;
    }
#line 963
    goto switch_default___0;
    case_5: /* CIL Label */ 
#line 947
    if (end - ptr < 2L) {
#line 947
      return (-2);
    }
#line 947
    ptr += 2;
#line 947
    goto switch_break;
    case_6: /* CIL Label */ 
#line 947
    if (end - ptr < 3L) {
#line 947
      return (-2);
    }
#line 947
    ptr += 3;
#line 947
    goto switch_break;
    case_7: /* CIL Label */ 
#line 947
    if (end - ptr < 4L) {
#line 947
      return (-2);
    }
#line 947
    ptr += 4;
#line 947
    goto switch_break;
    case_8: /* CIL Label */ 
    case_1: /* CIL Label */ 
    case_0: /* CIL Label */ 
#line 947
    *nextTokPtr = ptr;
#line 947
    return (0);
    case_13: /* CIL Label */ 
    case_12: /* CIL Label */ 
#line 950
    ptr += 2;
#line 951
    if (t != open___0) {
#line 952
      goto switch_break;
    }
#line 953
    if ((unsigned long )ptr == (unsigned long )end) {
#line 954
      return (-27);
    }
#line 955
    *nextTokPtr = ptr;
#line 956
    if ((int const   )*(ptr + 0) == 0) {
#line 956
      tmp___2 = (int )((struct normal_encoding *)enc)->type[(unsigned char )*(ptr + 1)];
    } else {
      {
#line 956
      tmp___1 = unicode_byte_type___0((char )*(ptr + 0), (char )*(ptr + 1));
#line 956
      tmp___2 = tmp___1;
      }
    }
    {
#line 958
    if (tmp___2 == 20) {
#line 958
      goto case_20;
    }
#line 958
    if (tmp___2 == 30) {
#line 958
      goto case_20;
    }
#line 958
    if (tmp___2 == 11) {
#line 958
      goto case_20;
    }
#line 958
    if (tmp___2 == 10) {
#line 958
      goto case_20;
    }
#line 958
    if (tmp___2 == 9) {
#line 958
      goto case_20;
    }
#line 958
    if (tmp___2 == 21) {
#line 958
      goto case_20;
    }
#line 960
    goto switch_default;
    case_20: /* CIL Label */ 
    case_30: /* CIL Label */ 
    case_11: /* CIL Label */ 
    case_10: /* CIL Label */ 
    case_9: /* CIL Label */ 
    case_21: /* CIL Label */ 
#line 959
    return (27);
    switch_default: /* CIL Label */ 
#line 961
    return (0);
    switch_break___0: /* CIL Label */ ;
    }
    switch_default___0: /* CIL Label */ 
#line 964
    ptr += 2;
#line 965
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 968
  return (-1);
}
}
#line 971 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmltok_impl.c"
static int big2_prologTok___0(ENCODING const   *enc , char const   *ptr , char const   *end ,
                              char const   **nextTokPtr ) 
{ 
  int tok ;
  size_t n ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;

  {
#line 976
  if ((unsigned long )ptr == (unsigned long )end) {
#line 977
    return (-4);
  }
#line 979
  n = (size_t )(end - ptr);
#line 980
  if (n & 1UL) {
#line 981
    n &= 0xfffffffffffffffeUL;
#line 982
    if (n == 0UL) {
#line 983
      return (-1);
    }
#line 984
    end = ptr + n;
  }
#line 987
  if ((int const   )*(ptr + 0) == 0) {
#line 987
    tmp___0 = (int )((struct normal_encoding *)enc)->type[(unsigned char )*(ptr + 1)];
  } else {
    {
#line 987
    tmp = unicode_byte_type___0((char )*(ptr + 0), (char )*(ptr + 1));
#line 987
    tmp___0 = tmp;
    }
  }
  {
#line 988
  if (tmp___0 == 12) {
#line 988
    goto case_12;
  }
#line 990
  if (tmp___0 == 13) {
#line 990
    goto case_13;
  }
#line 992
  if (tmp___0 == 2) {
#line 992
    goto case_2;
  }
#line 1014
  if (tmp___0 == 9) {
#line 1014
    goto case_9;
  }
#line 1021
  if (tmp___0 == 10) {
#line 1021
    goto case_10;
  }
#line 1021
  if (tmp___0 == 21) {
#line 1021
    goto case_10;
  }
#line 1041
  if (tmp___0 == 30) {
#line 1041
    goto case_30;
  }
#line 1043
  if (tmp___0 == 35) {
#line 1043
    goto case_35;
  }
#line 1046
  if (tmp___0 == 20) {
#line 1046
    goto case_20;
  }
#line 1049
  if (tmp___0 == 4) {
#line 1049
    goto case_4;
  }
#line 1063
  if (tmp___0 == 31) {
#line 1063
    goto case_31;
  }
#line 1066
  if (tmp___0 == 32) {
#line 1066
    goto case_32;
  }
#line 1088
  if (tmp___0 == 36) {
#line 1088
    goto case_36___0;
  }
#line 1091
  if (tmp___0 == 11) {
#line 1091
    goto case_11___0;
  }
#line 1094
  if (tmp___0 == 19) {
#line 1094
    goto case_19;
  }
#line 1112
  if (tmp___0 == 5) {
#line 1112
    goto case_5___0;
  }
#line 1112
  if (tmp___0 == 6) {
#line 1112
    goto case_6___0;
  }
#line 1112
  if (tmp___0 == 7) {
#line 1112
    goto case_7___0;
  }
#line 1115
  if (tmp___0 == 24) {
#line 1115
    goto case_24___0;
  }
#line 1115
  if (tmp___0 == 22) {
#line 1115
    goto case_24___0;
  }
#line 1123
  if (tmp___0 == 23) {
#line 1123
    goto case_23;
  }
#line 1123
  if (tmp___0 == 27) {
#line 1123
    goto case_23;
  }
#line 1123
  if (tmp___0 == 26) {
#line 1123
    goto case_23;
  }
#line 1123
  if (tmp___0 == 25) {
#line 1123
    goto case_23;
  }
#line 1128
  if (tmp___0 == 29) {
#line 1128
    goto case_29___0;
  }
#line 1140
  goto switch_default___0;
  case_12: /* CIL Label */ 
  {
#line 989
  tmp___1 = big2_scanLit___0(12, enc, ptr + 2, end, nextTokPtr);
  }
#line 989
  return (tmp___1);
  case_13: /* CIL Label */ 
  {
#line 991
  tmp___2 = big2_scanLit___0(13, enc, ptr + 2, end, nextTokPtr);
  }
#line 991
  return (tmp___2);
  case_2: /* CIL Label */ 
#line 994
  ptr += 2;
#line 995
  if ((unsigned long )ptr == (unsigned long )end) {
#line 996
    return (-1);
  }
#line 997
  if ((int const   )*(ptr + 0) == 0) {
#line 997
    tmp___4 = (int )((struct normal_encoding *)enc)->type[(unsigned char )*(ptr + 1)];
  } else {
    {
#line 997
    tmp___3 = unicode_byte_type___0((char )*(ptr + 0), (char )*(ptr + 1));
#line 997
    tmp___4 = tmp___3;
    }
  }
  {
#line 998
  if (tmp___4 == 16) {
#line 998
    goto case_16;
  }
#line 1000
  if (tmp___4 == 15) {
#line 1000
    goto case_15;
  }
#line 1007
  if (tmp___4 == 7) {
#line 1007
    goto case_7;
  }
#line 1007
  if (tmp___4 == 6) {
#line 1007
    goto case_7;
  }
#line 1007
  if (tmp___4 == 5) {
#line 1007
    goto case_7;
  }
#line 1007
  if (tmp___4 == 29) {
#line 1007
    goto case_7;
  }
#line 1007
  if (tmp___4 == 24) {
#line 1007
    goto case_7;
  }
#line 1007
  if (tmp___4 == 22) {
#line 1007
    goto case_7;
  }
#line 997
  goto switch_break___0;
  case_16: /* CIL Label */ 
  {
#line 999
  tmp___5 = big2_scanDecl___0(enc, ptr + 2, end, nextTokPtr);
  }
#line 999
  return (tmp___5);
  case_15: /* CIL Label */ 
  {
#line 1001
  tmp___6 = big2_scanPi___0(enc, ptr + 2, end, nextTokPtr);
  }
#line 1001
  return (tmp___6);
  case_7: /* CIL Label */ 
  case_6: /* CIL Label */ 
  case_5: /* CIL Label */ 
  case_29: /* CIL Label */ 
  case_24: /* CIL Label */ 
  case_22: /* CIL Label */ 
#line 1008
  *nextTokPtr = ptr - 2;
#line 1009
  return (29);
  switch_break___0: /* CIL Label */ ;
  }
#line 1011
  *nextTokPtr = ptr;
#line 1012
  return (0);
  case_9: /* CIL Label */ 
#line 1015
  if ((unsigned long )(ptr + 2) == (unsigned long )end) {
#line 1016
    *nextTokPtr = end;
#line 1018
    return (-15);
  }
  case_10: /* CIL Label */ 
  case_21: /* CIL Label */ 
  {
#line 1022
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1023
    ptr += 2;
#line 1024
    if ((unsigned long )ptr == (unsigned long )end) {
#line 1025
      goto while_break;
    }
#line 1026
    if ((int const   )*(ptr + 0) == 0) {
#line 1026
      tmp___8 = (int )((struct normal_encoding *)enc)->type[(unsigned char )*(ptr + 1)];
    } else {
      {
#line 1026
      tmp___7 = unicode_byte_type___0((char )*(ptr + 0), (char )*(ptr + 1));
#line 1026
      tmp___8 = tmp___7;
      }
    }
    {
#line 1027
    if (tmp___8 == 10) {
#line 1027
      goto case_10___0;
    }
#line 1027
    if (tmp___8 == 21) {
#line 1027
      goto case_10___0;
    }
#line 1029
    if (tmp___8 == 9) {
#line 1029
      goto case_9___0;
    }
#line 1034
    goto switch_default;
    case_10___0: /* CIL Label */ 
    case_21___0: /* CIL Label */ 
#line 1028
    goto switch_break___1;
    case_9___0: /* CIL Label */ 
#line 1031
    if ((unsigned long )(ptr + 2) != (unsigned long )end) {
#line 1032
      goto switch_break___1;
    }
    switch_default: /* CIL Label */ 
#line 1035
    *nextTokPtr = ptr;
#line 1036
    return (15);
    switch_break___1: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1039
  *nextTokPtr = ptr;
#line 1040
  return (15);
  case_30: /* CIL Label */ 
  {
#line 1042
  tmp___9 = big2_scanPercent___0(enc, ptr + 2, end, nextTokPtr);
  }
#line 1042
  return (tmp___9);
  case_35: /* CIL Label */ 
#line 1044
  *nextTokPtr = ptr + 2;
#line 1045
  return (38);
  case_20: /* CIL Label */ 
#line 1047
  *nextTokPtr = ptr + 2;
#line 1048
  return (25);
  case_4: /* CIL Label */ 
#line 1050
  ptr += 2;
#line 1051
  if ((unsigned long )ptr == (unsigned long )end) {
#line 1052
    return (-26);
  }
#line 1053
  if ((int const   )*(ptr + 0) == 0) {
#line 1053
    if ((int const   )*(ptr + 1) == 93) {
#line 1054
      if ((unsigned long )(ptr + 2) == (unsigned long )end) {
#line 1055
        return (-1);
      }
#line 1056
      if ((int const   )*((ptr + 2) + 0) == 0) {
#line 1056
        if ((int const   )*((ptr + 2) + 1) == 62) {
#line 1057
          *nextTokPtr = ptr + 4;
#line 1058
          return (34);
        }
      }
    }
  }
#line 1061
  *nextTokPtr = ptr;
#line 1062
  return (26);
  case_31: /* CIL Label */ 
#line 1064
  *nextTokPtr = ptr + 2;
#line 1065
  return (23);
  case_32: /* CIL Label */ 
#line 1067
  ptr += 2;
#line 1068
  if ((unsigned long )ptr == (unsigned long )end) {
#line 1069
    return (-24);
  }
#line 1070
  if ((int const   )*(ptr + 0) == 0) {
#line 1070
    tmp___11 = (int )((struct normal_encoding *)enc)->type[(unsigned char )*(ptr + 1)];
  } else {
    {
#line 1070
    tmp___10 = unicode_byte_type___0((char )*(ptr + 0), (char )*(ptr + 1));
#line 1070
    tmp___11 = tmp___10;
    }
  }
  {
#line 1071
  if (tmp___11 == 33) {
#line 1071
    goto case_33;
  }
#line 1074
  if (tmp___11 == 15) {
#line 1074
    goto case_15___0;
  }
#line 1077
  if (tmp___11 == 34) {
#line 1077
    goto case_34;
  }
#line 1082
  if (tmp___11 == 32) {
#line 1082
    goto case_32___0;
  }
#line 1082
  if (tmp___11 == 36) {
#line 1082
    goto case_32___0;
  }
#line 1082
  if (tmp___11 == 35) {
#line 1082
    goto case_32___0;
  }
#line 1082
  if (tmp___11 == 11) {
#line 1082
    goto case_32___0;
  }
#line 1082
  if (tmp___11 == 21) {
#line 1082
    goto case_32___0;
  }
#line 1082
  if (tmp___11 == 10) {
#line 1082
    goto case_32___0;
  }
#line 1082
  if (tmp___11 == 9) {
#line 1082
    goto case_32___0;
  }
#line 1070
  goto switch_break___2;
  case_33: /* CIL Label */ 
#line 1072
  *nextTokPtr = ptr + 2;
#line 1073
  return (36);
  case_15___0: /* CIL Label */ 
#line 1075
  *nextTokPtr = ptr + 2;
#line 1076
  return (35);
  case_34: /* CIL Label */ 
#line 1078
  *nextTokPtr = ptr + 2;
#line 1079
  return (37);
  case_32___0: /* CIL Label */ 
  case_36: /* CIL Label */ 
  case_35___0: /* CIL Label */ 
  case_11: /* CIL Label */ 
  case_21___1: /* CIL Label */ 
  case_10___1: /* CIL Label */ 
  case_9___1: /* CIL Label */ 
#line 1083
  *nextTokPtr = ptr;
#line 1084
  return (24);
  switch_break___2: /* CIL Label */ ;
  }
#line 1086
  *nextTokPtr = ptr;
#line 1087
  return (0);
  case_36___0: /* CIL Label */ 
#line 1089
  *nextTokPtr = ptr + 2;
#line 1090
  return (21);
  case_11___0: /* CIL Label */ 
#line 1092
  *nextTokPtr = ptr + 2;
#line 1093
  return (17);
  case_19: /* CIL Label */ 
  {
#line 1095
  tmp___12 = big2_scanPoundName___0(enc, ptr + 2, end, nextTokPtr);
  }
#line 1095
  return (tmp___12);
  case_5___0: /* CIL Label */ 
#line 1112
  if (end - ptr < 2L) {
#line 1112
    return (-2);
  }
#line 1112
  *nextTokPtr = ptr;
#line 1112
  return (0);
  case_6___0: /* CIL Label */ 
#line 1112
  if (end - ptr < 3L) {
#line 1112
    return (-2);
  }
#line 1112
  *nextTokPtr = ptr;
#line 1112
  return (0);
  case_7___0: /* CIL Label */ 
#line 1112
  if (end - ptr < 4L) {
#line 1112
    return (-2);
  }
#line 1112
  *nextTokPtr = ptr;
#line 1112
  return (0);
  case_24___0: /* CIL Label */ 
  case_22___0: /* CIL Label */ 
#line 1116
  tok = 18;
#line 1117
  ptr += 2;
#line 1118
  goto switch_break;
  case_23: /* CIL Label */ 
  case_27: /* CIL Label */ 
  case_26: /* CIL Label */ 
  case_25: /* CIL Label */ 
#line 1125
  tok = 19;
#line 1126
  ptr += 2;
#line 1127
  goto switch_break;
  case_29___0: /* CIL Label */ 
#line 1129
  if (namingBitmap___0[((int const   )nmstrtPages___0[(unsigned char )*(ptr + 0)] << 3) + (int const   )((int )((unsigned char )*(ptr + 1)) >> 5)] & (unsigned int const   )(1 << ((int )((unsigned char )*(ptr + 1)) & 31))) {
#line 1130
    ptr += 2;
#line 1131
    tok = 18;
#line 1132
    goto switch_break;
  }
#line 1134
  if (namingBitmap___0[((int const   )namePages___0[(unsigned char )*(ptr + 0)] << 3) + (int const   )((int )((unsigned char )*(ptr + 1)) >> 5)] & (unsigned int const   )(1 << ((int )((unsigned char )*(ptr + 1)) & 31))) {
#line 1135
    ptr += 2;
#line 1136
    tok = 19;
#line 1137
    goto switch_break;
  }
  switch_default___0: /* CIL Label */ 
#line 1141
  *nextTokPtr = ptr;
#line 1142
  return (0);
  switch_break: /* CIL Label */ ;
  }
  {
#line 1144
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1144
    if (! ((unsigned long )ptr != (unsigned long )end)) {
#line 1144
      goto while_break___0;
    }
#line 1145
    if ((int const   )*(ptr + 0) == 0) {
#line 1145
      tmp___14 = (int )((struct normal_encoding *)enc)->type[(unsigned char )*(ptr + 1)];
    } else {
      {
#line 1145
      tmp___13 = unicode_byte_type___0((char )*(ptr + 0), (char )*(ptr + 1));
#line 1145
      tmp___14 = tmp___13;
      }
    }
    {
#line 1146
    if (tmp___14 == 29) {
#line 1146
      goto case_29___1;
    }
#line 1146
    if (tmp___14 == 27) {
#line 1146
      goto case_27___0;
    }
#line 1146
    if (tmp___14 == 26) {
#line 1146
      goto case_27___0;
    }
#line 1146
    if (tmp___14 == 25) {
#line 1146
      goto case_27___0;
    }
#line 1146
    if (tmp___14 == 24) {
#line 1146
      goto case_27___0;
    }
#line 1146
    if (tmp___14 == 22) {
#line 1146
      goto case_27___0;
    }
#line 1146
    if (tmp___14 == 5) {
#line 1146
      goto case_5___1;
    }
#line 1146
    if (tmp___14 == 6) {
#line 1146
      goto case_6___1;
    }
#line 1146
    if (tmp___14 == 7) {
#line 1146
      goto case_7___1;
    }
#line 1149
    if (tmp___14 == 10) {
#line 1149
      goto case_10___2;
    }
#line 1149
    if (tmp___14 == 9) {
#line 1149
      goto case_10___2;
    }
#line 1149
    if (tmp___14 == 21) {
#line 1149
      goto case_10___2;
    }
#line 1149
    if (tmp___14 == 30) {
#line 1149
      goto case_10___2;
    }
#line 1149
    if (tmp___14 == 20) {
#line 1149
      goto case_10___2;
    }
#line 1149
    if (tmp___14 == 36) {
#line 1149
      goto case_10___2;
    }
#line 1149
    if (tmp___14 == 35) {
#line 1149
      goto case_10___2;
    }
#line 1149
    if (tmp___14 == 32) {
#line 1149
      goto case_10___2;
    }
#line 1149
    if (tmp___14 == 11) {
#line 1149
      goto case_10___2;
    }
#line 1153
    if (tmp___14 == 23) {
#line 1153
      goto case_23___0;
    }
#line 1173
    if (tmp___14 == 34) {
#line 1173
      goto case_34___0;
    }
#line 1180
    if (tmp___14 == 33) {
#line 1180
      goto case_33___0;
    }
#line 1187
    if (tmp___14 == 15) {
#line 1187
      goto case_15___1;
    }
#line 1194
    goto switch_default___2;
    case_29___1: /* CIL Label */ 
#line 1146
    if (! (namingBitmap___0[((int const   )namePages___0[(unsigned char )*(ptr + 0)] << 3) + (int const   )((int )((unsigned char )*(ptr + 1)) >> 5)] & (unsigned int const   )(1 << ((int )((unsigned char )*(ptr + 1)) & 31)))) {
#line 1146
      *nextTokPtr = ptr;
#line 1146
      return (0);
    }
    case_27___0: /* CIL Label */ 
    case_26___0: /* CIL Label */ 
    case_25___0: /* CIL Label */ 
    case_24___1: /* CIL Label */ 
    case_22___1: /* CIL Label */ 
#line 1146
    ptr += 2;
#line 1146
    goto switch_break___3;
    case_5___1: /* CIL Label */ 
#line 1146
    if (end - ptr < 2L) {
#line 1146
      return (-2);
    }
#line 1146
    *nextTokPtr = ptr;
#line 1146
    return (0);
#line 1146
    ptr += 2;
#line 1146
    goto switch_break___3;
    case_6___1: /* CIL Label */ 
#line 1146
    if (end - ptr < 3L) {
#line 1146
      return (-2);
    }
#line 1146
    *nextTokPtr = ptr;
#line 1146
    return (0);
#line 1146
    ptr += 3;
#line 1146
    goto switch_break___3;
    case_7___1: /* CIL Label */ 
#line 1146
    if (end - ptr < 4L) {
#line 1146
      return (-2);
    }
#line 1146
    *nextTokPtr = ptr;
#line 1146
    return (0);
#line 1146
    ptr += 4;
#line 1146
    goto switch_break___3;
    case_10___2: /* CIL Label */ 
    case_9___2: /* CIL Label */ 
    case_21___2: /* CIL Label */ 
    case_30___0: /* CIL Label */ 
    case_20___0: /* CIL Label */ 
    case_36___1: /* CIL Label */ 
    case_35___1: /* CIL Label */ 
    case_32___1: /* CIL Label */ 
    case_11___1: /* CIL Label */ 
#line 1150
    *nextTokPtr = ptr;
#line 1151
    return (tok);
    case_23___0: /* CIL Label */ 
#line 1154
    ptr += 2;
    {
#line 1156
    if (tok == 18) {
#line 1156
      goto case_18;
    }
#line 1167
    if (tok == 41) {
#line 1167
      goto case_41;
    }
#line 1155
    goto switch_break___4;
    case_18: /* CIL Label */ 
#line 1157
    if ((unsigned long )ptr == (unsigned long )end) {
#line 1158
      return (-1);
    }
#line 1159
    tok = 41;
#line 1160
    if ((int const   )*(ptr + 0) == 0) {
#line 1160
      tmp___16 = (int )((struct normal_encoding *)enc)->type[(unsigned char )*(ptr + 1)];
    } else {
      {
#line 1160
      tmp___15 = unicode_byte_type___0((char )*(ptr + 0), (char )*(ptr + 1));
#line 1160
      tmp___16 = tmp___15;
      }
    }
    {
#line 1161
    if (tmp___16 == 29) {
#line 1161
      goto case_29___2;
    }
#line 1161
    if (tmp___16 == 27) {
#line 1161
      goto case_27___1;
    }
#line 1161
    if (tmp___16 == 26) {
#line 1161
      goto case_27___1;
    }
#line 1161
    if (tmp___16 == 25) {
#line 1161
      goto case_27___1;
    }
#line 1161
    if (tmp___16 == 24) {
#line 1161
      goto case_27___1;
    }
#line 1161
    if (tmp___16 == 22) {
#line 1161
      goto case_27___1;
    }
#line 1161
    if (tmp___16 == 5) {
#line 1161
      goto case_5___2;
    }
#line 1161
    if (tmp___16 == 6) {
#line 1161
      goto case_6___2;
    }
#line 1161
    if (tmp___16 == 7) {
#line 1161
      goto case_7___2;
    }
#line 1162
    goto switch_default___1;
    case_29___2: /* CIL Label */ 
#line 1161
    if (! (namingBitmap___0[((int const   )namePages___0[(unsigned char )*(ptr + 0)] << 3) + (int const   )((int )((unsigned char )*(ptr + 1)) >> 5)] & (unsigned int const   )(1 << ((int )((unsigned char )*(ptr + 1)) & 31)))) {
#line 1161
      *nextTokPtr = ptr;
#line 1161
      return (0);
    }
    case_27___1: /* CIL Label */ 
    case_26___1: /* CIL Label */ 
    case_25___1: /* CIL Label */ 
    case_24___2: /* CIL Label */ 
    case_22___2: /* CIL Label */ 
#line 1161
    ptr += 2;
#line 1161
    goto switch_break___5;
    case_5___2: /* CIL Label */ 
#line 1161
    if (end - ptr < 2L) {
#line 1161
      return (-2);
    }
#line 1161
    *nextTokPtr = ptr;
#line 1161
    return (0);
#line 1161
    ptr += 2;
#line 1161
    goto switch_break___5;
    case_6___2: /* CIL Label */ 
#line 1161
    if (end - ptr < 3L) {
#line 1161
      return (-2);
    }
#line 1161
    *nextTokPtr = ptr;
#line 1161
    return (0);
#line 1161
    ptr += 3;
#line 1161
    goto switch_break___5;
    case_7___2: /* CIL Label */ 
#line 1161
    if (end - ptr < 4L) {
#line 1161
      return (-2);
    }
#line 1161
    *nextTokPtr = ptr;
#line 1161
    return (0);
#line 1161
    ptr += 4;
#line 1161
    goto switch_break___5;
    switch_default___1: /* CIL Label */ 
#line 1163
    tok = 19;
#line 1164
    goto switch_break___5;
    switch_break___5: /* CIL Label */ ;
    }
#line 1166
    goto switch_break___4;
    case_41: /* CIL Label */ 
#line 1168
    tok = 19;
#line 1169
    goto switch_break___4;
    switch_break___4: /* CIL Label */ ;
    }
#line 1171
    goto switch_break___3;
    case_34___0: /* CIL Label */ 
#line 1174
    if (tok == 19) {
#line 1175
      *nextTokPtr = ptr;
#line 1176
      return (0);
    }
#line 1178
    *nextTokPtr = ptr + 2;
#line 1179
    return (32);
    case_33___0: /* CIL Label */ 
#line 1181
    if (tok == 19) {
#line 1182
      *nextTokPtr = ptr;
#line 1183
      return (0);
    }
#line 1185
    *nextTokPtr = ptr + 2;
#line 1186
    return (31);
    case_15___1: /* CIL Label */ 
#line 1188
    if (tok == 19) {
#line 1189
      *nextTokPtr = ptr;
#line 1190
      return (0);
    }
#line 1192
    *nextTokPtr = ptr + 2;
#line 1193
    return (30);
    switch_default___2: /* CIL Label */ 
#line 1195
    *nextTokPtr = ptr;
#line 1196
    return (0);
    switch_break___3: /* CIL Label */ ;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1199
  return (- tok);
}
}
#line 1202 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmltok_impl.c"
static int big2_attributeValueTok___0(ENCODING const   *enc , char const   *ptr ,
                                      char const   *end , char const   **nextTokPtr ) 
{ 
  char const   *start ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 1207
  if ((unsigned long )ptr == (unsigned long )end) {
#line 1208
    return (-4);
  }
#line 1209
  start = ptr;
  {
#line 1210
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1210
    if (! ((unsigned long )ptr != (unsigned long )end)) {
#line 1210
      goto while_break;
    }
#line 1211
    if ((int const   )*(ptr + 0) == 0) {
#line 1211
      tmp___0 = (int )((struct normal_encoding *)enc)->type[(unsigned char )*(ptr + 1)];
    } else {
      {
#line 1211
      tmp = unicode_byte_type___0((char )*(ptr + 0), (char )*(ptr + 1));
#line 1211
      tmp___0 = tmp;
      }
    }
    {
#line 1214
    if (tmp___0 == 5) {
#line 1214
      goto case_5;
    }
#line 1214
    if (tmp___0 == 6) {
#line 1214
      goto case_6;
    }
#line 1214
    if (tmp___0 == 7) {
#line 1214
      goto case_7;
    }
#line 1216
    if (tmp___0 == 3) {
#line 1216
      goto case_3;
    }
#line 1221
    if (tmp___0 == 2) {
#line 1221
      goto case_2;
    }
#line 1225
    if (tmp___0 == 10) {
#line 1225
      goto case_10;
    }
#line 1232
    if (tmp___0 == 9) {
#line 1232
      goto case_9;
    }
#line 1244
    if (tmp___0 == 21) {
#line 1244
      goto case_21;
    }
#line 1251
    goto switch_default;
    case_5: /* CIL Label */ 
#line 1214
    ptr += 2;
#line 1214
    goto switch_break;
    case_6: /* CIL Label */ 
#line 1214
    ptr += 3;
#line 1214
    goto switch_break;
    case_7: /* CIL Label */ 
#line 1214
    ptr += 4;
#line 1214
    goto switch_break;
    case_3: /* CIL Label */ 
#line 1217
    if ((unsigned long )ptr == (unsigned long )start) {
      {
#line 1218
      tmp___1 = big2_scanRef___0(enc, ptr + 2, end, nextTokPtr);
      }
#line 1218
      return (tmp___1);
    }
#line 1219
    *nextTokPtr = ptr;
#line 1220
    return (6);
    case_2: /* CIL Label */ 
#line 1223
    *nextTokPtr = ptr;
#line 1224
    return (0);
    case_10: /* CIL Label */ 
#line 1226
    if ((unsigned long )ptr == (unsigned long )start) {
#line 1227
      *nextTokPtr = ptr + 2;
#line 1228
      return (7);
    }
#line 1230
    *nextTokPtr = ptr;
#line 1231
    return (6);
    case_9: /* CIL Label */ 
#line 1233
    if ((unsigned long )ptr == (unsigned long )start) {
#line 1234
      ptr += 2;
#line 1235
      if ((unsigned long )ptr == (unsigned long )end) {
#line 1236
        return (-3);
      }
#line 1237
      if ((int const   )*(ptr + 0) == 0) {
#line 1237
        tmp___3 = (int )((struct normal_encoding *)enc)->type[(unsigned char )*(ptr + 1)];
      } else {
        {
#line 1237
        tmp___2 = unicode_byte_type___0((char )*(ptr + 0), (char )*(ptr + 1));
#line 1237
        tmp___3 = tmp___2;
        }
      }
#line 1237
      if (tmp___3 == 10) {
#line 1238
        ptr += 2;
      }
#line 1239
      *nextTokPtr = ptr;
#line 1240
      return (7);
    }
#line 1242
    *nextTokPtr = ptr;
#line 1243
    return (6);
    case_21: /* CIL Label */ 
#line 1245
    if ((unsigned long )ptr == (unsigned long )start) {
#line 1246
      *nextTokPtr = ptr + 2;
#line 1247
      return (39);
    }
#line 1249
    *nextTokPtr = ptr;
#line 1250
    return (6);
    switch_default: /* CIL Label */ 
#line 1252
    ptr += 2;
#line 1253
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1256
  *nextTokPtr = ptr;
#line 1257
  return (6);
}
}
#line 1260 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmltok_impl.c"
static int big2_entityValueTok___0(ENCODING const   *enc , char const   *ptr , char const   *end ,
                                   char const   **nextTokPtr ) 
{ 
  char const   *start ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tok ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 1265
  if ((unsigned long )ptr == (unsigned long )end) {
#line 1266
    return (-4);
  }
#line 1267
  start = ptr;
  {
#line 1268
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1268
    if (! ((unsigned long )ptr != (unsigned long )end)) {
#line 1268
      goto while_break;
    }
#line 1269
    if ((int const   )*(ptr + 0) == 0) {
#line 1269
      tmp___0 = (int )((struct normal_encoding *)enc)->type[(unsigned char )*(ptr + 1)];
    } else {
      {
#line 1269
      tmp = unicode_byte_type___0((char )*(ptr + 0), (char )*(ptr + 1));
#line 1269
      tmp___0 = tmp;
      }
    }
    {
#line 1272
    if (tmp___0 == 5) {
#line 1272
      goto case_5;
    }
#line 1272
    if (tmp___0 == 6) {
#line 1272
      goto case_6;
    }
#line 1272
    if (tmp___0 == 7) {
#line 1272
      goto case_7;
    }
#line 1274
    if (tmp___0 == 3) {
#line 1274
      goto case_3;
    }
#line 1279
    if (tmp___0 == 30) {
#line 1279
      goto case_30;
    }
#line 1287
    if (tmp___0 == 10) {
#line 1287
      goto case_10;
    }
#line 1294
    if (tmp___0 == 9) {
#line 1294
      goto case_9;
    }
#line 1306
    goto switch_default;
    case_5: /* CIL Label */ 
#line 1272
    ptr += 2;
#line 1272
    goto switch_break;
    case_6: /* CIL Label */ 
#line 1272
    ptr += 3;
#line 1272
    goto switch_break;
    case_7: /* CIL Label */ 
#line 1272
    ptr += 4;
#line 1272
    goto switch_break;
    case_3: /* CIL Label */ 
#line 1275
    if ((unsigned long )ptr == (unsigned long )start) {
      {
#line 1276
      tmp___1 = big2_scanRef___0(enc, ptr + 2, end, nextTokPtr);
      }
#line 1276
      return (tmp___1);
    }
#line 1277
    *nextTokPtr = ptr;
#line 1278
    return (6);
    case_30: /* CIL Label */ 
#line 1280
    if ((unsigned long )ptr == (unsigned long )start) {
      {
#line 1281
      tmp___2 = big2_scanPercent___0(enc, ptr + 2, end, nextTokPtr);
#line 1281
      tok = tmp___2;
      }
#line 1283
      if (tok == 22) {
#line 1283
        tmp___3 = 0;
      } else {
#line 1283
        tmp___3 = tok;
      }
#line 1283
      return (tmp___3);
    }
#line 1285
    *nextTokPtr = ptr;
#line 1286
    return (6);
    case_10: /* CIL Label */ 
#line 1288
    if ((unsigned long )ptr == (unsigned long )start) {
#line 1289
      *nextTokPtr = ptr + 2;
#line 1290
      return (7);
    }
#line 1292
    *nextTokPtr = ptr;
#line 1293
    return (6);
    case_9: /* CIL Label */ 
#line 1295
    if ((unsigned long )ptr == (unsigned long )start) {
#line 1296
      ptr += 2;
#line 1297
      if ((unsigned long )ptr == (unsigned long )end) {
#line 1298
        return (-3);
      }
#line 1299
      if ((int const   )*(ptr + 0) == 0) {
#line 1299
        tmp___5 = (int )((struct normal_encoding *)enc)->type[(unsigned char )*(ptr + 1)];
      } else {
        {
#line 1299
        tmp___4 = unicode_byte_type___0((char )*(ptr + 0), (char )*(ptr + 1));
#line 1299
        tmp___5 = tmp___4;
        }
      }
#line 1299
      if (tmp___5 == 10) {
#line 1300
        ptr += 2;
      }
#line 1301
      *nextTokPtr = ptr;
#line 1302
      return (7);
    }
#line 1304
    *nextTokPtr = ptr;
#line 1305
    return (6);
    switch_default: /* CIL Label */ 
#line 1307
    ptr += 2;
#line 1308
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1311
  *nextTokPtr = ptr;
#line 1312
  return (6);
}
}
#line 1317 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmltok_impl.c"
static int big2_ignoreSectionTok___0(ENCODING const   *enc , char const   *ptr , char const   *end ,
                                     char const   **nextTokPtr ) 
{ 
  int level ;
  size_t n ;
  int tmp ;
  int tmp___0 ;

  {
#line 1321
  level = 0;
#line 1323
  n = (size_t )(end - ptr);
#line 1324
  if (n & 1UL) {
#line 1325
    n &= 0xfffffffffffffffeUL;
#line 1326
    end = ptr + n;
  }
  {
#line 1329
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1329
    if (! ((unsigned long )ptr != (unsigned long )end)) {
#line 1329
      goto while_break;
    }
#line 1330
    if ((int const   )*(ptr + 0) == 0) {
#line 1330
      tmp___0 = (int )((struct normal_encoding *)enc)->type[(unsigned char )*(ptr + 1)];
    } else {
      {
#line 1330
      tmp = unicode_byte_type___0((char )*(ptr + 0), (char )*(ptr + 1));
#line 1330
      tmp___0 = tmp;
      }
    }
    {
#line 1331
    if (tmp___0 == 5) {
#line 1331
      goto case_5;
    }
#line 1331
    if (tmp___0 == 6) {
#line 1331
      goto case_6;
    }
#line 1331
    if (tmp___0 == 7) {
#line 1331
      goto case_7;
    }
#line 1331
    if (tmp___0 == 8) {
#line 1331
      goto case_8;
    }
#line 1331
    if (tmp___0 == 1) {
#line 1331
      goto case_8;
    }
#line 1331
    if (tmp___0 == 0) {
#line 1331
      goto case_8;
    }
#line 1332
    if (tmp___0 == 2) {
#line 1332
      goto case_2;
    }
#line 1344
    if (tmp___0 == 4) {
#line 1344
      goto case_4;
    }
#line 1360
    goto switch_default;
    case_5: /* CIL Label */ 
#line 1331
    if (end - ptr < 2L) {
#line 1331
      return (-2);
    }
#line 1331
    ptr += 2;
#line 1331
    goto switch_break;
    case_6: /* CIL Label */ 
#line 1331
    if (end - ptr < 3L) {
#line 1331
      return (-2);
    }
#line 1331
    ptr += 3;
#line 1331
    goto switch_break;
    case_7: /* CIL Label */ 
#line 1331
    if (end - ptr < 4L) {
#line 1331
      return (-2);
    }
#line 1331
    ptr += 4;
#line 1331
    goto switch_break;
    case_8: /* CIL Label */ 
    case_1: /* CIL Label */ 
    case_0: /* CIL Label */ 
#line 1331
    *nextTokPtr = ptr;
#line 1331
    return (0);
    case_2: /* CIL Label */ 
#line 1333
    ptr += 2;
#line 1333
    if ((unsigned long )ptr == (unsigned long )end) {
#line 1334
      return (-1);
    }
#line 1335
    if ((int const   )*(ptr + 0) == 0) {
#line 1335
      if ((int const   )*(ptr + 1) == 33) {
#line 1336
        ptr += 2;
#line 1336
        if ((unsigned long )ptr == (unsigned long )end) {
#line 1337
          return (-1);
        }
#line 1338
        if ((int const   )*(ptr + 0) == 0) {
#line 1338
          if ((int const   )*(ptr + 1) == 91) {
#line 1339
            level ++;
#line 1340
            ptr += 2;
          }
        }
      }
    }
#line 1343
    goto switch_break;
    case_4: /* CIL Label */ 
#line 1345
    ptr += 2;
#line 1345
    if ((unsigned long )ptr == (unsigned long )end) {
#line 1346
      return (-1);
    }
#line 1347
    if ((int const   )*(ptr + 0) == 0) {
#line 1347
      if ((int const   )*(ptr + 1) == 93) {
#line 1348
        ptr += 2;
#line 1348
        if ((unsigned long )ptr == (unsigned long )end) {
#line 1349
          return (-1);
        }
#line 1350
        if ((int const   )*(ptr + 0) == 0) {
#line 1350
          if ((int const   )*(ptr + 1) == 62) {
#line 1351
            ptr += 2;
#line 1352
            if (level == 0) {
#line 1353
              *nextTokPtr = ptr;
#line 1354
              return (42);
            }
#line 1356
            level --;
          }
        }
      }
    }
#line 1359
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 1361
    ptr += 2;
#line 1362
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1365
  return (-1);
}
}
#line 1370 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmltok_impl.c"
static int big2_isPublicId___0(ENCODING const   *enc , char const   *ptr , char const   *end ,
                               char const   **badPtr ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 1374
  ptr += 2;
#line 1375
  end -= 2;
  {
#line 1376
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1376
    if (! ((unsigned long )ptr != (unsigned long )end)) {
#line 1376
      goto while_break;
    }
#line 1377
    if ((int const   )*(ptr + 0) == 0) {
#line 1377
      tmp___0 = (int )((struct normal_encoding *)enc)->type[(unsigned char )*(ptr + 1)];
    } else {
      {
#line 1377
      tmp = unicode_byte_type___0((char )*(ptr + 0), (char )*(ptr + 1));
#line 1377
      tmp___0 = tmp;
      }
    }
    {
#line 1397
    if (tmp___0 == 23) {
#line 1397
      goto case_23;
    }
#line 1397
    if (tmp___0 == 19) {
#line 1397
      goto case_23;
    }
#line 1397
    if (tmp___0 == 30) {
#line 1397
      goto case_23;
    }
#line 1397
    if (tmp___0 == 33) {
#line 1397
      goto case_23;
    }
#line 1397
    if (tmp___0 == 16) {
#line 1397
      goto case_23;
    }
#line 1397
    if (tmp___0 == 18) {
#line 1397
      goto case_23;
    }
#line 1397
    if (tmp___0 == 10) {
#line 1397
      goto case_23;
    }
#line 1397
    if (tmp___0 == 9) {
#line 1397
      goto case_23;
    }
#line 1397
    if (tmp___0 == 15) {
#line 1397
      goto case_23;
    }
#line 1397
    if (tmp___0 == 14) {
#line 1397
      goto case_23;
    }
#line 1397
    if (tmp___0 == 17) {
#line 1397
      goto case_23;
    }
#line 1397
    if (tmp___0 == 35) {
#line 1397
      goto case_23;
    }
#line 1397
    if (tmp___0 == 34) {
#line 1397
      goto case_23;
    }
#line 1397
    if (tmp___0 == 32) {
#line 1397
      goto case_23;
    }
#line 1397
    if (tmp___0 == 31) {
#line 1397
      goto case_23;
    }
#line 1397
    if (tmp___0 == 13) {
#line 1397
      goto case_23;
    }
#line 1397
    if (tmp___0 == 27) {
#line 1397
      goto case_23;
    }
#line 1397
    if (tmp___0 == 24) {
#line 1397
      goto case_23;
    }
#line 1397
    if (tmp___0 == 25) {
#line 1397
      goto case_23;
    }
#line 1400
    if (tmp___0 == 21) {
#line 1400
      goto case_21;
    }
#line 1407
    if (tmp___0 == 22) {
#line 1407
      goto case_22;
    }
#line 1407
    if (tmp___0 == 26) {
#line 1407
      goto case_22;
    }
#line 1410
    goto switch_default;
    case_23: /* CIL Label */ 
    case_19: /* CIL Label */ 
    case_30: /* CIL Label */ 
    case_33: /* CIL Label */ 
    case_16: /* CIL Label */ 
    case_18: /* CIL Label */ 
    case_10: /* CIL Label */ 
    case_9: /* CIL Label */ 
    case_15: /* CIL Label */ 
    case_14: /* CIL Label */ 
    case_17: /* CIL Label */ 
    case_35: /* CIL Label */ 
    case_34: /* CIL Label */ 
    case_32: /* CIL Label */ 
    case_31: /* CIL Label */ 
    case_13: /* CIL Label */ 
    case_27: /* CIL Label */ 
    case_24: /* CIL Label */ 
    case_25: /* CIL Label */ 
#line 1399
    goto switch_break;
    case_21: /* CIL Label */ 
#line 1401
    if ((int const   )*(ptr + 0) == 0) {
#line 1401
      if ((int const   )*(ptr + 1) == 9) {
#line 1402
        *badPtr = ptr;
#line 1403
        return (0);
      }
    }
#line 1405
    goto switch_break;
    case_22: /* CIL Label */ 
    case_26: /* CIL Label */ 
#line 1408
    if ((int const   )*(ptr + 0) == 0) {
#line 1408
      tmp___1 = (int const   )*(ptr + 1);
    } else {
#line 1408
      tmp___1 = (int const   )-1;
    }
#line 1408
    if (! (tmp___1 & -128)) {
#line 1409
      goto switch_break;
    }
    switch_default: /* CIL Label */ 
#line 1411
    if ((int const   )*(ptr + 0) == 0) {
#line 1411
      tmp___2 = (int const   )*(ptr + 1);
    } else {
#line 1411
      tmp___2 = (int const   )-1;
    }
    {
#line 1413
    if (tmp___2 == 64) {
#line 1413
      goto case_64;
    }
#line 1413
    if (tmp___2 == 36) {
#line 1413
      goto case_64;
    }
#line 1415
    goto switch_default___0;
    case_64: /* CIL Label */ 
    case_36: /* CIL Label */ 
#line 1414
    goto switch_break___0;
    switch_default___0: /* CIL Label */ 
#line 1416
    *badPtr = ptr;
#line 1417
    return (0);
    switch_break___0: /* CIL Label */ ;
    }
#line 1419
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 1376
    ptr += 2;
  }
  while_break: /* CIL Label */ ;
  }
#line 1422
  return (1);
}
}
#line 1430 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmltok_impl.c"
static int big2_getAtts___0(ENCODING const   *enc , char const   *ptr , int attsMax ,
                            ATTRIBUTE *atts ) 
{ 
  enum __anonenum_state_7___0 state ;
  int nAtts ;
  int open___0 ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 1434
  state = (enum __anonenum_state_7___0 )1;
#line 1435
  nAtts = 0;
#line 1436
  open___0 = 0;
#line 1439
  ptr += 2;
  {
#line 1439
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1440
    if ((int const   )*(ptr + 0) == 0) {
#line 1440
      tmp___0 = (int )((struct normal_encoding *)enc)->type[(unsigned char )*(ptr + 1)];
    } else {
      {
#line 1440
      tmp = unicode_byte_type___0((char )*(ptr + 0), (char )*(ptr + 1));
#line 1440
      tmp___0 = tmp;
      }
    }
    {
#line 1451
    if (tmp___0 == 5) {
#line 1451
      goto case_5;
    }
#line 1451
    if (tmp___0 == 6) {
#line 1451
      goto case_6;
    }
#line 1451
    if (tmp___0 == 7) {
#line 1451
      goto case_7;
    }
#line 1455
    if (tmp___0 == 24) {
#line 1455
      goto case_24;
    }
#line 1455
    if (tmp___0 == 22) {
#line 1455
      goto case_24;
    }
#line 1455
    if (tmp___0 == 29) {
#line 1455
      goto case_24;
    }
#line 1459
    if (tmp___0 == 12) {
#line 1459
      goto case_12;
    }
#line 1473
    if (tmp___0 == 13) {
#line 1473
      goto case_13;
    }
#line 1487
    if (tmp___0 == 3) {
#line 1487
      goto case_3;
    }
#line 1491
    if (tmp___0 == 21) {
#line 1491
      goto case_21;
    }
#line 1503
    if (tmp___0 == 10) {
#line 1503
      goto case_10;
    }
#line 1503
    if (tmp___0 == 9) {
#line 1503
      goto case_10;
    }
#line 1512
    if (tmp___0 == 17) {
#line 1512
      goto case_17;
    }
#line 1512
    if (tmp___0 == 11) {
#line 1512
      goto case_17;
    }
#line 1516
    goto switch_default;
    case_5: /* CIL Label */ 
#line 1451
    if ((unsigned int )state == 0U) {
#line 1451
      if (nAtts < attsMax) {
#line 1451
        (atts + nAtts)->name = ptr;
#line 1451
        (atts + nAtts)->normalized = (char)1;
      }
#line 1451
      state = (enum __anonenum_state_7___0 )1;
    }
#line 1451
    ptr += 0;
#line 1451
    goto switch_break;
    case_6: /* CIL Label */ 
#line 1451
    if ((unsigned int )state == 0U) {
#line 1451
      if (nAtts < attsMax) {
#line 1451
        (atts + nAtts)->name = ptr;
#line 1451
        (atts + nAtts)->normalized = (char)1;
      }
#line 1451
      state = (enum __anonenum_state_7___0 )1;
    }
#line 1451
    ptr ++;
#line 1451
    goto switch_break;
    case_7: /* CIL Label */ 
#line 1451
    if ((unsigned int )state == 0U) {
#line 1451
      if (nAtts < attsMax) {
#line 1451
        (atts + nAtts)->name = ptr;
#line 1451
        (atts + nAtts)->normalized = (char)1;
      }
#line 1451
      state = (enum __anonenum_state_7___0 )1;
    }
#line 1451
    ptr += 2;
#line 1451
    goto switch_break;
    case_24: /* CIL Label */ 
    case_22: /* CIL Label */ 
    case_29: /* CIL Label */ 
#line 1456
    if ((unsigned int )state == 0U) {
#line 1456
      if (nAtts < attsMax) {
#line 1456
        (atts + nAtts)->name = ptr;
#line 1456
        (atts + nAtts)->normalized = (char)1;
      }
#line 1456
      state = (enum __anonenum_state_7___0 )1;
    }
#line 1457
    goto switch_break;
    case_12: /* CIL Label */ 
#line 1460
    if ((unsigned int )state != 2U) {
#line 1461
      if (nAtts < attsMax) {
#line 1462
        (atts + nAtts)->valuePtr = ptr + 2;
      }
#line 1463
      state = (enum __anonenum_state_7___0 )2;
#line 1464
      open___0 = 12;
    } else
#line 1466
    if (open___0 == 12) {
#line 1467
      state = (enum __anonenum_state_7___0 )0;
#line 1468
      if (nAtts < attsMax) {
#line 1469
        (atts + nAtts)->valueEnd = ptr;
      }
#line 1470
      nAtts ++;
    }
#line 1472
    goto switch_break;
    case_13: /* CIL Label */ 
#line 1474
    if ((unsigned int )state != 2U) {
#line 1475
      if (nAtts < attsMax) {
#line 1476
        (atts + nAtts)->valuePtr = ptr + 2;
      }
#line 1477
      state = (enum __anonenum_state_7___0 )2;
#line 1478
      open___0 = 13;
    } else
#line 1480
    if (open___0 == 13) {
#line 1481
      state = (enum __anonenum_state_7___0 )0;
#line 1482
      if (nAtts < attsMax) {
#line 1483
        (atts + nAtts)->valueEnd = ptr;
      }
#line 1484
      nAtts ++;
    }
#line 1486
    goto switch_break;
    case_3: /* CIL Label */ 
#line 1488
    if (nAtts < attsMax) {
#line 1489
      (atts + nAtts)->normalized = (char)0;
    }
#line 1490
    goto switch_break;
    case_21: /* CIL Label */ 
#line 1492
    if ((unsigned int )state == 1U) {
#line 1493
      state = (enum __anonenum_state_7___0 )0;
    } else
#line 1494
    if ((unsigned int )state == 2U) {
#line 1494
      if (nAtts < attsMax) {
#line 1494
        if ((atts + nAtts)->normalized) {
#line 1494
          if ((unsigned long )ptr == (unsigned long )(atts + nAtts)->valuePtr) {
#line 1501
            (atts + nAtts)->normalized = (char)0;
          } else {
#line 1494
            if ((int const   )*(ptr + 0) == 0) {
#line 1494
              tmp___1 = (int const   )*(ptr + 1);
            } else {
#line 1494
              tmp___1 = (int const   )-1;
            }
#line 1494
            if (tmp___1 != 32) {
#line 1501
              (atts + nAtts)->normalized = (char)0;
            } else {
#line 1494
              if ((int const   )*((ptr + 2) + 0) == 0) {
#line 1494
                tmp___2 = (int const   )*((ptr + 2) + 1);
              } else {
#line 1494
                tmp___2 = (int const   )-1;
              }
#line 1494
              if (tmp___2 == 32) {
#line 1501
                (atts + nAtts)->normalized = (char)0;
              } else {
#line 1494
                if ((int const   )*((ptr + 2) + 0) == 0) {
#line 1494
                  tmp___4 = (int )((struct normal_encoding *)enc)->type[(unsigned char )*((ptr + 2) + 1)];
                } else {
                  {
#line 1494
                  tmp___3 = unicode_byte_type___0((char )*((ptr + 2) + 0), (char )*((ptr + 2) + 1));
#line 1494
                  tmp___4 = tmp___3;
                  }
                }
#line 1494
                if (tmp___4 == open___0) {
#line 1501
                  (atts + nAtts)->normalized = (char)0;
                }
              }
            }
          }
        }
      }
    }
#line 1502
    goto switch_break;
    case_10: /* CIL Label */ 
    case_9: /* CIL Label */ 
#line 1506
    if ((unsigned int )state == 1U) {
#line 1507
      state = (enum __anonenum_state_7___0 )0;
    } else
#line 1508
    if ((unsigned int )state == 2U) {
#line 1508
      if (nAtts < attsMax) {
#line 1509
        (atts + nAtts)->normalized = (char)0;
      }
    }
#line 1510
    goto switch_break;
    case_17: /* CIL Label */ 
    case_11: /* CIL Label */ 
#line 1513
    if ((unsigned int )state != 2U) {
#line 1514
      return (nAtts);
    }
#line 1515
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 1517
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 1439
    ptr += 2;
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 1523 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmltok_impl.c"
static int big2_charRefNumber___0(ENCODING const   *enc , char const   *ptr ) 
{ 
  int result ;
  int c___0 ;
  int tmp ;
  int c___1 ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 1526
  result = 0;
#line 1528
  ptr += 4;
#line 1529
  if ((int const   )*(ptr + 0) == 0) {
#line 1529
    if ((int const   )*(ptr + 1) == 120) {
#line 1530
      ptr += 2;
      {
#line 1530
      while (1) {
        while_continue: /* CIL Label */ ;
#line 1530
        if ((int const   )*(ptr + 0) == 0) {
#line 1530
          if ((int const   )*(ptr + 1) == 59) {
#line 1530
            goto while_break;
          }
        }
#line 1533
        if ((int const   )*(ptr + 0) == 0) {
#line 1533
          tmp = (int const   )*(ptr + 1);
        } else {
#line 1533
          tmp = (int const   )-1;
        }
#line 1533
        c___0 = (int )tmp;
        {
#line 1536
        if (c___0 == 57) {
#line 1536
          goto case_57;
        }
#line 1536
        if (c___0 == 56) {
#line 1536
          goto case_57;
        }
#line 1536
        if (c___0 == 55) {
#line 1536
          goto case_57;
        }
#line 1536
        if (c___0 == 54) {
#line 1536
          goto case_57;
        }
#line 1536
        if (c___0 == 53) {
#line 1536
          goto case_57;
        }
#line 1536
        if (c___0 == 52) {
#line 1536
          goto case_57;
        }
#line 1536
        if (c___0 == 51) {
#line 1536
          goto case_57;
        }
#line 1536
        if (c___0 == 50) {
#line 1536
          goto case_57;
        }
#line 1536
        if (c___0 == 49) {
#line 1536
          goto case_57;
        }
#line 1536
        if (c___0 == 48) {
#line 1536
          goto case_57;
        }
#line 1541
        if (c___0 == 70) {
#line 1541
          goto case_70;
        }
#line 1541
        if (c___0 == 69) {
#line 1541
          goto case_70;
        }
#line 1541
        if (c___0 == 68) {
#line 1541
          goto case_70;
        }
#line 1541
        if (c___0 == 67) {
#line 1541
          goto case_70;
        }
#line 1541
        if (c___0 == 66) {
#line 1541
          goto case_70;
        }
#line 1541
        if (c___0 == 65) {
#line 1541
          goto case_70;
        }
#line 1546
        if (c___0 == 102) {
#line 1546
          goto case_102;
        }
#line 1546
        if (c___0 == 101) {
#line 1546
          goto case_102;
        }
#line 1546
        if (c___0 == 100) {
#line 1546
          goto case_102;
        }
#line 1546
        if (c___0 == 99) {
#line 1546
          goto case_102;
        }
#line 1546
        if (c___0 == 98) {
#line 1546
          goto case_102;
        }
#line 1546
        if (c___0 == 97) {
#line 1546
          goto case_102;
        }
#line 1534
        goto switch_break;
        case_57: /* CIL Label */ 
        case_56: /* CIL Label */ 
        case_55: /* CIL Label */ 
        case_54: /* CIL Label */ 
        case_53: /* CIL Label */ 
        case_52: /* CIL Label */ 
        case_51: /* CIL Label */ 
        case_50: /* CIL Label */ 
        case_49: /* CIL Label */ 
        case_48: /* CIL Label */ 
#line 1537
        result <<= 4;
#line 1538
        result |= c___0 - 48;
#line 1539
        goto switch_break;
        case_70: /* CIL Label */ 
        case_69: /* CIL Label */ 
        case_68: /* CIL Label */ 
        case_67: /* CIL Label */ 
        case_66: /* CIL Label */ 
        case_65: /* CIL Label */ 
#line 1542
        result <<= 4;
#line 1543
        result += 10 + (c___0 - 65);
#line 1544
        goto switch_break;
        case_102: /* CIL Label */ 
        case_101: /* CIL Label */ 
        case_100: /* CIL Label */ 
        case_99: /* CIL Label */ 
        case_98: /* CIL Label */ 
        case_97: /* CIL Label */ 
#line 1547
        result <<= 4;
#line 1548
        result += 10 + (c___0 - 97);
#line 1549
        goto switch_break;
        switch_break: /* CIL Label */ ;
        }
#line 1551
        if (result >= 1114112) {
#line 1552
          return (-1);
        }
#line 1530
        ptr += 2;
      }
      while_break: /* CIL Label */ ;
      }
    } else {
#line 1529
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
    {
#line 1556
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1556
      if ((int const   )*(ptr + 0) == 0) {
#line 1556
        if ((int const   )*(ptr + 1) == 59) {
#line 1556
          goto while_break___0;
        }
      }
#line 1557
      if ((int const   )*(ptr + 0) == 0) {
#line 1557
        tmp___0 = (int const   )*(ptr + 1);
      } else {
#line 1557
        tmp___0 = (int const   )-1;
      }
#line 1557
      c___1 = (int )tmp___0;
#line 1558
      result *= 10;
#line 1559
      result += c___1 - 48;
#line 1560
      if (result >= 1114112) {
#line 1561
        return (-1);
      }
#line 1556
      ptr += 2;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  {
#line 1564
  tmp___1 = checkCharRefNumber___0(result);
  }
#line 1564
  return (tmp___1);
}
}
#line 1567 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmltok_impl.c"
static int big2_predefinedEntityName___0(ENCODING const   *enc , char const   *ptr ,
                                         char const   *end ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  {
#line 1572
  if ((end - ptr) / 2L == 2L) {
#line 1572
    goto case_2;
  }
#line 1582
  if ((end - ptr) / 2L == 3L) {
#line 1582
    goto case_3;
  }
#line 1592
  if ((end - ptr) / 2L == 4L) {
#line 1592
    goto case_4;
  }
#line 1571
  goto switch_break;
  case_2: /* CIL Label */ 
#line 1573
  if ((int const   )*((ptr + 2) + 0) == 0) {
#line 1573
    if ((int const   )*((ptr + 2) + 1) == 116) {
#line 1574
      if ((int const   )*(ptr + 0) == 0) {
#line 1574
        tmp = (int const   )*(ptr + 1);
      } else {
#line 1574
        tmp = (int const   )-1;
      }
      {
#line 1575
      if (tmp == 108) {
#line 1575
        goto case_108;
      }
#line 1577
      if (tmp == 103) {
#line 1577
        goto case_103;
      }
#line 1574
      goto switch_break___0;
      case_108: /* CIL Label */ 
#line 1576
      return (60);
      case_103: /* CIL Label */ 
#line 1578
      return (62);
      switch_break___0: /* CIL Label */ ;
      }
    }
  }
#line 1581
  goto switch_break;
  case_3: /* CIL Label */ 
#line 1583
  if ((int const   )*(ptr + 0) == 0) {
#line 1583
    if ((int const   )*(ptr + 1) == 97) {
#line 1584
      ptr += 2;
#line 1585
      if ((int const   )*(ptr + 0) == 0) {
#line 1585
        if ((int const   )*(ptr + 1) == 109) {
#line 1586
          ptr += 2;
#line 1587
          if ((int const   )*(ptr + 0) == 0) {
#line 1587
            if ((int const   )*(ptr + 1) == 112) {
#line 1588
              return (38);
            }
          }
        }
      }
    }
  }
#line 1591
  goto switch_break;
  case_4: /* CIL Label */ 
#line 1593
  if ((int const   )*(ptr + 0) == 0) {
#line 1593
    tmp___0 = (int const   )*(ptr + 1);
  } else {
#line 1593
    tmp___0 = (int const   )-1;
  }
  {
#line 1594
  if (tmp___0 == 113) {
#line 1594
    goto case_113;
  }
#line 1605
  if (tmp___0 == 97) {
#line 1605
    goto case_97;
  }
#line 1593
  goto switch_break___1;
  case_113: /* CIL Label */ 
#line 1595
  ptr += 2;
#line 1596
  if ((int const   )*(ptr + 0) == 0) {
#line 1596
    if ((int const   )*(ptr + 1) == 117) {
#line 1597
      ptr += 2;
#line 1598
      if ((int const   )*(ptr + 0) == 0) {
#line 1598
        if ((int const   )*(ptr + 1) == 111) {
#line 1599
          ptr += 2;
#line 1600
          if ((int const   )*(ptr + 0) == 0) {
#line 1600
            if ((int const   )*(ptr + 1) == 116) {
#line 1601
              return (34);
            }
          }
        }
      }
    }
  }
#line 1604
  goto switch_break___1;
  case_97: /* CIL Label */ 
#line 1606
  ptr += 2;
#line 1607
  if ((int const   )*(ptr + 0) == 0) {
#line 1607
    if ((int const   )*(ptr + 1) == 112) {
#line 1608
      ptr += 2;
#line 1609
      if ((int const   )*(ptr + 0) == 0) {
#line 1609
        if ((int const   )*(ptr + 1) == 111) {
#line 1610
          ptr += 2;
#line 1611
          if ((int const   )*(ptr + 0) == 0) {
#line 1611
            if ((int const   )*(ptr + 1) == 115) {
#line 1612
              return (39);
            }
          }
        }
      }
    }
  }
#line 1615
  goto switch_break___1;
  switch_break___1: /* CIL Label */ ;
  }
  switch_break: /* CIL Label */ ;
  }
#line 1618
  return (0);
}
}
#line 1621 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmltok_impl.c"
static int big2_sameName___0(ENCODING const   *enc , char const   *ptr1 , char const   *ptr2 ) 
{ 
  int tmp ;
  int tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;
  char const   *tmp___4 ;
  char const   *tmp___5 ;
  char const   *tmp___6 ;
  char const   *tmp___7 ;
  char const   *tmp___8 ;
  char const   *tmp___9 ;
  char const   *tmp___10 ;
  char const   *tmp___11 ;
  char const   *tmp___12 ;
  int tmp___17 ;
  int tmp___18 ;

  {
  {
#line 1624
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1625
    if ((int const   )*(ptr1 + 0) == 0) {
#line 1625
      tmp___0 = (int )((struct normal_encoding *)enc)->type[(unsigned char )*(ptr1 + 1)];
    } else {
      {
#line 1625
      tmp = unicode_byte_type___0((char )*(ptr1 + 0), (char )*(ptr1 + 1));
#line 1625
      tmp___0 = tmp;
      }
    }
    {
#line 1630
    if (tmp___0 == 7) {
#line 1630
      goto case_7;
    }
#line 1630
    if (tmp___0 == 6) {
#line 1630
      goto case_6;
    }
#line 1630
    if (tmp___0 == 5) {
#line 1630
      goto case_5;
    }
#line 1644
    if (tmp___0 == 27) {
#line 1644
      goto case_27;
    }
#line 1644
    if (tmp___0 == 26) {
#line 1644
      goto case_27;
    }
#line 1644
    if (tmp___0 == 25) {
#line 1644
      goto case_27;
    }
#line 1644
    if (tmp___0 == 24) {
#line 1644
      goto case_27;
    }
#line 1644
    if (tmp___0 == 23) {
#line 1644
      goto case_27;
    }
#line 1644
    if (tmp___0 == 22) {
#line 1644
      goto case_27;
    }
#line 1644
    if (tmp___0 == 29) {
#line 1644
      goto case_27;
    }
#line 1660
    goto switch_default;
    case_7: /* CIL Label */ 
#line 1630
    tmp___1 = ptr1;
#line 1630
    ptr1 ++;
#line 1630
    tmp___2 = ptr2;
#line 1630
    ptr2 ++;
#line 1630
    if ((int const   )*tmp___1 != (int const   )*tmp___2) {
#line 1630
      return (0);
    }
    case_6: /* CIL Label */ 
#line 1630
    tmp___3 = ptr1;
#line 1630
    ptr1 ++;
#line 1630
    tmp___4 = ptr2;
#line 1630
    ptr2 ++;
#line 1630
    if ((int const   )*tmp___3 != (int const   )*tmp___4) {
#line 1630
      return (0);
    }
    case_5: /* CIL Label */ 
#line 1630
    tmp___5 = ptr1;
#line 1630
    ptr1 ++;
#line 1630
    tmp___6 = ptr2;
#line 1630
    ptr2 ++;
#line 1630
    if ((int const   )*tmp___5 != (int const   )*tmp___6) {
#line 1630
      return (0);
    }
#line 1633
    tmp___7 = ptr1;
#line 1633
    ptr1 ++;
#line 1633
    tmp___8 = ptr2;
#line 1633
    ptr2 ++;
#line 1633
    if ((int const   )*tmp___7 != (int const   )*tmp___8) {
#line 1634
      return (0);
    }
#line 1635
    goto switch_break;
    case_27: /* CIL Label */ 
    case_26: /* CIL Label */ 
    case_25: /* CIL Label */ 
    case_24: /* CIL Label */ 
    case_23: /* CIL Label */ 
    case_22: /* CIL Label */ 
    case_29: /* CIL Label */ 
#line 1645
    tmp___9 = ptr2;
#line 1645
    ptr2 ++;
#line 1645
    tmp___10 = ptr1;
#line 1645
    ptr1 ++;
#line 1645
    if ((int const   )*tmp___9 != (int const   )*tmp___10) {
#line 1646
      return (0);
    }
#line 1648
    tmp___11 = ptr2;
#line 1648
    ptr2 ++;
#line 1648
    tmp___12 = ptr1;
#line 1648
    ptr1 ++;
#line 1648
    if ((int const   )*tmp___11 != (int const   )*tmp___12) {
#line 1649
      return (0);
    }
#line 1659
    goto switch_break;
    switch_default: /* CIL Label */ ;
#line 1663
    if ((int const   )*(ptr2 + 0) == 0) {
#line 1663
      tmp___18 = (int )((struct normal_encoding *)enc)->type[(unsigned char )*(ptr2 + 1)];
    } else {
      {
#line 1663
      tmp___17 = unicode_byte_type___0((char )*(ptr2 + 0), (char )*(ptr2 + 1));
#line 1663
      tmp___18 = tmp___17;
      }
    }
    {
#line 1675
    if (tmp___18 == 27) {
#line 1675
      goto case_27___0;
    }
#line 1675
    if (tmp___18 == 26) {
#line 1675
      goto case_27___0;
    }
#line 1675
    if (tmp___18 == 25) {
#line 1675
      goto case_27___0;
    }
#line 1675
    if (tmp___18 == 24) {
#line 1675
      goto case_27___0;
    }
#line 1675
    if (tmp___18 == 23) {
#line 1675
      goto case_27___0;
    }
#line 1675
    if (tmp___18 == 22) {
#line 1675
      goto case_27___0;
    }
#line 1675
    if (tmp___18 == 29) {
#line 1675
      goto case_27___0;
    }
#line 1675
    if (tmp___18 == 7) {
#line 1675
      goto case_27___0;
    }
#line 1675
    if (tmp___18 == 6) {
#line 1675
      goto case_27___0;
    }
#line 1675
    if (tmp___18 == 5) {
#line 1675
      goto case_27___0;
    }
#line 1677
    goto switch_default___0;
    case_27___0: /* CIL Label */ 
    case_26___0: /* CIL Label */ 
    case_25___0: /* CIL Label */ 
    case_24___0: /* CIL Label */ 
    case_23___0: /* CIL Label */ 
    case_22___0: /* CIL Label */ 
    case_29___0: /* CIL Label */ 
    case_7___0: /* CIL Label */ 
    case_6___0: /* CIL Label */ 
    case_5___0: /* CIL Label */ 
#line 1676
    return (0);
    switch_default___0: /* CIL Label */ 
#line 1678
    return (1);
    switch_break___0: /* CIL Label */ ;
    }
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 1685 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmltok_impl.c"
static int big2_nameMatchesAscii___0(ENCODING const   *enc , char const   *ptr1 ,
                                     char const   *end1 , char const   *ptr2 ) 
{ 


  {
  {
#line 1689
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1689
    if (! *ptr2) {
#line 1689
      goto while_break;
    }
#line 1690
    if ((unsigned long )ptr1 == (unsigned long )end1) {
#line 1691
      return (0);
    }
#line 1692
    if ((int const   )*(ptr1 + 0) == 0) {
#line 1692
      if (! ((int const   )*(ptr1 + 1) == (int const   )*ptr2)) {
#line 1693
        return (0);
      }
    } else {
#line 1693
      return (0);
    }
#line 1689
    ptr1 += 2;
#line 1689
    ptr2 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1695
  return ((unsigned long )ptr1 == (unsigned long )end1);
}
}
#line 1698 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmltok_impl.c"
static int big2_nameLength___0(ENCODING const   *enc , char const   *ptr ) 
{ 
  char const   *start ;
  int tmp ;
  int tmp___0 ;

  {
#line 1701
  start = ptr;
  {
#line 1702
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1703
    if ((int const   )*(ptr + 0) == 0) {
#line 1703
      tmp___0 = (int )((struct normal_encoding *)enc)->type[(unsigned char )*(ptr + 1)];
    } else {
      {
#line 1703
      tmp = unicode_byte_type___0((char )*(ptr + 0), (char )*(ptr + 1));
#line 1703
      tmp___0 = tmp;
      }
    }
    {
#line 1706
    if (tmp___0 == 5) {
#line 1706
      goto case_5;
    }
#line 1706
    if (tmp___0 == 6) {
#line 1706
      goto case_6;
    }
#line 1706
    if (tmp___0 == 7) {
#line 1706
      goto case_7;
    }
#line 1716
    if (tmp___0 == 27) {
#line 1716
      goto case_27;
    }
#line 1716
    if (tmp___0 == 26) {
#line 1716
      goto case_27;
    }
#line 1716
    if (tmp___0 == 25) {
#line 1716
      goto case_27;
    }
#line 1716
    if (tmp___0 == 24) {
#line 1716
      goto case_27;
    }
#line 1716
    if (tmp___0 == 23) {
#line 1716
      goto case_27;
    }
#line 1716
    if (tmp___0 == 22) {
#line 1716
      goto case_27;
    }
#line 1716
    if (tmp___0 == 29) {
#line 1716
      goto case_27;
    }
#line 1719
    goto switch_default;
    case_5: /* CIL Label */ 
#line 1706
    ptr += 2;
#line 1706
    goto switch_break;
    case_6: /* CIL Label */ 
#line 1706
    ptr += 3;
#line 1706
    goto switch_break;
    case_7: /* CIL Label */ 
#line 1706
    ptr += 4;
#line 1706
    goto switch_break;
    case_27: /* CIL Label */ 
    case_26: /* CIL Label */ 
    case_25: /* CIL Label */ 
    case_24: /* CIL Label */ 
    case_23: /* CIL Label */ 
    case_22: /* CIL Label */ 
    case_29: /* CIL Label */ 
#line 1717
    ptr += 2;
#line 1718
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 1720
    return ((int )(ptr - start));
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 1725 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmltok_impl.c"
static char const   *big2_skipS___0(ENCODING const   *enc , char const   *ptr ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  {
#line 1728
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1729
    if ((int const   )*(ptr + 0) == 0) {
#line 1729
      tmp___0 = (int )((struct normal_encoding *)enc)->type[(unsigned char )*(ptr + 1)];
    } else {
      {
#line 1729
      tmp = unicode_byte_type___0((char )*(ptr + 0), (char )*(ptr + 1));
#line 1729
      tmp___0 = tmp;
      }
    }
    {
#line 1732
    if (tmp___0 == 21) {
#line 1732
      goto case_21;
    }
#line 1732
    if (tmp___0 == 9) {
#line 1732
      goto case_21;
    }
#line 1732
    if (tmp___0 == 10) {
#line 1732
      goto case_21;
    }
#line 1735
    goto switch_default;
    case_21: /* CIL Label */ 
    case_9: /* CIL Label */ 
    case_10: /* CIL Label */ 
#line 1733
    ptr += 2;
#line 1734
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 1736
    return (ptr);
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 1741 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmltok_impl.c"
static void big2_updatePosition___0(ENCODING const   *enc , char const   *ptr , char const   *end ,
                                    POSITION *pos ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 1747
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1747
    if (! ((unsigned long )ptr < (unsigned long )end)) {
#line 1747
      goto while_break;
    }
#line 1748
    if ((int const   )*(ptr + 0) == 0) {
#line 1748
      tmp___0 = (int )((struct normal_encoding *)enc)->type[(unsigned char )*(ptr + 1)];
    } else {
      {
#line 1748
      tmp = unicode_byte_type___0((char )*(ptr + 0), (char )*(ptr + 1));
#line 1748
      tmp___0 = tmp;
      }
    }
    {
#line 1753
    if (tmp___0 == 5) {
#line 1753
      goto case_5;
    }
#line 1753
    if (tmp___0 == 6) {
#line 1753
      goto case_6;
    }
#line 1753
    if (tmp___0 == 7) {
#line 1753
      goto case_7;
    }
#line 1755
    if (tmp___0 == 10) {
#line 1755
      goto case_10;
    }
#line 1760
    if (tmp___0 == 9) {
#line 1760
      goto case_9;
    }
#line 1767
    goto switch_default;
    case_5: /* CIL Label */ 
#line 1753
    ptr += 2;
#line 1753
    goto switch_break;
    case_6: /* CIL Label */ 
#line 1753
    ptr += 3;
#line 1753
    goto switch_break;
    case_7: /* CIL Label */ 
#line 1753
    ptr += 4;
#line 1753
    goto switch_break;
    case_10: /* CIL Label */ 
#line 1756
    pos->columnNumber = (XML_Size )-1;
#line 1757
    (pos->lineNumber) ++;
#line 1758
    ptr += 2;
#line 1759
    goto switch_break;
    case_9: /* CIL Label */ 
#line 1761
    (pos->lineNumber) ++;
#line 1762
    ptr += 2;
#line 1763
    if ((unsigned long )ptr != (unsigned long )end) {
#line 1763
      if ((int const   )*(ptr + 0) == 0) {
#line 1763
        tmp___2 = (int )((struct normal_encoding *)enc)->type[(unsigned char )*(ptr + 1)];
      } else {
        {
#line 1763
        tmp___1 = unicode_byte_type___0((char )*(ptr + 0), (char )*(ptr + 1));
#line 1763
        tmp___2 = tmp___1;
        }
      }
#line 1763
      if (tmp___2 == 10) {
#line 1764
        ptr += 2;
      }
    }
#line 1765
    pos->columnNumber = (XML_Size )-1;
#line 1766
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 1768
    ptr += 2;
#line 1769
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 1771
    (pos->columnNumber) ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1773
  return;
}
}
#line 858 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmltok.c"
static struct normal_encoding  const  big2_encoding_ns___0  = 
#line 858 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmltok.c"
     {{{& big2_prologTok___0, & big2_contentTok___0, & big2_cdataSectionTok___0, & big2_ignoreSectionTok___0},
     {& big2_attributeValueTok___0, & big2_entityValueTok___0}, & big2_sameName___0,
     & big2_nameMatchesAscii___0, & big2_nameLength___0, & big2_skipS___0, & big2_getAtts___0,
     & big2_charRefNumber___0, & big2_predefinedEntityName___0, & big2_updatePosition___0,
     & big2_isPublicId___0, & big2_toUtf8___0, & big2_toUtf16___0, 2, (char)0, (char)0},
    {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
     (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)21,
     (unsigned char)10, (unsigned char)0, (unsigned char)0, (unsigned char)9, (unsigned char)0,
     (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
     (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
     (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
     (unsigned char)0, (unsigned char)0, (unsigned char)21, (unsigned char)16, (unsigned char)12,
     (unsigned char)19, (unsigned char)28, (unsigned char)30, (unsigned char)3, (unsigned char)13,
     (unsigned char)31, (unsigned char)32, (unsigned char)33, (unsigned char)34, (unsigned char)35,
     (unsigned char)27, (unsigned char)26, (unsigned char)17, (unsigned char)25, (unsigned char)25,
     (unsigned char)25, (unsigned char)25, (unsigned char)25, (unsigned char)25, (unsigned char)25,
     (unsigned char)25, (unsigned char)25, (unsigned char)25, (unsigned char)23, (unsigned char)18,
     (unsigned char)2, (unsigned char)14, (unsigned char)11, (unsigned char)15, (unsigned char)28,
     (unsigned char)24, (unsigned char)24, (unsigned char)24, (unsigned char)24, (unsigned char)24,
     (unsigned char)24, (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22,
     (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22,
     (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22,
     (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22,
     (unsigned char)22, (unsigned char)20, (unsigned char)28, (unsigned char)4, (unsigned char)28,
     (unsigned char)22, (unsigned char)28, (unsigned char)24, (unsigned char)24, (unsigned char)24,
     (unsigned char)24, (unsigned char)24, (unsigned char)24, (unsigned char)22, (unsigned char)22,
     (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22,
     (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22,
     (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22,
     (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)28, (unsigned char)36,
     (unsigned char)28, (unsigned char)28, (unsigned char)28, (unsigned char)28, (unsigned char)28,
     (unsigned char)28, (unsigned char)28, (unsigned char)28, (unsigned char)28, (unsigned char)28,
     (unsigned char)28, (unsigned char)28, (unsigned char)28, (unsigned char)28, (unsigned char)28,
     (unsigned char)28, (unsigned char)28, (unsigned char)28, (unsigned char)28, (unsigned char)28,
     (unsigned char)28, (unsigned char)28, (unsigned char)28, (unsigned char)28, (unsigned char)28,
     (unsigned char)28, (unsigned char)28, (unsigned char)28, (unsigned char)28, (unsigned char)28,
     (unsigned char)28, (unsigned char)28, (unsigned char)28, (unsigned char)28, (unsigned char)28,
     (unsigned char)28, (unsigned char)28, (unsigned char)28, (unsigned char)28, (unsigned char)28,
     (unsigned char)28, (unsigned char)28, (unsigned char)28, (unsigned char)28, (unsigned char)28,
     (unsigned char)22, (unsigned char)28, (unsigned char)28, (unsigned char)28, (unsigned char)28,
     (unsigned char)28, (unsigned char)28, (unsigned char)28, (unsigned char)28, (unsigned char)28,
     (unsigned char)28, (unsigned char)22, (unsigned char)28, (unsigned char)26, (unsigned char)28,
     (unsigned char)28, (unsigned char)22, (unsigned char)28, (unsigned char)28, (unsigned char)28,
     (unsigned char)28, (unsigned char)28, (unsigned char)22, (unsigned char)22, (unsigned char)22,
     (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22,
     (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22,
     (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22,
     (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22,
     (unsigned char)28, (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22,
     (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22,
     (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22,
     (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22,
     (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22,
     (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22,
     (unsigned char)22, (unsigned char)22, (unsigned char)28, (unsigned char)22, (unsigned char)22,
     (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22,
     (unsigned char)22}, (int (*)(ENCODING const   * , char const   * ))0, (int (*)(ENCODING const   * ,
                                                                                    char const   * ))0,
    (int (*)(ENCODING const   * , char const   * ))0, (int (*)(ENCODING const   * ,
                                                               char const   * ))0,
    (int (*)(ENCODING const   * , char const   * ))0, (int (*)(ENCODING const   * ,
                                                               char const   * ))0,
    (int (*)(ENCODING const   * , char const   * ))0, (int (*)(ENCODING const   * ,
                                                               char const   * ))0,
    (int (*)(ENCODING const   * , char const   * ))0};
#line 875 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmltok.c"
static struct normal_encoding  const  big2_encoding___0  = 
#line 875
     {{{& big2_prologTok___0, & big2_contentTok___0, & big2_cdataSectionTok___0, & big2_ignoreSectionTok___0},
     {& big2_attributeValueTok___0, & big2_entityValueTok___0}, & big2_sameName___0,
     & big2_nameMatchesAscii___0, & big2_nameLength___0, & big2_skipS___0, & big2_getAtts___0,
     & big2_charRefNumber___0, & big2_predefinedEntityName___0, & big2_updatePosition___0,
     & big2_isPublicId___0, & big2_toUtf8___0, & big2_toUtf16___0, 2, (char)0, (char)0},
    {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
     (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)21,
     (unsigned char)10, (unsigned char)0, (unsigned char)0, (unsigned char)9, (unsigned char)0,
     (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
     (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
     (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
     (unsigned char)0, (unsigned char)0, (unsigned char)21, (unsigned char)16, (unsigned char)12,
     (unsigned char)19, (unsigned char)28, (unsigned char)30, (unsigned char)3, (unsigned char)13,
     (unsigned char)31, (unsigned char)32, (unsigned char)33, (unsigned char)34, (unsigned char)35,
     (unsigned char)27, (unsigned char)26, (unsigned char)17, (unsigned char)25, (unsigned char)25,
     (unsigned char)25, (unsigned char)25, (unsigned char)25, (unsigned char)25, (unsigned char)25,
     (unsigned char)25, (unsigned char)25, (unsigned char)25, (unsigned char)22, (unsigned char)18,
     (unsigned char)2, (unsigned char)14, (unsigned char)11, (unsigned char)15, (unsigned char)28,
     (unsigned char)24, (unsigned char)24, (unsigned char)24, (unsigned char)24, (unsigned char)24,
     (unsigned char)24, (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22,
     (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22,
     (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22,
     (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22,
     (unsigned char)22, (unsigned char)20, (unsigned char)28, (unsigned char)4, (unsigned char)28,
     (unsigned char)22, (unsigned char)28, (unsigned char)24, (unsigned char)24, (unsigned char)24,
     (unsigned char)24, (unsigned char)24, (unsigned char)24, (unsigned char)22, (unsigned char)22,
     (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22,
     (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22,
     (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22,
     (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)28, (unsigned char)36,
     (unsigned char)28, (unsigned char)28, (unsigned char)28, (unsigned char)28, (unsigned char)28,
     (unsigned char)28, (unsigned char)28, (unsigned char)28, (unsigned char)28, (unsigned char)28,
     (unsigned char)28, (unsigned char)28, (unsigned char)28, (unsigned char)28, (unsigned char)28,
     (unsigned char)28, (unsigned char)28, (unsigned char)28, (unsigned char)28, (unsigned char)28,
     (unsigned char)28, (unsigned char)28, (unsigned char)28, (unsigned char)28, (unsigned char)28,
     (unsigned char)28, (unsigned char)28, (unsigned char)28, (unsigned char)28, (unsigned char)28,
     (unsigned char)28, (unsigned char)28, (unsigned char)28, (unsigned char)28, (unsigned char)28,
     (unsigned char)28, (unsigned char)28, (unsigned char)28, (unsigned char)28, (unsigned char)28,
     (unsigned char)28, (unsigned char)28, (unsigned char)28, (unsigned char)28, (unsigned char)28,
     (unsigned char)22, (unsigned char)28, (unsigned char)28, (unsigned char)28, (unsigned char)28,
     (unsigned char)28, (unsigned char)28, (unsigned char)28, (unsigned char)28, (unsigned char)28,
     (unsigned char)28, (unsigned char)22, (unsigned char)28, (unsigned char)26, (unsigned char)28,
     (unsigned char)28, (unsigned char)22, (unsigned char)28, (unsigned char)28, (unsigned char)28,
     (unsigned char)28, (unsigned char)28, (unsigned char)22, (unsigned char)22, (unsigned char)22,
     (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22,
     (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22,
     (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22,
     (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22,
     (unsigned char)28, (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22,
     (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22,
     (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22,
     (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22,
     (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22,
     (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22,
     (unsigned char)22, (unsigned char)22, (unsigned char)28, (unsigned char)22, (unsigned char)22,
     (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22, (unsigned char)22,
     (unsigned char)22}, (int (*)(ENCODING const   * , char const   * ))0, (int (*)(ENCODING const   * ,
                                                                                    char const   * ))0,
    (int (*)(ENCODING const   * , char const   * ))0, (int (*)(ENCODING const   * ,
                                                               char const   * ))0,
    (int (*)(ENCODING const   * , char const   * ))0, (int (*)(ENCODING const   * ,
                                                               char const   * ))0,
    (int (*)(ENCODING const   * , char const   * ))0, (int (*)(ENCODING const   * ,
                                                               char const   * ))0,
    (int (*)(ENCODING const   * , char const   * ))0};
#line 922 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmltok.c"
static int streqci___0(char const   *s1 , char const   *s2 ) 
{ 
  char c1 ;
  char const   *tmp ;
  char c2 ;
  char const   *tmp___0 ;

  {
  {
#line 925
  while (1) {
    while_continue: /* CIL Label */ ;
#line 926
    tmp = s1;
#line 926
    s1 ++;
#line 926
    c1 = (char )*tmp;
#line 927
    tmp___0 = s2;
#line 927
    s2 ++;
#line 927
    c2 = (char )*tmp___0;
#line 928
    if (97 <= (int )c1) {
#line 928
      if ((int )c1 <= 122) {
#line 929
        c1 = (char )((int )c1 + -32);
      }
    }
#line 930
    if (97 <= (int )c2) {
#line 930
      if ((int )c2 <= 122) {
#line 931
        c2 = (char )((int )c2 + -32);
      }
    }
#line 932
    if ((int )c1 != (int )c2) {
#line 933
      return (0);
    }
#line 934
    if (! c1) {
#line 935
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 937
  return (1);
}
}
#line 940 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmltok.c"
static void initUpdatePosition___0(ENCODING const   *enc , char const   *ptr , char const   *end ,
                                   POSITION *pos ) 
{ 


  {
  {
#line 944
  normal_updatePosition___0(& utf8_encoding___0.enc, ptr, end, pos);
  }
#line 945
  return;
}
}
#line 947 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmltok.c"
static int toAscii___0(ENCODING const   *enc , char const   *ptr , char const   *end ) 
{ 
  char buf[1] ;
  char *p ;

  {
  {
#line 951
  p = buf;
#line 952
  (*(enc->utf8Convert))(enc, & ptr, end, & p, (char const   *)(p + 1));
  }
#line 953
  if ((unsigned long )p == (unsigned long )(buf)) {
#line 954
    return (-1);
  } else {
#line 956
    return ((int )buf[0]);
  }
}
}
#line 959 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmltok.c"
static int isSpace___0(int c___0 ) 
{ 


  {
  {
#line 966
  if (c___0 == 9) {
#line 966
    goto case_9;
  }
#line 966
  if (c___0 == 10) {
#line 966
    goto case_9;
  }
#line 966
  if (c___0 == 13) {
#line 966
    goto case_9;
  }
#line 966
  if (c___0 == 32) {
#line 966
    goto case_9;
  }
#line 962
  goto switch_break;
  case_9: /* CIL Label */ 
  case_10: /* CIL Label */ 
  case_13: /* CIL Label */ 
  case_32: /* CIL Label */ 
#line 967
  return (1);
  switch_break: /* CIL Label */ ;
  }
#line 969
  return (0);
}
}
#line 975 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmltok.c"
static int parsePseudoAttribute___0(ENCODING const   *enc , char const   *ptr , char const   *end ,
                                    char const   **namePtr , char const   **nameEndPtr ,
                                    char const   **valPtr , char const   **nextTokPtr ) 
{ 
  int c___0 ;
  char open___0 ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 986
  if ((unsigned long )ptr == (unsigned long )end) {
#line 987
    *namePtr = (char const   *)((void *)0);
#line 988
    return (1);
  }
  {
#line 990
  tmp = toAscii___0(enc, ptr, end);
#line 990
  tmp___0 = isSpace___0(tmp);
  }
#line 990
  if (! tmp___0) {
#line 991
    *nextTokPtr = ptr;
#line 992
    return (0);
  }
  {
#line 994
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 995
    ptr += enc->minBytesPerChar;
#line 994
    tmp___1 = toAscii___0(enc, ptr, end);
#line 994
    tmp___2 = isSpace___0(tmp___1);
    }
#line 994
    if (! tmp___2) {
#line 994
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 997
  if ((unsigned long )ptr == (unsigned long )end) {
#line 998
    *namePtr = (char const   *)((void *)0);
#line 999
    return (1);
  }
#line 1001
  *namePtr = ptr;
  {
#line 1002
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 1003
    c___0 = toAscii___0(enc, ptr, end);
    }
#line 1004
    if (c___0 == -1) {
#line 1005
      *nextTokPtr = ptr;
#line 1006
      return (0);
    }
#line 1008
    if (c___0 == 61) {
#line 1009
      *nameEndPtr = ptr;
#line 1010
      goto while_break___0;
    }
    {
#line 1012
    tmp___4 = isSpace___0(c___0);
    }
#line 1012
    if (tmp___4) {
#line 1013
      *nameEndPtr = ptr;
      {
#line 1014
      while (1) {
        while_continue___1: /* CIL Label */ ;
        {
#line 1015
        ptr += enc->minBytesPerChar;
#line 1014
        c___0 = toAscii___0(enc, ptr, end);
#line 1014
        tmp___3 = isSpace___0(c___0);
        }
#line 1014
        if (! tmp___3) {
#line 1014
          goto while_break___1;
        }
      }
      while_break___1: /* CIL Label */ ;
      }
#line 1017
      if (c___0 != 61) {
#line 1018
        *nextTokPtr = ptr;
#line 1019
        return (0);
      }
#line 1021
      goto while_break___0;
    }
#line 1023
    ptr += enc->minBytesPerChar;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1025
  if ((unsigned long )ptr == (unsigned long )*namePtr) {
#line 1026
    *nextTokPtr = ptr;
#line 1027
    return (0);
  }
  {
#line 1029
  ptr += enc->minBytesPerChar;
#line 1030
  c___0 = toAscii___0(enc, ptr, end);
  }
  {
#line 1031
  while (1) {
    while_continue___2: /* CIL Label */ ;
    {
#line 1031
    tmp___5 = isSpace___0(c___0);
    }
#line 1031
    if (! tmp___5) {
#line 1031
      goto while_break___2;
    }
    {
#line 1032
    ptr += enc->minBytesPerChar;
#line 1033
    c___0 = toAscii___0(enc, ptr, end);
    }
  }
  while_break___2: /* CIL Label */ ;
  }
#line 1035
  if (c___0 != 34) {
#line 1035
    if (c___0 != 39) {
#line 1036
      *nextTokPtr = ptr;
#line 1037
      return (0);
    }
  }
#line 1039
  open___0 = (char )c___0;
#line 1040
  ptr += enc->minBytesPerChar;
#line 1041
  *valPtr = ptr;
  {
#line 1042
  while (1) {
    while_continue___3: /* CIL Label */ ;
    {
#line 1043
    c___0 = toAscii___0(enc, ptr, end);
    }
#line 1044
    if (c___0 == (int )open___0) {
#line 1045
      goto while_break___3;
    }
#line 1046
    if (97 <= c___0) {
#line 1046
      if (! (c___0 <= 122)) {
#line 1046
        goto _L___1;
      }
    } else
    _L___1: /* CIL Label */ 
#line 1046
    if (65 <= c___0) {
#line 1046
      if (! (c___0 <= 90)) {
#line 1046
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 1046
    if (48 <= c___0) {
#line 1046
      if (! (c___0 <= 57)) {
#line 1046
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 1046
    if (c___0 != 46) {
#line 1046
      if (c___0 != 45) {
#line 1046
        if (c___0 != 95) {
#line 1052
          *nextTokPtr = ptr;
#line 1053
          return (0);
        }
      }
    }
#line 1042
    ptr += enc->minBytesPerChar;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 1056
  *nextTokPtr = ptr + enc->minBytesPerChar;
#line 1057
  return (1);
}
}
#line 1060 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmltok.c"
static char const   KW_version___0[8]  = 
#line 1060
  {      (char const   )118,      (char const   )101,      (char const   )114,      (char const   )115, 
        (char const   )105,      (char const   )111,      (char const   )110,      (char const   )'\000'};
#line 1064 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmltok.c"
static char const   KW_encoding___0[9]  = 
#line 1064
  {      (char const   )101,      (char const   )110,      (char const   )99,      (char const   )111, 
        (char const   )100,      (char const   )105,      (char const   )110,      (char const   )103, 
        (char const   )'\000'};
#line 1068 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmltok.c"
static char const   KW_standalone___0[11]  = 
#line 1068
  {      (char const   )115,      (char const   )116,      (char const   )97,      (char const   )110, 
        (char const   )100,      (char const   )97,      (char const   )108,      (char const   )111, 
        (char const   )110,      (char const   )101,      (char const   )'\000'};
#line 1073 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmltok.c"
static char const   KW_yes___0[4]  = {      (char const   )121,      (char const   )101,      (char const   )115,      (char const   )'\000'};
#line 1077 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmltok.c"
static char const   KW_no___0[3]  = {      (char const   )110,      (char const   )111,      (char const   )'\000'};
#line 1081 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmltok.c"
static int doParseXmlDecl___0(ENCODING const   *(*encodingFinder)(ENCODING const   * ,
                                                                  char const   * ,
                                                                  char const   * ) ,
                              int isGeneralTextEntity , ENCODING const   *enc , char const   *ptr ,
                              char const   *end , char const   **badPtr , char const   **versionPtr ,
                              char const   **versionEndPtr , char const   **encodingName ,
                              ENCODING const   **encoding , int *standalone ) 
{ 
  char const   *val ;
  char const   *name ;
  char const   *nameEnd ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int c___0 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;

  {
  {
#line 1096
  val = (char const   *)((void *)0);
#line 1097
  name = (char const   *)((void *)0);
#line 1098
  nameEnd = (char const   *)((void *)0);
#line 1099
  ptr += 5 * (int )enc->minBytesPerChar;
#line 1100
  end -= 2 * (int )enc->minBytesPerChar;
#line 1101
  tmp = parsePseudoAttribute___0(enc, ptr, end, & name, & nameEnd, & val, & ptr);
  }
#line 1101
  if (tmp) {
#line 1101
    if (! name) {
#line 1103
      *badPtr = ptr;
#line 1104
      return (0);
    }
  } else {
#line 1103
    *badPtr = ptr;
#line 1104
    return (0);
  }
  {
#line 1106
  tmp___1 = (*(enc->nameMatchesAscii))(enc, name, nameEnd, KW_version___0);
  }
#line 1106
  if (tmp___1) {
#line 1113
    if (versionPtr) {
#line 1114
      *versionPtr = val;
    }
#line 1115
    if (versionEndPtr) {
#line 1116
      *versionEndPtr = ptr;
    }
    {
#line 1117
    tmp___0 = parsePseudoAttribute___0(enc, ptr, end, & name, & nameEnd, & val, & ptr);
    }
#line 1117
    if (! tmp___0) {
#line 1118
      *badPtr = ptr;
#line 1119
      return (0);
    }
#line 1121
    if (! name) {
#line 1122
      if (isGeneralTextEntity) {
#line 1124
        *badPtr = ptr;
#line 1125
        return (0);
      }
#line 1127
      return (1);
    }
  } else
#line 1107
  if (! isGeneralTextEntity) {
#line 1108
    *badPtr = name;
#line 1109
    return (0);
  }
  {
#line 1130
  tmp___4 = (*(enc->nameMatchesAscii))(enc, name, nameEnd, KW_encoding___0);
  }
#line 1130
  if (tmp___4) {
    {
#line 1131
    tmp___2 = toAscii___0(enc, val, end);
#line 1131
    c___0 = tmp___2;
    }
#line 1132
    if (97 <= c___0) {
#line 1132
      if (! (c___0 <= 122)) {
#line 1132
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 1132
    if (65 <= c___0) {
#line 1132
      if (! (c___0 <= 90)) {
#line 1133
        *badPtr = val;
#line 1134
        return (0);
      }
    } else {
#line 1133
      *badPtr = val;
#line 1134
      return (0);
    }
#line 1136
    if (encodingName) {
#line 1137
      *encodingName = val;
    }
#line 1138
    if (encoding) {
      {
#line 1139
      *encoding = (*encodingFinder)(enc, val, ptr - enc->minBytesPerChar);
      }
    }
    {
#line 1140
    tmp___3 = parsePseudoAttribute___0(enc, ptr, end, & name, & nameEnd, & val, & ptr);
    }
#line 1140
    if (! tmp___3) {
#line 1141
      *badPtr = ptr;
#line 1142
      return (0);
    }
#line 1144
    if (! name) {
#line 1145
      return (1);
    }
  }
  {
#line 1147
  tmp___5 = (*(enc->nameMatchesAscii))(enc, name, nameEnd, KW_standalone___0);
  }
#line 1147
  if (tmp___5) {
#line 1147
    if (isGeneralTextEntity) {
#line 1149
      *badPtr = name;
#line 1150
      return (0);
    }
  } else {
#line 1149
    *badPtr = name;
#line 1150
    return (0);
  }
  {
#line 1152
  tmp___7 = (*(enc->nameMatchesAscii))(enc, val, ptr - enc->minBytesPerChar, KW_yes___0);
  }
#line 1152
  if (tmp___7) {
#line 1153
    if (standalone) {
#line 1154
      *standalone = 1;
    }
  } else {
    {
#line 1156
    tmp___6 = (*(enc->nameMatchesAscii))(enc, val, ptr - enc->minBytesPerChar, KW_no___0);
    }
#line 1156
    if (tmp___6) {
#line 1157
      if (standalone) {
#line 1158
        *standalone = 0;
      }
    } else {
#line 1161
      *badPtr = val;
#line 1162
      return (0);
    }
  }
  {
#line 1164
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1164
    tmp___8 = toAscii___0(enc, ptr, end);
#line 1164
    tmp___9 = isSpace___0(tmp___8);
    }
#line 1164
    if (! tmp___9) {
#line 1164
      goto while_break;
    }
#line 1165
    ptr += enc->minBytesPerChar;
  }
  while_break: /* CIL Label */ ;
  }
#line 1166
  if ((unsigned long )ptr != (unsigned long )end) {
#line 1167
    *badPtr = ptr;
#line 1168
    return (0);
  }
#line 1170
  return (1);
}
}
#line 1173 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmltok.c"
static int checkCharRefNumber___0(int result ) 
{ 


  {
  {
#line 1178
  if (result >> 8 == 223) {
#line 1178
    goto case_223;
  }
#line 1178
  if (result >> 8 == 222) {
#line 1178
    goto case_223;
  }
#line 1178
  if (result >> 8 == 221) {
#line 1178
    goto case_223;
  }
#line 1178
  if (result >> 8 == 220) {
#line 1178
    goto case_223;
  }
#line 1178
  if (result >> 8 == 219) {
#line 1178
    goto case_223;
  }
#line 1178
  if (result >> 8 == 218) {
#line 1178
    goto case_223;
  }
#line 1178
  if (result >> 8 == 217) {
#line 1178
    goto case_223;
  }
#line 1178
  if (result >> 8 == 216) {
#line 1178
    goto case_223;
  }
#line 1180
  if (result >> 8 == 0) {
#line 1180
    goto case_0;
  }
#line 1184
  if (result >> 8 == 255) {
#line 1184
    goto case_255;
  }
#line 1176
  goto switch_break;
  case_223: /* CIL Label */ 
  case_222: /* CIL Label */ 
  case_221: /* CIL Label */ 
  case_220: /* CIL Label */ 
  case_219: /* CIL Label */ 
  case_218: /* CIL Label */ 
  case_217: /* CIL Label */ 
  case_216: /* CIL Label */ 
#line 1179
  return (-1);
  case_0: /* CIL Label */ 
#line 1181
  if ((int )latin1_encoding___0.type[result] == 0) {
#line 1182
    return (-1);
  }
#line 1183
  goto switch_break;
  case_255: /* CIL Label */ 
#line 1185
  if (result == 65534) {
#line 1186
    return (-1);
  } else
#line 1185
  if (result == 65535) {
#line 1186
    return (-1);
  }
#line 1187
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 1189
  return (result);
}
}
#line 1263 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmltok.c"
static int unknown_isName___0(ENCODING const   *enc , char const   *p ) 
{ 
  struct unknown_encoding  const  *uenc ;
  int c___0 ;
  int tmp ;

  {
  {
#line 1266
  uenc = (struct unknown_encoding  const  *)enc;
#line 1267
  tmp = (*(uenc->convert))((void *)uenc->userData, p);
#line 1267
  c___0 = tmp;
  }
#line 1268
  if (c___0 & -65536) {
#line 1269
    return (0);
  }
#line 1270
  return ((int )(namingBitmap___0[((int const   )namePages___0[c___0 >> 8] << 3) + (int const   )((c___0 & 255) >> 5)] & (unsigned int const   )(1 << ((c___0 & 255) & 31))));
}
}
#line 1273 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmltok.c"
static int unknown_isNmstrt___0(ENCODING const   *enc , char const   *p ) 
{ 
  struct unknown_encoding  const  *uenc ;
  int c___0 ;
  int tmp ;

  {
  {
#line 1276
  uenc = (struct unknown_encoding  const  *)enc;
#line 1277
  tmp = (*(uenc->convert))((void *)uenc->userData, p);
#line 1277
  c___0 = tmp;
  }
#line 1278
  if (c___0 & -65536) {
#line 1279
    return (0);
  }
#line 1280
  return ((int )(namingBitmap___0[((int const   )nmstrtPages___0[c___0 >> 8] << 3) + (int const   )((c___0 & 255) >> 5)] & (unsigned int const   )(1 << ((c___0 & 255) & 31))));
}
}
#line 1283 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmltok.c"
static int unknown_isInvalid___0(ENCODING const   *enc , char const   *p ) 
{ 
  struct unknown_encoding  const  *uenc ;
  int c___0 ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 1286
  uenc = (struct unknown_encoding  const  *)enc;
#line 1287
  tmp = (*(uenc->convert))((void *)uenc->userData, p);
#line 1287
  c___0 = tmp;
  }
#line 1288
  if (c___0 & -65536) {
#line 1288
    tmp___1 = 1;
  } else {
    {
#line 1288
    tmp___0 = checkCharRefNumber___0(c___0);
    }
#line 1288
    if (tmp___0 < 0) {
#line 1288
      tmp___1 = 1;
    } else {
#line 1288
      tmp___1 = 0;
    }
  }
#line 1288
  return (tmp___1);
}
}
#line 1291 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmltok.c"
static void unknown_toUtf8___0(ENCODING const   *enc , char const   **fromP , char const   *fromLim ,
                               char **toP , char const   *toLim ) 
{ 
  struct unknown_encoding  const  *uenc ;
  char buf[4] ;
  char const   *utf8 ;
  int n ;
  char const   *tmp ;
  int c___0 ;
  int tmp___0 ;
  char *tmp___1 ;
  char const   *tmp___2 ;

  {
#line 1296
  uenc = (struct unknown_encoding  const  *)enc;
  {
#line 1298
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1301
    if ((unsigned long )*fromP == (unsigned long )fromLim) {
#line 1302
      goto while_break;
    }
#line 1303
    utf8 = (char const   *)(uenc->utf8[(unsigned char )*(*fromP)]);
#line 1304
    tmp = utf8;
#line 1304
    utf8 ++;
#line 1304
    n = (int )*tmp;
#line 1305
    if (n == 0) {
      {
#line 1306
      tmp___0 = (*(uenc->convert))((void *)uenc->userData, *fromP);
#line 1306
      c___0 = tmp___0;
#line 1307
      n = XmlUtf8Encode(c___0, buf);
      }
#line 1308
      if ((long )n > toLim - (char const   *)*toP) {
#line 1309
        goto while_break;
      }
#line 1310
      utf8 = (char const   *)(buf);
#line 1311
      *fromP += (int )((struct normal_encoding  const  *)enc)->type[(unsigned char )*(*fromP)] - 3;
    } else {
#line 1315
      if ((long )n > toLim - (char const   *)*toP) {
#line 1316
        goto while_break;
      }
#line 1317
      (*fromP) ++;
    }
    {
#line 1319
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1320
      tmp___1 = *toP;
#line 1320
      (*toP) ++;
#line 1320
      tmp___2 = utf8;
#line 1320
      utf8 ++;
#line 1320
      *tmp___1 = (char )*tmp___2;
#line 1319
      n --;
#line 1319
      if (! (n != 0)) {
#line 1319
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1323
  return;
}
}
#line 1325 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmltok.c"
static void unknown_toUtf16___0(ENCODING const   *enc , char const   **fromP , char const   *fromLim ,
                                unsigned short **toP , unsigned short const   *toLim ) 
{ 
  struct unknown_encoding  const  *uenc ;
  unsigned short c___0 ;
  int tmp ;
  unsigned short *tmp___0 ;

  {
#line 1330
  uenc = (struct unknown_encoding  const  *)enc;
  {
#line 1331
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1331
    if ((unsigned long )*fromP != (unsigned long )fromLim) {
#line 1331
      if (! ((unsigned long )*toP != (unsigned long )toLim)) {
#line 1331
        goto while_break;
      }
    } else {
#line 1331
      goto while_break;
    }
#line 1332
    c___0 = uenc->utf16[(unsigned char )*(*fromP)];
#line 1333
    if ((int )c___0 == 0) {
      {
#line 1334
      tmp = (*(uenc->convert))((void *)uenc->userData, *fromP);
#line 1334
      c___0 = (unsigned short )tmp;
#line 1336
      *fromP += (int )((struct normal_encoding  const  *)enc)->type[(unsigned char )*(*fromP)] - 3;
      }
    } else {
#line 1340
      (*fromP) ++;
    }
#line 1341
    tmp___0 = *toP;
#line 1341
    (*toP) ++;
#line 1341
    *tmp___0 = c___0;
  }
  while_break: /* CIL Label */ ;
  }
#line 1343
  return;
}
}
#line 1438 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmltok.c"
static char const   KW_ISO_8859_1___0[11]  = 
#line 1438
  {      (char const   )73,      (char const   )83,      (char const   )79,      (char const   )45, 
        (char const   )56,      (char const   )56,      (char const   )53,      (char const   )57, 
        (char const   )45,      (char const   )49,      (char const   )'\000'};
#line 1442 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmltok.c"
static char const   KW_US_ASCII___0[9]  = 
#line 1442
  {      (char const   )85,      (char const   )83,      (char const   )45,      (char const   )65, 
        (char const   )83,      (char const   )67,      (char const   )73,      (char const   )73, 
        (char const   )'\000'};
#line 1446 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmltok.c"
static char const   KW_UTF_8___0[6]  = {      (char const   )85,      (char const   )84,      (char const   )70,      (char const   )45, 
        (char const   )56,      (char const   )'\000'};
#line 1449 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmltok.c"
static char const   KW_UTF_16___0[7]  = {      (char const   )85,      (char const   )84,      (char const   )70,      (char const   )45, 
        (char const   )49,      (char const   )54,      (char const   )'\000'};
#line 1452 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmltok.c"
static char const   KW_UTF_16BE___0[9]  = 
#line 1452
  {      (char const   )85,      (char const   )84,      (char const   )70,      (char const   )45, 
        (char const   )49,      (char const   )54,      (char const   )66,      (char const   )69, 
        (char const   )'\000'};
#line 1456 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmltok.c"
static char const   KW_UTF_16LE___0[9]  = 
#line 1456
  {      (char const   )85,      (char const   )84,      (char const   )70,      (char const   )45, 
        (char const   )49,      (char const   )54,      (char const   )76,      (char const   )69, 
        (char const   )'\000'};
#line 1464
static int getEncodingIndex___0(char const   *name ) ;
#line 1464 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmltok.c"
static char const   * const  encodingNames___0[6]  = {      (char const   */* const  */)(KW_ISO_8859_1___0),      (char const   */* const  */)(KW_US_ASCII___0),      (char const   */* const  */)(KW_UTF_8___0),      (char const   */* const  */)(KW_UTF_16___0), 
        (char const   */* const  */)(KW_UTF_16BE___0),      (char const   */* const  */)(KW_UTF_16LE___0)};
#line 1461 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmltok.c"
static int getEncodingIndex___0(char const   *name ) 
{ 
  int i ;
  int tmp ;

  {
#line 1473
  if ((unsigned long )name == (unsigned long )((void *)0)) {
#line 1474
    return (6);
  }
#line 1475
  i = 0;
  {
#line 1475
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1475
    if (! (i < (int )(sizeof(encodingNames___0) / sizeof(encodingNames___0[0])))) {
#line 1475
      goto while_break;
    }
    {
#line 1476
    tmp = streqci___0(name, (char const   *)encodingNames___0[i]);
    }
#line 1476
    if (tmp) {
#line 1477
      return (i);
    }
#line 1475
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1478
  return (-1);
}
}
#line 1496 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmltok.c"
static int initScan___0(ENCODING const   * const  *encodingTable , INIT_ENCODING const   *enc ,
                        int state , char const   *ptr , char const   *end , char const   **nextTokPtr ) 
{ 
  ENCODING const   **encPtr ;
  int tmp ;
  int e ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 1506
  if ((unsigned long )ptr == (unsigned long )end) {
#line 1507
    return (-4);
  }
#line 1508
  encPtr = (ENCODING const   **)enc->encPtr;
#line 1509
  if ((unsigned long )(ptr + 1) == (unsigned long )end) {
    {
#line 1521
    if ((int )enc->initEnc.isUtf16 == 4) {
#line 1521
      goto case_4;
    }
#line 1521
    if ((int )enc->initEnc.isUtf16 == 5) {
#line 1521
      goto case_4;
    }
#line 1521
    if ((int )enc->initEnc.isUtf16 == 3) {
#line 1521
      goto case_4;
    }
#line 1518
    goto switch_break;
    case_4: /* CIL Label */ 
    case_5: /* CIL Label */ 
    case_3: /* CIL Label */ 
#line 1522
    return (-1);
    switch_break: /* CIL Label */ ;
    }
    {
#line 1527
    if ((int )((unsigned char )*ptr) == 239) {
#line 1527
      goto case_239;
    }
#line 1527
    if ((int )((unsigned char )*ptr) == 255) {
#line 1527
      goto case_239;
    }
#line 1527
    if ((int )((unsigned char )*ptr) == 254) {
#line 1527
      goto case_239;
    }
#line 1533
    if ((int )((unsigned char )*ptr) == 60) {
#line 1533
      goto case_60;
    }
#line 1533
    if ((int )((unsigned char )*ptr) == 0) {
#line 1533
      goto case_60;
    }
#line 1524
    goto switch_break___0;
    case_239: /* CIL Label */ 
    case_255: /* CIL Label */ 
    case_254: /* CIL Label */ 
#line 1528
    if ((int )enc->initEnc.isUtf16 == 0) {
#line 1528
      if (state == 1) {
#line 1530
        goto switch_break___0;
      }
    }
    case_60: /* CIL Label */ 
    case_0: /* CIL Label */ 
#line 1534
    return (-1);
    switch_break___0: /* CIL Label */ ;
    }
  } else {
    {
#line 1539
    if ((((int )((unsigned char )*(ptr + 0)) << 8) | (int )((unsigned char )*(ptr + 1))) == 65279) {
#line 1539
      goto case_65279;
    }
#line 1547
    if ((((int )((unsigned char )*(ptr + 0)) << 8) | (int )((unsigned char )*(ptr + 1))) == 15360) {
#line 1547
      goto case_15360;
    }
#line 1554
    if ((((int )((unsigned char )*(ptr + 0)) << 8) | (int )((unsigned char )*(ptr + 1))) == 65534) {
#line 1554
      goto case_65534;
    }
#line 1561
    if ((((int )((unsigned char )*(ptr + 0)) << 8) | (int )((unsigned char )*(ptr + 1))) == 61371) {
#line 1561
      goto case_61371;
    }
#line 1583
    goto switch_default;
    case_65279: /* CIL Label */ 
#line 1540
    if ((int )enc->initEnc.isUtf16 == 0) {
#line 1540
      if (state == 1) {
#line 1542
        goto switch_break___1;
      }
    }
#line 1543
    *nextTokPtr = ptr + 2;
#line 1544
    *encPtr = (ENCODING const   *)*(encodingTable + 4);
#line 1545
    return (14);
    case_15360: /* CIL Label */ 
#line 1548
    if ((int )enc->initEnc.isUtf16 == 4) {
#line 1548
      goto _L;
    } else
#line 1548
    if ((int )enc->initEnc.isUtf16 == 3) {
      _L: /* CIL Label */ 
#line 1548
      if (state == 1) {
#line 1551
        goto switch_break___1;
      }
    }
    {
#line 1552
    *encPtr = (ENCODING const   *)*(encodingTable + 5);
#line 1553
    tmp = (*((*encPtr)->scanners[state]))(*encPtr, ptr, end, nextTokPtr);
    }
#line 1553
    return (tmp);
    case_65534: /* CIL Label */ 
#line 1555
    if ((int )enc->initEnc.isUtf16 == 0) {
#line 1555
      if (state == 1) {
#line 1557
        goto switch_break___1;
      }
    }
#line 1558
    *nextTokPtr = ptr + 2;
#line 1559
    *encPtr = (ENCODING const   *)*(encodingTable + 5);
#line 1560
    return (14);
    case_61371: /* CIL Label */ 
#line 1569
    if (state == 1) {
#line 1570
      e = (int )enc->initEnc.isUtf16;
#line 1571
      if (e == 0) {
#line 1573
        goto switch_break___1;
      } else
#line 1571
      if (e == 4) {
#line 1573
        goto switch_break___1;
      } else
#line 1571
      if (e == 5) {
#line 1573
        goto switch_break___1;
      } else
#line 1571
      if (e == 3) {
#line 1573
        goto switch_break___1;
      }
    }
#line 1575
    if ((unsigned long )(ptr + 2) == (unsigned long )end) {
#line 1576
      return (-1);
    }
#line 1577
    if ((int )((unsigned char )*(ptr + 2)) == 191) {
#line 1578
      *nextTokPtr = ptr + 3;
#line 1579
      *encPtr = (ENCODING const   *)*(encodingTable + 2);
#line 1580
      return (14);
    }
#line 1582
    goto switch_break___1;
    switch_default: /* CIL Label */ 
#line 1584
    if ((int const   )*(ptr + 0) == 0) {
#line 1591
      if (state == 1) {
#line 1591
        if ((int )enc->initEnc.isUtf16 == 5) {
#line 1592
          goto switch_break___1;
        }
      }
      {
#line 1593
      *encPtr = (ENCODING const   *)*(encodingTable + 4);
#line 1594
      tmp___0 = (*((*encPtr)->scanners[state]))(*encPtr, ptr, end, nextTokPtr);
      }
#line 1594
      return (tmp___0);
    } else
#line 1596
    if ((int const   )*(ptr + 1) == 0) {
#line 1606
      if (state == 1) {
#line 1607
        goto switch_break___1;
      }
      {
#line 1608
      *encPtr = (ENCODING const   *)*(encodingTable + 5);
#line 1609
      tmp___1 = (*((*encPtr)->scanners[state]))(*encPtr, ptr, end, nextTokPtr);
      }
#line 1609
      return (tmp___1);
    }
#line 1611
    goto switch_break___1;
    switch_break___1: /* CIL Label */ ;
    }
  }
  {
#line 1614
  *encPtr = (ENCODING const   *)*(encodingTable + (int )enc->initEnc.isUtf16);
#line 1615
  tmp___2 = (*((*encPtr)->scanners[state]))(*encPtr, ptr, end, nextTokPtr);
  }
#line 1615
  return (tmp___2);
}
}
#line 29 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmltok_ns.c"
static ENCODING const   * const  encodings___0[7]  = {      (ENCODING const   */* const  */)(& latin1_encoding___0.enc),      (ENCODING const   */* const  */)(& ascii_encoding___0.enc),      (ENCODING const   */* const  */)(& utf8_encoding___0.enc),      (ENCODING const   */* const  */)(& big2_encoding___0.enc), 
        (ENCODING const   */* const  */)(& big2_encoding___0.enc),      (ENCODING const   */* const  */)(& little2_encoding___0.enc),      (ENCODING const   */* const  */)(& utf8_encoding___0.enc)};
#line 39 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmltok_ns.c"
static int initScanProlog___0(ENCODING const   *enc , char const   *ptr , char const   *end ,
                              char const   **nextTokPtr ) 
{ 
  int tmp ;

  {
  {
#line 43
  tmp = initScan___0(encodings___0, (INIT_ENCODING const   *)enc, 0, ptr, end, nextTokPtr);
  }
#line 43
  return (tmp);
}
}
#line 47 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmltok_ns.c"
static int initScanContent___0(ENCODING const   *enc , char const   *ptr , char const   *end ,
                               char const   **nextTokPtr ) 
{ 
  int tmp ;

  {
  {
#line 51
  tmp = initScan___0(encodings___0, (INIT_ENCODING const   *)enc, 1, ptr, end, nextTokPtr);
  }
#line 51
  return (tmp);
}
}
#line 71 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmltok_ns.c"
static ENCODING const   *findEncoding___0(ENCODING const   *enc , char const   *ptr ,
                                          char const   *end ) 
{ 
  char buf[128] ;
  char *p ;
  int i ;
  int tmp ;

  {
  {
#line 76
  p = buf;
#line 78
  (*(enc->utf8Convert))(enc, & ptr, end, & p, (char const   *)((p + 128) - 1));
  }
#line 79
  if ((unsigned long )ptr != (unsigned long )end) {
#line 80
    return ((ENCODING const   *)0);
  }
  {
#line 81
  *p = (char)0;
#line 82
  tmp = streqci___0((char const   *)(buf), KW_UTF_16___0);
  }
#line 82
  if (tmp) {
#line 82
    if (enc->minBytesPerChar == 2) {
#line 83
      return (enc);
    }
  }
  {
#line 84
  i = getEncodingIndex___0((char const   *)(buf));
  }
#line 85
  if (i == -1) {
#line 86
    return ((ENCODING const   *)0);
  }
#line 87
  return ((ENCODING const   *)encodings___0[i]);
}
}
#line 29 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmltok_ns.c"
static ENCODING const   * const  encodingsNS___0[7]  = {      (ENCODING const   */* const  */)(& latin1_encoding_ns___0.enc),      (ENCODING const   */* const  */)(& ascii_encoding_ns___0.enc),      (ENCODING const   */* const  */)(& utf8_encoding_ns___0.enc),      (ENCODING const   */* const  */)(& big2_encoding_ns___0.enc), 
        (ENCODING const   */* const  */)(& big2_encoding_ns___0.enc),      (ENCODING const   */* const  */)(& little2_encoding_ns___0.enc),      (ENCODING const   */* const  */)(& utf8_encoding_ns___0.enc)};
#line 39 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmltok_ns.c"
static int initScanPrologNS___0(ENCODING const   *enc , char const   *ptr , char const   *end ,
                                char const   **nextTokPtr ) 
{ 
  int tmp ;

  {
  {
#line 43
  tmp = initScan___0(encodingsNS___0, (INIT_ENCODING const   *)enc, 0, ptr, end, nextTokPtr);
  }
#line 43
  return (tmp);
}
}
#line 47 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmltok_ns.c"
static int initScanContentNS___0(ENCODING const   *enc , char const   *ptr , char const   *end ,
                                 char const   **nextTokPtr ) 
{ 
  int tmp ;

  {
  {
#line 51
  tmp = initScan___0(encodingsNS___0, (INIT_ENCODING const   *)enc, 1, ptr, end, nextTokPtr);
  }
#line 51
  return (tmp);
}
}
#line 71 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmltok_ns.c"
static ENCODING const   *findEncodingNS___0(ENCODING const   *enc , char const   *ptr ,
                                            char const   *end ) 
{ 
  char buf[128] ;
  char *p ;
  int i ;
  int tmp ;

  {
  {
#line 76
  p = buf;
#line 78
  (*(enc->utf8Convert))(enc, & ptr, end, & p, (char const   *)((p + 128) - 1));
  }
#line 79
  if ((unsigned long )ptr != (unsigned long )end) {
#line 80
    return ((ENCODING const   *)0);
  }
  {
#line 81
  *p = (char)0;
#line 82
  tmp = streqci___0((char const   *)(buf), KW_UTF_16___0);
  }
#line 82
  if (tmp) {
#line 82
    if (enc->minBytesPerChar == 2) {
#line 83
      return (enc);
    }
  }
  {
#line 84
  i = getEncodingIndex___0((char const   *)(buf));
  }
#line 85
  if (i == -1) {
#line 86
    return ((ENCODING const   *)0);
  }
#line 87
  return ((ENCODING const   *)encodingsNS___0[i]);
}
}
#line 33 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlrole.c"
static char const   KW_ANY___0[4]  = {      (char const   )65,      (char const   )78,      (char const   )89,      (char const   )'\000'};
#line 35 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlrole.c"
static char const   KW_ATTLIST___0[8]  = 
#line 35
  {      (char const   )65,      (char const   )84,      (char const   )84,      (char const   )76, 
        (char const   )73,      (char const   )83,      (char const   )84,      (char const   )'\000'};
#line 37 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlrole.c"
static char const   KW_CDATA___0[6]  = {      (char const   )67,      (char const   )68,      (char const   )65,      (char const   )84, 
        (char const   )65,      (char const   )'\000'};
#line 39 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlrole.c"
static char const   KW_DOCTYPE___0[8]  = 
#line 39
  {      (char const   )68,      (char const   )79,      (char const   )67,      (char const   )84, 
        (char const   )89,      (char const   )80,      (char const   )69,      (char const   )'\000'};
#line 41 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlrole.c"
static char const   KW_ELEMENT___0[8]  = 
#line 41
  {      (char const   )69,      (char const   )76,      (char const   )69,      (char const   )77, 
        (char const   )69,      (char const   )78,      (char const   )84,      (char const   )'\000'};
#line 43 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlrole.c"
static char const   KW_EMPTY___0[6]  = {      (char const   )69,      (char const   )77,      (char const   )80,      (char const   )84, 
        (char const   )89,      (char const   )'\000'};
#line 45 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlrole.c"
static char const   KW_ENTITIES___0[9]  = 
#line 45
  {      (char const   )69,      (char const   )78,      (char const   )84,      (char const   )73, 
        (char const   )84,      (char const   )73,      (char const   )69,      (char const   )83, 
        (char const   )'\000'};
#line 48 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlrole.c"
static char const   KW_ENTITY___0[7]  = {      (char const   )69,      (char const   )78,      (char const   )84,      (char const   )73, 
        (char const   )84,      (char const   )89,      (char const   )'\000'};
#line 50 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlrole.c"
static char const   KW_FIXED___0[6]  = {      (char const   )70,      (char const   )73,      (char const   )88,      (char const   )69, 
        (char const   )68,      (char const   )'\000'};
#line 52 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlrole.c"
static char const   KW_ID___0[3]  = {      (char const   )73,      (char const   )68,      (char const   )'\000'};
#line 54 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlrole.c"
static char const   KW_IDREF___0[6]  = {      (char const   )73,      (char const   )68,      (char const   )82,      (char const   )69, 
        (char const   )70,      (char const   )'\000'};
#line 56 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlrole.c"
static char const   KW_IDREFS___0[7]  = {      (char const   )73,      (char const   )68,      (char const   )82,      (char const   )69, 
        (char const   )70,      (char const   )83,      (char const   )'\000'};
#line 59 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlrole.c"
static char const   KW_IGNORE___0[7]  = {      (char const   )73,      (char const   )71,      (char const   )78,      (char const   )79, 
        (char const   )82,      (char const   )69,      (char const   )'\000'};
#line 62 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlrole.c"
static char const   KW_IMPLIED___0[8]  = 
#line 62
  {      (char const   )73,      (char const   )77,      (char const   )80,      (char const   )76, 
        (char const   )73,      (char const   )69,      (char const   )68,      (char const   )'\000'};
#line 65 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlrole.c"
static char const   KW_INCLUDE___0[8]  = 
#line 65
  {      (char const   )73,      (char const   )78,      (char const   )67,      (char const   )76, 
        (char const   )85,      (char const   )68,      (char const   )69,      (char const   )'\000'};
#line 68 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlrole.c"
static char const   KW_NDATA___0[6]  = {      (char const   )78,      (char const   )68,      (char const   )65,      (char const   )84, 
        (char const   )65,      (char const   )'\000'};
#line 70 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlrole.c"
static char const   KW_NMTOKEN___0[8]  = 
#line 70
  {      (char const   )78,      (char const   )77,      (char const   )84,      (char const   )79, 
        (char const   )75,      (char const   )69,      (char const   )78,      (char const   )'\000'};
#line 72 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlrole.c"
static char const   KW_NMTOKENS___0[9]  = 
#line 72
  {      (char const   )78,      (char const   )77,      (char const   )84,      (char const   )79, 
        (char const   )75,      (char const   )69,      (char const   )78,      (char const   )83, 
        (char const   )'\000'};
#line 75 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlrole.c"
static char const   KW_NOTATION___0[9]  = 
#line 75
  {      (char const   )78,      (char const   )79,      (char const   )84,      (char const   )65, 
        (char const   )84,      (char const   )73,      (char const   )79,      (char const   )78, 
        (char const   )'\000'};
#line 78 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlrole.c"
static char const   KW_PCDATA___0[7]  = {      (char const   )80,      (char const   )67,      (char const   )68,      (char const   )65, 
        (char const   )84,      (char const   )65,      (char const   )'\000'};
#line 80 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlrole.c"
static char const   KW_PUBLIC___0[7]  = {      (char const   )80,      (char const   )85,      (char const   )66,      (char const   )76, 
        (char const   )73,      (char const   )67,      (char const   )'\000'};
#line 82 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlrole.c"
static char const   KW_REQUIRED___0[9]  = 
#line 82
  {      (char const   )82,      (char const   )69,      (char const   )81,      (char const   )85, 
        (char const   )73,      (char const   )82,      (char const   )69,      (char const   )68, 
        (char const   )'\000'};
#line 85 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlrole.c"
static char const   KW_SYSTEM___0[7]  = {      (char const   )83,      (char const   )89,      (char const   )83,      (char const   )84, 
        (char const   )69,      (char const   )77,      (char const   )'\000'};
#line 107
static int prolog0___0(PROLOG_STATE *state , int tok , char const   *ptr , char const   *end ,
                       ENCODING const   *enc ) ;
#line 107
static int prolog1___0(PROLOG_STATE *state , int tok , char const   *ptr , char const   *end ,
                       ENCODING const   *enc ) ;
#line 107
static int prolog2___0(PROLOG_STATE *state , int tok , char const   *ptr , char const   *end ,
                       ENCODING const   *enc ) ;
#line 107
static int doctype0___0(PROLOG_STATE *state , int tok , char const   *ptr , char const   *end ,
                        ENCODING const   *enc ) ;
#line 107
static int doctype1___0(PROLOG_STATE *state , int tok , char const   *ptr , char const   *end ,
                        ENCODING const   *enc ) ;
#line 107
static int doctype2___0(PROLOG_STATE *state , int tok , char const   *ptr , char const   *end ,
                        ENCODING const   *enc ) ;
#line 107
static int doctype3___0(PROLOG_STATE *state , int tok , char const   *ptr , char const   *end ,
                        ENCODING const   *enc ) ;
#line 107
static int doctype4___0(PROLOG_STATE *state , int tok , char const   *ptr , char const   *end ,
                        ENCODING const   *enc ) ;
#line 107
static int doctype5___0(PROLOG_STATE *state , int tok , char const   *ptr , char const   *end ,
                        ENCODING const   *enc ) ;
#line 107
static int internalSubset___0(PROLOG_STATE *state , int tok , char const   *ptr ,
                              char const   *end , ENCODING const   *enc ) ;
#line 107
static int entity0___0(PROLOG_STATE *state , int tok , char const   *ptr , char const   *end ,
                       ENCODING const   *enc ) ;
#line 107
static int entity1___0(PROLOG_STATE *state , int tok , char const   *ptr , char const   *end ,
                       ENCODING const   *enc ) ;
#line 107
static int entity2___0(PROLOG_STATE *state , int tok , char const   *ptr , char const   *end ,
                       ENCODING const   *enc ) ;
#line 107
static int entity3___0(PROLOG_STATE *state , int tok , char const   *ptr , char const   *end ,
                       ENCODING const   *enc ) ;
#line 107
static int entity4___0(PROLOG_STATE *state , int tok , char const   *ptr , char const   *end ,
                       ENCODING const   *enc ) ;
#line 107
static int entity5___0(PROLOG_STATE *state , int tok , char const   *ptr , char const   *end ,
                       ENCODING const   *enc ) ;
#line 107
static int entity6___0(PROLOG_STATE *state , int tok , char const   *ptr , char const   *end ,
                       ENCODING const   *enc ) ;
#line 107
static int entity7___0(PROLOG_STATE *state , int tok , char const   *ptr , char const   *end ,
                       ENCODING const   *enc ) ;
#line 107
static int entity8___0(PROLOG_STATE *state , int tok , char const   *ptr , char const   *end ,
                       ENCODING const   *enc ) ;
#line 107
static int entity9___0(PROLOG_STATE *state , int tok , char const   *ptr , char const   *end ,
                       ENCODING const   *enc ) ;
#line 107
static int entity10___0(PROLOG_STATE *state , int tok , char const   *ptr , char const   *end ,
                        ENCODING const   *enc ) ;
#line 107
static int notation0___0(PROLOG_STATE *state , int tok , char const   *ptr , char const   *end ,
                         ENCODING const   *enc ) ;
#line 107
static int notation1___0(PROLOG_STATE *state , int tok , char const   *ptr , char const   *end ,
                         ENCODING const   *enc ) ;
#line 107
static int notation2___0(PROLOG_STATE *state , int tok , char const   *ptr , char const   *end ,
                         ENCODING const   *enc ) ;
#line 107
static int notation3___0(PROLOG_STATE *state , int tok , char const   *ptr , char const   *end ,
                         ENCODING const   *enc ) ;
#line 107
static int notation4___0(PROLOG_STATE *state , int tok , char const   *ptr , char const   *end ,
                         ENCODING const   *enc ) ;
#line 107
static int attlist0___0(PROLOG_STATE *state , int tok , char const   *ptr , char const   *end ,
                        ENCODING const   *enc ) ;
#line 107
static int attlist1___0(PROLOG_STATE *state , int tok , char const   *ptr , char const   *end ,
                        ENCODING const   *enc ) ;
#line 107
static int attlist2___0(PROLOG_STATE *state , int tok , char const   *ptr , char const   *end ,
                        ENCODING const   *enc ) ;
#line 107
static int attlist3___0(PROLOG_STATE *state , int tok , char const   *ptr , char const   *end ,
                        ENCODING const   *enc ) ;
#line 107
static int attlist4___0(PROLOG_STATE *state , int tok , char const   *ptr , char const   *end ,
                        ENCODING const   *enc ) ;
#line 107
static int attlist5___0(PROLOG_STATE *state , int tok , char const   *ptr , char const   *end ,
                        ENCODING const   *enc ) ;
#line 107
static int attlist6___0(PROLOG_STATE *state , int tok , char const   *ptr , char const   *end ,
                        ENCODING const   *enc ) ;
#line 107
static int attlist7___0(PROLOG_STATE *state , int tok , char const   *ptr , char const   *end ,
                        ENCODING const   *enc ) ;
#line 107
static int attlist8___0(PROLOG_STATE *state , int tok , char const   *ptr , char const   *end ,
                        ENCODING const   *enc ) ;
#line 107
static int attlist9___0(PROLOG_STATE *state , int tok , char const   *ptr , char const   *end ,
                        ENCODING const   *enc ) ;
#line 107
static int element0___0(PROLOG_STATE *state , int tok , char const   *ptr , char const   *end ,
                        ENCODING const   *enc ) ;
#line 107
static int element1___0(PROLOG_STATE *state , int tok , char const   *ptr , char const   *end ,
                        ENCODING const   *enc ) ;
#line 107
static int element2___0(PROLOG_STATE *state , int tok , char const   *ptr , char const   *end ,
                        ENCODING const   *enc ) ;
#line 107
static int element3___0(PROLOG_STATE *state , int tok , char const   *ptr , char const   *end ,
                        ENCODING const   *enc ) ;
#line 107
static int element4___0(PROLOG_STATE *state , int tok , char const   *ptr , char const   *end ,
                        ENCODING const   *enc ) ;
#line 107
static int element5___0(PROLOG_STATE *state , int tok , char const   *ptr , char const   *end ,
                        ENCODING const   *enc ) ;
#line 107
static int element6___0(PROLOG_STATE *state , int tok , char const   *ptr , char const   *end ,
                        ENCODING const   *enc ) ;
#line 107
static int element7___0(PROLOG_STATE *state , int tok , char const   *ptr , char const   *end ,
                        ENCODING const   *enc ) ;
#line 107
static int externalSubset0___0(PROLOG_STATE *state , int tok , char const   *ptr ,
                               char const   *end , ENCODING const   *enc ) ;
#line 107
static int externalSubset1___0(PROLOG_STATE *state , int tok , char const   *ptr ,
                               char const   *end , ENCODING const   *enc ) ;
#line 107
static int condSect0___0(PROLOG_STATE *state , int tok , char const   *ptr , char const   *end ,
                         ENCODING const   *enc ) ;
#line 107
static int condSect1___0(PROLOG_STATE *state , int tok , char const   *ptr , char const   *end ,
                         ENCODING const   *enc ) ;
#line 107
static int condSect2___0(PROLOG_STATE *state , int tok , char const   *ptr , char const   *end ,
                         ENCODING const   *enc ) ;
#line 107
static int declClose___0(PROLOG_STATE *state , int tok , char const   *ptr , char const   *end ,
                         ENCODING const   *enc ) ;
#line 107
static int error___0(PROLOG_STATE *state , int tok , char const   *ptr , char const   *end ,
                     ENCODING const   *enc ) ;
#line 125
static int common___0(PROLOG_STATE *state , int tok ) ;
#line 127 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlrole.c"
static int prolog0___0(PROLOG_STATE *state , int tok , char const   *ptr , char const   *end ,
                       ENCODING const   *enc ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  {
#line 135
  if (tok == 15) {
#line 135
    goto case_15;
  }
#line 138
  if (tok == 12) {
#line 138
    goto case_12;
  }
#line 141
  if (tok == 11) {
#line 141
    goto case_11;
  }
#line 144
  if (tok == 13) {
#line 144
    goto case_13;
  }
#line 147
  if (tok == 14) {
#line 147
    goto case_14;
  }
#line 149
  if (tok == 16) {
#line 149
    goto case_16;
  }
#line 157
  if (tok == 29) {
#line 157
    goto case_29;
  }
#line 134
  goto switch_break;
  case_15: /* CIL Label */ 
#line 136
  state->handler = & prolog1___0;
#line 137
  return (0);
  case_12: /* CIL Label */ 
#line 139
  state->handler = & prolog1___0;
#line 140
  return (1);
  case_11: /* CIL Label */ 
#line 142
  state->handler = & prolog1___0;
#line 143
  return (55);
  case_13: /* CIL Label */ 
#line 145
  state->handler = & prolog1___0;
#line 146
  return (56);
  case_14: /* CIL Label */ 
#line 148
  return (0);
  case_16: /* CIL Label */ 
  {
#line 150
  tmp = (*(enc->nameMatchesAscii))(enc, ptr + 2 * (int )enc->minBytesPerChar, end,
                                   KW_DOCTYPE___0);
  }
#line 150
  if (! tmp) {
#line 154
    goto switch_break;
  }
#line 155
  state->handler = & doctype0___0;
#line 156
  return (3);
  case_29: /* CIL Label */ 
#line 158
  state->handler = & error___0;
#line 159
  return (2);
  switch_break: /* CIL Label */ ;
  }
  {
#line 161
  tmp___0 = common___0(state, tok);
  }
#line 161
  return (tmp___0);
}
}
#line 164 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlrole.c"
static int prolog1___0(PROLOG_STATE *state , int tok , char const   *ptr , char const   *end ,
                       ENCODING const   *enc ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  {
#line 172
  if (tok == 15) {
#line 172
    goto case_15;
  }
#line 174
  if (tok == 11) {
#line 174
    goto case_11;
  }
#line 176
  if (tok == 13) {
#line 176
    goto case_13;
  }
#line 178
  if (tok == 14) {
#line 178
    goto case_14;
  }
#line 180
  if (tok == 16) {
#line 180
    goto case_16;
  }
#line 188
  if (tok == 29) {
#line 188
    goto case_29;
  }
#line 171
  goto switch_break;
  case_15: /* CIL Label */ 
#line 173
  return (0);
  case_11: /* CIL Label */ 
#line 175
  return (55);
  case_13: /* CIL Label */ 
#line 177
  return (56);
  case_14: /* CIL Label */ 
#line 179
  return (0);
  case_16: /* CIL Label */ 
  {
#line 181
  tmp = (*(enc->nameMatchesAscii))(enc, ptr + 2 * (int )enc->minBytesPerChar, end,
                                   KW_DOCTYPE___0);
  }
#line 181
  if (! tmp) {
#line 185
    goto switch_break;
  }
#line 186
  state->handler = & doctype0___0;
#line 187
  return (3);
  case_29: /* CIL Label */ 
#line 189
  state->handler = & error___0;
#line 190
  return (2);
  switch_break: /* CIL Label */ ;
  }
  {
#line 192
  tmp___0 = common___0(state, tok);
  }
#line 192
  return (tmp___0);
}
}
#line 195 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlrole.c"
static int prolog2___0(PROLOG_STATE *state , int tok , char const   *ptr , char const   *end ,
                       ENCODING const   *enc ) 
{ 
  int tmp ;

  {
  {
#line 203
  if (tok == 15) {
#line 203
    goto case_15;
  }
#line 205
  if (tok == 11) {
#line 205
    goto case_11;
  }
#line 207
  if (tok == 13) {
#line 207
    goto case_13;
  }
#line 209
  if (tok == 29) {
#line 209
    goto case_29;
  }
#line 202
  goto switch_break;
  case_15: /* CIL Label */ 
#line 204
  return (0);
  case_11: /* CIL Label */ 
#line 206
  return (55);
  case_13: /* CIL Label */ 
#line 208
  return (56);
  case_29: /* CIL Label */ 
#line 210
  state->handler = & error___0;
#line 211
  return (2);
  switch_break: /* CIL Label */ ;
  }
  {
#line 213
  tmp = common___0(state, tok);
  }
#line 213
  return (tmp);
}
}
#line 216 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlrole.c"
static int doctype0___0(PROLOG_STATE *state , int tok , char const   *ptr , char const   *end ,
                        ENCODING const   *enc ) 
{ 
  int tmp ;

  {
  {
#line 224
  if (tok == 15) {
#line 224
    goto case_15;
  }
#line 227
  if (tok == 41) {
#line 227
    goto case_41;
  }
#line 227
  if (tok == 18) {
#line 227
    goto case_41;
  }
#line 223
  goto switch_break;
  case_15: /* CIL Label */ 
#line 225
  return (3);
  case_41: /* CIL Label */ 
  case_18: /* CIL Label */ 
#line 228
  state->handler = & doctype1___0;
#line 229
  return (4);
  switch_break: /* CIL Label */ ;
  }
  {
#line 231
  tmp = common___0(state, tok);
  }
#line 231
  return (tmp);
}
}
#line 234 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlrole.c"
static int doctype1___0(PROLOG_STATE *state , int tok , char const   *ptr , char const   *end ,
                        ENCODING const   *enc ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 242
  if (tok == 15) {
#line 242
    goto case_15;
  }
#line 244
  if (tok == 25) {
#line 244
    goto case_25;
  }
#line 247
  if (tok == 17) {
#line 247
    goto case_17;
  }
#line 250
  if (tok == 18) {
#line 250
    goto case_18;
  }
#line 241
  goto switch_break;
  case_15: /* CIL Label */ 
#line 243
  return (3);
  case_25: /* CIL Label */ 
#line 245
  state->handler = & internalSubset___0;
#line 246
  return (7);
  case_17: /* CIL Label */ 
#line 248
  state->handler = & prolog2___0;
#line 249
  return (8);
  case_18: /* CIL Label */ 
  {
#line 251
  tmp = (*(enc->nameMatchesAscii))(enc, ptr, end, KW_SYSTEM___0);
  }
#line 251
  if (tmp) {
#line 252
    state->handler = & doctype3___0;
#line 253
    return (3);
  }
  {
#line 255
  tmp___0 = (*(enc->nameMatchesAscii))(enc, ptr, end, KW_PUBLIC___0);
  }
#line 255
  if (tmp___0) {
#line 256
    state->handler = & doctype2___0;
#line 257
    return (3);
  }
#line 259
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 261
  tmp___1 = common___0(state, tok);
  }
#line 261
  return (tmp___1);
}
}
#line 264 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlrole.c"
static int doctype2___0(PROLOG_STATE *state , int tok , char const   *ptr , char const   *end ,
                        ENCODING const   *enc ) 
{ 
  int tmp ;

  {
  {
#line 272
  if (tok == 15) {
#line 272
    goto case_15;
  }
#line 274
  if (tok == 27) {
#line 274
    goto case_27;
  }
#line 271
  goto switch_break;
  case_15: /* CIL Label */ 
#line 273
  return (3);
  case_27: /* CIL Label */ 
#line 275
  state->handler = & doctype3___0;
#line 276
  return (6);
  switch_break: /* CIL Label */ ;
  }
  {
#line 278
  tmp = common___0(state, tok);
  }
#line 278
  return (tmp);
}
}
#line 281 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlrole.c"
static int doctype3___0(PROLOG_STATE *state , int tok , char const   *ptr , char const   *end ,
                        ENCODING const   *enc ) 
{ 
  int tmp ;

  {
  {
#line 289
  if (tok == 15) {
#line 289
    goto case_15;
  }
#line 291
  if (tok == 27) {
#line 291
    goto case_27;
  }
#line 288
  goto switch_break;
  case_15: /* CIL Label */ 
#line 290
  return (3);
  case_27: /* CIL Label */ 
#line 292
  state->handler = & doctype4___0;
#line 293
  return (5);
  switch_break: /* CIL Label */ ;
  }
  {
#line 295
  tmp = common___0(state, tok);
  }
#line 295
  return (tmp);
}
}
#line 298 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlrole.c"
static int doctype4___0(PROLOG_STATE *state , int tok , char const   *ptr , char const   *end ,
                        ENCODING const   *enc ) 
{ 
  int tmp ;

  {
  {
#line 306
  if (tok == 15) {
#line 306
    goto case_15;
  }
#line 308
  if (tok == 25) {
#line 308
    goto case_25;
  }
#line 311
  if (tok == 17) {
#line 311
    goto case_17;
  }
#line 305
  goto switch_break;
  case_15: /* CIL Label */ 
#line 307
  return (3);
  case_25: /* CIL Label */ 
#line 309
  state->handler = & internalSubset___0;
#line 310
  return (7);
  case_17: /* CIL Label */ 
#line 312
  state->handler = & prolog2___0;
#line 313
  return (8);
  switch_break: /* CIL Label */ ;
  }
  {
#line 315
  tmp = common___0(state, tok);
  }
#line 315
  return (tmp);
}
}
#line 318 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlrole.c"
static int doctype5___0(PROLOG_STATE *state , int tok , char const   *ptr , char const   *end ,
                        ENCODING const   *enc ) 
{ 
  int tmp ;

  {
  {
#line 326
  if (tok == 15) {
#line 326
    goto case_15;
  }
#line 328
  if (tok == 17) {
#line 328
    goto case_17;
  }
#line 325
  goto switch_break;
  case_15: /* CIL Label */ 
#line 327
  return (3);
  case_17: /* CIL Label */ 
#line 329
  state->handler = & prolog2___0;
#line 330
  return (8);
  switch_break: /* CIL Label */ ;
  }
  {
#line 332
  tmp = common___0(state, tok);
  }
#line 332
  return (tmp);
}
}
#line 335 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlrole.c"
static int internalSubset___0(PROLOG_STATE *state , int tok , char const   *ptr ,
                              char const   *end , ENCODING const   *enc ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  {
#line 343
  if (tok == 15) {
#line 343
    goto case_15;
  }
#line 345
  if (tok == 16) {
#line 345
    goto case_16;
  }
#line 375
  if (tok == 11) {
#line 375
    goto case_11;
  }
#line 377
  if (tok == 13) {
#line 377
    goto case_13;
  }
#line 379
  if (tok == 28) {
#line 379
    goto case_28;
  }
#line 381
  if (tok == 26) {
#line 381
    goto case_26;
  }
#line 384
  if (tok == -4) {
#line 384
    goto case_neg_4;
  }
#line 342
  goto switch_break;
  case_15: /* CIL Label */ 
#line 344
  return (0);
  case_16: /* CIL Label */ 
  {
#line 346
  tmp = (*(enc->nameMatchesAscii))(enc, ptr + 2 * (int )enc->minBytesPerChar, end,
                                   KW_ENTITY___0);
  }
#line 346
  if (tmp) {
#line 350
    state->handler = & entity0___0;
#line 351
    return (11);
  }
  {
#line 353
  tmp___0 = (*(enc->nameMatchesAscii))(enc, ptr + 2 * (int )enc->minBytesPerChar,
                                       end, KW_ATTLIST___0);
  }
#line 353
  if (tmp___0) {
#line 357
    state->handler = & attlist0___0;
#line 358
    return (33);
  }
  {
#line 360
  tmp___1 = (*(enc->nameMatchesAscii))(enc, ptr + 2 * (int )enc->minBytesPerChar,
                                       end, KW_ELEMENT___0);
  }
#line 360
  if (tmp___1) {
#line 364
    state->handler = & element0___0;
#line 365
    return (39);
  }
  {
#line 367
  tmp___2 = (*(enc->nameMatchesAscii))(enc, ptr + 2 * (int )enc->minBytesPerChar,
                                       end, KW_NOTATION___0);
  }
#line 367
  if (tmp___2) {
#line 371
    state->handler = & notation0___0;
#line 372
    return (17);
  }
#line 374
  goto switch_break;
  case_11: /* CIL Label */ 
#line 376
  return (55);
  case_13: /* CIL Label */ 
#line 378
  return (56);
  case_28: /* CIL Label */ 
#line 380
  return (60);
  case_26: /* CIL Label */ 
#line 382
  state->handler = & doctype5___0;
#line 383
  return (3);
  case_neg_4: /* CIL Label */ 
#line 385
  return (0);
  switch_break: /* CIL Label */ ;
  }
  {
#line 387
  tmp___3 = common___0(state, tok);
  }
#line 387
  return (tmp___3);
}
}
#line 392 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlrole.c"
static int externalSubset0___0(PROLOG_STATE *state , int tok , char const   *ptr ,
                               char const   *end , ENCODING const   *enc ) 
{ 
  int tmp ;

  {
#line 399
  state->handler = & externalSubset1___0;
#line 400
  if (tok == 12) {
#line 401
    return (57);
  }
  {
#line 402
  tmp = externalSubset1___0(state, tok, ptr, end, enc);
  }
#line 402
  return (tmp);
}
}
#line 405 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlrole.c"
static int externalSubset1___0(PROLOG_STATE *state , int tok , char const   *ptr ,
                               char const   *end , ENCODING const   *enc ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  {
#line 413
  if (tok == 33) {
#line 413
    goto case_33;
  }
#line 416
  if (tok == 34) {
#line 416
    goto case_34;
  }
#line 421
  if (tok == 15) {
#line 421
    goto case_15;
  }
#line 423
  if (tok == 26) {
#line 423
    goto case_26;
  }
#line 425
  if (tok == -4) {
#line 425
    goto case_neg_4;
  }
#line 429
  goto switch_default;
  case_33: /* CIL Label */ 
#line 414
  state->handler = & condSect0___0;
#line 415
  return (0);
  case_34: /* CIL Label */ 
#line 417
  if (state->includeLevel == 0U) {
#line 418
    goto switch_break;
  }
#line 419
  (state->includeLevel) --;
#line 420
  return (0);
  case_15: /* CIL Label */ 
#line 422
  return (0);
  case_26: /* CIL Label */ 
#line 424
  goto switch_break;
  case_neg_4: /* CIL Label */ 
#line 426
  if (state->includeLevel) {
#line 427
    goto switch_break;
  }
#line 428
  return (0);
  switch_default: /* CIL Label */ 
  {
#line 430
  tmp = internalSubset___0(state, tok, ptr, end, enc);
  }
#line 430
  return (tmp);
  switch_break: /* CIL Label */ ;
  }
  {
#line 432
  tmp___0 = common___0(state, tok);
  }
#line 432
  return (tmp___0);
}
}
#line 437 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlrole.c"
static int entity0___0(PROLOG_STATE *state , int tok , char const   *ptr , char const   *end ,
                       ENCODING const   *enc ) 
{ 
  int tmp ;

  {
  {
#line 445
  if (tok == 15) {
#line 445
    goto case_15;
  }
#line 447
  if (tok == 22) {
#line 447
    goto case_22;
  }
#line 450
  if (tok == 18) {
#line 450
    goto case_18;
  }
#line 444
  goto switch_break;
  case_15: /* CIL Label */ 
#line 446
  return (11);
  case_22: /* CIL Label */ 
#line 448
  state->handler = & entity1___0;
#line 449
  return (11);
  case_18: /* CIL Label */ 
#line 451
  state->handler = & entity2___0;
#line 452
  return (9);
  switch_break: /* CIL Label */ ;
  }
  {
#line 454
  tmp = common___0(state, tok);
  }
#line 454
  return (tmp);
}
}
#line 457 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlrole.c"
static int entity1___0(PROLOG_STATE *state , int tok , char const   *ptr , char const   *end ,
                       ENCODING const   *enc ) 
{ 
  int tmp ;

  {
  {
#line 465
  if (tok == 15) {
#line 465
    goto case_15;
  }
#line 467
  if (tok == 18) {
#line 467
    goto case_18;
  }
#line 464
  goto switch_break;
  case_15: /* CIL Label */ 
#line 466
  return (11);
  case_18: /* CIL Label */ 
#line 468
  state->handler = & entity7___0;
#line 469
  return (10);
  switch_break: /* CIL Label */ ;
  }
  {
#line 471
  tmp = common___0(state, tok);
  }
#line 471
  return (tmp);
}
}
#line 474 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlrole.c"
static int entity2___0(PROLOG_STATE *state , int tok , char const   *ptr , char const   *end ,
                       ENCODING const   *enc ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 482
  if (tok == 15) {
#line 482
    goto case_15;
  }
#line 484
  if (tok == 18) {
#line 484
    goto case_18;
  }
#line 494
  if (tok == 27) {
#line 494
    goto case_27;
  }
#line 481
  goto switch_break;
  case_15: /* CIL Label */ 
#line 483
  return (11);
  case_18: /* CIL Label */ 
  {
#line 485
  tmp = (*(enc->nameMatchesAscii))(enc, ptr, end, KW_SYSTEM___0);
  }
#line 485
  if (tmp) {
#line 486
    state->handler = & entity4___0;
#line 487
    return (11);
  }
  {
#line 489
  tmp___0 = (*(enc->nameMatchesAscii))(enc, ptr, end, KW_PUBLIC___0);
  }
#line 489
  if (tmp___0) {
#line 490
    state->handler = & entity3___0;
#line 491
    return (11);
  }
#line 493
  goto switch_break;
  case_27: /* CIL Label */ 
#line 495
  state->handler = & declClose___0;
#line 496
  state->role_none = 11;
#line 497
  return (12);
  switch_break: /* CIL Label */ ;
  }
  {
#line 499
  tmp___1 = common___0(state, tok);
  }
#line 499
  return (tmp___1);
}
}
#line 502 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlrole.c"
static int entity3___0(PROLOG_STATE *state , int tok , char const   *ptr , char const   *end ,
                       ENCODING const   *enc ) 
{ 
  int tmp ;

  {
  {
#line 510
  if (tok == 15) {
#line 510
    goto case_15;
  }
#line 512
  if (tok == 27) {
#line 512
    goto case_27;
  }
#line 509
  goto switch_break;
  case_15: /* CIL Label */ 
#line 511
  return (11);
  case_27: /* CIL Label */ 
#line 513
  state->handler = & entity4___0;
#line 514
  return (14);
  switch_break: /* CIL Label */ ;
  }
  {
#line 516
  tmp = common___0(state, tok);
  }
#line 516
  return (tmp);
}
}
#line 519 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlrole.c"
static int entity4___0(PROLOG_STATE *state , int tok , char const   *ptr , char const   *end ,
                       ENCODING const   *enc ) 
{ 
  int tmp ;

  {
  {
#line 527
  if (tok == 15) {
#line 527
    goto case_15;
  }
#line 529
  if (tok == 27) {
#line 529
    goto case_27;
  }
#line 526
  goto switch_break;
  case_15: /* CIL Label */ 
#line 528
  return (11);
  case_27: /* CIL Label */ 
#line 530
  state->handler = & entity5___0;
#line 531
  return (13);
  switch_break: /* CIL Label */ ;
  }
  {
#line 533
  tmp = common___0(state, tok);
  }
#line 533
  return (tmp);
}
}
#line 536 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlrole.c"
static int entity5___0(PROLOG_STATE *state , int tok , char const   *ptr , char const   *end ,
                       ENCODING const   *enc ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  {
#line 544
  if (tok == 15) {
#line 544
    goto case_15;
  }
#line 546
  if (tok == 17) {
#line 546
    goto case_17;
  }
#line 549
  if (tok == 18) {
#line 549
    goto case_18;
  }
#line 543
  goto switch_break;
  case_15: /* CIL Label */ 
#line 545
  return (11);
  case_17: /* CIL Label */ 
#line 547
  if (state->documentEntity) {
#line 547
    state->handler = & internalSubset___0;
  } else {
#line 547
    state->handler = & externalSubset1___0;
  }
#line 548
  return (15);
  case_18: /* CIL Label */ 
  {
#line 550
  tmp = (*(enc->nameMatchesAscii))(enc, ptr, end, KW_NDATA___0);
  }
#line 550
  if (tmp) {
#line 551
    state->handler = & entity6___0;
#line 552
    return (11);
  }
#line 554
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 556
  tmp___0 = common___0(state, tok);
  }
#line 556
  return (tmp___0);
}
}
#line 559 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlrole.c"
static int entity6___0(PROLOG_STATE *state , int tok , char const   *ptr , char const   *end ,
                       ENCODING const   *enc ) 
{ 
  int tmp ;

  {
  {
#line 567
  if (tok == 15) {
#line 567
    goto case_15;
  }
#line 569
  if (tok == 18) {
#line 569
    goto case_18;
  }
#line 566
  goto switch_break;
  case_15: /* CIL Label */ 
#line 568
  return (11);
  case_18: /* CIL Label */ 
#line 570
  state->handler = & declClose___0;
#line 571
  state->role_none = 11;
#line 572
  return (16);
  switch_break: /* CIL Label */ ;
  }
  {
#line 574
  tmp = common___0(state, tok);
  }
#line 574
  return (tmp);
}
}
#line 577 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlrole.c"
static int entity7___0(PROLOG_STATE *state , int tok , char const   *ptr , char const   *end ,
                       ENCODING const   *enc ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 585
  if (tok == 15) {
#line 585
    goto case_15;
  }
#line 587
  if (tok == 18) {
#line 587
    goto case_18;
  }
#line 597
  if (tok == 27) {
#line 597
    goto case_27;
  }
#line 584
  goto switch_break;
  case_15: /* CIL Label */ 
#line 586
  return (11);
  case_18: /* CIL Label */ 
  {
#line 588
  tmp = (*(enc->nameMatchesAscii))(enc, ptr, end, KW_SYSTEM___0);
  }
#line 588
  if (tmp) {
#line 589
    state->handler = & entity9___0;
#line 590
    return (11);
  }
  {
#line 592
  tmp___0 = (*(enc->nameMatchesAscii))(enc, ptr, end, KW_PUBLIC___0);
  }
#line 592
  if (tmp___0) {
#line 593
    state->handler = & entity8___0;
#line 594
    return (11);
  }
#line 596
  goto switch_break;
  case_27: /* CIL Label */ 
#line 598
  state->handler = & declClose___0;
#line 599
  state->role_none = 11;
#line 600
  return (12);
  switch_break: /* CIL Label */ ;
  }
  {
#line 602
  tmp___1 = common___0(state, tok);
  }
#line 602
  return (tmp___1);
}
}
#line 605 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlrole.c"
static int entity8___0(PROLOG_STATE *state , int tok , char const   *ptr , char const   *end ,
                       ENCODING const   *enc ) 
{ 
  int tmp ;

  {
  {
#line 613
  if (tok == 15) {
#line 613
    goto case_15;
  }
#line 615
  if (tok == 27) {
#line 615
    goto case_27;
  }
#line 612
  goto switch_break;
  case_15: /* CIL Label */ 
#line 614
  return (11);
  case_27: /* CIL Label */ 
#line 616
  state->handler = & entity9___0;
#line 617
  return (14);
  switch_break: /* CIL Label */ ;
  }
  {
#line 619
  tmp = common___0(state, tok);
  }
#line 619
  return (tmp);
}
}
#line 622 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlrole.c"
static int entity9___0(PROLOG_STATE *state , int tok , char const   *ptr , char const   *end ,
                       ENCODING const   *enc ) 
{ 
  int tmp ;

  {
  {
#line 630
  if (tok == 15) {
#line 630
    goto case_15;
  }
#line 632
  if (tok == 27) {
#line 632
    goto case_27;
  }
#line 629
  goto switch_break;
  case_15: /* CIL Label */ 
#line 631
  return (11);
  case_27: /* CIL Label */ 
#line 633
  state->handler = & entity10___0;
#line 634
  return (13);
  switch_break: /* CIL Label */ ;
  }
  {
#line 636
  tmp = common___0(state, tok);
  }
#line 636
  return (tmp);
}
}
#line 639 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlrole.c"
static int entity10___0(PROLOG_STATE *state , int tok , char const   *ptr , char const   *end ,
                        ENCODING const   *enc ) 
{ 
  int tmp ;

  {
  {
#line 647
  if (tok == 15) {
#line 647
    goto case_15;
  }
#line 649
  if (tok == 17) {
#line 649
    goto case_17;
  }
#line 646
  goto switch_break;
  case_15: /* CIL Label */ 
#line 648
  return (11);
  case_17: /* CIL Label */ 
#line 650
  if (state->documentEntity) {
#line 650
    state->handler = & internalSubset___0;
  } else {
#line 650
    state->handler = & externalSubset1___0;
  }
#line 651
  return (15);
  switch_break: /* CIL Label */ ;
  }
  {
#line 653
  tmp = common___0(state, tok);
  }
#line 653
  return (tmp);
}
}
#line 656 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlrole.c"
static int notation0___0(PROLOG_STATE *state , int tok , char const   *ptr , char const   *end ,
                         ENCODING const   *enc ) 
{ 
  int tmp ;

  {
  {
#line 664
  if (tok == 15) {
#line 664
    goto case_15;
  }
#line 666
  if (tok == 18) {
#line 666
    goto case_18;
  }
#line 663
  goto switch_break;
  case_15: /* CIL Label */ 
#line 665
  return (17);
  case_18: /* CIL Label */ 
#line 667
  state->handler = & notation1___0;
#line 668
  return (18);
  switch_break: /* CIL Label */ ;
  }
  {
#line 670
  tmp = common___0(state, tok);
  }
#line 670
  return (tmp);
}
}
#line 673 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlrole.c"
static int notation1___0(PROLOG_STATE *state , int tok , char const   *ptr , char const   *end ,
                         ENCODING const   *enc ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 681
  if (tok == 15) {
#line 681
    goto case_15;
  }
#line 683
  if (tok == 18) {
#line 683
    goto case_18;
  }
#line 680
  goto switch_break;
  case_15: /* CIL Label */ 
#line 682
  return (17);
  case_18: /* CIL Label */ 
  {
#line 684
  tmp = (*(enc->nameMatchesAscii))(enc, ptr, end, KW_SYSTEM___0);
  }
#line 684
  if (tmp) {
#line 685
    state->handler = & notation3___0;
#line 686
    return (17);
  }
  {
#line 688
  tmp___0 = (*(enc->nameMatchesAscii))(enc, ptr, end, KW_PUBLIC___0);
  }
#line 688
  if (tmp___0) {
#line 689
    state->handler = & notation2___0;
#line 690
    return (17);
  }
#line 692
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 694
  tmp___1 = common___0(state, tok);
  }
#line 694
  return (tmp___1);
}
}
#line 697 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlrole.c"
static int notation2___0(PROLOG_STATE *state , int tok , char const   *ptr , char const   *end ,
                         ENCODING const   *enc ) 
{ 
  int tmp ;

  {
  {
#line 705
  if (tok == 15) {
#line 705
    goto case_15;
  }
#line 707
  if (tok == 27) {
#line 707
    goto case_27;
  }
#line 704
  goto switch_break;
  case_15: /* CIL Label */ 
#line 706
  return (17);
  case_27: /* CIL Label */ 
#line 708
  state->handler = & notation4___0;
#line 709
  return (21);
  switch_break: /* CIL Label */ ;
  }
  {
#line 711
  tmp = common___0(state, tok);
  }
#line 711
  return (tmp);
}
}
#line 714 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlrole.c"
static int notation3___0(PROLOG_STATE *state , int tok , char const   *ptr , char const   *end ,
                         ENCODING const   *enc ) 
{ 
  int tmp ;

  {
  {
#line 722
  if (tok == 15) {
#line 722
    goto case_15;
  }
#line 724
  if (tok == 27) {
#line 724
    goto case_27;
  }
#line 721
  goto switch_break;
  case_15: /* CIL Label */ 
#line 723
  return (17);
  case_27: /* CIL Label */ 
#line 725
  state->handler = & declClose___0;
#line 726
  state->role_none = 17;
#line 727
  return (19);
  switch_break: /* CIL Label */ ;
  }
  {
#line 729
  tmp = common___0(state, tok);
  }
#line 729
  return (tmp);
}
}
#line 732 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlrole.c"
static int notation4___0(PROLOG_STATE *state , int tok , char const   *ptr , char const   *end ,
                         ENCODING const   *enc ) 
{ 
  int tmp ;

  {
  {
#line 740
  if (tok == 15) {
#line 740
    goto case_15;
  }
#line 742
  if (tok == 27) {
#line 742
    goto case_27;
  }
#line 746
  if (tok == 17) {
#line 746
    goto case_17;
  }
#line 739
  goto switch_break;
  case_15: /* CIL Label */ 
#line 741
  return (17);
  case_27: /* CIL Label */ 
#line 743
  state->handler = & declClose___0;
#line 744
  state->role_none = 17;
#line 745
  return (19);
  case_17: /* CIL Label */ 
#line 747
  if (state->documentEntity) {
#line 747
    state->handler = & internalSubset___0;
  } else {
#line 747
    state->handler = & externalSubset1___0;
  }
#line 748
  return (20);
  switch_break: /* CIL Label */ ;
  }
  {
#line 750
  tmp = common___0(state, tok);
  }
#line 750
  return (tmp);
}
}
#line 753 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlrole.c"
static int attlist0___0(PROLOG_STATE *state , int tok , char const   *ptr , char const   *end ,
                        ENCODING const   *enc ) 
{ 
  int tmp ;

  {
  {
#line 761
  if (tok == 15) {
#line 761
    goto case_15;
  }
#line 764
  if (tok == 41) {
#line 764
    goto case_41;
  }
#line 764
  if (tok == 18) {
#line 764
    goto case_41;
  }
#line 760
  goto switch_break;
  case_15: /* CIL Label */ 
#line 762
  return (33);
  case_41: /* CIL Label */ 
  case_18: /* CIL Label */ 
#line 765
  state->handler = & attlist1___0;
#line 766
  return (34);
  switch_break: /* CIL Label */ ;
  }
  {
#line 768
  tmp = common___0(state, tok);
  }
#line 768
  return (tmp);
}
}
#line 771 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlrole.c"
static int attlist1___0(PROLOG_STATE *state , int tok , char const   *ptr , char const   *end ,
                        ENCODING const   *enc ) 
{ 
  int tmp ;

  {
  {
#line 779
  if (tok == 15) {
#line 779
    goto case_15;
  }
#line 781
  if (tok == 17) {
#line 781
    goto case_17;
  }
#line 785
  if (tok == 41) {
#line 785
    goto case_41;
  }
#line 785
  if (tok == 18) {
#line 785
    goto case_41;
  }
#line 778
  goto switch_break;
  case_15: /* CIL Label */ 
#line 780
  return (33);
  case_17: /* CIL Label */ 
#line 782
  if (state->documentEntity) {
#line 782
    state->handler = & internalSubset___0;
  } else {
#line 782
    state->handler = & externalSubset1___0;
  }
#line 783
  return (33);
  case_41: /* CIL Label */ 
  case_18: /* CIL Label */ 
#line 786
  state->handler = & attlist2___0;
#line 787
  return (22);
  switch_break: /* CIL Label */ ;
  }
  {
#line 789
  tmp = common___0(state, tok);
  }
#line 789
  return (tmp);
}
}
#line 804 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlrole.c"
static char const   * const  types___0[8]  = 
#line 804
  {      (char const   */* const  */)(KW_CDATA___0),      (char const   */* const  */)(KW_ID___0),      (char const   */* const  */)(KW_IDREF___0),      (char const   */* const  */)(KW_IDREFS___0), 
        (char const   */* const  */)(KW_ENTITY___0),      (char const   */* const  */)(KW_ENTITIES___0),      (char const   */* const  */)(KW_NMTOKEN___0),      (char const   */* const  */)(KW_NMTOKENS___0)};
#line 792 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlrole.c"
static int attlist2___0(PROLOG_STATE *state , int tok , char const   *ptr , char const   *end ,
                        ENCODING const   *enc ) 
{ 
  int i ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 800
  if (tok == 15) {
#line 800
    goto case_15;
  }
#line 802
  if (tok == 18) {
#line 802
    goto case_18;
  }
#line 826
  if (tok == 23) {
#line 826
    goto case_23;
  }
#line 799
  goto switch_break;
  case_15: /* CIL Label */ 
#line 801
  return (33);
  case_18: /* CIL Label */ 
#line 815
  i = 0;
  {
#line 815
  while (1) {
    while_continue: /* CIL Label */ ;
#line 815
    if (! (i < (int )(sizeof(types___0) / sizeof(types___0[0])))) {
#line 815
      goto while_break;
    }
    {
#line 816
    tmp = (*(enc->nameMatchesAscii))(enc, ptr, end, (char const   *)types___0[i]);
    }
#line 816
    if (tmp) {
#line 817
      state->handler = & attlist8___0;
#line 818
      return (23 + i);
    }
#line 815
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 821
  tmp___0 = (*(enc->nameMatchesAscii))(enc, ptr, end, KW_NOTATION___0);
  }
#line 821
  if (tmp___0) {
#line 822
    state->handler = & attlist5___0;
#line 823
    return (33);
  }
#line 825
  goto switch_break;
  case_23: /* CIL Label */ 
#line 827
  state->handler = & attlist3___0;
#line 828
  return (33);
  switch_break: /* CIL Label */ ;
  }
  {
#line 830
  tmp___1 = common___0(state, tok);
  }
#line 830
  return (tmp___1);
}
}
#line 833 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlrole.c"
static int attlist3___0(PROLOG_STATE *state , int tok , char const   *ptr , char const   *end ,
                        ENCODING const   *enc ) 
{ 
  int tmp ;

  {
  {
#line 841
  if (tok == 15) {
#line 841
    goto case_15;
  }
#line 845
  if (tok == 41) {
#line 845
    goto case_41;
  }
#line 845
  if (tok == 18) {
#line 845
    goto case_41;
  }
#line 845
  if (tok == 19) {
#line 845
    goto case_41;
  }
#line 840
  goto switch_break;
  case_15: /* CIL Label */ 
#line 842
  return (33);
  case_41: /* CIL Label */ 
  case_18: /* CIL Label */ 
  case_19: /* CIL Label */ 
#line 846
  state->handler = & attlist4___0;
#line 847
  return (31);
  switch_break: /* CIL Label */ ;
  }
  {
#line 849
  tmp = common___0(state, tok);
  }
#line 849
  return (tmp);
}
}
#line 852 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlrole.c"
static int attlist4___0(PROLOG_STATE *state , int tok , char const   *ptr , char const   *end ,
                        ENCODING const   *enc ) 
{ 
  int tmp ;

  {
  {
#line 860
  if (tok == 15) {
#line 860
    goto case_15;
  }
#line 862
  if (tok == 24) {
#line 862
    goto case_24;
  }
#line 865
  if (tok == 21) {
#line 865
    goto case_21;
  }
#line 859
  goto switch_break;
  case_15: /* CIL Label */ 
#line 861
  return (33);
  case_24: /* CIL Label */ 
#line 863
  state->handler = & attlist8___0;
#line 864
  return (33);
  case_21: /* CIL Label */ 
#line 866
  state->handler = & attlist3___0;
#line 867
  return (33);
  switch_break: /* CIL Label */ ;
  }
  {
#line 869
  tmp = common___0(state, tok);
  }
#line 869
  return (tmp);
}
}
#line 872 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlrole.c"
static int attlist5___0(PROLOG_STATE *state , int tok , char const   *ptr , char const   *end ,
                        ENCODING const   *enc ) 
{ 
  int tmp ;

  {
  {
#line 880
  if (tok == 15) {
#line 880
    goto case_15;
  }
#line 882
  if (tok == 23) {
#line 882
    goto case_23;
  }
#line 879
  goto switch_break;
  case_15: /* CIL Label */ 
#line 881
  return (33);
  case_23: /* CIL Label */ 
#line 883
  state->handler = & attlist6___0;
#line 884
  return (33);
  switch_break: /* CIL Label */ ;
  }
  {
#line 886
  tmp = common___0(state, tok);
  }
#line 886
  return (tmp);
}
}
#line 889 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlrole.c"
static int attlist6___0(PROLOG_STATE *state , int tok , char const   *ptr , char const   *end ,
                        ENCODING const   *enc ) 
{ 
  int tmp ;

  {
  {
#line 897
  if (tok == 15) {
#line 897
    goto case_15;
  }
#line 899
  if (tok == 18) {
#line 899
    goto case_18;
  }
#line 896
  goto switch_break;
  case_15: /* CIL Label */ 
#line 898
  return (33);
  case_18: /* CIL Label */ 
#line 900
  state->handler = & attlist7___0;
#line 901
  return (32);
  switch_break: /* CIL Label */ ;
  }
  {
#line 903
  tmp = common___0(state, tok);
  }
#line 903
  return (tmp);
}
}
#line 906 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlrole.c"
static int attlist7___0(PROLOG_STATE *state , int tok , char const   *ptr , char const   *end ,
                        ENCODING const   *enc ) 
{ 
  int tmp ;

  {
  {
#line 914
  if (tok == 15) {
#line 914
    goto case_15;
  }
#line 916
  if (tok == 24) {
#line 916
    goto case_24;
  }
#line 919
  if (tok == 21) {
#line 919
    goto case_21;
  }
#line 913
  goto switch_break;
  case_15: /* CIL Label */ 
#line 915
  return (33);
  case_24: /* CIL Label */ 
#line 917
  state->handler = & attlist8___0;
#line 918
  return (33);
  case_21: /* CIL Label */ 
#line 920
  state->handler = & attlist6___0;
#line 921
  return (33);
  switch_break: /* CIL Label */ ;
  }
  {
#line 923
  tmp = common___0(state, tok);
  }
#line 923
  return (tmp);
}
}
#line 927 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlrole.c"
static int attlist8___0(PROLOG_STATE *state , int tok , char const   *ptr , char const   *end ,
                        ENCODING const   *enc ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 935
  if (tok == 15) {
#line 935
    goto case_15;
  }
#line 937
  if (tok == 20) {
#line 937
    goto case_20;
  }
#line 960
  if (tok == 27) {
#line 960
    goto case_27;
  }
#line 934
  goto switch_break;
  case_15: /* CIL Label */ 
#line 936
  return (33);
  case_20: /* CIL Label */ 
  {
#line 938
  tmp = (*(enc->nameMatchesAscii))(enc, ptr + enc->minBytesPerChar, end, KW_IMPLIED___0);
  }
#line 938
  if (tmp) {
#line 942
    state->handler = & attlist1___0;
#line 943
    return (35);
  }
  {
#line 945
  tmp___0 = (*(enc->nameMatchesAscii))(enc, ptr + enc->minBytesPerChar, end, KW_REQUIRED___0);
  }
#line 945
  if (tmp___0) {
#line 949
    state->handler = & attlist1___0;
#line 950
    return (36);
  }
  {
#line 952
  tmp___1 = (*(enc->nameMatchesAscii))(enc, ptr + enc->minBytesPerChar, end, KW_FIXED___0);
  }
#line 952
  if (tmp___1) {
#line 956
    state->handler = & attlist9___0;
#line 957
    return (33);
  }
#line 959
  goto switch_break;
  case_27: /* CIL Label */ 
#line 961
  state->handler = & attlist1___0;
#line 962
  return (37);
  switch_break: /* CIL Label */ ;
  }
  {
#line 964
  tmp___2 = common___0(state, tok);
  }
#line 964
  return (tmp___2);
}
}
#line 967 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlrole.c"
static int attlist9___0(PROLOG_STATE *state , int tok , char const   *ptr , char const   *end ,
                        ENCODING const   *enc ) 
{ 
  int tmp ;

  {
  {
#line 975
  if (tok == 15) {
#line 975
    goto case_15;
  }
#line 977
  if (tok == 27) {
#line 977
    goto case_27;
  }
#line 974
  goto switch_break;
  case_15: /* CIL Label */ 
#line 976
  return (33);
  case_27: /* CIL Label */ 
#line 978
  state->handler = & attlist1___0;
#line 979
  return (38);
  switch_break: /* CIL Label */ ;
  }
  {
#line 981
  tmp = common___0(state, tok);
  }
#line 981
  return (tmp);
}
}
#line 984 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlrole.c"
static int element0___0(PROLOG_STATE *state , int tok , char const   *ptr , char const   *end ,
                        ENCODING const   *enc ) 
{ 
  int tmp ;

  {
  {
#line 992
  if (tok == 15) {
#line 992
    goto case_15;
  }
#line 995
  if (tok == 41) {
#line 995
    goto case_41;
  }
#line 995
  if (tok == 18) {
#line 995
    goto case_41;
  }
#line 991
  goto switch_break;
  case_15: /* CIL Label */ 
#line 993
  return (39);
  case_41: /* CIL Label */ 
  case_18: /* CIL Label */ 
#line 996
  state->handler = & element1___0;
#line 997
  return (40);
  switch_break: /* CIL Label */ ;
  }
  {
#line 999
  tmp = common___0(state, tok);
  }
#line 999
  return (tmp);
}
}
#line 1002 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlrole.c"
static int element1___0(PROLOG_STATE *state , int tok , char const   *ptr , char const   *end ,
                        ENCODING const   *enc ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 1010
  if (tok == 15) {
#line 1010
    goto case_15;
  }
#line 1012
  if (tok == 18) {
#line 1012
    goto case_18;
  }
#line 1024
  if (tok == 23) {
#line 1024
    goto case_23;
  }
#line 1009
  goto switch_break;
  case_15: /* CIL Label */ 
#line 1011
  return (39);
  case_18: /* CIL Label */ 
  {
#line 1013
  tmp = (*(enc->nameMatchesAscii))(enc, ptr, end, KW_EMPTY___0);
  }
#line 1013
  if (tmp) {
#line 1014
    state->handler = & declClose___0;
#line 1015
    state->role_none = 39;
#line 1016
    return (42);
  }
  {
#line 1018
  tmp___0 = (*(enc->nameMatchesAscii))(enc, ptr, end, KW_ANY___0);
  }
#line 1018
  if (tmp___0) {
#line 1019
    state->handler = & declClose___0;
#line 1020
    state->role_none = 39;
#line 1021
    return (41);
  }
#line 1023
  goto switch_break;
  case_23: /* CIL Label */ 
#line 1025
  state->handler = & element2___0;
#line 1026
  state->level = 1U;
#line 1027
  return (44);
  switch_break: /* CIL Label */ ;
  }
  {
#line 1029
  tmp___1 = common___0(state, tok);
  }
#line 1029
  return (tmp___1);
}
}
#line 1032 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlrole.c"
static int element2___0(PROLOG_STATE *state , int tok , char const   *ptr , char const   *end ,
                        ENCODING const   *enc ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  {
#line 1040
  if (tok == 15) {
#line 1040
    goto case_15;
  }
#line 1042
  if (tok == 20) {
#line 1042
    goto case_20;
  }
#line 1051
  if (tok == 23) {
#line 1051
    goto case_23;
  }
#line 1056
  if (tok == 41) {
#line 1056
    goto case_41;
  }
#line 1056
  if (tok == 18) {
#line 1056
    goto case_41;
  }
#line 1059
  if (tok == 30) {
#line 1059
    goto case_30;
  }
#line 1062
  if (tok == 31) {
#line 1062
    goto case_31;
  }
#line 1065
  if (tok == 32) {
#line 1065
    goto case_32;
  }
#line 1039
  goto switch_break;
  case_15: /* CIL Label */ 
#line 1041
  return (39);
  case_20: /* CIL Label */ 
  {
#line 1043
  tmp = (*(enc->nameMatchesAscii))(enc, ptr + enc->minBytesPerChar, end, KW_PCDATA___0);
  }
#line 1043
  if (tmp) {
#line 1047
    state->handler = & element3___0;
#line 1048
    return (43);
  }
#line 1050
  goto switch_break;
  case_23: /* CIL Label */ 
#line 1052
  state->level = 2U;
#line 1053
  state->handler = & element6___0;
#line 1054
  return (44);
  case_41: /* CIL Label */ 
  case_18: /* CIL Label */ 
#line 1057
  state->handler = & element7___0;
#line 1058
  return (51);
  case_30: /* CIL Label */ 
#line 1060
  state->handler = & element7___0;
#line 1061
  return (53);
  case_31: /* CIL Label */ 
#line 1063
  state->handler = & element7___0;
#line 1064
  return (52);
  case_32: /* CIL Label */ 
#line 1066
  state->handler = & element7___0;
#line 1067
  return (54);
  switch_break: /* CIL Label */ ;
  }
  {
#line 1069
  tmp___0 = common___0(state, tok);
  }
#line 1069
  return (tmp___0);
}
}
#line 1072 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlrole.c"
static int element3___0(PROLOG_STATE *state , int tok , char const   *ptr , char const   *end ,
                        ENCODING const   *enc ) 
{ 
  int tmp ;

  {
  {
#line 1080
  if (tok == 15) {
#line 1080
    goto case_15;
  }
#line 1082
  if (tok == 24) {
#line 1082
    goto case_24;
  }
#line 1086
  if (tok == 36) {
#line 1086
    goto case_36;
  }
#line 1090
  if (tok == 21) {
#line 1090
    goto case_21;
  }
#line 1079
  goto switch_break;
  case_15: /* CIL Label */ 
#line 1081
  return (39);
  case_24: /* CIL Label */ 
#line 1083
  state->handler = & declClose___0;
#line 1084
  state->role_none = 39;
#line 1085
  return (45);
  case_36: /* CIL Label */ 
#line 1087
  state->handler = & declClose___0;
#line 1088
  state->role_none = 39;
#line 1089
  return (46);
  case_21: /* CIL Label */ 
#line 1091
  state->handler = & element4___0;
#line 1092
  return (39);
  switch_break: /* CIL Label */ ;
  }
  {
#line 1094
  tmp = common___0(state, tok);
  }
#line 1094
  return (tmp);
}
}
#line 1097 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlrole.c"
static int element4___0(PROLOG_STATE *state , int tok , char const   *ptr , char const   *end ,
                        ENCODING const   *enc ) 
{ 
  int tmp ;

  {
  {
#line 1105
  if (tok == 15) {
#line 1105
    goto case_15;
  }
#line 1108
  if (tok == 41) {
#line 1108
    goto case_41;
  }
#line 1108
  if (tok == 18) {
#line 1108
    goto case_41;
  }
#line 1104
  goto switch_break;
  case_15: /* CIL Label */ 
#line 1106
  return (39);
  case_41: /* CIL Label */ 
  case_18: /* CIL Label */ 
#line 1109
  state->handler = & element5___0;
#line 1110
  return (51);
  switch_break: /* CIL Label */ ;
  }
  {
#line 1112
  tmp = common___0(state, tok);
  }
#line 1112
  return (tmp);
}
}
#line 1115 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlrole.c"
static int element5___0(PROLOG_STATE *state , int tok , char const   *ptr , char const   *end ,
                        ENCODING const   *enc ) 
{ 
  int tmp ;

  {
  {
#line 1123
  if (tok == 15) {
#line 1123
    goto case_15;
  }
#line 1125
  if (tok == 36) {
#line 1125
    goto case_36;
  }
#line 1129
  if (tok == 21) {
#line 1129
    goto case_21;
  }
#line 1122
  goto switch_break;
  case_15: /* CIL Label */ 
#line 1124
  return (39);
  case_36: /* CIL Label */ 
#line 1126
  state->handler = & declClose___0;
#line 1127
  state->role_none = 39;
#line 1128
  return (46);
  case_21: /* CIL Label */ 
#line 1130
  state->handler = & element4___0;
#line 1131
  return (39);
  switch_break: /* CIL Label */ ;
  }
  {
#line 1133
  tmp = common___0(state, tok);
  }
#line 1133
  return (tmp);
}
}
#line 1136 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlrole.c"
static int element6___0(PROLOG_STATE *state , int tok , char const   *ptr , char const   *end ,
                        ENCODING const   *enc ) 
{ 
  int tmp ;

  {
  {
#line 1144
  if (tok == 15) {
#line 1144
    goto case_15;
  }
#line 1146
  if (tok == 23) {
#line 1146
    goto case_23;
  }
#line 1150
  if (tok == 41) {
#line 1150
    goto case_41;
  }
#line 1150
  if (tok == 18) {
#line 1150
    goto case_41;
  }
#line 1153
  if (tok == 30) {
#line 1153
    goto case_30;
  }
#line 1156
  if (tok == 31) {
#line 1156
    goto case_31;
  }
#line 1159
  if (tok == 32) {
#line 1159
    goto case_32;
  }
#line 1143
  goto switch_break;
  case_15: /* CIL Label */ 
#line 1145
  return (39);
  case_23: /* CIL Label */ 
#line 1147
  (state->level) ++;
#line 1148
  return (44);
  case_41: /* CIL Label */ 
  case_18: /* CIL Label */ 
#line 1151
  state->handler = & element7___0;
#line 1152
  return (51);
  case_30: /* CIL Label */ 
#line 1154
  state->handler = & element7___0;
#line 1155
  return (53);
  case_31: /* CIL Label */ 
#line 1157
  state->handler = & element7___0;
#line 1158
  return (52);
  case_32: /* CIL Label */ 
#line 1160
  state->handler = & element7___0;
#line 1161
  return (54);
  switch_break: /* CIL Label */ ;
  }
  {
#line 1163
  tmp = common___0(state, tok);
  }
#line 1163
  return (tmp);
}
}
#line 1166 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlrole.c"
static int element7___0(PROLOG_STATE *state , int tok , char const   *ptr , char const   *end ,
                        ENCODING const   *enc ) 
{ 
  int tmp ;

  {
  {
#line 1174
  if (tok == 15) {
#line 1174
    goto case_15;
  }
#line 1176
  if (tok == 24) {
#line 1176
    goto case_24;
  }
#line 1183
  if (tok == 36) {
#line 1183
    goto case_36;
  }
#line 1190
  if (tok == 35) {
#line 1190
    goto case_35;
  }
#line 1197
  if (tok == 37) {
#line 1197
    goto case_37;
  }
#line 1204
  if (tok == 38) {
#line 1204
    goto case_38;
  }
#line 1207
  if (tok == 21) {
#line 1207
    goto case_21;
  }
#line 1173
  goto switch_break;
  case_15: /* CIL Label */ 
#line 1175
  return (39);
  case_24: /* CIL Label */ 
#line 1177
  (state->level) --;
#line 1178
  if (state->level == 0U) {
#line 1179
    state->handler = & declClose___0;
#line 1180
    state->role_none = 39;
  }
#line 1182
  return (45);
  case_36: /* CIL Label */ 
#line 1184
  (state->level) --;
#line 1185
  if (state->level == 0U) {
#line 1186
    state->handler = & declClose___0;
#line 1187
    state->role_none = 39;
  }
#line 1189
  return (46);
  case_35: /* CIL Label */ 
#line 1191
  (state->level) --;
#line 1192
  if (state->level == 0U) {
#line 1193
    state->handler = & declClose___0;
#line 1194
    state->role_none = 39;
  }
#line 1196
  return (47);
  case_37: /* CIL Label */ 
#line 1198
  (state->level) --;
#line 1199
  if (state->level == 0U) {
#line 1200
    state->handler = & declClose___0;
#line 1201
    state->role_none = 39;
  }
#line 1203
  return (48);
  case_38: /* CIL Label */ 
#line 1205
  state->handler = & element6___0;
#line 1206
  return (50);
  case_21: /* CIL Label */ 
#line 1208
  state->handler = & element6___0;
#line 1209
  return (49);
  switch_break: /* CIL Label */ ;
  }
  {
#line 1211
  tmp = common___0(state, tok);
  }
#line 1211
  return (tmp);
}
}
#line 1216 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlrole.c"
static int condSect0___0(PROLOG_STATE *state , int tok , char const   *ptr , char const   *end ,
                         ENCODING const   *enc ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 1224
  if (tok == 15) {
#line 1224
    goto case_15;
  }
#line 1226
  if (tok == 18) {
#line 1226
    goto case_18;
  }
#line 1223
  goto switch_break;
  case_15: /* CIL Label */ 
#line 1225
  return (0);
  case_18: /* CIL Label */ 
  {
#line 1227
  tmp = (*(enc->nameMatchesAscii))(enc, ptr, end, KW_INCLUDE___0);
  }
#line 1227
  if (tmp) {
#line 1228
    state->handler = & condSect1___0;
#line 1229
    return (0);
  }
  {
#line 1231
  tmp___0 = (*(enc->nameMatchesAscii))(enc, ptr, end, KW_IGNORE___0);
  }
#line 1231
  if (tmp___0) {
#line 1232
    state->handler = & condSect2___0;
#line 1233
    return (0);
  }
#line 1235
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 1237
  tmp___1 = common___0(state, tok);
  }
#line 1237
  return (tmp___1);
}
}
#line 1240 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlrole.c"
static int condSect1___0(PROLOG_STATE *state , int tok , char const   *ptr , char const   *end ,
                         ENCODING const   *enc ) 
{ 
  int tmp ;

  {
  {
#line 1248
  if (tok == 15) {
#line 1248
    goto case_15;
  }
#line 1250
  if (tok == 25) {
#line 1250
    goto case_25;
  }
#line 1247
  goto switch_break;
  case_15: /* CIL Label */ 
#line 1249
  return (0);
  case_25: /* CIL Label */ 
#line 1251
  state->handler = & externalSubset1___0;
#line 1252
  (state->includeLevel) ++;
#line 1253
  return (0);
  switch_break: /* CIL Label */ ;
  }
  {
#line 1255
  tmp = common___0(state, tok);
  }
#line 1255
  return (tmp);
}
}
#line 1258 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlrole.c"
static int condSect2___0(PROLOG_STATE *state , int tok , char const   *ptr , char const   *end ,
                         ENCODING const   *enc ) 
{ 
  int tmp ;

  {
  {
#line 1266
  if (tok == 15) {
#line 1266
    goto case_15;
  }
#line 1268
  if (tok == 25) {
#line 1268
    goto case_25;
  }
#line 1265
  goto switch_break;
  case_15: /* CIL Label */ 
#line 1267
  return (0);
  case_25: /* CIL Label */ 
#line 1269
  state->handler = & externalSubset1___0;
#line 1270
  return (58);
  switch_break: /* CIL Label */ ;
  }
  {
#line 1272
  tmp = common___0(state, tok);
  }
#line 1272
  return (tmp);
}
}
#line 1277 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlrole.c"
static int declClose___0(PROLOG_STATE *state , int tok , char const   *ptr , char const   *end ,
                         ENCODING const   *enc ) 
{ 
  int tmp ;

  {
  {
#line 1285
  if (tok == 15) {
#line 1285
    goto case_15;
  }
#line 1287
  if (tok == 17) {
#line 1287
    goto case_17;
  }
#line 1284
  goto switch_break;
  case_15: /* CIL Label */ 
#line 1286
  return (state->role_none);
  case_17: /* CIL Label */ 
#line 1288
  if (state->documentEntity) {
#line 1288
    state->handler = & internalSubset___0;
  } else {
#line 1288
    state->handler = & externalSubset1___0;
  }
#line 1289
  return (state->role_none);
  switch_break: /* CIL Label */ ;
  }
  {
#line 1291
  tmp = common___0(state, tok);
  }
#line 1291
  return (tmp);
}
}
#line 1294 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlrole.c"
static int error___0(PROLOG_STATE *state , int tok , char const   *ptr , char const   *end ,
                     ENCODING const   *enc ) 
{ 


  {
#line 1301
  return (0);
}
}
#line 1304 "/home/june/repo/benchmarks/collector/temp/expat-2.1.0/lib/xmlrole.c"
static int common___0(PROLOG_STATE *state , int tok ) 
{ 


  {
#line 1308
  if (! state->documentEntity) {
#line 1308
    if (tok == 28) {
#line 1309
      return (59);
    }
  }
#line 1311
  state->handler = & error___0;
#line 1312
  return (-1);
}
}
