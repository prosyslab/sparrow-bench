/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 30 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned char __u_char;
#line 33 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __u_char u_char;
#line 196 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef int int32_t;
#line 201 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef unsigned short u_int16_t;
#line 202 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef unsigned int u_int32_t;
#line 66 "/home/june/repo/benchmarks/collector/temp/fatsort-0.9.15.245/src/FAT_fs.h"
struct sLongDirEntry {
   u_char LDIR_Ord ;
   char LDIR_Name1[10] ;
   u_char LDIR_Attr ;
   u_char LDIR_Type ;
   u_char LDIR_Checksum ;
   char LDIR_Name2[12] ;
   u_int16_t LDIR_FstClusLO ;
   char LDIR_Name3[4] ;
} __attribute__((__packed__)) ;
#line 78 "/home/june/repo/benchmarks/collector/temp/fatsort-0.9.15.245/src/FAT_fs.h"
struct sShortDirEntry {
   char DIR_Name[11] ;
   u_char DIR_Atrr ;
   u_char DIR_NTRes ;
   u_char DIR_CrtTimeTenth ;
   u_int16_t DIR_CrtTime ;
   u_int16_t DIR_CrtDate ;
   u_int16_t DIR_LstAccDate ;
   u_int16_t DIR_FstClusHI ;
   u_int16_t DIR_WrtTime ;
   u_int16_t DIR_WrtDate ;
   u_int16_t DIR_FstClusLO ;
   u_int32_t DIR_FileSize ;
} __attribute__((__packed__)) ;
#line 31 "/home/june/repo/benchmarks/collector/temp/fatsort-0.9.15.245/src/entrylist.h"
struct sLongDirEntryList {
   struct sLongDirEntry *lde ;
   struct sLongDirEntryList *next ;
};
#line 40 "/home/june/repo/benchmarks/collector/temp/fatsort-0.9.15.245/src/entrylist.h"
struct sDirEntryList {
   char *sname ;
   char *lname ;
   struct sShortDirEntry *sde ;
   struct sLongDirEntryList *ldel ;
   int32_t entries ;
   struct sDirEntryList *next ;
};
#line 31 "/home/june/repo/benchmarks/collector/temp/fatsort-0.9.15.245/src/stringlist.h"
struct sStringList {
   char *str ;
   struct sStringList *next ;
};
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 88 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __off64_t off_t;
#line 75 "/usr/include/time.h"
typedef __time_t time_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 100 "/home/june/repo/benchmarks/collector/temp/fatsort-0.9.15.245/src/FAT_fs.h"
struct sFAT12_16 {
   u_char BS_DrvNum ;
   u_char BS_Reserved ;
   u_char BS_BootSig ;
   u_int32_t BS_VolID ;
   char BS_VolLab[11] ;
   char BS_FilSysType[8] ;
   u_char unused[448] ;
} __attribute__((__packed__)) ;
#line 111 "/home/june/repo/benchmarks/collector/temp/fatsort-0.9.15.245/src/FAT_fs.h"
struct sFAT32 {
   u_int32_t BS_FATSz32 ;
   u_int16_t BS_ExtFlags ;
   u_int16_t BS_FSVer ;
   u_int32_t BS_RootClus ;
   u_int16_t BS_FSInfo ;
   u_int16_t BS_BkBootSec ;
   char BS_Reserved[12] ;
   char BS_DrvNum ;
   char BS_Reserved1 ;
   char BS_BootSig ;
   u_int32_t BS_VolID ;
   char BS_VolLab[11] ;
   char BS_FilSysType[8] ;
   u_char unused[420] ;
} __attribute__((__packed__)) ;
#line 128 "/home/june/repo/benchmarks/collector/temp/fatsort-0.9.15.245/src/FAT_fs.h"
union sFATxx {
   struct sFAT12_16 FAT12_16 ;
   struct sFAT32 FAT32 ;
} __attribute__((__packed__)) ;
#line 134 "/home/june/repo/benchmarks/collector/temp/fatsort-0.9.15.245/src/FAT_fs.h"
struct sBootSector {
   u_char BS_JmpBoot[3] ;
   char BS_OEMName[8] ;
   u_int16_t BS_BytesPerSec ;
   u_char BS_SecPerClus ;
   u_int16_t BS_RsvdSecCnt ;
   u_char BS_NumFATs ;
   u_int16_t BS_RootEntCnt ;
   u_int16_t BS_TotSec16 ;
   u_char BS_Media ;
   u_int16_t BS_FATSz16 ;
   u_int16_t BS_SecPerTrk ;
   u_int16_t BS_NumHeads ;
   u_int32_t BS_HiddSec ;
   u_int32_t BS_TotSec32 ;
   union sFATxx FATxx ;
   u_int16_t BS_EndOfBS ;
} __attribute__((__packed__)) ;
#line 27 "/usr/include/x86_64-linux-gnu/bits/sigset.h"
struct __anonstruct___sigset_t_9 {
   unsigned long __val[1024UL / (8UL * sizeof(unsigned long ))] ;
};
#line 27 "/usr/include/x86_64-linux-gnu/bits/sigset.h"
typedef struct __anonstruct___sigset_t_9 __sigset_t;
#line 37 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef __sigset_t sigset_t;
#line 34 "/home/june/repo/benchmarks/collector/temp/fatsort-0.9.15.245/src/clusterchain.h"
struct sClusterChain {
   u_int32_t cluster ;
   struct sClusterChain *next ;
};
#line 40 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stdarg.h"
typedef __builtin_va_list __gnuc_va_list;
#line 79 "/usr/include/stdio.h"
typedef __gnuc_va_list va_list;
#line 93 "/home/june/repo/benchmarks/collector/temp/fatsort-0.9.15.245/src/FAT_fs.h"
union sDirEntry {
   struct sShortDirEntry ShortDirEntry ;
   struct sLongDirEntry LongDirEntry ;
} __attribute__((__packed__)) ;
#line 194 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef signed char int8_t;
#line 29 "/usr/include/iconv.h"
typedef void *iconv_t;
#line 53 "/usr/include/mntent.h"
struct mntent {
   char *mnt_fsname ;
   char *mnt_dir ;
   char *mnt_type ;
   char *mnt_opts ;
   int mnt_freq ;
   int mnt_passno ;
};
#line 374 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) rand)(void) ;
#line 466
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 46 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memcpy)(void * __restrict  __dest ,
                                                                                                 void const   * __restrict  __src ,
                                                                                                 size_t __n ) ;
#line 66
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memset)(void *__s ,
                                                                                               int __c ,
                                                                                               size_t __n ) ;
#line 129
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcpy)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 132
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strncpy)(char * __restrict  __dest ,
                                                                                                  char const   * __restrict  __src ,
                                                                                                  size_t __n ) ;
#line 144
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 399
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 413
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) strerror)(int __errnum ) ;
#line 534
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcasecmp)(char const   *__s1 ,
                                                                                                   char const   *__s2 )  __attribute__((__pure__)) ;
#line 538
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strncasecmp)(char const   *__s1 ,
                                                                                                    char const   *__s2 ,
                                                                                                    size_t __n )  __attribute__((__pure__)) ;
#line 69 "/usr/include/assert.h"
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) __assert_fail)(char const   *__assertion ,
                                                                                                   char const   *__file ,
                                                                                                   unsigned int __line ,
                                                                                                   char const   *__function ) ;
#line 50 "/usr/include/x86_64-linux-gnu/bits/errno.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
#line 53 "/home/june/repo/benchmarks/collector/temp/fatsort-0.9.15.245/src/entrylist.h"
struct sDirEntryList *newDirEntryList(void) ;
#line 57
void randomizeDirEntryList(struct sDirEntryList *list , u_int32_t entries ) ;
#line 60
struct sDirEntryList *newDirEntry(char *sname , char *lname , struct sShortDirEntry *sde ,
                                  struct sLongDirEntryList *ldel , u_int32_t entries ) ;
#line 64
struct sLongDirEntryList *insertLongDirEntryList(struct sLongDirEntry *lde , struct sLongDirEntryList *list ) ;
#line 68
int32_t cmpEntries(struct sDirEntryList *de1 , struct sDirEntryList *de2 ) ;
#line 71
void insertDirEntryList(struct sDirEntryList *new , struct sDirEntryList *list ) ;
#line 74
void freeDirEntryList(struct sDirEntryList *list ) ;
#line 32 "/home/june/repo/benchmarks/collector/temp/fatsort-0.9.15.245/src/options.h"
u_int32_t OPT_IGNORE_CASE ;
#line 32
u_int32_t OPT_ORDER ;
#line 32
u_int32_t OPT_LIST ;
#line 32
u_int32_t OPT_REVERSE ;
#line 32
u_int32_t OPT_NATURAL_SORT ;
#line 32
u_int32_t OPT_RANDOM ;
#line 35
struct sStringList *OPT_IGNORE_PREFIXES_LIST ;
#line 40 "/home/june/repo/benchmarks/collector/temp/fatsort-0.9.15.245/src/errors.h"
void errormsg(char const   *func , char const   *str  , ...) ;
#line 30 "/home/june/repo/benchmarks/collector/temp/fatsort-0.9.15.245/src/natstrcmp.h"
int32_t natstrcmp(char const   *str1 , char const   *str2 ) ;
#line 33
int32_t natstrcasecmp(char const   *str1 , char const   *str2 ) ;
#line 38 "/home/june/repo/benchmarks/collector/temp/fatsort-0.9.15.245/src/entrylist.c"
u_int32_t irand(u_int32_t b , u_int32_t e ) 
{ 
  double r ;
  int tmp ;

  {
  {
#line 40
  r = (double )((e - b) + 1U);
#line 41
  tmp = rand();
  }
#line 41
  return (b + (u_int32_t )((r * (double )tmp) / ((double )2147483647 + 1.0)));
}
}
#line 46 "/home/june/repo/benchmarks/collector/temp/fatsort-0.9.15.245/src/entrylist.c"
struct sDirEntryList *newDirEntryList(void) 
{ 
  struct sDirEntryList *tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  void *tmp___2 ;

  {
  {
#line 52
  tmp___2 = malloc(sizeof(struct sDirEntryList ));
#line 52
  tmp = (struct sDirEntryList *)tmp___2;
  }
#line 52
  if ((unsigned long )tmp == (unsigned long )((void *)0)) {
    {
#line 53
    tmp___0 = __errno_location();
#line 53
    tmp___1 = strerror(*tmp___0);
#line 53
    errormsg("newDirEntryList", "%s!", tmp___1);
    }
#line 54
    return ((struct sDirEntryList *)((void *)0));
  }
  {
#line 56
  memset((void *)tmp, 0, sizeof(struct sDirEntryList ));
  }
#line 57
  return (tmp);
}
}
#line 60 "/home/june/repo/benchmarks/collector/temp/fatsort-0.9.15.245/src/entrylist.c"
struct sDirEntryList *newDirEntry(char *sname , char *lname , struct sShortDirEntry *sde ,
                                  struct sLongDirEntryList *ldel , u_int32_t entries ) 
{ 
  struct sDirEntryList *tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  void *tmp___2 ;
  int *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  size_t tmp___6 ;
  void *tmp___7 ;
  int *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  size_t tmp___11 ;
  void *tmp___12 ;
  int *tmp___13 ;
  char *tmp___14 ;
  struct sShortDirEntry *tmp___15 ;
  void *tmp___16 ;

  {
#line 65
  if (! ((unsigned long )sname != (unsigned long )((void *)0))) {
    {
#line 65
    __assert_fail("sname != ((void *)0)", "/home/june/repo/benchmarks/collector/temp/fatsort-0.9.15.245/src/entrylist.c",
                  65U, "newDirEntry");
    }
  }
#line 66
  if (! ((unsigned long )lname != (unsigned long )((void *)0))) {
    {
#line 66
    __assert_fail("lname != ((void *)0)", "/home/june/repo/benchmarks/collector/temp/fatsort-0.9.15.245/src/entrylist.c",
                  66U, "newDirEntry");
    }
  }
#line 67
  if (! ((unsigned long )sde != (unsigned long )((void *)0))) {
    {
#line 67
    __assert_fail("sde != ((void *)0)", "/home/june/repo/benchmarks/collector/temp/fatsort-0.9.15.245/src/entrylist.c",
                  67U, "newDirEntry");
    }
  }
  {
#line 71
  tmp___2 = malloc(sizeof(struct sDirEntryList ));
#line 71
  tmp = (struct sDirEntryList *)tmp___2;
  }
#line 71
  if ((unsigned long )tmp == (unsigned long )((void *)0)) {
    {
#line 72
    tmp___0 = __errno_location();
#line 72
    tmp___1 = strerror(*tmp___0);
#line 72
    errormsg("newDirEntry", "%s!", tmp___1);
    }
#line 73
    return ((struct sDirEntryList *)((void *)0));
  }
  {
#line 75
  tmp___6 = strlen((char const   *)sname);
#line 75
  tmp___7 = malloc(tmp___6 + 1UL);
#line 75
  tmp___5 = (char *)tmp___7;
#line 75
  tmp->sname = tmp___5;
  }
#line 75
  if ((unsigned long )tmp___5 == (unsigned long )((void *)0)) {
    {
#line 76
    tmp___3 = __errno_location();
#line 76
    tmp___4 = strerror(*tmp___3);
#line 76
    errormsg("newDirEntry", "%s!", tmp___4);
    }
#line 77
    return ((struct sDirEntryList *)((void *)0));
  }
  {
#line 79
  strcpy((char */* __restrict  */)tmp->sname, (char const   */* __restrict  */)sname);
#line 80
  tmp___11 = strlen((char const   *)lname);
#line 80
  tmp___12 = malloc(tmp___11 + 1UL);
#line 80
  tmp___10 = (char *)tmp___12;
#line 80
  tmp->lname = tmp___10;
  }
#line 80
  if ((unsigned long )tmp___10 == (unsigned long )((void *)0)) {
    {
#line 81
    tmp___8 = __errno_location();
#line 81
    tmp___9 = strerror(*tmp___8);
#line 81
    errormsg("newDirEntry", "%s!", tmp___9);
    }
#line 82
    return ((struct sDirEntryList *)((void *)0));
  }
  {
#line 84
  strcpy((char */* __restrict  */)tmp->lname, (char const   */* __restrict  */)lname);
#line 86
  tmp___16 = malloc(sizeof(struct sShortDirEntry ));
#line 86
  tmp___15 = (struct sShortDirEntry *)tmp___16;
#line 86
  tmp->sde = tmp___15;
  }
#line 86
  if ((unsigned long )tmp___15 == (unsigned long )((void *)0)) {
    {
#line 87
    tmp___13 = __errno_location();
#line 87
    tmp___14 = strerror(*tmp___13);
#line 87
    errormsg("newDirEntry", "%s!", tmp___14);
    }
#line 88
    return ((struct sDirEntryList *)((void *)0));
  }
  {
#line 90
  memcpy((void */* __restrict  */)tmp->sde, (void const   */* __restrict  */)sde,
         (size_t )32);
#line 91
  tmp->ldel = ldel;
#line 92
  tmp->entries = (int32_t )entries;
#line 93
  tmp->next = (struct sDirEntryList *)((void *)0);
  }
#line 94
  return (tmp);
}
}
#line 97 "/home/june/repo/benchmarks/collector/temp/fatsort-0.9.15.245/src/entrylist.c"
struct sLongDirEntryList *insertLongDirEntryList(struct sLongDirEntry *lde , struct sLongDirEntryList *list ) 
{ 
  struct sLongDirEntryList *tmp ;
  struct sLongDirEntryList *new ;
  int *tmp___0 ;
  char *tmp___1 ;
  void *tmp___2 ;
  int *tmp___3 ;
  char *tmp___4 ;
  struct sLongDirEntry *tmp___5 ;
  void *tmp___6 ;

  {
#line 103
  if (! ((unsigned long )lde != (unsigned long )((void *)0))) {
    {
#line 103
    __assert_fail("lde != ((void *)0)", "/home/june/repo/benchmarks/collector/temp/fatsort-0.9.15.245/src/entrylist.c",
                  103U, "insertLongDirEntryList");
    }
  }
  {
#line 107
  tmp___2 = malloc(sizeof(struct sLongDirEntryList ));
#line 107
  new = (struct sLongDirEntryList *)tmp___2;
  }
#line 107
  if ((unsigned long )new == (unsigned long )((void *)0)) {
    {
#line 108
    tmp___0 = __errno_location();
#line 108
    tmp___1 = strerror(*tmp___0);
#line 108
    errormsg("insertLongDirEntryList", "%s!", tmp___1);
    }
#line 109
    return ((struct sLongDirEntryList *)((void *)0));
  }
  {
#line 111
  tmp___6 = malloc(sizeof(struct sLongDirEntry ));
#line 111
  tmp___5 = (struct sLongDirEntry *)tmp___6;
#line 111
  new->lde = tmp___5;
  }
#line 111
  if ((unsigned long )tmp___5 == (unsigned long )((void *)0)) {
    {
#line 112
    tmp___3 = __errno_location();
#line 112
    tmp___4 = strerror(*tmp___3);
#line 112
    errormsg("insertLongDirEntryList", "%s!", tmp___4);
    }
#line 113
    return ((struct sLongDirEntryList *)((void *)0));
  }
  {
#line 115
  memcpy((void */* __restrict  */)new->lde, (void const   */* __restrict  */)lde,
         (size_t )32);
#line 116
  new->next = (struct sLongDirEntryList *)((void *)0);
  }
#line 118
  if ((unsigned long )list != (unsigned long )((void *)0)) {
#line 119
    tmp = list;
    {
#line 120
    while (1) {
      while_continue: /* CIL Label */ ;
#line 120
      if (! ((unsigned long )tmp->next != (unsigned long )((void *)0))) {
#line 120
        goto while_break;
      }
#line 121
      tmp = tmp->next;
    }
    while_break: /* CIL Label */ ;
    }
#line 123
    tmp->next = new;
#line 124
    return (list);
  } else {
#line 126
    return (new);
  }
}
}
#line 130 "/home/june/repo/benchmarks/collector/temp/fatsort-0.9.15.245/src/entrylist.c"
int32_t stripSpecialPrefixes(char *old , char *new ) 
{ 
  struct sStringList *prefix ;
  int32_t len ;
  int32_t len_old ;
  size_t tmp ;
  size_t tmp___0 ;
  int tmp___1 ;

  {
#line 134
  if (! ((unsigned long )old != (unsigned long )((void *)0))) {
    {
#line 134
    __assert_fail("old != ((void *)0)", "/home/june/repo/benchmarks/collector/temp/fatsort-0.9.15.245/src/entrylist.c",
                  134U, "stripSpecialPrefixes");
    }
  }
#line 135
  if (! ((unsigned long )new != (unsigned long )((void *)0))) {
    {
#line 135
    __assert_fail("new != ((void *)0)", "/home/june/repo/benchmarks/collector/temp/fatsort-0.9.15.245/src/entrylist.c",
                  135U, "stripSpecialPrefixes");
    }
  }
  {
#line 137
  prefix = OPT_IGNORE_PREFIXES_LIST;
#line 141
  tmp = strlen((char const   *)old);
#line 141
  len_old = (int32_t )tmp;
  }
  {
#line 143
  while (1) {
    while_continue: /* CIL Label */ ;
#line 143
    if (! ((unsigned long )prefix->next != (unsigned long )((void *)0))) {
#line 143
      goto while_break;
    }
    {
#line 144
    tmp___0 = strlen((char const   *)(prefix->next)->str);
#line 144
    len = (int32_t )tmp___0;
#line 146
    tmp___1 = strncasecmp((char const   *)old, (char const   *)(prefix->next)->str,
                          (size_t )len);
    }
#line 146
    if (tmp___1 == 0) {
      {
#line 147
      strncpy((char */* __restrict  */)new, (char const   */* __restrict  */)(old + len),
              (size_t )(len_old - len));
#line 148
      *(new + (len_old - len)) = (char )'\000';
      }
#line 149
      return (1);
    }
#line 151
    prefix = prefix->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 154
  return (0);
}
}
#line 157 "/home/june/repo/benchmarks/collector/temp/fatsort-0.9.15.245/src/entrylist.c"
int32_t cmpEntries(struct sDirEntryList *de1 , struct sDirEntryList *de2 ) 
{ 
  char s1[513] ;
  char s2[513] ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char *ss1 ;
  char *ss2 ;
  int32_t tmp___3 ;
  int32_t tmp___4 ;
  int32_t tmp___5 ;
  int32_t tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;

  {
#line 162
  if (! ((unsigned long )de1 != (unsigned long )((void *)0))) {
    {
#line 162
    __assert_fail("de1 != ((void *)0)", "/home/june/repo/benchmarks/collector/temp/fatsort-0.9.15.245/src/entrylist.c",
                  162U, "cmpEntries");
    }
  }
#line 163
  if (! ((unsigned long )de2 != (unsigned long )((void *)0))) {
    {
#line 163
    __assert_fail("de2 != ((void *)0)", "/home/june/repo/benchmarks/collector/temp/fatsort-0.9.15.245/src/entrylist.c",
                  163U, "cmpEntries");
    }
  }
#line 169
  if (((int )(de1->sde)->DIR_Atrr & 31) == 8) {
#line 170
    return (-1);
  } else
#line 171
  if (((int )(de2->sde)->DIR_Atrr & 31) == 8) {
#line 172
    return (1);
  } else {
    {
#line 174
    tmp___2 = strcmp((char const   *)de1->sname, ".");
    }
#line 174
    if (tmp___2 == 0) {
#line 175
      return (-1);
    } else {
      {
#line 176
      tmp___1 = strcmp((char const   *)de2->sname, ".");
      }
#line 176
      if (tmp___1 == 0) {
#line 177
        return (1);
      } else {
        {
#line 178
        tmp___0 = strcmp((char const   *)de1->sname, "..");
        }
#line 178
        if (tmp___0 == 0) {
#line 179
          return (-1);
        } else {
          {
#line 180
          tmp = strcmp((char const   *)de2->sname, "..");
          }
#line 180
          if (tmp == 0) {
#line 181
            return (1);
          } else
#line 183
          if ((int )*(de1->sname + 0) == -27) {
#line 184
            return (1);
          } else
#line 185
          if ((int )*(de2->sname + 0) == -27) {
#line 186
            return (-1);
          }
        }
      }
    }
  }
#line 191
  if ((unsigned long )de1->lname != (unsigned long )((void *)0)) {
#line 191
    if ((int )*(de1->lname + 0) != 0) {
#line 192
      ss1 = de1->lname;
    } else {
#line 194
      ss1 = de1->sname;
    }
  } else {
#line 194
    ss1 = de1->sname;
  }
#line 196
  if ((unsigned long )de2->lname != (unsigned long )((void *)0)) {
#line 196
    if ((int )*(de2->lname + 0) != 0) {
#line 197
      ss2 = de2->lname;
    } else {
#line 199
      ss2 = de2->sname;
    }
  } else {
#line 199
    ss2 = de2->sname;
  }
#line 204
  if (OPT_LIST) {
#line 204
    return (1);
  } else
#line 204
  if (OPT_RANDOM) {
#line 204
    return (1);
  }
#line 207
  if (OPT_ORDER == 0U) {
#line 208
    if ((int )(de1->sde)->DIR_Atrr & 16) {
#line 208
      if (! ((int )(de2->sde)->DIR_Atrr & 16)) {
#line 210
        return (-1);
      } else {
#line 208
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 211
    if (! ((int )(de1->sde)->DIR_Atrr & 16)) {
#line 211
      if ((int )(de2->sde)->DIR_Atrr & 16) {
#line 213
        return (1);
      }
    }
  } else
#line 215
  if (OPT_ORDER == 1U) {
#line 216
    if ((int )(de1->sde)->DIR_Atrr & 16) {
#line 216
      if (! ((int )(de2->sde)->DIR_Atrr & 16)) {
#line 218
        return (1);
      } else {
#line 216
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 219
    if (! ((int )(de1->sde)->DIR_Atrr & 16)) {
#line 219
      if ((int )(de2->sde)->DIR_Atrr & 16) {
#line 221
        return (-1);
      }
    }
  }
#line 226
  if ((unsigned long )OPT_IGNORE_PREFIXES_LIST->next != (unsigned long )((void *)0)) {
    {
#line 227
    tmp___3 = stripSpecialPrefixes(ss1, s1);
    }
#line 227
    if (tmp___3) {
#line 228
      ss1 = s1;
    }
    {
#line 230
    tmp___4 = stripSpecialPrefixes(ss2, s2);
    }
#line 230
    if (tmp___4) {
#line 231
      ss2 = s2;
    }
  }
#line 235
  if (OPT_NATURAL_SORT) {
#line 236
    if (OPT_IGNORE_CASE) {
      {
#line 237
      tmp___5 = natstrcasecmp((char const   *)ss1, (char const   *)ss2);
      }
#line 237
      return ((int32_t )((u_int32_t )tmp___5 * OPT_REVERSE));
    } else {
      {
#line 239
      tmp___6 = natstrcmp((char const   *)ss1, (char const   *)ss2);
      }
#line 239
      return ((int32_t )((u_int32_t )tmp___6 * OPT_REVERSE));
    }
  } else
#line 242
  if (OPT_IGNORE_CASE) {
    {
#line 243
    tmp___7 = strcasecmp((char const   *)ss1, (char const   *)ss2);
    }
#line 243
    return ((int32_t )((u_int32_t )tmp___7 * OPT_REVERSE));
  } else {
    {
#line 245
    tmp___8 = strcmp((char const   *)ss1, (char const   *)ss2);
    }
#line 245
    return ((int32_t )((u_int32_t )tmp___8 * OPT_REVERSE));
  }
}
}
#line 250 "/home/june/repo/benchmarks/collector/temp/fatsort-0.9.15.245/src/entrylist.c"
void insertDirEntryList(struct sDirEntryList *new , struct sDirEntryList *list ) 
{ 
  struct sDirEntryList *tmp ;
  struct sDirEntryList *dummy ;
  int32_t tmp___0 ;

  {
#line 255
  if (! ((unsigned long )new != (unsigned long )((void *)0))) {
    {
#line 255
    __assert_fail("new != ((void *)0)", "/home/june/repo/benchmarks/collector/temp/fatsort-0.9.15.245/src/entrylist.c",
                  255U, "insertDirEntryList");
    }
  }
#line 256
  if (! ((unsigned long )list != (unsigned long )((void *)0))) {
    {
#line 256
    __assert_fail("list != ((void *)0)", "/home/june/repo/benchmarks/collector/temp/fatsort-0.9.15.245/src/entrylist.c",
                  256U, "insertDirEntryList");
    }
  }
#line 260
  tmp = list;
  {
#line 262
  while (1) {
    while_continue: /* CIL Label */ ;
#line 262
    if ((unsigned long )tmp->next != (unsigned long )((void *)0)) {
      {
#line 262
      tmp___0 = cmpEntries(new, tmp->next);
      }
#line 262
      if (! (tmp___0 >= 0)) {
#line 262
        goto while_break;
      }
    } else {
#line 262
      goto while_break;
    }
#line 264
    tmp = tmp->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 267
  dummy = tmp->next;
#line 268
  tmp->next = new;
#line 269
  new->next = dummy;
#line 270
  return;
}
}
#line 272 "/home/june/repo/benchmarks/collector/temp/fatsort-0.9.15.245/src/entrylist.c"
void freeDirEntryList(struct sDirEntryList *list ) 
{ 
  struct sDirEntryList *tmp ;
  struct sLongDirEntryList *ldelist ;
  struct sLongDirEntryList *tmp2 ;

  {
#line 283
  if (! ((unsigned long )list != (unsigned long )((void *)0))) {
    {
#line 283
    __assert_fail("list != ((void *)0)", "/home/june/repo/benchmarks/collector/temp/fatsort-0.9.15.245/src/entrylist.c",
                  283U, "freeDirEntryList");
    }
  }
  {
#line 288
  while (1) {
    while_continue: /* CIL Label */ ;
#line 288
    if (! ((unsigned long )list != (unsigned long )((void *)0))) {
#line 288
      goto while_break;
    }
#line 289
    if (list->sname) {
      {
#line 289
      free((void *)list->sname);
      }
    }
#line 290
    if (list->lname) {
      {
#line 290
      free((void *)list->lname);
      }
    }
#line 291
    if (list->sde) {
      {
#line 291
      free((void *)list->sde);
      }
    }
#line 293
    ldelist = list->ldel;
    {
#line 294
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 294
      if (! ((unsigned long )ldelist != (unsigned long )((void *)0))) {
#line 294
        goto while_break___0;
      }
      {
#line 295
      free((void *)ldelist->lde);
#line 296
      tmp2 = ldelist;
#line 297
      ldelist = ldelist->next;
#line 298
      free((void *)tmp2);
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 301
    tmp = list;
#line 302
    list = list->next;
#line 303
    free((void *)tmp);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 305
  return;
}
}
#line 307 "/home/june/repo/benchmarks/collector/temp/fatsort-0.9.15.245/src/entrylist.c"
void randomizeDirEntryList(struct sDirEntryList *list , u_int32_t entries ) 
{ 
  struct sDirEntryList *randlist ;
  struct sDirEntryList *tmp ;
  struct sDirEntryList *dummy1 ;
  struct sDirEntryList *dummy2 ;
  u_int32_t i ;
  u_int32_t j ;
  u_int32_t pos ;
  u_int32_t skip ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 311
  if (! ((unsigned long )list != (unsigned long )((void *)0))) {
    {
#line 311
    __assert_fail("list != ((void *)0)", "/home/june/repo/benchmarks/collector/temp/fatsort-0.9.15.245/src/entrylist.c",
                  311U, "randomizeDirEntryList");
    }
  }
#line 315
  skip = (u_int32_t )0;
#line 317
  randlist = list;
  {
#line 321
  while (1) {
    while_continue: /* CIL Label */ ;
#line 321
    if (randlist->next) {
#line 321
      if (! (((int )((randlist->next)->sde)->DIR_Atrr & 31) == 8)) {
        {
#line 321
        tmp___0 = strcmp((char const   *)(randlist->next)->sname, ".");
        }
#line 321
        if (! (tmp___0 == 0)) {
          {
#line 321
          tmp___1 = strcmp((char const   *)(randlist->next)->sname, "..");
          }
#line 321
          if (! (tmp___1 == 0)) {
#line 321
            goto while_break;
          }
        }
      }
    } else {
#line 321
      goto while_break;
    }
#line 327
    randlist = randlist->next;
#line 328
    skip ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 331
  i = skip;
  {
#line 331
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 331
    if (! (i < entries)) {
#line 331
      goto while_break___0;
    }
    {
#line 332
    pos = irand((u_int32_t )0, (entries - 1U) - i);
#line 334
    tmp = randlist;
#line 336
    j = (u_int32_t )0;
    }
    {
#line 336
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 336
      if (! (j < pos)) {
#line 336
        goto while_break___1;
      }
#line 337
      tmp = tmp->next;
#line 336
      j ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 341
    dummy1 = tmp->next;
#line 342
    tmp->next = dummy1->next;
#line 344
    dummy2 = randlist->next;
#line 345
    randlist->next = dummy1;
#line 346
    dummy1->next = dummy2;
#line 348
    randlist = randlist->next;
#line 331
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 350
  return;
}
}
#line 376 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) srand)(unsigned int __seed ) ;
#line 169 "/usr/include/stdio.h"
extern struct _IO_FILE *stdout ;
#line 237
extern int fclose(FILE *__stream ) ;
#line 242
extern int fflush(FILE *__stream ) ;
#line 283
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes )  __asm__("fopen64")  ;
#line 362
extern int printf(char const   * __restrict  __format  , ...) ;
#line 71 "/usr/include/getopt.h"
extern int optind ;
#line 124 "/usr/include/locale.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) setlocale)(int __category ,
                                                                                  char const   *__locale ) ;
#line 192 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) time_t ( __attribute__((__leaf__)) time)(time_t *__timer ) ;
#line 34 "/home/june/repo/benchmarks/collector/temp/fatsort-0.9.15.245/src/signal.h"
void init_signal_handling(void) ;
#line 159 "/home/june/repo/benchmarks/collector/temp/fatsort-0.9.15.245/src/FAT_fs.h"
int32_t read_bootsector(FILE *fd , struct sBootSector *bs ) ;
#line 162
int32_t getCountOfClusters(struct sBootSector *bs ) ;
#line 165
int32_t getFATType(struct sBootSector *bs ) ;
#line 168
int32_t getFATEntry(FILE *fd , struct sBootSector *bs , u_int32_t cluster , u_int32_t *data ) ;
#line 174
off_t getClusterOffset(struct sBootSector *bs , u_int32_t cluster ) ;
#line 32 "/home/june/repo/benchmarks/collector/temp/fatsort-0.9.15.245/src/options.h"
u_int32_t OPT_VERSION ;
#line 32
u_int32_t OPT_HELP ;
#line 32
u_int32_t OPT_INFO ;
#line 38
int32_t parse_options(int argc , char **argv ) ;
#line 48
void freeOptions(void) ;
#line 32 "/home/june/repo/benchmarks/collector/temp/fatsort-0.9.15.245/src/sort.h"
int32_t sort_fs(char *filename ) ;
#line 28 "/home/june/repo/benchmarks/collector/temp/fatsort-0.9.15.245/src/misc.h"
void infomsg(char *str  , ...) ;
#line 93 "/home/june/repo/benchmarks/collector/temp/fatsort-0.9.15.245/src/fatsort.c"
int32_t printFSInfo(char *filename ) 
{ 
  u_int32_t FATSz ;
  u_int32_t value ;
  int32_t FATType ;
  int32_t cluster ;
  FILE *fd ;
  struct sBootSector bs ;
  int *tmp ;
  char *tmp___0 ;
  int32_t tmp___1 ;
  int32_t tmp___2 ;
  int32_t tmp___3 ;
  off_t tmp___4 ;

  {
#line 98
  if (! ((unsigned long )filename != (unsigned long )((void *)0))) {
    {
#line 98
    __assert_fail("filename != ((void *)0)", "/home/june/repo/benchmarks/collector/temp/fatsort-0.9.15.245/src/fatsort.c",
                  98U, "printFSInfo");
    }
  }
  {
#line 105
  printf((char const   */* __restrict  */)"\t- File system information -\n");
#line 107
  fd = fopen((char const   */* __restrict  */)filename, (char const   */* __restrict  */)"rb");
  }
#line 107
  if ((unsigned long )fd == (unsigned long )((void *)0)) {
    {
#line 108
    tmp = __errno_location();
#line 108
    tmp___0 = strerror(*tmp);
#line 108
    errormsg("printFSInfo", "%s!", tmp___0);
    }
#line 109
    return (-1);
  }
  {
#line 113
  tmp___1 = read_bootsector(fd, & bs);
  }
#line 113
  if (tmp___1) {
    {
#line 114
    errormsg("printFSInfo", "Failed to read boot sector!");
    }
#line 115
    return (-1);
  }
#line 118
  if ((int )bs.BS_FATSz16 != 0) {
#line 119
    FATSz = (u_int32_t )bs.BS_FATSz16;
  } else {
#line 121
    FATSz = bs.FATxx.FAT32.BS_FATSz32;
  }
  {
#line 124
  FATType = getFATType(& bs);
  }
#line 125
  if (FATType == -1) {
    {
#line 126
    errormsg("printFSInfo", "Failed to get FAT type!");
    }
#line 127
    return (-1);
  }
  {
#line 130
  cluster = getCountOfClusters(& bs);
  }
#line 131
  if (cluster == -1) {
    {
#line 132
    errormsg("printFSInfo", "Failed to get count of cluster!");
    }
#line 133
    return (-1);
  }
  {
#line 136
  printf((char const   */* __restrict  */)"Device:\t\t\t\t%s\n", filename);
#line 137
  fflush(stdout);
#line 138
  tmp___2 = getFATType(& bs);
#line 138
  printf((char const   */* __restrict  */)"Type:\t\t\t\tFAT%u\n", tmp___2);
#line 139
  fflush(stdout);
#line 140
  printf((char const   */* __restrict  */)"Sector size:\t\t\t%u bytes\n", (int )bs.BS_BytesPerSec);
#line 141
  fflush(stdout);
#line 142
  printf((char const   */* __restrict  */)"FAT size:\t\t\t%u sectors (%u bytes)\n",
         FATSz, FATSz * (u_int32_t )bs.BS_BytesPerSec);
#line 143
  printf((char const   */* __restrict  */)"Cluster size:\t\t\t%u bytes\n", (int )bs.BS_SecPerClus * (int )bs.BS_BytesPerSec);
#line 144
  printf((char const   */* __restrict  */)"Cluster count:\t\t\t%u\n", cluster);
#line 145
  printf((char const   */* __restrict  */)"FS size:\t\t\t%.2f MiBytes\n", (double )(((float )cluster * (float )bs.BS_SecPerClus) * (float )bs.BS_BytesPerSec) / (1024.0 * (double )1024));
  }
#line 146
  if (FATType == 32) {
    {
#line 147
    tmp___3 = getFATEntry(fd, & bs, bs.FATxx.FAT32.BS_RootClus, & value);
    }
#line 147
    if (tmp___3 == -1) {
      {
#line 148
      errormsg("printFSInfo", "Failed to get FAT enry!");
      }
#line 149
      return (-1);
    }
    {
#line 151
    tmp___4 = getClusterOffset(& bs, bs.FATxx.FAT32.BS_RootClus);
#line 151
    printf((char const   */* __restrict  */)"FAT32 root directory first cluster: 0x%x, Data offset: 0x%llx, FAT entry: 0x%x\n",
           bs.FATxx.FAT32.BS_RootClus, (unsigned long long )tmp___4, value);
    }
  }
  {
#line 156
  fclose(fd);
  }
#line 158
  return (0);
}
}
#line 177 "/home/june/repo/benchmarks/collector/temp/fatsort-0.9.15.245/src/fatsort.c"
int main(int argc , char **argv ) 
{ 
  time_t tmp ;
  char *tmp___0 ;
  char *filename ;
  int32_t tmp___1 ;
  int32_t tmp___2 ;
  int32_t tmp___3 ;

  {
  {
#line 183
  tmp = time((time_t *)0);
#line 183
  srand((unsigned int )tmp);
#line 186
  tmp___0 = setlocale(6, "");
  }
#line 186
  if ((unsigned long )tmp___0 == (unsigned long )((void *)0)) {
    {
#line 187
    errormsg("main", "Could not set locale!");
    }
#line 188
    return (-1);
  }
  {
#line 192
  init_signal_handling();
#line 195
  tmp___1 = parse_options(argc, argv);
  }
#line 195
  if (tmp___1 == -1) {
    {
#line 196
    errormsg("main", "Faild to parse options!");
    }
#line 197
    return (-1);
  }
#line 200
  if (OPT_HELP) {
    {
#line 201
    printf((char const   */* __restrict  */)"FATSort Utility 0.9.15 by Boris Leidner <fatsort(at)formenos.de>\n\nLicense GPLv2: GNU GPL version 2 (see LICENSE.txt)\nThis is free software: you are free to change and redistribute it.\nThere is NO WARRANTY, to the extent permitted by law.\n\nUsage: fatsort [options] device\n\nOptions:\n\t-c\t Ignore case of file names\n\t-f\t Force sorting even if filesystem is mounted\n\t-h\t Print some help\n\t-i\t Print file system information only\n\t-I\t Ignore prefixes \"a\" and \"the\"\n\t-l\t Print current order of files only\n\t-o flag\t Sort order of files where flag is one of\n\t\t\td : directories first (default)\n\t\t\tf : files first\n\t\t\ta : files and directories are not differentiated\n\t-n\t Natural order sorting\n\t-q\t Be quiet\n\t-r\t Sort in reverse order\n\t-R\t Sort in random order\n\t-v\t Print version information\n\n\tThe following options can be specified multiple times:\n\n\t-d dir\t Sort directory dir only\n\t-D dir\t Sort directory dir and all subdirectories\n\t-x dir\t Don\'t sort directory dir\n\t-X dir\t Don\'t sort directory dir and its subdirectories\n\nDevice must be a FAT16 or FAT32 file system. FAT12 is not supported yet.\n\nExample: fatsort /dev/sda\n\nNOTE: THE FILESYSTEM MUST BE CONSISTENT, OTHERWISE YOU MAY DAMAGE IT!\nIF SOMEONE ELSE HAS ACCESS TO THE DEVICE HE MIGHT EXPLOIT FATSORT WITH\nA FORGED CORRUPT FILESYSTEM! USE THIS PROGRAM AT YOUR OWN RISK!\n");
    }
#line 202
    return (0);
  } else
#line 203
  if (OPT_VERSION) {
    {
#line 204
    printf((char const   */* __restrict  */)"FATSort Utility 0.9.15 by Boris Leidner <fatsort(at)formenos.de>\n\nLicense GPLv2: GNU GPL version 2 (see LICENSE.txt)\nThis is free software: you are free to change and redistribute it.\nThere is NO WARRANTY, to the extent permitted by law.\n");
    }
#line 205
    return (0);
  } else
#line 206
  if (optind < argc - 1) {
    {
#line 207
    errormsg("main", "Too many arguments!");
#line 208
    errormsg("main", "Use -h for more help.");
    }
#line 209
    return (-1);
  } else
#line 210
  if (optind == argc) {
    {
#line 211
    errormsg("main", "Device must be given!");
#line 212
    errormsg("main", "Use -h for more help.");
    }
#line 213
    return (-1);
  }
#line 221
  filename = *(argv + optind);
#line 224
  if (OPT_INFO) {
    {
#line 225
    infomsg((char *)"FATSort Utility 0.9.15 by Boris Leidner <fatsort(at)formenos.de>\n\n");
#line 226
    tmp___2 = printFSInfo(filename);
    }
#line 226
    if (tmp___2 == -1) {
      {
#line 227
      errormsg("main", "Failed to print file system information");
      }
#line 228
      return (-1);
    }
  } else {
    {
#line 231
    infomsg((char *)"FATSort Utility 0.9.15 by Boris Leidner <fatsort(at)formenos.de>\n\n");
#line 232
    tmp___3 = sort_fs(filename);
    }
#line 232
    if (tmp___3 == -1) {
      {
#line 233
      errormsg("main", "Failed to sort file system!");
      }
#line 234
      return (-1);
    }
  }
  {
#line 238
  freeOptions();
  }
#line 243
  return (0);
}
}
#line 37 "/home/june/repo/benchmarks/collector/temp/fatsort-0.9.15.245/src/signal.h"
void start_critical_section(void) ;
#line 40
void end_critical_section(void) ;
#line 218 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) sigfillset)(sigset_t *__set ) ;
#line 248
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) sigprocmask)(int __how ,
                                                                                  sigset_t const   * __restrict  __set ,
                                                                                  sigset_t * __restrict  __oset ) ;
#line 31 "/home/june/repo/benchmarks/collector/temp/fatsort-0.9.15.245/src/signal.c"
sigset_t blocked_signals_set  ;
#line 33 "/home/june/repo/benchmarks/collector/temp/fatsort-0.9.15.245/src/signal.c"
void init_signal_handling(void) 
{ 


  {
  {
#line 37
  sigfillset(& blocked_signals_set);
  }
#line 38
  return;
}
}
#line 40 "/home/june/repo/benchmarks/collector/temp/fatsort-0.9.15.245/src/signal.c"
void start_critical_section(void) 
{ 


  {
  {
#line 44
  sigprocmask(0, (sigset_t const   */* __restrict  */)(& blocked_signals_set), (sigset_t */* __restrict  */)((void *)0));
  }
#line 45
  return;
}
}
#line 47 "/home/june/repo/benchmarks/collector/temp/fatsort-0.9.15.245/src/signal.c"
void end_critical_section(void) 
{ 


  {
  {
#line 51
  sigprocmask(1, (sigset_t const   */* __restrict  */)(& blocked_signals_set), (sigset_t */* __restrict  */)((void *)0));
  }
#line 52
  return;
}
}
#line 43 "/home/june/repo/benchmarks/collector/temp/fatsort-0.9.15.245/src/clusterchain.h"
struct sClusterChain *newClusterChain(void) ;
#line 46
int32_t insertCluster(struct sClusterChain *chain , u_int32_t cluster ) ;
#line 49
void freeClusterChain(struct sClusterChain *chain ) ;
#line 37 "/home/june/repo/benchmarks/collector/temp/fatsort-0.9.15.245/src/clusterchain.c"
struct sClusterChain *newClusterChain(void) 
{ 
  struct sClusterChain *tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  void *tmp___2 ;

  {
  {
#line 43
  tmp___2 = malloc(sizeof(struct sClusterChain ));
#line 43
  tmp = (struct sClusterChain *)tmp___2;
  }
#line 43
  if ((unsigned long )tmp == (unsigned long )((void *)0)) {
    {
#line 44
    tmp___0 = __errno_location();
#line 44
    tmp___1 = strerror(*tmp___0);
#line 44
    errormsg("newClusterChain", "%s!", tmp___1);
    }
#line 45
    return ((struct sClusterChain *)((void *)0));
  }
#line 47
  tmp->cluster = (u_int32_t )0;
#line 48
  tmp->next = (struct sClusterChain *)((void *)0);
#line 49
  return (tmp);
}
}
#line 52 "/home/june/repo/benchmarks/collector/temp/fatsort-0.9.15.245/src/clusterchain.c"
int32_t insertCluster(struct sClusterChain *chain , u_int32_t cluster ) 
{ 
  int *tmp ;
  char *tmp___0 ;
  struct sClusterChain *tmp___1 ;
  void *tmp___2 ;

  {
#line 56
  if (! ((unsigned long )chain != (unsigned long )((void *)0))) {
    {
#line 56
    __assert_fail("chain != ((void *)0)", "/home/june/repo/benchmarks/collector/temp/fatsort-0.9.15.245/src/clusterchain.c",
                  56U, "insertCluster");
    }
  }
  {
#line 58
  while (1) {
    while_continue: /* CIL Label */ ;
#line 58
    if (! ((unsigned long )chain->next != (unsigned long )((void *)0))) {
#line 58
      goto while_break;
    }
#line 58
    chain = chain->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 60
  tmp___2 = malloc(sizeof(struct sClusterChain ));
#line 60
  tmp___1 = (struct sClusterChain *)tmp___2;
#line 60
  chain->next = tmp___1;
  }
#line 60
  if ((unsigned long )tmp___1 == (unsigned long )((void *)0)) {
    {
#line 61
    tmp = __errno_location();
#line 61
    tmp___0 = strerror(*tmp);
#line 61
    errormsg("insertCluster", "%s!", tmp___0);
    }
#line 62
    return (-1);
  }
#line 64
  (chain->next)->cluster = cluster;
#line 65
  (chain->next)->next = (struct sClusterChain *)((void *)0);
#line 67
  return (0);
}
}
#line 70 "/home/june/repo/benchmarks/collector/temp/fatsort-0.9.15.245/src/clusterchain.c"
void freeClusterChain(struct sClusterChain *chain ) 
{ 
  struct sClusterChain *tmp ;

  {
#line 75
  if (! ((unsigned long )chain != (unsigned long )((void *)0))) {
    {
#line 75
    __assert_fail("chain != ((void *)0)", "/home/june/repo/benchmarks/collector/temp/fatsort-0.9.15.245/src/clusterchain.c",
                  75U, "freeClusterChain");
    }
  }
  {
#line 79
  while (1) {
    while_continue: /* CIL Label */ ;
#line 79
    if (! ((unsigned long )chain != (unsigned long )((void *)0))) {
#line 79
      goto while_break;
    }
    {
#line 80
    tmp = chain;
#line 81
    chain = chain->next;
#line 82
    free((void *)tmp);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 85
  return;
}
}
#line 709 "/usr/include/stdio.h"
extern size_t fread(void * __restrict  __ptr , size_t __size , size_t __n , FILE * __restrict  __stream ) ;
#line 715
extern size_t fwrite(void const   * __restrict  __ptr , size_t __size , size_t __n ,
                     FILE * __restrict  __s ) ;
#line 781
extern int fseeko(FILE *__stream , __off64_t __off , int __whence )  __asm__("fseeko64")  ;
#line 38 "/home/june/repo/benchmarks/collector/temp/fatsort-0.9.15.245/src/fileio.h"
int fs_seek(FILE *stream , off_t offset , int whence ) ;
#line 39
off_t fs_read(void *ptr , u_int32_t size , u_int32_t n , FILE *stream ) ;
#line 40
off_t fs_write(void const   *ptr , u_int32_t size , u_int32_t n , FILE *stream ) ;
#line 41
int fs_close(FILE *file ) ;
#line 156 "/home/june/repo/benchmarks/collector/temp/fatsort-0.9.15.245/src/fileio.c"
int fs_seek(FILE *stream , off_t offset , int whence ) 
{ 
  int tmp ;

  {
  {
#line 157
  tmp = fseeko(stream, offset, whence);
  }
#line 157
  return (tmp);
}
}
#line 160 "/home/june/repo/benchmarks/collector/temp/fatsort-0.9.15.245/src/fileio.c"
off_t fs_read(void *ptr , u_int32_t size , u_int32_t n , FILE *stream ) 
{ 
  size_t tmp ;

  {
  {
#line 161
  tmp = fread((void */* __restrict  */)ptr, (size_t )size, (size_t )n, (FILE */* __restrict  */)stream);
  }
#line 161
  return ((off_t )tmp);
}
}
#line 164 "/home/june/repo/benchmarks/collector/temp/fatsort-0.9.15.245/src/fileio.c"
off_t fs_write(void const   *ptr , u_int32_t size , u_int32_t n , FILE *stream ) 
{ 
  size_t tmp ;

  {
  {
#line 165
  tmp = fwrite((void const   */* __restrict  */)ptr, (size_t )size, (size_t )n, (FILE */* __restrict  */)stream);
  }
#line 165
  return ((off_t )tmp);
}
}
#line 168 "/home/june/repo/benchmarks/collector/temp/fatsort-0.9.15.245/src/fileio.c"
int fs_close(FILE *file ) 
{ 
  int tmp ;

  {
  {
#line 169
  tmp = fclose(file);
  }
#line 169
  return (tmp);
}
}
/* compiler builtin: 
   void __builtin_va_start(__builtin_va_list  ) ;  */
/* compiler builtin: 
   void __builtin_va_end(__builtin_va_list  ) ;  */
#line 170 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 390
extern  __attribute__((__nothrow__)) int ( /* format attribute */  vsnprintf)(char * __restrict  __s ,
                                                                              size_t __maxlen ,
                                                                              char const   * __restrict  __format ,
                                                                              __gnuc_va_list __arg ) ;
#line 30 "/home/june/repo/benchmarks/collector/temp/fatsort-0.9.15.245/src/errors.c"
void errormsg(char const   *func , char const   *str  , ...) 
{ 
  char msg[129] ;
  va_list argptr ;

  {
  {
#line 37
  __builtin_va_start(argptr, str);
#line 38
  vsnprintf((char */* __restrict  */)(msg), (size_t )128, (char const   */* __restrict  */)str,
            argptr);
#line 39
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: %s\n",
          func, msg);
#line 40
  __builtin_va_end(argptr);
  }
#line 42
  return;
}
}
#line 828 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) feof)(FILE *__stream ) ;
#line 156 "/home/june/repo/benchmarks/collector/temp/fatsort-0.9.15.245/src/FAT_fs.h"
int32_t check_bootsector(struct sBootSector *bs ) ;
#line 171
int32_t putFATEntry(FILE *fd , struct sBootSector *bs , u_int32_t cluster , u_int32_t data ) ;
#line 177
int32_t parseEntry(FILE *fd , union sDirEntry *de ) ;
#line 36 "/home/june/repo/benchmarks/collector/temp/fatsort-0.9.15.245/src/FAT_fs.c"
int32_t check_bootsector(struct sBootSector *bs ) 
{ 


  {
#line 41
  if (! ((unsigned long )bs != (unsigned long )((void *)0))) {
    {
#line 41
    __assert_fail("bs != ((void *)0)", "/home/june/repo/benchmarks/collector/temp/fatsort-0.9.15.245/src/FAT_fs.c",
                  41U, "check_bootsector");
    }
  }
#line 43
  if ((int )bs->BS_JmpBoot[0] == 235) {
#line 43
    if ((int )bs->BS_JmpBoot[2] == 144) {
      _L: /* CIL Label */ 
#line 49
      if ((int )bs->BS_EndOfBS != 43605) {
        {
#line 51
        errormsg("check_bootsector", "End of boot sector marker is missing!");
        }
#line 52
        return (-1);
      } else
#line 53
      if ((int )bs->BS_BytesPerSec == 0) {
        {
#line 54
        errormsg("check_bootsector", "Sectors have a size of zero! Corrupt boot sector!");
        }
#line 55
        return (-1);
      } else
#line 56
      if ((int )bs->BS_SecPerClus == 0) {
        {
#line 57
        errormsg("check_bootsector", "Clusters have a size of zero! Corrupt boot sector!");
        }
#line 58
        return (-1);
      }
    } else {
#line 43
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 43
  if (! ((int )bs->BS_JmpBoot[0] == 233)) {
    {
#line 47
    errormsg("check_bootsector", "Boot sector does not begin with jump instruction!");
    }
#line 48
    return (-1);
  } else {
#line 43
    goto _L;
  }
#line 61
  return (0);
}
}
#line 64 "/home/june/repo/benchmarks/collector/temp/fatsort-0.9.15.245/src/FAT_fs.c"
int32_t read_bootsector(FILE *fd , struct sBootSector *bs ) 
{ 
  int tmp ;
  off_t tmp___0 ;
  int32_t tmp___1 ;

  {
#line 69
  if (! ((unsigned long )fd != (unsigned long )((void *)0))) {
    {
#line 69
    __assert_fail("fd != ((void *)0)", "/home/june/repo/benchmarks/collector/temp/fatsort-0.9.15.245/src/FAT_fs.c",
                  69U, "read_bootsector");
    }
  }
#line 70
  if (! ((unsigned long )bs != (unsigned long )((void *)0))) {
    {
#line 70
    __assert_fail("bs != ((void *)0)", "/home/june/repo/benchmarks/collector/temp/fatsort-0.9.15.245/src/FAT_fs.c",
                  70U, "read_bootsector");
    }
  }
  {
#line 72
  tmp___0 = fs_read((void *)bs, (u_int32_t )sizeof(struct sBootSector ), (u_int32_t )1,
                    fd);
  }
#line 72
  if (tmp___0 < 1L) {
    {
#line 73
    tmp = feof(fd);
    }
#line 73
    if (tmp) {
      {
#line 74
      errormsg("read_bootsector", "Boot sector is too short!");
      }
    } else {
      {
#line 76
      errormsg("read_bootsector", "Failed to read from file!");
      }
    }
#line 78
    return (-1);
  }
  {
#line 86
  tmp___1 = check_bootsector(bs);
  }
#line 86
  if (tmp___1) {
    {
#line 87
    errormsg("read_bootsector", "This is not a FAT bootsector!");
    }
#line 88
    return (-1);
  }
#line 91
  return (0);
}
}
#line 94 "/home/june/repo/benchmarks/collector/temp/fatsort-0.9.15.245/src/FAT_fs.c"
int32_t getCountOfClusters(struct sBootSector *bs ) 
{ 
  u_int32_t RootDirSectors ;
  u_int32_t FATSz ;
  u_int32_t TotSec ;
  u_int32_t DataSec ;
  int32_t retvalue ;

  {
#line 99
  if (! ((unsigned long )bs != (unsigned long )((void *)0))) {
    {
#line 99
    __assert_fail("bs != ((void *)0)", "/home/june/repo/benchmarks/collector/temp/fatsort-0.9.15.245/src/FAT_fs.c",
                  99U, "getCountOfClusters");
    }
  }
#line 104
  RootDirSectors = (u_int32_t )((int )bs->BS_RootEntCnt * 32 + ((int )bs->BS_BytesPerSec - 1));
#line 105
  RootDirSectors /= (u_int32_t )bs->BS_BytesPerSec;
#line 107
  if ((int )bs->BS_FATSz16 != 0) {
#line 108
    FATSz = (u_int32_t )bs->BS_FATSz16;
  } else {
#line 110
    FATSz = bs->FATxx.FAT32.BS_FATSz32;
  }
#line 112
  if ((int )bs->BS_TotSec16 != 0) {
#line 113
    TotSec = (u_int32_t )bs->BS_TotSec16;
  } else {
#line 115
    TotSec = bs->BS_TotSec32;
  }
#line 117
  DataSec = TotSec - (((u_int32_t )bs->BS_RsvdSecCnt + (u_int32_t )bs->BS_NumFATs * FATSz) + RootDirSectors);
#line 119
  retvalue = (int32_t )(DataSec / (u_int32_t )bs->BS_SecPerClus);
#line 120
  if (retvalue <= 0) {
    {
#line 121
    errormsg("getCountOfClusters", "Failed to calculate count of clusters!");
    }
#line 122
    return (-1);
  }
#line 124
  return (retvalue);
}
}
#line 127 "/home/june/repo/benchmarks/collector/temp/fatsort-0.9.15.245/src/FAT_fs.c"
int32_t getFATType(struct sBootSector *bs ) 
{ 
  u_int32_t CountOfClusters ;
  int32_t tmp ;

  {
#line 132
  if (! ((unsigned long )bs != (unsigned long )((void *)0))) {
    {
#line 132
    __assert_fail("bs != ((void *)0)", "/home/june/repo/benchmarks/collector/temp/fatsort-0.9.15.245/src/FAT_fs.c",
                  132U, "getFATType");
    }
  }
  {
#line 136
  tmp = getCountOfClusters(bs);
#line 136
  CountOfClusters = (u_int32_t )tmp;
  }
#line 137
  if (CountOfClusters == 4294967295U) {
    {
#line 138
    errormsg("getFATType", "Failed to get count of clusters!");
    }
#line 139
    return (-1);
  } else
#line 140
  if (CountOfClusters < 4096U) {
#line 141
    return (12);
  } else
#line 142
  if (CountOfClusters < 65525U) {
#line 143
    return (16);
  } else {
#line 145
    return (32);
  }
}
}
#line 149 "/home/june/repo/benchmarks/collector/temp/fatsort-0.9.15.245/src/FAT_fs.c"
int32_t getFATEntry(FILE *fd , struct sBootSector *bs , u_int32_t cluster , u_int32_t *data ) 
{ 
  off_t FATOffset ;
  off_t BSOffset ;
  int32_t FATType ;
  int tmp ;
  off_t tmp___0 ;
  int tmp___1 ;
  off_t tmp___2 ;

  {
#line 154
  if (! ((unsigned long )fd != (unsigned long )((void *)0))) {
    {
#line 154
    __assert_fail("fd != ((void *)0)", "/home/june/repo/benchmarks/collector/temp/fatsort-0.9.15.245/src/FAT_fs.c",
                  154U, "getFATEntry");
    }
  }
#line 155
  if (! ((unsigned long )bs != (unsigned long )((void *)0))) {
    {
#line 155
    __assert_fail("bs != ((void *)0)", "/home/june/repo/benchmarks/collector/temp/fatsort-0.9.15.245/src/FAT_fs.c",
                  155U, "getFATEntry");
    }
  }
#line 156
  if (! ((unsigned long )data != (unsigned long )((void *)0))) {
    {
#line 156
    __assert_fail("data != ((void *)0)", "/home/june/repo/benchmarks/collector/temp/fatsort-0.9.15.245/src/FAT_fs.c",
                  156U, "getFATEntry");
    }
  }
  {
#line 161
  *data = (u_int32_t )0;
#line 163
  FATType = getFATType(bs);
  }
#line 165
  if (FATType == 16) {
    {
#line 166
    FATOffset = (off_t )cluster * 2L;
#line 167
    BSOffset = (off_t )bs->BS_RsvdSecCnt * (off_t )bs->BS_BytesPerSec + FATOffset;
#line 168
    tmp = fs_seek(fd, BSOffset, 0);
    }
#line 168
    if (tmp == -1) {
      {
#line 169
      errormsg("getFATEntry", "Seek error!");
      }
#line 170
      return (-1);
    }
    {
#line 172
    tmp___0 = fs_read((void *)data, (u_int32_t )2, (u_int32_t )1, fd);
    }
#line 172
    if (tmp___0 < 1L) {
      {
#line 173
      errormsg("getFATEntry", "Failed to read from file!");
      }
#line 174
      return (-1);
    }
#line 176
    *data = *data;
  } else
#line 177
  if (FATType == 32) {
    {
#line 178
    FATOffset = (off_t )cluster * 4L;
#line 179
    BSOffset = (off_t )bs->BS_RsvdSecCnt * (off_t )bs->BS_BytesPerSec + FATOffset;
#line 180
    tmp___1 = fs_seek(fd, BSOffset, 0);
    }
#line 180
    if (tmp___1 == -1) {
      {
#line 181
      errormsg("getFATEntry", "Seek error!");
      }
#line 182
      return (-1);
    }
    {
#line 184
    tmp___2 = fs_read((void *)data, (u_int32_t )4, (u_int32_t )1, fd);
    }
#line 184
    if (tmp___2 < 1L) {
      {
#line 185
      errormsg("getFATEntry", "Failed to read from file!");
      }
#line 186
      return (-1);
    }
#line 188
    *data = *data;
#line 189
    *data &= 268435455U;
  } else
#line 190
  if (FATType == 12) {
    {
#line 191
    errormsg("getFATEntry", "FAT12 is not supported!");
    }
#line 192
    return (-1);
  } else {
    {
#line 194
    errormsg("getFATEntry", "Failed to get FAT type!");
    }
#line 195
    return (-1);
  }
#line 198
  return (0);
}
}
#line 202 "/home/june/repo/benchmarks/collector/temp/fatsort-0.9.15.245/src/FAT_fs.c"
int32_t putFATEntry(FILE *fd , struct sBootSector *bs , u_int32_t cluster , u_int32_t data ) 
{ 
  off_t FATOffset ;
  off_t FATSz ;
  off_t BSOffset ;
  u_int32_t value ;
  u_int32_t i ;
  int32_t FATType ;
  off_t tmp ;
  int32_t tmp___0 ;
  off_t tmp___1 ;

  {
#line 207
  if (! ((unsigned long )fd != (unsigned long )((void *)0))) {
    {
#line 207
    __assert_fail("fd != ((void *)0)", "/home/june/repo/benchmarks/collector/temp/fatsort-0.9.15.245/src/FAT_fs.c",
                  207U, "putFATEntry");
    }
  }
#line 208
  if (! ((unsigned long )bs != (unsigned long )((void *)0))) {
    {
#line 208
    __assert_fail("bs != ((void *)0)", "/home/june/repo/benchmarks/collector/temp/fatsort-0.9.15.245/src/FAT_fs.c",
                  208U, "putFATEntry");
    }
  }
#line 214
  if ((int )bs->BS_FATSz16 != 0) {
#line 215
    FATSz = (off_t )bs->BS_FATSz16;
  } else {
#line 217
    FATSz = (off_t )bs->FATxx.FAT32.BS_FATSz32;
  }
  {
#line 220
  FATType = getFATType(bs);
  }
#line 222
  if (FATType == 16) {
    {
#line 223
    FATOffset = (off_t )cluster * 2L;
#line 224
    BSOffset = (off_t )bs->BS_RsvdSecCnt * (off_t )bs->BS_BytesPerSec + FATOffset;
#line 225
    fs_seek(fd, BSOffset, 0);
#line 226
    data = data;
#line 227
    tmp = fs_write((void const   *)(& data), (u_int32_t )2, (u_int32_t )1, fd);
    }
#line 227
    if (tmp < 1L) {
      {
#line 228
      errormsg("putFATEntry", "Failed to write to file!");
      }
#line 229
      return (-1);
    }
  } else
#line 231
  if (FATType == 32) {
    {
#line 232
    FATOffset = (off_t )cluster * 4L;
#line 233
    BSOffset = (off_t )bs->BS_RsvdSecCnt * (off_t )bs->BS_BytesPerSec + FATOffset;
#line 234
    tmp___0 = getFATEntry(fd, bs, cluster, & value);
    }
#line 234
    if (tmp___0 == -1) {
      {
#line 235
      errormsg("putFATEntry", "Failed to get FAT entry!");
      }
#line 236
      return (-1);
    }
#line 238
    value = (value & 4026531840U) | (data & 268435455U);
#line 239
    i = (u_int32_t )0;
    {
#line 239
    while (1) {
      while_continue: /* CIL Label */ ;
#line 239
      if (! (i < (u_int32_t )bs->BS_NumFATs)) {
#line 239
        goto while_break;
      }
      {
#line 240
      fs_seek(fd, BSOffset + ((off_t )i * FATSz) * (off_t )bs->BS_BytesPerSec, 0);
#line 241
      value = value;
#line 242
      tmp___1 = fs_write((void const   *)(& value), (u_int32_t )4, (u_int32_t )1,
                         fd);
      }
#line 242
      if (tmp___1 < 1L) {
        {
#line 243
        errormsg("putFATEntry", "Failed to write to file!");
        }
#line 244
        return (-1);
      }
#line 239
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  } else
#line 247
  if (FATType == 12) {
    {
#line 248
    errormsg("putFATEntry", "FAT12 is not supported!");
    }
#line 249
    return (-1);
  } else {
    {
#line 251
    errormsg("putFATEntry", "Failed to get FAT type!");
    }
#line 252
    return (-1);
  }
#line 255
  return (0);
}
}
#line 259 "/home/june/repo/benchmarks/collector/temp/fatsort-0.9.15.245/src/FAT_fs.c"
off_t getClusterOffset(struct sBootSector *bs , u_int32_t cluster ) 
{ 
  u_int32_t FATSz ;
  u_int32_t RootDirSectors ;
  u_int32_t FirstDataSector ;

  {
#line 265
  if (! ((unsigned long )bs != (unsigned long )((void *)0))) {
    {
#line 265
    __assert_fail("bs != ((void *)0)", "/home/june/repo/benchmarks/collector/temp/fatsort-0.9.15.245/src/FAT_fs.c",
                  265U, "getClusterOffset");
    }
  }
#line 266
  if (! (cluster > 1U)) {
    {
#line 266
    __assert_fail("cluster > 1", "/home/june/repo/benchmarks/collector/temp/fatsort-0.9.15.245/src/FAT_fs.c",
                  266U, "getClusterOffset");
    }
  }
#line 270
  if ((int )bs->BS_FATSz16 != 0) {
#line 271
    FATSz = (u_int32_t )bs->BS_FATSz16;
  } else {
#line 273
    FATSz = bs->FATxx.FAT32.BS_FATSz32;
  }
#line 276
  RootDirSectors = (u_int32_t )(((int )bs->BS_RootEntCnt * 32 + ((int )bs->BS_BytesPerSec - 1)) / (int )bs->BS_BytesPerSec);
#line 277
  FirstDataSector = ((u_int32_t )bs->BS_RsvdSecCnt + (u_int32_t )bs->BS_NumFATs * FATSz) + RootDirSectors;
#line 279
  return (((off_t )(cluster - 2U) * (off_t )bs->BS_SecPerClus + (off_t )FirstDataSector) * (off_t )bs->BS_BytesPerSec);
}
}
#line 283 "/home/june/repo/benchmarks/collector/temp/fatsort-0.9.15.245/src/FAT_fs.c"
int32_t parseEntry(FILE *fd , union sDirEntry *de ) 
{ 
  off_t tmp ;

  {
#line 288
  if (! ((unsigned long )fd != (unsigned long )((void *)0))) {
    {
#line 288
    __assert_fail("fd != ((void *)0)", "/home/june/repo/benchmarks/collector/temp/fatsort-0.9.15.245/src/FAT_fs.c",
                  288U, "parseEntry");
    }
  }
#line 289
  if (! ((unsigned long )de != (unsigned long )((void *)0))) {
    {
#line 289
    __assert_fail("de != ((void *)0)", "/home/june/repo/benchmarks/collector/temp/fatsort-0.9.15.245/src/FAT_fs.c",
                  289U, "parseEntry");
    }
  }
  {
#line 291
  tmp = fs_read((void *)de, (u_int32_t )32, (u_int32_t )1, fd);
  }
#line 291
  if (tmp < 1L) {
    {
#line 292
    errormsg("parseEntry", "Failed to read from file!");
    }
#line 293
    return (-1);
  }
#line 296
  if ((int )de->ShortDirEntry.DIR_Name[0] == 0) {
#line 296
    return (0);
  }
#line 299
  if (((int )de->LongDirEntry.LDIR_Attr & 63) == 15) {
#line 299
    return (2);
  }
#line 301
  return (1);
}
}
#line 42 "/home/june/repo/benchmarks/collector/temp/fatsort-0.9.15.245/src/stringlist.h"
struct sStringList *newStringList(void) ;
#line 45
int32_t addStringToStringList(struct sStringList *stringList , char *str ) ;
#line 48
int32_t matchesStringList(struct sStringList *stringList , char *str ) ;
#line 58
void freeStringList(struct sStringList *stringList ) ;
#line 32 "/home/june/repo/benchmarks/collector/temp/fatsort-0.9.15.245/src/options.h"
u_int32_t OPT_VERSION  ;
#line 32 "/home/june/repo/benchmarks/collector/temp/fatsort-0.9.15.245/src/options.h"
u_int32_t OPT_HELP  ;
#line 32 "/home/june/repo/benchmarks/collector/temp/fatsort-0.9.15.245/src/options.h"
u_int32_t OPT_INFO  ;
#line 32 "/home/june/repo/benchmarks/collector/temp/fatsort-0.9.15.245/src/options.h"
u_int32_t OPT_QUIET  ;
#line 32 "/home/june/repo/benchmarks/collector/temp/fatsort-0.9.15.245/src/options.h"
u_int32_t OPT_IGNORE_CASE  ;
#line 32 "/home/june/repo/benchmarks/collector/temp/fatsort-0.9.15.245/src/options.h"
u_int32_t OPT_ORDER  ;
#line 32 "/home/june/repo/benchmarks/collector/temp/fatsort-0.9.15.245/src/options.h"
u_int32_t OPT_LIST  ;
#line 32 "/home/june/repo/benchmarks/collector/temp/fatsort-0.9.15.245/src/options.h"
u_int32_t OPT_REVERSE  ;
#line 32 "/home/june/repo/benchmarks/collector/temp/fatsort-0.9.15.245/src/options.h"
u_int32_t OPT_FORCE  ;
#line 32 "/home/june/repo/benchmarks/collector/temp/fatsort-0.9.15.245/src/options.h"
u_int32_t OPT_NATURAL_SORT  ;
#line 32 "/home/june/repo/benchmarks/collector/temp/fatsort-0.9.15.245/src/options.h"
u_int32_t OPT_RECURSIVE  ;
#line 32 "/home/june/repo/benchmarks/collector/temp/fatsort-0.9.15.245/src/options.h"
u_int32_t OPT_RANDOM  ;
#line 35 "/home/june/repo/benchmarks/collector/temp/fatsort-0.9.15.245/src/options.h"
struct sStringList *OPT_INCL_DIRS  ;
#line 35 "/home/june/repo/benchmarks/collector/temp/fatsort-0.9.15.245/src/options.h"
struct sStringList *OPT_EXCL_DIRS  ;
#line 35 "/home/june/repo/benchmarks/collector/temp/fatsort-0.9.15.245/src/options.h"
struct sStringList *OPT_INCL_DIRS_REC  ;
#line 35 "/home/june/repo/benchmarks/collector/temp/fatsort-0.9.15.245/src/options.h"
struct sStringList *OPT_EXCL_DIRS_REC  ;
#line 35 "/home/june/repo/benchmarks/collector/temp/fatsort-0.9.15.245/src/options.h"
struct sStringList *OPT_IGNORE_PREFIXES_LIST  ;
#line 41
int32_t matchesDirPathLists(struct sStringList *includes , struct sStringList *includes_recursion ,
                            struct sStringList *excludes , struct sStringList *excludes_recursion ,
                            char *str ) ;
#line 57 "/usr/include/getopt.h"
extern char *optarg ;
#line 76
extern int opterr ;
#line 80
extern int optopt ;
#line 150
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) getopt)(int ___argc ,
                                                                             char * const  *___argv ,
                                                                             char const   *__shortopts ) ;
#line 140 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strncat)(char * __restrict  __dest ,
                                                                                                  char const   * __restrict  __src ,
                                                                                                  size_t __n ) ;
#line 38 "/home/june/repo/benchmarks/collector/temp/fatsort-0.9.15.245/src/options.c"
int32_t addDirPathToStringList(struct sStringList *stringList , char *str ) 
{ 
  size_t tmp ;
  char *newStr ;
  int32_t ret ;
  int32_t prefix ;
  int32_t suffix ;
  int32_t len ;
  size_t tmp___0 ;
  void *tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;

  {
#line 42
  if (! ((unsigned long )stringList != (unsigned long )((void *)0))) {
    {
#line 42
    __assert_fail("stringList != ((void *)0)", "/home/june/repo/benchmarks/collector/temp/fatsort-0.9.15.245/src/options.c",
                  42U, "addDirPathToStringList");
    }
  }
#line 43
  if (! ((unsigned long )stringList->str == (unsigned long )((void *)0))) {
    {
#line 43
    __assert_fail("stringList->str == ((void *)0)", "/home/june/repo/benchmarks/collector/temp/fatsort-0.9.15.245/src/options.c",
                  43U, "addDirPathToStringList");
    }
  }
#line 44
  if (! ((unsigned long )str != (unsigned long )((void *)0))) {
    {
#line 44
    __assert_fail("str != ((void *)0)", "/home/june/repo/benchmarks/collector/temp/fatsort-0.9.15.245/src/options.c",
                  44U, "addDirPathToStringList");
    }
  }
  {
#line 45
  tmp = strlen((char const   *)str);
  }
#line 45
  if (! (tmp <= 512UL)) {
    {
#line 45
    __assert_fail("strlen(str) <= 512", "/home/june/repo/benchmarks/collector/temp/fatsort-0.9.15.245/src/options.c",
                  45U, "addDirPathToStringList");
    }
  }
  {
#line 49
  prefix = 0;
#line 49
  suffix = 0;
#line 51
  tmp___0 = strlen((char const   *)str);
#line 51
  len = (int32_t )tmp___0;
  }
#line 54
  if ((int )*(str + 0) != 47) {
#line 54
    prefix = 1;
  }
#line 55
  if ((int )*(str + (len - 1)) != 47) {
#line 55
    suffix = 1;
  }
  {
#line 58
  tmp___1 = malloc((size_t )(((prefix + len) + suffix) + 1));
#line 58
  newStr = (char *)tmp___1;
  }
#line 59
  if ((unsigned long )newStr == (unsigned long )((void *)0)) {
    {
#line 60
    tmp___2 = __errno_location();
#line 60
    tmp___3 = strerror(*tmp___2);
#line 60
    errormsg("addDirPathToStringList", "%s!", tmp___3);
    }
#line 61
    return (-1);
  }
  {
#line 65
  *(newStr + 0) = (char )'\000';
#line 66
  strncat((char */* __restrict  */)newStr, (char const   */* __restrict  */)"/", (size_t )prefix);
#line 67
  strncat((char */* __restrict  */)newStr, (char const   */* __restrict  */)str, (size_t )len);
#line 68
  strncat((char */* __restrict  */)newStr, (char const   */* __restrict  */)"/", (size_t )suffix);
  }
#line 70
  if ((prefix + len) + suffix > 512) {
#line 71
    *(newStr + 512) = (char )'\000';
  } else {
#line 73
    *(newStr + ((prefix + len) + suffix)) = (char )'\000';
  }
  {
#line 76
  ret = addStringToStringList(stringList, newStr);
#line 78
  free((void *)newStr);
  }
#line 80
  return (ret);
}
}
#line 84 "/home/june/repo/benchmarks/collector/temp/fatsort-0.9.15.245/src/options.c"
int32_t matchesDirPathLists(struct sStringList *includes , struct sStringList *includes_recursion ,
                            struct sStringList *excludes , struct sStringList *excludes_recursion ,
                            char *str ) 
{ 
  int32_t incl ;
  int32_t incl_rec ;
  int32_t excl ;
  int32_t excl_rec ;

  {
  {
#line 95
  incl = matchesStringList(includes, (char *)str);
#line 96
  incl_rec = matchesStringList(includes_recursion, (char *)str);
#line 97
  excl = matchesStringList(excludes, (char *)str);
#line 98
  excl_rec = matchesStringList(excludes_recursion, (char *)str);
  }
#line 103
  if ((unsigned long )includes->next == (unsigned long )((void *)0)) {
#line 103
    if ((unsigned long )includes_recursion->next == (unsigned long )((void *)0)) {
#line 106
      if (excl != 1) {
#line 106
        if (excl_rec == 0) {
#line 107
          return (1);
        }
      }
    } else {
#line 103
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 113
  if (incl == 1) {
#line 113
    goto _L;
  } else
#line 113
  if (incl_rec != 0) {
    _L: /* CIL Label */ 
#line 113
    if (excl != 1) {
#line 113
      if (excl_rec == 0) {
#line 115
        return (1);
      }
    }
  }
#line 119
  return (0);
}
}
#line 122 "/home/june/repo/benchmarks/collector/temp/fatsort-0.9.15.245/src/options.c"
int32_t parse_options(int argc , char **argv ) 
{ 
  int8_t c ;
  int32_t tmp ;
  int32_t tmp___0 ;
  int32_t tmp___1 ;
  int32_t tmp___2 ;
  int32_t tmp___3 ;
  int tmp___4 ;

  {
  {
#line 130
  OPT_REVERSE = (u_int32_t )1;
#line 133
  OPT_NATURAL_SORT = (u_int32_t )0;
#line 136
  OPT_RANDOM = (u_int32_t )0;
#line 139
  OPT_INCL_DIRS = newStringList();
#line 140
  OPT_INCL_DIRS_REC = newStringList();
#line 141
  OPT_EXCL_DIRS = newStringList();
#line 142
  OPT_EXCL_DIRS_REC = newStringList();
#line 145
  OPT_IGNORE_PREFIXES_LIST = newStringList();
#line 147
  opterr = 0;
  }
  {
#line 148
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 148
    tmp___4 = getopt(argc, (char * const  *)argv, "ivhqcfo:lrRnd:D:x:X:I:");
#line 148
    c = (int8_t )tmp___4;
    }
#line 148
    if (! ((int )c != -1)) {
#line 148
      goto while_break;
    }
    {
#line 150
    if ((int )c == 99) {
#line 150
      goto case_99;
    }
#line 151
    if ((int )c == 102) {
#line 151
      goto case_102;
    }
#line 152
    if ((int )c == 104) {
#line 152
      goto case_104;
    }
#line 153
    if ((int )c == 105) {
#line 153
      goto case_105;
    }
#line 154
    if ((int )c == 108) {
#line 154
      goto case_108;
    }
#line 155
    if ((int )c == 111) {
#line 155
      goto case_111;
    }
#line 166
    if ((int )c == 100) {
#line 166
      goto case_100___0;
    }
#line 172
    if ((int )c == 68) {
#line 172
      goto case_68;
    }
#line 178
    if ((int )c == 120) {
#line 178
      goto case_120;
    }
#line 184
    if ((int )c == 88) {
#line 184
      goto case_88;
    }
#line 190
    if ((int )c == 73) {
#line 190
      goto case_73;
    }
#line 196
    if ((int )c == 110) {
#line 196
      goto case_110;
    }
#line 197
    if ((int )c == 113) {
#line 197
      goto case_113;
    }
#line 198
    if ((int )c == 114) {
#line 198
      goto case_114;
    }
#line 199
    if ((int )c == 82) {
#line 199
      goto case_82;
    }
#line 200
    if ((int )c == 118) {
#line 200
      goto case_118;
    }
#line 201
    goto switch_default___0;
    case_99: /* CIL Label */ 
#line 150
    OPT_IGNORE_CASE = (u_int32_t )1;
#line 150
    goto switch_break;
    case_102: /* CIL Label */ 
#line 151
    OPT_FORCE = (u_int32_t )1;
#line 151
    goto switch_break;
    case_104: /* CIL Label */ 
#line 152
    OPT_HELP = (u_int32_t )1;
#line 152
    goto switch_break;
    case_105: /* CIL Label */ 
#line 153
    OPT_INFO = (u_int32_t )1;
#line 153
    goto switch_break;
    case_108: /* CIL Label */ 
#line 154
    OPT_LIST = (u_int32_t )1;
#line 154
    goto switch_break;
    case_111: /* CIL Label */ 
    {
#line 157
    if ((int )*(optarg + 0) == 100) {
#line 157
      goto case_100;
    }
#line 158
    if ((int )*(optarg + 0) == 102) {
#line 158
      goto case_102___0;
    }
#line 159
    if ((int )*(optarg + 0) == 97) {
#line 159
      goto case_97;
    }
#line 160
    goto switch_default;
    case_100: /* CIL Label */ 
#line 157
    OPT_ORDER = (u_int32_t )0;
#line 157
    goto switch_break___0;
    case_102___0: /* CIL Label */ 
#line 158
    OPT_ORDER = (u_int32_t )1;
#line 158
    goto switch_break___0;
    case_97: /* CIL Label */ 
#line 159
    OPT_ORDER = (u_int32_t )2;
#line 159
    goto switch_break___0;
    switch_default: /* CIL Label */ 
    {
#line 161
    errormsg("parse_options", "Unknown flag \'%c\' for option \'o\'.", (int )*(optarg + 0));
#line 162
    errormsg("parse_options", "Use -h for more help.");
    }
#line 163
    return (-1);
    switch_break___0: /* CIL Label */ ;
    }
#line 165
    goto switch_break;
    case_100___0: /* CIL Label */ 
    {
#line 167
    tmp = addDirPathToStringList(OPT_INCL_DIRS, (char *)optarg);
    }
#line 167
    if (tmp) {
      {
#line 168
      errormsg("parse_options", "Could not add directory path to dirPathList");
      }
#line 169
      return (-1);
    }
#line 171
    goto switch_break;
    case_68: /* CIL Label */ 
    {
#line 173
    tmp___0 = addDirPathToStringList(OPT_INCL_DIRS_REC, (char *)optarg);
    }
#line 173
    if (tmp___0) {
      {
#line 174
      errormsg("parse_options", "Could not add directory path to string list");
      }
#line 175
      return (-1);
    }
#line 177
    goto switch_break;
    case_120: /* CIL Label */ 
    {
#line 179
    tmp___1 = addDirPathToStringList(OPT_EXCL_DIRS, (char *)optarg);
    }
#line 179
    if (tmp___1) {
      {
#line 180
      errormsg("parse_options", "Could not add directory path to string list");
      }
#line 181
      return (-1);
    }
#line 183
    goto switch_break;
    case_88: /* CIL Label */ 
    {
#line 185
    tmp___2 = addDirPathToStringList(OPT_EXCL_DIRS_REC, (char *)optarg);
    }
#line 185
    if (tmp___2) {
      {
#line 186
      errormsg("parse_options", "Could not add directory path to string list");
      }
#line 187
      return (-1);
    }
#line 189
    goto switch_break;
    case_73: /* CIL Label */ 
    {
#line 191
    tmp___3 = addStringToStringList(OPT_IGNORE_PREFIXES_LIST, optarg);
    }
#line 191
    if (tmp___3) {
      {
#line 192
      errormsg("parse_options", "Could not add directory path to string list");
      }
#line 193
      return (-1);
    }
#line 195
    goto switch_break;
    case_110: /* CIL Label */ 
#line 196
    OPT_NATURAL_SORT = (u_int32_t )1;
#line 196
    goto switch_break;
    case_113: /* CIL Label */ 
#line 197
    OPT_QUIET = (u_int32_t )1;
#line 197
    goto switch_break;
    case_114: /* CIL Label */ 
#line 198
    OPT_REVERSE = (u_int32_t )-1;
#line 198
    goto switch_break;
    case_82: /* CIL Label */ 
#line 199
    OPT_RANDOM = (u_int32_t )1;
#line 199
    goto switch_break;
    case_118: /* CIL Label */ 
#line 200
    OPT_VERSION = (u_int32_t )1;
#line 200
    goto switch_break;
    switch_default___0: /* CIL Label */ 
    {
#line 202
    errormsg("parse_options", "Unknown option \'%c\'.", optopt);
#line 203
    errormsg("parse_options", "Use -h for more help.");
    }
#line 204
    return (-1);
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 208
  return (0);
}
}
#line 211 "/home/june/repo/benchmarks/collector/temp/fatsort-0.9.15.245/src/options.c"
void freeOptions(void) 
{ 


  {
  {
#line 212
  freeStringList(OPT_INCL_DIRS);
#line 213
  freeStringList(OPT_INCL_DIRS_REC);
#line 214
  freeStringList(OPT_EXCL_DIRS);
#line 215
  freeStringList(OPT_EXCL_DIRS_REC);
#line 216
  freeStringList(OPT_IGNORE_PREFIXES_LIST);
  }
#line 217
  return;
}
}
#line 127 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) toupper)(int __c ) ;
#line 32 "/home/june/repo/benchmarks/collector/temp/fatsort-0.9.15.245/src/natstrcmp.c"
int32_t isDigit(char const   c ) 
{ 


  {
#line 36
  if ((int const   )c >= 48) {
#line 36
    if ((int const   )c <= 57) {
#line 36
      return (1);
    }
  }
#line 38
  return (0);
}
}
#line 41 "/home/june/repo/benchmarks/collector/temp/fatsort-0.9.15.245/src/natstrcmp.c"
u_int32_t parseNumber(char **s ) 
{ 
  u_int32_t value ;
  int32_t tmp ;
  int32_t tmp___0 ;

  {
  {
#line 45
  value = (u_int32_t )0;
#line 47
  tmp = isDigit((char const   )*(*s));
  }
#line 47
  if (! tmp) {
#line 47
    return ((u_int32_t )-1);
  }
  {
#line 49
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 49
    tmp___0 = isDigit((char const   )*(*s));
    }
#line 49
    if (! tmp___0) {
#line 49
      goto while_break;
    }
#line 50
    value = (value * 10U + (u_int32_t )*(*s)) - 48U;
#line 51
    (*s) ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 54
  return (value);
}
}
#line 57 "/home/june/repo/benchmarks/collector/temp/fatsort-0.9.15.245/src/natstrcmp.c"
int32_t natstrcompare(char const   *str1 , char const   *str2 , u_int32_t const   respectCase ) 
{ 
  u_int32_t n1 ;
  u_int32_t n2 ;
  char *s1 ;
  char *s2 ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int32_t tmp___6 ;
  int32_t tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;

  {
#line 61
  if (! ((unsigned long )str1 != (unsigned long )((void *)0))) {
    {
#line 61
    __assert_fail("str1 != ((void *)0)", "/home/june/repo/benchmarks/collector/temp/fatsort-0.9.15.245/src/natstrcmp.c",
                  61U, "natstrcompare");
    }
  }
#line 62
  if (! ((unsigned long )str2 != (unsigned long )((void *)0))) {
    {
#line 62
    __assert_fail("str2 != ((void *)0)", "/home/june/repo/benchmarks/collector/temp/fatsort-0.9.15.245/src/natstrcmp.c",
                  62U, "natstrcompare");
    }
  }
#line 64
  n1 = (u_int32_t )0;
#line 64
  n2 = (u_int32_t )0;
#line 65
  s1 = (char *)str1;
#line 66
  s2 = (char *)str2;
  {
#line 68
  while (1) {
    while_continue: /* CIL Label */ ;
#line 71
    if ((int )*s1 == 0) {
      {
#line 72
      tmp = strcmp((char const   *)s1, (char const   *)s2);
      }
#line 72
      return (tmp);
    } else
#line 71
    if ((int )*s2 == 0) {
      {
#line 72
      tmp = strcmp((char const   *)s1, (char const   *)s2);
      }
#line 72
      return (tmp);
    }
    {
#line 76
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 77
      tmp___6 = isDigit((char const   )*s1);
      }
#line 77
      if (tmp___6) {
#line 77
        goto while_break___0;
      } else {
        {
#line 77
        tmp___7 = isDigit((char const   )*s2);
        }
#line 77
        if (tmp___7) {
#line 77
          goto while_break___0;
        } else
#line 78
        if ((int )*s1 == 0) {
#line 78
          if ((int )*s1 == 0) {
#line 78
            return (0);
          } else {
#line 78
            goto _L;
          }
        } else
        _L: /* CIL Label */ 
#line 79
        if ((int )*s2 == 0) {
#line 80
          return (1);
        } else {
#line 79
          if (respectCase) {
            {
#line 79
            tmp___3 = toupper((int )*s1);
#line 79
            tmp___4 = toupper((int )*s2);
#line 79
            tmp___5 = tmp___3 > tmp___4;
            }
          } else {
#line 79
            tmp___5 = (int )*s1 > (int )*s2;
          }
#line 79
          if (tmp___5) {
#line 80
            return (1);
          } else
#line 81
          if ((int )*s1 == 0) {
#line 82
            return (-1);
          } else {
#line 81
            if (respectCase) {
              {
#line 81
              tmp___0 = toupper((int )*s1);
#line 81
              tmp___1 = toupper((int )*s2);
#line 81
              tmp___2 = tmp___0 < tmp___1;
              }
            } else {
#line 81
              tmp___2 = (int )*s1 < (int )*s2;
            }
#line 81
            if (tmp___2) {
#line 82
              return (-1);
            }
          }
        }
      }
#line 83
      s1 ++;
#line 83
      s2 ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 87
    n1 = parseNumber(& s1);
#line 88
    n2 = parseNumber(& s2);
    }
#line 93
    if (n1 == 4294967295U) {
#line 93
      goto _L___3;
    } else
#line 93
    if (n2 == 4294967295U) {
      _L___3: /* CIL Label */ 
#line 94
      if ((int )*s1 == 0) {
#line 94
        if (n1 == 4294967295U) {
#line 94
          return (-1);
        } else {
#line 94
          goto _L___2;
        }
      } else
      _L___2: /* CIL Label */ 
#line 95
      if ((int )*s1 == 0) {
#line 95
        if (n2 == 4294967295U) {
#line 95
          if (48 < (int )*s2) {
#line 95
            tmp___8 = -1;
          } else {
#line 95
            tmp___8 = 1;
          }
#line 95
          return (tmp___8);
        } else {
#line 95
          goto _L___1;
        }
      } else
      _L___1: /* CIL Label */ 
#line 96
      if ((int )*s2 == 0) {
#line 96
        if (n1 == 4294967295U) {
#line 96
          if (48 < (int )*s1) {
#line 96
            tmp___9 = 1;
          } else {
#line 96
            tmp___9 = -1;
          }
#line 96
          return (tmp___9);
        } else {
#line 96
          goto _L___0;
        }
      } else
      _L___0: /* CIL Label */ 
#line 97
      if ((int )*s2 == 0) {
#line 97
        if (n2 == 4294967295U) {
#line 97
          return (1);
        }
      }
    } else
#line 99
    if (n1 != n2) {
#line 99
      if (n1 > n2) {
#line 99
        tmp___10 = 1;
      } else {
#line 99
        tmp___10 = -1;
      }
#line 99
      return (tmp___10);
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 103 "/home/june/repo/benchmarks/collector/temp/fatsort-0.9.15.245/src/natstrcmp.c"
int32_t natstrcmp(char const   *str1 , char const   *str2 ) 
{ 
  int32_t tmp ;

  {
  {
#line 104
  tmp = natstrcompare(str1, str2, (u_int32_t const   )0);
  }
#line 104
  return (tmp);
}
}
#line 107 "/home/june/repo/benchmarks/collector/temp/fatsort-0.9.15.245/src/natstrcmp.c"
int32_t natstrcasecmp(char const   *str1 , char const   *str2 ) 
{ 
  int32_t tmp ;

  {
  {
#line 108
  tmp = natstrcompare(str1, str2, (u_int32_t const   )1);
  }
#line 108
  return (tmp);
}
}
#line 734 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) realpath)(char const   * __restrict  __name ,
                                                                                 char * __restrict  __resolved ) ;
#line 306 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) FILE *( __attribute__((__leaf__)) fdopen)(int __fd ,
                                                                               char const   *__modes ) ;
#line 35 "/home/june/repo/benchmarks/collector/temp/fatsort-0.9.15.245/src/sort.h"
int32_t sort_FAT16_rootdir(FILE *fd , struct sBootSector *bs ) ;
#line 38
int32_t sortClusterChain(FILE *fd , struct sBootSector *bs , u_int32_t cluster , char *path ) ;
#line 353 "/usr/include/unistd.h"
extern int close(int __fd ) ;
#line 137 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcat)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 236
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strchr)(char const   *__s ,
                                                                                               int __c )  __attribute__((__pure__)) ;
#line 149 "/usr/include/fcntl.h"
extern int ( __attribute__((__nonnull__(1))) open)(char const   *__file , int __oflag 
                                                   , ...)  __asm__("open64")  ;
#line 37 "/usr/include/iconv.h"
extern iconv_t iconv_open(char const   *__tocode , char const   *__fromcode ) ;
#line 42
extern size_t iconv(iconv_t __cd , char ** __restrict  __inbuf , size_t * __restrict  __inbytesleft ,
                    char ** __restrict  __outbuf , size_t * __restrict  __outbytesleft ) ;
#line 66 "/usr/include/mntent.h"
extern  __attribute__((__nothrow__)) FILE *( __attribute__((__leaf__)) setmntent)(char const   *__file ,
                                                                                  char const   *__mode ) ;
#line 71
extern  __attribute__((__nothrow__)) struct mntent *( __attribute__((__leaf__)) getmntent)(FILE *__stream ) ;
#line 87
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) endmntent)(FILE *__stream ) ;
#line 56 "/home/june/repo/benchmarks/collector/temp/fatsort-0.9.15.245/src/sort.c"
u_int32_t check_mounted(char *filename ) 
{ 
  FILE *fd ;
  struct mntent *mnt ;
  u_int32_t ret ;
  char rp_filename[4096] ;
  char rp_mnt_fsname[4096] ;
  int *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;

  {
  {
#line 64
  ret = (u_int32_t )0;
#line 67
  fd = setmntent("/etc/mtab", "r");
  }
#line 67
  if ((unsigned long )fd == (unsigned long )((void *)0)) {
    {
#line 68
    tmp = __errno_location();
#line 68
    tmp___0 = strerror(*tmp);
#line 68
    errormsg("check_mounted", "%s!", tmp___0);
    }
#line 69
    return ((u_int32_t )-1);
  }
  {
#line 73
  tmp___1 = realpath((char const   */* __restrict  */)filename, (char */* __restrict  */)(rp_filename));
  }
#line 73
  if ((unsigned long )tmp___1 == (unsigned long )((void *)0)) {
    {
#line 74
    errormsg("check_mounted", "Unable to get realpath of filename!");
    }
#line 75
    return ((u_int32_t )-1);
  }
  {
#line 78
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 78
    mnt = getmntent(fd);
    }
#line 78
    if (! ((unsigned long )mnt != (unsigned long )((void *)0))) {
#line 78
      goto while_break;
    }
    {
#line 79
    tmp___3 = realpath((char const   */* __restrict  */)mnt->mnt_fsname, (char */* __restrict  */)(rp_mnt_fsname));
    }
#line 79
    if ((unsigned long )tmp___3 != (unsigned long )((void *)0)) {
      {
#line 80
      tmp___2 = strcmp((char const   *)(rp_mnt_fsname), (char const   *)(rp_filename));
      }
#line 80
      if (tmp___2 == 0) {
#line 81
        ret = (u_int32_t )1;
#line 82
        goto while_break;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 87
  tmp___4 = endmntent(fd);
  }
#line 87
  if (tmp___4 != 1) {
    {
#line 88
    errormsg("check_mounted", "Closing mtab failed!");
    }
#line 89
    return ((u_int32_t )-1);
  }
#line 92
  return (ret);
}
}
#line 130 "/home/june/repo/benchmarks/collector/temp/fatsort-0.9.15.245/src/sort.c"
void parseLongFilenamePart(struct sLongDirEntry *lde , char *str ) 
{ 
  iconv_t cd ;
  size_t incount ;
  size_t outcount ;
  char *outptr ;
  char utf16str[28] ;
  char *inptr ;
  size_t ret ;

  {
#line 137
  if (! ((unsigned long )lde != (unsigned long )((void *)0))) {
    {
#line 137
    __assert_fail("lde != ((void *)0)", "/home/june/repo/benchmarks/collector/temp/fatsort-0.9.15.245/src/sort.c",
                  137U, "parseLongFilenamePart");
    }
  }
#line 138
  if (! ((unsigned long )str != (unsigned long )((void *)0))) {
    {
#line 138
    __assert_fail("str != ((void *)0)", "/home/june/repo/benchmarks/collector/temp/fatsort-0.9.15.245/src/sort.c",
                  138U, "parseLongFilenamePart");
    }
  }
  {
#line 143
  outptr = str + 0;
#line 145
  inptr = & utf16str[0];
#line 148
  *(str + 0) = (char )'\000';
#line 150
  memcpy((void */* __restrict  */)(utf16str), (void const   */* __restrict  */)(& lde->LDIR_Ord + 1),
         (size_t )10);
#line 151
  memcpy((void */* __restrict  */)(utf16str + 10), (void const   */* __restrict  */)(& lde->LDIR_Ord + 14),
         (size_t )12);
#line 152
  memcpy((void */* __restrict  */)(utf16str + 22), (void const   */* __restrict  */)(& lde->LDIR_Ord + 28),
         (size_t )4);
#line 153
  memset((void *)(utf16str + 26), 0, (size_t )2);
#line 155
  incount = (size_t )26;
#line 156
  outcount = (size_t )512;
#line 158
  cd = iconv_open("UTF-8", "UTF-16LE");
  }
#line 160
  if ((unsigned long )cd == (unsigned long )((iconv_t )-1)) {
    {
#line 161
    errormsg("parseLongFilenamePart", "iconv_open failed!");
    }
#line 162
    return;
  }
  {
#line 165
  while (1) {
    while_continue: /* CIL Label */ ;
#line 165
    if (! (incount != 0UL)) {
#line 165
      goto while_break;
    }
    {
#line 166
    ret = iconv(cd, (char **/* __restrict  */)(& inptr), (size_t */* __restrict  */)(& incount),
                (char **/* __restrict  */)(& outptr), (size_t */* __restrict  */)(& outcount));
    }
#line 166
    if (ret == 0xffffffffffffffffUL) {
      {
#line 167
      errormsg("parseLongFilenamePart", "iconv failed! %d", ret);
      }
#line 168
      return;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 171
  *(outptr + 0) = (char )'\000';
#line 177
  return;
}
}
#line 180 "/home/june/repo/benchmarks/collector/temp/fatsort-0.9.15.245/src/sort.c"
void parseShortFilename(struct sShortDirEntry *sde , char *str ) 
{ 
  char *s ;

  {
#line 185
  if (! ((unsigned long )sde != (unsigned long )((void *)0))) {
    {
#line 185
    __assert_fail("sde != ((void *)0)", "/home/june/repo/benchmarks/collector/temp/fatsort-0.9.15.245/src/sort.c",
                  185U, "parseShortFilename");
    }
  }
#line 186
  if (! ((unsigned long )str != (unsigned long )((void *)0))) {
    {
#line 186
    __assert_fail("str != ((void *)0)", "/home/june/repo/benchmarks/collector/temp/fatsort-0.9.15.245/src/sort.c",
                  186U, "parseShortFilename");
    }
  }
  {
#line 189
  strncpy((char */* __restrict  */)str, (char const   */* __restrict  */)(sde->DIR_Name),
          (size_t )8);
#line 190
  *(str + 8) = (char )'\000';
#line 191
  s = strchr((char const   *)str, ' ');
  }
#line 192
  if ((unsigned long )s != (unsigned long )((void *)0)) {
#line 192
    *(s + 0) = (char )'\000';
  }
#line 193
  if ((int )*(sde->DIR_Name + 8) != 32) {
    {
#line 194
    strcat((char */* __restrict  */)str, (char const   */* __restrict  */)".");
#line 195
    strncat((char */* __restrict  */)str, (char const   */* __restrict  */)(sde->DIR_Name + 8),
            (size_t )3);
#line 196
    *(str + 12) = (char )'\000';
    }
  }
#line 198
  return;
}
}
#line 200 "/home/june/repo/benchmarks/collector/temp/fatsort-0.9.15.245/src/sort.c"
int32_t parseClusterChain(FILE *fd , struct sBootSector *bs , struct sClusterChain *chain ,
                          struct sDirEntryList *list , u_int32_t *direntries ) 
{ 
  int32_t j ;
  int32_t ret ;
  u_int32_t maxEntries ;
  u_int32_t entries ;
  union sDirEntry de ;
  struct sDirEntryList *lnde ;
  struct sLongDirEntryList *llist ;
  char tmp[513] ;
  char dummy[513] ;
  char sname[513] ;
  char lname[513] ;
  off_t tmp___0 ;
  size_t tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 205
  if (! ((unsigned long )fd != (unsigned long )((void *)0))) {
    {
#line 205
    __assert_fail("fd != ((void *)0)", "/home/june/repo/benchmarks/collector/temp/fatsort-0.9.15.245/src/sort.c",
                  205U, "parseClusterChain");
    }
  }
#line 206
  if (! ((unsigned long )bs != (unsigned long )((void *)0))) {
    {
#line 206
    __assert_fail("bs != ((void *)0)", "/home/june/repo/benchmarks/collector/temp/fatsort-0.9.15.245/src/sort.c",
                  206U, "parseClusterChain");
    }
  }
#line 207
  if (! ((unsigned long )chain != (unsigned long )((void *)0))) {
    {
#line 207
    __assert_fail("chain != ((void *)0)", "/home/june/repo/benchmarks/collector/temp/fatsort-0.9.15.245/src/sort.c",
                  207U, "parseClusterChain");
    }
  }
#line 208
  if (! ((unsigned long )list != (unsigned long )((void *)0))) {
    {
#line 208
    __assert_fail("list != ((void *)0)", "/home/june/repo/benchmarks/collector/temp/fatsort-0.9.15.245/src/sort.c",
                  208U, "parseClusterChain");
    }
  }
#line 209
  if (! ((unsigned long )direntries != (unsigned long )((void *)0))) {
    {
#line 209
    __assert_fail("direntries != ((void *)0)", "/home/june/repo/benchmarks/collector/temp/fatsort-0.9.15.245/src/sort.c",
                  209U, "parseClusterChain");
    }
  }
#line 212
  entries = (u_int32_t )0;
#line 218
  *direntries = (u_int32_t )0;
#line 220
  maxEntries = (u_int32_t )(((int )bs->BS_SecPerClus * (int )bs->BS_BytesPerSec) / 32);
#line 222
  chain = chain->next;
#line 224
  llist = (struct sLongDirEntryList *)((void *)0);
#line 225
  lname[0] = (char )'\000';
  {
#line 226
  while (1) {
    while_continue: /* CIL Label */ ;
#line 226
    if (! ((unsigned long )chain != (unsigned long )((void *)0))) {
#line 226
      goto while_break;
    }
    {
#line 227
    tmp___0 = getClusterOffset(bs, chain->cluster);
#line 227
    fs_seek(fd, tmp___0, 0);
#line 228
    j = 1;
    }
    {
#line 228
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 228
      if (! ((u_int32_t )j <= maxEntries)) {
#line 228
        goto while_break___0;
      }
      {
#line 229
      entries ++;
#line 230
      ret = parseEntry(fd, & de);
      }
#line 231
      if (ret == -1) {
        {
#line 232
        errormsg("parseClusterChain", "Failed to parse directory entry!");
        }
#line 233
        return (-1);
      } else
#line 234
      if (ret == 0) {
#line 236
        return (0);
      } else
#line 237
      if (ret == 2) {
        {
#line 238
        parseLongFilenamePart(& de.LongDirEntry, tmp);
#line 241
        llist = insertLongDirEntryList(& de.LongDirEntry, llist);
        }
#line 242
        if ((unsigned long )llist == (unsigned long )((void *)0)) {
          {
#line 243
          errormsg("parseClusterChain", "Failed to insert LongDirEntry!");
          }
#line 244
          return (-1);
        }
        {
#line 247
        strncpy((char */* __restrict  */)(dummy), (char const   */* __restrict  */)(tmp),
                (size_t )512);
#line 248
        dummy[512] = (char )'\000';
#line 249
        tmp___1 = strlen((char const   *)(dummy));
#line 249
        strncat((char */* __restrict  */)(dummy), (char const   */* __restrict  */)(lname),
                512UL - tmp___1);
#line 250
        dummy[512] = (char )'\000';
#line 251
        strncpy((char */* __restrict  */)(lname), (char const   */* __restrict  */)(dummy),
                (size_t )512);
#line 252
        dummy[512] = (char )'\000';
        }
      } else {
        {
#line 254
        parseShortFilename(& de.ShortDirEntry, sname);
        }
#line 255
        if (OPT_LIST) {
          {
#line 255
          tmp___3 = strcmp((char const   *)(sname), ".");
          }
#line 255
          if (tmp___3) {
            {
#line 255
            tmp___4 = strcmp((char const   *)(sname), "..");
            }
#line 255
            if (tmp___4) {
#line 255
              if ((int )sname[0] != -27) {
#line 255
                if (! ((int )de.ShortDirEntry.DIR_Atrr & 8)) {
#line 259
                  if ((int )lname[0] != 0) {
#line 259
                    tmp___2 = lname;
                  } else {
#line 259
                    tmp___2 = sname;
                  }
                  {
#line 259
                  printf((char const   */* __restrict  */)"%s\n", tmp___2);
                  }
                }
              }
            }
          }
        }
        {
#line 262
        lnde = newDirEntry(sname, lname, & de.ShortDirEntry, llist, entries);
        }
#line 263
        if ((unsigned long )lnde == (unsigned long )((void *)0)) {
          {
#line 264
          errormsg("parseClusterChain", "Failed to create DirEntry!");
          }
#line 265
          return (-1);
        }
        {
#line 268
        insertDirEntryList(lnde, list);
#line 269
        (*direntries) ++;
#line 270
        entries = (u_int32_t )0;
#line 271
        llist = (struct sLongDirEntryList *)((void *)0);
#line 272
        lname[0] = (char )'\000';
        }
      }
#line 228
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 275
    chain = chain->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 278
  return (0);
}
}
#line 281 "/home/june/repo/benchmarks/collector/temp/fatsort-0.9.15.245/src/sort.c"
int32_t parseDirEntry(FILE *fd , struct sDirEntryList *list , u_int32_t *entries ) 
{ 
  char sname[513] ;
  char lname[513] ;
  char tmp[513] ;
  char dummy[513] ;
  union sDirEntry de ;
  struct sDirEntryList *lnde ;
  u_int32_t count ;
  struct sLongDirEntryList *llist ;
  off_t tmp___0 ;
  size_t tmp___1 ;
  off_t tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 286
  if (! ((unsigned long )fd != (unsigned long )((void *)0))) {
    {
#line 286
    __assert_fail("fd != ((void *)0)", "/home/june/repo/benchmarks/collector/temp/fatsort-0.9.15.245/src/sort.c",
                  286U, "parseDirEntry");
    }
  }
#line 287
  if (! ((unsigned long )list != (unsigned long )((void *)0))) {
    {
#line 287
    __assert_fail("list != ((void *)0)", "/home/june/repo/benchmarks/collector/temp/fatsort-0.9.15.245/src/sort.c",
                  287U, "parseDirEntry");
    }
  }
#line 288
  if (! ((unsigned long )entries != (unsigned long )((void *)0))) {
    {
#line 288
    __assert_fail("entries != ((void *)0)", "/home/june/repo/benchmarks/collector/temp/fatsort-0.9.15.245/src/sort.c",
                  288U, "parseDirEntry");
    }
  }
  {
#line 293
  count = (u_int32_t )0;
#line 295
  llist = (struct sLongDirEntryList *)((void *)0);
#line 298
  tmp___0 = fs_read((void *)(& de), (u_int32_t )32, (u_int32_t )1, fd);
  }
#line 298
  if (tmp___0 < 1L) {
    {
#line 299
    errormsg("parseDirEntry", "Failed to read from file!");
    }
#line 300
    return (-1);
  }
#line 304
  if ((int )de.LongDirEntry.LDIR_Ord == 0) {
#line 305
    return (1);
  }
#line 308
  lname[0] = (char )'\000';
#line 309
  *entries = (u_int32_t )0;
  {
#line 310
  while (1) {
    while_continue: /* CIL Label */ ;
#line 310
    if (! (((int )de.LongDirEntry.LDIR_Attr & 63) == 15)) {
#line 310
      goto while_break;
    }
    {
#line 312
    parseLongFilenamePart(& de.LongDirEntry, tmp);
#line 315
    llist = insertLongDirEntryList(& de.LongDirEntry, llist);
    }
#line 316
    if ((unsigned long )llist == (unsigned long )((void *)0)) {
      {
#line 317
      errormsg("parseDirEntry", "Failed to insert LongDirEntry!");
      }
#line 318
      return (-1);
    }
    {
#line 321
    count ++;
#line 322
    (*entries) ++;
#line 323
    strncpy((char */* __restrict  */)(dummy), (char const   */* __restrict  */)(tmp),
            (size_t )512);
#line 324
    dummy[512] = (char )'\000';
#line 325
    tmp___1 = strlen((char const   *)(dummy));
#line 325
    strncat((char */* __restrict  */)(dummy), (char const   */* __restrict  */)(lname),
            512UL - tmp___1);
#line 326
    dummy[512] = (char )'\000';
#line 327
    strncpy((char */* __restrict  */)(lname), (char const   */* __restrict  */)(dummy),
            (size_t )512);
#line 328
    dummy[512] = (char )'\000';
#line 329
    tmp___2 = fs_read((void *)(& de), (u_int32_t )32, (u_int32_t )1, fd);
    }
#line 329
    if (tmp___2 < 1L) {
      {
#line 330
      errormsg("parseDirEntry", "Failed to read from file!");
      }
#line 331
      return (-1);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 337
  parseShortFilename(& de.ShortDirEntry, sname);
#line 338
  (*entries) ++;
#line 341
  lnde = newDirEntry(sname, lname, & de.ShortDirEntry, llist, *entries);
  }
#line 342
  if ((unsigned long )lnde == (unsigned long )((void *)0)) {
    {
#line 343
    errormsg("parseDirEntry", "Failed to create DirEntry!");
    }
#line 344
    return (-1);
  }
  {
#line 346
  insertDirEntryList(lnde, list);
  }
#line 348
  if (OPT_LIST) {
    {
#line 348
    tmp___4 = strcmp((char const   *)(sname), ".");
    }
#line 348
    if (tmp___4) {
      {
#line 348
      tmp___5 = strcmp((char const   *)(sname), "..");
      }
#line 348
      if (tmp___5) {
#line 348
        if ((int )sname[0] != -27) {
#line 348
          if (! ((int )de.ShortDirEntry.DIR_Atrr & 8)) {
#line 349
            if ((int )lname[0] != 0) {
#line 349
              tmp___3 = lname;
            } else {
#line 349
              tmp___3 = sname;
            }
            {
#line 349
            printf((char const   */* __restrict  */)"%s\n", tmp___3);
            }
          }
        }
      }
    }
  }
#line 353
  return (0);
}
}
#line 357 "/home/june/repo/benchmarks/collector/temp/fatsort-0.9.15.245/src/sort.c"
int32_t writeList(FILE *fd , struct sDirEntryList *list ) 
{ 
  struct sLongDirEntryList *tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  off_t tmp___2 ;
  int *tmp___3 ;
  char *tmp___4 ;
  off_t tmp___5 ;

  {
#line 362
  if (! ((unsigned long )fd != (unsigned long )((void *)0))) {
    {
#line 362
    __assert_fail("fd != ((void *)0)", "/home/june/repo/benchmarks/collector/temp/fatsort-0.9.15.245/src/sort.c",
                  362U, "writeList");
    }
  }
#line 363
  if (! ((unsigned long )list != (unsigned long )((void *)0))) {
    {
#line 363
    __assert_fail("list != ((void *)0)", "/home/june/repo/benchmarks/collector/temp/fatsort-0.9.15.245/src/sort.c",
                  363U, "writeList");
    }
  }
  {
#line 368
  start_critical_section();
  }
  {
#line 370
  while (1) {
    while_continue: /* CIL Label */ ;
#line 370
    if (! ((unsigned long )list->next != (unsigned long )((void *)0))) {
#line 370
      goto while_break;
    }
#line 371
    tmp = (list->next)->ldel;
    {
#line 372
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 372
      if (! ((unsigned long )tmp != (unsigned long )((void *)0))) {
#line 372
        goto while_break___0;
      }
      {
#line 373
      tmp___2 = fs_write((void const   *)tmp->lde, (u_int32_t )32, (u_int32_t )1,
                         fd);
      }
#line 373
      if (tmp___2 < 1L) {
        {
#line 374
        tmp___0 = __errno_location();
#line 374
        tmp___1 = strerror(*tmp___0);
#line 374
        errormsg("writeList", "%s!", tmp___1);
        }
#line 375
        return (-1);
      }
#line 377
      tmp = tmp->next;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 379
    tmp___5 = fs_write((void const   *)(list->next)->sde, (u_int32_t )32, (u_int32_t )1,
                       fd);
    }
#line 379
    if (tmp___5 < 1L) {
      {
#line 380
      tmp___3 = __errno_location();
#line 380
      tmp___4 = strerror(*tmp___3);
#line 380
      errormsg("writeList", "%s!", tmp___4);
      }
#line 381
      return (-1);
    }
#line 383
    list = list->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 387
  end_critical_section();
  }
#line 389
  return (0);
}
}
#line 392 "/home/june/repo/benchmarks/collector/temp/fatsort-0.9.15.245/src/sort.c"
int32_t getClusterChain(FILE *fd , struct sBootSector *bs , u_int32_t startCluster ,
                        struct sClusterChain *chain ) 
{ 
  u_int32_t cluster ;
  u_int32_t data ;
  u_int32_t i ;
  int32_t FATType ;
  int32_t tmp ;
  int32_t tmp___0 ;
  int32_t tmp___1 ;
  int32_t tmp___2 ;

  {
#line 398
  if (! ((unsigned long )fd != (unsigned long )((void *)0))) {
    {
#line 398
    __assert_fail("fd != ((void *)0)", "/home/june/repo/benchmarks/collector/temp/fatsort-0.9.15.245/src/sort.c",
                  398U, "getClusterChain");
    }
  }
#line 399
  if (! ((unsigned long )bs != (unsigned long )((void *)0))) {
    {
#line 399
    __assert_fail("bs != ((void *)0)", "/home/june/repo/benchmarks/collector/temp/fatsort-0.9.15.245/src/sort.c",
                  399U, "getClusterChain");
    }
  }
#line 400
  if (! ((unsigned long )chain != (unsigned long )((void *)0))) {
    {
#line 400
    __assert_fail("chain != ((void *)0)", "/home/june/repo/benchmarks/collector/temp/fatsort-0.9.15.245/src/sort.c",
                  400U, "getClusterChain");
    }
  }
  {
#line 403
  i = (u_int32_t )0;
#line 406
  cluster = startCluster;
#line 408
  FATType = getFATType(bs);
  }
#line 410
  if (FATType == 12) {
    {
#line 411
    errormsg("getClusterChain", "FAT12 is not supported!");
    }
#line 412
    return (-1);
  } else
#line 413
  if (FATType == 16) {
    {
#line 414
    while (1) {
      while_continue: /* CIL Label */ ;
#line 415
      if (i == 4194303U) {
        {
#line 416
        errormsg("getClusterChain", "Cluster chain is too long!");
        }
#line 417
        return (-1);
      }
      {
#line 419
      tmp = insertCluster(chain, cluster);
      }
#line 419
      if (tmp == -1) {
        {
#line 420
        errormsg("getClusterChain", "Failed to insert cluster!");
        }
#line 421
        return (-1);
      }
      {
#line 423
      i ++;
#line 424
      tmp___0 = getFATEntry(fd, bs, cluster, & data);
      }
#line 424
      if (tmp___0) {
        {
#line 425
        errormsg("getClusterChain", "Failed to get FAT entry!");
        }
#line 426
        return (-1);
      }
#line 428
      cluster = data;
#line 414
      if (! (cluster < 65528U)) {
#line 414
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
  } else
#line 430
  if (FATType == 32) {
    {
#line 431
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 432
      if (i == 4194303U) {
        {
#line 433
        errormsg("getClusterChain", "Cluster chain is too long!");
        }
#line 434
        return (-1);
      }
      {
#line 436
      tmp___1 = insertCluster(chain, cluster);
      }
#line 436
      if (tmp___1 == -1) {
        {
#line 437
        errormsg("getClusterChain", "Failed to insert cluster!");
        }
#line 438
        return (-1);
      }
      {
#line 440
      i ++;
#line 441
      tmp___2 = getFATEntry(fd, bs, cluster, & data);
      }
#line 441
      if (tmp___2) {
        {
#line 442
        errormsg("getClusterChain", "Failed to get FAT entry");
        }
#line 443
        return (-1);
      }
#line 445
      cluster = data;
#line 431
      if ((cluster & 268435455U) != 267976696U) {
#line 431
        if (! ((cluster & 268435455U) < 268435448U)) {
#line 431
          goto while_break___0;
        }
      } else {
#line 431
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  } else {
    {
#line 449
    errormsg("getClusterChain", "Failed to get FAT type!");
    }
#line 450
    return (-1);
  }
#line 453
  return ((int32_t )i);
}
}
#line 456 "/home/june/repo/benchmarks/collector/temp/fatsort-0.9.15.245/src/sort.c"
int32_t writeClusterChain(FILE *fd , struct sBootSector *bs , struct sDirEntryList *list ,
                          struct sClusterChain *chain ) 
{ 
  int32_t i ;
  int32_t entries ;
  u_int32_t MaxEntries ;
  struct sLongDirEntryList *tmp ;
  struct sDirEntryList *p ;
  char empty[32] ;
  unsigned int tmp___0 ;
  off_t tmp___1 ;
  int tmp___2 ;
  int *tmp___3 ;
  char *tmp___4 ;
  off_t tmp___5 ;
  int *tmp___6 ;
  char *tmp___7 ;
  off_t tmp___8 ;
  int *tmp___9 ;
  char *tmp___10 ;
  off_t tmp___11 ;
  off_t tmp___12 ;
  int tmp___13 ;
  int *tmp___14 ;
  char *tmp___15 ;
  off_t tmp___16 ;
  int *tmp___17 ;
  char *tmp___18 ;
  off_t tmp___19 ;
  int *tmp___20 ;
  char *tmp___21 ;
  off_t tmp___22 ;

  {
#line 461
  if (! ((unsigned long )fd != (unsigned long )((void *)0))) {
    {
#line 461
    __assert_fail("fd != ((void *)0)", "/home/june/repo/benchmarks/collector/temp/fatsort-0.9.15.245/src/sort.c",
                  461U, "writeClusterChain");
    }
  }
#line 462
  if (! ((unsigned long )bs != (unsigned long )((void *)0))) {
    {
#line 462
    __assert_fail("bs != ((void *)0)", "/home/june/repo/benchmarks/collector/temp/fatsort-0.9.15.245/src/sort.c",
                  462U, "writeClusterChain");
    }
  }
#line 463
  if (! ((unsigned long )list != (unsigned long )((void *)0))) {
    {
#line 463
    __assert_fail("list != ((void *)0)", "/home/june/repo/benchmarks/collector/temp/fatsort-0.9.15.245/src/sort.c",
                  463U, "writeClusterChain");
    }
  }
#line 464
  if (! ((unsigned long )chain != (unsigned long )((void *)0))) {
    {
#line 464
    __assert_fail("chain != ((void *)0)", "/home/june/repo/benchmarks/collector/temp/fatsort-0.9.15.245/src/sort.c",
                  464U, "writeClusterChain");
    }
  }
#line 466
  i = 0;
#line 466
  entries = 0;
#line 469
  p = list->next;
#line 470
  empty[0] = (char)0;
#line 470
  tmp___0 = 1U;
  {
#line 470
  while (1) {
    while_continue: /* CIL Label */ ;
#line 470
    if (tmp___0 >= 32U) {
#line 470
      goto while_break;
    }
#line 470
    empty[tmp___0] = (char)0;
#line 470
    tmp___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 472
  chain = chain->next;
#line 474
  MaxEntries = (u_int32_t )(((int )bs->BS_SecPerClus * (int )bs->BS_BytesPerSec) / 32);
#line 475
  tmp___1 = getClusterOffset(bs, chain->cluster);
#line 475
  tmp___2 = fs_seek(fd, tmp___1, 0);
  }
#line 475
  if (tmp___2 == -1) {
    {
#line 476
    errormsg("writeClusterChain", "Seek error!");
    }
#line 477
    return (-1);
  }
  {
#line 481
  start_critical_section();
  }
  {
#line 483
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 483
    if (! ((unsigned long )p != (unsigned long )((void *)0))) {
#line 483
      goto while_break___0;
    }
#line 484
    if ((u_int32_t )(entries + p->entries) <= MaxEntries) {
#line 485
      tmp = p->ldel;
#line 486
      i = 1;
      {
#line 486
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 486
        if (! (i < p->entries)) {
#line 486
          goto while_break___1;
        }
        {
#line 487
        tmp___5 = fs_write((void const   *)tmp->lde, (u_int32_t )32, (u_int32_t )1,
                           fd);
        }
#line 487
        if (tmp___5 < 1L) {
          {
#line 488
          tmp___3 = __errno_location();
#line 488
          tmp___4 = strerror(*tmp___3);
#line 488
          errormsg("writeClusterChain", "%s!", tmp___4);
          }
#line 489
          return (-1);
        }
#line 491
        tmp = tmp->next;
#line 486
        i ++;
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 493
      tmp___8 = fs_write((void const   *)p->sde, (u_int32_t )32, (u_int32_t )1, fd);
      }
#line 493
      if (tmp___8 < 1L) {
        {
#line 494
        tmp___6 = __errno_location();
#line 494
        tmp___7 = strerror(*tmp___6);
#line 494
        errormsg("writeClusterChain", "%s!", tmp___7);
        }
#line 495
        return (-1);
      }
#line 497
      entries += p->entries;
    } else {
#line 499
      tmp = p->ldel;
#line 500
      i = 1;
      {
#line 500
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 500
        if (! ((u_int32_t )i <= MaxEntries - (u_int32_t )entries)) {
#line 500
          goto while_break___2;
        }
        {
#line 501
        tmp___11 = fs_write((void const   *)tmp->lde, (u_int32_t )32, (u_int32_t )1,
                            fd);
        }
#line 501
        if (tmp___11 < 1L) {
          {
#line 502
          tmp___9 = __errno_location();
#line 502
          tmp___10 = strerror(*tmp___9);
#line 502
          errormsg("writeClusterChain", "%s!", tmp___10);
          }
#line 503
          return (-1);
        }
#line 505
        tmp = tmp->next;
#line 500
        i ++;
      }
      while_break___2: /* CIL Label */ ;
      }
      {
#line 507
      chain = chain->next;
#line 507
      entries = (int32_t )((u_int32_t )p->entries - (MaxEntries - (u_int32_t )entries));
#line 508
      tmp___12 = getClusterOffset(bs, chain->cluster);
#line 508
      tmp___13 = fs_seek(fd, tmp___12, 0);
      }
#line 508
      if (tmp___13 == -1) {
        {
#line 509
        errormsg("writeClusterChain", "Seek error!");
        }
#line 510
        return (-1);
      }
      {
#line 512
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 512
        if (! ((unsigned long )tmp != (unsigned long )((void *)0))) {
#line 512
          goto while_break___3;
        }
        {
#line 513
        tmp___16 = fs_write((void const   *)tmp->lde, (u_int32_t )32, (u_int32_t )1,
                            fd);
        }
#line 513
        if (tmp___16 < 1L) {
          {
#line 514
          tmp___14 = __errno_location();
#line 514
          tmp___15 = strerror(*tmp___14);
#line 514
          errormsg("writeClusterChain", "%s!", tmp___15);
          }
#line 515
          return (-1);
        }
#line 517
        tmp = tmp->next;
      }
      while_break___3: /* CIL Label */ ;
      }
      {
#line 519
      tmp___19 = fs_write((void const   *)p->sde, (u_int32_t )32, (u_int32_t )1, fd);
      }
#line 519
      if (tmp___19 < 1L) {
        {
#line 520
        tmp___17 = __errno_location();
#line 520
        tmp___18 = strerror(*tmp___17);
#line 520
        errormsg("writeClusterChain", "%s!", tmp___18);
        }
#line 521
        return (-1);
      }
    }
#line 524
    p = p->next;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 526
  if ((u_int32_t )entries < MaxEntries) {
    {
#line 527
    tmp___22 = fs_write((void const   *)(empty), (u_int32_t )32, (u_int32_t )1, fd);
    }
#line 527
    if (tmp___22 < 1L) {
      {
#line 528
      tmp___20 = __errno_location();
#line 528
      tmp___21 = strerror(*tmp___20);
#line 528
      errormsg("writeClusterChain", "%s!", tmp___21);
      }
#line 529
      return (-1);
    }
  }
  {
#line 534
  end_critical_section();
  }
#line 536
  return (0);
}
}
#line 540 "/home/june/repo/benchmarks/collector/temp/fatsort-0.9.15.245/src/sort.c"
int32_t sort_fs(char *filename ) 
{ 
  FILE *fd ;
  u_int32_t rfd ;
  struct sBootSector bs ;
  int32_t FATType ;
  int32_t ret ;
  int *tmp ;
  char *tmp___0 ;
  char const   *tmp___1 ;
  u_int32_t tmp___2 ;
  int *tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int *tmp___7 ;
  char *tmp___8 ;
  char const   *tmp___9 ;
  int32_t tmp___10 ;
  int32_t tmp___11 ;
  int32_t tmp___12 ;

  {
#line 545
  if (! ((unsigned long )filename != (unsigned long )((void *)0))) {
    {
#line 545
    __assert_fail("filename != ((void *)0)", "/home/june/repo/benchmarks/collector/temp/fatsort-0.9.15.245/src/sort.c",
                  545U, "sort_fs");
    }
  }
#line 548
  rfd = (u_int32_t )0;
#line 555
  if (OPT_FORCE) {
#line 556
    if (OPT_LIST) {
#line 556
      tmp___1 = "rb";
    } else {
#line 556
      tmp___1 = "r+b";
    }
    {
#line 556
    fd = fopen((char const   */* __restrict  */)filename, (char const   */* __restrict  */)tmp___1);
    }
#line 556
    if ((unsigned long )fd == (unsigned long )((void *)0)) {
      {
#line 557
      tmp = __errno_location();
#line 557
      tmp___0 = strerror(*tmp);
#line 557
      errormsg("sort_fs", "%s!", tmp___0);
      }
#line 558
      return (-1);
    }
  } else {
    {
#line 564
    tmp___2 = check_mounted(filename);
#line 564
    ret = (int32_t )tmp___2;
    }
    {
#line 566
    if (ret == 0) {
#line 566
      goto case_0;
    }
#line 567
    if (ret == 1) {
#line 567
      goto case_1;
    }
#line 570
    if (ret == -1) {
#line 570
      goto case_neg_1;
    }
#line 565
    goto switch_break;
    case_0: /* CIL Label */ 
#line 566
    goto switch_break;
    case_1: /* CIL Label */ 
    {
#line 568
    errormsg("sort_fs", "Filesystem is mounted!");
    }
#line 569
    return (-1);
    case_neg_1: /* CIL Label */ 
    {
#line 571
    errormsg("sort_fs", "Could not check if filesystem is mounted!");
    }
#line 572
    return (-1);
    switch_break: /* CIL Label */ ;
    }
#line 576
    if (OPT_LIST) {
#line 576
      tmp___5 = 128;
    } else {
#line 576
      tmp___5 = 130;
    }
    {
#line 576
    tmp___6 = open((char const   *)filename, tmp___5);
#line 576
    rfd = (u_int32_t )tmp___6;
    }
#line 576
    if (rfd == 4294967295U) {
      {
#line 577
      tmp___3 = __errno_location();
#line 577
      tmp___4 = strerror(*tmp___3);
#line 577
      errormsg("sort_fs", "%s!", tmp___4);
      }
#line 578
      return (-1);
    }
#line 582
    if (OPT_LIST) {
#line 582
      tmp___9 = "rb";
    } else {
#line 582
      tmp___9 = "r+b";
    }
    {
#line 582
    fd = fdopen((int )rfd, tmp___9);
    }
#line 582
    if ((unsigned long )fd == (unsigned long )((void *)0)) {
      {
#line 583
      tmp___7 = __errno_location();
#line 583
      tmp___8 = strerror(*tmp___7);
#line 583
      errormsg("sort_fs", "%s!", tmp___8);
      }
#line 584
      return (-1);
    }
  }
  {
#line 589
  tmp___10 = read_bootsector(fd, & bs);
  }
#line 589
  if (tmp___10) {
    {
#line 590
    errormsg("sort_fs", "Failed to read boot sector!");
    }
#line 591
    return (-1);
  }
  {
#line 594
  FATType = getFATType(& bs);
  }
#line 596
  if (FATType == 12) {
    {
#line 599
    errormsg("sort_fs", "FAT12 is not supported!");
    }
#line 600
    return (-1);
  } else
#line 601
  if (FATType == 16) {
    {
#line 604
    infomsg((char *)"File system: FAT16.\n\n");
#line 605
    tmp___11 = sort_FAT16_rootdir(fd, & bs);
    }
#line 605
    if (tmp___11 == -1) {
      {
#line 606
      errormsg("sort_fs", "Failed to sort FAT16 root directory!");
      }
#line 607
      return (-1);
    }
  } else
#line 609
  if (FATType == 32) {
    {
#line 613
    infomsg((char *)"File system: FAT32.\n\n");
#line 614
    tmp___12 = sortClusterChain(fd, & bs, bs.FATxx.FAT32.BS_RootClus, (char *)"/");
    }
#line 614
    if (tmp___12 == -1) {
      {
#line 615
      errormsg("sort_fs", "Failed to sort first cluster chain!");
      }
#line 616
      return (-1);
    }
  } else {
    {
#line 619
    errormsg("sort_fs", "Failed to get FAT type!");
    }
#line 620
    return (-1);
  }
  {
#line 623
  fs_close(fd);
#line 624
  close((int )rfd);
  }
#line 626
  return (0);
}
}
#line 629 "/home/june/repo/benchmarks/collector/temp/fatsort-0.9.15.245/src/sort.c"
int32_t sortClusterChain(FILE *fd , struct sBootSector *bs , u_int32_t cluster , char *path ) 
{ 
  u_int32_t clen ;
  u_int32_t value ;
  u_int32_t c ;
  u_int32_t direntries ;
  struct sClusterChain *ClusterChain ;
  struct sClusterChain *tmp ;
  char newpath[513] ;
  unsigned int tmp___0 ;
  struct sDirEntryList *list ;
  struct sDirEntryList *tmp___1 ;
  struct sDirEntryList *p ;
  int32_t tmp___2 ;
  int32_t tmp___3 ;
  int32_t tmp___4 ;
  int32_t tmp___5 ;
  int32_t tmp___6 ;
  int32_t tmp___7 ;
  size_t tmp___8 ;
  size_t tmp___9 ;
  size_t tmp___10 ;
  size_t tmp___11 ;
  size_t tmp___12 ;
  int32_t tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;

  {
#line 634
  if (! ((unsigned long )fd != (unsigned long )((void *)0))) {
    {
#line 634
    __assert_fail("fd != ((void *)0)", "/home/june/repo/benchmarks/collector/temp/fatsort-0.9.15.245/src/sort.c",
                  634U, "sortClusterChain");
    }
  }
#line 635
  if (! ((unsigned long )bs != (unsigned long )((void *)0))) {
    {
#line 635
    __assert_fail("bs != ((void *)0)", "/home/june/repo/benchmarks/collector/temp/fatsort-0.9.15.245/src/sort.c",
                  635U, "sortClusterChain");
    }
  }
#line 636
  if (! ((unsigned long )path != (unsigned long )((void *)0))) {
    {
#line 636
    __assert_fail("path != ((void *)0)", "/home/june/repo/benchmarks/collector/temp/fatsort-0.9.15.245/src/sort.c",
                  636U, "sortClusterChain");
    }
  }
  {
#line 639
  tmp = newClusterChain();
#line 639
  ClusterChain = tmp;
#line 640
  newpath[0] = (char)0;
#line 640
  tmp___0 = 1U;
  }
  {
#line 640
  while (1) {
    while_continue: /* CIL Label */ ;
#line 640
    if (tmp___0 >= 513U) {
#line 640
      goto while_break;
    }
#line 640
    newpath[tmp___0] = (char)0;
#line 640
    tmp___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 642
  tmp___1 = newDirEntryList();
#line 642
  list = tmp___1;
#line 645
  tmp___2 = getClusterChain(fd, bs, cluster, ClusterChain);
#line 645
  clen = (u_int32_t )tmp___2;
  }
#line 645
  if (clen == 4294967295U) {
    {
#line 646
    errormsg("sortClusterChain", "Failed to get cluster chain!");
    }
#line 647
    return (-1);
  }
#line 650
  if (! OPT_LIST) {
    {
#line 651
    tmp___3 = parseClusterChain(fd, bs, ClusterChain, list, & direntries);
    }
#line 651
    if (tmp___3 == -1) {
      {
#line 652
      errormsg("sortClusterChain", "Failed to parse cluster chain!");
      }
#line 653
      return (-1);
    }
    {
#line 657
    tmp___5 = matchesDirPathLists(OPT_INCL_DIRS, OPT_INCL_DIRS_REC, OPT_EXCL_DIRS,
                                  OPT_EXCL_DIRS_REC, (char *)path);
    }
#line 657
    if (tmp___5) {
#line 659
      if (OPT_RANDOM) {
        {
#line 659
        randomizeDirEntryList(list, direntries);
        }
      }
      {
#line 661
      infomsg((char *)"Sorting directory %s\n", path);
#line 662
      tmp___4 = writeClusterChain(fd, bs, list, ClusterChain);
      }
#line 662
      if (tmp___4 == -1) {
        {
#line 663
        errormsg("sortClusterChain", "Failed to write cluster chain!");
        }
#line 664
        return (-1);
      }
    }
  } else {
    {
#line 668
    printf((char const   */* __restrict  */)"%s\n", path);
#line 669
    tmp___6 = parseClusterChain(fd, bs, ClusterChain, list, & direntries);
    }
#line 669
    if (tmp___6 == -1) {
      {
#line 670
      errormsg("sortClusterChain", "Failed to parse cluster chain!");
      }
#line 671
      return (-1);
    }
    {
#line 674
    printf((char const   */* __restrict  */)"\n");
    }
  }
  {
#line 677
  freeClusterChain(ClusterChain);
#line 680
  p = list->next;
  }
  {
#line 681
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 681
    if (! ((unsigned long )p != (unsigned long )((void *)0))) {
#line 681
      goto while_break___0;
    }
#line 682
    if ((int )(p->sde)->DIR_Atrr & 16) {
#line 682
      if ((int )(p->sde)->DIR_Name[0] != -27) {
#line 682
        if (! ((int )(p->sde)->DIR_Atrr & 8)) {
          {
#line 682
          tmp___14 = strcmp((char const   *)p->sname, ".");
          }
#line 682
          if (tmp___14) {
            {
#line 682
            tmp___15 = strcmp((char const   *)p->sname, "..");
            }
#line 682
            if (tmp___15) {
              {
#line 687
              c = (u_int32_t )((int )(p->sde)->DIR_FstClusHI * 65536 + (int )(p->sde)->DIR_FstClusLO);
#line 688
              tmp___7 = getFATEntry(fd, bs, c, & value);
              }
#line 688
              if (tmp___7 == -1) {
                {
#line 689
                errormsg("sortClusterChain", "Failed to get FAT entry!");
                }
#line 690
                return (-1);
              }
              {
#line 693
              tmp___8 = strlen((char const   *)(newpath));
#line 693
              strncpy((char */* __restrict  */)(newpath), (char const   */* __restrict  */)path,
                      512UL - tmp___8);
#line 694
              newpath[512] = (char )'\000';
              }
#line 695
              if ((unsigned long )p->lname != (unsigned long )((void *)0)) {
#line 695
                if ((int )*(p->lname + 0) != 0) {
                  {
#line 696
                  tmp___9 = strlen((char const   *)(newpath));
#line 696
                  strncat((char */* __restrict  */)(newpath), (char const   */* __restrict  */)p->lname,
                          512UL - tmp___9);
#line 697
                  newpath[512] = (char )'\000';
#line 698
                  tmp___10 = strlen((char const   *)(newpath));
#line 698
                  strncat((char */* __restrict  */)(newpath), (char const   */* __restrict  */)"/",
                          512UL - tmp___10);
#line 699
                  newpath[512] = (char )'\000';
                  }
                } else {
#line 695
                  goto _L;
                }
              } else {
                _L: /* CIL Label */ 
                {
#line 701
                tmp___11 = strlen((char const   *)(newpath));
#line 701
                strncat((char */* __restrict  */)(newpath), (char const   */* __restrict  */)p->sname,
                        512UL - tmp___11);
#line 702
                newpath[512] = (char )'\000';
#line 703
                tmp___12 = strlen((char const   *)(newpath));
#line 703
                strncat((char */* __restrict  */)(newpath), (char const   */* __restrict  */)"/",
                        512UL - tmp___12);
#line 704
                newpath[512] = (char )'\000';
                }
              }
              {
#line 707
              tmp___13 = sortClusterChain(fd, bs, c, newpath);
              }
#line 707
              if (tmp___13 == -1) {
                {
#line 708
                errormsg("sortClusterChain", "Failed to sort cluster chain!");
                }
#line 709
                return (-1);
              }
            }
          }
        }
      }
    }
#line 713
    p = p->next;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 716
  freeDirEntryList(list);
  }
#line 718
  return (0);
}
}
#line 721 "/home/june/repo/benchmarks/collector/temp/fatsort-0.9.15.245/src/sort.c"
int32_t sort_FAT16_rootdir(FILE *fd , struct sBootSector *bs ) 
{ 
  off_t BSOffset ;
  u_int32_t FATSz ;
  u_int32_t i ;
  u_int32_t ret ;
  u_int32_t entries ;
  u_int32_t count ;
  u_int32_t c ;
  u_int32_t value ;
  u_int32_t direntries ;
  char newpath[513] ;
  unsigned int tmp ;
  struct sDirEntryList *list ;
  struct sDirEntryList *tmp___0 ;
  struct sDirEntryList *p ;
  int32_t tmp___1 ;
  int32_t tmp___2 ;
  int32_t tmp___3 ;
  int32_t tmp___4 ;
  size_t tmp___5 ;
  size_t tmp___6 ;
  size_t tmp___7 ;
  size_t tmp___8 ;
  size_t tmp___9 ;
  int32_t tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;

  {
#line 726
  if (! ((unsigned long )fd != (unsigned long )((void *)0))) {
    {
#line 726
    __assert_fail("fd != ((void *)0)", "/home/june/repo/benchmarks/collector/temp/fatsort-0.9.15.245/src/sort.c",
                  726U, "sort_FAT16_rootdir");
    }
  }
#line 727
  if (! ((unsigned long )bs != (unsigned long )((void *)0))) {
    {
#line 727
    __assert_fail("bs != ((void *)0)", "/home/june/repo/benchmarks/collector/temp/fatsort-0.9.15.245/src/sort.c",
                  727U, "sort_FAT16_rootdir");
    }
  }
#line 731
  count = (u_int32_t )0;
#line 732
  direntries = (u_int32_t )0;
#line 733
  newpath[0] = (char)0;
#line 733
  tmp = 1U;
  {
#line 733
  while (1) {
    while_continue: /* CIL Label */ ;
#line 733
    if (tmp >= 513U) {
#line 733
      goto while_break;
    }
#line 733
    newpath[tmp] = (char)0;
#line 733
    tmp ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 735
  tmp___0 = newDirEntryList();
#line 735
  list = tmp___0;
  }
#line 738
  if ((int )bs->BS_FATSz16 != 0) {
#line 739
    FATSz = (u_int32_t )bs->BS_FATSz16;
  } else {
#line 741
    FATSz = bs->FATxx.FAT32.BS_FATSz32;
  }
  {
#line 744
  BSOffset = ((off_t )bs->BS_RsvdSecCnt + (off_t )((u_int32_t )bs->BS_NumFATs * FATSz)) * (off_t )bs->BS_BytesPerSec;
#line 746
  fs_seek(fd, BSOffset, 0);
  }
#line 748
  if (OPT_LIST) {
    {
#line 749
    printf((char const   */* __restrict  */)"/\n");
    }
  }
#line 753
  i = (u_int32_t )1;
  {
#line 753
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 753
    if (! (i <= (u_int32_t )bs->BS_RootEntCnt)) {
#line 753
      goto while_break___0;
    }
    {
#line 754
    tmp___1 = parseDirEntry(fd, list, & entries);
#line 754
    ret = (u_int32_t )tmp___1;
#line 755
    count += entries;
    }
#line 756
    if (ret == 1U) {
#line 757
      goto while_break___0;
    } else
#line 758
    if (ret == 4294967295U) {
      {
#line 759
      errormsg("sort_FAT16_rootdir", "Failed to parse directory entries!");
      }
#line 760
      return (-1);
    }
#line 762
    direntries ++;
#line 764
    if (entries == 0U) {
#line 764
      count ++;
    }
#line 753
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 767
  if (! OPT_LIST) {
    {
#line 770
    tmp___3 = matchesDirPathLists(OPT_INCL_DIRS, OPT_INCL_DIRS_REC, OPT_EXCL_DIRS,
                                  OPT_EXCL_DIRS_REC, (char *)"/");
    }
#line 770
    if (tmp___3) {
#line 772
      if (OPT_RANDOM) {
        {
#line 772
        randomizeDirEntryList(list, direntries);
        }
      }
      {
#line 774
      infomsg((char *)"Sorting directory /\n");
#line 775
      fs_seek(fd, BSOffset, 0);
#line 777
      tmp___2 = writeList(fd, list);
      }
#line 777
      if (tmp___2 == -1) {
        {
#line 778
        errormsg("sort_FAT16_rootdir", "Failed to write FAT entries!");
        }
#line 779
        return (-1);
      }
    }
  } else {
    {
#line 784
    printf((char const   */* __restrict  */)"\n");
    }
  }
#line 788
  p = list->next;
  {
#line 789
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 789
    if (! ((unsigned long )p != (unsigned long )((void *)0))) {
#line 789
      goto while_break___1;
    }
#line 790
    if ((int )(p->sde)->DIR_Atrr & 16) {
#line 790
      if ((int )(p->sde)->DIR_Name[0] != -27) {
#line 790
        if (! ((int )(p->sde)->DIR_Atrr & 8)) {
          {
#line 790
          tmp___11 = strcmp((char const   *)p->sname, ".");
          }
#line 790
          if (tmp___11) {
            {
#line 790
            tmp___12 = strcmp((char const   *)p->sname, "..");
            }
#line 790
            if (tmp___12) {
              {
#line 794
              c = (u_int32_t )((int )(p->sde)->DIR_FstClusHI * 65536 + (int )(p->sde)->DIR_FstClusLO);
#line 795
              tmp___4 = getFATEntry(fd, bs, c, & value);
              }
#line 795
              if (tmp___4 == -1) {
                {
#line 796
                errormsg("sort_FAT16_rootdir", "Failed to get FAT entry!");
                }
#line 797
                return (-1);
              }
              {
#line 800
              tmp___5 = strlen((char const   *)(newpath));
#line 800
              strncpy((char */* __restrict  */)(newpath), (char const   */* __restrict  */)"/",
                      512UL - tmp___5);
#line 801
              newpath[512] = (char )'\000';
              }
#line 802
              if ((unsigned long )p->lname != (unsigned long )((void *)0)) {
#line 802
                if ((int )*(p->lname + 0) != 0) {
                  {
#line 803
                  tmp___6 = strlen((char const   *)(newpath));
#line 803
                  strncat((char */* __restrict  */)(newpath), (char const   */* __restrict  */)p->lname,
                          512UL - tmp___6);
#line 804
                  newpath[512] = (char )'\000';
#line 805
                  tmp___7 = strlen((char const   *)(newpath));
#line 805
                  strncat((char */* __restrict  */)(newpath), (char const   */* __restrict  */)"/",
                          512UL - tmp___7);
#line 806
                  newpath[512] = (char )'\000';
                  }
                } else {
#line 802
                  goto _L;
                }
              } else {
                _L: /* CIL Label */ 
                {
#line 808
                tmp___8 = strlen((char const   *)(newpath));
#line 808
                strncat((char */* __restrict  */)(newpath), (char const   */* __restrict  */)p->sname,
                        512UL - tmp___8);
#line 809
                newpath[512] = (char )'\000';
#line 810
                tmp___9 = strlen((char const   *)(newpath));
#line 810
                strncat((char */* __restrict  */)(newpath), (char const   */* __restrict  */)"/",
                        512UL - tmp___9);
#line 811
                newpath[512] = (char )'\000';
                }
              }
              {
#line 814
              tmp___10 = sortClusterChain(fd, bs, c, newpath);
              }
#line 814
              if (tmp___10 == -1) {
                {
#line 815
                errormsg("sort_FAT16_rootdir", "Failed to sort cluster chain!");
                }
#line 816
                return (-1);
              }
            }
          }
        }
      }
    }
#line 819
    p = p->next;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 822
  freeDirEntryList(list);
  }
#line 824
  return (0);
}
}
#line 377 "/usr/include/stdio.h"
extern int vprintf(char const   * __restrict  __format , __gnuc_va_list __arg ) ;
#line 31 "/home/june/repo/benchmarks/collector/temp/fatsort-0.9.15.245/src/misc.c"
void infomsg(char *str  , ...) 
{ 
  va_list argptr ;

  {
#line 37
  if (! OPT_QUIET) {
    {
#line 38
    __builtin_va_start(argptr, str);
#line 39
    vprintf((char const   */* __restrict  */)str, argptr);
#line 40
    __builtin_va_end(argptr);
    }
  }
#line 43
  return;
}
}
#line 147 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strncmp)(char const   *__s1 ,
                                                                                                char const   *__s2 ,
                                                                                                size_t __n )  __attribute__((__pure__)) ;
#line 31 "/home/june/repo/benchmarks/collector/temp/fatsort-0.9.15.245/src/stringlist.c"
struct sStringList *newStringList(void) 
{ 
  struct sStringList *stringList ;
  void *tmp ;
  int *tmp___0 ;
  char *tmp___1 ;

  {
  {
#line 38
  tmp = malloc(sizeof(struct sStringList ));
#line 38
  stringList = (struct sStringList *)tmp;
  }
#line 39
  if ((unsigned long )stringList == (unsigned long )((void *)0)) {
    {
#line 40
    tmp___0 = __errno_location();
#line 40
    tmp___1 = strerror(*tmp___0);
#line 40
    errormsg("newStringList", "%s!", tmp___1);
    }
#line 41
    return ((struct sStringList *)((void *)0));
  }
#line 43
  stringList->str = (char *)((void *)0);
#line 44
  stringList->next = (struct sStringList *)((void *)0);
#line 46
  return (stringList);
}
}
#line 49 "/home/june/repo/benchmarks/collector/temp/fatsort-0.9.15.245/src/stringlist.c"
int32_t addStringToStringList(struct sStringList *stringList , char *str ) 
{ 
  int32_t len ;
  void *tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  size_t tmp___2 ;
  void *tmp___3 ;
  int *tmp___4 ;
  char *tmp___5 ;

  {
#line 53
  if (! ((unsigned long )stringList != (unsigned long )((void *)0))) {
    {
#line 53
    __assert_fail("stringList != ((void *)0)", "/home/june/repo/benchmarks/collector/temp/fatsort-0.9.15.245/src/stringlist.c",
                  53U, "addStringToStringList");
    }
  }
#line 54
  if (! ((unsigned long )stringList->str == (unsigned long )((void *)0))) {
    {
#line 54
    __assert_fail("stringList->str == ((void *)0)", "/home/june/repo/benchmarks/collector/temp/fatsort-0.9.15.245/src/stringlist.c",
                  54U, "addStringToStringList");
    }
  }
#line 55
  if (! ((unsigned long )str != (unsigned long )((void *)0))) {
    {
#line 55
    __assert_fail("str != ((void *)0)", "/home/june/repo/benchmarks/collector/temp/fatsort-0.9.15.245/src/stringlist.c",
                  55U, "addStringToStringList");
    }
  }
  {
#line 60
  while (1) {
    while_continue: /* CIL Label */ ;
#line 60
    if (! ((unsigned long )stringList->next != (unsigned long )((void *)0))) {
#line 60
      goto while_break;
    }
#line 61
    stringList = stringList->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 65
  tmp = malloc(sizeof(struct sStringList ));
#line 65
  stringList->next = (struct sStringList *)tmp;
  }
#line 66
  if ((unsigned long )stringList->next == (unsigned long )((void *)0)) {
    {
#line 67
    tmp___0 = __errno_location();
#line 67
    tmp___1 = strerror(*tmp___0);
#line 67
    errormsg("addStringToStringList", "%s!", tmp___1);
    }
#line 68
    return (-1);
  }
  {
#line 70
  (stringList->next)->next = (struct sStringList *)((void *)0);
#line 72
  tmp___2 = strlen((char const   *)str);
#line 72
  len = (int32_t )tmp___2;
#line 75
  tmp___3 = malloc((size_t )(len + 1));
#line 75
  (stringList->next)->str = (char *)tmp___3;
  }
#line 76
  if ((unsigned long )(stringList->next)->str == (unsigned long )((void *)0)) {
    {
#line 77
    tmp___4 = __errno_location();
#line 77
    tmp___5 = strerror(*tmp___4);
#line 77
    errormsg("addStringToStringList", "%s!", tmp___5);
    }
#line 78
    return (-1);
  }
  {
#line 81
  strncpy((char */* __restrict  */)(stringList->next)->str, (char const   */* __restrict  */)str,
          (size_t )len);
#line 82
  *((stringList->next)->str + len) = (char )'\000';
  }
#line 84
  return (0);
}
}
#line 88 "/home/june/repo/benchmarks/collector/temp/fatsort-0.9.15.245/src/stringlist.c"
int32_t matchesStringList(struct sStringList *stringList , char *str ) 
{ 
  int32_t ret ;
  size_t tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 93
  if (! ((unsigned long )stringList != (unsigned long )((void *)0))) {
    {
#line 93
    __assert_fail("stringList != ((void *)0)", "/home/june/repo/benchmarks/collector/temp/fatsort-0.9.15.245/src/stringlist.c",
                  93U, "matchesStringList");
    }
  }
#line 94
  if (! ((unsigned long )stringList->str == (unsigned long )((void *)0))) {
    {
#line 94
    __assert_fail("stringList->str == ((void *)0)", "/home/june/repo/benchmarks/collector/temp/fatsort-0.9.15.245/src/stringlist.c",
                  94U, "matchesStringList");
    }
  }
#line 95
  if (! ((unsigned long )str != (unsigned long )((void *)0))) {
    {
#line 95
    __assert_fail("str != ((void *)0)", "/home/june/repo/benchmarks/collector/temp/fatsort-0.9.15.245/src/stringlist.c",
                  95U, "matchesStringList");
    }
  }
#line 97
  ret = 0;
#line 99
  stringList = stringList->next;
  {
#line 100
  while (1) {
    while_continue: /* CIL Label */ ;
#line 100
    if (! ((unsigned long )stringList != (unsigned long )((void *)0))) {
#line 100
      goto while_break;
    }
    {
#line 101
    tmp = strlen((char const   *)stringList->str);
#line 101
    tmp___0 = strncmp((char const   *)stringList->str, (char const   *)str, tmp);
    }
#line 101
    if (tmp___0 == 0) {
#line 103
      ret = 2;
    }
    {
#line 105
    tmp___1 = strcmp((char const   *)stringList->str, (char const   *)str);
    }
#line 105
    if (tmp___1 == 0) {
#line 107
      return (1);
    }
#line 109
    stringList = stringList->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 112
  return (ret);
}
}
#line 115 "/home/june/repo/benchmarks/collector/temp/fatsort-0.9.15.245/src/stringlist.c"
void freeStringList(struct sStringList *stringList ) 
{ 
  struct sStringList *tmp ;

  {
#line 120
  if (! ((unsigned long )stringList != (unsigned long )((void *)0))) {
    {
#line 120
    __assert_fail("stringList != ((void *)0)", "/home/june/repo/benchmarks/collector/temp/fatsort-0.9.15.245/src/stringlist.c",
                  120U, "freeStringList");
    }
  }
  {
#line 124
  while (1) {
    while_continue: /* CIL Label */ ;
#line 124
    if (! ((unsigned long )stringList != (unsigned long )((void *)0))) {
#line 124
      goto while_break;
    }
#line 125
    if (stringList->str) {
      {
#line 125
      free((void *)stringList->str);
      }
    }
    {
#line 126
    tmp = stringList;
#line 127
    stringList = stringList->next;
#line 128
    free((void *)tmp);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 131
  return;
}
}
