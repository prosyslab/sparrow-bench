/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 211 "/usr/lib/gcc/i486-linux-gnu/4.4.3/include/stddef.h"
typedef unsigned int size_t;
#line 158 "/usr/include/bits/types.h"
typedef int __clockid_t;
#line 180 "/usr/include/bits/types.h"
typedef int __ssize_t;
#line 110 "/usr/include/sys/types.h"
typedef __ssize_t ssize_t;
#line 92 "/usr/include/time.h"
typedef __clockid_t clockid_t;
#line 197 "/usr/include/sys/types.h"
typedef int int32_t;
#line 29 "/usr/include/bits/sigset.h"
struct __anonstruct___sigset_t_9 {
   unsigned long __val[1024UL / (8UL * sizeof(unsigned long ))] ;
};
#line 29 "/usr/include/bits/sigset.h"
typedef struct __anonstruct___sigset_t_9 __sigset_t;
#line 38 "/usr/include/sys/select.h"
typedef __sigset_t sigset_t;
#line 221 "/usr/include/scsi/sg.h"
struct sg_header {
   int pack_len ;
   int reply_len ;
   int pack_id ;
   int result ;
   unsigned int twelve_byte : 1 ;
   unsigned int target_status : 5 ;
   unsigned int host_status : 8 ;
   unsigned int driver_status : 8 ;
   unsigned int other_flags : 10 ;
   unsigned char sense_buffer[16] ;
};
#line 26 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/interface/cdda_interface.h"
struct TOC {
   unsigned char bFlags ;
   unsigned char bTrack ;
   int32_t dwStartSector ;
};
#line 26 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/interface/cdda_interface.h"
typedef struct TOC TOC;
#line 45
struct cdda_private_data;
#line 45 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/interface/cdda_interface.h"
typedef struct cdda_private_data cdda_private_data_t;
#line 47 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/interface/cdda_interface.h"
struct cdrom_drive {
   int opened ;
   char *cdda_device_name ;
   char *ioctl_device_name ;
   int cdda_fd ;
   int ioctl_fd ;
   char *drive_model ;
   int drive_type ;
   int interface ;
   int bigendianp ;
   int nsectors ;
   int cd_extra ;
   int tracks ;
   TOC disc_toc[100] ;
   long audio_first_sector ;
   long audio_last_sector ;
   int errordest ;
   int messagedest ;
   char *errorbuf ;
   char *messagebuf ;
   int (*enable_cdda)(struct cdrom_drive *d , int onoff ) ;
   int (*read_toc)(struct cdrom_drive *d ) ;
   long (*read_audio)(struct cdrom_drive *d , void *p , long begin , long sectors ) ;
   int (*set_speed)(struct cdrom_drive *d , int speed ) ;
   int error_retry ;
   int report_all ;
   int is_atapi ;
   int is_mmc ;
   cdda_private_data_t *private ;
   void *reserved ;
   unsigned char inqbytes[4] ;
   unsigned char density ;
   unsigned char orgdens ;
   unsigned int orgsize ;
   long bigbuff ;
   int adjust_ssize ;
   int fua ;
   int lun ;
   sigset_t sigset ;
};
#line 47 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/interface/cdda_interface.h"
typedef struct cdrom_drive cdrom_drive;
#line 100 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/interface/low_interface.h"
struct cdda_private_data {
   struct sg_header *sg_hd ;
   unsigned char *sg_buffer ;
   clockid_t clock ;
   int last_milliseconds ;
};
#line 56 "/usr/include/bits/types.h"
typedef long long __quad_t;
#line 141 "/usr/include/bits/types.h"
typedef long __off_t;
#line 142 "/usr/include/bits/types.h"
typedef __quad_t __off64_t;
#line 149 "/usr/include/bits/types.h"
typedef long __time_t;
#line 150 "/usr/include/bits/types.h"
typedef unsigned int __useconds_t;
#line 151 "/usr/include/bits/types.h"
typedef long __suseconds_t;
#line 45 "/usr/include/stdio.h"
struct _IO_FILE;
#line 49 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 180 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 186 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 271 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 196 "/usr/include/sys/types.h"
typedef short int16_t;
#line 203 "/usr/include/sys/types.h"
typedef unsigned int u_int32_t;
#line 120 "/usr/include/time.h"
struct timespec {
   __time_t tv_sec ;
   long tv_nsec ;
};
#line 69 "/usr/include/bits/time.h"
struct timeval {
   __time_t tv_sec ;
   __suseconds_t tv_usec ;
};
#line 55 "/usr/include/sys/select.h"
typedef long __fd_mask;
#line 67 "/usr/include/sys/select.h"
struct __anonstruct_fd_set_10 {
   __fd_mask __fds_bits[1024 / (8 * (int )sizeof(__fd_mask ))] ;
};
#line 67 "/usr/include/sys/select.h"
typedef struct __anonstruct_fd_set_10 fd_set;
#line 43 "/usr/include/scsi/sg.h"
struct sg_io_hdr {
   int interface_id ;
   int dxfer_direction ;
   unsigned char cmd_len ;
   unsigned char mx_sb_len ;
   unsigned short iovec_count ;
   unsigned int dxfer_len ;
   void *dxferp ;
   unsigned char *cmdp ;
   unsigned char *sbp ;
   unsigned int timeout ;
   unsigned int flags ;
   int pack_id ;
   void *usr_ptr ;
   unsigned char status ;
   unsigned char masked_status ;
   unsigned char msg_status ;
   unsigned char sb_len_wr ;
   unsigned short host_status ;
   unsigned short driver_status ;
   int resid ;
   unsigned int duration ;
   unsigned int info ;
};
#line 10 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/interface/drive_exceptions.h"
struct exception {
   char *model ;
   int atapi ;
   unsigned char density ;
   int (*enable)(struct cdrom_drive * , int  ) ;
   long (*read)(struct cdrom_drive * , void * , long  , long  ) ;
   int bigendianp ;
};
#line 10 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/interface/drive_exceptions.h"
typedef struct exception exception;
#line 634 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/interface/scsi_interface.c"
struct scsi_TOC {
   unsigned char reserved1 ;
   unsigned char bFlags ;
   unsigned char bTrack ;
   unsigned char reserved2 ;
   signed char start_MSB ;
   unsigned char start_1 ;
   unsigned char start_2 ;
   unsigned char start_LSB ;
};
#line 634 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/interface/scsi_interface.c"
typedef struct scsi_TOC scsi_TOC;
#line 202 "/usr/include/sys/types.h"
typedef unsigned short u_int16_t;
#line 20 "/usr/include/asm-generic/int-ll64.h"
typedef unsigned char __u8;
#line 154 "/usr/include/linux/cdrom.h"
struct cdrom_msf0 {
   __u8 minute ;
   __u8 second ;
   __u8 frame ;
};
#line 162 "/usr/include/linux/cdrom.h"
union cdrom_addr {
   struct cdrom_msf0 msf ;
   int lba ;
};
#line 189 "/usr/include/linux/cdrom.h"
struct cdrom_tochdr {
   __u8 cdth_trk0 ;
   __u8 cdth_trk1 ;
};
#line 219 "/usr/include/linux/cdrom.h"
struct cdrom_tocentry {
   __u8 cdte_track ;
   __u8 cdte_adr : 4 ;
   __u8 cdte_ctrl : 4 ;
   __u8 cdte_format ;
   union cdrom_addr cdte_addr ;
   __u8 cdte_datamode ;
};
#line 238 "/usr/include/linux/cdrom.h"
struct cdrom_read_audio {
   union cdrom_addr addr ;
   __u8 addr_format ;
   int nframes ;
   __u8 *buf ;
};
#line 196 "/usr/include/linux/cdrom.h"
struct cdrom_volctrl {
   __u8 channel0 ;
   __u8 channel1 ;
   __u8 channel2 ;
   __u8 channel3 ;
};
#line 247 "/usr/include/linux/cdrom.h"
struct cdrom_multisession {
   union cdrom_addr addr ;
   __u8 xa_flag ;
   __u8 addr_format ;
};
#line 385 "/usr/include/linux/hdreg.h"
struct hd_driveid {
   unsigned short config ;
   unsigned short cyls ;
   unsigned short reserved2 ;
   unsigned short heads ;
   unsigned short track_bytes ;
   unsigned short sector_bytes ;
   unsigned short sectors ;
   unsigned short vendor0 ;
   unsigned short vendor1 ;
   unsigned short vendor2 ;
   unsigned char serial_no[20] ;
   unsigned short buf_type ;
   unsigned short buf_size ;
   unsigned short ecc_bytes ;
   unsigned char fw_rev[8] ;
   unsigned char model[40] ;
   unsigned char max_multsect ;
   unsigned char vendor3 ;
   unsigned short dword_io ;
   unsigned char vendor4 ;
   unsigned char capability ;
   unsigned short reserved50 ;
   unsigned char vendor5 ;
   unsigned char tPIO ;
   unsigned char vendor6 ;
   unsigned char tDMA ;
   unsigned short field_valid ;
   unsigned short cur_cyls ;
   unsigned short cur_heads ;
   unsigned short cur_sectors ;
   unsigned short cur_capacity0 ;
   unsigned short cur_capacity1 ;
   unsigned char multsect ;
   unsigned char multsect_valid ;
   unsigned int lba_capacity ;
   unsigned short dma_1word ;
   unsigned short dma_mword ;
   unsigned short eide_pio_modes ;
   unsigned short eide_dma_min ;
   unsigned short eide_dma_time ;
   unsigned short eide_pio ;
   unsigned short eide_pio_iordy ;
   unsigned short words69_70[2] ;
   unsigned short words71_74[4] ;
   unsigned short queue_depth ;
   unsigned short words76_79[4] ;
   unsigned short major_rev_num ;
   unsigned short minor_rev_num ;
   unsigned short command_set_1 ;
   unsigned short command_set_2 ;
   unsigned short cfsse ;
   unsigned short cfs_enable_1 ;
   unsigned short cfs_enable_2 ;
   unsigned short csf_default ;
   unsigned short dma_ultra ;
   unsigned short trseuc ;
   unsigned short trsEuc ;
   unsigned short CurAPMvalues ;
   unsigned short mprc ;
   unsigned short hw_config ;
   unsigned short acoustic ;
   unsigned short msrqs ;
   unsigned short sxfert ;
   unsigned short sal ;
   unsigned int spg ;
   unsigned long long lba_capacity_2 ;
   unsigned short words104_125[22] ;
   unsigned short last_lun ;
   unsigned short word127 ;
   unsigned short dlf ;
   unsigned short csfo ;
   unsigned short words130_155[26] ;
   unsigned short word156 ;
   unsigned short words157_159[3] ;
   unsigned short cfa_power ;
   unsigned short words161_175[15] ;
   unsigned short words176_205[30] ;
   unsigned short words206_254[49] ;
   unsigned short integrity_word ;
};
#line 57 "/usr/include/bits/types.h"
typedef unsigned long long __u_quad_t;
#line 134 "/usr/include/bits/types.h"
typedef __u_quad_t __dev_t;
#line 135 "/usr/include/bits/types.h"
typedef unsigned int __uid_t;
#line 136 "/usr/include/bits/types.h"
typedef unsigned int __gid_t;
#line 137 "/usr/include/bits/types.h"
typedef unsigned long __ino_t;
#line 139 "/usr/include/bits/types.h"
typedef unsigned int __mode_t;
#line 140 "/usr/include/bits/types.h"
typedef unsigned int __nlink_t;
#line 164 "/usr/include/bits/types.h"
typedef long __blksize_t;
#line 169 "/usr/include/bits/types.h"
typedef long __blkcnt_t;
#line 43 "/usr/include/bits/stat.h"
struct stat {
   __dev_t st_dev ;
   unsigned short __pad1 ;
   __ino_t st_ino ;
   __mode_t st_mode ;
   __nlink_t st_nlink ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   __dev_t st_rdev ;
   unsigned short __pad2 ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   unsigned long __unused4 ;
   unsigned long __unused5 ;
};
#line 277 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/interface/scan_devices.c"
struct sg_id {
   long l1 ;
   long l2 ;
};
#line 282 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/interface/scan_devices.c"
struct scsiid {
   int bus ;
   int id ;
   int lun ;
};
#line 282 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/interface/scan_devices.c"
typedef struct scsiid scsiid;
#line 9 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/paranoia/isort.h"
struct sort_link {
   struct sort_link *next ;
};
#line 9 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/paranoia/isort.h"
typedef struct sort_link sort_link;
#line 13 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/paranoia/isort.h"
struct sort_info {
   int16_t *vector ;
   long *abspos ;
   long size ;
   long maxsize ;
   long sortbegin ;
   long lo ;
   long hi ;
   int val ;
   sort_link **head ;
   long *bucketusage ;
   long lastbucket ;
   sort_link *revindex ;
};
#line 13 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/paranoia/isort.h"
typedef struct sort_info sort_info;
#line 26 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/paranoia/p_block.h"
struct linked_element;
#line 26 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/paranoia/p_block.h"
struct linked_list {
   struct linked_element *head ;
   struct linked_element *tail ;
   void *(*new_poly)() ;
   void (*free_poly)(void *poly ) ;
   long current ;
   long active ;
};
#line 26 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/paranoia/p_block.h"
typedef struct linked_list linked_list;
#line 38 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/paranoia/p_block.h"
struct linked_element {
   void *ptr ;
   struct linked_element *prev ;
   struct linked_element *next ;
   struct linked_list *list ;
   int stamp ;
};
#line 56
struct cdrom_paranoia;
#line 56 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/paranoia/p_block.h"
struct c_block {
   int16_t *vector ;
   long begin ;
   long size ;
   unsigned char *flags ;
   long lastsector ;
   struct cdrom_paranoia *p ;
   struct linked_element *e ;
};
#line 56 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/paranoia/p_block.h"
typedef struct c_block c_block;
#line 84 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/paranoia/p_block.h"
struct v_fragment {
   c_block *one ;
   long begin ;
   long size ;
   int16_t *vector ;
   long lastsector ;
   struct cdrom_paranoia *p ;
   struct linked_element *e ;
};
#line 84 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/paranoia/p_block.h"
typedef struct v_fragment v_fragment;
#line 115 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/paranoia/p_block.h"
struct root_block {
   long returnedlimit ;
   long lastsector ;
   struct cdrom_paranoia *p ;
   c_block *vector ;
   int silenceflag ;
   long silencebegin ;
};
#line 115 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/paranoia/p_block.h"
typedef struct root_block root_block;
#line 125 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/paranoia/p_block.h"
struct offsets {
   long offpoints ;
   long newpoints ;
   long offaccum ;
   long offdiff ;
   long offmin ;
   long offmax ;
};
#line 125 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/paranoia/p_block.h"
typedef struct offsets offsets;
#line 136 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/paranoia/p_block.h"
struct cdrom_paranoia {
   cdrom_drive *d ;
   root_block root ;
   linked_list *cache ;
   long cache_limit ;
   linked_list *fragments ;
   sort_info *sortcache ;
   int cdcache_size ;
   int cdcache_begin ;
   int cdcache_end ;
   int jitter ;
   int enable ;
   long cursor ;
   long current_lastsector ;
   long current_firstsector ;
   struct offsets stage1 ;
   struct offsets stage2 ;
   long dynoverlap ;
   long dyndrift ;
};
#line 136 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/paranoia/p_block.h"
typedef struct cdrom_paranoia cdrom_paranoia;
#line 38 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/paranoia/p_block.h"
typedef struct linked_element linked_element;
#line 126 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/paranoia/paranoia.c"
enum __anonenum_paranoia_read_flags_48 {
    FLAGS_EDGE = 1,
    FLAGS_UNREAD = 2,
    FLAGS_VERIFIED = 4
} ;
#line 757 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/paranoia/paranoia.c"
struct sync_result {
   long offset ;
   long begin ;
   long end ;
};
#line 757 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/paranoia/paranoia.c"
typedef struct sync_result sync_result;
#line 38 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/paranoia/cdda_paranoia.h"
typedef void cdrom_paranoia___0;
#line 106 "/usr/include/getopt.h"
struct option {
   char const   *name ;
   int has_arg ;
   int *flag ;
   int val ;
};
#line 57 "/usr/include/sys/time.h"
struct timezone {
   int tz_minuteswest ;
   int tz_dsttime ;
};
#line 63 "/usr/include/sys/time.h"
typedef struct timezone * __restrict  __timezone_ptr_t;
#line 473 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *calloc(size_t __nmemb , size_t __size )  __attribute__((__malloc__)) ;
#line 485
extern  __attribute__((__nothrow__)) void *( __attribute__((__warn_unused_result__)) realloc)(void *__ptr ,
                                                                                              size_t __size ) ;
#line 363 "/usr/include/unistd.h"
extern ssize_t write(int __fd , void const   *__buf , size_t __n ) ;
#line 135 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2))) strcat)(char * __restrict  __dest ,
                                                                                       char const   * __restrict  __src ) ;
#line 397
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1))) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 137 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/interface/cdda_interface.h"
long cdda_track_firstsector(cdrom_drive *d___0 , int track ) ;
#line 138
long cdda_track_lastsector(cdrom_drive *d___0 , int track ) ;
#line 139
long cdda_tracks(cdrom_drive *d___0 ) ;
#line 140
int cdda_sector_gettrack(cdrom_drive *d___0 , long sector ) ;
#line 141
int cdda_track_channels(cdrom_drive *d___0 , int track ) ;
#line 142
int cdda_track_audiop(cdrom_drive *d___0 , int track ) ;
#line 143
int cdda_track_copyp(cdrom_drive *d___0 , int track ) ;
#line 144
int cdda_track_preemp(cdrom_drive *d___0 , int track ) ;
#line 145
long cdda_disc_firstsector(cdrom_drive *d___0 ) ;
#line 146
long cdda_disc_lastsector(cdrom_drive *d___0 ) ;
#line 93 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/interface/utils.h"
__inline static char *catstring(char *buff , char const   *s ) 
{ 
  size_t tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;
  size_t tmp___2 ;
  void *tmp___3 ;

  {
#line 94
  if (s) {
#line 95
    if (buff) {
      {
#line 96
      tmp = strlen((char const   *)buff);
#line 96
      tmp___0 = strlen(s);
#line 96
      tmp___1 = realloc((void *)buff, (tmp + tmp___0) + 9U);
#line 96
      buff = (char *)tmp___1;
      }
    } else {
      {
#line 98
      tmp___2 = strlen(s);
#line 98
      tmp___3 = calloc(tmp___2 + 9U, (size_t )1);
#line 98
      buff = (char *)tmp___3;
      }
    }
    {
#line 99
    strcat((char */* __restrict  */)buff, (char const   */* __restrict  */)s);
    }
  }
#line 101
  return (buff);
}
}
#line 104 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/interface/utils.h"
static void cderror(cdrom_drive *d___0 , char const   *s ) 
{ 
  size_t tmp ;

  {
#line 105
  if (s) {
#line 105
    if (d___0) {
      {
#line 107
      if (d___0->errordest == 1) {
#line 107
        goto case_1;
      }
#line 110
      if (d___0->errordest == 2) {
#line 110
        goto case_2;
      }
#line 114
      goto switch_default;
      case_1: /* CIL Label */ 
      {
#line 108
      tmp = strlen(s);
#line 108
      write(2, (void const   *)s, tmp);
      }
#line 109
      goto switch_break;
      case_2: /* CIL Label */ 
      {
#line 111
      d___0->errorbuf = catstring(d___0->errorbuf, s);
      }
#line 112
      goto switch_break;
      switch_default: /* CIL Label */ 
#line 115
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    }
  }
#line 118
  return;
}
}
#line 13 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/interface/toc.c"
long cdda_track_firstsector(cdrom_drive *d___0 , int track ) 
{ 
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
#line 14
  if (! d___0->opened) {
    {
#line 15
    cderror(d___0, "400: Device not open\n");
    }
#line 16
    return (-400L);
  }
#line 19
  if (track == 0) {
#line 20
    if (d___0->disc_toc[0].dwStartSector == 0) {
      {
#line 22
      cderror(d___0, "401: Invalid track number\n");
      }
#line 23
      return (-401L);
    } else {
#line 26
      return (0L);
    }
  }
#line 30
  if (track < 0) {
    {
#line 31
    cderror(d___0, "401: Invalid track number\n");
    }
#line 32
    return (-401L);
  } else
#line 30
  if (track > d___0->tracks) {
    {
#line 31
    cderror(d___0, "401: Invalid track number\n");
    }
#line 32
    return (-401L);
  }
#line 34
  return ((long )d___0->disc_toc[track - 1].dwStartSector);
}
}
#line 37 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/interface/toc.c"
long cdda_disc_firstsector(cdrom_drive *d___0 ) 
{ 
  int i ;
  long tmp ;
  int tmp___0 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
#line 39
  if (! d___0->opened) {
    {
#line 40
    cderror(d___0, "400: Device not open\n");
    }
#line 41
    return (-400L);
  }
#line 45
  i = 0;
  {
#line 45
  while (1) {
    while_continue: /* CIL Label */ ;
#line 45
    if (! (i < d___0->tracks)) {
#line 45
      goto while_break;
    }
    {
#line 46
    tmp___0 = cdda_track_audiop(d___0, i + 1);
    }
#line 46
    if (tmp___0 == 1) {
#line 47
      if (i == 0) {
#line 48
        return (0L);
      } else {
        {
#line 50
        tmp = cdda_track_firstsector(d___0, i + 1);
        }
#line 50
        return (tmp);
      }
    }
#line 45
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 53
  cderror(d___0, "403: No audio tracks on disc\n");
  }
#line 54
  return (-403L);
}
}
#line 57 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/interface/toc.c"
long cdda_track_lastsector(cdrom_drive *d___0 , int track ) 
{ 
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
#line 58
  if (! d___0->opened) {
    {
#line 59
    cderror(d___0, "400: Device not open\n");
    }
#line 60
    return (-400L);
  }
#line 63
  if (track == 0) {
#line 64
    if (d___0->disc_toc[0].dwStartSector == 0) {
      {
#line 66
      cderror(d___0, "401: Invalid track number\n");
      }
#line 67
      return (-401L);
    } else {
#line 70
      return ((long )(d___0->disc_toc[0].dwStartSector - 1));
    }
  }
#line 74
  if (track < 1) {
    {
#line 75
    cderror(d___0, "401: Invalid track number\n");
    }
#line 76
    return (-401L);
  } else
#line 74
  if (track > d___0->tracks) {
    {
#line 75
    cderror(d___0, "401: Invalid track number\n");
    }
#line 76
    return (-401L);
  }
#line 79
  return ((long )(d___0->disc_toc[track].dwStartSector - 1));
}
}
#line 82 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/interface/toc.c"
long cdda_disc_lastsector(cdrom_drive *d___0 ) 
{ 
  int i ;
  long tmp ;
  int tmp___0 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
#line 84
  if (! d___0->opened) {
    {
#line 85
    cderror(d___0, "400: Device not open\n");
    }
#line 86
    return (-400L);
  }
#line 90
  i = d___0->tracks - 1;
  {
#line 90
  while (1) {
    while_continue: /* CIL Label */ ;
#line 90
    if (! (i >= 0)) {
#line 90
      goto while_break;
    }
    {
#line 91
    tmp___0 = cdda_track_audiop(d___0, i + 1);
    }
#line 91
    if (tmp___0 == 1) {
      {
#line 92
      tmp = cdda_track_lastsector(d___0, i + 1);
      }
#line 92
      return (tmp);
    }
#line 90
    i --;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 94
  cderror(d___0, "403: No audio tracks on disc\n");
  }
#line 95
  return (-403L);
}
}
#line 98 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/interface/toc.c"
long cdda_tracks(cdrom_drive *d___0 ) 
{ 
  char *__cil_tmp2 ;

  {
#line 99
  if (! d___0->opened) {
    {
#line 100
    cderror(d___0, "400: Device not open\n");
    }
#line 101
    return (-400L);
  }
#line 103
  return ((long )d___0->tracks);
}
}
#line 106 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/interface/toc.c"
int cdda_sector_gettrack(cdrom_drive *d___0 , long sector ) 
{ 
  int i ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;

  {
#line 107
  if (! d___0->opened) {
    {
#line 108
    cderror(d___0, "400: Device not open\n");
    }
#line 109
    return (-400);
  } else {
#line 113
    if (sector < (long )d___0->disc_toc[0].dwStartSector) {
#line 114
      return (0);
    }
#line 116
    i = 0;
    {
#line 116
    while (1) {
      while_continue: /* CIL Label */ ;
#line 116
      if (! (i < d___0->tracks)) {
#line 116
        goto while_break;
      }
#line 117
      if ((long )d___0->disc_toc[i].dwStartSector <= sector) {
#line 117
        if ((long )d___0->disc_toc[i + 1].dwStartSector > sector) {
#line 119
          return (i + 1);
        }
      }
#line 116
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 122
    cderror(d___0, "401: Invalid track number\n");
    }
#line 123
    return (-401);
  }
}
}
#line 127 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/interface/toc.c"
int cdda_track_bitmap(cdrom_drive *d___0 , int track , int bit , int set , int clear ) 
{ 
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
#line 128
  if (! d___0->opened) {
    {
#line 129
    cderror(d___0, "400: Device not open\n");
    }
#line 130
    return (-400);
  }
#line 133
  if (track == 0) {
#line 134
    track = 1;
  }
#line 136
  if (track < 1) {
    {
#line 137
    cderror(d___0, "401: Invalid track number\n");
    }
#line 138
    return (-401);
  } else
#line 136
  if (track > d___0->tracks) {
    {
#line 137
    cderror(d___0, "401: Invalid track number\n");
    }
#line 138
    return (-401);
  }
#line 140
  if ((int )d___0->disc_toc[track - 1].bFlags & bit) {
#line 141
    return (set);
  } else {
#line 143
    return (clear);
  }
}
}
#line 147 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/interface/toc.c"
int cdda_track_channels(cdrom_drive *d___0 , int track ) 
{ 
  int tmp ;

  {
  {
#line 148
  tmp = cdda_track_bitmap(d___0, track, 8, 4, 2);
  }
#line 148
  return (tmp);
}
}
#line 151 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/interface/toc.c"
int cdda_track_audiop(cdrom_drive *d___0 , int track ) 
{ 
  int tmp ;

  {
  {
#line 152
  tmp = cdda_track_bitmap(d___0, track, 4, 0, 1);
  }
#line 152
  return (tmp);
}
}
#line 155 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/interface/toc.c"
int cdda_track_copyp(cdrom_drive *d___0 , int track ) 
{ 
  int tmp ;

  {
  {
#line 156
  tmp = cdda_track_bitmap(d___0, track, 2, 1, 0);
  }
#line 156
  return (tmp);
}
}
#line 159 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/interface/toc.c"
int cdda_track_preemp(cdrom_drive *d___0 , int track ) 
{ 
  int tmp ;

  {
  {
#line 160
  tmp = cdda_track_bitmap(d___0, track, 1, 1, 0);
  }
#line 160
  return (tmp);
}
}
#line 488 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void free(void *__ptr ) ;
#line 64 "/usr/include/bits/mathcalls.h"
extern  __attribute__((__nothrow__)) double cos(double __x ) ;
#line 66
extern  __attribute__((__nothrow__)) double sin(double __x ) ;
#line 10 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/interface/smallft.h"
void fft_forward(int n , float *buf , float *trigcache , int *splitcache ) ;
#line 11
void fft_backward(int n , float *buf , float *trigcache , int *splitcache ) ;
#line 12
void fft_i(int n , float **trigcache , int **splitcache ) ;
#line 18 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/interface/smallft.c"
static void drfti1(int n , float *wa , int *ifac ) ;
#line 18 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/interface/smallft.c"
static int ntryh[4]  = {      4,      2,      3,      5};
#line 19 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/interface/smallft.c"
static float tpi  =    (float )6.28318530717958647692528676655900577;
#line 17 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/interface/smallft.c"
static void drfti1(int n , float *wa , int *ifac ) 
{ 
  float arg ;
  float argh ;
  float argld ;
  float fi ;
  int ntry ;
  int i ;
  int j ;
  int k1 ;
  int l1 ;
  int l2 ;
  int ib ;
  int ld ;
  int ii ;
  int ip ;
  int is ;
  int nq ;
  int nr ;
  int ido ;
  int ipm ;
  int nfm1 ;
  int nl ;
  int nf ;
  int tmp ;
  double tmp___0 ;
  int tmp___1 ;
  double tmp___2 ;

  {
#line 21
  ntry = 0;
#line 21
  j = -1;
#line 25
  nl = n;
#line 26
  nf = 0;
  L101: 
#line 29
  j ++;
#line 30
  if (j < 4) {
#line 31
    ntry = ntryh[j];
  } else {
#line 33
    ntry += 2;
  }
  L104: 
#line 36
  nq = nl / ntry;
#line 37
  nr = nl - ntry * nq;
#line 38
  if (nr != 0) {
#line 38
    goto L101;
  }
#line 40
  nf ++;
#line 41
  *(ifac + (nf + 1)) = ntry;
#line 42
  nl = nq;
#line 43
  if (ntry != 2) {
#line 43
    goto L107;
  }
#line 44
  if (nf == 1) {
#line 44
    goto L107;
  }
#line 46
  i = 1;
  {
#line 46
  while (1) {
    while_continue: /* CIL Label */ ;
#line 46
    if (! (i < nf)) {
#line 46
      goto while_break;
    }
#line 47
    ib = (nf - i) + 1;
#line 48
    *(ifac + (ib + 1)) = *(ifac + ib);
#line 46
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 50
  *(ifac + 2) = 2;
  L107: 
#line 53
  if (nl != 1) {
#line 53
    goto L104;
  }
#line 54
  *(ifac + 0) = n;
#line 55
  *(ifac + 1) = nf;
#line 56
  argh = tpi / (float )n;
#line 57
  is = 0;
#line 58
  nfm1 = nf - 1;
#line 59
  l1 = 1;
#line 61
  if (nfm1 == 0) {
#line 61
    return;
  }
#line 63
  k1 = 0;
  {
#line 63
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 63
    if (! (k1 < nfm1)) {
#line 63
      goto while_break___0;
    }
#line 64
    ip = *(ifac + (k1 + 2));
#line 65
    ld = 0;
#line 66
    l2 = l1 * ip;
#line 67
    ido = n / l2;
#line 68
    ipm = ip - 1;
#line 70
    j = 0;
    {
#line 70
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 70
      if (! (j < ipm)) {
#line 70
        goto while_break___1;
      }
#line 71
      ld += l1;
#line 72
      i = is;
#line 73
      argld = (float )ld * argh;
#line 74
      fi = (float )0.;
#line 75
      ii = 2;
      {
#line 75
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 75
        if (! (ii < ido)) {
#line 75
          goto while_break___2;
        }
        {
#line 76
        fi = (float )((double )fi + 1.);
#line 77
        arg = fi * argld;
#line 78
        tmp = i;
#line 78
        i ++;
#line 78
        tmp___0 = cos((double )arg);
#line 78
        *(wa + tmp) = (float )tmp___0;
#line 79
        tmp___1 = i;
#line 79
        i ++;
#line 79
        tmp___2 = sin((double )arg);
#line 79
        *(wa + tmp___1) = (float )tmp___2;
#line 75
        ii += 2;
        }
      }
      while_break___2: /* CIL Label */ ;
      }
#line 81
      is += ido;
#line 70
      j ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 83
    l1 = l2;
#line 63
    k1 ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 85
  return;
}
}
#line 87 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/interface/smallft.c"
static void fdrffti(int n , float *wsave , int *ifac ) 
{ 


  {
#line 89
  if (n == 1) {
#line 89
    return;
  }
  {
#line 90
  drfti1(n, wsave + n, ifac);
  }
#line 91
  return;
}
}
#line 93 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/interface/smallft.c"
static void dradf2(int ido , int l1 , float *cc , float *ch , float *wa1 ) 
{ 
  int i ;
  int k ;
  float ti2 ;
  float tr2 ;
  int t0 ;
  int t1 ;
  int t2 ;
  int t3 ;
  int t4 ;
  int t5 ;
  int t6 ;

  {
#line 98
  t1 = 0;
#line 99
  t2 = l1 * ido;
#line 99
  t0 = t2;
#line 100
  t3 = ido << 1;
#line 101
  k = 0;
  {
#line 101
  while (1) {
    while_continue: /* CIL Label */ ;
#line 101
    if (! (k < l1)) {
#line 101
      goto while_break;
    }
#line 102
    *(ch + (t1 << 1)) = *(cc + t1) + *(cc + t2);
#line 103
    *(ch + (((t1 << 1) + t3) - 1)) = *(cc + t1) - *(cc + t2);
#line 104
    t1 += ido;
#line 105
    t2 += ido;
#line 101
    k ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 108
  if (ido < 2) {
#line 108
    return;
  }
#line 109
  if (ido == 2) {
#line 109
    goto L105;
  }
#line 111
  t1 = 0;
#line 112
  t2 = t0;
#line 113
  k = 0;
  {
#line 113
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 113
    if (! (k < l1)) {
#line 113
      goto while_break___0;
    }
#line 114
    t3 = t2;
#line 115
    t4 = (t1 << 1) + (ido << 1);
#line 116
    t5 = t1;
#line 117
    t6 = t1 + t1;
#line 118
    i = 2;
    {
#line 118
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 118
      if (! (i < ido)) {
#line 118
        goto while_break___1;
      }
#line 119
      t3 += 2;
#line 120
      t4 -= 2;
#line 121
      t5 += 2;
#line 122
      t6 += 2;
#line 123
      tr2 = *(wa1 + (i - 2)) * *(cc + (t3 - 1)) + *(wa1 + (i - 1)) * *(cc + t3);
#line 124
      ti2 = *(wa1 + (i - 2)) * *(cc + t3) - *(wa1 + (i - 1)) * *(cc + (t3 - 1));
#line 125
      *(ch + t6) = *(cc + t5) + ti2;
#line 126
      *(ch + t4) = ti2 - *(cc + t5);
#line 127
      *(ch + (t6 - 1)) = *(cc + (t5 - 1)) + tr2;
#line 128
      *(ch + (t4 - 1)) = *(cc + (t5 - 1)) - tr2;
#line 118
      i += 2;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 130
    t1 += ido;
#line 131
    t2 += ido;
#line 113
    k ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 134
  if (ido % 2 == 1) {
#line 134
    return;
  }
  L105: 
#line 137
  t1 = ido;
#line 137
  t2 = t1 - 1;
#line 137
  t3 = t2;
#line 138
  t2 += t0;
#line 139
  k = 0;
  {
#line 139
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 139
    if (! (k < l1)) {
#line 139
      goto while_break___2;
    }
#line 140
    *(ch + t1) = - *(cc + t2);
#line 141
    *(ch + (t1 - 1)) = *(cc + t3);
#line 142
    t1 += ido << 1;
#line 143
    t2 += ido;
#line 144
    t3 += ido;
#line 139
    k ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 146
  return;
}
}
#line 150
static void dradf4(int ido , int l1 , float *cc , float *ch , float *wa1 , float *wa2 ,
                   float *wa3 ) ;
#line 150 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/interface/smallft.c"
static float hsqt2  =    (float ).70710678118654752440084436210485;
#line 148 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/interface/smallft.c"
static void dradf4(int ido , int l1 , float *cc , float *ch , float *wa1 , float *wa2 ,
                   float *wa3 ) 
{ 
  int i ;
  int k ;
  int t0 ;
  int t1 ;
  int t2 ;
  int t3 ;
  int t4 ;
  int t5 ;
  int t6 ;
  float ci2 ;
  float ci3 ;
  float ci4 ;
  float cr2 ;
  float cr3 ;
  float cr4 ;
  float ti1 ;
  float ti2 ;
  float ti3 ;
  float ti4 ;
  float tr1 ;
  float tr2 ;
  float tr3 ;
  float tr4 ;

  {
#line 153
  t0 = l1 * ido;
#line 155
  t1 = t0;
#line 156
  t4 = t1 << 1;
#line 157
  t2 = t1 + (t1 << 1);
#line 158
  t3 = 0;
#line 160
  k = 0;
  {
#line 160
  while (1) {
    while_continue: /* CIL Label */ ;
#line 160
    if (! (k < l1)) {
#line 160
      goto while_break;
    }
#line 161
    tr1 = *(cc + t1) + *(cc + t2);
#line 162
    tr2 = *(cc + t3) + *(cc + t4);
#line 164
    t5 = t3 << 2;
#line 164
    *(ch + t5) = tr1 + tr2;
#line 165
    *(ch + (((ido << 2) + t5) - 1)) = tr2 - tr1;
#line 166
    t5 += ido << 1;
#line 166
    *(ch + (t5 - 1)) = *(cc + t3) - *(cc + t4);
#line 167
    *(ch + t5) = *(cc + t2) - *(cc + t1);
#line 169
    t1 += ido;
#line 170
    t2 += ido;
#line 171
    t3 += ido;
#line 172
    t4 += ido;
#line 160
    k ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 175
  if (ido < 2) {
#line 175
    return;
  }
#line 176
  if (ido == 2) {
#line 176
    goto L105;
  }
#line 179
  t1 = 0;
#line 180
  k = 0;
  {
#line 180
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 180
    if (! (k < l1)) {
#line 180
      goto while_break___0;
    }
#line 181
    t2 = t1;
#line 182
    t4 = t1 << 2;
#line 183
    t6 = ido << 1;
#line 183
    t5 = t6 + t4;
#line 184
    i = 2;
    {
#line 184
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 184
      if (! (i < ido)) {
#line 184
        goto while_break___1;
      }
#line 185
      t2 += 2;
#line 185
      t3 = t2;
#line 186
      t4 += 2;
#line 187
      t5 -= 2;
#line 189
      t3 += t0;
#line 190
      cr2 = *(wa1 + (i - 2)) * *(cc + (t3 - 1)) + *(wa1 + (i - 1)) * *(cc + t3);
#line 191
      ci2 = *(wa1 + (i - 2)) * *(cc + t3) - *(wa1 + (i - 1)) * *(cc + (t3 - 1));
#line 192
      t3 += t0;
#line 193
      cr3 = *(wa2 + (i - 2)) * *(cc + (t3 - 1)) + *(wa2 + (i - 1)) * *(cc + t3);
#line 194
      ci3 = *(wa2 + (i - 2)) * *(cc + t3) - *(wa2 + (i - 1)) * *(cc + (t3 - 1));
#line 195
      t3 += t0;
#line 196
      cr4 = *(wa3 + (i - 2)) * *(cc + (t3 - 1)) + *(wa3 + (i - 1)) * *(cc + t3);
#line 197
      ci4 = *(wa3 + (i - 2)) * *(cc + t3) - *(wa3 + (i - 1)) * *(cc + (t3 - 1));
#line 199
      tr1 = cr2 + cr4;
#line 200
      tr4 = cr4 - cr2;
#line 201
      ti1 = ci2 + ci4;
#line 202
      ti4 = ci2 - ci4;
#line 204
      ti2 = *(cc + t2) + ci3;
#line 205
      ti3 = *(cc + t2) - ci3;
#line 206
      tr2 = *(cc + (t2 - 1)) + cr3;
#line 207
      tr3 = *(cc + (t2 - 1)) - cr3;
#line 209
      *(ch + (t4 - 1)) = tr1 + tr2;
#line 210
      *(ch + t4) = ti1 + ti2;
#line 212
      *(ch + (t5 - 1)) = tr3 - ti4;
#line 213
      *(ch + t5) = tr4 - ti3;
#line 215
      *(ch + ((t4 + t6) - 1)) = ti4 + tr3;
#line 216
      *(ch + (t4 + t6)) = tr4 + ti3;
#line 218
      *(ch + ((t5 + t6) - 1)) = tr2 - tr1;
#line 219
      *(ch + (t5 + t6)) = ti1 - ti2;
#line 184
      i += 2;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 221
    t1 += ido;
#line 180
    k ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 223
  if (ido & 1) {
#line 223
    return;
  }
  L105: 
#line 227
  t1 = (t0 + ido) - 1;
#line 227
  t2 = t1 + (t0 << 1);
#line 228
  t3 = ido << 2;
#line 229
  t4 = ido;
#line 230
  t5 = ido << 1;
#line 231
  t6 = ido;
#line 233
  k = 0;
  {
#line 233
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 233
    if (! (k < l1)) {
#line 233
      goto while_break___2;
    }
#line 234
    ti1 = - hsqt2 * (*(cc + t1) + *(cc + t2));
#line 235
    tr1 = hsqt2 * (*(cc + t1) - *(cc + t2));
#line 237
    *(ch + (t4 - 1)) = tr1 + *(cc + (t6 - 1));
#line 238
    *(ch + ((t4 + t5) - 1)) = *(cc + (t6 - 1)) - tr1;
#line 240
    *(ch + t4) = ti1 - *(cc + (t1 + t0));
#line 241
    *(ch + (t4 + t5)) = ti1 + *(cc + (t1 + t0));
#line 243
    t1 += ido;
#line 244
    t2 += ido;
#line 245
    t4 += t3;
#line 246
    t6 += ido;
#line 233
    k ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 248
  return;
}
}
#line 250 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/interface/smallft.c"
static void drftf1(int n , float *c , float *ch , float *wa , int *ifac ) 
{ 
  int i ;
  int k1 ;
  int l1 ;
  int l2 ;
  int na ;
  int kh ;
  int nf ;
  int ip ;
  int iw ;
  int ido ;
  int idl1 ;
  int ix2 ;
  int ix3 ;

  {
#line 255
  nf = *(ifac + 1);
#line 256
  na = 1;
#line 257
  l2 = n;
#line 258
  iw = n;
#line 260
  k1 = 0;
  {
#line 260
  while (1) {
    while_continue: /* CIL Label */ ;
#line 260
    if (! (k1 < nf)) {
#line 260
      goto while_break;
    }
#line 261
    kh = nf - k1;
#line 262
    ip = *(ifac + (kh + 1));
#line 263
    l1 = l2 / ip;
#line 264
    ido = n / l2;
#line 265
    idl1 = ido * l1;
#line 266
    iw -= (ip - 1) * ido;
#line 267
    na = 1 - na;
#line 269
    if (ip != 4) {
#line 269
      goto L102;
    }
#line 271
    ix2 = iw + ido;
#line 272
    ix3 = ix2 + ido;
#line 273
    if (na != 0) {
      {
#line 274
      dradf4(ido, l1, ch, c, (wa + iw) - 1, (wa + ix2) - 1, (wa + ix3) - 1);
      }
    } else {
      {
#line 276
      dradf4(ido, l1, c, ch, (wa + iw) - 1, (wa + ix2) - 1, (wa + ix3) - 1);
      }
    }
#line 277
    goto L110;
    L102: 
#line 280
    if (ip != 2) {
#line 280
      goto L104;
    }
#line 281
    if (na != 0) {
#line 281
      goto L103;
    }
    {
#line 283
    dradf2(ido, l1, c, ch, (wa + iw) - 1);
    }
#line 284
    goto L110;
    L103: 
    {
#line 287
    dradf2(ido, l1, ch, c, (wa + iw) - 1);
    }
#line 288
    goto L110;
    L104: 
#line 291
    return;
    L110: 
#line 294
    l2 = l1;
#line 260
    k1 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 297
  if (na == 1) {
#line 297
    return;
  }
#line 299
  i = 0;
  {
#line 299
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 299
    if (! (i < n)) {
#line 299
      goto while_break___0;
    }
#line 299
    *(c + i) = *(ch + i);
#line 299
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 300
  return;
}
}
#line 302 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/interface/smallft.c"
static void fdrfftf(int n , float *r , float *wsave , int *ifac ) 
{ 


  {
#line 303
  if (n == 1) {
#line 303
    return;
  }
  {
#line 304
  drftf1(n, r, wsave, wsave + n, ifac);
  }
#line 305
  return;
}
}
#line 307 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/interface/smallft.c"
static void dradb2(int ido , int l1 , float *cc , float *ch , float *wa1 ) 
{ 
  int i ;
  int k ;
  int t0 ;
  int t1 ;
  int t2 ;
  int t3 ;
  int t4 ;
  int t5 ;
  int t6 ;
  float ti2 ;
  float tr2 ;

  {
#line 311
  t0 = l1 * ido;
#line 313
  t1 = 0;
#line 314
  t2 = 0;
#line 315
  t3 = (ido << 1) - 1;
#line 316
  k = 0;
  {
#line 316
  while (1) {
    while_continue: /* CIL Label */ ;
#line 316
    if (! (k < l1)) {
#line 316
      goto while_break;
    }
#line 317
    *(ch + t1) = *(cc + t2) + *(cc + (t3 + t2));
#line 318
    *(ch + (t1 + t0)) = *(cc + t2) - *(cc + (t3 + t2));
#line 319
    t1 += ido;
#line 319
    t2 = t1 << 1;
#line 316
    k ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 322
  if (ido < 2) {
#line 322
    return;
  }
#line 323
  if (ido == 2) {
#line 323
    goto L105;
  }
#line 325
  t1 = 0;
#line 326
  t2 = 0;
#line 327
  k = 0;
  {
#line 327
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 327
    if (! (k < l1)) {
#line 327
      goto while_break___0;
    }
#line 328
    t3 = t1;
#line 329
    t4 = t2;
#line 329
    t5 = t4 + (ido << 1);
#line 330
    t6 = t0 + t1;
#line 331
    i = 2;
    {
#line 331
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 331
      if (! (i < ido)) {
#line 331
        goto while_break___1;
      }
#line 332
      t3 += 2;
#line 333
      t4 += 2;
#line 334
      t5 -= 2;
#line 335
      t6 += 2;
#line 336
      *(ch + (t3 - 1)) = *(cc + (t4 - 1)) + *(cc + (t5 - 1));
#line 337
      tr2 = *(cc + (t4 - 1)) - *(cc + (t5 - 1));
#line 338
      *(ch + t3) = *(cc + t4) - *(cc + t5);
#line 339
      ti2 = *(cc + t4) + *(cc + t5);
#line 340
      *(ch + (t6 - 1)) = *(wa1 + (i - 2)) * tr2 - *(wa1 + (i - 1)) * ti2;
#line 341
      *(ch + t6) = *(wa1 + (i - 2)) * ti2 + *(wa1 + (i - 1)) * tr2;
#line 331
      i += 2;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 343
    t1 += ido;
#line 343
    t2 = t1 << 1;
#line 327
    k ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 346
  if (ido % 2 == 1) {
#line 346
    return;
  }
  L105: 
#line 349
  t1 = ido - 1;
#line 350
  t2 = ido - 1;
#line 351
  k = 0;
  {
#line 351
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 351
    if (! (k < l1)) {
#line 351
      goto while_break___2;
    }
#line 352
    *(ch + t1) = *(cc + t2) + *(cc + t2);
#line 353
    *(ch + (t1 + t0)) = - (*(cc + (t2 + 1)) + *(cc + (t2 + 1)));
#line 354
    t1 += ido;
#line 355
    t2 += ido << 1;
#line 351
    k ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 357
  return;
}
}
#line 361
static void dradb4(int ido , int l1 , float *cc , float *ch , float *wa1 , float *wa2 ,
                   float *wa3 ) ;
#line 361 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/interface/smallft.c"
static float sqrt2  =    (float )1.4142135623730950488016887242097;
#line 359 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/interface/smallft.c"
static void dradb4(int ido , int l1 , float *cc , float *ch , float *wa1 , float *wa2 ,
                   float *wa3 ) 
{ 
  int i ;
  int k ;
  int t0 ;
  int t1 ;
  int t2 ;
  int t3 ;
  int t4 ;
  int t5 ;
  int t6 ;
  int t7 ;
  int t8 ;
  float ci2 ;
  float ci3 ;
  float ci4 ;
  float cr2 ;
  float cr3 ;
  float cr4 ;
  float ti1 ;
  float ti2 ;
  float ti3 ;
  float ti4 ;
  float tr1 ;
  float tr2 ;
  float tr3 ;
  float tr4 ;

  {
#line 364
  t0 = l1 * ido;
#line 366
  t1 = 0;
#line 367
  t2 = ido << 2;
#line 368
  t3 = 0;
#line 369
  t6 = ido << 1;
#line 370
  k = 0;
  {
#line 370
  while (1) {
    while_continue: /* CIL Label */ ;
#line 370
    if (! (k < l1)) {
#line 370
      goto while_break;
    }
#line 371
    t4 = t3 + t6;
#line 372
    t5 = t1;
#line 373
    tr3 = *(cc + (t4 - 1)) + *(cc + (t4 - 1));
#line 374
    tr4 = *(cc + t4) + *(cc + t4);
#line 375
    t4 += t6;
#line 375
    tr1 = *(cc + t3) - *(cc + (t4 - 1));
#line 376
    tr2 = *(cc + t3) + *(cc + (t4 - 1));
#line 377
    *(ch + t5) = tr2 + tr3;
#line 378
    t5 += t0;
#line 378
    *(ch + t5) = tr1 - tr4;
#line 379
    t5 += t0;
#line 379
    *(ch + t5) = tr2 - tr3;
#line 380
    t5 += t0;
#line 380
    *(ch + t5) = tr1 + tr4;
#line 381
    t1 += ido;
#line 382
    t3 += t2;
#line 370
    k ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 385
  if (ido < 2) {
#line 385
    return;
  }
#line 386
  if (ido == 2) {
#line 386
    goto L105;
  }
#line 388
  t1 = 0;
#line 389
  k = 0;
  {
#line 389
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 389
    if (! (k < l1)) {
#line 389
      goto while_break___0;
    }
#line 390
    t2 = t1 << 2;
#line 390
    t3 = t2 + t6;
#line 390
    t4 = t3;
#line 390
    t5 = t4 + t6;
#line 391
    t7 = t1;
#line 392
    i = 2;
    {
#line 392
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 392
      if (! (i < ido)) {
#line 392
        goto while_break___1;
      }
#line 393
      t2 += 2;
#line 394
      t3 += 2;
#line 395
      t4 -= 2;
#line 396
      t5 -= 2;
#line 397
      t7 += 2;
#line 398
      ti1 = *(cc + t2) + *(cc + t5);
#line 399
      ti2 = *(cc + t2) - *(cc + t5);
#line 400
      ti3 = *(cc + t3) - *(cc + t4);
#line 401
      tr4 = *(cc + t3) + *(cc + t4);
#line 402
      tr1 = *(cc + (t2 - 1)) - *(cc + (t5 - 1));
#line 403
      tr2 = *(cc + (t2 - 1)) + *(cc + (t5 - 1));
#line 404
      ti4 = *(cc + (t3 - 1)) - *(cc + (t4 - 1));
#line 405
      tr3 = *(cc + (t3 - 1)) + *(cc + (t4 - 1));
#line 406
      *(ch + (t7 - 1)) = tr2 + tr3;
#line 407
      cr3 = tr2 - tr3;
#line 408
      *(ch + t7) = ti2 + ti3;
#line 409
      ci3 = ti2 - ti3;
#line 410
      cr2 = tr1 - tr4;
#line 411
      cr4 = tr1 + tr4;
#line 412
      ci2 = ti1 + ti4;
#line 413
      ci4 = ti1 - ti4;
#line 415
      t8 = t7 + t0;
#line 415
      *(ch + (t8 - 1)) = *(wa1 + (i - 2)) * cr2 - *(wa1 + (i - 1)) * ci2;
#line 416
      *(ch + t8) = *(wa1 + (i - 2)) * ci2 + *(wa1 + (i - 1)) * cr2;
#line 417
      t8 += t0;
#line 417
      *(ch + (t8 - 1)) = *(wa2 + (i - 2)) * cr3 - *(wa2 + (i - 1)) * ci3;
#line 418
      *(ch + t8) = *(wa2 + (i - 2)) * ci3 + *(wa2 + (i - 1)) * cr3;
#line 419
      t8 += t0;
#line 419
      *(ch + (t8 - 1)) = *(wa3 + (i - 2)) * cr4 - *(wa3 + (i - 1)) * ci4;
#line 420
      *(ch + t8) = *(wa3 + (i - 2)) * ci4 + *(wa3 + (i - 1)) * cr4;
#line 392
      i += 2;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 422
    t1 += ido;
#line 389
    k ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 425
  if (ido % 2 == 1) {
#line 425
    return;
  }
  L105: 
#line 429
  t1 = ido;
#line 430
  t2 = ido << 2;
#line 431
  t3 = ido - 1;
#line 432
  t4 = ido + (ido << 1);
#line 433
  k = 0;
  {
#line 433
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 433
    if (! (k < l1)) {
#line 433
      goto while_break___2;
    }
#line 434
    t5 = t3;
#line 435
    ti1 = *(cc + t1) + *(cc + t4);
#line 436
    ti2 = *(cc + t4) - *(cc + t1);
#line 437
    tr1 = *(cc + (t1 - 1)) - *(cc + (t4 - 1));
#line 438
    tr2 = *(cc + (t1 - 1)) + *(cc + (t4 - 1));
#line 439
    *(ch + t5) = tr2 + tr2;
#line 440
    t5 += t0;
#line 440
    *(ch + t5) = sqrt2 * (tr1 - ti1);
#line 441
    t5 += t0;
#line 441
    *(ch + t5) = ti2 + ti2;
#line 442
    t5 += t0;
#line 442
    *(ch + t5) = - sqrt2 * (tr1 + ti1);
#line 444
    t3 += ido;
#line 445
    t1 += t2;
#line 446
    t4 += t2;
#line 433
    k ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 448
  return;
}
}
#line 450 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/interface/smallft.c"
static void drftb1(int n , float *c , float *ch , float *wa , int *ifac ) 
{ 
  int i ;
  int k1 ;
  int l1 ;
  int l2 ;
  int na ;
  int nf ;
  int ip ;
  int iw ;
  int ix2 ;
  int ix3 ;
  int ido ;
  int idl1 ;

  {
#line 455
  nf = *(ifac + 1);
#line 456
  na = 0;
#line 457
  l1 = 1;
#line 458
  iw = 1;
#line 460
  k1 = 0;
  {
#line 460
  while (1) {
    while_continue: /* CIL Label */ ;
#line 460
    if (! (k1 < nf)) {
#line 460
      goto while_break;
    }
#line 461
    ip = *(ifac + (k1 + 2));
#line 462
    l2 = ip * l1;
#line 463
    ido = n / l2;
#line 464
    idl1 = ido * l1;
#line 465
    if (ip != 4) {
#line 465
      goto L103;
    }
#line 466
    ix2 = iw + ido;
#line 467
    ix3 = ix2 + ido;
#line 469
    if (na != 0) {
      {
#line 470
      dradb4(ido, l1, ch, c, (wa + iw) - 1, (wa + ix2) - 1, (wa + ix3) - 1);
      }
    } else {
      {
#line 472
      dradb4(ido, l1, c, ch, (wa + iw) - 1, (wa + ix2) - 1, (wa + ix3) - 1);
      }
    }
#line 473
    na = 1 - na;
#line 474
    goto L115;
    L103: 
#line 477
    if (ip != 2) {
#line 477
      goto L106;
    }
#line 479
    if (na != 0) {
      {
#line 480
      dradb2(ido, l1, ch, c, (wa + iw) - 1);
      }
    } else {
      {
#line 482
      dradb2(ido, l1, c, ch, (wa + iw) - 1);
      }
    }
#line 483
    na = 1 - na;
#line 484
    goto L115;
    L106: 
#line 487
    return;
    L115: 
#line 490
    l1 = l2;
#line 491
    iw += (ip - 1) * ido;
#line 460
    k1 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 494
  if (na == 0) {
#line 494
    return;
  }
#line 496
  i = 0;
  {
#line 496
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 496
    if (! (i < n)) {
#line 496
      goto while_break___0;
    }
#line 496
    *(c + i) = *(ch + i);
#line 496
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 497
  return;
}
}
#line 499 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/interface/smallft.c"
static void fdrfftb(int n , float *r , float *wsave , int *ifac ) 
{ 


  {
#line 500
  if (n == 1) {
#line 500
    return;
  }
  {
#line 501
  drftb1(n, r, wsave, wsave + n, ifac);
  }
#line 502
  return;
}
}
#line 504 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/interface/smallft.c"
void fft_forward(int n , float *buf , float *trigcache , int *splitcache ) 
{ 
  int flag ;
  void *tmp ;
  void *tmp___0 ;

  {
#line 505
  flag = 0;
#line 507
  if (! trigcache) {
#line 507
    goto _L;
  } else
#line 507
  if (! splitcache) {
    _L: /* CIL Label */ 
    {
#line 508
    tmp = calloc((size_t )(3 * n), (size_t )sizeof(float ));
#line 508
    trigcache = (float *)tmp;
#line 509
    tmp___0 = calloc((size_t )32, (size_t )sizeof(int ));
#line 509
    splitcache = (int *)tmp___0;
#line 510
    fdrffti(n, trigcache, splitcache);
#line 511
    flag = 1;
    }
  }
  {
#line 514
  fdrfftf(n, buf, trigcache, splitcache);
  }
#line 516
  if (flag) {
    {
#line 517
    free((void *)trigcache);
#line 518
    free((void *)splitcache);
    }
  }
#line 520
  return;
}
}
#line 522 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/interface/smallft.c"
void fft_backward(int n , float *buf , float *trigcache , int *splitcache ) 
{ 
  int i ;
  int flag ;
  void *tmp ;
  void *tmp___0 ;

  {
#line 524
  flag = 0;
#line 526
  if (! trigcache) {
#line 526
    goto _L;
  } else
#line 526
  if (! splitcache) {
    _L: /* CIL Label */ 
    {
#line 527
    tmp = calloc((size_t )(3 * n), (size_t )sizeof(float ));
#line 527
    trigcache = (float *)tmp;
#line 528
    tmp___0 = calloc((size_t )32, (size_t )sizeof(int ));
#line 528
    splitcache = (int *)tmp___0;
#line 529
    fdrffti(n, trigcache, splitcache);
#line 530
    flag = 1;
    }
  }
  {
#line 533
  fdrfftb(n, buf, trigcache, splitcache);
#line 535
  i = 0;
  }
  {
#line 535
  while (1) {
    while_continue: /* CIL Label */ ;
#line 535
    if (! (i < n)) {
#line 535
      goto while_break;
    }
#line 535
    *(buf + i) /= (float )n;
#line 535
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 537
  if (flag) {
    {
#line 538
    free((void *)trigcache);
#line 539
    free((void *)splitcache);
    }
  }
#line 541
  return;
}
}
#line 543 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/interface/smallft.c"
void fft_i(int n , float **trigcache , int **splitcache ) 
{ 
  void *tmp ;
  void *tmp___0 ;

  {
  {
#line 544
  tmp = calloc((size_t )(3 * n), (size_t )sizeof(float ));
#line 544
  *trigcache = (float *)tmp;
#line 545
  tmp___0 = calloc((size_t )32, (size_t )sizeof(int ));
#line 545
  *splitcache = (int *)tmp___0;
#line 546
  fdrffti(n, *trigcache, *splitcache);
  }
#line 547
  return;
}
}
#line 147 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 333
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 341
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
#line 109 "/usr/include/sys/select.h"
extern int select(int __nfds , fd_set * __restrict  __readfds , fd_set * __restrict  __writefds ,
                  fd_set * __restrict  __exceptfds , struct timeval * __restrict  __timeout ) ;
#line 471 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *malloc(size_t __size )  __attribute__((__malloc__)) ;
#line 543
extern  __attribute__((__nothrow__, __noreturn__)) void exit(int __status ) ;
#line 566
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1))) getenv)(char const   *__name ) ;
#line 357 "/usr/include/unistd.h"
extern ssize_t read(int __fd , void *__buf , size_t __nbytes ) ;
#line 456
extern int usleep(__useconds_t __useconds ) ;
#line 43 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2))) memcpy)(void * __restrict  __dest ,
                                                                                       void const   * __restrict  __src ,
                                                                                       size_t __n ) ;
#line 48
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2))) memmove)(void *__dest ,
                                                                                        void const   *__src ,
                                                                                        size_t __n ) ;
#line 64
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1))) memset)(void *__s ,
                                                                                     int __c ,
                                                                                     size_t __n ) ;
#line 67
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) memcmp)(void const   *__s1 ,
                                                                                     void const   *__s2 ,
                                                                                     size_t __n )  __attribute__((__pure__)) ;
#line 145
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) strncmp)(char const   *__s1 ,
                                                                                      char const   *__s2 ,
                                                                                      size_t __n )  __attribute__((__pure__)) ;
#line 411
extern  __attribute__((__nothrow__)) char *strerror(int __errnum ) ;
#line 43 "/usr/include/bits/errno.h"
extern  __attribute__((__nothrow__)) int *__errno_location(void)  __attribute__((__const__)) ;
#line 336 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) int clock_gettime(clockid_t __clock_id , struct timespec *__tp ) ;
#line 42 "/usr/include/sys/ioctl.h"
extern  __attribute__((__nothrow__)) int ioctl(int __fd , unsigned long __request 
                                               , ...) ;
#line 255 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) int sigprocmask(int __how , sigset_t const   * __restrict  __set ,
                                                     sigset_t * __restrict  __oset ) ;
#line 163 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/interface/cdda_interface.h"
static char *strerror_tr[12]  = 
#line 163 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/interface/cdda_interface.h"
  {      (char *)"Success",      (char *)"Error writing packet command to device",      (char *)"Error reading command from device",      (char *)"SCSI packet data underrun (too little data)", 
        (char *)"SCSI packet data overrun (too much data)",      (char *)"Illegal SCSI request (rejected by target)",      (char *)"Medium reading data from medium",      (char *)"Device busy", 
        (char *)"Device not ready",      (char *)"Target hardware fault",      (char *)"Unspecified error",      (char *)"Drive lost streaming"};
#line 113 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/interface/low_interface.h"
unsigned char *scsi_inquiry(cdrom_drive *d___0 ) ;
#line 114
int scsi_init_drive(cdrom_drive *d___0 ) ;
#line 15 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/interface/common_interface.h"
int FixupTOC(cdrom_drive *d___0 , int tracks ) ;
#line 16 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/interface/utils.h"
__inline static int32_t swap32(int32_t x ) 
{ 


  {
#line 17
  return ((int32_t )((((((u_int32_t )x & 255U) << 24) | (((u_int32_t )x & 65280U) << 8)) | (((u_int32_t )x & 16711680U) >> 8)) | (((u_int32_t )x & 4278190080U) >> 24)));
}
}
#line 30 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/interface/utils.h"
__inline static int32_t be32_to_cpu(int32_t x ) 
{ 
  int32_t tmp ;

  {
  {
#line 31
  tmp = swap32(x);
  }
#line 31
  return (tmp);
}
}
#line 104 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/interface/utils.h"
static void cderror___0(cdrom_drive *d___0 , char const   *s ) 
{ 
  size_t tmp ;

  {
#line 105
  if (s) {
#line 105
    if (d___0) {
      {
#line 107
      if (d___0->errordest == 1) {
#line 107
        goto case_1;
      }
#line 110
      if (d___0->errordest == 2) {
#line 110
        goto case_2;
      }
#line 114
      goto switch_default;
      case_1: /* CIL Label */ 
      {
#line 108
      tmp = strlen(s);
#line 108
      write(2, (void const   *)s, tmp);
      }
#line 109
      goto switch_break;
      case_2: /* CIL Label */ 
      {
#line 111
      d___0->errorbuf = catstring(d___0->errorbuf, s);
      }
#line 112
      goto switch_break;
      switch_default: /* CIL Label */ 
#line 115
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    }
  }
#line 118
  return;
}
}
#line 120 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/interface/utils.h"
static void cdmessage(cdrom_drive *d___0 , char const   *s ) 
{ 
  size_t tmp ;

  {
#line 121
  if (s) {
#line 121
    if (d___0) {
      {
#line 123
      if (d___0->messagedest == 1) {
#line 123
        goto case_1;
      }
#line 126
      if (d___0->messagedest == 2) {
#line 126
        goto case_2;
      }
#line 130
      goto switch_default;
      case_1: /* CIL Label */ 
      {
#line 124
      tmp = strlen(s);
#line 124
      write(2, (void const   *)s, tmp);
      }
#line 125
      goto switch_break;
      case_2: /* CIL Label */ 
      {
#line 127
      d___0->messagebuf = catstring(d___0->messagebuf, s);
      }
#line 128
      goto switch_break;
      switch_default: /* CIL Label */ 
#line 131
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    }
  }
#line 134
  return;
}
}
#line 15 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/interface/scsi_interface.c"
static int timed_ioctl(cdrom_drive *d___0 , int fd , int command , void *arg ) 
{ 
  struct timespec tv1 ;
  struct timespec tv2 ;
  int ret1 ;
  int tmp ;
  int ret2 ;
  int tmp___0 ;
  int ret3 ;
  int tmp___1 ;

  {
  {
#line 18
  tmp = clock_gettime((d___0->private)->clock, & tv1);
#line 18
  ret1 = tmp;
#line 19
  tmp___0 = ioctl(fd, (unsigned long )command, arg);
#line 19
  ret2 = tmp___0;
#line 20
  tmp___1 = clock_gettime((d___0->private)->clock, & tv2);
#line 20
  ret3 = tmp___1;
  }
#line 21
  if (ret1 < 0) {
#line 22
    (d___0->private)->last_milliseconds = -1;
  } else
#line 21
  if (ret3 < 0) {
#line 22
    (d___0->private)->last_milliseconds = -1;
  } else {
#line 24
    (d___0->private)->last_milliseconds = (int )((double )(tv2.tv_sec - tv1.tv_sec) * 1000. + (double )(tv2.tv_nsec - tv1.tv_nsec) / 1000000.);
  }
#line 26
  return (ret2);
}
}
#line 30 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/interface/scsi_interface.c"
static int Dummy(cdrom_drive *d___0 , int s ) 
{ 


  {
#line 31
  return (0);
}
}
#line 1 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/interface/drive_exceptions.h"
int scsi_enable_cdda(cdrom_drive *d___0 , int fAudioMode ) ;
#line 2
long scsi_read_mmc(cdrom_drive *d___0 , void *p___0 , long begin , long sectors ) ;
#line 3
long scsi_read_mmc2(cdrom_drive *d___0 , void *p___0 , long begin , long sectors ) ;
#line 4
long scsi_read_D4_10(cdrom_drive *d___0 , void *p___0 , long begin , long sectors ) ;
#line 5
long scsi_read_D4_12(cdrom_drive *d___0 , void *p___0 , long begin , long sectors ) ;
#line 6
long scsi_read_D8(cdrom_drive *d___0 , void *p___0 , long begin , long sectors ) ;
#line 7
long scsi_read_28(cdrom_drive *d___0 , void *p___0 , long begin , long sectors ) ;
#line 8
long scsi_read_A8(cdrom_drive *d___0 , void *p___0 , long begin , long sectors ) ;
#line 24 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/interface/drive_exceptions.h"
static exception atapi_list[5]  = {      {(char *)"SAMSUNG SCR-830 REV 2.09 2.09 ", 1, (unsigned char)0, & Dummy, & scsi_read_mmc2,
      0}, 
        {(char *)"Memorex CR-622", 1, (unsigned char)0, & Dummy, (long (*)(struct cdrom_drive * ,
                                                                        void * , long  ,
                                                                        long  ))((void *)0),
      0}, 
        {(char *)"SONY CD-ROM CDU-561", 0, (unsigned char)0, & Dummy, (long (*)(struct cdrom_drive * ,
                                                                             void * ,
                                                                             long  ,
                                                                             long  ))((void *)0),
      0}, 
        {(char *)"Chinon CD-ROM CDS-525", 0, (unsigned char)0, & Dummy, (long (*)(struct cdrom_drive * ,
                                                                               void * ,
                                                                               long  ,
                                                                               long  ))((void *)0),
      0}, 
        {(char *)((void *)0), 0, (unsigned char)0, (int (*)(struct cdrom_drive * , int  ))((void *)0),
      (long (*)(struct cdrom_drive * , void * , long  , long  ))((void *)0), 0}};
#line 33 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/interface/drive_exceptions.h"
static exception mmc_list[6]  = {      {(char *)"SAMSUNG SCR-830 REV 2.09 2.09 ", 1, (unsigned char)0, & Dummy, & scsi_read_mmc2,
      0}, 
        {(char *)"Memorex CR-622", 1, (unsigned char)0, & Dummy, (long (*)(struct cdrom_drive * ,
                                                                        void * , long  ,
                                                                        long  ))((void *)0),
      0}, 
        {(char *)"SONY CD-ROM CDU-561", 0, (unsigned char)0, & Dummy, (long (*)(struct cdrom_drive * ,
                                                                             void * ,
                                                                             long  ,
                                                                             long  ))((void *)0),
      0}, 
        {(char *)"Chinon CD-ROM CDS-525", 0, (unsigned char)0, & Dummy, (long (*)(struct cdrom_drive * ,
                                                                               void * ,
                                                                               long  ,
                                                                               long  ))((void *)0),
      0}, 
        {(char *)"KENWOOD CD-ROM UCR", -1, (unsigned char)0, (int (*)(struct cdrom_drive * ,
                                                                   int  ))((void *)0),
      & scsi_read_D8, 0}, 
        {(char *)((void *)0), 0, (unsigned char)0, (int (*)(struct cdrom_drive * , int  ))((void *)0),
      (long (*)(struct cdrom_drive * , void * , long  , long  ))((void *)0), 0}};
#line 43 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/interface/drive_exceptions.h"
static exception scsi_list[18]  = 
#line 43
  {      {(char *)"TOSHIBA", -1, (unsigned char)130, & scsi_enable_cdda, & scsi_read_28,
      0}, 
        {(char *)"IBM", -1, (unsigned char)130, & scsi_enable_cdda, & scsi_read_28, 0}, 
        {(char *)"DEC",
      -1, (unsigned char)130, & scsi_enable_cdda, & scsi_read_28, 0}, 
        {(char *)"IMS", -1, (unsigned char)0, & scsi_enable_cdda, & scsi_read_28, 1}, 
        {(char *)"KODAK",
      -1, (unsigned char)0, & scsi_enable_cdda, & scsi_read_28, 1}, 
        {(char *)"RICOH", -1, (unsigned char)0, & scsi_enable_cdda, & scsi_read_28, 1}, 
        {(char *)"HP",
      -1, (unsigned char)0, & scsi_enable_cdda, & scsi_read_28, 1}, 
        {(char *)"PHILIPS", -1, (unsigned char)0, & scsi_enable_cdda, & scsi_read_28,
      1}, 
        {(char *)"PLASMON", -1, (unsigned char)0, & scsi_enable_cdda, & scsi_read_28,
      1}, 
        {(char *)"GRUNDIG CDR100IPW", -1, (unsigned char)0, & scsi_enable_cdda, & scsi_read_28,
      1}, 
        {(char *)"MITSUMI CD-R ", -1, (unsigned char)0, & scsi_enable_cdda, & scsi_read_28,
      1}, 
        {(char *)"KENWOOD CD-ROM UCR", -1, (unsigned char)0, (int (*)(struct cdrom_drive * ,
                                                                   int  ))((void *)0),
      & scsi_read_D8, 0}, 
        {(char *)"YAMAHA", -1, (unsigned char)0, & scsi_enable_cdda, (long (*)(struct cdrom_drive * ,
                                                                            void * ,
                                                                            long  ,
                                                                            long  ))((void *)0),
      0}, 
        {(char *)"PLEXTOR", -1, (unsigned char)0, (int (*)(struct cdrom_drive * , int  ))((void *)0),
      (long (*)(struct cdrom_drive * , void * , long  , long  ))((void *)0), 0}, 
        {(char *)"SONY", -1, (unsigned char)0, (int (*)(struct cdrom_drive * , int  ))((void *)0),
      (long (*)(struct cdrom_drive * , void * , long  , long  ))((void *)0), 0}, 
        {(char *)"NEC", -1, (unsigned char)0, (int (*)(struct cdrom_drive * , int  ))((void *)0),
      & scsi_read_D4_10, 0}, 
        {(char *)"MATSHITA CD-R   CW-7501", -1, (unsigned char)0, (int (*)(struct cdrom_drive * ,
                                                                        int  ))((void *)0),
      & scsi_read_D4_12, -1}, 
        {(char *)((void *)0), 0, (unsigned char)0, (int (*)(struct cdrom_drive * , int  ))((void *)0),
      (long (*)(struct cdrom_drive * , void * , long  , long  ))((void *)0), 0}};
#line 35 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/interface/scsi_interface.c"
static void tweak_SG_buffer(cdrom_drive *d___0 ) 
{ 
  int table ;
  int reserved ;
  int cur ;
  int err ;
  char buffer[256] ;
  int tmp ;
  char *tmp___0 ;
  void *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;

  {
#line 46
  cur = 1;
  {
#line 47
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 48
    cur <<= 1;
#line 48
    reserved = cur * (1 << 9);
#line 49
    err = ioctl(d___0->cdda_fd, 8821UL, & reserved);
    }
#line 47
    if (err >= 0) {
#line 47
      if (! (cur * (1 << 9) < 1073741824)) {
#line 47
        goto while_break;
      }
    } else {
#line 47
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 51
  ioctl(d___0->cdda_fd, 8818UL, & reserved);
#line 55
  tmp = ioctl(d___0->cdda_fd, 8831UL, & table);
  }
#line 55
  if (tmp < 0) {
#line 56
    table = 1;
  }
  {
#line 58
  sprintf((char */* __restrict  */)(buffer), (char const   */* __restrict  */)"\tDMA scatter/gather table entries: %d\n\ttable entry size: %d bytes\n\tmaximum theoretical transfer: %d sectors\n",
          table, reserved, table * (reserved / 2352));
#line 62
  cdmessage(d___0, (char const   *)(buffer));
#line 64
  cur = reserved;
#line 78
  tmp___0 = getenv("CDDA_IGNORE_BUFSIZE_LIMIT");
  }
#line 78
  if (tmp___0) {
    {
#line 81
    cdmessage(d___0, "\tEnvironment variable CDDA_IGNORE_BUFSIZE_LIMIT set,\n\t\tforcing maximum possible sector size.  This can break\n\t\tspectacularly; use with caution!\n");
    }
  } else
#line 79
  if (cur > 65536) {
#line 79
    cur = 65536;
  } else {
#line 79
    cur = cur;
  }
  {
#line 85
  d___0->nsectors = cur / 2352;
#line 86
  d___0->bigbuff = (long )cur;
#line 88
  sprintf((char */* __restrict  */)(buffer), (char const   */* __restrict  */)"\tSetting default read size to %d sectors (%d bytes).\n\n",
          d___0->nsectors, d___0->nsectors * 2352);
  }
#line 91
  if (cur == 0) {
    {
#line 91
    exit(1);
    }
  }
  {
#line 93
  cdmessage(d___0, (char const   *)(buffer));
  }
#line 94
  return;
}
}
#line 96 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/interface/scsi_interface.c"
static void clear_garbage(cdrom_drive *d___0 ) 
{ 
  fd_set fdset ;
  struct timeval tv ;
  struct sg_header *sg_hd ;
  int flag ;
  int __d0 ;
  int __d1 ;
  int __d0___0 ;
  int __d1___0 ;
  int tmp ;
  char *__cil_tmp11 ;

  {
#line 99
  sg_hd = (d___0->private)->sg_hd;
#line 100
  flag = 0;
  {
#line 103
  while (1) {
    while_continue: /* CIL Label */ ;
#line 103
    __asm__  volatile   ("cld; rep; "
                         "stosl": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                         "1" (& fdset.__fds_bits[0]): "memory");
#line 103
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 104
  fdset.__fds_bits[(unsigned long )d___0->cdda_fd / (8UL * sizeof(unsigned long ))] = (__fd_mask )((unsigned long )fdset.__fds_bits[(unsigned long )d___0->cdda_fd / (8UL * sizeof(unsigned long ))] | (1UL << (unsigned long )d___0->cdda_fd % (8UL * sizeof(unsigned long ))));
#line 105
  tv.tv_sec = (__time_t )0;
#line 106
  tv.tv_usec = (__suseconds_t )0;
  {
#line 109
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 109
    tmp = select(d___0->cdda_fd + 1, (fd_set */* __restrict  */)(& fdset), (fd_set */* __restrict  */)((void *)0),
                 (fd_set */* __restrict  */)((void *)0), (struct timeval */* __restrict  */)(& tv));
    }
#line 109
    if (! (tmp == 1)) {
#line 109
      goto while_break___0;
    }
    {
#line 111
    sg_hd->twelve_byte = 0U;
#line 112
    sg_hd->result = 0;
#line 113
    sg_hd->reply_len = (int )sizeof(struct sg_header );
#line 114
    read(d___0->cdda_fd, (void *)sg_hd, (size_t )1);
    }
    {
#line 117
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 117
      __asm__  volatile   ("cld; rep; "
                           "stosl": "=c" (__d0___0), "=D" (__d1___0): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                           "1" (& fdset.__fds_bits[0]): "memory");
#line 117
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 118
    fdset.__fds_bits[(unsigned long )d___0->cdda_fd / (8UL * sizeof(unsigned long ))] = (__fd_mask )((unsigned long )fdset.__fds_bits[(unsigned long )d___0->cdda_fd / (8UL * sizeof(unsigned long ))] | (1UL << (unsigned long )d___0->cdda_fd % (8UL * sizeof(unsigned long ))));
#line 119
    tv.tv_sec = (__time_t )0;
#line 120
    tv.tv_usec = (__suseconds_t )0;
#line 121
    if (! flag) {
#line 121
      if (d___0->report_all) {
        {
#line 122
        cdmessage(d___0, "Clearing previously returned data from SCSI buffer\n");
        }
      }
    }
#line 123
    flag = 1;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 125
  return;
}
}
#line 127 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/interface/scsi_interface.c"
static int check_sbp_error(unsigned char const   status , unsigned char const   *sbp ) 
{ 
  char key ;
  char ASC ;
  char ASCQ ;
  int *tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;
  int *tmp___4 ;
  int *tmp___5 ;
  int *tmp___6 ;
  int *tmp___7 ;
  int *tmp___8 ;
  int *tmp___9 ;
  int *tmp___10 ;
  int *tmp___11 ;

  {
#line 129
  key = (char )((int const   )*(sbp + 2) & 15);
#line 130
  ASC = (char )*(sbp + 12);
#line 131
  ASCQ = (char )*(sbp + 13);
#line 133
  if ((int const   )status == 0) {
#line 133
    return (0);
  }
#line 134
  if ((int const   )status == 8) {
#line 134
    return (7);
  }
#line 136
  if (*(sbp + 0)) {
    {
#line 138
    if ((int )key == 0) {
#line 138
      goto case_0;
    }
#line 142
    if ((int )key == 1) {
#line 142
      goto case_1;
    }
#line 144
    if ((int )key == 2) {
#line 144
      goto case_2;
    }
#line 147
    if ((int )key == 3) {
#line 147
      goto case_3;
    }
#line 158
    if ((int )key == 4) {
#line 158
      goto case_4;
    }
#line 162
    if ((int )key == 5) {
#line 162
      goto case_5;
    }
#line 166
    goto switch_default;
    case_0: /* CIL Label */ 
    {
#line 139
    tmp___0 = __errno_location();
    }
#line 139
    if (*tmp___0 == 0) {
      {
#line 140
      tmp = __errno_location();
#line 140
      *tmp = 5;
      }
    }
#line 141
    return (10);
    case_1: /* CIL Label */ 
#line 143
    goto switch_break;
    case_2: /* CIL Label */ 
    {
#line 145
    tmp___1 = __errno_location();
#line 145
    *tmp___1 = 123;
    }
#line 146
    return (8);
    case_3: /* CIL Label */ 
#line 148
    if (((int )ASC == 12) & ((int )ASCQ == 9)) {
      {
#line 150
      tmp___3 = __errno_location();
      }
#line 150
      if (*tmp___3 == 0) {
        {
#line 151
        tmp___2 = __errno_location();
#line 151
        *tmp___2 = 5;
        }
      }
#line 152
      return (11);
    } else {
      {
#line 154
      tmp___5 = __errno_location();
      }
#line 154
      if (*tmp___5 == 0) {
        {
#line 155
        tmp___4 = __errno_location();
#line 155
        *tmp___4 = 5;
        }
      }
#line 156
      return (6);
    }
    case_4: /* CIL Label */ 
    {
#line 159
    tmp___7 = __errno_location();
    }
#line 159
    if (*tmp___7 == 0) {
      {
#line 160
      tmp___6 = __errno_location();
#line 160
      *tmp___6 = 5;
      }
    }
#line 161
    return (9);
    case_5: /* CIL Label */ 
    {
#line 163
    tmp___9 = __errno_location();
    }
#line 163
    if (*tmp___9 == 0) {
      {
#line 164
      tmp___8 = __errno_location();
#line 164
      *tmp___8 = 22;
      }
    }
#line 165
    return (5);
    switch_default: /* CIL Label */ 
    {
#line 167
    tmp___11 = __errno_location();
    }
#line 167
    if (*tmp___11 == 0) {
      {
#line 168
      tmp___10 = __errno_location();
#line 168
      *tmp___10 = 5;
      }
    }
#line 169
    return (10);
    switch_break: /* CIL Label */ ;
    }
  }
#line 172
  return (0);
}
}
#line 176 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/interface/scsi_interface.c"
static int sg2_handle_scsi_cmd(cdrom_drive *d___0 , unsigned char *cmd , unsigned int cmd_len ,
                               unsigned int in_size , unsigned int out_size , unsigned char bytefill ,
                               int bytecheck , unsigned char *sense_buffer ) 
{ 
  struct timespec tv1 ;
  struct timespec tv2 ;
  int tret1 ;
  int tret2 ;
  int status ;
  struct sg_header *sg_hd ;
  long writebytes ;
  fd_set fdset ;
  struct timeval tv ;
  int __d0 ;
  int __d1 ;
  int ret ;
  int tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;
  fd_set rset ;
  struct timeval tv___0 ;
  int __d0___0 ;
  int __d1___0 ;
  int ret___0 ;
  int tmp___4 ;
  int *tmp___5 ;
  int *tmp___6 ;
  int *tmp___7 ;
  int *tmp___8 ;
  long i ;
  long flag ;
  int *tmp___9 ;
  int *tmp___10 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;

  {
  {
#line 187
  status = 0;
#line 188
  sg_hd = (d___0->private)->sg_hd;
#line 189
  writebytes = (long )((sizeof(struct sg_header ) + (unsigned long )cmd_len) + (unsigned long )in_size);
#line 194
  clear_garbage(d___0);
#line 196
  memset((void *)sg_hd, 0, (size_t )sizeof(sg_hd));
#line 197
  memset((void *)sense_buffer, 0, (size_t )16);
#line 198
  memcpy((void */* __restrict  */)(d___0->private)->sg_buffer, (void const   */* __restrict  */)cmd,
         cmd_len + in_size);
#line 199
  sg_hd->twelve_byte = (unsigned int )(cmd_len == 12U);
#line 200
  sg_hd->result = 0;
#line 201
  sg_hd->reply_len = (int )(sizeof(struct sg_header ) + (unsigned long )out_size);
  }
#line 211
  if (bytecheck) {
#line 211
    if (out_size > in_size) {
      {
#line 212
      memset((void *)(((d___0->private)->sg_buffer + cmd_len) + in_size), (int )bytefill,
             out_size - in_size);
#line 215
      writebytes += (long )(out_size - in_size);
      }
    }
  }
  {
#line 226
  while (1) {
    while_continue: /* CIL Label */ ;
#line 226
    __asm__  volatile   ("cld; rep; "
                         "stosl": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                         "1" (& fdset.__fds_bits[0]): "memory");
#line 226
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 227
  fdset.__fds_bits[(unsigned long )d___0->cdda_fd / (8UL * sizeof(unsigned long ))] = (__fd_mask )((unsigned long )fdset.__fds_bits[(unsigned long )d___0->cdda_fd / (8UL * sizeof(unsigned long ))] | (1UL << (unsigned long )d___0->cdda_fd % (8UL * sizeof(unsigned long ))));
#line 228
  tv.tv_sec = (__time_t )60;
#line 231
  tv.tv_usec = (__suseconds_t )0;
  {
#line 233
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 234
    tmp = select(d___0->cdda_fd + 1, (fd_set */* __restrict  */)((void *)0), (fd_set */* __restrict  */)(& fdset),
                 (fd_set */* __restrict  */)((void *)0), (struct timeval */* __restrict  */)(& tv));
#line 234
    ret = tmp;
    }
#line 235
    if (ret > 0) {
#line 235
      goto while_break___0;
    }
#line 236
    if (ret < 0) {
      {
#line 236
      tmp___0 = __errno_location();
      }
#line 236
      if (*tmp___0 != 4) {
#line 236
        goto while_break___0;
      }
    }
#line 237
    if (ret == 0) {
      {
#line 238
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\nSCSI transport error: timeout waiting to write packet\n\n");
      }
#line 240
      return (1);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 245
  sigprocmask(0, (sigset_t const   */* __restrict  */)(& d___0->sigset), (sigset_t */* __restrict  */)((void *)0));
#line 246
  tret1 = clock_gettime((d___0->private)->clock, & tv1);
#line 247
  tmp___1 = __errno_location();
#line 247
  *tmp___1 = 0;
#line 248
  status = write(d___0->cdda_fd, (void const   *)sg_hd, (size_t )writebytes);
  }
#line 250
  if (status < 0) {
#line 250
    goto _L;
  } else
#line 250
  if ((long )status != writebytes) {
    _L: /* CIL Label */ 
    {
#line 251
    sigprocmask(1, (sigset_t const   */* __restrict  */)(& d___0->sigset), (sigset_t */* __restrict  */)((void *)0));
#line 252
    tmp___3 = __errno_location();
    }
#line 252
    if (*tmp___3 == 0) {
      {
#line 252
      tmp___2 = __errno_location();
#line 252
      *tmp___2 = 5;
      }
    }
#line 253
    return (1);
  }
  {
#line 266
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 266
    __asm__  volatile   ("cld; rep; "
                         "stosl": "=c" (__d0___0), "=D" (__d1___0): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                         "1" (& rset.__fds_bits[0]): "memory");
#line 266
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 267
  rset.__fds_bits[(unsigned long )d___0->cdda_fd / (8UL * sizeof(unsigned long ))] = (__fd_mask )((unsigned long )rset.__fds_bits[(unsigned long )d___0->cdda_fd / (8UL * sizeof(unsigned long ))] | (1UL << (unsigned long )d___0->cdda_fd % (8UL * sizeof(unsigned long ))));
#line 268
  tv___0.tv_sec = (__time_t )60;
#line 271
  tv___0.tv_usec = (__suseconds_t )0;
  {
#line 273
  while (1) {
    while_continue___2: /* CIL Label */ ;
    {
#line 274
    tmp___4 = select(d___0->cdda_fd + 1, (fd_set */* __restrict  */)(& rset), (fd_set */* __restrict  */)((void *)0),
                     (fd_set */* __restrict  */)((void *)0), (struct timeval */* __restrict  */)(& tv___0));
#line 274
    ret___0 = tmp___4;
    }
#line 275
    if (ret___0 < 0) {
      {
#line 275
      tmp___5 = __errno_location();
      }
#line 275
      if (*tmp___5 != 4) {
#line 275
        goto while_break___2;
      }
    }
#line 276
    if (ret___0 == 0) {
      {
#line 277
      sigprocmask(1, (sigset_t const   */* __restrict  */)(& d___0->sigset), (sigset_t */* __restrict  */)((void *)0));
#line 278
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\nSCSI transport error: timeout waiting to read packet\n\n");
      }
#line 280
      return (2);
    }
#line 282
    if (ret___0 > 0) {
#line 284
      if (((unsigned long )rset.__fds_bits[(unsigned long )d___0->cdda_fd / (8UL * sizeof(unsigned long ))] & (1UL << (unsigned long )d___0->cdda_fd % (8UL * sizeof(unsigned long )))) != 0UL) {
#line 284
        goto while_break___2;
      }
      {
#line 285
      sigprocmask(1, (sigset_t const   */* __restrict  */)(& d___0->sigset), (sigset_t */* __restrict  */)((void *)0));
#line 286
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\nSCSI transport: error reading packet\n\n");
      }
#line 287
      return (2);
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 292
  tret2 = clock_gettime((d___0->private)->clock, & tv2);
#line 293
  tmp___6 = __errno_location();
#line 293
  *tmp___6 = 0;
#line 294
  status = read(d___0->cdda_fd, (void *)sg_hd, (size_t )(sizeof(struct sg_header ) + (unsigned long )out_size));
#line 295
  sigprocmask(1, (sigset_t const   */* __restrict  */)(& d___0->sigset), (sigset_t */* __restrict  */)((void *)0));
#line 296
  memcpy((void */* __restrict  */)sense_buffer, (void const   */* __restrict  */)(sg_hd->sense_buffer),
         (size_t )16);
  }
#line 298
  if (status < 0) {
#line 298
    return (status);
  }
#line 300
  if ((unsigned long )status != sizeof(struct sg_header ) + (unsigned long )out_size) {
#line 300
    goto _L___0;
  } else
#line 300
  if (sg_hd->result) {
    _L___0: /* CIL Label */ 
    {
#line 301
    tmp___8 = __errno_location();
    }
#line 301
    if (*tmp___8 == 0) {
      {
#line 301
      tmp___7 = __errno_location();
#line 301
      *tmp___7 = 5;
      }
    }
#line 302
    return (2);
  }
  {
#line 305
  status = check_sbp_error((unsigned char const   )sg_hd->target_status, (unsigned char const   *)sense_buffer);
  }
#line 306
  if (status) {
#line 306
    return (status);
  }
#line 313
  if (bytecheck) {
#line 313
    if (in_size + cmd_len < out_size) {
#line 314
      flag = 0L;
#line 315
      i = (long )in_size;
      {
#line 315
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 315
        if (! (i < (long )out_size)) {
#line 315
          goto while_break___3;
        }
#line 316
        if ((int )*((d___0->private)->sg_buffer + i) != (int )bytefill) {
#line 317
          flag = 1L;
#line 318
          goto while_break___3;
        }
#line 315
        i ++;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 321
      if (! flag) {
        {
#line 322
        tmp___9 = __errno_location();
#line 322
        *tmp___9 = 22;
        }
#line 323
        return (5);
      }
    }
  }
  {
#line 327
  tmp___10 = __errno_location();
#line 327
  *tmp___10 = 0;
  }
#line 328
  if (tret1 < 0) {
#line 329
    (d___0->private)->last_milliseconds = -1;
  } else
#line 328
  if (tret2 < 0) {
#line 329
    (d___0->private)->last_milliseconds = -1;
  } else {
#line 331
    (d___0->private)->last_milliseconds = (int )((tv2.tv_sec - tv1.tv_sec) * 1000L + (tv2.tv_nsec - tv1.tv_nsec) / 1000000L);
  }
#line 333
  return (0);
}
}
#line 336 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/interface/scsi_interface.c"
static int sgio_handle_scsi_cmd(cdrom_drive *d___0 , unsigned char *cmd , unsigned int cmd_len ,
                                unsigned int in_size , unsigned int out_size , unsigned char bytefill ,
                                int bytecheck , unsigned char *sense ) 
{ 
  int status ;
  struct sg_io_hdr hdr ;
  int *tmp ;
  int *tmp___0 ;
  long i ;
  long flag ;
  int *tmp___1 ;
  int *tmp___2 ;

  {
  {
#line 345
  status = 0;
#line 348
  memset((void *)(& hdr), 0, (size_t )sizeof(hdr));
#line 349
  memset((void *)sense, 0, (size_t )sizeof(sense));
#line 350
  memcpy((void */* __restrict  */)(d___0->private)->sg_buffer, (void const   */* __restrict  */)(cmd + cmd_len),
         in_size);
#line 352
  hdr.cmdp = cmd;
#line 353
  hdr.cmd_len = (unsigned char )cmd_len;
#line 354
  hdr.sbp = sense;
#line 355
  hdr.mx_sb_len = (unsigned char)16;
#line 356
  hdr.timeout = 50000U;
#line 357
  hdr.interface_id = 'S';
#line 358
  hdr.dxferp = (void *)(d___0->private)->sg_buffer;
#line 359
  hdr.flags = 1U;
  }
#line 362
  if (bytecheck) {
#line 362
    if (out_size > in_size) {
      {
#line 363
      memset(hdr.dxferp + in_size, (int )bytefill, out_size - in_size);
      }
    }
  }
#line 365
  if (in_size) {
    {
#line 366
    hdr.dxfer_len = in_size;
#line 367
    hdr.dxfer_direction = -2;
#line 369
    tmp = __errno_location();
#line 369
    *tmp = 0;
#line 370
    status = ioctl(d___0->ioctl_fd, 8837UL, & hdr);
    }
#line 371
    if (status >= 0) {
#line 371
      if (hdr.status) {
        {
#line 372
        status = check_sbp_error((unsigned char const   )hdr.status, (unsigned char const   *)hdr.sbp);
        }
#line 373
        if (status) {
#line 373
          return (status);
        }
      }
    }
#line 375
    if (status < 0) {
#line 375
      return (1);
    }
  }
#line 378
  if ((unsigned int )(! in_size) | out_size) {
#line 379
    hdr.dxfer_len = out_size;
#line 381
    if (bytecheck) {
#line 381
      if (d___0->interface != 4) {
#line 382
        if (out_size) {
#line 382
          hdr.dxfer_direction = -4;
        } else {
#line 382
          hdr.dxfer_direction = -1;
        }
      } else {
#line 381
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 384
    if (out_size) {
#line 384
      hdr.dxfer_direction = -3;
    } else {
#line 384
      hdr.dxfer_direction = -1;
    }
    {
#line 386
    tmp___0 = __errno_location();
#line 386
    *tmp___0 = 0;
#line 387
    status = timed_ioctl(d___0, d___0->ioctl_fd, 8837, (void *)(& hdr));
    }
#line 388
    if (status >= 0) {
#line 388
      if (hdr.status) {
        {
#line 389
        status = check_sbp_error((unsigned char const   )hdr.status, (unsigned char const   *)hdr.sbp);
        }
#line 390
        if (status) {
#line 390
          return (status);
        }
      }
    }
#line 392
    if (status < 0) {
#line 392
      return (status);
    }
  }
#line 400
  if (bytecheck) {
#line 400
    if (in_size < out_size) {
#line 401
      flag = 0L;
#line 402
      i = (long )in_size;
      {
#line 402
      while (1) {
        while_continue: /* CIL Label */ ;
#line 402
        if (! (i < (long )out_size)) {
#line 402
          goto while_break;
        }
#line 403
        if ((int )*((d___0->private)->sg_buffer + i) != (int )bytefill) {
#line 404
          flag = 1L;
#line 405
          goto while_break;
        }
#line 402
        i ++;
      }
      while_break: /* CIL Label */ ;
      }
#line 408
      if (! flag) {
        {
#line 409
        tmp___1 = __errno_location();
#line 409
        *tmp___1 = 22;
        }
#line 410
        return (5);
      }
    }
  }
  {
#line 417
  tmp___2 = __errno_location();
#line 417
  *tmp___2 = 0;
  }
#line 418
  return (0);
}
}
#line 421 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/interface/scsi_interface.c"
static int handle_scsi_cmd(cdrom_drive *d___0 , unsigned char *cmd , unsigned int cmd_len ,
                           unsigned int in_size , unsigned int out_size , unsigned char bytefill ,
                           int bytecheck , unsigned char *sense ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 430
  if (d___0->interface == 3) {
    {
#line 431
    tmp = sgio_handle_scsi_cmd(d___0, cmd, cmd_len, in_size, out_size, bytefill, bytecheck,
                               sense);
    }
#line 431
    return (tmp);
  } else
#line 430
  if (d___0->interface == 4) {
    {
#line 431
    tmp = sgio_handle_scsi_cmd(d___0, cmd, cmd_len, in_size, out_size, bytefill, bytecheck,
                               sense);
    }
#line 431
    return (tmp);
  }
  {
#line 432
  tmp___0 = sg2_handle_scsi_cmd(d___0, cmd, cmd_len, in_size, out_size, bytefill,
                                bytecheck, sense);
  }
#line 432
  return (tmp___0);
}
}
#line 436 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/interface/scsi_interface.c"
static int test_unit_ready(cdrom_drive *d___0 ) 
{ 
  unsigned char sense[16] ;
  unsigned char key ;
  unsigned char ASC ;
  unsigned char ASCQ ;
  unsigned char cmd[6] ;
  void *__cil_tmp7 ;
  void *__cil_tmp8 ;

  {
  {
#line 439
  cmd[0] = (unsigned char)0;
#line 439
  cmd[1] = (unsigned char)0;
#line 439
  cmd[2] = (unsigned char)0;
#line 439
  cmd[3] = (unsigned char)0;
#line 439
  cmd[4] = (unsigned char)0;
#line 439
  cmd[5] = (unsigned char)0;
#line 446
  handle_scsi_cmd(d___0, cmd, 6U, 0U, 56U, (unsigned char)0, 0, sense);
#line 448
  key = (unsigned char )((int )*((d___0->private)->sg_buffer + 2) & 15);
#line 449
  ASC = *((d___0->private)->sg_buffer + 12);
#line 450
  ASCQ = *((d___0->private)->sg_buffer + 13);
  }
#line 452
  if ((int )key == 2) {
#line 452
    if ((int )ASC == 4) {
#line 452
      if ((int )ASCQ == 1) {
#line 452
        return (0);
      }
    }
  }
#line 453
  return (1);
}
}
#line 456 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/interface/scsi_interface.c"
static void reset_scsi(cdrom_drive *d___0 ) 
{ 
  int arg ;
  int tries ;
  int tmp ;
  int tmp___0 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
  {
#line 457
  tries = 0;
#line 458
  (*(d___0->enable_cdda))(d___0, 0);
#line 460
  cdmessage(d___0, "sending SG SCSI reset... ");
#line 461
  tmp = ioctl(d___0->cdda_fd, 8836UL, & arg);
  }
#line 461
  if (tmp) {
    {
#line 462
    cdmessage(d___0, "FAILED: EBUSY\n");
    }
  } else {
    {
#line 464
    cdmessage(d___0, "OK\n");
    }
  }
  {
#line 466
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 467
    tmp___0 = test_unit_ready(d___0);
    }
#line 467
    if (tmp___0) {
#line 467
      goto while_break;
    }
    {
#line 468
    tries ++;
#line 469
    usleep((__useconds_t )10);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 472
  (*(d___0->enable_cdda))(d___0, 1);
  }
#line 473
  return;
}
}
#line 475 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/interface/scsi_interface.c"
static int mode_sense_atapi(cdrom_drive *d___0 , int size , int page ) 
{ 
  unsigned char sense[16] ;
  unsigned char cmd[10] ;
  int tmp ;
  unsigned char *b ;
  void *__cil_tmp8 ;
  void *__cil_tmp9 ;

  {
  {
#line 477
  cmd[0] = (unsigned char)90;
#line 477
  cmd[1] = (unsigned char)0;
#line 477
  cmd[2] = (unsigned char)0;
#line 477
  cmd[3] = (unsigned char)0;
#line 477
  cmd[4] = (unsigned char)0;
#line 477
  cmd[5] = (unsigned char)0;
#line 477
  cmd[6] = (unsigned char)0;
#line 477
  cmd[7] = (unsigned char)0;
#line 477
  cmd[8] = (unsigned char)0;
#line 477
  cmd[9] = (unsigned char)0;
#line 488
  cmd[1] = (unsigned char )(d___0->lun << 5);
#line 489
  cmd[2] = (unsigned char )(63 & page);
#line 490
  cmd[8] = (unsigned char )(size + 4);
#line 492
  tmp = handle_scsi_cmd(d___0, cmd, 10U, 0U, (unsigned int )(size + 4), (unsigned char )'\377',
                        1, sense);
  }
#line 492
  if (tmp) {
#line 492
    return (1);
  }
#line 495
  b = (d___0->private)->sg_buffer;
#line 496
  if (*(b + 0)) {
#line 496
    return (1);
  }
#line 497
  if (*(b + 6)) {
#line 497
    return (1);
  }
  {
#line 499
  *(b + 0) = (unsigned char )((int )*(b + 1) - 3);
#line 500
  *(b + 1) = *(b + 2);
#line 501
  *(b + 2) = *(b + 3);
#line 502
  *(b + 3) = *(b + 7);
#line 504
  memmove((void *)(b + 4), (void const   *)(b + 8), (size_t )(size - 4));
  }
#line 506
  return (0);
}
}
#line 511 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/interface/scsi_interface.c"
static int mode_sense_scsi(cdrom_drive *d___0 , int size , int page ) 
{ 
  unsigned char sense[16] ;
  unsigned char cmd[6] ;
  int tmp ;
  void *__cil_tmp7 ;
  void *__cil_tmp8 ;

  {
  {
#line 513
  cmd[0] = (unsigned char)26;
#line 513
  cmd[1] = (unsigned char)0;
#line 513
  cmd[2] = (unsigned char)0;
#line 513
  cmd[3] = (unsigned char)0;
#line 513
  cmd[4] = (unsigned char)0;
#line 513
  cmd[5] = (unsigned char)0;
#line 520
  cmd[1] = (unsigned char )(d___0->lun << 5);
#line 521
  cmd[2] = (unsigned char )(63 & page);
#line 522
  cmd[4] = (unsigned char )size;
#line 524
  tmp = handle_scsi_cmd(d___0, cmd, 6U, 0U, (unsigned int )size, (unsigned char )'\377',
                        1, sense);
  }
#line 524
  if (tmp) {
#line 524
    return (1);
  }
#line 529
  return (0);
}
}
#line 532 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/interface/scsi_interface.c"
static int mode_sense(cdrom_drive *d___0 , int size , int page ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 533
  if (d___0->is_atapi) {
    {
#line 534
    tmp = mode_sense_atapi(d___0, size, page);
    }
#line 534
    return (tmp);
  }
  {
#line 535
  tmp___0 = mode_sense_scsi(d___0, size, page);
  }
#line 535
  return (tmp___0);
}
}
#line 542 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/interface/scsi_interface.c"
static int mode_select(cdrom_drive *d___0 , int density , int secsize ) 
{ 
  unsigned char sense[16] ;
  unsigned char cmd[26] ;
  unsigned char *mode ;
  int tmp ;
  unsigned char cmd___0[18] ;
  unsigned char *mode___0 ;
  int tmp___0 ;
  void *__cil_tmp11 ;
  void *__cil_tmp12 ;
  void *__cil_tmp13 ;

  {
#line 545
  if (d___0->is_atapi) {
    {
#line 546
    cmd[0] = (unsigned char)85;
#line 546
    cmd[1] = (unsigned char)16;
#line 546
    cmd[2] = (unsigned char)0;
#line 546
    cmd[3] = (unsigned char)0;
#line 546
    cmd[4] = (unsigned char)0;
#line 546
    cmd[5] = (unsigned char)0;
#line 546
    cmd[6] = (unsigned char)0;
#line 546
    cmd[7] = (unsigned char)0;
#line 546
    cmd[8] = (unsigned char)16;
#line 546
    cmd[9] = (unsigned char)0;
#line 546
    cmd[10] = (unsigned char)0;
#line 546
    cmd[11] = (unsigned char)0;
#line 546
    cmd[12] = (unsigned char)0;
#line 546
    cmd[13] = (unsigned char)0;
#line 546
    cmd[14] = (unsigned char)0;
#line 546
    cmd[15] = (unsigned char)0;
#line 546
    cmd[16] = (unsigned char)0;
#line 546
    cmd[17] = (unsigned char)8;
#line 546
    cmd[18] = (unsigned char)0;
#line 546
    cmd[19] = (unsigned char)0;
#line 546
    cmd[20] = (unsigned char)0;
#line 546
    cmd[21] = (unsigned char)0;
#line 546
    cmd[22] = (unsigned char)0;
#line 546
    cmd[23] = (unsigned char)0;
#line 546
    cmd[24] = (unsigned char)0;
#line 546
    cmd[25] = (unsigned char)0;
#line 566
    mode = cmd + 18;
#line 569
    *(mode + 0) = (unsigned char )density;
#line 570
    *(mode + 6) = (unsigned char )(secsize >> 8);
#line 571
    *(mode + 7) = (unsigned char )(secsize & 255);
#line 574
    tmp = handle_scsi_cmd(d___0, cmd, 10U, 16U, 0U, (unsigned char)0, 0, sense);
    }
#line 574
    return (tmp);
  } else {
    {
#line 577
    cmd___0[0] = (unsigned char)21;
#line 577
    cmd___0[1] = (unsigned char)16;
#line 577
    cmd___0[2] = (unsigned char)0;
#line 577
    cmd___0[3] = (unsigned char)0;
#line 577
    cmd___0[4] = (unsigned char)12;
#line 577
    cmd___0[5] = (unsigned char)0;
#line 577
    cmd___0[6] = (unsigned char)0;
#line 577
    cmd___0[7] = (unsigned char)0;
#line 577
    cmd___0[8] = (unsigned char)0;
#line 577
    cmd___0[9] = (unsigned char)8;
#line 577
    cmd___0[10] = (unsigned char)0;
#line 577
    cmd___0[11] = (unsigned char)0;
#line 577
    cmd___0[12] = (unsigned char)0;
#line 577
    cmd___0[13] = (unsigned char)0;
#line 577
    cmd___0[14] = (unsigned char)0;
#line 577
    cmd___0[15] = (unsigned char)0;
#line 577
    cmd___0[16] = (unsigned char)0;
#line 577
    cmd___0[17] = (unsigned char)0;
#line 591
    mode___0 = cmd___0 + 10;
#line 594
    *(mode___0 + 0) = (unsigned char )density;
#line 595
    *(mode___0 + 6) = (unsigned char )(secsize >> 8);
#line 596
    *(mode___0 + 7) = (unsigned char )(secsize & 255);
#line 599
    tmp___0 = handle_scsi_cmd(d___0, cmd___0, 6U, 12U, 0U, (unsigned char)0, 0, sense);
    }
#line 599
    return (tmp___0);
  }
}
}
#line 604 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/interface/scsi_interface.c"
static unsigned int get_orig_sectorsize(cdrom_drive *d___0 ) 
{ 
  int tmp ;
  unsigned int tmp___0 ;

  {
  {
#line 605
  tmp = mode_sense(d___0, 12, 1);
  }
#line 605
  if (tmp) {
#line 605
    return (4294967295U);
  }
#line 607
  d___0->orgdens = *((d___0->private)->sg_buffer + 4);
#line 608
  tmp___0 = (unsigned int )(((int )*((d___0->private)->sg_buffer + 10) << 8) + (int )*((d___0->private)->sg_buffer + 11));
#line 608
  d___0->orgsize = tmp___0;
#line 608
  return (tmp___0);
}
}
#line 612 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/interface/scsi_interface.c"
static int set_sectorsize(cdrom_drive *d___0 , unsigned int secsize ) 
{ 
  int tmp ;

  {
  {
#line 613
  tmp = mode_select(d___0, (int )d___0->orgdens, (int )secsize);
  }
#line 613
  return (tmp);
}
}
#line 617 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/interface/scsi_interface.c"
int scsi_enable_cdda(cdrom_drive *d___0 , int fAudioMode ) 
{ 
  int tmp ;
  int tmp___0 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
#line 618
  if (fAudioMode) {
    {
#line 619
    tmp = mode_select(d___0, (int )d___0->density, 2352);
    }
#line 619
    if (tmp) {
#line 620
      if (d___0->error_retry) {
        {
#line 621
        cderror___0(d___0, "001: Unable to set CDROM to read audio mode\n");
        }
      }
#line 622
      return (-1);
    }
  } else {
    {
#line 625
    tmp___0 = mode_select(d___0, (int )d___0->orgdens, (int )d___0->orgsize);
    }
#line 625
    if (tmp___0) {
#line 626
      if (d___0->error_retry) {
        {
#line 627
        cderror___0(d___0, "001: Unable to set CDROM to read audio mode\n");
        }
      }
#line 628
      return (-1);
    }
  }
#line 631
  return (0);
}
}
#line 650 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/interface/scsi_interface.c"
static int scsi_read_toc(cdrom_drive *d___0 ) 
{ 
  int i ;
  int first ;
  int last___0 ;
  unsigned int tracks ;
  unsigned char sense[16] ;
  unsigned char cmd[10] ;
  int tmp ;
  char __constr_expr_0[10] ;
  int tmp___0 ;
  scsi_TOC *toc ;
  char __constr_expr_1[10] ;
  int tmp___1 ;
  scsi_TOC *toc___0 ;
  void *__cil_tmp15 ;
  void *__cil_tmp16 ;
  void *__cil_tmp17 ;
  void *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;

  {
  {
#line 659
  cmd[0] = (unsigned char)67;
#line 659
  cmd[1] = (unsigned char)0;
#line 659
  cmd[2] = (unsigned char)0;
#line 659
  cmd[3] = (unsigned char)0;
#line 659
  cmd[4] = (unsigned char)0;
#line 659
  cmd[5] = (unsigned char)0;
#line 659
  cmd[6] = (unsigned char)1;
#line 659
  cmd[7] = (unsigned char)0;
#line 659
  cmd[8] = (unsigned char)12;
#line 659
  cmd[9] = (unsigned char)0;
#line 660
  cmd[1] = (unsigned char )(d___0->lun << 5);
#line 662
  tmp = handle_scsi_cmd(d___0, cmd, 10U, 0U, 12U, (unsigned char )'\377', 1, sense);
  }
#line 662
  if (tmp) {
    {
#line 663
    cderror___0(d___0, "004: Unable to read table of contents header\n");
    }
#line 664
    return (-4);
  }
#line 667
  first = (int )*((d___0->private)->sg_buffer + 2);
#line 668
  last___0 = (int )*((d___0->private)->sg_buffer + 3);
#line 669
  tracks = (unsigned int )((last___0 - first) + 1);
#line 671
  if (last___0 > 100) {
    {
#line 672
    cderror___0(d___0, "003: CDROM reporting illegal number of tracks\n");
    }
#line 673
    return (-3);
  } else
#line 671
  if (first > 100) {
    {
#line 672
    cderror___0(d___0, "003: CDROM reporting illegal number of tracks\n");
    }
#line 673
    return (-3);
  } else
#line 671
  if (last___0 < 0) {
    {
#line 672
    cderror___0(d___0, "003: CDROM reporting illegal number of tracks\n");
    }
#line 673
    return (-3);
  } else
#line 671
  if (first < 0) {
    {
#line 672
    cderror___0(d___0, "003: CDROM reporting illegal number of tracks\n");
    }
#line 673
    return (-3);
  }
#line 676
  i = first;
  {
#line 676
  while (1) {
    while_continue: /* CIL Label */ ;
#line 676
    if (! (i <= last___0)) {
#line 676
      goto while_break;
    }
    {
#line 677
    __constr_expr_0[0] = (char)67;
#line 677
    __constr_expr_0[1] = (char)0;
#line 677
    __constr_expr_0[2] = (char)0;
#line 677
    __constr_expr_0[3] = (char)0;
#line 677
    __constr_expr_0[4] = (char)0;
#line 677
    __constr_expr_0[5] = (char)0;
#line 677
    __constr_expr_0[6] = (char)0;
#line 677
    __constr_expr_0[7] = (char)0;
#line 677
    __constr_expr_0[8] = (char)12;
#line 677
    __constr_expr_0[9] = (char)0;
#line 677
    memcpy((void */* __restrict  */)(cmd), (void const   */* __restrict  */)(__constr_expr_0),
           (size_t )10);
#line 678
    cmd[1] = (unsigned char )(d___0->lun << 5);
#line 679
    cmd[6] = (unsigned char )i;
#line 681
    tmp___0 = handle_scsi_cmd(d___0, cmd, 10U, 0U, 12U, (unsigned char )'\377', 1,
                              sense);
    }
#line 681
    if (tmp___0) {
      {
#line 682
      cderror___0(d___0, "005: Unable to read table of contents entry\n");
      }
#line 683
      return (-5);
    }
#line 686
    toc = (scsi_TOC *)((d___0->private)->sg_buffer + 4);
#line 688
    d___0->disc_toc[i - first].bFlags = toc->bFlags;
#line 689
    d___0->disc_toc[i - first].bTrack = (unsigned char )i;
#line 690
    d___0->disc_toc[i - first].dwStartSector = d___0->adjust_ssize * (((((int )toc->start_MSB << 24) | ((int )toc->start_1 << 16)) | ((int )toc->start_2 << 8)) | (int )toc->start_LSB);
#line 676
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 698
  __constr_expr_1[0] = (char)67;
#line 698
  __constr_expr_1[1] = (char)0;
#line 698
  __constr_expr_1[2] = (char)0;
#line 698
  __constr_expr_1[3] = (char)0;
#line 698
  __constr_expr_1[4] = (char)0;
#line 698
  __constr_expr_1[5] = (char)0;
#line 698
  __constr_expr_1[6] = (char)0;
#line 698
  __constr_expr_1[7] = (char)0;
#line 698
  __constr_expr_1[8] = (char)12;
#line 698
  __constr_expr_1[9] = (char)0;
#line 698
  memcpy((void */* __restrict  */)(cmd), (void const   */* __restrict  */)(__constr_expr_1),
         (size_t )10);
#line 699
  cmd[1] = (unsigned char )(d___0->lun << 5);
#line 700
  cmd[6] = (unsigned char)170;
#line 702
  tmp___1 = handle_scsi_cmd(d___0, cmd, 10U, 0U, 12U, (unsigned char )'\377', 1, sense);
  }
#line 702
  if (tmp___1) {
    {
#line 703
    cderror___0(d___0, "002: Unable to read table of contents lead-out\n");
    }
#line 704
    return (-2);
  }
  {
#line 707
  toc___0 = (scsi_TOC *)((d___0->private)->sg_buffer + 4);
#line 709
  d___0->disc_toc[i - first].bFlags = toc___0->bFlags;
#line 710
  d___0->disc_toc[i - first].bTrack = (unsigned char)170;
#line 711
  d___0->disc_toc[i - first].dwStartSector = d___0->adjust_ssize * (((((int )toc___0->start_MSB << 24) | ((int )toc___0->start_1 << 16)) | ((int )toc___0->start_2 << 8)) | (int )toc___0->start_LSB);
#line 718
  d___0->cd_extra = FixupTOC(d___0, (int )(tracks + 1U));
  }
#line 719
  return ((int )tracks);
}
}
#line 724 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/interface/scsi_interface.c"
static int scsi_read_toc2(cdrom_drive *d___0 ) 
{ 
  u_int32_t foo ;
  u_int32_t bar ;
  int i ;
  unsigned int tracks ;
  unsigned char cmd[10] ;
  unsigned char sense[16] ;
  int tmp ;
  char __constr_expr_2[10] ;
  int tmp___0 ;
  int32_t tmp___1 ;
  int32_t tmp___2 ;
  void *__cil_tmp13 ;
  void *__cil_tmp14 ;
  void *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;

  {
  {
#line 730
  cmd[0] = (unsigned char)229;
#line 730
  cmd[1] = (unsigned char)0;
#line 730
  cmd[2] = (unsigned char)0;
#line 730
  cmd[3] = (unsigned char)0;
#line 730
  cmd[4] = (unsigned char)0;
#line 730
  cmd[5] = (unsigned char)0;
#line 730
  cmd[6] = (unsigned char)0;
#line 730
  cmd[7] = (unsigned char)0;
#line 730
  cmd[8] = (unsigned char)0;
#line 730
  cmd[9] = (unsigned char)0;
#line 732
  cmd[5] = (unsigned char)1;
#line 733
  cmd[8] = (unsigned char)255;
#line 735
  tmp = handle_scsi_cmd(d___0, cmd, 10U, 0U, 256U, (unsigned char )'\377', 1, sense);
  }
#line 735
  if (tmp) {
    {
#line 736
    cderror___0(d___0, "004: Unable to read table of contents header\n");
    }
#line 737
    return (-4);
  }
#line 741
  tracks = (unsigned int )*((d___0->private)->sg_buffer + 1);
#line 742
  if (tracks > 100U) {
    {
#line 743
    cderror___0(d___0, "003: CDROM reporting illegal number of tracks\n");
    }
#line 744
    return (-3);
  }
#line 747
  i = 0;
  {
#line 747
  while (1) {
    while_continue: /* CIL Label */ ;
#line 747
    if (! ((unsigned int )i < tracks)) {
#line 747
      goto while_break;
    }
    {
#line 748
    __constr_expr_2[0] = (char)-27;
#line 748
    __constr_expr_2[1] = (char)0;
#line 748
    __constr_expr_2[2] = (char)0;
#line 748
    __constr_expr_2[3] = (char)0;
#line 748
    __constr_expr_2[4] = (char)0;
#line 748
    __constr_expr_2[5] = (char)0;
#line 748
    __constr_expr_2[6] = (char)0;
#line 748
    __constr_expr_2[7] = (char)0;
#line 748
    __constr_expr_2[8] = (char)0;
#line 748
    __constr_expr_2[9] = (char)0;
#line 748
    memcpy((void */* __restrict  */)(cmd), (void const   */* __restrict  */)(__constr_expr_2),
           (size_t )10);
#line 749
    cmd[5] = (unsigned char )(i + 1);
#line 750
    cmd[8] = (unsigned char)255;
#line 752
    tmp___0 = handle_scsi_cmd(d___0, cmd, 10U, 0U, 256U, (unsigned char )'\377', 1,
                              sense);
    }
#line 752
    if (tmp___0) {
      {
#line 753
      cderror___0(d___0, "005: Unable to read table of contents entry\n");
      }
#line 754
      return (-5);
    }
#line 757
    d___0->disc_toc[i].bFlags = *((d___0->private)->sg_buffer + 10);
#line 758
    d___0->disc_toc[i].bTrack = (unsigned char )(i + 1);
#line 760
    d___0->disc_toc[i].dwStartSector = d___0->adjust_ssize * (((((int )((signed char )*((d___0->private)->sg_buffer + 2)) << 24) | ((int )*((d___0->private)->sg_buffer + 3) << 16)) | ((int )*((d___0->private)->sg_buffer + 4) << 8)) | (int )*((d___0->private)->sg_buffer + 5));
#line 747
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 767
  d___0->disc_toc[i].bFlags = (unsigned char)0;
#line 768
  d___0->disc_toc[i].bTrack = (unsigned char )(i + 1);
#line 769
  memcpy((void */* __restrict  */)(& foo), (void const   */* __restrict  */)((d___0->private)->sg_buffer + 2),
         (size_t )4);
#line 770
  memcpy((void */* __restrict  */)(& bar), (void const   */* __restrict  */)((d___0->private)->sg_buffer + 6),
         (size_t )4);
#line 771
  tmp___1 = be32_to_cpu((int32_t )foo);
#line 771
  tmp___2 = be32_to_cpu((int32_t )bar);
#line 771
  d___0->disc_toc[i].dwStartSector = d___0->adjust_ssize * (tmp___1 + tmp___2);
#line 774
  d___0->disc_toc[i].dwStartSector = d___0->adjust_ssize * ((((((int )((signed char )*((d___0->private)->sg_buffer + 2)) << 24) | ((int )*((d___0->private)->sg_buffer + 3) << 16)) | ((int )*((d___0->private)->sg_buffer + 4) << 8)) | (int )*((d___0->private)->sg_buffer + 5)) + (((((int )((signed char )*((d___0->private)->sg_buffer + 6)) << 24) | ((int )*((d___0->private)->sg_buffer + 7) << 16)) | ((int )*((d___0->private)->sg_buffer + 8) << 8)) | (int )*((d___0->private)->sg_buffer + 9)));
#line 786
  d___0->cd_extra = FixupTOC(d___0, (int )(tracks + 1U));
  }
#line 787
  return ((int )tracks);
}
}
#line 790 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/interface/scsi_interface.c"
static int scsi_set_speed(cdrom_drive *d___0 , int speed ) 
{ 
  unsigned char cmd[12] ;
  unsigned char sense[16] ;
  int tmp ;
  void *__cil_tmp6 ;
  void *__cil_tmp7 ;

  {
#line 791
  cmd[0] = (unsigned char)187;
#line 791
  cmd[1] = (unsigned char)0;
#line 791
  cmd[2] = (unsigned char)0;
#line 791
  cmd[3] = (unsigned char)0;
#line 791
  cmd[4] = (unsigned char)255;
#line 791
  cmd[5] = (unsigned char)255;
#line 791
  cmd[6] = (unsigned char)0;
#line 791
  cmd[7] = (unsigned char)0;
#line 791
  cmd[8] = (unsigned char)0;
#line 791
  cmd[9] = (unsigned char)0;
#line 791
  cmd[10] = (unsigned char)0;
#line 791
  cmd[11] = (unsigned char)0;
#line 794
  if (speed >= 0) {
#line 795
    speed = ((speed * 44100) * 4) / 1024;
  } else {
#line 797
    speed = -1;
  }
  {
#line 798
  cmd[2] = (unsigned char )((speed >> 8) & 255);
#line 799
  cmd[3] = (unsigned char )(speed & 255);
#line 800
  tmp = handle_scsi_cmd(d___0, cmd, 12U, 0U, 0U, (unsigned char)0, 0, sense);
  }
#line 800
  return (tmp);
}
}
#line 805 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/interface/scsi_interface.c"
static int i_read_28(cdrom_drive *d___0 , void *p___0 , long begin , long sectors ,
                     unsigned char *sense ) 
{ 
  int ret ;
  unsigned char cmd[10] ;
  void *__cil_tmp8 ;

  {
#line 807
  cmd[0] = (unsigned char)40;
#line 807
  cmd[1] = (unsigned char)0;
#line 807
  cmd[2] = (unsigned char)0;
#line 807
  cmd[3] = (unsigned char)0;
#line 807
  cmd[4] = (unsigned char)0;
#line 807
  cmd[5] = (unsigned char)0;
#line 807
  cmd[6] = (unsigned char)0;
#line 807
  cmd[7] = (unsigned char)0;
#line 807
  cmd[8] = (unsigned char)0;
#line 807
  cmd[9] = (unsigned char)0;
#line 809
  if (d___0->fua) {
#line 810
    cmd[1] = (unsigned char)8;
  }
  {
#line 812
  cmd[1] = (unsigned char )((int )cmd[1] | (d___0->lun << 5));
#line 814
  cmd[3] = (unsigned char )((begin >> 16) & 255L);
#line 815
  cmd[4] = (unsigned char )((begin >> 8) & 255L);
#line 816
  cmd[5] = (unsigned char )(begin & 255L);
#line 817
  cmd[8] = (unsigned char )sectors;
#line 818
  ret = handle_scsi_cmd(d___0, cmd, 10U, 0U, (unsigned int )(sectors * 2352L), (unsigned char )'\177',
                        1, sense);
  }
#line 818
  if (ret) {
#line 819
    return (ret);
  }
#line 820
  if (p___0) {
    {
#line 820
    memcpy((void */* __restrict  */)p___0, (void const   */* __restrict  */)(d___0->private)->sg_buffer,
           (size_t )(sectors * 2352L));
    }
  }
#line 821
  return (0);
}
}
#line 824 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/interface/scsi_interface.c"
static int i_read_A8(cdrom_drive *d___0 , void *p___0 , long begin , long sectors ,
                     unsigned char *sense ) 
{ 
  int ret ;
  unsigned char cmd[12] ;
  void *__cil_tmp8 ;

  {
#line 826
  cmd[0] = (unsigned char)168;
#line 826
  cmd[1] = (unsigned char)0;
#line 826
  cmd[2] = (unsigned char)0;
#line 826
  cmd[3] = (unsigned char)0;
#line 826
  cmd[4] = (unsigned char)0;
#line 826
  cmd[5] = (unsigned char)0;
#line 826
  cmd[6] = (unsigned char)0;
#line 826
  cmd[7] = (unsigned char)0;
#line 826
  cmd[8] = (unsigned char)0;
#line 826
  cmd[9] = (unsigned char)0;
#line 826
  cmd[10] = (unsigned char)0;
#line 826
  cmd[11] = (unsigned char)0;
#line 828
  if (d___0->fua) {
#line 829
    cmd[1] = (unsigned char)8;
  }
  {
#line 831
  cmd[1] = (unsigned char )((int )cmd[1] | (d___0->lun << 5));
#line 833
  cmd[3] = (unsigned char )((begin >> 16) & 255L);
#line 834
  cmd[4] = (unsigned char )((begin >> 8) & 255L);
#line 835
  cmd[5] = (unsigned char )(begin & 255L);
#line 836
  cmd[9] = (unsigned char )sectors;
#line 837
  ret = handle_scsi_cmd(d___0, cmd, 12U, 0U, (unsigned int )(sectors * 2352L), (unsigned char )'\177',
                        1, sense);
  }
#line 837
  if (ret) {
#line 838
    return (ret);
  }
#line 839
  if (p___0) {
    {
#line 839
    memcpy((void */* __restrict  */)p___0, (void const   */* __restrict  */)(d___0->private)->sg_buffer,
           (size_t )(sectors * 2352L));
    }
  }
#line 840
  return (0);
}
}
#line 843 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/interface/scsi_interface.c"
static int i_read_D4_10(cdrom_drive *d___0 , void *p___0 , long begin , long sectors ,
                        unsigned char *sense ) 
{ 
  int ret ;
  unsigned char cmd[10] ;
  void *__cil_tmp8 ;

  {
#line 845
  cmd[0] = (unsigned char)212;
#line 845
  cmd[1] = (unsigned char)0;
#line 845
  cmd[2] = (unsigned char)0;
#line 845
  cmd[3] = (unsigned char)0;
#line 845
  cmd[4] = (unsigned char)0;
#line 845
  cmd[5] = (unsigned char)0;
#line 845
  cmd[6] = (unsigned char)0;
#line 845
  cmd[7] = (unsigned char)0;
#line 845
  cmd[8] = (unsigned char)0;
#line 845
  cmd[9] = (unsigned char)0;
#line 847
  if (d___0->fua) {
#line 848
    cmd[1] = (unsigned char)8;
  }
  {
#line 850
  cmd[1] = (unsigned char )((int )cmd[1] | (d___0->lun << 5));
#line 851
  cmd[3] = (unsigned char )((begin >> 16) & 255L);
#line 852
  cmd[4] = (unsigned char )((begin >> 8) & 255L);
#line 853
  cmd[5] = (unsigned char )(begin & 255L);
#line 854
  cmd[8] = (unsigned char )sectors;
#line 855
  ret = handle_scsi_cmd(d___0, cmd, 10U, 0U, (unsigned int )(sectors * 2352L), (unsigned char )'\177',
                        1, sense);
  }
#line 855
  if (ret) {
#line 856
    return (ret);
  }
#line 857
  if (p___0) {
    {
#line 857
    memcpy((void */* __restrict  */)p___0, (void const   */* __restrict  */)(d___0->private)->sg_buffer,
           (size_t )(sectors * 2352L));
    }
  }
#line 858
  return (0);
}
}
#line 861 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/interface/scsi_interface.c"
static int i_read_D4_12(cdrom_drive *d___0 , void *p___0 , long begin , long sectors ,
                        unsigned char *sense ) 
{ 
  int ret ;
  unsigned char cmd[12] ;
  void *__cil_tmp8 ;

  {
#line 863
  cmd[0] = (unsigned char)212;
#line 863
  cmd[1] = (unsigned char)0;
#line 863
  cmd[2] = (unsigned char)0;
#line 863
  cmd[3] = (unsigned char)0;
#line 863
  cmd[4] = (unsigned char)0;
#line 863
  cmd[5] = (unsigned char)0;
#line 863
  cmd[6] = (unsigned char)0;
#line 863
  cmd[7] = (unsigned char)0;
#line 863
  cmd[8] = (unsigned char)0;
#line 863
  cmd[9] = (unsigned char)0;
#line 863
  cmd[10] = (unsigned char)0;
#line 863
  cmd[11] = (unsigned char)0;
#line 865
  if (d___0->fua) {
#line 866
    cmd[1] = (unsigned char)8;
  }
  {
#line 868
  cmd[1] = (unsigned char )((int )cmd[1] | (d___0->lun << 5));
#line 869
  cmd[3] = (unsigned char )((begin >> 16) & 255L);
#line 870
  cmd[4] = (unsigned char )((begin >> 8) & 255L);
#line 871
  cmd[5] = (unsigned char )(begin & 255L);
#line 872
  cmd[9] = (unsigned char )sectors;
#line 873
  ret = handle_scsi_cmd(d___0, cmd, 12U, 0U, (unsigned int )(sectors * 2352L), (unsigned char )'\177',
                        1, sense);
  }
#line 873
  if (ret) {
#line 874
    return (ret);
  }
#line 875
  if (p___0) {
    {
#line 875
    memcpy((void */* __restrict  */)p___0, (void const   */* __restrict  */)(d___0->private)->sg_buffer,
           (size_t )(sectors * 2352L));
    }
  }
#line 876
  return (0);
}
}
#line 879 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/interface/scsi_interface.c"
static int i_read_D5(cdrom_drive *d___0 , void *p___0 , long begin , long sectors ,
                     unsigned char *sense ) 
{ 
  int ret ;
  unsigned char cmd[10] ;
  void *__cil_tmp8 ;

  {
#line 881
  cmd[0] = (unsigned char)213;
#line 881
  cmd[1] = (unsigned char)0;
#line 881
  cmd[2] = (unsigned char)0;
#line 881
  cmd[3] = (unsigned char)0;
#line 881
  cmd[4] = (unsigned char)0;
#line 881
  cmd[5] = (unsigned char)0;
#line 881
  cmd[6] = (unsigned char)0;
#line 881
  cmd[7] = (unsigned char)0;
#line 881
  cmd[8] = (unsigned char)0;
#line 881
  cmd[9] = (unsigned char)0;
#line 883
  if (d___0->fua) {
#line 884
    cmd[1] = (unsigned char)8;
  }
  {
#line 886
  cmd[1] = (unsigned char )((int )cmd[1] | (d___0->lun << 5));
#line 887
  cmd[3] = (unsigned char )((begin >> 16) & 255L);
#line 888
  cmd[4] = (unsigned char )((begin >> 8) & 255L);
#line 889
  cmd[5] = (unsigned char )(begin & 255L);
#line 890
  cmd[8] = (unsigned char )sectors;
#line 891
  ret = handle_scsi_cmd(d___0, cmd, 10U, 0U, (unsigned int )(sectors * 2352L), (unsigned char )'\177',
                        1, sense);
  }
#line 891
  if (ret) {
#line 892
    return (ret);
  }
#line 893
  if (p___0) {
    {
#line 893
    memcpy((void */* __restrict  */)p___0, (void const   */* __restrict  */)(d___0->private)->sg_buffer,
           (size_t )(sectors * 2352L));
    }
  }
#line 894
  return (0);
}
}
#line 897 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/interface/scsi_interface.c"
static int i_read_D8(cdrom_drive *d___0 , void *p___0 , long begin , long sectors ,
                     unsigned char *sense ) 
{ 
  int ret ;
  unsigned char cmd[12] ;
  void *__cil_tmp8 ;

  {
#line 899
  cmd[0] = (unsigned char)216;
#line 899
  cmd[1] = (unsigned char)0;
#line 899
  cmd[2] = (unsigned char)0;
#line 899
  cmd[3] = (unsigned char)0;
#line 899
  cmd[4] = (unsigned char)0;
#line 899
  cmd[5] = (unsigned char)0;
#line 899
  cmd[6] = (unsigned char)0;
#line 899
  cmd[7] = (unsigned char)0;
#line 899
  cmd[8] = (unsigned char)0;
#line 899
  cmd[9] = (unsigned char)0;
#line 899
  cmd[10] = (unsigned char)0;
#line 899
  cmd[11] = (unsigned char)0;
#line 901
  if (d___0->fua) {
#line 902
    cmd[1] = (unsigned char)8;
  }
  {
#line 904
  cmd[1] = (unsigned char )((int )cmd[1] | (d___0->lun << 5));
#line 905
  cmd[3] = (unsigned char )((begin >> 16) & 255L);
#line 906
  cmd[4] = (unsigned char )((begin >> 8) & 255L);
#line 907
  cmd[5] = (unsigned char )(begin & 255L);
#line 908
  cmd[9] = (unsigned char )sectors;
#line 909
  ret = handle_scsi_cmd(d___0, cmd, 12U, 0U, (unsigned int )(sectors * 2352L), (unsigned char )'\177',
                        1, sense);
  }
#line 909
  if (ret) {
#line 910
    return (ret);
  }
#line 911
  if (p___0) {
    {
#line 911
    memcpy((void */* __restrict  */)p___0, (void const   */* __restrict  */)(d___0->private)->sg_buffer,
           (size_t )(sectors * 2352L));
    }
  }
#line 912
  return (0);
}
}
#line 915 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/interface/scsi_interface.c"
static int i_read_mmc(cdrom_drive *d___0 , void *p___0 , long begin , long sectors ,
                      unsigned char *sense ) 
{ 
  int ret ;
  unsigned char cmd[12] ;
  void *__cil_tmp8 ;

  {
  {
#line 917
  cmd[0] = (unsigned char)190;
#line 917
  cmd[1] = (unsigned char)2;
#line 917
  cmd[2] = (unsigned char)0;
#line 917
  cmd[3] = (unsigned char)0;
#line 917
  cmd[4] = (unsigned char)0;
#line 917
  cmd[5] = (unsigned char)0;
#line 917
  cmd[6] = (unsigned char)0;
#line 917
  cmd[7] = (unsigned char)0;
#line 917
  cmd[8] = (unsigned char)0;
#line 917
  cmd[9] = (unsigned char)16;
#line 917
  cmd[10] = (unsigned char)0;
#line 917
  cmd[11] = (unsigned char)0;
#line 919
  cmd[3] = (unsigned char )((begin >> 16) & 255L);
#line 920
  cmd[4] = (unsigned char )((begin >> 8) & 255L);
#line 921
  cmd[5] = (unsigned char )(begin & 255L);
#line 922
  cmd[8] = (unsigned char )sectors;
#line 923
  ret = handle_scsi_cmd(d___0, cmd, 12U, 0U, (unsigned int )(sectors * 2352L), (unsigned char )'\177',
                        1, sense);
  }
#line 923
  if (ret) {
#line 924
    return (ret);
  }
#line 925
  if (p___0) {
    {
#line 925
    memcpy((void */* __restrict  */)p___0, (void const   */* __restrict  */)(d___0->private)->sg_buffer,
           (size_t )(sectors * 2352L));
    }
  }
#line 926
  return (0);
}
}
#line 929 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/interface/scsi_interface.c"
static int i_read_mmcB(cdrom_drive *d___0 , void *p___0 , long begin , long sectors ,
                       unsigned char *sense ) 
{ 
  int ret ;
  unsigned char cmd[12] ;
  void *__cil_tmp8 ;

  {
  {
#line 931
  cmd[0] = (unsigned char)190;
#line 931
  cmd[1] = (unsigned char)0;
#line 931
  cmd[2] = (unsigned char)0;
#line 931
  cmd[3] = (unsigned char)0;
#line 931
  cmd[4] = (unsigned char)0;
#line 931
  cmd[5] = (unsigned char)0;
#line 931
  cmd[6] = (unsigned char)0;
#line 931
  cmd[7] = (unsigned char)0;
#line 931
  cmd[8] = (unsigned char)0;
#line 931
  cmd[9] = (unsigned char)16;
#line 931
  cmd[10] = (unsigned char)0;
#line 931
  cmd[11] = (unsigned char)0;
#line 933
  cmd[3] = (unsigned char )((begin >> 16) & 255L);
#line 934
  cmd[4] = (unsigned char )((begin >> 8) & 255L);
#line 935
  cmd[5] = (unsigned char )(begin & 255L);
#line 936
  cmd[8] = (unsigned char )sectors;
#line 937
  ret = handle_scsi_cmd(d___0, cmd, 12U, 0U, (unsigned int )(sectors * 2352L), (unsigned char )'\177',
                        1, sense);
  }
#line 937
  if (ret) {
#line 938
    return (ret);
  }
#line 939
  if (p___0) {
    {
#line 939
    memcpy((void */* __restrict  */)p___0, (void const   */* __restrict  */)(d___0->private)->sg_buffer,
           (size_t )(sectors * 2352L));
    }
  }
#line 940
  return (0);
}
}
#line 943 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/interface/scsi_interface.c"
static int i_read_mmc2(cdrom_drive *d___0 , void *p___0 , long begin , long sectors ,
                       unsigned char *sense ) 
{ 
  int ret ;
  unsigned char cmd[12] ;
  void *__cil_tmp8 ;

  {
  {
#line 945
  cmd[0] = (unsigned char)190;
#line 945
  cmd[1] = (unsigned char)2;
#line 945
  cmd[2] = (unsigned char)0;
#line 945
  cmd[3] = (unsigned char)0;
#line 945
  cmd[4] = (unsigned char)0;
#line 945
  cmd[5] = (unsigned char)0;
#line 945
  cmd[6] = (unsigned char)0;
#line 945
  cmd[7] = (unsigned char)0;
#line 945
  cmd[8] = (unsigned char)0;
#line 945
  cmd[9] = (unsigned char)248;
#line 945
  cmd[10] = (unsigned char)0;
#line 945
  cmd[11] = (unsigned char)0;
#line 947
  cmd[3] = (unsigned char )((begin >> 16) & 255L);
#line 948
  cmd[4] = (unsigned char )((begin >> 8) & 255L);
#line 949
  cmd[5] = (unsigned char )(begin & 255L);
#line 950
  cmd[8] = (unsigned char )sectors;
#line 951
  ret = handle_scsi_cmd(d___0, cmd, 12U, 0U, (unsigned int )(sectors * 2352L), (unsigned char )'\177',
                        1, sense);
  }
#line 951
  if (ret) {
#line 952
    return (ret);
  }
#line 953
  if (p___0) {
    {
#line 953
    memcpy((void */* __restrict  */)p___0, (void const   */* __restrict  */)(d___0->private)->sg_buffer,
           (size_t )(sectors * 2352L));
    }
  }
#line 954
  return (0);
}
}
#line 957 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/interface/scsi_interface.c"
static int i_read_mmc2B(cdrom_drive *d___0 , void *p___0 , long begin , long sectors ,
                        unsigned char *sense ) 
{ 
  int ret ;
  unsigned char cmd[12] ;
  void *__cil_tmp8 ;

  {
  {
#line 959
  cmd[0] = (unsigned char)190;
#line 959
  cmd[1] = (unsigned char)0;
#line 959
  cmd[2] = (unsigned char)0;
#line 959
  cmd[3] = (unsigned char)0;
#line 959
  cmd[4] = (unsigned char)0;
#line 959
  cmd[5] = (unsigned char)0;
#line 959
  cmd[6] = (unsigned char)0;
#line 959
  cmd[7] = (unsigned char)0;
#line 959
  cmd[8] = (unsigned char)0;
#line 959
  cmd[9] = (unsigned char)248;
#line 959
  cmd[10] = (unsigned char)0;
#line 959
  cmd[11] = (unsigned char)0;
#line 961
  cmd[3] = (unsigned char )((begin >> 16) & 255L);
#line 962
  cmd[4] = (unsigned char )((begin >> 8) & 255L);
#line 963
  cmd[5] = (unsigned char )(begin & 255L);
#line 964
  cmd[8] = (unsigned char )sectors;
#line 965
  ret = handle_scsi_cmd(d___0, cmd, 12U, 0U, (unsigned int )(sectors * 2352L), (unsigned char )'\177',
                        1, sense);
  }
#line 965
  if (ret) {
#line 966
    return (ret);
  }
#line 967
  if (p___0) {
    {
#line 967
    memcpy((void */* __restrict  */)p___0, (void const   */* __restrict  */)(d___0->private)->sg_buffer,
           (size_t )(sectors * 2352L));
    }
  }
#line 968
  return (0);
}
}
#line 971 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/interface/scsi_interface.c"
static int i_read_mmc3(cdrom_drive *d___0 , void *p___0 , long begin , long sectors ,
                       unsigned char *sense ) 
{ 
  int ret ;
  unsigned char cmd[12] ;
  void *__cil_tmp8 ;

  {
  {
#line 973
  cmd[0] = (unsigned char)190;
#line 973
  cmd[1] = (unsigned char)6;
#line 973
  cmd[2] = (unsigned char)0;
#line 973
  cmd[3] = (unsigned char)0;
#line 973
  cmd[4] = (unsigned char)0;
#line 973
  cmd[5] = (unsigned char)0;
#line 973
  cmd[6] = (unsigned char)0;
#line 973
  cmd[7] = (unsigned char)0;
#line 973
  cmd[8] = (unsigned char)0;
#line 973
  cmd[9] = (unsigned char)248;
#line 973
  cmd[10] = (unsigned char)0;
#line 973
  cmd[11] = (unsigned char)0;
#line 975
  cmd[3] = (unsigned char )((begin >> 16) & 255L);
#line 976
  cmd[4] = (unsigned char )((begin >> 8) & 255L);
#line 977
  cmd[5] = (unsigned char )(begin & 255L);
#line 978
  cmd[8] = (unsigned char )sectors;
#line 979
  ret = handle_scsi_cmd(d___0, cmd, 12U, 0U, (unsigned int )(sectors * 2352L), (unsigned char )'\177',
                        1, sense);
  }
#line 979
  if (ret) {
#line 980
    return (ret);
  }
#line 981
  if (p___0) {
    {
#line 981
    memcpy((void */* __restrict  */)p___0, (void const   */* __restrict  */)(d___0->private)->sg_buffer,
           (size_t )(sectors * 2352L));
    }
  }
#line 982
  return (0);
}
}
#line 985 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/interface/scsi_interface.c"
static int i_read_mmc3B(cdrom_drive *d___0 , void *p___0 , long begin , long sectors ,
                        unsigned char *sense ) 
{ 
  int ret ;
  unsigned char cmd[12] ;
  void *__cil_tmp8 ;

  {
  {
#line 987
  cmd[0] = (unsigned char)190;
#line 987
  cmd[1] = (unsigned char)4;
#line 987
  cmd[2] = (unsigned char)0;
#line 987
  cmd[3] = (unsigned char)0;
#line 987
  cmd[4] = (unsigned char)0;
#line 987
  cmd[5] = (unsigned char)0;
#line 987
  cmd[6] = (unsigned char)0;
#line 987
  cmd[7] = (unsigned char)0;
#line 987
  cmd[8] = (unsigned char)0;
#line 987
  cmd[9] = (unsigned char)248;
#line 987
  cmd[10] = (unsigned char)0;
#line 987
  cmd[11] = (unsigned char)0;
#line 989
  cmd[3] = (unsigned char )((begin >> 16) & 255L);
#line 990
  cmd[4] = (unsigned char )((begin >> 8) & 255L);
#line 991
  cmd[5] = (unsigned char )(begin & 255L);
#line 992
  cmd[8] = (unsigned char )sectors;
#line 993
  ret = handle_scsi_cmd(d___0, cmd, 12U, 0U, (unsigned int )(sectors * 2352L), (unsigned char )'\177',
                        1, sense);
  }
#line 993
  if (ret) {
#line 994
    return (ret);
  }
#line 995
  if (p___0) {
    {
#line 995
    memcpy((void */* __restrict  */)p___0, (void const   */* __restrict  */)(d___0->private)->sg_buffer,
           (size_t )(sectors * 2352L));
    }
  }
#line 996
  return (0);
}
}
#line 1000 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/interface/scsi_interface.c"
__inline static void LBA_to_MSF(long lba , unsigned char *M , unsigned char *S , unsigned char *F ) 
{ 


  {
#line 1004
  if (lba >= -150L) {
#line 1005
    *M = (unsigned char )((lba + 150L) / 4500L);
#line 1006
    lba -= (long )(((int )*M * 60) * 75);
#line 1007
    *S = (unsigned char )((lba + 150L) / 75L);
#line 1008
    lba -= (long )((int )*S * 75);
#line 1009
    *F = (unsigned char )(lba + 150L);
  } else {
#line 1011
    *M = (unsigned char )((lba + 450150L) / 4500L);
#line 1012
    lba -= (long )(((int )*M * 60) * 75);
#line 1013
    *S = (unsigned char )((lba + 450150L) / 75L);
#line 1014
    lba -= (long )((int )*S * 75);
#line 1015
    *F = (unsigned char )(lba + 450150L);
  }
#line 1017
  return;
}
}
#line 1020 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/interface/scsi_interface.c"
static int i_read_msf(cdrom_drive *d___0 , void *p___0 , long begin , long sectors ,
                      unsigned char *sense ) 
{ 
  int ret ;
  unsigned char cmd[12] ;
  void *__cil_tmp8 ;

  {
  {
#line 1022
  cmd[0] = (unsigned char)185;
#line 1022
  cmd[1] = (unsigned char)0;
#line 1022
  cmd[2] = (unsigned char)0;
#line 1022
  cmd[3] = (unsigned char)0;
#line 1022
  cmd[4] = (unsigned char)0;
#line 1022
  cmd[5] = (unsigned char)0;
#line 1022
  cmd[6] = (unsigned char)0;
#line 1022
  cmd[7] = (unsigned char)0;
#line 1022
  cmd[8] = (unsigned char)0;
#line 1022
  cmd[9] = (unsigned char)16;
#line 1022
  cmd[10] = (unsigned char)0;
#line 1022
  cmd[11] = (unsigned char)0;
#line 1024
  LBA_to_MSF(begin, cmd + 3, cmd + 4, cmd + 5);
#line 1025
  LBA_to_MSF(begin + sectors, cmd + 6, cmd + 7, cmd + 8);
#line 1027
  ret = handle_scsi_cmd(d___0, cmd, 12U, 0U, (unsigned int )(sectors * 2352L), (unsigned char )'\177',
                        1, sense);
  }
#line 1027
  if (ret) {
#line 1028
    return (ret);
  }
#line 1029
  if (p___0) {
    {
#line 1029
    memcpy((void */* __restrict  */)p___0, (void const   */* __restrict  */)(d___0->private)->sg_buffer,
           (size_t )(sectors * 2352L));
    }
  }
#line 1030
  return (0);
}
}
#line 1033 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/interface/scsi_interface.c"
static int i_read_msf2(cdrom_drive *d___0 , void *p___0 , long begin , long sectors ,
                       unsigned char *sense ) 
{ 
  int ret ;
  unsigned char cmd[12] ;
  void *__cil_tmp8 ;

  {
  {
#line 1035
  cmd[0] = (unsigned char)185;
#line 1035
  cmd[1] = (unsigned char)0;
#line 1035
  cmd[2] = (unsigned char)0;
#line 1035
  cmd[3] = (unsigned char)0;
#line 1035
  cmd[4] = (unsigned char)0;
#line 1035
  cmd[5] = (unsigned char)0;
#line 1035
  cmd[6] = (unsigned char)0;
#line 1035
  cmd[7] = (unsigned char)0;
#line 1035
  cmd[8] = (unsigned char)0;
#line 1035
  cmd[9] = (unsigned char)248;
#line 1035
  cmd[10] = (unsigned char)0;
#line 1035
  cmd[11] = (unsigned char)0;
#line 1037
  LBA_to_MSF(begin, cmd + 3, cmd + 4, cmd + 5);
#line 1038
  LBA_to_MSF(begin + sectors, cmd + 6, cmd + 7, cmd + 8);
#line 1040
  ret = handle_scsi_cmd(d___0, cmd, 12U, 0U, (unsigned int )(sectors * 2352L), (unsigned char )'\177',
                        1, sense);
  }
#line 1040
  if (ret) {
#line 1041
    return (ret);
  }
#line 1042
  if (p___0) {
    {
#line 1042
    memcpy((void */* __restrict  */)p___0, (void const   */* __restrict  */)(d___0->private)->sg_buffer,
           (size_t )(sectors * 2352L));
    }
  }
#line 1043
  return (0);
}
}
#line 1046 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/interface/scsi_interface.c"
static int i_read_msf3(cdrom_drive *d___0 , void *p___0 , long begin , long sectors ,
                       unsigned char *sense ) 
{ 
  int ret ;
  unsigned char cmd[12] ;
  void *__cil_tmp8 ;

  {
  {
#line 1048
  cmd[0] = (unsigned char)185;
#line 1048
  cmd[1] = (unsigned char)4;
#line 1048
  cmd[2] = (unsigned char)0;
#line 1048
  cmd[3] = (unsigned char)0;
#line 1048
  cmd[4] = (unsigned char)0;
#line 1048
  cmd[5] = (unsigned char)0;
#line 1048
  cmd[6] = (unsigned char)0;
#line 1048
  cmd[7] = (unsigned char)0;
#line 1048
  cmd[8] = (unsigned char)0;
#line 1048
  cmd[9] = (unsigned char)248;
#line 1048
  cmd[10] = (unsigned char)0;
#line 1048
  cmd[11] = (unsigned char)0;
#line 1050
  LBA_to_MSF(begin, cmd + 3, cmd + 4, cmd + 5);
#line 1051
  LBA_to_MSF(begin + sectors, cmd + 6, cmd + 7, cmd + 8);
#line 1053
  ret = handle_scsi_cmd(d___0, cmd, 12U, 0U, (unsigned int )(sectors * 2352L), (unsigned char )'\177',
                        1, sense);
  }
#line 1053
  if (ret) {
#line 1054
    return (ret);
  }
#line 1055
  if (p___0) {
    {
#line 1055
    memcpy((void */* __restrict  */)p___0, (void const   */* __restrict  */)(d___0->private)->sg_buffer,
           (size_t )(sectors * 2352L));
    }
  }
#line 1056
  return (0);
}
}
#line 1060 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/interface/scsi_interface.c"
static long scsi_read_map(cdrom_drive *d___0 , void *p___0 , long begin , long sectors ,
                          int (*map)(cdrom_drive * , void * , long  , long  , unsigned char * ) ) 
{ 
  unsigned char sense[16] ;
  int retry_count ;
  int err ;
  char *buffer ;
  char b[256] ;
  int *tmp ;
  char *tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  int *tmp___3 ;
  char b___0[256] ;
  int *tmp___4 ;
  char b___1[256] ;
  long i ;
  char b___2[256] ;
  char *tmp___5 ;
  void *__cil_tmp22 ;
  void *__cil_tmp23 ;
  void *__cil_tmp24 ;
  void *__cil_tmp25 ;
  void *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;

  {
#line 1065
  buffer = (char *)p___0;
#line 1068
  if (sectors > (long )d___0->nsectors) {
#line 1068
    sectors = (long )d___0->nsectors;
  } else {
#line 1068
    sectors = sectors;
  }
#line 1069
  if (sectors < 1L) {
#line 1069
    sectors = 1L;
  } else {
#line 1069
    sectors = sectors;
  }
#line 1071
  retry_count = 0;
  {
#line 1073
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1075
    if (p___0) {
#line 1075
      tmp___5 = buffer;
    } else {
#line 1075
      tmp___5 = (char *)((void *)0);
    }
    {
#line 1075
    err = (*map)(d___0, (void *)tmp___5, begin, sectors, sense);
    }
#line 1075
    if (err) {
#line 1076
      if (d___0->report_all) {
        {
#line 1079
        sprintf((char */* __restrict  */)(b), (char const   */* __restrict  */)"scsi_read error: sector=%ld length=%ld retry=%d\n",
                begin, sectors, retry_count);
#line 1081
        cdmessage(d___0, (char const   *)(b));
#line 1082
        sprintf((char */* __restrict  */)(b), (char const   */* __restrict  */)"                 Sense key: %x ASC: %x ASCQ: %x\n",
                (int )sense[2] & 15, (int )sense[12], (int )sense[13]);
#line 1086
        cdmessage(d___0, (char const   *)(b));
#line 1087
        sprintf((char */* __restrict  */)(b), (char const   */* __restrict  */)"                 Transport error: %s\n",
                strerror_tr[err]);
#line 1088
        cdmessage(d___0, (char const   *)(b));
#line 1089
        tmp = __errno_location();
#line 1089
        tmp___0 = strerror(*tmp);
#line 1089
        sprintf((char */* __restrict  */)(b), (char const   */* __restrict  */)"                 System error: %s\n",
                tmp___0);
#line 1090
        cdmessage(d___0, (char const   *)(b));
#line 1092
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"scsi_read error: sector=%ld length=%ld retry=%d\n",
                begin, sectors, retry_count);
#line 1094
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"                 Sense key: %x ASC: %x ASCQ: %x\n",
                (int )sense[2] & 15, (int )sense[12], (int )sense[13]);
#line 1098
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"                 Transport error: %s\n",
                strerror_tr[err]);
#line 1099
        tmp___1 = __errno_location();
#line 1099
        tmp___2 = strerror(*tmp___1);
#line 1099
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"                 System error: %s\n",
                tmp___2);
        }
      }
      {
#line 1102
      tmp___3 = __errno_location();
      }
      {
#line 1103
      if (*tmp___3 == 4) {
#line 1103
        goto case_4;
      }
#line 1106
      if (*tmp___3 == 12) {
#line 1106
        goto case_12;
      }
#line 1123
      if (*tmp___3 == 123) {
#line 1123
        goto case_123;
      }
#line 1127
      goto switch_default;
      case_4: /* CIL Label */ 
      {
#line 1104
      usleep((__useconds_t )100);
      }
#line 1105
      goto while_continue;
      case_12: /* CIL Label */ 
      {
#line 1108
      usleep((__useconds_t )100);
      }
#line 1109
      if (sectors == 1L) {
        {
#line 1111
        cderror___0(d___0, "300: Kernel memory error\n");
        }
#line 1112
        return (-300L);
      }
#line 1114
      if (d___0->report_all) {
        {
#line 1116
        sprintf((char */* __restrict  */)(b___0), (char const   */* __restrict  */)"scsi_read: kernel couldn\'t alloc %ld bytes.  backing off...\n",
                sectors * 2352L);
#line 1119
        cdmessage(d___0, (char const   *)(b___0));
        }
      }
#line 1121
      sectors --;
#line 1122
      goto while_continue;
      case_123: /* CIL Label */ 
      {
#line 1124
      cderror___0(d___0, "404: No medium present\n");
      }
#line 1125
      return (-404L);
      switch_default: /* CIL Label */ 
#line 1128
      if (sectors == 1L) {
        {
#line 1129
        tmp___4 = __errno_location();
        }
#line 1129
        if (*tmp___4 == 5) {
#line 1130
          if (d___0->fua == -1) {
#line 1131
            return (-7L);
          }
        }
#line 1136
        if (retry_count > 7) {
          {
#line 1138
          sprintf((char */* __restrict  */)(b___1), (char const   */* __restrict  */)"010: Unable to access sector %ld\n",
                  begin);
#line 1140
          cderror___0(d___0, (char const   *)(b___1));
          }
#line 1141
          return (-10L);
        }
#line 1144
        goto switch_break;
      }
      {
#line 1150
      reset_scsi(d___0);
      }
      switch_break: /* CIL Label */ ;
      }
#line 1152
      if (! d___0->error_retry) {
#line 1152
        return (-7L);
      }
    } else
#line 1158
    if (buffer) {
#line 1160
      i = sectors * 2352L;
      {
#line 1160
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1160
        if (! (i > 1L)) {
#line 1160
          goto while_break___0;
        }
#line 1161
        if ((int )*(buffer + (i - 1L)) != 127) {
#line 1162
          goto while_break___0;
        } else
#line 1161
        if ((int )*(buffer + (i - 2L)) != 127) {
#line 1162
          goto while_break___0;
        }
#line 1160
        i -= 2L;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 1164
      i /= 2352L;
#line 1165
      if (i != sectors) {
#line 1166
        if (d___0->report_all) {
          {
#line 1168
          sprintf((char */* __restrict  */)(b___2), (char const   */* __restrict  */)"scsi_read underrun: pos=%ld len=%ld read=%ld retry=%d\n",
                  begin, sectors, i, retry_count);
#line 1171
          cdmessage(d___0, (char const   *)(b___2));
          }
        }
        {
#line 1173
        reset_scsi(d___0);
        }
      }
#line 1176
      if (i > 0L) {
#line 1176
        return (i);
      }
    } else {
#line 1179
      goto while_break;
    }
#line 1182
    retry_count ++;
#line 1183
    if (sectors == 1L) {
#line 1183
      if (retry_count > 8) {
        {
#line 1184
        cderror___0(d___0, "007: Unknown, unrecoverable error reading data\n");
        }
#line 1185
        return (-7L);
      }
    }
#line 1187
    if (sectors > 1L) {
#line 1187
      sectors /= 2L;
    }
    {
#line 1188
    (*(d___0->enable_cdda))(d___0, 0);
#line 1189
    (*(d___0->enable_cdda))(d___0, 1);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1192
  return (sectors);
}
}
#line 1195 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/interface/scsi_interface.c"
long scsi_read_28(cdrom_drive *d___0 , void *p___0 , long begin , long sectors ) 
{ 
  long tmp ;

  {
  {
#line 1197
  tmp = scsi_read_map(d___0, p___0, begin, sectors, & i_read_28);
  }
#line 1197
  return (tmp);
}
}
#line 1200 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/interface/scsi_interface.c"
long scsi_read_A8(cdrom_drive *d___0 , void *p___0 , long begin , long sectors ) 
{ 
  long tmp ;

  {
  {
#line 1202
  tmp = scsi_read_map(d___0, p___0, begin, sectors, & i_read_A8);
  }
#line 1202
  return (tmp);
}
}
#line 1205 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/interface/scsi_interface.c"
long scsi_read_D4_10(cdrom_drive *d___0 , void *p___0 , long begin , long sectors ) 
{ 
  long tmp ;

  {
  {
#line 1207
  tmp = scsi_read_map(d___0, p___0, begin, sectors, & i_read_D4_10);
  }
#line 1207
  return (tmp);
}
}
#line 1210 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/interface/scsi_interface.c"
long scsi_read_D4_12(cdrom_drive *d___0 , void *p___0 , long begin , long sectors ) 
{ 
  long tmp ;

  {
  {
#line 1212
  tmp = scsi_read_map(d___0, p___0, begin, sectors, & i_read_D4_12);
  }
#line 1212
  return (tmp);
}
}
#line 1215 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/interface/scsi_interface.c"
long scsi_read_D5(cdrom_drive *d___0 , void *p___0 , long begin , long sectors ) 
{ 
  long tmp ;

  {
  {
#line 1217
  tmp = scsi_read_map(d___0, p___0, begin, sectors, & i_read_D5);
  }
#line 1217
  return (tmp);
}
}
#line 1220 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/interface/scsi_interface.c"
long scsi_read_D8(cdrom_drive *d___0 , void *p___0 , long begin , long sectors ) 
{ 
  long tmp ;

  {
  {
#line 1222
  tmp = scsi_read_map(d___0, p___0, begin, sectors, & i_read_D8);
  }
#line 1222
  return (tmp);
}
}
#line 1225 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/interface/scsi_interface.c"
long scsi_read_mmc(cdrom_drive *d___0 , void *p___0 , long begin , long sectors ) 
{ 
  long tmp ;

  {
  {
#line 1227
  tmp = scsi_read_map(d___0, p___0, begin, sectors, & i_read_mmc);
  }
#line 1227
  return (tmp);
}
}
#line 1230 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/interface/scsi_interface.c"
long scsi_read_mmc2(cdrom_drive *d___0 , void *p___0 , long begin , long sectors ) 
{ 
  long tmp ;

  {
  {
#line 1232
  tmp = scsi_read_map(d___0, p___0, begin, sectors, & i_read_mmc2);
  }
#line 1232
  return (tmp);
}
}
#line 1235 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/interface/scsi_interface.c"
long scsi_read_mmc3(cdrom_drive *d___0 , void *p___0 , long begin , long sectors ) 
{ 
  long tmp ;

  {
  {
#line 1237
  tmp = scsi_read_map(d___0, p___0, begin, sectors, & i_read_mmc3);
  }
#line 1237
  return (tmp);
}
}
#line 1240 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/interface/scsi_interface.c"
long scsi_read_mmcB(cdrom_drive *d___0 , void *p___0 , long begin , long sectors ) 
{ 
  long tmp ;

  {
  {
#line 1242
  tmp = scsi_read_map(d___0, p___0, begin, sectors, & i_read_mmcB);
  }
#line 1242
  return (tmp);
}
}
#line 1245 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/interface/scsi_interface.c"
long scsi_read_mmc2B(cdrom_drive *d___0 , void *p___0 , long begin , long sectors ) 
{ 
  long tmp ;

  {
  {
#line 1247
  tmp = scsi_read_map(d___0, p___0, begin, sectors, & i_read_mmc2B);
  }
#line 1247
  return (tmp);
}
}
#line 1250 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/interface/scsi_interface.c"
long scsi_read_mmc3B(cdrom_drive *d___0 , void *p___0 , long begin , long sectors ) 
{ 
  long tmp ;

  {
  {
#line 1252
  tmp = scsi_read_map(d___0, p___0, begin, sectors, & i_read_mmc3B);
  }
#line 1252
  return (tmp);
}
}
#line 1255 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/interface/scsi_interface.c"
long scsi_read_msf(cdrom_drive *d___0 , void *p___0 , long begin , long sectors ) 
{ 
  long tmp ;

  {
  {
#line 1257
  tmp = scsi_read_map(d___0, p___0, begin, sectors, & i_read_msf);
  }
#line 1257
  return (tmp);
}
}
#line 1260 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/interface/scsi_interface.c"
long scsi_read_msf2(cdrom_drive *d___0 , void *p___0 , long begin , long sectors ) 
{ 
  long tmp ;

  {
  {
#line 1262
  tmp = scsi_read_map(d___0, p___0, begin, sectors, & i_read_msf2);
  }
#line 1262
  return (tmp);
}
}
#line 1265 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/interface/scsi_interface.c"
long scsi_read_msf3(cdrom_drive *d___0 , void *p___0 , long begin , long sectors ) 
{ 
  long tmp ;

  {
  {
#line 1267
  tmp = scsi_read_map(d___0, p___0, begin, sectors, & i_read_msf3);
  }
#line 1267
  return (tmp);
}
}
#line 1275 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/interface/scsi_interface.c"
static int count_2352_bytes(cdrom_drive *d___0 ) 
{ 
  long i ;

  {
#line 1277
  i = 2351L;
  {
#line 1277
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1277
    if (! (i >= 0L)) {
#line 1277
      goto while_break;
    }
#line 1278
    if ((int )*((d___0->private)->sg_buffer + i) != 127) {
#line 1279
      return ((int )(((i + 3L) >> 2) << 2));
    }
#line 1277
    i --;
  }
  while_break: /* CIL Label */ ;
  }
#line 1281
  return (0);
}
}
#line 1284 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/interface/scsi_interface.c"
static int verify_nonzero(cdrom_drive *d___0 ) 
{ 
  long i ;
  long flag ;

  {
#line 1285
  flag = 0L;
#line 1286
  i = 0L;
  {
#line 1286
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1286
    if (! (i < 2352L)) {
#line 1286
      goto while_break;
    }
#line 1287
    if ((int )*((d___0->private)->sg_buffer + i) != 0) {
#line 1288
      flag = 1L;
#line 1289
      goto while_break;
    }
#line 1286
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1292
  return ((int )flag);
}
}
#line 1299 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/interface/scsi_interface.c"
static int verify_read_command(cdrom_drive *d___0 ) 
{ 
  int i ;
  int j ;
  int k ;
  int audioflag ;
  int (*enablecommand)(struct cdrom_drive *d , int speed ) ;
  long (*readcommand)(struct cdrom_drive *d , void *p , long begin , long sectors ) ;
  unsigned char density ;
  int16_t *buff ;
  void *tmp ;
  long firstsector ;
  long tmp___0 ;
  long lastsector ;
  long tmp___1 ;
  long sector ;
  int tmp___2 ;
  long tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  char *es ;
  char *rs___0 ;
  int densitypossible ;
  int densityflag ;
  int rejectflag ;
  int zeroflag ;
  int lengthflag ;
  long firstsector___0 ;
  long tmp___6 ;
  long lastsector___0 ;
  long tmp___7 ;
  long sector___0 ;
  int tmp___8 ;
  long tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  char buffer[256] ;
  char buffer___0[256] ;
  char buffer___1[256] ;
  void *__cil_tmp39 ;
  void *__cil_tmp40 ;
  void *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;
  char *__cil_tmp52 ;
  char *__cil_tmp53 ;
  char *__cil_tmp54 ;
  char *__cil_tmp55 ;
  char *__cil_tmp56 ;
  char *__cil_tmp57 ;
  char *__cil_tmp58 ;
  char *__cil_tmp59 ;
  char *__cil_tmp60 ;
  char *__cil_tmp61 ;
  char *__cil_tmp62 ;
  char *__cil_tmp63 ;
  char *__cil_tmp64 ;
  char *__cil_tmp65 ;
  char *__cil_tmp66 ;
  char *__cil_tmp67 ;
  char *__cil_tmp68 ;
  char *__cil_tmp69 ;
  char *__cil_tmp70 ;
  char *__cil_tmp71 ;
  char *__cil_tmp72 ;
  char *__cil_tmp73 ;
  char *__cil_tmp74 ;
  char *__cil_tmp75 ;
  char *__cil_tmp76 ;
  char *__cil_tmp77 ;

  {
  {
#line 1301
  audioflag = 0;
#line 1308
  tmp = malloc((size_t )2352);
#line 1308
  buff = (int16_t *)tmp;
#line 1310
  cdmessage(d___0, "Verifying CDDA command set...\n");
#line 1315
  tmp___5 = (*(d___0->enable_cdda))(d___0, 1);
  }
#line 1315
  if (tmp___5 == 0) {
#line 1317
    i = 1;
    {
#line 1317
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1317
      if (! (i <= d___0->tracks)) {
#line 1317
        goto while_break;
      }
      {
#line 1318
      tmp___4 = cdda_track_audiop(d___0, i);
      }
#line 1318
      if (tmp___4 == 1) {
        {
#line 1319
        tmp___0 = cdda_track_firstsector(d___0, i);
#line 1319
        firstsector = tmp___0;
#line 1320
        tmp___1 = cdda_track_lastsector(d___0, i);
#line 1320
        lastsector = tmp___1;
#line 1321
        sector = (firstsector + lastsector) >> 1;
#line 1322
        audioflag = 1;
#line 1324
        tmp___3 = (*(d___0->read_audio))(d___0, (void *)buff, sector, 1L);
        }
#line 1324
        if (tmp___3 > 0L) {
          {
#line 1325
          tmp___2 = count_2352_bytes(d___0);
          }
#line 1325
          if (tmp___2 == 2352) {
            {
#line 1326
            cdmessage(d___0, "\tExpected command set reads OK.\n");
#line 1327
            (*(d___0->enable_cdda))(d___0, 0);
#line 1328
            free((void *)buff);
            }
#line 1329
            return (0);
          }
        }
      }
#line 1317
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 1335
    (*(d___0->enable_cdda))(d___0, 0);
    }
  }
#line 1337
  if (! audioflag) {
    {
#line 1338
    cdmessage(d___0, "\tCould not find any audio tracks on this disk.\n");
    }
#line 1339
    return (-403);
  }
  {
#line 1343
  es = (char *)"";
#line 1343
  rs___0 = (char *)"";
#line 1344
  d___0->bigendianp = -1;
#line 1345
  density = d___0->density;
#line 1346
  readcommand = d___0->read_audio;
#line 1347
  enablecommand = d___0->enable_cdda;
#line 1351
  cdmessage(d___0, "\tExpected command set FAILED!\n\tPerforming full probe for CDDA command set...\n");
#line 1361
  j = 0;
  }
  {
#line 1361
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1361
    if (! (j < 15)) {
#line 1361
      goto while_break___0;
    }
#line 1362
    densitypossible = 1;
    {
#line 1365
    if (j == 0) {
#line 1365
      goto case_0;
    }
#line 1369
    if (j == 1) {
#line 1369
      goto case_1;
    }
#line 1374
    if (j == 2) {
#line 1374
      goto case_2;
    }
#line 1379
    if (j == 3) {
#line 1379
      goto case_3;
    }
#line 1384
    if (j == 4) {
#line 1384
      goto case_4;
    }
#line 1390
    if (j == 5) {
#line 1390
      goto case_5;
    }
#line 1395
    if (j == 6) {
#line 1395
      goto case_6;
    }
#line 1400
    if (j == 7) {
#line 1400
      goto case_7;
    }
#line 1406
    if (j == 8) {
#line 1406
      goto case_8;
    }
#line 1411
    if (j == 9) {
#line 1411
      goto case_9;
    }
#line 1416
    if (j == 10) {
#line 1416
      goto case_10;
    }
#line 1422
    if (j == 11) {
#line 1422
      goto case_11;
    }
#line 1426
    if (j == 12) {
#line 1426
      goto case_12;
    }
#line 1430
    if (j == 13) {
#line 1430
      goto case_13;
    }
#line 1434
    if (j == 14) {
#line 1434
      goto case_14;
    }
#line 1364
    goto switch_break;
    case_0: /* CIL Label */ 
#line 1366
    d___0->read_audio = & scsi_read_28;
#line 1367
    rs___0 = (char *)"28 0x,00";
#line 1368
    goto switch_break;
    case_1: /* CIL Label */ 
#line 1370
    d___0->read_audio = & scsi_read_A8;
#line 1371
    rs___0 = (char *)"a8 0x,00";
#line 1372
    goto switch_break;
    case_2: /* CIL Label */ 
#line 1375
    d___0->read_audio = & scsi_read_mmcB;
#line 1376
    rs___0 = (char *)"be 02,10";
#line 1377
    densitypossible = 0;
#line 1378
    goto switch_break;
    case_3: /* CIL Label */ 
#line 1380
    d___0->read_audio = & scsi_read_mmc2B;
#line 1381
    rs___0 = (char *)"be 02,f8";
#line 1382
    densitypossible = 0;
#line 1383
    goto switch_break;
    case_4: /* CIL Label */ 
#line 1385
    d___0->read_audio = & scsi_read_mmc3B;
#line 1386
    rs___0 = (char *)"be 06,f8";
#line 1387
    densitypossible = 0;
#line 1388
    goto switch_break;
    case_5: /* CIL Label */ 
#line 1391
    d___0->read_audio = & scsi_read_mmc;
#line 1392
    rs___0 = (char *)"be 00,10";
#line 1393
    densitypossible = 0;
#line 1394
    goto switch_break;
    case_6: /* CIL Label */ 
#line 1396
    d___0->read_audio = & scsi_read_mmc2;
#line 1397
    rs___0 = (char *)"be 00,f8";
#line 1398
    densitypossible = 0;
#line 1399
    goto switch_break;
    case_7: /* CIL Label */ 
#line 1401
    d___0->read_audio = & scsi_read_mmc3;
#line 1402
    rs___0 = (char *)"be 04,f8";
#line 1403
    densitypossible = 0;
#line 1404
    goto switch_break;
    case_8: /* CIL Label */ 
#line 1407
    d___0->read_audio = & scsi_read_msf;
#line 1408
    rs___0 = (char *)"b9 00,10";
#line 1409
    densitypossible = 0;
#line 1410
    goto switch_break;
    case_9: /* CIL Label */ 
#line 1412
    d___0->read_audio = & scsi_read_msf2;
#line 1413
    rs___0 = (char *)"b9 00,f8";
#line 1414
    densitypossible = 0;
#line 1415
    goto switch_break;
    case_10: /* CIL Label */ 
#line 1417
    d___0->read_audio = & scsi_read_msf3;
#line 1418
    rs___0 = (char *)"b9 04,f8";
#line 1419
    densitypossible = 0;
#line 1420
    goto switch_break;
    case_11: /* CIL Label */ 
#line 1423
    d___0->read_audio = & scsi_read_D4_10;
#line 1424
    rs___0 = (char *)"d4(10)0x";
#line 1425
    goto switch_break;
    case_12: /* CIL Label */ 
#line 1427
    d___0->read_audio = & scsi_read_D4_12;
#line 1428
    rs___0 = (char *)"d4(12)0x";
#line 1429
    goto switch_break;
    case_13: /* CIL Label */ 
#line 1431
    d___0->read_audio = & scsi_read_D5;
#line 1432
    rs___0 = (char *)"d5 0x,00";
#line 1433
    goto switch_break;
    case_14: /* CIL Label */ 
#line 1435
    d___0->read_audio = & scsi_read_D8;
#line 1436
    rs___0 = (char *)"d8 0x,00";
#line 1437
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 1440
    i = 0;
    {
#line 1440
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1440
      if (! (i < 5)) {
#line 1440
        goto while_break___1;
      }
      {
#line 1442
      if (i == 0) {
#line 1442
        goto case_0___0;
      }
#line 1448
      if (i == 1) {
#line 1448
        goto case_1___0;
      }
#line 1453
      if (i == 2) {
#line 1453
        goto case_2___0;
      }
#line 1458
      if (i == 3) {
#line 1458
        goto case_3___0;
      }
#line 1463
      if (i == 4) {
#line 1463
        goto case_4___0;
      }
#line 1441
      goto switch_break___0;
      case_0___0: /* CIL Label */ 
#line 1443
      d___0->density = (unsigned char)0;
#line 1444
      d___0->enable_cdda = & Dummy;
#line 1445
      es = (char *)"none    ";
#line 1446
      if (! densitypossible) {
#line 1446
        i = 5;
      }
#line 1447
      goto switch_break___0;
      case_1___0: /* CIL Label */ 
#line 1449
      d___0->density = (unsigned char)0;
#line 1450
      d___0->enable_cdda = & scsi_enable_cdda;
#line 1451
      es = (char *)"yes/0x00";
#line 1452
      goto switch_break___0;
      case_2___0: /* CIL Label */ 
#line 1454
      d___0->density = (unsigned char)4;
#line 1455
      d___0->enable_cdda = & scsi_enable_cdda;
#line 1456
      es = (char *)"yes/0x04";
#line 1457
      goto switch_break___0;
      case_3___0: /* CIL Label */ 
#line 1459
      d___0->density = (unsigned char)130;
#line 1460
      d___0->enable_cdda = & scsi_enable_cdda;
#line 1461
      es = (char *)"yes/0x82";
#line 1462
      goto switch_break___0;
      case_4___0: /* CIL Label */ 
#line 1464
      d___0->density = (unsigned char)129;
#line 1465
      d___0->enable_cdda = & scsi_enable_cdda;
#line 1466
      es = (char *)"yes/0x81";
#line 1467
      goto switch_break___0;
      switch_break___0: /* CIL Label */ ;
      }
      {
#line 1470
      cdmessage(d___0, "\ttest -> density: [");
#line 1471
      cdmessage(d___0, (char const   *)es);
#line 1472
      cdmessage(d___0, "]  command: [");
#line 1473
      cdmessage(d___0, (char const   *)rs___0);
#line 1474
      cdmessage(d___0, "]\n");
#line 1477
      densityflag = 0;
#line 1478
      rejectflag = 0;
#line 1479
      zeroflag = 0;
#line 1480
      lengthflag = 0;
#line 1482
      tmp___11 = (*(d___0->enable_cdda))(d___0, 1);
      }
#line 1482
      if (tmp___11 == 0) {
#line 1483
        k = 1;
        {
#line 1483
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 1483
          if (! (k <= d___0->tracks)) {
#line 1483
            goto while_break___2;
          }
          {
#line 1484
          tmp___10 = cdda_track_audiop(d___0, k);
          }
#line 1484
          if (tmp___10 == 1) {
            {
#line 1485
            tmp___6 = cdda_track_firstsector(d___0, k);
#line 1485
            firstsector___0 = tmp___6;
#line 1486
            tmp___7 = cdda_track_lastsector(d___0, k);
#line 1486
            lastsector___0 = tmp___7;
#line 1487
            sector___0 = (firstsector___0 + lastsector___0) >> 1;
#line 1489
            tmp___9 = (*(d___0->read_audio))(d___0, (void *)buff, sector___0, 1L);
            }
#line 1489
            if (tmp___9 > 0L) {
              {
#line 1490
              lengthflag = count_2352_bytes(d___0);
              }
#line 1490
              if (lengthflag == 2352) {
                {
#line 1491
                tmp___8 = verify_nonzero(d___0);
                }
#line 1491
                if (tmp___8) {
                  {
#line 1492
                  cdmessage(d___0, "\t\tCommand set FOUND!\n");
#line 1494
                  free((void *)buff);
#line 1495
                  (*(d___0->enable_cdda))(d___0, 0);
                  }
#line 1496
                  return (0);
                } else {
#line 1498
                  zeroflag ++;
                }
              }
            } else {
#line 1502
              rejectflag ++;
#line 1503
              goto while_break___2;
            }
          }
#line 1483
          k ++;
        }
        while_break___2: /* CIL Label */ ;
        }
        {
#line 1507
        (*(d___0->enable_cdda))(d___0, 0);
        }
      } else {
#line 1509
        densityflag ++;
      }
#line 1512
      if (densityflag) {
        {
#line 1513
        cdmessage(d___0, "\t\tDrive rejected density set\n");
        }
      }
#line 1514
      if (rejectflag) {
        {
#line 1516
        sprintf((char */* __restrict  */)(buffer), (char const   */* __restrict  */)"\t\tDrive rejected read command packet(s)\n");
#line 1517
        cdmessage(d___0, (char const   *)(buffer));
        }
      }
#line 1519
      if (lengthflag > 0) {
#line 1519
        if (lengthflag < 2352) {
          {
#line 1521
          sprintf((char */* __restrict  */)(buffer___0), (char const   */* __restrict  */)"\t\tDrive returned at least one packet, but with\n\t\tincorrect size (%d)\n",
                  lengthflag);
#line 1523
          cdmessage(d___0, (char const   *)(buffer___0));
          }
        }
      }
#line 1525
      if (zeroflag) {
        {
#line 1527
        sprintf((char */* __restrict  */)(buffer___1), (char const   */* __restrict  */)"\t\tDrive returned %d packet(s), but contents\n\t\twere entirely zero\n",
                zeroflag);
#line 1529
        cdmessage(d___0, (char const   *)(buffer___1));
        }
      }
#line 1440
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 1361
    j ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 1536
  d___0->density = density;
#line 1537
  d___0->read_audio = readcommand;
#line 1538
  d___0->enable_cdda = enablecommand;
#line 1540
  cdmessage(d___0, "\tUnable to find any suitable command set from probe;\n\tdrive probably not CDDA capable.\n");
#line 1543
  cderror___0(d___0, "006: Could not read any data from drive\n");
#line 1546
  free((void *)buff);
  }
#line 1547
  return (-6);
}
}
#line 1550 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/interface/scsi_interface.c"
static void check_cache(cdrom_drive *d___0 ) 
{ 
  long i ;
  long firstsector ;
  long tmp ;
  long lastsector ;
  long tmp___0 ;
  long sector ;
  long tmp___1 ;
  int tmp___2 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;

  {
#line 1553
  if (! ((unsigned long )d___0->read_audio == (unsigned long )(& scsi_read_mmc))) {
#line 1553
    if (! ((unsigned long )d___0->read_audio == (unsigned long )(& scsi_read_mmc2))) {
#line 1553
      if (! ((unsigned long )d___0->read_audio == (unsigned long )(& scsi_read_mmc3))) {
#line 1553
        if (! ((unsigned long )d___0->read_audio == (unsigned long )(& scsi_read_mmcB))) {
#line 1553
          if (! ((unsigned long )d___0->read_audio == (unsigned long )(& scsi_read_mmc2B))) {
#line 1553
            if (! ((unsigned long )d___0->read_audio == (unsigned long )(& scsi_read_mmc3B))) {
              {
#line 1560
              cdmessage(d___0, "This command set may use a Force Unit Access bit.");
#line 1561
              cdmessage(d___0, "\nChecking drive for FUA bit support...\n");
#line 1563
              (*(d___0->enable_cdda))(d___0, 1);
#line 1564
              d___0->fua = 1;
#line 1566
              i = 1L;
              }
              {
#line 1566
              while (1) {
                while_continue: /* CIL Label */ ;
#line 1566
                if (! (i <= (long )d___0->tracks)) {
#line 1566
                  goto while_break;
                }
                {
#line 1567
                tmp___2 = cdda_track_audiop(d___0, (int )i);
                }
#line 1567
                if (tmp___2 == 1) {
                  {
#line 1568
                  tmp = cdda_track_firstsector(d___0, (int )i);
#line 1568
                  firstsector = tmp;
#line 1569
                  tmp___0 = cdda_track_lastsector(d___0, (int )i);
#line 1569
                  lastsector = tmp___0;
#line 1570
                  sector = (firstsector + lastsector) >> 1;
#line 1572
                  tmp___1 = (*(d___0->read_audio))(d___0, (void *)0, sector, 1L);
                  }
#line 1572
                  if (tmp___1 > 0L) {
                    {
#line 1573
                    cdmessage(d___0, "\tDrive accepted FUA bit.\n");
#line 1574
                    (*(d___0->enable_cdda))(d___0, 0);
                    }
#line 1575
                    return;
                  }
                }
#line 1566
                i ++;
              }
              while_break: /* CIL Label */ ;
              }
              {
#line 1580
              d___0->fua = 0;
#line 1581
              cdmessage(d___0, "\tDrive rejected FUA bit.\n");
              }
#line 1586
              return;
            }
          }
        }
      }
    }
  }
#line 1588
  return;
}
}
#line 1590 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/interface/scsi_interface.c"
static int check_atapi(cdrom_drive *d___0 ) 
{ 
  int atapiret ;
  int fd ;
  int tmp ;
  int tmp___0 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;

  {
  {
#line 1591
  atapiret = -1;
#line 1592
  fd = d___0->cdda_fd;
#line 1594
  cdmessage(d___0, "\nChecking for SCSI emulation...\n");
#line 1596
  tmp___0 = ioctl(fd, 8707UL, & atapiret);
  }
#line 1596
  if (tmp___0) {
    {
#line 1597
    cderror___0(d___0, "\tSG_EMULATED_HOST ioctl() failed!\n");
    }
#line 1598
    return (-1);
  } else {
#line 1600
    if (atapiret == 1) {
#line 1601
      if (d___0->interface == 3) {
        {
#line 1602
        cdmessage(d___0, "\tDrive is ATAPI (using SG_IO host adaptor emulation)\n");
        }
      } else
#line 1603
      if (d___0->interface == 4) {
        {
#line 1604
        cdmessage(d___0, "\tDrive is ATAPI (using SG_IO host adaptor emulation with workarounds)\n");
        }
      } else {
        {
#line 1606
        cdmessage(d___0, "\tDrive is ATAPI (using SCSI host adaptor emulation)\n");
#line 1608
        tmp = ioctl(fd, 8708UL, 0);
        }
#line 1608
        if (tmp) {
          {
#line 1609
          cderror___0(d___0, "\tCouldn\'t disable kernel command translation layer\n");
          }
        }
      }
#line 1611
      d___0->is_atapi = 1;
    } else {
      {
#line 1613
      cdmessage(d___0, "\tDrive is SCSI\n");
#line 1614
      d___0->is_atapi = 0;
      }
    }
#line 1617
    return (d___0->is_atapi);
  }
}
}
#line 1621 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/interface/scsi_interface.c"
static int check_mmc(cdrom_drive *d___0 ) 
{ 
  unsigned char *b ;
  int tmp ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
  {
#line 1623
  cdmessage(d___0, "\nChecking for MMC style command set...\n");
#line 1625
  d___0->is_mmc = 0;
#line 1626
  tmp = mode_sense(d___0, 22, 42);
  }
#line 1626
  if (tmp == 0) {
#line 1628
    b = (d___0->private)->sg_buffer;
#line 1629
    b += (int )*(b + 3) + 4;
#line 1631
    if (((int )*(b + 0) & 63) == 42) {
#line 1633
      d___0->is_mmc = 1;
#line 1635
      if ((int )*(b + 1) >= 4) {
#line 1636
        if ((int )*(b + 5) & 1) {
          {
#line 1637
          cdmessage(d___0, "\tDrive is MMC style\n");
          }
#line 1638
          return (1);
        } else {
          {
#line 1640
          cdmessage(d___0, "\tDrive is MMC, but reports CDDA incapable.\n");
#line 1641
          cdmessage(d___0, "\tIt will likely not be able to read audio data.\n");
          }
#line 1642
          return (1);
        }
      }
    }
  }
  {
#line 1648
  cdmessage(d___0, "\tDrive does not have MMC CDDA support\n");
  }
#line 1649
  return (0);
}
}
#line 1652 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/interface/scsi_interface.c"
static void check_exceptions(cdrom_drive *d___0 , exception *list ) 
{ 
  int i ;
  size_t tmp ;
  int tmp___0 ;

  {
#line 1654
  i = 0;
  {
#line 1655
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1655
    if (! (list + i)->model) {
#line 1655
      goto while_break;
    }
    {
#line 1656
    tmp = strlen((char const   *)(list + i)->model);
#line 1656
    tmp___0 = strncmp((char const   *)(list + i)->model, (char const   *)d___0->drive_model,
                      tmp);
    }
#line 1656
    if (! tmp___0) {
#line 1657
      if ((list + i)->density) {
#line 1657
        d___0->density = (list + i)->density;
      }
#line 1658
      if ((list + i)->enable) {
#line 1658
        d___0->enable_cdda = (list + i)->enable;
      }
#line 1659
      if ((list + i)->read) {
#line 1659
        d___0->read_audio = (list + i)->read;
      }
#line 1660
      if ((list + i)->bigendianp != -1) {
#line 1660
        d___0->bigendianp = (list + i)->bigendianp;
      }
#line 1661
      return;
    }
#line 1663
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1665
  return;
}
}
#line 1668 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/interface/scsi_interface.c"
unsigned char *scsi_inquiry(cdrom_drive *d___0 ) 
{ 
  unsigned char sense[16] ;
  unsigned char cmd[6] ;
  int tmp ;
  void *__cil_tmp5 ;
  void *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
  {
#line 1670
  cmd[0] = (unsigned char)18;
#line 1670
  cmd[1] = (unsigned char)0;
#line 1670
  cmd[2] = (unsigned char)0;
#line 1670
  cmd[3] = (unsigned char)0;
#line 1670
  cmd[4] = (unsigned char)56;
#line 1670
  cmd[5] = (unsigned char)0;
#line 1672
  tmp = handle_scsi_cmd(d___0, cmd, 6U, 0U, 56U, (unsigned char )'\377', 1, sense);
  }
#line 1672
  if (tmp) {
    {
#line 1673
    cderror___0(d___0, "008: Unable to identify CDROM model\n");
    }
#line 1674
    return ((unsigned char *)((void *)0));
  }
#line 1676
  return ((d___0->private)->sg_buffer);
}
}
#line 1679 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/interface/scsi_interface.c"
int scsi_init_drive(cdrom_drive *d___0 ) 
{ 
  int ret ;
  int tmp___0 ;
  unsigned int sector_size ;
  unsigned int tmp___1 ;
  int tmp___2 ;
  void *tmp___3 ;
  char *__cil_tmp9 ;

  {
  {
#line 1682
  check_atapi(d___0);
#line 1683
  check_mmc(d___0);
#line 1686
  d___0->density = (unsigned char)0;
#line 1687
  d___0->enable_cdda = & Dummy;
#line 1688
  d___0->read_audio = & scsi_read_D8;
#line 1689
  d___0->fua = 0;
  }
#line 1690
  if (d___0->is_atapi) {
#line 1690
    d___0->lun = 0;
  }
#line 1692
  if (d___0->is_mmc) {
    {
#line 1694
    d___0->read_audio = & scsi_read_mmc2B;
#line 1695
    d___0->bigendianp = 0;
#line 1697
    check_exceptions(d___0, mmc_list);
    }
  } else
#line 1701
  if (d___0->is_atapi) {
    {
#line 1704
    d___0->read_audio = & scsi_read_mmc2B;
#line 1705
    d___0->bigendianp = 0;
#line 1707
    check_exceptions(d___0, atapi_list);
    }
  } else {
    {
#line 1711
    check_exceptions(d___0, scsi_list);
    }
  }
#line 1716
  if (! d___0->is_atapi) {
    {
#line 1716
    set_sectorsize(d___0, 2048U);
    }
  }
  {
#line 1718
  (*(d___0->enable_cdda))(d___0, 0);
#line 1720
  tmp___0 = memcmp((void const   *)d___0->drive_model, (void const   *)"IMS", (size_t )3);
  }
#line 1720
  if (tmp___0) {
#line 1720
    d___0->read_toc = & scsi_read_toc;
  } else
#line 1720
  if (! d___0->is_atapi) {
#line 1720
    d___0->read_toc = & scsi_read_toc2;
  } else {
#line 1720
    d___0->read_toc = & scsi_read_toc;
  }
#line 1722
  d___0->set_speed = & scsi_set_speed;
#line 1724
  if (! d___0->is_atapi) {
    {
#line 1725
    tmp___1 = get_orig_sectorsize(d___0);
#line 1725
    sector_size = tmp___1;
    }
#line 1727
    if (sector_size < 2048U) {
      {
#line 1727
      tmp___2 = set_sectorsize(d___0, 2048U);
      }
#line 1727
      if (tmp___2) {
#line 1728
        d___0->adjust_ssize = (int )(2048U / sector_size);
      } else {
#line 1730
        d___0->adjust_ssize = 1;
      }
    } else {
#line 1730
      d___0->adjust_ssize = 1;
    }
  } else {
#line 1732
    d___0->adjust_ssize = 1;
  }
  {
#line 1734
  d___0->tracks = (*(d___0->read_toc))(d___0);
  }
#line 1735
  if (d___0->tracks < 1) {
#line 1736
    return (d___0->tracks);
  }
  {
#line 1738
  tweak_SG_buffer(d___0);
#line 1739
  d___0->opened = 1;
#line 1741
  ret = verify_read_command(d___0);
  }
#line 1741
  if (ret) {
#line 1741
    return (ret);
  }
  {
#line 1742
  check_cache(d___0);
#line 1744
  d___0->error_retry = 1;
#line 1745
  tmp___3 = realloc((void *)(d___0->private)->sg_hd, (size_t )(((unsigned long )(d___0->nsectors * 2352) + sizeof(struct sg_header )) + 128UL));
#line 1745
  (d___0->private)->sg_hd = (struct sg_header *)tmp___3;
#line 1746
  (d___0->private)->sg_buffer = (unsigned char *)(d___0->private)->sg_hd + sizeof(struct sg_header );
#line 1747
  d___0->report_all = 1;
  }
#line 1748
  return (0);
}
}
#line 350 "/usr/include/unistd.h"
extern int close(int __fd ) ;
#line 124 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/interface/cdda_interface.h"
char *cdda_version(void) ;
#line 125
int cdda_speed_set(cdrom_drive *d___0 , int speed ) ;
#line 126
void cdda_verbose_set(cdrom_drive *d___0 , int err_action , int mes_action ) ;
#line 127
extern char *cdda_messages(cdrom_drive *d___0 ) ;
#line 128
extern char *cdda_errors(cdrom_drive *d___0 ) ;
#line 130
int cdda_close(cdrom_drive *d___0 ) ;
#line 131
int cdda_open(cdrom_drive *d___0 ) ;
#line 132
long cdda_read(cdrom_drive *d___0 , void *buffer , long beginsector , long sectors ) ;
#line 134
long cdda_read_timed(cdrom_drive *d___0 , void *buffer , long beginsector , long sectors ,
                     int *ms ) ;
#line 112 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/interface/low_interface.h"
int cooked_init_drive(cdrom_drive *d___0 ) ;
#line 14 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/interface/common_interface.h"
int data_bigendianp(cdrom_drive *d___0 ) ;
#line 9 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/interface/utils.h"
__inline static int bigendianp(void) 
{ 
  int test ;
  char *hack ;

  {
#line 10
  test = 1;
#line 11
  hack = (char *)(& test);
#line 12
  if (*(hack + 0)) {
#line 12
    return (0);
  }
#line 13
  return (1);
}
}
#line 23 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/interface/utils.h"
__inline static int16_t swap16(int16_t x ) 
{ 


  {
#line 24
  return ((int16_t )((((unsigned int )((u_int16_t )x) & 255U) << 8) | (((unsigned int )((u_int16_t )x) & 65280U) >> 8)));
}
}
#line 104 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/interface/utils.h"
static void cderror___1(cdrom_drive *d___0 , char const   *s ) 
{ 
  size_t tmp ;

  {
#line 105
  if (s) {
#line 105
    if (d___0) {
      {
#line 107
      if (d___0->errordest == 1) {
#line 107
        goto case_1;
      }
#line 110
      if (d___0->errordest == 2) {
#line 110
        goto case_2;
      }
#line 114
      goto switch_default;
      case_1: /* CIL Label */ 
      {
#line 108
      tmp = strlen(s);
#line 108
      write(2, (void const   *)s, tmp);
      }
#line 109
      goto switch_break;
      case_2: /* CIL Label */ 
      {
#line 111
      d___0->errorbuf = catstring(d___0->errorbuf, s);
      }
#line 112
      goto switch_break;
      switch_default: /* CIL Label */ 
#line 115
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    }
  }
#line 118
  return;
}
}
#line 17 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/interface/interface.c"
char *cdda_version(void) 
{ 
  char *__cil_tmp1 ;

  {
#line 18
  return ((char *)"10.2");
}
}
#line 21 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/interface/interface.c"
static void _clean_messages(cdrom_drive *d___0 ) 
{ 


  {
#line 22
  if (d___0) {
#line 23
    if (d___0->messagebuf) {
      {
#line 23
      free((void *)d___0->messagebuf);
      }
    }
#line 24
    if (d___0->errorbuf) {
      {
#line 24
      free((void *)d___0->errorbuf);
      }
    }
#line 25
    d___0->messagebuf = (char *)((void *)0);
#line 26
    d___0->errorbuf = (char *)((void *)0);
  }
#line 28
  return;
}
}
#line 31 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/interface/interface.c"
int cdda_close(cdrom_drive *d___0 ) 
{ 


  {
#line 32
  if (d___0) {
#line 33
    if (d___0->opened) {
      {
#line 34
      (*(d___0->enable_cdda))(d___0, 0);
      }
    }
    {
#line 36
    _clean_messages(d___0);
    }
#line 37
    if (d___0->cdda_device_name) {
      {
#line 37
      free((void *)d___0->cdda_device_name);
      }
    }
#line 38
    if (d___0->ioctl_device_name) {
      {
#line 38
      free((void *)d___0->ioctl_device_name);
      }
    }
#line 39
    if (d___0->drive_model) {
      {
#line 39
      free((void *)d___0->drive_model);
      }
    }
#line 40
    if (d___0->cdda_fd != -1) {
      {
#line 40
      close(d___0->cdda_fd);
      }
    }
#line 41
    if (d___0->ioctl_fd != -1) {
#line 41
      if (d___0->ioctl_fd != d___0->cdda_fd) {
        {
#line 41
        close(d___0->ioctl_fd);
        }
      }
    }
#line 42
    if (d___0->private) {
#line 43
      if ((d___0->private)->sg_hd) {
        {
#line 43
        free((void *)(d___0->private)->sg_hd);
        }
      }
      {
#line 44
      free((void *)d___0->private);
      }
    }
    {
#line 47
    free((void *)d___0);
    }
  }
#line 49
  return (0);
}
}
#line 53 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/interface/interface.c"
int cdda_open(cdrom_drive *d___0 ) 
{ 
  int ret ;
  int i ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
#line 55
  if (d___0->opened) {
#line 55
    return (0);
  }
  {
#line 60
  if (d___0->interface == 0) {
#line 60
    goto case_0;
  }
#line 60
  if (d___0->interface == 3) {
#line 60
    goto case_0;
  }
#line 60
  if (d___0->interface == 4) {
#line 60
    goto case_0;
  }
#line 64
  if (d___0->interface == 1) {
#line 64
    goto case_1;
  }
#line 74
  goto switch_default;
  case_0: /* CIL Label */ 
  case_3: /* CIL Label */ 
  case_4: /* CIL Label */ 
  {
#line 61
  ret = scsi_init_drive(d___0);
  }
#line 61
  if (ret) {
#line 62
    return (ret);
  }
#line 63
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 65
  ret = cooked_init_drive(d___0);
  }
#line 65
  if (ret) {
#line 66
    return (ret);
  }
#line 67
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 75
  cderror___1(d___0, "100: Interface not supported\n");
  }
#line 76
  return (-100);
  switch_break: /* CIL Label */ ;
  }
#line 84
  i = 0;
  {
#line 84
  while (1) {
    while_continue: /* CIL Label */ ;
#line 84
    if (! (i < d___0->tracks)) {
#line 84
      goto while_break;
    }
#line 85
    if (d___0->disc_toc[i].dwStartSector < 0) {
      {
#line 87
      d___0->opened = 0;
#line 88
      cderror___1(d___0, "009: CDROM reporting illegal table of contents\n");
      }
#line 89
      return (-9);
    } else
#line 85
    if (d___0->disc_toc[i + 1].dwStartSector == 0) {
      {
#line 87
      d___0->opened = 0;
#line 88
      cderror___1(d___0, "009: CDROM reporting illegal table of contents\n");
      }
#line 89
      return (-9);
    }
#line 84
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 93
  ret = (*(d___0->enable_cdda))(d___0, 1);
  }
#line 93
  if (ret) {
#line 94
    return (ret);
  }
#line 97
  if (d___0->bigendianp == -1) {
    {
#line 97
    d___0->bigendianp = data_bigendianp(d___0);
    }
  }
#line 98
  return (0);
}
}
#line 101 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/interface/interface.c"
int cdda_speed_set(cdrom_drive *d___0 , int speed ) 
{ 
  int tmp ;
  char *__cil_tmp4 ;

  {
#line 103
  if (d___0->set_speed) {
    {
#line 104
    tmp = (*(d___0->set_speed))(d___0, speed);
    }
#line 104
    if (! tmp) {
#line 104
      return (0);
    }
  }
  {
#line 106
  cderror___1(d___0, "405: Option not supported by drive\n");
  }
#line 107
  return (-405);
}
}
#line 110 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/interface/interface.c"
long cdda_read_timed(cdrom_drive *d___0 , void *buffer , long beginsector , long sectors ,
                     int *ms ) 
{ 
  int i ;
  u_int16_t *p___0 ;
  long els ;
  int16_t tmp ;
  int tmp___0 ;
  char *__cil_tmp11 ;

  {
#line 111
  if (ms) {
#line 111
    *ms = -1;
  }
#line 112
  if (d___0->opened) {
#line 113
    if (sectors > 0L) {
      {
#line 114
      sectors = (*(d___0->read_audio))(d___0, buffer, beginsector, sectors);
      }
#line 116
      if (sectors > 0L) {
#line 118
        if (d___0->bigendianp == -1) {
          {
#line 119
          d___0->bigendianp = data_bigendianp(d___0);
          }
        }
        {
#line 121
        tmp___0 = bigendianp();
        }
#line 121
        if (d___0->bigendianp != tmp___0) {
#line 123
          p___0 = (u_int16_t *)buffer;
#line 124
          els = (sectors * 2352L) / 2L;
#line 126
          i = 0;
          {
#line 126
          while (1) {
            while_continue: /* CIL Label */ ;
#line 126
            if (! ((long )i < els)) {
#line 126
              goto while_break;
            }
            {
#line 126
            tmp = swap16((int16_t )*(p___0 + i));
#line 126
            *(p___0 + i) = (u_int16_t )tmp;
#line 126
            i ++;
            }
          }
          while_break: /* CIL Label */ ;
          }
        }
      }
    }
#line 130
    if (ms) {
#line 130
      *ms = (d___0->private)->last_milliseconds;
    }
#line 131
    return (sectors);
  }
  {
#line 134
  cderror___1(d___0, "400: Device not open\n");
  }
#line 135
  return (-400L);
}
}
#line 138 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/interface/interface.c"
long cdda_read(cdrom_drive *d___0 , void *buffer , long beginsector , long sectors ) 
{ 
  long tmp ;

  {
  {
#line 139
  tmp = cdda_read_timed(d___0, buffer, beginsector, sectors, (int *)((void *)0));
  }
#line 139
  return (tmp);
}
}
#line 142 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/interface/interface.c"
void cdda_verbose_set(cdrom_drive *d___0 , int err_action , int mes_action ) 
{ 


  {
#line 143
  d___0->messagedest = mes_action;
#line 144
  d___0->errordest = err_action;
#line 145
  return;
}
}
#line 147 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/interface/interface.c"
extern char *cdda_messages(cdrom_drive *d___0 ) 
{ 
  char *ret ;

  {
#line 148
  ret = d___0->messagebuf;
#line 149
  d___0->messagebuf = (char *)((void *)0);
#line 150
  return (ret);
}
}
#line 153 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/interface/interface.c"
extern char *cdda_errors(cdrom_drive *d___0 ) 
{ 
  char *ret ;

  {
#line 154
  ret = d___0->errorbuf;
#line 155
  d___0->errorbuf = (char *)((void *)0);
#line 156
  return (ret);
}
}
#line 104 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/interface/utils.h"
static void cderror___2(cdrom_drive *d___0 , char const   *s ) 
{ 
  size_t tmp ;

  {
#line 105
  if (s) {
#line 105
    if (d___0) {
      {
#line 107
      if (d___0->errordest == 1) {
#line 107
        goto case_1;
      }
#line 110
      if (d___0->errordest == 2) {
#line 110
        goto case_2;
      }
#line 114
      goto switch_default;
      case_1: /* CIL Label */ 
      {
#line 108
      tmp = strlen(s);
#line 108
      write(2, (void const   *)s, tmp);
      }
#line 109
      goto switch_break;
      case_2: /* CIL Label */ 
      {
#line 111
      d___0->errorbuf = catstring(d___0->errorbuf, s);
      }
#line 112
      goto switch_break;
      switch_default: /* CIL Label */ 
#line 115
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    }
  }
#line 118
  return;
}
}
#line 120 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/interface/utils.h"
static void cdmessage___0(cdrom_drive *d___0 , char const   *s ) 
{ 
  size_t tmp ;

  {
#line 121
  if (s) {
#line 121
    if (d___0) {
      {
#line 123
      if (d___0->messagedest == 1) {
#line 123
        goto case_1;
      }
#line 126
      if (d___0->messagedest == 2) {
#line 126
        goto case_2;
      }
#line 130
      goto switch_default;
      case_1: /* CIL Label */ 
      {
#line 124
      tmp = strlen(s);
#line 124
      write(2, (void const   *)s, tmp);
      }
#line 125
      goto switch_break;
      case_2: /* CIL Label */ 
      {
#line 127
      d___0->messagebuf = catstring(d___0->messagebuf, s);
      }
#line 128
      goto switch_break;
      switch_default: /* CIL Label */ 
#line 131
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    }
  }
#line 134
  return;
}
}
#line 13 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/interface/cooked_interface.c"
static int timed_ioctl___0(cdrom_drive *d___0 , int fd , int command , void *arg ) 
{ 
  struct timespec tv1 ;
  struct timespec tv2 ;
  int ret1 ;
  int tmp ;
  int ret2 ;
  int tmp___0 ;
  int ret3 ;
  int tmp___1 ;

  {
  {
#line 16
  tmp = clock_gettime((d___0->private)->clock, & tv1);
#line 16
  ret1 = tmp;
#line 17
  tmp___0 = ioctl(fd, (unsigned long )command, arg);
#line 17
  ret2 = tmp___0;
#line 18
  tmp___1 = clock_gettime((d___0->private)->clock, & tv2);
#line 18
  ret3 = tmp___1;
  }
#line 19
  if (ret1 < 0) {
#line 20
    (d___0->private)->last_milliseconds = -1;
  } else
#line 19
  if (ret3 < 0) {
#line 20
    (d___0->private)->last_milliseconds = -1;
  } else {
#line 22
    (d___0->private)->last_milliseconds = (int )((double )(tv2.tv_sec - tv1.tv_sec) * 1000. + (double )(tv2.tv_nsec - tv1.tv_nsec) / 1000000.);
  }
#line 24
  return (ret2);
}
}
#line 27 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/interface/cooked_interface.c"
static int cooked_readtoc(cdrom_drive *d___0 ) 
{ 
  int i ;
  int tracks ;
  struct cdrom_tochdr hdr ;
  struct cdrom_tocentry entry ;
  int *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;

  {
  {
#line 34
  tmp___0 = ioctl(d___0->ioctl_fd, 21253UL, & hdr);
  }
#line 34
  if (tmp___0) {
    {
#line 35
    tmp = __errno_location();
    }
    {
#line 36
    if (*tmp == 1) {
#line 36
      goto case_1;
    }
#line 39
    goto switch_default;
    case_1: /* CIL Label */ 
    {
#line 37
    cderror___2(d___0, "102: Permision denied on cdrom (ioctl) device\n");
    }
#line 38
    return (-102);
    switch_default: /* CIL Label */ 
    {
#line 40
    cderror___2(d___0, "004: Unable to read table of contents header\n");
    }
#line 41
    return (-4);
    switch_break: /* CIL Label */ ;
    }
  }
#line 45
  i = 0;
  {
#line 45
  while (1) {
    while_continue: /* CIL Label */ ;
#line 45
    if (! (i < (int )hdr.cdth_trk1)) {
#line 45
      goto while_break;
    }
    {
#line 46
    entry.cdte_track = (__u8 )(i + 1);
#line 47
    entry.cdte_format = (__u8 )1;
#line 48
    tmp___1 = ioctl(d___0->ioctl_fd, 21254UL, & entry);
    }
#line 48
    if (tmp___1) {
      {
#line 49
      cderror___2(d___0, "005: Unable to read table of contents entry\n");
      }
#line 50
      return (-5);
    }
#line 53
    d___0->disc_toc[i].bFlags = (unsigned char )(((int )entry.cdte_adr << 4) | ((int )entry.cdte_ctrl & 15));
#line 54
    d___0->disc_toc[i].bTrack = (unsigned char )(i + 1);
#line 55
    d___0->disc_toc[i].dwStartSector = entry.cdte_addr.lba;
#line 45
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 58
  entry.cdte_track = (__u8 )170;
#line 59
  entry.cdte_format = (__u8 )1;
#line 60
  tmp___2 = ioctl(d___0->ioctl_fd, 21254UL, & entry);
  }
#line 60
  if (tmp___2) {
    {
#line 61
    cderror___2(d___0, "005: Unable to read table of contents entry\n");
    }
#line 62
    return (-5);
  }
  {
#line 64
  d___0->disc_toc[i].bFlags = (unsigned char )(((int )entry.cdte_adr << 4) | ((int )entry.cdte_ctrl & 15));
#line 65
  d___0->disc_toc[i].bTrack = entry.cdte_track;
#line 66
  d___0->disc_toc[i].dwStartSector = entry.cdte_addr.lba;
#line 68
  tracks = (int )hdr.cdth_trk1 + 1;
#line 69
  d___0->cd_extra = FixupTOC(d___0, tracks);
#line 70
  tracks --;
  }
#line 70
  return (tracks);
}
}
#line 74 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/interface/cooked_interface.c"
static int cooked_setspeed(cdrom_drive *d___0 , int speed ) 
{ 
  int tmp ;

  {
#line 76
  if (d___0->ioctl_fd != -1) {
    {
#line 77
    tmp = ioctl(d___0->ioctl_fd, 21282UL, speed);
    }
#line 77
    return (tmp);
  } else {
#line 79
    return (0);
  }
}
}
#line 86 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/interface/cooked_interface.c"
static long cooked_read(cdrom_drive *d___0 , void *p___0 , long begin , long sectors ) 
{ 
  int retry_count ;
  int err ;
  int ret ;
  struct cdrom_read_audio arg ;
  char *buffer ;
  void *tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  char b[256] ;
  void *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;

  {
#line 87
  ret = 0;
#line 89
  buffer = (char *)p___0;
#line 92
  if (sectors > (long )d___0->nsectors) {
#line 92
    sectors = (long )d___0->nsectors;
  } else {
#line 92
    sectors = sectors;
  }
#line 93
  if ((unsigned long )p___0 == (unsigned long )((void *)0)) {
    {
#line 93
    tmp = malloc((size_t )(sectors * 2352L));
#line 93
    buffer = (char *)tmp;
    }
  }
#line 95
  arg.addr.lba = (int )begin;
#line 96
  arg.addr_format = (__u8 )1;
#line 97
  arg.nframes = (int )sectors;
#line 98
  arg.buf = (__u8 *)buffer;
#line 99
  retry_count = 0;
  {
#line 101
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 102
    err = timed_ioctl___0(d___0, d___0->ioctl_fd, 21262, (void *)(& arg));
    }
#line 102
    if (err) {
#line 103
      if (! d___0->error_retry) {
#line 104
        ret = -7;
#line 105
        goto done;
      }
      {
#line 107
      tmp___0 = __errno_location();
      }
      {
#line 108
      if (*tmp___0 == 12) {
#line 108
        goto case_12;
      }
#line 118
      if (*tmp___0 == 123) {
#line 118
        goto case_123;
      }
#line 118
      if (*tmp___0 == 9) {
#line 118
        goto case_123;
      }
#line 118
      if (*tmp___0 == 6) {
#line 118
        goto case_123;
      }
#line 122
      goto switch_default;
      case_12: /* CIL Label */ 
#line 110
      if (sectors == 1L) {
        {
#line 112
        cderror___2(d___0, "300: Kernel memory error\n");
#line 113
        ret = -300;
        }
#line 114
        goto done;
      }
      case_123: /* CIL Label */ 
      case_9: /* CIL Label */ 
      case_6: /* CIL Label */ 
      {
#line 119
      tmp___1 = __errno_location();
#line 119
      *tmp___1 = 123;
#line 120
      ret = 0;
      }
#line 121
      goto done;
      switch_default: /* CIL Label */ 
#line 123
      if (sectors == 1L) {
#line 129
        if (retry_count > 7) {
          {
#line 131
          sprintf((char */* __restrict  */)(b), (char const   */* __restrict  */)"010: Unable to access sector %ld: skipping...\n",
                  begin);
#line 133
          cderror___2(d___0, (char const   *)(b));
#line 134
          ret = -10;
          }
#line 135
          goto done;
        }
#line 137
        goto switch_break;
      }
      switch_break: /* CIL Label */ ;
      }
#line 140
      if (retry_count > 4) {
#line 141
        if (sectors > 1L) {
#line 142
          sectors = (sectors * 3L) / 4L;
        }
      }
#line 143
      retry_count ++;
#line 144
      if (retry_count > 8) {
        {
#line 145
        cderror___2(d___0, "007: Unknown, unrecoverable error reading data\n");
#line 146
        ret = -7;
        }
#line 147
        goto done;
      }
    } else {
#line 150
      goto while_break;
    }
#line 101
    if (! err) {
#line 101
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 153
  ret = (int )sectors;
  done: 
#line 156
  if ((unsigned long )p___0 == (unsigned long )((void *)0)) {
#line 156
    if (buffer) {
      {
#line 156
      free((void *)buffer);
      }
    }
  }
#line 157
  return ((long )ret);
}
}
#line 161 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/interface/cooked_interface.c"
static int Dummy___0(cdrom_drive *d___0 , int Switch ) 
{ 


  {
#line 162
  return (0);
}
}
#line 165 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/interface/cooked_interface.c"
static int verify_read_command___0(cdrom_drive *d___0 ) 
{ 
  int i ;
  int16_t *buff ;
  void *tmp ;
  int audioflag ;
  long firstsector ;
  long tmp___0 ;
  long lastsector ;
  long tmp___1 ;
  long sector ;
  long tmp___2 ;
  int tmp___3 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;

  {
  {
#line 167
  tmp = malloc((size_t )2352);
#line 167
  buff = (int16_t *)tmp;
#line 168
  audioflag = 0;
#line 170
  cdmessage___0(d___0, "Verifying drive can read CDDA...\n");
#line 172
  (*(d___0->enable_cdda))(d___0, 1);
#line 174
  i = 1;
  }
  {
#line 174
  while (1) {
    while_continue: /* CIL Label */ ;
#line 174
    if (! (i <= d___0->tracks)) {
#line 174
      goto while_break;
    }
    {
#line 175
    tmp___3 = cdda_track_audiop(d___0, i);
    }
#line 175
    if (tmp___3 == 1) {
      {
#line 176
      tmp___0 = cdda_track_firstsector(d___0, i);
#line 176
      firstsector = tmp___0;
#line 177
      tmp___1 = cdda_track_lastsector(d___0, i);
#line 177
      lastsector = tmp___1;
#line 178
      sector = (firstsector + lastsector) >> 1;
#line 179
      audioflag = 1;
#line 181
      tmp___2 = (*(d___0->read_audio))(d___0, (void *)buff, sector, 1L);
      }
#line 181
      if (tmp___2 > 0L) {
        {
#line 182
        cdmessage___0(d___0, "\tExpected command set reads OK.\n");
#line 183
        (*(d___0->enable_cdda))(d___0, 0);
#line 184
        free((void *)buff);
        }
#line 185
        return (0);
      }
    }
#line 174
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 190
  (*(d___0->enable_cdda))(d___0, 0);
  }
#line 192
  if (! audioflag) {
    {
#line 193
    cdmessage___0(d___0, "\tCould not find any audio tracks on this disk.\n");
    }
#line 194
    return (-403);
  }
  {
#line 197
  cdmessage___0(d___0, "\n\tUnable to read any data; drive probably not CDDA capable.\n");
#line 200
  cderror___2(d___0, "006: Could not read any data from drive\n");
#line 202
  free((void *)buff);
  }
#line 203
  return (-6);
}
}
#line 24 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/interface/drive_exceptions.h"
static exception atapi_list___0[5]  = {      {(char *)"SAMSUNG SCR-830 REV 2.09 2.09 ", 1, (unsigned char)0, & Dummy___0,
      & scsi_read_mmc2, 0}, 
        {(char *)"Memorex CR-622", 1, (unsigned char)0, & Dummy___0, (long (*)(struct cdrom_drive * ,
                                                                            void * ,
                                                                            long  ,
                                                                            long  ))((void *)0),
      0}, 
        {(char *)"SONY CD-ROM CDU-561", 0, (unsigned char)0, & Dummy___0, (long (*)(struct cdrom_drive * ,
                                                                                 void * ,
                                                                                 long  ,
                                                                                 long  ))((void *)0),
      0}, 
        {(char *)"Chinon CD-ROM CDS-525", 0, (unsigned char)0, & Dummy___0, (long (*)(struct cdrom_drive * ,
                                                                                   void * ,
                                                                                   long  ,
                                                                                   long  ))((void *)0),
      0}, 
        {(char *)((void *)0), 0, (unsigned char)0, (int (*)(struct cdrom_drive * , int  ))((void *)0),
      (long (*)(struct cdrom_drive * , void * , long  , long  ))((void *)0), 0}};
#line 208 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/interface/cooked_interface.c"
static void check_exceptions___0(cdrom_drive *d___0 , exception *list ) 
{ 
  int i ;
  size_t tmp ;
  int tmp___0 ;

  {
#line 210
  i = 0;
  {
#line 211
  while (1) {
    while_continue: /* CIL Label */ ;
#line 211
    if (! (list + i)->model) {
#line 211
      goto while_break;
    }
    {
#line 212
    tmp = strlen((char const   *)(list + i)->model);
#line 212
    tmp___0 = strncmp((char const   *)(list + i)->model, (char const   *)d___0->drive_model,
                      tmp);
    }
#line 212
    if (! tmp___0) {
#line 213
      if ((list + i)->bigendianp != -1) {
#line 213
        d___0->bigendianp = (list + i)->bigendianp;
      }
#line 214
      return;
    }
#line 216
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 218
  return;
}
}
#line 221 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/interface/cooked_interface.c"
int cooked_init_drive(cdrom_drive *d___0 ) 
{ 
  int ret ;
  char buffer[256] ;
  char buffer___0[256] ;
  int tmp ;
  int tmp___0 ;
  void *__cil_tmp7 ;
  void *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
  {
#line 228
  if (d___0->drive_type == 28) {
#line 228
    goto case_28;
  }
#line 228
  if (d___0->drive_type == 27) {
#line 228
    goto case_28;
  }
#line 228
  if (d___0->drive_type == 26) {
#line 228
    goto case_28;
  }
#line 228
  if (d___0->drive_type == 25) {
#line 228
    goto case_28;
  }
#line 262
  if (d___0->drive_type == 34) {
#line 262
    goto case_34;
  }
#line 262
  if (d___0->drive_type == 33) {
#line 262
    goto case_34;
  }
#line 262
  if (d___0->drive_type == 22) {
#line 262
    goto case_34;
  }
#line 262
  if (d___0->drive_type == 3) {
#line 262
    goto case_34;
  }
#line 271
  goto switch_default;
  case_28: /* CIL Label */ 
  case_27: /* CIL Label */ 
  case_26: /* CIL Label */ 
  case_25: /* CIL Label */ 
  {
#line 231
  cdmessage___0(d___0, "Attempting to set sbpcd buffer size...\n");
#line 233
  d___0->nsectors = 8;
  }
  {
#line 234
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 239
    tmp = ioctl(d___0->ioctl_fd, 21378UL, d___0->nsectors);
    }
#line 239
    if (tmp == 0) {
#line 240
      d___0->nsectors >>= 1;
#line 241
      if (d___0->nsectors == 0) {
        {
#line 243
        d___0->nsectors = 8;
#line 244
        sprintf((char */* __restrict  */)(buffer), (char const   */* __restrict  */)"\tTrouble setting buffer size.  Defaulting to %d sectors.\n",
                d___0->nsectors);
#line 246
        cdmessage___0(d___0, (char const   *)(buffer));
        }
#line 247
        goto while_break;
      }
    } else {
      {
#line 251
      sprintf((char */* __restrict  */)(buffer___0), (char const   */* __restrict  */)"\tSetting read block size at %d sectors (%ld bytes).\n",
              d___0->nsectors, (long )d___0->nsectors * 2352L);
#line 253
      cdmessage___0(d___0, (char const   *)(buffer___0));
      }
#line 254
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 258
  goto switch_break;
  case_34: /* CIL Label */ 
  case_33: /* CIL Label */ 
  case_22: /* CIL Label */ 
  case_3: /* CIL Label */ 
  {
#line 263
  d___0->nsectors = 8;
#line 265
  d___0->bigendianp = 0;
#line 266
  d___0->is_atapi = 1;
#line 268
  check_exceptions___0(d___0, atapi_list___0);
  }
#line 270
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 272
  d___0->nsectors = 40;
  switch_break: /* CIL Label */ ;
  }
  {
#line 274
  d___0->enable_cdda = & Dummy___0;
#line 275
  d___0->read_audio = & cooked_read;
#line 276
  d___0->read_toc = & cooked_readtoc;
#line 277
  d___0->set_speed = & cooked_setspeed;
#line 278
  tmp___0 = (*(d___0->read_toc))(d___0);
#line 278
  d___0->tracks = tmp___0;
#line 278
  ret = tmp___0;
  }
#line 279
  if (d___0->tracks < 1) {
#line 280
    return (ret);
  }
  {
#line 282
  d___0->opened = 1;
#line 283
  ret = verify_read_command___0(d___0);
  }
#line 283
  if (ret) {
#line 283
    return (ret);
  }
#line 284
  d___0->error_retry = 1;
#line 285
  return (0);
}
}
#line 182 "/usr/include/bits/mathcalls.h"
extern  __attribute__((__nothrow__)) double fabs(double __x )  __attribute__((__const__)) ;
#line 127 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2))) strcpy)(char * __restrict  __dest ,
                                                                                       char const   * __restrict  __src ) ;
#line 34 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/interface/utils.h"
__inline static int16_t be16_to_cpu(int16_t x ) 
{ 
  int16_t tmp ;

  {
  {
#line 35
  tmp = swap16(x);
  }
#line 35
  return (tmp);
}
}
#line 42 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/interface/utils.h"
__inline static int16_t le16_to_cpu(int16_t x ) 
{ 


  {
#line 43
  return (x);
}
}
#line 83 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/interface/utils.h"
__inline static char *copystring(char const   *s ) 
{ 
  char *ret ;
  size_t tmp ;
  void *tmp___0 ;

  {
#line 84
  if (s) {
    {
#line 85
    tmp = strlen(s);
#line 85
    tmp___0 = malloc((size_t )((unsigned long )(tmp + 9U) * sizeof(char )));
#line 85
    ret = (char *)tmp___0;
#line 87
    strcpy((char */* __restrict  */)ret, (char const   */* __restrict  */)s);
    }
#line 88
    return (ret);
  }
#line 90
  return ((char *)((void *)0));
}
}
#line 120 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/interface/utils.h"
static void cdmessage___1(cdrom_drive *d___0 , char const   *s ) 
{ 
  size_t tmp ;

  {
#line 121
  if (s) {
#line 121
    if (d___0) {
      {
#line 123
      if (d___0->messagedest == 1) {
#line 123
        goto case_1;
      }
#line 126
      if (d___0->messagedest == 2) {
#line 126
        goto case_2;
      }
#line 130
      goto switch_default;
      case_1: /* CIL Label */ 
      {
#line 124
      tmp = strlen(s);
#line 124
      write(2, (void const   *)s, tmp);
      }
#line 125
      goto switch_break;
      case_2: /* CIL Label */ 
      {
#line 127
      d___0->messagebuf = catstring(d___0->messagebuf, s);
      }
#line 128
      goto switch_break;
      switch_default: /* CIL Label */ 
#line 131
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    }
  }
#line 134
  return;
}
}
#line 21 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/interface/common_interface.c"
int ioctl_ping_cdrom(int fd ) 
{ 
  struct cdrom_volctrl volctl ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 23
  tmp = ioctl(fd, 21267UL, & volctl);
  }
#line 23
  if (tmp) {
    {
#line 23
    tmp___0 = ioctl(fd, 21297UL, (void *)0);
    }
#line 23
    if (tmp___0 < 0) {
#line 25
      return (1);
    }
  }
#line 27
  return (0);
}
}
#line 33 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/interface/common_interface.c"
char *atapi_drive_info(int fd ) 
{ 
  struct hd_driveid *id ;
  void *tmp ;
  char *ret ;
  int tmp___0 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
  {
#line 37
  tmp = malloc((size_t )512);
#line 37
  id = (struct hd_driveid *)tmp;
#line 40
  tmp___0 = ioctl(fd, 781UL, id);
  }
#line 40
  if (tmp___0) {
    {
#line 47
    ret = copystring("Generic Unidentifiable CDROM");
    }
  } else
#line 42
  if ((unsigned long )(id->model) == (unsigned long )((unsigned char *)0)) {
    {
#line 43
    ret = copystring("Generic Unidentifiable ATAPI CDROM");
    }
  } else
#line 42
  if ((int )id->model[0] == 0) {
    {
#line 43
    ret = copystring("Generic Unidentifiable ATAPI CDROM");
    }
  } else {
    {
#line 45
    ret = copystring((char const   *)(id->model));
    }
  }
  {
#line 49
  free((void *)id);
  }
#line 50
  return (ret);
}
}
#line 53 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/interface/common_interface.c"
int data_bigendianp(cdrom_drive *d___0 ) 
{ 
  float lsb_votes ;
  float msb_votes ;
  int i ;
  int checked ;
  int endiancache ;
  float *a ;
  void *tmp ;
  float *b ;
  void *tmp___0 ;
  long readsectors ;
  int16_t *buff ;
  void *tmp___1 ;
  float lsb_energy ;
  float msb_energy ;
  long firstsector ;
  long tmp___2 ;
  long lastsector ;
  long tmp___3 ;
  int zeroflag ;
  long beginsec ;
  int j ;
  int offset ;
  long tmp___4 ;
  int j___0 ;
  int16_t tmp___5 ;
  int16_t tmp___6 ;
  double tmp___7 ;
  double tmp___8 ;
  int16_t tmp___9 ;
  int16_t tmp___10 ;
  double tmp___11 ;
  double tmp___12 ;
  int tmp___13 ;
  char buffer[256] ;
  char buffer___0[256] ;
  int tmp___14 ;
  void *__cil_tmp38 ;
  void *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;

  {
  {
#line 54
  lsb_votes = (float )0;
#line 55
  msb_votes = (float )0;
#line 57
  endiancache = d___0->bigendianp;
#line 58
  tmp = calloc((size_t )1024, (size_t )sizeof(float ));
#line 58
  a = (float *)tmp;
#line 59
  tmp___0 = calloc((size_t )1024, (size_t )sizeof(float ));
#line 59
  b = (float *)tmp___0;
#line 60
  readsectors = 5L;
#line 61
  tmp___1 = malloc((size_t )(readsectors * 2352L));
#line 61
  buff = (int16_t *)tmp___1;
#line 67
  d___0->bigendianp = -1;
#line 69
  cdmessage___1(d___0, "\nAttempting to determine drive endianness from data...");
#line 70
  (*(d___0->enable_cdda))(d___0, 1);
#line 71
  i = 0;
#line 71
  checked = 0;
  }
  {
#line 71
  while (1) {
    while_continue: /* CIL Label */ ;
#line 71
    if (! (i < d___0->tracks)) {
#line 71
      goto while_break;
    }
    {
#line 72
    lsb_energy = (float )0;
#line 73
    msb_energy = (float )0;
#line 74
    tmp___13 = cdda_track_audiop(d___0, i + 1);
    }
#line 74
    if (tmp___13 == 1) {
      {
#line 75
      tmp___2 = cdda_track_firstsector(d___0, i + 1);
#line 75
      firstsector = tmp___2;
#line 76
      tmp___3 = cdda_track_lastsector(d___0, i + 1);
#line 76
      lastsector = tmp___3;
#line 77
      zeroflag = -1;
#line 78
      beginsec = 0L;
      }
      {
#line 82
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 82
        if (! (firstsector + readsectors <= lastsector)) {
#line 82
          goto while_break___0;
        }
        {
#line 85
        tmp___4 = (*(d___0->read_audio))(d___0, (void *)buff, firstsector, readsectors);
        }
#line 85
        if (tmp___4 > 0L) {
#line 88
          beginsec = 0L;
          {
#line 88
          while (1) {
            while_continue___1: /* CIL Label */ ;
#line 88
            if (! (beginsec < readsectors)) {
#line 88
              goto while_break___1;
            }
#line 89
            offset = (int )((beginsec * 2352L) / 2L);
#line 91
            j = 460;
            {
#line 91
            while (1) {
              while_continue___2: /* CIL Label */ ;
#line 91
              if (! (j < 588)) {
#line 91
                goto while_break___2;
              }
#line 92
              if ((int )*(buff + (offset + j)) != 0) {
#line 93
                zeroflag = 0;
#line 94
                goto while_break___2;
              }
#line 91
              j ++;
            }
            while_break___2: /* CIL Label */ ;
            }
#line 96
            if (! zeroflag) {
#line 96
              goto while_break___1;
            }
#line 88
            beginsec ++;
          }
          while_break___1: /* CIL Label */ ;
          }
#line 98
          if (! zeroflag) {
#line 98
            goto while_break___0;
          }
#line 99
          firstsector += readsectors;
        } else {
          {
#line 101
          (*(d___0->enable_cdda))(d___0, 0);
#line 102
          free((void *)a);
#line 103
          free((void *)b);
#line 104
          free((void *)buff);
          }
#line 105
          return (-1);
        }
      }
      while_break___0: /* CIL Label */ ;
      }
#line 109
      beginsec *= 1176L;
#line 112
      if (! zeroflag) {
#line 115
        j___0 = 0;
        {
#line 115
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 115
          if (! (j___0 < 128)) {
#line 115
            goto while_break___3;
          }
          {
#line 115
          tmp___5 = le16_to_cpu(*(buff + (((long )(j___0 * 2) + beginsec) + 460L)));
#line 115
          *(a + j___0) = (float )tmp___5;
#line 115
          j___0 ++;
          }
        }
        while_break___3: /* CIL Label */ ;
        }
#line 116
        j___0 = 0;
        {
#line 116
        while (1) {
          while_continue___4: /* CIL Label */ ;
#line 116
          if (! (j___0 < 128)) {
#line 116
            goto while_break___4;
          }
          {
#line 116
          tmp___6 = le16_to_cpu(*(buff + (((long )(j___0 * 2) + beginsec) + 461L)));
#line 116
          *(b + j___0) = (float )tmp___6;
#line 116
          j___0 ++;
          }
        }
        while_break___4: /* CIL Label */ ;
        }
        {
#line 117
        fft_forward(128, a, (float *)((void *)0), (int *)((void *)0));
#line 118
        fft_forward(128, b, (float *)((void *)0), (int *)((void *)0));
#line 119
        j___0 = 0;
        }
        {
#line 119
        while (1) {
          while_continue___5: /* CIL Label */ ;
#line 119
          if (! (j___0 < 128)) {
#line 119
            goto while_break___5;
          }
          {
#line 119
          tmp___7 = fabs((double )*(a + j___0));
#line 119
          tmp___8 = fabs((double )*(b + j___0));
#line 119
          lsb_energy = (float )((double )lsb_energy + (tmp___7 + tmp___8));
#line 119
          j___0 ++;
          }
        }
        while_break___5: /* CIL Label */ ;
        }
#line 121
        j___0 = 0;
        {
#line 121
        while (1) {
          while_continue___6: /* CIL Label */ ;
#line 121
          if (! (j___0 < 128)) {
#line 121
            goto while_break___6;
          }
          {
#line 121
          tmp___9 = be16_to_cpu(*(buff + (((long )(j___0 * 2) + beginsec) + 460L)));
#line 121
          *(a + j___0) = (float )tmp___9;
#line 121
          j___0 ++;
          }
        }
        while_break___6: /* CIL Label */ ;
        }
#line 122
        j___0 = 0;
        {
#line 122
        while (1) {
          while_continue___7: /* CIL Label */ ;
#line 122
          if (! (j___0 < 128)) {
#line 122
            goto while_break___7;
          }
          {
#line 122
          tmp___10 = be16_to_cpu(*(buff + (((long )(j___0 * 2) + beginsec) + 461L)));
#line 122
          *(b + j___0) = (float )tmp___10;
#line 122
          j___0 ++;
          }
        }
        while_break___7: /* CIL Label */ ;
        }
        {
#line 123
        fft_forward(128, a, (float *)((void *)0), (int *)((void *)0));
#line 124
        fft_forward(128, b, (float *)((void *)0), (int *)((void *)0));
#line 125
        j___0 = 0;
        }
        {
#line 125
        while (1) {
          while_continue___8: /* CIL Label */ ;
#line 125
          if (! (j___0 < 128)) {
#line 125
            goto while_break___8;
          }
          {
#line 125
          tmp___11 = fabs((double )*(a + j___0));
#line 125
          tmp___12 = fabs((double )*(b + j___0));
#line 125
          msb_energy = (float )((double )msb_energy + (tmp___11 + tmp___12));
#line 125
          j___0 ++;
          }
        }
        while_break___8: /* CIL Label */ ;
        }
      }
    }
#line 128
    if (lsb_energy < msb_energy) {
#line 129
      lsb_votes += msb_energy / lsb_energy;
#line 130
      checked ++;
    } else
#line 132
    if (lsb_energy > msb_energy) {
#line 133
      msb_votes += lsb_energy / msb_energy;
#line 134
      checked ++;
    }
#line 137
    if (checked == 5) {
#line 137
      if (lsb_votes == (float )0) {
#line 137
        goto while_break;
      } else
#line 137
      if (msb_votes == (float )0) {
#line 137
        goto while_break;
      }
    }
    {
#line 138
    cdmessage___1(d___0, ".");
#line 71
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 141
  free((void *)buff);
#line 142
  free((void *)a);
#line 143
  free((void *)b);
#line 144
  d___0->bigendianp = endiancache;
#line 145
  (*(d___0->enable_cdda))(d___0, 0);
  }
#line 148
  if (lsb_votes > msb_votes) {
    {
#line 150
    cdmessage___1(d___0, "\n\tData appears to be coming back little endian.\n");
#line 151
    sprintf((char */* __restrict  */)(buffer), (char const   */* __restrict  */)"\tcertainty: %d%%\n",
            (int )((100. * (double )lsb_votes) / (double )(lsb_votes + msb_votes) + .5));
#line 153
    cdmessage___1(d___0, (char const   *)(buffer));
    }
#line 154
    return (0);
  } else {
#line 156
    if (msb_votes > lsb_votes) {
      {
#line 158
      cdmessage___1(d___0, "\n\tData appears to be coming back big endian.\n");
#line 159
      sprintf((char */* __restrict  */)(buffer___0), (char const   */* __restrict  */)"\tcertainty: %d%%\n",
              (int )((100. * (double )msb_votes) / (double )(lsb_votes + msb_votes) + .5));
#line 161
      cdmessage___1(d___0, (char const   *)(buffer___0));
      }
#line 162
      return (1);
    }
    {
#line 165
    cdmessage___1(d___0, "\n\tCannot determine CDROM drive endianness.\n");
#line 166
    tmp___14 = bigendianp();
    }
#line 166
    return (tmp___14);
#line 167
    return (-1);
  }
}
}
#line 176 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/interface/common_interface.c"
int FixupTOC(cdrom_drive *d___0 , int tracks ) 
{ 
  struct cdrom_multisession ms_str ;
  int j ;
  long last___0 ;
  int result ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
#line 182
  j = 0;
  {
#line 182
  while (1) {
    while_continue: /* CIL Label */ ;
#line 182
    if (! (j < tracks)) {
#line 182
      goto while_break;
    }
#line 183
    if (d___0->disc_toc[j].dwStartSector < 0) {
      {
#line 184
      cdmessage___1(d___0, "\n\tTOC entry claims a negative start offset: massaging.\n");
#line 186
      d___0->disc_toc[j].dwStartSector = 0;
      }
    }
#line 188
    if (j < tracks - 1) {
#line 188
      if (d___0->disc_toc[j].dwStartSector > d___0->disc_toc[j + 1].dwStartSector) {
        {
#line 190
        cdmessage___1(d___0, "\n\tTOC entry claims an overly large start offset: massaging.\n");
#line 192
        d___0->disc_toc[j].dwStartSector = 0;
        }
      }
    }
#line 182
    j ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 199
  last___0 = (long )d___0->disc_toc[0].dwStartSector;
#line 200
  j = 1;
  {
#line 200
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 200
    if (! (j < tracks)) {
#line 200
      goto while_break___0;
    }
#line 201
    if ((long )d___0->disc_toc[j].dwStartSector < last___0) {
      {
#line 202
      cdmessage___1(d___0, "\n\tTOC entries claim non-increasing offsets: massaging.\n");
#line 204
      d___0->disc_toc[j].dwStartSector = (int32_t )last___0;
      }
    }
#line 207
    last___0 = (long )d___0->disc_toc[j].dwStartSector;
#line 200
    j ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 214
  if (d___0->ioctl_fd != -1) {
    {
#line 217
    ms_str.addr_format = (__u8 )1;
#line 218
    result = ioctl(d___0->ioctl_fd, 21264UL, & ms_str);
    }
#line 219
    if (result == -1) {
#line 219
      return (-1);
    }
#line 221
    if (ms_str.addr.lba > 100) {
#line 227
      j = tracks - 1;
      {
#line 227
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 227
        if (! (j >= 0)) {
#line 227
          goto while_break___1;
        }
#line 228
        if (j > 0) {
#line 228
          if (! (! ((int )d___0->disc_toc[j].bFlags & 4))) {
#line 228
            if (! ((int )d___0->disc_toc[j - 1].bFlags & 4)) {
#line 229
              if (d___0->disc_toc[j].dwStartSector > ms_str.addr.lba - 11400) {
#line 229
                if (ms_str.addr.lba - 11400 > d___0->disc_toc[j - 1].dwStartSector) {
#line 231
                  d___0->disc_toc[j].dwStartSector = ms_str.addr.lba - 11400;
                }
              }
#line 232
              goto while_break___1;
            }
          }
        }
#line 227
        j --;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 235
      return (1);
    }
  }
#line 238
  return (0);
}
}
#line 864 "/usr/include/stdio.h"
extern char *cuserid(char *__s ) ;
#line 526 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int dup(int __fd ) ;
#line 380 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int rand(void) ;
#line 729
extern  __attribute__((__nothrow__)) char *realpath(char const   * __restrict  __name ,
                                                    char * __restrict  __resolved ) ;
#line 209 "/usr/include/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) stat)(char const   * __restrict  __file ,
                                                                                   struct stat * __restrict  __buf ) ;
#line 263
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) lstat)(char const   * __restrict  __file ,
                                                                                    struct stat * __restrict  __buf ) ;
#line 109 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/interface/cdda_interface.h"
cdrom_drive *cdda_find_a_cdrom(int messagedest , char **messages ) ;
#line 110
cdrom_drive *cdda_identify(char const   *device , int messagedest , char **messages ) ;
#line 112
cdrom_drive *cdda_identify_cooked(char const   *dev , int messagedest , char **messages ) ;
#line 114
cdrom_drive *cdda_identify_scsi(char const   *generic_device , char const   *specialized_device ,
                                int messagedest , char **messages ) ;
#line 138 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2))) strncat)(char * __restrict  __dest ,
                                                                                        char const   * __restrict  __src ,
                                                                                        size_t __n ) ;
#line 173
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1))) strdup)(char const   *__s )  __attribute__((__malloc__)) ;
#line 233
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1))) strchr)(char const   *__s ,
                                                                                     int __c )  __attribute__((__pure__)) ;
#line 260
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1))) strrchr)(char const   *__s ,
                                                                                      int __c )  __attribute__((__pure__)) ;
#line 73 "/usr/include/fcntl.h"
extern int ( __attribute__((__nonnull__(1))) open)(char const   *__file , int __oflag 
                                                   , ...) ;
#line 136 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/interface/utils.h"
static void idperror(int messagedest , char **messages , char const   *f , char const   *s ) 
{ 
  char *buffer ;
  int malloced ;
  size_t tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;
  size_t tmp___2 ;
  int *tmp___3 ;
  char *tmp___4 ;
  size_t tmp___5 ;
  int *tmp___6 ;
  char *tmp___7 ;
  int *tmp___8 ;
  int *tmp___9 ;
  char *tmp___10 ;
  int *tmp___11 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;

  {
#line 140
  malloced = 0;
#line 141
  if (! f) {
#line 142
    buffer = (char *)s;
  } else
#line 144
  if (! s) {
#line 145
    buffer = (char *)f;
  } else {
    {
#line 147
    tmp = strlen(f);
#line 147
    tmp___0 = strlen(s);
#line 147
    tmp___1 = malloc((tmp + tmp___0) + 9U);
#line 147
    buffer = (char *)tmp___1;
#line 148
    sprintf((char */* __restrict  */)buffer, (char const   */* __restrict  */)f, s);
#line 149
    malloced = 1;
    }
  }
#line 152
  if (buffer) {
    {
#line 154
    if (messagedest == 1) {
#line 154
      goto case_1;
    }
#line 162
    if (messagedest == 2) {
#line 162
      goto case_2;
    }
#line 173
    goto switch_default;
    case_1: /* CIL Label */ 
    {
#line 155
    tmp___2 = strlen((char const   *)buffer);
#line 155
    write(2, (void const   *)buffer, tmp___2);
#line 156
    tmp___8 = __errno_location();
    }
#line 156
    if (*tmp___8) {
      {
#line 157
      write(2, (void const   *)": ", (size_t )2);
#line 158
      tmp___3 = __errno_location();
#line 158
      tmp___4 = strerror(*tmp___3);
#line 158
      tmp___5 = strlen((char const   *)tmp___4);
#line 158
      tmp___6 = __errno_location();
#line 158
      tmp___7 = strerror(*tmp___6);
#line 158
      write(2, (void const   *)tmp___7, tmp___5);
#line 159
      write(2, (void const   *)"\n", (size_t )1);
      }
    }
#line 161
    goto switch_break;
    case_2: /* CIL Label */ 
#line 163
    if (messages) {
      {
#line 164
      *messages = catstring(*messages, (char const   *)buffer);
#line 165
      tmp___11 = __errno_location();
      }
#line 165
      if (*tmp___11) {
        {
#line 166
        *messages = catstring(*messages, ": ");
#line 167
        tmp___9 = __errno_location();
#line 167
        tmp___10 = strerror(*tmp___9);
#line 167
        *messages = catstring(*messages, (char const   *)tmp___10);
#line 168
        *messages = catstring(*messages, "\n");
        }
      }
    }
#line 171
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 174
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
#line 177
  if (malloced) {
    {
#line 177
    free((void *)buffer);
    }
  }
#line 178
  return;
}
}
#line 181 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/interface/utils.h"
static void idmessage(int messagedest , char **messages , char const   *f , char const   *s ) 
{ 
  char *buffer ;
  int malloced ;
  size_t tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;
  size_t tmp___2 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;

  {
#line 184
  malloced = 0;
#line 185
  if (! f) {
#line 186
    buffer = (char *)s;
  } else
#line 188
  if (! s) {
#line 189
    buffer = (char *)f;
  } else {
    {
#line 191
    tmp = strlen(f);
#line 191
    tmp___0 = strlen(s);
#line 191
    tmp___1 = malloc((tmp + tmp___0) + 10U);
#line 191
    buffer = (char *)tmp___1;
#line 192
    sprintf((char */* __restrict  */)buffer, (char const   */* __restrict  */)f, s);
#line 193
    strcat((char */* __restrict  */)buffer, (char const   */* __restrict  */)"\n");
#line 194
    malloced = 1;
    }
  }
#line 197
  if (buffer) {
    {
#line 199
    if (messagedest == 1) {
#line 199
      goto case_1;
    }
#line 203
    if (messagedest == 2) {
#line 203
      goto case_2;
    }
#line 210
    goto switch_default;
    case_1: /* CIL Label */ 
    {
#line 200
    tmp___2 = strlen((char const   *)buffer);
#line 200
    write(2, (void const   *)buffer, tmp___2);
    }
#line 201
    if (! malloced) {
      {
#line 201
      write(2, (void const   *)"\n", (size_t )1);
      }
    }
#line 202
    goto switch_break;
    case_2: /* CIL Label */ 
#line 204
    if (messages) {
      {
#line 205
      *messages = catstring(*messages, (char const   *)buffer);
      }
#line 206
      if (! malloced) {
        {
#line 206
        *messages = catstring(*messages, "\n");
        }
      }
    }
#line 208
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 211
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
#line 214
  if (malloced) {
    {
#line 214
    free((void *)buffer);
    }
  }
#line 215
  return;
}
}
#line 27 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/interface/scan_devices.c"
static char *scsi_cdrom_prefixes[3]  = {      (char *)"/dev/scd",      (char *)"/dev/sr",      (char *)((void *)0)};
#line 31 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/interface/scan_devices.c"
static char *scsi_generic_prefixes[2]  = {      (char *)"/dev/sg",      (char *)((void *)0)};
#line 35 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/interface/scan_devices.c"
static char *devfs_scsi_test  =    (char *)"/dev/scsi/";
#line 36 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/interface/scan_devices.c"
static char *devfs_scsi_cd  =    (char *)"cd";
#line 37 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/interface/scan_devices.c"
static char *devfs_scsi_generic  =    (char *)"generic";
#line 39 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/interface/scan_devices.c"
static char *cdrom_devices[15]  = 
#line 39
  {      (char *)"/dev/cdrom",      (char *)"/dev/cdroms/cdrom?",      (char *)"/dev/hd?",      (char *)"/dev/sg?", 
        (char *)"/dev/cdu31a",      (char *)"/dev/cdu535",      (char *)"/dev/sbpcd",      (char *)"/dev/sbpcd?", 
        (char *)"/dev/sonycd",      (char *)"/dev/mcd",      (char *)"/dev/sjcd",      (char *)"/dev/cm206cd", 
        (char *)"/dev/gscd",      (char *)"/dev/optcd",      (char *)((void *)0)};
#line 59 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/interface/scan_devices.c"
cdrom_drive *cdda_find_a_cdrom(int messagedest , char **messages ) 
{ 
  int i ;
  cdrom_drive *d___0 ;
  char *pos ;
  int j ;
  char *buffer ;
  char *tmp ;
  char *tmp___0 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;

  {
#line 62
  i = 0;
  {
#line 65
  while (1) {
    while_continue: /* CIL Label */ ;
#line 65
    if (! ((unsigned long )cdrom_devices[i] != (unsigned long )((void *)0))) {
#line 65
      goto while_break;
    }
    {
#line 69
    pos = strchr((char const   *)cdrom_devices[i], '?');
    }
#line 69
    if (pos) {
#line 72
      j = 0;
      {
#line 72
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 72
        if (! (j < 4)) {
#line 72
          goto while_break___0;
        }
        {
#line 73
        tmp = copystring((char const   *)cdrom_devices[i]);
#line 73
        buffer = tmp;
#line 77
        *(buffer + (pos - cdrom_devices[i])) = (char )(j + 48);
#line 78
        d___0 = cdda_identify((char const   *)buffer, messagedest, messages);
        }
#line 78
        if (d___0) {
#line 79
          return (d___0);
        }
        {
#line 80
        idmessage(messagedest, messages, "", (char const   *)((void *)0));
#line 81
        *(buffer + (pos - cdrom_devices[i])) = (char )(j + 97);
#line 82
        d___0 = cdda_identify((char const   *)buffer, messagedest, messages);
        }
#line 82
        if (d___0) {
#line 83
          return (d___0);
        }
        {
#line 84
        idmessage(messagedest, messages, "", (char const   *)((void *)0));
#line 72
        j ++;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
    } else {
      {
#line 88
      d___0 = cdda_identify((char const   *)cdrom_devices[i], messagedest, messages);
      }
#line 88
      if (d___0) {
#line 89
        return (d___0);
      }
      {
#line 91
      idmessage(messagedest, messages, "", (char const   *)((void *)0));
      }
    }
#line 93
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 95
  tmp___0 = cuserid((char *)((void *)0));
#line 95
  idmessage(messagedest, messages, "\n\nNo cdrom drives accessible to %s found.\n",
            (char const   *)tmp___0);
  }
#line 98
  return ((cdrom_drive *)((void *)0));
}
}
#line 101 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/interface/scan_devices.c"
cdrom_drive *cdda_identify(char const   *device , int messagedest , char **messages ) 
{ 
  struct stat st ;
  cdrom_drive *d___0 ;
  int tmp ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
  {
#line 103
  d___0 = (cdrom_drive *)((void *)0);
#line 105
  idmessage(messagedest, messages, "Checking %s for cdrom...", device);
#line 107
  tmp = stat((char const   */* __restrict  */)device, (struct stat */* __restrict  */)(& st));
  }
#line 107
  if (tmp) {
    {
#line 108
    idperror(messagedest, messages, "\tCould not stat %s", device);
    }
#line 109
    return ((cdrom_drive *)((void *)0));
  }
#line 113
  if (! ((st.st_mode & 61440U) == 8192U)) {
#line 113
    if (! ((st.st_mode & 61440U) == 24576U)) {
      {
#line 115
      idmessage(messagedest, messages, "\t%s is not a block or character device",
                device);
      }
#line 116
      return ((cdrom_drive *)((void *)0));
    }
  }
  {
#line 122
  d___0 = cdda_identify_scsi((char const   *)((void *)0), device, messagedest, messages);
  }
#line 123
  if (! d___0) {
    {
#line 123
    d___0 = cdda_identify_cooked(device, messagedest, messages);
    }
  }
#line 129
  return (d___0);
}
}
#line 132 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/interface/scan_devices.c"
char *test_resolve_symlink(char const   *file , int messagedest , char **messages ) 
{ 
  char resolved[4096] ;
  struct stat st ;
  int tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  void *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
  {
#line 135
  tmp = lstat((char const   */* __restrict  */)file, (struct stat */* __restrict  */)(& st));
  }
#line 135
  if (tmp) {
    {
#line 136
    idperror(messagedest, messages, "\t\tCould not stat %s", file);
    }
#line 137
    return ((char *)((void *)0));
  }
  {
#line 140
  tmp___1 = realpath((char const   */* __restrict  */)file, (char */* __restrict  */)(resolved));
  }
#line 140
  if (tmp___1) {
    {
#line 141
    tmp___0 = strdup((char const   *)(resolved));
    }
#line 141
    return (tmp___0);
  }
  {
#line 143
  idperror(messagedest, messages, "\t\tCould not resolve symlink %s", file);
  }
#line 144
  return ((char *)((void *)0));
}
}
#line 148 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/interface/scan_devices.c"
cdrom_drive *cdda_identify_cooked(char const   *dev , int messagedest , char **messages ) 
{ 
  cdrom_drive *d___0 ;
  struct stat st ;
  int fd ;
  int type ;
  char *description ;
  char *device ;
  int tmp ;
  int tmp___0 ;
  char *temp ;
  char *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  struct timespec tv ;
  int tmp___5 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;

  {
  {
#line 151
  d___0 = (cdrom_drive *)((void *)0);
#line 153
  fd = -1;
#line 155
  description = (char *)((void *)0);
#line 158
  idmessage(messagedest, messages, "\tTesting %s for cooked ioctl() interface", dev);
#line 160
  device = test_resolve_symlink(dev, messagedest, messages);
  }
#line 161
  if ((unsigned long )device == (unsigned long )((void *)0)) {
#line 161
    return ((cdrom_drive *)((void *)0));
  }
  {
#line 163
  tmp = stat((char const   */* __restrict  */)device, (struct stat */* __restrict  */)(& st));
  }
#line 163
  if (tmp) {
    {
#line 164
    idperror(messagedest, messages, "\t\tCould not stat %s", (char const   *)device);
#line 165
    free((void *)device);
    }
#line 166
    return ((cdrom_drive *)((void *)0));
  }
#line 169
  if (! ((st.st_mode & 61440U) == 8192U)) {
#line 169
    if (! ((st.st_mode & 61440U) == 24576U)) {
      {
#line 171
      idmessage(messagedest, messages, "\t\t%s is not a block or character device",
                (char const   *)device);
#line 172
      free((void *)device);
      }
#line 173
      return ((cdrom_drive *)((void *)0));
    }
  }
#line 176
  type = (int )(st.st_rdev >> 8);
  {
#line 181
  if (type == 34) {
#line 181
    goto case_34;
  }
#line 181
  if (type == 33) {
#line 181
    goto case_34;
  }
#line 181
  if (type == 22) {
#line 181
    goto case_34;
  }
#line 181
  if (type == 3) {
#line 181
    goto case_34;
  }
#line 206
  if (type == 15) {
#line 206
    goto case_15;
  }
#line 210
  if (type == 24) {
#line 210
    goto case_24;
  }
#line 218
  if (type == 28) {
#line 218
    goto case_28;
  }
#line 218
  if (type == 27) {
#line 218
    goto case_28;
  }
#line 218
  if (type == 26) {
#line 218
    goto case_28;
  }
#line 218
  if (type == 25) {
#line 218
    goto case_28;
  }
#line 222
  if (type == 18) {
#line 222
    goto case_18;
  }
#line 226
  if (type == 20) {
#line 226
    goto case_20;
  }
#line 226
  if (type == 23) {
#line 226
    goto case_20;
  }
#line 229
  if (type == 17) {
#line 229
    goto case_17;
  }
#line 232
  if (type == 29) {
#line 232
    goto case_29;
  }
#line 235
  if (type == 16) {
#line 235
    goto case_16;
  }
#line 238
  if (type == 32) {
#line 238
    goto case_32;
  }
#line 243
  if (type == 21) {
#line 243
    goto case_21;
  }
#line 243
  if (type == 11) {
#line 243
    goto case_21;
  }
#line 248
  goto switch_default;
  case_34: /* CIL Label */ 
  case_33: /* CIL Label */ 
  case_22: /* CIL Label */ 
  case_3: /* CIL Label */ 
  {
#line 185
  fd = open((char const   *)device, 2048);
  }
#line 186
  if (fd == -1) {
    {
#line 187
    idperror(messagedest, messages, "\t\tUnable to open %s", (char const   *)device);
#line 188
    free((void *)device);
    }
#line 189
    return ((cdrom_drive *)((void *)0));
  }
  {
#line 192
  tmp___0 = ioctl_ping_cdrom(fd);
  }
#line 192
  if (tmp___0) {
    {
#line 193
    idmessage(messagedest, messages, "\t\tDevice %s is not a CDROM", (char const   *)device);
#line 194
    close(fd);
#line 195
    free((void *)device);
    }
#line 196
    return ((cdrom_drive *)((void *)0));
  }
  {
#line 199
  tmp___1 = atapi_drive_info(fd);
#line 199
  temp = tmp___1;
#line 200
  description = catstring((char *)((void *)0), "ATAPI compatible ");
#line 201
  description = catstring(description, (char const   *)temp);
#line 202
  free((void *)temp);
  }
#line 205
  goto switch_break;
  case_15: /* CIL Label */ 
  {
#line 208
  description = copystring("Sony CDU31A or compatible");
  }
#line 209
  goto switch_break;
  case_24: /* CIL Label */ 
  {
#line 212
  description = copystring("Sony CDU535 or compatible");
  }
#line 213
  goto switch_break;
  case_28: /* CIL Label */ 
  case_27: /* CIL Label */ 
  case_26: /* CIL Label */ 
  case_25: /* CIL Label */ 
  {
#line 220
  description = copystring("non-ATAPI IDE-style Matsushita/Panasonic CR-5xx or compatible");
  }
#line 221
  goto switch_break;
  case_18: /* CIL Label */ 
  {
#line 223
  description = copystring("Sanyo proprietary or compatible: NOT CDDA CAPABLE");
  }
#line 224
  goto switch_break;
  case_20: /* CIL Label */ 
  case_23: /* CIL Label */ 
  {
#line 227
  description = copystring("Mitsumi proprietary or compatible: NOT CDDA CAPABLE");
  }
#line 228
  goto switch_break;
  case_17: /* CIL Label */ 
  {
#line 230
  description = copystring("Optics Dolphin or compatible: NOT CDDA CAPABLE");
  }
#line 231
  goto switch_break;
  case_29: /* CIL Label */ 
  {
#line 233
  description = copystring("Aztech proprietary or compatible: NOT CDDA CAPABLE");
  }
#line 234
  goto switch_break;
  case_16: /* CIL Label */ 
  {
#line 236
  description = copystring("Goldstar proprietary: NOT CDDA CAPABLE");
  }
#line 237
  goto switch_break;
  case_32: /* CIL Label */ 
  {
#line 239
  description = copystring("Philips/LMS CM206 proprietary: NOT CDDA CAPABLE");
  }
#line 240
  goto switch_break;
  case_21: /* CIL Label */ 
  case_11: /* CIL Label */ 
  {
#line 245
  idmessage(messagedest, messages, "\t\t%s is not a cooked ioctl CDROM.", (char const   *)device);
#line 246
  free((void *)device);
  }
#line 247
  return ((cdrom_drive *)((void *)0));
  switch_default: /* CIL Label */ 
  {
#line 250
  idmessage(messagedest, messages, "\t\t%s is not a cooked ioctl CDROM.", (char const   *)device);
#line 251
  free((void *)device);
  }
#line 252
  return ((cdrom_drive *)((void *)0));
  switch_break: /* CIL Label */ ;
  }
  {
#line 257
  tmp___2 = calloc((size_t )1, (size_t )sizeof(cdrom_drive ));
#line 257
  d___0 = (cdrom_drive *)tmp___2;
#line 258
  d___0->cdda_device_name = device;
#line 259
  d___0->ioctl_device_name = copystring((char const   *)device);
#line 260
  d___0->drive_model = description;
#line 261
  d___0->drive_type = type;
#line 262
  d___0->cdda_fd = fd;
#line 263
  d___0->ioctl_fd = fd;
#line 264
  d___0->interface = 1;
#line 265
  d___0->bigendianp = -1;
#line 266
  d___0->nsectors = -1;
#line 267
  tmp___3 = calloc((size_t )1, (size_t )sizeof(*(d___0->private)));
#line 267
  d___0->private = (cdda_private_data_t *)tmp___3;
#line 271
  tmp___5 = clock_gettime(1, & tv);
  }
#line 271
  if (tmp___5 < 0) {
#line 271
    (d___0->private)->clock = 0;
  } else {
#line 271
    (d___0->private)->clock = 1;
  }
  {
#line 273
  idmessage(messagedest, messages, "\t\tCDROM sensed: %s\n", (char const   *)description);
  }
#line 274
  return (d___0);
}
}
#line 277 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/interface/scan_devices.c"
struct sg_id sg_id  ;
#line 290 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/interface/scan_devices.c"
static int get_scsi_id(int fd , scsiid *id ) 
{ 
  struct sg_id argid ;
  int busarg ;
  int tmp ;
  int tmp___0 ;

  {
#line 296
  if (fd == -1) {
#line 296
    return (-1);
  }
  {
#line 297
  tmp = ioctl(fd, 21378UL, & argid);
  }
#line 297
  if (tmp) {
#line 297
    return (-1);
  }
  {
#line 298
  id->bus = (int )argid.l2;
#line 299
  id->id = (int )(argid.l1 & 255L);
#line 300
  id->lun = (int )((argid.l1 >> 8) & 255L);
#line 302
  tmp___0 = ioctl(fd, 21382UL, & busarg);
  }
#line 302
  if (tmp___0 == 0) {
#line 303
    id->bus = busarg;
  }
#line 305
  return (0);
}
}
#line 309 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/interface/scan_devices.c"
static char *scsi_match(char const   *device , char **prefixes , char *devfs_test ,
                        char *devfs_other , char *prompt , int messagedest , char **messages ) 
{ 
  int dev ;
  int tmp ;
  scsiid a ;
  scsiid b ;
  int i ;
  int j ;
  char buffer[200] ;
  char *pos ;
  int matchf ;
  int *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;
  size_t tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int pattern ;
  int matchf___0 ;
  int k ;
  int *tmp___7 ;
  char *tmp___8 ;
  int tmp___9 ;
  char *tmp___10 ;
  int tmp___11 ;
  void *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;

  {
  {
#line 313
  tmp = open(device, 2048);
#line 313
  dev = tmp;
#line 321
  tmp___4 = strlen((char const   *)devfs_test);
#line 321
  tmp___5 = strncmp(device, (char const   *)devfs_test, tmp___4);
  }
#line 321
  if (! tmp___5) {
    {
#line 323
    strcpy((char */* __restrict  */)(buffer), (char const   */* __restrict  */)device);
#line 324
    pos = strrchr((char const   *)(buffer), '/');
    }
#line 325
    if (pos) {
      {
#line 327
      sprintf((char */* __restrict  */)pos, (char const   */* __restrict  */)"/%s",
              devfs_other);
#line 328
      matchf = open((char const   *)(buffer), 2048);
#line 329
      i = 0;
      }
      {
#line 329
      while (1) {
        while_continue: /* CIL Label */ ;
#line 329
        if (i < 10) {
#line 329
          if (! (matchf == -1)) {
#line 329
            goto while_break;
          }
        } else {
#line 329
          goto while_break;
        }
        {
#line 330
        tmp___0 = __errno_location();
#line 330
        tmp___1 = strerror(*tmp___0);
#line 330
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error trying to open %s exclusively (%s). retrying in 1 seconds.\n",
                buffer, tmp___1);
#line 331
        tmp___2 = rand();
#line 331
        usleep((__useconds_t )((double )1000000 + (100000.0 * (double )tmp___2) / ((double )2147483647 + 1.0)));
#line 332
        matchf = open((char const   *)(buffer), 2048);
#line 329
        i ++;
        }
      }
      while_break: /* CIL Label */ ;
      }
#line 334
      if (matchf != -1) {
        {
#line 335
        close(matchf);
#line 336
        close(dev);
#line 337
        tmp___3 = strdup((char const   *)(buffer));
        }
#line 337
        return (tmp___3);
      }
    }
  }
#line 343
  if (dev == -1) {
    {
#line 344
    idperror(messagedest, messages, "\t\tCould not access device %s", device);
    }
#line 347
    goto matchfail;
  }
  {
#line 349
  tmp___6 = get_scsi_id(dev, & a);
  }
#line 349
  if (tmp___6) {
    {
#line 350
    idperror(messagedest, messages, "\t\tDevice %s could not perform ioctl()", device);
    }
#line 353
    goto matchfail;
  }
#line 357
  i = 0;
  {
#line 357
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 357
    if (! (i < 25)) {
#line 357
      goto while_break___0;
    }
#line 358
    j = 0;
    {
#line 358
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 358
      if (! (j < 2)) {
#line 358
        goto while_break___1;
      }
#line 359
      pattern = 0;
      {
#line 362
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 362
        if (! ((unsigned long )*(prefixes + pattern) != (unsigned long )((void *)0))) {
#line 362
          goto while_break___2;
        }
        {
#line 364
        if (j == 0) {
#line 364
          goto case_0;
        }
#line 368
        if (j == 1) {
#line 368
          goto case_1;
        }
#line 363
        goto switch_break;
        case_0: /* CIL Label */ 
        {
#line 366
        sprintf((char */* __restrict  */)(buffer), (char const   */* __restrict  */)"%s%d",
                *(prefixes + pattern), i);
        }
#line 367
        goto switch_break;
        case_1: /* CIL Label */ 
        {
#line 370
        sprintf((char */* __restrict  */)(buffer), (char const   */* __restrict  */)"%s%c",
                *(prefixes + pattern), i + 97);
        }
#line 371
        goto switch_break;
        switch_break: /* CIL Label */ ;
        }
        {
#line 374
        matchf___0 = open((char const   *)(buffer), 2048);
#line 375
        k = 0;
        }
        {
#line 375
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 375
          if (k < 10) {
#line 375
            if (! (matchf___0 == -1)) {
#line 375
              goto while_break___3;
            }
          } else {
#line 375
            goto while_break___3;
          }
          {
#line 376
          tmp___7 = __errno_location();
#line 376
          tmp___8 = strerror(*tmp___7);
#line 376
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error trying to open %s exclusively (%s). retrying in 1 second.\n",
                  buffer, tmp___8);
#line 377
          tmp___9 = rand();
#line 377
          usleep((__useconds_t )((double )1000000 + (100000.0 * (double )tmp___9) / ((double )2147483647 + 1.0)));
#line 378
          matchf___0 = open((char const   *)(buffer), 2048);
#line 375
          k ++;
          }
        }
        while_break___3: /* CIL Label */ ;
        }
#line 381
        if (matchf___0 != -1) {
          {
#line 382
          tmp___11 = get_scsi_id(matchf___0, & b);
          }
#line 382
          if (tmp___11 == 0) {
#line 383
            if (a.bus == b.bus) {
#line 383
              if (a.id == b.id) {
#line 383
                if (a.lun == b.lun) {
                  {
#line 384
                  close(matchf___0);
#line 385
                  close(dev);
#line 386
                  tmp___10 = strdup((char const   *)(buffer));
                  }
#line 386
                  return (tmp___10);
                }
              }
            }
          }
          {
#line 389
          close(matchf___0);
          }
        }
#line 391
        pattern ++;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 358
      j ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 357
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 396
  idmessage(messagedest, messages, (char const   *)prompt, device);
  }
  matchfail: 
#line 400
  if (dev != -1) {
    {
#line 400
    close(dev);
    }
  }
#line 401
  return ((char *)((void *)0));
}
}
#line 404 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/interface/scan_devices.c"
void strscat(char *a , char *b , int n ) 
{ 
  int i ;
  char *__cil_tmp5 ;

  {
#line 407
  i = n;
  {
#line 407
  while (1) {
    while_continue: /* CIL Label */ ;
#line 407
    if (! (i > 0)) {
#line 407
      goto while_break;
    }
#line 408
    if ((int )*(b + (i - 1)) > 32) {
#line 408
      goto while_break;
    }
#line 407
    i --;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 410
  strncat((char */* __restrict  */)a, (char const   */* __restrict  */)b, (size_t )i);
#line 411
  strcat((char */* __restrict  */)a, (char const   */* __restrict  */)" ");
  }
#line 412
  return;
}
}
#line 416 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/interface/scan_devices.c"
static int verify_SG_version(cdrom_drive *d___0 , int messagedest , char **messages ) 
{ 
  int version ;
  int major ;
  int minor ;
  char buffer[256] ;
  int tmp ;
  void *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;

  {
  {
#line 421
  idmessage(messagedest, messages, "\nFound an accessible SCSI CDROM drive.\nLooking at revision of the SG interface in use...",
            "");
#line 425
  tmp = ioctl(d___0->cdda_fd, 8834UL, & version);
  }
#line 425
  if (tmp) {
    {
#line 427
    idmessage(messagedest, messages, "\tOOPS!  Old 2.0/early 2.1/early 2.2.x (non-ac patch) style SG.\n\tCdparanoia no longer supports the old interface.\n",
              "");
    }
#line 430
    return (0);
  }
  {
#line 432
  major = version / 10000;
#line 433
  version -= major * 10000;
#line 434
  minor = version / 100;
#line 435
  version -= minor * 100;
#line 437
  sprintf((char */* __restrict  */)(buffer), (char const   */* __restrict  */)"\tSG interface version %d.%d.%d; OK.",
          major, minor, version);
#line 440
  idmessage(messagedest, messages, (char const   *)(buffer), "");
  }
#line 441
  return (major);
}
}
#line 444 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/interface/scan_devices.c"
int check_sgio(char const   *device , int messagedest , char **messages ) 
{ 
  int fd ;
  struct sg_io_hdr hdr ;
  int *tmp ;
  int tmp___0 ;
  char *__cil_tmp8 ;

  {
#line 448
  if (! device) {
#line 448
    return (0);
  }
  {
#line 453
  fd = open(device, 2050);
  }
#line 454
  if (fd < 0) {
    {
#line 455
    idperror(messagedest, messages, "\t\tCould not access device %s to test for SG_IO support",
             device);
    }
#line 457
    return (0);
  }
  {
#line 460
  memset((void *)(& hdr), 0, (size_t )sizeof(struct sg_io_hdr ));
#line 464
  hdr.interface_id = 'A';
#line 465
  tmp___0 = ioctl(fd, 8837UL, & hdr);
  }
#line 465
  if (tmp___0) {
    {
#line 466
    tmp = __errno_location();
    }
    {
#line 470
    if (*tmp == 38) {
#line 470
      goto case_38;
    }
#line 470
    if (*tmp == 22) {
#line 470
      goto case_38;
    }
#line 477
    goto switch_default;
    case_38: /* CIL Label */ 
    case_22: /* CIL Label */ 
    {
#line 474
    close(fd);
    }
#line 475
    return (1);
    switch_default: /* CIL Label */ 
    {
#line 480
    close(fd);
    }
#line 481
    return (0);
    switch_break: /* CIL Label */ ;
    }
  }
  {
#line 488
  close(fd);
  }
#line 489
  return (0);
}
}
#line 496 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/interface/scan_devices.c"
cdrom_drive *cdda_identify_scsi(char const   *generic_device , char const   *specialized_device ,
                                int messagedest , char **messages ) 
{ 
  cdrom_drive *d___0 ;
  struct stat i_st ;
  struct stat g_st ;
  int use_sgio ;
  int i_fd ;
  int g_fd ;
  int version ;
  int type ;
  char *p___0 ;
  int tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  char *temp ;
  char *tmp___4 ;
  char *tmp___5 ;
  char const   *tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  void *tmp___9 ;
  void *tmp___10 ;
  struct timespec tv ;
  int tmp___12 ;
  struct sg_header *tmp___13 ;
  void *tmp___14 ;
  int tmp___15 ;
  void *tmp___16 ;
  scsiid lun ;
  int tmp___17 ;
  unsigned char *tmp___18 ;
  unsigned char *tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  void *tmp___22 ;
  void *tmp___23 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;
  char *__cil_tmp52 ;
  char *__cil_tmp53 ;
  char *__cil_tmp54 ;
  char *__cil_tmp55 ;
  char *__cil_tmp56 ;
  char *__cil_tmp57 ;
  char *__cil_tmp58 ;
  char *__cil_tmp59 ;
  char *__cil_tmp60 ;
  char *__cil_tmp61 ;
  char *__cil_tmp62 ;
  char *__cil_tmp63 ;
  char *__cil_tmp64 ;
  char *__cil_tmp65 ;
  char *__cil_tmp66 ;
  char *__cil_tmp67 ;
  char *__cil_tmp68 ;
  char *__cil_tmp69 ;

  {
#line 500
  d___0 = (cdrom_drive *)((void *)0);
#line 503
  use_sgio = 1;
#line 504
  i_fd = -1;
#line 505
  g_fd = -1;
#line 510
  if (generic_device) {
    {
#line 511
    idmessage(messagedest, messages, "\tTesting %s for SCSI/MMC interface", generic_device);
    }
  } else
#line 514
  if (specialized_device) {
    {
#line 515
    idmessage(messagedest, messages, "\tTesting %s for SCSI/MMC interface", specialized_device);
    }
  }
#line 519
  if (generic_device) {
    {
#line 520
    use_sgio = 0;
#line 521
    idmessage(messagedest, messages, "\t\tgeneric device forced; not testing for SG_IO interface",
              generic_device);
#line 524
    tmp = stat((char const   */* __restrict  */)generic_device, (struct stat */* __restrict  */)(& g_st));
    }
#line 524
    if (tmp) {
      {
#line 525
      idperror(messagedest, messages, "\t\tCould not access device %s", generic_device);
      }
#line 527
      return ((cdrom_drive *)((void *)0));
    }
#line 530
    if ((int )(g_st.st_rdev >> 8) != 21) {
      {
#line 531
      idmessage(messagedest, messages, "\t\t%s is not a generic SCSI device", generic_device);
      }
#line 533
      return ((cdrom_drive *)((void *)0));
    }
  }
#line 537
  if (specialized_device) {
    {
#line 538
    tmp___0 = stat((char const   */* __restrict  */)specialized_device, (struct stat */* __restrict  */)(& i_st));
    }
#line 538
    if (tmp___0) {
      {
#line 539
      idperror(messagedest, messages, "\t\tCould not access device %s", specialized_device);
      }
#line 541
      return ((cdrom_drive *)((void *)0));
    }
  }
#line 547
  if (generic_device) {
    {
#line 548
    tmp___1 = test_resolve_symlink(generic_device, messagedest, messages);
#line 548
    generic_device = (char const   *)tmp___1;
    }
#line 549
    if ((unsigned long )generic_device == (unsigned long )((void *)0)) {
#line 549
      goto cdda_identify_scsi_fail;
    }
  }
#line 551
  if (specialized_device) {
    {
#line 552
    tmp___2 = test_resolve_symlink(specialized_device, messagedest, messages);
#line 552
    specialized_device = (char const   *)tmp___2;
    }
#line 553
    if ((unsigned long )specialized_device == (unsigned long )((void *)0)) {
#line 553
      goto cdda_identify_scsi_fail;
    }
  }
#line 557
  if (use_sgio) {
    {
#line 558
    tmp___3 = check_sgio(specialized_device, messagedest, messages);
    }
#line 558
    if (tmp___3) {
      {
#line 559
      idmessage(messagedest, messages, "\t\tSG_IO device: %s", specialized_device);
      }
    } else {
      {
#line 561
      idmessage(messagedest, messages, "\t\tno SG_IO support for device: %s", specialized_device);
#line 562
      use_sgio = 0;
      }
    }
  }
#line 566
  if (! use_sgio) {
#line 569
    if (specialized_device) {
#line 570
      if ((int )(i_st.st_rdev >> 8) == 21) {
#line 571
        temp = (char *)generic_device;
#line 572
        generic_device = specialized_device;
#line 573
        specialized_device = (char const   *)temp;
      }
#line 576
      if (! generic_device) {
#line 576
        goto _L;
      } else
#line 576
      if (! specialized_device) {
        _L: /* CIL Label */ 
#line 577
        if (generic_device) {
          {
#line 578
          tmp___4 = scsi_match(generic_device, scsi_cdrom_prefixes, devfs_scsi_test,
                               devfs_scsi_cd, (char *)"\t\tNo cdrom device found to match generic device %s",
                               messagedest, messages);
#line 578
          specialized_device = (char const   *)tmp___4;
          }
        } else {
          {
#line 584
          tmp___5 = scsi_match(specialized_device, scsi_generic_prefixes, devfs_scsi_test,
                               devfs_scsi_generic, (char *)"\t\tNo generic SCSI device found to match CDROM device %s",
                               messagedest, messages);
#line 584
          generic_device = (char const   *)tmp___5;
          }
#line 589
          if (! generic_device) {
#line 590
            goto cdda_identify_scsi_fail;
          }
        }
      }
    }
    {
#line 595
    idmessage(messagedest, messages, "\t\tgeneric device: %s", generic_device);
    }
#line 596
    if (specialized_device) {
#line 596
      tmp___6 = specialized_device;
    } else {
#line 596
      tmp___6 = "not found";
    }
    {
#line 596
    idmessage(messagedest, messages, "\t\tioctl device: %s", tmp___6);
    }
#line 599
    if (specialized_device) {
      {
#line 600
      tmp___7 = stat((char const   */* __restrict  */)specialized_device, (struct stat */* __restrict  */)(& i_st));
      }
#line 600
      if (tmp___7) {
        {
#line 601
        idperror(messagedest, messages, "\t\tCould not access cdrom device %s", specialized_device);
        }
#line 603
        goto cdda_identify_scsi_fail;
      }
    }
    {
#line 607
    tmp___8 = stat((char const   */* __restrict  */)generic_device, (struct stat */* __restrict  */)(& g_st));
    }
#line 607
    if (tmp___8) {
      {
#line 608
      idperror(messagedest, messages, "\t\tCould not access generic SCSI device %s",
               generic_device);
      }
#line 611
      goto cdda_identify_scsi_fail;
    }
  }
#line 615
  if (specialized_device) {
#line 616
    if (use_sgio) {
      {
#line 617
      i_fd = open(specialized_device, 2050);
      }
    } else {
      {
#line 619
      i_fd = open(specialized_device, 2048);
      }
    }
  }
#line 622
  if (generic_device) {
    {
#line 623
    g_fd = open(generic_device, 2);
    }
  }
#line 626
  if (specialized_device) {
#line 626
    if (i_fd == -1) {
      {
#line 627
      idperror(messagedest, messages, "\t\tCould not open cdrom device %s (continuing)",
               specialized_device);
      }
#line 629
      goto cdda_identify_scsi_fail;
    }
  }
#line 632
  if (generic_device) {
#line 632
    if (g_fd == -1) {
      {
#line 633
      idperror(messagedest, messages, "\t\tCould not open generic SCSI device %s",
               generic_device);
      }
#line 635
      goto cdda_identify_scsi_fail;
    }
  }
#line 638
  if (i_fd != -1) {
#line 639
    type = (int )(i_st.st_rdev >> 8);
#line 641
    if (! use_sgio) {
#line 642
      if (type == 11) {
#line 643
        if (! ((i_st.st_mode & 61440U) == 24576U)) {
          {
#line 644
          idmessage(messagedest, messages, "\t\tSCSI CDROM device %s not a block device",
                    specialized_device);
          }
#line 646
          goto cdda_identify_scsi_fail;
        }
      } else {
        {
#line 649
        idmessage(messagedest, messages, "\t\tSCSI CDROM device %s has wrong major number",
                  specialized_device);
        }
#line 651
        goto cdda_identify_scsi_fail;
      }
    }
  }
#line 656
  if (g_fd != -1) {
#line 657
    if ((int )(g_st.st_rdev >> 8) == 21) {
#line 658
      if (! ((g_st.st_mode & 61440U) == 8192U)) {
        {
#line 659
        idmessage(messagedest, messages, "\t\tGeneric SCSI device %s not a char device",
                  generic_device);
        }
#line 661
        goto cdda_identify_scsi_fail;
      }
    } else {
      {
#line 664
      idmessage(messagedest, messages, "\t\tGeneric SCSI device %s has wrong major number",
                generic_device);
      }
#line 666
      goto cdda_identify_scsi_fail;
    }
  }
  {
#line 670
  tmp___9 = calloc((size_t )1, (size_t )sizeof(cdrom_drive ));
#line 670
  d___0 = (cdrom_drive *)tmp___9;
#line 671
  d___0->drive_type = type;
#line 672
  d___0->cdda_fd = g_fd;
#line 673
  d___0->ioctl_fd = i_fd;
#line 674
  d___0->bigendianp = -1;
#line 675
  d___0->nsectors = -1;
#line 676
  d___0->messagedest = messagedest;
#line 677
  tmp___10 = calloc((size_t )1, (size_t )sizeof(*(d___0->private)));
#line 677
  d___0->private = (cdda_private_data_t *)tmp___10;
#line 681
  tmp___12 = clock_gettime(1, & tv);
  }
#line 681
  if (tmp___12 < 0) {
#line 681
    (d___0->private)->clock = 0;
  } else {
#line 681
    (d___0->private)->clock = 1;
  }
#line 683
  if (use_sgio) {
    {
#line 684
    d___0->interface = 3;
#line 685
    tmp___14 = malloc((size_t )65536);
#line 685
    tmp___13 = (struct sg_header *)tmp___14;
#line 685
    (d___0->private)->sg_hd = tmp___13;
#line 685
    (d___0->private)->sg_buffer = (unsigned char *)tmp___13;
#line 686
    tmp___15 = dup(d___0->ioctl_fd);
#line 686
    d___0->cdda_fd = tmp___15;
#line 686
    g_fd = tmp___15;
    }
  } else {
    {
#line 688
    version = verify_SG_version(d___0, messagedest, messages);
    }
    {
#line 690
    if (version == 1) {
#line 690
      goto case_1;
    }
#line 690
    if (version == 0) {
#line 690
      goto case_1;
    }
#line 690
    if (version == -1) {
#line 690
      goto case_1;
    }
#line 693
    if (version == 3) {
#line 693
      goto case_3;
    }
#line 693
    if (version == 2) {
#line 693
      goto case_3;
    }
#line 689
    goto switch_break;
    case_1: /* CIL Label */ 
    case_0: /* CIL Label */ 
    case_neg_1: /* CIL Label */ 
#line 691
    d___0->interface = 0;
#line 692
    goto cdda_identify_scsi_fail;
    case_3: /* CIL Label */ 
    case_2: /* CIL Label */ 
#line 694
    d___0->interface = 0;
#line 695
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
    {
#line 699
    tmp___16 = malloc((size_t )65536);
#line 699
    (d___0->private)->sg_hd = (struct sg_header *)tmp___16;
#line 700
    (d___0->private)->sg_buffer = (unsigned char *)(d___0->private)->sg_hd + sizeof(struct sg_header );
    }
  }
  {
#line 706
  tmp___17 = get_scsi_id(i_fd, & lun);
  }
#line 706
  if (tmp___17) {
#line 707
    d___0->lun = 0;
  } else {
#line 709
    d___0->lun = lun.lun;
  }
  {
#line 712
  tmp___18 = scsi_inquiry(d___0);
#line 712
  p___0 = (char *)tmp___18;
  }
#line 714
  if (! p___0) {
#line 721
    if (d___0->interface == 3) {
      {
#line 723
      d___0->interface = 4;
#line 724
      tmp___19 = scsi_inquiry(d___0);
#line 724
      p___0 = (char *)tmp___19;
      }
#line 726
      if (p___0) {
        {
#line 727
        idmessage(messagedest, messages, "\t\tThis kernel\'s block layer has a buggy SG_DXFER_TO_FROM_DEVICE;\n\t\t   activating workaround.\n",
                  (char const   *)((void *)0));
        }
      } else {
#line 731
        d___0->interface = 3;
      }
    }
  }
#line 736
  if (! p___0) {
    {
#line 737
    idmessage(messagedest, messages, "\t\tInquiry command failed; unable to probe drive\n",
              (char const   *)((void *)0));
    }
#line 739
    goto cdda_identify_scsi_fail;
  }
#line 743
  if (p___0) {
    {
#line 743
    tmp___20 = strncmp((char const   *)(p___0 + 8), "TOSHIBA", (size_t )7);
    }
#line 743
    if (! tmp___20) {
      {
#line 743
      tmp___21 = strncmp((char const   *)(p___0 + 16), "CD-ROM", (size_t )6);
      }
#line 743
      if (! tmp___21) {
#line 743
        if ((int )*(p___0 + 0) == 0) {
#line 747
          *(p___0 + 0) = (char)5;
#line 748
          *(p___0 + 1) = (char )((int )*(p___0 + 1) | 128);
        }
      }
    }
  }
#line 751
  if ((int )*p___0 != 5) {
#line 751
    if ((int )*p___0 != 4) {
      {
#line 752
      idmessage(messagedest, messages, "\t\tDrive is neither a CDROM nor a WORM device\n",
                (char const   *)((void *)0));
      }
#line 754
      goto cdda_identify_scsi_fail;
    }
  }
  {
#line 757
  tmp___22 = calloc((size_t )36, (size_t )1);
#line 757
  d___0->drive_model = (char *)tmp___22;
#line 758
  memcpy((void */* __restrict  */)(d___0->inqbytes), (void const   */* __restrict  */)p___0,
         (size_t )4);
#line 759
  d___0->cdda_device_name = copystring(generic_device);
#line 760
  d___0->ioctl_device_name = copystring(specialized_device);
#line 761
  tmp___23 = calloc((size_t )36, (size_t )1);
#line 761
  d___0->drive_model = (char *)tmp___23;
#line 762
  strscat(d___0->drive_model, p___0 + 8, 8);
#line 763
  strscat(d___0->drive_model, p___0 + 16, 16);
#line 764
  strscat(d___0->drive_model, p___0 + 32, 4);
#line 766
  idmessage(messagedest, messages, "\nCDROM model sensed sensed: %s", (char const   *)d___0->drive_model);
  }
#line 767
  return (d___0);
  cdda_identify_scsi_fail: 
#line 770
  if (generic_device) {
    {
#line 770
    free((void *)((char *)generic_device));
    }
  }
#line 771
  if (specialized_device) {
    {
#line 771
    free((void *)((char *)specialized_device));
    }
  }
#line 772
  if (i_fd != -1) {
    {
#line 772
    close(i_fd);
    }
  }
#line 773
  if (g_fd != -1) {
    {
#line 773
    close(g_fd);
    }
  }
#line 774
  if (d___0) {
#line 775
    if (d___0->private) {
#line 776
      if ((d___0->private)->sg_hd) {
        {
#line 776
        free((void *)(d___0->private)->sg_hd);
        }
      }
      {
#line 777
      free((void *)d___0->private);
      }
    }
    {
#line 779
    free((void *)d___0);
    }
  }
#line 781
  return ((cdrom_drive *)((void *)0));
}
}
#line 40 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/paranoia/isort.h"
sort_info *sort_alloc(long size ) ;
#line 48
void sort_unsortall(sort_info *i ) ;
#line 63
void sort_setup(sort_info *i , int16_t *vector , long *abspos , long size , long sortlo ,
                long sorthi ) ;
#line 71
void sort_free(sort_info *i ) ;
#line 84
sort_link *sort_getmatch(sort_info *i , long post , long overlap___0 , int value ) ;
#line 95
sort_link *sort_nextmatch(sort_info *i , sort_link *prev ) ;
#line 36 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/paranoia/isort.c"
sort_info *sort_alloc(long size ) 
{ 
  sort_info *ret ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;

  {
  {
#line 37
  tmp = calloc((size_t )1, (size_t )sizeof(sort_info ));
#line 37
  ret = (sort_info *)tmp;
#line 39
  ret->vector = (int16_t *)((void *)0);
#line 40
  ret->sortbegin = -1L;
#line 41
  ret->size = -1L;
#line 42
  ret->maxsize = size;
#line 44
  tmp___0 = calloc((size_t )65536, (size_t )sizeof(sort_link *));
#line 44
  ret->head = (sort_link **)tmp___0;
#line 45
  tmp___1 = malloc((size_t )(65536UL * sizeof(long )));
#line 45
  ret->bucketusage = (long *)tmp___1;
#line 46
  tmp___2 = calloc((size_t )size, (size_t )sizeof(sort_link ));
#line 46
  ret->revindex = (sort_link *)tmp___2;
#line 47
  ret->lastbucket = 0L;
  }
#line 49
  return (ret);
}
}
#line 60 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/paranoia/isort.c"
void sort_unsortall(sort_info *i ) 
{ 
  long b ;

  {
#line 67
  if (i->lastbucket > 2000L) {
    {
#line 68
    memset((void *)i->head, 0, (size_t )(65536UL * sizeof(sort_link *)));
    }
  } else {
#line 71
    b = 0L;
    {
#line 71
    while (1) {
      while_continue: /* CIL Label */ ;
#line 71
      if (! (b < i->lastbucket)) {
#line 71
        goto while_break;
      }
#line 72
      *(i->head + *(i->bucketusage + b)) = (sort_link *)((void *)0);
#line 71
      b ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 75
  i->lastbucket = 0L;
#line 76
  i->sortbegin = -1L;
#line 82
  return;
}
}
#line 91 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/paranoia/isort.c"
void sort_free(sort_info *i ) 
{ 


  {
  {
#line 92
  free((void *)i->revindex);
#line 93
  free((void *)i->head);
#line 94
  free((void *)i->bucketusage);
#line 95
  free((void *)i);
  }
#line 96
  return;
}
}
#line 107 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/paranoia/isort.c"
static void sort_sort(sort_info *i , long sortlo , long sorthi ) 
{ 
  long j ;
  sort_link **hv ;
  sort_link *l ;

  {
#line 114
  j = sorthi - 1L;
  {
#line 114
  while (1) {
    while_continue: /* CIL Label */ ;
#line 114
    if (! (j >= sortlo)) {
#line 114
      goto while_break;
    }
#line 127
    hv = (i->head + (int )*(i->vector + j)) + 32768;
#line 128
    l = i->revindex + j;
#line 134
    if ((unsigned long )*hv == (unsigned long )((void *)0)) {
#line 135
      *(i->bucketusage + i->lastbucket) = (long )((int )*(i->vector + j) + 32768);
#line 136
      (i->lastbucket) ++;
    }
#line 142
    l->next = *hv;
#line 143
    *hv = l;
#line 114
    j --;
  }
  while_break: /* CIL Label */ ;
  }
#line 148
  i->sortbegin = 0L;
#line 149
  return;
}
}
#line 166 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/paranoia/isort.c"
void sort_setup(sort_info *i , int16_t *vector , long *abspos , long size , long sortlo ,
                long sorthi ) 
{ 
  long tmp___0 ;
  long tmp___1 ;
  long tmp___3 ;
  long tmp___4 ;

  {
#line 170
  if (i->sortbegin != -1L) {
    {
#line 170
    sort_unsortall(i);
    }
  }
#line 172
  i->vector = vector;
#line 173
  i->size = size;
#line 174
  i->abspos = abspos;
#line 180
  if (sortlo - *abspos < 0L) {
#line 180
    tmp___1 = 0L;
  } else {
#line 180
    tmp___1 = sortlo - *abspos;
  }
#line 180
  if (size > tmp___1) {
#line 180
    if (sortlo - *abspos < 0L) {
#line 180
      tmp___0 = 0L;
    } else {
#line 180
      tmp___0 = sortlo - *abspos;
    }
#line 180
    i->lo = tmp___0;
  } else {
#line 180
    i->lo = size;
  }
#line 181
  if (sorthi - *abspos > size) {
#line 181
    tmp___4 = size;
  } else {
#line 181
    tmp___4 = sorthi - *abspos;
  }
#line 181
  if (0L < tmp___4) {
#line 181
    if (sorthi - *abspos > size) {
#line 181
      tmp___3 = size;
    } else {
#line 181
      tmp___3 = sorthi - *abspos;
    }
#line 181
    i->hi = tmp___3;
  } else {
#line 181
    i->hi = 0L;
  }
#line 182
  return;
}
}
#line 196 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/paranoia/isort.c"
sort_link *sort_getmatch(sort_info *i , long post , long overlap___0 , int value ) 
{ 
  sort_link *ret ;
  long tmp___0 ;
  long tmp___1 ;

  {
#line 201
  if (i->sortbegin == -1L) {
    {
#line 201
    sort_sort(i, i->lo, i->hi);
    }
  }
#line 211
  if (i->size > post) {
#line 211
    tmp___1 = post;
  } else {
#line 211
    tmp___1 = i->size;
  }
#line 211
  if (0L < tmp___1) {
#line 211
    if (i->size > post) {
#line 211
      tmp___0 = post;
    } else {
#line 211
      tmp___0 = i->size;
    }
#line 211
    post = tmp___0;
  } else {
#line 211
    post = 0L;
  }
#line 212
  i->val = value + 32768;
#line 213
  if (0L < post - overlap___0) {
#line 213
    i->lo = post - overlap___0;
  } else {
#line 213
    i->lo = 0L;
  }
#line 214
  if (i->size > post + overlap___0) {
#line 214
    i->hi = post + overlap___0;
  } else {
#line 214
    i->hi = i->size;
  }
#line 220
  ret = *(i->head + i->val);
  {
#line 222
  while (1) {
    while_continue: /* CIL Label */ ;
#line 222
    if (! ret) {
#line 222
      goto while_break;
    }
#line 227
    if (ret - i->revindex < i->lo) {
#line 228
      ret = ret->next;
    } else {
#line 230
      if (ret - i->revindex >= i->hi) {
#line 231
        ret = (sort_link *)((void *)0);
      }
#line 232
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 236
  return (ret);
}
}
#line 250 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/paranoia/isort.c"
sort_link *sort_nextmatch(sort_info *i , sort_link *prev ) 
{ 
  sort_link *ret ;

  {
#line 251
  ret = prev->next;
#line 256
  if (! ret) {
#line 256
    return ((sort_link *)((void *)0));
  } else
#line 256
  if (ret - i->revindex >= i->hi) {
#line 256
    return ((sort_link *)((void *)0));
  }
#line 258
  return (ret);
}
}
#line 9 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/paranoia/gap.h"
long i_paranoia_overlap_r(int16_t *buffA , int16_t *buffB , long offsetA , long offsetB ) ;
#line 11
long i_paranoia_overlap_f(int16_t *buffA , int16_t *buffB , long offsetA , long offsetB ,
                          long sizeA , long sizeB ) ;
#line 14
int i_stutter_or_gap(int16_t *A , int16_t *B , long offA , long offB , long gap ) ;
#line 16
void i_analyze_rift_f(int16_t *A , int16_t *B , long sizeA , long sizeB , long aoffset ,
                      long boffset , long *matchA , long *matchB , long *matchC ) ;
#line 20
void i_analyze_rift_r(int16_t *A , int16_t *B , long sizeA , long sizeB , long aoffset ,
                      long boffset , long *matchA , long *matchB , long *matchC ) ;
#line 25
void analyze_rift_silence_f(int16_t *A , int16_t *B , long sizeA , long sizeB , long aoffset ,
                            long boffset , long *matchA , long *matchB ) ;
#line 29 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/paranoia/gap.c"
long i_paranoia_overlap_r(int16_t *buffA , int16_t *buffB , long offsetA , long offsetB ) 
{ 
  long beginA ;
  long beginB ;

  {
#line 31
  beginA = offsetA;
#line 32
  beginB = offsetB;
  {
#line 37
  while (1) {
    while_continue: /* CIL Label */ ;
#line 37
    if (beginA >= 0L) {
#line 37
      if (! (beginB >= 0L)) {
#line 37
        goto while_break;
      }
    } else {
#line 37
      goto while_break;
    }
#line 38
    if ((int )*(buffA + beginA) != (int )*(buffB + beginB)) {
#line 38
      goto while_break;
    }
#line 37
    beginA --;
#line 37
    beginB --;
  }
  while_break: /* CIL Label */ ;
  }
#line 40
  return (offsetA - beginA);
}
}
#line 57 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/paranoia/gap.c"
long i_paranoia_overlap_f(int16_t *buffA , int16_t *buffB , long offsetA , long offsetB ,
                          long sizeA , long sizeB ) 
{ 
  long endA ;
  long endB ;

  {
#line 60
  endA = offsetA;
#line 61
  endB = offsetB;
  {
#line 66
  while (1) {
    while_continue: /* CIL Label */ ;
#line 66
    if (endA < sizeA) {
#line 66
      if (! (endB < sizeB)) {
#line 66
        goto while_break;
      }
    } else {
#line 66
      goto while_break;
    }
#line 67
    if ((int )*(buffA + endA) != (int )*(buffB + endB)) {
#line 67
      goto while_break;
    }
#line 66
    endA ++;
#line 66
    endB ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 69
  return (endA - offsetA);
}
}
#line 84 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/paranoia/gap.c"
int i_stutter_or_gap(int16_t *A , int16_t *B , long offA , long offB , long gap ) 
{ 
  long a1 ;
  long b1 ;
  int tmp ;

  {
#line 86
  a1 = offA;
#line 87
  b1 = offB;
#line 103
  if (a1 < 0L) {
#line 106
    b1 -= a1;
#line 107
    gap += a1;
#line 108
    a1 = 0L;
  }
  {
#line 119
  tmp = memcmp((void const   *)(A + a1), (void const   *)(B + b1), (size_t )(gap * 2L));
  }
#line 119
  return (tmp);
}
}
#line 141 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/paranoia/gap.c"
void i_analyze_rift_f(int16_t *A , int16_t *B , long sizeA , long sizeB , long aoffset ,
                      long boffset , long *matchA , long *matchB , long *matchC ) 
{ 
  long apast ;
  long bpast ;
  long i ;
  long tmp ;
  long tmp___0 ;
  long tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 146
  apast = sizeA - aoffset;
#line 147
  bpast = sizeB - boffset;
#line 150
  *matchA = 0L;
#line 150
  *matchB = 0L;
#line 150
  *matchC = 0L;
#line 177
  i = 1L;
  {
#line 177
  while (1) {
    while_continue: /* CIL Label */ ;
#line 183
    if (i < bpast) {
      {
#line 188
      tmp = i_paranoia_overlap_f(A, B, aoffset, boffset + i, sizeA, sizeB);
      }
#line 188
      if (tmp >= 16L) {
#line 189
        *matchA = i;
#line 190
        goto while_break;
      }
    }
#line 194
    if (i < apast) {
      {
#line 199
      tmp___0 = i_paranoia_overlap_f(A, B, aoffset + i, boffset, sizeA, sizeB);
      }
#line 199
      if (tmp___0 >= 16L) {
#line 200
        *matchB = i;
#line 201
        goto while_break;
      }
#line 205
      if (i < bpast) {
        {
#line 210
        tmp___1 = i_paranoia_overlap_f(A, B, aoffset + i, boffset + i, sizeA, sizeB);
        }
#line 210
        if (tmp___1 >= 16L) {
#line 211
          *matchC = i;
#line 212
          goto while_break;
        }
      }
    } else
#line 220
    if (i >= bpast) {
#line 220
      goto while_break;
    }
#line 177
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 225
  if (*matchA == 0L) {
#line 225
    if (*matchB == 0L) {
#line 225
      if (*matchC == 0L) {
#line 225
        return;
      }
    }
  }
#line 227
  if (*matchC) {
#line 227
    return;
  }
#line 249
  if (*matchA) {
    {
#line 256
    tmp___2 = i_stutter_or_gap(A, B, aoffset - *matchA, boffset, *matchA);
    }
#line 256
    if (tmp___2) {
#line 257
      return;
    }
#line 262
    *matchB = - *matchA;
#line 263
    *matchA = 0L;
#line 264
    return;
  } else {
    {
#line 268
    tmp___3 = i_stutter_or_gap(B, A, boffset - *matchB, aoffset, *matchB);
    }
#line 268
    if (tmp___3) {
#line 269
      return;
    }
#line 271
    *matchA = - *matchB;
#line 272
    *matchB = 0L;
#line 273
    return;
  }
}
}
#line 296 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/paranoia/gap.c"
void i_analyze_rift_r(int16_t *A , int16_t *B , long sizeA , long sizeB , long aoffset ,
                      long boffset , long *matchA , long *matchB , long *matchC ) 
{ 
  long apast ;
  long bpast ;
  long i ;
  long tmp ;
  long tmp___0 ;
  long tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 301
  apast = aoffset + 1L;
#line 302
  bpast = boffset + 1L;
#line 305
  *matchA = 0L;
#line 305
  *matchB = 0L;
#line 305
  *matchC = 0L;
#line 332
  i = 1L;
  {
#line 332
  while (1) {
    while_continue: /* CIL Label */ ;
#line 338
    if (i < bpast) {
      {
#line 343
      tmp = i_paranoia_overlap_r(A, B, aoffset, boffset - i);
      }
#line 343
      if (tmp >= 16L) {
#line 344
        *matchA = i;
#line 345
        goto while_break;
      }
    }
#line 349
    if (i < apast) {
      {
#line 354
      tmp___0 = i_paranoia_overlap_r(A, B, aoffset - i, boffset);
      }
#line 354
      if (tmp___0 >= 16L) {
#line 355
        *matchB = i;
#line 356
        goto while_break;
      }
#line 360
      if (i < bpast) {
        {
#line 365
        tmp___1 = i_paranoia_overlap_r(A, B, aoffset - i, boffset - i);
        }
#line 365
        if (tmp___1 >= 16L) {
#line 366
          *matchC = i;
#line 367
          goto while_break;
        }
      }
    } else
#line 375
    if (i >= bpast) {
#line 375
      goto while_break;
    }
#line 332
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 380
  if (*matchA == 0L) {
#line 380
    if (*matchB == 0L) {
#line 380
      if (*matchC == 0L) {
#line 380
        return;
      }
    }
  }
#line 382
  if (*matchC) {
#line 382
    return;
  }
#line 405
  if (*matchA) {
    {
#line 421
    tmp___2 = i_stutter_or_gap(A, B, aoffset + 1L, (boffset - *matchA) + 1L, *matchA);
    }
#line 421
    if (tmp___2) {
#line 422
      return;
    }
#line 427
    *matchB = - *matchA;
#line 428
    *matchA = 0L;
#line 429
    return;
  } else {
    {
#line 433
    tmp___3 = i_stutter_or_gap(B, A, boffset + 1L, (aoffset - *matchB) + 1L, *matchB);
    }
#line 433
    if (tmp___3) {
#line 434
      return;
    }
#line 436
    *matchA = - *matchB;
#line 437
    *matchB = 0L;
#line 438
    return;
  }
}
}
#line 463 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/paranoia/gap.c"
void analyze_rift_silence_f(int16_t *A , int16_t *B , long sizeA , long sizeB , long aoffset ,
                            long boffset , long *matchA , long *matchB ) 
{ 


  {
#line 466
  *matchA = -1L;
#line 467
  *matchB = -1L;
#line 472
  if (sizeA > aoffset + 16L) {
#line 472
    sizeA = aoffset + 16L;
  } else {
#line 472
    sizeA = sizeA;
  }
#line 473
  if (sizeB > boffset + 16L) {
#line 473
    sizeB = boffset + 16L;
  } else {
#line 473
    sizeB = sizeB;
  }
#line 475
  aoffset ++;
#line 476
  boffset ++;
  {
#line 481
  while (1) {
    while_continue: /* CIL Label */ ;
#line 481
    if (! (aoffset < sizeA)) {
#line 481
      goto while_break;
    }
#line 482
    if ((int )*(A + aoffset) != (int )*(A + (aoffset - 1L))) {
#line 483
      *matchA = 0L;
#line 484
      goto while_break;
    }
#line 486
    aoffset ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 495
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 495
    if (! (boffset < sizeB)) {
#line 495
      goto while_break___0;
    }
#line 496
    if ((int )*(B + boffset) != (int )*(B + (boffset - 1L))) {
#line 497
      *matchB = 0L;
#line 498
      goto while_break___0;
    }
#line 500
    boffset ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 502
  return;
}
}
#line 766 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int abs(int __x )  __attribute__((__const__)) ;
#line 80 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/paranoia/p_block.h"
void free_c_block(c_block *c ) ;
#line 81
void i_cblock_destructor(c_block *c ) ;
#line 100
void free_v_fragment(v_fragment *v ) ;
#line 105
c_block *c_first(struct cdrom_paranoia *p___0 ) ;
#line 107
c_block *c_next(c_block *c ) ;
#line 110
v_fragment *v_first(struct cdrom_paranoia *p___0 ) ;
#line 112
v_fragment *v_next(v_fragment *v ) ;
#line 168
void c_set(c_block *v , long begin ) ;
#line 173
void c_removef(c_block *v , long cut ) ;
#line 9 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/paranoia/overlap.h"
void offset_add_value(cdrom_paranoia *p___0 , offsets *o , long value , void (*callback___0)(long  ,
                                                                                             int  ) ) ;
#line 12
void offset_adjust_settings(cdrom_paranoia *p___0 , void (*callback___0)(long  , int  ) ) ;
#line 14
void i_paranoia_trim(cdrom_paranoia *p___0 , long beginword , long endword ) ;
#line 15
void paranoia_resetall(cdrom_paranoia *p___0 ) ;
#line 16
void paranoia_resetcache(cdrom_paranoia *p___0 ) ;
#line 19 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/paranoia/overlap.c"
void paranoia_resetcache(cdrom_paranoia *p___0 ) 
{ 
  c_block *c ;
  c_block *tmp ;
  v_fragment *v ;

  {
  {
#line 20
  tmp = c_first(p___0);
#line 20
  c = tmp;
  }
  {
#line 23
  while (1) {
    while_continue: /* CIL Label */ ;
#line 23
    if (! c) {
#line 23
      goto while_break;
    }
    {
#line 24
    free_c_block(c);
#line 25
    c = c_first(p___0);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 28
  v = v_first(p___0);
  }
  {
#line 29
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 29
    if (! v) {
#line 29
      goto while_break___0;
    }
    {
#line 30
    free_v_fragment(v);
#line 31
    v = v_first(p___0);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 33
  return;
}
}
#line 35 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/paranoia/overlap.c"
void paranoia_resetall(cdrom_paranoia *p___0 ) 
{ 


  {
#line 36
  p___0->root.returnedlimit = 0L;
#line 37
  p___0->dyndrift = 0L;
#line 38
  p___0->root.lastsector = 0L;
#line 40
  if (p___0->root.vector) {
    {
#line 41
    i_cblock_destructor(p___0->root.vector);
#line 42
    p___0->root.vector = (c_block *)((void *)0);
    }
  }
  {
#line 45
  paranoia_resetcache(p___0);
  }
#line 46
  return;
}
}
#line 48 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/paranoia/overlap.c"
void i_paranoia_trim(cdrom_paranoia *p___0 , long beginword , long endword ) 
{ 
  root_block *root ;
  long target ;
  long rbegin ;
  long rend ;
  long offset ;
  c_block *c ;
  c_block *tmp ;
  c_block *next ;
  c_block *tmp___0 ;

  {
#line 49
  root = & p___0->root;
#line 50
  if ((unsigned long )root->vector != (unsigned long )((void *)0)) {
#line 51
    target = beginword - 37632L;
#line 52
    rbegin = (root->vector)->begin;
#line 53
    rend = (root->vector)->begin + (root->vector)->size;
#line 55
    if (rbegin > beginword) {
#line 56
      goto rootfree;
    }
#line 58
    if (rbegin + 37632L < beginword) {
#line 59
      if (target + 64L > rend) {
#line 60
        goto rootfree;
      }
      {
#line 63
      offset = target - rbegin;
#line 64
      c_removef(root->vector, offset);
      }
    }
    {
#line 69
    tmp = c_first(p___0);
#line 69
    c = tmp;
    }
    {
#line 70
    while (1) {
      while_continue: /* CIL Label */ ;
#line 70
      if (! c) {
#line 70
        goto while_break;
      }
      {
#line 71
      tmp___0 = c_next(c);
#line 71
      next = tmp___0;
      }
#line 72
      if (c->begin + c->size < beginword - 37632L) {
        {
#line 73
        free_c_block(c);
        }
      }
#line 74
      c = next;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 79
  return;
  rootfree: 
  {
#line 83
  i_cblock_destructor(root->vector);
#line 84
  root->vector = (c_block *)((void *)0);
#line 85
  root->returnedlimit = -1L;
#line 86
  root->lastsector = 0L;
  }
#line 88
  return;
}
}
#line 104 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/paranoia/overlap.c"
void offset_adjust_settings(cdrom_paranoia *p___0 , void (*callback___0)(long  , int  ) ) 
{ 
  long av ;
  long tmp ;
  c_block *c ;
  c_block *tmp___0 ;
  v_fragment *v ;
  v_fragment *tmp___1 ;
  long adj ;
  long tmp___2 ;
  int tmp___3 ;

  {
#line 105
  if (p___0->stage2.offpoints >= 10L) {
#line 108
    if (p___0->stage2.offpoints) {
#line 108
      tmp = p___0->stage2.offaccum / p___0->stage2.offpoints;
    } else {
#line 108
      tmp = 0L;
    }
    {
#line 108
    av = tmp;
#line 110
    tmp___3 = abs((int )av);
    }
#line 110
    if ((long )tmp___3 > p___0->dynoverlap / 4L) {
#line 111
      av = (av / 128L) * 128L;
#line 113
      if (callback___0) {
        {
#line 113
        (*callback___0)((p___0->root.vector)->begin + (p___0->root.vector)->size,
                        7);
        }
      }
      {
#line 114
      p___0->dyndrift += av;
#line 119
      tmp___0 = c_first(p___0);
#line 119
      c = tmp___0;
#line 120
      tmp___1 = v_first(p___0);
#line 120
      v = tmp___1;
      }
      {
#line 122
      while (1) {
        while_continue: /* CIL Label */ ;
#line 122
        if (v) {
#line 122
          if (! v->one) {
#line 122
            goto while_break;
          }
        } else {
#line 122
          goto while_break;
        }
#line 124
        if (v->begin < av) {
#line 125
          v->one = (c_block *)((void *)0);
        } else
#line 124
        if ((v->one)->begin < av) {
#line 125
          v->one = (c_block *)((void *)0);
        } else {
#line 127
          v->begin -= av;
        }
        {
#line 129
        v = v_next(v);
        }
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 131
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 131
        if (! c) {
#line 131
          goto while_break___0;
        }
#line 132
        if (av > c->begin) {
#line 132
          tmp___2 = c->begin;
        } else {
#line 132
          tmp___2 = av;
        }
        {
#line 132
        adj = tmp___2;
#line 133
        c_set(c, c->begin - adj);
#line 134
        c = c_next(c);
        }
      }
      while_break___0: /* CIL Label */ ;
      }
#line 138
      p___0->stage2.offaccum = 0L;
#line 139
      p___0->stage2.offmin = 0L;
#line 140
      p___0->stage2.offmax = 0L;
#line 141
      p___0->stage2.offpoints = 0L;
#line 142
      p___0->stage2.newpoints = 0L;
#line 143
      p___0->stage2.offdiff = 0L;
    }
  }
#line 147
  if (p___0->stage1.offpoints >= 10L) {
#line 151
    if (p___0->stage1.offpoints) {
#line 151
      p___0->dynoverlap = (p___0->stage1.offdiff / p___0->stage1.offpoints) * 3L;
    } else {
#line 151
      p___0->dynoverlap = 1176L;
    }
#line 154
    if ((double )p___0->dynoverlap < (double )(- p___0->stage1.offmin) * 1.5) {
#line 155
      p___0->dynoverlap = (long )((double )(- p___0->stage1.offmin) * 1.5);
    }
#line 157
    if ((double )p___0->dynoverlap < (double )p___0->stage1.offmax * 1.5) {
#line 158
      p___0->dynoverlap = (long )((double )p___0->stage1.offmax * 1.5);
    }
#line 160
    if (p___0->dynoverlap < 128L) {
#line 160
      p___0->dynoverlap = 128L;
    }
#line 161
    if (p___0->dynoverlap > 37632L) {
#line 162
      p___0->dynoverlap = 37632L;
    }
#line 164
    if (callback___0) {
      {
#line 164
      (*callback___0)(p___0->dynoverlap, 9);
      }
    }
#line 166
    if (p___0->stage1.offpoints > 600L) {
#line 169
      p___0->stage1.offpoints = (long )((double )p___0->stage1.offpoints / 1.2);
#line 170
      p___0->stage1.offaccum = (long )((double )p___0->stage1.offaccum / 1.2);
#line 171
      p___0->stage1.offdiff = (long )((double )p___0->stage1.offdiff / 1.2);
    }
#line 173
    p___0->stage1.offmin = 0L;
#line 174
    p___0->stage1.offmax = 0L;
#line 175
    p___0->stage1.newpoints = 0L;
  }
#line 177
  return;
}
}
#line 205 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/paranoia/overlap.c"
void offset_add_value(cdrom_paranoia *p___0 , offsets *o , long value , void (*callback___0)(long  ,
                                                                                             int  ) ) 
{ 
  int tmp ;

  {
#line 207
  if (o->offpoints != -1L) {
    {
#line 210
    tmp = abs((int )value);
#line 210
    o->offdiff += (long )tmp;
#line 211
    (o->offpoints) ++;
#line 212
    (o->newpoints) ++;
#line 215
    o->offaccum += value;
    }
#line 218
    if (value < o->offmin) {
#line 218
      o->offmin = value;
    }
#line 219
    if (value > o->offmax) {
#line 219
      o->offmax = value;
    }
#line 222
    if (o->newpoints >= 10L) {
      {
#line 222
      offset_adjust_settings(p___0, callback___0);
      }
    }
  }
#line 224
  return;
}
}
#line 47 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/paranoia/p_block.h"
linked_list *new_list(void *(*newp)(void) , void (*freep)(void * ) ) ;
#line 48
linked_element *new_elem(linked_list *list ) ;
#line 49
linked_element *add_elem(linked_list *l , void *elem ) ;
#line 50
void free_list(linked_list *list , int free_ptr ) ;
#line 51
void free_elem(linked_element *e , int free_ptr ) ;
#line 52
void *get_elem(linked_element *e ) ;
#line 53
linked_list *copy_list(linked_list *list ) ;
#line 82
c_block *new_c_block(struct cdrom_paranoia *p___0 ) ;
#line 101
v_fragment *new_v_fragment(struct cdrom_paranoia *p___0 , c_block *one , long begin ,
                           long end , int last___0 ) ;
#line 103
int16_t *v_buffer(v_fragment *v ) ;
#line 106
c_block *c_last(struct cdrom_paranoia *p___0 ) ;
#line 108
c_block *c_prev(c_block *c ) ;
#line 111
v_fragment *v_last(struct cdrom_paranoia *p___0 ) ;
#line 113
v_fragment *v_prev(v_fragment *v ) ;
#line 167
c_block *c_alloc(int16_t *vector , long begin , long size ) ;
#line 169
void c_insert(c_block *v , long pos , int16_t *b , long size ) ;
#line 170
void c_remove(c_block *v , long cutpos , long cutsize ) ;
#line 171
void c_overwrite(c_block *v , long pos , int16_t *b , long size ) ;
#line 172
void c_append(c_block *v , int16_t *vector , long size ) ;
#line 181
void recover_cache(cdrom_paranoia *p___0 ) ;
#line 182
void i_paranoia_firstlast(cdrom_paranoia *p___0 ) ;
#line 44 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/paranoia/cdda_paranoia.h"
cdrom_paranoia *paranoia_init(cdrom_drive *d___0 ) ;
#line 51
int paranoia_cachemodel_size(cdrom_paranoia *p___0 , int sectors ) ;
#line 9 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/paranoia/p_block.c"
linked_list *new_list(void *(*newp)(void) , void (*freep)(void * ) ) 
{ 
  linked_list *ret ;
  void *tmp ;

  {
  {
#line 10
  tmp = calloc((size_t )1, (size_t )sizeof(linked_list ));
#line 10
  ret = (linked_list *)tmp;
#line 11
  ret->new_poly = newp;
#line 12
  ret->free_poly = freep;
  }
#line 13
  return (ret);
}
}
#line 16 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/paranoia/p_block.c"
linked_element *add_elem(linked_list *l , void *elem ) 
{ 
  linked_element *ret ;
  void *tmp ;
  long tmp___0 ;

  {
  {
#line 18
  tmp = calloc((size_t )1, (size_t )sizeof(linked_element ));
#line 18
  ret = (linked_element *)tmp;
#line 19
  tmp___0 = l->current;
#line 19
  (l->current) ++;
#line 19
  ret->stamp = (int )tmp___0;
#line 20
  ret->ptr = elem;
#line 21
  ret->list = l;
  }
#line 23
  if (l->head) {
#line 24
    (l->head)->prev = ret;
  } else {
#line 26
    l->tail = ret;
  }
#line 27
  ret->next = l->head;
#line 28
  ret->prev = (struct linked_element *)((void *)0);
#line 29
  l->head = ret;
#line 30
  (l->active) ++;
#line 32
  return (ret);
}
}
#line 35 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/paranoia/p_block.c"
linked_element *new_elem(linked_list *list ) 
{ 
  void *new ;
  void *tmp ;
  linked_element *tmp___0 ;

  {
  {
#line 36
  tmp = (*(list->new_poly))();
#line 36
  new = tmp;
#line 37
  tmp___0 = add_elem(list, new);
  }
#line 37
  return (tmp___0);
}
}
#line 40 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/paranoia/p_block.c"
void free_elem(linked_element *e , int free_ptr ) 
{ 
  linked_list *l ;

  {
#line 41
  l = e->list;
#line 42
  if (free_ptr) {
    {
#line 42
    (*(l->free_poly))(e->ptr);
    }
  }
#line 44
  if ((unsigned long )e == (unsigned long )l->head) {
#line 45
    l->head = e->next;
  }
#line 46
  if ((unsigned long )e == (unsigned long )l->tail) {
#line 47
    l->tail = e->prev;
  }
#line 49
  if (e->prev) {
#line 50
    (e->prev)->next = e->next;
  }
#line 51
  if (e->next) {
#line 52
    (e->next)->prev = e->prev;
  }
  {
#line 54
  (l->active) --;
#line 55
  free((void *)e);
  }
#line 56
  return;
}
}
#line 58 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/paranoia/p_block.c"
void free_list(linked_list *list , int free_ptr ) 
{ 


  {
  {
#line 59
  while (1) {
    while_continue: /* CIL Label */ ;
#line 59
    if (! list->head) {
#line 59
      goto while_break;
    }
    {
#line 60
    free_elem(list->head, free_ptr);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 61
  free((void *)list);
  }
#line 62
  return;
}
}
#line 64 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/paranoia/p_block.c"
void *get_elem(linked_element *e ) 
{ 


  {
#line 65
  return (e->ptr);
}
}
#line 68 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/paranoia/p_block.c"
linked_list *copy_list(linked_list *list ) 
{ 
  linked_list *new ;
  linked_list *tmp ;
  linked_element *i ;

  {
  {
#line 69
  tmp = new_list(list->new_poly, list->free_poly);
#line 69
  new = tmp;
#line 70
  i = list->tail;
  }
  {
#line 72
  while (1) {
    while_continue: /* CIL Label */ ;
#line 72
    if (! i) {
#line 72
      goto while_break;
    }
    {
#line 73
    add_elem(new, i->ptr);
#line 74
    i = i->prev;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 76
  return (new);
}
}
#line 81 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/paranoia/p_block.c"
static c_block *i_cblock_constructor(cdrom_paranoia *p___0 ) 
{ 
  c_block *ret ;
  void *tmp ;

  {
  {
#line 82
  tmp = calloc((size_t )1, (size_t )sizeof(c_block ));
#line 82
  ret = (c_block *)tmp;
  }
#line 83
  return (ret);
}
}
#line 86 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/paranoia/p_block.c"
void i_cblock_destructor(c_block *c ) 
{ 


  {
#line 87
  if (c) {
#line 88
    if (c->vector) {
      {
#line 88
      free((void *)c->vector);
      }
    }
#line 89
    if (c->flags) {
      {
#line 89
      free((void *)c->flags);
      }
    }
    {
#line 90
    c->e = (struct linked_element *)((void *)0);
#line 91
    free((void *)c);
    }
  }
#line 93
  return;
}
}
#line 95 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/paranoia/p_block.c"
c_block *new_c_block(struct cdrom_paranoia *p___0 ) 
{ 
  linked_element *e ;
  linked_element *tmp ;
  c_block *c ;

  {
  {
#line 96
  tmp = new_elem(p___0->cache);
#line 96
  e = tmp;
#line 97
  c = (c_block *)e->ptr;
#line 98
  c->e = e;
#line 99
  c->p = p___0;
  }
#line 100
  return (c);
}
}
#line 103 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/paranoia/p_block.c"
void free_c_block(c_block *c ) 
{ 
  v_fragment *v ;
  v_fragment *tmp ;
  v_fragment *next ;
  v_fragment *tmp___0 ;

  {
  {
#line 105
  tmp = v_first(c->p);
#line 105
  v = tmp;
  }
  {
#line 107
  while (1) {
    while_continue: /* CIL Label */ ;
#line 107
    if (! v) {
#line 107
      goto while_break;
    }
    {
#line 108
    tmp___0 = v_next(v);
#line 108
    next = tmp___0;
    }
#line 109
    if ((unsigned long )v->one == (unsigned long )c) {
      {
#line 109
      free_v_fragment(v);
      }
    }
#line 110
    v = next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 113
  free_elem(c->e, 1);
  }
#line 114
  return;
}
}
#line 116 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/paranoia/p_block.c"
static v_fragment *i_vfragment_constructor(void) 
{ 
  v_fragment *ret ;
  void *tmp ;

  {
  {
#line 117
  tmp = calloc((size_t )1, (size_t )sizeof(v_fragment ));
#line 117
  ret = (v_fragment *)tmp;
  }
#line 118
  return (ret);
}
}
#line 121 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/paranoia/p_block.c"
static void i_v_fragment_destructor(v_fragment *v ) 
{ 


  {
  {
#line 122
  free((void *)v);
  }
#line 123
  return;
}
}
#line 125 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/paranoia/p_block.c"
v_fragment *new_v_fragment(struct cdrom_paranoia *p___0 , c_block *one , long begin ,
                           long end , int last___0 ) 
{ 
  linked_element *e ;
  linked_element *tmp ;
  v_fragment *b ;

  {
  {
#line 127
  tmp = new_elem(p___0->fragments);
#line 127
  e = tmp;
#line 128
  b = (v_fragment *)e->ptr;
#line 130
  b->e = e;
#line 131
  b->p = p___0;
#line 133
  b->one = one;
#line 134
  b->begin = begin;
#line 135
  b->vector = (one->vector + begin) - one->begin;
#line 136
  b->size = end - begin;
#line 137
  b->lastsector = (long )last___0;
  }
#line 139
  return (b);
}
}
#line 142 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/paranoia/p_block.c"
void free_v_fragment(v_fragment *v ) 
{ 


  {
  {
#line 143
  free_elem(v->e, 1);
  }
#line 144
  return;
}
}
#line 146 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/paranoia/p_block.c"
c_block *c_first(struct cdrom_paranoia *p___0 ) 
{ 


  {
#line 147
  if ((p___0->cache)->head) {
#line 148
    return ((c_block *)((p___0->cache)->head)->ptr);
  }
#line 149
  return ((c_block *)((void *)0));
}
}
#line 152 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/paranoia/p_block.c"
c_block *c_last(struct cdrom_paranoia *p___0 ) 
{ 


  {
#line 153
  if ((p___0->cache)->tail) {
#line 154
    return ((c_block *)((p___0->cache)->tail)->ptr);
  }
#line 155
  return ((c_block *)((void *)0));
}
}
#line 158 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/paranoia/p_block.c"
c_block *c_next(c_block *c ) 
{ 


  {
#line 159
  if ((c->e)->next) {
#line 160
    return ((c_block *)((c->e)->next)->ptr);
  }
#line 161
  return ((c_block *)((void *)0));
}
}
#line 164 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/paranoia/p_block.c"
c_block *c_prev(c_block *c ) 
{ 


  {
#line 165
  if ((c->e)->prev) {
#line 166
    return ((c_block *)((c->e)->prev)->ptr);
  }
#line 167
  return ((c_block *)((void *)0));
}
}
#line 170 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/paranoia/p_block.c"
v_fragment *v_first(struct cdrom_paranoia *p___0 ) 
{ 


  {
#line 171
  if ((p___0->fragments)->head) {
#line 172
    return ((v_fragment *)((p___0->fragments)->head)->ptr);
  }
#line 174
  return ((v_fragment *)((void *)0));
}
}
#line 177 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/paranoia/p_block.c"
v_fragment *v_last(struct cdrom_paranoia *p___0 ) 
{ 


  {
#line 178
  if ((p___0->fragments)->tail) {
#line 179
    return ((v_fragment *)((p___0->fragments)->tail)->ptr);
  }
#line 180
  return ((v_fragment *)((void *)0));
}
}
#line 183 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/paranoia/p_block.c"
v_fragment *v_next(v_fragment *v ) 
{ 


  {
#line 184
  if ((v->e)->next) {
#line 185
    return ((v_fragment *)((v->e)->next)->ptr);
  }
#line 186
  return ((v_fragment *)((void *)0));
}
}
#line 189 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/paranoia/p_block.c"
v_fragment *v_prev(v_fragment *v ) 
{ 


  {
#line 190
  if ((v->e)->prev) {
#line 191
    return ((v_fragment *)((v->e)->prev)->ptr);
  }
#line 192
  return ((v_fragment *)((void *)0));
}
}
#line 195 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/paranoia/p_block.c"
void recover_cache(cdrom_paranoia *p___0 ) 
{ 
  linked_list *l ;
  c_block *tmp ;

  {
#line 196
  l = p___0->cache;
  {
#line 199
  while (1) {
    while_continue: /* CIL Label */ ;
#line 199
    if (! (l->active > p___0->cache_limit)) {
#line 199
      goto while_break;
    }
    {
#line 201
    tmp = c_last(p___0);
#line 201
    free_c_block(tmp);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 203
  return;
}
}
#line 205 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/paranoia/p_block.c"
int16_t *v_buffer(v_fragment *v ) 
{ 


  {
#line 206
  if (! v->one) {
#line 206
    return ((int16_t *)((void *)0));
  }
#line 207
  if (! (v->one)->vector) {
#line 207
    return ((int16_t *)((void *)0));
  }
#line 208
  return (v->vector);
}
}
#line 212 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/paranoia/p_block.c"
c_block *c_alloc(int16_t *vector , long begin , long size ) 
{ 
  c_block *c ;
  void *tmp ;

  {
  {
#line 213
  tmp = calloc((size_t )1, (size_t )sizeof(c_block ));
#line 213
  c = (c_block *)tmp;
#line 214
  c->vector = vector;
#line 215
  c->begin = begin;
#line 216
  c->size = size;
  }
#line 217
  return (c);
}
}
#line 220 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/paranoia/p_block.c"
void c_set(c_block *v , long begin ) 
{ 


  {
#line 221
  v->begin = begin;
#line 222
  return;
}
}
#line 225 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/paranoia/p_block.c"
void c_insert(c_block *v , long pos , int16_t *b , long size ) 
{ 
  int vs ;
  void *tmp ;
  void *tmp___0 ;

  {
#line 226
  vs = (int )v->size;
#line 227
  if (pos < 0L) {
#line 227
    return;
  } else
#line 227
  if (pos > (long )vs) {
#line 227
    return;
  }
#line 229
  if (v->vector) {
    {
#line 230
    tmp = realloc((void *)v->vector, (size_t )(sizeof(int16_t ) * (unsigned long )(size + (long )vs)));
#line 230
    v->vector = (int16_t *)tmp;
    }
  } else {
    {
#line 232
    tmp___0 = malloc((size_t )(sizeof(int16_t ) * (unsigned long )size));
#line 232
    v->vector = (int16_t *)tmp___0;
    }
  }
#line 234
  if (pos < (long )vs) {
    {
#line 234
    memmove((void *)((v->vector + pos) + size), (void const   *)(v->vector + pos),
            (size_t )((unsigned long )((long )vs - pos) * sizeof(int16_t )));
    }
  }
  {
#line 236
  memcpy((void */* __restrict  */)(v->vector + pos), (void const   */* __restrict  */)b,
         (size_t )((unsigned long )size * sizeof(int16_t )));
#line 238
  v->size += size;
  }
#line 239
  return;
}
}
#line 241 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/paranoia/p_block.c"
void c_remove(c_block *v , long cutpos , long cutsize ) 
{ 
  int vs ;

  {
#line 242
  vs = (int )v->size;
#line 243
  if (cutpos < 0L) {
#line 243
    return;
  } else
#line 243
  if (cutpos > (long )vs) {
#line 243
    return;
  }
#line 244
  if (cutpos + cutsize > (long )vs) {
#line 244
    cutsize = (long )vs - cutpos;
  }
#line 245
  if (cutsize < 0L) {
#line 245
    cutsize = (long )vs - cutpos;
  }
#line 246
  if (cutsize < 1L) {
#line 246
    return;
  }
  {
#line 248
  memmove((void *)(v->vector + cutpos), (void const   *)((v->vector + cutpos) + cutsize),
          (size_t )((unsigned long )(((long )vs - cutpos) - cutsize) * sizeof(int16_t )));
#line 251
  v->size -= cutsize;
  }
#line 252
  return;
}
}
#line 254 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/paranoia/p_block.c"
void c_overwrite(c_block *v , long pos , int16_t *b , long size ) 
{ 
  int vs ;

  {
#line 255
  vs = (int )v->size;
#line 257
  if (pos < 0L) {
#line 257
    return;
  }
#line 258
  if (pos + size > (long )vs) {
#line 258
    size = (long )vs - pos;
  }
  {
#line 260
  memcpy((void */* __restrict  */)(v->vector + pos), (void const   */* __restrict  */)b,
         (size_t )((unsigned long )size * sizeof(int16_t )));
  }
#line 261
  return;
}
}
#line 263 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/paranoia/p_block.c"
void c_append(c_block *v , int16_t *vector , long size ) 
{ 
  int vs ;
  void *tmp ;
  void *tmp___0 ;

  {
#line 264
  vs = (int )v->size;
#line 267
  if (v->vector) {
    {
#line 268
    tmp = realloc((void *)v->vector, (size_t )(sizeof(int16_t ) * (unsigned long )(size + (long )vs)));
#line 268
    v->vector = (int16_t *)tmp;
    }
  } else {
    {
#line 270
    tmp___0 = malloc((size_t )(sizeof(int16_t ) * (unsigned long )size));
#line 270
    v->vector = (int16_t *)tmp___0;
    }
  }
  {
#line 271
  memcpy((void */* __restrict  */)(v->vector + vs), (void const   */* __restrict  */)vector,
         (size_t )(sizeof(int16_t ) * (unsigned long )size));
#line 273
  v->size += size;
  }
#line 274
  return;
}
}
#line 276 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/paranoia/p_block.c"
void c_removef(c_block *v , long cut ) 
{ 


  {
  {
#line 277
  c_remove(v, 0L, cut);
#line 278
  v->begin += cut;
  }
#line 279
  return;
}
}
#line 294 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/paranoia/p_block.c"
void i_paranoia_firstlast(cdrom_paranoia *p___0 ) 
{ 
  int i ;
  cdrom_drive *d___0 ;
  int tmp ;
  long tmp___0 ;
  int tmp___1 ;

  {
  {
#line 296
  d___0 = p___0->d;
#line 297
  p___0->current_lastsector = -1L;
#line 298
  i = cdda_sector_gettrack(d___0, p___0->cursor);
  }
  {
#line 298
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 298
    tmp___0 = cdda_tracks(d___0);
    }
#line 298
    if (! ((long )i < tmp___0)) {
#line 298
      goto while_break;
    }
    {
#line 299
    tmp = cdda_track_audiop(d___0, i);
    }
#line 299
    if (! tmp) {
      {
#line 300
      p___0->current_lastsector = cdda_track_lastsector(d___0, i - 1);
      }
    }
#line 298
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 301
  if (p___0->current_lastsector == -1L) {
    {
#line 302
    p___0->current_lastsector = cdda_disc_lastsector(d___0);
    }
  }
  {
#line 304
  p___0->current_firstsector = -1L;
#line 305
  i = cdda_sector_gettrack(d___0, p___0->cursor);
  }
  {
#line 305
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 305
    if (! (i > 0)) {
#line 305
      goto while_break___0;
    }
    {
#line 306
    tmp___1 = cdda_track_audiop(d___0, i);
    }
#line 306
    if (! tmp___1) {
      {
#line 307
      p___0->current_firstsector = cdda_track_firstsector(d___0, i + 1);
      }
    }
#line 305
    i --;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 308
  if (p___0->current_firstsector == -1L) {
    {
#line 309
    p___0->current_firstsector = cdda_disc_firstsector(d___0);
    }
  }
#line 311
  return;
}
}
#line 313 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/paranoia/p_block.c"
cdrom_paranoia *paranoia_init(cdrom_drive *d___0 ) 
{ 
  cdrom_paranoia *p___0 ;
  void *tmp ;

  {
  {
#line 314
  tmp = calloc((size_t )1, (size_t )sizeof(cdrom_paranoia ));
#line 314
  p___0 = (cdrom_paranoia *)tmp;
#line 316
  p___0->cache = new_list((void *(*)(void))((void *)(& i_cblock_constructor)), (void (*)(void * ))((void *)(& i_cblock_destructor)));
#line 319
  p___0->fragments = new_list((void *(*)(void))((void *)(& i_vfragment_constructor)),
                              (void (*)(void * ))((void *)(& i_v_fragment_destructor)));
#line 322
  p___0->cdcache_begin = 9999999;
#line 323
  p___0->cdcache_end = 9999999;
#line 324
  p___0->cdcache_size = 1200;
#line 325
  p___0->sortcache = sort_alloc((long )(p___0->cdcache_size * 1176));
#line 326
  p___0->d = d___0;
#line 327
  p___0->dynoverlap = 37632L;
#line 328
  p___0->cache_limit = 15L;
#line 329
  p___0->enable = 255;
#line 330
  p___0->cursor = cdda_disc_firstsector(d___0);
#line 333
  i_paranoia_firstlast(p___0);
  }
#line 335
  return (p___0);
}
}
#line 339 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/paranoia/p_block.c"
int paranoia_cachemodel_size(cdrom_paranoia *p___0 , int sectors ) 
{ 
  int ret ;

  {
#line 340
  ret = p___0->cdcache_size;
#line 341
  if (sectors >= 0) {
#line 342
    p___0->cdcache_size = sectors;
  }
#line 343
  return (ret);
}
}
/* compiler builtin: 
   void *__builtin_alloca(unsigned long  ) ;  */
#line 756 "/usr/include/stdlib.h"
extern void ( __attribute__((__nonnull__(1,4))) qsort)(void *__base , size_t __nmemb ,
                                                       size_t __size , int (*__compar)(void const   * ,
                                                                                       void const   * ) ) ;
#line 43 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/paranoia/cdda_paranoia.h"
char *paranoia_version(void) ;
#line 45
void paranoia_modeset(cdrom_paranoia *p___0 , int enable ) ;
#line 46
long paranoia_seek(cdrom_paranoia *p___0 , long seek , int mode ) ;
#line 47
int16_t *paranoia_read(cdrom_paranoia *p___0 , void (*callback___0)(long  , int  ) ) ;
#line 48
int16_t *paranoia_read_limited(cdrom_paranoia *p___0 , void (*callback___0)(long  ,
                                                                            int  ) ,
                               int max_retries ) ;
#line 49
void paranoia_free(cdrom_paranoia *p___0 ) ;
#line 50
void paranoia_overlapset(cdrom_paranoia *p___0 , long overlap___0 ) ;
#line 89 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/paranoia/paranoia.c"
__inline static long re(root_block *root ) 
{ 


  {
#line 90
  if (! root) {
#line 90
    return (-1L);
  }
#line 91
  if (! root->vector) {
#line 91
    return (-1L);
  }
#line 92
  return ((root->vector)->begin + (root->vector)->size);
}
}
#line 95 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/paranoia/paranoia.c"
__inline static long rb(root_block *root ) 
{ 


  {
#line 96
  if (! root) {
#line 96
    return (-1L);
  }
#line 97
  if (! root->vector) {
#line 97
    return (-1L);
  }
#line 98
  return ((root->vector)->begin);
}
}
#line 101 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/paranoia/paranoia.c"
__inline static long rs(root_block *root ) 
{ 


  {
#line 102
  if (! root) {
#line 102
    return (-1L);
  }
#line 103
  if (! root->vector) {
#line 103
    return (-1L);
  }
#line 104
  return ((root->vector)->size);
}
}
#line 107 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/paranoia/paranoia.c"
__inline static int16_t *rv(root_block *root ) 
{ 


  {
#line 108
  if (! root) {
#line 108
    return ((int16_t *)((void *)0));
  }
#line 109
  if (! root->vector) {
#line 109
    return ((int16_t *)((void *)0));
  }
#line 110
  return ((root->vector)->vector);
}
}
#line 126 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/paranoia/paranoia.c"
enum __anonenum_paranoia_read_flags_48 paranoia_read_flags  ;
#line 148 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/paranoia/paranoia.c"
__inline static long i_paranoia_overlap(int16_t *buffA , int16_t *buffB , long offsetA ,
                                        long offsetB , long sizeA , long sizeB , long *ret_begin ,
                                        long *ret_end ) 
{ 
  long beginA ;
  long endA ;
  long beginB ;
  long endB ;

  {
#line 152
  beginA = offsetA;
#line 152
  endA = offsetA;
#line 153
  beginB = offsetB;
#line 153
  endB = offsetB;
  {
#line 156
  while (1) {
    while_continue: /* CIL Label */ ;
#line 156
    if (beginA >= 0L) {
#line 156
      if (! (beginB >= 0L)) {
#line 156
        goto while_break;
      }
    } else {
#line 156
      goto while_break;
    }
#line 157
    if ((int )*(buffA + beginA) != (int )*(buffB + beginB)) {
#line 157
      goto while_break;
    }
#line 156
    beginA --;
#line 156
    beginB --;
  }
  while_break: /* CIL Label */ ;
  }
#line 158
  beginA ++;
#line 159
  beginB ++;
  {
#line 162
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 162
    if (endA < sizeA) {
#line 162
      if (! (endB < sizeB)) {
#line 162
        goto while_break___0;
      }
    } else {
#line 162
      goto while_break___0;
    }
#line 163
    if ((int )*(buffA + endA) != (int )*(buffB + endB)) {
#line 163
      goto while_break___0;
    }
#line 162
    endA ++;
#line 162
    endB ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 166
  if (ret_begin) {
#line 166
    *ret_begin = beginA;
  }
#line 167
  if (ret_end) {
#line 167
    *ret_end = endA;
  }
#line 168
  return (endA - beginA);
}
}
#line 188 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/paranoia/paranoia.c"
__inline static long i_paranoia_overlap2(int16_t *buffA , int16_t *buffB , unsigned char *flagsA ,
                                         unsigned char *flagsB , long offsetA , long offsetB ,
                                         long sizeA , long sizeB , long *ret_begin ,
                                         long *ret_end ) 
{ 
  long beginA ;
  long endA ;
  long beginB ;
  long endB ;

  {
#line 194
  beginA = offsetA;
#line 194
  endA = offsetA;
#line 195
  beginB = offsetB;
#line 195
  endB = offsetB;
  {
#line 198
  while (1) {
    while_continue: /* CIL Label */ ;
#line 198
    if (beginA >= 0L) {
#line 198
      if (! (beginB >= 0L)) {
#line 198
        goto while_break;
      }
    } else {
#line 198
      goto while_break;
    }
#line 199
    if ((int )*(buffA + beginA) != (int )*(buffB + beginB)) {
#line 199
      goto while_break;
    }
#line 208
    if (((int )*(flagsA + beginA) & (int )*(flagsB + beginB)) & 1) {
#line 209
      beginA --;
#line 210
      beginB --;
#line 211
      goto while_break;
    }
#line 215
    if ((int )*(flagsA + beginA) & 2) {
#line 215
      goto while_break;
    } else
#line 215
    if ((int )*(flagsB + beginB) & 2) {
#line 215
      goto while_break;
    }
#line 198
    beginA --;
#line 198
    beginB --;
  }
  while_break: /* CIL Label */ ;
  }
#line 217
  beginA ++;
#line 218
  beginB ++;
  {
#line 221
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 221
    if (endA < sizeA) {
#line 221
      if (! (endB < sizeB)) {
#line 221
        goto while_break___0;
      }
    } else {
#line 221
      goto while_break___0;
    }
#line 222
    if ((int )*(buffA + endA) != (int )*(buffB + endB)) {
#line 222
      goto while_break___0;
    }
#line 227
    if (((int )*(flagsA + endA) & (int )*(flagsB + endB)) & 1) {
#line 227
      if (endA != beginA) {
#line 228
        goto while_break___0;
      }
    }
#line 232
    if ((int )*(flagsA + endA) & 2) {
#line 232
      goto while_break___0;
    } else
#line 232
    if ((int )*(flagsB + endB) & 2) {
#line 232
      goto while_break___0;
    }
#line 221
    endA ++;
#line 221
    endB ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 236
  if (ret_begin) {
#line 236
    *ret_begin = beginA;
  }
#line 237
  if (ret_end) {
#line 237
    *ret_end = endA;
  }
#line 238
  return (endA - beginA);
}
}
#line 258 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/paranoia/paranoia.c"
__inline static long do_const_sync(c_block *A , sort_info *B , unsigned char *flagB ,
                                   long posA , long posB , long *begin , long *end ,
                                   long *offset ) 
{ 
  unsigned char *flagA ;
  long ret ;

  {
#line 263
  flagA = A->flags;
#line 264
  ret = 0L;
#line 271
  if ((unsigned long )flagB == (unsigned long )((void *)0)) {
    {
#line 272
    ret = i_paranoia_overlap(A->vector, B->vector, posA, posB, A->size, B->size, begin,
                             end);
    }
  } else
#line 275
  if (((int )*(flagB + posB) & 2) == 0) {
    {
#line 276
    ret = i_paranoia_overlap2(A->vector, B->vector, flagA, flagB, posA, posB, A->size,
                              B->size, begin, end);
    }
  }
#line 282
  if (ret > 64L) {
#line 283
    *offset = (posA + A->begin) - (posB + *(B->abspos));
#line 289
    *begin += A->begin;
#line 290
    *end += A->begin;
#line 291
    return (ret);
  }
#line 294
  return (0L);
}
}
#line 325 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/paranoia/paranoia.c"
__inline static long try_sort_sync(cdrom_paranoia *p___0 , sort_info *A , unsigned char *Aflags ,
                                   c_block *B , long post , long *begin , long *end ,
                                   long *offset , void (*callback___0)(long  , int  ) ) 
{ 
  long dynoverlap ;
  sort_link *ptr ;
  unsigned char *Bflags ;
  long zeropos ;
  long tmp ;
  long tmp___0 ;

  {
#line 331
  dynoverlap = p___0->dynoverlap;
#line 332
  ptr = (sort_link *)((void *)0);
#line 333
  Bflags = B->flags;
#line 336
  if ((unsigned long )Bflags == (unsigned long )((void *)0)) {
#line 336
    goto _L;
  } else
#line 336
  if (((int )*(Bflags + (post - B->begin)) & 2) == 0) {
    _L: /* CIL Label */ 
#line 339
    zeropos = post - *(A->abspos);
#line 340
    if (zeropos >= 0L) {
#line 340
      if (zeropos < A->size) {
#line 348
        if ((int )*(B->vector + (post - B->begin)) == (int )*(A->vector + zeropos)) {
          {
#line 354
          tmp = do_const_sync(B, A, Aflags, post - B->begin, zeropos, begin, end,
                              offset);
          }
#line 354
          if (tmp) {
            {
#line 358
            offset_add_value(p___0, & p___0->stage1, *offset, callback___0);
            }
#line 360
            return (1L);
          }
        }
      }
    }
  } else {
#line 366
    return (0L);
  }
  {
#line 374
  ptr = sort_getmatch(A, post - *(A->abspos), dynoverlap, (int )*(B->vector + (post - B->begin)));
  }
  {
#line 376
  while (1) {
    while_continue: /* CIL Label */ ;
#line 376
    if (! ptr) {
#line 376
      goto while_break;
    }
    {
#line 382
    tmp___0 = do_const_sync(B, A, Aflags, post - B->begin, ptr - A->revindex, begin,
                            end, offset);
    }
#line 382
    if (tmp___0) {
      {
#line 386
      offset_add_value(p___0, & p___0->stage1, *offset, callback___0);
      }
#line 387
      return (1L);
    }
    {
#line 394
    ptr = sort_nextmatch(A, ptr);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 398
  *begin = -1L;
#line 399
  *end = -1L;
#line 400
  *offset = -1L;
#line 401
  return (0L);
}
}
#line 439 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/paranoia/paranoia.c"
__inline static void stage1_matched(c_block *old , c_block *new , long matchbegin ,
                                    long matchend , long matchoffset , void (*callback___0)(long  ,
                                                                                            int  ) ) 
{ 
  long i ;
  long oldadjbegin ;
  long oldadjend ;
  long newadjbegin ;
  long newadjend ;

  {
#line 443
  oldadjbegin = matchbegin - old->begin;
#line 444
  oldadjend = matchend - old->begin;
#line 445
  newadjbegin = (matchbegin - matchoffset) - new->begin;
#line 446
  newadjend = (matchend - matchoffset) - new->begin;
#line 461
  if (matchbegin - matchoffset <= new->begin) {
#line 461
    goto _L;
  } else
#line 461
  if (matchbegin <= old->begin) {
#line 461
    goto _L;
  } else
#line 461
  if ((int )*(new->flags + newadjbegin) & 1) {
#line 461
    goto _L;
  } else
#line 461
  if ((int )*(old->flags + oldadjbegin) & 1) {
    _L: /* CIL Label */ 
#line 465
    if (matchoffset) {
#line 466
      if (callback___0) {
        {
#line 466
        (*callback___0)(matchbegin, 2);
        }
      }
    }
  } else
#line 468
  if (callback___0) {
    {
#line 468
    (*callback___0)(matchbegin, 3);
    }
  }
#line 470
  if (matchend - matchoffset >= new->begin + new->size) {
#line 470
    goto _L___0;
  } else
#line 470
  if ((int )*(new->flags + newadjend) & 1) {
#line 470
    goto _L___0;
  } else
#line 470
  if (matchend >= old->begin + old->size) {
#line 470
    goto _L___0;
  } else
#line 470
  if ((int )*(old->flags + oldadjend) & 1) {
    _L___0: /* CIL Label */ 
#line 474
    if (matchoffset) {
#line 475
      if (callback___0) {
        {
#line 475
        (*callback___0)(matchend, 2);
        }
      }
    }
  } else
#line 477
  if (callback___0) {
    {
#line 477
    (*callback___0)(matchend, 3);
    }
  }
#line 530
  newadjbegin += 31L;
#line 531
  newadjend -= 31L;
#line 532
  i = newadjbegin;
  {
#line 532
  while (1) {
    while_continue: /* CIL Label */ ;
#line 532
    if (! (i < newadjend)) {
#line 532
      goto while_break;
    }
#line 533
    *(new->flags + i) = (unsigned char )((int )*(new->flags + i) | 4);
#line 532
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 535
  oldadjbegin += 31L;
#line 536
  oldadjend -= 31L;
#line 537
  i = oldadjbegin;
  {
#line 537
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 537
    if (! (i < oldadjend)) {
#line 537
      goto while_break___0;
    }
#line 538
    *(old->flags + i) = (unsigned char )((int )*(old->flags + i) | 4);
#line 537
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 540
  return;
}
}
#line 566 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/paranoia/paranoia.c"
static long i_iterate_stage1(cdrom_paranoia *p___0 , c_block *old , c_block *new ,
                             void (*callback___0)(long  , int  ) ) 
{ 
  long matchbegin ;
  long matchend ;
  long matchoffset ;
  long searchend ;
  long tmp ;
  long searchbegin ;
  long tmp___0 ;
  long searchsize ;
  sort_info *i ;
  long ret ;
  long j ;
  long tried ;
  long matched ;
  long j___0 ;
  long end ;
  long tmp___1 ;

  {
#line 569
  matchbegin = -1L;
#line 569
  matchend = -1L;
#line 584
  if (old->begin + old->size > new->begin + new->size) {
#line 584
    tmp = new->begin + new->size;
  } else {
#line 584
    tmp = old->begin + old->size;
  }
#line 584
  searchend = tmp;
#line 585
  if (old->begin < new->begin) {
#line 585
    tmp___0 = new->begin;
  } else {
#line 585
    tmp___0 = old->begin;
  }
#line 585
  searchbegin = tmp___0;
#line 586
  searchsize = searchend - searchbegin;
#line 587
  i = p___0->sortcache;
#line 588
  ret = 0L;
#line 591
  tried = 0L;
#line 591
  matched = 0L;
#line 593
  if (searchsize <= 0L) {
#line 593
    return (0L);
  }
#line 598
  j = searchbegin;
  {
#line 598
  while (1) {
    while_continue: /* CIL Label */ ;
#line 598
    if (! (j < searchend)) {
#line 598
      goto while_break;
    }
#line 604
    if (((int )*(new->flags + (j - new->begin)) & 6) == 0) {
      {
#line 605
      tried ++;
#line 616
      tmp___1 = try_sort_sync(p___0, i, new->flags, old, j, & matchbegin, & matchend,
                              & matchoffset, callback___0);
      }
#line 616
      if (tmp___1 == 1L) {
#line 619
        matched += matchend - matchbegin;
#line 624
        j___0 = matchbegin - old->begin;
#line 625
        end = matchend - old->begin;
        {
#line 626
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 626
          if (! (j___0 < end)) {
#line 626
            goto while_break___0;
          }
#line 626
          if ((int )*(old->vector + j___0) != 0) {
#line 626
            goto while_break___0;
          }
#line 626
          j___0 ++;
        }
        while_break___0: /* CIL Label */ ;
        }
#line 632
        if (j___0 < end) {
          {
#line 633
          stage1_matched(old, new, matchbegin, matchend, matchoffset, callback___0);
          }
        } else {
          {
#line 635
          stage1_matched(old, new, matchbegin, matchend, matchoffset, (void (*)(long  ,
                                                                                int  ))((void *)0));
          }
        }
#line 638
        ret ++;
#line 641
        if (matchend - 1L > j) {
#line 641
          j = matchend - 1L;
        }
      }
    }
#line 598
    j += 23L;
  }
  while_break: /* CIL Label */ ;
  }
#line 651
  return (ret);
}
}
#line 684 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/paranoia/paranoia.c"
static long i_stage1(cdrom_paranoia *p___0 , c_block *new , void (*callback___0)(long  ,
                                                                                 int  ) ) 
{ 
  long size ;
  c_block *ptr ;
  c_block *tmp ;
  int ret ;
  long begin ;
  long end ;
  int tmp___0 ;
  long tmp___1 ;
  long tmp___2 ;

  {
  {
#line 687
  size = new->size;
#line 688
  tmp = c_last(p___0);
#line 688
  ptr = tmp;
#line 689
  ret = 0;
#line 690
  begin = 0L;
  }
#line 697
  if (ptr) {
    {
#line 697
    sort_setup(p___0->sortcache, new->vector, & new->begin, new->size, new->begin,
               new->begin + new->size);
    }
  }
  {
#line 708
  while (1) {
    while_continue: /* CIL Label */ ;
#line 708
    if (ptr) {
#line 708
      if (! ((unsigned long )ptr != (unsigned long )new)) {
#line 708
        goto while_break;
      }
    } else {
#line 708
      goto while_break;
    }
#line 710
    if (callback___0) {
      {
#line 710
      (*callback___0)(new->begin, 1);
      }
    }
    {
#line 711
    i_iterate_stage1(p___0, ptr, new, callback___0);
#line 713
    ptr = c_prev(ptr);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 721
  begin = 0L;
  {
#line 722
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 722
    if (! (begin < size)) {
#line 722
      goto while_break___0;
    }
    {
#line 723
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 723
      if (! (begin < size)) {
#line 723
        goto while_break___1;
      }
#line 723
      if ((int )*(new->flags + begin) & 4) {
#line 723
        goto while_break___1;
      }
#line 723
      begin ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 724
    end = begin;
    {
#line 724
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 724
      if (! (end < size)) {
#line 724
        goto while_break___2;
      }
#line 724
      if (((int )*(new->flags + end) & 4) == 0) {
#line 724
        goto while_break___2;
      }
#line 724
      end ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 725
    if (begin >= size) {
#line 725
      goto while_break___0;
    }
#line 727
    ret ++;
#line 738
    if (end + 31L >= size) {
#line 738
      if (new->lastsector) {
#line 738
        tmp___0 = 1;
      } else {
#line 738
        tmp___0 = 0;
      }
    } else {
#line 738
      tmp___0 = 0;
    }
#line 738
    if (size > end + 31L) {
#line 738
      tmp___1 = end + 31L;
    } else {
#line 738
      tmp___1 = size;
    }
#line 738
    if (0L < begin - 31L) {
#line 738
      tmp___2 = begin - 31L;
    } else {
#line 738
      tmp___2 = 0L;
    }
    {
#line 738
    new_v_fragment(p___0, new, new->begin + tmp___2, new->begin + tmp___1, tmp___0);
#line 742
    begin = end;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 748
  return ((long )ret);
}
}
#line 795 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/paranoia/paranoia.c"
static long i_iterate_stage2(cdrom_paranoia *p___0 , v_fragment *v , sync_result *r ,
                             void (*callback___0)(long  , int  ) ) 
{ 
  root_block *root ;
  long matchbegin ;
  long matchend ;
  long offset ;
  long fbv ;
  long fev ;
  long tmp___0 ;
  long tmp___1 ;
  long tmp___2 ;
  long tmp___4 ;
  long tmp___5 ;
  long tmp___6 ;
  long tmp___8 ;
  long tmp___9 ;
  int16_t *tmp___10 ;
  long tmp___16 ;
  long tmp___17 ;
  long tmp___18 ;
  long tmp___20 ;
  long tmp___21 ;
  long tmp___22 ;
  long searchend ;
  long tmp___24 ;
  long tmp___25 ;
  long tmp___26 ;
  long searchbegin ;
  long tmp___28 ;
  long tmp___29 ;
  long tmp___30 ;
  sort_info *i ;
  long j ;
  int16_t *tmp___31 ;
  int16_t *tmp___32 ;
  long tmp___33 ;
  long tmp___34 ;

  {
  {
#line 797
  root = & p___0->root;
#line 798
  matchbegin = -1L;
#line 798
  matchend = -1L;
#line 814
  tmp___2 = re(root);
  }
#line 814
  if ((v->begin + v->size) + p___0->dynoverlap > tmp___2) {
    {
#line 814
    tmp___0 = re(root);
#line 814
    tmp___1 = tmp___0;
    }
  } else {
#line 814
    tmp___1 = (v->begin + v->size) + p___0->dynoverlap;
  }
  {
#line 814
  tmp___6 = rb(root);
  }
#line 814
  if (v->begin - p___0->dynoverlap < tmp___6) {
    {
#line 814
    tmp___4 = rb(root);
#line 814
    tmp___5 = tmp___4;
    }
  } else {
#line 814
    tmp___5 = v->begin - p___0->dynoverlap;
  }
#line 814
  if (tmp___1 - tmp___5 <= 0L) {
#line 815
    return (0L);
  }
#line 817
  if (callback___0) {
    {
#line 817
    (*callback___0)(v->begin, 1);
    }
  }
  {
#line 825
  tmp___9 = rb(root);
  }
#line 825
  if (v->begin < tmp___9 - p___0->dynoverlap) {
    {
#line 825
    tmp___8 = rb(root);
#line 825
    fbv = tmp___8 - p___0->dynoverlap;
    }
  } else {
#line 825
    fbv = v->begin;
  }
  {
#line 830
  while (1) {
    while_continue: /* CIL Label */ ;
#line 830
    if (fbv < v->begin + v->size) {
      {
#line 830
      tmp___10 = v_buffer(v);
      }
#line 830
      if (! ((int )*(tmp___10 + (fbv - v->begin)) == 0)) {
#line 830
        goto while_break;
      }
    } else {
#line 830
      goto while_break;
    }
#line 830
    fbv ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 831
  if (fbv == v->begin + v->size) {
#line 831
    return (0L);
  }
  {
#line 846
  tmp___22 = re(root);
  }
#line 846
  if (fbv + 256L > tmp___22 + p___0->dynoverlap) {
    {
#line 846
    tmp___20 = re(root);
#line 846
    tmp___21 = tmp___20 + p___0->dynoverlap;
    }
  } else {
#line 846
    tmp___21 = fbv + 256L;
  }
#line 846
  if (tmp___21 > v->begin + v->size) {
#line 846
    fev = v->begin + v->size;
  } else {
    {
#line 846
    tmp___18 = re(root);
    }
#line 846
    if (fbv + 256L > tmp___18 + p___0->dynoverlap) {
      {
#line 846
      tmp___16 = re(root);
#line 846
      tmp___17 = tmp___16 + p___0->dynoverlap;
      }
    } else {
#line 846
      tmp___17 = fbv + 256L;
    }
#line 846
    fev = tmp___17;
  }
  {
#line 855
  tmp___26 = re(root);
  }
#line 855
  if (fev + p___0->dynoverlap > tmp___26) {
    {
#line 855
    tmp___24 = re(root);
#line 855
    tmp___25 = tmp___24;
    }
  } else {
#line 855
    tmp___25 = fev + p___0->dynoverlap;
  }
  {
#line 855
  searchend = tmp___25;
#line 856
  tmp___30 = rb(root);
  }
#line 856
  if (fbv - p___0->dynoverlap < tmp___30) {
    {
#line 856
    tmp___28 = rb(root);
#line 856
    tmp___29 = tmp___28;
    }
  } else {
#line 856
    tmp___29 = fbv - p___0->dynoverlap;
  }
  {
#line 856
  searchbegin = tmp___29;
#line 857
  i = p___0->sortcache;
#line 864
  tmp___31 = v_buffer(v);
#line 864
  sort_setup(i, tmp___31, & v->begin, v->size, fbv, fev);
#line 866
  j = searchbegin;
  }
  {
#line 866
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 866
    if (! (j < searchend)) {
#line 866
      goto while_break___0;
    }
    {
#line 879
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 879
      if (j < searchend) {
        {
#line 879
        tmp___32 = rv(root);
#line 879
        tmp___33 = rb(root);
        }
#line 879
        if (! ((int )*(tmp___32 + (j - tmp___33)) == 0)) {
#line 879
          goto while_break___1;
        }
      } else {
#line 879
        goto while_break___1;
      }
#line 879
      j ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 880
    if (j == searchend) {
#line 880
      goto while_break___0;
    }
    {
#line 895
    tmp___34 = try_sort_sync(p___0, i, (unsigned char *)((void *)0), root->vector,
                             j, & matchbegin, & matchend, & offset, callback___0);
    }
#line 895
    if (tmp___34) {
#line 911
      r->begin = matchbegin;
#line 912
      r->end = matchend;
#line 913
      r->offset = - offset;
#line 914
      if (offset) {
#line 914
        if (callback___0) {
          {
#line 914
          (*callback___0)(r->begin, 2);
          }
        }
      }
#line 915
      return (1L);
    }
#line 866
    j += 23L;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 920
  return (0L);
}
}
#line 936 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/paranoia/paranoia.c"
static void i_silence_test(root_block *root ) 
{ 
  int16_t *vec ;
  int16_t *tmp ;
  long end ;
  long tmp___0 ;
  long tmp___1 ;
  long j ;
  long tmp___2 ;

  {
  {
#line 937
  tmp = rv(root);
#line 937
  vec = tmp;
#line 938
  tmp___0 = re(root);
#line 938
  tmp___1 = rb(root);
#line 938
  end = (tmp___0 - tmp___1) - 1L;
#line 944
  j = end - 1L;
  }
  {
#line 944
  while (1) {
    while_continue: /* CIL Label */ ;
#line 944
    if (! (j >= 0L)) {
#line 944
      goto while_break;
    }
#line 944
    if ((int )*(vec + j) != 0) {
#line 944
      goto while_break;
    }
#line 944
    j --;
  }
  while_break: /* CIL Label */ ;
  }
#line 950
  if (j < 0L) {
#line 950
    goto _L;
  } else
#line 950
  if (end - j > 1024L) {
    _L: /* CIL Label */ 
    {
#line 951
    root->silenceflag = 1;
#line 952
    tmp___2 = rb(root);
#line 952
    root->silencebegin = (tmp___2 + j) + 1L;
    }
#line 953
    if (root->silencebegin < root->returnedlimit) {
#line 954
      root->silencebegin = root->returnedlimit;
    }
  }
#line 956
  return;
}
}
#line 984 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/paranoia/paranoia.c"
static long i_silence_match(root_block *root , v_fragment *v , void (*callback___0)(long  ,
                                                                                    int  ) ) 
{ 
  cdrom_paranoia *p___0 ;
  int16_t *vec ;
  int16_t *tmp ;
  long end ;
  long begin ;
  long j ;
  long addto ;
  long tmp___0 ;
  int16_t *vec___0 ;
  unsigned long __lengthofvec___0 ;
  void *tmp___1 ;
  long tmp___2 ;
  long tmp___3 ;
  long tmp___5 ;
  long tmp___6 ;
  long voff ;
  long tmp___7 ;
  long tmp___8 ;
  long voff___0 ;
  long tmp___9 ;
  long tmp___10 ;

  {
  {
#line 987
  p___0 = v->p;
#line 988
  tmp = v_buffer(v);
#line 988
  vec = tmp;
#line 989
  end = v->size;
  }
#line 1001
  if (end < 1024L) {
#line 1001
    return (0L);
  }
#line 1002
  j = 0L;
  {
#line 1002
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1002
    if (! (j < end)) {
#line 1002
      goto while_break;
    }
#line 1002
    if ((int )*(vec + j) != 0) {
#line 1002
      goto while_break;
    }
#line 1002
    j ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1003
  if (j < 1024L) {
#line 1003
    return (0L);
  }
  {
#line 1009
  j += v->begin;
#line 1014
  tmp___2 = re(root);
  }
#line 1014
  if (v->begin >= tmp___2) {
    {
#line 1014
    tmp___3 = re(root);
    }
#line 1014
    if (v->begin - p___0->dynoverlap < tmp___3) {
      {
#line 1021
      tmp___0 = re(root);
#line 1021
      addto = (v->begin + 1024L) - tmp___0;
#line 1022
      __lengthofvec___0 = (unsigned long )addto;
#line 1022
      tmp___1 = __builtin_alloca(sizeof(*vec___0) * __lengthofvec___0);
#line 1022
      vec___0 = (int16_t *)tmp___1;
#line 1023
      memset((void *)vec___0, 0, (size_t )(sizeof(*vec___0) * __lengthofvec___0));
#line 1024
      c_append(root->vector, vec___0, addto);
      }
    }
  }
#line 1030
  if (v->begin < root->silencebegin) {
#line 1030
    begin = root->silencebegin;
  } else {
#line 1030
    begin = v->begin;
  }
  {
#line 1031
  tmp___6 = re(root);
  }
#line 1031
  if (j > tmp___6) {
    {
#line 1031
    tmp___5 = re(root);
#line 1031
    end = tmp___5;
    }
  } else {
#line 1031
    end = j;
  }
#line 1036
  if (begin < end) {
    {
#line 1042
    tmp___8 = re(root);
    }
#line 1042
    if (v->begin + v->size > tmp___8) {
      {
#line 1043
      voff = begin - v->begin;
#line 1047
      tmp___7 = rb(root);
#line 1047
      c_remove(root->vector, begin - tmp___7, -1L);
#line 1051
      c_append(root->vector, vec + voff, v->size - voff);
      }
    }
    {
#line 1056
    offset_add_value(p___0, & p___0->stage2, 0L, callback___0);
    }
  } else
#line 1066
  if (j < begin) {
    {
#line 1089
    voff___0 = j - v->begin;
#line 1097
    tmp___10 = re(root);
    }
#line 1097
    if ((begin + v->size) - voff___0 > tmp___10) {
      {
#line 1101
      tmp___9 = rb(root);
#line 1101
      c_remove(root->vector, root->silencebegin - tmp___9, -1L);
#line 1105
      c_append(root->vector, vec + voff___0, v->size - voff___0);
      }
    }
    {
#line 1111
    offset_add_value(p___0, & p___0->stage2, end - begin, callback___0);
    }
  } else {
#line 1122
    return (0L);
  }
  {
#line 1133
  root->silenceflag = 0;
#line 1137
  i_silence_test(root);
  }
#line 1143
  if (v->lastsector) {
#line 1143
    root->lastsector = 1L;
  }
  {
#line 1144
  free_v_fragment(v);
  }
#line 1145
  return (1L);
}
}
#line 1171 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/paranoia/paranoia.c"
static long i_stage2_each(root_block *root , v_fragment *v , void (*callback___0)(long  ,
                                                                                  int  ) ) 
{ 
  cdrom_paranoia *p___0 ;
  long dynoverlap ;
  sync_result r ;
  long begin ;
  long tmp ;
  long end ;
  long tmp___0 ;
  long offset ;
  long temp ;
  c_block *l ;
  long matchA ;
  long matchB ;
  long matchC ;
  long beginL ;
  int16_t *buff ;
  void *tmp___1 ;
  int16_t *tmp___2 ;
  long tmp___3 ;
  int16_t *tmp___4 ;
  long tmp___5 ;
  long tmp___6 ;
  long tmp___7 ;
  long tmp___8 ;
  long tmp___9 ;
  int16_t *tmp___10 ;
  long tmp___11 ;
  long tmp___12 ;
  long tmp___13 ;
  int16_t *tmp___14 ;
  long matchA___0 ;
  long matchB___0 ;
  long matchC___0 ;
  long beginL___0 ;
  long endL ;
  int16_t *buff___0 ;
  void *tmp___15 ;
  int16_t *tmp___16 ;
  long tmp___17 ;
  int16_t *tmp___18 ;
  long tmp___19 ;
  long tmp___20 ;
  long tmp___21 ;
  long tmp___22 ;
  long tmp___23 ;
  int16_t *tmp___24 ;
  long tmp___25 ;
  long tmp___26 ;
  long tmp___27 ;
  int16_t *tmp___28 ;
  long tmp___29 ;
  long tmp___30 ;
  int16_t *tmp___31 ;
  long tmp___32 ;
  long sizeA ;
  long tmp___33 ;
  long sizeB ;
  long vecbegin ;
  int16_t *vector ;
  long tmp___34 ;
  long tmp___35 ;
  long tmp___36 ;
  int16_t *tmp___37 ;

  {
#line 1174
  p___0 = v->p;
#line 1175
  dynoverlap = (p___0->dynoverlap / 2L) * 2L;
#line 1180
  if (! v) {
#line 1180
    return (0L);
  } else
#line 1180
  if (! v->one) {
#line 1180
    return (0L);
  }
  {
#line 1183
  tmp___37 = rv(root);
  }
#line 1183
  if (tmp___37) {
    {
#line 1192
    tmp___36 = i_iterate_stage2(p___0, v, & r, callback___0);
    }
#line 1192
    if (tmp___36) {
      {
#line 1195
      tmp = rb(root);
#line 1195
      begin = r.begin - tmp;
#line 1196
      tmp___0 = rb(root);
#line 1196
      end = r.end - tmp___0;
#line 1206
      offset = ((r.begin + r.offset) - v->begin) - begin;
#line 1208
      l = (c_block *)((void *)0);
      }
      {
#line 1260
      while (1) {
        while_continue: /* CIL Label */ ;
#line 1260
        if (begin + offset > 0L) {
#line 1260
          if (! (begin > 0L)) {
#line 1260
            goto while_break;
          }
        } else {
#line 1260
          goto while_break;
        }
#line 1261
        matchA = 0L;
#line 1261
        matchB = 0L;
#line 1261
        matchC = 0L;
#line 1267
        beginL = begin + offset;
#line 1274
        if ((unsigned long )l == (unsigned long )((void *)0)) {
          {
#line 1275
          tmp___1 = malloc((size_t )((unsigned long )v->size * sizeof(int16_t )));
#line 1275
          buff = (int16_t *)tmp___1;
#line 1276
          l = c_alloc(buff, v->begin, v->size);
#line 1277
          tmp___2 = v_buffer(v);
#line 1277
          memcpy((void */* __restrict  */)buff, (void const   */* __restrict  */)tmp___2,
                 (size_t )((unsigned long )v->size * sizeof(int16_t )));
          }
        }
        {
#line 1291
        tmp___3 = rs(root);
#line 1291
        tmp___4 = rv(root);
#line 1291
        i_analyze_rift_r(tmp___4, l->vector, tmp___3, l->size, begin - 1L, beginL - 1L,
                         & matchA, & matchB, & matchC);
        }
#line 1305
        if (matchA) {
#line 1308
          if (matchA > 0L) {
#line 1312
            if (callback___0) {
              {
#line 1312
              tmp___5 = rb(root);
#line 1312
              (*callback___0)((begin + tmp___5) - 1L, 10);
              }
            }
            {
#line 1313
            tmp___6 = rb(root);
            }
#line 1313
            if (tmp___6 + begin < p___0->root.returnedlimit) {
#line 1314
              goto while_break;
            } else {
              {
#line 1322
              c_insert(root->vector, begin, (l->vector + beginL) - matchA, matchA);
#line 1330
              offset -= matchA;
#line 1331
              begin += matchA;
#line 1332
              end += matchA;
              }
            }
          } else {
#line 1339
            if (callback___0) {
              {
#line 1339
              tmp___7 = rb(root);
#line 1339
              (*callback___0)((begin + tmp___7) - 1L, 11);
              }
            }
            {
#line 1340
            tmp___8 = rb(root);
            }
#line 1340
            if ((tmp___8 + begin) + matchA < p___0->root.returnedlimit) {
#line 1341
              goto while_break;
            } else {
              {
#line 1347
              c_remove(root->vector, begin + matchA, - matchA);
#line 1354
              offset -= matchA;
#line 1355
              begin += matchA;
#line 1356
              end += matchA;
              }
            }
          }
        } else
#line 1359
        if (matchB) {
#line 1362
          if (matchB > 0L) {
#line 1366
            if (callback___0) {
              {
#line 1366
              tmp___9 = rb(root);
#line 1366
              (*callback___0)((begin + tmp___9) - 1L, 10);
              }
            }
            {
#line 1373
            tmp___10 = rv(root);
#line 1373
            c_insert(l, beginL, (tmp___10 + begin) - matchB, matchB);
#line 1380
            offset += matchB;
            }
          } else {
#line 1386
            if (callback___0) {
              {
#line 1386
              tmp___11 = rb(root);
#line 1386
              (*callback___0)((begin + tmp___11) - 1L, 11);
              }
            }
            {
#line 1391
            c_remove(l, beginL + matchB, - matchB);
#line 1397
            offset += matchB;
            }
          }
        } else
#line 1400
        if (matchC) {
          {
#line 1415
          tmp___12 = rb(root);
          }
#line 1415
          if ((tmp___12 + begin) - matchC < p___0->root.returnedlimit) {
#line 1416
            goto while_break;
          }
          {
#line 1426
          c_overwrite(root->vector, begin - matchC, (l->vector + beginL) - matchC,
                      matchC);
          }
        } else {
#line 1453
          goto while_break;
        }
        {
#line 1463
        beginL = begin + offset;
#line 1470
        tmp___13 = rs(root);
#line 1470
        tmp___14 = rv(root);
#line 1470
        i_paranoia_overlap(tmp___14, l->vector, begin, beginL, tmp___13, l->size,
                           & begin, & end);
        }
      }
      while_break: /* CIL Label */ ;
      }
#line 1496
      if (l) {
#line 1496
        temp = l->size;
      } else {
#line 1496
        temp = v->size;
      }
      {
#line 1497
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1497
        if (end + offset < temp) {
          {
#line 1497
          tmp___32 = rs(root);
          }
#line 1497
          if (! (end < tmp___32)) {
#line 1497
            goto while_break___0;
          }
        } else {
#line 1497
          goto while_break___0;
        }
#line 1498
        matchA___0 = 0L;
#line 1498
        matchB___0 = 0L;
#line 1498
        matchC___0 = 0L;
#line 1505
        beginL___0 = begin + offset;
#line 1511
        endL = end + offset;
#line 1520
        if ((unsigned long )l == (unsigned long )((void *)0)) {
          {
#line 1521
          tmp___15 = malloc((size_t )((unsigned long )v->size * sizeof(int16_t )));
#line 1521
          buff___0 = (int16_t *)tmp___15;
#line 1522
          l = c_alloc(buff___0, v->begin, v->size);
#line 1523
          tmp___16 = v_buffer(v);
#line 1523
          memcpy((void */* __restrict  */)buff___0, (void const   */* __restrict  */)tmp___16,
                 (size_t )((unsigned long )v->size * sizeof(int16_t )));
          }
        }
        {
#line 1537
        tmp___17 = rs(root);
#line 1537
        tmp___18 = rv(root);
#line 1537
        i_analyze_rift_f(tmp___18, l->vector, tmp___17, l->size, end, endL, & matchA___0,
                         & matchB___0, & matchC___0);
        }
#line 1547
        if (matchA___0) {
#line 1550
          if (matchA___0 > 0L) {
#line 1554
            if (callback___0) {
              {
#line 1554
              tmp___19 = rb(root);
#line 1554
              (*callback___0)(end + tmp___19, 10);
              }
            }
            {
#line 1555
            tmp___20 = rb(root);
            }
#line 1555
            if (end + tmp___20 < p___0->root.returnedlimit) {
#line 1556
              goto while_break___0;
            }
            {
#line 1563
            c_insert(root->vector, end, l->vector + endL, matchA___0);
            }
          } else {
#line 1573
            if (callback___0) {
              {
#line 1573
              tmp___21 = rb(root);
#line 1573
              (*callback___0)(end + tmp___21, 11);
              }
            }
            {
#line 1574
            tmp___22 = rb(root);
            }
#line 1574
            if (end + tmp___22 < p___0->root.returnedlimit) {
#line 1575
              goto while_break___0;
            }
            {
#line 1580
            c_remove(root->vector, end, - matchA___0);
            }
          }
        } else
#line 1587
        if (matchB___0) {
#line 1590
          if (matchB___0 > 0L) {
#line 1594
            if (callback___0) {
              {
#line 1594
              tmp___23 = rb(root);
#line 1594
              (*callback___0)(end + tmp___23, 10);
              }
            }
            {
#line 1601
            tmp___24 = rv(root);
#line 1601
            c_insert(l, endL, tmp___24 + end, matchB___0);
            }
          } else {
#line 1611
            if (callback___0) {
              {
#line 1611
              tmp___25 = rb(root);
#line 1611
              (*callback___0)(end + tmp___25, 11);
              }
            }
            {
#line 1616
            c_remove(l, endL, - matchB___0);
            }
          }
        } else
#line 1622
        if (matchC___0) {
          {
#line 1634
          tmp___26 = rb(root);
          }
#line 1634
          if (end + tmp___26 < p___0->root.returnedlimit) {
#line 1635
            goto while_break___0;
          }
          {
#line 1640
          c_overwrite(root->vector, end, l->vector + endL, matchC___0);
          }
        } else {
          {
#line 1650
          tmp___27 = rs(root);
#line 1650
          tmp___28 = rv(root);
#line 1650
          analyze_rift_silence_f(tmp___28, l->vector, tmp___27, l->size, end, endL,
                                 & matchA___0, & matchB___0);
          }
#line 1654
          if (matchA___0) {
            {
#line 1666
            tmp___29 = rb(root);
            }
#line 1666
            if (end + tmp___29 >= p___0->root.returnedlimit) {
              {
#line 1667
              c_remove(root->vector, end, -1L);
              }
            }
          } else
#line 1670
          if (matchB___0) {
#line 1684
            if (l) {
              {
#line 1684
              i_cblock_destructor(l);
              }
            }
            {
#line 1685
            free_v_fragment(v);
            }
#line 1686
            return (1L);
          }
#line 1696
          goto while_break___0;
        }
        {
#line 1704
        tmp___30 = rs(root);
#line 1704
        tmp___31 = rv(root);
#line 1704
        i_paranoia_overlap(tmp___31, l->vector, begin, beginL___0, tmp___30, l->size,
                           (long *)((void *)0), & end);
#line 1709
        temp = l->size;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 1737
      tmp___33 = rs(root);
#line 1737
      sizeA = tmp___33;
      }
#line 1745
      if (l) {
#line 1746
        sizeB = l->size;
#line 1747
        vector = l->vector;
#line 1748
        vecbegin = l->begin;
      } else {
        {
#line 1750
        sizeB = v->size;
#line 1751
        vector = v_buffer(v);
#line 1752
        vecbegin = v->begin;
        }
      }
#line 1765
      if (sizeB - offset > sizeA) {
#line 1765
        goto _L;
      } else
#line 1765
      if (v->lastsector) {
        _L: /* CIL Label */ 
#line 1766
        if (v->lastsector) {
#line 1767
          root->lastsector = 1L;
        }
#line 1776
        if (end < sizeA) {
          {
#line 1776
          c_remove(root->vector, end, -1L);
          }
        }
#line 1781
        if ((sizeB - offset) - end) {
          {
#line 1781
          c_append(root->vector, (vector + end) + offset, (sizeB - offset) - end);
          }
        }
        {
#line 1787
        i_silence_test(root);
#line 1802
        tmp___34 = rb(root);
#line 1802
        offset_add_value(p___0, & p___0->stage2, (offset + vecbegin) - tmp___34, callback___0);
        }
      }
#line 1805
      if (l) {
        {
#line 1805
        i_cblock_destructor(l);
        }
      }
      {
#line 1806
      free_v_fragment(v);
      }
#line 1807
      return (1L);
    } else {
      {
#line 1827
      tmp___35 = re(root);
      }
#line 1827
      if ((v->begin + v->size) + dynoverlap < tmp___35) {
#line 1827
        if (! root->silenceflag) {
          {
#line 1829
          free_v_fragment(v);
          }
        }
      }
#line 1834
      return (0L);
    }
  } else {
#line 1184
    return (0L);
  }
}
}
#line 1840 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/paranoia/paranoia.c"
static int i_init_root(root_block *root , v_fragment *v , long begin , void (*callback___0)(long  ,
                                                                                            int  ) ) 
{ 
  int16_t *tmp ;
  int16_t *buff ;
  void *tmp___0 ;
  int16_t *tmp___1 ;

  {
#line 1842
  if (v->begin <= begin) {
#line 1842
    if (v->begin + v->size > begin) {
      {
#line 1844
      root->lastsector = v->lastsector;
#line 1845
      root->returnedlimit = begin;
#line 1847
      tmp = rv(root);
      }
#line 1847
      if (tmp) {
        {
#line 1848
        i_cblock_destructor(root->vector);
#line 1849
        root->vector = (c_block *)((void *)0);
        }
      }
      {
#line 1853
      tmp___0 = malloc((size_t )((unsigned long )v->size * sizeof(int16_t )));
#line 1853
      buff = (int16_t *)tmp___0;
#line 1854
      tmp___1 = v_buffer(v);
#line 1854
      memcpy((void */* __restrict  */)buff, (void const   */* __restrict  */)tmp___1,
             (size_t )((unsigned long )v->size * sizeof(int16_t )));
#line 1855
      root->vector = c_alloc(buff, v->begin, v->size);
#line 1860
      i_silence_test(root);
      }
#line 1862
      return (1);
    } else {
#line 1864
      return (0);
    }
  } else {
#line 1864
    return (0);
  }
}
}
#line 1867 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/paranoia/paranoia.c"
static int vsort(void const   *a , void const   *b ) 
{ 


  {
#line 1868
  return ((int )((*((v_fragment **)a))->begin - (*((v_fragment **)b))->begin));
}
}
#line 1897 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/paranoia/paranoia.c"
static int i_stage2(cdrom_paranoia *p___0 , long beginword , long endword , void (*callback___0)(long  ,
                                                                                                 int  ) ) 
{ 
  int flag ;
  int ret ;
  root_block *root ;
  v_fragment *first ;
  v_fragment *tmp ;
  long active ;
  long count ;
  v_fragment **list ;
  unsigned long __lengthoflist ;
  void *tmp___0 ;
  v_fragment *next ;
  v_fragment *tmp___1 ;
  long tmp___2 ;
  int tmp___3 ;
  long tmp___4 ;
  int16_t *tmp___5 ;
  long tmp___6 ;
  int16_t *tmp___7 ;

  {
#line 1900
  flag = 1;
#line 1900
  ret = 0;
#line 1901
  root = & p___0->root;
  {
#line 1917
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1917
    if (! flag) {
#line 1917
      goto while_break;
    }
    {
#line 1922
    tmp = v_first(p___0);
#line 1922
    first = tmp;
#line 1923
    active = (p___0->fragments)->active;
#line 1923
    count = 0L;
#line 1924
    __lengthoflist = (unsigned long )active;
#line 1924
    tmp___0 = __builtin_alloca(sizeof(*list) * __lengthoflist);
#line 1924
    list = (v_fragment **)tmp___0;
    }
    {
#line 1926
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1926
      if (! first) {
#line 1926
        goto while_break___0;
      }
      {
#line 1927
      tmp___1 = v_next(first);
#line 1927
      next = tmp___1;
#line 1928
      tmp___2 = count;
#line 1928
      count ++;
#line 1928
      *(list + tmp___2) = first;
#line 1929
      first = next;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1936
    flag = 0;
#line 1937
    if (count) {
      {
#line 1942
      qsort((void *)list, (size_t )active, (size_t )sizeof(v_fragment *), & vsort);
#line 1953
      count = 0L;
      }
      {
#line 1953
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 1953
        if (! (count < active)) {
#line 1953
          goto while_break___1;
        }
#line 1954
        first = *(list + count);
#line 1958
        if (first->one) {
          {
#line 1984
          tmp___5 = rv(root);
          }
#line 1984
          if ((unsigned long )tmp___5 == (unsigned long )((void *)0)) {
            {
#line 1985
            tmp___3 = i_init_root(& p___0->root, first, beginword, callback___0);
            }
#line 1985
            if (tmp___3) {
              {
#line 1986
              free_v_fragment(first);
#line 1991
              flag = 1;
#line 1992
              ret ++;
              }
            }
          } else {
            {
#line 1999
            tmp___4 = i_stage2_each(root, first, callback___0);
            }
#line 1999
            if (tmp___4) {
#line 2004
              ret ++;
#line 2005
              flag = 1;
            }
          }
        }
#line 1953
        count ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 2015
      if (! flag) {
#line 2015
        if (p___0->root.silenceflag) {
#line 2016
          count = 0L;
          {
#line 2016
          while (1) {
            while_continue___2: /* CIL Label */ ;
#line 2016
            if (! (count < active)) {
#line 2016
              goto while_break___2;
            }
#line 2017
            first = *(list + count);
#line 2021
            if (first->one) {
              {
#line 2022
              tmp___7 = rv(root);
              }
#line 2022
              if ((unsigned long )tmp___7 != (unsigned long )((void *)0)) {
                {
#line 2031
                tmp___6 = i_silence_match(root, first, callback___0);
                }
#line 2031
                if (tmp___6) {
#line 2036
                  ret ++;
#line 2037
                  flag = 1;
                }
              }
            }
#line 2016
            count ++;
          }
          while_break___2: /* CIL Label */ ;
          }
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 2055
  return (ret);
}
}
#line 2058 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/paranoia/paranoia.c"
static void i_end_case(cdrom_paranoia *p___0 , long endword , void (*callback___0)(long  ,
                                                                                   int  ) ) 
{ 
  root_block *root ;
  long tmp ;
  long addto ;
  long tmp___0 ;
  char *temp ;
  void *tmp___1 ;

  {
#line 2061
  root = & p___0->root;
#line 2068
  if (root->lastsector == 0L) {
#line 2068
    return;
  }
  {
#line 2069
  tmp = re(root);
  }
#line 2069
  if (endword < tmp) {
#line 2069
    return;
  }
  {
#line 2072
  tmp___0 = re(root);
#line 2072
  addto = endword - tmp___0;
#line 2073
  tmp___1 = calloc((size_t )addto, (size_t )(sizeof(char ) * 2UL));
#line 2073
  temp = (char *)tmp___1;
#line 2075
  c_append(root->vector, (int16_t *)((void *)temp), addto);
#line 2076
  free((void *)temp);
#line 2079
  paranoia_resetcache(p___0);
  }
#line 2082
  return;
}
}
#line 2092 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/paranoia/paranoia.c"
static void verify_skip_case(cdrom_paranoia *p___0 , void (*callback___0)(long  ,
                                                                          int  ) ) 
{ 
  root_block *root ;
  c_block *graft ;
  int vflag ;
  int gend ;
  long post ;
  int16_t *tmp ;
  c_block *c ;
  c_block *tmp___0 ;
  long cbegin ;
  long cend ;
  long vend ;
  long cbegin___0 ;
  long cend___0 ;
  int16_t *buff ;
  void *tmp___1 ;
  int16_t *tmp___2 ;
  void *temp ;
  void *tmp___3 ;
  int16_t *tmp___4 ;

  {
  {
#line 2094
  root = & p___0->root;
#line 2095
  graft = (c_block *)((void *)0);
#line 2096
  vflag = 0;
#line 2097
  gend = 0;
#line 2104
  tmp = rv(root);
  }
#line 2104
  if ((unsigned long )tmp == (unsigned long )((void *)0)) {
#line 2105
    post = 0L;
  } else {
    {
#line 2107
    post = re(root);
    }
  }
#line 2109
  if (post == -1L) {
#line 2109
    post = 0L;
  }
#line 2111
  if (callback___0) {
    {
#line 2111
    (*callback___0)(post, 6);
    }
  }
  {
#line 2117
  tmp___0 = c_first(p___0);
#line 2117
  c = tmp___0;
  }
  {
#line 2118
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2118
    if (! c) {
#line 2118
      goto while_break;
    }
#line 2119
    cbegin = c->begin;
#line 2120
    cend = c->begin + c->size;
#line 2121
    if (cbegin <= post) {
#line 2121
      if (cend > post) {
#line 2122
        vend = post;
#line 2124
        if ((int )*(c->flags + (post - cbegin)) & 4) {
          {
#line 2126
          while (1) {
            while_continue___0: /* CIL Label */ ;
#line 2126
            if (vend < cend) {
#line 2126
              if (! ((int )*(c->flags + (vend - cbegin)) & 4)) {
#line 2126
                goto while_break___0;
              }
            } else {
#line 2126
              goto while_break___0;
            }
#line 2126
            vend ++;
          }
          while_break___0: /* CIL Label */ ;
          }
#line 2127
          if (! vflag) {
#line 2128
            graft = c;
#line 2129
            gend = (int )vend;
          } else
#line 2127
          if (vend > (long )vflag) {
#line 2128
            graft = c;
#line 2129
            gend = (int )vend;
          }
#line 2131
          vflag = 1;
        } else
#line 2134
        if (! vflag) {
          {
#line 2135
          while (1) {
            while_continue___1: /* CIL Label */ ;
#line 2135
            if (vend < cend) {
#line 2135
              if (! (((int )*(c->flags + (vend - cbegin)) & 4) == 0)) {
#line 2135
                goto while_break___1;
              }
            } else {
#line 2135
              goto while_break___1;
            }
#line 2135
            vend ++;
          }
          while_break___1: /* CIL Label */ ;
          }
#line 2136
          if ((unsigned long )graft == (unsigned long )((void *)0)) {
#line 2138
            graft = c;
#line 2139
            gend = (int )vend;
          } else
#line 2136
          if ((long )gend > vend) {
#line 2138
            graft = c;
#line 2139
            gend = (int )vend;
          }
        }
      }
    }
    {
#line 2144
    c = c_next(c);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 2147
  if (graft) {
#line 2148
    cbegin___0 = graft->begin;
#line 2149
    cend___0 = graft->begin + graft->size;
    {
#line 2151
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 2151
      if ((long )gend < cend___0) {
#line 2151
        if (! ((int )*(graft->flags + ((long )gend - cbegin___0)) & 4)) {
#line 2151
          goto while_break___2;
        }
      } else {
#line 2151
        goto while_break___2;
      }
#line 2151
      gend ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 2152
    if ((long )(gend + 31) > cend___0) {
#line 2152
      gend = (int )cend___0;
    } else {
#line 2152
      gend += 31;
    }
    {
#line 2154
    tmp___2 = rv(root);
    }
#line 2154
    if ((unsigned long )tmp___2 == (unsigned long )((void *)0)) {
      {
#line 2155
      tmp___1 = malloc((size_t )graft->size);
#line 2155
      buff = (int16_t *)tmp___1;
#line 2156
      memcpy((void */* __restrict  */)buff, (void const   */* __restrict  */)graft->vector,
             (size_t )graft->size);
#line 2157
      root->vector = c_alloc(buff, graft->begin, graft->size);
      }
    } else {
      {
#line 2159
      c_append(root->vector, (graft->vector + post) - cbegin___0, (long )gend - post);
      }
    }
    {
#line 2163
    root->returnedlimit = re(root);
    }
#line 2164
    return;
  }
  {
#line 2170
  tmp___3 = calloc((size_t )2352, (size_t )sizeof(int16_t ));
#line 2170
  temp = tmp___3;
#line 2172
  tmp___4 = rv(root);
  }
#line 2172
  if ((unsigned long )tmp___4 == (unsigned long )((void *)0)) {
    {
#line 2173
    root->vector = c_alloc((int16_t *)temp, post, 2352L);
    }
  } else {
    {
#line 2175
    c_append(root->vector, (int16_t *)temp, 2352L);
#line 2176
    free(temp);
    }
  }
  {
#line 2179
  root->returnedlimit = re(root);
  }
#line 2181
  return;
}
}
#line 2185 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/paranoia/paranoia.c"
void paranoia_free(cdrom_paranoia *p___0 ) 
{ 


  {
  {
#line 2186
  paranoia_resetall(p___0);
#line 2187
  sort_free(p___0->sortcache);
#line 2188
  free_list(p___0->cache, 1);
#line 2189
  free_list(p___0->fragments, 1);
#line 2190
  free((void *)p___0);
  }
#line 2191
  return;
}
}
#line 2193 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/paranoia/paranoia.c"
void paranoia_modeset(cdrom_paranoia *p___0 , int enable ) 
{ 


  {
#line 2194
  p___0->enable = enable;
#line 2195
  return;
}
}
#line 2197 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/paranoia/paranoia.c"
long paranoia_seek(cdrom_paranoia *p___0 , long seek , int mode ) 
{ 
  long sector ;
  long ret ;
  long tmp ;
  int tmp___0 ;

  {
  {
#line 2201
  if (mode == 0) {
#line 2201
    goto case_0;
  }
#line 2204
  if (mode == 2) {
#line 2204
    goto case_2;
  }
#line 2207
  goto switch_default;
  case_0: /* CIL Label */ 
#line 2202
  sector = seek;
#line 2203
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 2205
  tmp = cdda_disc_lastsector(p___0->d);
#line 2205
  sector = tmp + seek;
  }
#line 2206
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 2208
  sector = p___0->cursor + seek;
#line 2209
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 2212
  tmp___0 = cdda_sector_gettrack(p___0->d, sector);
  }
#line 2212
  if (tmp___0 == -1) {
#line 2212
    return (-1L);
  }
  {
#line 2214
  i_cblock_destructor(p___0->root.vector);
#line 2215
  p___0->root.vector = (c_block *)((void *)0);
#line 2216
  p___0->root.lastsector = 0L;
#line 2217
  p___0->root.returnedlimit = 0L;
#line 2219
  ret = p___0->cursor;
#line 2220
  p___0->cursor = sector;
#line 2222
  i_paranoia_firstlast(p___0);
#line 2225
  p___0->current_firstsector = sector;
  }
#line 2227
  return (ret);
}
}
#line 2230 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/paranoia/paranoia.c"
static void cdrom_cache_update(cdrom_paranoia *p___0 , int lba , int sectors ) 
{ 
  int end ;

  {
#line 2232
  if (lba + sectors > p___0->cdcache_size) {
#line 2233
    end = lba + sectors;
#line 2234
    lba = end - p___0->cdcache_size;
#line 2235
    sectors = end - lba;
  }
#line 2238
  if (lba < p___0->cdcache_begin) {
#line 2240
    p___0->cdcache_begin = lba;
#line 2241
    p___0->cdcache_end = lba + sectors;
  } else {
#line 2243
    if (lba + sectors > p___0->cdcache_end) {
#line 2244
      p___0->cdcache_end = lba + sectors;
    }
#line 2245
    if ((lba + sectors) - p___0->cdcache_size > p___0->cdcache_begin) {
#line 2246
      if ((lba + sectors) - p___0->cdcache_size < p___0->cdcache_end) {
#line 2247
        p___0->cdcache_begin = (lba + sectors) - p___0->cdcache_size;
      } else {
#line 2249
        p___0->cdcache_begin = lba;
      }
    }
  }
#line 2253
  return;
}
}
#line 2255 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/paranoia/paranoia.c"
static void cdrom_cache_handler(cdrom_paranoia *p___0 , int lba , void (*callback___0)(long  ,
                                                                                       int  ) ) 
{ 
  int seekpos ;
  int ms ;
  long tmp___0 ;
  int pre ;
  int post ;
  long tmp___2 ;
  long tmp___3 ;

  {
#line 2258
  if (lba >= p___0->cdcache_end) {
#line 2258
    return;
  }
#line 2260
  if (lba < 0) {
#line 2260
    lba = 0;
  }
#line 2262
  if (lba < p___0->cdcache_begin) {
#line 2264
    if (lba == 0) {
#line 2264
      seekpos = lba;
    } else {
      {
#line 2264
      tmp___0 = cdda_disc_firstsector(p___0->d);
      }
#line 2264
      if ((long )(lba - 1) < tmp___0) {
#line 2264
        seekpos = lba;
      } else {
#line 2264
        seekpos = lba - 1;
      }
    }
  } else {
    {
#line 2266
    pre = p___0->cdcache_begin - 1;
#line 2267
    post = lba + p___0->cdcache_size;
#line 2269
    tmp___2 = cdda_disc_firstsector(p___0->d);
    }
#line 2269
    if ((long )pre < tmp___2) {
#line 2269
      seekpos = post;
    } else {
#line 2269
      seekpos = pre;
    }
  }
  {
#line 2272
  tmp___3 = cdda_read_timed(p___0->d, (void *)0, (long )seekpos, 1L, & ms);
  }
#line 2272
  if (tmp___3 == 1L) {
#line 2273
    if (seekpos < p___0->cdcache_begin) {
#line 2273
      if (ms < 6) {
        {
#line 2274
        (*callback___0)((long )(seekpos * 1176), 13);
        }
      }
    }
  }
  {
#line 2275
  cdrom_cache_update(p___0, seekpos, 1);
  }
#line 2276
  return;
}
}
#line 2312 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/paranoia/paranoia.c"
c_block *i_read_c_block(cdrom_paranoia *p___0 , long beginword , long endword , void (*callback___0)(long  ,
                                                                                                     int  ) ) 
{ 
  long readat ;
  long firstread ;
  long totaltoread ;
  long sectatonce ;
  long driftcomp ;
  c_block *new ;
  root_block *root ;
  int16_t *buffer ;
  unsigned char *flags ;
  long sofar ;
  long dynoverlap ;
  long anyflag ;
  long target ;
  long tmp ;
  int16_t *tmp___0 ;
  long tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  long secread ;
  long adjread ;
  long thisread ;
  int *tmp___4 ;
  int i ;

  {
#line 2322
  totaltoread = (long )p___0->cdcache_size;
#line 2323
  sectatonce = (long )(p___0->d)->nsectors;
#line 2324
  driftcomp = (long )((double )((float )p___0->dyndrift / (float )1176) + .5);
#line 2325
  new = (c_block *)((void *)0);
#line 2326
  root = & p___0->root;
#line 2327
  buffer = (int16_t *)((void *)0);
#line 2328
  flags = (unsigned char *)((void *)0);
#line 2330
  dynoverlap = ((p___0->dynoverlap + 1176L) - 1L) / 1176L;
#line 2331
  anyflag = 0L;
#line 2343
  if (p___0->enable & 5) {
    {
#line 2346
    tmp___0 = rv(root);
    }
#line 2346
    if ((unsigned long )tmp___0 == (unsigned long )((void *)0)) {
#line 2347
      target = p___0->cursor - dynoverlap;
    } else {
      {
#line 2346
      tmp___1 = rb(root);
      }
#line 2346
      if (tmp___1 > beginword) {
#line 2347
        target = p___0->cursor - dynoverlap;
      } else {
        {
#line 2349
        tmp = re(root);
#line 2349
        target = tmp / 1176L - dynoverlap;
        }
      }
    }
#line 2357
    readat = (target & -15L) + (long )p___0->jitter;
#line 2358
    if (readat > target) {
#line 2358
      readat -= 15L;
    }
#line 2359
    (p___0->jitter) --;
#line 2360
    if (p___0->jitter < 0) {
#line 2360
      p___0->jitter += 15;
    }
  } else {
#line 2363
    readat = p___0->cursor;
  }
#line 2366
  readat += driftcomp;
#line 2372
  if (p___0->enable & 5) {
    {
#line 2373
    tmp___2 = calloc((size_t )(totaltoread * 1176L), (size_t )1);
#line 2373
    flags = (unsigned char *)tmp___2;
#line 2374
    new = new_c_block(p___0);
#line 2375
    recover_cache(p___0);
    }
  } else {
    {
#line 2378
    paranoia_resetall(p___0);
#line 2379
    new = new_c_block(p___0);
    }
  }
  {
#line 2382
  tmp___3 = malloc((size_t )(totaltoread * 2352L));
#line 2382
  buffer = (int16_t *)tmp___3;
#line 2383
  sofar = 0L;
#line 2384
  firstread = -1L;
#line 2387
  cdrom_cache_handler(p___0, (int )readat, callback___0);
  }
  {
#line 2399
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2399
    if (! (sofar < totaltoread)) {
#line 2399
      goto while_break;
    }
#line 2400
    secread = sectatonce;
#line 2401
    adjread = readat;
#line 2405
    if (adjread < p___0->current_firstsector) {
#line 2406
      secread -= p___0->current_firstsector - adjread;
#line 2407
      adjread = p___0->current_firstsector;
    }
#line 2409
    if ((adjread + secread) - 1L > p___0->current_lastsector) {
#line 2410
      secread = (p___0->current_lastsector - adjread) + 1L;
    }
#line 2412
    if (sofar + secread > totaltoread) {
#line 2412
      secread = totaltoread - sofar;
    }
#line 2414
    if (secread > 0L) {
#line 2416
      if (firstread < 0L) {
#line 2416
        firstread = adjread;
      }
      {
#line 2438
      thisread = cdda_read(p___0->d, (void *)(buffer + sofar * 1176L), adjread, secread);
      }
#line 2438
      if (thisread < secread) {
#line 2441
        if (thisread < 0L) {
          {
#line 2442
          tmp___4 = __errno_location();
          }
#line 2442
          if (*tmp___4 == 123) {
#line 2444
            if (new) {
              {
#line 2444
              free_c_block(new);
              }
            }
#line 2445
            if (buffer) {
              {
#line 2445
              free((void *)buffer);
              }
            }
#line 2446
            if (flags) {
              {
#line 2446
              free((void *)flags);
              }
            }
#line 2447
            return ((c_block *)((void *)0));
          }
#line 2449
          thisread = 0L;
        }
#line 2455
        if (callback___0) {
          {
#line 2455
          (*callback___0)((adjread + thisread) * 1176L, 12);
          }
        }
        {
#line 2456
        memset((void *)(buffer + (sofar + thisread) * 1176L), 0, (size_t )(2352L * (secread - thisread)));
        }
#line 2458
        if (flags) {
          {
#line 2458
          memset((void *)(flags + (sofar + thisread) * 1176L), 2, (size_t )(1176L * (secread - thisread)));
          }
        }
      }
#line 2461
      if (thisread != 0L) {
#line 2461
        anyflag = 1L;
      }
#line 2477
      if (flags) {
#line 2477
        if (sofar != 0L) {
#line 2480
          i = 0;
#line 2481
          i = -32;
          {
#line 2481
          while (1) {
            while_continue___0: /* CIL Label */ ;
#line 2481
            if (! (i < 32)) {
#line 2481
              goto while_break___0;
            }
#line 2482
            *(flags + (sofar * 1176L + (long )i)) = (unsigned char )((int )*(flags + (sofar * 1176L + (long )i)) | 1);
#line 2481
            i ++;
          }
          while_break___0: /* CIL Label */ ;
          }
        }
      }
#line 2485
      if ((adjread + secread) - 1L == p___0->current_lastsector) {
#line 2486
        new->lastsector = -1L;
      }
#line 2488
      if (callback___0) {
        {
#line 2488
        (*callback___0)(((adjread + secread) - 1L) * 1176L, 0);
        }
      }
      {
#line 2490
      cdrom_cache_update(p___0, (int )adjread, (int )secread);
#line 2491
      sofar += secread;
#line 2492
      readat = adjread + secread;
      }
    } else
#line 2494
    if (readat < p___0->current_firstsector) {
#line 2495
      readat += sectatonce;
    } else {
#line 2497
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 2511
  if (anyflag) {
#line 2512
    new->vector = buffer;
#line 2513
    new->begin = firstread * 1176L - p___0->dyndrift;
#line 2514
    new->size = sofar * 1176L;
#line 2515
    new->flags = flags;
  } else {
#line 2517
    if (new) {
      {
#line 2517
      free_c_block(new);
      }
    }
    {
#line 2518
    free((void *)buffer);
#line 2519
    free((void *)flags);
#line 2520
    new = (c_block *)((void *)0);
    }
  }
#line 2522
  return (new);
}
}
#line 2536 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/paranoia/paranoia.c"
int16_t *paranoia_read(cdrom_paranoia *p___0 , void (*callback___0)(long  , int  ) ) 
{ 
  int16_t *tmp ;

  {
  {
#line 2537
  tmp = paranoia_read_limited(p___0, callback___0, 20);
  }
#line 2537
  return (tmp);
}
}
#line 2543 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/paranoia/paranoia.c"
int16_t *paranoia_read_limited(cdrom_paranoia *p___0 , void (*callback___0)(long  ,
                                                                            int  ) ,
                               int max_retries ) 
{ 
  long beginword ;
  long endword ;
  long retry_count ;
  long lastend ;
  root_block *root ;
  int *tmp ;
  long tmp___0 ;
  long tmp___1 ;
  long tmp___2 ;
  long tmp___3 ;
  c_block *new ;
  c_block *tmp___4 ;
  long begin ;
  long end ;
  int tmp___5 ;
  int *tmp___6 ;
  long tmp___7 ;
  long tmp___8 ;
  int16_t *tmp___9 ;
  long tmp___10 ;
  long tmp___11 ;
  long tmp___12 ;
  int16_t *tmp___13 ;
  long tmp___14 ;

  {
#line 2546
  beginword = p___0->cursor * 1176L;
#line 2547
  endword = beginword + 1176L;
#line 2548
  retry_count = 0L;
#line 2548
  lastend = -2L;
#line 2549
  root = & p___0->root;
#line 2551
  if ((p___0->d)->opened == 0) {
    {
#line 2552
    tmp = __errno_location();
#line 2552
    *tmp = 9;
    }
#line 2553
    return ((int16_t *)((void *)0));
  }
#line 2556
  if (beginword > p___0->root.returnedlimit) {
#line 2556
    p___0->root.returnedlimit = beginword;
  }
  {
#line 2557
  lastend = re(root);
  }
  {
#line 2570
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 2570
    tmp___9 = rv(root);
    }
#line 2570
    if (! ((unsigned long )tmp___9 == (unsigned long )((void *)0))) {
      {
#line 2570
      tmp___10 = rb(root);
      }
#line 2570
      if (! (tmp___10 > beginword)) {
        {
#line 2570
        tmp___11 = re(root);
        }
#line 2570
        if (tmp___11 < endword + 37632L) {
#line 2570
          if (! (p___0->enable & 5)) {
#line 2570
            goto _L___1;
          }
        } else {
          _L___1: /* CIL Label */ 
          {
#line 2570
          tmp___12 = re(root);
          }
#line 2570
          if (! (tmp___12 < endword)) {
#line 2570
            goto while_break;
          }
        }
      }
    }
#line 2584
    if (p___0->enable & 5) {
      {
#line 2595
      i_paranoia_trim(p___0, beginword, endword);
#line 2596
      recover_cache(p___0);
#line 2598
      tmp___0 = rb(root);
      }
#line 2598
      if (tmp___0 != -1L) {
#line 2598
        if (p___0->root.lastsector) {
          {
#line 2599
          i_end_case(p___0, endword + 37632L, callback___0);
          }
        } else {
          {
#line 2608
          i_stage2(p___0, beginword, endword + 37632L, callback___0);
          }
        }
      } else {
        {
#line 2608
        i_stage2(p___0, beginword, endword + 37632L, callback___0);
        }
      }
    } else {
      {
#line 2612
      i_end_case(p___0, endword + 37632L, callback___0);
      }
    }
    {
#line 2618
    tmp___1 = rb(root);
    }
#line 2618
    if (! (tmp___1 == -1L)) {
      {
#line 2618
      tmp___2 = rb(root);
      }
#line 2618
      if (! (tmp___2 > beginword)) {
        {
#line 2618
        tmp___3 = re(root);
        }
#line 2618
        if (! (tmp___3 < endword + 37632L)) {
#line 2620
          goto while_break;
        }
      }
    }
    {
#line 2632
    tmp___4 = i_read_c_block(p___0, beginword, endword, callback___0);
#line 2632
    new = tmp___4;
    }
#line 2634
    if (new) {
#line 2635
      if (p___0->enable & 5) {
#line 2643
        if (p___0->enable & 1) {
          {
#line 2644
          i_stage1(p___0, new, callback___0);
          }
        } else {
#line 2656
          begin = 0L;
#line 2656
          end = 0L;
          {
#line 2658
          while (1) {
            while_continue___0: /* CIL Label */ ;
#line 2658
            if (! (begin < new->size)) {
#line 2658
              goto while_break___0;
            }
            {
#line 2659
            while (1) {
              while_continue___1: /* CIL Label */ ;
#line 2659
              if (begin < new->size) {
#line 2659
                if (! ((int )*(new->flags + begin) & 1)) {
#line 2659
                  goto while_break___1;
                }
              } else {
#line 2659
                goto while_break___1;
              }
#line 2659
              begin ++;
            }
            while_break___1: /* CIL Label */ ;
            }
#line 2660
            end = begin + 1L;
            {
#line 2661
            while (1) {
              while_continue___2: /* CIL Label */ ;
#line 2661
              if (end < new->size) {
#line 2661
                if (! (((int )*(new->flags + end) & 1) == 0)) {
#line 2661
                  goto while_break___2;
                }
              } else {
#line 2661
                goto while_break___2;
              }
#line 2661
              end ++;
            }
            while_break___2: /* CIL Label */ ;
            }
#line 2663
            if (new->lastsector) {
#line 2663
              if (new->begin + end == new->begin + new->size) {
#line 2663
                tmp___5 = 1;
              } else {
#line 2663
                tmp___5 = 0;
              }
            } else {
#line 2663
              tmp___5 = 0;
            }
            {
#line 2663
            new_v_fragment(p___0, new, begin + new->begin, end + new->begin, tmp___5);
#line 2667
            begin = end;
            }
          }
          while_break___0: /* CIL Label */ ;
          }
        }
      } else {
#line 2678
        if (p___0->root.vector) {
          {
#line 2678
          i_cblock_destructor(p___0->root.vector);
          }
        }
        {
#line 2679
        free_elem(new->e, 0);
#line 2680
        p___0->root.vector = new;
#line 2682
        i_end_case(p___0, endword + 37632L, callback___0);
        }
      }
    } else {
      {
#line 2690
      tmp___6 = __errno_location();
      }
#line 2690
      if (*tmp___6 == 123) {
#line 2690
        return ((int16_t *)((void *)0));
      }
    }
    {
#line 2700
    tmp___7 = rb(root);
    }
#line 2700
    if (tmp___7 != -1L) {
      {
#line 2700
      tmp___8 = re(root);
      }
#line 2700
      if (lastend + 588L < tmp___8) {
        {
#line 2702
        lastend = re(root);
#line 2703
        retry_count = 0L;
        }
      } else {
#line 2700
        goto _L___0;
      }
    } else {
      _L___0: /* CIL Label */ 
#line 2706
      retry_count ++;
#line 2711
      if (retry_count % 5L == 0L) {
#line 2712
        if (p___0->dynoverlap == 37632L) {
#line 2712
          goto _L;
        } else
#line 2712
        if (retry_count == (long )max_retries) {
          _L: /* CIL Label */ 
#line 2714
          if (! (p___0->enable & 32)) {
            {
#line 2714
            verify_skip_case(p___0, callback___0);
            }
          }
#line 2715
          retry_count = 0L;
        } else
#line 2717
        if (p___0->stage1.offpoints != -1L) {
#line 2718
          p___0->dynoverlap = (long )((double )p___0->dynoverlap * 1.5);
#line 2719
          if (p___0->dynoverlap > 37632L) {
#line 2720
            p___0->dynoverlap = 37632L;
          }
#line 2721
          if (callback___0) {
            {
#line 2721
            (*callback___0)(p___0->dynoverlap, 9);
            }
          }
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2734
  (p___0->cursor) ++;
#line 2739
  tmp___13 = rv(root);
#line 2739
  tmp___14 = rb(root);
  }
#line 2739
  return (tmp___13 + (beginword - tmp___14));
}
}
#line 2743 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/paranoia/paranoia.c"
void paranoia_overlapset(cdrom_paranoia *p___0 , long overlap___0 ) 
{ 


  {
#line 2744
  p___0->dynoverlap = overlap___0 * 1176L;
#line 2745
  p___0->stage1.offpoints = -1L;
#line 2746
  return;
}
}
#line 2748 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/paranoia/paranoia.c"
char *paranoia_version(void) 
{ 
  char *__cil_tmp1 ;

  {
#line 2749
  return ((char *)"10.2");
}
}
#line 104 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/interface/utils.h"
static void cderror___3(cdrom_drive *d___0 , char const   *s ) 
{ 
  size_t tmp ;

  {
#line 105
  if (s) {
#line 105
    if (d___0) {
      {
#line 107
      if (d___0->errordest == 1) {
#line 107
        goto case_1;
      }
#line 110
      if (d___0->errordest == 2) {
#line 110
        goto case_2;
      }
#line 114
      goto switch_default;
      case_1: /* CIL Label */ 
      {
#line 108
      tmp = strlen(s);
#line 108
      write(2, (void const   *)s, tmp);
      }
#line 109
      goto switch_break;
      case_2: /* CIL Label */ 
      {
#line 111
      d___0->errorbuf = catstring(d___0->errorbuf, s);
      }
#line 112
      goto switch_break;
      switch_default: /* CIL Label */ 
#line 115
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    }
  }
#line 118
  return;
}
}
#line 18 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/interface/smallft.c"
static void drfti1___0(int n , float *wa , int *ifac ) ;
#line 18 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/interface/smallft.c"
static int ntryh___0[4]  = {      4,      2,      3,      5};
#line 19 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/interface/smallft.c"
static float tpi___0  =    (float )6.28318530717958647692528676655900577;
#line 17 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/interface/smallft.c"
static void drfti1___0(int n , float *wa , int *ifac ) 
{ 
  float arg ;
  float argh ;
  float argld ;
  float fi ;
  int ntry ;
  int i ;
  int j ;
  int k1 ;
  int l1 ;
  int l2 ;
  int ib ;
  int ld ;
  int ii ;
  int ip ;
  int is ;
  int nq ;
  int nr ;
  int ido ;
  int ipm ;
  int nfm1 ;
  int nl ;
  int nf ;
  int tmp ;
  double tmp___0 ;
  int tmp___1 ;
  double tmp___2 ;

  {
#line 21
  ntry = 0;
#line 21
  j = -1;
#line 25
  nl = n;
#line 26
  nf = 0;
  L101: 
#line 29
  j ++;
#line 30
  if (j < 4) {
#line 31
    ntry = ntryh___0[j];
  } else {
#line 33
    ntry += 2;
  }
  L104: 
#line 36
  nq = nl / ntry;
#line 37
  nr = nl - ntry * nq;
#line 38
  if (nr != 0) {
#line 38
    goto L101;
  }
#line 40
  nf ++;
#line 41
  *(ifac + (nf + 1)) = ntry;
#line 42
  nl = nq;
#line 43
  if (ntry != 2) {
#line 43
    goto L107;
  }
#line 44
  if (nf == 1) {
#line 44
    goto L107;
  }
#line 46
  i = 1;
  {
#line 46
  while (1) {
    while_continue: /* CIL Label */ ;
#line 46
    if (! (i < nf)) {
#line 46
      goto while_break;
    }
#line 47
    ib = (nf - i) + 1;
#line 48
    *(ifac + (ib + 1)) = *(ifac + ib);
#line 46
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 50
  *(ifac + 2) = 2;
  L107: 
#line 53
  if (nl != 1) {
#line 53
    goto L104;
  }
#line 54
  *(ifac + 0) = n;
#line 55
  *(ifac + 1) = nf;
#line 56
  argh = tpi___0 / (float )n;
#line 57
  is = 0;
#line 58
  nfm1 = nf - 1;
#line 59
  l1 = 1;
#line 61
  if (nfm1 == 0) {
#line 61
    return;
  }
#line 63
  k1 = 0;
  {
#line 63
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 63
    if (! (k1 < nfm1)) {
#line 63
      goto while_break___0;
    }
#line 64
    ip = *(ifac + (k1 + 2));
#line 65
    ld = 0;
#line 66
    l2 = l1 * ip;
#line 67
    ido = n / l2;
#line 68
    ipm = ip - 1;
#line 70
    j = 0;
    {
#line 70
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 70
      if (! (j < ipm)) {
#line 70
        goto while_break___1;
      }
#line 71
      ld += l1;
#line 72
      i = is;
#line 73
      argld = (float )ld * argh;
#line 74
      fi = (float )0.;
#line 75
      ii = 2;
      {
#line 75
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 75
        if (! (ii < ido)) {
#line 75
          goto while_break___2;
        }
        {
#line 76
        fi = (float )((double )fi + 1.);
#line 77
        arg = fi * argld;
#line 78
        tmp = i;
#line 78
        i ++;
#line 78
        tmp___0 = cos((double )arg);
#line 78
        *(wa + tmp) = (float )tmp___0;
#line 79
        tmp___1 = i;
#line 79
        i ++;
#line 79
        tmp___2 = sin((double )arg);
#line 79
        *(wa + tmp___1) = (float )tmp___2;
#line 75
        ii += 2;
        }
      }
      while_break___2: /* CIL Label */ ;
      }
#line 81
      is += ido;
#line 70
      j ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 83
    l1 = l2;
#line 63
    k1 ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 85
  return;
}
}
#line 87 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/interface/smallft.c"
static void fdrffti___0(int n , float *wsave , int *ifac ) 
{ 


  {
#line 89
  if (n == 1) {
#line 89
    return;
  }
  {
#line 90
  drfti1___0(n, wsave + n, ifac);
  }
#line 91
  return;
}
}
#line 93 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/interface/smallft.c"
static void dradf2___0(int ido , int l1 , float *cc , float *ch , float *wa1 ) 
{ 
  int i ;
  int k ;
  float ti2 ;
  float tr2 ;
  int t0 ;
  int t1 ;
  int t2 ;
  int t3 ;
  int t4 ;
  int t5 ;
  int t6 ;

  {
#line 98
  t1 = 0;
#line 99
  t2 = l1 * ido;
#line 99
  t0 = t2;
#line 100
  t3 = ido << 1;
#line 101
  k = 0;
  {
#line 101
  while (1) {
    while_continue: /* CIL Label */ ;
#line 101
    if (! (k < l1)) {
#line 101
      goto while_break;
    }
#line 102
    *(ch + (t1 << 1)) = *(cc + t1) + *(cc + t2);
#line 103
    *(ch + (((t1 << 1) + t3) - 1)) = *(cc + t1) - *(cc + t2);
#line 104
    t1 += ido;
#line 105
    t2 += ido;
#line 101
    k ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 108
  if (ido < 2) {
#line 108
    return;
  }
#line 109
  if (ido == 2) {
#line 109
    goto L105;
  }
#line 111
  t1 = 0;
#line 112
  t2 = t0;
#line 113
  k = 0;
  {
#line 113
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 113
    if (! (k < l1)) {
#line 113
      goto while_break___0;
    }
#line 114
    t3 = t2;
#line 115
    t4 = (t1 << 1) + (ido << 1);
#line 116
    t5 = t1;
#line 117
    t6 = t1 + t1;
#line 118
    i = 2;
    {
#line 118
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 118
      if (! (i < ido)) {
#line 118
        goto while_break___1;
      }
#line 119
      t3 += 2;
#line 120
      t4 -= 2;
#line 121
      t5 += 2;
#line 122
      t6 += 2;
#line 123
      tr2 = *(wa1 + (i - 2)) * *(cc + (t3 - 1)) + *(wa1 + (i - 1)) * *(cc + t3);
#line 124
      ti2 = *(wa1 + (i - 2)) * *(cc + t3) - *(wa1 + (i - 1)) * *(cc + (t3 - 1));
#line 125
      *(ch + t6) = *(cc + t5) + ti2;
#line 126
      *(ch + t4) = ti2 - *(cc + t5);
#line 127
      *(ch + (t6 - 1)) = *(cc + (t5 - 1)) + tr2;
#line 128
      *(ch + (t4 - 1)) = *(cc + (t5 - 1)) - tr2;
#line 118
      i += 2;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 130
    t1 += ido;
#line 131
    t2 += ido;
#line 113
    k ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 134
  if (ido % 2 == 1) {
#line 134
    return;
  }
  L105: 
#line 137
  t1 = ido;
#line 137
  t2 = t1 - 1;
#line 137
  t3 = t2;
#line 138
  t2 += t0;
#line 139
  k = 0;
  {
#line 139
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 139
    if (! (k < l1)) {
#line 139
      goto while_break___2;
    }
#line 140
    *(ch + t1) = - *(cc + t2);
#line 141
    *(ch + (t1 - 1)) = *(cc + t3);
#line 142
    t1 += ido << 1;
#line 143
    t2 += ido;
#line 144
    t3 += ido;
#line 139
    k ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 146
  return;
}
}
#line 150
static void dradf4___0(int ido , int l1 , float *cc , float *ch , float *wa1 , float *wa2 ,
                       float *wa3 ) ;
#line 150 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/interface/smallft.c"
static float hsqt2___0  =    (float ).70710678118654752440084436210485;
#line 148 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/interface/smallft.c"
static void dradf4___0(int ido , int l1 , float *cc , float *ch , float *wa1 , float *wa2 ,
                       float *wa3 ) 
{ 
  int i ;
  int k ;
  int t0 ;
  int t1 ;
  int t2 ;
  int t3 ;
  int t4 ;
  int t5 ;
  int t6 ;
  float ci2 ;
  float ci3 ;
  float ci4 ;
  float cr2 ;
  float cr3 ;
  float cr4 ;
  float ti1 ;
  float ti2 ;
  float ti3 ;
  float ti4 ;
  float tr1 ;
  float tr2 ;
  float tr3 ;
  float tr4 ;

  {
#line 153
  t0 = l1 * ido;
#line 155
  t1 = t0;
#line 156
  t4 = t1 << 1;
#line 157
  t2 = t1 + (t1 << 1);
#line 158
  t3 = 0;
#line 160
  k = 0;
  {
#line 160
  while (1) {
    while_continue: /* CIL Label */ ;
#line 160
    if (! (k < l1)) {
#line 160
      goto while_break;
    }
#line 161
    tr1 = *(cc + t1) + *(cc + t2);
#line 162
    tr2 = *(cc + t3) + *(cc + t4);
#line 164
    t5 = t3 << 2;
#line 164
    *(ch + t5) = tr1 + tr2;
#line 165
    *(ch + (((ido << 2) + t5) - 1)) = tr2 - tr1;
#line 166
    t5 += ido << 1;
#line 166
    *(ch + (t5 - 1)) = *(cc + t3) - *(cc + t4);
#line 167
    *(ch + t5) = *(cc + t2) - *(cc + t1);
#line 169
    t1 += ido;
#line 170
    t2 += ido;
#line 171
    t3 += ido;
#line 172
    t4 += ido;
#line 160
    k ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 175
  if (ido < 2) {
#line 175
    return;
  }
#line 176
  if (ido == 2) {
#line 176
    goto L105;
  }
#line 179
  t1 = 0;
#line 180
  k = 0;
  {
#line 180
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 180
    if (! (k < l1)) {
#line 180
      goto while_break___0;
    }
#line 181
    t2 = t1;
#line 182
    t4 = t1 << 2;
#line 183
    t6 = ido << 1;
#line 183
    t5 = t6 + t4;
#line 184
    i = 2;
    {
#line 184
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 184
      if (! (i < ido)) {
#line 184
        goto while_break___1;
      }
#line 185
      t2 += 2;
#line 185
      t3 = t2;
#line 186
      t4 += 2;
#line 187
      t5 -= 2;
#line 189
      t3 += t0;
#line 190
      cr2 = *(wa1 + (i - 2)) * *(cc + (t3 - 1)) + *(wa1 + (i - 1)) * *(cc + t3);
#line 191
      ci2 = *(wa1 + (i - 2)) * *(cc + t3) - *(wa1 + (i - 1)) * *(cc + (t3 - 1));
#line 192
      t3 += t0;
#line 193
      cr3 = *(wa2 + (i - 2)) * *(cc + (t3 - 1)) + *(wa2 + (i - 1)) * *(cc + t3);
#line 194
      ci3 = *(wa2 + (i - 2)) * *(cc + t3) - *(wa2 + (i - 1)) * *(cc + (t3 - 1));
#line 195
      t3 += t0;
#line 196
      cr4 = *(wa3 + (i - 2)) * *(cc + (t3 - 1)) + *(wa3 + (i - 1)) * *(cc + t3);
#line 197
      ci4 = *(wa3 + (i - 2)) * *(cc + t3) - *(wa3 + (i - 1)) * *(cc + (t3 - 1));
#line 199
      tr1 = cr2 + cr4;
#line 200
      tr4 = cr4 - cr2;
#line 201
      ti1 = ci2 + ci4;
#line 202
      ti4 = ci2 - ci4;
#line 204
      ti2 = *(cc + t2) + ci3;
#line 205
      ti3 = *(cc + t2) - ci3;
#line 206
      tr2 = *(cc + (t2 - 1)) + cr3;
#line 207
      tr3 = *(cc + (t2 - 1)) - cr3;
#line 209
      *(ch + (t4 - 1)) = tr1 + tr2;
#line 210
      *(ch + t4) = ti1 + ti2;
#line 212
      *(ch + (t5 - 1)) = tr3 - ti4;
#line 213
      *(ch + t5) = tr4 - ti3;
#line 215
      *(ch + ((t4 + t6) - 1)) = ti4 + tr3;
#line 216
      *(ch + (t4 + t6)) = tr4 + ti3;
#line 218
      *(ch + ((t5 + t6) - 1)) = tr2 - tr1;
#line 219
      *(ch + (t5 + t6)) = ti1 - ti2;
#line 184
      i += 2;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 221
    t1 += ido;
#line 180
    k ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 223
  if (ido & 1) {
#line 223
    return;
  }
  L105: 
#line 227
  t1 = (t0 + ido) - 1;
#line 227
  t2 = t1 + (t0 << 1);
#line 228
  t3 = ido << 2;
#line 229
  t4 = ido;
#line 230
  t5 = ido << 1;
#line 231
  t6 = ido;
#line 233
  k = 0;
  {
#line 233
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 233
    if (! (k < l1)) {
#line 233
      goto while_break___2;
    }
#line 234
    ti1 = - hsqt2___0 * (*(cc + t1) + *(cc + t2));
#line 235
    tr1 = hsqt2___0 * (*(cc + t1) - *(cc + t2));
#line 237
    *(ch + (t4 - 1)) = tr1 + *(cc + (t6 - 1));
#line 238
    *(ch + ((t4 + t5) - 1)) = *(cc + (t6 - 1)) - tr1;
#line 240
    *(ch + t4) = ti1 - *(cc + (t1 + t0));
#line 241
    *(ch + (t4 + t5)) = ti1 + *(cc + (t1 + t0));
#line 243
    t1 += ido;
#line 244
    t2 += ido;
#line 245
    t4 += t3;
#line 246
    t6 += ido;
#line 233
    k ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 248
  return;
}
}
#line 250 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/interface/smallft.c"
static void drftf1___0(int n , float *c , float *ch , float *wa , int *ifac ) 
{ 
  int i ;
  int k1 ;
  int l1 ;
  int l2 ;
  int na ;
  int kh ;
  int nf ;
  int ip ;
  int iw ;
  int ido ;
  int idl1 ;
  int ix2 ;
  int ix3 ;

  {
#line 255
  nf = *(ifac + 1);
#line 256
  na = 1;
#line 257
  l2 = n;
#line 258
  iw = n;
#line 260
  k1 = 0;
  {
#line 260
  while (1) {
    while_continue: /* CIL Label */ ;
#line 260
    if (! (k1 < nf)) {
#line 260
      goto while_break;
    }
#line 261
    kh = nf - k1;
#line 262
    ip = *(ifac + (kh + 1));
#line 263
    l1 = l2 / ip;
#line 264
    ido = n / l2;
#line 265
    idl1 = ido * l1;
#line 266
    iw -= (ip - 1) * ido;
#line 267
    na = 1 - na;
#line 269
    if (ip != 4) {
#line 269
      goto L102;
    }
#line 271
    ix2 = iw + ido;
#line 272
    ix3 = ix2 + ido;
#line 273
    if (na != 0) {
      {
#line 274
      dradf4___0(ido, l1, ch, c, (wa + iw) - 1, (wa + ix2) - 1, (wa + ix3) - 1);
      }
    } else {
      {
#line 276
      dradf4___0(ido, l1, c, ch, (wa + iw) - 1, (wa + ix2) - 1, (wa + ix3) - 1);
      }
    }
#line 277
    goto L110;
    L102: 
#line 280
    if (ip != 2) {
#line 280
      goto L104;
    }
#line 281
    if (na != 0) {
#line 281
      goto L103;
    }
    {
#line 283
    dradf2___0(ido, l1, c, ch, (wa + iw) - 1);
    }
#line 284
    goto L110;
    L103: 
    {
#line 287
    dradf2___0(ido, l1, ch, c, (wa + iw) - 1);
    }
#line 288
    goto L110;
    L104: 
#line 291
    return;
    L110: 
#line 294
    l2 = l1;
#line 260
    k1 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 297
  if (na == 1) {
#line 297
    return;
  }
#line 299
  i = 0;
  {
#line 299
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 299
    if (! (i < n)) {
#line 299
      goto while_break___0;
    }
#line 299
    *(c + i) = *(ch + i);
#line 299
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 300
  return;
}
}
#line 302 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/interface/smallft.c"
static void fdrfftf___0(int n , float *r , float *wsave , int *ifac ) 
{ 


  {
#line 303
  if (n == 1) {
#line 303
    return;
  }
  {
#line 304
  drftf1___0(n, r, wsave, wsave + n, ifac);
  }
#line 305
  return;
}
}
#line 307 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/interface/smallft.c"
static void dradb2___0(int ido , int l1 , float *cc , float *ch , float *wa1 ) 
{ 
  int i ;
  int k ;
  int t0 ;
  int t1 ;
  int t2 ;
  int t3 ;
  int t4 ;
  int t5 ;
  int t6 ;
  float ti2 ;
  float tr2 ;

  {
#line 311
  t0 = l1 * ido;
#line 313
  t1 = 0;
#line 314
  t2 = 0;
#line 315
  t3 = (ido << 1) - 1;
#line 316
  k = 0;
  {
#line 316
  while (1) {
    while_continue: /* CIL Label */ ;
#line 316
    if (! (k < l1)) {
#line 316
      goto while_break;
    }
#line 317
    *(ch + t1) = *(cc + t2) + *(cc + (t3 + t2));
#line 318
    *(ch + (t1 + t0)) = *(cc + t2) - *(cc + (t3 + t2));
#line 319
    t1 += ido;
#line 319
    t2 = t1 << 1;
#line 316
    k ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 322
  if (ido < 2) {
#line 322
    return;
  }
#line 323
  if (ido == 2) {
#line 323
    goto L105;
  }
#line 325
  t1 = 0;
#line 326
  t2 = 0;
#line 327
  k = 0;
  {
#line 327
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 327
    if (! (k < l1)) {
#line 327
      goto while_break___0;
    }
#line 328
    t3 = t1;
#line 329
    t4 = t2;
#line 329
    t5 = t4 + (ido << 1);
#line 330
    t6 = t0 + t1;
#line 331
    i = 2;
    {
#line 331
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 331
      if (! (i < ido)) {
#line 331
        goto while_break___1;
      }
#line 332
      t3 += 2;
#line 333
      t4 += 2;
#line 334
      t5 -= 2;
#line 335
      t6 += 2;
#line 336
      *(ch + (t3 - 1)) = *(cc + (t4 - 1)) + *(cc + (t5 - 1));
#line 337
      tr2 = *(cc + (t4 - 1)) - *(cc + (t5 - 1));
#line 338
      *(ch + t3) = *(cc + t4) - *(cc + t5);
#line 339
      ti2 = *(cc + t4) + *(cc + t5);
#line 340
      *(ch + (t6 - 1)) = *(wa1 + (i - 2)) * tr2 - *(wa1 + (i - 1)) * ti2;
#line 341
      *(ch + t6) = *(wa1 + (i - 2)) * ti2 + *(wa1 + (i - 1)) * tr2;
#line 331
      i += 2;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 343
    t1 += ido;
#line 343
    t2 = t1 << 1;
#line 327
    k ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 346
  if (ido % 2 == 1) {
#line 346
    return;
  }
  L105: 
#line 349
  t1 = ido - 1;
#line 350
  t2 = ido - 1;
#line 351
  k = 0;
  {
#line 351
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 351
    if (! (k < l1)) {
#line 351
      goto while_break___2;
    }
#line 352
    *(ch + t1) = *(cc + t2) + *(cc + t2);
#line 353
    *(ch + (t1 + t0)) = - (*(cc + (t2 + 1)) + *(cc + (t2 + 1)));
#line 354
    t1 += ido;
#line 355
    t2 += ido << 1;
#line 351
    k ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 357
  return;
}
}
#line 361
static void dradb4___0(int ido , int l1 , float *cc , float *ch , float *wa1 , float *wa2 ,
                       float *wa3 ) ;
#line 361 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/interface/smallft.c"
static float sqrt2___0  =    (float )1.4142135623730950488016887242097;
#line 359 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/interface/smallft.c"
static void dradb4___0(int ido , int l1 , float *cc , float *ch , float *wa1 , float *wa2 ,
                       float *wa3 ) 
{ 
  int i ;
  int k ;
  int t0 ;
  int t1 ;
  int t2 ;
  int t3 ;
  int t4 ;
  int t5 ;
  int t6 ;
  int t7 ;
  int t8 ;
  float ci2 ;
  float ci3 ;
  float ci4 ;
  float cr2 ;
  float cr3 ;
  float cr4 ;
  float ti1 ;
  float ti2 ;
  float ti3 ;
  float ti4 ;
  float tr1 ;
  float tr2 ;
  float tr3 ;
  float tr4 ;

  {
#line 364
  t0 = l1 * ido;
#line 366
  t1 = 0;
#line 367
  t2 = ido << 2;
#line 368
  t3 = 0;
#line 369
  t6 = ido << 1;
#line 370
  k = 0;
  {
#line 370
  while (1) {
    while_continue: /* CIL Label */ ;
#line 370
    if (! (k < l1)) {
#line 370
      goto while_break;
    }
#line 371
    t4 = t3 + t6;
#line 372
    t5 = t1;
#line 373
    tr3 = *(cc + (t4 - 1)) + *(cc + (t4 - 1));
#line 374
    tr4 = *(cc + t4) + *(cc + t4);
#line 375
    t4 += t6;
#line 375
    tr1 = *(cc + t3) - *(cc + (t4 - 1));
#line 376
    tr2 = *(cc + t3) + *(cc + (t4 - 1));
#line 377
    *(ch + t5) = tr2 + tr3;
#line 378
    t5 += t0;
#line 378
    *(ch + t5) = tr1 - tr4;
#line 379
    t5 += t0;
#line 379
    *(ch + t5) = tr2 - tr3;
#line 380
    t5 += t0;
#line 380
    *(ch + t5) = tr1 + tr4;
#line 381
    t1 += ido;
#line 382
    t3 += t2;
#line 370
    k ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 385
  if (ido < 2) {
#line 385
    return;
  }
#line 386
  if (ido == 2) {
#line 386
    goto L105;
  }
#line 388
  t1 = 0;
#line 389
  k = 0;
  {
#line 389
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 389
    if (! (k < l1)) {
#line 389
      goto while_break___0;
    }
#line 390
    t2 = t1 << 2;
#line 390
    t3 = t2 + t6;
#line 390
    t4 = t3;
#line 390
    t5 = t4 + t6;
#line 391
    t7 = t1;
#line 392
    i = 2;
    {
#line 392
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 392
      if (! (i < ido)) {
#line 392
        goto while_break___1;
      }
#line 393
      t2 += 2;
#line 394
      t3 += 2;
#line 395
      t4 -= 2;
#line 396
      t5 -= 2;
#line 397
      t7 += 2;
#line 398
      ti1 = *(cc + t2) + *(cc + t5);
#line 399
      ti2 = *(cc + t2) - *(cc + t5);
#line 400
      ti3 = *(cc + t3) - *(cc + t4);
#line 401
      tr4 = *(cc + t3) + *(cc + t4);
#line 402
      tr1 = *(cc + (t2 - 1)) - *(cc + (t5 - 1));
#line 403
      tr2 = *(cc + (t2 - 1)) + *(cc + (t5 - 1));
#line 404
      ti4 = *(cc + (t3 - 1)) - *(cc + (t4 - 1));
#line 405
      tr3 = *(cc + (t3 - 1)) + *(cc + (t4 - 1));
#line 406
      *(ch + (t7 - 1)) = tr2 + tr3;
#line 407
      cr3 = tr2 - tr3;
#line 408
      *(ch + t7) = ti2 + ti3;
#line 409
      ci3 = ti2 - ti3;
#line 410
      cr2 = tr1 - tr4;
#line 411
      cr4 = tr1 + tr4;
#line 412
      ci2 = ti1 + ti4;
#line 413
      ci4 = ti1 - ti4;
#line 415
      t8 = t7 + t0;
#line 415
      *(ch + (t8 - 1)) = *(wa1 + (i - 2)) * cr2 - *(wa1 + (i - 1)) * ci2;
#line 416
      *(ch + t8) = *(wa1 + (i - 2)) * ci2 + *(wa1 + (i - 1)) * cr2;
#line 417
      t8 += t0;
#line 417
      *(ch + (t8 - 1)) = *(wa2 + (i - 2)) * cr3 - *(wa2 + (i - 1)) * ci3;
#line 418
      *(ch + t8) = *(wa2 + (i - 2)) * ci3 + *(wa2 + (i - 1)) * cr3;
#line 419
      t8 += t0;
#line 419
      *(ch + (t8 - 1)) = *(wa3 + (i - 2)) * cr4 - *(wa3 + (i - 1)) * ci4;
#line 420
      *(ch + t8) = *(wa3 + (i - 2)) * ci4 + *(wa3 + (i - 1)) * cr4;
#line 392
      i += 2;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 422
    t1 += ido;
#line 389
    k ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 425
  if (ido % 2 == 1) {
#line 425
    return;
  }
  L105: 
#line 429
  t1 = ido;
#line 430
  t2 = ido << 2;
#line 431
  t3 = ido - 1;
#line 432
  t4 = ido + (ido << 1);
#line 433
  k = 0;
  {
#line 433
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 433
    if (! (k < l1)) {
#line 433
      goto while_break___2;
    }
#line 434
    t5 = t3;
#line 435
    ti1 = *(cc + t1) + *(cc + t4);
#line 436
    ti2 = *(cc + t4) - *(cc + t1);
#line 437
    tr1 = *(cc + (t1 - 1)) - *(cc + (t4 - 1));
#line 438
    tr2 = *(cc + (t1 - 1)) + *(cc + (t4 - 1));
#line 439
    *(ch + t5) = tr2 + tr2;
#line 440
    t5 += t0;
#line 440
    *(ch + t5) = sqrt2___0 * (tr1 - ti1);
#line 441
    t5 += t0;
#line 441
    *(ch + t5) = ti2 + ti2;
#line 442
    t5 += t0;
#line 442
    *(ch + t5) = - sqrt2___0 * (tr1 + ti1);
#line 444
    t3 += ido;
#line 445
    t1 += t2;
#line 446
    t4 += t2;
#line 433
    k ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 448
  return;
}
}
#line 450 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/interface/smallft.c"
static void drftb1___0(int n , float *c , float *ch , float *wa , int *ifac ) 
{ 
  int i ;
  int k1 ;
  int l1 ;
  int l2 ;
  int na ;
  int nf ;
  int ip ;
  int iw ;
  int ix2 ;
  int ix3 ;
  int ido ;
  int idl1 ;

  {
#line 455
  nf = *(ifac + 1);
#line 456
  na = 0;
#line 457
  l1 = 1;
#line 458
  iw = 1;
#line 460
  k1 = 0;
  {
#line 460
  while (1) {
    while_continue: /* CIL Label */ ;
#line 460
    if (! (k1 < nf)) {
#line 460
      goto while_break;
    }
#line 461
    ip = *(ifac + (k1 + 2));
#line 462
    l2 = ip * l1;
#line 463
    ido = n / l2;
#line 464
    idl1 = ido * l1;
#line 465
    if (ip != 4) {
#line 465
      goto L103;
    }
#line 466
    ix2 = iw + ido;
#line 467
    ix3 = ix2 + ido;
#line 469
    if (na != 0) {
      {
#line 470
      dradb4___0(ido, l1, ch, c, (wa + iw) - 1, (wa + ix2) - 1, (wa + ix3) - 1);
      }
    } else {
      {
#line 472
      dradb4___0(ido, l1, c, ch, (wa + iw) - 1, (wa + ix2) - 1, (wa + ix3) - 1);
      }
    }
#line 473
    na = 1 - na;
#line 474
    goto L115;
    L103: 
#line 477
    if (ip != 2) {
#line 477
      goto L106;
    }
#line 479
    if (na != 0) {
      {
#line 480
      dradb2___0(ido, l1, ch, c, (wa + iw) - 1);
      }
    } else {
      {
#line 482
      dradb2___0(ido, l1, c, ch, (wa + iw) - 1);
      }
    }
#line 483
    na = 1 - na;
#line 484
    goto L115;
    L106: 
#line 487
    return;
    L115: 
#line 490
    l1 = l2;
#line 491
    iw += (ip - 1) * ido;
#line 460
    k1 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 494
  if (na == 0) {
#line 494
    return;
  }
#line 496
  i = 0;
  {
#line 496
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 496
    if (! (i < n)) {
#line 496
      goto while_break___0;
    }
#line 496
    *(c + i) = *(ch + i);
#line 496
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 497
  return;
}
}
#line 499 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/interface/smallft.c"
static void fdrfftb___0(int n , float *r , float *wsave , int *ifac ) 
{ 


  {
#line 500
  if (n == 1) {
#line 500
    return;
  }
  {
#line 501
  drftb1___0(n, r, wsave, wsave + n, ifac);
  }
#line 502
  return;
}
}
#line 163 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/interface/cdda_interface.h"
static char *strerror_tr___0[12]  = 
#line 163 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/interface/cdda_interface.h"
  {      (char *)"Success",      (char *)"Error writing packet command to device",      (char *)"Error reading command from device",      (char *)"SCSI packet data underrun (too little data)", 
        (char *)"SCSI packet data overrun (too much data)",      (char *)"Illegal SCSI request (rejected by target)",      (char *)"Medium reading data from medium",      (char *)"Device busy", 
        (char *)"Device not ready",      (char *)"Target hardware fault",      (char *)"Unspecified error",      (char *)"Drive lost streaming"};
#line 104 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/interface/utils.h"
static void cderror___4(cdrom_drive *d___0 , char const   *s ) 
{ 
  size_t tmp ;

  {
#line 105
  if (s) {
#line 105
    if (d___0) {
      {
#line 107
      if (d___0->errordest == 1) {
#line 107
        goto case_1;
      }
#line 110
      if (d___0->errordest == 2) {
#line 110
        goto case_2;
      }
#line 114
      goto switch_default;
      case_1: /* CIL Label */ 
      {
#line 108
      tmp = strlen(s);
#line 108
      write(2, (void const   *)s, tmp);
      }
#line 109
      goto switch_break;
      case_2: /* CIL Label */ 
      {
#line 111
      d___0->errorbuf = catstring(d___0->errorbuf, s);
      }
#line 112
      goto switch_break;
      switch_default: /* CIL Label */ 
#line 115
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    }
  }
#line 118
  return;
}
}
#line 120 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/interface/utils.h"
static void cdmessage___2(cdrom_drive *d___0 , char const   *s ) 
{ 
  size_t tmp ;

  {
#line 121
  if (s) {
#line 121
    if (d___0) {
      {
#line 123
      if (d___0->messagedest == 1) {
#line 123
        goto case_1;
      }
#line 126
      if (d___0->messagedest == 2) {
#line 126
        goto case_2;
      }
#line 130
      goto switch_default;
      case_1: /* CIL Label */ 
      {
#line 124
      tmp = strlen(s);
#line 124
      write(2, (void const   *)s, tmp);
      }
#line 125
      goto switch_break;
      case_2: /* CIL Label */ 
      {
#line 127
      d___0->messagebuf = catstring(d___0->messagebuf, s);
      }
#line 128
      goto switch_break;
      switch_default: /* CIL Label */ 
#line 131
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    }
  }
#line 134
  return;
}
}
#line 15 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/interface/scsi_interface.c"
static int timed_ioctl___1(cdrom_drive *d___0 , int fd , int command , void *arg ) 
{ 
  struct timespec tv1 ;
  struct timespec tv2 ;
  int ret1 ;
  int tmp ;
  int ret2 ;
  int tmp___0 ;
  int ret3 ;
  int tmp___1 ;

  {
  {
#line 18
  tmp = clock_gettime((d___0->private)->clock, & tv1);
#line 18
  ret1 = tmp;
#line 19
  tmp___0 = ioctl(fd, (unsigned long )command, arg);
#line 19
  ret2 = tmp___0;
#line 20
  tmp___1 = clock_gettime((d___0->private)->clock, & tv2);
#line 20
  ret3 = tmp___1;
  }
#line 21
  if (ret1 < 0) {
#line 22
    (d___0->private)->last_milliseconds = -1;
  } else
#line 21
  if (ret3 < 0) {
#line 22
    (d___0->private)->last_milliseconds = -1;
  } else {
#line 24
    (d___0->private)->last_milliseconds = (int )((double )(tv2.tv_sec - tv1.tv_sec) * 1000. + (double )(tv2.tv_nsec - tv1.tv_nsec) / 1000000.);
  }
#line 26
  return (ret2);
}
}
#line 30 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/interface/scsi_interface.c"
static int Dummy___1(cdrom_drive *d___0 , int s ) 
{ 


  {
#line 31
  return (0);
}
}
#line 24 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/interface/drive_exceptions.h"
static exception atapi_list___1[5]  = {      {(char *)"SAMSUNG SCR-830 REV 2.09 2.09 ", 1, (unsigned char)0, & Dummy___1,
      & scsi_read_mmc2, 0}, 
        {(char *)"Memorex CR-622", 1, (unsigned char)0, & Dummy___1, (long (*)(struct cdrom_drive * ,
                                                                            void * ,
                                                                            long  ,
                                                                            long  ))((void *)0),
      0}, 
        {(char *)"SONY CD-ROM CDU-561", 0, (unsigned char)0, & Dummy___1, (long (*)(struct cdrom_drive * ,
                                                                                 void * ,
                                                                                 long  ,
                                                                                 long  ))((void *)0),
      0}, 
        {(char *)"Chinon CD-ROM CDS-525", 0, (unsigned char)0, & Dummy___1, (long (*)(struct cdrom_drive * ,
                                                                                   void * ,
                                                                                   long  ,
                                                                                   long  ))((void *)0),
      0}, 
        {(char *)((void *)0), 0, (unsigned char)0, (int (*)(struct cdrom_drive * , int  ))((void *)0),
      (long (*)(struct cdrom_drive * , void * , long  , long  ))((void *)0), 0}};
#line 33 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/interface/drive_exceptions.h"
static exception mmc_list___0[6]  = {      {(char *)"SAMSUNG SCR-830 REV 2.09 2.09 ", 1, (unsigned char)0, & Dummy___1,
      & scsi_read_mmc2, 0}, 
        {(char *)"Memorex CR-622", 1, (unsigned char)0, & Dummy___1, (long (*)(struct cdrom_drive * ,
                                                                            void * ,
                                                                            long  ,
                                                                            long  ))((void *)0),
      0}, 
        {(char *)"SONY CD-ROM CDU-561", 0, (unsigned char)0, & Dummy___1, (long (*)(struct cdrom_drive * ,
                                                                                 void * ,
                                                                                 long  ,
                                                                                 long  ))((void *)0),
      0}, 
        {(char *)"Chinon CD-ROM CDS-525", 0, (unsigned char)0, & Dummy___1, (long (*)(struct cdrom_drive * ,
                                                                                   void * ,
                                                                                   long  ,
                                                                                   long  ))((void *)0),
      0}, 
        {(char *)"KENWOOD CD-ROM UCR", -1, (unsigned char)0, (int (*)(struct cdrom_drive * ,
                                                                   int  ))((void *)0),
      & scsi_read_D8, 0}, 
        {(char *)((void *)0), 0, (unsigned char)0, (int (*)(struct cdrom_drive * , int  ))((void *)0),
      (long (*)(struct cdrom_drive * , void * , long  , long  ))((void *)0), 0}};
#line 43 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/interface/drive_exceptions.h"
static exception scsi_list___0[18]  = 
#line 43
  {      {(char *)"TOSHIBA", -1, (unsigned char)130, & scsi_enable_cdda, & scsi_read_28,
      0}, 
        {(char *)"IBM", -1, (unsigned char)130, & scsi_enable_cdda, & scsi_read_28, 0}, 
        {(char *)"DEC",
      -1, (unsigned char)130, & scsi_enable_cdda, & scsi_read_28, 0}, 
        {(char *)"IMS", -1, (unsigned char)0, & scsi_enable_cdda, & scsi_read_28, 1}, 
        {(char *)"KODAK",
      -1, (unsigned char)0, & scsi_enable_cdda, & scsi_read_28, 1}, 
        {(char *)"RICOH", -1, (unsigned char)0, & scsi_enable_cdda, & scsi_read_28, 1}, 
        {(char *)"HP",
      -1, (unsigned char)0, & scsi_enable_cdda, & scsi_read_28, 1}, 
        {(char *)"PHILIPS", -1, (unsigned char)0, & scsi_enable_cdda, & scsi_read_28,
      1}, 
        {(char *)"PLASMON", -1, (unsigned char)0, & scsi_enable_cdda, & scsi_read_28,
      1}, 
        {(char *)"GRUNDIG CDR100IPW", -1, (unsigned char)0, & scsi_enable_cdda, & scsi_read_28,
      1}, 
        {(char *)"MITSUMI CD-R ", -1, (unsigned char)0, & scsi_enable_cdda, & scsi_read_28,
      1}, 
        {(char *)"KENWOOD CD-ROM UCR", -1, (unsigned char)0, (int (*)(struct cdrom_drive * ,
                                                                   int  ))((void *)0),
      & scsi_read_D8, 0}, 
        {(char *)"YAMAHA", -1, (unsigned char)0, & scsi_enable_cdda, (long (*)(struct cdrom_drive * ,
                                                                            void * ,
                                                                            long  ,
                                                                            long  ))((void *)0),
      0}, 
        {(char *)"PLEXTOR", -1, (unsigned char)0, (int (*)(struct cdrom_drive * , int  ))((void *)0),
      (long (*)(struct cdrom_drive * , void * , long  , long  ))((void *)0), 0}, 
        {(char *)"SONY", -1, (unsigned char)0, (int (*)(struct cdrom_drive * , int  ))((void *)0),
      (long (*)(struct cdrom_drive * , void * , long  , long  ))((void *)0), 0}, 
        {(char *)"NEC", -1, (unsigned char)0, (int (*)(struct cdrom_drive * , int  ))((void *)0),
      & scsi_read_D4_10, 0}, 
        {(char *)"MATSHITA CD-R   CW-7501", -1, (unsigned char)0, (int (*)(struct cdrom_drive * ,
                                                                        int  ))((void *)0),
      & scsi_read_D4_12, -1}, 
        {(char *)((void *)0), 0, (unsigned char)0, (int (*)(struct cdrom_drive * , int  ))((void *)0),
      (long (*)(struct cdrom_drive * , void * , long  , long  ))((void *)0), 0}};
#line 35 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/interface/scsi_interface.c"
static void tweak_SG_buffer___0(cdrom_drive *d___0 ) 
{ 
  int table ;
  int reserved ;
  int cur ;
  int err ;
  char buffer[256] ;
  int tmp ;
  char *tmp___0 ;
  void *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;

  {
#line 46
  cur = 1;
  {
#line 47
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 48
    cur <<= 1;
#line 48
    reserved = cur * (1 << 9);
#line 49
    err = ioctl(d___0->cdda_fd, 8821UL, & reserved);
    }
#line 47
    if (err >= 0) {
#line 47
      if (! (cur * (1 << 9) < 1073741824)) {
#line 47
        goto while_break;
      }
    } else {
#line 47
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 51
  ioctl(d___0->cdda_fd, 8818UL, & reserved);
#line 55
  tmp = ioctl(d___0->cdda_fd, 8831UL, & table);
  }
#line 55
  if (tmp < 0) {
#line 56
    table = 1;
  }
  {
#line 58
  sprintf((char */* __restrict  */)(buffer), (char const   */* __restrict  */)"\tDMA scatter/gather table entries: %d\n\ttable entry size: %d bytes\n\tmaximum theoretical transfer: %d sectors\n",
          table, reserved, table * (reserved / 2352));
#line 62
  cdmessage___2(d___0, (char const   *)(buffer));
#line 64
  cur = reserved;
#line 78
  tmp___0 = getenv("CDDA_IGNORE_BUFSIZE_LIMIT");
  }
#line 78
  if (tmp___0) {
    {
#line 81
    cdmessage___2(d___0, "\tEnvironment variable CDDA_IGNORE_BUFSIZE_LIMIT set,\n\t\tforcing maximum possible sector size.  This can break\n\t\tspectacularly; use with caution!\n");
    }
  } else
#line 79
  if (cur > 65536) {
#line 79
    cur = 65536;
  } else {
#line 79
    cur = cur;
  }
  {
#line 85
  d___0->nsectors = cur / 2352;
#line 86
  d___0->bigbuff = (long )cur;
#line 88
  sprintf((char */* __restrict  */)(buffer), (char const   */* __restrict  */)"\tSetting default read size to %d sectors (%d bytes).\n\n",
          d___0->nsectors, d___0->nsectors * 2352);
  }
#line 91
  if (cur == 0) {
    {
#line 91
    exit(1);
    }
  }
  {
#line 93
  cdmessage___2(d___0, (char const   *)(buffer));
  }
#line 94
  return;
}
}
#line 96 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/interface/scsi_interface.c"
static void clear_garbage___0(cdrom_drive *d___0 ) 
{ 
  fd_set fdset ;
  struct timeval tv ;
  struct sg_header *sg_hd ;
  int flag ;
  int __d0 ;
  int __d1 ;
  int __d0___0 ;
  int __d1___0 ;
  int tmp ;
  char *__cil_tmp11 ;

  {
#line 99
  sg_hd = (d___0->private)->sg_hd;
#line 100
  flag = 0;
  {
#line 103
  while (1) {
    while_continue: /* CIL Label */ ;
#line 103
    __asm__  volatile   ("cld; rep; "
                         "stosl": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                         "1" (& fdset.__fds_bits[0]): "memory");
#line 103
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 104
  fdset.__fds_bits[(unsigned long )d___0->cdda_fd / (8UL * sizeof(unsigned long ))] = (__fd_mask )((unsigned long )fdset.__fds_bits[(unsigned long )d___0->cdda_fd / (8UL * sizeof(unsigned long ))] | (1UL << (unsigned long )d___0->cdda_fd % (8UL * sizeof(unsigned long ))));
#line 105
  tv.tv_sec = (__time_t )0;
#line 106
  tv.tv_usec = (__suseconds_t )0;
  {
#line 109
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 109
    tmp = select(d___0->cdda_fd + 1, (fd_set */* __restrict  */)(& fdset), (fd_set */* __restrict  */)((void *)0),
                 (fd_set */* __restrict  */)((void *)0), (struct timeval */* __restrict  */)(& tv));
    }
#line 109
    if (! (tmp == 1)) {
#line 109
      goto while_break___0;
    }
    {
#line 111
    sg_hd->twelve_byte = 0U;
#line 112
    sg_hd->result = 0;
#line 113
    sg_hd->reply_len = (int )sizeof(struct sg_header );
#line 114
    read(d___0->cdda_fd, (void *)sg_hd, (size_t )1);
    }
    {
#line 117
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 117
      __asm__  volatile   ("cld; rep; "
                           "stosl": "=c" (__d0___0), "=D" (__d1___0): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                           "1" (& fdset.__fds_bits[0]): "memory");
#line 117
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 118
    fdset.__fds_bits[(unsigned long )d___0->cdda_fd / (8UL * sizeof(unsigned long ))] = (__fd_mask )((unsigned long )fdset.__fds_bits[(unsigned long )d___0->cdda_fd / (8UL * sizeof(unsigned long ))] | (1UL << (unsigned long )d___0->cdda_fd % (8UL * sizeof(unsigned long ))));
#line 119
    tv.tv_sec = (__time_t )0;
#line 120
    tv.tv_usec = (__suseconds_t )0;
#line 121
    if (! flag) {
#line 121
      if (d___0->report_all) {
        {
#line 122
        cdmessage___2(d___0, "Clearing previously returned data from SCSI buffer\n");
        }
      }
    }
#line 123
    flag = 1;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 125
  return;
}
}
#line 127 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/interface/scsi_interface.c"
static int check_sbp_error___0(unsigned char const   status , unsigned char const   *sbp ) 
{ 
  char key ;
  char ASC ;
  char ASCQ ;
  int *tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;
  int *tmp___4 ;
  int *tmp___5 ;
  int *tmp___6 ;
  int *tmp___7 ;
  int *tmp___8 ;
  int *tmp___9 ;
  int *tmp___10 ;
  int *tmp___11 ;

  {
#line 129
  key = (char )((int const   )*(sbp + 2) & 15);
#line 130
  ASC = (char )*(sbp + 12);
#line 131
  ASCQ = (char )*(sbp + 13);
#line 133
  if ((int const   )status == 0) {
#line 133
    return (0);
  }
#line 134
  if ((int const   )status == 8) {
#line 134
    return (7);
  }
#line 136
  if (*(sbp + 0)) {
    {
#line 138
    if ((int )key == 0) {
#line 138
      goto case_0;
    }
#line 142
    if ((int )key == 1) {
#line 142
      goto case_1;
    }
#line 144
    if ((int )key == 2) {
#line 144
      goto case_2;
    }
#line 147
    if ((int )key == 3) {
#line 147
      goto case_3;
    }
#line 158
    if ((int )key == 4) {
#line 158
      goto case_4;
    }
#line 162
    if ((int )key == 5) {
#line 162
      goto case_5;
    }
#line 166
    goto switch_default;
    case_0: /* CIL Label */ 
    {
#line 139
    tmp___0 = __errno_location();
    }
#line 139
    if (*tmp___0 == 0) {
      {
#line 140
      tmp = __errno_location();
#line 140
      *tmp = 5;
      }
    }
#line 141
    return (10);
    case_1: /* CIL Label */ 
#line 143
    goto switch_break;
    case_2: /* CIL Label */ 
    {
#line 145
    tmp___1 = __errno_location();
#line 145
    *tmp___1 = 123;
    }
#line 146
    return (8);
    case_3: /* CIL Label */ 
#line 148
    if (((int )ASC == 12) & ((int )ASCQ == 9)) {
      {
#line 150
      tmp___3 = __errno_location();
      }
#line 150
      if (*tmp___3 == 0) {
        {
#line 151
        tmp___2 = __errno_location();
#line 151
        *tmp___2 = 5;
        }
      }
#line 152
      return (11);
    } else {
      {
#line 154
      tmp___5 = __errno_location();
      }
#line 154
      if (*tmp___5 == 0) {
        {
#line 155
        tmp___4 = __errno_location();
#line 155
        *tmp___4 = 5;
        }
      }
#line 156
      return (6);
    }
    case_4: /* CIL Label */ 
    {
#line 159
    tmp___7 = __errno_location();
    }
#line 159
    if (*tmp___7 == 0) {
      {
#line 160
      tmp___6 = __errno_location();
#line 160
      *tmp___6 = 5;
      }
    }
#line 161
    return (9);
    case_5: /* CIL Label */ 
    {
#line 163
    tmp___9 = __errno_location();
    }
#line 163
    if (*tmp___9 == 0) {
      {
#line 164
      tmp___8 = __errno_location();
#line 164
      *tmp___8 = 22;
      }
    }
#line 165
    return (5);
    switch_default: /* CIL Label */ 
    {
#line 167
    tmp___11 = __errno_location();
    }
#line 167
    if (*tmp___11 == 0) {
      {
#line 168
      tmp___10 = __errno_location();
#line 168
      *tmp___10 = 5;
      }
    }
#line 169
    return (10);
    switch_break: /* CIL Label */ ;
    }
  }
#line 172
  return (0);
}
}
#line 176 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/interface/scsi_interface.c"
static int sg2_handle_scsi_cmd___0(cdrom_drive *d___0 , unsigned char *cmd , unsigned int cmd_len ,
                                   unsigned int in_size , unsigned int out_size ,
                                   unsigned char bytefill , int bytecheck , unsigned char *sense_buffer ) 
{ 
  struct timespec tv1 ;
  struct timespec tv2 ;
  int tret1 ;
  int tret2 ;
  int status ;
  struct sg_header *sg_hd ;
  long writebytes ;
  fd_set fdset ;
  struct timeval tv ;
  int __d0 ;
  int __d1 ;
  int ret ;
  int tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;
  fd_set rset ;
  struct timeval tv___0 ;
  int __d0___0 ;
  int __d1___0 ;
  int ret___0 ;
  int tmp___4 ;
  int *tmp___5 ;
  int *tmp___6 ;
  int *tmp___7 ;
  int *tmp___8 ;
  long i ;
  long flag ;
  int *tmp___9 ;
  int *tmp___10 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;

  {
  {
#line 187
  status = 0;
#line 188
  sg_hd = (d___0->private)->sg_hd;
#line 189
  writebytes = (long )((sizeof(struct sg_header ) + (unsigned long )cmd_len) + (unsigned long )in_size);
#line 194
  clear_garbage___0(d___0);
#line 196
  memset((void *)sg_hd, 0, (size_t )sizeof(sg_hd));
#line 197
  memset((void *)sense_buffer, 0, (size_t )16);
#line 198
  memcpy((void */* __restrict  */)(d___0->private)->sg_buffer, (void const   */* __restrict  */)cmd,
         cmd_len + in_size);
#line 199
  sg_hd->twelve_byte = (unsigned int )(cmd_len == 12U);
#line 200
  sg_hd->result = 0;
#line 201
  sg_hd->reply_len = (int )(sizeof(struct sg_header ) + (unsigned long )out_size);
  }
#line 211
  if (bytecheck) {
#line 211
    if (out_size > in_size) {
      {
#line 212
      memset((void *)(((d___0->private)->sg_buffer + cmd_len) + in_size), (int )bytefill,
             out_size - in_size);
#line 215
      writebytes += (long )(out_size - in_size);
      }
    }
  }
  {
#line 226
  while (1) {
    while_continue: /* CIL Label */ ;
#line 226
    __asm__  volatile   ("cld; rep; "
                         "stosl": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                         "1" (& fdset.__fds_bits[0]): "memory");
#line 226
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 227
  fdset.__fds_bits[(unsigned long )d___0->cdda_fd / (8UL * sizeof(unsigned long ))] = (__fd_mask )((unsigned long )fdset.__fds_bits[(unsigned long )d___0->cdda_fd / (8UL * sizeof(unsigned long ))] | (1UL << (unsigned long )d___0->cdda_fd % (8UL * sizeof(unsigned long ))));
#line 228
  tv.tv_sec = (__time_t )60;
#line 231
  tv.tv_usec = (__suseconds_t )0;
  {
#line 233
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 234
    tmp = select(d___0->cdda_fd + 1, (fd_set */* __restrict  */)((void *)0), (fd_set */* __restrict  */)(& fdset),
                 (fd_set */* __restrict  */)((void *)0), (struct timeval */* __restrict  */)(& tv));
#line 234
    ret = tmp;
    }
#line 235
    if (ret > 0) {
#line 235
      goto while_break___0;
    }
#line 236
    if (ret < 0) {
      {
#line 236
      tmp___0 = __errno_location();
      }
#line 236
      if (*tmp___0 != 4) {
#line 236
        goto while_break___0;
      }
    }
#line 237
    if (ret == 0) {
      {
#line 238
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\nSCSI transport error: timeout waiting to write packet\n\n");
      }
#line 240
      return (1);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 245
  sigprocmask(0, (sigset_t const   */* __restrict  */)(& d___0->sigset), (sigset_t */* __restrict  */)((void *)0));
#line 246
  tret1 = clock_gettime((d___0->private)->clock, & tv1);
#line 247
  tmp___1 = __errno_location();
#line 247
  *tmp___1 = 0;
#line 248
  status = write(d___0->cdda_fd, (void const   *)sg_hd, (size_t )writebytes);
  }
#line 250
  if (status < 0) {
#line 250
    goto _L;
  } else
#line 250
  if ((long )status != writebytes) {
    _L: /* CIL Label */ 
    {
#line 251
    sigprocmask(1, (sigset_t const   */* __restrict  */)(& d___0->sigset), (sigset_t */* __restrict  */)((void *)0));
#line 252
    tmp___3 = __errno_location();
    }
#line 252
    if (*tmp___3 == 0) {
      {
#line 252
      tmp___2 = __errno_location();
#line 252
      *tmp___2 = 5;
      }
    }
#line 253
    return (1);
  }
  {
#line 266
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 266
    __asm__  volatile   ("cld; rep; "
                         "stosl": "=c" (__d0___0), "=D" (__d1___0): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                         "1" (& rset.__fds_bits[0]): "memory");
#line 266
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 267
  rset.__fds_bits[(unsigned long )d___0->cdda_fd / (8UL * sizeof(unsigned long ))] = (__fd_mask )((unsigned long )rset.__fds_bits[(unsigned long )d___0->cdda_fd / (8UL * sizeof(unsigned long ))] | (1UL << (unsigned long )d___0->cdda_fd % (8UL * sizeof(unsigned long ))));
#line 268
  tv___0.tv_sec = (__time_t )60;
#line 271
  tv___0.tv_usec = (__suseconds_t )0;
  {
#line 273
  while (1) {
    while_continue___2: /* CIL Label */ ;
    {
#line 274
    tmp___4 = select(d___0->cdda_fd + 1, (fd_set */* __restrict  */)(& rset), (fd_set */* __restrict  */)((void *)0),
                     (fd_set */* __restrict  */)((void *)0), (struct timeval */* __restrict  */)(& tv___0));
#line 274
    ret___0 = tmp___4;
    }
#line 275
    if (ret___0 < 0) {
      {
#line 275
      tmp___5 = __errno_location();
      }
#line 275
      if (*tmp___5 != 4) {
#line 275
        goto while_break___2;
      }
    }
#line 276
    if (ret___0 == 0) {
      {
#line 277
      sigprocmask(1, (sigset_t const   */* __restrict  */)(& d___0->sigset), (sigset_t */* __restrict  */)((void *)0));
#line 278
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\nSCSI transport error: timeout waiting to read packet\n\n");
      }
#line 280
      return (2);
    }
#line 282
    if (ret___0 > 0) {
#line 284
      if (((unsigned long )rset.__fds_bits[(unsigned long )d___0->cdda_fd / (8UL * sizeof(unsigned long ))] & (1UL << (unsigned long )d___0->cdda_fd % (8UL * sizeof(unsigned long )))) != 0UL) {
#line 284
        goto while_break___2;
      }
      {
#line 285
      sigprocmask(1, (sigset_t const   */* __restrict  */)(& d___0->sigset), (sigset_t */* __restrict  */)((void *)0));
#line 286
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\nSCSI transport: error reading packet\n\n");
      }
#line 287
      return (2);
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 292
  tret2 = clock_gettime((d___0->private)->clock, & tv2);
#line 293
  tmp___6 = __errno_location();
#line 293
  *tmp___6 = 0;
#line 294
  status = read(d___0->cdda_fd, (void *)sg_hd, (size_t )(sizeof(struct sg_header ) + (unsigned long )out_size));
#line 295
  sigprocmask(1, (sigset_t const   */* __restrict  */)(& d___0->sigset), (sigset_t */* __restrict  */)((void *)0));
#line 296
  memcpy((void */* __restrict  */)sense_buffer, (void const   */* __restrict  */)(sg_hd->sense_buffer),
         (size_t )16);
  }
#line 298
  if (status < 0) {
#line 298
    return (status);
  }
#line 300
  if ((unsigned long )status != sizeof(struct sg_header ) + (unsigned long )out_size) {
#line 300
    goto _L___0;
  } else
#line 300
  if (sg_hd->result) {
    _L___0: /* CIL Label */ 
    {
#line 301
    tmp___8 = __errno_location();
    }
#line 301
    if (*tmp___8 == 0) {
      {
#line 301
      tmp___7 = __errno_location();
#line 301
      *tmp___7 = 5;
      }
    }
#line 302
    return (2);
  }
  {
#line 305
  status = check_sbp_error___0((unsigned char const   )sg_hd->target_status, (unsigned char const   *)sense_buffer);
  }
#line 306
  if (status) {
#line 306
    return (status);
  }
#line 313
  if (bytecheck) {
#line 313
    if (in_size + cmd_len < out_size) {
#line 314
      flag = 0L;
#line 315
      i = (long )in_size;
      {
#line 315
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 315
        if (! (i < (long )out_size)) {
#line 315
          goto while_break___3;
        }
#line 316
        if ((int )*((d___0->private)->sg_buffer + i) != (int )bytefill) {
#line 317
          flag = 1L;
#line 318
          goto while_break___3;
        }
#line 315
        i ++;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 321
      if (! flag) {
        {
#line 322
        tmp___9 = __errno_location();
#line 322
        *tmp___9 = 22;
        }
#line 323
        return (5);
      }
    }
  }
  {
#line 327
  tmp___10 = __errno_location();
#line 327
  *tmp___10 = 0;
  }
#line 328
  if (tret1 < 0) {
#line 329
    (d___0->private)->last_milliseconds = -1;
  } else
#line 328
  if (tret2 < 0) {
#line 329
    (d___0->private)->last_milliseconds = -1;
  } else {
#line 331
    (d___0->private)->last_milliseconds = (int )((tv2.tv_sec - tv1.tv_sec) * 1000L + (tv2.tv_nsec - tv1.tv_nsec) / 1000000L);
  }
#line 333
  return (0);
}
}
#line 336 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/interface/scsi_interface.c"
static int sgio_handle_scsi_cmd___0(cdrom_drive *d___0 , unsigned char *cmd , unsigned int cmd_len ,
                                    unsigned int in_size , unsigned int out_size ,
                                    unsigned char bytefill , int bytecheck , unsigned char *sense ) 
{ 
  int status ;
  struct sg_io_hdr hdr ;
  int *tmp ;
  int *tmp___0 ;
  long i ;
  long flag ;
  int *tmp___1 ;
  int *tmp___2 ;

  {
  {
#line 345
  status = 0;
#line 348
  memset((void *)(& hdr), 0, (size_t )sizeof(hdr));
#line 349
  memset((void *)sense, 0, (size_t )sizeof(sense));
#line 350
  memcpy((void */* __restrict  */)(d___0->private)->sg_buffer, (void const   */* __restrict  */)(cmd + cmd_len),
         in_size);
#line 352
  hdr.cmdp = cmd;
#line 353
  hdr.cmd_len = (unsigned char )cmd_len;
#line 354
  hdr.sbp = sense;
#line 355
  hdr.mx_sb_len = (unsigned char)16;
#line 356
  hdr.timeout = 50000U;
#line 357
  hdr.interface_id = 'S';
#line 358
  hdr.dxferp = (void *)(d___0->private)->sg_buffer;
#line 359
  hdr.flags = 1U;
  }
#line 362
  if (bytecheck) {
#line 362
    if (out_size > in_size) {
      {
#line 363
      memset(hdr.dxferp + in_size, (int )bytefill, out_size - in_size);
      }
    }
  }
#line 365
  if (in_size) {
    {
#line 366
    hdr.dxfer_len = in_size;
#line 367
    hdr.dxfer_direction = -2;
#line 369
    tmp = __errno_location();
#line 369
    *tmp = 0;
#line 370
    status = ioctl(d___0->ioctl_fd, 8837UL, & hdr);
    }
#line 371
    if (status >= 0) {
#line 371
      if (hdr.status) {
        {
#line 372
        status = check_sbp_error___0((unsigned char const   )hdr.status, (unsigned char const   *)hdr.sbp);
        }
#line 373
        if (status) {
#line 373
          return (status);
        }
      }
    }
#line 375
    if (status < 0) {
#line 375
      return (1);
    }
  }
#line 378
  if ((unsigned int )(! in_size) | out_size) {
#line 379
    hdr.dxfer_len = out_size;
#line 381
    if (bytecheck) {
#line 381
      if (d___0->interface != 4) {
#line 382
        if (out_size) {
#line 382
          hdr.dxfer_direction = -4;
        } else {
#line 382
          hdr.dxfer_direction = -1;
        }
      } else {
#line 381
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 384
    if (out_size) {
#line 384
      hdr.dxfer_direction = -3;
    } else {
#line 384
      hdr.dxfer_direction = -1;
    }
    {
#line 386
    tmp___0 = __errno_location();
#line 386
    *tmp___0 = 0;
#line 387
    status = timed_ioctl___1(d___0, d___0->ioctl_fd, 8837, (void *)(& hdr));
    }
#line 388
    if (status >= 0) {
#line 388
      if (hdr.status) {
        {
#line 389
        status = check_sbp_error___0((unsigned char const   )hdr.status, (unsigned char const   *)hdr.sbp);
        }
#line 390
        if (status) {
#line 390
          return (status);
        }
      }
    }
#line 392
    if (status < 0) {
#line 392
      return (status);
    }
  }
#line 400
  if (bytecheck) {
#line 400
    if (in_size < out_size) {
#line 401
      flag = 0L;
#line 402
      i = (long )in_size;
      {
#line 402
      while (1) {
        while_continue: /* CIL Label */ ;
#line 402
        if (! (i < (long )out_size)) {
#line 402
          goto while_break;
        }
#line 403
        if ((int )*((d___0->private)->sg_buffer + i) != (int )bytefill) {
#line 404
          flag = 1L;
#line 405
          goto while_break;
        }
#line 402
        i ++;
      }
      while_break: /* CIL Label */ ;
      }
#line 408
      if (! flag) {
        {
#line 409
        tmp___1 = __errno_location();
#line 409
        *tmp___1 = 22;
        }
#line 410
        return (5);
      }
    }
  }
  {
#line 417
  tmp___2 = __errno_location();
#line 417
  *tmp___2 = 0;
  }
#line 418
  return (0);
}
}
#line 421 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/interface/scsi_interface.c"
static int handle_scsi_cmd___0(cdrom_drive *d___0 , unsigned char *cmd , unsigned int cmd_len ,
                               unsigned int in_size , unsigned int out_size , unsigned char bytefill ,
                               int bytecheck , unsigned char *sense ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 430
  if (d___0->interface == 3) {
    {
#line 431
    tmp = sgio_handle_scsi_cmd___0(d___0, cmd, cmd_len, in_size, out_size, bytefill,
                                   bytecheck, sense);
    }
#line 431
    return (tmp);
  } else
#line 430
  if (d___0->interface == 4) {
    {
#line 431
    tmp = sgio_handle_scsi_cmd___0(d___0, cmd, cmd_len, in_size, out_size, bytefill,
                                   bytecheck, sense);
    }
#line 431
    return (tmp);
  }
  {
#line 432
  tmp___0 = sg2_handle_scsi_cmd___0(d___0, cmd, cmd_len, in_size, out_size, bytefill,
                                    bytecheck, sense);
  }
#line 432
  return (tmp___0);
}
}
#line 436 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/interface/scsi_interface.c"
static int test_unit_ready___0(cdrom_drive *d___0 ) 
{ 
  unsigned char sense[16] ;
  unsigned char key ;
  unsigned char ASC ;
  unsigned char ASCQ ;
  unsigned char cmd[6] ;
  void *__cil_tmp7 ;
  void *__cil_tmp8 ;

  {
  {
#line 439
  cmd[0] = (unsigned char)0;
#line 439
  cmd[1] = (unsigned char)0;
#line 439
  cmd[2] = (unsigned char)0;
#line 439
  cmd[3] = (unsigned char)0;
#line 439
  cmd[4] = (unsigned char)0;
#line 439
  cmd[5] = (unsigned char)0;
#line 446
  handle_scsi_cmd___0(d___0, cmd, 6U, 0U, 56U, (unsigned char)0, 0, sense);
#line 448
  key = (unsigned char )((int )*((d___0->private)->sg_buffer + 2) & 15);
#line 449
  ASC = *((d___0->private)->sg_buffer + 12);
#line 450
  ASCQ = *((d___0->private)->sg_buffer + 13);
  }
#line 452
  if ((int )key == 2) {
#line 452
    if ((int )ASC == 4) {
#line 452
      if ((int )ASCQ == 1) {
#line 452
        return (0);
      }
    }
  }
#line 453
  return (1);
}
}
#line 456 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/interface/scsi_interface.c"
static void reset_scsi___0(cdrom_drive *d___0 ) 
{ 
  int arg ;
  int tries ;
  int tmp ;
  int tmp___0 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
  {
#line 457
  tries = 0;
#line 458
  (*(d___0->enable_cdda))(d___0, 0);
#line 460
  cdmessage___2(d___0, "sending SG SCSI reset... ");
#line 461
  tmp = ioctl(d___0->cdda_fd, 8836UL, & arg);
  }
#line 461
  if (tmp) {
    {
#line 462
    cdmessage___2(d___0, "FAILED: EBUSY\n");
    }
  } else {
    {
#line 464
    cdmessage___2(d___0, "OK\n");
    }
  }
  {
#line 466
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 467
    tmp___0 = test_unit_ready___0(d___0);
    }
#line 467
    if (tmp___0) {
#line 467
      goto while_break;
    }
    {
#line 468
    tries ++;
#line 469
    usleep((__useconds_t )10);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 472
  (*(d___0->enable_cdda))(d___0, 1);
  }
#line 473
  return;
}
}
#line 475 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/interface/scsi_interface.c"
static int mode_sense_atapi___0(cdrom_drive *d___0 , int size , int page ) 
{ 
  unsigned char sense[16] ;
  unsigned char cmd[10] ;
  int tmp ;
  unsigned char *b ;
  void *__cil_tmp8 ;
  void *__cil_tmp9 ;

  {
  {
#line 477
  cmd[0] = (unsigned char)90;
#line 477
  cmd[1] = (unsigned char)0;
#line 477
  cmd[2] = (unsigned char)0;
#line 477
  cmd[3] = (unsigned char)0;
#line 477
  cmd[4] = (unsigned char)0;
#line 477
  cmd[5] = (unsigned char)0;
#line 477
  cmd[6] = (unsigned char)0;
#line 477
  cmd[7] = (unsigned char)0;
#line 477
  cmd[8] = (unsigned char)0;
#line 477
  cmd[9] = (unsigned char)0;
#line 488
  cmd[1] = (unsigned char )(d___0->lun << 5);
#line 489
  cmd[2] = (unsigned char )(63 & page);
#line 490
  cmd[8] = (unsigned char )(size + 4);
#line 492
  tmp = handle_scsi_cmd___0(d___0, cmd, 10U, 0U, (unsigned int )(size + 4), (unsigned char )'\377',
                            1, sense);
  }
#line 492
  if (tmp) {
#line 492
    return (1);
  }
#line 495
  b = (d___0->private)->sg_buffer;
#line 496
  if (*(b + 0)) {
#line 496
    return (1);
  }
#line 497
  if (*(b + 6)) {
#line 497
    return (1);
  }
  {
#line 499
  *(b + 0) = (unsigned char )((int )*(b + 1) - 3);
#line 500
  *(b + 1) = *(b + 2);
#line 501
  *(b + 2) = *(b + 3);
#line 502
  *(b + 3) = *(b + 7);
#line 504
  memmove((void *)(b + 4), (void const   *)(b + 8), (size_t )(size - 4));
  }
#line 506
  return (0);
}
}
#line 511 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/interface/scsi_interface.c"
static int mode_sense_scsi___0(cdrom_drive *d___0 , int size , int page ) 
{ 
  unsigned char sense[16] ;
  unsigned char cmd[6] ;
  int tmp ;
  void *__cil_tmp7 ;
  void *__cil_tmp8 ;

  {
  {
#line 513
  cmd[0] = (unsigned char)26;
#line 513
  cmd[1] = (unsigned char)0;
#line 513
  cmd[2] = (unsigned char)0;
#line 513
  cmd[3] = (unsigned char)0;
#line 513
  cmd[4] = (unsigned char)0;
#line 513
  cmd[5] = (unsigned char)0;
#line 520
  cmd[1] = (unsigned char )(d___0->lun << 5);
#line 521
  cmd[2] = (unsigned char )(63 & page);
#line 522
  cmd[4] = (unsigned char )size;
#line 524
  tmp = handle_scsi_cmd___0(d___0, cmd, 6U, 0U, (unsigned int )size, (unsigned char )'\377',
                            1, sense);
  }
#line 524
  if (tmp) {
#line 524
    return (1);
  }
#line 529
  return (0);
}
}
#line 532 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/interface/scsi_interface.c"
static int mode_sense___0(cdrom_drive *d___0 , int size , int page ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 533
  if (d___0->is_atapi) {
    {
#line 534
    tmp = mode_sense_atapi___0(d___0, size, page);
    }
#line 534
    return (tmp);
  }
  {
#line 535
  tmp___0 = mode_sense_scsi___0(d___0, size, page);
  }
#line 535
  return (tmp___0);
}
}
#line 542 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/interface/scsi_interface.c"
static int mode_select___0(cdrom_drive *d___0 , int density , int secsize ) 
{ 
  unsigned char sense[16] ;
  unsigned char cmd[26] ;
  unsigned char *mode ;
  int tmp ;
  unsigned char cmd___0[18] ;
  unsigned char *mode___0 ;
  int tmp___0 ;
  void *__cil_tmp11 ;
  void *__cil_tmp12 ;
  void *__cil_tmp13 ;

  {
#line 545
  if (d___0->is_atapi) {
    {
#line 546
    cmd[0] = (unsigned char)85;
#line 546
    cmd[1] = (unsigned char)16;
#line 546
    cmd[2] = (unsigned char)0;
#line 546
    cmd[3] = (unsigned char)0;
#line 546
    cmd[4] = (unsigned char)0;
#line 546
    cmd[5] = (unsigned char)0;
#line 546
    cmd[6] = (unsigned char)0;
#line 546
    cmd[7] = (unsigned char)0;
#line 546
    cmd[8] = (unsigned char)16;
#line 546
    cmd[9] = (unsigned char)0;
#line 546
    cmd[10] = (unsigned char)0;
#line 546
    cmd[11] = (unsigned char)0;
#line 546
    cmd[12] = (unsigned char)0;
#line 546
    cmd[13] = (unsigned char)0;
#line 546
    cmd[14] = (unsigned char)0;
#line 546
    cmd[15] = (unsigned char)0;
#line 546
    cmd[16] = (unsigned char)0;
#line 546
    cmd[17] = (unsigned char)8;
#line 546
    cmd[18] = (unsigned char)0;
#line 546
    cmd[19] = (unsigned char)0;
#line 546
    cmd[20] = (unsigned char)0;
#line 546
    cmd[21] = (unsigned char)0;
#line 546
    cmd[22] = (unsigned char)0;
#line 546
    cmd[23] = (unsigned char)0;
#line 546
    cmd[24] = (unsigned char)0;
#line 546
    cmd[25] = (unsigned char)0;
#line 566
    mode = cmd + 18;
#line 569
    *(mode + 0) = (unsigned char )density;
#line 570
    *(mode + 6) = (unsigned char )(secsize >> 8);
#line 571
    *(mode + 7) = (unsigned char )(secsize & 255);
#line 574
    tmp = handle_scsi_cmd___0(d___0, cmd, 10U, 16U, 0U, (unsigned char)0, 0, sense);
    }
#line 574
    return (tmp);
  } else {
    {
#line 577
    cmd___0[0] = (unsigned char)21;
#line 577
    cmd___0[1] = (unsigned char)16;
#line 577
    cmd___0[2] = (unsigned char)0;
#line 577
    cmd___0[3] = (unsigned char)0;
#line 577
    cmd___0[4] = (unsigned char)12;
#line 577
    cmd___0[5] = (unsigned char)0;
#line 577
    cmd___0[6] = (unsigned char)0;
#line 577
    cmd___0[7] = (unsigned char)0;
#line 577
    cmd___0[8] = (unsigned char)0;
#line 577
    cmd___0[9] = (unsigned char)8;
#line 577
    cmd___0[10] = (unsigned char)0;
#line 577
    cmd___0[11] = (unsigned char)0;
#line 577
    cmd___0[12] = (unsigned char)0;
#line 577
    cmd___0[13] = (unsigned char)0;
#line 577
    cmd___0[14] = (unsigned char)0;
#line 577
    cmd___0[15] = (unsigned char)0;
#line 577
    cmd___0[16] = (unsigned char)0;
#line 577
    cmd___0[17] = (unsigned char)0;
#line 591
    mode___0 = cmd___0 + 10;
#line 594
    *(mode___0 + 0) = (unsigned char )density;
#line 595
    *(mode___0 + 6) = (unsigned char )(secsize >> 8);
#line 596
    *(mode___0 + 7) = (unsigned char )(secsize & 255);
#line 599
    tmp___0 = handle_scsi_cmd___0(d___0, cmd___0, 6U, 12U, 0U, (unsigned char)0, 0,
                                  sense);
    }
#line 599
    return (tmp___0);
  }
}
}
#line 604 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/interface/scsi_interface.c"
static unsigned int get_orig_sectorsize___0(cdrom_drive *d___0 ) 
{ 
  int tmp ;
  unsigned int tmp___0 ;

  {
  {
#line 605
  tmp = mode_sense___0(d___0, 12, 1);
  }
#line 605
  if (tmp) {
#line 605
    return (4294967295U);
  }
#line 607
  d___0->orgdens = *((d___0->private)->sg_buffer + 4);
#line 608
  tmp___0 = (unsigned int )(((int )*((d___0->private)->sg_buffer + 10) << 8) + (int )*((d___0->private)->sg_buffer + 11));
#line 608
  d___0->orgsize = tmp___0;
#line 608
  return (tmp___0);
}
}
#line 612 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/interface/scsi_interface.c"
static int set_sectorsize___0(cdrom_drive *d___0 , unsigned int secsize ) 
{ 
  int tmp ;

  {
  {
#line 613
  tmp = mode_select___0(d___0, (int )d___0->orgdens, (int )secsize);
  }
#line 613
  return (tmp);
}
}
#line 650 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/interface/scsi_interface.c"
static int scsi_read_toc___0(cdrom_drive *d___0 ) 
{ 
  int i ;
  int first ;
  int last___0 ;
  unsigned int tracks ;
  unsigned char sense[16] ;
  unsigned char cmd[10] ;
  int tmp ;
  char __constr_expr_3[10] ;
  int tmp___0 ;
  scsi_TOC *toc ;
  char __constr_expr_4[10] ;
  int tmp___1 ;
  scsi_TOC *toc___0 ;
  void *__cil_tmp15 ;
  void *__cil_tmp16 ;
  void *__cil_tmp17 ;
  void *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;

  {
  {
#line 659
  cmd[0] = (unsigned char)67;
#line 659
  cmd[1] = (unsigned char)0;
#line 659
  cmd[2] = (unsigned char)0;
#line 659
  cmd[3] = (unsigned char)0;
#line 659
  cmd[4] = (unsigned char)0;
#line 659
  cmd[5] = (unsigned char)0;
#line 659
  cmd[6] = (unsigned char)1;
#line 659
  cmd[7] = (unsigned char)0;
#line 659
  cmd[8] = (unsigned char)12;
#line 659
  cmd[9] = (unsigned char)0;
#line 660
  cmd[1] = (unsigned char )(d___0->lun << 5);
#line 662
  tmp = handle_scsi_cmd___0(d___0, cmd, 10U, 0U, 12U, (unsigned char )'\377', 1, sense);
  }
#line 662
  if (tmp) {
    {
#line 663
    cderror___4(d___0, "004: Unable to read table of contents header\n");
    }
#line 664
    return (-4);
  }
#line 667
  first = (int )*((d___0->private)->sg_buffer + 2);
#line 668
  last___0 = (int )*((d___0->private)->sg_buffer + 3);
#line 669
  tracks = (unsigned int )((last___0 - first) + 1);
#line 671
  if (last___0 > 100) {
    {
#line 672
    cderror___4(d___0, "003: CDROM reporting illegal number of tracks\n");
    }
#line 673
    return (-3);
  } else
#line 671
  if (first > 100) {
    {
#line 672
    cderror___4(d___0, "003: CDROM reporting illegal number of tracks\n");
    }
#line 673
    return (-3);
  } else
#line 671
  if (last___0 < 0) {
    {
#line 672
    cderror___4(d___0, "003: CDROM reporting illegal number of tracks\n");
    }
#line 673
    return (-3);
  } else
#line 671
  if (first < 0) {
    {
#line 672
    cderror___4(d___0, "003: CDROM reporting illegal number of tracks\n");
    }
#line 673
    return (-3);
  }
#line 676
  i = first;
  {
#line 676
  while (1) {
    while_continue: /* CIL Label */ ;
#line 676
    if (! (i <= last___0)) {
#line 676
      goto while_break;
    }
    {
#line 677
    __constr_expr_3[0] = (char)67;
#line 677
    __constr_expr_3[1] = (char)0;
#line 677
    __constr_expr_3[2] = (char)0;
#line 677
    __constr_expr_3[3] = (char)0;
#line 677
    __constr_expr_3[4] = (char)0;
#line 677
    __constr_expr_3[5] = (char)0;
#line 677
    __constr_expr_3[6] = (char)0;
#line 677
    __constr_expr_3[7] = (char)0;
#line 677
    __constr_expr_3[8] = (char)12;
#line 677
    __constr_expr_3[9] = (char)0;
#line 677
    memcpy((void */* __restrict  */)(cmd), (void const   */* __restrict  */)(__constr_expr_3),
           (size_t )10);
#line 678
    cmd[1] = (unsigned char )(d___0->lun << 5);
#line 679
    cmd[6] = (unsigned char )i;
#line 681
    tmp___0 = handle_scsi_cmd___0(d___0, cmd, 10U, 0U, 12U, (unsigned char )'\377',
                                  1, sense);
    }
#line 681
    if (tmp___0) {
      {
#line 682
      cderror___4(d___0, "005: Unable to read table of contents entry\n");
      }
#line 683
      return (-5);
    }
#line 686
    toc = (scsi_TOC *)((d___0->private)->sg_buffer + 4);
#line 688
    d___0->disc_toc[i - first].bFlags = toc->bFlags;
#line 689
    d___0->disc_toc[i - first].bTrack = (unsigned char )i;
#line 690
    d___0->disc_toc[i - first].dwStartSector = d___0->adjust_ssize * (((((int )toc->start_MSB << 24) | ((int )toc->start_1 << 16)) | ((int )toc->start_2 << 8)) | (int )toc->start_LSB);
#line 676
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 698
  __constr_expr_4[0] = (char)67;
#line 698
  __constr_expr_4[1] = (char)0;
#line 698
  __constr_expr_4[2] = (char)0;
#line 698
  __constr_expr_4[3] = (char)0;
#line 698
  __constr_expr_4[4] = (char)0;
#line 698
  __constr_expr_4[5] = (char)0;
#line 698
  __constr_expr_4[6] = (char)0;
#line 698
  __constr_expr_4[7] = (char)0;
#line 698
  __constr_expr_4[8] = (char)12;
#line 698
  __constr_expr_4[9] = (char)0;
#line 698
  memcpy((void */* __restrict  */)(cmd), (void const   */* __restrict  */)(__constr_expr_4),
         (size_t )10);
#line 699
  cmd[1] = (unsigned char )(d___0->lun << 5);
#line 700
  cmd[6] = (unsigned char)170;
#line 702
  tmp___1 = handle_scsi_cmd___0(d___0, cmd, 10U, 0U, 12U, (unsigned char )'\377',
                                1, sense);
  }
#line 702
  if (tmp___1) {
    {
#line 703
    cderror___4(d___0, "002: Unable to read table of contents lead-out\n");
    }
#line 704
    return (-2);
  }
  {
#line 707
  toc___0 = (scsi_TOC *)((d___0->private)->sg_buffer + 4);
#line 709
  d___0->disc_toc[i - first].bFlags = toc___0->bFlags;
#line 710
  d___0->disc_toc[i - first].bTrack = (unsigned char)170;
#line 711
  d___0->disc_toc[i - first].dwStartSector = d___0->adjust_ssize * (((((int )toc___0->start_MSB << 24) | ((int )toc___0->start_1 << 16)) | ((int )toc___0->start_2 << 8)) | (int )toc___0->start_LSB);
#line 718
  d___0->cd_extra = FixupTOC(d___0, (int )(tracks + 1U));
  }
#line 719
  return ((int )tracks);
}
}
#line 724 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/interface/scsi_interface.c"
static int scsi_read_toc2___0(cdrom_drive *d___0 ) 
{ 
  u_int32_t foo ;
  u_int32_t bar ;
  int i ;
  unsigned int tracks ;
  unsigned char cmd[10] ;
  unsigned char sense[16] ;
  int tmp ;
  char __constr_expr_5[10] ;
  int tmp___0 ;
  int32_t tmp___1 ;
  int32_t tmp___2 ;
  void *__cil_tmp13 ;
  void *__cil_tmp14 ;
  void *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;

  {
  {
#line 730
  cmd[0] = (unsigned char)229;
#line 730
  cmd[1] = (unsigned char)0;
#line 730
  cmd[2] = (unsigned char)0;
#line 730
  cmd[3] = (unsigned char)0;
#line 730
  cmd[4] = (unsigned char)0;
#line 730
  cmd[5] = (unsigned char)0;
#line 730
  cmd[6] = (unsigned char)0;
#line 730
  cmd[7] = (unsigned char)0;
#line 730
  cmd[8] = (unsigned char)0;
#line 730
  cmd[9] = (unsigned char)0;
#line 732
  cmd[5] = (unsigned char)1;
#line 733
  cmd[8] = (unsigned char)255;
#line 735
  tmp = handle_scsi_cmd___0(d___0, cmd, 10U, 0U, 256U, (unsigned char )'\377', 1,
                            sense);
  }
#line 735
  if (tmp) {
    {
#line 736
    cderror___4(d___0, "004: Unable to read table of contents header\n");
    }
#line 737
    return (-4);
  }
#line 741
  tracks = (unsigned int )*((d___0->private)->sg_buffer + 1);
#line 742
  if (tracks > 100U) {
    {
#line 743
    cderror___4(d___0, "003: CDROM reporting illegal number of tracks\n");
    }
#line 744
    return (-3);
  }
#line 747
  i = 0;
  {
#line 747
  while (1) {
    while_continue: /* CIL Label */ ;
#line 747
    if (! ((unsigned int )i < tracks)) {
#line 747
      goto while_break;
    }
    {
#line 748
    __constr_expr_5[0] = (char)-27;
#line 748
    __constr_expr_5[1] = (char)0;
#line 748
    __constr_expr_5[2] = (char)0;
#line 748
    __constr_expr_5[3] = (char)0;
#line 748
    __constr_expr_5[4] = (char)0;
#line 748
    __constr_expr_5[5] = (char)0;
#line 748
    __constr_expr_5[6] = (char)0;
#line 748
    __constr_expr_5[7] = (char)0;
#line 748
    __constr_expr_5[8] = (char)0;
#line 748
    __constr_expr_5[9] = (char)0;
#line 748
    memcpy((void */* __restrict  */)(cmd), (void const   */* __restrict  */)(__constr_expr_5),
           (size_t )10);
#line 749
    cmd[5] = (unsigned char )(i + 1);
#line 750
    cmd[8] = (unsigned char)255;
#line 752
    tmp___0 = handle_scsi_cmd___0(d___0, cmd, 10U, 0U, 256U, (unsigned char )'\377',
                                  1, sense);
    }
#line 752
    if (tmp___0) {
      {
#line 753
      cderror___4(d___0, "005: Unable to read table of contents entry\n");
      }
#line 754
      return (-5);
    }
#line 757
    d___0->disc_toc[i].bFlags = *((d___0->private)->sg_buffer + 10);
#line 758
    d___0->disc_toc[i].bTrack = (unsigned char )(i + 1);
#line 760
    d___0->disc_toc[i].dwStartSector = d___0->adjust_ssize * (((((int )((signed char )*((d___0->private)->sg_buffer + 2)) << 24) | ((int )*((d___0->private)->sg_buffer + 3) << 16)) | ((int )*((d___0->private)->sg_buffer + 4) << 8)) | (int )*((d___0->private)->sg_buffer + 5));
#line 747
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 767
  d___0->disc_toc[i].bFlags = (unsigned char)0;
#line 768
  d___0->disc_toc[i].bTrack = (unsigned char )(i + 1);
#line 769
  memcpy((void */* __restrict  */)(& foo), (void const   */* __restrict  */)((d___0->private)->sg_buffer + 2),
         (size_t )4);
#line 770
  memcpy((void */* __restrict  */)(& bar), (void const   */* __restrict  */)((d___0->private)->sg_buffer + 6),
         (size_t )4);
#line 771
  tmp___1 = be32_to_cpu((int32_t )foo);
#line 771
  tmp___2 = be32_to_cpu((int32_t )bar);
#line 771
  d___0->disc_toc[i].dwStartSector = d___0->adjust_ssize * (tmp___1 + tmp___2);
#line 774
  d___0->disc_toc[i].dwStartSector = d___0->adjust_ssize * ((((((int )((signed char )*((d___0->private)->sg_buffer + 2)) << 24) | ((int )*((d___0->private)->sg_buffer + 3) << 16)) | ((int )*((d___0->private)->sg_buffer + 4) << 8)) | (int )*((d___0->private)->sg_buffer + 5)) + (((((int )((signed char )*((d___0->private)->sg_buffer + 6)) << 24) | ((int )*((d___0->private)->sg_buffer + 7) << 16)) | ((int )*((d___0->private)->sg_buffer + 8) << 8)) | (int )*((d___0->private)->sg_buffer + 9)));
#line 786
  d___0->cd_extra = FixupTOC(d___0, (int )(tracks + 1U));
  }
#line 787
  return ((int )tracks);
}
}
#line 790 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/interface/scsi_interface.c"
static int scsi_set_speed___0(cdrom_drive *d___0 , int speed ) 
{ 
  unsigned char cmd[12] ;
  unsigned char sense[16] ;
  int tmp ;
  void *__cil_tmp6 ;
  void *__cil_tmp7 ;

  {
#line 791
  cmd[0] = (unsigned char)187;
#line 791
  cmd[1] = (unsigned char)0;
#line 791
  cmd[2] = (unsigned char)0;
#line 791
  cmd[3] = (unsigned char)0;
#line 791
  cmd[4] = (unsigned char)255;
#line 791
  cmd[5] = (unsigned char)255;
#line 791
  cmd[6] = (unsigned char)0;
#line 791
  cmd[7] = (unsigned char)0;
#line 791
  cmd[8] = (unsigned char)0;
#line 791
  cmd[9] = (unsigned char)0;
#line 791
  cmd[10] = (unsigned char)0;
#line 791
  cmd[11] = (unsigned char)0;
#line 794
  if (speed >= 0) {
#line 795
    speed = ((speed * 44100) * 4) / 1024;
  } else {
#line 797
    speed = -1;
  }
  {
#line 798
  cmd[2] = (unsigned char )((speed >> 8) & 255);
#line 799
  cmd[3] = (unsigned char )(speed & 255);
#line 800
  tmp = handle_scsi_cmd___0(d___0, cmd, 12U, 0U, 0U, (unsigned char)0, 0, sense);
  }
#line 800
  return (tmp);
}
}
#line 805 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/interface/scsi_interface.c"
static int i_read_28___0(cdrom_drive *d___0 , void *p___0 , long begin , long sectors ,
                         unsigned char *sense ) 
{ 
  int ret ;
  unsigned char cmd[10] ;
  void *__cil_tmp8 ;

  {
#line 807
  cmd[0] = (unsigned char)40;
#line 807
  cmd[1] = (unsigned char)0;
#line 807
  cmd[2] = (unsigned char)0;
#line 807
  cmd[3] = (unsigned char)0;
#line 807
  cmd[4] = (unsigned char)0;
#line 807
  cmd[5] = (unsigned char)0;
#line 807
  cmd[6] = (unsigned char)0;
#line 807
  cmd[7] = (unsigned char)0;
#line 807
  cmd[8] = (unsigned char)0;
#line 807
  cmd[9] = (unsigned char)0;
#line 809
  if (d___0->fua) {
#line 810
    cmd[1] = (unsigned char)8;
  }
  {
#line 812
  cmd[1] = (unsigned char )((int )cmd[1] | (d___0->lun << 5));
#line 814
  cmd[3] = (unsigned char )((begin >> 16) & 255L);
#line 815
  cmd[4] = (unsigned char )((begin >> 8) & 255L);
#line 816
  cmd[5] = (unsigned char )(begin & 255L);
#line 817
  cmd[8] = (unsigned char )sectors;
#line 818
  ret = handle_scsi_cmd___0(d___0, cmd, 10U, 0U, (unsigned int )(sectors * 2352L),
                            (unsigned char )'\177', 1, sense);
  }
#line 818
  if (ret) {
#line 819
    return (ret);
  }
#line 820
  if (p___0) {
    {
#line 820
    memcpy((void */* __restrict  */)p___0, (void const   */* __restrict  */)(d___0->private)->sg_buffer,
           (size_t )(sectors * 2352L));
    }
  }
#line 821
  return (0);
}
}
#line 824 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/interface/scsi_interface.c"
static int i_read_A8___0(cdrom_drive *d___0 , void *p___0 , long begin , long sectors ,
                         unsigned char *sense ) 
{ 
  int ret ;
  unsigned char cmd[12] ;
  void *__cil_tmp8 ;

  {
#line 826
  cmd[0] = (unsigned char)168;
#line 826
  cmd[1] = (unsigned char)0;
#line 826
  cmd[2] = (unsigned char)0;
#line 826
  cmd[3] = (unsigned char)0;
#line 826
  cmd[4] = (unsigned char)0;
#line 826
  cmd[5] = (unsigned char)0;
#line 826
  cmd[6] = (unsigned char)0;
#line 826
  cmd[7] = (unsigned char)0;
#line 826
  cmd[8] = (unsigned char)0;
#line 826
  cmd[9] = (unsigned char)0;
#line 826
  cmd[10] = (unsigned char)0;
#line 826
  cmd[11] = (unsigned char)0;
#line 828
  if (d___0->fua) {
#line 829
    cmd[1] = (unsigned char)8;
  }
  {
#line 831
  cmd[1] = (unsigned char )((int )cmd[1] | (d___0->lun << 5));
#line 833
  cmd[3] = (unsigned char )((begin >> 16) & 255L);
#line 834
  cmd[4] = (unsigned char )((begin >> 8) & 255L);
#line 835
  cmd[5] = (unsigned char )(begin & 255L);
#line 836
  cmd[9] = (unsigned char )sectors;
#line 837
  ret = handle_scsi_cmd___0(d___0, cmd, 12U, 0U, (unsigned int )(sectors * 2352L),
                            (unsigned char )'\177', 1, sense);
  }
#line 837
  if (ret) {
#line 838
    return (ret);
  }
#line 839
  if (p___0) {
    {
#line 839
    memcpy((void */* __restrict  */)p___0, (void const   */* __restrict  */)(d___0->private)->sg_buffer,
           (size_t )(sectors * 2352L));
    }
  }
#line 840
  return (0);
}
}
#line 843 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/interface/scsi_interface.c"
static int i_read_D4_10___0(cdrom_drive *d___0 , void *p___0 , long begin , long sectors ,
                            unsigned char *sense ) 
{ 
  int ret ;
  unsigned char cmd[10] ;
  void *__cil_tmp8 ;

  {
#line 845
  cmd[0] = (unsigned char)212;
#line 845
  cmd[1] = (unsigned char)0;
#line 845
  cmd[2] = (unsigned char)0;
#line 845
  cmd[3] = (unsigned char)0;
#line 845
  cmd[4] = (unsigned char)0;
#line 845
  cmd[5] = (unsigned char)0;
#line 845
  cmd[6] = (unsigned char)0;
#line 845
  cmd[7] = (unsigned char)0;
#line 845
  cmd[8] = (unsigned char)0;
#line 845
  cmd[9] = (unsigned char)0;
#line 847
  if (d___0->fua) {
#line 848
    cmd[1] = (unsigned char)8;
  }
  {
#line 850
  cmd[1] = (unsigned char )((int )cmd[1] | (d___0->lun << 5));
#line 851
  cmd[3] = (unsigned char )((begin >> 16) & 255L);
#line 852
  cmd[4] = (unsigned char )((begin >> 8) & 255L);
#line 853
  cmd[5] = (unsigned char )(begin & 255L);
#line 854
  cmd[8] = (unsigned char )sectors;
#line 855
  ret = handle_scsi_cmd___0(d___0, cmd, 10U, 0U, (unsigned int )(sectors * 2352L),
                            (unsigned char )'\177', 1, sense);
  }
#line 855
  if (ret) {
#line 856
    return (ret);
  }
#line 857
  if (p___0) {
    {
#line 857
    memcpy((void */* __restrict  */)p___0, (void const   */* __restrict  */)(d___0->private)->sg_buffer,
           (size_t )(sectors * 2352L));
    }
  }
#line 858
  return (0);
}
}
#line 861 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/interface/scsi_interface.c"
static int i_read_D4_12___0(cdrom_drive *d___0 , void *p___0 , long begin , long sectors ,
                            unsigned char *sense ) 
{ 
  int ret ;
  unsigned char cmd[12] ;
  void *__cil_tmp8 ;

  {
#line 863
  cmd[0] = (unsigned char)212;
#line 863
  cmd[1] = (unsigned char)0;
#line 863
  cmd[2] = (unsigned char)0;
#line 863
  cmd[3] = (unsigned char)0;
#line 863
  cmd[4] = (unsigned char)0;
#line 863
  cmd[5] = (unsigned char)0;
#line 863
  cmd[6] = (unsigned char)0;
#line 863
  cmd[7] = (unsigned char)0;
#line 863
  cmd[8] = (unsigned char)0;
#line 863
  cmd[9] = (unsigned char)0;
#line 863
  cmd[10] = (unsigned char)0;
#line 863
  cmd[11] = (unsigned char)0;
#line 865
  if (d___0->fua) {
#line 866
    cmd[1] = (unsigned char)8;
  }
  {
#line 868
  cmd[1] = (unsigned char )((int )cmd[1] | (d___0->lun << 5));
#line 869
  cmd[3] = (unsigned char )((begin >> 16) & 255L);
#line 870
  cmd[4] = (unsigned char )((begin >> 8) & 255L);
#line 871
  cmd[5] = (unsigned char )(begin & 255L);
#line 872
  cmd[9] = (unsigned char )sectors;
#line 873
  ret = handle_scsi_cmd___0(d___0, cmd, 12U, 0U, (unsigned int )(sectors * 2352L),
                            (unsigned char )'\177', 1, sense);
  }
#line 873
  if (ret) {
#line 874
    return (ret);
  }
#line 875
  if (p___0) {
    {
#line 875
    memcpy((void */* __restrict  */)p___0, (void const   */* __restrict  */)(d___0->private)->sg_buffer,
           (size_t )(sectors * 2352L));
    }
  }
#line 876
  return (0);
}
}
#line 879 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/interface/scsi_interface.c"
static int i_read_D5___0(cdrom_drive *d___0 , void *p___0 , long begin , long sectors ,
                         unsigned char *sense ) 
{ 
  int ret ;
  unsigned char cmd[10] ;
  void *__cil_tmp8 ;

  {
#line 881
  cmd[0] = (unsigned char)213;
#line 881
  cmd[1] = (unsigned char)0;
#line 881
  cmd[2] = (unsigned char)0;
#line 881
  cmd[3] = (unsigned char)0;
#line 881
  cmd[4] = (unsigned char)0;
#line 881
  cmd[5] = (unsigned char)0;
#line 881
  cmd[6] = (unsigned char)0;
#line 881
  cmd[7] = (unsigned char)0;
#line 881
  cmd[8] = (unsigned char)0;
#line 881
  cmd[9] = (unsigned char)0;
#line 883
  if (d___0->fua) {
#line 884
    cmd[1] = (unsigned char)8;
  }
  {
#line 886
  cmd[1] = (unsigned char )((int )cmd[1] | (d___0->lun << 5));
#line 887
  cmd[3] = (unsigned char )((begin >> 16) & 255L);
#line 888
  cmd[4] = (unsigned char )((begin >> 8) & 255L);
#line 889
  cmd[5] = (unsigned char )(begin & 255L);
#line 890
  cmd[8] = (unsigned char )sectors;
#line 891
  ret = handle_scsi_cmd___0(d___0, cmd, 10U, 0U, (unsigned int )(sectors * 2352L),
                            (unsigned char )'\177', 1, sense);
  }
#line 891
  if (ret) {
#line 892
    return (ret);
  }
#line 893
  if (p___0) {
    {
#line 893
    memcpy((void */* __restrict  */)p___0, (void const   */* __restrict  */)(d___0->private)->sg_buffer,
           (size_t )(sectors * 2352L));
    }
  }
#line 894
  return (0);
}
}
#line 897 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/interface/scsi_interface.c"
static int i_read_D8___0(cdrom_drive *d___0 , void *p___0 , long begin , long sectors ,
                         unsigned char *sense ) 
{ 
  int ret ;
  unsigned char cmd[12] ;
  void *__cil_tmp8 ;

  {
#line 899
  cmd[0] = (unsigned char)216;
#line 899
  cmd[1] = (unsigned char)0;
#line 899
  cmd[2] = (unsigned char)0;
#line 899
  cmd[3] = (unsigned char)0;
#line 899
  cmd[4] = (unsigned char)0;
#line 899
  cmd[5] = (unsigned char)0;
#line 899
  cmd[6] = (unsigned char)0;
#line 899
  cmd[7] = (unsigned char)0;
#line 899
  cmd[8] = (unsigned char)0;
#line 899
  cmd[9] = (unsigned char)0;
#line 899
  cmd[10] = (unsigned char)0;
#line 899
  cmd[11] = (unsigned char)0;
#line 901
  if (d___0->fua) {
#line 902
    cmd[1] = (unsigned char)8;
  }
  {
#line 904
  cmd[1] = (unsigned char )((int )cmd[1] | (d___0->lun << 5));
#line 905
  cmd[3] = (unsigned char )((begin >> 16) & 255L);
#line 906
  cmd[4] = (unsigned char )((begin >> 8) & 255L);
#line 907
  cmd[5] = (unsigned char )(begin & 255L);
#line 908
  cmd[9] = (unsigned char )sectors;
#line 909
  ret = handle_scsi_cmd___0(d___0, cmd, 12U, 0U, (unsigned int )(sectors * 2352L),
                            (unsigned char )'\177', 1, sense);
  }
#line 909
  if (ret) {
#line 910
    return (ret);
  }
#line 911
  if (p___0) {
    {
#line 911
    memcpy((void */* __restrict  */)p___0, (void const   */* __restrict  */)(d___0->private)->sg_buffer,
           (size_t )(sectors * 2352L));
    }
  }
#line 912
  return (0);
}
}
#line 915 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/interface/scsi_interface.c"
static int i_read_mmc___0(cdrom_drive *d___0 , void *p___0 , long begin , long sectors ,
                          unsigned char *sense ) 
{ 
  int ret ;
  unsigned char cmd[12] ;
  void *__cil_tmp8 ;

  {
  {
#line 917
  cmd[0] = (unsigned char)190;
#line 917
  cmd[1] = (unsigned char)2;
#line 917
  cmd[2] = (unsigned char)0;
#line 917
  cmd[3] = (unsigned char)0;
#line 917
  cmd[4] = (unsigned char)0;
#line 917
  cmd[5] = (unsigned char)0;
#line 917
  cmd[6] = (unsigned char)0;
#line 917
  cmd[7] = (unsigned char)0;
#line 917
  cmd[8] = (unsigned char)0;
#line 917
  cmd[9] = (unsigned char)16;
#line 917
  cmd[10] = (unsigned char)0;
#line 917
  cmd[11] = (unsigned char)0;
#line 919
  cmd[3] = (unsigned char )((begin >> 16) & 255L);
#line 920
  cmd[4] = (unsigned char )((begin >> 8) & 255L);
#line 921
  cmd[5] = (unsigned char )(begin & 255L);
#line 922
  cmd[8] = (unsigned char )sectors;
#line 923
  ret = handle_scsi_cmd___0(d___0, cmd, 12U, 0U, (unsigned int )(sectors * 2352L),
                            (unsigned char )'\177', 1, sense);
  }
#line 923
  if (ret) {
#line 924
    return (ret);
  }
#line 925
  if (p___0) {
    {
#line 925
    memcpy((void */* __restrict  */)p___0, (void const   */* __restrict  */)(d___0->private)->sg_buffer,
           (size_t )(sectors * 2352L));
    }
  }
#line 926
  return (0);
}
}
#line 929 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/interface/scsi_interface.c"
static int i_read_mmcB___0(cdrom_drive *d___0 , void *p___0 , long begin , long sectors ,
                           unsigned char *sense ) 
{ 
  int ret ;
  unsigned char cmd[12] ;
  void *__cil_tmp8 ;

  {
  {
#line 931
  cmd[0] = (unsigned char)190;
#line 931
  cmd[1] = (unsigned char)0;
#line 931
  cmd[2] = (unsigned char)0;
#line 931
  cmd[3] = (unsigned char)0;
#line 931
  cmd[4] = (unsigned char)0;
#line 931
  cmd[5] = (unsigned char)0;
#line 931
  cmd[6] = (unsigned char)0;
#line 931
  cmd[7] = (unsigned char)0;
#line 931
  cmd[8] = (unsigned char)0;
#line 931
  cmd[9] = (unsigned char)16;
#line 931
  cmd[10] = (unsigned char)0;
#line 931
  cmd[11] = (unsigned char)0;
#line 933
  cmd[3] = (unsigned char )((begin >> 16) & 255L);
#line 934
  cmd[4] = (unsigned char )((begin >> 8) & 255L);
#line 935
  cmd[5] = (unsigned char )(begin & 255L);
#line 936
  cmd[8] = (unsigned char )sectors;
#line 937
  ret = handle_scsi_cmd___0(d___0, cmd, 12U, 0U, (unsigned int )(sectors * 2352L),
                            (unsigned char )'\177', 1, sense);
  }
#line 937
  if (ret) {
#line 938
    return (ret);
  }
#line 939
  if (p___0) {
    {
#line 939
    memcpy((void */* __restrict  */)p___0, (void const   */* __restrict  */)(d___0->private)->sg_buffer,
           (size_t )(sectors * 2352L));
    }
  }
#line 940
  return (0);
}
}
#line 943 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/interface/scsi_interface.c"
static int i_read_mmc2___0(cdrom_drive *d___0 , void *p___0 , long begin , long sectors ,
                           unsigned char *sense ) 
{ 
  int ret ;
  unsigned char cmd[12] ;
  void *__cil_tmp8 ;

  {
  {
#line 945
  cmd[0] = (unsigned char)190;
#line 945
  cmd[1] = (unsigned char)2;
#line 945
  cmd[2] = (unsigned char)0;
#line 945
  cmd[3] = (unsigned char)0;
#line 945
  cmd[4] = (unsigned char)0;
#line 945
  cmd[5] = (unsigned char)0;
#line 945
  cmd[6] = (unsigned char)0;
#line 945
  cmd[7] = (unsigned char)0;
#line 945
  cmd[8] = (unsigned char)0;
#line 945
  cmd[9] = (unsigned char)248;
#line 945
  cmd[10] = (unsigned char)0;
#line 945
  cmd[11] = (unsigned char)0;
#line 947
  cmd[3] = (unsigned char )((begin >> 16) & 255L);
#line 948
  cmd[4] = (unsigned char )((begin >> 8) & 255L);
#line 949
  cmd[5] = (unsigned char )(begin & 255L);
#line 950
  cmd[8] = (unsigned char )sectors;
#line 951
  ret = handle_scsi_cmd___0(d___0, cmd, 12U, 0U, (unsigned int )(sectors * 2352L),
                            (unsigned char )'\177', 1, sense);
  }
#line 951
  if (ret) {
#line 952
    return (ret);
  }
#line 953
  if (p___0) {
    {
#line 953
    memcpy((void */* __restrict  */)p___0, (void const   */* __restrict  */)(d___0->private)->sg_buffer,
           (size_t )(sectors * 2352L));
    }
  }
#line 954
  return (0);
}
}
#line 957 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/interface/scsi_interface.c"
static int i_read_mmc2B___0(cdrom_drive *d___0 , void *p___0 , long begin , long sectors ,
                            unsigned char *sense ) 
{ 
  int ret ;
  unsigned char cmd[12] ;
  void *__cil_tmp8 ;

  {
  {
#line 959
  cmd[0] = (unsigned char)190;
#line 959
  cmd[1] = (unsigned char)0;
#line 959
  cmd[2] = (unsigned char)0;
#line 959
  cmd[3] = (unsigned char)0;
#line 959
  cmd[4] = (unsigned char)0;
#line 959
  cmd[5] = (unsigned char)0;
#line 959
  cmd[6] = (unsigned char)0;
#line 959
  cmd[7] = (unsigned char)0;
#line 959
  cmd[8] = (unsigned char)0;
#line 959
  cmd[9] = (unsigned char)248;
#line 959
  cmd[10] = (unsigned char)0;
#line 959
  cmd[11] = (unsigned char)0;
#line 961
  cmd[3] = (unsigned char )((begin >> 16) & 255L);
#line 962
  cmd[4] = (unsigned char )((begin >> 8) & 255L);
#line 963
  cmd[5] = (unsigned char )(begin & 255L);
#line 964
  cmd[8] = (unsigned char )sectors;
#line 965
  ret = handle_scsi_cmd___0(d___0, cmd, 12U, 0U, (unsigned int )(sectors * 2352L),
                            (unsigned char )'\177', 1, sense);
  }
#line 965
  if (ret) {
#line 966
    return (ret);
  }
#line 967
  if (p___0) {
    {
#line 967
    memcpy((void */* __restrict  */)p___0, (void const   */* __restrict  */)(d___0->private)->sg_buffer,
           (size_t )(sectors * 2352L));
    }
  }
#line 968
  return (0);
}
}
#line 971 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/interface/scsi_interface.c"
static int i_read_mmc3___0(cdrom_drive *d___0 , void *p___0 , long begin , long sectors ,
                           unsigned char *sense ) 
{ 
  int ret ;
  unsigned char cmd[12] ;
  void *__cil_tmp8 ;

  {
  {
#line 973
  cmd[0] = (unsigned char)190;
#line 973
  cmd[1] = (unsigned char)6;
#line 973
  cmd[2] = (unsigned char)0;
#line 973
  cmd[3] = (unsigned char)0;
#line 973
  cmd[4] = (unsigned char)0;
#line 973
  cmd[5] = (unsigned char)0;
#line 973
  cmd[6] = (unsigned char)0;
#line 973
  cmd[7] = (unsigned char)0;
#line 973
  cmd[8] = (unsigned char)0;
#line 973
  cmd[9] = (unsigned char)248;
#line 973
  cmd[10] = (unsigned char)0;
#line 973
  cmd[11] = (unsigned char)0;
#line 975
  cmd[3] = (unsigned char )((begin >> 16) & 255L);
#line 976
  cmd[4] = (unsigned char )((begin >> 8) & 255L);
#line 977
  cmd[5] = (unsigned char )(begin & 255L);
#line 978
  cmd[8] = (unsigned char )sectors;
#line 979
  ret = handle_scsi_cmd___0(d___0, cmd, 12U, 0U, (unsigned int )(sectors * 2352L),
                            (unsigned char )'\177', 1, sense);
  }
#line 979
  if (ret) {
#line 980
    return (ret);
  }
#line 981
  if (p___0) {
    {
#line 981
    memcpy((void */* __restrict  */)p___0, (void const   */* __restrict  */)(d___0->private)->sg_buffer,
           (size_t )(sectors * 2352L));
    }
  }
#line 982
  return (0);
}
}
#line 985 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/interface/scsi_interface.c"
static int i_read_mmc3B___0(cdrom_drive *d___0 , void *p___0 , long begin , long sectors ,
                            unsigned char *sense ) 
{ 
  int ret ;
  unsigned char cmd[12] ;
  void *__cil_tmp8 ;

  {
  {
#line 987
  cmd[0] = (unsigned char)190;
#line 987
  cmd[1] = (unsigned char)4;
#line 987
  cmd[2] = (unsigned char)0;
#line 987
  cmd[3] = (unsigned char)0;
#line 987
  cmd[4] = (unsigned char)0;
#line 987
  cmd[5] = (unsigned char)0;
#line 987
  cmd[6] = (unsigned char)0;
#line 987
  cmd[7] = (unsigned char)0;
#line 987
  cmd[8] = (unsigned char)0;
#line 987
  cmd[9] = (unsigned char)248;
#line 987
  cmd[10] = (unsigned char)0;
#line 987
  cmd[11] = (unsigned char)0;
#line 989
  cmd[3] = (unsigned char )((begin >> 16) & 255L);
#line 990
  cmd[4] = (unsigned char )((begin >> 8) & 255L);
#line 991
  cmd[5] = (unsigned char )(begin & 255L);
#line 992
  cmd[8] = (unsigned char )sectors;
#line 993
  ret = handle_scsi_cmd___0(d___0, cmd, 12U, 0U, (unsigned int )(sectors * 2352L),
                            (unsigned char )'\177', 1, sense);
  }
#line 993
  if (ret) {
#line 994
    return (ret);
  }
#line 995
  if (p___0) {
    {
#line 995
    memcpy((void */* __restrict  */)p___0, (void const   */* __restrict  */)(d___0->private)->sg_buffer,
           (size_t )(sectors * 2352L));
    }
  }
#line 996
  return (0);
}
}
#line 1020 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/interface/scsi_interface.c"
static int i_read_msf___0(cdrom_drive *d___0 , void *p___0 , long begin , long sectors ,
                          unsigned char *sense ) 
{ 
  int ret ;
  unsigned char cmd[12] ;
  void *__cil_tmp8 ;

  {
  {
#line 1022
  cmd[0] = (unsigned char)185;
#line 1022
  cmd[1] = (unsigned char)0;
#line 1022
  cmd[2] = (unsigned char)0;
#line 1022
  cmd[3] = (unsigned char)0;
#line 1022
  cmd[4] = (unsigned char)0;
#line 1022
  cmd[5] = (unsigned char)0;
#line 1022
  cmd[6] = (unsigned char)0;
#line 1022
  cmd[7] = (unsigned char)0;
#line 1022
  cmd[8] = (unsigned char)0;
#line 1022
  cmd[9] = (unsigned char)16;
#line 1022
  cmd[10] = (unsigned char)0;
#line 1022
  cmd[11] = (unsigned char)0;
#line 1024
  LBA_to_MSF(begin, cmd + 3, cmd + 4, cmd + 5);
#line 1025
  LBA_to_MSF(begin + sectors, cmd + 6, cmd + 7, cmd + 8);
#line 1027
  ret = handle_scsi_cmd___0(d___0, cmd, 12U, 0U, (unsigned int )(sectors * 2352L),
                            (unsigned char )'\177', 1, sense);
  }
#line 1027
  if (ret) {
#line 1028
    return (ret);
  }
#line 1029
  if (p___0) {
    {
#line 1029
    memcpy((void */* __restrict  */)p___0, (void const   */* __restrict  */)(d___0->private)->sg_buffer,
           (size_t )(sectors * 2352L));
    }
  }
#line 1030
  return (0);
}
}
#line 1033 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/interface/scsi_interface.c"
static int i_read_msf2___0(cdrom_drive *d___0 , void *p___0 , long begin , long sectors ,
                           unsigned char *sense ) 
{ 
  int ret ;
  unsigned char cmd[12] ;
  void *__cil_tmp8 ;

  {
  {
#line 1035
  cmd[0] = (unsigned char)185;
#line 1035
  cmd[1] = (unsigned char)0;
#line 1035
  cmd[2] = (unsigned char)0;
#line 1035
  cmd[3] = (unsigned char)0;
#line 1035
  cmd[4] = (unsigned char)0;
#line 1035
  cmd[5] = (unsigned char)0;
#line 1035
  cmd[6] = (unsigned char)0;
#line 1035
  cmd[7] = (unsigned char)0;
#line 1035
  cmd[8] = (unsigned char)0;
#line 1035
  cmd[9] = (unsigned char)248;
#line 1035
  cmd[10] = (unsigned char)0;
#line 1035
  cmd[11] = (unsigned char)0;
#line 1037
  LBA_to_MSF(begin, cmd + 3, cmd + 4, cmd + 5);
#line 1038
  LBA_to_MSF(begin + sectors, cmd + 6, cmd + 7, cmd + 8);
#line 1040
  ret = handle_scsi_cmd___0(d___0, cmd, 12U, 0U, (unsigned int )(sectors * 2352L),
                            (unsigned char )'\177', 1, sense);
  }
#line 1040
  if (ret) {
#line 1041
    return (ret);
  }
#line 1042
  if (p___0) {
    {
#line 1042
    memcpy((void */* __restrict  */)p___0, (void const   */* __restrict  */)(d___0->private)->sg_buffer,
           (size_t )(sectors * 2352L));
    }
  }
#line 1043
  return (0);
}
}
#line 1046 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/interface/scsi_interface.c"
static int i_read_msf3___0(cdrom_drive *d___0 , void *p___0 , long begin , long sectors ,
                           unsigned char *sense ) 
{ 
  int ret ;
  unsigned char cmd[12] ;
  void *__cil_tmp8 ;

  {
  {
#line 1048
  cmd[0] = (unsigned char)185;
#line 1048
  cmd[1] = (unsigned char)4;
#line 1048
  cmd[2] = (unsigned char)0;
#line 1048
  cmd[3] = (unsigned char)0;
#line 1048
  cmd[4] = (unsigned char)0;
#line 1048
  cmd[5] = (unsigned char)0;
#line 1048
  cmd[6] = (unsigned char)0;
#line 1048
  cmd[7] = (unsigned char)0;
#line 1048
  cmd[8] = (unsigned char)0;
#line 1048
  cmd[9] = (unsigned char)248;
#line 1048
  cmd[10] = (unsigned char)0;
#line 1048
  cmd[11] = (unsigned char)0;
#line 1050
  LBA_to_MSF(begin, cmd + 3, cmd + 4, cmd + 5);
#line 1051
  LBA_to_MSF(begin + sectors, cmd + 6, cmd + 7, cmd + 8);
#line 1053
  ret = handle_scsi_cmd___0(d___0, cmd, 12U, 0U, (unsigned int )(sectors * 2352L),
                            (unsigned char )'\177', 1, sense);
  }
#line 1053
  if (ret) {
#line 1054
    return (ret);
  }
#line 1055
  if (p___0) {
    {
#line 1055
    memcpy((void */* __restrict  */)p___0, (void const   */* __restrict  */)(d___0->private)->sg_buffer,
           (size_t )(sectors * 2352L));
    }
  }
#line 1056
  return (0);
}
}
#line 1060 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/interface/scsi_interface.c"
static long scsi_read_map___0(cdrom_drive *d___0 , void *p___0 , long begin , long sectors ,
                              int (*map)(cdrom_drive * , void * , long  , long  ,
                                         unsigned char * ) ) 
{ 
  unsigned char sense[16] ;
  int retry_count ;
  int err ;
  char *buffer ;
  char b[256] ;
  int *tmp ;
  char *tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  int *tmp___3 ;
  char b___0[256] ;
  int *tmp___4 ;
  char b___1[256] ;
  long i ;
  char b___2[256] ;
  char *tmp___5 ;
  void *__cil_tmp22 ;
  void *__cil_tmp23 ;
  void *__cil_tmp24 ;
  void *__cil_tmp25 ;
  void *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;

  {
#line 1065
  buffer = (char *)p___0;
#line 1068
  if (sectors > (long )d___0->nsectors) {
#line 1068
    sectors = (long )d___0->nsectors;
  } else {
#line 1068
    sectors = sectors;
  }
#line 1069
  if (sectors < 1L) {
#line 1069
    sectors = 1L;
  } else {
#line 1069
    sectors = sectors;
  }
#line 1071
  retry_count = 0;
  {
#line 1073
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1075
    if (p___0) {
#line 1075
      tmp___5 = buffer;
    } else {
#line 1075
      tmp___5 = (char *)((void *)0);
    }
    {
#line 1075
    err = (*map)(d___0, (void *)tmp___5, begin, sectors, sense);
    }
#line 1075
    if (err) {
#line 1076
      if (d___0->report_all) {
        {
#line 1079
        sprintf((char */* __restrict  */)(b), (char const   */* __restrict  */)"scsi_read error: sector=%ld length=%ld retry=%d\n",
                begin, sectors, retry_count);
#line 1081
        cdmessage___2(d___0, (char const   *)(b));
#line 1082
        sprintf((char */* __restrict  */)(b), (char const   */* __restrict  */)"                 Sense key: %x ASC: %x ASCQ: %x\n",
                (int )sense[2] & 15, (int )sense[12], (int )sense[13]);
#line 1086
        cdmessage___2(d___0, (char const   *)(b));
#line 1087
        sprintf((char */* __restrict  */)(b), (char const   */* __restrict  */)"                 Transport error: %s\n",
                strerror_tr___0[err]);
#line 1088
        cdmessage___2(d___0, (char const   *)(b));
#line 1089
        tmp = __errno_location();
#line 1089
        tmp___0 = strerror(*tmp);
#line 1089
        sprintf((char */* __restrict  */)(b), (char const   */* __restrict  */)"                 System error: %s\n",
                tmp___0);
#line 1090
        cdmessage___2(d___0, (char const   *)(b));
#line 1092
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"scsi_read error: sector=%ld length=%ld retry=%d\n",
                begin, sectors, retry_count);
#line 1094
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"                 Sense key: %x ASC: %x ASCQ: %x\n",
                (int )sense[2] & 15, (int )sense[12], (int )sense[13]);
#line 1098
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"                 Transport error: %s\n",
                strerror_tr___0[err]);
#line 1099
        tmp___1 = __errno_location();
#line 1099
        tmp___2 = strerror(*tmp___1);
#line 1099
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"                 System error: %s\n",
                tmp___2);
        }
      }
      {
#line 1102
      tmp___3 = __errno_location();
      }
      {
#line 1103
      if (*tmp___3 == 4) {
#line 1103
        goto case_4;
      }
#line 1106
      if (*tmp___3 == 12) {
#line 1106
        goto case_12;
      }
#line 1123
      if (*tmp___3 == 123) {
#line 1123
        goto case_123;
      }
#line 1127
      goto switch_default;
      case_4: /* CIL Label */ 
      {
#line 1104
      usleep((__useconds_t )100);
      }
#line 1105
      goto while_continue;
      case_12: /* CIL Label */ 
      {
#line 1108
      usleep((__useconds_t )100);
      }
#line 1109
      if (sectors == 1L) {
        {
#line 1111
        cderror___4(d___0, "300: Kernel memory error\n");
        }
#line 1112
        return (-300L);
      }
#line 1114
      if (d___0->report_all) {
        {
#line 1116
        sprintf((char */* __restrict  */)(b___0), (char const   */* __restrict  */)"scsi_read: kernel couldn\'t alloc %ld bytes.  backing off...\n",
                sectors * 2352L);
#line 1119
        cdmessage___2(d___0, (char const   *)(b___0));
        }
      }
#line 1121
      sectors --;
#line 1122
      goto while_continue;
      case_123: /* CIL Label */ 
      {
#line 1124
      cderror___4(d___0, "404: No medium present\n");
      }
#line 1125
      return (-404L);
      switch_default: /* CIL Label */ 
#line 1128
      if (sectors == 1L) {
        {
#line 1129
        tmp___4 = __errno_location();
        }
#line 1129
        if (*tmp___4 == 5) {
#line 1130
          if (d___0->fua == -1) {
#line 1131
            return (-7L);
          }
        }
#line 1136
        if (retry_count > 7) {
          {
#line 1138
          sprintf((char */* __restrict  */)(b___1), (char const   */* __restrict  */)"010: Unable to access sector %ld\n",
                  begin);
#line 1140
          cderror___4(d___0, (char const   *)(b___1));
          }
#line 1141
          return (-10L);
        }
#line 1144
        goto switch_break;
      }
      {
#line 1150
      reset_scsi___0(d___0);
      }
      switch_break: /* CIL Label */ ;
      }
#line 1152
      if (! d___0->error_retry) {
#line 1152
        return (-7L);
      }
    } else
#line 1158
    if (buffer) {
#line 1160
      i = sectors * 2352L;
      {
#line 1160
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1160
        if (! (i > 1L)) {
#line 1160
          goto while_break___0;
        }
#line 1161
        if ((int )*(buffer + (i - 1L)) != 127) {
#line 1162
          goto while_break___0;
        } else
#line 1161
        if ((int )*(buffer + (i - 2L)) != 127) {
#line 1162
          goto while_break___0;
        }
#line 1160
        i -= 2L;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 1164
      i /= 2352L;
#line 1165
      if (i != sectors) {
#line 1166
        if (d___0->report_all) {
          {
#line 1168
          sprintf((char */* __restrict  */)(b___2), (char const   */* __restrict  */)"scsi_read underrun: pos=%ld len=%ld read=%ld retry=%d\n",
                  begin, sectors, i, retry_count);
#line 1171
          cdmessage___2(d___0, (char const   *)(b___2));
          }
        }
        {
#line 1173
        reset_scsi___0(d___0);
        }
      }
#line 1176
      if (i > 0L) {
#line 1176
        return (i);
      }
    } else {
#line 1179
      goto while_break;
    }
#line 1182
    retry_count ++;
#line 1183
    if (sectors == 1L) {
#line 1183
      if (retry_count > 8) {
        {
#line 1184
        cderror___4(d___0, "007: Unknown, unrecoverable error reading data\n");
        }
#line 1185
        return (-7L);
      }
    }
#line 1187
    if (sectors > 1L) {
#line 1187
      sectors /= 2L;
    }
    {
#line 1188
    (*(d___0->enable_cdda))(d___0, 0);
#line 1189
    (*(d___0->enable_cdda))(d___0, 1);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1192
  return (sectors);
}
}
#line 1275 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/interface/scsi_interface.c"
static int count_2352_bytes___0(cdrom_drive *d___0 ) 
{ 
  long i ;

  {
#line 1277
  i = 2351L;
  {
#line 1277
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1277
    if (! (i >= 0L)) {
#line 1277
      goto while_break;
    }
#line 1278
    if ((int )*((d___0->private)->sg_buffer + i) != 127) {
#line 1279
      return ((int )(((i + 3L) >> 2) << 2));
    }
#line 1277
    i --;
  }
  while_break: /* CIL Label */ ;
  }
#line 1281
  return (0);
}
}
#line 1284 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/interface/scsi_interface.c"
static int verify_nonzero___0(cdrom_drive *d___0 ) 
{ 
  long i ;
  long flag ;

  {
#line 1285
  flag = 0L;
#line 1286
  i = 0L;
  {
#line 1286
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1286
    if (! (i < 2352L)) {
#line 1286
      goto while_break;
    }
#line 1287
    if ((int )*((d___0->private)->sg_buffer + i) != 0) {
#line 1288
      flag = 1L;
#line 1289
      goto while_break;
    }
#line 1286
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1292
  return ((int )flag);
}
}
#line 1299 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/interface/scsi_interface.c"
static int verify_read_command___1(cdrom_drive *d___0 ) 
{ 
  int i ;
  int j ;
  int k ;
  int audioflag ;
  int (*enablecommand)(struct cdrom_drive *d , int speed ) ;
  long (*readcommand)(struct cdrom_drive *d , void *p , long begin , long sectors ) ;
  unsigned char density ;
  int16_t *buff ;
  void *tmp ;
  long firstsector ;
  long tmp___0 ;
  long lastsector ;
  long tmp___1 ;
  long sector ;
  int tmp___2 ;
  long tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  char *es ;
  char *rs___0 ;
  int densitypossible ;
  int densityflag ;
  int rejectflag ;
  int zeroflag ;
  int lengthflag ;
  long firstsector___0 ;
  long tmp___6 ;
  long lastsector___0 ;
  long tmp___7 ;
  long sector___0 ;
  int tmp___8 ;
  long tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  char buffer[256] ;
  char buffer___0[256] ;
  char buffer___1[256] ;
  void *__cil_tmp39 ;
  void *__cil_tmp40 ;
  void *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;
  char *__cil_tmp52 ;
  char *__cil_tmp53 ;
  char *__cil_tmp54 ;
  char *__cil_tmp55 ;
  char *__cil_tmp56 ;
  char *__cil_tmp57 ;
  char *__cil_tmp58 ;
  char *__cil_tmp59 ;
  char *__cil_tmp60 ;
  char *__cil_tmp61 ;
  char *__cil_tmp62 ;
  char *__cil_tmp63 ;
  char *__cil_tmp64 ;
  char *__cil_tmp65 ;
  char *__cil_tmp66 ;
  char *__cil_tmp67 ;
  char *__cil_tmp68 ;
  char *__cil_tmp69 ;
  char *__cil_tmp70 ;
  char *__cil_tmp71 ;
  char *__cil_tmp72 ;
  char *__cil_tmp73 ;
  char *__cil_tmp74 ;
  char *__cil_tmp75 ;
  char *__cil_tmp76 ;
  char *__cil_tmp77 ;

  {
  {
#line 1301
  audioflag = 0;
#line 1308
  tmp = malloc((size_t )2352);
#line 1308
  buff = (int16_t *)tmp;
#line 1310
  cdmessage___2(d___0, "Verifying CDDA command set...\n");
#line 1315
  tmp___5 = (*(d___0->enable_cdda))(d___0, 1);
  }
#line 1315
  if (tmp___5 == 0) {
#line 1317
    i = 1;
    {
#line 1317
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1317
      if (! (i <= d___0->tracks)) {
#line 1317
        goto while_break;
      }
      {
#line 1318
      tmp___4 = cdda_track_audiop(d___0, i);
      }
#line 1318
      if (tmp___4 == 1) {
        {
#line 1319
        tmp___0 = cdda_track_firstsector(d___0, i);
#line 1319
        firstsector = tmp___0;
#line 1320
        tmp___1 = cdda_track_lastsector(d___0, i);
#line 1320
        lastsector = tmp___1;
#line 1321
        sector = (firstsector + lastsector) >> 1;
#line 1322
        audioflag = 1;
#line 1324
        tmp___3 = (*(d___0->read_audio))(d___0, (void *)buff, sector, 1L);
        }
#line 1324
        if (tmp___3 > 0L) {
          {
#line 1325
          tmp___2 = count_2352_bytes___0(d___0);
          }
#line 1325
          if (tmp___2 == 2352) {
            {
#line 1326
            cdmessage___2(d___0, "\tExpected command set reads OK.\n");
#line 1327
            (*(d___0->enable_cdda))(d___0, 0);
#line 1328
            free((void *)buff);
            }
#line 1329
            return (0);
          }
        }
      }
#line 1317
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 1335
    (*(d___0->enable_cdda))(d___0, 0);
    }
  }
#line 1337
  if (! audioflag) {
    {
#line 1338
    cdmessage___2(d___0, "\tCould not find any audio tracks on this disk.\n");
    }
#line 1339
    return (-403);
  }
  {
#line 1343
  es = (char *)"";
#line 1343
  rs___0 = (char *)"";
#line 1344
  d___0->bigendianp = -1;
#line 1345
  density = d___0->density;
#line 1346
  readcommand = d___0->read_audio;
#line 1347
  enablecommand = d___0->enable_cdda;
#line 1351
  cdmessage___2(d___0, "\tExpected command set FAILED!\n\tPerforming full probe for CDDA command set...\n");
#line 1361
  j = 0;
  }
  {
#line 1361
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1361
    if (! (j < 15)) {
#line 1361
      goto while_break___0;
    }
#line 1362
    densitypossible = 1;
    {
#line 1365
    if (j == 0) {
#line 1365
      goto case_0;
    }
#line 1369
    if (j == 1) {
#line 1369
      goto case_1;
    }
#line 1374
    if (j == 2) {
#line 1374
      goto case_2;
    }
#line 1379
    if (j == 3) {
#line 1379
      goto case_3;
    }
#line 1384
    if (j == 4) {
#line 1384
      goto case_4;
    }
#line 1390
    if (j == 5) {
#line 1390
      goto case_5;
    }
#line 1395
    if (j == 6) {
#line 1395
      goto case_6;
    }
#line 1400
    if (j == 7) {
#line 1400
      goto case_7;
    }
#line 1406
    if (j == 8) {
#line 1406
      goto case_8;
    }
#line 1411
    if (j == 9) {
#line 1411
      goto case_9;
    }
#line 1416
    if (j == 10) {
#line 1416
      goto case_10;
    }
#line 1422
    if (j == 11) {
#line 1422
      goto case_11;
    }
#line 1426
    if (j == 12) {
#line 1426
      goto case_12;
    }
#line 1430
    if (j == 13) {
#line 1430
      goto case_13;
    }
#line 1434
    if (j == 14) {
#line 1434
      goto case_14;
    }
#line 1364
    goto switch_break;
    case_0: /* CIL Label */ 
#line 1366
    d___0->read_audio = & scsi_read_28;
#line 1367
    rs___0 = (char *)"28 0x,00";
#line 1368
    goto switch_break;
    case_1: /* CIL Label */ 
#line 1370
    d___0->read_audio = & scsi_read_A8;
#line 1371
    rs___0 = (char *)"a8 0x,00";
#line 1372
    goto switch_break;
    case_2: /* CIL Label */ 
#line 1375
    d___0->read_audio = & scsi_read_mmcB;
#line 1376
    rs___0 = (char *)"be 02,10";
#line 1377
    densitypossible = 0;
#line 1378
    goto switch_break;
    case_3: /* CIL Label */ 
#line 1380
    d___0->read_audio = & scsi_read_mmc2B;
#line 1381
    rs___0 = (char *)"be 02,f8";
#line 1382
    densitypossible = 0;
#line 1383
    goto switch_break;
    case_4: /* CIL Label */ 
#line 1385
    d___0->read_audio = & scsi_read_mmc3B;
#line 1386
    rs___0 = (char *)"be 06,f8";
#line 1387
    densitypossible = 0;
#line 1388
    goto switch_break;
    case_5: /* CIL Label */ 
#line 1391
    d___0->read_audio = & scsi_read_mmc;
#line 1392
    rs___0 = (char *)"be 00,10";
#line 1393
    densitypossible = 0;
#line 1394
    goto switch_break;
    case_6: /* CIL Label */ 
#line 1396
    d___0->read_audio = & scsi_read_mmc2;
#line 1397
    rs___0 = (char *)"be 00,f8";
#line 1398
    densitypossible = 0;
#line 1399
    goto switch_break;
    case_7: /* CIL Label */ 
#line 1401
    d___0->read_audio = & scsi_read_mmc3;
#line 1402
    rs___0 = (char *)"be 04,f8";
#line 1403
    densitypossible = 0;
#line 1404
    goto switch_break;
    case_8: /* CIL Label */ 
#line 1407
    d___0->read_audio = & scsi_read_msf;
#line 1408
    rs___0 = (char *)"b9 00,10";
#line 1409
    densitypossible = 0;
#line 1410
    goto switch_break;
    case_9: /* CIL Label */ 
#line 1412
    d___0->read_audio = & scsi_read_msf2;
#line 1413
    rs___0 = (char *)"b9 00,f8";
#line 1414
    densitypossible = 0;
#line 1415
    goto switch_break;
    case_10: /* CIL Label */ 
#line 1417
    d___0->read_audio = & scsi_read_msf3;
#line 1418
    rs___0 = (char *)"b9 04,f8";
#line 1419
    densitypossible = 0;
#line 1420
    goto switch_break;
    case_11: /* CIL Label */ 
#line 1423
    d___0->read_audio = & scsi_read_D4_10;
#line 1424
    rs___0 = (char *)"d4(10)0x";
#line 1425
    goto switch_break;
    case_12: /* CIL Label */ 
#line 1427
    d___0->read_audio = & scsi_read_D4_12;
#line 1428
    rs___0 = (char *)"d4(12)0x";
#line 1429
    goto switch_break;
    case_13: /* CIL Label */ 
#line 1431
    d___0->read_audio = & scsi_read_D5;
#line 1432
    rs___0 = (char *)"d5 0x,00";
#line 1433
    goto switch_break;
    case_14: /* CIL Label */ 
#line 1435
    d___0->read_audio = & scsi_read_D8;
#line 1436
    rs___0 = (char *)"d8 0x,00";
#line 1437
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 1440
    i = 0;
    {
#line 1440
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1440
      if (! (i < 5)) {
#line 1440
        goto while_break___1;
      }
      {
#line 1442
      if (i == 0) {
#line 1442
        goto case_0___0;
      }
#line 1448
      if (i == 1) {
#line 1448
        goto case_1___0;
      }
#line 1453
      if (i == 2) {
#line 1453
        goto case_2___0;
      }
#line 1458
      if (i == 3) {
#line 1458
        goto case_3___0;
      }
#line 1463
      if (i == 4) {
#line 1463
        goto case_4___0;
      }
#line 1441
      goto switch_break___0;
      case_0___0: /* CIL Label */ 
#line 1443
      d___0->density = (unsigned char)0;
#line 1444
      d___0->enable_cdda = & Dummy___1;
#line 1445
      es = (char *)"none    ";
#line 1446
      if (! densitypossible) {
#line 1446
        i = 5;
      }
#line 1447
      goto switch_break___0;
      case_1___0: /* CIL Label */ 
#line 1449
      d___0->density = (unsigned char)0;
#line 1450
      d___0->enable_cdda = & scsi_enable_cdda;
#line 1451
      es = (char *)"yes/0x00";
#line 1452
      goto switch_break___0;
      case_2___0: /* CIL Label */ 
#line 1454
      d___0->density = (unsigned char)4;
#line 1455
      d___0->enable_cdda = & scsi_enable_cdda;
#line 1456
      es = (char *)"yes/0x04";
#line 1457
      goto switch_break___0;
      case_3___0: /* CIL Label */ 
#line 1459
      d___0->density = (unsigned char)130;
#line 1460
      d___0->enable_cdda = & scsi_enable_cdda;
#line 1461
      es = (char *)"yes/0x82";
#line 1462
      goto switch_break___0;
      case_4___0: /* CIL Label */ 
#line 1464
      d___0->density = (unsigned char)129;
#line 1465
      d___0->enable_cdda = & scsi_enable_cdda;
#line 1466
      es = (char *)"yes/0x81";
#line 1467
      goto switch_break___0;
      switch_break___0: /* CIL Label */ ;
      }
      {
#line 1470
      cdmessage___2(d___0, "\ttest -> density: [");
#line 1471
      cdmessage___2(d___0, (char const   *)es);
#line 1472
      cdmessage___2(d___0, "]  command: [");
#line 1473
      cdmessage___2(d___0, (char const   *)rs___0);
#line 1474
      cdmessage___2(d___0, "]\n");
#line 1477
      densityflag = 0;
#line 1478
      rejectflag = 0;
#line 1479
      zeroflag = 0;
#line 1480
      lengthflag = 0;
#line 1482
      tmp___11 = (*(d___0->enable_cdda))(d___0, 1);
      }
#line 1482
      if (tmp___11 == 0) {
#line 1483
        k = 1;
        {
#line 1483
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 1483
          if (! (k <= d___0->tracks)) {
#line 1483
            goto while_break___2;
          }
          {
#line 1484
          tmp___10 = cdda_track_audiop(d___0, k);
          }
#line 1484
          if (tmp___10 == 1) {
            {
#line 1485
            tmp___6 = cdda_track_firstsector(d___0, k);
#line 1485
            firstsector___0 = tmp___6;
#line 1486
            tmp___7 = cdda_track_lastsector(d___0, k);
#line 1486
            lastsector___0 = tmp___7;
#line 1487
            sector___0 = (firstsector___0 + lastsector___0) >> 1;
#line 1489
            tmp___9 = (*(d___0->read_audio))(d___0, (void *)buff, sector___0, 1L);
            }
#line 1489
            if (tmp___9 > 0L) {
              {
#line 1490
              lengthflag = count_2352_bytes___0(d___0);
              }
#line 1490
              if (lengthflag == 2352) {
                {
#line 1491
                tmp___8 = verify_nonzero___0(d___0);
                }
#line 1491
                if (tmp___8) {
                  {
#line 1492
                  cdmessage___2(d___0, "\t\tCommand set FOUND!\n");
#line 1494
                  free((void *)buff);
#line 1495
                  (*(d___0->enable_cdda))(d___0, 0);
                  }
#line 1496
                  return (0);
                } else {
#line 1498
                  zeroflag ++;
                }
              }
            } else {
#line 1502
              rejectflag ++;
#line 1503
              goto while_break___2;
            }
          }
#line 1483
          k ++;
        }
        while_break___2: /* CIL Label */ ;
        }
        {
#line 1507
        (*(d___0->enable_cdda))(d___0, 0);
        }
      } else {
#line 1509
        densityflag ++;
      }
#line 1512
      if (densityflag) {
        {
#line 1513
        cdmessage___2(d___0, "\t\tDrive rejected density set\n");
        }
      }
#line 1514
      if (rejectflag) {
        {
#line 1516
        sprintf((char */* __restrict  */)(buffer), (char const   */* __restrict  */)"\t\tDrive rejected read command packet(s)\n");
#line 1517
        cdmessage___2(d___0, (char const   *)(buffer));
        }
      }
#line 1519
      if (lengthflag > 0) {
#line 1519
        if (lengthflag < 2352) {
          {
#line 1521
          sprintf((char */* __restrict  */)(buffer___0), (char const   */* __restrict  */)"\t\tDrive returned at least one packet, but with\n\t\tincorrect size (%d)\n",
                  lengthflag);
#line 1523
          cdmessage___2(d___0, (char const   *)(buffer___0));
          }
        }
      }
#line 1525
      if (zeroflag) {
        {
#line 1527
        sprintf((char */* __restrict  */)(buffer___1), (char const   */* __restrict  */)"\t\tDrive returned %d packet(s), but contents\n\t\twere entirely zero\n",
                zeroflag);
#line 1529
        cdmessage___2(d___0, (char const   *)(buffer___1));
        }
      }
#line 1440
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 1361
    j ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 1536
  d___0->density = density;
#line 1537
  d___0->read_audio = readcommand;
#line 1538
  d___0->enable_cdda = enablecommand;
#line 1540
  cdmessage___2(d___0, "\tUnable to find any suitable command set from probe;\n\tdrive probably not CDDA capable.\n");
#line 1543
  cderror___4(d___0, "006: Could not read any data from drive\n");
#line 1546
  free((void *)buff);
  }
#line 1547
  return (-6);
}
}
#line 1550 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/interface/scsi_interface.c"
static void check_cache___0(cdrom_drive *d___0 ) 
{ 
  long i ;
  long firstsector ;
  long tmp ;
  long lastsector ;
  long tmp___0 ;
  long sector ;
  long tmp___1 ;
  int tmp___2 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;

  {
#line 1553
  if (! ((unsigned long )d___0->read_audio == (unsigned long )(& scsi_read_mmc))) {
#line 1553
    if (! ((unsigned long )d___0->read_audio == (unsigned long )(& scsi_read_mmc2))) {
#line 1553
      if (! ((unsigned long )d___0->read_audio == (unsigned long )(& scsi_read_mmc3))) {
#line 1553
        if (! ((unsigned long )d___0->read_audio == (unsigned long )(& scsi_read_mmcB))) {
#line 1553
          if (! ((unsigned long )d___0->read_audio == (unsigned long )(& scsi_read_mmc2B))) {
#line 1553
            if (! ((unsigned long )d___0->read_audio == (unsigned long )(& scsi_read_mmc3B))) {
              {
#line 1560
              cdmessage___2(d___0, "This command set may use a Force Unit Access bit.");
#line 1561
              cdmessage___2(d___0, "\nChecking drive for FUA bit support...\n");
#line 1563
              (*(d___0->enable_cdda))(d___0, 1);
#line 1564
              d___0->fua = 1;
#line 1566
              i = 1L;
              }
              {
#line 1566
              while (1) {
                while_continue: /* CIL Label */ ;
#line 1566
                if (! (i <= (long )d___0->tracks)) {
#line 1566
                  goto while_break;
                }
                {
#line 1567
                tmp___2 = cdda_track_audiop(d___0, (int )i);
                }
#line 1567
                if (tmp___2 == 1) {
                  {
#line 1568
                  tmp = cdda_track_firstsector(d___0, (int )i);
#line 1568
                  firstsector = tmp;
#line 1569
                  tmp___0 = cdda_track_lastsector(d___0, (int )i);
#line 1569
                  lastsector = tmp___0;
#line 1570
                  sector = (firstsector + lastsector) >> 1;
#line 1572
                  tmp___1 = (*(d___0->read_audio))(d___0, (void *)0, sector, 1L);
                  }
#line 1572
                  if (tmp___1 > 0L) {
                    {
#line 1573
                    cdmessage___2(d___0, "\tDrive accepted FUA bit.\n");
#line 1574
                    (*(d___0->enable_cdda))(d___0, 0);
                    }
#line 1575
                    return;
                  }
                }
#line 1566
                i ++;
              }
              while_break: /* CIL Label */ ;
              }
              {
#line 1580
              d___0->fua = 0;
#line 1581
              cdmessage___2(d___0, "\tDrive rejected FUA bit.\n");
              }
#line 1586
              return;
            }
          }
        }
      }
    }
  }
#line 1588
  return;
}
}
#line 1590 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/interface/scsi_interface.c"
static int check_atapi___0(cdrom_drive *d___0 ) 
{ 
  int atapiret ;
  int fd ;
  int tmp ;
  int tmp___0 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;

  {
  {
#line 1591
  atapiret = -1;
#line 1592
  fd = d___0->cdda_fd;
#line 1594
  cdmessage___2(d___0, "\nChecking for SCSI emulation...\n");
#line 1596
  tmp___0 = ioctl(fd, 8707UL, & atapiret);
  }
#line 1596
  if (tmp___0) {
    {
#line 1597
    cderror___4(d___0, "\tSG_EMULATED_HOST ioctl() failed!\n");
    }
#line 1598
    return (-1);
  } else {
#line 1600
    if (atapiret == 1) {
#line 1601
      if (d___0->interface == 3) {
        {
#line 1602
        cdmessage___2(d___0, "\tDrive is ATAPI (using SG_IO host adaptor emulation)\n");
        }
      } else
#line 1603
      if (d___0->interface == 4) {
        {
#line 1604
        cdmessage___2(d___0, "\tDrive is ATAPI (using SG_IO host adaptor emulation with workarounds)\n");
        }
      } else {
        {
#line 1606
        cdmessage___2(d___0, "\tDrive is ATAPI (using SCSI host adaptor emulation)\n");
#line 1608
        tmp = ioctl(fd, 8708UL, 0);
        }
#line 1608
        if (tmp) {
          {
#line 1609
          cderror___4(d___0, "\tCouldn\'t disable kernel command translation layer\n");
          }
        }
      }
#line 1611
      d___0->is_atapi = 1;
    } else {
      {
#line 1613
      cdmessage___2(d___0, "\tDrive is SCSI\n");
#line 1614
      d___0->is_atapi = 0;
      }
    }
#line 1617
    return (d___0->is_atapi);
  }
}
}
#line 1621 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/interface/scsi_interface.c"
static int check_mmc___0(cdrom_drive *d___0 ) 
{ 
  unsigned char *b ;
  int tmp ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
  {
#line 1623
  cdmessage___2(d___0, "\nChecking for MMC style command set...\n");
#line 1625
  d___0->is_mmc = 0;
#line 1626
  tmp = mode_sense___0(d___0, 22, 42);
  }
#line 1626
  if (tmp == 0) {
#line 1628
    b = (d___0->private)->sg_buffer;
#line 1629
    b += (int )*(b + 3) + 4;
#line 1631
    if (((int )*(b + 0) & 63) == 42) {
#line 1633
      d___0->is_mmc = 1;
#line 1635
      if ((int )*(b + 1) >= 4) {
#line 1636
        if ((int )*(b + 5) & 1) {
          {
#line 1637
          cdmessage___2(d___0, "\tDrive is MMC style\n");
          }
#line 1638
          return (1);
        } else {
          {
#line 1640
          cdmessage___2(d___0, "\tDrive is MMC, but reports CDDA incapable.\n");
#line 1641
          cdmessage___2(d___0, "\tIt will likely not be able to read audio data.\n");
          }
#line 1642
          return (1);
        }
      }
    }
  }
  {
#line 1648
  cdmessage___2(d___0, "\tDrive does not have MMC CDDA support\n");
  }
#line 1649
  return (0);
}
}
#line 1652 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/interface/scsi_interface.c"
static void check_exceptions___1(cdrom_drive *d___0 , exception *list ) 
{ 
  int i ;
  size_t tmp ;
  int tmp___0 ;

  {
#line 1654
  i = 0;
  {
#line 1655
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1655
    if (! (list + i)->model) {
#line 1655
      goto while_break;
    }
    {
#line 1656
    tmp = strlen((char const   *)(list + i)->model);
#line 1656
    tmp___0 = strncmp((char const   *)(list + i)->model, (char const   *)d___0->drive_model,
                      tmp);
    }
#line 1656
    if (! tmp___0) {
#line 1657
      if ((list + i)->density) {
#line 1657
        d___0->density = (list + i)->density;
      }
#line 1658
      if ((list + i)->enable) {
#line 1658
        d___0->enable_cdda = (list + i)->enable;
      }
#line 1659
      if ((list + i)->read) {
#line 1659
        d___0->read_audio = (list + i)->read;
      }
#line 1660
      if ((list + i)->bigendianp != -1) {
#line 1660
        d___0->bigendianp = (list + i)->bigendianp;
      }
#line 1661
      return;
    }
#line 1663
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1665
  return;
}
}
#line 104 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/interface/utils.h"
static void cderror___5(cdrom_drive *d___0 , char const   *s ) 
{ 
  size_t tmp ;

  {
#line 105
  if (s) {
#line 105
    if (d___0) {
      {
#line 107
      if (d___0->errordest == 1) {
#line 107
        goto case_1;
      }
#line 110
      if (d___0->errordest == 2) {
#line 110
        goto case_2;
      }
#line 114
      goto switch_default;
      case_1: /* CIL Label */ 
      {
#line 108
      tmp = strlen(s);
#line 108
      write(2, (void const   *)s, tmp);
      }
#line 109
      goto switch_break;
      case_2: /* CIL Label */ 
      {
#line 111
      d___0->errorbuf = catstring(d___0->errorbuf, s);
      }
#line 112
      goto switch_break;
      switch_default: /* CIL Label */ 
#line 115
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    }
  }
#line 118
  return;
}
}
#line 21 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/interface/interface.c"
static void _clean_messages___0(cdrom_drive *d___0 ) 
{ 


  {
#line 22
  if (d___0) {
#line 23
    if (d___0->messagebuf) {
      {
#line 23
      free((void *)d___0->messagebuf);
      }
    }
#line 24
    if (d___0->errorbuf) {
      {
#line 24
      free((void *)d___0->errorbuf);
      }
    }
#line 25
    d___0->messagebuf = (char *)((void *)0);
#line 26
    d___0->errorbuf = (char *)((void *)0);
  }
#line 28
  return;
}
}
#line 104 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/interface/utils.h"
static void cderror___6(cdrom_drive *d___0 , char const   *s ) 
{ 
  size_t tmp ;

  {
#line 105
  if (s) {
#line 105
    if (d___0) {
      {
#line 107
      if (d___0->errordest == 1) {
#line 107
        goto case_1;
      }
#line 110
      if (d___0->errordest == 2) {
#line 110
        goto case_2;
      }
#line 114
      goto switch_default;
      case_1: /* CIL Label */ 
      {
#line 108
      tmp = strlen(s);
#line 108
      write(2, (void const   *)s, tmp);
      }
#line 109
      goto switch_break;
      case_2: /* CIL Label */ 
      {
#line 111
      d___0->errorbuf = catstring(d___0->errorbuf, s);
      }
#line 112
      goto switch_break;
      switch_default: /* CIL Label */ 
#line 115
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    }
  }
#line 118
  return;
}
}
#line 120 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/interface/utils.h"
static void cdmessage___3(cdrom_drive *d___0 , char const   *s ) 
{ 
  size_t tmp ;

  {
#line 121
  if (s) {
#line 121
    if (d___0) {
      {
#line 123
      if (d___0->messagedest == 1) {
#line 123
        goto case_1;
      }
#line 126
      if (d___0->messagedest == 2) {
#line 126
        goto case_2;
      }
#line 130
      goto switch_default;
      case_1: /* CIL Label */ 
      {
#line 124
      tmp = strlen(s);
#line 124
      write(2, (void const   *)s, tmp);
      }
#line 125
      goto switch_break;
      case_2: /* CIL Label */ 
      {
#line 127
      d___0->messagebuf = catstring(d___0->messagebuf, s);
      }
#line 128
      goto switch_break;
      switch_default: /* CIL Label */ 
#line 131
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    }
  }
#line 134
  return;
}
}
#line 13 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/interface/cooked_interface.c"
static int timed_ioctl___2(cdrom_drive *d___0 , int fd , int command , void *arg ) 
{ 
  struct timespec tv1 ;
  struct timespec tv2 ;
  int ret1 ;
  int tmp ;
  int ret2 ;
  int tmp___0 ;
  int ret3 ;
  int tmp___1 ;

  {
  {
#line 16
  tmp = clock_gettime((d___0->private)->clock, & tv1);
#line 16
  ret1 = tmp;
#line 17
  tmp___0 = ioctl(fd, (unsigned long )command, arg);
#line 17
  ret2 = tmp___0;
#line 18
  tmp___1 = clock_gettime((d___0->private)->clock, & tv2);
#line 18
  ret3 = tmp___1;
  }
#line 19
  if (ret1 < 0) {
#line 20
    (d___0->private)->last_milliseconds = -1;
  } else
#line 19
  if (ret3 < 0) {
#line 20
    (d___0->private)->last_milliseconds = -1;
  } else {
#line 22
    (d___0->private)->last_milliseconds = (int )((double )(tv2.tv_sec - tv1.tv_sec) * 1000. + (double )(tv2.tv_nsec - tv1.tv_nsec) / 1000000.);
  }
#line 24
  return (ret2);
}
}
#line 27 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/interface/cooked_interface.c"
static int cooked_readtoc___0(cdrom_drive *d___0 ) 
{ 
  int i ;
  int tracks ;
  struct cdrom_tochdr hdr ;
  struct cdrom_tocentry entry ;
  int *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;

  {
  {
#line 34
  tmp___0 = ioctl(d___0->ioctl_fd, 21253UL, & hdr);
  }
#line 34
  if (tmp___0) {
    {
#line 35
    tmp = __errno_location();
    }
    {
#line 36
    if (*tmp == 1) {
#line 36
      goto case_1;
    }
#line 39
    goto switch_default;
    case_1: /* CIL Label */ 
    {
#line 37
    cderror___6(d___0, "102: Permision denied on cdrom (ioctl) device\n");
    }
#line 38
    return (-102);
    switch_default: /* CIL Label */ 
    {
#line 40
    cderror___6(d___0, "004: Unable to read table of contents header\n");
    }
#line 41
    return (-4);
    switch_break: /* CIL Label */ ;
    }
  }
#line 45
  i = 0;
  {
#line 45
  while (1) {
    while_continue: /* CIL Label */ ;
#line 45
    if (! (i < (int )hdr.cdth_trk1)) {
#line 45
      goto while_break;
    }
    {
#line 46
    entry.cdte_track = (__u8 )(i + 1);
#line 47
    entry.cdte_format = (__u8 )1;
#line 48
    tmp___1 = ioctl(d___0->ioctl_fd, 21254UL, & entry);
    }
#line 48
    if (tmp___1) {
      {
#line 49
      cderror___6(d___0, "005: Unable to read table of contents entry\n");
      }
#line 50
      return (-5);
    }
#line 53
    d___0->disc_toc[i].bFlags = (unsigned char )(((int )entry.cdte_adr << 4) | ((int )entry.cdte_ctrl & 15));
#line 54
    d___0->disc_toc[i].bTrack = (unsigned char )(i + 1);
#line 55
    d___0->disc_toc[i].dwStartSector = entry.cdte_addr.lba;
#line 45
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 58
  entry.cdte_track = (__u8 )170;
#line 59
  entry.cdte_format = (__u8 )1;
#line 60
  tmp___2 = ioctl(d___0->ioctl_fd, 21254UL, & entry);
  }
#line 60
  if (tmp___2) {
    {
#line 61
    cderror___6(d___0, "005: Unable to read table of contents entry\n");
    }
#line 62
    return (-5);
  }
  {
#line 64
  d___0->disc_toc[i].bFlags = (unsigned char )(((int )entry.cdte_adr << 4) | ((int )entry.cdte_ctrl & 15));
#line 65
  d___0->disc_toc[i].bTrack = entry.cdte_track;
#line 66
  d___0->disc_toc[i].dwStartSector = entry.cdte_addr.lba;
#line 68
  tracks = (int )hdr.cdth_trk1 + 1;
#line 69
  d___0->cd_extra = FixupTOC(d___0, tracks);
#line 70
  tracks --;
  }
#line 70
  return (tracks);
}
}
#line 74 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/interface/cooked_interface.c"
static int cooked_setspeed___0(cdrom_drive *d___0 , int speed ) 
{ 
  int tmp ;

  {
#line 76
  if (d___0->ioctl_fd != -1) {
    {
#line 77
    tmp = ioctl(d___0->ioctl_fd, 21282UL, speed);
    }
#line 77
    return (tmp);
  } else {
#line 79
    return (0);
  }
}
}
#line 86 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/interface/cooked_interface.c"
static long cooked_read___0(cdrom_drive *d___0 , void *p___0 , long begin , long sectors ) 
{ 
  int retry_count ;
  int err ;
  int ret ;
  struct cdrom_read_audio arg ;
  char *buffer ;
  void *tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  char b[256] ;
  void *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;

  {
#line 87
  ret = 0;
#line 89
  buffer = (char *)p___0;
#line 92
  if (sectors > (long )d___0->nsectors) {
#line 92
    sectors = (long )d___0->nsectors;
  } else {
#line 92
    sectors = sectors;
  }
#line 93
  if ((unsigned long )p___0 == (unsigned long )((void *)0)) {
    {
#line 93
    tmp = malloc((size_t )(sectors * 2352L));
#line 93
    buffer = (char *)tmp;
    }
  }
#line 95
  arg.addr.lba = (int )begin;
#line 96
  arg.addr_format = (__u8 )1;
#line 97
  arg.nframes = (int )sectors;
#line 98
  arg.buf = (__u8 *)buffer;
#line 99
  retry_count = 0;
  {
#line 101
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 102
    err = timed_ioctl___2(d___0, d___0->ioctl_fd, 21262, (void *)(& arg));
    }
#line 102
    if (err) {
#line 103
      if (! d___0->error_retry) {
#line 104
        ret = -7;
#line 105
        goto done;
      }
      {
#line 107
      tmp___0 = __errno_location();
      }
      {
#line 108
      if (*tmp___0 == 12) {
#line 108
        goto case_12;
      }
#line 118
      if (*tmp___0 == 123) {
#line 118
        goto case_123;
      }
#line 118
      if (*tmp___0 == 9) {
#line 118
        goto case_123;
      }
#line 118
      if (*tmp___0 == 6) {
#line 118
        goto case_123;
      }
#line 122
      goto switch_default;
      case_12: /* CIL Label */ 
#line 110
      if (sectors == 1L) {
        {
#line 112
        cderror___6(d___0, "300: Kernel memory error\n");
#line 113
        ret = -300;
        }
#line 114
        goto done;
      }
      case_123: /* CIL Label */ 
      case_9: /* CIL Label */ 
      case_6: /* CIL Label */ 
      {
#line 119
      tmp___1 = __errno_location();
#line 119
      *tmp___1 = 123;
#line 120
      ret = 0;
      }
#line 121
      goto done;
      switch_default: /* CIL Label */ 
#line 123
      if (sectors == 1L) {
#line 129
        if (retry_count > 7) {
          {
#line 131
          sprintf((char */* __restrict  */)(b), (char const   */* __restrict  */)"010: Unable to access sector %ld: skipping...\n",
                  begin);
#line 133
          cderror___6(d___0, (char const   *)(b));
#line 134
          ret = -10;
          }
#line 135
          goto done;
        }
#line 137
        goto switch_break;
      }
      switch_break: /* CIL Label */ ;
      }
#line 140
      if (retry_count > 4) {
#line 141
        if (sectors > 1L) {
#line 142
          sectors = (sectors * 3L) / 4L;
        }
      }
#line 143
      retry_count ++;
#line 144
      if (retry_count > 8) {
        {
#line 145
        cderror___6(d___0, "007: Unknown, unrecoverable error reading data\n");
#line 146
        ret = -7;
        }
#line 147
        goto done;
      }
    } else {
#line 150
      goto while_break;
    }
#line 101
    if (! err) {
#line 101
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 153
  ret = (int )sectors;
  done: 
#line 156
  if ((unsigned long )p___0 == (unsigned long )((void *)0)) {
#line 156
    if (buffer) {
      {
#line 156
      free((void *)buffer);
      }
    }
  }
#line 157
  return ((long )ret);
}
}
#line 161 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/interface/cooked_interface.c"
static int Dummy___2(cdrom_drive *d___0 , int Switch ) 
{ 


  {
#line 162
  return (0);
}
}
#line 165 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/interface/cooked_interface.c"
static int verify_read_command___2(cdrom_drive *d___0 ) 
{ 
  int i ;
  int16_t *buff ;
  void *tmp ;
  int audioflag ;
  long firstsector ;
  long tmp___0 ;
  long lastsector ;
  long tmp___1 ;
  long sector ;
  long tmp___2 ;
  int tmp___3 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;

  {
  {
#line 167
  tmp = malloc((size_t )2352);
#line 167
  buff = (int16_t *)tmp;
#line 168
  audioflag = 0;
#line 170
  cdmessage___3(d___0, "Verifying drive can read CDDA...\n");
#line 172
  (*(d___0->enable_cdda))(d___0, 1);
#line 174
  i = 1;
  }
  {
#line 174
  while (1) {
    while_continue: /* CIL Label */ ;
#line 174
    if (! (i <= d___0->tracks)) {
#line 174
      goto while_break;
    }
    {
#line 175
    tmp___3 = cdda_track_audiop(d___0, i);
    }
#line 175
    if (tmp___3 == 1) {
      {
#line 176
      tmp___0 = cdda_track_firstsector(d___0, i);
#line 176
      firstsector = tmp___0;
#line 177
      tmp___1 = cdda_track_lastsector(d___0, i);
#line 177
      lastsector = tmp___1;
#line 178
      sector = (firstsector + lastsector) >> 1;
#line 179
      audioflag = 1;
#line 181
      tmp___2 = (*(d___0->read_audio))(d___0, (void *)buff, sector, 1L);
      }
#line 181
      if (tmp___2 > 0L) {
        {
#line 182
        cdmessage___3(d___0, "\tExpected command set reads OK.\n");
#line 183
        (*(d___0->enable_cdda))(d___0, 0);
#line 184
        free((void *)buff);
        }
#line 185
        return (0);
      }
    }
#line 174
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 190
  (*(d___0->enable_cdda))(d___0, 0);
  }
#line 192
  if (! audioflag) {
    {
#line 193
    cdmessage___3(d___0, "\tCould not find any audio tracks on this disk.\n");
    }
#line 194
    return (-403);
  }
  {
#line 197
  cdmessage___3(d___0, "\n\tUnable to read any data; drive probably not CDDA capable.\n");
#line 200
  cderror___6(d___0, "006: Could not read any data from drive\n");
#line 202
  free((void *)buff);
  }
#line 203
  return (-6);
}
}
#line 24 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/interface/drive_exceptions.h"
static exception atapi_list___2[5]  = {      {(char *)"SAMSUNG SCR-830 REV 2.09 2.09 ", 1, (unsigned char)0, & Dummy___2,
      & scsi_read_mmc2, 0}, 
        {(char *)"Memorex CR-622", 1, (unsigned char)0, & Dummy___2, (long (*)(struct cdrom_drive * ,
                                                                            void * ,
                                                                            long  ,
                                                                            long  ))((void *)0),
      0}, 
        {(char *)"SONY CD-ROM CDU-561", 0, (unsigned char)0, & Dummy___2, (long (*)(struct cdrom_drive * ,
                                                                                 void * ,
                                                                                 long  ,
                                                                                 long  ))((void *)0),
      0}, 
        {(char *)"Chinon CD-ROM CDS-525", 0, (unsigned char)0, & Dummy___2, (long (*)(struct cdrom_drive * ,
                                                                                   void * ,
                                                                                   long  ,
                                                                                   long  ))((void *)0),
      0}, 
        {(char *)((void *)0), 0, (unsigned char)0, (int (*)(struct cdrom_drive * , int  ))((void *)0),
      (long (*)(struct cdrom_drive * , void * , long  , long  ))((void *)0), 0}};
#line 208 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/interface/cooked_interface.c"
static void check_exceptions___2(cdrom_drive *d___0 , exception *list ) 
{ 
  int i ;
  size_t tmp ;
  int tmp___0 ;

  {
#line 210
  i = 0;
  {
#line 211
  while (1) {
    while_continue: /* CIL Label */ ;
#line 211
    if (! (list + i)->model) {
#line 211
      goto while_break;
    }
    {
#line 212
    tmp = strlen((char const   *)(list + i)->model);
#line 212
    tmp___0 = strncmp((char const   *)(list + i)->model, (char const   *)d___0->drive_model,
                      tmp);
    }
#line 212
    if (! tmp___0) {
#line 213
      if ((list + i)->bigendianp != -1) {
#line 213
        d___0->bigendianp = (list + i)->bigendianp;
      }
#line 214
      return;
    }
#line 216
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 218
  return;
}
}
#line 120 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/interface/utils.h"
static void cdmessage___4(cdrom_drive *d___0 , char const   *s ) 
{ 
  size_t tmp ;

  {
#line 121
  if (s) {
#line 121
    if (d___0) {
      {
#line 123
      if (d___0->messagedest == 1) {
#line 123
        goto case_1;
      }
#line 126
      if (d___0->messagedest == 2) {
#line 126
        goto case_2;
      }
#line 130
      goto switch_default;
      case_1: /* CIL Label */ 
      {
#line 124
      tmp = strlen(s);
#line 124
      write(2, (void const   *)s, tmp);
      }
#line 125
      goto switch_break;
      case_2: /* CIL Label */ 
      {
#line 127
      d___0->messagebuf = catstring(d___0->messagebuf, s);
      }
#line 128
      goto switch_break;
      switch_default: /* CIL Label */ 
#line 131
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    }
  }
#line 134
  return;
}
}
#line 136 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/interface/utils.h"
static void idperror___0(int messagedest , char **messages , char const   *f , char const   *s ) 
{ 
  char *buffer ;
  int malloced ;
  size_t tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;
  size_t tmp___2 ;
  int *tmp___3 ;
  char *tmp___4 ;
  size_t tmp___5 ;
  int *tmp___6 ;
  char *tmp___7 ;
  int *tmp___8 ;
  int *tmp___9 ;
  char *tmp___10 ;
  int *tmp___11 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;

  {
#line 140
  malloced = 0;
#line 141
  if (! f) {
#line 142
    buffer = (char *)s;
  } else
#line 144
  if (! s) {
#line 145
    buffer = (char *)f;
  } else {
    {
#line 147
    tmp = strlen(f);
#line 147
    tmp___0 = strlen(s);
#line 147
    tmp___1 = malloc((tmp + tmp___0) + 9U);
#line 147
    buffer = (char *)tmp___1;
#line 148
    sprintf((char */* __restrict  */)buffer, (char const   */* __restrict  */)f, s);
#line 149
    malloced = 1;
    }
  }
#line 152
  if (buffer) {
    {
#line 154
    if (messagedest == 1) {
#line 154
      goto case_1;
    }
#line 162
    if (messagedest == 2) {
#line 162
      goto case_2;
    }
#line 173
    goto switch_default;
    case_1: /* CIL Label */ 
    {
#line 155
    tmp___2 = strlen((char const   *)buffer);
#line 155
    write(2, (void const   *)buffer, tmp___2);
#line 156
    tmp___8 = __errno_location();
    }
#line 156
    if (*tmp___8) {
      {
#line 157
      write(2, (void const   *)": ", (size_t )2);
#line 158
      tmp___3 = __errno_location();
#line 158
      tmp___4 = strerror(*tmp___3);
#line 158
      tmp___5 = strlen((char const   *)tmp___4);
#line 158
      tmp___6 = __errno_location();
#line 158
      tmp___7 = strerror(*tmp___6);
#line 158
      write(2, (void const   *)tmp___7, tmp___5);
#line 159
      write(2, (void const   *)"\n", (size_t )1);
      }
    }
#line 161
    goto switch_break;
    case_2: /* CIL Label */ 
#line 163
    if (messages) {
      {
#line 164
      *messages = catstring(*messages, (char const   *)buffer);
#line 165
      tmp___11 = __errno_location();
      }
#line 165
      if (*tmp___11) {
        {
#line 166
        *messages = catstring(*messages, ": ");
#line 167
        tmp___9 = __errno_location();
#line 167
        tmp___10 = strerror(*tmp___9);
#line 167
        *messages = catstring(*messages, (char const   *)tmp___10);
#line 168
        *messages = catstring(*messages, "\n");
        }
      }
    }
#line 171
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 174
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
#line 177
  if (malloced) {
    {
#line 177
    free((void *)buffer);
    }
  }
#line 178
  return;
}
}
#line 181 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/interface/utils.h"
static void idmessage___0(int messagedest , char **messages , char const   *f , char const   *s ) 
{ 
  char *buffer ;
  int malloced ;
  size_t tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;
  size_t tmp___2 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;

  {
#line 184
  malloced = 0;
#line 185
  if (! f) {
#line 186
    buffer = (char *)s;
  } else
#line 188
  if (! s) {
#line 189
    buffer = (char *)f;
  } else {
    {
#line 191
    tmp = strlen(f);
#line 191
    tmp___0 = strlen(s);
#line 191
    tmp___1 = malloc((tmp + tmp___0) + 10U);
#line 191
    buffer = (char *)tmp___1;
#line 192
    sprintf((char */* __restrict  */)buffer, (char const   */* __restrict  */)f, s);
#line 193
    strcat((char */* __restrict  */)buffer, (char const   */* __restrict  */)"\n");
#line 194
    malloced = 1;
    }
  }
#line 197
  if (buffer) {
    {
#line 199
    if (messagedest == 1) {
#line 199
      goto case_1;
    }
#line 203
    if (messagedest == 2) {
#line 203
      goto case_2;
    }
#line 210
    goto switch_default;
    case_1: /* CIL Label */ 
    {
#line 200
    tmp___2 = strlen((char const   *)buffer);
#line 200
    write(2, (void const   *)buffer, tmp___2);
    }
#line 201
    if (! malloced) {
      {
#line 201
      write(2, (void const   *)"\n", (size_t )1);
      }
    }
#line 202
    goto switch_break;
    case_2: /* CIL Label */ 
#line 204
    if (messages) {
      {
#line 205
      *messages = catstring(*messages, (char const   *)buffer);
      }
#line 206
      if (! malloced) {
        {
#line 206
        *messages = catstring(*messages, "\n");
        }
      }
    }
#line 208
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 211
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
#line 214
  if (malloced) {
    {
#line 214
    free((void *)buffer);
    }
  }
#line 215
  return;
}
}
#line 27 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/interface/scan_devices.c"
static char *scsi_cdrom_prefixes___0[3]  = {      (char *)"/dev/scd",      (char *)"/dev/sr",      (char *)((void *)0)};
#line 31 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/interface/scan_devices.c"
static char *scsi_generic_prefixes___0[2]  = {      (char *)"/dev/sg",      (char *)((void *)0)};
#line 35 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/interface/scan_devices.c"
static char *devfs_scsi_test___0  =    (char *)"/dev/scsi/";
#line 36 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/interface/scan_devices.c"
static char *devfs_scsi_cd___0  =    (char *)"cd";
#line 37 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/interface/scan_devices.c"
static char *devfs_scsi_generic___0  =    (char *)"generic";
#line 39 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/interface/scan_devices.c"
static char *cdrom_devices___0[15]  = 
#line 39
  {      (char *)"/dev/cdrom",      (char *)"/dev/cdroms/cdrom?",      (char *)"/dev/hd?",      (char *)"/dev/sg?", 
        (char *)"/dev/cdu31a",      (char *)"/dev/cdu535",      (char *)"/dev/sbpcd",      (char *)"/dev/sbpcd?", 
        (char *)"/dev/sonycd",      (char *)"/dev/mcd",      (char *)"/dev/sjcd",      (char *)"/dev/cm206cd", 
        (char *)"/dev/gscd",      (char *)"/dev/optcd",      (char *)((void *)0)};
#line 290 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/interface/scan_devices.c"
static int get_scsi_id___0(int fd , scsiid *id ) 
{ 
  struct sg_id argid ;
  int busarg ;
  int tmp ;
  int tmp___0 ;

  {
#line 296
  if (fd == -1) {
#line 296
    return (-1);
  }
  {
#line 297
  tmp = ioctl(fd, 21378UL, & argid);
  }
#line 297
  if (tmp) {
#line 297
    return (-1);
  }
  {
#line 298
  id->bus = (int )argid.l2;
#line 299
  id->id = (int )(argid.l1 & 255L);
#line 300
  id->lun = (int )((argid.l1 >> 8) & 255L);
#line 302
  tmp___0 = ioctl(fd, 21382UL, & busarg);
  }
#line 302
  if (tmp___0 == 0) {
#line 303
    id->bus = busarg;
  }
#line 305
  return (0);
}
}
#line 309 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/interface/scan_devices.c"
static char *scsi_match___0(char const   *device , char **prefixes , char *devfs_test ,
                            char *devfs_other , char *prompt , int messagedest , char **messages ) 
{ 
  int dev ;
  int tmp ;
  scsiid a ;
  scsiid b ;
  int i ;
  int j ;
  char buffer[200] ;
  char *pos ;
  int matchf ;
  int *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;
  size_t tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int pattern ;
  int matchf___0 ;
  int k ;
  int *tmp___7 ;
  char *tmp___8 ;
  int tmp___9 ;
  char *tmp___10 ;
  int tmp___11 ;
  void *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;

  {
  {
#line 313
  tmp = open(device, 2048);
#line 313
  dev = tmp;
#line 321
  tmp___4 = strlen((char const   *)devfs_test);
#line 321
  tmp___5 = strncmp(device, (char const   *)devfs_test, tmp___4);
  }
#line 321
  if (! tmp___5) {
    {
#line 323
    strcpy((char */* __restrict  */)(buffer), (char const   */* __restrict  */)device);
#line 324
    pos = strrchr((char const   *)(buffer), '/');
    }
#line 325
    if (pos) {
      {
#line 327
      sprintf((char */* __restrict  */)pos, (char const   */* __restrict  */)"/%s",
              devfs_other);
#line 328
      matchf = open((char const   *)(buffer), 2048);
#line 329
      i = 0;
      }
      {
#line 329
      while (1) {
        while_continue: /* CIL Label */ ;
#line 329
        if (i < 10) {
#line 329
          if (! (matchf == -1)) {
#line 329
            goto while_break;
          }
        } else {
#line 329
          goto while_break;
        }
        {
#line 330
        tmp___0 = __errno_location();
#line 330
        tmp___1 = strerror(*tmp___0);
#line 330
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error trying to open %s exclusively (%s). retrying in 1 seconds.\n",
                buffer, tmp___1);
#line 331
        tmp___2 = rand();
#line 331
        usleep((__useconds_t )((double )1000000 + (100000.0 * (double )tmp___2) / ((double )2147483647 + 1.0)));
#line 332
        matchf = open((char const   *)(buffer), 2048);
#line 329
        i ++;
        }
      }
      while_break: /* CIL Label */ ;
      }
#line 334
      if (matchf != -1) {
        {
#line 335
        close(matchf);
#line 336
        close(dev);
#line 337
        tmp___3 = strdup((char const   *)(buffer));
        }
#line 337
        return (tmp___3);
      }
    }
  }
#line 343
  if (dev == -1) {
    {
#line 344
    idperror___0(messagedest, messages, "\t\tCould not access device %s", device);
    }
#line 347
    goto matchfail;
  }
  {
#line 349
  tmp___6 = get_scsi_id___0(dev, & a);
  }
#line 349
  if (tmp___6) {
    {
#line 350
    idperror___0(messagedest, messages, "\t\tDevice %s could not perform ioctl()",
                 device);
    }
#line 353
    goto matchfail;
  }
#line 357
  i = 0;
  {
#line 357
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 357
    if (! (i < 25)) {
#line 357
      goto while_break___0;
    }
#line 358
    j = 0;
    {
#line 358
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 358
      if (! (j < 2)) {
#line 358
        goto while_break___1;
      }
#line 359
      pattern = 0;
      {
#line 362
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 362
        if (! ((unsigned long )*(prefixes + pattern) != (unsigned long )((void *)0))) {
#line 362
          goto while_break___2;
        }
        {
#line 364
        if (j == 0) {
#line 364
          goto case_0;
        }
#line 368
        if (j == 1) {
#line 368
          goto case_1;
        }
#line 363
        goto switch_break;
        case_0: /* CIL Label */ 
        {
#line 366
        sprintf((char */* __restrict  */)(buffer), (char const   */* __restrict  */)"%s%d",
                *(prefixes + pattern), i);
        }
#line 367
        goto switch_break;
        case_1: /* CIL Label */ 
        {
#line 370
        sprintf((char */* __restrict  */)(buffer), (char const   */* __restrict  */)"%s%c",
                *(prefixes + pattern), i + 97);
        }
#line 371
        goto switch_break;
        switch_break: /* CIL Label */ ;
        }
        {
#line 374
        matchf___0 = open((char const   *)(buffer), 2048);
#line 375
        k = 0;
        }
        {
#line 375
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 375
          if (k < 10) {
#line 375
            if (! (matchf___0 == -1)) {
#line 375
              goto while_break___3;
            }
          } else {
#line 375
            goto while_break___3;
          }
          {
#line 376
          tmp___7 = __errno_location();
#line 376
          tmp___8 = strerror(*tmp___7);
#line 376
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error trying to open %s exclusively (%s). retrying in 1 second.\n",
                  buffer, tmp___8);
#line 377
          tmp___9 = rand();
#line 377
          usleep((__useconds_t )((double )1000000 + (100000.0 * (double )tmp___9) / ((double )2147483647 + 1.0)));
#line 378
          matchf___0 = open((char const   *)(buffer), 2048);
#line 375
          k ++;
          }
        }
        while_break___3: /* CIL Label */ ;
        }
#line 381
        if (matchf___0 != -1) {
          {
#line 382
          tmp___11 = get_scsi_id___0(matchf___0, & b);
          }
#line 382
          if (tmp___11 == 0) {
#line 383
            if (a.bus == b.bus) {
#line 383
              if (a.id == b.id) {
#line 383
                if (a.lun == b.lun) {
                  {
#line 384
                  close(matchf___0);
#line 385
                  close(dev);
#line 386
                  tmp___10 = strdup((char const   *)(buffer));
                  }
#line 386
                  return (tmp___10);
                }
              }
            }
          }
          {
#line 389
          close(matchf___0);
          }
        }
#line 391
        pattern ++;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 358
      j ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 357
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 396
  idmessage___0(messagedest, messages, (char const   *)prompt, device);
  }
  matchfail: 
#line 400
  if (dev != -1) {
    {
#line 400
    close(dev);
    }
  }
#line 401
  return ((char *)((void *)0));
}
}
#line 416 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/interface/scan_devices.c"
static int verify_SG_version___0(cdrom_drive *d___0 , int messagedest , char **messages ) 
{ 
  int version ;
  int major ;
  int minor ;
  char buffer[256] ;
  int tmp ;
  void *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;

  {
  {
#line 421
  idmessage___0(messagedest, messages, "\nFound an accessible SCSI CDROM drive.\nLooking at revision of the SG interface in use...",
                "");
#line 425
  tmp = ioctl(d___0->cdda_fd, 8834UL, & version);
  }
#line 425
  if (tmp) {
    {
#line 427
    idmessage___0(messagedest, messages, "\tOOPS!  Old 2.0/early 2.1/early 2.2.x (non-ac patch) style SG.\n\tCdparanoia no longer supports the old interface.\n",
                  "");
    }
#line 430
    return (0);
  }
  {
#line 432
  major = version / 10000;
#line 433
  version -= major * 10000;
#line 434
  minor = version / 100;
#line 435
  version -= minor * 100;
#line 437
  sprintf((char */* __restrict  */)(buffer), (char const   */* __restrict  */)"\tSG interface version %d.%d.%d; OK.",
          major, minor, version);
#line 440
  idmessage___0(messagedest, messages, (char const   *)(buffer), "");
  }
#line 441
  return (major);
}
}
#line 142 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) strcmp)(char const   *__s1 ,
                                                                                     char const   *__s2 )  __attribute__((__pure__)) ;
#line 157 "/usr/include/bits/mathcalls.h"
extern  __attribute__((__nothrow__)) double sqrt(double __x ) ;
#line 48 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/cachetest.c"
static int time_drive(cdrom_drive *d___0 , FILE *progress , FILE *log___0 , int lba ,
                      int len , int initial_seek ) 
{ 
  int i ;
  int x ;
  int latency ;
  double sum ;
  double sumsq ;
  int sofar ;
  int toread ;
  int tmp ;
  int ret ;
  long tmp___0 ;
  double mean ;
  double stddev ;
  double tmp___1 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;

  {
#line 50
  latency = 0;
#line 51
  sum = (double )0;
#line 52
  sumsq = (double )0;
#line 55
  if (log___0) {
    {
#line 55
    fprintf((FILE */* __restrict  */)log___0, (char const   */* __restrict  */)"\n");
    }
  }
#line 57
  i = 0;
#line 57
  sofar = 0;
  {
#line 57
  while (1) {
    while_continue: /* CIL Label */ ;
#line 57
    if (! (sofar < len)) {
#line 57
      goto while_break;
    }
#line 58
    if (i == 0) {
#line 58
      if (initial_seek) {
#line 58
        tmp = 1;
      } else {
#line 58
        tmp = len - sofar;
      }
    } else {
#line 58
      tmp = len - sofar;
    }
    {
#line 58
    toread = tmp;
#line 61
    tmp___0 = cdda_read_timed(d___0, (void *)0, (long )(lba + sofar), (long )toread,
                              & x);
#line 61
    ret = (int )tmp___0;
    }
#line 61
    if (ret <= 0) {
#line 63
      if (ret == -404) {
#line 63
        return (-404);
      }
#line 64
      return (-1);
    }
#line 67
    if (x > 9999) {
#line 67
      x = 9999;
    }
#line 68
    if (x < 0) {
#line 68
      x = 0;
    }
#line 69
    if (log___0) {
      {
#line 69
      fprintf((FILE */* __restrict  */)log___0, (char const   */* __restrict  */)"%d:%d:%d ",
              lba + sofar, ret, x);
      }
    }
#line 71
    sofar += ret;
#line 72
    if (i) {
#line 73
      sum += (double )x;
#line 74
      sumsq += (double )((float )(x * x) / (float )ret);
    } else
#line 72
    if (! initial_seek) {
#line 73
      sum += (double )x;
#line 74
      sumsq += (double )((float )(x * x) / (float )ret);
    } else {
#line 76
      latency = x;
    }
#line 57
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 85
  mean = sum / (double )((float )(len - 1));
#line 86
  tmp___1 = sqrt(sumsq / (double )((float )(len - 1)) - mean * mean);
#line 86
  stddev = tmp___1;
  }
#line 88
  if (initial_seek) {
#line 89
    if (progress) {
      {
#line 89
      fprintf((FILE */* __restrict  */)progress, (char const   */* __restrict  */)"%4dms seek, %.2fms/sec read [%.1fx]",
              latency, mean, (1000. / 75.) / mean);
      }
    }
#line 90
    if (log___0) {
      {
#line 90
      fprintf((FILE */* __restrict  */)log___0, (char const   */* __restrict  */)"\n\tInitial seek latency (%d sectors): %dms",
              len, latency);
      }
    }
  }
#line 93
  if (log___0) {
    {
#line 93
    fprintf((FILE */* __restrict  */)log___0, (char const   */* __restrict  */)"\n\tAverage read latency: %.2fms/sector (raw speed: %.1fx)",
            mean, (1000. / 75.) / mean);
    }
  }
#line 94
  if (log___0) {
    {
#line 94
    fprintf((FILE */* __restrict  */)log___0, (char const   */* __restrict  */)"\n\tRead latency standard deviation: %.2fms/sector",
            stddev);
    }
  }
#line 96
  return ((int )sum);
}
}
#line 100 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/cachetest.c"
static float retime_drive(cdrom_drive *d___0 , FILE *progress , FILE *log___0 , int lba ,
                          int readahead , float oldmean ) 
{ 
  int sectors ;
  int total ;
  float newmean ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;

  {
#line 101
  sectors = 2000;
#line 104
  if ((float )sectors * oldmean > (float )5000) {
#line 104
    sectors = (int )((float )5000 / oldmean);
  }
#line 105
  readahead *= 10;
#line 106
  readahead /= 9;
#line 107
  if (readahead > sectors) {
#line 107
    sectors = readahead;
  }
#line 109
  if (progress) {
    {
#line 109
    fprintf((FILE */* __restrict  */)progress, (char const   */* __restrict  */)"\bo");
    }
  }
#line 110
  if (log___0) {
    {
#line 110
    fprintf((FILE */* __restrict  */)log___0, (char const   */* __restrict  */)"\n\tRetiming drive...                               ");
    }
  }
  {
#line 112
  total = time_drive(d___0, (FILE *)((void *)0), log___0, lba, sectors, 1);
#line 113
  newmean = (float )total / (float )sectors;
  }
#line 115
  if (log___0) {
    {
#line 115
    fprintf((FILE */* __restrict  */)log___0, (char const   */* __restrict  */)"\n\tOld mean=%.2fms/sec, New mean=%.2fms/sec\n",
            (double )oldmean, (double )newmean);
    }
  }
#line 116
  if (progress) {
    {
#line 116
    fprintf((FILE */* __restrict  */)progress, (char const   */* __restrict  */)"\b");
    }
  }
#line 118
  if (newmean > oldmean) {
#line 118
    return (newmean);
  }
#line 119
  return (oldmean);
}
}
#line 122 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/cachetest.c"
int analyze_cache(cdrom_drive *d___0 , FILE *progress , FILE *log___0 , int speed ) 
{ 
  int i ;
  int j ;
  int ret ;
  int x ;
  int firstsector ;
  int lastsector ;
  int firsttest ;
  int lasttest ;
  int offset ;
  int warn ;
  int current ;
  int hi ;
  int cachesize ;
  int readahead ;
  int rollbehind ;
  int cachegran ;
  float mspersector ;
  char *tmp ;
  int tmp___0 ;
  long tmp___1 ;
  long tmp___2 ;
  int tmp___3 ;
  int best ;
  int bestcount ;
  int iterating ;
  int m ;
  int s ;
  int f ;
  int sofar ;
  long tmp___4 ;
  int under ;
  int onex ;
  int i___0 ;
  int j___0 ;
  int tmp___5 ;
  int ret1 ;
  int ret2 ;
  int sofar___0 ;
  int tmp___6 ;
  long tmp___7 ;
  long tmp___8 ;
  long tmp___9 ;
  cdrom_paranoia___0 *p___0 ;
  cdrom_paranoia___0 *tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int seekoff ;
  int under___0 ;
  int ret1___0 ;
  int ret2___0 ;
  long tmp___13 ;
  long tmp___14 ;
  int lower ;
  int gran ;
  int it ;
  int tests ;
  int under___1 ;
  int sofar___1 ;
  int ret___0 ;
  long tmp___15 ;
  int usec ;
  int max ;
  long tmp___16 ;
  int sofar___2 ;
  int ret___1 ;
  int retry ;
  long tmp___17 ;
  int usec___0 ;
  long tmp___18 ;
  float newms ;
  float tmp___19 ;
  int sofar___3 ;
  int ret___2 ;
  int retry___0 ;
  long tmp___20 ;
  int usec___1 ;
  long tmp___21 ;
  float newms___0 ;
  float tmp___22 ;
  float cachems ;
  float readms ;
  int readsize ;
  int retry___1 ;
  int ret___3 ;
  int tmp___23 ;
  int elapsed ;
  int sectors ;
  int spinner ;
  int tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  int tmp___27 ;
  int total ;
  int elapsed___0 ;
  int sectors___0 ;
  int spinner___0 ;
  int retry___2 ;
  int ret___4 ;
  int seekpos ;
  long tmp___28 ;
  int tmp___29 ;
  int tmp___30 ;
  int tmp___31 ;
  char *__cil_tmp108 ;
  char *__cil_tmp109 ;
  char *__cil_tmp110 ;
  char *__cil_tmp111 ;
  char *__cil_tmp112 ;
  char *__cil_tmp113 ;
  char *__cil_tmp114 ;
  char *__cil_tmp115 ;
  char *__cil_tmp116 ;
  char *__cil_tmp117 ;
  char *__cil_tmp118 ;
  char *__cil_tmp119 ;
  char *__cil_tmp120 ;
  char *__cil_tmp121 ;
  char *__cil_tmp122 ;
  char *__cil_tmp123 ;
  char *__cil_tmp124 ;
  char *__cil_tmp125 ;
  char *__cil_tmp126 ;
  char *__cil_tmp127 ;
  char *__cil_tmp128 ;
  char *__cil_tmp129 ;
  char *__cil_tmp130 ;
  char *__cil_tmp131 ;
  char *__cil_tmp132 ;
  char *__cil_tmp133 ;
  char *__cil_tmp134 ;
  char *__cil_tmp135 ;
  char *__cil_tmp136 ;
  char *__cil_tmp137 ;
  char *__cil_tmp138 ;
  char *__cil_tmp139 ;
  char *__cil_tmp140 ;
  char *__cil_tmp141 ;
  char *__cil_tmp142 ;
  char *__cil_tmp143 ;
  char *__cil_tmp144 ;
  char *__cil_tmp145 ;
  char *__cil_tmp146 ;
  char *__cil_tmp147 ;
  char *__cil_tmp148 ;
  char *__cil_tmp149 ;
  char *__cil_tmp150 ;
  char *__cil_tmp151 ;
  char *__cil_tmp152 ;
  char *__cil_tmp153 ;
  char *__cil_tmp154 ;
  char *__cil_tmp155 ;
  char *__cil_tmp156 ;
  char *__cil_tmp157 ;
  char *__cil_tmp158 ;
  char *__cil_tmp159 ;
  char *__cil_tmp160 ;
  char *__cil_tmp161 ;
  char *__cil_tmp162 ;
  char *__cil_tmp163 ;
  char *__cil_tmp164 ;
  char *__cil_tmp165 ;
  char *__cil_tmp166 ;
  char *__cil_tmp167 ;
  char *__cil_tmp168 ;
  char *__cil_tmp169 ;
  char *__cil_tmp170 ;
  char *__cil_tmp171 ;
  char *__cil_tmp172 ;
  char *__cil_tmp173 ;
  char *__cil_tmp174 ;
  char *__cil_tmp175 ;
  char *__cil_tmp176 ;
  char *__cil_tmp177 ;
  char *__cil_tmp178 ;
  char *__cil_tmp179 ;
  char *__cil_tmp180 ;
  char *__cil_tmp181 ;
  char *__cil_tmp182 ;
  char *__cil_tmp183 ;
  char *__cil_tmp184 ;
  char *__cil_tmp185 ;
  char *__cil_tmp186 ;
  char *__cil_tmp187 ;
  char *__cil_tmp188 ;
  char *__cil_tmp189 ;
  char *__cil_tmp190 ;
  char *__cil_tmp191 ;
  char *__cil_tmp192 ;
  char *__cil_tmp193 ;
  char *__cil_tmp194 ;
  char *__cil_tmp195 ;
  char *__cil_tmp196 ;
  char *__cil_tmp197 ;
  char *__cil_tmp198 ;
  char *__cil_tmp199 ;
  char *__cil_tmp200 ;
  char *__cil_tmp201 ;
  char *__cil_tmp202 ;
  char *__cil_tmp203 ;
  char *__cil_tmp204 ;
  char *__cil_tmp205 ;
  char *__cil_tmp206 ;
  char *__cil_tmp207 ;
  char *__cil_tmp208 ;
  char *__cil_tmp209 ;
  char *__cil_tmp210 ;
  char *__cil_tmp211 ;
  char *__cil_tmp212 ;
  char *__cil_tmp213 ;
  char *__cil_tmp214 ;
  char *__cil_tmp215 ;
  char *__cil_tmp216 ;
  char *__cil_tmp217 ;
  char *__cil_tmp218 ;
  char *__cil_tmp219 ;
  char *__cil_tmp220 ;
  char *__cil_tmp221 ;
  char *__cil_tmp222 ;
  char *__cil_tmp223 ;
  char *__cil_tmp224 ;
  char *__cil_tmp225 ;
  char *__cil_tmp226 ;
  char *__cil_tmp227 ;
  char *__cil_tmp228 ;
  char *__cil_tmp229 ;
  char *__cil_tmp230 ;
  char *__cil_tmp231 ;
  char *__cil_tmp232 ;
  char *__cil_tmp233 ;
  char *__cil_tmp234 ;
  char *__cil_tmp235 ;
  char *__cil_tmp236 ;
  char *__cil_tmp237 ;
  char *__cil_tmp238 ;
  char *__cil_tmp239 ;
  char *__cil_tmp240 ;
  char *__cil_tmp241 ;
  char *__cil_tmp242 ;
  char *__cil_tmp243 ;
  char *__cil_tmp244 ;
  char *__cil_tmp245 ;
  char *__cil_tmp246 ;
  char *__cil_tmp247 ;
  char *__cil_tmp248 ;
  char *__cil_tmp249 ;
  char *__cil_tmp250 ;
  char *__cil_tmp251 ;
  char *__cil_tmp252 ;
  char *__cil_tmp253 ;
  char *__cil_tmp254 ;
  char *__cil_tmp255 ;
  char *__cil_tmp256 ;
  char *__cil_tmp257 ;
  char *__cil_tmp258 ;
  char *__cil_tmp259 ;
  char *__cil_tmp260 ;
  char *__cil_tmp261 ;
  char *__cil_tmp262 ;
  char *__cil_tmp263 ;
  char *__cil_tmp264 ;
  char *__cil_tmp265 ;
  char *__cil_tmp266 ;
  char *__cil_tmp267 ;
  char *__cil_tmp268 ;
  char *__cil_tmp269 ;
  char *__cil_tmp270 ;
  char *__cil_tmp271 ;
  char *__cil_tmp272 ;
  char *__cil_tmp273 ;
  char *__cil_tmp274 ;

  {
#line 148
  ret = 0;
#line 149
  firstsector = -1;
#line 150
  lastsector = -1;
#line 151
  firsttest = -1;
#line 152
  lasttest = -1;
#line 154
  warn = 0;
#line 155
  current = 1000;
#line 156
  hi = 15000;
#line 157
  cachesize = 0;
#line 158
  readahead = 0;
#line 159
  rollbehind = 0;
#line 160
  cachegran = 0;
#line 161
  mspersector = (float )0;
#line 162
  if (speed <= 0) {
#line 162
    speed = -1;
  }
#line 164
  if (progress) {
    {
#line 164
    fprintf((FILE */* __restrict  */)progress, (char const   */* __restrict  */)"\n=================== Checking drive cache/timing behavior ===================\n");
    }
  }
#line 164
  if (log___0) {
    {
#line 164
    fprintf((FILE */* __restrict  */)log___0, (char const   */* __restrict  */)"\n=================== Checking drive cache/timing behavior ===================\n");
    }
  }
  {
#line 165
  d___0->error_retry = 0;
#line 168
  tmp = paranoia_version();
#line 168
  tmp___0 = strcmp("10.2", (char const   *)tmp);
  }
#line 168
  if (tmp___0) {
#line 169
    if (progress) {
      {
#line 169
      fprintf((FILE */* __restrict  */)progress, (char const   */* __restrict  */)"\nWARNING: cdparanoia application (and thus the cache tests) does not match the\ninstalled (or in use) libcdda_paranoia.so library.  The final verdict of this\ntesting may or may not be accurate for the actual version of the paranoialibrary.  Continuing anyway...\n\n");
      }
    }
#line 169
    if (log___0) {
      {
#line 169
      fprintf((FILE */* __restrict  */)log___0, (char const   */* __restrict  */)"\nWARNING: cdparanoia application (and thus the cache tests) does not match the\ninstalled (or in use) libcdda_paranoia.so library.  The final verdict of this\ntesting may or may not be accurate for the actual version of the paranoialibrary.  Continuing anyway...\n\n");
      }
    }
  }
#line 177
  i = 0;
  {
#line 177
  while (1) {
    while_continue: /* CIL Label */ ;
#line 177
    if (! (i < d___0->tracks)) {
#line 177
      goto while_break;
    }
    {
#line 178
    tmp___3 = cdda_track_audiop(d___0, i + 1);
    }
#line 178
    if (tmp___3 == 1) {
#line 179
      if (firsttest == -1) {
        {
#line 180
        tmp___1 = cdda_track_firstsector(d___0, i + 1);
#line 180
        firsttest = (int )tmp___1;
        }
      }
      {
#line 181
      tmp___2 = cdda_track_lastsector(d___0, i + 1);
#line 181
      lasttest = (int )tmp___2;
      }
#line 182
      if (lasttest - firsttest > lastsector - firstsector) {
#line 183
        firstsector = firsttest;
#line 184
        lastsector = lasttest;
      }
    } else {
#line 187
      firsttest = -1;
#line 188
      lasttest = -1;
    }
#line 177
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 192
  if (firstsector == -1) {
#line 193
    if (progress) {
      {
#line 193
      fprintf((FILE */* __restrict  */)progress, (char const   */* __restrict  */)"\n\tNo audio on disc; Cannot determine timing behavior...");
      }
    }
#line 193
    if (log___0) {
      {
#line 193
      fprintf((FILE */* __restrict  */)log___0, (char const   */* __restrict  */)"\n\tNo audio on disc; Cannot determine timing behavior...");
      }
    }
#line 194
    return (-1);
  }
#line 200
  best = 0;
#line 201
  bestcount = 0;
#line 202
  iterating = 0;
#line 204
  offset = ((lastsector - firstsector) - current) - 1;
#line 206
  if (progress) {
    {
#line 206
    fprintf((FILE */* __restrict  */)progress, (char const   */* __restrict  */)"\nSeek/read timing:\n");
    }
  }
#line 206
  if (log___0) {
    {
#line 206
    fprintf((FILE */* __restrict  */)log___0, (char const   */* __restrict  */)"\nSeek/read timing:\n");
    }
  }
  {
#line 208
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 208
    if (! (offset >= firstsector)) {
#line 208
      goto while_break___0;
    }
#line 209
    m = offset / 4500;
#line 210
    s = (offset - m * 4500) / 75;
#line 211
    f = (offset - m * 4500) - s * 75;
#line 214
    if (iterating) {
#line 215
      if (progress) {
        {
#line 215
        fprintf((FILE */* __restrict  */)progress, (char const   */* __restrict  */)"\n");
        }
      }
#line 215
      if (log___0) {
        {
#line 215
        fprintf((FILE */* __restrict  */)log___0, (char const   */* __restrict  */)"\n");
        }
      }
    } else {
#line 217
      if (progress) {
        {
#line 217
        fprintf((FILE */* __restrict  */)progress, (char const   */* __restrict  */)"\r");
        }
      }
#line 218
      if (log___0) {
        {
#line 218
        fprintf((FILE */* __restrict  */)log___0, (char const   */* __restrict  */)"\n");
        }
      }
    }
#line 220
    if (progress) {
      {
#line 220
      fprintf((FILE */* __restrict  */)progress, (char const   */* __restrict  */)"\t[%02d:%02d.%02d]: ",
              m, s, f);
      }
    }
#line 220
    if (log___0) {
      {
#line 220
      fprintf((FILE */* __restrict  */)log___0, (char const   */* __restrict  */)"\t[%02d:%02d.%02d]: ",
              m, s, f);
      }
    }
    {
#line 223
    tmp___4 = cdda_read(d___0, (void *)0, (long )((offset + current) + 1), 1L);
#line 223
    ret = (int )tmp___4;
    }
#line 223
    if (ret < 0) {
#line 225
      if (ret == -404) {
#line 225
        return (-1);
      }
#line 226
      if (progress) {
        {
#line 226
        fprintf((FILE */* __restrict  */)progress, (char const   */* __restrict  */)"\n\tWARNING: media error during read; continuing at next offset...");
        }
      }
#line 226
      if (log___0) {
        {
#line 226
        fprintf((FILE */* __restrict  */)log___0, (char const   */* __restrict  */)"\n\tWARNING: media error during read; continuing at next offset...");
        }
      }
#line 227
      offset = (((offset - firstsector) + 44999) / 45000) * 45000 + firstsector;
#line 228
      offset -= 45000;
#line 229
      goto while_continue___0;
    }
    {
#line 232
    sofar = time_drive(d___0, progress, log___0, offset, current, 1);
    }
#line 233
    if (offset == firstsector) {
#line 233
      mspersector = (float )sofar / (float )current;
    }
#line 234
    if (sofar == -404) {
#line 235
      return (-1);
    } else
#line 236
    if (sofar < 0) {
#line 237
      if (progress) {
        {
#line 237
        fprintf((FILE */* __restrict  */)progress, (char const   */* __restrict  */)"\n\tWARNING: media error during read; continuing at next offset...");
        }
      }
#line 237
      if (log___0) {
        {
#line 237
        fprintf((FILE */* __restrict  */)log___0, (char const   */* __restrict  */)"\n\tWARNING: media error during read; continuing at next offset...");
        }
      }
#line 238
      offset = (((offset - firstsector) + 44999) / 45000) * 45000 + firstsector;
#line 239
      offset -= 45000;
#line 240
      goto while_continue___0;
    } else
#line 242
    if (! iterating) {
#line 243
      if (best == 0) {
#line 244
        best = sofar;
#line 245
        bestcount = 0;
      } else
#line 243
      if ((double )sofar * 1.01 < (double )best) {
#line 244
        best = sofar;
#line 245
        bestcount = 0;
      } else {
#line 247
        bestcount += sofar;
#line 248
        if (bestcount > sofar) {
#line 248
          if (bestcount > 4000) {
#line 249
            iterating = 1;
          }
        }
      }
    }
#line 254
    if (iterating) {
#line 255
      offset = (((offset - firstsector) + 44999) / 45000) * 45000 + firstsector;
#line 256
      offset -= 45000;
#line 257
      if (progress) {
        {
#line 257
        fprintf((FILE */* __restrict  */)progress, (char const   */* __restrict  */)"                 ");
        }
      }
    } else {
#line 259
      offset --;
#line 260
      if (progress) {
        {
#line 260
        fprintf((FILE */* __restrict  */)progress, (char const   */* __restrict  */)" spinning up...  ");
        }
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 265
  if (progress) {
    {
#line 265
    fprintf((FILE */* __restrict  */)progress, (char const   */* __restrict  */)"\n\nAnalyzing cache behavior...\n");
    }
  }
#line 265
  if (log___0) {
    {
#line 265
    fprintf((FILE */* __restrict  */)log___0, (char const   */* __restrict  */)"\n\nAnalyzing cache behavior...\n");
    }
  }
#line 271
  under = 1;
#line 272
  onex = 0;
#line 273
  current = 0;
#line 274
  offset = firstsector + 10;
  {
#line 276
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 276
    if (current <= hi) {
#line 276
      if (! under) {
#line 276
        goto while_break___1;
      }
    } else {
#line 276
      goto while_break___1;
    }
#line 278
    under = 0;
#line 279
    current ++;
#line 281
    if (onex) {
#line 282
      if (speed == -1) {
#line 283
        if (log___0) {
          {
#line 283
          fprintf((FILE */* __restrict  */)log___0, (char const   */* __restrict  */)"\tAttempting to reset read speed to full... ");
          }
        }
      } else
#line 285
      if (log___0) {
        {
#line 285
        fprintf((FILE */* __restrict  */)log___0, (char const   */* __restrict  */)"\tAttempting to reset read speed to %dx... ",
                speed);
        }
      }
      {
#line 287
      tmp___5 = cdda_speed_set(d___0, speed);
      }
#line 287
      if (tmp___5) {
#line 288
        if (log___0) {
          {
#line 288
          fprintf((FILE */* __restrict  */)log___0, (char const   */* __restrict  */)"failed.\n");
          }
        }
      } else
#line 290
      if (log___0) {
        {
#line 290
        fprintf((FILE */* __restrict  */)log___0, (char const   */* __restrict  */)"drive said OK\n");
        }
      }
#line 292
      onex = 0;
    }
#line 295
    if (progress) {
      {
#line 295
      fprintf((FILE */* __restrict  */)progress, (char const   */* __restrict  */)"\r");
      }
    }
#line 296
    if (progress) {
      {
#line 296
      fprintf((FILE */* __restrict  */)progress, (char const   */* __restrict  */)"\tFast search for approximate cache size... %d sectors            ",
              current - 1);
      }
    }
#line 296
    if (log___0) {
      {
#line 296
      fprintf((FILE */* __restrict  */)log___0, (char const   */* __restrict  */)"\tFast search for approximate cache size... %d sectors            ",
              current - 1);
      }
    }
#line 297
    if (log___0) {
      {
#line 297
      fprintf((FILE */* __restrict  */)log___0, (char const   */* __restrict  */)"\n");
      }
    }
#line 299
    i___0 = 0;
    {
#line 299
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 299
      if (i___0 < 25) {
#line 299
        if (! (! under)) {
#line 299
          goto while_break___2;
        }
      } else {
#line 299
        goto while_break___2;
      }
#line 300
      j___0 = 0;
      {
#line 300
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 301
        ret1 = 0;
#line 301
        ret2 = 0;
#line 302
        if (i___0 >= 15) {
#line 303
          sofar___0 = 0;
#line 305
          if (i___0 == 15) {
#line 306
            if (progress) {
              {
#line 306
              fprintf((FILE */* __restrict  */)progress, (char const   */* __restrict  */)"\r");
              }
            }
#line 307
            if (progress) {
              {
#line 307
              fprintf((FILE */* __restrict  */)progress, (char const   */* __restrict  */)"\tSlow verify for approximate cache size... %d sectors",
                      current - 1);
              }
            }
#line 307
            if (log___0) {
              {
#line 307
              fprintf((FILE */* __restrict  */)log___0, (char const   */* __restrict  */)"\tSlow verify for approximate cache size... %d sectors",
                      current - 1);
              }
            }
#line 308
            if (log___0) {
              {
#line 308
              fprintf((FILE */* __restrict  */)log___0, (char const   */* __restrict  */)"\n");
              }
            }
#line 310
            if (log___0) {
              {
#line 310
              fprintf((FILE */* __restrict  */)log___0, (char const   */* __restrict  */)"\tAttempting to reduce read speed to 1x... ");
              }
            }
            {
#line 311
            tmp___6 = cdda_speed_set(d___0, 1);
            }
#line 311
            if (tmp___6) {
#line 312
              if (log___0) {
                {
#line 312
                fprintf((FILE */* __restrict  */)log___0, (char const   */* __restrict  */)"failed.\n");
                }
              }
            } else
#line 314
            if (log___0) {
              {
#line 314
              fprintf((FILE */* __restrict  */)log___0, (char const   */* __restrict  */)"drive said OK\n");
              }
            }
#line 316
            onex = 1;
          }
#line 318
          if (progress) {
            {
#line 318
            fprintf((FILE */* __restrict  */)progress, (char const   */* __restrict  */)".");
            }
          }
#line 319
          if (log___0) {
            {
#line 319
            fprintf((FILE */* __restrict  */)log___0, (char const   */* __restrict  */)"\t\t>>> ");
            }
          }
          {
#line 321
          while (1) {
            while_continue___4: /* CIL Label */ ;
#line 321
            if (! (sofar___0 < current)) {
#line 321
              goto while_break___4;
            }
            {
#line 322
            tmp___7 = cdda_read_timed(d___0, (void *)0, (long )(offset + sofar___0),
                                      (long )(current - sofar___0), & x);
#line 322
            ret1 = (int )tmp___7;
            }
#line 323
            if (log___0) {
              {
#line 323
              fprintf((FILE */* __restrict  */)log___0, (char const   */* __restrict  */)"slow_read=%d:%d:%d ",
                      offset + sofar___0, ret1, x);
              }
            }
#line 324
            if (ret1 <= 0) {
#line 324
              goto while_break___4;
            }
#line 325
            sofar___0 += ret1;
          }
          while_break___4: /* CIL Label */ ;
          }
        } else {
          {
#line 328
          tmp___8 = cdda_read_timed(d___0, (void *)0, (long )((offset + current) - 1),
                                    1L, & x);
#line 328
          ret1 = (int )tmp___8;
          }
#line 329
          if (log___0) {
            {
#line 329
            fprintf((FILE */* __restrict  */)log___0, (char const   */* __restrict  */)"\t\t>>> fast_read=%d:%d:%d ",
                    (offset + current) - 1, ret1, x);
            }
          }
#line 338
          if (ret == 1) {
#line 338
            if (i___0) {
#line 338
              if (x < 6) {
#line 339
                under = 1;
#line 340
                if (log___0) {
                  {
#line 340
                  fprintf((FILE */* __restrict  */)log___0, (char const   */* __restrict  */)"\n");
                  }
                }
#line 341
                goto while_break___3;
              }
            }
          }
        }
        {
#line 344
        tmp___9 = cdda_read_timed(d___0, (void *)0, (long )offset, 1L, & x);
#line 344
        ret2 = (int )tmp___9;
        }
#line 345
        if (log___0) {
          {
#line 345
          fprintf((FILE */* __restrict  */)log___0, (char const   */* __restrict  */)"seek_read=%d:%d:%d\n",
                  offset, ret2, x);
          }
        }
#line 347
        if (ret1 <= 0) {
#line 347
          goto _L___0;
        } else
#line 347
        if (ret2 <= 0) {
          _L___0: /* CIL Label */ 
#line 348
          offset += current + 100;
#line 349
          if (j___0 == 10) {
#line 349
            goto _L;
          } else
#line 349
          if (offset + current > lastsector) {
            _L: /* CIL Label */ 
#line 350
            if (progress) {
              {
#line 350
              fprintf((FILE */* __restrict  */)progress, (char const   */* __restrict  */)"\n\tToo many read errors while performing drive cache checks;\n\t  aborting test.\n\n");
              }
            }
#line 350
            if (log___0) {
              {
#line 350
              fprintf((FILE */* __restrict  */)log___0, (char const   */* __restrict  */)"\n\tToo many read errors while performing drive cache checks;\n\t  aborting test.\n\n");
              }
            }
#line 352
            return (-1);
          }
#line 354
          if (progress) {
            {
#line 354
            fprintf((FILE */* __restrict  */)progress, (char const   */* __restrict  */)"\n\tRead error while performing drive cache checks;\n\t  choosing new offset and trying again.\n");
            }
          }
#line 354
          if (log___0) {
            {
#line 354
            fprintf((FILE */* __restrict  */)log___0, (char const   */* __restrict  */)"\n\tRead error while performing drive cache checks;\n\t  choosing new offset and trying again.\n");
            }
          }
        } else
#line 357
        if (x == -1) {
#line 358
          if (progress) {
            {
#line 358
            fprintf((FILE */* __restrict  */)progress, (char const   */* __restrict  */)"\n\tTiming error while performing drive cache checks; aborting test.\n");
            }
          }
#line 358
          if (log___0) {
            {
#line 358
            fprintf((FILE */* __restrict  */)log___0, (char const   */* __restrict  */)"\n\tTiming error while performing drive cache checks; aborting test.\n");
            }
          }
#line 359
          return (-1);
        } else {
#line 361
          if (x < 6) {
#line 362
            under = 1;
          }
#line 364
          goto while_break___3;
        }
#line 300
        j___0 ++;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 299
      i___0 ++;
    }
    while_break___2: /* CIL Label */ ;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 371
  cachesize = current - 1;
#line 373
  if (progress) {
    {
#line 373
    fprintf((FILE */* __restrict  */)progress, (char const   */* __restrict  */)"\r");
    }
  }
#line 374
  if (cachesize == hi) {
#line 375
    if (progress) {
      {
#line 375
      fprintf((FILE */* __restrict  */)progress, (char const   */* __restrict  */)"\tWARNING: Cannot determine drive cache size or behavior!          \n");
      }
    }
#line 375
    if (log___0) {
      {
#line 375
      fprintf((FILE */* __restrict  */)log___0, (char const   */* __restrict  */)"\tWARNING: Cannot determine drive cache size or behavior!          \n");
      }
    }
#line 376
    return (1);
  } else
#line 377
  if (cachesize) {
#line 378
    if (progress) {
      {
#line 378
      fprintf((FILE */* __restrict  */)progress, (char const   */* __restrict  */)"\tApproximate random access cache size: %d sector(s)               \n",
              cachesize);
      }
    }
#line 378
    if (log___0) {
      {
#line 378
      fprintf((FILE */* __restrict  */)log___0, (char const   */* __restrict  */)"\tApproximate random access cache size: %d sector(s)               \n",
              cachesize);
      }
    }
  } else {
#line 380
    if (progress) {
      {
#line 380
      fprintf((FILE */* __restrict  */)progress, (char const   */* __restrict  */)"\tDrive does not cache nonlinear access                            \n");
      }
    }
#line 380
    if (log___0) {
      {
#line 380
      fprintf((FILE */* __restrict  */)log___0, (char const   */* __restrict  */)"\tDrive does not cache nonlinear access                            \n");
      }
    }
#line 381
    return (0);
  }
  {
#line 386
  tmp___10 = paranoia_init(d___0);
#line 386
  p___0 = tmp___10;
#line 387
  tmp___11 = paranoia_cachemodel_size(p___0, -1);
  }
#line 387
  if (cachesize > tmp___11) {
#line 388
    if (progress) {
      {
#line 388
      fprintf((FILE */* __restrict  */)progress, (char const   */* __restrict  */)"\nWARNING: This drive appears to be caching more sectors of\n           readahead than Paranoia can currently handle!\n");
      }
    }
#line 388
    if (log___0) {
      {
#line 388
      fprintf((FILE */* __restrict  */)log___0, (char const   */* __restrict  */)"\nWARNING: This drive appears to be caching more sectors of\n           readahead than Paranoia can currently handle!\n");
      }
    }
#line 390
    warn = 1;
  }
  {
#line 393
  paranoia_free(p___0);
  }
#line 395
  if (speed == -1) {
#line 396
    if (log___0) {
      {
#line 396
      fprintf((FILE */* __restrict  */)log___0, (char const   */* __restrict  */)"\tAttempting to reset read speed to full... ");
      }
    }
  } else
#line 398
  if (log___0) {
    {
#line 398
    fprintf((FILE */* __restrict  */)log___0, (char const   */* __restrict  */)"\tAttempting to reset read speed to %d... ",
            speed);
    }
  }
  {
#line 400
  tmp___12 = cdda_speed_set(d___0, speed);
  }
#line 400
  if (tmp___12) {
#line 401
    if (log___0) {
      {
#line 401
      fprintf((FILE */* __restrict  */)log___0, (char const   */* __restrict  */)"failed.\n");
      }
    }
  } else
#line 403
  if (log___0) {
    {
#line 403
    fprintf((FILE */* __restrict  */)log___0, (char const   */* __restrict  */)"drive said OK\n");
    }
  }
#line 410
  seekoff = cachesize * 3;
#line 411
  under___0 = 0;
#line 412
  if (progress) {
    {
#line 412
    fprintf((FILE */* __restrict  */)progress, (char const   */* __restrict  */)"\tVerifying that cache is contiguous...");
    }
  }
#line 412
  if (log___0) {
    {
#line 412
    fprintf((FILE */* __restrict  */)log___0, (char const   */* __restrict  */)"\tVerifying that cache is contiguous...");
    }
  }
#line 414
  i = 0;
  {
#line 414
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 414
    if (i < 20) {
#line 414
      if (! (! under___0)) {
#line 414
        goto while_break___5;
      }
    } else {
#line 414
      goto while_break___5;
    }
#line 415
    if (progress) {
      {
#line 415
      fprintf((FILE */* __restrict  */)progress, (char const   */* __restrict  */)".");
      }
    }
#line 416
    j = 0;
    {
#line 416
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 419
      if (offset + seekoff > lastsector) {
#line 420
        if (progress) {
          {
#line 420
          fprintf((FILE */* __restrict  */)progress, (char const   */* __restrict  */)"\n\tOut of readable space on CDROM while performing drive checks;\n\t  aborting test.\n\n");
          }
        }
#line 420
        if (log___0) {
          {
#line 420
          fprintf((FILE */* __restrict  */)log___0, (char const   */* __restrict  */)"\n\tOut of readable space on CDROM while performing drive checks;\n\t  aborting test.\n\n");
          }
        }
#line 422
        return (-1);
      }
      {
#line 426
      tmp___13 = cdda_read_timed(d___0, (void *)0, (long )(offset + seekoff), 1L,
                                 & x);
#line 426
      ret1___0 = (int )tmp___13;
      }
#line 427
      if (log___0) {
        {
#line 427
        fprintf((FILE */* __restrict  */)log___0, (char const   */* __restrict  */)"\t\t>>> %d:%d:%d ",
                offset + seekoff, ret1___0, x);
        }
      }
      {
#line 428
      tmp___14 = cdda_read_timed(d___0, (void *)0, (long )offset, 1L, & x);
#line 428
      ret2___0 = (int )tmp___14;
      }
#line 429
      if (log___0) {
        {
#line 429
        fprintf((FILE */* __restrict  */)log___0, (char const   */* __restrict  */)"seek_read:%d:%d:%d\n",
                offset, ret2___0, x);
        }
      }
#line 431
      if (ret1___0 <= 0) {
#line 431
        goto _L___1;
      } else
#line 431
      if (ret2___0 <= 0) {
        _L___1: /* CIL Label */ 
#line 432
        offset += cachesize + 100;
#line 433
        if (j == 10) {
#line 434
          if (progress) {
            {
#line 434
            fprintf((FILE */* __restrict  */)progress, (char const   */* __restrict  */)"\n\tToo many read errors while performing drive cache checks;\n\t  aborting test.\n\n");
            }
          }
#line 434
          if (log___0) {
            {
#line 434
            fprintf((FILE */* __restrict  */)log___0, (char const   */* __restrict  */)"\n\tToo many read errors while performing drive cache checks;\n\t  aborting test.\n\n");
            }
          }
#line 436
          return (-1);
        }
#line 438
        if (progress) {
          {
#line 438
          fprintf((FILE */* __restrict  */)progress, (char const   */* __restrict  */)"\n\tRead error while performing drive cache checks;\n\t  choosing new offset and trying again.\n");
          }
        }
#line 438
        if (log___0) {
          {
#line 438
          fprintf((FILE */* __restrict  */)log___0, (char const   */* __restrict  */)"\n\tRead error while performing drive cache checks;\n\t  choosing new offset and trying again.\n");
          }
        }
      } else
#line 441
      if (x == -1) {
#line 442
        if (progress) {
          {
#line 442
          fprintf((FILE */* __restrict  */)progress, (char const   */* __restrict  */)"\n\tTiming error while performing drive cache checks; aborting test.\n");
          }
        }
#line 442
        if (log___0) {
          {
#line 442
          fprintf((FILE */* __restrict  */)log___0, (char const   */* __restrict  */)"\n\tTiming error while performing drive cache checks; aborting test.\n");
          }
        }
#line 443
        return (-1);
      } else {
#line 445
        if (x < 6) {
#line 445
          under___0 = 1;
        }
#line 446
        goto while_break___6;
      }
#line 416
      j ++;
    }
    while_break___6: /* CIL Label */ ;
    }
#line 414
    i ++;
  }
  while_break___5: /* CIL Label */ ;
  }
#line 451
  if (progress) {
    {
#line 451
    fprintf((FILE */* __restrict  */)progress, (char const   */* __restrict  */)"\r");
    }
  }
#line 452
  if (under___0) {
#line 453
    if (progress) {
      {
#line 453
      fprintf((FILE */* __restrict  */)progress, (char const   */* __restrict  */)"\nWARNING: Drive cache does not appear to be contiguous!\n");
      }
    }
#line 453
    if (log___0) {
      {
#line 453
      fprintf((FILE */* __restrict  */)log___0, (char const   */* __restrict  */)"\nWARNING: Drive cache does not appear to be contiguous!\n");
      }
    }
#line 454
    warn = 1;
  } else {
#line 456
    if (progress) {
      {
#line 456
      fprintf((FILE */* __restrict  */)progress, (char const   */* __restrict  */)"\tDrive cache tests as contiguous                           \n");
      }
    }
#line 456
    if (log___0) {
      {
#line 456
      fprintf((FILE */* __restrict  */)log___0, (char const   */* __restrict  */)"\tDrive cache tests as contiguous                           \n");
      }
    }
  }
#line 475
  lower = 0;
#line 476
  gran = 64;
#line 477
  it = 3;
#line 478
  tests = 0;
#line 479
  under___1 = 1;
#line 480
  readahead = 0;
  {
#line 482
  while (1) {
    while_continue___7: /* CIL Label */ ;
#line 482
    if (! (gran > 1)) {
#line 482
      if (! under___1) {
#line 482
        goto while_break___7;
      }
    }
#line 483
    tests ++;
#line 484
    if (tests > 8) {
#line 484
      if (gran < 64) {
#line 485
        gran <<= 3;
#line 486
        tests = 0;
#line 487
        it = 3;
      }
    }
#line 489
    if (gran) {
#line 489
      if (! under___1) {
#line 490
        gran >>= 3;
#line 491
        tests = 0;
#line 492
        if (gran == 1) {
#line 492
          it = 10;
        }
      }
    }
#line 495
    under___1 = 0;
#line 496
    readahead = lower + gran;
#line 498
    if (progress) {
      {
#line 498
      fprintf((FILE */* __restrict  */)progress, (char const   */* __restrict  */)"\r");
      }
    }
#line 499
    if (log___0) {
      {
#line 499
      fprintf((FILE */* __restrict  */)log___0, (char const   */* __restrict  */)"\n");
      }
    }
#line 500
    if (progress) {
      {
#line 500
      fprintf((FILE */* __restrict  */)progress, (char const   */* __restrict  */)"\tTesting background readahead past read cursor... %d",
              readahead);
      }
    }
#line 500
    if (log___0) {
      {
#line 500
      fprintf((FILE */* __restrict  */)log___0, (char const   */* __restrict  */)"\tTesting background readahead past read cursor... %d",
              readahead);
      }
    }
#line 501
    if (progress) {
      {
#line 501
      fprintf((FILE */* __restrict  */)progress, (char const   */* __restrict  */)"           \b\b\b\b\b\b\b\b\b\b\b");
      }
    }
#line 502
    i = 0;
    {
#line 502
    while (1) {
      while_continue___8: /* CIL Label */ ;
#line 502
      if (! (i < it)) {
#line 502
        goto while_break___8;
      }
#line 503
      sofar___1 = 0;
#line 504
      if (log___0) {
        {
#line 504
        fprintf((FILE */* __restrict  */)log___0, (char const   */* __restrict  */)"\n\t\t%d >>> ",
                i);
        }
      }
      {
#line 506
      while (1) {
        while_continue___9: /* CIL Label */ ;
#line 506
        if (! (sofar___1 < cachesize)) {
#line 506
          goto while_break___9;
        }
        {
#line 507
        tmp___15 = cdda_read_timed(d___0, (void *)0, (long )(offset + sofar___1),
                                   (long )(cachesize - sofar___1), & x);
#line 507
        ret___0 = (int )tmp___15;
        }
#line 508
        if (ret___0 <= 0) {
#line 508
          goto error;
        }
#line 509
        if (log___0) {
          {
#line 509
          fprintf((FILE */* __restrict  */)log___0, (char const   */* __restrict  */)"%d:%d:%d ",
                  offset + sofar___1, ret___0, x);
          }
        }
#line 516
        sofar___1 += ret___0;
      }
      while_break___9: /* CIL Label */ ;
      }
#line 519
      if (progress) {
        {
#line 519
        fprintf((FILE */* __restrict  */)progress, (char const   */* __restrict  */)".");
        }
      }
#line 523
      usec = (int )(((mspersector * (float )readahead) * (float )(6 + i)) * (float )200);
#line 524
      max = 26000 * readahead;
#line 525
      if (usec > max) {
#line 525
        usec = max;
      }
#line 526
      if (log___0) {
        {
#line 526
        fprintf((FILE */* __restrict  */)log___0, (char const   */* __restrict  */)"sleep=%dus ",
                usec);
        }
      }
      {
#line 527
      usleep((__useconds_t )usec);
#line 531
      tmp___16 = cdda_read_timed(d___0, (void *)0, (long )(((offset + cachesize) + readahead) - 1),
                                 1L, & x);
#line 531
      ret___0 = (int )tmp___16;
      }
#line 532
      if (ret___0 <= 0) {
#line 532
        goto while_break___8;
      }
#line 533
      if (log___0) {
        {
#line 533
        fprintf((FILE */* __restrict  */)log___0, (char const   */* __restrict  */)"seek=%d:%d:%d",
                ((offset + cachesize) + readahead) - 1, ret___0, x);
        }
      }
#line 534
      if (x < 6) {
#line 535
        under___1 = 1;
#line 536
        goto while_break___8;
      } else
#line 537
      if (i % 3 == 1) {
        {
#line 539
        mspersector = retime_drive(d___0, progress, log___0, offset, readahead, mspersector);
        }
      }
#line 502
      i ++;
    }
    while_break___8: /* CIL Label */ ;
    }
#line 543
    if (under___1) {
#line 544
      lower = readahead;
    }
  }
  while_break___7: /* CIL Label */ ;
  }
#line 547
  readahead = lower;
#line 549
  if (log___0) {
    {
#line 549
    fprintf((FILE */* __restrict  */)log___0, (char const   */* __restrict  */)"\n");
    }
  }
#line 550
  if (progress) {
    {
#line 550
    fprintf((FILE */* __restrict  */)progress, (char const   */* __restrict  */)"\r");
    }
  }
#line 551
  if (readahead == 0) {
#line 552
    if (progress) {
      {
#line 552
      fprintf((FILE */* __restrict  */)progress, (char const   */* __restrict  */)"\tDrive does not read ahead past read cursor (very strange)     \n");
      }
    }
#line 552
    if (log___0) {
      {
#line 552
      fprintf((FILE */* __restrict  */)log___0, (char const   */* __restrict  */)"\tDrive does not read ahead past read cursor (very strange)     \n");
      }
    }
  } else {
#line 554
    if (progress) {
      {
#line 554
      fprintf((FILE */* __restrict  */)progress, (char const   */* __restrict  */)"\tDrive readahead past read cursor: %d sector(s)                \n",
              readahead);
      }
    }
#line 554
    if (log___0) {
      {
#line 554
      fprintf((FILE */* __restrict  */)log___0, (char const   */* __restrict  */)"\tDrive readahead past read cursor: %d sector(s)                \n",
              readahead);
      }
    }
  }
#line 557
  if (progress) {
    {
#line 557
    fprintf((FILE */* __restrict  */)progress, (char const   */* __restrict  */)"\tTesting cache tail cursor...");
    }
  }
#line 557
  if (log___0) {
    {
#line 557
    fprintf((FILE */* __restrict  */)log___0, (char const   */* __restrict  */)"\tTesting cache tail cursor...");
    }
  }
  {
#line 559
  while (1) {
    while_continue___10: /* CIL Label */ ;
#line 560
    rollbehind = cachesize;
#line 562
    i = 0;
    {
#line 562
    while (1) {
      while_continue___11: /* CIL Label */ ;
#line 562
      if (i < 10) {
#line 562
        if (! rollbehind) {
#line 562
          goto while_break___11;
        }
      } else {
#line 562
        goto while_break___11;
      }
#line 563
      sofar___2 = 0;
#line 563
      ret___1 = 0;
#line 563
      retry = 0;
#line 564
      if (log___0) {
        {
#line 564
        fprintf((FILE */* __restrict  */)log___0, (char const   */* __restrict  */)"\n\t\t>>> ");
        }
      }
#line 565
      if (progress) {
        {
#line 565
        fprintf((FILE */* __restrict  */)progress, (char const   */* __restrict  */)".");
        }
      }
      {
#line 566
      while (1) {
        while_continue___12: /* CIL Label */ ;
#line 566
        if (! (sofar___2 < cachesize)) {
#line 566
          goto while_break___12;
        }
        {
#line 567
        tmp___17 = cdda_read_timed(d___0, (void *)0, (long )(offset + sofar___2),
                                   (long )(cachesize - sofar___2), & x);
#line 567
        ret___1 = (int )tmp___17;
        }
#line 568
        if (ret___1 <= 0) {
#line 568
          goto error;
        }
#line 569
        if (log___0) {
          {
#line 569
          fprintf((FILE */* __restrict  */)log___0, (char const   */* __restrict  */)"%d:%d:%d ",
                  offset + sofar___2, ret___1, x);
          }
        }
#line 570
        sofar___2 += ret___1;
      }
      while_break___12: /* CIL Label */ ;
      }
#line 575
      usec___0 = (int )((mspersector * (float )readahead) * (float )1500);
#line 576
      if (log___0) {
        {
#line 576
        fprintf((FILE */* __restrict  */)log___0, (char const   */* __restrict  */)"\n\t\tsleeping %d microseconds",
                usec___0);
        }
      }
      {
#line 577
      usleep((__useconds_t )usec___0);
      }
#line 581
      if (log___0) {
        {
#line 581
        fprintf((FILE */* __restrict  */)log___0, (char const   */* __restrict  */)"\n\t\t<<< ");
        }
      }
#line 582
      sofar___2 = rollbehind;
      {
#line 583
      while (1) {
        while_continue___13: /* CIL Label */ ;
#line 583
        if (! (sofar___2 > 0)) {
#line 583
          goto while_break___13;
        }
        {
#line 584
        sofar___2 --;
#line 585
        tmp___18 = cdda_read_timed(d___0, (void *)0, (long )(offset + sofar___2),
                                   1L, & x);
#line 585
        ret___1 = (int )tmp___18;
        }
#line 586
        if (ret___1 <= 0) {
#line 586
          goto while_break___13;
        }
#line 587
        if (log___0) {
          {
#line 587
          fprintf((FILE */* __restrict  */)log___0, (char const   */* __restrict  */)"%d:%d:%d ",
                  sofar___2, ret___1, x);
          }
        }
#line 588
        if (x >= 6) {
#line 589
          if (rollbehind != sofar___2 + 1) {
#line 590
            rollbehind = sofar___2 + 1;
#line 591
            i = 0;
          } else {
#line 593
            i ++;
          }
#line 595
          goto while_break___13;
        }
#line 597
        if (sofar___2 == 0) {
#line 597
          rollbehind = 0;
        }
      }
      while_break___13: /* CIL Label */ ;
      }
      error: 
#line 601
      if (ret___1 <= 0) {
#line 602
        offset += cachesize;
#line 603
        retry ++;
#line 604
        if (retry > 10) {
#line 604
          goto _L___2;
        } else
#line 604
        if (offset + cachesize > lastsector) {
          _L___2: /* CIL Label */ 
#line 605
          if (progress) {
            {
#line 605
            fprintf((FILE */* __restrict  */)progress, (char const   */* __restrict  */)"\n\tToo many read errors while performing drive cache checks;\n\t  aborting test.\n\n");
            }
          }
#line 605
          if (log___0) {
            {
#line 605
            fprintf((FILE */* __restrict  */)log___0, (char const   */* __restrict  */)"\n\tToo many read errors while performing drive cache checks;\n\t  aborting test.\n\n");
            }
          }
#line 607
          return (-1);
        }
#line 609
        if (progress) {
          {
#line 609
          fprintf((FILE */* __restrict  */)progress, (char const   */* __restrict  */)"\n\tRead error while performing drive cache checks;\n\t  choosing new offset and trying again.\n");
          }
        }
#line 609
        if (log___0) {
          {
#line 609
          fprintf((FILE */* __restrict  */)log___0, (char const   */* __restrict  */)"\n\tRead error while performing drive cache checks;\n\t  choosing new offset and trying again.\n");
          }
        }
#line 611
        goto __Cont;
      }
      __Cont: /* CIL Label */ ;
    }
    while_break___11: /* CIL Label */ ;
    }
    {
#line 617
    tmp___19 = retime_drive(d___0, progress, log___0, offset, readahead, mspersector);
#line 617
    newms = tmp___19;
    }
#line 618
    if ((double )newms > (double )mspersector * 1.2) {
#line 619
      mspersector = newms;
#line 620
      if (progress) {
        {
#line 620
        fprintf((FILE */* __restrict  */)progress, (char const   */* __restrict  */)"\r");
        }
      }
#line 621
      if (progress) {
        {
#line 621
        fprintf((FILE */* __restrict  */)progress, (char const   */* __restrict  */)"\tDrive timing changed during test; retrying...");
        }
      }
#line 621
      if (log___0) {
        {
#line 621
        fprintf((FILE */* __restrict  */)log___0, (char const   */* __restrict  */)"\tDrive timing changed during test; retrying...");
        }
      }
#line 622
      goto while_continue___10;
    }
#line 625
    goto while_break___10;
  }
  while_break___10: /* CIL Label */ ;
  }
#line 629
  if (log___0) {
    {
#line 629
    fprintf((FILE */* __restrict  */)log___0, (char const   */* __restrict  */)"\n");
    }
  }
#line 630
  if (progress) {
    {
#line 630
    fprintf((FILE */* __restrict  */)progress, (char const   */* __restrict  */)"\r");
    }
  }
#line 631
  if (rollbehind == 0) {
#line 632
    if (progress) {
      {
#line 632
      fprintf((FILE */* __restrict  */)progress, (char const   */* __restrict  */)"\tCache tail cursor tied to read cursor                      \n");
      }
    }
#line 632
    if (log___0) {
      {
#line 632
      fprintf((FILE */* __restrict  */)log___0, (char const   */* __restrict  */)"\tCache tail cursor tied to read cursor                      \n");
      }
    }
  } else {
#line 634
    if (progress) {
      {
#line 634
      fprintf((FILE */* __restrict  */)progress, (char const   */* __restrict  */)"\tCache tail rollbehind: %d sector(s)                        \n",
              rollbehind);
      }
    }
#line 634
    if (log___0) {
      {
#line 634
      fprintf((FILE */* __restrict  */)log___0, (char const   */* __restrict  */)"\tCache tail rollbehind: %d sector(s)                        \n",
              rollbehind);
      }
    }
  }
#line 636
  if (progress) {
    {
#line 636
    fprintf((FILE */* __restrict  */)progress, (char const   */* __restrict  */)"\tTesting granularity of cache tail");
    }
  }
#line 636
  if (log___0) {
    {
#line 636
    fprintf((FILE */* __restrict  */)log___0, (char const   */* __restrict  */)"\tTesting granularity of cache tail");
    }
  }
  {
#line 638
  while (1) {
    while_continue___14: /* CIL Label */ ;
#line 639
    cachegran = cachesize + 1;
#line 640
    i = 0;
    {
#line 640
    while (1) {
      while_continue___15: /* CIL Label */ ;
#line 640
      if (i < 10) {
#line 640
        if (! cachegran) {
#line 640
          goto while_break___15;
        }
      } else {
#line 640
        goto while_break___15;
      }
#line 641
      sofar___3 = 0;
#line 641
      ret___2 = 0;
#line 641
      retry___0 = 0;
#line 642
      if (log___0) {
        {
#line 642
        fprintf((FILE */* __restrict  */)log___0, (char const   */* __restrict  */)"\n\t\t>>> ");
        }
      }
#line 643
      if (progress) {
        {
#line 643
        fprintf((FILE */* __restrict  */)progress, (char const   */* __restrict  */)".");
        }
      }
      {
#line 644
      while (1) {
        while_continue___16: /* CIL Label */ ;
#line 644
        if (! (sofar___3 < cachesize + 1)) {
#line 644
          goto while_break___16;
        }
        {
#line 645
        tmp___20 = cdda_read_timed(d___0, (void *)0, (long )(offset + sofar___3),
                                   (long )((cachesize - sofar___3) + 1), & x);
#line 645
        ret___2 = (int )tmp___20;
        }
#line 646
        if (ret___2 <= 0) {
#line 646
          goto error2;
        }
#line 647
        if (log___0) {
          {
#line 647
          fprintf((FILE */* __restrict  */)log___0, (char const   */* __restrict  */)"%d:%d:%d ",
                  offset + sofar___3, ret___2, x);
          }
        }
#line 648
        sofar___3 += ret___2;
      }
      while_break___16: /* CIL Label */ ;
      }
#line 653
      usec___1 = (int )((mspersector * (float )readahead) * (float )1500);
#line 654
      if (log___0) {
        {
#line 654
        fprintf((FILE */* __restrict  */)log___0, (char const   */* __restrict  */)"\n\t\tsleeping %d microseconds",
                usec___1);
        }
      }
      {
#line 655
      usleep((__useconds_t )usec___1);
      }
#line 659
      if (log___0) {
        {
#line 659
        fprintf((FILE */* __restrict  */)log___0, (char const   */* __restrict  */)"\n\t\t<<< ");
        }
      }
#line 660
      sofar___3 = cachegran;
      {
#line 661
      while (1) {
        while_continue___17: /* CIL Label */ ;
#line 661
        if (! sofar___3) {
#line 661
          goto while_break___17;
        }
        {
#line 662
        sofar___3 --;
#line 663
        tmp___21 = cdda_read_timed(d___0, (void *)0, (long )(offset + sofar___3),
                                   1L, & x);
#line 663
        ret___2 = (int )tmp___21;
        }
#line 664
        if (ret___2 <= 0) {
#line 664
          goto while_break___17;
        }
#line 665
        if (log___0) {
          {
#line 665
          fprintf((FILE */* __restrict  */)log___0, (char const   */* __restrict  */)"%d:%d:%d ",
                  offset + sofar___3, ret___2, x);
          }
        }
#line 666
        if (x >= 6) {
#line 667
          if (cachegran == sofar___3 + 1) {
#line 668
            i ++;
          } else {
#line 670
            cachegran = sofar___3 + 1;
#line 671
            i = 0;
          }
#line 673
          goto while_break___17;
        }
#line 675
        if (sofar___3 == 0) {
#line 675
          cachegran = 0;
        }
      }
      while_break___17: /* CIL Label */ ;
      }
      error2: 
#line 679
      if (ret___2 <= 0) {
#line 680
        offset += cachesize;
#line 681
        retry___0 ++;
#line 682
        if (retry___0 > 10) {
#line 682
          goto _L___3;
        } else
#line 682
        if (offset + cachesize > lastsector) {
          _L___3: /* CIL Label */ 
#line 683
          if (progress) {
            {
#line 683
            fprintf((FILE */* __restrict  */)progress, (char const   */* __restrict  */)"\n\tToo many read errors while performing drive cache checks;\n\t  aborting test.\n\n");
            }
          }
#line 683
          if (log___0) {
            {
#line 683
            fprintf((FILE */* __restrict  */)log___0, (char const   */* __restrict  */)"\n\tToo many read errors while performing drive cache checks;\n\t  aborting test.\n\n");
            }
          }
#line 685
          return (-1);
        }
#line 687
        if (progress) {
          {
#line 687
          fprintf((FILE */* __restrict  */)progress, (char const   */* __restrict  */)"\n\tRead error while performing drive cache checks;\n\t  choosing new offset and trying again.\n");
          }
        }
#line 687
        if (log___0) {
          {
#line 687
          fprintf((FILE */* __restrict  */)log___0, (char const   */* __restrict  */)"\n\tRead error while performing drive cache checks;\n\t  choosing new offset and trying again.\n");
          }
        }
#line 689
        goto __Cont___0;
      }
      __Cont___0: /* CIL Label */ ;
    }
    while_break___15: /* CIL Label */ ;
    }
    {
#line 695
    tmp___22 = retime_drive(d___0, progress, log___0, offset, readahead, mspersector);
#line 695
    newms___0 = tmp___22;
    }
#line 696
    if ((double )newms___0 > (double )mspersector * 1.2) {
#line 697
      mspersector = newms___0;
#line 698
      if (progress) {
        {
#line 698
        fprintf((FILE */* __restrict  */)progress, (char const   */* __restrict  */)"\r");
        }
      }
#line 699
      if (progress) {
        {
#line 699
        fprintf((FILE */* __restrict  */)progress, (char const   */* __restrict  */)"\tDrive timing changed during test; retrying...");
        }
      }
#line 699
      if (log___0) {
        {
#line 699
        fprintf((FILE */* __restrict  */)log___0, (char const   */* __restrict  */)"\tDrive timing changed during test; retrying...");
        }
      }
#line 700
      goto while_continue___14;
    }
#line 703
    goto while_break___14;
  }
  while_break___14: /* CIL Label */ ;
  }
#line 707
  cachegran -= rollbehind;
#line 709
  if (log___0) {
    {
#line 709
    fprintf((FILE */* __restrict  */)log___0, (char const   */* __restrict  */)"\n");
    }
  }
#line 710
  if (progress) {
    {
#line 710
    fprintf((FILE */* __restrict  */)progress, (char const   */* __restrict  */)"\r");
    }
  }
#line 711
  if (progress) {
    {
#line 711
    fprintf((FILE */* __restrict  */)progress, (char const   */* __restrict  */)"\tCache tail granularity: %d sector(s)                      \n",
            cachegran);
    }
  }
#line 711
  if (log___0) {
    {
#line 711
    fprintf((FILE */* __restrict  */)log___0, (char const   */* __restrict  */)"\tCache tail granularity: %d sector(s)                      \n",
            cachegran);
    }
  }
#line 733
  readsize = (cachesize - rollbehind) - 8;
#line 734
  retry___1 = 0;
#line 736
  if (readsize > cachesize - 1) {
#line 736
    readsize = cachesize - 1;
  }
#line 738
  if (readsize < 7) {
#line 739
    if (progress) {
      {
#line 739
      fprintf((FILE */* __restrict  */)progress, (char const   */* __restrict  */)"\tCache size (considering rollbehind) too small to test cache speed.\n");
      }
    }
#line 739
    if (log___0) {
      {
#line 739
      fprintf((FILE */* __restrict  */)log___0, (char const   */* __restrict  */)"\tCache size (considering rollbehind) too small to test cache speed.\n");
      }
    }
  } else {
#line 741
    if (progress) {
      {
#line 741
      fprintf((FILE */* __restrict  */)progress, (char const   */* __restrict  */)"\tTesting cache transfer speed...");
      }
    }
#line 741
    if (log___0) {
      {
#line 741
      fprintf((FILE */* __restrict  */)log___0, (char const   */* __restrict  */)"\tTesting cache transfer speed...");
      }
    }
    {
#line 753
    while (1) {
      while_continue___18: /* CIL Label */ ;
      {
#line 754
      tmp___23 = time_drive(d___0, (FILE *)((void *)0), log___0, offset, readsize,
                            0);
#line 754
      ret___3 = tmp___23;
      }
#line 755
      if (ret___3 == -404) {
#line 755
        return (-1);
      }
#line 756
      if (ret___3 > 0) {
#line 756
        goto while_break___18;
      }
#line 757
      retry___1 ++;
#line 758
      if (retry___1 == 10) {
#line 759
        if (progress) {
          {
#line 759
          fprintf((FILE */* __restrict  */)progress, (char const   */* __restrict  */)"\n\tToo many read errors while performing drive cache checks;\n\t  aborting test.\n\n");
          }
        }
#line 759
        if (log___0) {
          {
#line 759
          fprintf((FILE */* __restrict  */)log___0, (char const   */* __restrict  */)"\n\tToo many read errors while performing drive cache checks;\n\t  aborting test.\n\n");
          }
        }
#line 761
        return (-1);
      }
#line 763
      if (progress) {
        {
#line 763
        fprintf((FILE */* __restrict  */)progress, (char const   */* __restrict  */)"\n\tRead error while performing drive cache checks;\n\t  choosing new offset and trying again.\n");
        }
      }
#line 763
      if (log___0) {
        {
#line 763
        fprintf((FILE */* __restrict  */)log___0, (char const   */* __restrict  */)"\n\tRead error while performing drive cache checks;\n\t  choosing new offset and trying again.\n");
        }
      }
    }
    while_break___18: /* CIL Label */ ;
    }
#line 768
    elapsed = 0;
#line 769
    sectors = 0;
#line 770
    spinner = 0;
    {
#line 771
    while (1) {
      while_continue___19: /* CIL Label */ ;
#line 771
      if (! (elapsed < 5000)) {
#line 771
        goto while_break___19;
      }
      {
#line 772
      sectors += readsize;
#line 773
      tmp___24 = time_drive(d___0, (FILE *)((void *)0), log___0, offset, readsize,
                            0);
#line 773
      elapsed += tmp___24;
#line 774
      spinner = ((elapsed * 5) / 1000) % 4;
      }
#line 775
      if (progress) {
#line 775
        if (spinner == 0) {
#line 775
          tmp___27 = 'o';
        } else {
#line 775
          if (spinner == 1) {
#line 775
            tmp___26 = 'O';
          } else {
#line 775
            if (spinner == 2) {
#line 775
              tmp___25 = 'o';
            } else {
#line 775
              tmp___25 = '.';
            }
#line 775
            tmp___26 = tmp___25;
          }
#line 775
          tmp___27 = tmp___26;
        }
        {
#line 775
        fprintf((FILE */* __restrict  */)progress, (char const   */* __restrict  */)"\b%c",
                tmp___27);
        }
      }
    }
    while_break___19: /* CIL Label */ ;
    }
#line 777
    if (progress) {
      {
#line 777
      fprintf((FILE */* __restrict  */)progress, (char const   */* __restrict  */)"\r");
      }
    }
#line 778
    if (log___0) {
      {
#line 778
      fprintf((FILE */* __restrict  */)log___0, (char const   */* __restrict  */)"\n");
      }
    }
#line 779
    cachems = (float )elapsed / (float )sectors;
#line 780
    if (progress) {
      {
#line 780
      fprintf((FILE */* __restrict  */)progress, (char const   */* __restrict  */)"\t        Cache read speed: %.2fms/sector [%dx]\n",
              (double )cachems, (int )((1000. / 75.) / (double )cachems));
      }
    }
#line 780
    if (log___0) {
      {
#line 780
      fprintf((FILE */* __restrict  */)log___0, (char const   */* __restrict  */)"\t        Cache read speed: %.2fms/sector [%dx]\n",
              (double )cachems, (int )((1000. / 75.) / (double )cachems));
      }
    }
#line 784
    if (cachems * (float )3 > mspersector) {
#line 785
      if (progress) {
        {
#line 785
        fprintf((FILE */* __restrict  */)progress, (char const   */* __restrict  */)"\tCache access insufficiently faster than media access to\n\t\tperform cache backseek tests\n\n");
        }
      }
#line 785
      if (log___0) {
        {
#line 785
        fprintf((FILE */* __restrict  */)log___0, (char const   */* __restrict  */)"\tCache access insufficiently faster than media access to\n\t\tperform cache backseek tests\n\n");
        }
      }
    } else {
#line 790
      if (progress) {
        {
#line 790
        fprintf((FILE */* __restrict  */)progress, (char const   */* __restrict  */)"\tTesting that backseek flushes cache...");
        }
      }
#line 790
      if (log___0) {
        {
#line 790
        fprintf((FILE */* __restrict  */)log___0, (char const   */* __restrict  */)"\tTesting that backseek flushes cache...");
        }
      }
#line 792
      total = 0;
#line 793
      elapsed___0 = 0;
#line 794
      sectors___0 = 0;
#line 795
      spinner___0 = 0;
#line 796
      retry___2 = 0;
      {
#line 797
      while (1) {
        while_continue___20: /* CIL Label */ ;
#line 797
        if (elapsed___0 < 5000) {
#line 797
          if (! (total < 25)) {
#line 797
            goto while_break___20;
          }
        } else {
#line 797
          goto while_break___20;
        }
        {
#line 799
        while (1) {
          while_continue___21: /* CIL Label */ ;
#line 801
          seekpos = (offset + cachesize) + 20000;
#line 802
          if (seekpos > lastsector - 150) {
#line 802
            seekpos = lastsector - 150;
          }
          {
#line 803
          tmp___28 = cdda_read(d___0, (void *)0, (long )seekpos, 1L);
#line 803
          ret___4 = (int )tmp___28;
          }
#line 804
          if (ret___4 > 0) {
            {
#line 804
            ret___4 = time_drive(d___0, (FILE *)((void *)0), log___0, offset + 1,
                                 readsize, 1);
            }
          }
#line 805
          if (ret___4 >= 0) {
            {
#line 805
            ret___4 = time_drive(d___0, (FILE *)((void *)0), log___0, offset, readsize,
                                 1);
            }
          }
#line 807
          if (ret___4 <= 0) {
#line 808
            retry___2 ++;
#line 809
            if (retry___2 == 10) {
#line 810
              if (progress) {
                {
#line 810
                fprintf((FILE */* __restrict  */)progress, (char const   */* __restrict  */)"\n\tToo many read errors while performing drive cache checks;\n\t  aborting test.\n\n");
                }
              }
#line 810
              if (log___0) {
                {
#line 810
                fprintf((FILE */* __restrict  */)log___0, (char const   */* __restrict  */)"\n\tToo many read errors while performing drive cache checks;\n\t  aborting test.\n\n");
                }
              }
#line 812
              return (-1);
            }
#line 814
            if (progress) {
              {
#line 814
              fprintf((FILE */* __restrict  */)progress, (char const   */* __restrict  */)"\n\tRead error while performing drive cache checks; retrying...");
              }
            }
#line 814
            if (log___0) {
              {
#line 814
              fprintf((FILE */* __restrict  */)log___0, (char const   */* __restrict  */)"\n\tRead error while performing drive cache checks; retrying...");
              }
            }
          } else {
#line 816
            goto while_break___21;
          }
        }
        while_break___21: /* CIL Label */ ;
        }
#line 819
        sectors___0 += readsize - 1;
#line 820
        elapsed___0 += ret___4;
#line 821
        total ++;
#line 823
        spinner___0 = ((elapsed___0 * 5) / 1000) % 4;
#line 824
        if (progress) {
#line 824
          if (spinner___0 == 0) {
#line 824
            tmp___31 = 'o';
          } else {
#line 824
            if (spinner___0 == 1) {
#line 824
              tmp___30 = 'O';
            } else {
#line 824
              if (spinner___0 == 2) {
#line 824
                tmp___29 = 'o';
              } else {
#line 824
                tmp___29 = '.';
              }
#line 824
              tmp___30 = tmp___29;
            }
#line 824
            tmp___31 = tmp___30;
          }
          {
#line 824
          fprintf((FILE */* __restrict  */)progress, (char const   */* __restrict  */)"\b%c",
                  tmp___31);
          }
        }
      }
      while_break___20: /* CIL Label */ ;
      }
#line 827
      if (progress) {
        {
#line 827
        fprintf((FILE */* __restrict  */)progress, (char const   */* __restrict  */)"\r");
        }
      }
#line 828
      if (log___0) {
        {
#line 828
        fprintf((FILE */* __restrict  */)log___0, (char const   */* __restrict  */)"\n");
        }
      }
#line 829
      readms = (float )elapsed___0 / (float )sectors___0;
#line 830
      if (progress) {
        {
#line 830
        fprintf((FILE */* __restrict  */)progress, (char const   */* __restrict  */)"\t        Access speed after backseek: %.2fms/sector [%dx]\n",
                (double )readms, (int )((1000. / 75.) / (double )readms));
        }
      }
#line 830
      if (log___0) {
        {
#line 830
        fprintf((FILE */* __restrict  */)log___0, (char const   */* __restrict  */)"\t        Access speed after backseek: %.2fms/sector [%dx]\n",
                (double )readms, (int )((1000. / 75.) / (double )readms));
        }
      }
#line 832
      if ((double )readms * 2. < (double )mspersector) {
#line 832
        goto _L___4;
      } else
#line 832
      if ((double )cachems * 2. > (double )readms) {
        _L___4: /* CIL Label */ 
#line 834
        if (progress) {
          {
#line 834
          fprintf((FILE */* __restrict  */)progress, (char const   */* __restrict  */)"\tWARNING: Read timing after backseek faster than expected!\n\t         It\'s possible/likely that this drive is not\n\t         flushing the readahead cache on backward seeks!\n\n");
          }
        }
#line 834
        if (log___0) {
          {
#line 834
          fprintf((FILE */* __restrict  */)log___0, (char const   */* __restrict  */)"\tWARNING: Read timing after backseek faster than expected!\n\t         It\'s possible/likely that this drive is not\n\t         flushing the readahead cache on backward seeks!\n\n");
          }
        }
#line 837
        warn = 1;
      } else {
#line 839
        if (progress) {
          {
#line 839
          fprintf((FILE */* __restrict  */)progress, (char const   */* __restrict  */)"\tBackseek flushes the cache as expected\n");
          }
        }
#line 839
        if (log___0) {
          {
#line 839
          fprintf((FILE */* __restrict  */)log___0, (char const   */* __restrict  */)"\tBackseek flushes the cache as expected\n");
          }
        }
      }
    }
  }
#line 849
  return (warn);
}
}
#line 819 "/usr/include/stdio.h"
extern void perror(char const   *__s ) ;
#line 7 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/utils.h"
long buffering_write(int fd , char *buffer , long num ) ;
#line 8
int buffering_close(int fd ) ;
#line 12 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/buffering_write.c"
long blocking_write(int outf , char *buffer , long num ) ;
#line 16 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/buffering_write.c"
static int bw_fd  =    -1;
#line 17 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/buffering_write.c"
static long bw_pos  =    0L;
#line 18 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/buffering_write.c"
static char bw_outbuf[32768]  ;
#line 27 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/buffering_write.c"
long buffering_write(int fd , char *buffer , long num ) 
{ 
  long tmp ;
  long tmp___0 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
#line 29
  if (fd != bw_fd) {
#line 31
    if (bw_fd >= 0) {
#line 31
      if (bw_pos > 0L) {
        {
#line 32
        tmp = blocking_write(bw_fd, bw_outbuf, bw_pos);
        }
#line 32
        if (tmp) {
          {
#line 33
          perror("write (in buffering_write, flushing)");
          }
        }
      }
    }
#line 36
    bw_fd = fd;
#line 37
    bw_pos = 0L;
  }
#line 40
  if (bw_pos + num > 32768L) {
    {
#line 42
    memcpy((void */* __restrict  */)(& bw_outbuf[bw_pos]), (void const   */* __restrict  */)buffer,
           (size_t )(32768L - bw_pos));
#line 43
    tmp___0 = blocking_write(fd, bw_outbuf, 32768L);
    }
#line 43
    if (tmp___0) {
      {
#line 44
      perror("write (in buffering_write, full buffer)");
      }
#line 45
      return (-1L);
    }
#line 47
    num -= 32768L - bw_pos;
#line 48
    buffer += 32768L - bw_pos;
#line 49
    bw_pos = 0L;
  }
#line 52
  if (buffer) {
#line 52
    if (num) {
      {
#line 53
      memcpy((void */* __restrict  */)(& bw_outbuf[bw_pos]), (void const   */* __restrict  */)buffer,
             (size_t )num);
      }
    }
  }
#line 54
  bw_pos += num;
#line 56
  return (0L);
}
}
#line 63 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/buffering_write.c"
int buffering_close(int fd ) 
{ 
  long tmp ;
  int tmp___0 ;
  char *__cil_tmp4 ;

  {
#line 65
  if (fd == bw_fd) {
#line 65
    if (bw_pos > 0L) {
      {
#line 67
      tmp = blocking_write(fd, bw_outbuf, bw_pos);
      }
#line 67
      if (tmp) {
        {
#line 68
        perror("write (in buffering_close)");
        }
      }
#line 70
      bw_fd = -1;
#line 71
      bw_pos = 0L;
    }
  }
  {
#line 73
  tmp___0 = close(fd);
  }
#line 73
  return (tmp___0);
}
}
#line 15 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/header.c"
static void PutNum(long num , int f , int endianness , int bytes ) 
{ 
  int i ;
  unsigned char c ;
  ssize_t tmp ;
  int tmp___0 ;
  char *__cil_tmp9 ;

  {
#line 19
  if (! endianness) {
#line 20
    i = 0;
  } else {
#line 22
    i = bytes - 1;
  }
  {
#line 23
  while (1) {
    while_continue: /* CIL Label */ ;
#line 23
    tmp___0 = bytes;
#line 23
    bytes --;
#line 23
    if (! tmp___0) {
#line 23
      goto while_break;
    }
    {
#line 24
    c = (unsigned char )((num >> (i << 3)) & 255L);
#line 25
    tmp = write(f, (void const   *)(& c), (size_t )1);
    }
#line 25
    if (tmp == -1) {
      {
#line 26
      perror("Could not write to output.");
#line 27
      exit(1);
      }
    }
#line 29
    if (endianness) {
#line 30
      i --;
    } else {
#line 32
      i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 34
  return;
}
}
#line 36 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/header.c"
void WriteWav(int f , long bytes ) 
{ 
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;

  {
  {
#line 39
  write(f, (void const   *)"RIFF", (size_t )4);
#line 40
  PutNum((bytes + 44L) - 8L, f, 0, 4);
#line 41
  write(f, (void const   *)"WAVEfmt ", (size_t )8);
#line 42
  PutNum(16L, f, 0, 4);
#line 43
  PutNum(1L, f, 0, 2);
#line 44
  PutNum(2L, f, 0, 2);
#line 45
  PutNum(44100L, f, 0, 4);
#line 46
  PutNum(176400L, f, 0, 4);
#line 47
  PutNum(4L, f, 0, 2);
#line 48
  PutNum(16L, f, 0, 2);
#line 49
  write(f, (void const   *)"data", (size_t )4);
#line 50
  PutNum(bytes, f, 0, 4);
  }
#line 51
  return;
}
}
#line 53 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/header.c"
void WriteAiff(int f , long bytes ) 
{ 
  long size ;
  long frames ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
  {
#line 54
  size = bytes + 54L;
#line 55
  frames = bytes / 4L;
#line 59
  write(f, (void const   *)"FORM", (size_t )4);
#line 60
  PutNum(size - 8L, f, 1, 4);
#line 61
  write(f, (void const   *)"AIFF", (size_t )4);
#line 63
  write(f, (void const   *)"COMM", (size_t )4);
#line 64
  PutNum(18L, f, 1, 4);
#line 65
  PutNum(2L, f, 1, 2);
#line 66
  PutNum(frames, f, 1, 4);
#line 67
  PutNum(16L, f, 1, 2);
#line 68
  write(f, (void const   *)"@\016\254D\000\000\000\000\000\000", (size_t )10);
#line 70
  write(f, (void const   *)"SSND", (size_t )4);
#line 71
  PutNum(bytes + 8L, f, 1, 4);
#line 72
  PutNum(0L, f, 1, 4);
#line 73
  PutNum(0L, f, 1, 4);
  }
#line 75
  return;
}
}
#line 77 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/header.c"
void WriteAifc(int f , long bytes ) 
{ 
  long size ;
  long frames ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;

  {
  {
#line 78
  size = bytes + 86L;
#line 79
  frames = bytes / 4L;
#line 83
  write(f, (void const   *)"FORM", (size_t )4);
#line 84
  PutNum(size - 8L, f, 1, 4);
#line 85
  write(f, (void const   *)"AIFC", (size_t )4);
#line 86
  write(f, (void const   *)"FVER", (size_t )4);
#line 87
  PutNum(4L, f, 1, 4);
#line 88
  PutNum(2726318400L, f, 1, 4);
#line 90
  write(f, (void const   *)"COMM", (size_t )4);
#line 91
  PutNum(38L, f, 1, 4);
#line 92
  PutNum(2L, f, 1, 2);
#line 93
  PutNum(frames, f, 1, 4);
#line 94
  PutNum(16L, f, 1, 2);
#line 95
  write(f, (void const   *)"@\016\254D\000\000\000\000\000\000", (size_t )10);
#line 97
  write(f, (void const   *)"NONE", (size_t )4);
#line 98
  PutNum(14L, f, 1, 1);
#line 99
  write(f, (void const   *)"not compressed", (size_t )14);
#line 100
  PutNum(0L, f, 1, 1);
#line 102
  write(f, (void const   *)"SSND", (size_t )4);
#line 103
  PutNum(bytes + 8L, f, 1, 4);
#line 104
  PutNum(0L, f, 1, 4);
#line 105
  PutNum(0L, f, 1, 4);
  }
#line 107
  return;
}
}
#line 4 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/report.c"
int quiet  =    0;
#line 5 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/report.c"
int verbose  =    0;
#line 6 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/report.c"
FILE *reportfile  =    (FILE *)((void *)0);
#line 146 "/usr/include/stdio.h"
extern struct _IO_FILE *stdout ;
#line 214
extern int fclose(FILE *__stream ) ;
#line 219
extern int fflush(FILE *__stream ) ;
#line 249
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 363
extern  __attribute__((__nothrow__)) int ( /* format attribute */  snprintf)(char * __restrict  __s ,
                                                                             size_t __maxlen ,
                                                                             char const   * __restrict  __format 
                                                                             , ...) ;
#line 555
extern int fputc(int __c , FILE *__stream ) ;
#line 831
extern  __attribute__((__nothrow__)) int fileno(FILE *__stream ) ;
#line 148 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 517
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) atexit)(void (*__func)(void) ) ;
#line 692 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) __uid_t getuid(void) ;
#line 698
extern  __attribute__((__nothrow__)) __gid_t getgid(void) ;
#line 727
extern  __attribute__((__nothrow__)) int seteuid(__uid_t __uid ) ;
#line 744
extern  __attribute__((__nothrow__)) int setegid(__gid_t __gid ) ;
#line 795
extern  __attribute__((__nothrow__)) int isatty(int __fd ) ;
#line 842
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) unlink)(char const   *__name ) ;
#line 59 "/usr/include/getopt.h"
extern char *optarg ;
#line 73
extern int optind ;
#line 286 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1,2))) strspn)(char const   *__s ,
                                                                                        char const   *__accept )  __attribute__((__pure__)) ;
#line 175 "/usr/include/getopt.h"
extern  __attribute__((__nothrow__)) int getopt_long(int ___argc , char * const  *___argv ,
                                                     char const   *__shortopts , struct option  const  *__longopts ,
                                                     int *__longind ) ;
#line 73 "/usr/include/sys/time.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) gettimeofday)(struct timeval * __restrict  __tv ,
                                                                                         __timezone_ptr_t __tz ) ;
#line 87 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/utils.h"
__inline static char *copystring___3(char const   *s ) 
{ 
  char *ret ;
  size_t tmp ;
  void *tmp___0 ;

  {
#line 88
  if (s) {
    {
#line 89
    tmp = strlen(s);
#line 89
    tmp___0 = malloc((size_t )((unsigned long )(tmp + 1U) * sizeof(char )));
#line 89
    ret = (char *)tmp___0;
#line 90
    strcpy((char */* __restrict  */)ret, (char const   */* __restrict  */)s);
    }
#line 91
    return (ret);
  }
#line 93
  return ((char *)((void *)0));
}
}
#line 43 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/main.c"
static long parse_offset(cdrom_drive *d___0 , char *offset , int begin ) 
{ 
  long track ;
  long hours ;
  long minutes ;
  long seconds ;
  long sectors ;
  char *time ;
  char *temp ;
  long ret ;
  int chars ;
  size_t tmp ;
  int tmp___0 ;
  long val ;
  long chars___0 ;
  char *sec ;
  char *tmp___1 ;
  size_t tmp___2 ;
  int tmp___3 ;
  long tmp___4 ;
  long tmp___5 ;
  int tmp___6 ;
  long tmp___7 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;

  {
#line 44
  track = -1L;
#line 45
  hours = -1L;
#line 46
  minutes = -1L;
#line 47
  seconds = -1L;
#line 48
  sectors = -1L;
#line 49
  time = (char *)((void *)0);
#line 49
  temp = (char *)((void *)0);
#line 52
  if ((unsigned long )offset == (unsigned long )((void *)0)) {
#line 52
    return (-1L);
  }
  {
#line 55
  temp = strchr((char const   *)offset, ']');
  }
#line 56
  if (temp) {
    {
#line 57
    *temp = (char )'\000';
#line 58
    temp = strchr((char const   *)offset, '[');
    }
#line 59
    if ((unsigned long )temp == (unsigned long )((void *)0)) {
#line 60
      if (! quiet) {
        {
#line 60
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error parsing span argument");
#line 60
        fputc('\n', stderr);
        }
      }
#line 60
      if (reportfile) {
        {
#line 60
        fprintf((FILE */* __restrict  */)reportfile, (char const   */* __restrict  */)"Error parsing span argument");
#line 60
        fputc('\n', reportfile);
        }
      }
      {
#line 61
      exit(1);
      }
    }
#line 63
    *temp = (char )'\000';
#line 64
    time = temp + 1;
  }
  {
#line 69
  tmp = strspn((char const   *)offset, "0123456789");
#line 69
  chars = (int )tmp;
  }
#line 70
  if (chars > 0) {
    {
#line 71
    *(offset + chars) = (char )'\000';
#line 72
    tmp___0 = atoi((char const   *)offset);
#line 72
    track = (long )tmp___0;
    }
#line 73
    if (track < 0L) {
#line 73
      goto _L;
    } else
#line 73
    if (track > (long )d___0->tracks) {
      _L: /* CIL Label */ 
#line 74
      if (! quiet) {
        {
#line 74
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Track #%ld does not exist.",
                track);
#line 74
        fputc('\n', stderr);
        }
      }
#line 74
      if (reportfile) {
        {
#line 74
        fprintf((FILE */* __restrict  */)reportfile, (char const   */* __restrict  */)"Track #%ld does not exist.",
                track);
#line 74
        fputc('\n', reportfile);
        }
      }
      {
#line 75
      exit(1);
      }
    }
  }
  {
#line 80
  while (1) {
    while_continue: /* CIL Label */ ;
#line 80
    if (! time) {
#line 80
      goto while_break;
    }
    {
#line 82
    tmp___1 = strrchr((char const   *)time, '.');
#line 82
    sec = tmp___1;
    }
#line 83
    if (! sec) {
      {
#line 83
      sec = strrchr((char const   *)time, ':');
      }
    }
#line 84
    if (! sec) {
#line 84
      sec = time - 1;
    }
    {
#line 86
    tmp___2 = strspn((char const   *)(sec + 1), "0123456789");
#line 86
    chars___0 = (long )tmp___2;
    }
#line 87
    if (chars___0) {
      {
#line 88
      tmp___3 = atoi((char const   *)(sec + 1));
#line 88
      val = (long )tmp___3;
      }
    } else {
#line 90
      val = 0L;
    }
    {
#line 93
    if ((int )*sec == 46) {
#line 93
      goto case_46;
    }
#line 100
    goto switch_default;
    case_46: /* CIL Label */ 
#line 94
    if (sectors != -1L) {
#line 95
      if (! quiet) {
        {
#line 95
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error parsing span argument");
#line 95
        fputc('\n', stderr);
        }
      }
#line 95
      if (reportfile) {
        {
#line 95
        fprintf((FILE */* __restrict  */)reportfile, (char const   */* __restrict  */)"Error parsing span argument");
#line 95
        fputc('\n', reportfile);
        }
      }
      {
#line 96
      exit(1);
      }
    }
#line 98
    sectors = val;
#line 99
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 101
    if (seconds == -1L) {
#line 102
      seconds = val;
    } else
#line 104
    if (minutes == -1L) {
#line 105
      minutes = val;
    } else
#line 107
    if (hours == -1L) {
#line 108
      hours = val;
    } else {
#line 110
      if (! quiet) {
        {
#line 110
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error parsing span argument");
#line 110
        fputc('\n', stderr);
        }
      }
#line 110
      if (reportfile) {
        {
#line 110
        fprintf((FILE */* __restrict  */)reportfile, (char const   */* __restrict  */)"Error parsing span argument");
#line 110
        fputc('\n', reportfile);
        }
      }
      {
#line 111
      exit(1);
      }
    }
#line 113
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 116
    if ((unsigned long )sec <= (unsigned long )time) {
#line 116
      goto while_break;
    }
#line 117
    *sec = (char )'\000';
  }
  while_break: /* CIL Label */ ;
  }
#line 120
  if (track == -1L) {
#line 121
    if (seconds == -1L) {
#line 121
      if (sectors == -1L) {
#line 121
        return (-1L);
      }
    }
#line 122
    if (begin == -1) {
      {
#line 123
      ret = cdda_disc_firstsector(d___0);
      }
    } else {
#line 125
      ret = (long )begin;
    }
  } else
#line 127
  if (seconds == -1L) {
#line 127
    if (sectors == -1L) {
#line 128
      if (begin == -1) {
        {
#line 129
        tmp___4 = cdda_track_firstsector(d___0, (int )track);
        }
#line 129
        return (tmp___4);
      } else {
        {
#line 131
        tmp___5 = cdda_track_lastsector(d___0, (int )track);
        }
#line 131
        return (tmp___5);
      }
    } else {
      {
#line 135
      ret = cdda_track_firstsector(d___0, (int )track);
      }
    }
  } else {
    {
#line 135
    ret = cdda_track_firstsector(d___0, (int )track);
    }
  }
#line 141
  if (sectors != -1L) {
#line 141
    ret += sectors;
  }
#line 142
  if (seconds != -1L) {
#line 142
    ret += seconds * 75L;
  }
#line 143
  if (minutes != -1L) {
#line 143
    ret += (minutes * 60L) * 75L;
  }
#line 144
  if (hours != -1L) {
#line 144
    ret += ((hours * 60L) * 60L) * 75L;
  }
#line 147
  if (track != -1L) {
    {
#line 148
    tmp___6 = cdda_sector_gettrack(d___0, ret);
    }
#line 148
    if ((long )tmp___6 != track) {
#line 149
      if (! quiet) {
        {
#line 149
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Time/sector offset goes beyond end of specified track.");
#line 149
        fputc('\n', stderr);
        }
      }
#line 149
      if (reportfile) {
        {
#line 149
        fprintf((FILE */* __restrict  */)reportfile, (char const   */* __restrict  */)"Time/sector offset goes beyond end of specified track.");
#line 149
        fputc('\n', reportfile);
        }
      }
      {
#line 150
      exit(1);
      }
    }
  }
  {
#line 156
  tmp___7 = cdda_disc_lastsector(d___0);
  }
#line 156
  if (ret > tmp___7) {
#line 157
    if (! quiet) {
      {
#line 157
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Time/sector offset goes beyond end of disc.");
#line 157
      fputc('\n', stderr);
      }
    }
#line 157
    if (reportfile) {
      {
#line 157
      fprintf((FILE */* __restrict  */)reportfile, (char const   */* __restrict  */)"Time/sector offset goes beyond end of disc.");
#line 157
      fputc('\n', reportfile);
      }
    }
    {
#line 158
    exit(1);
    }
  }
#line 161
  return (ret);
}
}
#line 166 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/main.c"
static void display_toc(cdrom_drive *d___0 ) 
{ 
  long audiolen ;
  int i ;
  long sec ;
  long tmp ;
  long off ;
  long tmp___0 ;
  char const   *tmp___2 ;
  int tmp___3 ;
  char const   *tmp___5 ;
  int tmp___6 ;
  char const   *tmp___8 ;
  int tmp___9 ;
  char const   *tmp___11 ;
  int tmp___12 ;
  char const   *tmp___14 ;
  int tmp___15 ;
  char const   *tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;

  {
#line 167
  audiolen = 0L;
#line 169
  if (! quiet) {
    {
#line 169
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\nTable of contents (audio tracks only):\ntrack        length               begin        copy pre ch\n===========================================================");
#line 169
    fputc('\n', stderr);
    }
  }
#line 169
  if (reportfile) {
    {
#line 169
    fprintf((FILE */* __restrict  */)reportfile, (char const   */* __restrict  */)"\nTable of contents (audio tracks only):\ntrack        length               begin        copy pre ch\n===========================================================");
#line 169
    fputc('\n', reportfile);
    }
  }
#line 173
  i = 1;
  {
#line 173
  while (1) {
    while_continue: /* CIL Label */ ;
#line 173
    if (! (i <= d___0->tracks)) {
#line 173
      goto while_break;
    }
    {
#line 174
    tmp___19 = cdda_track_audiop(d___0, i);
    }
#line 174
    if (tmp___19 > 0) {
      {
#line 176
      tmp = cdda_track_firstsector(d___0, i);
#line 176
      sec = tmp;
#line 177
      tmp___0 = cdda_track_lastsector(d___0, i);
#line 177
      off = (tmp___0 - sec) + 1L;
      }
#line 179
      if (! quiet) {
        {
#line 179
        tmp___3 = cdda_track_channels(d___0, i);
        }
#line 179
        if (tmp___3 == 2) {
#line 179
          tmp___2 = " 2";
        } else {
#line 179
          tmp___2 = " 4";
        }
        {
#line 179
        tmp___6 = cdda_track_preemp(d___0, i);
        }
#line 179
        if (tmp___6) {
#line 179
          tmp___5 = " yes";
        } else {
#line 179
          tmp___5 = "  no";
        }
        {
#line 179
        tmp___9 = cdda_track_copyp(d___0, i);
        }
#line 179
        if (tmp___9) {
#line 179
          tmp___8 = "  OK";
        } else {
#line 179
          tmp___8 = "  no";
        }
        {
#line 179
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%3d.  %7ld [%02d:%02d.%02d]  %7ld [%02d:%02d.%02d]  %s %s %s",
                i, off, (int )(off / 4500L), (int )((off / 75L) % 60L), (int )(off % 75L),
                sec, (int )(sec / 4500L), (int )((sec / 75L) % 60L), (int )(sec % 75L),
                tmp___8, tmp___5, tmp___2);
#line 179
        fputc('\n', stderr);
        }
      }
#line 179
      if (reportfile) {
        {
#line 179
        tmp___12 = cdda_track_channels(d___0, i);
        }
#line 179
        if (tmp___12 == 2) {
#line 179
          tmp___11 = " 2";
        } else {
#line 179
          tmp___11 = " 4";
        }
        {
#line 179
        tmp___15 = cdda_track_preemp(d___0, i);
        }
#line 179
        if (tmp___15) {
#line 179
          tmp___14 = " yes";
        } else {
#line 179
          tmp___14 = "  no";
        }
        {
#line 179
        tmp___18 = cdda_track_copyp(d___0, i);
        }
#line 179
        if (tmp___18) {
#line 179
          tmp___17 = "  OK";
        } else {
#line 179
          tmp___17 = "  no";
        }
        {
#line 179
        fprintf((FILE */* __restrict  */)reportfile, (char const   */* __restrict  */)"%3d.  %7ld [%02d:%02d.%02d]  %7ld [%02d:%02d.%02d]  %s %s %s",
                i, off, (int )(off / 4500L), (int )((off / 75L) % 60L), (int )(off % 75L),
                sec, (int )(sec / 4500L), (int )((sec / 75L) % 60L), (int )(sec % 75L),
                tmp___17, tmp___14, tmp___11);
#line 179
        fputc('\n', reportfile);
        }
      }
#line 186
      audiolen += off;
    }
#line 173
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 188
  if (! quiet) {
    {
#line 188
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"TOTAL %7ld [%02d:%02d.%02d]    (audio only)",
            audiolen, (int )(audiolen / 4500L), (int )((audiolen / 75L) % 60L), (int )(audiolen % 75L));
#line 188
    fputc('\n', stderr);
    }
  }
#line 188
  if (reportfile) {
    {
#line 188
    fprintf((FILE */* __restrict  */)reportfile, (char const   */* __restrict  */)"TOTAL %7ld [%02d:%02d.%02d]    (audio only)",
            audiolen, (int )(audiolen / 4500L), (int )((audiolen / 75L) % 60L), (int )(audiolen % 75L));
#line 188
    fputc('\n', reportfile);
    }
  }
#line 191
  if (! quiet) {
    {
#line 191
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" ");
#line 191
    fputc('\n', stderr);
    }
  }
#line 191
  if (reportfile) {
    {
#line 191
    fprintf((FILE */* __restrict  */)reportfile, (char const   */* __restrict  */)" ");
#line 191
    fputc('\n', reportfile);
    }
  }
#line 192
  return;
}
}
#line 194 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/main.c"
static void usage(FILE *f ) 
{ 
  char *__cil_tmp2 ;

  {
  {
#line 195
  fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"cdparanoia III release 10.2 (September 11, 2008)\n\n(C) 2008 Monty <monty@xiph.org> and Xiph.Org\n\nReport bugs to paranoia@xiph.org\nhttp://www.xiph.org/paranoia/\nUSAGE:\n  cdparanoia [options] <span> [outfile]\n\nOPTIONS:\n  -A --analyze-drive              : run and log a complete analysis of drive\n                                    caching, timing and reading behavior;\n                                    verifies that cdparanoia is correctly\n                                    modelling a sprcific drive\'s cache and\n                                    read behavior. Implies -vQL\n\n  -v --verbose                    : extra verbose operation\n  -q --quiet                      : quiet operation\n  -e --stderr-progress            : force output of progress information to\n                                    stderr (for wrapper scripts)\n  -l --log-summary [<file>]       : save result summary to file, default\n                                    filename cdparanoia.log\n  -L --log-debug   [<file>]       : save detailed device autosense and\n                                    debugging output to file, default\n                                    filename cdparanoia.log\n  -V --version                    : print version info and quit\n  -Q --query                      : autosense drive, query disc and quit\n  -B --batch                      : \'batch\' mode (saves each track to a\n                                    seperate file.\n  -s --search-for-drive           : do an exhaustive search for drive\n  -h --help                       : print help\n\n  -p --output-raw                 : output raw 16 bit PCM in host byte \n                                    order\n  -r --output-raw-little-endian   : output raw 16 bit little-endian PCM\n  -R --output-raw-big-endian      : output raw 16 bit big-endian PCM\n  -w --output-wav                 : output as WAV file (default)\n  -f --output-aiff                : output as AIFF file\n  -a --output-aifc                : output as AIFF-C file\n\n  -c --force-cdrom-little-endian  : force treating drive as little endian\n  -C --force-cdrom-big-endian     : force treating drive as big endian\n  -n --force-default-sectors <n>  : force default number of sectors in read\n                                    to n sectors\n  -o --force-search-overlap  <n>  : force minimum overlap search during\n                                    verification to n sectors\n  -d --force-cdrom-device   <dev> : use specified device; disallow \n                                    autosense\n  -k --force-cooked-device  <dev> : use specified cdrom device and force\n                                    use of the old \'cooked ioctl\' kernel\n                                    interface. -k cannot be used with -d\n                                    or -g.\n  -g --force-generic-device <dev> : use specified generic scsi device and\n                                    force use of the old SG kernel\n                                    interface. -g cannot be used with -k.\n  -S --force-read-speed <n>       : read from device at specified speed; by\n                                    default, cdparanoia sets drive to full\n                                    speed.\n  -t --toc-offset <n>             : Add <n> sectors to the values reported\n                                    when addressing tracks. May be negative\n  -T --toc-bias                   : Assume that the beginning offset of \n                                    track 1 as reported in the TOC will be\n                                    addressed as LBA 0.  Necessary for some\n                                    Toshiba drives to get track boundaries\n                                    correct\n  -O --sample-offset <n>          : Add <n> samples to the offset when\n                                    reading data.  May be negative.\n  -z --never-skip[=n]             : never accept any less than perfect\n                                    data reconstruction (don\'t allow \'V\'s)\n                                    but if [n] is given, skip after [n]\n                                    retries without progress.\n  -Z --disable-paranoia           : disable all paranoia checking\n  -Y --disable-extra-paranoia     : only do cdda2wav-style overlap checking\n  -X --abort-on-skip              : abort on imperfect reads/skips\n\nOUTPUT SMILIES:\n  :-)   Normal operation, low/no jitter\n  :-|   Normal operation, considerable jitter\n  :-/   Read drift\n  :-P   Unreported loss of streaming in atomic read operation\n  8-|   Finding read problems at same point during reread; hard to correct\n  :-0   SCSI/ATAPI transport error\n  :-(   Scratch detected\n  ;-(   Gave up trying to perform a correction\n  8-X   Aborted (as per -X) due to a scratch/skip\n  :^D   Finished extracting\n\nPROGRESS BAR SYMBOLS:\n<space> No corrections needed\n   -    Jitter correction required\n   +    Unreported loss of streaming/other error in read\n   !    Errors are getting through stage 1 but corrected in stage2\n   e    SCSI/ATAPI transport error (corrected)\n   V    Uncorrected error/skip\n\nSPAN ARGUMENT:\nThe span argument may be a simple track number or a offset/span\nspecification.  The syntax of an offset/span takes the rough form:\n\n                       1[ww:xx:yy.zz]-2[aa:bb:cc.dd] \n\nHere, 1 and 2 are track numbers; the numbers in brackets provide a\nfiner grained offset within a particular track. [aa:bb:cc.dd] is in\nhours/minutes/seconds/sectors format. Zero fields need not be\nspecified: [::20], [:20], [20], [20.], etc, would be interpreted as\ntwenty seconds, [10:] would be ten minutes, [.30] would be thirty\nsectors (75 sectors per second).\n\nWhen only a single offset is supplied, it is interpreted as a starting\noffset and ripping will continue to the end of he track.  If a single\noffset is preceeded or followed by a hyphen, the implicit missing\noffset is taken to be the start or end of the disc, respectively. Thus:\n\n    1:[20.35]    Specifies ripping from track 1, second 20, sector 35 to \n                 the end of track 1.\n\n    1:[20.35]-   Specifies ripping from 1[20.35] to the end of the disc\n\n    -2           Specifies ripping from the beginning of the disc up to\n                 (and including) track 2\n\n    -2:[30.35]   Specifies ripping from the beginning of the disc up to\n                 2:[30.35]\n\n    2-4          Specifies ripping from the beginning of track two to the\n                 end of track 4.\n\nDon\'t forget to protect square brackets and preceeding hyphens from\nthe shell...\n\nA few examples, protected from the shell:\n  A) query only with exhaustive search for a drive and full reporting\n     of autosense:\n       cdparanoia -vsQ\n\n  B) extract up to and including track 3, putting each track in a seperate\n     file:\n       cdparanoia -B -- \"-3\"\n\n  C) extract from track 1, time 0:30.12 to 1:10.00:\n       cdparanoia \"1[:30.12]-1[1:10]\"\n\nSubmit bug reports to paranoia@xiph.org\n\n");
  }
#line 336
  return;
}
}
#line 338 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/main.c"
long callbegin  ;
#line 339 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/main.c"
long callend  ;
#line 340 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/main.c"
long callscript  =    0L;
#line 342 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/main.c"
static char *callback_strings[16]  = 
#line 342
  {      (char *)"wrote",      (char *)"finished",      (char *)"read",      (char *)"verify", 
        (char *)"jitter",      (char *)"correction",      (char *)"scratch",      (char *)"scratch repair", 
        (char *)"skip",      (char *)"drift",      (char *)"backoff",      (char *)"overlap", 
        (char *)"dropped",      (char *)"duped",      (char *)"transport error",      (char *)"cache error"};
#line 359 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/main.c"
static int skipped_flag  =    0;
#line 360 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/main.c"
static int abort_on_skip  =    0;
#line 361 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/main.c"
FILE *logfile  =    (FILE *)((void *)0);
#line 371
static void callback(long inpos , int function ) ;
#line 371 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/main.c"
static long c_sector  =    0L;
#line 371 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/main.c"
static long v_sector  =    0L;
#line 372 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/main.c"
static char dispcache[31]  = 
#line 372
  {      (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )'\000'};
#line 373 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/main.c"
static int last  =    0;
#line 374 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/main.c"
static long lasttime  =    0L;
#line 377 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/main.c"
static char heartbeat  =    (char )' ';
#line 379 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/main.c"
static int overlap  =    0;
#line 380 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/main.c"
static int printit  =    -1;
#line 382 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/main.c"
static int slevel  =    0;
#line 383 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/main.c"
static int slast  =    0;
#line 384 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/main.c"
static int stimeout  =    0;
#line 385 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/main.c"
static int cacheerr  =    0;
#line 362 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/main.c"
static void callback(long inpos , int function ) 
{ 
  int graph ;
  char buffer[256] ;
  long sector ;
  long osector ;
  struct timeval thistime ;
  int position ;
  int aheadposition ;
  char *smilie ;
  char const   *tmp ;
  long test ;
  int tmp___0 ;
  void *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;

  {
#line 369
  graph = 30;
#line 375
  osector = 0L;
#line 378
  position = 0;
#line 378
  aheadposition = 0;
#line 386
  smilie = (char *)"= :-)";
#line 388
  if (callscript) {
#line 389
    if (function >= -2) {
#line 389
      if (function <= 13) {
#line 389
        tmp = (char const   *)callback_strings[function + 2];
      } else {
#line 389
        tmp = "";
      }
    } else {
#line 389
      tmp = "";
    }
    {
#line 389
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"##: %d [%s] @ %ld\n",
            function, tmp, inpos);
    }
  } else
#line 393
  if (function == 13) {
#line 394
    if (! cacheerr) {
      {
#line 395
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\rWARNING: The CDROM drive appears to be seeking impossibly quickly.\nThis could be due to timer bugs, a drive that really is improbably fast,\nor, most likely, a bug in cdparanoia\'s cache modelling.\n\nPlease consider using the -A option to perform an analysis run, then mail\nthe cdparanoia.log file produced by the analysis to paranoia-dev@xiph.org\nto assist developers in correcting the problem.\n\n");
      }
    }
#line 403
    cacheerr ++;
  }
#line 407
  if (! quiet) {
#line 409
    osector = inpos;
#line 410
    sector = inpos / 1176L;
#line 412
    if (printit == -1) {
      {
#line 413
      tmp___0 = isatty(2);
      }
#line 413
      if (tmp___0) {
#line 414
        printit = 1;
      } else {
#line 416
        printit = 0;
      }
    }
#line 420
    if (printit == 1) {
#line 422
      position = (int )(((float )(sector - callbegin) / (float )(callend - callbegin)) * (float )graph);
#line 425
      aheadposition = (int )(((float )(c_sector - callbegin) / (float )(callend - callbegin)) * (float )graph);
#line 428
      if (function == -2) {
#line 429
        v_sector = sector;
#line 430
        return;
      }
#line 432
      if (function == -1) {
#line 433
        last = 8;
#line 434
        heartbeat = (char )'*';
#line 435
        slevel = 0;
#line 436
        v_sector = sector;
      } else
#line 438
      if (position < graph) {
#line 438
        if (position >= 0) {
          {
#line 440
          if (function == 1) {
#line 440
            goto case_1;
          }
#line 448
          if (function == 0) {
#line 448
            goto case_0;
          }
#line 452
          if (function == 2) {
#line 452
            goto case_2;
          }
#line 462
          if (function == 3) {
#line 462
            goto case_3;
          }
#line 468
          if (function == 12) {
#line 468
            goto case_12;
          }
#line 473
          if (function == 13) {
#line 473
            goto case_13;
          }
#line 477
          if (function == 6) {
#line 477
            goto case_6;
          }
#line 482
          if (function == 9) {
#line 482
            goto case_9;
          }
#line 485
          if (function == 4) {
#line 485
            goto case_4;
          }
#line 488
          if (function == 7) {
#line 488
            goto case_7;
          }
#line 492
          if (function == 11) {
#line 492
            goto case_11;
          }
#line 492
          if (function == 10) {
#line 492
            goto case_11;
          }
#line 439
          goto switch_break;
          case_1: /* CIL Label */ 
#line 441
          if (stimeout >= 30) {
#line 442
            if (overlap > 1176) {
#line 443
              slevel = 2;
            } else {
#line 445
              slevel = 1;
            }
          }
#line 447
          goto switch_break;
          case_0: /* CIL Label */ 
#line 449
          if (sector > c_sector) {
#line 449
            c_sector = sector;
          }
#line 450
          goto switch_break;
          case_2: /* CIL Label */ 
#line 453
          if (stimeout >= 5) {
#line 454
            if (overlap > 1176) {
#line 455
              slevel = 2;
            } else {
#line 457
              slevel = 1;
            }
          }
#line 459
          if ((int )dispcache[position] == 32) {
#line 460
            dispcache[position] = (char )'-';
          }
#line 461
          goto switch_break;
          case_3: /* CIL Label */ 
#line 463
          if (slevel < 3) {
#line 463
            slevel = 3;
          } else
#line 463
          if (stimeout > 5) {
#line 463
            slevel = 3;
          }
#line 464
          if ((int )dispcache[position] == 32) {
#line 466
            dispcache[position] = (char )'+';
          } else
#line 464
          if ((int )dispcache[position] == 45) {
#line 466
            dispcache[position] = (char )'+';
          }
#line 467
          goto switch_break;
          case_12: /* CIL Label */ 
#line 469
          slevel = 6;
#line 470
          if ((int )dispcache[position] != 86) {
#line 470
            if ((int )dispcache[position] != 67) {
#line 471
              dispcache[position] = (char )'e';
            }
          }
#line 472
          goto switch_break;
          case_13: /* CIL Label */ 
#line 474
          slevel = 8;
#line 475
          dispcache[position] = (char )'C';
#line 476
          goto switch_break;
          case_6: /* CIL Label */ 
#line 478
          slevel = 8;
#line 479
          if ((int )dispcache[position] != 67) {
#line 480
            dispcache[position] = (char )'V';
          }
#line 481
          goto switch_break;
          case_9: /* CIL Label */ 
#line 483
          overlap = (int )osector;
#line 484
          goto switch_break;
          case_4: /* CIL Label */ 
#line 486
          slevel = 7;
#line 487
          goto switch_break;
          case_7: /* CIL Label */ 
#line 489
          if (slevel < 4) {
#line 489
            slevel = 4;
          } else
#line 489
          if (stimeout > 5) {
#line 489
            slevel = 4;
          }
#line 490
          goto switch_break;
          case_11: /* CIL Label */ 
          case_10: /* CIL Label */ 
#line 493
          slevel = 5;
#line 494
          if ((int )dispcache[position] == 32) {
#line 497
            dispcache[position] = (char )'!';
          } else
#line 494
          if ((int )dispcache[position] == 45) {
#line 497
            dispcache[position] = (char )'!';
          } else
#line 494
          if ((int )dispcache[position] == 43) {
#line 497
            dispcache[position] = (char )'!';
          }
#line 498
          goto switch_break;
          switch_break: /* CIL Label */ ;
          }
        }
      }
      {
#line 502
      if (slevel == 0) {
#line 502
        goto case_0___0;
      }
#line 508
      if (slevel == 1) {
#line 508
        goto case_1___0;
      }
#line 511
      if (slevel == 2) {
#line 511
        goto case_2___0;
      }
#line 514
      if (slevel == 4) {
#line 514
        goto case_4___0;
      }
#line 517
      if (slevel == 3) {
#line 517
        goto case_3___0;
      }
#line 520
      if (slevel == 5) {
#line 520
        goto case_5;
      }
#line 523
      if (slevel == 6) {
#line 523
        goto case_6___0;
      }
#line 526
      if (slevel == 7) {
#line 526
        goto case_7___0;
      }
#line 529
      if (slevel == 8) {
#line 529
        goto case_8;
      }
#line 501
      goto switch_break___0;
      case_0___0: /* CIL Label */ 
#line 503
      if (skipped_flag) {
#line 504
        smilie = (char *)" 8-X";
      } else {
#line 506
        smilie = (char *)" :^D";
      }
#line 507
      goto switch_break___0;
      case_1___0: /* CIL Label */ 
#line 509
      smilie = (char *)" :-)";
#line 510
      goto switch_break___0;
      case_2___0: /* CIL Label */ 
#line 512
      smilie = (char *)" :-|";
#line 513
      goto switch_break___0;
      case_4___0: /* CIL Label */ 
#line 515
      smilie = (char *)" :-/";
#line 516
      goto switch_break___0;
      case_3___0: /* CIL Label */ 
#line 518
      smilie = (char *)" :-P";
#line 519
      goto switch_break___0;
      case_5: /* CIL Label */ 
#line 521
      smilie = (char *)" 8-|";
#line 522
      goto switch_break___0;
      case_6___0: /* CIL Label */ 
#line 524
      smilie = (char *)" :-0";
#line 525
      goto switch_break___0;
      case_7___0: /* CIL Label */ 
#line 527
      smilie = (char *)" :-(";
#line 528
      goto switch_break___0;
      case_8: /* CIL Label */ 
#line 530
      smilie = (char *)" ;-(";
#line 531
      skipped_flag = 1;
#line 532
      goto switch_break___0;
      switch_break___0: /* CIL Label */ ;
      }
      {
#line 536
      gettimeofday((struct timeval */* __restrict  */)(& thistime), (__timezone_ptr_t )((void *)0));
#line 537
      test = thistime.tv_sec * 10L + thistime.tv_usec / 100000L;
      }
#line 539
      if (lasttime != test) {
#line 539
        goto _L___2;
      } else
#line 539
      if (function == -1) {
#line 539
        goto _L___2;
      } else
#line 539
      if (slast != slevel) {
        _L___2: /* CIL Label */ 
#line 540
        if (lasttime != test) {
#line 540
          goto _L;
        } else
#line 540
        if (function == -1) {
          _L: /* CIL Label */ 
#line 541
          last ++;
#line 542
          lasttime = test;
#line 543
          if (last > 7) {
#line 543
            last = 0;
          }
#line 544
          stimeout ++;
          {
#line 546
          if (last == 0) {
#line 546
            goto case_0___1;
          }
#line 549
          if (last == 7) {
#line 549
            goto case_7___1;
          }
#line 549
          if (last == 1) {
#line 549
            goto case_7___1;
          }
#line 552
          if (last == 6) {
#line 552
            goto case_6___1;
          }
#line 552
          if (last == 2) {
#line 552
            goto case_6___1;
          }
#line 555
          if (last == 5) {
#line 555
            goto case_5___0;
          }
#line 555
          if (last == 3) {
#line 555
            goto case_5___0;
          }
#line 558
          if (last == 4) {
#line 558
            goto case_4___1;
          }
#line 545
          goto switch_break___1;
          case_0___1: /* CIL Label */ 
#line 547
          heartbeat = (char )' ';
#line 548
          goto switch_break___1;
          case_7___1: /* CIL Label */ 
          case_1___1: /* CIL Label */ 
#line 550
          heartbeat = (char )'.';
#line 551
          goto switch_break___1;
          case_6___1: /* CIL Label */ 
          case_2___1: /* CIL Label */ 
#line 553
          heartbeat = (char )'o';
#line 554
          goto switch_break___1;
          case_5___0: /* CIL Label */ 
          case_3___1: /* CIL Label */ 
#line 556
          heartbeat = (char )'0';
#line 557
          goto switch_break___1;
          case_4___1: /* CIL Label */ 
#line 559
          heartbeat = (char )'O';
#line 560
          goto switch_break___1;
          switch_break___1: /* CIL Label */ ;
          }
#line 562
          if (function == -1) {
#line 563
            heartbeat = (char )'*';
          }
        }
#line 566
        if (slast != slevel) {
#line 567
          stimeout = 0;
        }
#line 569
        slast = slevel;
#line 571
        if (abort_on_skip) {
#line 571
          if (skipped_flag) {
#line 571
            if (function != -1) {
              {
#line 572
              sprintf((char */* __restrict  */)(buffer), (char const   */* __restrict  */)"\r (== PROGRESS == [%s| %06ld %02d ] ==%s %c ==)   ",
                      "  ...aborting; please wait... ", v_sector, overlap / 1176,
                      smilie, (int )heartbeat);
              }
            } else {
#line 571
              goto _L___1;
            }
          } else {
#line 571
            goto _L___1;
          }
        } else {
          _L___1: /* CIL Label */ 
#line 577
          if (v_sector == 0L) {
            {
#line 578
            sprintf((char */* __restrict  */)(buffer), (char const   */* __restrict  */)"\r (== PROGRESS == [%s| ...... %02d ] ==%s %c ==)   ",
                    dispcache, overlap / 1176, smilie, (int )heartbeat);
            }
          } else {
            {
#line 583
            sprintf((char */* __restrict  */)(buffer), (char const   */* __restrict  */)"\r (== PROGRESS == [%s| %06ld %02d ] ==%s %c ==)   ",
                    dispcache, v_sector, overlap / 1176, smilie, (int )heartbeat);
            }
          }
#line 587
          if (aheadposition >= 0) {
#line 587
            if (aheadposition < graph) {
#line 587
              if (! (function == -1)) {
#line 588
                buffer[aheadposition + 19] = (char )'>';
              }
            }
          }
        }
        {
#line 591
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)(buffer));
        }
#line 593
        if ((unsigned long )logfile != (unsigned long )((void *)0)) {
#line 593
          if (function == -1) {
            {
#line 594
            fprintf((FILE */* __restrict  */)logfile, (char const   */* __restrict  */)(buffer + 1));
#line 595
            fprintf((FILE */* __restrict  */)logfile, (char const   */* __restrict  */)"\n\n");
#line 596
            fflush(logfile);
            }
          }
        }
      }
    }
  }
#line 603
  if (function == -1) {
    {
#line 604
    memset((void *)(dispcache), ' ', (size_t )graph);
    }
  }
#line 605
  return;
}
}
#line 607 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/main.c"
char const   *optstring  =    "escCn:o:O:d:g:k:S:prRwafvqVQhZz::YXWBi:Tt:l::L::A";
#line 609 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/main.c"
struct option options[35]  = 
#line 609
  {      {"stderr-progress", 0, (int *)((void *)0), 'e'}, 
        {"search-for-drive", 0, (int *)((void *)0), 's'}, 
        {"force-cdrom-little-endian", 0, (int *)((void *)0), 'c'}, 
        {"force-cdrom-big-endian", 0, (int *)((void *)0), 'C'}, 
        {"force-default-sectors", 1, (int *)((void *)0), 'n'}, 
        {"force-search-overlap", 1, (int *)((void *)0), 'o'}, 
        {"force-cdrom-device", 1, (int *)((void *)0), 'd'}, 
        {"force-cooked-device", 1, (int *)((void *)0), 'k'}, 
        {"force-generic-device", 1, (int *)((void *)0), 'g'}, 
        {"force-read-speed", 1, (int *)((void *)0), 'S'}, 
        {"sample-offset", 1, (int *)((void *)0), 'O'}, 
        {"toc-offset", 1, (int *)((void *)0), 't'}, 
        {"toc-bias", 0, (int *)((void *)0), 'T'}, 
        {"output-raw", 0, (int *)((void *)0), 'p'}, 
        {"output-raw-little-endian", 0, (int *)((void *)0), 'r'}, 
        {"output-raw-big-endian", 0, (int *)((void *)0), 'R'}, 
        {"output-wav", 0, (int *)((void *)0), 'w'}, 
        {"output-aiff", 0, (int *)((void *)0), 'f'}, 
        {"output-aifc", 0, (int *)((void *)0), 'a'}, 
        {"batch", 0, (int *)((void *)0), 'B'}, 
        {"verbose", 0, (int *)((void *)0), 'v'}, 
        {"quiet", 0, (int *)((void *)0), 'q'}, 
        {"version", 0, (int *)((void *)0), 'V'}, 
        {"query", 0, (int *)((void *)0), 'Q'}, 
        {"help", 0, (int *)((void *)0), 'h'}, 
        {"analyze-drive", 0, (int *)((void *)0), 'A'}, 
        {"disable-paranoia", 0, (int *)((void *)0), 'Z'}, 
        {"disable-extra-paranoia", 0, (int *)((void *)0), 'Y'}, 
        {"abort-on-skip", 0, (int *)((void *)0), 'X'}, 
        {"disable-fragmentation", 0, (int *)((void *)0), 'F'}, 
        {"output-info", 1, (int *)((void *)0), 'i'}, 
        {"never-skip", 2, (int *)((void *)0), 'z'}, 
        {"log-summary", 2, (int *)((void *)0), 'l'}, 
        {"log-debug", 2, (int *)((void *)0), 'L'}, 
        {(char const   *)((void *)0), 0, (int *)((void *)0), 0}};
#line 648 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/main.c"
long blocking_write(int outf , char *buffer , long num ) 
{ 
  long words ;
  long temp ;
  ssize_t tmp ;
  int *tmp___0 ;
  int *tmp___1 ;

  {
#line 649
  words = 0L;
  {
#line 651
  while (1) {
    while_continue: /* CIL Label */ ;
#line 651
    if (! (words < num)) {
#line 651
      goto while_break;
    }
    {
#line 652
    tmp = write(outf, (void const   *)(buffer + words), (size_t )(num - words));
#line 652
    temp = (long )tmp;
    }
#line 653
    if (temp == -1L) {
      {
#line 654
      tmp___0 = __errno_location();
      }
#line 654
      if (*tmp___0 != 4) {
        {
#line 654
        tmp___1 = __errno_location();
        }
#line 654
        if (*tmp___1 != 11) {
#line 655
          return (-1L);
        }
      }
#line 656
      temp = 0L;
    }
#line 658
    words += temp;
  }
  while_break: /* CIL Label */ ;
  }
#line 660
  return (0L);
}
}
#line 663 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/main.c"
static cdrom_drive *d  =    (cdrom_drive *)((void *)0);
#line 664 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/main.c"
static cdrom_paranoia___0 *p  =    (void *)0;
#line 666 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/main.c"
static void cleanup(void) 
{ 


  {
#line 667
  if (p) {
    {
#line 667
    paranoia_free(p);
    }
  }
#line 668
  if (d) {
    {
#line 668
    cdda_close(d);
    }
  }
#line 669
  return;
}
}
#line 671 "/home/wslee/benchmarks/sound/cdparanoia-3.10.2+debian/main.c"
int main(int argc , char **argv ) 
{ 
  int toc_bias ;
  int toc_offset ;
  int sample_offset ;
  int force_cdrom_endian ;
  int force_cdrom_sectors ;
  int force_cdrom_overlap ;
  char *force_cdrom_device ;
  char *force_generic_device ;
  char *force_cooked_device ;
  int force_cdrom_speed ;
  int max_retries ;
  char *span ;
  int output_type ;
  int output_endian ;
  int query_only ;
  int batch ;
  int i ;
  int run_cache_test ;
  char *logfile_name ;
  char *reportfile_name ;
  int logfile_open ;
  int reportfile_open ;
  int paranoia_mode ;
  char *info_file ;
  int out ;
  int search ;
  int c ;
  int long_option_index ;
  int *tmp ;
  char *tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  int *tmp___4 ;
  char *tmp___5 ;
  int *tmp___6 ;
  char *tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int i___0 ;
  char *tmp___10 ;
  char *tmp___11 ;
  int i___1 ;
  char *tmp___12 ;
  char *tmp___13 ;
  char *tmp___14 ;
  char *tmp___15 ;
  struct stat s ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int warn ;
  int tmp___19 ;
  long tmp___20 ;
  long first_sector ;
  long last_sector ;
  long batch_first ;
  long batch_last ;
  int batch_track ;
  char *span2 ;
  char *tmp___21 ;
  char *tmp___22 ;
  long tmp___23 ;
  int tmp___24 ;
  int track1 ;
  int tmp___25 ;
  int track2 ;
  int tmp___26 ;
  long off1 ;
  long tmp___27 ;
  long off2 ;
  long tmp___28 ;
  int i___2 ;
  int tmp___29 ;
  long cursor ;
  int16_t offset_buffer[1176] ;
  int offset_buffer_used ;
  int offset_skip ;
  __uid_t tmp___30 ;
  __gid_t tmp___31 ;
  char outfile_name[256] ;
  int tmp___32 ;
  char path[256] ;
  char *post ;
  char *tmp___33 ;
  int pos ;
  long tmp___34 ;
  char *file ;
  int tmp___35 ;
  int *tmp___36 ;
  char *tmp___37 ;
  int *tmp___38 ;
  char *tmp___39 ;
  int tmp___40 ;
  int *tmp___41 ;
  char *tmp___42 ;
  int *tmp___43 ;
  char *tmp___44 ;
  int *tmp___45 ;
  char *tmp___46 ;
  int *tmp___47 ;
  char *tmp___48 ;
  long tmp___49 ;
  int16_t *readbuf ;
  int16_t *tmp___50 ;
  char *err ;
  char *tmp___51 ;
  char *mes ;
  char *tmp___52 ;
  char const   *tmp___53 ;
  char const   *tmp___54 ;
  int *tmp___55 ;
  int *tmp___56 ;
  int i___3 ;
  int tmp___57 ;
  int *tmp___58 ;
  char *tmp___59 ;
  int *tmp___60 ;
  char *tmp___61 ;
  long tmp___62 ;
  int i___4 ;
  int tmp___63 ;
  int i___5 ;
  char const   *tmp___64 ;
  char const   *tmp___65 ;
  int tmp___66 ;
  int *tmp___67 ;
  char *tmp___68 ;
  int *tmp___69 ;
  char *tmp___70 ;
  long tmp___71 ;
  void *__cil_tmp134 ;
  void *__cil_tmp135 ;
  void *__cil_tmp136 ;
  char *__cil_tmp137 ;
  char *__cil_tmp138 ;
  char *__cil_tmp139 ;
  char *__cil_tmp140 ;
  char *__cil_tmp141 ;
  char *__cil_tmp142 ;
  char *__cil_tmp143 ;
  char *__cil_tmp144 ;
  char *__cil_tmp145 ;
  char *__cil_tmp146 ;
  char *__cil_tmp147 ;
  char *__cil_tmp148 ;
  char *__cil_tmp149 ;
  char *__cil_tmp150 ;
  char *__cil_tmp151 ;
  char *__cil_tmp152 ;
  char *__cil_tmp153 ;
  char *__cil_tmp154 ;
  char *__cil_tmp155 ;
  char *__cil_tmp156 ;
  char *__cil_tmp157 ;
  char *__cil_tmp158 ;
  char *__cil_tmp159 ;
  char *__cil_tmp160 ;
  char *__cil_tmp161 ;
  char *__cil_tmp162 ;
  char *__cil_tmp163 ;
  char *__cil_tmp164 ;
  char *__cil_tmp165 ;
  char *__cil_tmp166 ;
  char *__cil_tmp167 ;
  char *__cil_tmp168 ;
  char *__cil_tmp169 ;
  char *__cil_tmp170 ;
  char *__cil_tmp171 ;
  char *__cil_tmp172 ;
  char *__cil_tmp173 ;
  char *__cil_tmp174 ;
  char *__cil_tmp175 ;
  char *__cil_tmp176 ;
  char *__cil_tmp177 ;
  char *__cil_tmp178 ;
  char *__cil_tmp179 ;
  char *__cil_tmp180 ;
  char *__cil_tmp181 ;
  char *__cil_tmp182 ;
  char *__cil_tmp183 ;
  char *__cil_tmp184 ;
  char *__cil_tmp185 ;
  char *__cil_tmp186 ;
  char *__cil_tmp187 ;
  char *__cil_tmp188 ;
  char *__cil_tmp189 ;
  char *__cil_tmp190 ;
  char *__cil_tmp191 ;
  char *__cil_tmp192 ;
  char *__cil_tmp193 ;
  char *__cil_tmp194 ;
  char *__cil_tmp195 ;
  char *__cil_tmp196 ;
  char *__cil_tmp197 ;
  char *__cil_tmp198 ;
  char *__cil_tmp199 ;
  char *__cil_tmp200 ;
  char *__cil_tmp201 ;
  char *__cil_tmp202 ;
  char *__cil_tmp203 ;
  char *__cil_tmp204 ;
  char *__cil_tmp205 ;
  char *__cil_tmp206 ;
  char *__cil_tmp207 ;
  char *__cil_tmp208 ;
  char *__cil_tmp209 ;
  char *__cil_tmp210 ;
  char *__cil_tmp211 ;
  char *__cil_tmp212 ;
  char *__cil_tmp213 ;
  char *__cil_tmp214 ;
  char *__cil_tmp215 ;
  char *__cil_tmp216 ;
  char *__cil_tmp217 ;
  char *__cil_tmp218 ;
  char *__cil_tmp219 ;
  char *__cil_tmp220 ;
  char *__cil_tmp221 ;
  char *__cil_tmp222 ;
  char *__cil_tmp223 ;
  char *__cil_tmp224 ;
  char *__cil_tmp225 ;
  char *__cil_tmp226 ;
  char *__cil_tmp227 ;
  char *__cil_tmp228 ;
  char *__cil_tmp229 ;
  char *__cil_tmp230 ;
  char *__cil_tmp231 ;
  char *__cil_tmp232 ;
  char *__cil_tmp233 ;
  char *__cil_tmp234 ;
  char *__cil_tmp235 ;
  char *__cil_tmp236 ;
  char *__cil_tmp237 ;
  char *__cil_tmp238 ;
  char *__cil_tmp239 ;
  char *__cil_tmp240 ;
  char *__cil_tmp241 ;
  char *__cil_tmp242 ;
  char *__cil_tmp243 ;
  char *__cil_tmp244 ;
  char *__cil_tmp245 ;
  char *__cil_tmp246 ;
  char *__cil_tmp247 ;
  char *__cil_tmp248 ;
  char *__cil_tmp249 ;
  char *__cil_tmp250 ;
  char *__cil_tmp251 ;
  char *__cil_tmp252 ;
  char *__cil_tmp253 ;
  char *__cil_tmp254 ;
  char *__cil_tmp255 ;
  char *__cil_tmp256 ;
  char *__cil_tmp257 ;
  char *__cil_tmp258 ;
  char *__cil_tmp259 ;
  char *__cil_tmp260 ;
  char *__cil_tmp261 ;
  char *__cil_tmp262 ;
  char *__cil_tmp263 ;
  char *__cil_tmp264 ;
  char *__cil_tmp265 ;
  char *__cil_tmp266 ;
  char *__cil_tmp267 ;
  char *__cil_tmp268 ;
  char *__cil_tmp269 ;

  {
  {
#line 672
  toc_bias = 0;
#line 673
  toc_offset = 0;
#line 674
  sample_offset = 0;
#line 675
  force_cdrom_endian = -1;
#line 676
  force_cdrom_sectors = -1;
#line 677
  force_cdrom_overlap = -1;
#line 678
  force_cdrom_device = (char *)((void *)0);
#line 679
  force_generic_device = (char *)((void *)0);
#line 680
  force_cooked_device = (char *)((void *)0);
#line 681
  force_cdrom_speed = 0;
#line 682
  max_retries = 20;
#line 683
  span = (char *)((void *)0);
#line 684
  output_type = 1;
#line 685
  output_endian = 0;
#line 686
  query_only = 0;
#line 687
  batch = 0;
#line 688
  run_cache_test = 0;
#line 690
  logfile_name = (char *)((void *)0);
#line 691
  reportfile_name = (char *)((void *)0);
#line 692
  logfile_open = 0;
#line 693
  reportfile_open = 0;
#line 696
  paranoia_mode = 223;
#line 698
  info_file = (char *)((void *)0);
#line 701
  search = 0;
#line 704
  atexit(& cleanup);
  }
  {
#line 706
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 706
    c = getopt_long(argc, (char * const  *)argv, optstring, (struct option  const  *)(options),
                    & long_option_index);
    }
#line 706
    if (! (c != -1)) {
#line 706
      goto while_break;
    }
    {
#line 708
    if (c == 66) {
#line 708
      goto case_66;
    }
#line 711
    if (c == 99) {
#line 711
      goto case_99;
    }
#line 714
    if (c == 67) {
#line 714
      goto case_67;
    }
#line 717
    if (c == 110) {
#line 717
      goto case_110;
    }
#line 720
    if (c == 111) {
#line 720
      goto case_111;
    }
#line 723
    if (c == 100) {
#line 723
      goto case_100;
    }
#line 727
    if (c == 103) {
#line 727
      goto case_103;
    }
#line 736
    if (c == 107) {
#line 736
      goto case_107;
    }
#line 744
    if (c == 83) {
#line 744
      goto case_83;
    }
#line 747
    if (c == 112) {
#line 747
      goto case_112;
    }
#line 751
    if (c == 114) {
#line 751
      goto case_114;
    }
#line 755
    if (c == 82) {
#line 755
      goto case_82;
    }
#line 759
    if (c == 119) {
#line 759
      goto case_119;
    }
#line 763
    if (c == 97) {
#line 763
      goto case_97;
    }
#line 767
    if (c == 102) {
#line 767
      goto case_102;
    }
#line 771
    if (c == 118) {
#line 771
      goto case_118;
    }
#line 775
    if (c == 115) {
#line 775
      goto case_115;
    }
#line 778
    if (c == 113) {
#line 778
      goto case_113;
    }
#line 782
    if (c == 101) {
#line 782
      goto case_101;
    }
#line 786
    if (c == 86) {
#line 786
      goto case_86;
    }
#line 791
    if (c == 81) {
#line 791
      goto case_81;
    }
#line 794
    if (c == 104) {
#line 794
      goto case_104;
    }
#line 797
    if (c == 90) {
#line 797
      goto case_90;
    }
#line 800
    if (c == 65) {
#line 800
      goto case_65;
    }
#line 806
    if (c == 122) {
#line 806
      goto case_122;
    }
#line 814
    if (c == 89) {
#line 814
      goto case_89;
    }
#line 819
    if (c == 88) {
#line 819
      goto case_88;
    }
#line 823
    if (c == 87) {
#line 823
      goto case_87;
    }
#line 826
    if (c == 70) {
#line 826
      goto case_70;
    }
#line 829
    if (c == 105) {
#line 829
      goto case_105;
    }
#line 833
    if (c == 84) {
#line 833
      goto case_84;
    }
#line 836
    if (c == 116) {
#line 836
      goto case_116;
    }
#line 839
    if (c == 108) {
#line 839
      goto case_108;
    }
#line 846
    if (c == 76) {
#line 846
      goto case_76;
    }
#line 853
    if (c == 79) {
#line 853
      goto case_79;
    }
#line 856
    goto switch_default;
    case_66: /* CIL Label */ 
#line 709
    batch = 1;
#line 710
    goto switch_break;
    case_99: /* CIL Label */ 
#line 712
    force_cdrom_endian = 0;
#line 713
    goto switch_break;
    case_67: /* CIL Label */ 
#line 715
    force_cdrom_endian = 1;
#line 716
    goto switch_break;
    case_110: /* CIL Label */ 
    {
#line 718
    force_cdrom_sectors = atoi((char const   *)optarg);
    }
#line 719
    goto switch_break;
    case_111: /* CIL Label */ 
    {
#line 721
    force_cdrom_overlap = atoi((char const   *)optarg);
    }
#line 722
    goto switch_break;
    case_100: /* CIL Label */ 
#line 724
    if (force_cdrom_device) {
      {
#line 724
      free((void *)force_cdrom_device);
      }
    }
    {
#line 725
    force_cdrom_device = copystring___3((char const   *)optarg);
    }
#line 726
    goto switch_break;
    case_103: /* CIL Label */ 
#line 728
    if (force_cooked_device) {
#line 729
      if (! quiet) {
        {
#line 729
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"-g option incompatable with -k\n");
#line 729
        fputc('\n', stderr);
        }
      }
#line 729
      if (reportfile) {
        {
#line 729
        fprintf((FILE */* __restrict  */)reportfile, (char const   */* __restrict  */)"-g option incompatable with -k\n");
#line 729
        fputc('\n', reportfile);
        }
      }
      {
#line 730
      exit(1);
      }
    }
#line 732
    force_cooked_device = (char *)((void *)0);
#line 733
    if (force_generic_device) {
      {
#line 733
      free((void *)force_generic_device);
      }
    }
    {
#line 734
    force_generic_device = copystring___3((char const   *)optarg);
    }
#line 735
    goto switch_break;
    case_107: /* CIL Label */ 
#line 737
    if (force_generic_device) {
#line 737
      goto _L;
    } else
#line 737
    if (force_cdrom_device) {
      _L: /* CIL Label */ 
#line 738
      if (! quiet) {
        {
#line 738
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"-k option incompatable with -d and -g\n");
#line 738
        fputc('\n', stderr);
        }
      }
#line 738
      if (reportfile) {
        {
#line 738
        fprintf((FILE */* __restrict  */)reportfile, (char const   */* __restrict  */)"-k option incompatable with -d and -g\n");
#line 738
        fputc('\n', reportfile);
        }
      }
      {
#line 739
      exit(1);
      }
    }
#line 741
    if (force_cooked_device) {
      {
#line 741
      free((void *)force_cooked_device);
      }
    }
    {
#line 742
    force_cooked_device = copystring___3((char const   *)optarg);
    }
#line 743
    goto switch_break;
    case_83: /* CIL Label */ 
    {
#line 745
    force_cdrom_speed = atoi((char const   *)optarg);
    }
#line 746
    goto switch_break;
    case_112: /* CIL Label */ 
#line 748
    output_type = 0;
#line 749
    output_endian = -1;
#line 750
    goto switch_break;
    case_114: /* CIL Label */ 
#line 752
    output_type = 0;
#line 753
    output_endian = 0;
#line 754
    goto switch_break;
    case_82: /* CIL Label */ 
#line 756
    output_type = 0;
#line 757
    output_endian = 1;
#line 758
    goto switch_break;
    case_119: /* CIL Label */ 
#line 760
    output_type = 1;
#line 761
    output_endian = 0;
#line 762
    goto switch_break;
    case_97: /* CIL Label */ 
#line 764
    output_type = 2;
#line 765
    output_endian = 1;
#line 766
    goto switch_break;
    case_102: /* CIL Label */ 
#line 768
    output_type = 3;
#line 769
    output_endian = 1;
#line 770
    goto switch_break;
    case_118: /* CIL Label */ 
#line 772
    verbose = 1;
#line 773
    quiet = 0;
#line 774
    goto switch_break;
    case_115: /* CIL Label */ 
#line 776
    search = 1;
#line 777
    goto switch_break;
    case_113: /* CIL Label */ 
#line 779
    verbose = 0;
#line 780
    quiet = 1;
#line 781
    goto switch_break;
    case_101: /* CIL Label */ 
    {
#line 783
    callscript = 1L;
#line 784
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Sending all callbacks to stderr for wrapper script\n");
    }
#line 785
    goto switch_break;
    case_86: /* CIL Label */ 
    {
#line 787
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"cdparanoia III release 10.2 (September 11, 2008)\n");
#line 788
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
#line 789
    exit(0);
    }
#line 790
    goto switch_break;
    case_81: /* CIL Label */ 
#line 792
    query_only = 1;
#line 793
    goto switch_break;
    case_104: /* CIL Label */ 
    {
#line 795
    usage(stdout);
#line 796
    exit(0);
    }
    case_90: /* CIL Label */ 
#line 798
    paranoia_mode = 0;
#line 799
    goto switch_break;
    case_65: /* CIL Label */ 
#line 801
    run_cache_test = 1;
#line 802
    query_only = 1;
#line 803
    reportfile_open = 1;
#line 804
    verbose = 1;
#line 805
    goto switch_break;
    case_122: /* CIL Label */ 
#line 807
    if (optarg) {
      {
#line 808
      max_retries = atoi((char const   *)optarg);
#line 809
      paranoia_mode &= -33;
      }
    } else {
#line 811
      paranoia_mode |= 32;
    }
#line 813
    goto switch_break;
    case_89: /* CIL Label */ 
#line 815
    paranoia_mode |= 4;
#line 817
    paranoia_mode &= -2;
#line 818
    goto switch_break;
    case_88: /* CIL Label */ 
#line 821
    abort_on_skip = 1;
#line 822
    goto switch_break;
    case_87: /* CIL Label */ 
#line 824
    paranoia_mode &= -17;
#line 825
    goto switch_break;
    case_70: /* CIL Label */ 
#line 827
    paranoia_mode &= -3;
#line 828
    goto switch_break;
    case_105: /* CIL Label */ 
#line 830
    if (info_file) {
      {
#line 830
      free((void *)info_file);
      }
    }
    {
#line 831
    info_file = copystring___3((char const   *)info_file);
    }
#line 832
    goto switch_break;
    case_84: /* CIL Label */ 
#line 834
    toc_bias = -1;
#line 835
    goto switch_break;
    case_116: /* CIL Label */ 
    {
#line 837
    toc_offset = atoi((char const   *)optarg);
    }
#line 838
    goto switch_break;
    case_108: /* CIL Label */ 
#line 840
    if (logfile_name) {
      {
#line 840
      free((void *)logfile_name);
      }
    }
#line 841
    logfile_name = (char *)((void *)0);
#line 842
    if (optarg) {
      {
#line 843
      logfile_name = strdup((char const   *)optarg);
      }
    }
#line 844
    logfile_open = 1;
#line 845
    goto switch_break;
    case_76: /* CIL Label */ 
#line 847
    if (reportfile_name) {
      {
#line 847
      free((void *)reportfile_name);
      }
    }
#line 848
    reportfile_name = (char *)((void *)0);
#line 849
    if (optarg) {
      {
#line 850
      reportfile_name = strdup((char const   *)optarg);
      }
    }
#line 851
    reportfile_open = 1;
#line 852
    goto switch_break;
    case_79: /* CIL Label */ 
    {
#line 854
    sample_offset = atoi((char const   *)optarg);
    }
#line 855
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 857
    usage(stderr);
#line 858
    exit(1);
    }
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 862
  if (logfile_open) {
#line 863
    if ((unsigned long )logfile_name == (unsigned long )((void *)0)) {
      {
#line 864
      logfile_name = strdup("cdparanoia.log");
      }
    }
    {
#line 865
    tmp___3 = strcmp((char const   *)logfile_name, "-");
    }
#line 865
    if (tmp___3) {
      {
#line 869
      logfile = fopen((char const   */* __restrict  */)logfile_name, (char const   */* __restrict  */)"w");
      }
#line 870
      if ((unsigned long )logfile == (unsigned long )((void *)0)) {
#line 871
        if (! quiet) {
          {
#line 871
          tmp = __errno_location();
#line 871
          tmp___0 = strerror(*tmp);
#line 871
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Cannot open log summary file %s: %s",
                  logfile_name, tmp___0);
#line 871
          fputc('\n', stderr);
          }
        }
#line 871
        if (reportfile) {
          {
#line 871
          tmp___1 = __errno_location();
#line 871
          tmp___2 = strerror(*tmp___1);
#line 871
          fprintf((FILE */* __restrict  */)reportfile, (char const   */* __restrict  */)"Cannot open log summary file %s: %s",
                  logfile_name, tmp___2);
#line 871
          fputc('\n', reportfile);
          }
        }
        {
#line 873
        exit(1);
        }
      }
    } else {
#line 866
      logfile = stdout;
#line 867
      logfile_open = 0;
    }
  }
#line 877
  if (reportfile_open) {
#line 878
    if ((unsigned long )reportfile_name == (unsigned long )((void *)0)) {
      {
#line 879
      reportfile_name = strdup("cdparanoia.log");
      }
    }
    {
#line 880
    tmp___9 = strcmp((char const   *)reportfile_name, "-");
    }
#line 880
    if (tmp___9) {
#line 884
      if (logfile_name) {
        {
#line 884
        tmp___8 = strcmp((char const   *)reportfile_name, (char const   *)logfile_name);
        }
#line 884
        if (tmp___8) {
#line 884
          goto _L___0;
        } else {
#line 885
          reportfile = logfile;
#line 886
          reportfile_open = 0;
        }
      } else {
        _L___0: /* CIL Label */ 
        {
#line 888
        reportfile = fopen((char const   */* __restrict  */)reportfile_name, (char const   */* __restrict  */)"w");
        }
#line 889
        if ((unsigned long )reportfile == (unsigned long )((void *)0)) {
#line 890
          if (! quiet) {
            {
#line 890
            tmp___4 = __errno_location();
#line 890
            tmp___5 = strerror(*tmp___4);
#line 890
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Cannot open debug log file %s: %s",
                    reportfile_name, tmp___5);
#line 890
            fputc('\n', stderr);
            }
          }
#line 890
          if (reportfile) {
            {
#line 890
            tmp___6 = __errno_location();
#line 890
            tmp___7 = strerror(*tmp___6);
#line 890
            fprintf((FILE */* __restrict  */)reportfile, (char const   */* __restrict  */)"Cannot open debug log file %s: %s",
                    reportfile_name, tmp___7);
#line 890
            fputc('\n', reportfile);
            }
          }
          {
#line 892
          exit(1);
          }
        }
      }
    } else {
#line 881
      reportfile = stdout;
#line 882
      reportfile_open = 0;
    }
  }
#line 898
  if (logfile) {
#line 901
    i___0 = 0;
    {
#line 901
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 901
      if (! (i___0 < argc)) {
#line 901
        goto while_break___0;
      }
      {
#line 902
      fprintf((FILE */* __restrict  */)logfile, (char const   */* __restrict  */)"%s ",
              *(argv + i___0));
#line 901
      i___0 ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 903
    fprintf((FILE */* __restrict  */)logfile, (char const   */* __restrict  */)"\n");
    }
#line 905
    if ((unsigned long )reportfile != (unsigned long )logfile) {
      {
#line 906
      fprintf((FILE */* __restrict  */)logfile, (char const   */* __restrict  */)"cdparanoia III release 10.2 (September 11, 2008)\n");
#line 907
      fprintf((FILE */* __restrict  */)logfile, (char const   */* __restrict  */)"\n");
#line 908
      tmp___10 = cdda_version();
#line 908
      fprintf((FILE */* __restrict  */)logfile, (char const   */* __restrict  */)"Using cdda library version: %s\n",
              tmp___10);
#line 909
      tmp___11 = paranoia_version();
#line 909
      fprintf((FILE */* __restrict  */)logfile, (char const   */* __restrict  */)"Using paranoia library version: %s\n",
              tmp___11);
      }
    }
    {
#line 911
    fflush(logfile);
    }
  }
#line 914
  if (reportfile) {
#line 914
    if ((unsigned long )reportfile != (unsigned long )logfile) {
#line 917
      i___1 = 0;
      {
#line 917
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 917
        if (! (i___1 < argc)) {
#line 917
          goto while_break___1;
        }
        {
#line 918
        fprintf((FILE */* __restrict  */)reportfile, (char const   */* __restrict  */)"%s ",
                *(argv + i___1));
#line 917
        i___1 ++;
        }
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 919
      fprintf((FILE */* __restrict  */)reportfile, (char const   */* __restrict  */)"\n");
#line 920
      fflush(reportfile);
      }
    }
  }
#line 923
  if (optind >= argc) {
#line 923
    if (! query_only) {
#line 924
      if (batch) {
#line 925
        span = (char *)((void *)0);
      } else {
        {
#line 928
        usage(stderr);
#line 929
        exit(1);
        }
      }
    } else {
      {
#line 932
      span = copystring___3((char const   *)*(argv + optind));
      }
    }
  } else {
    {
#line 932
    span = copystring___3((char const   *)*(argv + optind));
    }
  }
#line 934
  if (! quiet) {
    {
#line 934
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"cdparanoia III release 10.2 (September 11, 2008)\n");
#line 934
    fputc('\n', stderr);
    }
  }
#line 934
  if (reportfile) {
    {
#line 934
    fprintf((FILE */* __restrict  */)reportfile, (char const   */* __restrict  */)"cdparanoia III release 10.2 (September 11, 2008)\n");
#line 934
    fputc('\n', reportfile);
    }
  }
#line 935
  if (verbose) {
#line 936
    if (! quiet) {
      {
#line 936
      tmp___12 = cdda_version();
#line 936
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Using cdda library version: %s",
              tmp___12);
#line 936
      fputc('\n', stderr);
      }
    }
#line 936
    if (reportfile) {
      {
#line 936
      tmp___13 = cdda_version();
#line 936
      fprintf((FILE */* __restrict  */)reportfile, (char const   */* __restrict  */)"Using cdda library version: %s",
              tmp___13);
#line 936
      fputc('\n', reportfile);
      }
    }
#line 937
    if (! quiet) {
      {
#line 937
      tmp___14 = paranoia_version();
#line 937
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Using paranoia library version: %s",
              tmp___14);
#line 937
      fputc('\n', stderr);
      }
    }
#line 937
    if (reportfile) {
      {
#line 937
      tmp___15 = paranoia_version();
#line 937
      fprintf((FILE */* __restrict  */)reportfile, (char const   */* __restrict  */)"Using paranoia library version: %s",
              tmp___15);
#line 937
      fputc('\n', reportfile);
      }
    }
  }
#line 942
  if (force_cooked_device) {
    {
#line 943
    d = cdda_identify_cooked((char const   *)force_cooked_device, verbose, (char **)((void *)0));
    }
  } else
#line 944
  if (force_generic_device) {
    {
#line 945
    d = cdda_identify_scsi((char const   *)force_generic_device, (char const   *)force_cdrom_device,
                           verbose, (char **)((void *)0));
    }
  } else
#line 947
  if (force_cdrom_device) {
    {
#line 948
    d = cdda_identify((char const   *)force_cdrom_device, verbose, (char **)((void *)0));
    }
  } else
#line 950
  if (search) {
    {
#line 951
    d = cdda_find_a_cdrom(verbose, (char **)((void *)0));
    }
  } else {
    {
#line 955
    tmp___16 = lstat((char const   */* __restrict  */)"/dev/cdrom", (struct stat */* __restrict  */)(& s));
    }
#line 955
    if (tmp___16) {
      {
#line 957
      d = cdda_find_a_cdrom(verbose, (char **)((void *)0));
      }
    } else {
      {
#line 959
      d = cdda_identify("/dev/cdrom", verbose, (char **)((void *)0));
      }
#line 960
      if ((unsigned long )d == (unsigned long )((void *)0)) {
#line 960
        if (! verbose) {
#line 961
          verbose = 1;
#line 962
          if (! quiet) {
            {
#line 962
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n/dev/cdrom exists but isn\'t accessible.  By default,\ncdparanoia stops searching for an accessible drive here.\nConsider using -sv to force a more complete autosense\nof the machine.\n\nMore information about /dev/cdrom:");
#line 962
            fputc('\n', stderr);
            }
          }
#line 962
          if (reportfile) {
            {
#line 962
            fprintf((FILE */* __restrict  */)reportfile, (char const   */* __restrict  */)"\n/dev/cdrom exists but isn\'t accessible.  By default,\ncdparanoia stops searching for an accessible drive here.\nConsider using -sv to force a more complete autosense\nof the machine.\n\nMore information about /dev/cdrom:");
#line 962
            fputc('\n', reportfile);
            }
          }
          {
#line 967
          d = cdda_identify("/dev/cdrom", 1, (char **)((void *)0));
          }
#line 968
          if (! quiet) {
            {
#line 968
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
#line 968
            fputc('\n', stderr);
            }
          }
#line 968
          if (reportfile) {
            {
#line 968
            fprintf((FILE */* __restrict  */)reportfile, (char const   */* __restrict  */)"\n");
#line 968
            fputc('\n', reportfile);
            }
          }
          {
#line 969
          exit(1);
          }
        } else {
#line 960
          goto _L___1;
        }
      } else {
        _L___1: /* CIL Label */ 
#line 971
        if (! quiet) {
          {
#line 971
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" ");
#line 971
          fputc('\n', stderr);
          }
        }
#line 971
        if (reportfile) {
          {
#line 971
          fprintf((FILE */* __restrict  */)reportfile, (char const   */* __restrict  */)" ");
#line 971
          fputc('\n', reportfile);
          }
        }
      }
    }
  }
#line 975
  if (! d) {
#line 976
    if (! verbose) {
#line 977
      if (! quiet) {
        {
#line 977
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\nUnable to open cdrom drive; -v will give more information.");
#line 977
        fputc('\n', stderr);
        }
      }
#line 977
      if (reportfile) {
        {
#line 977
        fprintf((FILE */* __restrict  */)reportfile, (char const   */* __restrict  */)"\nUnable to open cdrom drive; -v will give more information.");
#line 977
        fputc('\n', reportfile);
        }
      }
    }
    {
#line 978
    exit(1);
    }
  }
#line 981
  if (verbose) {
    {
#line 982
    cdda_verbose_set(d, 1, 1);
    }
  } else {
    {
#line 984
    cdda_verbose_set(d, 1, 0);
    }
  }
#line 987
  if (force_cdrom_endian != -1) {
#line 988
    d->bigendianp = force_cdrom_endian;
    {
#line 990
    if (force_cdrom_endian == 0) {
#line 990
      goto case_0;
    }
#line 993
    if (force_cdrom_endian == 1) {
#line 993
      goto case_1;
    }
#line 989
    goto switch_break___0;
    case_0: /* CIL Label */ 
#line 991
    if (! quiet) {
      {
#line 991
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Forcing CDROM sense to little-endian; ignoring preset and autosense");
#line 991
      fputc('\n', stderr);
      }
    }
#line 991
    if (reportfile) {
      {
#line 991
      fprintf((FILE */* __restrict  */)reportfile, (char const   */* __restrict  */)"Forcing CDROM sense to little-endian; ignoring preset and autosense");
#line 991
      fputc('\n', reportfile);
      }
    }
#line 992
    goto switch_break___0;
    case_1: /* CIL Label */ 
#line 994
    if (! quiet) {
      {
#line 994
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Forcing CDROM sense to big-endian; ignoring preset and autosense");
#line 994
      fputc('\n', stderr);
      }
    }
#line 994
    if (reportfile) {
      {
#line 994
      fprintf((FILE */* __restrict  */)reportfile, (char const   */* __restrict  */)"Forcing CDROM sense to big-endian; ignoring preset and autosense");
#line 994
      fputc('\n', reportfile);
      }
    }
#line 995
    goto switch_break___0;
    switch_break___0: /* CIL Label */ ;
    }
  }
#line 998
  if (force_cdrom_sectors != -1) {
#line 999
    if (force_cdrom_sectors < 0) {
#line 999
      goto _L___2;
    } else
#line 999
    if (force_cdrom_sectors > 100) {
      _L___2: /* CIL Label */ 
#line 1000
      if (! quiet) {
        {
#line 1000
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Default sector read size must be 1<= n <= 100\n");
#line 1000
        fputc('\n', stderr);
        }
      }
#line 1000
      if (reportfile) {
        {
#line 1000
        fprintf((FILE */* __restrict  */)reportfile, (char const   */* __restrict  */)"Default sector read size must be 1<= n <= 100\n");
#line 1000
        fputc('\n', reportfile);
        }
      }
      {
#line 1001
      cdda_close(d);
#line 1002
      d = (cdrom_drive *)((void *)0);
#line 1003
      exit(1);
      }
    }
#line 1005
    if (! quiet) {
      {
#line 1005
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Forcing default to read %d sectors; ignoring preset and autosense",
              force_cdrom_sectors);
#line 1005
      fputc('\n', stderr);
      }
    }
#line 1005
    if (reportfile) {
      {
#line 1005
      fprintf((FILE */* __restrict  */)reportfile, (char const   */* __restrict  */)"Forcing default to read %d sectors; ignoring preset and autosense",
              force_cdrom_sectors);
#line 1005
      fputc('\n', reportfile);
      }
    }
#line 1007
    d->nsectors = force_cdrom_sectors;
#line 1008
    d->bigbuff = (long )(force_cdrom_sectors * 2352);
  }
#line 1010
  if (force_cdrom_overlap != -1) {
#line 1011
    if (force_cdrom_overlap < 0) {
#line 1011
      goto _L___3;
    } else
#line 1011
    if (force_cdrom_overlap > 75) {
      _L___3: /* CIL Label */ 
#line 1012
      if (! quiet) {
        {
#line 1012
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Search overlap sectors must be 0<= n <=75\n");
#line 1012
        fputc('\n', stderr);
        }
      }
#line 1012
      if (reportfile) {
        {
#line 1012
        fprintf((FILE */* __restrict  */)reportfile, (char const   */* __restrict  */)"Search overlap sectors must be 0<= n <=75\n");
#line 1012
        fputc('\n', reportfile);
        }
      }
      {
#line 1013
      cdda_close(d);
#line 1014
      d = (cdrom_drive *)((void *)0);
#line 1015
      exit(1);
      }
    }
#line 1017
    if (! quiet) {
      {
#line 1017
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Forcing search overlap to %d sectors; ignoring autosense",
              force_cdrom_overlap);
#line 1017
      fputc('\n', stderr);
      }
    }
#line 1017
    if (reportfile) {
      {
#line 1017
      fprintf((FILE */* __restrict  */)reportfile, (char const   */* __restrict  */)"Forcing search overlap to %d sectors; ignoring autosense",
              force_cdrom_overlap);
#line 1017
      fputc('\n', reportfile);
      }
    }
  }
  {
#line 1021
  tmp___17 = cdda_open(d);
  }
  {
#line 1022
  if (tmp___17 == -5) {
#line 1022
    goto case_neg_5;
  }
#line 1022
  if (tmp___17 == -4) {
#line 1022
    goto case_neg_5;
  }
#line 1022
  if (tmp___17 == -3) {
#line 1022
    goto case_neg_5;
  }
#line 1022
  if (tmp___17 == -2) {
#line 1022
    goto case_neg_5;
  }
#line 1025
  if (tmp___17 == -6) {
#line 1025
    goto case_neg_6;
  }
#line 1028
  if (tmp___17 == 0) {
#line 1028
    goto case_0___0;
  }
#line 1030
  goto switch_default___0;
  case_neg_5: /* CIL Label */ 
  case_neg_4: /* CIL Label */ 
  case_neg_3: /* CIL Label */ 
  case_neg_2: /* CIL Label */ 
#line 1023
  if (! quiet) {
    {
#line 1023
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\nUnable to open disc.  Is there an audio CD in the drive?");
#line 1023
    fputc('\n', stderr);
    }
  }
#line 1023
  if (reportfile) {
    {
#line 1023
    fprintf((FILE */* __restrict  */)reportfile, (char const   */* __restrict  */)"\nUnable to open disc.  Is there an audio CD in the drive?");
#line 1023
    fputc('\n', reportfile);
    }
  }
  {
#line 1024
  exit(1);
  }
  case_neg_6: /* CIL Label */ 
#line 1026
  if (! quiet) {
    {
#line 1026
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\ncdparanoia could not find a way to read audio from this drive.");
#line 1026
    fputc('\n', stderr);
    }
  }
#line 1026
  if (reportfile) {
    {
#line 1026
    fprintf((FILE */* __restrict  */)reportfile, (char const   */* __restrict  */)"\ncdparanoia could not find a way to read audio from this drive.");
#line 1026
    fputc('\n', reportfile);
    }
  }
  {
#line 1027
  exit(1);
  }
  case_0___0: /* CIL Label */ 
#line 1029
  goto switch_break___1;
  switch_default___0: /* CIL Label */ 
#line 1031
  if (! quiet) {
    {
#line 1031
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\nUnable to open disc.");
#line 1031
    fputc('\n', stderr);
    }
  }
#line 1031
  if (reportfile) {
    {
#line 1031
    fprintf((FILE */* __restrict  */)reportfile, (char const   */* __restrict  */)"\nUnable to open disc.");
#line 1031
    fputc('\n', reportfile);
    }
  }
  {
#line 1032
  exit(1);
  }
  switch_break___1: /* CIL Label */ ;
  }
#line 1035
  if (force_cdrom_speed == 0) {
#line 1035
    force_cdrom_speed = -1;
  }
#line 1036
  if (force_cdrom_speed != -1) {
#line 1037
    if (! quiet) {
      {
#line 1037
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\nAttempting to set speed to %dx... ",
              force_cdrom_speed);
#line 1037
      fputc('\n', stderr);
      }
    }
#line 1037
    if (reportfile) {
      {
#line 1037
      fprintf((FILE */* __restrict  */)reportfile, (char const   */* __restrict  */)"\nAttempting to set speed to %dx... ",
              force_cdrom_speed);
#line 1037
      fputc('\n', reportfile);
      }
    }
  } else
#line 1039
  if (verbose) {
#line 1040
    if (! quiet) {
      {
#line 1040
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\nAttempting to set cdrom to full speed... ");
#line 1040
      fputc('\n', stderr);
      }
    }
#line 1040
    if (reportfile) {
      {
#line 1040
      fprintf((FILE */* __restrict  */)reportfile, (char const   */* __restrict  */)"\nAttempting to set cdrom to full speed... ");
#line 1040
      fputc('\n', reportfile);
      }
    }
  }
  {
#line 1043
  tmp___18 = cdda_speed_set(d, force_cdrom_speed);
  }
#line 1043
  if (tmp___18) {
#line 1044
    if (verbose) {
#line 1044
      goto _L___4;
    } else
#line 1044
    if (force_cdrom_speed != -1) {
      _L___4: /* CIL Label */ 
#line 1045
      if (! quiet) {
        {
#line 1045
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\tCDROM speed set FAILED. Continuing anyway...");
#line 1045
        fputc('\n', stderr);
        }
      }
#line 1045
      if (reportfile) {
        {
#line 1045
        fprintf((FILE */* __restrict  */)reportfile, (char const   */* __restrict  */)"\tCDROM speed set FAILED. Continuing anyway...");
#line 1045
        fputc('\n', reportfile);
        }
      }
    }
  } else
#line 1047
  if (verbose) {
#line 1048
    if (! quiet) {
      {
#line 1048
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\tdrive returned OK.");
#line 1048
      fputc('\n', stderr);
      }
    }
#line 1048
    if (reportfile) {
      {
#line 1048
      fprintf((FILE */* __restrict  */)reportfile, (char const   */* __restrict  */)"\tdrive returned OK.");
#line 1048
      fputc('\n', reportfile);
      }
    }
  }
#line 1051
  if (run_cache_test) {
    {
#line 1052
    tmp___19 = analyze_cache(d, stderr, reportfile, force_cdrom_speed);
#line 1052
    warn = tmp___19;
    }
#line 1054
    if (warn == 0) {
#line 1055
      if (! quiet) {
        {
#line 1055
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\nDrive tests OK with Paranoia.\n\n");
        }
      }
#line 1055
      if (reportfile) {
        {
#line 1055
        fprintf((FILE */* __restrict  */)reportfile, (char const   */* __restrict  */)"\nDrive tests OK with Paranoia.\n\n");
        }
      }
#line 1056
      return (0);
    }
#line 1059
    if (warn == 1) {
#line 1060
      if (! quiet) {
        {
#line 1060
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\nWARNING! PARANOIA MAY NOT BE TRUSTWORTHY WITH THIS DRIVE!\n\nThe Paranoia library may not model this CDROM drive\'s cache\ncorrectly according to this analysis run. Analysis is not\nalways accurate (it can be fooled by machine load or random\nkernel latencies), but if a failed result happens more often\nthan one time in twenty on an unloaded machine, please mail\nthe %s file produced by this failed analysis to\nparanoia-dev@xiph.org to assist developers in extending\nParanoia to handle this CDROM properly.\n\n",
                reportfile_name);
        }
      }
#line 1060
      if (reportfile) {
        {
#line 1060
        fprintf((FILE */* __restrict  */)reportfile, (char const   */* __restrict  */)"\nWARNING! PARANOIA MAY NOT BE TRUSTWORTHY WITH THIS DRIVE!\n\nThe Paranoia library may not model this CDROM drive\'s cache\ncorrectly according to this analysis run. Analysis is not\nalways accurate (it can be fooled by machine load or random\nkernel latencies), but if a failed result happens more often\nthan one time in twenty on an unloaded machine, please mail\nthe %s file produced by this failed analysis to\nparanoia-dev@xiph.org to assist developers in extending\nParanoia to handle this CDROM properly.\n\n",
                reportfile_name);
        }
      }
    }
#line 1069
    return (1);
  }
#line 1074
  if (query_only) {
    {
#line 1074
    display_toc(d);
    }
  } else
#line 1074
  if (verbose) {
    {
#line 1074
    display_toc(d);
    }
  }
#line 1075
  if (query_only) {
    {
#line 1075
    exit(0);
    }
  }
#line 1081
  if (sample_offset) {
#line 1082
    toc_offset += sample_offset / 588;
#line 1083
    sample_offset %= 588;
#line 1084
    if (sample_offset < 0) {
#line 1085
      sample_offset += 588;
#line 1086
      toc_offset --;
    }
  }
#line 1090
  if (toc_bias) {
    {
#line 1091
    tmp___20 = cdda_track_firstsector(d, 1);
#line 1091
    toc_offset = (int )(- tmp___20);
    }
  }
#line 1093
  i = 0;
  {
#line 1093
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 1093
    if (! (i < d->tracks + 1)) {
#line 1093
      goto while_break___2;
    }
#line 1094
    d->disc_toc[i].dwStartSector += toc_offset;
#line 1093
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 1097
  if (d->nsectors == 1) {
#line 1098
    if (! quiet) {
      {
#line 1098
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"WARNING: The autosensed/selected sectors per read value is\n         one sector, making it very unlikely Paranoia can \n         work.\n\n         Attempting to continue...\n\n");
#line 1098
      fputc('\n', stderr);
      }
    }
#line 1098
    if (reportfile) {
      {
#line 1098
      fprintf((FILE */* __restrict  */)reportfile, (char const   */* __restrict  */)"WARNING: The autosensed/selected sectors per read value is\n         one sector, making it very unlikely Paranoia can \n         work.\n\n         Attempting to continue...\n\n");
#line 1098
      fputc('\n', reportfile);
      }
    }
  }
#line 1113
  if (span) {
    {
#line 1115
    tmp___21 = strchr((char const   *)span, '-');
#line 1115
    span2 = tmp___21;
#line 1116
    tmp___22 = strrchr((char const   *)span, '-');
    }
#line 1116
    if ((unsigned long )tmp___22 != (unsigned long )span2) {
#line 1117
      if (! quiet) {
        {
#line 1117
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error parsing span argument");
#line 1117
        fputc('\n', stderr);
        }
      }
#line 1117
      if (reportfile) {
        {
#line 1117
        fprintf((FILE */* __restrict  */)reportfile, (char const   */* __restrict  */)"Error parsing span argument");
#line 1117
        fputc('\n', reportfile);
        }
      }
      {
#line 1118
      cdda_close(d);
#line 1119
      d = (cdrom_drive *)((void *)0);
#line 1120
      exit(1);
      }
    }
#line 1123
    if ((unsigned long )span2 != (unsigned long )((void *)0)) {
#line 1124
      *span2 = (char )'\000';
#line 1125
      span2 ++;
    }
    {
#line 1128
    first_sector = parse_offset(d, span, -1);
    }
#line 1129
    if (first_sector == -1L) {
      {
#line 1130
      tmp___23 = cdda_disc_firstsector(d);
#line 1130
      last_sector = parse_offset(d, span2, (int )tmp___23);
      }
    } else {
      {
#line 1132
      last_sector = parse_offset(d, span2, (int )first_sector);
      }
    }
#line 1134
    if (first_sector == -1L) {
#line 1135
      if (last_sector == -1L) {
#line 1136
        if (! quiet) {
          {
#line 1136
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error parsing span argument");
#line 1136
          fputc('\n', stderr);
          }
        }
#line 1136
        if (reportfile) {
          {
#line 1136
          fprintf((FILE */* __restrict  */)reportfile, (char const   */* __restrict  */)"Error parsing span argument");
#line 1136
          fputc('\n', reportfile);
          }
        }
        {
#line 1137
        cdda_close(d);
#line 1138
        d = (cdrom_drive *)((void *)0);
#line 1139
        exit(1);
        }
      } else {
        {
#line 1141
        first_sector = cdda_disc_firstsector(d);
        }
      }
    } else
#line 1144
    if (last_sector == -1L) {
#line 1145
      if (span2) {
        {
#line 1146
        last_sector = cdda_disc_lastsector(d);
        }
      } else {
        {
#line 1148
        tmp___24 = cdda_sector_gettrack(d, first_sector);
#line 1148
        last_sector = cdda_track_lastsector(d, tmp___24);
        }
      }
    }
  } else {
    {
#line 1154
    first_sector = cdda_disc_firstsector(d);
#line 1155
    last_sector = cdda_disc_lastsector(d);
    }
  }
  {
#line 1159
  tmp___25 = cdda_sector_gettrack(d, first_sector);
#line 1159
  track1 = tmp___25;
#line 1160
  tmp___26 = cdda_sector_gettrack(d, last_sector);
#line 1160
  track2 = tmp___26;
#line 1161
  tmp___27 = cdda_track_firstsector(d, track1);
#line 1161
  off1 = first_sector - tmp___27;
#line 1162
  tmp___28 = cdda_track_firstsector(d, track2);
#line 1162
  off2 = last_sector - tmp___28;
#line 1165
  i___2 = track1;
  }
  {
#line 1165
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 1165
    if (! (i___2 <= track2)) {
#line 1165
      goto while_break___3;
    }
    {
#line 1166
    tmp___29 = cdda_track_audiop(d, i___2);
    }
#line 1166
    if (! tmp___29) {
#line 1167
      if (! quiet) {
        {
#line 1167
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Selected span contains non audio tracks.  Aborting.\n\n");
#line 1167
        fputc('\n', stderr);
        }
      }
#line 1167
      if (reportfile) {
        {
#line 1167
        fprintf((FILE */* __restrict  */)reportfile, (char const   */* __restrict  */)"Selected span contains non audio tracks.  Aborting.\n\n");
#line 1167
        fputc('\n', reportfile);
        }
      }
      {
#line 1168
      exit(1);
      }
    }
#line 1165
    i___2 ++;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 1171
  if (! quiet) {
    {
#line 1171
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Ripping from sector %7ld (track %2d [%d:%02d.%02d])\n\t  to sector %7ld (track %2d [%d:%02d.%02d])\n",
            first_sector, track1, (int )(off1 / 4500L), (int )((off1 / 75L) % 60L),
            (int )(off1 % 75L), last_sector, track2, (int )(off2 / 4500L), (int )((off2 / 75L) % 60L),
            (int )(off2 % 75L));
#line 1171
    fputc('\n', stderr);
    }
  }
#line 1171
  if (reportfile) {
    {
#line 1171
    fprintf((FILE */* __restrict  */)reportfile, (char const   */* __restrict  */)"Ripping from sector %7ld (track %2d [%d:%02d.%02d])\n\t  to sector %7ld (track %2d [%d:%02d.%02d])\n",
            first_sector, track1, (int )(off1 / 4500L), (int )((off1 / 75L) % 60L),
            (int )(off1 % 75L), last_sector, track2, (int )(off2 / 4500L), (int )((off2 / 75L) % 60L),
            (int )(off2 % 75L));
#line 1171
    fputc('\n', reportfile);
    }
  }
  {
#line 1182
  offset_buffer_used = 0;
#line 1183
  offset_skip = sample_offset * 4;
#line 1185
  p = paranoia_init(d);
#line 1186
  paranoia_modeset(p, paranoia_mode);
  }
#line 1187
  if (force_cdrom_overlap != -1) {
    {
#line 1187
    paranoia_overlapset(p, (long )force_cdrom_overlap);
    }
  }
#line 1189
  if (verbose) {
    {
#line 1190
    cdda_verbose_set(d, 2, 2);
    }
  } else {
    {
#line 1192
    cdda_verbose_set(d, 0, 0);
    }
  }
  {
#line 1194
  cursor = first_sector;
#line 1194
  paranoia_seek(p, cursor, 0);
#line 1197
  tmp___30 = getuid();
#line 1197
  seteuid(tmp___30);
#line 1198
  tmp___31 = getgid();
#line 1198
  setegid(tmp___31);
  }
#line 1205
  if (sample_offset) {
#line 1206
    (d->disc_toc[d->tracks].dwStartSector) ++;
  }
  {
#line 1208
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 1208
    if (! (cursor <= last_sector)) {
#line 1208
      goto while_break___4;
    }
#line 1210
    if (batch) {
      {
#line 1211
      batch_first = cursor;
#line 1212
      batch_track = cdda_sector_gettrack(d, cursor);
#line 1212
      batch_last = cdda_track_lastsector(d, batch_track);
      }
#line 1215
      if (batch_last > last_sector) {
#line 1215
        batch_last = last_sector;
      }
    } else {
#line 1217
      batch_first = first_sector;
#line 1218
      batch_last = last_sector;
#line 1219
      batch_track = -1;
    }
#line 1222
    callbegin = batch_first;
#line 1223
    callend = batch_last;
#line 1227
    if (optind + 1 < argc) {
      {
#line 1228
      tmp___40 = strcmp((char const   *)*(argv + (optind + 1)), "-");
      }
#line 1228
      if (tmp___40) {
        {
#line 1241
        tmp___33 = strrchr((char const   *)*(argv + (optind + 1)), '/');
#line 1241
        post = tmp___33;
        }
#line 1242
        if (post) {
#line 1242
          tmp___34 = (post - *(argv + (optind + 1))) + 1L;
        } else {
#line 1242
          tmp___34 = 0L;
        }
#line 1242
        pos = (int )tmp___34;
#line 1243
        file = *(argv + (optind + 1)) + pos;
#line 1245
        path[0] = (char )'\000';
#line 1247
        if (pos) {
#line 1248
          if (pos > 256) {
#line 1248
            tmp___35 = 256;
          } else {
#line 1248
            tmp___35 = pos;
          }
          {
#line 1248
          strncat((char */* __restrict  */)(path), (char const   */* __restrict  */)*(argv + (optind + 1)),
                  (size_t )tmp___35);
          }
        }
#line 1250
        if (batch) {
          {
#line 1251
          snprintf((char */* __restrict  */)(outfile_name), (size_t )246, (char const   */* __restrict  */)"%strack%02d.%s",
                   path, batch_track, file);
          }
        } else {
          {
#line 1253
          snprintf((char */* __restrict  */)(outfile_name), (size_t )246, (char const   */* __restrict  */)"%s%s",
                   path, file);
          }
        }
#line 1255
        if ((int )*(file + 0) == 0) {
          {
#line 1257
          if (output_type == 0) {
#line 1257
            goto case_0___1;
          }
#line 1260
          if (output_type == 1) {
#line 1260
            goto case_1___0;
          }
#line 1263
          if (output_type == 2) {
#line 1263
            goto case_2;
          }
#line 1266
          if (output_type == 3) {
#line 1266
            goto case_3;
          }
#line 1256
          goto switch_break___2;
          case_0___1: /* CIL Label */ 
          {
#line 1258
          strcat((char */* __restrict  */)(outfile_name), (char const   */* __restrict  */)"cdda.raw");
          }
#line 1259
          goto switch_break___2;
          case_1___0: /* CIL Label */ 
          {
#line 1261
          strcat((char */* __restrict  */)(outfile_name), (char const   */* __restrict  */)"cdda.wav");
          }
#line 1262
          goto switch_break___2;
          case_2: /* CIL Label */ 
          {
#line 1264
          strcat((char */* __restrict  */)(outfile_name), (char const   */* __restrict  */)"cdda.aifc");
          }
#line 1265
          goto switch_break___2;
          case_3: /* CIL Label */ 
          {
#line 1267
          strcat((char */* __restrict  */)(outfile_name), (char const   */* __restrict  */)"cdda.aiff");
          }
#line 1268
          goto switch_break___2;
          switch_break___2: /* CIL Label */ ;
          }
        }
        {
#line 1272
        out = open((char const   *)(outfile_name), 578, 438);
        }
#line 1273
        if (out == -1) {
#line 1274
          if (! quiet) {
            {
#line 1274
            tmp___36 = __errno_location();
#line 1274
            tmp___37 = strerror(*tmp___36);
#line 1274
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Cannot open specified output file %s: %s",
                    outfile_name, tmp___37);
#line 1274
            fputc('\n', stderr);
            }
          }
#line 1274
          if (reportfile) {
            {
#line 1274
            tmp___38 = __errno_location();
#line 1274
            tmp___39 = strerror(*tmp___38);
#line 1274
            fprintf((FILE */* __restrict  */)reportfile, (char const   */* __restrict  */)"Cannot open specified output file %s: %s",
                    outfile_name, tmp___39);
#line 1274
            fputc('\n', reportfile);
            }
          }
          {
#line 1276
          cdda_close(d);
#line 1277
          d = (cdrom_drive *)((void *)0);
#line 1278
          exit(1);
          }
        }
#line 1280
        if (! quiet) {
          {
#line 1280
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"outputting to %s\n",
                  outfile_name);
#line 1280
          fputc('\n', stderr);
          }
        }
#line 1280
        if (reportfile) {
          {
#line 1280
          fprintf((FILE */* __restrict  */)reportfile, (char const   */* __restrict  */)"outputting to %s\n",
                  outfile_name);
#line 1280
          fputc('\n', reportfile);
          }
        }
#line 1281
        if (logfile) {
          {
#line 1282
          fprintf((FILE */* __restrict  */)logfile, (char const   */* __restrict  */)"outputting to %s\n",
                  outfile_name);
#line 1283
          fflush(logfile);
          }
        }
      } else {
        {
#line 1229
        tmp___32 = fileno(stdout);
#line 1229
        out = dup(tmp___32);
        }
#line 1230
        if (batch) {
#line 1230
          if (! quiet) {
            {
#line 1230
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Are you sure you wanted \'batch\' (-B) output with stdout?");
#line 1230
            fputc('\n', stderr);
            }
          }
#line 1230
          if (reportfile) {
            {
#line 1230
            fprintf((FILE */* __restrict  */)reportfile, (char const   */* __restrict  */)"Are you sure you wanted \'batch\' (-B) output with stdout?");
#line 1230
            fputc('\n', reportfile);
            }
          }
        }
#line 1232
        if (! quiet) {
          {
#line 1232
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"outputting to stdout\n");
#line 1232
          fputc('\n', stderr);
          }
        }
#line 1232
        if (reportfile) {
          {
#line 1232
          fprintf((FILE */* __restrict  */)reportfile, (char const   */* __restrict  */)"outputting to stdout\n");
#line 1232
          fputc('\n', reportfile);
          }
        }
#line 1233
        if (logfile) {
          {
#line 1234
          fprintf((FILE */* __restrict  */)logfile, (char const   */* __restrict  */)"outputting to stdout\n");
#line 1235
          fflush(logfile);
          }
        }
#line 1237
        outfile_name[0] = (char )'\000';
      }
    } else {
#line 1288
      if (batch) {
        {
#line 1289
        sprintf((char */* __restrict  */)(outfile_name), (char const   */* __restrict  */)"track%02d.",
                batch_track);
        }
      } else {
#line 1291
        outfile_name[0] = (char )'\000';
      }
      {
#line 1294
      if (output_type == 0) {
#line 1294
        goto case_0___2;
      }
#line 1297
      if (output_type == 1) {
#line 1297
        goto case_1___1;
      }
#line 1300
      if (output_type == 2) {
#line 1300
        goto case_2___0;
      }
#line 1303
      if (output_type == 3) {
#line 1303
        goto case_3___0;
      }
#line 1293
      goto switch_break___3;
      case_0___2: /* CIL Label */ 
      {
#line 1295
      strcat((char */* __restrict  */)(outfile_name), (char const   */* __restrict  */)"cdda.raw");
      }
#line 1296
      goto switch_break___3;
      case_1___1: /* CIL Label */ 
      {
#line 1298
      strcat((char */* __restrict  */)(outfile_name), (char const   */* __restrict  */)"cdda.wav");
      }
#line 1299
      goto switch_break___3;
      case_2___0: /* CIL Label */ 
      {
#line 1301
      strcat((char */* __restrict  */)(outfile_name), (char const   */* __restrict  */)"cdda.aifc");
      }
#line 1302
      goto switch_break___3;
      case_3___0: /* CIL Label */ 
      {
#line 1304
      strcat((char */* __restrict  */)(outfile_name), (char const   */* __restrict  */)"cdda.aiff");
      }
#line 1305
      goto switch_break___3;
      switch_break___3: /* CIL Label */ ;
      }
      {
#line 1308
      out = open((char const   *)(outfile_name), 578, 438);
      }
#line 1309
      if (out == -1) {
#line 1310
        if (! quiet) {
          {
#line 1310
          tmp___41 = __errno_location();
#line 1310
          tmp___42 = strerror(*tmp___41);
#line 1310
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Cannot open default output file %s: %s",
                  outfile_name, tmp___42);
#line 1310
          fputc('\n', stderr);
          }
        }
#line 1310
        if (reportfile) {
          {
#line 1310
          tmp___43 = __errno_location();
#line 1310
          tmp___44 = strerror(*tmp___43);
#line 1310
          fprintf((FILE */* __restrict  */)reportfile, (char const   */* __restrict  */)"Cannot open default output file %s: %s",
                  outfile_name, tmp___44);
#line 1310
          fputc('\n', reportfile);
          }
        }
        {
#line 1312
        cdda_close(d);
#line 1313
        d = (cdrom_drive *)((void *)0);
#line 1314
        exit(1);
        }
      }
#line 1316
      if (! quiet) {
        {
#line 1316
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"outputting to %s\n",
                outfile_name);
#line 1316
        fputc('\n', stderr);
        }
      }
#line 1316
      if (reportfile) {
        {
#line 1316
        fprintf((FILE */* __restrict  */)reportfile, (char const   */* __restrict  */)"outputting to %s\n",
                outfile_name);
#line 1316
        fputc('\n', reportfile);
        }
      }
#line 1317
      if (logfile) {
        {
#line 1318
        fprintf((FILE */* __restrict  */)logfile, (char const   */* __restrict  */)"outputting to %s\n",
                outfile_name);
#line 1319
        fflush(logfile);
        }
      }
    }
    {
#line 1324
    if (output_type == 0) {
#line 1324
      goto case_0___3;
    }
#line 1326
    if (output_type == 1) {
#line 1326
      goto case_1___2;
    }
#line 1329
    if (output_type == 2) {
#line 1329
      goto case_2___1;
    }
#line 1332
    if (output_type == 3) {
#line 1332
      goto case_3___1;
    }
#line 1323
    goto switch_break___4;
    case_0___3: /* CIL Label */ 
#line 1325
    goto switch_break___4;
    case_1___2: /* CIL Label */ 
    {
#line 1327
    WriteWav(out, ((batch_last - batch_first) + 1L) * 2352L);
    }
#line 1328
    goto switch_break___4;
    case_2___1: /* CIL Label */ 
    {
#line 1330
    WriteAifc(out, ((batch_last - batch_first) + 1L) * 2352L);
    }
#line 1331
    goto switch_break___4;
    case_3___1: /* CIL Label */ 
    {
#line 1333
    WriteAiff(out, ((batch_last - batch_first) + 1L) * 2352L);
    }
#line 1334
    goto switch_break___4;
    switch_break___4: /* CIL Label */ ;
    }
#line 1339
    if (offset_buffer_used) {
      {
#line 1341
      cursor ++;
#line 1342
      tmp___49 = buffering_write(out, (char *)(offset_buffer) + offset_buffer_used,
                                 (long )(2352 - offset_buffer_used));
      }
#line 1342
      if (tmp___49) {
#line 1345
        if (! quiet) {
          {
#line 1345
          tmp___45 = __errno_location();
#line 1345
          tmp___46 = strerror(*tmp___45);
#line 1345
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error writing output: %s",
                  tmp___46);
#line 1345
          fputc('\n', stderr);
          }
        }
#line 1345
        if (reportfile) {
          {
#line 1345
          tmp___47 = __errno_location();
#line 1345
          tmp___48 = strerror(*tmp___47);
#line 1345
          fprintf((FILE */* __restrict  */)reportfile, (char const   */* __restrict  */)"Error writing output: %s",
                  tmp___48);
#line 1345
          fputc('\n', reportfile);
          }
        }
        {
#line 1346
        exit(1);
        }
      }
    }
#line 1350
    skipped_flag = 0;
    {
#line 1351
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 1351
      if (! (cursor <= batch_last)) {
#line 1351
        goto while_break___5;
      }
      {
#line 1353
      tmp___50 = paranoia_read_limited(p, & callback, max_retries);
#line 1353
      readbuf = tmp___50;
#line 1354
      tmp___51 = cdda_errors(d);
#line 1354
      err = tmp___51;
#line 1355
      tmp___52 = cdda_messages(d);
#line 1355
      mes = tmp___52;
      }
#line 1357
      if (mes) {
#line 1357
        goto _L___5;
      } else
#line 1357
      if (err) {
        _L___5: /* CIL Label */ 
#line 1358
        if (err) {
#line 1358
          tmp___53 = (char const   *)err;
        } else {
#line 1358
          tmp___53 = "";
        }
#line 1358
        if (mes) {
#line 1358
          tmp___54 = (char const   *)mes;
        } else {
#line 1358
          tmp___54 = "";
        }
        {
#line 1358
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\r                                                                          \r%s%s\n",
                tmp___54, tmp___53);
        }
      }
#line 1362
      if (err) {
        {
#line 1362
        free((void *)err);
        }
      }
#line 1363
      if (mes) {
        {
#line 1363
        free((void *)mes);
        }
      }
#line 1364
      if ((unsigned long )readbuf == (unsigned long )((void *)0)) {
        {
#line 1365
        tmp___55 = __errno_location();
        }
#line 1365
        if (*tmp___55 == 9) {
#line 1365
          goto _L___6;
        } else {
          {
#line 1365
          tmp___56 = __errno_location();
          }
#line 1365
          if (*tmp___56 == 123) {
            _L___6: /* CIL Label */ 
#line 1366
            if (! quiet) {
              {
#line 1366
              fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\nparanoia_read: CDROM drive unavailable, bailing.\n");
#line 1366
              fputc('\n', stderr);
              }
            }
#line 1366
            if (reportfile) {
              {
#line 1366
              fprintf((FILE */* __restrict  */)reportfile, (char const   */* __restrict  */)"\nparanoia_read: CDROM drive unavailable, bailing.\n");
#line 1366
              fputc('\n', reportfile);
              }
            }
            {
#line 1367
            exit(1);
            }
          }
        }
#line 1369
        skipped_flag = 1;
#line 1370
        if (! quiet) {
          {
#line 1370
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\nparanoia_read: Unrecoverable error, bailing.\n");
#line 1370
          fputc('\n', stderr);
          }
        }
#line 1370
        if (reportfile) {
          {
#line 1370
          fprintf((FILE */* __restrict  */)reportfile, (char const   */* __restrict  */)"\nparanoia_read: Unrecoverable error, bailing.\n");
#line 1370
          fputc('\n', reportfile);
          }
        }
#line 1371
        goto while_break___5;
      }
#line 1373
      if (skipped_flag) {
#line 1373
        if (abort_on_skip) {
#line 1374
          cursor = batch_last + 1L;
#line 1375
          goto while_break___5;
        }
      }
      {
#line 1378
      skipped_flag = 0;
#line 1379
      cursor ++;
#line 1381
      tmp___57 = bigendianp();
      }
#line 1381
      if (output_endian != tmp___57) {
#line 1383
        i___3 = 0;
        {
#line 1383
        while (1) {
          while_continue___6: /* CIL Label */ ;
#line 1383
          if (! (i___3 < 1176)) {
#line 1383
            goto while_break___6;
          }
          {
#line 1383
          *(readbuf + i___3) = swap16(*(readbuf + i___3));
#line 1383
          i___3 ++;
          }
        }
        while_break___6: /* CIL Label */ ;
        }
      }
      {
#line 1386
      callback(cursor * 1176L - 1L, -2);
#line 1388
      tmp___62 = buffering_write(out, (char *)readbuf + offset_skip, (long )(2352 - offset_skip));
      }
#line 1388
      if (tmp___62) {
#line 1390
        if (! quiet) {
          {
#line 1390
          tmp___58 = __errno_location();
#line 1390
          tmp___59 = strerror(*tmp___58);
#line 1390
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error writing output: %s",
                  tmp___59);
#line 1390
          fputc('\n', stderr);
          }
        }
#line 1390
        if (reportfile) {
          {
#line 1390
          tmp___60 = __errno_location();
#line 1390
          tmp___61 = strerror(*tmp___60);
#line 1390
          fprintf((FILE */* __restrict  */)reportfile, (char const   */* __restrict  */)"Error writing output: %s",
                  tmp___61);
#line 1390
          fputc('\n', reportfile);
          }
        }
        {
#line 1391
        exit(1);
        }
      }
      {
#line 1393
      offset_skip = 0;
#line 1395
      tmp___63 = bigendianp();
      }
#line 1395
      if (output_endian != tmp___63) {
#line 1397
        i___4 = 0;
        {
#line 1397
        while (1) {
          while_continue___7: /* CIL Label */ ;
#line 1397
          if (! (i___4 < 1176)) {
#line 1397
            goto while_break___7;
          }
          {
#line 1397
          *(readbuf + i___4) = swap16(*(readbuf + i___4));
#line 1397
          i___4 ++;
          }
        }
        while_break___7: /* CIL Label */ ;
        }
      }
#line 1401
      if (sample_offset) {
#line 1401
        if (cursor > batch_last) {
          {
#line 1405
          readbuf = paranoia_read_limited(p, & callback, max_retries);
#line 1406
          err = cdda_errors(d);
#line 1406
          mes = cdda_messages(d);
          }
#line 1408
          if (mes) {
#line 1408
            goto _L___7;
          } else
#line 1408
          if (err) {
            _L___7: /* CIL Label */ 
#line 1409
            if (err) {
#line 1409
              tmp___64 = (char const   *)err;
            } else {
#line 1409
              tmp___64 = "";
            }
#line 1409
            if (mes) {
#line 1409
              tmp___65 = (char const   *)mes;
            } else {
#line 1409
              tmp___65 = "";
            }
            {
#line 1409
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\r                                                                          \r%s%s\n",
                    tmp___65, tmp___64);
            }
          }
#line 1413
          if (err) {
            {
#line 1413
            free((void *)err);
            }
          }
#line 1413
          if (mes) {
            {
#line 1413
            free((void *)mes);
            }
          }
#line 1414
          if ((unsigned long )readbuf == (unsigned long )((void *)0)) {
#line 1415
            skipped_flag = 1;
#line 1416
            if (! quiet) {
              {
#line 1416
              fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\nparanoia_read: Unrecoverable error reading through sample_offset shift\n\tat end of track, bailing.\n");
#line 1416
              fputc('\n', stderr);
              }
            }
#line 1416
            if (reportfile) {
              {
#line 1416
              fprintf((FILE */* __restrict  */)reportfile, (char const   */* __restrict  */)"\nparanoia_read: Unrecoverable error reading through sample_offset shift\n\tat end of track, bailing.\n");
#line 1416
              fputc('\n', reportfile);
              }
            }
#line 1418
            goto while_break___5;
          }
#line 1420
          if (skipped_flag) {
#line 1420
            if (abort_on_skip) {
#line 1420
              goto while_break___5;
            }
          }
          {
#line 1421
          skipped_flag = 0;
#line 1424
          tmp___66 = bigendianp();
          }
#line 1424
          if (output_endian != tmp___66) {
#line 1425
            i___5 = 0;
            {
#line 1425
            while (1) {
              while_continue___8: /* CIL Label */ ;
#line 1425
              if (! (i___5 < 1176)) {
#line 1425
                goto while_break___8;
              }
              {
#line 1426
              offset_buffer[i___5] = swap16(*(readbuf + i___5));
#line 1425
              i___5 ++;
              }
            }
            while_break___8: /* CIL Label */ ;
            }
          } else {
            {
#line 1428
            memcpy((void */* __restrict  */)(offset_buffer), (void const   */* __restrict  */)readbuf,
                   (size_t )2352);
            }
          }
          {
#line 1429
          offset_buffer_used = sample_offset * 4;
#line 1431
          callback(cursor * 1176L, -2);
#line 1433
          tmp___71 = buffering_write(out, (char *)(offset_buffer), (long )offset_buffer_used);
          }
#line 1433
          if (tmp___71) {
#line 1435
            if (! quiet) {
              {
#line 1435
              tmp___67 = __errno_location();
#line 1435
              tmp___68 = strerror(*tmp___67);
#line 1435
              fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error writing output: %s",
                      tmp___68);
#line 1435
              fputc('\n', stderr);
              }
            }
#line 1435
            if (reportfile) {
              {
#line 1435
              tmp___69 = __errno_location();
#line 1435
              tmp___70 = strerror(*tmp___69);
#line 1435
              fprintf((FILE */* __restrict  */)reportfile, (char const   */* __restrict  */)"Error writing output: %s",
                      tmp___70);
#line 1435
              fputc('\n', reportfile);
              }
            }
            {
#line 1436
            exit(1);
            }
          }
        }
      }
    }
    while_break___5: /* CIL Label */ ;
    }
    {
#line 1440
    callback(cursor * 1176L - 1L, -1);
#line 1441
    buffering_close(out);
    }
#line 1442
    if (skipped_flag) {
#line 1444
      if (! quiet) {
        {
#line 1444
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\nRemoving aborted file: %s",
                outfile_name);
#line 1444
        fputc('\n', stderr);
        }
      }
#line 1444
      if (reportfile) {
        {
#line 1444
        fprintf((FILE */* __restrict  */)reportfile, (char const   */* __restrict  */)"\nRemoving aborted file: %s",
                outfile_name);
#line 1444
        fputc('\n', reportfile);
        }
      }
      {
#line 1445
      unlink((char const   *)(outfile_name));
      }
#line 1447
      if (batch_track != -1) {
        {
#line 1448
        batch_track ++;
#line 1449
        cursor = cdda_track_firstsector(d, batch_track);
#line 1450
        paranoia_seek(p, cursor, 0);
#line 1451
        offset_skip = sample_offset * 4;
#line 1452
        offset_buffer_used = 0;
        }
      }
    }
#line 1455
    if (! quiet) {
      {
#line 1455
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
#line 1455
      fputc('\n', stderr);
      }
    }
#line 1455
    if (reportfile) {
      {
#line 1455
      fprintf((FILE */* __restrict  */)reportfile, (char const   */* __restrict  */)"\n");
#line 1455
      fputc('\n', reportfile);
      }
    }
  }
  while_break___4: /* CIL Label */ ;
  }
  {
#line 1458
  paranoia_free(p);
#line 1459
  p = (void *)0;
  }
#line 1463
  if (! quiet) {
    {
#line 1463
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Done.\n\n");
#line 1463
    fputc('\n', stderr);
    }
  }
#line 1463
  if (reportfile) {
    {
#line 1463
    fprintf((FILE */* __restrict  */)reportfile, (char const   */* __restrict  */)"Done.\n\n");
#line 1463
    fputc('\n', reportfile);
    }
  }
  {
#line 1465
  cdda_close(d);
#line 1466
  d = (cdrom_drive *)((void *)0);
  }
#line 1467
  if (logfile_open) {
    {
#line 1468
    fclose(logfile);
    }
  }
#line 1469
  if (reportfile_open) {
    {
#line 1470
    fclose(reportfile);
    }
  }
#line 1471
  return (0);
}
}
