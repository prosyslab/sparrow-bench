/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 44
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 144 "/usr/include/libio.h"
struct _IO_FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 37 "/home/june/repo/benchmarks/collector/temp/ircmarkers-0.14/overlap.c"
struct box {
   int left ;
   int right ;
   int top ;
   int bottom ;
   int width ;
   int height ;
};
#line 46 "/home/june/repo/benchmarks/collector/temp/ircmarkers-0.14/overlap.c"
struct marker {
   unsigned int id ;
   unsigned int x ;
   unsigned int y ;
   int alignment ;
   struct box dot ;
   struct box txt ;
};
#line 168 "/usr/include/stdio.h"
extern struct _IO_FILE *stdin ;
#line 170
extern struct _IO_FILE *stderr ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 362
extern int printf(char const   * __restrict  __format  , ...) ;
#line 431
extern int scanf(char const   * __restrict  __format  , ...)  __asm__("__isoc99_scanf")  ;
#line 828
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) feof)(FILE *__stream ) ;
#line 147 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 466
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 480
extern  __attribute__((__nothrow__)) void *( __attribute__((__warn_unused_result__,
__leaf__)) realloc)(void *__ptr , size_t __size ) ;
#line 69 "/usr/include/assert.h"
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) __assert_fail)(char const   *__assertion ,
                                                                                                   char const   *__file ,
                                                                                                   unsigned int __line ,
                                                                                                   char const   *__function ) ;
#line 59 "/home/june/repo/benchmarks/collector/temp/ircmarkers-0.14/overlap.c"
static int nb_markers  ;
#line 60 "/home/june/repo/benchmarks/collector/temp/ircmarkers-0.14/overlap.c"
static unsigned int image_width  ;
#line 61 "/home/june/repo/benchmarks/collector/temp/ircmarkers-0.14/overlap.c"
static unsigned int image_height  ;
#line 62 "/home/june/repo/benchmarks/collector/temp/ircmarkers-0.14/overlap.c"
static int offset  ;
#line 63 "/home/june/repo/benchmarks/collector/temp/ircmarkers-0.14/overlap.c"
static struct marker *markers  ;
#line 66 "/home/june/repo/benchmarks/collector/temp/ircmarkers-0.14/overlap.c"
static int box_overlap(struct box *label , struct box *b ) 
{ 
  int width ;
  int height ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 71
  if (label->left > b->right) {
#line 72
    return (0);
  } else
#line 71
  if (label->right < b->left) {
#line 72
    return (0);
  }
#line 73
  if (label->top > b->bottom) {
#line 74
    return (0);
  } else
#line 73
  if (label->bottom < b->top) {
#line 74
    return (0);
  }
#line 76
  if (label->left > b->left) {
#line 77
    if (b->right < label->right) {
#line 77
      tmp = b->right;
    } else {
#line 77
      tmp = label->right;
    }
#line 77
    width = tmp - label->left;
  } else {
#line 79
    if (b->right < label->right) {
#line 79
      tmp___0 = b->right;
    } else {
#line 79
      tmp___0 = label->right;
    }
#line 79
    if (b->left > label->left) {
#line 79
      tmp___1 = b->left;
    } else {
#line 79
      tmp___1 = label->left;
    }
#line 79
    width = tmp___0 - tmp___1;
  }
#line 81
  if (label->top > b->top) {
#line 82
    if (b->bottom < label->bottom) {
#line 82
      tmp___2 = b->bottom;
    } else {
#line 82
      tmp___2 = label->bottom;
    }
#line 82
    height = tmp___2 - label->top;
  } else {
#line 84
    if (b->bottom < label->bottom) {
#line 84
      tmp___3 = b->bottom;
    } else {
#line 84
      tmp___3 = label->bottom;
    }
#line 84
    if (b->top > label->top) {
#line 84
      tmp___4 = b->top;
    } else {
#line 84
      tmp___4 = label->top;
    }
#line 84
    height = tmp___3 - tmp___4;
  }
#line 86
  return (width * height);
}
}
#line 89 "/home/june/repo/benchmarks/collector/temp/ircmarkers-0.14/overlap.c"
static int overlap(unsigned int id_current , struct box *b ) 
{ 
  int total_overlap ;
  int i ;
  int tmp ;
  int tmp___0 ;

  {
#line 92
  total_overlap = 0;
#line 94
  i = 0;
  {
#line 94
  while (1) {
    while_continue: /* CIL Label */ ;
#line 94
    if (! (i < nb_markers)) {
#line 94
      goto while_break;
    }
#line 95
    if ((unsigned int )i == id_current) {
#line 96
      goto __Cont;
    }
    {
#line 97
    tmp = box_overlap(b, & (markers + i)->txt);
#line 97
    total_overlap += tmp;
#line 98
    tmp___0 = box_overlap(b, & (markers + i)->dot);
#line 98
    total_overlap += tmp___0;
    }
    __Cont: /* CIL Label */ 
#line 94
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 100
  return (total_overlap);
}
}
#line 103 "/home/june/repo/benchmarks/collector/temp/ircmarkers-0.14/overlap.c"
static int border_overlap(struct box *m ) 
{ 
  int ordinate_overhang ;
  int abscissa_overhang ;
  int tmp ;
  int tmp___0 ;

  {
#line 108
  if (image_width - (unsigned int )m->right < 0U) {
#line 108
    ordinate_overhang = (int )(image_width - (unsigned int )m->right);
  } else {
#line 108
    if (0 < m->left) {
#line 108
      tmp = 0;
    } else {
#line 108
      tmp = m->left;
    }
#line 108
    ordinate_overhang = - tmp;
  }
#line 109
  if (image_height - (unsigned int )m->bottom < 0U) {
#line 109
    abscissa_overhang = (int )(image_height - (unsigned int )m->bottom);
  } else {
#line 109
    if (0 < m->top) {
#line 109
      tmp___0 = 0;
    } else {
#line 109
      tmp___0 = m->top;
    }
#line 109
    abscissa_overhang = - tmp___0;
  }
#line 110
  return ((ordinate_overhang * m->width + abscissa_overhang * m->height) + ordinate_overhang * abscissa_overhang);
}
}
#line 114 "/home/june/repo/benchmarks/collector/temp/ircmarkers-0.14/overlap.c"
void align(struct box *b , struct marker *m , int a ) 
{ 


  {
  {
#line 118
  if (a == 0) {
#line 118
    goto case_0;
  }
#line 122
  if (a == 1) {
#line 122
    goto case_1;
  }
#line 126
  if (a == 2) {
#line 126
    goto case_2;
  }
#line 130
  if (a == 3) {
#line 130
    goto case_3;
  }
#line 134
  if (a == 4) {
#line 134
    goto case_4;
  }
#line 138
  goto switch_default;
  case_0: /* CIL Label */ 
#line 119
  b->left = (int )((m->x + (unsigned int )offset) + (unsigned int )(m->dot.width / 2));
#line 120
  b->top = (int )(m->y - (unsigned int )(m->txt.height / 2));
#line 121
  goto switch_break;
  case_1: /* CIL Label */ 
#line 123
  b->left = (int )(((m->x - (unsigned int )offset) - (unsigned int )m->txt.width) - (unsigned int )(m->dot.width / 2));
#line 124
  b->top = (int )(m->y - (unsigned int )(m->txt.height / 2));
#line 125
  goto switch_break;
  case_2: /* CIL Label */ 
#line 127
  b->left = (int )(m->x - (unsigned int )(m->txt.width / 2));
#line 128
  b->top = (int )(((m->y - (unsigned int )offset) - (unsigned int )m->txt.height) - (unsigned int )(m->dot.height / 2));
#line 129
  goto switch_break;
  case_3: /* CIL Label */ 
#line 131
  b->left = (int )(m->x - (unsigned int )(m->txt.width / 2));
#line 132
  b->top = (int )((m->y + (unsigned int )offset) + (unsigned int )(m->dot.height / 2));
#line 133
  goto switch_break;
  case_4: /* CIL Label */ 
#line 135
  b->left = (int )(m->x - (unsigned int )(m->txt.width / 2));
#line 136
  b->top = (int )(m->y - (unsigned int )(m->txt.height / 2));
#line 137
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 139
  __assert_fail("0", "/home/june/repo/benchmarks/collector/temp/ircmarkers-0.14/overlap.c",
                139U, "align");
  }
  switch_break: /* CIL Label */ ;
  }
#line 142
  b->width = m->txt.width;
#line 143
  b->height = m->txt.height;
#line 145
  b->right = b->left + b->width;
#line 146
  b->bottom = b->top + b->height;
#line 147
  return;
}
}
#line 149 "/home/june/repo/benchmarks/collector/temp/ircmarkers-0.14/overlap.c"
static void correctOverlap(void) 
{ 
  int i ;
  struct box b[5] ;
  int max_overlap ;
  int a ;
  int total_overlap ;
  int tmp ;
  int tmp___0 ;

  {
#line 154
  i = 0;
  {
#line 154
  while (1) {
    while_continue: /* CIL Label */ ;
#line 154
    if (! (i < nb_markers)) {
#line 154
      goto while_break;
    }
#line 157
    max_overlap = 0;
#line 157
    a = 0;
#line 162
    a = 0;
    {
#line 162
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 162
      if (! (a <= 4)) {
#line 162
        goto while_break___0;
      }
      {
#line 164
      align(b + a, markers + i, a);
#line 165
      tmp = border_overlap(b + a);
#line 165
      tmp___0 = overlap((unsigned int )i, b + a);
#line 165
      total_overlap = tmp + tmp___0;
      }
#line 169
      if (a == 0) {
#line 170
        (markers + i)->alignment = a;
#line 171
        max_overlap = total_overlap;
      } else
#line 169
      if (total_overlap < max_overlap) {
#line 170
        (markers + i)->alignment = a;
#line 171
        max_overlap = total_overlap;
      }
#line 173
      if (total_overlap == 0) {
#line 174
        goto while_break___0;
      }
#line 162
      a ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 177
    (markers + i)->txt = b[(markers + i)->alignment];
#line 154
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 179
  return;
}
}
#line 181 "/home/june/repo/benchmarks/collector/temp/ircmarkers-0.14/overlap.c"
int main(int argc , char **argv ) 
{ 
  int i ;
  int alloc_markers ;
  int tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  void *nm ;
  int tmp___2 ;

  {
#line 184
  i = 0;
#line 185
  alloc_markers = 4;
#line 188
  if (argc != 4) {
    {
#line 190
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"invalid number of args\n");
    }
#line 191
    return (1);
  }
  {
#line 194
  nb_markers = 0;
#line 195
  tmp = atoi((char const   *)*(argv + 1));
#line 195
  image_width = (unsigned int )tmp;
#line 196
  tmp___0 = atoi((char const   *)*(argv + 2));
#line 196
  image_height = (unsigned int )tmp___0;
#line 197
  offset = atoi((char const   *)*(argv + 3));
#line 198
  tmp___1 = malloc((unsigned long )alloc_markers * sizeof(struct marker ));
#line 198
  markers = (struct marker *)tmp___1;
  }
#line 199
  if (! markers) {
    {
#line 199
    __assert_fail("markers", "/home/june/repo/benchmarks/collector/temp/ircmarkers-0.14/overlap.c",
                  199U, "main");
    }
  }
#line 202
  nb_markers = 0;
  {
#line 202
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 202
    tmp___2 = feof(stdin);
    }
#line 202
    if (tmp___2) {
#line 202
      goto while_break;
    }
#line 203
    if (nb_markers >= alloc_markers) {
      {
#line 205
      alloc_markers <<= 2;
#line 206
      nm = realloc((void *)markers, (unsigned long )alloc_markers * sizeof(struct marker ));
      }
#line 207
      if (! nm) {
        {
#line 207
        __assert_fail("nm", "/home/june/repo/benchmarks/collector/temp/ircmarkers-0.14/overlap.c",
                      207U, "main");
        }
      }
#line 208
      markers = (struct marker *)nm;
    }
    {
#line 210
    i = scanf((char const   */* __restrict  */)"%u\t%u\t%u\t%d\t%d\t%d\t%d\t%d\t%d\t%d\t%d\t%d\t%d\t%d\t%d\n",
              & (markers + nb_markers)->id, & (markers + nb_markers)->x, & (markers + nb_markers)->y,
              & (markers + nb_markers)->dot.left, & (markers + nb_markers)->dot.right,
              & (markers + nb_markers)->dot.top, & (markers + nb_markers)->dot.bottom,
              & (markers + nb_markers)->dot.width, & (markers + nb_markers)->dot.height,
              & (markers + nb_markers)->txt.left, & (markers + nb_markers)->txt.right,
              & (markers + nb_markers)->txt.top, & (markers + nb_markers)->txt.bottom,
              & (markers + nb_markers)->txt.width, & (markers + nb_markers)->txt.height);
    }
#line 226
    if (i == -1) {
#line 226
      goto __Cont;
    }
#line 227
    if (i != 15) {
      {
#line 227
      __assert_fail("0", "/home/june/repo/benchmarks/collector/temp/ircmarkers-0.14/overlap.c",
                    227U, "main");
      }
    }
    __Cont: /* CIL Label */ 
#line 202
    nb_markers ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 234
  correctOverlap();
#line 237
  i = 0;
  }
  {
#line 237
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 237
    if (! (i < nb_markers)) {
#line 237
      goto while_break___0;
    }
    {
#line 238
    printf((char const   */* __restrict  */)"%u\t%+d\t%+d\n", (markers + i)->id, (markers + i)->txt.left,
           (markers + i)->txt.bottom);
#line 237
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 250
  return (0);
}
}
