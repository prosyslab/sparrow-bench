/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 35 "/home/wheatley/newnew/temp/lbdb-0.38ubuntu1/rfc822.h"
struct address_t {
   char *personal ;
   char *mailbox ;
   int group ;
   struct address_t *next ;
};
#line 35 "/home/wheatley/newnew/temp/lbdb-0.38ubuntu1/rfc822.h"
typedef struct address_t ADDRESS;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 75 "/usr/include/time.h"
typedef __time_t time_t;
#line 133 "/usr/include/time.h"
struct tm {
   int tm_sec ;
   int tm_min ;
   int tm_hour ;
   int tm_mday ;
   int tm_mon ;
   int tm_year ;
   int tm_wday ;
   int tm_yday ;
   int tm_isdst ;
   long tm_gmtoff ;
   char const   *tm_zone ;
};
#line 36 "/home/wheatley/newnew/temp/lbdb-0.38ubuntu1/fetchaddr.c"
struct header {
   char *tag ;
   char *value ;
   size_t len ;
   size_t taglen ;
};
#line 29 "/usr/include/iconv.h"
typedef void *iconv_t;
#line 124 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __dev_t;
#line 125 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uid_t;
#line 126 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __gid_t;
#line 127 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __ino_t;
#line 129 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __mode_t;
#line 130 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __nlink_t;
#line 133 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __pid_t;
#line 153 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blksize_t;
#line 158 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blkcnt_t;
#line 172 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __ssize_t;
#line 175 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __syscall_slong_t;
#line 102 "/usr/include/stdio.h"
typedef __ssize_t ssize_t;
#line 120 "/usr/include/time.h"
struct timespec {
   __time_t tv_sec ;
   __syscall_slong_t tv_nsec ;
};
#line 46 "/usr/include/x86_64-linux-gnu/bits/stat.h"
struct stat {
   __dev_t st_dev ;
   __ino_t st_ino ;
   __nlink_t st_nlink ;
   __mode_t st_mode ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   int __pad0 ;
   __dev_t st_rdev ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   __syscall_slong_t __glibc_reserved[3] ;
};
#line 48 "/usr/include/x86_64-linux-gnu/sys/utsname.h"
struct utsname {
   char sysname[65] ;
   char nodename[65] ;
   char release[65] ;
   char version[65] ;
   char machine[65] ;
   char __domainname[65] ;
};
#line 132 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strncpy)(char * __restrict  __dest ,
                                                                                                  char const   * __restrict  __src ,
                                                                                                  size_t __n ) ;
#line 236
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strchr)(char const   *__s ,
                                                                                               int __c )  __attribute__((__pure__)) ;
#line 315
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strpbrk)(char const   *__s ,
                                                                                                  char const   *__accept )  __attribute__((__pure__)) ;
#line 399
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 79 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) unsigned short const   **( __attribute__((__leaf__)) __ctype_b_loc)(void)  __attribute__((__const__)) ;
#line 468 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) calloc)(size_t __nmemb ,
                                                                               size_t __size )  __attribute__((__malloc__)) ;
#line 364 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
#line 38 "/home/wheatley/newnew/temp/lbdb-0.38ubuntu1/helpers.h"
char *safe_strdup(char const   *s ) ;
#line 40
void *safe_malloc(unsigned int siz ) ;
#line 42
void safe_free(void *ptr ) ;
#line 47 "/home/wheatley/newnew/temp/lbdb-0.38ubuntu1/rfc822.h"
void rfc822_free_address(ADDRESS **p ) ;
#line 48
void rfc822_qualify(ADDRESS *addr , char const   *host ) ;
#line 49
ADDRESS *rfc822_parse_adrlist(ADDRESS *top , char const   *s ) ;
#line 50
ADDRESS *rfc822_cpy_adr(ADDRESS *addr ) ;
#line 51
ADDRESS *rfc822_cpy_adr_real(ADDRESS *addr ) ;
#line 52
ADDRESS *rfc822_append(ADDRESS **a , ADDRESS *b ) ;
#line 53
void rfc822_write_address(char *buf , size_t buflen , ADDRESS *addr ) ;
#line 56
void rfc822_cat(char *buf , size_t buflen , char const   *value , char const   *specials ) ;
#line 58
int RFC822Error ;
#line 59
char const   *RFC822Errors[6] ;
#line 29 "/home/wheatley/newnew/temp/lbdb-0.38ubuntu1/rfc822.c"
char const   RFC822Specials[14]  = 
#line 29 "/home/wheatley/newnew/temp/lbdb-0.38ubuntu1/rfc822.c"
  {      (char const   )'@',      (char const   )'.',      (char const   )',',      (char const   )':', 
        (char const   )';',      (char const   )'<',      (char const   )'>',      (char const   )'[', 
        (char const   )']',      (char const   )'\\',      (char const   )'\"',      (char const   )'(', 
        (char const   )')',      (char const   )'\000'};
#line 32 "/home/wheatley/newnew/temp/lbdb-0.38ubuntu1/rfc822.c"
int RFC822Error  =    0;
#line 35 "/home/wheatley/newnew/temp/lbdb-0.38ubuntu1/rfc822.c"
char const   *RFC822Errors[6]  = {      "out of memory",      "mismatched parenthesis",      "mismatched quotes",      "bad route in <>", 
        "bad address in <>",      "bad address spec"};
#line 44 "/home/wheatley/newnew/temp/lbdb-0.38ubuntu1/rfc822.c"
void rfc822_dequote_comment(char *s ) 
{ 
  char *w ;
  char *tmp ;

  {
#line 46
  w = s;
  {
#line 48
  while (1) {
    while_continue: /* CIL Label */ ;
#line 48
    if (! *s) {
#line 48
      goto while_break;
    }
#line 50
    if ((int )*s == 92) {
#line 52
      s ++;
#line 52
      if (! *s) {
#line 53
        goto while_break;
      }
#line 54
      tmp = w;
#line 54
      w ++;
#line 54
      *tmp = *s;
    } else
#line 56
    if ((int )*s != 34) {
#line 58
      if ((unsigned long )w != (unsigned long )s) {
#line 59
        *w = *s;
      }
#line 60
      w ++;
    }
#line 48
    s ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 63
  *w = (char)0;
#line 64
  return;
}
}
#line 66 "/home/wheatley/newnew/temp/lbdb-0.38ubuntu1/rfc822.c"
void rfc822_free_address(ADDRESS **p ) 
{ 
  ADDRESS *t ;

  {
  {
#line 70
  while (1) {
    while_continue: /* CIL Label */ ;
#line 70
    if (! *p) {
#line 70
      goto while_break;
    }
    {
#line 72
    t = *p;
#line 73
    *p = (*p)->next;
#line 77
    safe_free((void *)(& t->personal));
#line 78
    safe_free((void *)(& t->mailbox));
#line 79
    safe_free((void *)(& t));
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 81
  return;
}
}
#line 83 "/home/wheatley/newnew/temp/lbdb-0.38ubuntu1/rfc822.c"
static char const   *parse_comment(char const   *s , char *comment , size_t *commentlen ,
                                   size_t commentmax ) 
{ 
  int level ;
  size_t tmp ;

  {
#line 87
  level = 1;
  {
#line 89
  while (1) {
    while_continue: /* CIL Label */ ;
#line 89
    if (*s) {
#line 89
      if (! level) {
#line 89
        goto while_break;
      }
    } else {
#line 89
      goto while_break;
    }
#line 91
    if ((int const   )*s == 40) {
#line 92
      level ++;
    } else
#line 93
    if ((int const   )*s == 41) {
#line 95
      level --;
#line 95
      if (level == 0) {
#line 97
        s ++;
#line 98
        goto while_break;
      }
    } else
#line 101
    if ((int const   )*s == 92) {
#line 103
      s ++;
#line 103
      if (! *s) {
#line 104
        goto while_break;
      }
    }
#line 106
    if (*commentlen < commentmax) {
#line 107
      tmp = *commentlen;
#line 107
      (*commentlen) ++;
#line 107
      *(comment + tmp) = (char )*s;
    }
#line 108
    s ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 110
  if (level) {
#line 112
    RFC822Error = 2;
#line 113
    return ((char const   *)((void *)0));
  }
#line 115
  return (s);
}
}
#line 118 "/home/wheatley/newnew/temp/lbdb-0.38ubuntu1/rfc822.c"
static char const   *parse_quote(char const   *s , char *token , size_t *tokenlen ,
                                 size_t tokenmax ) 
{ 
  size_t tmp ;
  size_t tmp___0 ;

  {
#line 121
  if (*tokenlen < tokenmax) {
#line 122
    tmp = *tokenlen;
#line 122
    (*tokenlen) ++;
#line 122
    *(token + tmp) = (char )'\"';
  }
  {
#line 123
  while (1) {
    while_continue: /* CIL Label */ ;
#line 123
    if (! *s) {
#line 123
      goto while_break;
    }
#line 125
    if (*tokenlen < tokenmax) {
#line 126
      tmp___0 = *tokenlen;
#line 126
      (*tokenlen) ++;
#line 126
      *(token + tmp___0) = (char )*s;
    }
#line 127
    if ((int const   )*s == 34) {
#line 128
      return (s + 1);
    }
#line 129
    if ((int const   )*s == 92) {
#line 131
      s ++;
#line 131
      if (! *s) {
#line 132
        goto while_break;
      }
    }
#line 134
    s ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 136
  RFC822Error = 3;
#line 137
  return ((char const   *)((void *)0));
}
}
#line 140 "/home/wheatley/newnew/temp/lbdb-0.38ubuntu1/rfc822.c"
static char const   *next_token(char const   *s , char *token , size_t *tokenlen ,
                                size_t tokenmax ) 
{ 
  char const   *tmp ;
  char const   *tmp___0 ;
  size_t tmp___1 ;
  char *tmp___2 ;
  unsigned short const   **tmp___3 ;
  char *tmp___4 ;
  size_t tmp___5 ;

  {
#line 143
  if ((int const   )*s == 40) {
    {
#line 144
    tmp = parse_comment(s + 1, token, tokenlen, tokenmax);
    }
#line 144
    return (tmp);
  }
#line 145
  if ((int const   )*s == 34) {
    {
#line 146
    tmp___0 = parse_quote(s + 1, token, tokenlen, tokenmax);
    }
#line 146
    return (tmp___0);
  }
  {
#line 147
  tmp___2 = strchr(RFC822Specials, (int )*s);
  }
#line 147
  if (tmp___2) {
#line 149
    if (*tokenlen < tokenmax) {
#line 150
      tmp___1 = *tokenlen;
#line 150
      (*tokenlen) ++;
#line 150
      *(token + tmp___1) = (char )*s;
    }
#line 151
    return (s + 1);
  }
  {
#line 153
  while (1) {
    while_continue: /* CIL Label */ ;
#line 153
    if (! *s) {
#line 153
      goto while_break;
    }
    {
#line 155
    tmp___3 = __ctype_b_loc();
    }
#line 155
    if ((int const   )*(*tmp___3 + (int )*s) & 8192) {
#line 156
      goto while_break;
    } else {
      {
#line 155
      tmp___4 = strchr(RFC822Specials, (int )*s);
      }
#line 155
      if (tmp___4) {
#line 156
        goto while_break;
      }
    }
#line 157
    if (*tokenlen < tokenmax) {
#line 158
      tmp___5 = *tokenlen;
#line 158
      (*tokenlen) ++;
#line 158
      *(token + tmp___5) = (char )*s;
    }
#line 159
    s ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 161
  return (s);
}
}
#line 164 "/home/wheatley/newnew/temp/lbdb-0.38ubuntu1/rfc822.c"
static char const   *parse_mailboxdomain(char const   *s , char const   *nonspecial ,
                                         char *mailbox , size_t *mailboxlen , size_t mailboxmax ,
                                         char *comment , size_t *commentlen , size_t commentmax ) 
{ 
  char const   *ps ;
  unsigned short const   **tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  size_t tmp___2 ;

  {
  {
#line 171
  while (1) {
    while_continue: /* CIL Label */ ;
#line 171
    if (! *s) {
#line 171
      goto while_break;
    }
    {
#line 173
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 173
      if (*s) {
        {
#line 173
        tmp = __ctype_b_loc();
        }
#line 173
        if (! ((int const   )*(*tmp + (int )((unsigned char )*s)) & 8192)) {
#line 173
          goto while_break___0;
        }
      } else {
#line 173
        goto while_break___0;
      }
#line 173
      s ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 174
    tmp___0 = strchr(nonspecial, (int )*s);
    }
#line 174
    if ((unsigned long )tmp___0 == (unsigned long )((void *)0)) {
      {
#line 174
      tmp___1 = strchr(RFC822Specials, (int )*s);
      }
#line 174
      if (tmp___1) {
#line 175
        return (s);
      }
    }
#line 177
    if ((int const   )*s == 40) {
#line 179
      if (*commentlen) {
#line 179
        if (*commentlen < commentmax) {
#line 180
          tmp___2 = *commentlen;
#line 180
          (*commentlen) ++;
#line 180
          *(comment + tmp___2) = (char )' ';
        }
      }
      {
#line 181
      ps = next_token(s, comment, commentlen, commentmax);
      }
    } else {
      {
#line 184
      ps = next_token(s, mailbox, mailboxlen, mailboxmax);
      }
    }
#line 185
    if (! ps) {
#line 186
      return ((char const   *)((void *)0));
    }
#line 187
    s = ps;
  }
  while_break: /* CIL Label */ ;
  }
#line 190
  return (s);
}
}
#line 193 "/home/wheatley/newnew/temp/lbdb-0.38ubuntu1/rfc822.c"
static char const   *parse_address(char const   *s , char *token , size_t *tokenlen ,
                                   size_t tokenmax , char *comment , size_t *commentlen ,
                                   size_t commentmax , ADDRESS *addr ) 
{ 
  size_t tmp ;

  {
  {
#line 199
  s = parse_mailboxdomain(s, ".\"(\\", token, tokenlen, tokenmax, comment, commentlen,
                          commentmax);
  }
#line 202
  if (! s) {
#line 203
    return ((char const   *)((void *)0));
  }
#line 205
  if ((int const   )*s == 64) {
#line 207
    if (*tokenlen < tokenmax) {
#line 208
      tmp = *tokenlen;
#line 208
      (*tokenlen) ++;
#line 208
      *(token + tmp) = (char )'@';
    }
    {
#line 209
    s = parse_mailboxdomain(s + 1, ".([]\\", token, tokenlen, tokenmax, comment, commentlen,
                            commentmax);
    }
#line 212
    if (! s) {
#line 213
      return ((char const   *)((void *)0));
    }
  }
  {
#line 216
  *(token + *tokenlen) = (char)0;
#line 217
  addr->mailbox = safe_strdup((char const   *)token);
  }
#line 219
  if (*commentlen) {
#line 219
    if (! addr->personal) {
      {
#line 221
      *(comment + *commentlen) = (char)0;
#line 222
      addr->personal = safe_strdup((char const   *)comment);
      }
    }
  }
#line 225
  return (s);
}
}
#line 228 "/home/wheatley/newnew/temp/lbdb-0.38ubuntu1/rfc822.c"
static char const   *parse_route_addr(char const   *s , char *comment , size_t *commentlen ,
                                      size_t commentmax , ADDRESS *addr ) 
{ 
  char token[256] ;
  size_t tokenlen ;
  unsigned short const   **tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;

  {
#line 234
  tokenlen = (size_t )0;
  {
#line 236
  while (1) {
    while_continue: /* CIL Label */ ;
#line 236
    if (*s) {
      {
#line 236
      tmp = __ctype_b_loc();
      }
#line 236
      if (! ((int const   )*(*tmp + (int )((unsigned char )*s)) & 8192)) {
#line 236
        goto while_break;
      }
    } else {
#line 236
      goto while_break;
    }
#line 236
    s ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 239
  if ((int const   )*s == 64) {
    {
#line 241
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 241
      if (s) {
#line 241
        if (! ((int const   )*s == 64)) {
#line 241
          goto while_break___0;
        }
      } else {
#line 241
        goto while_break___0;
      }
#line 243
      if (tokenlen < sizeof(token) - 1UL) {
#line 244
        tmp___0 = tokenlen;
#line 244
        tokenlen ++;
#line 244
        token[tmp___0] = (char )'@';
      }
      {
#line 245
      s = parse_mailboxdomain(s + 1, ".\\[](", token, & tokenlen, sizeof(token) - 1UL,
                              comment, commentlen, commentmax);
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 249
    if (! s) {
#line 251
      RFC822Error = 4;
#line 252
      return ((char const   *)((void *)0));
    } else
#line 249
    if ((int const   )*s != 58) {
#line 251
      RFC822Error = 4;
#line 252
      return ((char const   *)((void *)0));
    }
#line 255
    if (tokenlen < sizeof(token) - 1UL) {
#line 256
      tmp___1 = tokenlen;
#line 256
      tokenlen ++;
#line 256
      token[tmp___1] = (char )':';
    }
#line 257
    s ++;
  }
  {
#line 260
  s = parse_address(s, token, & tokenlen, sizeof(token) - 1UL, comment, commentlen,
                    commentmax, addr);
  }
#line 260
  if ((unsigned long )s == (unsigned long )((void *)0)) {
#line 261
    return ((char const   *)((void *)0));
  }
#line 263
  if ((int const   )*s != 62) {
#line 265
    RFC822Error = 5;
#line 266
    return ((char const   *)((void *)0));
  } else
#line 263
  if (! addr->mailbox) {
#line 265
    RFC822Error = 5;
#line 266
    return ((char const   *)((void *)0));
  }
#line 269
  s ++;
#line 270
  return (s);
}
}
#line 273 "/home/wheatley/newnew/temp/lbdb-0.38ubuntu1/rfc822.c"
static char const   *parse_addr_spec(char const   *s , char *comment , size_t *commentlen ,
                                     size_t commentmax , ADDRESS *addr ) 
{ 
  char token[256] ;
  size_t tokenlen ;

  {
  {
#line 279
  tokenlen = (size_t )0;
#line 281
  s = parse_address(s, token, & tokenlen, sizeof(token) - 1UL, comment, commentlen,
                    commentmax, addr);
  }
#line 282
  if (s) {
#line 282
    if (*s) {
#line 282
      if ((int const   )*s != 44) {
#line 282
        if ((int const   )*s != 59) {
#line 284
          RFC822Error = 6;
#line 285
          return ((char const   *)((void *)0));
        }
      }
    }
  }
#line 287
  return (s);
}
}
#line 290 "/home/wheatley/newnew/temp/lbdb-0.38ubuntu1/rfc822.c"
static void add_addrspec(ADDRESS **top , ADDRESS **last , char const   *phrase , char *comment ,
                         size_t *commentlen , size_t commentmax ) 
{ 
  ADDRESS *cur ;
  void *tmp ;
  char const   *tmp___0 ;

  {
  {
#line 294
  tmp = calloc((size_t )1, sizeof(ADDRESS ));
#line 294
  cur = (ADDRESS *)tmp;
#line 296
  tmp___0 = parse_addr_spec(phrase, comment, commentlen, commentmax, cur);
  }
#line 296
  if ((unsigned long )tmp___0 == (unsigned long )((void *)0)) {
#line 297
    return;
  }
#line 299
  if (*last) {
#line 300
    (*last)->next = cur;
  } else {
#line 302
    *top = cur;
  }
#line 303
  *last = cur;
#line 304
  return;
}
}
#line 306 "/home/wheatley/newnew/temp/lbdb-0.38ubuntu1/rfc822.c"
ADDRESS *rfc822_parse_adrlist(ADDRESS *top , char const   *s ) 
{ 
  char const   *begin ;
  char const   *ps ;
  char comment[256] ;
  char phrase[256] ;
  size_t phraselen ;
  size_t commentlen ;
  ADDRESS *cur ;
  ADDRESS *last ;
  unsigned short const   **tmp ;
  unsigned short const   **tmp___0 ;
  size_t tmp___1 ;
  void *tmp___2 ;
  unsigned short const   **tmp___3 ;
  void *tmp___4 ;
  unsigned short const   **tmp___5 ;
  void *tmp___6 ;
  size_t tmp___7 ;
  unsigned short const   **tmp___8 ;

  {
#line 310
  phraselen = (size_t )0;
#line 310
  commentlen = (size_t )0;
#line 311
  last = (ADDRESS *)((void *)0);
#line 313
  RFC822Error = 0;
#line 315
  last = top;
  {
#line 316
  while (1) {
    while_continue: /* CIL Label */ ;
#line 316
    if (last) {
#line 316
      if (! last->next) {
#line 316
        goto while_break;
      }
    } else {
#line 316
      goto while_break;
    }
#line 317
    last = last->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 319
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 319
    if (*s) {
      {
#line 319
      tmp = __ctype_b_loc();
      }
#line 319
      if (! ((int const   )*(*tmp + (int )((unsigned char )*s)) & 8192)) {
#line 319
        goto while_break___0;
      }
    } else {
#line 319
      goto while_break___0;
    }
#line 319
    s ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 320
  begin = s;
  {
#line 321
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 321
    if (! *s) {
#line 321
      goto while_break___1;
    }
#line 323
    if ((int const   )*s == 44) {
#line 325
      if (phraselen) {
        {
#line 327
        phrase[phraselen] = (char)0;
#line 328
        add_addrspec(& top, & last, (char const   *)(phrase), comment, & commentlen,
                     sizeof(comment) - 1UL);
        }
      } else
#line 330
      if (commentlen) {
#line 330
        if (last) {
#line 330
          if (! last->personal) {
            {
#line 332
            comment[commentlen] = (char)0;
#line 333
            last->personal = safe_strdup((char const   *)(comment));
            }
          }
        }
      }
#line 340
      commentlen = (size_t )0;
#line 341
      phraselen = (size_t )0;
#line 342
      s ++;
#line 343
      begin = s;
      {
#line 344
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 344
        if (*begin) {
          {
#line 344
          tmp___0 = __ctype_b_loc();
          }
#line 344
          if (! ((int const   )*(*tmp___0 + (int )((unsigned char )*begin)) & 8192)) {
#line 344
            goto while_break___2;
          }
        } else {
#line 344
          goto while_break___2;
        }
#line 344
        begin ++;
      }
      while_break___2: /* CIL Label */ ;
      }
    } else
#line 346
    if ((int const   )*s == 40) {
#line 348
      if (commentlen) {
#line 348
        if (commentlen < sizeof(comment) - 1UL) {
#line 349
          tmp___1 = commentlen;
#line 349
          commentlen ++;
#line 349
          comment[tmp___1] = (char )' ';
        }
      }
      {
#line 350
      ps = next_token(s, comment, & commentlen, sizeof(comment) - 1UL);
      }
#line 350
      if ((unsigned long )ps == (unsigned long )((void *)0)) {
        {
#line 352
        rfc822_free_address(& top);
        }
#line 353
        return ((ADDRESS *)((void *)0));
      }
#line 355
      s = ps;
    } else
#line 357
    if ((int const   )*s == 58) {
      {
#line 359
      tmp___2 = calloc((size_t )1, sizeof(ADDRESS ));
#line 359
      cur = (ADDRESS *)tmp___2;
#line 360
      phrase[phraselen] = (char)0;
#line 361
      cur->mailbox = safe_strdup((char const   *)(phrase));
#line 362
      cur->group = 1;
      }
#line 364
      if (last) {
#line 365
        last->next = cur;
      } else {
#line 367
        top = cur;
      }
#line 368
      last = cur;
#line 374
      phraselen = (size_t )0;
#line 375
      commentlen = (size_t )0;
#line 376
      s ++;
#line 377
      begin = s;
      {
#line 378
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 378
        if (*begin) {
          {
#line 378
          tmp___3 = __ctype_b_loc();
          }
#line 378
          if (! ((int const   )*(*tmp___3 + (int )((unsigned char )*begin)) & 8192)) {
#line 378
            goto while_break___3;
          }
        } else {
#line 378
          goto while_break___3;
        }
#line 378
        begin ++;
      }
      while_break___3: /* CIL Label */ ;
      }
    } else
#line 380
    if ((int const   )*s == 59) {
#line 382
      if (phraselen) {
        {
#line 384
        phrase[phraselen] = (char)0;
#line 385
        add_addrspec(& top, & last, (char const   *)(phrase), comment, & commentlen,
                     sizeof(comment) - 1UL);
        }
      } else
#line 387
      if (commentlen) {
#line 387
        if (! last->personal) {
          {
#line 389
          comment[commentlen] = (char)0;
#line 390
          last->personal = safe_strdup((char const   *)(comment));
          }
        }
      }
      {
#line 398
      tmp___4 = calloc((size_t )1, sizeof(ADDRESS ));
#line 398
      cur = (ADDRESS *)tmp___4;
      }
#line 399
      if (last) {
#line 401
        last->next = cur;
#line 402
        last = cur;
      }
#line 405
      phraselen = (size_t )0;
#line 406
      commentlen = (size_t )0;
#line 407
      s ++;
#line 408
      begin = s;
      {
#line 409
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 409
        if (*begin) {
          {
#line 409
          tmp___5 = __ctype_b_loc();
          }
#line 409
          if (! ((int const   )*(*tmp___5 + (int )((unsigned char )*begin)) & 8192)) {
#line 409
            goto while_break___4;
          }
        } else {
#line 409
          goto while_break___4;
        }
#line 409
        begin ++;
      }
      while_break___4: /* CIL Label */ ;
      }
    } else
#line 411
    if ((int const   )*s == 60) {
      {
#line 413
      phrase[phraselen] = (char)0;
#line 414
      tmp___6 = calloc((size_t )1, sizeof(ADDRESS ));
#line 414
      cur = (ADDRESS *)tmp___6;
      }
#line 415
      if (phraselen) {
#line 417
        if (cur->personal) {
          {
#line 418
          safe_free((void *)(& cur->personal));
          }
        }
        {
#line 420
        rfc822_dequote_comment(phrase);
#line 421
        cur->personal = safe_strdup((char const   *)(phrase));
        }
      }
      {
#line 423
      ps = parse_route_addr(s + 1, comment, & commentlen, sizeof(comment) - 1UL, cur);
      }
#line 423
      if ((unsigned long )ps == (unsigned long )((void *)0)) {
        {
#line 425
        rfc822_free_address(& top);
#line 426
        rfc822_free_address(& cur);
        }
#line 427
        return ((ADDRESS *)((void *)0));
      }
#line 430
      if (last) {
#line 431
        last->next = cur;
      } else {
#line 433
        top = cur;
      }
#line 434
      last = cur;
#line 436
      phraselen = (size_t )0;
#line 437
      commentlen = (size_t )0;
#line 438
      s = ps;
    } else {
#line 442
      if (phraselen) {
#line 442
        if (phraselen < sizeof(phrase) - 1UL) {
#line 443
          tmp___7 = phraselen;
#line 443
          phraselen ++;
#line 443
          phrase[tmp___7] = (char )' ';
        }
      }
      {
#line 444
      ps = next_token(s, phrase, & phraselen, sizeof(phrase) - 1UL);
      }
#line 444
      if ((unsigned long )ps == (unsigned long )((void *)0)) {
        {
#line 446
        rfc822_free_address(& top);
        }
#line 447
        return ((ADDRESS *)((void *)0));
      }
#line 449
      s = ps;
    }
    {
#line 451
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 451
      if (*s) {
        {
#line 451
        tmp___8 = __ctype_b_loc();
        }
#line 451
        if (! ((int const   )*(*tmp___8 + (int )((unsigned char )*s)) & 8192)) {
#line 451
          goto while_break___5;
        }
      } else {
#line 451
        goto while_break___5;
      }
#line 451
      s ++;
    }
    while_break___5: /* CIL Label */ ;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 454
  if (phraselen) {
    {
#line 456
    phrase[phraselen] = (char)0;
#line 457
    comment[commentlen] = (char)0;
#line 458
    add_addrspec(& top, & last, (char const   *)(phrase), comment, & commentlen, sizeof(comment) - 1UL);
    }
  } else
#line 460
  if (commentlen) {
#line 460
    if (last) {
#line 460
      if (! last->personal) {
        {
#line 462
        comment[commentlen] = (char)0;
#line 463
        last->personal = safe_strdup((char const   *)(comment));
        }
      }
    }
  }
#line 470
  return (top);
}
}
#line 473 "/home/wheatley/newnew/temp/lbdb-0.38ubuntu1/rfc822.c"
void rfc822_qualify(ADDRESS *addr , char const   *host ) 
{ 
  char *p ;
  size_t tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;
  char *tmp___2 ;

  {
  {
#line 477
  while (1) {
    while_continue: /* CIL Label */ ;
#line 477
    if (! addr) {
#line 477
      goto while_break;
    }
#line 478
    if (! addr->group) {
#line 478
      if (addr->mailbox) {
        {
#line 478
        tmp___2 = strchr((char const   *)addr->mailbox, '@');
        }
#line 478
        if ((unsigned long )tmp___2 == (unsigned long )((void *)0)) {
          {
#line 480
          tmp = strlen((char const   *)addr->mailbox);
#line 480
          tmp___0 = strlen(host);
#line 480
          tmp___1 = safe_malloc((unsigned int )((tmp + tmp___0) + 2UL));
#line 480
          p = (char *)tmp___1;
#line 481
          sprintf((char */* __restrict  */)p, (char const   */* __restrict  */)"%s@%s",
                  addr->mailbox, host);
#line 482
          safe_free((void *)(& addr->mailbox));
#line 483
          addr->mailbox = p;
          }
        }
      }
    }
#line 477
    addr = addr->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 485
  return;
}
}
#line 487 "/home/wheatley/newnew/temp/lbdb-0.38ubuntu1/rfc822.c"
void rfc822_cat(char *buf , size_t buflen , char const   *value , char const   *specials ) 
{ 
  char tmp[256] ;
  char *pc ;
  size_t tmplen ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;

  {
  {
#line 490
  tmp___4 = strpbrk(value, specials);
  }
#line 490
  if (tmp___4) {
#line 492
    pc = tmp;
#line 493
    tmplen = sizeof(tmp) - 3UL;
#line 495
    tmp___0 = pc;
#line 495
    pc ++;
#line 495
    *tmp___0 = (char )'\"';
    {
#line 496
    while (1) {
      while_continue: /* CIL Label */ ;
#line 496
      if (*value) {
#line 496
        if (! (tmplen > 1UL)) {
#line 496
          goto while_break;
        }
      } else {
#line 496
        goto while_break;
      }
#line 498
      if ((int const   )*value == 92) {
#line 500
        tmp___1 = pc;
#line 500
        pc ++;
#line 500
        *tmp___1 = (char )'\\';
#line 501
        tmplen --;
      } else
#line 498
      if ((int const   )*value == 34) {
#line 500
        tmp___1 = pc;
#line 500
        pc ++;
#line 500
        *tmp___1 = (char )'\\';
#line 501
        tmplen --;
      }
#line 503
      tmp___2 = pc;
#line 503
      pc ++;
#line 503
      *tmp___2 = (char )*value;
#line 504
      tmplen --;
#line 496
      value ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 506
    tmp___3 = pc;
#line 506
    pc ++;
#line 506
    *tmp___3 = (char )'\"';
#line 507
    *pc = (char)0;
#line 508
    strncpy((char */* __restrict  */)buf, (char const   */* __restrict  */)(tmp),
            buflen);
#line 508
    *((buf + buflen) - 1) = (char)0;
    }
  } else {
    {
#line 511
    strncpy((char */* __restrict  */)buf, (char const   */* __restrict  */)value,
            buflen);
#line 511
    *((buf + buflen) - 1) = (char)0;
    }
  }
#line 512
  return;
}
}
#line 514 "/home/wheatley/newnew/temp/lbdb-0.38ubuntu1/rfc822.c"
void rfc822_write_address_single(char *buf , size_t buflen , ADDRESS *addr ) 
{ 
  size_t len ;
  char *pbuf ;
  char *pc ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;

  {
#line 517
  pbuf = buf;
#line 520
  if (! addr) {
#line 521
    return;
  }
#line 523
  buflen --;
#line 546
  if (addr->personal) {
    {
#line 548
    tmp___3 = strpbrk((char const   *)addr->personal, RFC822Specials);
    }
#line 548
    if (tmp___3) {
#line 550
      if (! buflen) {
#line 551
        goto done;
      }
#line 552
      tmp = pbuf;
#line 552
      pbuf ++;
#line 552
      *tmp = (char )'\"';
#line 553
      buflen --;
#line 554
      pc = addr->personal;
      {
#line 554
      while (1) {
        while_continue: /* CIL Label */ ;
#line 554
        if (*pc) {
#line 554
          if (! (buflen > 0UL)) {
#line 554
            goto while_break;
          }
        } else {
#line 554
          goto while_break;
        }
#line 556
        if ((int )*pc == 34) {
#line 556
          goto _L;
        } else
#line 556
        if ((int )*pc == 92) {
          _L: /* CIL Label */ 
#line 558
          if (! buflen) {
#line 559
            goto done;
          }
#line 560
          tmp___0 = pbuf;
#line 560
          pbuf ++;
#line 560
          *tmp___0 = (char )'\\';
#line 561
          buflen --;
        }
#line 563
        if (! buflen) {
#line 564
          goto done;
        }
#line 565
        tmp___1 = pbuf;
#line 565
        pbuf ++;
#line 565
        *tmp___1 = *pc;
#line 566
        buflen --;
#line 554
        pc ++;
      }
      while_break: /* CIL Label */ ;
      }
#line 568
      if (! buflen) {
#line 569
        goto done;
      }
#line 570
      tmp___2 = pbuf;
#line 570
      pbuf ++;
#line 570
      *tmp___2 = (char )'\"';
#line 571
      buflen --;
    } else {
#line 575
      if (! buflen) {
#line 576
        goto done;
      }
      {
#line 577
      strncpy((char */* __restrict  */)pbuf, (char const   */* __restrict  */)addr->personal,
              buflen);
#line 577
      *((pbuf + buflen) - 1) = (char)0;
#line 578
      len = strlen((char const   *)pbuf);
#line 579
      pbuf += len;
#line 580
      buflen -= len;
      }
    }
#line 583
    if (! buflen) {
#line 584
      goto done;
    }
#line 585
    tmp___4 = pbuf;
#line 585
    pbuf ++;
#line 585
    *tmp___4 = (char )' ';
#line 586
    buflen --;
  }
#line 589
  if (addr->personal) {
#line 589
    goto _L___0;
  } else
#line 589
  if (addr->mailbox) {
#line 589
    if ((int )*(addr->mailbox) == 64) {
      _L___0: /* CIL Label */ 
#line 591
      if (! buflen) {
#line 592
        goto done;
      }
#line 593
      tmp___5 = pbuf;
#line 593
      pbuf ++;
#line 593
      *tmp___5 = (char )'<';
#line 594
      buflen --;
    }
  }
#line 597
  if (addr->mailbox) {
#line 599
    if (! buflen) {
#line 600
      goto done;
    }
    {
#line 601
    strncpy((char */* __restrict  */)pbuf, (char const   */* __restrict  */)addr->mailbox,
            buflen);
#line 601
    *((pbuf + buflen) - 1) = (char)0;
#line 602
    len = strlen((char const   *)pbuf);
#line 603
    pbuf += len;
#line 604
    buflen -= len;
    }
#line 606
    if (addr->personal) {
#line 606
      goto _L___1;
    } else
#line 606
    if (addr->mailbox) {
#line 606
      if ((int )*(addr->mailbox) == 64) {
        _L___1: /* CIL Label */ 
#line 608
        if (! buflen) {
#line 609
          goto done;
        }
#line 610
        tmp___6 = pbuf;
#line 610
        pbuf ++;
#line 610
        *tmp___6 = (char )'>';
#line 611
        buflen --;
      }
    }
#line 614
    if (addr->group) {
#line 616
      if (! buflen) {
#line 617
        goto done;
      }
#line 618
      tmp___7 = pbuf;
#line 618
      pbuf ++;
#line 618
      *tmp___7 = (char )':';
#line 619
      buflen --;
#line 620
      if (! buflen) {
#line 621
        goto done;
      }
#line 622
      tmp___8 = pbuf;
#line 622
      pbuf ++;
#line 622
      *tmp___8 = (char )' ';
#line 623
      buflen --;
    }
  } else {
#line 628
    if (! buflen) {
#line 629
      goto done;
    }
#line 630
    tmp___9 = pbuf;
#line 630
    pbuf ++;
#line 630
    *tmp___9 = (char )';';
#line 631
    buflen --;
  }
  done: 
#line 636
  *pbuf = (char)0;
#line 637
  return;
}
}
#line 640 "/home/wheatley/newnew/temp/lbdb-0.38ubuntu1/rfc822.c"
void rfc822_write_address(char *buf , size_t buflen , ADDRESS *addr ) 
{ 
  char *pbuf ;
  size_t len ;
  size_t tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;

  {
  {
#line 642
  pbuf = buf;
#line 643
  tmp = strlen((char const   *)buf);
#line 643
  len = tmp;
#line 645
  buflen --;
  }
#line 647
  if (len > 0UL) {
#line 649
    if (len > buflen) {
#line 650
      return;
    }
#line 652
    pbuf += len;
#line 653
    buflen -= len;
#line 654
    if (! buflen) {
#line 655
      goto done;
    }
#line 656
    tmp___0 = pbuf;
#line 656
    pbuf ++;
#line 656
    *tmp___0 = (char )',';
#line 657
    buflen --;
#line 658
    if (! buflen) {
#line 659
      goto done;
    }
#line 660
    tmp___1 = pbuf;
#line 660
    pbuf ++;
#line 660
    *tmp___1 = (char )' ';
#line 661
    buflen --;
  }
  {
#line 664
  while (1) {
    while_continue: /* CIL Label */ ;
#line 664
    if (addr) {
#line 664
      if (! (buflen > 0UL)) {
#line 664
        goto while_break;
      }
    } else {
#line 664
      goto while_break;
    }
    {
#line 668
    rfc822_write_address_single(pbuf, buflen + 1UL, addr);
#line 672
    len = strlen((char const   *)pbuf);
#line 673
    pbuf += len;
#line 674
    buflen -= len;
    }
#line 678
    if (addr->next) {
#line 678
      if ((addr->next)->mailbox) {
#line 678
        if (! addr->group) {
#line 680
          if (! buflen) {
#line 681
            goto done;
          }
#line 682
          tmp___2 = pbuf;
#line 682
          pbuf ++;
#line 682
          *tmp___2 = (char )',';
#line 683
          buflen --;
#line 684
          if (! buflen) {
#line 685
            goto done;
          }
#line 686
          tmp___3 = pbuf;
#line 686
          pbuf ++;
#line 686
          *tmp___3 = (char )' ';
#line 687
          buflen --;
        }
      }
    }
#line 664
    addr = addr->next;
  }
  while_break: /* CIL Label */ ;
  }
  done: 
#line 691
  *pbuf = (char)0;
#line 692
  return;
}
}
#line 695 "/home/wheatley/newnew/temp/lbdb-0.38ubuntu1/rfc822.c"
ADDRESS *rfc822_cpy_adr_real(ADDRESS *addr ) 
{ 
  ADDRESS *p ;
  void *tmp ;

  {
  {
#line 697
  tmp = calloc((size_t )1, sizeof(ADDRESS ));
#line 697
  p = (ADDRESS *)tmp;
#line 702
  p->personal = safe_strdup((char const   *)addr->personal);
#line 703
  p->mailbox = safe_strdup((char const   *)addr->mailbox);
#line 704
  p->group = addr->group;
  }
#line 705
  return (p);
}
}
#line 709 "/home/wheatley/newnew/temp/lbdb-0.38ubuntu1/rfc822.c"
ADDRESS *rfc822_cpy_adr(ADDRESS *addr ) 
{ 
  ADDRESS *top ;
  ADDRESS *last ;

  {
#line 711
  top = (ADDRESS *)((void *)0);
#line 711
  last = (ADDRESS *)((void *)0);
  {
#line 713
  while (1) {
    while_continue: /* CIL Label */ ;
#line 713
    if (! addr) {
#line 713
      goto while_break;
    }
#line 715
    if (last) {
      {
#line 717
      last->next = rfc822_cpy_adr_real(addr);
#line 718
      last = last->next;
      }
    } else {
      {
#line 721
      last = rfc822_cpy_adr_real(addr);
#line 721
      top = last;
      }
    }
#line 713
    addr = addr->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 723
  return (top);
}
}
#line 727 "/home/wheatley/newnew/temp/lbdb-0.38ubuntu1/rfc822.c"
ADDRESS *rfc822_append(ADDRESS **a , ADDRESS *b ) 
{ 
  ADDRESS *tmp ;
  ADDRESS *tmp___0 ;

  {
#line 729
  tmp = *a;
  {
#line 731
  while (1) {
    while_continue: /* CIL Label */ ;
#line 731
    if (tmp) {
#line 731
      if (! tmp->next) {
#line 731
        goto while_break;
      }
    } else {
#line 731
      goto while_break;
    }
#line 732
    tmp = tmp->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 733
  if (! b) {
#line 734
    return (tmp);
  }
#line 735
  if (tmp) {
    {
#line 736
    tmp->next = rfc822_cpy_adr(b);
    }
  } else {
    {
#line 738
    tmp___0 = rfc822_cpy_adr(b);
#line 738
    *a = tmp___0;
#line 738
    tmp = tmp___0;
    }
  }
  {
#line 739
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 739
    if (tmp) {
#line 739
      if (! tmp->next) {
#line 739
        goto while_break___0;
      }
    } else {
#line 739
      goto while_break___0;
    }
#line 740
    tmp = tmp->next;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 741
  return (tmp);
}
}
#line 168 "/usr/include/stdio.h"
extern struct _IO_FILE *stdin ;
#line 170
extern struct _IO_FILE *stderr ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 362
extern int printf(char const   * __restrict  __format  , ...) ;
#line 622
extern char *fgets(char * __restrict  __s , int __n , FILE * __restrict  __stream ) ;
#line 129 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcpy)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 144
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 538
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strncasecmp)(char const   *__s1 ,
                                                                                                    char const   *__s2 ,
                                                                                                    size_t __n )  __attribute__((__pure__)) ;
#line 192 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) time_t ( __attribute__((__leaf__)) time)(time_t *__timer ) ;
#line 205
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__leaf__)) strftime)(char * __restrict  __s ,
                                                                                  size_t __maxsize ,
                                                                                  char const   * __restrict  __format ,
                                                                                  struct tm  const  * __restrict  __tp ) ;
#line 243
extern  __attribute__((__nothrow__)) struct tm *( __attribute__((__leaf__)) localtime)(time_t const   *__timer ) ;
#line 124 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) tolower)(int __c ) ;
#line 41 "/home/wheatley/newnew/temp/lbdb-0.38ubuntu1/helpers.h"
void safe_realloc(void **p , size_t siz ) ;
#line 21 "/home/wheatley/newnew/temp/lbdb-0.38ubuntu1/rfc2047.h"
char const   *Charset ;
#line 26
void rfc2047_decode_adrlist(ADDRESS *a ) ;
#line 44 "/home/wheatley/newnew/temp/lbdb-0.38ubuntu1/fetchaddr.c"
struct header hdr[21]  = {      {(char *)"to:", (char *)((void *)0), (size_t )0, (size_t )3}, 
        {(char *)"from:", (char *)((void *)0), (size_t )0, (size_t )5}, 
        {(char *)"cc:", (char *)((void *)0), (size_t )0, (size_t )3}, 
        {(char *)"resent-from:", (char *)((void *)0), (size_t )0, (size_t )12}, 
        {(char *)"resent-to:", (char *)((void *)0), (size_t )0, (size_t )10}, 
        {(char *)((void *)0), (char *)((void *)0), (size_t )0, (size_t )0}};
#line 54 "/home/wheatley/newnew/temp/lbdb-0.38ubuntu1/fetchaddr.c"
void chop(struct header *cur ) 
{ 


  {
#line 56
  if (cur->len) {
#line 56
    if ((int )*(cur->value + (cur->len - 1UL)) == 10) {
#line 57
      (cur->len) --;
#line 57
      *(cur->value + cur->len) = (char )'\000';
    }
  }
#line 58
  return;
}
}
#line 60 "/home/wheatley/newnew/temp/lbdb-0.38ubuntu1/fetchaddr.c"
int writeout(struct header *h , char const   *datefmt , unsigned char create_real_name ) 
{ 
  int rv ;
  ADDRESS *addr ;
  ADDRESS *p ;
  time_t timep ;
  char timebuf[256] ;
  char *c ;
  size_t tmp ;
  int tmp___0 ;
  struct tm *tmp___1 ;
  char const   *tmp___2 ;

  {
#line 63
  rv = 0;
#line 69
  if (! h->value) {
#line 70
    return (0);
  }
  {
#line 72
  addr = rfc822_parse_adrlist((ADDRESS *)((void *)0), (char const   *)h->value);
#line 73
  time(& timep);
#line 75
  rfc2047_decode_adrlist(addr);
#line 76
  p = addr;
  }
  {
#line 76
  while (1) {
    while_continue: /* CIL Label */ ;
#line 76
    if (! p) {
#line 76
      goto while_break;
    }
#line 78
    if ((int )create_real_name == 1) {
#line 78
      if (! p->personal) {
#line 78
        goto _L;
      } else
#line 78
      if (! *(p->personal)) {
        _L: /* CIL Label */ 
#line 78
        if (p->mailbox) {
#line 82
          if (p->personal) {
            {
#line 83
            safe_free((void *)p->personal);
            }
          }
          {
#line 84
          p->personal = safe_strdup((char const   *)p->mailbox);
#line 85
          c = strchr((char const   *)p->personal, '@');
          }
#line 86
          if (c) {
#line 87
            *c = (char )'\000';
          }
        }
      }
    }
#line 89
    if (! p->group) {
#line 89
      if (p->mailbox) {
#line 89
        if (*(p->mailbox)) {
#line 89
          if (p->personal) {
#line 91
            if (p->personal) {
              {
#line 91
              tmp = strlen((char const   *)p->personal);
              }
#line 91
              if (tmp > 30UL) {
                {
#line 92
                strcpy((char */* __restrict  */)(p->personal + 27), (char const   */* __restrict  */)"...");
                }
              }
            }
            {
#line 94
            c = strchr((char const   *)p->mailbox, '@');
            }
#line 94
            if (c) {
#line 95
              c ++;
              {
#line 95
              while (1) {
                while_continue___0: /* CIL Label */ ;
#line 95
                if (! *c) {
#line 95
                  goto while_break___0;
                }
                {
#line 96
                tmp___0 = tolower((int )*c);
#line 96
                *c = (char )tmp___0;
#line 95
                c ++;
                }
              }
              while_break___0: /* CIL Label */ ;
              }
            }
            {
#line 98
            tmp___1 = localtime((time_t const   *)(& timep));
#line 98
            strftime((char */* __restrict  */)(timebuf), sizeof(timebuf), (char const   */* __restrict  */)datefmt,
                     (struct tm  const  */* __restrict  */)tmp___1);
            }
#line 99
            if (p->personal) {
#line 99
              if (*(p->personal)) {
#line 99
                tmp___2 = (char const   *)p->personal;
              } else {
#line 99
                tmp___2 = "no realname given";
              }
            } else {
#line 99
              tmp___2 = "no realname given";
            }
            {
#line 99
            printf((char const   */* __restrict  */)"%s\t%s\t%s\n", p->mailbox, tmp___2,
                   timebuf);
#line 102
            rv = 1;
            }
          }
        }
      }
    }
#line 76
    p = p->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 106
  rfc822_free_address(& addr);
  }
#line 108
  return (rv);
}
}
#line 111 "/home/wheatley/newnew/temp/lbdb-0.38ubuntu1/fetchaddr.c"
int main(int argc , char **argv ) 
{ 
  char buff[2048] ;
  char *t ;
  int i ;
  int rv ;
  int partial ;
  struct header *cur_hdr ;
  char *datefmt ;
  char *headerlist ;
  char *fieldname ;
  char *next ;
  char create_real_name ;
  char const   **charsetptr ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  void *tmp___3 ;
  size_t tmp___4 ;
  void *tmp___5 ;
  size_t tmp___6 ;
  size_t tmp___7 ;
  size_t tmp___8 ;
  size_t tmp___9 ;
  size_t tmp___10 ;
  size_t nl ;
  size_t tmp___11 ;
  int tmp___12 ;
  char *tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;

  {
#line 116
  partial = 0;
#line 117
  cur_hdr = (struct header *)((void *)0);
#line 118
  datefmt = (char *)((void *)0);
#line 119
  headerlist = (char *)((void *)0);
#line 121
  create_real_name = (char)0;
#line 123
  charsetptr = & Charset;
#line 127
  if (argc > 1) {
#line 128
    i = 1;
    {
#line 129
    while (1) {
      while_continue: /* CIL Label */ ;
#line 129
      if (! (i < argc)) {
#line 129
        goto while_break;
      }
      {
#line 130
      tmp___2 = strcmp((char const   *)*(argv + i), "-d");
      }
#line 130
      if (tmp___2) {
        _L___1: /* CIL Label */ 
        {
#line 132
        tmp___1 = strcmp((char const   *)*(argv + i), "-x");
        }
#line 132
        if (tmp___1) {
          _L___0: /* CIL Label */ 
          {
#line 135
          tmp___0 = strcmp((char const   *)*(argv + i), "-c");
          }
#line 135
          if (tmp___0) {
            _L: /* CIL Label */ 
            {
#line 138
            tmp = strcmp((char const   *)*(argv + i), "-a");
            }
#line 138
            if (tmp) {
              {
#line 141
              fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: `%s\' wrong parameter\n",
                      *(argv + 0), *(argv + i));
              }
            } else {
#line 139
              create_real_name = (char)1;
            }
          } else
#line 135
          if (i + 1 < argc) {
#line 136
            i ++;
#line 136
            *charsetptr = (char const   *)*(argv + i);
          } else {
#line 135
            goto _L;
          }
        } else
#line 132
        if (i + 1 < argc) {
#line 133
          i ++;
#line 133
          headerlist = *(argv + i);
        } else {
#line 132
          goto _L___0;
        }
      } else
#line 130
      if (i + 1 < argc) {
#line 131
        i ++;
#line 131
        datefmt = *(argv + i);
      } else {
#line 130
        goto _L___1;
      }
#line 143
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 147
  if (! datefmt) {
    {
#line 148
    datefmt = safe_strdup("%Y-%m-%d %H:%M");
    }
  }
#line 150
  if (headerlist) {
    {
#line 150
    tmp___10 = strlen((char const   *)headerlist);
    }
#line 150
    if (tmp___10 > 0UL) {
#line 151
      fieldname = headerlist;
#line 152
      i = 0;
      {
#line 153
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 153
        if (i < 20) {
          {
#line 153
          next = strchr((char const   *)fieldname, ':');
          }
#line 153
          if (! next) {
#line 153
            goto while_break___0;
          }
        } else {
#line 153
          goto while_break___0;
        }
        {
#line 154
        tmp___3 = safe_malloc((unsigned int )((next - fieldname) + 2L));
#line 154
        hdr[i].tag = (char *)tmp___3;
#line 155
        strncpy((char */* __restrict  */)hdr[i].tag, (char const   */* __restrict  */)fieldname,
                (size_t )(next - fieldname));
#line 156
        *(hdr[i].tag + (next - fieldname)) = (char )':';
#line 157
        *(hdr[i].tag + ((next - fieldname) + 1L)) = (char )'\000';
#line 158
        hdr[i].taglen = (size_t )((next - fieldname) + 1L);
#line 159
        fieldname = next + 1;
#line 160
        i ++;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
#line 163
      if (i < 20) {
#line 163
        if ((int )*fieldname != 0) {
          {
#line 164
          tmp___4 = strlen((char const   *)fieldname);
#line 164
          tmp___5 = safe_malloc((unsigned int )(tmp___4 + 2UL));
#line 164
          hdr[i].tag = (char *)tmp___5;
#line 165
          tmp___6 = strlen((char const   *)fieldname);
#line 165
          strncpy((char */* __restrict  */)hdr[i].tag, (char const   */* __restrict  */)fieldname,
                  tmp___6);
#line 166
          tmp___7 = strlen((char const   *)fieldname);
#line 166
          *(hdr[i].tag + tmp___7) = (char )':';
#line 167
          tmp___8 = strlen((char const   *)fieldname);
#line 167
          *(hdr[i].tag + (tmp___8 + 1UL)) = (char )'\000';
#line 168
          tmp___9 = strlen((char const   *)fieldname);
#line 168
          hdr[i].taglen = tmp___9 + 1UL;
#line 169
          i ++;
          }
        }
      }
#line 172
      hdr[i].tag = (char *)((void *)0);
    }
  }
  {
#line 175
  while (1) {
    while_continue___1: /* CIL Label */ ;
    {
#line 175
    tmp___13 = fgets((char */* __restrict  */)(buff), (int )sizeof(buff), (FILE */* __restrict  */)stdin);
    }
#line 175
    if (! tmp___13) {
#line 175
      goto while_break___1;
    }
#line 178
    if (! partial) {
#line 178
      if ((int )buff[0] == 10) {
#line 179
        goto while_break___1;
      }
    }
#line 181
    if (cur_hdr) {
#line 181
      if (partial) {
#line 181
        goto _L___3;
      } else
#line 181
      if ((int )buff[0] == 32) {
#line 181
        goto _L___3;
      } else
#line 181
      if ((int )buff[0] == 9) {
        _L___3: /* CIL Label */ 
        {
#line 183
        tmp___11 = strlen((char const   *)(buff));
#line 183
        nl = cur_hdr->len + tmp___11;
#line 185
        safe_realloc((void **)(& cur_hdr->value), nl + 1UL);
#line 186
        strcpy((char */* __restrict  */)(cur_hdr->value + cur_hdr->len), (char const   */* __restrict  */)(buff));
#line 187
        cur_hdr->len = nl;
#line 188
        chop(cur_hdr);
        }
      } else {
#line 181
        goto _L___2;
      }
    } else
    _L___2: /* CIL Label */ 
#line 190
    if (! partial) {
#line 190
      if ((int )buff[0] != 32) {
#line 190
        if ((int )buff[0] != 9) {
#line 192
          cur_hdr = (struct header *)((void *)0);
#line 194
          i = 0;
          {
#line 194
          while (1) {
            while_continue___2: /* CIL Label */ ;
#line 194
            if (! hdr[i].tag) {
#line 194
              goto while_break___2;
            }
            {
#line 196
            tmp___12 = strncasecmp((char const   *)(buff), (char const   *)hdr[i].tag,
                                   hdr[i].taglen);
            }
#line 196
            if (! tmp___12) {
#line 198
              cur_hdr = & hdr[i];
#line 199
              goto while_break___2;
            }
#line 194
            i ++;
          }
          while_break___2: /* CIL Label */ ;
          }
#line 203
          if (cur_hdr) {
            {
#line 205
            safe_free((void *)(& cur_hdr->value));
#line 206
            cur_hdr->value = safe_strdup((char const   *)(buff + cur_hdr->taglen));
#line 207
            cur_hdr->len = strlen((char const   *)cur_hdr->value);
#line 208
            chop(cur_hdr);
            }
          }
        }
      }
    }
    {
#line 212
    t = strchr((char const   *)(buff), '\n');
    }
#line 212
    if (t) {
#line 215
      partial = 0;
    } else {
#line 213
      partial = 1;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 218
  rv = 0;
#line 218
  i = 0;
  {
#line 218
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 218
    if (! hdr[i].tag) {
#line 218
      goto while_break___3;
    }
#line 220
    if (hdr[i].value) {
      {
#line 221
      tmp___14 = writeout(& hdr[i], (char const   *)datefmt, (unsigned char )create_real_name);
      }
#line 221
      if (tmp___14) {
#line 221
        tmp___15 = 1;
      } else
#line 221
      if (rv) {
#line 221
        tmp___15 = 1;
      } else {
#line 221
        tmp___15 = 0;
      }
#line 221
      rv = tmp___15;
    }
#line 218
    i ++;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 224
  if (rv) {
#line 224
    tmp___16 = 0;
  } else {
#line 224
    tmp___16 = 1;
  }
#line 224
  return (tmp___16);
}
}
#line 127 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) toupper)(int __c ) ;
#line 46 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memcpy)(void * __restrict  __dest ,
                                                                                                 void const   * __restrict  __src ,
                                                                                                 size_t __n ) ;
#line 289
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1,2), __leaf__)) strspn)(char const   *__s ,
                                                                                                  char const   *__accept )  __attribute__((__pure__)) ;
#line 342
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strstr)(char const   *__haystack ,
                                                                                                 char const   *__needle )  __attribute__((__pure__)) ;
#line 348
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(2), __leaf__)) strtok)(char * __restrict  __s ,
                                                                                               char const   * __restrict  __delim ) ;
#line 534
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcasecmp)(char const   *__s1 ,
                                                                                                   char const   *__s2 )  __attribute__((__pure__)) ;
#line 37 "/usr/include/iconv.h"
extern iconv_t iconv_open(char const   *__tocode , char const   *__fromcode ) ;
#line 42
extern size_t iconv(iconv_t __cd , char ** __restrict  __inbuf , size_t * __restrict  __inbytesleft ,
                    char ** __restrict  __outbuf , size_t * __restrict  __outbytesleft ) ;
#line 51
extern int iconv_close(iconv_t __cd ) ;
#line 50 "/usr/include/x86_64-linux-gnu/bits/errno.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
#line 25 "/home/wheatley/newnew/temp/lbdb-0.38ubuntu1/rfc2047.h"
void rfc2047_decode(char *d , char const   *s , size_t dlen ) ;
#line 43 "/home/wheatley/newnew/temp/lbdb-0.38ubuntu1/rfc2047.c"
char const   MimeSpecials[16]  = 
#line 43 "/home/wheatley/newnew/temp/lbdb-0.38ubuntu1/rfc2047.c"
  {      (char const   )'@',      (char const   )'.',      (char const   )',',      (char const   )';', 
        (char const   )'<',      (char const   )'>',      (char const   )'[',      (char const   )']', 
        (char const   )'\\',      (char const   )'\"',      (char const   )'(',      (char const   )')', 
        (char const   )'?',      (char const   )'/',      (char const   )'=',      (char const   )'\000'};
#line 44 "/home/wheatley/newnew/temp/lbdb-0.38ubuntu1/rfc2047.c"
char const   *Charset  =    "iso-8859-15";
#line 47 "/home/wheatley/newnew/temp/lbdb-0.38ubuntu1/rfc2047.c"
int Index_hex[128]  = 
#line 47
  {      -1,      -1,      -1,      -1, 
        -1,      -1,      -1,      -1, 
        -1,      -1,      -1,      -1, 
        -1,      -1,      -1,      -1, 
        -1,      -1,      -1,      -1, 
        -1,      -1,      -1,      -1, 
        -1,      -1,      -1,      -1, 
        -1,      -1,      -1,      -1, 
        -1,      -1,      -1,      -1, 
        -1,      -1,      -1,      -1, 
        -1,      -1,      -1,      -1, 
        -1,      -1,      -1,      -1, 
        0,      1,      2,      3, 
        4,      5,      6,      7, 
        8,      9,      -1,      -1, 
        -1,      -1,      -1,      -1, 
        -1,      10,      11,      12, 
        13,      14,      15,      -1, 
        -1,      -1,      -1,      -1, 
        -1,      -1,      -1,      -1, 
        -1,      -1,      -1,      -1, 
        -1,      -1,      -1,      -1, 
        -1,      -1,      -1,      -1, 
        -1,      -1,      -1,      -1, 
        -1,      10,      11,      12, 
        13,      14,      15,      -1, 
        -1,      -1,      -1,      -1, 
        -1,      -1,      -1,      -1, 
        -1,      -1,      -1,      -1, 
        -1,      -1,      -1,      -1, 
        -1,      -1,      -1,      -1, 
        -1,      -1,      -1,      -1};
#line 58 "/home/wheatley/newnew/temp/lbdb-0.38ubuntu1/rfc2047.c"
int Index_64[128]  = 
#line 58
  {      -1,      -1,      -1,      -1, 
        -1,      -1,      -1,      -1, 
        -1,      -1,      -1,      -1, 
        -1,      -1,      -1,      -1, 
        -1,      -1,      -1,      -1, 
        -1,      -1,      -1,      -1, 
        -1,      -1,      -1,      -1, 
        -1,      -1,      -1,      -1, 
        -1,      -1,      -1,      -1, 
        -1,      -1,      -1,      -1, 
        -1,      -1,      -1,      62, 
        -1,      -1,      -1,      63, 
        52,      53,      54,      55, 
        56,      57,      58,      59, 
        60,      61,      -1,      -1, 
        -1,      -1,      -1,      -1, 
        -1,      0,      1,      2, 
        3,      4,      5,      6, 
        7,      8,      9,      10, 
        11,      12,      13,      14, 
        15,      16,      17,      18, 
        19,      20,      21,      22, 
        23,      24,      25,      -1, 
        -1,      -1,      -1,      -1, 
        -1,      26,      27,      28, 
        29,      30,      31,      32, 
        33,      34,      35,      36, 
        37,      38,      39,      40, 
        41,      42,      43,      44, 
        45,      46,      47,      48, 
        49,      50,      51,      -1, 
        -1,      -1,      -1,      -1};
#line 76 "/home/wheatley/newnew/temp/lbdb-0.38ubuntu1/rfc2047.c"
static int rfc2047_decode_word(char *d , char const   *s , size_t dlen ) 
{ 
  char *p ;
  char *tmp ;
  char *pp ;
  char *pd ;
  size_t len ;
  int enc ;
  int filter ;
  int count ;
  int c1 ;
  int c2 ;
  int c3 ;
  int c4 ;
  char *fromcharset ;
  iconv_t cd ;
  size_t in ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  unsigned short const   **tmp___9 ;
  size_t tmp___10 ;
  int *tmp___11 ;
  size_t tmp___12 ;

  {
  {
#line 78
  tmp = safe_strdup(s);
#line 78
  p = tmp;
#line 79
  pp = p;
#line 80
  pd = d;
#line 81
  len = dlen;
#line 82
  enc = 0;
#line 82
  filter = 0;
#line 82
  count = 0;
  }
  {
#line 89
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 89
    pp = strtok((char */* __restrict  */)pp, (char const   */* __restrict  */)"?");
    }
#line 89
    if (! ((unsigned long )pp != (unsigned long )((void *)0))) {
#line 89
      goto while_break;
    }
#line 91
    count ++;
    {
#line 94
    if (count == 2) {
#line 94
      goto case_2;
    }
#line 103
    if (count == 3) {
#line 103
      goto case_3;
    }
#line 111
    if (count == 4) {
#line 111
      goto case_4;
    }
#line 92
    goto switch_break;
    case_2: /* CIL Label */ 
    {
#line 95
    tmp___0 = strcasecmp((char const   *)pp, Charset);
    }
#line 95
    if (tmp___0 != 0) {
      {
#line 97
      filter = 1;
#line 99
      fromcharset = safe_strdup((char const   *)pp);
      }
    }
#line 102
    goto switch_break;
    case_3: /* CIL Label */ 
    {
#line 104
    tmp___2 = toupper((int )*pp);
    }
#line 104
    if (tmp___2 == 81) {
#line 105
      enc = 3;
    } else {
      {
#line 106
      tmp___1 = toupper((int )*pp);
      }
#line 106
      if (tmp___1 == 66) {
#line 107
        enc = 4;
      } else {
#line 109
        return (-1);
      }
    }
#line 110
    goto switch_break;
    case_4: /* CIL Label */ 
#line 112
    if (enc == 3) {
      {
#line 114
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 114
        if (*pp) {
#line 114
          if (! (len > 0UL)) {
#line 114
            goto while_break___0;
          }
        } else {
#line 114
          goto while_break___0;
        }
#line 116
        if ((int )*pp == 95) {
#line 118
          tmp___3 = pd;
#line 118
          pd ++;
#line 118
          *tmp___3 = (char )' ';
#line 119
          len --;
        } else
#line 121
        if ((int )*pp == 61) {
#line 123
          tmp___4 = pd;
#line 123
          pd ++;
#line 123
          *tmp___4 = (char )((Index_hex[(unsigned int )*(pp + 1)] << 4) | Index_hex[(unsigned int )*(pp + 2)]);
#line 124
          len --;
#line 125
          pp += 2;
        } else {
#line 129
          tmp___5 = pd;
#line 129
          pd ++;
#line 129
          *tmp___5 = *pp;
#line 130
          len --;
        }
#line 132
        pp ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 134
      *pd = (char)0;
    } else
#line 136
    if (enc == 4) {
      {
#line 138
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 138
        if (*pp) {
#line 138
          if (! (len > 0UL)) {
#line 138
            goto while_break___1;
          }
        } else {
#line 138
          goto while_break___1;
        }
#line 140
        c1 = Index_64[(unsigned int )*(pp + 0)];
#line 141
        c2 = Index_64[(unsigned int )*(pp + 1)];
#line 142
        tmp___6 = pd;
#line 142
        pd ++;
#line 142
        *tmp___6 = (char )((c1 << 2) | ((c2 >> 4) & 3));
#line 143
        len --;
#line 143
        if (len == 0UL) {
#line 143
          goto while_break___1;
        }
#line 145
        if ((int )*(pp + 2) == 61) {
#line 145
          goto while_break___1;
        }
#line 147
        c3 = Index_64[(unsigned int )*(pp + 2)];
#line 148
        tmp___7 = pd;
#line 148
        pd ++;
#line 148
        *tmp___7 = (char )(((c2 & 15) << 4) | ((c3 >> 2) & 15));
#line 149
        len --;
#line 149
        if (len == 0UL) {
#line 150
          goto while_break___1;
        }
#line 152
        if ((int )*(pp + 3) == 61) {
#line 153
          goto while_break___1;
        }
#line 155
        c4 = Index_64[(unsigned int )*(pp + 3)];
#line 156
        tmp___8 = pd;
#line 156
        pd ++;
#line 156
        *tmp___8 = (char )(((c3 & 3) << 6) | c4);
#line 157
        len --;
#line 157
        if (len == 0UL) {
#line 158
          goto while_break___1;
        }
#line 160
        pp += 4;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 162
      *pd = (char)0;
    }
#line 164
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 166
    pp = (char *)0;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 168
  safe_free((void *)(& p));
  }
#line 169
  if (filter) {
    {
#line 172
    cd = iconv_open(Charset, (char const   *)fromcharset);
    }
#line 172
    if ((unsigned long )cd == (unsigned long )((iconv_t )-1)) {
#line 175
      pd = d;
      {
#line 176
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 176
        if (! *pd) {
#line 176
          goto while_break___2;
        }
        {
#line 178
        tmp___9 = __ctype_b_loc();
        }
#line 178
        if (! ((int const   )*(*tmp___9 + (int )((unsigned char )*pd)) & 16384)) {
#line 178
          if (! ((int )((unsigned char )*pd) >= 160)) {
#line 179
            *pd = (char )'?';
          }
        }
#line 180
        pd ++;
      }
      while_break___2: /* CIL Label */ ;
      }
    } else {
      {
#line 184
      p = safe_strdup((char const   *)d);
#line 185
      pp = p;
#line 186
      tmp___10 = strlen((char const   *)d);
#line 186
      in = tmp___10 + 1UL;
#line 187
      pd = d;
#line 189
      len = dlen;
      }
      {
#line 190
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 190
        if (*pd) {
          {
#line 190
          tmp___12 = iconv(cd, (char **/* __restrict  */)(& pp), (size_t */* __restrict  */)(& in),
                           (char **/* __restrict  */)(& pd), (size_t */* __restrict  */)(& len));
          }
#line 190
          if (! (tmp___12 == 0xffffffffffffffffUL)) {
#line 190
            goto while_break___3;
          }
        } else {
#line 190
          goto while_break___3;
        }
        {
#line 192
        tmp___11 = __errno_location();
        }
#line 192
        if (*tmp___11 == 7) {
#line 193
          goto while_break___3;
        }
#line 195
        *pd = (char )'?';
#line 196
        pp ++;
#line 197
        in --;
#line 198
        pd ++;
#line 199
        len --;
      }
      while_break___3: /* CIL Label */ ;
      }
      {
#line 201
      iconv(cd, (char **/* __restrict  */)((void *)0), (size_t */* __restrict  */)((void *)0),
            (char **/* __restrict  */)(& pd), (size_t */* __restrict  */)(& len));
#line 202
      iconv_close(cd);
#line 203
      safe_free((void *)(& p));
      }
    }
    {
#line 205
    safe_free((void *)(& fromcharset));
    }
  }
#line 208
  return (0);
}
}
#line 214 "/home/wheatley/newnew/temp/lbdb-0.38ubuntu1/rfc2047.c"
void rfc2047_decode(char *d , char const   *s , size_t dlen ) 
{ 
  char const   *p ;
  char const   *q ;
  size_t n ;
  int found_encoded ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  size_t tmp___3 ;

  {
#line 218
  found_encoded = 0;
#line 220
  dlen --;
  {
#line 222
  while (1) {
    while_continue: /* CIL Label */ ;
#line 222
    if (*s) {
#line 222
      if (! (dlen > 0UL)) {
#line 222
        goto while_break;
      }
    } else {
#line 222
      goto while_break;
    }
    {
#line 224
    tmp = strstr(s, "=?");
#line 224
    p = (char const   *)tmp;
    }
#line 224
    if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 224
      goto _L;
    } else {
      {
#line 224
      tmp___0 = strchr(p + 2, '?');
#line 224
      q = (char const   *)tmp___0;
      }
#line 224
      if ((unsigned long )q == (unsigned long )((void *)0)) {
#line 224
        goto _L;
      } else {
        {
#line 224
        tmp___1 = strchr(q + 1, '?');
#line 224
        q = (char const   *)tmp___1;
        }
#line 224
        if ((unsigned long )q == (unsigned long )((void *)0)) {
#line 224
          goto _L;
        } else {
          {
#line 224
          tmp___2 = strstr(q + 1, "?=");
#line 224
          q = (char const   *)tmp___2;
          }
#line 224
          if ((unsigned long )q == (unsigned long )((void *)0)) {
            _L: /* CIL Label */ 
#line 230
            if ((unsigned long )d != (unsigned long )s) {
              {
#line 231
              strncpy((char */* __restrict  */)d, (char const   */* __restrict  */)s,
                      dlen + 1UL);
#line 231
              *((d + (dlen + 1UL)) - 1) = (char)0;
              }
            }
#line 232
            return;
          }
        }
      }
    }
#line 235
    if ((unsigned long )p != (unsigned long )s) {
#line 237
      n = (size_t )(p - s);
#line 239
      if (! found_encoded) {
#line 239
        goto _L___0;
      } else {
        {
#line 239
        tmp___3 = strspn(s, " \t\r\n");
        }
#line 239
        if (tmp___3 != n) {
          _L___0: /* CIL Label */ 
#line 241
          if (n > dlen) {
#line 242
            n = dlen;
          }
#line 243
          if ((unsigned long )d != (unsigned long )s) {
            {
#line 244
            memcpy((void */* __restrict  */)d, (void const   */* __restrict  */)s,
                   n);
            }
          }
#line 245
          d += n;
#line 246
          dlen -= n;
        }
      }
    }
    {
#line 250
    rfc2047_decode_word(d, p, dlen);
#line 251
    found_encoded = 1;
#line 252
    s = q + 2;
#line 253
    n = strlen((char const   *)d);
#line 254
    dlen -= n;
#line 255
    d += n;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 257
  *d = (char)0;
#line 258
  return;
}
}
#line 260 "/home/wheatley/newnew/temp/lbdb-0.38ubuntu1/rfc2047.c"
void rfc2047_decode_adrlist(ADDRESS *a ) 
{ 
  size_t tmp ;
  char *tmp___0 ;

  {
  {
#line 262
  while (1) {
    while_continue: /* CIL Label */ ;
#line 262
    if (! a) {
#line 262
      goto while_break;
    }
#line 264
    if (a->personal) {
      {
#line 264
      tmp___0 = strstr((char const   *)a->personal, "=?");
      }
#line 264
      if ((unsigned long )tmp___0 != (unsigned long )((void *)0)) {
        {
#line 265
        tmp = strlen((char const   *)a->personal);
#line 265
        rfc2047_decode(a->personal, (char const   *)a->personal, tmp + 1UL);
        }
      }
    }
#line 266
    a = a->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 268
  return;
}
}
#line 846 "/usr/include/stdio.h"
extern void perror(char const   *__s ) ;
#line 466 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 480
extern  __attribute__((__nothrow__)) void *( __attribute__((__warn_unused_result__,
__leaf__)) realloc)(void *__ptr , size_t __size ) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 543
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 444 "/usr/include/unistd.h"
extern unsigned int sleep(unsigned int __seconds ) ;
#line 39 "/home/wheatley/newnew/temp/lbdb-0.38ubuntu1/helpers.h"
void *safe_calloc(size_t nmemb , size_t size ) ;
#line 39 "/home/wheatley/newnew/temp/lbdb-0.38ubuntu1/helpers.c"
void *safe_calloc(size_t nmemb , size_t size ) 
{ 
  void *p ;

  {
#line 43
  if (! nmemb) {
#line 44
    return ((void *)0);
  } else
#line 43
  if (! size) {
#line 44
    return ((void *)0);
  }
  {
#line 45
  p = calloc(nmemb, size);
  }
#line 45
  if (! p) {
    {
#line 47
    perror("Out of memory");
#line 48
    sleep(1U);
#line 49
    exit(1);
    }
  }
#line 51
  return (p);
}
}
#line 54 "/home/wheatley/newnew/temp/lbdb-0.38ubuntu1/helpers.c"
void *safe_malloc(unsigned int siz ) 
{ 
  void *p ;
  void *tmp ;

  {
#line 58
  if (siz == 0U) {
#line 59
    return ((void *)0);
  }
  {
#line 60
  tmp = malloc((size_t )siz);
#line 60
  p = tmp;
  }
#line 60
  if ((unsigned long )p == (unsigned long )((void *)0)) {
    {
#line 62
    perror("Out of memory!");
#line 63
    sleep(1U);
#line 64
    exit(1);
    }
  }
#line 66
  return (p);
}
}
#line 69 "/home/wheatley/newnew/temp/lbdb-0.38ubuntu1/helpers.c"
void safe_realloc(void **p , size_t siz ) 
{ 
  void *r ;
  void *tmp ;
  void *tmp___0 ;

  {
#line 73
  if (siz == 0UL) {
#line 75
    if (*p) {
      {
#line 77
      free(*p);
#line 78
      *p = (void *)0;
      }
    }
#line 80
    return;
  }
#line 83
  if (*p) {
    {
#line 84
    tmp = realloc(*p, siz);
#line 84
    r = tmp;
    }
  } else {
    {
#line 88
    tmp___0 = malloc(siz);
#line 88
    r = tmp___0;
    }
  }
#line 91
  if (! r) {
    {
#line 93
    perror("Out of memory!");
#line 94
    sleep(1U);
#line 95
    exit(1);
    }
  }
#line 98
  *p = r;
#line 99
  return;
}
}
#line 101 "/home/wheatley/newnew/temp/lbdb-0.38ubuntu1/helpers.c"
void safe_free(void *ptr ) 
{ 
  void **p ;

  {
#line 103
  p = (void **)ptr;
#line 104
  if (*p) {
    {
#line 106
    free(*p);
#line 107
    *p = (void *)0;
    }
  }
#line 109
  return;
}
}
#line 111 "/home/wheatley/newnew/temp/lbdb-0.38ubuntu1/helpers.c"
char *safe_strdup(char const   *s ) 
{ 
  char *p ;
  size_t l ;
  size_t tmp ;
  void *tmp___0 ;

  {
#line 116
  if (! s) {
#line 116
    return ((char *)0);
  } else
#line 116
  if (! *s) {
#line 116
    return ((char *)0);
  }
  {
#line 117
  tmp = strlen(s);
#line 117
  l = tmp + 1UL;
#line 118
  tmp___0 = safe_malloc((unsigned int )l);
#line 118
  p = (char *)tmp___0;
#line 119
  memcpy((void */* __restrict  */)p, (void const   */* __restrict  */)s, l);
  }
#line 120
  return (p);
}
}
#line 83 "/home/wheatley/newnew/temp/lbdb-0.38ubuntu1/rfc822.c"
static char const   *parse_comment___0(char const   *s , char *comment , size_t *commentlen ,
                                       size_t commentmax ) 
{ 
  int level ;
  size_t tmp ;

  {
#line 87
  level = 1;
  {
#line 89
  while (1) {
    while_continue: /* CIL Label */ ;
#line 89
    if (*s) {
#line 89
      if (! level) {
#line 89
        goto while_break;
      }
    } else {
#line 89
      goto while_break;
    }
#line 91
    if ((int const   )*s == 40) {
#line 92
      level ++;
    } else
#line 93
    if ((int const   )*s == 41) {
#line 95
      level --;
#line 95
      if (level == 0) {
#line 97
        s ++;
#line 98
        goto while_break;
      }
    } else
#line 101
    if ((int const   )*s == 92) {
#line 103
      s ++;
#line 103
      if (! *s) {
#line 104
        goto while_break;
      }
    }
#line 106
    if (*commentlen < commentmax) {
#line 107
      tmp = *commentlen;
#line 107
      (*commentlen) ++;
#line 107
      *(comment + tmp) = (char )*s;
    }
#line 108
    s ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 110
  if (level) {
#line 112
    RFC822Error = 2;
#line 113
    return ((char const   *)((void *)0));
  }
#line 115
  return (s);
}
}
#line 118 "/home/wheatley/newnew/temp/lbdb-0.38ubuntu1/rfc822.c"
static char const   *parse_quote___0(char const   *s , char *token , size_t *tokenlen ,
                                     size_t tokenmax ) 
{ 
  size_t tmp ;
  size_t tmp___0 ;

  {
#line 121
  if (*tokenlen < tokenmax) {
#line 122
    tmp = *tokenlen;
#line 122
    (*tokenlen) ++;
#line 122
    *(token + tmp) = (char )'\"';
  }
  {
#line 123
  while (1) {
    while_continue: /* CIL Label */ ;
#line 123
    if (! *s) {
#line 123
      goto while_break;
    }
#line 125
    if (*tokenlen < tokenmax) {
#line 126
      tmp___0 = *tokenlen;
#line 126
      (*tokenlen) ++;
#line 126
      *(token + tmp___0) = (char )*s;
    }
#line 127
    if ((int const   )*s == 34) {
#line 128
      return (s + 1);
    }
#line 129
    if ((int const   )*s == 92) {
#line 131
      s ++;
#line 131
      if (! *s) {
#line 132
        goto while_break;
      }
    }
#line 134
    s ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 136
  RFC822Error = 3;
#line 137
  return ((char const   *)((void *)0));
}
}
#line 140 "/home/wheatley/newnew/temp/lbdb-0.38ubuntu1/rfc822.c"
static char const   *next_token___0(char const   *s , char *token , size_t *tokenlen ,
                                    size_t tokenmax ) 
{ 
  char const   *tmp ;
  char const   *tmp___0 ;
  size_t tmp___1 ;
  char *tmp___2 ;
  unsigned short const   **tmp___3 ;
  char *tmp___4 ;
  size_t tmp___5 ;

  {
#line 143
  if ((int const   )*s == 40) {
    {
#line 144
    tmp = parse_comment___0(s + 1, token, tokenlen, tokenmax);
    }
#line 144
    return (tmp);
  }
#line 145
  if ((int const   )*s == 34) {
    {
#line 146
    tmp___0 = parse_quote___0(s + 1, token, tokenlen, tokenmax);
    }
#line 146
    return (tmp___0);
  }
  {
#line 147
  tmp___2 = strchr(RFC822Specials, (int )*s);
  }
#line 147
  if (tmp___2) {
#line 149
    if (*tokenlen < tokenmax) {
#line 150
      tmp___1 = *tokenlen;
#line 150
      (*tokenlen) ++;
#line 150
      *(token + tmp___1) = (char )*s;
    }
#line 151
    return (s + 1);
  }
  {
#line 153
  while (1) {
    while_continue: /* CIL Label */ ;
#line 153
    if (! *s) {
#line 153
      goto while_break;
    }
    {
#line 155
    tmp___3 = __ctype_b_loc();
    }
#line 155
    if ((int const   )*(*tmp___3 + (int )*s) & 8192) {
#line 156
      goto while_break;
    } else {
      {
#line 155
      tmp___4 = strchr(RFC822Specials, (int )*s);
      }
#line 155
      if (tmp___4) {
#line 156
        goto while_break;
      }
    }
#line 157
    if (*tokenlen < tokenmax) {
#line 158
      tmp___5 = *tokenlen;
#line 158
      (*tokenlen) ++;
#line 158
      *(token + tmp___5) = (char )*s;
    }
#line 159
    s ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 161
  return (s);
}
}
#line 164 "/home/wheatley/newnew/temp/lbdb-0.38ubuntu1/rfc822.c"
static char const   *parse_mailboxdomain___0(char const   *s , char const   *nonspecial ,
                                             char *mailbox , size_t *mailboxlen ,
                                             size_t mailboxmax , char *comment , size_t *commentlen ,
                                             size_t commentmax ) 
{ 
  char const   *ps ;
  unsigned short const   **tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  size_t tmp___2 ;

  {
  {
#line 171
  while (1) {
    while_continue: /* CIL Label */ ;
#line 171
    if (! *s) {
#line 171
      goto while_break;
    }
    {
#line 173
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 173
      if (*s) {
        {
#line 173
        tmp = __ctype_b_loc();
        }
#line 173
        if (! ((int const   )*(*tmp + (int )((unsigned char )*s)) & 8192)) {
#line 173
          goto while_break___0;
        }
      } else {
#line 173
        goto while_break___0;
      }
#line 173
      s ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 174
    tmp___0 = strchr(nonspecial, (int )*s);
    }
#line 174
    if ((unsigned long )tmp___0 == (unsigned long )((void *)0)) {
      {
#line 174
      tmp___1 = strchr(RFC822Specials, (int )*s);
      }
#line 174
      if (tmp___1) {
#line 175
        return (s);
      }
    }
#line 177
    if ((int const   )*s == 40) {
#line 179
      if (*commentlen) {
#line 179
        if (*commentlen < commentmax) {
#line 180
          tmp___2 = *commentlen;
#line 180
          (*commentlen) ++;
#line 180
          *(comment + tmp___2) = (char )' ';
        }
      }
      {
#line 181
      ps = next_token___0(s, comment, commentlen, commentmax);
      }
    } else {
      {
#line 184
      ps = next_token___0(s, mailbox, mailboxlen, mailboxmax);
      }
    }
#line 185
    if (! ps) {
#line 186
      return ((char const   *)((void *)0));
    }
#line 187
    s = ps;
  }
  while_break: /* CIL Label */ ;
  }
#line 190
  return (s);
}
}
#line 193 "/home/wheatley/newnew/temp/lbdb-0.38ubuntu1/rfc822.c"
static char const   *parse_address___0(char const   *s , char *token , size_t *tokenlen ,
                                       size_t tokenmax , char *comment , size_t *commentlen ,
                                       size_t commentmax , ADDRESS *addr ) 
{ 
  size_t tmp ;

  {
  {
#line 199
  s = parse_mailboxdomain___0(s, ".\"(\\", token, tokenlen, tokenmax, comment, commentlen,
                              commentmax);
  }
#line 202
  if (! s) {
#line 203
    return ((char const   *)((void *)0));
  }
#line 205
  if ((int const   )*s == 64) {
#line 207
    if (*tokenlen < tokenmax) {
#line 208
      tmp = *tokenlen;
#line 208
      (*tokenlen) ++;
#line 208
      *(token + tmp) = (char )'@';
    }
    {
#line 209
    s = parse_mailboxdomain___0(s + 1, ".([]\\", token, tokenlen, tokenmax, comment,
                                commentlen, commentmax);
    }
#line 212
    if (! s) {
#line 213
      return ((char const   *)((void *)0));
    }
  }
  {
#line 216
  *(token + *tokenlen) = (char)0;
#line 217
  addr->mailbox = safe_strdup((char const   *)token);
  }
#line 219
  if (*commentlen) {
#line 219
    if (! addr->personal) {
      {
#line 221
      *(comment + *commentlen) = (char)0;
#line 222
      addr->personal = safe_strdup((char const   *)comment);
      }
    }
  }
#line 225
  return (s);
}
}
#line 228 "/home/wheatley/newnew/temp/lbdb-0.38ubuntu1/rfc822.c"
static char const   *parse_route_addr___0(char const   *s , char *comment , size_t *commentlen ,
                                          size_t commentmax , ADDRESS *addr ) 
{ 
  char token[256] ;
  size_t tokenlen ;
  unsigned short const   **tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;

  {
#line 234
  tokenlen = (size_t )0;
  {
#line 236
  while (1) {
    while_continue: /* CIL Label */ ;
#line 236
    if (*s) {
      {
#line 236
      tmp = __ctype_b_loc();
      }
#line 236
      if (! ((int const   )*(*tmp + (int )((unsigned char )*s)) & 8192)) {
#line 236
        goto while_break;
      }
    } else {
#line 236
      goto while_break;
    }
#line 236
    s ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 239
  if ((int const   )*s == 64) {
    {
#line 241
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 241
      if (s) {
#line 241
        if (! ((int const   )*s == 64)) {
#line 241
          goto while_break___0;
        }
      } else {
#line 241
        goto while_break___0;
      }
#line 243
      if (tokenlen < sizeof(token) - 1UL) {
#line 244
        tmp___0 = tokenlen;
#line 244
        tokenlen ++;
#line 244
        token[tmp___0] = (char )'@';
      }
      {
#line 245
      s = parse_mailboxdomain___0(s + 1, ".\\[](", token, & tokenlen, sizeof(token) - 1UL,
                                  comment, commentlen, commentmax);
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 249
    if (! s) {
#line 251
      RFC822Error = 4;
#line 252
      return ((char const   *)((void *)0));
    } else
#line 249
    if ((int const   )*s != 58) {
#line 251
      RFC822Error = 4;
#line 252
      return ((char const   *)((void *)0));
    }
#line 255
    if (tokenlen < sizeof(token) - 1UL) {
#line 256
      tmp___1 = tokenlen;
#line 256
      tokenlen ++;
#line 256
      token[tmp___1] = (char )':';
    }
#line 257
    s ++;
  }
  {
#line 260
  s = parse_address___0(s, token, & tokenlen, sizeof(token) - 1UL, comment, commentlen,
                        commentmax, addr);
  }
#line 260
  if ((unsigned long )s == (unsigned long )((void *)0)) {
#line 261
    return ((char const   *)((void *)0));
  }
#line 263
  if ((int const   )*s != 62) {
#line 265
    RFC822Error = 5;
#line 266
    return ((char const   *)((void *)0));
  } else
#line 263
  if (! addr->mailbox) {
#line 265
    RFC822Error = 5;
#line 266
    return ((char const   *)((void *)0));
  }
#line 269
  s ++;
#line 270
  return (s);
}
}
#line 273 "/home/wheatley/newnew/temp/lbdb-0.38ubuntu1/rfc822.c"
static char const   *parse_addr_spec___0(char const   *s , char *comment , size_t *commentlen ,
                                         size_t commentmax , ADDRESS *addr ) 
{ 
  char token[256] ;
  size_t tokenlen ;

  {
  {
#line 279
  tokenlen = (size_t )0;
#line 281
  s = parse_address___0(s, token, & tokenlen, sizeof(token) - 1UL, comment, commentlen,
                        commentmax, addr);
  }
#line 282
  if (s) {
#line 282
    if (*s) {
#line 282
      if ((int const   )*s != 44) {
#line 282
        if ((int const   )*s != 59) {
#line 284
          RFC822Error = 6;
#line 285
          return ((char const   *)((void *)0));
        }
      }
    }
  }
#line 287
  return (s);
}
}
#line 290 "/home/wheatley/newnew/temp/lbdb-0.38ubuntu1/rfc822.c"
static void add_addrspec___0(ADDRESS **top , ADDRESS **last , char const   *phrase ,
                             char *comment , size_t *commentlen , size_t commentmax ) 
{ 
  ADDRESS *cur ;
  void *tmp ;
  char const   *tmp___0 ;

  {
  {
#line 294
  tmp = calloc((size_t )1, sizeof(ADDRESS ));
#line 294
  cur = (ADDRESS *)tmp;
#line 296
  tmp___0 = parse_addr_spec___0(phrase, comment, commentlen, commentmax, cur);
  }
#line 296
  if ((unsigned long )tmp___0 == (unsigned long )((void *)0)) {
#line 297
    return;
  }
#line 299
  if (*last) {
#line 300
    (*last)->next = cur;
  } else {
#line 302
    *top = cur;
  }
#line 303
  *last = cur;
#line 304
  return;
}
}
#line 76 "/home/wheatley/newnew/temp/lbdb-0.38ubuntu1/rfc2047.c"
static int rfc2047_decode_word___0(char *d , char const   *s , size_t dlen ) 
{ 
  char *p ;
  char *tmp ;
  char *pp ;
  char *pd ;
  size_t len ;
  int enc ;
  int filter ;
  int count ;
  int c1 ;
  int c2 ;
  int c3 ;
  int c4 ;
  char *fromcharset ;
  iconv_t cd ;
  size_t in ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  unsigned short const   **tmp___9 ;
  size_t tmp___10 ;
  int *tmp___11 ;
  size_t tmp___12 ;

  {
  {
#line 78
  tmp = safe_strdup(s);
#line 78
  p = tmp;
#line 79
  pp = p;
#line 80
  pd = d;
#line 81
  len = dlen;
#line 82
  enc = 0;
#line 82
  filter = 0;
#line 82
  count = 0;
  }
  {
#line 89
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 89
    pp = strtok((char */* __restrict  */)pp, (char const   */* __restrict  */)"?");
    }
#line 89
    if (! ((unsigned long )pp != (unsigned long )((void *)0))) {
#line 89
      goto while_break;
    }
#line 91
    count ++;
    {
#line 94
    if (count == 2) {
#line 94
      goto case_2;
    }
#line 103
    if (count == 3) {
#line 103
      goto case_3;
    }
#line 111
    if (count == 4) {
#line 111
      goto case_4;
    }
#line 92
    goto switch_break;
    case_2: /* CIL Label */ 
    {
#line 95
    tmp___0 = strcasecmp((char const   *)pp, Charset);
    }
#line 95
    if (tmp___0 != 0) {
      {
#line 97
      filter = 1;
#line 99
      fromcharset = safe_strdup((char const   *)pp);
      }
    }
#line 102
    goto switch_break;
    case_3: /* CIL Label */ 
    {
#line 104
    tmp___2 = toupper((int )*pp);
    }
#line 104
    if (tmp___2 == 81) {
#line 105
      enc = 3;
    } else {
      {
#line 106
      tmp___1 = toupper((int )*pp);
      }
#line 106
      if (tmp___1 == 66) {
#line 107
        enc = 4;
      } else {
#line 109
        return (-1);
      }
    }
#line 110
    goto switch_break;
    case_4: /* CIL Label */ 
#line 112
    if (enc == 3) {
      {
#line 114
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 114
        if (*pp) {
#line 114
          if (! (len > 0UL)) {
#line 114
            goto while_break___0;
          }
        } else {
#line 114
          goto while_break___0;
        }
#line 116
        if ((int )*pp == 95) {
#line 118
          tmp___3 = pd;
#line 118
          pd ++;
#line 118
          *tmp___3 = (char )' ';
#line 119
          len --;
        } else
#line 121
        if ((int )*pp == 61) {
#line 123
          tmp___4 = pd;
#line 123
          pd ++;
#line 123
          *tmp___4 = (char )((Index_hex[(unsigned int )*(pp + 1)] << 4) | Index_hex[(unsigned int )*(pp + 2)]);
#line 124
          len --;
#line 125
          pp += 2;
        } else {
#line 129
          tmp___5 = pd;
#line 129
          pd ++;
#line 129
          *tmp___5 = *pp;
#line 130
          len --;
        }
#line 132
        pp ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 134
      *pd = (char)0;
    } else
#line 136
    if (enc == 4) {
      {
#line 138
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 138
        if (*pp) {
#line 138
          if (! (len > 0UL)) {
#line 138
            goto while_break___1;
          }
        } else {
#line 138
          goto while_break___1;
        }
#line 140
        c1 = Index_64[(unsigned int )*(pp + 0)];
#line 141
        c2 = Index_64[(unsigned int )*(pp + 1)];
#line 142
        tmp___6 = pd;
#line 142
        pd ++;
#line 142
        *tmp___6 = (char )((c1 << 2) | ((c2 >> 4) & 3));
#line 143
        len --;
#line 143
        if (len == 0UL) {
#line 143
          goto while_break___1;
        }
#line 145
        if ((int )*(pp + 2) == 61) {
#line 145
          goto while_break___1;
        }
#line 147
        c3 = Index_64[(unsigned int )*(pp + 2)];
#line 148
        tmp___7 = pd;
#line 148
        pd ++;
#line 148
        *tmp___7 = (char )(((c2 & 15) << 4) | ((c3 >> 2) & 15));
#line 149
        len --;
#line 149
        if (len == 0UL) {
#line 150
          goto while_break___1;
        }
#line 152
        if ((int )*(pp + 3) == 61) {
#line 153
          goto while_break___1;
        }
#line 155
        c4 = Index_64[(unsigned int )*(pp + 3)];
#line 156
        tmp___8 = pd;
#line 156
        pd ++;
#line 156
        *tmp___8 = (char )(((c3 & 3) << 6) | c4);
#line 157
        len --;
#line 157
        if (len == 0UL) {
#line 158
          goto while_break___1;
        }
#line 160
        pp += 4;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 162
      *pd = (char)0;
    }
#line 164
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 166
    pp = (char *)0;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 168
  safe_free((void *)(& p));
  }
#line 169
  if (filter) {
    {
#line 172
    cd = iconv_open(Charset, (char const   *)fromcharset);
    }
#line 172
    if ((unsigned long )cd == (unsigned long )((iconv_t )-1)) {
#line 175
      pd = d;
      {
#line 176
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 176
        if (! *pd) {
#line 176
          goto while_break___2;
        }
        {
#line 178
        tmp___9 = __ctype_b_loc();
        }
#line 178
        if (! ((int const   )*(*tmp___9 + (int )((unsigned char )*pd)) & 16384)) {
#line 178
          if (! ((int )((unsigned char )*pd) >= 160)) {
#line 179
            *pd = (char )'?';
          }
        }
#line 180
        pd ++;
      }
      while_break___2: /* CIL Label */ ;
      }
    } else {
      {
#line 184
      p = safe_strdup((char const   *)d);
#line 185
      pp = p;
#line 186
      tmp___10 = strlen((char const   *)d);
#line 186
      in = tmp___10 + 1UL;
#line 187
      pd = d;
#line 189
      len = dlen;
      }
      {
#line 190
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 190
        if (*pd) {
          {
#line 190
          tmp___12 = iconv(cd, (char **/* __restrict  */)(& pp), (size_t */* __restrict  */)(& in),
                           (char **/* __restrict  */)(& pd), (size_t */* __restrict  */)(& len));
          }
#line 190
          if (! (tmp___12 == 0xffffffffffffffffUL)) {
#line 190
            goto while_break___3;
          }
        } else {
#line 190
          goto while_break___3;
        }
        {
#line 192
        tmp___11 = __errno_location();
        }
#line 192
        if (*tmp___11 == 7) {
#line 193
          goto while_break___3;
        }
#line 195
        *pd = (char )'?';
#line 196
        pp ++;
#line 197
        in --;
#line 198
        pd ++;
#line 199
        len --;
      }
      while_break___3: /* CIL Label */ ;
      }
      {
#line 201
      iconv(cd, (char **/* __restrict  */)((void *)0), (size_t */* __restrict  */)((void *)0),
            (char **/* __restrict  */)(& pd), (size_t */* __restrict  */)(& len));
#line 202
      iconv_close(cd);
#line 203
      safe_free((void *)(& p));
      }
    }
    {
#line 205
    safe_free((void *)(& fromcharset));
    }
  }
#line 208
  return (0);
}
}
#line 169 "/usr/include/stdio.h"
extern struct _IO_FILE *stdout ;
#line 689
extern int fputs(char const   * __restrict  __s , FILE * __restrict  __stream ) ;
#line 76 "/home/wheatley/newnew/temp/lbdb-0.38ubuntu1/rfc2047.c"
static int rfc2047_decode_word___1(char *d , char const   *s , size_t dlen ) 
{ 
  char *p ;
  char *tmp ;
  char *pp ;
  char *pd ;
  size_t len ;
  int enc ;
  int filter ;
  int count ;
  int c1 ;
  int c2 ;
  int c3 ;
  int c4 ;
  char *fromcharset ;
  iconv_t cd ;
  size_t in ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  unsigned short const   **tmp___9 ;
  size_t tmp___10 ;
  int *tmp___11 ;
  size_t tmp___12 ;

  {
  {
#line 78
  tmp = safe_strdup(s);
#line 78
  p = tmp;
#line 79
  pp = p;
#line 80
  pd = d;
#line 81
  len = dlen;
#line 82
  enc = 0;
#line 82
  filter = 0;
#line 82
  count = 0;
  }
  {
#line 89
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 89
    pp = strtok((char */* __restrict  */)pp, (char const   */* __restrict  */)"?");
    }
#line 89
    if (! ((unsigned long )pp != (unsigned long )((void *)0))) {
#line 89
      goto while_break;
    }
#line 91
    count ++;
    {
#line 94
    if (count == 2) {
#line 94
      goto case_2;
    }
#line 103
    if (count == 3) {
#line 103
      goto case_3;
    }
#line 111
    if (count == 4) {
#line 111
      goto case_4;
    }
#line 92
    goto switch_break;
    case_2: /* CIL Label */ 
    {
#line 95
    tmp___0 = strcasecmp((char const   *)pp, Charset);
    }
#line 95
    if (tmp___0 != 0) {
      {
#line 97
      filter = 1;
#line 99
      fromcharset = safe_strdup((char const   *)pp);
      }
    }
#line 102
    goto switch_break;
    case_3: /* CIL Label */ 
    {
#line 104
    tmp___2 = toupper((int )*pp);
    }
#line 104
    if (tmp___2 == 81) {
#line 105
      enc = 3;
    } else {
      {
#line 106
      tmp___1 = toupper((int )*pp);
      }
#line 106
      if (tmp___1 == 66) {
#line 107
        enc = 4;
      } else {
#line 109
        return (-1);
      }
    }
#line 110
    goto switch_break;
    case_4: /* CIL Label */ 
#line 112
    if (enc == 3) {
      {
#line 114
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 114
        if (*pp) {
#line 114
          if (! (len > 0UL)) {
#line 114
            goto while_break___0;
          }
        } else {
#line 114
          goto while_break___0;
        }
#line 116
        if ((int )*pp == 95) {
#line 118
          tmp___3 = pd;
#line 118
          pd ++;
#line 118
          *tmp___3 = (char )' ';
#line 119
          len --;
        } else
#line 121
        if ((int )*pp == 61) {
#line 123
          tmp___4 = pd;
#line 123
          pd ++;
#line 123
          *tmp___4 = (char )((Index_hex[(unsigned int )*(pp + 1)] << 4) | Index_hex[(unsigned int )*(pp + 2)]);
#line 124
          len --;
#line 125
          pp += 2;
        } else {
#line 129
          tmp___5 = pd;
#line 129
          pd ++;
#line 129
          *tmp___5 = *pp;
#line 130
          len --;
        }
#line 132
        pp ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 134
      *pd = (char)0;
    } else
#line 136
    if (enc == 4) {
      {
#line 138
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 138
        if (*pp) {
#line 138
          if (! (len > 0UL)) {
#line 138
            goto while_break___1;
          }
        } else {
#line 138
          goto while_break___1;
        }
#line 140
        c1 = Index_64[(unsigned int )*(pp + 0)];
#line 141
        c2 = Index_64[(unsigned int )*(pp + 1)];
#line 142
        tmp___6 = pd;
#line 142
        pd ++;
#line 142
        *tmp___6 = (char )((c1 << 2) | ((c2 >> 4) & 3));
#line 143
        len --;
#line 143
        if (len == 0UL) {
#line 143
          goto while_break___1;
        }
#line 145
        if ((int )*(pp + 2) == 61) {
#line 145
          goto while_break___1;
        }
#line 147
        c3 = Index_64[(unsigned int )*(pp + 2)];
#line 148
        tmp___7 = pd;
#line 148
        pd ++;
#line 148
        *tmp___7 = (char )(((c2 & 15) << 4) | ((c3 >> 2) & 15));
#line 149
        len --;
#line 149
        if (len == 0UL) {
#line 150
          goto while_break___1;
        }
#line 152
        if ((int )*(pp + 3) == 61) {
#line 153
          goto while_break___1;
        }
#line 155
        c4 = Index_64[(unsigned int )*(pp + 3)];
#line 156
        tmp___8 = pd;
#line 156
        pd ++;
#line 156
        *tmp___8 = (char )(((c3 & 3) << 6) | c4);
#line 157
        len --;
#line 157
        if (len == 0UL) {
#line 158
          goto while_break___1;
        }
#line 160
        pp += 4;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 162
      *pd = (char)0;
    }
#line 164
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 166
    pp = (char *)0;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 168
  safe_free((void *)(& p));
  }
#line 169
  if (filter) {
    {
#line 172
    cd = iconv_open(Charset, (char const   *)fromcharset);
    }
#line 172
    if ((unsigned long )cd == (unsigned long )((iconv_t )-1)) {
#line 175
      pd = d;
      {
#line 176
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 176
        if (! *pd) {
#line 176
          goto while_break___2;
        }
        {
#line 178
        tmp___9 = __ctype_b_loc();
        }
#line 178
        if (! ((int const   )*(*tmp___9 + (int )((unsigned char )*pd)) & 16384)) {
#line 178
          if (! ((int )((unsigned char )*pd) >= 160)) {
#line 179
            *pd = (char )'?';
          }
        }
#line 180
        pd ++;
      }
      while_break___2: /* CIL Label */ ;
      }
    } else {
      {
#line 184
      p = safe_strdup((char const   *)d);
#line 185
      pp = p;
#line 186
      tmp___10 = strlen((char const   *)d);
#line 186
      in = tmp___10 + 1UL;
#line 187
      pd = d;
#line 189
      len = dlen;
      }
      {
#line 190
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 190
        if (*pd) {
          {
#line 190
          tmp___12 = iconv(cd, (char **/* __restrict  */)(& pp), (size_t */* __restrict  */)(& in),
                           (char **/* __restrict  */)(& pd), (size_t */* __restrict  */)(& len));
          }
#line 190
          if (! (tmp___12 == 0xffffffffffffffffUL)) {
#line 190
            goto while_break___3;
          }
        } else {
#line 190
          goto while_break___3;
        }
        {
#line 192
        tmp___11 = __errno_location();
        }
#line 192
        if (*tmp___11 == 7) {
#line 193
          goto while_break___3;
        }
#line 195
        *pd = (char )'?';
#line 196
        pp ++;
#line 197
        in --;
#line 198
        pd ++;
#line 199
        len --;
      }
      while_break___3: /* CIL Label */ ;
      }
      {
#line 201
      iconv(cd, (char **/* __restrict  */)((void *)0), (size_t */* __restrict  */)((void *)0),
            (char **/* __restrict  */)(& pd), (size_t */* __restrict  */)(& len));
#line 202
      iconv_close(cd);
#line 203
      safe_free((void *)(& p));
      }
    }
    {
#line 205
    safe_free((void *)(& fromcharset));
    }
  }
#line 208
  return (0);
}
}
#line 147 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 263 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strrchr)(char const   *__s ,
                                                                                                int __c )  __attribute__((__pure__)) ;
#line 287 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) access)(char const   *__name ,
                                                                                             int __type ) ;
#line 353
extern int close(int __fd ) ;
#line 497
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) chdir)(char const   *__path ) ;
#line 628
extern  __attribute__((__nothrow__)) __pid_t ( __attribute__((__leaf__)) getpid)(void) ;
#line 790
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) link)(char const   *__from ,
                                                                                             char const   *__to ) ;
#line 809
extern  __attribute__((__nothrow__)) ssize_t ( __attribute__((__nonnull__(1,2), __leaf__)) readlink)(char const   * __restrict  __path ,
                                                                                                     char * __restrict  __buf ,
                                                                                                     size_t __len ) ;
#line 826
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) unlink)(char const   *__name ) ;
#line 57 "/usr/include/getopt.h"
extern char *optarg ;
#line 71
extern int optind ;
#line 150
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) getopt)(int ___argc ,
                                                                             char * const  *___argv ,
                                                                             char const   *__shortopts ) ;
#line 146 "/usr/include/fcntl.h"
extern int ( __attribute__((__nonnull__(1))) open)(char const   *__file , int __oflag 
                                                   , ...) ;
#line 209 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) stat)(char const   * __restrict  __file ,
                                                                                             struct stat * __restrict  __buf ) ;
#line 214
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2), __leaf__)) fstat)(int __fd ,
                                                                                            struct stat *__buf ) ;
#line 263
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) lstat)(char const   * __restrict  __file ,
                                                                                              struct stat * __restrict  __buf ) ;
#line 81 "/usr/include/x86_64-linux-gnu/sys/utsname.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) uname)(struct utsname *__name ) ;
#line 54 "/home/wheatley/newnew/temp/lbdb-0.38ubuntu1/dotlock.c"
static int DotlockFlags  ;
#line 55 "/home/wheatley/newnew/temp/lbdb-0.38ubuntu1/dotlock.c"
static int Retry  =    5;
#line 57 "/home/wheatley/newnew/temp/lbdb-0.38ubuntu1/dotlock.c"
static char *Hostname  ;
#line 59
static int dotlock_deference_symlink(char *d , size_t l , char const   *path ) ;
#line 60
static int dotlock_prepare(char *bn , size_t l , char const   *f , int _fd ) ;
#line 61
static int dotlock_check_stats(struct stat *fsb , struct stat *lsb ) ;
#line 62
static int dotlock_dispatch(char const   *f , int fd ) ;
#line 64
static void usage(char const   *av0 ) ;
#line 66
static void dotlock_expand_link(char *newpath , char const   *path , char const   *link___0 ) ;
#line 73
static int dotlock_try(void) ;
#line 74
static int dotlock_unlock(char const   *realpath___0 ) ;
#line 75
static int dotlock_unlink(char const   *realpath___0 ) ;
#line 76
static int dotlock_lock(char const   *realpath___0 ) ;
#line 123 "/home/wheatley/newnew/temp/lbdb-0.38ubuntu1/dotlock.c"
static int dotlock_dispatch(char const   *f , int fd ) 
{ 
  char realpath___0[256] ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  {
#line 138
  tmp = dotlock_prepare(realpath___0, sizeof(realpath___0), f, fd);
  }
#line 138
  if (tmp != 0) {
#line 139
    return (1);
  }
#line 143
  if (DotlockFlags & 1) {
    {
#line 144
    tmp___0 = dotlock_try();
    }
#line 144
    return (tmp___0);
  } else
#line 145
  if (DotlockFlags & (1 << 1)) {
    {
#line 146
    tmp___1 = dotlock_unlock((char const   *)(realpath___0));
    }
#line 146
    return (tmp___1);
  } else
#line 147
  if (DotlockFlags & (1 << 5)) {
    {
#line 148
    tmp___2 = dotlock_unlink((char const   *)(realpath___0));
    }
#line 148
    return (tmp___2);
  } else {
    {
#line 150
    tmp___3 = dotlock_lock((char const   *)(realpath___0));
    }
#line 150
    return (tmp___3);
  }
}
}
#line 161 "/home/wheatley/newnew/temp/lbdb-0.38ubuntu1/dotlock.c"
static void usage(char const   *av0 ) 
{ 


  {
  {
#line 164
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"usage: %s [-t|-f|-u|-d] [-r <retries>] file\n",
          av0);
#line 166
  fputs((char const   */* __restrict  */)"\noptions:\n  -t\t\ttry\n  -f\t\tforce\n  -u\t\tunlock\n  -d\t\tunlink\n  -r <retries>\tRetry locking\n",
        (FILE */* __restrict  */)stderr);
#line 174
  exit(1);
  }
}
}
#line 226 "/home/wheatley/newnew/temp/lbdb-0.38ubuntu1/dotlock.c"
static int dotlock_check_stats(struct stat *fsb , struct stat *lsb ) 
{ 


  {
#line 234
  if ((lsb->st_mode & 61440U) == 40960U) {
#line 235
    return (-1);
  } else
#line 234
  if ((fsb->st_mode & 61440U) == 40960U) {
#line 235
    return (-1);
  }
#line 237
  if (lsb->st_dev != fsb->st_dev) {
#line 247
    return (-1);
  } else
#line 237
  if (lsb->st_ino != fsb->st_ino) {
#line 247
    return (-1);
  } else
#line 237
  if (lsb->st_mode != fsb->st_mode) {
#line 247
    return (-1);
  } else
#line 237
  if (lsb->st_nlink != fsb->st_nlink) {
#line 247
    return (-1);
  } else
#line 237
  if (lsb->st_uid != fsb->st_uid) {
#line 247
    return (-1);
  } else
#line 237
  if (lsb->st_gid != fsb->st_gid) {
#line 247
    return (-1);
  } else
#line 237
  if (lsb->st_rdev != fsb->st_rdev) {
#line 247
    return (-1);
  } else
#line 237
  if (lsb->st_size != fsb->st_size) {
#line 247
    return (-1);
  }
#line 250
  return (0);
}
}
#line 253 "/home/wheatley/newnew/temp/lbdb-0.38ubuntu1/dotlock.c"
static int dotlock_prepare(char *bn , size_t l , char const   *f , int _fd ) 
{ 
  struct stat fsb ;
  struct stat lsb ;
  char realpath___0[256] ;
  char *basename ;
  char *dirname ;
  char *p ;
  int fd ;
  int r ;
  int tmp ;
  size_t tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  {
#line 263
  tmp = dotlock_deference_symlink(realpath___0, sizeof(realpath___0), f);
  }
#line 263
  if (tmp == -1) {
#line 264
    return (-1);
  }
  {
#line 266
  p = strrchr((char const   *)(realpath___0), '/');
  }
#line 266
  if (p) {
#line 268
    *p = (char )'\000';
#line 269
    basename = p + 1;
#line 270
    dirname = realpath___0;
  } else {
#line 274
    basename = realpath___0;
#line 275
    dirname = (char *)".";
  }
  {
#line 278
  tmp___0 = strlen((char const   *)basename);
  }
#line 278
  if (tmp___0 + 1UL > l) {
#line 279
    return (-1);
  }
  {
#line 281
  strncpy((char */* __restrict  */)bn, (char const   */* __restrict  */)basename,
          l);
#line 281
  *((bn + l) - 1) = (char)0;
#line 283
  tmp___1 = chdir((char const   *)dirname);
  }
#line 283
  if (tmp___1 == -1) {
#line 284
    return (-1);
  }
#line 286
  if (_fd != -1) {
#line 287
    fd = _fd;
  } else {
    {
#line 288
    fd = open((char const   *)basename, 0);
    }
#line 288
    if (fd == -1) {
#line 289
      return (-1);
    }
  }
  {
#line 291
  r = fstat(fd, & fsb);
  }
#line 293
  if (_fd == -1) {
    {
#line 294
    close(fd);
    }
  }
#line 296
  if (r == -1) {
#line 297
    return (-1);
  }
  {
#line 299
  tmp___2 = lstat((char const   */* __restrict  */)basename, (struct stat */* __restrict  */)(& lsb));
  }
#line 299
  if (tmp___2 == -1) {
#line 300
    return (-1);
  }
  {
#line 302
  tmp___3 = dotlock_check_stats(& fsb, & lsb);
  }
#line 302
  if (tmp___3 == -1) {
#line 303
    return (-1);
  }
#line 305
  return (0);
}
}
#line 316 "/home/wheatley/newnew/temp/lbdb-0.38ubuntu1/dotlock.c"
static void dotlock_expand_link(char *newpath , char const   *path , char const   *link___0 ) 
{ 
  char const   *lb ;
  size_t len ;
  char *tmp ;

  {
#line 319
  lb = (char const   *)((void *)0);
#line 323
  if ((int const   )*link___0 == 47) {
    {
#line 325
    strncpy((char */* __restrict  */)newpath, (char const   */* __restrict  */)link___0,
            (size_t )256);
#line 325
    *((newpath + 256) - 1) = (char)0;
    }
#line 326
    return;
  }
  {
#line 329
  tmp = strrchr(path, '/');
#line 329
  lb = (char const   *)tmp;
  }
#line 329
  if ((unsigned long )lb == (unsigned long )((void *)0)) {
    {
#line 332
    strncpy((char */* __restrict  */)newpath, (char const   */* __restrict  */)link___0,
            (size_t )256);
#line 332
    *((newpath + 256) - 1) = (char)0;
    }
#line 333
    return;
  }
  {
#line 336
  len = (size_t )((lb - path) + 1L);
#line 337
  memcpy((void */* __restrict  */)newpath, (void const   */* __restrict  */)path,
         len);
#line 338
  strncpy((char */* __restrict  */)(newpath + len), (char const   */* __restrict  */)link___0,
          256UL - len);
#line 338
  *(((newpath + len) + (256UL - len)) - 1) = (char)0;
  }
#line 339
  return;
}
}
#line 349 "/home/wheatley/newnew/temp/lbdb-0.38ubuntu1/dotlock.c"
static int dotlock_deference_symlink(char *d , size_t l , char const   *path ) 
{ 
  struct stat sb ;
  char realpath___0[256] ;
  char const   *pathptr ;
  int count ;
  int tmp ;
  char linkfile[256] ;
  char linkpath[256] ;
  int len ;
  ssize_t tmp___0 ;
  int tmp___1 ;

  {
#line 354
  pathptr = path;
#line 355
  count = 0;
  {
#line 357
  while (1) {
    while_continue: /* CIL Label */ ;
#line 357
    tmp___1 = count;
#line 357
    count ++;
#line 357
    if (! (tmp___1 < 1024)) {
#line 357
      goto while_break;
    }
    {
#line 359
    tmp = lstat((char const   */* __restrict  */)pathptr, (struct stat */* __restrict  */)(& sb));
    }
#line 359
    if (tmp == -1) {
#line 362
      return (-1);
    }
#line 365
    if ((sb.st_mode & 61440U) == 40960U) {
      {
#line 371
      tmp___0 = readlink((char const   */* __restrict  */)pathptr, (char */* __restrict  */)(linkfile),
                         sizeof(linkfile));
#line 371
      len = (int )tmp___0;
      }
#line 371
      if (len == -1) {
#line 374
        return (-1);
      }
      {
#line 377
      linkfile[len] = (char )'\000';
#line 378
      dotlock_expand_link(linkpath, pathptr, (char const   *)(linkfile));
#line 379
      strncpy((char */* __restrict  */)(realpath___0), (char const   */* __restrict  */)(linkpath),
              sizeof(realpath___0));
#line 379
      *((realpath___0 + sizeof(realpath___0)) - 1) = (char)0;
#line 380
      pathptr = (char const   *)(realpath___0);
      }
    } else {
#line 383
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 386
  strncpy((char */* __restrict  */)d, (char const   */* __restrict  */)pathptr, l);
#line 386
  *((d + l) - 1) = (char)0;
  }
#line 387
  return (0);
}
}
#line 401 "/home/wheatley/newnew/temp/lbdb-0.38ubuntu1/dotlock.c"
static int dotlock_lock(char const   *realpath___0 ) 
{ 
  char lockfile[1280] ;
  char nfslockfile[1280] ;
  size_t prev_size ;
  int fd ;
  int count ;
  int hard_count ;
  struct stat sb ;
  time_t t ;
  __pid_t tmp ;
  int *tmp___0 ;
  int tmp___1 ;
  time_t tmp___2 ;
  int tmp___3 ;

  {
  {
#line 406
  prev_size = (size_t )0;
#line 408
  count = 0;
#line 409
  hard_count = 0;
#line 413
  tmp = getpid();
#line 413
  sprintf((char */* __restrict  */)(nfslockfile), (char const   */* __restrict  */)"%s.%s.%d",
          realpath___0, Hostname, tmp);
#line 414
  sprintf((char */* __restrict  */)(lockfile), (char const   */* __restrict  */)"%s.lock",
          realpath___0);
#line 417
  unlink((char const   *)(nfslockfile));
  }
  {
#line 419
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 419
    fd = open((char const   *)(nfslockfile), 193, 0);
    }
#line 419
    if (! (fd < 0)) {
#line 419
      goto while_break;
    }
    {
#line 421
    tmp___0 = __errno_location();
    }
#line 421
    if (*tmp___0 != 11) {
#line 424
      return (1);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 430
  close(fd);
  }
  {
#line 432
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 432
    tmp___3 = hard_count;
#line 432
    hard_count ++;
#line 432
    if (! (tmp___3 < 10)) {
#line 432
      goto while_break___0;
    }
    {
#line 434
    link((char const   *)(nfslockfile), (char const   *)(lockfile));
#line 436
    tmp___1 = stat((char const   */* __restrict  */)(nfslockfile), (struct stat */* __restrict  */)(& sb));
    }
#line 436
    if (tmp___1 != 0) {
#line 439
      return (1);
    }
#line 442
    if (sb.st_nlink == 2UL) {
#line 443
      goto while_break___0;
    }
#line 445
    if (count == 0) {
#line 446
      prev_size = (size_t )sb.st_size;
    }
#line 448
    if (prev_size == (size_t )sb.st_size) {
#line 448
      count ++;
#line 448
      if (count > Retry) {
#line 450
        if (DotlockFlags & (1 << 3)) {
          {
#line 452
          unlink((char const   *)(lockfile));
#line 453
          count = 0;
          }
#line 454
          goto while_continue___0;
        } else {
          {
#line 458
          unlink((char const   *)(nfslockfile));
          }
#line 459
          return (3);
        }
      }
    }
    {
#line 463
    prev_size = (size_t )sb.st_size;
#line 469
    t = time((time_t *)((void *)0));
    }
    {
#line 470
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 471
      sleep(1U);
#line 470
      tmp___2 = time((time_t *)((void *)0));
      }
#line 470
      if (! (tmp___2 == t)) {
#line 470
        goto while_break___1;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 475
  unlink((char const   *)(nfslockfile));
  }
#line 477
  return (0);
}
}
#line 488 "/home/wheatley/newnew/temp/lbdb-0.38ubuntu1/dotlock.c"
static int dotlock_unlock(char const   *realpath___0 ) 
{ 
  char lockfile[1280] ;
  int i ;

  {
  {
#line 494
  sprintf((char */* __restrict  */)(lockfile), (char const   */* __restrict  */)"%s.lock",
          realpath___0);
#line 496
  i = unlink((char const   *)(lockfile));
  }
#line 498
  if (i == -1) {
#line 499
    return (1);
  }
#line 501
  return (0);
}
}
#line 506 "/home/wheatley/newnew/temp/lbdb-0.38ubuntu1/dotlock.c"
static int dotlock_unlink(char const   *realpath___0 ) 
{ 
  struct stat lsb ;
  int i ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 510
  i = -1;
#line 512
  tmp = dotlock_lock(realpath___0);
  }
#line 512
  if (tmp != 0) {
#line 513
    return (1);
  }
  {
#line 515
  i = lstat((char const   */* __restrict  */)realpath___0, (struct stat */* __restrict  */)(& lsb));
  }
#line 515
  if (i == 0) {
#line 515
    if (lsb.st_size == 0L) {
      {
#line 516
      unlink(realpath___0);
      }
    }
  }
  {
#line 518
  dotlock_unlock(realpath___0);
  }
#line 520
  if (i == 0) {
#line 520
    tmp___0 = 0;
  } else {
#line 520
    tmp___0 = 1;
  }
#line 520
  return (tmp___0);
}
}
#line 531 "/home/wheatley/newnew/temp/lbdb-0.38ubuntu1/dotlock.c"
static int dotlock_try(void) 
{ 
  int tmp ;

  {
  {
#line 534
  tmp = access(".", 2);
  }
#line 534
  if (tmp == 0) {
#line 535
    return (0);
  }
#line 537
  return (5);
}
}
