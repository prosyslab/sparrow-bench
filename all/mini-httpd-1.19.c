/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 75 "/usr/include/time.h"
typedef __time_t time_t;
#line 133 "/usr/include/time.h"
struct tm {
   int tm_sec ;
   int tm_min ;
   int tm_hour ;
   int tm_mday ;
   int tm_mon ;
   int tm_year ;
   int tm_wday ;
   int tm_yday ;
   int tm_isdst ;
   long tm_gmtoff ;
   char const   *tm_zone ;
};
#line 46 "/home/wheatley/newnew/temp/mini-httpd-1.19/tdate_parse.c"
struct strlong {
   char *s ;
   long l ;
};
#line 124 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __dev_t;
#line 125 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uid_t;
#line 126 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __gid_t;
#line 127 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __ino_t;
#line 129 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __mode_t;
#line 130 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __nlink_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 133 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __pid_t;
#line 141 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __suseconds_t;
#line 153 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blksize_t;
#line 158 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blkcnt_t;
#line 172 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __ssize_t;
#line 175 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __syscall_slong_t;
#line 189 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __socklen_t;
#line 220 "/usr/include/unistd.h"
typedef __ssize_t ssize_t;
#line 232 "/usr/include/unistd.h"
typedef __gid_t gid_t;
#line 237 "/usr/include/unistd.h"
typedef __uid_t uid_t;
#line 243 "/usr/include/unistd.h"
typedef __off_t off_t;
#line 260 "/usr/include/unistd.h"
typedef __pid_t pid_t;
#line 274 "/usr/include/unistd.h"
typedef __socklen_t socklen_t;
#line 120 "/usr/include/time.h"
struct timespec {
   __time_t tv_sec ;
   __syscall_slong_t tv_nsec ;
};
#line 30 "/usr/include/x86_64-linux-gnu/bits/time.h"
struct timeval {
   __time_t tv_sec ;
   __suseconds_t tv_usec ;
};
#line 54 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef long __fd_mask;
#line 64 "/usr/include/x86_64-linux-gnu/sys/select.h"
struct __anonstruct_fd_set_13 {
   __fd_mask __fds_bits[1024 / (8 * (int )sizeof(__fd_mask ))] ;
};
#line 64 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef struct __anonstruct_fd_set_13 fd_set;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 85 "/usr/include/signal.h"
typedef void (*__sighandler_t)(int  );
#line 46 "/usr/include/x86_64-linux-gnu/bits/stat.h"
struct stat {
   __dev_t st_dev ;
   __ino_t st_ino ;
   __nlink_t st_nlink ;
   __mode_t st_mode ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   int __pad0 ;
   __dev_t st_rdev ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   __syscall_slong_t __glibc_reserved[3] ;
};
#line 49 "/usr/include/pwd.h"
struct passwd {
   char *pw_name ;
   char *pw_passwd ;
   __uid_t pw_uid ;
   __gid_t pw_gid ;
   char *pw_gecos ;
   char *pw_dir ;
   char *pw_shell ;
};
#line 28 "/usr/include/x86_64-linux-gnu/bits/sockaddr.h"
typedef unsigned short sa_family_t;
#line 149 "/usr/include/x86_64-linux-gnu/bits/socket.h"
struct sockaddr {
   sa_family_t sa_family ;
   char sa_data[14] ;
};
#line 162 "/usr/include/x86_64-linux-gnu/bits/socket.h"
struct sockaddr_storage {
   sa_family_t ss_family ;
   unsigned long __ss_align ;
   char __ss_padding[128UL - 2UL * sizeof(unsigned long )] ;
};
#line 48 "/usr/include/stdint.h"
typedef unsigned char uint8_t;
#line 49 "/usr/include/stdint.h"
typedef unsigned short uint16_t;
#line 51 "/usr/include/stdint.h"
typedef unsigned int uint32_t;
#line 30 "/usr/include/netinet/in.h"
typedef uint32_t in_addr_t;
#line 31 "/usr/include/netinet/in.h"
struct in_addr {
   in_addr_t s_addr ;
};
#line 117 "/usr/include/netinet/in.h"
typedef uint16_t in_port_t;
#line 209 "/usr/include/netinet/in.h"
union __anonunion___in6_u_59 {
   uint8_t __u6_addr8[16] ;
   uint16_t __u6_addr16[8] ;
   uint32_t __u6_addr32[4] ;
};
#line 209 "/usr/include/netinet/in.h"
struct in6_addr {
   union __anonunion___in6_u_59 __in6_u ;
};
#line 237 "/usr/include/netinet/in.h"
struct sockaddr_in {
   sa_family_t sin_family ;
   in_port_t sin_port ;
   struct in_addr sin_addr ;
   unsigned char sin_zero[((sizeof(struct sockaddr ) - sizeof(unsigned short )) - sizeof(in_port_t )) - sizeof(struct in_addr )] ;
};
#line 252 "/usr/include/netinet/in.h"
struct sockaddr_in6 {
   sa_family_t sin6_family ;
   in_port_t sin6_port ;
   uint32_t sin6_flowinfo ;
   struct in6_addr sin6_addr ;
   uint32_t sin6_scope_id ;
};
#line 567 "/usr/include/netdb.h"
struct addrinfo {
   int ai_flags ;
   int ai_family ;
   int ai_socktype ;
   int ai_protocol ;
   socklen_t ai_addrlen ;
   struct sockaddr *ai_addr ;
   char *ai_canonname ;
   struct addrinfo *ai_next ;
};
#line 22 "/usr/include/x86_64-linux-gnu/bits/dirent.h"
struct dirent {
   __ino_t d_ino ;
   __off_t d_off ;
   unsigned short d_reclen ;
   unsigned char d_type ;
   char d_name[256] ;
};
#line 161 "/home/wheatley/newnew/temp/mini-httpd-1.19/mini_httpd.c"
union __anonunion_usockaddr_66 {
   struct sockaddr sa ;
   struct sockaddr_in sa_in ;
   struct sockaddr_in6 sa_in6 ;
   struct sockaddr_storage sa_stor ;
};
#line 161 "/home/wheatley/newnew/temp/mini-httpd-1.19/mini_httpd.c"
typedef union __anonunion_usockaddr_66 usockaddr;
#line 2882 "/home/wheatley/newnew/temp/mini-httpd-1.19/mini_httpd.c"
struct mime_entry {
   char *ext ;
   size_t ext_len ;
   char *val ;
   size_t val_len ;
};
#line 236 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strchr)(char const   *__s ,
                                                                                               int __c )  __attribute__((__pure__)) ;
#line 285
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1,2), __leaf__)) strcspn)(char const   *__s ,
                                                                                                   char const   *__reject )  __attribute__((__pure__)) ;
#line 399
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 34 "/home/wheatley/newnew/temp/mini-httpd-1.19/match.h"
int match(char const   *pattern , char const   *string ) ;
#line 35 "/home/wheatley/newnew/temp/mini-httpd-1.19/match.c"
static int match_one(char const   *pattern , int patternlen , char const   *string ) ;
#line 37 "/home/wheatley/newnew/temp/mini-httpd-1.19/match.c"
int match(char const   *pattern , char const   *string ) 
{ 
  char const   *or ;
  char *tmp ;
  size_t tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 42
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 44
    tmp = strchr(pattern, '|');
#line 44
    or = (char const   *)tmp;
    }
#line 45
    if ((unsigned long )or == (unsigned long )((char *)0)) {
      {
#line 46
      tmp___0 = strlen(pattern);
#line 46
      tmp___1 = match_one(pattern, (int )tmp___0, string);
      }
#line 46
      return (tmp___1);
    }
    {
#line 47
    tmp___2 = match_one(pattern, (int )(or - pattern), string);
    }
#line 47
    if (tmp___2) {
#line 48
      return (1);
    }
#line 49
    pattern = or + 1;
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 54 "/home/wheatley/newnew/temp/mini-httpd-1.19/match.c"
static int match_one(char const   *pattern , int patternlen , char const   *string ) 
{ 
  char const   *p ;
  int i ;
  int pl ;
  size_t tmp ;
  size_t tmp___0 ;
  int tmp___1 ;

  {
#line 59
  p = pattern;
  {
#line 59
  while (1) {
    while_continue: /* CIL Label */ ;
#line 59
    if (! (p - pattern < (long )patternlen)) {
#line 59
      goto while_break;
    }
#line 61
    if ((int const   )*p == 63) {
#line 61
      if ((int const   )*string != 0) {
#line 62
        goto __Cont;
      }
    }
#line 63
    if ((int const   )*p == 42) {
#line 66
      p ++;
#line 67
      if ((int const   )*p == 42) {
        {
#line 70
        p ++;
#line 71
        tmp = strlen(string);
#line 71
        i = (int )tmp;
        }
      } else {
        {
#line 75
        tmp___0 = strcspn(string, "/");
#line 75
        i = (int )tmp___0;
        }
      }
#line 76
      pl = (int )((long )patternlen - (p - pattern));
      {
#line 77
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 77
        if (! (i >= 0)) {
#line 77
          goto while_break___0;
        }
        {
#line 78
        tmp___1 = match_one(p, pl, string + i);
        }
#line 78
        if (tmp___1) {
#line 79
          return (1);
        }
#line 77
        i --;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 80
      return (0);
    }
#line 82
    if ((int const   )*p != (int const   )*string) {
#line 83
      return (0);
    }
    __Cont: /* CIL Label */ 
#line 59
    p ++;
#line 59
    string ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 85
  if ((int const   )*string == 0) {
#line 86
    return (1);
  }
#line 87
  return (0);
}
}
#line 79 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) unsigned short const   **( __attribute__((__leaf__)) __ctype_b_loc)(void)  __attribute__((__const__)) ;
#line 124
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) tolower)(int __c ) ;
#line 433 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) sscanf)(char const   * __restrict  __s ,
                                                                             char const   * __restrict  __format 
                                                                             , ...)  __asm__("__isoc99_sscanf")  ;
#line 765 "/usr/include/stdlib.h"
extern void ( __attribute__((__nonnull__(1,4))) qsort)(void *__base , size_t __nmemb ,
                                                       size_t __size , int (*__compar)(void const   * ,
                                                                                       void const   * ) ) ;
#line 66 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memset)(void *__s ,
                                                                                               int __c ,
                                                                                               size_t __n ) ;
#line 144
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 31 "/home/wheatley/newnew/temp/mini-httpd-1.19/tdate_parse.h"
time_t tdate_parse(char *str___0 ) ;
#line 52 "/home/wheatley/newnew/temp/mini-httpd-1.19/tdate_parse.c"
static void pound_case(char *str___0 ) 
{ 
  int tmp ;
  unsigned short const   **tmp___0 ;

  {
  {
#line 55
  while (1) {
    while_continue: /* CIL Label */ ;
#line 55
    if (! ((int )*str___0 != 0)) {
#line 55
      goto while_break;
    }
    {
#line 57
    tmp___0 = __ctype_b_loc();
    }
#line 57
    if ((int const   )*(*tmp___0 + (int )*str___0) & 256) {
      {
#line 58
      tmp = tolower((int )*str___0);
#line 58
      *str___0 = (char )tmp;
      }
    }
#line 55
    str___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 60
  return;
}
}
#line 62 "/home/wheatley/newnew/temp/mini-httpd-1.19/tdate_parse.c"
static int strlong_compare(char *v1 , char *v2 ) 
{ 
  int tmp ;

  {
  {
#line 67
  tmp = strcmp((char const   *)((struct strlong *)v1)->s, (char const   *)((struct strlong *)v2)->s);
  }
#line 67
  return (tmp);
}
}
#line 71 "/home/wheatley/newnew/temp/mini-httpd-1.19/tdate_parse.c"
static int strlong_search(char *str___0 , struct strlong *tab , int n , long *lP ) 
{ 
  int i ;
  int h ;
  int l ;
  int r ;

  {
#line 76
  l = 0;
#line 77
  h = n - 1;
  {
#line 78
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 80
    i = (h + l) / 2;
#line 81
    r = strcmp((char const   *)str___0, (char const   *)(tab + i)->s);
    }
#line 82
    if (r < 0) {
#line 83
      h = i - 1;
    } else
#line 84
    if (r > 0) {
#line 85
      l = i + 1;
    } else {
#line 88
      *lP = (tab + i)->l;
#line 89
      return (1);
    }
#line 91
    if (h < l) {
#line 92
      return (0);
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 100
static int scan_wday(char *str_wday , long *tm_wdayP ) ;
#line 100 "/home/wheatley/newnew/temp/mini-httpd-1.19/tdate_parse.c"
static struct strlong wday_tab[14]  = 
#line 100
  {      {(char *)"sun", 0L}, 
        {(char *)"sunday", 0L}, 
        {(char *)"mon", 1L}, 
        {(char *)"monday", 1L}, 
        {(char *)"tue", 2L}, 
        {(char *)"tuesday", 2L}, 
        {(char *)"wed", 3L}, 
        {(char *)"wednesday", 3L}, 
        {(char *)"thu", 4L}, 
        {(char *)"thursday", 4L}, 
        {(char *)"fri", 5L}, 
        {(char *)"friday", 5L}, 
        {(char *)"sat", 6L}, 
        {(char *)"saturday", 6L}};
#line 109 "/home/wheatley/newnew/temp/mini-httpd-1.19/tdate_parse.c"
static int sorted  =    0;
#line 97 "/home/wheatley/newnew/temp/mini-httpd-1.19/tdate_parse.c"
static int scan_wday(char *str_wday , long *tm_wdayP ) 
{ 
  int tmp ;

  {
#line 111
  if (! sorted) {
    {
#line 113
    qsort((void *)(wday_tab), sizeof(wday_tab) / sizeof(struct strlong ), sizeof(struct strlong ),
          (int (*)(void const   * , void const   * ))(& strlong_compare));
#line 116
    sorted = 1;
    }
  }
  {
#line 118
  pound_case(str_wday);
#line 119
  tmp = strlong_search(str_wday, wday_tab, (int )(sizeof(wday_tab) / sizeof(struct strlong )),
                       tm_wdayP);
  }
#line 119
  return (tmp);
}
}
#line 127
static int scan_mon(char *str_mon , long *tm_monP ) ;
#line 127 "/home/wheatley/newnew/temp/mini-httpd-1.19/tdate_parse.c"
static struct strlong mon_tab[23]  = 
#line 127
  {      {(char *)"jan", 0L}, 
        {(char *)"january", 0L}, 
        {(char *)"feb", 1L}, 
        {(char *)"february", 1L}, 
        {(char *)"mar", 2L}, 
        {(char *)"march", 2L}, 
        {(char *)"apr", 3L}, 
        {(char *)"april", 3L}, 
        {(char *)"may", 4L}, 
        {(char *)"jun", 5L}, 
        {(char *)"june", 5L}, 
        {(char *)"jul", 6L}, 
        {(char *)"july", 6L}, 
        {(char *)"aug", 7L}, 
        {(char *)"august", 7L}, 
        {(char *)"sep", 8L}, 
        {(char *)"september", 8L}, 
        {(char *)"oct", 9L}, 
        {(char *)"october", 9L}, 
        {(char *)"nov", 10L}, 
        {(char *)"november", 10L}, 
        {(char *)"dec", 11L}, 
        {(char *)"december", 11L}};
#line 141 "/home/wheatley/newnew/temp/mini-httpd-1.19/tdate_parse.c"
static int sorted___0  =    0;
#line 124 "/home/wheatley/newnew/temp/mini-httpd-1.19/tdate_parse.c"
static int scan_mon(char *str_mon , long *tm_monP ) 
{ 
  int tmp ;

  {
#line 143
  if (! sorted___0) {
    {
#line 145
    qsort((void *)(mon_tab), sizeof(mon_tab) / sizeof(struct strlong ), sizeof(struct strlong ),
          (int (*)(void const   * , void const   * ))(& strlong_compare));
#line 148
    sorted___0 = 1;
    }
  }
  {
#line 150
  pound_case(str_mon);
#line 151
  tmp = strlong_search(str_mon, mon_tab, (int )(sizeof(mon_tab) / sizeof(struct strlong )),
                       tm_monP);
  }
#line 151
  return (tmp);
}
}
#line 156 "/home/wheatley/newnew/temp/mini-httpd-1.19/tdate_parse.c"
static int is_leap(int year ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 159
  if (year % 400) {
#line 159
    if (year % 100) {
#line 159
      if (year % 4) {
#line 159
        tmp = 0;
      } else {
#line 159
        tmp = 1;
      }
#line 159
      tmp___0 = tmp;
    } else {
#line 159
      tmp___0 = 0;
    }
#line 159
    tmp___1 = tmp___0;
  } else {
#line 159
    tmp___1 = 1;
  }
#line 159
  return (tmp___1);
}
}
#line 168
static time_t tm_to_time(struct tm *tmP ) ;
#line 168 "/home/wheatley/newnew/temp/mini-httpd-1.19/tdate_parse.c"
static int monthtab[12]  = 
#line 168
  {      0,      31,      59,      90, 
        120,      151,      181,      212, 
        243,      273,      304,      334};
#line 164 "/home/wheatley/newnew/temp/mini-httpd-1.19/tdate_parse.c"
static time_t tm_to_time(struct tm *tmP ) 
{ 
  time_t t ;
  int tmp ;

  {
#line 172
  t = (time_t )((tmP->tm_year - 70) * 365);
#line 174
  t += (time_t )((tmP->tm_year - 69) / 4);
#line 176
  t += (time_t )monthtab[tmP->tm_mon];
#line 178
  if (tmP->tm_mon >= 2) {
    {
#line 178
    tmp = is_leap(tmP->tm_year + 1900);
    }
#line 178
    if (tmp) {
#line 179
      t ++;
    }
  }
#line 181
  t += (time_t )(tmP->tm_mday - 1);
#line 183
  t = t * 24L + (time_t )tmP->tm_hour;
#line 184
  t = t * 60L + (time_t )tmP->tm_min;
#line 185
  t = t * 60L + (time_t )tmP->tm_sec;
#line 187
  return (t);
}
}
#line 191 "/home/wheatley/newnew/temp/mini-httpd-1.19/tdate_parse.c"
time_t tdate_parse(char *str___0 ) 
{ 
  struct tm tm ;
  char *cp ;
  char str_mon[500] ;
  char str_wday[500] ;
  int tm_sec ;
  int tm_min ;
  int tm_hour ;
  int tm_mday ;
  int tm_year ;
  long tm_mon ;
  long tm_wday ;
  time_t t ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;

  {
  {
#line 202
  memset((void *)((char *)(& tm)), 0, sizeof(struct tm ));
#line 205
  cp = str___0;
  }
  {
#line 205
  while (1) {
    while_continue: /* CIL Label */ ;
#line 205
    if (! ((int )*cp == 32)) {
#line 205
      if (! ((int )*cp == 9)) {
#line 205
        goto while_break;
      }
    }
#line 206
    goto __Cont;
    __Cont: /* CIL Label */ 
#line 205
    cp ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 214
  tmp___14 = sscanf((char const   */* __restrict  */)cp, (char const   */* __restrict  */)"%d-%400[a-zA-Z]-%d %d:%d:%d GMT",
                    & tm_mday, str_mon, & tm_year, & tm_hour, & tm_min, & tm_sec);
  }
#line 214
  if (tmp___14 == 6) {
    {
#line 214
    tmp___15 = scan_mon(str_mon, & tm_mon);
    }
#line 214
    if (tmp___15) {
#line 219
      tm.tm_mday = tm_mday;
#line 220
      tm.tm_mon = (int )tm_mon;
#line 221
      tm.tm_year = tm_year;
#line 222
      tm.tm_hour = tm_hour;
#line 223
      tm.tm_min = tm_min;
#line 224
      tm.tm_sec = tm_sec;
    } else {
#line 214
      goto _L___6;
    }
  } else {
    _L___6: /* CIL Label */ 
    {
#line 228
    tmp___12 = sscanf((char const   */* __restrict  */)cp, (char const   */* __restrict  */)"%d %400[a-zA-Z] %d %d:%d:%d GMT",
                      & tm_mday, str_mon, & tm_year, & tm_hour, & tm_min, & tm_sec);
    }
#line 228
    if (tmp___12 == 6) {
      {
#line 228
      tmp___13 = scan_mon(str_mon, & tm_mon);
      }
#line 228
      if (tmp___13) {
#line 233
        tm.tm_mday = tm_mday;
#line 234
        tm.tm_mon = (int )tm_mon;
#line 235
        tm.tm_year = tm_year;
#line 236
        tm.tm_hour = tm_hour;
#line 237
        tm.tm_min = tm_min;
#line 238
        tm.tm_sec = tm_sec;
      } else {
#line 228
        goto _L___5;
      }
    } else {
      _L___5: /* CIL Label */ 
      {
#line 242
      tmp___10 = sscanf((char const   */* __restrict  */)cp, (char const   */* __restrict  */)"%d:%d:%d GMT %d-%400[a-zA-Z]-%d",
                        & tm_hour, & tm_min, & tm_sec, & tm_mday, str_mon, & tm_year);
      }
#line 242
      if (tmp___10 == 6) {
        {
#line 242
        tmp___11 = scan_mon(str_mon, & tm_mon);
        }
#line 242
        if (tmp___11) {
#line 247
          tm.tm_hour = tm_hour;
#line 248
          tm.tm_min = tm_min;
#line 249
          tm.tm_sec = tm_sec;
#line 250
          tm.tm_mday = tm_mday;
#line 251
          tm.tm_mon = (int )tm_mon;
#line 252
          tm.tm_year = tm_year;
        } else {
#line 242
          goto _L___4;
        }
      } else {
        _L___4: /* CIL Label */ 
        {
#line 256
        tmp___8 = sscanf((char const   */* __restrict  */)cp, (char const   */* __restrict  */)"%d:%d:%d GMT %d %400[a-zA-Z] %d",
                         & tm_hour, & tm_min, & tm_sec, & tm_mday, str_mon, & tm_year);
        }
#line 256
        if (tmp___8 == 6) {
          {
#line 256
          tmp___9 = scan_mon(str_mon, & tm_mon);
          }
#line 256
          if (tmp___9) {
#line 261
            tm.tm_hour = tm_hour;
#line 262
            tm.tm_min = tm_min;
#line 263
            tm.tm_sec = tm_sec;
#line 264
            tm.tm_mday = tm_mday;
#line 265
            tm.tm_mon = (int )tm_mon;
#line 266
            tm.tm_year = tm_year;
          } else {
#line 256
            goto _L___3;
          }
        } else {
          _L___3: /* CIL Label */ 
          {
#line 270
          tmp___5 = sscanf((char const   */* __restrict  */)cp, (char const   */* __restrict  */)"%400[a-zA-Z], %d-%400[a-zA-Z]-%d %d:%d:%d GMT",
                           str_wday, & tm_mday, str_mon, & tm_year, & tm_hour, & tm_min,
                           & tm_sec);
          }
#line 270
          if (tmp___5 == 7) {
            {
#line 270
            tmp___6 = scan_wday(str_wday, & tm_wday);
            }
#line 270
            if (tmp___6) {
              {
#line 270
              tmp___7 = scan_mon(str_mon, & tm_mon);
              }
#line 270
              if (tmp___7) {
#line 276
                tm.tm_wday = (int )tm_wday;
#line 277
                tm.tm_mday = tm_mday;
#line 278
                tm.tm_mon = (int )tm_mon;
#line 279
                tm.tm_year = tm_year;
#line 280
                tm.tm_hour = tm_hour;
#line 281
                tm.tm_min = tm_min;
#line 282
                tm.tm_sec = tm_sec;
              } else {
#line 270
                goto _L___2;
              }
            } else {
#line 270
              goto _L___2;
            }
          } else {
            _L___2: /* CIL Label */ 
            {
#line 286
            tmp___2 = sscanf((char const   */* __restrict  */)cp, (char const   */* __restrict  */)"%400[a-zA-Z], %d %400[a-zA-Z] %d %d:%d:%d GMT",
                             str_wday, & tm_mday, str_mon, & tm_year, & tm_hour, & tm_min,
                             & tm_sec);
            }
#line 286
            if (tmp___2 == 7) {
              {
#line 286
              tmp___3 = scan_wday(str_wday, & tm_wday);
              }
#line 286
              if (tmp___3) {
                {
#line 286
                tmp___4 = scan_mon(str_mon, & tm_mon);
                }
#line 286
                if (tmp___4) {
#line 292
                  tm.tm_wday = (int )tm_wday;
#line 293
                  tm.tm_mday = tm_mday;
#line 294
                  tm.tm_mon = (int )tm_mon;
#line 295
                  tm.tm_year = tm_year;
#line 296
                  tm.tm_hour = tm_hour;
#line 297
                  tm.tm_min = tm_min;
#line 298
                  tm.tm_sec = tm_sec;
                } else {
#line 286
                  goto _L___0;
                }
              } else {
#line 286
                goto _L___0;
              }
            } else {
              _L___0: /* CIL Label */ 
              {
#line 302
              tmp = sscanf((char const   */* __restrict  */)cp, (char const   */* __restrict  */)"%400[a-zA-Z] %400[a-zA-Z] %d %d:%d:%d GMT %d",
                           str_wday, str_mon, & tm_mday, & tm_hour, & tm_min, & tm_sec,
                           & tm_year);
              }
#line 302
              if (tmp == 7) {
                {
#line 302
                tmp___0 = scan_wday(str_wday, & tm_wday);
                }
#line 302
                if (tmp___0) {
                  {
#line 302
                  tmp___1 = scan_mon(str_mon, & tm_mon);
                  }
#line 302
                  if (tmp___1) {
#line 308
                    tm.tm_wday = (int )tm_wday;
#line 309
                    tm.tm_mon = (int )tm_mon;
#line 310
                    tm.tm_mday = tm_mday;
#line 311
                    tm.tm_hour = tm_hour;
#line 312
                    tm.tm_min = tm_min;
#line 313
                    tm.tm_sec = tm_sec;
#line 314
                    tm.tm_year = tm_year;
                  } else {
#line 317
                    return ((time_t )-1);
                  }
                } else {
#line 317
                  return ((time_t )-1);
                }
              } else {
#line 317
                return ((time_t )-1);
              }
            }
          }
        }
      }
    }
  }
#line 319
  if (tm.tm_year > 1900) {
#line 320
    tm.tm_year -= 1900;
  } else
#line 321
  if (tm.tm_year < 70) {
#line 322
    tm.tm_year += 100;
  }
  {
#line 324
  t = tm_to_time(& tm);
  }
#line 326
  return (t);
}
}
#line 353 "/usr/include/unistd.h"
extern int close(int __fd ) ;
#line 360
extern ssize_t read(int __fd , void *__buf , size_t __nbytes ) ;
#line 366
extern ssize_t write(int __fd , void const   *__buf , size_t __n ) ;
#line 417
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) pipe)(int *__pipedes ) ;
#line 432
extern  __attribute__((__nothrow__)) unsigned int ( __attribute__((__leaf__)) alarm)(unsigned int __seconds ) ;
#line 444
extern unsigned int sleep(unsigned int __seconds ) ;
#line 478
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) fchown)(int __fd ,
                                                                             __uid_t __owner ,
                                                                             __gid_t __group ) ;
#line 497
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) chdir)(char const   *__path ) ;
#line 511
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) getcwd)(char *__buf ,
                                                                               size_t __size ) ;
#line 534
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) dup2)(int __fd ,
                                                                           int __fd2 ) ;
#line 551
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) execve)(char const   *__path ,
                                                                                               char * const  *__argv ,
                                                                                               char * const  *__envp ) ;
#line 598
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) nice)(int __inc ) ;
#line 628
extern  __attribute__((__nothrow__)) __pid_t ( __attribute__((__leaf__)) getpid)(void) ;
#line 667
extern  __attribute__((__nothrow__)) __pid_t ( __attribute__((__leaf__)) setsid)(void) ;
#line 675
extern  __attribute__((__nothrow__)) __uid_t ( __attribute__((__leaf__)) getuid)(void) ;
#line 700
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) setuid)(__uid_t __uid ) ;
#line 717
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) setgid)(__gid_t __gid ) ;
#line 756
extern  __attribute__((__nothrow__)) __pid_t fork(void) ;
#line 879
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) gethostname)(char *__name ,
                                                                                                  size_t __len ) ;
#line 937
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) daemon)(int __nochdir ,
                                                                             int __noclose ) ;
#line 944
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) chroot)(char const   *__path ) ;
#line 147 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 150
extern  __attribute__((__nothrow__)) long ( __attribute__((__nonnull__(1), __leaf__)) atol)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 106 "/usr/include/x86_64-linux-gnu/sys/select.h"
extern int select(int __nfds , fd_set * __restrict  __readfds , fd_set * __restrict  __writefds ,
                  fd_set * __restrict  __exceptfds , struct timeval * __restrict  __timeout ) ;
#line 466 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 480
extern  __attribute__((__nothrow__)) void *( __attribute__((__warn_unused_result__,
__leaf__)) realloc)(void *__ptr , size_t __size ) ;
#line 543
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 564
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) getenv)(char const   *__name ) ;
#line 170 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 237
extern int fclose(FILE *__stream ) ;
#line 242
extern int fflush(FILE *__stream ) ;
#line 272
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 362
extern int printf(char const   * __restrict  __format  , ...) ;
#line 364
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
#line 386
extern  __attribute__((__nothrow__)) int ( /* format attribute */  snprintf)(char * __restrict  __s ,
                                                                             size_t __maxlen ,
                                                                             char const   * __restrict  __format 
                                                                             , ...) ;
#line 622
extern char *fgets(char * __restrict  __s , int __n , FILE * __restrict  __stream ) ;
#line 709
extern size_t fread(void * __restrict  __ptr , size_t __size , size_t __n , FILE * __restrict  __stream ) ;
#line 846
extern void perror(char const   *__s ) ;
#line 858
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) fileno)(FILE *__stream ) ;
#line 50 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memmove)(void *__dest ,
                                                                                                  void const   *__src ,
                                                                                                  size_t __n ) ;
#line 129
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcpy)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 132
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strncpy)(char * __restrict  __dest ,
                                                                                                  char const   * __restrict  __src ,
                                                                                                  size_t __n ) ;
#line 137
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcat)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 147
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strncmp)(char const   *__s1 ,
                                                                                                char const   *__s2 ,
                                                                                                size_t __n )  __attribute__((__pure__)) ;
#line 176
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strdup)(char const   *__s )  __attribute__((__malloc__)) ;
#line 263
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strrchr)(char const   *__s ,
                                                                                                int __c )  __attribute__((__pure__)) ;
#line 289
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1,2), __leaf__)) strspn)(char const   *__s ,
                                                                                                  char const   *__accept )  __attribute__((__pure__)) ;
#line 315
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strpbrk)(char const   *__s ,
                                                                                                  char const   *__accept )  __attribute__((__pure__)) ;
#line 342
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strstr)(char const   *__haystack ,
                                                                                                 char const   *__needle )  __attribute__((__pure__)) ;
#line 534
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcasecmp)(char const   *__s1 ,
                                                                                                   char const   *__s2 )  __attribute__((__pure__)) ;
#line 538
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strncasecmp)(char const   *__s1 ,
                                                                                                    char const   *__s2 ,
                                                                                                    size_t __n )  __attribute__((__pure__)) ;
#line 175 "/usr/include/x86_64-linux-gnu/sys/syslog.h"
extern void closelog(void) ;
#line 181
extern void openlog(char const   *__ident , int __option , int __facility ) ;
#line 190
extern void ( /* format attribute */  syslog)(int __pri , char const   *__fmt  , ...) ;
#line 102 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) __sighandler_t ( __attribute__((__leaf__)) signal)(int __sig ,
                                                                                        void (*__handler)(int  ) ) ;
#line 209 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) stat)(char const   * __restrict  __file ,
                                                                                             struct stat * __restrict  __buf ) ;
#line 263
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) lstat)(char const   * __restrict  __file ,
                                                                                              struct stat * __restrict  __buf ) ;
#line 192 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) time_t ( __attribute__((__leaf__)) time)(time_t *__timer ) ;
#line 205
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__leaf__)) strftime)(char * __restrict  __s ,
                                                                                  size_t __maxsize ,
                                                                                  char const   * __restrict  __format ,
                                                                                  struct tm  const  * __restrict  __tp ) ;
#line 239
extern  __attribute__((__nothrow__)) struct tm *( __attribute__((__leaf__)) gmtime)(time_t const   *__timer ) ;
#line 243
extern  __attribute__((__nothrow__)) struct tm *( __attribute__((__leaf__)) localtime)(time_t const   *__timer ) ;
#line 293
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) tzset)(void) ;
#line 116 "/usr/include/pwd.h"
extern struct passwd *getpwnam(char const   *__name ) ;
#line 50 "/usr/include/x86_64-linux-gnu/bits/errno.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
#line 137 "/usr/include/fcntl.h"
extern int fcntl(int __fd , int __cmd  , ...) ;
#line 146
extern int ( __attribute__((__nonnull__(1))) open)(char const   *__file , int __oflag 
                                                   , ...) ;
#line 125 "/usr/include/x86_64-linux-gnu/sys/wait.h"
extern __pid_t waitpid(__pid_t __pid , int *__stat_loc , int __options ) ;
#line 113 "/usr/include/x86_64-linux-gnu/sys/socket.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) socket)(int __domain ,
                                                                             int __type ,
                                                                             int __protocol ) ;
#line 123
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) bind)(int __fd ,
                                                                           struct sockaddr  const  *__addr ,
                                                                           socklen_t __len ) ;
#line 127
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) getsockname)(int __fd ,
                                                                                  struct sockaddr * __restrict  __addr ,
                                                                                  socklen_t * __restrict  __len ) ;
#line 226
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) setsockopt)(int __fd ,
                                                                                 int __level ,
                                                                                 int __optname ,
                                                                                 void const   *__optval ,
                                                                                 socklen_t __optlen ) ;
#line 233
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) listen)(int __fd ,
                                                                             int __n ) ;
#line 243
extern int accept(int __fd , struct sockaddr * __restrict  __addr , socklen_t * __restrict  __addr_len ) ;
#line 261
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) shutdown)(int __fd ,
                                                                               int __how ) ;
#line 377 "/usr/include/netinet/in.h"
extern  __attribute__((__nothrow__)) uint32_t ( __attribute__((__leaf__)) htonl)(uint32_t __hostlong )  __attribute__((__const__)) ;
#line 662 "/usr/include/netdb.h"
extern int getaddrinfo(char const   * __restrict  __name , char const   * __restrict  __service ,
                       struct addrinfo  const  * __restrict  __req , struct addrinfo ** __restrict  __pai ) ;
#line 668
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) freeaddrinfo)(struct addrinfo *__ai ) ;
#line 671
extern  __attribute__((__nothrow__)) char const   *( __attribute__((__leaf__)) gai_strerror)(int __ecode ) ;
#line 677
extern int getnameinfo(struct sockaddr  const  * __restrict  __sa , socklen_t __salen ,
                       char * __restrict  __host , socklen_t __hostlen , char * __restrict  __serv ,
                       socklen_t __servlen , int __flags ) ;
#line 254 "/usr/include/dirent.h"
extern int ( __attribute__((__nonnull__(1,2))) scandir)(char const   * __restrict  __dir ,
                                                        struct dirent *** __restrict  __namelist ,
                                                        int (*__selector)(struct dirent  const  * ) ,
                                                        int (*__cmp)(struct dirent  const  ** ,
                                                                     struct dirent  const  ** ) ) ;
#line 324
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) alphasort)(struct dirent  const  **__e1 ,
                                                                                                  struct dirent  const  **__e2 )  __attribute__((__pure__)) ;
#line 33 "/usr/include/x86_64-linux-gnu/sys/sendfile.h"
extern  __attribute__((__nothrow__)) ssize_t ( __attribute__((__leaf__)) sendfile)(int __out_fd ,
                                                                                   int __in_fd ,
                                                                                   off_t *__offset ,
                                                                                   size_t __count ) ;
#line 73 "/home/wheatley/newnew/temp/mini-httpd-1.19/mini_httpd.c"
extern char *crypt(char const   *key , char const   *setting ) ;
#line 171 "/home/wheatley/newnew/temp/mini-httpd-1.19/mini_httpd.c"
static char *argv0  ;
#line 172 "/home/wheatley/newnew/temp/mini-httpd-1.19/mini_httpd.c"
static int debug  ;
#line 173 "/home/wheatley/newnew/temp/mini-httpd-1.19/mini_httpd.c"
static unsigned short port  ;
#line 174 "/home/wheatley/newnew/temp/mini-httpd-1.19/mini_httpd.c"
static char *dir  ;
#line 175 "/home/wheatley/newnew/temp/mini-httpd-1.19/mini_httpd.c"
static char *data_dir  ;
#line 176 "/home/wheatley/newnew/temp/mini-httpd-1.19/mini_httpd.c"
static int do_chroot  ;
#line 177 "/home/wheatley/newnew/temp/mini-httpd-1.19/mini_httpd.c"
static int vhost  ;
#line 178 "/home/wheatley/newnew/temp/mini-httpd-1.19/mini_httpd.c"
static char *user  ;
#line 179 "/home/wheatley/newnew/temp/mini-httpd-1.19/mini_httpd.c"
static char *cgi_pattern  ;
#line 180 "/home/wheatley/newnew/temp/mini-httpd-1.19/mini_httpd.c"
static char *url_pattern  ;
#line 181 "/home/wheatley/newnew/temp/mini-httpd-1.19/mini_httpd.c"
static int no_empty_referers  ;
#line 182 "/home/wheatley/newnew/temp/mini-httpd-1.19/mini_httpd.c"
static char *local_pattern  ;
#line 183 "/home/wheatley/newnew/temp/mini-httpd-1.19/mini_httpd.c"
static char *hostname  ;
#line 184 "/home/wheatley/newnew/temp/mini-httpd-1.19/mini_httpd.c"
static char hostname_buf[500]  ;
#line 185 "/home/wheatley/newnew/temp/mini-httpd-1.19/mini_httpd.c"
static char *logfile  ;
#line 186 "/home/wheatley/newnew/temp/mini-httpd-1.19/mini_httpd.c"
static char *pidfile  ;
#line 187 "/home/wheatley/newnew/temp/mini-httpd-1.19/mini_httpd.c"
static char *charset  ;
#line 188 "/home/wheatley/newnew/temp/mini-httpd-1.19/mini_httpd.c"
static char *p3p  ;
#line 189 "/home/wheatley/newnew/temp/mini-httpd-1.19/mini_httpd.c"
static int max_age  ;
#line 190 "/home/wheatley/newnew/temp/mini-httpd-1.19/mini_httpd.c"
static FILE *logfp  ;
#line 191 "/home/wheatley/newnew/temp/mini-httpd-1.19/mini_httpd.c"
static int listen4_fd  ;
#line 191 "/home/wheatley/newnew/temp/mini-httpd-1.19/mini_httpd.c"
static int listen6_fd  ;
#line 198 "/home/wheatley/newnew/temp/mini-httpd-1.19/mini_httpd.c"
static char cwd[4096]  ;
#line 199 "/home/wheatley/newnew/temp/mini-httpd-1.19/mini_httpd.c"
static int got_hup  ;
#line 203 "/home/wheatley/newnew/temp/mini-httpd-1.19/mini_httpd.c"
static int conn_fd  ;
#line 207 "/home/wheatley/newnew/temp/mini-httpd-1.19/mini_httpd.c"
static usockaddr client_addr  ;
#line 208 "/home/wheatley/newnew/temp/mini-httpd-1.19/mini_httpd.c"
static char *request  ;
#line 209 "/home/wheatley/newnew/temp/mini-httpd-1.19/mini_httpd.c"
static size_t request_size  ;
#line 209 "/home/wheatley/newnew/temp/mini-httpd-1.19/mini_httpd.c"
static size_t request_len  ;
#line 209 "/home/wheatley/newnew/temp/mini-httpd-1.19/mini_httpd.c"
static size_t request_idx  ;
#line 210 "/home/wheatley/newnew/temp/mini-httpd-1.19/mini_httpd.c"
static int method  ;
#line 211 "/home/wheatley/newnew/temp/mini-httpd-1.19/mini_httpd.c"
static char *path  ;
#line 212 "/home/wheatley/newnew/temp/mini-httpd-1.19/mini_httpd.c"
static char *file  ;
#line 213 "/home/wheatley/newnew/temp/mini-httpd-1.19/mini_httpd.c"
static char *pathinfo  ;
#line 214 "/home/wheatley/newnew/temp/mini-httpd-1.19/mini_httpd.c"
struct stat sb  ;
#line 215 "/home/wheatley/newnew/temp/mini-httpd-1.19/mini_httpd.c"
static char *query  ;
#line 216 "/home/wheatley/newnew/temp/mini-httpd-1.19/mini_httpd.c"
static char *protocol  ;
#line 217 "/home/wheatley/newnew/temp/mini-httpd-1.19/mini_httpd.c"
static int status  ;
#line 218 "/home/wheatley/newnew/temp/mini-httpd-1.19/mini_httpd.c"
static off_t bytes  ;
#line 219 "/home/wheatley/newnew/temp/mini-httpd-1.19/mini_httpd.c"
static char *req_hostname  ;
#line 221 "/home/wheatley/newnew/temp/mini-httpd-1.19/mini_httpd.c"
static char *authorization  ;
#line 222 "/home/wheatley/newnew/temp/mini-httpd-1.19/mini_httpd.c"
static size_t content_length  ;
#line 223 "/home/wheatley/newnew/temp/mini-httpd-1.19/mini_httpd.c"
static char *content_type  ;
#line 224 "/home/wheatley/newnew/temp/mini-httpd-1.19/mini_httpd.c"
static char *cookie  ;
#line 225 "/home/wheatley/newnew/temp/mini-httpd-1.19/mini_httpd.c"
static char *host  ;
#line 226 "/home/wheatley/newnew/temp/mini-httpd-1.19/mini_httpd.c"
static time_t if_modified_since  ;
#line 227 "/home/wheatley/newnew/temp/mini-httpd-1.19/mini_httpd.c"
static char *referer  ;
#line 228 "/home/wheatley/newnew/temp/mini-httpd-1.19/mini_httpd.c"
static char *useragent  ;
#line 230 "/home/wheatley/newnew/temp/mini-httpd-1.19/mini_httpd.c"
static char *remoteuser  ;
#line 234
static void usage(void) ;
#line 235
static void read_config(char *filename ) ;
#line 236
static void value_required(char *name , char *value ) ;
#line 237
static void no_value_required(char *name , char *value ) ;
#line 238
static int initialize_listen_socket(usockaddr *usaP ) ;
#line 239
static void handle_request(void) ;
#line 240
static void de_dotdot(char *file___0 ) ;
#line 241
static int get_pathinfo(void) ;
#line 242
static void do_file(void) ;
#line 243
static void do_dir(void) ;
#line 245
static char *file_details(char const   *dir___0 , char const   *name ) ;
#line 246
static void strencode(char *to , size_t tosize , char const   *from ) ;
#line 248
static void do_cgi(void) ;
#line 249
static void cgi_interpose_input(int wfd ) ;
#line 250
static void post_post_garbage_hack(void) ;
#line 251
static void cgi_interpose_output(int rfd , int parse_headers ) ;
#line 252
static char **make_argp(void) ;
#line 253
static char **make_envp(void) ;
#line 254
static char *build_env(char *fmt , char *arg ) ;
#line 255
static void auth_check(char *dirname ) ;
#line 256
static void send_authenticate(char *realm ) ;
#line 257
static char *virtual_file(char *file___0 ) ;
#line 258
static void send_error(int s , char *title , char *extra_header , char *text ) ;
#line 259
static void send_error_body(int s , char *title , char *text ) ;
#line 260
static int send_error_file(char *filename ) ;
#line 261
static void send_error_tail(void) ;
#line 262
static void add_headers(int s , char *title , char *extra_header , char *me , char *mt ,
                        off_t b , time_t mod ) ;
#line 263
static void start_request(void) ;
#line 264
static void add_to_request(char *str___0 , size_t len ) ;
#line 265
static char *get_request_line(void) ;
#line 266
static void start_response(void) ;
#line 267
static void add_to_response(char *str___0 , size_t len ) ;
#line 268
static void send_response(void) ;
#line 270
static ssize_t my_read(char *buf___1 , size_t size ) ;
#line 271
static ssize_t my_write(char *buf___1 , size_t size ) ;
#line 273
static int my_sendfile(int fd , int socket___0 , off_t offset , size_t nbytes ) ;
#line 275
static void add_to_buf(char **bufP , size_t *bufsizeP , size_t *buflenP , char *str___0 ,
                       size_t len ) ;
#line 276
static void make_log_entry(void) ;
#line 277
static void check_referer(void) ;
#line 278
static int really_check_referer(void) ;
#line 279
static char *get_method_str(int m ) ;
#line 280
static void init_mime(void) ;
#line 281
static char const   *figure_mime(char *name , char *me , size_t me_size ) ;
#line 282
static void handle_sigterm(int sig ) ;
#line 283
static void handle_sighup(int sig ) ;
#line 284
static void handle_sigchld(int sig ) ;
#line 285
static void re_open_logfile(void) ;
#line 286
static void handle_read_timeout(int sig ) ;
#line 287
static void handle_write_timeout(int sig ) ;
#line 288
static void lookup_hostname(usockaddr *usa4P , size_t sa4_len , int *gotv4P , usockaddr *usa6P ,
                            size_t sa6_len , int *gotv6P ) ;
#line 289
static char *ntoa(usockaddr *usaP ) ;
#line 290
static int sockaddr_check(usockaddr *usaP ) ;
#line 291
static size_t sockaddr_len(usockaddr *usaP ) ;
#line 292
static void strdecode(char *to , char *from ) ;
#line 293
static int hexit(char c ) ;
#line 294
static int b64_decode(char const   *str___0 , unsigned char *space , int size ) ;
#line 295
static void set_ndelay(int fd ) ;
#line 296
static void clear_ndelay(int fd ) ;
#line 297
static void *e_malloc(size_t size ) ;
#line 298
static void *e_realloc(void *optr , size_t size ) ;
#line 299
static char *e_strdup(char *ostr ) ;
#line 623
extern int ( /* missing proto */  setgroups)() ;
#line 637
extern int ( /* missing proto */  initgroups)() ;
#line 305 "/home/wheatley/newnew/temp/mini-httpd-1.19/mini_httpd.c"
int main(int argc , char **argv ) 
{ 
  int argn ;
  struct passwd *pwd ;
  uid_t uid ;
  gid_t gid ;
  usockaddr host_addr4 ;
  usockaddr host_addr6 ;
  int gotv4 ;
  int gotv6 ;
  fd_set lfdset ;
  int maxfd ;
  usockaddr usa ;
  int sz ;
  int r ;
  char *cp ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  __uid_t tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  __uid_t tmp___19 ;
  int tmp___20 ;
  FILE *pidfp ;
  FILE *tmp___21 ;
  __pid_t tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  __uid_t tmp___26 ;
  int tmp___27 ;
  size_t tmp___28 ;
  int tmp___29 ;
  size_t tmp___30 ;
  size_t tmp___31 ;
  int tmp___32 ;
  int tmp___33 ;
  int tmp___34 ;
  int tmp___35 ;
  __uid_t tmp___36 ;
  int __d0 ;
  int __d1 ;
  int *tmp___37 ;
  int *tmp___38 ;
  int tmp___39 ;
  int *tmp___40 ;
  int *tmp___41 ;
  int *tmp___42 ;

  {
#line 310
  uid = (uid_t )32767;
#line 311
  gid = (gid_t )32767;
#line 322
  argv0 = *(argv + 0);
#line 323
  debug = 0;
#line 324
  port = (unsigned short)0;
#line 325
  dir = (char *)0;
#line 326
  data_dir = (char *)0;
#line 327
  do_chroot = 0;
#line 328
  vhost = 0;
#line 329
  cgi_pattern = (char *)0;
#line 330
  url_pattern = (char *)0;
#line 331
  no_empty_referers = 0;
#line 332
  local_pattern = (char *)0;
#line 333
  charset = (char *)"iso-8859-1";
#line 334
  p3p = (char *)0;
#line 335
  max_age = -1;
#line 336
  user = (char *)"nobody";
#line 337
  hostname = (char *)0;
#line 338
  logfile = (char *)0;
#line 339
  pidfile = (char *)0;
#line 340
  logfp = (FILE *)0;
#line 346
  argn = 1;
  {
#line 347
  while (1) {
    while_continue: /* CIL Label */ ;
#line 347
    if (argn < argc) {
#line 347
      if (! ((int )*(*(argv + argn) + 0) == 45)) {
#line 347
        goto while_break;
      }
    } else {
#line 347
      goto while_break;
    }
    {
#line 349
    tmp___15 = strcmp((char const   *)*(argv + argn), "-V");
    }
#line 349
    if (tmp___15 == 0) {
      {
#line 351
      printf((char const   */* __restrict  */)"%s\n", "mini_httpd/1.19 19dec2003");
#line 352
      exit(0);
      }
    } else {
      {
#line 354
      tmp___14 = strcmp((char const   *)*(argv + argn), "-C");
      }
#line 354
      if (tmp___14 == 0) {
#line 354
        if (argn + 1 < argc) {
          {
#line 356
          argn ++;
#line 357
          read_config(*(argv + argn));
          }
        } else {
#line 354
          goto _L___9;
        }
      } else {
        _L___9: /* CIL Label */ 
        {
#line 359
        tmp___13 = strcmp((char const   *)*(argv + argn), "-D");
        }
#line 359
        if (tmp___13 == 0) {
#line 360
          debug = 1;
        } else {
          {
#line 375
          tmp___12 = strcmp((char const   *)*(argv + argn), "-p");
          }
#line 375
          if (tmp___12 == 0) {
#line 375
            if (argn + 1 < argc) {
              {
#line 377
              argn ++;
#line 378
              tmp = atoi((char const   *)*(argv + argn));
#line 378
              port = (unsigned short )tmp;
              }
            } else {
#line 375
              goto _L___8;
            }
          } else {
            _L___8: /* CIL Label */ 
            {
#line 380
            tmp___11 = strcmp((char const   *)*(argv + argn), "-d");
            }
#line 380
            if (tmp___11 == 0) {
#line 380
              if (argn + 1 < argc) {
#line 382
                argn ++;
#line 383
                dir = *(argv + argn);
              } else {
#line 380
                goto _L___7;
              }
            } else {
              _L___7: /* CIL Label */ 
              {
#line 385
              tmp___10 = strcmp((char const   *)*(argv + argn), "-dd");
              }
#line 385
              if (tmp___10 == 0) {
#line 385
                if (argn + 1 < argc) {
#line 387
                  argn ++;
#line 388
                  data_dir = *(argv + argn);
                } else {
#line 385
                  goto _L___6;
                }
              } else {
                _L___6: /* CIL Label */ 
                {
#line 390
                tmp___9 = strcmp((char const   *)*(argv + argn), "-c");
                }
#line 390
                if (tmp___9 == 0) {
#line 390
                  if (argn + 1 < argc) {
#line 392
                    argn ++;
#line 393
                    cgi_pattern = *(argv + argn);
                  } else {
#line 390
                    goto _L___5;
                  }
                } else {
                  _L___5: /* CIL Label */ 
                  {
#line 395
                  tmp___8 = strcmp((char const   *)*(argv + argn), "-u");
                  }
#line 395
                  if (tmp___8 == 0) {
#line 395
                    if (argn + 1 < argc) {
#line 397
                      argn ++;
#line 398
                      user = *(argv + argn);
                    } else {
#line 395
                      goto _L___4;
                    }
                  } else {
                    _L___4: /* CIL Label */ 
                    {
#line 400
                    tmp___7 = strcmp((char const   *)*(argv + argn), "-h");
                    }
#line 400
                    if (tmp___7 == 0) {
#line 400
                      if (argn + 1 < argc) {
#line 402
                        argn ++;
#line 403
                        hostname = *(argv + argn);
                      } else {
#line 400
                        goto _L___3;
                      }
                    } else {
                      _L___3: /* CIL Label */ 
                      {
#line 405
                      tmp___6 = strcmp((char const   *)*(argv + argn), "-r");
                      }
#line 405
                      if (tmp___6 == 0) {
#line 406
                        do_chroot = 1;
                      } else {
                        {
#line 407
                        tmp___5 = strcmp((char const   *)*(argv + argn), "-v");
                        }
#line 407
                        if (tmp___5 == 0) {
#line 408
                          vhost = 1;
                        } else {
                          {
#line 409
                          tmp___4 = strcmp((char const   *)*(argv + argn), "-l");
                          }
#line 409
                          if (tmp___4 == 0) {
#line 409
                            if (argn + 1 < argc) {
#line 411
                              argn ++;
#line 412
                              logfile = *(argv + argn);
                            } else {
#line 409
                              goto _L___2;
                            }
                          } else {
                            _L___2: /* CIL Label */ 
                            {
#line 414
                            tmp___3 = strcmp((char const   *)*(argv + argn), "-i");
                            }
#line 414
                            if (tmp___3 == 0) {
#line 414
                              if (argn + 1 < argc) {
#line 416
                                argn ++;
#line 417
                                pidfile = *(argv + argn);
                              } else {
#line 414
                                goto _L___1;
                              }
                            } else {
                              _L___1: /* CIL Label */ 
                              {
#line 419
                              tmp___2 = strcmp((char const   *)*(argv + argn), "-T");
                              }
#line 419
                              if (tmp___2 == 0) {
#line 419
                                if (argn + 1 < argc) {
#line 421
                                  argn ++;
#line 422
                                  charset = *(argv + argn);
                                } else {
#line 419
                                  goto _L___0;
                                }
                              } else {
                                _L___0: /* CIL Label */ 
                                {
#line 424
                                tmp___1 = strcmp((char const   *)*(argv + argn), "-P");
                                }
#line 424
                                if (tmp___1 == 0) {
#line 424
                                  if (argn + 1 < argc) {
#line 426
                                    argn ++;
#line 427
                                    p3p = *(argv + argn);
                                  } else {
#line 424
                                    goto _L;
                                  }
                                } else {
                                  _L: /* CIL Label */ 
                                  {
#line 429
                                  tmp___0 = strcmp((char const   *)*(argv + argn),
                                                   "-M");
                                  }
#line 429
                                  if (tmp___0 == 0) {
#line 429
                                    if (argn + 1 < argc) {
                                      {
#line 431
                                      argn ++;
#line 432
                                      max_age = atoi((char const   *)*(argv + argn));
                                      }
                                    } else {
                                      {
#line 435
                                      usage();
                                      }
                                    }
                                  } else {
                                    {
#line 435
                                    usage();
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
#line 436
    argn ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 438
  if (argn != argc) {
    {
#line 439
    usage();
    }
  }
  {
#line 441
  cp = strrchr((char const   *)argv0, '/');
  }
#line 442
  if ((unsigned long )cp != (unsigned long )((char *)0)) {
#line 443
    cp ++;
  } else {
#line 445
    cp = argv0;
  }
  {
#line 446
  openlog((char const   *)cp, 9, 3 << 3);
  }
#line 448
  if ((int )port == 0) {
#line 456
    port = (unsigned short)80;
  }
  {
#line 463
  tmp___16 = getuid();
  }
#line 463
  if (tmp___16 == 0U) {
    {
#line 465
    pwd = getpwnam((char const   *)user);
    }
#line 466
    if ((unsigned long )pwd == (unsigned long )((struct passwd *)0)) {
      {
#line 468
      syslog(2, "unknown user - \'%s\'", user);
#line 469
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: unknown user - \'%s\'\n",
              argv0, user);
#line 470
      exit(1);
      }
    }
#line 472
    uid = pwd->pw_uid;
#line 473
    gid = pwd->pw_gid;
  }
#line 477
  if ((unsigned long )logfile != (unsigned long )((char *)0)) {
    {
#line 479
    logfp = fopen((char const   */* __restrict  */)logfile, (char const   */* __restrict  */)"a");
    }
#line 480
    if ((unsigned long )logfp == (unsigned long )((FILE *)0)) {
      {
#line 482
      syslog(2, "%s - %m", logfile);
#line 483
      perror((char const   *)logfile);
#line 484
      exit(1);
      }
    }
#line 486
    if ((int )*(logfile + 0) != 47) {
      {
#line 488
      syslog(4, "logfile is not an absolute path, you may not be able to re-open it");
#line 489
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: logfile is not an absolute path, you may not be able to re-open it\n",
              argv0);
      }
    }
    {
#line 491
    tmp___19 = getuid();
    }
#line 491
    if (tmp___19 == 0U) {
      {
#line 496
      tmp___17 = fileno(logfp);
#line 496
      tmp___18 = fchown(tmp___17, uid, gid);
      }
#line 496
      if (tmp___18 < 0) {
        {
#line 498
        syslog(4, "fchown logfile - %m");
#line 499
        perror("fchown logfile");
        }
      }
    }
  }
  {
#line 505
  lookup_hostname(& host_addr4, sizeof(host_addr4), & gotv4, & host_addr6, sizeof(host_addr6),
                  & gotv6);
  }
#line 508
  if ((unsigned long )hostname == (unsigned long )((char *)0)) {
    {
#line 510
    gethostname(hostname_buf, sizeof(hostname_buf));
#line 511
    hostname = hostname_buf;
    }
  }
#line 513
  if (! gotv4) {
#line 513
    if (! gotv6) {
      {
#line 515
      syslog(2, "can\'t find any valid address");
#line 516
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: can\'t find any valid address\n",
              argv0);
#line 517
      exit(1);
      }
    }
  }
#line 524
  if (gotv6) {
    {
#line 525
    listen6_fd = initialize_listen_socket(& host_addr6);
    }
  } else {
#line 527
    listen6_fd = -1;
  }
#line 528
  if (gotv4) {
    {
#line 529
    listen4_fd = initialize_listen_socket(& host_addr4);
    }
  } else {
#line 531
    listen4_fd = -1;
  }
#line 533
  if (listen4_fd == -1) {
#line 533
    if (listen6_fd == -1) {
      {
#line 535
      syslog(2, "can\'t bind to any address");
#line 536
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: can\'t bind to any address\n",
              argv0);
#line 537
      exit(1);
      }
    }
  }
#line 565
  if (! debug) {
    {
#line 569
    tmp___20 = daemon(1, 1);
    }
#line 569
    if (tmp___20 < 0) {
      {
#line 571
      syslog(2, "daemon - %m");
#line 572
      perror("daemon");
#line 573
      exit(1);
      }
    }
  } else {
    {
#line 598
    setsid();
    }
  }
#line 602
  if ((unsigned long )pidfile != (unsigned long )((char *)0)) {
    {
#line 605
    tmp___21 = fopen((char const   */* __restrict  */)pidfile, (char const   */* __restrict  */)"w");
#line 605
    pidfp = tmp___21;
    }
#line 606
    if ((unsigned long )pidfp == (unsigned long )((FILE *)0)) {
      {
#line 608
      syslog(2, "%s - %m", pidfile);
#line 609
      perror((char const   *)pidfile);
#line 610
      exit(1);
      }
    }
    {
#line 612
    tmp___22 = getpid();
#line 612
    fprintf((FILE */* __restrict  */)pidfp, (char const   */* __restrict  */)"%d\n",
            tmp___22);
#line 613
    fclose(pidfp);
    }
  }
  {
#line 617
  tzset();
#line 620
  tmp___26 = getuid();
  }
#line 620
  if (tmp___26 == 0U) {
    {
#line 623
    tmp___23 = setgroups(0, (gid_t *)0);
    }
#line 623
    if (tmp___23 < 0) {
      {
#line 625
      syslog(2, "setgroups - %m");
#line 626
      perror("setgroups");
#line 627
      exit(1);
      }
    }
    {
#line 630
    tmp___24 = setgid(gid);
    }
#line 630
    if (tmp___24 < 0) {
      {
#line 632
      syslog(2, "setgid - %m");
#line 633
      perror("setgid");
#line 634
      exit(1);
      }
    }
    {
#line 637
    tmp___25 = initgroups(user, gid);
    }
#line 637
    if (tmp___25 < 0) {
      {
#line 639
      syslog(3, "initgroups - %m");
#line 640
      perror("initgroups");
      }
    }
  }
#line 649
  if ((unsigned long )dir != (unsigned long )((char *)0)) {
    {
#line 651
    tmp___27 = chdir((char const   *)dir);
    }
#line 651
    if (tmp___27 < 0) {
      {
#line 653
      syslog(2, "chdir - %m");
#line 654
      perror("chdir");
#line 655
      exit(1);
      }
    }
  }
  {
#line 660
  getcwd(cwd, sizeof(cwd) - 1UL);
#line 661
  tmp___28 = strlen((char const   *)(cwd));
  }
#line 661
  if ((int )cwd[tmp___28 - 1UL] != 47) {
    {
#line 662
    strcat((char */* __restrict  */)(cwd), (char const   */* __restrict  */)"/");
    }
  }
#line 665
  if (do_chroot) {
    {
#line 667
    tmp___29 = chroot((char const   *)(cwd));
    }
#line 667
    if (tmp___29 < 0) {
      {
#line 669
      syslog(2, "chroot - %m");
#line 670
      perror("chroot");
#line 671
      exit(1);
      }
    }
#line 678
    if ((unsigned long )logfile != (unsigned long )((char *)0)) {
      {
#line 679
      tmp___31 = strlen((char const   *)(cwd));
#line 679
      tmp___32 = strncmp((char const   *)logfile, (char const   *)(cwd), tmp___31);
      }
#line 679
      if (tmp___32 == 0) {
        {
#line 681
        tmp___30 = strlen((char const   *)(cwd));
#line 681
        strcpy((char */* __restrict  */)logfile, (char const   */* __restrict  */)(logfile + (tmp___30 - 1UL)));
        }
      } else {
        {
#line 689
        syslog(4, "logfile is not within the chroot tree, you will not be able to re-open it");
#line 690
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: logfile is not within the chroot tree, you will not be able to re-open it\n",
                argv0);
        }
      }
    }
    {
#line 692
    strcpy((char */* __restrict  */)(cwd), (char const   */* __restrict  */)"/");
#line 694
    tmp___33 = chdir((char const   *)(cwd));
    }
#line 694
    if (tmp___33 < 0) {
      {
#line 696
      syslog(2, "chroot chdir - %m");
#line 697
      perror("chroot chdir");
#line 698
      exit(1);
      }
    }
  }
#line 704
  if ((unsigned long )data_dir != (unsigned long )((char *)0)) {
    {
#line 706
    tmp___34 = chdir((char const   *)data_dir);
    }
#line 706
    if (tmp___34 < 0) {
      {
#line 708
      syslog(2, "data_dir chdir - %m");
#line 709
      perror("data_dir chdir");
#line 710
      exit(1);
      }
    }
  }
  {
#line 715
  tmp___36 = getuid();
  }
#line 715
  if (tmp___36 == 0U) {
    {
#line 718
    tmp___35 = setuid(uid);
    }
#line 718
    if (tmp___35 < 0) {
      {
#line 720
      syslog(2, "setuid - %m");
#line 721
      perror("setuid");
#line 722
      exit(1);
      }
    }
#line 725
    if (! do_chroot) {
      {
#line 727
      syslog(4, "started as root without requesting chroot(), warning only");
#line 729
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: started as root without requesting chroot(), warning only\n",
              argv0);
      }
    }
  }
  {
#line 743
  signal(15, & handle_sigterm);
#line 744
  signal(2, & handle_sigterm);
#line 745
  signal(10, & handle_sigterm);
#line 746
  signal(1, & handle_sighup);
#line 747
  signal(17, & handle_sigchld);
#line 748
  signal(13, (void (*)(int  ))1);
#line 750
  got_hup = 0;
#line 752
  init_mime();
  }
#line 754
  if ((unsigned long )hostname == (unsigned long )((char *)0)) {
    {
#line 755
    syslog(5, "%.80s starting on port %d", "mini_httpd/1.19 19dec2003", (int )port);
    }
  } else {
    {
#line 759
    syslog(5, "%.80s starting on %.80s, port %d", "mini_httpd/1.19 19dec2003", hostname,
           (int )port);
    }
  }
  {
#line 764
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 767
    if (got_hup) {
      {
#line 769
      re_open_logfile();
#line 770
      got_hup = 0;
      }
    }
    {
#line 782
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 782
      __asm__  volatile   ("cld; rep; "
                           "stosq": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                           "1" (& lfdset.__fds_bits[0]): "memory");
#line 782
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 783
    maxfd = -1;
#line 784
    if (listen4_fd != -1) {
#line 786
      lfdset.__fds_bits[listen4_fd / (8 * (int )sizeof(__fd_mask ))] |= 1L << listen4_fd % (8 * (int )sizeof(__fd_mask ));
#line 787
      if (listen4_fd > maxfd) {
#line 788
        maxfd = listen4_fd;
      }
    }
#line 790
    if (listen6_fd != -1) {
#line 792
      lfdset.__fds_bits[listen6_fd / (8 * (int )sizeof(__fd_mask ))] |= 1L << listen6_fd % (8 * (int )sizeof(__fd_mask ));
#line 793
      if (listen6_fd > maxfd) {
#line 794
        maxfd = listen6_fd;
      }
    }
    {
#line 796
    tmp___39 = select(maxfd + 1, (fd_set */* __restrict  */)(& lfdset), (fd_set */* __restrict  */)((fd_set *)0),
                      (fd_set */* __restrict  */)((fd_set *)0), (struct timeval */* __restrict  */)((struct timeval *)0));
    }
#line 796
    if (tmp___39 < 0) {
      {
#line 798
      tmp___37 = __errno_location();
      }
#line 798
      if (*tmp___37 == 4) {
#line 799
        goto __Cont;
      } else {
        {
#line 798
        tmp___38 = __errno_location();
        }
#line 798
        if (*tmp___38 == 11) {
#line 799
          goto __Cont;
        }
      }
      {
#line 800
      syslog(2, "select - %m");
#line 801
      perror("select");
#line 802
      exit(1);
      }
    }
#line 806
    sz = (int )sizeof(usa);
#line 807
    if (listen4_fd != -1) {
#line 807
      if ((lfdset.__fds_bits[listen4_fd / (8 * (int )sizeof(__fd_mask ))] & (1L << listen4_fd % (8 * (int )sizeof(__fd_mask )))) != 0L) {
        {
#line 808
        conn_fd = accept(listen4_fd, (struct sockaddr */* __restrict  */)(& usa.sa),
                         (socklen_t */* __restrict  */)(& sz));
        }
      } else {
#line 807
        goto _L___10;
      }
    } else
    _L___10: /* CIL Label */ 
#line 809
    if (listen6_fd != -1) {
#line 809
      if ((lfdset.__fds_bits[listen6_fd / (8 * (int )sizeof(__fd_mask ))] & (1L << listen6_fd % (8 * (int )sizeof(__fd_mask )))) != 0L) {
        {
#line 810
        conn_fd = accept(listen6_fd, (struct sockaddr */* __restrict  */)(& usa.sa),
                         (socklen_t */* __restrict  */)(& sz));
        }
      } else {
        {
#line 813
        syslog(2, "select failure");
#line 814
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: select failure\n",
                argv0);
#line 815
        exit(1);
        }
      }
    } else {
      {
#line 813
      syslog(2, "select failure");
#line 814
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: select failure\n",
              argv0);
#line 815
      exit(1);
      }
    }
#line 817
    if (conn_fd < 0) {
      {
#line 819
      tmp___40 = __errno_location();
      }
#line 819
      if (*tmp___40 == 4) {
#line 820
        goto __Cont;
      } else {
        {
#line 819
        tmp___41 = __errno_location();
        }
#line 819
        if (*tmp___41 == 11) {
#line 820
          goto __Cont;
        }
      }
      {
#line 822
      tmp___42 = __errno_location();
      }
#line 822
      if (*tmp___42 == 71) {
#line 823
        goto __Cont;
      }
      {
#line 825
      syslog(2, "accept - %m");
#line 826
      perror("accept");
#line 827
      exit(1);
      }
    }
    {
#line 831
    r = fork();
    }
#line 832
    if (r < 0) {
      {
#line 834
      syslog(2, "fork - %m");
#line 835
      perror("fork");
#line 836
      exit(1);
      }
    }
#line 838
    if (r == 0) {
#line 841
      client_addr = usa;
#line 842
      if (listen4_fd != -1) {
        {
#line 843
        close(listen4_fd);
        }
      }
#line 844
      if (listen6_fd != -1) {
        {
#line 845
        close(listen6_fd);
        }
      }
      {
#line 846
      handle_request();
#line 847
      exit(0);
      }
    }
    {
#line 849
    close(conn_fd);
    }
    __Cont: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
}
}
#line 854 "/home/wheatley/newnew/temp/mini-httpd-1.19/mini_httpd.c"
static void usage(void) 
{ 


  {
  {
#line 860
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"usage:  %s [-C configfile] [-D] [-p port] [-d dir] [-dd data_dir] [-c cgipat] [-u user] [-h hostname] [-r] [-v] [-l logfile] [-i pidfile] [-T charset] [-P P3P] [-M maxage]\n",
          argv0);
#line 862
  exit(1);
  }
}
}
#line 866 "/home/wheatley/newnew/temp/mini-httpd-1.19/mini_httpd.c"
static void read_config(char *filename ) 
{ 
  FILE *fp ;
  char line___0[10000] ;
  char *cp ;
  char *cp2 ;
  char *name ;
  char *value ;
  size_t tmp ;
  size_t tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  size_t tmp___22 ;
  char *tmp___23 ;

  {
  {
#line 876
  fp = fopen((char const   */* __restrict  */)filename, (char const   */* __restrict  */)"r");
  }
#line 877
  if ((unsigned long )fp == (unsigned long )((FILE *)0)) {
    {
#line 879
    syslog(2, "%s - %m", filename);
#line 880
    perror((char const   *)filename);
#line 881
    exit(1);
    }
  }
  {
#line 884
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 884
    tmp___23 = fgets((char */* __restrict  */)(line___0), (int )sizeof(line___0),
                     (FILE */* __restrict  */)fp);
    }
#line 884
    if (! ((unsigned long )tmp___23 != (unsigned long )((char *)0))) {
#line 884
      goto while_break;
    }
    {
#line 887
    cp = strchr((char const   *)(line___0), '#');
    }
#line 887
    if ((unsigned long )cp != (unsigned long )((char *)0)) {
#line 888
      *cp = (char )'\000';
    }
    {
#line 891
    cp = line___0;
#line 892
    tmp = strspn((char const   *)cp, " \t\n\r");
#line 892
    cp += tmp;
    }
    {
#line 895
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 895
      if (! ((int )*cp != 0)) {
#line 895
        goto while_break___0;
      }
      {
#line 898
      tmp___0 = strcspn((char const   *)cp, " \t\n\r");
#line 898
      cp2 = cp + tmp___0;
      }
      {
#line 900
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 900
        if (! ((int )*cp2 == 32)) {
#line 900
          if (! ((int )*cp2 == 9)) {
#line 900
            if (! ((int )*cp2 == 10)) {
#line 900
              if (! ((int )*cp2 == 13)) {
#line 900
                goto while_break___1;
              }
            }
          }
        }
#line 901
        tmp___1 = cp2;
#line 901
        cp2 ++;
#line 901
        *tmp___1 = (char )'\000';
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 903
      name = cp;
#line 904
      value = strchr((char const   *)name, '=');
      }
#line 905
      if ((unsigned long )value != (unsigned long )((char *)0)) {
#line 906
        tmp___2 = value;
#line 906
        value ++;
#line 906
        *tmp___2 = (char )'\000';
      }
      {
#line 908
      tmp___21 = strcasecmp((char const   *)name, "debug");
      }
#line 908
      if (tmp___21 == 0) {
        {
#line 910
        no_value_required(name, value);
#line 911
        debug = 1;
        }
      } else {
        {
#line 913
        tmp___20 = strcasecmp((char const   *)name, "port");
        }
#line 913
        if (tmp___20 == 0) {
          {
#line 915
          value_required(name, value);
#line 916
          tmp___3 = atoi((char const   *)value);
#line 916
          port = (unsigned short )tmp___3;
          }
        } else {
          {
#line 918
          tmp___19 = strcasecmp((char const   *)name, "dir");
          }
#line 918
          if (tmp___19 == 0) {
            {
#line 920
            value_required(name, value);
#line 921
            dir = e_strdup(value);
            }
          } else {
            {
#line 923
            tmp___18 = strcasecmp((char const   *)name, "data_dir");
            }
#line 923
            if (tmp___18 == 0) {
              {
#line 925
              value_required(name, value);
#line 926
              data_dir = e_strdup(value);
              }
            } else {
              {
#line 928
              tmp___17 = strcasecmp((char const   *)name, "chroot");
              }
#line 928
              if (tmp___17 == 0) {
                {
#line 930
                no_value_required(name, value);
#line 931
                do_chroot = 1;
                }
              } else {
                {
#line 933
                tmp___16 = strcasecmp((char const   *)name, "nochroot");
                }
#line 933
                if (tmp___16 == 0) {
                  {
#line 935
                  no_value_required(name, value);
#line 936
                  do_chroot = 0;
                  }
                } else {
                  {
#line 938
                  tmp___15 = strcasecmp((char const   *)name, "user");
                  }
#line 938
                  if (tmp___15 == 0) {
                    {
#line 940
                    value_required(name, value);
#line 941
                    user = e_strdup(value);
                    }
                  } else {
                    {
#line 943
                    tmp___14 = strcasecmp((char const   *)name, "cgipat");
                    }
#line 943
                    if (tmp___14 == 0) {
                      {
#line 945
                      value_required(name, value);
#line 946
                      cgi_pattern = e_strdup(value);
                      }
                    } else {
                      {
#line 948
                      tmp___13 = strcasecmp((char const   *)name, "urlpat");
                      }
#line 948
                      if (tmp___13 == 0) {
                        {
#line 950
                        value_required(name, value);
#line 951
                        url_pattern = e_strdup(value);
                        }
                      } else {
                        {
#line 953
                        tmp___12 = strcasecmp((char const   *)name, "noemptyreferers");
                        }
#line 953
                        if (tmp___12 == 0) {
                          {
#line 955
                          value_required(name, value);
#line 956
                          no_empty_referers = 1;
                          }
                        } else {
                          {
#line 958
                          tmp___11 = strcasecmp((char const   *)name, "localpat");
                          }
#line 958
                          if (tmp___11 == 0) {
                            {
#line 960
                            value_required(name, value);
#line 961
                            local_pattern = e_strdup(value);
                            }
                          } else {
                            {
#line 963
                            tmp___10 = strcasecmp((char const   *)name, "host");
                            }
#line 963
                            if (tmp___10 == 0) {
                              {
#line 965
                              value_required(name, value);
#line 966
                              hostname = e_strdup(value);
                              }
                            } else {
                              {
#line 968
                              tmp___9 = strcasecmp((char const   *)name, "logfile");
                              }
#line 968
                              if (tmp___9 == 0) {
                                {
#line 970
                                value_required(name, value);
#line 971
                                logfile = e_strdup(value);
                                }
                              } else {
                                {
#line 973
                                tmp___8 = strcasecmp((char const   *)name, "vhost");
                                }
#line 973
                                if (tmp___8 == 0) {
                                  {
#line 975
                                  no_value_required(name, value);
#line 976
                                  vhost = 1;
                                  }
                                } else {
                                  {
#line 978
                                  tmp___7 = strcasecmp((char const   *)name, "pidfile");
                                  }
#line 978
                                  if (tmp___7 == 0) {
                                    {
#line 980
                                    value_required(name, value);
#line 981
                                    pidfile = e_strdup(value);
                                    }
                                  } else {
                                    {
#line 983
                                    tmp___6 = strcasecmp((char const   *)name, "charset");
                                    }
#line 983
                                    if (tmp___6 == 0) {
                                      {
#line 985
                                      value_required(name, value);
#line 986
                                      charset = e_strdup(value);
                                      }
                                    } else {
                                      {
#line 988
                                      tmp___5 = strcasecmp((char const   *)name, "p3p");
                                      }
#line 988
                                      if (tmp___5 == 0) {
                                        {
#line 990
                                        value_required(name, value);
#line 991
                                        p3p = e_strdup(value);
                                        }
                                      } else {
                                        {
#line 993
                                        tmp___4 = strcasecmp((char const   *)name,
                                                             "max_age");
                                        }
#line 993
                                        if (tmp___4 == 0) {
                                          {
#line 995
                                          value_required(name, value);
#line 996
                                          max_age = atoi((char const   *)value);
                                          }
                                        } else {
                                          {
#line 1017
                                          fprintf((FILE */* __restrict  */)stderr,
                                                  (char const   */* __restrict  */)"%s: unknown config option \'%s\'\n",
                                                  argv0, name);
#line 1019
                                          exit(1);
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
      {
#line 1023
      cp = cp2;
#line 1024
      tmp___22 = strspn((char const   *)cp, " \t\n\r");
#line 1024
      cp += tmp___22;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1028
  fclose(fp);
  }
#line 1029
  return;
}
}
#line 1032 "/home/wheatley/newnew/temp/mini-httpd-1.19/mini_httpd.c"
static void value_required(char *name , char *value ) 
{ 


  {
#line 1035
  if ((unsigned long )value == (unsigned long )((char *)0)) {
    {
#line 1037
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: value required for %s option\n",
            argv0, name);
#line 1039
    exit(1);
    }
  }
#line 1041
  return;
}
}
#line 1044 "/home/wheatley/newnew/temp/mini-httpd-1.19/mini_httpd.c"
static void no_value_required(char *name , char *value ) 
{ 


  {
#line 1047
  if ((unsigned long )value != (unsigned long )((char *)0)) {
    {
#line 1049
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: no value required for %s option\n",
            argv0, name);
#line 1052
    exit(1);
    }
  }
#line 1054
  return;
}
}
#line 1057 "/home/wheatley/newnew/temp/mini-httpd-1.19/mini_httpd.c"
static int initialize_listen_socket(usockaddr *usaP ) 
{ 
  int listen_fd ;
  int i ;
  int tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  size_t tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
  {
#line 1064
  tmp = sockaddr_check(usaP);
  }
#line 1064
  if (! tmp) {
    {
#line 1066
    syslog(3, "unknown sockaddr family on listen socket - %d", (int )usaP->sa.sa_family);
#line 1069
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: unknown sockaddr family on listen socket - %d\n",
            argv0, (int )usaP->sa.sa_family);
    }
#line 1072
    return (-1);
  }
  {
#line 1075
  listen_fd = socket((int )usaP->sa.sa_family, 1, 0);
  }
#line 1076
  if (listen_fd < 0) {
    {
#line 1078
    tmp___0 = ntoa(usaP);
#line 1078
    syslog(2, "socket %.80s - %m", tmp___0);
#line 1079
    perror("socket");
    }
#line 1080
    return (-1);
  }
  {
#line 1083
  fcntl(listen_fd, 2, 1);
#line 1085
  i = 1;
#line 1086
  tmp___1 = setsockopt(listen_fd, 1, 2, (void const   *)((void *)(& i)), (socklen_t )sizeof(i));
  }
#line 1086
  if (tmp___1 < 0) {
    {
#line 1088
    syslog(2, "setsockopt SO_REUSEADDR - %m");
#line 1089
    perror("setsockopt SO_REUSEADDR");
    }
#line 1090
    return (-1);
  }
  {
#line 1093
  tmp___3 = sockaddr_len(usaP);
#line 1093
  tmp___4 = bind(listen_fd, (struct sockaddr  const  *)(& usaP->sa), (socklen_t )tmp___3);
  }
#line 1093
  if (tmp___4 < 0) {
    {
#line 1095
    tmp___2 = ntoa(usaP);
#line 1095
    syslog(2, "bind %.80s - %m", tmp___2);
#line 1096
    perror("bind");
    }
#line 1097
    return (-1);
  }
  {
#line 1100
  tmp___5 = listen(listen_fd, 1024);
  }
#line 1100
  if (tmp___5 < 0) {
    {
#line 1102
    syslog(2, "listen - %m");
#line 1103
    perror("listen");
    }
#line 1104
    return (-1);
  }
#line 1116
  return (listen_fd);
}
}
#line 1123 "/home/wheatley/newnew/temp/mini-httpd-1.19/mini_httpd.c"
static void handle_request(void) 
{ 
  char *method_str ;
  char *line___0 ;
  char *cp ;
  int r ;
  int file_len ;
  int i ;
  char const   *index_names[6] ;
  char buf___1[10000] ;
  int r___0 ;
  ssize_t tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  size_t tmp___5 ;
  char *tmp___6 ;
  size_t tmp___7 ;
  char *tmp___8 ;
  size_t tmp___9 ;
  size_t tmp___10 ;
  long tmp___11 ;
  size_t tmp___12 ;
  size_t tmp___13 ;
  size_t tmp___14 ;
  char *tmp___15 ;
  size_t tmp___16 ;
  size_t tmp___17 ;
  size_t tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  char *tmp___27 ;
  int tmp___28 ;
  char *tmp___29 ;
  int tmp___30 ;
  char *tmp___31 ;
  int tmp___32 ;
  size_t tmp___33 ;
  char idx[10000] ;
  char location[10000] ;
  int tmp___34 ;

  {
  {
#line 1130
  index_names[0] = "index.html";
#line 1130
  index_names[1] = "index.htm";
#line 1130
  index_names[2] = "index.xhtml";
#line 1130
  index_names[3] = "index.xht";
#line 1130
  index_names[4] = "Default.htm";
#line 1130
  index_names[5] = "index.cgi";
#line 1138
  signal(14, & handle_read_timeout);
#line 1140
  alarm(60U);
#line 1143
  remoteuser = (char *)0;
#line 1144
  method = 0;
#line 1145
  path = (char *)0;
#line 1146
  file = (char *)0;
#line 1147
  pathinfo = (char *)0;
#line 1148
  query = (char *)"";
#line 1149
  protocol = (char *)0;
#line 1150
  status = 0;
#line 1151
  bytes = (off_t )-1;
#line 1152
  req_hostname = (char *)0;
#line 1154
  authorization = (char *)0;
#line 1155
  content_type = (char *)0;
#line 1156
  content_length = (size_t )-1;
#line 1157
  cookie = (char *)0;
#line 1158
  host = (char *)0;
#line 1159
  if_modified_since = (time_t )-1;
#line 1160
  referer = (char *)"";
#line 1161
  useragent = (char *)"";
#line 1188
  start_request();
  }
  {
#line 1189
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1192
    tmp = my_read(buf___1, sizeof(buf___1));
#line 1192
    r___0 = (int )tmp;
    }
#line 1193
    if (r___0 < 0) {
      {
#line 1193
      tmp___0 = __errno_location();
      }
#line 1193
      if (*tmp___0 == 4) {
#line 1194
        goto __Cont;
      } else {
        {
#line 1193
        tmp___1 = __errno_location();
        }
#line 1193
        if (*tmp___1 == 11) {
#line 1194
          goto __Cont;
        }
      }
    }
#line 1195
    if (r___0 <= 0) {
#line 1196
      goto while_break;
    }
    {
#line 1197
    alarm(60U);
#line 1198
    add_to_request(buf___1, (size_t )r___0);
#line 1199
    tmp___2 = strstr((char const   *)request, "\r\n\r\n");
    }
#line 1199
    if ((unsigned long )tmp___2 != (unsigned long )((char *)0)) {
#line 1201
      goto while_break;
    } else {
      {
#line 1199
      tmp___3 = strstr((char const   *)request, "\n\n");
      }
#line 1199
      if ((unsigned long )tmp___3 != (unsigned long )((char *)0)) {
#line 1201
        goto while_break;
      }
    }
    __Cont: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1205
  method_str = get_request_line();
  }
#line 1206
  if ((unsigned long )method_str == (unsigned long )((char *)0)) {
    {
#line 1207
    send_error(400, (char *)"Bad Request", (char *)"", (char *)"Can\'t parse request.");
    }
  }
  {
#line 1208
  path = strpbrk((char const   *)method_str, " \t\n\r");
  }
#line 1209
  if ((unsigned long )path == (unsigned long )((char *)0)) {
    {
#line 1210
    send_error(400, (char *)"Bad Request", (char *)"", (char *)"Can\'t parse request.");
    }
  }
  {
#line 1211
  tmp___4 = path;
#line 1211
  path ++;
#line 1211
  *tmp___4 = (char )'\000';
#line 1212
  tmp___5 = strspn((char const   *)path, " \t\n\r");
#line 1212
  path += tmp___5;
#line 1213
  protocol = strpbrk((char const   *)path, " \t\n\r");
  }
#line 1214
  if ((unsigned long )protocol == (unsigned long )((char *)0)) {
    {
#line 1215
    send_error(400, (char *)"Bad Request", (char *)"", (char *)"Can\'t parse request.");
    }
  }
  {
#line 1216
  tmp___6 = protocol;
#line 1216
  protocol ++;
#line 1216
  *tmp___6 = (char )'\000';
#line 1217
  tmp___7 = strspn((char const   *)protocol, " \t\n\r");
#line 1217
  protocol += tmp___7;
#line 1218
  query = strchr((char const   *)path, '?');
  }
#line 1219
  if ((unsigned long )query == (unsigned long )((char *)0)) {
#line 1220
    query = (char *)"";
  } else {
#line 1222
    tmp___8 = query;
#line 1222
    query ++;
#line 1222
    *tmp___8 = (char )'\000';
  }
  {
#line 1225
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 1225
    line___0 = get_request_line();
    }
#line 1225
    if (! ((unsigned long )line___0 != (unsigned long )((char *)0))) {
#line 1225
      goto while_break___0;
    }
#line 1227
    if ((int )*(line___0 + 0) == 0) {
#line 1228
      goto while_break___0;
    } else {
      {
#line 1229
      tmp___26 = strncasecmp((char const   *)line___0, "Authorization:", (size_t )14);
      }
#line 1229
      if (tmp___26 == 0) {
        {
#line 1231
        cp = line___0 + 14;
#line 1232
        tmp___9 = strspn((char const   *)cp, " \t");
#line 1232
        cp += tmp___9;
#line 1233
        authorization = cp;
        }
      } else {
        {
#line 1235
        tmp___25 = strncasecmp((char const   *)line___0, "Content-Length:", (size_t )15);
        }
#line 1235
        if (tmp___25 == 0) {
          {
#line 1237
          cp = line___0 + 15;
#line 1238
          tmp___10 = strspn((char const   *)cp, " \t");
#line 1238
          cp += tmp___10;
#line 1239
          tmp___11 = atol((char const   *)cp);
#line 1239
          content_length = (size_t )tmp___11;
          }
        } else {
          {
#line 1241
          tmp___24 = strncasecmp((char const   *)line___0, "Content-Type:", (size_t )13);
          }
#line 1241
          if (tmp___24 == 0) {
            {
#line 1243
            cp = line___0 + 13;
#line 1244
            tmp___12 = strspn((char const   *)cp, " \t");
#line 1244
            cp += tmp___12;
#line 1245
            content_type = cp;
            }
          } else {
            {
#line 1247
            tmp___23 = strncasecmp((char const   *)line___0, "Cookie:", (size_t )7);
            }
#line 1247
            if (tmp___23 == 0) {
              {
#line 1249
              cp = line___0 + 7;
#line 1250
              tmp___13 = strspn((char const   *)cp, " \t");
#line 1250
              cp += tmp___13;
#line 1251
              cookie = cp;
              }
            } else {
              {
#line 1253
              tmp___22 = strncasecmp((char const   *)line___0, "Host:", (size_t )5);
              }
#line 1253
              if (tmp___22 == 0) {
                {
#line 1255
                cp = line___0 + 5;
#line 1256
                tmp___14 = strspn((char const   *)cp, " \t");
#line 1256
                cp += tmp___14;
#line 1257
                host = cp;
#line 1258
                tmp___15 = strchr((char const   *)host, '/');
                }
#line 1258
                if ((unsigned long )tmp___15 != (unsigned long )((char *)0)) {
                  {
#line 1259
                  send_error(400, (char *)"Bad Request", (char *)"", (char *)"Can\'t parse request.");
                  }
                } else
#line 1258
                if ((int )*(host + 0) == 46) {
                  {
#line 1259
                  send_error(400, (char *)"Bad Request", (char *)"", (char *)"Can\'t parse request.");
                  }
                }
              } else {
                {
#line 1261
                tmp___21 = strncasecmp((char const   *)line___0, "If-Modified-Since:",
                                       (size_t )18);
                }
#line 1261
                if (tmp___21 == 0) {
                  {
#line 1263
                  cp = line___0 + 18;
#line 1264
                  tmp___16 = strspn((char const   *)cp, " \t");
#line 1264
                  cp += tmp___16;
#line 1265
                  if_modified_since = tdate_parse(cp);
                  }
                } else {
                  {
#line 1267
                  tmp___20 = strncasecmp((char const   *)line___0, "Referer:", (size_t )8);
                  }
#line 1267
                  if (tmp___20 == 0) {
                    {
#line 1269
                    cp = line___0 + 8;
#line 1270
                    tmp___17 = strspn((char const   *)cp, " \t");
#line 1270
                    cp += tmp___17;
#line 1271
                    referer = cp;
                    }
                  } else {
                    {
#line 1273
                    tmp___19 = strncasecmp((char const   *)line___0, "User-Agent:",
                                           (size_t )11);
                    }
#line 1273
                    if (tmp___19 == 0) {
                      {
#line 1275
                      cp = line___0 + 11;
#line 1276
                      tmp___18 = strspn((char const   *)cp, " \t");
#line 1276
                      cp += tmp___18;
#line 1277
                      useragent = cp;
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 1281
  tmp___31 = get_method_str(1);
#line 1281
  tmp___32 = strcasecmp((char const   *)method_str, (char const   *)tmp___31);
  }
#line 1281
  if (tmp___32 == 0) {
#line 1282
    method = 1;
  } else {
    {
#line 1283
    tmp___29 = get_method_str(2);
#line 1283
    tmp___30 = strcasecmp((char const   *)method_str, (char const   *)tmp___29);
    }
#line 1283
    if (tmp___30 == 0) {
#line 1284
      method = 2;
    } else {
      {
#line 1285
      tmp___27 = get_method_str(3);
#line 1285
      tmp___28 = strcasecmp((char const   *)method_str, (char const   *)tmp___27);
      }
#line 1285
      if (tmp___28 == 0) {
#line 1286
        method = 3;
      } else {
        {
#line 1288
        send_error(501, (char *)"Not Implemented", (char *)"", (char *)"That method is not implemented.");
        }
      }
    }
  }
  {
#line 1290
  strdecode(path, path);
  }
#line 1291
  if ((int )*(path + 0) != 47) {
    {
#line 1292
    send_error(400, (char *)"Bad Request", (char *)"", (char *)"Bad filename.");
    }
  }
  {
#line 1293
  file = path + 1;
#line 1294
  de_dotdot(file);
  }
#line 1295
  if ((int )*(file + 0) == 0) {
#line 1296
    file = (char *)"./";
  }
#line 1297
  if ((int )*(file + 0) == 47) {
    {
#line 1300
    send_error(400, (char *)"Bad Request", (char *)"", (char *)"Illegal filename.");
    }
  } else
#line 1297
  if ((int )*(file + 0) == 46) {
#line 1297
    if ((int )*(file + 1) == 46) {
#line 1297
      if ((int )*(file + 2) == 0) {
        {
#line 1300
        send_error(400, (char *)"Bad Request", (char *)"", (char *)"Illegal filename.");
        }
      } else
#line 1297
      if ((int )*(file + 2) == 47) {
        {
#line 1300
        send_error(400, (char *)"Bad Request", (char *)"", (char *)"Illegal filename.");
        }
      }
    }
  }
#line 1301
  if (vhost) {
    {
#line 1302
    file = virtual_file(file);
    }
  }
  {
#line 1308
  signal(14, & handle_write_timeout);
#line 1310
  alarm(300U);
#line 1312
  r = stat((char const   */* __restrict  */)file, (struct stat */* __restrict  */)(& sb));
  }
#line 1313
  if (r < 0) {
    {
#line 1314
    r = get_pathinfo();
    }
  }
#line 1315
  if (r < 0) {
    {
#line 1316
    send_error(404, (char *)"Not Found", (char *)"", (char *)"File not found.");
    }
  }
  {
#line 1317
  tmp___33 = strlen((char const   *)file);
#line 1317
  file_len = (int )tmp___33;
  }
#line 1318
  if (! ((sb.st_mode & 61440U) == 16384U)) {
    {
#line 1321
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1321
      if (! ((int )*(file + (file_len - 1)) == 47)) {
#line 1321
        goto while_break___1;
      }
#line 1323
      *(file + (file_len - 1)) = (char )'\000';
#line 1324
      file_len --;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 1326
    do_file();
    }
  } else {
#line 1333
    if ((int )*(file + (file_len - 1)) != 47) {
#line 1333
      if ((unsigned long )pathinfo == (unsigned long )((char *)0)) {
#line 1336
        if ((int )*(query + 0) != 0) {
          {
#line 1337
          snprintf((char */* __restrict  */)(location), sizeof(location), (char const   */* __restrict  */)"Location: %s/?%s",
                   path, query);
          }
        } else {
          {
#line 1341
          snprintf((char */* __restrict  */)(location), sizeof(location), (char const   */* __restrict  */)"Location: %s/",
                   path);
          }
        }
        {
#line 1343
        send_error(302, (char *)"Found", location, (char *)"Directories must end with a slash.");
        }
      }
    }
#line 1347
    i = 0;
    {
#line 1347
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 1347
      if (! ((unsigned long )i < sizeof(index_names) / sizeof(char *))) {
#line 1347
        goto while_break___2;
      }
      {
#line 1349
      snprintf((char */* __restrict  */)(idx), sizeof(idx), (char const   */* __restrict  */)"%s%s",
               file, index_names[i]);
#line 1350
      tmp___34 = stat((char const   */* __restrict  */)(idx), (struct stat */* __restrict  */)(& sb));
      }
#line 1350
      if (tmp___34 >= 0) {
        {
#line 1352
        file = idx;
#line 1353
        do_file();
        }
#line 1354
        goto got_one;
      }
#line 1347
      i ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 1359
    do_dir();
    }
    got_one: ;
  }
#line 1367
  return;
}
}
#line 1370 "/home/wheatley/newnew/temp/mini-httpd-1.19/mini_httpd.c"
static void de_dotdot(char *file___0 ) 
{ 
  char *cp ;
  char *cp2 ;
  int l ;
  int tmp ;
  int tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;

  {
  {
#line 1378
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1378
    cp = strstr((char const   *)file___0, "//");
    }
#line 1378
    if (! ((unsigned long )cp != (unsigned long )((char *)0))) {
#line 1378
      goto while_break;
    }
#line 1380
    cp2 = cp + 2;
    {
#line 1380
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1380
      if (! ((int )*cp2 == 47)) {
#line 1380
        goto while_break___0;
      }
#line 1381
      goto __Cont;
      __Cont: /* CIL Label */ 
#line 1380
      cp2 ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 1382
    strcpy((char */* __restrict  */)(cp + 1), (char const   */* __restrict  */)cp2);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1386
  while (1) {
    while_continue___1: /* CIL Label */ ;
    {
#line 1386
    tmp = strncmp((char const   *)file___0, "./", (size_t )2);
    }
#line 1386
    if (! (tmp == 0)) {
#line 1386
      goto while_break___1;
    }
    {
#line 1387
    strcpy((char */* __restrict  */)file___0, (char const   */* __restrict  */)(file___0 + 2));
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 1388
  while (1) {
    while_continue___2: /* CIL Label */ ;
    {
#line 1388
    cp = strstr((char const   *)file___0, "/./");
    }
#line 1388
    if (! ((unsigned long )cp != (unsigned long )((char *)0))) {
#line 1388
      goto while_break___2;
    }
    {
#line 1389
    strcpy((char */* __restrict  */)cp, (char const   */* __restrict  */)(cp + 2));
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 1392
  while (1) {
    while_continue___3: /* CIL Label */ ;
    {
#line 1394
    while (1) {
      while_continue___4: /* CIL Label */ ;
      {
#line 1394
      tmp___0 = strncmp((char const   *)file___0, "../", (size_t )3);
      }
#line 1394
      if (! (tmp___0 == 0)) {
#line 1394
        goto while_break___4;
      }
      {
#line 1395
      strcpy((char */* __restrict  */)file___0, (char const   */* __restrict  */)(file___0 + 3));
      }
    }
    while_break___4: /* CIL Label */ ;
    }
    {
#line 1396
    cp = strstr((char const   *)file___0, "/../");
    }
#line 1397
    if ((unsigned long )cp == (unsigned long )((char *)0)) {
#line 1398
      goto while_break___3;
    }
#line 1399
    cp2 = cp - 1;
    {
#line 1399
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 1399
      if ((unsigned long )cp2 >= (unsigned long )file___0) {
#line 1399
        if (! ((int )*cp2 != 47)) {
#line 1399
          goto while_break___5;
        }
      } else {
#line 1399
        goto while_break___5;
      }
#line 1400
      goto __Cont___0;
      __Cont___0: /* CIL Label */ 
#line 1399
      cp2 --;
    }
    while_break___5: /* CIL Label */ ;
    }
    {
#line 1401
    strcpy((char */* __restrict  */)(cp2 + 1), (char const   */* __restrict  */)(cp + 4));
    }
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 1405
  while (1) {
    while_continue___6: /* CIL Label */ ;
    {
#line 1405
    tmp___1 = strlen((char const   *)file___0);
#line 1405
    l = (int )tmp___1;
    }
#line 1405
    if (l > 3) {
      {
#line 1405
      cp = (file___0 + l) - 3;
#line 1405
      tmp___2 = strcmp((char const   *)cp, "/..");
      }
#line 1405
      if (! (tmp___2 == 0)) {
#line 1405
        goto while_break___6;
      }
    } else {
#line 1405
      goto while_break___6;
    }
#line 1408
    cp2 = cp - 1;
    {
#line 1408
    while (1) {
      while_continue___7: /* CIL Label */ ;
#line 1408
      if ((unsigned long )cp2 >= (unsigned long )file___0) {
#line 1408
        if (! ((int )*cp2 != 47)) {
#line 1408
          goto while_break___7;
        }
      } else {
#line 1408
        goto while_break___7;
      }
#line 1409
      goto __Cont___1;
      __Cont___1: /* CIL Label */ 
#line 1408
      cp2 --;
    }
    while_break___7: /* CIL Label */ ;
    }
#line 1410
    if ((unsigned long )cp2 < (unsigned long )file___0) {
#line 1411
      goto while_break___6;
    }
#line 1412
    *cp2 = (char )'\000';
  }
  while_break___6: /* CIL Label */ ;
  }
#line 1414
  return;
}
}
#line 1417 "/home/wheatley/newnew/temp/mini-httpd-1.19/mini_httpd.c"
static int get_pathinfo(void) 
{ 
  int r ;
  size_t tmp ;

  {
  {
#line 1422
  tmp = strlen((char const   *)file);
#line 1422
  pathinfo = file + tmp;
  }
  {
#line 1423
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1425
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1427
      pathinfo --;
#line 1428
      if ((unsigned long )pathinfo <= (unsigned long )file) {
#line 1430
        pathinfo = (char *)0;
#line 1431
        return (-1);
      }
#line 1425
      if (! ((int )*pathinfo != 47)) {
#line 1425
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 1435
    *pathinfo = (char )'\000';
#line 1436
    r = stat((char const   */* __restrict  */)file, (struct stat */* __restrict  */)(& sb));
    }
#line 1437
    if (r >= 0) {
#line 1439
      pathinfo ++;
#line 1440
      return (r);
    } else {
#line 1443
      *pathinfo = (char )'/';
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 1448 "/home/wheatley/newnew/temp/mini-httpd-1.19/mini_httpd.c"
static void do_file(void) 
{ 
  char buf___1[10000] ;
  char mime_encodings[500] ;
  char const   *mime_type ;
  char fixed_mime_type[500] ;
  char *cp ;
  int fd ;
  char *tmp ;
  int tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;
  size_t tmp___3 ;
  int tmp___4 ;
  char *tmp___5 ;

  {
  {
#line 1459
  strncpy((char */* __restrict  */)(buf___1), (char const   */* __restrict  */)file,
          sizeof(buf___1));
#line 1460
  cp = strrchr((char const   *)(buf___1), '/');
  }
#line 1461
  if ((unsigned long )cp == (unsigned long )((char *)0)) {
    {
#line 1462
    strcpy((char */* __restrict  */)(buf___1), (char const   */* __restrict  */)".");
    }
  } else {
#line 1464
    *cp = (char )'\000';
  }
  {
#line 1465
  auth_check(buf___1);
#line 1468
  tmp___0 = strcmp((char const   *)file, ".htpasswd");
  }
#line 1468
  if (tmp___0 == 0) {
    {
#line 1472
    tmp = ntoa(& client_addr);
#line 1472
    syslog(5, "%.80s URL \"%.80s\" tried to retrieve an auth file", tmp, path);
#line 1475
    send_error(403, (char *)"Forbidden", (char *)"", (char *)"File is protected.");
    }
  } else {
    {
#line 1468
    tmp___1 = strlen((char const   *)file);
#line 1468
    tmp___2 = strcmp((char const   *)(file + ((tmp___1 - sizeof(".htpasswd")) + 1UL)),
                     ".htpasswd");
    }
#line 1468
    if (tmp___2 == 0) {
      {
#line 1468
      tmp___3 = strlen((char const   *)file);
      }
#line 1468
      if ((int )*(file + (tmp___3 - sizeof(".htpasswd"))) == 47) {
        {
#line 1472
        tmp = ntoa(& client_addr);
#line 1472
        syslog(5, "%.80s URL \"%.80s\" tried to retrieve an auth file", tmp, path);
#line 1475
        send_error(403, (char *)"Forbidden", (char *)"", (char *)"File is protected.");
        }
      }
    }
  }
  {
#line 1479
  check_referer();
  }
#line 1482
  if ((unsigned long )cgi_pattern != (unsigned long )((char *)0)) {
    {
#line 1482
    tmp___4 = match((char const   *)cgi_pattern, (char const   *)file);
    }
#line 1482
    if (tmp___4) {
      {
#line 1484
      do_cgi();
      }
#line 1485
      return;
    } else {
#line 1482
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 1487
  if ((unsigned long )pathinfo != (unsigned long )((char *)0)) {
    {
#line 1488
    send_error(404, (char *)"Not Found", (char *)"", (char *)"File not found.");
    }
  }
  {
#line 1490
  fd = open((char const   *)file, 0);
  }
#line 1491
  if (fd < 0) {
    {
#line 1493
    tmp___5 = ntoa(& client_addr);
#line 1493
    syslog(6, "%.80s File \"%.80s\" is protected", tmp___5, path);
#line 1496
    send_error(403, (char *)"Forbidden", (char *)"", (char *)"File is protected.");
    }
  }
  {
#line 1498
  mime_type = figure_mime(file, mime_encodings, sizeof(mime_encodings));
#line 1499
  snprintf((char */* __restrict  */)(fixed_mime_type), sizeof(fixed_mime_type), (char const   */* __restrict  */)mime_type,
           charset);
  }
#line 1501
  if (if_modified_since != -1L) {
#line 1501
    if (if_modified_since >= sb.st_mtim.tv_sec) {
      {
#line 1504
      add_headers(304, (char *)"Not Modified", (char *)"", mime_encodings, fixed_mime_type,
                  (off_t )-1, sb.st_mtim.tv_sec);
#line 1507
      send_response();
      }
#line 1508
      return;
    }
  }
  {
#line 1510
  add_headers(200, (char *)"Ok", (char *)"", mime_encodings, fixed_mime_type, sb.st_size,
              sb.st_mtim.tv_sec);
#line 1513
  send_response();
  }
#line 1514
  if (method == 2) {
#line 1515
    return;
  }
#line 1517
  if (sb.st_size > 0L) {
    {
#line 1522
    my_sendfile(fd, conn_fd, (off_t )0, (size_t )sb.st_size);
    }
  }
  {
#line 1537
  close(fd);
  }
#line 1538
  return;
}
}
#line 1541 "/home/wheatley/newnew/temp/mini-httpd-1.19/mini_httpd.c"
static void do_dir(void) 
{ 
  char buf___1[10000] ;
  size_t buflen ;
  char *contents ;
  size_t contents_size ;
  size_t contents_len ;
  int n ;
  int i ;
  struct dirent **dl ;
  char *name_info ;
  char *tmp ;
  int tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;

  {
#line 1557
  if ((unsigned long )pathinfo != (unsigned long )((char *)0)) {
    {
#line 1558
    send_error(404, (char *)"Not Found", (char *)"", (char *)"File not found.");
    }
  }
  {
#line 1561
  auth_check(file);
#line 1564
  check_referer();
#line 1567
  n = scandir((char const   */* __restrict  */)file, (struct dirent ***/* __restrict  */)(& dl),
              (int (*)(struct dirent  const  * ))((void *)0), (int (*)(struct dirent  const  ** ,
                                                                       struct dirent  const  ** ))(& alphasort));
  }
#line 1568
  if (n < 0) {
    {
#line 1570
    tmp = ntoa(& client_addr);
#line 1570
    syslog(6, "%.80s Directory \"%.80s\" is protected", tmp, path);
#line 1573
    send_error(403, (char *)"Forbidden", (char *)"", (char *)"Directory is protected.");
    }
  }
  {
#line 1577
  contents_size = (size_t )0;
#line 1578
  tmp___0 = snprintf((char */* __restrict  */)(buf___1), sizeof(buf___1), (char const   */* __restrict  */)"<HTML>\n<HEAD><TITLE>Index of %s</TITLE></HEAD>\n<BODY BGCOLOR=\"#99cc99\" TEXT=\"#000000\" LINK=\"#2020ff\" VLINK=\"#4040cc\">\n<H4>Index of %s</H4>\n<PRE>\n",
                     file, file);
#line 1578
  buflen = (size_t )tmp___0;
#line 1585
  add_to_buf(& contents, & contents_size, & contents_len, buf___1, buflen);
#line 1589
  i = 0;
  }
  {
#line 1589
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1589
    if (! (i < n)) {
#line 1589
      goto while_break;
    }
    {
#line 1591
    name_info = file_details((char const   *)file, (char const   *)((*(dl + i))->d_name));
#line 1592
    tmp___1 = strlen((char const   *)name_info);
#line 1592
    add_to_buf(& contents, & contents_size, & contents_len, name_info, tmp___1);
#line 1589
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1618
  tmp___2 = snprintf((char */* __restrict  */)(buf___1), sizeof(buf___1), (char const   */* __restrict  */)"</PRE>\n<HR>\n<ADDRESS><A HREF=\"%s\">%s</A></ADDRESS>\n</BODY>\n</HTML>\n",
                     "http://www.acme.com/software/mini_httpd/", "mini_httpd/1.19 19dec2003");
#line 1618
  buflen = (size_t )tmp___2;
#line 1625
  add_to_buf(& contents, & contents_size, & contents_len, buf___1, buflen);
#line 1627
  add_headers(200, (char *)"Ok", (char *)"", (char *)"", (char *)"text/html; charset=%s",
              (off_t )contents_len, sb.st_mtim.tv_sec);
  }
#line 1628
  if (method != 2) {
    {
#line 1629
    add_to_response(contents, contents_len);
    }
  }
  {
#line 1630
  send_response();
  }
#line 1631
  return;
}
}
#line 1641 "/home/wheatley/newnew/temp/mini-httpd-1.19/mini_httpd.c"
static char encname[1000]  ;
#line 1642 "/home/wheatley/newnew/temp/mini-httpd-1.19/mini_httpd.c"
static char buf[2000]  ;
#line 1636 "/home/wheatley/newnew/temp/mini-httpd-1.19/mini_httpd.c"
static char *file_details(char const   *dir___0 , char const   *name ) 
{ 
  struct stat sb___0 ;
  char f_time[20] ;
  int tmp ;
  struct tm *tmp___0 ;

  {
  {
#line 1644
  snprintf((char */* __restrict  */)(buf), sizeof(buf), (char const   */* __restrict  */)"%s/%s",
           dir___0, name);
#line 1645
  tmp = lstat((char const   */* __restrict  */)(buf), (struct stat */* __restrict  */)(& sb___0));
  }
#line 1645
  if (tmp < 0) {
#line 1646
    return ((char *)"???");
  }
  {
#line 1647
  tmp___0 = localtime((time_t const   *)(& sb___0.st_mtim.tv_sec));
#line 1647
  strftime((char */* __restrict  */)(f_time), sizeof(f_time), (char const   */* __restrict  */)"%d%b%Y %H:%M",
           (struct tm  const  */* __restrict  */)tmp___0);
#line 1648
  strencode(encname, sizeof(encname), name);
#line 1649
  snprintf((char */* __restrict  */)(buf), sizeof(buf), (char const   */* __restrict  */)"<A HREF=\"%s\">%-32.32s</A>    %15s %14lld\n",
           encname, name, f_time, sb___0.st_size);
  }
#line 1652
  return (buf);
}
}
#line 1657 "/home/wheatley/newnew/temp/mini-httpd-1.19/mini_httpd.c"
static void strencode(char *to , size_t tosize , char const   *from ) 
{ 
  int tolen ;
  unsigned short const   **tmp ;
  char *tmp___0 ;

  {
#line 1662
  tolen = 0;
  {
#line 1662
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1662
    if ((int const   )*from != 0) {
#line 1662
      if (! ((size_t )(tolen + 4) < tosize)) {
#line 1662
        goto while_break;
      }
    } else {
#line 1662
      goto while_break;
    }
    {
#line 1664
    tmp = __ctype_b_loc();
    }
#line 1664
    if ((int const   )*(*tmp + (int )*from) & 8) {
#line 1666
      *to = (char )*from;
#line 1667
      to ++;
#line 1668
      tolen ++;
    } else {
      {
#line 1664
      tmp___0 = strchr("/_.-~", (int )*from);
      }
#line 1664
      if ((unsigned long )tmp___0 != (unsigned long )((char *)0)) {
#line 1666
        *to = (char )*from;
#line 1667
        to ++;
#line 1668
        tolen ++;
      } else {
        {
#line 1672
        sprintf((char */* __restrict  */)to, (char const   */* __restrict  */)"%%%02x",
                (int )*from & 255);
#line 1673
        to += 3;
#line 1674
        tolen += 3;
        }
      }
    }
#line 1662
    from ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1677
  *to = (char )'\000';
#line 1678
  return;
}
}
#line 1683 "/home/wheatley/newnew/temp/mini-httpd-1.19/mini_httpd.c"
static void do_cgi(void) 
{ 
  char **argp ;
  char **envp___0 ;
  int parse_headers ;
  char *binary ;
  char *directory ;
  int newfd ;
  int tmp ;
  int p[2] ;
  int r ;
  int tmp___0 ;
  int tmp___1 ;
  int p___0[2] ;
  int r___0 ;
  int tmp___2 ;
  char *tmp___3 ;

  {
#line 1692
  if (method != 1) {
#line 1692
    if (method != 3) {
      {
#line 1693
      send_error(501, (char *)"Not Implemented", (char *)"", (char *)"That method is not implemented for CGI.");
      }
    }
  }
#line 1702
  if (conn_fd == 0) {
#line 1702
    goto _L;
  } else
#line 1702
  if (conn_fd == 1) {
#line 1702
    goto _L;
  } else
#line 1702
  if (conn_fd == 2) {
    _L: /* CIL Label */ 
    {
#line 1704
    tmp = dup2(conn_fd, 3);
#line 1704
    newfd = tmp;
    }
#line 1705
    if (newfd >= 0) {
#line 1706
      conn_fd = newfd;
    }
  }
  {
#line 1713
  envp___0 = make_envp();
#line 1716
  argp = make_argp();
  }
#line 1725
  if (method == 3) {
#line 1725
    if (request_len > request_idx) {
      {
#line 1731
      tmp___0 = pipe((int *)(p));
      }
#line 1731
      if (tmp___0 < 0) {
        {
#line 1732
        send_error(500, (char *)"Internal Error", (char *)"", (char *)"Something unexpected went wrong making a pipe.");
        }
      }
      {
#line 1733
      r = fork();
      }
#line 1734
      if (r < 0) {
        {
#line 1735
        send_error(500, (char *)"Internal Error", (char *)"", (char *)"Something unexpected went wrong forking an interposer.");
        }
      }
#line 1736
      if (r == 0) {
        {
#line 1739
        close(p[0]);
#line 1740
        cgi_interpose_input(p[1]);
#line 1741
        exit(0);
        }
      }
      {
#line 1743
      close(p[1]);
      }
#line 1744
      if (p[0] != 0) {
        {
#line 1746
        dup2(p[0], 0);
#line 1747
        close(p[0]);
        }
      }
    } else {
#line 1725
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 1753
  if (conn_fd != 0) {
    {
#line 1754
    dup2(conn_fd, 0);
    }
  }
  {
#line 1760
  tmp___1 = strncmp((char const   *)*(argp + 0), "nph-", (size_t )4);
  }
#line 1760
  if (tmp___1 == 0) {
#line 1761
    parse_headers = 0;
  } else {
#line 1763
    parse_headers = 1;
  }
#line 1767
  if (parse_headers) {
    {
#line 1773
    tmp___2 = pipe((int *)(p___0));
    }
#line 1773
    if (tmp___2 < 0) {
      {
#line 1774
      send_error(500, (char *)"Internal Error", (char *)"", (char *)"Something unexpected went wrong making a pipe.");
      }
    }
    {
#line 1775
    r___0 = fork();
    }
#line 1776
    if (r___0 < 0) {
      {
#line 1777
      send_error(500, (char *)"Internal Error", (char *)"", (char *)"Something unexpected went wrong forking an interposer.");
      }
    }
#line 1778
    if (r___0 == 0) {
      {
#line 1781
      close(p___0[1]);
#line 1782
      cgi_interpose_output(p___0[0], parse_headers);
#line 1783
      exit(0);
      }
    }
    {
#line 1785
    close(p___0[0]);
    }
#line 1786
    if (p___0[1] != 1) {
      {
#line 1787
      dup2(p___0[1], 1);
      }
    }
#line 1788
    if (p___0[1] != 2) {
      {
#line 1789
      dup2(p___0[1], 2);
      }
    }
#line 1790
    if (p___0[1] != 1) {
#line 1790
      if (p___0[1] != 2) {
        {
#line 1791
        close(p___0[1]);
        }
      }
    }
  } else {
#line 1796
    if (conn_fd != 1) {
      {
#line 1797
      dup2(conn_fd, 1);
      }
    }
#line 1798
    if (conn_fd != 2) {
      {
#line 1799
      dup2(conn_fd, 2);
      }
    }
  }
#line 1814
  if ((unsigned long )logfp != (unsigned long )((FILE *)0)) {
    {
#line 1815
    fclose(logfp);
    }
  }
  {
#line 1818
  closelog();
#line 1821
  nice(10);
#line 1827
  directory = e_strdup(file);
#line 1828
  binary = strrchr((char const   *)directory, '/');
  }
#line 1829
  if ((unsigned long )binary == (unsigned long )((char *)0)) {
#line 1830
    binary = file;
  } else {
    {
#line 1833
    tmp___3 = binary;
#line 1833
    binary ++;
#line 1833
    *tmp___3 = (char )'\000';
#line 1834
    chdir((char const   *)directory);
    }
  }
  {
#line 1841
  signal(13, (void (*)(int  ))0);
#line 1845
  execve((char const   *)binary, (char * const  *)argp, (char * const  *)envp___0);
#line 1848
  send_error(500, (char *)"Internal Error", (char *)"", (char *)"Something unexpected went wrong running a CGI program.");
  }
#line 1849
  return;
}
}
#line 1860 "/home/wheatley/newnew/temp/mini-httpd-1.19/mini_httpd.c"
static void cgi_interpose_input(int wfd ) 
{ 
  size_t c ;
  ssize_t r ;
  ssize_t r2 ;
  char buf___1[1024] ;
  ssize_t tmp ;
  unsigned long tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;
  int *tmp___4 ;

  {
#line 1867
  c = request_len - request_idx;
#line 1868
  if (c > 0UL) {
    {
#line 1870
    tmp = write(wfd, (void const   *)(request + request_idx), c);
    }
#line 1870
    if ((size_t )tmp != c) {
#line 1871
      return;
    }
  }
  {
#line 1873
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1873
    if (! (c < content_length)) {
#line 1873
      goto while_break;
    }
#line 1875
    if (sizeof(buf___1) < content_length - c) {
#line 1875
      tmp___0 = sizeof(buf___1);
    } else {
#line 1875
      tmp___0 = content_length - c;
    }
    {
#line 1875
    r = my_read(buf___1, tmp___0);
    }
#line 1876
    if (r < 0L) {
      {
#line 1876
      tmp___1 = __errno_location();
      }
#line 1876
      if (*tmp___1 == 4) {
        {
#line 1878
        sleep(1U);
        }
#line 1879
        goto while_continue;
      } else {
        {
#line 1876
        tmp___2 = __errno_location();
        }
#line 1876
        if (*tmp___2 == 11) {
          {
#line 1878
          sleep(1U);
          }
#line 1879
          goto while_continue;
        }
      }
    }
#line 1881
    if (r <= 0L) {
#line 1882
      return;
    }
    {
#line 1883
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 1885
      r2 = write(wfd, (void const   *)(buf___1), (size_t )r);
      }
#line 1886
      if (r2 < 0L) {
        {
#line 1886
        tmp___3 = __errno_location();
        }
#line 1886
        if (*tmp___3 == 4) {
          {
#line 1888
          sleep(1U);
          }
#line 1889
          goto __Cont;
        } else {
          {
#line 1886
          tmp___4 = __errno_location();
          }
#line 1886
          if (*tmp___4 == 11) {
            {
#line 1888
            sleep(1U);
            }
#line 1889
            goto __Cont;
          }
        }
      }
#line 1891
      if (r2 != r) {
#line 1892
        return;
      }
#line 1893
      goto while_break___0;
      __Cont: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1895
    c += (size_t )r;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1897
  post_post_garbage_hack();
  }
#line 1898
  return;
}
}
#line 1908 "/home/wheatley/newnew/temp/mini-httpd-1.19/mini_httpd.c"
static void post_post_garbage_hack(void) 
{ 
  char buf___1[2] ;

  {
  {
#line 1921
  set_ndelay(conn_fd);
#line 1922
  read(conn_fd, (void *)(buf___1), sizeof(buf___1));
#line 1923
  clear_ndelay(conn_fd);
  }
#line 1924
  return;
}
}
#line 1928 "/home/wheatley/newnew/temp/mini-httpd-1.19/mini_httpd.c"
static void cgi_interpose_output(int rfd , int parse_headers ) 
{ 
  ssize_t r ;
  ssize_t r2 ;
  char buf___1[1024] ;
  char http_head[18] ;
  size_t headers_size ;
  size_t headers_len ;
  char *headers ;
  char *br ;
  int status___0 ;
  char *title ;
  char *cp ;
  int *tmp ;
  int *tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  int *tmp___3 ;
  int *tmp___4 ;
  int *tmp___5 ;
  int *tmp___6 ;

  {
#line 1934
  if (! parse_headers) {
    {
#line 1939
    http_head[0] = (char )'H';
#line 1939
    http_head[1] = (char )'T';
#line 1939
    http_head[2] = (char )'T';
#line 1939
    http_head[3] = (char )'P';
#line 1939
    http_head[4] = (char )'/';
#line 1939
    http_head[5] = (char )'1';
#line 1939
    http_head[6] = (char )'.';
#line 1939
    http_head[7] = (char )'0';
#line 1939
    http_head[8] = (char )' ';
#line 1939
    http_head[9] = (char )'2';
#line 1939
    http_head[10] = (char )'0';
#line 1939
    http_head[11] = (char )'0';
#line 1939
    http_head[12] = (char )' ';
#line 1939
    http_head[13] = (char )'O';
#line 1939
    http_head[14] = (char )'K';
#line 1939
    http_head[15] = (char )'\r';
#line 1939
    http_head[16] = (char )'\n';
#line 1939
    http_head[17] = (char )'\000';
#line 1940
    my_write(http_head, sizeof(http_head));
    }
  } else {
    {
#line 1960
    headers_size = (size_t )0;
#line 1961
    add_to_buf(& headers, & headers_size, & headers_len, (char *)0, (size_t )0);
    }
    {
#line 1962
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 1964
      r = read(rfd, (void *)(buf___1), sizeof(buf___1));
      }
#line 1965
      if (r < 0L) {
        {
#line 1965
        tmp = __errno_location();
        }
#line 1965
        if (*tmp == 4) {
          {
#line 1967
          sleep(1U);
          }
#line 1968
          goto __Cont;
        } else {
          {
#line 1965
          tmp___0 = __errno_location();
          }
#line 1965
          if (*tmp___0 == 11) {
            {
#line 1967
            sleep(1U);
            }
#line 1968
            goto __Cont;
          }
        }
      }
#line 1970
      if (r <= 0L) {
#line 1972
        br = headers + headers_len;
#line 1973
        goto while_break;
      }
      {
#line 1975
      add_to_buf(& headers, & headers_size, & headers_len, buf___1, (size_t )r);
#line 1976
      br = strstr((char const   *)headers, "\r\n\r\n");
      }
#line 1976
      if ((unsigned long )br != (unsigned long )((char *)0)) {
#line 1978
        goto while_break;
      } else {
        {
#line 1976
        br = strstr((char const   *)headers, "\n\n");
        }
#line 1976
        if ((unsigned long )br != (unsigned long )((char *)0)) {
#line 1978
          goto while_break;
        }
      }
      __Cont: /* CIL Label */ ;
    }
    while_break: /* CIL Label */ ;
    }
#line 1982
    if ((int )*(headers + 0) == 0) {
#line 1983
      return;
    }
    {
#line 1986
    status___0 = 200;
#line 1987
    cp = strstr((char const   *)headers, "Status:");
    }
#line 1987
    if ((unsigned long )cp != (unsigned long )((char *)0)) {
#line 1987
      if ((unsigned long )cp < (unsigned long )br) {
#line 1987
        if ((unsigned long )cp == (unsigned long )headers) {
          {
#line 1991
          cp += 7;
#line 1992
          tmp___1 = strspn((char const   *)cp, " \t");
#line 1992
          cp += tmp___1;
#line 1993
          status___0 = atoi((char const   *)cp);
          }
        } else
#line 1987
        if ((int )*(cp - 1) == 10) {
          {
#line 1991
          cp += 7;
#line 1992
          tmp___1 = strspn((char const   *)cp, " \t");
#line 1992
          cp += tmp___1;
#line 1993
          status___0 = atoi((char const   *)cp);
          }
        }
      }
    }
    {
#line 1995
    cp = strstr((char const   *)headers, "Location:");
    }
#line 1995
    if ((unsigned long )cp != (unsigned long )((char *)0)) {
#line 1995
      if ((unsigned long )cp < (unsigned long )br) {
#line 1995
        if ((unsigned long )cp == (unsigned long )headers) {
#line 1998
          status___0 = 302;
        } else
#line 1995
        if ((int )*(cp - 1) == 10) {
#line 1998
          status___0 = 302;
        }
      }
    }
    {
#line 2003
    if (status___0 == 200) {
#line 2003
      goto case_200;
    }
#line 2004
    if (status___0 == 302) {
#line 2004
      goto case_302;
    }
#line 2005
    if (status___0 == 304) {
#line 2005
      goto case_304;
    }
#line 2006
    if (status___0 == 400) {
#line 2006
      goto case_400;
    }
#line 2007
    if (status___0 == 401) {
#line 2007
      goto case_401;
    }
#line 2008
    if (status___0 == 403) {
#line 2008
      goto case_403;
    }
#line 2009
    if (status___0 == 404) {
#line 2009
      goto case_404;
    }
#line 2010
    if (status___0 == 408) {
#line 2010
      goto case_408;
    }
#line 2011
    if (status___0 == 500) {
#line 2011
      goto case_500;
    }
#line 2012
    if (status___0 == 501) {
#line 2012
      goto case_501;
    }
#line 2013
    if (status___0 == 503) {
#line 2013
      goto case_503;
    }
#line 2014
    goto switch_default;
    case_200: /* CIL Label */ 
#line 2003
    title = (char *)"OK";
#line 2003
    goto switch_break;
    case_302: /* CIL Label */ 
#line 2004
    title = (char *)"Found";
#line 2004
    goto switch_break;
    case_304: /* CIL Label */ 
#line 2005
    title = (char *)"Not Modified";
#line 2005
    goto switch_break;
    case_400: /* CIL Label */ 
#line 2006
    title = (char *)"Bad Request";
#line 2006
    goto switch_break;
    case_401: /* CIL Label */ 
#line 2007
    title = (char *)"Unauthorized";
#line 2007
    goto switch_break;
    case_403: /* CIL Label */ 
#line 2008
    title = (char *)"Forbidden";
#line 2008
    goto switch_break;
    case_404: /* CIL Label */ 
#line 2009
    title = (char *)"Not Found";
#line 2009
    goto switch_break;
    case_408: /* CIL Label */ 
#line 2010
    title = (char *)"Request Timeout";
#line 2010
    goto switch_break;
    case_500: /* CIL Label */ 
#line 2011
    title = (char *)"Internal Error";
#line 2011
    goto switch_break;
    case_501: /* CIL Label */ 
#line 2012
    title = (char *)"Not Implemented";
#line 2012
    goto switch_break;
    case_503: /* CIL Label */ 
#line 2013
    title = (char *)"Service Temporarily Overloaded";
#line 2013
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 2014
    title = (char *)"Something";
#line 2014
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
    {
#line 2016
    snprintf((char */* __restrict  */)(buf___1), sizeof(buf___1), (char const   */* __restrict  */)"HTTP/1.0 %d %s\r\n",
             status___0, title);
#line 2018
    tmp___2 = strlen((char const   *)(buf___1));
#line 2018
    my_write(buf___1, tmp___2);
#line 2021
    my_write(headers, headers_len);
    }
  }
  {
#line 2025
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 2027
    r = read(rfd, (void *)(buf___1), sizeof(buf___1));
    }
#line 2028
    if (r < 0L) {
      {
#line 2028
      tmp___3 = __errno_location();
      }
#line 2028
      if (*tmp___3 == 4) {
        {
#line 2030
        sleep(1U);
        }
#line 2031
        goto __Cont___0;
      } else {
        {
#line 2028
        tmp___4 = __errno_location();
        }
#line 2028
        if (*tmp___4 == 11) {
          {
#line 2030
          sleep(1U);
          }
#line 2031
          goto __Cont___0;
        }
      }
    }
#line 2033
    if (r <= 0L) {
#line 2034
      goto done;
    }
    {
#line 2035
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 2037
      r2 = my_write(buf___1, (size_t )r);
      }
#line 2038
      if (r2 < 0L) {
        {
#line 2038
        tmp___5 = __errno_location();
        }
#line 2038
        if (*tmp___5 == 4) {
          {
#line 2040
          sleep(1U);
          }
#line 2041
          goto __Cont___1;
        } else {
          {
#line 2038
          tmp___6 = __errno_location();
          }
#line 2038
          if (*tmp___6 == 11) {
            {
#line 2040
            sleep(1U);
            }
#line 2041
            goto __Cont___1;
          }
        }
      }
#line 2043
      if (r2 != r) {
#line 2044
        goto done;
      }
#line 2045
      goto while_break___1;
      __Cont___1: /* CIL Label */ ;
    }
    while_break___1: /* CIL Label */ ;
    }
    __Cont___0: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
  done: 
  {
#line 2049
  shutdown(conn_fd, 1);
  }
#line 2050
  return;
}
}
#line 2057 "/home/wheatley/newnew/temp/mini-httpd-1.19/mini_httpd.c"
static char **make_argp(void) 
{ 
  char **argp ;
  int argn ;
  char *cp1 ;
  char *cp2 ;
  size_t tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;

  {
  {
#line 2069
  tmp = strlen((char const   *)query);
#line 2069
  tmp___0 = malloc((tmp + 2UL) * sizeof(char *));
#line 2069
  argp = (char **)tmp___0;
  }
#line 2070
  if ((unsigned long )argp == (unsigned long )((char **)0)) {
#line 2071
    return ((char **)0);
  }
  {
#line 2073
  *(argp + 0) = strrchr((char const   *)file, '/');
  }
#line 2074
  if ((unsigned long )*(argp + 0) != (unsigned long )((char *)0)) {
#line 2075
    (*(argp + 0)) ++;
  } else {
#line 2077
    *(argp + 0) = file;
  }
  {
#line 2079
  argn = 1;
#line 2085
  tmp___3 = strchr((char const   *)query, '=');
  }
#line 2085
  if ((unsigned long )tmp___3 == (unsigned long )((char *)0)) {
#line 2087
    cp2 = query;
#line 2087
    cp1 = cp2;
    {
#line 2087
    while (1) {
      while_continue: /* CIL Label */ ;
#line 2087
      if (! ((int )*cp2 != 0)) {
#line 2087
        goto while_break;
      }
#line 2089
      if ((int )*cp2 == 43) {
        {
#line 2091
        *cp2 = (char )'\000';
#line 2092
        strdecode(cp1, cp1);
#line 2093
        tmp___1 = argn;
#line 2093
        argn ++;
#line 2093
        *(argp + tmp___1) = cp1;
#line 2094
        cp1 = cp2 + 1;
        }
      }
#line 2087
      cp2 ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 2097
    if ((unsigned long )cp2 != (unsigned long )cp1) {
      {
#line 2099
      strdecode(cp1, cp1);
#line 2100
      tmp___2 = argn;
#line 2100
      argn ++;
#line 2100
      *(argp + tmp___2) = cp1;
      }
    }
  }
#line 2104
  *(argp + argn) = (char *)0;
#line 2105
  return (argp);
}
}
#line 2116 "/home/wheatley/newnew/temp/mini-httpd-1.19/mini_httpd.c"
static char *envp[50]  ;
#line 2113 "/home/wheatley/newnew/temp/mini-httpd-1.19/mini_httpd.c"
static char **make_envp(void) 
{ 
  int envn ;
  char *cp ;
  char buf___1[256] ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  char *tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  char *tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  char *tmp___23 ;
  char *tmp___24 ;

  {
  {
#line 2121
  envn = 0;
#line 2122
  tmp = envn;
#line 2122
  envn ++;
#line 2122
  envp[tmp] = build_env((char *)"PATH=%s", (char *)"/usr/local/bin:/usr/ucb:/bin:/usr/bin");
#line 2123
  tmp___0 = envn;
#line 2123
  envn ++;
#line 2123
  envp[tmp___0] = build_env((char *)"LD_LIBRARY_PATH=%s", (char *)"/usr/local/lib:/usr/lib");
#line 2124
  tmp___1 = envn;
#line 2124
  envn ++;
#line 2124
  envp[tmp___1] = build_env((char *)"SERVER_SOFTWARE=%s", (char *)"mini_httpd/1.19 19dec2003");
  }
#line 2125
  if (! vhost) {
#line 2126
    cp = hostname;
  } else {
#line 2128
    cp = req_hostname;
  }
#line 2129
  if ((unsigned long )cp != (unsigned long )((char *)0)) {
    {
#line 2130
    tmp___2 = envn;
#line 2130
    envn ++;
#line 2130
    envp[tmp___2] = build_env((char *)"SERVER_NAME=%s", cp);
    }
  }
  {
#line 2131
  tmp___3 = envn;
#line 2131
  envn ++;
#line 2131
  envp[tmp___3] = (char *)"GATEWAY_INTERFACE=CGI/1.1";
#line 2132
  tmp___4 = envn;
#line 2132
  envn ++;
#line 2132
  envp[tmp___4] = (char *)"SERVER_PROTOCOL=HTTP/1.0";
#line 2133
  snprintf((char */* __restrict  */)(buf___1), sizeof(buf___1), (char const   */* __restrict  */)"%d",
           (int )port);
#line 2134
  tmp___5 = envn;
#line 2134
  envn ++;
#line 2134
  envp[tmp___5] = build_env((char *)"SERVER_PORT=%s", buf___1);
#line 2135
  tmp___6 = envn;
#line 2135
  envn ++;
#line 2135
  tmp___7 = get_method_str(method);
#line 2135
  envp[tmp___6] = build_env((char *)"REQUEST_METHOD=%s", tmp___7);
#line 2137
  tmp___8 = envn;
#line 2137
  envn ++;
#line 2137
  envp[tmp___8] = build_env((char *)"SCRIPT_NAME=%s", path);
  }
#line 2138
  if ((unsigned long )pathinfo != (unsigned long )((char *)0)) {
    {
#line 2140
    tmp___9 = envn;
#line 2140
    envn ++;
#line 2140
    envp[tmp___9] = build_env((char *)"PATH_INFO=/%s", pathinfo);
#line 2141
    snprintf((char */* __restrict  */)(buf___1), sizeof(buf___1), (char const   */* __restrict  */)"%s%s",
             cwd, pathinfo);
#line 2142
    tmp___10 = envn;
#line 2142
    envn ++;
#line 2142
    envp[tmp___10] = build_env((char *)"PATH_TRANSLATED=%s", buf___1);
    }
  }
#line 2144
  if ((int )*(query + 0) != 0) {
    {
#line 2145
    tmp___11 = envn;
#line 2145
    envn ++;
#line 2145
    envp[tmp___11] = build_env((char *)"QUERY_STRING=%s", query);
    }
  }
  {
#line 2146
  tmp___12 = envn;
#line 2146
  envn ++;
#line 2146
  tmp___13 = ntoa(& client_addr);
#line 2146
  envp[tmp___12] = build_env((char *)"REMOTE_ADDR=%s", tmp___13);
  }
#line 2147
  if ((int )*(referer + 0) != 0) {
    {
#line 2148
    tmp___14 = envn;
#line 2148
    envn ++;
#line 2148
    envp[tmp___14] = build_env((char *)"HTTP_REFERER=%s", referer);
    }
  }
#line 2149
  if ((int )*(useragent + 0) != 0) {
    {
#line 2150
    tmp___15 = envn;
#line 2150
    envn ++;
#line 2150
    envp[tmp___15] = build_env((char *)"HTTP_USER_AGENT=%s", useragent);
    }
  }
#line 2151
  if ((unsigned long )cookie != (unsigned long )((char *)0)) {
    {
#line 2152
    tmp___16 = envn;
#line 2152
    envn ++;
#line 2152
    envp[tmp___16] = build_env((char *)"HTTP_COOKIE=%s", cookie);
    }
  }
#line 2153
  if ((unsigned long )host != (unsigned long )((char *)0)) {
    {
#line 2154
    tmp___17 = envn;
#line 2154
    envn ++;
#line 2154
    envp[tmp___17] = build_env((char *)"HTTP_HOST=%s", host);
    }
  }
#line 2155
  if ((unsigned long )content_type != (unsigned long )((char *)0)) {
    {
#line 2156
    tmp___18 = envn;
#line 2156
    envn ++;
#line 2156
    envp[tmp___18] = build_env((char *)"CONTENT_TYPE=%s", content_type);
    }
  }
#line 2157
  if (content_length != 0xffffffffffffffffUL) {
    {
#line 2159
    snprintf((char */* __restrict  */)(buf___1), sizeof(buf___1), (char const   */* __restrict  */)"%lu",
             content_length);
#line 2161
    tmp___19 = envn;
#line 2161
    envn ++;
#line 2161
    envp[tmp___19] = build_env((char *)"CONTENT_LENGTH=%s", buf___1);
    }
  }
#line 2163
  if ((unsigned long )remoteuser != (unsigned long )((char *)0)) {
    {
#line 2164
    tmp___20 = envn;
#line 2164
    envn ++;
#line 2164
    envp[tmp___20] = build_env((char *)"REMOTE_USER=%s", remoteuser);
    }
  }
#line 2165
  if ((unsigned long )authorization != (unsigned long )((char *)0)) {
    {
#line 2166
    tmp___21 = envn;
#line 2166
    envn ++;
#line 2166
    envp[tmp___21] = build_env((char *)"AUTH_TYPE=%s", (char *)"Basic");
    }
  }
  {
#line 2167
  tmp___24 = getenv("TZ");
  }
#line 2167
  if ((unsigned long )tmp___24 != (unsigned long )((char *)0)) {
    {
#line 2168
    tmp___22 = envn;
#line 2168
    envn ++;
#line 2168
    tmp___23 = getenv("TZ");
#line 2168
    envp[tmp___22] = build_env((char *)"TZ=%s", tmp___23);
    }
  }
#line 2170
  envp[envn] = (char *)0;
#line 2171
  return (envp);
}
}
#line 2180 "/home/wheatley/newnew/temp/mini-httpd-1.19/mini_httpd.c"
static char *buf___0  ;
#line 2181 "/home/wheatley/newnew/temp/mini-httpd-1.19/mini_httpd.c"
static int maxbuf  =    0;
#line 2175 "/home/wheatley/newnew/temp/mini-httpd-1.19/mini_httpd.c"
static char *build_env(char *fmt , char *arg ) 
{ 
  char *cp ;
  int size ;
  size_t tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;

  {
  {
#line 2183
  tmp = strlen((char const   *)fmt);
#line 2183
  tmp___0 = strlen((char const   *)arg);
#line 2183
  size = (int )(tmp + tmp___0);
  }
#line 2184
  if (size > maxbuf) {
#line 2186
    if (maxbuf == 0) {
#line 2188
      if (200 > size + 100) {
#line 2188
        maxbuf = 200;
      } else {
#line 2188
        maxbuf = size + 100;
      }
      {
#line 2189
      tmp___1 = e_malloc((size_t )maxbuf);
#line 2189
      buf___0 = (char *)tmp___1;
      }
    } else {
#line 2193
      if (maxbuf * 2 > (size * 5) / 4) {
#line 2193
        maxbuf *= 2;
      } else {
#line 2193
        maxbuf = (size * 5) / 4;
      }
      {
#line 2194
      tmp___2 = e_realloc((void *)buf___0, (size_t )maxbuf);
#line 2194
      buf___0 = (char *)tmp___2;
      }
    }
  }
  {
#line 2197
  snprintf((char */* __restrict  */)buf___0, (size_t )maxbuf, (char const   */* __restrict  */)fmt,
           arg);
#line 2198
  cp = e_strdup(buf___0);
  }
#line 2199
  return (cp);
}
}
#line 2211 "/home/wheatley/newnew/temp/mini-httpd-1.19/mini_httpd.c"
static char line[10000]  ;
#line 2203 "/home/wheatley/newnew/temp/mini-httpd-1.19/mini_httpd.c"
static void auth_check(char *dirname ) 
{ 
  char authpath[10000] ;
  struct stat sb___0 ;
  char authinfo[500] ;
  char *authpass ;
  char *colon ;
  int l ;
  FILE *fp ;
  char *cryp ;
  size_t tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  size_t tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  char *tmp___9 ;

  {
  {
#line 2217
  tmp = strlen((char const   *)dirname);
  }
#line 2217
  if ((int )*(dirname + (tmp - 1UL)) == 47) {
    {
#line 2218
    snprintf((char */* __restrict  */)(authpath), sizeof(authpath), (char const   */* __restrict  */)"%s%s",
             dirname, ".htpasswd");
    }
  } else {
    {
#line 2220
    snprintf((char */* __restrict  */)(authpath), sizeof(authpath), (char const   */* __restrict  */)"%s/%s",
             dirname, ".htpasswd");
    }
  }
  {
#line 2223
  tmp___0 = stat((char const   */* __restrict  */)(authpath), (struct stat */* __restrict  */)(& sb___0));
  }
#line 2223
  if (tmp___0 < 0) {
#line 2225
    return;
  }
#line 2228
  if ((unsigned long )authorization == (unsigned long )((char *)0)) {
    {
#line 2230
    send_authenticate(dirname);
    }
  }
  {
#line 2233
  tmp___1 = strncmp((char const   *)authorization, "Basic ", (size_t )6);
  }
#line 2233
  if (tmp___1 != 0) {
    {
#line 2234
    send_authenticate(dirname);
    }
  }
  {
#line 2237
  l = b64_decode((char const   *)(authorization + 6), (unsigned char *)(authinfo),
                 (int )(sizeof(authinfo) - 1UL));
#line 2239
  authinfo[l] = (char )'\000';
#line 2241
  authpass = strchr((char const   *)(authinfo), ':');
  }
#line 2242
  if ((unsigned long )authpass == (unsigned long )((char *)0)) {
    {
#line 2244
    send_authenticate(dirname);
    }
  }
  {
#line 2245
  tmp___2 = authpass;
#line 2245
  authpass ++;
#line 2245
  *tmp___2 = (char )'\000';
#line 2247
  colon = strchr((char const   *)authpass, ':');
  }
#line 2248
  if ((unsigned long )colon != (unsigned long )((char *)0)) {
#line 2249
    *colon = (char )'\000';
  }
  {
#line 2252
  fp = fopen((char const   */* __restrict  */)(authpath), (char const   */* __restrict  */)"r");
  }
#line 2253
  if ((unsigned long )fp == (unsigned long )((FILE *)0)) {
    {
#line 2256
    tmp___3 = ntoa(& client_addr);
#line 2256
    syslog(3, "%.80s auth file %.80s could not be opened - %m", tmp___3, authpath);
#line 2259
    send_error(403, (char *)"Forbidden", (char *)"", (char *)"File is protected.");
    }
  }
  {
#line 2263
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 2263
    tmp___9 = fgets((char */* __restrict  */)(line), (int )sizeof(line), (FILE */* __restrict  */)fp);
    }
#line 2263
    if (! ((unsigned long )tmp___9 != (unsigned long )((char *)0))) {
#line 2263
      goto while_break;
    }
    {
#line 2266
    tmp___4 = strlen((char const   *)(line));
#line 2266
    l = (int )tmp___4;
    }
#line 2267
    if ((int )line[l - 1] == 10) {
#line 2268
      line[l - 1] = (char )'\000';
    }
    {
#line 2270
    cryp = strchr((char const   *)(line), ':');
    }
#line 2271
    if ((unsigned long )cryp == (unsigned long )((char *)0)) {
#line 2272
      goto while_continue;
    }
    {
#line 2273
    tmp___5 = cryp;
#line 2273
    cryp ++;
#line 2273
    *tmp___5 = (char )'\000';
#line 2275
    tmp___8 = strcmp((char const   *)(line), (char const   *)(authinfo));
    }
#line 2275
    if (tmp___8 == 0) {
      {
#line 2278
      fclose(fp);
#line 2280
      tmp___6 = crypt((char const   *)authpass, (char const   *)cryp);
#line 2280
      tmp___7 = strcmp((char const   *)tmp___6, (char const   *)cryp);
      }
#line 2280
      if (tmp___7 == 0) {
#line 2283
        remoteuser = line;
#line 2284
        return;
      } else {
        {
#line 2288
        send_authenticate(dirname);
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2293
  fclose(fp);
#line 2294
  send_authenticate(dirname);
  }
#line 2295
  return;
}
}
#line 2298 "/home/wheatley/newnew/temp/mini-httpd-1.19/mini_httpd.c"
static void send_authenticate(char *realm ) 
{ 
  char header[10000] ;

  {
  {
#line 2303
  snprintf((char */* __restrict  */)(header), sizeof(header), (char const   */* __restrict  */)"WWW-Authenticate: Basic realm=\"%s\"",
           realm);
#line 2305
  send_error(401, (char *)"Unauthorized", header, (char *)"Authorization required.");
  }
#line 2306
  return;
}
}
#line 2313 "/home/wheatley/newnew/temp/mini-httpd-1.19/mini_httpd.c"
static char vfile[10000]  ;
#line 2309 "/home/wheatley/newnew/temp/mini-httpd-1.19/mini_httpd.c"
static char *virtual_file(char *file___0 ) 
{ 
  char *cp ;
  usockaddr usa ;
  int sz ;
  int tmp ;
  int tmp___0 ;
  unsigned short const   **tmp___1 ;

  {
#line 2316
  if ((unsigned long )host != (unsigned long )((char *)0)) {
#line 2317
    req_hostname = host;
  } else {
    {
#line 2321
    sz = (int )sizeof(usa);
#line 2322
    tmp = getsockname(conn_fd, (struct sockaddr */* __restrict  */)(& usa.sa), (socklen_t */* __restrict  */)(& sz));
    }
#line 2322
    if (tmp < 0) {
#line 2323
      req_hostname = (char *)"UNKNOWN_HOST";
    } else {
      {
#line 2325
      req_hostname = ntoa(& usa);
      }
    }
  }
#line 2328
  cp = req_hostname;
  {
#line 2328
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2328
    if (! ((int )*cp != 0)) {
#line 2328
      goto while_break;
    }
    {
#line 2329
    tmp___1 = __ctype_b_loc();
    }
#line 2329
    if ((int const   )*(*tmp___1 + (int )*cp) & 256) {
      {
#line 2330
      tmp___0 = tolower((int )*cp);
#line 2330
      *cp = (char )tmp___0;
      }
    }
#line 2328
    cp ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2331
  snprintf((char */* __restrict  */)(vfile), sizeof(vfile), (char const   */* __restrict  */)"%s/%s",
           req_hostname, file___0);
  }
#line 2332
  return (vfile);
}
}
#line 2336 "/home/wheatley/newnew/temp/mini-httpd-1.19/mini_httpd.c"
static void send_error(int s , char *title , char *extra_header , char *text ) 
{ 


  {
  {
#line 2339
  add_headers(s, title, extra_header, (char *)"", (char *)"text/html; charset=%s",
              (off_t )-1, (time_t )-1);
#line 2342
  send_error_body(s, title, text);
#line 2344
  send_error_tail();
#line 2346
  send_response();
#line 2351
  exit(1);
  }
}
}
#line 2355 "/home/wheatley/newnew/temp/mini-httpd-1.19/mini_httpd.c"
static void send_error_body(int s , char *title , char *text ) 
{ 
  char filename[1000] ;
  char buf___1[10000] ;
  int buflen ;
  int tmp ;
  int tmp___0 ;

  {
#line 2362
  if (vhost) {
#line 2362
    if ((unsigned long )req_hostname != (unsigned long )((char *)0)) {
      {
#line 2365
      snprintf((char */* __restrict  */)(filename), sizeof(filename), (char const   */* __restrict  */)"%s/%s/err%d.html",
               req_hostname, "errors", s);
#line 2368
      tmp = send_error_file(filename);
      }
#line 2368
      if (tmp) {
#line 2369
        return;
      }
    }
  }
  {
#line 2373
  snprintf((char */* __restrict  */)(filename), sizeof(filename), (char const   */* __restrict  */)"%s/err%d.html",
           "errors", s);
#line 2375
  tmp___0 = send_error_file(filename);
  }
#line 2375
  if (tmp___0) {
#line 2376
    return;
  }
  {
#line 2379
  buflen = snprintf((char */* __restrict  */)(buf___1), sizeof(buf___1), (char const   */* __restrict  */)"<HTML>\n<HEAD><TITLE>%d %s</TITLE></HEAD>\n<BODY BGCOLOR=\"#cc9999\" TEXT=\"#000000\" LINK=\"#2020ff\" VLINK=\"#4040cc\">\n<H4>%d %s</H4>\n",
                    s, title, s, title);
#line 2386
  add_to_response(buf___1, (size_t )buflen);
#line 2387
  buflen = snprintf((char */* __restrict  */)(buf___1), sizeof(buf___1), (char const   */* __restrict  */)"%s\n",
                    text);
#line 2388
  add_to_response(buf___1, (size_t )buflen);
  }
#line 2389
  return;
}
}
#line 2392 "/home/wheatley/newnew/temp/mini-httpd-1.19/mini_httpd.c"
static int send_error_file(char *filename ) 
{ 
  FILE *fp ;
  char buf___1[1000] ;
  size_t r ;

  {
  {
#line 2399
  fp = fopen((char const   */* __restrict  */)filename, (char const   */* __restrict  */)"r");
  }
#line 2400
  if ((unsigned long )fp == (unsigned long )((FILE *)0)) {
#line 2401
    return (0);
  }
  {
#line 2402
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 2404
    r = fread((void */* __restrict  */)(buf___1), (size_t )1, sizeof(buf___1), (FILE */* __restrict  */)fp);
    }
#line 2405
    if (r == 0UL) {
#line 2406
      goto while_break;
    }
    {
#line 2407
    add_to_response(buf___1, r);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2409
  fclose(fp);
  }
#line 2410
  return (1);
}
}
#line 2414 "/home/wheatley/newnew/temp/mini-httpd-1.19/mini_httpd.c"
static void send_error_tail(void) 
{ 
  char buf___1[500] ;
  int buflen ;
  int n ;
  int tmp ;

  {
  {
#line 2420
  tmp = match("**MSIE**", (char const   *)useragent);
  }
#line 2420
  if (tmp) {
    {
#line 2423
    buflen = snprintf((char */* __restrict  */)(buf___1), sizeof(buf___1), (char const   */* __restrict  */)"<!--\n");
#line 2424
    add_to_response(buf___1, (size_t )buflen);
#line 2425
    n = 0;
    }
    {
#line 2425
    while (1) {
      while_continue: /* CIL Label */ ;
#line 2425
      if (! (n < 6)) {
#line 2425
        goto while_break;
      }
      {
#line 2427
      buflen = snprintf((char */* __restrict  */)(buf___1), sizeof(buf___1), (char const   */* __restrict  */)"Padding so that MSIE deigns to show this error instead of its own canned one.\n");
#line 2428
      add_to_response(buf___1, (size_t )buflen);
#line 2425
      n ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 2430
    buflen = snprintf((char */* __restrict  */)(buf___1), sizeof(buf___1), (char const   */* __restrict  */)"-->\n");
#line 2431
    add_to_response(buf___1, (size_t )buflen);
    }
  }
  {
#line 2434
  buflen = snprintf((char */* __restrict  */)(buf___1), sizeof(buf___1), (char const   */* __restrict  */)"<HR>\n<ADDRESS><A HREF=\"%s\">%s</A></ADDRESS>\n</BODY>\n</HTML>\n",
                    "http://www.acme.com/software/mini_httpd/", "mini_httpd/1.19 19dec2003");
#line 2440
  add_to_response(buf___1, (size_t )buflen);
  }
#line 2441
  return;
}
}
#line 2444 "/home/wheatley/newnew/temp/mini-httpd-1.19/mini_httpd.c"
static void add_headers(int s , char *title , char *extra_header , char *me , char *mt ,
                        off_t b , time_t mod ) 
{ 
  time_t now ;
  time_t expires ;
  char timebuf[100] ;
  char buf___1[10000] ;
  int buflen ;
  int s100 ;
  char const   *rfc1123_fmt ;
  struct tm *tmp ;
  struct tm *tmp___0 ;
  struct tm *tmp___1 ;

  {
  {
#line 2452
  rfc1123_fmt = "%a, %d %b %Y %H:%M:%S GMT";
#line 2454
  status = s;
#line 2455
  bytes = b;
#line 2456
  make_log_entry();
#line 2457
  start_response();
#line 2458
  buflen = snprintf((char */* __restrict  */)(buf___1), sizeof(buf___1), (char const   */* __restrict  */)"%s %d %s\r\n",
                    protocol, status, title);
#line 2459
  add_to_response(buf___1, (size_t )buflen);
#line 2460
  buflen = snprintf((char */* __restrict  */)(buf___1), sizeof(buf___1), (char const   */* __restrict  */)"Server: %s\r\n",
                    "mini_httpd/1.19 19dec2003");
#line 2461
  add_to_response(buf___1, (size_t )buflen);
#line 2462
  now = time((time_t *)0);
#line 2463
  tmp = gmtime((time_t const   *)(& now));
#line 2463
  strftime((char */* __restrict  */)(timebuf), sizeof(timebuf), (char const   */* __restrict  */)rfc1123_fmt,
           (struct tm  const  */* __restrict  */)tmp);
#line 2464
  buflen = snprintf((char */* __restrict  */)(buf___1), sizeof(buf___1), (char const   */* __restrict  */)"Date: %s\r\n",
                    timebuf);
#line 2465
  add_to_response(buf___1, (size_t )buflen);
#line 2466
  s100 = status / 100;
  }
#line 2467
  if (s100 != 2) {
#line 2467
    if (s100 != 3) {
      {
#line 2469
      buflen = snprintf((char */* __restrict  */)(buf___1), sizeof(buf___1), (char const   */* __restrict  */)"Cache-Control: no-cache,no-store\r\n");
#line 2470
      add_to_response(buf___1, (size_t )buflen);
      }
    }
  }
#line 2472
  if ((unsigned long )extra_header != (unsigned long )((char *)0)) {
#line 2472
    if ((int )*(extra_header + 0) != 0) {
      {
#line 2474
      buflen = snprintf((char */* __restrict  */)(buf___1), sizeof(buf___1), (char const   */* __restrict  */)"%s\r\n",
                        extra_header);
#line 2475
      add_to_response(buf___1, (size_t )buflen);
      }
    }
  }
#line 2477
  if ((unsigned long )me != (unsigned long )((char *)0)) {
#line 2477
    if ((int )*(me + 0) != 0) {
      {
#line 2479
      buflen = snprintf((char */* __restrict  */)(buf___1), sizeof(buf___1), (char const   */* __restrict  */)"Content-Encoding: %s\r\n",
                        me);
#line 2480
      add_to_response(buf___1, (size_t )buflen);
      }
    }
  }
#line 2482
  if ((unsigned long )mt != (unsigned long )((char *)0)) {
#line 2482
    if ((int )*(mt + 0) != 0) {
      {
#line 2484
      buflen = snprintf((char */* __restrict  */)(buf___1), sizeof(buf___1), (char const   */* __restrict  */)"Content-Type: %s\r\n",
                        mt);
#line 2485
      add_to_response(buf___1, (size_t )buflen);
      }
    }
  }
#line 2487
  if (bytes >= 0L) {
    {
#line 2489
    buflen = snprintf((char */* __restrict  */)(buf___1), sizeof(buf___1), (char const   */* __restrict  */)"Content-Length: %lld\r\n",
                      bytes);
#line 2491
    add_to_response(buf___1, (size_t )buflen);
    }
  }
#line 2493
  if ((unsigned long )p3p != (unsigned long )((char *)0)) {
#line 2493
    if ((int )*(p3p + 0) != 0) {
      {
#line 2495
      buflen = snprintf((char */* __restrict  */)(buf___1), sizeof(buf___1), (char const   */* __restrict  */)"P3P: %s\r\n",
                        p3p);
#line 2496
      add_to_response(buf___1, (size_t )buflen);
      }
    }
  }
#line 2498
  if (max_age >= 0) {
    {
#line 2500
    expires = now + (time_t )max_age;
#line 2501
    tmp___0 = gmtime((time_t const   *)(& expires));
#line 2501
    strftime((char */* __restrict  */)(timebuf), sizeof(timebuf), (char const   */* __restrict  */)rfc1123_fmt,
             (struct tm  const  */* __restrict  */)tmp___0);
#line 2503
    buflen = snprintf((char */* __restrict  */)(buf___1), sizeof(buf___1), (char const   */* __restrict  */)"Cache-Control: max-age=%d\r\nExpires: %s\r\n",
                      max_age, timebuf);
#line 2505
    add_to_response(buf___1, (size_t )buflen);
    }
  }
#line 2507
  if (mod != -1L) {
    {
#line 2509
    tmp___1 = gmtime((time_t const   *)(& mod));
#line 2509
    strftime((char */* __restrict  */)(timebuf), sizeof(timebuf), (char const   */* __restrict  */)rfc1123_fmt,
             (struct tm  const  */* __restrict  */)tmp___1);
#line 2511
    buflen = snprintf((char */* __restrict  */)(buf___1), sizeof(buf___1), (char const   */* __restrict  */)"Last-Modified: %s\r\n",
                      timebuf);
#line 2512
    add_to_response(buf___1, (size_t )buflen);
    }
  }
  {
#line 2514
  buflen = snprintf((char */* __restrict  */)(buf___1), sizeof(buf___1), (char const   */* __restrict  */)"Connection: close\r\n\r\n");
#line 2515
  add_to_response(buf___1, (size_t )buflen);
  }
#line 2516
  return;
}
}
#line 2519 "/home/wheatley/newnew/temp/mini-httpd-1.19/mini_httpd.c"
static void start_request(void) 
{ 


  {
#line 2522
  request_size = (size_t )0;
#line 2523
  request_idx = (size_t )0;
#line 2524
  return;
}
}
#line 2526 "/home/wheatley/newnew/temp/mini-httpd-1.19/mini_httpd.c"
static void add_to_request(char *str___0 , size_t len ) 
{ 


  {
  {
#line 2529
  add_to_buf(& request, & request_size, & request_len, str___0, len);
  }
#line 2530
  return;
}
}
#line 2532 "/home/wheatley/newnew/temp/mini-httpd-1.19/mini_httpd.c"
static char *get_request_line(void) 
{ 
  int i ;
  char c ;

  {
#line 2538
  i = (int )request_idx;
  {
#line 2538
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2538
    if (! (request_idx < request_len)) {
#line 2538
      goto while_break;
    }
#line 2540
    c = *(request + request_idx);
#line 2541
    if ((int )c == 10) {
#line 2541
      goto _L;
    } else
#line 2541
    if ((int )c == 13) {
      _L: /* CIL Label */ 
#line 2543
      *(request + request_idx) = (char )'\000';
#line 2544
      request_idx ++;
#line 2545
      if ((int )c == 13) {
#line 2545
        if (request_idx < request_len) {
#line 2545
          if ((int )*(request + request_idx) == 10) {
#line 2548
            *(request + request_idx) = (char )'\000';
#line 2549
            request_idx ++;
          }
        }
      }
#line 2551
      return (request + i);
    }
#line 2538
    request_idx ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2554
  return ((char *)0);
}
}
#line 2558 "/home/wheatley/newnew/temp/mini-httpd-1.19/mini_httpd.c"
static char *response  ;
#line 2559 "/home/wheatley/newnew/temp/mini-httpd-1.19/mini_httpd.c"
static size_t response_size  ;
#line 2559 "/home/wheatley/newnew/temp/mini-httpd-1.19/mini_httpd.c"
static size_t response_len  ;
#line 2561 "/home/wheatley/newnew/temp/mini-httpd-1.19/mini_httpd.c"
static void start_response(void) 
{ 


  {
#line 2564
  response_size = (size_t )0;
#line 2565
  return;
}
}
#line 2567 "/home/wheatley/newnew/temp/mini-httpd-1.19/mini_httpd.c"
static void add_to_response(char *str___0 , size_t len ) 
{ 


  {
  {
#line 2570
  add_to_buf(& response, & response_size, & response_len, str___0, len);
  }
#line 2571
  return;
}
}
#line 2573 "/home/wheatley/newnew/temp/mini-httpd-1.19/mini_httpd.c"
static void send_response(void) 
{ 


  {
  {
#line 2576
  my_write(response, response_len);
  }
#line 2577
  return;
}
}
#line 2632 "/home/wheatley/newnew/temp/mini-httpd-1.19/mini_httpd.c"
static ssize_t my_read(char *buf___1 , size_t size ) 
{ 
  ssize_t tmp ;

  {
  {
#line 2641
  tmp = read(conn_fd, (void *)buf___1, size);
  }
#line 2641
  return (tmp);
}
}
#line 2646 "/home/wheatley/newnew/temp/mini-httpd-1.19/mini_httpd.c"
static ssize_t my_write(char *buf___1 , size_t size ) 
{ 
  ssize_t tmp ;

  {
  {
#line 2655
  tmp = write(conn_fd, (void const   *)buf___1, size);
  }
#line 2655
  return (tmp);
}
}
#line 2661 "/home/wheatley/newnew/temp/mini-httpd-1.19/mini_httpd.c"
static int my_sendfile(int fd , int socket___0 , off_t offset , size_t nbytes ) 
{ 
  off_t lo ;
  ssize_t tmp ;

  {
  {
#line 2665
  lo = offset;
#line 2666
  tmp = sendfile(socket___0, fd, & lo, nbytes);
  }
#line 2666
  return ((int )tmp);
}
}
#line 2674 "/home/wheatley/newnew/temp/mini-httpd-1.19/mini_httpd.c"
static void add_to_buf(char **bufP , size_t *bufsizeP , size_t *buflenP , char *str___0 ,
                       size_t len ) 
{ 
  void *tmp ;
  void *tmp___0 ;

  {
#line 2677
  if (*bufsizeP == 0UL) {
    {
#line 2679
    *bufsizeP = len + 500UL;
#line 2680
    *buflenP = (size_t )0;
#line 2681
    tmp = e_malloc(*bufsizeP);
#line 2681
    *bufP = (char *)tmp;
    }
  } else
#line 2683
  if (*buflenP + len >= *bufsizeP) {
    {
#line 2685
    *bufsizeP = (*buflenP + len) + 500UL;
#line 2686
    tmp___0 = e_realloc((void *)*bufP, *bufsizeP);
#line 2686
    *bufP = (char *)tmp___0;
    }
  }
  {
#line 2688
  memmove((void *)(*bufP + *buflenP), (void const   *)str___0, len);
#line 2689
  *buflenP += len;
#line 2690
  *(*bufP + *buflenP) = (char )'\000';
  }
#line 2691
  return;
}
}
#line 2694 "/home/wheatley/newnew/temp/mini-httpd-1.19/mini_httpd.c"
static void make_log_entry(void) 
{ 
  char *ru ;
  char url[500] ;
  char bytes_str[40] ;
  time_t now ;
  struct tm *t ;
  char const   *cernfmt_nozone ;
  char date_nozone[100] ;
  int zone ;
  char sign ;
  char date[100] ;
  char *tmp ;
  char *tmp___0 ;

  {
#line 2702
  cernfmt_nozone = "%d/%b/%Y:%H:%M:%S";
#line 2708
  if ((unsigned long )logfp == (unsigned long )((FILE *)0)) {
#line 2709
    return;
  }
#line 2712
  if ((unsigned long )protocol == (unsigned long )((char *)0)) {
#line 2713
    protocol = (char *)"UNKNOWN";
  }
#line 2714
  if ((unsigned long )path == (unsigned long )((char *)0)) {
#line 2715
    path = (char *)"";
  }
#line 2716
  if ((unsigned long )req_hostname == (unsigned long )((char *)0)) {
#line 2717
    req_hostname = hostname;
  }
#line 2720
  if ((unsigned long )remoteuser != (unsigned long )((char *)0)) {
#line 2721
    ru = remoteuser;
  } else {
#line 2723
    ru = (char *)"-";
  }
  {
#line 2724
  now = time((time_t *)0);
  }
#line 2729
  if (vhost) {
    {
#line 2730
    snprintf((char */* __restrict  */)(url), sizeof(url), (char const   */* __restrict  */)"/%s%s",
             req_hostname, path);
    }
  } else {
    {
#line 2732
    snprintf((char */* __restrict  */)(url), sizeof(url), (char const   */* __restrict  */)"%s",
             path);
    }
  }
#line 2734
  if (bytes >= 0L) {
    {
#line 2735
    snprintf((char */* __restrict  */)(bytes_str), sizeof(bytes_str), (char const   */* __restrict  */)"%lld",
             bytes);
    }
  } else {
    {
#line 2738
    strcpy((char */* __restrict  */)(bytes_str), (char const   */* __restrict  */)"-");
    }
  }
  {
#line 2742
  t = localtime((time_t const   *)(& now));
#line 2743
  strftime((char */* __restrict  */)(date_nozone), sizeof(date_nozone), (char const   */* __restrict  */)cernfmt_nozone,
           (struct tm  const  */* __restrict  */)t);
#line 2745
  zone = (int )(t->tm_gmtoff / 60L);
  }
#line 2750
  if (zone >= 0) {
#line 2751
    sign = (char )'+';
  } else {
#line 2754
    sign = (char )'-';
#line 2755
    zone = - zone;
  }
  {
#line 2757
  zone = (zone / 60) * 100 + zone % 60;
#line 2758
  snprintf((char */* __restrict  */)(date), sizeof(date), (char const   */* __restrict  */)"%s %c%04d",
           date_nozone, (int )sign, zone);
#line 2760
  tmp = get_method_str(method);
#line 2760
  tmp___0 = ntoa(& client_addr);
#line 2760
  fprintf((FILE */* __restrict  */)logfp, (char const   */* __restrict  */)"%.80s - %.80s [%s] \"%.80s %.200s %.80s\" %d %s \"%.200s\" \"%.200s\"\n",
          tmp___0, ru, date, tmp, url, protocol, status, bytes_str, referer, useragent);
#line 2764
  fflush(logfp);
  }
#line 2765
  return;
}
}
#line 2771 "/home/wheatley/newnew/temp/mini-httpd-1.19/mini_httpd.c"
static void check_referer(void) 
{ 
  char *cp ;
  int tmp ;
  char *tmp___0 ;

  {
#line 2777
  if ((unsigned long )url_pattern == (unsigned long )((char *)0)) {
#line 2778
    return;
  }
  {
#line 2781
  tmp = really_check_referer();
  }
#line 2781
  if (tmp) {
#line 2782
    return;
  }
#line 2785
  if (vhost) {
#line 2785
    if ((unsigned long )req_hostname != (unsigned long )((char *)0)) {
#line 2786
      cp = req_hostname;
    } else {
#line 2788
      cp = hostname;
    }
  } else {
#line 2788
    cp = hostname;
  }
#line 2789
  if ((unsigned long )cp == (unsigned long )((char *)0)) {
#line 2790
    cp = (char *)"";
  }
  {
#line 2791
  tmp___0 = ntoa(& client_addr);
#line 2791
  syslog(6, "%.80s non-local referer \"%.80s%.80s\" \"%.80s\"", tmp___0, cp, path,
         referer);
#line 2794
  send_error(403, (char *)"Forbidden", (char *)"", (char *)"You must supply a local referer.");
  }
#line 2795
  return;
}
}
#line 2799 "/home/wheatley/newnew/temp/mini-httpd-1.19/mini_httpd.c"
static int really_check_referer(void) 
{ 
  char *cp1 ;
  char *cp2 ;
  char *cp3 ;
  char *refhost ;
  char *lp ;
  int tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  unsigned short const   **tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 2809
  if ((unsigned long )referer == (unsigned long )((char *)0)) {
#line 2809
    goto _L;
  } else
#line 2809
  if ((int )*(referer + 0) == 0) {
#line 2809
    goto _L;
  } else {
    {
#line 2809
    cp1 = strstr((char const   *)referer, "//");
    }
#line 2809
    if ((unsigned long )cp1 == (unsigned long )((char *)0)) {
      _L: /* CIL Label */ 
#line 2813
      if (no_empty_referers) {
        {
#line 2813
        tmp = match((char const   *)url_pattern, (char const   *)path);
        }
#line 2813
        if (tmp) {
#line 2814
          return (0);
        }
      }
#line 2816
      return (1);
    }
  }
#line 2820
  cp1 += 2;
#line 2821
  cp2 = cp1;
  {
#line 2821
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2821
    if ((int )*cp2 != 47) {
#line 2821
      if ((int )*cp2 != 58) {
#line 2821
        if (! ((int )*cp2 != 0)) {
#line 2821
          goto while_break;
        }
      } else {
#line 2821
        goto while_break;
      }
    } else {
#line 2821
      goto while_break;
    }
#line 2822
    goto __Cont;
    __Cont: /* CIL Label */ 
#line 2821
    cp2 ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2823
  tmp___0 = e_malloc((size_t )((cp2 - cp1) + 1L));
#line 2823
  refhost = (char *)tmp___0;
#line 2824
  cp3 = refhost;
  }
  {
#line 2824
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 2824
    if (! ((unsigned long )cp1 < (unsigned long )cp2)) {
#line 2824
      goto while_break___0;
    }
    {
#line 2825
    tmp___2 = __ctype_b_loc();
    }
#line 2825
    if ((int const   )*(*tmp___2 + (int )*cp1) & 256) {
      {
#line 2826
      tmp___1 = tolower((int )*cp1);
#line 2826
      *cp3 = (char )tmp___1;
      }
    } else {
#line 2828
      *cp3 = *cp1;
    }
#line 2824
    cp1 ++;
#line 2824
    cp3 ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 2829
  *cp3 = (char )'\000';
#line 2832
  if ((unsigned long )local_pattern != (unsigned long )((char *)0)) {
#line 2833
    lp = local_pattern;
  } else
#line 2837
  if (! vhost) {
#line 2840
    lp = hostname;
#line 2841
    if ((unsigned long )lp == (unsigned long )((char *)0)) {
#line 2843
      return (1);
    }
  } else {
#line 2848
    lp = req_hostname;
#line 2849
    if ((unsigned long )lp == (unsigned long )((char *)0)) {
#line 2855
      return (1);
    }
  }
  {
#line 2862
  tmp___3 = match((char const   *)lp, (char const   *)refhost);
  }
#line 2862
  if (! tmp___3) {
    {
#line 2862
    tmp___4 = match((char const   *)url_pattern, (char const   *)path);
    }
#line 2862
    if (tmp___4) {
#line 2863
      return (0);
    }
  }
#line 2865
  return (1);
}
}
#line 2869 "/home/wheatley/newnew/temp/mini-httpd-1.19/mini_httpd.c"
static char *get_method_str(int m ) 
{ 


  {
  {
#line 2874
  if (m == 1) {
#line 2874
    goto case_1;
  }
#line 2875
  if (m == 2) {
#line 2875
    goto case_2;
  }
#line 2876
  if (m == 3) {
#line 2876
    goto case_3;
  }
#line 2877
  goto switch_default;
  case_1: /* CIL Label */ 
#line 2874
  return ((char *)"GET");
  case_2: /* CIL Label */ 
#line 2875
  return ((char *)"HEAD");
  case_3: /* CIL Label */ 
#line 2876
  return ((char *)"POST");
  switch_default: /* CIL Label */ 
#line 2877
  return ((char *)"UNKNOWN");
  switch_break: /* CIL Label */ ;
  }
}
}
#line 2888 "/home/wheatley/newnew/temp/mini-httpd-1.19/mini_httpd.c"
static struct mime_entry enc_tab[3]  = {      {(char *)"Z", (size_t )0, (char *)"compress", (size_t )0}, 
        {(char *)"gz", (size_t )0, (char *)"gzip", (size_t )0}, 
        {(char *)"uu", (size_t )0, (char *)"x-uuencode", (size_t )0}};
#line 2891 "/home/wheatley/newnew/temp/mini-httpd-1.19/mini_httpd.c"
static int const   n_enc_tab  =    (int const   )(sizeof(enc_tab) / sizeof(enc_tab[0]));
#line 2892 "/home/wheatley/newnew/temp/mini-httpd-1.19/mini_httpd.c"
static struct mime_entry typ_tab[190]  = 
#line 2892
  {      {(char *)"a", (size_t )0, (char *)"application/octet-stream", (size_t )0}, 
        {(char *)"aab", (size_t )0, (char *)"application/x-authorware-bin", (size_t )0}, 
        {(char *)"aam",
      (size_t )0, (char *)"application/x-authorware-map", (size_t )0}, 
        {(char *)"aas", (size_t )0, (char *)"application/x-authorware-seg", (size_t )0}, 
        {(char *)"ai",
      (size_t )0, (char *)"application/postscript", (size_t )0}, 
        {(char *)"aif", (size_t )0, (char *)"audio/x-aiff", (size_t )0}, 
        {(char *)"aifc", (size_t )0, (char *)"audio/x-aiff", (size_t )0}, 
        {(char *)"aiff", (size_t )0, (char *)"audio/x-aiff", (size_t )0}, 
        {(char *)"asc", (size_t )0, (char *)"text/plain", (size_t )0}, 
        {(char *)"asf", (size_t )0, (char *)"video/x-ms-asf", (size_t )0}, 
        {(char *)"asx", (size_t )0, (char *)"video/x-ms-asf", (size_t )0}, 
        {(char *)"au", (size_t )0, (char *)"audio/basic", (size_t )0}, 
        {(char *)"avi", (size_t )0, (char *)"video/x-msvideo", (size_t )0}, 
        {(char *)"bcpio", (size_t )0, (char *)"application/x-bcpio", (size_t )0}, 
        {(char *)"bin", (size_t )0, (char *)"application/octet-stream", (size_t )0}, 
        {(char *)"bmp", (size_t )0, (char *)"image/bmp", (size_t )0}, 
        {(char *)"cdf", (size_t )0, (char *)"application/x-netcdf", (size_t )0}, 
        {(char *)"class", (size_t )0, (char *)"application/x-java-vm", (size_t )0}, 
        {(char *)"cpio", (size_t )0, (char *)"application/x-cpio", (size_t )0}, 
        {(char *)"cpt", (size_t )0, (char *)"application/mac-compactpro", (size_t )0}, 
        {(char *)"crl",
      (size_t )0, (char *)"application/x-pkcs7-crl", (size_t )0}, 
        {(char *)"crt", (size_t )0, (char *)"application/x-x509-ca-cert", (size_t )0}, 
        {(char *)"csh",
      (size_t )0, (char *)"application/x-csh", (size_t )0}, 
        {(char *)"css", (size_t )0, (char *)"text/css", (size_t )0}, 
        {(char *)"dcr", (size_t )0, (char *)"application/x-director", (size_t )0}, 
        {(char *)"dir", (size_t )0, (char *)"application/x-director", (size_t )0}, 
        {(char *)"djv", (size_t )0, (char *)"image/vnd.djvu", (size_t )0}, 
        {(char *)"djvu", (size_t )0, (char *)"image/vnd.djvu", (size_t )0}, 
        {(char *)"dll", (size_t )0, (char *)"application/octet-stream", (size_t )0}, 
        {(char *)"dms", (size_t )0, (char *)"application/octet-stream", (size_t )0}, 
        {(char *)"doc", (size_t )0, (char *)"application/msword", (size_t )0}, 
        {(char *)"dtd", (size_t )0, (char *)"text/xml", (size_t )0}, 
        {(char *)"dump", (size_t )0, (char *)"application/octet-stream", (size_t )0}, 
        {(char *)"dvi",
      (size_t )0, (char *)"application/x-dvi", (size_t )0}, 
        {(char *)"dxr", (size_t )0, (char *)"application/x-director", (size_t )0}, 
        {(char *)"eps", (size_t )0, (char *)"application/postscript", (size_t )0}, 
        {(char *)"etx", (size_t )0, (char *)"text/x-setext", (size_t )0}, 
        {(char *)"exe", (size_t )0, (char *)"application/octet-stream", (size_t )0}, 
        {(char *)"ez", (size_t )0, (char *)"application/andrew-inset", (size_t )0}, 
        {(char *)"fgd", (size_t )0, (char *)"application/x-director", (size_t )0}, 
        {(char *)"fh", (size_t )0, (char *)"image/x-freehand", (size_t )0}, 
        {(char *)"fh4", (size_t )0, (char *)"image/x-freehand", (size_t )0}, 
        {(char *)"fh5", (size_t )0, (char *)"image/x-freehand", (size_t )0}, 
        {(char *)"fh7", (size_t )0, (char *)"image/x-freehand", (size_t )0}, 
        {(char *)"fhc", (size_t )0, (char *)"image/x-freehand", (size_t )0}, 
        {(char *)"gif", (size_t )0, (char *)"image/gif", (size_t )0}, 
        {(char *)"gtar", (size_t )0, (char *)"application/x-gtar", (size_t )0}, 
        {(char *)"hdf", (size_t )0, (char *)"application/x-hdf", (size_t )0}, 
        {(char *)"hqx", (size_t )0, (char *)"application/mac-binhex40", (size_t )0}, 
        {(char *)"htm", (size_t )0, (char *)"text/html; charset=%s", (size_t )0}, 
        {(char *)"html", (size_t )0, (char *)"text/html; charset=%s", (size_t )0}, 
        {(char *)"ice", (size_t )0, (char *)"x-conference/x-cooltalk", (size_t )0}, 
        {(char *)"ief", (size_t )0, (char *)"image/ief", (size_t )0}, 
        {(char *)"iges", (size_t )0, (char *)"model/iges", (size_t )0}, 
        {(char *)"igs", (size_t )0, (char *)"model/iges", (size_t )0}, 
        {(char *)"iv", (size_t )0, (char *)"application/x-inventor", (size_t )0}, 
        {(char *)"jar", (size_t )0, (char *)"application/x-java-archive", (size_t )0}, 
        {(char *)"jfif",
      (size_t )0, (char *)"image/jpeg", (size_t )0}, 
        {(char *)"jpe", (size_t )0, (char *)"image/jpeg", (size_t )0}, 
        {(char *)"jpeg", (size_t )0, (char *)"image/jpeg", (size_t )0}, 
        {(char *)"jpg", (size_t )0, (char *)"image/jpeg", (size_t )0}, 
        {(char *)"js", (size_t )0, (char *)"application/x-javascript", (size_t )0}, 
        {(char *)"kar", (size_t )0, (char *)"audio/midi", (size_t )0}, 
        {(char *)"latex", (size_t )0, (char *)"application/x-latex", (size_t )0}, 
        {(char *)"lha", (size_t )0, (char *)"application/octet-stream", (size_t )0}, 
        {(char *)"lzh", (size_t )0, (char *)"application/octet-stream", (size_t )0}, 
        {(char *)"m3u", (size_t )0, (char *)"audio/x-mpegurl", (size_t )0}, 
        {(char *)"man", (size_t )0, (char *)"application/x-troff-man", (size_t )0}, 
        {(char *)"mathml", (size_t )0, (char *)"application/mathml+xml", (size_t )0}, 
        {(char *)"me",
      (size_t )0, (char *)"application/x-troff-me", (size_t )0}, 
        {(char *)"mesh", (size_t )0, (char *)"model/mesh", (size_t )0}, 
        {(char *)"mid", (size_t )0, (char *)"audio/midi", (size_t )0}, 
        {(char *)"midi", (size_t )0, (char *)"audio/midi", (size_t )0}, 
        {(char *)"mif", (size_t )0, (char *)"application/vnd.mif", (size_t )0}, 
        {(char *)"mime", (size_t )0, (char *)"message/rfc822", (size_t )0}, 
        {(char *)"mml", (size_t )0, (char *)"application/mathml+xml", (size_t )0}, 
        {(char *)"mov", (size_t )0, (char *)"video/quicktime", (size_t )0}, 
        {(char *)"movie", (size_t )0, (char *)"video/x-sgi-movie", (size_t )0}, 
        {(char *)"mp2", (size_t )0, (char *)"audio/mpeg", (size_t )0}, 
        {(char *)"mp3", (size_t )0, (char *)"audio/mpeg", (size_t )0}, 
        {(char *)"mp4", (size_t )0, (char *)"video/mp4", (size_t )0}, 
        {(char *)"mpe", (size_t )0, (char *)"video/mpeg", (size_t )0}, 
        {(char *)"mpeg", (size_t )0, (char *)"video/mpeg", (size_t )0}, 
        {(char *)"mpg", (size_t )0, (char *)"video/mpeg", (size_t )0}, 
        {(char *)"mpga", (size_t )0, (char *)"audio/mpeg", (size_t )0}, 
        {(char *)"ms", (size_t )0, (char *)"application/x-troff-ms", (size_t )0}, 
        {(char *)"msh", (size_t )0, (char *)"model/mesh", (size_t )0}, 
        {(char *)"mv", (size_t )0, (char *)"video/x-sgi-movie", (size_t )0}, 
        {(char *)"mxu", (size_t )0, (char *)"video/vnd.mpegurl", (size_t )0}, 
        {(char *)"nc", (size_t )0, (char *)"application/x-netcdf", (size_t )0}, 
        {(char *)"o", (size_t )0, (char *)"application/octet-stream", (size_t )0}, 
        {(char *)"oda", (size_t )0, (char *)"application/oda", (size_t )0}, 
        {(char *)"ogg", (size_t )0, (char *)"application/x-ogg", (size_t )0}, 
        {(char *)"pac", (size_t )0, (char *)"application/x-ns-proxy-autoconfig", (size_t )0}, 
        {(char *)"pbm",
      (size_t )0, (char *)"image/x-portable-bitmap", (size_t )0}, 
        {(char *)"pdb", (size_t )0, (char *)"chemical/x-pdb", (size_t )0}, 
        {(char *)"pdf", (size_t )0, (char *)"application/pdf", (size_t )0}, 
        {(char *)"pgm", (size_t )0, (char *)"image/x-portable-graymap", (size_t )0}, 
        {(char *)"pgn", (size_t )0, (char *)"application/x-chess-pgn", (size_t )0}, 
        {(char *)"png", (size_t )0, (char *)"image/png", (size_t )0}, 
        {(char *)"pnm", (size_t )0, (char *)"image/x-portable-anymap", (size_t )0}, 
        {(char *)"ppm", (size_t )0, (char *)"image/x-portable-pixmap", (size_t )0}, 
        {(char *)"ppt", (size_t )0, (char *)"application/vnd.ms-powerpoint", (size_t )0}, 
        {(char *)"ps",
      (size_t )0, (char *)"application/postscript", (size_t )0}, 
        {(char *)"qt", (size_t )0, (char *)"video/quicktime", (size_t )0}, 
        {(char *)"ra", (size_t )0, (char *)"audio/x-realaudio", (size_t )0}, 
        {(char *)"ram", (size_t )0, (char *)"audio/x-pn-realaudio", (size_t )0}, 
        {(char *)"ras", (size_t )0, (char *)"image/x-cmu-raster", (size_t )0}, 
        {(char *)"rdf", (size_t )0, (char *)"application/rdf+xml", (size_t )0}, 
        {(char *)"rgb", (size_t )0, (char *)"image/x-rgb", (size_t )0}, 
        {(char *)"rm", (size_t )0, (char *)"audio/x-pn-realaudio", (size_t )0}, 
        {(char *)"roff", (size_t )0, (char *)"application/x-troff", (size_t )0}, 
        {(char *)"rpm", (size_t )0, (char *)"audio/x-pn-realaudio-plugin", (size_t )0}, 
        {(char *)"rss",
      (size_t )0, (char *)"application/rss+xml", (size_t )0}, 
        {(char *)"rtf", (size_t )0, (char *)"text/rtf", (size_t )0}, 
        {(char *)"rtx", (size_t )0, (char *)"text/richtext", (size_t )0}, 
        {(char *)"sgm", (size_t )0, (char *)"text/sgml", (size_t )0}, 
        {(char *)"sgml", (size_t )0, (char *)"text/sgml", (size_t )0}, 
        {(char *)"sh", (size_t )0, (char *)"application/x-sh", (size_t )0}, 
        {(char *)"shar", (size_t )0, (char *)"application/x-shar", (size_t )0}, 
        {(char *)"silo", (size_t )0, (char *)"model/mesh", (size_t )0}, 
        {(char *)"sit", (size_t )0, (char *)"application/x-stuffit", (size_t )0}, 
        {(char *)"skd", (size_t )0, (char *)"application/x-koan", (size_t )0}, 
        {(char *)"skm", (size_t )0, (char *)"application/x-koan", (size_t )0}, 
        {(char *)"skp", (size_t )0, (char *)"application/x-koan", (size_t )0}, 
        {(char *)"skt", (size_t )0, (char *)"application/x-koan", (size_t )0}, 
        {(char *)"smi", (size_t )0, (char *)"application/smil", (size_t )0}, 
        {(char *)"smil", (size_t )0, (char *)"application/smil", (size_t )0}, 
        {(char *)"snd", (size_t )0, (char *)"audio/basic", (size_t )0}, 
        {(char *)"so", (size_t )0, (char *)"application/octet-stream", (size_t )0}, 
        {(char *)"spl", (size_t )0, (char *)"application/x-futuresplash", (size_t )0}, 
        {(char *)"src",
      (size_t )0, (char *)"application/x-wais-source", (size_t )0}, 
        {(char *)"stc", (size_t )0, (char *)"application/vnd.sun.xml.calc.template",
      (size_t )0}, 
        {(char *)"std", (size_t )0, (char *)"application/vnd.sun.xml.draw.template",
      (size_t )0}, 
        {(char *)"sti", (size_t )0, (char *)"application/vnd.sun.xml.impress.template",
      (size_t )0}, 
        {(char *)"stw", (size_t )0, (char *)"application/vnd.sun.xml.writer.template",
      (size_t )0}, 
        {(char *)"sv4cpio", (size_t )0, (char *)"application/x-sv4cpio", (size_t )0}, 
        {(char *)"sv4crc",
      (size_t )0, (char *)"application/x-sv4crc", (size_t )0}, 
        {(char *)"svg", (size_t )0, (char *)"image/svg+xml", (size_t )0}, 
        {(char *)"svgz", (size_t )0, (char *)"image/svg+xml", (size_t )0}, 
        {(char *)"swf", (size_t )0, (char *)"application/x-shockwave-flash", (size_t )0}, 
        {(char *)"sxc",
      (size_t )0, (char *)"application/vnd.sun.xml.calc", (size_t )0}, 
        {(char *)"sxd", (size_t )0, (char *)"application/vnd.sun.xml.draw", (size_t )0}, 
        {(char *)"sxg",
      (size_t )0, (char *)"application/vnd.sun.xml.writer.global", (size_t )0}, 
        {(char *)"sxi", (size_t )0, (char *)"application/vnd.sun.xml.impress", (size_t )0}, 
        {(char *)"sxm",
      (size_t )0, (char *)"application/vnd.sun.xml.math", (size_t )0}, 
        {(char *)"sxw", (size_t )0, (char *)"application/vnd.sun.xml.writer", (size_t )0}, 
        {(char *)"t",
      (size_t )0, (char *)"application/x-troff", (size_t )0}, 
        {(char *)"tar", (size_t )0, (char *)"application/x-tar", (size_t )0}, 
        {(char *)"tcl", (size_t )0, (char *)"application/x-tcl", (size_t )0}, 
        {(char *)"tex", (size_t )0, (char *)"application/x-tex", (size_t )0}, 
        {(char *)"texi", (size_t )0, (char *)"application/x-texinfo", (size_t )0}, 
        {(char *)"texinfo", (size_t )0, (char *)"application/x-texinfo", (size_t )0}, 
        {(char *)"tif",
      (size_t )0, (char *)"image/tiff", (size_t )0}, 
        {(char *)"tiff", (size_t )0, (char *)"image/tiff", (size_t )0}, 
        {(char *)"tr", (size_t )0, (char *)"application/x-troff", (size_t )0}, 
        {(char *)"tsp", (size_t )0, (char *)"application/dsptype", (size_t )0}, 
        {(char *)"tsv", (size_t )0, (char *)"text/tab-separated-values", (size_t )0}, 
        {(char *)"txt",
      (size_t )0, (char *)"text/plain; charset=%s", (size_t )0}, 
        {(char *)"ustar", (size_t )0, (char *)"application/x-ustar", (size_t )0}, 
        {(char *)"vcd", (size_t )0, (char *)"application/x-cdlink", (size_t )0}, 
        {(char *)"vrml", (size_t )0, (char *)"model/vrml", (size_t )0}, 
        {(char *)"vx", (size_t )0, (char *)"video/x-rad-screenplay", (size_t )0}, 
        {(char *)"wav", (size_t )0, (char *)"audio/x-wav", (size_t )0}, 
        {(char *)"wax", (size_t )0, (char *)"audio/x-ms-wax", (size_t )0}, 
        {(char *)"wbmp", (size_t )0, (char *)"image/vnd.wap.wbmp", (size_t )0}, 
        {(char *)"wbxml", (size_t )0, (char *)"application/vnd.wap.wbxml", (size_t )0}, 
        {(char *)"wm",
      (size_t )0, (char *)"video/x-ms-wm", (size_t )0}, 
        {(char *)"wma", (size_t )0, (char *)"audio/x-ms-wma", (size_t )0}, 
        {(char *)"wmd", (size_t )0, (char *)"application/x-ms-wmd", (size_t )0}, 
        {(char *)"wml", (size_t )0, (char *)"text/vnd.wap.wml", (size_t )0}, 
        {(char *)"wmlc", (size_t )0, (char *)"application/vnd.wap.wmlc", (size_t )0}, 
        {(char *)"wmls",
      (size_t )0, (char *)"text/vnd.wap.wmlscript", (size_t )0}, 
        {(char *)"wmlsc", (size_t )0, (char *)"application/vnd.wap.wmlscriptc", (size_t )0}, 
        {(char *)"wmv",
      (size_t )0, (char *)"video/x-ms-wmv", (size_t )0}, 
        {(char *)"wmx", (size_t )0, (char *)"video/x-ms-wmx", (size_t )0}, 
        {(char *)"wmz", (size_t )0, (char *)"application/x-ms-wmz", (size_t )0}, 
        {(char *)"wrl", (size_t )0, (char *)"model/vrml", (size_t )0}, 
        {(char *)"wsrc", (size_t )0, (char *)"application/x-wais-source", (size_t )0}, 
        {(char *)"wvx",
      (size_t )0, (char *)"video/x-ms-wvx", (size_t )0}, 
        {(char *)"xbm", (size_t )0, (char *)"image/x-xbitmap", (size_t )0}, 
        {(char *)"xht", (size_t )0, (char *)"application/xhtml+xml", (size_t )0}, 
        {(char *)"xhtml", (size_t )0, (char *)"application/xhtml+xml", (size_t )0}, 
        {(char *)"xls", (size_t )0, (char *)"application/vnd.ms-excel", (size_t )0}, 
        {(char *)"xml", (size_t )0, (char *)"text/xml", (size_t )0}, 
        {(char *)"xpm", (size_t )0, (char *)"image/x-xpixmap", (size_t )0}, 
        {(char *)"xsl", (size_t )0, (char *)"text/xml", (size_t )0}, 
        {(char *)"xwd", (size_t )0, (char *)"image/x-xwindowdump", (size_t )0}, 
        {(char *)"xyz", (size_t )0, (char *)"chemical/x-xyz", (size_t )0}, 
        {(char *)"zip", (size_t )0, (char *)"application/zip", (size_t )0}};
#line 2895 "/home/wheatley/newnew/temp/mini-httpd-1.19/mini_httpd.c"
static int const   n_typ_tab  =    (int const   )(sizeof(typ_tab) / sizeof(typ_tab[0]));
#line 2899 "/home/wheatley/newnew/temp/mini-httpd-1.19/mini_httpd.c"
static int ext_compare(struct mime_entry *a , struct mime_entry *b ) 
{ 
  int tmp ;

  {
  {
#line 2904
  tmp = strcmp((char const   *)a->ext, (char const   *)b->ext);
  }
#line 2904
  return (tmp);
}
}
#line 2908 "/home/wheatley/newnew/temp/mini-httpd-1.19/mini_httpd.c"
static void init_mime(void) 
{ 
  int i ;

  {
  {
#line 2914
  qsort((void *)(enc_tab), (size_t )n_enc_tab, sizeof(enc_tab[0]), (int (*)(void const   * ,
                                                                            void const   * ))(& ext_compare));
#line 2915
  qsort((void *)(typ_tab), (size_t )n_typ_tab, sizeof(typ_tab[0]), (int (*)(void const   * ,
                                                                            void const   * ))(& ext_compare));
#line 2918
  i = 0;
  }
  {
#line 2918
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2918
    if (! (i < (int )n_enc_tab)) {
#line 2918
      goto while_break;
    }
    {
#line 2920
    enc_tab[i].ext_len = strlen((char const   *)enc_tab[i].ext);
#line 2921
    enc_tab[i].val_len = strlen((char const   *)enc_tab[i].val);
#line 2918
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 2923
  i = 0;
  {
#line 2923
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 2923
    if (! (i < (int )n_typ_tab)) {
#line 2923
      goto while_break___0;
    }
    {
#line 2925
    typ_tab[i].ext_len = strlen((char const   *)typ_tab[i].ext);
#line 2926
    typ_tab[i].val_len = strlen((char const   *)typ_tab[i].val);
#line 2923
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 2928
  return;
}
}
#line 2935 "/home/wheatley/newnew/temp/mini-httpd-1.19/mini_httpd.c"
static char const   *figure_mime(char *name , char *me , size_t me_size ) 
{ 
  char *prev_dot ;
  char *dot ;
  char *ext ;
  int me_indexes[100] ;
  int n_me_indexes ;
  size_t ext_len ;
  size_t me_len ;
  int i ;
  int top ;
  int bot ;
  int mid ;
  int r ;
  char const   *default_type ;
  char const   *type ;
  size_t tmp ;
  int tmp___0 ;

  {
  {
#line 2945
  default_type = "text/plain; charset=%s";
#line 2949
  n_me_indexes = 0;
#line 2950
  tmp = strlen((char const   *)name);
#line 2950
  prev_dot = name + tmp;
  }
  {
#line 2950
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2952
    dot = prev_dot - 1;
    {
#line 2952
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 2952
      if ((unsigned long )dot >= (unsigned long )name) {
#line 2952
        if (! ((int )*dot != 46)) {
#line 2952
          goto while_break___0;
        }
      } else {
#line 2952
        goto while_break___0;
      }
#line 2952
      dot --;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 2954
    if ((unsigned long )dot < (unsigned long )name) {
#line 2959
      type = default_type;
#line 2960
      goto done;
    }
#line 2962
    ext = dot + 1;
#line 2963
    ext_len = (size_t )(prev_dot - ext);
#line 2967
    i = 0;
    {
#line 2967
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 2967
      if (! (i < (int )n_enc_tab)) {
#line 2967
        goto while_break___1;
      }
#line 2969
      if (ext_len == enc_tab[i].ext_len) {
        {
#line 2969
        tmp___0 = strncasecmp((char const   *)ext, (char const   *)enc_tab[i].ext,
                              ext_len);
        }
#line 2969
        if (tmp___0 == 0) {
#line 2971
          if ((unsigned long )n_me_indexes < sizeof(me_indexes) / sizeof(me_indexes[0])) {
#line 2973
            me_indexes[n_me_indexes] = i;
#line 2974
            n_me_indexes ++;
          }
#line 2976
          goto next;
        }
      }
#line 2967
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 2980
    goto while_break;
    next: 
#line 2950
    prev_dot = dot;
  }
  while_break: /* CIL Label */ ;
  }
#line 2986
  top = (int )(n_typ_tab - 1);
#line 2987
  bot = 0;
  {
#line 2988
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 2988
    if (! (top >= bot)) {
#line 2988
      goto while_break___2;
    }
    {
#line 2990
    mid = (top + bot) / 2;
#line 2991
    r = strncasecmp((char const   *)ext, (char const   *)typ_tab[mid].ext, ext_len);
    }
#line 2992
    if (r < 0) {
#line 2993
      top = mid - 1;
    } else
#line 2994
    if (r > 0) {
#line 2995
      bot = mid + 1;
    } else
#line 2997
    if (ext_len < typ_tab[mid].ext_len) {
#line 2998
      top = mid - 1;
    } else
#line 2999
    if (ext_len > typ_tab[mid].ext_len) {
#line 3000
      bot = mid + 1;
    } else {
#line 3003
      type = (char const   *)typ_tab[mid].val;
#line 3004
      goto done;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
#line 3007
  type = default_type;
  done: 
#line 3012
  *(me + 0) = (char )'\000';
#line 3013
  me_len = (size_t )0;
#line 3014
  i = n_me_indexes - 1;
  {
#line 3014
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 3014
    if (! (i >= 0)) {
#line 3014
      goto while_break___3;
    }
#line 3016
    if ((me_len + enc_tab[me_indexes[i]].val_len) + 1UL < me_size) {
#line 3018
      if ((int )*(me + 0) != 0) {
        {
#line 3020
        strcpy((char */* __restrict  */)(me + me_len), (char const   */* __restrict  */)",");
#line 3021
        me_len ++;
        }
      }
      {
#line 3023
      strcpy((char */* __restrict  */)(me + me_len), (char const   */* __restrict  */)enc_tab[me_indexes[i]].val);
#line 3024
      me_len += enc_tab[me_indexes[i]].val_len;
      }
    }
#line 3014
    i --;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 3028
  return (type);
}
}
#line 3032 "/home/wheatley/newnew/temp/mini-httpd-1.19/mini_httpd.c"
static void handle_sigterm(int sig ) 
{ 


  {
  {
#line 3037
  syslog(5, "exiting due to signal %d", sig);
#line 3038
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: exiting due to signal %d\n",
          argv0, sig);
#line 3039
  closelog();
#line 3040
  exit(1);
  }
}
}
#line 3045 "/home/wheatley/newnew/temp/mini-httpd-1.19/mini_httpd.c"
static void handle_sighup(int sig ) 
{ 
  int oerrno ;
  int *tmp ;
  int *tmp___0 ;

  {
  {
#line 3048
  tmp = __errno_location();
#line 3048
  oerrno = *tmp;
#line 3052
  signal(1, & handle_sighup);
#line 3056
  got_hup = 1;
#line 3059
  tmp___0 = __errno_location();
#line 3059
  *tmp___0 = oerrno;
  }
#line 3060
  return;
}
}
#line 3063 "/home/wheatley/newnew/temp/mini-httpd-1.19/mini_httpd.c"
static void handle_sigchld(int sig ) 
{ 
  int oerrno ;
  int *tmp ;
  pid_t pid ;
  int status___0 ;
  int *tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;

  {
  {
#line 3066
  tmp = __errno_location();
#line 3066
  oerrno = *tmp;
#line 3072
  signal(17, & handle_sigchld);
  }
  {
#line 3076
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 3079
    pid = waitpid(-1, & status___0, 1);
    }
#line 3083
    if (pid == 0) {
#line 3084
      goto while_break;
    }
#line 3085
    if (pid < 0) {
      {
#line 3087
      tmp___0 = __errno_location();
      }
#line 3087
      if (*tmp___0 == 4) {
#line 3088
        goto __Cont;
      } else {
        {
#line 3087
        tmp___1 = __errno_location();
        }
#line 3087
        if (*tmp___1 == 11) {
#line 3088
          goto __Cont;
        }
      }
      {
#line 3092
      tmp___2 = __errno_location();
      }
#line 3092
      if (*tmp___2 != 10) {
        {
#line 3094
        syslog(3, "child wait - %m");
#line 3095
        perror("child wait");
        }
      }
#line 3097
      goto while_break;
    }
    __Cont: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 3102
  tmp___3 = __errno_location();
#line 3102
  *tmp___3 = oerrno;
  }
#line 3103
  return;
}
}
#line 3106 "/home/wheatley/newnew/temp/mini-httpd-1.19/mini_httpd.c"
static void re_open_logfile(void) 
{ 


  {
#line 3109
  if ((unsigned long )logfp != (unsigned long )((FILE *)0)) {
    {
#line 3111
    fclose(logfp);
#line 3112
    logfp = (FILE *)0;
    }
  }
#line 3114
  if ((unsigned long )logfile != (unsigned long )((char *)0)) {
    {
#line 3116
    syslog(5, "re-opening logfile");
#line 3117
    logfp = fopen((char const   */* __restrict  */)logfile, (char const   */* __restrict  */)"a");
    }
#line 3118
    if ((unsigned long )logfp == (unsigned long )((FILE *)0)) {
      {
#line 3120
      syslog(2, "%s - %m", logfile);
#line 3121
      perror((char const   *)logfile);
#line 3122
      exit(1);
      }
    }
  }
#line 3125
  return;
}
}
#line 3128 "/home/wheatley/newnew/temp/mini-httpd-1.19/mini_httpd.c"
static void handle_read_timeout(int sig ) 
{ 
  char *tmp ;

  {
  {
#line 3131
  tmp = ntoa(& client_addr);
#line 3131
  syslog(6, "%.80s connection timed out reading", tmp);
#line 3132
  send_error(408, (char *)"Request Timeout", (char *)"", (char *)"No request appeared within a reasonable time period.");
  }
#line 3135
  return;
}
}
#line 3138 "/home/wheatley/newnew/temp/mini-httpd-1.19/mini_httpd.c"
static void handle_write_timeout(int sig ) 
{ 
  char *tmp ;

  {
  {
#line 3141
  tmp = ntoa(& client_addr);
#line 3141
  syslog(6, "%.80s connection timed out writing", tmp);
#line 3142
  exit(1);
  }
}
}
#line 3147 "/home/wheatley/newnew/temp/mini-httpd-1.19/mini_httpd.c"
static void lookup_hostname(usockaddr *usa4P , size_t sa4_len , int *gotv4P , usockaddr *usa6P ,
                            size_t sa6_len , int *gotv6P ) 
{ 
  struct addrinfo hints ;
  char portstr[10] ;
  int gaierr ;
  struct addrinfo *ai ;
  struct addrinfo *ai2 ;
  struct addrinfo *aiv6 ;
  struct addrinfo *aiv4 ;
  char const   *tmp ;
  char const   *tmp___0 ;

  {
  {
#line 3160
  memset((void *)(& hints), 0, sizeof(hints));
#line 3161
  hints.ai_family = 0;
#line 3162
  hints.ai_flags = 1;
#line 3163
  hints.ai_socktype = 1;
#line 3164
  snprintf((char */* __restrict  */)(portstr), sizeof(portstr), (char const   */* __restrict  */)"%d",
           (int )port);
#line 3165
  gaierr = getaddrinfo((char const   */* __restrict  */)hostname, (char const   */* __restrict  */)(portstr),
                       (struct addrinfo  const  */* __restrict  */)(& hints), (struct addrinfo **/* __restrict  */)(& ai));
  }
#line 3165
  if (gaierr != 0) {
    {
#line 3167
    tmp = gai_strerror(gaierr);
#line 3167
    syslog(2, "getaddrinfo %.80s - %s", hostname, tmp);
#line 3170
    tmp___0 = gai_strerror(gaierr);
#line 3170
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: getaddrinfo %.80s - %s\n",
            argv0, hostname, tmp___0);
#line 3173
    exit(1);
    }
  }
#line 3177
  aiv6 = (struct addrinfo *)0;
#line 3178
  aiv4 = (struct addrinfo *)0;
#line 3179
  ai2 = ai;
  {
#line 3179
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3179
    if (! ((unsigned long )ai2 != (unsigned long )((struct addrinfo *)0))) {
#line 3179
      goto while_break;
    }
    {
#line 3183
    if (ai2->ai_family == 10) {
#line 3183
      goto case_10;
    }
#line 3187
    if (ai2->ai_family == 2) {
#line 3187
      goto case_2;
    }
#line 3181
    goto switch_break;
    case_10: /* CIL Label */ 
#line 3184
    if ((unsigned long )aiv6 == (unsigned long )((struct addrinfo *)0)) {
#line 3185
      aiv6 = ai2;
    }
#line 3186
    goto switch_break;
    case_2: /* CIL Label */ 
#line 3188
    if ((unsigned long )aiv4 == (unsigned long )((struct addrinfo *)0)) {
#line 3189
      aiv4 = ai2;
    }
#line 3190
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 3179
    ai2 = ai2->ai_next;
  }
  while_break: /* CIL Label */ ;
  }
#line 3194
  if ((unsigned long )aiv6 == (unsigned long )((struct addrinfo *)0)) {
#line 3195
    *gotv6P = 0;
  } else {
#line 3198
    if (sa6_len < (size_t )aiv6->ai_addrlen) {
      {
#line 3200
      syslog(2, "%.80s - sockaddr too small (%lu < %lu)", hostname, sa6_len, (unsigned long )aiv6->ai_addrlen);
#line 3204
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: %.80s - sockaddr too small (%lu < %lu)\n",
              argv0, hostname, sa6_len, (unsigned long )aiv6->ai_addrlen);
#line 3208
      exit(1);
      }
    }
    {
#line 3210
    memset((void *)usa6P, 0, sa6_len);
#line 3211
    memmove((void *)usa6P, (void const   *)aiv6->ai_addr, (size_t )aiv6->ai_addrlen);
#line 3212
    *gotv6P = 1;
    }
  }
#line 3215
  if ((unsigned long )aiv4 == (unsigned long )((struct addrinfo *)0)) {
#line 3216
    *gotv4P = 0;
  } else {
#line 3219
    if (sa4_len < (size_t )aiv4->ai_addrlen) {
      {
#line 3221
      syslog(2, "%.80s - sockaddr too small (%lu < %lu)", hostname, sa4_len, (unsigned long )aiv4->ai_addrlen);
#line 3225
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: %.80s - sockaddr too small (%lu < %lu)\n",
              argv0, hostname, sa4_len, (unsigned long )aiv4->ai_addrlen);
#line 3229
      exit(1);
      }
    }
    {
#line 3231
    memset((void *)usa4P, 0, sa4_len);
#line 3232
    memmove((void *)usa4P, (void const   *)aiv4->ai_addr, (size_t )aiv4->ai_addrlen);
#line 3233
    *gotv4P = 1;
    }
  }
  {
#line 3236
  freeaddrinfo(ai);
  }
#line 3287
  return;
}
}
#line 3294 "/home/wheatley/newnew/temp/mini-httpd-1.19/mini_httpd.c"
static char str[200]  ;
#line 3290 "/home/wheatley/newnew/temp/mini-httpd-1.19/mini_httpd.c"
static char *ntoa(usockaddr *usaP ) 
{ 
  struct in6_addr  const  *__a ;
  uint32_t tmp ;
  int tmp___0 ;
  int tmp___1 ;
  size_t tmp___2 ;
  int tmp___3 ;

  {
  {
#line 3296
  tmp___2 = sockaddr_len(usaP);
#line 3296
  tmp___3 = getnameinfo((struct sockaddr  const  */* __restrict  */)(& usaP->sa),
                        (socklen_t )tmp___2, (char */* __restrict  */)(str), (socklen_t )sizeof(str),
                        (char */* __restrict  */)0, (socklen_t )0, 1);
  }
#line 3296
  if (tmp___3 != 0) {
#line 3298
    str[0] = (char )'?';
#line 3299
    str[1] = (char )'\000';
  } else {
#line 3301
    __a = (struct in6_addr  const  *)(& usaP->sa_in6.sin6_addr);
#line 3301
    if (__a->__in6_u.__u6_addr32[0] == 0U) {
#line 3301
      if (__a->__in6_u.__u6_addr32[1] == 0U) {
        {
#line 3301
        tmp = htonl((uint32_t )65535);
        }
#line 3301
        if (__a->__in6_u.__u6_addr32[2] == tmp) {
#line 3301
          tmp___0 = 1;
        } else {
#line 3301
          tmp___0 = 0;
        }
      } else {
#line 3301
        tmp___0 = 0;
      }
    } else {
#line 3301
      tmp___0 = 0;
    }
#line 3301
    if (tmp___0) {
      {
#line 3301
      tmp___1 = strncmp((char const   *)(str), "::ffff:", (size_t )7);
      }
#line 3301
      if (tmp___1 == 0) {
        {
#line 3303
        strcpy((char */* __restrict  */)(str), (char const   */* __restrict  */)(& str[7]));
        }
      }
    }
  }
#line 3305
  return (str);
}
}
#line 3315 "/home/wheatley/newnew/temp/mini-httpd-1.19/mini_httpd.c"
static int sockaddr_check(usockaddr *usaP ) 
{ 


  {
  {
#line 3320
  if ((int )usaP->sa.sa_family == 2) {
#line 3320
    goto case_2;
  }
#line 3322
  if ((int )usaP->sa.sa_family == 10) {
#line 3322
    goto case_10;
  }
#line 3324
  goto switch_default;
  case_2: /* CIL Label */ 
#line 3320
  return (1);
  case_10: /* CIL Label */ 
#line 3322
  return (1);
  switch_default: /* CIL Label */ 
#line 3325
  return (0);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 3330 "/home/wheatley/newnew/temp/mini-httpd-1.19/mini_httpd.c"
static size_t sockaddr_len(usockaddr *usaP ) 
{ 


  {
  {
#line 3335
  if ((int )usaP->sa.sa_family == 2) {
#line 3335
    goto case_2;
  }
#line 3337
  if ((int )usaP->sa.sa_family == 10) {
#line 3337
    goto case_10;
  }
#line 3339
  goto switch_default;
  case_2: /* CIL Label */ 
#line 3335
  return (sizeof(struct sockaddr_in ));
  case_10: /* CIL Label */ 
#line 3337
  return (sizeof(struct sockaddr_in6 ));
  switch_default: /* CIL Label */ 
#line 3340
  return ((size_t )0);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 3348 "/home/wheatley/newnew/temp/mini-httpd-1.19/mini_httpd.c"
static void strdecode(char *to , char *from ) 
{ 
  int tmp ;
  int tmp___0 ;
  unsigned short const   **tmp___1 ;
  unsigned short const   **tmp___2 ;

  {
  {
#line 3351
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3351
    if (! ((int )*from != 0)) {
#line 3351
      goto while_break;
    }
#line 3353
    if ((int )*(from + 0) == 37) {
      {
#line 3353
      tmp___1 = __ctype_b_loc();
      }
#line 3353
      if ((int const   )*(*tmp___1 + (int )*(from + 1)) & 4096) {
        {
#line 3353
        tmp___2 = __ctype_b_loc();
        }
#line 3353
        if ((int const   )*(*tmp___2 + (int )*(from + 2)) & 4096) {
          {
#line 3355
          tmp = hexit(*(from + 1));
#line 3355
          tmp___0 = hexit(*(from + 2));
#line 3355
          *to = (char )(tmp * 16 + tmp___0);
#line 3356
          from += 2;
          }
        } else {
#line 3359
          *to = *from;
        }
      } else {
#line 3359
        *to = *from;
      }
    } else {
#line 3359
      *to = *from;
    }
#line 3351
    to ++;
#line 3351
    from ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 3361
  *to = (char )'\000';
#line 3362
  return;
}
}
#line 3365 "/home/wheatley/newnew/temp/mini-httpd-1.19/mini_httpd.c"
static int hexit(char c ) 
{ 


  {
#line 3368
  if ((int )c >= 48) {
#line 3368
    if ((int )c <= 57) {
#line 3369
      return ((int )c - 48);
    }
  }
#line 3370
  if ((int )c >= 97) {
#line 3370
    if ((int )c <= 102) {
#line 3371
      return (((int )c - 97) + 10);
    }
  }
#line 3372
  if ((int )c >= 65) {
#line 3372
    if ((int )c <= 70) {
#line 3373
      return (((int )c - 65) + 10);
    }
  }
#line 3374
  return (0);
}
}
#line 3389 "/home/wheatley/newnew/temp/mini-httpd-1.19/mini_httpd.c"
static int b64_decode_table[256]  = 
#line 3389
  {      -1,      -1,      -1,      -1, 
        -1,      -1,      -1,      -1, 
        -1,      -1,      -1,      -1, 
        -1,      -1,      -1,      -1, 
        -1,      -1,      -1,      -1, 
        -1,      -1,      -1,      -1, 
        -1,      -1,      -1,      -1, 
        -1,      -1,      -1,      -1, 
        -1,      -1,      -1,      -1, 
        -1,      -1,      -1,      -1, 
        -1,      -1,      -1,      62, 
        -1,      -1,      -1,      63, 
        52,      53,      54,      55, 
        56,      57,      58,      59, 
        60,      61,      -1,      -1, 
        -1,      -1,      -1,      -1, 
        -1,      0,      1,      2, 
        3,      4,      5,      6, 
        7,      8,      9,      10, 
        11,      12,      13,      14, 
        15,      16,      17,      18, 
        19,      20,      21,      22, 
        23,      24,      25,      -1, 
        -1,      -1,      -1,      -1, 
        -1,      26,      27,      28, 
        29,      30,      31,      32, 
        33,      34,      35,      36, 
        37,      38,      39,      40, 
        41,      42,      43,      44, 
        45,      46,      47,      48, 
        49,      50,      51,      -1, 
        -1,      -1,      -1,      -1, 
        -1,      -1,      -1,      -1, 
        -1,      -1,      -1,      -1, 
        -1,      -1,      -1,      -1, 
        -1,      -1,      -1,      -1, 
        -1,      -1,      -1,      -1, 
        -1,      -1,      -1,      -1, 
        -1,      -1,      -1,      -1, 
        -1,      -1,      -1,      -1, 
        -1,      -1,      -1,      -1, 
        -1,      -1,      -1,      -1, 
        -1,      -1,      -1,      -1, 
        -1,      -1,      -1,      -1, 
        -1,      -1,      -1,      -1, 
        -1,      -1,      -1,      -1, 
        -1,      -1,      -1,      -1, 
        -1,      -1,      -1,      -1, 
        -1,      -1,      -1,      -1, 
        -1,      -1,      -1,      -1, 
        -1,      -1,      -1,      -1, 
        -1,      -1,      -1,      -1, 
        -1,      -1,      -1,      -1, 
        -1,      -1,      -1,      -1, 
        -1,      -1,      -1,      -1, 
        -1,      -1,      -1,      -1, 
        -1,      -1,      -1,      -1, 
        -1,      -1,      -1,      -1, 
        -1,      -1,      -1,      -1, 
        -1,      -1,      -1,      -1, 
        -1,      -1,      -1,      -1, 
        -1,      -1,      -1,      -1, 
        -1,      -1,      -1,      -1, 
        -1,      -1,      -1,      -1};
#line 3413 "/home/wheatley/newnew/temp/mini-httpd-1.19/mini_httpd.c"
static int b64_decode(char const   *str___0 , unsigned char *space , int size ) 
{ 
  char const   *cp ;
  int space_idx ;
  int phase ;
  int d ;
  int prev_d ;
  unsigned char c ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 3418
  prev_d = 0;
#line 3421
  space_idx = 0;
#line 3422
  phase = 0;
#line 3423
  cp = str___0;
  {
#line 3423
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3423
    if (! ((int const   )*cp != 0)) {
#line 3423
      goto while_break;
    }
#line 3425
    d = b64_decode_table[(int )*cp];
#line 3426
    if (d != -1) {
      {
#line 3430
      if (phase == 0) {
#line 3430
        goto case_0;
      }
#line 3433
      if (phase == 1) {
#line 3433
        goto case_1;
      }
#line 3439
      if (phase == 2) {
#line 3439
        goto case_2;
      }
#line 3445
      if (phase == 3) {
#line 3445
        goto case_3;
      }
#line 3428
      goto switch_break;
      case_0: /* CIL Label */ 
#line 3431
      phase ++;
#line 3432
      goto switch_break;
      case_1: /* CIL Label */ 
#line 3434
      c = (unsigned char )((prev_d << 2) | ((d & 48) >> 4));
#line 3435
      if (space_idx < size) {
#line 3436
        tmp = space_idx;
#line 3436
        space_idx ++;
#line 3436
        *(space + tmp) = c;
      }
#line 3437
      phase ++;
#line 3438
      goto switch_break;
      case_2: /* CIL Label */ 
#line 3440
      c = (unsigned char )(((prev_d & 15) << 4) | ((d & 60) >> 2));
#line 3441
      if (space_idx < size) {
#line 3442
        tmp___0 = space_idx;
#line 3442
        space_idx ++;
#line 3442
        *(space + tmp___0) = c;
      }
#line 3443
      phase ++;
#line 3444
      goto switch_break;
      case_3: /* CIL Label */ 
#line 3446
      c = (unsigned char )(((prev_d & 3) << 6) | d);
#line 3447
      if (space_idx < size) {
#line 3448
        tmp___1 = space_idx;
#line 3448
        space_idx ++;
#line 3448
        *(space + tmp___1) = c;
      }
#line 3449
      phase = 0;
#line 3450
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
#line 3452
      prev_d = d;
    }
#line 3423
    cp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 3455
  return (space_idx);
}
}
#line 3460 "/home/wheatley/newnew/temp/mini-httpd-1.19/mini_httpd.c"
static void set_ndelay(int fd ) 
{ 
  int flags ;
  int newflags ;

  {
  {
#line 3465
  flags = fcntl(fd, 3, 0);
  }
#line 3466
  if (flags != -1) {
#line 3468
    newflags = flags | 2048;
#line 3469
    if (newflags != flags) {
      {
#line 3470
      fcntl(fd, 4, newflags);
      }
    }
  }
#line 3472
  return;
}
}
#line 3476 "/home/wheatley/newnew/temp/mini-httpd-1.19/mini_httpd.c"
static void clear_ndelay(int fd ) 
{ 
  int flags ;
  int newflags ;

  {
  {
#line 3481
  flags = fcntl(fd, 3, 0);
  }
#line 3482
  if (flags != -1) {
#line 3484
    newflags = flags & -2049;
#line 3485
    if (newflags != flags) {
      {
#line 3486
      fcntl(fd, 4, newflags);
      }
    }
  }
#line 3488
  return;
}
}
#line 3491 "/home/wheatley/newnew/temp/mini-httpd-1.19/mini_httpd.c"
static void *e_malloc(size_t size ) 
{ 
  void *ptr ;

  {
  {
#line 3496
  ptr = malloc(size);
  }
#line 3497
  if ((unsigned long )ptr == (unsigned long )((void *)0)) {
    {
#line 3499
    syslog(2, "out of memory");
#line 3500
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: out of memory\n",
            argv0);
#line 3501
    exit(1);
    }
  }
#line 3503
  return (ptr);
}
}
#line 3507 "/home/wheatley/newnew/temp/mini-httpd-1.19/mini_httpd.c"
static void *e_realloc(void *optr , size_t size ) 
{ 
  void *ptr ;

  {
  {
#line 3512
  ptr = realloc(optr, size);
  }
#line 3513
  if ((unsigned long )ptr == (unsigned long )((void *)0)) {
    {
#line 3515
    syslog(2, "out of memory");
#line 3516
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: out of memory\n",
            argv0);
#line 3517
    exit(1);
    }
  }
#line 3519
  return (ptr);
}
}
#line 3523 "/home/wheatley/newnew/temp/mini-httpd-1.19/mini_httpd.c"
static char *e_strdup(char *ostr ) 
{ 
  char *str___0 ;

  {
  {
#line 3528
  str___0 = strdup((char const   *)ostr);
  }
#line 3529
  if ((unsigned long )str___0 == (unsigned long )((char *)0)) {
    {
#line 3531
    syslog(2, "out of memory copying a string");
#line 3532
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: out of memory copying a string\n",
            argv0);
#line 3533
    exit(1);
    }
  }
#line 3535
  return (str___0);
}
}
