/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 133 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __pid_t;
#line 183 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef char *__caddr_t;
#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 28 "/usr/include/x86_64-linux-gnu/bits/sockaddr.h"
typedef unsigned short sa_family_t;
#line 149 "/usr/include/x86_64-linux-gnu/bits/socket.h"
struct sockaddr {
   sa_family_t sa_family ;
   char sa_data[14] ;
};
#line 90 "/usr/include/x86_64-linux-gnu/sys/socket.h"
struct sockaddr_in;
#line 49 "/usr/include/stdint.h"
typedef unsigned short uint16_t;
#line 51 "/usr/include/stdint.h"
typedef unsigned int uint32_t;
#line 30 "/usr/include/netinet/in.h"
typedef uint32_t in_addr_t;
#line 31 "/usr/include/netinet/in.h"
struct in_addr {
   in_addr_t s_addr ;
};
#line 117 "/usr/include/netinet/in.h"
typedef uint16_t in_port_t;
#line 237 "/usr/include/netinet/in.h"
struct sockaddr_in {
   sa_family_t sin_family ;
   in_port_t sin_port ;
   struct in_addr sin_addr ;
   unsigned char sin_zero[((sizeof(struct sockaddr ) - sizeof(unsigned short )) - sizeof(in_port_t )) - sizeof(struct in_addr )] ;
};
#line 228 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/test/../ipvers.h"
union __anonunion_pdnsd_a_23 {
   struct in_addr ipv4 ;
};
#line 228 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/test/../ipvers.h"
typedef union __anonunion_pdnsd_a_23 pdnsd_a;
#line 111 "/usr/include/net/if.h"
struct ifmap {
   unsigned long mem_start ;
   unsigned long mem_end ;
   unsigned short base_addr ;
   unsigned char irq ;
   unsigned char dma ;
   unsigned char port ;
};
#line 126 "/usr/include/net/if.h"
union __anonunion_ifr_ifrn_28 {
   char ifrn_name[16] ;
};
#line 126 "/usr/include/net/if.h"
union __anonunion_ifr_ifru_29 {
   struct sockaddr ifru_addr ;
   struct sockaddr ifru_dstaddr ;
   struct sockaddr ifru_broadaddr ;
   struct sockaddr ifru_netmask ;
   struct sockaddr ifru_hwaddr ;
   short ifru_flags ;
   int ifru_ivalue ;
   int ifru_mtu ;
   struct ifmap ifru_map ;
   char ifru_slave[16] ;
   char ifru_newname[16] ;
   __caddr_t ifru_data ;
};
#line 126 "/usr/include/net/if.h"
struct ifreq {
   union __anonunion_ifr_ifrn_28 ifr_ifrn ;
   union __anonunion_ifr_ifru_29 ifr_ifru ;
};
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 75 "/usr/include/time.h"
typedef __time_t time_t;
#line 60 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef unsigned long pthread_t;
#line 117 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/test/../conff.h"
typedef unsigned char *zone_t;
#line 118 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/test/../conff.h"
struct __anonstruct_zone_array_79 {
   size_t nel ;
   zone_t elem[0] ;
};
#line 118 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/test/../conff.h"
typedef struct __anonstruct_zone_array_79 *zone_array;
#line 120 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/test/../conff.h"
struct __anonstruct_globparm_t_80 {
   long perm_cache ;
   char *cache_dir ;
   char *pidfile ;
   int port ;
   pdnsd_a a ;
   pdnsd_a out_a ;
   time_t max_ttl ;
   time_t min_ttl ;
   time_t neg_ttl ;
   short neg_rrs_pol ;
   short neg_domain_pol ;
   short verbosity ;
   char run_as[21] ;
   char daemon ;
   char debug ;
   char stat_pipe ;
   char notcp ;
   char strict_suid ;
   char use_nss ;
   char paranoid ;
   char lndown_kluge ;
   char onquery ;
   char rnd_recs ;
   int ctl_perms ;
   char *scheme_file ;
   int proc_limit ;
   int procq_limit ;
   time_t tcp_qtimeout ;
   time_t timeout ;
   int par_queries ;
   int query_method ;
   int query_port_start ;
   int query_port_end ;
   int udpbufsize ;
   zone_array deleg_only_zones ;
};
#line 120 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/test/../conff.h"
typedef struct __anonstruct_globparm_t_80 globparm_t;
#line 172 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __ssize_t;
#line 189 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __socklen_t;
#line 36 "/usr/include/x86_64-linux-gnu/sys/poll.h"
typedef unsigned long nfds_t;
#line 39 "/usr/include/x86_64-linux-gnu/sys/poll.h"
struct pollfd {
   int fd ;
   short events ;
   short revents ;
};
#line 109 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __ssize_t ssize_t;
#line 200 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef unsigned char u_int8_t;
#line 201 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef unsigned short u_int16_t;
#line 202 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef unsigned int u_int32_t;
#line 274 "/usr/include/unistd.h"
typedef __socklen_t socklen_t;
#line 44 "/usr/include/netinet/ip.h"
struct iphdr {
   unsigned int ihl : 4 ;
   unsigned int version : 4 ;
   u_int8_t tos ;
   u_int16_t tot_len ;
   u_int16_t id ;
   u_int16_t frag_off ;
   u_int8_t ttl ;
   u_int8_t protocol ;
   u_int16_t check ;
   u_int32_t saddr ;
   u_int32_t daddr ;
};
#line 20 "/usr/include/asm-generic/int-ll64.h"
typedef unsigned char __u8;
#line 23 "/usr/include/asm-generic/int-ll64.h"
typedef unsigned short __u16;
#line 26 "/usr/include/asm-generic/int-ll64.h"
typedef unsigned int __u32;
#line 28 "/usr/include/linux/types.h"
typedef __u16 __be16;
#line 30 "/usr/include/linux/types.h"
typedef __u32 __be32;
#line 34 "/usr/include/linux/types.h"
typedef __u16 __sum16;
#line 68 "/usr/include/linux/icmp.h"
struct __anonstruct_echo_39 {
   __be16 id ;
   __be16 sequence ;
};
#line 68 "/usr/include/linux/icmp.h"
struct __anonstruct_frag_40 {
   __be16 __unused ;
   __be16 mtu ;
};
#line 68 "/usr/include/linux/icmp.h"
union __anonunion_un_38 {
   struct __anonstruct_echo_39 echo ;
   __be32 gateway ;
   struct __anonstruct_frag_40 frag ;
};
#line 68 "/usr/include/linux/icmp.h"
struct icmphdr {
   __u8 type ;
   __u8 code ;
   __sum16 checksum ;
   union __anonunion_un_38 un ;
};
#line 92 "/usr/include/linux/icmp.h"
struct icmp_filter {
   __u32 data ;
};
#line 75 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
struct __pthread_internal_list {
   struct __pthread_internal_list *__prev ;
   struct __pthread_internal_list *__next ;
};
#line 75 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef struct __pthread_internal_list __pthread_list_t;
#line 90 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
struct __pthread_mutex_s {
   int __lock ;
   unsigned int __count ;
   int __owner ;
   unsigned int __nusers ;
   int __kind ;
   short __spins ;
   short __elision ;
   __pthread_list_t __list ;
};
#line 90 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
union __anonunion_pthread_mutex_t_4 {
   struct __pthread_mutex_s __data ;
   char __size[40] ;
   long __align ;
};
#line 90 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef union __anonunion_pthread_mutex_t_4 pthread_mutex_t;
#line 163 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef unsigned int pthread_key_t;
#line 40 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stdarg.h"
typedef __builtin_va_list __gnuc_va_list;
#line 79 "/usr/include/stdio.h"
typedef __gnuc_va_list va_list;
#line 133 "/usr/include/time.h"
struct tm {
   int tm_sec ;
   int tm_min ;
   int tm_hour ;
   int tm_mday ;
   int tm_mon ;
   int tm_year ;
   int tm_wday ;
   int tm_yday ;
   int tm_isdst ;
   long tm_gmtoff ;
   char const   *tm_zone ;
};
#line 125 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uid_t;
#line 126 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __gid_t;
#line 141 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __suseconds_t;
#line 175 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __syscall_slong_t;
#line 120 "/usr/include/time.h"
struct timespec {
   __time_t tv_sec ;
   __syscall_slong_t tv_nsec ;
};
#line 30 "/usr/include/x86_64-linux-gnu/bits/time.h"
struct timeval {
   __time_t tv_sec ;
   __suseconds_t tv_usec ;
};
#line 55 "/usr/include/x86_64-linux-gnu/sys/time.h"
struct timezone {
   int tz_minuteswest ;
   int tz_dsttime ;
};
#line 61 "/usr/include/x86_64-linux-gnu/sys/time.h"
typedef struct timezone * __restrict  __timezone_ptr_t;
#line 49 "/usr/include/pwd.h"
struct passwd {
   char *pw_name ;
   char *pw_passwd ;
   __uid_t pw_uid ;
   __gid_t pw_gid ;
   char *pw_gecos ;
   char *pw_dir ;
   char *pw_shell ;
};
#line 63 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
union pthread_attr_t {
   char __size[56] ;
   long __align ;
};
#line 69 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef union pthread_attr_t pthread_attr_t;
#line 90 "/usr/include/x86_64-linux-gnu/sys/socket.h"
struct sockaddr_un;
#line 29 "/usr/include/x86_64-linux-gnu/sys/un.h"
struct sockaddr_un {
   sa_family_t sun_family ;
   char sun_path[108] ;
};
#line 48 "/usr/include/stdint.h"
typedef unsigned char uint8_t;
#line 209 "/usr/include/netinet/in.h"
union __anonunion___in6_u_51 {
   uint8_t __u6_addr8[16] ;
   uint16_t __u6_addr16[8] ;
   uint32_t __u6_addr32[4] ;
};
#line 209 "/usr/include/netinet/in.h"
struct in6_addr {
   union __anonunion___in6_u_51 __in6_u ;
};
#line 58 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/pdnsd-ctl/pdnsd-ctl.c"
struct __anonstruct_cmd_s_88 {
   char *name ;
   int val ;
};
#line 58 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/pdnsd-ctl/pdnsd-ctl.c"
typedef struct __anonstruct_cmd_s_88 cmd_s;
#line 287 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/ipvers.h"
union __anonunion_pdnsd_ca_79 {
   struct in_addr ipv4 ;
   struct in6_addr ipv6 ;
};
#line 287 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/ipvers.h"
typedef union __anonunion_pdnsd_ca_79 pdnsd_ca;
#line 78 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/list.h"
struct _dynamic_list_head {
   size_t last ;
   size_t lastsz ;
   char data[0] ;
};
#line 83 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/list.h"
typedef struct _dynamic_list_head *dlist;
#line 166 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/dns.h"
struct __anonstruct_dns_hdr_t_88 {
   uint16_t id ;
   unsigned int rd : 1 ;
   unsigned int tc : 1 ;
   unsigned int aa : 1 ;
   unsigned int opcode : 4 ;
   unsigned int qr : 1 ;
   unsigned int rcode : 4 ;
   unsigned int cd : 1 ;
   unsigned int ad : 1 ;
   unsigned int z : 1 ;
   unsigned int ra : 1 ;
   uint16_t qdcount ;
   uint16_t ancount ;
   uint16_t nscount ;
   uint16_t arcount ;
} __attribute__((__packed__)) ;
#line 166 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/dns.h"
typedef struct __anonstruct_dns_hdr_t_88 dns_hdr_t;
#line 279 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/dns.h"
struct __anonstruct_compel_t_91 {
   unsigned int index ;
   unsigned char s[0] ;
};
#line 279 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/dns.h"
typedef struct __anonstruct_compel_t_91 compel_t;
#line 34 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/cache.h"
struct rr_lent_s;
#line 39 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/cache.h"
struct rr_b_s {
   struct rr_b_s *next ;
   unsigned int rdlen ;
   struct in6_addr data[0] ;
};
#line 39 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/cache.h"
typedef struct rr_b_s rr_bucket_t;
#line 49 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/cache.h"
struct __anonstruct_rr_set_t_107 {
   struct rr_lent_s *lent ;
   time_t ttl ;
   time_t ts ;
   unsigned short flags ;
   rr_bucket_t *rrs ;
};
#line 49 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/cache.h"
typedef struct __anonstruct_rr_set_t_107 rr_set_t;
#line 58 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/cache.h"
struct __anonstruct_neg_110 {
   struct rr_lent_s *lent ;
   time_t ttl ;
   time_t ts ;
};
#line 58 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/cache.h"
struct __anonstruct_rr_111 {
   rr_set_t *rrmu[8] ;
   rr_set_t **rrext ;
};
#line 58 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/cache.h"
union __anonunion____missing_field_name_109 {
   struct __anonstruct_neg_110 neg ;
   struct __anonstruct_rr_111 rr ;
};
#line 58 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/cache.h"
struct __anonstruct_dns_cent_t_108 {
   unsigned char *qname ;
   size_t cs ;
   unsigned short num_rrs ;
   unsigned short flags ;
   union __anonunion____missing_field_name_109 __annonCompField2 ;
   unsigned char c_ns ;
   unsigned char c_soa ;
};
#line 58 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/cache.h"
typedef struct __anonstruct_dns_cent_t_108 dns_cent_t;
#line 32 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/list.h"
struct __anonstruct_darray_37 {
   size_t nel ;
};
#line 32 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/list.h"
typedef struct __anonstruct_darray_37 *darray;
#line 248 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/ipvers.h"
struct __anonstruct_pdnsd_a2_42 {
   struct in_addr ipv4 ;
};
#line 248 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/ipvers.h"
typedef struct __anonstruct_pdnsd_a2_42 pdnsd_a2;
#line 201 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/dns.h"
struct __anonstruct_dns_msg_t_56 {
   uint16_t len ;
   dns_hdr_t hdr ;
} __attribute__((__packed__)) ;
#line 201 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/dns.h"
typedef struct __anonstruct_dns_msg_t_56 dns_msg_t;
#line 216 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/dns.h"
struct __anonstruct_edns_info_t_57 {
   unsigned short udpsize ;
   unsigned short rcode ;
   unsigned short version ;
   unsigned char do_flg ;
};
#line 216 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/dns.h"
typedef struct __anonstruct_edns_info_t_57 edns_info_t;
#line 53 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/conff.h"
struct __anonstruct_addr2_array_73 {
   size_t nel ;
   pdnsd_a2 elem[0] ;
};
#line 53 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/conff.h"
typedef struct __anonstruct_addr2_array_73 *addr2_array;
#line 55 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/conff.h"
struct __anonstruct_atup_t_74 {
   time_t i_ts ;
   char is_up ;
   pdnsd_a2 a ;
};
#line 55 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/conff.h"
typedef struct __anonstruct_atup_t_74 atup_t;
#line 60 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/conff.h"
struct __anonstruct_atup_array_75 {
   size_t nel ;
   atup_t elem[0] ;
};
#line 60 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/conff.h"
typedef struct __anonstruct_atup_array_75 *atup_array;
#line 62 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/conff.h"
struct __anonstruct_slist_t_76 {
   unsigned char *domain ;
   short exact ;
   short rule ;
};
#line 62 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/conff.h"
typedef struct __anonstruct_slist_t_76 slist_t;
#line 67 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/conff.h"
struct __anonstruct_slist_array_77 {
   size_t nel ;
   slist_t elem[0] ;
};
#line 67 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/conff.h"
typedef struct __anonstruct_slist_array_77 *slist_array;
#line 69 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/conff.h"
struct __anonstruct_addr4maskpair_t_78 {
   struct in_addr a ;
   struct in_addr mask ;
};
#line 69 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/conff.h"
typedef struct __anonstruct_addr4maskpair_t_78 addr4maskpair_t;
#line 73 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/conff.h"
struct __anonstruct_a4_array_79 {
   size_t nel ;
   addr4maskpair_t elem[0] ;
};
#line 73 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/conff.h"
typedef struct __anonstruct_a4_array_79 *a4_array;
#line 76 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/conff.h"
struct __anonstruct_addr6maskpair_t_80 {
   struct in6_addr a ;
   struct in6_addr mask ;
};
#line 76 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/conff.h"
typedef struct __anonstruct_addr6maskpair_t_80 addr6maskpair_t;
#line 80 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/conff.h"
struct __anonstruct_a6_array_81 {
   size_t nel ;
   addr6maskpair_t elem[0] ;
};
#line 80 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/conff.h"
typedef struct __anonstruct_a6_array_81 *a6_array;
#line 83 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/conff.h"
struct __anonstruct_servparm_t_82 {
   unsigned short port ;
   short uptest ;
   time_t timeout ;
   time_t interval ;
   time_t ping_timeout ;
   char scheme[32] ;
   char *uptest_cmd ;
   char uptest_usr[21] ;
   char interface[16] ;
   char device[16] ;
   unsigned char *query_test_name ;
   char *label ;
   char purge_cache ;
   char nocache ;
   char lean_query ;
   char edns_query ;
   char is_proxy ;
   char rootserver ;
   char rand_servers ;
   char preset ;
   char rejectrecursively ;
   short rejectpolicy ;
   short policy ;
   slist_array alist ;
   atup_array atup_a ;
   a4_array reject_a4 ;
   a6_array reject_a6 ;
   pdnsd_a ping_a ;
};
#line 83 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/conff.h"
typedef struct __anonstruct_servparm_t_82 servparm_t;
#line 115 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/conff.h"
struct __anonstruct_servparm_array_83 {
   size_t nel ;
   servparm_t elem[0] ;
};
#line 115 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/conff.h"
typedef struct __anonstruct_servparm_array_83 *servparm_array;
#line 33 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/dns_query.h"
struct qhintnode_s;
#line 33 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/dns_query.h"
typedef struct qhintnode_s qhintnode_t;
#line 61 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/dns_query.c"
struct rejectlist_s {
   struct rejectlist_s *next ;
   short policy ;
   short inherit ;
   int na4 ;
   int na6 ;
   addr6maskpair_t rdata[0] ;
};
#line 61 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/dns_query.c"
typedef struct rejectlist_s rejectlist_t;
#line 75 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/dns_query.c"
union __anonunion_a_116 {
   struct sockaddr_in sin4 ;
};
#line 75 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/dns_query.c"
struct __anonstruct_query_stat_t_115 {
   union __anonunion_a_116 a ;
   time_t timeout ;
   unsigned short flags ;
   short nocache ;
   short state ;
   short qm ;
   char auth_serv ;
   char lean_query ;
   char edns_query ;
   char needs_testing ;
   char trusted ;
   char aa ;
   char tc ;
   char failed ;
   unsigned char const   *nsdomain ;
   rejectlist_t *rejectlist ;
   int sock ;
   unsigned short transl ;
   unsigned short recvl ;
   int iolen ;
   dns_msg_t *msg ;
   dns_hdr_t *recvbuf ;
   unsigned short myrid ;
   int s_errno ;
};
#line 75 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/dns_query.c"
typedef struct __anonstruct_query_stat_t_115 query_stat_t;
#line 118 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/dns_query.c"
struct __anonstruct_query_stat_array_117 {
   size_t nel ;
   query_stat_t elem[0] ;
};
#line 118 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/dns_query.c"
typedef struct __anonstruct_query_stat_array_117 *query_stat_array;
#line 174 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/dns_query.c"
struct __anonstruct_dns_cent_array_118 {
   size_t nel ;
   dns_cent_t elem[0] ;
};
#line 174 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/dns_query.c"
typedef struct __anonstruct_dns_cent_array_118 *dns_cent_array;
#line 691 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/dns_query.c"
union __anonunion_sin_119 {
   struct sockaddr_in sin4 ;
};
#line 2030 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/dns_query.c"
struct qstatnode_s {
   query_stat_array qa ;
   struct qstatnode_s *next ;
};
#line 2034 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/dns_query.c"
typedef struct qstatnode_s qstatnode_t;
#line 2036 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/dns_query.c"
struct qhintnode_s {
   unsigned char const   *nm ;
   int tp ;
   struct qhintnode_s *next ;
};
#line 161 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/conff.h"
struct __anonstruct_cmdlineflags_t_75 {
   char pidfile ;
   char verbosity ;
   char pdnsduser ;
   char daemon ;
   char debug ;
   char stat_pipe ;
   char notcp ;
   char query_method ;
};
#line 161 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/conff.h"
typedef struct __anonstruct_cmdlineflags_t_75 cmdlineflags_t;
#line 60 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/consts.h"
struct __anonstruct_namevalue_t_77 {
   char const   *name ;
   int val ;
};
#line 60 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/consts.h"
typedef struct __anonstruct_namevalue_t_77 namevalue_t;
#line 124 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __dev_t;
#line 127 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __ino_t;
#line 129 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __mode_t;
#line 130 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __nlink_t;
#line 153 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blksize_t;
#line 158 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blkcnt_t;
#line 80 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __uid_t uid_t;
#line 46 "/usr/include/x86_64-linux-gnu/bits/stat.h"
struct stat {
   __dev_t st_dev ;
   __ino_t st_ino ;
   __nlink_t st_nlink ;
   __mode_t st_mode ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   int __pad0 ;
   __dev_t st_rdev ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   __syscall_slong_t __glibc_reserved[3] ;
};
#line 70 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __mode_t mode_t;
#line 48 "/usr/include/x86_64-linux-gnu/sys/utsname.h"
struct utsname {
   char sysname[65] ;
   char nodename[65] ;
   char release[65] ;
   char version[65] ;
   char machine[65] ;
   char domainname[65] ;
};
#line 52 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/conff.h"
struct __anonstruct_addr_array_87 {
   size_t nel ;
   pdnsd_a elem[0] ;
};
#line 52 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/conff.h"
typedef struct __anonstruct_addr_array_87 *addr_array;
#line 138 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
struct __anonstruct___data_14 {
   int __lock ;
   unsigned int __futex ;
   unsigned long long __total_seq ;
   unsigned long long __wakeup_seq ;
   unsigned long long __woken_seq ;
   void *__mutex ;
   unsigned int __nwaiters ;
   unsigned int __broadcast_seq ;
};
#line 138 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
union __anonunion_pthread_cond_t_13 {
   struct __anonstruct___data_14 __data ;
   char __size[48] ;
   long long __align ;
};
#line 138 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef union __anonunion_pthread_cond_t_13 pthread_cond_t;
#line 455 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/rr_types.h"
struct rr_infos {
   unsigned short class ;
   unsigned short excludes ;
};
#line 29 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/hash.h"
struct dns_hash_ent_s {
   struct dns_hash_ent_s *next ;
   unsigned long rhash ;
   dns_cent_t *data ;
};
#line 29 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/hash.h"
typedef struct dns_hash_ent_s dns_hash_ent_t;
#line 49 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/hash.h"
struct __anonstruct_dns_hash_loc_t_113 {
   dns_hash_ent_t **pos ;
   unsigned long rhash ;
};
#line 49 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/hash.h"
typedef struct __anonstruct_dns_hash_loc_t_113 dns_hash_loc_t;
#line 55 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/hash.h"
struct __anonstruct_dns_hash_pos_t_114 {
   int bucket ;
   dns_hash_ent_t *ent ;
};
#line 55 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/hash.h"
typedef struct __anonstruct_dns_hash_pos_t_114 dns_hash_pos_t;
#line 104 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/cache.c"
struct __anonstruct_rr_fbucket_t_115 {
   unsigned short rdlen ;
};
#line 104 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/cache.c"
typedef struct __anonstruct_rr_fbucket_t_115 rr_fbucket_t;
#line 109 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/cache.c"
struct __anonstruct_rr_fset_t_116 {
   unsigned char tp ;
   unsigned char num_rr ;
   unsigned short flags ;
   time_t ttl ;
   time_t ts ;
} __attribute__((__packed__)) ;
#line 109 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/cache.c"
typedef struct __anonstruct_rr_fset_t_116 rr_fset_t;
#line 122 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/cache.c"
struct __anonstruct_dns_file_t_117 {
   unsigned char qlen ;
   unsigned char num_rrs ;
   unsigned short flags ;
   unsigned char c_ns ;
   unsigned char c_soa ;
} __attribute__((__packed__)) ;
#line 122 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/cache.c"
typedef struct __anonstruct_dns_file_t_117 dns_file_t;
#line 135 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/cache.c"
struct __anonstruct_dom_fttlts_t_118 {
   time_t ttl ;
   time_t ts ;
} __attribute__((__packed__)) ;
#line 135 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/cache.c"
typedef struct __anonstruct_dom_fttlts_t_118 dom_fttlts_t;
#line 145 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/cache.c"
struct rr_lent_s {
   struct rr_lent_s *next ;
   struct rr_lent_s *prev ;
   rr_set_t *rrset ;
   dns_cent_t *cent ;
   int idx ;
};
#line 145 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/cache.c"
typedef struct rr_lent_s rr_lent_t;
#line 196 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef int int32_t;
#line 135 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __clock_t;
#line 98 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __pid_t pid_t;
#line 27 "/usr/include/x86_64-linux-gnu/bits/sigset.h"
struct __anonstruct___sigset_t_9 {
   unsigned long __val[1024UL / (8UL * sizeof(unsigned long ))] ;
};
#line 27 "/usr/include/x86_64-linux-gnu/bits/sigset.h"
typedef struct __anonstruct___sigset_t_9 __sigset_t;
#line 37 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef __sigset_t sigset_t;
#line 32 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
union sigval {
   int sival_int ;
   void *sival_ptr ;
};
#line 32 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
typedef union sigval sigval_t;
#line 58 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
typedef __clock_t __sigchld_clock_t;
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__kill_28 {
   __pid_t si_pid ;
   __uid_t si_uid ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__timer_29 {
   int si_tid ;
   int si_overrun ;
   sigval_t si_sigval ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__rt_30 {
   __pid_t si_pid ;
   __uid_t si_uid ;
   sigval_t si_sigval ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__sigchld_31 {
   __pid_t si_pid ;
   __uid_t si_uid ;
   int si_status ;
   __sigchld_clock_t si_utime ;
   __sigchld_clock_t si_stime ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__sigfault_32 {
   void *si_addr ;
   short si_addr_lsb ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__sigpoll_33 {
   long si_band ;
   int si_fd ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__sigsys_34 {
   void *_call_addr ;
   int _syscall ;
   unsigned int _arch ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
union __anonunion__sifields_27 {
   int _pad[128UL / sizeof(int ) - 4UL] ;
   struct __anonstruct__kill_28 _kill ;
   struct __anonstruct__timer_29 _timer ;
   struct __anonstruct__rt_30 _rt ;
   struct __anonstruct__sigchld_31 _sigchld ;
   struct __anonstruct__sigfault_32 _sigfault ;
   struct __anonstruct__sigpoll_33 _sigpoll ;
   struct __anonstruct__sigsys_34 _sigsys ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct_siginfo_t_26 {
   int si_signo ;
   int si_errno ;
   int si_code ;
   union __anonunion__sifields_27 _sifields ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
typedef struct __anonstruct_siginfo_t_26 siginfo_t;
#line 24 "/usr/include/x86_64-linux-gnu/bits/sigaction.h"
union __anonunion___sigaction_handler_46 {
   void (*sa_handler)(int  ) ;
   void (*sa_sigaction)(int  , siginfo_t * , void * ) ;
};
#line 24 "/usr/include/x86_64-linux-gnu/bits/sigaction.h"
struct sigaction {
   union __anonunion___sigaction_handler_46 __sigaction_handler ;
   __sigset_t sa_mask ;
   int sa_flags ;
   void (*sa_restorer)(void) ;
};
#line 43 "/usr/include/x86_64-linux-gnu/bits/uio.h"
struct iovec {
   void *iov_base ;
   size_t iov_len ;
};
#line 224 "/usr/include/x86_64-linux-gnu/bits/socket.h"
struct msghdr {
   void *msg_name ;
   socklen_t msg_namelen ;
   struct iovec *msg_iov ;
   size_t msg_iovlen ;
   void *msg_control ;
   size_t msg_controllen ;
   int msg_flags ;
};
#line 242 "/usr/include/x86_64-linux-gnu/bits/socket.h"
struct cmsghdr {
   size_t cmsg_len ;
   int cmsg_level ;
   int cmsg_type ;
   unsigned char __cmsg_data[] ;
};
#line 127 "/usr/include/x86_64-linux-gnu/bits/in.h"
struct in_pktinfo {
   int ipi_ifindex ;
   struct in_addr ipi_spec_dst ;
   struct in_addr ipi_addr ;
};
#line 31 "/usr/include/x86_64-linux-gnu/bits/setjmp.h"
typedef long __jmp_buf[8];
#line 534 "/usr/include/pthread.h"
struct __anonstruct___cancel_jmp_buf_38 {
   __jmp_buf __cancel_jmp_buf ;
   int __mask_was_saved ;
};
#line 534 "/usr/include/pthread.h"
struct __anonstruct___pthread_unwind_buf_t_37 {
   struct __anonstruct___cancel_jmp_buf_38 __cancel_jmp_buf[1] ;
   void *__pad[4] ;
};
#line 534 "/usr/include/pthread.h"
typedef struct __anonstruct___pthread_unwind_buf_t_37  __attribute__((__aligned__)) __pthread_unwind_buf_t;
#line 753
struct __jmp_buf_tag;
#line 118 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/list.h"
struct llistnode_s {
   struct llistnode_s *next ;
   char *data[0] ;
};
#line 123 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/list.h"
struct __anonstruct_llist_76 {
   struct llistnode_s *first ;
   struct llistnode_s *last ;
};
#line 123 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/list.h"
typedef struct __anonstruct_llist_76 llist;
#line 90 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/dns_answer.c"
union __anonunion_pkt_info_t_113 {
   struct in_pktinfo pi4 ;
};
#line 90 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/dns_answer.c"
typedef union __anonunion_pkt_info_t_113 pkt_info_t;
#line 104 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/dns_answer.c"
union __anonunion_addr_115 {
   struct sockaddr_in sin4 ;
};
#line 104 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/dns_answer.c"
struct __anonstruct_udp_buf_t_114 {
   union __anonunion_addr_115 addr ;
   pkt_info_t pi ;
   int sock ;
   int proto ;
   size_t len ;
   unsigned char buf[0] ;
};
#line 104 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/dns_answer.c"
typedef struct __anonstruct_udp_buf_t_114 udp_buf_t;
#line 128 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/dns_answer.c"
struct __anonstruct_dns_queryel_t_116 {
   unsigned short qtype ;
   unsigned short qclass ;
   unsigned char query[0] ;
};
#line 128 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/dns_answer.c"
typedef struct __anonstruct_dns_queryel_t_116 dns_queryel_t;
#line 139 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/dns_answer.c"
struct __anonstruct_sva_t_117 {
   unsigned short tp ;
   unsigned short dlen ;
   unsigned char nm[0] ;
};
#line 139 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/dns_answer.c"
typedef struct __anonstruct_sva_t_117 sva_t;
#line 481 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/dns_answer.c"
struct rre_s {
   unsigned short tp ;
   unsigned short tsz ;
   uint32_t ttl ;
   unsigned char tnm[0] ;
};
#line 481 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/dns_answer.c"
typedef struct rre_s rr_ext_t;
#line 1540 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/dns_answer.c"
union __anonunion_sin_118 {
   struct sockaddr_in sin4 ;
};
#line 1970 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/dns_answer.c"
union __anonunion_sin_119___0 {
   struct sockaddr_in sin4 ;
};
#line 136 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __rlim_t;
#line 31 "/usr/include/x86_64-linux-gnu/bits/resource.h"
enum __rlimit_resource {
    RLIMIT_CPU = 0,
    RLIMIT_FSIZE = 1,
    RLIMIT_DATA = 2,
    RLIMIT_STACK = 3,
    RLIMIT_CORE = 4,
    __RLIMIT_RSS = 5,
    RLIMIT_NOFILE = 7,
    __RLIMIT_OFILE = 7,
    RLIMIT_AS = 9,
    __RLIMIT_NPROC = 6,
    __RLIMIT_MEMLOCK = 8,
    __RLIMIT_LOCKS = 10,
    __RLIMIT_SIGPENDING = 11,
    __RLIMIT_MSGQUEUE = 12,
    __RLIMIT_NICE = 13,
    __RLIMIT_RTPRIO = 14,
    __RLIMIT_RTTIME = 15,
    __RLIMIT_NLIMITS = 16,
    __RLIM_NLIMITS = 16
} ;
#line 131 "/usr/include/x86_64-linux-gnu/bits/resource.h"
typedef __rlim_t rlim_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/resource.h"
struct rlimit {
   rlim_t rlim_cur ;
   rlim_t rlim_max ;
};
#line 38 "/usr/include/x86_64-linux-gnu/sys/resource.h"
typedef enum __rlimit_resource __rlimit_resource_t;
#line 154 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/servers.c"
union __anonunion_129 {
   int __in ;
   int __i ;
};
#line 161 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/servers.c"
union __anonunion_130 {
   int __in ;
   int __i ;
};
#line 160 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/servers.c"
union __anonunion_131 {
   int __in ;
   int __i ;
};
#line 153 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/servers.c"
union __anonunion_132 {
   int __in ;
   int __i ;
};
/* compiler builtin: 
   void *__builtin_alloca(unsigned long  ) ;  */
#line 113 "/usr/include/x86_64-linux-gnu/sys/socket.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) socket)(int __domain ,
                                                                             int __type ,
                                                                             int __protocol ) ;
#line 41 "/usr/include/x86_64-linux-gnu/sys/ioctl.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) ioctl)(int __fd ,
                                                                            unsigned long __request 
                                                                            , ...) ;
#line 147 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strncmp)(char const   *__s1 ,
                                                                                                char const   *__s2 ,
                                                                                                size_t __n )  __attribute__((__pure__)) ;
#line 399
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 413
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) strerror)(int __errnum ) ;
#line 569
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) stpcpy)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 577
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) stpncpy)(char * __restrict  __dest ,
                                                                                                  char const   * __restrict  __src ,
                                                                                                  size_t __n ) ;
#line 353 "/usr/include/unistd.h"
extern int close(int __fd ) ;
#line 237 "/usr/include/stdio.h"
extern int fclose(FILE *__stream ) ;
#line 272
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 425
extern int fscanf(FILE * __restrict  __stream , char const   * __restrict  __format 
                  , ...) ;
#line 50 "/usr/include/x86_64-linux-gnu/bits/errno.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
#line 232 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/test/../helpers.h"
__inline static int ( __attribute__((__always_inline__)) strncp)(char *dst , char const   *src ,
                                                                 size_t dstsz ) ;
#line 234 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/test/../helpers.h"
__inline static int ( __attribute__((__always_inline__)) strncp)(char *dst , char const   *src ,
                                                                 size_t dstsz ) 
{ 
  char *p ;
  char *tmp ;

  {
  {
#line 240
  tmp = stpncpy((char */* __restrict  */)dst, (char const   */* __restrict  */)src,
                dstsz);
#line 240
  p = tmp;
  }
#line 241
  if ((unsigned long )p < (unsigned long )(dst + dstsz)) {
#line 241
    return (1);
  }
#line 242
  *(p - 1) = (char )'\000';
#line 243
  return (0);
}
}
#line 28 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/test/../netdev.h"
int if_up(char *devname ) ;
#line 29
int dev_up(char *ifname , char *devname ) ;
#line 30
int is_local_addr(pdnsd_a *a ) ;
#line 127 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) kill)(__pid_t __pid ,
                                                                           int __sig ) ;
#line 50 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/test/../error.h"
void ( /* format attribute */  log_message)(int prior , char const   *s  , ...) ;
#line 86 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/test/../netdev.c"
static unsigned long volatile   socketopen_errs  =    (unsigned long volatile   )0;
#line 96 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/test/../netdev.c"
static unsigned long volatile   isdn_errs  =    (unsigned long volatile   )0;
#line 135 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/test/../netdev.c"
int dev_up(char *ifname , char *devname ) 
{ 
  FILE *fd ;
  int pidi ;
  int pidd ;
  int rv ;
  size_t tmp ;
  char *path ;
  unsigned long __lengthofpath ;
  void *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  size_t tmp___4 ;
  char *path___0 ;
  unsigned long __lengthofpath___0 ;
  void *tmp___5 ;
  char *tmp___6 ;
  int tmp___7 ;
  int *tmp___8 ;
  int tmp___9 ;

  {
  {
#line 141
  tmp = strlen((char const   *)ifname);
#line 141
  __lengthofpath = sizeof("/var/run/.pid") + tmp;
#line 141
  tmp___0 = __builtin_alloca(sizeof(*path) * __lengthofpath);
#line 141
  path = (char *)tmp___0;
#line 142
  tmp___1 = stpcpy((char */* __restrict  */)path, (char const   */* __restrict  */)"/var/run/");
#line 142
  tmp___2 = stpcpy((char */* __restrict  */)tmp___1, (char const   */* __restrict  */)ifname);
#line 142
  stpcpy((char */* __restrict  */)tmp___2, (char const   */* __restrict  */)".pid");
#line 143
  fd = fopen((char const   */* __restrict  */)path, (char const   */* __restrict  */)"r");
  }
#line 143
  if ((unsigned long )fd == (unsigned long )((void *)0)) {
#line 144
    return (0);
  }
  {
#line 146
  tmp___3 = fscanf((FILE */* __restrict  */)fd, (char const   */* __restrict  */)"%d",
                   & pidi);
  }
#line 146
  if (tmp___3 != 1) {
    {
#line 147
    fclose(fd);
    }
#line 148
    return (0);
  }
  {
#line 150
  fclose(fd);
#line 154
  tmp___4 = strlen((char const   *)devname);
#line 154
  __lengthofpath___0 = sizeof("/var/lock/LCK..") + tmp___4;
#line 154
  tmp___5 = __builtin_alloca(sizeof(*path___0) * __lengthofpath___0);
#line 154
  path___0 = (char *)tmp___5;
#line 155
  tmp___6 = stpcpy((char */* __restrict  */)path___0, (char const   */* __restrict  */)"/var/lock/LCK..");
#line 155
  stpcpy((char */* __restrict  */)tmp___6, (char const   */* __restrict  */)devname);
#line 156
  fd = fopen((char const   */* __restrict  */)path___0, (char const   */* __restrict  */)"r");
  }
#line 156
  if ((unsigned long )fd == (unsigned long )((void *)0)) {
#line 157
    return (0);
  }
  {
#line 159
  tmp___7 = fscanf((FILE */* __restrict  */)fd, (char const   */* __restrict  */)"%d",
                   & pidd);
  }
#line 159
  if (tmp___7 != 1) {
    {
#line 160
    fclose(fd);
    }
#line 161
    return (0);
  }
  {
#line 163
  fclose(fd);
  }
#line 166
  if (pidi != pidd) {
#line 167
    return (0);
  }
  {
#line 169
  rv = kill(pidi, 0);
  }
#line 170
  if (rv == 0) {
#line 170
    tmp___9 = 1;
  } else
#line 170
  if (rv == -1) {
    {
#line 170
    tmp___8 = __errno_location();
    }
#line 170
    if (*tmp___8 != 3) {
#line 170
      tmp___9 = 1;
    } else {
#line 170
      tmp___9 = 0;
    }
  } else {
#line 170
    tmp___9 = 0;
  }
#line 170
  return (tmp___9);
}
}
#line 186 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/test/../netdev.c"
int if_up(char *devname ) 
{ 
  int sock ;
  struct ifreq ifr ;
  unsigned int devnamelen ;
  size_t tmp ;
  unsigned long volatile   tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
  {
#line 191
  tmp = strlen((char const   *)devname);
#line 191
  devnamelen = (unsigned int )tmp;
  }
#line 192
  if (devnamelen > 4U) {
#line 192
    if (devnamelen <= 6U) {
      {
#line 192
      tmp___1 = strncmp((char const   *)devname, "ippp", (size_t )4);
      }
#line 192
      if (tmp___1 == 0) {
#line 200
        tmp___0 = isdn_errs;
#line 200
        isdn_errs += (unsigned long volatile   )1;
#line 200
        if (tmp___0 == (unsigned long volatile   )0) {
          {
#line 201
          log_message(4, "An ippp? device was specified for uptest, but pdnsd was compiled without ISDN support.");
#line 202
          log_message(4, "The uptest result will be wrong.");
          }
        }
      }
    }
  }
  {
#line 208
  sock = socket(2, 2, 17);
  }
#line 208
  if (sock == -1) {
#line 209
    socketopen_errs += (unsigned long volatile   )1;
#line 209
    if (socketopen_errs <= (unsigned long volatile   )10) {
      {
#line 210
      tmp___2 = __errno_location();
#line 210
      tmp___3 = strerror(*tmp___2);
#line 210
      log_message(4, "Could not open socket in if_up(): %s", tmp___3);
      }
    }
#line 212
    return (0);
  }
  {
#line 214
  strncp(ifr.ifr_ifrn.ifrn_name, (char const   *)devname, (size_t )16);
#line 215
  tmp___4 = ioctl(sock, 35091UL, & ifr);
  }
#line 215
  if (tmp___4 == -1) {
    {
#line 216
    close(sock);
    }
#line 217
    return (0);
  }
  {
#line 219
  close(sock);
  }
#line 220
  if ((int )ifr.ifr_ifru.ifru_flags & 1) {
#line 220
    if ((int )ifr.ifr_ifru.ifru_flags & 64) {
#line 220
      tmp___5 = 1;
    } else {
#line 220
      tmp___5 = 0;
    }
  } else {
#line 220
    tmp___5 = 0;
  }
#line 220
  return (tmp___5);
}
}
#line 225 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/test/../netdev.c"
int is_local_addr(pdnsd_a *a ) 
{ 
  int res ;
  int i ;
  int sock ;
  struct ifreq ifr ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 227
  res = 0;
#line 233
  sock = socket(2, 2, 17);
  }
#line 233
  if (sock == -1) {
#line 234
    socketopen_errs += (unsigned long volatile   )1;
#line 234
    if (socketopen_errs <= (unsigned long volatile   )10) {
      {
#line 235
      tmp = __errno_location();
#line 235
      tmp___0 = strerror(*tmp);
#line 235
      log_message(4, "Could not open socket in is_local_addr(): %s", tmp___0);
      }
    }
#line 237
    return (0);
  }
#line 239
  i = 1;
  {
#line 239
  while (1) {
    while_continue: /* CIL Label */ ;
#line 239
    if (! (i < 255)) {
#line 239
      goto while_break;
    }
    {
#line 240
    ifr.ifr_ifru.ifru_ivalue = i;
#line 241
    tmp___1 = ioctl(sock, 35088UL, & ifr);
    }
#line 241
    if (tmp___1 == -1) {
#line 243
      goto __Cont;
    }
    {
#line 245
    tmp___2 = ioctl(sock, 35093UL, & ifr);
    }
#line 245
    if (tmp___2 == -1) {
#line 246
      goto __Cont;
    }
#line 248
    if (((struct sockaddr_in *)(& ifr.ifr_ifru.ifru_addr))->sin_addr.s_addr == a->ipv4.s_addr) {
#line 249
      res = 1;
#line 250
      goto while_break;
    }
    __Cont: /* CIL Label */ 
#line 239
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 253
  close(sock);
  }
#line 296
  return (res);
}
}
#line 543 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 362 "/usr/include/stdio.h"
extern int printf(char const   * __restrict  __format  , ...) ;
#line 41 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/test/../conff.h"
short debug_p ;
#line 46 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/test/../conff.h"
pthread_t main_thrid  ;
#line 176 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/test/../conff.h"
globparm_t global  ;
#line 9 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/test/if_up.c"
short daemon_p  =    (short)0;
#line 11 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/test/if_up.c"
short debug_p  =    (short)0;
#line 13 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/test/if_up.c"
short verbosity  =    (short)0;
#line 20 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/test/if_up.c"
pthread_t servstat_thrid  ;
#line 21 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/test/if_up.c"
int volatile   signal_interrupt  ;
#line 23 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/test/if_up.c"
FILE *dbg_file  ;
#line 28 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/test/if_up.c"
int main(int argc , char **argv ) 
{ 
  char const   *tmp___0 ;
  int tmp___1 ;

  {
#line 30
  if (argc != 2) {
    {
#line 31
    printf((char const   */* __restrict  */)"Usage: %s <interface>\n", *(argv + 0));
#line 32
    exit(1);
    }
  }
  {
#line 34
  tmp___1 = if_up(*(argv + 1));
  }
#line 34
  if (tmp___1) {
#line 34
    tmp___0 = "up";
  } else {
#line 34
    tmp___0 = "down";
  }
  {
#line 34
  printf((char const   */* __restrict  */)"if_up: %s - %s\n", *(argv + 1), tmp___0);
  }
#line 35
  return (0);
}
}
#line 57 "/usr/include/x86_64-linux-gnu/sys/poll.h"
extern int poll(struct pollfd *__fds , nfds_t __nfds , int __timeout ) ;
#line 46 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memcpy)(void * __restrict  __dest ,
                                                                                                 void const   * __restrict  __src ,
                                                                                                 size_t __n ) ;
#line 66
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memset)(void *__s ,
                                                                                               int __c ,
                                                                                               size_t __n ) ;
#line 69
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) memcmp)(void const   *__s1 ,
                                                                                               void const   *__s2 ,
                                                                                               size_t __n )  __attribute__((__pure__)) ;
#line 163 "/usr/include/x86_64-linux-gnu/sys/socket.h"
extern ssize_t sendto(int __fd , void const   *__buf , size_t __n , int __flags ,
                      struct sockaddr  const  * __restrict  __addr , socklen_t __addr_len ) ;
#line 174
extern ssize_t recvfrom(int __fd , void * __restrict  __buf , size_t __n , int __flags ,
                        struct sockaddr * __restrict  __addr , socklen_t * __restrict  __addr_len ) ;
#line 226
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) setsockopt)(int __fd ,
                                                                                 int __level ,
                                                                                 int __optname ,
                                                                                 void const   *__optval ,
                                                                                 socklen_t __optlen ) ;
#line 375 "/usr/include/netinet/in.h"
extern  __attribute__((__nothrow__)) uint16_t ( __attribute__((__leaf__)) ntohs)(uint16_t __netshort )  __attribute__((__const__)) ;
#line 379
extern  __attribute__((__nothrow__)) uint16_t ( __attribute__((__leaf__)) htons)(uint16_t __hostshort )  __attribute__((__const__)) ;
#line 30 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/test/../icmp.h"
int volatile   ping_isocket ;
#line 34
void init_ping_socket(void) ;
#line 41
int ping(pdnsd_a *addr , int timeout , int rep ) ;
#line 192 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) time_t ( __attribute__((__leaf__)) time)(time_t *__timer ) ;
#line 286 "/usr/include/pthread.h"
extern  __attribute__((__nothrow__)) pthread_t ( __attribute__((__leaf__)) pthread_self)(void)  __attribute__((__const__)) ;
#line 289
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) pthread_equal)(pthread_t __thread1 ,
                                                                                    pthread_t __thread2 )  __attribute__((__const__)) ;
#line 38 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/test/../pdnsd_assert.h"
void pdnsd_exit(void) ;
#line 168 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/test/../helpers.h"
unsigned short get_rand16(void) ;
#line 74 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/test/../error.h"
void ( /* format attribute */  debug_msg)(int c , char const   *fmt  , ...) ;
#line 61 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/test/../servers.h"
__inline static int ( __attribute__((__always_inline__)) is_interrupted_servstat_thread)(void) ;
#line 63 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/test/../servers.h"
__inline static int ( __attribute__((__always_inline__)) is_interrupted_servstat_thread)(void) 
{ 
  pthread_t tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 65
  if (signal_interrupt) {
    {
#line 65
    tmp = pthread_self();
#line 65
    tmp___0 = pthread_equal(tmp, servstat_thrid);
    }
#line 65
    if (tmp___0) {
#line 65
      tmp___1 = 1;
    } else {
#line 65
      tmp___1 = 0;
    }
  } else {
#line 65
    tmp___1 = 0;
  }
#line 65
  return (tmp___1);
}
}
#line 69 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/test/../icmp.c"
static unsigned long volatile   icmp_errs  =    (unsigned long volatile   )0;
#line 74 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/test/../icmp.c"
int volatile   ping_isocket  =    (int volatile   )-1;
#line 114 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/test/../icmp.c"
void init_ping_socket(void) 
{ 
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;

  {
  {
#line 116
  tmp___1 = socket(2, 3, 1);
#line 116
  ping_isocket = (int volatile   )tmp___1;
  }
#line 116
  if (ping_isocket == (int volatile   )-1) {
    {
#line 117
    tmp = __errno_location();
#line 117
    tmp___0 = strerror(*tmp);
#line 117
    log_message(4, "icmp ping: socket() failed: %s", tmp___0);
    }
  }
#line 128
  return;
}
}
#line 136 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/test/../icmp.c"
static int icmp4_errcmp(char *packet , int plen , struct in_addr *to , char *errmsg ,
                        int elen , int errtype ) 
{ 
  struct iphdr iph ;
  struct icmphdr icmph ;
  struct iphdr eiph ;
  char *data ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 144
  if ((unsigned long )elen < sizeof(struct iphdr )) {
#line 145
    return (0);
  }
  {
#line 146
  memcpy((void */* __restrict  */)(& iph), (void const   */* __restrict  */)errmsg,
         sizeof(iph));
  }
#line 147
  if ((int )iph.protocol != 1) {
#line 148
    return (0);
  } else
#line 147
  if ((unsigned long )elen < (unsigned long )(iph.ihl * 4U + 8U) + sizeof(eiph)) {
#line 148
    return (0);
  }
#line 149
  if (! (sizeof(icmph) >= 8UL)) {
    {
#line 149
    log_message(3, "%s:%d: %s", "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/test/../icmp.c",
                149, "icmp4_errcmp: ICMP_BASEHDR_LEN botched");
#line 149
    pdnsd_exit();
    }
  }
  {
#line 150
  memcpy((void */* __restrict  */)(& icmph), (void const   */* __restrict  */)(errmsg + iph.ihl * 4U),
         (size_t )8);
#line 151
  memcpy((void */* __restrict  */)(& eiph), (void const   */* __restrict  */)((errmsg + iph.ihl * 4U) + 8),
         sizeof(eiph));
  }
#line 152
  if ((unsigned int )elen < ((iph.ihl * 4U + 8U) + eiph.ihl * 4U) + 8U) {
#line 153
    return (0);
  }
#line 154
  data = ((errmsg + iph.ihl * 4U) + 8) + eiph.ihl * 4U;
#line 155
  if ((int )icmph.type == errtype) {
    {
#line 155
    tmp = memcmp((void const   *)(& to->s_addr), (void const   *)(& eiph.daddr), sizeof(to->s_addr));
    }
#line 155
    if (tmp == 0) {
#line 155
      if (plen < 8) {
#line 155
        tmp___0 = plen;
      } else {
#line 155
        tmp___0 = 8;
      }
      {
#line 155
      tmp___1 = memcmp((void const   *)data, (void const   *)packet, (size_t )tmp___0);
      }
#line 155
      if (tmp___1 == 0) {
#line 155
        tmp___2 = 1;
      } else {
#line 155
        tmp___2 = 0;
      }
    } else {
#line 155
      tmp___2 = 0;
    }
  } else {
#line 155
    tmp___2 = 0;
  }
#line 155
  return (tmp___2);
}
}
#line 160 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/test/../icmp.c"
static int ping4(struct in_addr addr , int timeout , int rep ) 
{ 
  int i ;
  int isock ;
  struct icmp_filter f ;
  unsigned short id ;
  unsigned short tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  struct sockaddr_in from ;
  struct sockaddr_in to ;
  struct icmphdr icmpd ;
  unsigned long sum ;
  uint16_t *ptr ;
  long tm ;
  long tpassed ;
  int j ;
  uint16_t *tmp___3 ;
  int *tmp___4 ;
  char *tmp___5 ;
  ssize_t tmp___6 ;
  int psres ;
  struct pollfd pfd ;
  int tmp___7 ;
  long tmp___8 ;
  int *tmp___9 ;
  char *tmp___10 ;
  int *tmp___11 ;
  int tmp___12 ;
  char buf[1024] ;
  socklen_t sl ;
  int len ;
  struct iphdr iph ;
  struct icmphdr icmpp ;
  uint16_t tmp___13 ;
  time_t tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  uint16_t tmp___17 ;
  uint16_t tmp___18 ;
  ssize_t tmp___19 ;
  time_t tmp___20 ;

  {
  {
#line 167
  tmp = get_rand16();
#line 167
  id = tmp;
#line 169
  isock = (int )ping_isocket;
#line 178
  f.data = 4294965238U;
#line 179
  tmp___2 = setsockopt(isock, 255, 1, (void const   *)(& f), (socklen_t )sizeof(f));
  }
#line 179
  if (tmp___2 == -1) {
#line 180
    icmp_errs += (unsigned long volatile   )1;
#line 180
    if (icmp_errs <= (unsigned long volatile   )10) {
      {
#line 181
      tmp___0 = __errno_location();
#line 181
      tmp___1 = strerror(*tmp___0);
#line 181
      log_message(4, "icmp ping: setsockopt() failed: %s", tmp___1);
      }
    }
#line 183
    return (-1);
  }
#line 187
  i = 0;
  {
#line 187
  while (1) {
    while_continue: /* CIL Label */ ;
#line 187
    if (! (i < rep)) {
#line 187
      goto while_break;
    }
    {
#line 195
    icmpd.type = (__u8 )8;
#line 196
    icmpd.code = (__u8 )0;
#line 197
    icmpd.checksum = (__sum16 )0;
#line 198
    icmpd.un.echo.id = htons(id);
#line 199
    icmpd.un.echo.sequence = htons((uint16_t )i);
#line 203
    ptr = (uint16_t *)(& icmpd);
#line 204
    sum = 0UL;
#line 206
    j = 0;
    }
    {
#line 206
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 206
      if (! (j < 4)) {
#line 206
        goto while_break___0;
      }
#line 207
      tmp___3 = ptr;
#line 207
      ptr ++;
#line 207
      sum += (unsigned long )*tmp___3;
#line 206
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 209
    sum = (sum >> 16) + (sum & 65535UL);
#line 210
    sum += sum >> 16;
#line 211
    icmpd.checksum = (__sum16 )(~ sum);
#line 213
    memset((void *)(& to), 0, sizeof(to));
#line 214
    to.sin_family = (sa_family_t )2;
#line 215
    to.sin_port = (in_port_t )0;
#line 216
    to.sin_addr = addr;
#line 218
    tmp___6 = sendto(isock, (void const   *)(& icmpd), (size_t )8, 0, (struct sockaddr  const  */* __restrict  */)((struct sockaddr *)(& to)),
                     (socklen_t )sizeof(to));
    }
#line 218
    if (tmp___6 == -1L) {
#line 219
      icmp_errs += (unsigned long volatile   )1;
#line 219
      if (icmp_errs <= (unsigned long volatile   )10) {
        {
#line 220
        tmp___4 = __errno_location();
#line 220
        tmp___5 = strerror(*tmp___4);
#line 220
        log_message(4, "icmp ping: sendto() failed: %s.", tmp___5);
        }
      }
#line 222
      return (-1);
    }
    {
#line 225
    tm = time((time_t *)((void *)0));
#line 225
    tpassed = 0L;
    }
    {
#line 226
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 248
      pfd.fd = isock;
#line 249
      pfd.events = (short)1;
#line 254
      tmp___7 = is_interrupted_servstat_thread();
      }
#line 254
      if (tmp___7) {
#line 255
        if (debug_p) {
          {
#line 255
          debug_msg(0, "server status thread interrupted.\n");
          }
        }
#line 256
        return (-1);
      }
#line 258
      if ((long )timeout > tpassed) {
#line 258
        tmp___8 = ((long )timeout - tpassed) * 1000L;
      } else {
#line 258
        tmp___8 = 0L;
      }
      {
#line 258
      psres = poll(& pfd, (nfds_t )1, (int )tmp___8);
      }
#line 261
      if (psres < 0) {
        {
#line 262
        tmp___11 = __errno_location();
        }
#line 262
        if (*tmp___11 == 4) {
          {
#line 262
          tmp___12 = is_interrupted_servstat_thread();
          }
#line 262
          if (tmp___12) {
#line 263
            if (debug_p) {
              {
#line 263
              debug_msg(0, "poll/select interrupted in server status thread.\n");
              }
            }
          } else {
#line 262
            goto _L;
          }
        } else {
          _L: /* CIL Label */ 
#line 265
          icmp_errs += (unsigned long volatile   )1;
#line 265
          if (icmp_errs <= (unsigned long volatile   )10) {
            {
#line 266
            tmp___9 = __errno_location();
#line 266
            tmp___10 = strerror(*tmp___9);
#line 266
            log_message(4, "poll/select failed: %s", tmp___10);
            }
          }
        }
#line 268
        return (-1);
      }
#line 270
      if (psres == 0) {
#line 271
        goto while_break___1;
      }
#line 276
      if ((int )pfd.revents & 9) {
        {
#line 280
        sl = (socklen_t )sizeof(from);
#line 283
        tmp___19 = recvfrom(isock, (void */* __restrict  */)(& buf), sizeof(buf),
                            0, (struct sockaddr */* __restrict  */)((struct sockaddr *)(& from)),
                            (socklen_t */* __restrict  */)(& sl));
#line 283
        len = (int )tmp___19;
        }
#line 283
        if (len != -1) {
#line 284
          if ((unsigned long )len > sizeof(struct iphdr )) {
            {
#line 287
            memcpy((void */* __restrict  */)(& iph), (void const   */* __restrict  */)(buf),
                   sizeof(iph));
            }
#line 288
            if ((unsigned int )len - iph.ihl * 4U >= 8U) {
              {
#line 291
              memcpy((void */* __restrict  */)(& icmpp), (void const   */* __restrict  */)((uint32_t *)(buf) + iph.ihl),
                     sizeof(icmpp));
              }
#line 292
              if (iph.saddr == addr.s_addr) {
#line 292
                if ((int )icmpp.type == 0) {
                  {
#line 292
                  tmp___17 = ntohs(icmpp.un.echo.id);
                  }
#line 292
                  if ((int )tmp___17 == (int )id) {
                    {
#line 292
                    tmp___18 = ntohs(icmpp.un.echo.sequence);
                    }
#line 292
                    if ((int )tmp___18 <= i) {
                      {
#line 294
                      tmp___13 = ntohs(icmpp.un.echo.sequence);
#line 294
                      tmp___14 = time((time_t *)((void *)0));
                      }
#line 294
                      return ((int )((time_t )((i - (int )tmp___13) * timeout) + (tmp___14 - tm)));
                    } else {
#line 292
                      goto _L___2;
                    }
                  } else {
#line 292
                    goto _L___2;
                  }
                } else {
#line 292
                  goto _L___2;
                }
              } else {
                _L___2: /* CIL Label */ 
                {
#line 297
                tmp___15 = icmp4_errcmp((char *)(& icmpd), 8, & to.sin_addr, buf,
                                        len, 3);
                }
#line 297
                if (tmp___15) {
#line 299
                  return (-1);
                } else {
                  {
#line 297
                  tmp___16 = icmp4_errcmp((char *)(& icmpd), 8, & to.sin_addr, buf,
                                          len, 11);
                  }
#line 297
                  if (tmp___16) {
#line 299
                    return (-1);
                  }
                }
              }
            }
          }
        } else {
#line 305
          return (-1);
        }
      } else {
#line 309
        icmp_errs += (unsigned long volatile   )1;
#line 309
        if (icmp_errs <= (unsigned long volatile   )10) {
          {
#line 310
          log_message(3, "Unhandled poll/select event in ping4() at %s, line %d.",
                      "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/test/../icmp.c",
                      310);
          }
        }
#line 312
        return (-1);
      }
      {
#line 314
      tmp___20 = time((time_t *)((void *)0));
#line 314
      tpassed = tmp___20 - tm;
      }
#line 226
      if (! (tpassed < (long )timeout)) {
#line 226
        goto while_break___1;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
#line 187
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 317
  return (-1);
}
}
#line 514 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/test/../icmp.c"
int ping(pdnsd_a *addr , int timeout , int rep ) 
{ 
  int tmp ;

  {
#line 517
  if (ping_isocket == (int volatile   )-1) {
#line 518
    return (-1);
  }
  {
#line 522
  timeout /= 10;
#line 526
  tmp = ping4(addr->ipv4, timeout, rep);
  }
#line 526
  return (tmp);
#line 539
  return (-1);
}
}
/* compiler builtin: 
   void __builtin_va_start(__builtin_va_list  ) ;  */
/* compiler builtin: 
   void __builtin_va_end(__builtin_va_list  ) ;  */
#line 170 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 242
extern int fflush(FILE *__stream ) ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 371
extern int vfprintf(FILE * __restrict  __s , char const   * __restrict  __format ,
                    __gnuc_va_list __arg ) ;
#line 573
extern int fputc(int __c , FILE *__stream ) ;
#line 175 "/usr/include/x86_64-linux-gnu/sys/syslog.h"
extern void closelog(void) ;
#line 181
extern void openlog(char const   *__ident , int __option , int __facility ) ;
#line 200
extern void ( /* format attribute */  vsyslog)(int __pri , char const   *__fmt , __gnuc_va_list __ap ) ;
#line 205 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__leaf__)) strftime)(char * __restrict  __s ,
                                                                                  size_t __maxsize ,
                                                                                  char const   * __restrict  __format ,
                                                                                  struct tm  const  * __restrict  __tp ) ;
#line 254
extern  __attribute__((__nothrow__)) struct tm *( __attribute__((__leaf__)) localtime_r)(time_t const   * __restrict  __timer ,
                                                                                         struct tm * __restrict  __tp ) ;
#line 784 "/usr/include/pthread.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_mutex_unlock)(pthread_mutex_t *__mutex ) ;
#line 1130
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) pthread_getspecific)(pthread_key_t __key ) ;
#line 236 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strchr)(char const   *__s ,
                                                                                               int __c )  __attribute__((__pure__)) ;
#line 140 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/test/../thread.h"
pthread_key_t thrid_key ;
#line 39 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/test/../helpers.h"
int softlock_mutex(pthread_mutex_t *mutex ) ;
#line 39 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/test/../error.h"
short volatile   use_log_lock ;
#line 42
void crash_msg(char *msg ) ;
#line 36 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/test/../error.c"
pthread_mutex_t loglock  =    {{0, 0U, 0, 0U, 0, (short)0, (short)0, {(struct __pthread_internal_list *)0, (struct __pthread_internal_list *)0}}};
#line 37 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/test/../error.c"
short volatile   use_log_lock  =    (short volatile   )0;
#line 52 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/test/../error.c"
void crash_msg(char *msg ) 
{ 


  {
  {
#line 54
  log_message(3, "%s", msg);
#line 55
  log_message(3, "pdnsd probably crashed due to a bug. Please consider sending a bug");
#line 56
  log_message(3, "report to p.a.rombouts@home.nl or tmoestl@gmx.net");
  }
#line 57
  return;
}
}
#line 62 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/test/../error.c"
void ( /* format attribute */  log_message)(int prior , char const   *s  , ...) 
{ 
  int gotlock ;
  va_list va ;
  FILE *f ;
  char ts[sizeof("* 12/31 23:59:59| ")] ;
  time_t tt ;
  time_t tmp ;
  struct tm tm ;
  struct tm *tmp___0 ;
  size_t tmp___1 ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;
  char const   *tmp___4 ;
  char const   *p ;
  char *tmp___5 ;

  {
#line 64
  gotlock = 0;
#line 68
  if (use_log_lock) {
    {
#line 69
    gotlock = softlock_mutex(& loglock);
    }
#line 72
    if (! gotlock) {
#line 72
      if (prior >= 6) {
#line 73
        return;
      }
    }
  }
#line 75
  if (global.daemon) {
    {
#line 76
    openlog("pdnsd", 1, 3 << 3);
#line 77
    __builtin_va_start(va, s);
#line 78
    vsyslog(prior, s, va);
#line 79
    __builtin_va_end(va);
#line 80
    closelog();
    }
  } else {
#line 83
    f = stderr;
#line 85
    goto printtofile;
  }
#line 87
  if (debug_p) {
#line 88
    f = dbg_file;
    printtofile: 
    {
#line 93
    tmp = time((time_t *)((void *)0));
#line 93
    tt = tmp;
#line 96
    tmp___0 = localtime_r((time_t const   */* __restrict  */)(& tt), (struct tm */* __restrict  */)(& tm));
    }
#line 96
    if (tmp___0) {
      {
#line 96
      tmp___1 = strftime((char */* __restrict  */)(ts), sizeof(ts), (char const   */* __restrict  */)"* %m/%d %T| ",
                         (struct tm  const  */* __restrict  */)(& tm));
      }
#line 96
      if (tmp___1 <= 0UL) {
#line 97
        ts[0] = (char)0;
      }
    } else {
#line 97
      ts[0] = (char)0;
    }
#line 98
    if (prior <= 2) {
#line 98
      tmp___4 = "critical";
    } else {
#line 98
      if (prior == 3) {
#line 98
        tmp___3 = "error";
      } else {
#line 98
        if (prior == 4) {
#line 98
          tmp___2 = "warning";
        } else {
#line 98
          tmp___2 = "info";
        }
#line 98
        tmp___3 = tmp___2;
      }
#line 98
      tmp___4 = tmp___3;
    }
    {
#line 98
    fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"%spdnsd: %s: ",
            ts, tmp___4);
#line 104
    __builtin_va_start(va, s);
#line 105
    vfprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)s, va);
#line 106
    __builtin_va_end(va);
#line 108
    tmp___5 = strchr(s, 0);
#line 108
    p = (char const   *)tmp___5;
    }
#line 109
    if (! p) {
      {
#line 110
      fputc('\n', f);
      }
    } else
#line 109
    if ((unsigned long )p == (unsigned long )s) {
      {
#line 110
      fputc('\n', f);
      }
    } else
#line 109
    if ((int const   )*(p - 1) != 10) {
      {
#line 110
      fputc('\n', f);
      }
    }
  }
#line 113
  if (gotlock) {
    {
#line 114
    pthread_mutex_unlock(& loglock);
    }
  }
#line 115
  return;
}
}
#line 120 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/test/../error.c"
void ( /* format attribute */  debug_msg)(int c , char const   *fmt  , ...) 
{ 
  va_list va ;
  char ts[sizeof("12/31 23:59:59")] ;
  time_t tt ;
  time_t tmp ;
  struct tm tm ;
  unsigned int *id ;
  void *tmp___0 ;
  struct tm *tmp___1 ;
  size_t tmp___2 ;

  {
#line 124
  if (! c) {
    {
#line 126
    tmp = time((time_t *)((void *)0));
#line 126
    tt = tmp;
#line 130
    tmp___1 = localtime_r((time_t const   */* __restrict  */)(& tt), (struct tm */* __restrict  */)(& tm));
    }
#line 130
    if (tmp___1) {
      {
#line 130
      tmp___2 = strftime((char */* __restrict  */)(ts), sizeof(ts), (char const   */* __restrict  */)"%m/%d %T",
                         (struct tm  const  */* __restrict  */)(& tm));
      }
#line 130
      if (tmp___2 > 0UL) {
        {
#line 131
        tmp___0 = pthread_getspecific(thrid_key);
#line 131
        id = (unsigned int *)tmp___0;
        }
#line 131
        if (id) {
          {
#line 132
          fprintf((FILE */* __restrict  */)dbg_file, (char const   */* __restrict  */)"%u %s| ",
                  *id, ts);
          }
        } else {
          {
#line 134
          fprintf((FILE */* __restrict  */)dbg_file, (char const   */* __restrict  */)"- %s| ",
                  ts);
          }
        }
      }
    }
  }
  {
#line 137
  __builtin_va_start(va, fmt);
#line 138
  vfprintf((FILE */* __restrict  */)dbg_file, (char const   */* __restrict  */)fmt,
           va);
#line 139
  __builtin_va_end(va);
#line 140
  fflush(dbg_file);
  }
#line 141
  return;
}
}
#line 71 "/usr/include/x86_64-linux-gnu/sys/time.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) gettimeofday)(struct timeval * __restrict  __tv ,
                                                                                                   __timezone_ptr_t __tz ) ;
#line 35 "/usr/include/x86_64-linux-gnu/bits/sigthread.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) pthread_kill)(pthread_t __threadid ,
                                                                                   int __signo ) ;
#line 321 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) long ( __attribute__((__leaf__)) random)(void) ;
#line 324
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) srandom)(unsigned int __seed ) ;
#line 79 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) unsigned short const   **( __attribute__((__leaf__)) __ctype_b_loc)(void)  __attribute__((__const__)) ;
#line 386 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int ( /* format attribute */  snprintf)(char * __restrict  __s ,
                                                                             size_t __maxlen ,
                                                                             char const   * __restrict  __format 
                                                                             , ...) ;
#line 390
extern  __attribute__((__nothrow__)) int ( /* format attribute */  vsnprintf)(char * __restrict  __s ,
                                                                              size_t __maxlen ,
                                                                              char const   * __restrict  __format ,
                                                                              __gnuc_va_list __arg ) ;
#line 366 "/usr/include/unistd.h"
extern ssize_t write(int __fd , void const   *__buf , size_t __n ) ;
#line 700
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) setuid)(__uid_t __uid ) ;
#line 717
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) setgid)(__gid_t __gid ) ;
#line 149 "/usr/include/pwd.h"
extern int getpwnam_r(char const   * __restrict  __name , struct passwd * __restrict  __resultbuf ,
                      char * __restrict  __buffer , size_t __buflen , struct passwd ** __restrict  __result ) ;
#line 201 "/usr/include/grp.h"
extern int initgroups(char const   *__user , __gid_t __group ) ;
#line 64 "/usr/include/arpa/inet.h"
extern  __attribute__((__nothrow__)) char const   *( __attribute__((__leaf__)) inet_ntop)(int __af ,
                                                                                          void const   * __restrict  __cp ,
                                                                                          char * __restrict  __buf ,
                                                                                          socklen_t __len ) ;
#line 73
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) inet_aton)(char const   *__cp ,
                                                                                struct in_addr *__inp ) ;
#line 334 "/usr/include/time.h"
extern int nanosleep(struct timespec  const  *__requested_time , struct timespec *__remaining ) ;
#line 253 "/usr/include/pthread.h"
extern  __attribute__((__noreturn__)) void pthread_exit(void *__retval ) ;
#line 769
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_mutex_trylock)(pthread_mutex_t *__mutex ) ;
#line 111 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/test/../thread.h"
__inline static int ( __attribute__((__always_inline__)) usleep_r)(unsigned long useconds ) ;
#line 113 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/test/../thread.h"
__inline static int ( __attribute__((__always_inline__)) usleep_r)(unsigned long useconds ) 
{ 
  struct timespec ts ;
  int tmp ;

  {
  {
#line 115
  ts.tv_sec = (__time_t )(useconds / 1000000UL);
#line 115
  ts.tv_nsec = (__syscall_slong_t )((useconds % 1000000UL) * 1000UL);
#line 118
  tmp = nanosleep((struct timespec  const  *)(& ts), (struct timespec *)((void *)0));
  }
#line 118
  return (tmp);
}
}
#line 37 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/test/../helpers.h"
int run_as(char const   *user ) ;
#line 52
unsigned char const   *rhn2str(unsigned char const   *rhn , unsigned char *str , unsigned int size ) ;
#line 53
int str2rhn(unsigned char const   *str , unsigned char *rhn ) ;
#line 54
char const   *parsestr2rhn(unsigned char const   *str , unsigned int len , unsigned char *rhn ) ;
#line 60
__inline static unsigned int ( __attribute__((__always_inline__)) rhnlen)(unsigned char const   *rhn ) ;
#line 62 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/test/../helpers.h"
__inline static unsigned int ( __attribute__((__always_inline__)) rhnlen)(unsigned char const   *rhn ) 
{ 
  unsigned int i ;
  unsigned int lb ;
  unsigned int tmp ;

  {
#line 64
  i = 0U;
  {
#line 66
  while (1) {
    while_continue: /* CIL Label */ ;
#line 66
    tmp = i;
#line 66
    i ++;
#line 66
    lb = (unsigned int )*(rhn + tmp);
#line 66
    if (! lb) {
#line 66
      goto while_break;
    }
#line 67
    i += lb;
  }
  while_break: /* CIL Label */ ;
  }
#line 68
  return (i);
}
}
#line 111
unsigned int rhncpy(unsigned char *dst , unsigned char const   *src ) ;
#line 112
int isnormalencdomname(unsigned char const   *rhn , unsigned int maxlen ) ;
#line 156
int str2pdnsd_a(char const   *addr , pdnsd_a *a ) ;
#line 157
char const   *pdnsd_a2str(pdnsd_a *a , char *buf , int maxlen ) ;
#line 159
int init_rng(void) ;
#line 170
int ( /* format attribute */  fsprintf)(int fd , char const   *format  , ...) ;
#line 180
__inline static ssize_t ( __attribute__((__always_inline__)) write_all)(int fd , void const   *data ,
                                                                        size_t n ) ;
#line 182 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/test/../helpers.h"
__inline static ssize_t ( __attribute__((__always_inline__)) write_all)(int fd , void const   *data ,
                                                                        size_t n ) 
{ 
  ssize_t written ;
  ssize_t m ;
  ssize_t tmp ;

  {
#line 184
  written = (ssize_t )0;
  {
#line 186
  while (1) {
    while_continue: /* CIL Label */ ;
#line 186
    if (! ((size_t )written < n)) {
#line 186
      goto while_break;
    }
    {
#line 187
    tmp = write(fd, (void const   *)((char const   *)data + written), n - (size_t )written);
#line 187
    m = tmp;
    }
#line 189
    if (m < 0L) {
#line 190
      return (m);
    }
#line 192
    written += m;
  }
  while_break: /* CIL Label */ ;
  }
#line 195
  return (written);
}
}
#line 198
void hexdump(void const   *data , int dlen , char *buf , int buflen ) ;
#line 199
int escapestr(char const   *in , int ilen , char *str , int size ) ;
#line 47 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/test/../helpers.c"
void pdnsd_exit(void) 
{ 


  {
  {
#line 49
  pthread_kill(main_thrid, 15);
#line 50
  pthread_exit((void *)0);
  }
}
}
#line 58 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/test/../helpers.c"
int softlock_mutex(pthread_mutex_t *mutex ) 
{ 
  unsigned int tr ;
  int tmp ;

  {
#line 60
  tr = 0U;
  {
#line 61
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 61
    tmp = pthread_mutex_trylock(mutex);
    }
#line 61
    if (! tmp) {
#line 61
      goto while_break;
    }
#line 62
    tr ++;
#line 62
    if (tr >= 1000U) {
#line 63
      return (0);
    }
    {
#line 64
    usleep_r(10000UL);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 66
  return (1);
}
}
#line 72 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/test/../helpers.c"
int run_as(char const   *user ) 
{ 
  struct passwd pwdbuf ;
  struct passwd *pwd ;
  size_t buflen ;
  int err ;
  char *buf ;
  unsigned long __lengthofbuf ;
  void *tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  int *tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  int *tmp___6 ;
  char *tmp___7 ;
  int tmp___8 ;
  char *tmp___9 ;

  {
#line 74
  if (*(user + 0)) {
#line 80
    buflen = (size_t )128;
    {
#line 80
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 81
      __lengthofbuf = buflen;
#line 81
      tmp = __builtin_alloca(sizeof(*buf) * __lengthofbuf);
#line 81
      buf = (char *)tmp;
#line 87
      err = getpwnam_r((char const   */* __restrict  */)user, (struct passwd */* __restrict  */)(& pwdbuf),
                       (char */* __restrict  */)buf, buflen, (struct passwd **/* __restrict  */)(& pwd));
      }
#line 88
      if (err == 0) {
#line 88
        if (pwd) {
          {
#line 90
          tmp___2 = setgid(pwd->pw_gid);
          }
#line 90
          if (tmp___2 != 0) {
            {
#line 91
            tmp___0 = __errno_location();
#line 91
            tmp___1 = strerror(*tmp___0);
#line 91
            log_message(3, "Could not change group id to that of run_as user \'%s\': %s",
                        user, tmp___1);
            }
#line 93
            return (0);
          }
#line 98
          if (global.use_nss) {
            {
#line 98
            tmp___5 = initgroups(user, pwd->pw_gid);
            }
#line 98
            if (tmp___5 != 0) {
              {
#line 99
              tmp___3 = __errno_location();
#line 99
              tmp___4 = strerror(*tmp___3);
#line 99
              log_message(3, "Could not initialize the group access list of run_as user \'%s\': %s",
                          user, tmp___4);
              }
#line 101
              return (0);
            }
          }
          {
#line 103
          tmp___8 = setuid(pwd->pw_uid);
          }
#line 103
          if (tmp___8 != 0) {
            {
#line 104
            tmp___6 = __errno_location();
#line 104
            tmp___7 = strerror(*tmp___6);
#line 104
            log_message(3, "Could not change user id to that of run_as user \'%s\': %s",
                        user, tmp___7);
            }
#line 106
            return (0);
          }
#line 108
          goto while_break;
        } else {
#line 88
          goto _L;
        }
      } else
      _L: /* CIL Label */ 
#line 110
      if (err != 34) {
#line 111
        if (err) {
          {
#line 112
          tmp___9 = strerror(err);
#line 112
          log_message(3, "run_as user \'%s\' could not be found: %s", user, tmp___9);
          }
        } else {
          {
#line 114
          log_message(3, "run_as user \'%s\' could not be found.", user);
          }
        }
#line 115
        return (0);
      } else
#line 117
      if (buflen >= 16384UL) {
        {
#line 120
        log_message(3, "getpwnam_r() requires more than %u bytes of buffer space.",
                    (unsigned int )buflen);
        }
#line 121
        return (0);
      }
#line 80
      buflen *= 2UL;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 154
  return (1);
}
}
#line 181 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/test/../helpers.c"
int str2rhn(unsigned char const   *str , unsigned char *rhn ) 
{ 
  unsigned int i ;
  unsigned int j ;
  unsigned int jlim ;

  {
#line 185
  if ((int const   )*str == 46) {
#line 185
    if (! *(str + 1)) {
#line 187
      *(rhn + 0) = (unsigned char)0;
#line 188
      return (1);
    }
  }
#line 191
  i = 0U;
  {
#line 191
  while (1) {
    while_continue: /* CIL Label */ ;
#line 192
    jlim = i + 63U;
#line 193
    if (jlim > 254U) {
#line 193
      jlim = 254U;
    }
#line 194
    j = i;
    {
#line 194
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 194
      if (*(str + j)) {
#line 194
        if (! ((int const   )*(str + j) != 46)) {
#line 194
          goto while_break___0;
        }
      } else {
#line 194
        goto while_break___0;
      }
#line 195
      if (j >= jlim) {
#line 195
        return (0);
      }
#line 196
      *(rhn + (j + 1U)) = (unsigned char )*(str + j);
#line 194
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 198
    if (! *(str + j)) {
#line 199
      goto while_break;
    }
#line 200
    if (j <= i) {
#line 201
      return (0);
    }
#line 202
    *(rhn + i) = (unsigned char )(j - i);
#line 203
    i = j + 1U;
  }
  while_break: /* CIL Label */ ;
  }
#line 206
  *(rhn + i) = (unsigned char)0;
#line 207
  if (j > i) {
#line 208
    return (0);
  } else
#line 207
  if (i == 0U) {
#line 208
    return (0);
  }
#line 209
  return (1);
}
}
#line 217 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/test/../helpers.c"
char const   *parsestr2rhn(unsigned char const   *str , unsigned int len , unsigned char *rhn ) 
{ 
  unsigned int i ;
  unsigned int j ;
  unsigned int jlim ;

  {
#line 221
  if (len > 0U) {
#line 221
    if ((int const   )*str == 46) {
#line 221
      if (len == 1U) {
#line 223
        *(rhn + 0) = (unsigned char)0;
#line 224
        return ((char const   *)((void *)0));
      } else
#line 221
      if (! *(str + 1)) {
#line 223
        *(rhn + 0) = (unsigned char)0;
#line 224
        return ((char const   *)((void *)0));
      }
    }
  }
#line 227
  i = 0U;
  {
#line 228
  while (1) {
    while_continue: /* CIL Label */ ;
#line 229
    jlim = i + 63U;
#line 230
    if (jlim > 254U) {
#line 230
      jlim = 254U;
    }
#line 231
    j = i;
    {
#line 231
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 231
      if (j < len) {
#line 231
        if (*(str + j)) {
#line 231
          if (! ((int const   )*(str + j) != 46)) {
#line 231
            goto while_break___0;
          }
        } else {
#line 231
          goto while_break___0;
        }
      } else {
#line 231
        goto while_break___0;
      }
#line 234
      if (j >= jlim) {
#line 235
        return ("Domain name element too long");
      }
#line 236
      *(rhn + (j + 1U)) = (unsigned char )*(str + j);
#line 231
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 239
    if (j <= i) {
#line 240
      if (j < len) {
#line 240
        if (*(str + j)) {
#line 241
          return ("Empty name element in domain name");
        } else {
#line 243
          goto while_break;
        }
      } else {
#line 243
        goto while_break;
      }
    }
#line 246
    *(rhn + i) = (unsigned char )(j - i);
#line 247
    i = j + 1U;
#line 228
    if (j < len) {
#line 228
      if (! *(str + j)) {
#line 228
        goto while_break;
      }
    } else {
#line 228
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 250
  *(rhn + i) = (unsigned char)0;
#line 251
  if (i == 0U) {
#line 252
    return ("Empty domain name not allowed");
  }
#line 253
  return ((char const   *)((void *)0));
}
}
#line 273 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/test/../helpers.c"
unsigned char const   *rhn2str(unsigned char const   *rhn , unsigned char *str , unsigned int size ) 
{ 
  unsigned int i ;
  unsigned int j ;
  unsigned int lb ;
  unsigned int tmp ;
  unsigned int tmp___0 ;
  unsigned char c ;
  unsigned int tmp___1 ;
  unsigned int tmp___2 ;
  unsigned int tmp___3 ;
  unsigned int rem ;
  int n ;
  int tmp___4 ;
  unsigned int tmp___5 ;
  unsigned short const   **tmp___6 ;
  unsigned int tmp___7 ;
  unsigned int tmp___8 ;

  {
#line 277
  if (size == 0U) {
#line 277
    return ((unsigned char const   *)((void *)0));
  }
#line 279
  i = 0U;
#line 279
  j = 0U;
#line 280
  tmp = i;
#line 280
  i ++;
#line 280
  lb = (unsigned int )*(rhn + tmp);
#line 281
  if (! lb) {
#line 282
    if (size >= 2U) {
#line 283
      tmp___0 = j;
#line 283
      j ++;
#line 283
      *(str + tmp___0) = (unsigned char )'.';
    }
  } else {
    {
#line 286
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 287
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 287
        if (! lb) {
#line 287
          goto while_break___0;
        }
#line 289
        if (j + 2U >= size) {
#line 290
          goto overflow;
        }
        {
#line 291
        tmp___1 = i;
#line 291
        i ++;
#line 291
        c = (unsigned char )*(rhn + tmp___1);
#line 292
        tmp___6 = __ctype_b_loc();
        }
#line 292
        if ((int const   )*(*tmp___6 + (int )c) & 32768) {
#line 293
          if ((int )c == 46) {
#line 293
            goto _L;
          } else
#line 293
          if ((int )c == 92) {
#line 293
            goto _L;
          } else
#line 293
          if ((int )c == 34) {
            _L: /* CIL Label */ 
#line 294
            tmp___2 = j;
#line 294
            j ++;
#line 294
            *(str + tmp___2) = (unsigned char )'\\';
#line 295
            if (j + 2U >= size) {
#line 296
              goto overflow;
            }
          }
#line 298
          tmp___3 = j;
#line 298
          j ++;
#line 298
          *(str + tmp___3) = c;
        } else {
          {
#line 301
          rem = (size - 1U) - j;
#line 302
          tmp___4 = snprintf((char */* __restrict  */)((char *)(str + j)), (size_t )rem,
                             (char const   */* __restrict  */)"\\%03o", (int )c);
#line 302
          n = tmp___4;
          }
#line 303
          if (n < 0) {
#line 304
            tmp___5 = j;
#line 304
            j ++;
#line 304
            *(str + tmp___5) = (unsigned char )'.';
#line 305
            goto overflow;
          } else
#line 303
          if ((unsigned int )n >= rem) {
#line 304
            tmp___5 = j;
#line 304
            j ++;
#line 304
            *(str + tmp___5) = (unsigned char )'.';
#line 305
            goto overflow;
          }
#line 307
          j += (unsigned int )n;
        }
#line 287
        lb --;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 310
      tmp___7 = j;
#line 310
      j ++;
#line 310
      *(str + tmp___7) = (unsigned char )'.';
#line 311
      tmp___8 = i;
#line 311
      i ++;
#line 311
      lb = (unsigned int )*(rhn + tmp___8);
#line 286
      if (! lb) {
#line 286
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 314
  *(str + j) = (unsigned char)0;
#line 315
  return ((unsigned char const   *)str);
  overflow: 
#line 318
  j = size;
#line 319
  j --;
#line 319
  *(str + j) = (unsigned char)0;
#line 320
  if (j > 0U) {
#line 321
    j --;
#line 321
    *(str + j) = (unsigned char )'.';
#line 322
    if (j > 0U) {
#line 323
      j --;
#line 323
      *(str + j) = (unsigned char )'.';
#line 324
      if (j > 0U) {
#line 325
        j --;
#line 325
        *(str + j) = (unsigned char )'.';
      }
    }
  }
#line 328
  return ((unsigned char const   *)str);
}
}
#line 355 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/test/../helpers.c"
unsigned int rhncpy(unsigned char *dst , unsigned char const   *src ) 
{ 
  unsigned int len ;
  unsigned int tmp ;
  unsigned int tmp___0 ;

  {
  {
#line 357
  tmp = rhnlen(src);
#line 357
  len = tmp;
  }
#line 359
  if (! (len <= 256U)) {
    {
#line 359
    log_message(3, "%s:%d: %s", "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/test/../helpers.c",
                359, "rhncpy: src too long!");
#line 359
    pdnsd_exit();
    }
  }
#line 360
  if (len > 256U) {
#line 360
    tmp___0 = 256U;
  } else {
#line 360
    tmp___0 = len;
  }
  {
#line 360
  memcpy((void */* __restrict  */)dst, (void const   */* __restrict  */)src, (size_t )tmp___0);
  }
#line 361
  return (len);
}
}
#line 369 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/test/../helpers.c"
int isnormalencdomname(unsigned char const   *rhn , unsigned int maxlen ) 
{ 
  unsigned int i ;
  unsigned int lb ;
  unsigned int tmp ;

  {
#line 373
  if (maxlen > 256U) {
#line 374
    maxlen = 256U;
  }
#line 375
  i = 0U;
  {
#line 375
  while (1) {
    while_continue: /* CIL Label */ ;
#line 376
    if (i >= maxlen) {
#line 376
      return (0);
    }
#line 377
    tmp = i;
#line 377
    i ++;
#line 377
    lb = (unsigned int )*(rhn + tmp);
#line 378
    if (lb == 0U) {
#line 378
      goto while_break;
    }
#line 379
    if (lb > 63U) {
#line 379
      return (0);
    }
#line 380
    i += lb;
  }
  while_break: /* CIL Label */ ;
  }
#line 383
  return (1);
}
}
#line 386 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/test/../helpers.c"
int str2pdnsd_a(char const   *addr , pdnsd_a *a ) 
{ 
  int tmp ;

  {
  {
#line 390
  tmp = inet_aton(addr, & a->ipv4);
  }
#line 390
  return (tmp);
}
}
#line 420 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/test/../helpers.c"
char const   *pdnsd_a2str(pdnsd_a *a , char *buf , int maxlen ) 
{ 
  char const   *res ;
  char const   *tmp ;
  int *tmp___0 ;
  char *tmp___1 ;

  {
  {
#line 422
  tmp = inet_ntop(2, (void const   */* __restrict  */)(& a->ipv4), (char */* __restrict  */)buf,
                  (socklen_t )maxlen);
#line 422
  res = tmp;
  }
#line 424
  if (! res) {
    {
#line 425
    tmp___0 = __errno_location();
#line 425
    tmp___1 = strerror(*tmp___0);
#line 425
    log_message(3, "inet_ntop: %s", tmp___1);
    }
#line 426
    return ("?.?.?.?");
  }
#line 429
  return (res);
}
}
#line 447 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/test/../helpers.c"
void init_crandom(void) 
{ 
  struct timeval tv ;
  struct timezone tz ;

  {
  {
#line 452
  gettimeofday((struct timeval */* __restrict  */)(& tv), (__timezone_ptr_t )(& tz));
#line 453
  srandom((unsigned int )(tv.tv_sec ^ tv.tv_usec));
  }
#line 454
  return;
}
}
#line 458 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/test/../helpers.c"
int init_rng(void) 
{ 


  {
  {
#line 467
  init_crandom();
  }
#line 469
  return (1);
}
}
#line 484 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/test/../helpers.c"
unsigned short get_rand16(void) 
{ 
  long tmp ;

  {
  {
#line 499
  tmp = random();
  }
#line 499
  return ((unsigned short )(tmp & 65535L));
}
}
#line 510 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/test/../helpers.c"
int ( /* format attribute */  fsprintf)(int fd , char const   *format  , ...) 
{ 
  int n ;
  va_list va ;
  char buf[256] ;
  ssize_t tmp ;
  unsigned int bufsize ;
  char *buf___0 ;
  unsigned long __lengthofbuf___0 ;
  void *tmp___0 ;
  ssize_t tmp___1 ;

  {
  {
#line 518
  __builtin_va_start(va, format);
#line 519
  n = vsnprintf((char */* __restrict  */)(buf), sizeof(buf), (char const   */* __restrict  */)format,
                va);
#line 520
  __builtin_va_end(va);
  }
#line 522
  if (n < (int )sizeof(buf)) {
#line 523
    if (n > 0) {
      {
#line 523
      tmp = write_all(fd, (void const   *)(buf), (size_t )n);
#line 523
      n = (int )tmp;
      }
    }
#line 524
    return (n);
  }
  {
#line 529
  bufsize = (unsigned int )(n + 1);
#line 530
  __lengthofbuf___0 = (unsigned long )bufsize;
#line 530
  tmp___0 = __builtin_alloca(sizeof(*buf___0) * __lengthofbuf___0);
#line 530
  buf___0 = (char *)tmp___0;
#line 532
  __builtin_va_start(va, format);
#line 533
  n = vsnprintf((char */* __restrict  */)buf___0, (size_t )bufsize, (char const   */* __restrict  */)format,
                va);
#line 534
  __builtin_va_end(va);
  }
#line 536
  if (n > 0) {
    {
#line 536
    tmp___1 = write_all(fd, (void const   *)buf___0, (size_t )n);
#line 536
    n = (int )tmp___1;
    }
  }
#line 538
  return (n);
}
}
#line 546 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/test/../helpers.c"
void hexdump(void const   *data , int dlen , char *buf , int buflen ) 
{ 
  unsigned char const   *p ;
  int i ;
  int j ;
  int rem ;
  int n ;
  char const   *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int ndots ;
  int tmp___5 ;

  {
#line 548
  p = (unsigned char const   *)data;
#line 549
  j = 0;
#line 550
  i = 0;
  {
#line 550
  while (1) {
    while_continue: /* CIL Label */ ;
#line 550
    if (! (i < dlen)) {
#line 550
      goto while_break;
    }
#line 551
    rem = buflen - j;
#line 552
    if (i == 0) {
#line 552
      tmp = "%02x";
    } else {
#line 552
      tmp = " %02x";
    }
    {
#line 552
    tmp___0 = snprintf((char */* __restrict  */)(buf + j), (size_t )rem, (char const   */* __restrict  */)tmp,
                       (int const   )*(p + i));
#line 552
    n = tmp___0;
    }
#line 553
    if (n < 0) {
#line 553
      goto truncated;
    } else
#line 553
    if (n >= rem) {
#line 553
      goto truncated;
    }
#line 554
    j += n;
#line 550
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 556
  goto done;
  truncated: 
#line 559
  if (j >= 6) {
#line 560
    j -= 3;
#line 561
    if (j + 4 >= buflen) {
#line 562
      j -= 3;
    }
#line 563
    tmp___1 = j;
#line 563
    j ++;
#line 563
    *(buf + tmp___1) = (char )' ';
#line 564
    tmp___2 = j;
#line 564
    j ++;
#line 564
    *(buf + tmp___2) = (char )'.';
#line 565
    tmp___3 = j;
#line 565
    j ++;
#line 565
    *(buf + tmp___3) = (char )'.';
#line 566
    tmp___4 = j;
#line 566
    j ++;
#line 566
    *(buf + tmp___4) = (char )'.';
  } else {
#line 569
    ndots = buflen - 1;
#line 570
    if (ndots > 3) {
#line 570
      ndots = 3;
    }
#line 571
    j = 0;
    {
#line 572
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 572
      if (! (j < ndots)) {
#line 572
        goto while_break___0;
      }
#line 572
      tmp___5 = j;
#line 572
      j ++;
#line 572
      *(buf + tmp___5) = (char )'.';
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  done: 
#line 575
  *(buf + j) = (char)0;
#line 576
  return;
}
}
#line 583 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/test/../helpers.c"
int escapestr(char const   *in , int ilen , char *str , int size ) 
{ 
  int i ;
  int j ;
  unsigned char c ;
  int rem ;
  int n ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  unsigned short const   **tmp___2 ;

  {
#line 585
  j = 0;
#line 586
  i = 0;
  {
#line 586
  while (1) {
    while_continue: /* CIL Label */ ;
#line 586
    if (! (i < ilen)) {
#line 586
      goto while_break;
    }
#line 588
    if (j + 1 >= size) {
#line 589
      return (-1);
    }
    {
#line 590
    c = (unsigned char )*(in + i);
#line 591
    tmp___2 = __ctype_b_loc();
    }
#line 591
    if ((int const   )*(*tmp___2 + (int )c) & 16384) {
#line 600
      if ((int )c == 92) {
#line 600
        goto _L;
      } else
#line 600
      if ((int )c == 34) {
        _L: /* CIL Label */ 
#line 601
        tmp___0 = j;
#line 601
        j ++;
#line 601
        *(str + tmp___0) = (char )'\\';
#line 602
        if (j + 1 >= size) {
#line 603
          return (-1);
        }
      }
#line 605
      tmp___1 = j;
#line 605
      j ++;
#line 605
      *(str + tmp___1) = (char )c;
    } else {
      {
#line 592
      rem = size - j;
#line 593
      tmp = snprintf((char */* __restrict  */)(str + j), (size_t )rem, (char const   */* __restrict  */)"\\%03o",
                     (int )c);
#line 593
      n = tmp;
      }
#line 594
      if (n < 0) {
#line 595
        return (-1);
      } else
#line 594
      if (n >= rem) {
#line 595
        return (-1);
      }
#line 597
      j += n;
    }
#line 586
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 608
  *(str + j) = (char)0;
#line 609
  return (j);
}
}
#line 136 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/test/../thread.h"
pthread_attr_t attr_detached  ;
#line 140 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/test/../thread.h"
pthread_key_t thrid_key  ;
#line 232 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/test/../helpers.h"
__inline static int ( __attribute__((__always_inline__)) strncp)(char *dst , char const   *src ,
                                                                 size_t dstsz ) ;
#line 86 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/test/../netdev.c"
static unsigned long volatile   socketopen_errs___0  =    (unsigned long volatile   )0;
#line 96 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/test/../netdev.c"
static unsigned long volatile   isdn_errs___0  =    (unsigned long volatile   )0;
#line 61 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/test/../servers.h"
__inline static int ( __attribute__((__always_inline__)) is_interrupted_servstat_thread)(void) ;
#line 69 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/test/../icmp.c"
static unsigned long volatile   icmp_errs___0  =    (unsigned long volatile   )0;
#line 136 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/test/../icmp.c"
static int icmp4_errcmp___0(char *packet , int plen , struct in_addr *to , char *errmsg ,
                            int elen , int errtype ) 
{ 
  struct iphdr iph ;
  struct icmphdr icmph ;
  struct iphdr eiph ;
  char *data ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 144
  if ((unsigned long )elen < sizeof(struct iphdr )) {
#line 145
    return (0);
  }
  {
#line 146
  memcpy((void */* __restrict  */)(& iph), (void const   */* __restrict  */)errmsg,
         sizeof(iph));
  }
#line 147
  if ((int )iph.protocol != 1) {
#line 148
    return (0);
  } else
#line 147
  if ((unsigned long )elen < (unsigned long )(iph.ihl * 4U + 8U) + sizeof(eiph)) {
#line 148
    return (0);
  }
#line 149
  if (! (sizeof(icmph) >= 8UL)) {
    {
#line 149
    log_message(3, "%s:%d: %s", "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/test/../icmp.c",
                149, "icmp4_errcmp: ICMP_BASEHDR_LEN botched");
#line 149
    pdnsd_exit();
    }
  }
  {
#line 150
  memcpy((void */* __restrict  */)(& icmph), (void const   */* __restrict  */)(errmsg + iph.ihl * 4U),
         (size_t )8);
#line 151
  memcpy((void */* __restrict  */)(& eiph), (void const   */* __restrict  */)((errmsg + iph.ihl * 4U) + 8),
         sizeof(eiph));
  }
#line 152
  if ((unsigned int )elen < ((iph.ihl * 4U + 8U) + eiph.ihl * 4U) + 8U) {
#line 153
    return (0);
  }
#line 154
  data = ((errmsg + iph.ihl * 4U) + 8) + eiph.ihl * 4U;
#line 155
  if ((int )icmph.type == errtype) {
    {
#line 155
    tmp = memcmp((void const   *)(& to->s_addr), (void const   *)(& eiph.daddr), sizeof(to->s_addr));
    }
#line 155
    if (tmp == 0) {
#line 155
      if (plen < 8) {
#line 155
        tmp___0 = plen;
      } else {
#line 155
        tmp___0 = 8;
      }
      {
#line 155
      tmp___1 = memcmp((void const   *)data, (void const   *)packet, (size_t )tmp___0);
      }
#line 155
      if (tmp___1 == 0) {
#line 155
        tmp___2 = 1;
      } else {
#line 155
        tmp___2 = 0;
      }
    } else {
#line 155
      tmp___2 = 0;
    }
  } else {
#line 155
    tmp___2 = 0;
  }
#line 155
  return (tmp___2);
}
}
#line 160 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/test/../icmp.c"
static int ping4___0(struct in_addr addr , int timeout , int rep ) 
{ 
  int i ;
  int isock ;
  struct icmp_filter f ;
  unsigned short id ;
  unsigned short tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  struct sockaddr_in from ;
  struct sockaddr_in to ;
  struct icmphdr icmpd ;
  unsigned long sum ;
  uint16_t *ptr ;
  long tm ;
  long tpassed ;
  int j ;
  uint16_t *tmp___3 ;
  int *tmp___4 ;
  char *tmp___5 ;
  ssize_t tmp___6 ;
  int psres ;
  struct pollfd pfd ;
  int tmp___7 ;
  long tmp___8 ;
  int *tmp___9 ;
  char *tmp___10 ;
  int *tmp___11 ;
  int tmp___12 ;
  char buf[1024] ;
  socklen_t sl ;
  int len ;
  struct iphdr iph ;
  struct icmphdr icmpp ;
  uint16_t tmp___13 ;
  time_t tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  uint16_t tmp___17 ;
  uint16_t tmp___18 ;
  ssize_t tmp___19 ;
  time_t tmp___20 ;

  {
  {
#line 167
  tmp = get_rand16();
#line 167
  id = tmp;
#line 169
  isock = (int )ping_isocket;
#line 178
  f.data = 4294965238U;
#line 179
  tmp___2 = setsockopt(isock, 255, 1, (void const   *)(& f), (socklen_t )sizeof(f));
  }
#line 179
  if (tmp___2 == -1) {
#line 180
    icmp_errs___0 += (unsigned long volatile   )1;
#line 180
    if (icmp_errs___0 <= (unsigned long volatile   )10) {
      {
#line 181
      tmp___0 = __errno_location();
#line 181
      tmp___1 = strerror(*tmp___0);
#line 181
      log_message(4, "icmp ping: setsockopt() failed: %s", tmp___1);
      }
    }
#line 183
    return (-1);
  }
#line 187
  i = 0;
  {
#line 187
  while (1) {
    while_continue: /* CIL Label */ ;
#line 187
    if (! (i < rep)) {
#line 187
      goto while_break;
    }
    {
#line 195
    icmpd.type = (__u8 )8;
#line 196
    icmpd.code = (__u8 )0;
#line 197
    icmpd.checksum = (__sum16 )0;
#line 198
    icmpd.un.echo.id = htons(id);
#line 199
    icmpd.un.echo.sequence = htons((uint16_t )i);
#line 203
    ptr = (uint16_t *)(& icmpd);
#line 204
    sum = 0UL;
#line 206
    j = 0;
    }
    {
#line 206
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 206
      if (! (j < 4)) {
#line 206
        goto while_break___0;
      }
#line 207
      tmp___3 = ptr;
#line 207
      ptr ++;
#line 207
      sum += (unsigned long )*tmp___3;
#line 206
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 209
    sum = (sum >> 16) + (sum & 65535UL);
#line 210
    sum += sum >> 16;
#line 211
    icmpd.checksum = (__sum16 )(~ sum);
#line 213
    memset((void *)(& to), 0, sizeof(to));
#line 214
    to.sin_family = (sa_family_t )2;
#line 215
    to.sin_port = (in_port_t )0;
#line 216
    to.sin_addr = addr;
#line 218
    tmp___6 = sendto(isock, (void const   *)(& icmpd), (size_t )8, 0, (struct sockaddr  const  */* __restrict  */)((struct sockaddr *)(& to)),
                     (socklen_t )sizeof(to));
    }
#line 218
    if (tmp___6 == -1L) {
#line 219
      icmp_errs___0 += (unsigned long volatile   )1;
#line 219
      if (icmp_errs___0 <= (unsigned long volatile   )10) {
        {
#line 220
        tmp___4 = __errno_location();
#line 220
        tmp___5 = strerror(*tmp___4);
#line 220
        log_message(4, "icmp ping: sendto() failed: %s.", tmp___5);
        }
      }
#line 222
      return (-1);
    }
    {
#line 225
    tm = time((time_t *)((void *)0));
#line 225
    tpassed = 0L;
    }
    {
#line 226
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 248
      pfd.fd = isock;
#line 249
      pfd.events = (short)1;
#line 254
      tmp___7 = is_interrupted_servstat_thread();
      }
#line 254
      if (tmp___7) {
#line 255
        if (debug_p) {
          {
#line 255
          debug_msg(0, "server status thread interrupted.\n");
          }
        }
#line 256
        return (-1);
      }
#line 258
      if ((long )timeout > tpassed) {
#line 258
        tmp___8 = ((long )timeout - tpassed) * 1000L;
      } else {
#line 258
        tmp___8 = 0L;
      }
      {
#line 258
      psres = poll(& pfd, (nfds_t )1, (int )tmp___8);
      }
#line 261
      if (psres < 0) {
        {
#line 262
        tmp___11 = __errno_location();
        }
#line 262
        if (*tmp___11 == 4) {
          {
#line 262
          tmp___12 = is_interrupted_servstat_thread();
          }
#line 262
          if (tmp___12) {
#line 263
            if (debug_p) {
              {
#line 263
              debug_msg(0, "poll/select interrupted in server status thread.\n");
              }
            }
          } else {
#line 262
            goto _L;
          }
        } else {
          _L: /* CIL Label */ 
#line 265
          icmp_errs___0 += (unsigned long volatile   )1;
#line 265
          if (icmp_errs___0 <= (unsigned long volatile   )10) {
            {
#line 266
            tmp___9 = __errno_location();
#line 266
            tmp___10 = strerror(*tmp___9);
#line 266
            log_message(4, "poll/select failed: %s", tmp___10);
            }
          }
        }
#line 268
        return (-1);
      }
#line 270
      if (psres == 0) {
#line 271
        goto while_break___1;
      }
#line 276
      if ((int )pfd.revents & 9) {
        {
#line 280
        sl = (socklen_t )sizeof(from);
#line 283
        tmp___19 = recvfrom(isock, (void */* __restrict  */)(& buf), sizeof(buf),
                            0, (struct sockaddr */* __restrict  */)((struct sockaddr *)(& from)),
                            (socklen_t */* __restrict  */)(& sl));
#line 283
        len = (int )tmp___19;
        }
#line 283
        if (len != -1) {
#line 284
          if ((unsigned long )len > sizeof(struct iphdr )) {
            {
#line 287
            memcpy((void */* __restrict  */)(& iph), (void const   */* __restrict  */)(buf),
                   sizeof(iph));
            }
#line 288
            if ((unsigned int )len - iph.ihl * 4U >= 8U) {
              {
#line 291
              memcpy((void */* __restrict  */)(& icmpp), (void const   */* __restrict  */)((uint32_t *)(buf) + iph.ihl),
                     sizeof(icmpp));
              }
#line 292
              if (iph.saddr == addr.s_addr) {
#line 292
                if ((int )icmpp.type == 0) {
                  {
#line 292
                  tmp___17 = ntohs(icmpp.un.echo.id);
                  }
#line 292
                  if ((int )tmp___17 == (int )id) {
                    {
#line 292
                    tmp___18 = ntohs(icmpp.un.echo.sequence);
                    }
#line 292
                    if ((int )tmp___18 <= i) {
                      {
#line 294
                      tmp___13 = ntohs(icmpp.un.echo.sequence);
#line 294
                      tmp___14 = time((time_t *)((void *)0));
                      }
#line 294
                      return ((int )((time_t )((i - (int )tmp___13) * timeout) + (tmp___14 - tm)));
                    } else {
#line 292
                      goto _L___2;
                    }
                  } else {
#line 292
                    goto _L___2;
                  }
                } else {
#line 292
                  goto _L___2;
                }
              } else {
                _L___2: /* CIL Label */ 
                {
#line 297
                tmp___15 = icmp4_errcmp___0((char *)(& icmpd), 8, & to.sin_addr, buf,
                                            len, 3);
                }
#line 297
                if (tmp___15) {
#line 299
                  return (-1);
                } else {
                  {
#line 297
                  tmp___16 = icmp4_errcmp___0((char *)(& icmpd), 8, & to.sin_addr,
                                              buf, len, 11);
                  }
#line 297
                  if (tmp___16) {
#line 299
                    return (-1);
                  }
                }
              }
            }
          }
        } else {
#line 305
          return (-1);
        }
      } else {
#line 309
        icmp_errs___0 += (unsigned long volatile   )1;
#line 309
        if (icmp_errs___0 <= (unsigned long volatile   )10) {
          {
#line 310
          log_message(3, "Unhandled poll/select event in ping4() at %s, line %d.",
                      "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/test/../icmp.c",
                      310);
          }
        }
#line 312
        return (-1);
      }
      {
#line 314
      tmp___20 = time((time_t *)((void *)0));
#line 314
      tpassed = tmp___20 - tm;
      }
#line 226
      if (! (tpassed < (long )timeout)) {
#line 226
        goto while_break___1;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
#line 187
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 317
  return (-1);
}
}
#line 111 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/test/../thread.h"
__inline static int ( __attribute__((__always_inline__)) usleep_r)(unsigned long useconds ) ;
#line 60 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/test/../helpers.h"
__inline static unsigned int ( __attribute__((__always_inline__)) rhnlen)(unsigned char const   *rhn ) ;
#line 180
__inline static ssize_t ( __attribute__((__always_inline__)) write_all)(int fd , void const   *data ,
                                                                        size_t n ) ;
#line 232
__inline static int ( __attribute__((__always_inline__)) strncp)(char *dst , char const   *src ,
                                                                 size_t dstsz ) ;
#line 86 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/test/../netdev.c"
static unsigned long volatile   socketopen_errs___1  =    (unsigned long volatile   )0;
#line 96 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/test/../netdev.c"
static unsigned long volatile   isdn_errs___1  =    (unsigned long volatile   )0;
#line 61 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/test/../servers.h"
__inline static int ( __attribute__((__always_inline__)) is_interrupted_servstat_thread)(void) ;
#line 69 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/test/../icmp.c"
static unsigned long volatile   icmp_errs___1  =    (unsigned long volatile   )0;
#line 136 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/test/../icmp.c"
static int icmp4_errcmp___1(char *packet , int plen , struct in_addr *to , char *errmsg ,
                            int elen , int errtype ) 
{ 
  struct iphdr iph ;
  struct icmphdr icmph ;
  struct iphdr eiph ;
  char *data ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 144
  if ((unsigned long )elen < sizeof(struct iphdr )) {
#line 145
    return (0);
  }
  {
#line 146
  memcpy((void */* __restrict  */)(& iph), (void const   */* __restrict  */)errmsg,
         sizeof(iph));
  }
#line 147
  if ((int )iph.protocol != 1) {
#line 148
    return (0);
  } else
#line 147
  if ((unsigned long )elen < (unsigned long )(iph.ihl * 4U + 8U) + sizeof(eiph)) {
#line 148
    return (0);
  }
#line 149
  if (! (sizeof(icmph) >= 8UL)) {
    {
#line 149
    log_message(3, "%s:%d: %s", "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/test/../icmp.c",
                149, "icmp4_errcmp: ICMP_BASEHDR_LEN botched");
#line 149
    pdnsd_exit();
    }
  }
  {
#line 150
  memcpy((void */* __restrict  */)(& icmph), (void const   */* __restrict  */)(errmsg + iph.ihl * 4U),
         (size_t )8);
#line 151
  memcpy((void */* __restrict  */)(& eiph), (void const   */* __restrict  */)((errmsg + iph.ihl * 4U) + 8),
         sizeof(eiph));
  }
#line 152
  if ((unsigned int )elen < ((iph.ihl * 4U + 8U) + eiph.ihl * 4U) + 8U) {
#line 153
    return (0);
  }
#line 154
  data = ((errmsg + iph.ihl * 4U) + 8) + eiph.ihl * 4U;
#line 155
  if ((int )icmph.type == errtype) {
    {
#line 155
    tmp = memcmp((void const   *)(& to->s_addr), (void const   *)(& eiph.daddr), sizeof(to->s_addr));
    }
#line 155
    if (tmp == 0) {
#line 155
      if (plen < 8) {
#line 155
        tmp___0 = plen;
      } else {
#line 155
        tmp___0 = 8;
      }
      {
#line 155
      tmp___1 = memcmp((void const   *)data, (void const   *)packet, (size_t )tmp___0);
      }
#line 155
      if (tmp___1 == 0) {
#line 155
        tmp___2 = 1;
      } else {
#line 155
        tmp___2 = 0;
      }
    } else {
#line 155
      tmp___2 = 0;
    }
  } else {
#line 155
    tmp___2 = 0;
  }
#line 155
  return (tmp___2);
}
}
#line 160 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/test/../icmp.c"
static int ping4___1(struct in_addr addr , int timeout , int rep ) 
{ 
  int i ;
  int isock ;
  struct icmp_filter f ;
  unsigned short id ;
  unsigned short tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  struct sockaddr_in from ;
  struct sockaddr_in to ;
  struct icmphdr icmpd ;
  unsigned long sum ;
  uint16_t *ptr ;
  long tm ;
  long tpassed ;
  int j ;
  uint16_t *tmp___3 ;
  int *tmp___4 ;
  char *tmp___5 ;
  ssize_t tmp___6 ;
  int psres ;
  struct pollfd pfd ;
  int tmp___7 ;
  long tmp___8 ;
  int *tmp___9 ;
  char *tmp___10 ;
  int *tmp___11 ;
  int tmp___12 ;
  char buf[1024] ;
  socklen_t sl ;
  int len ;
  struct iphdr iph ;
  struct icmphdr icmpp ;
  uint16_t tmp___13 ;
  time_t tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  uint16_t tmp___17 ;
  uint16_t tmp___18 ;
  ssize_t tmp___19 ;
  time_t tmp___20 ;

  {
  {
#line 167
  tmp = get_rand16();
#line 167
  id = tmp;
#line 169
  isock = (int )ping_isocket;
#line 178
  f.data = 4294965238U;
#line 179
  tmp___2 = setsockopt(isock, 255, 1, (void const   *)(& f), (socklen_t )sizeof(f));
  }
#line 179
  if (tmp___2 == -1) {
#line 180
    icmp_errs___1 += (unsigned long volatile   )1;
#line 180
    if (icmp_errs___1 <= (unsigned long volatile   )10) {
      {
#line 181
      tmp___0 = __errno_location();
#line 181
      tmp___1 = strerror(*tmp___0);
#line 181
      log_message(4, "icmp ping: setsockopt() failed: %s", tmp___1);
      }
    }
#line 183
    return (-1);
  }
#line 187
  i = 0;
  {
#line 187
  while (1) {
    while_continue: /* CIL Label */ ;
#line 187
    if (! (i < rep)) {
#line 187
      goto while_break;
    }
    {
#line 195
    icmpd.type = (__u8 )8;
#line 196
    icmpd.code = (__u8 )0;
#line 197
    icmpd.checksum = (__sum16 )0;
#line 198
    icmpd.un.echo.id = htons(id);
#line 199
    icmpd.un.echo.sequence = htons((uint16_t )i);
#line 203
    ptr = (uint16_t *)(& icmpd);
#line 204
    sum = 0UL;
#line 206
    j = 0;
    }
    {
#line 206
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 206
      if (! (j < 4)) {
#line 206
        goto while_break___0;
      }
#line 207
      tmp___3 = ptr;
#line 207
      ptr ++;
#line 207
      sum += (unsigned long )*tmp___3;
#line 206
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 209
    sum = (sum >> 16) + (sum & 65535UL);
#line 210
    sum += sum >> 16;
#line 211
    icmpd.checksum = (__sum16 )(~ sum);
#line 213
    memset((void *)(& to), 0, sizeof(to));
#line 214
    to.sin_family = (sa_family_t )2;
#line 215
    to.sin_port = (in_port_t )0;
#line 216
    to.sin_addr = addr;
#line 218
    tmp___6 = sendto(isock, (void const   *)(& icmpd), (size_t )8, 0, (struct sockaddr  const  */* __restrict  */)((struct sockaddr *)(& to)),
                     (socklen_t )sizeof(to));
    }
#line 218
    if (tmp___6 == -1L) {
#line 219
      icmp_errs___1 += (unsigned long volatile   )1;
#line 219
      if (icmp_errs___1 <= (unsigned long volatile   )10) {
        {
#line 220
        tmp___4 = __errno_location();
#line 220
        tmp___5 = strerror(*tmp___4);
#line 220
        log_message(4, "icmp ping: sendto() failed: %s.", tmp___5);
        }
      }
#line 222
      return (-1);
    }
    {
#line 225
    tm = time((time_t *)((void *)0));
#line 225
    tpassed = 0L;
    }
    {
#line 226
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 248
      pfd.fd = isock;
#line 249
      pfd.events = (short)1;
#line 254
      tmp___7 = is_interrupted_servstat_thread();
      }
#line 254
      if (tmp___7) {
#line 255
        if (debug_p) {
          {
#line 255
          debug_msg(0, "server status thread interrupted.\n");
          }
        }
#line 256
        return (-1);
      }
#line 258
      if ((long )timeout > tpassed) {
#line 258
        tmp___8 = ((long )timeout - tpassed) * 1000L;
      } else {
#line 258
        tmp___8 = 0L;
      }
      {
#line 258
      psres = poll(& pfd, (nfds_t )1, (int )tmp___8);
      }
#line 261
      if (psres < 0) {
        {
#line 262
        tmp___11 = __errno_location();
        }
#line 262
        if (*tmp___11 == 4) {
          {
#line 262
          tmp___12 = is_interrupted_servstat_thread();
          }
#line 262
          if (tmp___12) {
#line 263
            if (debug_p) {
              {
#line 263
              debug_msg(0, "poll/select interrupted in server status thread.\n");
              }
            }
          } else {
#line 262
            goto _L;
          }
        } else {
          _L: /* CIL Label */ 
#line 265
          icmp_errs___1 += (unsigned long volatile   )1;
#line 265
          if (icmp_errs___1 <= (unsigned long volatile   )10) {
            {
#line 266
            tmp___9 = __errno_location();
#line 266
            tmp___10 = strerror(*tmp___9);
#line 266
            log_message(4, "poll/select failed: %s", tmp___10);
            }
          }
        }
#line 268
        return (-1);
      }
#line 270
      if (psres == 0) {
#line 271
        goto while_break___1;
      }
#line 276
      if ((int )pfd.revents & 9) {
        {
#line 280
        sl = (socklen_t )sizeof(from);
#line 283
        tmp___19 = recvfrom(isock, (void */* __restrict  */)(& buf), sizeof(buf),
                            0, (struct sockaddr */* __restrict  */)((struct sockaddr *)(& from)),
                            (socklen_t */* __restrict  */)(& sl));
#line 283
        len = (int )tmp___19;
        }
#line 283
        if (len != -1) {
#line 284
          if ((unsigned long )len > sizeof(struct iphdr )) {
            {
#line 287
            memcpy((void */* __restrict  */)(& iph), (void const   */* __restrict  */)(buf),
                   sizeof(iph));
            }
#line 288
            if ((unsigned int )len - iph.ihl * 4U >= 8U) {
              {
#line 291
              memcpy((void */* __restrict  */)(& icmpp), (void const   */* __restrict  */)((uint32_t *)(buf) + iph.ihl),
                     sizeof(icmpp));
              }
#line 292
              if (iph.saddr == addr.s_addr) {
#line 292
                if ((int )icmpp.type == 0) {
                  {
#line 292
                  tmp___17 = ntohs(icmpp.un.echo.id);
                  }
#line 292
                  if ((int )tmp___17 == (int )id) {
                    {
#line 292
                    tmp___18 = ntohs(icmpp.un.echo.sequence);
                    }
#line 292
                    if ((int )tmp___18 <= i) {
                      {
#line 294
                      tmp___13 = ntohs(icmpp.un.echo.sequence);
#line 294
                      tmp___14 = time((time_t *)((void *)0));
                      }
#line 294
                      return ((int )((time_t )((i - (int )tmp___13) * timeout) + (tmp___14 - tm)));
                    } else {
#line 292
                      goto _L___2;
                    }
                  } else {
#line 292
                    goto _L___2;
                  }
                } else {
#line 292
                  goto _L___2;
                }
              } else {
                _L___2: /* CIL Label */ 
                {
#line 297
                tmp___15 = icmp4_errcmp___1((char *)(& icmpd), 8, & to.sin_addr, buf,
                                            len, 3);
                }
#line 297
                if (tmp___15) {
#line 299
                  return (-1);
                } else {
                  {
#line 297
                  tmp___16 = icmp4_errcmp___1((char *)(& icmpd), 8, & to.sin_addr,
                                              buf, len, 11);
                  }
#line 297
                  if (tmp___16) {
#line 299
                    return (-1);
                  }
                }
              }
            }
          }
        } else {
#line 305
          return (-1);
        }
      } else {
#line 309
        icmp_errs___1 += (unsigned long volatile   )1;
#line 309
        if (icmp_errs___1 <= (unsigned long volatile   )10) {
          {
#line 310
          log_message(3, "Unhandled poll/select event in ping4() at %s, line %d.",
                      "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/test/../icmp.c",
                      310);
          }
        }
#line 312
        return (-1);
      }
      {
#line 314
      tmp___20 = time((time_t *)((void *)0));
#line 314
      tpassed = tmp___20 - tm;
      }
#line 226
      if (! (tpassed < (long )timeout)) {
#line 226
        goto while_break___1;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
#line 187
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 317
  return (-1);
}
}
#line 111 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/test/../thread.h"
__inline static int ( __attribute__((__always_inline__)) usleep_r)(unsigned long useconds ) ;
#line 60 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/test/../helpers.h"
__inline static unsigned int ( __attribute__((__always_inline__)) rhnlen)(unsigned char const   *rhn ) ;
#line 180
__inline static ssize_t ( __attribute__((__always_inline__)) write_all)(int fd , void const   *data ,
                                                                        size_t n ) ;
#line 232
__inline static int ( __attribute__((__always_inline__)) strncp)(char *dst , char const   *src ,
                                                                 size_t dstsz ) ;
#line 86 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/test/../netdev.c"
static unsigned long volatile   socketopen_errs___2  =    (unsigned long volatile   )0;
#line 96 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/test/../netdev.c"
static unsigned long volatile   isdn_errs___2  =    (unsigned long volatile   )0;
#line 61 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/test/../servers.h"
__inline static int ( __attribute__((__always_inline__)) is_interrupted_servstat_thread)(void) ;
#line 69 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/test/../icmp.c"
static unsigned long volatile   icmp_errs___2  =    (unsigned long volatile   )0;
#line 136 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/test/../icmp.c"
static int icmp4_errcmp___2(char *packet , int plen , struct in_addr *to , char *errmsg ,
                            int elen , int errtype ) 
{ 
  struct iphdr iph ;
  struct icmphdr icmph ;
  struct iphdr eiph ;
  char *data ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 144
  if ((unsigned long )elen < sizeof(struct iphdr )) {
#line 145
    return (0);
  }
  {
#line 146
  memcpy((void */* __restrict  */)(& iph), (void const   */* __restrict  */)errmsg,
         sizeof(iph));
  }
#line 147
  if ((int )iph.protocol != 1) {
#line 148
    return (0);
  } else
#line 147
  if ((unsigned long )elen < (unsigned long )(iph.ihl * 4U + 8U) + sizeof(eiph)) {
#line 148
    return (0);
  }
#line 149
  if (! (sizeof(icmph) >= 8UL)) {
    {
#line 149
    log_message(3, "%s:%d: %s", "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/test/../icmp.c",
                149, "icmp4_errcmp: ICMP_BASEHDR_LEN botched");
#line 149
    pdnsd_exit();
    }
  }
  {
#line 150
  memcpy((void */* __restrict  */)(& icmph), (void const   */* __restrict  */)(errmsg + iph.ihl * 4U),
         (size_t )8);
#line 151
  memcpy((void */* __restrict  */)(& eiph), (void const   */* __restrict  */)((errmsg + iph.ihl * 4U) + 8),
         sizeof(eiph));
  }
#line 152
  if ((unsigned int )elen < ((iph.ihl * 4U + 8U) + eiph.ihl * 4U) + 8U) {
#line 153
    return (0);
  }
#line 154
  data = ((errmsg + iph.ihl * 4U) + 8) + eiph.ihl * 4U;
#line 155
  if ((int )icmph.type == errtype) {
    {
#line 155
    tmp = memcmp((void const   *)(& to->s_addr), (void const   *)(& eiph.daddr), sizeof(to->s_addr));
    }
#line 155
    if (tmp == 0) {
#line 155
      if (plen < 8) {
#line 155
        tmp___0 = plen;
      } else {
#line 155
        tmp___0 = 8;
      }
      {
#line 155
      tmp___1 = memcmp((void const   *)data, (void const   *)packet, (size_t )tmp___0);
      }
#line 155
      if (tmp___1 == 0) {
#line 155
        tmp___2 = 1;
      } else {
#line 155
        tmp___2 = 0;
      }
    } else {
#line 155
      tmp___2 = 0;
    }
  } else {
#line 155
    tmp___2 = 0;
  }
#line 155
  return (tmp___2);
}
}
#line 160 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/test/../icmp.c"
static int ping4___2(struct in_addr addr , int timeout , int rep ) 
{ 
  int i ;
  int isock ;
  struct icmp_filter f ;
  unsigned short id ;
  unsigned short tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  struct sockaddr_in from ;
  struct sockaddr_in to ;
  struct icmphdr icmpd ;
  unsigned long sum ;
  uint16_t *ptr ;
  long tm ;
  long tpassed ;
  int j ;
  uint16_t *tmp___3 ;
  int *tmp___4 ;
  char *tmp___5 ;
  ssize_t tmp___6 ;
  int psres ;
  struct pollfd pfd ;
  int tmp___7 ;
  long tmp___8 ;
  int *tmp___9 ;
  char *tmp___10 ;
  int *tmp___11 ;
  int tmp___12 ;
  char buf[1024] ;
  socklen_t sl ;
  int len ;
  struct iphdr iph ;
  struct icmphdr icmpp ;
  uint16_t tmp___13 ;
  time_t tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  uint16_t tmp___17 ;
  uint16_t tmp___18 ;
  ssize_t tmp___19 ;
  time_t tmp___20 ;

  {
  {
#line 167
  tmp = get_rand16();
#line 167
  id = tmp;
#line 169
  isock = (int )ping_isocket;
#line 178
  f.data = 4294965238U;
#line 179
  tmp___2 = setsockopt(isock, 255, 1, (void const   *)(& f), (socklen_t )sizeof(f));
  }
#line 179
  if (tmp___2 == -1) {
#line 180
    icmp_errs___2 += (unsigned long volatile   )1;
#line 180
    if (icmp_errs___2 <= (unsigned long volatile   )10) {
      {
#line 181
      tmp___0 = __errno_location();
#line 181
      tmp___1 = strerror(*tmp___0);
#line 181
      log_message(4, "icmp ping: setsockopt() failed: %s", tmp___1);
      }
    }
#line 183
    return (-1);
  }
#line 187
  i = 0;
  {
#line 187
  while (1) {
    while_continue: /* CIL Label */ ;
#line 187
    if (! (i < rep)) {
#line 187
      goto while_break;
    }
    {
#line 195
    icmpd.type = (__u8 )8;
#line 196
    icmpd.code = (__u8 )0;
#line 197
    icmpd.checksum = (__sum16 )0;
#line 198
    icmpd.un.echo.id = htons(id);
#line 199
    icmpd.un.echo.sequence = htons((uint16_t )i);
#line 203
    ptr = (uint16_t *)(& icmpd);
#line 204
    sum = 0UL;
#line 206
    j = 0;
    }
    {
#line 206
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 206
      if (! (j < 4)) {
#line 206
        goto while_break___0;
      }
#line 207
      tmp___3 = ptr;
#line 207
      ptr ++;
#line 207
      sum += (unsigned long )*tmp___3;
#line 206
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 209
    sum = (sum >> 16) + (sum & 65535UL);
#line 210
    sum += sum >> 16;
#line 211
    icmpd.checksum = (__sum16 )(~ sum);
#line 213
    memset((void *)(& to), 0, sizeof(to));
#line 214
    to.sin_family = (sa_family_t )2;
#line 215
    to.sin_port = (in_port_t )0;
#line 216
    to.sin_addr = addr;
#line 218
    tmp___6 = sendto(isock, (void const   *)(& icmpd), (size_t )8, 0, (struct sockaddr  const  */* __restrict  */)((struct sockaddr *)(& to)),
                     (socklen_t )sizeof(to));
    }
#line 218
    if (tmp___6 == -1L) {
#line 219
      icmp_errs___2 += (unsigned long volatile   )1;
#line 219
      if (icmp_errs___2 <= (unsigned long volatile   )10) {
        {
#line 220
        tmp___4 = __errno_location();
#line 220
        tmp___5 = strerror(*tmp___4);
#line 220
        log_message(4, "icmp ping: sendto() failed: %s.", tmp___5);
        }
      }
#line 222
      return (-1);
    }
    {
#line 225
    tm = time((time_t *)((void *)0));
#line 225
    tpassed = 0L;
    }
    {
#line 226
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 248
      pfd.fd = isock;
#line 249
      pfd.events = (short)1;
#line 254
      tmp___7 = is_interrupted_servstat_thread();
      }
#line 254
      if (tmp___7) {
#line 255
        if (debug_p) {
          {
#line 255
          debug_msg(0, "server status thread interrupted.\n");
          }
        }
#line 256
        return (-1);
      }
#line 258
      if ((long )timeout > tpassed) {
#line 258
        tmp___8 = ((long )timeout - tpassed) * 1000L;
      } else {
#line 258
        tmp___8 = 0L;
      }
      {
#line 258
      psres = poll(& pfd, (nfds_t )1, (int )tmp___8);
      }
#line 261
      if (psres < 0) {
        {
#line 262
        tmp___11 = __errno_location();
        }
#line 262
        if (*tmp___11 == 4) {
          {
#line 262
          tmp___12 = is_interrupted_servstat_thread();
          }
#line 262
          if (tmp___12) {
#line 263
            if (debug_p) {
              {
#line 263
              debug_msg(0, "poll/select interrupted in server status thread.\n");
              }
            }
          } else {
#line 262
            goto _L;
          }
        } else {
          _L: /* CIL Label */ 
#line 265
          icmp_errs___2 += (unsigned long volatile   )1;
#line 265
          if (icmp_errs___2 <= (unsigned long volatile   )10) {
            {
#line 266
            tmp___9 = __errno_location();
#line 266
            tmp___10 = strerror(*tmp___9);
#line 266
            log_message(4, "poll/select failed: %s", tmp___10);
            }
          }
        }
#line 268
        return (-1);
      }
#line 270
      if (psres == 0) {
#line 271
        goto while_break___1;
      }
#line 276
      if ((int )pfd.revents & 9) {
        {
#line 280
        sl = (socklen_t )sizeof(from);
#line 283
        tmp___19 = recvfrom(isock, (void */* __restrict  */)(& buf), sizeof(buf),
                            0, (struct sockaddr */* __restrict  */)((struct sockaddr *)(& from)),
                            (socklen_t */* __restrict  */)(& sl));
#line 283
        len = (int )tmp___19;
        }
#line 283
        if (len != -1) {
#line 284
          if ((unsigned long )len > sizeof(struct iphdr )) {
            {
#line 287
            memcpy((void */* __restrict  */)(& iph), (void const   */* __restrict  */)(buf),
                   sizeof(iph));
            }
#line 288
            if ((unsigned int )len - iph.ihl * 4U >= 8U) {
              {
#line 291
              memcpy((void */* __restrict  */)(& icmpp), (void const   */* __restrict  */)((uint32_t *)(buf) + iph.ihl),
                     sizeof(icmpp));
              }
#line 292
              if (iph.saddr == addr.s_addr) {
#line 292
                if ((int )icmpp.type == 0) {
                  {
#line 292
                  tmp___17 = ntohs(icmpp.un.echo.id);
                  }
#line 292
                  if ((int )tmp___17 == (int )id) {
                    {
#line 292
                    tmp___18 = ntohs(icmpp.un.echo.sequence);
                    }
#line 292
                    if ((int )tmp___18 <= i) {
                      {
#line 294
                      tmp___13 = ntohs(icmpp.un.echo.sequence);
#line 294
                      tmp___14 = time((time_t *)((void *)0));
                      }
#line 294
                      return ((int )((time_t )((i - (int )tmp___13) * timeout) + (tmp___14 - tm)));
                    } else {
#line 292
                      goto _L___2;
                    }
                  } else {
#line 292
                    goto _L___2;
                  }
                } else {
#line 292
                  goto _L___2;
                }
              } else {
                _L___2: /* CIL Label */ 
                {
#line 297
                tmp___15 = icmp4_errcmp___2((char *)(& icmpd), 8, & to.sin_addr, buf,
                                            len, 3);
                }
#line 297
                if (tmp___15) {
#line 299
                  return (-1);
                } else {
                  {
#line 297
                  tmp___16 = icmp4_errcmp___2((char *)(& icmpd), 8, & to.sin_addr,
                                              buf, len, 11);
                  }
#line 297
                  if (tmp___16) {
#line 299
                    return (-1);
                  }
                }
              }
            }
          }
        } else {
#line 305
          return (-1);
        }
      } else {
#line 309
        icmp_errs___2 += (unsigned long volatile   )1;
#line 309
        if (icmp_errs___2 <= (unsigned long volatile   )10) {
          {
#line 310
          log_message(3, "Unhandled poll/select event in ping4() at %s, line %d.",
                      "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/test/../icmp.c",
                      310);
          }
        }
#line 312
        return (-1);
      }
      {
#line 314
      tmp___20 = time((time_t *)((void *)0));
#line 314
      tpassed = tmp___20 - tm;
      }
#line 226
      if (! (tpassed < (long )timeout)) {
#line 226
        goto while_break___1;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
#line 187
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 317
  return (-1);
}
}
#line 111 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/test/../thread.h"
__inline static int ( __attribute__((__always_inline__)) usleep_r)(unsigned long useconds ) ;
#line 60 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/test/../helpers.h"
__inline static unsigned int ( __attribute__((__always_inline__)) rhnlen)(unsigned char const   *rhn ) ;
#line 180
__inline static ssize_t ( __attribute__((__always_inline__)) write_all)(int fd , void const   *data ,
                                                                        size_t n ) ;
#line 169 "/usr/include/stdio.h"
extern struct _IO_FILE *stdout ;
#line 689
extern int fputs(char const   * __restrict  __s , FILE * __restrict  __stream ) ;
#line 715
extern size_t fwrite(void const   * __restrict  __ptr , size_t __size , size_t __n ,
                     FILE * __restrict  __s ) ;
#line 846
extern void perror(char const   *__s ) ;
#line 183 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) long ( __attribute__((__nonnull__(1), __leaf__)) strtol)(char const   * __restrict  __nptr ,
                                                                                              char ** __restrict  __endptr ,
                                                                                              int __base ) ;
#line 144 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 534
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcasecmp)(char const   *__s1 ,
                                                                                                   char const   *__s2 )  __attribute__((__pure__)) ;
#line 137 "/usr/include/x86_64-linux-gnu/sys/socket.h"
extern int connect(int __fd , struct sockaddr  const  * __restrict  __addr , socklen_t __len ) ;
#line 360 "/usr/include/unistd.h"
extern ssize_t read(int __fd , void *__buf , size_t __nbytes ) ;
#line 377 "/usr/include/netinet/in.h"
extern  __attribute__((__nothrow__)) uint32_t ( __attribute__((__leaf__)) htonl)(uint32_t __hostlong )  __attribute__((__const__)) ;
#line 58 "/usr/include/arpa/inet.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) inet_pton)(int __af ,
                                                                                char const   * __restrict  __cp ,
                                                                                void * __restrict  __buf ) ;
#line 182 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/pdnsd-ctl/../rr_types.h"
unsigned short const   rrcachiterlist[47] ;
#line 397
char const   * const  rrnames[51] ;
#line 533
int rr_tp_byname(char *name ) ;
#line 180 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/pdnsd-ctl/../helpers.h"
__inline static ssize_t ( __attribute__((__always_inline__)) write_all)(int fd , void const   *data ,
                                                                        size_t n ) ;
#line 56 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/pdnsd-ctl/pdnsd-ctl.c"
static short verbose  =    (short)1;
#line 67 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/pdnsd-ctl/pdnsd-ctl.c"
static cmd_s const   top_cmds[15]  = 
#line 67
  {      {(char *)"help", 13}, 
        {(char *)"version", 14}, 
        {(char *)"list-rrtypes", 12}, 
        {(char *)"status", 1}, 
        {(char *)"server", 2}, 
        {(char *)"record", 3}, 
        {(char *)"source", 4}, 
        {(char *)"add", 5}, 
        {(char *)"neg", 6}, 
        {(char *)"config", 7}, 
        {(char *)"include", 8}, 
        {(char *)"eval", 9}, 
        {(char *)"empty-cache", 10}, 
        {(char *)"dump", 11}, 
        {(char *)((void *)0), 0}};
#line 75 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/pdnsd-ctl/pdnsd-ctl.c"
static cmd_s const   server_cmds[4]  = {      {(char *)"up", 1}, 
        {(char *)"down", 2}, 
        {(char *)"retest", 3}, 
        {(char *)((void *)0), 0}};
#line 76 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/pdnsd-ctl/pdnsd-ctl.c"
static cmd_s const   record_cmds[3]  = {      {(char *)"delete", 1}, 
        {(char *)"invalidate", 2}, 
        {(char *)((void *)0), 0}};
#line 77 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/pdnsd-ctl/pdnsd-ctl.c"
static cmd_s const   onoff_cmds[3]  = {      {(char *)"off", 0}, 
        {(char *)"on", 1}, 
        {(char *)((void *)0), 0}};
#line 78 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/pdnsd-ctl/pdnsd-ctl.c"
static cmd_s const   rectype_cmds[7]  = {      {(char *)"a", 1}, 
        {(char *)"aaaa", 28}, 
        {(char *)"ptr", 12}, 
        {(char *)"cname", 5}, 
        {(char *)"mx", 15}, 
        {(char *)"ns", 2}, 
        {(char *)((void *)0), 0}};
#line 84 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/pdnsd-ctl/pdnsd-ctl.c"
static char const   version_message[38]  = 
#line 84
  {      (char const   )'p',      (char const   )'d',      (char const   )'n',      (char const   )'s', 
        (char const   )'d',      (char const   )'-',      (char const   )'c',      (char const   )'t', 
        (char const   )'l',      (char const   )',',      (char const   )' ',      (char const   )'v', 
        (char const   )'e',      (char const   )'r',      (char const   )'s',      (char const   )'i', 
        (char const   )'o',      (char const   )'n',      (char const   )' ',      (char const   )'p', 
        (char const   )'d',      (char const   )'n',      (char const   )'s',      (char const   )'d', 
        (char const   )'-',      (char const   )'1',      (char const   )'.',      (char const   )'2', 
        (char const   )'.',      (char const   )'9',      (char const   )'a',      (char const   )'-', 
        (char const   )'p',      (char const   )'a',      (char const   )'r',      (char const   )'\n', 
        (char const   )'\n',      (char const   )'\000'};
#line 87 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/pdnsd-ctl/pdnsd-ctl.c"
static char const   license_statement[782]  = 
#line 87
  {      (char const   )'C',      (char const   )'o',      (char const   )'p',      (char const   )'y', 
        (char const   )'r',      (char const   )'i',      (char const   )'g',      (char const   )'h', 
        (char const   )'t',      (char const   )' ',      (char const   )'(',      (char const   )'C', 
        (char const   )')',      (char const   )' ',      (char const   )'2',      (char const   )'0', 
        (char const   )'0',      (char const   )'0',      (char const   )',',      (char const   )' ', 
        (char const   )'2',      (char const   )'0',      (char const   )'0',      (char const   )'1', 
        (char const   )' ',      (char const   )'T',      (char const   )'h',      (char const   )'o', 
        (char const   )'m',      (char const   )'a',      (char const   )'s',      (char const   )' ', 
        (char const   )'M',      (char const   )'o',      (char const   )'e',      (char const   )'s', 
        (char const   )'t',      (char const   )'l',      (char const   )'\n',      (char const   )'C', 
        (char const   )'o',      (char const   )'p',      (char const   )'y',      (char const   )'r', 
        (char const   )'i',      (char const   )'g',      (char const   )'h',      (char const   )'t', 
        (char const   )' ',      (char const   )'(',      (char const   )'C',      (char const   )')', 
        (char const   )' ',      (char const   )'2',      (char const   )'0',      (char const   )'0', 
        (char const   )'2',      (char const   )',',      (char const   )' ',      (char const   )'2', 
        (char const   )'0',      (char const   )'0',      (char const   )'3',      (char const   )',', 
        (char const   )' ',      (char const   )'2',      (char const   )'0',      (char const   )'0', 
        (char const   )'4',      (char const   )',',      (char const   )' ',      (char const   )'2', 
        (char const   )'0',      (char const   )'0',      (char const   )'5',      (char const   )',', 
        (char const   )' ',      (char const   )'2',      (char const   )'0',      (char const   )'0', 
        (char const   )'7',      (char const   )',',      (char const   )' ',      (char const   )'2', 
        (char const   )'0',      (char const   )'0',      (char const   )'8',      (char const   )',', 
        (char const   )' ',      (char const   )'2',      (char const   )'0',      (char const   )'0', 
        (char const   )'9',      (char const   )',',      (char const   )' ',      (char const   )'2', 
        (char const   )'0',      (char const   )'1',      (char const   )'0',      (char const   )',', 
        (char const   )' ',      (char const   )'2',      (char const   )'0',      (char const   )'1', 
        (char const   )'1',      (char const   )' ',      (char const   )'P',      (char const   )'a', 
        (char const   )'u',      (char const   )'l',      (char const   )' ',      (char const   )'A', 
        (char const   )'.',      (char const   )' ',      (char const   )'R',      (char const   )'o', 
        (char const   )'m',      (char const   )'b',      (char const   )'o',      (char const   )'u', 
        (char const   )'t',      (char const   )'s',      (char const   )'\n',      (char const   )'\n', 
        (char const   )'T',      (char const   )'h',      (char const   )'i',      (char const   )'s', 
        (char const   )' ',      (char const   )'p',      (char const   )'r',      (char const   )'o', 
        (char const   )'g',      (char const   )'r',      (char const   )'a',      (char const   )'m', 
        (char const   )' ',      (char const   )'i',      (char const   )'s',      (char const   )' ', 
        (char const   )'p',      (char const   )'a',      (char const   )'r',      (char const   )'t', 
        (char const   )' ',      (char const   )'o',      (char const   )'f',      (char const   )' ', 
        (char const   )'t',      (char const   )'h',      (char const   )'e',      (char const   )' ', 
        (char const   )'p',      (char const   )'d',      (char const   )'n',      (char const   )'s', 
        (char const   )'d',      (char const   )' ',      (char const   )'p',      (char const   )'a', 
        (char const   )'c',      (char const   )'k',      (char const   )'a',      (char const   )'g', 
        (char const   )'e',      (char const   )'.',      (char const   )'\n',      (char const   )'\n', 
        (char const   )'p',      (char const   )'d',      (char const   )'n',      (char const   )'s', 
        (char const   )'d',      (char const   )' ',      (char const   )'i',      (char const   )'s', 
        (char const   )' ',      (char const   )'f',      (char const   )'r',      (char const   )'e', 
        (char const   )'e',      (char const   )' ',      (char const   )'s',      (char const   )'o', 
        (char const   )'f',      (char const   )'t',      (char const   )'w',      (char const   )'a', 
        (char const   )'r',      (char const   )'e',      (char const   )';',      (char const   )' ', 
        (char const   )'y',      (char const   )'o',      (char const   )'u',      (char const   )' ', 
        (char const   )'c',      (char const   )'a',      (char const   )'n',      (char const   )' ', 
        (char const   )'r',      (char const   )'e',      (char const   )'d',      (char const   )'i', 
        (char const   )'s',      (char const   )'t',      (char const   )'r',      (char const   )'i', 
        (char const   )'b',      (char const   )'u',      (char const   )'t',      (char const   )'e', 
        (char const   )' ',      (char const   )'i',      (char const   )'t',      (char const   )' ', 
        (char const   )'a',      (char const   )'n',      (char const   )'d',      (char const   )'/', 
        (char const   )'o',      (char const   )'r',      (char const   )' ',      (char const   )'m', 
        (char const   )'o',      (char const   )'d',      (char const   )'i',      (char const   )'f', 
        (char const   )'y',      (char const   )'\n',      (char const   )'i',      (char const   )'t', 
        (char const   )' ',      (char const   )'u',      (char const   )'n',      (char const   )'d', 
        (char const   )'e',      (char const   )'r',      (char const   )' ',      (char const   )'t', 
        (char const   )'h',      (char const   )'e',      (char const   )' ',      (char const   )'t', 
        (char const   )'e',      (char const   )'r',      (char const   )'m',      (char const   )'s', 
        (char const   )' ',      (char const   )'o',      (char const   )'f',      (char const   )' ', 
        (char const   )'t',      (char const   )'h',      (char const   )'e',      (char const   )' ', 
        (char const   )'G',      (char const   )'N',      (char const   )'U',      (char const   )' ', 
        (char const   )'G',      (char const   )'e',      (char const   )'n',      (char const   )'e', 
        (char const   )'r',      (char const   )'a',      (char const   )'l',      (char const   )' ', 
        (char const   )'P',      (char const   )'u',      (char const   )'b',      (char const   )'l', 
        (char const   )'i',      (char const   )'c',      (char const   )' ',      (char const   )'L', 
        (char const   )'i',      (char const   )'c',      (char const   )'e',      (char const   )'n', 
        (char const   )'s',      (char const   )'e',      (char const   )' ',      (char const   )'a', 
        (char const   )'s',      (char const   )' ',      (char const   )'p',      (char const   )'u', 
        (char const   )'b',      (char const   )'l',      (char const   )'i',      (char const   )'s', 
        (char const   )'h',      (char const   )'e',      (char const   )'d',      (char const   )' ', 
        (char const   )'b',      (char const   )'y',      (char const   )'\n',      (char const   )'t', 
        (char const   )'h',      (char const   )'e',      (char const   )' ',      (char const   )'F', 
        (char const   )'r',      (char const   )'e',      (char const   )'e',      (char const   )' ', 
        (char const   )'S',      (char const   )'o',      (char const   )'f',      (char const   )'t', 
        (char const   )'w',      (char const   )'a',      (char const   )'r',      (char const   )'e', 
        (char const   )' ',      (char const   )'F',      (char const   )'o',      (char const   )'u', 
        (char const   )'n',      (char const   )'d',      (char const   )'a',      (char const   )'t', 
        (char const   )'i',      (char const   )'o',      (char const   )'n',      (char const   )';', 
        (char const   )' ',      (char const   )'e',      (char const   )'i',      (char const   )'t', 
        (char const   )'h',      (char const   )'e',      (char const   )'r',      (char const   )' ', 
        (char const   )'v',      (char const   )'e',      (char const   )'r',      (char const   )'s', 
        (char const   )'i',      (char const   )'o',      (char const   )'n',      (char const   )' ', 
        (char const   )'3',      (char const   )' ',      (char const   )'o',      (char const   )'f', 
        (char const   )' ',      (char const   )'t',      (char const   )'h',      (char const   )'e', 
        (char const   )' ',      (char const   )'L',      (char const   )'i',      (char const   )'c', 
        (char const   )'e',      (char const   )'n',      (char const   )'s',      (char const   )'e', 
        (char const   )',',      (char const   )' ',      (char const   )'o',      (char const   )'r', 
        (char const   )'\n',      (char const   )'(',      (char const   )'a',      (char const   )'t', 
        (char const   )' ',      (char const   )'y',      (char const   )'o',      (char const   )'u', 
        (char const   )'r',      (char const   )' ',      (char const   )'o',      (char const   )'p', 
        (char const   )'t',      (char const   )'i',      (char const   )'o',      (char const   )'n', 
        (char const   )')',      (char const   )' ',      (char const   )'a',      (char const   )'n', 
        (char const   )'y',      (char const   )' ',      (char const   )'l',      (char const   )'a', 
        (char const   )'t',      (char const   )'e',      (char const   )'r',      (char const   )' ', 
        (char const   )'v',      (char const   )'e',      (char const   )'r',      (char const   )'s', 
        (char const   )'i',      (char const   )'o',      (char const   )'n',      (char const   )'.', 
        (char const   )'\n',      (char const   )'\n',      (char const   )'p',      (char const   )'d', 
        (char const   )'n',      (char const   )'s',      (char const   )'d',      (char const   )' ', 
        (char const   )'i',      (char const   )'s',      (char const   )' ',      (char const   )'d', 
        (char const   )'i',      (char const   )'s',      (char const   )'t',      (char const   )'r', 
        (char const   )'i',      (char const   )'b',      (char const   )'u',      (char const   )'t', 
        (char const   )'e',      (char const   )'d',      (char const   )' ',      (char const   )'i', 
        (char const   )'n',      (char const   )' ',      (char const   )'t',      (char const   )'h', 
        (char const   )'e',      (char const   )' ',      (char const   )'h',      (char const   )'o', 
        (char const   )'p',      (char const   )'e',      (char const   )' ',      (char const   )'t', 
        (char const   )'h',      (char const   )'a',      (char const   )'t',      (char const   )' ', 
        (char const   )'i',      (char const   )'t',      (char const   )' ',      (char const   )'w', 
        (char const   )'i',      (char const   )'l',      (char const   )'l',      (char const   )' ', 
        (char const   )'b',      (char const   )'e',      (char const   )' ',      (char const   )'u', 
        (char const   )'s',      (char const   )'e',      (char const   )'f',      (char const   )'u', 
        (char const   )'l',      (char const   )',',      (char const   )'\n',      (char const   )'b', 
        (char const   )'u',      (char const   )'t',      (char const   )' ',      (char const   )'W', 
        (char const   )'I',      (char const   )'T',      (char const   )'H',      (char const   )'O', 
        (char const   )'U',      (char const   )'T',      (char const   )' ',      (char const   )'A', 
        (char const   )'N',      (char const   )'Y',      (char const   )' ',      (char const   )'W', 
        (char const   )'A',      (char const   )'R',      (char const   )'R',      (char const   )'A', 
        (char const   )'N',      (char const   )'T',      (char const   )'Y',      (char const   )';', 
        (char const   )' ',      (char const   )'w',      (char const   )'i',      (char const   )'t', 
        (char const   )'h',      (char const   )'o',      (char const   )'u',      (char const   )'t', 
        (char const   )' ',      (char const   )'e',      (char const   )'v',      (char const   )'e', 
        (char const   )'n',      (char const   )' ',      (char const   )'t',      (char const   )'h', 
        (char const   )'e',      (char const   )' ',      (char const   )'i',      (char const   )'m', 
        (char const   )'p',      (char const   )'l',      (char const   )'i',      (char const   )'e', 
        (char const   )'d',      (char const   )' ',      (char const   )'w',      (char const   )'a', 
        (char const   )'r',      (char const   )'r',      (char const   )'a',      (char const   )'n', 
        (char const   )'t',      (char const   )'y',      (char const   )' ',      (char const   )'o', 
        (char const   )'f',      (char const   )'\n',      (char const   )'M',      (char const   )'E', 
        (char const   )'R',      (char const   )'C',      (char const   )'H',      (char const   )'A', 
        (char const   )'N',      (char const   )'T',      (char const   )'A',      (char const   )'B', 
        (char const   )'I',      (char const   )'L',      (char const   )'I',      (char const   )'T', 
        (char const   )'Y',      (char const   )' ',      (char const   )'o',      (char const   )'r', 
        (char const   )' ',      (char const   )'F',      (char const   )'I',      (char const   )'T', 
        (char const   )'N',      (char const   )'E',      (char const   )'S',      (char const   )'S', 
        (char const   )' ',      (char const   )'F',      (char const   )'O',      (char const   )'R', 
        (char const   )' ',      (char const   )'A',      (char const   )' ',      (char const   )'P', 
        (char const   )'A',      (char const   )'R',      (char const   )'T',      (char const   )'I', 
        (char const   )'C',      (char const   )'U',      (char const   )'L',      (char const   )'A', 
        (char const   )'R',      (char const   )' ',      (char const   )'P',      (char const   )'U', 
        (char const   )'R',      (char const   )'P',      (char const   )'O',      (char const   )'S', 
        (char const   )'E',      (char const   )'.',      (char const   )' ',      (char const   )' ', 
        (char const   )'S',      (char const   )'e',      (char const   )'e',      (char const   )' ', 
        (char const   )'t',      (char const   )'h',      (char const   )'e',      (char const   )'\n', 
        (char const   )'G',      (char const   )'N',      (char const   )'U',      (char const   )' ', 
        (char const   )'G',      (char const   )'e',      (char const   )'n',      (char const   )'e', 
        (char const   )'r',      (char const   )'a',      (char const   )'l',      (char const   )' ', 
        (char const   )'P',      (char const   )'u',      (char const   )'b',      (char const   )'l', 
        (char const   )'i',      (char const   )'c',      (char const   )' ',      (char const   )'L', 
        (char const   )'i',      (char const   )'c',      (char const   )'e',      (char const   )'n', 
        (char const   )'s',      (char const   )'e',      (char const   )' ',      (char const   )'f', 
        (char const   )'o',      (char const   )'r',      (char const   )' ',      (char const   )'m', 
        (char const   )'o',      (char const   )'r',      (char const   )'e',      (char const   )' ', 
        (char const   )'d',      (char const   )'e',      (char const   )'t',      (char const   )'a', 
        (char const   )'i',      (char const   )'l',      (char const   )'s',      (char const   )'.', 
        (char const   )'\n',      (char const   )'\n',      (char const   )'Y',      (char const   )'o', 
        (char const   )'u',      (char const   )' ',      (char const   )'s',      (char const   )'h', 
        (char const   )'o',      (char const   )'u',      (char const   )'l',      (char const   )'d', 
        (char const   )' ',      (char const   )'h',      (char const   )'a',      (char const   )'v', 
        (char const   )'e',      (char const   )' ',      (char const   )'r',      (char const   )'e', 
        (char const   )'c',      (char const   )'e',      (char const   )'i',      (char const   )'v', 
        (char const   )'e',      (char const   )'d',      (char const   )' ',      (char const   )'a', 
        (char const   )' ',      (char const   )'c',      (char const   )'o',      (char const   )'p', 
        (char const   )'y',      (char const   )' ',      (char const   )'o',      (char const   )'f', 
        (char const   )' ',      (char const   )'t',      (char const   )'h',      (char const   )'e', 
        (char const   )' ',      (char const   )'G',      (char const   )'N',      (char const   )'U', 
        (char const   )' ',      (char const   )'G',      (char const   )'e',      (char const   )'n', 
        (char const   )'e',      (char const   )'r',      (char const   )'a',      (char const   )'l', 
        (char const   )' ',      (char const   )'P',      (char const   )'u',      (char const   )'b', 
        (char const   )'l',      (char const   )'i',      (char const   )'c',      (char const   )' ', 
        (char const   )'L',      (char const   )'i',      (char const   )'c',      (char const   )'e', 
        (char const   )'n',      (char const   )'s',      (char const   )'e',      (char const   )'\n', 
        (char const   )'a',      (char const   )'l',      (char const   )'o',      (char const   )'n', 
        (char const   )'g',      (char const   )' ',      (char const   )'w',      (char const   )'i', 
        (char const   )'t',      (char const   )'h',      (char const   )' ',      (char const   )'p', 
        (char const   )'d',      (char const   )'s',      (char const   )'n',      (char const   )'d', 
        (char const   )';',      (char const   )' ',      (char const   )'s',      (char const   )'e', 
        (char const   )'e',      (char const   )' ',      (char const   )'t',      (char const   )'h', 
        (char const   )'e',      (char const   )' ',      (char const   )'f',      (char const   )'i', 
        (char const   )'l',      (char const   )'e',      (char const   )' ',      (char const   )'C', 
        (char const   )'O',      (char const   )'P',      (char const   )'Y',      (char const   )'I', 
        (char const   )'N',      (char const   )'G',      (char const   )'.',      (char const   )' ', 
        (char const   )' ',      (char const   )'I',      (char const   )'f',      (char const   )' ', 
        (char const   )'n',      (char const   )'o',      (char const   )'t',      (char const   )',', 
        (char const   )' ',      (char const   )'s',      (char const   )'e',      (char const   )'e', 
        (char const   )'\n',      (char const   )'<',      (char const   )'h',      (char const   )'t', 
        (char const   )'t',      (char const   )'p',      (char const   )':',      (char const   )'/', 
        (char const   )'/',      (char const   )'w',      (char const   )'w',      (char const   )'w', 
        (char const   )'.',      (char const   )'g',      (char const   )'n',      (char const   )'u', 
        (char const   )'.',      (char const   )'o',      (char const   )'r',      (char const   )'g', 
        (char const   )'/',      (char const   )'l',      (char const   )'i',      (char const   )'c', 
        (char const   )'e',      (char const   )'n',      (char const   )'s',      (char const   )'e', 
        (char const   )'s',      (char const   )'/',      (char const   )'>',      (char const   )'.', 
        (char const   )'\n',      (char const   )'\000'};
#line 103 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/pdnsd-ctl/pdnsd-ctl.c"
static char const   * const  help_messages[13]  = 
#line 103
  {      (char const   */* const  */)"Usage: pdnsd-ctl [-c cachedir] [-q] <command> [arguments]\n\nCommand-line options:\n-c\tcachedir\n\tSet the cache directory to cachedir (must match pdnsd setting).\n\tThe default is \'/var/cache/pdnsd\'.\n-q\n\tBe quiet unless output is specified by command or something goes wrong.\n\nCommands and needed arguments are:\nhelp\t[no arguments]\n\tPrint this help.\nversion\t[no arguments]\n\tPrint version and license info.\n",      (char const   */* const  */)"status\t[no arguments]\n\tPrint pdnsd\'s status.\n",      (char const   */* const  */)"server\t(index|label)\t(up|down|retest)\t[dns1[,dns2[,...]]]\n\tSet the status of the server with the given index to up or down, or\n\tforce a retest. The index is assigned in the order of definition in\n\tpdnsd.conf starting with 0. Use the status command to see the indexes.\n\tYou can specify the label of a server (that matches the label option)\n\tinstead of an index to make this easier.\n\tYou can specify all instead of an index to perform the action for all\n\tservers registered with pdnsd.\n\tAn optional third argument can be given consisting of a list of IP\n\taddresses separated by commas or spaces. This list will replace the\n\taddresses of name servers used by pdnsd for the given server section.\n\tThis feature is useful for run-time configuration of pdnsd with dynamic\n\tDNS data in scripts called by ppp or DHCP clients. The last argument\n\tmay also be an empty string, which causes existing IP addresses to be\n\tremoved and the corresponding server section to become inactive.\n",      (char const   */* const  */)"record\tname\t(delete|invalidate)\n\tDelete or invalidate the record of the given domain if it is in the\n\tcache.\n", 
        (char const   */* const  */)"source\tfn\towner\t[ttl]\t[(on|off)]\t[noauth]\n\tLoad a hosts-style file. Works like using the pdnsd source\n\tconfiguration section.\n\tOwner and ttl are used as in the source section. ttl has a default\n\tof 900 (it does not need to be specified). The next to last argument\n\tcorresponds to the serve_aliases option, and is off by default.\n\tnoauth is used to make the domains non-authoritative (please\n\tconsult the pdnsd manual for what that means).\n\tfn is the name of the file, which must be readable by pdnsd.\n",      (char const   */* const  */)"add\ta\taddr\tname\t[ttl]\t[noauth]\nadd\taaaa\taddr\tname\t[ttl]\t[noauth]\nadd\tptr\thost\tname\t[ttl]\t[noauth]\nadd\tcname\thost\tname\t[ttl]\t[noauth]\nadd\tmx\thost\tname\tpref\t[ttl]\t[noauth]\nadd\tns\thost\tname\t[ttl]\t[noauth]\n\tAdd a record of the given type to the pdnsd cache, replacing existing\n\trecords for the same name and type. The 2nd argument corresponds\n\tto the value of the option in the rr section that is named like\n\tthe first argument. The addr argument may be a list of IP addresses,\n\tseparated by commas or white space. The ttl is optional, the default is\n\t900 seconds. noauth is used to make the domains non-authoritative.\n\tIf you want no other record than the newly added in the cache, do\n\tpdnsdctl record <name> delete\n\tbefore adding records.\n",      (char const   */* const  */)"neg\tname\t[type]\t[ttl]\n\tAdd a negatively cached record to pdnsd\'s cache, replacing existing\n\trecords for the same name and type. If no type is given, the whole\n\tdomain is cached negatively. For negatively cached records, errors are\n\timmediately returned on a query, without querying other servers first.\n\tThe ttl is optional, the default is 900 seconds.\n",      (char const   */* const  */)"config\t[filename]\n\tReload pdnsd\'s configuration file.\n\tThe config file must be owned by the uid that pdnsd had when it was\n\tstarted, and be readable by pdnsd\'s run_as uid. If no file name is\n\tspecified, the config file used at start up is reloaded.\n", 
        (char const   */* const  */)"include\tfilename\n\tParse the given file as an include file, which may contain the same\n\ttype of sections as a config file, expect for global and server\n\tsections, which are not allowed. This command can be used to add data\n\tto the cache without reconfiguring pdnsd.\n",      (char const   */* const  */)"eval\tstring\n\tParse string as if it were part of pdnsd\'s configuration file.\n\tThe string should hold one or more complete configuration sections,\n\tbut no global and server sections, which are not allowed.\n\tIf multiple strings are given, they will be joined using newline chars\n\tand parsed together.\n",      (char const   */* const  */)"empty-cache\t[[+|-]name ...]\n\tDelete all entries in the cache matching include/exclude rules.\n\tIf no arguments are provided, the cache is completely emptied,\n\tfreeing all existing entries. This also removes \"local\" records,\n\tas defined by the config file. To restore local records, run\n\t\"pdnsd-ctl config\" or \"pdnsd-ctl include filename\"  immediately\n\tafterwards.\n\tIf one or more arguments are provided, these are interpreted as \n\tinclude/exclude names. If an argument starts with a \'+\' the name is to\n\tbe included. If an argument starts with a \'-\' it is to be excluded.\n\tIf an argument does not begin with \'+\' or \'-\', a \'+\' is assumed.\n\tIf the domain name of a cache entry ends in one of the names in the\n\tlist, the first match will determine what happens. If the matching name\n\tis to be included, the cache entry is deleted, otherwise it remains.\n\tIf there are no matches, the default action is not to delete.\n",      (char const   */* const  */)"dump\t[name]\n\tPrint information stored in the cache about name.\n\tIf name begins with a dot and is not the root domain, information\n\tabout the names in the cache ending in name (including name without\n\tthe leading dot) will be printed. If name is missing, information about\n\tall the names in the cache will be printed.\n", 
        (char const   */* const  */)"list-rrtypes\t[no arguments]\n\tList available rr types for the neg command. Note that those are only\n\tused for the neg command, not for add!\n"};
#line 231 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/pdnsd-ctl/pdnsd-ctl.c"
static int open_sock(char const   *cache_dir , uint16_t cmd ) 
{ 
  struct sockaddr_un *sa ;
  unsigned int sa_len ;
  int sock ;
  uint16_t nc ;
  size_t tmp ;
  void *tmp___0 ;
  char *tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  ssize_t tmp___5 ;

  {
  {
#line 238
  sock = socket(1, 1, 0);
  }
#line 238
  if (sock == -1) {
    {
#line 239
    perror("Error: could not open socket");
#line 240
    exit(2);
    }
  }
  {
#line 243
  tmp = strlen(cache_dir);
#line 243
  sa_len = (unsigned int )(((unsigned long )(& ((struct sockaddr_un *)0)->sun_path) + (sizeof("/pdnsd.status") - 1UL)) + tmp);
#line 244
  tmp___0 = __builtin_alloca((unsigned long )(sa_len + 1U));
#line 244
  sa = (struct sockaddr_un *)tmp___0;
#line 245
  sa->sun_family = (sa_family_t )1;
#line 246
  tmp___1 = stpcpy((char */* __restrict  */)(sa->sun_path), (char const   */* __restrict  */)cache_dir);
#line 246
  stpcpy((char */* __restrict  */)tmp___1, (char const   */* __restrict  */)"/pdnsd.status");
#line 248
  tmp___4 = connect(sock, (struct sockaddr  const  */* __restrict  */)((struct sockaddr *)sa),
                    sa_len);
  }
#line 248
  if (tmp___4 == -1) {
    {
#line 249
    tmp___2 = __errno_location();
#line 249
    tmp___3 = strerror(*tmp___2);
#line 249
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error: could not open socket %s: %s\n",
            sa->sun_path, tmp___3);
#line 250
    close(sock);
#line 251
    exit(2);
    }
  }
#line 253
  if (verbose) {
    {
#line 253
    printf((char const   */* __restrict  */)"Opening socket %s\n", sa->sun_path);
    }
  }
  {
#line 257
  nc = htons((uint16_t )((int )cmd | 26624));
#line 259
  tmp___5 = write(sock, (void const   *)(& nc), sizeof(nc));
  }
#line 259
  if ((unsigned long )tmp___5 != sizeof(nc)) {
    {
#line 260
    perror("Error: could not write command code");
#line 261
    close(sock);
#line 262
    exit(2);
    }
  }
#line 265
  return (sock);
}
}
#line 268 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/pdnsd-ctl/pdnsd-ctl.c"
static void send_long(int fd , uint32_t cmd ) 
{ 
  uint32_t nc ;
  uint32_t tmp ;
  ssize_t tmp___0 ;

  {
  {
#line 270
  tmp = htonl(cmd);
#line 270
  nc = tmp;
#line 272
  tmp___0 = write(fd, (void const   *)(& nc), sizeof(nc));
  }
#line 272
  if ((unsigned long )tmp___0 != sizeof(nc)) {
    {
#line 273
    perror("Error: could not write long");
#line 274
    close(fd);
#line 275
    exit(2);
    }
  }
#line 277
  return;
}
}
#line 279 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/pdnsd-ctl/pdnsd-ctl.c"
static void send_short(int fd , uint16_t cmd ) 
{ 
  uint16_t nc ;
  uint16_t tmp ;
  ssize_t tmp___0 ;

  {
  {
#line 281
  tmp = htons(cmd);
#line 281
  nc = tmp;
#line 283
  tmp___0 = write(fd, (void const   *)(& nc), sizeof(nc));
  }
#line 283
  if ((unsigned long )tmp___0 != sizeof(nc)) {
    {
#line 284
    perror("Error: could not write short");
#line 285
    close(fd);
#line 286
    exit(2);
    }
  }
#line 288
  return;
}
}
#line 292 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/pdnsd-ctl/pdnsd-ctl.c"
static void send_string(int fd , char const   *s ) 
{ 
  size_t len ;
  size_t tmp ;
  ssize_t tmp___0 ;

  {
#line 294
  if (s) {
    {
#line 295
    tmp = strlen(s);
#line 295
    len = tmp;
    }
#line 296
    if (len > 65534UL) {
      {
#line 297
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error: send_string: string length (%lu) exceeds maximum (%u).\n",
              len, 65534);
#line 299
      close(fd);
#line 300
      exit(2);
      }
    }
    {
#line 302
    send_short(fd, (uint16_t )len);
#line 303
    tmp___0 = write_all(fd, (void const   *)s, len);
    }
#line 303
    if ((size_t )tmp___0 != len) {
      {
#line 304
      perror("Error: could not write string");
#line 305
      close(fd);
#line 306
      exit(2);
      }
    }
  } else {
    {
#line 310
    send_short(fd, (uint16_t )(~ 0));
    }
  }
#line 311
  return;
}
}
#line 313 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/pdnsd-ctl/pdnsd-ctl.c"
static uint16_t read_short(int fd ) 
{ 
  ssize_t err ;
  uint16_t nc ;
  int *tmp ;
  char *tmp___0 ;
  char const   *tmp___1 ;
  uint16_t tmp___2 ;

  {
  {
#line 318
  err = read(fd, (void *)(& nc), sizeof(nc));
  }
#line 318
  if ((unsigned long )err != sizeof(nc)) {
#line 319
    if (err < 0L) {
      {
#line 319
      tmp = __errno_location();
#line 319
      tmp___0 = strerror(*tmp);
#line 319
      tmp___1 = (char const   *)tmp___0;
      }
    } else {
#line 319
      tmp___1 = "unexpected EOF";
    }
    {
#line 319
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error: could not read short: %s\n",
            tmp___1);
#line 320
    close(fd);
#line 321
    exit(2);
    }
  }
  {
#line 323
  tmp___2 = ntohs(nc);
  }
#line 323
  return (tmp___2);
}
}
#line 329 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/pdnsd-ctl/pdnsd-ctl.c"
static ssize_t copymsgtofile(int fd , FILE *out ) 
{ 
  ssize_t n ;
  ssize_t ntot ;
  char buf[1024] ;
  size_t tmp ;

  {
#line 331
  ntot = (ssize_t )0;
  {
#line 334
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 334
    n = read(fd, (void *)(buf), sizeof(buf));
    }
#line 334
    if (! (n > 0L)) {
#line 334
      goto while_break;
    }
    {
#line 335
    tmp = fwrite((void const   */* __restrict  */)(buf), (size_t )1, (size_t )n, (FILE */* __restrict  */)out);
#line 335
    ntot = (ssize_t )((size_t )ntot + tmp);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 337
  if (n < 0L) {
#line 338
    return (n);
  }
#line 340
  return (ntot);
}
}
#line 343 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/pdnsd-ctl/pdnsd-ctl.c"
static int match_cmd(char const   *cmd , cmd_s const   *cmds ) 
{ 
  int i ;
  int tmp ;

  {
#line 346
  i = 0;
  {
#line 346
  while (1) {
    while_continue: /* CIL Label */ ;
#line 346
    if (! (cmds + i)->name) {
#line 346
      goto while_break;
    }
    {
#line 347
    tmp = strcasecmp(cmd, (char const   *)(cmds + i)->name);
    }
#line 347
    if (tmp == 0) {
#line 348
      return ((int )(cmds + i)->val);
    }
#line 346
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 350
  return (-1);
}
}
#line 184 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/pdnsd-ctl/../rr_types.h"
unsigned short const   rrcachiterlist[47]  = 
#line 184 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/pdnsd-ctl/../rr_types.h"
  {      (unsigned short const   )1,      (unsigned short const   )2,      (unsigned short const   )3,      (unsigned short const   )4, 
        (unsigned short const   )5,      (unsigned short const   )6,      (unsigned short const   )7,      (unsigned short const   )8, 
        (unsigned short const   )9,      (unsigned short const   )10,      (unsigned short const   )11,      (unsigned short const   )12, 
        (unsigned short const   )13,      (unsigned short const   )14,      (unsigned short const   )15,      (unsigned short const   )16, 
        (unsigned short const   )17,      (unsigned short const   )18,      (unsigned short const   )19,      (unsigned short const   )20, 
        (unsigned short const   )21,      (unsigned short const   )22,      (unsigned short const   )23,      (unsigned short const   )24, 
        (unsigned short const   )25,      (unsigned short const   )26,      (unsigned short const   )27,      (unsigned short const   )28, 
        (unsigned short const   )29,      (unsigned short const   )30,      (unsigned short const   )31,      (unsigned short const   )32, 
        (unsigned short const   )33,      (unsigned short const   )34,      (unsigned short const   )35,      (unsigned short const   )36, 
        (unsigned short const   )37,      (unsigned short const   )42,      (unsigned short const   )43,      (unsigned short const   )44, 
        (unsigned short const   )45,      (unsigned short const   )46,      (unsigned short const   )47,      (unsigned short const   )48, 
        (unsigned short const   )49,      (unsigned short const   )50,      (unsigned short const   )51};
#line 399 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/pdnsd-ctl/../rr_types.h"
char const   * const  rrnames[51]  = 
#line 399
  {      (char const   */* const  */)"A",      (char const   */* const  */)"NS",      (char const   */* const  */)"MD",      (char const   */* const  */)"MF", 
        (char const   */* const  */)"CNAME",      (char const   */* const  */)"SOA",      (char const   */* const  */)"MB",      (char const   */* const  */)"MG", 
        (char const   */* const  */)"MR",      (char const   */* const  */)"NULL",      (char const   */* const  */)"WKS",      (char const   */* const  */)"PTR", 
        (char const   */* const  */)"HINFO",      (char const   */* const  */)"MINFO",      (char const   */* const  */)"MX",      (char const   */* const  */)"TXT", 
        (char const   */* const  */)"RP",      (char const   */* const  */)"AFSDB",      (char const   */* const  */)"X25",      (char const   */* const  */)"ISDN", 
        (char const   */* const  */)"RT",      (char const   */* const  */)"NSAP",      (char const   */* const  */)"NSAP_PTR",      (char const   */* const  */)"SIG", 
        (char const   */* const  */)"KEY",      (char const   */* const  */)"PX",      (char const   */* const  */)"GPOS",      (char const   */* const  */)"AAAA", 
        (char const   */* const  */)"LOC",      (char const   */* const  */)"NXT",      (char const   */* const  */)"EID",      (char const   */* const  */)"NIMLOC", 
        (char const   */* const  */)"SRV",      (char const   */* const  */)"ATMA",      (char const   */* const  */)"NAPTR",      (char const   */* const  */)"KX", 
        (char const   */* const  */)"CERT",      (char const   */* const  */)"A6",      (char const   */* const  */)"DNAME",      (char const   */* const  */)"SINK", 
        (char const   */* const  */)"OPT",      (char const   */* const  */)"APL",      (char const   */* const  */)"DS",      (char const   */* const  */)"SSHFP", 
        (char const   */* const  */)"IPSECKEY",      (char const   */* const  */)"RRSIG",      (char const   */* const  */)"NSEC",      (char const   */* const  */)"DNSKEY", 
        (char const   */* const  */)"DHCID",      (char const   */* const  */)"NSEC3",      (char const   */* const  */)"NSEC3PARAM"};
#line 39 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/pdnsd-ctl/../rr_types.c"
int rr_tp_byname(char *name ) 
{ 
  int i ;
  int tmp ;

  {
#line 43
  i = 0;
  {
#line 43
  while (1) {
    while_continue: /* CIL Label */ ;
#line 43
    if (! (i < 51)) {
#line 43
      goto while_break;
    }
    {
#line 44
    tmp = strcmp((char const   *)name, (char const   *)rrnames[i]);
    }
#line 44
    if (tmp == 0) {
#line 45
      return (i + 1);
    }
#line 43
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 47
  return (-1);
}
}
#line 124 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) tolower)(int __c ) ;
#line 466 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 391 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) mempcpy)(void * __restrict  __dest ,
                                                                                                  void const   * __restrict  __src ,
                                                                                                  size_t __n ) ;
#line 405 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int ( /* format attribute */  asprintf)(char ** __restrict  __ptr ,
                                                                             char const   * __restrict  __fmt 
                                                                             , ...) ;
#line 678
extern __ssize_t getline(char ** __restrict  __lineptr , size_t * __restrict  __n ,
                         FILE * __restrict  __stream ) ;
#line 828
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) feof)(FILE *__stream ) ;
#line 85 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/list.h"
__inline static void *( __attribute__((__always_inline__)) dlist_first)(dlist a ) ;
#line 87 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/list.h"
__inline static void *( __attribute__((__always_inline__)) dlist_first)(dlist a ) 
{ 
  char *tmp ;

  {
#line 89
  if (a) {
#line 89
    tmp = & a->data[sizeof(size_t )];
  } else {
#line 89
    tmp = (char *)((void *)0);
  }
#line 89
  return ((void *)tmp);
}
}
#line 96
__inline static void *( __attribute__((__always_inline__)) dlist_next)(void *ref ) ;
#line 98 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/list.h"
__inline static void *( __attribute__((__always_inline__)) dlist_next)(void *ref ) 
{ 
  size_t incr ;
  char *tmp ;

  {
#line 100
  incr = *((size_t *)ref - 1);
#line 101
  if (incr) {
#line 101
    tmp = (char *)ref + incr;
  } else {
#line 101
    tmp = (char *)((void *)0);
  }
#line 101
  return ((void *)tmp);
}
}
#line 105
__inline static void *( __attribute__((__always_inline__)) dlist_last)(dlist a ) ;
#line 107 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/list.h"
__inline static void *( __attribute__((__always_inline__)) dlist_last)(dlist a ) 
{ 
  char *tmp ;

  {
#line 109
  if (a) {
#line 109
    tmp = & a->data[a->last + sizeof(size_t )];
  } else {
#line 109
    tmp = (char *)((void *)0);
  }
#line 109
  return ((void *)tmp);
}
}
#line 112
dlist dlist_grow(dlist a , size_t len ) ;
#line 286 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/dns.h"
int decompress_name(unsigned char *msg , size_t msgsz , unsigned char **src , size_t *sz ,
                    unsigned char *tgt , unsigned int *len ) ;
#line 288
unsigned int domain_match(unsigned char const   *ms , unsigned char const   *md ,
                          unsigned int *os , unsigned int *od ) ;
#line 289
unsigned int compress_name(unsigned char *in , unsigned char *out , unsigned int offs ,
                           dlist *cb ) ;
#line 290
int a2ptrstr(pdnsd_ca *a , int tp , unsigned char *buf ) ;
#line 291
int read_hosts(char const   *fn , unsigned char *rns , time_t ttl , unsigned int flags ,
               int aliases , char **errstr ) ;
#line 293
char const   *getrrtpname(int tp ) ;
#line 295
char const   *get_cname(int id ) ;
#line 296
char const   *get_tname(int id ) ;
#line 297
char const   *get_ename(int id ) ;
#line 299
char *dnsflags2str(dns_hdr_t *hdr , char *buf ) ;
#line 173 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/cache.h"
void add_cache(dns_cent_t *cent ) ;
#line 199
int init_cent(dns_cent_t *cent , unsigned char const   *qname , time_t ttl , time_t ts ,
              unsigned int flags ) ;
#line 201
int add_cent_rr(dns_cent_t *cent , int type , time_t ttl , time_t ts , unsigned int flags ,
                unsigned int dlen , void *data ) ;
#line 203
void free_cent(dns_cent_t *cent ) ;
#line 60 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/helpers.h"
__inline static unsigned int ( __attribute__((__always_inline__)) rhnlen)(unsigned char const   *rhn ) ;
#line 232
__inline static int ( __attribute__((__always_inline__)) strncp)(char *dst , char const   *src ,
                                                                 size_t dstsz ) ;
#line 44 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/dns.c"
int decompress_name(unsigned char *msg , size_t msgsz , unsigned char **src , size_t *sz ,
                    unsigned char *tgt , unsigned int *len ) 
{ 
  unsigned int lb ;
  unsigned int offs ;
  unsigned int hops ;
  unsigned int tpos ;
  unsigned char *lptr ;
  size_t oldsz ;
  size_t newsz ;
  unsigned char *tmp ;
  unsigned int tmp___0 ;
  unsigned int tmp___1 ;
  unsigned char *tmp___2 ;
  unsigned char *tmp___3 ;
  unsigned char *tmp___4 ;
  unsigned int tmp___5 ;
  unsigned int tmp___6 ;
  unsigned char *tmp___7 ;
  char const   *tmp___8 ;

  {
#line 47
  hops = 0U;
#line 47
  tpos = 0U;
#line 48
  lptr = *src;
#line 49
  oldsz = *sz;
#line 50
  newsz = oldsz;
#line 52
  if (newsz == 0UL) {
#line 53
    goto name_outside_data;
  }
#line 54
  if ((size_t )(lptr - msg) >= msgsz) {
#line 55
    goto name_outside_msg;
  }
  {
#line 57
  while (1) {
    while_continue: /* CIL Label */ ;
#line 58
    newsz --;
#line 59
    tmp = lptr;
#line 59
    lptr ++;
#line 59
    lb = (unsigned int )*tmp;
#line 61
    if (lb > 63U) {
#line 62
      if (lb < 192U) {
#line 63
        goto unsupported_lbl_bits;
      }
#line 64
      if (newsz == 0UL) {
#line 65
        goto name_outside_data;
      }
#line 66
      if ((size_t )(lptr - msg) >= msgsz) {
#line 67
        goto name_outside_msg;
      }
#line 68
      newsz --;
#line 69
      offs = ((lb & 63U) << 8) | (unsigned int )*lptr;
#line 70
      if ((size_t )offs >= msgsz) {
#line 71
        goto offset_outside_msg;
      }
#line 72
      lptr = msg + offs;
#line 73
      goto jumped;
    }
#line 75
    tmp___0 = tpos;
#line 75
    tpos ++;
#line 75
    *(tgt + tmp___0) = (unsigned char )lb;
#line 76
    if (lb == 0U) {
#line 77
      goto while_break;
    }
#line 79
    if (newsz <= (size_t )lb) {
#line 80
      goto name_outside_data;
    }
#line 81
    if ((size_t )((lptr + lb) - msg) >= msgsz) {
#line 82
      goto name_outside_msg;
    }
#line 83
    if (tpos + lb > 255U) {
#line 84
      goto name_buf_full;
    }
#line 85
    newsz -= (size_t )lb;
    {
#line 86
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 89
      tmp___1 = tpos;
#line 89
      tpos ++;
#line 89
      tmp___2 = lptr;
#line 89
      lptr ++;
#line 89
      *(tgt + tmp___1) = *tmp___2;
#line 86
      lb --;
#line 86
      if (! lb) {
#line 86
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 92
  goto return_OK;
  jumped: 
#line 95
  hops ++;
  {
#line 96
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 97
    tmp___3 = lptr;
#line 97
    lptr ++;
#line 97
    lb = (unsigned int )*tmp___3;
    {
#line 99
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 99
      if (! (lb > 63U)) {
#line 99
        goto while_break___2;
      }
#line 100
      if (lb < 192U) {
#line 101
        goto unsupported_lbl_bits;
      }
#line 102
      if ((size_t )(lptr - msg) >= msgsz) {
#line 103
        goto name_outside_msg;
      }
#line 104
      hops ++;
#line 104
      if (hops > 255U) {
#line 105
        goto too_many_hops;
      }
#line 106
      offs = ((lb & 63U) << 8) | (unsigned int )*lptr;
#line 107
      if ((size_t )offs >= msgsz) {
#line 108
        goto offset_outside_msg;
      }
#line 109
      lptr = msg + offs;
#line 110
      tmp___4 = lptr;
#line 110
      lptr ++;
#line 110
      lb = (unsigned int )*tmp___4;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 112
    tmp___5 = tpos;
#line 112
    tpos ++;
#line 112
    *(tgt + tmp___5) = (unsigned char )lb;
#line 113
    if (lb == 0U) {
#line 114
      goto while_break___1;
    }
#line 116
    if ((size_t )((lptr + lb) - msg) >= msgsz) {
#line 117
      goto name_outside_msg;
    }
#line 118
    if (tpos + lb > 255U) {
#line 119
      goto name_buf_full;
    }
    {
#line 120
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 123
      tmp___6 = tpos;
#line 123
      tpos ++;
#line 123
      tmp___7 = lptr;
#line 123
      lptr ++;
#line 123
      *(tgt + tmp___6) = *tmp___7;
#line 120
      lb --;
#line 120
      if (! lb) {
#line 120
        goto while_break___3;
      }
    }
    while_break___3: /* CIL Label */ ;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  return_OK: 
#line 127
  *src += oldsz - newsz;
#line 128
  *sz = newsz;
#line 129
  if (len) {
#line 129
    *len = tpos;
  }
#line 130
  return (0);
  name_outside_data: 
#line 133
  if (debug_p) {
    {
#line 133
    debug_msg(0, "decompress_name: compressed name extends outside data field.\n");
    }
  }
#line 134
  return (65534);
  name_outside_msg: 
#line 137
  if (debug_p) {
    {
#line 137
    debug_msg(0, "decompress_name: compressed name extends outside message.\n");
    }
  }
#line 138
  return (1);
  unsupported_lbl_bits: 
#line 141
  if (debug_p) {
#line 141
    if (lb == 65U) {
#line 141
      tmp___8 = "decompress_name: Bit-string labels not supported.\n";
    } else {
#line 141
      tmp___8 = "decompress_name: unsupported label type.\n";
    }
    {
#line 141
    debug_msg(0, tmp___8);
    }
  }
#line 143
  return (1);
  offset_outside_msg: 
#line 146
  if (debug_p) {
    {
#line 146
    debug_msg(0, "decompress_name: offset points outside message.\n");
    }
  }
#line 147
  return (1);
  name_buf_full: 
#line 150
  if (debug_p) {
    {
#line 150
    debug_msg(0, "decompress_name: decompressed name larger than %u bytes.\n", 256);
    }
  }
#line 151
  return (1);
  too_many_hops: 
#line 154
  if (debug_p) {
    {
#line 154
    debug_msg(0, "decompress_name: too many offsets in compressed name.\n");
    }
  }
#line 155
  return (1);
}
}
#line 204 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/dns.c"
unsigned int domain_match(unsigned char const   *ms , unsigned char const   *md ,
                          unsigned int *os , unsigned int *od ) 
{ 
  unsigned int i ;
  unsigned int j ;
  unsigned int k ;
  unsigned int n ;
  unsigned int ns ;
  unsigned int nd ;
  unsigned int offs ;
  unsigned int offd ;
  unsigned char lb ;
  unsigned char ls[128] ;
  unsigned char ld[128] ;
  unsigned int tmp ;
  unsigned int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 206
  ns = 0U;
#line 206
  nd = 0U;
#line 210
  i = 0U;
  {
#line 211
  while (1) {
    while_continue: /* CIL Label */ ;
#line 211
    lb = (unsigned char )*(ms + i);
#line 211
    if (! lb) {
#line 211
      goto while_break;
    }
#line 212
    if (! (ns < 128U)) {
      {
#line 212
      log_message(3, "%s:%d: %s", "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/dns.c",
                  212, "domain_match: too many name segments");
#line 212
      pdnsd_exit();
      }
    }
#line 213
    tmp = ns;
#line 213
    ns ++;
#line 213
    ls[tmp] = lb;
#line 214
    i += (unsigned int )lb + 1U;
  }
  while_break: /* CIL Label */ ;
  }
#line 217
  j = 0U;
  {
#line 218
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 218
    lb = (unsigned char )*(md + j);
#line 218
    if (! lb) {
#line 218
      goto while_break___0;
    }
#line 219
    if (! (nd < 128U)) {
      {
#line 219
      log_message(3, "%s:%d: %s", "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/dns.c",
                  219, "domain_match: too many name segments");
#line 219
      pdnsd_exit();
      }
    }
#line 220
    tmp___0 = nd;
#line 220
    nd ++;
#line 220
    ld[tmp___0] = lb;
#line 221
    j += (unsigned int )lb + 1U;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 224
  n = ns;
#line 224
  if (n > nd) {
#line 224
    n = nd;
  }
#line 226
  k = 1U;
  {
#line 226
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 226
    offs = i;
#line 226
    offd = j;
#line 226
    if (! (k <= n)) {
#line 226
      goto while_break___1;
    }
#line 227
    lb = ls[ns - k];
#line 228
    if ((int )lb != (int )ld[nd - k]) {
#line 228
      goto mismatch;
    }
    {
#line 229
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 229
      if (! lb) {
#line 229
        goto while_break___2;
      }
      {
#line 230
      i --;
#line 230
      tmp___1 = tolower((int )*(ms + i));
#line 230
      j --;
#line 230
      tmp___2 = tolower((int )*(md + j));
      }
#line 230
      if (tmp___1 != tmp___2) {
#line 230
        goto mismatch;
      }
#line 229
      lb = (unsigned char )((int )lb - 1);
    }
    while_break___2: /* CIL Label */ ;
    }
#line 231
    i --;
#line 231
    j --;
#line 226
    k ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  mismatch: 
#line 235
  if (os) {
#line 235
    *os = offs;
  }
#line 236
  if (od) {
#line 236
    *od = offd;
  }
#line 237
  return (k - 1U);
}
}
#line 248 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/dns.c"
unsigned int compress_name(unsigned char *in , unsigned char *out , unsigned int offs ,
                           dlist *cb ) 
{ 
  compel_t *ci ;
  unsigned int longest ;
  unsigned int lrem ;
  unsigned int coffs ;
  unsigned int rl ;
  unsigned int ilen ;
  unsigned int tmp ;
  unsigned short add ;
  void *tmp___0 ;
  void *tmp___1 ;
  unsigned int rv ;
  unsigned int rem ;
  unsigned int to ;
  unsigned int newoffs ;
  dlist tmp___2 ;
  void *tmp___3 ;

  {
  {
#line 251
  longest = 0U;
#line 251
  lrem = 0U;
#line 251
  coffs = 0U;
#line 252
  rl = 0U;
#line 253
  tmp = rhnlen((unsigned char const   *)in);
#line 253
  ilen = tmp;
#line 254
  add = (unsigned short)1;
  }
#line 256
  if (! (ilen <= 256U)) {
    {
#line 256
    log_message(3, "%s:%d: %s", "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/dns.c",
                256, "compress_name: name too long");
#line 256
    pdnsd_exit();
    }
  }
  {
#line 259
  tmp___0 = dlist_first(*cb);
#line 259
  ci = (compel_t *)tmp___0;
  }
  {
#line 259
  while (1) {
    while_continue: /* CIL Label */ ;
#line 259
    if (! ci) {
#line 259
      goto while_break;
    }
    {
#line 261
    rv = domain_match((unsigned char const   *)in, (unsigned char const   *)(ci->s),
                      & rem, & to);
    }
#line 261
    if (rv > longest) {
#line 269
      newoffs = ci->index + to;
#line 271
      if (newoffs <= 16383U) {
#line 272
        longest = rv;
#line 273
        lrem = rem;
#line 274
        coffs = newoffs;
      }
    }
    {
#line 259
    tmp___1 = dlist_next((void *)ci);
#line 259
    ci = (compel_t *)tmp___1;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 278
  if (longest > 0U) {
#line 279
    if (! (lrem + 2U <= ilen)) {
      {
#line 279
      log_message(3, "%s:%d: %s", "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/dns.c",
                  279, "compress_name: length increased");
#line 279
      pdnsd_exit();
      }
    }
    {
#line 280
    memcpy((void */* __restrict  */)out, (void const   */* __restrict  */)in, (size_t )lrem);
#line 281
    *(out + lrem) = (unsigned char )(192U | ((coffs & 16128U) >> 8));
#line 282
    *(out + (lrem + 1U)) = (unsigned char )(coffs & 255U);
#line 283
    rl = lrem + 2U;
#line 284
    add = (unsigned short )(lrem != 0U);
    }
  } else {
    {
#line 287
    memcpy((void */* __restrict  */)out, (void const   */* __restrict  */)in, (size_t )ilen);
#line 288
    rl = ilen;
    }
  }
#line 292
  if (add) {
    {
#line 293
    tmp___2 = dlist_grow(*cb, sizeof(compel_t ) + (unsigned long )ilen);
#line 293
    *cb = tmp___2;
    }
#line 293
    if (! tmp___2) {
#line 294
      return (0U);
    }
    {
#line 295
    tmp___3 = dlist_last(*cb);
#line 295
    ci = (compel_t *)tmp___3;
#line 296
    ci->index = offs;
#line 297
    memcpy((void */* __restrict  */)(ci->s), (void const   */* __restrict  */)in,
           (size_t )ilen);
    }
  }
#line 299
  return (rl);
}
}
#line 306 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/dns.c"
int a2ptrstr(pdnsd_ca *a , int tp , unsigned char *buf ) 
{ 
  unsigned char *p ;
  int n ;
  int tmp ;
  unsigned char *p___0 ;
  int i ;
  int offs ;
  unsigned char bt ;
  int n___0 ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 308
  if (tp == 1) {
    {
#line 309
    p = (unsigned char *)(& a->ipv4.s_addr);
#line 310
    tmp = snprintf((char */* __restrict  */)((char *)buf), (size_t )256, (char const   */* __restrict  */)"%u.%u.%u.%u.in-addr.arpa.",
                   (int )*(p + 3), (int )*(p + 2), (int )*(p + 1), (int )*(p + 0));
#line 310
    n = tmp;
    }
#line 311
    if (n < 0) {
#line 312
      return (0);
    } else
#line 311
    if (n >= 256) {
#line 312
      return (0);
    }
  } else
#line 316
  if (tp == 28) {
#line 317
    p___0 = (unsigned char *)(& a->ipv6);
#line 318
    offs = 0;
#line 319
    i = 15;
    {
#line 319
    while (1) {
      while_continue: /* CIL Label */ ;
#line 319
      if (! (i >= 0)) {
#line 319
        goto while_break;
      }
      {
#line 320
      bt = *(p___0 + i);
#line 321
      tmp___0 = snprintf((char */* __restrict  */)((char *)(buf + offs)), (size_t )(256 - offs),
                         (char const   */* __restrict  */)"%x.%x.", (int )bt & 15,
                         ((int )bt >> 4) & 15);
#line 321
      n___0 = tmp___0;
      }
#line 322
      if (n___0 < 0) {
#line 322
        return (0);
      }
#line 323
      offs += n___0;
#line 324
      if (offs >= 256) {
#line 324
        return (0);
      }
#line 319
      i --;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 326
    tmp___1 = strncp((char *)(buf + offs), "ip6.arpa.", (size_t )(256 - offs));
    }
#line 326
    if (! tmp___1) {
#line 327
      return (0);
    }
  } else {
#line 331
    return (0);
  }
#line 332
  return (1);
}
}
#line 340 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/dns.c"
static int add_host(unsigned char *pn , unsigned char *rns , pdnsd_ca *a , int tp ,
                    int a_sz , time_t ttl , unsigned int flags , int reverse ) 
{ 
  dns_cent_t ce ;
  int tmp ;
  int tmp___0 ;
  unsigned int tmp___1 ;
  int tmp___2 ;
  unsigned char b2[256] ;
  unsigned char rhn[256] ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  unsigned int tmp___6 ;
  int tmp___7 ;
  unsigned int tmp___8 ;
  int tmp___9 ;

  {
  {
#line 344
  tmp = init_cent(& ce, (unsigned char const   *)pn, (time_t )0, (time_t )0, flags);
  }
#line 344
  if (! tmp) {
#line 345
    return (0);
  }
  {
#line 346
  tmp___0 = add_cent_rr(& ce, tp, ttl, (time_t )0, 2U, (unsigned int )a_sz, (void *)a);
  }
#line 346
  if (! tmp___0) {
#line 347
    goto free_cent_return0;
  }
  {
#line 348
  tmp___1 = rhnlen((unsigned char const   *)rns);
#line 348
  tmp___2 = add_cent_rr(& ce, 2, ttl, (time_t )0, 2U, tmp___1, (void *)rns);
  }
#line 348
  if (! tmp___2) {
#line 349
    goto free_cent_return0;
  }
  {
#line 350
  add_cache(& ce);
#line 351
  free_cent(& ce);
  }
#line 352
  if (reverse) {
    {
#line 354
    tmp___3 = a2ptrstr(a, tp, b2);
    }
#line 354
    if (! tmp___3) {
#line 355
      return (-1);
    }
    {
#line 356
    tmp___4 = str2rhn((unsigned char const   *)(b2), rhn);
    }
#line 356
    if (! tmp___4) {
#line 357
      return (-1);
    }
    {
#line 358
    tmp___5 = init_cent(& ce, (unsigned char const   *)(rhn), (time_t )0, (time_t )0,
                        flags);
    }
#line 358
    if (! tmp___5) {
#line 359
      return (0);
    }
    {
#line 360
    tmp___6 = rhnlen((unsigned char const   *)pn);
#line 360
    tmp___7 = add_cent_rr(& ce, 12, ttl, (time_t )0, 2U, tmp___6, (void *)pn);
    }
#line 360
    if (! tmp___7) {
#line 361
      goto free_cent_return0;
    }
    {
#line 362
    tmp___8 = rhnlen((unsigned char const   *)rns);
#line 362
    tmp___9 = add_cent_rr(& ce, 2, ttl, (time_t )0, 2U, tmp___8, (void *)rns);
    }
#line 362
    if (! tmp___9) {
#line 363
      goto free_cent_return0;
    }
    {
#line 364
    add_cache(& ce);
#line 365
    free_cent(& ce);
    }
  }
#line 367
  return (1);
  free_cent_return0: 
  {
#line 370
  free_cent(& ce);
  }
#line 371
  return (0);
}
}
#line 379 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/dns.c"
int read_hosts(char const   *fn , unsigned char *rns , time_t ttl , unsigned int flags ,
               int aliases , char **errstr ) 
{ 
  int rv ;
  FILE *f ;
  char *buf ;
  size_t buflen ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  void *tmp___2 ;
  unsigned int len ;
  unsigned char *p ;
  unsigned char *pn ;
  unsigned char *pi ;
  unsigned char rhn[256] ;
  int tp ;
  int sz ;
  pdnsd_ca a ;
  char *tmp___3 ;
  unsigned short const   **tmp___4 ;
  unsigned short const   **tmp___5 ;
  unsigned short const   **tmp___6 ;
  unsigned short const   **tmp___7 ;
  char const   *tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int res ;
  int tmp___11 ;
  unsigned short const   **tmp___12 ;
  unsigned short const   **tmp___13 ;
  char const   *tmp___14 ;
  int tmp___15 ;
  __ssize_t tmp___16 ;
  int *tmp___17 ;
  char *tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;

  {
  {
#line 381
  rv = 0;
#line 384
  buflen = (size_t )256;
#line 386
  f = fopen((char const   */* __restrict  */)fn, (char const   */* __restrict  */)"r");
  }
#line 386
  if (! f) {
    {
#line 387
    tmp = __errno_location();
#line 387
    tmp___0 = strerror(*tmp);
#line 387
    tmp___1 = asprintf((char **/* __restrict  */)errstr, (char const   */* __restrict  */)"Failed to source %s: %s",
                       fn, tmp___0);
    }
#line 387
    if (tmp___1 < 0) {
#line 387
      *errstr = (char *)((void *)0);
    }
#line 388
    return (0);
  }
  {
#line 390
  tmp___2 = malloc(buflen);
#line 390
  buf = (char *)tmp___2;
  }
#line 391
  if (! buf) {
#line 392
    *errstr = (char *)((void *)0);
#line 393
    goto fclose_return;
  }
  {
#line 395
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 395
    tmp___16 = getline((char **/* __restrict  */)(& buf), (size_t */* __restrict  */)(& buflen),
                       (FILE */* __restrict  */)f);
    }
#line 395
    if (! (tmp___16 >= 0L)) {
#line 395
      goto while_break;
    }
    {
#line 402
    tmp___3 = strchr((char const   *)buf, '#');
#line 402
    p = (unsigned char *)tmp___3;
    }
#line 403
    if (p) {
#line 403
      *p = (unsigned char)0;
    }
#line 404
    p = (unsigned char *)buf;
    {
#line 405
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 406
      if (! *p) {
#line 406
        goto nextline;
      }
      {
#line 407
      tmp___4 = __ctype_b_loc();
      }
#line 407
      if (! ((int const   )*(*tmp___4 + (int )*p) & 8192)) {
#line 407
        goto while_break___0;
      }
#line 408
      p ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 410
    pi = p;
    {
#line 411
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 412
      p ++;
#line 412
      if (! *p) {
#line 412
        goto nextline;
      }
      {
#line 411
      tmp___5 = __ctype_b_loc();
      }
#line 411
      if ((int const   )*(*tmp___5 + (int )*p) & 8192) {
#line 411
        goto while_break___1;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
#line 414
    *p = (unsigned char)0;
    {
#line 415
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 416
      p ++;
#line 416
      if (! *p) {
#line 416
        goto nextline;
      }
      {
#line 415
      tmp___6 = __ctype_b_loc();
      }
#line 415
      if (! ((int const   )*(*tmp___6 + (int )*p) & 8192)) {
#line 415
        goto while_break___2;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
#line 418
    pn = p;
    {
#line 419
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 420
      p ++;
#line 419
      if (*p) {
        {
#line 419
        tmp___7 = __ctype_b_loc();
        }
#line 419
        if ((int const   )*(*tmp___7 + (int )*p) & 8192) {
#line 419
          goto while_break___3;
        }
      } else {
#line 419
        goto while_break___3;
      }
    }
    while_break___3: /* CIL Label */ ;
    }
    {
#line 422
    len = (unsigned int )(p - pn);
#line 423
    tmp___8 = parsestr2rhn((unsigned char const   *)pn, len, rhn);
    }
#line 423
    if ((unsigned long )tmp___8 != (unsigned long )((void *)0)) {
#line 424
      goto while_continue;
    }
    {
#line 425
    tmp___10 = inet_aton((char const   *)((char *)pi), & a.ipv4);
    }
#line 425
    if (tmp___10) {
#line 426
      tp = 1;
#line 427
      sz = (int )sizeof(struct in_addr );
    } else {
      {
#line 430
      tmp___9 = inet_pton(10, (char const   */* __restrict  */)((char *)pi), (void */* __restrict  */)(& a.ipv6));
      }
#line 430
      if (tmp___9 > 0) {
#line 431
        tp = 28;
#line 432
        sz = (int )sizeof(struct in6_addr );
      } else {
#line 435
        goto while_continue;
      }
    }
    {
#line 438
    tmp___11 = add_host(rhn, rns, & a, tp, sz, ttl, flags, 1);
#line 438
    res = tmp___11;
    }
#line 439
    if (res == 0) {
#line 440
      *errstr = (char *)((void *)0);
#line 441
      goto cleanup_return;
    } else
#line 443
    if (res < 0) {
#line 444
      goto while_continue;
    }
#line 446
    if (aliases) {
      {
#line 447
      while (1) {
        while_continue___4: /* CIL Label */ ;
        {
#line 448
        while (1) {
          while_continue___5: /* CIL Label */ ;
#line 449
          if (! *p) {
#line 449
            goto nextline;
          }
          {
#line 450
          tmp___12 = __ctype_b_loc();
          }
#line 450
          if (! ((int const   )*(*tmp___12 + (int )*p) & 8192)) {
#line 450
            goto while_break___5;
          }
#line 451
          p ++;
        }
        while_break___5: /* CIL Label */ ;
        }
#line 453
        pn = p;
        {
#line 454
        while (1) {
          while_continue___6: /* CIL Label */ ;
#line 455
          p ++;
#line 454
          if (*p) {
            {
#line 454
            tmp___13 = __ctype_b_loc();
            }
#line 454
            if ((int const   )*(*tmp___13 + (int )*p) & 8192) {
#line 454
              goto while_break___6;
            }
          } else {
#line 454
            goto while_break___6;
          }
        }
        while_break___6: /* CIL Label */ ;
        }
        {
#line 457
        len = (unsigned int )(p - pn);
#line 458
        tmp___14 = parsestr2rhn((unsigned char const   *)pn, len, rhn);
        }
#line 458
        if ((unsigned long )tmp___14 != (unsigned long )((void *)0)) {
#line 459
          goto while_break___4;
        }
        {
#line 460
        tmp___15 = add_host(rhn, rns, & a, tp, sz, ttl, flags, 0);
        }
#line 460
        if (tmp___15 == 0) {
#line 461
          *errstr = (char *)((void *)0);
#line 462
          goto cleanup_return;
        }
      }
      while_break___4: /* CIL Label */ ;
      }
    }
    nextline: ;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 468
  tmp___20 = feof(f);
  }
#line 468
  if (tmp___20) {
#line 469
    rv = 1;
  } else {
    {
#line 470
    tmp___17 = __errno_location();
#line 470
    tmp___18 = strerror(*tmp___17);
#line 470
    tmp___19 = asprintf((char **/* __restrict  */)errstr, (char const   */* __restrict  */)"Failed to source %s: %s",
                        fn, tmp___18);
    }
#line 470
    if (tmp___19 < 0) {
#line 470
      *errstr = (char *)((void *)0);
    }
  }
  cleanup_return: 
  {
#line 472
  free((void *)buf);
  }
  fclose_return: 
  {
#line 474
  fclose(f);
  }
#line 475
  return (rv);
}
}
#line 480 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/dns.c"
char const   *getrrtpname(int tp ) 
{ 
  char const   *tmp ;

  {
#line 482
  if (tp >= 1) {
#line 482
    if (tp <= 51) {
#line 482
      tmp = rrnames[tp - 1];
    } else {
#line 482
      tmp = (char const   */* const  */)"[unknown]";
    }
  } else {
#line 482
    tmp = (char const   */* const  */)"[unknown]";
  }
#line 482
  return ((char const   *)tmp);
}
}
#line 489 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/dns.c"
static char const   * const  c_names[4]  = {      (char const   */* const  */)"IN",      (char const   */* const  */)"CS",      (char const   */* const  */)"CH",      (char const   */* const  */)"HS"};
#line 490 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/dns.c"
static char const   * const  qt_names[5]  = {      (char const   */* const  */)"IXFR",      (char const   */* const  */)"AXFR",      (char const   */* const  */)"MAILB",      (char const   */* const  */)"MAILA", 
        (char const   */* const  */)"*"};
#line 492 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/dns.c"
char const   *get_cname(int id ) 
{ 


  {
#line 494
  if (id >= 1) {
#line 494
    if (id <= 4) {
#line 495
      return ((char const   *)c_names[id - 1]);
    }
  }
#line 496
  if (id == 255) {
#line 497
    return ("*");
  }
#line 498
  return ("[unknown]");
}
}
#line 501 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/dns.c"
char const   *get_tname(int id ) 
{ 


  {
#line 503
  if (id >= 1) {
#line 503
    if (id <= 51) {
#line 504
      return ((char const   *)rrnames[id - 1]);
    } else {
#line 503
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 505
  if (id >= 251) {
#line 505
    if (id <= 255) {
#line 506
      return ((char const   *)qt_names[id - 251]);
    }
  }
#line 507
  return ("[unknown]");
}
}
#line 512 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/dns.c"
static char const   * const  e_names[17]  = 
#line 512
  {      (char const   */* const  */)"no error",      (char const   */* const  */)"query format error",      (char const   */* const  */)"server failed",      (char const   */* const  */)"non-existent domain", 
        (char const   */* const  */)"not supported",      (char const   */* const  */)"query refused",      (char const   */* const  */)"name exists when it should not",      (char const   */* const  */)"RR set exists when it should not", 
        (char const   */* const  */)"RR set that should exist does not",      (char const   */* const  */)"server not authoritative for zone",      (char const   */* const  */)"name not contained in zone",      (char const   */* const  */)"11", 
        (char const   */* const  */)"12",      (char const   */* const  */)"13",      (char const   */* const  */)"14",      (char const   */* const  */)"15", 
        (char const   */* const  */)"bad OPT version"};
#line 532 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/dns.c"
char const   *get_ename(int id ) 
{ 


  {
#line 534
  if (id >= 0) {
#line 534
    if (id < 17) {
#line 535
      return ((char const   *)e_names[id]);
    }
  }
#line 536
  return ("[unknown]");
}
}
#line 544 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/dns.c"
char *dnsflags2str(dns_hdr_t *hdr , char *buf ) 
{ 
  char *p ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;

  {
#line 546
  p = buf;
#line 548
  if (hdr->aa) {
    {
#line 549
    tmp = mempcpy((void */* __restrict  */)p, (void const   */* __restrict  */)" AA",
                  (size_t )3);
#line 549
    p = (char *)tmp;
    }
  }
#line 550
  if (hdr->tc) {
    {
#line 551
    tmp___0 = mempcpy((void */* __restrict  */)p, (void const   */* __restrict  */)" TC",
                      (size_t )3);
#line 551
    p = (char *)tmp___0;
    }
  }
#line 552
  if (hdr->rd) {
    {
#line 553
    tmp___1 = mempcpy((void */* __restrict  */)p, (void const   */* __restrict  */)" RD",
                      (size_t )3);
#line 553
    p = (char *)tmp___1;
    }
  }
#line 554
  if (hdr->ra) {
    {
#line 555
    tmp___2 = mempcpy((void */* __restrict  */)p, (void const   */* __restrict  */)" RA",
                      (size_t )3);
#line 555
    p = (char *)tmp___2;
    }
  }
#line 556
  if (hdr->z) {
    {
#line 557
    tmp___3 = mempcpy((void */* __restrict  */)p, (void const   */* __restrict  */)" Z",
                      (size_t )2);
#line 557
    p = (char *)tmp___3;
    }
  }
#line 558
  if (hdr->ad) {
    {
#line 559
    tmp___4 = mempcpy((void */* __restrict  */)p, (void const   */* __restrict  */)" AD",
                      (size_t )3);
#line 559
    p = (char *)tmp___4;
    }
  }
#line 560
  if (hdr->cd) {
    {
#line 561
    tmp___5 = mempcpy((void */* __restrict  */)p, (void const   */* __restrict  */)" CD",
                      (size_t )3);
#line 561
    p = (char *)tmp___5;
    }
  }
#line 562
  *p = (char)0;
#line 564
  return (buf);
}
}
#line 480 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__warn_unused_result__,
__leaf__)) realloc)(void *__ptr , size_t __size ) ;
#line 123 "/usr/include/x86_64-linux-gnu/sys/socket.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) bind)(int __fd ,
                                                                           struct sockaddr  const  * __restrict  __addr ,
                                                                           socklen_t __len ) ;
#line 149
extern ssize_t send(int __fd , void const   *__buf , size_t __n , int __flags ) ;
#line 156
extern ssize_t recv(int __fd , void *__buf , size_t __n , int __flags ) ;
#line 137 "/usr/include/fcntl.h"
extern int fcntl(int __fd , int __cmd  , ...) ;
#line 54 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/list.h"
darray da_grow1(darray a , size_t headsz , size_t elemsz , void (*cleanuproutine)(void * ) ) ;
#line 55
darray da_resize(darray a , size_t headsz , size_t elemsz , size_t n , void (*cleanuproutine)(void * ) ) ;
#line 57
__inline static unsigned int ( __attribute__((__always_inline__)) da_nel)(darray a ) ;
#line 59 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/list.h"
__inline static unsigned int ( __attribute__((__always_inline__)) da_nel)(darray a ) 
{ 


  {
#line 61
  if ((unsigned long )a == (unsigned long )((void *)0)) {
#line 62
    return (0U);
  }
#line 63
  return ((unsigned int )a->nel);
}
}
#line 85
__inline static void *( __attribute__((__always_inline__)) dlist_first)(dlist a ) ;
#line 96
__inline static void *( __attribute__((__always_inline__)) dlist_next)(void *ref ) ;
#line 105
__inline static void *( __attribute__((__always_inline__)) dlist_last)(dlist a ) ;
#line 109 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/rr_types.h"
unsigned short const   rrlkuptab[51] ;
#line 180 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/conff.h"
servparm_array servers ;
#line 117 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/cache.h"
char const   cflgnames[21] ;
#line 118
char const   dflgnames[15] ;
#line 119
char *flags2str(unsigned int flags , char *buf , int nflags , char const   *flgnames ) ;
#line 178
unsigned char *getlocalowner(unsigned char *name , int tp ) ;
#line 179
dns_cent_t *lookup_cache(unsigned char const   *name , int *wild ) ;
#line 180
rr_set_t *lookup_cache_local_rrset(unsigned char const   *name , int type ) ;
#line 185
__inline static unsigned int ( __attribute__((__always_inline__)) mk_flag_val)(servparm_t *server ) ;
#line 187 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/cache.h"
__inline static unsigned int ( __attribute__((__always_inline__)) mk_flag_val)(servparm_t *server ) 
{ 
  unsigned int fl ;

  {
#line 189
  fl = 0U;
#line 190
  if (! server->purge_cache) {
#line 191
    fl |= 32U;
  }
#line 192
  if (server->nocache) {
#line 193
    fl |= 8U;
  }
#line 194
  if (server->rootserver) {
#line 195
    fl |= 64U;
  }
#line 196
  return (fl);
}
}
#line 200
int add_cent_rrset_by_type(dns_cent_t *cent , int type , time_t ttl , time_t ts ,
                           unsigned int flags ) ;
#line 202
int del_rrset(rr_set_t *rrs ) ;
#line 204
void free_cent0(void *ptr ) ;
#line 205
void negate_cent(dns_cent_t *cent , time_t ttl , time_t ts ) ;
#line 219
__inline static rr_set_t *( __attribute__((__always_inline__)) getrrset)(dns_cent_t *cent ,
                                                                         int type ) ;
#line 221 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/cache.h"
__inline static rr_set_t *( __attribute__((__always_inline__)) getrrset)(dns_cent_t *cent ,
                                                                         int type ) 
{ 
  int tpi ;
  unsigned int idx ;
  rr_set_t **rrext ;

  {
#line 223
  if (! ((int )cent->flags & 1)) {
#line 224
    tpi = type - 1;
#line 226
    if (tpi >= 0) {
#line 226
      if (tpi < 51) {
#line 227
        idx = (unsigned int )rrlkuptab[tpi];
#line 228
        if (idx < 8U) {
#line 229
          return (cent->__annonCompField2.rr.rrmu[idx]);
        } else {
#line 231
          idx -= 8U;
#line 232
          if (idx < 39U) {
#line 233
            rrext = cent->__annonCompField2.rr.rrext;
#line 234
            if (rrext) {
#line 235
              return (*(rrext + idx));
            }
          }
        }
      }
    }
  }
#line 241
  return ((rr_set_t *)((void *)0));
}
}
#line 249
__inline static rr_set_t *( __attribute__((__always_inline__)) getrrset_eff)(dns_cent_t *cent ,
                                                                             int type ) ;
#line 251 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/cache.h"
__inline static rr_set_t *( __attribute__((__always_inline__)) getrrset_eff)(dns_cent_t *cent ,
                                                                             int type ) 
{ 
  unsigned int idx ;
  rr_set_t **rrext ;

  {
#line 253
  idx = (unsigned int )rrlkuptab[type - 1];
#line 254
  if (idx < 8U) {
#line 255
    return (cent->__annonCompField2.rr.rrmu[idx]);
  } else {
#line 257
    idx -= 8U;
#line 258
    if (idx < 39U) {
#line 259
      rrext = cent->__annonCompField2.rr.rrext;
#line 260
      if (rrext) {
#line 261
        return (*(rrext + idx));
      }
    }
  }
#line 265
  return ((rr_set_t *)((void *)0));
}
}
#line 272
__inline static int ( __attribute__((__always_inline__)) have_rr)(dns_cent_t *cent ,
                                                                  int type ) ;
#line 274 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/cache.h"
__inline static int ( __attribute__((__always_inline__)) have_rr)(dns_cent_t *cent ,
                                                                  int type ) 
{ 
  rr_set_t *rrset ;
  int tmp ;

  {
#line 277
  if (! ((int )cent->flags & 1)) {
    {
#line 277
    rrset = getrrset_eff(cent, type);
    }
#line 277
    if (rrset) {
#line 277
      if (rrset->rrs) {
#line 277
        tmp = 1;
      } else {
#line 277
        tmp = 0;
      }
    } else {
#line 277
      tmp = 0;
    }
  } else {
#line 277
    tmp = 0;
  }
#line 277
  return (tmp);
}
}
#line 36 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/dns_query.h"
int r_dns_cached_resolve(unsigned char *name , int thint , dns_cent_t **cachedp ,
                         int hops , qhintnode_t *qhlist , time_t queryts , unsigned char *c_soa ) ;
#line 42
addr2_array dns_rootserver_resolv(atup_array atup_a , int port , char edns_query ,
                                  time_t timeout ) ;
#line 43
int query_uptest(pdnsd_a *addr , int port , unsigned char const   *name , time_t timeout ,
                 int rep ) ;
#line 46
int add_opt_pseudo_rr(dns_msg_t **ans , size_t *sz , size_t *allocsz , unsigned short udpsize ,
                      unsigned short rcode , unsigned short ednsver , unsigned short Zflags ) ;
#line 49
size_t remove_opt_pseudo_rr(dns_msg_t *ans , size_t sz ) ;
#line 38 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/servers.h"
void sched_server_test(pdnsd_a *sa , int nadr , int up ) ;
#line 40
void test_onquery(void) ;
#line 41
void lock_server_data(void) ;
#line 42
void unlock_server_data(void) ;
#line 47
__inline static int ( __attribute__((__always_inline__)) needs_testing)(servparm_t *sp ) ;
#line 49 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/servers.h"
__inline static int ( __attribute__((__always_inline__)) needs_testing)(servparm_t *sp ) 
{ 
  int tmp ;

  {
#line 51
  if (sp->interval > 0L) {
#line 51
    goto _L;
  } else
#line 51
  if (sp->interval == -2L) {
    _L: /* CIL Label */ 
#line 51
    if ((int )sp->uptest != 5) {
#line 51
      tmp = 1;
    } else
#line 51
    if (sp->scheme[0]) {
#line 51
      tmp = 1;
    } else {
#line 51
      tmp = 0;
    }
  } else {
#line 51
    tmp = 0;
  }
#line 51
  return (tmp);
}
}
#line 61
__inline static int ( __attribute__((__always_inline__)) is_interrupted_servstat_thread)(void) ;
#line 60 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/helpers.h"
__inline static unsigned int ( __attribute__((__always_inline__)) rhnlen)(unsigned char const   *rhn ) ;
#line 72
__inline static unsigned char const   *( __attribute__((__always_inline__)) skipsegs)(unsigned char const   *nm ,
                                                                                      unsigned int k ) ;
#line 74 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/helpers.h"
__inline static unsigned char const   *( __attribute__((__always_inline__)) skipsegs)(unsigned char const   *nm ,
                                                                                      unsigned int k ) 
{ 
  unsigned int lb ;

  {
  {
#line 77
  while (1) {
    while_continue: /* CIL Label */ ;
#line 77
    if (k) {
#line 77
      lb = (unsigned int )*nm;
#line 77
      if (! lb) {
#line 77
        goto while_break;
      }
    } else {
#line 77
      goto while_break;
    }
#line 78
    nm += lb + 1U;
#line 77
    k --;
  }
  while_break: /* CIL Label */ ;
  }
#line 80
  return (nm);
}
}
#line 86
__inline static unsigned char *( __attribute__((__always_inline__)) skiprhn)(unsigned char *rhn ) ;
#line 88 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/helpers.h"
__inline static unsigned char *( __attribute__((__always_inline__)) skiprhn)(unsigned char *rhn ) 
{ 
  unsigned int lb ;
  unsigned char *tmp ;

  {
  {
#line 92
  while (1) {
    while_continue: /* CIL Label */ ;
#line 92
    tmp = rhn;
#line 92
    rhn ++;
#line 92
    lb = (unsigned int )*tmp;
#line 92
    if (! lb) {
#line 92
      goto while_break;
    }
#line 93
    rhn += lb;
  }
  while_break: /* CIL Label */ ;
  }
#line 94
  return (rhn);
}
}
#line 98
__inline static unsigned int ( __attribute__((__always_inline__)) rhnsegcnt)(unsigned char const   *rhn ) ;
#line 100 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/helpers.h"
__inline static unsigned int ( __attribute__((__always_inline__)) rhnsegcnt)(unsigned char const   *rhn ) 
{ 
  unsigned int res ;
  unsigned int lb ;

  {
#line 102
  res = 0U;
  {
#line 104
  while (1) {
    while_continue: /* CIL Label */ ;
#line 104
    lb = (unsigned int )*rhn;
#line 104
    if (! lb) {
#line 104
      goto while_break;
    }
#line 105
    res ++;
#line 106
    rhn += lb + 1U;
  }
  while_break: /* CIL Label */ ;
  }
#line 108
  return (res);
}
}
#line 122
__inline static int ( __attribute__((__always_inline__)) is_inaddr2_any)(pdnsd_a2 *a ) ;
#line 123 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/helpers.h"
__inline static int ( __attribute__((__always_inline__)) is_inaddr2_any)(pdnsd_a2 *a ) 
{ 


  {
#line 125
  return (a->ipv4.s_addr == 0U);
}
}
#line 147
__inline static int ( __attribute__((__always_inline__)) equiv_inaddr2)(pdnsd_a *a ,
                                                                        pdnsd_a2 *b ) ;
#line 149 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/helpers.h"
__inline static int ( __attribute__((__always_inline__)) equiv_inaddr2)(pdnsd_a *a ,
                                                                        pdnsd_a2 *b ) 
{ 


  {
#line 151
  return (a->ipv4.s_addr == b->ipv4.s_addr);
}
}
#line 212
__inline static int ( __attribute__((__always_inline__)) rhnicmp)(unsigned char const   *a ,
                                                                  unsigned char const   *b ) ;
#line 214 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/helpers.h"
__inline static int ( __attribute__((__always_inline__)) rhnicmp)(unsigned char const   *a ,
                                                                  unsigned char const   *b ) 
{ 
  unsigned int i ;
  unsigned char lb ;
  int tmp ;
  int tmp___0 ;

  {
#line 216
  i = 0U;
  {
#line 218
  while (1) {
    while_continue: /* CIL Label */ ;
#line 219
    lb = (unsigned char )*(a + i);
#line 220
    if ((int )lb != (int )*(b + i)) {
#line 220
      return (0);
    }
#line 221
    if (! lb) {
#line 221
      goto while_break;
    }
#line 222
    i ++;
    {
#line 223
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 224
      tmp = tolower((int )*(a + i));
#line 224
      tmp___0 = tolower((int )*(b + i));
      }
#line 224
      if (tmp != tmp___0) {
#line 224
        return (0);
      }
#line 225
      i ++;
#line 223
      lb = (unsigned char )((int )lb - 1);
#line 223
      if (! lb) {
#line 223
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 228
  return (1);
}
}
#line 159 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/dns_query.c"
static unsigned long volatile   poll_errs  =    (unsigned long volatile   )0;
#line 183 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/dns_query.c"
static int rr_to_cache(dns_cent_array *centa , unsigned char *oname , int tp , time_t ttl ,
                       unsigned int dlen , void *data , unsigned int flags , time_t queryts ) 
{ 
  int i ;
  int n ;
  dns_cent_t *cent ;
  unsigned int tmp ;
  int retval ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  dns_cent_array tmp___4 ;
  darray tmp___5 ;
  darray tmp___6 ;
  int tmp___7 ;
  int tmp___9 ;
  int tmp___10 ;

  {
  {
#line 189
  tmp = da_nel((darray )*centa);
#line 189
  n = (int )tmp;
#line 190
  i = 0;
  }
  {
#line 190
  while (1) {
    while_continue: /* CIL Label */ ;
#line 190
    if (! (i < n)) {
#line 190
      goto while_break;
    }
    {
#line 191
    cent = & (*centa)->elem[i];
#line 192
    tmp___3 = rhnicmp((unsigned char const   *)cent->qname, (unsigned char const   *)oname);
    }
#line 192
    if (tmp___3) {
      {
#line 193
      retval = 0;
#line 201
      tmp___2 = add_cent_rr(cent, tp, ttl, queryts, flags, dlen, data);
      }
#line 201
      if (tmp___2) {
#line 201
        tmp___1 = retval;
      } else {
#line 201
        tmp___1 = 65535;
      }
#line 201
      return (tmp___1);
    }
#line 190
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 206
  tmp___5 = da_grow1((darray )*centa, (size_t )(((dns_cent_array )0)->elem), sizeof((*centa)->elem[0]),
                     & free_cent0);
#line 206
  tmp___4 = (dns_cent_array )tmp___5;
#line 206
  *centa = tmp___4;
  }
#line 206
  if (! tmp___4) {
#line 207
    return (65535);
  }
  {
#line 208
  cent = & (*centa)->elem[(*centa)->nel - 1UL];
#line 209
  tmp___7 = init_cent(cent, (unsigned char const   *)oname, (time_t )0, (time_t )0,
                      0U);
  }
#line 209
  if (! tmp___7) {
    {
#line 210
    tmp___6 = da_resize((darray )*centa, (size_t )(((dns_cent_array )0)->elem), sizeof((*centa)->elem[0]),
                        (size_t )n, (void (*)(void * ))((void *)0));
#line 210
    *centa = (dns_cent_array )tmp___6;
    }
#line 211
    return (65535);
  }
  {
#line 213
  tmp___10 = add_cent_rr(cent, tp, ttl, queryts, flags, dlen, data);
  }
#line 213
  if (tmp___10) {
#line 213
    tmp___9 = 0;
  } else {
#line 213
    tmp___9 = 65535;
  }
#line 213
  return (tmp___9);
}
}
#line 229 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/dns_query.c"
static int rrs2cent(unsigned char *msg , size_t msgsz , unsigned char **ptr , size_t *lcnt ,
                    int recnum , unsigned int flags , time_t queryts , dns_cent_array *centa ,
                    int *numopt , edns_info_t *ep ) 
{ 
  int rc ;
  int retval ;
  int i ;
  uint16_t type ;
  uint16_t class ;
  uint32_t ttl ;
  uint16_t rdlength ;
  unsigned char oname[256] ;
  unsigned char *ttlp ;
  unsigned int len ;
  register uint16_t t_s ;
  register unsigned char const   *t_cp ;
  unsigned char const   *tmp ;
  unsigned char const   *tmp___0 ;
  register uint16_t t_s___0 ;
  register unsigned char const   *t_cp___0 ;
  unsigned char const   *tmp___1 ;
  unsigned char const   *tmp___2 ;
  register uint32_t t_l ;
  register unsigned char const   *t_cp___1 ;
  unsigned char const   *tmp___3 ;
  unsigned char const   *tmp___4 ;
  unsigned char const   *tmp___5 ;
  unsigned char const   *tmp___6 ;
  register uint16_t t_s___1 ;
  register unsigned char const   *t_cp___2 ;
  unsigned char const   *tmp___7 ;
  unsigned char const   *tmp___8 ;
  unsigned int Zflags ;
  int tmp___9 ;
  size_t blcnt ;
  unsigned char *bptr ;
  unsigned char *nptr ;
  unsigned int slen ;
  unsigned char db[256] ;
  int tmp___10 ;
  unsigned char db___0[512] ;
  int tmp___11 ;
  int tmp___12 ;
  unsigned char db___1[258] ;
  int tmp___13 ;
  unsigned char db___2[532] ;
  int tmp___14 ;
  int tmp___15 ;
  unsigned char db___3[514] ;
  int tmp___16 ;
  int tmp___17 ;
  unsigned char db___4[262] ;
  int tmp___18 ;
  unsigned char db___5[1040] ;
  int tmp___19 ;
  int j ;
  unsigned char db___6[1028] ;
  int tmp___20 ;
  unsigned int gwtp ;
  int tmp___21 ;
  unsigned char *rbuf ;
  unsigned char nmbuf[256] ;
  int tmp___22 ;
  void *tmp___23 ;
  void *tmp___24 ;
  void *tmp___25 ;
  char const   *tmp___26 ;
  int tmp___27 ;
  unsigned char *rbuf___0 ;
  unsigned char nmbuf___0[256] ;
  int tmp___28 ;
  void *tmp___29 ;
  void *tmp___30 ;
  void *tmp___31 ;
  int tmp___32 ;
  unsigned char *rbuf___1 ;
  unsigned char nmbuf___1[256] ;
  int tmp___33 ;
  void *tmp___34 ;
  void *tmp___35 ;
  char const   *tmp___36 ;
  char const   *tmp___37 ;
  char const   *tmp___38 ;
  char const   *tmp___39 ;
  char const   *tmp___40 ;
  char const   *tmp___41 ;

  {
#line 232
  retval = 0;
#line 236
  i = 0;
  {
#line 236
  while (1) {
    while_continue: /* CIL Label */ ;
#line 236
    if (! (i < recnum)) {
#line 236
      goto while_break;
    }
    {
#line 239
    rc = decompress_name(msg, msgsz, ptr, lcnt, oname, & len);
    }
#line 239
    if (rc != 0) {
#line 240
      return (rc);
    }
#line 242
    if (*lcnt < 10UL) {
#line 243
      return (65534);
    }
#line 245
    *lcnt -= 10UL;
    {
#line 246
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 246
      t_cp = (unsigned char const   *)*ptr;
#line 246
      tmp = t_cp;
#line 246
      t_cp ++;
#line 246
      t_s = (uint16_t )((int )((uint16_t )*tmp) << 8);
#line 246
      tmp___0 = t_cp;
#line 246
      t_cp ++;
#line 246
      t_s = (uint16_t )((int )t_s | (int )((uint16_t )*tmp___0));
#line 246
      type = t_s;
#line 246
      *ptr = (unsigned char *)((void *)t_cp);
#line 246
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 247
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 247
      t_cp___0 = (unsigned char const   *)*ptr;
#line 247
      tmp___1 = t_cp___0;
#line 247
      t_cp___0 ++;
#line 247
      t_s___0 = (uint16_t )((int )((uint16_t )*tmp___1) << 8);
#line 247
      tmp___2 = t_cp___0;
#line 247
      t_cp___0 ++;
#line 247
      t_s___0 = (uint16_t )((int )t_s___0 | (int )((uint16_t )*tmp___2));
#line 247
      class = t_s___0;
#line 247
      *ptr = (unsigned char *)((void *)t_cp___0);
#line 247
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 248
    ttlp = *ptr;
    {
#line 249
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 249
      t_cp___1 = (unsigned char const   *)*ptr;
#line 249
      tmp___3 = t_cp___1;
#line 249
      t_cp___1 ++;
#line 249
      t_l = (uint32_t )*tmp___3 << 24;
#line 249
      tmp___4 = t_cp___1;
#line 249
      t_cp___1 ++;
#line 249
      t_l |= (uint32_t )*tmp___4 << 16;
#line 249
      tmp___5 = t_cp___1;
#line 249
      t_cp___1 ++;
#line 249
      t_l |= (uint32_t )*tmp___5 << 8;
#line 249
      tmp___6 = t_cp___1;
#line 249
      t_cp___1 ++;
#line 249
      t_l |= (uint32_t )*tmp___6;
#line 249
      ttl = t_l;
#line 249
      *ptr = (unsigned char *)((void *)t_cp___1);
#line 249
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 250
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 250
      t_cp___2 = (unsigned char const   *)*ptr;
#line 250
      tmp___7 = t_cp___2;
#line 250
      t_cp___2 ++;
#line 250
      t_s___1 = (uint16_t )((int )((uint16_t )*tmp___7) << 8);
#line 250
      tmp___8 = t_cp___2;
#line 250
      t_cp___2 ++;
#line 250
      t_s___1 = (uint16_t )((int )t_s___1 | (int )((uint16_t )*tmp___8));
#line 250
      rdlength = t_s___1;
#line 250
      *ptr = (unsigned char *)((void *)t_cp___2);
#line 250
      goto while_break___3;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 251
    if (*lcnt < (size_t )rdlength) {
#line 252
      return (65534);
    }
#line 255
    if ((int )type == 41) {
#line 257
      tmp___9 = *numopt;
#line 257
      (*numopt) ++;
#line 257
      if (tmp___9 == 0) {
#line 259
        if ((int )oname[0] != 0) {
#line 260
          if (debug_p) {
            {
#line 260
            debug_msg(0, "rrs2cent: name in OPT record not empty!\n");
            }
          }
        }
#line 263
        ep->udpsize = class;
#line 264
        ep->rcode = (unsigned short )((unsigned int )((int )((uint16_t )*(ttlp + 0)) << 4) | ((dns_hdr_t *)msg)->rcode);
#line 265
        ep->version = (unsigned short )*(ttlp + 1);
#line 266
        ep->do_flg = (unsigned char )(((int )*(ttlp + 2) >> 7) & 1);
#line 268
        if (debug_p) {
#line 269
          Zflags = (unsigned int )(((int )((uint16_t )*(ttlp + 2)) << 8) | (int )*(ttlp + 3));
#line 270
          if (Zflags & 32767U) {
#line 271
            if (debug_p) {
              {
#line 271
              debug_msg(0, "rrs2cent: Z field contains unknown nonzero bits (%04x).\n",
                        Zflags);
              }
            }
          }
        }
#line 275
        if (rdlength) {
#line 276
          if (debug_p) {
            {
#line 276
            debug_msg(0, "rrs2cent: RDATA field in OPT record not empty!\n");
            }
          }
        }
      } else
#line 281
      if (debug_p) {
        {
#line 281
        debug_msg(0, "rrs2cent: ingnoring surplus OPT record.\n");
        }
      }
    } else
#line 284
    if ((int )type < 1) {
#line 284
      goto _L;
    } else
#line 284
    if ((int )type > 51) {
#line 284
      goto _L;
    } else
#line 284
    if ((int const   )rrlkuptab[(int )type - 1] >= 47) {
#line 284
      goto _L;
    } else
#line 284
    if ((int )class != 1) {
      _L: /* CIL Label */ 
#line 652
      if (debug_p) {
#line 652
        if ((int )class == 1) {
#line 652
          tmp___36 = "IN";
        } else {
#line 652
          tmp___36 = "[unknown]";
        }
        {
#line 652
        tmp___37 = getrrtpname((int )type);
#line 652
        debug_msg(0, "rrs2cent: ignoring record of type %s (%d), class %s (%d).\n",
                  tmp___37, (int )type, tmp___36, (int )class);
        }
      }
    } else {
#line 288
      blcnt = (size_t )rdlength;
#line 289
      bptr = *ptr;
      {
#line 296
      if ((int )type == 1) {
#line 296
        goto case_1;
      }
#line 308
      if ((int )type == 12) {
#line 308
        goto case_12;
      }
#line 308
      if ((int )type == 2) {
#line 308
        goto case_12;
      }
#line 308
      if ((int )type == 9) {
#line 308
        goto case_12;
      }
#line 308
      if ((int )type == 8) {
#line 308
        goto case_12;
      }
#line 308
      if ((int )type == 4) {
#line 308
        goto case_12;
      }
#line 308
      if ((int )type == 3) {
#line 308
        goto case_12;
      }
#line 308
      if ((int )type == 7) {
#line 308
        goto case_12;
      }
#line 308
      if ((int )type == 5) {
#line 308
        goto case_12;
      }
#line 328
      if ((int )type == 17) {
#line 328
        goto case_17;
      }
#line 328
      if ((int )type == 14) {
#line 328
        goto case_17;
      }
#line 360
      if ((int )type == 36) {
#line 360
        goto case_36;
      }
#line 360
      if ((int )type == 21) {
#line 360
        goto case_36;
      }
#line 360
      if ((int )type == 18) {
#line 360
        goto case_36;
      }
#line 360
      if ((int )type == 15) {
#line 360
        goto case_36;
      }
#line 385
      if ((int )type == 6) {
#line 385
        goto case_6;
      }
#line 414
      if ((int )type == 28) {
#line 414
        goto case_28;
      }
#line 420
      if ((int )type == 26) {
#line 420
        goto case_26;
      }
#line 450
      if ((int )type == 33) {
#line 450
        goto case_33;
      }
#line 475
      if ((int )type == 30) {
#line 475
        goto case_30;
      }
#line 495
      if ((int )type == 35) {
#line 495
        goto case_35;
      }
#line 538
      if ((int )type == 45) {
#line 538
        goto case_45;
      }
#line 586
      if ((int )type == 46) {
#line 586
        goto case_46;
      }
#line 616
      if ((int )type == 47) {
#line 616
        goto case_47;
      }
#line 641
      goto default_case;
      case_1: /* CIL Label */ 
#line 298
      if ((int )rdlength != 4) {
#line 298
        goto invalid_length;
      }
#line 299
      goto default_case;
      case_12: /* CIL Label */ 
      case_2: /* CIL Label */ 
      case_9: /* CIL Label */ 
      case_8: /* CIL Label */ 
      case_4: /* CIL Label */ 
      case_3: /* CIL Label */ 
      case_7: /* CIL Label */ 
      case_5: /* CIL Label */ 
      {
#line 311
      rc = decompress_name(msg, msgsz, & bptr, & blcnt, db, & len);
      }
#line 311
      if (rc != 0) {
#line 312
        if (rc == 65534) {
#line 312
          tmp___10 = 1;
        } else {
#line 312
          tmp___10 = rc;
        }
#line 312
        return (tmp___10);
      }
#line 313
      if (blcnt != 0UL) {
#line 314
        goto trailing_junk;
      }
      {
#line 315
      rc = rr_to_cache(centa, oname, (int )type, (time_t )ttl, len, (void *)(db),
                       flags, queryts);
      }
#line 315
      if (rc != 0) {
#line 316
        if (rc == 65535) {
#line 317
          return (rc);
        }
#line 318
        retval = rc;
      }
#line 321
      goto switch_break;
      case_17: /* CIL Label */ 
      case_14: /* CIL Label */ 
      {
#line 332
      nptr = db___0;
#line 333
      rc = decompress_name(msg, msgsz, & bptr, & blcnt, nptr, & len);
      }
#line 333
      if (rc != 0) {
#line 334
        if (rc == 65534) {
#line 334
          tmp___11 = 1;
        } else {
#line 334
          tmp___11 = rc;
        }
#line 334
        return (tmp___11);
      }
      {
#line 336
      nptr += len;
#line 337
      slen = len;
#line 338
      rc = decompress_name(msg, msgsz, & bptr, & blcnt, nptr, & len);
      }
#line 338
      if (rc != 0) {
#line 339
        if (rc == 65534) {
#line 339
          tmp___12 = 1;
        } else {
#line 339
          tmp___12 = rc;
        }
#line 339
        return (tmp___12);
      }
#line 341
      slen += len;
#line 342
      if (blcnt != 0UL) {
#line 343
        goto trailing_junk;
      }
      {
#line 344
      rc = rr_to_cache(centa, oname, (int )type, (time_t )ttl, slen, (void *)(db___0),
                       flags, queryts);
      }
#line 344
      if (rc != 0) {
#line 345
        if (rc == 65535) {
#line 346
          return (rc);
        }
#line 347
        retval = rc;
      }
#line 350
      goto switch_break;
      case_36: /* CIL Label */ 
      case_21: /* CIL Label */ 
      case_18: /* CIL Label */ 
      case_15: /* CIL Label */ 
#line 364
      if (blcnt < 2UL) {
#line 365
        goto record_too_short;
      }
      {
#line 366
      memcpy((void */* __restrict  */)(db___1), (void const   */* __restrict  */)bptr,
             (size_t )2);
#line 367
      blcnt -= 2UL;
#line 368
      bptr += 2;
#line 369
      nptr = db___1 + 2;
#line 370
      slen = 2U;
#line 371
      rc = decompress_name(msg, msgsz, & bptr, & blcnt, nptr, & len);
      }
#line 371
      if (rc != 0) {
#line 372
        if (rc == 65534) {
#line 372
          tmp___13 = 1;
        } else {
#line 372
          tmp___13 = rc;
        }
#line 372
        return (tmp___13);
      }
#line 374
      slen += len;
#line 375
      if (blcnt != 0UL) {
#line 376
        goto trailing_junk;
      }
      {
#line 377
      rc = rr_to_cache(centa, oname, (int )type, (time_t )ttl, slen, (void *)(db___1),
                       flags, queryts);
      }
#line 377
      if (rc != 0) {
#line 378
        if (rc == 65535) {
#line 379
          return (rc);
        }
#line 380
        retval = rc;
      }
#line 383
      goto switch_break;
      case_6: /* CIL Label */ 
      {
#line 388
      nptr = db___2;
#line 389
      rc = decompress_name(msg, msgsz, & bptr, & blcnt, nptr, & len);
      }
#line 389
      if (rc != 0) {
#line 390
        if (rc == 65534) {
#line 390
          tmp___14 = 1;
        } else {
#line 390
          tmp___14 = rc;
        }
#line 390
        return (tmp___14);
      }
      {
#line 392
      nptr += len;
#line 393
      slen = len;
#line 394
      rc = decompress_name(msg, msgsz, & bptr, & blcnt, nptr, & len);
      }
#line 394
      if (rc != 0) {
#line 395
        if (rc == 65534) {
#line 395
          tmp___15 = 1;
        } else {
#line 395
          tmp___15 = rc;
        }
#line 395
        return (tmp___15);
      }
#line 396
      nptr += len;
#line 397
      slen += len;
#line 399
      if (blcnt < 20UL) {
#line 400
        goto record_too_short;
      }
      {
#line 401
      memcpy((void */* __restrict  */)nptr, (void const   */* __restrict  */)bptr,
             (size_t )20);
#line 402
      blcnt -= 20UL;
#line 403
      slen += 20U;
      }
#line 404
      if (blcnt != 0UL) {
#line 405
        goto trailing_junk;
      }
      {
#line 406
      rc = rr_to_cache(centa, oname, (int )type, (time_t )ttl, slen, (void *)(db___2),
                       flags, queryts);
      }
#line 406
      if (rc != 0) {
#line 407
        if (rc == 65535) {
#line 408
          return (rc);
        }
#line 409
        retval = rc;
      }
#line 412
      goto switch_break;
      case_28: /* CIL Label */ 
#line 416
      if ((int )rdlength != 16) {
#line 416
        goto invalid_length;
      }
#line 417
      goto default_case;
      case_26: /* CIL Label */ 
#line 423
      if (blcnt < 2UL) {
#line 424
        goto record_too_short;
      }
      {
#line 425
      memcpy((void */* __restrict  */)(db___3), (void const   */* __restrict  */)bptr,
             (size_t )2);
#line 426
      blcnt -= 2UL;
#line 427
      bptr += 2;
#line 428
      nptr = db___3 + 2;
#line 429
      slen = 2U;
#line 430
      rc = decompress_name(msg, msgsz, & bptr, & blcnt, nptr, & len);
      }
#line 430
      if (rc != 0) {
#line 431
        if (rc == 65534) {
#line 431
          tmp___16 = 1;
        } else {
#line 431
          tmp___16 = rc;
        }
#line 431
        return (tmp___16);
      }
      {
#line 433
      nptr += len;
#line 434
      slen += len;
#line 435
      rc = decompress_name(msg, msgsz, & bptr, & blcnt, nptr, & len);
      }
#line 435
      if (rc != 0) {
#line 436
        if (rc == 65534) {
#line 436
          tmp___17 = 1;
        } else {
#line 436
          tmp___17 = rc;
        }
#line 436
        return (tmp___17);
      }
#line 438
      slen += len;
#line 439
      if (blcnt != 0UL) {
#line 440
        goto trailing_junk;
      }
      {
#line 441
      rc = rr_to_cache(centa, oname, (int )type, (time_t )ttl, slen, (void *)(db___3),
                       flags, queryts);
      }
#line 441
      if (rc != 0) {
#line 442
        if (rc == 65535) {
#line 443
          return (rc);
        }
#line 444
        retval = rc;
      }
#line 447
      goto switch_break;
      case_33: /* CIL Label */ 
#line 453
      if (blcnt < 6UL) {
#line 454
        goto record_too_short;
      }
      {
#line 455
      memcpy((void */* __restrict  */)(db___4), (void const   */* __restrict  */)bptr,
             (size_t )6);
#line 456
      blcnt -= 6UL;
#line 457
      bptr += 6;
#line 458
      nptr = db___4 + 6;
#line 459
      slen = 6U;
#line 460
      rc = decompress_name(msg, msgsz, & bptr, & blcnt, nptr, & len);
      }
#line 460
      if (rc != 0) {
#line 461
        if (rc == 65534) {
#line 461
          tmp___18 = 1;
        } else {
#line 461
          tmp___18 = rc;
        }
#line 461
        return (tmp___18);
      }
#line 463
      slen += len;
#line 464
      if (blcnt != 0UL) {
#line 465
        goto trailing_junk;
      }
      {
#line 466
      rc = rr_to_cache(centa, oname, (int )type, (time_t )ttl, slen, (void *)(db___4),
                       flags, queryts);
      }
#line 466
      if (rc != 0) {
#line 467
        if (rc == 65535) {
#line 468
          return (rc);
        }
#line 469
        retval = rc;
      }
#line 472
      goto switch_break;
      case_30: /* CIL Label */ 
      {
#line 478
      nptr = db___5;
#line 479
      rc = decompress_name(msg, msgsz, & bptr, & blcnt, nptr, & len);
      }
#line 479
      if (rc != 0) {
#line 480
        if (rc == 65534) {
#line 480
          tmp___19 = 1;
        } else {
#line 480
          tmp___19 = rc;
        }
#line 480
        return (tmp___19);
      }
#line 481
      nptr += len;
#line 482
      slen = (unsigned int )((size_t )len + blcnt);
#line 483
      if ((unsigned long )slen > sizeof(db___5)) {
#line 484
        goto buffer_overflow;
      }
      {
#line 485
      memcpy((void */* __restrict  */)nptr, (void const   */* __restrict  */)bptr,
             blcnt);
#line 486
      rc = rr_to_cache(centa, oname, (int )type, (time_t )ttl, slen, (void *)(db___5),
                       flags, queryts);
      }
#line 486
      if (rc != 0) {
#line 487
        if (rc == 65535) {
#line 488
          return (rc);
        }
#line 489
        retval = rc;
      }
#line 492
      goto switch_break;
      case_35: /* CIL Label */ 
#line 499
      nptr = db___6;
#line 508
      len = 4U;
#line 509
      j = 0;
      {
#line 509
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 509
        if (! (j < 3)) {
#line 509
          goto while_break___4;
        }
#line 510
        if ((size_t )len >= blcnt) {
#line 511
          goto record_too_short;
        }
#line 512
        len += (unsigned int )*(bptr + len) + 1U;
#line 509
        j ++;
      }
      while_break___4: /* CIL Label */ ;
      }
#line 514
      if ((size_t )len > blcnt) {
#line 515
        goto record_too_short;
      }
      {
#line 516
      memcpy((void */* __restrict  */)nptr, (void const   */* __restrict  */)bptr,
             (size_t )len);
#line 517
      blcnt -= (size_t )len;
#line 518
      bptr += len;
#line 519
      nptr += len;
#line 520
      slen = len;
#line 523
      rc = decompress_name(msg, msgsz, & bptr, & blcnt, nptr, & len);
      }
#line 523
      if (rc != 0) {
#line 524
        if (rc == 65534) {
#line 524
          tmp___20 = 1;
        } else {
#line 524
          tmp___20 = rc;
        }
#line 524
        return (tmp___20);
      }
#line 526
      slen += len;
#line 527
      if (blcnt != 0UL) {
#line 528
        goto trailing_junk;
      }
      {
#line 529
      rc = rr_to_cache(centa, oname, (int )type, (time_t )ttl, slen, (void *)(db___6),
                       flags, queryts);
      }
#line 529
      if (rc != 0) {
#line 530
        if (rc == 65535) {
#line 531
          return (rc);
        }
#line 532
        retval = rc;
      }
#line 535
      goto switch_break;
      case_45: /* CIL Label */ 
#line 542
      if (blcnt < 3UL) {
#line 542
        goto record_too_short;
      }
#line 543
      gwtp = (unsigned int )*(bptr + 1);
#line 544
      blcnt -= 3UL;
#line 545
      bptr += 3;
      {
#line 547
      if (gwtp == 0U) {
#line 547
        goto case_0;
      }
#line 548
      if (gwtp == 1U) {
#line 548
        goto case_1___0;
      }
#line 551
      if (gwtp == 2U) {
#line 551
        goto case_2___0;
      }
#line 554
      if (gwtp == 3U) {
#line 554
        goto case_3___0;
      }
#line 578
      goto switch_default;
      case_0: /* CIL Label */ 
#line 547
      goto default_case;
      case_1___0: /* CIL Label */ 
#line 549
      if (blcnt < 4UL) {
#line 549
        goto record_too_short;
      }
#line 550
      goto default_case;
      case_2___0: /* CIL Label */ 
#line 552
      if (blcnt < 16UL) {
#line 552
        goto record_too_short;
      }
#line 553
      goto default_case;
      case_3___0: /* CIL Label */ 
      {
#line 555
      tmp___21 = isnormalencdomname((unsigned char const   *)bptr, (unsigned int )blcnt);
      }
#line 555
      if (tmp___21) {
#line 555
        goto default_case;
      }
      {
#line 561
      rc = decompress_name(msg, msgsz, & bptr, & blcnt, nmbuf, & len);
      }
#line 561
      if (rc != 0) {
#line 562
        if (rc == 65534) {
#line 562
          tmp___22 = 1;
        } else {
#line 562
          tmp___22 = rc;
        }
#line 562
        return (tmp___22);
      }
      {
#line 563
      slen = (unsigned int )((size_t )(3U + len) + blcnt);
#line 564
      tmp___23 = malloc((size_t )slen);
#line 564
      rbuf = (unsigned char *)tmp___23;
      }
#line 565
      if (! rbuf) {
#line 565
        return (65535);
      }
      {
#line 566
      tmp___24 = mempcpy((void */* __restrict  */)rbuf, (void const   */* __restrict  */)*ptr,
                         (size_t )3);
#line 566
      nptr = (unsigned char *)tmp___24;
#line 567
      tmp___25 = mempcpy((void */* __restrict  */)nptr, (void const   */* __restrict  */)(nmbuf),
                         (size_t )len);
#line 567
      nptr = (unsigned char *)tmp___25;
#line 568
      memcpy((void */* __restrict  */)nptr, (void const   */* __restrict  */)bptr,
             blcnt);
#line 569
      rc = rr_to_cache(centa, oname, (int )type, (time_t )ttl, slen, (void *)rbuf,
                       flags, queryts);
#line 570
      free((void *)rbuf);
      }
#line 571
      if (rc != 0) {
#line 572
        if (rc == 65535) {
#line 573
          return (rc);
        }
#line 574
        retval = rc;
      }
#line 577
      goto switch_break___0;
      switch_default: /* CIL Label */ 
#line 579
      if (debug_p) {
        {
#line 579
        tmp___26 = getrrtpname((int )type);
#line 579
        debug_msg(0, "rrs2cent: %s record contains unsupported gateway type (%u).\n",
                  tmp___26, gwtp);
        }
      }
#line 580
      return (1);
      switch_break___0: /* CIL Label */ ;
      }
#line 583
      goto switch_break;
      case_46: /* CIL Label */ 
#line 588
      if (blcnt < 18UL) {
#line 588
        goto record_too_short;
      }
      {
#line 589
      blcnt -= 18UL;
#line 590
      bptr += 18;
#line 591
      tmp___27 = isnormalencdomname((unsigned char const   *)bptr, (unsigned int )blcnt);
      }
#line 591
      if (tmp___27) {
#line 591
        goto default_case;
      }
      {
#line 597
      rc = decompress_name(msg, msgsz, & bptr, & blcnt, nmbuf___0, & len);
      }
#line 597
      if (rc != 0) {
#line 598
        if (rc == 65534) {
#line 598
          tmp___28 = 1;
        } else {
#line 598
          tmp___28 = rc;
        }
#line 598
        return (tmp___28);
      }
      {
#line 599
      slen = (unsigned int )((size_t )(18U + len) + blcnt);
#line 600
      tmp___29 = malloc((size_t )slen);
#line 600
      rbuf___0 = (unsigned char *)tmp___29;
      }
#line 601
      if (! rbuf___0) {
#line 601
        return (65535);
      }
      {
#line 602
      tmp___30 = mempcpy((void */* __restrict  */)rbuf___0, (void const   */* __restrict  */)*ptr,
                         (size_t )18);
#line 602
      nptr = (unsigned char *)tmp___30;
#line 603
      tmp___31 = mempcpy((void */* __restrict  */)nptr, (void const   */* __restrict  */)(nmbuf___0),
                         (size_t )len);
#line 603
      nptr = (unsigned char *)tmp___31;
#line 604
      memcpy((void */* __restrict  */)nptr, (void const   */* __restrict  */)bptr,
             blcnt);
#line 605
      rc = rr_to_cache(centa, oname, (int )type, (time_t )ttl, slen, (void *)rbuf___0,
                       flags, queryts);
#line 606
      free((void *)rbuf___0);
      }
#line 607
      if (rc != 0) {
#line 608
        if (rc == 65535) {
#line 609
          return (rc);
        }
#line 610
        retval = rc;
      }
#line 613
      goto switch_break;
      case_47: /* CIL Label */ 
      {
#line 618
      tmp___32 = isnormalencdomname((unsigned char const   *)bptr, (unsigned int )blcnt);
      }
#line 618
      if (tmp___32) {
#line 618
        goto default_case;
      }
      {
#line 624
      rc = decompress_name(msg, msgsz, & bptr, & blcnt, nmbuf___1, & len);
      }
#line 624
      if (rc != 0) {
#line 625
        if (rc == 65534) {
#line 625
          tmp___33 = 1;
        } else {
#line 625
          tmp___33 = rc;
        }
#line 625
        return (tmp___33);
      }
      {
#line 626
      slen = (unsigned int )((size_t )len + blcnt);
#line 627
      tmp___34 = malloc((size_t )slen);
#line 627
      rbuf___1 = (unsigned char *)tmp___34;
      }
#line 628
      if (! rbuf___1) {
#line 628
        return (65535);
      }
      {
#line 629
      tmp___35 = mempcpy((void */* __restrict  */)rbuf___1, (void const   */* __restrict  */)(nmbuf___1),
                         (size_t )len);
#line 629
      nptr = (unsigned char *)tmp___35;
#line 630
      memcpy((void */* __restrict  */)nptr, (void const   */* __restrict  */)bptr,
             blcnt);
#line 631
      rc = rr_to_cache(centa, oname, (int )type, (time_t )ttl, slen, (void *)rbuf___1,
                       flags, queryts);
#line 632
      free((void *)rbuf___1);
      }
#line 633
      if (rc != 0) {
#line 634
        if (rc == 65535) {
#line 635
          return (rc);
        }
#line 636
        retval = rc;
      }
#line 639
      goto switch_break;
      default_case: 
      switch_default___0: /* CIL Label */ 
      {
#line 643
      rc = rr_to_cache(centa, oname, (int )type, (time_t )ttl, (unsigned int )rdlength,
                       (void *)*ptr, flags, queryts);
      }
#line 643
      if (rc != 0) {
#line 644
        if (rc == 65535) {
#line 645
          return (rc);
        }
#line 646
        retval = rc;
      }
      switch_break: /* CIL Label */ ;
      }
    }
#line 657
    *lcnt -= (size_t )rdlength;
#line 658
    *ptr += (int )rdlength;
#line 236
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 660
  return (retval);
  trailing_junk: 
#line 663
  if (debug_p) {
    {
#line 663
    tmp___38 = getrrtpname((int )type);
#line 663
    debug_msg(0, "rrs2cent: %s record has trailing junk.\n", tmp___38);
    }
  }
#line 664
  return (1);
  record_too_short: 
#line 667
  if (debug_p) {
    {
#line 667
    tmp___39 = getrrtpname((int )type);
#line 667
    debug_msg(0, "rrs2cent: %s record too short.\n", tmp___39);
    }
  }
#line 668
  return (1);
  buffer_overflow: 
#line 671
  if (debug_p) {
    {
#line 671
    tmp___40 = getrrtpname((int )type);
#line 671
    debug_msg(0, "rrs2cent: buffer too small to process %s record.\n", tmp___40);
    }
  }
#line 672
  return (1);
  invalid_length: 
#line 675
  if (debug_p) {
    {
#line 675
    tmp___41 = getrrtpname((int )type);
#line 675
    debug_msg(0, "rrs2cent: %s record has length %u.\n", tmp___41, (int )rdlength);
    }
  }
#line 676
  return (1);
}
}
#line 682 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/dns_query.c"
static int bind_socket(int s ) 
{ 
  int query_port_start ;
  int query_port_end ;
  union __anonunion_sin_119 sin ;
  socklen_t sinl ;
  int prt ;
  int pstart ;
  int range ;
  int m ;
  unsigned int try1 ;
  unsigned int try2 ;
  unsigned int maxtry2 ;
  unsigned short tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;
  int tmp___4 ;

  {
#line 684
  query_port_start = global.query_port_start;
#line 684
  query_port_end = global.query_port_end;
#line 690
  if (query_port_start >= 0) {
#line 700
    range = (query_port_end - query_port_start) + 1;
#line 700
    m = 65535;
#line 703
    if (range <= 0) {
      {
#line 704
      log_message(4, "Illegal port range in %s line %d, dropping query!\n", "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/dns_query.c",
                  704);
      }
#line 705
      return (0);
    } else
#line 703
    if (range > 65536) {
      {
#line 704
      log_message(4, "Illegal port range in %s line %d, dropping query!\n", "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/dns_query.c",
                  704);
      }
#line 705
      return (0);
    }
#line 707
    if (range <= 32768) {
#line 709
      m = 1;
      {
#line 709
      while (1) {
        while_continue: /* CIL Label */ ;
#line 709
        if (! (m < range)) {
#line 709
          goto while_break;
        }
#line 709
        m <<= 1;
      }
      while_break: /* CIL Label */ ;
      }
#line 711
      m --;
    }
#line 714
    try2 = 0U;
#line 714
    maxtry2 = (unsigned int )(range * 2);
    {
#line 714
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 716
      try1 = 0U;
      {
#line 716
      while (1) {
        while_continue___1: /* CIL Label */ ;
        {
#line 717
        tmp = get_rand16();
#line 717
        prt = (int )tmp & m;
        }
#line 718
        if (prt < range) {
#line 718
          goto while_break___1;
        }
#line 719
        try1 ++;
#line 719
        if (try1 >= 65536U) {
          {
#line 720
          log_message(4, "Cannot get random number < range after %d tries in %s line %d, bad random number generator?\n",
                      try1, "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/dns_query.c",
                      723);
          }
#line 724
          return (0);
        }
      }
      while_break___1: /* CIL Label */ ;
      }
#line 727
      prt += query_port_start;
#line 729
      pstart = prt;
      {
#line 729
      while (1) {
        while_continue___2: /* CIL Label */ ;
        {
#line 732
        memset((void *)(& sin.sin4), 0, sizeof(struct sockaddr_in ));
#line 733
        sin.sin4.sin_family = (sa_family_t )2;
#line 734
        sin.sin4.sin_port = htons((uint16_t )prt);
#line 735
        sin.sin4.sin_addr = global.out_a.ipv4;
#line 737
        sinl = (socklen_t )sizeof(struct sockaddr_in );
#line 751
        tmp___4 = bind(s, (struct sockaddr  const  */* __restrict  */)((struct sockaddr *)(& sin)),
                       sinl);
        }
#line 751
        if (tmp___4 == -1) {
          {
#line 752
          tmp___2 = __errno_location();
          }
#line 752
          if (*tmp___2 != 98) {
            {
#line 752
            tmp___3 = __errno_location();
            }
#line 752
            if (*tmp___3 != 99) {
              {
#line 754
              tmp___0 = __errno_location();
#line 754
              tmp___1 = strerror(*tmp___0);
#line 754
              log_message(4, "Could not bind to socket: %s\n", tmp___1);
              }
#line 755
              return (0);
            }
          }
        } else {
#line 759
          goto done;
        }
#line 761
        try2 ++;
#line 761
        if (try2 >= maxtry2) {
#line 764
          prt ++;
#line 764
          if (prt > query_port_end) {
#line 765
            prt = query_port_start;
          }
#line 766
          if (prt == pstart) {
            {
#line 768
            log_message(4, "Out of ports in the range %d-%d, dropping query!\n", query_port_start,
                        query_port_end);
            }
#line 771
            return (0);
          }
        } else {
#line 775
          goto while_break___2;
        }
      }
      while_break___2: /* CIL Label */ ;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  done: 
#line 780
  return (1);
}
}
#line 784 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/dns_query.c"
__inline static void *realloc_or_cleanup(void *ptr , size_t size ) 
{ 
  void *retval ;
  void *tmp ;

  {
  {
#line 786
  tmp = realloc(ptr, size);
#line 786
  retval = tmp;
  }
#line 787
  if (! retval) {
    {
#line 788
    free(ptr);
    }
  }
#line 789
  return (retval);
}
}
#line 803 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/dns_query.c"
__inline static void switch_to_udp(query_stat_t *st ) 
{ 


  {
  {
#line 805
  st->qm = (short)12;
#line 806
  st->myrid = get_rand16();
#line 807
  (st->msg)->hdr.id = htons(st->myrid);
#line 808
  st->state = (short)4;
  }
#line 810
  return;
}
}
#line 814 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/dns_query.c"
__inline static void switch_to_tcp(query_stat_t *st ) 
{ 


  {
#line 818
  st->qm = (short)13;
#line 819
  st->state = (short)0;
#line 820
  st->failed = (char)0;
#line 821
  return;
}
}
#line 847 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/dns_query.c"
static int p_query_sm(query_stat_t *st ) 
{ 
  int retval ;
  int rv ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int oldflags ;
  int tmp___3 ;
  char _debugsockabuf[16] ;
  int *tmp___4 ;
  char *tmp___5 ;
  char const   *tmp___6 ;
  int tmp___7 ;
  int *tmp___8 ;
  char _debugsockabuf___0[16] ;
  char const   *tmp___9 ;
  char _debugsockabuf___1[16] ;
  int *tmp___10 ;
  char *tmp___11 ;
  char const   *tmp___12 ;
  int *tmp___13 ;
  int *tmp___14 ;
  int *tmp___15 ;
  int tmp___16 ;
  int rem ;
  ssize_t tmp___17 ;
  int *tmp___18 ;
  int *tmp___19 ;
  char _debugsockabuf___2[16] ;
  char *tmp___20 ;
  char const   *tmp___21 ;
  char _debugsockabuf___3[16] ;
  char *tmp___22 ;
  char const   *tmp___23 ;
  uint16_t recvl_net ;
  ssize_t tmp___24 ;
  int *tmp___25 ;
  dns_hdr_t *tmp___26 ;
  void *tmp___27 ;
  int offset ;
  int rem___0 ;
  ssize_t tmp___28 ;
  int *tmp___29 ;
  int *tmp___30 ;
  char _debugsockabuf___4[16] ;
  int *tmp___31 ;
  char *tmp___32 ;
  char const   *tmp___33 ;
  char const   *tmp___34 ;
  char const   *tmp___35 ;
  char _debugsockabuf___5[16] ;
  char const   *tmp___36 ;
  int *tmp___37 ;
  char *tmp___38 ;
  int tmp___39 ;
  int tmp___40 ;
  int *tmp___41 ;
  int *tmp___42 ;
  char _debugsockabuf___6[16] ;
  int *tmp___43 ;
  char *tmp___44 ;
  char const   *tmp___45 ;
  int tmp___46 ;
  int *tmp___47 ;
  char _debugsockabuf___7[16] ;
  int *tmp___48 ;
  char *tmp___49 ;
  char const   *tmp___50 ;
  ssize_t tmp___51 ;
  int udpbufsize ;
  int tmp___52 ;
  dns_hdr_t *tmp___53 ;
  void *tmp___54 ;
  int *tmp___55 ;
  char _debugsockabuf___8[16] ;
  int *tmp___56 ;
  char *tmp___57 ;
  char const   *tmp___58 ;
  ssize_t tmp___59 ;
  uint16_t tmp___60 ;

  {
#line 849
  retval = 2;
  tryagain: 
  {
#line 857
  if ((int )st->state == 1) {
#line 857
    goto case_1;
  }
#line 922
  if ((int )st->state == 2) {
#line 922
    goto case_2;
  }
#line 952
  if ((int )st->state == 3) {
#line 952
    goto case_3;
  }
#line 1007
  if ((int )st->state == 4) {
#line 1007
    goto case_4;
  }
#line 1059
  if ((int )st->state == 5) {
#line 1059
    goto case_5;
  }
#line 854
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 858
  tmp___1 = socket(2, 1, 6);
#line 858
  st->sock = tmp___1;
  }
#line 858
  if (tmp___1 == -1) {
#line 859
    if (debug_p) {
      {
#line 859
      tmp = __errno_location();
#line 859
      tmp___0 = strerror(*tmp);
#line 859
      debug_msg(0, "Could not open socket: %s\n", tmp___0);
      }
    }
#line 860
    goto switch_break;
  }
  {
#line 865
  tmp___2 = bind_socket(st->sock);
  }
#line 865
  if (! tmp___2) {
    {
#line 866
    close(st->sock);
    }
#line 867
    goto switch_break;
  }
  {
#line 873
  tmp___3 = fcntl(st->sock, 3, 0);
#line 873
  oldflags = tmp___3;
  }
#line 874
  if (oldflags == -1) {
#line 874
    goto _L;
  } else {
    {
#line 874
    tmp___7 = fcntl(st->sock, 4, oldflags | 2048);
    }
#line 874
    if (tmp___7 == -1) {
      _L: /* CIL Label */ 
#line 875
      if (debug_p) {
        {
#line 875
        tmp___4 = __errno_location();
#line 875
        tmp___5 = strerror(*tmp___4);
#line 875
        tmp___6 = pdnsd_a2str((pdnsd_a *)(& st->a.sin4.sin_addr), _debugsockabuf,
                              16);
#line 875
        debug_msg(0, "fcntl error while trying to make socket to %s non-blocking: %s\n",
                  tmp___6, tmp___5);
        }
      }
      {
#line 876
      close(st->sock);
      }
#line 877
      goto switch_break;
    }
  }
  {
#line 880
  st->iolen = 0;
#line 884
  tmp___16 = connect(st->sock, (struct sockaddr  const  */* __restrict  */)((struct sockaddr *)(& st->a)),
                     (socklen_t )sizeof(struct sockaddr_in ));
  }
#line 884
  if (tmp___16 == -1) {
    {
#line 885
    tmp___14 = __errno_location();
    }
#line 885
    if (*tmp___14 == 115) {
#line 886
      st->state = (short)2;
#line 888
      return (-1);
    } else {
      {
#line 885
      tmp___15 = __errno_location();
      }
#line 885
      if (*tmp___15 == 32) {
#line 886
        st->state = (short)2;
#line 888
        return (-1);
      } else {
        {
#line 889
        tmp___13 = __errno_location();
        }
#line 889
        if (*tmp___13 == 111) {
          {
#line 890
          tmp___8 = __errno_location();
#line 890
          st->s_errno = *tmp___8;
          }
#line 891
          if (debug_p) {
            {
#line 891
            tmp___9 = pdnsd_a2str((pdnsd_a *)(& st->a.sin4.sin_addr), _debugsockabuf___0,
                                  16);
#line 891
            debug_msg(0, "TCP connection refused by %s\n", tmp___9);
            }
          }
          {
#line 892
          close(st->sock);
          }
#line 893
          goto tcp_failed;
        } else {
#line 914
          if (debug_p) {
            {
#line 914
            tmp___10 = __errno_location();
#line 914
            tmp___11 = strerror(*tmp___10);
#line 914
            tmp___12 = pdnsd_a2str((pdnsd_a *)(& st->a.sin4.sin_addr), _debugsockabuf___1,
                                   16);
#line 914
            debug_msg(0, "Error while connecting to %s: %s\n", tmp___12, tmp___11);
            }
          }
          {
#line 915
          close(st->sock);
          }
#line 916
          goto switch_break;
        }
      }
    }
  }
#line 919
  st->state = (short)2;
  case_2: /* CIL Label */ 
#line 924
  rem = (2 + (int )st->transl) - st->iolen;
#line 925
  if (rem > 0) {
    {
#line 926
    tmp___17 = write(st->sock, (void const   *)((unsigned char *)st->msg + st->iolen),
                     (size_t )rem);
#line 926
    rv = (int )tmp___17;
    }
#line 927
    if (rv == -1) {
      {
#line 928
      tmp___18 = __errno_location();
      }
#line 928
      if (*tmp___18 == 11) {
#line 929
        return (-1);
      }
      {
#line 930
      tmp___19 = __errno_location();
#line 930
      st->s_errno = *tmp___19;
#line 931
      close(st->sock);
      }
#line 932
      if (st->iolen == 0) {
#line 932
        if (st->s_errno == 111) {
#line 932
          goto _L___0;
        } else
#line 932
        if (st->s_errno == 104) {
#line 932
          goto _L___0;
        } else
#line 932
        if (st->s_errno == 32) {
          _L___0: /* CIL Label */ 
#line 937
          if (debug_p) {
            {
#line 937
            tmp___20 = strerror(st->s_errno);
#line 937
            tmp___21 = pdnsd_a2str((pdnsd_a *)(& st->a.sin4.sin_addr), _debugsockabuf___2,
                                   16);
#line 937
            debug_msg(0, "TCP connection to %s failed: %s\n", tmp___21, tmp___20);
            }
          }
#line 938
          goto tcp_failed;
        }
      }
#line 940
      if (debug_p) {
        {
#line 940
        tmp___22 = strerror(st->s_errno);
#line 940
        tmp___23 = pdnsd_a2str((pdnsd_a *)(& st->a.sin4.sin_addr), _debugsockabuf___3,
                               16);
#line 940
        debug_msg(0, "Error while sending data to %s: %s\n", tmp___23, tmp___22);
        }
      }
#line 941
      goto switch_break;
    }
#line 943
    st->iolen += rv;
#line 944
    if (rv < rem) {
#line 945
      return (-1);
    }
  }
#line 948
  st->state = (short)3;
#line 949
  st->iolen = 0;
  case_3: /* CIL Label */ 
#line 953
  if (st->iolen == 0) {
    {
#line 955
    tmp___24 = read(st->sock, (void *)(& recvl_net), sizeof(recvl_net));
#line 955
    rv = (int )tmp___24;
    }
#line 956
    if (rv == -1) {
      {
#line 956
      tmp___25 = __errno_location();
      }
#line 956
      if (*tmp___25 == 11) {
#line 957
        return (-1);
      }
    }
#line 958
    if ((unsigned long )rv != sizeof(recvl_net)) {
#line 959
      goto error_receiv_data;
    }
    {
#line 960
    st->iolen = rv;
#line 961
    st->recvl = ntohs(recvl_net);
#line 962
    tmp___27 = realloc_or_cleanup((void *)st->recvbuf, (size_t )st->recvl);
#line 962
    tmp___26 = (dns_hdr_t *)tmp___27;
#line 962
    st->recvbuf = tmp___26;
    }
#line 962
    if (! tmp___26) {
      {
#line 963
      close(st->sock);
      }
#line 964
      if (debug_p) {
        {
#line 964
        debug_msg(0, "Out of memory in query.\n");
        }
      }
#line 965
      retval = 65535;
#line 966
      goto switch_break;
    }
  }
#line 970
  offset = (int )((unsigned long )st->iolen - sizeof(uint16_t ));
#line 971
  rem___0 = (int )st->recvl - offset;
#line 972
  if (rem___0 > 0) {
    {
#line 973
    tmp___28 = read(st->sock, (void *)((unsigned char *)st->recvbuf + offset), (size_t )rem___0);
#line 973
    rv = (int )tmp___28;
    }
#line 974
    if (rv == -1) {
      {
#line 975
      tmp___29 = __errno_location();
      }
#line 975
      if (*tmp___29 == 11) {
#line 976
        return (-1);
      }
#line 977
      goto error_receiv_data;
    }
#line 979
    if (rv == 0) {
#line 980
      goto error_receiv_data;
    }
#line 981
    st->iolen += rv;
#line 982
    if (rv < rem___0) {
#line 983
      return (-1);
    }
  }
  {
#line 986
  close(st->sock);
#line 987
  st->state = (short)8;
  }
#line 988
  return (0);
  error_receiv_data: 
#line 990
  if (rv == -1) {
    {
#line 990
    tmp___30 = __errno_location();
#line 990
    st->s_errno = *tmp___30;
    }
  }
#line 991
  if (debug_p) {
#line 991
    if (rv == -1) {
      {
#line 991
      tmp___31 = __errno_location();
#line 991
      tmp___32 = strerror(*tmp___31);
#line 991
      tmp___34 = (char const   *)tmp___32;
      }
    } else {
#line 991
      if (rv == 0) {
#line 991
        if (st->iolen == 0) {
#line 991
          tmp___33 = "no data";
        } else {
#line 991
          tmp___33 = "incomplete data";
        }
      } else {
#line 991
        tmp___33 = "incomplete data";
      }
#line 991
      tmp___34 = tmp___33;
    }
    {
#line 991
    tmp___35 = pdnsd_a2str((pdnsd_a *)(& st->a.sin4.sin_addr), _debugsockabuf___4,
                           16);
#line 991
    debug_msg(0, "Error while receiving data from %s: %s\n", tmp___35, tmp___34);
    }
  }
  {
#line 993
  close(st->sock);
  }
  tcp_failed: 
#line 996
  if ((int )st->qm == 14) {
    {
#line 997
    switch_to_udp(st);
    }
#line 998
    if (debug_p) {
      {
#line 998
      tmp___36 = pdnsd_a2str((pdnsd_a *)(& st->a.sin4.sin_addr), _debugsockabuf___5,
                             16);
#line 998
      debug_msg(0, "TCP query to %s failed. Trying to use UDP.\n", tmp___36);
      }
    }
#line 999
    goto tryagain;
  }
#line 1002
  goto switch_break;
  case_4: /* CIL Label */ 
  {
#line 1008
  tmp___39 = socket(2, 2, 17);
#line 1008
  st->sock = tmp___39;
  }
#line 1008
  if (tmp___39 == -1) {
#line 1009
    if (debug_p) {
      {
#line 1009
      tmp___37 = __errno_location();
#line 1009
      tmp___38 = strerror(*tmp___37);
#line 1009
      debug_msg(0, "Could not open socket: %s\n", tmp___38);
      }
    }
#line 1010
    goto switch_break;
  }
  {
#line 1014
  tmp___40 = bind_socket(st->sock);
  }
#line 1014
  if (! tmp___40) {
    {
#line 1015
    close(st->sock);
    }
#line 1016
    goto switch_break;
  }
  {
#line 1023
  tmp___46 = connect(st->sock, (struct sockaddr  const  */* __restrict  */)((struct sockaddr *)(& st->a)),
                     (socklen_t )sizeof(struct sockaddr_in ));
  }
#line 1023
  if (tmp___46 == -1) {
    {
#line 1024
    tmp___42 = __errno_location();
    }
#line 1024
    if (*tmp___42 == 111) {
      {
#line 1024
      tmp___41 = __errno_location();
#line 1024
      st->s_errno = *tmp___41;
      }
    }
#line 1042
    if (debug_p) {
      {
#line 1042
      tmp___43 = __errno_location();
#line 1042
      tmp___44 = strerror(*tmp___43);
#line 1042
      tmp___45 = pdnsd_a2str((pdnsd_a *)(& st->a.sin4.sin_addr), _debugsockabuf___6,
                             16);
#line 1042
      debug_msg(0, "Error while connecting to %s: %s\n", tmp___45, tmp___44);
      }
    }
    {
#line 1043
    close(st->sock);
    }
#line 1044
    goto switch_break;
  }
  {
#line 1050
  tmp___51 = send(st->sock, (void const   *)(& (st->msg)->hdr), (size_t )st->transl,
                  0);
  }
#line 1050
  if (tmp___51 == -1L) {
    {
#line 1051
    tmp___47 = __errno_location();
#line 1051
    st->s_errno = *tmp___47;
    }
#line 1052
    if (debug_p) {
      {
#line 1052
      tmp___48 = __errno_location();
#line 1052
      tmp___49 = strerror(*tmp___48);
#line 1052
      tmp___50 = pdnsd_a2str((pdnsd_a *)(& st->a.sin4.sin_addr), _debugsockabuf___7,
                             16);
#line 1052
      debug_msg(0, "Error while sending data to %s: %s\n", tmp___50, tmp___49);
      }
    }
    {
#line 1053
    close(st->sock);
    }
#line 1054
    goto switch_break;
  }
#line 1056
  st->state = (short)5;
#line 1058
  return (-1);
  case_5: /* CIL Label */ 
#line 1061
  if (st->edns_query) {
#line 1061
    tmp___52 = global.udpbufsize;
  } else {
#line 1061
    tmp___52 = 512;
  }
  {
#line 1061
  udpbufsize = tmp___52;
#line 1062
  tmp___54 = realloc_or_cleanup((void *)st->recvbuf, (size_t )udpbufsize);
#line 1062
  tmp___53 = (dns_hdr_t *)tmp___54;
#line 1062
  st->recvbuf = tmp___53;
  }
#line 1062
  if (! tmp___53) {
    {
#line 1063
    close(st->sock);
    }
#line 1064
    if (debug_p) {
      {
#line 1064
      debug_msg(0, "Out of memory in query.\n");
      }
    }
#line 1065
    retval = 65535;
#line 1066
    goto switch_break;
  }
  {
#line 1068
  tmp___59 = recv(st->sock, (void *)st->recvbuf, (size_t )udpbufsize, 0);
#line 1068
  rv = (int )tmp___59;
  }
#line 1068
  if (rv == -1) {
    {
#line 1069
    tmp___55 = __errno_location();
#line 1069
    st->s_errno = *tmp___55;
    }
#line 1070
    if (debug_p) {
      {
#line 1070
      tmp___56 = __errno_location();
#line 1070
      tmp___57 = strerror(*tmp___56);
#line 1070
      tmp___58 = pdnsd_a2str((pdnsd_a *)(& st->a.sin4.sin_addr), _debugsockabuf___8,
                             16);
#line 1070
      debug_msg(0, "Error while receiving data from %s: %s\n", tmp___58, tmp___57);
      }
    }
    {
#line 1071
    close(st->sock);
    }
#line 1072
    goto switch_break;
  }
#line 1074
  st->recvl = (unsigned short )rv;
#line 1075
  if ((unsigned long )st->recvl < sizeof(dns_hdr_t )) {
#line 1075
    goto _L___1;
  } else {
    {
#line 1075
    tmp___60 = ntohs((st->recvbuf)->id);
    }
#line 1075
    if ((int )tmp___60 != (int )st->myrid) {
      _L___1: /* CIL Label */ 
#line 1076
      if (debug_p) {
        {
#line 1076
        debug_msg(0, "Bad answer received. Ignoring it.\n");
        }
      }
#line 1078
      st->state = (short)5;
#line 1080
      return (-1);
    }
  }
  {
#line 1082
  close(st->sock);
#line 1083
  st->state = (short)8;
  }
#line 1084
  return (0);
  switch_break: /* CIL Label */ ;
  }
#line 1090
  st->state = (short)8;
#line 1091
  return (retval);
}
}
#line 1094 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/dns_query.c"
static dns_cent_t *lookup_cent_array(dns_cent_array ca , unsigned char const   *nm ) 
{ 
  int i ;
  int n ;
  unsigned int tmp ;
  dns_cent_t *ce ;
  int tmp___0 ;

  {
  {
#line 1096
  tmp = da_nel((darray )ca);
#line 1096
  n = (int )tmp;
#line 1097
  i = 0;
  }
  {
#line 1097
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1097
    if (! (i < n)) {
#line 1097
      goto while_break;
    }
    {
#line 1098
    ce = & ca->elem[i];
#line 1099
    tmp___0 = rhnicmp((unsigned char const   *)ce->qname, nm);
    }
#line 1099
    if (tmp___0) {
#line 1100
      return (ce);
    }
#line 1097
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1102
  return ((dns_cent_t *)((void *)0));
}
}
#line 1106 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/dns_query.c"
static time_t soa_minimum(rr_bucket_t *rrs ) 
{ 
  uint32_t minimum ;
  unsigned char *p ;
  unsigned char *tmp ;
  register uint32_t t_l ;
  register unsigned char const   *t_cp ;
  unsigned char const   *tmp___0 ;
  unsigned char const   *tmp___1 ;
  unsigned char const   *tmp___2 ;
  unsigned char const   *tmp___3 ;

  {
  {
#line 1109
  p = (unsigned char *)(rrs->data);
#line 1112
  tmp = skiprhn(p);
#line 1112
  p = skiprhn(tmp);
#line 1114
  p += 4UL * sizeof(uint32_t );
  }
  {
#line 1115
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1115
    t_cp = (unsigned char const   *)p;
#line 1115
    tmp___0 = t_cp;
#line 1115
    t_cp ++;
#line 1115
    t_l = (uint32_t )*tmp___0 << 24;
#line 1115
    tmp___1 = t_cp;
#line 1115
    t_cp ++;
#line 1115
    t_l |= (uint32_t )*tmp___1 << 16;
#line 1115
    tmp___2 = t_cp;
#line 1115
    t_cp ++;
#line 1115
    t_l |= (uint32_t )*tmp___2 << 8;
#line 1115
    tmp___3 = t_cp;
#line 1115
    t_cp ++;
#line 1115
    t_l |= (uint32_t )*tmp___3;
#line 1115
    minimum = t_l;
#line 1115
    p = (unsigned char *)((void *)t_cp);
#line 1115
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 1116
  return ((time_t )minimum);
}
}
#line 1792
static int p_exec_query(dns_cent_t **entp , unsigned char const   *name , int thint ,
                        query_stat_t *st , dlist *ns , unsigned char *c_soa ) ;
#line 1792 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/dns_query.c"
static unsigned short const   nstypes[2]  = {      (unsigned short const   )2,      (unsigned short const   )6};
#line 1886 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/dns_query.c"
static char const   * const  secname[3]  = {      (char const   */* const  */)"answer",      (char const   */* const  */)"authority",      (char const   */* const  */)"additional"};
#line 1137 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/dns_query.c"
static int p_exec_query(dns_cent_t **entp , unsigned char const   *name , int thint ,
                        query_stat_t *st , dlist *ns , unsigned char *c_soa ) 
{ 
  int rv ;
  int rcode ;
  unsigned short rd ;
  size_t transl ;
  size_t allocsz ;
  unsigned int rrnlen ;
  void *tmp ;
  int tmp___0 ;
  unsigned char *p ;
  void *tmp___1 ;
  unsigned short qtype ;
  int tmp___2 ;
  register uint16_t t_s ;
  register unsigned char *t_cp ;
  unsigned char *tmp___3 ;
  unsigned char *tmp___4 ;
  register uint16_t t_s___0 ;
  register unsigned char *t_cp___0 ;
  unsigned char *tmp___5 ;
  unsigned char *tmp___6 ;
  char _debugsockabuf[16] ;
  char const   *tmp___7 ;
  uint16_t recvid ;
  uint16_t tmp___8 ;
  char flgsbuf[22] ;
  char *tmp___9 ;
  char const   *tmp___10 ;
  char _debugsockabuf___0[16] ;
  char const   *tmp___11 ;
  char const   *tmp___12 ;
  char _debugsockabuf___1[16] ;
  char const   *tmp___13 ;
  char const   *tmp___14 ;
  size_t transl___0 ;
  char _debugsockabuf___2[16] ;
  char const   *tmp___15 ;
  char const   *tmp___16 ;
  char _debugsockabuf___3[16] ;
  char const   *tmp___17 ;
  char _debugsockabuf___4[16] ;
  char const   *tmp___18 ;
  time_t queryts ;
  time_t tmp___19 ;
  size_t lcnt ;
  unsigned char *rrp ;
  dns_cent_array secs[3] ;
  unsigned short qtype___0 ;
  unsigned short flags ;
  unsigned short aa ;
  unsigned short neg_ans ;
  unsigned short reject_ans ;
  unsigned short num_ns ;
  int numoptrr ;
  edns_info_t ednsinfo ;
  char _debugsockabuf___5[16] ;
  char const   *tmp___20 ;
  uint16_t tmp___21 ;
  unsigned char nbuf[256] ;
  char _debugsockabuf___6[16] ;
  char const   *tmp___22 ;
  char _debugsockabuf___7[16] ;
  char const   *tmp___23 ;
  int tmp___24 ;
  char _debugsockabuf___8[16] ;
  char const   *tmp___25 ;
  unsigned short qt ;
  unsigned short qc ;
  register uint16_t t_s___1 ;
  register unsigned char const   *t_cp___1 ;
  unsigned char const   *tmp___26 ;
  unsigned char const   *tmp___27 ;
  register uint16_t t_s___2 ;
  register unsigned char const   *t_cp___2 ;
  unsigned char const   *tmp___28 ;
  unsigned char const   *tmp___29 ;
  char _debugsockabuf___9[16] ;
  char const   *tmp___30 ;
  int tmp___31 ;
  int tmp___32 ;
  darray tmp___33 ;
  int tmp___34 ;
  int tmp___35 ;
  uint16_t tmp___36 ;
  uint16_t nscount ;
  uint16_t tmp___37 ;
  uint16_t arcount ;
  uint16_t tmp___38 ;
  char _debugsockabuf___10[16] ;
  char const   *tmp___39 ;
  char _debugsockabuf___11[16] ;
  char const   *tmp___40 ;
  char const   *tmp___41 ;
  char _debugsockabuf___12[16] ;
  char const   *tmp___42 ;
  char const   *tmp___43 ;
  char const   *tmp___44 ;
  char const   *tmp___45 ;
  int i ;
  int n ;
  unsigned int tmp___46 ;
  dns_cent_t *cent ;
  unsigned int scnt ;
  unsigned int tmp___47 ;
  rr_set_t *tmp___48 ;
  rr_set_t *tmp___49 ;
  int j ;
  int m ;
  unsigned int tmp___50 ;
  dns_cent_t *ce ;
  unsigned int ml ;
  unsigned int rem ;
  rr_set_t *tmp___51 ;
  rr_set_t *tmp___52 ;
  rr_set_t *tmp___53 ;
  int i___0 ;
  int na4 ;
  addr4maskpair_t *a4arr ;
  int na6 ;
  addr6maskpair_t *a6arr ;
  dns_cent_array sec ;
  int j___0 ;
  int nce ;
  unsigned int tmp___54 ;
  dns_cent_t *cent___0 ;
  rr_set_t *rrset ;
  rr_set_t *tmp___55 ;
  rr_bucket_t *rr ;
  struct in_addr *a ;
  int k ;
  addr4maskpair_t *am ;
  unsigned char nmbuf[256] ;
  char abuf[16] ;
  char _debugsockabuf___13[16] ;
  char const   *tmp___56 ;
  unsigned char const   *tmp___57 ;
  char const   *tmp___58 ;
  rr_bucket_t *rr___0 ;
  struct in6_addr *a___0 ;
  int k___0 ;
  addr6maskpair_t *am___0 ;
  unsigned char nmbuf___0[256] ;
  char abuf___0[46] ;
  char _debugsockabuf___14[16] ;
  char const   *tmp___59 ;
  unsigned char const   *tmp___60 ;
  char const   *tmp___61 ;
  char _debugsockabuf___15[16] ;
  char const   *tmp___62 ;
  char const   *tmp___63 ;
  dns_cent_t *ent ;
  int neg_domain_pol ;
  time_t ttl ;
  unsigned int scnt___0 ;
  unsigned int tmp___64 ;
  dns_cent_t *cent___1 ;
  rr_set_t *rrset___0 ;
  rr_set_t *tmp___65 ;
  time_t min ;
  time_t tmp___66 ;
  unsigned char const   *tmp___67 ;
  unsigned char _debugstrbuf[256] ;
  unsigned char const   *tmp___68 ;
  int missingdelegation ;
  int authcnt ;
  int i___1 ;
  int n___0 ;
  unsigned int tmp___69 ;
  unsigned int rem___0 ;
  unsigned int zrem ;
  unsigned int tmp___70 ;
  int j___1 ;
  dns_cent_array sec___0 ;
  int k___1 ;
  int m___0 ;
  unsigned int tmp___71 ;
  dns_cent_t *ce___0 ;
  int l ;
  unsigned int tmp___72 ;
  rr_set_t *tmp___73 ;
  rr_set_t *tmp___74 ;
  unsigned char nmbuf___1[256] ;
  unsigned char zbuf[256] ;
  char _debugsockabuf___16[16] ;
  char const   *tmp___75 ;
  unsigned char const   *tmp___76 ;
  unsigned char const   *tmp___77 ;
  char const   *tmp___78 ;
  dns_cent_t *ent___0 ;
  int neg_rrs_pol ;
  time_t ttl___0 ;
  rr_set_t *rrset___1 ;
  rr_set_t *tmp___79 ;
  dns_cent_t *cent___2 ;
  unsigned int scnt___1 ;
  time_t min___0 ;
  time_t tmp___80 ;
  unsigned char const   *tmp___81 ;
  unsigned char const   *tmp___82 ;
  unsigned char _debugstrbuf___0[256] ;
  unsigned char const   *tmp___83 ;
  char const   *tmp___84 ;
  int tmp___85 ;
  rr_set_t *tmp___86 ;
  int i___2 ;
  dns_cent_array sec___1 ;
  int j___2 ;
  int n___1 ;
  unsigned int tmp___87 ;
  dns_cent_t *cent___3 ;
  unsigned int rem___1 ;
  int k___2 ;
  rr_set_t *rrset___2 ;
  rr_set_t *tmp___88 ;
  rr_bucket_t *rr___1 ;
  unsigned short first ;
  size_t sz1 ;
  size_t sz2 ;
  unsigned char *p___0 ;
  void *tmp___89 ;
  void *tmp___90 ;
  unsigned char *tmp___91 ;
  unsigned char *tmp___92 ;
  int tmp___93 ;
  unsigned int tmp___94 ;
  unsigned int tmp___95 ;
  dlist tmp___96 ;
  void *tmp___97 ;
  void *tmp___98 ;
  unsigned char *tmp___99 ;
  char _debugsockabuf___17[16] ;
  char const   *tmp___100 ;
  dns_cent_t *tmp___101 ;
  void *tmp___102 ;
  int i___3 ;
  int j___3 ;
  int n___2 ;
  unsigned int tmp___103 ;
  unsigned char nmbuf___2[256] ;
  unsigned char nmbuf2[256] ;
  char _debugsockabuf___18[16] ;
  unsigned char const   *tmp___104 ;
  unsigned char const   *tmp___105 ;
  char const   *tmp___106 ;
  dns_cent_array sec___2 ;
  int j___4 ;
  int n___3 ;
  unsigned int tmp___107 ;
  dns_cent_t *cent___4 ;
  unsigned int rem___2 ;
  unsigned char nmbuf___3[256] ;
  unsigned char nsbuf[256] ;
  unsigned char const   *tmp___108 ;
  unsigned char const   *tmp___109 ;
  char _debugsockabuf___19[16] ;
  char const   *tmp___110 ;
  unsigned int tmp___111 ;
  int i___4 ;
  dns_cent_array sec___3 ;
  int j___5 ;
  int n___4 ;
  unsigned int tmp___112 ;

  {
  {
#line 1144
  if ((int )st->state == 0) {
#line 1144
    goto case_0;
  }
#line 1196
  if ((int )st->state == 5) {
#line 1196
    goto tryagain;
  }
#line 1196
  if ((int )st->state == 4) {
#line 1196
    goto tryagain;
  }
#line 1196
  if ((int )st->state == 3) {
#line 1196
    goto tryagain;
  }
#line 1196
  if ((int )st->state == 2) {
#line 1196
    goto tryagain;
  }
#line 1196
  if ((int )st->state == 1) {
#line 1196
    goto tryagain;
  }
#line 1348
  goto switch_default;
  case_0: /* CIL Label */ 
#line 1146
  rrnlen = 0U;
#line 1148
  allocsz = sizeof(dns_msg_t );
#line 1149
  if (name) {
    {
#line 1150
    rrnlen = rhnlen(name);
#line 1151
    allocsz += (size_t )(rrnlen + 4U);
    }
#line 1152
    if (st->edns_query) {
#line 1153
      allocsz += 11UL;
    }
  }
  {
#line 1155
  tmp = malloc(allocsz);
#line 1155
  st->msg = (dns_msg_t *)tmp;
  }
#line 1156
  if (! st->msg) {
#line 1157
    st->state = (short)8;
#line 1158
    return (65535);
  }
  {
#line 1160
  st->myrid = get_rand16();
#line 1161
  (st->msg)->hdr.id = htons(st->myrid);
#line 1162
  (st->msg)->hdr.qr = 0U;
#line 1163
  (st->msg)->hdr.opcode = 0U;
#line 1164
  (st->msg)->hdr.aa = 0U;
#line 1165
  (st->msg)->hdr.tc = 0U;
  }
#line 1166
  if (name) {
#line 1166
    if (st->trusted) {
#line 1166
      tmp___0 = 1;
    } else {
#line 1166
      tmp___0 = 0;
    }
  } else {
#line 1166
    tmp___0 = 0;
  }
  {
#line 1166
  (st->msg)->hdr.rd = (unsigned int )tmp___0;
#line 1167
  (st->msg)->hdr.ra = 0U;
#line 1168
  (st->msg)->hdr.z = 0U;
#line 1169
  (st->msg)->hdr.ad = 0U;
#line 1170
  (st->msg)->hdr.cd = 0U;
#line 1171
  (st->msg)->hdr.rcode = 0U;
#line 1172
  (st->msg)->hdr.qdcount = htons((uint16_t )((unsigned long )name != (unsigned long )((void *)0)));
#line 1173
  (st->msg)->hdr.ancount = (uint16_t )0;
#line 1174
  (st->msg)->hdr.nscount = (uint16_t )0;
#line 1175
  (st->msg)->hdr.arcount = (uint16_t )0;
#line 1177
  transl = sizeof(dns_hdr_t );
  }
#line 1178
  if (name) {
    {
#line 1179
    tmp___1 = mempcpy((void */* __restrict  */)((unsigned char *)(& (st->msg)->hdr + 1)),
                      (void const   */* __restrict  */)name, (size_t )rrnlen);
#line 1179
    p = (unsigned char *)tmp___1;
    }
#line 1180
    if (st->lean_query) {
#line 1180
      tmp___2 = thint;
    } else {
#line 1180
      tmp___2 = 255;
    }
#line 1180
    qtype = (unsigned short )tmp___2;
    {
#line 1181
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1181
      t_s = qtype;
#line 1181
      t_cp = p;
#line 1181
      tmp___3 = t_cp;
#line 1181
      t_cp ++;
#line 1181
      *tmp___3 = (unsigned char )((int )t_s >> 8);
#line 1181
      tmp___4 = t_cp;
#line 1181
      t_cp ++;
#line 1181
      *tmp___4 = (unsigned char )t_s;
#line 1181
      p = (unsigned char *)((void *)t_cp);
#line 1181
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 1182
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1182
      t_s___0 = (uint16_t )1;
#line 1182
      t_cp___0 = p;
#line 1182
      tmp___5 = t_cp___0;
#line 1182
      t_cp___0 ++;
#line 1182
      *tmp___5 = (unsigned char )((int )t_s___0 >> 8);
#line 1182
      tmp___6 = t_cp___0;
#line 1182
      t_cp___0 ++;
#line 1182
      *tmp___6 = (unsigned char )t_s___0;
#line 1182
      p = (unsigned char *)((void *)t_cp___0);
#line 1182
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1183
    transl += (size_t )(rrnlen + 4U);
#line 1184
    if (st->edns_query) {
      {
#line 1185
      add_opt_pseudo_rr(& st->msg, & transl, & allocsz, (unsigned short )global.udpbufsize,
                        (unsigned short)0, (unsigned short)0, (unsigned short)0);
      }
    }
  }
  {
#line 1188
  st->transl = (unsigned short )transl;
#line 1190
  (st->msg)->len = htons(st->transl);
#line 1192
  st->recvbuf = (dns_hdr_t *)((void *)0);
  }
#line 1193
  if ((int )st->qm == 12) {
#line 1193
    st->state = (short)4;
  } else
#line 1193
  if ((int )st->qm == 15) {
#line 1193
    st->state = (short)4;
  } else {
#line 1193
    st->state = (short)1;
  }
  tryagain: 
  case_5: /* CIL Label */ 
  case_4: /* CIL Label */ 
  case_3: /* CIL Label */ 
  case_2: /* CIL Label */ 
  case_1: /* CIL Label */ 
  {
#line 1198
  rv = p_query_sm(st);
  }
#line 1199
  if (rv == -1) {
#line 1200
    return (-1);
  }
#line 1202
  if (rv != 0) {
    {
#line 1203
    free((void *)st->msg);
#line 1204
    free((void *)st->recvbuf);
#line 1205
    st->state = (short)8;
    }
#line 1206
    if (st->needs_testing) {
      {
#line 1215
      if (st->s_errno == 64) {
#line 1215
        goto case_64;
      }
#line 1215
      if (st->s_errno == 112) {
#line 1215
        goto case_64;
      }
#line 1215
      if (st->s_errno == 100) {
#line 1215
        goto case_64;
      }
#line 1215
      if (st->s_errno == 111) {
#line 1215
        goto case_64;
      }
#line 1215
      if (st->s_errno == 92) {
#line 1215
        goto case_64;
      }
#line 1215
      if (st->s_errno == 113) {
#line 1215
        goto case_64;
      }
#line 1215
      if (st->s_errno == 101) {
#line 1215
        goto case_64;
      }
#line 1207
      goto switch_break___0;
      case_64: /* CIL Label */ 
      case_112: /* CIL Label */ 
      case_100: /* CIL Label */ 
      case_111: /* CIL Label */ 
      case_92: /* CIL Label */ 
      case_113: /* CIL Label */ 
      case_101: /* CIL Label */ 
      {
#line 1218
      sched_server_test((pdnsd_a *)(& st->a.sin4.sin_addr), 1, 0);
#line 1219
      st->needs_testing = (char)0;
      }
      switch_break___0: /* CIL Label */ ;
      }
    }
#line 1222
    return (rv);
  }
#line 1225
  if (debug_p) {
    {
#line 1225
    tmp___7 = pdnsd_a2str((pdnsd_a *)(& st->a.sin4.sin_addr), _debugsockabuf, 16);
#line 1225
    debug_msg(0, "Received reply from %s (msg len=%u).\n", tmp___7, (int )st->recvl);
    }
  }
#line 1229
  if ((unsigned long )st->recvl < sizeof(dns_hdr_t )) {
#line 1230
    if (debug_p) {
      {
#line 1230
      debug_msg(0, "Message too short!\n");
      }
    }
#line 1231
    goto discard_reply;
  }
  {
#line 1234
  tmp___8 = ntohs((st->recvbuf)->id);
#line 1234
  recvid = tmp___8;
  }
#line 1235
  if ((int )recvid != (int )st->myrid) {
#line 1236
    if (debug_p) {
      {
#line 1236
      debug_msg(0, "ID mismatch: expected %04x, got %04x!\n", (int )st->myrid, (int )recvid);
      }
    }
#line 1237
    goto discard_reply;
  }
#line 1240
  if ((st->recvbuf)->qr != 1U) {
#line 1241
    if (debug_p) {
      {
#line 1241
      debug_msg(0, "The QR bit indicates this is a query, not a response!\n");
      }
    }
#line 1242
    goto discard_reply;
  }
#line 1244
  if ((st->recvbuf)->opcode != 0U) {
#line 1245
    if (debug_p) {
      {
#line 1245
      debug_msg(0, "Not a reply to a standard query (opcode=%u).\n", (st->recvbuf)->opcode);
      }
    }
#line 1246
    goto discard_reply;
  }
#line 1249
  rcode = (int )(st->recvbuf)->rcode;
#line 1253
  if (debug_p) {
    {
#line 1253
    tmp___9 = dnsflags2str(st->recvbuf, flgsbuf);
#line 1253
    tmp___10 = get_ename(rcode);
#line 1253
    debug_msg(0, "rcode=%u (%s), flags:%s\n", rcode, tmp___10, tmp___9);
    }
  }
#line 1256
  if ((st->recvbuf)->z != 0U) {
#line 1257
    if (debug_p) {
      {
#line 1257
      debug_msg(0, "Malformed response (nonzero Z bit).\n");
      }
    }
#line 1258
    goto discard_reply;
  }
#line 1261
  if (st->needs_testing) {
    {
#line 1263
    sched_server_test((pdnsd_a *)(& st->a.sin4.sin_addr), 1, 1);
#line 1264
    st->needs_testing = (char)0;
    }
  }
#line 1267
  rv = rcode;
#line 1268
  if (rcode == 0) {
#line 1270
    st->state = (short)8;
#line 1271
    goto switch_break;
  } else
#line 1268
  if (rcode == 3) {
#line 1270
    st->state = (short)8;
#line 1271
    goto switch_break;
  } else
#line 1273
  if (entp) {
#line 1274
    if (rcode == 2) {
#line 1274
      goto _L___3;
    } else
#line 1274
    if (rcode == 4) {
#line 1274
      goto _L___3;
    } else
#line 1274
    if (rcode == 5) {
      _L___3: /* CIL Label */ 
#line 1275
      if ((st->msg)->hdr.rd) {
#line 1275
        if (! (st->recvbuf)->ra) {
#line 1278
          if (debug_p) {
            {
#line 1278
            tmp___11 = get_ename(rcode);
#line 1278
            tmp___12 = pdnsd_a2str((pdnsd_a *)(& st->a.sin4.sin_addr), _debugsockabuf___0,
                                   16);
#line 1278
            debug_msg(0, "Server %s returned error code: %s. Maybe does not support recursive query? Querying non-recursively.\n",
                      tmp___12, tmp___11);
            }
          }
#line 1282
          (st->msg)->hdr.rd = 0U;
#line 1283
          goto resetstate_tryagain;
        } else {
#line 1275
          goto _L___1;
        }
      } else
      _L___1: /* CIL Label */ 
#line 1285
      if (rcode != 2) {
#line 1285
        if (st->edns_query) {
#line 1285
          if ((st->msg)->hdr.arcount) {
#line 1286
            goto try_withoutedns;
          } else {
#line 1285
            goto _L___0;
          }
        } else {
#line 1285
          goto _L___0;
        }
      } else
      _L___0: /* CIL Label */ 
#line 1287
      if ((st->recvbuf)->ancount) {
#line 1287
        if ((int )st->auth_serv == 2) {
#line 1293
          if (debug_p) {
            {
#line 1293
            tmp___13 = get_ename(rcode);
#line 1293
            tmp___14 = pdnsd_a2str((pdnsd_a *)(& st->a.sin4.sin_addr), _debugsockabuf___1,
                                   16);
#line 1293
            debug_msg(0, "Server %s returned error code: %s, but the answer section is not empty. Using the answer tentatively.\n",
                      tmp___14, tmp___13);
            }
          }
#line 1297
          st->failed = (char)3;
#line 1298
          st->state = (short)8;
#line 1299
          goto switch_break;
        }
      }
    } else
#line 1302
    if (rcode == 1) {
#line 1302
      if (st->edns_query) {
#line 1302
        if ((st->msg)->hdr.arcount) {
          try_withoutedns: 
#line 1308
          if (debug_p) {
            {
#line 1308
            tmp___15 = get_ename(rcode);
#line 1308
            tmp___16 = pdnsd_a2str((pdnsd_a *)(& st->a.sin4.sin_addr), _debugsockabuf___2,
                                   16);
#line 1308
            debug_msg(0, "Server %s returned error code: %s. Maybe cannot handle EDNS? Querying with empty additional section.\n",
                      tmp___16, tmp___15);
            }
          }
          {
#line 1312
          transl___0 = remove_opt_pseudo_rr(st->msg, (size_t )st->transl);
          }
#line 1313
          if (transl___0 != 0UL) {
#line 1313
            if ((int )(st->msg)->hdr.arcount == 0) {
              {
#line 1314
              st->transl = (unsigned short )transl___0;
#line 1316
              (st->msg)->len = htons(st->transl);
#line 1318
              st->edns_query = (char)0;
              }
              resetstate_tryagain: 
              {
#line 1320
              st->myrid = get_rand16();
#line 1321
              (st->msg)->hdr.id = htons(st->myrid);
              }
#line 1322
              if ((int )st->qm == 12) {
#line 1322
                st->state = (short)4;
              } else
#line 1322
              if ((int )st->qm == 15) {
#line 1322
                st->state = (short)4;
              } else {
#line 1322
                st->state = (short)1;
              }
#line 1323
              goto tryagain;
            } else {
#line 1313
              goto _L___2;
            }
          } else
          _L___2: /* CIL Label */ 
#line 1326
          if (debug_p) {
            {
#line 1326
            tmp___17 = pdnsd_a2str((pdnsd_a *)(& st->a.sin4.sin_addr), _debugsockabuf___3,
                                   16);
#line 1326
            debug_msg(0, "Internal error: could not remove additional section from query to server %s\n",
                      tmp___17);
            }
          }
        }
      }
    }
  }
  discard_reply: 
  {
#line 1334
  free((void *)st->msg);
#line 1335
  free((void *)st->recvbuf);
#line 1337
  st->state = (short)8;
  }
#line 1339
  if (entp) {
#line 1340
    if (debug_p) {
      {
#line 1340
      tmp___18 = pdnsd_a2str((pdnsd_a *)(& st->a.sin4.sin_addr), _debugsockabuf___4,
                             16);
#line 1340
      debug_msg(0, "Discarding reply from server %s\n", tmp___18);
      }
    }
  }
#line 1343
  if (rv != 0) {
#line 1344
    return (rv);
  }
#line 1346
  return (2);
  switch_default: /* CIL Label */ 
#line 1349
  st->state = (short)8;
#line 1350
  return (2);
  switch_break: /* CIL Label */ ;
  }
  {
#line 1357
  rd = (unsigned short )(st->msg)->hdr.rd;
#line 1358
  free((void *)st->msg);
  }
#line 1359
  if (entp) {
    {
#line 1360
    tmp___19 = time((time_t *)((void *)0));
#line 1360
    queryts = tmp___19;
#line 1361
    lcnt = (size_t )st->recvl - sizeof(dns_hdr_t );
#line 1362
    rrp = (unsigned char *)(st->recvbuf + 1);
#line 1363
    secs[0] = (dns_cent_array )((void *)0);
#line 1363
    secs[1] = (dns_cent_array )((void *)0);
#line 1363
    secs[2] = (dns_cent_array )((void *)0);
#line 1367
    neg_ans = (unsigned short)0;
#line 1367
    reject_ans = (unsigned short)0;
#line 1367
    num_ns = (unsigned short)0;
#line 1369
    ednsinfo.udpsize = (unsigned short)0;
#line 1369
    ednsinfo.rcode = (unsigned short)0;
#line 1369
    ednsinfo.version = (unsigned short)0;
#line 1369
    ednsinfo.do_flg = (unsigned char)0;
#line 1371
    tmp___21 = ntohs((st->recvbuf)->qdcount);
    }
#line 1371
    if ((int )tmp___21 != 1) {
#line 1372
      if (debug_p) {
        {
#line 1372
        tmp___20 = pdnsd_a2str((pdnsd_a *)(& st->a.sin4.sin_addr), _debugsockabuf___5,
                               16);
#line 1372
        debug_msg(0, "Bad number of query records in answer from %s\n", tmp___20);
        }
      }
#line 1374
      rv = 2;
#line 1375
      goto free_recvbuf_return;
    }
    {
#line 1380
    rv = decompress_name((unsigned char *)st->recvbuf, (size_t )st->recvl, & rrp,
                         & lcnt, nbuf, (unsigned int *)((void *)0));
    }
#line 1380
    if (rv != 0) {
#line 1381
      if (debug_p) {
        {
#line 1381
        tmp___22 = pdnsd_a2str((pdnsd_a *)(& st->a.sin4.sin_addr), _debugsockabuf___6,
                               16);
#line 1381
        debug_msg(0, "Cannot decompress QNAME in answer from %s\n", tmp___22);
        }
      }
#line 1383
      rv = 2;
#line 1384
      goto free_recvbuf_return;
    }
    {
#line 1386
    tmp___24 = rhnicmp((unsigned char const   *)(nbuf), name);
    }
#line 1386
    if (! tmp___24) {
#line 1387
      if (debug_p) {
        {
#line 1387
        tmp___23 = pdnsd_a2str((pdnsd_a *)(& st->a.sin4.sin_addr), _debugsockabuf___7,
                               16);
#line 1387
        debug_msg(0, "Answer from %s does not match query.\n", tmp___23);
        }
      }
#line 1389
      rv = 2;
#line 1390
      goto free_recvbuf_return;
    }
#line 1394
    if (st->lean_query) {
#line 1394
      qtype___0 = (unsigned short )thint;
    } else {
#line 1394
      qtype___0 = (unsigned short)255;
    }
#line 1395
    if (lcnt < 4UL) {
#line 1396
      if (debug_p) {
        {
#line 1396
        tmp___25 = pdnsd_a2str((pdnsd_a *)(& st->a.sin4.sin_addr), _debugsockabuf___8,
                               16);
#line 1396
        debug_msg(0, "Format error in reply from %s (message truncated in qtype or qclass).\n",
                  tmp___25);
        }
      }
#line 1398
      rv = 2;
#line 1399
      goto free_recvbuf_return;
    }
    {
#line 1403
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1403
      t_cp___1 = (unsigned char const   *)rrp;
#line 1403
      tmp___26 = t_cp___1;
#line 1403
      t_cp___1 ++;
#line 1403
      t_s___1 = (uint16_t )((int )((uint16_t )*tmp___26) << 8);
#line 1403
      tmp___27 = t_cp___1;
#line 1403
      t_cp___1 ++;
#line 1403
      t_s___1 = (uint16_t )((int )t_s___1 | (int )((uint16_t )*tmp___27));
#line 1403
      qt = t_s___1;
#line 1403
      rrp = (unsigned char *)((void *)t_cp___1);
#line 1403
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 1404
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 1404
      t_cp___2 = (unsigned char const   *)rrp;
#line 1404
      tmp___28 = t_cp___2;
#line 1404
      t_cp___2 ++;
#line 1404
      t_s___2 = (uint16_t )((int )((uint16_t )*tmp___28) << 8);
#line 1404
      tmp___29 = t_cp___2;
#line 1404
      t_cp___2 ++;
#line 1404
      t_s___2 = (uint16_t )((int )t_s___2 | (int )((uint16_t )*tmp___29));
#line 1404
      qc = t_s___2;
#line 1404
      rrp = (unsigned char *)((void *)t_cp___2);
#line 1404
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 1405
    if ((int )qt != (int )qtype___0) {
#line 1406
      if (debug_p) {
        {
#line 1406
        tmp___30 = pdnsd_a2str((pdnsd_a *)(& st->a.sin4.sin_addr), _debugsockabuf___9,
                               16);
#line 1406
        debug_msg(0, "qtype in answer (%u) from %s does not match expected qtype (%u).\n",
                  (int )qt, tmp___30, (int )qtype___0);
        }
      }
#line 1408
      rv = 2;
#line 1409
      goto free_recvbuf_return;
    }
#line 1412
    lcnt -= 4UL;
#line 1414
    if ((st->recvbuf)->aa) {
#line 1414
      if (! st->failed) {
#line 1414
        tmp___31 = 1;
      } else {
#line 1414
        tmp___31 = 0;
      }
    } else {
#line 1414
      tmp___31 = 0;
    }
#line 1414
    st->aa = (char )tmp___31;
#line 1415
    st->tc = (char )(st->recvbuf)->tc;
#line 1418
    if (st->aa) {
#line 1418
      if (! st->tc) {
#line 1418
        tmp___32 = 1;
      } else {
#line 1418
        tmp___32 = 0;
      }
    } else {
#line 1418
      tmp___32 = 0;
    }
#line 1418
    aa = (unsigned short )tmp___32;
#line 1419
    flags = st->flags;
#line 1420
    if (aa) {
#line 1420
      flags = (unsigned short )((int )flags | 4);
    }
    {
#line 1424
    tmp___33 = da_grow1((darray )secs[0], (size_t )(((dns_cent_array )0)->elem), sizeof((secs[0])->elem[0]),
                        (void (*)(void * ))((void *)0));
#line 1424
    secs[0] = (dns_cent_array )tmp___33;
    }
#line 1424
    if (! secs[0]) {
#line 1425
      rv = 65535;
#line 1426
      goto free_recvbuf_return;
    }
#line 1429
    if (aa) {
#line 1429
      if ((int )qtype___0 == 255) {
#line 1429
        tmp___34 = 4;
      } else {
#line 1429
        tmp___34 = 0;
      }
    } else {
#line 1429
      tmp___34 = 0;
    }
    {
#line 1429
    tmp___35 = init_cent(& (secs[0])->elem[0], name, (time_t )0, (time_t )0, (unsigned int )tmp___34);
    }
#line 1429
    if (! tmp___35) {
#line 1430
      rv = 65535;
#line 1431
      goto free_centarrays_recvbuf_return;
    }
    {
#line 1437
    numoptrr = 0;
#line 1438
    tmp___36 = ntohs((st->recvbuf)->ancount);
#line 1438
    rv = rrs2cent((unsigned char *)st->recvbuf, (size_t )st->recvl, & rrp, & lcnt,
                  (int )tmp___36, (unsigned int )flags, queryts, & secs[0], & numoptrr,
                  & ednsinfo);
    }
#line 1441
    if (numoptrr != 0) {
#line 1442
      if (debug_p) {
        {
#line 1442
        debug_msg(0, "Answer section in reply contains %d OPT pseudo-RRs!\n", numoptrr);
        }
      }
    }
#line 1445
    numoptrr = 0;
#line 1446
    if (rv == 0) {
      {
#line 1447
      tmp___37 = ntohs((st->recvbuf)->nscount);
#line 1447
      nscount = tmp___37;
      }
#line 1448
      if (nscount) {
        {
#line 1449
        rv = rrs2cent((unsigned char *)st->recvbuf, (size_t )st->recvl, & rrp, & lcnt,
                      (int )nscount, (unsigned int )((int )flags | 16), queryts, & secs[1],
                      & numoptrr, & ednsinfo);
        }
#line 1452
        if (numoptrr != 0) {
#line 1453
          if (debug_p) {
            {
#line 1453
            debug_msg(0, "Authority section in reply contains %d OPT pseudo-RRs!\n",
                      numoptrr);
            }
          }
        }
      }
    }
#line 1459
    numoptrr = 0;
#line 1460
    if (rv == 0) {
      {
#line 1461
      tmp___38 = ntohs((st->recvbuf)->arcount);
#line 1461
      arcount = tmp___38;
      }
#line 1462
      if (arcount) {
        {
#line 1463
        rv = rrs2cent((unsigned char *)st->recvbuf, (size_t )st->recvl, & rrp, & lcnt,
                      (int )arcount, (unsigned int )((int )flags | 16), queryts, & secs[2],
                      & numoptrr, & ednsinfo);
        }
#line 1465
        if (numoptrr != 0) {
#line 1467
          if (numoptrr != 1) {
#line 1468
            if (debug_p) {
              {
#line 1468
              debug_msg(0, "Additional section in reply contains %d OPT pseudo-RRs!\n",
                        numoptrr);
              }
            }
          }
#line 1470
          if (debug_p) {
            {
#line 1470
            tmp___39 = pdnsd_a2str((pdnsd_a *)(& st->a.sin4.sin_addr), _debugsockabuf___10,
                                   16);
#line 1470
            debug_msg(0, "Reply from %s contains OPT pseudosection: EDNS version = %u, udp size = %u, flag DO=%u\n",
                      tmp___39, (int )ednsinfo.version, (int )ednsinfo.udpsize, (int )ednsinfo.do_flg);
            }
          }
#line 1473
          if (rcode != (int )ednsinfo.rcode) {
#line 1474
            if (debug_p) {
              {
#line 1474
              tmp___40 = get_ename((int )ednsinfo.rcode);
#line 1474
              tmp___41 = pdnsd_a2str((pdnsd_a *)(& st->a.sin4.sin_addr), _debugsockabuf___11,
                                     16);
#line 1474
              debug_msg(0, "Reply from %s contains unexpected EDNS rcode %u (%s)!\n",
                        tmp___41, (int )ednsinfo.rcode, tmp___40);
              }
            }
#line 1476
            rcode = (int )ednsinfo.rcode;
#line 1478
            if (! st->failed) {
#line 1478
              st->failed = (char)1;
            }
          }
        }
      }
    }
#line 1484
    if (! (rv == 0)) {
#line 1484
      if (rv == 65534) {
#line 1484
        if (! (st->recvbuf)->tc) {
#line 1484
          goto _L___4;
        }
      } else {
        _L___4: /* CIL Label */ 
#line 1485
        if (debug_p) {
          {
#line 1485
          tmp___42 = pdnsd_a2str((pdnsd_a *)(& st->a.sin4.sin_addr), _debugsockabuf___12,
                                 16);
          }
#line 1485
          if (rv == 1) {
#line 1485
            tmp___45 = "Format error in reply from %s.\n";
          } else {
#line 1485
            if (rv == 65534) {
#line 1485
              tmp___44 = "Format error in reply from %s (message unexpectedly truncated).\n";
            } else {
#line 1485
              if (rv == 2) {
#line 1485
                tmp___43 = "Inconsistent timestamps in reply from %s.\n";
              } else {
#line 1485
                tmp___43 = "Out of memory while processing reply from %s.\n";
              }
#line 1485
              tmp___44 = tmp___43;
            }
#line 1485
            tmp___45 = tmp___44;
          }
          {
#line 1485
          debug_msg(0, tmp___45, tmp___42);
          }
        }
#line 1490
        if (rv == 2) {
#line 1494
          if (! st->failed) {
#line 1494
            st->failed = (char)1;
          }
        } else {
#line 1497
          if (rv != 65535) {
#line 1497
            rv = 2;
          }
#line 1498
          goto free_ent_centarrays_recvbuf_return;
        }
      }
    }
    {
#line 1505
    tmp___46 = da_nel((darray )secs[0]);
#line 1505
    n = (int )tmp___46;
#line 1506
    i = 0;
    }
    {
#line 1506
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 1506
      if (! (i < n)) {
#line 1506
        goto while_break___3;
      }
      {
#line 1507
      cent = & (secs[0])->elem[i];
#line 1508
      tmp___47 = rhnsegcnt((unsigned char const   *)cent->qname);
#line 1508
      scnt = tmp___47;
      }
#line 1510
      if (! ((int )cent->flags & 1)) {
#line 1510
        tmp___48 = cent->__annonCompField2.rr.rrmu[1];
      } else {
#line 1510
        tmp___48 = (rr_set_t *)((void *)0);
      }
#line 1510
      if (tmp___48) {
#line 1511
        cent->c_ns = (unsigned char )scnt;
      }
#line 1512
      if (! ((int )cent->flags & 1)) {
#line 1512
        tmp___49 = cent->__annonCompField2.rr.rrmu[3];
      } else {
#line 1512
        tmp___49 = (rr_set_t *)((void *)0);
      }
#line 1512
      if (tmp___49) {
#line 1513
        cent->c_soa = (unsigned char )scnt;
      }
#line 1515
      if ((int )qtype___0 >= 251) {
#line 1515
        if ((int )qtype___0 <= 255) {
#line 1515
          goto _L___6;
        } else {
#line 1515
          goto _L___7;
        }
      } else {
        _L___7: /* CIL Label */ 
        {
#line 1515
        tmp___53 = getrrset(cent, (int )qtype___0);
        }
#line 1515
        if (tmp___53) {
#line 1515
          goto _L___6;
        } else
#line 1515
        if (n == 1) {
#line 1515
          if ((int )cent->num_rrs == 0) {
            _L___6: /* CIL Label */ 
            {
#line 1520
            tmp___50 = da_nel((darray )secs[1]);
#line 1520
            m = (int )tmp___50;
#line 1521
            j = 0;
            }
            {
#line 1521
            while (1) {
              while_continue___4: /* CIL Label */ ;
#line 1521
              if (! (j < m)) {
#line 1521
                goto while_break___4;
              }
              {
#line 1522
              ce = & (secs[1])->elem[j];
#line 1524
              ml = domain_match((unsigned char const   *)ce->qname, (unsigned char const   *)cent->qname,
                                & rem, (unsigned int *)((void *)0));
              }
#line 1525
              if (rem == 0U) {
#line 1525
                if (ml) {
#line 1525
                  goto _L___5;
                } else
#line 1525
                if ((int )st->auth_serv != 2) {
                  _L___5: /* CIL Label */ 
#line 1529
                  if (! ((int )ce->flags & 1)) {
#line 1529
                    tmp___51 = ce->__annonCompField2.rr.rrmu[1];
                  } else {
#line 1529
                    tmp___51 = (rr_set_t *)((void *)0);
                  }
#line 1529
                  if (tmp___51) {
#line 1530
                    if ((int )cent->c_ns == 255) {
#line 1531
                      cent->c_ns = (unsigned char )ml;
                    } else
#line 1530
                    if ((unsigned int )cent->c_ns < ml) {
#line 1531
                      cent->c_ns = (unsigned char )ml;
                    }
                  }
#line 1533
                  if (! ((int )ce->flags & 1)) {
#line 1533
                    tmp___52 = ce->__annonCompField2.rr.rrmu[3];
                  } else {
#line 1533
                    tmp___52 = (rr_set_t *)((void *)0);
                  }
#line 1533
                  if (tmp___52) {
#line 1534
                    if ((int )cent->c_soa == 255) {
#line 1535
                      cent->c_soa = (unsigned char )ml;
                    } else
#line 1534
                    if ((unsigned int )cent->c_soa < ml) {
#line 1535
                      cent->c_soa = (unsigned char )ml;
                    }
                  }
                }
              }
#line 1521
              j ++;
            }
            while_break___4: /* CIL Label */ ;
            }
          }
        }
      }
#line 1506
      i ++;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 1544
    if ((unsigned long )st->rejectlist != (unsigned long )((void *)0)) {
#line 1546
      na4 = (st->rejectlist)->na4;
#line 1547
      a4arr = (addr4maskpair_t *)((st->rejectlist)->rdata + (st->rejectlist)->na6);
#line 1549
      na6 = (st->rejectlist)->na6;
#line 1550
      a6arr = (st->rejectlist)->rdata;
#line 1553
      i___0 = 0;
      {
#line 1553
      while (1) {
        while_continue___5: /* CIL Label */ ;
#line 1553
        if (! (i___0 < 3)) {
#line 1553
          goto while_break___5;
        }
        {
#line 1554
        sec = secs[i___0];
#line 1555
        tmp___54 = da_nel((darray )sec);
#line 1555
        nce = (int )tmp___54;
#line 1556
        j___0 = 0;
        }
        {
#line 1556
        while (1) {
          while_continue___6: /* CIL Label */ ;
#line 1556
          if (! (j___0 < nce)) {
#line 1556
            goto while_break___6;
          }
#line 1557
          cent___0 = & sec->elem[j___0];
#line 1558
          if (! ((int )cent___0->flags & 1)) {
#line 1558
            tmp___55 = cent___0->__annonCompField2.rr.rrmu[0];
          } else {
#line 1558
            tmp___55 = (rr_set_t *)((void *)0);
          }
#line 1558
          rrset = tmp___55;
#line 1559
          if (rrset) {
#line 1559
            if (na4) {
#line 1564
              rr = rrset->rrs;
              {
#line 1564
              while (1) {
                while_continue___7: /* CIL Label */ ;
#line 1564
                if (! rr) {
#line 1564
                  goto while_break___7;
                }
#line 1565
                a = (struct in_addr *)(rr->data);
#line 1567
                k = 0;
                {
#line 1567
                while (1) {
                  while_continue___8: /* CIL Label */ ;
#line 1567
                  if (! (k < na4)) {
#line 1567
                    goto while_break___8;
                  }
#line 1568
                  am = a4arr + k;
#line 1569
                  if (((a->s_addr ^ am->a.s_addr) & am->mask.s_addr) == 0U) {
#line 1572
                    if (debug_p) {
                      {
#line 1572
                      tmp___56 = inet_ntop(2, (void const   */* __restrict  */)a,
                                           (char */* __restrict  */)(abuf), (socklen_t )sizeof(abuf));
#line 1572
                      tmp___57 = rhn2str((unsigned char const   *)cent___0->qname,
                                         nmbuf, (unsigned int )sizeof(nmbuf));
#line 1572
                      tmp___58 = pdnsd_a2str((pdnsd_a *)(& st->a.sin4.sin_addr), _debugsockabuf___13,
                                             16);
#line 1572
                      debug_msg(0, "Rejecting answer from server %s because it contains an A record for \"%s\" with an address in the reject list: %s\n",
                                tmp___58, tmp___57, tmp___56);
                      }
                    }
#line 1578
                    reject_ans = (unsigned short)1;
#line 1578
                    goto rejectlist_scan_done;
                  }
#line 1567
                  k ++;
                }
                while_break___8: /* CIL Label */ ;
                }
#line 1564
                rr = rr->next;
              }
              while_break___7: /* CIL Label */ ;
              }
            }
          }
#line 1584
          if (! ((int )cent___0->flags & 1)) {
#line 1584
            rrset = cent___0->__annonCompField2.rr.rrmu[7];
          } else {
#line 1584
            rrset = (rr_set_t *)((void *)0);
          }
#line 1585
          if (rrset) {
#line 1585
            if (na6) {
#line 1587
              rr___0 = rrset->rrs;
              {
#line 1587
              while (1) {
                while_continue___9: /* CIL Label */ ;
#line 1587
                if (! rr___0) {
#line 1587
                  goto while_break___9;
                }
#line 1588
                a___0 = rr___0->data;
#line 1590
                k___0 = 0;
                {
#line 1590
                while (1) {
                  while_continue___10: /* CIL Label */ ;
#line 1590
                  if (! (k___0 < na6)) {
#line 1590
                    goto while_break___10;
                  }
#line 1591
                  am___0 = a6arr + k___0;
#line 1592
                  if (((*((uint32_t *)a___0 + 0) ^ *((uint32_t *)(& am___0->a) + 0)) & *((uint32_t *)(& am___0->mask) + 0)) == 0U) {
#line 1592
                    if (((*((uint32_t *)a___0 + 1) ^ *((uint32_t *)(& am___0->a) + 1)) & *((uint32_t *)(& am___0->mask) + 1)) == 0U) {
#line 1592
                      if (((*((uint32_t *)a___0 + 2) ^ *((uint32_t *)(& am___0->a) + 2)) & *((uint32_t *)(& am___0->mask) + 2)) == 0U) {
#line 1592
                        if (((*((uint32_t *)a___0 + 3) ^ *((uint32_t *)(& am___0->a) + 3)) & *((uint32_t *)(& am___0->mask) + 3)) == 0U) {
#line 1595
                          if (debug_p) {
                            {
#line 1595
                            tmp___59 = inet_ntop(10, (void const   */* __restrict  */)a___0,
                                                 (char */* __restrict  */)(abuf___0),
                                                 (socklen_t )sizeof(abuf___0));
#line 1595
                            tmp___60 = rhn2str((unsigned char const   *)cent___0->qname,
                                               nmbuf___0, (unsigned int )sizeof(nmbuf___0));
#line 1595
                            tmp___61 = pdnsd_a2str((pdnsd_a *)(& st->a.sin4.sin_addr),
                                                   _debugsockabuf___14, 16);
#line 1595
                            debug_msg(0, "Rejecting answer from server %s because it contains an AAAA record for \"%s\" with an address in the reject list: %s\n",
                                      tmp___61, tmp___60, tmp___59);
                            }
                          }
#line 1601
                          reject_ans = (unsigned short)1;
#line 1601
                          goto rejectlist_scan_done;
                        }
                      }
                    }
                  }
#line 1590
                  k___0 ++;
                }
                while_break___10: /* CIL Label */ ;
                }
#line 1587
                rr___0 = rr___0->next;
              }
              while_break___9: /* CIL Label */ ;
              }
            }
          }
#line 1556
          j___0 ++;
        }
        while_break___6: /* CIL Label */ ;
        }
#line 1553
        i___0 ++;
      }
      while_break___5: /* CIL Label */ ;
      }
      rejectlist_scan_done: ;
    }
#line 1613
    if (rcode == 3) {
#line 1614
      if (debug_p) {
        {
#line 1614
        tmp___62 = get_ename(rcode);
#line 1614
        tmp___63 = pdnsd_a2str((pdnsd_a *)(& st->a.sin4.sin_addr), _debugsockabuf___15,
                               16);
#line 1614
        debug_msg(0, "Server %s returned error code: %s\n", tmp___63, tmp___62);
        }
      }
      name_error: 
#line 1616
      neg_ans = (unsigned short)1;
#line 1619
      ent = & (secs[0])->elem[0];
#line 1620
      neg_domain_pol = (int )global.neg_domain_pol;
#line 1621
      if (neg_domain_pol == 1) {
#line 1621
        goto _L___8;
      } else
#line 1621
      if (neg_domain_pol == 22) {
#line 1621
        if ((st->recvbuf)->aa) {
          _L___8: /* CIL Label */ 
#line 1622
          ttl = global.neg_ttl;
#line 1626
          if ((int )ent->c_soa != 255) {
            {
#line 1627
            tmp___64 = rhnsegcnt(name);
#line 1627
            scnt___0 = tmp___64;
            }
#line 1629
            if ((unsigned int )ent->c_soa < scnt___0) {
              {
#line 1629
              tmp___67 = skipsegs(name, scnt___0 - (unsigned int )ent->c_soa);
#line 1629
              cent___1 = lookup_cent_array(secs[1], tmp___67);
              }
#line 1629
              if (cent___1) {
#line 1630
                if (! ((int )cent___1->flags & 1)) {
#line 1630
                  tmp___65 = cent___1->__annonCompField2.rr.rrmu[3];
                } else {
#line 1630
                  tmp___65 = (rr_set_t *)((void *)0);
                }
#line 1630
                rrset___0 = tmp___65;
#line 1631
                if (rrset___0) {
#line 1631
                  if (rrset___0->rrs) {
                    {
#line 1632
                    tmp___66 = soa_minimum(rrset___0->rrs);
#line 1632
                    min = tmp___66;
#line 1633
                    ttl = rrset___0->ttl;
                    }
#line 1634
                    if (ttl > min) {
#line 1635
                      ttl = min;
                    }
                  }
                }
              }
            }
          }
#line 1639
          if (debug_p) {
            {
#line 1639
            tmp___68 = rhn2str(name, _debugstrbuf, (unsigned int )sizeof(_debugstrbuf));
#line 1639
            debug_msg(0, "Caching domain %s negative with ttl %li\n", tmp___68, ttl);
            }
          }
          {
#line 1640
          negate_cent(ent, ttl, queryts);
          }
#line 1641
          if (st->nocache) {
#line 1641
            ent->flags = (unsigned short )((int )ent->flags | 8);
          }
#line 1642
          goto cleanup_return_OK;
        } else {
#line 1621
          goto _L___9;
        }
      } else {
        _L___9: /* CIL Label */ 
#line 1644
        if (c_soa) {
#line 1644
          *c_soa = ent->c_soa;
        }
        {
#line 1645
        free_cent(ent);
#line 1646
        rv = 3;
        }
#line 1647
        goto add_additional;
      }
    }
#line 1652
    if (reject_ans) {
#line 1653
      if ((int )(st->rejectlist)->policy == 25) {
#line 1653
        if ((int )st->failed <= 1) {
#line 1654
          goto name_error;
        } else {
#line 1656
          rv = 2;
#line 1657
          goto free_ent_centarrays_recvbuf_return;
        }
      } else {
#line 1656
        rv = 2;
#line 1657
        goto free_ent_centarrays_recvbuf_return;
      }
    }
#line 1661
    if (global.deleg_only_zones) {
#line 1661
      if ((int )st->auth_serv < 3) {
        {
#line 1665
        lock_server_data();
#line 1666
        missingdelegation = 0;
#line 1666
        authcnt = 0;
#line 1668
        tmp___69 = da_nel((darray )global.deleg_only_zones);
#line 1668
        n___0 = (int )tmp___69;
#line 1669
        i___1 = 0;
        }
        {
#line 1669
        while (1) {
          while_continue___11: /* CIL Label */ ;
#line 1669
          if (! (i___1 < n___0)) {
#line 1669
            goto while_break___11;
          }
          {
#line 1670
          tmp___70 = domain_match(name, (unsigned char const   *)(global.deleg_only_zones)->elem[i___1],
                                  & rem___0, & zrem);
          }
#line 1670
          if (tmp___70) {
#line 1670
            if (zrem == 0U) {
#line 1671
              goto zone_match;
            }
          }
#line 1669
          i___1 ++;
        }
        while_break___11: /* CIL Label */ ;
        }
#line 1673
        goto delegation_OK;
        zone_match: 
#line 1676
        if (rem___0) {
#line 1680
          j___1 = 0;
          {
#line 1680
          while (1) {
            while_continue___12: /* CIL Label */ ;
#line 1680
            if (! (j___1 < 2)) {
#line 1680
              goto while_break___12;
            }
            {
#line 1681
            sec___0 = secs[j___1];
#line 1682
            tmp___71 = da_nel((darray )sec___0);
#line 1682
            m___0 = (int )tmp___71;
#line 1683
            k___1 = 0;
            }
            {
#line 1683
            while (1) {
              while_continue___13: /* CIL Label */ ;
#line 1683
              if (! (k___1 < m___0)) {
#line 1683
                goto while_break___13;
              }
#line 1684
              ce___0 = & sec___0->elem[k___1];
#line 1685
              if (! ((int )ce___0->flags & 1)) {
#line 1685
                tmp___73 = ce___0->__annonCompField2.rr.rrmu[1];
              } else {
#line 1685
                tmp___73 = (rr_set_t *)((void *)0);
              }
#line 1685
              if (tmp___73) {
#line 1685
                goto _L___10;
              } else {
#line 1685
                if (! ((int )ce___0->flags & 1)) {
#line 1685
                  tmp___74 = ce___0->__annonCompField2.rr.rrmu[3];
                } else {
#line 1685
                  tmp___74 = (rr_set_t *)((void *)0);
                }
#line 1685
                if (tmp___74) {
                  _L___10: /* CIL Label */ 
#line 1688
                  authcnt ++;
#line 1689
                  l = 0;
                  {
#line 1689
                  while (1) {
                    while_continue___14: /* CIL Label */ ;
#line 1689
                    if (! (l < n___0)) {
#line 1689
                      goto while_break___14;
                    }
                    {
#line 1690
                    tmp___72 = domain_match((unsigned char const   *)ce___0->qname,
                                            (unsigned char const   *)(global.deleg_only_zones)->elem[l],
                                            & rem___0, & zrem);
                    }
#line 1690
                    if (tmp___72) {
#line 1690
                      if (zrem == 0U) {
#line 1691
                        if (rem___0) {
#line 1691
                          goto while_break___14;
                        } else {
#line 1692
                          goto try_next_auth;
                        }
                      }
                    }
#line 1689
                    l ++;
                  }
                  while_break___14: /* CIL Label */ ;
                  }
#line 1695
                  goto delegation_OK;
                }
              }
              try_next_auth: 
#line 1683
              k___1 ++;
            }
            while_break___13: /* CIL Label */ ;
            }
#line 1680
            j___1 ++;
          }
          while_break___12: /* CIL Label */ ;
          }
#line 1703
          if (debug_p) {
            {
#line 1703
            tmp___75 = pdnsd_a2str((pdnsd_a *)(& st->a.sin4.sin_addr), _debugsockabuf___16,
                                   16);
#line 1703
            tmp___76 = rhn2str((unsigned char const   *)(global.deleg_only_zones)->elem[i___1],
                               zbuf, (unsigned int )sizeof(zbuf));
#line 1703
            tmp___77 = rhn2str(name, nmbuf___1, (unsigned int )sizeof(nmbuf___1));
            }
#line 1703
            if (authcnt) {
#line 1703
              tmp___78 = "%s is in %s zone, but no delegation found in answer returned by server %s\n";
            } else {
#line 1703
              tmp___78 = "%s is in %s zone, but no authority information provided by server %s\n";
            }
            {
#line 1703
            debug_msg(0, tmp___78, tmp___77, tmp___76, tmp___75);
            }
          }
#line 1709
          missingdelegation = 1;
        }
        delegation_OK: 
        {
#line 1713
        unlock_server_data();
        }
#line 1715
        if (missingdelegation) {
#line 1716
          if (authcnt) {
#line 1716
            if ((int )st->failed <= 1) {
#line 1718
              goto name_error;
            } else {
#line 1716
              goto _L___11;
            }
          } else
          _L___11: /* CIL Label */ 
#line 1720
          if ((int )st->auth_serv < 2) {
#line 1726
            rv = 2;
#line 1727
            goto free_ent_centarrays_recvbuf_return;
          }
        }
      }
    }
#line 1734
    ent___0 = & (secs[0])->elem[0];
#line 1736
    if (! ent___0->num_rrs) {
#line 1736
      neg_ans = (unsigned short)1;
    }
#line 1738
    if (thint >= 1) {
#line 1738
      if (thint <= 51) {
        {
#line 1738
        tmp___86 = getrrset(ent___0, thint);
        }
#line 1738
        if (! tmp___86) {
#line 1738
          if (! st->tc) {
#line 1738
            if ((int )st->failed <= 1) {
#line 1740
              neg_rrs_pol = (int )global.neg_rrs_pol;
#line 1741
              if (neg_rrs_pol == 1) {
#line 1741
                goto _L___15;
              } else
#line 1741
              if (neg_rrs_pol == 22) {
#line 1741
                if (aa) {
#line 1741
                  goto _L___15;
                } else {
#line 1741
                  goto _L___16;
                }
              } else
              _L___16: /* CIL Label */ 
#line 1741
              if (neg_rrs_pol == 3) {
#line 1741
                if (aa) {
#line 1741
                  goto _L___15;
                } else
#line 1741
                if (rd) {
#line 1741
                  if ((st->recvbuf)->ra) {
                    _L___15: /* CIL Label */ 
#line 1744
                    ttl___0 = global.neg_ttl;
#line 1745
                    if (! ((int )ent___0->flags & 1)) {
#line 1745
                      tmp___79 = ent___0->__annonCompField2.rr.rrmu[3];
                    } else {
#line 1745
                      tmp___79 = (rr_set_t *)((void *)0);
                    }
#line 1745
                    rrset___1 = tmp___79;
#line 1749
                    if (rrset___1) {
#line 1749
                      if (rrset___1->rrs) {
#line 1749
                        goto _L___12;
                      } else {
#line 1749
                        goto _L___13;
                      }
                    } else {
                      _L___13: /* CIL Label */ 
#line 1749
                      if ((int )ent___0->c_soa != 255) {
                        {
#line 1749
                        scnt___1 = rhnsegcnt(name);
                        }
#line 1749
                        if ((unsigned int )ent___0->c_soa < scnt___1) {
                          {
#line 1749
                          tmp___81 = skipsegs(name, scnt___1 - (unsigned int )ent___0->c_soa);
#line 1749
                          tmp___82 = tmp___81;
                          }
                        } else {
#line 1749
                          tmp___82 = name;
                        }
                      } else {
#line 1749
                        tmp___82 = name;
                      }
                      {
#line 1749
                      cent___2 = lookup_cent_array(secs[1], tmp___82);
                      }
#line 1749
                      if (cent___2) {
#line 1749
                        if (! ((int )cent___2->flags & 1)) {
#line 1749
                          rrset___1 = cent___2->__annonCompField2.rr.rrmu[3];
                        } else {
#line 1749
                          rrset___1 = (rr_set_t *)((void *)0);
                        }
#line 1749
                        if (rrset___1) {
#line 1749
                          if (rrset___1->rrs) {
                            _L___12: /* CIL Label */ 
                            {
#line 1757
                            tmp___80 = soa_minimum(rrset___1->rrs);
#line 1757
                            min___0 = tmp___80;
#line 1758
                            ttl___0 = rrset___1->ttl;
                            }
#line 1759
                            if (ttl___0 > min___0) {
#line 1760
                              ttl___0 = min___0;
                            }
                          }
                        }
                      }
                    }
#line 1762
                    if (debug_p) {
                      {
#line 1762
                      tmp___83 = rhn2str(name, _debugstrbuf___0, (unsigned int )sizeof(_debugstrbuf___0));
#line 1762
                      tmp___84 = getrrtpname(thint);
#line 1762
                      debug_msg(0, "Caching type %s for domain %s negative with ttl %li\n",
                                tmp___84, tmp___83, ttl___0);
                      }
                    }
                    {
#line 1763
                    tmp___85 = add_cent_rrset_by_type(ent___0, thint, ttl___0, queryts,
                                                      (unsigned int )(1 | (int )flags));
                    }
#line 1763
                    if (! tmp___85) {
#line 1764
                      rv = 65535;
#line 1765
                      goto free_ent_centarrays_recvbuf_return;
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
#line 1771
    if ((int )st->failed <= 1) {
#line 1776
      i___2 = 0;
      {
#line 1776
      while (1) {
        while_continue___15: /* CIL Label */ ;
#line 1776
        if (! (i___2 < 2)) {
#line 1776
          goto while_break___15;
        }
        {
#line 1777
        sec___1 = secs[i___2];
#line 1778
        tmp___87 = da_nel((darray )sec___1);
#line 1778
        n___1 = (int )tmp___87;
#line 1779
        j___2 = 0;
        }
        {
#line 1779
        while (1) {
          while_continue___16: /* CIL Label */ ;
#line 1779
          if (! (j___2 < n___1)) {
#line 1779
            goto while_break___16;
          }
#line 1780
          cent___3 = & sec___1->elem[j___2];
#line 1784
          if (*(cent___3->qname)) {
#line 1784
            goto _L___18;
          } else
#line 1784
          if ((int )st->auth_serv != 2) {
            _L___18: /* CIL Label */ 
#line 1784
            if (st->trusted) {
#line 1784
              goto _L___17;
            } else
#line 1784
            if (! st->nsdomain) {
#line 1784
              goto _L___17;
            } else {
              {
#line 1784
              domain_match(st->nsdomain, (unsigned char const   *)cent___3->qname,
                           & rem___1, (unsigned int *)((void *)0));
              }
#line 1784
              if (rem___1 == 0U) {
                _L___17: /* CIL Label */ 
#line 1784
                if ((int )*(cent___3->qname) != 255) {
#line 1794
                  k___2 = 0;
                  {
#line 1794
                  while (1) {
                    while_continue___17: /* CIL Label */ ;
#line 1794
                    if (! (k___2 < 2)) {
#line 1794
                      goto while_break___17;
                    }
                    {
#line 1795
                    tmp___88 = getrrset(cent___3, (int )nstypes[k___2]);
#line 1795
                    rrset___2 = tmp___88;
                    }
#line 1796
                    if (rrset___2) {
#line 1798
                      first = (unsigned short)1;
#line 1799
                      rr___1 = rrset___2->rrs;
                      {
#line 1799
                      while (1) {
                        while_continue___18: /* CIL Label */ ;
#line 1799
                        if (! rr___1) {
#line 1799
                          goto while_break___18;
                        }
                        {
#line 1803
                        tmp___89 = dlist_first(*ns);
#line 1803
                        p___0 = (unsigned char *)tmp___89;
                        }
                        {
#line 1803
                        while (1) {
                          while_continue___19: /* CIL Label */ ;
#line 1803
                          if (! p___0) {
#line 1803
                            goto while_break___19;
                          }
#line 1804
                          if ((int )*p___0 == 255) {
#line 1804
                            tmp___92 = p___0 + 1;
                          } else {
                            {
#line 1804
                            tmp___91 = skiprhn(p___0);
#line 1804
                            tmp___92 = tmp___91;
                            }
                          }
                          {
#line 1804
                          tmp___93 = rhnicmp((unsigned char const   *)tmp___92, (unsigned char const   *)((unsigned char *)(rr___1->data)));
                          }
#line 1804
                          if (tmp___93) {
#line 1805
                            goto next_nsr;
                          }
                          {
#line 1803
                          tmp___90 = dlist_next((void *)p___0);
#line 1803
                          p___0 = (unsigned char *)tmp___90;
                          }
                        }
                        while_break___19: /* CIL Label */ ;
                        }
#line 1812
                        if (first) {
                          {
#line 1812
                          tmp___94 = rhnlen((unsigned char const   *)cent___3->qname);
#line 1812
                          sz1 = (size_t )tmp___94;
                          }
                        } else {
#line 1812
                          sz1 = (size_t )1;
                        }
                        {
#line 1813
                        tmp___95 = rhnlen((unsigned char const   *)((unsigned char *)(rr___1->data)));
#line 1813
                        sz2 = (size_t )tmp___95;
#line 1814
                        tmp___96 = dlist_grow(*ns, sz1 + sz2);
#line 1814
                        *ns = tmp___96;
                        }
#line 1814
                        if (! tmp___96) {
#line 1815
                          rv = 65535;
#line 1816
                          goto free_ent_centarrays_recvbuf_return;
                        }
                        {
#line 1818
                        tmp___97 = dlist_last(*ns);
#line 1818
                        p___0 = (unsigned char *)tmp___97;
                        }
#line 1819
                        if (first) {
                          {
#line 1820
                          first = (unsigned short)0;
#line 1821
                          tmp___98 = mempcpy((void */* __restrict  */)p___0, (void const   */* __restrict  */)cent___3->qname,
                                             sz1);
#line 1821
                          p___0 = (unsigned char *)tmp___98;
                          }
                        } else {
#line 1824
                          tmp___99 = p___0;
#line 1824
                          p___0 ++;
#line 1824
                          *tmp___99 = (unsigned char)255;
                        }
                        {
#line 1826
                        memcpy((void */* __restrict  */)p___0, (void const   */* __restrict  */)((unsigned char *)(rr___1->data)),
                               sz2);
#line 1827
                        num_ns = (unsigned short )((int )num_ns + 1);
                        }
                        next_nsr: 
#line 1799
                        rr___1 = rr___1->next;
                      }
                      while_break___18: /* CIL Label */ ;
                      }
                    }
#line 1794
                    k___2 ++;
                  }
                  while_break___17: /* CIL Label */ ;
                  }
                }
              }
            }
          }
#line 1779
          j___2 ++;
        }
        while_break___16: /* CIL Label */ ;
        }
#line 1776
        i___2 ++;
      }
      while_break___15: /* CIL Label */ ;
      }
    }
    cleanup_return_OK: 
#line 1837
    if (st->failed) {
#line 1837
      if (neg_ans) {
#line 1837
        if ((int )num_ns == 0) {
#line 1838
          if (debug_p) {
            {
#line 1838
            tmp___100 = pdnsd_a2str((pdnsd_a *)(& st->a.sin4.sin_addr), _debugsockabuf___17,
                                    16);
#line 1838
            debug_msg(0, "Answer from server %s does not contain usable records.\n",
                      tmp___100);
            }
          }
#line 1840
          rv = 2;
#line 1841
          goto free_ns_ent_centarrays_recvbuf_return;
        }
      }
    }
    {
#line 1843
    tmp___102 = malloc(sizeof(dns_cent_t ));
#line 1843
    tmp___101 = (dns_cent_t *)tmp___102;
#line 1843
    *entp = tmp___101;
    }
#line 1843
    if (! tmp___101) {
#line 1844
      rv = 65535;
#line 1845
      goto free_ns_ent_centarrays_recvbuf_return;
    }
#line 1847
    *(*entp) = (secs[0])->elem[0];
#line 1848
    rv = 0;
    add_additional: 
#line 1850
    if (! st->failed) {
#line 1850
      if (! reject_ans) {
#line 1855
        if (debug_p) {
#line 1855
          if (neg_ans) {
            {
#line 1856
            tmp___103 = da_nel((darray )secs[0]);
#line 1856
            n___2 = (int )tmp___103;
#line 1857
            j___3 = 1;
            }
            {
#line 1857
            while (1) {
              while_continue___20: /* CIL Label */ ;
#line 1857
              if (! (j___3 < n___2)) {
#line 1857
                goto while_break___20;
              }
#line 1859
              if (debug_p) {
                {
#line 1859
                tmp___104 = rhn2str((unsigned char const   *)(secs[0])->elem[j___3].qname,
                                    nmbuf2, (unsigned int )sizeof(nmbuf2));
#line 1859
                tmp___105 = rhn2str(name, nmbuf___2, (unsigned int )sizeof(nmbuf___2));
#line 1859
                tmp___106 = pdnsd_a2str((pdnsd_a *)(& st->a.sin4.sin_addr), _debugsockabuf___18,
                                        16);
#line 1859
                debug_msg(0, "Reply from %s is negative for %s, dropping record(s) for %s in answer section.\n",
                          tmp___106, tmp___105, tmp___104);
                }
              }
#line 1857
              j___3 ++;
            }
            while_break___20: /* CIL Label */ ;
            }
          }
        }
#line 1866
        i___3 = (int )neg_ans;
        {
#line 1866
        while (1) {
          while_continue___21: /* CIL Label */ ;
#line 1866
          if (! (i___3 < 3)) {
#line 1866
            goto while_break___21;
          }
          {
#line 1867
          sec___2 = secs[i___3];
#line 1868
          tmp___107 = da_nel((darray )sec___2);
#line 1868
          n___3 = (int )tmp___107;
#line 1870
          j___4 = ! i___3;
          }
          {
#line 1870
          while (1) {
            while_continue___22: /* CIL Label */ ;
#line 1870
            if (! (j___4 < n___3)) {
#line 1870
              goto while_break___22;
            }
#line 1871
            cent___4 = & sec___2->elem[j___4];
#line 1872
            if (*(cent___4->qname)) {
#line 1872
              goto _L___19;
            } else
#line 1872
            if ((int )st->auth_serv != 2) {
              _L___19: /* CIL Label */ 
#line 1874
              if (st->trusted) {
                {
#line 1875
                add_cache(cent___4);
                }
              } else
#line 1874
              if (! st->nsdomain) {
                {
#line 1875
                add_cache(cent___4);
                }
              } else {
                {
#line 1874
                domain_match(st->nsdomain, (unsigned char const   *)cent___4->qname,
                             & rem___2, (unsigned int *)((void *)0));
                }
#line 1874
                if (rem___2 == 0U) {
                  {
#line 1875
                  add_cache(cent___4);
                  }
                } else
#line 1879
                if (debug_p) {
                  {
#line 1879
                  tmp___108 = rhn2str(st->nsdomain, nsbuf, (unsigned int )sizeof(nsbuf));
#line 1879
                  tmp___109 = rhn2str((unsigned char const   *)cent___4->qname, nmbuf___3,
                                      (unsigned int )sizeof(nmbuf___3));
#line 1879
                  debug_msg(0, "Record for %s not in nsdomain %s; dropped.\n", tmp___109,
                            tmp___108);
                  }
                }
              }
            } else
#line 1887
            if (debug_p) {
              {
#line 1887
              tmp___110 = pdnsd_a2str((pdnsd_a *)(& st->a.sin4.sin_addr), _debugsockabuf___19,
                                      16);
#line 1887
              debug_msg(0, "Record(s) for root domain in %s section from %s dropped.\n",
                        secname[i___3], tmp___110);
              }
            }
#line 1870
            j___4 ++;
          }
          while_break___22: /* CIL Label */ ;
          }
#line 1866
          i___3 ++;
        }
        while_break___21: /* CIL Label */ ;
        }
      }
    }
#line 1893
    goto free_centarrays_recvbuf_return;
    free_ns_ent_centarrays_recvbuf_return: 
    {
#line 1896
    free((void *)*ns);
#line 1896
    *ns = (dlist )((void *)0);
    }
    free_ent_centarrays_recvbuf_return: 
    {
#line 1898
    tmp___111 = da_nel((darray )secs[0]);
    }
#line 1898
    if (tmp___111 >= 1U) {
      {
#line 1898
      free_cent(& (secs[0])->elem[0]);
      }
    }
    free_centarrays_recvbuf_return: 
#line 1903
    i___4 = 0;
    {
#line 1903
    while (1) {
      while_continue___23: /* CIL Label */ ;
#line 1903
      if (! (i___4 < 3)) {
#line 1903
        goto while_break___23;
      }
      {
#line 1904
      sec___3 = secs[i___4];
#line 1905
      tmp___112 = da_nel((darray )sec___3);
#line 1905
      n___4 = (int )tmp___112;
#line 1907
      j___5 = ! i___4;
      }
      {
#line 1907
      while (1) {
        while_continue___24: /* CIL Label */ ;
#line 1907
        if (! (j___5 < n___4)) {
#line 1907
          goto while_break___24;
        }
        {
#line 1908
        free_cent(& sec___3->elem[j___5]);
#line 1907
        j___5 ++;
        }
      }
      while_break___24: /* CIL Label */ ;
      }
      {
#line 1910
      free((void *)sec___3);
#line 1903
      i___4 ++;
      }
    }
    while_break___23: /* CIL Label */ ;
    }
  }
  free_recvbuf_return: 
  {
#line 1918
  free((void *)st->recvbuf);
  }
#line 1919
  return (rv);
}
}
#line 1926 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/dns_query.c"
static void p_cancel_query(query_stat_t *st ) 
{ 


  {
  {
#line 1930
  if ((int )st->state == 5) {
#line 1930
    goto case_5;
  }
#line 1930
  if ((int )st->state == 3) {
#line 1930
    goto case_5;
  }
#line 1930
  if ((int )st->state == 2) {
#line 1930
    goto case_5;
  }
#line 1934
  if ((int )st->state == 4) {
#line 1934
    goto case_4;
  }
#line 1934
  if ((int )st->state == 1) {
#line 1934
    goto case_4;
  }
#line 1928
  goto switch_break;
  case_5: /* CIL Label */ 
  case_3: /* CIL Label */ 
  case_2: /* CIL Label */ 
  {
#line 1931
  close(st->sock);
  }
  case_4: /* CIL Label */ 
  case_1: /* CIL Label */ 
  {
#line 1935
  free((void *)st->recvbuf);
#line 1936
  free((void *)st->msg);
  }
  switch_break: /* CIL Label */ ;
  }
#line 1938
  if ((int )st->state != 0) {
#line 1938
    if ((int )st->state != 8) {
#line 1939
      st->state = (short)7;
    }
  }
#line 1940
  return;
}
}
#line 1958 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/dns_query.c"
static int add_qserv(query_stat_array *q , pdnsd_a2 *a , int port , time_t timeout ,
                     unsigned int flags , int nocache , char lean_query , char edns_query ,
                     char auth_s , char needs_testing___0 , char trusted , unsigned char const   *nsdomain ,
                     rejectlist_t *rejectlist ) 
{ 
  query_stat_t *qs ;
  query_stat_array tmp ;
  darray tmp___0 ;

  {
  {
#line 1964
  tmp___0 = da_grow1((darray )*q, (size_t )(((query_stat_array )0)->elem), sizeof((*q)->elem[0]),
                     (void (*)(void * ))((void *)0));
#line 1964
  tmp = (query_stat_array )tmp___0;
#line 1964
  *q = tmp;
  }
#line 1964
  if ((unsigned long )tmp == (unsigned long )((void *)0)) {
#line 1965
    if (debug_p) {
      {
#line 1965
      debug_msg(0, "Out of memory in add_qserv()\n");
      }
    }
#line 1966
    return (0);
  }
  {
#line 1969
  qs = & (*q)->elem[(*q)->nel - 1UL];
#line 1972
  memset((void *)(& qs->a.sin4), 0, sizeof(qs->a.sin4));
#line 1973
  qs->a.sin4.sin_family = (sa_family_t )2;
#line 1974
  qs->a.sin4.sin_port = htons((uint16_t )port);
#line 1975
  qs->a.sin4.sin_addr = a->ipv4;
#line 1991
  qs->timeout = timeout;
#line 1992
  qs->flags = (unsigned short )flags;
#line 1993
  qs->nocache = (short )nocache;
#line 1994
  qs->auth_serv = auth_s;
#line 1995
  qs->lean_query = lean_query;
#line 1996
  qs->edns_query = edns_query;
#line 1997
  qs->needs_testing = needs_testing___0;
#line 1998
  qs->trusted = trusted;
#line 1999
  qs->aa = (char)0;
#line 2000
  qs->tc = (char)0;
#line 2001
  qs->failed = (char)0;
#line 2002
  qs->nsdomain = nsdomain;
#line 2003
  qs->rejectlist = rejectlist;
#line 2005
  qs->state = (short)0;
#line 2006
  qs->qm = (short )global.query_method;
#line 2007
  qs->s_errno = 0;
  }
#line 2008
  return (1);
}
}
#line 2013 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/dns_query.c"
__inline static int query_stat_same_inaddr2(query_stat_t *qs , pdnsd_a2 *b ) 
{ 


  {
#line 2015
  return (qs->a.sin4.sin_addr.s_addr == b->ipv4.s_addr);
}
}
#line 2025 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/dns_query.c"
__inline static void del_qserv(query_stat_array q ) 
{ 


  {
  {
#line 2027
  free((void *)q);
  }
#line 2028
  return;
}
}
#line 2043
static int auth_ok(query_stat_array q , unsigned char const   *name , int thint ,
                   dns_cent_t *ent , int hops , qstatnode_t *qslist , qhintnode_t *qhlist ,
                   query_stat_t *qse , dlist ns , query_stat_array *serv ) ;
#line 2046
static int p_dns_cached_resolve(query_stat_array q , unsigned char const   *name ,
                                int thint , dns_cent_t **cachedp , int hops , qstatnode_t *qslist ,
                                qhintnode_t *qhlist , time_t queryts , unsigned char *c_soa ) ;
#line 2049
static int simple_dns_cached_resolve(atup_array atup_a , int port , char edns_query ,
                                     time_t timeout , unsigned char const   *name ,
                                     int thint , dns_cent_t **cachedp ) ;
#line 2070 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/dns_query.c"
static int p_recursive_query(query_stat_array q , unsigned char const   *name , int thint ,
                             dns_cent_t **entp , int *nocache , int hops , qstatnode_t *qslist ,
                             qhintnode_t *qhlist , unsigned char *c_soa ) 
{ 
  dns_cent_t *ent ;
  dns_cent_t *entsave ;
  int i ;
  int j ;
  int k ;
  int rv ;
  int qualval ;
  query_stat_t *qse ;
  dlist ns ;
  dlist nssave ;
  query_stat_array serv ;
  query_stat_array servsave ;
  time_t ts0 ;
  time_t tmp ;
  time_t global_timeout ;
  int dc ;
  int mc ;
  int nq ;
  unsigned int tmp___0 ;
  int parqueries ;
  query_stat_t *qs ;
  char _debugsockabuf[16] ;
  char const   *tmp___1 ;
  int authok ;
  char _debugsockabuf___0[16] ;
  char const   *tmp___2 ;
  int qval ;
  unsigned int tmp___3 ;
  char _debugsockabuf___1[16] ;
  char const   *tmp___4 ;
  time_t ts ;
  time_t maxto ;
  time_t now ;
  int pc ;
  int nevents ;
  int ic ;
  struct pollfd *polls ;
  unsigned long __lengthofpolls ;
  void *tmp___5 ;
  query_stat_t *qs___0 ;
  query_stat_t *qs___1 ;
  time_t globto ;
  time_t tmp___6 ;
  int *tmp___7 ;
  char *tmp___8 ;
  query_stat_t *qs___2 ;
  char _debugsockabuf___2[16] ;
  char const   *tmp___9 ;
  int authok___0 ;
  char _debugsockabuf___3[16] ;
  char const   *tmp___10 ;
  int qval___0 ;
  unsigned int tmp___11 ;
  time_t tmp___12 ;
  query_stat_t *qs___3 ;
  int srv_event ;
  int tmp___13 ;
  int authok___1 ;
  char _debugsockabuf___4[16] ;
  char const   *tmp___14 ;
  int qval___1 ;
  unsigned int tmp___15 ;
  char _debugsockabuf___5[16] ;
  char const   *tmp___16 ;
  int n ;
  pdnsd_a *addrs ;
  unsigned long __lengthofaddrs ;
  void *tmp___17 ;
  query_stat_t *qs___4 ;
  int tmp___18 ;
  char _debugsockabuf___6[16] ;
  char const   *tmp___19 ;
  char const   *tmp___20 ;
  char const   *tmp___21 ;
  char const   *tmp___22 ;
  char const   *tmp___23 ;
  int jlim ;
  int tmp___24 ;
  int tmp___25 ;
  rr_set_t *rrs ;
  rr_set_t *tmp___26 ;
  char const   *tmp___27 ;
  qstatnode_t qsn ;
  unsigned char save_ns ;
  unsigned char save_soa ;
  time_t tmp___28 ;
  unsigned int tmp___29 ;

  {
  {
#line 2074
  entsave = (dns_cent_t *)((void *)0);
#line 2076
  rv = 2;
#line 2077
  qualval = 0;
#line 2078
  qse = (query_stat_t *)((void *)0);
#line 2079
  ns = (dlist )((void *)0);
#line 2079
  nssave = (dlist )((void *)0);
#line 2080
  serv = (query_stat_array )((void *)0);
#line 2080
  servsave = (query_stat_array )((void *)0);
#line 2119
  tmp = time((time_t *)((void *)0));
#line 2119
  ts0 = tmp;
#line 2119
  global_timeout = global.timeout;
#line 2120
  dc = 0;
#line 2120
  mc = 0;
#line 2120
  tmp___0 = da_nel((darray )q);
#line 2120
  nq = (int )tmp___0;
#line 2120
  parqueries = global.par_queries;
#line 2122
  j = 0;
  }
  {
#line 2122
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2122
    if (! (j < nq)) {
#line 2122
      goto while_break;
    }
#line 2123
    mc = j + parqueries;
#line 2124
    if (mc > nq) {
#line 2124
      mc = nq;
    }
#line 2129
    i = dc;
    {
#line 2129
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 2129
      if (! (i < mc)) {
#line 2129
        goto while_break___0;
      }
#line 2130
      qs = & q->elem[i];
#line 2131
      if (i >= j) {
#line 2134
        if (debug_p) {
          {
#line 2134
          tmp___1 = pdnsd_a2str((pdnsd_a *)(& qs->a.sin4.sin_addr), _debugsockabuf,
                                16);
#line 2134
          debug_msg(0, "Sending query to %s\n", tmp___1);
          }
        }
        retryquery: 
        {
#line 2136
        rv = p_exec_query(& ent, name, thint, qs, & ns, c_soa);
        }
#line 2137
        if (rv == 0) {
#line 2139
          if (debug_p) {
            {
#line 2139
            tmp___2 = pdnsd_a2str((pdnsd_a *)(& qs->a.sin4.sin_addr), _debugsockabuf___0,
                                  16);
#line 2139
            debug_msg(0, "Query to %s succeeded.\n", tmp___2);
            }
          }
          {
#line 2140
          authok = auth_ok(q, name, thint, ent, hops, qslist, qhlist, qs, ns, & serv);
          }
#line 2140
          if (authok) {
#line 2141
            if (authok >= 0) {
#line 2142
              if (! qs->failed) {
#line 2142
                if ((int )qs->qm == 15) {
#line 2142
                  if (! qs->tc) {
#line 2148
                    qse = qs;
#line 2149
                    mc = i;
#line 2150
                    goto done;
                  }
                } else {
#line 2148
                  qse = qs;
#line 2149
                  mc = i;
#line 2150
                  goto done;
                }
              }
            } else {
#line 2154
              mc = i;
#line 2155
              goto free_ent_return_failed;
            }
          }
#line 2162
          qval = (authok * 8 + (3 - (int )qs->failed) * 2) + ! qs->tc;
#line 2162
          if (entsave) {
#line 2162
            if (qval > qualval) {
              {
#line 2162
              free_cent(entsave);
#line 2162
              free((void *)entsave);
#line 2162
              entsave = (dns_cent_t *)((void *)0);
#line 2162
              del_qserv(servsave);
#line 2162
              free((void *)nssave);
              }
            }
          }
#line 2162
          if (! entsave) {
            {
#line 2162
            entsave = ent;
#line 2162
            servsave = serv;
#line 2162
            tmp___3 = da_nel((darray )serv);
            }
#line 2162
            if (tmp___3 > 0U) {
#line 2162
              nssave = ns;
            } else {
              {
#line 2162
              nssave = (dlist )((void *)0);
#line 2162
              free((void *)ns);
              }
            }
#line 2162
            qualval = qval;
#line 2162
            qse = qs;
          } else {
            {
#line 2162
            free_cent(ent);
#line 2162
            free((void *)ent);
#line 2162
            del_qserv(serv);
#line 2162
            free((void *)ns);
            }
          }
#line 2162
          serv = (query_stat_array )((void *)0);
#line 2162
          ns = (dlist )((void *)0);
#line 2164
          if ((int )qs->qm == 15) {
#line 2164
            if (qs->tc) {
              {
#line 2165
              switch_to_tcp(qs);
              }
#line 2166
              if (debug_p) {
                {
#line 2166
                tmp___4 = pdnsd_a2str((pdnsd_a *)(& qs->a.sin4.sin_addr), _debugsockabuf___1,
                                      16);
#line 2166
                debug_msg(0, "Reply from %s was truncated. Trying again using TCP.\n",
                          tmp___4);
                }
              }
#line 2168
              goto retryquery;
            }
          }
        } else
#line 2172
        if (rv == 3) {
#line 2173
          mc = i;
#line 2174
          goto done;
        } else
#line 2172
        if (rv == 65535) {
#line 2173
          mc = i;
#line 2174
          goto done;
        }
      }
#line 2177
      if ((int )qs->state == 8) {
#line 2177
        if (i == dc) {
#line 2178
          dc ++;
        }
      }
#line 2129
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 2180
    if (dc < mc) {
      {
#line 2190
      __lengthofpolls = (unsigned long )(mc - dc);
#line 2190
      tmp___5 = __builtin_alloca(sizeof(*polls) * __lengthofpolls);
#line 2190
      polls = (struct pollfd *)tmp___5;
#line 2194
      ts = time((time_t *)((void *)0));
      }
      {
#line 2195
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 2207
        maxto = (time_t )0;
#line 2208
        pc = 0;
#line 2209
        rv = 2;
#line 2216
        i = dc;
        {
#line 2216
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 2216
          if (! (i < mc)) {
#line 2216
            goto while_break___2;
          }
#line 2217
          qs___0 = & q->elem[i];
#line 2218
          if ((int )qs___0->state != 8) {
#line 2219
            if (i >= j) {
#line 2219
              if (qs___0->timeout > maxto) {
#line 2220
                maxto = qs___0->timeout;
              }
            }
#line 2236
            (polls + pc)->fd = qs___0->sock;
            {
#line 2238
            if ((int )qs___0->state == 5) {
#line 2238
              goto case_5;
            }
#line 2238
            if ((int )qs___0->state == 3) {
#line 2238
              goto case_5;
            }
#line 2241
            if ((int )qs___0->state == 2) {
#line 2241
              goto case_2;
            }
#line 2244
            goto switch_default;
            case_5: /* CIL Label */ 
            case_3: /* CIL Label */ 
#line 2239
            (polls + pc)->events = (short)1;
#line 2240
            goto switch_break;
            case_2: /* CIL Label */ 
#line 2242
            (polls + pc)->events = (short)4;
#line 2243
            goto switch_break;
            switch_default: /* CIL Label */ 
#line 2245
            (polls + pc)->events = (short)0;
            switch_break: /* CIL Label */ ;
            }
#line 2248
            pc ++;
          }
#line 2216
          i ++;
        }
        while_break___2: /* CIL Label */ ;
        }
#line 2251
        if (pc == 0) {
#line 2254
          dc = mc;
#line 2255
          goto while_break___1;
        }
        {
#line 2257
        now = time((time_t *)((void *)0));
#line 2258
        maxto -= now - ts;
        }
#line 2259
        if (mc == nq) {
#line 2263
          i = j;
          {
#line 2263
          while (1) {
            while_continue___3: /* CIL Label */ ;
#line 2263
            if (! (i < mc)) {
#line 2263
              goto while_break___3;
            }
#line 2264
            qs___1 = & q->elem[i];
#line 2265
            if ((int )qs___1->qm == 14) {
#line 2265
              if ((int )qs___1->state == 2) {
#line 2266
                goto skip_globto;
              } else
#line 2265
              if ((int )qs___1->state == 3) {
#line 2265
                if (qs___1->iolen == 0) {
#line 2266
                  goto skip_globto;
                }
              }
            }
#line 2263
            i ++;
          }
          while_break___3: /* CIL Label */ ;
          }
#line 2270
          globto = global_timeout - (now - ts0);
#line 2271
          if (globto > maxto) {
#line 2271
            maxto = globto;
          }
          skip_globto: ;
        }
#line 2282
        if (maxto > 0L) {
#line 2282
          tmp___6 = maxto * 1000L;
        } else {
#line 2282
          tmp___6 = (time_t )0;
        }
        {
#line 2282
        nevents = poll(polls, (nfds_t )pc, (int )tmp___6);
        }
#line 2284
        if (nevents < 0) {
          {
#line 2287
          tmp___7 = __errno_location();
#line 2287
          tmp___8 = strerror(*tmp___7);
#line 2287
          log_message(4, "poll/select failed: %s", tmp___8);
          }
#line 2288
          goto done;
        }
#line 2290
        if (nevents == 0) {
#line 2294
          i = j;
          {
#line 2294
          while (1) {
            while_continue___4: /* CIL Label */ ;
#line 2294
            if (! (i < mc)) {
#line 2294
              goto while_break___4;
            }
#line 2295
            qs___2 = & q->elem[i];
#line 2296
            if ((int )qs___2->state != 8) {
#line 2296
              if (qs___2->needs_testing) {
#line 2297
                qs___2->needs_testing = (char)2;
              }
            }
#line 2299
            if ((int )qs___2->qm == 14) {
#line 2299
              if ((int )qs___2->state == 2) {
#line 2299
                goto _L;
              } else
#line 2299
              if ((int )qs___2->state == 3) {
#line 2299
                if (qs___2->iolen == 0) {
                  _L: /* CIL Label */ 
                  {
#line 2303
                  close(qs___2->sock);
#line 2304
                  switch_to_udp(qs___2);
                  }
#line 2305
                  if (debug_p) {
                    {
#line 2305
                    tmp___9 = pdnsd_a2str((pdnsd_a *)(& qs___2->a.sin4.sin_addr),
                                          _debugsockabuf___2, 16);
#line 2305
                    debug_msg(0, "TCP connection to %s timed out. Trying to use UDP.\n",
                              tmp___9);
                    }
                  }
                  {
#line 2308
                  rv = p_exec_query(& ent, name, thint, qs___2, & ns, c_soa);
                  }
#line 2310
                  if (rv == 0) {
#line 2312
                    if (debug_p) {
                      {
#line 2312
                      tmp___10 = pdnsd_a2str((pdnsd_a *)(& qs___2->a.sin4.sin_addr),
                                             _debugsockabuf___3, 16);
#line 2312
                      debug_msg(0, "Query to %s succeeded.\n", tmp___10);
                      }
                    }
                    {
#line 2313
                    authok___0 = auth_ok(q, name, thint, ent, hops, qslist, qhlist,
                                         qs___2, ns, & serv);
                    }
#line 2313
                    if (authok___0) {
#line 2314
                      if (authok___0 >= 0) {
#line 2315
                        if (! qs___2->failed) {
#line 2316
                          qse = qs___2;
#line 2317
                          goto done;
                        }
                      } else {
#line 2321
                        goto free_ent_return_failed;
                      }
                    }
#line 2323
                    qval___0 = (authok___0 * 8 + (3 - (int )qs___2->failed) * 2) + ! qs___2->tc;
#line 2323
                    if (entsave) {
#line 2323
                      if (qval___0 > qualval) {
                        {
#line 2323
                        free_cent(entsave);
#line 2323
                        free((void *)entsave);
#line 2323
                        entsave = (dns_cent_t *)((void *)0);
#line 2323
                        del_qserv(servsave);
#line 2323
                        free((void *)nssave);
                        }
                      }
                    }
#line 2323
                    if (! entsave) {
                      {
#line 2323
                      entsave = ent;
#line 2323
                      servsave = serv;
#line 2323
                      tmp___11 = da_nel((darray )serv);
                      }
#line 2323
                      if (tmp___11 > 0U) {
#line 2323
                        nssave = ns;
                      } else {
                        {
#line 2323
                        nssave = (dlist )((void *)0);
#line 2323
                        free((void *)ns);
                        }
                      }
#line 2323
                      qualval = qval___0;
#line 2323
                      qse = qs___2;
                    } else {
                      {
#line 2323
                      free_cent(ent);
#line 2323
                      free((void *)ent);
#line 2323
                      del_qserv(serv);
#line 2323
                      free((void *)ns);
                      }
                    }
#line 2323
                    serv = (query_stat_array )((void *)0);
#line 2323
                    ns = (dlist )((void *)0);
                  } else
#line 2325
                  if (rv == 3) {
#line 2326
                    goto done;
                  } else
#line 2325
                  if (rv == 65535) {
#line 2326
                    goto done;
                  }
#line 2328
                  nevents ++;
                }
              }
            }
#line 2294
            i ++;
          }
          while_break___4: /* CIL Label */ ;
          }
#line 2333
          if (mc == nq) {
#line 2337
            if (nevents) {
              {
#line 2337
              tmp___12 = time((time_t *)((void *)0));
              }
#line 2337
              if (tmp___12 - ts0 < global_timeout) {
#line 2338
                goto __Cont;
              }
            }
          }
#line 2341
          goto while_break___1;
        }
#line 2344
        ic = 0;
#line 2346
        i = dc;
        {
#line 2346
        while (1) {
          while_continue___5: /* CIL Label */ ;
#line 2346
          if (! (i < mc)) {
#line 2346
            goto while_break___5;
          }
#line 2347
          qs___3 = & q->elem[i];
#line 2349
          if ((int )qs___3->state != 8) {
#line 2350
            srv_event = 0;
            {
#line 2363
            while (1) {
              while_continue___6: /* CIL Label */ ;
#line 2364
              if (! (ic < pc)) {
                {
#line 2364
                log_message(3, "%s:%d: %s", "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/dns_query.c",
                            2364, "file descriptor not found in poll() array");
#line 2364
                pdnsd_exit();
                }
              }
#line 2365
              tmp___13 = ic;
#line 2365
              ic ++;
#line 2365
              k = tmp___13;
#line 2363
              if (! ((polls + k)->fd != qs___3->sock)) {
#line 2363
                goto while_break___6;
              }
            }
            while_break___6: /* CIL Label */ ;
            }
            {
#line 2372
            if ((int )qs___3->state == 5) {
#line 2372
              goto case_5___0;
            }
#line 2372
            if ((int )qs___3->state == 3) {
#line 2372
              goto case_5___0;
            }
#line 2375
            if ((int )qs___3->state == 2) {
#line 2375
              goto case_2___0;
            }
#line 2371
            goto switch_break___0;
            case_5___0: /* CIL Label */ 
            case_3___0: /* CIL Label */ 
#line 2373
            srv_event = (int )(polls + k)->revents & 57;
#line 2374
            goto switch_break___0;
            case_2___0: /* CIL Label */ 
#line 2376
            srv_event = (int )(polls + k)->revents & 60;
#line 2377
            goto switch_break___0;
            switch_break___0: /* CIL Label */ ;
            }
#line 2380
            if (srv_event) {
#line 2381
              nevents --;
              retryquery2: 
              {
#line 2383
              rv = p_exec_query(& ent, name, thint, qs___3, & ns, c_soa);
              }
#line 2384
              if (rv == 0) {
#line 2386
                if (debug_p) {
                  {
#line 2386
                  tmp___14 = pdnsd_a2str((pdnsd_a *)(& qs___3->a.sin4.sin_addr), _debugsockabuf___4,
                                         16);
#line 2386
                  debug_msg(0, "Query to %s succeeded.\n", tmp___14);
                  }
                }
                {
#line 2387
                authok___1 = auth_ok(q, name, thint, ent, hops, qslist, qhlist, qs___3,
                                     ns, & serv);
                }
#line 2387
                if (authok___1) {
#line 2388
                  if (authok___1 >= 0) {
#line 2389
                    if (! qs___3->failed) {
#line 2389
                      if ((int )qs___3->qm == 15) {
#line 2389
                        if (! qs___3->tc) {
#line 2395
                          qse = qs___3;
#line 2396
                          goto done;
                        }
                      } else {
#line 2395
                        qse = qs___3;
#line 2396
                        goto done;
                      }
                    }
                  } else {
#line 2400
                    goto free_ent_return_failed;
                  }
                }
#line 2402
                qval___1 = (authok___1 * 8 + (3 - (int )qs___3->failed) * 2) + ! qs___3->tc;
#line 2402
                if (entsave) {
#line 2402
                  if (qval___1 > qualval) {
                    {
#line 2402
                    free_cent(entsave);
#line 2402
                    free((void *)entsave);
#line 2402
                    entsave = (dns_cent_t *)((void *)0);
#line 2402
                    del_qserv(servsave);
#line 2402
                    free((void *)nssave);
                    }
                  }
                }
#line 2402
                if (! entsave) {
                  {
#line 2402
                  entsave = ent;
#line 2402
                  servsave = serv;
#line 2402
                  tmp___15 = da_nel((darray )serv);
                  }
#line 2402
                  if (tmp___15 > 0U) {
#line 2402
                    nssave = ns;
                  } else {
                    {
#line 2402
                    nssave = (dlist )((void *)0);
#line 2402
                    free((void *)ns);
                    }
                  }
#line 2402
                  qualval = qval___1;
#line 2402
                  qse = qs___3;
                } else {
                  {
#line 2402
                  free_cent(ent);
#line 2402
                  free((void *)ent);
#line 2402
                  del_qserv(serv);
#line 2402
                  free((void *)ns);
                  }
                }
#line 2402
                serv = (query_stat_array )((void *)0);
#line 2402
                ns = (dlist )((void *)0);
#line 2404
                if ((int )qs___3->qm == 15) {
#line 2404
                  if (qs___3->tc) {
                    {
#line 2405
                    switch_to_tcp(qs___3);
                    }
#line 2406
                    if (debug_p) {
                      {
#line 2406
                      tmp___16 = pdnsd_a2str((pdnsd_a *)(& qs___3->a.sin4.sin_addr),
                                             _debugsockabuf___5, 16);
#line 2406
                      debug_msg(0, "Reply from %s was truncated. Trying again using TCP.\n",
                                tmp___16);
                      }
                    }
#line 2408
                    goto retryquery2;
                  }
                }
              } else
#line 2412
              if (rv == 3) {
#line 2413
                goto done;
              } else
#line 2412
              if (rv == 65535) {
#line 2413
                goto done;
              }
            }
          }
#line 2418
          if ((int )qs___3->state == 8) {
#line 2418
            if (i == dc) {
#line 2419
              dc ++;
            }
          }
#line 2346
          i ++;
        }
        while_break___5: /* CIL Label */ ;
        }
#line 2421
        if (nevents > 0) {
#line 2425
          poll_errs += (unsigned long volatile   )1;
#line 2425
          if (poll_errs <= (unsigned long volatile   )10) {
            {
#line 2426
            log_message(3, "%d unhandled poll/select event(s) in p_recursive_query() at %s, line %d.",
                        nevents, "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/dns_query.c",
                        2426);
            }
          }
#line 2427
          rv = 2;
#line 2428
          goto done;
        }
        __Cont: /* CIL Label */ 
#line 2195
        if (! (dc < mc)) {
#line 2195
          goto while_break___1;
        }
      }
      while_break___1: /* CIL Label */ ;
      }
    }
#line 2122
    j += parqueries;
  }
  while_break: /* CIL Label */ ;
  }
#line 2433
  goto cancel_queries;
  free_ent_return_failed: 
  {
#line 2435
  free_cent(ent);
#line 2436
  free((void *)ent);
#line 2437
  rv = 65535;
  }
  done: 
#line 2439
  if (entsave) {
    {
#line 2442
    free_cent(entsave);
#line 2443
    free((void *)entsave);
#line 2444
    entsave = (dns_cent_t *)((void *)0);
#line 2445
    del_qserv(servsave);
#line 2446
    free((void *)nssave);
    }
  }
  cancel_queries: 
#line 2450
  i = dc;
  {
#line 2450
  while (1) {
    while_continue___7: /* CIL Label */ ;
#line 2450
    if (! (i < mc)) {
#line 2450
      goto while_break___7;
    }
    {
#line 2451
    p_cancel_query(& q->elem[i]);
#line 2450
    i ++;
    }
  }
  while_break___7: /* CIL Label */ ;
  }
#line 2458
  n = 0;
#line 2459
  i = 0;
  {
#line 2459
  while (1) {
    while_continue___8: /* CIL Label */ ;
#line 2459
    if (! (i < mc)) {
#line 2459
      goto while_break___8;
    }
#line 2460
    if ((int )q->elem[i].needs_testing > 1) {
#line 2461
      n ++;
    }
#line 2459
    i ++;
  }
  while_break___8: /* CIL Label */ ;
  }
#line 2462
  if (n > 0) {
    {
#line 2463
    __lengthofaddrs = (unsigned long )n;
#line 2463
    tmp___17 = __builtin_alloca(sizeof(*addrs) * __lengthofaddrs);
#line 2463
    addrs = (pdnsd_a *)tmp___17;
#line 2464
    k = 0;
#line 2465
    i = 0;
    }
    {
#line 2465
    while (1) {
      while_continue___9: /* CIL Label */ ;
#line 2465
      if (! (i < mc)) {
#line 2465
        goto while_break___9;
      }
#line 2466
      qs___4 = & q->elem[i];
#line 2467
      if ((int )qs___4->needs_testing > 1) {
#line 2468
        tmp___18 = k;
#line 2468
        k ++;
#line 2468
        *(addrs + tmp___18) = *((pdnsd_a *)(& qs___4->a.sin4.sin_addr));
      }
#line 2465
      i ++;
    }
    while_break___9: /* CIL Label */ ;
    }
    {
#line 2470
    sched_server_test(addrs, n, -1);
    }
  }
#line 2475
  if (entsave) {
#line 2482
    if (debug_p) {
      {
#line 2482
      tmp___19 = pdnsd_a2str((pdnsd_a *)(& qse->a.sin4.sin_addr), _debugsockabuf___6,
                             16);
      }
#line 2482
      if (! (qualval & 6)) {
#line 2482
        tmp___23 = "reportedly failed";
      } else {
#line 2482
        if (! (qualval & 2)) {
#line 2482
          tmp___22 = "inconsistent";
        } else {
#line 2482
          if (! (qualval & 1)) {
#line 2482
            tmp___21 = "truncated";
          } else {
#line 2482
            if (! (qualval & 8)) {
#line 2482
              tmp___20 = "non-authoritative";
            } else {
#line 2482
              tmp___20 = "good";
            }
#line 2482
            tmp___21 = tmp___20;
          }
#line 2482
          tmp___22 = tmp___21;
        }
#line 2482
        tmp___23 = tmp___22;
      }
      {
#line 2482
      debug_msg(0, "Using %s reply from %s.\n", tmp___23, tmp___19);
      }
    }
#line 2488
    ent = entsave;
#line 2489
    serv = servsave;
#line 2490
    ns = nssave;
#line 2491
    if (qualval < 14) {
#line 2492
      if (! ((int )ent->flags & 1)) {
#line 2493
        if ((int )ent->flags & 1) {
#line 2493
          tmp___25 = 0;
        } else {
#line 2493
          if (ent->__annonCompField2.rr.rrext) {
#line 2493
            tmp___24 = 47;
          } else {
#line 2493
            tmp___24 = 8;
          }
#line 2493
          tmp___25 = tmp___24;
        }
#line 2493
        jlim = tmp___25;
#line 2494
        j = 0;
        {
#line 2494
        while (1) {
          while_continue___10: /* CIL Label */ ;
#line 2494
          if (! (j < jlim)) {
#line 2494
            goto while_break___10;
          }
#line 2495
          if (j < 8) {
#line 2495
            tmp___26 = ent->__annonCompField2.rr.rrmu[j];
          } else {
#line 2495
            tmp___26 = *(ent->__annonCompField2.rr.rrext + (j - 8));
          }
#line 2495
          rrs = tmp___26;
#line 2496
          if (rrs) {
#line 2497
            rrs->flags = (unsigned short )((int )rrs->flags | 8);
          }
#line 2494
          j ++;
        }
        while_break___10: /* CIL Label */ ;
        }
      } else {
#line 2501
        ent->flags = (unsigned short )((int )ent->flags | 8);
      }
    }
#line 2503
    rv = 0;
  } else
#line 2505
  if (rv != 0) {
#line 2506
    if (rv == 65535) {
#line 2507
      if (debug_p) {
        {
#line 2507
        debug_msg(0, "Unrecoverable error encountered while processing query.\n");
        }
      }
#line 2508
      rv = 2;
    }
#line 2510
    if (debug_p) {
      {
#line 2510
      tmp___27 = get_ename(rv);
#line 2510
      debug_msg(0, "No query succeeded. Returning error code \"%s\"\n", tmp___27);
      }
    }
#line 2511
    goto clean_up_return;
  }
#line 2514
  if (nocache) {
#line 2514
    *nocache = (int )qse->nocache;
  }
  {
#line 2516
  tmp___29 = da_nel((darray )serv);
  }
#line 2516
  if (tmp___29 > 0U) {
    {
#line 2518
    qsn.qa = q;
#line 2518
    qsn.next = qslist;
#line 2519
    save_ns = ent->c_ns;
#line 2519
    save_soa = ent->c_soa;
#line 2520
    free_cent(ent);
#line 2521
    free((void *)ent);
#line 2522
    tmp___28 = time((time_t *)((void *)0));
#line 2522
    rv = p_dns_cached_resolve(serv, name, thint, & ent, hops - 1, & qsn, qhlist, tmp___28,
                              c_soa);
    }
#line 2523
    if (rv == 0) {
#line 2524
      if ((int )save_ns != 255) {
#line 2524
        if ((int )ent->c_ns == 255) {
#line 2525
          ent->c_ns = save_ns;
        } else
#line 2524
        if ((int )ent->c_ns < (int )save_ns) {
#line 2525
          ent->c_ns = save_ns;
        }
      }
#line 2526
      if ((int )save_soa != 255) {
#line 2526
        if ((int )ent->c_soa == 255) {
#line 2527
          ent->c_soa = save_soa;
        } else
#line 2526
        if ((int )ent->c_soa < (int )save_soa) {
#line 2527
          ent->c_soa = save_soa;
        }
      }
    } else
#line 2529
    if (rv == 3) {
#line 2529
      if (c_soa) {
#line 2530
        if ((int )save_soa != 255) {
#line 2530
          if ((int )*c_soa == 255) {
#line 2531
            *c_soa = save_soa;
          } else
#line 2530
          if ((int )*c_soa < (int )save_soa) {
#line 2531
            *c_soa = save_soa;
          }
        }
      }
    }
  }
  clean_up_return: 
  {
#line 2539
  del_qserv(serv);
#line 2540
  free((void *)ns);
  }
#line 2542
  if (rv == 0) {
#line 2542
    *entp = ent;
  }
#line 2543
  return (rv);
}
}
#line 2554 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/dns_query.c"
static int auth_ok(query_stat_array q , unsigned char const   *name , int thint ,
                   dns_cent_t *ent , int hops , qstatnode_t *qslist , qhintnode_t *qhlist ,
                   query_stat_t *qse , dlist ns , query_stat_array *serv ) 
{ 
  int retval ;
  int tmp ;
  unsigned char *nsdomain ;
  void *tmp___0 ;
  unsigned int rem ;
  unsigned int crem ;
  void *tmp___1 ;
  unsigned char dbuf[256] ;
  unsigned char sdbuf[256] ;
  void *tmp___2 ;
  char _debugsockabuf[16] ;
  unsigned char const   *tmp___3 ;
  unsigned char const   *tmp___4 ;
  char const   *tmp___5 ;
  unsigned char *nsdomp ;
  unsigned char *nsdomain___0 ;
  rr_set_t *localrrset ;
  rr_bucket_t *localrr ;
  void *tmp___6 ;
  unsigned char *nsname ;
  pdnsd_a2 serva ;
  unsigned int rem___0 ;
  unsigned char nmbuf[256] ;
  unsigned char dbuf___0[256] ;
  unsigned char nsbuf[256] ;
  unsigned char const   *tmp___7 ;
  unsigned char const   *tmp___8 ;
  unsigned char const   *tmp___9 ;
  void *tmp___10 ;
  void *tmp___11 ;
  void *tmp___12 ;
  void *tmp___13 ;
  unsigned char const   *nm ;
  int tp ;
  qhintnode_t *ql ;
  unsigned char _debugstrbuf[256] ;
  unsigned char const   *tmp___14 ;
  int tmp___15 ;
  qhintnode_t qhn ;
  dns_cent_t *servent ;
  rr_set_t *rrset ;
  rr_set_t *tmp___16 ;
  time_t tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int i ;
  int n ;
  unsigned int tmp___21 ;
  query_stat_t *qs ;
  int tmp___22 ;
  query_stat_array qa ;
  qstatnode_t *ql___0 ;
  int i___0 ;
  int n___0 ;
  unsigned int tmp___23 ;
  query_stat_t *qs___0 ;
  char _debugsockabuf___0[16] ;
  char const   *tmp___24 ;
  int tmp___25 ;
  rejectlist_t *tmp___26 ;
  int tmp___27 ;
  char _debugsockabuf___1[16] ;
  char const   *tmp___28 ;

  {
#line 2558
  retval = 0;
#line 2562
  if ((int )qse->failed > 1) {
#line 2562
    return (0);
  }
#line 2580
  if (qse->auth_serv) {
#line 2580
    if (! ((int )ent->flags & 1)) {
#line 2580
      if (thint >= 251) {
#line 2580
        if (! (thint <= 255)) {
#line 2580
          goto _L;
        }
      } else
      _L: /* CIL Label */ 
#line 2580
      if (thint >= 1) {
#line 2580
        if (thint <= 51) {
          {
#line 2580
          tmp = have_rr(ent, thint);
          }
#line 2580
          if (tmp) {
#line 2581
            return (1);
          } else
#line 2580
          if (! ((int )ent->flags & 1)) {
#line 2580
            if (ent->__annonCompField2.rr.rrmu[2]) {
#line 2580
              if ((ent->__annonCompField2.rr.rrmu[2])->rrs) {
#line 2581
                return (1);
              }
            }
          }
        } else {
#line 2581
          return (1);
        }
      } else {
#line 2581
        return (1);
      }
    } else {
#line 2581
      return (1);
    }
  } else {
#line 2581
    return (1);
  }
#line 2583
  if (qse->aa) {
#line 2591
    if (! qse->nsdomain) {
#line 2592
      return (1);
    }
    {
#line 2594
    tmp___0 = dlist_first(ns);
#line 2594
    nsdomain = (unsigned char *)tmp___0;
    }
#line 2595
    if (! nsdomain) {
#line 2596
      return (1);
    }
    {
#line 2597
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 2599
      domain_match((unsigned char const   *)nsdomain, qse->nsdomain, & rem, & crem);
      }
#line 2600
      if (rem > 0U) {
#line 2600
        if (! (crem == 0U)) {
#line 2601
          return (1);
        }
      } else {
#line 2601
        return (1);
      }
      {
#line 2602
      domain_match((unsigned char const   *)nsdomain, name, & rem, (unsigned int *)((void *)0));
      }
#line 2603
      if (rem != 0U) {
#line 2604
        return (1);
      }
      {
#line 2605
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 2606
        tmp___1 = dlist_next((void *)nsdomain);
#line 2606
        nsdomain = (unsigned char *)tmp___1;
        }
#line 2607
        if (! nsdomain) {
#line 2608
          goto done_checkauth;
        }
#line 2605
        if (! ((int )*nsdomain == 255)) {
#line 2605
          goto while_break___0;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
    }
    while_break: /* CIL Label */ ;
    }
    done_checkauth: ;
#line 2617
    if (debug_p) {
      {
#line 2619
      tmp___2 = dlist_first(ns);
#line 2619
      nsdomain = (unsigned char *)tmp___2;
      }
#line 2620
      if (debug_p) {
        {
#line 2620
        tmp___3 = rhn2str((unsigned char const   *)nsdomain, sdbuf, (unsigned int )sizeof(sdbuf));
#line 2620
        tmp___4 = rhn2str(qse->nsdomain, dbuf, (unsigned int )sizeof(dbuf));
#line 2620
        tmp___5 = pdnsd_a2str((pdnsd_a *)(& qse->a.sin4.sin_addr), _debugsockabuf,
                              16);
#line 2620
        debug_msg(0, "The name server %s which is responsible for the %s domain, raised the aa flag, but appears to delegate to the sub-domain %s\n",
                  tmp___5, tmp___4, tmp___3);
        }
      }
    }
  }
#line 2629
  if (hops > 0) {
    {
#line 2630
    nsdomain___0 = (unsigned char *)((void *)0);
#line 2631
    localrrset = (rr_set_t *)((void *)0);
#line 2632
    localrr = (rr_bucket_t *)((void *)0);
#line 2633
    tmp___6 = dlist_first(ns);
#line 2633
    nsdomp = (unsigned char *)tmp___6;
    }
    {
#line 2633
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 2634
      nsname = (unsigned char *)((void *)0);
#line 2638
      if (localrr) {
#line 2640
        nsname = (unsigned char *)(localrr->data);
#line 2641
        localrr = localrr->next;
      } else {
#line 2644
        if (localrrset) {
          {
#line 2646
          del_rrset(localrrset);
#line 2647
          localrrset = (rr_set_t *)((void *)0);
          }
        }
#line 2649
        if (! nsdomp) {
#line 2650
          goto while_break___1;
        } else
#line 2651
        if ((int )*nsdomp != 255) {
#line 2653
          nsdomain___0 = nsdomp;
#line 2654
          if (global.paranoid) {
            {
#line 2657
            domain_match((unsigned char const   *)nsdomain___0, name, & rem___0, (unsigned int *)((void *)0));
            }
#line 2658
            if (rem___0 != 0U) {
#line 2661
              if (debug_p) {
                {
#line 2661
                tmp___7 = rhn2str(name, nmbuf, (unsigned int )sizeof(nmbuf));
#line 2661
                tmp___8 = rhn2str((unsigned char const   *)nsdomain___0, dbuf___0,
                                  (unsigned int )sizeof(dbuf___0));
#line 2661
                tmp___9 = rhn2str((unsigned char const   *)nsname, nsbuf, (unsigned int )sizeof(nsbuf));
#line 2661
                debug_msg(0, "The name server %s is responsible for the %s domain, which does not match %s\n",
                          tmp___9, tmp___8, tmp___7);
                }
              }
              {
#line 2667
              while (1) {
                while_continue___2: /* CIL Label */ ;
                {
#line 2668
                tmp___10 = dlist_next((void *)nsdomp);
#line 2668
                nsdomp = (unsigned char *)tmp___10;
                }
#line 2667
                if (nsdomp) {
#line 2667
                  if (! ((int )*nsdomp == 255)) {
#line 2667
                    goto while_break___2;
                  }
                } else {
#line 2667
                  goto while_break___2;
                }
              }
              while_break___2: /* CIL Label */ ;
              }
#line 2670
              goto __Cont;
            }
          }
          {
#line 2676
          localrrset = lookup_cache_local_rrset((unsigned char const   *)nsdomain___0,
                                                2);
          }
#line 2677
          if (localrrset) {
            {
#line 2679
            while (1) {
              while_continue___3: /* CIL Label */ ;
              {
#line 2680
              tmp___11 = dlist_next((void *)nsdomp);
#line 2680
              nsdomp = (unsigned char *)tmp___11;
              }
#line 2679
              if (nsdomp) {
#line 2679
                if (! ((int )*nsdomp == 255)) {
#line 2679
                  goto while_break___3;
                }
              } else {
#line 2679
                goto while_break___3;
              }
            }
            while_break___3: /* CIL Label */ ;
            }
#line 2682
            localrr = localrrset->rrs;
#line 2683
            if (! localrr) {
#line 2683
              goto __Cont;
            }
#line 2684
            nsname = (unsigned char *)(localrr->data);
#line 2685
            localrr = localrr->next;
          } else {
            {
#line 2688
            nsname = skiprhn(nsdomp);
#line 2689
            tmp___12 = dlist_next((void *)nsdomp);
#line 2689
            nsdomp = (unsigned char *)tmp___12;
            }
          }
        } else {
          {
#line 2694
          nsname = nsdomp + 1;
#line 2695
          tmp___13 = dlist_next((void *)nsdomp);
#line 2695
          nsdomp = (unsigned char *)tmp___13;
          }
        }
      }
#line 2705
      serva.ipv4.s_addr = (in_addr_t )0;
#line 2707
      nm = name;
#line 2708
      tp = thint;
#line 2709
      ql = qhlist;
      {
#line 2711
      while (1) {
        while_continue___4: /* CIL Label */ ;
        {
#line 2712
        tmp___15 = rhnicmp(nm, (unsigned char const   *)nsname);
        }
#line 2712
        if (tmp___15) {
#line 2712
          if (tp == 1) {
#line 2713
            if (debug_p) {
              {
#line 2713
              tmp___14 = rhn2str((unsigned char const   *)nsname, _debugstrbuf, (unsigned int )sizeof(_debugstrbuf));
#line 2713
              debug_msg(0, "Not looking up address for name server \"%s\": risk of infinite recursion.\n",
                        tmp___14);
              }
            }
#line 2715
            goto skip_server;
          }
        }
#line 2717
        if (! ql) {
#line 2717
          goto while_break___4;
        }
#line 2718
        nm = ql->nm;
#line 2719
        tp = ql->tp;
#line 2720
        ql = ql->next;
      }
      while_break___4: /* CIL Label */ ;
      }
      {
#line 2723
      qhn.nm = name;
#line 2723
      qhn.tp = thint;
#line 2723
      qhn.next = qhlist;
#line 2725
      tmp___17 = time((time_t *)((void *)0));
#line 2725
      tmp___18 = r_dns_cached_resolve(nsname, 1, & servent, hops - 1, & qhn, tmp___17,
                                      (unsigned char *)((void *)0));
      }
#line 2725
      if (tmp___18 == 0) {
#line 2728
        if (! ((int )servent->flags & 1)) {
#line 2728
          tmp___16 = servent->__annonCompField2.rr.rrmu[0];
        } else {
#line 2728
          tmp___16 = (rr_set_t *)((void *)0);
        }
#line 2728
        rrset = tmp___16;
#line 2729
        if (rrset) {
#line 2729
          if (rrset->rrs) {
#line 2730
            serva.ipv4 = *((struct in_addr *)((rrset->rrs)->data));
          }
        }
        {
#line 2749
        free_cent(servent);
#line 2750
        free((void *)servent);
        }
      }
      {
#line 2755
      tmp___19 = is_inaddr2_any(& serva);
      }
#line 2755
      if (tmp___19) {
#line 2756
        goto __Cont;
      }
      {
#line 2758
      tmp___20 = is_local_addr((pdnsd_a *)(& serva.ipv4));
      }
#line 2758
      if (tmp___20) {
#line 2759
        goto __Cont;
      }
      {
#line 2762
      tmp___21 = da_nel((darray )*serv);
#line 2762
      n = (int )tmp___21;
#line 2763
      i = 0;
      }
      {
#line 2763
      while (1) {
        while_continue___5: /* CIL Label */ ;
#line 2763
        if (! (i < n)) {
#line 2763
          goto while_break___5;
        }
        {
#line 2764
        qs = & (*serv)->elem[i];
#line 2765
        tmp___22 = query_stat_same_inaddr2(qs, & serva);
        }
#line 2765
        if (tmp___22) {
#line 2766
          goto skip_server;
        }
#line 2763
        i ++;
      }
      while_break___5: /* CIL Label */ ;
      }
#line 2771
      qa = q;
#line 2772
      ql___0 = qslist;
      {
#line 2773
      while (1) {
        while_continue___6: /* CIL Label */ ;
        {
#line 2774
        tmp___23 = da_nel((darray )qa);
#line 2774
        n___0 = (int )tmp___23;
#line 2775
        i___0 = 0;
        }
        {
#line 2775
        while (1) {
          while_continue___7: /* CIL Label */ ;
#line 2775
          if (! (i___0 < n___0)) {
#line 2775
            goto while_break___7;
          }
#line 2778
          qs___0 = & qa->elem[i___0];
#line 2779
          if ((int )qs___0->state == 8) {
            {
#line 2779
            tmp___25 = equiv_inaddr2((pdnsd_a *)(& qs___0->a.sin4.sin_addr), & serva);
            }
#line 2779
            if (tmp___25) {
#line 2780
              if (debug_p) {
                {
#line 2780
                tmp___24 = pdnsd_a2str((pdnsd_a *)(& serva.ipv4), _debugsockabuf___0,
                                       16);
#line 2780
                debug_msg(0, "Not trying name server %s, already queried.\n", tmp___24);
                }
              }
#line 2781
              goto skip_server;
            }
          }
#line 2775
          i___0 ++;
        }
        while_break___7: /* CIL Label */ ;
        }
#line 2784
        if (! ql___0) {
#line 2784
          goto while_break___6;
        }
#line 2785
        qa = ql___0->qa;
#line 2786
        ql___0 = ql___0->next;
      }
      while_break___6: /* CIL Label */ ;
      }
#line 2792
      if (qse->rejectlist) {
#line 2792
        if ((qse->rejectlist)->inherit) {
#line 2792
          tmp___26 = qse->rejectlist;
        } else {
#line 2792
          tmp___26 = (rejectlist_t *)((void *)0);
        }
      } else {
#line 2792
        tmp___26 = (rejectlist_t *)((void *)0);
      }
      {
#line 2792
      tmp___27 = add_qserv(serv, & serva, 53, qse->timeout, (unsigned int )((int )qse->flags & -87),
                           0, qse->lean_query, qse->edns_query, (char)2, (char)0,
                           (char )(! global.paranoid), (unsigned char const   *)nsdomain___0,
                           tmp___26);
      }
#line 2792
      if (! tmp___27) {
#line 2796
        return (-1);
      }
#line 2798
      retval = 1;
      skip_server: ;
      __Cont: /* CIL Label */ ;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 2802
    if (! retval) {
#line 2803
      if (debug_p) {
        {
#line 2803
        tmp___28 = pdnsd_a2str((pdnsd_a *)(& qse->a.sin4.sin_addr), _debugsockabuf___1,
                               16);
#line 2803
        debug_msg(0, "No remaining authoritative name servers to try in authority section from %s.\n",
                  tmp___28);
        }
      }
    }
  } else
#line 2808
  if (debug_p) {
    {
#line 2808
    debug_msg(0, "Maximum hops count reached; not trying any more name servers.\n");
    }
  }
#line 2811
  return (retval);
}
}
#line 2820 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/dns_query.c"
static int use_server(servparm_t *s , unsigned char const   *name ) 
{ 
  int i ;
  int n ;
  unsigned int tmp ;
  slist_t *sl ;
  unsigned int nrem ;
  unsigned int lrem ;
  unsigned int tmp___0 ;

  {
  {
#line 2822
  tmp = da_nel((darray )s->alist);
#line 2822
  n = (int )tmp;
#line 2824
  i = 0;
  }
  {
#line 2824
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2824
    if (! (i < n)) {
#line 2824
      goto while_break;
    }
    {
#line 2825
    sl = & (s->alist)->elem[i];
#line 2827
    domain_match(name, (unsigned char const   *)sl->domain, & nrem, & lrem);
    }
#line 2828
    if (! lrem) {
#line 2828
      if (! sl->exact) {
#line 2829
        return ((int )sl->rule == 18);
      } else
#line 2828
      if (! nrem) {
#line 2829
        return ((int )sl->rule == 18);
      }
    }
#line 2824
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2832
  if ((int )s->policy == 20) {
#line 2832
    goto _L;
  } else
#line 2832
  if ((int )s->policy == 21) {
    _L: /* CIL Label */ 
    {
#line 2833
    tmp___0 = rhnsegcnt(name);
    }
#line 2833
    if (tmp___0 <= 1U) {
#line 2834
      return ((int )s->policy == 20);
    } else {
#line 2836
      return ((int )s->policy == 21);
    }
  }
#line 2839
  return ((int )s->policy == 18);
}
}
#line 2853 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/dns_query.c"
static rejectlist_t *add_rejectlist(rejectlist_t *rl , servparm_t *sp ) 
{ 
  int i ;
  int na4 ;
  unsigned int tmp ;
  addr4maskpair_t *a4p ;
  int na6 ;
  unsigned int tmp___0 ;
  addr6maskpair_t *a6p ;
  rejectlist_t *rlist ;
  void *tmp___1 ;
  addr6maskpair_t *tmp___2 ;
  addr4maskpair_t *tmp___3 ;

  {
  {
#line 2855
  tmp = da_nel((darray )sp->reject_a4);
#line 2855
  na4 = (int )tmp;
#line 2858
  tmp___0 = da_nel((darray )sp->reject_a6);
#line 2858
  na6 = (int )tmp___0;
#line 2861
  tmp___1 = malloc((sizeof(rejectlist_t ) + (unsigned long )na4 * sizeof(addr4maskpair_t )) + (unsigned long )na6 * sizeof(addr6maskpair_t ));
#line 2861
  rlist = (rejectlist_t *)tmp___1;
  }
#line 2867
  if (rlist) {
#line 2870
    rlist->na6 = na6;
#line 2871
    a6p = rlist->rdata;
#line 2872
    i = 0;
    {
#line 2872
    while (1) {
      while_continue: /* CIL Label */ ;
#line 2872
      if (! (i < na6)) {
#line 2872
        goto while_break;
      }
#line 2873
      tmp___2 = a6p;
#line 2873
      a6p ++;
#line 2873
      *tmp___2 = (sp->reject_a6)->elem[i];
#line 2872
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 2875
    rlist->na4 = na4;
#line 2877
    a4p = (addr4maskpair_t *)a6p;
#line 2881
    i = 0;
    {
#line 2881
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 2881
      if (! (i < na4)) {
#line 2881
        goto while_break___0;
      }
#line 2882
      tmp___3 = a4p;
#line 2882
      a4p ++;
#line 2882
      *tmp___3 = (sp->reject_a4)->elem[i];
#line 2881
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 2884
    rlist->policy = sp->rejectpolicy;
#line 2885
    rlist->inherit = (short )sp->rejectrecursively;
#line 2886
    rlist->next = rl;
  }
#line 2889
  return (rlist);
}
}
#line 2892 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/dns_query.c"
__inline static void free_rejectlist(rejectlist_t *rl ) 
{ 
  rejectlist_t *next ;

  {
  {
#line 2894
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2894
    if (! rl) {
#line 2894
      goto while_break;
    }
    {
#line 2895
    next = rl->next;
#line 2896
    free((void *)rl);
#line 2897
    rl = next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 2899
  return;
}
}
#line 2904 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/dns_query.c"
static addr2_array lookup_ns(unsigned char const   *domain ) 
{ 
  addr2_array res ;
  dns_cent_t *cent ;
  dns_cent_t *tmp ;
  rr_set_t *rrset ;
  rr_set_t *tmp___0 ;
  rr_bucket_t *rr ;
  pdnsd_a2 *serva ;
  dns_cent_t *servent ;
  darray tmp___1 ;
  rr_set_t *rrset___0 ;
  rr_set_t *tmp___2 ;
  time_t tmp___3 ;
  time_t tmp___4 ;
  int tmp___5 ;
  time_t tmp___6 ;
  time_t tmp___7 ;

  {
  {
#line 2906
  res = (addr2_array )((void *)0);
#line 2908
  tmp = lookup_cache(domain, (int *)((void *)0));
#line 2908
  cent = tmp;
  }
#line 2909
  if (cent) {
#line 2910
    if (! ((int )cent->flags & 1)) {
#line 2910
      tmp___0 = cent->__annonCompField2.rr.rrmu[1];
    } else {
#line 2910
      tmp___0 = (rr_set_t *)((void *)0);
    }
#line 2910
    rrset = tmp___0;
#line 2911
    if (rrset) {
#line 2911
      if ((int )rrset->flags & 64) {
#line 2911
        if (rrset->ttl < 120L) {
#line 2911
          tmp___6 = (time_t )120;
        } else {
#line 2911
          tmp___6 = rrset->ttl;
        }
        {
#line 2911
        tmp___7 = time((time_t *)((void *)0));
        }
#line 2911
        if (! (rrset->ts + tmp___6 < tmp___7)) {
#line 2913
          rr = rrset->rrs;
          {
#line 2913
          while (1) {
            while_continue: /* CIL Label */ ;
#line 2913
            if (! rr) {
#line 2913
              goto while_break;
            }
            {
#line 2916
            tmp___1 = da_grow1((darray )res, (size_t )(((addr2_array )0)->elem), sizeof(res->elem[0]),
                               (void (*)(void * ))((void *)0));
#line 2916
            res = (addr2_array )tmp___1;
            }
#line 2916
            if (! res) {
#line 2917
              if (debug_p) {
                {
#line 2917
                debug_msg(0, "Out of memory in lookup_ns()\n");
                }
              }
#line 2918
              goto while_break;
            }
            {
#line 2920
            serva = & res->elem[res->nel - 1UL];
#line 2925
            serva->ipv4.s_addr = (in_addr_t )0;
#line 2927
            servent = lookup_cache((unsigned char const   *)((unsigned char *)(rr->data)),
                                   (int *)((void *)0));
            }
#line 2928
            if (servent) {
#line 2931
              if (! ((int )servent->flags & 1)) {
#line 2931
                tmp___2 = servent->__annonCompField2.rr.rrmu[0];
              } else {
#line 2931
                tmp___2 = (rr_set_t *)((void *)0);
              }
#line 2931
              rrset___0 = tmp___2;
#line 2932
              if (rrset___0) {
#line 2932
                if (rrset___0->ttl < 120L) {
#line 2932
                  tmp___3 = (time_t )120;
                } else {
#line 2932
                  tmp___3 = rrset___0->ttl;
                }
                {
#line 2932
                tmp___4 = time((time_t *)((void *)0));
                }
#line 2932
                if (! (rrset___0->ts + tmp___3 < tmp___4)) {
#line 2932
                  if (rrset___0->rrs) {
#line 2933
                    serva->ipv4 = *((struct in_addr *)((rrset___0->rrs)->data));
                  }
                }
              }
              {
#line 2956
              free_cent(servent);
#line 2957
              free((void *)servent);
              }
            }
            {
#line 2959
            tmp___5 = is_inaddr2_any(serva);
            }
#line 2959
            if (tmp___5) {
              {
#line 2961
              free((void *)res);
#line 2961
              res = (addr2_array )((void *)0);
              }
#line 2962
              goto while_break;
            }
#line 2913
            rr = rr->next;
          }
          while_break: /* CIL Label */ ;
          }
        }
      }
    }
    {
#line 2966
    free_cent(cent);
#line 2967
    free((void *)cent);
    }
  }
#line 2970
  return (res);
}
}
#line 2982 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/dns_query.c"
static unsigned char const   rdomain[1]  = {      (unsigned char const   )0};
#line 2978 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/dns_query.c"
addr2_array dns_rootserver_resolv(atup_array atup_a , int port , char edns_query ,
                                  time_t timeout ) 
{ 
  addr2_array res ;
  dns_cent_t *cent ;
  int rc ;
  rr_set_t *rrset ;
  rr_set_t *tmp ;
  rr_bucket_t *rr ;
  unsigned int nfail ;
  pdnsd_a2 serva ;
  dns_cent_t *servent ;
  rr_set_t *rrset___0 ;
  rr_set_t *tmp___0 ;
  unsigned char _debugstrbuf[256] ;
  char const   *tmp___1 ;
  unsigned char const   *tmp___2 ;
  unsigned char _debugstrbuf___0[256] ;
  unsigned char const   *tmp___3 ;
  int tmp___4 ;
  darray tmp___5 ;
  unsigned int tmp___6 ;
  unsigned int tmp___7 ;
  char const   *tmp___8 ;

  {
  {
#line 2980
  res = (addr2_array )((void *)0);
#line 2985
  rc = simple_dns_cached_resolve(atup_a, port, edns_query, timeout, rdomain, 2, & cent);
  }
#line 2986
  if (rc == 0) {
#line 2987
    if (! ((int )cent->flags & 1)) {
#line 2987
      tmp = cent->__annonCompField2.rr.rrmu[1];
    } else {
#line 2987
      tmp = (rr_set_t *)((void *)0);
    }
#line 2987
    rrset = tmp;
#line 2988
    if (rrset) {
#line 2990
      nfail = 0U;
#line 2991
      rr = rrset->rrs;
      {
#line 2991
      while (1) {
        while_continue: /* CIL Label */ ;
#line 2991
        if (! rr) {
#line 2991
          goto while_break;
        }
        {
#line 2998
        serva.ipv4.s_addr = (in_addr_t )0;
#line 3000
        rc = simple_dns_cached_resolve(atup_a, port, edns_query, timeout, (unsigned char const   *)(rr->data),
                                       1, & servent);
        }
#line 3002
        if (rc == 0) {
#line 3005
          if (! ((int )servent->flags & 1)) {
#line 3005
            tmp___0 = servent->__annonCompField2.rr.rrmu[0];
          } else {
#line 3005
            tmp___0 = (rr_set_t *)((void *)0);
          }
#line 3005
          rrset___0 = tmp___0;
#line 3006
          if (rrset___0) {
#line 3006
            if (rrset___0->rrs) {
#line 3007
              serva.ipv4 = *((struct in_addr *)((rrset___0->rrs)->data));
            }
          }
          {
#line 3026
          free_cent(servent);
#line 3027
          free((void *)servent);
          }
        } else
#line 3030
        if (debug_p) {
          {
#line 3030
          tmp___1 = get_ename(rc);
#line 3030
          tmp___2 = rhn2str((unsigned char const   *)(rr->data), _debugstrbuf, (unsigned int )sizeof(_debugstrbuf));
#line 3030
          debug_msg(0, "Simple query for %s type A failed (rc: %s)\n", tmp___2, tmp___1);
          }
        }
        {
#line 3034
        tmp___4 = is_inaddr2_any(& serva);
        }
#line 3034
        if (tmp___4) {
#line 3036
          if (debug_p) {
            {
#line 3036
            tmp___3 = rhn2str((unsigned char const   *)(rr->data), _debugstrbuf___0,
                              (unsigned int )sizeof(_debugstrbuf___0));
#line 3036
            debug_msg(0, "Failed to obtain address of root server %s in dns_rootserver_resolv()\n",
                      tmp___3);
            }
          }
#line 3038
          nfail ++;
#line 3039
          goto __Cont;
        }
        {
#line 3041
        tmp___5 = da_grow1((darray )res, (size_t )(((addr2_array )0)->elem), sizeof(res->elem[0]),
                           (void (*)(void * ))((void *)0));
#line 3041
        res = (addr2_array )tmp___5;
        }
#line 3041
        if (! res) {
#line 3042
          if (debug_p) {
            {
#line 3042
            debug_msg(0, "Out of memory in dns_rootserver_resolv()\n");
            }
          }
#line 3043
          goto free_cent_return;
        }
#line 3045
        res->elem[res->nel - 1UL] = serva;
        __Cont: /* CIL Label */ 
#line 2991
        rr = rr->next;
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 3048
      tmp___7 = da_nel((darray )res);
      }
#line 3048
      if (nfail > tmp___7) {
#line 3049
        if (debug_p) {
          {
#line 3049
          tmp___6 = da_nel((darray )res);
#line 3049
          debug_msg(0, "Too many root-server resolve failures (%u succeeded, %u failed), rejecting the result.\n",
                    tmp___6, nfail);
          }
        }
        {
#line 3051
        free((void *)res);
#line 3051
        res = (addr2_array )((void *)0);
        }
      }
    }
    free_cent_return: 
    {
#line 3055
    free_cent(cent);
#line 3056
    free((void *)cent);
    }
  } else
#line 3059
  if (debug_p) {
    {
#line 3059
    tmp___8 = get_ename(rc);
#line 3059
    debug_msg(0, "Simple query for root domain type NS failed (rc: %s)\n", tmp___8);
    }
  }
#line 3062
  return (res);
}
}
#line 3096
static int p_dns_resolve(unsigned char const   *name , int thint , dns_cent_t **cachedp ,
                         int hops , qhintnode_t *qhlist , unsigned char *c_soa ) ;
#line 3096 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/dns_query.c"
static unsigned char const   rhn_arpa[6]  = {      (unsigned char const   )4,      (unsigned char const   )'a',      (unsigned char const   )'r',      (unsigned char const   )'p', 
        (unsigned char const   )'a',      (unsigned char const   )0};
#line 3066 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/dns_query.c"
static int p_dns_resolve(unsigned char const   *name , int thint , dns_cent_t **cachedp ,
                         int hops , qhintnode_t *qhlist , unsigned char *c_soa ) 
{ 
  int i ;
  int n ;
  int rc ;
  int one_up ;
  int seenrootserv ;
  query_stat_array serv ;
  rejectlist_t *rejectlist ;
  unsigned int tmp ;
  servparm_t *sp ;
  int m ;
  unsigned int tmp___0 ;
  rejectlist_t *rjl ;
  int j ;
  int jstart ;
  long tmp___1 ;
  atup_t *at ;
  int nseg ;
  int mseg ;
  int l ;
  unsigned char const   *topdomain ;
  addr2_array adrs ;
  unsigned int tmp___2 ;
  unsigned int rem ;
  unsigned int tmp___3 ;
  int k ;
  int kstart ;
  long tmp___4 ;
  unsigned int tmp___5 ;
  char _debugsockabuf[16] ;
  char const   *tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  unsigned int tmp___9 ;
  int tmp___10 ;
  dns_cent_t *cached ;
  int nocache ;
  dns_cent_t *tc ;

  {
  {
#line 3070
  one_up = 0;
#line 3070
  seenrootserv = 0;
#line 3071
  serv = (query_stat_array )((void *)0);
#line 3072
  rejectlist = (rejectlist_t *)((void *)0);
#line 3075
  lock_server_data();
#line 3076
  tmp = da_nel((darray )servers);
#line 3076
  n = (int )tmp;
#line 3077
  i = 0;
  }
  {
#line 3077
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3077
    if (! (i < n)) {
#line 3077
      goto while_break;
    }
#line 3078
    sp = & servers->elem[i];
#line 3079
    if ((int )sp->rootserver <= 1) {
      {
#line 3079
      tmp___10 = use_server(sp, name);
      }
#line 3079
      if (tmp___10) {
        {
#line 3080
        tmp___0 = da_nel((darray )sp->atup_a);
#line 3080
        m = (int )tmp___0;
        }
#line 3081
        if (m > 0) {
#line 3082
          rjl = (rejectlist_t *)((void *)0);
#line 3083
          j = 0;
#line 3083
          jstart = 0;
#line 3084
          if (sp->rand_servers) {
            {
#line 3084
            tmp___1 = random();
#line 3084
            jstart = (int )(tmp___1 % (long )m);
#line 3084
            j = jstart;
            }
          }
          {
#line 3085
          while (1) {
            while_continue___0: /* CIL Label */ ;
#line 3086
            at = & (sp->atup_a)->elem[j];
#line 3087
            if (at->is_up) {
#line 3088
              if (sp->rootserver) {
#line 3089
                if (! seenrootserv) {
                  {
#line 3090
                  mseg = 1;
#line 3090
                  l = 0;
#line 3091
                  topdomain = (unsigned char const   *)((void *)0);
#line 3092
                  adrs = (addr2_array )((void *)0);
#line 3093
                  seenrootserv = 1;
#line 3094
                  tmp___2 = rhnsegcnt(name);
#line 3094
                  nseg = (int )tmp___2;
                  }
#line 3095
                  if (nseg >= 2) {
                    {
#line 3099
                    domain_match(rhn_arpa, name, & rem, (unsigned int *)((void *)0));
                    }
#line 3100
                    if (rem == 0U) {
#line 3100
                      mseg = 3;
                    }
                  }
#line 3102
                  if (nseg <= mseg) {
#line 3103
                    if (nseg > 0) {
#line 3103
                      mseg = nseg - 1;
                    } else {
#line 3103
                      mseg = 0;
                    }
                  }
                  {
#line 3105
                  while (1) {
                    while_continue___1: /* CIL Label */ ;
#line 3105
                    if (! (mseg >= 1)) {
#line 3105
                      goto while_break___1;
                    }
                    {
#line 3106
                    topdomain = skipsegs(name, (unsigned int )(nseg - mseg));
#line 3107
                    adrs = lookup_ns(topdomain);
#line 3108
                    tmp___3 = da_nel((darray )adrs);
#line 3108
                    l = (int )tmp___3;
                    }
#line 3109
                    if (l > 0) {
#line 3109
                      goto while_break___1;
                    }
#line 3110
                    if (adrs) {
                      {
#line 3110
                      free((void *)adrs);
                      }
                    }
#line 3105
                    mseg --;
                  }
                  while_break___1: /* CIL Label */ ;
                  }
#line 3112
                  if (l > 0) {
#line 3116
                    k = 0;
#line 3116
                    kstart = 0;
#line 3117
                    if (sp->rand_servers) {
                      {
#line 3117
                      tmp___4 = random();
#line 3117
                      kstart = (int )(tmp___4 % (long )l);
#line 3117
                      k = kstart;
                      }
                    }
#line 3118
                    if ((unsigned long )sp->reject_a4 != (unsigned long )((void *)0)) {
#line 3118
                      goto _L;
                    } else
#line 3118
                    if ((unsigned long )sp->reject_a6 != (unsigned long )((void *)0)) {
                      _L: /* CIL Label */ 
#line 3118
                      if (sp->rejectrecursively) {
#line 3118
                        if (! rjl) {
                          {
#line 3119
                          rjl = add_rejectlist(rejectlist, sp);
                          }
#line 3120
                          if (! rjl) {
                            {
#line 3120
                            one_up = 0;
#line 3120
                            free((void *)adrs);
                            }
#line 3120
                            goto done;
                          }
#line 3121
                          rejectlist = rjl;
                        }
                      }
                    }
                    {
#line 3123
                    while (1) {
                      while_continue___2: /* CIL Label */ ;
                      {
#line 3124
                      tmp___5 = mk_flag_val(sp);
#line 3124
                      one_up = add_qserv(& serv, & adrs->elem[k], 53, sp->timeout,
                                         tmp___5 & 4294967209U, (int )sp->nocache,
                                         sp->lean_query, sp->edns_query, (char)2,
                                         (char)0, (char )(! global.paranoid), topdomain,
                                         rjl);
                      }
#line 3128
                      if (! one_up) {
                        {
#line 3129
                        free((void *)adrs);
                        }
#line 3130
                        goto done;
                      }
#line 3132
                      k ++;
#line 3132
                      if (k == l) {
#line 3132
                        k = 0;
                      }
#line 3123
                      if (! (k != kstart)) {
#line 3123
                        goto while_break___2;
                      }
                    }
                    while_break___2: /* CIL Label */ ;
                    }
                    {
#line 3134
                    free((void *)adrs);
                    }
#line 3135
                    if (debug_p) {
                      {
#line 3135
                      tmp___6 = pdnsd_a2str((pdnsd_a *)(& at->a.ipv4), _debugsockabuf,
                                            16);
#line 3135
                      debug_msg(0, "Not querying root-server %s, using cached information instead.\n",
                                tmp___6);
                      }
                    }
#line 3137
                    seenrootserv = 2;
#line 3138
                    goto while_break___0;
                  }
                } else
#line 3141
                if (seenrootserv == 2) {
#line 3142
                  goto while_break___0;
                }
              }
#line 3144
              if ((unsigned long )sp->reject_a4 != (unsigned long )((void *)0)) {
#line 3144
                goto _L___0;
              } else
#line 3144
              if ((unsigned long )sp->reject_a6 != (unsigned long )((void *)0)) {
                _L___0: /* CIL Label */ 
#line 3144
                if (! rjl) {
                  {
#line 3145
                  rjl = add_rejectlist(rejectlist, sp);
                  }
#line 3146
                  if (! rjl) {
#line 3146
                    one_up = 0;
#line 3146
                    goto done;
                  }
#line 3147
                  rejectlist = rjl;
                }
              }
              {
#line 3150
              tmp___7 = needs_testing(sp);
              }
#line 3150
              if (sp->rootserver) {
#line 3150
                tmp___8 = 3;
              } else {
#line 3150
                tmp___8 = ! sp->is_proxy;
              }
              {
#line 3150
              tmp___9 = mk_flag_val(sp);
#line 3150
              one_up = add_qserv(& serv, & at->a, (int )sp->port, sp->timeout, tmp___9,
                                 (int )sp->nocache, sp->lean_query, sp->edns_query,
                                 (char )tmp___8, (char )tmp___7, (char)1, (unsigned char const   *)((void *)0),
                                 rjl);
              }
#line 3155
              if (! one_up) {
#line 3156
                goto done;
              }
            }
#line 3158
            j ++;
#line 3158
            if (j == m) {
#line 3158
              j = 0;
            }
#line 3085
            if (! (j != jstart)) {
#line 3085
              goto while_break___0;
            }
          }
          while_break___0: /* CIL Label */ ;
          }
        }
      }
    }
#line 3077
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  done: 
  {
#line 3164
  unlock_server_data();
  }
#line 3165
  if (one_up) {
    {
#line 3168
    rc = p_recursive_query(serv, name, thint, & cached, & nocache, hops, (qstatnode_t *)((void *)0),
                           qhlist, c_soa);
    }
#line 3169
    if (rc == 0) {
#line 3170
      if (! nocache) {
        {
#line 3172
        add_cache(cached);
#line 3173
        tc = lookup_cache(name, (int *)((void *)0));
        }
#line 3173
        if (tc) {
          {
#line 3176
          free_cent(cached);
#line 3177
          free((void *)cached);
#line 3178
          cached = tc;
          }
        } else
#line 3180
        if (debug_p) {
          {
#line 3180
          debug_msg(0, "p_dns_resolve: merging answer with cache failed, using local cent copy.\n");
          }
        }
      } else
#line 3182
      if (debug_p) {
        {
#line 3182
        debug_msg(0, "p_dns_resolve: nocache.\n");
        }
      }
#line 3184
      *cachedp = cached;
    }
  } else {
#line 3188
    if (debug_p) {
      {
#line 3188
      debug_msg(0, "No server is marked up and allowed for this domain.\n");
      }
    }
#line 3189
    rc = 2;
  }
  {
#line 3191
  del_qserv(serv);
#line 3192
  free_rejectlist(rejectlist);
  }
#line 3193
  return (rc);
}
}
#line 3196 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/dns_query.c"
static int set_flags_ttl(unsigned short *flags , time_t *ttl , dns_cent_t *cached ,
                         int tp ) 
{ 
  rr_set_t *rrset ;
  rr_set_t *tmp ;
  time_t t ;
  time_t tmp___0 ;

  {
  {
#line 3198
  tmp = getrrset(cached, tp);
#line 3198
  rrset = tmp;
  }
#line 3199
  if (rrset) {
#line 3201
    *flags = (unsigned short )((int )*flags | (int )rrset->flags);
#line 3202
    if (rrset->ttl < 120L) {
#line 3202
      tmp___0 = (time_t )120;
    } else {
#line 3202
      tmp___0 = rrset->ttl;
    }
#line 3202
    t = rrset->ts + tmp___0;
#line 3203
    if (! *ttl) {
#line 3204
      *ttl = t;
    } else
#line 3203
    if (*ttl > t) {
#line 3204
      *ttl = t;
    }
#line 3205
    return (1);
  }
#line 3207
  return (0);
}
}
#line 3210 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/dns_query.c"
static void set_all_flags_ttl(unsigned short *flags , time_t *ttl , dns_cent_t *cached ) 
{ 
  int i ;
  int ilim ;
  int tmp ;
  int tmp___0 ;
  rr_set_t *rrset ;
  rr_set_t *tmp___1 ;
  time_t t ;
  time_t tmp___2 ;

  {
#line 3212
  if ((int )cached->flags & 1) {
#line 3212
    tmp___0 = 0;
  } else {
#line 3212
    if (cached->__annonCompField2.rr.rrext) {
#line 3212
      tmp = 47;
    } else {
#line 3212
      tmp = 8;
    }
#line 3212
    tmp___0 = tmp;
  }
#line 3212
  ilim = tmp___0;
#line 3214
  i = 0;
  {
#line 3214
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3214
    if (! (i < ilim)) {
#line 3214
      goto while_break;
    }
#line 3215
    if (i < 8) {
#line 3215
      tmp___1 = cached->__annonCompField2.rr.rrmu[i];
    } else {
#line 3215
      tmp___1 = *(cached->__annonCompField2.rr.rrext + (i - 8));
    }
#line 3215
    rrset = tmp___1;
#line 3216
    if (rrset) {
#line 3218
      *flags = (unsigned short )((int )*flags | (int )rrset->flags);
#line 3219
      if (rrset->ttl < 120L) {
#line 3219
        tmp___2 = (time_t )120;
      } else {
#line 3219
        tmp___2 = rrset->ttl;
      }
#line 3219
      t = rrset->ts + tmp___2;
#line 3220
      if (! *ttl) {
#line 3221
        *ttl = t;
      } else
#line 3220
      if (*ttl > t) {
#line 3221
        *ttl = t;
      }
    }
#line 3214
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 3224
  return;
}
}
#line 3235 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/dns_query.c"
static int lookup_cache_status(unsigned char const   *name , int thint , dns_cent_t **cachedp ,
                               unsigned short *flagsp , time_t queryts , unsigned char *c_soa ) 
{ 
  dns_cent_t *cached ;
  int rc ;
  int wild ;
  unsigned short flags ;
  short neg ;
  short timed ;
  short need_req ;
  time_t ttl ;
  char dflagstr[20] ;
  unsigned char _debugstrbuf[256] ;
  char *tmp ;
  unsigned char const   *tmp___0 ;
  unsigned int tmp___1 ;
  unsigned char *owner ;
  unsigned char *tmp___2 ;
  unsigned int tmp___3 ;
  unsigned char _debugstrbuf___0[256] ;
  unsigned char const   *tmp___4 ;
  time_t tmp___5 ;
  rr_set_t *tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  rr_set_t *tmp___10 ;
  char dflagstr___0[20] ;
  char cflagstr[28] ;
  time_t tmp___11 ;
  char const   *tmp___12 ;
  char *tmp___13 ;
  char *tmp___14 ;

  {
  {
#line 3239
  rc = 65530;
#line 3240
  wild = 0;
#line 3241
  flags = (unsigned short)0;
#line 3243
  cached = lookup_cache(name, & wild);
  }
#line 3243
  if (cached) {
#line 3244
    neg = (short)0;
#line 3244
    timed = (short)0;
#line 3244
    need_req = (short)0;
#line 3245
    ttl = (time_t )0;
#line 3247
    if ((int )cached->flags & 2) {
#line 3251
      if (debug_p) {
        {
#line 3251
        tmp = flags2str((unsigned int )cached->flags, dflagstr, 5, dflgnames);
#line 3251
        tmp___0 = rhn2str((unsigned char const   *)cached->qname, _debugstrbuf, (unsigned int )sizeof(_debugstrbuf));
#line 3251
        debug_msg(0, "Entry found in cache for \'%s\' with dflags=%s.\n", tmp___0,
                  tmp);
        }
      }
#line 3255
      if ((int )cached->flags & 1) {
#line 3255
        goto _L___1;
      } else
#line 3255
      if (wild == 3) {
        _L___1: /* CIL Label */ 
#line 3256
        if (c_soa) {
#line 3257
          if ((int )cached->c_soa != 255) {
#line 3258
            *c_soa = cached->c_soa;
          } else
#line 3259
          if (! ((int )cached->flags & 1)) {
#line 3259
            if (cached->__annonCompField2.rr.rrmu[3]) {
#line 3259
              if ((cached->__annonCompField2.rr.rrmu[3])->rrs) {
                {
#line 3260
                tmp___1 = rhnsegcnt((unsigned char const   *)cached->qname);
#line 3260
                *c_soa = (unsigned char )tmp___1;
                }
              } else {
#line 3259
                goto _L___0;
              }
            } else {
#line 3259
              goto _L___0;
            }
          } else {
            _L___0: /* CIL Label */ 
            {
#line 3262
            tmp___2 = getlocalowner(cached->qname, 6);
#line 3262
            owner = tmp___2;
            }
#line 3263
            if (owner) {
              {
#line 3264
              tmp___3 = rhnsegcnt((unsigned char const   *)owner);
#line 3264
              *c_soa = (unsigned char )tmp___3;
              }
            }
          }
        }
        {
#line 3267
        free_cent(cached);
#line 3268
        free((void *)cached);
#line 3269
        rc = 3;
        }
#line 3270
        goto return_rc;
      } else {
#line 3273
        rc = 0;
#line 3274
        goto return_rc_cent;
      }
    }
#line 3277
    if (debug_p) {
      {
#line 3277
      tmp___4 = rhn2str((unsigned char const   *)cached->qname, _debugstrbuf___0,
                        (unsigned int )sizeof(_debugstrbuf___0));
#line 3277
      debug_msg(0, "Record found in cache for %s\n", tmp___4);
      }
    }
#line 3278
    if ((int )cached->flags & 1) {
#line 3279
      if (cached->__annonCompField2.neg.ttl < 120L) {
#line 3279
        tmp___5 = (time_t )120;
      } else {
#line 3279
        tmp___5 = cached->__annonCompField2.neg.ttl;
      }
#line 3279
      ttl = cached->__annonCompField2.neg.ts + tmp___5;
#line 3279
      if (ttl >= queryts) {
#line 3280
        neg = (short)1;
      } else {
#line 3282
        timed = (short)1;
      }
    } else {
#line 3284
      if (thint == 255) {
        {
#line 3285
        set_all_flags_ttl(& flags, & ttl, cached);
        }
      } else {
        {
#line 3287
        tmp___9 = set_flags_ttl(& flags, & ttl, cached, 5);
        }
#line 3287
        if (tmp___9) {
#line 3287
          if (! ((int )cached->flags & 1)) {
#line 3287
            tmp___10 = cached->__annonCompField2.rr.rrmu[2];
          } else {
#line 3287
            tmp___10 = (rr_set_t *)((void *)0);
          }
#line 3287
          if ((int )tmp___10->flags & 1) {
            _L___3: /* CIL Label */ 
#line 3288
            flags = (unsigned short)0;
#line 3288
            ttl = (time_t )0;
#line 3289
            if (thint >= 1) {
#line 3289
              if (thint <= 51) {
                {
#line 3290
                tmp___8 = set_flags_ttl(& flags, & ttl, cached, thint);
                }
#line 3290
                if (tmp___8) {
                  {
#line 3291
                  tmp___6 = getrrset(cached, thint);
                  }
#line 3291
                  if ((int )tmp___6->flags & 1) {
#line 3291
                    if (ttl >= queryts) {
#line 3291
                      tmp___7 = 1;
                    } else {
#line 3291
                      tmp___7 = 0;
                    }
                  } else {
#line 3291
                    tmp___7 = 0;
                  }
#line 3291
                  neg = (short )tmp___7;
                }
              } else {
#line 3289
                goto _L___2;
              }
            } else
            _L___2: /* CIL Label */ 
#line 3293
            if (thint == 253) {
              {
#line 3294
              set_flags_ttl(& flags, & ttl, cached, 7);
#line 3295
              set_flags_ttl(& flags, & ttl, cached, 8);
#line 3296
              set_flags_ttl(& flags, & ttl, cached, 9);
              }
            } else
#line 3298
            if (thint == 254) {
              {
#line 3299
              set_flags_ttl(& flags, & ttl, cached, 3);
#line 3300
              set_flags_ttl(& flags, & ttl, cached, 4);
              }
            }
          }
        } else {
#line 3287
          goto _L___3;
        }
      }
#line 3303
      if (! ((int )flags & 2)) {
#line 3304
        if (thint == 255) {
#line 3305
          if (! ((int )cached->flags & 4)) {
#line 3306
            need_req = (short)1;
          }
        } else
#line 3308
        if (thint >= 251) {
#line 3308
          if (thint <= 255) {
#line 3309
            if ((int )flags & 4) {
#line 3309
              if (! (! ((int )flags & 16))) {
#line 3310
                need_req = (short)1;
              }
            } else {
#line 3310
              need_req = (short)1;
            }
          }
        }
#line 3312
        if (ttl < queryts) {
#line 3313
          timed = (short)1;
        }
      }
    }
#line 3319
    if (debug_p) {
#line 3319
      if (ttl) {
#line 3319
        tmp___11 = ttl - queryts;
      } else {
#line 3319
        tmp___11 = ttl;
      }
#line 3319
      if (ttl) {
#line 3319
        tmp___12 = "ttl";
      } else {
#line 3319
        tmp___12 = "timestamp";
      }
      {
#line 3319
      tmp___13 = flags2str((unsigned int )flags, cflagstr, 7, cflgnames);
#line 3319
      tmp___14 = flags2str((unsigned int )cached->flags, dflagstr___0, 5, dflgnames);
#line 3319
      debug_msg(0, "Requery decision: dflags=%s, cflags=%s, req=%i, neg=%i, timed=%i, %s=%li\n",
                tmp___14, tmp___13, (int )need_req, (int )neg, (int )timed, tmp___12,
                tmp___11);
      }
    }
#line 3324
    if (! neg) {
#line 3324
      if (need_req) {
#line 3324
        rc = 65532;
      } else
#line 3324
      if (timed) {
#line 3324
        rc = 65532;
      } else {
#line 3324
        rc = 65531;
      }
    } else {
#line 3324
      rc = 65531;
    }
    return_rc_cent: 
#line 3326
    *cachedp = cached;
  }
  return_rc: 
#line 3330
  if (flagsp) {
#line 3330
    *flagsp = flags;
  }
#line 3331
  return (rc);
}
}
#line 3340 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/dns_query.c"
static int p_dns_cached_resolve(query_stat_array q , unsigned char const   *name ,
                                int thint , dns_cent_t **cachedp , int hops , qstatnode_t *qslist ,
                                qhintnode_t *qhlist , time_t queryts , unsigned char *c_soa ) 
{ 
  dns_cent_t *cached ;
  int rc ;
  unsigned short flags ;
  unsigned char _debugstrbuf[256] ;
  char const   *tmp ;
  unsigned char const   *tmp___0 ;
  int i ;
  int n ;
  int linkdown ;
  unsigned int tmp___1 ;
  servparm_t *sp ;
  int j ;
  int m ;
  unsigned int tmp___2 ;
  dns_cent_t *ent ;

  {
#line 3344
  cached = (dns_cent_t *)((void *)0);
#line 3346
  flags = (unsigned short)0;
#line 3348
  if (debug_p) {
    {
#line 3348
    tmp = get_tname(thint);
#line 3348
    tmp___0 = rhn2str(name, _debugstrbuf, (unsigned int )sizeof(_debugstrbuf));
#line 3348
    debug_msg(0, "Starting cached resolve for: %s, query %s\n", tmp___0, tmp);
    }
  }
  {
#line 3349
  rc = lookup_cache_status(name, thint, & cached, & flags, queryts, c_soa);
  }
#line 3350
  if (rc == 0) {
#line 3352
    *cachedp = cached;
#line 3353
    return (0);
  } else
#line 3355
  if (rc == 3) {
#line 3356
    return (3);
  }
#line 3359
  if (global.onquery) {
    {
#line 3359
    test_onquery();
    }
  }
#line 3360
  if (global.lndown_kluge) {
#line 3360
    if (! ((int )flags & 2)) {
      {
#line 3361
      linkdown = 1;
#line 3362
      lock_server_data();
#line 3363
      tmp___1 = da_nel((darray )servers);
#line 3363
      n = (int )tmp___1;
#line 3364
      i = 0;
      }
      {
#line 3364
      while (1) {
        while_continue: /* CIL Label */ ;
#line 3364
        if (! (i < n)) {
#line 3364
          goto while_break;
        }
#line 3365
        sp = & servers->elem[i];
#line 3366
        if ((int )sp->rootserver <= 1) {
          {
#line 3367
          tmp___2 = da_nel((darray )sp->atup_a);
#line 3367
          m = (int )tmp___2;
#line 3368
          j = 0;
          }
          {
#line 3368
          while (1) {
            while_continue___0: /* CIL Label */ ;
#line 3368
            if (! (j < m)) {
#line 3368
              goto while_break___0;
            }
#line 3369
            if ((sp->atup_a)->elem[j].is_up) {
#line 3370
              linkdown = 0;
#line 3371
              goto done;
            }
#line 3368
            j ++;
          }
          while_break___0: /* CIL Label */ ;
          }
        }
#line 3364
        i ++;
      }
      while_break: /* CIL Label */ ;
      }
      done: 
      {
#line 3377
      unlock_server_data();
      }
#line 3378
      if (linkdown) {
#line 3379
        if (debug_p) {
          {
#line 3379
          debug_msg(0, "Link is down.\n");
          }
        }
#line 3380
        rc = 2;
#line 3381
        goto cleanup_return;
      }
    }
  }
#line 3384
  if (rc != 65531) {
#line 3386
    if (debug_p) {
      {
#line 3386
      debug_msg(0, "Trying name servers.\n");
      }
    }
#line 3387
    if (q) {
      {
#line 3388
      rc = p_recursive_query(q, name, thint, & ent, (int *)((void *)0), hops, qslist,
                             qhlist, c_soa);
      }
    } else {
      {
#line 3390
      rc = p_dns_resolve(name, thint, & ent, hops, qhlist, c_soa);
      }
    }
#line 3391
    if (rc != 0) {
#line 3392
      if (rc == 2) {
#line 3392
        if (cached) {
#line 3392
          if ((int )flags & 32) {
#line 3396
            if (debug_p) {
              {
#line 3396
              debug_msg(0, "Falling back to cached record.\n");
              }
            }
          } else {
#line 3398
            goto cleanup_return;
          }
        } else {
#line 3398
          goto cleanup_return;
        }
      } else {
#line 3398
        goto cleanup_return;
      }
    } else {
#line 3401
      if (cached) {
        {
#line 3402
        free_cent(cached);
#line 3403
        free((void *)cached);
        }
      }
#line 3405
      cached = ent;
    }
  } else
#line 3408
  if (debug_p) {
    {
#line 3408
    debug_msg(0, "Using cached record.\n");
    }
  }
#line 3410
  *cachedp = cached;
#line 3411
  return (0);
  cleanup_return: 
#line 3414
  if (cached) {
    {
#line 3415
    free_cent(cached);
#line 3416
    free((void *)cached);
    }
  }
#line 3418
  return (rc);
}
}
#line 3425 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/dns_query.c"
int r_dns_cached_resolve(unsigned char *name , int thint , dns_cent_t **cachedp ,
                         int hops , qhintnode_t *qhlist , time_t queryts , unsigned char *c_soa ) 
{ 
  dns_cent_t *cached ;
  int rc ;
  int tmp ;

  {
  {
#line 3430
  tmp = p_dns_cached_resolve((query_stat_array )((void *)0), (unsigned char const   *)name,
                             thint, & cached, hops, (qstatnode_t *)((void *)0), qhlist,
                             queryts, c_soa);
#line 3430
  rc = tmp;
  }
#line 3431
  if (rc == 0) {
#line 3432
    if ((int )cached->flags & 1) {
#line 3433
      if (c_soa) {
#line 3434
        *c_soa = cached->c_soa;
      }
      {
#line 3435
      free_cent(cached);
#line 3436
      free((void *)cached);
#line 3437
      rc = 3;
      }
    } else {
#line 3440
      *cachedp = cached;
    }
  }
#line 3442
  return (rc);
}
}
#line 3446 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/dns_query.c"
static int simple_dns_cached_resolve(atup_array atup_a , int port , char edns_query ,
                                     time_t timeout , unsigned char const   *name ,
                                     int thint , dns_cent_t **cachedp ) 
{ 
  dns_cent_t *cached ;
  int rc ;
  unsigned char _debugstrbuf[256] ;
  char const   *tmp ;
  unsigned char const   *tmp___0 ;
  time_t tmp___1 ;
  query_stat_array qserv ;
  int j ;
  int m ;
  unsigned int tmp___2 ;
  int tmp___3 ;
  dns_cent_t *tc ;

  {
#line 3449
  cached = (dns_cent_t *)((void *)0);
#line 3452
  if (debug_p) {
    {
#line 3452
    tmp = get_tname(thint);
#line 3452
    tmp___0 = rhn2str(name, _debugstrbuf, (unsigned int )sizeof(_debugstrbuf));
#line 3452
    debug_msg(0, "Starting simple cached resolve for: %s, query %s\n", tmp___0, tmp);
    }
  }
  {
#line 3453
  tmp___1 = time((time_t *)((void *)0));
#line 3453
  rc = lookup_cache_status(name, thint, & cached, (unsigned short *)((void *)0), tmp___1,
                           (unsigned char *)((void *)0));
  }
#line 3454
  if (rc == 0) {
#line 3456
    *cachedp = cached;
#line 3457
    return (0);
  } else
#line 3459
  if (rc == 3) {
#line 3460
    return (3);
  }
#line 3462
  if (rc != 65531) {
#line 3465
    if (cached) {
      {
#line 3466
      free_cent(cached);
#line 3467
      free((void *)cached);
#line 3468
      cached = (dns_cent_t *)((void *)0);
      }
    }
#line 3470
    if (debug_p) {
      {
#line 3470
      debug_msg(0, "Trying name servers.\n");
      }
    }
    {
#line 3471
    qserv = (query_stat_array )((void *)0);
#line 3472
    tmp___2 = da_nel((darray )atup_a);
#line 3472
    m = (int )tmp___2;
#line 3473
    j = 0;
    }
    {
#line 3473
    while (1) {
      while_continue: /* CIL Label */ ;
#line 3473
      if (! (j < m)) {
#line 3473
        goto while_break;
      }
      {
#line 3474
      tmp___3 = add_qserv(& qserv, & atup_a->elem[j].a, port, timeout, 0U, 0, (char)1,
                          edns_query, (char)0, (char)0, (char)1, (unsigned char const   *)((void *)0),
                          (rejectlist_t *)((void *)0));
      }
#line 3474
      if (! tmp___3) {
#line 3476
        return (2);
      }
#line 3473
      j ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 3479
    rc = p_recursive_query(qserv, name, thint, & cached, (int *)((void *)0), 0, (qstatnode_t *)((void *)0),
                           (qhintnode_t *)((void *)0), (unsigned char *)((void *)0));
#line 3480
    del_qserv(qserv);
    }
#line 3481
    if (rc == 0) {
      {
#line 3483
      add_cache(cached);
#line 3484
      tc = lookup_cache(name, (int *)((void *)0));
      }
#line 3484
      if (tc) {
        {
#line 3487
        free_cent(cached);
#line 3488
        free((void *)cached);
#line 3489
        cached = tc;
        }
      } else
#line 3491
      if (debug_p) {
        {
#line 3491
        debug_msg(0, "simple_dns_cached_resolve: merging answer with cache failed, using local cent copy.\n");
        }
      }
    } else {
#line 3494
      return (rc);
    }
  } else
#line 3496
  if (debug_p) {
    {
#line 3496
    debug_msg(0, "Using cached record.\n");
    }
  }
#line 3499
  if ((int )cached->flags & 1) {
    {
#line 3500
    free_cent(cached);
#line 3501
    free((void *)cached);
    }
#line 3502
    return (3);
  }
#line 3505
  *cachedp = cached;
#line 3506
  return (0);
}
}
#line 3513 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/dns_query.c"
int query_uptest(pdnsd_a *addr , int port , unsigned char const   *name , time_t timeout ,
                 int rep ) 
{ 
  query_stat_t qs ;
  int iter ;
  int rv ;
  time_t ts ;
  time_t tpassed ;
  time_t tmp ;
  int event ;
  struct pollfd pfd ;
  int tmp___0 ;
  time_t tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  int *tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
  {
#line 3516
  iter = 0;
#line 3520
  memset((void *)(& qs.a.sin4), 0, sizeof(qs.a.sin4));
#line 3521
  qs.a.sin4.sin_family = (sa_family_t )2;
#line 3522
  qs.a.sin4.sin_port = htons((uint16_t )port);
#line 3523
  qs.a.sin4.sin_addr = addr->ipv4;
#line 3539
  qs.timeout = timeout;
#line 3540
  qs.flags = (unsigned short)0;
#line 3541
  qs.nocache = (short)0;
#line 3542
  qs.auth_serv = (char)0;
#line 3543
  qs.lean_query = (char)1;
#line 3544
  qs.edns_query = (char)0;
#line 3545
  qs.needs_testing = (char)0;
#line 3546
  qs.trusted = (char)1;
#line 3547
  qs.aa = (char)0;
#line 3548
  qs.tc = (char)0;
#line 3549
  qs.nsdomain = (unsigned char const   *)((void *)0);
#line 3550
  qs.rejectlist = (rejectlist_t *)((void *)0);
  }
  try_again: 
  {
#line 3553
  qs.state = (short)0;
#line 3554
  qs.qm = (short )global.query_method;
#line 3555
  qs.s_errno = 0;
#line 3556
  rv = p_exec_query((dns_cent_t **)((void *)0), name, 1, & qs, (dlist *)((void *)0),
                    (unsigned char *)((void *)0));
  }
#line 3557
  if (rv == -1) {
    {
#line 3559
    ts = time((time_t *)((void *)0));
#line 3559
    tpassed = (time_t )0;
    }
    {
#line 3559
    while (1) {
      while_continue: /* CIL Label */ ;
#line 3590
      pfd.fd = qs.sock;
      {
#line 3592
      if ((int )qs.state == 5) {
#line 3592
        goto case_5;
      }
#line 3592
      if ((int )qs.state == 3) {
#line 3592
        goto case_5;
      }
#line 3595
      if ((int )qs.state == 2) {
#line 3595
        goto case_2;
      }
#line 3598
      goto switch_default;
      case_5: /* CIL Label */ 
      case_3: /* CIL Label */ 
#line 3593
      pfd.events = (short)1;
#line 3594
      goto switch_break;
      case_2: /* CIL Label */ 
#line 3596
      pfd.events = (short)4;
#line 3597
      goto switch_break;
      switch_default: /* CIL Label */ 
#line 3599
      pfd.events = (short)0;
      switch_break: /* CIL Label */ ;
      }
      {
#line 3605
      tmp___0 = is_interrupted_servstat_thread();
      }
#line 3605
      if (tmp___0) {
#line 3606
        if (debug_p) {
          {
#line 3606
          debug_msg(0, "server status thread interrupted.\n");
          }
        }
        {
#line 3607
        p_cancel_query(& qs);
        }
#line 3608
        return (0);
      }
#line 3610
      if (timeout > tpassed) {
#line 3610
        tmp___1 = (timeout - tpassed) * 1000L;
      } else {
#line 3610
        tmp___1 = (time_t )0;
      }
      {
#line 3610
      event = poll(& pfd, (nfds_t )1, (int )tmp___1);
      }
#line 3612
      if (event < 0) {
        {
#line 3613
        tmp___4 = __errno_location();
        }
#line 3613
        if (*tmp___4 == 4) {
          {
#line 3613
          tmp___5 = is_interrupted_servstat_thread();
          }
#line 3613
          if (tmp___5) {
#line 3614
            if (debug_p) {
              {
#line 3614
              debug_msg(0, "poll/select interrupted in server status thread.\n");
              }
            }
          } else {
            {
#line 3617
            tmp___2 = __errno_location();
#line 3617
            tmp___3 = strerror(*tmp___2);
#line 3617
            log_message(4, "poll/select failed: %s", tmp___3);
            }
          }
        } else {
          {
#line 3617
          tmp___2 = __errno_location();
#line 3617
          tmp___3 = strerror(*tmp___2);
#line 3617
          log_message(4, "poll/select failed: %s", tmp___3);
          }
        }
        {
#line 3618
        p_cancel_query(& qs);
        }
#line 3619
        return (0);
      }
#line 3621
      if (event == 0) {
        {
#line 3623
        p_cancel_query(& qs);
#line 3624
        iter ++;
        }
#line 3624
        if (iter < rep) {
#line 3624
          goto try_again;
        }
#line 3625
        return (0);
      }
#line 3627
      event = 0;
      {
#line 3639
      if ((int )qs.state == 5) {
#line 3639
        goto case_5___0;
      }
#line 3639
      if ((int )qs.state == 3) {
#line 3639
        goto case_5___0;
      }
#line 3642
      if ((int )qs.state == 2) {
#line 3642
        goto case_2___0;
      }
#line 3638
      goto switch_break___0;
      case_5___0: /* CIL Label */ 
      case_3___0: /* CIL Label */ 
#line 3640
      event = (int )pfd.revents & 57;
#line 3641
      goto switch_break___0;
      case_2___0: /* CIL Label */ 
#line 3643
      event = (int )pfd.revents & 60;
#line 3644
      goto switch_break___0;
      switch_break___0: /* CIL Label */ ;
      }
#line 3647
      if (event) {
        {
#line 3648
        rv = p_exec_query((dns_cent_t **)((void *)0), name, 1, & qs, (dlist *)((void *)0),
                          (unsigned char *)((void *)0));
        }
#line 3649
        if (rv != -1) {
#line 3649
          goto while_break;
        }
      } else {
#line 3652
        poll_errs += (unsigned long volatile   )1;
#line 3652
        if (poll_errs <= (unsigned long volatile   )10) {
          {
#line 3653
          log_message(3, "Unhandled poll/select event in query_uptest() at %s, line %d.",
                      "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/dns_query.c",
                      3653);
          }
        }
        {
#line 3654
        p_cancel_query(& qs);
        }
#line 3655
        return (0);
      }
      {
#line 3559
      tmp = time((time_t *)((void *)0));
#line 3559
      tpassed = tmp - ts;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 3659
  if (rv != 2) {
#line 3659
    if (rv != 65535) {
#line 3659
      tmp___6 = 1;
    } else {
#line 3659
      tmp___6 = 0;
    }
  } else {
#line 3659
    tmp___6 = 0;
  }
#line 3659
  return (tmp___6);
}
}
#line 184 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strndup)(char const   *__string ,
                                                                                                size_t __n )  __attribute__((__malloc__)) ;
#line 399 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int ( /* format attribute */  vasprintf)(char ** __restrict  __ptr ,
                                                                              char const   * __restrict  __f ,
                                                                              __gnuc_va_list __arg ) ;
#line 57 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/list.h"
__inline static unsigned int ( __attribute__((__always_inline__)) da_nel)(darray a ) ;
#line 177 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/conff.h"
cmdlineflags_t cmdline ;
#line 178
servparm_t serv_presets ;
#line 182
int read_config_file(char const   *nm , globparm_t *global___0 , servparm_array *servers___0 ,
                     int includedepth , char **errstr ) ;
#line 184
void free_zone(void *ptr ) ;
#line 185
void free_slist_domain(void *ptr ) ;
#line 187
void free_servparm(servparm_t *serv ) ;
#line 65 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/consts.h"
int binsearch_keyword(char const   *name , int len , namevalue_t const   *dic , int range ) ;
#line 66
int lookup_const(char const   *name , int len ) ;
#line 67
char const   *const_name(int c ) ;
#line 174 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/cache.h"
int add_reverse_cache(dns_cent_t *cent ) ;
#line 177
int set_cent_flags(unsigned char const   *name , unsigned int flags ) ;
#line 249
__inline static rr_set_t *( __attribute__((__always_inline__)) getrrset_eff)(dns_cent_t *cent ,
                                                                             int type ) ;
#line 60 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/helpers.h"
__inline static unsigned int ( __attribute__((__always_inline__)) rhnlen)(unsigned char const   *rhn ) ;
#line 114
__inline static int ( __attribute__((__always_inline__)) is_inaddr_any)(pdnsd_a *a ) ;
#line 115 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/helpers.h"
__inline static int ( __attribute__((__always_inline__)) is_inaddr_any)(pdnsd_a *a ) 
{ 


  {
#line 117
  return (a->ipv4.s_addr == 0U);
}
}
#line 147
__inline static int ( __attribute__((__always_inline__)) equiv_inaddr2)(pdnsd_a *a ,
                                                                        pdnsd_a2 *b ) ;
#line 117 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/conf-keywords.h"
static namevalue_t const   section_headers[6]  = {      {"global", 1}, 
        {"include", 6}, 
        {"neg", 4}, 
        {"rr", 3}, 
        {"server", 2}, 
        {"source", 5}};
#line 127 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/conf-keywords.h"
static namevalue_t const   global_options[39]  = 
#line 127
  {      {"cache_dir", 8}, 
        {"ctl_perms", 30}, 
        {"daemon", 22}, 
        {"debug", 29}, 
        {"delegation_only", 42}, 
        {"ignore_cd", 20}, 
        {"interface", 10}, 
        {"ipv4_6_prefix", 28}, 
        {"linkdown_kluge", 13}, 
        {"max_ttl", 14}, 
        {"min_ttl", 15}, 
        {"neg_domain_pol", 38}, 
        {"neg_rrs_pol", 37}, 
        {"neg_ttl", 36}, 
        {"outgoing_ip", 11}, 
        {"outside_interface", 11}, 
        {"par_queries", 34}, 
        {"paranoid", 19}, 
        {"perm_cache", 7}, 
        {"pid_file", 24}, 
        {"proc_limit", 31}, 
        {"procq_limit", 32}, 
        {"query_method", 26}, 
        {"query_port_end", 40}, 
        {"query_port_start", 39}, 
        {"randomize_recs", 35}, 
        {"run_as", 16}, 
        {"run_ipv4", 27}, 
        {"scheme_file", 12}, 
        {"server_ip", 10}, 
        {"server_port", 9}, 
        {"status_ctl", 21}, 
        {"strict_setuid", 17}, 
        {"tcp_qtimeout", 33}, 
        {"tcp_server", 23}, 
        {"timeout", 47}, 
        {"udpbufsize", 41}, 
        {"use_nss", 18}, 
        {"verbosity", 25}};
#line 170 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/conf-keywords.h"
static namevalue_t const   server_options[28]  = 
#line 170
  {      {"caching", 56}, 
        {"device", 54}, 
        {"edns_query", 58}, 
        {"exclude", 64}, 
        {"file", 81}, 
        {"include", 63}, 
        {"interface", 53}, 
        {"interval", 52}, 
        {"ip", 43}, 
        {"label", 69}, 
        {"lean_query", 57}, 
        {"ping_ip", 49}, 
        {"ping_timeout", 48}, 
        {"policy", 65}, 
        {"port", 44}, 
        {"preset", 59}, 
        {"proxy_only", 60}, 
        {"purge_cache", 55}, 
        {"query_test_name", 51}, 
        {"randomize_servers", 62}, 
        {"reject", 66}, 
        {"reject_policy", 67}, 
        {"reject_recursively", 68}, 
        {"root_server", 61}, 
        {"scheme", 45}, 
        {"timeout", 47}, 
        {"uptest", 46}, 
        {"uptest_cmd", 50}};
#line 202 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/conf-keywords.h"
static namevalue_t const   rr_options[13]  = 
#line 202
  {      {"a", 70}, 
        {"authrec", 83}, 
        {"cname", 74}, 
        {"mx", 72}, 
        {"name", 77}, 
        {"ns", 78}, 
        {"owner", 78}, 
        {"ptr", 71}, 
        {"reverse", 84}, 
        {"soa", 73}, 
        {"spf", 76}, 
        {"ttl", 79}, 
        {"txt", 75}};
#line 219 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/conf-keywords.h"
static namevalue_t const   source_options[6]  = {      {"authrec", 83}, 
        {"file", 81}, 
        {"ns", 78}, 
        {"owner", 78}, 
        {"serve_aliases", 82}, 
        {"ttl", 79}};
#line 229 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/conf-keywords.h"
static namevalue_t const   include_options[1]  = {      {"file", 81}};
#line 234 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/conf-keywords.h"
static namevalue_t const   neg_options[3]  = {      {"name", 77}, 
        {"ttl", 79}, 
        {"types", 80}};
#line 27 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/conf-parser.h"
int confparse(FILE *in , char *prestr , globparm_t *global___0 , servparm_array *servers___0 ,
              int includedepth , char **errstr ) ;
#line 54 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/conf-parser.c"
static char *report_error(char const   *conftype , unsigned int linenr , char const   *msg ) 
{ 
  char *retval ;
  int tmp ;
  int tmp___0 ;

  {
#line 57
  if (linenr) {
    {
#line 58
    tmp = asprintf((char **/* __restrict  */)(& retval), (char const   */* __restrict  */)"Error in %s (line %u): %s",
                   conftype, linenr, msg);
    }
#line 58
    if (tmp < 0) {
#line 59
      retval = (char *)((void *)0);
    }
  } else {
    {
#line 62
    tmp___0 = asprintf((char **/* __restrict  */)(& retval), (char const   */* __restrict  */)"Error in %s: %s",
                       conftype, msg);
    }
#line 62
    if (tmp___0 < 0) {
#line 63
      retval = (char *)((void *)0);
    }
  }
#line 66
  return (retval);
}
}
#line 69
static char *( /* format attribute */  report_errorf)(char const   *conftype , unsigned int linenr ,
                                                      char const   *frm  , ...) ;
#line 70 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/conf-parser.c"
static char *( /* format attribute */  report_errorf)(char const   *conftype , unsigned int linenr ,
                                                      char const   *frm  , ...) 
{ 
  char *msg ;
  char *retval ;
  int mlen ;
  va_list va ;

  {
  {
#line 74
  __builtin_va_start(va, frm);
#line 75
  mlen = vasprintf((char **/* __restrict  */)(& msg), (char const   */* __restrict  */)frm,
                   va);
#line 76
  __builtin_va_end(va);
  }
#line 77
  if (mlen < 0) {
#line 77
    return ((char *)((void *)0));
  }
  {
#line 78
  retval = report_error(conftype, linenr, (char const   *)msg);
#line 79
  free((void *)msg);
  }
#line 80
  return (retval);
}
}
#line 84 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/conf-parser.c"
static char *getnextp(char **buf , size_t *n , FILE *in , char *p , unsigned int *linenr ,
                      char **errstr ) 
{ 
  __ssize_t tmp ;
  unsigned short const   **tmp___0 ;
  int lev ;
  __ssize_t tmp___1 ;

  {
#line 86
  if (! p) {
#line 86
    goto nextline;
  }
  tryagain: 
#line 88
  if (! *p) {
    nextline: 
    {
#line 90
    while (1) {
      while_continue: /* CIL Label */ ;
#line 91
      if (! in) {
#line 92
        *errstr = (char *)((void *)0);
#line 93
        return ((char *)((void *)0));
      } else {
        {
#line 91
        tmp = getline((char **/* __restrict  */)buf, (size_t */* __restrict  */)n,
                      (FILE */* __restrict  */)in);
        }
#line 91
        if (tmp < 0L) {
#line 92
          *errstr = (char *)((void *)0);
#line 93
          return ((char *)((void *)0));
        }
      }
#line 95
      (*linenr) ++;
#line 96
      p = *buf;
#line 90
      if (! (! *p)) {
#line 90
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 99
  tmp___0 = __ctype_b_loc();
  }
#line 99
  if ((int const   )*(*tmp___0 + (int )*p) & 8192) {
#line 100
    p ++;
#line 100
    goto tryagain;
  }
#line 102
  if ((int )*p == 35) {
    skip_rest_of_line: 
#line 104
    if (*linenr) {
#line 105
      goto nextline;
    } else {
      {
#line 107
      p = strchr((char const   *)p, '\n');
      }
#line 108
      if (p) {
#line 109
        p ++;
#line 110
        goto tryagain;
      } else {
#line 113
        goto nextline;
      }
    }
  }
#line 116
  if ((int )*p == 47) {
#line 117
    if ((int )*(p + 1) == 47) {
#line 118
      goto skip_rest_of_line;
    }
#line 119
    if ((int )*(p + 1) == 42) {
#line 120
      lev = 1;
#line 121
      p += 2;
      {
#line 122
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 123
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 123
          if (! *p) {
#line 123
            goto while_break___1;
          }
#line 124
          if ((int )*p == 47) {
#line 124
            if ((int )*(p + 1) == 42) {
#line 125
              lev ++;
#line 126
              p += 2;
#line 127
              goto while_continue___1;
            } else {
#line 124
              goto _L;
            }
          } else
          _L: /* CIL Label */ 
#line 129
          if ((int )*p == 42) {
#line 129
            if ((int )*(p + 1) == 47) {
#line 130
              p += 2;
#line 131
              lev --;
#line 131
              if (lev == 0) {
#line 131
                goto tryagain;
              }
#line 132
              goto while_continue___1;
            }
          }
#line 134
          p ++;
        }
        while_break___1: /* CIL Label */ ;
        }
#line 136
        if (! in) {
#line 137
          *errstr = (char *)"comment without closing */";
#line 138
          return ((char *)((void *)0));
        } else {
          {
#line 136
          tmp___1 = getline((char **/* __restrict  */)buf, (size_t */* __restrict  */)n,
                            (FILE */* __restrict  */)in);
          }
#line 136
          if (tmp___1 < 0L) {
#line 137
            *errstr = (char *)"comment without closing */";
#line 138
            return ((char *)((void *)0));
          }
        }
#line 140
        (*linenr) ++;
#line 141
        p = *buf;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
  }
#line 146
  return (p);
}
}
#line 149 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/conf-parser.c"
static char translescapedchar(char c ) 
{ 


  {
  {
#line 152
  if ((int )c == 102) {
#line 152
    goto case_102;
  }
#line 153
  if ((int )c == 110) {
#line 153
    goto case_110;
  }
#line 154
  if ((int )c == 114) {
#line 154
    goto case_114;
  }
#line 155
  if ((int )c == 116) {
#line 155
    goto case_116;
  }
#line 156
  if ((int )c == 118) {
#line 156
    goto case_118;
  }
#line 151
  goto switch_break;
  case_102: /* CIL Label */ 
#line 152
  return ((char )'\f');
  case_110: /* CIL Label */ 
#line 153
  return ((char )'\n');
  case_114: /* CIL Label */ 
#line 154
  return ((char )'\r');
  case_116: /* CIL Label */ 
#line 155
  return ((char )'\t');
  case_118: /* CIL Label */ 
#line 156
  return ((char )'\v');
  switch_break: /* CIL Label */ ;
  }
#line 158
  return (c);
}
}
#line 186 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/conf-parser.c"
static int scan_string(char **curp , char *outbuf , unsigned int outbufsz , char **errstr ) 
{ 
  char *cur ;
  unsigned int i ;
  unsigned short const   **tmp ;

  {
#line 188
  cur = *curp;
#line 189
  i = 0U;
#line 191
  if ((int )*cur == 34) {
#line 193
    cur ++;
    {
#line 194
    while (1) {
      while_continue: /* CIL Label */ ;
#line 195
      if (! *cur) {
#line 195
        goto noclosingquote;
      }
#line 196
      if ((int )*cur == 34) {
#line 196
        goto while_break;
      }
#line 197
      if ((int )*cur == 92) {
#line 198
        cur ++;
#line 198
        if (! *cur) {
#line 198
          goto nofollowingchar;
        }
#line 199
        if (i < outbufsz) {
          {
#line 200
          *(outbuf + i) = translescapedchar(*cur);
          }
        }
      } else
#line 202
      if (i < outbufsz) {
#line 203
        *(outbuf + i) = *cur;
      }
#line 194
      i ++;
#line 194
      cur ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 205
    cur ++;
  } else {
    {
#line 209
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 209
      if (! *cur) {
#line 209
        goto while_break___0;
      }
#line 210
      if ((int )*cur == 92) {
#line 212
        cur ++;
#line 212
        if (! *cur) {
#line 212
          goto nofollowingchar;
        }
#line 213
        if (i < outbufsz) {
          {
#line 214
          *(outbuf + i) = translescapedchar(*cur);
          }
        }
      } else {
        {
#line 216
        tmp = __ctype_b_loc();
        }
#line 216
        if ((int const   )*(*tmp + (int )*cur) & 8192) {
#line 221
          goto while_break___0;
        } else
#line 216
        if ((int )*cur == 44) {
#line 221
          goto while_break___0;
        } else
#line 216
        if ((int )*cur == 59) {
#line 221
          goto while_break___0;
        } else
#line 216
        if ((int )*cur == 123) {
#line 221
          goto while_break___0;
        } else
#line 216
        if ((int )*cur == 125) {
#line 221
          goto while_break___0;
        } else
#line 216
        if ((int )*cur == 34) {
#line 221
          goto while_break___0;
        } else
#line 216
        if ((int )*cur == 35) {
#line 221
          goto while_break___0;
        } else
#line 216
        if ((int )*cur == 47) {
#line 216
          if ((int )*(cur + 1) == 47) {
#line 221
            goto while_break___0;
          } else
#line 216
          if ((int )*(cur + 1) == 42) {
#line 221
            goto while_break___0;
          } else {
#line 216
            goto _L;
          }
        } else
        _L: /* CIL Label */ 
#line 222
        if (i < outbufsz) {
#line 223
          *(outbuf + i) = *cur;
        }
      }
#line 209
      i ++;
#line 209
      cur ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 227
  if (i < outbufsz) {
#line 228
    *(outbuf + i) = (char)0;
  }
#line 229
  *curp = cur;
#line 230
  return ((int )i);
  noclosingquote: 
#line 233
  *errstr = (char *)"quoted string without closing quote";
#line 234
  return (-1);
  nofollowingchar: 
#line 236
  *errstr = (char *)"may not use backslash to escape end-of-line";
#line 237
  return (-1);
}
}
#line 249 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/conf-parser.c"
static time_t strtotime(char *nptr , char **endptr , char **errstr ) 
{ 
  time_t retval ;
  time_t t ;
  char c ;
  unsigned short const   **tmp ;
  unsigned short const   **tmp___0 ;
  unsigned short const   **tmp___1 ;

  {
#line 251
  retval = (time_t )0;
#line 254
  *errstr = (char *)((void *)0);
  {
#line 255
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 255
    tmp___1 = __ctype_b_loc();
#line 255
    c = *nptr;
    }
#line 255
    if (! ((int const   )*(*tmp___1 + (int )c) & 8)) {
#line 255
      goto while_break;
    }
    {
#line 256
    tmp = __ctype_b_loc();
    }
#line 256
    if (! ((int const   )*(*tmp + (int )c) & 2048)) {
#line 257
      *errstr = (char *)"no digits before suffix.";
#line 258
      goto while_break;
    }
    {
#line 261
    t = strtol((char const   */* __restrict  */)nptr, (char **/* __restrict  */)(& nptr),
               10);
#line 263
    tmp___0 = __ctype_b_loc();
#line 263
    c = *nptr;
    }
#line 263
    if ((int const   )*(*tmp___0 + (int )c) & 1024) {
#line 264
      if (! ((int )c == 115)) {
#line 266
        if ((int )c == 109) {
#line 267
          t *= 60L;
        } else
#line 268
        if ((int )c == 104) {
#line 269
          t *= 3600L;
        } else
#line 270
        if ((int )c == 100) {
#line 271
          t *= 86400L;
        } else
#line 272
        if ((int )c == 119) {
#line 273
          t *= 604800L;
        } else {
#line 275
          *errstr = (char *)"allowed suffixes are w,d,h,m,s.";
#line 276
          goto while_break;
        }
      }
#line 278
      nptr ++;
    }
#line 281
    retval += t;
  }
  while_break: /* CIL Label */ ;
  }
#line 284
  if (endptr) {
#line 284
    *endptr = nptr;
  }
#line 285
  return (retval);
}
}
#line 290
static char const   *parse_ip(char const   *ipstr , pdnsd_a *a ) ;
#line 291
static char const   *addr_add(atup_array *ata , char const   *ipstr ) ;
#line 293
static char const   *reject_add(servparm_t *serv , char const   *ipstr ) ;
#line 295
static void check_localaddrs(servparm_t *serv ) ;
#line 296
static int read_resolv_conf(char const   *fn , atup_array *ata , char **errstr ) ;
#line 297
static char const   *slist_add(slist_array *sla , char const   *nm , unsigned int len ,
                               int tp ) ;
#line 300
static char const   *zone_add(zone_array *za , char const   *zone , unsigned int len ) ;
#line 488 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/conf-parser.c"
int confparse(FILE *in , char *prestr , globparm_t *global___0 , servparm_array *servers___0 ,
              int includedepth , char **errstr ) 
{ 
  char *linebuf ;
  char *p ;
  char *ps ;
  char *getnextperr ;
  char *scanstrerr ;
  char const   *conftype ;
  size_t buflen ;
  unsigned int linenr ;
  int retval ;
  int sechdr ;
  int option ;
  int len ;
  char strbuf[1024] ;
  void *tmp ;
  unsigned short const   **tmp___0 ;
  char const   *tmp___1 ;
  unsigned short const   **tmp___2 ;
  pdnsd_a *ipaddrp ;
  int cnst ;
  unsigned short const   **tmp___3 ;
  unsigned short const   **tmp___4 ;
  unsigned short const   **tmp___5 ;
  char *tmp___6 ;
  long tmp___7 ;
  unsigned short const   **tmp___8 ;
  char const   *err ;
  int fd ;
  struct ifreq req ;
  int *tmp___9 ;
  char *tmp___10 ;
  int tmp___11 ;
  char const   *tmp___12 ;
  int tmp___13 ;
  char *tmp___14 ;
  char *_str ;
  size_t _len ;
  int _cnst ;
  unsigned short const   **tmp___15 ;
  unsigned short const   **tmp___16 ;
  char *_err ;
  unsigned short const   **tmp___17 ;
  char *_err___0 ;
  unsigned short const   **tmp___18 ;
  char *_str___0 ;
  size_t _len___0 ;
  int _cnst___0 ;
  unsigned short const   **tmp___19 ;
  unsigned short const   **tmp___20 ;
  char *_str___1 ;
  size_t _len___1 ;
  int _cnst___1 ;
  unsigned short const   **tmp___21 ;
  unsigned short const   **tmp___22 ;
  char *_str___2 ;
  size_t _len___2 ;
  int _cnst___2 ;
  unsigned short const   **tmp___23 ;
  unsigned short const   **tmp___24 ;
  int ignore_cd ;
  char *_str___3 ;
  size_t _len___3 ;
  int _cnst___3 ;
  unsigned short const   **tmp___25 ;
  unsigned short const   **tmp___26 ;
  int cnst___0 ;
  char *_str___4 ;
  size_t _len___4 ;
  unsigned short const   **tmp___27 ;
  unsigned short const   **tmp___28 ;
  int cnst___1 ;
  char *_str___5 ;
  size_t _len___5 ;
  unsigned short const   **tmp___29 ;
  unsigned short const   **tmp___30 ;
  int cnst___2 ;
  char *_str___6 ;
  size_t _len___6 ;
  unsigned short const   **tmp___31 ;
  unsigned short const   **tmp___32 ;
  char *tmp___33 ;
  int val ;
  long tmp___34 ;
  unsigned short const   **tmp___35 ;
  int cnst___3 ;
  char *_str___7 ;
  size_t _len___7 ;
  unsigned short const   **tmp___36 ;
  unsigned short const   **tmp___37 ;
  int cnst___4 ;
  char *_str___8 ;
  size_t _len___8 ;
  unsigned short const   **tmp___38 ;
  unsigned short const   **tmp___39 ;
  int cnst___5 ;
  char *_str___9 ;
  size_t _len___9 ;
  unsigned short const   **tmp___40 ;
  unsigned short const   **tmp___41 ;
  long tmp___42 ;
  unsigned short const   **tmp___43 ;
  long tmp___44 ;
  unsigned short const   **tmp___45 ;
  long tmp___46 ;
  unsigned short const   **tmp___47 ;
  char *_err___1 ;
  unsigned short const   **tmp___48 ;
  char *_err___2 ;
  unsigned short const   **tmp___49 ;
  int val___0 ;
  long tmp___50 ;
  unsigned short const   **tmp___51 ;
  char *_str___10 ;
  size_t _len___10 ;
  int _cnst___4 ;
  unsigned short const   **tmp___52 ;
  unsigned short const   **tmp___53 ;
  char *_err___3 ;
  unsigned short const   **tmp___54 ;
  int cnst___6 ;
  char *_str___11 ;
  size_t _len___11 ;
  unsigned short const   **tmp___55 ;
  unsigned short const   **tmp___56 ;
  int cnst___7 ;
  char *_str___12 ;
  size_t _len___12 ;
  unsigned short const   **tmp___57 ;
  unsigned short const   **tmp___58 ;
  int val___1 ;
  int cnst___8 ;
  unsigned short const   **tmp___59 ;
  long tmp___60 ;
  unsigned short const   **tmp___61 ;
  unsigned short const   **tmp___62 ;
  int val___2 ;
  long tmp___63 ;
  unsigned short const   **tmp___64 ;
  int val___3 ;
  long tmp___65 ;
  unsigned short const   **tmp___66 ;
  char const   *_err___4 ;
  unsigned short const   **tmp___67 ;
  servparm_t server ;
  char const   *tmp___68 ;
  unsigned short const   **tmp___69 ;
  char const   *_err___5 ;
  char *errmsg ;
  int tmp___70 ;
  long tmp___71 ;
  unsigned short const   **tmp___72 ;
  int cnst___9 ;
  char *_str___13 ;
  size_t _len___13 ;
  unsigned short const   **tmp___73 ;
  unsigned short const   **tmp___74 ;
  char *_err___6 ;
  unsigned short const   **tmp___75 ;
  unsigned short const   **tmp___76 ;
  char const   *err___0 ;
  int cnst___10 ;
  unsigned short const   **tmp___77 ;
  unsigned short const   **tmp___78 ;
  unsigned char tname[256] ;
  unsigned char *copy ;
  unsigned int sz ;
  char const   *_err___7 ;
  void *tmp___79 ;
  int cnst___11 ;
  unsigned short const   **tmp___80 ;
  char *err___1 ;
  unsigned short const   **tmp___81 ;
  unsigned short const   **tmp___82 ;
  char *_str___14 ;
  size_t _len___14 ;
  int _cnst___5 ;
  unsigned short const   **tmp___83 ;
  unsigned short const   **tmp___84 ;
  char *_str___15 ;
  size_t _len___15 ;
  int _cnst___6 ;
  unsigned short const   **tmp___85 ;
  unsigned short const   **tmp___86 ;
  char *_str___16 ;
  size_t _len___16 ;
  int _cnst___7 ;
  unsigned short const   **tmp___87 ;
  unsigned short const   **tmp___88 ;
  char *_str___17 ;
  size_t _len___17 ;
  int _cnst___8 ;
  unsigned short const   **tmp___89 ;
  unsigned short const   **tmp___90 ;
  char *_str___18 ;
  size_t _len___18 ;
  int _cnst___9 ;
  unsigned short const   **tmp___91 ;
  unsigned short const   **tmp___92 ;
  char *_str___19 ;
  size_t _len___19 ;
  int _cnst___10 ;
  unsigned short const   **tmp___93 ;
  unsigned short const   **tmp___94 ;
  int cnst___12 ;
  char *_str___20 ;
  size_t _len___20 ;
  unsigned short const   **tmp___95 ;
  unsigned short const   **tmp___96 ;
  char *_str___21 ;
  size_t _len___21 ;
  int _cnst___11 ;
  unsigned short const   **tmp___97 ;
  unsigned short const   **tmp___98 ;
  int cnst___13 ;
  char *_str___22 ;
  size_t _len___22 ;
  unsigned short const   **tmp___99 ;
  unsigned short const   **tmp___100 ;
  char const   *_err___8 ;
  char const   *_err___9 ;
  char const   *_err___10 ;
  int cnst___14 ;
  char *_str___23 ;
  size_t _len___23 ;
  unsigned short const   **tmp___101 ;
  unsigned short const   **tmp___102 ;
  char *_str___24 ;
  size_t _len___24 ;
  int _cnst___12 ;
  unsigned short const   **tmp___103 ;
  unsigned short const   **tmp___104 ;
  unsigned short const   **tmp___105 ;
  char const   *tmp___106 ;
  unsigned int tmp___107 ;
  unsigned int tmp___108 ;
  int j ;
  int n ;
  unsigned int tmp___109 ;
  atup_t *at ;
  servparm_array tmp___110 ;
  darray tmp___111 ;
  dns_cent_t c_cent ;
  time_t c_ttl ;
  unsigned int c_flags ;
  unsigned char reverse ;
  unsigned short const   **tmp___112 ;
  int tp ;
  char const   *tpname ;
  unsigned char c_name[256] ;
  char const   *_err___11 ;
  int tmp___113 ;
  char *_err___12 ;
  unsigned short const   **tmp___114 ;
  int cnst___15 ;
  char *_str___25 ;
  size_t _len___25 ;
  unsigned short const   **tmp___115 ;
  unsigned short const   **tmp___116 ;
  char *_str___26 ;
  size_t _len___26 ;
  int _cnst___13 ;
  unsigned short const   **tmp___117 ;
  unsigned short const   **tmp___118 ;
  unsigned int sz___0 ;
  pdnsd_ca c_a ;
  int tmp___119 ;
  int tmp___120 ;
  int tmp___121 ;
  unsigned char c_name___0[256] ;
  char const   *_err___13 ;
  unsigned int tmp___122 ;
  int tmp___123 ;
  unsigned char *cp ;
  unsigned int pref ;
  unsigned char c_mx[258] ;
  char const   *_err___14 ;
  long tmp___124 ;
  unsigned short const   **tmp___125 ;
  register uint16_t t_s ;
  register unsigned char *t_cp ;
  unsigned char *tmp___126 ;
  unsigned char *tmp___127 ;
  unsigned int tmp___128 ;
  int tmp___129 ;
  unsigned int blen ;
  unsigned int rlen ;
  unsigned char *bp ;
  uint32_t val___4 ;
  unsigned char buf[532] ;
  char const   *_err___15 ;
  char const   *_err___16 ;
  long tmp___130 ;
  unsigned short const   **tmp___131 ;
  register uint32_t t_l ;
  register unsigned char *t_cp___0 ;
  unsigned char *tmp___132 ;
  unsigned char *tmp___133 ;
  unsigned char *tmp___134 ;
  unsigned char *tmp___135 ;
  char *_err___17 ;
  time_t tmp___136 ;
  unsigned short const   **tmp___137 ;
  register uint32_t t_l___0 ;
  register unsigned char *t_cp___1 ;
  unsigned char *tmp___138 ;
  unsigned char *tmp___139 ;
  unsigned char *tmp___140 ;
  unsigned char *tmp___141 ;
  char *_err___18 ;
  time_t tmp___142 ;
  unsigned short const   **tmp___143 ;
  register uint32_t t_l___1 ;
  register unsigned char *t_cp___2 ;
  unsigned char *tmp___144 ;
  unsigned char *tmp___145 ;
  unsigned char *tmp___146 ;
  unsigned char *tmp___147 ;
  char *_err___19 ;
  time_t tmp___148 ;
  unsigned short const   **tmp___149 ;
  register uint32_t t_l___2 ;
  register unsigned char *t_cp___3 ;
  unsigned char *tmp___150 ;
  unsigned char *tmp___151 ;
  unsigned char *tmp___152 ;
  unsigned char *tmp___153 ;
  char *_err___20 ;
  time_t tmp___154 ;
  unsigned short const   **tmp___155 ;
  register uint32_t t_l___3 ;
  register unsigned char *t_cp___4 ;
  unsigned char *tmp___156 ;
  unsigned char *tmp___157 ;
  unsigned char *tmp___158 ;
  unsigned char *tmp___159 ;
  int tmp___160 ;
  unsigned char *rbuf ;
  unsigned int sz___1 ;
  unsigned int allocsz ;
  int rv ;
  unsigned char *newbuf ;
  unsigned char *cp___0 ;
  unsigned int newsz ;
  int n___0 ;
  void *tmp___161 ;
  unsigned short const   **tmp___162 ;
  unsigned char buf___0[256] ;
  int tmp___163 ;
  int tmp___164 ;
  unsigned char c_owner[256] ;
  time_t c_ttl___0 ;
  unsigned int c_flags___0 ;
  unsigned char c_aliases ;
  unsigned short const   **tmp___165 ;
  char const   *_err___21 ;
  char *_err___22 ;
  unsigned short const   **tmp___166 ;
  char *errmsg___0 ;
  int tmp___167 ;
  char *_str___27 ;
  size_t _len___27 ;
  int _cnst___14 ;
  unsigned short const   **tmp___168 ;
  unsigned short const   **tmp___169 ;
  int cnst___16 ;
  char *_str___28 ;
  size_t _len___28 ;
  unsigned short const   **tmp___170 ;
  unsigned short const   **tmp___171 ;
  unsigned short const   **tmp___172 ;
  unsigned short const   **tmp___173 ;
  char *errmsg___1 ;
  int tmp___174 ;
  int tmp___175 ;
  int tmp___176 ;
  unsigned short const   **tmp___177 ;
  unsigned char c_name___1[256] ;
  time_t c_ttl___1 ;
  unsigned char htp ;
  unsigned char hdtp ;
  unsigned short const   **tmp___178 ;
  char const   *_err___23 ;
  char *_err___24 ;
  unsigned short const   **tmp___179 ;
  int cnst___17 ;
  dns_cent_t c_cent___0 ;
  unsigned short const   **tmp___180 ;
  int tmp___181 ;
  int tmp___182 ;
  char *buf___1 ;
  unsigned long __lengthofbuf___1 ;
  void *tmp___183 ;
  rr_set_t *tmp___184 ;
  int tmp___185 ;
  unsigned short const   **tmp___186 ;
  unsigned short const   **tmp___187 ;
  unsigned short const   **tmp___188 ;
  unsigned short const   **tmp___189 ;
  unsigned short const   **tmp___190 ;
  int tmp___191 ;
  int tmp___192 ;
  char const   *tmp___193 ;
  char const   *tmp___194 ;
  int *tmp___195 ;
  char *tmp___196 ;
  int tmp___197 ;
  int tmp___198 ;

  {
#line 490
  linebuf = (char *)((void *)0);
#line 490
  getnextperr = (char *)((void *)0);
#line 490
  scanstrerr = (char *)((void *)0);
#line 492
  buflen = (size_t )256;
#line 493
  linenr = 0U;
#line 494
  retval = 0;
#line 518
  *errstr = (char *)((void *)0);
#line 519
  if (in) {
    {
#line 520
    tmp = malloc(buflen);
#line 520
    linebuf = (char *)tmp;
    }
#line 521
    if (! linebuf) {
#line 523
      return (0);
    }
#line 525
    if (global___0) {
#line 526
      conftype = "config file";
    } else {
#line 528
      conftype = "include file";
    }
  } else {
#line 531
    conftype = "config string";
  }
#line 533
  p = prestr;
  {
#line 534
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 534
    p = getnextp(& linebuf, & buflen, in, p, & linenr, & getnextperr);
    }
#line 534
    if (! p) {
#line 534
      goto while_break;
    }
    {
#line 535
    tmp___190 = __ctype_b_loc();
    }
#line 535
    if ((int const   )*(*tmp___190 + (int )*p) & 1024) {
#line 536
      ps = p;
      {
#line 536
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 536
        p ++;
#line 536
        if (*p) {
          {
#line 536
          tmp___0 = __ctype_b_loc();
          }
#line 536
          if (! ((int const   )*(*tmp___0 + (int )*p) & 8)) {
#line 536
            if (! ((int )*p == 95)) {
#line 536
              goto while_break___0;
            }
          }
        } else {
#line 536
          goto while_break___0;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 536
      len = (int )(p - ps);
#line 537
      sechdr = binsearch_keyword((char const   *)ps, len, section_headers, (int )(sizeof(section_headers) / sizeof(namevalue_t )));
      }
#line 538
      if (! sechdr) {
        {
#line 539
        *errstr = report_errorf(conftype, linenr, "invalid section header: %.*s",
                                len, ps);
        }
#line 540
        goto free_linebuf_return;
      }
      {
#line 542
      p = getnextp(& linebuf, & buflen, in, p, & linenr, & getnextperr);
      }
#line 542
      if (! p) {
#line 542
        goto unexpected_eof;
      }
#line 543
      if ((int )*p != 123) {
#line 543
        goto expected_bropen;
      }
      {
#line 544
      p ++;
#line 545
      p = getnextp(& linebuf, & buflen, in, p, & linenr, & getnextperr);
      }
#line 545
      if (! p) {
#line 545
        goto unexpected_eof;
      }
      {
#line 548
      if (sechdr == 1) {
#line 548
        goto case_1;
      }
#line 948
      if (sechdr == 2) {
#line 948
        goto case_2;
      }
#line 1234
      if (sechdr == 3) {
#line 1234
        goto case_3;
      }
#line 1514
      if (sechdr == 5) {
#line 1514
        goto case_5;
      }
#line 1586
      if (sechdr == 6) {
#line 1586
        goto case_6;
      }
#line 1639
      if (sechdr == 4) {
#line 1639
        goto case_4;
      }
#line 1752
      goto switch_default___5;
      case_1: /* CIL Label */ 
#line 549
      if (! global___0) {
#line 550
        if (in) {
#line 550
          tmp___1 = "global section not allowed in include file";
        } else {
#line 550
          tmp___1 = "global section not allowed in eval string";
        }
        {
#line 550
        *errstr = report_error(conftype, linenr, tmp___1);
        }
#line 552
        goto free_linebuf_return;
      }
      {
#line 555
      while (1) {
        while_continue___1: /* CIL Label */ ;
        {
#line 555
        tmp___67 = __ctype_b_loc();
        }
#line 555
        if (! ((int const   )*(*tmp___67 + (int )*p) & 1024)) {
#line 555
          goto while_break___1;
        }
#line 556
        ps = p;
        {
#line 556
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 556
          p ++;
#line 556
          if (*p) {
            {
#line 556
            tmp___2 = __ctype_b_loc();
            }
#line 556
            if (! ((int const   )*(*tmp___2 + (int )*p) & 8)) {
#line 556
              if (! ((int )*p == 95)) {
#line 556
                goto while_break___2;
              }
            }
          } else {
#line 556
            goto while_break___2;
          }
        }
        while_break___2: /* CIL Label */ ;
        }
        {
#line 556
        len = (int )(p - ps);
#line 557
        option = binsearch_keyword((char const   *)ps, len, global_options, (int )(sizeof(global_options) / sizeof(namevalue_t )));
        }
#line 558
        if (! option) {
          {
#line 559
          *errstr = report_errorf(conftype, linenr, "invalid option for global section: %.*s",
                                  len, ps);
          }
#line 560
          goto free_linebuf_return;
        }
        {
#line 562
        p = getnextp(& linebuf, & buflen, in, p, & linenr, & getnextperr);
        }
#line 562
        if (! p) {
#line 562
          goto unexpected_eof;
        }
#line 563
        if ((int )*p != 61) {
#line 563
          goto expected_equals;
        }
        {
#line 564
        p ++;
#line 565
        p = getnextp(& linebuf, & buflen, in, p, & linenr, & getnextperr);
        }
#line 565
        if (! p) {
#line 565
          goto unexpected_eof;
        }
        {
#line 570
        if (option == 7) {
#line 570
          goto case_7;
        }
#line 591
        if (option == 8) {
#line 591
          goto case_8;
        }
#line 596
        if (option == 9) {
#line 596
          goto case_9;
        }
#line 600
        if (option == 11) {
#line 600
          goto case_11;
        }
#line 604
        if (option == 10) {
#line 604
          goto case_10;
        }
#line 650
        if (option == 12) {
#line 650
          goto case_12;
        }
#line 655
        if (option == 13) {
#line 655
          goto case_13;
        }
#line 659
        if (option == 14) {
#line 659
          goto case_14;
        }
#line 663
        if (option == 15) {
#line 663
          goto case_15;
        }
#line 667
        if (option == 16) {
#line 667
          goto case_16;
        }
#line 672
        if (option == 17) {
#line 672
          goto case_17;
        }
#line 676
        if (option == 18) {
#line 676
          goto case_18;
        }
#line 680
        if (option == 19) {
#line 680
          goto case_19;
        }
#line 684
        if (option == 20) {
#line 684
          goto case_20;
        }
#line 691
        if (option == 21) {
#line 691
          goto case_21;
        }
#line 698
        if (option == 22) {
#line 698
          goto case_22;
        }
#line 705
        if (option == 23) {
#line 705
          goto case_23;
        }
#line 720
        if (option == 24) {
#line 720
          goto case_24;
        }
#line 725
        if (option == 25) {
#line 725
          goto case_25;
        }
#line 732
        if (option == 26) {
#line 732
          goto case_26;
        }
#line 764
        if (option == 27) {
#line 764
          goto case_27;
        }
#line 793
        if (option == 28) {
#line 793
          goto case_28;
        }
#line 807
        if (option == 29) {
#line 807
          goto case_29;
        }
#line 820
        if (option == 30) {
#line 820
          goto case_30;
        }
#line 824
        if (option == 31) {
#line 824
          goto case_31;
        }
#line 828
        if (option == 32) {
#line 828
          goto case_32;
        }
#line 832
        if (option == 33) {
#line 832
          goto case_33;
        }
#line 836
        if (option == 47) {
#line 836
          goto case_47;
        }
#line 840
        if (option == 34) {
#line 840
          goto case_34;
        }
#line 852
        if (option == 35) {
#line 852
          goto case_35;
        }
#line 856
        if (option == 36) {
#line 856
          goto case_36;
        }
#line 860
        if (option == 37) {
#line 860
          goto case_37;
        }
#line 868
        if (option == 38) {
#line 868
          goto case_38;
        }
#line 875
        if (option == 39) {
#line 875
          goto case_39;
        }
#line 905
        if (option == 40) {
#line 905
          goto case_40;
        }
#line 916
        if (option == 41) {
#line 916
          goto case_41;
        }
#line 927
        if (option == 42) {
#line 927
          goto case_42;
        }
#line 931
        goto switch_default;
        case_7: /* CIL Label */ 
        {
#line 571
        tmp___5 = __ctype_b_loc();
        }
#line 571
        if ((int const   )*(*tmp___5 + (int )*p) & 1024) {
#line 573
          ps = p;
          {
#line 573
          while (1) {
            while_continue___3: /* CIL Label */ ;
#line 573
            p ++;
#line 573
            if (*p) {
              {
#line 573
              tmp___3 = __ctype_b_loc();
              }
#line 573
              if (! ((int const   )*(*tmp___3 + (int )*p) & 8)) {
#line 573
                if (! ((int )*p == 95)) {
#line 573
                  goto while_break___3;
                }
              }
            } else {
#line 573
              goto while_break___3;
            }
          }
          while_break___3: /* CIL Label */ ;
          }
          {
#line 573
          len = (int )(p - ps);
#line 574
          cnst = lookup_const((char const   *)ps, len);
          }
#line 575
          if (cnst == 2) {
#line 576
            global___0->perm_cache = 0L;
          } else {
#line 579
            goto bad_perm_cache_option;
          }
        } else {
          {
#line 581
          tmp___4 = __ctype_b_loc();
          }
#line 581
          if ((int const   )*(*tmp___4 + (int )*p) & 2048) {
            {
#line 582
            global___0->perm_cache = strtol((char const   */* __restrict  */)p, (char **/* __restrict  */)(& p),
                                            0);
            }
          } else {
            bad_perm_cache_option: 
            {
#line 586
            *errstr = report_error(conftype, linenr, "bad qualifier in perm_cache= option.");
            }
#line 587
            goto free_linebuf_return;
          }
        }
#line 589
        goto switch_break___0;
        case_8: /* CIL Label */ 
        {
#line 592
        len = scan_string(& p, strbuf, (unsigned int )sizeof(strbuf), & scanstrerr);
        }
#line 592
        if (len == -1) {
#line 592
          goto string_err;
        } else
#line 592
        if ((unsigned long )len >= sizeof(strbuf)) {
#line 592
          goto string_too_long;
        }
#line 593
        if (global___0->cache_dir) {
          {
#line 593
          free((void *)global___0->cache_dir);
          }
        }
        {
#line 593
        tmp___6 = strndup((char const   *)(strbuf), (size_t )len);
#line 593
        global___0->cache_dir = tmp___6;
        }
#line 593
        if (! tmp___6) {
#line 593
          goto out_of_memory;
        }
#line 594
        goto switch_break___0;
        case_9: /* CIL Label */ 
        {
#line 597
        tmp___8 = __ctype_b_loc();
        }
#line 597
        if ((int const   )*(*tmp___8 + (int )*p) & 2048) {
          {
#line 597
          tmp___7 = strtol((char const   */* __restrict  */)p, (char **/* __restrict  */)(& p),
                           0);
#line 597
          global___0->port = (int )tmp___7;
          }
        } else {
          {
#line 597
          *errstr = report_error(conftype, linenr, "expected unsigned integer value for server_port option");
          }
#line 597
          goto free_linebuf_return;
        }
#line 598
        goto switch_break___0;
        case_11: /* CIL Label */ 
#line 601
        ipaddrp = & global___0->out_a;
#line 602
        goto scan_ip_or_interface;
        case_10: /* CIL Label */ 
#line 605
        ipaddrp = & global___0->a;
        scan_ip_or_interface: 
        {
#line 607
        len = scan_string(& p, strbuf, (unsigned int )sizeof(strbuf), & scanstrerr);
        }
#line 607
        if (len == -1) {
#line 607
          goto string_err;
        } else
#line 607
        if ((unsigned long )len >= sizeof(strbuf)) {
#line 607
          goto string_too_long;
        }
        {
#line 610
        err = parse_ip((char const   *)(strbuf), ipaddrp);
        }
#line 610
        if (err) {
          {
#line 612
          tmp___13 = strcmp(err, "bad IP address");
          }
#line 612
          if (tmp___13) {
            _L___0: /* CIL Label */ 
#line 643
            if (option == 10) {
#line 643
              tmp___12 = "server_ip";
            } else {
#line 643
              tmp___12 = "outgoing_ip";
            }
            {
#line 643
            *errstr = report_errorf(conftype, linenr, "%s for the %s= option.", err,
                                    tmp___12);
            }
#line 644
            goto free_linebuf_return;
          } else
#line 612
          if (len < 16) {
            {
#line 618
            memcpy((void */* __restrict  */)(req.ifr_ifrn.ifrn_name), (void const   */* __restrict  */)(strbuf),
                   (size_t )len);
#line 619
            req.ifr_ifrn.ifrn_name[len] = (char)0;
#line 620
            req.ifr_ifru.ifru_addr.sa_family = (sa_family_t )2;
#line 623
            fd = socket(2, 2, 0);
            }
#line 623
            if (fd != -1) {
              {
#line 623
              tmp___11 = ioctl(fd, 35093UL, & req);
              }
#line 623
              if (tmp___11 != -1) {
                {
#line 626
                ipaddrp->ipv4 = ((struct sockaddr_in *)(& req.ifr_ifru.ifru_addr))->sin_addr;
#line 632
                close(fd);
                }
              } else {
#line 623
                goto _L;
              }
            } else {
              _L: /* CIL Label */ 
              {
#line 635
              tmp___9 = __errno_location();
#line 635
              tmp___10 = strerror(*tmp___9);
#line 635
              *errstr = report_errorf(conftype, linenr, "Failed to get IP address of %s: %s",
                                      req.ifr_ifrn.ifrn_name, tmp___10);
              }
#line 636
              if (fd != -1) {
                {
#line 636
                close(fd);
                }
              }
#line 637
              goto free_linebuf_return;
            }
          } else {
#line 612
            goto _L___0;
          }
        }
#line 648
        goto switch_break___0;
        case_12: /* CIL Label */ 
        {
#line 651
        len = scan_string(& p, strbuf, (unsigned int )sizeof(strbuf), & scanstrerr);
        }
#line 651
        if (len == -1) {
#line 651
          goto string_err;
        } else
#line 651
        if ((unsigned long )len >= sizeof(strbuf)) {
#line 651
          goto string_too_long;
        }
#line 652
        if (global___0->scheme_file) {
          {
#line 652
          free((void *)global___0->scheme_file);
          }
        }
        {
#line 652
        tmp___14 = strndup((char const   *)(strbuf), (size_t )len);
#line 652
        global___0->scheme_file = tmp___14;
        }
#line 652
        if (! tmp___14) {
#line 652
          goto out_of_memory;
        }
#line 653
        goto switch_break___0;
        case_13: /* CIL Label */ 
        {
#line 656
        tmp___16 = __ctype_b_loc();
        }
#line 656
        if ((int const   )*(*tmp___16 + (int )*p) & 1024) {
#line 656
          _str = p;
          {
#line 656
          while (1) {
            while_continue___4: /* CIL Label */ ;
#line 656
            p ++;
#line 656
            if (*p) {
              {
#line 656
              tmp___15 = __ctype_b_loc();
              }
#line 656
              if (! ((int const   )*(*tmp___15 + (int )*p) & 8)) {
#line 656
                if (! ((int )*p == 95)) {
#line 656
                  goto while_break___4;
                }
              }
            } else {
#line 656
              goto while_break___4;
            }
          }
          while_break___4: /* CIL Label */ ;
          }
          {
#line 656
          _len = (size_t )(p - _str);
#line 656
          _cnst = lookup_const((char const   *)_str, (int )_len);
          }
#line 656
          if (_cnst == 1) {
#line 656
            global___0->lndown_kluge = (char )(_cnst == 1);
          } else
#line 656
          if (_cnst == 2) {
#line 656
            global___0->lndown_kluge = (char )(_cnst == 1);
          } else {
#line 656
            goto ASSIGN_ON_OFF_656;
          }
        } else {
          ASSIGN_ON_OFF_656: 
          {
#line 656
          *errstr = report_error(conftype, linenr, "bad qualifier in linkdown_kluge= option.");
          }
#line 656
          goto free_linebuf_return;
        }
#line 657
        goto switch_break___0;
        case_14: /* CIL Label */ 
        {
#line 660
        tmp___17 = __ctype_b_loc();
        }
#line 660
        if ((int const   )*(*tmp___17 + (int )*p) & 2048) {
          {
#line 660
          global___0->max_ttl = strtotime(p, & p, & _err);
          }
#line 660
          if (_err) {
            {
#line 660
            *errstr = report_errorf(conftype, linenr, "invalid time specification for %s: %s",
                                    "max_ttl option", _err);
            }
#line 660
            goto free_linebuf_return;
          }
        } else {
          {
#line 660
          *errstr = report_error(conftype, linenr, "expected a time specification for max_ttl option");
          }
#line 660
          goto free_linebuf_return;
        }
#line 661
        goto switch_break___0;
        case_15: /* CIL Label */ 
        {
#line 664
        tmp___18 = __ctype_b_loc();
        }
#line 664
        if ((int const   )*(*tmp___18 + (int )*p) & 2048) {
          {
#line 664
          global___0->min_ttl = strtotime(p, & p, & _err___0);
          }
#line 664
          if (_err___0) {
            {
#line 664
            *errstr = report_errorf(conftype, linenr, "invalid time specification for %s: %s",
                                    "min_ttl option", _err___0);
            }
#line 664
            goto free_linebuf_return;
          }
        } else {
          {
#line 664
          *errstr = report_error(conftype, linenr, "expected a time specification for min_ttl option");
          }
#line 664
          goto free_linebuf_return;
        }
#line 665
        goto switch_break___0;
        case_16: /* CIL Label */ 
        {
#line 668
        len = scan_string(& p, strbuf, (unsigned int )sizeof(strbuf), & scanstrerr);
        }
#line 668
        if (len == -1) {
#line 668
          goto string_err;
        } else
#line 668
        if ((unsigned long )len >= sizeof(strbuf)) {
#line 668
          goto string_too_long;
        }
#line 669
        if ((unsigned long )len < sizeof(global___0->run_as)) {
          {
#line 669
          memcpy((void */* __restrict  */)(global___0->run_as), (void const   */* __restrict  */)(strbuf),
                 (size_t )len);
#line 669
          global___0->run_as[len] = (char)0;
          }
        } else {
          {
#line 669
          *errstr = report_error(conftype, linenr, "run_as: string too long");
          }
#line 669
          goto free_linebuf_return;
        }
#line 670
        goto switch_break___0;
        case_17: /* CIL Label */ 
        {
#line 673
        tmp___20 = __ctype_b_loc();
        }
#line 673
        if ((int const   )*(*tmp___20 + (int )*p) & 1024) {
#line 673
          _str___0 = p;
          {
#line 673
          while (1) {
            while_continue___5: /* CIL Label */ ;
#line 673
            p ++;
#line 673
            if (*p) {
              {
#line 673
              tmp___19 = __ctype_b_loc();
              }
#line 673
              if (! ((int const   )*(*tmp___19 + (int )*p) & 8)) {
#line 673
                if (! ((int )*p == 95)) {
#line 673
                  goto while_break___5;
                }
              }
            } else {
#line 673
              goto while_break___5;
            }
          }
          while_break___5: /* CIL Label */ ;
          }
          {
#line 673
          _len___0 = (size_t )(p - _str___0);
#line 673
          _cnst___0 = lookup_const((char const   *)_str___0, (int )_len___0);
          }
#line 673
          if (_cnst___0 == 1) {
#line 673
            global___0->strict_suid = (char )(_cnst___0 == 1);
          } else
#line 673
          if (_cnst___0 == 2) {
#line 673
            global___0->strict_suid = (char )(_cnst___0 == 1);
          } else {
#line 673
            goto ASSIGN_ON_OFF_673;
          }
        } else {
          ASSIGN_ON_OFF_673: 
          {
#line 673
          *errstr = report_error(conftype, linenr, "bad qualifier in strict_setuid= option.");
          }
#line 673
          goto free_linebuf_return;
        }
#line 674
        goto switch_break___0;
        case_18: /* CIL Label */ 
        {
#line 677
        tmp___22 = __ctype_b_loc();
        }
#line 677
        if ((int const   )*(*tmp___22 + (int )*p) & 1024) {
#line 677
          _str___1 = p;
          {
#line 677
          while (1) {
            while_continue___6: /* CIL Label */ ;
#line 677
            p ++;
#line 677
            if (*p) {
              {
#line 677
              tmp___21 = __ctype_b_loc();
              }
#line 677
              if (! ((int const   )*(*tmp___21 + (int )*p) & 8)) {
#line 677
                if (! ((int )*p == 95)) {
#line 677
                  goto while_break___6;
                }
              }
            } else {
#line 677
              goto while_break___6;
            }
          }
          while_break___6: /* CIL Label */ ;
          }
          {
#line 677
          _len___1 = (size_t )(p - _str___1);
#line 677
          _cnst___1 = lookup_const((char const   *)_str___1, (int )_len___1);
          }
#line 677
          if (_cnst___1 == 1) {
#line 677
            global___0->use_nss = (char )(_cnst___1 == 1);
          } else
#line 677
          if (_cnst___1 == 2) {
#line 677
            global___0->use_nss = (char )(_cnst___1 == 1);
          } else {
#line 677
            goto ASSIGN_ON_OFF_677;
          }
        } else {
          ASSIGN_ON_OFF_677: 
          {
#line 677
          *errstr = report_error(conftype, linenr, "bad qualifier in use_nss= option.");
          }
#line 677
          goto free_linebuf_return;
        }
#line 678
        goto switch_break___0;
        case_19: /* CIL Label */ 
        {
#line 681
        tmp___24 = __ctype_b_loc();
        }
#line 681
        if ((int const   )*(*tmp___24 + (int )*p) & 1024) {
#line 681
          _str___2 = p;
          {
#line 681
          while (1) {
            while_continue___7: /* CIL Label */ ;
#line 681
            p ++;
#line 681
            if (*p) {
              {
#line 681
              tmp___23 = __ctype_b_loc();
              }
#line 681
              if (! ((int const   )*(*tmp___23 + (int )*p) & 8)) {
#line 681
                if (! ((int )*p == 95)) {
#line 681
                  goto while_break___7;
                }
              }
            } else {
#line 681
              goto while_break___7;
            }
          }
          while_break___7: /* CIL Label */ ;
          }
          {
#line 681
          _len___2 = (size_t )(p - _str___2);
#line 681
          _cnst___2 = lookup_const((char const   *)_str___2, (int )_len___2);
          }
#line 681
          if (_cnst___2 == 1) {
#line 681
            global___0->paranoid = (char )(_cnst___2 == 1);
          } else
#line 681
          if (_cnst___2 == 2) {
#line 681
            global___0->paranoid = (char )(_cnst___2 == 1);
          } else {
#line 681
            goto ASSIGN_ON_OFF_681;
          }
        } else {
          ASSIGN_ON_OFF_681: 
          {
#line 681
          *errstr = report_error(conftype, linenr, "bad qualifier in paranoid= option.");
          }
#line 681
          goto free_linebuf_return;
        }
#line 682
        goto switch_break___0;
        case_20: /* CIL Label */ 
        {
#line 686
        tmp___26 = __ctype_b_loc();
        }
#line 686
        if ((int const   )*(*tmp___26 + (int )*p) & 1024) {
#line 686
          _str___3 = p;
          {
#line 686
          while (1) {
            while_continue___8: /* CIL Label */ ;
#line 686
            p ++;
#line 686
            if (*p) {
              {
#line 686
              tmp___25 = __ctype_b_loc();
              }
#line 686
              if (! ((int const   )*(*tmp___25 + (int )*p) & 8)) {
#line 686
                if (! ((int )*p == 95)) {
#line 686
                  goto while_break___8;
                }
              }
            } else {
#line 686
              goto while_break___8;
            }
          }
          while_break___8: /* CIL Label */ ;
          }
          {
#line 686
          _len___3 = (size_t )(p - _str___3);
#line 686
          _cnst___3 = lookup_const((char const   *)_str___3, (int )_len___3);
          }
#line 686
          if (_cnst___3 == 1) {
#line 686
            ignore_cd = _cnst___3 == 1;
          } else
#line 686
          if (_cnst___3 == 2) {
#line 686
            ignore_cd = _cnst___3 == 1;
          } else {
#line 686
            goto ASSIGN_ON_OFF_686;
          }
        } else {
          ASSIGN_ON_OFF_686: 
          {
#line 686
          *errstr = report_error(conftype, linenr, "bad qualifier in ignore_cd= option.");
          }
#line 686
          goto free_linebuf_return;
        }
        {
#line 687
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Warning: ignore_cd option in configuration file is obsolete and currently has no effect.\n");
        }
#line 689
        goto switch_break___0;
        case_21: /* CIL Label */ 
        {
#line 693
        tmp___28 = __ctype_b_loc();
        }
#line 693
        if ((int const   )*(*tmp___28 + (int )*p) & 1024) {
#line 693
          _str___4 = p;
          {
#line 693
          while (1) {
            while_continue___9: /* CIL Label */ ;
#line 693
            p ++;
#line 693
            if (*p) {
              {
#line 693
              tmp___27 = __ctype_b_loc();
              }
#line 693
              if (! ((int const   )*(*tmp___27 + (int )*p) & 8)) {
#line 693
                if (! ((int )*p == 95)) {
#line 693
                  goto while_break___9;
                }
              }
            } else {
#line 693
              goto while_break___9;
            }
          }
          while_break___9: /* CIL Label */ ;
          }
          {
#line 693
          _len___4 = (size_t )(p - _str___4);
#line 693
          cnst___0 = lookup_const((char const   *)_str___4, (int )_len___4);
          }
#line 693
          if (! (cnst___0 == 1)) {
#line 693
            if (! (cnst___0 == 2)) {
#line 693
              goto ASSIGN_CONST_693;
            }
          }
        } else {
          ASSIGN_CONST_693: 
          {
#line 693
          *errstr = report_error(conftype, linenr, "bad qualifier in status_pipe= option.");
          }
#line 693
          goto free_linebuf_return;
        }
#line 694
        if (! cmdline.stat_pipe) {
#line 694
          global___0->stat_pipe = (char )(cnst___0 == 1);
        }
#line 696
        goto switch_break___0;
        case_22: /* CIL Label */ 
        {
#line 700
        tmp___30 = __ctype_b_loc();
        }
#line 700
        if ((int const   )*(*tmp___30 + (int )*p) & 1024) {
#line 700
          _str___5 = p;
          {
#line 700
          while (1) {
            while_continue___10: /* CIL Label */ ;
#line 700
            p ++;
#line 700
            if (*p) {
              {
#line 700
              tmp___29 = __ctype_b_loc();
              }
#line 700
              if (! ((int const   )*(*tmp___29 + (int )*p) & 8)) {
#line 700
                if (! ((int )*p == 95)) {
#line 700
                  goto while_break___10;
                }
              }
            } else {
#line 700
              goto while_break___10;
            }
          }
          while_break___10: /* CIL Label */ ;
          }
          {
#line 700
          _len___5 = (size_t )(p - _str___5);
#line 700
          cnst___1 = lookup_const((char const   *)_str___5, (int )_len___5);
          }
#line 700
          if (! (cnst___1 == 1)) {
#line 700
            if (! (cnst___1 == 2)) {
#line 700
              goto ASSIGN_CONST_700;
            }
          }
        } else {
          ASSIGN_CONST_700: 
          {
#line 700
          *errstr = report_error(conftype, linenr, "bad qualifier in daemon= option.");
          }
#line 700
          goto free_linebuf_return;
        }
#line 701
        if (! cmdline.daemon) {
#line 701
          global___0->daemon = (char )(cnst___1 == 1);
        }
#line 703
        goto switch_break___0;
        case_23: /* CIL Label */ 
        {
#line 707
        tmp___32 = __ctype_b_loc();
        }
#line 707
        if ((int const   )*(*tmp___32 + (int )*p) & 1024) {
#line 707
          _str___6 = p;
          {
#line 707
          while (1) {
            while_continue___11: /* CIL Label */ ;
#line 707
            p ++;
#line 707
            if (*p) {
              {
#line 707
              tmp___31 = __ctype_b_loc();
              }
#line 707
              if (! ((int const   )*(*tmp___31 + (int )*p) & 8)) {
#line 707
                if (! ((int )*p == 95)) {
#line 707
                  goto while_break___11;
                }
              }
            } else {
#line 707
              goto while_break___11;
            }
          }
          while_break___11: /* CIL Label */ ;
          }
          {
#line 707
          _len___6 = (size_t )(p - _str___6);
#line 707
          cnst___2 = lookup_const((char const   *)_str___6, (int )_len___6);
          }
#line 707
          if (! (cnst___2 == 1)) {
#line 707
            if (! (cnst___2 == 2)) {
#line 707
              goto ASSIGN_CONST_707;
            }
          }
        } else {
          ASSIGN_CONST_707: 
          {
#line 707
          *errstr = report_error(conftype, linenr, "bad qualifier in tcp_server= option.");
          }
#line 707
          goto free_linebuf_return;
        }
#line 708
        if (! cmdline.notcp) {
#line 709
          global___0->notcp = (char )(cnst___2 == 2);
        }
#line 718
        goto switch_break___0;
        case_24: /* CIL Label */ 
        {
#line 721
        len = scan_string(& p, strbuf, (unsigned int )sizeof(strbuf), & scanstrerr);
        }
#line 721
        if (len == -1) {
#line 721
          goto string_err;
        } else
#line 721
        if ((unsigned long )len >= sizeof(strbuf)) {
#line 721
          goto string_too_long;
        }
#line 722
        if (! cmdline.pidfile) {
#line 722
          if (global___0->pidfile) {
            {
#line 722
            free((void *)global___0->pidfile);
            }
          }
          {
#line 722
          tmp___33 = strndup((char const   *)(strbuf), (size_t )len);
#line 722
          global___0->pidfile = tmp___33;
          }
#line 722
          if (! tmp___33) {
#line 722
            goto out_of_memory;
          }
        }
#line 723
        goto switch_break___0;
        case_25: /* CIL Label */ 
        {
#line 727
        tmp___35 = __ctype_b_loc();
        }
#line 727
        if ((int const   )*(*tmp___35 + (int )*p) & 2048) {
          {
#line 727
          tmp___34 = strtol((char const   */* __restrict  */)p, (char **/* __restrict  */)(& p),
                            0);
#line 727
          val = (int )tmp___34;
          }
        } else {
          {
#line 727
          *errstr = report_error(conftype, linenr, "expected unsigned integer value for verbosity option");
          }
#line 727
          goto free_linebuf_return;
        }
#line 728
        if (! cmdline.verbosity) {
#line 728
          global___0->verbosity = (short )val;
        }
#line 730
        goto switch_break___0;
        case_26: /* CIL Label */ 
        {
#line 734
        tmp___37 = __ctype_b_loc();
        }
#line 734
        if ((int const   )*(*tmp___37 + (int )*p) & 1024) {
#line 734
          _str___7 = p;
          {
#line 734
          while (1) {
            while_continue___12: /* CIL Label */ ;
#line 734
            p ++;
#line 734
            if (*p) {
              {
#line 734
              tmp___36 = __ctype_b_loc();
              }
#line 734
              if (! ((int const   )*(*tmp___36 + (int )*p) & 8)) {
#line 734
                if (! ((int )*p == 95)) {
#line 734
                  goto while_break___12;
                }
              }
            } else {
#line 734
              goto while_break___12;
            }
          }
          while_break___12: /* CIL Label */ ;
          }
          {
#line 734
          _len___7 = (size_t )(p - _str___7);
#line 734
          cnst___3 = lookup_const((char const   *)_str___7, (int )_len___7);
          }
#line 734
          if (! (cnst___3 == 13)) {
#line 734
            if (! (cnst___3 == 12)) {
#line 734
              if (! (cnst___3 == 14)) {
#line 734
                if (! (cnst___3 == 15)) {
#line 734
                  goto ASSIGN_CONST_734;
                }
              }
            }
          }
        } else {
          ASSIGN_CONST_734: 
          {
#line 734
          *errstr = report_error(conftype, linenr, "bad qualifier in query_method= option.");
          }
#line 734
          goto free_linebuf_return;
        }
#line 760
        if (! cmdline.query_method) {
#line 760
          global___0->query_method = cnst___3;
        }
#line 762
        goto switch_break___0;
        case_27: /* CIL Label */ 
        {
#line 766
        tmp___39 = __ctype_b_loc();
        }
#line 766
        if ((int const   )*(*tmp___39 + (int )*p) & 1024) {
#line 766
          _str___8 = p;
          {
#line 766
          while (1) {
            while_continue___13: /* CIL Label */ ;
#line 766
            p ++;
#line 766
            if (*p) {
              {
#line 766
              tmp___38 = __ctype_b_loc();
              }
#line 766
              if (! ((int const   )*(*tmp___38 + (int )*p) & 8)) {
#line 766
                if (! ((int )*p == 95)) {
#line 766
                  goto while_break___13;
                }
              }
            } else {
#line 766
              goto while_break___13;
            }
          }
          while_break___13: /* CIL Label */ ;
          }
          {
#line 766
          _len___8 = (size_t )(p - _str___8);
#line 766
          cnst___4 = lookup_const((char const   *)_str___8, (int )_len___8);
          }
#line 766
          if (! (cnst___4 == 1)) {
#line 766
            if (! (cnst___4 == 2)) {
#line 766
              goto ASSIGN_CONST_766;
            }
          }
        } else {
          ASSIGN_CONST_766: 
          {
#line 766
          *errstr = report_error(conftype, linenr, "bad qualifier in run_ipv4= option.");
          }
#line 766
          goto free_linebuf_return;
        }
#line 774
        if (cnst___4 == 2) {
          {
#line 775
          *errstr = report_error(conftype, linenr, "You can only set run_ipv4=off when pdnsd is compiled with IPv6 support.");
          }
#line 776
          goto free_linebuf_return;
        }
#line 791
        goto switch_break___0;
        case_28: /* CIL Label */ 
        {
#line 794
        len = scan_string(& p, strbuf, (unsigned int )sizeof(strbuf), & scanstrerr);
        }
#line 794
        if (len == -1) {
#line 794
          goto string_err;
        } else
#line 794
        if ((unsigned long )len >= sizeof(strbuf)) {
#line 794
          goto string_too_long;
        }
        {
#line 803
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"pdnsd was compiled without IPv6 support. ipv4_6_prefix option in config file will be ignored.\n");
        }
#line 805
        goto switch_break___0;
        case_29: /* CIL Label */ 
        {
#line 809
        tmp___41 = __ctype_b_loc();
        }
#line 809
        if ((int const   )*(*tmp___41 + (int )*p) & 1024) {
#line 809
          _str___9 = p;
          {
#line 809
          while (1) {
            while_continue___14: /* CIL Label */ ;
#line 809
            p ++;
#line 809
            if (*p) {
              {
#line 809
              tmp___40 = __ctype_b_loc();
              }
#line 809
              if (! ((int const   )*(*tmp___40 + (int )*p) & 8)) {
#line 809
                if (! ((int )*p == 95)) {
#line 809
                  goto while_break___14;
                }
              }
            } else {
#line 809
              goto while_break___14;
            }
          }
          while_break___14: /* CIL Label */ ;
          }
          {
#line 809
          _len___9 = (size_t )(p - _str___9);
#line 809
          cnst___5 = lookup_const((char const   *)_str___9, (int )_len___9);
          }
#line 809
          if (! (cnst___5 == 1)) {
#line 809
            if (! (cnst___5 == 2)) {
#line 809
              goto ASSIGN_CONST_809;
            }
          }
        } else {
          ASSIGN_CONST_809: 
          {
#line 809
          *errstr = report_error(conftype, linenr, "bad qualifier in debug= option.");
          }
#line 809
          goto free_linebuf_return;
        }
#line 810
        if (! cmdline.debug) {
#line 811
          global___0->debug = (char )(cnst___5 == 1);
        }
#line 818
        goto switch_break___0;
        case_30: /* CIL Label */ 
        {
#line 821
        tmp___43 = __ctype_b_loc();
        }
#line 821
        if ((int const   )*(*tmp___43 + (int )*p) & 2048) {
          {
#line 821
          tmp___42 = strtol((char const   */* __restrict  */)p, (char **/* __restrict  */)(& p),
                            0);
#line 821
          global___0->ctl_perms = (int )tmp___42;
          }
        } else {
          {
#line 821
          *errstr = report_error(conftype, linenr, "expected unsigned integer value for ctl_perms option");
          }
#line 821
          goto free_linebuf_return;
        }
#line 822
        goto switch_break___0;
        case_31: /* CIL Label */ 
        {
#line 825
        tmp___45 = __ctype_b_loc();
        }
#line 825
        if ((int const   )*(*tmp___45 + (int )*p) & 2048) {
          {
#line 825
          tmp___44 = strtol((char const   */* __restrict  */)p, (char **/* __restrict  */)(& p),
                            0);
#line 825
          global___0->proc_limit = (int )tmp___44;
          }
        } else {
          {
#line 825
          *errstr = report_error(conftype, linenr, "expected unsigned integer value for proc_limit option");
          }
#line 825
          goto free_linebuf_return;
        }
#line 826
        goto switch_break___0;
        case_32: /* CIL Label */ 
        {
#line 829
        tmp___47 = __ctype_b_loc();
        }
#line 829
        if ((int const   )*(*tmp___47 + (int )*p) & 2048) {
          {
#line 829
          tmp___46 = strtol((char const   */* __restrict  */)p, (char **/* __restrict  */)(& p),
                            0);
#line 829
          global___0->procq_limit = (int )tmp___46;
          }
        } else {
          {
#line 829
          *errstr = report_error(conftype, linenr, "expected unsigned integer value for procq_limit option");
          }
#line 829
          goto free_linebuf_return;
        }
#line 830
        goto switch_break___0;
        case_33: /* CIL Label */ 
        {
#line 833
        tmp___48 = __ctype_b_loc();
        }
#line 833
        if ((int const   )*(*tmp___48 + (int )*p) & 2048) {
          {
#line 833
          global___0->tcp_qtimeout = strtotime(p, & p, & _err___1);
          }
#line 833
          if (_err___1) {
            {
#line 833
            *errstr = report_errorf(conftype, linenr, "invalid time specification for %s: %s",
                                    "tcp_qtimeout option", _err___1);
            }
#line 833
            goto free_linebuf_return;
          }
        } else {
          {
#line 833
          *errstr = report_error(conftype, linenr, "expected a time specification for tcp_qtimeout option");
          }
#line 833
          goto free_linebuf_return;
        }
#line 834
        goto switch_break___0;
        case_47: /* CIL Label */ 
        {
#line 837
        tmp___49 = __ctype_b_loc();
        }
#line 837
        if ((int const   )*(*tmp___49 + (int )*p) & 2048) {
          {
#line 837
          global___0->timeout = strtotime(p, & p, & _err___2);
          }
#line 837
          if (_err___2) {
            {
#line 837
            *errstr = report_errorf(conftype, linenr, "invalid time specification for %s: %s",
                                    "global timeout option", _err___2);
            }
#line 837
            goto free_linebuf_return;
          }
        } else {
          {
#line 837
          *errstr = report_error(conftype, linenr, "expected a time specification for global timeout option");
          }
#line 837
          goto free_linebuf_return;
        }
#line 838
        goto switch_break___0;
        case_34: /* CIL Label */ 
        {
#line 842
        tmp___51 = __ctype_b_loc();
        }
#line 842
        if ((int const   )*(*tmp___51 + (int )*p) & 2048) {
          {
#line 842
          tmp___50 = strtol((char const   */* __restrict  */)p, (char **/* __restrict  */)(& p),
                            0);
#line 842
          val___0 = (int )tmp___50;
          }
        } else {
          {
#line 842
          *errstr = report_error(conftype, linenr, "expected unsigned integer value for par_queries option");
          }
#line 842
          goto free_linebuf_return;
        }
#line 843
        if (val___0 <= 0) {
          {
#line 844
          *errstr = report_error(conftype, linenr, "bad value for par_queries.");
          }
#line 845
          goto free_linebuf_return;
        } else {
#line 847
          global___0->par_queries = val___0;
        }
#line 850
        goto switch_break___0;
        case_35: /* CIL Label */ 
        {
#line 853
        tmp___53 = __ctype_b_loc();
        }
#line 853
        if ((int const   )*(*tmp___53 + (int )*p) & 1024) {
#line 853
          _str___10 = p;
          {
#line 853
          while (1) {
            while_continue___15: /* CIL Label */ ;
#line 853
            p ++;
#line 853
            if (*p) {
              {
#line 853
              tmp___52 = __ctype_b_loc();
              }
#line 853
              if (! ((int const   )*(*tmp___52 + (int )*p) & 8)) {
#line 853
                if (! ((int )*p == 95)) {
#line 853
                  goto while_break___15;
                }
              }
            } else {
#line 853
              goto while_break___15;
            }
          }
          while_break___15: /* CIL Label */ ;
          }
          {
#line 853
          _len___10 = (size_t )(p - _str___10);
#line 853
          _cnst___4 = lookup_const((char const   *)_str___10, (int )_len___10);
          }
#line 853
          if (_cnst___4 == 1) {
#line 853
            global___0->rnd_recs = (char )(_cnst___4 == 1);
          } else
#line 853
          if (_cnst___4 == 2) {
#line 853
            global___0->rnd_recs = (char )(_cnst___4 == 1);
          } else {
#line 853
            goto ASSIGN_ON_OFF_853;
          }
        } else {
          ASSIGN_ON_OFF_853: 
          {
#line 853
          *errstr = report_error(conftype, linenr, "bad qualifier in randomize_recs= option.");
          }
#line 853
          goto free_linebuf_return;
        }
#line 854
        goto switch_break___0;
        case_36: /* CIL Label */ 
        {
#line 857
        tmp___54 = __ctype_b_loc();
        }
#line 857
        if ((int const   )*(*tmp___54 + (int )*p) & 2048) {
          {
#line 857
          global___0->neg_ttl = strtotime(p, & p, & _err___3);
          }
#line 857
          if (_err___3) {
            {
#line 857
            *errstr = report_errorf(conftype, linenr, "invalid time specification for %s: %s",
                                    "neg_ttl option", _err___3);
            }
#line 857
            goto free_linebuf_return;
          }
        } else {
          {
#line 857
          *errstr = report_error(conftype, linenr, "expected a time specification for neg_ttl option");
          }
#line 857
          goto free_linebuf_return;
        }
#line 858
        goto switch_break___0;
        case_37: /* CIL Label */ 
        {
#line 862
        tmp___56 = __ctype_b_loc();
        }
#line 862
        if ((int const   )*(*tmp___56 + (int )*p) & 1024) {
#line 862
          _str___11 = p;
          {
#line 862
          while (1) {
            while_continue___16: /* CIL Label */ ;
#line 862
            p ++;
#line 862
            if (*p) {
              {
#line 862
              tmp___55 = __ctype_b_loc();
              }
#line 862
              if (! ((int const   )*(*tmp___55 + (int )*p) & 8)) {
#line 862
                if (! ((int )*p == 95)) {
#line 862
                  goto while_break___16;
                }
              }
            } else {
#line 862
              goto while_break___16;
            }
          }
          while_break___16: /* CIL Label */ ;
          }
          {
#line 862
          _len___11 = (size_t )(p - _str___11);
#line 862
          cnst___6 = lookup_const((char const   *)_str___11, (int )_len___11);
          }
#line 862
          if (! (cnst___6 == 1)) {
#line 862
            if (! (cnst___6 == 2)) {
#line 862
              if (! (cnst___6 == 3)) {
#line 862
                if (! (cnst___6 == 22)) {
#line 862
                  goto ASSIGN_CONST_863;
                }
              }
            }
          }
        } else {
          ASSIGN_CONST_863: 
          {
#line 862
          *errstr = report_error(conftype, linenr, "bad qualifier in neg_rrs_pol= option.");
          }
#line 862
          goto free_linebuf_return;
        }
#line 864
        global___0->neg_rrs_pol = (short )cnst___6;
#line 866
        goto switch_break___0;
        case_38: /* CIL Label */ 
        {
#line 870
        tmp___58 = __ctype_b_loc();
        }
#line 870
        if ((int const   )*(*tmp___58 + (int )*p) & 1024) {
#line 870
          _str___12 = p;
          {
#line 870
          while (1) {
            while_continue___17: /* CIL Label */ ;
#line 870
            p ++;
#line 870
            if (*p) {
              {
#line 870
              tmp___57 = __ctype_b_loc();
              }
#line 870
              if (! ((int const   )*(*tmp___57 + (int )*p) & 8)) {
#line 870
                if (! ((int )*p == 95)) {
#line 870
                  goto while_break___17;
                }
              }
            } else {
#line 870
              goto while_break___17;
            }
          }
          while_break___17: /* CIL Label */ ;
          }
          {
#line 870
          _len___12 = (size_t )(p - _str___12);
#line 870
          cnst___7 = lookup_const((char const   *)_str___12, (int )_len___12);
          }
#line 870
          if (! (cnst___7 == 1)) {
#line 870
            if (! (cnst___7 == 2)) {
#line 870
              if (! (cnst___7 == 22)) {
#line 870
                goto ASSIGN_CONST_870;
              }
            }
          }
        } else {
          ASSIGN_CONST_870: 
          {
#line 870
          *errstr = report_error(conftype, linenr, "bad qualifier in neg_domain_pol= option.");
          }
#line 870
          goto free_linebuf_return;
        }
#line 871
        global___0->neg_domain_pol = (short )cnst___7;
#line 873
        goto switch_break___0;
        case_39: /* CIL Label */ 
        {
#line 877
        tmp___62 = __ctype_b_loc();
        }
#line 877
        if ((int const   )*(*tmp___62 + (int )*p) & 1024) {
#line 879
          ps = p;
          {
#line 879
          while (1) {
            while_continue___18: /* CIL Label */ ;
#line 879
            p ++;
#line 879
            if (*p) {
              {
#line 879
              tmp___59 = __ctype_b_loc();
              }
#line 879
              if (! ((int const   )*(*tmp___59 + (int )*p) & 8)) {
#line 879
                if (! ((int )*p == 95)) {
#line 879
                  goto while_break___18;
                }
              }
            } else {
#line 879
              goto while_break___18;
            }
          }
          while_break___18: /* CIL Label */ ;
          }
          {
#line 879
          len = (int )(p - ps);
#line 880
          cnst___8 = lookup_const((char const   *)ps, len);
          }
#line 881
          if (cnst___8 == 5) {
#line 882
            val___1 = -1;
          } else {
#line 884
            goto bad_port_start_option;
          }
        } else {
          {
#line 886
          tmp___61 = __ctype_b_loc();
          }
#line 886
          if ((int const   )*(*tmp___61 + (int )*p) & 2048) {
            {
#line 887
            tmp___60 = strtol((char const   */* __restrict  */)p, (char **/* __restrict  */)(& p),
                              0);
#line 887
            val___1 = (int )tmp___60;
            }
#line 888
            if (val___1 > 65535) {
              {
#line 889
              *errstr = report_error(conftype, linenr, "value for query_port_start out of range.");
              }
#line 890
              goto free_linebuf_return;
            } else
#line 892
            if (val___1 < 1024) {
              {
#line 893
              fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Warning: query_port_start=%i but source ports <1204 can only be used as root.\n",
                      val___1);
              }
            }
          } else {
            bad_port_start_option: 
            {
#line 898
            *errstr = report_error(conftype, linenr, "bad qualifier in query_port_start= option.");
            }
#line 899
            goto free_linebuf_return;
          }
        }
#line 901
        global___0->query_port_start = val___1;
#line 903
        goto switch_break___0;
        case_40: /* CIL Label */ 
        {
#line 907
        tmp___64 = __ctype_b_loc();
        }
#line 907
        if ((int const   )*(*tmp___64 + (int )*p) & 2048) {
          {
#line 907
          tmp___63 = strtol((char const   */* __restrict  */)p, (char **/* __restrict  */)(& p),
                            0);
#line 907
          val___2 = (int )tmp___63;
          }
        } else {
          {
#line 907
          *errstr = report_error(conftype, linenr, "expected unsigned integer value for query_port_end option");
          }
#line 907
          goto free_linebuf_return;
        }
#line 908
        if (val___2 > 65535) {
          {
#line 909
          *errstr = report_error(conftype, linenr, "value for query_port_end out of range.");
          }
#line 910
          goto free_linebuf_return;
        }
#line 912
        global___0->query_port_end = val___2;
#line 914
        goto switch_break___0;
        case_41: /* CIL Label */ 
        {
#line 918
        tmp___66 = __ctype_b_loc();
        }
#line 918
        if ((int const   )*(*tmp___66 + (int )*p) & 2048) {
          {
#line 918
          tmp___65 = strtol((char const   */* __restrict  */)p, (char **/* __restrict  */)(& p),
                            0);
#line 918
          val___3 = (int )tmp___65;
          }
        } else {
          {
#line 918
          *errstr = report_error(conftype, linenr, "expected unsigned integer value for udpbufsize");
          }
#line 918
          goto free_linebuf_return;
        }
#line 919
        if (val___3 < 512) {
          {
#line 920
          *errstr = report_error(conftype, linenr, "value for udpbufsize out of range.");
          }
#line 921
          goto free_linebuf_return;
        } else
#line 919
        if (val___3 > 65507) {
          {
#line 920
          *errstr = report_error(conftype, linenr, "value for udpbufsize out of range.");
          }
#line 921
          goto free_linebuf_return;
        }
#line 923
        global___0->udpbufsize = val___3;
#line 925
        goto switch_break___0;
        case_42: /* CIL Label */ 
        {
#line 928
        while (1) {
          while_continue___19: /* CIL Label */ ;
          {
#line 928
          len = scan_string(& p, strbuf, (unsigned int )sizeof(strbuf), & scanstrerr);
          }
#line 928
          if (len == -1) {
#line 928
            goto string_err;
          } else
#line 928
          if ((unsigned long )len >= sizeof(strbuf)) {
#line 928
            goto string_too_long;
          }
          {
#line 928
          _err___4 = zone_add(& global___0->deleg_only_zones, (char const   *)(strbuf),
                              (unsigned int )len);
          }
#line 928
          if (_err___4) {
            {
#line 928
            *errstr = report_error(conftype, linenr, _err___4);
            }
#line 928
            goto free_linebuf_return;
          }
          {
#line 928
          p = getnextp(& linebuf, & buflen, in, p, & linenr, & getnextperr);
          }
#line 928
          if (! p) {
#line 928
            goto unexpected_eof;
          }
#line 928
          if ((int )*p != 44) {
#line 928
            goto while_break___19;
          }
          {
#line 928
          p ++;
#line 928
          p = getnextp(& linebuf, & buflen, in, p, & linenr, & getnextperr);
          }
#line 928
          if (! p) {
#line 928
            goto unexpected_eof;
          }
        }
        while_break___19: /* CIL Label */ ;
        }
#line 929
        goto switch_break___0;
        switch_default: /* CIL Label */ 
#line 932
        goto internal_parse_error;
        switch_break___0: /* CIL Label */ ;
        }
        {
#line 935
        p = getnextp(& linebuf, & buflen, in, p, & linenr, & getnextperr);
        }
#line 935
        if (! p) {
#line 935
          goto unexpected_eof;
        }
#line 936
        if ((int )*p != 59) {
#line 936
          goto expected_semicolon;
        }
        {
#line 937
        p ++;
#line 938
        p = getnextp(& linebuf, & buflen, in, p, & linenr, & getnextperr);
        }
#line 938
        if (! p) {
#line 938
          goto unexpected_eof;
        }
      }
      while_break___1: /* CIL Label */ ;
      }
#line 941
      if ((int )*p != 125) {
#line 941
        goto expected_closing_brace;
      }
#line 942
      if (global___0->query_port_end < global___0->query_port_start) {
        {
#line 943
        *errstr = report_error(conftype, linenr, "query_port_end may not be smaller than query_port_start.");
        }
#line 944
        goto free_linebuf_return;
      }
#line 946
      goto switch_break;
      case_2: /* CIL Label */ 
#line 951
      if (! servers___0) {
#line 952
        if (in) {
#line 952
          tmp___68 = "server section not allowed in include file";
        } else {
#line 952
          tmp___68 = "server section not allowed in eval string";
        }
        {
#line 952
        *errstr = report_error(conftype, linenr, tmp___68);
        }
#line 954
        goto free_linebuf_return;
      }
#line 957
      server = serv_presets;
      {
#line 961
      while (1) {
        while_continue___20: /* CIL Label */ ;
        {
#line 961
        tmp___105 = __ctype_b_loc();
        }
#line 961
        if (! ((int const   )*(*tmp___105 + (int )*p) & 1024)) {
#line 961
          goto while_break___20;
        }
#line 962
        ps = p;
        {
#line 962
        while (1) {
          while_continue___21: /* CIL Label */ ;
#line 962
          p ++;
#line 962
          if (*p) {
            {
#line 962
            tmp___69 = __ctype_b_loc();
            }
#line 962
            if (! ((int const   )*(*tmp___69 + (int )*p) & 8)) {
#line 962
              if (! ((int )*p == 95)) {
#line 962
                goto while_break___21;
              }
            }
          } else {
#line 962
            goto while_break___21;
          }
        }
        while_break___21: /* CIL Label */ ;
        }
        {
#line 962
        len = (int )(p - ps);
#line 963
        option = binsearch_keyword((char const   *)ps, len, server_options, (int )(sizeof(server_options) / sizeof(namevalue_t )));
        }
#line 964
        if (! option) {
          {
#line 965
          *errstr = report_errorf(conftype, linenr, "invalid option for server section: %.*s",
                                  len, ps);
#line 966
          free_servparm(& server);
          }
#line 966
          goto free_linebuf_return;
        }
        {
#line 968
        p = getnextp(& linebuf, & buflen, in, p, & linenr, & getnextperr);
        }
#line 968
        if (! p) {
          {
#line 968
          free_servparm(& server);
          }
#line 968
          goto unexpected_eof;
        }
#line 969
        if ((int )*p != 61) {
          {
#line 969
          free_servparm(& server);
          }
#line 969
          goto expected_equals;
        }
        {
#line 970
        p ++;
#line 971
        p = getnextp(& linebuf, & buflen, in, p, & linenr, & getnextperr);
        }
#line 971
        if (! p) {
          {
#line 971
          free_servparm(& server);
          }
#line 971
          goto unexpected_eof;
        }
        {
#line 974
        if (option == 43) {
#line 974
          goto case_43;
        }
#line 978
        if (option == 81) {
#line 978
          goto case_81;
        }
#line 990
        if (option == 44) {
#line 990
          goto case_44;
        }
#line 994
        if (option == 45) {
#line 994
          goto case_45;
        }
#line 999
        if (option == 46) {
#line 999
          goto case_46;
        }
#line 1006
        if (option == 47) {
#line 1006
          goto case_47___0;
        }
#line 1010
        if (option == 48) {
#line 1010
          goto case_48;
        }
#line 1014
        if (option == 49) {
#line 1014
          goto case_49;
        }
#line 1025
        if (option == 50) {
#line 1025
          goto case_50;
        }
#line 1037
        if (option == 51) {
#line 1037
          goto case_51;
        }
#line 1070
        if (option == 52) {
#line 1070
          goto case_52;
        }
#line 1100
        if (option == 53) {
#line 1100
          goto case_53;
        }
#line 1105
        if (option == 54) {
#line 1105
          goto case_54;
        }
#line 1110
        if (option == 55) {
#line 1110
          goto case_55;
        }
#line 1114
        if (option == 56) {
#line 1114
          goto case_56;
        }
#line 1118
        if (option == 57) {
#line 1118
          goto case_57;
        }
#line 1122
        if (option == 58) {
#line 1122
          goto case_58;
        }
#line 1126
        if (option == 59) {
#line 1126
          goto case_59;
        }
#line 1130
        if (option == 60) {
#line 1130
          goto case_60;
        }
#line 1134
        if (option == 61) {
#line 1134
          goto case_61;
        }
#line 1141
        if (option == 62) {
#line 1141
          goto case_62;
        }
#line 1145
        if (option == 65) {
#line 1145
          goto case_65;
        }
#line 1152
        if (option == 63) {
#line 1152
          goto case_63;
        }
#line 1156
        if (option == 64) {
#line 1156
          goto case_64;
        }
#line 1160
        if (option == 66) {
#line 1160
          goto case_66;
        }
#line 1164
        if (option == 67) {
#line 1164
          goto case_67;
        }
#line 1171
        if (option == 68) {
#line 1171
          goto case_68;
        }
#line 1175
        if (option == 69) {
#line 1175
          goto case_69;
        }
#line 1180
        goto switch_default___0;
        case_43: /* CIL Label */ 
        {
#line 975
        while (1) {
          while_continue___22: /* CIL Label */ ;
          {
#line 975
          len = scan_string(& p, strbuf, (unsigned int )sizeof(strbuf), & scanstrerr);
          }
#line 975
          if (len == -1) {
            {
#line 975
            free_servparm(& server);
            }
#line 975
            goto string_err;
          } else
#line 975
          if ((unsigned long )len >= sizeof(strbuf)) {
            {
#line 975
            free_servparm(& server);
            }
#line 975
            goto string_too_long;
          }
          {
#line 975
          _err___5 = addr_add(& server.atup_a, (char const   *)(strbuf));
          }
#line 975
          if (_err___5) {
            {
#line 975
            *errstr = report_error(conftype, linenr, _err___5);
#line 975
            free_servparm(& server);
            }
#line 975
            goto free_linebuf_return;
          }
          {
#line 975
          p = getnextp(& linebuf, & buflen, in, p, & linenr, & getnextperr);
          }
#line 975
          if (! p) {
            {
#line 975
            free_servparm(& server);
            }
#line 975
            goto unexpected_eof;
          }
#line 975
          if ((int )*p != 44) {
#line 975
            goto while_break___22;
          }
          {
#line 975
          p ++;
#line 975
          p = getnextp(& linebuf, & buflen, in, p, & linenr, & getnextperr);
          }
#line 975
          if (! p) {
            {
#line 975
            free_servparm(& server);
            }
#line 975
            goto unexpected_eof;
          }
        }
        while_break___22: /* CIL Label */ ;
        }
#line 976
        goto switch_break___1;
        case_81: /* CIL Label */ 
        {
#line 979
        len = scan_string(& p, strbuf, (unsigned int )sizeof(strbuf), & scanstrerr);
        }
#line 979
        if (len == -1) {
          {
#line 979
          free_servparm(& server);
          }
#line 979
          goto string_err;
        } else
#line 979
        if ((unsigned long )len >= sizeof(strbuf)) {
          {
#line 979
          free_servparm(& server);
          }
#line 979
          goto string_too_long;
        }
        {
#line 982
        tmp___70 = read_resolv_conf((char const   *)(strbuf), & server.atup_a, & errmsg);
        }
#line 982
        if (! tmp___70) {
#line 983
          if (errmsg) {
            {
#line 983
            *errstr = report_error(conftype, linenr, (char const   *)errmsg);
#line 983
            free((void *)errmsg);
            }
          } else {
#line 984
            *errstr = (char *)((void *)0);
          }
          {
#line 985
          free_servparm(& server);
          }
#line 985
          goto free_linebuf_return;
        }
#line 988
        goto switch_break___1;
        case_44: /* CIL Label */ 
        {
#line 991
        tmp___72 = __ctype_b_loc();
        }
#line 991
        if ((int const   )*(*tmp___72 + (int )*p) & 2048) {
          {
#line 991
          tmp___71 = strtol((char const   */* __restrict  */)p, (char **/* __restrict  */)(& p),
                            0);
#line 991
          server.port = (unsigned short )tmp___71;
          }
        } else {
          {
#line 991
          *errstr = report_error(conftype, linenr, "expected unsigned integer value for port option");
#line 991
          free_servparm(& server);
          }
#line 991
          goto free_linebuf_return;
        }
#line 992
        goto switch_break___1;
        case_45: /* CIL Label */ 
        {
#line 995
        len = scan_string(& p, strbuf, (unsigned int )sizeof(strbuf), & scanstrerr);
        }
#line 995
        if (len == -1) {
          {
#line 995
          free_servparm(& server);
          }
#line 995
          goto string_err;
        } else
#line 995
        if ((unsigned long )len >= sizeof(strbuf)) {
          {
#line 995
          free_servparm(& server);
          }
#line 995
          goto string_too_long;
        }
#line 996
        if ((unsigned long )len < sizeof(server.scheme)) {
          {
#line 996
          memcpy((void */* __restrict  */)(server.scheme), (void const   */* __restrict  */)(strbuf),
                 (size_t )len);
#line 996
          server.scheme[len] = (char)0;
          }
        } else {
          {
#line 996
          *errstr = report_error(conftype, linenr, "scheme: string too long");
#line 996
          free_servparm(& server);
          }
#line 996
          goto free_linebuf_return;
        }
#line 997
        goto switch_break___1;
        case_46: /* CIL Label */ 
        {
#line 1001
        tmp___74 = __ctype_b_loc();
        }
#line 1001
        if ((int const   )*(*tmp___74 + (int )*p) & 1024) {
#line 1001
          _str___13 = p;
          {
#line 1001
          while (1) {
            while_continue___23: /* CIL Label */ ;
#line 1001
            p ++;
#line 1001
            if (*p) {
              {
#line 1001
              tmp___73 = __ctype_b_loc();
              }
#line 1001
              if (! ((int const   )*(*tmp___73 + (int )*p) & 8)) {
#line 1001
                if (! ((int )*p == 95)) {
#line 1001
                  goto while_break___23;
                }
              }
            } else {
#line 1001
              goto while_break___23;
            }
          }
          while_break___23: /* CIL Label */ ;
          }
          {
#line 1001
          _len___13 = (size_t )(p - _str___13);
#line 1001
          cnst___9 = lookup_const((char const   *)_str___13, (int )_len___13);
          }
#line 1001
          if (! (cnst___9 == 8)) {
#line 1001
            if (! (cnst___9 == 5)) {
#line 1001
              if (! (cnst___9 == 6)) {
#line 1001
                if (! (cnst___9 == 7)) {
#line 1001
                  if (! (cnst___9 == 16)) {
#line 1001
                    if (! (cnst___9 == 17)) {
#line 1001
                      if (! (cnst___9 == 9)) {
#line 1001
                        goto ASSIGN_CONST_1001;
                      }
                    }
                  }
                }
              }
            }
          }
        } else {
          ASSIGN_CONST_1001: 
          {
#line 1001
          *errstr = report_error(conftype, linenr, "bad qualifier in uptest= option.");
#line 1001
          free_servparm(& server);
          }
#line 1001
          goto free_linebuf_return;
        }
#line 1002
        server.uptest = (short )cnst___9;
#line 1004
        goto switch_break___1;
        case_47___0: /* CIL Label */ 
        {
#line 1007
        tmp___75 = __ctype_b_loc();
        }
#line 1007
        if ((int const   )*(*tmp___75 + (int )*p) & 2048) {
          {
#line 1007
          server.timeout = strtotime(p, & p, & _err___6);
          }
#line 1007
          if (_err___6) {
            {
#line 1007
            *errstr = report_errorf(conftype, linenr, "invalid time specification for %s: %s",
                                    "timeout option", _err___6);
#line 1007
            free_servparm(& server);
            }
#line 1007
            goto free_linebuf_return;
          }
        } else {
          {
#line 1007
          *errstr = report_error(conftype, linenr, "expected a time specification for timeout option");
#line 1007
          free_servparm(& server);
          }
#line 1007
          goto free_linebuf_return;
        }
#line 1008
        goto switch_break___1;
        case_48: /* CIL Label */ 
        {
#line 1011
        tmp___76 = __ctype_b_loc();
        }
#line 1011
        if ((int const   )*(*tmp___76 + (int )*p) & 2048) {
          {
#line 1011
          server.ping_timeout = strtol((char const   */* __restrict  */)p, (char **/* __restrict  */)(& p),
                                       0);
          }
        } else {
          {
#line 1011
          *errstr = report_error(conftype, linenr, "expected unsigned integer value for ping_timeout option");
#line 1011
          free_servparm(& server);
          }
#line 1011
          goto free_linebuf_return;
        }
#line 1012
        goto switch_break___1;
        case_49: /* CIL Label */ 
        {
#line 1015
        len = scan_string(& p, strbuf, (unsigned int )sizeof(strbuf), & scanstrerr);
        }
#line 1015
        if (len == -1) {
          {
#line 1015
          free_servparm(& server);
          }
#line 1015
          goto string_err;
        } else
#line 1015
        if ((unsigned long )len >= sizeof(strbuf)) {
          {
#line 1015
          free_servparm(& server);
          }
#line 1015
          goto string_too_long;
        }
        {
#line 1018
        err___0 = parse_ip((char const   *)(strbuf), & server.ping_a);
        }
#line 1018
        if (err___0) {
          {
#line 1019
          *errstr = report_errorf(conftype, linenr, "%s for the ping_ip= option.",
                                  err___0);
#line 1020
          free_servparm(& server);
          }
#line 1020
          goto free_linebuf_return;
        }
#line 1023
        goto switch_break___1;
        case_50: /* CIL Label */ 
        {
#line 1026
        len = scan_string(& p, strbuf, (unsigned int )sizeof(strbuf), & scanstrerr);
        }
#line 1026
        if (len == -1) {
          {
#line 1026
          free_servparm(& server);
          }
#line 1026
          goto string_err;
        } else
#line 1026
        if ((unsigned long )len >= sizeof(strbuf)) {
          {
#line 1026
          free_servparm(& server);
          }
#line 1026
          goto string_too_long;
        }
#line 1027
        if (server.uptest_cmd) {
          {
#line 1027
          free((void *)server.uptest_cmd);
          }
        }
        {
#line 1027
        server.uptest_cmd = strndup((char const   *)(strbuf), (size_t )len);
        }
#line 1027
        if (! server.uptest_cmd) {
          {
#line 1027
          free_servparm(& server);
          }
#line 1027
          goto out_of_memory;
        }
        {
#line 1028
        p = getnextp(& linebuf, & buflen, in, p, & linenr, & getnextperr);
        }
#line 1028
        if (! p) {
          {
#line 1028
          free_servparm(& server);
          }
#line 1028
          goto unexpected_eof;
        }
#line 1029
        if ((int )*p == 44) {
          {
#line 1030
          p ++;
#line 1031
          p = getnextp(& linebuf, & buflen, in, p, & linenr, & getnextperr);
          }
#line 1031
          if (! p) {
            {
#line 1031
            free_servparm(& server);
            }
#line 1031
            goto unexpected_eof;
          }
          {
#line 1032
          len = scan_string(& p, strbuf, (unsigned int )sizeof(strbuf), & scanstrerr);
          }
#line 1032
          if (len == -1) {
            {
#line 1032
            free_servparm(& server);
            }
#line 1032
            goto string_err;
          } else
#line 1032
          if ((unsigned long )len >= sizeof(strbuf)) {
            {
#line 1032
            free_servparm(& server);
            }
#line 1032
            goto string_too_long;
          }
#line 1033
          if ((unsigned long )len < sizeof(server.uptest_usr)) {
            {
#line 1033
            memcpy((void */* __restrict  */)(server.uptest_usr), (void const   */* __restrict  */)(strbuf),
                   (size_t )len);
#line 1033
            server.uptest_usr[len] = (char)0;
            }
          } else {
            {
#line 1033
            *errstr = report_error(conftype, linenr, "second argument of uptest_cmd: string too long");
#line 1033
            free_servparm(& server);
            }
#line 1033
            goto free_linebuf_return;
          }
        }
#line 1035
        goto switch_break___1;
        case_51: /* CIL Label */ 
        {
#line 1038
        tmp___78 = __ctype_b_loc();
        }
#line 1038
        if ((int const   )*(*tmp___78 + (int )*p) & 1024) {
#line 1040
          ps = p;
          {
#line 1040
          while (1) {
            while_continue___24: /* CIL Label */ ;
#line 1040
            p ++;
#line 1040
            if (*p) {
              {
#line 1040
              tmp___77 = __ctype_b_loc();
              }
#line 1040
              if (! ((int const   )*(*tmp___77 + (int )*p) & 8)) {
#line 1040
                if (! ((int )*p == 95)) {
#line 1040
                  goto while_break___24;
                }
              }
            } else {
#line 1040
              goto while_break___24;
            }
          }
          while_break___24: /* CIL Label */ ;
          }
#line 1040
          len = (int )(p - ps);
#line 1041
          if ((int )*p != 46) {
#line 1041
            if ((int )*p != 45) {
              {
#line 1042
              cnst___10 = lookup_const((char const   *)ps, len);
              }
#line 1043
              if (cnst___10 == 5) {
#line 1044
                if (server.query_test_name) {
                  {
#line 1045
                  free((void *)server.query_test_name);
                  }
                }
#line 1046
                server.query_test_name = (unsigned char *)((void *)0);
#line 1047
                goto switch_break___1;
              }
            }
          }
#line 1050
          p = ps;
        }
        {
#line 1056
        len = scan_string(& p, strbuf, (unsigned int )sizeof(strbuf), & scanstrerr);
        }
#line 1056
        if (len == -1) {
          {
#line 1056
          free_servparm(& server);
          }
#line 1056
          goto string_err;
        } else
#line 1056
        if ((unsigned long )len >= sizeof(strbuf)) {
          {
#line 1056
          free_servparm(& server);
          }
#line 1056
          goto string_too_long;
        }
        {
#line 1057
        _err___7 = parsestr2rhn((unsigned char const   *)((unsigned char *)(strbuf)),
                                (unsigned int )len, tname);
        }
#line 1057
        if (_err___7) {
          {
#line 1057
          *errstr = report_error(conftype, linenr, _err___7);
#line 1057
          free_servparm(& server);
          }
#line 1057
          goto free_linebuf_return;
        }
        {
#line 1058
        sz = rhnlen((unsigned char const   *)(tname));
#line 1059
        tmp___79 = malloc((size_t )sz);
#line 1059
        copy = (unsigned char *)tmp___79;
        }
#line 1060
        if (! copy) {
          {
#line 1061
          free_servparm(& server);
          }
#line 1061
          goto out_of_memory;
        }
        {
#line 1063
        memcpy((void */* __restrict  */)copy, (void const   */* __restrict  */)(tname),
               (size_t )sz);
        }
#line 1064
        if (server.query_test_name) {
          {
#line 1065
          free((void *)server.query_test_name);
          }
        }
#line 1066
        server.query_test_name = copy;
#line 1068
        goto switch_break___1;
        case_52: /* CIL Label */ 
        {
#line 1071
        tmp___82 = __ctype_b_loc();
        }
#line 1071
        if ((int const   )*(*tmp___82 + (int )*p) & 1024) {
#line 1073
          ps = p;
          {
#line 1073
          while (1) {
            while_continue___25: /* CIL Label */ ;
#line 1073
            p ++;
#line 1073
            if (*p) {
              {
#line 1073
              tmp___80 = __ctype_b_loc();
              }
#line 1073
              if (! ((int const   )*(*tmp___80 + (int )*p) & 8)) {
#line 1073
                if (! ((int )*p == 95)) {
#line 1073
                  goto while_break___25;
                }
              }
            } else {
#line 1073
              goto while_break___25;
            }
          }
          while_break___25: /* CIL Label */ ;
          }
          {
#line 1073
          len = (int )(p - ps);
#line 1074
          cnst___11 = lookup_const((char const   *)ps, len);
          }
#line 1075
          if (cnst___11 == 10) {
#line 1076
            server.interval = (time_t )-1;
          } else
#line 1078
          if (cnst___11 == 11) {
#line 1079
            server.interval = (time_t )-2;
          } else {
#line 1082
            goto bad_interval_option;
          }
        } else {
          {
#line 1085
          tmp___81 = __ctype_b_loc();
          }
#line 1085
          if ((int const   )*(*tmp___81 + (int )*p) & 2048) {
            {
#line 1087
            server.interval = strtotime(p, & p, & err___1);
            }
#line 1088
            if (err___1) {
              {
#line 1089
              *errstr = report_errorf(conftype, linenr, "bad time specification in interval= option: %s",
                                      err___1);
#line 1090
              free_servparm(& server);
              }
#line 1090
              goto free_linebuf_return;
            }
          } else {
            bad_interval_option: 
            {
#line 1095
            *errstr = report_error(conftype, linenr, "bad qualifier in interval= option.");
#line 1096
            free_servparm(& server);
            }
#line 1096
            goto free_linebuf_return;
          }
        }
#line 1098
        goto switch_break___1;
        case_53: /* CIL Label */ 
        {
#line 1101
        len = scan_string(& p, strbuf, (unsigned int )sizeof(strbuf), & scanstrerr);
        }
#line 1101
        if (len == -1) {
          {
#line 1101
          free_servparm(& server);
          }
#line 1101
          goto string_err;
        } else
#line 1101
        if ((unsigned long )len >= sizeof(strbuf)) {
          {
#line 1101
          free_servparm(& server);
          }
#line 1101
          goto string_too_long;
        }
#line 1102
        if ((unsigned long )len < sizeof(server.interface)) {
          {
#line 1102
          memcpy((void */* __restrict  */)(server.interface), (void const   */* __restrict  */)(strbuf),
                 (size_t )len);
#line 1102
          server.interface[len] = (char)0;
          }
        } else {
          {
#line 1102
          *errstr = report_error(conftype, linenr, "interface: string too long");
#line 1102
          free_servparm(& server);
          }
#line 1102
          goto free_linebuf_return;
        }
#line 1103
        goto switch_break___1;
        case_54: /* CIL Label */ 
        {
#line 1106
        len = scan_string(& p, strbuf, (unsigned int )sizeof(strbuf), & scanstrerr);
        }
#line 1106
        if (len == -1) {
          {
#line 1106
          free_servparm(& server);
          }
#line 1106
          goto string_err;
        } else
#line 1106
        if ((unsigned long )len >= sizeof(strbuf)) {
          {
#line 1106
          free_servparm(& server);
          }
#line 1106
          goto string_too_long;
        }
#line 1107
        if ((unsigned long )len < sizeof(server.device)) {
          {
#line 1107
          memcpy((void */* __restrict  */)(server.device), (void const   */* __restrict  */)(strbuf),
                 (size_t )len);
#line 1107
          server.device[len] = (char)0;
          }
        } else {
          {
#line 1107
          *errstr = report_error(conftype, linenr, "device: string too long");
#line 1107
          free_servparm(& server);
          }
#line 1107
          goto free_linebuf_return;
        }
#line 1108
        goto switch_break___1;
        case_55: /* CIL Label */ 
        {
#line 1111
        tmp___84 = __ctype_b_loc();
        }
#line 1111
        if ((int const   )*(*tmp___84 + (int )*p) & 1024) {
#line 1111
          _str___14 = p;
          {
#line 1111
          while (1) {
            while_continue___26: /* CIL Label */ ;
#line 1111
            p ++;
#line 1111
            if (*p) {
              {
#line 1111
              tmp___83 = __ctype_b_loc();
              }
#line 1111
              if (! ((int const   )*(*tmp___83 + (int )*p) & 8)) {
#line 1111
                if (! ((int )*p == 95)) {
#line 1111
                  goto while_break___26;
                }
              }
            } else {
#line 1111
              goto while_break___26;
            }
          }
          while_break___26: /* CIL Label */ ;
          }
          {
#line 1111
          _len___14 = (size_t )(p - _str___14);
#line 1111
          _cnst___5 = lookup_const((char const   *)_str___14, (int )_len___14);
          }
#line 1111
          if (_cnst___5 == 1) {
#line 1111
            server.purge_cache = (char )(_cnst___5 == 1);
          } else
#line 1111
          if (_cnst___5 == 2) {
#line 1111
            server.purge_cache = (char )(_cnst___5 == 1);
          } else {
#line 1111
            goto ASSIGN_ON_OFF_1111;
          }
        } else {
          ASSIGN_ON_OFF_1111: 
          {
#line 1111
          *errstr = report_error(conftype, linenr, "bad qualifier in purge_cache= option.");
#line 1111
          free_servparm(& server);
          }
#line 1111
          goto free_linebuf_return;
        }
#line 1112
        goto switch_break___1;
        case_56: /* CIL Label */ 
        {
#line 1115
        tmp___86 = __ctype_b_loc();
        }
#line 1115
        if ((int const   )*(*tmp___86 + (int )*p) & 1024) {
#line 1115
          _str___15 = p;
          {
#line 1115
          while (1) {
            while_continue___27: /* CIL Label */ ;
#line 1115
            p ++;
#line 1115
            if (*p) {
              {
#line 1115
              tmp___85 = __ctype_b_loc();
              }
#line 1115
              if (! ((int const   )*(*tmp___85 + (int )*p) & 8)) {
#line 1115
                if (! ((int )*p == 95)) {
#line 1115
                  goto while_break___27;
                }
              }
            } else {
#line 1115
              goto while_break___27;
            }
          }
          while_break___27: /* CIL Label */ ;
          }
          {
#line 1115
          _len___15 = (size_t )(p - _str___15);
#line 1115
          _cnst___6 = lookup_const((char const   *)_str___15, (int )_len___15);
          }
#line 1115
          if (_cnst___6 == 1) {
#line 1115
            server.nocache = (char )(_cnst___6 == 2);
          } else
#line 1115
          if (_cnst___6 == 2) {
#line 1115
            server.nocache = (char )(_cnst___6 == 2);
          } else {
#line 1115
            goto ASSIGN_ON_OFF_1115;
          }
        } else {
          ASSIGN_ON_OFF_1115: 
          {
#line 1115
          *errstr = report_error(conftype, linenr, "bad qualifier in caching= option.");
#line 1115
          free_servparm(& server);
          }
#line 1115
          goto free_linebuf_return;
        }
#line 1116
        goto switch_break___1;
        case_57: /* CIL Label */ 
        {
#line 1119
        tmp___88 = __ctype_b_loc();
        }
#line 1119
        if ((int const   )*(*tmp___88 + (int )*p) & 1024) {
#line 1119
          _str___16 = p;
          {
#line 1119
          while (1) {
            while_continue___28: /* CIL Label */ ;
#line 1119
            p ++;
#line 1119
            if (*p) {
              {
#line 1119
              tmp___87 = __ctype_b_loc();
              }
#line 1119
              if (! ((int const   )*(*tmp___87 + (int )*p) & 8)) {
#line 1119
                if (! ((int )*p == 95)) {
#line 1119
                  goto while_break___28;
                }
              }
            } else {
#line 1119
              goto while_break___28;
            }
          }
          while_break___28: /* CIL Label */ ;
          }
          {
#line 1119
          _len___16 = (size_t )(p - _str___16);
#line 1119
          _cnst___7 = lookup_const((char const   *)_str___16, (int )_len___16);
          }
#line 1119
          if (_cnst___7 == 1) {
#line 1119
            server.lean_query = (char )(_cnst___7 == 1);
          } else
#line 1119
          if (_cnst___7 == 2) {
#line 1119
            server.lean_query = (char )(_cnst___7 == 1);
          } else {
#line 1119
            goto ASSIGN_ON_OFF_1119;
          }
        } else {
          ASSIGN_ON_OFF_1119: 
          {
#line 1119
          *errstr = report_error(conftype, linenr, "bad qualifier in lean_query= option.");
#line 1119
          free_servparm(& server);
          }
#line 1119
          goto free_linebuf_return;
        }
#line 1120
        goto switch_break___1;
        case_58: /* CIL Label */ 
        {
#line 1123
        tmp___90 = __ctype_b_loc();
        }
#line 1123
        if ((int const   )*(*tmp___90 + (int )*p) & 1024) {
#line 1123
          _str___17 = p;
          {
#line 1123
          while (1) {
            while_continue___29: /* CIL Label */ ;
#line 1123
            p ++;
#line 1123
            if (*p) {
              {
#line 1123
              tmp___89 = __ctype_b_loc();
              }
#line 1123
              if (! ((int const   )*(*tmp___89 + (int )*p) & 8)) {
#line 1123
                if (! ((int )*p == 95)) {
#line 1123
                  goto while_break___29;
                }
              }
            } else {
#line 1123
              goto while_break___29;
            }
          }
          while_break___29: /* CIL Label */ ;
          }
          {
#line 1123
          _len___17 = (size_t )(p - _str___17);
#line 1123
          _cnst___8 = lookup_const((char const   *)_str___17, (int )_len___17);
          }
#line 1123
          if (_cnst___8 == 1) {
#line 1123
            server.edns_query = (char )(_cnst___8 == 1);
          } else
#line 1123
          if (_cnst___8 == 2) {
#line 1123
            server.edns_query = (char )(_cnst___8 == 1);
          } else {
#line 1123
            goto ASSIGN_ON_OFF_1123;
          }
        } else {
          ASSIGN_ON_OFF_1123: 
          {
#line 1123
          *errstr = report_error(conftype, linenr, "bad qualifier in edns_query= option.");
#line 1123
          free_servparm(& server);
          }
#line 1123
          goto free_linebuf_return;
        }
#line 1124
        goto switch_break___1;
        case_59: /* CIL Label */ 
        {
#line 1127
        tmp___92 = __ctype_b_loc();
        }
#line 1127
        if ((int const   )*(*tmp___92 + (int )*p) & 1024) {
#line 1127
          _str___18 = p;
          {
#line 1127
          while (1) {
            while_continue___30: /* CIL Label */ ;
#line 1127
            p ++;
#line 1127
            if (*p) {
              {
#line 1127
              tmp___91 = __ctype_b_loc();
              }
#line 1127
              if (! ((int const   )*(*tmp___91 + (int )*p) & 8)) {
#line 1127
                if (! ((int )*p == 95)) {
#line 1127
                  goto while_break___30;
                }
              }
            } else {
#line 1127
              goto while_break___30;
            }
          }
          while_break___30: /* CIL Label */ ;
          }
          {
#line 1127
          _len___18 = (size_t )(p - _str___18);
#line 1127
          _cnst___9 = lookup_const((char const   *)_str___18, (int )_len___18);
          }
#line 1127
          if (_cnst___9 == 1) {
#line 1127
            server.preset = (char )(_cnst___9 == 1);
          } else
#line 1127
          if (_cnst___9 == 2) {
#line 1127
            server.preset = (char )(_cnst___9 == 1);
          } else {
#line 1127
            goto ASSIGN_ON_OFF_1127;
          }
        } else {
          ASSIGN_ON_OFF_1127: 
          {
#line 1127
          *errstr = report_error(conftype, linenr, "bad qualifier in preset= option.");
#line 1127
          free_servparm(& server);
          }
#line 1127
          goto free_linebuf_return;
        }
#line 1128
        goto switch_break___1;
        case_60: /* CIL Label */ 
        {
#line 1131
        tmp___94 = __ctype_b_loc();
        }
#line 1131
        if ((int const   )*(*tmp___94 + (int )*p) & 1024) {
#line 1131
          _str___19 = p;
          {
#line 1131
          while (1) {
            while_continue___31: /* CIL Label */ ;
#line 1131
            p ++;
#line 1131
            if (*p) {
              {
#line 1131
              tmp___93 = __ctype_b_loc();
              }
#line 1131
              if (! ((int const   )*(*tmp___93 + (int )*p) & 8)) {
#line 1131
                if (! ((int )*p == 95)) {
#line 1131
                  goto while_break___31;
                }
              }
            } else {
#line 1131
              goto while_break___31;
            }
          }
          while_break___31: /* CIL Label */ ;
          }
          {
#line 1131
          _len___19 = (size_t )(p - _str___19);
#line 1131
          _cnst___10 = lookup_const((char const   *)_str___19, (int )_len___19);
          }
#line 1131
          if (_cnst___10 == 1) {
#line 1131
            server.is_proxy = (char )(_cnst___10 == 1);
          } else
#line 1131
          if (_cnst___10 == 2) {
#line 1131
            server.is_proxy = (char )(_cnst___10 == 1);
          } else {
#line 1131
            goto ASSIGN_ON_OFF_1131;
          }
        } else {
          ASSIGN_ON_OFF_1131: 
          {
#line 1131
          *errstr = report_error(conftype, linenr, "bad qualifier in proxy_only= option.");
#line 1131
          free_servparm(& server);
          }
#line 1131
          goto free_linebuf_return;
        }
#line 1132
        goto switch_break___1;
        case_61: /* CIL Label */ 
        {
#line 1136
        tmp___96 = __ctype_b_loc();
        }
#line 1136
        if ((int const   )*(*tmp___96 + (int )*p) & 1024) {
#line 1136
          _str___20 = p;
          {
#line 1136
          while (1) {
            while_continue___32: /* CIL Label */ ;
#line 1136
            p ++;
#line 1136
            if (*p) {
              {
#line 1136
              tmp___95 = __ctype_b_loc();
              }
#line 1136
              if (! ((int const   )*(*tmp___95 + (int )*p) & 8)) {
#line 1136
                if (! ((int )*p == 95)) {
#line 1136
                  goto while_break___32;
                }
              }
            } else {
#line 1136
              goto while_break___32;
            }
          }
          while_break___32: /* CIL Label */ ;
          }
          {
#line 1136
          _len___20 = (size_t )(p - _str___20);
#line 1136
          cnst___12 = lookup_const((char const   *)_str___20, (int )_len___20);
          }
#line 1136
          if (! (cnst___12 == 1)) {
#line 1136
            if (! (cnst___12 == 2)) {
#line 1136
              if (! (cnst___12 == 4)) {
#line 1136
                goto ASSIGN_CONST_1136;
              }
            }
          }
        } else {
          ASSIGN_CONST_1136: 
          {
#line 1136
          *errstr = report_error(conftype, linenr, "bad qualifier in root_server= option.");
#line 1136
          free_servparm(& server);
          }
#line 1136
          goto free_linebuf_return;
        }
#line 1137
        if (cnst___12 == 4) {
#line 1137
          server.rootserver = (char)2;
        } else {
#line 1137
          server.rootserver = (char )(cnst___12 == 1);
        }
#line 1139
        goto switch_break___1;
        case_62: /* CIL Label */ 
        {
#line 1142
        tmp___98 = __ctype_b_loc();
        }
#line 1142
        if ((int const   )*(*tmp___98 + (int )*p) & 1024) {
#line 1142
          _str___21 = p;
          {
#line 1142
          while (1) {
            while_continue___33: /* CIL Label */ ;
#line 1142
            p ++;
#line 1142
            if (*p) {
              {
#line 1142
              tmp___97 = __ctype_b_loc();
              }
#line 1142
              if (! ((int const   )*(*tmp___97 + (int )*p) & 8)) {
#line 1142
                if (! ((int )*p == 95)) {
#line 1142
                  goto while_break___33;
                }
              }
            } else {
#line 1142
              goto while_break___33;
            }
          }
          while_break___33: /* CIL Label */ ;
          }
          {
#line 1142
          _len___21 = (size_t )(p - _str___21);
#line 1142
          _cnst___11 = lookup_const((char const   *)_str___21, (int )_len___21);
          }
#line 1142
          if (_cnst___11 == 1) {
#line 1142
            server.rand_servers = (char )(_cnst___11 == 1);
          } else
#line 1142
          if (_cnst___11 == 2) {
#line 1142
            server.rand_servers = (char )(_cnst___11 == 1);
          } else {
#line 1142
            goto ASSIGN_ON_OFF_1142;
          }
        } else {
          ASSIGN_ON_OFF_1142: 
          {
#line 1142
          *errstr = report_error(conftype, linenr, "bad qualifier in randomize_servers= option.");
#line 1142
          free_servparm(& server);
          }
#line 1142
          goto free_linebuf_return;
        }
#line 1143
        goto switch_break___1;
        case_65: /* CIL Label */ 
        {
#line 1147
        tmp___100 = __ctype_b_loc();
        }
#line 1147
        if ((int const   )*(*tmp___100 + (int )*p) & 1024) {
#line 1147
          _str___22 = p;
          {
#line 1147
          while (1) {
            while_continue___34: /* CIL Label */ ;
#line 1147
            p ++;
#line 1147
            if (*p) {
              {
#line 1147
              tmp___99 = __ctype_b_loc();
              }
#line 1147
              if (! ((int const   )*(*tmp___99 + (int )*p) & 8)) {
#line 1147
                if (! ((int )*p == 95)) {
#line 1147
                  goto while_break___34;
                }
              }
            } else {
#line 1147
              goto while_break___34;
            }
          }
          while_break___34: /* CIL Label */ ;
          }
          {
#line 1147
          _len___22 = (size_t )(p - _str___22);
#line 1147
          cnst___13 = lookup_const((char const   *)_str___22, (int )_len___22);
          }
#line 1147
          if (! (cnst___13 == 18)) {
#line 1147
            if (! (cnst___13 == 19)) {
#line 1147
              if (! (cnst___13 == 20)) {
#line 1147
                if (! (cnst___13 == 21)) {
#line 1147
                  goto ASSIGN_CONST_1147;
                }
              }
            }
          }
        } else {
          ASSIGN_CONST_1147: 
          {
#line 1147
          *errstr = report_error(conftype, linenr, "bad qualifier in policy= option.");
#line 1147
          free_servparm(& server);
          }
#line 1147
          goto free_linebuf_return;
        }
#line 1148
        server.policy = (short )cnst___13;
#line 1150
        goto switch_break___1;
        case_63: /* CIL Label */ 
        {
#line 1153
        while (1) {
          while_continue___35: /* CIL Label */ ;
          {
#line 1153
          len = scan_string(& p, strbuf, (unsigned int )sizeof(strbuf), & scanstrerr);
          }
#line 1153
          if (len == -1) {
            {
#line 1153
            free_servparm(& server);
            }
#line 1153
            goto string_err;
          } else
#line 1153
          if ((unsigned long )len >= sizeof(strbuf)) {
            {
#line 1153
            free_servparm(& server);
            }
#line 1153
            goto string_too_long;
          }
          {
#line 1153
          _err___8 = slist_add(& server.alist, (char const   *)(strbuf), (unsigned int )len,
                               18);
          }
#line 1153
          if (_err___8) {
            {
#line 1153
            *errstr = report_error(conftype, linenr, _err___8);
#line 1153
            free_servparm(& server);
            }
#line 1153
            goto free_linebuf_return;
          }
          {
#line 1153
          p = getnextp(& linebuf, & buflen, in, p, & linenr, & getnextperr);
          }
#line 1153
          if (! p) {
            {
#line 1153
            free_servparm(& server);
            }
#line 1153
            goto unexpected_eof;
          }
#line 1153
          if ((int )*p != 44) {
#line 1153
            goto while_break___35;
          }
          {
#line 1153
          p ++;
#line 1153
          p = getnextp(& linebuf, & buflen, in, p, & linenr, & getnextperr);
          }
#line 1153
          if (! p) {
            {
#line 1153
            free_servparm(& server);
            }
#line 1153
            goto unexpected_eof;
          }
        }
        while_break___35: /* CIL Label */ ;
        }
#line 1154
        goto switch_break___1;
        case_64: /* CIL Label */ 
        {
#line 1157
        while (1) {
          while_continue___36: /* CIL Label */ ;
          {
#line 1157
          len = scan_string(& p, strbuf, (unsigned int )sizeof(strbuf), & scanstrerr);
          }
#line 1157
          if (len == -1) {
            {
#line 1157
            free_servparm(& server);
            }
#line 1157
            goto string_err;
          } else
#line 1157
          if ((unsigned long )len >= sizeof(strbuf)) {
            {
#line 1157
            free_servparm(& server);
            }
#line 1157
            goto string_too_long;
          }
          {
#line 1157
          _err___9 = slist_add(& server.alist, (char const   *)(strbuf), (unsigned int )len,
                               19);
          }
#line 1157
          if (_err___9) {
            {
#line 1157
            *errstr = report_error(conftype, linenr, _err___9);
#line 1157
            free_servparm(& server);
            }
#line 1157
            goto free_linebuf_return;
          }
          {
#line 1157
          p = getnextp(& linebuf, & buflen, in, p, & linenr, & getnextperr);
          }
#line 1157
          if (! p) {
            {
#line 1157
            free_servparm(& server);
            }
#line 1157
            goto unexpected_eof;
          }
#line 1157
          if ((int )*p != 44) {
#line 1157
            goto while_break___36;
          }
          {
#line 1157
          p ++;
#line 1157
          p = getnextp(& linebuf, & buflen, in, p, & linenr, & getnextperr);
          }
#line 1157
          if (! p) {
            {
#line 1157
            free_servparm(& server);
            }
#line 1157
            goto unexpected_eof;
          }
        }
        while_break___36: /* CIL Label */ ;
        }
#line 1158
        goto switch_break___1;
        case_66: /* CIL Label */ 
        {
#line 1161
        while (1) {
          while_continue___37: /* CIL Label */ ;
          {
#line 1161
          len = scan_string(& p, strbuf, (unsigned int )sizeof(strbuf), & scanstrerr);
          }
#line 1161
          if (len == -1) {
            {
#line 1161
            free_servparm(& server);
            }
#line 1161
            goto string_err;
          } else
#line 1161
          if ((unsigned long )len >= sizeof(strbuf)) {
            {
#line 1161
            free_servparm(& server);
            }
#line 1161
            goto string_too_long;
          }
          {
#line 1161
          _err___10 = reject_add(& server, (char const   *)(strbuf));
          }
#line 1161
          if (_err___10) {
            {
#line 1161
            *errstr = report_error(conftype, linenr, _err___10);
#line 1161
            free_servparm(& server);
            }
#line 1161
            goto free_linebuf_return;
          }
          {
#line 1161
          p = getnextp(& linebuf, & buflen, in, p, & linenr, & getnextperr);
          }
#line 1161
          if (! p) {
            {
#line 1161
            free_servparm(& server);
            }
#line 1161
            goto unexpected_eof;
          }
#line 1161
          if ((int )*p != 44) {
#line 1161
            goto while_break___37;
          }
          {
#line 1161
          p ++;
#line 1161
          p = getnextp(& linebuf, & buflen, in, p, & linenr, & getnextperr);
          }
#line 1161
          if (! p) {
            {
#line 1161
            free_servparm(& server);
            }
#line 1161
            goto unexpected_eof;
          }
        }
        while_break___37: /* CIL Label */ ;
        }
#line 1162
        goto switch_break___1;
        case_67: /* CIL Label */ 
        {
#line 1166
        tmp___102 = __ctype_b_loc();
        }
#line 1166
        if ((int const   )*(*tmp___102 + (int )*p) & 1024) {
#line 1166
          _str___23 = p;
          {
#line 1166
          while (1) {
            while_continue___38: /* CIL Label */ ;
#line 1166
            p ++;
#line 1166
            if (*p) {
              {
#line 1166
              tmp___101 = __ctype_b_loc();
              }
#line 1166
              if (! ((int const   )*(*tmp___101 + (int )*p) & 8)) {
#line 1166
                if (! ((int )*p == 95)) {
#line 1166
                  goto while_break___38;
                }
              }
            } else {
#line 1166
              goto while_break___38;
            }
          }
          while_break___38: /* CIL Label */ ;
          }
          {
#line 1166
          _len___23 = (size_t )(p - _str___23);
#line 1166
          cnst___14 = lookup_const((char const   *)_str___23, (int )_len___23);
          }
#line 1166
          if (! (cnst___14 == 24)) {
#line 1166
            if (! (cnst___14 == 25)) {
#line 1166
              goto ASSIGN_CONST_1166;
            }
          }
        } else {
          ASSIGN_CONST_1166: 
          {
#line 1166
          *errstr = report_error(conftype, linenr, "bad qualifier in reject_policy= option.");
#line 1166
          free_servparm(& server);
          }
#line 1166
          goto free_linebuf_return;
        }
#line 1167
        server.rejectpolicy = (short )cnst___14;
#line 1169
        goto switch_break___1;
        case_68: /* CIL Label */ 
        {
#line 1172
        tmp___104 = __ctype_b_loc();
        }
#line 1172
        if ((int const   )*(*tmp___104 + (int )*p) & 1024) {
#line 1172
          _str___24 = p;
          {
#line 1172
          while (1) {
            while_continue___39: /* CIL Label */ ;
#line 1172
            p ++;
#line 1172
            if (*p) {
              {
#line 1172
              tmp___103 = __ctype_b_loc();
              }
#line 1172
              if (! ((int const   )*(*tmp___103 + (int )*p) & 8)) {
#line 1172
                if (! ((int )*p == 95)) {
#line 1172
                  goto while_break___39;
                }
              }
            } else {
#line 1172
              goto while_break___39;
            }
          }
          while_break___39: /* CIL Label */ ;
          }
          {
#line 1172
          _len___24 = (size_t )(p - _str___24);
#line 1172
          _cnst___12 = lookup_const((char const   *)_str___24, (int )_len___24);
          }
#line 1172
          if (_cnst___12 == 1) {
#line 1172
            server.rejectrecursively = (char )(_cnst___12 == 1);
          } else
#line 1172
          if (_cnst___12 == 2) {
#line 1172
            server.rejectrecursively = (char )(_cnst___12 == 1);
          } else {
#line 1172
            goto ASSIGN_ON_OFF_1172;
          }
        } else {
          ASSIGN_ON_OFF_1172: 
          {
#line 1172
          *errstr = report_error(conftype, linenr, "bad qualifier in reject_recursively= option.");
#line 1172
          free_servparm(& server);
          }
#line 1172
          goto free_linebuf_return;
        }
#line 1173
        goto switch_break___1;
        case_69: /* CIL Label */ 
        {
#line 1176
        len = scan_string(& p, strbuf, (unsigned int )sizeof(strbuf), & scanstrerr);
        }
#line 1176
        if (len == -1) {
          {
#line 1176
          free_servparm(& server);
          }
#line 1176
          goto string_err;
        } else
#line 1176
        if ((unsigned long )len >= sizeof(strbuf)) {
          {
#line 1176
          free_servparm(& server);
          }
#line 1176
          goto string_too_long;
        }
#line 1177
        if (server.label) {
          {
#line 1177
          free((void *)server.label);
          }
        }
        {
#line 1177
        server.label = strndup((char const   *)(strbuf), (size_t )len);
        }
#line 1177
        if (! server.label) {
          {
#line 1177
          free_servparm(& server);
          }
#line 1177
          goto out_of_memory;
        }
#line 1178
        goto switch_break___1;
        switch_default___0: /* CIL Label */ 
        {
#line 1181
        free_servparm(& server);
        }
#line 1181
        goto internal_parse_error;
        switch_break___1: /* CIL Label */ ;
        }
        {
#line 1184
        p = getnextp(& linebuf, & buflen, in, p, & linenr, & getnextperr);
        }
#line 1184
        if (! p) {
          {
#line 1184
          free_servparm(& server);
          }
#line 1184
          goto unexpected_eof;
        }
#line 1185
        if ((int )*p != 59) {
          {
#line 1185
          free_servparm(& server);
          }
#line 1185
          goto expected_semicolon;
        }
        {
#line 1186
        p ++;
#line 1187
        p = getnextp(& linebuf, & buflen, in, p, & linenr, & getnextperr);
        }
#line 1187
        if (! p) {
          {
#line 1187
          free_servparm(& server);
          }
#line 1187
          goto unexpected_eof;
        }
      }
      while_break___20: /* CIL Label */ ;
      }
#line 1190
      if ((int )*p != 125) {
        {
#line 1190
        free_servparm(& server);
        }
#line 1190
        goto expected_closing_brace;
      }
#line 1191
      if ((int )server.uptest == 7) {
#line 1192
        if (! server.uptest_cmd) {
          {
#line 1193
          *errstr = report_error(conftype, linenr, "you must specify uptest_cmd if you specify uptest=exec!");
#line 1194
          free_servparm(& server);
          }
#line 1194
          goto free_linebuf_return;
        }
      }
#line 1197
      if (server.is_proxy) {
#line 1197
        if (server.rootserver) {
          {
#line 1198
          *errstr = report_error(conftype, linenr, "A server may not be specified as both a proxy and a root-server.");
#line 1199
          free_servparm(& server);
          }
#line 1199
          goto free_linebuf_return;
        }
      }
#line 1201
      if (server.rootserver) {
#line 1201
        if ((int )server.policy == 20) {
          {
#line 1202
          tmp___106 = const_name((int )server.policy);
#line 1202
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Warning: using policy=%s with a root-server usually makes no sense.",
                  tmp___106);
          }
        } else
#line 1201
        if ((int )server.policy == 21) {
          {
#line 1202
          tmp___106 = const_name((int )server.policy);
#line 1202
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Warning: using policy=%s with a root-server usually makes no sense.",
                  tmp___106);
          }
        }
      }
      {
#line 1204
      tmp___108 = da_nel((darray )server.atup_a);
      }
#line 1204
      if (tmp___108) {
        {
#line 1205
        check_localaddrs(& server);
#line 1206
        tmp___107 = da_nel((darray )server.atup_a);
        }
#line 1206
        if (! tmp___107) {
          {
#line 1207
          *errstr = report_error(conftype, linenr, "Server section contains only local IP addresses.\nBind pdnsd to a different local IP address or specify different port numbers in global section and server section if you want pdnsd to query servers on the same machine.");
#line 1211
          free_servparm(& server);
          }
#line 1211
          goto free_linebuf_return;
        }
      }
      {
#line 1215
      tmp___109 = da_nel((darray )server.atup_a);
#line 1215
      n = (int )tmp___109;
#line 1216
      j = 0;
      }
      {
#line 1216
      while (1) {
        while_continue___40: /* CIL Label */ ;
#line 1216
        if (! (j < n)) {
#line 1216
          goto while_break___40;
        }
#line 1217
        at = & (server.atup_a)->elem[j];
#line 1218
        at->is_up = server.preset;
#line 1220
        if (server.interval < 0L) {
          {
#line 1220
          at->i_ts = time((time_t *)((void *)0));
          }
        }
#line 1216
        j ++;
      }
      while_break___40: /* CIL Label */ ;
      }
#line 1223
      if (server.interval == -1L) {
#line 1223
        global___0->onquery = (char)1;
      }
      {
#line 1225
      tmp___111 = da_grow1((darray )*servers___0, (size_t )(((servparm_array )0)->elem),
                           sizeof((*servers___0)->elem[0]), (void (*)(void * ))(& free_servparm));
#line 1225
      tmp___110 = (servparm_array )tmp___111;
#line 1225
      *servers___0 = tmp___110;
      }
#line 1225
      if (! tmp___110) {
        {
#line 1226
        free_servparm(& server);
        }
#line 1226
        goto out_of_memory;
      }
#line 1228
      (*servers___0)->elem[(*servers___0)->nel - 1UL] = server;
#line 1232
      goto switch_break;
      case_3: /* CIL Label */ 
#line 1237
      c_cent.qname = (unsigned char *)0;
#line 1237
      c_cent.cs = 0UL;
#line 1237
      c_cent.num_rrs = (unsigned short)0;
#line 1237
      c_cent.flags = (unsigned short)0;
#line 1237
      c_cent.__annonCompField2.rr.rrmu[0] = (rr_set_t *)0;
#line 1237
      c_cent.__annonCompField2.rr.rrmu[1] = (rr_set_t *)0;
#line 1237
      c_cent.__annonCompField2.rr.rrmu[2] = (rr_set_t *)0;
#line 1237
      c_cent.__annonCompField2.rr.rrmu[3] = (rr_set_t *)0;
#line 1237
      c_cent.__annonCompField2.rr.rrmu[4] = (rr_set_t *)0;
#line 1237
      c_cent.__annonCompField2.rr.rrmu[5] = (rr_set_t *)0;
#line 1237
      c_cent.__annonCompField2.rr.rrmu[6] = (rr_set_t *)0;
#line 1237
      c_cent.__annonCompField2.rr.rrmu[7] = (rr_set_t *)0;
#line 1237
      c_cent.__annonCompField2.rr.rrext = (rr_set_t **)0;
#line 1237
      c_cent.c_ns = (unsigned char)0;
#line 1237
      c_cent.c_soa = (unsigned char)0;
#line 1238
      c_ttl = (time_t )86400;
#line 1239
      c_flags = 2U;
#line 1240
      reverse = (unsigned char)0;
      {
#line 1245
      while (1) {
        while_continue___41: /* CIL Label */ ;
        {
#line 1245
        tmp___162 = __ctype_b_loc();
        }
#line 1245
        if (! ((int const   )*(*tmp___162 + (int )*p) & 1024)) {
#line 1245
          goto while_break___41;
        }
#line 1246
        ps = p;
        {
#line 1246
        while (1) {
          while_continue___42: /* CIL Label */ ;
#line 1246
          p ++;
#line 1246
          if (*p) {
            {
#line 1246
            tmp___112 = __ctype_b_loc();
            }
#line 1246
            if (! ((int const   )*(*tmp___112 + (int )*p) & 8)) {
#line 1246
              if (! ((int )*p == 95)) {
#line 1246
                goto while_break___42;
              }
            }
          } else {
#line 1246
            goto while_break___42;
          }
        }
        while_break___42: /* CIL Label */ ;
        }
        {
#line 1246
        len = (int )(p - ps);
#line 1247
        option = binsearch_keyword((char const   *)ps, len, rr_options, (int )(sizeof(rr_options) / sizeof(namevalue_t )));
        }
#line 1248
        if (! option) {
          {
#line 1249
          *errstr = report_errorf(conftype, linenr, "invalid option for rr section: %.*s",
                                  len, ps);
#line 1250
          free_cent(& c_cent);
          }
#line 1250
          goto free_linebuf_return;
        }
        {
#line 1252
        p = getnextp(& linebuf, & buflen, in, p, & linenr, & getnextperr);
        }
#line 1252
        if (! p) {
          {
#line 1252
          free_cent(& c_cent);
          }
#line 1252
          goto unexpected_eof;
        }
#line 1253
        if ((int )*p != 61) {
          {
#line 1253
          free_cent(& c_cent);
          }
#line 1253
          goto expected_equals;
        }
        {
#line 1254
        p ++;
#line 1255
        p = getnextp(& linebuf, & buflen, in, p, & linenr, & getnextperr);
        }
#line 1255
        if (! p) {
          {
#line 1255
          free_cent(& c_cent);
          }
#line 1255
          goto unexpected_eof;
        }
        {
#line 1259
        if (option == 77) {
#line 1259
          goto case_77;
        }
#line 1272
        if (option == 79) {
#line 1272
          goto case_79;
        }
#line 1276
        if (option == 83) {
#line 1276
          goto case_83;
        }
#line 1287
        if (option == 84) {
#line 1287
          goto case_84;
        }
#line 1291
        if (option == 70) {
#line 1291
          goto case_70;
        }
#line 1320
        if (option == 78) {
#line 1320
          goto case_78;
        }
#line 1323
        if (option == 74) {
#line 1323
          goto case_74;
        }
#line 1326
        if (option == 71) {
#line 1326
          goto case_71;
        }
#line 1341
        if (option == 72) {
#line 1341
          goto case_72;
        }
#line 1360
        if (option == 73) {
#line 1360
          goto case_73;
        }
#line 1399
        if (option == 76) {
#line 1399
          goto case_76;
        }
#line 1407
        if (option == 75) {
#line 1407
          goto case_75;
        }
#line 1472
        goto switch_default___1;
        case_77: /* CIL Label */ 
#line 1261
        if (c_cent.qname) {
          {
#line 1262
          *errstr = report_error(conftype, linenr, "You may specify only one name in a rr section.");
#line 1263
          free_cent(& c_cent);
          }
#line 1263
          goto free_linebuf_return;
        }
        {
#line 1265
        len = scan_string(& p, strbuf, (unsigned int )sizeof(strbuf), & scanstrerr);
        }
#line 1265
        if (len == -1) {
          {
#line 1265
          free_cent(& c_cent);
          }
#line 1265
          goto string_err;
        } else
#line 1265
        if ((unsigned long )len >= sizeof(strbuf)) {
          {
#line 1265
          free_cent(& c_cent);
          }
#line 1265
          goto string_too_long;
        }
        {
#line 1266
        _err___11 = parsestr2rhn((unsigned char const   *)((unsigned char *)(strbuf)),
                                 (unsigned int )len, c_name);
        }
#line 1266
        if (_err___11) {
          {
#line 1266
          *errstr = report_error(conftype, linenr, _err___11);
#line 1266
          free_cent(& c_cent);
          }
#line 1266
          goto free_linebuf_return;
        }
        {
#line 1267
        tmp___113 = init_cent(& c_cent, (unsigned char const   *)(c_name), (time_t )0,
                              (time_t )0, c_flags);
        }
#line 1267
        if (! tmp___113) {
#line 1268
          goto out_of_memory;
        }
#line 1270
        goto switch_break___2;
        case_79: /* CIL Label */ 
        {
#line 1273
        tmp___114 = __ctype_b_loc();
        }
#line 1273
        if ((int const   )*(*tmp___114 + (int )*p) & 2048) {
          {
#line 1273
          c_ttl = strtotime(p, & p, & _err___12);
          }
#line 1273
          if (_err___12) {
            {
#line 1273
            *errstr = report_errorf(conftype, linenr, "invalid time specification for %s: %s",
                                    "ttl option", _err___12);
#line 1273
            free_cent(& c_cent);
            }
#line 1273
            goto free_linebuf_return;
          }
        } else {
          {
#line 1273
          *errstr = report_error(conftype, linenr, "expected a time specification for ttl option");
#line 1273
          free_cent(& c_cent);
          }
#line 1273
          goto free_linebuf_return;
        }
#line 1274
        goto switch_break___2;
        case_83: /* CIL Label */ 
#line 1278
        if (c_cent.qname) {
          {
#line 1279
          *errstr = report_error(conftype, linenr, "The authrec= option has no effect unless it precedes name= in a rr section.");
#line 1280
          free_cent(& c_cent);
          }
#line 1280
          goto free_linebuf_return;
        }
        {
#line 1282
        tmp___116 = __ctype_b_loc();
        }
#line 1282
        if ((int const   )*(*tmp___116 + (int )*p) & 1024) {
#line 1282
          _str___25 = p;
          {
#line 1282
          while (1) {
            while_continue___43: /* CIL Label */ ;
#line 1282
            p ++;
#line 1282
            if (*p) {
              {
#line 1282
              tmp___115 = __ctype_b_loc();
              }
#line 1282
              if (! ((int const   )*(*tmp___115 + (int )*p) & 8)) {
#line 1282
                if (! ((int )*p == 95)) {
#line 1282
                  goto while_break___43;
                }
              }
            } else {
#line 1282
              goto while_break___43;
            }
          }
          while_break___43: /* CIL Label */ ;
          }
          {
#line 1282
          _len___25 = (size_t )(p - _str___25);
#line 1282
          cnst___15 = lookup_const((char const   *)_str___25, (int )_len___25);
          }
#line 1282
          if (! (cnst___15 == 1)) {
#line 1282
            if (! (cnst___15 == 2)) {
#line 1282
              goto ASSIGN_CONST_1282;
            }
          }
        } else {
          ASSIGN_CONST_1282: 
          {
#line 1282
          *errstr = report_error(conftype, linenr, "Bad qualifier in authrec= option.");
#line 1282
          free_cent(& c_cent);
          }
#line 1282
          goto free_linebuf_return;
        }
#line 1283
        if (cnst___15 == 1) {
#line 1283
          c_flags = 2U;
        } else {
#line 1283
          c_flags = 0U;
        }
#line 1285
        goto switch_break___2;
        case_84: /* CIL Label */ 
        {
#line 1288
        tmp___118 = __ctype_b_loc();
        }
#line 1288
        if ((int const   )*(*tmp___118 + (int )*p) & 1024) {
#line 1288
          _str___26 = p;
          {
#line 1288
          while (1) {
            while_continue___44: /* CIL Label */ ;
#line 1288
            p ++;
#line 1288
            if (*p) {
              {
#line 1288
              tmp___117 = __ctype_b_loc();
              }
#line 1288
              if (! ((int const   )*(*tmp___117 + (int )*p) & 8)) {
#line 1288
                if (! ((int )*p == 95)) {
#line 1288
                  goto while_break___44;
                }
              }
            } else {
#line 1288
              goto while_break___44;
            }
          }
          while_break___44: /* CIL Label */ ;
          }
          {
#line 1288
          _len___26 = (size_t )(p - _str___26);
#line 1288
          _cnst___13 = lookup_const((char const   *)_str___26, (int )_len___26);
          }
#line 1288
          if (_cnst___13 == 1) {
#line 1288
            reverse = (unsigned char )(_cnst___13 == 1);
          } else
#line 1288
          if (_cnst___13 == 2) {
#line 1288
            reverse = (unsigned char )(_cnst___13 == 1);
          } else {
#line 1288
            goto ASSIGN_ON_OFF_1288;
          }
        } else {
          ASSIGN_ON_OFF_1288: 
          {
#line 1288
          *errstr = report_error(conftype, linenr, "bad qualifier in reverse= option.");
#line 1288
          free_cent(& c_cent);
          }
#line 1288
          goto free_linebuf_return;
        }
#line 1289
        goto switch_break___2;
        case_70: /* CIL Label */ 
#line 1295
        if (! c_cent.qname) {
#line 1296
          goto no_name_spec;
        }
        {
#line 1297
        len = scan_string(& p, strbuf, (unsigned int )sizeof(strbuf), & scanstrerr);
        }
#line 1297
        if (len == -1) {
          {
#line 1297
          free_cent(& c_cent);
          }
#line 1297
          goto string_err;
        } else
#line 1297
        if ((unsigned long )len >= sizeof(strbuf)) {
          {
#line 1297
          free_cent(& c_cent);
          }
#line 1297
          goto string_too_long;
        }
        {
#line 1298
        tmp___120 = inet_aton((char const   *)(strbuf), & c_a.ipv4);
        }
#line 1298
        if (tmp___120) {
#line 1299
          tp = 1;
#line 1300
          sz___0 = (unsigned int )sizeof(struct in_addr );
        } else {
          {
#line 1304
          tmp___119 = inet_pton(10, (char const   */* __restrict  */)(strbuf), (void */* __restrict  */)(& c_a.ipv6));
          }
#line 1304
          if (tmp___119 > 0) {
#line 1305
            tp = 28;
#line 1306
            sz___0 = (unsigned int )sizeof(struct in6_addr );
          } else {
            {
#line 1311
            *errstr = report_error(conftype, linenr, "bad IP address in a= option.");
#line 1312
            free_cent(& c_cent);
            }
#line 1312
            goto free_linebuf_return;
          }
        }
        {
#line 1315
        tmp___121 = add_cent_rr(& c_cent, tp, c_ttl, (time_t )0, 2U, sz___0, (void *)(& c_a));
        }
#line 1315
        if (! tmp___121) {
#line 1316
          goto add_rr_failed;
        }
#line 1318
        goto switch_break___2;
        case_78: /* CIL Label */ 
#line 1321
        tp = 2;
#line 1322
        goto scan_name;
        case_74: /* CIL Label */ 
#line 1324
        tp = 5;
#line 1325
        goto scan_name;
        case_71: /* CIL Label */ 
#line 1327
        tp = 12;
        scan_name: 
#line 1332
        if (! c_cent.qname) {
#line 1333
          goto no_name_spec;
        }
        {
#line 1334
        len = scan_string(& p, strbuf, (unsigned int )sizeof(strbuf), & scanstrerr);
        }
#line 1334
        if (len == -1) {
          {
#line 1334
          free_cent(& c_cent);
          }
#line 1334
          goto string_err;
        } else
#line 1334
        if ((unsigned long )len >= sizeof(strbuf)) {
          {
#line 1334
          free_cent(& c_cent);
          }
#line 1334
          goto string_too_long;
        }
        {
#line 1335
        _err___13 = parsestr2rhn((unsigned char const   *)((unsigned char *)(strbuf)),
                                 (unsigned int )len, c_name___0);
        }
#line 1335
        if (_err___13) {
          {
#line 1335
          *errstr = report_error(conftype, linenr, _err___13);
#line 1335
          free_cent(& c_cent);
          }
#line 1335
          goto free_linebuf_return;
        }
        {
#line 1336
        tmp___122 = rhnlen((unsigned char const   *)(c_name___0));
#line 1336
        tmp___123 = add_cent_rr(& c_cent, tp, c_ttl, (time_t )0, 2U, tmp___122, (void *)(c_name___0));
        }
#line 1336
        if (! tmp___123) {
#line 1337
          goto add_rr_failed;
        }
#line 1339
        goto switch_break___2;
        case_72: /* CIL Label */ 
#line 1346
        if (! c_cent.qname) {
#line 1347
          goto no_name_spec;
        }
        {
#line 1348
        cp = c_mx + 2;
#line 1349
        len = scan_string(& p, strbuf, (unsigned int )sizeof(strbuf), & scanstrerr);
        }
#line 1349
        if (len == -1) {
          {
#line 1349
          free_cent(& c_cent);
          }
#line 1349
          goto string_err;
        } else
#line 1349
        if ((unsigned long )len >= sizeof(strbuf)) {
          {
#line 1349
          free_cent(& c_cent);
          }
#line 1349
          goto string_too_long;
        }
        {
#line 1350
        _err___14 = parsestr2rhn((unsigned char const   *)((unsigned char *)(strbuf)),
                                 (unsigned int )len, cp);
        }
#line 1350
        if (_err___14) {
          {
#line 1350
          *errstr = report_error(conftype, linenr, _err___14);
#line 1350
          free_cent(& c_cent);
          }
#line 1350
          goto free_linebuf_return;
        }
        {
#line 1351
        p = getnextp(& linebuf, & buflen, in, p, & linenr, & getnextperr);
        }
#line 1351
        if (! p) {
          {
#line 1351
          free_cent(& c_cent);
          }
#line 1351
          goto unexpected_eof;
        }
#line 1351
        if ((int )*p != 44) {
          {
#line 1351
          *errstr = report_error(conftype, linenr, "missing second argument (preference level) of mx= option");
#line 1351
          free_cent(& c_cent);
          }
#line 1351
          goto free_linebuf_return;
        }
        {
#line 1351
        p ++;
#line 1351
        p = getnextp(& linebuf, & buflen, in, p, & linenr, & getnextperr);
        }
#line 1351
        if (! p) {
          {
#line 1351
          free_cent(& c_cent);
          }
#line 1351
          goto unexpected_eof;
        }
        {
#line 1352
        tmp___125 = __ctype_b_loc();
        }
#line 1352
        if ((int const   )*(*tmp___125 + (int )*p) & 2048) {
          {
#line 1352
          tmp___124 = strtol((char const   */* __restrict  */)p, (char **/* __restrict  */)(& p),
                             0);
#line 1352
          pref = (unsigned int )tmp___124;
          }
        } else {
          {
#line 1352
          *errstr = report_error(conftype, linenr, "expected unsigned integer value for second argument of mx= option");
#line 1352
          free_cent(& c_cent);
          }
#line 1352
          goto free_linebuf_return;
        }
#line 1353
        cp = c_mx;
        {
#line 1354
        while (1) {
          while_continue___45: /* CIL Label */ ;
#line 1354
          t_s = (uint16_t )pref;
#line 1354
          t_cp = cp;
#line 1354
          tmp___126 = t_cp;
#line 1354
          t_cp ++;
#line 1354
          *tmp___126 = (unsigned char )((int )t_s >> 8);
#line 1354
          tmp___127 = t_cp;
#line 1354
          t_cp ++;
#line 1354
          *tmp___127 = (unsigned char )t_s;
#line 1354
          cp = (unsigned char *)((void *)t_cp);
#line 1354
          goto while_break___45;
        }
        while_break___45: /* CIL Label */ ;
        }
        {
#line 1355
        tmp___128 = rhnlen((unsigned char const   *)cp);
#line 1355
        tmp___129 = add_cent_rr(& c_cent, 15, c_ttl, (time_t )0, 2U, 2U + tmp___128,
                                (void *)(c_mx));
        }
#line 1355
        if (! tmp___129) {
#line 1356
          goto add_rr_failed;
        }
#line 1358
        goto switch_break___2;
        case_73: /* CIL Label */ 
#line 1366
        if (! c_cent.qname) {
#line 1367
          goto no_name_spec;
        }
        {
#line 1368
        len = scan_string(& p, strbuf, (unsigned int )sizeof(strbuf), & scanstrerr);
        }
#line 1368
        if (len == -1) {
          {
#line 1368
          free_cent(& c_cent);
          }
#line 1368
          goto string_err;
        } else
#line 1368
        if ((unsigned long )len >= sizeof(strbuf)) {
          {
#line 1368
          free_cent(& c_cent);
          }
#line 1368
          goto string_too_long;
        }
        {
#line 1369
        _err___15 = parsestr2rhn((unsigned char const   *)((unsigned char *)(strbuf)),
                                 (unsigned int )len, buf);
        }
#line 1369
        if (_err___15) {
          {
#line 1369
          *errstr = report_error(conftype, linenr, _err___15);
#line 1369
          free_cent(& c_cent);
          }
#line 1369
          goto free_linebuf_return;
        }
        {
#line 1370
        rlen = rhnlen((unsigned char const   *)(buf));
#line 1371
        blen = rlen;
#line 1372
        bp = buf + rlen;
#line 1373
        p = getnextp(& linebuf, & buflen, in, p, & linenr, & getnextperr);
        }
#line 1373
        if (! p) {
          {
#line 1373
          free_cent(& c_cent);
          }
#line 1373
          goto unexpected_eof;
        }
#line 1373
        if ((int )*p != 44) {
          {
#line 1373
          *errstr = report_error(conftype, linenr, "missing 2nd argument of soa= option");
#line 1373
          free_cent(& c_cent);
          }
#line 1373
          goto free_linebuf_return;
        }
        {
#line 1373
        p ++;
#line 1373
        p = getnextp(& linebuf, & buflen, in, p, & linenr, & getnextperr);
        }
#line 1373
        if (! p) {
          {
#line 1373
          free_cent(& c_cent);
          }
#line 1373
          goto unexpected_eof;
        }
        {
#line 1374
        len = scan_string(& p, strbuf, (unsigned int )sizeof(strbuf), & scanstrerr);
        }
#line 1374
        if (len == -1) {
          {
#line 1374
          free_cent(& c_cent);
          }
#line 1374
          goto string_err;
        } else
#line 1374
        if ((unsigned long )len >= sizeof(strbuf)) {
          {
#line 1374
          free_cent(& c_cent);
          }
#line 1374
          goto string_too_long;
        }
        {
#line 1375
        _err___16 = parsestr2rhn((unsigned char const   *)((unsigned char *)(strbuf)),
                                 (unsigned int )len, bp);
        }
#line 1375
        if (_err___16) {
          {
#line 1375
          *errstr = report_error(conftype, linenr, _err___16);
#line 1375
          free_cent(& c_cent);
          }
#line 1375
          goto free_linebuf_return;
        }
        {
#line 1376
        rlen = rhnlen((unsigned char const   *)bp);
#line 1377
        blen += rlen;
#line 1378
        bp += rlen;
#line 1379
        p = getnextp(& linebuf, & buflen, in, p, & linenr, & getnextperr);
        }
#line 1379
        if (! p) {
          {
#line 1379
          free_cent(& c_cent);
          }
#line 1379
          goto unexpected_eof;
        }
#line 1379
        if ((int )*p != 44) {
          {
#line 1379
          *errstr = report_error(conftype, linenr, "missing 3rd argument of soa= option");
#line 1379
          free_cent(& c_cent);
          }
#line 1379
          goto free_linebuf_return;
        }
        {
#line 1379
        p ++;
#line 1379
        p = getnextp(& linebuf, & buflen, in, p, & linenr, & getnextperr);
        }
#line 1379
        if (! p) {
          {
#line 1379
          free_cent(& c_cent);
          }
#line 1379
          goto unexpected_eof;
        }
        {
#line 1380
        tmp___131 = __ctype_b_loc();
        }
#line 1380
        if ((int const   )*(*tmp___131 + (int )*p) & 2048) {
          {
#line 1380
          tmp___130 = strtol((char const   */* __restrict  */)p, (char **/* __restrict  */)(& p),
                             0);
#line 1380
          val___4 = (uint32_t )tmp___130;
          }
        } else {
          {
#line 1380
          *errstr = report_error(conftype, linenr, "expected unsigned integer value for 3rd argument of soa= option");
#line 1380
          free_cent(& c_cent);
          }
#line 1380
          goto free_linebuf_return;
        }
        {
#line 1381
        while (1) {
          while_continue___46: /* CIL Label */ ;
#line 1381
          t_l = val___4;
#line 1381
          t_cp___0 = bp;
#line 1381
          tmp___132 = t_cp___0;
#line 1381
          t_cp___0 ++;
#line 1381
          *tmp___132 = (unsigned char )(t_l >> 24);
#line 1381
          tmp___133 = t_cp___0;
#line 1381
          t_cp___0 ++;
#line 1381
          *tmp___133 = (unsigned char )(t_l >> 16);
#line 1381
          tmp___134 = t_cp___0;
#line 1381
          t_cp___0 ++;
#line 1381
          *tmp___134 = (unsigned char )(t_l >> 8);
#line 1381
          tmp___135 = t_cp___0;
#line 1381
          t_cp___0 ++;
#line 1381
          *tmp___135 = (unsigned char )t_l;
#line 1381
          bp = (unsigned char *)((void *)t_cp___0);
#line 1381
          goto while_break___46;
        }
        while_break___46: /* CIL Label */ ;
        }
        {
#line 1382
        p = getnextp(& linebuf, & buflen, in, p, & linenr, & getnextperr);
        }
#line 1382
        if (! p) {
          {
#line 1382
          free_cent(& c_cent);
          }
#line 1382
          goto unexpected_eof;
        }
#line 1382
        if ((int )*p != 44) {
          {
#line 1382
          *errstr = report_error(conftype, linenr, "missing 4th argument of soa= option");
#line 1382
          free_cent(& c_cent);
          }
#line 1382
          goto free_linebuf_return;
        }
        {
#line 1382
        p ++;
#line 1382
        p = getnextp(& linebuf, & buflen, in, p, & linenr, & getnextperr);
        }
#line 1382
        if (! p) {
          {
#line 1382
          free_cent(& c_cent);
          }
#line 1382
          goto unexpected_eof;
        }
        {
#line 1383
        tmp___137 = __ctype_b_loc();
        }
#line 1383
        if ((int const   )*(*tmp___137 + (int )*p) & 2048) {
          {
#line 1383
          tmp___136 = strtotime(p, & p, & _err___17);
#line 1383
          val___4 = (uint32_t )tmp___136;
          }
#line 1383
          if (_err___17) {
            {
#line 1383
            *errstr = report_errorf(conftype, linenr, "invalid time specification for %s: %s",
                                    "4th argument of soa= option", _err___17);
#line 1383
            free_cent(& c_cent);
            }
#line 1383
            goto free_linebuf_return;
          }
        } else {
          {
#line 1383
          *errstr = report_error(conftype, linenr, "expected a time specification for 4th argument of soa= option");
#line 1383
          free_cent(& c_cent);
          }
#line 1383
          goto free_linebuf_return;
        }
        {
#line 1384
        while (1) {
          while_continue___47: /* CIL Label */ ;
#line 1384
          t_l___0 = val___4;
#line 1384
          t_cp___1 = bp;
#line 1384
          tmp___138 = t_cp___1;
#line 1384
          t_cp___1 ++;
#line 1384
          *tmp___138 = (unsigned char )(t_l___0 >> 24);
#line 1384
          tmp___139 = t_cp___1;
#line 1384
          t_cp___1 ++;
#line 1384
          *tmp___139 = (unsigned char )(t_l___0 >> 16);
#line 1384
          tmp___140 = t_cp___1;
#line 1384
          t_cp___1 ++;
#line 1384
          *tmp___140 = (unsigned char )(t_l___0 >> 8);
#line 1384
          tmp___141 = t_cp___1;
#line 1384
          t_cp___1 ++;
#line 1384
          *tmp___141 = (unsigned char )t_l___0;
#line 1384
          bp = (unsigned char *)((void *)t_cp___1);
#line 1384
          goto while_break___47;
        }
        while_break___47: /* CIL Label */ ;
        }
        {
#line 1385
        p = getnextp(& linebuf, & buflen, in, p, & linenr, & getnextperr);
        }
#line 1385
        if (! p) {
          {
#line 1385
          free_cent(& c_cent);
          }
#line 1385
          goto unexpected_eof;
        }
#line 1385
        if ((int )*p != 44) {
          {
#line 1385
          *errstr = report_error(conftype, linenr, "missing 5th argument of soa= option");
#line 1385
          free_cent(& c_cent);
          }
#line 1385
          goto free_linebuf_return;
        }
        {
#line 1385
        p ++;
#line 1385
        p = getnextp(& linebuf, & buflen, in, p, & linenr, & getnextperr);
        }
#line 1385
        if (! p) {
          {
#line 1385
          free_cent(& c_cent);
          }
#line 1385
          goto unexpected_eof;
        }
        {
#line 1386
        tmp___143 = __ctype_b_loc();
        }
#line 1386
        if ((int const   )*(*tmp___143 + (int )*p) & 2048) {
          {
#line 1386
          tmp___142 = strtotime(p, & p, & _err___18);
#line 1386
          val___4 = (uint32_t )tmp___142;
          }
#line 1386
          if (_err___18) {
            {
#line 1386
            *errstr = report_errorf(conftype, linenr, "invalid time specification for %s: %s",
                                    "5th argument of soa= option", _err___18);
#line 1386
            free_cent(& c_cent);
            }
#line 1386
            goto free_linebuf_return;
          }
        } else {
          {
#line 1386
          *errstr = report_error(conftype, linenr, "expected a time specification for 5th argument of soa= option");
#line 1386
          free_cent(& c_cent);
          }
#line 1386
          goto free_linebuf_return;
        }
        {
#line 1387
        while (1) {
          while_continue___48: /* CIL Label */ ;
#line 1387
          t_l___1 = val___4;
#line 1387
          t_cp___2 = bp;
#line 1387
          tmp___144 = t_cp___2;
#line 1387
          t_cp___2 ++;
#line 1387
          *tmp___144 = (unsigned char )(t_l___1 >> 24);
#line 1387
          tmp___145 = t_cp___2;
#line 1387
          t_cp___2 ++;
#line 1387
          *tmp___145 = (unsigned char )(t_l___1 >> 16);
#line 1387
          tmp___146 = t_cp___2;
#line 1387
          t_cp___2 ++;
#line 1387
          *tmp___146 = (unsigned char )(t_l___1 >> 8);
#line 1387
          tmp___147 = t_cp___2;
#line 1387
          t_cp___2 ++;
#line 1387
          *tmp___147 = (unsigned char )t_l___1;
#line 1387
          bp = (unsigned char *)((void *)t_cp___2);
#line 1387
          goto while_break___48;
        }
        while_break___48: /* CIL Label */ ;
        }
        {
#line 1388
        p = getnextp(& linebuf, & buflen, in, p, & linenr, & getnextperr);
        }
#line 1388
        if (! p) {
          {
#line 1388
          free_cent(& c_cent);
          }
#line 1388
          goto unexpected_eof;
        }
#line 1388
        if ((int )*p != 44) {
          {
#line 1388
          *errstr = report_error(conftype, linenr, "missing 6th argument of soa= option");
#line 1388
          free_cent(& c_cent);
          }
#line 1388
          goto free_linebuf_return;
        }
        {
#line 1388
        p ++;
#line 1388
        p = getnextp(& linebuf, & buflen, in, p, & linenr, & getnextperr);
        }
#line 1388
        if (! p) {
          {
#line 1388
          free_cent(& c_cent);
          }
#line 1388
          goto unexpected_eof;
        }
        {
#line 1389
        tmp___149 = __ctype_b_loc();
        }
#line 1389
        if ((int const   )*(*tmp___149 + (int )*p) & 2048) {
          {
#line 1389
          tmp___148 = strtotime(p, & p, & _err___19);
#line 1389
          val___4 = (uint32_t )tmp___148;
          }
#line 1389
          if (_err___19) {
            {
#line 1389
            *errstr = report_errorf(conftype, linenr, "invalid time specification for %s: %s",
                                    "6th argument of soa= option", _err___19);
#line 1389
            free_cent(& c_cent);
            }
#line 1389
            goto free_linebuf_return;
          }
        } else {
          {
#line 1389
          *errstr = report_error(conftype, linenr, "expected a time specification for 6th argument of soa= option");
#line 1389
          free_cent(& c_cent);
          }
#line 1389
          goto free_linebuf_return;
        }
        {
#line 1390
        while (1) {
          while_continue___49: /* CIL Label */ ;
#line 1390
          t_l___2 = val___4;
#line 1390
          t_cp___3 = bp;
#line 1390
          tmp___150 = t_cp___3;
#line 1390
          t_cp___3 ++;
#line 1390
          *tmp___150 = (unsigned char )(t_l___2 >> 24);
#line 1390
          tmp___151 = t_cp___3;
#line 1390
          t_cp___3 ++;
#line 1390
          *tmp___151 = (unsigned char )(t_l___2 >> 16);
#line 1390
          tmp___152 = t_cp___3;
#line 1390
          t_cp___3 ++;
#line 1390
          *tmp___152 = (unsigned char )(t_l___2 >> 8);
#line 1390
          tmp___153 = t_cp___3;
#line 1390
          t_cp___3 ++;
#line 1390
          *tmp___153 = (unsigned char )t_l___2;
#line 1390
          bp = (unsigned char *)((void *)t_cp___3);
#line 1390
          goto while_break___49;
        }
        while_break___49: /* CIL Label */ ;
        }
        {
#line 1391
        p = getnextp(& linebuf, & buflen, in, p, & linenr, & getnextperr);
        }
#line 1391
        if (! p) {
          {
#line 1391
          free_cent(& c_cent);
          }
#line 1391
          goto unexpected_eof;
        }
#line 1391
        if ((int )*p != 44) {
          {
#line 1391
          *errstr = report_error(conftype, linenr, "missing 7th argument of soa= option");
#line 1391
          free_cent(& c_cent);
          }
#line 1391
          goto free_linebuf_return;
        }
        {
#line 1391
        p ++;
#line 1391
        p = getnextp(& linebuf, & buflen, in, p, & linenr, & getnextperr);
        }
#line 1391
        if (! p) {
          {
#line 1391
          free_cent(& c_cent);
          }
#line 1391
          goto unexpected_eof;
        }
        {
#line 1392
        tmp___155 = __ctype_b_loc();
        }
#line 1392
        if ((int const   )*(*tmp___155 + (int )*p) & 2048) {
          {
#line 1392
          tmp___154 = strtotime(p, & p, & _err___20);
#line 1392
          val___4 = (uint32_t )tmp___154;
          }
#line 1392
          if (_err___20) {
            {
#line 1392
            *errstr = report_errorf(conftype, linenr, "invalid time specification for %s: %s",
                                    "7th argument of soa= option", _err___20);
#line 1392
            free_cent(& c_cent);
            }
#line 1392
            goto free_linebuf_return;
          }
        } else {
          {
#line 1392
          *errstr = report_error(conftype, linenr, "expected a time specification for 7th argument of soa= option");
#line 1392
          free_cent(& c_cent);
          }
#line 1392
          goto free_linebuf_return;
        }
        {
#line 1393
        while (1) {
          while_continue___50: /* CIL Label */ ;
#line 1393
          t_l___3 = val___4;
#line 1393
          t_cp___4 = bp;
#line 1393
          tmp___156 = t_cp___4;
#line 1393
          t_cp___4 ++;
#line 1393
          *tmp___156 = (unsigned char )(t_l___3 >> 24);
#line 1393
          tmp___157 = t_cp___4;
#line 1393
          t_cp___4 ++;
#line 1393
          *tmp___157 = (unsigned char )(t_l___3 >> 16);
#line 1393
          tmp___158 = t_cp___4;
#line 1393
          t_cp___4 ++;
#line 1393
          *tmp___158 = (unsigned char )(t_l___3 >> 8);
#line 1393
          tmp___159 = t_cp___4;
#line 1393
          t_cp___4 ++;
#line 1393
          *tmp___159 = (unsigned char )t_l___3;
#line 1393
          bp = (unsigned char *)((void *)t_cp___4);
#line 1393
          goto while_break___50;
        }
        while_break___50: /* CIL Label */ ;
        }
        {
#line 1394
        blen += 20U;
#line 1395
        tmp___160 = add_cent_rr(& c_cent, 6, c_ttl, (time_t )0, 2U, blen, (void *)(buf));
        }
#line 1395
        if (! tmp___160) {
#line 1396
          goto add_rr_failed;
        }
#line 1398
        goto switch_break___2;
        case_76: /* CIL Label */ 
        {
#line 1404
        *errstr = report_error(conftype, linenr, "Missing support for caching SPF records in rr section");
#line 1405
        free_cent(& c_cent);
        }
#line 1405
        goto free_linebuf_return;
        case_75: /* CIL Label */ 
#line 1409
        tp = 16;
#line 1409
        tpname = "txt";
#line 1423
        if (! c_cent.qname) {
#line 1424
          goto no_name_spec;
        }
#line 1425
        rbuf = (unsigned char *)((void *)0);
#line 1426
        allocsz = 0U;
#line 1426
        sz___1 = allocsz;
        {
#line 1430
        while (1) {
          while_continue___51: /* CIL Label */ ;
#line 1432
          newsz = sz___1 + 256U;
#line 1434
          if (newsz > allocsz) {
            {
#line 1435
            allocsz += 512U;
#line 1436
            tmp___161 = realloc((void *)rbuf, (size_t )allocsz);
#line 1436
            newbuf = (unsigned char *)tmp___161;
            }
#line 1437
            if (! newbuf) {
              {
#line 1438
              free((void *)rbuf);
#line 1438
              free_cent(& c_cent);
              }
#line 1438
              goto out_of_memory;
            }
#line 1440
            rbuf = newbuf;
          }
          {
#line 1442
          cp___0 = rbuf + sz___1;
#line 1443
          n___0 = scan_string(& p, (char *)(cp___0 + 1), 255U, & scanstrerr);
          }
#line 1444
          if (n___0 == -1) {
            {
#line 1445
            *errstr = report_errorf(conftype, linenr, "%s in %s= option", scanstrerr,
                                    tpname);
#line 1446
            free((void *)rbuf);
#line 1446
            free_cent(& c_cent);
            }
#line 1446
            goto free_linebuf_return;
          }
#line 1448
          if (n___0 > 255) {
            {
#line 1449
            *errstr = report_errorf(conftype, linenr, "string longer than 255 bytes in %s= option",
                                    tpname);
#line 1450
            free((void *)rbuf);
#line 1450
            free_cent(& c_cent);
            }
#line 1450
            goto free_linebuf_return;
          }
#line 1452
          *cp___0 = (unsigned char )n___0;
#line 1453
          sz___1 += (unsigned int )(n___0 + 1);
#line 1454
          if (sz___1 > 65535U) {
            {
#line 1455
            *errstr = report_errorf(conftype, linenr, "data exceeds maximum size (65535 bytes) in %s= option",
                                    tpname);
#line 1456
            free((void *)rbuf);
#line 1456
            free_cent(& c_cent);
            }
#line 1456
            goto free_linebuf_return;
          }
          {
#line 1458
          p = getnextp(& linebuf, & buflen, in, p, & linenr, & getnextperr);
          }
#line 1458
          if (! p) {
            {
#line 1458
            free((void *)rbuf);
#line 1458
            free_cent(& c_cent);
            }
#line 1458
            goto unexpected_eof;
          }
#line 1459
          if ((int )*p != 44) {
#line 1459
            goto while_break___51;
          }
          {
#line 1460
          p ++;
#line 1461
          p = getnextp(& linebuf, & buflen, in, p, & linenr, & getnextperr);
          }
#line 1461
          if (! p) {
            {
#line 1461
            free((void *)rbuf);
#line 1461
            free_cent(& c_cent);
            }
#line 1461
            goto unexpected_eof;
          }
        }
        while_break___51: /* CIL Label */ ;
        }
        {
#line 1463
        rv = add_cent_rr(& c_cent, tp, c_ttl, (time_t )0, 2U, sz___1, (void *)rbuf);
#line 1464
        free((void *)rbuf);
        }
#line 1467
        if (! rv) {
#line 1468
          goto add_rr_failed;
        }
#line 1470
        goto switch_break___2;
        switch_default___1: /* CIL Label */ 
        {
#line 1473
        free_cent(& c_cent);
        }
#line 1473
        goto internal_parse_error;
        switch_break___2: /* CIL Label */ ;
        }
        {
#line 1476
        p = getnextp(& linebuf, & buflen, in, p, & linenr, & getnextperr);
        }
#line 1476
        if (! p) {
          {
#line 1476
          free_cent(& c_cent);
          }
#line 1476
          goto unexpected_eof;
        }
#line 1477
        if ((int )*p != 59) {
          {
#line 1477
          free_cent(& c_cent);
          }
#line 1477
          goto expected_semicolon;
        }
        {
#line 1478
        p ++;
#line 1479
        p = getnextp(& linebuf, & buflen, in, p, & linenr, & getnextperr);
        }
#line 1479
        if (! p) {
          {
#line 1479
          free_cent(& c_cent);
          }
#line 1479
          goto unexpected_eof;
        }
      }
      while_break___41: /* CIL Label */ ;
      }
#line 1482
      if ((int )*p != 125) {
        {
#line 1482
        free_cent(& c_cent);
        }
#line 1482
        goto expected_closing_brace;
      }
#line 1483
      if (! c_cent.qname) {
#line 1484
        goto no_name_spec;
      }
#line 1485
      if ((int )*(c_cent.qname + 0) == 1) {
#line 1485
        if ((int )*(c_cent.qname + 1) == 42) {
          {
#line 1487
          tmp___163 = set_cent_flags((unsigned char const   *)(c_cent.qname + 2),
                                     16U);
          }
#line 1487
          if (! tmp___163) {
            {
#line 1489
            rhn2str((unsigned char const   *)c_cent.qname, buf___0, (unsigned int )sizeof(buf___0));
#line 1490
            *errstr = report_errorf(conftype, linenr, "You must define some records for \'%s\' before you can define records for the wildcard name \'%s\'",
                                    & buf___0[2], buf___0);
#line 1493
            free_cent(& c_cent);
            }
#line 1493
            goto free_linebuf_return;
          }
        }
      }
      {
#line 1497
      add_cache(& c_cent);
      }
#line 1498
      if (reverse) {
        {
#line 1499
        tmp___164 = add_reverse_cache(& c_cent);
        }
#line 1499
        if (! tmp___164) {
          {
#line 1500
          *errstr = report_error(conftype, linenr, "Can\'t convert IP address in a= option into form suitable for reverse resolving.");
#line 1502
          free_cent(& c_cent);
          }
#line 1502
          goto free_linebuf_return;
        }
      }
      {
#line 1505
      free_cent(& c_cent);
      }
#line 1506
      goto switch_break;
      add_rr_failed: 
      {
#line 1509
      free_cent(& c_cent);
      }
#line 1509
      goto out_of_memory;
      case_5: /* CIL Label */ 
#line 1520
      c_owner[0] = (unsigned char )'\000';
#line 1521
      c_ttl___0 = (time_t )86400;
#line 1522
      c_flags___0 = 2U;
#line 1523
      c_aliases = (unsigned char)0;
      {
#line 1525
      while (1) {
        while_continue___52: /* CIL Label */ ;
        {
#line 1525
        tmp___172 = __ctype_b_loc();
        }
#line 1525
        if (! ((int const   )*(*tmp___172 + (int )*p) & 1024)) {
#line 1525
          goto while_break___52;
        }
#line 1526
        ps = p;
        {
#line 1526
        while (1) {
          while_continue___53: /* CIL Label */ ;
#line 1526
          p ++;
#line 1526
          if (*p) {
            {
#line 1526
            tmp___165 = __ctype_b_loc();
            }
#line 1526
            if (! ((int const   )*(*tmp___165 + (int )*p) & 8)) {
#line 1526
              if (! ((int )*p == 95)) {
#line 1526
                goto while_break___53;
              }
            }
          } else {
#line 1526
            goto while_break___53;
          }
        }
        while_break___53: /* CIL Label */ ;
        }
        {
#line 1526
        len = (int )(p - ps);
#line 1527
        option = binsearch_keyword((char const   *)ps, len, source_options, (int )(sizeof(source_options) / sizeof(namevalue_t )));
        }
#line 1528
        if (! option) {
          {
#line 1529
          *errstr = report_errorf(conftype, linenr, "invalid option for source section: %.*s",
                                  len, ps);
          }
#line 1530
          goto free_linebuf_return;
        }
        {
#line 1532
        p = getnextp(& linebuf, & buflen, in, p, & linenr, & getnextperr);
        }
#line 1532
        if (! p) {
#line 1532
          goto unexpected_eof;
        }
#line 1533
        if ((int )*p != 61) {
#line 1533
          goto expected_equals;
        }
        {
#line 1534
        p ++;
#line 1535
        p = getnextp(& linebuf, & buflen, in, p, & linenr, & getnextperr);
        }
#line 1535
        if (! p) {
#line 1535
          goto unexpected_eof;
        }
        {
#line 1538
        if (option == 78) {
#line 1538
          goto case_78___0;
        }
#line 1543
        if (option == 79) {
#line 1543
          goto case_79___0;
        }
#line 1547
        if (option == 81) {
#line 1547
          goto case_81___0;
        }
#line 1563
        if (option == 82) {
#line 1563
          goto case_82;
        }
#line 1567
        if (option == 83) {
#line 1567
          goto case_83___0;
        }
#line 1574
        goto switch_default___2;
        case_78___0: /* CIL Label */ 
        {
#line 1539
        len = scan_string(& p, strbuf, (unsigned int )sizeof(strbuf), & scanstrerr);
        }
#line 1539
        if (len == -1) {
#line 1539
          goto string_err;
        } else
#line 1539
        if ((unsigned long )len >= sizeof(strbuf)) {
#line 1539
          goto string_too_long;
        }
        {
#line 1540
        _err___21 = parsestr2rhn((unsigned char const   *)((unsigned char *)(strbuf)),
                                 (unsigned int )len, c_owner);
        }
#line 1540
        if (_err___21) {
          {
#line 1540
          *errstr = report_error(conftype, linenr, _err___21);
          }
#line 1540
          goto free_linebuf_return;
        }
#line 1541
        goto switch_break___3;
        case_79___0: /* CIL Label */ 
        {
#line 1544
        tmp___166 = __ctype_b_loc();
        }
#line 1544
        if ((int const   )*(*tmp___166 + (int )*p) & 2048) {
          {
#line 1544
          c_ttl___0 = strtotime(p, & p, & _err___22);
          }
#line 1544
          if (_err___22) {
            {
#line 1544
            *errstr = report_errorf(conftype, linenr, "invalid time specification for %s: %s",
                                    "ttl option", _err___22);
            }
#line 1544
            goto free_linebuf_return;
          }
        } else {
          {
#line 1544
          *errstr = report_error(conftype, linenr, "expected a time specification for ttl option");
          }
#line 1544
          goto free_linebuf_return;
        }
#line 1545
        goto switch_break___3;
        case_81___0: /* CIL Label */ 
#line 1548
        if (! c_owner[0]) {
          {
#line 1549
          *errstr = report_error(conftype, linenr, "you must specify owner before file= in source records.");
          }
#line 1550
          goto free_linebuf_return;
        }
        {
#line 1552
        len = scan_string(& p, strbuf, (unsigned int )sizeof(strbuf), & scanstrerr);
        }
#line 1552
        if (len == -1) {
#line 1552
          goto string_err;
        } else
#line 1552
        if ((unsigned long )len >= sizeof(strbuf)) {
#line 1552
          goto string_too_long;
        }
        {
#line 1555
        tmp___167 = read_hosts((char const   *)(strbuf), c_owner, c_ttl___0, c_flags___0,
                               (int )c_aliases, & errmsg___0);
        }
#line 1555
        if (! tmp___167) {
#line 1556
          if (errmsg___0) {
            {
#line 1556
            *errstr = report_error(conftype, linenr, (char const   *)errmsg___0);
#line 1556
            free((void *)errmsg___0);
            }
          } else {
#line 1557
            *errstr = (char *)((void *)0);
          }
#line 1558
          goto free_linebuf_return;
        }
#line 1561
        goto switch_break___3;
        case_82: /* CIL Label */ 
        {
#line 1564
        tmp___169 = __ctype_b_loc();
        }
#line 1564
        if ((int const   )*(*tmp___169 + (int )*p) & 1024) {
#line 1564
          _str___27 = p;
          {
#line 1564
          while (1) {
            while_continue___54: /* CIL Label */ ;
#line 1564
            p ++;
#line 1564
            if (*p) {
              {
#line 1564
              tmp___168 = __ctype_b_loc();
              }
#line 1564
              if (! ((int const   )*(*tmp___168 + (int )*p) & 8)) {
#line 1564
                if (! ((int )*p == 95)) {
#line 1564
                  goto while_break___54;
                }
              }
            } else {
#line 1564
              goto while_break___54;
            }
          }
          while_break___54: /* CIL Label */ ;
          }
          {
#line 1564
          _len___27 = (size_t )(p - _str___27);
#line 1564
          _cnst___14 = lookup_const((char const   *)_str___27, (int )_len___27);
          }
#line 1564
          if (_cnst___14 == 1) {
#line 1564
            c_aliases = (unsigned char )(_cnst___14 == 1);
          } else
#line 1564
          if (_cnst___14 == 2) {
#line 1564
            c_aliases = (unsigned char )(_cnst___14 == 1);
          } else {
#line 1564
            goto ASSIGN_ON_OFF_1564;
          }
        } else {
          ASSIGN_ON_OFF_1564: 
          {
#line 1564
          *errstr = report_error(conftype, linenr, "Bad qualifier in serve_aliases= option.");
          }
#line 1564
          goto free_linebuf_return;
        }
#line 1565
        goto switch_break___3;
        case_83___0: /* CIL Label */ 
        {
#line 1569
        tmp___171 = __ctype_b_loc();
        }
#line 1569
        if ((int const   )*(*tmp___171 + (int )*p) & 1024) {
#line 1569
          _str___28 = p;
          {
#line 1569
          while (1) {
            while_continue___55: /* CIL Label */ ;
#line 1569
            p ++;
#line 1569
            if (*p) {
              {
#line 1569
              tmp___170 = __ctype_b_loc();
              }
#line 1569
              if (! ((int const   )*(*tmp___170 + (int )*p) & 8)) {
#line 1569
                if (! ((int )*p == 95)) {
#line 1569
                  goto while_break___55;
                }
              }
            } else {
#line 1569
              goto while_break___55;
            }
          }
          while_break___55: /* CIL Label */ ;
          }
          {
#line 1569
          _len___28 = (size_t )(p - _str___28);
#line 1569
          cnst___16 = lookup_const((char const   *)_str___28, (int )_len___28);
          }
#line 1569
          if (! (cnst___16 == 1)) {
#line 1569
            if (! (cnst___16 == 2)) {
#line 1569
              goto ASSIGN_CONST_1569;
            }
          }
        } else {
          ASSIGN_CONST_1569: 
          {
#line 1569
          *errstr = report_error(conftype, linenr, "Bad qualifier in authrec= option.");
          }
#line 1569
          goto free_linebuf_return;
        }
#line 1570
        if (cnst___16 == 1) {
#line 1570
          c_flags___0 = 2U;
        } else {
#line 1570
          c_flags___0 = 0U;
        }
#line 1572
        goto switch_break___3;
        switch_default___2: /* CIL Label */ 
#line 1575
        goto internal_parse_error;
        switch_break___3: /* CIL Label */ ;
        }
        {
#line 1578
        p = getnextp(& linebuf, & buflen, in, p, & linenr, & getnextperr);
        }
#line 1578
        if (! p) {
#line 1578
          goto unexpected_eof;
        }
#line 1579
        if ((int )*p != 59) {
#line 1579
          goto expected_semicolon;
        }
        {
#line 1580
        p ++;
#line 1581
        p = getnextp(& linebuf, & buflen, in, p, & linenr, & getnextperr);
        }
#line 1581
        if (! p) {
#line 1581
          goto unexpected_eof;
        }
      }
      while_break___52: /* CIL Label */ ;
      }
#line 1584
      goto switch_break;
      case_6: /* CIL Label */ 
      {
#line 1587
      while (1) {
        while_continue___56: /* CIL Label */ ;
        {
#line 1587
        tmp___177 = __ctype_b_loc();
        }
#line 1587
        if (! ((int const   )*(*tmp___177 + (int )*p) & 1024)) {
#line 1587
          goto while_break___56;
        }
#line 1588
        ps = p;
        {
#line 1588
        while (1) {
          while_continue___57: /* CIL Label */ ;
#line 1588
          p ++;
#line 1588
          if (*p) {
            {
#line 1588
            tmp___173 = __ctype_b_loc();
            }
#line 1588
            if (! ((int const   )*(*tmp___173 + (int )*p) & 8)) {
#line 1588
              if (! ((int )*p == 95)) {
#line 1588
                goto while_break___57;
              }
            }
          } else {
#line 1588
            goto while_break___57;
          }
        }
        while_break___57: /* CIL Label */ ;
        }
        {
#line 1588
        len = (int )(p - ps);
#line 1589
        option = binsearch_keyword((char const   *)ps, len, include_options, (int )(sizeof(include_options) / sizeof(namevalue_t )));
        }
#line 1590
        if (! option) {
          {
#line 1591
          *errstr = report_errorf(conftype, linenr, "invalid option for include section: %.*s",
                                  len, ps);
          }
#line 1592
          goto free_linebuf_return;
        }
        {
#line 1594
        p = getnextp(& linebuf, & buflen, in, p, & linenr, & getnextperr);
        }
#line 1594
        if (! p) {
#line 1594
          goto unexpected_eof;
        }
#line 1595
        if ((int )*p != 61) {
#line 1595
          goto expected_equals;
        }
        {
#line 1596
        p ++;
#line 1597
        p = getnextp(& linebuf, & buflen, in, p, & linenr, & getnextperr);
        }
#line 1597
        if (! p) {
#line 1597
          goto unexpected_eof;
        }
        {
#line 1600
        if (option == 81) {
#line 1600
          goto case_81___1;
        }
#line 1627
        goto switch_default___3;
        case_81___1: /* CIL Label */ 
#line 1601
        if (includedepth >= 100) {
          {
#line 1602
          *errstr = report_errorf(conftype, linenr, "maximum include depth (%d) exceeded.",
                                  100);
          }
#line 1603
          goto free_linebuf_return;
        }
        {
#line 1605
        len = scan_string(& p, strbuf, (unsigned int )sizeof(strbuf), & scanstrerr);
        }
#line 1605
        if (len == -1) {
#line 1605
          goto string_err;
        } else
#line 1605
        if ((unsigned long )len >= sizeof(strbuf)) {
#line 1605
          goto string_too_long;
        }
        {
#line 1608
        tmp___176 = read_config_file((char const   *)(strbuf), (globparm_t *)((void *)0),
                                     (servparm_array *)((void *)0), includedepth + 1,
                                     & errmsg___1);
        }
#line 1608
        if (! tmp___176) {
#line 1609
          if (errmsg___1) {
#line 1610
            if (linenr) {
              {
#line 1611
              tmp___174 = asprintf((char **/* __restrict  */)errstr, (char const   */* __restrict  */)"In file %s included at line %u:\n%s",
                                   strbuf, linenr, errmsg___1);
              }
#line 1611
              if (tmp___174 < 0) {
#line 1612
                *errstr = (char *)((void *)0);
              }
            } else {
              {
#line 1615
              tmp___175 = asprintf((char **/* __restrict  */)errstr, (char const   */* __restrict  */)"In file %s:\n%s",
                                   strbuf, errmsg___1);
              }
#line 1615
              if (tmp___175 < 0) {
#line 1616
                *errstr = (char *)((void *)0);
              }
            }
            {
#line 1618
            free((void *)errmsg___1);
            }
          } else {
#line 1621
            *errstr = (char *)((void *)0);
          }
#line 1622
          goto free_linebuf_return;
        }
#line 1625
        goto switch_break___4;
        switch_default___3: /* CIL Label */ 
#line 1628
        goto internal_parse_error;
        switch_break___4: /* CIL Label */ ;
        }
        {
#line 1631
        p = getnextp(& linebuf, & buflen, in, p, & linenr, & getnextperr);
        }
#line 1631
        if (! p) {
#line 1631
          goto unexpected_eof;
        }
#line 1632
        if ((int )*p != 59) {
#line 1632
          goto expected_semicolon;
        }
        {
#line 1633
        p ++;
#line 1634
        p = getnextp(& linebuf, & buflen, in, p, & linenr, & getnextperr);
        }
#line 1634
        if (! p) {
#line 1634
          goto unexpected_eof;
        }
      }
      while_break___56: /* CIL Label */ ;
      }
#line 1637
      goto switch_break;
      case_4: /* CIL Label */ 
#line 1644
      htp = (unsigned char)0;
#line 1645
      hdtp = (unsigned char)0;
#line 1646
      c_name___1[0] = (unsigned char )'\000';
#line 1647
      c_ttl___1 = (time_t )86400;
      {
#line 1649
      while (1) {
        while_continue___58: /* CIL Label */ ;
        {
#line 1649
        tmp___189 = __ctype_b_loc();
        }
#line 1649
        if (! ((int const   )*(*tmp___189 + (int )*p) & 1024)) {
#line 1649
          goto while_break___58;
        }
#line 1650
        ps = p;
        {
#line 1650
        while (1) {
          while_continue___59: /* CIL Label */ ;
#line 1650
          p ++;
#line 1650
          if (*p) {
            {
#line 1650
            tmp___178 = __ctype_b_loc();
            }
#line 1650
            if (! ((int const   )*(*tmp___178 + (int )*p) & 8)) {
#line 1650
              if (! ((int )*p == 95)) {
#line 1650
                goto while_break___59;
              }
            }
          } else {
#line 1650
            goto while_break___59;
          }
        }
        while_break___59: /* CIL Label */ ;
        }
        {
#line 1650
        len = (int )(p - ps);
#line 1651
        option = binsearch_keyword((char const   *)ps, len, neg_options, (int )(sizeof(neg_options) / sizeof(namevalue_t )));
        }
#line 1652
        if (! option) {
          {
#line 1653
          *errstr = report_errorf(conftype, linenr, "invalid option for neg section: %.*s",
                                  len, ps);
          }
#line 1654
          goto free_linebuf_return;
        }
        {
#line 1656
        p = getnextp(& linebuf, & buflen, in, p, & linenr, & getnextperr);
        }
#line 1656
        if (! p) {
#line 1656
          goto unexpected_eof;
        }
#line 1657
        if ((int )*p != 61) {
#line 1657
          goto expected_equals;
        }
        {
#line 1658
        p ++;
#line 1659
        p = getnextp(& linebuf, & buflen, in, p, & linenr, & getnextperr);
        }
#line 1659
        if (! p) {
#line 1659
          goto unexpected_eof;
        }
        {
#line 1662
        if (option == 77) {
#line 1662
          goto case_77___0;
        }
#line 1667
        if (option == 79) {
#line 1667
          goto case_79___1;
        }
#line 1671
        if (option == 80) {
#line 1671
          goto case_80;
        }
#line 1740
        goto switch_default___4;
        case_77___0: /* CIL Label */ 
        {
#line 1663
        len = scan_string(& p, strbuf, (unsigned int )sizeof(strbuf), & scanstrerr);
        }
#line 1663
        if (len == -1) {
#line 1663
          goto string_err;
        } else
#line 1663
        if ((unsigned long )len >= sizeof(strbuf)) {
#line 1663
          goto string_too_long;
        }
        {
#line 1664
        _err___23 = parsestr2rhn((unsigned char const   *)((unsigned char *)(strbuf)),
                                 (unsigned int )len, c_name___1);
        }
#line 1664
        if (_err___23) {
          {
#line 1664
          *errstr = report_error(conftype, linenr, _err___23);
          }
#line 1664
          goto free_linebuf_return;
        }
#line 1665
        goto switch_break___5;
        case_79___1: /* CIL Label */ 
        {
#line 1668
        tmp___179 = __ctype_b_loc();
        }
#line 1668
        if ((int const   )*(*tmp___179 + (int )*p) & 2048) {
          {
#line 1668
          c_ttl___1 = strtotime(p, & p, & _err___24);
          }
#line 1668
          if (_err___24) {
            {
#line 1668
            *errstr = report_errorf(conftype, linenr, "invalid time specification for %s: %s",
                                    "ttl option", _err___24);
            }
#line 1668
            goto free_linebuf_return;
          }
        } else {
          {
#line 1668
          *errstr = report_error(conftype, linenr, "expected a time specification for ttl option");
          }
#line 1668
          goto free_linebuf_return;
        }
#line 1669
        goto switch_break___5;
        case_80: /* CIL Label */ 
#line 1672
        if (! c_name___1[0]) {
          {
#line 1673
          *errstr = report_error(conftype, linenr, "you must specify a name before the types= option.");
          }
#line 1674
          goto free_linebuf_return;
        }
        {
#line 1676
        tmp___188 = __ctype_b_loc();
        }
#line 1676
        if ((int const   )*(*tmp___188 + (int )*p) & 1024) {
#line 1679
          ps = p;
          {
#line 1679
          while (1) {
            while_continue___60: /* CIL Label */ ;
#line 1679
            p ++;
#line 1679
            if (*p) {
              {
#line 1679
              tmp___180 = __ctype_b_loc();
              }
#line 1679
              if (! ((int const   )*(*tmp___180 + (int )*p) & 8)) {
#line 1679
                if (! ((int )*p == 95)) {
#line 1679
                  goto while_break___60;
                }
              }
            } else {
#line 1679
              goto while_break___60;
            }
          }
          while_break___60: /* CIL Label */ ;
          }
          {
#line 1679
          len = (int )(p - ps);
#line 1680
          cnst___17 = lookup_const((char const   *)ps, len);
          }
#line 1681
          if (cnst___17 == 23) {
#line 1682
            if (htp) {
              {
#line 1683
              *errstr = report_error(conftype, linenr, "You may not specify types=domain together with other types!");
              }
#line 1684
              goto free_linebuf_return;
            }
            {
#line 1686
            hdtp = (unsigned char)1;
#line 1687
            tmp___181 = init_cent(& c_cent___0, (unsigned char const   *)(c_name___1),
                                  c_ttl___1, (time_t )0, 3U);
            }
#line 1687
            if (! tmp___181) {
#line 1688
              goto out_of_memory;
            }
          } else
#line 1690
          if (cnst___17 == 0) {
#line 1691
            if (hdtp) {
              {
#line 1692
              *errstr = report_error(conftype, linenr, "You may not specify types=domain together with other types!");
              }
#line 1693
              goto free_linebuf_return;
            }
            {
#line 1695
            htp = (unsigned char)1;
#line 1696
            tmp___182 = init_cent(& c_cent___0, (unsigned char const   *)(c_name___1),
                                  (time_t )0, (time_t )0, 0U);
            }
#line 1696
            if (! tmp___182) {
#line 1697
              goto out_of_memory;
            }
            {
#line 1700
            while (1) {
              while_continue___61: /* CIL Label */ ;
              {
#line 1702
              __lengthofbuf___1 = (unsigned long )(len + 1);
#line 1702
              tmp___183 = __builtin_alloca(sizeof(*buf___1) * __lengthofbuf___1);
#line 1702
              buf___1 = (char *)tmp___183;
#line 1702
              memcpy((void */* __restrict  */)buf___1, (void const   */* __restrict  */)ps,
                     (size_t )len);
#line 1702
              *(buf___1 + len) = (char)0;
#line 1703
              cnst___17 = rr_tp_byname(buf___1);
              }
#line 1705
              if (cnst___17 == -1) {
                {
#line 1706
                *errstr = report_errorf(conftype, linenr, "unrecognized rr type \'%.*s\' used as argument for types= option.",
                                        len, ps);
#line 1707
                free_cent(& c_cent___0);
                }
#line 1707
                goto free_linebuf_return;
              }
#line 1709
              if (cnst___17 < 1) {
                {
#line 1710
                *errstr = report_errorf(conftype, linenr, "illegal rr type \'%.*s\' used as argument for types= option.",
                                        len, ps);
#line 1711
                free_cent(& c_cent___0);
                }
#line 1711
                goto free_linebuf_return;
              } else
#line 1709
              if (cnst___17 > 51) {
                {
#line 1710
                *errstr = report_errorf(conftype, linenr, "illegal rr type \'%.*s\' used as argument for types= option.",
                                        len, ps);
#line 1711
                free_cent(& c_cent___0);
                }
#line 1711
                goto free_linebuf_return;
              } else
#line 1709
              if ((int const   )rrlkuptab[cnst___17 - 1] >= 47) {
                {
#line 1710
                *errstr = report_errorf(conftype, linenr, "illegal rr type \'%.*s\' used as argument for types= option.",
                                        len, ps);
#line 1711
                free_cent(& c_cent___0);
                }
#line 1711
                goto free_linebuf_return;
              }
              {
#line 1713
              tmp___184 = getrrset_eff(& c_cent___0, cnst___17);
              }
#line 1713
              if (! tmp___184) {
                {
#line 1713
                tmp___185 = add_cent_rrset_by_type(& c_cent___0, cnst___17, c_ttl___1,
                                                   (time_t )0, 3U);
                }
#line 1713
                if (! tmp___185) {
                  {
#line 1714
                  free_cent(& c_cent___0);
                  }
#line 1714
                  goto out_of_memory;
                }
              }
              {
#line 1716
              p = getnextp(& linebuf, & buflen, in, p, & linenr, & getnextperr);
              }
#line 1716
              if (! p) {
                {
#line 1716
                free_cent(& c_cent___0);
                }
#line 1716
                goto unexpected_eof;
              }
#line 1717
              if ((int )*p != 44) {
#line 1717
                goto while_break___61;
              }
              {
#line 1718
              p ++;
#line 1719
              p = getnextp(& linebuf, & buflen, in, p, & linenr, & getnextperr);
              }
#line 1719
              if (! p) {
                {
#line 1719
                free_cent(& c_cent___0);
                }
#line 1719
                goto unexpected_eof;
              }
              {
#line 1720
              tmp___186 = __ctype_b_loc();
              }
#line 1720
              if (! ((int const   )*(*tmp___186 + (int )*p) & 1024)) {
                {
#line 1721
                free_cent(& c_cent___0);
                }
#line 1721
                goto bad_types_option;
              }
#line 1722
              ps = p;
              {
#line 1722
              while (1) {
                while_continue___62: /* CIL Label */ ;
#line 1722
                p ++;
#line 1722
                if (*p) {
                  {
#line 1722
                  tmp___187 = __ctype_b_loc();
                  }
#line 1722
                  if (! ((int const   )*(*tmp___187 + (int )*p) & 8)) {
#line 1722
                    if (! ((int )*p == 95)) {
#line 1722
                      goto while_break___62;
                    }
                  }
                } else {
#line 1722
                  goto while_break___62;
                }
              }
              while_break___62: /* CIL Label */ ;
              }
#line 1722
              len = (int )(p - ps);
            }
            while_break___61: /* CIL Label */ ;
            }
          } else {
#line 1726
            goto bad_types_option;
          }
          {
#line 1728
          add_cache(& c_cent___0);
#line 1729
          free_cent(& c_cent___0);
          }
        } else {
          bad_types_option: 
          {
#line 1735
          *errstr = report_error(conftype, linenr, "Bad argument for types= option.");
          }
#line 1736
          goto free_linebuf_return;
        }
#line 1738
        goto switch_break___5;
        switch_default___4: /* CIL Label */ 
#line 1741
        goto internal_parse_error;
        switch_break___5: /* CIL Label */ ;
        }
        {
#line 1744
        p = getnextp(& linebuf, & buflen, in, p, & linenr, & getnextperr);
        }
#line 1744
        if (! p) {
#line 1744
          goto unexpected_eof;
        }
#line 1745
        if ((int )*p != 59) {
#line 1745
          goto expected_semicolon;
        }
        {
#line 1746
        p ++;
#line 1747
        p = getnextp(& linebuf, & buflen, in, p, & linenr, & getnextperr);
        }
#line 1747
        if (! p) {
#line 1747
          goto unexpected_eof;
        }
      }
      while_break___58: /* CIL Label */ ;
      }
#line 1750
      goto switch_break;
      switch_default___5: /* CIL Label */ 
#line 1753
      goto internal_parse_error;
      switch_break: /* CIL Label */ ;
      }
#line 1756
      if ((int )*p != 125) {
#line 1756
        goto expected_closing_brace;
      }
#line 1757
      p ++;
    } else {
      {
#line 1760
      *errstr = report_error(conftype, linenr, "expected section header");
      }
#line 1761
      goto free_linebuf_return;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1765
  if (! in) {
#line 1765
    goto _L___1;
  } else {
    {
#line 1765
    tmp___191 = feof(in);
    }
#line 1765
    if (tmp___191) {
      _L___1: /* CIL Label */ 
#line 1766
      if (getnextperr) {
        {
#line 1767
        *errstr = report_error(conftype, linenr, (char const   *)getnextperr);
        }
#line 1768
        goto free_linebuf_return;
      }
#line 1770
      retval = 1;
    } else {
#line 1773
      goto input_error;
    }
  }
#line 1775
  goto free_linebuf_return;
  expected_bropen: 
  {
#line 1778
  *errstr = report_error(conftype, linenr, "expected opening brace after section name");
  }
#line 1779
  goto free_linebuf_return;
  expected_closing_brace: 
  {
#line 1782
  *errstr = report_error(conftype, linenr, "expected beginning of new option or closing brace");
  }
#line 1783
  goto free_linebuf_return;
  expected_equals: 
  {
#line 1786
  *errstr = report_error(conftype, linenr, "expected equals sign after option name");
  }
#line 1787
  goto free_linebuf_return;
  expected_semicolon: 
  {
#line 1790
  *errstr = report_error(conftype, linenr, "too many arguments to option or missing semicolon");
  }
#line 1791
  goto free_linebuf_return;
  string_err: 
  {
#line 1794
  *errstr = report_error(conftype, linenr, (char const   *)scanstrerr);
  }
#line 1795
  goto free_linebuf_return;
  string_too_long: 
  {
#line 1798
  *errstr = report_error(conftype, linenr, "string length exceeds buffer size");
  }
#line 1799
  goto free_linebuf_return;
  no_name_spec: 
  {
#line 1802
  *errstr = report_error(conftype, linenr, "you must specify a name before a,ptr,cname,mx,ns(owner) and soa records.");
  }
#line 1803
  goto free_linebuf_return;
  internal_parse_error: 
  {
#line 1806
  tmp___192 = asprintf((char **/* __restrict  */)errstr, (char const   */* __restrict  */)"Internal inconsistency detected while parsing line %u of %s.\nPlease consider reporting this error to one of the maintainers.\n",
                       linenr, conftype);
  }
#line 1806
  if (tmp___192 < 0) {
#line 1808
    *errstr = (char *)((void *)0);
  }
#line 1809
  goto free_linebuf_return;
  out_of_memory: 
#line 1813
  *errstr = (char *)((void *)0);
#line 1814
  goto free_linebuf_return;
  unexpected_eof: 
#line 1817
  if (! in) {
#line 1817
    goto _L___2;
  } else {
    {
#line 1817
    tmp___198 = feof(in);
    }
#line 1817
    if (tmp___198) {
      _L___2: /* CIL Label */ 
#line 1818
      if (getnextperr) {
#line 1818
        tmp___194 = (char const   *)getnextperr;
      } else {
#line 1818
        if (in) {
#line 1818
          tmp___193 = "unexpected end of file";
        } else {
#line 1818
          tmp___193 = "unexpected end of input string";
        }
#line 1818
        tmp___194 = tmp___193;
      }
      {
#line 1818
      *errstr = report_error(conftype, linenr, tmp___194);
      }
    } else {
      input_error: 
      {
#line 1822
      tmp___195 = __errno_location();
#line 1822
      tmp___196 = strerror(*tmp___195);
#line 1822
      tmp___197 = asprintf((char **/* __restrict  */)errstr, (char const   */* __restrict  */)"Error while reading config file: %s",
                           tmp___196);
      }
#line 1822
      if (tmp___197 < 0) {
#line 1823
        *errstr = (char *)((void *)0);
      }
    }
  }
  free_linebuf_return: 
  {
#line 1827
  free((void *)linebuf);
  }
#line 1828
  return (retval);
}
}
#line 1841 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/conf-parser.c"
static char const   *parse_ip(char const   *ipstr , pdnsd_a *a ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  {
#line 1847
  tmp___0 = strcmp(ipstr, "any");
  }
#line 1847
  if (tmp___0) {
    {
#line 1857
    tmp = str2pdnsd_a(ipstr, a);
    }
#line 1857
    if (! tmp) {
#line 1864
      return ("bad IP address");
    }
  } else {
#line 1850
    a->ipv4.s_addr = (in_addr_t )0;
  }
#line 1867
  return ((char const   *)((void *)0));
}
}
#line 1871 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/conf-parser.c"
static char const   *addr_add(atup_array *ata , char const   *ipstr ) 
{ 
  atup_t *at ;
  pdnsd_a addr ;
  int tmp ;
  atup_array tmp___0 ;
  darray tmp___1 ;

  {
  {
#line 1880
  tmp = str2pdnsd_a(ipstr, & addr);
  }
#line 1880
  if (! tmp) {
#line 1887
    return ("bad IP address");
  }
  {
#line 1891
  tmp___1 = da_grow1((darray )*ata, (size_t )(((atup_array )0)->elem), sizeof((*ata)->elem[0]),
                     (void (*)(void * ))((void *)0));
#line 1891
  tmp___0 = (atup_array )tmp___1;
#line 1891
  *ata = tmp___0;
  }
#line 1891
  if (! tmp___0) {
#line 1892
    return ("out of memory!");
  }
#line 1894
  at = & (*ata)->elem[(*ata)->nel - 1UL];
#line 1895
  at->a.ipv4 = addr.ipv4;
#line 1896
  at->is_up = (char)0;
#line 1897
  at->i_ts = (time_t )0;
#line 1898
  return ((char const   *)((void *)0));
}
}
#line 1903 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/conf-parser.c"
__inline static uint32_t mk_netmask4(int len ) 
{ 
  uint32_t m ;
  uint32_t tmp ;
  uint32_t tmp___0 ;

  {
#line 1907
  if (len <= 0) {
#line 1908
    return ((uint32_t )0);
  }
#line 1910
  m = ~ ((uint32_t )0);
#line 1911
  if (len < 32) {
    {
#line 1911
    tmp = htonl(m << (32 - len));
#line 1911
    tmp___0 = tmp;
    }
  } else {
#line 1911
    tmp___0 = m;
  }
#line 1911
  return (tmp___0);
}
}
#line 1915 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/conf-parser.c"
__inline static void mk_netmask6(struct in6_addr *m , int len ) 
{ 
  uint32_t *ma ;

  {
  {
#line 1917
  ma = (uint32_t *)m;
#line 1918
  *(ma + 0) = mk_netmask4(len);
#line 1919
  len -= 32;
#line 1919
  *(ma + 1) = mk_netmask4(len);
#line 1920
  len -= 32;
#line 1920
  *(ma + 2) = mk_netmask4(len);
#line 1921
  len -= 32;
#line 1921
  *(ma + 3) = mk_netmask4(len);
  }
#line 1922
  return;
}
}
#line 1926 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/conf-parser.c"
static char const   *reject_add(servparm_t *serv , char const   *ipstr ) 
{ 
  char *slash ;
  char *tmp ;
  int mlen ;
  char *tmp___0 ;
  char *endptr ;
  int l ;
  long tmp___1 ;
  unsigned short const   **tmp___2 ;
  addr4maskpair_t am ;
  a4_array tmp___3 ;
  darray tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  addr6maskpair_t am___0 ;
  a6_array tmp___7 ;
  darray tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;

  {
  {
#line 1928
  tmp = strchr(ipstr, '/');
#line 1928
  slash = tmp;
#line 1928
  mlen = 0;
  }
#line 1930
  if (slash) {
#line 1931
    tmp___0 = slash;
#line 1931
    slash ++;
#line 1931
    *tmp___0 = (char)0;
#line 1933
    if (*slash) {
      {
#line 1933
      tmp___2 = __ctype_b_loc();
      }
#line 1933
      if ((int const   )*(*tmp___2 + (int )*slash) & 2048) {
        {
#line 1935
        tmp___1 = strtol((char const   */* __restrict  */)slash, (char **/* __restrict  */)(& endptr),
                         10);
#line 1935
        l = (int )tmp___1;
        }
#line 1936
        if (! *endptr) {
#line 1937
          mlen = l;
#line 1938
          slash = (char *)((void *)0);
        }
      }
    }
  } else {
#line 1943
    mlen = 128;
  }
  {
#line 1948
  am.mask.s_addr = mk_netmask4(mlen);
#line 1949
  tmp___5 = inet_aton(ipstr, & am.a);
  }
#line 1949
  if (tmp___5) {
#line 1949
    if (! slash) {
#line 1949
      goto _L;
    } else {
      {
#line 1949
      tmp___6 = inet_aton((char const   *)slash, & am.mask);
      }
#line 1949
      if (tmp___6) {
        _L: /* CIL Label */ 
        {
#line 1950
        tmp___4 = da_grow1((darray )serv->reject_a4, (size_t )(((a4_array )0)->elem),
                           sizeof((serv->reject_a4)->elem[0]), (void (*)(void * ))((void *)0));
#line 1950
        tmp___3 = (a4_array )tmp___4;
#line 1950
        serv->reject_a4 = tmp___3;
        }
#line 1950
        if (! tmp___3) {
#line 1951
          return ("out of memory!");
        }
#line 1953
        (serv->reject_a4)->elem[(serv->reject_a4)->nel - 1UL] = am;
#line 1954
        return ((char const   *)((void *)0));
      }
    }
  }
  {
#line 1961
  mk_netmask6(& am___0.mask, mlen);
#line 1962
  tmp___9 = inet_pton(10, (char const   */* __restrict  */)ipstr, (void */* __restrict  */)(& am___0.a));
  }
#line 1962
  if (tmp___9 > 0) {
#line 1962
    if (! slash) {
#line 1962
      goto _L___0;
    } else {
      {
#line 1962
      tmp___10 = inet_pton(10, (char const   */* __restrict  */)slash, (void */* __restrict  */)(& am___0.mask));
      }
#line 1962
      if (tmp___10 > 0) {
        _L___0: /* CIL Label */ 
        {
#line 1963
        tmp___8 = da_grow1((darray )serv->reject_a6, (size_t )(((a6_array )0)->elem),
                           sizeof((serv->reject_a6)->elem[0]), (void (*)(void * ))((void *)0));
#line 1963
        tmp___7 = (a6_array )tmp___8;
#line 1963
        serv->reject_a6 = tmp___7;
        }
#line 1963
        if (! tmp___7) {
#line 1964
          return ("out of memory!");
        }
#line 1966
        (serv->reject_a6)->elem[(serv->reject_a6)->nel - 1UL] = am___0;
#line 1967
        return ((char const   *)((void *)0));
      }
    }
  }
#line 1972
  return ("bad IP address");
}
}
#line 1976 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/conf-parser.c"
static void check_localaddrs(servparm_t *serv ) 
{ 
  atup_array ata ;
  int i ;
  int j ;
  int n ;
  unsigned int tmp ;
  atup_t *at ;
  char buf[16] ;
  char const   *tmp___0 ;
  int tmp___1 ;
  char buf___0[16] ;
  char const   *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  darray tmp___5 ;

  {
#line 1978
  if ((int )serv->port == global.port) {
    {
#line 1979
    ata = serv->atup_a;
#line 1980
    j = 0;
#line 1980
    tmp = da_nel((darray )ata);
#line 1980
    n = (int )tmp;
#line 1981
    i = 0;
    }
    {
#line 1981
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1981
      if (! (i < n)) {
#line 1981
        goto while_break;
      }
      {
#line 1982
      at = & ata->elem[i];
#line 1983
      tmp___4 = is_inaddr_any(& global.a);
      }
#line 1983
      if (tmp___4) {
        {
#line 1984
        tmp___1 = is_local_addr((pdnsd_a *)(& at->a.ipv4));
        }
#line 1984
        if (tmp___1) {
          {
#line 1986
          tmp___0 = pdnsd_a2str((pdnsd_a *)(& at->a.ipv4), buf, 16);
#line 1986
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Local name-server address \"%s\" ignored in config file.\n",
                  tmp___0);
          }
#line 1988
          goto __Cont;
        }
      } else {
        {
#line 1992
        tmp___3 = equiv_inaddr2(& global.a, & at->a);
        }
#line 1992
        if (tmp___3) {
          {
#line 1994
          tmp___2 = pdnsd_a2str((pdnsd_a *)(& at->a.ipv4), buf___0, 16);
#line 1994
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Ignoring name-server address \"%s\" in config file (identical to server_ip address).\n",
                  tmp___2);
          }
#line 1996
          goto __Cont;
        }
      }
#line 1999
      if (j < i) {
#line 2000
        ata->elem[j] = *at;
      }
#line 2001
      j ++;
      __Cont: /* CIL Label */ 
#line 1981
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 2003
    if (j < n) {
      {
#line 2004
      tmp___5 = da_resize((darray )ata, (size_t )(((atup_array )0)->elem), sizeof(ata->elem[0]),
                          (size_t )j, (void (*)(void * ))((void *)0));
#line 2004
      serv->atup_a = (atup_array )tmp___5;
      }
    }
  }
#line 2006
  return;
}
}
#line 2009 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/conf-parser.c"
static int read_resolv_conf(char const   *fn , atup_array *ata , char **errstr ) 
{ 
  int rv ;
  FILE *f ;
  char *buf ;
  size_t buflen ;
  unsigned int linenr ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  void *tmp___2 ;
  size_t len ;
  char *p ;
  char *ps ;
  unsigned short const   **tmp___3 ;
  unsigned short const   **tmp___4 ;
  char const   *errmsg ;
  unsigned short const   **tmp___5 ;
  unsigned short const   **tmp___6 ;
  char *ipstr ;
  unsigned long __lengthofipstr ;
  void *tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  __ssize_t tmp___10 ;
  int *tmp___11 ;
  char *tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;

  {
  {
#line 2011
  rv = 0;
#line 2014
  buflen = (size_t )256;
#line 2015
  linenr = 0U;
#line 2017
  f = fopen((char const   */* __restrict  */)fn, (char const   */* __restrict  */)"r");
  }
#line 2017
  if (! f) {
    {
#line 2018
    tmp = __errno_location();
#line 2018
    tmp___0 = strerror(*tmp);
#line 2018
    tmp___1 = asprintf((char **/* __restrict  */)errstr, (char const   */* __restrict  */)"Failed to open %s: %s",
                       fn, tmp___0);
    }
#line 2018
    if (tmp___1 < 0) {
#line 2019
      *errstr = (char *)((void *)0);
    }
#line 2020
    return (0);
  }
  {
#line 2022
  tmp___2 = malloc(buflen);
#line 2022
  buf = (char *)tmp___2;
  }
#line 2023
  if (! buf) {
#line 2024
    *errstr = (char *)((void *)0);
#line 2025
    goto fclose_return;
  }
  {
#line 2027
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 2027
    tmp___10 = getline((char **/* __restrict  */)(& buf), (size_t */* __restrict  */)(& buflen),
                       (FILE */* __restrict  */)f);
    }
#line 2027
    if (! (tmp___10 >= 0L)) {
#line 2027
      goto while_break;
    }
#line 2030
    linenr ++;
#line 2031
    p = buf;
    {
#line 2032
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 2033
      if (! *p) {
#line 2033
        goto nextline;
      }
      {
#line 2034
      tmp___3 = __ctype_b_loc();
      }
#line 2034
      if (! ((int const   )*(*tmp___3 + (int )*p) & 8192)) {
#line 2034
        goto while_break___0;
      }
#line 2032
      p ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 2036
    ps = p;
    {
#line 2037
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 2038
      p ++;
#line 2038
      if (! *p) {
#line 2038
        goto nextline;
      }
      {
#line 2037
      tmp___4 = __ctype_b_loc();
      }
#line 2037
      if ((int const   )*(*tmp___4 + (int )*p) & 8192) {
#line 2037
        goto while_break___1;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
#line 2040
    len = (size_t )(p - ps);
#line 2041
    if (len == sizeof("nameserver") - 1UL) {
      {
#line 2041
      tmp___9 = strncmp((char const   *)ps, "nameserver", len);
      }
#line 2041
      if (! tmp___9) {
        {
#line 2043
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 2044
          p ++;
#line 2044
          if (! *p) {
#line 2044
            goto nextline;
          }
          {
#line 2043
          tmp___5 = __ctype_b_loc();
          }
#line 2043
          if (! ((int const   )*(*tmp___5 + (int )*p) & 8192)) {
#line 2043
            goto while_break___2;
          }
        }
        while_break___2: /* CIL Label */ ;
        }
#line 2046
        ps = p;
        {
#line 2047
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 2048
          p ++;
#line 2047
          if (*p) {
            {
#line 2047
            tmp___6 = __ctype_b_loc();
            }
#line 2047
            if ((int const   )*(*tmp___6 + (int )*p) & 8192) {
#line 2047
              goto while_break___3;
            }
          } else {
#line 2047
            goto while_break___3;
          }
        }
        while_break___3: /* CIL Label */ ;
        }
        {
#line 2050
        len = (size_t )(p - ps);
#line 2052
        __lengthofipstr = len + 1UL;
#line 2052
        tmp___7 = __builtin_alloca(sizeof(*ipstr) * __lengthofipstr);
#line 2052
        ipstr = (char *)tmp___7;
#line 2052
        memcpy((void */* __restrict  */)ipstr, (void const   */* __restrict  */)ps,
               len);
#line 2052
        *(ipstr + len) = (char)0;
#line 2053
        errmsg = addr_add(ata, (char const   *)ipstr);
        }
#line 2055
        if (errmsg) {
          {
#line 2056
          tmp___8 = asprintf((char **/* __restrict  */)errstr, (char const   */* __restrict  */)"%s in line %u of file %s",
                             errmsg, linenr, fn);
          }
#line 2056
          if (tmp___8 < 0) {
#line 2057
            *errstr = (char *)((void *)0);
          }
#line 2058
          goto cleanup_return;
        }
      }
    }
    nextline: ;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2063
  tmp___14 = feof(f);
  }
#line 2063
  if (tmp___14) {
#line 2064
    rv = 1;
  } else {
    {
#line 2065
    tmp___11 = __errno_location();
#line 2065
    tmp___12 = strerror(*tmp___11);
#line 2065
    tmp___13 = asprintf((char **/* __restrict  */)errstr, (char const   */* __restrict  */)"Failed to read %s: %s",
                        fn, tmp___12);
    }
#line 2065
    if (tmp___13 < 0) {
#line 2066
      *errstr = (char *)((void *)0);
    }
  }
  cleanup_return: 
  {
#line 2068
  free((void *)buf);
  }
  fclose_return: 
  {
#line 2070
  fclose(f);
  }
#line 2071
  return (rv);
}
}
#line 2074 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/conf-parser.c"
static char const   *slist_add(slist_array *sla , char const   *nm , unsigned int len ,
                               int tp ) 
{ 
  slist_t *sl ;
  int exact ;
  char const   *err ;
  size_t sz ;
  unsigned char rhn[256] ;
  unsigned int tmp ;
  slist_array tmp___0 ;
  darray tmp___1 ;
  unsigned char *tmp___2 ;
  void *tmp___3 ;

  {
#line 2077
  exact = 1;
#line 2082
  if (len > 1U) {
#line 2082
    if ((int const   )*nm == 46) {
#line 2083
      exact = 0;
#line 2084
      nm ++;
#line 2085
      len --;
    }
  }
  {
#line 2087
  err = parsestr2rhn((unsigned char const   *)((unsigned char *)nm), len, rhn);
  }
#line 2087
  if (err) {
#line 2088
    return (err);
  }
  {
#line 2089
  tmp = rhnlen((unsigned char const   *)(rhn));
#line 2089
  sz = (size_t )tmp;
#line 2090
  tmp___1 = da_grow1((darray )*sla, (size_t )(((slist_array )0)->elem), sizeof((*sla)->elem[0]),
                     & free_slist_domain);
#line 2090
  tmp___0 = (slist_array )tmp___1;
#line 2090
  *sla = tmp___0;
  }
#line 2090
  if (! tmp___0) {
#line 2091
    return ("out of memory!");
  }
  {
#line 2093
  sl = & (*sla)->elem[(*sla)->nel - 1UL];
#line 2095
  sl->exact = (short )exact;
#line 2096
  sl->rule = (short )tp;
#line 2097
  tmp___3 = malloc(sz);
#line 2097
  tmp___2 = (unsigned char *)tmp___3;
#line 2097
  sl->domain = tmp___2;
  }
#line 2097
  if (! tmp___2) {
#line 2098
    return ("out of memory!");
  }
  {
#line 2099
  memcpy((void */* __restrict  */)sl->domain, (void const   */* __restrict  */)(rhn),
         sz);
  }
#line 2100
  return ((char const   *)((void *)0));
}
}
#line 2103 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/conf-parser.c"
static char const   *zone_add(zone_array *za , char const   *zone , unsigned int len ) 
{ 
  zone_t z ;
  char const   *err ;
  size_t sz ;
  unsigned char rhn[256] ;
  unsigned int tmp ;
  zone_array tmp___0 ;
  darray tmp___1 ;
  zone_t tmp___2 ;
  void *tmp___3 ;

  {
  {
#line 2110
  err = parsestr2rhn((unsigned char const   *)((unsigned char *)zone), len, rhn);
  }
#line 2110
  if (err) {
#line 2111
    return (err);
  }
  {
#line 2112
  tmp = rhnlen((unsigned char const   *)(rhn));
#line 2112
  sz = (size_t )tmp;
#line 2113
  tmp___1 = da_grow1((darray )*za, (size_t )(((zone_array )0)->elem), sizeof((*za)->elem[0]),
                     & free_zone);
#line 2113
  tmp___0 = (zone_array )tmp___1;
#line 2113
  *za = tmp___0;
  }
#line 2113
  if (tmp___0) {
    {
#line 2113
    tmp___3 = malloc(sz);
#line 2113
    z = (zone_t )tmp___3;
#line 2113
    tmp___2 = z;
#line 2113
    (*za)->elem[(*za)->nel - 1UL] = tmp___2;
    }
#line 2113
    if (! tmp___2) {
#line 2114
      return ("out of memory!");
    }
  } else {
#line 2114
    return ("out of memory!");
  }
  {
#line 2115
  memcpy((void */* __restrict  */)z, (void const   */* __restrict  */)(rhn), sz);
  }
#line 2116
  return ((char const   *)((void *)0));
}
}
#line 364 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
#line 858
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) fileno)(FILE *__stream ) ;
#line 176 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strdup)(char const   *__s )  __attribute__((__malloc__)) ;
#line 214 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2), __leaf__)) fstat)(int __fd ,
                                                                                            struct stat *__buf ) ;
#line 110 "/usr/include/pwd.h"
extern struct passwd *getpwuid(__uid_t __uid ) ;
#line 57 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/list.h"
__inline static unsigned int ( __attribute__((__always_inline__)) da_nel)(darray a ) ;
#line 47 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/conff.h"
uid_t init_uid ;
#line 48
char *conf_file ;
#line 183
int reload_config_file(char const   *nm , char **errstr ) ;
#line 186
void free_slist_array(slist_array sla ) ;
#line 189
int report_conf_stat(int f ) ;
#line 114 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/helpers.h"
__inline static int ( __attribute__((__always_inline__)) is_inaddr_any)(pdnsd_a *a ) ;
#line 232
__inline static int ( __attribute__((__always_inline__)) strncp)(char *dst , char const   *src ,
                                                                 size_t dstsz ) ;
#line 43 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/servers.h"
int exclusive_lock_server_data(int tm ) ;
#line 44
void exclusive_unlock_server_data(int retest___0 ) ;
#line 40 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/conff.c"
globparm_t global  = 
#line 40 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/conff.c"
     {2048L, (char *)((void *)0), (char *)((void *)0), 53, {{(in_addr_t )0}}, {{(in_addr_t )0}},
    (time_t )604800, (time_t )120, (time_t )900, (short)3, (short)22, (short)0, {(char )'\000'},
    (char)0, (char)0, (char)0, (char)0, (char)1, (char)1, (char)0, (char)0, (char)0,
    (char)1, 384, (char *)((void *)0), 40, 60, (time_t )30, (time_t )0, 2, 12, 1024,
    65535, 1024, (zone_array )((void *)0)};
#line 81 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/conff.c"
servparm_t serv_presets  = 
#line 81
     {(unsigned short)53, (short)5, (time_t )120, (time_t )900, (time_t )600, {(char )'\000'},
    (char *)((void *)0), {(char )'\000'}, {(char )'\000'}, {(char )'\000'}, (unsigned char *)((void *)0),
    (char *)((void *)0), (char)0, (char)0, (char)1, (char)0, (char)0, (char)0, (char)0,
    (char)1, (char)0, (short)24, (short)18, (slist_array )((void *)0), (atup_array )((void *)0),
    (a4_array )((void *)0), (a6_array )((void *)0), {{(in_addr_t )0}}};
#line 114 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/conff.c"
servparm_array servers  =    (servparm_array )((void *)0);
#line 116
static void free_zones(zone_array za ) ;
#line 117
static void free_server_data(servparm_array sa ) ;
#line 118
static int report_server_stat(int f , int i ) ;
#line 141 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/conff.c"
int read_config_file(char const   *nm , globparm_t *global___0 , servparm_array *servers___0 ,
                     int includedepth , char **errstr ) 
{ 
  int retval ;
  char const   *conftype ;
  char const   *tmp ;
  FILE *in ;
  int *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  int fd ;
  int tmp___3 ;
  struct stat sb ;
  int *tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  struct passwd *pws ;
  char owner[24] ;
  char user[24] ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int *tmp___10 ;
  char *tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  unsigned int tmp___15 ;

  {
#line 143
  retval = 0;
#line 144
  if (global___0) {
#line 144
    tmp = "config";
  } else {
#line 144
    tmp = "include";
  }
#line 144
  conftype = tmp;
#line 147
  if ((unsigned long )nm == (unsigned long )((void *)0)) {
#line 148
    nm = (char const   *)conf_file;
  }
  {
#line 150
  in = fopen((char const   */* __restrict  */)nm, (char const   */* __restrict  */)"r");
  }
#line 150
  if (! in) {
    {
#line 151
    tmp___0 = __errno_location();
#line 151
    tmp___1 = strerror(*tmp___0);
#line 151
    tmp___2 = asprintf((char **/* __restrict  */)errstr, (char const   */* __restrict  */)"Error: Could not open %s file %s: %s",
                       conftype, nm, tmp___1);
    }
#line 151
    if (tmp___2 < 0) {
#line 152
      *errstr = (char *)((void *)0);
    }
#line 153
    return (0);
  }
#line 155
  if (global___0) {
#line 155
    goto _L___0;
  } else
#line 155
  if (servers___0) {
    _L___0: /* CIL Label */ 
    {
#line 157
    tmp___3 = fileno(in);
#line 157
    fd = tmp___3;
    }
#line 162
    if (fd == -1) {
#line 162
      goto _L;
    } else {
      {
#line 162
      tmp___9 = fstat(fd, & sb);
      }
#line 162
      if (tmp___9 != 0) {
        _L: /* CIL Label */ 
        {
#line 163
        tmp___4 = __errno_location();
#line 163
        tmp___5 = strerror(*tmp___4);
#line 163
        tmp___6 = asprintf((char **/* __restrict  */)errstr, (char const   */* __restrict  */)"Error: Could not stat %s file %s: %s",
                           conftype, nm, tmp___5);
        }
#line 163
        if (tmp___6 < 0) {
#line 166
          *errstr = (char *)((void *)0);
        }
#line 167
        goto close_file;
      } else
#line 169
      if (sb.st_uid != init_uid) {
        {
#line 177
        pws = getpwuid(sb.st_uid);
        }
#line 177
        if (pws) {
          {
#line 178
          strncp(owner, (char const   *)pws->pw_name, sizeof(owner));
          }
        } else {
          {
#line 180
          sprintf((char */* __restrict  */)(owner), (char const   */* __restrict  */)"%i",
                  sb.st_uid);
          }
        }
        {
#line 181
        pws = getpwuid(init_uid);
        }
#line 181
        if (pws) {
          {
#line 182
          strncp(user, (char const   *)pws->pw_name, sizeof(user));
          }
        } else {
          {
#line 184
          sprintf((char */* __restrict  */)(user), (char const   */* __restrict  */)"%i",
                  init_uid);
          }
        }
        {
#line 185
        tmp___7 = asprintf((char **/* __restrict  */)errstr, (char const   */* __restrict  */)"Error: %s file %s is owned by \'%s\', but pdnsd was started as user \'%s\'.",
                           conftype, nm, owner, user);
        }
#line 185
        if (tmp___7 < 0) {
#line 188
          *errstr = (char *)((void *)0);
        }
#line 189
        goto close_file;
      } else
#line 191
      if (sb.st_mode & (unsigned int )((128 >> 3) | ((128 >> 3) >> 3))) {
        {
#line 192
        tmp___8 = asprintf((char **/* __restrict  */)errstr, (char const   */* __restrict  */)"Error: Bad %s file permissions: file %s must be only writeable by the user.",
                           conftype, nm);
        }
#line 192
        if (tmp___8 < 0) {
#line 195
          *errstr = (char *)((void *)0);
        }
#line 196
        goto close_file;
      }
    }
  }
  {
#line 200
  retval = confparse(in, (char *)((void *)0), global___0, servers___0, includedepth,
                     errstr);
  }
  close_file: 
  {
#line 202
  tmp___13 = fclose(in);
  }
#line 202
  if (tmp___13) {
#line 202
    if (retval) {
      {
#line 203
      tmp___10 = __errno_location();
#line 203
      tmp___11 = strerror(*tmp___10);
#line 203
      tmp___12 = asprintf((char **/* __restrict  */)errstr, (char const   */* __restrict  */)"Error: Could not close %s file %s: %s",
                          conftype, nm, tmp___11);
      }
#line 203
      if (tmp___12 < 0) {
#line 205
        *errstr = (char *)((void *)0);
      }
#line 206
      return (0);
    }
  }
#line 208
  if (retval) {
#line 208
    if (servers___0) {
      {
#line 208
      tmp___15 = da_nel((darray )*servers___0);
      }
#line 208
      if (! tmp___15) {
        {
#line 209
        tmp___14 = asprintf((char **/* __restrict  */)errstr, (char const   */* __restrict  */)"Error: no server sections defined in config file %s",
                            nm);
        }
#line 209
        if (tmp___14 < 0) {
#line 210
          *errstr = (char *)((void *)0);
        }
#line 211
        return (0);
      }
    }
  }
#line 213
  return (retval);
}
}
#line 222 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/conff.c"
int reload_config_file(char const   *nm , char **errstr ) 
{ 
  globparm_t global_new ;
  servparm_array servers_new ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int i ;
  int n ;
  unsigned int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
  {
#line 227
  global_new = global;
#line 228
  global_new.cache_dir = (char *)((void *)0);
#line 229
  global_new.pidfile = (char *)((void *)0);
#line 230
  global_new.scheme_file = (char *)((void *)0);
#line 231
  global_new.deleg_only_zones = (zone_array )((void *)0);
#line 232
  global_new.onquery = (char)0;
#line 233
  servers_new = (servparm_array )((void *)0);
#line 234
  tmp___6 = read_config_file(nm, & global_new, & servers_new, 0, errstr);
  }
#line 234
  if (tmp___6) {
#line 235
    if (global_new.cache_dir) {
      {
#line 235
      tmp = strcmp((char const   *)global_new.cache_dir, (char const   *)global.cache_dir);
      }
#line 235
      if (tmp) {
        {
#line 236
        *errstr = strdup("Cannot reload config file: the specified cache_dir directory has changed.\nTry restarting pdnsd instead.");
        }
#line 238
        goto cleanup_return;
      }
    }
#line 240
    if (global_new.pidfile) {
#line 240
      if (! global.pidfile) {
        {
#line 241
        *errstr = strdup("Cannot reload config file: the specified pid_file has changed.\nTry restarting pdnsd instead.");
        }
#line 243
        goto cleanup_return;
      } else {
        {
#line 240
        tmp___0 = strcmp((char const   *)global_new.pidfile, (char const   *)global.pidfile);
        }
#line 240
        if (tmp___0) {
          {
#line 241
          *errstr = strdup("Cannot reload config file: the specified pid_file has changed.\nTry restarting pdnsd instead.");
          }
#line 243
          goto cleanup_return;
        }
      }
    }
#line 245
    if (global_new.scheme_file) {
      {
#line 245
      tmp___1 = strcmp((char const   *)global_new.scheme_file, (char const   *)global.scheme_file);
      }
#line 245
      if (tmp___1) {
        {
#line 246
        *errstr = strdup("Cannot reload config file: the specified scheme_file has changed.\nTry restarting pdnsd instead.");
        }
#line 248
        goto cleanup_return;
      }
    }
#line 250
    if (global_new.port != global.port) {
      {
#line 251
      *errstr = strdup("Cannot reload config file: the specified server_port has changed.\nTry restarting pdnsd instead.");
      }
#line 253
      goto cleanup_return;
    }
#line 255
    if (! (((struct in_addr *)(& global_new.a))->s_addr == ((struct in_addr *)(& global.a))->s_addr)) {
      {
#line 256
      *errstr = strdup("Cannot reload config file: the specified interface address (server_ip) has changed.\nTry restarting pdnsd instead.");
      }
#line 258
      goto cleanup_return;
    }
    {
#line 267
    tmp___2 = strcmp((char const   *)(global_new.run_as), (char const   *)(global.run_as));
    }
#line 267
    if (tmp___2) {
      {
#line 268
      *errstr = strdup("Cannot reload config file: the specified run_as id has changed.\nTry restarting pdnsd instead.");
      }
#line 270
      goto cleanup_return;
    }
#line 272
    if ((int )global_new.daemon != (int )global.daemon) {
      {
#line 273
      *errstr = strdup("Cannot reload config file: the daemon option has changed.\nTry restarting pdnsd instead.");
      }
#line 275
      goto cleanup_return;
    }
#line 277
    if ((int )global_new.debug != (int )global.debug) {
      {
#line 278
      *errstr = strdup("Cannot reload config file: the debug option has changed.\nTry restarting pdnsd instead.");
      }
#line 280
      goto cleanup_return;
    }
#line 282
    if ((int )global_new.stat_pipe != (int )global.stat_pipe) {
      {
#line 283
      *errstr = strdup("Cannot reload config file: the status_ctl option has changed.\nTry restarting pdnsd instead.");
      }
#line 285
      goto cleanup_return;
    }
#line 287
    if ((int )global_new.notcp != (int )global.notcp) {
      {
#line 288
      *errstr = strdup("Cannot reload config file: the tcp_server option has changed.\nTry restarting pdnsd instead.");
      }
#line 290
      goto cleanup_return;
    }
#line 292
    if ((int )global_new.strict_suid != (int )global.strict_suid) {
      {
#line 293
      *errstr = strdup("Cannot reload config file: the strict_setuid option has changed.\nTry restarting pdnsd instead.");
      }
#line 295
      goto cleanup_return;
    }
#line 297
    if (global_new.ctl_perms != global.ctl_perms) {
      {
#line 298
      *errstr = strdup("Cannot reload config file: the specified ctl_perms has changed.\nTry restarting pdnsd instead.");
      }
#line 300
      goto cleanup_return;
    }
#line 302
    if (ping_isocket == (int volatile   )-1) {
      {
#line 307
      tmp___3 = da_nel((darray )servers_new);
#line 307
      n = (int )tmp___3;
#line 308
      i = 0;
      }
      {
#line 308
      while (1) {
        while_continue: /* CIL Label */ ;
#line 308
        if (! (i < n)) {
#line 308
          goto while_break;
        }
#line 309
        if ((int )servers_new->elem[i].uptest == 8) {
          {
#line 310
          tmp___4 = asprintf((char **/* __restrict  */)errstr, (char const   */* __restrict  */)"Cannot reload config file: the ping socket is not initialized and the new config contains uptest=ping in server section %i.\nTry restarting pdnsd instead.",
                             i);
          }
#line 310
          if (tmp___4 < 0) {
#line 313
            *errstr = (char *)((void *)0);
          }
#line 314
          goto cleanup_return;
        }
#line 308
        i ++;
      }
      while_break: /* CIL Label */ ;
      }
    }
    {
#line 321
    tmp___5 = exclusive_lock_server_data(60);
    }
#line 321
    if (! tmp___5) {
      {
#line 322
      *errstr = strdup("Cannot reload config file: Timed out while waiting for access to config data.");
      }
#line 323
      goto cleanup_return;
    }
    {
#line 325
    free((void *)global_new.cache_dir);
#line 325
    global_new.cache_dir = global.cache_dir;
#line 326
    free((void *)global_new.pidfile);
#line 326
    global_new.pidfile = global.pidfile;
#line 327
    free((void *)global_new.scheme_file);
#line 327
    global_new.scheme_file = global.scheme_file;
#line 328
    free_zones(global.deleg_only_zones);
#line 329
    global = global_new;
#line 331
    free_server_data(servers);
#line 332
    servers = servers_new;
#line 335
    exclusive_unlock_server_data(1);
    }
#line 337
    return (1);
  }
  cleanup_return: 
  {
#line 341
  free((void *)global_new.cache_dir);
#line 342
  free((void *)global_new.pidfile);
#line 343
  free((void *)global_new.scheme_file);
#line 344
  free_zones(global_new.deleg_only_zones);
#line 345
  free_server_data(servers_new);
  }
#line 346
  return (0);
}
}
#line 349 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/conff.c"
void free_zone(void *ptr ) 
{ 


  {
  {
#line 351
  free((void *)*((unsigned char **)ptr));
  }
#line 352
  return;
}
}
#line 354 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/conff.c"
static void free_zones(zone_array za ) 
{ 
  int i ;
  int n ;
  unsigned int tmp ;

  {
  {
#line 356
  tmp = da_nel((darray )za);
#line 356
  n = (int )tmp;
#line 357
  i = 0;
  }
  {
#line 357
  while (1) {
    while_continue: /* CIL Label */ ;
#line 357
    if (! (i < n)) {
#line 357
      goto while_break;
    }
    {
#line 358
    free((void *)za->elem[i]);
#line 357
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 360
  free((void *)za);
  }
#line 361
  return;
}
}
#line 363 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/conff.c"
void free_slist_domain(void *ptr ) 
{ 


  {
  {
#line 365
  free((void *)((slist_t *)ptr)->domain);
  }
#line 366
  return;
}
}
#line 368 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/conff.c"
void free_slist_array(slist_array sla ) 
{ 
  int j ;
  int m ;
  unsigned int tmp ;

  {
  {
#line 370
  tmp = da_nel((darray )sla);
#line 370
  m = (int )tmp;
#line 371
  j = 0;
  }
  {
#line 371
  while (1) {
    while_continue: /* CIL Label */ ;
#line 371
    if (! (j < m)) {
#line 371
      goto while_break;
    }
    {
#line 372
    free((void *)sla->elem[j].domain);
#line 371
    j ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 373
  free((void *)sla);
  }
#line 375
  return;
}
}
#line 377 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/conff.c"
void free_servparm(servparm_t *serv ) 
{ 


  {
  {
#line 379
  free((void *)serv->uptest_cmd);
#line 380
  free((void *)serv->query_test_name);
#line 381
  free((void *)serv->label);
#line 382
  free((void *)serv->atup_a);
#line 383
  free_slist_array(serv->alist);
#line 384
  free((void *)serv->reject_a4);
#line 386
  free((void *)serv->reject_a6);
  }
#line 388
  return;
}
}
#line 390 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/conff.c"
static void free_server_data(servparm_array sa ) 
{ 
  int i ;
  int n ;
  unsigned int tmp ;

  {
  {
#line 392
  tmp = da_nel((darray )sa);
#line 392
  n = (int )tmp;
#line 393
  i = 0;
  }
  {
#line 393
  while (1) {
    while_continue: /* CIL Label */ ;
#line 393
    if (! (i < n)) {
#line 393
      goto while_break;
    }
    {
#line 394
    free_servparm(& sa->elem[i]);
#line 393
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 395
  free((void *)sa);
  }
#line 396
  return;
}
}
#line 399 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/conff.c"
int report_conf_stat(int f ) 
{ 
  int i ;
  int n ;
  int retval ;
  int _retval ;
  int _retval___0 ;
  int _retval___1 ;
  int _retval___2 ;
  int _retval___3 ;
  char buf[16] ;
  int _retval___4 ;
  char const   *tmp ;
  int _retval___5 ;
  char const   *tmp___0 ;
  int tmp___1 ;
  int _retval___6 ;
  char const   *tmp___2 ;
  int _retval___7 ;
  int _retval___8 ;
  int _retval___9 ;
  int _retval___10 ;
  char const   *tmp___3 ;
  int _retval___11 ;
  char const   *tmp___4 ;
  int _retval___12 ;
  int _retval___13 ;
  char const   *tmp___5 ;
  int _retval___14 ;
  char const   *tmp___6 ;
  int _retval___15 ;
  char const   *tmp___7 ;
  int _retval___16 ;
  int _retval___17 ;
  int _retval___18 ;
  int _retval___19 ;
  int _retval___20 ;
  int _retval___21 ;
  char const   *tmp___8 ;
  int _retval___22 ;
  char const   *tmp___9 ;
  int query_port_start ;
  int _retval___23 ;
  int _retval___24 ;
  int _retval___25 ;
  int _retval___26 ;
  char const   *tmp___10 ;
  int _retval___27 ;
  int _retval___28 ;
  int rv ;
  int tmp___11 ;
  int rv___0 ;
  int tmp___12 ;
  int rv___1 ;
  unsigned int tmp___13 ;
  unsigned char buf___0[256] ;
  unsigned char const   *tmp___14 ;
  char const   *tmp___15 ;
  unsigned int tmp___16 ;
  int rv___2 ;
  int tmp___17 ;

  {
  {
#line 401
  retval = 0;
#line 403
  _retval = fsprintf(f, "\nConfiguration:\n==============\nGlobal:\n-------\n");
  }
#line 403
  if (_retval < 0) {
#line 403
    return (_retval);
  }
  {
#line 404
  _retval___0 = fsprintf(f, "\tCache size: %li kB\n", global.perm_cache);
  }
#line 404
  if (_retval___0 < 0) {
#line 404
    return (_retval___0);
  }
  {
#line 405
  _retval___1 = fsprintf(f, "\tServer directory: %s\n", global.cache_dir);
  }
#line 405
  if (_retval___1 < 0) {
#line 405
    return (_retval___1);
  }
  {
#line 406
  _retval___2 = fsprintf(f, "\tScheme file (for Linux pcmcia support): %s\n", global.scheme_file);
  }
#line 406
  if (_retval___2 < 0) {
#line 406
    return (_retval___2);
  }
  {
#line 407
  _retval___3 = fsprintf(f, "\tServer port: %i\n", global.port);
  }
#line 407
  if (_retval___3 < 0) {
#line 407
    return (_retval___3);
  }
  {
#line 410
  tmp = pdnsd_a2str(& global.a, buf, 16);
#line 410
  _retval___4 = fsprintf(f, "\tServer IP (%s=any available one): %s\n", "0.0.0.0",
                         tmp);
  }
#line 410
  if (_retval___4 < 0) {
#line 410
    return (_retval___4);
  }
  {
#line 412
  tmp___1 = is_inaddr_any(& global.out_a);
  }
#line 412
  if (! tmp___1) {
    {
#line 413
    tmp___0 = pdnsd_a2str(& global.out_a, buf, 16);
#line 413
    _retval___5 = fsprintf(f, "\tIP bound to interface used for querying remote servers: %s\n",
                           tmp___0);
    }
#line 413
    if (_retval___5 < 0) {
#line 413
      return (_retval___5);
    }
  }
#line 423
  if (global.lndown_kluge) {
#line 423
    tmp___2 = "on";
  } else {
#line 423
    tmp___2 = "off";
  }
  {
#line 423
  _retval___6 = fsprintf(f, "\tIgnore cache when link is down: %s\n", tmp___2);
  }
#line 423
  if (_retval___6 < 0) {
#line 423
    return (_retval___6);
  }
  {
#line 424
  _retval___7 = fsprintf(f, "\tMaximum ttl: %li\n", global.max_ttl);
  }
#line 424
  if (_retval___7 < 0) {
#line 424
    return (_retval___7);
  }
  {
#line 425
  _retval___8 = fsprintf(f, "\tMinimum ttl: %li\n", global.min_ttl);
  }
#line 425
  if (_retval___8 < 0) {
#line 425
    return (_retval___8);
  }
  {
#line 426
  _retval___9 = fsprintf(f, "\tNegative ttl: %li\n", global.neg_ttl);
  }
#line 426
  if (_retval___9 < 0) {
#line 426
    return (_retval___9);
  }
  {
#line 427
  tmp___3 = const_name((int )global.neg_rrs_pol);
#line 427
  _retval___10 = fsprintf(f, "\tNegative RRS policy: %s\n", tmp___3);
  }
#line 427
  if (_retval___10 < 0) {
#line 427
    return (_retval___10);
  }
  {
#line 428
  tmp___4 = const_name((int )global.neg_domain_pol);
#line 428
  _retval___11 = fsprintf(f, "\tNegative domain policy: %s\n", tmp___4);
  }
#line 428
  if (_retval___11 < 0) {
#line 428
    return (_retval___11);
  }
  {
#line 429
  _retval___12 = fsprintf(f, "\tRun as: %s\n", global.run_as);
  }
#line 429
  if (_retval___12 < 0) {
#line 429
    return (_retval___12);
  }
#line 430
  if (global.strict_suid) {
#line 430
    tmp___5 = "on";
  } else {
#line 430
    tmp___5 = "off";
  }
  {
#line 430
  _retval___13 = fsprintf(f, "\tStrict run as: %s\n", tmp___5);
  }
#line 430
  if (_retval___13 < 0) {
#line 430
    return (_retval___13);
  }
#line 431
  if (global.use_nss) {
#line 431
    tmp___6 = "on";
  } else {
#line 431
    tmp___6 = "off";
  }
  {
#line 431
  _retval___14 = fsprintf(f, "\tUse NSS: %s\n", tmp___6);
  }
#line 431
  if (_retval___14 < 0) {
#line 431
    return (_retval___14);
  }
#line 432
  if (global.paranoid) {
#line 432
    tmp___7 = "on";
  } else {
#line 432
    tmp___7 = "off";
  }
  {
#line 432
  _retval___15 = fsprintf(f, "\tParanoid mode (cache pollution prevention): %s\n",
                          tmp___7);
  }
#line 432
  if (_retval___15 < 0) {
#line 432
    return (_retval___15);
  }
  {
#line 433
  _retval___16 = fsprintf(f, "\tControl socket permissions (mode): %o\n", global.ctl_perms);
  }
#line 433
  if (_retval___16 < 0) {
#line 433
    return (_retval___16);
  }
  {
#line 434
  _retval___17 = fsprintf(f, "\tMaximum parallel queries served: %i\n", global.proc_limit);
  }
#line 434
  if (_retval___17 < 0) {
#line 434
    return (_retval___17);
  }
  {
#line 435
  _retval___18 = fsprintf(f, "\tMaximum queries queued for serving: %i\n", global.procq_limit);
  }
#line 435
  if (_retval___18 < 0) {
#line 435
    return (_retval___18);
  }
  {
#line 436
  _retval___19 = fsprintf(f, "\tGlobal timeout setting: %li\n", global.timeout);
  }
#line 436
  if (_retval___19 < 0) {
#line 436
    return (_retval___19);
  }
  {
#line 437
  _retval___20 = fsprintf(f, "\tParallel queries increment: %i\n", global.par_queries);
  }
#line 437
  if (_retval___20 < 0) {
#line 437
    return (_retval___20);
  }
#line 438
  if (global.rnd_recs) {
#line 438
    tmp___8 = "on";
  } else {
#line 438
    tmp___8 = "off";
  }
  {
#line 438
  _retval___21 = fsprintf(f, "\tRandomize records in answer: %s\n", tmp___8);
  }
#line 438
  if (_retval___21 < 0) {
#line 438
    return (_retval___21);
  }
  {
#line 439
  tmp___9 = const_name(global.query_method);
#line 439
  _retval___22 = fsprintf(f, "\tQuery method: %s\n", tmp___9);
  }
#line 439
  if (_retval___22 < 0) {
#line 439
    return (_retval___22);
  }
#line 441
  query_port_start = global.query_port_start;
#line 442
  if (query_port_start == -1) {
    {
#line 443
    _retval___23 = fsprintf(f, "\tQuery port start: (let kernel choose)\n");
    }
#line 443
    if (_retval___23 < 0) {
#line 443
      return (_retval___23);
    }
  } else {
    {
#line 446
    _retval___24 = fsprintf(f, "\tQuery port start: %i\n", query_port_start);
    }
#line 446
    if (_retval___24 < 0) {
#line 446
      return (_retval___24);
    }
    {
#line 447
    _retval___25 = fsprintf(f, "\tQuery port end: %i\n", global.query_port_end);
    }
#line 447
    if (_retval___25 < 0) {
#line 447
      return (_retval___25);
    }
  }
#line 451
  if (global.notcp) {
#line 451
    tmp___10 = "off";
  } else {
#line 451
    tmp___10 = "on";
  }
  {
#line 451
  _retval___26 = fsprintf(f, "\tTCP server thread: %s\n", tmp___10);
  }
#line 451
  if (_retval___26 < 0) {
#line 451
    return (_retval___26);
  }
#line 452
  if (! global.notcp) {
    {
#line 453
    _retval___27 = fsprintf(f, "\tTCP query timeout: %li\n", global.tcp_qtimeout);
    }
#line 453
    if (_retval___27 < 0) {
#line 453
      return (_retval___27);
    }
  }
  {
#line 455
  _retval___28 = fsprintf(f, "\tMaximum udp buffer size: %i\n", global.udpbufsize);
  }
#line 455
  if (_retval___28 < 0) {
#line 455
    return (_retval___28);
  }
  {
#line 457
  lock_server_data();
#line 459
  tmp___11 = fsprintf(f, "\tDelegation-only zones: ");
#line 459
  rv = tmp___11;
  }
#line 460
  if (rv < 0) {
#line 460
    retval = rv;
#line 460
    goto unlock_return;
  }
#line 462
  if ((unsigned long )global.deleg_only_zones == (unsigned long )((void *)0)) {
    {
#line 463
    tmp___12 = fsprintf(f, "(none)\n");
#line 463
    rv___0 = tmp___12;
    }
#line 464
    if (rv___0 < 0) {
#line 464
      retval = rv___0;
#line 464
      goto unlock_return;
    }
  } else {
    {
#line 468
    tmp___13 = da_nel((darray )global.deleg_only_zones);
#line 468
    n = (int )tmp___13;
#line 469
    i = 0;
    }
    {
#line 469
    while (1) {
      while_continue: /* CIL Label */ ;
#line 469
      if (! (i < n)) {
#line 469
        goto while_break;
      }
      {
#line 471
      tmp___14 = rhn2str((unsigned char const   *)(global.deleg_only_zones)->elem[i],
                         buf___0, (unsigned int )sizeof(buf___0));
      }
#line 471
      if (i == 0) {
#line 471
        tmp___15 = "%s";
      } else {
#line 471
        tmp___15 = ", %s";
      }
      {
#line 471
      rv___1 = fsprintf(f, tmp___15, tmp___14);
      }
#line 473
      if (rv___1 < 0) {
#line 473
        retval = rv___1;
#line 473
        goto unlock_return;
      }
#line 469
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 475
    rv___1 = fsprintf(f, "\n");
    }
#line 476
    if (rv___1 < 0) {
#line 476
      retval = rv___1;
#line 476
      goto unlock_return;
    }
  }
  {
#line 479
  tmp___16 = da_nel((darray )servers);
#line 479
  n = (int )tmp___16;
#line 480
  i = 0;
  }
  {
#line 480
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 480
    if (! (i < n)) {
#line 480
      goto while_break___0;
    }
    {
#line 481
    tmp___17 = report_server_stat(f, i);
#line 481
    rv___2 = tmp___17;
    }
#line 482
    if (rv___2 < 0) {
#line 482
      retval = rv___2;
#line 482
      goto unlock_return;
    }
#line 480
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  unlock_return: 
  {
#line 485
  unlock_server_data();
  }
#line 487
  return (retval);
}
}
#line 501 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/conff.c"
static int report_server_stat(int f , int i ) 
{ 
  servparm_t *st ;
  int j ;
  int m ;
  int _retval ;
  int _retval___0 ;
  char const   *tmp ;
  unsigned int tmp___0 ;
  int _retval___1 ;
  atup_t *at ;
  char buf[16] ;
  int _retval___2 ;
  char const   *tmp___1 ;
  int _retval___3 ;
  char const   *tmp___2 ;
  int _retval___4 ;
  int _retval___5 ;
  char const   *tmp___3 ;
  int _retval___6 ;
  int _retval___7 ;
  int _retval___8 ;
  char const   *tmp___4 ;
  char const   *tmp___5 ;
  int _retval___9 ;
  char buf___0[16] ;
  int _retval___10 ;
  char const   *tmp___7 ;
  char const   *tmp___8 ;
  int tmp___9 ;
  int _retval___11 ;
  int _retval___12 ;
  int _retval___13 ;
  int _retval___14 ;
  char const   *tmp___10 ;
  unsigned char nmbuf[256] ;
  int _retval___15 ;
  unsigned char const   *tmp___11 ;
  int _retval___16 ;
  int _retval___17 ;
  char const   *tmp___12 ;
  int _retval___18 ;
  char const   *tmp___13 ;
  int _retval___19 ;
  char const   *tmp___14 ;
  int _retval___20 ;
  char const   *tmp___15 ;
  int _retval___21 ;
  char const   *tmp___16 ;
  int _retval___22 ;
  char const   *tmp___17 ;
  char const   *tmp___18 ;
  int _retval___23 ;
  char const   *tmp___19 ;
  int _retval___24 ;
  char const   *tmp___20 ;
  int _retval___25 ;
  char const   *tmp___21 ;
  slist_t *sl ;
  unsigned char buf___1[256] ;
  int _retval___26 ;
  unsigned char const   *tmp___22 ;
  char const   *tmp___23 ;
  char const   *tmp___24 ;
  unsigned int tmp___25 ;
  int _retval___27 ;
  unsigned int tmp___26 ;
  addr4maskpair_t *am ;
  char abuf[16] ;
  char mbuf[16] ;
  int _retval___28 ;
  char const   *tmp___27 ;
  char const   *tmp___28 ;
  unsigned int tmp___29 ;
  addr6maskpair_t *am___0 ;
  char abuf___0[46] ;
  char mbuf___0[46] ;
  int _retval___29 ;
  char const   *tmp___30 ;
  char const   *tmp___31 ;
  int _retval___30 ;
  char const   *tmp___32 ;
  int _retval___31 ;
  char const   *tmp___33 ;

  {
  {
#line 503
  st = & servers->elem[i];
#line 506
  _retval = fsprintf(f, "Server %i:\n------\n", i);
  }
#line 506
  if (_retval < 0) {
#line 506
    return (_retval);
  }
#line 507
  if (st->label) {
#line 507
    tmp = (char const   *)st->label;
  } else {
#line 507
    tmp = "(none)";
  }
  {
#line 507
  _retval___0 = fsprintf(f, "\tlabel: %s\n", tmp);
  }
#line 507
  if (_retval___0 < 0) {
#line 507
    return (_retval___0);
  }
  {
#line 508
  tmp___0 = da_nel((darray )st->atup_a);
#line 508
  m = (int )tmp___0;
  }
#line 509
  if ((int )st->rootserver > 1) {
#line 509
    if (m) {
      {
#line 510
      _retval___1 = fsprintf(f, "\tThe following name servers will be used for discovery of rootservers only:\n");
      }
#line 510
      if (_retval___1 < 0) {
#line 510
        return (_retval___1);
      }
    }
  }
#line 511
  j = 0;
  {
#line 511
  while (1) {
    while_continue: /* CIL Label */ ;
#line 511
    if (! (j < m)) {
#line 511
      goto while_break;
    }
    {
#line 512
    at = & (st->atup_a)->elem[j];
#line 514
    tmp___1 = pdnsd_a2str((pdnsd_a *)(& at->a.ipv4), buf, 16);
#line 514
    _retval___2 = fsprintf(f, "\tip: %s\n", tmp___1);
    }
#line 514
    if (_retval___2 < 0) {
#line 514
      return (_retval___2);
    }
#line 515
    if (at->is_up) {
#line 515
      tmp___2 = "yes";
    } else {
#line 515
      tmp___2 = "no";
    }
    {
#line 515
    _retval___3 = fsprintf(f, "\tserver assumed available: %s\n", tmp___2);
    }
#line 515
    if (_retval___3 < 0) {
#line 515
      return (_retval___3);
    }
#line 511
    j ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 517
  _retval___4 = fsprintf(f, "\tport: %hu\n", (int )st->port);
  }
#line 517
  if (_retval___4 < 0) {
#line 517
    return (_retval___4);
  }
  {
#line 518
  tmp___3 = const_name((int )st->uptest);
#line 518
  _retval___5 = fsprintf(f, "\tuptest: %s\n", tmp___3);
  }
#line 518
  if (_retval___5 < 0) {
#line 518
    return (_retval___5);
  }
  {
#line 519
  _retval___6 = fsprintf(f, "\ttimeout: %li\n", st->timeout);
  }
#line 519
  if (_retval___6 < 0) {
#line 519
    return (_retval___6);
  }
#line 520
  if (st->interval > 0L) {
    {
#line 521
    _retval___7 = fsprintf(f, "\tuptest interval: %li\n", st->interval);
    }
#line 521
    if (_retval___7 < 0) {
#line 521
      return (_retval___7);
    }
  } else {
#line 523
    if (st->interval == -1L) {
#line 523
      tmp___5 = "onquery";
    } else {
#line 523
      if (st->interval == -2L) {
#line 523
        tmp___4 = "ontimeout";
      } else {
#line 523
        tmp___4 = "(never retest)";
      }
#line 523
      tmp___5 = tmp___4;
    }
    {
#line 523
    _retval___8 = fsprintf(f, "\tuptest interval: %s\n", tmp___5);
    }
#line 523
    if (_retval___8 < 0) {
#line 523
      return (_retval___8);
    }
  }
  {
#line 528
  _retval___9 = fsprintf(f, "\tping timeout: %li\n", st->ping_timeout);
  }
#line 528
  if (_retval___9 < 0) {
#line 528
    return (_retval___9);
  }
  {
#line 530
  tmp___9 = is_inaddr_any(& st->ping_a);
  }
#line 530
  if (tmp___9) {
#line 530
    tmp___8 = "(using server ip)";
  } else {
    {
#line 530
    tmp___7 = pdnsd_a2str(& st->ping_a, buf___0, 16);
#line 530
    tmp___8 = tmp___7;
    }
  }
  {
#line 530
  _retval___10 = fsprintf(f, "\tping ip: %s\n", tmp___8);
  }
#line 530
  if (_retval___10 < 0) {
#line 530
    return (_retval___10);
  }
#line 531
  if (st->interface[0]) {
    {
#line 532
    _retval___11 = fsprintf(f, "\tinterface: %s\n", st->interface);
    }
#line 532
    if (_retval___11 < 0) {
#line 532
      return (_retval___11);
    }
  }
#line 534
  if (st->device[0]) {
    {
#line 535
    _retval___12 = fsprintf(f, "\tdevice (for special Linux ppp device support): %s\n",
                            st->device);
    }
#line 535
    if (_retval___12 < 0) {
#line 535
      return (_retval___12);
    }
  }
#line 537
  if (st->uptest_cmd) {
    {
#line 538
    _retval___13 = fsprintf(f, "\tuptest command: %s\n", st->uptest_cmd);
    }
#line 538
    if (_retval___13 < 0) {
#line 538
      return (_retval___13);
    }
#line 539
    if (st->uptest_usr[0]) {
#line 539
      tmp___10 = (char const   *)(st->uptest_usr);
    } else {
#line 539
      tmp___10 = "(process owner)";
    }
    {
#line 539
    _retval___14 = fsprintf(f, "\tuptest user: %s\n", tmp___10);
    }
#line 539
    if (_retval___14 < 0) {
#line 539
      return (_retval___14);
    }
  }
#line 541
  if (st->query_test_name) {
    {
#line 543
    tmp___11 = rhn2str((unsigned char const   *)st->query_test_name, nmbuf, (unsigned int )sizeof(nmbuf));
#line 543
    _retval___15 = fsprintf(f, "\tname used in query uptest: %s\n", tmp___11);
    }
#line 543
    if (_retval___15 < 0) {
#line 543
      return (_retval___15);
    }
  }
#line 546
  if (st->scheme[0]) {
    {
#line 547
    _retval___16 = fsprintf(f, "\tscheme: %s\n", st->scheme);
    }
#line 547
    if (_retval___16 < 0) {
#line 547
      return (_retval___16);
    }
  }
#line 549
  if (st->purge_cache) {
#line 549
    tmp___12 = "on";
  } else {
#line 549
    tmp___12 = "off";
  }
  {
#line 549
  _retval___17 = fsprintf(f, "\tforce cache purging: %s\n", tmp___12);
  }
#line 549
  if (_retval___17 < 0) {
#line 549
    return (_retval___17);
  }
#line 550
  if (st->nocache) {
#line 550
    tmp___13 = "off";
  } else {
#line 550
    tmp___13 = "on";
  }
  {
#line 550
  _retval___18 = fsprintf(f, "\tserver is cached: %s\n", tmp___13);
  }
#line 550
  if (_retval___18 < 0) {
#line 550
    return (_retval___18);
  }
#line 551
  if (st->lean_query) {
#line 551
    tmp___14 = "on";
  } else {
#line 551
    tmp___14 = "off";
  }
  {
#line 551
  _retval___19 = fsprintf(f, "\tlean query: %s\n", tmp___14);
  }
#line 551
  if (_retval___19 < 0) {
#line 551
    return (_retval___19);
  }
#line 552
  if (st->edns_query) {
#line 552
    tmp___15 = "on";
  } else {
#line 552
    tmp___15 = "off";
  }
  {
#line 552
  _retval___20 = fsprintf(f, "\tUse EDNS in outgoing queries: %s\n", tmp___15);
  }
#line 552
  if (_retval___20 < 0) {
#line 552
    return (_retval___20);
  }
#line 553
  if (st->is_proxy) {
#line 553
    tmp___16 = "on";
  } else {
#line 553
    tmp___16 = "off";
  }
  {
#line 553
  _retval___21 = fsprintf(f, "\tUse only proxy?: %s\n", tmp___16);
  }
#line 553
  if (_retval___21 < 0) {
#line 553
    return (_retval___21);
  }
#line 554
  if (st->rootserver) {
#line 554
    if ((int )st->rootserver == 1) {
#line 554
      tmp___17 = "yes";
    } else {
#line 554
      tmp___17 = "discover";
    }
#line 554
    tmp___18 = tmp___17;
  } else {
#line 554
    tmp___18 = "no";
  }
  {
#line 554
  _retval___22 = fsprintf(f, "\tAssumed root server: %s\n", tmp___18);
  }
#line 554
  if (_retval___22 < 0) {
#line 554
    return (_retval___22);
  }
#line 555
  if (st->rand_servers) {
#line 555
    tmp___19 = "yes";
  } else {
#line 555
    tmp___19 = "no";
  }
  {
#line 555
  _retval___23 = fsprintf(f, "\tRandomize server query order: %s\n", tmp___19);
  }
#line 555
  if (_retval___23 < 0) {
#line 555
    return (_retval___23);
  }
  {
#line 556
  tmp___20 = const_name((int )st->policy);
#line 556
  _retval___24 = fsprintf(f, "\tDefault policy: %s\n", tmp___20);
  }
#line 556
  if (_retval___24 < 0) {
#line 556
    return (_retval___24);
  }
#line 557
  if (st->alist) {
#line 557
    tmp___21 = "";
  } else {
#line 557
    tmp___21 = " (none)";
  }
  {
#line 557
  _retval___25 = fsprintf(f, "\tPolicies:%s\n", tmp___21);
  }
#line 557
  if (_retval___25 < 0) {
#line 557
    return (_retval___25);
  }
#line 558
  j = 0;
  {
#line 558
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 558
    tmp___25 = da_nel((darray )st->alist);
    }
#line 558
    if (! ((unsigned int )j < tmp___25)) {
#line 558
      goto while_break___0;
    }
    {
#line 559
    sl = & (st->alist)->elem[j];
#line 561
    tmp___22 = rhn2str((unsigned char const   *)sl->domain, buf___1, (unsigned int )sizeof(buf___1));
    }
#line 561
    if (sl->exact) {
#line 561
      tmp___23 = "";
    } else {
#line 561
      tmp___23 = ".";
    }
#line 561
    if ((int )sl->rule == 18) {
#line 561
      tmp___24 = "include";
    } else {
#line 561
      tmp___24 = "exclude";
    }
    {
#line 561
    _retval___26 = fsprintf(f, "\t\t%s: %s%s\n", tmp___24, tmp___23, tmp___22);
    }
#line 561
    if (_retval___26 < 0) {
#line 561
      return (_retval___26);
    }
#line 558
    j ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 566
  if ((unsigned long )st->reject_a4 != (unsigned long )((void *)0)) {
#line 566
    goto _L;
  } else
#line 566
  if ((unsigned long )st->reject_a6 != (unsigned long )((void *)0)) {
    _L: /* CIL Label */ 
    {
#line 567
    _retval___27 = fsprintf(f, "\tAddresses which should be rejected in replies:\n");
    }
#line 567
    if (_retval___27 < 0) {
#line 567
      return (_retval___27);
    }
    {
#line 568
    tmp___26 = da_nel((darray )st->reject_a4);
#line 568
    m = (int )tmp___26;
#line 569
    j = 0;
    }
    {
#line 569
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 569
      if (! (j < m)) {
#line 569
        goto while_break___1;
      }
      {
#line 570
      am = & (st->reject_a4)->elem[j];
#line 572
      tmp___27 = inet_ntop(2, (void const   */* __restrict  */)(& am->mask), (char */* __restrict  */)(mbuf),
                           (socklen_t )sizeof(mbuf));
#line 572
      tmp___28 = inet_ntop(2, (void const   */* __restrict  */)(& am->a), (char */* __restrict  */)(abuf),
                           (socklen_t )sizeof(abuf));
#line 572
      _retval___28 = fsprintf(f, "\t\t%s/%s\n", tmp___28, tmp___27);
      }
#line 572
      if (_retval___28 < 0) {
#line 572
        return (_retval___28);
      }
#line 569
      j ++;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 576
    tmp___29 = da_nel((darray )st->reject_a6);
#line 576
    m = (int )tmp___29;
#line 577
    j = 0;
    }
    {
#line 577
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 577
      if (! (j < m)) {
#line 577
        goto while_break___2;
      }
      {
#line 578
      am___0 = & (st->reject_a6)->elem[j];
#line 580
      tmp___30 = inet_ntop(10, (void const   */* __restrict  */)(& am___0->mask),
                           (char */* __restrict  */)(mbuf___0), (socklen_t )sizeof(mbuf___0));
#line 580
      tmp___31 = inet_ntop(10, (void const   */* __restrict  */)(& am___0->a), (char */* __restrict  */)(abuf___0),
                           (socklen_t )sizeof(abuf___0));
#line 580
      _retval___29 = fsprintf(f, "\t\t%s/%s\n", tmp___31, tmp___30);
      }
#line 580
      if (_retval___29 < 0) {
#line 580
        return (_retval___29);
      }
#line 577
      j ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 584
    tmp___32 = const_name((int )st->rejectpolicy);
#line 584
    _retval___30 = fsprintf(f, "\tReject policy: %s\n", tmp___32);
    }
#line 584
    if (_retval___30 < 0) {
#line 584
      return (_retval___30);
    }
#line 585
    if (st->rejectrecursively) {
#line 585
      tmp___33 = "yes";
    } else {
#line 585
      tmp___33 = "no";
    }
    {
#line 585
    _retval___31 = fsprintf(f, "\tReject recursively: %s\n", tmp___33);
    }
#line 585
    if (_retval___31 < 0) {
#line 585
      return (_retval___31);
    }
  }
#line 587
  return (0);
}
}
#line 111 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/thread.h"
__inline static int ( __attribute__((__always_inline__)) usleep_r)(unsigned long useconds ) ;
#line 60 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/helpers.h"
__inline static unsigned int ( __attribute__((__always_inline__)) rhnlen)(unsigned char const   *rhn ) ;
#line 180
__inline static ssize_t ( __attribute__((__always_inline__)) write_all)(int fd , void const   *data ,
                                                                        size_t n ) ;
#line 312 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) __mode_t ( __attribute__((__leaf__)) umask)(__mode_t __mask ) ;
#line 81 "/usr/include/x86_64-linux-gnu/sys/utsname.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) uname)(struct utsname *__name ) ;
#line 244 "/usr/include/pthread.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,3))) pthread_create)(pthread_t * __restrict  __newthread ,
                                                                                             pthread_attr_t const   * __restrict  __attr ,
                                                                                             void *(*__start_routine)(void * ) ,
                                                                                             void * __restrict  __arg ) ;
#line 826 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) unlink)(char const   *__name ) ;
#line 233 "/usr/include/x86_64-linux-gnu/sys/socket.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) listen)(int __fd ,
                                                                             int __n ) ;
#line 243
extern int accept(int __fd , struct sockaddr * __restrict  __addr , socklen_t * __restrict  __addr_len ) ;
#line 374 "/usr/include/netinet/in.h"
extern  __attribute__((__nothrow__)) uint32_t ( __attribute__((__leaf__)) ntohl)(uint32_t __netlong )  __attribute__((__const__)) ;
#line 57 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/list.h"
__inline static unsigned int ( __attribute__((__always_inline__)) da_nel)(darray a ) ;
#line 45 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/conff.h"
short stat_pipe ;
#line 30 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/status.h"
char *sock_path ;
#line 31 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/status.h"
int stat_sock  ;
#line 56
void init_stat_sock(void) ;
#line 57
int start_stat_sock(void) ;
#line 111 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/thread.h"
__inline static int ( __attribute__((__always_inline__)) usleep_r)(unsigned long useconds ) ;
#line 162 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/cache.h"
int empty_cache(slist_array sla ) ;
#line 167
int report_cache_stat(int f ) ;
#line 168
int dump_cache(int fd , unsigned char const   *name , int exact ) ;
#line 175
void del_cache(unsigned char const   *name ) ;
#line 176
void invalidate_record(unsigned char const   *name ) ;
#line 60 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/helpers.h"
__inline static unsigned int ( __attribute__((__always_inline__)) rhnlen)(unsigned char const   *rhn ) ;
#line 180
__inline static ssize_t ( __attribute__((__always_inline__)) write_all)(int fd , void const   *data ,
                                                                        size_t n ) ;
#line 39 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/servers.h"
int mark_servers(int i , char *label , int up ) ;
#line 45
int change_servers(int i , addr_array ar , int up ) ;
#line 30 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/dns_answer.h"
pthread_t statsock_thrid ;
#line 38
int report_thread_stat(int f ) ;
#line 56 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/status.c"
char *sock_path  =    (char *)((void *)0);
#line 61 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/status.c"
static int print_serr(int rs , char const   *msg ) 
{ 
  uint16_t cmd ;
  int *tmp ;
  char *tmp___0 ;
  ssize_t tmp___1 ;
  size_t tmp___2 ;
  ssize_t tmp___3 ;

  {
#line 65
  if (debug_p) {
    {
#line 65
    debug_msg(0, "Sending error message to control socket: \'%s\'\n", msg);
    }
  }
  {
#line 66
  cmd = htons((uint16_t )1);
#line 67
  tmp___1 = write(rs, (void const   *)(& cmd), sizeof(cmd));
  }
#line 67
  if ((unsigned long )tmp___1 != sizeof(cmd)) {
#line 67
    goto _L;
  } else {
    {
#line 67
    tmp___2 = strlen(msg);
#line 67
    tmp___3 = write_all(rs, (void const   *)msg, tmp___2);
    }
#line 67
    if (tmp___3 < 0L) {
      _L: /* CIL Label */ 
#line 70
      if (debug_p) {
        {
#line 70
        tmp = __errno_location();
#line 70
        tmp___0 = strerror(*tmp);
#line 70
        debug_msg(0, "Error writing to control socket: %s\n", tmp___0);
        }
      }
#line 71
      return (0);
    }
  }
#line 73
  return (1);
}
}
#line 77 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/status.c"
static int print_succ(int rs ) 
{ 
  uint16_t cmd ;
  int *tmp ;
  char *tmp___0 ;
  ssize_t tmp___1 ;

  {
  {
#line 81
  cmd = htons((uint16_t )0);
#line 82
  tmp___1 = write(rs, (void const   *)(& cmd), sizeof(cmd));
  }
#line 82
  if ((unsigned long )tmp___1 != sizeof(cmd)) {
#line 83
    if (debug_p) {
      {
#line 83
      tmp = __errno_location();
#line 83
      tmp___0 = strerror(*tmp);
#line 83
      debug_msg(0, "Error writing to control socket: %s\nFailed to send success code.\n",
                tmp___0);
      }
    }
#line 85
    return (0);
  }
#line 87
  return (1);
}
}
#line 91 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/status.c"
static int read_short___0(int fh , uint16_t *res ) 
{ 
  uint16_t cmd ;
  ssize_t tmp ;

  {
  {
#line 95
  tmp = read(fh, (void *)(& cmd), sizeof(cmd));
  }
#line 95
  if ((unsigned long )tmp != sizeof(cmd)) {
#line 97
    return (0);
  }
  {
#line 99
  *res = ntohs(cmd);
  }
#line 100
  return (1);
}
}
#line 104 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/status.c"
static int read_long(int fh , uint32_t *res ) 
{ 
  uint32_t cmd ;
  ssize_t tmp ;

  {
  {
#line 108
  tmp = read(fh, (void *)(& cmd), sizeof(cmd));
  }
#line 108
  if ((unsigned long )tmp != sizeof(cmd)) {
#line 110
    return (0);
  }
  {
#line 112
  *res = ntohl(cmd);
  }
#line 113
  return (1);
}
}
#line 122 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/status.c"
static int read_allocstring(int fh , char **res , unsigned int *len ) 
{ 
  uint16_t count ;
  char *buf ;
  unsigned int nread ;
  int tmp ;
  void *tmp___0 ;
  ssize_t m ;
  ssize_t tmp___1 ;

  {
  {
#line 128
  tmp = read_short___0(fh, & count);
  }
#line 128
  if (! tmp) {
#line 128
    return (0);
  }
#line 129
  if ((int )count == 65535) {
#line 129
    *res = (char *)((void *)0);
#line 129
    return (-1);
  }
  {
#line 130
  tmp___0 = malloc((size_t )((int )count + 1));
#line 130
  buf = (char *)tmp___0;
  }
#line 130
  if (! buf) {
#line 130
    return (0);
  }
#line 131
  nread = 0U;
  {
#line 132
  while (1) {
    while_continue: /* CIL Label */ ;
#line 132
    if (! (nread < (unsigned int )count)) {
#line 132
      goto while_break;
    }
    {
#line 133
    tmp___1 = read(fh, (void *)(buf + nread), (size_t )((unsigned int )count - nread));
#line 133
    m = tmp___1;
    }
#line 134
    if (m <= 0L) {
      {
#line 134
      free((void *)buf);
      }
#line 134
      return (0);
    }
#line 135
    nread = (unsigned int )((ssize_t )nread + m);
  }
  while_break: /* CIL Label */ ;
  }
#line 137
  *(buf + count) = (char)0;
#line 138
  *res = buf;
#line 139
  if (len) {
#line 139
    *len = (unsigned int )count;
  }
#line 140
  return (1);
}
}
#line 148 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/status.c"
static int read_domain(int fh , char *buf , unsigned int buflen ) 
{ 
  uint16_t count ;
  unsigned int nread ;
  int tmp ;
  ssize_t m ;
  ssize_t tmp___0 ;

  {
  {
#line 153
  tmp = read_short___0(fh, & count);
  }
#line 153
  if (! tmp) {
#line 153
    return (0);
  }
#line 154
  if ((int )count == 65535) {
#line 154
    return (-1);
  }
#line 155
  if ((unsigned int )count >= buflen) {
#line 155
    return (0);
  }
#line 156
  nread = 0U;
  {
#line 157
  while (1) {
    while_continue: /* CIL Label */ ;
#line 157
    if (! (nread < (unsigned int )count)) {
#line 157
      goto while_break;
    }
    {
#line 158
    tmp___0 = read(fh, (void *)(buf + nread), (size_t )((unsigned int )count - nread));
#line 158
    m = tmp___0;
    }
#line 159
    if (m <= 0L) {
#line 159
      return (0);
    }
#line 160
    nread = (unsigned int )((ssize_t )nread + m);
  }
  while_break: /* CIL Label */ ;
  }
#line 162
  *(buf + count) = (char)0;
#line 169
  return (1);
}
}
#line 172 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/status.c"
static void *status_thread(void *p ) 
{ 
  int tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  struct sockaddr_un ra ;
  socklen_t res ;
  int rs ;
  uint16_t cmd ;
  char const   *errmsg ;
  struct utsname nm ;
  int tmp___3 ;
  int *tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  char *label ;
  char *dnsaddr ;
  int indx ;
  uint16_t cmd2 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  char *endptr ;
  long tmp___13 ;
  unsigned int tmp___14 ;
  int tmp___15 ;
  int i ;
  char *servlabel ;
  int tmp___16 ;
  unsigned int tmp___17 ;
  int tmp___18 ;
  char *tmp___19 ;
  int tmp___20 ;
  int i___0 ;
  char *servlabel___0 ;
  int tmp___21 ;
  unsigned int tmp___22 ;
  char *ipstr ;
  char *q ;
  addr_array ar ;
  pdnsd_a addr ;
  int err ;
  unsigned short const   **tmp___23 ;
  char *tmp___24 ;
  unsigned short const   **tmp___25 ;
  int tmp___26 ;
  darray tmp___27 ;
  int tmp___28 ;
  char const   *tmp___29 ;
  char const   *tmp___30 ;
  uint16_t cmd2___0 ;
  unsigned char name[256] ;
  unsigned char buf[256] ;
  int tmp___31 ;
  int tmp___32 ;
  uint32_t ttl ;
  char *fn ;
  uint16_t servaliases ;
  uint16_t flags ;
  unsigned char buf___0[256] ;
  unsigned char owner[256] ;
  int tmp___33 ;
  int tmp___34 ;
  int tmp___35 ;
  int tmp___36 ;
  int tmp___37 ;
  char *errmsg___0 ;
  char const   *tmp___38 ;
  int tmp___39 ;
  uint32_t ttl___0 ;
  unsigned int sz ;
  uint16_t tp ;
  uint16_t flags___0 ;
  uint16_t nadr ;
  unsigned char name___0[256] ;
  unsigned char buf___1[256] ;
  unsigned char dbuf[258] ;
  size_t adrbufsz ;
  unsigned char *adrbuf ;
  int tmp___40 ;
  int tmp___41 ;
  int tmp___42 ;
  int tmp___43 ;
  int tmp___44 ;
  void *tmp___45 ;
  size_t nread ;
  ssize_t m ;
  ssize_t tmp___46 ;
  int tmp___47 ;
  ssize_t tmp___48 ;
  int tmp___49 ;
  unsigned int tmp___50 ;
  dns_cent_t cent ;
  int tmp___51 ;
  unsigned char *adrp ;
  int i___1 ;
  int tmp___52 ;
  int tmp___53 ;
  int tmp___54 ;
  uint32_t ttl___1 ;
  uint16_t tp___0 ;
  unsigned char name___1[256] ;
  unsigned char buf___2[256] ;
  int tmp___55 ;
  int tmp___56 ;
  int tmp___57 ;
  dns_cent_t cent___0 ;
  int tmp___58 ;
  int tmp___59 ;
  int tmp___60 ;
  char *fn___0 ;
  char *errmsg___1 ;
  int tmp___61 ;
  char const   *tmp___62 ;
  int tmp___63 ;
  char *fn___1 ;
  char *errmsg___2 ;
  int tmp___64 ;
  char const   *tmp___65 ;
  int tmp___66 ;
  char *str ;
  char *errmsg___3 ;
  int tmp___67 ;
  char const   *tmp___68 ;
  int tmp___69 ;
  slist_array sla ;
  char *names ;
  unsigned int len ;
  int tmp___70 ;
  char *p___0 ;
  char *last ;
  int tp___1 ;
  char *q___0 ;
  slist_t *sl ;
  unsigned int sz___0 ;
  unsigned char rhn[256] ;
  darray tmp___71 ;
  unsigned char *tmp___72 ;
  void *tmp___73 ;
  int tmp___74 ;
  int rv ;
  int exact ;
  unsigned char *nm___0 ;
  char buf___3[256] ;
  unsigned char rhn___0[256] ;
  int sz___1 ;
  int tmp___75 ;
  int *tmp___76 ;
  char *tmp___77 ;
  char const   *tmp___78 ;
  char const   *tmp___79 ;
  char const   *tmp___80 ;
  int tmp___81 ;
  int tmp___82 ;
  int *tmp___83 ;
  char *tmp___84 ;
  int *tmp___85 ;

  {
#line 177
  if (! global.strict_suid) {
    {
#line 178
    tmp = run_as((char const   *)(global.run_as));
    }
#line 178
    if (! tmp) {
      {
#line 179
      pdnsd_exit();
      }
    }
  }
  {
#line 183
  tmp___2 = listen(stat_sock, 5);
  }
#line 183
  if (tmp___2 == -1) {
    {
#line 184
    tmp___0 = __errno_location();
#line 184
    tmp___1 = strerror(*tmp___0);
#line 184
    log_message(4, "Error: could not listen on socket: %s.\nStatus readback will be impossible",
                tmp___1);
    }
#line 185
    goto exit_thread;
  }
  {
#line 187
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 189
    res = (socklen_t )sizeof(ra);
#line 191
    rs = accept(stat_sock, (struct sockaddr */* __restrict  */)((struct sockaddr *)(& ra)),
                (socklen_t */* __restrict  */)(& res));
    }
#line 191
    if (rs != -1) {
#line 193
      if (debug_p) {
        {
#line 193
        debug_msg(0, "Status socket query pending.\n");
        }
      }
      {
#line 194
      tmp___82 = read_short___0(rs, & cmd);
      }
#line 194
      if (tmp___82) {
#line 196
        if (((int )cmd & 65280) == 26624) {
#line 198
          cmd = (uint16_t )((int )cmd & 255);
          {
#line 200
          if ((int )cmd == 1) {
#line 200
            goto case_1;
          }
#line 216
          if ((int )cmd == 2) {
#line 216
            goto case_2;
          }
#line 347
          if ((int )cmd == 3) {
#line 347
            goto case_3;
          }
#line 371
          if ((int )cmd == 4) {
#line 371
            goto case_4;
          }
#line 415
          if ((int )cmd == 5) {
#line 415
            goto case_5;
          }
#line 528
          if ((int )cmd == 6) {
#line 528
            goto case_6;
          }
#line 571
          if ((int )cmd == 7) {
#line 571
            goto case_7;
          }
#line 587
          if ((int )cmd == 8) {
#line 587
            goto case_8;
          }
#line 603
          if ((int )cmd == 9) {
#line 603
            goto case_9;
          }
#line 619
          if ((int )cmd == 10) {
#line 619
            goto case_10;
          }
#line 682
          if ((int )cmd == 11) {
#line 682
            goto case_11;
          }
#line 731
          goto switch_default___1;
          case_1: /* CIL Label */ 
#line 202
          if (debug_p) {
            {
#line 202
            debug_msg(0, "Received STATUS query.\n");
            }
          }
          {
#line 203
          tmp___3 = print_succ(rs);
          }
#line 203
          if (! tmp___3) {
#line 204
            goto switch_break;
          }
          {
#line 205
          uname(& nm);
#line 206
          tmp___6 = fsprintf(rs, "pdnsd-%s running on %s.\n", "1.2.9a-par", nm.nodename);
          }
#line 206
          if (tmp___6 < 0) {
#line 206
            goto _L;
          } else {
            {
#line 206
            tmp___7 = report_cache_stat(rs);
            }
#line 206
            if (tmp___7 < 0) {
#line 206
              goto _L;
            } else {
              {
#line 206
              tmp___8 = report_thread_stat(rs);
              }
#line 206
              if (tmp___8 < 0) {
#line 206
                goto _L;
              } else {
                {
#line 206
                tmp___9 = report_conf_stat(rs);
                }
#line 206
                if (tmp___9 < 0) {
                  _L: /* CIL Label */ 
#line 211
                  if (debug_p) {
                    {
#line 211
                    tmp___4 = __errno_location();
#line 211
                    tmp___5 = strerror(*tmp___4);
#line 211
                    debug_msg(0, "Error writing to control socket: %s\nFailed to send status report.\n",
                              tmp___5);
                    }
                  }
                }
              }
            }
          }
#line 215
          goto switch_break;
          case_2: /* CIL Label */ 
#line 220
          if (debug_p) {
            {
#line 220
            debug_msg(0, "Received SERVER command.\n");
            }
          }
          {
#line 221
          tmp___10 = read_allocstring(rs, & label, (unsigned int *)((void *)0));
          }
#line 221
          if (tmp___10 <= 0) {
            {
#line 222
            print_serr(rs, "Error reading server label.");
            }
#line 223
            goto switch_break;
          }
          {
#line 225
          tmp___11 = read_short___0(rs, & cmd2);
          }
#line 225
          if (! tmp___11) {
            {
#line 226
            print_serr(rs, "Missing up|down|retest.");
            }
#line 227
            goto free_label_break;
          }
          {
#line 229
          tmp___12 = read_allocstring(rs, & dnsaddr, (unsigned int *)((void *)0));
          }
#line 229
          if (! tmp___12) {
            {
#line 230
            print_serr(rs, "Error reading DNS addresses.");
            }
#line 231
            goto free_label_break;
          }
          {
#line 244
          tmp___13 = strtol((char const   */* __restrict  */)label, (char **/* __restrict  */)(& endptr),
                            0);
#line 244
          indx = (int )tmp___13;
          }
#line 245
          if (! *endptr) {
#line 246
            if (indx < 0) {
              {
#line 247
              print_serr(rs, "Server index out of range.");
              }
#line 248
              goto free_dnsaddr_label_break;
            } else {
              {
#line 246
              tmp___14 = da_nel((darray )servers);
              }
#line 246
              if ((unsigned int )indx >= tmp___14) {
                {
#line 247
                print_serr(rs, "Server index out of range.");
                }
#line 248
                goto free_dnsaddr_label_break;
              }
            }
          } else {
            {
#line 252
            tmp___15 = strcmp((char const   *)label, "all");
            }
#line 252
            if (tmp___15) {
#line 255
              indx = -1;
            } else {
#line 253
              indx = -2;
            }
          }
#line 258
          if ((int )cmd2 == 1) {
#line 258
            goto _L___0;
          } else
#line 258
          if ((int )cmd2 == 2) {
#line 258
            goto _L___0;
          } else
#line 258
          if ((int )cmd2 == 3) {
            _L___0: /* CIL Label */ 
#line 259
            if (! dnsaddr) {
#line 260
              if (indx == -1) {
#line 262
                i = 0;
                {
#line 262
                while (1) {
                  while_continue___0: /* CIL Label */ ;
                  {
#line 262
                  tmp___17 = da_nel((darray )servers);
                  }
#line 262
                  if (! ((unsigned int )i < tmp___17)) {
#line 262
                    goto while_break___0;
                  }
#line 263
                  servlabel = servers->elem[i].label;
#line 264
                  if (servlabel) {
                    {
#line 264
                    tmp___16 = strcmp((char const   *)servlabel, (char const   *)label);
                    }
#line 264
                    if (! tmp___16) {
#line 265
                      goto found_label;
                    }
                  }
#line 262
                  i ++;
                }
                while_break___0: /* CIL Label */ ;
                }
                {
#line 267
                print_serr(rs, "Bad server label.");
                }
#line 268
                goto free_dnsaddr_label_break;
                found_label: ;
              }
#line 271
              if ((int )cmd2 == 3) {
#line 271
                tmp___18 = -1;
              } else {
#line 271
                tmp___18 = (int )cmd2 == 1;
              }
#line 271
              if (indx == -1) {
#line 271
                tmp___19 = label;
              } else {
#line 271
                tmp___19 = (char *)((void *)0);
              }
              {
#line 271
              tmp___20 = mark_servers(indx, tmp___19, tmp___18);
              }
#line 271
              if (tmp___20 == 0) {
                {
#line 272
                print_succ(rs);
                }
              } else {
                {
#line 274
                print_serr(rs, "Could not start up or signal server status thread.");
                }
              }
            } else {
#line 277
              if (indx == -2) {
                {
#line 278
                print_serr(rs, "Can\'t use label \"all\" to change server addresses.");
                }
#line 279
                goto free_dnsaddr_label_break;
              }
#line 281
              if (indx == -1) {
#line 283
                i___0 = 0;
                {
#line 283
                while (1) {
                  while_continue___1: /* CIL Label */ ;
                  {
#line 283
                  tmp___22 = da_nel((darray )servers);
                  }
#line 283
                  if (! ((unsigned int )i___0 < tmp___22)) {
#line 283
                    goto while_break___1;
                  }
#line 284
                  servlabel___0 = servers->elem[i___0].label;
#line 285
                  if (servlabel___0) {
                    {
#line 285
                    tmp___21 = strcmp((char const   *)servlabel___0, (char const   *)label);
                    }
#line 285
                    if (! tmp___21) {
#line 286
                      if (indx != -1) {
                        {
#line 287
                        print_serr(rs, "server label must be unique to change server addresses.");
                        }
#line 288
                        goto free_dnsaddr_label_break;
                      }
#line 290
                      indx = i___0;
                    }
                  }
#line 283
                  i___0 ++;
                }
                while_break___1: /* CIL Label */ ;
                }
#line 293
                if (indx == -1) {
                  {
#line 294
                  print_serr(rs, "Bad server label.");
                  }
#line 295
                  goto free_dnsaddr_label_break;
                }
              }
#line 299
              q = dnsaddr;
#line 300
              ar = (addr_array )((void *)0);
              {
#line 303
              while (1) {
                while_continue___2: /* CIL Label */ ;
                {
#line 304
                while (1) {
                  while_continue___3: /* CIL Label */ ;
#line 305
                  if (! *q) {
#line 305
                    goto change_servs;
                  }
#line 306
                  if ((int )*q != 44) {
                    {
#line 306
                    tmp___23 = __ctype_b_loc();
                    }
#line 306
                    if (! ((int const   )*(*tmp___23 + (int )*q) & 8192)) {
#line 306
                      goto while_break___3;
                    }
                  }
#line 307
                  q ++;
                }
                while_break___3: /* CIL Label */ ;
                }
#line 309
                ipstr = q;
                {
#line 310
                while (1) {
                  while_continue___4: /* CIL Label */ ;
#line 311
                  q ++;
#line 312
                  if (! *q) {
#line 312
                    goto while_break___4;
                  }
#line 313
                  if ((int )*q == 44) {
#line 313
                    tmp___24 = q;
#line 313
                    q ++;
#line 313
                    *tmp___24 = (char)0;
#line 313
                    goto while_break___4;
                  } else {
                    {
#line 313
                    tmp___25 = __ctype_b_loc();
                    }
#line 313
                    if ((int const   )*(*tmp___25 + (int )*q) & 8192) {
#line 313
                      tmp___24 = q;
#line 313
                      q ++;
#line 313
                      *tmp___24 = (char)0;
#line 313
                      goto while_break___4;
                    }
                  }
                }
                while_break___4: /* CIL Label */ ;
                }
                {
#line 315
                tmp___26 = str2pdnsd_a((char const   *)ipstr, & addr);
                }
#line 315
                if (! tmp___26) {
                  {
#line 316
                  print_serr(rs, "Bad server ip");
                  }
#line 317
                  goto free_ar;
                }
                {
#line 319
                tmp___27 = da_grow1((darray )ar, (size_t )(((addr_array )0)->elem),
                                    sizeof(ar->elem[0]), (void (*)(void * ))((void *)0));
#line 319
                ar = (addr_array )tmp___27;
                }
#line 319
                if (! ar) {
                  {
#line 320
                  print_serr(rs, "Out of memory.");
                  }
#line 321
                  goto free_dnsaddr_label_break;
                }
#line 323
                ar->elem[ar->nel - 1UL] = addr;
              }
              while_break___2: /* CIL Label */ ;
              }
              change_servs: 
#line 326
              if ((int )cmd2 == 3) {
#line 326
                tmp___28 = -1;
              } else {
#line 326
                tmp___28 = (int )cmd2 == 1;
              }
              {
#line 326
              err = change_servers(indx, ar, tmp___28);
              }
#line 327
              if (err == 0) {
                {
#line 328
                print_succ(rs);
                }
              } else {
#line 330
                if (err == 110) {
#line 330
                  tmp___30 = "Timed out while trying to gain access to server data.";
                } else {
#line 330
                  if (err == 12) {
#line 330
                    tmp___29 = "Out of memory.";
                  } else {
#line 330
                    tmp___29 = "Could not start up or signal server status thread.";
                  }
#line 330
                  tmp___30 = tmp___29;
                }
                {
#line 330
                print_serr(rs, tmp___30);
                }
              }
              free_ar: 
              {
#line 334
              free((void *)ar);
              }
            }
          } else {
            {
#line 339
            print_serr(rs, "Bad command.");
            }
          }
          free_dnsaddr_label_break: 
          {
#line 342
          free((void *)dnsaddr);
          }
          free_label_break: 
          {
#line 344
          free((void *)label);
          }
#line 346
          goto switch_break;
          case_3: /* CIL Label */ 
#line 350
          if (debug_p) {
            {
#line 350
            debug_msg(0, "Received RECORD command.\n");
            }
          }
          {
#line 351
          tmp___31 = read_short___0(rs, & cmd2___0);
          }
#line 351
          if (! tmp___31) {
#line 352
            goto incomplete_command;
          }
          {
#line 353
          tmp___32 = read_domain(rs, (char *)(buf), (unsigned int )sizeof(buf));
          }
#line 353
          if (tmp___32 <= 0) {
#line 354
            goto incomplete_command;
          }
          {
#line 355
          errmsg = parsestr2rhn((unsigned char const   *)(buf), (unsigned int )sizeof(buf),
                                name);
          }
#line 355
          if ((unsigned long )errmsg != (unsigned long )((void *)0)) {
#line 356
            goto bad_domain_name;
          }
          {
#line 358
          if ((int )cmd2___0 == 1) {
#line 358
            goto case_1___0;
          }
#line 362
          if ((int )cmd2___0 == 2) {
#line 362
            goto case_2___0;
          }
#line 366
          goto switch_default;
          case_1___0: /* CIL Label */ 
          {
#line 359
          del_cache((unsigned char const   *)(name));
#line 360
          print_succ(rs);
          }
#line 361
          goto switch_break___0;
          case_2___0: /* CIL Label */ 
          {
#line 363
          invalidate_record((unsigned char const   *)(name));
#line 364
          print_succ(rs);
          }
#line 365
          goto switch_break___0;
          switch_default: /* CIL Label */ 
          {
#line 367
          print_serr(rs, "Bad command.");
          }
          switch_break___0: /* CIL Label */ ;
          }
#line 370
          goto switch_break;
          case_4: /* CIL Label */ 
#line 377
          if (debug_p) {
            {
#line 377
            debug_msg(0, "Received SOURCE command.\n");
            }
          }
          {
#line 378
          tmp___33 = read_allocstring(rs, & fn, (unsigned int *)((void *)0));
          }
#line 378
          if (tmp___33 <= 0) {
            {
#line 379
            print_serr(rs, "Bad filename name.");
            }
#line 380
            goto switch_break;
          }
          {
#line 382
          tmp___34 = read_domain(rs, (char *)(buf___0), (unsigned int )sizeof(buf___0));
          }
#line 382
          if (tmp___34 <= 0) {
            {
#line 387
            print_serr(rs, "Malformed or incomplete command.");
            }
#line 388
            goto free_fn;
          } else {
            {
#line 382
            tmp___35 = read_long(rs, & ttl);
            }
#line 382
            if (tmp___35) {
              {
#line 382
              tmp___36 = read_short___0(rs, & servaliases);
              }
#line 382
              if (tmp___36) {
                {
#line 382
                tmp___37 = read_short___0(rs, & flags);
                }
#line 382
                if (! tmp___37) {
                  {
#line 387
                  print_serr(rs, "Malformed or incomplete command.");
                  }
#line 388
                  goto free_fn;
                }
              } else {
                {
#line 387
                print_serr(rs, "Malformed or incomplete command.");
                }
#line 388
                goto free_fn;
              }
            } else {
              {
#line 387
              print_serr(rs, "Malformed or incomplete command.");
              }
#line 388
              goto free_fn;
            }
          }
          {
#line 390
          errmsg = parsestr2rhn((unsigned char const   *)(buf___0), (unsigned int )sizeof(buf___0),
                                owner);
          }
#line 390
          if ((unsigned long )errmsg != (unsigned long )((void *)0)) {
            {
#line 391
            print_serr(rs, errmsg);
            }
#line 392
            goto free_fn;
          }
#line 394
          if (ttl < 0U) {
            {
#line 395
            print_serr(rs, "Bad TTL.");
            }
#line 396
            goto free_fn;
          }
#line 398
          if ((int )flags & 1) {
            {
#line 399
            print_serr(rs, "Bad cache flags.");
            }
#line 400
            goto free_fn;
          }
          {
#line 404
          tmp___39 = read_hosts((char const   *)fn, owner, (time_t )ttl, (unsigned int )flags,
                                (int )servaliases, & errmsg___0);
          }
#line 404
          if (tmp___39) {
            {
#line 405
            print_succ(rs);
            }
          } else {
#line 407
            tmp___38 = (char const   *)errmsg___0;
#line 407
            if (! tmp___38) {
#line 407
              tmp___38 = "Out of memory.";
            }
            {
#line 407
            print_serr(rs, tmp___38);
#line 408
            free((void *)errmsg___0);
            }
          }
          free_fn: 
          {
#line 412
          free((void *)fn);
          }
#line 414
          goto switch_break;
          case_5: /* CIL Label */ 
#line 418
          nadr = (uint16_t )0;
#line 420
          adrbufsz = (size_t )0;
#line 421
          adrbuf = (unsigned char *)((void *)0);
#line 423
          if (debug_p) {
            {
#line 423
            debug_msg(0, "Received ADD command.\n");
            }
          }
          {
#line 424
          tmp___40 = read_short___0(rs, & tp);
          }
#line 424
          if (! tmp___40) {
#line 425
            goto incomplete_command;
          }
          {
#line 426
          tmp___41 = read_domain(rs, (char *)(buf___1), (unsigned int )sizeof(buf___1));
          }
#line 426
          if (tmp___41 <= 0) {
#line 427
            goto incomplete_command;
          }
          {
#line 428
          tmp___42 = read_long(rs, & ttl___0);
          }
#line 428
          if (! tmp___42) {
#line 429
            goto incomplete_command;
          }
          {
#line 430
          tmp___43 = read_short___0(rs, & flags___0);
          }
#line 430
          if (! tmp___43) {
#line 431
            goto incomplete_command;
          }
          {
#line 432
          errmsg = parsestr2rhn((unsigned char const   *)(buf___1), (unsigned int )sizeof(buf___1),
                                name___0);
          }
#line 432
          if ((unsigned long )errmsg != (unsigned long )((void *)0)) {
#line 433
            goto bad_domain_name;
          }
#line 434
          if (ttl___0 < 0U) {
#line 435
            goto bad_ttl;
          }
#line 436
          if ((int )flags___0 & 1) {
#line 437
            goto bad_flags;
          }
          {
#line 440
          if ((int )tp == 1) {
#line 440
            goto case_1___1;
          }
#line 444
          if ((int )tp == 28) {
#line 444
            goto case_28;
          }
#line 467
          if ((int )tp == 2) {
#line 467
            goto case_2___1;
          }
#line 467
          if ((int )tp == 12) {
#line 467
            goto case_2___1;
          }
#line 467
          if ((int )tp == 5) {
#line 467
            goto case_2___1;
          }
#line 474
          if ((int )tp == 15) {
#line 474
            goto case_15;
          }
#line 483
          goto switch_default___0;
          case_1___1: /* CIL Label */ 
#line 441
          sz = (unsigned int )sizeof(struct in_addr );
#line 443
          goto read_adress_list;
          case_28: /* CIL Label */ 
#line 445
          sz = (unsigned int )sizeof(struct in6_addr );
          read_adress_list: 
          {
#line 448
          tmp___44 = read_short___0(rs, & nadr);
          }
#line 448
          if (! tmp___44) {
#line 449
            goto incomplete_command;
          }
#line 450
          if (! nadr) {
#line 451
            goto bad_arg;
          }
          {
#line 452
          adrbufsz = (size_t )nadr * (size_t )sz;
#line 453
          tmp___45 = malloc(adrbufsz);
#line 453
          adrbuf = (unsigned char *)tmp___45;
          }
#line 454
          if (! adrbuf) {
#line 455
            goto out_of_memory;
          }
#line 457
          nread = (size_t )0;
          {
#line 458
          while (1) {
            while_continue___5: /* CIL Label */ ;
#line 458
            if (! (nread < adrbufsz)) {
#line 458
              goto while_break___5;
            }
            {
#line 459
            tmp___46 = read(rs, (void *)(adrbuf + nread), adrbufsz - nread);
#line 459
            m = tmp___46;
            }
#line 460
            if (m <= 0L) {
              {
#line 460
              free((void *)adrbuf);
              }
#line 460
              goto bad_arg;
            }
#line 461
            nread += (size_t )m;
          }
          while_break___5: /* CIL Label */ ;
          }
#line 464
          goto switch_break___1;
          case_2___1: /* CIL Label */ 
          case_12: /* CIL Label */ 
          case_5___0: /* CIL Label */ 
          {
#line 468
          tmp___47 = read_domain(rs, (char *)(buf___1), (unsigned int )sizeof(buf___1));
          }
#line 468
          if (tmp___47 <= 0) {
#line 469
            goto incomplete_command;
          }
          {
#line 470
          errmsg = parsestr2rhn((unsigned char const   *)(buf___1), (unsigned int )sizeof(buf___1),
                                dbuf);
          }
#line 470
          if ((unsigned long )errmsg != (unsigned long )((void *)0)) {
#line 471
            goto bad_domain_name;
          }
          {
#line 472
          sz = rhnlen((unsigned char const   *)(dbuf));
          }
#line 473
          goto switch_break___1;
          case_15: /* CIL Label */ 
          {
#line 475
          tmp___48 = read(rs, (void *)(dbuf), (size_t )2);
          }
#line 475
          if (tmp___48 != 2L) {
#line 476
            goto bad_arg;
          }
          {
#line 477
          tmp___49 = read_domain(rs, (char *)(buf___1), (unsigned int )sizeof(buf___1));
          }
#line 477
          if (tmp___49 <= 0) {
#line 478
            goto incomplete_command;
          }
          {
#line 479
          errmsg = parsestr2rhn((unsigned char const   *)(buf___1), (unsigned int )sizeof(buf___1),
                                dbuf + 2);
          }
#line 479
          if ((unsigned long )errmsg != (unsigned long )((void *)0)) {
#line 480
            goto bad_domain_name;
          }
          {
#line 481
          tmp___50 = rhnlen((unsigned char const   *)(dbuf + 2));
#line 481
          sz = tmp___50 + 2U;
          }
#line 482
          goto switch_break___1;
          switch_default___0: /* CIL Label */ 
#line 484
          goto bad_arg;
          switch_break___1: /* CIL Label */ ;
          }
          {
#line 489
          tmp___51 = init_cent(& cent, (unsigned char const   *)(name___0), (time_t )0,
                               (time_t )0, (unsigned int )flags___0);
          }
#line 489
          if (! tmp___51) {
            {
#line 490
            free((void *)adrbuf);
            }
#line 491
            goto out_of_memory;
          }
#line 493
          if (adrbuf) {
#line 495
            adrp = adrbuf;
#line 495
            i___1 = 0;
            {
#line 495
            while (1) {
              while_continue___6: /* CIL Label */ ;
#line 495
              if (! (i___1 < (int )nadr)) {
#line 495
                goto while_break___6;
              }
              {
#line 496
              tmp___52 = add_cent_rr(& cent, (int )tp, (time_t )ttl___0, (time_t )0,
                                     2U, sz, (void *)adrp);
              }
#line 496
              if (! tmp___52) {
                {
#line 497
                free_cent(& cent);
#line 498
                free((void *)adrbuf);
                }
#line 499
                goto out_of_memory;
              }
#line 495
              adrp += sz;
#line 495
              i___1 ++;
            }
            while_break___6: /* CIL Label */ ;
            }
            {
#line 502
            free((void *)adrbuf);
            }
          } else {
            {
#line 504
            tmp___53 = add_cent_rr(& cent, (int )tp, (time_t )ttl___0, (time_t )0,
                                   2U, sz, (void *)(dbuf));
            }
#line 504
            if (! tmp___53) {
              {
#line 505
              free_cent(& cent);
              }
#line 506
              goto out_of_memory;
            }
          }
#line 509
          if ((int )*(cent.qname + 0) == 1) {
#line 509
            if ((int )*(cent.qname + 1) == 42) {
              {
#line 512
              tmp___54 = set_cent_flags((unsigned char const   *)(cent.qname + 2),
                                        16U);
              }
#line 512
              if (! tmp___54) {
                {
#line 513
                print_serr(rs, "Before defining records for a name with a wildcard you must first define some records for the name with \'*.\' removed.");
                }
#line 517
                goto cleanup_cent;
              }
            }
          }
          {
#line 521
          add_cache(& cent);
#line 522
          print_succ(rs);
          }
          cleanup_cent: 
          {
#line 524
          free_cent(& cent);
          }
#line 527
          goto switch_break;
          case_6: /* CIL Label */ 
#line 533
          if (debug_p) {
            {
#line 533
            debug_msg(0, "Received NEG command.\n");
            }
          }
          {
#line 534
          tmp___55 = read_domain(rs, (char *)(buf___2), (unsigned int )sizeof(buf___2));
          }
#line 534
          if (tmp___55 <= 0) {
#line 535
            goto incomplete_command;
          }
          {
#line 536
          tmp___56 = read_short___0(rs, & tp___0);
          }
#line 536
          if (! tmp___56) {
#line 537
            goto incomplete_command;
          }
          {
#line 538
          tmp___57 = read_long(rs, & ttl___1);
          }
#line 538
          if (! tmp___57) {
#line 539
            goto incomplete_command;
          }
          {
#line 540
          errmsg = parsestr2rhn((unsigned char const   *)(buf___2), (unsigned int )sizeof(buf___2),
                                name___1);
          }
#line 540
          if ((unsigned long )errmsg != (unsigned long )((void *)0)) {
#line 541
            if (debug_p) {
              {
#line 541
              debug_msg(0, "NEG: received bad domain name.\n");
              }
            }
#line 542
            goto bad_domain_name;
          }
#line 544
          if ((int )tp___0 != 255) {
#line 544
            if ((int )tp___0 < 1) {
#line 544
              goto _L___1;
            } else
#line 544
            if ((int )tp___0 > 51) {
#line 544
              goto _L___1;
            } else
#line 544
            if ((int const   )rrlkuptab[(int )tp___0 - 1] >= 47) {
              _L___1: /* CIL Label */ 
#line 545
              if (debug_p) {
                {
#line 545
                debug_msg(0, "NEG: received bad record type.\n");
                }
              }
              {
#line 546
              print_serr(rs, "Bad record type.");
              }
#line 547
              goto switch_break;
            }
          }
#line 549
          if (ttl___1 < 0U) {
#line 550
            goto bad_ttl;
          }
#line 554
          if ((int )tp___0 == 255) {
            {
#line 555
            tmp___58 = init_cent(& cent___0, (unsigned char const   *)(name___1),
                                 (time_t )ttl___1, (time_t )0, 3U);
            }
#line 555
            if (! tmp___58) {
#line 556
              goto out_of_memory;
            }
          } else {
            {
#line 558
            tmp___59 = init_cent(& cent___0, (unsigned char const   *)(name___1),
                                 (time_t )0, (time_t )0, 0U);
            }
#line 558
            if (! tmp___59) {
#line 559
              goto out_of_memory;
            }
            {
#line 560
            tmp___60 = add_cent_rrset_by_type(& cent___0, (int )tp___0, (time_t )ttl___1,
                                              (time_t )0, 3U);
            }
#line 560
            if (! tmp___60) {
              {
#line 561
              free_cent(& cent___0);
              }
#line 562
              goto out_of_memory;
            }
          }
          {
#line 565
          add_cache(& cent___0);
#line 566
          free_cent(& cent___0);
#line 568
          print_succ(rs);
          }
#line 570
          goto switch_break;
          case_7: /* CIL Label */ 
#line 573
          if (debug_p) {
            {
#line 573
            debug_msg(0, "Received CONFIG command.\n");
            }
          }
          {
#line 574
          tmp___61 = read_allocstring(rs, & fn___0, (unsigned int *)((void *)0));
          }
#line 574
          if (! tmp___61) {
            {
#line 575
            print_serr(rs, "Bad filename name.");
            }
#line 576
            goto switch_break;
          }
          {
#line 578
          tmp___63 = reload_config_file((char const   *)fn___0, & errmsg___1);
          }
#line 578
          if (tmp___63) {
            {
#line 579
            print_succ(rs);
            }
          } else {
#line 581
            tmp___62 = (char const   *)errmsg___1;
#line 581
            if (! tmp___62) {
#line 581
              tmp___62 = "Out of memory.";
            }
            {
#line 581
            print_serr(rs, tmp___62);
#line 582
            free((void *)errmsg___1);
            }
          }
          {
#line 584
          free((void *)fn___0);
          }
#line 586
          goto switch_break;
          case_8: /* CIL Label */ 
#line 589
          if (debug_p) {
            {
#line 589
            debug_msg(0, "Received INCLUDE command.\n");
            }
          }
          {
#line 590
          tmp___64 = read_allocstring(rs, & fn___1, (unsigned int *)((void *)0));
          }
#line 590
          if (tmp___64 <= 0) {
            {
#line 591
            print_serr(rs, "Bad filename name.");
            }
#line 592
            goto switch_break;
          }
          {
#line 594
          tmp___66 = read_config_file((char const   *)fn___1, (globparm_t *)((void *)0),
                                      (servparm_array *)((void *)0), 0, & errmsg___2);
          }
#line 594
          if (tmp___66) {
            {
#line 595
            print_succ(rs);
            }
          } else {
#line 597
            tmp___65 = (char const   *)errmsg___2;
#line 597
            if (! tmp___65) {
#line 597
              tmp___65 = "Out of memory.";
            }
            {
#line 597
            print_serr(rs, tmp___65);
#line 598
            free((void *)errmsg___2);
            }
          }
          {
#line 600
          free((void *)fn___1);
          }
#line 602
          goto switch_break;
          case_9: /* CIL Label */ 
#line 605
          if (debug_p) {
            {
#line 605
            debug_msg(0, "Received EVAL command.\n");
            }
          }
          {
#line 606
          tmp___67 = read_allocstring(rs, & str, (unsigned int *)((void *)0));
          }
#line 606
          if (! tmp___67) {
            {
#line 607
            print_serr(rs, "Bad input string.");
            }
#line 608
            goto switch_break;
          }
          {
#line 610
          tmp___69 = confparse((FILE *)((void *)0), str, (globparm_t *)((void *)0),
                               (servparm_array *)((void *)0), 0, & errmsg___3);
          }
#line 610
          if (tmp___69) {
            {
#line 611
            print_succ(rs);
            }
          } else {
#line 613
            tmp___68 = (char const   *)errmsg___3;
#line 613
            if (! tmp___68) {
#line 613
              tmp___68 = "Out of memory.";
            }
            {
#line 613
            print_serr(rs, tmp___68);
#line 614
            free((void *)errmsg___3);
            }
          }
          {
#line 616
          free((void *)str);
          }
#line 618
          goto switch_break;
          case_10: /* CIL Label */ 
#line 620
          sla = (slist_array )((void *)0);
#line 623
          if (debug_p) {
            {
#line 623
            debug_msg(0, "Received EMPTY command.\n");
            }
          }
          {
#line 624
          tmp___70 = read_allocstring(rs, & names, & len);
          }
#line 624
          if (! tmp___70) {
            {
#line 625
            print_serr(rs, "Bad arguments.");
            }
#line 626
            goto switch_break;
          }
#line 628
          if (names) {
#line 629
            p___0 = names;
#line 629
            last = names + len;
            {
#line 631
            while (1) {
              while_continue___7: /* CIL Label */ ;
#line 631
              if (! ((unsigned long )p___0 < (unsigned long )last)) {
#line 631
                goto while_break___7;
              }
#line 638
              if ((int )*p___0 == 45) {
#line 639
                tp___1 = 19;
#line 640
                p___0 ++;
              } else {
#line 643
                tp___1 = 18;
#line 644
                if ((int )*p___0 == 43) {
#line 644
                  p___0 ++;
                }
              }
#line 647
              if ((unsigned long )(p___0 + 1) < (unsigned long )last) {
#line 647
                if ((int )*p___0 == 46) {
#line 647
                  if (*(p___0 + 1)) {
#line 647
                    p___0 ++;
                  }
                }
              }
#line 648
              q___0 = p___0;
              {
#line 649
              while (1) {
                while_continue___8: /* CIL Label */ ;
#line 649
                if ((unsigned long )q___0 < (unsigned long )last) {
#line 649
                  if (! *q___0) {
#line 649
                    goto while_break___8;
                  }
                } else {
#line 649
                  goto while_break___8;
                }
#line 649
                q___0 ++;
              }
              while_break___8: /* CIL Label */ ;
              }
              {
#line 650
              errmsg = parsestr2rhn((unsigned char const   *)((unsigned char *)p___0),
                                    (unsigned int )(q___0 - p___0), rhn);
              }
#line 650
              if ((unsigned long )errmsg != (unsigned long )((void *)0)) {
#line 651
                if (debug_p) {
                  {
#line 651
                  debug_msg(0, "EMPTY: received bad domain name: %s\n", p___0);
                  }
                }
                {
#line 652
                print_serr(rs, errmsg);
                }
#line 653
                goto free_sla_names_break;
              }
              {
#line 655
              sz___0 = rhnlen((unsigned char const   *)(rhn));
#line 656
              tmp___71 = da_grow1((darray )sla, (size_t )(((slist_array )0)->elem),
                                  sizeof(sla->elem[0]), & free_slist_domain);
#line 656
              sla = (slist_array )tmp___71;
              }
#line 656
              if (! sla) {
                {
#line 657
                print_serr(rs, "Out of memory.");
                }
#line 658
                goto free_names_break;
              }
              {
#line 660
              sl = & sla->elem[sla->nel - 1UL];
#line 662
              tmp___73 = malloc((size_t )sz___0);
#line 662
              tmp___72 = (unsigned char *)tmp___73;
#line 662
              sl->domain = tmp___72;
              }
#line 662
              if (! tmp___72) {
                {
#line 663
                print_serr(rs, "Out of memory.");
                }
#line 664
                goto free_sla_names_break;
              }
              {
#line 666
              memcpy((void */* __restrict  */)sl->domain, (void const   */* __restrict  */)(rhn),
                     (size_t )sz___0);
#line 667
              sl->exact = (short)0;
#line 668
              sl->rule = (short )tp___1;
#line 669
              p___0 = q___0 + 1;
              }
            }
            while_break___7: /* CIL Label */ ;
            }
          }
          {
#line 672
          tmp___74 = empty_cache(sla);
          }
#line 672
          if (tmp___74) {
            {
#line 673
            print_succ(rs);
            }
          } else {
            {
#line 675
            print_serr(rs, "Could not lock the cache.");
            }
          }
          free_sla_names_break: 
          {
#line 677
          free_slist_array(sla);
          }
          free_names_break: 
          {
#line 679
          free((void *)names);
          }
#line 681
          goto switch_break;
          case_11: /* CIL Label */ 
#line 683
          exact = 0;
#line 684
          nm___0 = (unsigned char *)((void *)0);
#line 687
          if (debug_p) {
            {
#line 687
            debug_msg(0, "Received DUMP command.\n");
            }
          }
          {
#line 688
          rv = read_domain(rs, buf___3, (unsigned int )sizeof(buf___3));
          }
#line 688
          if (! rv) {
            {
#line 689
            print_serr(rs, "Bad domain name.");
            }
#line 690
            goto switch_break;
          }
#line 692
          if (rv > 0) {
#line 694
            exact = 1;
#line 694
            nm___0 = (unsigned char *)(buf___3);
#line 694
            sz___1 = (int )sizeof(buf___3);
#line 695
            if ((int )buf___3[0] == 46) {
#line 695
              if (buf___3[1]) {
#line 696
                exact = 0;
#line 696
                nm___0 ++;
#line 696
                sz___1 --;
              }
            }
            {
#line 698
            errmsg = parsestr2rhn((unsigned char const   *)nm___0, (unsigned int )sz___1,
                                  rhn___0);
            }
#line 698
            if ((unsigned long )errmsg != (unsigned long )((void *)0)) {
#line 699
              goto bad_domain_name;
            }
#line 700
            nm___0 = rhn___0;
          }
          {
#line 702
          tmp___75 = print_succ(rs);
          }
#line 702
          if (! tmp___75) {
#line 703
            goto switch_break;
          }
          {
#line 704
          rv = dump_cache(rs, (unsigned char const   *)nm___0, exact);
          }
#line 704
          if (rv < 0) {
#line 704
            goto _L___2;
          } else
#line 704
          if (! rv) {
#line 704
            if (nm___0) {
#line 704
              tmp___78 = (char const   *)(buf___3);
            } else {
#line 704
              tmp___78 = "";
            }
#line 704
            if (exact) {
#line 704
              tmp___80 = "";
            } else {
#line 704
              if (nm___0) {
#line 704
                tmp___79 = "any entries matching ";
              } else {
#line 704
                tmp___79 = "any entries";
              }
#line 704
              tmp___80 = tmp___79;
            }
            {
#line 704
            tmp___81 = fsprintf(rs, "Could not find %s%s in the cache.\n", tmp___80,
                                tmp___78);
            }
#line 704
            if (tmp___81 < 0) {
              _L___2: /* CIL Label */ 
#line 709
              if (debug_p) {
                {
#line 709
                tmp___76 = __errno_location();
#line 709
                tmp___77 = strerror(*tmp___76);
#line 709
                debug_msg(0, "Error writing to control socket: %s\n", tmp___77);
                }
              }
            }
          }
#line 712
          goto switch_break;
          incomplete_command: 
          {
#line 714
          print_serr(rs, "Malformed or incomplete command.");
          }
#line 715
          goto switch_break;
          bad_arg: 
          {
#line 717
          print_serr(rs, "Bad arg.");
          }
#line 718
          goto switch_break;
          bad_domain_name: 
          {
#line 720
          print_serr(rs, errmsg);
          }
#line 721
          goto switch_break;
          bad_ttl: 
          {
#line 723
          print_serr(rs, "Bad TTL.");
          }
#line 724
          goto switch_break;
          bad_flags: 
          {
#line 726
          print_serr(rs, "Bad cache flags.");
          }
#line 727
          goto switch_break;
          out_of_memory: 
          {
#line 729
          print_serr(rs, "Out of memory.");
          }
#line 730
          goto switch_break;
          switch_default___1: /* CIL Label */ 
          {
#line 732
          print_serr(rs, "Unknown command.");
          }
          switch_break: /* CIL Label */ ;
          }
        } else {
#line 736
          if (debug_p) {
            {
#line 736
            debug_msg(0, "Incorrect magic number in status-socket command code: %02x\n",
                      (int )cmd >> 8);
            }
          }
          {
#line 737
          print_serr(rs, "Command code contains incompatible version number.");
          }
        }
      } else {
#line 741
        if (debug_p) {
          {
#line 741
          debug_msg(0, "short status-socket query\n");
          }
        }
        {
#line 742
        print_serr(rs, "Command code missing or too short.");
        }
      }
      {
#line 744
      close(rs);
#line 745
      usleep_r(100000UL);
      }
    } else {
      {
#line 747
      tmp___85 = __errno_location();
      }
#line 747
      if (*tmp___85 != 4) {
        {
#line 748
        tmp___83 = __errno_location();
#line 748
        tmp___84 = strerror(*tmp___83);
#line 748
        log_message(4, "Failed to accept connection on status socket: %s. Status readback will be impossible",
                    tmp___84);
        }
#line 750
        goto while_break;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  exit_thread: 
  {
#line 755
  stat_pipe = (short)0;
#line 756
  close(stat_sock);
#line 757
  statsock_thrid = main_thrid;
  }
#line 759
  return ((void *)0);
}
}
#line 765 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/status.c"
void init_stat_sock(void) 
{ 
  struct sockaddr_un *sa ;
  unsigned int sa_len ;
  size_t tmp ;
  void *tmp___0 ;
  char *tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  int *tmp___5 ;
  int *tmp___6 ;
  char *tmp___7 ;
  mode_t old_mask ;
  __mode_t tmp___8 ;
  int *tmp___9 ;
  char *tmp___10 ;
  int tmp___11 ;

  {
  {
#line 776
  tmp = strlen((char const   *)global.cache_dir);
#line 776
  sa_len = (unsigned int )(((unsigned long )(& ((struct sockaddr_un *)0)->sun_path) + (sizeof("/pdnsd.status") - 1UL)) + tmp);
#line 778
  tmp___0 = __builtin_alloca((unsigned long )(sa_len + 1U));
#line 778
  sa = (struct sockaddr_un *)tmp___0;
#line 779
  tmp___1 = stpcpy((char */* __restrict  */)(sa->sun_path), (char const   */* __restrict  */)global.cache_dir);
#line 779
  stpcpy((char */* __restrict  */)tmp___1, (char const   */* __restrict  */)"/pdnsd.status");
#line 781
  tmp___4 = unlink((char const   *)(sa->sun_path));
  }
#line 781
  if (tmp___4 != 0) {
    {
#line 781
    tmp___5 = __errno_location();
    }
#line 781
    if (*tmp___5 != 2) {
      {
#line 782
      tmp___2 = __errno_location();
#line 782
      tmp___3 = strerror(*tmp___2);
#line 782
      log_message(4, "Failed to unlink %s: %s.\nStatus readback will be disabled",
                  sa->sun_path, tmp___3);
#line 783
      stat_pipe = (short)0;
      }
#line 784
      return;
    }
  }
  {
#line 786
  stat_sock = socket(1, 1, 0);
  }
#line 786
  if (stat_sock == -1) {
    {
#line 787
    tmp___6 = __errno_location();
#line 787
    tmp___7 = strerror(*tmp___6);
#line 787
    log_message(4, "Failed to open socket: %s. Status readback will be impossible",
                tmp___7);
#line 788
    stat_pipe = (short)0;
    }
#line 789
    return;
  }
  {
#line 791
  sa->sun_family = (sa_family_t )1;
#line 797
  tmp___8 = umask((__mode_t )(((448 | (448 >> 3)) | ((448 >> 3) >> 3)) & ~ global.ctl_perms));
#line 797
  old_mask = tmp___8;
#line 798
  tmp___11 = bind(stat_sock, (struct sockaddr  const  */* __restrict  */)((struct sockaddr *)sa),
                  sa_len);
  }
#line 798
  if (tmp___11 == -1) {
    {
#line 799
    tmp___9 = __errno_location();
#line 799
    tmp___10 = strerror(*tmp___9);
#line 799
    log_message(4, "Error: could not bind socket: %s.\nStatus readback will be impossible",
                tmp___10);
#line 800
    close(stat_sock);
#line 801
    stat_pipe = (short)0;
    }
  }
  {
#line 803
  umask(old_mask);
  }
#line 806
  if (stat_pipe) {
    {
#line 806
    sock_path = strdup((char const   *)(sa->sun_path));
    }
  }
#line 807
  return;
}
}
#line 812 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/status.c"
int start_stat_sock(void) 
{ 
  pthread_t st ;
  int rv ;
  int tmp ;

  {
  {
#line 816
  tmp = pthread_create((pthread_t */* __restrict  */)(& st), (pthread_attr_t const   */* __restrict  */)(& attr_detached),
                       & status_thread, (void */* __restrict  */)((void *)0));
#line 816
  rv = tmp;
  }
#line 817
  if (rv) {
    {
#line 818
    log_message(4, "Failed to start status thread. The status socket will be unuseable");
    }
  } else {
#line 820
    statsock_thrid = st;
#line 821
    if (2 <= (int )global.verbosity) {
      {
#line 821
      log_message(6, "Status thread started.");
      }
    }
  }
#line 823
  return (rv);
}
}
#line 232 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/helpers.h"
__inline static int ( __attribute__((__always_inline__)) strncp)(char *dst , char const   *src ,
                                                                 size_t dstsz ) ;
#line 86 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/netdev.c"
static unsigned long volatile   socketopen_errs___3  =    (unsigned long volatile   )0;
#line 96 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/netdev.c"
static unsigned long volatile   isdn_errs___3  =    (unsigned long volatile   )0;
#line 709 "/usr/include/stdio.h"
extern size_t fread(void * __restrict  __ptr , size_t __size , size_t __n , FILE * __restrict  __stream ) ;
#line 830
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) ferror)(FILE *__stream ) ;
#line 773 "/usr/include/pthread.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_mutex_lock)(pthread_mutex_t *__mutex ) ;
#line 988
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_cond_signal)(pthread_cond_t *__cond ) ;
#line 992
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_cond_broadcast)(pthread_cond_t *__cond ) ;
#line 1000
extern int ( __attribute__((__nonnull__(1,2))) pthread_cond_wait)(pthread_cond_t * __restrict  __cond ,
                                                                  pthread_mutex_t * __restrict  __mutex ) ;
#line 1011
extern int ( __attribute__((__nonnull__(1,2,3))) pthread_cond_timedwait)(pthread_cond_t * __restrict  __cond ,
                                                                         pthread_mutex_t * __restrict  __mutex ,
                                                                         struct timespec  const  * __restrict  __abstime ) ;
#line 129 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcpy)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 167 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/rr_types.h"
unsigned short const   rrmuiterlist[8] ;
#line 480
struct rr_infos  const  rr_info[47] ;
#line 534
char const   *loc2str(void const   *binary , char *ascii , size_t asclen ) ;
#line 136 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/cache.h"
short volatile   use_cache_lock ;
#line 163
void destroy_cache(void) ;
#line 164
void read_disk_cache(void) ;
#line 165
void write_disk_cache(void) ;
#line 206
void del_cent(dns_cent_t *cent ) ;
#line 212
dns_cent_t *copy_cent(dns_cent_t *cent ) ;
#line 219
__inline static rr_set_t *( __attribute__((__always_inline__)) getrrset)(dns_cent_t *cent ,
                                                                         int type ) ;
#line 249
__inline static rr_set_t *( __attribute__((__always_inline__)) getrrset_eff)(dns_cent_t *cent ,
                                                                             int type ) ;
#line 272
__inline static int ( __attribute__((__always_inline__)) have_rr)(dns_cent_t *cent ,
                                                                  int type ) ;
#line 68 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/hash.h"
dns_cent_t *dns_lookup(unsigned char const   *key , dns_hash_loc_t *loc ) ;
#line 69
int add_dns_hash(dns_cent_t *data , dns_hash_loc_t *loc ) ;
#line 70
dns_cent_t *del_dns_hash_ent(dns_hash_loc_t *loc ) ;
#line 71
dns_cent_t *del_dns_hash(unsigned char const   *key ) ;
#line 72
void free_dns_hash_bucket(int i ) ;
#line 73
void free_dns_hash_selected(int i , slist_array sla ) ;
#line 74
void free_dns_hash(void) ;
#line 76
dns_cent_t *fetch_first(dns_hash_pos_t *pos ) ;
#line 77
dns_cent_t *fetch_next(dns_hash_pos_t *pos ) ;
#line 60 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/helpers.h"
__inline static unsigned int ( __attribute__((__always_inline__)) rhnlen)(unsigned char const   *rhn ) ;
#line 72
__inline static unsigned char const   *( __attribute__((__always_inline__)) skipsegs)(unsigned char const   *nm ,
                                                                                      unsigned int k ) ;
#line 86
__inline static unsigned char *( __attribute__((__always_inline__)) skiprhn)(unsigned char *rhn ) ;
#line 98
__inline static unsigned int ( __attribute__((__always_inline__)) rhnsegcnt)(unsigned char const   *rhn ) ;
#line 111 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/thread.h"
__inline static int ( __attribute__((__always_inline__)) usleep_r)(unsigned long useconds ) ;
#line 46 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/cache.c"
static char const   cachverid[4]  = {      (char const   )'p',      (char const   )'d',      (char const   )'1',      (char const   )'3'};
#line 154 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/cache.c"
static rr_lent_t *rrset_l  =    (rr_lent_t *)((void *)0);
#line 155 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/cache.c"
static rr_lent_t *rrset_l_tail  =    (rr_lent_t *)((void *)0);
#line 161 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/cache.c"
static long volatile   cache_size  =    (long volatile   )0;
#line 162 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/cache.c"
static long volatile   ent_num  =    (long volatile   )0;
#line 164 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/cache.c"
static int volatile   cache_w_lock  =    (int volatile   )0;
#line 165 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/cache.c"
static int volatile   cache_r_lock  =    (int volatile   )0;
#line 167 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/cache.c"
pthread_mutex_t lock_mutex  =    {{0, 0U, 0, 0U, 0, (short)0, (short)0, {(struct __pthread_internal_list *)0, (struct __pthread_internal_list *)0}}};
#line 177 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/cache.c"
pthread_cond_t rw_cond  =    {{0, 0U, 0ULL, 0ULL, 0ULL, (void *)0, 0U, 0U}};
#line 178 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/cache.c"
pthread_cond_t r_cond  =    {{0, 0U, 0ULL, 0ULL, 0ULL, (void *)0, 0U, 0U}};
#line 181 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/cache.c"
static int volatile   r_pend  =    (int volatile   )0;
#line 182 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/cache.c"
static int volatile   rw_pend  =    (int volatile   )0;
#line 183 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/cache.c"
static int volatile   r_susp  =    (int volatile   )0;
#line 193 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/cache.c"
short volatile   use_cache_lock  =    (short volatile   )0;
#line 199 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/cache.c"
static short insert_sort  =    (short)1;
#line 218
static void purge_cache(long sz , int lazy ) ;
#line 219
static void del_cache_ent(dns_cent_t *cent , dns_hash_loc_t *loc ) ;
#line 220
static void remove_rrl(rr_lent_t *le ) ;
#line 235 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/cache.c"
static void lock_cache_r(void) 
{ 
  int volatile   tmp ;

  {
#line 237
  if (! use_cache_lock) {
#line 238
    return;
  }
  {
#line 239
  pthread_mutex_lock(& lock_mutex);
#line 240
  r_pend += (int volatile   )1;
  }
  {
#line 241
  while (1) {
    while_continue: /* CIL Label */ ;
#line 241
    if (rw_pend > r_pend / (int volatile   )2 + (int volatile   )2) {
#line 241
      r_susp = (int volatile   )1;
#line 241
      tmp = r_susp;
    } else {
#line 241
      tmp = r_susp;
    }
#line 241
    if (! tmp) {
#line 241
      if (! cache_w_lock) {
#line 241
        goto while_break;
      }
    }
    {
#line 243
    pthread_cond_wait((pthread_cond_t */* __restrict  */)(& r_cond), (pthread_mutex_t */* __restrict  */)(& lock_mutex));
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 245
  cache_r_lock += (int volatile   )1;
#line 246
  r_pend -= (int volatile   )1;
#line 247
  pthread_mutex_unlock(& lock_mutex);
  }
#line 248
  return;
}
}
#line 250 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/cache.c"
static void unlock_cache_r(void) 
{ 


  {
#line 252
  if (! use_cache_lock) {
#line 253
    return;
  }
  {
#line 254
  pthread_mutex_lock(& lock_mutex);
  }
#line 255
  if (cache_r_lock > (int volatile   )0) {
#line 256
    cache_r_lock -= (int volatile   )1;
  }
#line 258
  if (! cache_r_lock) {
    {
#line 259
    pthread_cond_signal(& rw_cond);
    }
  }
  {
#line 260
  pthread_mutex_unlock(& lock_mutex);
  }
#line 261
  return;
}
}
#line 269 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/cache.c"
static void lock_cache_rw(void) 
{ 


  {
#line 271
  if (! use_cache_lock) {
#line 272
    return;
  }
  {
#line 273
  pthread_mutex_lock(& lock_mutex);
#line 274
  rw_pend += (int volatile   )1;
  }
  {
#line 275
  while (1) {
    while_continue: /* CIL Label */ ;
#line 275
    if (! cache_w_lock) {
#line 275
      if (! cache_r_lock) {
#line 275
        goto while_break;
      }
    }
    {
#line 277
    pthread_cond_wait((pthread_cond_t */* __restrict  */)(& rw_cond), (pthread_mutex_t */* __restrict  */)(& lock_mutex));
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 279
  cache_w_lock = (int volatile   )1;
#line 280
  rw_pend -= (int volatile   )1;
#line 281
  pthread_mutex_unlock(& lock_mutex);
  }
#line 282
  return;
}
}
#line 285 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/cache.c"
static int timedlock_cache_rw(int tm ) 
{ 
  int retval ;
  struct timeval now ;
  struct timespec timeout ;
  int tmp ;

  {
#line 287
  retval = 0;
#line 291
  if (! use_cache_lock) {
#line 292
    return (0);
  }
  {
#line 293
  pthread_mutex_lock(& lock_mutex);
#line 294
  gettimeofday((struct timeval */* __restrict  */)(& now), (__timezone_ptr_t )((void *)0));
#line 295
  timeout.tv_sec = now.tv_sec + (__time_t )tm;
#line 296
  timeout.tv_nsec = now.tv_usec * 1000L;
#line 297
  rw_pend += (int volatile   )1;
  }
  {
#line 298
  while (1) {
    while_continue: /* CIL Label */ ;
#line 298
    if (! cache_w_lock) {
#line 298
      if (! cache_r_lock) {
#line 298
        goto while_break;
      }
    }
    {
#line 300
    tmp = pthread_cond_timedwait((pthread_cond_t */* __restrict  */)(& rw_cond), (pthread_mutex_t */* __restrict  */)(& lock_mutex),
                                 (struct timespec  const  */* __restrict  */)(& timeout));
    }
#line 300
    if (tmp == 110) {
#line 301
      goto cleanup_return;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 303
  cache_w_lock = (int volatile   )1;
#line 304
  retval = 1;
  cleanup_return: 
  {
#line 306
  rw_pend -= (int volatile   )1;
#line 307
  pthread_mutex_unlock(& lock_mutex);
  }
#line 308
  return (retval);
}
}
#line 311 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/cache.c"
static void unlock_cache_rw(void) 
{ 


  {
#line 313
  if (! use_cache_lock) {
#line 314
    return;
  }
  {
#line 315
  pthread_mutex_lock(& lock_mutex);
#line 316
  cache_w_lock = (int volatile   )0;
#line 318
  r_susp = (int volatile   )0;
  }
#line 320
  if (r_pend == (int volatile   )0) {
    {
#line 321
    pthread_cond_signal(& rw_cond);
    }
  } else
#line 320
  if (rw_pend > r_pend / (int volatile   )2 + (int volatile   )2) {
    {
#line 321
    pthread_cond_signal(& rw_cond);
    }
  } else {
    {
#line 323
    pthread_cond_broadcast(& r_cond);
    }
  }
  {
#line 324
  pthread_mutex_unlock(& lock_mutex);
  }
#line 325
  return;
}
}
#line 336 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/cache.c"
static void yield_lock_cache_rw(void) 
{ 


  {
#line 338
  if (! use_cache_lock) {
#line 339
    return;
  } else
#line 338
  if (! r_pend) {
#line 338
    if (! rw_pend) {
#line 339
      return;
    }
  }
  {
#line 342
  pthread_mutex_lock(& lock_mutex);
#line 343
  cache_w_lock = (int volatile   )0;
#line 345
  r_susp = (int volatile   )0;
  }
#line 347
  if (r_pend == (int volatile   )0) {
    {
#line 348
    pthread_cond_signal(& rw_cond);
    }
  } else
#line 347
  if (rw_pend > r_pend / (int volatile   )2 + (int volatile   )2) {
    {
#line 348
    pthread_cond_signal(& rw_cond);
    }
  } else {
    {
#line 350
    pthread_cond_broadcast(& r_cond);
    }
  }
  {
#line 351
  pthread_mutex_unlock(& lock_mutex);
#line 353
  usleep_r(1000UL);
#line 356
  pthread_mutex_lock(& lock_mutex);
#line 357
  rw_pend += (int volatile   )1;
  }
  {
#line 358
  while (1) {
    while_continue: /* CIL Label */ ;
#line 358
    if (! cache_w_lock) {
#line 358
      if (! cache_r_lock) {
#line 358
        goto while_break;
      }
    }
    {
#line 360
    pthread_cond_wait((pthread_cond_t */* __restrict  */)(& rw_cond), (pthread_mutex_t */* __restrict  */)(& lock_mutex));
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 362
  cache_w_lock = (int volatile   )1;
#line 363
  rw_pend -= (int volatile   )1;
#line 364
  pthread_mutex_unlock(& lock_mutex);
  }
#line 365
  return;
}
}
#line 371 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/cache.c"
static int softlock_cache_r(void) 
{ 
  int lk ;
  int tr ;
  int tmp ;

  {
#line 373
  if (! use_cache_lock) {
#line 374
    return (0);
  }
#line 376
  lk = 0;
#line 376
  tr = 0;
  {
#line 378
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 379
    tmp = softlock_mutex(& lock_mutex);
    }
#line 379
    if (! tmp) {
#line 380
      return (0);
    }
#line 381
    if (! cache_w_lock) {
#line 382
      lk = 1;
#line 383
      cache_r_lock += (int volatile   )1;
    }
    {
#line 385
    pthread_mutex_unlock(& lock_mutex);
    }
#line 386
    if (lk) {
#line 386
      goto while_break;
    }
#line 387
    tr ++;
#line 387
    if (tr >= 1000) {
#line 388
      return (0);
    }
    {
#line 389
    usleep_r(1000UL);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 392
  return (1);
}
}
#line 396 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/cache.c"
static int softunlock_cache_r(void) 
{ 
  int tmp ;

  {
#line 398
  if (! use_cache_lock) {
#line 399
    return (0);
  }
  {
#line 400
  tmp = softlock_mutex(& lock_mutex);
  }
#line 400
  if (! tmp) {
#line 401
    return (0);
  }
#line 402
  if (cache_r_lock > (int volatile   )0) {
#line 403
    cache_r_lock -= (int volatile   )1;
  }
  {
#line 404
  pthread_mutex_unlock(& lock_mutex);
  }
#line 405
  return (1);
}
}
#line 408 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/cache.c"
static int softlock_cache_rw(void) 
{ 
  int lk ;
  int tr ;
  int tmp ;

  {
#line 410
  if (! use_cache_lock) {
#line 411
    return (0);
  }
#line 413
  lk = 0;
#line 413
  tr = 0;
  {
#line 415
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 416
    tmp = softlock_mutex(& lock_mutex);
    }
#line 416
    if (! tmp) {
#line 417
      return (0);
    }
#line 418
    if (! cache_w_lock) {
#line 418
      if (! cache_r_lock) {
#line 419
        lk = 1;
#line 420
        cache_w_lock = (int volatile   )1;
      }
    }
    {
#line 422
    pthread_mutex_unlock(& lock_mutex);
    }
#line 423
    if (lk) {
#line 423
      goto while_break;
    }
#line 424
    tr ++;
#line 424
    if (tr >= 1000) {
#line 425
      return (0);
    }
    {
#line 426
    usleep_r(1000UL);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 429
  return (1);
}
}
#line 432 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/cache.c"
static int softunlock_cache_rw(void) 
{ 
  int tmp ;

  {
#line 434
  if (! use_cache_lock) {
#line 435
    return (0);
  }
  {
#line 436
  tmp = softlock_mutex(& lock_mutex);
  }
#line 436
  if (! tmp) {
#line 437
    return (0);
  }
  {
#line 438
  cache_w_lock = (int volatile   )0;
#line 439
  pthread_mutex_unlock(& lock_mutex);
  }
#line 440
  return (1);
}
}
#line 486 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/cache.c"
int empty_cache(slist_array sla ) 
{ 
  int i ;
  int tmp ;

  {
  {
#line 491
  tmp = timedlock_cache_rw(60);
  }
#line 491
  if (! tmp) {
#line 492
    return (0);
  }
#line 494
  i = 0;
  {
#line 494
  while (1) {
    while_continue: /* CIL Label */ ;
#line 495
    if (sla) {
      {
#line 496
      free_dns_hash_selected(i, sla);
      }
    } else {
      {
#line 498
      free_dns_hash_bucket(i);
      }
    }
#line 499
    i ++;
#line 499
    if (i >= 1 << 10) {
#line 500
      goto while_break;
    }
    {
#line 502
    yield_lock_cache_rw();
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 505
  unlock_cache_rw();
  }
#line 506
  return (1);
}
}
#line 510 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/cache.c"
void destroy_cache(void) 
{ 
  int tmp ;

  {
  {
#line 513
  tmp = softlock_cache_rw();
  }
#line 513
  if (! tmp) {
    {
#line 514
    log_message(3, "Lock failed; could not destroy cache on exit.");
    }
#line 515
    return;
  }
  {
#line 517
  free_dns_hash();
  }
#line 519
  if (ent_num) {
#line 519
    goto _L;
  } else
#line 519
  if (cache_size) {
    _L: /* CIL Label */ 
#line 520
    if (debug_p) {
      {
#line 520
      debug_msg(0, "After destroying cache, %ld entries (%ld bytes) remaining.\n",
                ent_num, cache_size);
      }
    }
  }
#line 532
  return;
}
}
#line 558 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/cache.c"
int init_cent(dns_cent_t *cent , unsigned char const   *qname , time_t ttl , time_t ts ,
              unsigned int flags ) 
{ 
  int i ;
  size_t namesz ;
  unsigned int tmp ;
  void *tmp___0 ;

  {
  {
#line 561
  tmp = rhnlen(qname);
#line 561
  namesz = (size_t )tmp;
#line 563
  tmp___0 = malloc(namesz);
#line 563
  cent->qname = (unsigned char *)tmp___0;
  }
#line 564
  if ((unsigned long )cent->qname == (unsigned long )((void *)0)) {
#line 565
    return (0);
  }
  {
#line 566
  memcpy((void */* __restrict  */)cent->qname, (void const   */* __restrict  */)qname,
         namesz);
#line 567
  cent->cs = sizeof(dns_cent_t ) + namesz;
#line 568
  cent->num_rrs = (unsigned short)0;
#line 569
  cent->flags = (unsigned short )flags;
  }
#line 570
  if (flags & 1U) {
#line 571
    cent->__annonCompField2.neg.lent = (struct rr_lent_s *)((void *)0);
#line 572
    cent->__annonCompField2.neg.ttl = ttl;
#line 573
    cent->__annonCompField2.neg.ts = ts;
  } else {
#line 576
    i = 0;
    {
#line 576
    while (1) {
      while_continue: /* CIL Label */ ;
#line 576
      if (! (i < 8)) {
#line 576
        goto while_break;
      }
#line 577
      cent->__annonCompField2.rr.rrmu[i] = (rr_set_t *)((void *)0);
#line 576
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 578
    cent->__annonCompField2.rr.rrext = (rr_set_t **)((void *)0);
  }
#line 580
  cent->c_ns = (unsigned char)255;
#line 581
  cent->c_soa = (unsigned char)255;
#line 582
  return (1);
}
}
#line 588 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/cache.c"
static rr_bucket_t *create_rr(unsigned int dlen , void *data ) 
{ 
  rr_bucket_t *rrb ;
  void *tmp ;

  {
  {
#line 591
  tmp = malloc(sizeof(rr_bucket_t ) + (unsigned long )dlen);
#line 591
  rrb = (rr_bucket_t *)tmp;
  }
#line 592
  if ((unsigned long )rrb == (unsigned long )((void *)0)) {
#line 593
    return ((rr_bucket_t *)((void *)0));
  }
  {
#line 594
  rrb->next = (struct rr_b_s *)((void *)0);
#line 596
  rrb->rdlen = dlen;
#line 597
  memcpy((void */* __restrict  */)(rrb->data), (void const   */* __restrict  */)data,
         (size_t )dlen);
  }
#line 598
  return (rrb);
}
}
#line 605 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/cache.c"
static int add_cent_rrset_by_index(dns_cent_t *cent , unsigned int idx , time_t ttl ,
                                   time_t ts , unsigned int flags ) 
{ 
  rr_set_t **rrext ;
  rr_set_t **rrsetpa ;
  rr_set_t *rrset ;
  int i ;
  int i___0 ;
  void *tmp ;
  void *tmp___0 ;

  {
#line 610
  if ((int )cent->flags & 1) {
#line 613
    if (cent->__annonCompField2.neg.lent) {
      {
#line 614
      remove_rrl(cent->__annonCompField2.neg.lent);
      }
    }
#line 615
    cent->flags = (unsigned short )((int )cent->flags & -2);
#line 616
    i = 0;
    {
#line 616
    while (1) {
      while_continue: /* CIL Label */ ;
#line 616
      if (! (i < 8)) {
#line 616
        goto while_break;
      }
#line 617
      cent->__annonCompField2.rr.rrmu[i] = (rr_set_t *)((void *)0);
#line 616
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 618
    cent->__annonCompField2.rr.rrext = (rr_set_t **)((void *)0);
  }
#line 621
  if (idx < 8U) {
#line 622
    rrsetpa = & cent->__annonCompField2.rr.rrmu[idx];
  } else {
#line 624
    idx -= 8U;
#line 625
    if (! (idx < 39U)) {
      {
#line 625
      log_message(3, "%s:%d: %s", "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/cache.c",
                  625, "add_cent_rrset_by_index: rr-set index out of range");
#line 625
      pdnsd_exit();
      }
    }
#line 626
    rrext = cent->__annonCompField2.rr.rrext;
#line 627
    if (! rrext) {
      {
#line 629
      tmp = malloc(sizeof(rr_set_t *) * 39UL);
#line 629
      rrext = (rr_set_t **)tmp;
#line 629
      cent->__annonCompField2.rr.rrext = rrext;
      }
#line 630
      if (! rrext) {
#line 631
        return (0);
      }
#line 632
      i___0 = 0;
      {
#line 632
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 632
        if (! (i___0 < 39)) {
#line 632
          goto while_break___0;
        }
#line 633
        *(rrext + i___0) = (rr_set_t *)((void *)0);
#line 632
        i___0 ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 634
      cent->cs += sizeof(rr_set_t *) * 39UL;
    }
#line 636
    rrsetpa = rrext + idx;
  }
  {
#line 642
  tmp___0 = malloc(sizeof(rr_set_t ));
#line 642
  rrset = (rr_set_t *)tmp___0;
#line 642
  *rrsetpa = rrset;
  }
#line 643
  if (! rrset) {
#line 644
    return (0);
  }
#line 645
  rrset->lent = (struct rr_lent_s *)((void *)0);
#line 646
  rrset->ttl = ttl;
#line 647
  rrset->ts = ts;
#line 648
  rrset->flags = (unsigned short )flags;
#line 649
  rrset->rrs = (rr_bucket_t *)((void *)0);
#line 650
  cent->cs += sizeof(rr_set_t );
#line 651
  cent->num_rrs = (unsigned short )((int )cent->num_rrs + 1);
#line 652
  return (1);
}
}
#line 655 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/cache.c"
int add_cent_rrset_by_type(dns_cent_t *cent , int type , time_t ttl , time_t ts ,
                           unsigned int flags ) 
{ 
  int tpi ;
  int tmp ;

  {
#line 657
  tpi = type - 1;
#line 659
  if (tpi >= 0) {
#line 659
    if (! (tpi < 51)) {
      {
#line 659
      log_message(3, "%s:%d: %s", "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/cache.c",
                  659, "add_cent_rrset_by_type: rr type value out of range");
#line 659
      pdnsd_exit();
      }
    }
  } else {
    {
#line 659
    log_message(3, "%s:%d: %s", "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/cache.c",
                659, "add_cent_rrset_by_type: rr type value out of range");
#line 659
    pdnsd_exit();
    }
  }
  {
#line 660
  tmp = add_cent_rrset_by_index(cent, (unsigned int )rrlkuptab[tpi], ttl, ts, flags);
  }
#line 660
  return (tmp);
}
}
#line 668 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/cache.c"
static int add_cent_rr_int(dns_cent_t *cent , unsigned int idx , time_t ttl , time_t ts ,
                           unsigned int flags , unsigned int dlen , void *data , rr_bucket_t **rtail ) 
{ 
  rr_bucket_t *rr ;
  rr_set_t *rrset ;
  rr_set_t *tmp ;
  rr_set_t *tmp___0 ;
  int tmp___1 ;
  char cflagstr[28] ;
  char *tmp___2 ;

  {
  {
#line 674
  rr = create_rr(dlen, data);
  }
#line 674
  if (! rr) {
#line 675
    return (0);
  }
#line 676
  if (rtail) {
#line 676
    if (*rtail) {
#line 689
      rr->next = (*rtail)->next;
#line 690
      (*rtail)->next = rr;
    } else {
#line 676
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
#line 677
    if ((int )cent->flags & 1) {
#line 677
      rrset = (rr_set_t *)((void *)0);
    } else {
#line 677
      if (idx < 8U) {
#line 677
        tmp___0 = cent->__annonCompField2.rr.rrmu[idx];
      } else {
#line 677
        if (cent->__annonCompField2.rr.rrext) {
#line 677
          tmp = *(cent->__annonCompField2.rr.rrext + (idx - 8U));
        } else {
#line 677
          tmp = (rr_set_t *)((void *)0);
        }
#line 677
        tmp___0 = tmp;
      }
#line 677
      rrset = tmp___0;
    }
#line 678
    if (! rrset) {
      {
#line 679
      tmp___1 = add_cent_rrset_by_index(cent, idx, ttl, ts, flags);
      }
#line 679
      if (! tmp___1) {
#line 680
        goto cleanup_return;
      }
#line 681
      if (idx < 8U) {
#line 681
        rrset = cent->__annonCompField2.rr.rrmu[idx];
      } else {
#line 681
        rrset = *(cent->__annonCompField2.rr.rrext + (idx - 8U));
      }
    }
#line 684
    rr->next = rrset->rrs;
#line 685
    rrset->rrs = rr;
  }
#line 692
  if (rtail) {
#line 692
    *rtail = rr;
  }
#line 693
  cent->cs += sizeof(rr_bucket_t ) + (unsigned long )rr->rdlen;
#line 695
  if (debug_p) {
#line 696
    if (idx < 8U) {
#line 696
      rrset = cent->__annonCompField2.rr.rrmu[idx];
    } else {
#line 696
      rrset = *(cent->__annonCompField2.rr.rrext + (idx - 8U));
    }
#line 697
    if ((int )rrset->flags & 1) {
#line 699
      if (debug_p) {
        {
#line 699
        tmp___2 = flags2str((unsigned int )rrset->flags, cflagstr, 7, cflgnames);
#line 699
        debug_msg(0, "Tried to add rr to a rrset with CF_NEGATIVE set! flags=%s\n",
                  tmp___2);
        }
      }
    }
  }
#line 703
  return (1);
  cleanup_return: 
  {
#line 707
  free((void *)rr);
  }
#line 708
  return (0);
}
}
#line 718 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/cache.c"
int add_cent_rr(dns_cent_t *cent , int type , time_t ttl , time_t ts , unsigned int flags ,
                unsigned int dlen , void *data ) 
{ 
  int tpi ;
  unsigned int idx ;
  rr_set_t *rrset ;
  rr_bucket_t *rtail ;
  rr_bucket_t *rrb ;
  rr_set_t *tmp ;
  rr_set_t *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 726
  if ((int )cent->flags & 2) {
#line 726
    if (! (flags & 2U)) {
#line 727
      return (1);
    }
  }
#line 729
  tpi = type - 1;
#line 730
  if (tpi >= 0) {
#line 730
    if (! (tpi < 51)) {
      {
#line 730
      log_message(3, "%s:%d: %s", "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/cache.c",
                  730, "add_cent_rr: rr type value out of range");
#line 730
      pdnsd_exit();
      }
    }
  } else {
    {
#line 730
    log_message(3, "%s:%d: %s", "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/cache.c",
                730, "add_cent_rr: rr type value out of range");
#line 730
    pdnsd_exit();
    }
  }
#line 731
  idx = (unsigned int )rrlkuptab[tpi];
#line 732
  if (! (idx < 47U)) {
    {
#line 732
    log_message(3, "%s:%d: %s", "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/cache.c",
                732, "add_cent_rr: illegal rr type value for caching");
#line 732
    pdnsd_exit();
    }
  }
#line 733
  if ((int )cent->flags & 1) {
#line 733
    rrset = (rr_set_t *)((void *)0);
  } else {
#line 733
    if (idx < 8U) {
#line 733
      tmp___0 = cent->__annonCompField2.rr.rrmu[idx];
    } else {
#line 733
      if (cent->__annonCompField2.rr.rrext) {
#line 733
        tmp = *(cent->__annonCompField2.rr.rrext + (idx - 8U));
      } else {
#line 733
        tmp = (rr_set_t *)((void *)0);
      }
#line 733
      tmp___0 = tmp;
    }
#line 733
    rrset = tmp___0;
  }
#line 734
  rtail = (rr_bucket_t *)((void *)0);
#line 736
  if (rrset) {
#line 737
    if (ttl < rrset->ttl) {
#line 740
      rrset->ttl = ttl;
    }
#line 743
    rrb = rrset->rrs;
    {
#line 744
    while (1) {
      while_continue: /* CIL Label */ ;
#line 744
      if (! rrb) {
#line 744
        goto while_break;
      }
#line 745
      if (rrb->rdlen == dlen) {
        {
#line 745
        tmp___1 = memcmp((void const   *)(rrb->data), (void const   *)data, (size_t )dlen);
        }
#line 745
        if (tmp___1 == 0) {
#line 746
          return (1);
        }
      }
#line 747
      rtail = rrb;
#line 748
      rrb = rrb->next;
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 751
  tmp___2 = add_cent_rr_int(cent, idx, ttl, ts, flags, dlen, data, & rtail);
  }
#line 751
  return (tmp___2);
}
}
#line 755 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/cache.c"
int del_rrset(rr_set_t *rrs ) 
{ 
  int rv ;
  rr_bucket_t *rrb ;
  rr_bucket_t *rrn ;

  {
#line 757
  rv = (int )sizeof(rr_set_t );
#line 760
  if (rrs->lent) {
    {
#line 760
    remove_rrl(rrs->lent);
    }
  }
#line 761
  rrb = rrs->rrs;
  {
#line 762
  while (1) {
    while_continue: /* CIL Label */ ;
#line 762
    if (! rrb) {
#line 762
      goto while_break;
    }
    {
#line 763
    rv = (int )((unsigned long )rv + (sizeof(rr_bucket_t ) + (unsigned long )rrb->rdlen));
#line 764
    rrn = rrb->next;
#line 766
    free((void *)rrb);
#line 767
    rrb = rrn;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 769
  free((void *)rrs);
  }
#line 770
  return (rv);
}
}
#line 776 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/cache.c"
static int del_cent_rrset_by_index(dns_cent_t *cent , int i ) 
{ 
  int rv ;
  rr_set_t **rrspa ;
  rr_set_t **tmp ;
  rr_set_t **tmp___0 ;
  rr_set_t **tmp___1 ;
  rr_set_t *rrs ;

  {
#line 778
  rv = 0;
#line 779
  if ((int )cent->flags & 1) {
#line 779
    tmp___1 = (rr_set_t **)((void *)0);
  } else {
#line 779
    if (i < 8) {
#line 779
      tmp___0 = & cent->__annonCompField2.rr.rrmu[i];
    } else {
#line 779
      if (cent->__annonCompField2.rr.rrext) {
#line 779
        tmp = cent->__annonCompField2.rr.rrext + (i - 8);
      } else {
#line 779
        tmp = (rr_set_t **)((void *)0);
      }
#line 779
      tmp___0 = tmp;
    }
#line 779
    tmp___1 = tmp___0;
  }
#line 779
  rrspa = tmp___1;
#line 781
  if (rrspa) {
#line 782
    rrs = *rrspa;
#line 783
    if (rrs) {
      {
#line 784
      rv = del_rrset(rrs);
#line 785
      *rrspa = (rr_set_t *)((void *)0);
#line 786
      cent->num_rrs = (unsigned short )((int )cent->num_rrs - 1);
#line 787
      cent->cs -= (size_t )rv;
#line 788
      cent->flags = (unsigned short )((int )cent->flags & -5);
      }
    }
  }
#line 791
  return (rv);
}
}
#line 813 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/cache.c"
void free_cent(dns_cent_t *cent ) 
{ 
  int i ;
  rr_set_t *rrs ;
  rr_set_t **rrext ;
  rr_set_t *rrs___0 ;

  {
  {
#line 815
  free((void *)cent->qname);
  }
#line 816
  if ((int )cent->flags & 1) {
#line 817
    if (cent->__annonCompField2.neg.lent) {
      {
#line 818
      remove_rrl(cent->__annonCompField2.neg.lent);
      }
    }
  } else {
#line 822
    i = 0;
    {
#line 822
    while (1) {
      while_continue: /* CIL Label */ ;
#line 822
      if (! (i < 8)) {
#line 822
        goto while_break;
      }
#line 823
      rrs = cent->__annonCompField2.rr.rrmu[i];
#line 824
      if (rrs) {
        {
#line 824
        del_rrset(rrs);
        }
      }
#line 822
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 827
    rrext = cent->__annonCompField2.rr.rrext;
#line 828
    if (rrext) {
#line 829
      i = 0;
      {
#line 829
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 829
        if (! (i < 39)) {
#line 829
          goto while_break___0;
        }
#line 830
        rrs___0 = *(rrext + i);
#line 831
        if (rrs___0) {
          {
#line 831
          del_rrset(rrs___0);
          }
        }
#line 829
        i ++;
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 833
      free((void *)rrext);
      }
    }
  }
#line 837
  return;
}
}
#line 840 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/cache.c"
void free_cent0(void *ptr ) 
{ 


  {
  {
#line 842
  free_cent((dns_cent_t *)ptr);
  }
#line 843
  return;
}
}
#line 846 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/cache.c"
void negate_cent(dns_cent_t *cent , time_t ttl , time_t ts ) 
{ 
  int i ;
  rr_set_t *rrs ;
  int tmp ;
  rr_set_t **rrext ;
  rr_set_t *rrs___0 ;
  int tmp___0 ;

  {
#line 850
  if (! ((int )cent->flags & 1)) {
#line 851
    i = 0;
    {
#line 851
    while (1) {
      while_continue: /* CIL Label */ ;
#line 851
      if (! (i < 8)) {
#line 851
        goto while_break;
      }
#line 852
      rrs = cent->__annonCompField2.rr.rrmu[i];
#line 853
      if (rrs) {
        {
#line 854
        tmp = del_rrset(rrs);
#line 854
        cent->cs -= (size_t )tmp;
        }
      }
#line 851
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 859
    rrext = cent->__annonCompField2.rr.rrext;
#line 860
    if (rrext) {
#line 861
      i = 0;
      {
#line 861
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 861
        if (! (i < 39)) {
#line 861
          goto while_break___0;
        }
#line 862
        rrs___0 = *(rrext + i);
#line 863
        if (rrs___0) {
          {
#line 864
          tmp___0 = del_rrset(rrs___0);
#line 864
          cent->cs -= (size_t )tmp___0;
          }
        }
#line 861
        i ++;
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 866
      free((void *)rrext);
#line 868
      cent->cs -= sizeof(rr_set_t *) * 39UL;
      }
    }
#line 871
    cent->num_rrs = (unsigned short)0;
#line 872
    cent->flags = (unsigned short )((int )cent->flags | 1);
#line 873
    cent->__annonCompField2.neg.lent = (struct rr_lent_s *)((void *)0);
  }
#line 876
  cent->__annonCompField2.neg.ttl = ttl;
#line 877
  cent->__annonCompField2.neg.ts = ts;
#line 878
  return;
}
}
#line 880 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/cache.c"
__inline static time_t get_rrlent_ts(rr_lent_t *le ) 
{ 
  time_t tmp ;

  {
#line 882
  if (le->rrset) {
#line 882
    tmp = (le->rrset)->ts;
  } else {
#line 882
    tmp = (le->cent)->__annonCompField2.neg.ts;
  }
#line 882
  return (tmp);
}
}
#line 889 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/cache.c"
static int insert_rrl(rr_set_t *rrs , dns_cent_t *cent , int idx ) 
{ 
  time_t ts ;
  rr_lent_t *le ;
  rr_lent_t *ne ;
  void *tmp ;
  time_t tmp___0 ;

  {
#line 895
  if (rrs) {
#line 895
    if ((int )rrs->flags & 2) {
#line 896
      return (1);
    } else {
#line 895
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 895
  if ((int )cent->flags & 2) {
#line 896
    return (1);
  }
  {
#line 898
  tmp = malloc(sizeof(rr_lent_t ));
#line 898
  ne = (rr_lent_t *)tmp;
  }
#line 898
  if (! ne) {
#line 899
    return (0);
  }
#line 900
  ne->rrset = rrs;
#line 901
  ne->cent = cent;
#line 902
  ne->idx = idx;
#line 903
  ne->next = (struct rr_lent_s *)((void *)0);
#line 904
  ne->prev = (struct rr_lent_s *)((void *)0);
#line 906
  if (insert_sort) {
    {
#line 910
    ts = get_rrlent_ts(ne);
#line 911
    le = rrset_l_tail;
    }
    {
#line 912
    while (1) {
      while_continue: /* CIL Label */ ;
#line 912
      if (! le) {
#line 912
        goto while_break;
      }
      {
#line 913
      tmp___0 = get_rrlent_ts(le);
      }
#line 913
      if (ts >= tmp___0) {
#line 913
        goto found;
      }
#line 914
      le = le->prev;
    }
    while_break: /* CIL Label */ ;
    }
#line 917
    ne->next = rrset_l;
#line 918
    if (rrset_l) {
#line 919
      rrset_l->prev = ne;
    } else {
#line 921
      rrset_l_tail = ne;
    }
#line 922
    rrset_l = ne;
#line 923
    goto finish;
    found: 
#line 925
    ne->next = le->next;
#line 926
    ne->prev = le;
#line 927
    if (le->next) {
#line 928
      (le->next)->prev = ne;
    } else {
#line 930
      rrset_l_tail = ne;
    }
#line 931
    le->next = ne;
    finish: ;
  } else {
#line 936
    ne->prev = rrset_l_tail;
#line 937
    if (rrset_l_tail) {
#line 938
      rrset_l_tail->next = ne;
    } else {
#line 940
      rrset_l = ne;
    }
#line 941
    rrset_l_tail = ne;
  }
#line 944
  if (rrs) {
#line 945
    rrs->lent = ne;
  } else {
#line 947
    cent->__annonCompField2.neg.lent = ne;
  }
#line 949
  return (1);
}
}
#line 953 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/cache.c"
static void remove_rrl(rr_lent_t *le ) 
{ 
  rr_lent_t *next ;
  rr_lent_t *prev ;

  {
#line 955
  next = le->next;
#line 955
  prev = le->prev;
#line 956
  if (next) {
#line 957
    next->prev = prev;
  } else {
#line 959
    rrset_l_tail = prev;
  }
#line 960
  if (prev) {
#line 961
    prev->next = next;
  } else {
#line 963
    rrset_l = next;
  }
  {
#line 964
  free((void *)le);
  }
#line 965
  return;
}
}
#line 972 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/cache.c"
static rr_lent_t *listmerge(rr_lent_t *p , rr_lent_t *q ) 
{ 
  rr_lent_t *l ;
  rr_lent_t **s ;
  time_t tmp ;
  time_t tmp___0 ;

  {
#line 975
  if (! p) {
#line 976
    return (q);
  } else
#line 977
  if (! q) {
#line 978
    return (p);
  } else {
#line 980
    l = (rr_lent_t *)((void *)0);
#line 980
    s = & l;
    {
#line 982
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 983
      tmp = get_rrlent_ts(p);
#line 983
      tmp___0 = get_rrlent_ts(q);
      }
#line 983
      if (tmp <= tmp___0) {
#line 984
        *s = p;
#line 985
        s = & p->next;
#line 986
        p = *s;
#line 987
        if (! p) {
#line 988
          *s = q;
#line 989
          goto while_break;
        }
      } else {
#line 993
        *s = q;
#line 994
        s = & q->next;
#line 995
        q = *s;
#line 996
        if (! q) {
#line 997
          *s = p;
#line 998
          goto while_break;
        }
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 1003
    return (l);
  }
}
}
#line 1012 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/cache.c"
static void sort_rrl(void) 
{ 
  rr_lent_t *tmp[32] ;
  rr_lent_t **fill ;
  rr_lent_t **end ;
  rr_lent_t **counter ;
  rr_lent_t *rem ;
  rr_lent_t *carry ;
  rr_lent_t *p ;
  rr_lent_t *q ;

  {
#line 1015
  if (rrset_l) {
#line 1015
    if (rrset_l->next) {
#line 1021
      fill = tmp;
#line 1021
      end = tmp + 32;
#line 1022
      rem = rrset_l;
      {
#line 1024
      while (1) {
        while_continue: /* CIL Label */ ;
#line 1025
        carry = rem;
#line 1025
        rem = rem->next;
#line 1026
        carry->next = (struct rr_lent_s *)((void *)0);
#line 1027
        counter = tmp;
        {
#line 1027
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 1027
          if ((unsigned long )counter != (unsigned long )fill) {
#line 1027
            if (! ((unsigned long )*counter != (unsigned long )((void *)0))) {
#line 1027
              goto while_break___0;
            }
          } else {
#line 1027
            goto while_break___0;
          }
          {
#line 1028
          carry = listmerge(*counter, carry);
#line 1029
          *counter = (rr_lent_t *)((void *)0);
#line 1027
          counter ++;
          }
        }
        while_break___0: /* CIL Label */ ;
        }
#line 1032
        if (! ((unsigned long )counter != (unsigned long )end)) {
          {
#line 1032
          log_message(3, "%s:%d: %s", "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/cache.c",
                      1032, "sort_rrl: tmp array overflowed");
#line 1032
          pdnsd_exit();
          }
        }
#line 1034
        *counter = carry;
#line 1036
        if ((unsigned long )counter == (unsigned long )fill) {
#line 1036
          fill ++;
        }
#line 1024
        if (! rem) {
#line 1024
          goto while_break;
        }
      }
      while_break: /* CIL Label */ ;
      }
#line 1041
      carry = tmp[0];
#line 1042
      counter = tmp;
      {
#line 1043
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 1043
        counter ++;
#line 1043
        if (! ((unsigned long )counter != (unsigned long )fill)) {
#line 1043
          goto while_break___1;
        }
        {
#line 1044
        carry = listmerge(*counter, carry);
        }
      }
      while_break___1: /* CIL Label */ ;
      }
#line 1046
      rrset_l = carry;
#line 1050
      q = (rr_lent_t *)((void *)0);
#line 1051
      p = rrset_l;
      {
#line 1051
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 1051
        if (! p) {
#line 1051
          goto while_break___2;
        }
#line 1051
        p->prev = q;
#line 1051
        q = p;
#line 1051
        p = p->next;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 1052
      rrset_l_tail = q;
    }
  }
#line 1055
  return;
}
}
#line 1059 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/cache.c"
__inline static rr_bucket_t *copy_rr(rr_bucket_t *rr ) 
{ 
  rr_bucket_t *rrn ;
  void *tmp ;

  {
  {
#line 1062
  tmp = malloc(sizeof(rr_bucket_t ) + (unsigned long )rr->rdlen);
#line 1062
  rrn = (rr_bucket_t *)tmp;
  }
#line 1063
  if ((unsigned long )rrn == (unsigned long )((void *)0)) {
#line 1064
    return ((rr_bucket_t *)((void *)0));
  }
  {
#line 1065
  memcpy((void */* __restrict  */)rrn, (void const   */* __restrict  */)rr, sizeof(rr_bucket_t ) + (unsigned long )rr->rdlen);
#line 1066
  rrn->next = (struct rr_b_s *)((void *)0);
  }
#line 1067
  return (rrn);
}
}
#line 1072 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/cache.c"
static rr_set_t *copy_rrset(rr_set_t *rrset ) 
{ 
  rr_set_t *rrsc ;
  void *tmp ;
  rr_bucket_t *rr ;
  rr_bucket_t **rrp ;
  rr_bucket_t *rrc ;
  rr_bucket_t *tmp___0 ;

  {
  {
#line 1074
  tmp = malloc(sizeof(rr_set_t ));
#line 1074
  rrsc = (rr_set_t *)tmp;
  }
#line 1076
  if (rrsc) {
#line 1077
    *rrsc = *rrset;
#line 1078
    rrsc->lent = (struct rr_lent_s *)((void *)0);
#line 1079
    rrp = & rrsc->rrs;
#line 1080
    rr = rrset->rrs;
    {
#line 1081
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1081
      if (! rr) {
#line 1081
        goto while_break;
      }
      {
#line 1082
      tmp___0 = copy_rr(rr);
#line 1082
      rrc = tmp___0;
#line 1083
      *rrp = rrc;
      }
#line 1084
      if (! rrc) {
#line 1084
        goto cleanup_return;
      }
#line 1085
      rrp = & rrc->next;
#line 1086
      rr = rr->next;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 1089
  return (rrsc);
  cleanup_return: 
  {
#line 1092
  del_rrset(rrsc);
  }
#line 1093
  return ((rr_set_t *)((void *)0));
}
}
#line 1098 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/cache.c"
dns_cent_t *copy_cent(dns_cent_t *cent ) 
{ 
  dns_cent_t *copy ;
  void *tmp ;
  size_t namesz ;
  unsigned int tmp___0 ;
  unsigned char *tmp___1 ;
  void *tmp___2 ;
  int i ;
  int ilim ;
  rr_set_t **rrextc ;
  void *tmp___3 ;
  rr_set_t *rrset ;
  rr_set_t *tmp___4 ;
  rr_set_t *rrsc ;
  void *tmp___5 ;
  rr_bucket_t *rr ;
  rr_bucket_t **rrp ;
  rr_set_t **tmp___6 ;
  rr_bucket_t *rrc ;
  rr_bucket_t *tmp___7 ;

  {
  {
#line 1106
  tmp = malloc(sizeof(dns_cent_t ));
#line 1106
  copy = (dns_cent_t *)tmp;
  }
#line 1106
  if (! copy) {
#line 1107
    return ((dns_cent_t *)((void *)0));
  }
  {
#line 1111
  tmp___0 = rhnlen((unsigned char const   *)cent->qname);
#line 1111
  namesz = (size_t )tmp___0;
#line 1112
  tmp___2 = malloc(namesz);
#line 1112
  tmp___1 = (unsigned char *)tmp___2;
#line 1112
  copy->qname = tmp___1;
  }
#line 1112
  if (! tmp___1) {
#line 1113
    goto free_return_null;
  }
  {
#line 1115
  memcpy((void */* __restrict  */)copy->qname, (void const   */* __restrict  */)cent->qname,
         namesz);
#line 1117
  copy->cs = cent->cs;
#line 1118
  copy->num_rrs = cent->num_rrs;
#line 1119
  copy->flags = cent->flags;
#line 1120
  copy->c_ns = cent->c_ns;
#line 1121
  copy->c_soa = cent->c_soa;
  }
#line 1122
  if ((int )cent->flags & 1) {
#line 1123
    copy->__annonCompField2.neg.lent = (struct rr_lent_s *)((void *)0);
#line 1124
    copy->__annonCompField2.neg.ttl = cent->__annonCompField2.neg.ttl;
#line 1125
    copy->__annonCompField2.neg.ts = cent->__annonCompField2.neg.ts;
  } else {
#line 1129
    i = 0;
    {
#line 1129
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1129
      if (! (i < 8)) {
#line 1129
        goto while_break;
      }
#line 1130
      copy->__annonCompField2.rr.rrmu[i] = (rr_set_t *)((void *)0);
#line 1129
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 1131
    copy->__annonCompField2.rr.rrext = (rr_set_t **)((void *)0);
#line 1133
    ilim = 8;
#line 1134
    if (cent->__annonCompField2.rr.rrext) {
      {
#line 1136
      ilim = 47;
#line 1137
      tmp___3 = malloc(sizeof(rr_set_t *) * 39UL);
#line 1137
      rrextc = (rr_set_t **)tmp___3;
#line 1137
      copy->__annonCompField2.rr.rrext = rrextc;
      }
#line 1138
      if (! rrextc) {
#line 1138
        goto free_cent_return_null;
      }
#line 1140
      i = 0;
      {
#line 1140
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1140
        if (! (i < 39)) {
#line 1140
          goto while_break___0;
        }
#line 1141
        *(rrextc + i) = (rr_set_t *)((void *)0);
#line 1140
        i ++;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
#line 1144
    i = 0;
    {
#line 1144
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1144
      if (! (i < ilim)) {
#line 1144
        goto while_break___1;
      }
#line 1145
      if (i < 8) {
#line 1145
        tmp___4 = cent->__annonCompField2.rr.rrmu[i];
      } else {
#line 1145
        tmp___4 = *(cent->__annonCompField2.rr.rrext + (i - 8));
      }
#line 1145
      rrset = tmp___4;
#line 1146
      if (rrset) {
        {
#line 1147
        tmp___5 = malloc(sizeof(rr_set_t ));
#line 1147
        rrsc = (rr_set_t *)tmp___5;
        }
#line 1149
        if (i < 8) {
#line 1149
          tmp___6 = & copy->__annonCompField2.rr.rrmu[i];
        } else {
#line 1149
          tmp___6 = copy->__annonCompField2.rr.rrext + (i - 8);
        }
#line 1149
        *tmp___6 = rrsc;
#line 1150
        if (! rrsc) {
#line 1151
          goto free_cent_return_null;
        }
#line 1152
        *rrsc = *rrset;
#line 1153
        rrsc->lent = (struct rr_lent_s *)((void *)0);
#line 1154
        rrp = & rrsc->rrs;
#line 1155
        rr = rrset->rrs;
        {
#line 1156
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 1156
          if (! rr) {
#line 1156
            goto while_break___2;
          }
          {
#line 1157
          tmp___7 = copy_rr(rr);
#line 1157
          rrc = tmp___7;
#line 1158
          *rrp = rrc;
          }
#line 1159
          if (! rrc) {
#line 1159
            goto free_cent_return_null;
          }
#line 1160
          rrp = & rrc->next;
#line 1161
          rr = rr->next;
        }
        while_break___2: /* CIL Label */ ;
        }
      }
#line 1144
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
#line 1166
  return (copy);
  free_cent_return_null: 
  {
#line 1169
  free_cent(copy);
  }
  free_return_null: 
  {
#line 1171
  free((void *)copy);
  }
#line 1172
  return ((dns_cent_t *)((void *)0));
}
}
#line 1188 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/cache.c"
static int purge_rrset(dns_cent_t *cent , int idx , int test ) 
{ 
  rr_set_t *rrs ;
  rr_set_t *tmp ;
  rr_set_t *tmp___0 ;
  rr_set_t *tmp___1 ;
  int tmp___2 ;
  time_t tmp___3 ;
  time_t tmp___4 ;

  {
#line 1190
  if ((int )cent->flags & 1) {
#line 1190
    tmp___1 = (rr_set_t *)((void *)0);
  } else {
#line 1190
    if (idx < 8) {
#line 1190
      tmp___0 = cent->__annonCompField2.rr.rrmu[idx];
    } else {
#line 1190
      if (cent->__annonCompField2.rr.rrext) {
#line 1190
        tmp = *(cent->__annonCompField2.rr.rrext + (idx - 8));
      } else {
#line 1190
        tmp = (rr_set_t *)((void *)0);
      }
#line 1190
      tmp___0 = tmp;
    }
#line 1190
    tmp___1 = tmp___0;
  }
#line 1190
  rrs = tmp___1;
#line 1191
  if (rrs) {
#line 1191
    if (! ((int )rrs->flags & 32)) {
#line 1191
      if (! ((int )rrs->flags & 2)) {
#line 1191
        if (rrs->ttl < 120L) {
#line 1191
          tmp___3 = (time_t )120;
        } else {
#line 1191
          tmp___3 = rrs->ttl;
        }
        {
#line 1191
        tmp___4 = time((time_t *)((void *)0));
        }
#line 1191
        if (rrs->ts + tmp___3 < tmp___4) {
#line 1193
          if (! test) {
            {
#line 1194
            tmp___2 = del_cent_rrset_by_index(cent, idx);
#line 1194
            cache_size -= (long volatile   )tmp___2;
            }
          }
#line 1195
          return (1);
        }
      }
    }
  }
#line 1197
  return (0);
}
}
#line 1207 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/cache.c"
static int purge_all_rrsets(dns_cent_t *cent , int test , int *numrrsrem ) 
{ 
  int rv ;
  int numrrs ;
  int numrrext ;
  int i ;
  int ilim ;
  int tmp ;
  int tmp___0 ;
  rr_set_t *rrs ;
  rr_set_t *tmp___1 ;
  int tmp___2 ;
  time_t tmp___3 ;
  time_t tmp___4 ;

  {
#line 1209
  rv = 0;
#line 1209
  numrrs = 0;
#line 1209
  numrrext = 0;
#line 1211
  if (! ((int )cent->flags & 1)) {
#line 1212
    if ((int )cent->flags & 1) {
#line 1212
      tmp___0 = 0;
    } else {
#line 1212
      if (cent->__annonCompField2.rr.rrext) {
#line 1212
        tmp = 47;
      } else {
#line 1212
        tmp = 8;
      }
#line 1212
      tmp___0 = tmp;
    }
#line 1212
    ilim = tmp___0;
#line 1213
    i = 0;
    {
#line 1213
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1213
      if (! (i < ilim)) {
#line 1213
        goto while_break;
      }
#line 1214
      if (i < 8) {
#line 1214
        tmp___1 = cent->__annonCompField2.rr.rrmu[i];
      } else {
#line 1214
        tmp___1 = *(cent->__annonCompField2.rr.rrext + (i - 8));
      }
#line 1214
      rrs = tmp___1;
#line 1215
      if (rrs) {
#line 1216
        if ((int )rrs->flags & 32) {
#line 1216
          goto _L___0;
        } else
#line 1216
        if ((int )rrs->flags & 2) {
          _L___0: /* CIL Label */ 
#line 1223
          numrrs ++;
#line 1224
          if (i >= 8) {
#line 1224
            numrrext ++;
          }
        } else {
#line 1216
          if (rrs->ttl < 120L) {
#line 1216
            tmp___3 = (time_t )120;
          } else {
#line 1216
            tmp___3 = rrs->ttl;
          }
          {
#line 1216
          tmp___4 = time((time_t *)((void *)0));
          }
#line 1216
          if (rrs->ts + tmp___3 < tmp___4) {
#line 1218
            if (! test) {
              {
#line 1219
              tmp___2 = del_cent_rrset_by_index(cent, i);
#line 1219
              cache_size -= (long volatile   )tmp___2;
              }
            }
#line 1220
            rv ++;
          } else {
#line 1216
            goto _L___0;
          }
        }
      }
#line 1213
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 1230
    if (cent->__annonCompField2.rr.rrext) {
#line 1230
      if (numrrext == 0) {
#line 1231
        if (! test) {
          {
#line 1232
          free((void *)cent->__annonCompField2.rr.rrext);
#line 1233
          cent->__annonCompField2.rr.rrext = (rr_set_t **)((void *)0);
#line 1234
          cent->cs -= sizeof(rr_set_t *) * 39UL;
#line 1235
          cache_size = (long volatile   )((unsigned long )cache_size - sizeof(rr_set_t *) * 39UL);
          }
        }
#line 1237
        rv ++;
      }
    }
  }
#line 1241
  if (numrrsrem) {
#line 1241
    *numrrsrem = numrrs;
  }
#line 1242
  return (rv);
}
}
#line 1257 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/cache.c"
static int purge_cent(dns_cent_t *cent , int delete , int test ) 
{ 
  int npurge ;
  int numrrs ;
  time_t tmp ;
  time_t tmp___0 ;
  unsigned int scnt ;
  unsigned int tmp___1 ;
  rr_set_t *rrset ;
  dns_cent_t *ce ;
  unsigned char const   *tmp___2 ;
  dns_cent_t *tmp___3 ;
  time_t tmp___4 ;
  time_t tmp___5 ;
  rr_set_t *rrset___0 ;
  dns_cent_t *ce___0 ;
  unsigned char const   *tmp___6 ;
  dns_cent_t *tmp___7 ;
  time_t tmp___8 ;
  time_t tmp___9 ;

  {
  {
#line 1261
  npurge = purge_all_rrsets(cent, test, & numrrs);
  }
#line 1264
  if (delete) {
#line 1264
    if (numrrs == 0) {
#line 1264
      if (! ((int )cent->flags & 1)) {
#line 1264
        goto _L;
      } else
#line 1264
      if (! ((int )cent->flags & 2)) {
#line 1264
        if (cent->__annonCompField2.neg.ttl < 120L) {
#line 1264
          tmp = (time_t )120;
        } else {
#line 1264
          tmp = cent->__annonCompField2.neg.ttl;
        }
        {
#line 1264
        tmp___0 = time((time_t *)((void *)0));
        }
#line 1264
        if (cent->__annonCompField2.neg.ts + tmp < tmp___0) {
          _L: /* CIL Label */ 
#line 1268
          if (! test) {
            {
#line 1269
            del_cache_ent(cent, (dns_hash_loc_t *)((void *)0));
            }
          }
#line 1270
          return (-1);
        }
      }
    }
  }
#line 1273
  if (! ((int )cent->flags & 2)) {
    {
#line 1275
    tmp___1 = rhnsegcnt((unsigned char const   *)cent->qname);
#line 1275
    scnt = tmp___1;
    }
#line 1276
    if ((int )cent->c_ns != 255) {
#line 1277
      rrset = (rr_set_t *)((void *)0);
#line 1278
      if ((unsigned int )cent->c_ns == scnt) {
#line 1279
        if (! ((int )cent->flags & 1)) {
#line 1279
          rrset = cent->__annonCompField2.rr.rrmu[1];
        } else {
#line 1279
          rrset = (rr_set_t *)((void *)0);
        }
      } else
#line 1280
      if ((unsigned int )cent->c_ns < scnt) {
        {
#line 1281
        tmp___2 = skipsegs((unsigned char const   *)cent->qname, scnt - (unsigned int )cent->c_ns);
#line 1281
        tmp___3 = dns_lookup(tmp___2, (dns_hash_loc_t *)((void *)0));
#line 1281
        ce = tmp___3;
        }
#line 1282
        if (ce) {
#line 1282
          if (! ((int )ce->flags & 1)) {
#line 1282
            rrset = ce->__annonCompField2.rr.rrmu[1];
          } else {
#line 1282
            rrset = (rr_set_t *)((void *)0);
          }
        }
      }
#line 1284
      if (! rrset) {
#line 1284
        goto _L___0;
      } else
#line 1284
      if (! rrset->rrs) {
#line 1284
        goto _L___0;
      } else
#line 1284
      if (! ((int )rrset->flags & 2)) {
#line 1284
        if (rrset->ttl < 120L) {
#line 1284
          tmp___4 = (time_t )120;
        } else {
#line 1284
          tmp___4 = rrset->ttl;
        }
        {
#line 1284
        tmp___5 = time((time_t *)((void *)0));
        }
#line 1284
        if (rrset->ts + tmp___4 < tmp___5) {
          _L___0: /* CIL Label */ 
#line 1285
          if (! test) {
#line 1286
            cent->c_ns = (unsigned char)255;
          }
#line 1287
          npurge ++;
        }
      }
    }
#line 1290
    if ((int )cent->c_soa != 255) {
#line 1291
      rrset___0 = (rr_set_t *)((void *)0);
#line 1292
      if ((unsigned int )cent->c_soa == scnt) {
#line 1293
        if (! ((int )cent->flags & 1)) {
#line 1293
          rrset___0 = cent->__annonCompField2.rr.rrmu[3];
        } else {
#line 1293
          rrset___0 = (rr_set_t *)((void *)0);
        }
      } else
#line 1294
      if ((unsigned int )cent->c_soa < scnt) {
        {
#line 1295
        tmp___6 = skipsegs((unsigned char const   *)cent->qname, scnt - (unsigned int )cent->c_soa);
#line 1295
        tmp___7 = dns_lookup(tmp___6, (dns_hash_loc_t *)((void *)0));
#line 1295
        ce___0 = tmp___7;
        }
#line 1296
        if (ce___0) {
#line 1296
          if (! ((int )ce___0->flags & 1)) {
#line 1296
            rrset___0 = ce___0->__annonCompField2.rr.rrmu[3];
          } else {
#line 1296
            rrset___0 = (rr_set_t *)((void *)0);
          }
        }
      }
#line 1298
      if (! rrset___0) {
#line 1298
        goto _L___1;
      } else
#line 1298
      if (! rrset___0->rrs) {
#line 1298
        goto _L___1;
      } else
#line 1298
      if (! ((int )rrset___0->flags & 2)) {
#line 1298
        if (rrset___0->ttl < 120L) {
#line 1298
          tmp___8 = (time_t )120;
        } else {
#line 1298
          tmp___8 = rrset___0->ttl;
        }
        {
#line 1298
        tmp___9 = time((time_t *)((void *)0));
        }
#line 1298
        if (rrset___0->ts + tmp___8 < tmp___9) {
          _L___1: /* CIL Label */ 
#line 1299
          if (! test) {
#line 1300
            cent->c_soa = (unsigned char)255;
          }
#line 1301
          npurge ++;
        }
      }
    }
  }
#line 1306
  return (npurge);
}
}
#line 1314 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/cache.c"
static void purge_cache(long sz , int lazy ) 
{ 
  rr_lent_t *le ;
  rr_lent_t *next ;
  dns_cent_t *ce ;
  time_t tmp ;
  time_t tmp___0 ;
  rr_lent_t *next___0 ;
  dns_cent_t *ce___0 ;
  int tmp___1 ;

  {
#line 1322
  le = rrset_l;
  {
#line 1323
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1323
    if (le) {
#line 1323
      if (! (! lazy)) {
#line 1323
        if (! (cache_size > (long volatile   )sz)) {
#line 1323
          goto while_break;
        }
      }
    } else {
#line 1323
      goto while_break;
    }
#line 1327
    next = le->next;
#line 1328
    if (le->rrset) {
#line 1328
      if (! ((int )(le->rrset)->flags & 2)) {
#line 1328
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 1328
    if (! ((int )(le->cent)->flags & 2)) {
#line 1330
      ce = le->cent;
#line 1331
      if (le->rrset) {
        {
#line 1332
        purge_rrset(ce, le->idx, 0);
        }
      }
#line 1335
      if ((int )ce->num_rrs == 0) {
#line 1335
        if (! ((int )ce->flags & 1)) {
          {
#line 1337
          del_cache_ent(ce, (dns_hash_loc_t *)((void *)0));
          }
        } else
#line 1335
        if (! ((int )ce->flags & 2)) {
#line 1335
          if (ce->__annonCompField2.neg.ttl < 120L) {
#line 1335
            tmp = (time_t )120;
          } else {
#line 1335
            tmp = ce->__annonCompField2.neg.ttl;
          }
          {
#line 1335
          tmp___0 = time((time_t *)((void *)0));
          }
#line 1335
          if (ce->__annonCompField2.neg.ts + tmp < tmp___0) {
            {
#line 1337
            del_cache_ent(ce, (dns_hash_loc_t *)((void *)0));
            }
          }
        }
      }
    }
#line 1339
    le = next;
  }
  while_break: /* CIL Label */ ;
  }
#line 1341
  if (cache_size <= (long volatile   )sz) {
#line 1342
    return;
  }
#line 1347
  if (! insert_sort) {
    {
#line 1348
    sort_rrl();
#line 1349
    insert_sort = (short)1;
    }
  }
#line 1352
  le = rrset_l;
  {
#line 1353
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1353
    if (le) {
#line 1353
      if (! (cache_size > (long volatile   )sz)) {
#line 1353
        goto while_break___0;
      }
    } else {
#line 1353
      goto while_break___0;
    }
#line 1354
    next___0 = le->next;
#line 1355
    if (le->rrset) {
#line 1355
      if (! ((int )(le->rrset)->flags & 2)) {
#line 1355
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 1355
    if (! ((int )(le->cent)->flags & 2)) {
#line 1357
      ce___0 = le->cent;
#line 1358
      if (le->rrset) {
        {
#line 1359
        tmp___1 = del_cent_rrset_by_index(ce___0, le->idx);
#line 1359
        cache_size -= (long volatile   )tmp___1;
        }
      }
#line 1361
      if ((int )ce___0->num_rrs == 0) {
        {
#line 1362
        del_cache_ent(ce___0, (dns_hash_loc_t *)((void *)0));
        }
      }
    }
#line 1364
    le = next___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1366
  return;
}
}
#line 1375 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/cache.c"
void read_disk_cache(void) 
{ 
  dns_cent_t ce ;
  int dtsz ;
  unsigned char *data ;
  unsigned long cnt ;
  FILE *f ;
  size_t tmp ;
  char *path ;
  unsigned long __lengthofpath ;
  void *tmp___0 ;
  char *tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  void *tmp___4 ;
  unsigned int nb ;
  char buf[sizeof(cachverid)] ;
  size_t tmp___5 ;
  char const   *tmp___8 ;
  int tmp___9 ;
  char const   *tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  char const   *tmp___16 ;
  int tmp___17 ;
  char const   *tmp___18 ;
  int tmp___19 ;
  size_t tmp___20 ;
  dns_file_t fe ;
  dom_fttlts_t fttlts ;
  unsigned char nb___0[256] ;
  unsigned int num_rrs ;
  unsigned char prevtp ;
  char const   *tmp___23 ;
  int tmp___24 ;
  char const   *tmp___25 ;
  int tmp___26 ;
  size_t tmp___27 ;
  char const   *tmp___30 ;
  int tmp___31 ;
  char const   *tmp___32 ;
  int tmp___33 ;
  size_t tmp___34 ;
  int i ;
  char const   *tmp___37 ;
  int tmp___38 ;
  char const   *tmp___39 ;
  int tmp___40 ;
  size_t tmp___41 ;
  unsigned int lb ;
  int tmp___42 ;
  rr_fset_t sh ;
  unsigned int num_rr ;
  char const   *tmp___45 ;
  int tmp___46 ;
  char const   *tmp___47 ;
  int tmp___48 ;
  size_t tmp___49 ;
  int tmp___50 ;
  rr_fbucket_t rr ;
  char const   *tmp___53 ;
  int tmp___54 ;
  char const   *tmp___55 ;
  int tmp___56 ;
  size_t tmp___57 ;
  unsigned char *tmp___58 ;
  void *tmp___59 ;
  char const   *tmp___62 ;
  int tmp___63 ;
  char const   *tmp___64 ;
  int tmp___65 ;
  size_t tmp___66 ;
  int tmp___67 ;

  {
  {
#line 1379
  dtsz = 512;
#line 1384
  tmp = strlen((char const   *)global.cache_dir);
#line 1384
  __lengthofpath = tmp + sizeof("/pdnsd.cache");
#line 1384
  tmp___0 = __builtin_alloca(sizeof(*path) * __lengthofpath);
#line 1384
  path = (char *)tmp___0;
#line 1386
  tmp___1 = stpcpy((char */* __restrict  */)path, (char const   */* __restrict  */)global.cache_dir);
#line 1386
  stpcpy((char */* __restrict  */)tmp___1, (char const   */* __restrict  */)"/pdnsd.cache");
#line 1388
  f = fopen((char const   */* __restrict  */)path, (char const   */* __restrict  */)"r");
  }
#line 1388
  if (! f) {
    {
#line 1389
    tmp___2 = __errno_location();
#line 1389
    tmp___3 = strerror(*tmp___2);
#line 1389
    log_message(4, "Could not open disk cache file %s: %s", path, tmp___3);
    }
#line 1390
    return;
  }
  {
#line 1393
  tmp___4 = malloc((size_t )dtsz);
#line 1393
  data = (unsigned char *)tmp___4;
  }
#line 1393
  if (! data) {
#line 1394
    goto fclose_exit;
  }
  {
#line 1402
  insert_sort = (short)0;
#line 1409
  tmp___5 = fread((void */* __restrict  */)(buf), (size_t )1, sizeof(cachverid), (FILE */* __restrict  */)f);
#line 1409
  nb = (unsigned int )tmp___5;
  }
#line 1410
  if ((unsigned long )nb != sizeof(cachverid)) {
#line 1412
    if (nb != 0U) {
#line 1412
      goto _L;
    } else {
      {
#line 1412
      tmp___12 = feof(f);
      }
#line 1412
      if (! tmp___12) {
        _L: /* CIL Label */ 
        {
#line 1413
        tmp___11 = ferror(f);
        }
#line 1413
        if (tmp___11) {
#line 1413
          tmp___10 = "Error";
        } else {
          {
#line 1413
          tmp___9 = feof(f);
          }
#line 1413
          if (tmp___9) {
#line 1413
            tmp___8 = "EOF";
          } else {
#line 1413
            tmp___8 = "Incomplete item";
          }
#line 1413
          tmp___10 = tmp___8;
        }
        {
#line 1413
        log_message(4, "%s encountered while reading %s from disk cache file.", tmp___10,
                    "cache version identifier");
        }
      }
    }
#line 1415
    goto free_data_fclose;
  }
  {
#line 1417
  tmp___13 = memcmp((void const   *)(buf), (void const   *)(cachverid), sizeof(cachverid));
  }
#line 1417
  if (tmp___13) {
    {
#line 1418
    log_message(4, "Cache file %s ignored because of incompatible version identifier",
                path);
    }
#line 1419
    goto free_data_fclose;
  }
  {
#line 1423
  tmp___20 = fread((void */* __restrict  */)(& cnt), sizeof(cnt), (size_t )1, (FILE */* __restrict  */)f);
  }
#line 1423
  if (tmp___20 != 1UL) {
    {
#line 1424
    tmp___19 = ferror(f);
    }
#line 1424
    if (tmp___19) {
#line 1424
      tmp___18 = "Error";
    } else {
      {
#line 1424
      tmp___17 = feof(f);
      }
#line 1424
      if (tmp___17) {
#line 1424
        tmp___16 = "EOF";
      } else {
#line 1424
        tmp___16 = "Incomplete item";
      }
#line 1424
      tmp___18 = tmp___16;
    }
    {
#line 1424
    log_message(4, "%s encountered while reading %s from disk cache file.", tmp___18,
                "entry count");
    }
#line 1425
    goto free_data_fclose;
  }
  {
#line 1428
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1428
    if (! (cnt > 0UL)) {
#line 1428
      goto while_break;
    }
    {
#line 1430
    fttlts.ttl = (time_t )0;
#line 1430
    fttlts.ts = (time_t )0;
#line 1434
    tmp___27 = fread((void */* __restrict  */)(& fe), sizeof(fe), (size_t )1, (FILE */* __restrict  */)f);
    }
#line 1434
    if (tmp___27 != 1UL) {
      {
#line 1435
      tmp___26 = ferror(f);
      }
#line 1435
      if (tmp___26) {
#line 1435
        tmp___25 = "Error";
      } else {
        {
#line 1435
        tmp___24 = feof(f);
        }
#line 1435
        if (tmp___24) {
#line 1435
          tmp___23 = "EOF";
        } else {
#line 1435
          tmp___23 = "Incomplete item";
        }
#line 1435
        tmp___25 = tmp___23;
      }
      {
#line 1435
      log_message(4, "%s encountered while reading %s from disk cache file.", tmp___25,
                  "cache entry header");
      }
#line 1436
      goto free_data_fclose;
    }
#line 1438
    if ((int )fe.flags & 1) {
      {
#line 1439
      tmp___34 = fread((void */* __restrict  */)(& fttlts), sizeof(fttlts), (size_t )1,
                       (FILE */* __restrict  */)f);
      }
#line 1439
      if (tmp___34 != 1UL) {
        {
#line 1440
        tmp___33 = ferror(f);
        }
#line 1440
        if (tmp___33) {
#line 1440
          tmp___32 = "Error";
        } else {
          {
#line 1440
          tmp___31 = feof(f);
          }
#line 1440
          if (tmp___31) {
#line 1440
            tmp___30 = "EOF";
          } else {
#line 1440
            tmp___30 = "Incomplete item";
          }
#line 1440
          tmp___32 = tmp___30;
        }
        {
#line 1440
        log_message(4, "%s encountered while reading %s from disk cache file.", tmp___32,
                    "cache TTL and timestamp");
        }
#line 1441
        goto free_data_fclose;
      }
    }
#line 1444
    if (fe.qlen) {
      {
#line 1447
      tmp___41 = fread((void */* __restrict  */)(nb___0), (size_t )fe.qlen, (size_t )1,
                       (FILE */* __restrict  */)f);
      }
#line 1447
      if (tmp___41 != 1UL) {
        {
#line 1448
        tmp___40 = ferror(f);
        }
#line 1448
        if (tmp___40) {
#line 1448
          tmp___39 = "Error";
        } else {
          {
#line 1448
          tmp___38 = feof(f);
          }
#line 1448
          if (tmp___38) {
#line 1448
            tmp___37 = "EOF";
          } else {
#line 1448
            tmp___37 = "Incomplete item";
          }
#line 1448
          tmp___39 = tmp___37;
        }
        {
#line 1448
        log_message(4, "%s encountered while reading %s from disk cache file.", tmp___39,
                    "domain name");
        }
#line 1449
        goto free_data_fclose;
      }
#line 1451
      i = 0;
      {
#line 1451
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1451
        if (! (i < (int )fe.qlen)) {
#line 1451
          goto while_break___0;
        }
#line 1452
        lb = (unsigned int )nb___0[i];
#line 1453
        if (! lb) {
          {
#line 1454
          log_message(4, "Invalid domain name encountered while reading disk cache file.");
          }
#line 1455
          goto free_data_fclose;
        } else
#line 1453
        if (lb > 63U) {
          {
#line 1454
          log_message(4, "Invalid domain name encountered while reading disk cache file.");
          }
#line 1455
          goto free_data_fclose;
        } else {
#line 1453
          i = (int )((unsigned int )i + (lb + 1U));
#line 1453
          if (i > (int )fe.qlen) {
            {
#line 1454
            log_message(4, "Invalid domain name encountered while reading disk cache file.");
            }
#line 1455
            goto free_data_fclose;
          }
        }
      }
      while_break___0: /* CIL Label */ ;
      }
    }
    {
#line 1459
    nb___0[fe.qlen] = (unsigned char )'\000';
#line 1460
    tmp___42 = init_cent(& ce, (unsigned char const   *)(nb___0), fttlts.ttl, fttlts.ts,
                         (unsigned int )fe.flags);
    }
#line 1460
    if (! tmp___42) {
#line 1461
      goto free_data_fclose_exit;
    }
#line 1463
    ce.c_ns = fe.c_ns;
#line 1463
    ce.c_soa = fe.c_soa;
#line 1466
    prevtp = (unsigned char)0;
#line 1467
    num_rrs = (unsigned int )fe.num_rrs;
    {
#line 1467
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1467
      if (! num_rrs) {
#line 1467
        goto while_break___1;
      }
      {
#line 1470
      tmp___49 = fread((void */* __restrict  */)(& sh), sizeof(sh), (size_t )1, (FILE */* __restrict  */)f);
      }
#line 1470
      if (tmp___49 != 1UL) {
        {
#line 1471
        tmp___48 = ferror(f);
        }
#line 1471
        if (tmp___48) {
#line 1471
          tmp___47 = "Error";
        } else {
          {
#line 1471
          tmp___46 = feof(f);
          }
#line 1471
          if (tmp___46) {
#line 1471
            tmp___45 = "EOF";
          } else {
#line 1471
            tmp___45 = "Incomplete item";
          }
#line 1471
          tmp___47 = tmp___45;
        }
        {
#line 1471
        log_message(4, "%s encountered while reading %s from disk cache file.", tmp___47,
                    "rr header");
        }
#line 1472
        goto free_cent_data_fclose;
      }
#line 1474
      if ((int )sh.tp < 1) {
        {
#line 1475
        log_message(4, "Invalid rr type encountered while reading disk cache file.");
        }
#line 1476
        goto free_data_fclose;
      } else
#line 1474
      if ((int )sh.tp > 51) {
        {
#line 1475
        log_message(4, "Invalid rr type encountered while reading disk cache file.");
        }
#line 1476
        goto free_data_fclose;
      } else
#line 1474
      if ((int const   )rrlkuptab[(int )sh.tp - 1] >= 47) {
        {
#line 1475
        log_message(4, "Invalid rr type encountered while reading disk cache file.");
        }
#line 1476
        goto free_data_fclose;
      }
#line 1478
      if ((int )sh.tp <= (int )prevtp) {
        {
#line 1479
        log_message(4, "Unexpected rr type encountered (not in strict ascending order) while reading disk cache file.");
        }
#line 1480
        goto free_data_fclose;
      }
      {
#line 1482
      prevtp = sh.tp;
#line 1484
      tmp___50 = add_cent_rrset_by_type(& ce, (int )sh.tp, sh.ttl, sh.ts, (unsigned int )sh.flags);
      }
#line 1484
      if (! tmp___50) {
#line 1485
        goto free_cent_data_fclose_exit;
      }
#line 1487
      num_rr = (unsigned int )sh.num_rr;
      {
#line 1487
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 1487
        if (! num_rr) {
#line 1487
          goto while_break___2;
        }
        {
#line 1489
        tmp___57 = fread((void */* __restrict  */)(& rr), sizeof(rr), (size_t )1,
                         (FILE */* __restrict  */)f);
        }
#line 1489
        if (tmp___57 != 1UL) {
          {
#line 1490
          tmp___56 = ferror(f);
          }
#line 1490
          if (tmp___56) {
#line 1490
            tmp___55 = "Error";
          } else {
            {
#line 1490
            tmp___54 = feof(f);
            }
#line 1490
            if (tmp___54) {
#line 1490
              tmp___53 = "EOF";
            } else {
#line 1490
              tmp___53 = "Incomplete item";
            }
#line 1490
            tmp___55 = tmp___53;
          }
          {
#line 1490
          log_message(4, "%s encountered while reading %s from disk cache file.",
                      tmp___55, "rr data length");
          }
#line 1491
          goto free_cent_data_fclose;
        }
#line 1493
        if ((int )rr.rdlen > dtsz) {
          {
#line 1495
          dtsz = (int )rr.rdlen;
#line 1496
          tmp___59 = realloc((void *)data, (size_t )dtsz);
#line 1496
          tmp___58 = (unsigned char *)tmp___59;
          }
#line 1497
          if (! tmp___58) {
#line 1498
            goto free_cent_data_fclose_exit;
          }
#line 1500
          data = tmp___58;
        }
#line 1502
        if (rr.rdlen) {
          {
#line 1502
          tmp___66 = fread((void */* __restrict  */)data, (size_t )rr.rdlen, (size_t )1,
                           (FILE */* __restrict  */)f);
          }
#line 1502
          if (tmp___66 != 1UL) {
            {
#line 1503
            tmp___65 = ferror(f);
            }
#line 1503
            if (tmp___65) {
#line 1503
              tmp___64 = "Error";
            } else {
              {
#line 1503
              tmp___63 = feof(f);
              }
#line 1503
              if (tmp___63) {
#line 1503
                tmp___62 = "EOF";
              } else {
#line 1503
                tmp___62 = "Incomplete item";
              }
#line 1503
              tmp___64 = tmp___62;
            }
            {
#line 1503
            log_message(4, "%s encountered while reading %s from disk cache file.",
                        tmp___64, "rr data");
            }
#line 1504
            goto free_cent_data_fclose;
          }
        }
        {
#line 1506
        tmp___67 = add_cent_rr(& ce, (int )sh.tp, sh.ttl, sh.ts, (unsigned int )sh.flags,
                               (unsigned int )rr.rdlen, (void *)data);
        }
#line 1506
        if (! tmp___67) {
#line 1507
          goto free_cent_data_fclose_exit;
        }
#line 1487
        num_rr --;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 1467
      num_rrs --;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 1511
    add_cache(& ce);
#line 1512
    free_cent(& ce);
#line 1428
    cnt --;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1520
  goto free_data_fclose;
  free_cent_data_fclose: 
  {
#line 1524
  free_cent(& ce);
  }
  free_data_fclose: 
  {
#line 1526
  free((void *)data);
#line 1527
  fclose(f);
#line 1535
  lock_cache_r();
  }
#line 1536
  if (! insert_sort) {
    {
#line 1537
    sort_rrl();
#line 1538
    insert_sort = (short)1;
    }
  }
  {
#line 1540
  unlock_cache_r();
  }
#line 1541
  return;
  free_cent_data_fclose_exit: 
  {
#line 1544
  free_cent(& ce);
  }
  free_data_fclose_exit: 
  {
#line 1546
  free((void *)data);
  }
  fclose_exit: 
  {
#line 1548
  fclose(f);
#line 1549
  log_message(3, "Out of memory in reading cache file. Exiting.");
#line 1550
  pdnsd_exit();
  }
#line 1551
  return;
}
}
#line 1554 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/cache.c"
static int write_rrset(int tp , rr_set_t *rrs , FILE *f ) 
{ 
  rr_bucket_t *rr ;
  rr_fset_t sh ;
  rr_fbucket_t rf ;
  unsigned int num_rr ;
  int *tmp ;
  char *tmp___0 ;
  size_t tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  size_t tmp___4 ;
  size_t tmp___5 ;

  {
#line 1561
  sh.tp = (unsigned char )tp;
#line 1563
  num_rr = 0U;
#line 1564
  rr = rrs->rrs;
  {
#line 1564
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1564
    if (rr) {
#line 1564
      if (! (num_rr < 255U)) {
#line 1564
        goto while_break;
      }
    } else {
#line 1564
      goto while_break;
    }
#line 1564
    num_rr ++;
#line 1564
    rr = rr->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1565
  sh.num_rr = (unsigned char )num_rr;
#line 1566
  sh.flags = rrs->flags;
#line 1567
  sh.ttl = rrs->ttl;
#line 1568
  sh.ts = rrs->ts;
#line 1570
  tmp___1 = fwrite((void const   */* __restrict  */)(& sh), sizeof(sh), (size_t )1,
                   (FILE */* __restrict  */)f);
  }
#line 1570
  if (tmp___1 != 1UL) {
    {
#line 1571
    tmp = __errno_location();
#line 1571
    tmp___0 = strerror(*tmp);
#line 1571
    log_message(3, "Error while writing rr header to disk cache: %s", tmp___0);
    }
#line 1572
    return (0);
  }
#line 1575
  rr = rrs->rrs;
  {
#line 1576
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1576
    if (! num_rr) {
#line 1576
      goto while_break___0;
    }
    {
#line 1577
    rf.rdlen = (unsigned short )rr->rdlen;
#line 1578
    tmp___4 = fwrite((void const   */* __restrict  */)(& rf), sizeof(rf), (size_t )1,
                     (FILE */* __restrict  */)f);
    }
#line 1578
    if (tmp___4 != 1UL) {
      {
#line 1579
      tmp___2 = __errno_location();
#line 1579
      tmp___3 = strerror(*tmp___2);
#line 1579
      log_message(3, "Error while writing rr data to disk cache: %s", tmp___3);
      }
#line 1580
      return (0);
    } else
#line 1578
    if (rf.rdlen) {
      {
#line 1578
      tmp___5 = fwrite((void const   */* __restrict  */)(rr->data), (size_t )rf.rdlen,
                       (size_t )1, (FILE */* __restrict  */)f);
      }
#line 1578
      if (tmp___5 != 1UL) {
        {
#line 1579
        tmp___2 = __errno_location();
#line 1579
        tmp___3 = strerror(*tmp___2);
#line 1579
        log_message(3, "Error while writing rr data to disk cache: %s", tmp___3);
        }
#line 1580
        return (0);
      }
    }
#line 1582
    rr = rr->next;
#line 1576
    num_rr --;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1585
  return (1);
}
}
#line 1597 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/cache.c"
void write_disk_cache(void) 
{ 
  int j ;
  int jlim ;
  dns_cent_t *le ;
  unsigned long en ;
  dns_hash_pos_t pos ;
  FILE *f ;
  unsigned long num_rrs_errs ;
  size_t tmp ;
  char *path ;
  unsigned long __lengthofpath ;
  void *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int *tmp___5 ;
  char *tmp___6 ;
  int *tmp___7 ;
  char *tmp___8 ;
  size_t tmp___9 ;
  int tmp___10 ;
  rr_set_t *rrset ;
  rr_set_t *tmp___11 ;
  int *tmp___12 ;
  char *tmp___13 ;
  size_t tmp___14 ;
  int tmp___15 ;
  rr_set_t *rrset___0 ;
  rr_set_t *tmp___16 ;
  dns_file_t df ;
  int num_rrs ;
  unsigned short const   *iterlist ;
  unsigned int tmp___17 ;
  int tmp___18 ;
  rr_set_t *rrset___1 ;
  rr_set_t *tmp___19 ;
  unsigned char buf[256] ;
  unsigned char const   *tmp___20 ;
  int *tmp___21 ;
  char *tmp___22 ;
  size_t tmp___23 ;
  dom_fttlts_t fttlts ;
  int *tmp___24 ;
  char *tmp___25 ;
  size_t tmp___26 ;
  int *tmp___27 ;
  char *tmp___28 ;
  size_t tmp___29 ;
  int tmp___30 ;
  unsigned short const   *tmp___31 ;
  int tp ;
  rr_set_t *rrset___2 ;
  rr_set_t *tmp___32 ;
  int tmp___33 ;
  int *tmp___34 ;
  char *tmp___35 ;
  int tmp___36 ;

  {
  {
#line 1601
  en = 0UL;
#line 1604
  num_rrs_errs = 0UL;
#line 1607
  tmp = strlen((char const   *)global.cache_dir);
#line 1607
  __lengthofpath = tmp + sizeof("/pdnsd.cache");
#line 1607
  tmp___0 = __builtin_alloca(sizeof(*path) * __lengthofpath);
#line 1607
  path = (char *)tmp___0;
#line 1609
  tmp___1 = stpcpy((char */* __restrict  */)path, (char const   */* __restrict  */)global.cache_dir);
#line 1609
  stpcpy((char */* __restrict  */)tmp___1, (char const   */* __restrict  */)"/pdnsd.cache");
  }
#line 1611
  if (debug_p) {
    {
#line 1611
    debug_msg(0, "Writing cache to %s\n", path);
    }
  }
  {
#line 1613
  tmp___2 = softlock_cache_rw();
  }
#line 1613
  if (! tmp___2) {
#line 1614
    goto lock_failed;
  }
  {
#line 1617
  purge_cache(global.perm_cache * 1024L, 0);
#line 1618
  tmp___3 = softunlock_cache_rw();
  }
#line 1618
  if (! tmp___3) {
#line 1619
    goto lock_failed;
  }
  {
#line 1622
  tmp___4 = softlock_cache_r();
  }
#line 1622
  if (! tmp___4) {
#line 1623
    goto lock_failed;
  }
  {
#line 1626
  f = fopen((char const   */* __restrict  */)path, (char const   */* __restrict  */)"w");
  }
#line 1626
  if (! f) {
    {
#line 1627
    tmp___5 = __errno_location();
#line 1627
    tmp___6 = strerror(*tmp___5);
#line 1627
    log_message(4, "Could not open disk cache file %s: %s", path, tmp___6);
    }
#line 1628
    goto softunlock_return;
  }
  {
#line 1632
  tmp___9 = fwrite((void const   */* __restrict  */)(cachverid), sizeof(cachverid),
                   (size_t )1, (FILE */* __restrict  */)f);
  }
#line 1632
  if (tmp___9 != 1UL) {
    {
#line 1633
    tmp___7 = __errno_location();
#line 1633
    tmp___8 = strerror(*tmp___7);
#line 1633
    log_message(3, "Error while writing cache version identifier to disk cache: %s",
                tmp___8);
    }
#line 1634
    goto fclose_unlock;
  }
  {
#line 1637
  le = fetch_first(& pos);
  }
  {
#line 1637
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1637
    if (! le) {
#line 1637
      goto while_break;
    }
#line 1639
    if ((int )le->flags & 1) {
#line 1640
      if (! ((int )le->flags & 2)) {
#line 1641
        en ++;
      }
    } else {
#line 1644
      if ((int )le->flags & 1) {
#line 1644
        jlim = 0;
      } else {
#line 1644
        if (le->__annonCompField2.rr.rrext) {
#line 1644
          tmp___10 = 47;
        } else {
#line 1644
          tmp___10 = 8;
        }
#line 1644
        jlim = tmp___10;
      }
#line 1645
      j = 0;
      {
#line 1645
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1645
        if (! (j < jlim)) {
#line 1645
          goto while_break___0;
        }
#line 1646
        if (j < 8) {
#line 1646
          tmp___11 = le->__annonCompField2.rr.rrmu[j];
        } else {
#line 1646
          tmp___11 = *(le->__annonCompField2.rr.rrext + (j - 8));
        }
#line 1646
        rrset = tmp___11;
#line 1647
        if (rrset) {
#line 1647
          if (! ((int )rrset->flags & 2)) {
#line 1648
            en ++;
#line 1649
            goto while_break___0;
          }
        }
#line 1645
        j ++;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
    {
#line 1637
    le = fetch_next(& pos);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1654
  tmp___14 = fwrite((void const   */* __restrict  */)(& en), sizeof(en), (size_t )1,
                    (FILE */* __restrict  */)f);
  }
#line 1654
  if (tmp___14 != 1UL) {
    {
#line 1655
    tmp___12 = __errno_location();
#line 1655
    tmp___13 = strerror(*tmp___12);
#line 1655
    log_message(3, "Error while writing entry count to disk cache: %s", tmp___13);
    }
#line 1656
    goto fclose_unlock;
  }
  {
#line 1659
  le = fetch_first(& pos);
  }
  {
#line 1659
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1659
    if (! le) {
#line 1659
      goto while_break___1;
    }
#line 1661
    if ((int )le->flags & 1) {
#line 1662
      if (! ((int )le->flags & 2)) {
#line 1663
        goto write_rrs;
      }
    } else {
#line 1666
      if ((int )le->flags & 1) {
#line 1666
        jlim = 0;
      } else {
#line 1666
        if (le->__annonCompField2.rr.rrext) {
#line 1666
          tmp___15 = 47;
        } else {
#line 1666
          tmp___15 = 8;
        }
#line 1666
        jlim = tmp___15;
      }
#line 1667
      j = 0;
      {
#line 1667
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 1667
        if (! (j < jlim)) {
#line 1667
          goto while_break___2;
        }
#line 1668
        if (j < 8) {
#line 1668
          tmp___16 = le->__annonCompField2.rr.rrmu[j];
        } else {
#line 1668
          tmp___16 = *(le->__annonCompField2.rr.rrext + (j - 8));
        }
#line 1668
        rrset___0 = tmp___16;
#line 1669
        if (rrset___0) {
#line 1669
          if (! ((int )rrset___0->flags & 2)) {
#line 1670
            goto write_rrs;
          }
        }
#line 1667
        j ++;
      }
      while_break___2: /* CIL Label */ ;
      }
    }
#line 1674
    goto __Cont;
    write_rrs: 
    {
#line 1680
    tmp___17 = rhnlen((unsigned char const   *)le->qname);
#line 1680
    df.qlen = (unsigned char )(tmp___17 - 1U);
#line 1681
    df.num_rrs = (unsigned char)0;
#line 1682
    df.flags = le->flags;
#line 1683
    df.c_ns = le->c_ns;
#line 1683
    df.c_soa = le->c_soa;
#line 1684
    num_rrs = 0;
    }
#line 1685
    if ((int )le->flags & 1) {
#line 1685
      jlim = 0;
    } else {
#line 1685
      if (le->__annonCompField2.rr.rrext) {
#line 1685
        tmp___18 = 47;
      } else {
#line 1685
        tmp___18 = 8;
      }
#line 1685
      jlim = tmp___18;
    }
#line 1686
    j = 0;
    {
#line 1686
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 1686
      if (! (j < jlim)) {
#line 1686
        goto while_break___3;
      }
#line 1687
      if (j < 8) {
#line 1687
        tmp___19 = le->__annonCompField2.rr.rrmu[j];
      } else {
#line 1687
        tmp___19 = *(le->__annonCompField2.rr.rrext + (j - 8));
      }
#line 1687
      rrset___1 = tmp___19;
#line 1688
      if (rrset___1) {
#line 1689
        num_rrs ++;
#line 1690
        if (! ((int )rrset___1->flags & 2)) {
#line 1691
          df.num_rrs = (unsigned char )((int )df.num_rrs + 1);
        }
      }
#line 1686
      j ++;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 1694
    if (num_rrs != (int )le->num_rrs) {
#line 1694
      num_rrs_errs ++;
#line 1694
      if (num_rrs_errs <= 10UL) {
        {
#line 1696
        tmp___20 = rhn2str((unsigned char const   *)le->qname, buf, (unsigned int )sizeof(buf));
#line 1696
        log_message(4, "Counted %d rr record types for %s but cached counter=%d",
                    num_rrs, tmp___20, (int )le->num_rrs);
        }
      }
    }
    {
#line 1699
    tmp___23 = fwrite((void const   */* __restrict  */)(& df), sizeof(df), (size_t )1,
                      (FILE */* __restrict  */)f);
    }
#line 1699
    if (tmp___23 != 1UL) {
      {
#line 1700
      tmp___21 = __errno_location();
#line 1700
      tmp___22 = strerror(*tmp___21);
#line 1700
      log_message(3, "Error while writing cache entry header to disk cache: %s", tmp___22);
      }
#line 1701
      goto fclose_unlock;
    }
#line 1703
    if ((int )le->flags & 1) {
      {
#line 1704
      fttlts.ttl = le->__annonCompField2.neg.ttl;
#line 1704
      fttlts.ts = le->__annonCompField2.neg.ts;
#line 1705
      tmp___26 = fwrite((void const   */* __restrict  */)(& fttlts), sizeof(fttlts),
                        (size_t )1, (FILE */* __restrict  */)f);
      }
#line 1705
      if (tmp___26 != 1UL) {
        {
#line 1706
        tmp___24 = __errno_location();
#line 1706
        tmp___25 = strerror(*tmp___24);
#line 1706
        log_message(3, "Error while writing cache TTL and timestamp to disk cache: %s",
                    tmp___25);
        }
#line 1707
        goto fclose_unlock;
      }
    }
#line 1710
    if (df.qlen) {
      {
#line 1710
      tmp___29 = fwrite((void const   */* __restrict  */)le->qname, (size_t )df.qlen,
                        (size_t )1, (FILE */* __restrict  */)f);
      }
#line 1710
      if (tmp___29 != 1UL) {
        {
#line 1711
        tmp___27 = __errno_location();
#line 1711
        tmp___28 = strerror(*tmp___27);
#line 1711
        log_message(3, "Error while writing domain name to disk cache: %s", tmp___28);
        }
#line 1712
        goto fclose_unlock;
      }
    }
#line 1715
    if ((int )le->flags & 1) {
#line 1715
      jlim = 0;
    } else {
#line 1715
      if (le->__annonCompField2.rr.rrext) {
#line 1715
        tmp___30 = 47;
      } else {
#line 1715
        tmp___30 = 8;
      }
#line 1715
      jlim = tmp___30;
    }
#line 1716
    if ((int )le->flags & 1) {
#line 1716
      iterlist = (unsigned short const   *)((void *)0);
    } else {
#line 1716
      if (le->__annonCompField2.rr.rrext) {
#line 1716
        tmp___31 = rrcachiterlist;
      } else {
#line 1716
        tmp___31 = rrmuiterlist;
      }
#line 1716
      iterlist = tmp___31;
    }
#line 1717
    j = 0;
    {
#line 1717
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 1717
      if (! (j < jlim)) {
#line 1717
        goto while_break___4;
      }
      {
#line 1718
      tp = (int )*(iterlist + j);
#line 1719
      tmp___32 = getrrset_eff(le, tp);
#line 1719
      rrset___2 = tmp___32;
      }
#line 1720
      if (rrset___2) {
#line 1720
        if (! ((int )rrset___2->flags & 2)) {
          {
#line 1721
          tmp___33 = write_rrset(tp, rrset___2, f);
          }
#line 1721
          if (! tmp___33) {
#line 1722
            goto fclose_unlock;
          }
        }
      }
#line 1717
      j ++;
    }
    while_break___4: /* CIL Label */ ;
    }
    __Cont: /* CIL Label */ 
    {
#line 1659
    le = fetch_next(& pos);
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 1727
  tmp___36 = fclose(f);
  }
#line 1727
  if (tmp___36) {
    {
#line 1728
    tmp___34 = __errno_location();
#line 1728
    tmp___35 = strerror(*tmp___34);
#line 1728
    log_message(3, "Could not close cache file %s after writing cache: %s", path,
                tmp___35);
    }
  }
  {
#line 1730
  softunlock_cache_r();
  }
#line 1731
  if (debug_p) {
    {
#line 1731
    debug_msg(0, "Finished writing cache to disk.\n");
    }
  }
#line 1732
  return;
  fclose_unlock: 
  {
#line 1735
  fclose(f);
  }
  softunlock_return: 
  {
#line 1737
  softunlock_cache_r();
  }
#line 1738
  return;
  lock_failed: 
  {
#line 1741
  crash_msg((char *)"Lock failed; could not write disk cache.");
  }
#line 1742
  return;
}
}
#line 1759 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/cache.c"
static int cr_check_add(dns_cent_t *cent , int idx , time_t ttl , time_t ts , unsigned int flags ) 
{ 
  time_t nttl ;
  struct rr_infos  const  *rri ;
  int i ;
  int ilim ;
  int ncf ;
  int tmp ;
  rr_set_t *rrs ;
  rr_set_t *tmp___0 ;
  time_t rttl ;
  time_t tmp___1 ;
  int i___0 ;
  int ilim___0 ;
  int tmp___2 ;
  int tmp___3 ;
  rr_set_t *rrs___0 ;
  rr_set_t *tmp___4 ;

  {
#line 1764
  if (flags & 1U) {
#line 1765
    return (1);
  }
#line 1767
  nttl = (time_t )0;
#line 1768
  rri = & rr_info[idx];
#line 1770
  if (! (flags & 2U)) {
#line 1773
    if ((int )cent->flags & 2) {
#line 1774
      return (0);
    }
#line 1776
    ncf = 0;
#line 1776
    if ((int )cent->flags & 1) {
#line 1776
      ilim = 0;
    } else {
#line 1776
      if (cent->__annonCompField2.rr.rrext) {
#line 1776
        tmp = 47;
      } else {
#line 1776
        tmp = 8;
      }
#line 1776
      ilim = tmp;
    }
#line 1777
    i = 0;
    {
#line 1777
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1777
      if (! (i < ilim)) {
#line 1777
        goto while_break;
      }
#line 1778
      if (i < 8) {
#line 1778
        tmp___0 = cent->__annonCompField2.rr.rrmu[i];
      } else {
#line 1778
        tmp___0 = *(cent->__annonCompField2.rr.rrext + (i - 8));
      }
#line 1778
      rrs = tmp___0;
#line 1780
      if (rrs) {
#line 1780
        if (! ((int )rrs->flags & 1)) {
#line 1780
          if ((int const   )rri->class & (int const   )rr_info[i].excludes) {
#line 1780
            goto _L;
          } else
#line 1780
          if ((int const   )rri->excludes & (int const   )rr_info[i].class) {
            _L: /* CIL Label */ 
#line 1785
            if ((int )rrs->flags & 2) {
#line 1786
              return (0);
            }
            {
#line 1787
            ncf ++;
#line 1788
            tmp___1 = time((time_t *)((void *)0));
#line 1788
            rttl = (rrs->ttl + rrs->ts) - tmp___1;
            }
#line 1789
            if (rttl > 0L) {
#line 1789
              nttl += rttl;
            }
          }
        }
      }
#line 1777
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 1792
    if (ncf == 0) {
#line 1793
      return (1);
    }
#line 1795
    nttl /= (time_t )ncf;
  }
#line 1797
  if (flags & 2U) {
#line 1797
    goto _L___0;
  } else
#line 1797
  if (ttl > nttl) {
    _L___0: /* CIL Label */ 
#line 1798
    if ((int )cent->flags & 1) {
#line 1798
      tmp___3 = 0;
    } else {
#line 1798
      if (cent->__annonCompField2.rr.rrext) {
#line 1798
        tmp___2 = 47;
      } else {
#line 1798
        tmp___2 = 8;
      }
#line 1798
      tmp___3 = tmp___2;
    }
#line 1798
    ilim___0 = tmp___3;
#line 1801
    i___0 = 0;
    {
#line 1801
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1801
      if (! (i___0 < ilim___0)) {
#line 1801
        goto while_break___0;
      }
#line 1802
      if (i___0 < 8) {
#line 1802
        tmp___4 = cent->__annonCompField2.rr.rrmu[i___0];
      } else {
#line 1802
        tmp___4 = *(cent->__annonCompField2.rr.rrext + (i___0 - 8));
      }
#line 1802
      rrs___0 = tmp___4;
#line 1804
      if (rrs___0) {
#line 1804
        if (! ((int )rrs___0->flags & 1)) {
#line 1804
          if ((int const   )rri->class & (int const   )rr_info[i___0].excludes) {
            {
#line 1807
            del_cent_rrset_by_index(cent, i___0);
            }
          } else
#line 1804
          if ((int const   )rri->excludes & (int const   )rr_info[i___0].class) {
            {
#line 1807
            del_cent_rrset_by_index(cent, i___0);
            }
          }
        }
      }
#line 1801
      i___0 ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1810
    return (1);
  }
#line 1813
  return (0);
}
}
#line 1817 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/cache.c"
__inline static void adjust_ttl(rr_set_t *rrset ) 
{ 
  time_t min_ttl ;
  time_t neg_ttl ;
  time_t max_ttl ;

  {
#line 1819
  if ((int )rrset->flags & 8) {
#line 1820
    rrset->flags = (unsigned short )((int )rrset->flags & -9);
#line 1821
    rrset->ttl = (time_t )0;
  } else {
#line 1824
    min_ttl = global.min_ttl;
#line 1824
    neg_ttl = global.neg_ttl;
#line 1825
    if ((int )rrset->flags & 1) {
#line 1825
      if (neg_ttl < min_ttl) {
#line 1826
        min_ttl = neg_ttl;
      }
    }
#line 1827
    if (rrset->ttl < min_ttl) {
#line 1828
      rrset->ttl = min_ttl;
    } else {
#line 1830
      max_ttl = global.max_ttl;
#line 1831
      if (rrset->ttl > max_ttl) {
#line 1832
        rrset->ttl = max_ttl;
      }
    }
  }
#line 1835
  return;
}
}
#line 1840 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/cache.c"
__inline static void adjust_dom_ttl(dns_cent_t *cent ) 
{ 
  time_t min_ttl ;
  time_t neg_ttl ;
  time_t max_ttl ;

  {
#line 1842
  if ((int )cent->flags & 8) {
#line 1843
    cent->flags = (unsigned short )((int )cent->flags & -9);
#line 1844
    cent->__annonCompField2.neg.ttl = (time_t )0;
  } else {
#line 1847
    min_ttl = global.min_ttl;
#line 1847
    neg_ttl = global.neg_ttl;
#line 1848
    if (neg_ttl < min_ttl) {
#line 1849
      min_ttl = neg_ttl;
    }
#line 1850
    if (cent->__annonCompField2.neg.ttl < min_ttl) {
#line 1851
      cent->__annonCompField2.neg.ttl = min_ttl;
    } else {
#line 1853
      max_ttl = global.max_ttl;
#line 1854
      if (cent->__annonCompField2.neg.ttl > max_ttl) {
#line 1855
        cent->__annonCompField2.neg.ttl = max_ttl;
      }
    }
  }
#line 1858
  return;
}
}
#line 1874 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/cache.c"
void add_cache(dns_cent_t *cent ) 
{ 
  dns_cent_t *ce ;
  dns_hash_loc_t loc ;
  int i ;
  int ilim ;
  int tmp ;
  rr_set_t *rrset ;
  rr_set_t *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  rr_set_t *cerrs ;
  rr_set_t *tmp___5 ;
  int tmp___6 ;
  rr_set_t *centrrs ;
  rr_set_t *tmp___7 ;
  rr_set_t *cerrs___0 ;
  rr_set_t *tmp___8 ;
  rr_set_t *tmp___9 ;
  rr_set_t *tmp___10 ;
  rr_bucket_t *rr ;
  rr_bucket_t *rtail ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  time_t tmp___15 ;
  time_t tmp___16 ;

  {
  {
#line 1880
  lock_cache_rw();
  }
  retry: 
  {
#line 1882
  ce = dns_lookup((unsigned char const   *)cent->qname, & loc);
  }
#line 1882
  if (ce) {
#line 1915
    if ((int )cent->flags & 1) {
#line 1918
      if ((int )ce->flags & 1) {
#line 1918
        ilim = 0;
      } else {
#line 1918
        if (ce->__annonCompField2.rr.rrext) {
#line 1918
          tmp___4 = 47;
        } else {
#line 1918
          tmp___4 = 8;
        }
#line 1918
        ilim = tmp___4;
      }
#line 1919
      i = 0;
      {
#line 1919
      while (1) {
        while_continue: /* CIL Label */ ;
#line 1919
        if (! (i < ilim)) {
#line 1919
          goto while_break;
        }
#line 1920
        if (i < 8) {
#line 1920
          tmp___5 = ce->__annonCompField2.rr.rrmu[i];
        } else {
#line 1920
          tmp___5 = *(ce->__annonCompField2.rr.rrext + (i - 8));
        }
#line 1920
        cerrs = tmp___5;
#line 1921
        if (cerrs) {
#line 1921
          if ((int )cerrs->flags & 2) {
#line 1922
            goto unlock_cache_return;
          }
        }
#line 1919
        i ++;
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 1925
      del_cache_ent(ce, & loc);
      }
#line 1926
      goto retry;
    }
    {
#line 1928
    purge_cent(ce, 0, 0);
#line 1930
    cache_size = (long volatile   )((size_t )cache_size - ce->cs);
    }
#line 1932
    if ((int )cent->flags & 1) {
#line 1932
      ilim = 0;
    } else {
#line 1932
      if (cent->__annonCompField2.rr.rrext) {
#line 1932
        tmp___6 = 47;
      } else {
#line 1932
        tmp___6 = 8;
      }
#line 1932
      ilim = tmp___6;
    }
#line 1933
    i = 0;
    {
#line 1933
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1933
      if (! (i < ilim)) {
#line 1933
        goto while_break___0;
      }
#line 1934
      if (i < 8) {
#line 1934
        tmp___7 = cent->__annonCompField2.rr.rrmu[i];
      } else {
#line 1934
        tmp___7 = *(cent->__annonCompField2.rr.rrext + (i - 8));
      }
#line 1934
      centrrs = tmp___7;
#line 1935
      if (centrrs) {
#line 1936
        if ((int )ce->flags & 1) {
#line 1936
          tmp___10 = (rr_set_t *)((void *)0);
        } else {
#line 1936
          if (i < 8) {
#line 1936
            tmp___9 = ce->__annonCompField2.rr.rrmu[i];
          } else {
#line 1936
            if (ce->__annonCompField2.rr.rrext) {
#line 1936
              tmp___8 = *(ce->__annonCompField2.rr.rrext + (i - 8));
            } else {
#line 1936
              tmp___8 = (rr_set_t *)((void *)0);
            }
#line 1936
            tmp___9 = tmp___8;
          }
#line 1936
          tmp___10 = tmp___9;
        }
#line 1936
        cerrs___0 = tmp___10;
#line 1941
        if (cerrs___0) {
#line 1941
          if (! ((int )centrrs->flags & 2)) {
#line 1941
            if (! ((int )cerrs___0->flags & 2)) {
#line 1941
              goto _L___1;
            }
          } else
          _L___1: /* CIL Label */ 
#line 1941
          if ((int )centrrs->flags & 16) {
#line 1941
            if (! ((int )cerrs___0->flags & 16)) {
#line 1941
              goto _L___0;
            } else
#line 1941
            if (! ((int )centrrs->flags & 64)) {
#line 1941
              if ((int )cerrs___0->flags & 64) {
                _L___0: /* CIL Label */ 
#line 1941
                if (cerrs___0->ttl < 120L) {
#line 1941
                  tmp___15 = (time_t )120;
                } else {
#line 1941
                  tmp___15 = cerrs___0->ttl;
                }
                {
#line 1941
                tmp___16 = time((time_t *)((void *)0));
                }
#line 1941
                if (cerrs___0->ts + tmp___15 < tmp___16) {
#line 1941
                  goto _L;
                }
              } else {
#line 1941
                goto _L;
              }
            } else {
#line 1941
              goto _L;
            }
          } else {
#line 1941
            goto _L;
          }
        } else {
          _L: /* CIL Label */ 
          {
#line 1950
          del_cent_rrset_by_index(ce, i);
#line 1952
          tmp___11 = cr_check_add(ce, i, centrrs->ttl, centrrs->ts, (unsigned int )centrrs->flags);
          }
#line 1952
          if (! tmp___11) {
#line 1953
            goto __Cont;
          }
          {
#line 1957
          tmp___12 = add_cent_rrset_by_index(ce, (unsigned int )i, centrrs->ttl, centrrs->ts,
                                             (unsigned int )centrrs->flags);
          }
#line 1957
          if (! tmp___12) {
#line 1958
            goto addsize_unlock_cache_return;
          }
#line 1960
          rtail = (rr_bucket_t *)((void *)0);
#line 1961
          rr = centrrs->rrs;
          {
#line 1961
          while (1) {
            while_continue___1: /* CIL Label */ ;
#line 1961
            if (! rr) {
#line 1961
              goto while_break___1;
            }
            {
#line 1962
            tmp___13 = add_cent_rr_int(ce, (unsigned int )i, centrrs->ttl, centrrs->ts,
                                       (unsigned int )centrrs->flags, rr->rdlen, (void *)(rr->data),
                                       & rtail);
            }
#line 1962
            if (! tmp___13) {
#line 1966
              goto cleanup_cent_unlock_cache_return;
            }
#line 1961
            rr = rr->next;
          }
          while_break___1: /* CIL Label */ ;
          }
#line 1969
          if (i < 8) {
#line 1969
            cerrs___0 = ce->__annonCompField2.rr.rrmu[i];
          } else {
#line 1969
            cerrs___0 = *(ce->__annonCompField2.rr.rrext + (i - 8));
          }
          {
#line 1970
          adjust_ttl(cerrs___0);
#line 1971
          tmp___14 = insert_rrl(cerrs___0, ce, i);
          }
#line 1971
          if (! tmp___14) {
#line 1972
            goto cleanup_cent_unlock_cache_return;
          }
        }
      }
      __Cont: /* CIL Label */ 
#line 1933
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1977
    ce->flags = (unsigned short )((int )ce->flags | ((int )cent->flags & 20));
#line 1978
    if ((int )cent->c_ns != 255) {
#line 1978
      if ((int )ce->c_ns == 255) {
#line 1979
        ce->c_ns = cent->c_ns;
      } else
#line 1978
      if ((int )ce->c_ns < (int )cent->c_ns) {
#line 1979
        ce->c_ns = cent->c_ns;
      }
    }
#line 1980
    if ((int )cent->c_soa != 255) {
#line 1980
      if ((int )ce->c_soa == 255) {
#line 1981
        ce->c_soa = cent->c_soa;
      } else
#line 1980
      if ((int )ce->c_soa < (int )cent->c_soa) {
#line 1981
        ce->c_soa = cent->c_soa;
      }
    }
  } else {
#line 1887
    if ((int )cent->num_rrs == 0) {
#line 1887
      if (! ((int )cent->flags & 1)) {
#line 1888
        goto purge_cache_return;
      }
    }
    {
#line 1890
    ce = copy_cent(cent);
    }
#line 1890
    if (! ce) {
#line 1891
      goto warn_unlock_cache_return;
    }
#line 1893
    if (! ((int )ce->flags & 1)) {
#line 1894
      if ((int )ce->flags & 1) {
#line 1894
        ilim = 0;
      } else {
#line 1894
        if (ce->__annonCompField2.rr.rrext) {
#line 1894
          tmp = 47;
        } else {
#line 1894
          tmp = 8;
        }
#line 1894
        ilim = tmp;
      }
#line 1896
      i = 0;
      {
#line 1896
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 1896
        if (! (i < ilim)) {
#line 1896
          goto while_break___2;
        }
#line 1897
        if (i < 8) {
#line 1897
          tmp___0 = ce->__annonCompField2.rr.rrmu[i];
        } else {
#line 1897
          tmp___0 = *(ce->__annonCompField2.rr.rrext + (i - 8));
        }
#line 1897
        rrset = tmp___0;
#line 1898
        if (rrset) {
          {
#line 1899
          adjust_ttl(rrset);
#line 1900
          tmp___1 = insert_rrl(rrset, ce, i);
          }
#line 1900
          if (! tmp___1) {
#line 1901
            goto free_cent_unlock_cache_return;
          }
        }
#line 1896
        i ++;
      }
      while_break___2: /* CIL Label */ ;
      }
    } else {
      {
#line 1907
      adjust_dom_ttl(ce);
#line 1908
      tmp___2 = insert_rrl((rr_set_t *)((void *)0), ce, -1);
      }
#line 1908
      if (! tmp___2) {
#line 1909
        goto free_cent_unlock_cache_return;
      }
    }
    {
#line 1911
    tmp___3 = add_dns_hash(ce, & loc);
    }
#line 1911
    if (! tmp___3) {
#line 1912
      goto free_cent_unlock_cache_return;
    }
#line 1913
    ent_num += (long volatile   )1;
  }
#line 1984
  cache_size = (long volatile   )((size_t )cache_size + ce->cs);
  purge_cache_return: 
  {
#line 1986
  purge_cache(global.perm_cache * 1024L + 10240L, 1);
  }
#line 1987
  goto unlock_cache_return;
  cleanup_cent_unlock_cache_return: 
  {
#line 1990
  del_cent_rrset_by_index(ce, i);
  }
  addsize_unlock_cache_return: 
#line 1992
  cache_size = (long volatile   )((size_t )cache_size + ce->cs);
#line 1993
  goto warn_unlock_cache_return;
  free_cent_unlock_cache_return: 
  {
#line 1996
  free_cent(ce);
#line 1997
  free((void *)ce);
  }
  warn_unlock_cache_return: 
  {
#line 1999
  log_message(4, "Out of cache memory.");
  }
  unlock_cache_return: 
  {
#line 2001
  unlock_cache_rw();
  }
#line 2002
  return;
}
}
#line 2008 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/cache.c"
int add_reverse_cache(dns_cent_t *cent ) 
{ 
  int tp ;
  rr_set_t *rrset ;
  rr_set_t *tmp ;
  rr_bucket_t *rr ;
  dns_cent_t ce ;
  unsigned char buf[256] ;
  unsigned char rhn[256] ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  unsigned int tmp___3 ;
  int tmp___4 ;

  {
#line 2010
  tp = 1;
#line 2011
  if (! ((int )cent->flags & 1)) {
#line 2011
    tmp = cent->__annonCompField2.rr.rrmu[0];
  } else {
#line 2011
    tmp = (rr_set_t *)((void *)0);
  }
#line 2011
  rrset = tmp;
  {
#line 2013
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2014
    if (rrset) {
#line 2016
      rr = rrset->rrs;
      {
#line 2016
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 2016
        if (! rr) {
#line 2016
          goto while_break___0;
        }
        {
#line 2019
        tmp___0 = a2ptrstr((pdnsd_ca *)(rr->data), tp, buf);
        }
#line 2019
        if (tmp___0) {
          {
#line 2019
          tmp___1 = str2rhn((unsigned char const   *)(buf), rhn);
          }
#line 2019
          if (! tmp___1) {
#line 2020
            return (0);
          }
        } else {
#line 2020
          return (0);
        }
        {
#line 2021
        tmp___2 = init_cent(& ce, (unsigned char const   *)(rhn), (time_t )0, (time_t )0,
                            (unsigned int )cent->flags);
        }
#line 2021
        if (! tmp___2) {
#line 2022
          return (0);
        }
        {
#line 2023
        tmp___3 = rhnlen((unsigned char const   *)cent->qname);
#line 2023
        tmp___4 = add_cent_rr(& ce, 12, rrset->ttl, rrset->ts, (unsigned int )rrset->flags,
                              tmp___3, (void *)cent->qname);
        }
#line 2023
        if (! tmp___4) {
          {
#line 2024
          free_cent(& ce);
          }
#line 2025
          return (0);
        }
        {
#line 2028
        ce.__annonCompField2.rr.rrmu[1] = cent->__annonCompField2.rr.rrmu[1];
#line 2031
        ce.__annonCompField2.rr.rrmu[3] = cent->__annonCompField2.rr.rrmu[3];
#line 2033
        add_cache(& ce);
#line 2035
        ce.__annonCompField2.rr.rrmu[1] = (rr_set_t *)((void *)0);
#line 2038
        ce.__annonCompField2.rr.rrmu[3] = (rr_set_t *)((void *)0);
#line 2040
        free_cent(& ce);
#line 2016
        rr = rr->next;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
    }
#line 2044
    if (tp == 28) {
#line 2045
      goto while_break;
    }
#line 2046
    tp = 28;
#line 2047
    if (! ((int )cent->flags & 1)) {
#line 2047
      rrset = cent->__annonCompField2.rr.rrmu[7];
    } else {
#line 2047
      rrset = (rr_set_t *)((void *)0);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 2052
  return (1);
}
}
#line 2061 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/cache.c"
void del_cent(dns_cent_t *cent ) 
{ 


  {
  {
#line 2063
  cache_size = (long volatile   )((size_t )cache_size - cent->cs);
#line 2066
  free_cent(cent);
#line 2067
  free((void *)cent);
#line 2069
  ent_num -= (long volatile   )1;
  }
#line 2070
  return;
}
}
#line 2075 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/cache.c"
static void del_cache_ent(dns_cent_t *cent , dns_hash_loc_t *loc ) 
{ 
  dns_cent_t *data ;

  {
#line 2080
  if (loc) {
    {
#line 2081
    data = del_dns_hash_ent(loc);
    }
  } else {
    {
#line 2083
    data = del_dns_hash((unsigned char const   *)cent->qname);
    }
  }
#line 2084
  if (! data) {
    {
#line 2085
    log_message(4, "Cache entry not found by del_dns_hash() in %s, line %d", "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/cache.c",
                2085);
    }
  } else
#line 2087
  if ((unsigned long )data != (unsigned long )cent) {
    {
#line 2088
    log_message(4, "pointer returned by del_dns_hash() does not match cache entry in %s, line %d",
                "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/cache.c", 2088);
    }
  }
  {
#line 2090
  del_cent(cent);
  }
#line 2091
  return;
}
}
#line 2094 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/cache.c"
void del_cache(unsigned char const   *name ) 
{ 
  dns_cent_t *cent ;

  {
  {
#line 2098
  lock_cache_rw();
#line 2099
  cent = del_dns_hash(name);
  }
#line 2099
  if (cent) {
    {
#line 2100
    del_cent(cent);
    }
  }
  {
#line 2102
  unlock_cache_rw();
  }
#line 2103
  return;
}
}
#line 2108 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/cache.c"
void invalidate_record(unsigned char const   *name ) 
{ 
  dns_cent_t *ce ;
  int i ;
  int ilim ;
  int tmp ;
  rr_set_t *rrs ;
  rr_set_t *tmp___0 ;

  {
  {
#line 2113
  lock_cache_rw();
#line 2114
  ce = dns_lookup(name, (dns_hash_loc_t *)((void *)0));
  }
#line 2114
  if (ce) {
#line 2115
    if (! ((int )ce->flags & 1)) {
#line 2116
      if ((int )ce->flags & 1) {
#line 2116
        ilim = 0;
      } else {
#line 2116
        if (ce->__annonCompField2.rr.rrext) {
#line 2116
          tmp = 47;
        } else {
#line 2116
          tmp = 8;
        }
#line 2116
        ilim = tmp;
      }
#line 2117
      i = 0;
      {
#line 2117
      while (1) {
        while_continue: /* CIL Label */ ;
#line 2117
        if (! (i < ilim)) {
#line 2117
          goto while_break;
        }
#line 2118
        if (i < 8) {
#line 2118
          tmp___0 = ce->__annonCompField2.rr.rrmu[i];
        } else {
#line 2118
          tmp___0 = *(ce->__annonCompField2.rr.rrext + (i - 8));
        }
#line 2118
        rrs = tmp___0;
#line 2119
        if (rrs) {
#line 2120
          rrs->ts = (time_t )0;
#line 2121
          rrs->flags = (unsigned short )((int )rrs->flags & -5);
        }
#line 2117
        i ++;
      }
      while_break: /* CIL Label */ ;
      }
    } else {
#line 2127
      ce->__annonCompField2.neg.ts = (time_t )0;
    }
#line 2129
    ce->flags = (unsigned short )((int )ce->flags & -5);
  }
  {
#line 2131
  unlock_cache_rw();
  }
#line 2132
  return;
}
}
#line 2141 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/cache.c"
int set_cent_flags(unsigned char const   *name , unsigned int flags ) 
{ 
  dns_cent_t *ret ;

  {
  {
#line 2144
  lock_cache_rw();
#line 2145
  ret = dns_lookup(name, (dns_hash_loc_t *)((void *)0));
  }
#line 2146
  if (ret) {
#line 2147
    ret->flags = (unsigned short )((unsigned int )ret->flags | flags);
  }
  {
#line 2149
  unlock_cache_rw();
  }
#line 2150
  return ((unsigned long )ret != (unsigned long )((void *)0));
}
}
#line 2153 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/cache.c"
unsigned char *getlocalowner(unsigned char *name , int tp ) 
{ 
  unsigned char *ret ;
  dns_cent_t *ce ;
  unsigned int lb ;
  int tmp ;

  {
  {
#line 2155
  ret = (unsigned char *)((void *)0);
#line 2159
  lock_cache_r();
#line 2160
  lb = (unsigned int )*name;
  }
#line 2160
  if (lb) {
    {
#line 2161
    while (1) {
      while_continue: /* CIL Label */ ;
#line 2161
      name += lb + 1U;
#line 2161
      lb = (unsigned int )*name;
#line 2161
      if (! lb) {
#line 2161
        goto while_break;
      }
      {
#line 2162
      ce = dns_lookup((unsigned char const   *)name, (dns_hash_loc_t *)((void *)0));
      }
#line 2162
      if (ce) {
#line 2163
        if (! ((int )ce->flags & 2)) {
#line 2164
          goto while_break;
        }
        {
#line 2165
        tmp = have_rr(ce, tp);
        }
#line 2165
        if (tmp) {
#line 2166
          ret = name;
#line 2167
          goto while_break;
        }
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 2172
  unlock_cache_r();
  }
#line 2174
  return (ret);
}
}
#line 2184 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/cache.c"
dns_cent_t *lookup_cache(unsigned char const   *name , int *wild ) 
{ 
  int purge ;
  dns_cent_t *ret ;
  unsigned char const   *nm ;
  unsigned int lb ;
  unsigned char buf[256] ;
  unsigned char const   *nm___0 ;
  unsigned int lb___0 ;
  unsigned char buf___0[256] ;
  int tmp ;

  {
  {
#line 2186
  purge = 0;
#line 2190
  lock_cache_r();
#line 2191
  ret = dns_lookup(name, (dns_hash_loc_t *)((void *)0));
  }
#line 2192
  if (wild) {
#line 2193
    *wild = 0;
#line 2194
    if (! ret) {
#line 2195
      nm = name;
#line 2196
      lb = (unsigned int )*nm;
#line 2197
      if (lb) {
        {
#line 2198
        while (1) {
          while_continue: /* CIL Label */ ;
#line 2198
          nm += lb + 1U;
#line 2198
          lb = (unsigned int )*nm;
#line 2198
          if (! lb) {
#line 2198
            goto while_break;
          }
          {
#line 2199
          ret = dns_lookup(nm, (dns_hash_loc_t *)((void *)0));
          }
#line 2199
          if (ret) {
#line 2200
            if ((int )ret->flags & 1) {
#line 2202
              *wild = 2;
            } else
#line 2203
            if ((int )ret->flags & 16) {
              {
#line 2205
              buf[0] = (unsigned char)1;
#line 2205
              buf[1] = (unsigned char )'*';
#line 2210
              rhncpy(& buf[2], nm);
#line 2211
              ret = dns_lookup((unsigned char const   *)(buf), (dns_hash_loc_t *)((void *)0));
              }
#line 2212
              if (ret) {
#line 2213
                *wild = 1;
              }
            } else
#line 2215
            if ((int )ret->flags & 2) {
#line 2216
              *wild = 3;
            } else {
#line 2218
              ret = (dns_cent_t *)((void *)0);
            }
#line 2219
            goto while_break;
          }
        }
        while_break: /* CIL Label */ ;
        }
      }
    }
  }
#line 2225
  if (ret) {
    {
#line 2226
    purge = purge_cent(ret, 1, 1);
    }
#line 2226
    if (! purge) {
      {
#line 2227
      ret = copy_cent(ret);
      }
    }
  }
  {
#line 2229
  unlock_cache_r();
  }
#line 2231
  if (purge) {
    {
#line 2233
    lock_cache_rw();
#line 2234
    ret = dns_lookup(name, (dns_hash_loc_t *)((void *)0));
    }
#line 2235
    if (wild) {
#line 2236
      *wild = 0;
#line 2237
      if (! ret) {
#line 2238
        nm___0 = name;
#line 2239
        lb___0 = (unsigned int )*nm___0;
#line 2240
        if (lb___0) {
          {
#line 2241
          while (1) {
            while_continue___0: /* CIL Label */ ;
#line 2241
            nm___0 += lb___0 + 1U;
#line 2241
            lb___0 = (unsigned int )*nm___0;
#line 2241
            if (! lb___0) {
#line 2241
              goto while_break___0;
            }
            {
#line 2242
            ret = dns_lookup(nm___0, (dns_hash_loc_t *)((void *)0));
            }
#line 2242
            if (ret) {
#line 2243
              if ((int )ret->flags & 1) {
#line 2245
                *wild = 2;
              } else
#line 2246
              if ((int )ret->flags & 16) {
                {
#line 2248
                buf___0[0] = (unsigned char)1;
#line 2248
                buf___0[1] = (unsigned char )'*';
#line 2249
                rhncpy(& buf___0[2], nm___0);
#line 2250
                ret = dns_lookup((unsigned char const   *)(buf___0), (dns_hash_loc_t *)((void *)0));
                }
#line 2251
                if (ret) {
#line 2252
                  *wild = 1;
                }
              } else
#line 2254
              if ((int )ret->flags & 2) {
#line 2255
                *wild = 3;
              } else {
#line 2257
                ret = (dns_cent_t *)((void *)0);
              }
#line 2258
              goto while_break___0;
            }
          }
          while_break___0: /* CIL Label */ ;
          }
        }
      }
    }
#line 2264
    if (ret) {
      {
#line 2265
      tmp = purge_cent(ret, 1, 0);
      }
#line 2265
      if (tmp < 0) {
#line 2266
        ret = (dns_cent_t *)((void *)0);
      } else {
        {
#line 2268
        ret = copy_cent(ret);
        }
      }
    }
    {
#line 2270
    unlock_cache_rw();
    }
  }
#line 2273
  return (ret);
}
}
#line 2282 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/cache.c"
rr_set_t *lookup_cache_local_rrset(unsigned char const   *name , int type ) 
{ 
  rr_set_t *ret ;
  dns_cent_t *cent ;
  rr_set_t *rrset ;
  rr_set_t *tmp ;

  {
  {
#line 2284
  ret = (rr_set_t *)((void *)0);
#line 2287
  lock_cache_r();
#line 2288
  cent = dns_lookup(name, (dns_hash_loc_t *)((void *)0));
  }
#line 2289
  if (cent) {
    {
#line 2290
    tmp = getrrset(cent, type);
#line 2290
    rrset = tmp;
    }
#line 2291
    if (rrset) {
#line 2291
      if ((int )rrset->flags & 2) {
        {
#line 2292
        ret = copy_rrset(rrset);
        }
      }
    }
  }
  {
#line 2295
  unlock_cache_r();
  }
#line 2297
  return (ret);
}
}
#line 2369 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/cache.c"
int report_cache_stat(int f ) 
{ 
  long mc ;
  int _retval ;
  int _retval___0 ;
  int _retval___1 ;

  {
  {
#line 2371
  mc = global.perm_cache * 1024L + 10240L;
#line 2372
  _retval = fsprintf(f, "\nCache status:\n=============\n");
  }
#line 2372
  if (_retval < 0) {
#line 2372
    return (_retval);
  }
  {
#line 2373
  _retval___0 = fsprintf(f, "%ld kB maximum disk cache size.\n", global.perm_cache);
  }
#line 2373
  if (_retval___0 < 0) {
#line 2373
    return (_retval___0);
  }
  {
#line 2374
  _retval___1 = fsprintf(f, "%ld of %ld bytes (%.3g%%) memory cache used in %ld entries (avg %.5g bytes/entry).\n",
                         cache_size, mc, ((double )cache_size / (double )mc) * (double )100,
                         ent_num, (double )cache_size / (double )ent_num);
  }
#line 2374
  if (_retval___1 < 0) {
#line 2374
    return (_retval___1);
  }
#line 2378
  return (0);
}
}
#line 2395 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/cache.c"
static int dump_cent(int fd , dns_cent_t *cent ) 
{ 
  time_t now ;
  char tstr[sizeof("2000/12/31 23:59:59")] ;
  char dbuf[1024] ;
  int _retval ;
  unsigned char const   *tmp ;
  struct tm tstm ;
  struct tm *tmp___0 ;
  char const   *tmp___1 ;
  size_t tmp___2 ;
  int _retval___0 ;
  int i ;
  int n ;
  int tmp___3 ;
  int tmp___4 ;
  unsigned short const   *iterlist ;
  unsigned short const   *tmp___5 ;
  unsigned short const   *tmp___6 ;
  int tp ;
  rr_set_t *rrset ;
  rr_set_t *tmp___7 ;
  struct tm tstm___0 ;
  struct tm *tmp___8 ;
  char const   *tmp___9 ;
  size_t tmp___10 ;
  int _retval___1 ;
  rr_bucket_t *rr ;
  unsigned char *p ;
  int n___0 ;
  size_t tmp___11 ;
  int tmp___12 ;
  unsigned char *tmp___13 ;
  unsigned char *p___0 ;
  unsigned int pref ;
  int n___1 ;
  register uint16_t t_s ;
  register unsigned char const   *t_cp ;
  unsigned char const   *tmp___14 ;
  unsigned char const   *tmp___15 ;
  unsigned char *p___1 ;
  char *q ;
  int n___2 ;
  int rem ;
  uint32_t serial ;
  uint32_t refresh ;
  uint32_t retry ;
  uint32_t expire ;
  uint32_t minimum ;
  size_t tmp___16 ;
  int tmp___17 ;
  size_t tmp___18 ;
  int tmp___19 ;
  register uint32_t t_l ;
  register unsigned char const   *t_cp___0 ;
  unsigned char const   *tmp___20 ;
  unsigned char const   *tmp___21 ;
  unsigned char const   *tmp___22 ;
  unsigned char const   *tmp___23 ;
  register uint32_t t_l___0 ;
  register unsigned char const   *t_cp___1 ;
  unsigned char const   *tmp___24 ;
  unsigned char const   *tmp___25 ;
  unsigned char const   *tmp___26 ;
  unsigned char const   *tmp___27 ;
  register uint32_t t_l___1 ;
  register unsigned char const   *t_cp___2 ;
  unsigned char const   *tmp___28 ;
  unsigned char const   *tmp___29 ;
  unsigned char const   *tmp___30 ;
  unsigned char const   *tmp___31 ;
  register uint32_t t_l___2 ;
  register unsigned char const   *t_cp___3 ;
  unsigned char const   *tmp___32 ;
  unsigned char const   *tmp___33 ;
  unsigned char const   *tmp___34 ;
  unsigned char const   *tmp___35 ;
  register uint32_t t_l___3 ;
  register unsigned char const   *t_cp___4 ;
  unsigned char const   *tmp___36 ;
  unsigned char const   *tmp___37 ;
  unsigned char const   *tmp___38 ;
  unsigned char const   *tmp___39 ;
  unsigned char *p___2 ;
  char *q___0 ;
  int j ;
  int n___3 ;
  int rem___0 ;
  unsigned int lb ;
  char *tmp___40 ;
  char *tmp___41 ;
  unsigned char *tmp___42 ;
  char *tmp___43 ;
  unsigned char *p___3 ;
  char *q___1 ;
  unsigned int pref___0 ;
  int n___4 ;
  int rem___1 ;
  register uint16_t t_s___0 ;
  register unsigned char const   *t_cp___5 ;
  unsigned char const   *tmp___44 ;
  unsigned char const   *tmp___45 ;
  size_t tmp___46 ;
  int tmp___47 ;
  unsigned char *tmp___48 ;
  unsigned char *p___4 ;
  unsigned int priority ;
  unsigned int weight ;
  unsigned int port ;
  int n___5 ;
  register uint16_t t_s___1 ;
  register unsigned char const   *t_cp___6 ;
  unsigned char const   *tmp___49 ;
  unsigned char const   *tmp___50 ;
  register uint16_t t_s___2 ;
  register unsigned char const   *t_cp___7 ;
  unsigned char const   *tmp___51 ;
  unsigned char const   *tmp___52 ;
  register uint16_t t_s___3 ;
  register unsigned char const   *t_cp___8 ;
  unsigned char const   *tmp___53 ;
  unsigned char const   *tmp___54 ;
  unsigned char *p___5 ;
  int n___6 ;
  int rlen ;
  size_t tmp___55 ;
  int tmp___56 ;
  unsigned int tmp___57 ;
  unsigned char *p___6 ;
  char *q___2 ;
  unsigned int order ;
  unsigned int pref___1 ;
  int n___7 ;
  int rem___2 ;
  int j___0 ;
  register uint16_t t_s___4 ;
  register unsigned char const   *t_cp___9 ;
  unsigned char const   *tmp___58 ;
  unsigned char const   *tmp___59 ;
  register uint16_t t_s___5 ;
  register unsigned char const   *t_cp___10 ;
  unsigned char const   *tmp___60 ;
  unsigned char const   *tmp___61 ;
  unsigned int lb___0 ;
  char *tmp___62 ;
  unsigned char *tmp___63 ;
  char *tmp___64 ;
  char *tmp___65 ;
  char const   *tmp___66 ;
  char const   *tmp___67 ;
  char const   *tmp___68 ;
  int _retval___2 ;
  int _retval___3 ;

  {
  {
#line 2400
  tmp = rhn2str((unsigned char const   *)cent->qname, (unsigned char *)(dbuf), (unsigned int )sizeof(dbuf));
#line 2400
  _retval = fsprintf(fd, "%s\n", tmp);
  }
#line 2400
  if (_retval < 0) {
#line 2400
    return (_retval);
  }
  {
#line 2401
  now = time((time_t *)((void *)0));
  }
#line 2403
  if ((int )cent->flags & 1) {
#line 2404
    if (cent->__annonCompField2.neg.ts) {
      {
#line 2404
      tmp___0 = localtime_r((time_t const   */* __restrict  */)(& cent->__annonCompField2.neg.ts),
                            (struct tm */* __restrict  */)(& tstm));
      }
#line 2404
      if (tmp___0) {
#line 2404
        if (cent->__annonCompField2.neg.ts <= now) {
#line 2404
          if (now - cent->__annonCompField2.neg.ts < 15768000L) {
#line 2404
            tmp___1 = "    %m/%d %T";
          } else {
#line 2404
            tmp___1 = "%Y/%m/%d %T";
          }
        } else {
#line 2404
          tmp___1 = "%Y/%m/%d %T";
        }
        {
#line 2404
        tmp___2 = strftime((char */* __restrict  */)(tstr), sizeof(tstr), (char const   */* __restrict  */)tmp___1,
                           (struct tm  const  */* __restrict  */)(& tstm));
        }
#line 2404
        if (! (tmp___2 > 0UL)) {
          {
#line 2404
          strcpy((char */* __restrict  */)(tstr), (char const   */* __restrict  */)"                  ");
          }
        }
      } else {
        {
#line 2404
        strcpy((char */* __restrict  */)(tstr), (char const   */* __restrict  */)"                  ");
        }
      }
    } else {
      {
#line 2404
      strcpy((char */* __restrict  */)(tstr), (char const   */* __restrict  */)"                  ");
      }
    }
    {
#line 2405
    _retval___0 = fsprintf(fd, "%s    (domain negated)\n", tstr);
    }
#line 2405
    if (_retval___0 < 0) {
#line 2405
      return (_retval___0);
    }
  } else {
#line 2408
    if ((int )cent->flags & 1) {
#line 2408
      tmp___4 = 0;
    } else {
#line 2408
      if (cent->__annonCompField2.rr.rrext) {
#line 2408
        tmp___3 = 47;
      } else {
#line 2408
        tmp___3 = 8;
      }
#line 2408
      tmp___4 = tmp___3;
    }
#line 2408
    n = tmp___4;
#line 2409
    if ((int )cent->flags & 1) {
#line 2409
      tmp___6 = (unsigned short const   *)((void *)0);
    } else {
#line 2409
      if (cent->__annonCompField2.rr.rrext) {
#line 2409
        tmp___5 = rrcachiterlist;
      } else {
#line 2409
        tmp___5 = rrmuiterlist;
      }
#line 2409
      tmp___6 = tmp___5;
    }
#line 2409
    iterlist = tmp___6;
#line 2410
    i = 0;
    {
#line 2410
    while (1) {
      while_continue: /* CIL Label */ ;
#line 2410
      if (! (i < n)) {
#line 2410
        goto while_break;
      }
      {
#line 2411
      tp = (int )*(iterlist + i);
#line 2412
      tmp___7 = getrrset_eff(cent, tp);
#line 2412
      rrset = tmp___7;
      }
#line 2413
      if (rrset) {
#line 2414
        if (rrset->ts) {
          {
#line 2414
          tmp___8 = localtime_r((time_t const   */* __restrict  */)(& rrset->ts),
                                (struct tm */* __restrict  */)(& tstm___0));
          }
#line 2414
          if (tmp___8) {
#line 2414
            if (rrset->ts <= now) {
#line 2414
              if (now - rrset->ts < 15768000L) {
#line 2414
                tmp___9 = "    %m/%d %T";
              } else {
#line 2414
                tmp___9 = "%Y/%m/%d %T";
              }
            } else {
#line 2414
              tmp___9 = "%Y/%m/%d %T";
            }
            {
#line 2414
            tmp___10 = strftime((char */* __restrict  */)(tstr), sizeof(tstr), (char const   */* __restrict  */)tmp___9,
                                (struct tm  const  */* __restrict  */)(& tstm___0));
            }
#line 2414
            if (! (tmp___10 > 0UL)) {
              {
#line 2414
              strcpy((char */* __restrict  */)(tstr), (char const   */* __restrict  */)"                  ");
              }
            }
          } else {
            {
#line 2414
            strcpy((char */* __restrict  */)(tstr), (char const   */* __restrict  */)"                  ");
            }
          }
        } else {
          {
#line 2414
          strcpy((char */* __restrict  */)(tstr), (char const   */* __restrict  */)"                  ");
          }
        }
#line 2415
        if ((int )rrset->flags & 1) {
          {
#line 2416
          _retval___1 = fsprintf(fd, "%s    %-7s (negated)\n", tstr, rrnames[tp - 1]);
          }
#line 2416
          if (_retval___1 < 0) {
#line 2416
            return (_retval___1);
          }
        } else {
#line 2420
          rr = rrset->rrs;
          {
#line 2420
          while (1) {
            while_continue___0: /* CIL Label */ ;
#line 2420
            if (! rr) {
#line 2420
              goto while_break___0;
            }
            {
#line 2429
            if (tp == 12) {
#line 2429
              goto case_12;
            }
#line 2429
            if (tp == 2) {
#line 2429
              goto case_12;
            }
#line 2429
            if (tp == 9) {
#line 2429
              goto case_12;
            }
#line 2429
            if (tp == 8) {
#line 2429
              goto case_12;
            }
#line 2429
            if (tp == 4) {
#line 2429
              goto case_12;
            }
#line 2429
            if (tp == 3) {
#line 2429
              goto case_12;
            }
#line 2429
            if (tp == 7) {
#line 2429
              goto case_12;
            }
#line 2429
            if (tp == 5) {
#line 2429
              goto case_12;
            }
#line 2437
            if (tp == 17) {
#line 2437
              goto case_17;
            }
#line 2437
            if (tp == 14) {
#line 2437
              goto case_17;
            }
#line 2459
            if (tp == 36) {
#line 2459
              goto case_36;
            }
#line 2459
            if (tp == 21) {
#line 2459
              goto case_36;
            }
#line 2459
            if (tp == 18) {
#line 2459
              goto case_36;
            }
#line 2459
            if (tp == 15) {
#line 2459
              goto case_36;
            }
#line 2471
            if (tp == 6) {
#line 2471
              goto case_6;
            }
#line 2511
            if (tp == 16) {
#line 2511
              goto case_16;
            }
#line 2511
            if (tp == 13) {
#line 2511
              goto case_16;
            }
#line 2549
            if (tp == 26) {
#line 2549
              goto case_26;
            }
#line 2570
            if (tp == 33) {
#line 2570
              goto case_33;
            }
#line 2585
            if (tp == 30) {
#line 2585
              goto case_30;
            }
#line 2600
            if (tp == 35) {
#line 2600
              goto case_35;
            }
#line 2633
            if (tp == 29) {
#line 2633
              goto case_29;
            }
#line 2641
            if (tp == 1) {
#line 2641
              goto case_1;
            }
#line 2646
            if (tp == 28) {
#line 2646
              goto case_28;
            }
#line 2651
            goto hex_dump;
            case_12: /* CIL Label */ 
            case_2: /* CIL Label */ 
            case_9: /* CIL Label */ 
            case_8: /* CIL Label */ 
            case_4: /* CIL Label */ 
            case_3: /* CIL Label */ 
            case_7: /* CIL Label */ 
            case_5: /* CIL Label */ 
            {
#line 2430
            rhn2str((unsigned char const   *)((unsigned char *)(rr->data)), (unsigned char *)(dbuf),
                    (unsigned int )sizeof(dbuf));
            }
#line 2431
            goto switch_break;
            case_17: /* CIL Label */ 
            case_14: /* CIL Label */ 
            {
#line 2440
            p = (unsigned char *)(rr->data);
#line 2442
            rhn2str((unsigned char const   *)p, (unsigned char *)(dbuf), (unsigned int )sizeof(dbuf));
#line 2443
            tmp___11 = strlen((char const   *)(dbuf));
#line 2443
            n___0 = (int )tmp___11;
#line 2444
            tmp___12 = n___0;
#line 2444
            n___0 ++;
#line 2444
            dbuf[tmp___12] = (char )' ';
            }
#line 2445
            if ((unsigned long )n___0 >= sizeof(dbuf)) {
#line 2446
              goto hex_dump;
            }
            {
#line 2447
            tmp___13 = skiprhn(p);
#line 2447
            rhn2str((unsigned char const   *)tmp___13, (unsigned char *)(dbuf) + n___0,
                    (unsigned int )(sizeof(dbuf) - (unsigned long )n___0));
            }
#line 2449
            goto switch_break;
            case_36: /* CIL Label */ 
            case_21: /* CIL Label */ 
            case_18: /* CIL Label */ 
            case_15: /* CIL Label */ 
#line 2462
            p___0 = (unsigned char *)(rr->data);
            {
#line 2465
            while (1) {
              while_continue___1: /* CIL Label */ ;
#line 2465
              t_cp = (unsigned char const   *)p___0;
#line 2465
              tmp___14 = t_cp;
#line 2465
              t_cp ++;
#line 2465
              t_s = (uint16_t )((int )((uint16_t )*tmp___14) << 8);
#line 2465
              tmp___15 = t_cp;
#line 2465
              t_cp ++;
#line 2465
              t_s = (uint16_t )((int )t_s | (int )((uint16_t )*tmp___15));
#line 2465
              pref = (unsigned int )t_s;
#line 2465
              p___0 = (unsigned char *)((void *)t_cp);
#line 2465
              goto while_break___1;
            }
            while_break___1: /* CIL Label */ ;
            }
            {
#line 2466
            n___1 = sprintf((char */* __restrict  */)(dbuf), (char const   */* __restrict  */)"%u ",
                            pref);
            }
#line 2467
            if (n___1 < 0) {
#line 2467
              goto hex_dump;
            }
            {
#line 2468
            rhn2str((unsigned char const   *)p___0, (unsigned char *)(dbuf) + n___1,
                    (unsigned int )(sizeof(dbuf) - (unsigned long )n___1));
            }
#line 2470
            goto switch_break;
            case_6: /* CIL Label */ 
            {
#line 2473
            p___1 = (unsigned char *)(rr->data);
#line 2477
            rhn2str((unsigned char const   *)p___1, (unsigned char *)(dbuf), (unsigned int )sizeof(dbuf));
#line 2478
            tmp___16 = strlen((char const   *)(dbuf));
#line 2478
            n___2 = (int )tmp___16;
#line 2479
            tmp___17 = n___2;
#line 2479
            n___2 ++;
#line 2479
            dbuf[tmp___17] = (char )' ';
            }
#line 2480
            if ((unsigned long )n___2 >= sizeof(dbuf)) {
#line 2481
              goto hex_dump;
            }
            {
#line 2482
            q = dbuf + n___2;
#line 2483
            rem = (int )(sizeof(dbuf) - (unsigned long )n___2);
#line 2484
            p___1 = skiprhn(p___1);
#line 2485
            rhn2str((unsigned char const   *)p___1, (unsigned char *)q, (unsigned int )rem);
#line 2486
            tmp___18 = strlen((char const   *)q);
#line 2486
            n___2 = (int )tmp___18;
#line 2487
            tmp___19 = n___2;
#line 2487
            n___2 ++;
#line 2487
            *(q + tmp___19) = (char )' ';
            }
#line 2488
            if (n___2 >= rem) {
#line 2489
              goto hex_dump;
            }
            {
#line 2490
            q += n___2;
#line 2491
            rem -= n___2;
#line 2492
            p___1 = skiprhn(p___1);
            }
            {
#line 2493
            while (1) {
              while_continue___2: /* CIL Label */ ;
#line 2493
              t_cp___0 = (unsigned char const   *)p___1;
#line 2493
              tmp___20 = t_cp___0;
#line 2493
              t_cp___0 ++;
#line 2493
              t_l = (uint32_t )*tmp___20 << 24;
#line 2493
              tmp___21 = t_cp___0;
#line 2493
              t_cp___0 ++;
#line 2493
              t_l |= (uint32_t )*tmp___21 << 16;
#line 2493
              tmp___22 = t_cp___0;
#line 2493
              t_cp___0 ++;
#line 2493
              t_l |= (uint32_t )*tmp___22 << 8;
#line 2493
              tmp___23 = t_cp___0;
#line 2493
              t_cp___0 ++;
#line 2493
              t_l |= (uint32_t )*tmp___23;
#line 2493
              serial = t_l;
#line 2493
              p___1 = (unsigned char *)((void *)t_cp___0);
#line 2493
              goto while_break___2;
            }
            while_break___2: /* CIL Label */ ;
            }
            {
#line 2494
            while (1) {
              while_continue___3: /* CIL Label */ ;
#line 2494
              t_cp___1 = (unsigned char const   *)p___1;
#line 2494
              tmp___24 = t_cp___1;
#line 2494
              t_cp___1 ++;
#line 2494
              t_l___0 = (uint32_t )*tmp___24 << 24;
#line 2494
              tmp___25 = t_cp___1;
#line 2494
              t_cp___1 ++;
#line 2494
              t_l___0 |= (uint32_t )*tmp___25 << 16;
#line 2494
              tmp___26 = t_cp___1;
#line 2494
              t_cp___1 ++;
#line 2494
              t_l___0 |= (uint32_t )*tmp___26 << 8;
#line 2494
              tmp___27 = t_cp___1;
#line 2494
              t_cp___1 ++;
#line 2494
              t_l___0 |= (uint32_t )*tmp___27;
#line 2494
              refresh = t_l___0;
#line 2494
              p___1 = (unsigned char *)((void *)t_cp___1);
#line 2494
              goto while_break___3;
            }
            while_break___3: /* CIL Label */ ;
            }
            {
#line 2495
            while (1) {
              while_continue___4: /* CIL Label */ ;
#line 2495
              t_cp___2 = (unsigned char const   *)p___1;
#line 2495
              tmp___28 = t_cp___2;
#line 2495
              t_cp___2 ++;
#line 2495
              t_l___1 = (uint32_t )*tmp___28 << 24;
#line 2495
              tmp___29 = t_cp___2;
#line 2495
              t_cp___2 ++;
#line 2495
              t_l___1 |= (uint32_t )*tmp___29 << 16;
#line 2495
              tmp___30 = t_cp___2;
#line 2495
              t_cp___2 ++;
#line 2495
              t_l___1 |= (uint32_t )*tmp___30 << 8;
#line 2495
              tmp___31 = t_cp___2;
#line 2495
              t_cp___2 ++;
#line 2495
              t_l___1 |= (uint32_t )*tmp___31;
#line 2495
              retry = t_l___1;
#line 2495
              p___1 = (unsigned char *)((void *)t_cp___2);
#line 2495
              goto while_break___4;
            }
            while_break___4: /* CIL Label */ ;
            }
            {
#line 2496
            while (1) {
              while_continue___5: /* CIL Label */ ;
#line 2496
              t_cp___3 = (unsigned char const   *)p___1;
#line 2496
              tmp___32 = t_cp___3;
#line 2496
              t_cp___3 ++;
#line 2496
              t_l___2 = (uint32_t )*tmp___32 << 24;
#line 2496
              tmp___33 = t_cp___3;
#line 2496
              t_cp___3 ++;
#line 2496
              t_l___2 |= (uint32_t )*tmp___33 << 16;
#line 2496
              tmp___34 = t_cp___3;
#line 2496
              t_cp___3 ++;
#line 2496
              t_l___2 |= (uint32_t )*tmp___34 << 8;
#line 2496
              tmp___35 = t_cp___3;
#line 2496
              t_cp___3 ++;
#line 2496
              t_l___2 |= (uint32_t )*tmp___35;
#line 2496
              expire = t_l___2;
#line 2496
              p___1 = (unsigned char *)((void *)t_cp___3);
#line 2496
              goto while_break___5;
            }
            while_break___5: /* CIL Label */ ;
            }
            {
#line 2497
            while (1) {
              while_continue___6: /* CIL Label */ ;
#line 2497
              t_cp___4 = (unsigned char const   *)p___1;
#line 2497
              tmp___36 = t_cp___4;
#line 2497
              t_cp___4 ++;
#line 2497
              t_l___3 = (uint32_t )*tmp___36 << 24;
#line 2497
              tmp___37 = t_cp___4;
#line 2497
              t_cp___4 ++;
#line 2497
              t_l___3 |= (uint32_t )*tmp___37 << 16;
#line 2497
              tmp___38 = t_cp___4;
#line 2497
              t_cp___4 ++;
#line 2497
              t_l___3 |= (uint32_t )*tmp___38 << 8;
#line 2497
              tmp___39 = t_cp___4;
#line 2497
              t_cp___4 ++;
#line 2497
              t_l___3 |= (uint32_t )*tmp___39;
#line 2497
              minimum = t_l___3;
#line 2497
              p___1 = (unsigned char *)((void *)t_cp___4);
#line 2497
              goto while_break___6;
            }
            while_break___6: /* CIL Label */ ;
            }
            {
#line 2498
            n___2 = snprintf((char */* __restrict  */)q, (size_t )rem, (char const   */* __restrict  */)"%lu %lu %lu %lu %lu",
                             (unsigned long )serial, (unsigned long )refresh, (unsigned long )retry,
                             (unsigned long )expire, (unsigned long )minimum);
            }
#line 2502
            if (n___2 < 0) {
#line 2503
              goto hex_dump;
            } else
#line 2502
            if (n___2 >= rem) {
#line 2503
              goto hex_dump;
            }
#line 2505
            goto switch_break;
            case_16: /* CIL Label */ 
            case_13: /* CIL Label */ 
#line 2520
            p___2 = (unsigned char *)(rr->data);
#line 2521
            q___0 = dbuf;
#line 2522
            j = 0;
#line 2522
            rem___0 = (int )sizeof(dbuf);
            {
#line 2523
            while (1) {
              while_continue___7: /* CIL Label */ ;
#line 2523
              if (! ((unsigned int )j < rr->rdlen)) {
#line 2523
                goto while_break___7;
              }
#line 2525
              if (rem___0 < 3) {
#line 2526
                goto hex_dump;
              }
#line 2527
              if (j) {
#line 2528
                tmp___40 = q___0;
#line 2528
                q___0 ++;
#line 2528
                *tmp___40 = (char )' ';
#line 2529
                rem___0 --;
              }
#line 2531
              tmp___41 = q___0;
#line 2531
              q___0 ++;
#line 2531
              *tmp___41 = (char )'\"';
#line 2532
              rem___0 --;
#line 2533
              tmp___42 = p___2;
#line 2533
              p___2 ++;
#line 2533
              lb = (unsigned int )*tmp___42;
#line 2534
              j = (int )((unsigned int )j + (lb + 1U));
#line 2534
              if ((unsigned int )j > rr->rdlen) {
#line 2535
                goto hex_dump;
              }
              {
#line 2536
              n___3 = escapestr((char const   *)((char *)p___2), (int )lb, q___0,
                                rem___0);
              }
#line 2537
              if (n___3 < 0) {
#line 2538
                goto hex_dump;
              } else
#line 2537
              if (n___3 + 1 >= rem___0) {
#line 2538
                goto hex_dump;
              }
#line 2539
              q___0 += n___3;
#line 2540
              tmp___43 = q___0;
#line 2540
              q___0 ++;
#line 2540
              *tmp___43 = (char )'\"';
#line 2541
              rem___0 -= n___3 + 1;
#line 2542
              p___2 += lb;
            }
            while_break___7: /* CIL Label */ ;
            }
#line 2544
            *q___0 = (char)0;
#line 2546
            goto switch_break;
            case_26: /* CIL Label */ 
#line 2551
            p___3 = (unsigned char *)(rr->data);
            {
#line 2555
            while (1) {
              while_continue___8: /* CIL Label */ ;
#line 2555
              t_cp___5 = (unsigned char const   *)p___3;
#line 2555
              tmp___44 = t_cp___5;
#line 2555
              t_cp___5 ++;
#line 2555
              t_s___0 = (uint16_t )((int )((uint16_t )*tmp___44) << 8);
#line 2555
              tmp___45 = t_cp___5;
#line 2555
              t_cp___5 ++;
#line 2555
              t_s___0 = (uint16_t )((int )t_s___0 | (int )((uint16_t )*tmp___45));
#line 2555
              pref___0 = (unsigned int )t_s___0;
#line 2555
              p___3 = (unsigned char *)((void *)t_cp___5);
#line 2555
              goto while_break___8;
            }
            while_break___8: /* CIL Label */ ;
            }
            {
#line 2556
            n___4 = sprintf((char */* __restrict  */)(dbuf), (char const   */* __restrict  */)"%u ",
                            pref___0);
            }
#line 2557
            if (n___4 < 0) {
#line 2557
              goto hex_dump;
            }
            {
#line 2558
            q___1 = dbuf + n___4;
#line 2559
            rem___1 = (int )(sizeof(dbuf) - (unsigned long )n___4);
#line 2560
            rhn2str((unsigned char const   *)p___3, (unsigned char *)q___1, (unsigned int )rem___1);
#line 2561
            tmp___46 = strlen((char const   *)q___1);
#line 2561
            n___4 = (int )tmp___46;
#line 2562
            tmp___47 = n___4;
#line 2562
            n___4 ++;
#line 2562
            *(q___1 + tmp___47) = (char )' ';
            }
#line 2563
            if (n___4 >= rem___1) {
#line 2564
              goto hex_dump;
            }
            {
#line 2565
            tmp___48 = skiprhn(p___3);
#line 2565
            rhn2str((unsigned char const   *)tmp___48, (unsigned char *)q___1 + n___4,
                    (unsigned int )(rem___1 - n___4));
            }
#line 2567
            goto switch_break;
            case_33: /* CIL Label */ 
#line 2572
            p___4 = (unsigned char *)(rr->data);
            {
#line 2575
            while (1) {
              while_continue___9: /* CIL Label */ ;
#line 2575
              t_cp___6 = (unsigned char const   *)p___4;
#line 2575
              tmp___49 = t_cp___6;
#line 2575
              t_cp___6 ++;
#line 2575
              t_s___1 = (uint16_t )((int )((uint16_t )*tmp___49) << 8);
#line 2575
              tmp___50 = t_cp___6;
#line 2575
              t_cp___6 ++;
#line 2575
              t_s___1 = (uint16_t )((int )t_s___1 | (int )((uint16_t )*tmp___50));
#line 2575
              priority = (unsigned int )t_s___1;
#line 2575
              p___4 = (unsigned char *)((void *)t_cp___6);
#line 2575
              goto while_break___9;
            }
            while_break___9: /* CIL Label */ ;
            }
            {
#line 2576
            while (1) {
              while_continue___10: /* CIL Label */ ;
#line 2576
              t_cp___7 = (unsigned char const   *)p___4;
#line 2576
              tmp___51 = t_cp___7;
#line 2576
              t_cp___7 ++;
#line 2576
              t_s___2 = (uint16_t )((int )((uint16_t )*tmp___51) << 8);
#line 2576
              tmp___52 = t_cp___7;
#line 2576
              t_cp___7 ++;
#line 2576
              t_s___2 = (uint16_t )((int )t_s___2 | (int )((uint16_t )*tmp___52));
#line 2576
              weight = (unsigned int )t_s___2;
#line 2576
              p___4 = (unsigned char *)((void *)t_cp___7);
#line 2576
              goto while_break___10;
            }
            while_break___10: /* CIL Label */ ;
            }
            {
#line 2577
            while (1) {
              while_continue___11: /* CIL Label */ ;
#line 2577
              t_cp___8 = (unsigned char const   *)p___4;
#line 2577
              tmp___53 = t_cp___8;
#line 2577
              t_cp___8 ++;
#line 2577
              t_s___3 = (uint16_t )((int )((uint16_t )*tmp___53) << 8);
#line 2577
              tmp___54 = t_cp___8;
#line 2577
              t_cp___8 ++;
#line 2577
              t_s___3 = (uint16_t )((int )t_s___3 | (int )((uint16_t )*tmp___54));
#line 2577
              port = (unsigned int )t_s___3;
#line 2577
              p___4 = (unsigned char *)((void *)t_cp___8);
#line 2577
              goto while_break___11;
            }
            while_break___11: /* CIL Label */ ;
            }
            {
#line 2578
            n___5 = sprintf((char */* __restrict  */)(dbuf), (char const   */* __restrict  */)"%u %u %u ",
                            priority, weight, port);
            }
#line 2579
            if (n___5 < 0) {
#line 2579
              goto hex_dump;
            }
            {
#line 2580
            rhn2str((unsigned char const   *)p___4, (unsigned char *)(dbuf) + n___5,
                    (unsigned int )(sizeof(dbuf) - (unsigned long )n___5));
            }
#line 2582
            goto switch_break;
            case_30: /* CIL Label */ 
            {
#line 2587
            p___5 = (unsigned char *)(rr->data);
#line 2589
            rhn2str((unsigned char const   *)p___5, (unsigned char *)(dbuf), (unsigned int )sizeof(dbuf));
#line 2590
            tmp___55 = strlen((char const   *)(dbuf));
#line 2590
            n___6 = (int )tmp___55;
#line 2591
            tmp___56 = n___6;
#line 2591
            n___6 ++;
#line 2591
            dbuf[tmp___56] = (char )' ';
            }
#line 2592
            if ((unsigned long )n___6 >= sizeof(dbuf)) {
#line 2593
              goto hex_dump;
            }
            {
#line 2594
            tmp___57 = rhnlen((unsigned char const   *)p___5);
#line 2594
            rlen = (int )tmp___57;
#line 2595
            hexdump((void const   *)(p___5 + rlen), (int )(rr->rdlen - (unsigned int )rlen),
                    dbuf + n___6, (int )(sizeof(dbuf) - (unsigned long )n___6));
            }
#line 2597
            goto switch_break;
            case_35: /* CIL Label */ 
#line 2602
            p___6 = (unsigned char *)(rr->data);
            {
#line 2606
            while (1) {
              while_continue___12: /* CIL Label */ ;
#line 2606
              t_cp___9 = (unsigned char const   *)p___6;
#line 2606
              tmp___58 = t_cp___9;
#line 2606
              t_cp___9 ++;
#line 2606
              t_s___4 = (uint16_t )((int )((uint16_t )*tmp___58) << 8);
#line 2606
              tmp___59 = t_cp___9;
#line 2606
              t_cp___9 ++;
#line 2606
              t_s___4 = (uint16_t )((int )t_s___4 | (int )((uint16_t )*tmp___59));
#line 2606
              order = (unsigned int )t_s___4;
#line 2606
              p___6 = (unsigned char *)((void *)t_cp___9);
#line 2606
              goto while_break___12;
            }
            while_break___12: /* CIL Label */ ;
            }
            {
#line 2607
            while (1) {
              while_continue___13: /* CIL Label */ ;
#line 2607
              t_cp___10 = (unsigned char const   *)p___6;
#line 2607
              tmp___60 = t_cp___10;
#line 2607
              t_cp___10 ++;
#line 2607
              t_s___5 = (uint16_t )((int )((uint16_t )*tmp___60) << 8);
#line 2607
              tmp___61 = t_cp___10;
#line 2607
              t_cp___10 ++;
#line 2607
              t_s___5 = (uint16_t )((int )t_s___5 | (int )((uint16_t )*tmp___61));
#line 2607
              pref___1 = (unsigned int )t_s___5;
#line 2607
              p___6 = (unsigned char *)((void *)t_cp___10);
#line 2607
              goto while_break___13;
            }
            while_break___13: /* CIL Label */ ;
            }
            {
#line 2608
            n___7 = sprintf((char */* __restrict  */)(dbuf), (char const   */* __restrict  */)"%u %u ",
                            order, pref___1);
            }
#line 2609
            if (n___7 < 0) {
#line 2609
              goto hex_dump;
            }
#line 2610
            q___2 = dbuf + n___7;
#line 2611
            rem___2 = (int )(sizeof(dbuf) - (unsigned long )n___7);
#line 2612
            j___0 = 0;
            {
#line 2612
            while (1) {
              while_continue___14: /* CIL Label */ ;
#line 2612
              if (! (j___0 < 3)) {
#line 2612
                goto while_break___14;
              }
#line 2614
              if (rem___2 < 2) {
#line 2615
                goto hex_dump;
              }
              {
#line 2616
              tmp___62 = q___2;
#line 2616
              q___2 ++;
#line 2616
              *tmp___62 = (char )'\"';
#line 2617
              rem___2 --;
#line 2618
              tmp___63 = p___6;
#line 2618
              p___6 ++;
#line 2618
              lb___0 = (unsigned int )*tmp___63;
#line 2619
              n___7 = escapestr((char const   *)((char *)p___6), (int )lb___0, q___2,
                                rem___2);
              }
#line 2620
              if (n___7 < 0) {
#line 2621
                goto hex_dump;
              } else
#line 2620
              if (n___7 + 2 >= rem___2) {
#line 2621
                goto hex_dump;
              }
#line 2622
              q___2 += n___7;
#line 2623
              tmp___64 = q___2;
#line 2623
              q___2 ++;
#line 2623
              *tmp___64 = (char )'\"';
#line 2624
              tmp___65 = q___2;
#line 2624
              q___2 ++;
#line 2624
              *tmp___65 = (char )' ';
#line 2625
              rem___2 -= n___7 + 2;
#line 2626
              p___6 += lb___0;
#line 2612
              j___0 ++;
            }
            while_break___14: /* CIL Label */ ;
            }
            {
#line 2628
            rhn2str((unsigned char const   *)p___6, (unsigned char *)q___2, (unsigned int )rem___2);
            }
#line 2630
            goto switch_break;
            case_29: /* CIL Label */ 
#line 2635
            if (rr->rdlen != 16U) {
#line 2636
              goto hex_dump;
            }
            {
#line 2637
            tmp___66 = loc2str((void const   *)(rr->data), dbuf, sizeof(dbuf));
            }
#line 2637
            if (! tmp___66) {
#line 2638
              goto hex_dump;
            }
#line 2639
            goto switch_break;
            case_1: /* CIL Label */ 
            {
#line 2642
            tmp___67 = inet_ntop(2, (void const   */* __restrict  */)(rr->data), (char */* __restrict  */)(dbuf),
                                 (socklen_t )sizeof(dbuf));
            }
#line 2642
            if (! tmp___67) {
#line 2643
              goto hex_dump;
            }
#line 2644
            goto switch_break;
            case_28: /* CIL Label */ 
            {
#line 2647
            tmp___68 = inet_ntop(10, (void const   */* __restrict  */)(rr->data),
                                 (char */* __restrict  */)(dbuf), (socklen_t )sizeof(dbuf));
            }
#line 2647
            if (! tmp___68) {
#line 2648
              goto hex_dump;
            }
#line 2649
            goto switch_break;
            hex_dump: 
            switch_default: /* CIL Label */ 
            {
#line 2653
            hexdump((void const   *)(rr->data), (int )rr->rdlen, dbuf, (int )sizeof(dbuf));
            }
            switch_break: /* CIL Label */ ;
            }
            {
#line 2655
            _retval___2 = fsprintf(fd, "%s    %-7s %s\n", tstr, rrnames[tp - 1], dbuf);
            }
#line 2655
            if (_retval___2 < 0) {
#line 2655
              return (_retval___2);
            }
#line 2420
            rr = rr->next;
          }
          while_break___0: /* CIL Label */ ;
          }
        }
      }
#line 2410
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 2661
  _retval___3 = fsprintf(fd, "\n");
  }
#line 2661
  if (_retval___3 < 0) {
#line 2661
    return (_retval___3);
  }
#line 2662
  return (1);
}
}
#line 2671 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/cache.c"
int dump_cache(int fd , unsigned char const   *name , int exact ) 
{ 
  int rv ;
  dns_cent_t *cent ;
  dns_cent_t *tmp ;
  dns_cent_t *cent___0 ;
  dns_hash_pos_t pos ;
  unsigned int nrem ;

  {
  {
#line 2673
  rv = 0;
#line 2674
  lock_cache_r();
  }
#line 2675
  if (name) {
#line 2675
    if (exact) {
      {
#line 2676
      tmp = dns_lookup(name, (dns_hash_loc_t *)((void *)0));
#line 2676
      cent = tmp;
      }
#line 2677
      if (cent) {
        {
#line 2678
        rv = dump_cent(fd, cent);
        }
      }
    } else {
#line 2675
      goto _L___0;
    }
  } else {
    _L___0: /* CIL Label */ 
    {
#line 2683
    cent___0 = fetch_first(& pos);
    }
    {
#line 2683
    while (1) {
      while_continue: /* CIL Label */ ;
#line 2683
      if (! cent___0) {
#line 2683
        goto while_break;
      }
#line 2685
      if (! name) {
#line 2685
        goto _L;
      } else {
        {
#line 2685
        domain_match(name, (unsigned char const   *)cent___0->qname, & nrem, (unsigned int *)((void *)0));
        }
#line 2685
        if (nrem == 0U) {
          _L: /* CIL Label */ 
          {
#line 2686
          rv = dump_cent(fd, cent___0);
          }
#line 2686
          if (rv < 0) {
#line 2687
            goto while_break;
          }
        }
      }
      {
#line 2683
      cent___0 = fetch_next(& pos);
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 2690
  unlock_cache_r();
  }
#line 2691
  return (rv);
}
}
#line 2698 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/cache.c"
char const   cflgnames[21]  = 
#line 2698
  {      (char const   )'N',      (char const   )'E',      (char const   )'G',      (char const   )'L', 
        (char const   )'O',      (char const   )'C',      (char const   )'A',      (char const   )'U', 
        (char const   )'T',      (char const   )'N',      (char const   )'O',      (char const   )'C', 
        (char const   )'A',      (char const   )'D',      (char const   )'D',      (char const   )'N', 
        (char const   )'O',      (char const   )'P',      (char const   )'R',      (char const   )'T', 
        (char const   )'S'};
#line 2699 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/cache.c"
char const   dflgnames[15]  = 
#line 2699
  {      (char const   )'N',      (char const   )'E',      (char const   )'G',      (char const   )'L', 
        (char const   )'O',      (char const   )'C',      (char const   )'A',      (char const   )'U', 
        (char const   )'T',      (char const   )'N',      (char const   )'O',      (char const   )'C', 
        (char const   )'W',      (char const   )'L',      (char const   )'D'};
#line 2701 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/cache.c"
char *flags2str(unsigned int flags , char *buf , int nflags , char const   *flgnames ) 
{ 
  char *p ;
  int i ;
  int nflgchars ;
  char *tmp ;
  void *tmp___0 ;
  char *tmp___1 ;

  {
#line 2703
  p = buf;
#line 2704
  nflgchars = 3 * nflags;
#line 2705
  i = 0;
  {
#line 2705
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2705
    if (! (i < nflgchars)) {
#line 2705
      goto while_break;
    }
#line 2706
    if (flags & 1U) {
#line 2707
      if ((unsigned long )p > (unsigned long )buf) {
#line 2707
        tmp = p;
#line 2707
        p ++;
#line 2707
        *tmp = (char )'|';
      }
      {
#line 2708
      tmp___0 = mempcpy((void */* __restrict  */)p, (void const   */* __restrict  */)(flgnames + i),
                        (size_t )3);
#line 2708
      p = (char *)tmp___0;
      }
    }
#line 2710
    flags >>= 1;
#line 2705
    i += 3;
  }
  while_break: /* CIL Label */ ;
  }
#line 2712
  if ((unsigned long )p == (unsigned long )buf) {
#line 2713
    tmp___1 = p;
#line 2713
    p ++;
#line 2713
    *tmp___1 = (char )'0';
  }
#line 2714
  *p = (char)0;
#line 2715
  return (buf);
}
}
#line 111 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/rr_types.h"
unsigned short const   rrlkuptab[51]  = 
#line 111 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/rr_types.h"
  {      (unsigned short const   )0,      (unsigned short const   )1,      (unsigned short const   )8,      (unsigned short const   )9, 
        (unsigned short const   )2,      (unsigned short const   )3,      (unsigned short const   )10,      (unsigned short const   )11, 
        (unsigned short const   )12,      (unsigned short const   )13,      (unsigned short const   )14,      (unsigned short const   )4, 
        (unsigned short const   )15,      (unsigned short const   )16,      (unsigned short const   )5,      (unsigned short const   )6, 
        (unsigned short const   )17,      (unsigned short const   )18,      (unsigned short const   )19,      (unsigned short const   )20, 
        (unsigned short const   )21,      (unsigned short const   )22,      (unsigned short const   )23,      (unsigned short const   )24, 
        (unsigned short const   )25,      (unsigned short const   )26,      (unsigned short const   )27,      (unsigned short const   )7, 
        (unsigned short const   )28,      (unsigned short const   )29,      (unsigned short const   )30,      (unsigned short const   )31, 
        (unsigned short const   )32,      (unsigned short const   )33,      (unsigned short const   )34,      (unsigned short const   )35, 
        (unsigned short const   )36,      (unsigned short const   )47,      (unsigned short const   )48,      (unsigned short const   )49, 
        (unsigned short const   )50,      (unsigned short const   )37,      (unsigned short const   )38,      (unsigned short const   )39, 
        (unsigned short const   )40,      (unsigned short const   )41,      (unsigned short const   )42,      (unsigned short const   )43, 
        (unsigned short const   )44,      (unsigned short const   )45,      (unsigned short const   )46};
#line 169 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/rr_types.h"
unsigned short const   rrmuiterlist[8]  = 
#line 169
  {      (unsigned short const   )1,      (unsigned short const   )2,      (unsigned short const   )5,      (unsigned short const   )6, 
        (unsigned short const   )12,      (unsigned short const   )15,      (unsigned short const   )16,      (unsigned short const   )28};
#line 482 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/rr_types.h"
struct rr_infos  const  rr_info[47]  = 
#line 482
  {      {(unsigned short)2, (unsigned short)9}, 
        {(unsigned short)4, (unsigned short)0}, 
        {(unsigned short)1, (unsigned short)10}, 
        {(unsigned short)4, (unsigned short)0}, 
        {(unsigned short)8, (unsigned short)3}, 
        {(unsigned short)4, (unsigned short)0}, 
        {(unsigned short)4, (unsigned short)0}, 
        {(unsigned short)2, (unsigned short)9}, 
        {(unsigned short)4, (unsigned short)0}, 
        {(unsigned short)4, (unsigned short)0}, 
        {(unsigned short)4, (unsigned short)0}, 
        {(unsigned short)4, (unsigned short)0}, 
        {(unsigned short)4, (unsigned short)0}, 
        {(unsigned short)4, (unsigned short)0}, 
        {(unsigned short)2, (unsigned short)9}, 
        {(unsigned short)2, (unsigned short)9}, 
        {(unsigned short)4, (unsigned short)0}, 
        {(unsigned short)2, (unsigned short)9}, 
        {(unsigned short)2, (unsigned short)9}, 
        {(unsigned short)2, (unsigned short)9}, 
        {(unsigned short)2, (unsigned short)9}, 
        {(unsigned short)2, (unsigned short)9}, 
        {(unsigned short)2, (unsigned short)9}, 
        {(unsigned short)8, (unsigned short)3}, 
        {(unsigned short)4, (unsigned short)0}, 
        {(unsigned short)4, (unsigned short)0}, 
        {(unsigned short)4, (unsigned short)0}, 
        {(unsigned short)2, (unsigned short)9}, 
        {(unsigned short)2, (unsigned short)9}, 
        {(unsigned short)4, (unsigned short)0}, 
        {(unsigned short)2, (unsigned short)9}, 
        {(unsigned short)2, (unsigned short)9}, 
        {(unsigned short)2, (unsigned short)9}, 
        {(unsigned short)2, (unsigned short)9}, 
        {(unsigned short)2, (unsigned short)9}, 
        {(unsigned short)2, (unsigned short)9}, 
        {(unsigned short)2, (unsigned short)9}, 
        {(unsigned short)4, (unsigned short)0}, 
        {(unsigned short)4, (unsigned short)0}, 
        {(unsigned short)4, (unsigned short)0}, 
        {(unsigned short)4, (unsigned short)0}, 
        {(unsigned short)4, (unsigned short)0}, 
        {(unsigned short)4, (unsigned short)0}, 
        {(unsigned short)4, (unsigned short)0}, 
        {(unsigned short)4, (unsigned short)0}, 
        {(unsigned short)4, (unsigned short)0}, 
        {(unsigned short)4, (unsigned short)0}};
#line 53 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/rr_types.c"
static unsigned int const   poweroften[8]  = 
#line 53 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/rr_types.c"
  {      (unsigned int const   )1,      (unsigned int const   )10,      (unsigned int const   )100,      (unsigned int const   )1000, 
        (unsigned int const   )10000,      (unsigned int const   )100000,      (unsigned int const   )1000000,      (unsigned int const   )10000000};
#line 60 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/rr_types.c"
static char const   *precsize_ntoa(uint8_t prec , char *retbuf ) 
{ 
  unsigned int mantissa ;
  unsigned int exponent ;

  {
#line 64
  mantissa = (unsigned int )((int )prec >> 4);
#line 65
  exponent = (unsigned int )((int )prec & 15);
#line 67
  if (mantissa >= 10U) {
#line 68
    return ((char const   *)((void *)0));
  } else
#line 67
  if (exponent >= 10U) {
#line 68
    return ((char const   *)((void *)0));
  }
#line 69
  if (exponent >= 2U) {
    {
#line 70
    sprintf((char */* __restrict  */)retbuf, (char const   */* __restrict  */)"%u",
            mantissa * (unsigned int )poweroften[exponent - 2U]);
    }
  } else {
    {
#line 72
    sprintf((char */* __restrict  */)retbuf, (char const   */* __restrict  */)"0.%.2u",
            mantissa * (unsigned int )poweroften[exponent]);
    }
  }
#line 73
  return ((char const   *)retbuf);
}
}
#line 80 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/rr_types.c"
char const   *loc2str(void const   *binary , char *ascii , size_t asclen ) 
{ 
  unsigned char const   *cp ;
  int latdeg ;
  int latmin ;
  int latsec ;
  int latsecfrac ;
  int longdeg ;
  int longmin ;
  int longsec ;
  int longsecfrac ;
  char northsouth ;
  char eastwest ;
  char const   *altsign ;
  int altmeters ;
  int altfrac ;
  uint32_t referencealt ;
  int32_t latval ;
  int32_t longval ;
  int32_t altval ;
  uint32_t templ ;
  uint8_t sizeval ;
  uint8_t hpval ;
  uint8_t vpval ;
  uint8_t versionval ;
  char sizestr[sizeof("90000000")] ;
  char hpstr[sizeof("90000000")] ;
  char vpstr[sizeof("90000000")] ;
  unsigned char const   *tmp ;
  unsigned char const   *tmp___0 ;
  unsigned char const   *tmp___1 ;
  unsigned char const   *tmp___2 ;
  register uint32_t t_l ;
  register unsigned char const   *t_cp ;
  unsigned char const   *tmp___3 ;
  unsigned char const   *tmp___4 ;
  unsigned char const   *tmp___5 ;
  unsigned char const   *tmp___6 ;
  register uint32_t t_l___0 ;
  register unsigned char const   *t_cp___0 ;
  unsigned char const   *tmp___7 ;
  unsigned char const   *tmp___8 ;
  unsigned char const   *tmp___9 ;
  unsigned char const   *tmp___10 ;
  register uint32_t t_l___1 ;
  register unsigned char const   *t_cp___1 ;
  unsigned char const   *tmp___11 ;
  unsigned char const   *tmp___12 ;
  unsigned char const   *tmp___13 ;
  unsigned char const   *tmp___14 ;
  char const   *tmp___15 ;
  char const   *tmp___16 ;
  char const   *tmp___17 ;
  int n ;
  int tmp___18 ;

  {
#line 82
  cp = (unsigned char const   *)binary;
#line 90
  referencealt = (uint32_t )10000000;
#line 98
  tmp = cp;
#line 98
  cp ++;
#line 98
  versionval = (uint8_t )*tmp;
#line 100
  if (versionval) {
#line 102
    return ((char const   *)((void *)0));
  }
#line 105
  tmp___0 = cp;
#line 105
  cp ++;
#line 105
  sizeval = (uint8_t )*tmp___0;
#line 107
  tmp___1 = cp;
#line 107
  cp ++;
#line 107
  hpval = (uint8_t )*tmp___1;
#line 108
  tmp___2 = cp;
#line 108
  cp ++;
#line 108
  vpval = (uint8_t )*tmp___2;
  {
#line 110
  while (1) {
    while_continue: /* CIL Label */ ;
#line 110
    t_cp = cp;
#line 110
    tmp___3 = t_cp;
#line 110
    t_cp ++;
#line 110
    t_l = (uint32_t )*tmp___3 << 24;
#line 110
    tmp___4 = t_cp;
#line 110
    t_cp ++;
#line 110
    t_l |= (uint32_t )*tmp___4 << 16;
#line 110
    tmp___5 = t_cp;
#line 110
    t_cp ++;
#line 110
    t_l |= (uint32_t )*tmp___5 << 8;
#line 110
    tmp___6 = t_cp;
#line 110
    t_cp ++;
#line 110
    t_l |= (uint32_t )*tmp___6;
#line 110
    templ = t_l;
#line 110
    cp = (unsigned char const   *)((void *)t_cp);
#line 110
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 111
  latval = (int32_t )(templ - (1U << 31));
  {
#line 113
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 113
    t_cp___0 = cp;
#line 113
    tmp___7 = t_cp___0;
#line 113
    t_cp___0 ++;
#line 113
    t_l___0 = (uint32_t )*tmp___7 << 24;
#line 113
    tmp___8 = t_cp___0;
#line 113
    t_cp___0 ++;
#line 113
    t_l___0 |= (uint32_t )*tmp___8 << 16;
#line 113
    tmp___9 = t_cp___0;
#line 113
    t_cp___0 ++;
#line 113
    t_l___0 |= (uint32_t )*tmp___9 << 8;
#line 113
    tmp___10 = t_cp___0;
#line 113
    t_cp___0 ++;
#line 113
    t_l___0 |= (uint32_t )*tmp___10;
#line 113
    templ = t_l___0;
#line 113
    cp = (unsigned char const   *)((void *)t_cp___0);
#line 113
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 114
  longval = (int32_t )(templ - (1U << 31));
  {
#line 116
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 116
    t_cp___1 = cp;
#line 116
    tmp___11 = t_cp___1;
#line 116
    t_cp___1 ++;
#line 116
    t_l___1 = (uint32_t )*tmp___11 << 24;
#line 116
    tmp___12 = t_cp___1;
#line 116
    t_cp___1 ++;
#line 116
    t_l___1 |= (uint32_t )*tmp___12 << 16;
#line 116
    tmp___13 = t_cp___1;
#line 116
    t_cp___1 ++;
#line 116
    t_l___1 |= (uint32_t )*tmp___13 << 8;
#line 116
    tmp___14 = t_cp___1;
#line 116
    t_cp___1 ++;
#line 116
    t_l___1 |= (uint32_t )*tmp___14;
#line 116
    templ = t_l___1;
#line 116
    cp = (unsigned char const   *)((void *)t_cp___1);
#line 116
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 117
  if (templ < referencealt) {
#line 118
    altval = (int32_t )(referencealt - templ);
#line 119
    altsign = "-";
  } else {
#line 121
    altval = (int32_t )(templ - referencealt);
#line 122
    altsign = "";
  }
#line 125
  if (latval < 0) {
#line 126
    northsouth = (char )'S';
#line 127
    latval = - latval;
  } else {
#line 129
    northsouth = (char )'N';
  }
#line 131
  latsecfrac = latval % 1000;
#line 132
  latval /= 1000;
#line 133
  latsec = latval % 60;
#line 134
  latval /= 60;
#line 135
  latmin = latval % 60;
#line 136
  latval /= 60;
#line 137
  latdeg = latval;
#line 139
  if (longval < 0) {
#line 140
    eastwest = (char )'W';
#line 141
    longval = - longval;
  } else {
#line 143
    eastwest = (char )'E';
  }
  {
#line 145
  longsecfrac = longval % 1000;
#line 146
  longval /= 1000;
#line 147
  longsec = longval % 60;
#line 148
  longval /= 60;
#line 149
  longmin = longval % 60;
#line 150
  longval /= 60;
#line 151
  longdeg = longval;
#line 153
  altfrac = altval % 100;
#line 154
  altmeters = altval / 100;
#line 156
  tmp___15 = precsize_ntoa(sizeval, sizestr);
  }
#line 156
  if (tmp___15) {
    {
#line 156
    tmp___16 = precsize_ntoa(hpval, hpstr);
    }
#line 156
    if (tmp___16) {
      {
#line 156
      tmp___17 = precsize_ntoa(vpval, vpstr);
      }
#line 156
      if (! tmp___17) {
#line 157
        return ((char const   *)((void *)0));
      }
    } else {
#line 157
      return ((char const   *)((void *)0));
    }
  } else {
#line 157
    return ((char const   *)((void *)0));
  }
  {
#line 159
  tmp___18 = snprintf((char */* __restrict  */)ascii, asclen, (char const   */* __restrict  */)"%d %.2d %.2d.%.3d %c %d %.2d %.2d.%.3d %c %s%d.%.2dm %sm %sm %sm",
                      latdeg, latmin, latsec, latsecfrac, (int )northsouth, longdeg,
                      longmin, longsec, longsecfrac, (int )eastwest, altsign, altmeters,
                      altfrac, sizestr, hpstr, vpstr);
#line 159
  n = tmp___18;
  }
#line 165
  if (n < 0) {
#line 166
    return ((char const   *)((void *)0));
  } else
#line 165
  if ((size_t )n >= asclen) {
#line 166
    return ((char const   *)((void *)0));
  }
#line 169
  return ((char const   *)ascii);
}
}
#line 215 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) sigemptyset)(sigset_t *__set ) ;
#line 221
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) sigaddset)(sigset_t *__set ,
                                                                                                int __signo ) ;
#line 259
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) sigaction)(int __sig ,
                                                                                struct sigaction  const  * __restrict  __act ,
                                                                                struct sigaction * __restrict  __oact ) ;
#line 270
extern int ( __attribute__((__nonnull__(1,2))) sigwait)(sigset_t const   * __restrict  __set ,
                                                        int * __restrict  __sig ) ;
#line 30 "/usr/include/x86_64-linux-gnu/bits/sigthread.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) pthread_sigmask)(int __how ,
                                                                                      __sigset_t const   * __restrict  __newmask ,
                                                                                      __sigset_t * __restrict  __oldmask ) ;
#line 497 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) chdir)(char const   *__path ) ;
#line 534
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) dup2)(int __fd ,
                                                                           int __fd2 ) ;
#line 603
extern  __attribute__((__noreturn__)) void _exit(int __status ) ;
#line 667
extern  __attribute__((__nothrow__)) __pid_t ( __attribute__((__leaf__)) setsid)(void) ;
#line 675
extern  __attribute__((__nothrow__)) __uid_t ( __attribute__((__leaf__)) getuid)(void) ;
#line 756
extern  __attribute__((__nothrow__)) __pid_t fork(void) ;
#line 146 "/usr/include/fcntl.h"
extern int ( __attribute__((__nonnull__(1))) open)(char const   *__file , int __oflag 
                                                   , ...) ;
#line 57 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/list.h"
__inline static unsigned int ( __attribute__((__always_inline__)) da_nel)(darray a ) ;
#line 298 "/usr/include/pthread.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) pthread_attr_init)(pthread_attr_t *__attr ) ;
#line 310
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) pthread_attr_setdetachstate)(pthread_attr_t *__attr ,
                                                                                                                  int __detachstate ) ;
#line 1122
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) pthread_key_create)(pthread_key_t *__key ,
                                                                                                         void (*__destr_function)(void * ) ) ;
#line 47 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/conff.h"
uid_t init_uid  ;
#line 156 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/cache.h"
__inline static void ( __attribute__((__always_inline__)) init_cache_lock)(void) ;
#line 157 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/cache.h"
__inline static void ( __attribute__((__always_inline__)) init_cache_lock)(void) 
{ 


  {
#line 159
  use_cache_lock = (short volatile   )1;
#line 160
  return;
}
}
#line 37 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/servers.h"
int start_servstat_thread(void) ;
#line 30 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/dns_answer.h"
pthread_t statsock_thrid  ;
#line 30 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/dns_answer.h"
pthread_t tcps_thrid  ;
#line 30 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/dns_answer.h"
pthread_t udps_thrid  ;
#line 31
int volatile   tcp_socket ;
#line 32
int volatile   udp_socket ;
#line 35
int init_udp_socket(void) ;
#line 36
int init_tcp_socket(void) ;
#line 37
void start_dns_servers(void) ;
#line 32 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/thread.h"
sigset_t sigs_msk  ;
#line 44 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/error.h"
__inline static void ( __attribute__((__always_inline__)) init_log_lock)(void) ;
#line 45 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/error.h"
__inline static void ( __attribute__((__always_inline__)) init_log_lock)(void) 
{ 


  {
#line 47
  use_log_lock = (short volatile   )1;
#line 48
  return;
}
}
#line 46 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/hash.h"
dns_hash_ent_t *hash_buckets[1 << 10] ;
#line 60
__inline static void ( __attribute__((__always_inline__)) mk_dns_hash)(void) ;
#line 61 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/hash.h"
__inline static void ( __attribute__((__always_inline__)) mk_dns_hash)(void) 
{ 
  int i ;

  {
#line 64
  i = 0;
  {
#line 64
  while (1) {
    while_continue: /* CIL Label */ ;
#line 64
    if (! (i < 1 << 10)) {
#line 64
      goto while_break;
    }
#line 65
    hash_buckets[i] = (dns_hash_ent_t *)((void *)0);
#line 64
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 66
  return;
}
}
#line 54 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/main.c"
short stat_pipe  =    (short)0;
#line 61 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/main.c"
cmdlineflags_t cmdline  = 
#line 61
     {(char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0};
#line 65 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/main.c"
FILE *dbg_file  =    (FILE *)((void *)0);
#line 67 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/main.c"
int volatile   tcp_socket  =    (int volatile   )-1;
#line 68 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/main.c"
int volatile   udp_socket  =    (int volatile   )-1;
#line 70 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/main.c"
char *conf_file  =    (char *)"/usr/local/etc/pdnsd.conf";
#line 74 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/main.c"
static char const   info_message[778]  = 
#line 74
  {      (char const   )'p',      (char const   )'d',      (char const   )'n',      (char const   )'s', 
        (char const   )'d',      (char const   )' ',      (char const   )'-',      (char const   )' ', 
        (char const   )'d',      (char const   )'n',      (char const   )'s',      (char const   )' ', 
        (char const   )'p',      (char const   )'r',      (char const   )'o',      (char const   )'x', 
        (char const   )'y',      (char const   )' ',      (char const   )'d',      (char const   )'a', 
        (char const   )'e',      (char const   )'m',      (char const   )'o',      (char const   )'n', 
        (char const   )',',      (char const   )' ',      (char const   )'v',      (char const   )'e', 
        (char const   )'r',      (char const   )'s',      (char const   )'i',      (char const   )'o', 
        (char const   )'n',      (char const   )' ',      (char const   )'1',      (char const   )'.', 
        (char const   )'2',      (char const   )'.',      (char const   )'9',      (char const   )'a', 
        (char const   )'-',      (char const   )'p',      (char const   )'a',      (char const   )'r', 
        (char const   )'\n',      (char const   )'\n',      (char const   )'C',      (char const   )'o', 
        (char const   )'p',      (char const   )'y',      (char const   )'r',      (char const   )'i', 
        (char const   )'g',      (char const   )'h',      (char const   )'t',      (char const   )' ', 
        (char const   )'(',      (char const   )'C',      (char const   )')',      (char const   )' ', 
        (char const   )'2',      (char const   )'0',      (char const   )'0',      (char const   )'0', 
        (char const   )',',      (char const   )' ',      (char const   )'2',      (char const   )'0', 
        (char const   )'0',      (char const   )'1',      (char const   )' ',      (char const   )'T', 
        (char const   )'h',      (char const   )'o',      (char const   )'m',      (char const   )'a', 
        (char const   )'s',      (char const   )' ',      (char const   )'M',      (char const   )'o', 
        (char const   )'e',      (char const   )'s',      (char const   )'t',      (char const   )'l', 
        (char const   )'\n',      (char const   )'C',      (char const   )'o',      (char const   )'p', 
        (char const   )'y',      (char const   )'r',      (char const   )'i',      (char const   )'g', 
        (char const   )'h',      (char const   )'t',      (char const   )' ',      (char const   )'(', 
        (char const   )'C',      (char const   )')',      (char const   )' ',      (char const   )'2', 
        (char const   )'0',      (char const   )'0',      (char const   )'2',      (char const   )',', 
        (char const   )' ',      (char const   )'2',      (char const   )'0',      (char const   )'0', 
        (char const   )'3',      (char const   )',',      (char const   )' ',      (char const   )'2', 
        (char const   )'0',      (char const   )'0',      (char const   )'4',      (char const   )',', 
        (char const   )' ',      (char const   )'2',      (char const   )'0',      (char const   )'0', 
        (char const   )'5',      (char const   )',',      (char const   )' ',      (char const   )'2', 
        (char const   )'0',      (char const   )'0',      (char const   )'6',      (char const   )',', 
        (char const   )' ',      (char const   )'2',      (char const   )'0',      (char const   )'0', 
        (char const   )'7',      (char const   )',',      (char const   )' ',      (char const   )'2', 
        (char const   )'0',      (char const   )'0',      (char const   )'8',      (char const   )',', 
        (char const   )' ',      (char const   )'2',      (char const   )'0',      (char const   )'1', 
        (char const   )'0',      (char const   )' ',      (char const   )'P',      (char const   )'a', 
        (char const   )'u',      (char const   )'l',      (char const   )' ',      (char const   )'A', 
        (char const   )'.',      (char const   )' ',      (char const   )'R',      (char const   )'o', 
        (char const   )'m',      (char const   )'b',      (char const   )'o',      (char const   )'u', 
        (char const   )'t',      (char const   )'s',      (char const   )'\n',      (char const   )'\n', 
        (char const   )'p',      (char const   )'d',      (char const   )'n',      (char const   )'s', 
        (char const   )'d',      (char const   )' ',      (char const   )'i',      (char const   )'s', 
        (char const   )' ',      (char const   )'f',      (char const   )'r',      (char const   )'e', 
        (char const   )'e',      (char const   )' ',      (char const   )'s',      (char const   )'o', 
        (char const   )'f',      (char const   )'t',      (char const   )'w',      (char const   )'a', 
        (char const   )'r',      (char const   )'e',      (char const   )';',      (char const   )' ', 
        (char const   )'y',      (char const   )'o',      (char const   )'u',      (char const   )' ', 
        (char const   )'c',      (char const   )'a',      (char const   )'n',      (char const   )' ', 
        (char const   )'r',      (char const   )'e',      (char const   )'d',      (char const   )'i', 
        (char const   )'s',      (char const   )'t',      (char const   )'r',      (char const   )'i', 
        (char const   )'b',      (char const   )'u',      (char const   )'t',      (char const   )'e', 
        (char const   )' ',      (char const   )'i',      (char const   )'t',      (char const   )' ', 
        (char const   )'a',      (char const   )'n',      (char const   )'d',      (char const   )'/', 
        (char const   )'o',      (char const   )'r',      (char const   )' ',      (char const   )'m', 
        (char const   )'o',      (char const   )'d',      (char const   )'i',      (char const   )'f', 
        (char const   )'y',      (char const   )'\n',      (char const   )'i',      (char const   )'t', 
        (char const   )' ',      (char const   )'u',      (char const   )'n',      (char const   )'d', 
        (char const   )'e',      (char const   )'r',      (char const   )' ',      (char const   )'t', 
        (char const   )'h',      (char const   )'e',      (char const   )' ',      (char const   )'t', 
        (char const   )'e',      (char const   )'r',      (char const   )'m',      (char const   )'s', 
        (char const   )' ',      (char const   )'o',      (char const   )'f',      (char const   )' ', 
        (char const   )'t',      (char const   )'h',      (char const   )'e',      (char const   )' ', 
        (char const   )'G',      (char const   )'N',      (char const   )'U',      (char const   )' ', 
        (char const   )'G',      (char const   )'e',      (char const   )'n',      (char const   )'e', 
        (char const   )'r',      (char const   )'a',      (char const   )'l',      (char const   )' ', 
        (char const   )'P',      (char const   )'u',      (char const   )'b',      (char const   )'l', 
        (char const   )'i',      (char const   )'c',      (char const   )' ',      (char const   )'L', 
        (char const   )'i',      (char const   )'c',      (char const   )'e',      (char const   )'n', 
        (char const   )'s',      (char const   )'e',      (char const   )' ',      (char const   )'a', 
        (char const   )'s',      (char const   )' ',      (char const   )'p',      (char const   )'u', 
        (char const   )'b',      (char const   )'l',      (char const   )'i',      (char const   )'s', 
        (char const   )'h',      (char const   )'e',      (char const   )'d',      (char const   )' ', 
        (char const   )'b',      (char const   )'y',      (char const   )'\n',      (char const   )'t', 
        (char const   )'h',      (char const   )'e',      (char const   )' ',      (char const   )'F', 
        (char const   )'r',      (char const   )'e',      (char const   )'e',      (char const   )' ', 
        (char const   )'S',      (char const   )'o',      (char const   )'f',      (char const   )'t', 
        (char const   )'w',      (char const   )'a',      (char const   )'r',      (char const   )'e', 
        (char const   )' ',      (char const   )'F',      (char const   )'o',      (char const   )'u', 
        (char const   )'n',      (char const   )'d',      (char const   )'a',      (char const   )'t', 
        (char const   )'i',      (char const   )'o',      (char const   )'n',      (char const   )';', 
        (char const   )' ',      (char const   )'e',      (char const   )'i',      (char const   )'t', 
        (char const   )'h',      (char const   )'e',      (char const   )'r',      (char const   )' ', 
        (char const   )'v',      (char const   )'e',      (char const   )'r',      (char const   )'s', 
        (char const   )'i',      (char const   )'o',      (char const   )'n',      (char const   )' ', 
        (char const   )'3',      (char const   )' ',      (char const   )'o',      (char const   )'f', 
        (char const   )' ',      (char const   )'t',      (char const   )'h',      (char const   )'e', 
        (char const   )' ',      (char const   )'L',      (char const   )'i',      (char const   )'c', 
        (char const   )'e',      (char const   )'n',      (char const   )'s',      (char const   )'e', 
        (char const   )',',      (char const   )' ',      (char const   )'o',      (char const   )'r', 
        (char const   )'\n',      (char const   )'(',      (char const   )'a',      (char const   )'t', 
        (char const   )' ',      (char const   )'y',      (char const   )'o',      (char const   )'u', 
        (char const   )'r',      (char const   )' ',      (char const   )'o',      (char const   )'p', 
        (char const   )'t',      (char const   )'i',      (char const   )'o',      (char const   )'n', 
        (char const   )')',      (char const   )' ',      (char const   )'a',      (char const   )'n', 
        (char const   )'y',      (char const   )' ',      (char const   )'l',      (char const   )'a', 
        (char const   )'t',      (char const   )'e',      (char const   )'r',      (char const   )' ', 
        (char const   )'v',      (char const   )'e',      (char const   )'r',      (char const   )'s', 
        (char const   )'i',      (char const   )'o',      (char const   )'n',      (char const   )'.', 
        (char const   )'\n',      (char const   )'\n',      (char const   )'p',      (char const   )'d', 
        (char const   )'n',      (char const   )'s',      (char const   )'d',      (char const   )' ', 
        (char const   )'i',      (char const   )'s',      (char const   )' ',      (char const   )'d', 
        (char const   )'i',      (char const   )'s',      (char const   )'t',      (char const   )'r', 
        (char const   )'i',      (char const   )'b',      (char const   )'u',      (char const   )'t', 
        (char const   )'e',      (char const   )'d',      (char const   )' ',      (char const   )'i', 
        (char const   )'n',      (char const   )' ',      (char const   )'t',      (char const   )'h', 
        (char const   )'e',      (char const   )' ',      (char const   )'h',      (char const   )'o', 
        (char const   )'p',      (char const   )'e',      (char const   )' ',      (char const   )'t', 
        (char const   )'h',      (char const   )'a',      (char const   )'t',      (char const   )' ', 
        (char const   )'i',      (char const   )'t',      (char const   )' ',      (char const   )'w', 
        (char const   )'i',      (char const   )'l',      (char const   )'l',      (char const   )' ', 
        (char const   )'b',      (char const   )'e',      (char const   )' ',      (char const   )'u', 
        (char const   )'s',      (char const   )'e',      (char const   )'f',      (char const   )'u', 
        (char const   )'l',      (char const   )',',      (char const   )'\n',      (char const   )'b', 
        (char const   )'u',      (char const   )'t',      (char const   )' ',      (char const   )'W', 
        (char const   )'I',      (char const   )'T',      (char const   )'H',      (char const   )'O', 
        (char const   )'U',      (char const   )'T',      (char const   )' ',      (char const   )'A', 
        (char const   )'N',      (char const   )'Y',      (char const   )' ',      (char const   )'W', 
        (char const   )'A',      (char const   )'R',      (char const   )'R',      (char const   )'A', 
        (char const   )'N',      (char const   )'T',      (char const   )'Y',      (char const   )';', 
        (char const   )' ',      (char const   )'w',      (char const   )'i',      (char const   )'t', 
        (char const   )'h',      (char const   )'o',      (char const   )'u',      (char const   )'t', 
        (char const   )' ',      (char const   )'e',      (char const   )'v',      (char const   )'e', 
        (char const   )'n',      (char const   )' ',      (char const   )'t',      (char const   )'h', 
        (char const   )'e',      (char const   )' ',      (char const   )'i',      (char const   )'m', 
        (char const   )'p',      (char const   )'l',      (char const   )'i',      (char const   )'e', 
        (char const   )'d',      (char const   )' ',      (char const   )'w',      (char const   )'a', 
        (char const   )'r',      (char const   )'r',      (char const   )'a',      (char const   )'n', 
        (char const   )'t',      (char const   )'y',      (char const   )' ',      (char const   )'o', 
        (char const   )'f',      (char const   )'\n',      (char const   )'M',      (char const   )'E', 
        (char const   )'R',      (char const   )'C',      (char const   )'H',      (char const   )'A', 
        (char const   )'N',      (char const   )'T',      (char const   )'A',      (char const   )'B', 
        (char const   )'I',      (char const   )'L',      (char const   )'I',      (char const   )'T', 
        (char const   )'Y',      (char const   )' ',      (char const   )'o',      (char const   )'r', 
        (char const   )' ',      (char const   )'F',      (char const   )'I',      (char const   )'T', 
        (char const   )'N',      (char const   )'E',      (char const   )'S',      (char const   )'S', 
        (char const   )' ',      (char const   )'F',      (char const   )'O',      (char const   )'R', 
        (char const   )' ',      (char const   )'A',      (char const   )' ',      (char const   )'P', 
        (char const   )'A',      (char const   )'R',      (char const   )'T',      (char const   )'I', 
        (char const   )'C',      (char const   )'U',      (char const   )'L',      (char const   )'A', 
        (char const   )'R',      (char const   )' ',      (char const   )'P',      (char const   )'U', 
        (char const   )'R',      (char const   )'P',      (char const   )'O',      (char const   )'S', 
        (char const   )'E',      (char const   )'.',      (char const   )' ',      (char const   )' ', 
        (char const   )'S',      (char const   )'e',      (char const   )'e',      (char const   )' ', 
        (char const   )'t',      (char const   )'h',      (char const   )'e',      (char const   )'\n', 
        (char const   )'G',      (char const   )'N',      (char const   )'U',      (char const   )' ', 
        (char const   )'G',      (char const   )'e',      (char const   )'n',      (char const   )'e', 
        (char const   )'r',      (char const   )'a',      (char const   )'l',      (char const   )' ', 
        (char const   )'P',      (char const   )'u',      (char const   )'b',      (char const   )'l', 
        (char const   )'i',      (char const   )'c',      (char const   )' ',      (char const   )'L', 
        (char const   )'i',      (char const   )'c',      (char const   )'e',      (char const   )'n', 
        (char const   )'s',      (char const   )'e',      (char const   )' ',      (char const   )'f', 
        (char const   )'o',      (char const   )'r',      (char const   )' ',      (char const   )'m', 
        (char const   )'o',      (char const   )'r',      (char const   )'e',      (char const   )' ', 
        (char const   )'d',      (char const   )'e',      (char const   )'t',      (char const   )'a', 
        (char const   )'i',      (char const   )'l',      (char const   )'s',      (char const   )'.', 
        (char const   )'\n',      (char const   )'\n',      (char const   )'Y',      (char const   )'o', 
        (char const   )'u',      (char const   )' ',      (char const   )'s',      (char const   )'h', 
        (char const   )'o',      (char const   )'u',      (char const   )'l',      (char const   )'d', 
        (char const   )' ',      (char const   )'h',      (char const   )'a',      (char const   )'v', 
        (char const   )'e',      (char const   )' ',      (char const   )'r',      (char const   )'e', 
        (char const   )'c',      (char const   )'e',      (char const   )'i',      (char const   )'v', 
        (char const   )'e',      (char const   )'d',      (char const   )' ',      (char const   )'a', 
        (char const   )' ',      (char const   )'c',      (char const   )'o',      (char const   )'p', 
        (char const   )'y',      (char const   )' ',      (char const   )'o',      (char const   )'f', 
        (char const   )' ',      (char const   )'t',      (char const   )'h',      (char const   )'e', 
        (char const   )' ',      (char const   )'G',      (char const   )'N',      (char const   )'U', 
        (char const   )' ',      (char const   )'G',      (char const   )'e',      (char const   )'n', 
        (char const   )'e',      (char const   )'r',      (char const   )'a',      (char const   )'l', 
        (char const   )' ',      (char const   )'P',      (char const   )'u',      (char const   )'b', 
        (char const   )'l',      (char const   )'i',      (char const   )'c',      (char const   )' ', 
        (char const   )'L',      (char const   )'i',      (char const   )'c',      (char const   )'e', 
        (char const   )'n',      (char const   )'s',      (char const   )'e',      (char const   )'\n', 
        (char const   )'a',      (char const   )'l',      (char const   )'o',      (char const   )'n', 
        (char const   )'g',      (char const   )' ',      (char const   )'w',      (char const   )'i', 
        (char const   )'t',      (char const   )'h',      (char const   )' ',      (char const   )'p', 
        (char const   )'d',      (char const   )'s',      (char const   )'n',      (char const   )'d', 
        (char const   )';',      (char const   )' ',      (char const   )'s',      (char const   )'e', 
        (char const   )'e',      (char const   )' ',      (char const   )'t',      (char const   )'h', 
        (char const   )'e',      (char const   )' ',      (char const   )'f',      (char const   )'i', 
        (char const   )'l',      (char const   )'e',      (char const   )' ',      (char const   )'C', 
        (char const   )'O',      (char const   )'P',      (char const   )'Y',      (char const   )'I', 
        (char const   )'N',      (char const   )'G',      (char const   )'.',      (char const   )' ', 
        (char const   )' ',      (char const   )'I',      (char const   )'f',      (char const   )' ', 
        (char const   )'n',      (char const   )'o',      (char const   )'t',      (char const   )',', 
        (char const   )' ',      (char const   )'s',      (char const   )'e',      (char const   )'e', 
        (char const   )'\n',      (char const   )'<',      (char const   )'h',      (char const   )'t', 
        (char const   )'t',      (char const   )'p',      (char const   )':',      (char const   )'/', 
        (char const   )'/',      (char const   )'w',      (char const   )'w',      (char const   )'w', 
        (char const   )'.',      (char const   )'g',      (char const   )'n',      (char const   )'u', 
        (char const   )'.',      (char const   )'o',      (char const   )'r',      (char const   )'g', 
        (char const   )'/',      (char const   )'l',      (char const   )'i',      (char const   )'c', 
        (char const   )'e',      (char const   )'n',      (char const   )'s',      (char const   )'e', 
        (char const   )'s',      (char const   )'/',      (char const   )'>',      (char const   )'.', 
        (char const   )'\n',      (char const   )'\000'};
#line 93 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/main.c"
static char const   help_message[1382]  = 
#line 93
  {      (char const   )'\n',      (char const   )'\n',      (char const   )'U',      (char const   )'s', 
        (char const   )'a',      (char const   )'g',      (char const   )'e',      (char const   )':', 
        (char const   )' ',      (char const   )'p',      (char const   )'d',      (char const   )'n', 
        (char const   )'s',      (char const   )'d',      (char const   )' ',      (char const   )'[', 
        (char const   )'-',      (char const   )'h',      (char const   )']',      (char const   )' ', 
        (char const   )'[',      (char const   )'-',      (char const   )'V',      (char const   )']', 
        (char const   )' ',      (char const   )'[',      (char const   )'-',      (char const   )'s', 
        (char const   )']',      (char const   )' ',      (char const   )'[',      (char const   )'-', 
        (char const   )'d',      (char const   )']',      (char const   )' ',      (char const   )'[', 
        (char const   )'-',      (char const   )'g',      (char const   )']',      (char const   )' ', 
        (char const   )'[',      (char const   )'-',      (char const   )'t',      (char const   )']', 
        (char const   )' ',      (char const   )'[',      (char const   )'-',      (char const   )'p', 
        (char const   )' ',      (char const   )'f',      (char const   )'i',      (char const   )'l', 
        (char const   )'e',      (char const   )']',      (char const   )' ',      (char const   )'[', 
        (char const   )'-',      (char const   )'v',      (char const   )'n',      (char const   )']', 
        (char const   )' ',      (char const   )'[',      (char const   )'-',      (char const   )'m', 
        (char const   )'x',      (char const   )'x',      (char const   )']',      (char const   )' ', 
        (char const   )'[',      (char const   )'-',      (char const   )'c',      (char const   )' ', 
        (char const   )'f',      (char const   )'i',      (char const   )'l',      (char const   )'e', 
        (char const   )']',      (char const   )' ',      (char const   )'[',      (char const   )'-', 
        (char const   )'4',      (char const   )']',      (char const   )'\n',      (char const   )'\n', 
        (char const   )'O',      (char const   )'p',      (char const   )'t',      (char const   )'i', 
        (char const   )'o',      (char const   )'n',      (char const   )'s',      (char const   )':', 
        (char const   )'\n',      (char const   )'-',      (char const   )'h',      (char const   )'\t', 
        (char const   )'\t',      (char const   )'-',      (char const   )'-',      (char const   )'o', 
        (char const   )'r',      (char const   )'-',      (char const   )'-',      (char const   )'\n', 
        (char const   )'-',      (char const   )'-',      (char const   )'h',      (char const   )'e', 
        (char const   )'l',      (char const   )'p',      (char const   )'\t',      (char const   )'\t', 
        (char const   )'p',      (char const   )'r',      (char const   )'i',      (char const   )'n', 
        (char const   )'t',      (char const   )' ',      (char const   )'t',      (char const   )'h', 
        (char const   )'i',      (char const   )'s',      (char const   )' ',      (char const   )'h', 
        (char const   )'e',      (char const   )'l',      (char const   )'p',      (char const   )' ', 
        (char const   )'p',      (char const   )'a',      (char const   )'g',      (char const   )'e', 
        (char const   )' ',      (char const   )'a',      (char const   )'n',      (char const   )'d', 
        (char const   )' ',      (char const   )'e',      (char const   )'x',      (char const   )'i', 
        (char const   )'t',      (char const   )'.',      (char const   )'\n',      (char const   )'-', 
        (char const   )'V',      (char const   )'\t',      (char const   )'\t',      (char const   )'-', 
        (char const   )'-',      (char const   )'o',      (char const   )'r',      (char const   )'-', 
        (char const   )'-',      (char const   )'\n',      (char const   )'-',      (char const   )'-', 
        (char const   )'v',      (char const   )'e',      (char const   )'r',      (char const   )'s', 
        (char const   )'i',      (char const   )'o',      (char const   )'n',      (char const   )'\t', 
        (char const   )'p',      (char const   )'r',      (char const   )'i',      (char const   )'n', 
        (char const   )'t',      (char const   )' ',      (char const   )'v',      (char const   )'e', 
        (char const   )'r',      (char const   )'s',      (char const   )'i',      (char const   )'o', 
        (char const   )'n',      (char const   )' ',      (char const   )'a',      (char const   )'n', 
        (char const   )'d',      (char const   )' ',      (char const   )'l',      (char const   )'i', 
        (char const   )'c',      (char const   )'e',      (char const   )'n',      (char const   )'s', 
        (char const   )'e',      (char const   )' ',      (char const   )'i',      (char const   )'n', 
        (char const   )'f',      (char const   )'o',      (char const   )'r',      (char const   )'m', 
        (char const   )'a',      (char const   )'t',      (char const   )'i',      (char const   )'o', 
        (char const   )'n',      (char const   )' ',      (char const   )'a',      (char const   )'n', 
        (char const   )'d',      (char const   )' ',      (char const   )'e',      (char const   )'x', 
        (char const   )'i',      (char const   )'t',      (char const   )'.',      (char const   )'\n', 
        (char const   )'-',      (char const   )'-',      (char const   )'p',      (char const   )'d', 
        (char const   )'n',      (char const   )'s',      (char const   )'d',      (char const   )'-', 
        (char const   )'u',      (char const   )'s',      (char const   )'e',      (char const   )'r', 
        (char const   )'\t',      (char const   )'p',      (char const   )'r',      (char const   )'i', 
        (char const   )'n',      (char const   )'t',      (char const   )' ',      (char const   )'t', 
        (char const   )'h',      (char const   )'e',      (char const   )' ',      (char const   )'u', 
        (char const   )'s',      (char const   )'e',      (char const   )'r',      (char const   )' ', 
        (char const   )'p',      (char const   )'d',      (char const   )'n',      (char const   )'s', 
        (char const   )'d',      (char const   )' ',      (char const   )'w',      (char const   )'i', 
        (char const   )'l',      (char const   )'l',      (char const   )' ',      (char const   )'r', 
        (char const   )'u',      (char const   )'n',      (char const   )' ',      (char const   )'a', 
        (char const   )'s',      (char const   )' ',      (char const   )'a',      (char const   )'n', 
        (char const   )'d',      (char const   )' ',      (char const   )'e',      (char const   )'x', 
        (char const   )'i',      (char const   )'t',      (char const   )'.',      (char const   )'\n', 
        (char const   )'-',      (char const   )'s',      (char const   )'\t',      (char const   )'\t', 
        (char const   )'-',      (char const   )'-',      (char const   )'o',      (char const   )'r', 
        (char const   )'-',      (char const   )'-',      (char const   )'\n',      (char const   )'-', 
        (char const   )'-',      (char const   )'s',      (char const   )'t',      (char const   )'a', 
        (char const   )'t',      (char const   )'u',      (char const   )'s',      (char const   )'\t', 
        (char const   )'E',      (char const   )'n',      (char const   )'a',      (char const   )'b', 
        (char const   )'l',      (char const   )'e',      (char const   )' ',      (char const   )'s', 
        (char const   )'t',      (char const   )'a',      (char const   )'t',      (char const   )'u', 
        (char const   )'s',      (char const   )' ',      (char const   )'c',      (char const   )'o', 
        (char const   )'n',      (char const   )'t',      (char const   )'r',      (char const   )'o', 
        (char const   )'l',      (char const   )' ',      (char const   )'s',      (char const   )'o', 
        (char const   )'c',      (char const   )'k',      (char const   )'e',      (char const   )'t', 
        (char const   )' ',      (char const   )'i',      (char const   )'n',      (char const   )' ', 
        (char const   )'t',      (char const   )'h',      (char const   )'e',      (char const   )' ', 
        (char const   )'c',      (char const   )'a',      (char const   )'c',      (char const   )'h', 
        (char const   )'e',      (char const   )' ',      (char const   )'d',      (char const   )'i', 
        (char const   )'r',      (char const   )'e',      (char const   )'c',      (char const   )'t', 
        (char const   )'o',      (char const   )'r',      (char const   )'y',      (char const   )'.', 
        (char const   )'\n',      (char const   )'-',      (char const   )'d',      (char const   )'\t', 
        (char const   )'\t',      (char const   )'-',      (char const   )'-',      (char const   )'o', 
        (char const   )'r',      (char const   )'-',      (char const   )'-',      (char const   )'\n', 
        (char const   )'-',      (char const   )'-',      (char const   )'d',      (char const   )'a', 
        (char const   )'e',      (char const   )'m',      (char const   )'o',      (char const   )'n', 
        (char const   )'\t',      (char const   )'S',      (char const   )'t',      (char const   )'a', 
        (char const   )'r',      (char const   )'t',      (char const   )' ',      (char const   )'p', 
        (char const   )'d',      (char const   )'n',      (char const   )'s',      (char const   )'d', 
        (char const   )' ',      (char const   )'i',      (char const   )'n',      (char const   )' ', 
        (char const   )'d',      (char const   )'a',      (char const   )'e',      (char const   )'m', 
        (char const   )'o',      (char const   )'n',      (char const   )' ',      (char const   )'m', 
        (char const   )'o',      (char const   )'d',      (char const   )'e',      (char const   )' ', 
        (char const   )'(',      (char const   )'a',      (char const   )'s',      (char const   )' ', 
        (char const   )'b',      (char const   )'a',      (char const   )'c',      (char const   )'k', 
        (char const   )'g',      (char const   )'r',      (char const   )'o',      (char const   )'u', 
        (char const   )'n',      (char const   )'d',      (char const   )' ',      (char const   )'p', 
        (char const   )'r',      (char const   )'o',      (char const   )'c',      (char const   )'e', 
        (char const   )'s',      (char const   )'s',      (char const   )'.',      (char const   )')', 
        (char const   )'\n',      (char const   )'-',      (char const   )'g',      (char const   )'\t', 
        (char const   )'\t',      (char const   )'-',      (char const   )'-',      (char const   )'o', 
        (char const   )'r',      (char const   )'-',      (char const   )'-',      (char const   )'\n', 
        (char const   )'-',      (char const   )'-',      (char const   )'d',      (char const   )'e', 
        (char const   )'b',      (char const   )'u',      (char const   )'g',      (char const   )'\t', 
        (char const   )'\t',      (char const   )'P',      (char const   )'r',      (char const   )'i', 
        (char const   )'n',      (char const   )'t',      (char const   )' ',      (char const   )'s', 
        (char const   )'o',      (char const   )'m',      (char const   )'e',      (char const   )' ', 
        (char const   )'d',      (char const   )'e',      (char const   )'b',      (char const   )'u', 
        (char const   )'g',      (char const   )' ',      (char const   )'m',      (char const   )'e', 
        (char const   )'s',      (char const   )'s',      (char const   )'a',      (char const   )'g', 
        (char const   )'e',      (char const   )'s',      (char const   )' ',      (char const   )'o', 
        (char const   )'n',      (char const   )' ',      (char const   )'t',      (char const   )'h', 
        (char const   )'e',      (char const   )' ',      (char const   )'c',      (char const   )'o', 
        (char const   )'n',      (char const   )'s',      (char const   )'o',      (char const   )'l', 
        (char const   )'e',      (char const   )' ',      (char const   )'o',      (char const   )'r', 
        (char const   )' ',      (char const   )'t',      (char const   )'o',      (char const   )' ', 
        (char const   )'t',      (char const   )'h',      (char const   )'e',      (char const   )'\n', 
        (char const   )'\t',      (char const   )'\t',      (char const   )'f',      (char const   )'i', 
        (char const   )'l',      (char const   )'e',      (char const   )' ',      (char const   )'p', 
        (char const   )'d',      (char const   )'n',      (char const   )'s',      (char const   )'d', 
        (char const   )'.',      (char const   )'d',      (char const   )'e',      (char const   )'b', 
        (char const   )'u',      (char const   )'g',      (char const   )' ',      (char const   )'i', 
        (char const   )'n',      (char const   )' ',      (char const   )'y',      (char const   )'o', 
        (char const   )'u',      (char const   )'r',      (char const   )' ',      (char const   )'c', 
        (char const   )'a',      (char const   )'c',      (char const   )'h',      (char const   )'e', 
        (char const   )' ',      (char const   )'d',      (char const   )'i',      (char const   )'r', 
        (char const   )'e',      (char const   )'c',      (char const   )'t',      (char const   )'o', 
        (char const   )'r',      (char const   )'y',      (char const   )' ',      (char const   )'(', 
        (char const   )'i',      (char const   )'n',      (char const   )' ',      (char const   )'d', 
        (char const   )'a',      (char const   )'e',      (char const   )'m',      (char const   )'o', 
        (char const   )'n',      (char const   )' ',      (char const   )'m',      (char const   )'o', 
        (char const   )'d',      (char const   )'e',      (char const   )')',      (char const   )'.', 
        (char const   )'\n',      (char const   )'-',      (char const   )'t',      (char const   )'\t', 
        (char const   )'\t',      (char const   )'-',      (char const   )'-',      (char const   )'o', 
        (char const   )'r',      (char const   )'-',      (char const   )'-',      (char const   )'\n', 
        (char const   )'-',      (char const   )'-',      (char const   )'t',      (char const   )'c', 
        (char const   )'p',      (char const   )'\t',      (char const   )'\t',      (char const   )'E', 
        (char const   )'n',      (char const   )'a',      (char const   )'b',      (char const   )'l', 
        (char const   )'e',      (char const   )'s',      (char const   )' ',      (char const   )'t', 
        (char const   )'h',      (char const   )'e',      (char const   )' ',      (char const   )'T', 
        (char const   )'C',      (char const   )'P',      (char const   )' ',      (char const   )'s', 
        (char const   )'e',      (char const   )'r',      (char const   )'v',      (char const   )'e', 
        (char const   )'r',      (char const   )' ',      (char const   )'t',      (char const   )'h', 
        (char const   )'r',      (char const   )'e',      (char const   )'a',      (char const   )'d', 
        (char const   )'.',      (char const   )' ',      (char const   )'p',      (char const   )'d', 
        (char const   )'n',      (char const   )'s',      (char const   )'d',      (char const   )' ', 
        (char const   )'w',      (char const   )'i',      (char const   )'l',      (char const   )'l', 
        (char const   )' ',      (char const   )'t',      (char const   )'h',      (char const   )'e', 
        (char const   )'n',      (char const   )' ',      (char const   )'s',      (char const   )'e', 
        (char const   )'r',      (char const   )'v',      (char const   )'e',      (char const   )'\n', 
        (char const   )'\t',      (char const   )'\t',      (char const   )'T',      (char const   )'C', 
        (char const   )'P',      (char const   )' ',      (char const   )'a',      (char const   )'n', 
        (char const   )'d',      (char const   )' ',      (char const   )'U',      (char const   )'D', 
        (char const   )'P',      (char const   )' ',      (char const   )'q',      (char const   )'u', 
        (char const   )'e',      (char const   )'r',      (char const   )'i',      (char const   )'e', 
        (char const   )'s',      (char const   )'.',      (char const   )'\n',      (char const   )'-', 
        (char const   )'p',      (char const   )'\t',      (char const   )'\t',      (char const   )'W', 
        (char const   )'r',      (char const   )'i',      (char const   )'t',      (char const   )'e', 
        (char const   )'s',      (char const   )' ',      (char const   )'t',      (char const   )'h', 
        (char const   )'e',      (char const   )' ',      (char const   )'p',      (char const   )'i', 
        (char const   )'d',      (char const   )' ',      (char const   )'t',      (char const   )'h', 
        (char const   )'e',      (char const   )' ',      (char const   )'s',      (char const   )'e', 
        (char const   )'r',      (char const   )'v',      (char const   )'e',      (char const   )'r', 
        (char const   )' ',      (char const   )'r',      (char const   )'u',      (char const   )'n', 
        (char const   )'s',      (char const   )' ',      (char const   )'a',      (char const   )'s', 
        (char const   )' ',      (char const   )'t',      (char const   )'o',      (char const   )' ', 
        (char const   )'a',      (char const   )' ',      (char const   )'s',      (char const   )'p', 
        (char const   )'e',      (char const   )'c',      (char const   )'i',      (char const   )'f', 
        (char const   )'i',      (char const   )'e',      (char const   )'d',      (char const   )' ', 
        (char const   )'f',      (char const   )'i',      (char const   )'l',      (char const   )'e', 
        (char const   )'n',      (char const   )'a',      (char const   )'m',      (char const   )'e', 
        (char const   )'.',      (char const   )'\n',      (char const   )'\t',      (char const   )'\t', 
        (char const   )'W',      (char const   )'o',      (char const   )'r',      (char const   )'k', 
        (char const   )'s',      (char const   )' ',      (char const   )'o',      (char const   )'n', 
        (char const   )'l',      (char const   )'y',      (char const   )' ',      (char const   )'i', 
        (char const   )'n',      (char const   )' ',      (char const   )'d',      (char const   )'a', 
        (char const   )'e',      (char const   )'m',      (char const   )'o',      (char const   )'n', 
        (char const   )' ',      (char const   )'m',      (char const   )'o',      (char const   )'d', 
        (char const   )'e',      (char const   )'.',      (char const   )'\n',      (char const   )'-', 
        (char const   )'v',      (char const   )'n',      (char const   )'\t',      (char const   )'\t', 
        (char const   )'s',      (char const   )'e',      (char const   )'t',      (char const   )'s', 
        (char const   )' ',      (char const   )'t',      (char const   )'h',      (char const   )'e', 
        (char const   )' ',      (char const   )'v',      (char const   )'e',      (char const   )'r', 
        (char const   )'b',      (char const   )'o',      (char const   )'s',      (char const   )'i', 
        (char const   )'t',      (char const   )'y',      (char const   )' ',      (char const   )'o', 
        (char const   )'f',      (char const   )' ',      (char const   )'p',      (char const   )'d', 
        (char const   )'n',      (char const   )'s',      (char const   )'d',      (char const   )'.', 
        (char const   )' ',      (char const   )'n',      (char const   )' ',      (char const   )'i', 
        (char const   )'s',      (char const   )' ',      (char const   )'a',      (char const   )' ', 
        (char const   )'n',      (char const   )'u',      (char const   )'m',      (char const   )'e', 
        (char const   )'r',      (char const   )'i',      (char const   )'c',      (char const   )' ', 
        (char const   )'a',      (char const   )'r',      (char const   )'g',      (char const   )'u', 
        (char const   )'m',      (char const   )'e',      (char const   )'n',      (char const   )'t', 
        (char const   )' ',      (char const   )'f',      (char const   )'r',      (char const   )'o', 
        (char const   )'m',      (char const   )' ',      (char const   )'0',      (char const   )'\n', 
        (char const   )'\t',      (char const   )'\t',      (char const   )'(',      (char const   )'n', 
        (char const   )'o',      (char const   )'r',      (char const   )'m',      (char const   )'a', 
        (char const   )'l',      (char const   )' ',      (char const   )'o',      (char const   )'p', 
        (char const   )'e',      (char const   )'r',      (char const   )'a',      (char const   )'t', 
        (char const   )'i',      (char const   )'o',      (char const   )'n',      (char const   )')', 
        (char const   )' ',      (char const   )'t',      (char const   )'o',      (char const   )' ', 
        (char const   )'9',      (char const   )' ',      (char const   )'(',      (char const   )'m', 
        (char const   )'a',      (char const   )'n',      (char const   )'y',      (char const   )' ', 
        (char const   )'m',      (char const   )'e',      (char const   )'s',      (char const   )'s', 
        (char const   )'a',      (char const   )'g',      (char const   )'e',      (char const   )'s', 
        (char const   )' ',      (char const   )'f',      (char const   )'o',      (char const   )'r', 
        (char const   )' ',      (char const   )'d',      (char const   )'e',      (char const   )'b', 
        (char const   )'u',      (char const   )'g',      (char const   )'g',      (char const   )'i', 
        (char const   )'n',      (char const   )'g',      (char const   )')',      (char const   )'.', 
        (char const   )'\n',      (char const   )'\t',      (char const   )'\t',      (char const   )'U', 
        (char const   )'s',      (char const   )'e',      (char const   )' ',      (char const   )'l', 
        (char const   )'i',      (char const   )'k',      (char const   )'e',      (char const   )' ', 
        (char const   )'-',      (char const   )'v',      (char const   )'2',      (char const   )'\n', 
        (char const   )'-',      (char const   )'m',      (char const   )'x',      (char const   )'x', 
        (char const   )'\t',      (char const   )'\t',      (char const   )'s',      (char const   )'e', 
        (char const   )'t',      (char const   )'s',      (char const   )' ',      (char const   )'t', 
        (char const   )'h',      (char const   )'e',      (char const   )' ',      (char const   )'q', 
        (char const   )'u',      (char const   )'e',      (char const   )'r',      (char const   )'y', 
        (char const   )' ',      (char const   )'m',      (char const   )'e',      (char const   )'t', 
        (char const   )'h',      (char const   )'o',      (char const   )'d',      (char const   )' ', 
        (char const   )'p',      (char const   )'d',      (char const   )'n',      (char const   )'s', 
        (char const   )'d',      (char const   )' ',      (char const   )'u',      (char const   )'s', 
        (char const   )'e',      (char const   )'s',      (char const   )'.',      (char const   )' ', 
        (char const   )'P',      (char const   )'o',      (char const   )'s',      (char const   )'s', 
        (char const   )'i',      (char const   )'b',      (char const   )'l',      (char const   )'e', 
        (char const   )' ',      (char const   )'v',      (char const   )'a',      (char const   )'l', 
        (char const   )'u',      (char const   )'e',      (char const   )'s',      (char const   )' ', 
        (char const   )'f',      (char const   )'o',      (char const   )'r',      (char const   )' ', 
        (char const   )'x',      (char const   )'x',      (char const   )' ',      (char const   )'a', 
        (char const   )'r',      (char const   )'e',      (char const   )':',      (char const   )'\n', 
        (char const   )'\t',      (char const   )'\t',      (char const   )'u',      (char const   )'o', 
        (char const   )' ',      (char const   )'(',      (char const   )'U',      (char const   )'D', 
        (char const   )'P',      (char const   )' ',      (char const   )'o',      (char const   )'n', 
        (char const   )'l',      (char const   )'y',      (char const   )')',      (char const   )',', 
        (char const   )' ',      (char const   )'t',      (char const   )'o',      (char const   )' ', 
        (char const   )'(',      (char const   )'T',      (char const   )'C',      (char const   )'P', 
        (char const   )' ',      (char const   )'o',      (char const   )'n',      (char const   )'l', 
        (char const   )'y',      (char const   )')',      (char const   )',',      (char const   )' ', 
        (char const   )'t',      (char const   )'u',      (char const   )' ',      (char const   )'(', 
        (char const   )'T',      (char const   )'C',      (char const   )'P',      (char const   )' ', 
        (char const   )'o',      (char const   )'r',      (char const   )',',      (char const   )' ', 
        (char const   )'i',      (char const   )'f',      (char const   )' ',      (char const   )'t', 
        (char const   )'h',      (char const   )'e',      (char const   )' ',      (char const   )'s', 
        (char const   )'e',      (char const   )'r',      (char const   )'v',      (char const   )'e', 
        (char const   )'r',      (char const   )'\n',      (char const   )'\t',      (char const   )'\t', 
        (char const   )'d',      (char const   )'o',      (char const   )'e',      (char const   )'s', 
        (char const   )' ',      (char const   )'n',      (char const   )'o',      (char const   )'t', 
        (char const   )' ',      (char const   )'s',      (char const   )'u',      (char const   )'p', 
        (char const   )'p',      (char const   )'o',      (char const   )'r',      (char const   )'t', 
        (char const   )' ',      (char const   )'t',      (char const   )'h',      (char const   )'i', 
        (char const   )'s',      (char const   )',',      (char const   )' ',      (char const   )'U', 
        (char const   )'D',      (char const   )'P',      (char const   )')',      (char const   )' ', 
        (char const   )'a',      (char const   )'n',      (char const   )'d',      (char const   )' ', 
        (char const   )'u',      (char const   )'t',      (char const   )' ',      (char const   )'(', 
        (char const   )'U',      (char const   )'D',      (char const   )'P',      (char const   )' ', 
        (char const   )'a',      (char const   )'n',      (char const   )'d',      (char const   )',', 
        (char const   )' ',      (char const   )'i',      (char const   )'f',      (char const   )' ', 
        (char const   )'t',      (char const   )'h',      (char const   )'e',      (char const   )' ', 
        (char const   )'r',      (char const   )'e',      (char const   )'p',      (char const   )'l', 
        (char const   )'y',      (char const   )' ',      (char const   )'w',      (char const   )'a', 
        (char const   )'s',      (char const   )'\n',      (char const   )'\t',      (char const   )'\t', 
        (char const   )'t',      (char const   )'r',      (char const   )'u',      (char const   )'n', 
        (char const   )'c',      (char const   )'a',      (char const   )'t',      (char const   )'e', 
        (char const   )'d',      (char const   )',',      (char const   )' ',      (char const   )'T', 
        (char const   )'C',      (char const   )'P',      (char const   )')',      (char const   )'.', 
        (char const   )' ',      (char const   )'U',      (char const   )'s',      (char const   )'e', 
        (char const   )' ',      (char const   )'l',      (char const   )'i',      (char const   )'k', 
        (char const   )'e',      (char const   )' ',      (char const   )'-',      (char const   )'m', 
        (char const   )'u',      (char const   )'o',      (char const   )'.',      (char const   )' ', 
        (char const   )'P',      (char const   )'r',      (char const   )'e',      (char const   )'s', 
        (char const   )'e',      (char const   )'t',      (char const   )':',      (char const   )' ', 
        (char const   )'-',      (char const   )'m',      (char const   )'u',      (char const   )'o', 
        (char const   )'\n',      (char const   )'-',      (char const   )'c',      (char const   )'\t', 
        (char const   )'\t',      (char const   )'-',      (char const   )'-',      (char const   )'o', 
        (char const   )'r',      (char const   )'-',      (char const   )'-',      (char const   )'\n', 
        (char const   )'-',      (char const   )'-',      (char const   )'c',      (char const   )'o', 
        (char const   )'n',      (char const   )'f',      (char const   )'i',      (char const   )'g', 
        (char const   )'-',      (char const   )'f',      (char const   )'i',      (char const   )'l', 
        (char const   )'e',      (char const   )'\t',      (char const   )'s',      (char const   )'p', 
        (char const   )'e',      (char const   )'c',      (char const   )'i',      (char const   )'f', 
        (char const   )'i',      (char const   )'e',      (char const   )'s',      (char const   )' ', 
        (char const   )'t',      (char const   )'h',      (char const   )'e',      (char const   )' ', 
        (char const   )'f',      (char const   )'i',      (char const   )'l',      (char const   )'e', 
        (char const   )' ',      (char const   )'t',      (char const   )'h',      (char const   )'e', 
        (char const   )' ',      (char const   )'c',      (char const   )'o',      (char const   )'n', 
        (char const   )'f',      (char const   )'i',      (char const   )'g',      (char const   )'u', 
        (char const   )'r',      (char const   )'a',      (char const   )'t',      (char const   )'i', 
        (char const   )'o',      (char const   )'n',      (char const   )' ',      (char const   )'i', 
        (char const   )'s',      (char const   )' ',      (char const   )'r',      (char const   )'e', 
        (char const   )'a',      (char const   )'d',      (char const   )' ',      (char const   )'f', 
        (char const   )'r',      (char const   )'o',      (char const   )'m',      (char const   )'.', 
        (char const   )'\n',      (char const   )'\t',      (char const   )'\t',      (char const   )'D', 
        (char const   )'e',      (char const   )'f',      (char const   )'a',      (char const   )'u', 
        (char const   )'l',      (char const   )'t',      (char const   )' ',      (char const   )'i', 
        (char const   )'s',      (char const   )' ',      (char const   )'/',      (char const   )'u', 
        (char const   )'s',      (char const   )'r',      (char const   )'/',      (char const   )'l', 
        (char const   )'o',      (char const   )'c',      (char const   )'a',      (char const   )'l', 
        (char const   )'/',      (char const   )'e',      (char const   )'t',      (char const   )'c', 
        (char const   )'/',      (char const   )'p',      (char const   )'d',      (char const   )'n', 
        (char const   )'s',      (char const   )'d',      (char const   )'.',      (char const   )'c', 
        (char const   )'o',      (char const   )'n',      (char const   )'f',      (char const   )'\n', 
        (char const   )'-',      (char const   )'4',      (char const   )'\t',      (char const   )'\t', 
        (char const   )'s',      (char const   )'w',      (char const   )'i',      (char const   )'t', 
        (char const   )'c',      (char const   )'h',      (char const   )'e',      (char const   )'s', 
        (char const   )' ',      (char const   )'t',      (char const   )'o',      (char const   )' ', 
        (char const   )'I',      (char const   )'P',      (char const   )'v',      (char const   )'4', 
        (char const   )' ',      (char const   )'m',      (char const   )'o',      (char const   )'d', 
        (char const   )'e',      (char const   )'.',      (char const   )'\n',      (char const   )'\t', 
        (char const   )'\t',      (char const   )'O',      (char const   )'n',      (char const   )' ', 
        (char const   )'b',      (char const   )'y',      (char const   )' ',      (char const   )'d', 
        (char const   )'e',      (char const   )'f',      (char const   )'a',      (char const   )'u', 
        (char const   )'l',      (char const   )'t',      (char const   )'.',      (char const   )'\n', 
        (char const   )'\n',      (char const   )'\n',      (char const   )'\"',      (char const   )'n', 
        (char const   )'o',      (char const   )'\"',      (char const   )' ',      (char const   )'c', 
        (char const   )'a',      (char const   )'n',      (char const   )' ',      (char const   )'b', 
        (char const   )'e',      (char const   )' ',      (char const   )'p',      (char const   )'r', 
        (char const   )'e',      (char const   )'p',      (char const   )'e',      (char const   )'n', 
        (char const   )'d',      (char const   )'e',      (char const   )'d',      (char const   )' ', 
        (char const   )'t',      (char const   )'o',      (char const   )' ',      (char const   )'t', 
        (char const   )'h',      (char const   )'e',      (char const   )' ',      (char const   )'-', 
        (char const   )'-',      (char const   )'s',      (char const   )'t',      (char const   )'a', 
        (char const   )'t',      (char const   )'u',      (char const   )'s',      (char const   )',', 
        (char const   )' ',      (char const   )'-',      (char const   )'-',      (char const   )'d', 
        (char const   )'a',      (char const   )'e',      (char const   )'m',      (char const   )'o', 
        (char const   )'n',      (char const   )',',      (char const   )' ',      (char const   )'-', 
        (char const   )'-',      (char const   )'d',      (char const   )'e',      (char const   )'b', 
        (char const   )'u',      (char const   )'g',      (char const   )' ',      (char const   )'a', 
        (char const   )'n',      (char const   )'d',      (char const   )' ',      (char const   )'-', 
        (char const   )'-',      (char const   )'t',      (char const   )'c',      (char const   )'p', 
        (char const   )'\n',      (char const   )'o',      (char const   )'p',      (char const   )'t', 
        (char const   )'i',      (char const   )'o',      (char const   )'n',      (char const   )'s', 
        (char const   )' ',      (char const   )'(',      (char const   )'e',      (char const   )'.', 
        (char const   )'g',      (char const   )'.',      (char const   )' ',      (char const   )'-', 
        (char const   )'-',      (char const   )'n',      (char const   )'o',      (char const   )'t', 
        (char const   )'c',      (char const   )'p',      (char const   )')',      (char const   )' ', 
        (char const   )'t',      (char const   )'o',      (char const   )' ',      (char const   )'r', 
        (char const   )'e',      (char const   )'v',      (char const   )'e',      (char const   )'r', 
        (char const   )'s',      (char const   )'e',      (char const   )' ',      (char const   )'t', 
        (char const   )'h',      (char const   )'e',      (char const   )'i',      (char const   )'r', 
        (char const   )' ',      (char const   )'e',      (char const   )'f',      (char const   )'f', 
        (char const   )'e',      (char const   )'c',      (char const   )'t',      (char const   )'.', 
        (char const   )'\n',      (char const   )'\000'};
#line 179 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/main.c"
int final_init(void) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 182
  if (! global.notcp) {
    {
#line 183
    tmp = init_tcp_socket();
#line 183
    tcp_socket = (int volatile   )tmp;
    }
  }
  {
#line 185
  tmp___0 = init_udp_socket();
#line 185
  udp_socket = (int volatile   )tmp___0;
  }
#line 186
  if (tcp_socket == (int volatile   )-1) {
#line 186
    if (udp_socket == (int volatile   )-1) {
      {
#line 187
      log_message(3, "tcp and udp initialization failed. Exiting.");
      }
#line 188
      return (0);
    }
  }
#line 190
  if (global.strict_suid) {
    {
#line 191
    tmp___1 = run_as((char const   *)(global.run_as));
    }
#line 191
    if (! tmp___1) {
#line 192
      return (0);
    }
  }
#line 195
  return (1);
}
}
/* compiler builtin: 
   long __builtin_expect(long  , long  ) ;  */
#line 272 "/usr/include/x86_64-linux-gnu/bits/socket.h"
extern  __attribute__((__nothrow__)) struct cmsghdr *( __attribute__((__leaf__)) __cmsg_nxthdr)(struct msghdr *__mhdr ,
                                                                                                struct cmsghdr *__cmsg ) ;
#line 184 "/usr/include/x86_64-linux-gnu/sys/socket.h"
extern ssize_t sendmsg(int __fd , struct msghdr  const  *__message , int __flags ) ;
#line 202
extern ssize_t recvmsg(int __fd , struct msghdr *__message , int __flags ) ;
#line 219
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) getsockopt)(int __fd ,
                                                                                 int __level ,
                                                                                 int __optname ,
                                                                                 void * __restrict  __optval ,
                                                                                 socklen_t * __restrict  __optlen ) ;
#line 691 "/usr/include/pthread.h"
extern void __pthread_register_cancel(__pthread_unwind_buf_t *__buf ) ;
#line 703
extern void __pthread_unregister_cancel(__pthread_unwind_buf_t *__buf ) ;
#line 744
extern  __attribute__((__noreturn__)) void __pthread_unwind_next(__pthread_unwind_buf_t *__buf )  __attribute__((__weak__)) ;
#line 754
extern  __attribute__((__nothrow__)) int __sigsetjmp(struct __jmp_buf_tag *__env ,
                                                     int __savemask ) ;
#line 1133
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) pthread_setspecific)(pthread_key_t __key ,
                                                                                          void const   *__pointer ) ;
#line 468 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) calloc)(size_t __nmemb ,
                                                                               size_t __size )  __attribute__((__malloc__)) ;
#line 111 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/thread.h"
__inline static int ( __attribute__((__always_inline__)) usleep_r)(unsigned long useconds ) ;
#line 85 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/list.h"
__inline static void *( __attribute__((__always_inline__)) dlist_first)(dlist a ) ;
#line 96
__inline static void *( __attribute__((__always_inline__)) dlist_next)(void *ref ) ;
#line 105
__inline static void *( __attribute__((__always_inline__)) dlist_last)(dlist a ) ;
#line 128
__inline static void ( __attribute__((__always_inline__)) llist_init)(llist *a ) ;
#line 130 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/list.h"
__inline static void ( __attribute__((__always_inline__)) llist_init)(llist *a ) 
{ 


  {
#line 132
  a->first = (struct llistnode_s *)((void *)0);
#line 133
  a->last = (struct llistnode_s *)((void *)0);
#line 134
  return;
}
}
#line 136
__inline static int ( __attribute__((__always_inline__)) llist_isempty)(llist *a ) ;
#line 138 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/list.h"
__inline static int ( __attribute__((__always_inline__)) llist_isempty)(llist *a ) 
{ 


  {
#line 140
  return ((unsigned long )a->first == (unsigned long )((void *)0));
}
}
#line 143
__inline static void *( __attribute__((__always_inline__)) llist_first)(llist *a ) ;
#line 145 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/list.h"
__inline static void *( __attribute__((__always_inline__)) llist_first)(llist *a ) 
{ 
  struct llistnode_s *p ;
  char **tmp ;

  {
#line 147
  p = a->first;
#line 148
  if (p) {
#line 148
    tmp = p->data;
  } else {
#line 148
    tmp = (char **)((void *)0);
  }
#line 148
  return ((void *)tmp);
}
}
#line 151
__inline static void *( __attribute__((__always_inline__)) llist_next)(void *ref ) ;
#line 153 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/list.h"
__inline static void *( __attribute__((__always_inline__)) llist_next)(void *ref ) 
{ 
  struct llistnode_s *next ;
  char **tmp ;

  {
#line 155
  next = *((struct llistnode_s **)ref - 1);
#line 156
  if (next) {
#line 156
    tmp = next->data;
  } else {
#line 156
    tmp = (char **)((void *)0);
  }
#line 156
  return ((void *)tmp);
}
}
#line 159
__inline static void *( __attribute__((__always_inline__)) llist_last)(llist *a ) ;
#line 161 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/list.h"
__inline static void *( __attribute__((__always_inline__)) llist_last)(llist *a ) 
{ 
  struct llistnode_s *p ;
  char **tmp ;

  {
#line 163
  p = a->last;
#line 164
  if (p) {
#line 164
    tmp = p->data;
  } else {
#line 164
    tmp = (char **)((void *)0);
  }
#line 164
  return ((void *)tmp);
}
}
#line 167
int llist_grow(llist *a , size_t len ) ;
#line 168
void llist_free(llist *a ) ;
#line 219 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/cache.h"
__inline static rr_set_t *( __attribute__((__always_inline__)) getrrset)(dns_cent_t *cent ,
                                                                         int type ) ;
#line 249
__inline static rr_set_t *( __attribute__((__always_inline__)) getrrset_eff)(dns_cent_t *cent ,
                                                                             int type ) ;
#line 272
__inline static int ( __attribute__((__always_inline__)) have_rr)(dns_cent_t *cent ,
                                                                  int type ) ;
#line 60 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/helpers.h"
__inline static unsigned int ( __attribute__((__always_inline__)) rhnlen)(unsigned char const   *rhn ) ;
#line 72
__inline static unsigned char const   *( __attribute__((__always_inline__)) skipsegs)(unsigned char const   *nm ,
                                                                                      unsigned int k ) ;
#line 86
__inline static unsigned char *( __attribute__((__always_inline__)) skiprhn)(unsigned char *rhn ) ;
#line 98
__inline static unsigned int ( __attribute__((__always_inline__)) rhnsegcnt)(unsigned char const   *rhn ) ;
#line 180
__inline static ssize_t ( __attribute__((__always_inline__)) write_all)(int fd , void const   *data ,
                                                                        size_t n ) ;
#line 212
__inline static int ( __attribute__((__always_inline__)) rhnicmp)(unsigned char const   *a ,
                                                                  unsigned char const   *b ) ;
#line 73 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/dns_answer.c"
static unsigned long volatile   da_tcp_errs  =    (unsigned long volatile   )0;
#line 74 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/dns_answer.c"
static unsigned long volatile   da_udp_errs  =    (unsigned long volatile   )0;
#line 75 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/dns_answer.c"
static unsigned long volatile   da_mem_errs  =    (unsigned long volatile   )0;
#line 76 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/dns_answer.c"
static unsigned long volatile   da_thrd_errs  =    (unsigned long volatile   )0;
#line 78 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/dns_answer.c"
static unsigned long volatile   da_misc_errs  =    (unsigned long volatile   )0;
#line 80 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/dns_answer.c"
static int volatile   procs  =    (int volatile   )0;
#line 81 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/dns_answer.c"
static int volatile   qprocs  =    (int volatile   )0;
#line 82 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/dns_answer.c"
static unsigned long volatile   dropped  =    (unsigned long volatile   )0;
#line 82 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/dns_answer.c"
static unsigned long volatile   spawned  =    (unsigned long volatile   )0;
#line 83 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/dns_answer.c"
static unsigned int volatile   thrid_cnt  =    (unsigned int volatile   )0;
#line 84 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/dns_answer.c"
static pthread_mutex_t proc_lock  =    {{0, 0U, 0, 0U, 0, (short)0, (short)0, {(struct __pthread_internal_list *)0, (struct __pthread_internal_list *)0}}};
#line 149 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/dns_answer.c"
static int sva_add(dlist *sva , unsigned char const   *rhn , unsigned short tp , unsigned short dlen ,
                   void *data ) 
{ 
  size_t rlen ;
  unsigned int tmp ;
  sva_t *st ;
  dlist tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;

  {
#line 151
  if (sva) {
    {
#line 152
    tmp = rhnlen(rhn);
#line 152
    rlen = (size_t )tmp;
#line 154
    tmp___0 = dlist_grow(*sva, (sizeof(sva_t ) + rlen) + (unsigned long )dlen);
#line 154
    *sva = tmp___0;
    }
#line 154
    if (! tmp___0) {
#line 155
      return (0);
    }
    {
#line 157
    tmp___1 = dlist_last(*sva);
#line 157
    st = (sva_t *)tmp___1;
#line 158
    st->tp = tp;
#line 159
    st->dlen = dlen;
#line 160
    tmp___2 = mempcpy((void */* __restrict  */)(st->nm), (void const   */* __restrict  */)rhn,
                      rlen);
#line 160
    memcpy((void */* __restrict  */)tmp___2, (void const   */* __restrict  */)data,
           (size_t )dlen);
    }
  }
#line 162
  return (1);
}
}
#line 170 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/dns_answer.c"
__inline static time_t ans_ttl(rr_set_t *rrset , time_t queryts ) 
{ 
  time_t ttl ;
  time_t tpassed ;

  {
#line 172
  ttl = rrset->ttl;
#line 174
  if (! ((int )rrset->flags & 2)) {
#line 175
    tpassed = queryts - rrset->ts;
#line 176
    if (tpassed < 0L) {
#line 176
      tpassed = (time_t )0;
    }
#line 177
    ttl -= tpassed;
#line 178
    if (ttl < 0L) {
#line 178
      ttl = (time_t )0;
    }
  }
#line 180
  return (ttl);
}
}
#line 188 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/dns_answer.c"
__inline static int follow_cname_chain(dns_cent_t *c , unsigned char *name ) 
{ 
  rr_set_t *rrset ;
  rr_set_t *tmp ;
  rr_bucket_t *rr ;

  {
#line 190
  if (! ((int )c->flags & 1)) {
#line 190
    tmp = c->__annonCompField2.rr.rrmu[2];
  } else {
#line 190
    tmp = (rr_set_t *)((void *)0);
  }
#line 190
  rrset = tmp;
#line 192
  if (! rrset) {
#line 193
    return (0);
  } else {
#line 192
    rr = rrset->rrs;
#line 192
    if (! rr) {
#line 193
      return (0);
    }
  }
#line 194
  if (! (rr->rdlen <= 256U)) {
    {
#line 194
    log_message(3, "%s:%d: %s", "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/dns_answer.c",
                194, "follow_cname_chain: record too long");
#line 194
    pdnsd_exit();
    }
  }
  {
#line 195
  memcpy((void */* __restrict  */)name, (void const   */* __restrict  */)(rr->data),
         (size_t )rr->rdlen);
  }
#line 196
  return (1);
}
}
#line 213 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/dns_answer.c"
static int add_rr(dns_msg_t **ans , size_t *sz , size_t *allocsz , unsigned char *rrn ,
                  unsigned short type , uint32_t ttl , unsigned int dlen , void *data ,
                  char section , unsigned int *udp , dlist *cb ) 
{ 
  size_t osz ;
  unsigned int ilen ;
  unsigned int blen ;
  unsigned int rdlen ;
  unsigned char *rrht ;
  unsigned int nlen ;
  unsigned char nbuf[256] ;
  size_t newsz ;
  size_t newallocsz ;
  dns_msg_t *newans ;
  void *tmp ;
  unsigned int tmp___0 ;
  unsigned int tmp___1 ;
  unsigned int wlen ;
  int j ;
  register uint16_t t_s ;
  register unsigned char *t_cp ;
  unsigned char *tmp___2 ;
  unsigned char *tmp___3 ;
  register uint16_t t_s___0 ;
  register unsigned char *t_cp___0 ;
  unsigned char *tmp___4 ;
  unsigned char *tmp___5 ;
  register uint32_t t_l ;
  register unsigned char *t_cp___1 ;
  unsigned char *tmp___6 ;
  unsigned char *tmp___7 ;
  unsigned char *tmp___8 ;
  unsigned char *tmp___9 ;
  register uint16_t t_s___1 ;
  register unsigned char *t_cp___2 ;
  unsigned char *tmp___10 ;
  unsigned char *tmp___11 ;
  uint16_t tmp___12 ;
  uint16_t tmp___13 ;
  uint16_t tmp___14 ;

  {
  {
#line 217
  osz = *sz;
#line 225
  nlen = compress_name(rrn, nbuf, (unsigned int )*sz, cb);
  }
#line 225
  if (! nlen) {
#line 226
    return (0);
  }
#line 231
  newsz = (((2UL + *sz) + (size_t )nlen) + 10UL) + (size_t )dlen;
#line 232
  if (newsz > *allocsz) {
    {
#line 236
    newallocsz = (newsz + 127UL) & 0xffffffffffffff80UL;
#line 237
    tmp = realloc((void *)*ans, newallocsz);
#line 237
    newans = (dns_msg_t *)tmp;
    }
#line 238
    if (! newans) {
#line 239
      return (0);
    }
#line 240
    *ans = newans;
#line 241
    *allocsz = newallocsz;
  }
  {
#line 244
  memcpy((void */* __restrict  */)((unsigned char *)(& (*ans)->hdr) + *sz), (void const   */* __restrict  */)(nbuf),
         (size_t )nlen);
#line 245
  *sz += (size_t )nlen;
#line 249
  rrht = (unsigned char *)(& (*ans)->hdr) + *sz;
#line 250
  *sz += 10UL;
  }
  {
#line 260
  if ((int )type == 12) {
#line 260
    goto case_12;
  }
#line 260
  if ((int )type == 2) {
#line 260
    goto case_12;
  }
#line 260
  if ((int )type == 9) {
#line 260
    goto case_12;
  }
#line 260
  if ((int )type == 8) {
#line 260
    goto case_12;
  }
#line 260
  if ((int )type == 4) {
#line 260
    goto case_12;
  }
#line 260
  if ((int )type == 3) {
#line 260
    goto case_12;
  }
#line 260
  if ((int )type == 7) {
#line 260
    goto case_12;
  }
#line 260
  if ((int )type == 5) {
#line 260
    goto case_12;
  }
#line 271
  if ((int )type == 17) {
#line 271
    goto case_17;
  }
#line 271
  if ((int )type == 14) {
#line 271
    goto case_17;
  }
#line 293
  if ((int )type == 36) {
#line 293
    goto case_36;
  }
#line 293
  if ((int )type == 21) {
#line 293
    goto case_36;
  }
#line 293
  if ((int )type == 18) {
#line 293
    goto case_36;
  }
#line 293
  if ((int )type == 15) {
#line 293
    goto case_36;
  }
#line 304
  if ((int )type == 6) {
#line 304
    goto case_6;
  }
#line 322
  if ((int )type == 26) {
#line 322
    goto case_26;
  }
#line 341
  if ((int )type == 33) {
#line 341
    goto case_33;
  }
#line 353
  if ((int )type == 30) {
#line 353
    goto case_30;
  }
#line 370
  if ((int )type == 35) {
#line 370
    goto case_35;
  }
#line 390
  goto switch_default;
  case_12: /* CIL Label */ 
  case_2: /* CIL Label */ 
  case_9: /* CIL Label */ 
  case_8: /* CIL Label */ 
  case_4: /* CIL Label */ 
  case_3: /* CIL Label */ 
  case_7: /* CIL Label */ 
  case_5: /* CIL Label */ 
  {
#line 261
  rdlen = compress_name((unsigned char *)data, (unsigned char *)(& (*ans)->hdr) + *sz,
                        (unsigned int )*sz, cb);
  }
#line 261
  if (! rdlen) {
#line 262
    return (0);
  }
#line 263
  if (! (rdlen <= dlen)) {
    {
#line 263
    log_message(3, "%s:%d: %s", "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/dns_answer.c",
                263, "T_CNAME/T_MB/...: got longer");
#line 263
    pdnsd_exit();
    }
  }
#line 264
  *sz += (size_t )rdlen;
#line 265
  goto switch_break;
  case_17: /* CIL Label */ 
  case_14: /* CIL Label */ 
  {
#line 273
  rdlen = compress_name((unsigned char *)data, (unsigned char *)(& (*ans)->hdr) + *sz,
                        (unsigned int )*sz, cb);
  }
#line 273
  if (! rdlen) {
#line 274
    return (0);
  }
  {
#line 275
  *sz += (size_t )rdlen;
#line 276
  ilen = rhnlen((unsigned char const   *)((unsigned char *)data));
  }
#line 277
  if (! (rdlen <= ilen)) {
    {
#line 277
    log_message(3, "%s:%d: %s", "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/dns_answer.c",
                277, "T_MINFO/T_RP: got longer");
#line 277
    pdnsd_exit();
    }
  }
  {
#line 278
  blen = compress_name((unsigned char *)data + ilen, (unsigned char *)(& (*ans)->hdr) + *sz,
                       (unsigned int )*sz, cb);
  }
#line 278
  if (! blen) {
#line 279
    return (0);
  }
#line 280
  rdlen += blen;
#line 281
  if (! (rdlen <= dlen)) {
    {
#line 281
    log_message(3, "%s:%d: %s", "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/dns_answer.c",
                281, "T_MINFO/T_RP: got longer");
#line 281
    pdnsd_exit();
    }
  }
#line 282
  *sz += (size_t )blen;
#line 283
  goto switch_break;
  case_36: /* CIL Label */ 
  case_21: /* CIL Label */ 
  case_18: /* CIL Label */ 
  case_15: /* CIL Label */ 
#line 295
  if (! (dlen > 2U)) {
    {
#line 295
    log_message(3, "%s:%d: %s", "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/dns_answer.c",
                295, "T_MX/T_AFSDB/...: rr botch");
#line 295
    pdnsd_exit();
    }
  }
  {
#line 296
  memcpy((void */* __restrict  */)((unsigned char *)(& (*ans)->hdr) + *sz), (void const   */* __restrict  */)((unsigned char *)data),
         (size_t )2);
#line 297
  *sz += 2UL;
#line 298
  blen = compress_name((unsigned char *)data + 2, (unsigned char *)(& (*ans)->hdr) + *sz,
                       (unsigned int )*sz, cb);
  }
#line 298
  if (! blen) {
#line 299
    return (0);
  }
#line 300
  rdlen = 2U + blen;
#line 301
  if (! (rdlen <= dlen)) {
    {
#line 301
    log_message(3, "%s:%d: %s", "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/dns_answer.c",
                301, "T_MX/T_AFSDB/...: got longer");
#line 301
    pdnsd_exit();
    }
  }
#line 302
  *sz += (size_t )blen;
#line 303
  goto switch_break;
  case_6: /* CIL Label */ 
  {
#line 305
  rdlen = compress_name((unsigned char *)data, (unsigned char *)(& (*ans)->hdr) + *sz,
                        (unsigned int )*sz, cb);
  }
#line 305
  if (! rdlen) {
#line 306
    return (0);
  }
  {
#line 307
  *sz += (size_t )rdlen;
#line 308
  ilen = rhnlen((unsigned char const   *)((unsigned char *)data));
  }
#line 309
  if (! (rdlen <= ilen)) {
    {
#line 309
    log_message(3, "%s:%d: %s", "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/dns_answer.c",
                309, "T_SOA: got longer");
#line 309
    pdnsd_exit();
    }
  }
  {
#line 310
  blen = compress_name((unsigned char *)data + ilen, (unsigned char *)(& (*ans)->hdr) + *sz,
                       (unsigned int )*sz, cb);
  }
#line 310
  if (! blen) {
#line 311
    return (0);
  }
  {
#line 312
  rdlen += blen;
#line 313
  *sz += (size_t )blen;
#line 314
  tmp___0 = rhnlen((unsigned char const   *)((unsigned char *)data + ilen));
#line 314
  ilen += tmp___0;
  }
#line 315
  if (! (rdlen <= ilen)) {
    {
#line 315
    log_message(3, "%s:%d: %s", "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/dns_answer.c",
                315, "T_SOA: got longer");
#line 315
    pdnsd_exit();
    }
  }
  {
#line 316
  memcpy((void */* __restrict  */)((unsigned char *)(& (*ans)->hdr) + *sz), (void const   */* __restrict  */)((unsigned char *)data + ilen),
         (size_t )20);
#line 317
  rdlen += 20U;
  }
#line 318
  if (! (rdlen <= dlen)) {
    {
#line 318
    log_message(3, "%s:%d: %s", "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/dns_answer.c",
                318, "T_SOA: rr botch");
#line 318
    pdnsd_exit();
    }
  }
#line 319
  *sz += 20UL;
#line 320
  goto switch_break;
  case_26: /* CIL Label */ 
#line 323
  if (! (dlen > 2U)) {
    {
#line 323
    log_message(3, "%s:%d: %s", "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/dns_answer.c",
                323, "T_PX: rr botch");
#line 323
    pdnsd_exit();
    }
  }
  {
#line 324
  memcpy((void */* __restrict  */)((unsigned char *)(& (*ans)->hdr) + *sz), (void const   */* __restrict  */)((unsigned char *)data),
         (size_t )2);
#line 325
  *sz += 2UL;
#line 326
  ilen = 2U;
#line 327
  blen = compress_name((unsigned char *)data + ilen, (unsigned char *)(& (*ans)->hdr) + *sz,
                       (unsigned int )*sz, cb);
  }
#line 327
  if (! blen) {
#line 328
    return (0);
  }
  {
#line 329
  rdlen = 2U + blen;
#line 330
  *sz += (size_t )blen;
#line 331
  tmp___1 = rhnlen((unsigned char const   *)((unsigned char *)data + ilen));
#line 331
  ilen += tmp___1;
  }
#line 332
  if (! (rdlen <= ilen)) {
    {
#line 332
    log_message(3, "%s:%d: %s", "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/dns_answer.c",
                332, "T_PX: got longer");
#line 332
    pdnsd_exit();
    }
  }
  {
#line 333
  blen = compress_name((unsigned char *)data + ilen, (unsigned char *)(& (*ans)->hdr) + *sz,
                       (unsigned int )*sz, cb);
  }
#line 333
  if (! blen) {
#line 334
    return (0);
  }
#line 335
  rdlen += blen;
#line 336
  if (! (rdlen <= dlen)) {
    {
#line 336
    log_message(3, "%s:%d: %s", "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/dns_answer.c",
                336, "T_PX: got longer");
#line 336
    pdnsd_exit();
    }
  }
#line 337
  *sz += (size_t )blen;
#line 338
  goto switch_break;
  case_33: /* CIL Label */ 
#line 342
  if (! (dlen > 6U)) {
    {
#line 342
    log_message(3, "%s:%d: %s", "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/dns_answer.c",
                342, "T_SRV: rr botch");
#line 342
    pdnsd_exit();
    }
  }
  {
#line 343
  memcpy((void */* __restrict  */)((unsigned char *)(& (*ans)->hdr) + *sz), (void const   */* __restrict  */)((unsigned char *)data),
         (size_t )6);
#line 344
  *sz += 6UL;
#line 345
  blen = compress_name((unsigned char *)data + 6, (unsigned char *)(& (*ans)->hdr) + *sz,
                       (unsigned int )*sz, cb);
  }
#line 345
  if (! blen) {
#line 346
    return (0);
  }
#line 347
  rdlen = 6U + blen;
#line 348
  if (! (rdlen <= dlen)) {
    {
#line 348
    log_message(3, "%s:%d: %s", "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/dns_answer.c",
                348, "T_SRV: got longer");
#line 348
    pdnsd_exit();
    }
  }
#line 349
  *sz += (size_t )blen;
#line 350
  goto switch_break;
  case_30: /* CIL Label */ 
  {
#line 354
  blen = compress_name((unsigned char *)data, (unsigned char *)(& (*ans)->hdr) + *sz,
                       (unsigned int )*sz, cb);
  }
#line 354
  if (! blen) {
#line 355
    return (0);
  }
  {
#line 356
  rdlen = blen;
#line 357
  *sz += (size_t )blen;
#line 358
  ilen = rhnlen((unsigned char const   *)((unsigned char *)data));
  }
#line 359
  if (! (rdlen <= ilen)) {
    {
#line 359
    log_message(3, "%s:%d: %s", "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/dns_answer.c",
                359, "T_NXT: got longer");
#line 359
    pdnsd_exit();
    }
  }
#line 360
  if (! (dlen >= ilen)) {
    {
#line 360
    log_message(3, "%s:%d: %s", "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/dns_answer.c",
                360, "T_NXT: rr botch");
#line 360
    pdnsd_exit();
    }
  }
#line 361
  if (dlen > ilen) {
    {
#line 362
    wlen = dlen - ilen;
#line 363
    memcpy((void */* __restrict  */)((unsigned char *)(& (*ans)->hdr) + *sz), (void const   */* __restrict  */)((unsigned char *)data + ilen),
           (size_t )wlen);
#line 364
    *sz += (size_t )wlen;
#line 365
    rdlen += wlen;
    }
  }
#line 367
  goto switch_break;
  case_35: /* CIL Label */ 
#line 371
  if (! (dlen > 4U)) {
    {
#line 371
    log_message(3, "%s:%d: %s", "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/dns_answer.c",
                371, "T_NAPTR: rr botch");
#line 371
    pdnsd_exit();
    }
  }
#line 372
  ilen = 4U;
#line 375
  j = 0;
  {
#line 375
  while (1) {
    while_continue: /* CIL Label */ ;
#line 375
    if (! (j < 3)) {
#line 375
      goto while_break;
    }
#line 376
    ilen += (unsigned int )*((unsigned char *)data + ilen) + 1U;
#line 377
    if (! (dlen > ilen)) {
      {
#line 377
      log_message(3, "%s:%d: %s", "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/dns_answer.c",
                  377, "T_NAPTR: rr botch 2");
#line 377
      pdnsd_exit();
      }
    }
#line 375
    j ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 380
  memcpy((void */* __restrict  */)((unsigned char *)(& (*ans)->hdr) + *sz), (void const   */* __restrict  */)((unsigned char *)data),
         (size_t )ilen);
#line 381
  *sz += (size_t )ilen;
#line 383
  blen = compress_name((unsigned char *)data + ilen, (unsigned char *)(& (*ans)->hdr) + *sz,
                       (unsigned int )*sz, cb);
  }
#line 383
  if (! blen) {
#line 384
    return (0);
  }
#line 385
  rdlen = ilen + blen;
#line 386
  if (! (rdlen <= dlen)) {
    {
#line 386
    log_message(3, "%s:%d: %s", "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/dns_answer.c",
                386, "T_NAPTR: got longer");
#line 386
    pdnsd_exit();
    }
  }
#line 387
  *sz += (size_t )blen;
#line 388
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 391
  memcpy((void */* __restrict  */)((unsigned char *)(& (*ans)->hdr) + *sz), (void const   */* __restrict  */)((unsigned char *)data),
         (size_t )dlen);
#line 392
  rdlen = dlen;
#line 393
  *sz += (size_t )dlen;
  }
  switch_break: /* CIL Label */ ;
  }
#line 396
  if (udp) {
#line 396
    if (*sz > (size_t )*udp) {
#line 396
      if ((int )section == 3) {
#line 397
        *sz = osz;
      } else {
#line 396
        goto _L___0;
      }
    } else {
#line 396
      goto _L___0;
    }
  } else {
    _L___0: /* CIL Label */ 
    {
#line 399
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 399
      t_s = type;
#line 399
      t_cp = rrht;
#line 399
      tmp___2 = t_cp;
#line 399
      t_cp ++;
#line 399
      *tmp___2 = (unsigned char )((int )t_s >> 8);
#line 399
      tmp___3 = t_cp;
#line 399
      t_cp ++;
#line 399
      *tmp___3 = (unsigned char )t_s;
#line 399
      rrht = (unsigned char *)((void *)t_cp);
#line 399
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 400
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 400
      t_s___0 = (uint16_t )1;
#line 400
      t_cp___0 = rrht;
#line 400
      tmp___4 = t_cp___0;
#line 400
      t_cp___0 ++;
#line 400
      *tmp___4 = (unsigned char )((int )t_s___0 >> 8);
#line 400
      tmp___5 = t_cp___0;
#line 400
      t_cp___0 ++;
#line 400
      *tmp___5 = (unsigned char )t_s___0;
#line 400
      rrht = (unsigned char *)((void *)t_cp___0);
#line 400
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 401
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 401
      t_l = ttl;
#line 401
      t_cp___1 = rrht;
#line 401
      tmp___6 = t_cp___1;
#line 401
      t_cp___1 ++;
#line 401
      *tmp___6 = (unsigned char )(t_l >> 24);
#line 401
      tmp___7 = t_cp___1;
#line 401
      t_cp___1 ++;
#line 401
      *tmp___7 = (unsigned char )(t_l >> 16);
#line 401
      tmp___8 = t_cp___1;
#line 401
      t_cp___1 ++;
#line 401
      *tmp___8 = (unsigned char )(t_l >> 8);
#line 401
      tmp___9 = t_cp___1;
#line 401
      t_cp___1 ++;
#line 401
      *tmp___9 = (unsigned char )t_l;
#line 401
      rrht = (unsigned char *)((void *)t_cp___1);
#line 401
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 402
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 402
      t_s___1 = (uint16_t )rdlen;
#line 402
      t_cp___2 = rrht;
#line 402
      tmp___10 = t_cp___2;
#line 402
      t_cp___2 ++;
#line 402
      *tmp___10 = (unsigned char )((int )t_s___1 >> 8);
#line 402
      tmp___11 = t_cp___2;
#line 402
      t_cp___2 ++;
#line 402
      *tmp___11 = (unsigned char )t_s___1;
#line 402
      rrht = (unsigned char *)((void *)t_cp___2);
#line 402
      goto while_break___3;
    }
    while_break___3: /* CIL Label */ ;
    }
    {
#line 405
    if ((int )section == 1) {
#line 405
      goto case_1;
    }
#line 408
    if ((int )section == 2) {
#line 408
      goto case_2___0;
    }
#line 411
    if ((int )section == 3) {
#line 411
      goto case_3___0;
    }
#line 404
    goto switch_break___0;
    case_1: /* CIL Label */ 
    {
#line 406
    tmp___12 = ntohs((*ans)->hdr.ancount);
#line 406
    (*ans)->hdr.ancount = htons((uint16_t )((int )tmp___12 + 1));
    }
#line 407
    goto switch_break___0;
    case_2___0: /* CIL Label */ 
    {
#line 409
    tmp___13 = ntohs((*ans)->hdr.nscount);
#line 409
    (*ans)->hdr.nscount = htons((uint16_t )((int )tmp___13 + 1));
    }
#line 410
    goto switch_break___0;
    case_3___0: /* CIL Label */ 
    {
#line 412
    tmp___14 = ntohs((*ans)->hdr.arcount);
#line 412
    (*ans)->hdr.arcount = htons((uint16_t )((int )tmp___14 + 1));
    }
#line 413
    goto switch_break___0;
    switch_break___0: /* CIL Label */ ;
    }
  }
#line 417
  return (1);
}
}
#line 423 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/dns_answer.c"
int add_opt_pseudo_rr(dns_msg_t **ans , size_t *sz , size_t *allocsz , unsigned short udpsize ,
                      unsigned short rcode , unsigned short ednsver , unsigned short Zflags ) 
{ 
  unsigned char *ptr ;
  size_t newsz ;
  size_t newallocsz ;
  dns_msg_t *newans ;
  void *tmp ;
  unsigned char *tmp___0 ;
  register uint16_t t_s ;
  register unsigned char *t_cp ;
  unsigned char *tmp___1 ;
  unsigned char *tmp___2 ;
  register uint16_t t_s___0 ;
  register unsigned char *t_cp___0 ;
  unsigned char *tmp___3 ;
  unsigned char *tmp___4 ;
  unsigned char *tmp___5 ;
  unsigned char *tmp___6 ;
  register uint16_t t_s___1 ;
  register unsigned char *t_cp___1 ;
  unsigned char *tmp___7 ;
  unsigned char *tmp___8 ;
  register uint16_t t_s___2 ;
  register unsigned char *t_cp___2 ;
  unsigned char *tmp___9 ;
  unsigned char *tmp___10 ;
  uint16_t tmp___11 ;

  {
#line 428
  newsz = (2UL + *sz) + 11UL;
#line 429
  if (newsz > *allocsz) {
    {
#line 433
    newallocsz = (newsz + 127UL) & 0xffffffffffffff80UL;
#line 434
    tmp = realloc((void *)*ans, newallocsz);
#line 434
    newans = (dns_msg_t *)tmp;
    }
#line 435
    if (! newans) {
#line 436
      return (0);
    }
#line 437
    *ans = newans;
#line 438
    *allocsz = newallocsz;
  }
#line 441
  ptr = (unsigned char *)(& (*ans)->hdr) + *sz;
#line 442
  tmp___0 = ptr;
#line 442
  ptr ++;
#line 442
  *tmp___0 = (unsigned char)0;
  {
#line 443
  while (1) {
    while_continue: /* CIL Label */ ;
#line 443
    t_s = (uint16_t )41;
#line 443
    t_cp = ptr;
#line 443
    tmp___1 = t_cp;
#line 443
    t_cp ++;
#line 443
    *tmp___1 = (unsigned char )((int )t_s >> 8);
#line 443
    tmp___2 = t_cp;
#line 443
    t_cp ++;
#line 443
    *tmp___2 = (unsigned char )t_s;
#line 443
    ptr = (unsigned char *)((void *)t_cp);
#line 443
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 444
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 444
    t_s___0 = udpsize;
#line 444
    t_cp___0 = ptr;
#line 444
    tmp___3 = t_cp___0;
#line 444
    t_cp___0 ++;
#line 444
    *tmp___3 = (unsigned char )((int )t_s___0 >> 8);
#line 444
    tmp___4 = t_cp___0;
#line 444
    t_cp___0 ++;
#line 444
    *tmp___4 = (unsigned char )t_s___0;
#line 444
    ptr = (unsigned char *)((void *)t_cp___0);
#line 444
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 445
  tmp___5 = ptr;
#line 445
  ptr ++;
#line 445
  *tmp___5 = (unsigned char )((int )rcode >> 4);
#line 446
  tmp___6 = ptr;
#line 446
  ptr ++;
#line 446
  *tmp___6 = (unsigned char )ednsver;
  {
#line 447
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 447
    t_s___1 = Zflags;
#line 447
    t_cp___1 = ptr;
#line 447
    tmp___7 = t_cp___1;
#line 447
    t_cp___1 ++;
#line 447
    *tmp___7 = (unsigned char )((int )t_s___1 >> 8);
#line 447
    tmp___8 = t_cp___1;
#line 447
    t_cp___1 ++;
#line 447
    *tmp___8 = (unsigned char )t_s___1;
#line 447
    ptr = (unsigned char *)((void *)t_cp___1);
#line 447
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 448
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 448
    t_s___2 = (uint16_t )0;
#line 448
    t_cp___2 = ptr;
#line 448
    tmp___9 = t_cp___2;
#line 448
    t_cp___2 ++;
#line 448
    *tmp___9 = (unsigned char )((int )t_s___2 >> 8);
#line 448
    tmp___10 = t_cp___2;
#line 448
    t_cp___2 ++;
#line 448
    *tmp___10 = (unsigned char )t_s___2;
#line 448
    ptr = (unsigned char *)((void *)t_cp___2);
#line 448
    goto while_break___2;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 451
  *sz += 11UL;
#line 453
  tmp___11 = ntohs((*ans)->hdr.arcount);
#line 453
  (*ans)->hdr.arcount = htons((uint16_t )((int )tmp___11 + 1));
  }
#line 454
  return (1);
}
}
#line 462 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/dns_answer.c"
size_t remove_opt_pseudo_rr(dns_msg_t *ans , size_t sz ) 
{ 
  uint16_t acnt ;
  uint16_t tmp ;
  uint16_t type ;
  unsigned char *ptr ;
  unsigned char *tmp___0 ;
  register uint16_t t_s ;
  register unsigned char const   *t_cp ;
  unsigned char const   *tmp___1 ;
  unsigned char const   *tmp___2 ;

  {
  {
#line 464
  tmp = ntohs(ans->hdr.arcount);
#line 464
  acnt = tmp;
  }
#line 467
  if ((int )acnt > 0) {
#line 467
    if (! (sz >= sizeof(dns_hdr_t ) + 11UL)) {
#line 468
      return ((size_t )0);
    }
  } else {
#line 468
    return ((size_t )0);
  }
#line 469
  sz -= 11UL;
#line 470
  ptr = (unsigned char *)(& ans->hdr) + sz;
#line 471
  tmp___0 = ptr;
#line 471
  ptr ++;
#line 471
  if (*tmp___0) {
#line 472
    return ((size_t )0);
  }
  {
#line 473
  while (1) {
    while_continue: /* CIL Label */ ;
#line 473
    t_cp = (unsigned char const   *)ptr;
#line 473
    tmp___1 = t_cp;
#line 473
    t_cp ++;
#line 473
    t_s = (uint16_t )((int )((uint16_t )*tmp___1) << 8);
#line 473
    tmp___2 = t_cp;
#line 473
    t_cp ++;
#line 473
    t_s = (uint16_t )((int )t_s | (int )((uint16_t )*tmp___2));
#line 473
    type = t_s;
#line 473
    ptr = (unsigned char *)((void *)t_cp);
#line 473
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 474
  if ((int )type != 41) {
#line 475
    return ((size_t )0);
  }
  {
#line 477
  ans->hdr.arcount = htons((uint16_t )((int )acnt - 1));
  }
#line 478
  return (sz);
}
}
#line 495 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/dns_answer.c"
static int add_ar(dlist *ar , unsigned short tp , unsigned short tsz , void *tnm ,
                  unsigned char *nm , uint32_t ttl ) 
{ 
  rr_ext_t *re ;
  unsigned char *p ;
  size_t nmsz ;
  size_t size ;
  unsigned int tmp ;
  dlist tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;

  {
#line 499
  nmsz = (size_t )0;
#line 499
  size = sizeof(rr_ext_t ) + (unsigned long )tsz;
#line 500
  if ((int )tp == 2) {
    {
#line 501
    tmp = rhnlen((unsigned char const   *)nm);
#line 501
    nmsz = (size_t )tmp;
#line 502
    size += nmsz;
    }
  } else
#line 500
  if ((int )tp == 6) {
    {
#line 501
    tmp = rhnlen((unsigned char const   *)nm);
#line 501
    nmsz = (size_t )tmp;
#line 502
    size += nmsz;
    }
  }
  {
#line 504
  tmp___0 = dlist_grow(*ar, size);
#line 504
  *ar = tmp___0;
  }
#line 504
  if (! tmp___0) {
#line 505
    return (0);
  }
  {
#line 506
  tmp___1 = dlist_last(*ar);
#line 506
  re = (rr_ext_t *)tmp___1;
#line 507
  re->tp = tp;
#line 508
  re->tsz = tsz;
#line 509
  re->ttl = ttl;
#line 510
  tmp___2 = mempcpy((void */* __restrict  */)(re->tnm), (void const   */* __restrict  */)tnm,
                    (size_t )tsz);
#line 510
  p = (unsigned char *)tmp___2;
  }
#line 511
  if ((int )tp == 2) {
    {
#line 512
    memcpy((void */* __restrict  */)p, (void const   */* __restrict  */)nm, nmsz);
    }
  } else
#line 511
  if ((int )tp == 6) {
    {
#line 512
    memcpy((void */* __restrict  */)p, (void const   */* __restrict  */)nm, nmsz);
    }
  }
#line 514
  return (1);
}
}
#line 519 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/dns_answer.c"
__inline static rr_bucket_t *randrr(rr_bucket_t *rrb ) 
{ 
  rr_bucket_t *rr ;
  unsigned int cnt ;
  long tmp ;

  {
#line 522
  cnt = 0U;
#line 525
  rr = rrb;
  {
#line 525
  while (1) {
    while_continue: /* CIL Label */ ;
#line 525
    if (! rr) {
#line 525
      goto while_break;
    }
#line 525
    cnt ++;
#line 525
    rr = rr->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 529
  if (cnt) {
    {
#line 529
    tmp = random();
#line 529
    cnt = (unsigned int )(tmp % (long )cnt);
    }
    {
#line 529
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 529
      if (! cnt) {
#line 529
        goto while_break___0;
      }
#line 529
      rrb = rrb->next;
#line 529
      cnt --;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 531
  return (rrb);
}
}
#line 539 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/dns_answer.c"
static int const   ar_recs[6]  = {      (int const   )2,      (int const   )3,      (int const   )4,      (int const   )7, 
        (int const   )15,      (int const   )33};
#line 545 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/dns_answer.c"
static int const   ar_offs[6]  = {      (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )2,      (int const   )6};
#line 554 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/dns_answer.c"
static int add_rrset(dns_msg_t **ans , size_t *sz , size_t *allocsz , unsigned char *rrn ,
                     unsigned int tp , time_t queryts , dns_cent_t *cached , unsigned int *udp ,
                     dlist *cb , dlist *sva , dlist *ar ) 
{ 
  rr_set_t *crrset ;
  rr_set_t *tmp ;
  rr_bucket_t *b ;
  rr_bucket_t *first ;
  int i ;
  short rnd_recs ;
  time_t tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  {
#line 558
  tmp = getrrset(cached, (int )tp);
#line 558
  crrset = tmp;
  }
#line 560
  if (crrset) {
#line 560
    if (crrset->rrs) {
#line 562
      first = (rr_bucket_t *)((void *)0);
#line 564
      rnd_recs = (short )global.rnd_recs;
#line 566
      b = crrset->rrs;
#line 567
      if (rnd_recs) {
        {
#line 567
        first = randrr(crrset->rrs);
#line 567
        b = first;
        }
      }
      {
#line 569
      while (1) {
        while_continue: /* CIL Label */ ;
#line 569
        if (! b) {
#line 569
          goto while_break;
        }
        {
#line 570
        tmp___0 = ans_ttl(crrset, queryts);
#line 570
        tmp___1 = add_rr(ans, sz, allocsz, rrn, (unsigned short )tp, (uint32_t )tmp___0,
                         b->rdlen, (void *)(b->data), (char)1, udp, cb);
        }
#line 570
        if (! tmp___1) {
#line 572
          return (0);
        }
#line 573
        if (tp == 2U) {
#line 573
          goto _L;
        } else
#line 573
        if (tp == 1U) {
#line 573
          goto _L;
        } else
#line 573
        if (tp == 28U) {
          _L: /* CIL Label */ 
          {
#line 575
          tmp___2 = sva_add(sva, (unsigned char const   *)rrn, (unsigned short )tp,
                            (unsigned short )b->rdlen, (void *)(b->data));
          }
#line 575
          if (! tmp___2) {
#line 576
            return (0);
          }
        }
#line 579
        i = 0;
        {
#line 579
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 579
          if (! (i < 6)) {
#line 579
            goto while_break___0;
          }
#line 580
          if ((unsigned int )ar_recs[i] == tp) {
            {
#line 581
            tmp___3 = add_ar(ar, (unsigned short)0, (unsigned short )(b->rdlen - (unsigned int )ar_offs[i]),
                             (void *)((unsigned char *)(b->data) + ar_offs[i]), (unsigned char *)"",
                             (uint32_t )0);
            }
#line 581
            if (! tmp___3) {
#line 583
              return (0);
            }
#line 584
            goto while_break___0;
          }
#line 579
          i ++;
        }
        while_break___0: /* CIL Label */ ;
        }
#line 587
        b = b->next;
#line 588
        if (rnd_recs) {
#line 589
          if (! b) {
#line 589
            b = crrset->rrs;
          }
#line 590
          if ((unsigned long )b == (unsigned long )first) {
#line 590
            goto while_break;
          }
        }
      }
      while_break: /* CIL Label */ ;
      }
    }
  }
#line 594
  return (1);
}
}
#line 605 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/dns_answer.c"
static int add_to_response(dns_msg_t **ans , size_t *sz , size_t *allocsz , unsigned char *rrn ,
                           unsigned int qtype , time_t queryts , dns_cent_t *cached ,
                           unsigned int *udp , dlist *cb , dlist *sva , dlist *ar ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int i ;
  int n ;
  int tmp___6 ;
  int tmp___7 ;
  unsigned short const   *iterlist ;
  unsigned short const   *tmp___8 ;
  unsigned short const   *tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;

  {
#line 611
  if (qtype != 5U) {
#line 611
    if (qtype != 255U) {
#line 611
      if (qtype >= 1U) {
#line 611
        if (qtype <= 51U) {
          {
#line 611
          tmp___0 = have_rr(cached, (int )qtype);
          }
#line 611
          if (! tmp___0) {
#line 611
            goto _L___0;
          }
        } else {
#line 611
          goto _L___0;
        }
      } else {
        _L___0: /* CIL Label */ 
        {
#line 612
        tmp = add_rrset(ans, sz, allocsz, rrn, 5U, queryts, cached, udp, cb, sva,
                        ar);
        }
#line 612
        if (! tmp) {
#line 613
          return (0);
        }
      }
    }
  }
#line 616
  if (qtype == 252U) {
#line 623
    return (0);
  } else
#line 616
  if (qtype == 251U) {
#line 623
    return (0);
  } else
#line 624
  if (qtype == 253U) {
    {
#line 625
    tmp___1 = add_rrset(ans, sz, allocsz, rrn, 7U, queryts, cached, udp, cb, sva,
                        ar);
    }
#line 625
    if (! tmp___1) {
#line 626
      return (0);
    }
    {
#line 627
    tmp___2 = add_rrset(ans, sz, allocsz, rrn, 8U, queryts, cached, udp, cb, sva,
                        ar);
    }
#line 627
    if (! tmp___2) {
#line 628
      return (0);
    }
    {
#line 629
    tmp___3 = add_rrset(ans, sz, allocsz, rrn, 9U, queryts, cached, udp, cb, sva,
                        ar);
    }
#line 629
    if (! tmp___3) {
#line 630
      return (0);
    }
  } else
#line 631
  if (qtype == 254U) {
    {
#line 632
    tmp___4 = add_rrset(ans, sz, allocsz, rrn, 3U, queryts, cached, udp, cb, sva,
                        ar);
    }
#line 632
    if (! tmp___4) {
#line 633
      return (0);
    }
    {
#line 634
    tmp___5 = add_rrset(ans, sz, allocsz, rrn, 4U, queryts, cached, udp, cb, sva,
                        ar);
    }
#line 634
    if (! tmp___5) {
#line 635
      return (0);
    }
  } else
#line 636
  if (qtype == 255U) {
#line 637
    if ((int )cached->flags & 1) {
#line 637
      tmp___7 = 0;
    } else {
#line 637
      if (cached->__annonCompField2.rr.rrext) {
#line 637
        tmp___6 = 47;
      } else {
#line 637
        tmp___6 = 8;
      }
#line 637
      tmp___7 = tmp___6;
    }
#line 637
    n = tmp___7;
#line 638
    if ((int )cached->flags & 1) {
#line 638
      tmp___9 = (unsigned short const   *)((void *)0);
    } else {
#line 638
      if (cached->__annonCompField2.rr.rrext) {
#line 638
        tmp___8 = rrcachiterlist;
      } else {
#line 638
        tmp___8 = rrmuiterlist;
      }
#line 638
      tmp___9 = tmp___8;
    }
#line 638
    iterlist = tmp___9;
#line 639
    i = 0;
    {
#line 639
    while (1) {
      while_continue: /* CIL Label */ ;
#line 639
      if (! (i < n)) {
#line 639
        goto while_break;
      }
      {
#line 640
      tmp___10 = add_rrset(ans, sz, allocsz, rrn, (unsigned int )*(iterlist + i),
                           queryts, cached, udp, cb, sva, ar);
      }
#line 640
      if (! tmp___10) {
#line 641
        return (0);
      }
#line 639
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  } else
#line 643
  if (qtype >= 1U) {
#line 643
    if (qtype <= 51U) {
      {
#line 644
      tmp___11 = add_rrset(ans, sz, allocsz, rrn, qtype, queryts, cached, udp, cb,
                           sva, ar);
      }
#line 644
      if (! tmp___11) {
#line 645
        return (0);
      }
    } else {
#line 647
      return (0);
    }
  } else {
#line 647
    return (0);
  }
#line 656
  return (1);
}
}
#line 662 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/dns_answer.c"
static int add_additional_rr(dns_msg_t **ans , size_t *rlen , size_t *allocsz , unsigned char *rhn ,
                             unsigned int tp , time_t ttl , unsigned int dlen , void *data ,
                             int sect , unsigned int *udp , dlist *cb , dlist *sva ) 
{ 
  sva_t *st ;
  void *tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  unsigned char *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
  {
#line 669
  tmp = dlist_first(*sva);
#line 669
  st = (sva_t *)tmp;
  }
  {
#line 669
  while (1) {
    while_continue: /* CIL Label */ ;
#line 669
    if (! st) {
#line 669
      goto while_break;
    }
#line 670
    if ((unsigned int )st->tp == tp) {
      {
#line 670
      tmp___1 = rhnicmp((unsigned char const   *)(st->nm), (unsigned char const   *)rhn);
      }
#line 670
      if (tmp___1) {
#line 670
        if ((unsigned int )st->dlen == dlen) {
          {
#line 670
          tmp___2 = skiprhn(st->nm);
#line 670
          tmp___3 = memcmp((void const   *)tmp___2, (void const   *)data, (size_t )dlen);
          }
#line 670
          if (tmp___3 == 0) {
#line 673
            return (1);
          }
        }
      }
    }
    {
#line 669
    tmp___0 = dlist_next((void *)st);
#line 669
    st = (sva_t *)tmp___0;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 677
  tmp___4 = add_rr(ans, rlen, allocsz, rhn, (unsigned short )tp, (uint32_t )ttl, dlen,
                   data, (char )sect, udp, cb);
  }
#line 677
  if (! tmp___4) {
#line 678
    return (0);
  }
  {
#line 680
  tmp___5 = sva_add(sva, (unsigned char const   *)rhn, (unsigned short )tp, (unsigned short )dlen,
                    data);
  }
#line 680
  if (! tmp___5) {
#line 681
    return (0);
  }
#line 683
  return (1);
}
}
#line 689 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/dns_answer.c"
static int add_additional_rrs(dns_msg_t **ans , size_t *rlen , size_t *allocsz , unsigned char *rhn ,
                              unsigned int tp , time_t ttl , rr_bucket_t *rrb , int sect ,
                              unsigned int *udp , dlist *cb , dlist *sva ) 
{ 
  rr_bucket_t *rr ;
  rr_bucket_t *first ;
  short rnd_recs ;
  int tmp ;

  {
#line 694
  first = (rr_bucket_t *)((void *)0);
#line 695
  rnd_recs = (short )global.rnd_recs;
#line 697
  rr = rrb;
#line 698
  if (rnd_recs) {
    {
#line 698
    first = randrr(rrb);
#line 698
    rr = first;
    }
  }
  {
#line 700
  while (1) {
    while_continue: /* CIL Label */ ;
#line 700
    if (! rr) {
#line 700
      goto while_break;
    }
    {
#line 701
    tmp = add_additional_rr(ans, rlen, allocsz, rhn, tp, ttl, rr->rdlen, (void *)(rr->data),
                            sect, udp, cb, sva);
    }
#line 701
    if (! tmp) {
#line 702
      return (0);
    }
#line 703
    rr = rr->next;
#line 704
    if (rnd_recs) {
#line 705
      if (! rr) {
#line 705
        rr = rrb;
      }
#line 706
      if ((unsigned long )rr == (unsigned long )first) {
#line 706
        goto while_break;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 709
  return (1);
}
}
#line 715 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/dns_answer.c"
static int add_additional_a(dns_msg_t **ans , size_t *rlen , size_t *allocsz , unsigned char *rhn ,
                            time_t queryts , unsigned int *udp , dlist *cb , dlist *sva ) 
{ 
  dns_cent_t *ae ;
  int retval ;
  rr_set_t *rrset ;
  rr_bucket_t *rr ;
  time_t tmp ;
  int tmp___0 ;
  time_t tmp___1 ;
  int tmp___2 ;

  {
  {
#line 720
  retval = 1;
#line 722
  ae = lookup_cache((unsigned char const   *)rhn, (int *)((void *)0));
  }
#line 722
  if (ae) {
#line 724
    if (! ((int )ae->flags & 1)) {
#line 724
      rrset = ae->__annonCompField2.rr.rrmu[0];
    } else {
#line 724
      rrset = (rr_set_t *)((void *)0);
    }
#line 725
    if (rrset) {
#line 725
      rr = rrset->rrs;
#line 725
      if (rr) {
        {
#line 726
        tmp = ans_ttl(rrset, queryts);
#line 726
        tmp___0 = add_additional_rrs(ans, rlen, allocsz, rhn, 1U, tmp, rr, 3, udp,
                                     cb, sva);
        }
#line 726
        if (! tmp___0) {
#line 729
          retval = 0;
        }
      }
    }
#line 732
    if (retval) {
#line 733
      if (! ((int )ae->flags & 1)) {
#line 733
        rrset = ae->__annonCompField2.rr.rrmu[7];
      } else {
#line 733
        rrset = (rr_set_t *)((void *)0);
      }
#line 734
      if (rrset) {
#line 734
        rr = rrset->rrs;
#line 734
        if (rr) {
          {
#line 735
          tmp___1 = ans_ttl(rrset, queryts);
#line 735
          tmp___2 = add_additional_rrs(ans, rlen, allocsz, rhn, 28U, tmp___1, rr,
                                       3, udp, cb, sva);
          }
#line 735
          if (! tmp___2) {
#line 738
            retval = 0;
          }
        }
      }
    }
    {
#line 741
    free_cent(ae);
#line 742
    free((void *)ae);
    }
  }
#line 744
  return (retval);
}
}
#line 752 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/dns_answer.c"
static dns_msg_t *compose_answer(llist *ql , dns_hdr_t *hdr , size_t *rlen , edns_info_t *ednsinfo ,
                                 unsigned int *udp , int *rcodep ) 
{ 
  unsigned short rcode ;
  unsigned short aa ;
  dlist cb ;
  dlist sva ;
  dlist ar ;
  time_t queryts ;
  time_t tmp ;
  dns_queryel_t *qe ;
  dns_msg_t *ans ;
  size_t allocsz ;
  dns_cent_t *cached ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  unsigned int qclen ;
  size_t newsz ;
  unsigned int tmp___3 ;
  size_t newallocsz ;
  dns_msg_t *newans ;
  void *tmp___4 ;
  unsigned char *p ;
  register uint16_t t_s ;
  register unsigned char *t_cp ;
  unsigned char *tmp___5 ;
  unsigned char *tmp___6 ;
  register uint16_t t_s___0 ;
  register unsigned char *t_cp___0 ;
  unsigned char *tmp___7 ;
  unsigned char *tmp___8 ;
  uint16_t tmp___9 ;
  void *tmp___10 ;
  void *tmp___11 ;
  void *tmp___12 ;
  void *tmp___13 ;
  int hops ;
  unsigned char qname[256] ;
  int rc ;
  unsigned char c_soa ;
  unsigned int scnt ;
  unsigned int tmp___14 ;
  rr_set_t *rrset ;
  rr_set_t *tmp___15 ;
  rr_bucket_t *rr ;
  time_t tmp___16 ;
  int tmp___17 ;
  unsigned char const   *tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  rr_set_t *rrset___0 ;
  int rretp ;
  int tmp___21 ;
  dns_cent_t *prev ;
  unsigned int scnt___0 ;
  unsigned int tmp___22 ;
  unsigned int tcnt ;
  int tmp___23 ;
  unsigned char const   *tmp___24 ;
  unsigned char const   *tmp___25 ;
  unsigned char *nm ;
  unsigned char *tmp___26 ;
  rr_bucket_t *rr___0 ;
  time_t tmp___27 ;
  int tmp___28 ;
  int tmp___29 ;
  int tmp___30 ;
  rr_ext_t *rre ;
  void *tmp___31 ;
  void *tmp___32 ;
  unsigned char *nm___0 ;
  int tmp___33 ;
  int tmp___34 ;
  void *tmp___35 ;
  void *tmp___36 ;
  int tmp___37 ;

  {
  {
#line 754
  rcode = (unsigned short)0;
#line 754
  aa = (unsigned short)1;
#line 755
  cb = (dlist )((void *)0);
#line 756
  sva = (dlist )((void *)0);
#line 757
  ar = (dlist )((void *)0);
#line 758
  tmp = time((time_t *)((void *)0));
#line 758
  queryts = tmp;
#line 761
  allocsz = (size_t )256;
#line 764
  tmp___0 = malloc(allocsz);
#line 764
  ans = (dns_msg_t *)tmp___0;
  }
#line 765
  if (! ans) {
#line 766
    goto return_ans;
  }
  {
#line 767
  ans->hdr.id = hdr->id;
#line 768
  ans->hdr.qr = 1U;
#line 769
  ans->hdr.opcode = 0U;
#line 770
  ans->hdr.aa = 0U;
#line 771
  ans->hdr.tc = 0U;
#line 772
  ans->hdr.rd = hdr->rd;
#line 773
  ans->hdr.ra = 1U;
#line 774
  ans->hdr.z = 0U;
#line 775
  ans->hdr.ad = 0U;
#line 776
  ans->hdr.cd = 0U;
#line 777
  ans->hdr.rcode = (unsigned int )rcode;
#line 778
  ans->hdr.qdcount = (uint16_t )0;
#line 779
  ans->hdr.ancount = (uint16_t )0;
#line 780
  ans->hdr.nscount = (uint16_t )0;
#line 781
  ans->hdr.arcount = (uint16_t )0;
#line 783
  *rlen = sizeof(dns_hdr_t );
#line 785
  tmp___1 = llist_first(ql);
#line 785
  qe = (dns_queryel_t *)tmp___1;
  }
  {
#line 785
  while (1) {
    while_continue: /* CIL Label */ ;
#line 785
    if (! qe) {
#line 785
      goto while_break;
    }
    {
#line 787
    tmp___3 = rhnlen((unsigned char const   *)(qe->query));
#line 787
    newsz = ((2UL + *rlen) + (size_t )tmp___3) + 4UL;
    }
#line 788
    if (newsz > allocsz) {
      {
#line 792
      newallocsz = (newsz + 127UL) & 0xffffffffffffff80UL;
#line 793
      tmp___4 = realloc((void *)ans, newallocsz);
#line 793
      newans = (dns_msg_t *)tmp___4;
      }
#line 794
      if (! newans) {
#line 795
        goto error_ans;
      }
#line 796
      ans = newans;
#line 797
      allocsz = newallocsz;
    }
    {
#line 801
    p = (unsigned char *)(& ans->hdr) + *rlen;
#line 804
    qclen = compress_name(qe->query, p, (unsigned int )*rlen, & cb);
    }
#line 804
    if (! qclen) {
#line 805
      goto error_ans;
    }
#line 806
    p += qclen;
    {
#line 807
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 807
      t_s = qe->qtype;
#line 807
      t_cp = p;
#line 807
      tmp___5 = t_cp;
#line 807
      t_cp ++;
#line 807
      *tmp___5 = (unsigned char )((int )t_s >> 8);
#line 807
      tmp___6 = t_cp;
#line 807
      t_cp ++;
#line 807
      *tmp___6 = (unsigned char )t_s;
#line 807
      p = (unsigned char *)((void *)t_cp);
#line 807
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 808
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 808
      t_s___0 = qe->qclass;
#line 808
      t_cp___0 = p;
#line 808
      tmp___7 = t_cp___0;
#line 808
      t_cp___0 ++;
#line 808
      *tmp___7 = (unsigned char )((int )t_s___0 >> 8);
#line 808
      tmp___8 = t_cp___0;
#line 808
      t_cp___0 ++;
#line 808
      *tmp___8 = (unsigned char )t_s___0;
#line 808
      p = (unsigned char *)((void *)t_cp___0);
#line 808
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 810
    *rlen += (size_t )(qclen + 4U);
#line 811
    tmp___9 = ntohs(ans->hdr.qdcount);
#line 811
    ans->hdr.qdcount = htons((uint16_t )((int )tmp___9 + 1));
#line 785
    tmp___2 = llist_next((void *)qe);
#line 785
    qe = (dns_queryel_t *)tmp___2;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 815
  tmp___10 = llist_first(ql);
#line 815
  qe = (dns_queryel_t *)tmp___10;
  }
  {
#line 815
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 815
    if (! qe) {
#line 815
      goto while_break___2;
    }
#line 816
    if ((int )qe->qtype < 1) {
#line 816
      goto _L___1;
    } else
#line 816
    if ((int )qe->qtype > 51) {
#line 816
      goto _L___1;
    } else
#line 816
    if ((int const   )rrlkuptab[(int )qe->qtype - 1] >= 47) {
      _L___1: /* CIL Label */ 
#line 816
      if ((int )qe->qtype != 253) {
#line 816
        if ((int )qe->qtype != 254) {
#line 816
          if ((int )qe->qtype != 255) {
#line 816
            goto _L;
          } else {
#line 816
            goto _L___0;
          }
        } else {
#line 816
          goto _L___0;
        }
      } else {
#line 816
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 816
    if ((int )qe->qclass != 1) {
#line 816
      if ((int )qe->qclass != 255) {
        _L: /* CIL Label */ 
#line 820
        if (debug_p) {
          {
#line 820
          debug_msg(0, "Unsupported QTYPE or QCLASS.\n");
          }
        }
#line 821
        rcode = (unsigned short)4;
#line 821
        ans->hdr.rcode = (unsigned int )rcode;
#line 822
        goto cleanup_return;
      }
    }
    {
#line 815
    tmp___11 = llist_next((void *)qe);
#line 815
    qe = (dns_queryel_t *)tmp___11;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 827
  tmp___12 = llist_first(ql);
#line 827
  qe = (dns_queryel_t *)tmp___12;
  }
  {
#line 827
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 827
    if (! qe) {
#line 827
      goto while_break___3;
    }
    {
#line 831
    rhncpy(qname, (unsigned char const   *)(qe->query));
#line 833
    hops = 20;
    }
    {
#line 834
    while (1) {
      while_continue___4: /* CIL Label */ ;
      {
#line 836
      c_soa = (unsigned char)255;
#line 837
      rc = r_dns_cached_resolve(qname, (int )qe->qtype, & cached, 20, (qhintnode_t *)((void *)0),
                                queryts, & c_soa);
      }
#line 837
      if (rc != 0) {
#line 838
        rcode = (unsigned short )rc;
#line 838
        ans->hdr.rcode = (unsigned int )rcode;
#line 839
        if (rc == 3) {
#line 840
          if ((int )c_soa != 255) {
            {
#line 842
            tmp___14 = rhnsegcnt((unsigned char const   *)(qname));
#line 842
            scnt = tmp___14;
            }
#line 843
            if ((unsigned int )c_soa < scnt) {
              {
#line 843
              tmp___18 = skipsegs((unsigned char const   *)(qname), scnt - (unsigned int )c_soa);
#line 843
              cached = lookup_cache(tmp___18, (int *)((void *)0));
              }
#line 843
              if (cached) {
#line 844
                if (! ((int )cached->flags & 1)) {
#line 844
                  tmp___15 = cached->__annonCompField2.rr.rrmu[3];
                } else {
#line 844
                  tmp___15 = (rr_set_t *)((void *)0);
                }
#line 844
                rrset = tmp___15;
#line 845
                if (rrset) {
#line 845
                  if (! ((int )rrset->flags & 1)) {
#line 847
                    rr = rrset->rrs;
                    {
#line 847
                    while (1) {
                      while_continue___5: /* CIL Label */ ;
#line 847
                      if (! rr) {
#line 847
                        goto while_break___5;
                      }
                      {
#line 848
                      tmp___16 = ans_ttl(rrset, queryts);
#line 848
                      tmp___17 = add_rr(& ans, rlen, & allocsz, cached->qname, (unsigned short)6,
                                        (uint32_t )tmp___16, rr->rdlen, (void *)(rr->data),
                                        (char)2, udp, & cb);
                      }
#line 848
                      if (! tmp___17) {
#line 850
                        goto error_cached;
                      }
#line 847
                      rr = rr->next;
                    }
                    while_break___5: /* CIL Label */ ;
                    }
                  }
                }
                {
#line 853
                free_cent(cached);
#line 854
                free((void *)cached);
                }
              }
            }
          }
#line 859
          if (ednsinfo) {
            {
#line 860
            tmp___19 = add_opt_pseudo_rr(& ans, rlen, & allocsz, (unsigned short )global.udpbufsize,
                                         rcode, (unsigned short)0, (unsigned short)0);
            }
#line 860
            if (! tmp___19) {
#line 861
              goto error_ans;
            }
          }
        }
#line 864
        goto cleanup_return;
      }
#line 866
      if (! ((int )cached->flags & 2)) {
#line 867
        aa = (unsigned short)0;
      }
      {
#line 869
      tmp___20 = add_to_response(& ans, rlen, & allocsz, qname, (unsigned int )qe->qtype,
                                 queryts, cached, udp, & cb, & sva, & ar);
      }
#line 869
      if (! tmp___20) {
#line 870
        goto error_cached;
      }
#line 871
      if (hdr->rd) {
#line 871
        if ((int )qe->qtype != 5) {
#line 871
          if ((int )qe->qtype != 255) {
#line 871
            if ((int )qe->qtype >= 1) {
#line 871
              if ((int )qe->qtype <= 51) {
                {
#line 871
                tmp___29 = have_rr(cached, (int )qe->qtype);
                }
#line 871
                if (tmp___29) {
#line 871
                  goto _L___21;
                } else {
#line 871
                  goto _L___19;
                }
              } else {
#line 871
                goto _L___19;
              }
            } else {
              _L___19: /* CIL Label */ 
              {
#line 871
              tmp___30 = follow_cname_chain(cached, qname);
              }
#line 871
              if (! tmp___30) {
#line 871
                goto _L___21;
              }
            }
          } else {
#line 871
            goto _L___21;
          }
        } else {
#line 871
          goto _L___21;
        }
      } else {
        _L___21: /* CIL Label */ 
#line 885
        rretp = 2;
#line 886
        if ((int )qe->qtype >= 1) {
#line 886
          if ((int )qe->qtype <= 51) {
            {
#line 886
            tmp___21 = have_rr(cached, (int )qe->qtype);
            }
#line 886
            if (tmp___21) {
#line 886
              goto _L___15;
            } else {
#line 891
              rretp = 6;
            }
          } else {
#line 886
            goto _L___15;
          }
        } else
        _L___15: /* CIL Label */ 
#line 886
        if ((int )qe->qtype == 253) {
#line 886
          if (! ((int )cached->flags & 1)) {
#line 886
            if (cached->__annonCompField2.rr.rrext) {
#line 886
              if (*(cached->__annonCompField2.rr.rrext + 2)) {
#line 886
                if ((*(cached->__annonCompField2.rr.rrext + 2))->rrs) {
#line 886
                  goto _L___10;
                } else {
#line 886
                  goto _L___13;
                }
              } else {
#line 886
                goto _L___13;
              }
            } else {
#line 886
              goto _L___13;
            }
          } else
          _L___13: /* CIL Label */ 
#line 886
          if (! ((int )cached->flags & 1)) {
#line 886
            if (cached->__annonCompField2.rr.rrext) {
#line 886
              if (*(cached->__annonCompField2.rr.rrext + 3)) {
#line 886
                if ((*(cached->__annonCompField2.rr.rrext + 3))->rrs) {
#line 886
                  goto _L___10;
                } else {
#line 886
                  goto _L___9;
                }
              } else {
#line 886
                goto _L___9;
              }
            } else {
#line 886
              goto _L___9;
            }
          } else
          _L___9: /* CIL Label */ 
#line 886
          if (! ((int )cached->flags & 1)) {
#line 886
            if (cached->__annonCompField2.rr.rrext) {
#line 886
              if (*(cached->__annonCompField2.rr.rrext + 4)) {
#line 886
                if ((*(cached->__annonCompField2.rr.rrext + 4))->rrs) {
#line 886
                  goto _L___10;
                } else {
#line 891
                  rretp = 6;
                }
              } else {
#line 891
                rretp = 6;
              }
            } else {
#line 891
              rretp = 6;
            }
          } else {
#line 891
            rretp = 6;
          }
        } else
        _L___10: /* CIL Label */ 
#line 886
        if ((int )qe->qtype == 254) {
#line 886
          if (! ((int )cached->flags & 1)) {
#line 886
            if (cached->__annonCompField2.rr.rrext) {
#line 886
              if (*(cached->__annonCompField2.rr.rrext + 0)) {
#line 886
                if (! (*(cached->__annonCompField2.rr.rrext + 0))->rrs) {
#line 886
                  goto _L___4;
                }
              } else {
#line 886
                goto _L___4;
              }
            } else {
#line 886
              goto _L___4;
            }
          } else
          _L___4: /* CIL Label */ 
#line 886
          if (! ((int )cached->flags & 1)) {
#line 886
            if (cached->__annonCompField2.rr.rrext) {
#line 886
              if (*(cached->__annonCompField2.rr.rrext + 1)) {
#line 886
                if (! (*(cached->__annonCompField2.rr.rrext + 1))->rrs) {
#line 891
                  rretp = 6;
                }
              } else {
#line 891
                rretp = 6;
              }
            } else {
#line 891
              rretp = 6;
            }
          } else {
#line 891
            rretp = 6;
          }
        }
        {
#line 893
        rrset___0 = getrrset(cached, rretp);
        }
#line 894
        if (rrset___0) {
#line 894
          if ((int )rrset___0->flags & 1) {
#line 895
            rrset___0 = (rr_set_t *)((void *)0);
          }
        }
#line 896
        if (! rrset___0) {
          {
#line 899
          prev = cached;
#line 900
          tmp___22 = rhnsegcnt((unsigned char const   *)prev->qname);
#line 900
          scnt___0 = tmp___22;
          }
#line 901
          if (rretp == 2) {
#line 901
            tmp___23 = (int )prev->c_ns;
          } else {
#line 901
            tmp___23 = (int )prev->c_soa;
          }
#line 901
          tcnt = (unsigned int )tmp___23;
#line 902
          if (tcnt != 255U) {
#line 902
            if (tcnt < scnt___0) {
              {
#line 902
              tmp___24 = skipsegs((unsigned char const   *)prev->qname, scnt___0 - tcnt);
#line 902
              tmp___25 = tmp___24;
              }
            } else {
#line 902
              tmp___25 = (unsigned char const   *)prev->qname;
            }
          } else {
#line 902
            tmp___25 = (unsigned char const   *)prev->qname;
          }
          {
#line 902
          cached = lookup_cache(tmp___25, (int *)((void *)0));
          }
#line 902
          if (cached) {
            {
#line 903
            rrset___0 = getrrset(cached, rretp);
            }
#line 904
            if (rrset___0) {
#line 904
              if ((int )rrset___0->flags & 1) {
#line 905
                rrset___0 = (rr_set_t *)((void *)0);
              }
            }
          }
#line 907
          if (! rrset___0) {
#line 907
            if ((int )prev->flags & 2) {
              {
#line 908
              tmp___26 = getlocalowner(prev->qname, rretp);
#line 908
              nm = tmp___26;
              }
#line 909
              if (nm) {
#line 910
                if (cached) {
                  {
#line 911
                  free_cent(cached);
#line 912
                  free((void *)cached);
                  }
                }
                {
#line 914
                cached = lookup_cache((unsigned char const   *)nm, (int *)((void *)0));
                }
#line 914
                if (cached) {
                  {
#line 915
                  rrset___0 = getrrset(cached, rretp);
                  }
                }
              }
            }
          }
          {
#line 918
          free_cent(prev);
#line 919
          free((void *)prev);
          }
        }
#line 921
        if (rrset___0) {
#line 923
          rr___0 = rrset___0->rrs;
          {
#line 923
          while (1) {
            while_continue___6: /* CIL Label */ ;
#line 923
            if (! rr___0) {
#line 923
              goto while_break___6;
            }
            {
#line 924
            tmp___27 = ans_ttl(rrset___0, queryts);
#line 924
            tmp___28 = add_ar(& ar, (unsigned short )rretp, (unsigned short )rr___0->rdlen,
                              (void *)(rr___0->data), cached->qname, (uint32_t )tmp___27);
            }
#line 924
            if (! tmp___28) {
#line 926
              goto error_cached;
            }
#line 923
            rr___0 = rr___0->next;
          }
          while_break___6: /* CIL Label */ ;
          }
        }
#line 929
        hops = 0;
      }
#line 931
      if (cached) {
        {
#line 932
        free_cent(cached);
#line 933
        free((void *)cached);
        }
      }
#line 834
      hops --;
#line 834
      if (! (hops >= 0)) {
#line 834
        goto while_break___4;
      }
    }
    while_break___4: /* CIL Label */ ;
    }
    {
#line 827
    tmp___13 = llist_next((void *)qe);
#line 827
    qe = (dns_queryel_t *)tmp___13;
    }
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 941
  tmp___31 = dlist_first(ar);
#line 941
  rre = (rr_ext_t *)tmp___31;
  }
  {
#line 941
  while (1) {
    while_continue___7: /* CIL Label */ ;
#line 941
    if (! rre) {
#line 941
      goto while_break___7;
    }
#line 942
    if ((int )rre->tp == 2) {
#line 942
      goto _L___22;
    } else
#line 942
    if ((int )rre->tp == 6) {
      _L___22: /* CIL Label */ 
      {
#line 943
      nm___0 = rre->tnm + (int )rre->tsz;
#line 944
      tmp___33 = add_additional_rr(& ans, rlen, & allocsz, nm___0, (unsigned int )rre->tp,
                                   (time_t )rre->ttl, (unsigned int )rre->tsz, (void *)(rre->tnm),
                                   2, udp, & cb, & sva);
      }
#line 944
      if (! tmp___33) {
#line 948
        goto error_ans;
      }
    }
    {
#line 941
    tmp___32 = dlist_next((void *)rre);
#line 941
    rre = (rr_ext_t *)tmp___32;
    }
  }
  while_break___7: /* CIL Label */ ;
  }
#line 955
  if (udp) {
#line 955
    if (! (*rlen + 11UL > (size_t )*udp)) {
#line 955
      goto _L___24;
    }
  } else {
    _L___24: /* CIL Label */ 
#line 958
    if (ednsinfo) {
      {
#line 959
      tmp___34 = add_opt_pseudo_rr(& ans, rlen, & allocsz, (unsigned short )global.udpbufsize,
                                   rcode, (unsigned short)0, (unsigned short)0);
      }
#line 959
      if (! tmp___34) {
#line 960
        goto error_ans;
      }
    }
    {
#line 964
    tmp___35 = dlist_first(ar);
#line 964
    rre = (rr_ext_t *)tmp___35;
    }
    {
#line 964
    while (1) {
      while_continue___8: /* CIL Label */ ;
#line 964
      if (! rre) {
#line 964
        goto while_break___8;
      }
#line 965
      if ((int )rre->tp == 2) {
#line 965
        goto _L___23;
      } else
#line 965
      if ((int )rre->tp == 0) {
        _L___23: /* CIL Label */ 
        {
#line 966
        tmp___37 = add_additional_a(& ans, rlen, & allocsz, rre->tnm, queryts, udp,
                                    & cb, & sva);
        }
#line 966
        if (! tmp___37) {
#line 968
          goto error_ans;
        }
      }
      {
#line 964
      tmp___36 = dlist_next((void *)rre);
#line 964
      rre = (rr_ext_t *)tmp___36;
      }
    }
    while_break___8: /* CIL Label */ ;
    }
  }
#line 973
  if (aa) {
#line 974
    ans->hdr.aa = 1U;
  }
#line 975
  goto cleanup_return;
  error_cached: 
  {
#line 979
  free_cent(cached);
#line 980
  free((void *)cached);
  }
  error_ans: 
  {
#line 982
  free((void *)ans);
#line 983
  ans = (dns_msg_t *)((void *)0);
  }
  cleanup_return: 
  {
#line 985
  free((void *)ar);
#line 986
  free((void *)sva);
#line 987
  free((void *)cb);
  }
  return_ans: 
#line 989
  if (rcodep) {
#line 989
    *rcodep = (int )rcode;
  }
#line 990
  return (ans);
}
}
#line 1003 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/dns_answer.c"
static int decode_query(unsigned char *data , size_t rlen , unsigned char **ptrrem ,
                        size_t *lenrem , llist *qp ) 
{ 
  int i ;
  int res ;
  dns_hdr_t *hdr ;
  unsigned char *ptr ;
  size_t sz ;
  uint16_t qdcount ;
  uint16_t tmp ;
  dns_queryel_t *qe ;
  unsigned int qlen ;
  unsigned char qbuf[256] ;
  int tmp___0 ;
  void *tmp___1 ;
  register uint16_t t_s ;
  register unsigned char const   *t_cp ;
  unsigned char const   *tmp___2 ;
  unsigned char const   *tmp___3 ;
  register uint16_t t_s___0 ;
  register unsigned char const   *t_cp___0 ;
  unsigned char const   *tmp___4 ;
  unsigned char const   *tmp___5 ;

  {
  {
#line 1005
  res = 0;
#line 1006
  hdr = (dns_hdr_t *)data;
#line 1007
  ptr = (unsigned char *)(hdr + 1);
#line 1008
  sz = rlen - sizeof(dns_hdr_t );
#line 1009
  tmp = ntohs(hdr->qdcount);
#line 1009
  qdcount = tmp;
#line 1011
  llist_init(qp);
#line 1012
  i = 0;
  }
  {
#line 1012
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1012
    if (! (i < (int )qdcount)) {
#line 1012
      goto while_break;
    }
    {
#line 1016
    res = decompress_name(data, rlen, & ptr, & sz, qbuf, & qlen);
    }
#line 1017
    if (res == 65534) {
#line 1018
      goto while_break;
    }
#line 1019
    if (res != 0) {
      {
#line 1020
      llist_free(qp);
      }
#line 1021
      goto while_break;
    }
#line 1023
    if (sz < 4UL) {
#line 1025
      if (debug_p) {
        {
#line 1025
        debug_msg(0, "decode_query: query truncated in qtype or qclass.\n");
        }
      }
#line 1026
      res = 65534;
#line 1027
      goto while_break;
    }
    {
#line 1029
    tmp___0 = llist_grow(qp, sizeof(dns_queryel_t ) + (unsigned long )qlen);
    }
#line 1029
    if (! tmp___0) {
#line 1030
      res = 2;
#line 1031
      goto while_break;
    }
    {
#line 1033
    tmp___1 = llist_last(qp);
#line 1033
    qe = (dns_queryel_t *)tmp___1;
    }
    {
#line 1034
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1034
      t_cp = (unsigned char const   *)ptr;
#line 1034
      tmp___2 = t_cp;
#line 1034
      t_cp ++;
#line 1034
      t_s = (uint16_t )((int )((uint16_t )*tmp___2) << 8);
#line 1034
      tmp___3 = t_cp;
#line 1034
      t_cp ++;
#line 1034
      t_s = (uint16_t )((int )t_s | (int )((uint16_t )*tmp___3));
#line 1034
      qe->qtype = t_s;
#line 1034
      ptr = (unsigned char *)((void *)t_cp);
#line 1034
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 1035
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1035
      t_cp___0 = (unsigned char const   *)ptr;
#line 1035
      tmp___4 = t_cp___0;
#line 1035
      t_cp___0 ++;
#line 1035
      t_s___0 = (uint16_t )((int )((uint16_t )*tmp___4) << 8);
#line 1035
      tmp___5 = t_cp___0;
#line 1035
      t_cp___0 ++;
#line 1035
      t_s___0 = (uint16_t )((int )t_s___0 | (int )((uint16_t )*tmp___5));
#line 1035
      qe->qclass = t_s___0;
#line 1035
      ptr = (unsigned char *)((void *)t_cp___0);
#line 1035
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 1036
    sz -= 4UL;
#line 1037
    memcpy((void */* __restrict  */)(qe->query), (void const   */* __restrict  */)(qbuf),
           (size_t )qlen);
#line 1012
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1040
  if (ptrrem) {
#line 1040
    *ptrrem = ptr;
  }
#line 1041
  if (lenrem) {
#line 1041
    *lenrem = sz;
  }
#line 1042
  return (res);
}
}
#line 1058 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/dns_answer.c"
static int decode_query_additional(unsigned char *data , size_t rlen , unsigned char *ptr ,
                                   size_t sz , int numrr , int *numopt , edns_info_t *ep ) 
{ 
  int i ;
  int res ;
  unsigned char nmbuf[256] ;
  uint16_t type ;
  uint16_t class ;
  unsigned char *ttlp ;
  uint16_t rdlen ;
  register uint16_t t_s ;
  register unsigned char const   *t_cp ;
  unsigned char const   *tmp ;
  unsigned char const   *tmp___0 ;
  register uint16_t t_s___0 ;
  register unsigned char const   *t_cp___0 ;
  unsigned char const   *tmp___1 ;
  unsigned char const   *tmp___2 ;
  register uint16_t t_s___1 ;
  register unsigned char const   *t_cp___1 ;
  unsigned char const   *tmp___3 ;
  unsigned char const   *tmp___4 ;
  unsigned int Zflags ;
  int tmp___5 ;
  char const   *tmp___6 ;

  {
#line 1063
  i = 0;
  {
#line 1063
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1063
    if (! (i < numrr)) {
#line 1063
      goto while_break;
    }
    {
#line 1068
    res = decompress_name(data, rlen, & ptr, & sz, nmbuf, (unsigned int *)((void *)0));
    }
#line 1069
    if (res != 0) {
#line 1070
      return (res);
    }
#line 1071
    if (sz < 10UL) {
#line 1073
      if (debug_p) {
        {
#line 1073
        debug_msg(0, "decode_query_additional: additional section truncated in RR header.\n");
        }
      }
#line 1074
      return (65534);
    }
#line 1076
    sz -= 10UL;
    {
#line 1077
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1077
      t_cp = (unsigned char const   *)ptr;
#line 1077
      tmp = t_cp;
#line 1077
      t_cp ++;
#line 1077
      t_s = (uint16_t )((int )((uint16_t )*tmp) << 8);
#line 1077
      tmp___0 = t_cp;
#line 1077
      t_cp ++;
#line 1077
      t_s = (uint16_t )((int )t_s | (int )((uint16_t )*tmp___0));
#line 1077
      type = t_s;
#line 1077
      ptr = (unsigned char *)((void *)t_cp);
#line 1077
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 1078
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1078
      t_cp___0 = (unsigned char const   *)ptr;
#line 1078
      tmp___1 = t_cp___0;
#line 1078
      t_cp___0 ++;
#line 1078
      t_s___0 = (uint16_t )((int )((uint16_t )*tmp___1) << 8);
#line 1078
      tmp___2 = t_cp___0;
#line 1078
      t_cp___0 ++;
#line 1078
      t_s___0 = (uint16_t )((int )t_s___0 | (int )((uint16_t )*tmp___2));
#line 1078
      class = t_s___0;
#line 1078
      ptr = (unsigned char *)((void *)t_cp___0);
#line 1078
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 1079
    ttlp = ptr;
#line 1080
    ptr += 4;
    {
#line 1081
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 1081
      t_cp___1 = (unsigned char const   *)ptr;
#line 1081
      tmp___3 = t_cp___1;
#line 1081
      t_cp___1 ++;
#line 1081
      t_s___1 = (uint16_t )((int )((uint16_t )*tmp___3) << 8);
#line 1081
      tmp___4 = t_cp___1;
#line 1081
      t_cp___1 ++;
#line 1081
      t_s___1 = (uint16_t )((int )t_s___1 | (int )((uint16_t )*tmp___4));
#line 1081
      rdlen = t_s___1;
#line 1081
      ptr = (unsigned char *)((void *)t_cp___1);
#line 1081
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 1082
    if (sz < (size_t )rdlen) {
#line 1083
      if (debug_p) {
        {
#line 1083
        debug_msg(0, "decode_query_additional: additional section truncated in RDATA field.\n");
        }
      }
#line 1084
      return (65534);
    }
#line 1087
    if ((int )type == 41) {
#line 1089
      tmp___5 = *numopt;
#line 1089
      (*numopt) ++;
#line 1089
      if (tmp___5 == 0) {
#line 1091
        if ((int )nmbuf[0] != 0) {
#line 1092
          if (debug_p) {
            {
#line 1092
            debug_msg(0, "decode_query_additional: name in OPT record not empty!\n");
            }
          }
        }
#line 1095
        ep->udpsize = class;
#line 1096
        ep->rcode = (unsigned short )((unsigned int )((int )((uint16_t )*(ttlp + 0)) << 4) | ((dns_hdr_t *)data)->rcode);
#line 1097
        ep->version = (unsigned short )*(ttlp + 1);
#line 1098
        ep->do_flg = (unsigned char )(((int )*(ttlp + 2) >> 7) & 1);
#line 1100
        if (debug_p) {
#line 1101
          Zflags = (unsigned int )(((int )((uint16_t )*(ttlp + 2)) << 8) | (int )*(ttlp + 3));
#line 1102
          if (Zflags & 32767U) {
#line 1103
            if (debug_p) {
              {
#line 1103
              debug_msg(0, "decode_query_additional: Z field contains unknown nonzero bits (%04x).\n",
                        Zflags);
              }
            }
          }
#line 1106
          if (rdlen) {
#line 1107
            if (debug_p) {
              {
#line 1107
              debug_msg(0, "decode_query_additional: RDATA field in OPT record not empty!\n");
              }
            }
          }
        }
      } else
#line 1113
      if (debug_p) {
        {
#line 1113
        debug_msg(0, "decode_query_additional: ingnoring surplus OPT record.\n");
        }
      }
    } else
#line 1117
    if (debug_p) {
      {
#line 1117
      tmp___6 = getrrtpname((int )type);
#line 1117
      debug_msg(0, "decode_query_additional: ignoring record of type %s (%d).\n",
                tmp___6, (int )type);
      }
    }
#line 1122
    sz -= (size_t )rdlen;
#line 1123
    ptr += (int )rdlen;
#line 1063
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1126
  return (0);
}
}
#line 1133 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/dns_answer.c"
static void mk_error_reply(unsigned short id , unsigned short opcode , unsigned short rescode ,
                           dns_hdr_t *rep ) 
{ 


  {
#line 1135
  rep->id = id;
#line 1136
  rep->qr = 1U;
#line 1137
  rep->opcode = (unsigned int )opcode;
#line 1138
  rep->aa = 0U;
#line 1139
  rep->tc = 0U;
#line 1140
  rep->rd = 0U;
#line 1141
  rep->ra = 1U;
#line 1142
  rep->z = 0U;
#line 1143
  rep->ad = 0U;
#line 1144
  rep->cd = 0U;
#line 1145
  rep->rcode = (unsigned int )rescode;
#line 1146
  rep->qdcount = (uint16_t )0;
#line 1147
  rep->ancount = (uint16_t )0;
#line 1148
  rep->nscount = (uint16_t )0;
#line 1149
  rep->arcount = (uint16_t )0;
#line 1150
  return;
}
}
#line 1156 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/dns_answer.c"
static dns_msg_t *process_query(unsigned char *data , size_t *rlenp , unsigned int *udp ,
                                int *rcodep ) 
{ 
  size_t rlen ;
  int res ;
  dns_hdr_t *hdr ;
  llist ql ;
  dns_msg_t *ans ;
  edns_info_t ednsinfo ;
  edns_info_t *ednsinfop ;
  char flgsbuf[22] ;
  unsigned char *ptr ;
  size_t sz ;
  uint16_t arcount ;
  int tmp ;
  int numoptrr ;
  unsigned int udpbufsize ;
  dns_queryel_t *qe ;
  void *tmp___0 ;
  void *tmp___1 ;
  unsigned char _debugstrbuf[256] ;
  unsigned char const   *tmp___2 ;
  char const   *tmp___3 ;
  char const   *tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  size_t allocsz ;
  void *tmp___7 ;
  unsigned int tmp___8 ;

  {
#line 1158
  rlen = *rlenp;
#line 1163
  ednsinfo.udpsize = (unsigned short)0;
#line 1163
  ednsinfo.rcode = (unsigned short)0;
#line 1163
  ednsinfo.version = (unsigned short)0;
#line 1163
  ednsinfo.do_flg = (unsigned char)0;
#line 1163
  ednsinfop = (edns_info_t *)((void *)0);
#line 1165
  if (debug_p) {
    {
#line 1165
    debug_msg(0, "Received query (msg len=%u).\n", (unsigned int )rlen);
    }
  }
#line 1175
  hdr = (dns_hdr_t *)data;
#line 1176
  if (rlen < 2UL) {
#line 1177
    if (debug_p) {
      {
#line 1177
      debug_msg(0, "Message too short.\n");
      }
    }
#line 1178
    return ((dns_msg_t *)((void *)0));
  }
#line 1180
  if (rlen < sizeof(dns_hdr_t )) {
#line 1181
    if (debug_p) {
      {
#line 1181
      debug_msg(0, "Message too short.\n");
      }
    }
#line 1182
    res = 1;
#line 1183
    goto error_reply;
  }
#line 1185
  if (hdr->qr != 0U) {
#line 1186
    if (debug_p) {
      {
#line 1186
      debug_msg(0, "The QR bit indicates this is a response, not a query.\n");
      }
    }
#line 1187
    return ((dns_msg_t *)((void *)0));
  }
#line 1189
  if (hdr->opcode != 0U) {
#line 1190
    if (debug_p) {
      {
#line 1190
      debug_msg(0, "Not a standard query (opcode=%u).\n", hdr->opcode);
      }
    }
#line 1191
    res = 4;
#line 1192
    goto error_reply;
  }
#line 1195
  if (debug_p) {
    {
#line 1197
    dnsflags2str(hdr, flgsbuf);
    }
#line 1198
    if (flgsbuf[0]) {
#line 1199
      if (debug_p) {
        {
#line 1199
        debug_msg(0, "Flags:%s\n", flgsbuf);
        }
      }
    }
  }
#line 1203
  if (hdr->z != 0U) {
#line 1204
    if (debug_p) {
      {
#line 1204
      debug_msg(0, "Malformed query (nonzero Z bit).\n");
      }
    }
#line 1205
    res = 1;
#line 1206
    goto error_reply;
  }
#line 1208
  if (hdr->rcode != 0U) {
#line 1209
    if (debug_p) {
      {
#line 1209
      debug_msg(0, "Bad rcode(%u).\n", hdr->rcode);
      }
    }
#line 1210
    return ((dns_msg_t *)((void *)0));
  }
#line 1213
  if (hdr->ancount) {
#line 1214
    if (debug_p) {
      {
#line 1214
      debug_msg(0, "Query has a non-empty answer section!\n");
      }
    }
#line 1215
    res = 1;
#line 1216
    goto error_reply;
  }
#line 1219
  if (hdr->nscount) {
#line 1220
    if (debug_p) {
      {
#line 1220
      debug_msg(0, "Query has a non-empty authority section!\n");
      }
    }
#line 1221
    res = 1;
#line 1222
    goto error_reply;
  }
  {
#line 1238
  res = decode_query(data, rlen, & ptr, & sz, & ql);
  }
#line 1239
  if (res != 0) {
#line 1240
    if (res == 65534) {
#line 1241
      if (! hdr->tc) {
#line 1242
        res = 1;
#line 1243
        goto free_ql_error_reply;
      } else {
        {
#line 1241
        tmp = llist_isempty(& ql);
        }
#line 1241
        if (tmp) {
#line 1242
          res = 1;
#line 1243
          goto free_ql_error_reply;
        }
      }
    } else {
#line 1247
      goto error_reply;
    }
  }
  {
#line 1250
  arcount = ntohs(hdr->arcount);
  }
#line 1250
  if (arcount) {
#line 1251
    numoptrr = 0;
#line 1252
    if (debug_p) {
      {
#line 1252
      debug_msg(0, "Query has a non-empty additional section: checking for OPT pseudo-RR.\n");
      }
    }
#line 1254
    if (res == 65534) {
#line 1255
      if (debug_p) {
        {
#line 1255
        debug_msg(0, "Additional section cannot be read due to truncation!\n");
        }
      }
#line 1256
      res = 1;
#line 1257
      goto free_ql_error_reply;
    }
    {
#line 1259
    res = decode_query_additional(data, rlen, ptr, sz, (int )arcount, & numoptrr,
                                  & ednsinfo);
    }
#line 1260
    if (! (res == 0)) {
#line 1260
      if (res == 65534) {
#line 1260
        if (! hdr->tc) {
#line 1261
          res = 1;
#line 1262
          goto free_ql_error_reply;
        }
      } else {
#line 1261
        res = 1;
#line 1262
        goto free_ql_error_reply;
      }
    }
#line 1264
    if (numoptrr) {
#line 1266
      if (numoptrr != 1) {
#line 1267
        if (debug_p) {
          {
#line 1267
          debug_msg(0, "Additional section in query contains %d OPT pseudo-RRs!\n",
                    numoptrr);
          }
        }
      }
#line 1270
      if ((int )ednsinfo.version != 0) {
#line 1271
        if (debug_p) {
          {
#line 1271
          debug_msg(0, "Query contains unsupported EDNS version %d!\n", (int )ednsinfo.version);
          }
        }
#line 1272
        res = 16;
#line 1273
        goto free_ql_error_reply;
      }
#line 1275
      if ((int )ednsinfo.rcode != 0) {
#line 1276
        if (debug_p) {
          {
#line 1276
          debug_msg(0, "Query contains non-zero EDNS rcode (%d)!\n", (int )ednsinfo.rcode);
          }
        }
#line 1277
        res = 1;
#line 1278
        goto free_ql_error_reply;
      }
#line 1280
      if (debug_p) {
        {
#line 1280
        debug_msg(0, "Query contains OPT pseudosection: EDNS udp size = %u, flag DO=%u\n",
                  (int )ednsinfo.udpsize, (int )ednsinfo.do_flg);
        }
      }
#line 1282
      ednsinfop = & ednsinfo;
#line 1283
      if (udp) {
#line 1283
        if ((int )ednsinfo.udpsize > 512) {
#line 1284
          udpbufsize = (unsigned int )global.udpbufsize;
#line 1285
          if (udpbufsize > (unsigned int )ednsinfo.udpsize) {
#line 1286
            udpbufsize = (unsigned int )ednsinfo.udpsize;
          }
#line 1287
          *udp = udpbufsize;
        }
      }
    }
  }
#line 1294
  if (debug_p) {
    {
#line 1295
    tmp___5 = llist_isempty(& ql);
    }
#line 1295
    if (tmp___5) {
#line 1304
      if (debug_p) {
        {
#line 1304
        debug_msg(0, "Query contains no questions.\n");
        }
      }
    } else {
#line 1297
      if (debug_p) {
        {
#line 1297
        debug_msg(0, "Questions are:\n");
        }
      }
      {
#line 1298
      tmp___0 = llist_first(& ql);
#line 1298
      qe = (dns_queryel_t *)tmp___0;
      }
      {
#line 1298
      while (1) {
        while_continue: /* CIL Label */ ;
#line 1298
        if (! qe) {
#line 1298
          goto while_break;
        }
#line 1299
        if (debug_p) {
          {
#line 1299
          tmp___2 = rhn2str((unsigned char const   *)(qe->query), _debugstrbuf, (unsigned int )sizeof(_debugstrbuf));
#line 1299
          tmp___3 = get_tname((int )qe->qtype);
#line 1299
          tmp___4 = get_cname((int )qe->qclass);
#line 1299
          debug_msg(0, "\tqc=%s (%u), qt=%s (%u), query=\"%s\"\n", tmp___4, (int )qe->qclass,
                    tmp___3, (int )qe->qtype, tmp___2);
          }
        }
        {
#line 1298
        tmp___1 = llist_next((void *)qe);
#line 1298
        qe = (dns_queryel_t *)tmp___1;
        }
      }
      while_break: /* CIL Label */ ;
      }
    }
  }
  {
#line 1309
  tmp___6 = llist_isempty(& ql);
  }
#line 1309
  if (tmp___6) {
#line 1310
    res = 1;
#line 1311
    goto error_reply;
  }
  {
#line 1313
  ans = compose_answer(& ql, hdr, rlenp, ednsinfop, udp, rcodep);
  }
#line 1313
  if (! ans) {
#line 1315
    res = 2;
#line 1316
    goto free_ql_error_reply;
  }
  {
#line 1318
  llist_free(& ql);
  }
#line 1319
  return (ans);
  free_ql_error_reply: 
  {
#line 1322
  llist_free(& ql);
  }
  error_reply: 
#line 1324
  *rlenp = sizeof(dns_hdr_t );
#line 1326
  allocsz = sizeof(dns_msg_t );
#line 1327
  if (res & -16) {
#line 1328
    allocsz += 11UL;
  }
  {
#line 1329
  tmp___7 = malloc(allocsz);
#line 1329
  ans = (dns_msg_t *)tmp___7;
  }
#line 1330
  if (ans) {
#line 1331
    if (rlen >= 3UL) {
#line 1331
      tmp___8 = hdr->opcode;
    } else {
#line 1331
      tmp___8 = 0U;
    }
    {
#line 1331
    mk_error_reply(hdr->id, (unsigned short )tmp___8, (unsigned short )res, & ans->hdr);
    }
#line 1332
    if (res & -16) {
      {
#line 1333
      add_opt_pseudo_rr(& ans, rlenp, & allocsz, (unsigned short )global.udpbufsize,
                        (unsigned short )res, (unsigned short)0, (unsigned short)0);
      }
    }
  } else {
#line 1336
    da_mem_errs += (unsigned long volatile   )1;
#line 1336
    if (da_mem_errs <= (unsigned long volatile   )10) {
      {
#line 1337
      log_message(3, "Out of memory in query processing.");
      }
    }
  }
#line 1340
  if (rcodep) {
#line 1340
    *rcodep = res;
  }
#line 1341
  return (ans);
}
}
#line 1347 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/dns_answer.c"
__inline static void decrease_procs(void) 
{ 


  {
  {
#line 1350
  pthread_mutex_lock(& proc_lock);
#line 1351
  procs -= (int volatile   )1;
#line 1352
  qprocs -= (int volatile   )1;
#line 1353
  pthread_mutex_unlock(& proc_lock);
  }
#line 1354
  return;
}
}
#line 1356 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/dns_answer.c"
static void udp_answer_thread_cleanup(void *data ) 
{ 


  {
  {
#line 1358
  free(data);
#line 1359
  decrease_procs();
  }
#line 1360
  return;
}
}
#line 1368 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/dns_answer.c"
static void *udp_answer_thread(void *data ) 
{ 
  struct msghdr msg ;
  struct iovec v ;
  struct cmsghdr *cmsg ;
  char ctrl[(((sizeof(pkt_info_t ) + sizeof(size_t )) - 1UL) & ~ (sizeof(size_t ) - 1UL)) + (((sizeof(struct cmsghdr ) + sizeof(size_t )) - 1UL) & ~ (sizeof(size_t ) - 1UL))] ;
  size_t rlen ;
  unsigned int udpmaxrespsize ;
  dns_msg_t *resp ;
  int rcode ;
  unsigned int thrid ;
  __pthread_unwind_buf_t __cancel_buf ;
  void (*__cancel_routine)(void * ) ;
  void *__cancel_arg ;
  int __not_first_call ;
  int tmp ;
  long tmp___0 ;
  int tmp___1 ;
  int err ;
  char *tmp___2 ;
  __pthread_unwind_buf_t __cancel_buf___0 ;
  void (*__cancel_routine___0)(void * ) ;
  void *__cancel_arg___0 ;
  int __not_first_call___0 ;
  int tmp___3 ;
  long tmp___4 ;
  char const   *tmp___5 ;
  char buf[16] ;
  char const   *tmp___6 ;
  char const   *tmp___7 ;
  int *tmp___8 ;
  char *tmp___9 ;
  int tmp___10 ;
  socklen_t sl ;
  ssize_t tmp___11 ;

  {
#line 1376
  rlen = ((udp_buf_t *)data)->len;
#line 1377
  udpmaxrespsize = 512U;
  {
#line 1382
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1382
    __cancel_routine = & udp_answer_thread_cleanup;
#line 1382
    __cancel_arg = data;
#line 1382
    tmp = __sigsetjmp((struct __jmp_buf_tag *)((void *)(__cancel_buf.__cancel_jmp_buf)),
                      0);
#line 1382
    __not_first_call = tmp;
#line 1382
    tmp___0 = __builtin_expect((long )__not_first_call, 0L);
    }
#line 1382
    if (tmp___0) {
      {
#line 1382
      (*__cancel_routine)(__cancel_arg);
#line 1382
      __pthread_unwind_next(& __cancel_buf);
      }
    }
    {
#line 1382
    __pthread_register_cancel(& __cancel_buf);
    }
    {
#line 1382
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1385
      if (! global.strict_suid) {
        {
#line 1386
        tmp___1 = run_as((char const   *)(global.run_as));
        }
#line 1386
        if (! tmp___1) {
          {
#line 1387
          pdnsd_exit();
          }
        }
      }
      {
#line 1391
      while (1) {
        while_continue___1: /* CIL Label */ ;
        {
#line 1392
        pthread_mutex_lock(& proc_lock);
        }
#line 1393
        if (procs < (int volatile   )global.proc_limit) {
#line 1394
          goto while_break___1;
        }
        {
#line 1395
        pthread_mutex_unlock(& proc_lock);
#line 1396
        usleep_r(50000UL);
        }
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 1398
      procs += (int volatile   )1;
#line 1399
      thrid_cnt += (unsigned int volatile   )1;
#line 1399
      thrid = (unsigned int )thrid_cnt;
#line 1400
      pthread_mutex_unlock(& proc_lock);
      }
#line 1403
      if (debug_p) {
        {
#line 1405
        err = pthread_setspecific(thrid_key, (void const   *)(& thrid));
        }
#line 1405
        if (err != 0) {
#line 1406
          da_misc_errs += (unsigned long volatile   )1;
#line 1406
          if (da_misc_errs <= (unsigned long volatile   )10) {
            {
#line 1407
            tmp___2 = strerror(err);
#line 1407
            log_message(3, "pthread_setspecific failed: %s", tmp___2);
            }
          }
        }
      }
      {
#line 1413
      resp = process_query(((udp_buf_t *)data)->buf, & rlen, & udpmaxrespsize, & rcode);
      }
#line 1413
      if (! resp) {
        {
#line 1418
        pthread_exit((void *)0);
        }
      }
      {
#line 1420
      while (1) {
        while_continue___2: /* CIL Label */ ;
        {
#line 1420
        __cancel_routine___0 = (void (*)(void * ))(& free);
#line 1420
        __cancel_arg___0 = (void *)resp;
#line 1420
        tmp___3 = __sigsetjmp((struct __jmp_buf_tag *)((void *)(__cancel_buf___0.__cancel_jmp_buf)),
                              0);
#line 1420
        __not_first_call___0 = tmp___3;
#line 1420
        tmp___4 = __builtin_expect((long )__not_first_call___0, 0L);
        }
#line 1420
        if (tmp___4) {
          {
#line 1420
          (*__cancel_routine___0)(__cancel_arg___0);
#line 1420
          __pthread_unwind_next(& __cancel_buf___0);
          }
        }
        {
#line 1420
        __pthread_register_cancel(& __cancel_buf___0);
        }
        {
#line 1420
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 1421
          if (rlen > (size_t )udpmaxrespsize) {
#line 1422
            rlen = (size_t )udpmaxrespsize;
#line 1423
            resp->hdr.tc = 1U;
          }
#line 1425
          if (debug_p) {
            {
#line 1425
            tmp___5 = get_ename(rcode);
#line 1425
            debug_msg(0, "Outbound msg len %li, tc=%u, rc=\"%s\"\n", (long )rlen,
                      resp->hdr.tc, tmp___5);
            }
          }
#line 1427
          v.iov_base = (void *)((char *)(& resp->hdr));
#line 1428
          v.iov_len = rlen;
#line 1429
          msg.msg_iov = & v;
#line 1430
          msg.msg_iovlen = (size_t )1;
#line 1433
          msg.msg_control = (void *)(ctrl);
#line 1434
          msg.msg_controllen = sizeof(ctrl);
#line 1439
          msg.msg_flags = 0;
#line 1445
          msg.msg_name = (void *)(& ((udp_buf_t *)data)->addr.sin4);
#line 1446
          msg.msg_namelen = (socklen_t )sizeof(struct sockaddr_in );
#line 1449
          ((udp_buf_t *)data)->pi.pi4.ipi_spec_dst = ((udp_buf_t *)data)->pi.pi4.ipi_addr;
#line 1450
          if (msg.msg_controllen >= sizeof(struct cmsghdr )) {
#line 1450
            cmsg = (struct cmsghdr *)msg.msg_control;
          } else {
#line 1450
            cmsg = (struct cmsghdr *)0;
          }
          {
#line 1451
          cmsg->cmsg_len = (((sizeof(struct cmsghdr ) + sizeof(size_t )) - 1UL) & ~ (sizeof(size_t ) - 1UL)) + sizeof(struct in_pktinfo );
#line 1452
          cmsg->cmsg_level = 0;
#line 1453
          cmsg->cmsg_type = 8;
#line 1454
          memcpy((void */* __restrict  */)(cmsg->__cmsg_data), (void const   */* __restrict  */)(& ((udp_buf_t *)data)->pi.pi4),
                 sizeof(struct in_pktinfo ));
#line 1455
          msg.msg_controllen = (((sizeof(struct in_pktinfo ) + sizeof(size_t )) - 1UL) & ~ (sizeof(size_t ) - 1UL)) + (((sizeof(struct cmsghdr ) + sizeof(size_t )) - 1UL) & ~ (sizeof(size_t ) - 1UL));
          }
#line 1469
          if (debug_p) {
            {
#line 1469
            tmp___6 = inet_ntop(2, (void const   */* __restrict  */)(& ((udp_buf_t *)data)->addr.sin4.sin_addr),
                                (char */* __restrict  */)(buf), (socklen_t )16);
#line 1469
            debug_msg(0, "Answering to: %s", tmp___6);
            }
          }
#line 1472
          if (debug_p) {
            {
#line 1472
            tmp___7 = inet_ntop(2, (void const   */* __restrict  */)(& ((udp_buf_t *)data)->pi.pi4.ipi_spec_dst),
                                (char */* __restrict  */)(buf), (socklen_t )16);
#line 1472
            debug_msg(1, ", source address: %s\n", tmp___7);
            }
          }
          {
#line 1515
          tmp___11 = sendmsg(((udp_buf_t *)data)->sock, (struct msghdr  const  *)(& msg),
                             0);
          }
#line 1515
          if (tmp___11 < 0L) {
#line 1519
            da_udp_errs += (unsigned long volatile   )1;
#line 1519
            if (da_udp_errs <= (unsigned long volatile   )10) {
              {
#line 1520
              tmp___8 = __errno_location();
#line 1520
              tmp___9 = strerror(*tmp___8);
#line 1520
              log_message(3, "Error in udp send: %s", tmp___9);
              }
            }
          } else {
            {
#line 1524
            sl = (socklen_t )sizeof(tmp___10);
#line 1525
            getsockopt(((udp_buf_t *)data)->sock, 1, 4, (void */* __restrict  */)(& tmp___10),
                       (socklen_t */* __restrict  */)(& sl));
            }
          }
          {
#line 1531
          while (1) {
            while_continue___4: /* CIL Label */ ;
#line 1531
            goto while_break___4;
          }
          while_break___4: /* CIL Label */ ;
          }
#line 1420
          goto while_break___3;
        }
        while_break___3: /* CIL Label */ ;
        }
        {
#line 1531
        __pthread_unregister_cancel(& __cancel_buf___0);
#line 1531
        (*__cancel_routine___0)(__cancel_arg___0);
        }
#line 1420
        goto while_break___2;
      }
      while_break___2: /* CIL Label */ ;
      }
      {
#line 1532
      while (1) {
        while_continue___5: /* CIL Label */ ;
#line 1532
        goto while_break___5;
      }
      while_break___5: /* CIL Label */ ;
      }
#line 1382
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 1532
    __pthread_unregister_cancel(& __cancel_buf);
#line 1532
    (*__cancel_routine)(__cancel_arg);
    }
#line 1382
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 1533
  return ((void *)0);
}
}
#line 1536 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/dns_answer.c"
int init_udp_socket(void) 
{ 
  int sock ;
  int so ;
  union __anonunion_sin_118 sin ;
  socklen_t sinl ;
  int *tmp ;
  char *tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  int *tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;

  {
  {
#line 1539
  so = 1;
#line 1552
  sock = socket(2, 2, 17);
  }
#line 1552
  if (sock == -1) {
    {
#line 1553
    tmp = __errno_location();
#line 1553
    tmp___0 = strerror(*tmp);
#line 1553
    log_message(3, "Could not open udp socket: %s", tmp___0);
    }
#line 1554
    return (-1);
  }
  {
#line 1556
  memset((void *)(& sin.sin4), 0, sizeof(struct sockaddr_in ));
#line 1557
  sin.sin4.sin_family = (sa_family_t )2;
#line 1558
  sin.sin4.sin_port = htons((uint16_t )global.port);
#line 1559
  sin.sin4.sin_addr = global.a.ipv4;
#line 1561
  sinl = (socklen_t )sizeof(struct sockaddr_in );
#line 1587
  tmp___3 = setsockopt(sock, 0, 8, (void const   *)(& so), (socklen_t )sizeof(so));
  }
#line 1587
  if (tmp___3 != 0) {
    {
#line 1591
    tmp___1 = __errno_location();
#line 1591
    tmp___2 = strerror(*tmp___1);
#line 1591
    log_message(3, "Could not set options on udp socket: %s", tmp___2);
#line 1592
    close(sock);
    }
#line 1593
    return (-1);
  }
  {
#line 1609
  tmp___6 = bind(sock, (struct sockaddr  const  */* __restrict  */)((struct sockaddr *)(& sin)),
                 sinl);
  }
#line 1609
  if (tmp___6 != 0) {
    {
#line 1610
    tmp___4 = __errno_location();
#line 1610
    tmp___5 = strerror(*tmp___4);
#line 1610
    log_message(3, "Could not bind to udp socket: %s", tmp___5);
#line 1611
    close(sock);
    }
#line 1612
    return (-1);
  }
#line 1614
  return (sock);
}
}
#line 1623 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/dns_answer.c"
void *udp_server_thread(void *dummy ) 
{ 
  int sock ;
  ssize_t qlen ;
  pthread_t pt ;
  udp_buf_t *buf ;
  struct msghdr msg ;
  struct iovec v ;
  struct cmsghdr *cmsg ;
  char ctrl[512] ;
  int tmp ;
  int udpbufsize ;
  void *tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  int *tmp___3 ;
  int err ;
  char *tmp___4 ;

  {
#line 1641
  if (! global.strict_suid) {
    {
#line 1642
    tmp = run_as((char const   *)(global.run_as));
    }
#line 1642
    if (! tmp) {
      {
#line 1643
      pdnsd_exit();
      }
    }
  }
#line 1647
  sock = (int )udp_socket;
  {
#line 1649
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1650
    udpbufsize = global.udpbufsize;
#line 1651
    tmp___0 = calloc((size_t )1, sizeof(udp_buf_t ) + (unsigned long )udpbufsize);
#line 1651
    buf = (udp_buf_t *)tmp___0;
    }
#line 1651
    if (! buf) {
#line 1652
      da_mem_errs += (unsigned long volatile   )1;
#line 1652
      if (da_mem_errs <= (unsigned long volatile   )10) {
        {
#line 1653
        log_message(3, "Out of memory in request handling.");
        }
      }
#line 1655
      goto while_break;
    }
    {
#line 1658
    buf->sock = sock;
#line 1660
    v.iov_base = (void *)((char *)(buf->buf));
#line 1661
    v.iov_len = (size_t )udpbufsize;
#line 1662
    msg.msg_iov = & v;
#line 1663
    msg.msg_iovlen = (size_t )1;
#line 1665
    msg.msg_control = (void *)(ctrl);
#line 1666
    msg.msg_controllen = sizeof(ctrl);
#line 1672
    msg.msg_name = (void *)(& buf->addr.sin4);
#line 1673
    msg.msg_namelen = (socklen_t )sizeof(struct sockaddr_in );
#line 1674
    qlen = recvmsg(sock, & msg, 0);
    }
#line 1674
    if (qlen >= 0L) {
#line 1675
      if (msg.msg_controllen >= sizeof(struct cmsghdr )) {
#line 1675
        cmsg = (struct cmsghdr *)msg.msg_control;
      } else {
#line 1675
        cmsg = (struct cmsghdr *)0;
      }
      {
#line 1676
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1676
        if (! cmsg) {
#line 1676
          goto while_break___0;
        }
#line 1678
        if (cmsg->cmsg_level == 0) {
#line 1678
          if (cmsg->cmsg_type == 8) {
            {
#line 1679
            memcpy((void */* __restrict  */)(& buf->pi.pi4), (void const   */* __restrict  */)(cmsg->__cmsg_data),
                   sizeof(struct in_pktinfo ));
            }
#line 1680
            goto while_break___0;
          }
        }
        {
#line 1688
        cmsg = __cmsg_nxthdr(& msg, cmsg);
        }
      }
      while_break___0: /* CIL Label */ ;
      }
#line 1690
      if (! cmsg) {
#line 1691
        da_udp_errs += (unsigned long volatile   )1;
#line 1691
        if (da_udp_errs <= (unsigned long volatile   )10) {
          {
#line 1692
          log_message(3, "Could not discover udp destination address");
          }
        }
#line 1694
        goto free_buf_continue;
      }
    } else {
      {
#line 1696
      tmp___3 = __errno_location();
      }
#line 1696
      if (*tmp___3 != 4) {
#line 1697
        da_udp_errs += (unsigned long volatile   )1;
#line 1697
        if (da_udp_errs <= (unsigned long volatile   )10) {
          {
#line 1698
          tmp___1 = __errno_location();
#line 1698
          tmp___2 = strerror(*tmp___1);
#line 1698
          log_message(3, "error in UDP recv: %s", tmp___2);
          }
        }
      }
    }
#line 1767
    if (qlen >= 0L) {
      {
#line 1768
      pthread_mutex_lock(& proc_lock);
      }
#line 1769
      if (qprocs < (int volatile   )(global.proc_limit + global.procq_limit)) {
        {
#line 1771
        qprocs += (int volatile   )1;
#line 1771
        spawned += (unsigned long volatile   )1;
#line 1772
        pthread_mutex_unlock(& proc_lock);
#line 1773
        buf->len = (size_t )qlen;
#line 1774
        err = pthread_create((pthread_t */* __restrict  */)(& pt), (pthread_attr_t const   */* __restrict  */)(& attr_detached),
                             & udp_answer_thread, (void */* __restrict  */)((void *)buf));
        }
#line 1775
        if (err == 0) {
#line 1776
          goto while_continue;
        }
#line 1777
        da_thrd_errs += (unsigned long volatile   )1;
#line 1777
        if (da_thrd_errs <= (unsigned long volatile   )10) {
          {
#line 1778
          tmp___4 = strerror(err);
#line 1778
          log_message(4, "pthread_create failed: %s", tmp___4);
          }
        }
        {
#line 1780
        pthread_mutex_lock(& proc_lock);
#line 1781
        qprocs -= (int volatile   )1;
#line 1781
        spawned -= (unsigned long volatile   )1;
        }
      }
      {
#line 1783
      dropped += (unsigned long volatile   )1;
#line 1784
      pthread_mutex_unlock(& proc_lock);
      }
    }
    free_buf_continue: 
    {
#line 1787
    free((void *)buf);
#line 1788
    usleep_r(50000UL);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1791
  udp_socket = (int volatile   )-1;
#line 1792
  close(sock);
#line 1793
  udps_thrid = main_thrid;
  }
#line 1794
  if (tcp_socket == (int volatile   )-1) {
    {
#line 1795
    pdnsd_exit();
    }
  }
#line 1796
  return ((void *)0);
}
}
#line 1801 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/dns_answer.c"
static void tcp_answer_thread_cleanup(void *csock ) 
{ 


  {
  {
#line 1803
  close(*((int *)csock));
#line 1804
  free(csock);
#line 1805
  decrease_procs();
  }
#line 1806
  return;
}
}
#line 1811 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/dns_answer.c"
static void *tcp_answer_thread(void *csock ) 
{ 
  int sock ;
  unsigned int thrid ;
  __pthread_unwind_buf_t __cancel_buf ;
  void (*__cancel_routine)(void * ) ;
  void *__cancel_arg ;
  int __not_first_call ;
  int tmp ;
  long tmp___0 ;
  int tmp___1 ;
  int err ;
  char *tmp___2 ;
  int rlen ;
  int olen ;
  size_t nlen ;
  unsigned char *buf ;
  dns_msg_t *resp ;
  struct pollfd pfd ;
  int tmp___3 ;
  ssize_t err___0 ;
  uint16_t rlen_net ;
  int *tmp___4 ;
  char *tmp___5 ;
  char const   *tmp___6 ;
  uint16_t tmp___7 ;
  void *tmp___8 ;
  __pthread_unwind_buf_t __cancel_buf___0 ;
  void (*__cancel_routine___0)(void * ) ;
  void *__cancel_arg___0 ;
  int __not_first_call___0 ;
  int tmp___9 ;
  long tmp___10 ;
  int rv ;
  int tmp___11 ;
  ssize_t tmp___12 ;
  int *tmp___13 ;
  char *tmp___14 ;
  char const   *tmp___15 ;
  dns_msg_t err___1 ;
  unsigned int tmp___16 ;
  __pthread_unwind_buf_t __cancel_buf___1 ;
  void (*__cancel_routine___1)(void * ) ;
  void *__cancel_arg___1 ;
  int __not_first_call___1 ;
  int tmp___17 ;
  long tmp___18 ;
  int err___2 ;
  size_t rsize ;
  int *tmp___19 ;
  char *tmp___20 ;
  char const   *tmp___21 ;
  ssize_t tmp___22 ;

  {
#line 1814
  sock = *((int *)csock);
  {
#line 1817
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1817
    __cancel_routine = & tcp_answer_thread_cleanup;
#line 1817
    __cancel_arg = csock;
#line 1817
    tmp = __sigsetjmp((struct __jmp_buf_tag *)((void *)(__cancel_buf.__cancel_jmp_buf)),
                      0);
#line 1817
    __not_first_call = tmp;
#line 1817
    tmp___0 = __builtin_expect((long )__not_first_call, 0L);
    }
#line 1817
    if (tmp___0) {
      {
#line 1817
      (*__cancel_routine)(__cancel_arg);
#line 1817
      __pthread_unwind_next(& __cancel_buf);
      }
    }
    {
#line 1817
    __pthread_register_cancel(& __cancel_buf);
    }
    {
#line 1817
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1820
      if (! global.strict_suid) {
        {
#line 1821
        tmp___1 = run_as((char const   *)(global.run_as));
        }
#line 1821
        if (! tmp___1) {
          {
#line 1822
          pdnsd_exit();
          }
        }
      }
      {
#line 1826
      while (1) {
        while_continue___1: /* CIL Label */ ;
        {
#line 1827
        pthread_mutex_lock(& proc_lock);
        }
#line 1828
        if (procs < (int volatile   )global.proc_limit) {
#line 1829
          goto while_break___1;
        }
        {
#line 1830
        pthread_mutex_unlock(& proc_lock);
#line 1831
        usleep_r(50000UL);
        }
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 1833
      procs += (int volatile   )1;
#line 1834
      thrid_cnt += (unsigned int volatile   )1;
#line 1834
      thrid = (unsigned int )thrid_cnt;
#line 1835
      pthread_mutex_unlock(& proc_lock);
      }
#line 1838
      if (debug_p) {
        {
#line 1840
        err = pthread_setspecific(thrid_key, (void const   *)(& thrid));
        }
#line 1840
        if (err != 0) {
#line 1841
          da_misc_errs += (unsigned long volatile   )1;
#line 1841
          if (da_misc_errs <= (unsigned long volatile   )10) {
            {
#line 1842
            tmp___2 = strerror(err);
#line 1842
            log_message(3, "pthread_setspecific failed: %s", tmp___2);
            }
          }
        }
      }
      {
#line 1873
      pfd.fd = sock;
#line 1874
      pfd.events = (short)1;
#line 1875
      tmp___3 = poll(& pfd, (nfds_t )1, (int )(global.tcp_qtimeout * 1000L));
      }
#line 1875
      if (tmp___3 <= 0) {
        {
#line 1876
        pthread_exit((void *)0);
        }
      }
      {
#line 1881
      err___0 = read(sock, (void *)(& rlen_net), sizeof(rlen_net));
      }
#line 1881
      if ((unsigned long )err___0 != sizeof(rlen_net)) {
#line 1882
        if (debug_p) {
#line 1882
          if (err___0 == -1L) {
            {
#line 1882
            tmp___4 = __errno_location();
#line 1882
            tmp___5 = strerror(*tmp___4);
#line 1882
            tmp___6 = (char const   *)tmp___5;
            }
          } else {
#line 1882
            tmp___6 = "incomplete data";
          }
          {
#line 1882
          debug_msg(0, "Error while reading from TCP client: %s\n", tmp___6);
          }
        }
        {
#line 1887
        pthread_exit((void *)0);
        }
      }
      {
#line 1889
      tmp___7 = ntohs(rlen_net);
#line 1889
      rlen = (int )tmp___7;
      }
#line 1891
      if (rlen == 0) {
        {
#line 1892
        log_message(3, "TCP zero size query received.\n");
#line 1893
        pthread_exit((void *)0);
        }
      }
      {
#line 1895
      tmp___8 = malloc((size_t )rlen);
#line 1895
      buf = (unsigned char *)tmp___8;
      }
#line 1896
      if (! buf) {
#line 1897
        da_mem_errs += (unsigned long volatile   )1;
#line 1897
        if (da_mem_errs <= (unsigned long volatile   )10) {
          {
#line 1898
          log_message(3, "Out of memory in request handling.");
          }
        }
        {
#line 1900
        pthread_exit((void *)0);
        }
      }
      {
#line 1902
      while (1) {
        while_continue___2: /* CIL Label */ ;
        {
#line 1902
        __cancel_routine___0 = (void (*)(void * ))(& free);
#line 1902
        __cancel_arg___0 = (void *)buf;
#line 1902
        tmp___9 = __sigsetjmp((struct __jmp_buf_tag *)((void *)(__cancel_buf___0.__cancel_jmp_buf)),
                              0);
#line 1902
        __not_first_call___0 = tmp___9;
#line 1902
        tmp___10 = __builtin_expect((long )__not_first_call___0, 0L);
        }
#line 1902
        if (tmp___10) {
          {
#line 1902
          (*__cancel_routine___0)(__cancel_arg___0);
#line 1902
          __pthread_unwind_next(& __cancel_buf___0);
          }
        }
        {
#line 1902
        __pthread_register_cancel(& __cancel_buf___0);
        }
        {
#line 1902
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 1904
          olen = 0;
          {
#line 1905
          while (1) {
            while_continue___4: /* CIL Label */ ;
#line 1905
            if (! (olen < rlen)) {
#line 1905
              goto while_break___4;
            }
            {
#line 1915
            pfd.fd = sock;
#line 1916
            pfd.events = (short)1;
#line 1917
            tmp___11 = poll(& pfd, (nfds_t )1, (int )(global.tcp_qtimeout * 1000L));
            }
#line 1917
            if (tmp___11 <= 0) {
              {
#line 1918
              pthread_exit((void *)0);
              }
            }
            {
#line 1920
            tmp___12 = read(sock, (void *)(buf + olen), (size_t )(rlen - olen));
#line 1920
            rv = (int )tmp___12;
            }
#line 1921
            if (rv <= 0) {
#line 1922
              if (debug_p) {
#line 1922
                if (rv == -1) {
                  {
#line 1922
                  tmp___13 = __errno_location();
#line 1922
                  tmp___14 = strerror(*tmp___13);
#line 1922
                  tmp___15 = (char const   *)tmp___14;
                  }
                } else {
#line 1922
                  tmp___15 = "incomplete data";
                }
                {
#line 1922
                debug_msg(0, "Error while reading from TCP client: %s\n", tmp___15);
                }
              }
#line 1927
              if (olen >= 2) {
#line 1929
                if (olen >= 3) {
#line 1929
                  tmp___16 = ((dns_hdr_t *)buf)->opcode;
                } else {
#line 1929
                  tmp___16 = 0U;
                }
                {
#line 1929
                mk_error_reply(((dns_hdr_t *)buf)->id, (unsigned short )tmp___16,
                               (unsigned short)1, & err___1.hdr);
#line 1933
                err___1.len = htons((uint16_t )sizeof(dns_hdr_t ));
#line 1934
                write_all(sock, (void const   *)(& err___1), sizeof(err___1));
                }
              }
              {
#line 1936
              pthread_exit((void *)0);
              }
            }
#line 1938
            olen += rv;
          }
          while_break___4: /* CIL Label */ ;
          }
          {
#line 1940
          nlen = (size_t )rlen;
#line 1941
          resp = process_query(buf, & nlen, (unsigned int *)((void *)0), (int *)((void *)0));
          }
#line 1941
          if (! resp) {
            {
#line 1946
            pthread_exit((void *)0);
            }
          }
          {
#line 1948
          while (1) {
            while_continue___5: /* CIL Label */ ;
#line 1948
            goto while_break___5;
          }
          while_break___5: /* CIL Label */ ;
          }
#line 1902
          goto while_break___3;
        }
        while_break___3: /* CIL Label */ ;
        }
        {
#line 1948
        __pthread_unregister_cancel(& __cancel_buf___0);
#line 1948
        (*__cancel_routine___0)(__cancel_arg___0);
        }
#line 1902
        goto while_break___2;
      }
      while_break___2: /* CIL Label */ ;
      }
      {
#line 1949
      while (1) {
        while_continue___6: /* CIL Label */ ;
        {
#line 1949
        __cancel_routine___1 = (void (*)(void * ))(& free);
#line 1949
        __cancel_arg___1 = (void *)resp;
#line 1949
        tmp___17 = __sigsetjmp((struct __jmp_buf_tag *)((void *)(__cancel_buf___1.__cancel_jmp_buf)),
                               0);
#line 1949
        __not_first_call___1 = tmp___17;
#line 1949
        tmp___18 = __builtin_expect((long )__not_first_call___1, 0L);
        }
#line 1949
        if (tmp___18) {
          {
#line 1949
          (*__cancel_routine___1)(__cancel_arg___1);
#line 1949
          __pthread_unwind_next(& __cancel_buf___1);
          }
        }
        {
#line 1949
        __pthread_register_cancel(& __cancel_buf___1);
        }
        {
#line 1949
        while (1) {
          while_continue___7: /* CIL Label */ ;
          {
#line 1952
          resp->len = htons((uint16_t )nlen);
#line 1953
          rsize = 2UL + nlen;
#line 1954
          tmp___22 = write_all(sock, (void const   *)resp, rsize);
#line 1954
          err___2 = (int )tmp___22;
          }
#line 1954
          if ((size_t )err___2 != rsize) {
#line 1955
            if (debug_p) {
#line 1955
              if (err___2 == -1) {
                {
#line 1955
                tmp___19 = __errno_location();
#line 1955
                tmp___20 = strerror(*tmp___19);
#line 1955
                tmp___21 = (char const   *)tmp___20;
                }
              } else {
#line 1955
                tmp___21 = "unknown error";
              }
              {
#line 1955
              debug_msg(0, "Error while writing to TCP client: %s\n", tmp___21);
              }
            }
            {
#line 1956
            pthread_exit((void *)0);
            }
          }
          {
#line 1959
          while (1) {
            while_continue___8: /* CIL Label */ ;
#line 1959
            goto while_break___8;
          }
          while_break___8: /* CIL Label */ ;
          }
#line 1949
          goto while_break___7;
        }
        while_break___7: /* CIL Label */ ;
        }
        {
#line 1959
        __pthread_unregister_cancel(& __cancel_buf___1);
#line 1959
        (*__cancel_routine___1)(__cancel_arg___1);
        }
#line 1949
        goto while_break___6;
      }
      while_break___6: /* CIL Label */ ;
      }
      {
#line 1963
      while (1) {
        while_continue___9: /* CIL Label */ ;
#line 1963
        goto while_break___9;
      }
      while_break___9: /* CIL Label */ ;
      }
#line 1817
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 1963
    __pthread_unregister_cancel(& __cancel_buf);
#line 1963
    (*__cancel_routine)(__cancel_arg);
    }
#line 1817
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 1964
  return ((void *)0);
}
}
#line 1967 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/dns_answer.c"
int init_tcp_socket(void) 
{ 
  int sock ;
  union __anonunion_sin_119___0 sin ;
  socklen_t sinl ;
  int *tmp ;
  char *tmp___0 ;
  int so ;
  int *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  int *tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;

  {
  {
#line 1982
  sock = socket(2, 1, 6);
  }
#line 1982
  if (sock == -1) {
    {
#line 1983
    tmp = __errno_location();
#line 1983
    tmp___0 = strerror(*tmp);
#line 1983
    log_message(3, "Could not open tcp socket: %s", tmp___0);
    }
#line 1984
    return (-1);
  }
  {
#line 1986
  memset((void *)(& sin.sin4), 0, sizeof(struct sockaddr_in ));
#line 1987
  sin.sin4.sin_family = (sa_family_t )2;
#line 1988
  sin.sin4.sin_port = htons((uint16_t )global.port);
#line 1989
  sin.sin4.sin_addr = global.a.ipv4;
#line 1991
  sinl = (socklen_t )sizeof(struct sockaddr_in );
#line 2010
  so = 1;
#line 2019
  tmp___3 = setsockopt(sock, 1, 2, (void const   *)(& so), (socklen_t )sizeof(so));
  }
#line 2019
  if (tmp___3) {
    {
#line 2020
    tmp___1 = __errno_location();
#line 2020
    tmp___2 = strerror(*tmp___1);
#line 2020
    log_message(4, "Could not set options on tcp socket: %s", tmp___2);
    }
  }
  {
#line 2022
  tmp___6 = bind(sock, (struct sockaddr  const  */* __restrict  */)((struct sockaddr *)(& sin)),
                 sinl);
  }
#line 2022
  if (tmp___6) {
    {
#line 2023
    tmp___4 = __errno_location();
#line 2023
    tmp___5 = strerror(*tmp___4);
#line 2023
    log_message(3, "Could not bind tcp socket: %s", tmp___5);
#line 2024
    close(sock);
    }
#line 2025
    return (-1);
  }
#line 2027
  return (sock);
}
}
#line 2033 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/dns_answer.c"
void *tcp_server_thread(void *p ) 
{ 
  int sock ;
  pthread_t pt ;
  int *csock ;
  int tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  void *tmp___3 ;
  int *tmp___4 ;
  char *tmp___5 ;
  int *tmp___6 ;
  int err ;
  char *tmp___7 ;
  int tmp___8 ;

  {
#line 2043
  if (! global.strict_suid) {
    {
#line 2044
    tmp = run_as((char const   *)(global.run_as));
    }
#line 2044
    if (! tmp) {
      {
#line 2045
      pdnsd_exit();
      }
    }
  }
  {
#line 2049
  sock = (int )tcp_socket;
#line 2051
  tmp___2 = listen(sock, 5);
  }
#line 2051
  if (tmp___2) {
#line 2052
    da_tcp_errs += (unsigned long volatile   )1;
#line 2052
    if (da_tcp_errs <= (unsigned long volatile   )10) {
      {
#line 2053
      tmp___0 = __errno_location();
#line 2053
      tmp___1 = strerror(*tmp___0);
#line 2053
      log_message(3, "Could not listen on tcp socket: %s", tmp___1);
      }
    }
#line 2055
    goto close_sock_return;
  }
  {
#line 2058
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 2059
    tmp___3 = malloc(sizeof(int ));
#line 2059
    csock = (int *)tmp___3;
    }
#line 2059
    if (! csock) {
#line 2060
      da_mem_errs += (unsigned long volatile   )1;
#line 2060
      if (da_mem_errs <= (unsigned long volatile   )10) {
        {
#line 2061
        log_message(3, "Out of memory in request handling.");
        }
      }
#line 2063
      goto while_break;
    }
    {
#line 2065
    tmp___8 = accept(sock, (struct sockaddr */* __restrict  */)((void *)0), (socklen_t */* __restrict  */)0);
#line 2065
    *csock = tmp___8;
    }
#line 2065
    if (tmp___8 == -1) {
      {
#line 2066
      tmp___6 = __errno_location();
      }
#line 2066
      if (*tmp___6 != 4) {
#line 2066
        da_tcp_errs += (unsigned long volatile   )1;
#line 2066
        if (da_tcp_errs <= (unsigned long volatile   )10) {
          {
#line 2067
          tmp___4 = __errno_location();
#line 2067
          tmp___5 = strerror(*tmp___4);
#line 2067
          log_message(3, "tcp accept failed: %s", tmp___5);
          }
        }
      }
    } else {
      {
#line 2074
      pthread_mutex_lock(& proc_lock);
      }
#line 2075
      if (qprocs < (int volatile   )(global.proc_limit + global.procq_limit)) {
        {
#line 2077
        qprocs += (int volatile   )1;
#line 2077
        spawned += (unsigned long volatile   )1;
#line 2078
        pthread_mutex_unlock(& proc_lock);
#line 2079
        err = pthread_create((pthread_t */* __restrict  */)(& pt), (pthread_attr_t const   */* __restrict  */)(& attr_detached),
                             & tcp_answer_thread, (void */* __restrict  */)((void *)csock));
        }
#line 2080
        if (err == 0) {
#line 2081
          goto while_continue;
        }
#line 2082
        da_thrd_errs += (unsigned long volatile   )1;
#line 2082
        if (da_thrd_errs <= (unsigned long volatile   )10) {
          {
#line 2083
          tmp___7 = strerror(err);
#line 2083
          log_message(4, "pthread_create failed: %s", tmp___7);
          }
        }
        {
#line 2085
        pthread_mutex_lock(& proc_lock);
#line 2086
        qprocs -= (int volatile   )1;
#line 2086
        spawned -= (unsigned long volatile   )1;
        }
      }
      {
#line 2088
      dropped += (unsigned long volatile   )1;
#line 2089
      pthread_mutex_unlock(& proc_lock);
#line 2090
      close(*csock);
      }
    }
    {
#line 2092
    free((void *)csock);
#line 2093
    usleep_r(50000UL);
    }
  }
  while_break: /* CIL Label */ ;
  }
  close_sock_return: 
  {
#line 2096
  tcp_socket = (int volatile   )-1;
#line 2097
  close(sock);
#line 2098
  tcps_thrid = main_thrid;
  }
#line 2099
  if (udp_socket == (int volatile   )-1) {
    {
#line 2100
    pdnsd_exit();
    }
  }
#line 2101
  return ((void *)0);
}
}
#line 2109 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/dns_answer.c"
void start_dns_servers(void) 
{ 
  pthread_t tcps ;
  int tmp ;
  pthread_t udps ;
  int tmp___0 ;

  {
#line 2113
  if (tcp_socket != (int volatile   )-1) {
    {
#line 2116
    tmp = pthread_create((pthread_t */* __restrict  */)(& tcps), (pthread_attr_t const   */* __restrict  */)(& attr_detached),
                         & tcp_server_thread, (void */* __restrict  */)((void *)0));
    }
#line 2116
    if (tmp) {
      {
#line 2117
      log_message(3, "Could not create TCP server thread. Exiting.");
#line 2118
      pdnsd_exit();
      }
    } else {
#line 2120
      tcps_thrid = tcps;
#line 2121
      if (2 <= (int )global.verbosity) {
        {
#line 2121
        log_message(6, "TCP server thread started.");
        }
      }
    }
  }
#line 2126
  if (udp_socket != (int volatile   )-1) {
    {
#line 2129
    tmp___0 = pthread_create((pthread_t */* __restrict  */)(& udps), (pthread_attr_t const   */* __restrict  */)(& attr_detached),
                             & udp_server_thread, (void */* __restrict  */)((void *)0));
    }
#line 2129
    if (tmp___0) {
      {
#line 2130
      log_message(3, "Could not create UDP server thread. Exiting.");
#line 2131
      pdnsd_exit();
      }
    } else {
#line 2133
      udps_thrid = udps;
#line 2134
      if (2 <= (int )global.verbosity) {
        {
#line 2134
        log_message(6, "UDP server thread started.");
        }
      }
    }
  }
#line 2137
  return;
}
}
#line 2141 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/dns_answer.c"
int report_thread_stat(int f ) 
{ 
  unsigned long nspawned ;
  unsigned long ndropped ;
  int nactive ;
  int ncurrent ;
  int nqueued ;
  int _retval ;
  int _retval___0 ;
  int tmp ;
  int _retval___1 ;
  int tmp___0 ;
  int _retval___2 ;
  int tmp___1 ;
  int _retval___3 ;
  int tmp___2 ;
  int _retval___4 ;
  int _retval___5 ;

  {
  {
#line 2149
  pthread_mutex_lock(& proc_lock);
#line 2150
  nspawned = (unsigned long )spawned;
#line 2150
  ndropped = (unsigned long )dropped;
#line 2151
  nactive = (int )procs;
#line 2151
  ncurrent = (int )qprocs;
#line 2152
  nqueued = ncurrent - nactive;
#line 2153
  pthread_mutex_unlock(& proc_lock);
#line 2155
  _retval = fsprintf(f, "\nThread status:\n==============\n");
  }
#line 2155
  if (_retval < 0) {
#line 2155
    return (_retval);
  }
  {
#line 2156
  tmp = pthread_equal(servstat_thrid, main_thrid);
  }
#line 2156
  if (! tmp) {
    {
#line 2157
    _retval___0 = fsprintf(f, "server status thread is running.\n");
    }
#line 2157
    if (_retval___0 < 0) {
#line 2157
      return (_retval___0);
    }
  }
  {
#line 2158
  tmp___0 = pthread_equal(statsock_thrid, main_thrid);
  }
#line 2158
  if (! tmp___0) {
    {
#line 2159
    _retval___1 = fsprintf(f, "pdnsd control thread is running.\n");
    }
#line 2159
    if (_retval___1 < 0) {
#line 2159
      return (_retval___1);
    }
  }
  {
#line 2160
  tmp___1 = pthread_equal(tcps_thrid, main_thrid);
  }
#line 2160
  if (! tmp___1) {
    {
#line 2161
    _retval___2 = fsprintf(f, "tcp server thread is running.\n");
    }
#line 2161
    if (_retval___2 < 0) {
#line 2161
      return (_retval___2);
    }
  }
  {
#line 2162
  tmp___2 = pthread_equal(udps_thrid, main_thrid);
  }
#line 2162
  if (! tmp___2) {
    {
#line 2163
    _retval___3 = fsprintf(f, "udp server thread is running.\n");
    }
#line 2163
    if (_retval___3 < 0) {
#line 2163
      return (_retval___3);
    }
  }
  {
#line 2164
  _retval___4 = fsprintf(f, "%lu query threads spawned in total (%lu queries dropped).\n",
                         nspawned, ndropped);
  }
#line 2164
  if (_retval___4 < 0) {
#line 2164
    return (_retval___4);
  }
  {
#line 2166
  _retval___5 = fsprintf(f, "%i running query threads (%i active, %i queued).\n",
                         ncurrent, nactive, nqueued);
  }
#line 2166
  if (_retval___5 < 0) {
#line 2166
    return (_retval___5);
  }
#line 2168
  return (0);
}
}
#line 31 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/consts.c"
static namevalue_t const   const_dic[29]  = 
#line 31 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/consts.c"
  {      {"auth", 22}, 
        {"default", 3}, 
        {"dev", 16}, 
        {"diald", 17}, 
        {"discover", 4}, 
        {"domain", 23}, 
        {"excluded", 19}, 
        {"exec", 7}, 
        {"fail", 24}, 
        {"false", 2}, 
        {"fqdn_only", 21}, 
        {"if", 6}, 
        {"included", 18}, 
        {"negate", 25}, 
        {"no", 2}, 
        {"none", 5}, 
        {"off", 2}, 
        {"on", 1}, 
        {"onquery", 10}, 
        {"ontimeout", 11}, 
        {"ping", 8}, 
        {"query", 9}, 
        {"simple_only", 20}, 
        {"tcp_only", 13}, 
        {"tcp_udp", 14}, 
        {"true", 1}, 
        {"udp_only", 12}, 
        {"udp_tcp", 15}, 
        {"yes", 1}};
#line 64 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/consts.c"
static char const   * const  const_names[26]  = 
#line 64
  {      (char const   */* const  */)"error",      (char const   */* const  */)"on",      (char const   */* const  */)"off",      (char const   */* const  */)"default", 
        (char const   */* const  */)"discover",      (char const   */* const  */)"none",      (char const   */* const  */)"if",      (char const   */* const  */)"exec", 
        (char const   */* const  */)"ping",      (char const   */* const  */)"query",      (char const   */* const  */)"onquery",      (char const   */* const  */)"ontimeout", 
        (char const   */* const  */)"udp_only",      (char const   */* const  */)"tcp_only",      (char const   */* const  */)"tcp_udp",      (char const   */* const  */)"udp_tcp", 
        (char const   */* const  */)"dev",      (char const   */* const  */)"diald",      (char const   */* const  */)"included",      (char const   */* const  */)"excluded", 
        (char const   */* const  */)"simple_only",      (char const   */* const  */)"fqdn_only",      (char const   */* const  */)"auth",      (char const   */* const  */)"domain", 
        (char const   */* const  */)"fail",      (char const   */* const  */)"negate"};
#line 98 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/consts.c"
__inline static int keyncmp(char const   *key1 , int len , char const   *key2 ) 
{ 
  int cmp ;
  int tmp ;

  {
  {
#line 100
  tmp = strncmp(key1, key2, (size_t )len);
#line 100
  cmp = tmp;
  }
#line 101
  if (cmp) {
#line 101
    return (cmp);
  }
#line 102
  return (- ((int )((unsigned char )*(key2 + len))));
}
}
#line 105 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/consts.c"
int binsearch_keyword(char const   *name , int len , namevalue_t const   *dic , int range ) 
{ 
  int i ;
  int j ;
  int k ;
  int cmp ;
  int tmp ;

  {
#line 107
  i = 0;
#line 107
  j = range;
  {
#line 109
  while (1) {
    while_continue: /* CIL Label */ ;
#line 109
    if (! (i < j)) {
#line 109
      goto while_break;
    }
    {
#line 110
    k = (i + j) / 2;
#line 111
    tmp = keyncmp(name, len, (char const   *)(dic + k)->name);
#line 111
    cmp = tmp;
    }
#line 112
    if (cmp < 0) {
#line 113
      j = k;
    } else
#line 114
    if (cmp > 0) {
#line 115
      i = k + 1;
    } else {
#line 117
      return ((int )(dic + k)->val);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 120
  return (0);
}
}
#line 124 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/consts.c"
int lookup_const(char const   *name , int len ) 
{ 
  int tmp ;

  {
  {
#line 126
  tmp = binsearch_keyword(name, len, const_dic, (int )(sizeof(const_dic) / sizeof(namevalue_t )));
  }
#line 126
  return (tmp);
}
}
#line 130 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/consts.c"
char const   *const_name(int c ) 
{ 
  char const   *tmp ;

  {
#line 132
  if (c >= 0) {
#line 132
    if ((unsigned long )c < sizeof(const_names) / sizeof(char *)) {
#line 132
      tmp = const_names[c];
    } else {
#line 132
      tmp = (char const   */* const  */)"ILLEGAL!";
    }
  } else {
#line 132
    tmp = (char const   */* const  */)"ILLEGAL!";
  }
#line 132
  return ((char const   *)tmp);
}
}
#line 127 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) toupper)(int __c ) ;
#line 57 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/list.h"
__inline static unsigned int ( __attribute__((__always_inline__)) da_nel)(darray a ) ;
#line 46 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/hash.h"
dns_hash_ent_t *hash_buckets[1 << 10]  ;
#line 212 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/helpers.h"
__inline static int ( __attribute__((__always_inline__)) rhnicmp)(unsigned char const   *a ,
                                                                  unsigned char const   *b ) ;
#line 57 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/hash.c"
static unsigned int dns_hash(unsigned char const   *str , unsigned long *rhash ) 
{ 
  unsigned int s ;
  unsigned int i ;
  unsigned int lb ;
  unsigned int c ;
  unsigned long r ;
  int tmp ;

  {
#line 61
  s = 0U;
#line 61
  r = 0UL;
#line 62
  i = 0U;
  {
#line 63
  while (1) {
    while_continue: /* CIL Label */ ;
#line 63
    lb = (unsigned int )*(str + i);
#line 63
    if (! lb) {
#line 63
      goto while_break;
    }
#line 64
    s += lb << i % 5U;
#line 65
    r += (unsigned long )lb << (unsigned long )i % (8UL * sizeof(unsigned long ) - 7UL);
#line 66
    i ++;
    {
#line 67
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 68
      tmp = toupper((int )*(str + i));
#line 68
      c = (unsigned int )tmp;
#line 69
      s += c << i % 5U;
#line 70
      r += (unsigned long )c << (unsigned long )i % (8UL * sizeof(unsigned long ) - 7UL);
#line 71
      i ++;
#line 67
      lb --;
      }
#line 67
      if (! lb) {
#line 67
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 74
  s = (s & (unsigned int )((1 << 10) - 1)) + ((s & (unsigned int )(~ ((1 << 10) - 1))) >> 10);
#line 75
  s = (s & (unsigned int )((1 << 10) - 1)) + ((s & (unsigned int )(~ ((1 << 10) - 1))) >> 10);
#line 76
  s &= (unsigned int )((1 << 10) - 1);
#line 83
  if (rhash) {
#line 83
    *rhash = r;
  }
#line 84
  return (s);
}
}
#line 106 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/hash.c"
dns_cent_t *dns_lookup(unsigned char const   *key , dns_hash_loc_t *loc ) 
{ 
  dns_cent_t *retval ;
  unsigned int idx ;
  unsigned long rh ;
  dns_hash_ent_t **hep ;
  dns_hash_ent_t *he ;
  int tmp ;

  {
  {
#line 108
  retval = (dns_cent_t *)((void *)0);
#line 113
  idx = dns_hash(key, & rh);
#line 114
  hep = & hash_buckets[idx];
  }
  {
#line 115
  while (1) {
    while_continue: /* CIL Label */ ;
#line 115
    he = *hep;
#line 115
    if (he) {
#line 115
      if (! (he->rhash <= rh)) {
#line 115
        goto while_break;
      }
    } else {
#line 115
      goto while_break;
    }
#line 116
    if (he->rhash == rh) {
      {
#line 116
      tmp = rhnicmp(key, (unsigned char const   *)(he->data)->qname);
      }
#line 116
      if (tmp) {
#line 117
        retval = he->data;
#line 118
        goto while_break;
      }
    }
#line 120
    hep = & he->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 122
  if (loc) {
#line 123
    loc->pos = hep;
#line 124
    loc->rhash = rh;
  }
#line 126
  return (retval);
}
}
#line 137 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/hash.c"
int add_dns_hash(dns_cent_t *data , dns_hash_loc_t *loc ) 
{ 
  dns_hash_ent_t *he ;
  void *tmp ;

  {
  {
#line 139
  tmp = malloc(sizeof(dns_hash_ent_t ));
#line 139
  he = (dns_hash_ent_t *)tmp;
  }
#line 141
  if (! he) {
#line 142
    return (0);
  }
#line 144
  he->next = *(loc->pos);
#line 145
  he->rhash = loc->rhash;
#line 146
  he->data = data;
#line 147
  *(loc->pos) = he;
#line 149
  return (1);
}
}
#line 155 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/hash.c"
dns_cent_t *del_dns_hash_ent(dns_hash_loc_t *loc ) 
{ 
  dns_hash_ent_t *he ;
  dns_cent_t *data ;

  {
  {
#line 157
  he = *(loc->pos);
#line 160
  *(loc->pos) = he->next;
#line 161
  data = he->data;
#line 162
  free((void *)he);
  }
#line 163
  return (data);
}
}
#line 170 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/hash.c"
dns_cent_t *del_dns_hash(unsigned char const   *key ) 
{ 
  unsigned int idx ;
  unsigned long rh ;
  dns_hash_ent_t **hep ;
  dns_hash_ent_t *he ;
  dns_cent_t *data ;
  int tmp ;

  {
  {
#line 177
  idx = dns_hash(key, & rh);
#line 178
  hep = & hash_buckets[idx];
  }
  {
#line 179
  while (1) {
    while_continue: /* CIL Label */ ;
#line 179
    he = *hep;
#line 179
    if (he) {
#line 179
      if (! (he->rhash <= rh)) {
#line 179
        goto while_break;
      }
    } else {
#line 179
      goto while_break;
    }
#line 180
    if (he->rhash == rh) {
      {
#line 180
      tmp = rhnicmp(key, (unsigned char const   *)(he->data)->qname);
      }
#line 180
      if (tmp) {
        {
#line 181
        *hep = he->next;
#line 182
        data = he->data;
#line 183
        free((void *)he);
        }
#line 184
        return (data);
      }
    }
#line 186
    hep = & he->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 188
  return ((dns_cent_t *)((void *)0));
}
}
#line 195 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/hash.c"
void free_dns_hash_bucket(int i ) 
{ 
  dns_hash_ent_t *he ;
  dns_hash_ent_t *hen ;

  {
#line 199
  he = hash_buckets[i];
#line 200
  hash_buckets[i] = (dns_hash_ent_t *)((void *)0);
  {
#line 201
  while (1) {
    while_continue: /* CIL Label */ ;
#line 201
    if (! he) {
#line 201
      goto while_break;
    }
    {
#line 202
    hen = he->next;
#line 203
    del_cent(he->data);
#line 204
    free((void *)he);
#line 205
    he = hen;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 207
  return;
}
}
#line 213 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/hash.c"
void free_dns_hash_selected(int i , slist_array sla ) 
{ 
  dns_hash_ent_t **hep ;
  dns_hash_ent_t *he ;
  dns_hash_ent_t *hen ;
  int j ;
  int m ;
  unsigned int tmp ;
  unsigned char *name ;
  slist_t *sl ;
  unsigned int nrem ;
  unsigned int lrem ;

  {
  {
#line 216
  tmp = da_nel((darray )sla);
#line 216
  m = (int )tmp;
#line 218
  hep = & hash_buckets[i];
#line 219
  he = *hep;
  }
  {
#line 221
  while (1) {
    while_continue: /* CIL Label */ ;
#line 221
    if (! he) {
#line 221
      goto while_break;
    }
#line 222
    name = (he->data)->qname;
#line 223
    j = 0;
    {
#line 223
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 223
      if (! (j < m)) {
#line 223
        goto while_break___0;
      }
      {
#line 224
      sl = & sla->elem[j];
#line 226
      domain_match((unsigned char const   *)name, (unsigned char const   *)sl->domain,
                   & nrem, & lrem);
      }
#line 227
      if (! lrem) {
#line 227
        if (! sl->exact) {
#line 227
          goto _L;
        } else
#line 227
        if (! nrem) {
          _L: /* CIL Label */ 
#line 228
          if ((int )sl->rule == 18) {
#line 229
            goto delete_entry;
          } else {
#line 231
            goto while_break___0;
          }
        }
      }
#line 223
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 235
    hep = & he->next;
#line 236
    he = *hep;
#line 237
    goto while_continue;
    delete_entry: 
    {
#line 240
    hen = he->next;
#line 240
    *hep = hen;
#line 241
    del_cent(he->data);
#line 242
    free((void *)he);
#line 243
    he = hen;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 245
  return;
}
}
#line 250 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/hash.c"
void free_dns_hash(void) 
{ 
  int i ;
  dns_hash_ent_t *he ;
  dns_hash_ent_t *hen ;

  {
#line 254
  i = 0;
  {
#line 254
  while (1) {
    while_continue: /* CIL Label */ ;
#line 254
    if (! (i < 1 << 10)) {
#line 254
      goto while_break;
    }
#line 255
    he = hash_buckets[i];
#line 256
    hash_buckets[i] = (dns_hash_ent_t *)((void *)0);
    {
#line 257
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 257
      if (! he) {
#line 257
        goto while_break___0;
      }
      {
#line 258
      hen = he->next;
#line 259
      del_cent(he->data);
#line 260
      free((void *)he);
#line 261
      he = hen;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 254
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 264
  return;
}
}
#line 275 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/hash.c"
dns_cent_t *fetch_first(dns_hash_pos_t *pos ) 
{ 
  int i ;
  dns_hash_ent_t *he ;

  {
#line 278
  i = 0;
  {
#line 278
  while (1) {
    while_continue: /* CIL Label */ ;
#line 278
    if (! (i < 1 << 10)) {
#line 278
      goto while_break;
    }
#line 279
    he = hash_buckets[i];
#line 280
    if (he) {
#line 281
      pos->bucket = i;
#line 282
      pos->ent = he->next;
#line 283
      return (he->data);
    }
#line 278
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 286
  return ((dns_cent_t *)((void *)0));
}
}
#line 289 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/hash.c"
dns_cent_t *fetch_next(dns_hash_pos_t *pos ) 
{ 
  dns_hash_ent_t *he ;
  int i ;

  {
#line 291
  he = pos->ent;
#line 293
  if (he) {
#line 294
    pos->ent = he->next;
#line 295
    return (he->data);
  }
#line 298
  i = pos->bucket + 1;
  {
#line 298
  while (1) {
    while_continue: /* CIL Label */ ;
#line 298
    if (! (i < 1 << 10)) {
#line 298
      goto while_break;
    }
#line 299
    he = hash_buckets[i];
#line 300
    if (he) {
#line 301
      pos->bucket = i;
#line 302
      pos->ent = he->next;
#line 303
      return (he->data);
    }
#line 298
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 306
  return ((dns_cent_t *)((void *)0));
}
}
#line 38 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/list.c"
darray da_grow1(darray a , size_t headsz , size_t elemsz , void (*cleanuproutine)(void * ) ) 
{ 
  size_t k ;
  size_t tmp ;
  darray tmp___0 ;
  void *tmp___1 ;
  size_t i ;

  {
#line 40
  if (a) {
#line 40
    tmp = a->nel;
  } else {
#line 40
    tmp = (size_t )0;
  }
#line 40
  k = tmp;
#line 41
  if (! a) {
#line 41
    goto _L;
  } else
#line 41
  if (k != 0UL) {
#line 41
    if ((k & 7UL) == 0UL) {
      _L: /* CIL Label */ 
      {
#line 42
      tmp___1 = realloc((void *)a, headsz + elemsz * (k + 8UL));
#line 42
      tmp___0 = (darray )tmp___1;
      }
#line 43
      if (! tmp___0) {
#line 43
        if (a) {
#line 44
          if (cleanuproutine) {
#line 46
            i = (size_t )0;
            {
#line 46
            while (1) {
              while_continue: /* CIL Label */ ;
#line 46
              if (! (i < k)) {
#line 46
                goto while_break;
              }
              {
#line 47
              (*cleanuproutine)((void *)(((char *)a + headsz) + elemsz * i));
#line 46
              i ++;
              }
            }
            while_break: /* CIL Label */ ;
            }
          }
          {
#line 49
          free((void *)a);
          }
        }
      }
#line 51
      a = tmp___0;
    }
  }
#line 53
  if (a) {
#line 53
    a->nel = k + 1UL;
  }
#line 54
  return (a);
}
}
#line 57 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/list.c"
__inline static size_t alloc_nel(size_t n ) 
{ 
  unsigned long tmp ;

  {
#line 59
  if (n == 0UL) {
#line 59
    tmp = 8UL;
  } else {
#line 59
    tmp = (n + 7UL) & 0xfffffffffffffff8UL;
  }
#line 59
  return (tmp);
}
}
#line 65 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/list.c"
darray da_resize(darray a , size_t headsz , size_t elemsz , size_t n , void (*cleanuproutine)(void * ) ) 
{ 
  size_t ael ;
  size_t tmp ;
  size_t tmp___0 ;
  size_t new_ael ;
  size_t tmp___1 ;
  darray tmp___2 ;
  void *tmp___3 ;
  size_t i ;
  size_t k ;

  {
#line 67
  if (a) {
    {
#line 67
    tmp = alloc_nel(a->nel);
#line 67
    tmp___0 = tmp;
    }
  } else {
#line 67
    tmp___0 = (size_t )0;
  }
  {
#line 67
  ael = tmp___0;
#line 68
  tmp___1 = alloc_nel(n);
#line 68
  new_ael = tmp___1;
  }
#line 69
  if (new_ael != ael) {
    {
#line 71
    tmp___3 = realloc((void *)a, headsz + elemsz * new_ael);
#line 71
    tmp___2 = (darray )tmp___3;
    }
#line 72
    if (! tmp___2) {
#line 72
      if (a) {
#line 73
        if (cleanuproutine) {
#line 74
          k = a->nel;
#line 75
          i = (size_t )0;
          {
#line 75
          while (1) {
            while_continue: /* CIL Label */ ;
#line 75
            if (! (i < k)) {
#line 75
              goto while_break;
            }
            {
#line 76
            (*cleanuproutine)((void *)(((char *)a + headsz) + elemsz * i));
#line 75
            i ++;
            }
          }
          while_break: /* CIL Label */ ;
          }
        }
        {
#line 78
        free((void *)a);
        }
      }
    }
#line 80
    a = tmp___2;
  }
#line 82
  if (a) {
#line 82
    a->nel = n;
  }
#line 83
  return (a);
}
}
#line 107 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/list.c"
dlist dlist_grow(dlist a , size_t len ) 
{ 
  size_t sz ;
  size_t allocsz ;
  size_t szincr ;
  size_t newsz ;
  dlist tmp ;
  void *tmp___0 ;

  {
#line 109
  sz = (size_t )0;
#line 109
  allocsz = (size_t )0;
#line 110
  if (a) {
#line 111
    sz = a->last + a->lastsz;
#line 112
    allocsz = (sz + 1023UL) & 0xfffffffffffffc00UL;
#line 113
    *((size_t *)(& a->data[a->last])) = a->lastsz;
  }
#line 115
  szincr = ((len + sizeof(size_t )) + (sizeof(size_t ) - 1UL)) & ~ (sizeof(size_t ) - 1UL);
#line 116
  newsz = sz + szincr;
#line 117
  if (newsz > allocsz) {
    {
#line 119
    allocsz = (newsz + 1023UL) & 0xfffffffffffffc00UL;
#line 120
    tmp___0 = realloc((void *)a, sizeof(struct _dynamic_list_head ) + allocsz);
#line 120
    tmp = (dlist )tmp___0;
    }
#line 121
    if (! tmp) {
      {
#line 122
      free((void *)a);
      }
    }
#line 123
    a = tmp;
  }
#line 125
  if (a) {
#line 126
    a->last = sz;
#line 127
    a->lastsz = szincr;
#line 128
    *((size_t *)(& a->data[sz])) = (size_t )0;
  }
#line 130
  return (a);
}
}
#line 138 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/list.c"
int llist_grow(llist *a , size_t len ) 
{ 
  struct llistnode_s *new ;
  void *tmp ;

  {
  {
#line 140
  tmp = malloc(sizeof(struct llistnode_s ) + len);
#line 140
  new = (struct llistnode_s *)tmp;
  }
#line 142
  if (! new) {
    {
#line 143
    llist_free(a);
    }
#line 144
    return (0);
  }
#line 147
  new->next = (struct llistnode_s *)((void *)0);
#line 149
  if (! a->first) {
#line 150
    a->first = new;
  } else {
#line 152
    (a->last)->next = new;
  }
#line 154
  a->last = new;
#line 156
  return (1);
}
}
#line 159 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/list.c"
void llist_free(llist *a ) 
{ 
  struct llistnode_s *p ;
  struct llistnode_s *next ;

  {
#line 161
  p = a->first;
  {
#line 163
  while (1) {
    while_continue: /* CIL Label */ ;
#line 163
    if (! p) {
#line 163
      goto while_break;
    }
    {
#line 164
    next = p->next;
#line 165
    free((void *)p);
#line 166
    p = next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 169
  a->first = (struct llistnode_s *)((void *)0);
#line 170
  a->last = (struct llistnode_s *)((void *)0);
#line 171
  return;
}
}
#line 573 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) execl)(char const   *__path ,
                                                                                              char const   *__arg 
                                                                                              , ...) ;
#line 681
extern  __attribute__((__nothrow__)) __gid_t ( __attribute__((__leaf__)) getgid)(void) ;
#line 50 "/usr/include/x86_64-linux-gnu/sys/resource.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) getrlimit)(__rlimit_resource_t __resource ,
                                                                                struct rlimit *__rlimits ) ;
#line 125 "/usr/include/x86_64-linux-gnu/sys/wait.h"
extern __pid_t waitpid(__pid_t __pid , int *__stat_loc , int __options ) ;
#line 56 "/usr/include/fnmatch.h"
extern int fnmatch(char const   *__pattern , char const   *__name , int __flags ) ;
#line 57 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/list.h"
__inline static unsigned int ( __attribute__((__always_inline__)) da_nel)(darray a ) ;
#line 114 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/helpers.h"
__inline static int ( __attribute__((__always_inline__)) is_inaddr_any)(pdnsd_a *a ) ;
#line 139
__inline static int ( __attribute__((__always_inline__)) same_inaddr2)(pdnsd_a *a ,
                                                                       pdnsd_a2 *b ) ;
#line 147
__inline static int ( __attribute__((__always_inline__)) equiv_inaddr2)(pdnsd_a *a ,
                                                                        pdnsd_a2 *b ) ;
#line 47 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/servers.h"
__inline static int ( __attribute__((__always_inline__)) needs_testing)(servparm_t *sp ) ;
#line 54
__inline static int ( __attribute__((__always_inline__)) needs_intermittent_testing)(servparm_t *sp ) ;
#line 56 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/servers.h"
__inline static int ( __attribute__((__always_inline__)) needs_intermittent_testing)(servparm_t *sp ) 
{ 
  int tmp ;

  {
#line 58
  if (sp->interval > 0L) {
#line 58
    if ((int )sp->uptest != 5) {
#line 58
      tmp = 1;
    } else
#line 58
    if (sp->scheme[0]) {
#line 58
      tmp = 1;
    } else {
#line 58
      tmp = 0;
    }
  } else {
#line 58
    tmp = 0;
  }
#line 58
  return (tmp);
}
}
#line 56 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/servers.c"
static pthread_mutex_t servers_lock  =    {{0, 0U, 0, 0U, 0, (short)0, (short)0, {(struct __pthread_internal_list *)0, (struct __pthread_internal_list *)0}}};
#line 57 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/servers.c"
static pthread_cond_t server_data_cond  =    {{0, 0U, 0ULL, 0ULL, 0ULL, (void *)0, 0U, 0U}};
#line 58 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/servers.c"
static pthread_cond_t server_test_cond  =    {{0, 0U, 0ULL, 0ULL, 0ULL, (void *)0, 0U, 0U}};
#line 59 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/servers.c"
static int server_data_users  =    0;
#line 59 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/servers.c"
static int server_status_ping  =    0;
#line 61 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/servers.c"
int volatile   signal_interrupt  =    (int volatile   )0;
#line 64 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/servers.c"
static short retest_flag  =    (short)0;
#line 66 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/servers.c"
static char schm[32]  ;
#line 68
static void sigint_handler(int signum ) ;
#line 73 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/servers.c"
static int uptest(servparm_t *serv , int j ) 
{ 
  int ret ;
  int count_running_ping ;
  pdnsd_a *s_addr ;
  char _debugsockabuf[16] ;
  char const   *tmp ;
  char const   *tmp___0 ;
  pthread_t tmp___1 ;
  int tmp___2 ;
  pdnsd_a *tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  pid_t pid ;
  int *tmp___7 ;
  char *tmp___8 ;
  int *tmp___9 ;
  char *tmp___10 ;
  __gid_t tmp___11 ;
  int tmp___12 ;
  __uid_t tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  struct rlimit rl ;
  int i ;
  int *tmp___16 ;
  char *tmp___17 ;
  int tmp___18 ;
  int *tmp___19 ;
  char *tmp___20 ;
  int tmp___21 ;
  int *tmp___22 ;
  int status ;
  pid_t wpid ;
  __pid_t tmp___23 ;
  int exitstatus ;
  union __anonunion_129 __constr_expr_0 ;
  union __anonunion_130 __constr_expr_1 ;
  union __anonunion_131 __constr_expr_2 ;
  union __anonunion_132 __constr_expr_3 ;
  int *tmp___24 ;
  char *tmp___25 ;
  time_t tmp___26 ;
  char _debugsockabuf___0[16] ;
  char const   *tmp___27 ;
  char const   *tmp___28 ;

  {
#line 75
  ret = 0;
#line 75
  count_running_ping = 0;
#line 76
  s_addr = (pdnsd_a *)(& (serv->atup_a)->elem[j].a.ipv4);
#line 78
  if (debug_p) {
    {
#line 78
    tmp = pdnsd_a2str(s_addr, _debugsockabuf, 16);
#line 78
    tmp___0 = const_name((int )serv->uptest);
#line 78
    debug_msg(0, "performing uptest (type=%s) for %s\n", tmp___0, tmp);
    }
  }
#line 81
  server_data_users ++;
#line 82
  if ((int )serv->uptest == 8) {
#line 82
    goto _L;
  } else
#line 82
  if ((int )serv->uptest == 9) {
    _L: /* CIL Label */ 
    {
#line 82
    tmp___1 = pthread_self();
#line 82
    tmp___2 = pthread_equal(tmp___1, servstat_thrid);
    }
#line 82
    if (tmp___2) {
#line 84
      count_running_ping = 1;
#line 85
      server_status_ping ++;
    }
  }
  {
#line 87
  pthread_mutex_unlock(& servers_lock);
  }
  {
#line 90
  if ((int )serv->uptest == 5) {
#line 90
    goto case_5;
  }
#line 94
  if ((int )serv->uptest == 8) {
#line 94
    goto case_8;
  }
#line 99
  if ((int )serv->uptest == 17) {
#line 99
    goto case_17;
  }
#line 99
  if ((int )serv->uptest == 16) {
#line 99
    goto case_17;
  }
#line 99
  if ((int )serv->uptest == 6) {
#line 99
    goto case_17;
  }
#line 110
  if ((int )serv->uptest == 7) {
#line 110
    goto case_7;
  }
#line 185
  if ((int )serv->uptest == 9) {
#line 185
    goto case_9;
  }
#line 89
  goto switch_break;
  case_5: /* CIL Label */ 
#line 92
  ret = (int )(serv->atup_a)->elem[j].is_up;
#line 93
  goto switch_break;
  case_8: /* CIL Label */ 
  {
#line 95
  tmp___5 = is_inaddr_any(& serv->ping_a);
  }
#line 95
  if (tmp___5) {
#line 95
    tmp___4 = s_addr;
  } else {
#line 95
    tmp___4 = & serv->ping_a;
  }
  {
#line 95
  tmp___6 = ping(tmp___4, (int )serv->ping_timeout, 2);
#line 95
  ret = tmp___6 != -1;
  }
#line 96
  goto switch_break;
  case_17: /* CIL Label */ 
  case_16: /* CIL Label */ 
  case_6: /* CIL Label */ 
  {
#line 100
  ret = if_up(serv->interface);
  }
#line 102
  if (ret != 0) {
#line 103
    if ((int )serv->uptest == 16) {
      {
#line 104
      ret = dev_up(serv->interface, serv->device);
      }
    } else
#line 105
    if ((int )serv->uptest == 17) {
      {
#line 106
      ret = dev_up((char *)"diald", serv->device);
      }
    }
  }
#line 109
  goto switch_break;
  case_7: /* CIL Label */ 
  {
#line 113
  pid = fork();
  }
#line 113
  if (pid == -1) {
#line 114
    if (debug_p) {
      {
#line 114
      tmp___7 = __errno_location();
#line 114
      tmp___8 = strerror(*tmp___7);
#line 114
      debug_msg(0, "Could not fork to perform exec uptest: %s\n", tmp___8);
      }
    }
#line 115
    goto switch_break;
  } else
#line 116
  if (pid == 0) {
    {
#line 122
    tmp___11 = getgid();
#line 122
    tmp___12 = setgid(tmp___11);
    }
#line 122
    if (tmp___12 == -1) {
      {
#line 123
      tmp___9 = __errno_location();
#line 123
      tmp___10 = strerror(*tmp___9);
#line 123
      log_message(3, "Could not reset uid or gid: %s", tmp___10);
#line 124
      _exit(1);
      }
    } else {
      {
#line 122
      tmp___13 = getuid();
#line 122
      tmp___14 = setuid(tmp___13);
      }
#line 122
      if (tmp___14 == -1) {
        {
#line 123
        tmp___9 = __errno_location();
#line 123
        tmp___10 = strerror(*tmp___9);
#line 123
        log_message(3, "Could not reset uid or gid: %s", tmp___10);
#line 124
        _exit(1);
        }
      }
    }
    {
#line 128
    tmp___15 = run_as((char const   *)(serv->uptest_usr));
    }
#line 128
    if (! tmp___15) {
      {
#line 129
      _exit(1);
      }
    }
    {
#line 136
    tmp___18 = getrlimit((__rlimit_resource_t )7, & rl);
    }
#line 136
    if (tmp___18 == -1) {
      {
#line 137
      tmp___16 = __errno_location();
#line 137
      tmp___17 = strerror(*tmp___16);
#line 137
      log_message(3, "getrlimit() failed: %s", tmp___17);
#line 138
      _exit(1);
      }
    }
#line 140
    i = 0;
    {
#line 140
    while (1) {
      while_continue: /* CIL Label */ ;
#line 140
      if (! ((rlim_t )i < rl.rlim_max)) {
#line 140
        goto while_break;
      }
      {
#line 141
      tmp___21 = fcntl(i, 2, 1);
      }
#line 141
      if (tmp___21 == -1) {
        {
#line 141
        tmp___22 = __errno_location();
        }
#line 141
        if (*tmp___22 != 9) {
          {
#line 142
          tmp___19 = __errno_location();
#line 142
          tmp___20 = strerror(*tmp___19);
#line 142
          log_message(3, "fcntl(F_SETFD) failed: %s", tmp___20);
#line 143
          _exit(1);
          }
        }
      }
#line 140
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 147
    execl("/bin/sh", "uptest_sh", "-c", serv->uptest_cmd, (char *)((void *)0));
#line 148
    _exit(1);
    }
  } else {
    {
#line 151
    tmp___23 = waitpid(pid, & status, 0);
#line 151
    wpid = tmp___23;
    }
#line 152
    if (wpid == pid) {
#line 153
      __constr_expr_3.__in = status;
#line 153
      if ((__constr_expr_3.__i & 127) == 0) {
#line 154
        __constr_expr_0.__in = status;
#line 154
        exitstatus = (__constr_expr_0.__i & 65280) >> 8;
#line 155
        if (debug_p) {
          {
#line 155
          debug_msg(0, "uptest command \"%s\" exited with status %d\n", serv->uptest_cmd,
                    exitstatus);
          }
        }
#line 157
        ret = exitstatus == 0;
      } else {
#line 160
        __constr_expr_2.__in = status;
#line 160
        if ((int )((signed char )((__constr_expr_2.__i & 127) + 1)) >> 1 > 0) {
#line 161
          if (debug_p) {
            {
#line 161
            __constr_expr_1.__in = status;
#line 161
            debug_msg(0, "uptest command \"%s\" was terminated by signal %d\n", serv->uptest_cmd,
                      __constr_expr_1.__i & 127);
            }
          }
        } else
#line 165
        if (debug_p) {
          {
#line 165
          debug_msg(0, "status of uptest command \"%s\" is of unknown type (0x%x)\n",
                    serv->uptest_cmd, status);
          }
        }
      }
    } else
#line 171
    if (wpid == -1) {
#line 172
      if (debug_p) {
        {
#line 172
        tmp___24 = __errno_location();
#line 172
        tmp___25 = strerror(*tmp___24);
#line 172
        debug_msg(0, "Error while waiting for uptest command \"%s\" to terminate: waitpid for pid %d failed: %s\n",
                  serv->uptest_cmd, pid, tmp___25);
        }
      }
    } else
#line 177
    if (debug_p) {
      {
#line 177
      debug_msg(0, "Error while waiting for uptest command \"%s\" to terminate: waitpid returned %d, expected pid %d\n",
                serv->uptest_cmd, wpid, pid);
      }
    }
  }
#line 184
  goto switch_break;
  case_9: /* CIL Label */ 
#line 186
  if (serv->timeout >= global.timeout) {
#line 186
    tmp___26 = serv->timeout;
  } else {
#line 186
    tmp___26 = global.timeout;
  }
  {
#line 186
  ret = query_uptest(s_addr, (int )serv->port, (unsigned char const   *)serv->query_test_name,
                     tmp___26, 2);
  }
  switch_break: /* CIL Label */ ;
  }
  {
#line 191
  pthread_mutex_lock(& servers_lock);
  }
#line 192
  if (count_running_ping) {
#line 193
    server_status_ping --;
  }
#line 194
  if (! (server_data_users > 0)) {
    {
#line 194
    log_message(3, "%s:%d: %s", "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/servers.c",
                194, "server_data_users non-positive before attempt to decrement it");
#line 194
    pdnsd_exit();
    }
  }
#line 195
  server_data_users --;
#line 195
  if (server_data_users == 0) {
    {
#line 195
    pthread_cond_broadcast(& server_data_cond);
    }
  }
#line 197
  if (debug_p) {
#line 197
    if (ret) {
#line 197
      tmp___27 = "OK";
    } else {
#line 197
      tmp___27 = "failed";
    }
    {
#line 197
    tmp___28 = pdnsd_a2str(s_addr, _debugsockabuf___0, 16);
#line 197
    debug_msg(0, "result of uptest for %s: %s\n", tmp___28, tmp___27);
    }
  }
#line 200
  return (ret);
}
}
#line 203 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/servers.c"
static int scheme_ok(servparm_t *serv ) 
{ 
  ssize_t nschm ;
  int sc ;
  int tmp ;
  char *s ;
  int tmp___0 ;

  {
#line 205
  if (serv->scheme[0]) {
#line 206
    if (! schm[0]) {
      {
#line 208
      tmp = open((char const   *)global.scheme_file, 0);
#line 208
      sc = tmp;
      }
#line 210
      if (sc < 0) {
#line 211
        return (0);
      }
      {
#line 212
      nschm = read(sc, (void *)(schm), sizeof(schm) - 1UL);
#line 213
      close(sc);
      }
#line 214
      if (nschm < 0L) {
#line 215
        return (0);
      }
      {
#line 216
      schm[nschm] = (char )'\000';
#line 217
      s = strchr((char const   *)(schm), '\n');
      }
#line 218
      if (s) {
#line 219
        *s = (char )'\000';
      }
    }
    {
#line 221
    tmp___0 = fnmatch((char const   *)(serv->scheme), (char const   *)(schm), 0);
    }
#line 221
    if (tmp___0) {
#line 222
      return (0);
    }
  }
#line 224
  return (1);
}
}
#line 230 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/servers.c"
static void retest(int i , int j ) 
{ 
  time_t s_ts ;
  servparm_t *srv ;
  int nsrvs ;
  unsigned int tmp ;
  atup_t *at ;
  atup_t *at___0 ;
  int tmp___0 ;
  int res ;
  atup_t *at___1 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 233
  srv = & servers->elem[i];
#line 234
  tmp = da_nel((darray )srv->atup_a);
#line 234
  nsrvs = (int )tmp;
  }
#line 236
  if (! nsrvs) {
#line 236
    return;
  }
#line 237
  if (j >= 0) {
#line 238
    if (j < nsrvs) {
#line 238
      nsrvs = j + 1;
    }
  } else {
#line 241
    j = 0;
  }
  {
#line 244
  tmp___2 = scheme_ok(srv);
  }
#line 244
  if (tmp___2) {
#line 253
    if ((int )srv->uptest == 5) {
      {
#line 254
      s_ts = time((time_t *)((void *)0));
      }
      {
#line 256
      while (1) {
        while_continue: /* CIL Label */ ;
#line 256
        if (! (j < nsrvs)) {
#line 256
          goto while_break;
        }
#line 257
        (srv->atup_a)->elem[j].i_ts = s_ts;
#line 256
        j ++;
      }
      while_break: /* CIL Label */ ;
      }
    } else
#line 260
    if ((int )srv->uptest == 9) {
#line 260
      goto _L;
    } else
#line 260
    if ((int )srv->uptest == 8) {
      {
#line 260
      tmp___1 = is_inaddr_any(& srv->ping_a);
      }
#line 260
      if (tmp___1) {
        _L: /* CIL Label */ 
        {
#line 261
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 261
          if (! (j < nsrvs)) {
#line 261
            goto while_break___0;
          }
          {
#line 262
          at___0 = & (srv->atup_a)->elem[j];
#line 263
          s_ts = time((time_t *)((void *)0));
#line 264
          tmp___0 = uptest(srv, j);
#line 264
          at___0->is_up = (char )tmp___0;
          }
#line 265
          if (signal_interrupt) {
#line 266
            goto while_break___0;
          }
#line 267
          at___0->i_ts = s_ts;
#line 261
          j ++;
        }
        while_break___0: /* CIL Label */ ;
        }
      } else {
#line 260
        goto _L___0;
      }
    } else {
      _L___0: /* CIL Label */ 
      {
#line 273
      s_ts = time((time_t *)((void *)0));
#line 274
      res = uptest(srv, j);
      }
      {
#line 275
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 275
        if (! (j < nsrvs)) {
#line 275
          goto while_break___1;
        }
#line 276
        at___1 = & (srv->atup_a)->elem[j];
#line 277
        at___1->is_up = (char )res;
#line 278
        if (signal_interrupt) {
#line 278
          if ((int )srv->uptest == 8) {
#line 279
            goto __Cont;
          }
        }
#line 280
        at___1->i_ts = s_ts;
        __Cont: /* CIL Label */ 
#line 275
        j ++;
      }
      while_break___1: /* CIL Label */ ;
      }
    }
  } else {
    {
#line 245
    s_ts = time((time_t *)((void *)0));
    }
    {
#line 247
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 247
      if (! (j < nsrvs)) {
#line 247
        goto while_break___2;
      }
#line 248
      at = & (srv->atup_a)->elem[j];
#line 249
      at->is_up = (char)0;
#line 250
      at->i_ts = s_ts;
#line 247
      j ++;
    }
    while_break___2: /* CIL Label */ ;
    }
  }
#line 283
  return;
}
}
#line 289 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/servers.c"
static addr2_array resolv_rootserver_addrs(atup_array a , int port , char edns_query ,
                                           time_t timeout ) 
{ 
  addr2_array retval ;

  {
  {
#line 291
  retval = (addr2_array )((void *)0);
#line 294
  server_data_users ++;
#line 295
  pthread_mutex_unlock(& servers_lock);
#line 297
  retval = dns_rootserver_resolv(a, port, edns_query, timeout);
#line 299
  pthread_mutex_lock(& servers_lock);
  }
#line 300
  if (! (server_data_users > 0)) {
    {
#line 300
    log_message(3, "%s:%d: %s", "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/servers.c",
                300, "server_data_users non-positive before attempt to decrement it");
#line 300
    pdnsd_exit();
    }
  }
#line 301
  server_data_users --;
#line 301
  if (server_data_users == 0) {
    {
#line 301
    pthread_cond_broadcast(& server_data_cond);
    }
  }
#line 303
  return (retval);
}
}
#line 314 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/servers.c"
void *servstat_thread(void *p ) 
{ 
  struct sigaction action ;
  int keep_testing ;
  sigset_t smask ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int i ;
  int n ;
  unsigned int tmp___2 ;
  servparm_t *sp ;
  int j ;
  int m ;
  addr2_array adrs ;
  int l ;
  int one_up ;
  time_t now ;
  time_t tmp___3 ;
  unsigned int tmp___4 ;
  unsigned int tmp___5 ;
  time_t now___0 ;
  time_t tmp___6 ;
  unsigned int tmp___7 ;
  atup_t *at ;
  unsigned int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  unsigned int tmp___11 ;
  struct timeval now___1 ;
  struct timespec timeout ;
  atup_array ata ;
  int tmp___12 ;
  darray tmp___13 ;
  atup_t *at___0 ;
  time_t tmp___14 ;
  unsigned int tmp___15 ;
  int tmp___16 ;
  unsigned int tmp___17 ;
  time_t ts ;
  time_t now___2 ;
  int tmp___18 ;
  struct timeval now___3 ;
  struct timespec timeout___0 ;
  time_t minwait ;
  int i___0 ;
  int n___0 ;
  int retval ;
  unsigned int tmp___19 ;
  servparm_t *sp___0 ;
  int j___0 ;
  int m___0 ;
  unsigned int tmp___20 ;
  time_t ts___0 ;
  time_t wait___0 ;
  int tmp___21 ;
  char const   *tmp___22 ;
  char const   *tmp___23 ;
  char const   *tmp___24 ;

  {
  {
#line 323
  pthread_mutex_lock(& servers_lock);
#line 326
  signal_interrupt = (int volatile   )0;
#line 327
  action.__sigaction_handler.sa_handler = & sigint_handler;
#line 328
  sigemptyset(& action.sa_mask);
#line 329
  action.sa_flags = 0;
#line 330
  tmp___1 = sigaction(1, (struct sigaction  const  */* __restrict  */)(& action),
                      (struct sigaction */* __restrict  */)((void *)0));
  }
#line 330
  if (tmp___1 == 0) {
    {
#line 332
    sigemptyset(& smask);
#line 333
    sigaddset(& smask, 1);
#line 334
    pthread_sigmask(1, (__sigset_t const   */* __restrict  */)(& smask), (__sigset_t */* __restrict  */)((void *)0));
    }
  } else {
    {
#line 337
    tmp = __errno_location();
#line 337
    tmp___0 = strerror(*tmp);
#line 337
    log_message(4, "Cannot install signal handler for server status thread: %s\n",
                tmp___0);
    }
  }
  {
#line 340
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 341
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 343
      keep_testing = 0;
#line 344
      retest_flag = (short)0;
#line 345
      schm[0] = (char )'\000';
#line 346
      tmp___2 = da_nel((darray )servers);
#line 346
      n = (int )tmp___2;
#line 347
      i = 0;
      }
      {
#line 347
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 347
        if (! (i < n)) {
#line 347
          goto while_break___1;
        }
#line 348
        sp = & servers->elem[i];
#line 350
        if ((int )sp->rootserver == 2) {
          {
#line 353
          one_up = 0;
#line 355
          tmp___9 = scheme_ok(sp);
          }
#line 355
          if (tmp___9) {
#line 360
            if ((int )sp->uptest == 8) {
#line 360
              goto _L;
            } else
#line 360
            if ((int )sp->uptest == 9) {
              _L: /* CIL Label */ 
#line 362
              if (sp->interval > 0L) {
                {
#line 363
                tmp___5 = da_nel((darray )sp->atup_a);
#line 363
                one_up = (int )tmp___5;
                }
              } else {
                {
#line 365
                tmp___6 = time((time_t *)((void *)0));
#line 365
                now___0 = tmp___6;
#line 366
                tmp___7 = da_nel((darray )sp->atup_a);
#line 366
                m = (int )tmp___7;
#line 367
                j = 0;
                }
                {
#line 367
                while (1) {
                  while_continue___2: /* CIL Label */ ;
#line 367
                  if (! (j < m)) {
#line 367
                    goto while_break___2;
                  }
#line 368
                  at = & (sp->atup_a)->elem[j];
#line 369
                  if (at->is_up) {
#line 370
                    one_up = 1;
                  } else
#line 369
                  if (at->i_ts == 0L) {
#line 370
                    one_up = 1;
                  }
#line 371
                  at->i_ts = now___0;
#line 367
                  j ++;
                }
                while_break___2: /* CIL Label */ ;
                }
              }
            } else {
              {
#line 376
              retest(i, -1);
#line 378
              tmp___8 = da_nel((darray )sp->atup_a);
#line 378
              m = (int )tmp___8;
#line 379
              j = 0;
              }
              {
#line 379
              while (1) {
                while_continue___3: /* CIL Label */ ;
#line 379
                if (! (j < m)) {
#line 379
                  goto while_break___3;
                }
#line 380
                if ((sp->atup_a)->elem[j].is_up) {
#line 381
                  one_up = 1;
#line 382
                  goto while_break___3;
                }
#line 379
                j ++;
              }
              while_break___3: /* CIL Label */ ;
              }
            }
          } else {
            {
#line 356
            tmp___3 = time((time_t *)((void *)0));
#line 356
            now = tmp___3;
#line 357
            tmp___4 = da_nel((darray )sp->atup_a);
#line 357
            m = (int )tmp___4;
#line 358
            j = 0;
            }
            {
#line 358
            while (1) {
              while_continue___4: /* CIL Label */ ;
#line 358
              if (! (j < m)) {
#line 358
                goto while_break___4;
              }
#line 359
              (sp->atup_a)->elem[j].i_ts = now;
#line 358
              j ++;
            }
            while_break___4: /* CIL Label */ ;
            }
          }
#line 387
          if (! one_up) {
            {
#line 388
            tmp___10 = needs_intermittent_testing(sp);
            }
#line 388
            if (tmp___10) {
#line 388
              keep_testing = 1;
            }
#line 389
            goto __Cont;
          }
#line 392
          if (debug_p) {
            {
#line 392
            debug_msg(0, "Attempting to discover root servers for server section #%d.\n",
                      i);
            }
          }
          {
#line 393
          adrs = resolv_rootserver_addrs(sp->atup_a, (int )sp->port, sp->edns_query,
                                         sp->timeout);
#line 394
          tmp___11 = da_nel((darray )adrs);
#line 394
          l = (int )tmp___11;
          }
#line 395
          if (l > 0) {
#line 399
            if (debug_p) {
              {
#line 399
              debug_msg(0, "Filling server section #%d with %d root server addresses.\n",
                        i, l);
              }
            }
            {
#line 400
            gettimeofday((struct timeval */* __restrict  */)(& now___1), (__timezone_ptr_t )((void *)0));
#line 401
            timeout.tv_sec = now___1.tv_sec + 60L;
#line 402
            timeout.tv_nsec = now___1.tv_usec * 1000L;
            }
            {
#line 403
            while (1) {
              while_continue___5: /* CIL Label */ ;
#line 403
              if (! (server_data_users > 0)) {
#line 403
                goto while_break___5;
              }
              {
#line 404
              tmp___12 = pthread_cond_timedwait((pthread_cond_t */* __restrict  */)(& server_data_cond),
                                                (pthread_mutex_t */* __restrict  */)(& servers_lock),
                                                (struct timespec  const  */* __restrict  */)(& timeout));
              }
#line 404
              if (tmp___12 == 110) {
#line 405
                if (debug_p) {
                  {
#line 405
                  debug_msg(0, "Timed out while waiting for exclusive access to server data to set root server addresses of server section #%d\n",
                            i);
                  }
                }
                {
#line 407
                free((void *)adrs);
#line 408
                keep_testing = 1;
                }
#line 409
                goto while_continue___5;
              }
            }
            while_break___5: /* CIL Label */ ;
            }
            {
#line 412
            tmp___13 = da_resize((darray )((void *)0), (size_t )(((atup_array )0)->elem),
                                 sizeof(((atup_array )0)->elem[0]), (size_t )l, (void (*)(void * ))((void *)0));
#line 412
            ata = (atup_array )tmp___13;
            }
#line 413
            if (! ata) {
              {
#line 414
              log_message(4, "Out of memory in servstat_thread() while discovering root servers.");
#line 415
              free((void *)adrs);
#line 416
              keep_testing = 1;
              }
#line 417
              goto __Cont;
            }
#line 419
            j = 0;
            {
#line 419
            while (1) {
              while_continue___6: /* CIL Label */ ;
#line 419
              if (! (j < l)) {
#line 419
                goto while_break___6;
              }
#line 420
              at___0 = & ata->elem[j];
#line 421
              at___0->a = adrs->elem[j];
#line 422
              at___0->is_up = sp->preset;
#line 423
              if (sp->interval < 0L) {
                {
#line 423
                tmp___14 = time((time_t *)((void *)0));
#line 423
                at___0->i_ts = tmp___14;
                }
              } else {
#line 423
                at___0->i_ts = (time_t )0;
              }
#line 419
              j ++;
            }
            while_break___6: /* CIL Label */ ;
            }
            {
#line 425
            free((void *)sp->atup_a);
#line 426
            sp->atup_a = ata;
#line 427
            free((void *)adrs);
#line 429
            sp->rootserver = (char)1;
            }
          } else {
#line 432
            if (debug_p) {
              {
#line 432
              debug_msg(0, "Failed to discover root servers in servstat_thread() (server section #%d).\n",
                        i);
              }
            }
#line 433
            if (adrs) {
              {
#line 433
              free((void *)adrs);
              }
            }
            {
#line 434
            tmp___15 = da_nel((darray )sp->atup_a);
            }
#line 434
            if (tmp___15) {
#line 434
              keep_testing = 1;
            }
#line 435
            goto __Cont;
          }
        }
        {
#line 439
        tmp___16 = needs_testing(sp);
        }
#line 439
        if (tmp___16) {
#line 439
          keep_testing = 1;
        }
        {
#line 440
        tmp___17 = da_nel((darray )sp->atup_a);
#line 440
        m = (int )tmp___17;
#line 441
        j = 0;
        }
        {
#line 441
        while (1) {
          while_continue___7: /* CIL Label */ ;
#line 441
          if (! (j < m)) {
#line 441
            goto while_break___7;
          }
#line 442
          if ((sp->atup_a)->elem[j].i_ts) {
#line 443
            goto individual_tests;
          }
#line 441
          j ++;
        }
        while_break___7: /* CIL Label */ ;
        }
#line 445
        if (! signal_interrupt) {
          {
#line 445
          retest(i, -1);
          }
        }
#line 446
        goto __Cont;
        individual_tests: 
#line 449
        j = 0;
        {
#line 449
        while (1) {
          while_continue___8: /* CIL Label */ ;
#line 449
          if (! signal_interrupt) {
#line 449
            if (! (j < m)) {
#line 449
              goto while_break___8;
            }
          } else {
#line 449
            goto while_break___8;
          }
#line 450
          ts = (sp->atup_a)->elem[j].i_ts;
#line 452
          if (ts == 0L) {
            {
#line 457
            retest(i, j);
            }
          } else {
            {
#line 452
            tmp___18 = needs_intermittent_testing(sp);
            }
#line 452
            if (tmp___18) {
              {
#line 452
              now___2 = time((time_t *)((void *)0));
              }
#line 452
              if (now___2 - ts > sp->interval) {
                {
#line 457
                retest(i, j);
                }
              } else
#line 452
              if (ts > now___2) {
                {
#line 457
                retest(i, j);
                }
              }
            }
          }
#line 449
          j ++;
        }
        while_break___8: /* CIL Label */ ;
        }
        __Cont: /* CIL Label */ 
#line 347
        i ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 341
      if (! signal_interrupt) {
#line 341
        if (! retest_flag) {
#line 341
          goto while_break___0;
        }
      } else {
#line 341
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 463
    signal_interrupt = (int volatile   )0;
#line 466
    if (! keep_testing) {
#line 466
      goto while_break;
    }
    {
#line 474
    gettimeofday((struct timeval */* __restrict  */)(& now___3), (__timezone_ptr_t )((void *)0));
#line 475
    minwait = (time_t )3600;
#line 476
    tmp___19 = da_nel((darray )servers);
#line 476
    n___0 = (int )tmp___19;
#line 477
    i___0 = 0;
    }
    {
#line 477
    while (1) {
      while_continue___9: /* CIL Label */ ;
#line 477
      if (! (i___0 < n___0)) {
#line 477
        goto while_break___9;
      }
      {
#line 478
      sp___0 = & servers->elem[i___0];
#line 479
      tmp___20 = da_nel((darray )sp___0->atup_a);
#line 479
      m___0 = (int )tmp___20;
#line 480
      j___0 = 0;
      }
      {
#line 480
      while (1) {
        while_continue___10: /* CIL Label */ ;
#line 480
        if (! (j___0 < m___0)) {
#line 480
          goto while_break___10;
        }
#line 481
        ts___0 = (sp___0->atup_a)->elem[j___0].i_ts;
#line 482
        if (ts___0 == 0L) {
#line 484
          if (minwait > 0L) {
#line 484
            minwait = (time_t )0;
          }
        } else {
          {
#line 486
          tmp___21 = needs_intermittent_testing(sp___0);
          }
#line 486
          if (tmp___21) {
#line 487
            wait___0 = (ts___0 + sp___0->interval) - now___3.tv_sec;
#line 488
            if (wait___0 < minwait) {
#line 488
              minwait = wait___0;
            }
          }
        }
#line 480
        j___0 ++;
      }
      while_break___10: /* CIL Label */ ;
      }
#line 477
      i___0 ++;
    }
    while_break___9: /* CIL Label */ ;
    }
#line 492
    timeout___0.tv_sec = now___3.tv_sec;
#line 493
    if (minwait > 0L) {
#line 494
      timeout___0.tv_sec += minwait;
    }
#line 495
    timeout___0.tv_nsec = now___3.tv_usec * 1000L + 500000000L;
#line 496
    if (timeout___0.tv_nsec >= 1000000000L) {
#line 497
      timeout___0.tv_nsec -= 1000000000L;
#line 498
      (timeout___0.tv_sec) ++;
    }
    {
#line 504
    retval = pthread_cond_timedwait((pthread_cond_t */* __restrict  */)(& server_test_cond),
                                    (pthread_mutex_t */* __restrict  */)(& servers_lock),
                                    (struct timespec  const  */* __restrict  */)(& timeout___0));
    }
#line 505
    if (debug_p) {
#line 505
      if (retval == 0) {
#line 505
        tmp___24 = "test condition";
      } else {
#line 505
        if (retval == 110) {
#line 505
          tmp___23 = "timer";
        } else {
#line 505
          if (retval == 4) {
#line 505
            tmp___22 = "interrupt";
          } else {
#line 505
            tmp___22 = "error";
          }
#line 505
          tmp___23 = tmp___22;
        }
#line 505
        tmp___24 = tmp___23;
      }
      {
#line 505
      debug_msg(0, "Server status thread woke up (%s signal).\n", tmp___24);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 511
  servstat_thrid = main_thrid;
#line 512
  pthread_mutex_unlock(& servers_lock);
  }
#line 513
  if (debug_p) {
    {
#line 513
    debug_msg(0, "Server status thread exiting.\n");
    }
  }
#line 514
  return ((void *)0);
}
}
#line 520 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/servers.c"
int start_servstat_thread(void) 
{ 
  pthread_t stt ;
  int rv ;
  int tmp ;
  char *tmp___0 ;

  {
  {
#line 524
  tmp = pthread_create((pthread_t */* __restrict  */)(& stt), (pthread_attr_t const   */* __restrict  */)(& attr_detached),
                       & servstat_thread, (void */* __restrict  */)((void *)0));
#line 524
  rv = tmp;
  }
#line 525
  if (rv) {
    {
#line 526
    tmp___0 = strerror(rv);
#line 526
    log_message(4, "Failed to start server status thread: %s", tmp___0);
    }
  } else {
#line 528
    servstat_thrid = stt;
#line 529
    if (2 <= (int )global.verbosity) {
      {
#line 529
      log_message(6, "Server status thread started.");
      }
    }
  }
#line 531
  return (rv);
}
}
#line 540 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/servers.c"
void sched_server_test(pdnsd_a *sa , int nadr , int up ) 
{ 
  int k ;
  int signal_test ;
  pdnsd_a *sak ;
  int i ;
  int n ;
  unsigned int tmp ;
  servparm_t *sp ;
  int j ;
  int m ;
  unsigned int tmp___0 ;
  atup_t *at ;
  char _debugsockabuf[16] ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  int tmp___3 ;

  {
  {
#line 544
  pthread_mutex_lock(& servers_lock);
#line 546
  signal_test = 0;
#line 549
  k = 0;
  }
  {
#line 549
  while (1) {
    while_continue: /* CIL Label */ ;
#line 549
    if (! (k < nadr)) {
#line 549
      goto while_break;
    }
    {
#line 550
    sak = sa + k;
#line 551
    tmp = da_nel((darray )servers);
#line 551
    n = (int )tmp;
#line 552
    i = 0;
    }
    {
#line 552
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 552
      if (! (i < n)) {
#line 552
        goto while_break___0;
      }
      {
#line 553
      sp = & servers->elem[i];
#line 554
      tmp___0 = da_nel((darray )sp->atup_a);
#line 554
      m = (int )tmp___0;
#line 555
      j = 0;
      }
      {
#line 555
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 555
        if (! (j < m)) {
#line 555
          goto while_break___1;
        }
        {
#line 556
        at = & (sp->atup_a)->elem[j];
#line 557
        tmp___3 = equiv_inaddr2(sak, & at->a);
        }
#line 557
        if (tmp___3) {
#line 558
          if (up >= 0) {
            {
#line 559
            at->is_up = (char )up;
#line 560
            at->i_ts = time((time_t *)((void *)0));
            }
#line 561
            if (debug_p) {
#line 561
              if (up) {
#line 561
                tmp___1 = "up";
              } else {
#line 561
                tmp___1 = "down";
              }
              {
#line 561
              tmp___2 = pdnsd_a2str(sak, _debugsockabuf, 16);
#line 561
              debug_msg(0, "Marked server %s %s.\n", tmp___2, tmp___1);
              }
            }
          } else
#line 563
          if (at->i_ts) {
#line 569
            at->i_ts = (time_t )0;
#line 570
            signal_test = 1;
          }
        }
#line 555
        j ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 552
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 549
    k ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 576
  if (signal_test) {
    {
#line 576
    pthread_cond_signal(& server_test_cond);
    }
  }
  {
#line 578
  pthread_mutex_unlock(& servers_lock);
  }
#line 579
  return;
}
}
#line 590 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/servers.c"
int mark_servers(int i , char *label , int up ) 
{ 
  int retval ;
  int n ;
  int signal_test ;
  unsigned int tmp ;
  servparm_t *sp ;
  int j ;
  int m ;
  unsigned int tmp___0 ;
  atup_t *at ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 592
  retval = 0;
#line 594
  pthread_mutex_lock(& servers_lock);
#line 596
  signal_test = 0;
#line 597
  tmp = da_nel((darray )servers);
#line 597
  n = (int )tmp;
  }
#line 598
  if (i >= 0) {
#line 600
    if (i < n) {
#line 600
      n = i + 1;
    }
  } else {
#line 603
    i = 0;
  }
  {
#line 605
  while (1) {
    while_continue: /* CIL Label */ ;
#line 605
    if (! (i < n)) {
#line 605
      goto while_break;
    }
#line 606
    sp = & servers->elem[i];
#line 607
    if (! label) {
#line 607
      goto _L;
    } else
#line 607
    if (sp->label) {
      {
#line 607
      tmp___1 = strcmp((char const   *)sp->label, (char const   *)label);
      }
#line 607
      if (! tmp___1) {
        _L: /* CIL Label */ 
        {
#line 608
        tmp___0 = da_nel((darray )sp->atup_a);
#line 608
        m = (int )tmp___0;
        }
#line 611
        if (m) {
#line 611
          if ((int )sp->rootserver > 1) {
#line 611
            if (up > 0) {
#line 611
              signal_test = 1;
            }
          }
        }
#line 613
        j = 0;
        {
#line 613
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 613
          if (! (j < m)) {
#line 613
            goto while_break___0;
          }
#line 614
          at = & (sp->atup_a)->elem[j];
#line 615
          if (up >= 0) {
            {
#line 616
            at->is_up = (char )up;
#line 617
            at->i_ts = time((time_t *)((void *)0));
            }
          } else
#line 619
          if (at->i_ts) {
#line 625
            at->i_ts = (time_t )0;
#line 626
            signal_test = 1;
          }
#line 613
          j ++;
        }
        while_break___0: /* CIL Label */ ;
        }
      }
    }
#line 605
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 631
  if (signal_test) {
    {
#line 632
    tmp___2 = pthread_equal(servstat_thrid, main_thrid);
    }
#line 632
    if (tmp___2) {
      {
#line 633
      retval = start_servstat_thread();
      }
    } else {
      {
#line 635
      retest_flag = (short)1;
#line 636
      retval = pthread_cond_signal(& server_test_cond);
      }
    }
  }
  {
#line 640
  pthread_mutex_unlock(& servers_lock);
  }
#line 641
  return (retval);
}
}
#line 647 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/servers.c"
void test_onquery(void) 
{ 
  int i ;
  int n ;
  int signal_test ;
  unsigned int tmp ;
  servparm_t *sp ;
  int j ;
  int m ;
  unsigned int tmp___0 ;
  int rv ;
  char *tmp___1 ;
  int tmp___2 ;

  {
  {
#line 651
  pthread_mutex_lock(& servers_lock);
#line 652
  schm[0] = (char )'\000';
#line 653
  signal_test = 0;
#line 654
  tmp = da_nel((darray )servers);
#line 654
  n = (int )tmp;
#line 655
  i = 0;
  }
  {
#line 655
  while (1) {
    while_continue: /* CIL Label */ ;
#line 655
    if (! (i < n)) {
#line 655
      goto while_break;
    }
#line 656
    sp = & servers->elem[i];
#line 657
    if (sp->interval == -1L) {
#line 658
      if ((int )sp->rootserver <= 1) {
        {
#line 659
        retest(i, -1);
        }
      } else {
        {
#line 662
        tmp___0 = da_nel((darray )sp->atup_a);
#line 662
        m = (int )tmp___0;
#line 663
        j = 0;
        }
        {
#line 663
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 663
          if (! (j < m)) {
#line 663
            goto while_break___0;
          }
#line 664
          (sp->atup_a)->elem[j].i_ts = (time_t )0;
#line 663
          j ++;
        }
        while_break___0: /* CIL Label */ ;
        }
#line 665
        signal_test = 1;
      }
    }
#line 655
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 670
  if (signal_test) {
    {
#line 672
    tmp___2 = pthread_equal(servstat_thrid, main_thrid);
    }
#line 672
    if (tmp___2) {
      {
#line 673
      start_servstat_thread();
      }
    } else {
      {
#line 675
      retest_flag = (short)1;
#line 676
      rv = pthread_cond_signal(& server_test_cond);
      }
#line 676
      if (rv) {
#line 677
        if (debug_p) {
          {
#line 677
          tmp___1 = strerror(rv);
#line 677
          debug_msg(0, "test_onquery(): couldn\'t signal server status thread: %s\n",
                    tmp___1);
          }
        }
      }
    }
  }
  {
#line 682
  pthread_mutex_unlock(& servers_lock);
  }
#line 683
  return;
}
}
#line 686 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/servers.c"
void lock_server_data(void) 
{ 


  {
  {
#line 688
  pthread_mutex_lock(& servers_lock);
#line 689
  server_data_users ++;
#line 690
  pthread_mutex_unlock(& servers_lock);
  }
#line 691
  return;
}
}
#line 693 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/servers.c"
void unlock_server_data(void) 
{ 


  {
  {
#line 695
  pthread_mutex_lock(& servers_lock);
  }
#line 696
  if (! (server_data_users > 0)) {
    {
#line 696
    log_message(3, "%s:%d: %s", "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/servers.c",
                696, "server_data_users non-positive before attempt to decrement it");
#line 696
    pdnsd_exit();
    }
  }
#line 697
  server_data_users --;
#line 697
  if (server_data_users == 0) {
    {
#line 697
    pthread_cond_broadcast(& server_data_cond);
    }
  }
  {
#line 698
  pthread_mutex_unlock(& servers_lock);
  }
#line 699
  return;
}
}
#line 704 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/servers.c"
int exclusive_lock_server_data(int tm ) 
{ 
  struct timeval now ;
  struct timespec timeout ;
  int err ;
  char *tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 709
  pthread_mutex_lock(& servers_lock);
  }
#line 710
  if (server_status_ping > 0) {
    {
#line 710
    tmp___0 = pthread_equal(servstat_thrid, main_thrid);
    }
#line 710
    if (! tmp___0) {
#line 713
      if (debug_p) {
        {
#line 713
        debug_msg(0, "Sending server status thread an interrupt signal.\n");
        }
      }
      {
#line 714
      err = pthread_kill(servstat_thrid, 1);
      }
#line 714
      if (err) {
#line 715
        if (debug_p) {
          {
#line 715
          tmp = strerror(err);
#line 715
          debug_msg(0, "pthread_kill failed: %s\n", tmp);
          }
        }
      }
    }
  }
  {
#line 718
  gettimeofday((struct timeval */* __restrict  */)(& now), (__timezone_ptr_t )((void *)0));
#line 719
  timeout.tv_sec = now.tv_sec + (__time_t )tm;
#line 720
  timeout.tv_nsec = now.tv_usec * 1000L;
  }
  {
#line 721
  while (1) {
    while_continue: /* CIL Label */ ;
#line 721
    if (! (server_data_users > 0)) {
#line 721
      goto while_break;
    }
    {
#line 722
    tmp___1 = pthread_cond_timedwait((pthread_cond_t */* __restrict  */)(& server_data_cond),
                                     (pthread_mutex_t */* __restrict  */)(& servers_lock),
                                     (struct timespec  const  */* __restrict  */)(& timeout));
    }
#line 722
    if (tmp___1 == 110) {
      {
#line 723
      pthread_mutex_unlock(& servers_lock);
      }
#line 724
      return (0);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 727
  return (1);
}
}
#line 733 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/servers.c"
void exclusive_unlock_server_data(int retest___0 ) 
{ 
  int tmp ;

  {
#line 735
  if (retest___0) {
    {
#line 736
    tmp = pthread_equal(servstat_thrid, main_thrid);
    }
#line 736
    if (tmp) {
      {
#line 737
      start_servstat_thread();
      }
    } else {
      {
#line 739
      pthread_cond_signal(& server_test_cond);
      }
    }
  }
  {
#line 741
  pthread_mutex_unlock(& servers_lock);
  }
#line 742
  return;
}
}
#line 753 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/servers.c"
int change_servers(int i , addr_array ar , int up ) 
{ 
  int retval ;
  int j ;
  int change ;
  int signal_test ;
  int n ;
  servparm_t *sp ;
  unsigned int tmp ;
  int j___0 ;
  int tmp___0 ;
  unsigned int tmp___1 ;
  struct timeval now ;
  struct timespec timeout ;
  atup_array ata ;
  int err ;
  char *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  darray tmp___5 ;
  atup_t *at ;
  int tmp___6 ;

  {
  {
#line 755
  retval = 0;
#line 759
  pthread_mutex_lock(& servers_lock);
#line 761
  signal_test = 0;
#line 762
  change = 0;
#line 763
  tmp = da_nel((darray )ar);
#line 763
  n = (int )tmp;
#line 764
  sp = & servers->elem[i];
#line 765
  tmp___1 = da_nel((darray )sp->atup_a);
  }
#line 765
  if ((unsigned int )n != tmp___1) {
#line 766
    change = 1;
  } else
#line 765
  if ((int )sp->rootserver > 1) {
#line 766
    change = 1;
  } else {
#line 769
    j___0 = 0;
    {
#line 769
    while (1) {
      while_continue: /* CIL Label */ ;
#line 769
      if (! (j___0 < n)) {
#line 769
        goto while_break;
      }
      {
#line 770
      tmp___0 = equiv_inaddr2(& ar->elem[j___0], & (sp->atup_a)->elem[j___0].a);
      }
#line 770
      if (! tmp___0) {
#line 771
        change = 1;
#line 772
        goto while_break;
      }
#line 769
      j___0 ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 775
  if (change) {
#line 781
    if (server_status_ping > 0) {
      {
#line 781
      tmp___3 = pthread_equal(servstat_thrid, main_thrid);
      }
#line 781
      if (! tmp___3) {
#line 784
        if (debug_p) {
          {
#line 784
          debug_msg(0, "Sending server status thread an interrupt signal.\n");
          }
        }
        {
#line 785
        err = pthread_kill(servstat_thrid, 1);
        }
#line 785
        if (err) {
#line 786
          if (debug_p) {
            {
#line 786
            tmp___2 = strerror(err);
#line 786
            debug_msg(0, "pthread_kill failed: %s\n", tmp___2);
            }
          }
        }
      }
    }
#line 790
    if (debug_p) {
      {
#line 790
      debug_msg(0, "Changing IPs of server section #%d\n", i);
      }
    }
    {
#line 791
    gettimeofday((struct timeval */* __restrict  */)(& now), (__timezone_ptr_t )((void *)0));
#line 792
    timeout.tv_sec = now.tv_sec + 60L;
#line 793
    timeout.tv_nsec = now.tv_usec * 1000L;
    }
    {
#line 794
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 794
      if (! (server_data_users > 0)) {
#line 794
        goto while_break___0;
      }
      {
#line 795
      tmp___4 = pthread_cond_timedwait((pthread_cond_t */* __restrict  */)(& server_data_cond),
                                       (pthread_mutex_t */* __restrict  */)(& servers_lock),
                                       (struct timespec  const  */* __restrict  */)(& timeout));
      }
#line 795
      if (tmp___4 == 110) {
#line 796
        retval = 110;
#line 797
        goto unlock_mutex;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 801
    tmp___5 = da_resize((darray )((void *)0), (size_t )(((atup_array )0)->elem), sizeof(((atup_array )0)->elem[0]),
                        (size_t )n, (void (*)(void * ))((void *)0));
#line 801
    ata = (atup_array )tmp___5;
    }
#line 802
    if (! ata) {
      {
#line 803
      log_message(4, "Out of memory in change_servers().");
#line 804
      retval = 12;
      }
#line 805
      goto unlock_mutex;
    }
    {
#line 807
    free((void *)sp->atup_a);
#line 808
    sp->atup_a = ata;
    }
#line 811
    if ((int )sp->rootserver > 1) {
#line 811
      sp->rootserver = (char)1;
    }
  }
#line 814
  j = 0;
  {
#line 814
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 814
    if (! (j < n)) {
#line 814
      goto while_break___1;
    }
#line 815
    at = & (sp->atup_a)->elem[j];
#line 816
    if (change) {
#line 817
      at->a.ipv4 = ar->elem[j].ipv4;
#line 818
      at->is_up = sp->preset;
    }
#line 820
    if (up >= 0) {
      {
#line 821
      at->is_up = (char )up;
#line 822
      at->i_ts = time((time_t *)((void *)0));
      }
    } else
#line 824
    if (change) {
#line 830
      at->i_ts = (time_t )0;
#line 831
      signal_test = 1;
    } else
#line 824
    if (at->i_ts) {
#line 830
      at->i_ts = (time_t )0;
#line 831
      signal_test = 1;
    }
#line 814
    j ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 835
  if (signal_test) {
    {
#line 836
    tmp___6 = pthread_equal(servstat_thrid, main_thrid);
    }
#line 836
    if (tmp___6) {
      {
#line 837
      retval = start_servstat_thread();
      }
    } else {
      {
#line 839
      retest_flag = (short)1;
#line 840
      retval = pthread_cond_signal(& server_test_cond);
      }
    }
  }
  unlock_mutex: 
  {
#line 845
  pthread_mutex_unlock(& servers_lock);
  }
#line 846
  return (retval);
}
}
#line 853 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/servers.c"
static void sigint_handler(int signum ) 
{ 


  {
#line 855
  signal_interrupt = (int volatile   )1;
#line 856
  return;
}
}
#line 61 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/servers.h"
__inline static int ( __attribute__((__always_inline__)) is_interrupted_servstat_thread)(void) ;
#line 69 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/icmp.c"
static unsigned long volatile   icmp_errs___3  =    (unsigned long volatile   )0;
#line 136 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/icmp.c"
static int icmp4_errcmp___3(char *packet , int plen , struct in_addr *to , char *errmsg ,
                            int elen , int errtype ) 
{ 
  struct iphdr iph ;
  struct icmphdr icmph ;
  struct iphdr eiph ;
  char *data ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 144
  if ((unsigned long )elen < sizeof(struct iphdr )) {
#line 145
    return (0);
  }
  {
#line 146
  memcpy((void */* __restrict  */)(& iph), (void const   */* __restrict  */)errmsg,
         sizeof(iph));
  }
#line 147
  if ((int )iph.protocol != 1) {
#line 148
    return (0);
  } else
#line 147
  if ((unsigned long )elen < (unsigned long )(iph.ihl * 4U + 8U) + sizeof(eiph)) {
#line 148
    return (0);
  }
#line 149
  if (! (sizeof(icmph) >= 8UL)) {
    {
#line 149
    log_message(3, "%s:%d: %s", "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/icmp.c",
                149, "icmp4_errcmp: ICMP_BASEHDR_LEN botched");
#line 149
    pdnsd_exit();
    }
  }
  {
#line 150
  memcpy((void */* __restrict  */)(& icmph), (void const   */* __restrict  */)(errmsg + iph.ihl * 4U),
         (size_t )8);
#line 151
  memcpy((void */* __restrict  */)(& eiph), (void const   */* __restrict  */)((errmsg + iph.ihl * 4U) + 8),
         sizeof(eiph));
  }
#line 152
  if ((unsigned int )elen < ((iph.ihl * 4U + 8U) + eiph.ihl * 4U) + 8U) {
#line 153
    return (0);
  }
#line 154
  data = ((errmsg + iph.ihl * 4U) + 8) + eiph.ihl * 4U;
#line 155
  if ((int )icmph.type == errtype) {
    {
#line 155
    tmp = memcmp((void const   *)(& to->s_addr), (void const   *)(& eiph.daddr), sizeof(to->s_addr));
    }
#line 155
    if (tmp == 0) {
#line 155
      if (plen < 8) {
#line 155
        tmp___0 = plen;
      } else {
#line 155
        tmp___0 = 8;
      }
      {
#line 155
      tmp___1 = memcmp((void const   *)data, (void const   *)packet, (size_t )tmp___0);
      }
#line 155
      if (tmp___1 == 0) {
#line 155
        tmp___2 = 1;
      } else {
#line 155
        tmp___2 = 0;
      }
    } else {
#line 155
      tmp___2 = 0;
    }
  } else {
#line 155
    tmp___2 = 0;
  }
#line 155
  return (tmp___2);
}
}
#line 160 "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/icmp.c"
static int ping4___3(struct in_addr addr , int timeout , int rep ) 
{ 
  int i ;
  int isock ;
  struct icmp_filter f ;
  unsigned short id ;
  unsigned short tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  struct sockaddr_in from ;
  struct sockaddr_in to ;
  struct icmphdr icmpd ;
  unsigned long sum ;
  uint16_t *ptr ;
  long tm ;
  long tpassed ;
  int j ;
  uint16_t *tmp___3 ;
  int *tmp___4 ;
  char *tmp___5 ;
  ssize_t tmp___6 ;
  int psres ;
  struct pollfd pfd ;
  int tmp___7 ;
  long tmp___8 ;
  int *tmp___9 ;
  char *tmp___10 ;
  int *tmp___11 ;
  int tmp___12 ;
  char buf[1024] ;
  socklen_t sl ;
  int len ;
  struct iphdr iph ;
  struct icmphdr icmpp ;
  uint16_t tmp___13 ;
  time_t tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  uint16_t tmp___17 ;
  uint16_t tmp___18 ;
  ssize_t tmp___19 ;
  time_t tmp___20 ;

  {
  {
#line 167
  tmp = get_rand16();
#line 167
  id = tmp;
#line 169
  isock = (int )ping_isocket;
#line 178
  f.data = 4294965238U;
#line 179
  tmp___2 = setsockopt(isock, 255, 1, (void const   *)(& f), (socklen_t )sizeof(f));
  }
#line 179
  if (tmp___2 == -1) {
#line 180
    icmp_errs___3 += (unsigned long volatile   )1;
#line 180
    if (icmp_errs___3 <= (unsigned long volatile   )10) {
      {
#line 181
      tmp___0 = __errno_location();
#line 181
      tmp___1 = strerror(*tmp___0);
#line 181
      log_message(4, "icmp ping: setsockopt() failed: %s", tmp___1);
      }
    }
#line 183
    return (-1);
  }
#line 187
  i = 0;
  {
#line 187
  while (1) {
    while_continue: /* CIL Label */ ;
#line 187
    if (! (i < rep)) {
#line 187
      goto while_break;
    }
    {
#line 195
    icmpd.type = (__u8 )8;
#line 196
    icmpd.code = (__u8 )0;
#line 197
    icmpd.checksum = (__sum16 )0;
#line 198
    icmpd.un.echo.id = htons(id);
#line 199
    icmpd.un.echo.sequence = htons((uint16_t )i);
#line 203
    ptr = (uint16_t *)(& icmpd);
#line 204
    sum = 0UL;
#line 206
    j = 0;
    }
    {
#line 206
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 206
      if (! (j < 4)) {
#line 206
        goto while_break___0;
      }
#line 207
      tmp___3 = ptr;
#line 207
      ptr ++;
#line 207
      sum += (unsigned long )*tmp___3;
#line 206
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 209
    sum = (sum >> 16) + (sum & 65535UL);
#line 210
    sum += sum >> 16;
#line 211
    icmpd.checksum = (__sum16 )(~ sum);
#line 213
    memset((void *)(& to), 0, sizeof(to));
#line 214
    to.sin_family = (sa_family_t )2;
#line 215
    to.sin_port = (in_port_t )0;
#line 216
    to.sin_addr = addr;
#line 218
    tmp___6 = sendto(isock, (void const   *)(& icmpd), (size_t )8, 0, (struct sockaddr  const  */* __restrict  */)((struct sockaddr *)(& to)),
                     (socklen_t )sizeof(to));
    }
#line 218
    if (tmp___6 == -1L) {
#line 219
      icmp_errs___3 += (unsigned long volatile   )1;
#line 219
      if (icmp_errs___3 <= (unsigned long volatile   )10) {
        {
#line 220
        tmp___4 = __errno_location();
#line 220
        tmp___5 = strerror(*tmp___4);
#line 220
        log_message(4, "icmp ping: sendto() failed: %s.", tmp___5);
        }
      }
#line 222
      return (-1);
    }
    {
#line 225
    tm = time((time_t *)((void *)0));
#line 225
    tpassed = 0L;
    }
    {
#line 226
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 248
      pfd.fd = isock;
#line 249
      pfd.events = (short)1;
#line 254
      tmp___7 = is_interrupted_servstat_thread();
      }
#line 254
      if (tmp___7) {
#line 255
        if (debug_p) {
          {
#line 255
          debug_msg(0, "server status thread interrupted.\n");
          }
        }
#line 256
        return (-1);
      }
#line 258
      if ((long )timeout > tpassed) {
#line 258
        tmp___8 = ((long )timeout - tpassed) * 1000L;
      } else {
#line 258
        tmp___8 = 0L;
      }
      {
#line 258
      psres = poll(& pfd, (nfds_t )1, (int )tmp___8);
      }
#line 261
      if (psres < 0) {
        {
#line 262
        tmp___11 = __errno_location();
        }
#line 262
        if (*tmp___11 == 4) {
          {
#line 262
          tmp___12 = is_interrupted_servstat_thread();
          }
#line 262
          if (tmp___12) {
#line 263
            if (debug_p) {
              {
#line 263
              debug_msg(0, "poll/select interrupted in server status thread.\n");
              }
            }
          } else {
#line 262
            goto _L;
          }
        } else {
          _L: /* CIL Label */ 
#line 265
          icmp_errs___3 += (unsigned long volatile   )1;
#line 265
          if (icmp_errs___3 <= (unsigned long volatile   )10) {
            {
#line 266
            tmp___9 = __errno_location();
#line 266
            tmp___10 = strerror(*tmp___9);
#line 266
            log_message(4, "poll/select failed: %s", tmp___10);
            }
          }
        }
#line 268
        return (-1);
      }
#line 270
      if (psres == 0) {
#line 271
        goto while_break___1;
      }
#line 276
      if ((int )pfd.revents & 9) {
        {
#line 280
        sl = (socklen_t )sizeof(from);
#line 283
        tmp___19 = recvfrom(isock, (void */* __restrict  */)(& buf), sizeof(buf),
                            0, (struct sockaddr */* __restrict  */)((struct sockaddr *)(& from)),
                            (socklen_t */* __restrict  */)(& sl));
#line 283
        len = (int )tmp___19;
        }
#line 283
        if (len != -1) {
#line 284
          if ((unsigned long )len > sizeof(struct iphdr )) {
            {
#line 287
            memcpy((void */* __restrict  */)(& iph), (void const   */* __restrict  */)(buf),
                   sizeof(iph));
            }
#line 288
            if ((unsigned int )len - iph.ihl * 4U >= 8U) {
              {
#line 291
              memcpy((void */* __restrict  */)(& icmpp), (void const   */* __restrict  */)((uint32_t *)(buf) + iph.ihl),
                     sizeof(icmpp));
              }
#line 292
              if (iph.saddr == addr.s_addr) {
#line 292
                if ((int )icmpp.type == 0) {
                  {
#line 292
                  tmp___17 = ntohs(icmpp.un.echo.id);
                  }
#line 292
                  if ((int )tmp___17 == (int )id) {
                    {
#line 292
                    tmp___18 = ntohs(icmpp.un.echo.sequence);
                    }
#line 292
                    if ((int )tmp___18 <= i) {
                      {
#line 294
                      tmp___13 = ntohs(icmpp.un.echo.sequence);
#line 294
                      tmp___14 = time((time_t *)((void *)0));
                      }
#line 294
                      return ((int )((time_t )((i - (int )tmp___13) * timeout) + (tmp___14 - tm)));
                    } else {
#line 292
                      goto _L___2;
                    }
                  } else {
#line 292
                    goto _L___2;
                  }
                } else {
#line 292
                  goto _L___2;
                }
              } else {
                _L___2: /* CIL Label */ 
                {
#line 297
                tmp___15 = icmp4_errcmp___3((char *)(& icmpd), 8, & to.sin_addr, buf,
                                            len, 3);
                }
#line 297
                if (tmp___15) {
#line 299
                  return (-1);
                } else {
                  {
#line 297
                  tmp___16 = icmp4_errcmp___3((char *)(& icmpd), 8, & to.sin_addr,
                                              buf, len, 11);
                  }
#line 297
                  if (tmp___16) {
#line 299
                    return (-1);
                  }
                }
              }
            }
          }
        } else {
#line 305
          return (-1);
        }
      } else {
#line 309
        icmp_errs___3 += (unsigned long volatile   )1;
#line 309
        if (icmp_errs___3 <= (unsigned long volatile   )10) {
          {
#line 310
          log_message(3, "Unhandled poll/select event in ping4() at %s, line %d.",
                      "/home/wheatley/newnew/temp/pdnsd-1.2.9a-par/src/icmp.c", 310);
          }
        }
#line 312
        return (-1);
      }
      {
#line 314
      tmp___20 = time((time_t *)((void *)0));
#line 314
      tpassed = tmp___20 - tm;
      }
#line 226
      if (! (tpassed < (long )timeout)) {
#line 226
        goto while_break___1;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
#line 187
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 317
  return (-1);
}
}
