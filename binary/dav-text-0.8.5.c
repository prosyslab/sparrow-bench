/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 150 "/usr/include/curses.h"
typedef unsigned long chtype;
#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 358 "/usr/include/curses.h"
struct _win_st;
#line 358 "/usr/include/curses.h"
typedef struct _win_st WINDOW;
#line 360 "/usr/include/curses.h"
typedef chtype attr_t;
#line 405
struct ldat;
#line 407 "/usr/include/curses.h"
struct pdat {
   short _pad_y ;
   short _pad_x ;
   short _pad_top ;
   short _pad_left ;
   short _pad_bottom ;
   short _pad_right ;
};
#line 407 "/usr/include/curses.h"
struct _win_st {
   short _cury ;
   short _curx ;
   short _maxy ;
   short _maxx ;
   short _begy ;
   short _begx ;
   short _flags ;
   attr_t _attrs ;
   chtype _bkgd ;
   _Bool _notimeout ;
   _Bool _clear ;
   _Bool _leaveok ;
   _Bool _scroll ;
   _Bool _idlok ;
   _Bool _idcok ;
   _Bool _immed ;
   _Bool _sync ;
   _Bool _use_keypad ;
   int _delay ;
   struct ldat *_line ;
   short _regtop ;
   short _regbottom ;
   int _parx ;
   int _pary ;
   WINDOW *_parent ;
   struct pdat _pad ;
   short _yoffset ;
};
#line 21 "/home/june/repo/benchmarks/collector/temp/dav-text-0.8.5/structs.h"
struct line {
   unsigned char *data ;
   unsigned int length ;
   struct line *next ;
   struct line *prev ;
   unsigned char hasTabs ;
};
#line 29 "/home/june/repo/benchmarks/collector/temp/dav-text-0.8.5/structs.h"
struct position {
   struct line *l ;
   unsigned int offset ;
   unsigned int lineNum ;
   unsigned int cursX ;
   unsigned int cursY ;
   unsigned int wantCursX ;
};
#line 37 "/home/june/repo/benchmarks/collector/temp/dav-text-0.8.5/structs.h"
struct undoMove {
   unsigned int line ;
   unsigned int offset ;
   char c ;
};
#line 43 "/home/june/repo/benchmarks/collector/temp/dav-text-0.8.5/structs.h"
struct buffer {
   char searchString[80] ;
   int numLines ;
   struct line *head ;
   struct line *tail ;
   struct position cursor ;
   struct position topLine ;
   struct position lineUpdate ;
   char keepGoing ;
   struct line **currentLine ;
   char fname[80] ;
   int lineNumBak ;
   char updated ;
   struct undoMove *undoMoves ;
   int undoBufferPointer ;
   int undoBufferLength ;
};
#line 40 "/home/june/repo/benchmarks/collector/temp/dav-text-0.8.5/main.h"
typedef void (*ptrToFunction)();
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 124 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __dev_t;
#line 125 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uid_t;
#line 126 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __gid_t;
#line 127 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __ino_t;
#line 129 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __mode_t;
#line 130 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __nlink_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 153 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blksize_t;
#line 158 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blkcnt_t;
#line 175 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __syscall_slong_t;
#line 120 "/usr/include/time.h"
struct timespec {
   __time_t tv_sec ;
   __syscall_slong_t tv_nsec ;
};
#line 315 "/usr/include/libio.h"
typedef struct _IO_FILE _IO_FILE;
#line 46 "/usr/include/x86_64-linux-gnu/bits/stat.h"
struct stat {
   __dev_t st_dev ;
   __ino_t st_ino ;
   __nlink_t st_nlink ;
   __mode_t st_mode ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   int __pad0 ;
   __dev_t st_rdev ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   __syscall_slong_t __glibc_reserved[3] ;
};
#line 22 "/usr/include/x86_64-linux-gnu/bits/dirent.h"
struct dirent {
   __ino_t d_ino ;
   __off_t d_off ;
   unsigned short d_reclen ;
   unsigned char d_type ;
   char d_name[256] ;
};
#line 127 "/usr/include/dirent.h"
struct __dirstream;
#line 127 "/usr/include/dirent.h"
typedef struct __dirstream DIR;
#line 85 "/usr/include/signal.h"
typedef void (*__sighandler_t)(int  );
#line 785 "/usr/include/curses.h"
extern int waddch(WINDOW * , chtype const    ) ;
#line 788
extern int waddnstr(WINDOW * , char const   * , int  ) ;
#line 810
extern int wgetch(WINDOW * ) ;
#line 824
extern int wmove(WINDOW * , int  , int  ) ;
#line 1386
extern WINDOW *stdscr ;
#line 466 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 480
extern  __attribute__((__nothrow__)) void *( __attribute__((__warn_unused_result__,
__leaf__)) realloc)(void *__ptr , size_t __size ) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 50 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memmove)(void *__dest ,
                                                                                                  void const   *__src ,
                                                                                                  size_t __n ) ;
#line 66
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memset)(void *__s ,
                                                                                               int __c ,
                                                                                               size_t __n ) ;
#line 129
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcpy)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 399
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 21 "/home/june/repo/benchmarks/collector/temp/dav-text-0.8.5/keyboard.h"
void keyHit(int keypress , char undoNow ) ;
#line 22
void listChoice(int n , char **choices , char *answer , char *message ) ;
#line 25 "/home/june/repo/benchmarks/collector/temp/dav-text-0.8.5/main.h"
char scrollDown(void) ;
#line 26
char scrollUp(void) ;
#line 42
void addLineAfter(struct line *whichLine , char *data ) ;
#line 43
void connectLines(struct line *baseline ) ;
#line 45
void countTabs(struct line *l ) ;
#line 46
void determineCursX(struct position *p ) ;
#line 47 "/home/june/repo/benchmarks/collector/temp/dav-text-0.8.5/main.h"
ptrToFunction Fn_ptr[12]  ;
#line 49
int maxY ;
#line 49
int maxX ;
#line 50
int helpBarUpdate ;
#line 57
char autoIndent ;
#line 61
char tabWidth ;
#line 62
char smartCursor ;
#line 65
int *lastDisplayed ;
#line 66
char displayWholeScreen ;
#line 69
struct buffer *currentBuffer ;
#line 25 "/home/june/repo/benchmarks/collector/temp/dav-text-0.8.5/screenIO.h"
void helpBar(void) ;
#line 26
void displayBottomRow(void) ;
#line 21 "/home/june/repo/benchmarks/collector/temp/dav-text-0.8.5/undo.h"
void Do(int keypress ) ;
#line 25 "/home/june/repo/benchmarks/collector/temp/dav-text-0.8.5/move.h"
void moveUp(struct position *p ) ;
#line 26
void moveDown(struct position *p ) ;
#line 27
char moveLeft(struct position *p ) ;
#line 28
char moveRight(struct position *p ) ;
#line 32 "/home/june/repo/benchmarks/collector/temp/dav-text-0.8.5/keyboard.c"
static char ctrl  =    (char)0;
#line 28 "/home/june/repo/benchmarks/collector/temp/dav-text-0.8.5/keyboard.c"
void keyHit(int keypress , char undoNow ) 
{ 
  int t ;
  int t2 ;
  int x ;
  unsigned char *ptr ;
  unsigned char **data ;
  char tmp ;
  char tmp___0 ;
  char tmp___1 ;
  char tmp___2 ;
  unsigned int tmp___3 ;
  unsigned int tmp___4 ;
  unsigned int tmp___5 ;
  struct line *tempLine ;
  void *tmp___6 ;
  char tmp___7 ;
  void *tmp___8 ;
  void *tmp___9 ;
  void *tmp___10 ;
  void *tmp___11 ;

  {
#line 30
  t = 0;
#line 30
  t2 = 0;
#line 36
  if (keypress == 27) {
#line 37
    ctrl = (char)3;
#line 38
    return;
  }
#line 40
  if (keypress == 79) {
#line 40
    if ((int )ctrl == 3) {
#line 41
      ctrl = (char )((int )ctrl - 1);
#line 42
      return;
    }
  }
#line 44
  if (keypress == 99) {
#line 44
    if ((int )ctrl == 2) {
#line 45
      currentBuffer->lineUpdate.offset = 4294967295U;
#line 46
      ctrl = (char)0;
#line 47
      helpBarUpdate = 1;
#line 48
      data = & (*(currentBuffer->currentLine))->data;
#line 49
      t = (int )currentBuffer->cursor.cursY;
#line 50
      currentBuffer->lineUpdate = currentBuffer->cursor;
#line 51
      currentBuffer->lineUpdate.lineNum = currentBuffer->cursor.cursY;
      {
#line 52
      while (1) {
        while_continue: /* CIL Label */ ;
#line 52
        if ((int )*(*data + currentBuffer->cursor.offset) != 32) {
#line 52
          if ((int )*(*data + currentBuffer->cursor.offset) != 10) {
#line 52
            if (! ((int )*(*data + currentBuffer->cursor.offset) != 9)) {
#line 52
              goto while_break;
            }
          } else {
#line 52
            goto while_break;
          }
        } else {
#line 52
          goto while_break;
        }
        {
#line 54
        tmp = moveRight(& currentBuffer->cursor);
        }
#line 54
        if (tmp) {
#line 54
          goto while_break;
        }
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 55
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 55
        if (! ((int )*(*data + currentBuffer->cursor.offset) == 32)) {
#line 55
          if (! ((int )*(*data + currentBuffer->cursor.offset) == 10)) {
#line 55
            if (! ((int )*(*data + currentBuffer->cursor.offset) == 9)) {
#line 55
              goto while_break___0;
            }
          }
        }
        {
#line 57
        tmp___0 = moveRight(& currentBuffer->cursor);
        }
#line 57
        if (tmp___0) {
#line 57
          goto while_break___0;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
#line 58
      return;
    }
  }
#line 60
  if (keypress == 100) {
#line 60
    if ((int )ctrl == 2) {
      {
#line 61
      currentBuffer->lineUpdate.offset = 4294967295U;
#line 62
      ctrl = (char)0;
#line 63
      helpBarUpdate = 1;
#line 64
      data = & (*(currentBuffer->currentLine))->data;
#line 65
      t = (int )currentBuffer->cursor.cursY;
#line 66
      currentBuffer->lineUpdate = currentBuffer->cursor;
#line 67
      currentBuffer->lineUpdate.lineNum = currentBuffer->cursor.cursY;
#line 68
      moveLeft(& currentBuffer->cursor);
      }
      {
#line 69
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 69
        if (! ((int )*(*data + currentBuffer->cursor.offset) == 32)) {
#line 69
          if (! ((int )*(*data + currentBuffer->cursor.offset) == 10)) {
#line 69
            if (! ((int )*(*data + currentBuffer->cursor.offset) == 9)) {
#line 69
              goto while_break___1;
            }
          }
        }
        {
#line 71
        tmp___1 = moveLeft(& currentBuffer->cursor);
        }
#line 71
        if (tmp___1) {
#line 71
          goto while_break___1;
        }
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 72
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 72
        if ((int )*(*data + currentBuffer->cursor.offset) != 32) {
#line 72
          if ((int )*(*data + currentBuffer->cursor.offset) != 10) {
#line 72
            if (! ((int )*(*data + currentBuffer->cursor.offset) != 9)) {
#line 72
              goto while_break___2;
            }
          } else {
#line 72
            goto while_break___2;
          }
        } else {
#line 72
          goto while_break___2;
        }
        {
#line 74
        tmp___2 = moveLeft(& currentBuffer->cursor);
        }
#line 74
        if (tmp___2) {
#line 74
          goto while_break___2;
        }
      }
      while_break___2: /* CIL Label */ ;
      }
      {
#line 75
      moveRight(& currentBuffer->cursor);
      }
#line 76
      return;
    }
  }
#line 78
  if (keypress == 91) {
#line 78
    if ((int )ctrl == 3) {
#line 79
      ctrl = (char )((int )ctrl - 1);
#line 80
      return;
    }
  }
#line 82
  if (keypress == 55) {
#line 82
    if ((int )ctrl == 2) {
#line 83
      ctrl = (char)1;
#line 84
      return;
    } else {
#line 82
      goto _L___2;
    }
  } else
  _L___2: /* CIL Label */ 
#line 86
  if (keypress == 94) {
#line 86
    if ((int )ctrl == 1) {
#line 86
      goto _L___0;
    } else {
#line 86
      goto _L___1;
    }
  } else
  _L___1: /* CIL Label */ 
#line 86
  if (keypress == 391) {
    _L___0: /* CIL Label */ 
#line 88
    tmp___4 = 0U;
#line 88
    currentBuffer->cursor.offset = tmp___4;
#line 88
    tmp___3 = tmp___4;
#line 88
    currentBuffer->cursor.cursX = tmp___3;
#line 88
    currentBuffer->cursor.cursY = tmp___3;
#line 89
    currentBuffer->cursor.l = (currentBuffer->head)->next;
#line 90
    currentBuffer->topLine = currentBuffer->cursor;
#line 91
    currentBuffer->lineUpdate = currentBuffer->cursor;
#line 92
    currentBuffer->lineUpdate.lineNum = 0U;
#line 93
    currentBuffer->keepGoing = (char)1;
#line 94
    ctrl = (char)0;
#line 95
    return;
  } else
#line 97
  if (keypress == 335) {
#line 97
    goto _L;
  } else
#line 97
  if (keypress == 386) {
    _L: /* CIL Label */ 
    {
#line 99
    *(currentBuffer->currentLine) = (currentBuffer->tail)->prev;
#line 100
    currentBuffer->cursor.offset = (*(currentBuffer->currentLine))->length - 1U;
#line 101
    determineCursX(& currentBuffer->cursor);
#line 102
    currentBuffer->cursor.cursY = 0U;
#line 103
    currentBuffer->topLine = currentBuffer->cursor;
#line 104
    tmp___5 = 0U;
#line 104
    currentBuffer->topLine.offset = tmp___5;
#line 104
    currentBuffer->topLine.cursX = tmp___5;
#line 105
    t = 0;
    }
    {
#line 105
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 105
      if (! (t < maxY - 4)) {
#line 105
        goto while_break___3;
      }
      {
#line 106
      scrollUp();
#line 105
      t ++;
      }
    }
    while_break___3: /* CIL Label */ ;
    }
#line 107
    currentBuffer->lineUpdate = currentBuffer->topLine;
#line 108
    currentBuffer->lineUpdate.lineNum = 0U;
#line 109
    currentBuffer->keepGoing = (char)1;
#line 110
    return;
  }
#line 112
  ctrl = (char)0;
  {
#line 115
  if (keypress == 410) {
#line 115
    goto case_410;
  }
#line 118
  if (keypress == -1) {
#line 118
    goto case_neg_1;
  }
#line 164
  if (keypress == 276) {
#line 164
    goto case_276;
  }
#line 164
  if (keypress == 275) {
#line 164
    goto case_276;
  }
#line 164
  if (keypress == 274) {
#line 164
    goto case_276;
  }
#line 164
  if (keypress == 273) {
#line 164
    goto case_276;
  }
#line 164
  if (keypress == 272) {
#line 164
    goto case_276;
  }
#line 164
  if (keypress == 271) {
#line 164
    goto case_276;
  }
#line 164
  if (keypress == 270) {
#line 164
    goto case_276;
  }
#line 164
  if (keypress == 269) {
#line 164
    goto case_276;
  }
#line 164
  if (keypress == 268) {
#line 164
    goto case_276;
  }
#line 164
  if (keypress == 267) {
#line 164
    goto case_276;
  }
#line 164
  if (keypress == 266) {
#line 164
    goto case_276;
  }
#line 164
  if (keypress == 265) {
#line 164
    goto case_276;
  }
#line 169
  if (keypress == 258) {
#line 169
    goto case_258;
  }
#line 180
  if (keypress == 259) {
#line 180
    goto case_259;
  }
#line 191
  if (keypress == 260) {
#line 191
    goto case_260;
  }
#line 197
  if (keypress == 261) {
#line 197
    goto case_261;
  }
#line 203
  if (keypress == 338) {
#line 203
    goto case_338;
  }
#line 221
  if (keypress == 339) {
#line 221
    goto case_339;
  }
#line 236
  if (keypress == 262) {
#line 236
    goto case_262;
  }
#line 242
  if (keypress == 360) {
#line 242
    goto case_360;
  }
#line 258
  if (keypress == 8) {
#line 258
    goto case_8;
  }
#line 258
  if (keypress == 263) {
#line 258
    goto case_8;
  }
#line 266
  if (keypress == 330) {
#line 266
    goto case_330;
  }
#line 285
  if (keypress == 21) {
#line 285
    goto case_21;
  }
#line 292
  if (keypress == 11) {
#line 292
    goto case_11;
  }
#line 307
  if (keypress == 13) {
#line 307
    goto case_13;
  }
#line 354
  goto switch_default;
  case_410: /* CIL Label */ 
  {
#line 116
  displayBottomRow();
  }
#line 117
  goto switch_break;
  case_neg_1: /* CIL Label */ 
  {
#line 120
  tempLine = currentBuffer->cursor.l;
#line 121
  t = (int )currentBuffer->cursor.offset;
#line 124
  keyHit(262, (char)0);
  }
  {
#line 125
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 125
    if (! (currentBuffer->cursor.cursY > 0U)) {
#line 125
      goto while_break___4;
    }
    {
#line 126
    keyHit(259, (char)0);
    }
  }
  while_break___4: /* CIL Label */ ;
  }
#line 129
  if (stdscr) {
#line 129
    maxY = (int )stdscr->_maxy + 1;
  } else {
#line 129
    maxY = -1;
  }
#line 129
  if (stdscr) {
#line 129
    maxX = (int )stdscr->_maxx + 1;
  } else {
#line 129
    maxX = -1;
  }
  {
#line 130
  free((void *)lastDisplayed);
#line 131
  tmp___6 = malloc((unsigned long )maxY * sizeof(int ));
#line 131
  lastDisplayed = (int *)tmp___6;
#line 132
  memset((void *)lastDisplayed, 0, (unsigned long )maxY * sizeof(int ));
#line 133
  helpBar();
  }
  {
#line 134
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 134
    if (! ((unsigned long )currentBuffer->cursor.l != (unsigned long )tempLine)) {
#line 134
      goto while_break___5;
    }
    {
#line 135
    keyHit(258, (char)0);
    }
  }
  while_break___5: /* CIL Label */ ;
  }
  {
#line 137
  while (1) {
    while_continue___6: /* CIL Label */ ;
#line 137
    if (! (currentBuffer->cursor.offset < (unsigned int )t)) {
#line 137
      goto while_break___6;
    }
    {
#line 138
    keyHit(261, (char)0);
    }
  }
  while_break___6: /* CIL Label */ ;
  }
  {
#line 140
  while (1) {
    while_continue___7: /* CIL Label */ ;
#line 140
    if (! (currentBuffer->cursor.offset > (unsigned int )t)) {
#line 140
      goto while_break___7;
    }
    {
#line 141
    keyHit(260, (char)0);
    }
  }
  while_break___7: /* CIL Label */ ;
  }
#line 143
  currentBuffer->lineUpdate = currentBuffer->topLine;
#line 144
  currentBuffer->lineUpdate.lineNum = 0U;
#line 145
  currentBuffer->keepGoing = (char)1;
#line 148
  displayWholeScreen = (char)1;
#line 150
  goto switch_break;
  case_276: /* CIL Label */ 
  case_275: /* CIL Label */ 
  case_274: /* CIL Label */ 
  case_273: /* CIL Label */ 
  case_272: /* CIL Label */ 
  case_271: /* CIL Label */ 
  case_270: /* CIL Label */ 
  case_269: /* CIL Label */ 
  case_268: /* CIL Label */ 
  case_267: /* CIL Label */ 
  case_266: /* CIL Label */ 
  case_265: /* CIL Label */ 
  {
#line 165
  currentBuffer->lineUpdate.offset = 4294967295U;
#line 166
  (*(Fn_ptr[keypress - 265]))();
  }
#line 167
  goto switch_break;
  case_258: /* CIL Label */ 
  {
#line 170
  currentBuffer->lineUpdate.offset = 4294967295U;
#line 171
  moveDown(& currentBuffer->cursor);
  }
#line 172
  if (smartCursor) {
    {
#line 173
    while (1) {
      while_continue___8: /* CIL Label */ ;
#line 173
      if (currentBuffer->cursor.wantCursX > currentBuffer->cursor.cursX) {
#line 173
        if (! (currentBuffer->cursor.cursX < (*(currentBuffer->currentLine))->length % (unsigned int )maxX - 1U)) {
#line 173
          goto while_break___8;
        }
      } else {
#line 173
        goto while_break___8;
      }
      {
#line 175
      moveRight(& currentBuffer->cursor);
      }
    }
    while_break___8: /* CIL Label */ ;
    }
  }
#line 178
  goto switch_break;
  case_259: /* CIL Label */ 
  {
#line 181
  currentBuffer->lineUpdate.offset = 4294967295U;
#line 182
  moveUp(& currentBuffer->cursor);
  }
#line 183
  if (smartCursor) {
    {
#line 184
    while (1) {
      while_continue___9: /* CIL Label */ ;
#line 184
      if (currentBuffer->cursor.wantCursX > currentBuffer->cursor.cursX) {
#line 184
        if (! (currentBuffer->cursor.cursX < (*(currentBuffer->currentLine))->length % (unsigned int )maxX - 1U)) {
#line 184
          goto while_break___9;
        }
      } else {
#line 184
        goto while_break___9;
      }
      {
#line 186
      moveRight(& currentBuffer->cursor);
      }
    }
    while_break___9: /* CIL Label */ ;
    }
  }
#line 189
  goto switch_break;
  case_260: /* CIL Label */ 
  {
#line 192
  currentBuffer->lineUpdate.offset = 4294967295U;
#line 193
  moveLeft(& currentBuffer->cursor);
#line 194
  currentBuffer->cursor.wantCursX = currentBuffer->cursor.cursX;
  }
#line 195
  goto switch_break;
  case_261: /* CIL Label */ 
  {
#line 198
  currentBuffer->lineUpdate.offset = 4294967295U;
#line 199
  moveRight(& currentBuffer->cursor);
#line 200
  currentBuffer->cursor.wantCursX = currentBuffer->cursor.cursX;
  }
#line 201
  goto switch_break;
  case_338: /* CIL Label */ 
#line 204
  currentBuffer->lineUpdate.offset = 4294967295U;
#line 205
  x = (int )(currentBuffer->cursor.cursY + 2U);
#line 206
  t = maxY - 1;
  {
#line 206
  while (1) {
    while_continue___10: /* CIL Label */ ;
#line 206
    if (! t) {
#line 206
      goto while_break___10;
    }
    {
#line 207
    moveDown(& currentBuffer->cursor);
#line 206
    t --;
    }
  }
  while_break___10: /* CIL Label */ ;
  }
#line 209
  t = 0;
  {
#line 209
  while (1) {
    while_continue___11: /* CIL Label */ ;
#line 209
    if (! (t < maxY - x)) {
#line 209
      goto while_break___11;
    }
    {
#line 210
    scrollDown();
#line 209
    t ++;
    }
  }
  while_break___11: /* CIL Label */ ;
  }
#line 212
  if (smartCursor) {
    {
#line 213
    while (1) {
      while_continue___12: /* CIL Label */ ;
#line 213
      if (currentBuffer->cursor.wantCursX > currentBuffer->cursor.cursX) {
#line 213
        if (! (currentBuffer->cursor.cursX < (*(currentBuffer->currentLine))->length - 1U)) {
#line 213
          goto while_break___12;
        }
      } else {
#line 213
        goto while_break___12;
      }
      {
#line 215
      moveRight(& currentBuffer->cursor);
      }
    }
    while_break___12: /* CIL Label */ ;
    }
  }
#line 219
  goto switch_break;
  case_339: /* CIL Label */ 
#line 222
  currentBuffer->lineUpdate.offset = 4294967295U;
#line 223
  x = (int )currentBuffer->cursor.cursY;
#line 224
  t = 0;
  {
#line 224
  while (1) {
    while_continue___13: /* CIL Label */ ;
#line 224
    if (! (t < maxY - 1)) {
#line 224
      goto while_break___13;
    }
    {
#line 225
    moveUp(& currentBuffer->cursor);
#line 224
    t ++;
    }
  }
  while_break___13: /* CIL Label */ ;
  }
#line 226
  t = 0;
  {
#line 226
  while (1) {
    while_continue___14: /* CIL Label */ ;
#line 226
    if (! (t < x)) {
#line 226
      goto while_break___14;
    }
    {
#line 227
    scrollUp();
#line 226
    t ++;
    }
  }
  while_break___14: /* CIL Label */ ;
  }
#line 228
  if (smartCursor) {
    {
#line 229
    while (1) {
      while_continue___15: /* CIL Label */ ;
#line 229
      if (currentBuffer->cursor.wantCursX > currentBuffer->cursor.cursX) {
#line 229
        if (! (currentBuffer->cursor.cursX < (*(currentBuffer->currentLine))->length - 1U)) {
#line 229
          goto while_break___15;
        }
      } else {
#line 229
        goto while_break___15;
      }
      {
#line 231
      moveRight(& currentBuffer->cursor);
      }
    }
    while_break___15: /* CIL Label */ ;
    }
  }
#line 234
  goto switch_break;
  case_262: /* CIL Label */ 
#line 237
  currentBuffer->lineUpdate.offset = 4294967295U;
  {
#line 238
  while (1) {
    while_continue___16: /* CIL Label */ ;
#line 238
    if (! currentBuffer->cursor.cursX) {
#line 238
      goto while_break___16;
    }
    {
#line 238
    moveLeft(& currentBuffer->cursor);
    }
  }
  while_break___16: /* CIL Label */ ;
  }
#line 239
  currentBuffer->cursor.wantCursX = currentBuffer->cursor.cursX;
#line 240
  goto switch_break;
  case_360: /* CIL Label */ 
#line 243
  t2 = (int )currentBuffer->topLine.lineNum;
  {
#line 244
  while (1) {
    while_continue___17: /* CIL Label */ ;
    {
#line 245
    tmp___7 = moveRight(& currentBuffer->cursor);
#line 245
    t = (int )tmp___7;
    }
#line 246
    if (t == 1) {
#line 246
      goto while_break___17;
    } else
#line 247
    if (t > 1) {
      {
#line 248
      moveLeft(& currentBuffer->cursor);
      }
#line 249
      goto while_break___17;
    }
  }
  while_break___17: /* CIL Label */ ;
  }
#line 252
  currentBuffer->lineUpdate.offset = 4294967295U;
#line 253
  if ((unsigned int )t2 != currentBuffer->topLine.lineNum) {
    {
#line 253
    scrollUp();
    }
  }
#line 254
  currentBuffer->cursor.wantCursX = currentBuffer->cursor.cursX;
#line 255
  goto switch_break;
  case_8: /* CIL Label */ 
  case_263: /* CIL Label */ 
#line 259
  if ((unsigned long )*(currentBuffer->currentLine) == (unsigned long )(currentBuffer->head)->next) {
#line 259
    if (currentBuffer->cursor.offset == 0U) {
#line 260
      currentBuffer->lineUpdate.offset = 4294967295U;
#line 261
      goto switch_break;
    }
  }
  {
#line 263
  moveLeft(& currentBuffer->cursor);
  }
  case_330: /* CIL Label */ 
#line 267
  if ((unsigned long )(*(currentBuffer->currentLine))->next == (unsigned long )currentBuffer->tail) {
#line 267
    if (currentBuffer->cursor.offset == (*(currentBuffer->currentLine))->length - 1U) {
#line 267
      goto switch_break;
    }
  }
#line 268
  if (undoNow) {
    {
#line 268
    Do(0);
    }
  }
#line 269
  if ((int )*((*(currentBuffer->currentLine))->data + currentBuffer->cursor.offset) == 9) {
#line 269
    (*(currentBuffer->currentLine))->hasTabs = (unsigned char )((int )(*(currentBuffer->currentLine))->hasTabs - 1);
  }
  {
#line 270
  x = (int )*((*(currentBuffer->currentLine))->data + currentBuffer->cursor.offset) == 10;
#line 271
  ((*(currentBuffer->currentLine))->length) --;
#line 273
  ptr = (*(currentBuffer->currentLine))->data;
#line 274
  memmove((void *)(ptr + currentBuffer->cursor.offset), (void const   *)((ptr + currentBuffer->cursor.offset) + 1),
          (size_t )((currentBuffer->cursor.l)->length - currentBuffer->cursor.offset));
#line 275
  tmp___8 = realloc((void *)(*(currentBuffer->currentLine))->data, (size_t )(*(currentBuffer->currentLine))->length);
#line 275
  (*(currentBuffer->currentLine))->data = (unsigned char *)tmp___8;
#line 277
  currentBuffer->lineUpdate = currentBuffer->cursor;
#line 278
  currentBuffer->lineUpdate.lineNum = currentBuffer->cursor.cursY;
  }
#line 279
  if (! ((*(currentBuffer->currentLine))->length % (unsigned int )maxX)) {
#line 279
    currentBuffer->keepGoing = (char)1;
  }
#line 280
  if (x) {
    {
#line 280
    connectLines(*(currentBuffer->currentLine));
#line 280
    currentBuffer->keepGoing = (char)1;
    }
  }
#line 281
  currentBuffer->updated = (char)1;
#line 282
  currentBuffer->cursor.wantCursX = currentBuffer->cursor.cursX;
#line 283
  goto switch_break;
  case_21: /* CIL Label */ 
  {
#line 286
  keyHit(262, undoNow);
#line 287
  x = (int )(*(currentBuffer->currentLine))->length;
  }
  {
#line 287
  while (1) {
    while_continue___18: /* CIL Label */ ;
#line 287
    if (! x) {
#line 287
      goto while_break___18;
    }
    {
#line 288
    keyHit(330, undoNow);
#line 287
    x --;
    }
  }
  while_break___18: /* CIL Label */ ;
  }
#line 290
  goto switch_break;
  case_11: /* CIL Label */ 
#line 293
  if (currentBuffer->cursor.offset == (*(currentBuffer->currentLine))->length - 1U) {
    {
#line 294
    keyHit(330, undoNow);
    }
#line 295
    goto switch_break;
  }
  {
#line 297
  x = (int )currentBuffer->cursor.cursX;
#line 298
  keyHit(360, undoNow);
  }
#line 299
  if ((int )*((currentBuffer->cursor.l)->data + currentBuffer->cursor.offset) != 10) {
    {
#line 300
    keyHit(330, undoNow);
    }
  }
  {
#line 302
  while (1) {
    while_continue___19: /* CIL Label */ ;
#line 302
    if (! (currentBuffer->cursor.cursX > (unsigned int )x)) {
#line 302
      goto while_break___19;
    }
    {
#line 303
    keyHit(263, undoNow);
    }
  }
  while_break___19: /* CIL Label */ ;
  }
#line 305
  goto switch_break;
  case_13: /* CIL Label */ 
#line 308
  if (undoNow) {
    {
#line 308
    Do(1);
    }
  }
#line 309
  currentBuffer->updated = (char)1;
#line 310
  (currentBuffer->cursor.cursY) ++;
#line 311
  currentBuffer->cursor.cursX = 0U;
#line 312
  (currentBuffer->cursor.lineNum) ++;
#line 314
  if (autoIndent) {
#line 315
    t2 = 0;
    {
#line 315
    while (1) {
      while_continue___20: /* CIL Label */ ;
#line 315
      if ((int )*((*(currentBuffer->currentLine))->data + t2) == 9) {
#line 315
        if (! ((unsigned int )t2 < currentBuffer->cursor.offset)) {
#line 315
          goto while_break___20;
        }
      } else {
#line 315
        goto while_break___20;
      }
#line 315
      t2 ++;
    }
    while_break___20: /* CIL Label */ ;
    }
#line 316
    t = t2;
    {
#line 316
    while (1) {
      while_continue___21: /* CIL Label */ ;
#line 316
      if ((int )*((*(currentBuffer->currentLine))->data + t) == 32) {
#line 316
        if (! ((unsigned int )t < currentBuffer->cursor.offset)) {
#line 316
          goto while_break___21;
        }
      } else {
#line 316
        goto while_break___21;
      }
#line 316
      t ++;
    }
    while_break___21: /* CIL Label */ ;
    }
#line 317
    t -= t2;
  }
  {
#line 320
  addLineAfter(*(currentBuffer->currentLine), (char *)"");
#line 321
  x = (int )(*(currentBuffer->currentLine))->length;
#line 323
  tmp___9 = malloc((size_t )((unsigned int )x - currentBuffer->cursor.offset));
#line 323
  ptr = (unsigned char *)tmp___9;
#line 324
  memmove((void *)ptr, (void const   *)((*(currentBuffer->currentLine))->data + currentBuffer->cursor.offset),
          (size_t )((unsigned int )x - currentBuffer->cursor.offset));
#line 325
  free((void *)((*(currentBuffer->currentLine))->next)->data);
#line 326
  ((*(currentBuffer->currentLine))->next)->data = ptr;
#line 327
  ((*(currentBuffer->currentLine))->next)->length = (unsigned int )x - currentBuffer->cursor.offset;
#line 329
  tmp___10 = realloc((void *)(*(currentBuffer->currentLine))->data, (size_t )(currentBuffer->cursor.offset + 1U));
#line 329
  (*(currentBuffer->currentLine))->data = (unsigned char *)tmp___10;
#line 330
  (*(currentBuffer->currentLine))->length = currentBuffer->cursor.offset + 1U;
#line 332
  *((*(currentBuffer->currentLine))->data + ((*(currentBuffer->currentLine))->length - 1U)) = (unsigned char )'\n';
#line 333
  *(currentBuffer->currentLine) = (*(currentBuffer->currentLine))->next;
#line 334
  currentBuffer->cursor.offset = 0U;
#line 335
  countTabs(*(currentBuffer->currentLine));
#line 336
  countTabs((*(currentBuffer->currentLine))->next);
  }
#line 337
  if (autoIndent) {
    {
#line 338
    while (1) {
      while_continue___22: /* CIL Label */ ;
#line 338
      if (! t2) {
#line 338
        goto while_break___22;
      }
      {
#line 338
      keyHit(9, undoNow);
#line 338
      t2 --;
      }
    }
    while_break___22: /* CIL Label */ ;
    }
    {
#line 339
    while (1) {
      while_continue___23: /* CIL Label */ ;
#line 339
      if (! t) {
#line 339
        goto while_break___23;
      }
      {
#line 339
      keyHit(' ', undoNow);
#line 339
      t --;
      }
    }
    while_break___23: /* CIL Label */ ;
    }
  }
#line 341
  currentBuffer->lineUpdate = currentBuffer->cursor;
  {
#line 342
  while (1) {
    while_continue___24: /* CIL Label */ ;
    {
#line 343
    moveLeft(& currentBuffer->lineUpdate);
    }
#line 342
    if (! currentBuffer->lineUpdate.offset) {
#line 342
      goto while_break___24;
    }
  }
  while_break___24: /* CIL Label */ ;
  }
  {
#line 345
  while (1) {
    while_continue___25: /* CIL Label */ ;
    {
#line 346
    moveLeft(& currentBuffer->lineUpdate);
    }
#line 345
    if (! currentBuffer->lineUpdate.offset) {
#line 345
      goto while_break___25;
    }
  }
  while_break___25: /* CIL Label */ ;
  }
#line 348
  currentBuffer->lineUpdate.lineNum = currentBuffer->lineUpdate.cursY;
#line 349
  currentBuffer->keepGoing = (char)1;
#line 350
  if (currentBuffer->cursor.cursY == (unsigned int )(maxY - 1)) {
    {
#line 350
    scrollDown();
    }
  }
#line 351
  currentBuffer->cursor.wantCursX = currentBuffer->cursor.cursX;
#line 352
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 355
  if (undoNow) {
    {
#line 355
    Do(1);
    }
  }
#line 356
  currentBuffer->lineUpdate = currentBuffer->cursor;
#line 357
  currentBuffer->lineUpdate.lineNum = currentBuffer->cursor.cursY;
#line 358
  if (! ((*(currentBuffer->currentLine))->length % (unsigned int )maxX)) {
#line 358
    currentBuffer->keepGoing = (char)1;
  }
#line 360
  if (keypress == 9) {
#line 362
    currentBuffer->cursor.cursX += (unsigned int )((int )tabWidth - 1) - currentBuffer->cursor.cursX % (unsigned int )tabWidth;
#line 363
    (*(currentBuffer->currentLine))->hasTabs = (unsigned char )((int )(*(currentBuffer->currentLine))->hasTabs + 1);
  }
  {
#line 366
  x = (int )(*(currentBuffer->currentLine))->length;
#line 368
  tmp___11 = realloc((void *)(*(currentBuffer->currentLine))->data, (size_t )(x + 1));
#line 368
  (*(currentBuffer->currentLine))->data = (unsigned char *)tmp___11;
#line 369
  memmove((void *)(((*(currentBuffer->currentLine))->data + currentBuffer->cursor.offset) + 1),
          (void const   *)((*(currentBuffer->currentLine))->data + currentBuffer->cursor.offset),
          (size_t )((unsigned int )x - currentBuffer->cursor.offset));
#line 370
  *((*(currentBuffer->currentLine))->data + currentBuffer->cursor.offset) = (unsigned char )keypress;
#line 372
  ((*(currentBuffer->currentLine))->length) ++;
#line 373
  (currentBuffer->cursor.offset) ++;
#line 374
  (currentBuffer->cursor.cursX) ++;
  }
#line 375
  if (currentBuffer->cursor.cursX >= (unsigned int )maxX) {
#line 377
    currentBuffer->cursor.cursX = 0U;
#line 378
    (currentBuffer->cursor.cursY) ++;
#line 378
    if (currentBuffer->cursor.cursY >= (unsigned int )(maxY - 1)) {
      {
#line 378
      scrollDown();
      }
    }
  }
#line 380
  currentBuffer->cursor.wantCursX = currentBuffer->cursor.cursX;
#line 381
  currentBuffer->updated = (char)1;
  switch_break: /* CIL Label */ ;
  }
#line 383
  return;
}
}
#line 385 "/home/june/repo/benchmarks/collector/temp/dav-text-0.8.5/keyboard.c"
void listChoice(int n , char **choices , char *answer , char *message ) 
{ 
  int start ;
  int end ;
  int selected ;
  int t ;
  int line ;
  int keypress ;
  char newName[256] ;
  int x ;
  int y ;
  char focus ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  size_t tmp___3 ;
  int tmp___4 ;
  char *tmp___5 ;
  size_t tmp___6 ;
  size_t tmp___7 ;
  int t___0 ;
  int t___1 ;
  void *tmp___8 ;
  size_t tmp___9 ;
  size_t tmp___10 ;
  int tmp___11 ;

  {
#line 387
  start = 0;
#line 389
  selected = 0;
#line 395
  focus = (char)0;
#line 397
  newName[0] = (char )'\000';
  {
#line 399
  while (1) {
    while_continue: /* CIL Label */ ;
#line 401
    y = 0;
    {
#line 401
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 401
      if (! (y < maxY)) {
#line 401
        goto while_break___0;
      }
#line 402
      x = 0;
      {
#line 402
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 402
        if (! (x < maxX)) {
#line 402
          goto while_break___1;
        }
        {
#line 403
        tmp = wmove(stdscr, y, x);
        }
#line 403
        if (! (tmp == -1)) {
          {
#line 403
          waddch(stdscr, (chtype const   )' ');
          }
        }
#line 402
        x ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 401
      y ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 405
    line = 0;
#line 406
    if ((start + maxY) - 1 >= n) {
#line 406
      end = n;
    } else {
#line 406
      end = (start + maxY) - 1;
    }
#line 407
    t = start;
    {
#line 407
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 407
      if (! (t < end)) {
#line 407
        goto while_break___2;
      }
      {
#line 409
      tmp___0 = wmove(stdscr, line, 2);
      }
#line 409
      if (! (tmp___0 == -1)) {
        {
#line 409
        waddnstr(stdscr, (char const   *)*(choices + t), -1);
        }
      }
#line 410
      line ++;
#line 407
      t ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 412
    if (! focus) {
      {
#line 412
      tmp___1 = wmove(stdscr, selected - start, 0);
      }
#line 412
      if (! (tmp___1 == -1)) {
        {
#line 412
        waddnstr(stdscr, "->", -1);
        }
      }
    }
    {
#line 413
    tmp___2 = wmove(stdscr, maxY - 1, 0);
    }
#line 413
    if (! (tmp___2 == -1)) {
      {
#line 413
      waddnstr(stdscr, (char const   *)message, -1);
      }
    }
    {
#line 414
    tmp___3 = strlen((char const   *)message);
#line 414
    tmp___4 = wmove(stdscr, maxY - 1, (int )(tmp___3 + 1UL));
    }
#line 414
    if (! (tmp___4 == -1)) {
      {
#line 414
      waddnstr(stdscr, (char const   *)(newName), -1);
      }
    }
    {
#line 416
    keypress = wgetch(stdscr);
    }
#line 417
    if (keypress == 258) {
#line 418
      focus = (char)0;
#line 419
      if (selected < n - 1) {
#line 419
        selected ++;
      }
#line 420
      if (selected - start == maxY - 1) {
#line 421
        start ++;
      }
    } else
#line 423
    if (keypress == 259) {
#line 424
      focus = (char)0;
#line 425
      if (selected) {
#line 425
        selected --;
      }
#line 426
      if (selected < start) {
#line 426
        start --;
      }
    } else
#line 428
    if (keypress == 13) {
#line 429
      if (focus) {
#line 429
        tmp___5 = newName;
      } else {
#line 429
        tmp___5 = *(choices + selected);
      }
      {
#line 429
      strcpy((char */* __restrict  */)answer, (char const   */* __restrict  */)tmp___5);
      }
#line 430
      if ((int )focus == 0) {
#line 430
        if (selected == 0) {
          {
#line 431
          strcpy((char */* __restrict  */)answer, (char const   */* __restrict  */)"DAV_CANCEL");
          }
        }
      }
#line 432
      goto while_break;
    } else
#line 434
    if (keypress == 263) {
      {
#line 435
      focus = (char)1;
#line 436
      tmp___7 = strlen((char const   *)(newName));
      }
#line 436
      if (tmp___7 != 0UL) {
        {
#line 437
        tmp___6 = strlen((char const   *)(newName));
#line 437
        newName[tmp___6 - 1UL] = (char )'\000';
        }
      }
    } else
#line 439
    if (keypress == 338) {
#line 441
      focus = (char)0;
#line 442
      t___0 = 0;
      {
#line 442
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 442
        if (! (t___0 < maxY)) {
#line 442
          goto while_break___3;
        }
#line 443
        if (selected < n - 1) {
#line 443
          selected ++;
        }
#line 444
        if (selected - start == maxY - 1) {
#line 445
          start ++;
        }
#line 442
        t___0 ++;
      }
      while_break___3: /* CIL Label */ ;
      }
    } else
#line 448
    if (keypress == 339) {
#line 450
      focus = (char)0;
#line 451
      t___1 = 0;
      {
#line 451
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 451
        if (! (t___1 < maxY)) {
#line 451
          goto while_break___4;
        }
#line 452
        if (selected) {
#line 452
          selected --;
        }
#line 453
        if (selected < start) {
#line 453
          start --;
        }
#line 451
        t___1 ++;
      }
      while_break___4: /* CIL Label */ ;
      }
    } else
#line 456
    if (! (keypress == 410)) {
#line 459
      if (keypress == -1) {
#line 460
        if (stdscr) {
#line 460
          maxY = (int )stdscr->_maxy + 1;
        } else {
#line 460
          maxY = -1;
        }
#line 460
        if (stdscr) {
#line 460
          maxX = (int )stdscr->_maxx + 1;
        } else {
#line 460
          maxX = -1;
        }
        {
#line 461
        free((void *)lastDisplayed);
#line 462
        tmp___8 = malloc((unsigned long )maxY * sizeof(int ));
#line 462
        lastDisplayed = (int *)tmp___8;
#line 463
        memset((void *)lastDisplayed, 0, (unsigned long )maxY * sizeof(int ));
        }
        {
#line 464
        while (1) {
          while_continue___5: /* CIL Label */ ;
#line 464
          if (! (selected - start >= maxY - 1)) {
#line 464
            goto while_break___5;
          }
#line 465
          start ++;
        }
        while_break___5: /* CIL Label */ ;
        }
      } else {
        {
#line 468
        focus = (char)1;
#line 469
        tmp___9 = strlen((char const   *)(newName));
#line 469
        newName[tmp___9 + 1UL] = (char )'\000';
#line 470
        tmp___10 = strlen((char const   *)(newName));
#line 470
        newName[tmp___10] = (char )keypress;
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 474
  y = 0;
  {
#line 474
  while (1) {
    while_continue___6: /* CIL Label */ ;
#line 474
    if (! (y < maxY)) {
#line 474
      goto while_break___6;
    }
#line 475
    x = 0;
    {
#line 475
    while (1) {
      while_continue___7: /* CIL Label */ ;
#line 475
      if (! (x < maxX)) {
#line 475
        goto while_break___7;
      }
      {
#line 476
      tmp___11 = wmove(stdscr, y, x);
      }
#line 476
      if (! (tmp___11 == -1)) {
        {
#line 476
        waddch(stdscr, (chtype const   )' ');
        }
      }
#line 475
      x ++;
    }
    while_break___7: /* CIL Label */ ;
    }
#line 474
    y ++;
  }
  while_break___6: /* CIL Label */ ;
  }
#line 477
  return;
}
}
#line 717 "/usr/include/stdlib.h"
extern int system(char const   *__command ) ;
#line 144 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 342
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strstr)(char const   *__haystack ,
                                                                                                 char const   *__needle )  __attribute__((__pure__)) ;
#line 237 "/usr/include/stdio.h"
extern int fclose(FILE *__stream ) ;
#line 272
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 531
extern int fgetc(FILE *__stream ) ;
#line 828
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) feof)(FILE *__stream ) ;
#line 774 "/usr/include/curses.h"
extern int ungetch(int  ) ;
#line 811
extern int wgetnstr(WINDOW * , char * , int  ) ;
#line 21 "/home/june/repo/benchmarks/collector/temp/dav-text-0.8.5/features.h"
void search(void) ;
#line 22
void replace(void) ;
#line 23
void tryCompile(void) ;
#line 24
void gotoLine(int line ) ;
#line 25
void toggleAutoIndent(void) ;
#line 26
void toggleBottomRow(void) ;
#line 59 "/home/june/repo/benchmarks/collector/temp/dav-text-0.8.5/main.h"
char bottomRowToggle ;
#line 23 "/home/june/repo/benchmarks/collector/temp/dav-text-0.8.5/screenIO.h"
void displayScreen(void) ;
#line 22 "/home/june/repo/benchmarks/collector/temp/dav-text-0.8.5/fileIO.h"
void save(void) ;
#line 24
void load(char *filename ) ;
#line 23 "/home/june/repo/benchmarks/collector/temp/dav-text-0.8.5/buffers.h"
void goToNextBuffer(void) ;
#line 23 "/home/june/repo/benchmarks/collector/temp/dav-text-0.8.5/move.h"
char positionDown(struct position *p ) ;
#line 30 "/home/june/repo/benchmarks/collector/temp/dav-text-0.8.5/features.c"
void search(void) 
{ 
  unsigned char *t ;
  int offset ;
  struct line *l ;
  char down ;
  char count ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  char tmp___4 ;
  char tmp___5 ;

  {
#line 34
  l = *(currentBuffer->currentLine);
#line 35
  down = (char)1;
#line 36
  count = (char)2;
#line 38
  if ((unsigned long )((currentBuffer->head)->next)->next == (unsigned long )currentBuffer->tail) {
#line 38
    if (((currentBuffer->head)->next)->length == 1U) {
#line 40
      return;
    }
  }
#line 43
  if (helpBarUpdate == 0) {
#line 43
    goto _L;
  } else {
    {
#line 43
    tmp___1 = strcmp((char const   *)(currentBuffer->searchString), "");
    }
#line 43
    if (tmp___1 == 0) {
      _L: /* CIL Label */ 
      {
#line 44
      displayBottomRow();
#line 45
      tmp = wmove(stdscr, maxY - 1, 0);
      }
#line 45
      if (! (tmp == -1)) {
        {
#line 45
        waddnstr(stdscr, "Search for what word?", -1);
        }
      }
      {
#line 46
      tmp___0 = wmove(stdscr, maxY - 1, 22);
      }
#line 46
      if (! (tmp___0 == -1)) {
        {
#line 46
        wgetnstr(stdscr, currentBuffer->searchString, -1);
        }
      }
    }
  }
#line 48
  if ((unsigned long )l == (unsigned long )(currentBuffer->tail)->prev) {
#line 48
    if (currentBuffer->cursor.offset >= l->length - 2U) {
#line 49
      l = (currentBuffer->head)->next;
#line 50
      offset = 0;
#line 51
      down = (char)0;
    } else {
#line 54
      offset = (int )(currentBuffer->cursor.offset + 1U);
    }
  } else {
#line 54
    offset = (int )(currentBuffer->cursor.offset + 1U);
  }
  {
#line 56
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 57
    tmp___2 = strstr((char const   *)(l->data + offset), (char const   *)(currentBuffer->searchString));
#line 57
    t = (unsigned char *)tmp___2;
    }
#line 58
    if ((unsigned long )t != (unsigned long )((void *)0)) {
#line 58
      goto while_break;
    }
#line 59
    offset = 0;
#line 60
    l = l->next;
#line 61
    if ((unsigned long )l == (unsigned long )(*(currentBuffer->currentLine))->next) {
#line 61
      count = (char )((int )count - 1);
    }
#line 62
    if ((unsigned long )l == (unsigned long )currentBuffer->tail) {
#line 63
      l = (currentBuffer->head)->next;
#line 64
      down = (char)0;
    }
#line 66
    if ((int )count == 0) {
#line 66
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 69
  if ((unsigned long )t == (unsigned long )((void *)0)) {
    {
#line 70
    displayBottomRow();
#line 71
    tmp___3 = wmove(stdscr, maxY - 1, 0);
    }
#line 71
    if (! (tmp___3 == -1)) {
      {
#line 71
      waddnstr(stdscr, "String not found.", -1);
      }
    }
    {
#line 72
    helpBarUpdate = 2;
#line 73
    strcpy((char */* __restrict  */)(currentBuffer->searchString), (char const   */* __restrict  */)"");
    }
#line 74
    return;
  }
#line 77
  offset = (int )(t - l->data);
#line 79
  if (down) {
    {
#line 80
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 80
      if (! ((unsigned long )currentBuffer->cursor.l != (unsigned long )l)) {
#line 80
        goto while_break___0;
      }
      {
#line 81
      moveDown(& currentBuffer->cursor);
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  } else {
    {
#line 84
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 84
      if (! ((unsigned long )currentBuffer->cursor.l != (unsigned long )l)) {
#line 84
        goto while_break___1;
      }
      {
#line 85
      moveUp(& currentBuffer->cursor);
      }
    }
    while_break___1: /* CIL Label */ ;
    }
  }
  {
#line 88
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 88
    if (! (currentBuffer->cursor.offset < (unsigned int )offset)) {
#line 88
      goto while_break___2;
    }
    {
#line 89
    tmp___4 = moveRight(& currentBuffer->cursor);
    }
#line 89
    if ((int )tmp___4 == 1) {
#line 89
      goto while_break___2;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 92
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 92
    if (! (currentBuffer->cursor.offset > (unsigned int )offset)) {
#line 92
      goto while_break___3;
    }
    {
#line 93
    tmp___5 = moveLeft(& currentBuffer->cursor);
    }
#line 93
    if ((int )tmp___5 == 1) {
#line 93
      goto while_break___3;
    }
  }
  while_break___3: /* CIL Label */ ;
  }
#line 96
  currentBuffer->lineUpdate = currentBuffer->topLine;
#line 97
  currentBuffer->lineUpdate.lineNum = 0U;
#line 98
  currentBuffer->keepGoing = (char)1;
#line 100
  helpBarUpdate = 2;
#line 101
  return;
}
}
#line 105 "/home/june/repo/benchmarks/collector/temp/dav-text-0.8.5/features.c"
static char replaceString[80]  ;
#line 106 "/home/june/repo/benchmarks/collector/temp/dav-text-0.8.5/features.c"
static char findString[80]  ;
#line 103 "/home/june/repo/benchmarks/collector/temp/dav-text-0.8.5/features.c"
void replace(void) 
{ 
  unsigned char *t ;
  int offset ;
  struct line *l ;
  char down ;
  char count ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  char tmp___7 ;
  char tmp___8 ;
  size_t tmp___9 ;
  size_t tmp___10 ;

  {
#line 109
  l = *(currentBuffer->currentLine);
#line 110
  down = (char)1;
#line 111
  count = (char)2;
#line 113
  if (helpBarUpdate == 0) {
#line 113
    goto _L;
  } else {
    {
#line 113
    tmp___3 = strcmp((char const   *)(findString), "");
    }
#line 113
    if (tmp___3) {
      {
#line 113
      tmp___4 = strcmp((char const   *)(replaceString), "");
      }
#line 113
      if (! tmp___4) {
        _L: /* CIL Label */ 
        {
#line 115
        displayBottomRow();
#line 116
        tmp = wmove(stdscr, maxY - 1, 0);
        }
#line 116
        if (! (tmp == -1)) {
          {
#line 116
          waddnstr(stdscr, "Replace what?", -1);
          }
        }
        {
#line 117
        tmp___0 = wmove(stdscr, maxY - 1, 14);
        }
#line 117
        if (! (tmp___0 == -1)) {
          {
#line 117
          wgetnstr(stdscr, findString, -1);
          }
        }
        {
#line 118
        displayBottomRow();
#line 119
        tmp___1 = wmove(stdscr, maxY - 1, 0);
        }
#line 119
        if (! (tmp___1 == -1)) {
          {
#line 119
          waddnstr(stdscr, "Replace with what?", -1);
          }
        }
        {
#line 120
        tmp___2 = wmove(stdscr, maxY - 1, 19);
        }
#line 120
        if (! (tmp___2 == -1)) {
          {
#line 120
          wgetnstr(stdscr, replaceString, -1);
          }
        }
      }
    } else {
#line 113
      goto _L;
    }
  }
#line 122
  offset = (int )(currentBuffer->cursor.offset + 1U);
  {
#line 123
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 125
    tmp___5 = strstr((char const   *)(l->data + offset), (char const   *)(findString));
#line 125
    t = (unsigned char *)tmp___5;
    }
#line 126
    if ((unsigned long )t != (unsigned long )((void *)0)) {
#line 126
      goto while_break;
    }
#line 127
    offset = 0;
#line 128
    l = l->next;
#line 129
    if ((unsigned long )l == (unsigned long )(*(currentBuffer->currentLine))->next) {
#line 129
      count = (char )((int )count - 1);
    }
#line 130
    if ((unsigned long )l == (unsigned long )currentBuffer->tail) {
#line 130
      l = (currentBuffer->head)->next;
#line 130
      down = (char)0;
    }
#line 131
    if ((int )count == 0) {
#line 131
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 134
  if ((unsigned long )t == (unsigned long )((void *)0)) {
    {
#line 136
    displayBottomRow();
#line 137
    tmp___6 = wmove(stdscr, maxY - 1, 0);
    }
#line 137
    if (! (tmp___6 == -1)) {
      {
#line 137
      waddnstr(stdscr, "String not found.", -1);
      }
    }
    {
#line 138
    helpBarUpdate = 2;
#line 139
    strcpy((char */* __restrict  */)(findString), (char const   */* __restrict  */)"");
    }
#line 140
    return;
  }
#line 143
  offset = (int )(t - l->data);
#line 145
  if (down) {
    {
#line 146
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 146
      if (! ((unsigned long )currentBuffer->cursor.l != (unsigned long )l)) {
#line 146
        goto while_break___0;
      }
      {
#line 147
      moveDown(& currentBuffer->cursor);
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  } else {
    {
#line 150
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 150
      if (! ((unsigned long )currentBuffer->cursor.l != (unsigned long )l)) {
#line 150
        goto while_break___1;
      }
      {
#line 151
      moveUp(& currentBuffer->cursor);
      }
    }
    while_break___1: /* CIL Label */ ;
    }
  }
  {
#line 154
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 154
    if (! (currentBuffer->cursor.offset < (unsigned int )offset)) {
#line 154
      goto while_break___2;
    }
    {
#line 155
    tmp___7 = moveRight(& currentBuffer->cursor);
    }
#line 155
    if ((int )tmp___7 == 1) {
#line 155
      goto while_break___2;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 158
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 158
    if (! (currentBuffer->cursor.offset > (unsigned int )offset)) {
#line 158
      goto while_break___3;
    }
    {
#line 159
    tmp___8 = moveLeft(& currentBuffer->cursor);
    }
#line 159
    if ((int )tmp___8 == 1) {
#line 159
      goto while_break___3;
    }
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 163
  tmp___9 = strlen((char const   *)(findString));
#line 163
  offset = (int )tmp___9;
  }
  {
#line 163
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 163
    if (! offset) {
#line 163
      goto while_break___4;
    }
    {
#line 164
    keyHit(330, (char)0);
#line 163
    offset --;
    }
  }
  while_break___4: /* CIL Label */ ;
  }
#line 167
  offset = 0;
  {
#line 167
  while (1) {
    while_continue___5: /* CIL Label */ ;
    {
#line 167
    tmp___10 = strlen((char const   *)(replaceString));
    }
#line 167
    if (! ((size_t )offset < tmp___10)) {
#line 167
      goto while_break___5;
    }
    {
#line 168
    keyHit((int )replaceString[offset], (char)0);
#line 167
    offset ++;
    }
  }
  while_break___5: /* CIL Label */ ;
  }
#line 170
  currentBuffer->lineUpdate = currentBuffer->topLine;
#line 171
  currentBuffer->lineUpdate.lineNum = 0U;
#line 172
  currentBuffer->keepGoing = (char)1;
#line 174
  helpBarUpdate = 2;
#line 175
  return;
}
}
#line 177 "/home/june/repo/benchmarks/collector/temp/dav-text-0.8.5/features.c"
void tryCompile(void) 
{ 
  FILE *fp ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 180
  displayBottomRow();
#line 181
  tmp = wmove(stdscr, maxY - 1, 0);
  }
#line 181
  if (! (tmp == -1)) {
    {
#line 181
    waddnstr(stdscr, "Running Makefile...", -1);
    }
  }
  {
#line 182
  ungetch(' ');
#line 183
  wgetch(stdscr);
#line 184
  tmp___0 = strcmp((char const   *)(currentBuffer->fname), "");
  }
#line 184
  if (tmp___0) {
    {
#line 184
    save();
    }
  }
  {
#line 185
  system("make 2>dav.err >/dev/null");
#line 186
  fp = fopen((char const   */* __restrict  */)"dav.err", (char const   */* __restrict  */)"r");
#line 187
  fgetc(fp);
#line 188
  tmp___2 = feof(fp);
  }
#line 188
  if (tmp___2) {
    {
#line 190
    displayBottomRow();
#line 191
    tmp___1 = wmove(stdscr, maxY - 1, 0);
    }
#line 191
    if (! (tmp___1 == -1)) {
      {
#line 191
      waddnstr(stdscr, "Compile successful.", -1);
      }
    }
#line 192
    helpBarUpdate = 2;
  } else {
    {
#line 196
    displayBottomRow();
    }
    {
#line 197
    while (1) {
      while_continue: /* CIL Label */ ;
#line 197
      if (! ((unsigned long )((currentBuffer->head)->next)->next != (unsigned long )currentBuffer->tail)) {
#line 197
        if (! (((currentBuffer->head)->next)->length != 1U)) {
#line 197
          goto while_break;
        }
      }
      {
#line 198
      goToNextBuffer();
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 199
    load((char *)"dav.err");
#line 200
    currentBuffer->lineUpdate = currentBuffer->cursor;
#line 201
    currentBuffer->lineUpdate.lineNum = 0U;
#line 202
    currentBuffer->keepGoing = (char)1;
#line 203
    helpBarUpdate = 1;
    }
  }
  {
#line 205
  fclose(fp);
#line 206
  system("rm dav.err");
  }
#line 207
  return;
}
}
#line 209 "/home/june/repo/benchmarks/collector/temp/dav-text-0.8.5/features.c"
void gotoLine(int line ) 
{ 
  char tmp ;
  char tmp___0 ;

  {
  {
#line 211
  while (1) {
    while_continue: /* CIL Label */ ;
#line 211
    if (! (currentBuffer->cursor.lineNum < (unsigned int )(line - 1))) {
#line 211
      goto while_break;
    }
    {
#line 212
    tmp = scrollDown();
    }
#line 212
    if (tmp) {
#line 213
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 217
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 217
    if (! (currentBuffer->cursor.lineNum < (unsigned int )(line - 1))) {
#line 217
      goto while_break___0;
    }
    {
#line 218
    tmp___0 = positionDown(& currentBuffer->cursor);
    }
#line 218
    if (tmp___0) {
#line 219
      goto while_break___0;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 223
  currentBuffer->lineUpdate = currentBuffer->topLine;
#line 224
  currentBuffer->lineUpdate.lineNum = 0U;
#line 225
  currentBuffer->keepGoing = (char)1;
#line 226
  displayScreen();
  }
#line 227
  return;
}
}
#line 229 "/home/june/repo/benchmarks/collector/temp/dav-text-0.8.5/features.c"
void toggleAutoIndent(void) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  {
#line 231
  currentBuffer->lineUpdate.offset = 4294967295U;
#line 232
  autoIndent = (char )(! autoIndent);
#line 233
  displayBottomRow();
#line 234
  tmp = wmove(stdscr, maxY - 1, 0);
  }
#line 234
  if (! (tmp == -1)) {
    {
#line 234
    waddnstr(stdscr, "Auto indenting set to", -1);
    }
  }
  {
#line 235
  tmp___0 = wmove(stdscr, maxY - 1, 22);
  }
#line 235
  if (! (tmp___0 == -1)) {
    {
#line 235
    waddch(stdscr, (chtype const   )((int )autoIndent + 48));
    }
  }
#line 236
  helpBarUpdate = 2;
#line 237
  return;
}
}
#line 239 "/home/june/repo/benchmarks/collector/temp/dav-text-0.8.5/features.c"
void toggleBottomRow(void) 
{ 


  {
  {
#line 241
  bottomRowToggle = (char )(! bottomRowToggle);
#line 242
  helpBar();
#line 243
  currentBuffer->lineUpdate.offset = 4294967295U;
  }
#line 244
  return;
}
}
#line 24 "/home/june/repo/benchmarks/collector/temp/dav-text-0.8.5/buffers.h"
void goToPrevBuffer(void) ;
#line 25
void closeBuffer(void) ;
#line 22 "/home/june/repo/benchmarks/collector/temp/dav-text-0.8.5/buffers.c"
int numberOfBuffers ;
#line 26
struct buffer *buffers ;
#line 28
int currentBufferNum ;
#line 31
void quit(char *text ) ;
#line 33 "/home/june/repo/benchmarks/collector/temp/dav-text-0.8.5/buffers.c"
void goToNextBuffer(void) 
{ 


  {
#line 35
  currentBufferNum ++;
#line 36
  if (currentBufferNum == numberOfBuffers) {
#line 36
    currentBufferNum = 0;
  }
#line 37
  currentBuffer = buffers + currentBufferNum;
#line 38
  currentBuffer->lineUpdate = currentBuffer->topLine;
#line 39
  currentBuffer->lineUpdate.lineNum = 0U;
#line 40
  currentBuffer->keepGoing = (char)1;
#line 41
  helpBarUpdate = 1;
#line 42
  return;
}
}
#line 44 "/home/june/repo/benchmarks/collector/temp/dav-text-0.8.5/buffers.c"
void goToPrevBuffer(void) 
{ 


  {
#line 46
  currentBufferNum --;
#line 47
  if (currentBufferNum == -1) {
#line 47
    currentBufferNum = numberOfBuffers - 1;
  }
#line 48
  currentBuffer = buffers + currentBufferNum;
#line 49
  currentBuffer->lineUpdate = currentBuffer->topLine;
#line 50
  currentBuffer->lineUpdate.lineNum = 0U;
#line 51
  currentBuffer->keepGoing = (char)1;
#line 52
  helpBarUpdate = 1;
#line 53
  return;
}
}
#line 55 "/home/june/repo/benchmarks/collector/temp/dav-text-0.8.5/buffers.c"
void closeBuffer(void) 
{ 
  struct buffer *b ;
  char tempSmartCursor ;
  int tmp ;

  {
#line 57
  b = currentBuffer;
#line 58
  tempSmartCursor = smartCursor;
#line 59
  smartCursor = (char)0;
  {
#line 62
  while (1) {
    while_continue: /* CIL Label */ ;
#line 62
    if (! ((unsigned long )currentBuffer->cursor.l != (unsigned long )(currentBuffer->head)->next)) {
#line 62
      if (! (currentBuffer->cursor.offset != 0U)) {
#line 62
        goto while_break;
      }
    }
    {
#line 63
    keyHit(259, (char)0);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 66
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 66
    if (! currentBuffer->numLines) {
#line 66
      goto while_break___0;
    }
    {
#line 67
    keyHit(21, (char)0);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 68
  keyHit(21, (char)0);
#line 70
  currentBuffer->updated = (char)0;
#line 71
  strcpy((char */* __restrict  */)(currentBuffer->fname), (char const   */* __restrict  */)"");
  }
  {
#line 73
  while (1) {
    while_continue___1: /* CIL Label */ ;
    {
#line 73
    tmp = strcmp((char const   *)(currentBuffer->fname), "");
    }
#line 73
    if (tmp == 0) {
#line 73
      if (! (! currentBuffer->updated)) {
#line 73
        goto while_break___1;
      }
    } else {
#line 73
      goto while_break___1;
    }
    {
#line 74
    goToPrevBuffer();
    }
#line 75
    if ((unsigned long )currentBuffer == (unsigned long )b) {
      {
#line 75
      quit((char *)"");
      }
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 77
  smartCursor = tempSmartCursor;
#line 80
  displayScreen();
  }
#line 81
  return;
}
}
#line 22 "/home/june/repo/benchmarks/collector/temp/dav-text-0.8.5/undo.h"
void addToUndo(int keypress ) ;
#line 23
void Undo(void) ;
#line 55 "/home/june/repo/benchmarks/collector/temp/dav-text-0.8.5/main.h"
int maxUndoLength ;
#line 56
char undoEnabled ;
#line 23 "/home/june/repo/benchmarks/collector/temp/dav-text-0.8.5/undo.c"
void Do(int keypress ) 
{ 


  {
  {
#line 27
  if (keypress == 0) {
#line 27
    goto case_0;
  }
#line 31
  if (keypress == 1) {
#line 31
    goto case_1;
  }
#line 35
  goto switch_default;
  case_0: /* CIL Label */ 
  {
#line 28
  addToUndo((int )*((currentBuffer->cursor.l)->data + currentBuffer->cursor.offset));
  }
#line 29
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 32
  addToUndo(0);
  }
#line 33
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 36
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 38
  return;
}
}
#line 40 "/home/june/repo/benchmarks/collector/temp/dav-text-0.8.5/undo.c"
void addToUndo(int keypress ) 
{ 


  {
#line 42
  (currentBuffer->undoMoves + currentBuffer->undoBufferPointer)->c = (char )keypress;
#line 43
  (currentBuffer->undoMoves + currentBuffer->undoBufferPointer)->line = currentBuffer->cursor.lineNum;
#line 44
  (currentBuffer->undoMoves + currentBuffer->undoBufferPointer)->offset = currentBuffer->cursor.offset;
#line 45
  (currentBuffer->undoBufferPointer) ++;
#line 46
  currentBuffer->undoBufferPointer %= maxUndoLength;
#line 47
  (currentBuffer->undoBufferLength) ++;
#line 47
  if (currentBuffer->undoBufferLength > maxUndoLength) {
#line 47
    (currentBuffer->undoBufferLength) --;
  }
#line 48
  return;
}
}
#line 50 "/home/june/repo/benchmarks/collector/temp/dav-text-0.8.5/undo.c"
void Undo(void) 
{ 
  int key ;

  {
#line 53
  if (! undoEnabled) {
#line 53
    return;
  }
#line 54
  if (currentBuffer->undoBufferLength == 0) {
#line 54
    return;
  }
#line 55
  (currentBuffer->undoBufferLength) --;
#line 56
  (currentBuffer->undoBufferPointer) --;
#line 56
  if (currentBuffer->undoBufferPointer == -1) {
#line 56
    currentBuffer->undoBufferPointer = maxUndoLength - 1;
  }
#line 57
  key = (int )(currentBuffer->undoMoves + currentBuffer->undoBufferPointer)->c;
  {
#line 58
  while (1) {
    while_continue: /* CIL Label */ ;
#line 58
    if (! (currentBuffer->cursor.lineNum > (currentBuffer->undoMoves + currentBuffer->undoBufferPointer)->line)) {
#line 58
      goto while_break;
    }
    {
#line 59
    moveUp(& currentBuffer->cursor);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 60
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 60
    if (! (currentBuffer->cursor.lineNum < (currentBuffer->undoMoves + currentBuffer->undoBufferPointer)->line)) {
#line 60
      goto while_break___0;
    }
    {
#line 61
    moveDown(& currentBuffer->cursor);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 62
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 62
    if (! (currentBuffer->cursor.offset < (currentBuffer->undoMoves + currentBuffer->undoBufferPointer)->offset)) {
#line 62
      goto while_break___1;
    }
    {
#line 63
    moveRight(& currentBuffer->cursor);
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 64
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 64
    if (! (currentBuffer->cursor.offset > (currentBuffer->undoMoves + currentBuffer->undoBufferPointer)->offset)) {
#line 64
      goto while_break___2;
    }
    {
#line 65
    moveLeft(& currentBuffer->cursor);
    }
  }
  while_break___2: /* CIL Label */ ;
  }
#line 67
  if (key == 10) {
#line 67
    key = 13;
  }
#line 68
  if (key == 0) {
#line 68
    key = 330;
  }
  {
#line 69
  keyHit(key, (char)0);
#line 70
  currentBuffer->lineUpdate = currentBuffer->topLine;
#line 71
  currentBuffer->lineUpdate.lineNum = 0U;
#line 72
  currentBuffer->keepGoing = (char)1;
  }
#line 73
  return;
}
}
#line 24 "/home/june/repo/benchmarks/collector/temp/dav-text-0.8.5/move.h"
char positionUp(struct position *p ) ;
#line 21 "/home/june/repo/benchmarks/collector/temp/dav-text-0.8.5/move.c"
void moveDown(struct position *p ) 
{ 


  {
  {
#line 22
  positionDown(p);
  }
#line 23
  if (p->cursY == (unsigned int )(maxY - 1)) {
#line 23
    if ((unsigned long )p == (unsigned long )(& currentBuffer->cursor)) {
      {
#line 24
      scrollDown();
      }
    }
  }
#line 26
  return;
}
}
#line 28 "/home/june/repo/benchmarks/collector/temp/dav-text-0.8.5/move.c"
void moveUp(struct position *p ) 
{ 


  {
  {
#line 29
  positionUp(p);
  }
#line 30
  if (p->cursY == 4294967295U) {
#line 30
    if ((unsigned long )p == (unsigned long )(& currentBuffer->cursor)) {
      {
#line 31
      scrollUp();
      }
    }
  }
#line 33
  return;
}
}
#line 35 "/home/june/repo/benchmarks/collector/temp/dav-text-0.8.5/move.c"
char moveLeft(struct position *p ) 
{ 
  char r ;

  {
#line 43
  r = (char)0;
#line 44
  if ((unsigned long )p->l == (unsigned long )(currentBuffer->head)->next) {
#line 44
    if (p->offset == 0U) {
#line 46
      return ((char)1);
    }
  }
#line 48
  if (! p->offset) {
#line 50
    p->l = (p->l)->prev;
#line 51
    p->offset = (p->l)->length - 1U;
#line 52
    if ((p->l)->hasTabs) {
      {
#line 53
      determineCursX(p);
      }
    } else {
#line 56
      p->cursX = p->offset % (unsigned int )maxX;
    }
#line 58
    (p->cursY) --;
#line 59
    (p->lineNum) --;
#line 60
    r = (char)2;
  } else {
#line 63
    (p->offset) --;
#line 64
    if (! p->cursX) {
#line 65
      r = (char)3;
#line 66
      (p->cursY) --;
#line 67
      if ((p->l)->hasTabs) {
        {
#line 68
        determineCursX(p);
        }
      } else {
#line 71
        p->cursX = (unsigned int )(maxX - 1);
      }
    } else
#line 75
    if ((p->l)->hasTabs) {
      {
#line 76
      determineCursX(p);
      }
    } else {
#line 78
      (p->cursX) --;
    }
  }
#line 82
  if (p->cursY == 4294967295U) {
#line 82
    if ((unsigned long )p == (unsigned long )(& currentBuffer->cursor)) {
      {
#line 83
      scrollUp();
      }
    }
  }
#line 85
  return (r);
}
}
#line 88 "/home/june/repo/benchmarks/collector/temp/dav-text-0.8.5/move.c"
char moveRight(struct position *p ) 
{ 
  char r ;
  int temp ;
  unsigned int tmp ;

  {
#line 96
  r = (char)0;
#line 97
  if ((unsigned long )(p->l)->next == (unsigned long )currentBuffer->tail) {
#line 97
    if (p->offset == (p->l)->length - 1U) {
#line 99
      return ((char)1);
    }
  }
#line 102
  if (p->offset < (p->l)->length - 1U) {
#line 104
    temp = (int )p->cursX;
#line 105
    (p->offset) ++;
#line 106
    if ((p->l)->hasTabs) {
      {
#line 107
      determineCursX(p);
      }
    } else {
#line 109
      (p->cursX) ++;
#line 110
      if (p->cursX == (unsigned int )maxX) {
#line 111
        p->cursX = 0U;
      }
    }
#line 114
    if (p->cursX < (unsigned int )temp) {
#line 115
      (p->cursY) ++;
#line 116
      r = (char)3;
    }
  } else {
#line 121
    p->l = (p->l)->next;
#line 122
    tmp = 0U;
#line 122
    p->offset = tmp;
#line 122
    p->cursX = tmp;
#line 123
    (p->cursY) ++;
#line 124
    (p->lineNum) ++;
#line 125
    r = (char)2;
  }
#line 127
  if (p->cursY == (unsigned int )(maxY - 1)) {
#line 127
    if ((unsigned long )p == (unsigned long )(& currentBuffer->cursor)) {
      {
#line 128
      scrollDown();
      }
    }
  }
#line 130
  return (r);
}
}
#line 133 "/home/june/repo/benchmarks/collector/temp/dav-text-0.8.5/move.c"
char scrollDown(void) 
{ 
  char tmp ;

  {
#line 137
  if (currentBuffer->topLine.lineNum + (unsigned int )(maxY >> 1) > (unsigned int )currentBuffer->numLines) {
#line 138
    return ((char)1);
  }
#line 141
  if (currentBuffer->cursor.cursY == 0U) {
    {
#line 142
    positionDown(& currentBuffer->cursor);
    }
  }
  {
#line 145
  tmp = positionDown(& currentBuffer->topLine);
  }
#line 145
  if (! tmp) {
#line 146
    (currentBuffer->cursor.cursY) --;
  }
#line 149
  currentBuffer->lineUpdate = currentBuffer->topLine;
#line 150
  currentBuffer->lineUpdate.lineNum = 0U;
#line 151
  currentBuffer->keepGoing = (char)1;
#line 152
  return ((char)0);
}
}
#line 155 "/home/june/repo/benchmarks/collector/temp/dav-text-0.8.5/move.c"
char scrollUp(void) 
{ 
  char tmp ;

  {
#line 158
  if (currentBuffer->cursor.cursY == (unsigned int )(maxY - 1)) {
    {
#line 159
    positionUp(& currentBuffer->cursor);
    }
  }
  {
#line 162
  tmp = positionUp(& currentBuffer->topLine);
  }
#line 162
  if (! tmp) {
#line 163
    (currentBuffer->cursor.cursY) ++;
  }
#line 166
  currentBuffer->lineUpdate = currentBuffer->topLine;
#line 167
  currentBuffer->lineUpdate.lineNum = 0U;
#line 168
  currentBuffer->keepGoing = (char)1;
#line 169
  return ((char)0);
}
}
#line 137 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcat)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 24 "/home/june/repo/benchmarks/collector/temp/dav-text-0.8.5/screenIO.h"
void showRow(void) ;
#line 27
void displayLine(int line , struct position *pos ) ;
#line 34 "/home/june/repo/benchmarks/collector/temp/dav-text-0.8.5/main.h"
void tryQuit(void) ;
#line 35
void nothing(void) ;
#line 23 "/home/june/repo/benchmarks/collector/temp/dav-text-0.8.5/fileIO.h"
void saveAs(void) ;
#line 25
void askLoad(void) ;
#line 29 "/home/june/repo/benchmarks/collector/temp/dav-text-0.8.5/screenIO.c"
void displayLine(int line , struct position *pos ) 
{ 
  int ch ;
  unsigned char *data ;
  int length ;
  unsigned char *end ;
  int screenX ;
  unsigned char *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 31
  data = (pos->l)->data + pos->offset;
#line 32
  length = (int )(pos->l)->length;
#line 33
  end = (pos->l)->data + length;
#line 34
  screenX = 0;
#line 36
  if ((unsigned long )pos->l != (unsigned long )currentBuffer->tail) {
    {
#line 37
    while (1) {
      while_continue: /* CIL Label */ ;
#line 38
      tmp = data;
#line 38
      data ++;
#line 38
      ch = (int )*tmp;
#line 39
      if (ch == 9) {
        {
#line 41
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 41
          if (! (screenX % (int )tabWidth != (int )tabWidth - 1)) {
#line 41
            goto while_break___0;
          }
          {
#line 42
          tmp___0 = screenX;
#line 42
          screenX ++;
#line 42
          tmp___1 = wmove(stdscr, line, tmp___0);
          }
#line 42
          if (! (tmp___1 == -1)) {
            {
#line 42
            waddch(stdscr, (chtype const   )' ');
            }
          }
        }
        while_break___0: /* CIL Label */ ;
        }
      }
      {
#line 45
      tmp___2 = wmove(stdscr, line, screenX);
      }
#line 45
      if (! (tmp___2 == -1)) {
        {
#line 45
        waddch(stdscr, (chtype const   )ch);
        }
      }
#line 46
      tmp___3 = screenX;
#line 46
      screenX ++;
#line 46
      if (tmp___3 >= maxX) {
#line 47
        screenX --;
#line 48
        goto while_break;
      } else
#line 46
      if ((unsigned long )data == (unsigned long )end) {
#line 47
        screenX --;
#line 48
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 53
  length = *(lastDisplayed + line);
#line 54
  *(lastDisplayed + line) = screenX;
  {
#line 55
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 55
    if (! (screenX < length)) {
#line 55
      goto while_break___1;
    }
    {
#line 56
    tmp___4 = screenX;
#line 56
    screenX ++;
#line 56
    tmp___5 = wmove(stdscr, line, tmp___4);
    }
#line 56
    if (! (tmp___5 == -1)) {
      {
#line 56
      waddch(stdscr, (chtype const   )' ');
      }
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 59
  return;
}
}
#line 61 "/home/june/repo/benchmarks/collector/temp/dav-text-0.8.5/screenIO.c"
void displayScreen(void) 
{ 
  int lineNum ;
  int i ;
  int tmp ;
  char tmp___0 ;
  char tmp___1 ;

  {
#line 62
  lineNum = (int )currentBuffer->lineUpdate.lineNum;
#line 64
  if (currentBuffer->lineUpdate.offset == 4294967295U) {
#line 65
    return;
  }
#line 68
  if (displayWholeScreen) {
#line 70
    i = 0;
    {
#line 70
    while (1) {
      while_continue: /* CIL Label */ ;
#line 70
      if (! (i < maxY)) {
#line 70
        goto while_break;
      }
#line 71
      *(lastDisplayed + i) = maxX;
#line 70
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 73
    displayWholeScreen = (char)0;
  }
  {
#line 76
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 76
    if (! currentBuffer->lineUpdate.cursX) {
#line 76
      goto while_break___0;
    }
    {
#line 77
    moveLeft(& currentBuffer->lineUpdate);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 80
  while (1) {
    while_continue___1: /* CIL Label */ ;
    {
#line 81
    tmp = lineNum;
#line 81
    lineNum ++;
#line 81
    displayLine(tmp, & currentBuffer->lineUpdate);
#line 80
    tmp___0 = positionDown(& currentBuffer->lineUpdate);
    }
#line 80
    if (tmp___0) {
#line 80
      goto while_break___1;
    } else
#line 80
    if (! (currentBuffer->lineUpdate.cursY < (unsigned int )(maxY - 1))) {
#line 80
      goto while_break___1;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 84
  if (currentBuffer->keepGoing) {
    {
#line 85
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 85
      if (! (lineNum < maxY - 1)) {
#line 85
        goto while_break___2;
      }
      {
#line 86
      displayLine(lineNum, & currentBuffer->lineUpdate);
#line 87
      tmp___1 = positionDown(& currentBuffer->lineUpdate);
      }
#line 87
      if ((int )tmp___1 == 1) {
#line 88
        currentBuffer->lineUpdate.l = currentBuffer->tail;
      }
#line 90
      lineNum ++;
    }
    while_break___2: /* CIL Label */ ;
    }
  }
#line 94
  currentBuffer->keepGoing = (char)0;
#line 95
  return;
}
}
#line 97 "/home/june/repo/benchmarks/collector/temp/dav-text-0.8.5/screenIO.c"
void showRow(void) 
{ 
  char num[5] ;
  char total[5] ;
  int t ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 101
  num[0] = (char )(((currentBuffer->cursor.lineNum + 1U) / 10000U) % 10U + 48U);
#line 102
  num[1] = (char )(((currentBuffer->cursor.lineNum + 1U) / 1000U) % 10U + 48U);
#line 103
  num[2] = (char )(((currentBuffer->cursor.lineNum + 1U) / 100U) % 10U + 48U);
#line 104
  num[3] = (char )(((currentBuffer->cursor.lineNum + 1U) / 10U) % 10U + 48U);
#line 105
  num[4] = (char )((currentBuffer->cursor.lineNum + 1U) % 10U + 48U);
#line 107
  total[0] = (char )(((currentBuffer->numLines + 1) / 10000) % 10 + 48);
#line 108
  total[1] = (char )(((currentBuffer->numLines + 1) / 1000) % 10 + 48);
#line 109
  total[2] = (char )(((currentBuffer->numLines + 1) / 100) % 10 + 48);
#line 110
  total[3] = (char )(((currentBuffer->numLines + 1) / 10) % 10 + 48);
#line 111
  total[4] = (char )((currentBuffer->numLines + 1) % 10 + 48);
#line 112
  t = 0;
  {
#line 112
  while (1) {
    while_continue: /* CIL Label */ ;
#line 112
    if (! (t < 4)) {
#line 112
      goto while_break;
    }
#line 113
    if ((int )num[t] == 48) {
#line 114
      num[t] = (char )' ';
    } else {
#line 116
      goto while_break;
    }
#line 112
    t ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 119
  t = 0;
  {
#line 119
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 119
    if (! (t < 4)) {
#line 119
      goto while_break___0;
    }
#line 120
    if ((int )total[t] == 48) {
#line 121
      total[t] = (char )' ';
    } else {
#line 123
      goto while_break___0;
    }
#line 119
    t ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 126
  tmp = wmove(stdscr, maxY - 1, maxX - 11);
  }
#line 126
  if (! (tmp == -1)) {
    {
#line 126
    waddnstr(stdscr, (char const   *)(num), -1);
    }
  }
  {
#line 127
  tmp___0 = wmove(stdscr, maxY - 1, maxX - 6);
  }
#line 127
  if (! (tmp___0 == -1)) {
    {
#line 127
    waddch(stdscr, (chtype const   )'/');
    }
  }
  {
#line 128
  tmp___1 = wmove(stdscr, maxY - 1, maxX - 5);
  }
#line 128
  if (! (tmp___1 == -1)) {
    {
#line 128
    waddnstr(stdscr, (char const   *)(total), -1);
    }
  }
#line 129
  return;
}
}
#line 131 "/home/june/repo/benchmarks/collector/temp/dav-text-0.8.5/screenIO.c"
void helpBar(void) 
{ 
  char c[200] ;
  char *ptr ;
  int t ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  char temp[3] ;
  int tmp___5 ;

  {
  {
#line 133
  ptr = c;
#line 135
  displayBottomRow();
  }
#line 137
  if (bottomRowToggle) {
    {
#line 138
    strcpy((char */* __restrict  */)ptr, (char const   */* __restrict  */)"F|");
#line 139
    ptr += 2;
#line 140
    t = 0;
    }
    {
#line 140
    while (1) {
      while_continue: /* CIL Label */ ;
#line 140
      if (! (t < 12)) {
#line 140
        goto while_break;
      }
#line 142
      if (t <= 8) {
#line 143
        tmp = ptr;
#line 143
        ptr ++;
#line 143
        *tmp = (char )(t + 49);
      } else {
#line 146
        tmp___0 = ptr;
#line 146
        ptr ++;
#line 146
        *tmp___0 = (char )'1';
#line 147
        tmp___1 = ptr;
#line 147
        ptr ++;
#line 147
        *tmp___1 = (char )((t + 49) - 10);
      }
#line 149
      tmp___2 = ptr;
#line 149
      ptr ++;
#line 149
      *tmp___2 = (char )':';
#line 150
      if ((unsigned long )Fn_ptr[t] == (unsigned long )(& search)) {
        {
#line 151
        strcpy((char */* __restrict  */)ptr, (char const   */* __restrict  */)"Search");
#line 152
        ptr += 6;
        }
      } else
#line 153
      if ((unsigned long )Fn_ptr[t] == (unsigned long )(& save)) {
        {
#line 154
        strcpy((char */* __restrict  */)ptr, (char const   */* __restrict  */)"Save");
#line 155
        ptr += 4;
        }
      } else
#line 156
      if ((unsigned long )Fn_ptr[t] == (unsigned long )(& saveAs)) {
        {
#line 157
        strcpy((char */* __restrict  */)ptr, (char const   */* __restrict  */)"SaveAs");
#line 158
        ptr += 6;
        }
      } else
#line 159
      if ((unsigned long )Fn_ptr[t] == (unsigned long )(& askLoad)) {
        {
#line 160
        strcpy((char */* __restrict  */)ptr, (char const   */* __restrict  */)"Load");
#line 161
        ptr += 4;
        }
      } else
#line 162
      if ((unsigned long )Fn_ptr[t] == (unsigned long )(& tryQuit)) {
        {
#line 163
        strcpy((char */* __restrict  */)ptr, (char const   */* __restrict  */)"Quit");
#line 164
        ptr += 4;
        }
      } else
#line 165
      if ((unsigned long )Fn_ptr[t] == (unsigned long )(& Undo)) {
        {
#line 166
        strcpy((char */* __restrict  */)ptr, (char const   */* __restrict  */)"Undo");
#line 167
        ptr += 4;
        }
      } else
#line 168
      if ((unsigned long )Fn_ptr[t] == (unsigned long )(& tryCompile)) {
        {
#line 169
        strcpy((char */* __restrict  */)ptr, (char const   */* __restrict  */)"Compile");
#line 170
        ptr += 7;
        }
      } else
#line 171
      if ((unsigned long )Fn_ptr[t] == (unsigned long )(& toggleAutoIndent)) {
        {
#line 172
        strcpy((char */* __restrict  */)ptr, (char const   */* __restrict  */)"AutoIndent");
#line 173
        ptr += 10;
        }
      } else
#line 174
      if ((unsigned long )Fn_ptr[t] == (unsigned long )(& toggleBottomRow)) {
        {
#line 175
        strcpy((char */* __restrict  */)ptr, (char const   */* __restrict  */)"BottomRow");
#line 176
        ptr += 9;
        }
      } else
#line 177
      if ((unsigned long )Fn_ptr[t] == (unsigned long )(& replace)) {
        {
#line 178
        strcpy((char */* __restrict  */)ptr, (char const   */* __restrict  */)"Replace");
#line 179
        ptr += 7;
        }
      } else
#line 180
      if ((unsigned long )Fn_ptr[t] == (unsigned long )(& goToNextBuffer)) {
        {
#line 181
        strcpy((char */* __restrict  */)ptr, (char const   */* __restrict  */)"Next");
#line 182
        ptr += 4;
        }
      } else
#line 183
      if ((unsigned long )Fn_ptr[t] == (unsigned long )(& goToPrevBuffer)) {
        {
#line 184
        strcpy((char */* __restrict  */)ptr, (char const   */* __restrict  */)"Prev");
#line 185
        ptr += 4;
        }
      } else
#line 186
      if ((unsigned long )Fn_ptr[t] == (unsigned long )(& nothing)) {
#line 187
        ptr -= 3;
      }
#line 189
      tmp___3 = ptr;
#line 189
      ptr ++;
#line 189
      *tmp___3 = (char )'|';
#line 140
      t ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 191
    *ptr = (char )'\000';
#line 192
    tmp___4 = wmove(stdscr, maxY - 1, 0);
    }
#line 192
    if (! (tmp___4 == -1)) {
      {
#line 192
      waddnstr(stdscr, (char const   *)(c), maxX - 1);
      }
    }
  } else {
    {
#line 195
    temp[0] = (char )(currentBufferNum / 10 + 48);
#line 196
    temp[1] = (char )(currentBufferNum % 10 + 48);
#line 197
    temp[2] = (char )'\000';
#line 198
    strcpy((char */* __restrict  */)(c), (char const   */* __restrict  */)"Editing ");
#line 199
    strcat((char */* __restrict  */)(c), (char const   */* __restrict  */)(currentBuffer->fname));
#line 200
    strcat((char */* __restrict  */)(c), (char const   */* __restrict  */)" [");
    }
#line 201
    if (currentBufferNum >= 10) {
      {
#line 202
      strcat((char */* __restrict  */)(c), (char const   */* __restrict  */)(temp));
      }
    } else {
      {
#line 204
      strcat((char */* __restrict  */)(c), (char const   */* __restrict  */)(temp + 1));
      }
    }
    {
#line 206
    strcat((char */* __restrict  */)(c), (char const   */* __restrict  */)"]");
#line 207
    tmp___5 = wmove(stdscr, maxY - 1, 0);
    }
#line 207
    if (! (tmp___5 == -1)) {
      {
#line 207
      waddnstr(stdscr, (char const   *)(c), -1);
      }
    }
  }
  {
#line 209
  showRow();
  }
#line 210
  return;
}
}
#line 212 "/home/june/repo/benchmarks/collector/temp/dav-text-0.8.5/screenIO.c"
void displayBottomRow(void) 
{ 
  int x ;
  int tmp ;

  {
#line 214
  x = maxX - 12;
  {
#line 214
  while (1) {
    while_continue: /* CIL Label */ ;
#line 214
    if (! x) {
#line 214
      goto while_break;
    }
    {
#line 215
    tmp = wmove(stdscr, maxY - 1, x);
    }
#line 215
    if (! (tmp == -1)) {
      {
#line 215
      waddch(stdscr, (chtype const   )' ');
      }
    }
#line 214
    x --;
  }
  while_break: /* CIL Label */ ;
  }
#line 217
  return;
}
}
#line 434 "/usr/include/libio.h"
extern int _IO_getc(_IO_FILE *__fp ) ;
#line 435
extern int _IO_putc(int __c , _IO_FILE *__fp ) ;
#line 364 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
#line 209 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) stat)(char const   * __restrict  __file ,
                                                                                             struct stat * __restrict  __buf ) ;
#line 134 "/usr/include/dirent.h"
extern DIR *( __attribute__((__nonnull__(1))) opendir)(char const   *__name ) ;
#line 149
extern int ( __attribute__((__nonnull__(1))) closedir)(DIR *__dirp ) ;
#line 162
extern struct dirent *( __attribute__((__nonnull__(1))) readdir)(DIR *__dirp ) ;
#line 21 "/home/june/repo/benchmarks/collector/temp/dav-text-0.8.5/fileIO.h"
char *doSave(char *filename ) ;
#line 37 "/home/june/repo/benchmarks/collector/temp/dav-text-0.8.5/main.h"
void radixSort(char **strings , int number ) ;
#line 38
void randomizedQuickSort(char **strings , int low , int high ) ;
#line 63
char optimize ;
#line 36 "/home/june/repo/benchmarks/collector/temp/dav-text-0.8.5/fileIO.c"
void save(void) 
{ 
  int tmp ;

  {
  {
#line 38
  tmp = strcmp((char const   *)(currentBuffer->fname), "");
  }
#line 38
  if (tmp) {
    {
#line 42
    doSave(currentBuffer->fname);
    }
  } else {
    {
#line 39
    doSave((char *)".");
    }
  }
#line 44
  currentBuffer->lineUpdate = currentBuffer->topLine;
#line 45
  currentBuffer->lineUpdate.lineNum = 0U;
#line 46
  currentBuffer->lineUpdate.cursY = 0U;
#line 47
  currentBuffer->keepGoing = (char)1;
#line 48
  return;
}
}
#line 50 "/home/june/repo/benchmarks/collector/temp/dav-text-0.8.5/fileIO.c"
void saveAs(void) 
{ 
  char *ptr ;
  size_t tmp ;
  void *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;

  {
  {
#line 52
  tmp = strlen((char const   *)(currentBuffer->fname));
#line 52
  tmp___0 = malloc(tmp);
#line 52
  ptr = (char *)tmp___0;
#line 53
  strcpy((char */* __restrict  */)ptr, (char const   */* __restrict  */)(currentBuffer->fname));
#line 54
  tmp___1 = doSave((char *)".");
#line 54
  tmp___2 = strcmp((char const   *)tmp___1, "");
  }
#line 54
  if (! tmp___2) {
    {
#line 55
    strcpy((char */* __restrict  */)(currentBuffer->fname), (char const   */* __restrict  */)ptr);
    }
  }
  {
#line 57
  free((void *)ptr);
#line 58
  currentBuffer->lineUpdate = currentBuffer->topLine;
#line 59
  currentBuffer->lineUpdate.lineNum = 0U;
#line 60
  currentBuffer->lineUpdate.cursY = 0U;
#line 61
  currentBuffer->keepGoing = (char)1;
  }
#line 62
  return;
}
}
#line 64 "/home/june/repo/benchmarks/collector/temp/dav-text-0.8.5/fileIO.c"
char *doSave(char *filename ) 
{ 
  int t ;
  FILE *fp ;
  struct line *l ;
  struct stat s ;
  int tmp ;
  char newFile[256] ;
  DIR *dir ;
  DIR *tmp___0 ;
  char **choices ;
  void *tmp___1 ;
  int n ;
  char answer[256] ;
  struct dirent *d ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  char *tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;

  {
  {
#line 67
  l = (currentBuffer->head)->next;
#line 70
  helpBarUpdate = 1;
#line 72
  tmp = strcmp((char const   *)filename, "");
  }
#line 72
  if (! tmp) {
#line 73
    return ((char *)"");
  }
  {
#line 75
  stat((char const   */* __restrict  */)filename, (struct stat */* __restrict  */)(& s));
  }
#line 77
  if ((s.st_mode & 61440U) == 16384U) {
    {
#line 78
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 80
      tmp___0 = opendir((char const   *)filename);
#line 80
      dir = tmp___0;
#line 81
      tmp___1 = malloc(sizeof(char *));
#line 81
      choices = (char **)tmp___1;
#line 82
      n = 1;
#line 86
      tmp___2 = malloc((size_t )7);
#line 86
      *(choices + 0) = (char *)tmp___2;
#line 87
      strcpy((char */* __restrict  */)*(choices + 0), (char const   */* __restrict  */)"Cancel");
      }
      {
#line 88
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 90
        d = readdir(dir);
        }
#line 91
        if ((unsigned long )d == (unsigned long )((void *)0)) {
#line 91
          goto while_break___0;
        }
        {
#line 92
        n ++;
#line 93
        tmp___3 = realloc((void *)choices, (unsigned long )n * sizeof(char *));
#line 93
        choices = (char **)tmp___3;
#line 94
        tmp___4 = malloc((size_t )256);
#line 94
        *(choices + (n - 1)) = (char *)tmp___4;
#line 95
        sprintf((char */* __restrict  */)*(choices + (n - 1)), (char const   */* __restrict  */)(d->d_name));
        }
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 97
      closedir(dir);
      }
#line 99
      if ((int )optimize == 0) {
        {
#line 100
        randomizedQuickSort(choices + 1, 0, n - 2);
        }
      } else {
        {
#line 103
        radixSort(choices + 1, n - 1);
        }
      }
      {
#line 106
      listChoice(n, choices, answer, (char *)"File to save as?");
#line 107
      tmp___7 = strcmp((char const   *)(answer), "DAV_CANCEL");
      }
#line 107
      if (tmp___7) {
        {
#line 110
        tmp___6 = strcmp((char const   *)(answer), ".");
        }
#line 110
        if (tmp___6) {
          {
#line 113
          tmp___5 = strcmp((char const   *)(answer), "..");
          }
#line 113
          if (tmp___5) {
            {
#line 117
            sprintf((char */* __restrict  */)(newFile), (char const   */* __restrict  */)"%s/%s",
                    filename, answer);
            }
          } else {
            {
#line 114
            sprintf((char */* __restrict  */)(newFile), (char const   */* __restrict  */)"%s/%s",
                    filename, answer);
            }
          }
        } else {
          {
#line 111
          sprintf((char */* __restrict  */)(newFile), (char const   */* __restrict  */)"%s",
                  filename);
          }
        }
      } else {
#line 108
        newFile[0] = (char )'\000';
      }
#line 119
      n --;
      {
#line 119
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 119
        if (! (n >= 0)) {
#line 119
          goto while_break___1;
        }
        {
#line 120
        free((void *)*(choices + n));
#line 119
        n --;
        }
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 122
      free((void *)choices);
#line 123
      tmp___8 = doSave(newFile);
      }
#line 123
      return (tmp___8);
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 127
  fp = fopen((char const   */* __restrict  */)filename, (char const   */* __restrict  */)"w");
#line 128
  helpBarUpdate = 2;
  }
#line 129
  if ((unsigned long )fp == (unsigned long )((void *)0)) {
    {
#line 131
    tmp___9 = wmove(stdscr, maxY - 1, 0);
    }
#line 131
    if (! (tmp___9 == -1)) {
      {
#line 131
      waddnstr(stdscr, "You do not have the proper permissions to save to that file",
               -1);
      }
    }
#line 133
    return ((char *)"");
  }
  {
#line 135
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 135
    if (! ((unsigned long )l != (unsigned long )(currentBuffer->tail)->prev)) {
#line 135
      goto while_break___2;
    }
#line 137
    t = 0;
    {
#line 137
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 137
      if (! ((unsigned int )t < l->length)) {
#line 137
        goto while_break___3;
      }
      {
#line 138
      _IO_putc((int )*(l->data + t), fp);
#line 137
      t ++;
      }
    }
    while_break___3: /* CIL Label */ ;
    }
#line 139
    l = l->next;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 141
  t = 0;
  {
#line 141
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 141
    if (! ((unsigned int )t < l->length - 1U)) {
#line 141
      goto while_break___4;
    }
    {
#line 142
    _IO_putc((int )*(l->data + t), fp);
#line 141
    t ++;
    }
  }
  while_break___4: /* CIL Label */ ;
  }
  {
#line 143
  fclose(fp);
#line 144
  displayBottomRow();
#line 145
  tmp___10 = wmove(stdscr, maxY - 1, 0);
  }
#line 145
  if (! (tmp___10 == -1)) {
    {
#line 145
    waddnstr(stdscr, "File successfully saved.", -1);
    }
  }
  {
#line 146
  strcpy((char */* __restrict  */)(currentBuffer->fname), (char const   */* __restrict  */)filename);
#line 147
  currentBuffer->updated = (char)0;
  }
#line 148
  return (currentBuffer->fname);
}
}
#line 151 "/home/june/repo/benchmarks/collector/temp/dav-text-0.8.5/fileIO.c"
void load(char *filename ) 
{ 
  char t ;
  int i ;
  struct stat s ;
  FILE *fp ;
  int tmp ;
  DIR *dir ;
  DIR *tmp___0 ;
  char **choices ;
  void *tmp___1 ;
  int n ;
  char answer[256] ;
  char newFile[256] ;
  struct dirent *d ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;

  {
  {
#line 157
  stat((char const   */* __restrict  */)filename, (struct stat */* __restrict  */)(& s));
#line 159
  tmp = strcmp((char const   *)filename, "");
  }
#line 159
  if (! tmp) {
#line 160
    return;
  }
#line 162
  if ((s.st_mode & 61440U) == 16384U) {
    {
#line 164
    tmp___0 = opendir((char const   *)filename);
#line 164
    dir = tmp___0;
#line 165
    tmp___1 = malloc(sizeof(char *));
#line 165
    choices = (char **)tmp___1;
#line 166
    n = 1;
#line 171
    tmp___2 = malloc((size_t )7);
#line 171
    *(choices + 0) = (char *)tmp___2;
#line 172
    strcpy((char */* __restrict  */)*(choices + 0), (char const   */* __restrict  */)"Cancel");
    }
    {
#line 174
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 176
      d = readdir(dir);
      }
#line 177
      if ((unsigned long )d == (unsigned long )((void *)0)) {
#line 177
        goto while_break;
      }
      {
#line 178
      n ++;
#line 179
      tmp___3 = realloc((void *)choices, (unsigned long )n * sizeof(char *));
#line 179
      choices = (char **)tmp___3;
#line 180
      tmp___4 = malloc((size_t )256);
#line 180
      *(choices + (n - 1)) = (char *)tmp___4;
#line 181
      sprintf((char */* __restrict  */)*(choices + (n - 1)), (char const   */* __restrict  */)(d->d_name));
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 183
    closedir(dir);
    }
#line 185
    if ((int )optimize == 0) {
      {
#line 186
      randomizedQuickSort(choices + 1, 0, n - 2);
      }
    } else {
      {
#line 189
      radixSort(choices + 1, n - 1);
      }
    }
    {
#line 192
    listChoice(n, choices, answer, (char *)"File to load?");
#line 193
    tmp___7 = strcmp((char const   *)(answer), "DAV_CANCEL");
    }
#line 193
    if (tmp___7) {
      {
#line 201
      tmp___6 = strcmp((char const   *)(answer), ".");
      }
#line 201
      if (tmp___6) {
        {
#line 204
        tmp___5 = strcmp((char const   *)(answer), "..");
        }
#line 204
        if (tmp___5) {
          {
#line 208
          sprintf((char */* __restrict  */)(newFile), (char const   */* __restrict  */)"%s/%s",
                  filename, answer);
          }
        } else {
          {
#line 205
          sprintf((char */* __restrict  */)(newFile), (char const   */* __restrict  */)"%s/%s",
                  filename, answer);
          }
        }
      } else {
        {
#line 202
        sprintf((char */* __restrict  */)(newFile), (char const   */* __restrict  */)"%s",
                filename);
        }
      }
    } else {
#line 195
      currentBuffer->lineUpdate = currentBuffer->topLine;
#line 196
      currentBuffer->keepGoing = (char)1;
#line 197
      currentBuffer->lineUpdate.lineNum = 0U;
#line 198
      currentBuffer->lineUpdate.cursY = 0U;
#line 199
      newFile[0] = (char )'\000';
    }
#line 210
    n --;
    {
#line 210
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 210
      if (! (n >= 0)) {
#line 210
        goto while_break___0;
      }
      {
#line 211
      free((void *)*(choices + n));
#line 210
      n --;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 212
    free((void *)choices);
#line 213
    load(newFile);
    }
#line 214
    return;
  }
  {
#line 216
  fp = fopen((char const   */* __restrict  */)filename, (char const   */* __restrict  */)"r");
#line 218
  strcpy((char */* __restrict  */)(currentBuffer->fname), (char const   */* __restrict  */)filename);
  }
#line 219
  if ((unsigned long )fp == (unsigned long )((void *)0)) {
    {
#line 221
    displayBottomRow();
#line 222
    tmp___8 = wmove(stdscr, maxY - 1, 0);
    }
#line 222
    if (! (tmp___8 == -1)) {
      {
#line 222
      waddnstr(stdscr, "Couldn\'t open file.", -1);
      }
    }
#line 223
    helpBarUpdate = 2;
#line 224
    return;
  }
  {
#line 228
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 228
    if (! ((unsigned long )currentBuffer->cursor.l != (unsigned long )(currentBuffer->head)->next)) {
#line 228
      if (! (currentBuffer->cursor.offset != 0U)) {
#line 228
        goto while_break___1;
      }
    }
    {
#line 229
    keyHit(259, (char)0);
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 232
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 232
    if (! currentBuffer->numLines) {
#line 232
      goto while_break___2;
    }
    {
#line 233
    keyHit(21, (char)0);
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 234
  keyHit(21, (char)0);
#line 237
  t = autoIndent;
#line 238
  autoIndent = (char)0;
#line 239
  tmp___9 = _IO_getc(fp);
#line 239
  i = tmp___9;
  }
#line 240
  if (i == 10) {
#line 240
    i = 13;
  }
  {
#line 241
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 241
    if (! (i != -1)) {
#line 241
      goto while_break___3;
    }
    {
#line 243
    keyHit(i, (char)0);
#line 244
    tmp___10 = _IO_getc(fp);
#line 244
    i = tmp___10;
    }
#line 245
    if (i == 10) {
#line 245
      i = 13;
    }
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 247
  fclose(fp);
#line 248
  autoIndent = t;
  }
  {
#line 251
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 251
    if (! ((unsigned long )currentBuffer->cursor.l != (unsigned long )(currentBuffer->head)->next)) {
#line 251
      if (! (currentBuffer->cursor.offset != 0U)) {
#line 251
        goto while_break___4;
      }
    }
    {
#line 252
    keyHit(259, (char)0);
    }
  }
  while_break___4: /* CIL Label */ ;
  }
#line 254
  currentBuffer->lineUpdate = currentBuffer->cursor;
#line 255
  currentBuffer->keepGoing = (char)1;
#line 256
  currentBuffer->lineUpdate.lineNum = 0U;
#line 257
  currentBuffer->lineUpdate.cursY = 0U;
#line 258
  currentBuffer->updated = (char)0;
#line 259
  return;
}
}
#line 261 "/home/june/repo/benchmarks/collector/temp/dav-text-0.8.5/fileIO.c"
void askLoad(void) 
{ 


  {
  {
#line 263
  load((char *)".");
#line 264
  helpBarUpdate = 1;
  }
#line 265
  return;
}
}
#line 356 "/usr/include/stdio.h"
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 362
extern int printf(char const   * __restrict  __format  , ...) ;
#line 622
extern char *fgets(char * __restrict  __s , int __n , FILE * __restrict  __stream ) ;
#line 147 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 374
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) rand)(void) ;
#line 543
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 564
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) getenv)(char const   *__name ) ;
#line 587 "/usr/include/curses.h"
extern int cbreak(void) ;
#line 611
extern int endwin(void) ;
#line 632
extern WINDOW *initscr(void) ;
#line 642
extern int intrflush(WINDOW * , _Bool  ) ;
#line 647
extern int keypad(WINDOW * , _Bool  ) ;
#line 710
extern int nodelay(WINDOW * , _Bool  ) ;
#line 712
extern int nonl(void) ;
#line 102 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) __sighandler_t ( __attribute__((__leaf__)) signal)(int __sig ,
                                                                                        void (*__handler)(int  ) ) ;
#line 348 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(2), __leaf__)) strtok)(char * __restrict  __s ,
                                                                                               char const   * __restrict  __delim ) ;
#line 79 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) unsigned short const   **( __attribute__((__leaf__)) __ctype_b_loc)(void)  __attribute__((__const__)) ;
#line 27 "/home/june/repo/benchmarks/collector/temp/dav-text-0.8.5/main.h"
void doArguments(int argc , char **argv ) ;
#line 29
void displayHelp(void) ;
#line 30
void displayVersion(void) ;
#line 31
void sigcatch(void) ;
#line 32
void loadSettings(void) ;
#line 33
void writeRC(FILE *fp ) ;
#line 36
void logMsg(char *msg ) ;
#line 44
void determineLineNum(struct position *p ) ;
#line 49 "/home/june/repo/benchmarks/collector/temp/dav-text-0.8.5/main.h"
int maxY  ;
#line 49 "/home/june/repo/benchmarks/collector/temp/dav-text-0.8.5/main.h"
int maxX  ;
#line 52
char *version ;
#line 60
char bufferQuit ;
#line 65 "/home/june/repo/benchmarks/collector/temp/dav-text-0.8.5/main.h"
int *lastDisplayed  ;
#line 68 "/home/june/repo/benchmarks/collector/temp/dav-text-0.8.5/main.h"
struct buffer *buffers  ;
#line 69 "/home/june/repo/benchmarks/collector/temp/dav-text-0.8.5/main.h"
struct buffer *currentBuffer  ;
#line 38 "/home/june/repo/benchmarks/collector/temp/dav-text-0.8.5/main.c"
int helpBarUpdate  =    0;
#line 40 "/home/june/repo/benchmarks/collector/temp/dav-text-0.8.5/main.c"
char *version  =    (char *)"0.8.5";
#line 43 "/home/june/repo/benchmarks/collector/temp/dav-text-0.8.5/main.c"
int maxUndoLength  =    500;
#line 44 "/home/june/repo/benchmarks/collector/temp/dav-text-0.8.5/main.c"
char undoEnabled  =    (char)1;
#line 45 "/home/june/repo/benchmarks/collector/temp/dav-text-0.8.5/main.c"
char autoIndent  =    (char)1;
#line 46 "/home/june/repo/benchmarks/collector/temp/dav-text-0.8.5/main.c"
int numberOfBuffers  =    10;
#line 47 "/home/june/repo/benchmarks/collector/temp/dav-text-0.8.5/main.c"
char bottomRowToggle  =    (char)1;
#line 48 "/home/june/repo/benchmarks/collector/temp/dav-text-0.8.5/main.c"
char bufferQuit  =    (char)0;
#line 49 "/home/june/repo/benchmarks/collector/temp/dav-text-0.8.5/main.c"
char tabWidth  =    (char)8;
#line 50 "/home/june/repo/benchmarks/collector/temp/dav-text-0.8.5/main.c"
char smartCursor  =    (char)1;
#line 51 "/home/june/repo/benchmarks/collector/temp/dav-text-0.8.5/main.c"
char optimize  =    (char)0;
#line 54 "/home/june/repo/benchmarks/collector/temp/dav-text-0.8.5/main.c"
char displayWholeScreen  =    (char)0;
#line 58 "/home/june/repo/benchmarks/collector/temp/dav-text-0.8.5/main.c"
int currentBufferNum  =    0;
#line 61 "/home/june/repo/benchmarks/collector/temp/dav-text-0.8.5/main.c"
int main(int argc , char **argv ) 
{ 
  int x ;
  int y ;
  int keypress ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  unsigned int tmp___2 ;
  unsigned int tmp___3 ;
  void *tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  void *tmp___7 ;

  {
  {
#line 66
  signal(2, (void (*)(int  ))(& sigcatch));
#line 68
  Fn_ptr[0] = & search;
#line 69
  Fn_ptr[1] = & save;
#line 70
  Fn_ptr[2] = & saveAs;
#line 71
  Fn_ptr[3] = & askLoad;
#line 72
  Fn_ptr[4] = & tryQuit;
#line 73
  Fn_ptr[5] = & Undo;
#line 74
  Fn_ptr[7] = & toggleAutoIndent;
#line 75
  Fn_ptr[8] = & tryCompile;
#line 76
  Fn_ptr[9] = & toggleBottomRow;
#line 77
  loadSettings();
  }
#line 79
  if (numberOfBuffers > 100) {
#line 79
    numberOfBuffers = 100;
  }
  {
#line 80
  tmp = malloc((unsigned long )numberOfBuffers * sizeof(struct buffer ));
#line 80
  buffers = (struct buffer *)tmp;
#line 83
  x = 0;
  }
  {
#line 83
  while (1) {
    while_continue: /* CIL Label */ ;
#line 83
    if (! (x < numberOfBuffers)) {
#line 83
      goto while_break;
    }
    {
#line 85
    tmp___0 = malloc(sizeof(struct line ));
#line 85
    (buffers + x)->head = (struct line *)tmp___0;
#line 86
    tmp___1 = malloc(sizeof(struct line ));
#line 86
    (buffers + x)->tail = (struct line *)tmp___1;
#line 87
    ((buffers + x)->head)->next = (buffers + x)->tail;
#line 88
    ((buffers + x)->head)->data = (unsigned char *)((void *)0);
#line 89
    ((buffers + x)->tail)->prev = (buffers + x)->head;
#line 90
    ((buffers + x)->tail)->next = (buffers + x)->tail;
#line 91
    ((buffers + x)->tail)->data = (unsigned char *)((void *)0);
#line 92
    ((buffers + x)->tail)->hasTabs = (unsigned char)0;
#line 94
    currentBuffer = buffers + x;
#line 95
    addLineAfter((buffers + x)->head, (char *)" ");
#line 97
    (buffers + x)->cursor.l = ((buffers + x)->head)->next;
#line 98
    (buffers + x)->cursor.offset = 0U;
#line 99
    (buffers + x)->cursor.lineNum = 0U;
#line 100
    (buffers + x)->topLine.l = ((buffers + x)->head)->next;
#line 101
    (buffers + x)->topLine.offset = 0U;
#line 102
    (buffers + x)->topLine.lineNum = 0U;
#line 103
    tmp___2 = 0U;
#line 103
    (buffers + x)->topLine.cursY = tmp___2;
#line 103
    (buffers + x)->topLine.cursX = tmp___2;
#line 104
    tmp___3 = 0U;
#line 104
    (buffers + x)->cursor.cursY = tmp___3;
#line 104
    (buffers + x)->cursor.cursX = tmp___3;
#line 105
    (buffers + x)->cursor.wantCursX = 0U;
#line 106
    (buffers + x)->currentLine = & (buffers + x)->cursor.l;
#line 107
    (buffers + x)->lineUpdate.offset = 4294967295U;
#line 109
    (buffers + x)->numLines = 0;
#line 110
    (buffers + x)->updated = (char)0;
    }
#line 111
    if (undoEnabled) {
      {
#line 111
      tmp___4 = malloc((unsigned long )maxUndoLength * sizeof(struct undoMove ));
#line 111
      (buffers + x)->undoMoves = (struct undoMove *)tmp___4;
      }
    }
#line 112
    tmp___5 = 0;
#line 112
    (buffers + x)->undoBufferLength = tmp___5;
#line 112
    (buffers + x)->undoBufferPointer = tmp___5;
#line 83
    x ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 115
  currentBuffer = buffers + 0;
#line 117
  initscr();
#line 118
  cbreak();
#line 119
  nonl();
#line 120
  intrflush(stdscr, (_Bool)0);
#line 121
  keypad(stdscr, (_Bool)1);
  }
#line 122
  if (stdscr) {
#line 122
    maxY = (int )stdscr->_maxy + 1;
  } else {
#line 122
    maxY = -1;
  }
#line 122
  if (stdscr) {
#line 122
    maxX = (int )stdscr->_maxx + 1;
  } else {
#line 122
    maxX = -1;
  }
#line 123
  x = 0;
  {
#line 123
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 123
    if (! (x < maxX)) {
#line 123
      goto while_break___0;
    }
#line 124
    y = 0;
    {
#line 124
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 124
      if (! (y < maxY)) {
#line 124
        goto while_break___1;
      }
      {
#line 125
      tmp___6 = wmove(stdscr, y, x);
      }
#line 125
      if (! (tmp___6 == -1)) {
        {
#line 125
        waddch(stdscr, (chtype const   )' ');
        }
      }
#line 124
      y ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 123
    x ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 126
  wmove(stdscr, 0, 0);
#line 127
  tmp___7 = malloc((unsigned long )maxY * sizeof(int ));
#line 127
  lastDisplayed = (int *)tmp___7;
  }
#line 129
  if (argc >= 2) {
    {
#line 129
    doArguments(argc, argv);
    }
  }
  {
#line 131
  helpBar();
#line 132
  showRow();
  }
  {
#line 134
  while (1) {
    while_continue___2: /* CIL Label */ ;
    {
#line 136
    wmove(stdscr, (int )currentBuffer->cursor.cursY, (int )currentBuffer->cursor.cursX);
#line 137
    keypress = wgetch(stdscr);
#line 138
    keyHit(keypress, undoEnabled);
#line 139
    displayScreen();
#line 140
    showRow();
    }
#line 141
    if (helpBarUpdate) {
#line 143
      helpBarUpdate --;
#line 144
      if (! helpBarUpdate) {
        {
#line 144
        helpBar();
        }
      }
    }
  }
  while_break___2: /* CIL Label */ ;
  }
#line 147
  return (0);
}
}
#line 150 "/home/june/repo/benchmarks/collector/temp/dav-text-0.8.5/main.c"
void nothing(void) 
{ 


  {
#line 152
  currentBuffer->lineUpdate.offset = 4294967295U;
#line 153
  return;
}
}
#line 155 "/home/june/repo/benchmarks/collector/temp/dav-text-0.8.5/main.c"
void tryQuit(void) 
{ 
  int t ;
  int tmp ;
  int tmp___0 ;

  {
#line 158
  if (! currentBuffer->updated) {
#line 159
    if (! bufferQuit) {
      {
#line 159
      quit((char *)"");
      }
    } else {
      {
#line 160
      closeBuffer();
      }
    }
#line 161
    return;
  }
  {
#line 163
  displayBottomRow();
#line 164
  tmp = wmove(stdscr, maxY - 1, 0);
  }
#line 164
  if (! (tmp == -1)) {
    {
#line 164
    waddnstr(stdscr, "Save before quit? y/n/[C]", -1);
    }
  }
  {
#line 165
  wmove(stdscr, maxY - 1, 26);
#line 166
  t = wgetch(stdscr);
#line 167
  tmp___0 = wmove(stdscr, maxY - 1, 26);
  }
#line 167
  if (! (tmp___0 == -1)) {
    {
#line 167
    waddch(stdscr, (chtype const   )' ');
    }
  }
#line 168
  if (t == 121) {
    {
#line 169
    save();
#line 170
    t = 'n';
    }
  } else
#line 168
  if (t == 89) {
    {
#line 169
    save();
#line 170
    t = 'n';
    }
  }
#line 172
  if (t == 110) {
#line 172
    goto _L;
  } else
#line 172
  if (t == 78) {
    _L: /* CIL Label */ 
#line 173
    if (! bufferQuit) {
      {
#line 173
      quit((char *)"");
      }
    } else {
      {
#line 174
      closeBuffer();
      }
    }
  }
#line 176
  helpBarUpdate = 1;
#line 177
  currentBuffer->lineUpdate.offset = 4294967295U;
#line 178
  return;
}
}
#line 180 "/home/june/repo/benchmarks/collector/temp/dav-text-0.8.5/main.c"
void quit(char *text ) 
{ 
  struct line *l ;
  int t ;
  int tmp ;
  int tmp___0 ;

  {
#line 185
  t = 0;
  {
#line 185
  while (1) {
    while_continue: /* CIL Label */ ;
#line 185
    if (! (t < numberOfBuffers)) {
#line 185
      goto while_break;
    }
#line 186
    if (t == currentBufferNum) {
#line 186
      goto __Cont;
    }
#line 187
    if ((buffers + t)->updated) {
      {
#line 188
      displayBottomRow();
#line 189
      tmp = wmove(stdscr, maxY - 1, 0);
      }
#line 189
      if (! (tmp == -1)) {
        {
#line 189
        waddnstr(stdscr, "One or more buffers have not been saved. Quit? y/[N]", -1);
        }
      }
      {
#line 190
      t = wgetch(stdscr);
      }
#line 191
      if (t == 121) {
#line 192
        goto while_break;
      } else
#line 191
      if (t == 89) {
#line 192
        goto while_break;
      } else {
#line 195
        helpBarUpdate = 1;
#line 196
        return;
      }
    }
    __Cont: /* CIL Label */ 
#line 185
    t ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 201
  t = 0;
  {
#line 201
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 201
    if (! (t < maxX)) {
#line 201
      goto while_break___0;
    }
    {
#line 202
    tmp___0 = wmove(stdscr, maxY - 1, t);
    }
#line 202
    if (! (tmp___0 == -1)) {
      {
#line 202
      waddch(stdscr, (chtype const   )' ');
      }
    }
#line 201
    t ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 204
  nodelay(stdscr, (_Bool)1);
#line 205
  wgetch(stdscr);
#line 206
  endwin();
  }
#line 208
  if (undoEnabled) {
#line 209
    t = 0;
    {
#line 209
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 209
      if (! (t < numberOfBuffers)) {
#line 209
        goto while_break___1;
      }
      {
#line 210
      free((void *)(buffers + t)->undoMoves);
#line 209
      t ++;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
  }
#line 214
  t = 0;
  {
#line 214
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 214
    if (! (t < numberOfBuffers)) {
#line 214
      goto while_break___2;
    }
#line 215
    l = (buffers + t)->head;
    {
#line 216
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 216
      if (! ((unsigned long )l != (unsigned long )(buffers + t)->tail)) {
#line 216
        goto while_break___3;
      }
#line 217
      l = l->next;
#line 218
      if ((l->prev)->data) {
        {
#line 218
        free((void *)(l->prev)->data);
        }
      }
      {
#line 219
      free((void *)l->prev);
      }
    }
    while_break___3: /* CIL Label */ ;
    }
    {
#line 221
    free((void *)(buffers + t)->tail);
#line 214
    t ++;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 224
  free((void *)buffers);
#line 225
  free((void *)lastDisplayed);
#line 226
  printf((char const   */* __restrict  */)"%s", text);
#line 227
  exit(0);
  }
}
}
#line 230 "/home/june/repo/benchmarks/collector/temp/dav-text-0.8.5/main.c"
void doArguments(int argc , char **argv ) 
{ 
  int x ;
  char firstFile ;
  int tmp ;
  char *tmp___0 ;
  unsigned short const   **tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 233
  firstFile = (char)1;
#line 234
  x = 1;
  {
#line 234
  while (1) {
    while_continue: /* CIL Label */ ;
#line 234
    if (! (x < argc)) {
#line 234
      goto while_break;
    }
#line 236
    if ((int )*(*(argv + x) + 0) != 45) {
#line 238
      if (! firstFile) {
        {
#line 239
        goToNextBuffer();
        }
      }
      {
#line 241
      load(*(argv + x));
#line 242
      firstFile = (char)0;
      }
    } else {
      {
#line 245
      tmp___3 = strcmp((char const   *)*(argv + x), "--help");
      }
#line 245
      if (tmp___3) {
        {
#line 247
        tmp___2 = strcmp((char const   *)*(argv + x), "--version");
        }
#line 247
        if (tmp___2) {
          {
#line 249
          tmp___0 = strstr((char const   *)*(argv + x), "-l");
          }
#line 249
          if ((unsigned long )tmp___0 != (unsigned long )((void *)0)) {
            {
#line 249
            tmp___1 = __ctype_b_loc();
            }
#line 249
            if ((int const   )*(*tmp___1 + (int )*(*(argv + x) + 2)) & 2048) {
              {
#line 250
              tmp = atoi((char const   *)(*(argv + x) + 2));
#line 250
              gotoLine(tmp);
              }
            } else {
              {
#line 253
              displayHelp();
              }
            }
          } else {
            {
#line 253
            displayHelp();
            }
          }
        } else {
          {
#line 248
          displayVersion();
          }
        }
      } else {
        {
#line 246
        displayHelp();
        }
      }
    }
#line 234
    x ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 259
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 259
    if (! ((unsigned long )currentBuffer != (unsigned long )(buffers + 0))) {
#line 259
      goto while_break___0;
    }
    {
#line 260
    goToPrevBuffer();
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 263
  displayScreen();
  }
#line 264
  return;
}
}
#line 266 "/home/june/repo/benchmarks/collector/temp/dav-text-0.8.5/main.c"
void displayVersion(void) 
{ 
  char text[30] ;

  {
  {
#line 269
  sprintf((char */* __restrict  */)(text), (char const   */* __restrict  */)"Dav version %s\n",
          version);
#line 270
  quit(text);
  }
#line 271
  return;
}
}
#line 273 "/home/june/repo/benchmarks/collector/temp/dav-text-0.8.5/main.c"
void displayHelp(void) 
{ 
  char *c ;
  char *tmp ;
  int t ;

  {
  {
#line 275
  tmp = getenv("HOME");
#line 275
  c = tmp;
#line 277
  endwin();
#line 278
  printf((char const   */* __restrict  */)"Dav v%s, written by David Gucwa\n", version);
#line 279
  printf((char const   */* __restrict  */)"Usage: dav [arguments] [FILENAME] [FILENAME] ...\n");
#line 280
  printf((char const   */* __restrict  */)"  where FILENAMEs, if specified, are the names of the files you wish to load.\n");
#line 281
  printf((char const   */* __restrict  */)"Arguments list:\n");
#line 282
  printf((char const   */* __restrict  */)"  --help : Display this help screen\n");
#line 283
  printf((char const   */* __restrict  */)"  --version: Display the version of Dav that you are running\n");
#line 284
  printf((char const   */* __restrict  */)"  -l#: Initialize Dav at a specific line number. (eg -l123)\n");
#line 285
  printf((char const   */* __restrict  */)"Basic commands:\n");
#line 286
  t = 0;
  }
  {
#line 286
  while (1) {
    while_continue: /* CIL Label */ ;
#line 286
    if (! (t < 12)) {
#line 286
      goto while_break;
    }
#line 288
    if (! Fn_ptr[t]) {
#line 289
      goto __Cont;
    } else
#line 288
    if ((unsigned long )Fn_ptr[t] == (unsigned long )(& nothing)) {
#line 289
      goto __Cont;
    }
    {
#line 290
    printf((char const   */* __restrict  */)"  F%i : ", t + 1);
    }
#line 291
    if ((unsigned long )Fn_ptr[t] == (unsigned long )(& search)) {
      {
#line 292
      printf((char const   */* __restrict  */)"Search\n");
      }
    } else
#line 293
    if ((unsigned long )Fn_ptr[t] == (unsigned long )(& replace)) {
      {
#line 294
      printf((char const   */* __restrict  */)"Find and replace\n");
      }
    } else
#line 295
    if ((unsigned long )Fn_ptr[t] == (unsigned long )(& save)) {
      {
#line 296
      printf((char const   */* __restrict  */)"Save current file\n");
      }
    } else
#line 297
    if ((unsigned long )Fn_ptr[t] == (unsigned long )(& saveAs)) {
      {
#line 298
      printf((char const   */* __restrict  */)"Save current file, prompt for filename\n");
      }
    } else
#line 299
    if ((unsigned long )Fn_ptr[t] == (unsigned long )(& askLoad)) {
      {
#line 300
      printf((char const   */* __restrict  */)"Load file from within Dav\n");
      }
    } else
#line 301
    if ((unsigned long )Fn_ptr[t] == (unsigned long )(& tryQuit)) {
      {
#line 302
      printf((char const   */* __restrict  */)"Quit (ask for save if needed)\n");
      }
    } else
#line 303
    if ((unsigned long )Fn_ptr[t] == (unsigned long )(& Undo)) {
      {
#line 304
      printf((char const   */* __restrict  */)"Undo last keypress\n");
      }
    } else
#line 305
    if ((unsigned long )Fn_ptr[t] == (unsigned long )(& toggleAutoIndent)) {
      {
#line 306
      printf((char const   */* __restrict  */)"Toggle auto-indenting\n");
      }
    } else
#line 307
    if ((unsigned long )Fn_ptr[t] == (unsigned long )(& tryCompile)) {
      {
#line 308
      printf((char const   */* __restrict  */)"Compile and print error messages\n");
      }
    } else
#line 309
    if ((unsigned long )Fn_ptr[t] == (unsigned long )(& toggleBottomRow)) {
      {
#line 310
      printf((char const   */* __restrict  */)"Toggle help bar\n");
      }
    } else
#line 311
    if ((unsigned long )Fn_ptr[t] == (unsigned long )(& goToNextBuffer)) {
      {
#line 312
      printf((char const   */* __restrict  */)"Switch to next text buffer\n");
      }
    } else
#line 313
    if ((unsigned long )Fn_ptr[t] == (unsigned long )(& goToPrevBuffer)) {
      {
#line 314
      printf((char const   */* __restrict  */)"Switch to previous text buffer\n");
      }
    }
    __Cont: /* CIL Label */ 
#line 286
    t ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 317
  printf((char const   */* __restrict  */)"  Ctrl-C : Quit (won\'t ask for save)\n");
#line 318
  printf((char const   */* __restrict  */)"  Ctrl-K : Erase to end of line\n");
#line 319
  printf((char const   */* __restrict  */)"  Ctrl-U : Erase whole line\n");
#line 320
  printf((char const   */* __restrict  */)"Personal options:\n");
#line 321
  printf((char const   */* __restrict  */)"  Located in %s/.davrc\n", c);
#line 322
  printf((char const   */* __restrict  */)"Also edit %s/.davrc to customize function key bindings\n",
         c);
#line 323
  initscr();
#line 324
  quit((char *)"");
  }
#line 325
  return;
}
}
#line 327 "/home/june/repo/benchmarks/collector/temp/dav-text-0.8.5/main.c"
void loadSettings(void) 
{ 
  int l ;
  char s[80] ;
  char home[80] ;
  char *r ;
  char *c ;
  FILE *fp ;
  int gotten ;
  char FnGotten[12] ;
  char *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  size_t tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;

  {
#line 335
  gotten = 0;
#line 337
  l = 0;
  {
#line 337
  while (1) {
    while_continue: /* CIL Label */ ;
#line 337
    if (! (l < 12)) {
#line 337
      goto while_break;
    }
#line 338
    FnGotten[l] = (char)0;
#line 337
    l ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 339
  tmp = getenv("HOME");
#line 339
  strcpy((char */* __restrict  */)(home), (char const   */* __restrict  */)tmp);
#line 340
  strcat((char */* __restrict  */)(home), (char const   */* __restrict  */)"/.davrc");
#line 341
  fp = fopen((char const   */* __restrict  */)(home), (char const   */* __restrict  */)"r");
  }
#line 342
  if ((unsigned long )fp == (unsigned long )((void *)0)) {
    {
#line 344
    fp = fopen((char const   */* __restrict  */)(home), (char const   */* __restrict  */)"w");
    }
#line 345
    if ((unsigned long )fp == (unsigned long )((void *)0)) {
#line 345
      return;
    }
    {
#line 346
    writeRC(fp);
#line 347
    fclose(fp);
#line 348
    fp = fopen((char const   */* __restrict  */)(home), (char const   */* __restrict  */)"r");
    }
  }
  {
#line 351
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 351
    tmp___23 = feof(fp);
    }
#line 351
    if (tmp___23) {
#line 351
      goto while_break___0;
    }
    {
#line 352
    fgets((char */* __restrict  */)(s), 200, (FILE */* __restrict  */)fp);
    }
#line 353
    if ((int )s[0] == 35) {
#line 353
      goto while_continue___0;
    }
    {
#line 354
    r = strtok((char */* __restrict  */)(s), (char const   */* __restrict  */)" =");
#line 355
    c = strtok((char */* __restrict  */)((void *)0), (char const   */* __restrict  */)" =");
    }
#line 356
    if ((unsigned long )c == (unsigned long )((void *)0)) {
#line 356
      goto while_continue___0;
    }
    {
#line 357
    l = atoi((char const   *)c);
#line 358
    tmp___0 = strcmp((char const   *)r, "Undo");
    }
#line 358
    if (! tmp___0) {
#line 358
      undoEnabled = (char )l;
#line 358
      gotten |= 1;
    }
    {
#line 359
    tmp___1 = strcmp((char const   *)r, "UndoBuffer");
    }
#line 359
    if (! tmp___1) {
#line 359
      maxUndoLength = l;
#line 359
      gotten |= 2;
    }
    {
#line 360
    tmp___2 = strcmp((char const   *)r, "autoIndent");
    }
#line 360
    if (! tmp___2) {
#line 360
      autoIndent = (char )l;
#line 360
      gotten |= 4;
    }
    {
#line 361
    tmp___3 = strcmp((char const   *)r, "helpBarInit");
    }
#line 361
    if (! tmp___3) {
#line 361
      bottomRowToggle = (char )l;
#line 361
      gotten |= 8;
    }
    {
#line 362
    tmp___4 = strcmp((char const   *)r, "buffers");
    }
#line 362
    if (! tmp___4) {
#line 362
      numberOfBuffers = l;
#line 362
      gotten |= 16;
    }
    {
#line 363
    tmp___5 = strcmp((char const   *)r, "bufferQuit");
    }
#line 363
    if (! tmp___5) {
#line 363
      bufferQuit = (char )l;
#line 363
      gotten |= 32;
    }
    {
#line 364
    tmp___6 = strcmp((char const   *)r, "tabWidth");
    }
#line 364
    if (! tmp___6) {
#line 364
      tabWidth = (char )l;
#line 364
      gotten |= 64;
    }
    {
#line 365
    tmp___7 = strcmp((char const   *)r, "smartCursor");
    }
#line 365
    if (! tmp___7) {
#line 365
      smartCursor = (char )l;
#line 365
      gotten |= 128;
    }
    {
#line 366
    tmp___8 = strcmp((char const   *)r, "optimize");
    }
#line 366
    if (! tmp___8) {
#line 366
      optimize = (char )l;
#line 366
      gotten |= 256;
    }
#line 367
    if ((int )*(r + 0) == 70) {
      {
#line 369
      tmp___9 = strlen((char const   *)c);
#line 369
      *(c + (tmp___9 - 1UL)) = (char )'\000';
#line 370
      r ++;
#line 371
      l = atoi((char const   *)r);
#line 372
      l --;
#line 374
      tmp___22 = strcmp((char const   *)c, "SEARCH");
      }
#line 374
      if (tmp___22) {
        {
#line 379
        tmp___21 = strcmp((char const   *)c, "SAVE");
        }
#line 379
        if (tmp___21) {
          {
#line 384
          tmp___20 = strcmp((char const   *)c, "SAVE_AS");
          }
#line 384
          if (tmp___20) {
            {
#line 389
            tmp___19 = strcmp((char const   *)c, "LOAD");
            }
#line 389
            if (tmp___19) {
              {
#line 394
              tmp___18 = strcmp((char const   *)c, "QUIT");
              }
#line 394
              if (tmp___18) {
                {
#line 399
                tmp___17 = strcmp((char const   *)c, "UNDO");
                }
#line 399
                if (tmp___17) {
                  {
#line 404
                  tmp___16 = strcmp((char const   *)c, "COMPILE");
                  }
#line 404
                  if (tmp___16) {
                    {
#line 409
                    tmp___15 = strcmp((char const   *)c, "TOGGLE_AUTOINDENT");
                    }
#line 409
                    if (tmp___15) {
                      {
#line 414
                      tmp___14 = strcmp((char const   *)c, "TOGGLE_BOTTOM_ROW");
                      }
#line 414
                      if (tmp___14) {
                        {
#line 419
                        tmp___13 = strcmp((char const   *)c, "NOTHING");
                        }
#line 419
                        if (tmp___13) {
                          {
#line 424
                          tmp___12 = strcmp((char const   *)c, "REPLACE");
                          }
#line 424
                          if (tmp___12) {
                            {
#line 429
                            tmp___11 = strcmp((char const   *)c, "PREV");
                            }
#line 429
                            if (tmp___11) {
                              {
#line 434
                              tmp___10 = strcmp((char const   *)c, "NEXT");
                              }
#line 434
                              if (tmp___10) {
#line 441
                                Fn_ptr[l] = & nothing;
#line 442
                                FnGotten[l] = (char)0;
                              } else {
#line 436
                                Fn_ptr[l] = & goToNextBuffer;
#line 437
                                FnGotten[l] = (char)13;
                              }
                            } else {
#line 431
                              Fn_ptr[l] = & goToPrevBuffer;
#line 432
                              FnGotten[l] = (char)12;
                            }
                          } else {
#line 426
                            Fn_ptr[l] = & replace;
#line 427
                            FnGotten[l] = (char)11;
                          }
                        } else {
#line 421
                          Fn_ptr[l] = & nothing;
#line 422
                          FnGotten[l] = (char)10;
                        }
                      } else {
#line 416
                        Fn_ptr[l] = & toggleBottomRow;
#line 417
                        FnGotten[l] = (char)9;
                      }
                    } else {
#line 411
                      Fn_ptr[l] = & toggleAutoIndent;
#line 412
                      FnGotten[l] = (char)8;
                    }
                  } else {
#line 406
                    Fn_ptr[l] = & tryCompile;
#line 407
                    FnGotten[l] = (char)7;
                  }
                } else {
#line 401
                  Fn_ptr[l] = & Undo;
#line 402
                  FnGotten[l] = (char)6;
                }
              } else {
#line 396
                Fn_ptr[l] = & tryQuit;
#line 397
                FnGotten[l] = (char)5;
              }
            } else {
#line 391
              Fn_ptr[l] = & askLoad;
#line 392
              FnGotten[l] = (char)4;
            }
          } else {
#line 386
            Fn_ptr[l] = & saveAs;
#line 387
            FnGotten[l] = (char)3;
          }
        } else {
#line 381
          Fn_ptr[l] = & save;
#line 382
          FnGotten[l] = (char)2;
        }
      } else {
#line 376
        Fn_ptr[l] = & search;
#line 377
        FnGotten[l] = (char)1;
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 446
  fclose(fp);
#line 447
  l = 0;
  }
  {
#line 447
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 447
    if (! (l < 12)) {
#line 447
      goto while_break___1;
    }
#line 449
    if ((int )FnGotten[l] == 0) {
#line 450
      gotten = 0;
    }
#line 447
    l ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 452
  if (gotten != 511) {
    {
#line 454
    fp = fopen((char const   */* __restrict  */)(home), (char const   */* __restrict  */)"w");
    }
#line 455
    if ((unsigned long )fp == (unsigned long )((void *)0)) {
#line 455
      return;
    }
    {
#line 456
    writeRC(fp);
#line 457
    fclose(fp);
    }
  }
#line 459
  return;
}
}
#line 461 "/home/june/repo/benchmarks/collector/temp/dav-text-0.8.5/main.c"
void writeRC(FILE *fp ) 
{ 
  int t ;

  {
  {
#line 464
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"#Set this to 1 if you want undoing enabled, otherwise set it to 0.\n");
#line 465
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"#Having the undo feature enabled uses a little more processor power.\n");
#line 466
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"Undo = %i\n\n",
          (int )undoEnabled);
#line 467
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"#This determines how big your undo buffer will be.\n");
#line 468
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"#Actual memory usage in bytes is the following number times nine.\n");
#line 469
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"UndoBuffer = %i\n\n",
          maxUndoLength);
#line 470
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"#Set this to 1 if you want auto indenting enabled, otherwise set it to 0.\n");
#line 471
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"#If auto indent is enabled, new lines will be indented.\n");
#line 472
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"autoIndent = %i\n\n",
          (int )autoIndent);
#line 473
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"#This line will determine whether the help bar is enabled by default.\n");
#line 474
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"#You can toggle it any time by hitting F10 inside Dav.\n");
#line 475
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"helpBarInit = %i\n\n",
          (int )bottomRowToggle);
#line 476
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"#How many text buffers will Dav use?\n");
#line 477
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"#The default value is 10. The maximum is 100.\n");
#line 478
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"buffers = %i\n\n",
          numberOfBuffers);
#line 479
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"#0 = QUIT function exits Dav\n");
#line 480
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"#1 = QUIT function closes only the current buffer\n");
#line 481
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"#    (If there are no more buffers left, it will exit Dav)\n");
#line 482
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"bufferQuit = %i\n\n",
          (int )bufferQuit);
#line 483
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"#Tab width (default value is 8)\n");
#line 484
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"tabWidth = %i\n\n",
          (int )tabWidth);
#line 485
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"#SmartCursor controls whether the cursor will try to stay on the same column\n");
#line 486
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"#during up/down movement between lines of varying widths.\n");
#line 487
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"smartCursor = %i\n\n",
          (int )smartCursor);
#line 488
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"#Optimize controls whether Dav is optimized for memory or cpu efficiency.\n");
#line 489
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"#Right now this is only used for sorting directories by filename.\n");
#line 490
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"#Default value is 0. If you notice lag in the load/save dialogue, you may\n");
#line 491
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"# want to change it to 1.\n");
#line 492
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"#0 = Optimized for memory efficiency (uses quicksort)\n");
#line 493
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"#1 = Optimized for cpu efficiency (uses radix sort)\n");
#line 494
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"optimize = %i\n\n",
          (int )optimize);
#line 495
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"#Function Key definitions:\n");
#line 496
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"#  SEARCH : Search the file for a string\n");
#line 497
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"#  REPLACE : Find and replace strings\n");
#line 498
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"#  SAVE : Saves current file\n");
#line 499
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"#  SAVE_AS : Saves current file, prompts for filename first\n");
#line 500
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"#  LOAD : Load a different file\n");
#line 501
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"#  QUIT : Exits out of Dav\n");
#line 502
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"#  UNDO : Undoes your last action\n");
#line 503
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"#  COMPILE : Runs a Makefile and displays error messages\n");
#line 504
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"#  TOGGLE_AUTOINDENT : Toggles auto indenting\n");
#line 505
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"#  TOGGLE_BOTTOM_ROW : Switches between displaying Fn bindings and file name\n");
#line 506
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"#  PREV : Switches to the previous text buffer (of 10)\n");
#line 507
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"#  NEXT : Switches to the next text buffer (of 10)\n");
#line 508
  t = 0;
  }
  {
#line 508
  while (1) {
    while_continue: /* CIL Label */ ;
#line 508
    if (! (t < 12)) {
#line 508
      goto while_break;
    }
    {
#line 510
    fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"F%i = ",
            t + 1);
    }
#line 511
    if ((unsigned long )Fn_ptr[t] == (unsigned long )(& search)) {
      {
#line 512
      fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"SEARCH\n");
      }
    } else
#line 513
    if ((unsigned long )Fn_ptr[t] == (unsigned long )(& save)) {
      {
#line 514
      fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"SAVE\n");
      }
    } else
#line 515
    if ((unsigned long )Fn_ptr[t] == (unsigned long )(& saveAs)) {
      {
#line 516
      fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"SAVE_AS\n");
      }
    } else
#line 517
    if ((unsigned long )Fn_ptr[t] == (unsigned long )(& askLoad)) {
      {
#line 518
      fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"LOAD\n");
      }
    } else
#line 519
    if ((unsigned long )Fn_ptr[t] == (unsigned long )(& tryQuit)) {
      {
#line 520
      fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"QUIT\n");
      }
    } else
#line 521
    if ((unsigned long )Fn_ptr[t] == (unsigned long )(& Undo)) {
      {
#line 522
      fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"UNDO\n");
      }
    } else
#line 523
    if ((unsigned long )Fn_ptr[t] == (unsigned long )(& tryCompile)) {
      {
#line 524
      fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"COMPILE\n");
      }
    } else
#line 525
    if ((unsigned long )Fn_ptr[t] == (unsigned long )(& toggleAutoIndent)) {
      {
#line 526
      fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"TOGGLE_AUTOINDENT\n");
      }
    } else
#line 527
    if ((unsigned long )Fn_ptr[t] == (unsigned long )(& toggleBottomRow)) {
      {
#line 528
      fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"TOGGLE_BOTTOM_ROW\n");
      }
    } else
#line 529
    if ((unsigned long )Fn_ptr[t] == (unsigned long )(& replace)) {
      {
#line 530
      fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"REPLACE\n");
      }
    } else
#line 531
    if ((unsigned long )Fn_ptr[t] == (unsigned long )(& goToNextBuffer)) {
      {
#line 532
      fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"NEXT\n");
      }
    } else
#line 533
    if ((unsigned long )Fn_ptr[t] == (unsigned long )(& goToPrevBuffer)) {
      {
#line 534
      fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"PREV\n");
      }
    } else {
      {
#line 535
      fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"NOTHING\n");
      }
    }
#line 508
    t ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 537
  return;
}
}
#line 539 "/home/june/repo/benchmarks/collector/temp/dav-text-0.8.5/main.c"
void addLineAfter(struct line *whichLine , char *data ) 
{ 
  struct line *temp ;
  struct line *newLine ;
  void *tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;
  size_t tmp___2 ;

  {
  {
#line 541
  temp = whichLine->next;
#line 542
  tmp = malloc(sizeof(struct line ));
#line 542
  newLine = (struct line *)tmp;
#line 543
  temp->prev = newLine;
#line 544
  whichLine->next = newLine;
#line 545
  newLine->next = temp;
#line 546
  newLine->prev = whichLine;
#line 547
  tmp___0 = strlen((char const   *)data);
#line 547
  tmp___1 = malloc(tmp___0);
#line 547
  newLine->data = (unsigned char *)tmp___1;
#line 548
  strcpy((char */* __restrict  */)newLine->data, (char const   */* __restrict  */)data);
#line 549
  tmp___2 = strlen((char const   *)data);
#line 549
  newLine->length = (unsigned int )tmp___2;
#line 550
  countTabs(newLine);
#line 551
  (currentBuffer->numLines) ++;
  }
#line 552
  return;
}
}
#line 554 "/home/june/repo/benchmarks/collector/temp/dav-text-0.8.5/main.c"
char positionDown(struct position *p ) 
{ 
  int tempX ;
  char temp ;

  {
#line 560
  tempX = (int )p->cursX;
#line 561
  temp = (char)0;
  {
#line 563
  while (1) {
    while_continue: /* CIL Label */ ;
#line 563
    if (! (! temp)) {
#line 563
      goto while_break;
    }
    {
#line 569
    temp = moveRight(p);
    }
#line 570
    if ((int )temp == 1) {
#line 571
      return ((char)1);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 574
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 577
    if (p->cursX >= (unsigned int )tempX) {
#line 578
      return ((char)0);
    } else
#line 579
    if (p->offset == (p->l)->length - 1U) {
#line 580
      return ((char)0);
    }
    {
#line 583
    temp = moveRight(p);
    }
#line 584
    if ((int )temp == 1) {
#line 585
      return ((char)0);
    } else
#line 586
    if ((int )temp > 1) {
      {
#line 587
      moveLeft(p);
      }
#line 588
      return ((char)0);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
}
}
#line 593 "/home/june/repo/benchmarks/collector/temp/dav-text-0.8.5/main.c"
char positionUp(struct position *p ) 
{ 
  int tempX ;
  char temp ;

  {
#line 600
  tempX = (int )p->cursX;
#line 601
  temp = (char)0;
  {
#line 602
  while (1) {
    while_continue: /* CIL Label */ ;
#line 602
    if (! (! temp)) {
#line 602
      goto while_break;
    }
    {
#line 603
    temp = moveLeft(p);
    }
#line 604
    if ((int )temp == 1) {
#line 605
      if ((unsigned long )p == (unsigned long )(& currentBuffer->cursor)) {
#line 606
        currentBuffer->cursor.wantCursX = currentBuffer->cursor.cursX;
      }
#line 608
      return ((char)1);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 611
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 612
    if (p->cursX <= (unsigned int )tempX) {
#line 613
      return ((char)0);
    }
    {
#line 615
    temp = moveLeft(p);
    }
#line 616
    if ((int )temp == 1) {
#line 617
      return ((char)0);
    } else
#line 618
    if ((int )temp > 1) {
      {
#line 619
      moveRight(p);
      }
#line 620
      return ((char)0);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
}
}
#line 625 "/home/june/repo/benchmarks/collector/temp/dav-text-0.8.5/main.c"
void connectLines(struct line *baseline ) 
{ 
  struct line *l ;
  unsigned char *ptr ;
  void *tmp ;

  {
  {
#line 627
  l = baseline->next;
#line 628
  tmp = malloc((size_t )(baseline->length + l->length));
#line 628
  ptr = (unsigned char *)tmp;
#line 629
  memmove((void *)ptr, (void const   *)baseline->data, (size_t )baseline->length);
#line 630
  memmove((void *)(ptr + baseline->length), (void const   *)l->data, (size_t )l->length);
#line 631
  free((void *)baseline->data);
#line 632
  baseline->data = ptr;
#line 633
  baseline->length += l->length;
#line 634
  baseline->next = l->next;
#line 635
  (l->next)->prev = baseline;
#line 636
  baseline->hasTabs = (unsigned char )((int )baseline->hasTabs + (int )l->hasTabs);
#line 637
  free((void *)l->data);
#line 638
  free((void *)l);
#line 639
  (currentBuffer->numLines) --;
  }
#line 640
  return;
}
}
#line 642 "/home/june/repo/benchmarks/collector/temp/dav-text-0.8.5/main.c"
void determineLineNum(struct position *p ) 
{ 
  struct position temp ;
  int cX ;
  int cY ;

  {
#line 645
  cX = (int )p->cursX;
#line 645
  cY = (int )p->cursY;
#line 647
  temp.l = (currentBuffer->head)->next;
#line 648
  temp.offset = 0U;
#line 649
  temp.lineNum = 0U;
  {
#line 650
  while (1) {
    while_continue: /* CIL Label */ ;
#line 650
    if (! ((unsigned long )temp.l != (unsigned long )p->l)) {
#line 650
      goto while_break;
    }
    {
#line 651
    positionDown(& temp);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 653
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 653
    if (! (temp.offset + (unsigned int )maxX <= p->offset)) {
#line 653
      goto while_break___0;
    }
    {
#line 654
    positionDown(& temp);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 656
  p->lineNum = temp.lineNum;
#line 657
  p->cursX = (unsigned int )cX;
#line 658
  p->cursY = (unsigned int )cY;
#line 659
  return;
}
}
#line 661 "/home/june/repo/benchmarks/collector/temp/dav-text-0.8.5/main.c"
void countTabs(struct line *l ) 
{ 
  int t ;

  {
#line 664
  l->hasTabs = (unsigned char)0;
#line 665
  t = (int )(l->length - 1U);
  {
#line 665
  while (1) {
    while_continue: /* CIL Label */ ;
#line 665
    if (! (t >= 0)) {
#line 665
      goto while_break;
    }
#line 666
    if ((int )*(l->data + t) == 9) {
#line 666
      l->hasTabs = (unsigned char )((int )l->hasTabs + 1);
    }
#line 665
    t --;
  }
  while_break: /* CIL Label */ ;
  }
#line 667
  return;
}
}
#line 669 "/home/june/repo/benchmarks/collector/temp/dav-text-0.8.5/main.c"
void determineCursX(struct position *p ) 
{ 
  struct position temp ;
  unsigned char c ;

  {
#line 674
  temp.l = p->l;
#line 675
  temp.offset = 0U;
#line 676
  temp.cursX = 0U;
  {
#line 677
  while (1) {
    while_continue: /* CIL Label */ ;
#line 677
    if (! (p->offset != temp.offset)) {
#line 677
      goto while_break;
    }
#line 679
    c = *((temp.l)->data + temp.offset);
#line 680
    (temp.offset) ++;
#line 681
    if ((int )c != 9) {
#line 682
      (temp.cursX) ++;
    } else {
#line 684
      temp.cursX += (unsigned int )tabWidth - temp.cursX % (unsigned int )tabWidth;
    }
#line 685
    if (temp.cursX >= (unsigned int )maxX) {
#line 685
      temp.cursX = 0U;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 687
  p->cursX = temp.cursX;
#line 688
  return;
}
}
#line 690 "/home/june/repo/benchmarks/collector/temp/dav-text-0.8.5/main.c"
void logMsg(char *msg ) 
{ 
  char text[256] ;

  {
  {
#line 692
  sprintf((char */* __restrict  */)(text), (char const   */* __restrict  */)"echo \"%s\" >> log",
          msg);
#line 693
  system((char const   *)(text));
  }
#line 694
  return;
}
}
#line 696 "/home/june/repo/benchmarks/collector/temp/dav-text-0.8.5/main.c"
void sigcatch(void) 
{ 


  {
  {
#line 697
  quit((char *)"");
  }
#line 698
  return;
}
}
#line 700 "/home/june/repo/benchmarks/collector/temp/dav-text-0.8.5/main.c"
void radixSort(char **strings , int number ) 
{ 
  char **buckets[256] ;
  int numberInBuckets[256] ;
  int radix ;
  int t ;
  int i ;
  int j ;
  void *tmp ;
  int bucket ;
  void *tmp___0 ;

  {
#line 703
  radix = 0;
#line 707
  i = 0;
  {
#line 707
  while (1) {
    while_continue: /* CIL Label */ ;
#line 707
    if (! (i < 256)) {
#line 707
      goto while_break;
    }
    {
#line 708
    tmp = malloc(0UL);
#line 708
    buckets[i] = (char **)tmp;
#line 707
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 711
  radix = 255;
  {
#line 711
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 711
    if (! (radix >= 0)) {
#line 711
      goto while_break___0;
    }
#line 712
    t = 0;
    {
#line 712
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 712
      if (! (t < 256)) {
#line 712
        goto while_break___1;
      }
#line 713
      numberInBuckets[t] = 0;
#line 712
      t ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 716
    t = 0;
    {
#line 716
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 716
      if (! (t < number)) {
#line 716
        goto while_break___2;
      }
      {
#line 717
      bucket = (int )((unsigned char )*(*(strings + t) + radix));
#line 718
      tmp___0 = realloc((void *)buckets[bucket], (unsigned long )(numberInBuckets[bucket] + 1) * sizeof(char *));
#line 718
      buckets[bucket] = (char **)tmp___0;
#line 719
      *(buckets[bucket] + numberInBuckets[bucket]) = *(strings + t);
#line 720
      (numberInBuckets[bucket]) ++;
#line 716
      t ++;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
#line 723
    t = 0;
#line 724
    i = 0;
    {
#line 724
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 724
      if (! (i < 256)) {
#line 724
        goto while_break___3;
      }
#line 725
      j = 0;
      {
#line 725
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 725
        if (! (j < numberInBuckets[i])) {
#line 725
          goto while_break___4;
        }
#line 726
        *(strings + t) = *(buckets[i] + j);
#line 727
        t ++;
#line 725
        j ++;
      }
      while_break___4: /* CIL Label */ ;
      }
#line 724
      i ++;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 711
    radix --;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 732
  i = 0;
  {
#line 732
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 732
    if (! (i < 256)) {
#line 732
      goto while_break___5;
    }
    {
#line 733
    free((void *)buckets[i]);
#line 732
    i ++;
    }
  }
  while_break___5: /* CIL Label */ ;
  }
#line 735
  return;
}
}
#line 737 "/home/june/repo/benchmarks/collector/temp/dav-text-0.8.5/main.c"
void randomizedQuickSort(char **strings , int low , int high ) 
{ 
  int axis ;
  int oldLow ;
  int oldHigh ;
  char *temp ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 740
  oldLow = low;
#line 741
  oldHigh = high;
#line 744
  if (low >= high) {
#line 745
    return;
  }
#line 748
  if (high - low == 1) {
    {
#line 749
    tmp = strcmp((char const   *)*(strings + high), (char const   *)*(strings + low));
    }
#line 749
    if (tmp < 0) {
#line 750
      temp = *(strings + high);
#line 751
      *(strings + high) = *(strings + low);
#line 752
      *(strings + low) = temp;
    }
#line 754
    return;
  }
  {
#line 758
  tmp___0 = rand();
#line 758
  axis = tmp___0 % ((high - low) + 1) + low;
#line 759
  temp = *(strings + axis);
#line 760
  *(strings + axis) = *(strings + high);
#line 761
  *(strings + high) = temp;
#line 762
  axis = high;
#line 763
  high --;
  }
  {
#line 765
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 766
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 766
      tmp___1 = strcmp((char const   *)*(strings + low), (char const   *)*(strings + axis));
      }
#line 766
      if (tmp___1 <= 0) {
#line 766
        if (! (low < high)) {
#line 766
          goto while_break___0;
        }
      } else {
#line 766
        goto while_break___0;
      }
#line 767
      low ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 770
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 770
      tmp___2 = strcmp((char const   *)*(strings + high), (char const   *)*(strings + axis));
      }
#line 770
      if (tmp___2 >= 0) {
#line 770
        if (! (low < high)) {
#line 770
          goto while_break___1;
        }
      } else {
#line 770
        goto while_break___1;
      }
#line 771
      high --;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 774
    if (low >= high) {
#line 775
      goto while_break;
    }
#line 778
    temp = *(strings + low);
#line 779
    *(strings + low) = *(strings + high);
#line 780
    *(strings + high) = temp;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 783
  tmp___3 = strcmp((char const   *)*(strings + low), (char const   *)*(strings + axis));
  }
#line 783
  if (tmp___3 < 0) {
#line 784
    low ++;
  }
  {
#line 786
  temp = *(strings + axis);
#line 787
  *(strings + axis) = *(strings + low);
#line 788
  *(strings + low) = temp;
#line 790
  randomizedQuickSort(strings, oldLow, low - 1);
#line 791
  randomizedQuickSort(strings, low + 1, oldHigh);
  }
#line 792
  return;
}
}
