/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 141 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __suseconds_t;
#line 172 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __ssize_t;
#line 183 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef char *__caddr_t;
#line 189 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __socklen_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 315 "/usr/include/libio.h"
typedef struct _IO_FILE _IO_FILE;
#line 102 "/usr/include/stdio.h"
typedef __ssize_t ssize_t;
#line 30 "/usr/include/x86_64-linux-gnu/bits/time.h"
struct timeval {
   __time_t tv_sec ;
   __suseconds_t tv_usec ;
};
#line 85 "/usr/include/signal.h"
typedef void (*__sighandler_t)(int  );
#line 274 "/usr/include/unistd.h"
typedef __socklen_t socklen_t;
#line 28 "/usr/include/x86_64-linux-gnu/bits/sockaddr.h"
typedef unsigned short sa_family_t;
#line 149 "/usr/include/x86_64-linux-gnu/bits/socket.h"
struct sockaddr {
   sa_family_t sa_family ;
   char sa_data[14] ;
};
#line 55 "/usr/include/x86_64-linux-gnu/sys/time.h"
struct timezone {
   int tz_minuteswest ;
   int tz_dsttime ;
};
#line 61 "/usr/include/x86_64-linux-gnu/sys/time.h"
typedef struct timezone * __restrict  __timezone_ptr_t;
#line 107 "/usr/include/x86_64-linux-gnu/sys/time.h"
struct itimerval {
   struct timeval it_interval ;
   struct timeval it_value ;
};
#line 120 "/usr/include/x86_64-linux-gnu/sys/time.h"
typedef int __itimer_which_t;
#line 111 "/usr/include/net/if.h"
struct ifmap {
   unsigned long mem_start ;
   unsigned long mem_end ;
   unsigned short base_addr ;
   unsigned char irq ;
   unsigned char dma ;
   unsigned char port ;
};
#line 126 "/usr/include/net/if.h"
union __anonunion_ifr_ifrn_57 {
   char ifrn_name[16] ;
};
#line 126 "/usr/include/net/if.h"
union __anonunion_ifr_ifru_58 {
   struct sockaddr ifru_addr ;
   struct sockaddr ifru_dstaddr ;
   struct sockaddr ifru_broadaddr ;
   struct sockaddr ifru_netmask ;
   struct sockaddr ifru_hwaddr ;
   short ifru_flags ;
   int ifru_ivalue ;
   int ifru_mtu ;
   struct ifmap ifru_map ;
   char ifru_slave[16] ;
   char ifru_newname[16] ;
   __caddr_t ifru_data ;
};
#line 126 "/usr/include/net/if.h"
struct ifreq {
   union __anonunion_ifr_ifrn_57 ifr_ifrn ;
   union __anonunion_ifr_ifru_58 ifr_ifru ;
};
#line 29 "/usr/include/net/if_packet.h"
struct sockaddr_pkt {
   sa_family_t spkt_family ;
   unsigned char spkt_device[14] ;
   unsigned short spkt_protocol ;
};
#line 20 "/usr/include/asm-generic/int-ll64.h"
typedef unsigned char __u8;
#line 23 "/usr/include/asm-generic/int-ll64.h"
typedef unsigned short __u16;
#line 26 "/usr/include/asm-generic/int-ll64.h"
typedef unsigned int __u32;
#line 49 "/usr/include/stdint.h"
typedef unsigned short uint16_t;
#line 67 "/home/june/repo/benchmarks/collector/temp/irda-utils-0.9.18/irdaping/irdaping.c"
struct test_frame {
   __u8 caddr ;
   __u8 control ;
   __u32 saddr ;
   __u32 daddr ;
   __u8 info[0] ;
} __attribute__((__packed__)) ;
#line 75 "/home/june/repo/benchmarks/collector/temp/irda-utils-0.9.18/irdaping/irdaping.c"
struct test_info {
   __u16 pkt_nr ;
   struct timeval time ;
   __u8 info[0] ;
} __attribute__((__packed__)) ;
#line 82 "/home/june/repo/benchmarks/collector/temp/irda-utils-0.9.18/irdaping/irdaping.c"
struct instance {
   int fd ;
   int packets ;
   __u32 saddr ;
   __u32 daddr ;
   struct ifreq ifr ;
   int framelen ;
   char device[14] ;
   struct timeval time_current ;
   __u8 buf[2048] ;
};
#line 133 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __pid_t;
#line 23 "/usr/include/x86_64-linux-gnu/bits/termios.h"
typedef unsigned char cc_t;
#line 24 "/usr/include/x86_64-linux-gnu/bits/termios.h"
typedef unsigned int speed_t;
#line 25 "/usr/include/x86_64-linux-gnu/bits/termios.h"
typedef unsigned int tcflag_t;
#line 28 "/usr/include/x86_64-linux-gnu/bits/termios.h"
struct termios {
   tcflag_t c_iflag ;
   tcflag_t c_oflag ;
   tcflag_t c_cflag ;
   tcflag_t c_lflag ;
   cc_t c_line ;
   cc_t c_cc[32] ;
   speed_t c_ispeed ;
   speed_t c_ospeed ;
};
#line 48 "/usr/include/x86_64-linux-gnu/sys/utsname.h"
struct utsname {
   char sysname[65] ;
   char nodename[65] ;
   char release[65] ;
   char version[65] ;
   char machine[65] ;
   char __domainname[65] ;
};
#line 74 "/home/june/repo/benchmarks/collector/temp/irda-utils-0.9.18/irattach/irattach.c"
struct irtty_info {
   char name[6] ;
};
#line 87 "/home/june/repo/benchmarks/collector/temp/irda-utils-0.9.18/irattach/irattach.c"
struct dongle_list_s {
   int id ;
   char *dongle ;
};
#line 140 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __useconds_t;
#line 109 "/home/june/repo/benchmarks/collector/temp/irda-utils-0.9.18/irattach/util.c"
union __anonunion_52 {
   int __in ;
   int __i ;
};
#line 108 "/home/june/repo/benchmarks/collector/temp/irda-utils-0.9.18/irattach/util.c"
union __anonunion_53 {
   int __in ;
   int __i ;
};
#line 111 "/home/june/repo/benchmarks/collector/temp/irda-utils-0.9.18/irattach/util.c"
union __anonunion_54 {
   int __in ;
   int __i ;
};
#line 113 "/home/june/repo/benchmarks/collector/temp/irda-utils-0.9.18/irattach/util.c"
union __anonunion_55 {
   int __in ;
   int __i ;
};
#line 107 "/home/june/repo/benchmarks/collector/temp/irda-utils-0.9.18/irattach/util.c"
union __anonunion_56 {
   int __in ;
   int __i ;
};
#line 435 "/usr/include/libio.h"
extern int _IO_putc(int __c , _IO_FILE *__fp ) ;
#line 169 "/usr/include/stdio.h"
extern struct _IO_FILE *stdout ;
#line 242
extern int fflush(FILE *__stream ) ;
#line 362
extern int printf(char const   * __restrict  __format  , ...) ;
#line 846
extern void perror(char const   *__s ) ;
#line 183 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) long ( __attribute__((__nonnull__(1), __leaf__)) strtol)(char const   * __restrict  __nptr ,
                                                                                              char ** __restrict  __endptr ,
                                                                                              int __base ) ;
#line 187
extern  __attribute__((__nothrow__)) unsigned long ( __attribute__((__nonnull__(1),
__leaf__)) strtoul)(char const   * __restrict  __nptr , char ** __restrict  __endptr ,
                    int __base ) ;
#line 543
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 46 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memcpy)(void * __restrict  __dest ,
                                                                                                 void const   * __restrict  __src ,
                                                                                                 size_t __n ) ;
#line 66
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memset)(void *__s ,
                                                                                               int __c ,
                                                                                               size_t __n ) ;
#line 132
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strncpy)(char * __restrict  __dest ,
                                                                                                  char const   * __restrict  __src ,
                                                                                                  size_t __n ) ;
#line 102 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) __sighandler_t ( __attribute__((__leaf__)) signal)(int __sig ,
                                                                                        void (*__handler)(int  ) ) ;
#line 57 "/usr/include/getopt.h"
extern char *optarg ;
#line 150
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) getopt)(int ___argc ,
                                                                             char * const  *___argv ,
                                                                             char const   *__shortopts ) ;
#line 113 "/usr/include/x86_64-linux-gnu/sys/socket.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) socket)(int __domain ,
                                                                             int __type ,
                                                                             int __protocol ) ;
#line 123
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) bind)(int __fd ,
                                                                           struct sockaddr  const  *__addr ,
                                                                           socklen_t __len ) ;
#line 163
extern ssize_t sendto(int __fd , void const   *__buf , size_t __n , int __flags ,
                      struct sockaddr  const  *__addr , socklen_t __addr_len ) ;
#line 174
extern ssize_t recvfrom(int __fd , void * __restrict  __buf , size_t __n , int __flags ,
                        struct sockaddr * __restrict  __addr , socklen_t * __restrict  __addr_len ) ;
#line 71 "/usr/include/x86_64-linux-gnu/sys/time.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) gettimeofday)(struct timeval * __restrict  __tv ,
                                                                                                   __timezone_ptr_t __tz ) ;
#line 131
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) setitimer)(__itimer_which_t __which ,
                                                                                struct itimerval  const  * __restrict  __new ,
                                                                                struct itimerval * __restrict  __old ) ;
#line 41 "/usr/include/x86_64-linux-gnu/sys/ioctl.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) ioctl)(int __fd ,
                                                                            unsigned long __request 
                                                                            , ...) ;
#line 379 "/usr/include/netinet/in.h"
extern  __attribute__((__nothrow__)) uint16_t ( __attribute__((__leaf__)) htons)(uint16_t __hostshort )  __attribute__((__const__)) ;
#line 82 "/home/june/repo/benchmarks/collector/temp/irda-utils-0.9.18/irdaping/irdaping.c"
struct instance self  ;
#line 100 "/home/june/repo/benchmarks/collector/temp/irda-utils-0.9.18/irdaping/irdaping.c"
void cleanup(int signo ) 
{ 


  {
  {
#line 102
  fflush(stdout);
#line 103
  _IO_putc('\n', stdout);
#line 105
  printf((char const   */* __restrict  */)"%d packets received by filter\n", self.packets);
#line 107
  exit(0);
  }
}
}
#line 116 "/home/june/repo/benchmarks/collector/temp/irda-utils-0.9.18/irdaping/irdaping.c"
void timeout(int signo ) 
{ 
  struct test_frame *frame ;
  struct test_info *info___0 ;
  struct sockaddr_pkt from ;
  int n ;
  int i ;
  int count ;
  int rest ;
  int tmp ;
  int tmp___0 ;
  ssize_t tmp___1 ;

  {
  {
#line 121
  n = 0;
#line 125
  frame = (struct test_frame *)(self.buf);
#line 126
  info___0 = (struct test_info *)(frame->info);
#line 129
  self.saddr = *((__u32 *)(self.ifr.ifr_ifru.ifru_hwaddr.sa_data));
#line 131
  frame->caddr = (__u8 )255;
#line 132
  frame->control = (__u8 )243;
#line 133
  frame->saddr = self.saddr;
#line 134
  frame->daddr = self.daddr;
#line 136
  tmp = self.packets;
#line 136
  (self.packets) ++;
#line 136
  info___0->pkt_nr = (__u16 )tmp;
#line 137
  gettimeofday((struct timeval */* __restrict  */)(& self.time_current), (__timezone_ptr_t )((struct timezone *)0));
#line 138
  memcpy((void */* __restrict  */)(& info___0->time), (void const   */* __restrict  */)(& self.time_current),
         sizeof(struct timezone ));
#line 141
  rest = (int )(((unsigned long )self.framelen - sizeof(struct test_frame )) - sizeof(struct test_info ));
#line 142
  i = 0;
  }
  {
#line 142
  while (1) {
    while_continue: /* CIL Label */ ;
#line 142
    if (! (i < rest)) {
#line 142
      goto while_break;
    }
#line 143
    tmp___0 = n;
#line 143
    n ++;
#line 143
    info___0->info[i] = (__u8 )tmp___0;
#line 142
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 146
  from.spkt_family = (sa_family_t )783;
#line 147
  from.spkt_protocol = htons((uint16_t )23);
#line 148
  memcpy((void */* __restrict  */)(from.spkt_device), (void const   */* __restrict  */)(self.device),
         (size_t )6);
#line 150
  tmp___1 = sendto(self.fd, (void const   *)(self.buf), (size_t )self.framelen, 0,
                   (struct sockaddr  const  *)((struct sockaddr *)(& from)), (socklen_t )sizeof(from));
#line 150
  count = (int )tmp___1;
  }
#line 152
  if (count < 0) {
    {
#line 153
    perror("sendto");
#line 154
    exit(-1);
    }
  }
#line 156
  return;
}
}
#line 164 "/home/june/repo/benchmarks/collector/temp/irda-utils-0.9.18/irdaping/irdaping.c"
int main(int argc , char **argv ) 
{ 
  int count ;
  struct test_frame *frame ;
  struct test_info *info___0 ;
  unsigned char buf[2048] ;
  struct sockaddr from_sa ;
  struct sockaddr_pkt from ;
  socklen_t fromlen ;
  struct timeval time ;
  struct timeval *timep ;
  struct itimerval itime ;
  float diff ;
  int c ;
  unsigned long tmp ;
  long tmp___0 ;
  uint16_t tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  ssize_t tmp___4 ;

  {
#line 178
  if (argc < 2) {
    {
#line 179
    printf((char const   */* __restrict  */)"Usage: irdaping <daddr> [-s <framesize>] [-i <iface>]\n");
#line 180
    exit(-1);
    }
  }
  {
#line 184
  memset((void *)(& self), 0, sizeof(struct instance ));
#line 185
  tmp = strtoul((char const   */* __restrict  */)*(argv + 1), (char **/* __restrict  */)((void *)0),
                0);
#line 185
  self.daddr = (__u32 )tmp;
#line 186
  self.framelen = 32;
#line 187
  strncpy((char */* __restrict  */)(self.device), (char const   */* __restrict  */)"irda0",
          (size_t )14);
  }
  {
#line 189
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 189
    c = getopt(argc, (char * const  *)argv, "hs:i:");
    }
#line 189
    if (! (c != -1)) {
#line 189
      goto while_break;
    }
    {
#line 191
    if (c == 115) {
#line 191
      goto case_115;
    }
#line 194
    if (c == 105) {
#line 194
      goto case_105;
    }
#line 197
    if (c == 104) {
#line 197
      goto case_104;
    }
#line 200
    goto switch_default;
    case_115: /* CIL Label */ 
    {
#line 192
    tmp___0 = strtol((char const   */* __restrict  */)optarg, (char **/* __restrict  */)((void *)0),
                     10);
#line 192
    self.framelen = (int )tmp___0;
    }
#line 193
    goto switch_break;
    case_105: /* CIL Label */ 
    {
#line 195
    strncpy((char */* __restrict  */)(self.device), (char const   */* __restrict  */)optarg,
            (size_t )14);
    }
#line 196
    goto switch_break;
    case_104: /* CIL Label */ 
    {
#line 198
    printf((char const   */* __restrict  */)"Usage: irdaping <daddr> [-s <framesize>] [-i <iface>]\n");
#line 199
    exit(-1);
    }
    switch_default: /* CIL Label */ 
#line 201
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 206
  if ((unsigned long )self.framelen < 12UL + sizeof(struct timeval )) {
#line 207
    self.framelen = (int )(12UL + sizeof(struct timeval ));
  }
  {
#line 210
  signal(15, & cleanup);
#line 211
  signal(2, & cleanup);
#line 212
  signal(1, & cleanup);
#line 213
  signal(14, & timeout);
#line 216
  tmp___1 = htons((uint16_t )3);
#line 216
  self.fd = socket(17, 10, (int )tmp___1);
  }
#line 217
  if (self.fd < 0) {
    {
#line 218
    perror("socket");
#line 219
    exit(-1);
    }
  }
  {
#line 223
  memset((void *)(& from_sa), 0, sizeof(from_sa));
#line 224
  from_sa.sa_family = (sa_family_t )17;
#line 225
  strncpy((char */* __restrict  */)(from_sa.sa_data), (char const   */* __restrict  */)(self.device),
          sizeof(from_sa.sa_data));
#line 226
  tmp___2 = bind(self.fd, (struct sockaddr  const  *)(& from_sa), (socklen_t )sizeof(from_sa));
  }
#line 226
  if (tmp___2) {
    {
#line 227
    perror("bind");
#line 228
    exit(-1);
    }
  }
  {
#line 232
  memset((void *)(& self.ifr), 0, sizeof(self.ifr));
#line 233
  strncpy((char */* __restrict  */)(self.ifr.ifr_ifrn.ifrn_name), (char const   */* __restrict  */)(self.device),
          sizeof(self.ifr.ifr_ifrn.ifrn_name));
#line 234
  tmp___3 = ioctl(self.fd, 35111UL, & self.ifr);
  }
#line 234
  if (tmp___3 < 0) {
    {
#line 235
    perror("SIOCGIFHWADDR");
#line 236
    exit(-1);
    }
  }
  {
#line 238
  itime.it_value.tv_sec = (__time_t )1;
#line 239
  itime.it_value.tv_usec = (__suseconds_t )0;
#line 241
  itime.it_interval.tv_sec = (__time_t )1;
#line 242
  itime.it_interval.tv_usec = (__suseconds_t )0;
#line 243
  setitimer(0, (struct itimerval  const  */* __restrict  */)(& itime), (struct itimerval */* __restrict  */)((void *)0));
#line 245
  printf((char const   */* __restrict  */)"IrDA ping (0x%08x on %s): %d bytes\n",
         self.daddr, self.device, self.framelen);
  }
  {
#line 247
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 248
    fromlen = (socklen_t )sizeof(struct sockaddr_pkt );
#line 249
    tmp___4 = recvfrom(self.fd, (void */* __restrict  */)(buf), (size_t )2048, 0,
                       (struct sockaddr */* __restrict  */)((struct sockaddr *)(& from)),
                       (socklen_t */* __restrict  */)(& fromlen));
#line 249
    count = (int )tmp___4;
    }
#line 251
    if (count < 0) {
      {
#line 252
      perror("recvfrom");
#line 253
      exit(-1);
      }
    }
#line 256
    frame = (struct test_frame *)(buf);
#line 257
    info___0 = (struct test_info *)(frame->info);
#line 260
    if ((int )frame->caddr & 1) {
#line 262
      goto while_continue___0;
    } else
#line 260
    if ((int )frame->control != 243) {
#line 262
      goto while_continue___0;
    }
#line 264
    if ((unsigned long )count < sizeof(struct test_frame )) {
#line 265
      goto while_continue___0;
    }
    {
#line 267
    printf((char const   */* __restrict  */)"%d bytes from ", count);
#line 268
    printf((char const   */* __restrict  */)"0x%08x", frame->saddr);
    }
#line 271
    if ((unsigned long )count < sizeof(struct test_frame ) + sizeof(struct test_info )) {
      {
#line 273
      printf((char const   */* __restrict  */)"\n");
      }
#line 274
      goto while_continue___0;
    }
    {
#line 277
    gettimeofday((struct timeval */* __restrict  */)(& time), (__timezone_ptr_t )((struct timezone *)0));
#line 280
    timep = & info___0->time;
    }
#line 282
    if (timep->tv_usec > time.tv_usec) {
#line 283
      time.tv_usec += 1000000L;
#line 284
      (time.tv_sec) --;
    }
    {
#line 286
    time.tv_usec -= timep->tv_usec;
#line 287
    time.tv_sec -= timep->tv_sec;
#line 289
    diff = (float )(((double )((float )time.tv_sec) * 1000000.0 + (double )time.tv_usec) / 1000.0);
#line 292
    printf((char const   */* __restrict  */)": irda_seq=%d ", (int )info___0->pkt_nr);
#line 293
    printf((char const   */* __restrict  */)"time=%6.2f ms.\n", (double )diff);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
}
}
#line 170 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 237
extern int fclose(FILE *__stream ) ;
#line 272
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 364
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
#line 622
extern char *fgets(char * __restrict  __s , int __n , FILE * __restrict  __stream ) ;
#line 129 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcpy)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 144
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 147
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strncmp)(char const   *__s1 ,
                                                                                                char const   *__s2 ,
                                                                                                size_t __n )  __attribute__((__pure__)) ;
#line 236
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strchr)(char const   *__s ,
                                                                                               int __c )  __attribute__((__pure__)) ;
#line 348
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(2), __leaf__)) strtok)(char * __restrict  __s ,
                                                                                               char const   * __restrict  __delim ) ;
#line 413
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) strerror)(int __errnum ) ;
#line 79 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) unsigned short const   **( __attribute__((__leaf__)) __ctype_b_loc)(void)  __attribute__((__const__)) ;
#line 50 "/usr/include/x86_64-linux-gnu/bits/errno.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
#line 137 "/usr/include/fcntl.h"
extern int fcntl(int __fd , int __cmd  , ...) ;
#line 146
extern int ( __attribute__((__nonnull__(1))) open)(char const   *__file , int __oflag 
                                                   , ...) ;
#line 190 "/usr/include/x86_64-linux-gnu/sys/syslog.h"
extern void ( /* format attribute */  syslog)(int __pri , char const   *__fmt  , ...) ;
#line 66 "/usr/include/termios.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) tcgetattr)(int __fd ,
                                                                                struct termios *__termios_p ) ;
#line 70
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) tcsetattr)(int __fd ,
                                                                                int __optional_actions ,
                                                                                struct termios  const  *__termios_p ) ;
#line 353 "/usr/include/unistd.h"
extern int close(int __fd ) ;
#line 444
extern unsigned int sleep(unsigned int __seconds ) ;
#line 469
extern int pause(void) ;
#line 756
extern  __attribute__((__nothrow__)) __pid_t fork(void) ;
#line 826
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) unlink)(char const   *__name ) ;
#line 81 "/usr/include/x86_64-linux-gnu/sys/utsname.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) uname)(struct utsname *__name ) ;
#line 53 "/home/june/repo/benchmarks/collector/temp/irda-utils-0.9.18/irattach/irattach.c"
void fork_now(int ttyfd ) ;
#line 54
int set_sysctl_param(char *name , char *value ) ;
#line 55
int execute(char *msg , char *cmd ) ;
#line 63 "/home/june/repo/benchmarks/collector/temp/irda-utils-0.9.18/irattach/irattach.c"
static int devfd  =    -1;
#line 64 "/home/june/repo/benchmarks/collector/temp/irda-utils-0.9.18/irattach/irattach.c"
static int fdflags  =    -1;
#line 65 "/home/june/repo/benchmarks/collector/temp/irda-utils-0.9.18/irattach/irattach.c"
static int initfdflags  =    -1;
#line 66 "/home/june/repo/benchmarks/collector/temp/irda-utils-0.9.18/irattach/irattach.c"
static int initdisc  =    -1;
#line 67 "/home/june/repo/benchmarks/collector/temp/irda-utils-0.9.18/irattach/irattach.c"
static struct termios termsave  ;
#line 68 "/home/june/repo/benchmarks/collector/temp/irda-utils-0.9.18/irattach/irattach.c"
static int termvalid  =    -1;
#line 71 "/home/june/repo/benchmarks/collector/temp/irda-utils-0.9.18/irattach/irattach.c"
char *pidfile  =    (char *)"/var/run/irattach.pid";
#line 83 "/home/june/repo/benchmarks/collector/temp/irda-utils-0.9.18/irattach/irattach.c"
struct irtty_info info  ;
#line 85 "/home/june/repo/benchmarks/collector/temp/irda-utils-0.9.18/irattach/irattach.c"
char device[20]  ;
#line 91 "/home/june/repo/benchmarks/collector/temp/irda-utils-0.9.18/irattach/irattach.c"
struct dongle_list_s dongle_list[14]  = 
#line 91
  {      {1, (char *)"esi"}, 
        {0, (char *)"tekram"}, 
        {2, (char *)"actisys"}, 
        {3, (char *)"actisys+"}, 
        {4, (char *)"girbil"}, 
        {5, (char *)"litelink"}, 
        {6, (char *)"airport"}, 
        {7, (char *)"old_belkin"}, 
        {8, (char *)"ep7211"}, 
        {9, (char *)"mcp2120"}, 
        {10, (char *)"act200l"}, 
        {11, (char *)"ma600"}, 
        {12, (char *)"toim3232"}, 
        {-1, (char *)((void *)0)}};
#line 119 "/home/june/repo/benchmarks/collector/temp/irda-utils-0.9.18/irattach/irattach.c"
static int modify_flags(char *dev , int set , int clear ) 
{ 
  struct ifreq ifr ;
  int sockfd ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 125
  sockfd = socket(23, 1, 0);
  }
#line 126
  if (sockfd < 0) {
    {
#line 127
    syslog(4, "socket(AF_IRDA): %m");
    }
#line 128
    return (-1);
  }
  {
#line 133
  strncpy((char */* __restrict  */)(ifr.ifr_ifrn.ifrn_name), (char const   */* __restrict  */)dev,
          (size_t )16);
#line 134
  tmp = ioctl(sockfd, 35091UL, & ifr);
  }
#line 134
  if (tmp < 0) {
    {
#line 135
    syslog(4, "ioctl(SIOCGIFFLAGS): %m");
#line 136
    close(sockfd);
    }
#line 137
    return (-1);
  }
  {
#line 141
  ifr.ifr_ifru.ifru_flags = (short )((int )ifr.ifr_ifru.ifru_flags | set);
#line 142
  ifr.ifr_ifru.ifru_flags = (short )((int )ifr.ifr_ifru.ifru_flags & ~ clear);
#line 145
  strncpy((char */* __restrict  */)(ifr.ifr_ifrn.ifrn_name), (char const   */* __restrict  */)dev,
          (size_t )16);
#line 146
  tmp___0 = ioctl(sockfd, 35092UL, & ifr);
  }
#line 146
  if (tmp___0 < 0) {
    {
#line 147
    syslog(4, "ioctl(SIOCSIFFLAGS): %m");
#line 148
    close(sockfd);
    }
#line 149
    return (-1);
  }
  {
#line 151
  close(sockfd);
  }
#line 152
  return (0);
}
}
#line 161 "/home/june/repo/benchmarks/collector/temp/irda-utils-0.9.18/irattach/irattach.c"
__inline static int ifup(char *dev ) 
{ 
  int tmp ;

  {
  {
#line 163
  syslog(6, "Starting device %s", dev);
#line 164
  tmp = modify_flags(dev, 65, 0);
  }
#line 164
  return (tmp);
}
}
#line 173 "/home/june/repo/benchmarks/collector/temp/irda-utils-0.9.18/irattach/irattach.c"
__inline static int ifdown(char *dev ) 
{ 
  int tmp ;

  {
  {
#line 175
  syslog(6, "Stopping device %s", dev);
#line 176
  tmp = modify_flags(dev, 0, 1);
  }
#line 176
  return (tmp);
}
}
#line 234 "/home/june/repo/benchmarks/collector/temp/irda-utils-0.9.18/irattach/irattach.c"
__inline static void clean_exit(int status ) 
{ 


  {
  {
#line 236
  cleanup(status);
  }
#line 238
  return;
}
}
#line 240 "/home/june/repo/benchmarks/collector/temp/irda-utils-0.9.18/irattach/irattach.c"
static void print_usage(void) 
{ 
  int i ;

  {
  {
#line 243
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Usage: irattach <dev> [-d dongle] [-s] [-b] [-v] [-h]\n");
#line 244
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"       <dev> is tty name, device name or module name\n");
#line 245
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Dongles supported :\n");
#line 246
  i = 0;
  }
  {
#line 246
  while (1) {
    while_continue: /* CIL Label */ ;
#line 246
    if (! ((unsigned long )dongle_list[i].dongle != (unsigned long )((void *)0))) {
#line 246
      goto while_break;
    }
    {
#line 247
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t%s\n",
            dongle_list[i].dongle);
#line 246
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 248
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
  }
#line 249
  return;
}
}
#line 259 "/home/june/repo/benchmarks/collector/temp/irda-utils-0.9.18/irattach/irattach.c"
static int load_module(char *name ) 
{ 
  char msg[128] ;
  char cmd[512] ;
  int ret ;

  {
  {
#line 264
  sprintf((char */* __restrict  */)(msg), (char const   */* __restrict  */)"Trying to load module %s",
          name);
#line 265
  sprintf((char */* __restrict  */)(cmd), (char const   */* __restrict  */)"/sbin/modprobe %s",
          name);
#line 267
  ret = execute(msg, cmd);
  }
#line 269
  return (ret);
}
}
#line 276 "/home/june/repo/benchmarks/collector/temp/irda-utils-0.9.18/irattach/irattach.c"
static char *get_irdevname(char *name , int nsize , char *buf ) 
{ 
  char *end ;
  unsigned short const   **tmp ;
  int tmp___0 ;

  {
  {
#line 284
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 284
    tmp = __ctype_b_loc();
    }
#line 284
    if (! ((int const   )*(*tmp + (int )*buf) & 8192)) {
#line 284
      goto while_break;
    }
#line 285
    buf ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 288
  tmp___0 = strncmp((char const   *)buf, "irda", (size_t )4);
  }
#line 288
  if (tmp___0) {
#line 289
    return ((char *)((void *)0));
  }
  {
#line 291
  end = strchr((char const   *)buf, ':');
  }
#line 294
  if ((unsigned long )end == (unsigned long )((void *)0)) {
#line 295
    return ((char *)((void *)0));
  } else
#line 294
  if ((end - buf) + 1L > (long )nsize) {
#line 295
    return ((char *)((void *)0));
  }
  {
#line 298
  memcpy((void */* __restrict  */)name, (void const   */* __restrict  */)buf, (size_t )(end - buf));
#line 299
  *(name + (end - buf)) = (char )'\000';
  }
#line 301
  return (end + 2);
}
}
#line 310 "/home/june/repo/benchmarks/collector/temp/irda-utils-0.9.18/irattach/irattach.c"
static int get_devlist(char (*ifnames)[17] , int maxchars , int maxnames ) 
{ 
  char buff[1024] ;
  FILE *fh ;
  int ifnum ;
  char *tmp ;
  char *tmp___0 ;

  {
  {
#line 318
  fh = fopen((char const   */* __restrict  */)"/proc/net/dev", (char const   */* __restrict  */)"r");
  }
#line 320
  if ((unsigned long )fh == (unsigned long )((void *)0)) {
#line 321
    return (-1);
  }
  {
#line 324
  ifnum = 0;
#line 327
  fgets((char */* __restrict  */)(buff), (int )sizeof(buff), (FILE */* __restrict  */)fh);
#line 328
  fgets((char */* __restrict  */)(buff), (int )sizeof(buff), (FILE */* __restrict  */)fh);
  }
  {
#line 331
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 331
    tmp___0 = fgets((char */* __restrict  */)(buff), (int )sizeof(buff), (FILE */* __restrict  */)fh);
    }
#line 331
    if (! tmp___0) {
#line 331
      goto while_break;
    }
    {
#line 333
    tmp = get_irdevname(*(ifnames + ifnum), maxchars, buff);
    }
#line 333
    if (tmp) {
#line 334
      ifnum ++;
    }
#line 336
    if (ifnum > maxnames) {
      {
#line 337
      fclose(fh);
      }
#line 338
      return (-1);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 341
  fclose(fh);
  }
#line 342
  return (ifnum);
}
}
#line 351 "/home/june/repo/benchmarks/collector/temp/irda-utils-0.9.18/irattach/irattach.c"
__inline static int get_module_devices(char *modname ) 
{ 
  char before_names[10][17] ;
  int before_num ;
  char after_names[15][17] ;
  int after_num ;
  int firstone ;
  int pid ;
  int i ;
  int j ;
  int ret ;
  int tmp ;

  {
  {
#line 357
  firstone = -1;
#line 363
  before_num = get_devlist(before_names, 17, 10);
  }
#line 364
  if (before_num < 0) {
    {
#line 365
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Could not get device name list.\n");
#line 366
    exit(-1);
    }
  }
  {
#line 370
  ret = load_module(modname);
  }
#line 371
  if (ret) {
    {
#line 372
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Invalid module name [%s] !\n",
            device);
#line 373
    print_usage();
#line 374
    exit(-1);
    }
  }
  {
#line 378
  after_num = get_devlist(after_names, 17, 15);
  }
#line 379
  if (after_num <= 0) {
    {
#line 380
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Could not get device name list.\n");
#line 381
    exit(-1);
    }
  }
#line 385
  i = 0;
  {
#line 385
  while (1) {
    while_continue: /* CIL Label */ ;
#line 385
    if (! (i < after_num)) {
#line 385
      goto while_break;
    }
#line 387
    j = 0;
    {
#line 387
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 387
      if (! (j < before_num)) {
#line 387
        goto while_break___0;
      }
      {
#line 388
      tmp = strcmp((char const   *)(before_names[j]), (char const   *)(after_names[i]));
      }
#line 388
      if (! tmp) {
#line 389
        goto while_break___0;
      }
#line 387
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 392
    if (j == before_num) {
#line 394
      if (firstone >= 0) {
        {
#line 395
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Found additional interface [%s]\n",
                after_names[i]);
#line 400
        pid = fork();
        }
#line 402
        if (! pid) {
          {
#line 404
          strcpy((char */* __restrict  */)(device), (char const   */* __restrict  */)(after_names[i]));
          }
#line 406
          return (0);
        }
      } else {
        {
#line 413
        firstone = i;
#line 414
        strcpy((char */* __restrict  */)(device), (char const   */* __restrict  */)(after_names[i]));
#line 415
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Found interface [%s]\n",
                device);
        }
      }
    }
#line 385
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 420
  return (0);
}
}
#line 430 "/home/june/repo/benchmarks/collector/temp/irda-utils-0.9.18/irattach/irattach.c"
static void establish_irda(int ttyfd ) 
{ 
  int irdadisc ;
  int tmp ;
  int tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;

  {
  {
#line 432
  irdadisc = 11;
#line 434
  tmp = ioctl(ttyfd, 21516UL, 0);
  }
#line 434
  if (tmp < 0) {
    {
#line 435
    syslog(4, "ioctl(TIOCEXCL): %m");
    }
  }
  {
#line 438
  tmp___0 = ioctl(ttyfd, 21540UL, & initdisc);
  }
#line 438
  if (tmp___0 < 0) {
    {
#line 439
    syslog(3, "ioctl(TIOCGETD): %m");
#line 440
    clean_exit(-1);
    }
  }
  {
#line 443
  tmp___3 = ioctl(ttyfd, 21539UL, & irdadisc);
  }
#line 443
  if (tmp___3 < 0) {
    {
#line 444
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Maybe you don\'t have IrDA support in your kernel?\n");
#line 446
    tmp___1 = __errno_location();
#line 446
    tmp___2 = strerror(*tmp___1);
#line 446
    syslog(3, "irattach: tty: set_disc(%d): %s\n", irdadisc, tmp___2);
#line 448
    clean_exit(-1);
    }
  }
#line 450
  return;
}
}
#line 458 "/home/june/repo/benchmarks/collector/temp/irda-utils-0.9.18/irattach/irattach.c"
static int tty_configure(struct termios *tios ) 
{ 


  {
#line 460
  tios->c_cflag = (tcflag_t )2237;
#line 463
  tios->c_iflag = (tcflag_t )5;
#line 464
  tios->c_oflag = (tcflag_t )0;
#line 465
  tios->c_lflag = (tcflag_t )0;
#line 466
  tios->c_cc[6] = (cc_t )1;
#line 467
  tios->c_cc[5] = (cc_t )0;
#line 469
  return (0);
}
}
#line 478 "/home/june/repo/benchmarks/collector/temp/irda-utils-0.9.18/irattach/irattach.c"
static void init_irda_ldisc(int ttyfd ) 
{ 
  struct termios tios ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 483
  tmp = tcgetattr(ttyfd, & tios);
  }
#line 483
  if (tmp != 0) {
    {
#line 484
    syslog(3, "tcgetattr: %m");
#line 485
    clean_exit(-1);
    }
  }
  {
#line 488
  memcpy((void */* __restrict  */)(& termsave), (void const   */* __restrict  */)(& tios),
         sizeof(struct termios ));
#line 489
  termvalid = 0;
#line 491
  tty_configure(& tios);
#line 494
  tmp___0 = tcsetattr(ttyfd, 2, (struct termios  const  *)(& tios));
  }
#line 494
  if (tmp___0 < 0) {
    {
#line 495
    syslog(3, "tcsetattr: %m");
#line 496
    clean_exit(-1);
    }
  }
#line 498
  return;
}
}
#line 507 "/home/june/repo/benchmarks/collector/temp/irda-utils-0.9.18/irattach/irattach.c"
static void start_tty(int ttyfd ) 
{ 
  int cloexec ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 512
  fdflags &= -2049;
#line 513
  tmp = fcntl(ttyfd, 4, fdflags);
  }
#line 513
  if (tmp == -1) {
    {
#line 514
    syslog(4, "Couldn\'t set device fd flags: %m");
    }
  }
  {
#line 526
  cloexec = fcntl(devfd, 1);
  }
#line 526
  if (cloexec == -1) {
    {
#line 527
    syslog(3, "Couldn\'t get device fd close-on-exec flag: %m");
#line 529
    clean_exit(-1);
    }
  }
  {
#line 531
  cloexec |= 1;
#line 532
  tmp___0 = fcntl(devfd, 2, cloexec);
  }
#line 532
  if (tmp___0 == -1) {
    {
#line 533
    syslog(3, "Couldn\'t set device fd close-on-exec flag: %m");
#line 535
    clean_exit(-1);
    }
  }
  {
#line 539
  init_irda_ldisc(ttyfd);
#line 540
  establish_irda(ttyfd);
#line 543
  sleep(1U);
#line 548
  tmp___1 = fcntl(ttyfd, 4, fdflags | 2048);
  }
#line 548
  if (tmp___1 == -1) {
    {
#line 549
    syslog(3, "Couldn\'t set device to non-blocking mode: %m");
#line 551
    clean_exit(-1);
    }
  }
#line 553
  return;
}
}
#line 562 "/home/june/repo/benchmarks/collector/temp/irda-utils-0.9.18/irattach/irattach.c"
static int open_tty(char *dev ) 
{ 
  int ttyfd ;
  int *tmp ;
  char *tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;

  {
  {
#line 567
  ttyfd = open((char const   *)dev, 2050, 0);
  }
#line 568
  if (ttyfd < 0) {
    {
#line 569
    tmp = __errno_location();
#line 569
    tmp___0 = strerror(*tmp);
#line 569
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Failed to open device %s: %s\n",
            dev, tmp___0);
#line 571
    exit(-1);
    }
  }
  {
#line 577
  fdflags = fcntl(ttyfd, 3);
  }
#line 577
  if (fdflags == -1) {
    {
#line 578
    tmp___1 = __errno_location();
#line 578
    tmp___2 = strerror(*tmp___1);
#line 578
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Couldn\'t get device %s flags: %s\n",
            dev, tmp___2);
#line 580
    close(ttyfd);
#line 581
    exit(-1);
    }
  }
#line 583
  initfdflags = fdflags;
#line 585
  return (ttyfd);
}
}
#line 596 "/home/june/repo/benchmarks/collector/temp/irda-utils-0.9.18/irattach/irattach.c"
__inline static void attach_dongle(int ttyfd , char *dev , int dongle ) 
{ 
  int sockfd ;
  struct ifreq ifr ;
  int tmp ;

  {
#line 600
  if (ttyfd != -1) {
    {
#line 602
    ioctl(ttyfd, (unsigned long )((unsigned int )(101 << 8) | 1U), dongle);
    }
  } else {
    {
#line 609
    sockfd = socket(23, 1, 0);
    }
#line 610
    if (sockfd < 0) {
      {
#line 611
      perror("socket");
#line 612
      clean_exit(-1);
      }
    }
    {
#line 616
    ifr.ifr_ifru.ifru_data = (__caddr_t )((void *)dongle);
#line 617
    strncpy((char */* __restrict  */)(ifr.ifr_ifrn.ifrn_name), (char const   */* __restrict  */)dev,
            (size_t )16);
#line 618
    tmp = ioctl(sockfd, 35312UL, & ifr);
    }
#line 618
    if (tmp < 0) {
      {
#line 619
      perror("ioctl");
#line 620
      close(sockfd);
#line 621
      clean_exit(-1);
      }
    }
    {
#line 625
    close(sockfd);
    }
  }
#line 627
  return;
}
}
#line 635 "/home/june/repo/benchmarks/collector/temp/irda-utils-0.9.18/irattach/irattach.c"
__inline static int get_dongle(char *dongle ) 
{ 
  int i ;
  int tmp ;

  {
#line 638
  i = 0;
  {
#line 638
  while (1) {
    while_continue: /* CIL Label */ ;
#line 638
    if (! ((unsigned long )dongle_list[i].dongle != (unsigned long )((void *)0))) {
#line 638
      goto while_break;
    }
    {
#line 639
    tmp = strcmp((char const   *)dongle_list[i].dongle, (char const   *)dongle);
    }
#line 639
    if (tmp == 0) {
#line 640
      return (dongle_list[i].id);
    }
#line 638
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 642
  return (-1);
}
}
#line 433 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) sscanf)(char const   * __restrict  __s ,
                                                                             char const   * __restrict  __format 
                                                                             , ...)  __asm__("__isoc99_sscanf")  ;
#line 873
extern FILE *popen(char const   *__command , char const   *__modes ) ;
#line 879
extern int pclose(FILE *__stream ) ;
#line 137 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcat)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 399
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 460 "/usr/include/unistd.h"
extern int usleep(__useconds_t __useconds ) ;
#line 628
extern  __attribute__((__nothrow__)) __pid_t ( __attribute__((__leaf__)) getpid)(void) ;
#line 667
extern  __attribute__((__nothrow__)) __pid_t ( __attribute__((__leaf__)) setsid)(void) ;
#line 21 "/home/june/repo/benchmarks/collector/temp/irda-utils-0.9.18/irattach/util.c"
int be_quiet  =    1;
#line 22 "/home/june/repo/benchmarks/collector/temp/irda-utils-0.9.18/irattach/util.c"
int caught_signal  =    0;
#line 30 "/home/june/repo/benchmarks/collector/temp/irda-utils-0.9.18/irattach/util.c"
void beep(unsigned int ms , unsigned int freq ) 
{ 
  int fd ;
  int arg ;

  {
#line 34
  if (be_quiet) {
#line 35
    return;
  }
  {
#line 36
  fd = open("/dev/console", 2);
  }
#line 37
  if (fd < 0) {
#line 38
    return;
  }
  {
#line 39
  arg = (int )((ms << 16) | freq);
#line 40
  ioctl(fd, 19248UL, arg);
#line 41
  close(fd);
#line 42
  usleep(ms * 1000U);
  }
#line 43
  return;
}
}
#line 72 "/home/june/repo/benchmarks/collector/temp/irda-utils-0.9.18/irattach/util.c"
int lookup_dev(char *name ) 
{ 
  FILE *f ;
  int n ;
  char s[32] ;
  char t[32] ;
  int *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;

  {
  {
#line 78
  f = fopen((char const   */* __restrict  */)"/proc/misc", (char const   */* __restrict  */)"r");
  }
#line 79
  if ((unsigned long )f == (unsigned long )((void *)0)) {
    {
#line 80
    tmp = __errno_location();
    }
#line 80
    return (- *tmp);
  }
  {
#line 81
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 81
    tmp___2 = fgets((char */* __restrict  */)(s), 32, (FILE */* __restrict  */)f);
    }
#line 81
    if (! ((unsigned long )tmp___2 != (unsigned long )((void *)0))) {
#line 81
      goto while_break;
    }
    {
#line 82
    tmp___1 = sscanf((char const   */* __restrict  */)(s), (char const   */* __restrict  */)"%d %s",
                     & n, t);
    }
#line 82
    if (tmp___1 == 2) {
      {
#line 83
      tmp___0 = strcmp((char const   *)name, (char const   *)(t));
      }
#line 83
      if (tmp___0 == 0) {
#line 84
        goto while_break;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 86
  fclose(f);
#line 87
  tmp___3 = strcmp((char const   *)name, (char const   *)(t));
  }
#line 87
  if (tmp___3 == 0) {
#line 88
    return (n);
  } else {
#line 90
    return (-19);
  }
}
}
#line 93 "/home/june/repo/benchmarks/collector/temp/irda-utils-0.9.18/irattach/util.c"
int execute(char *msg , char *cmd ) 
{ 
  int ret ;
  FILE *f ;
  char line[256] ;
  size_t tmp ;
  char *tmp___0 ;
  union __anonunion_52 __constr_expr_0 ;
  union __anonunion_53 __constr_expr_1 ;
  union __anonunion_54 __constr_expr_2 ;
  union __anonunion_55 __constr_expr_3 ;
  union __anonunion_56 __constr_expr_4 ;

  {
  {
#line 99
  syslog(6, "executing: \'%s\'", cmd);
#line 100
  strcat((char */* __restrict  */)cmd, (char const   */* __restrict  */)" 2>&1");
#line 101
  f = popen((char const   *)cmd, "r");
  }
  {
#line 102
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 102
    tmp___0 = fgets((char */* __restrict  */)(line), 255, (FILE */* __restrict  */)f);
    }
#line 102
    if (! tmp___0) {
#line 102
      goto while_break;
    }
    {
#line 103
    tmp = strlen((char const   *)(line));
#line 103
    line[tmp - 1UL] = (char )'\000';
#line 104
    syslog(6, "+ %s", line);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 106
  ret = pclose(f);
#line 107
  __constr_expr_4.__in = ret;
  }
#line 107
  if ((__constr_expr_4.__i & 127) == 0) {
#line 108
    __constr_expr_1.__in = ret;
#line 108
    if ((__constr_expr_1.__i & 65280) >> 8) {
      {
#line 109
      __constr_expr_0.__in = ret;
#line 109
      syslog(6, "%s exited with status %d", msg, (__constr_expr_0.__i & 65280) >> 8);
      }
    }
#line 111
    __constr_expr_2.__in = ret;
#line 111
    return ((__constr_expr_2.__i & 65280) >> 8);
  } else {
    {
#line 113
    __constr_expr_3.__in = ret;
#line 113
    syslog(6, "%s exited on signal %d", msg, __constr_expr_3.__i & 127);
    }
  }
#line 115
  return (-1);
}
}
#line 118 "/home/june/repo/benchmarks/collector/temp/irda-utils-0.9.18/irattach/util.c"
int execute_on_dev(char *action , char *class , char *dev , int minor ) 
{ 
  char msg[128] ;
  char cmd[512] ;
  int tmp ;

  {
  {
#line 122
  sprintf((char */* __restrict  */)(msg), (char const   */* __restrict  */)"%s cmd",
          action);
#line 123
  sprintf((char */* __restrict  */)(cmd), (char const   */* __restrict  */)"./%s %s %s %d",
          class, action, dev, minor);
#line 125
  tmp = execute(msg, cmd);
  }
#line 125
  return (tmp);
}
}
#line 134 "/home/june/repo/benchmarks/collector/temp/irda-utils-0.9.18/irattach/util.c"
int set_sysctl_param(char *name , char *value ) 
{ 
  char msg[128] ;
  char cmd[512] ;
  int tmp ;

  {
  {
#line 138
  sprintf((char */* __restrict  */)(msg), (char const   */* __restrict  */)"Setting %s to %s",
          name, value);
#line 139
  sprintf((char */* __restrict  */)(cmd), (char const   */* __restrict  */)"echo %s > /proc/sys/net/irda/%s",
          value, name);
#line 141
  tmp = execute(msg, cmd);
  }
#line 141
  return (tmp);
}
}
#line 145 "/home/june/repo/benchmarks/collector/temp/irda-utils-0.9.18/irattach/util.c"
void write_pid(void) 
{ 
  FILE *f ;
  __pid_t tmp ;

  {
  {
#line 148
  f = fopen((char const   */* __restrict  */)pidfile, (char const   */* __restrict  */)"w");
  }
#line 149
  if ((unsigned long )f == (unsigned long )((void *)0)) {
    {
#line 150
    syslog(6, "could not open %s: %m", pidfile);
    }
  } else {
    {
#line 152
    tmp = getpid();
#line 152
    fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"%d\n", tmp);
#line 153
    fclose(f);
    }
  }
#line 155
  return;
}
}
#line 157 "/home/june/repo/benchmarks/collector/temp/irda-utils-0.9.18/irattach/util.c"
void fork_now(int ttyfd ) 
{ 
  int ret ;
  int i ;
  __pid_t tmp ;

  {
  {
#line 162
  ret = fork();
  }
#line 162
  if (ret > 0) {
    {
#line 163
    exit(0);
    }
  }
#line 165
  if (ret == -1) {
    {
#line 166
    syslog(6, "forking: %m");
    }
  }
  {
#line 167
  tmp = setsid();
  }
#line 167
  if (tmp < 0) {
    {
#line 168
    syslog(6, "detaching from tty: %m");
    }
  }
  {
#line 170
  ret = fork();
  }
#line 170
  if (ret > 0) {
    {
#line 172
    exit(0);
    }
  }
#line 176
  i = 0;
  {
#line 176
  while (1) {
    while_continue: /* CIL Label */ ;
#line 176
    if (! (i < 64)) {
#line 176
      goto while_break;
    }
#line 177
    if (i != ttyfd) {
      {
#line 178
      close(i);
      }
    }
#line 176
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 180
  write_pid();
  }
#line 181
  return;
}
}
