/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 133 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __pid_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 141 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __suseconds_t;
#line 175 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __syscall_slong_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 66 "/usr/include/x86_64-linux-gnu/bits/waitstatus.h"
struct __anonstruct___wait_terminated_10 {
   unsigned int __w_termsig : 7 ;
   unsigned int __w_coredump : 1 ;
   unsigned int __w_retcode : 8 ;
   unsigned int  : 16 ;
};
#line 66 "/usr/include/x86_64-linux-gnu/bits/waitstatus.h"
struct __anonstruct___wait_stopped_11 {
   unsigned int __w_stopval : 8 ;
   unsigned int __w_stopsig : 8 ;
   unsigned int  : 16 ;
};
#line 66 "/usr/include/x86_64-linux-gnu/bits/waitstatus.h"
union wait {
   int w_status ;
   struct __anonstruct___wait_terminated_10 __wait_terminated ;
   struct __anonstruct___wait_stopped_11 __wait_stopped ;
};
#line 30 "/usr/include/x86_64-linux-gnu/bits/time.h"
struct timeval {
   __time_t tv_sec ;
   __suseconds_t tv_usec ;
};
#line 85 "/usr/include/signal.h"
typedef void (*__sighandler_t)(int  );
#line 155 "/usr/include/x86_64-linux-gnu/sys/wait.h"
struct rusage;
#line 187 "/usr/include/x86_64-linux-gnu/bits/resource.h"
union __anonunion____missing_field_name_52 {
   long ru_maxrss ;
   __syscall_slong_t __ru_maxrss_word ;
};
#line 187 "/usr/include/x86_64-linux-gnu/bits/resource.h"
union __anonunion____missing_field_name_53 {
   long ru_ixrss ;
   __syscall_slong_t __ru_ixrss_word ;
};
#line 187 "/usr/include/x86_64-linux-gnu/bits/resource.h"
union __anonunion____missing_field_name_54 {
   long ru_idrss ;
   __syscall_slong_t __ru_idrss_word ;
};
#line 187 "/usr/include/x86_64-linux-gnu/bits/resource.h"
union __anonunion____missing_field_name_55 {
   long ru_isrss ;
   __syscall_slong_t __ru_isrss_word ;
};
#line 187 "/usr/include/x86_64-linux-gnu/bits/resource.h"
union __anonunion____missing_field_name_56 {
   long ru_minflt ;
   __syscall_slong_t __ru_minflt_word ;
};
#line 187 "/usr/include/x86_64-linux-gnu/bits/resource.h"
union __anonunion____missing_field_name_57 {
   long ru_majflt ;
   __syscall_slong_t __ru_majflt_word ;
};
#line 187 "/usr/include/x86_64-linux-gnu/bits/resource.h"
union __anonunion____missing_field_name_58 {
   long ru_nswap ;
   __syscall_slong_t __ru_nswap_word ;
};
#line 187 "/usr/include/x86_64-linux-gnu/bits/resource.h"
union __anonunion____missing_field_name_59 {
   long ru_inblock ;
   __syscall_slong_t __ru_inblock_word ;
};
#line 187 "/usr/include/x86_64-linux-gnu/bits/resource.h"
union __anonunion____missing_field_name_60 {
   long ru_oublock ;
   __syscall_slong_t __ru_oublock_word ;
};
#line 187 "/usr/include/x86_64-linux-gnu/bits/resource.h"
union __anonunion____missing_field_name_61 {
   long ru_msgsnd ;
   __syscall_slong_t __ru_msgsnd_word ;
};
#line 187 "/usr/include/x86_64-linux-gnu/bits/resource.h"
union __anonunion____missing_field_name_62 {
   long ru_msgrcv ;
   __syscall_slong_t __ru_msgrcv_word ;
};
#line 187 "/usr/include/x86_64-linux-gnu/bits/resource.h"
union __anonunion____missing_field_name_63 {
   long ru_nsignals ;
   __syscall_slong_t __ru_nsignals_word ;
};
#line 187 "/usr/include/x86_64-linux-gnu/bits/resource.h"
union __anonunion____missing_field_name_64 {
   long ru_nvcsw ;
   __syscall_slong_t __ru_nvcsw_word ;
};
#line 187 "/usr/include/x86_64-linux-gnu/bits/resource.h"
union __anonunion____missing_field_name_65 {
   long ru_nivcsw ;
   __syscall_slong_t __ru_nivcsw_word ;
};
#line 187 "/usr/include/x86_64-linux-gnu/bits/resource.h"
struct rusage {
   struct timeval ru_utime ;
   struct timeval ru_stime ;
   union __anonunion____missing_field_name_52 __annonCompField2 ;
   union __anonunion____missing_field_name_53 __annonCompField3 ;
   union __anonunion____missing_field_name_54 __annonCompField4 ;
   union __anonunion____missing_field_name_55 __annonCompField5 ;
   union __anonunion____missing_field_name_56 __annonCompField6 ;
   union __anonunion____missing_field_name_57 __annonCompField7 ;
   union __anonunion____missing_field_name_58 __annonCompField8 ;
   union __anonunion____missing_field_name_59 __annonCompField9 ;
   union __anonunion____missing_field_name_60 __annonCompField10 ;
   union __anonunion____missing_field_name_61 __annonCompField11 ;
   union __anonunion____missing_field_name_62 __annonCompField12 ;
   union __anonunion____missing_field_name_63 __annonCompField13 ;
   union __anonunion____missing_field_name_64 __annonCompField14 ;
   union __anonunion____missing_field_name_65 __annonCompField15 ;
};
#line 31 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned short __u_short;
#line 124 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __dev_t;
#line 125 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uid_t;
#line 126 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __gid_t;
#line 127 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __ino_t;
#line 129 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __mode_t;
#line 130 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __nlink_t;
#line 153 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blksize_t;
#line 158 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blkcnt_t;
#line 189 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __socklen_t;
#line 34 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __u_short u_short;
#line 120 "/usr/include/time.h"
struct timespec {
   __time_t tv_sec ;
   __syscall_slong_t tv_nsec ;
};
#line 274 "/usr/include/unistd.h"
typedef __socklen_t socklen_t;
#line 49 "/usr/include/stdint.h"
typedef unsigned short uint16_t;
#line 51 "/usr/include/stdint.h"
typedef unsigned int uint32_t;
#line 28 "/usr/include/x86_64-linux-gnu/bits/sockaddr.h"
typedef unsigned short sa_family_t;
#line 149 "/usr/include/x86_64-linux-gnu/bits/socket.h"
struct sockaddr {
   sa_family_t sa_family ;
   char sa_data[14] ;
};
#line 30 "/usr/include/netinet/in.h"
typedef uint32_t in_addr_t;
#line 31 "/usr/include/netinet/in.h"
struct in_addr {
   in_addr_t s_addr ;
};
#line 117 "/usr/include/netinet/in.h"
typedef uint16_t in_port_t;
#line 237 "/usr/include/netinet/in.h"
struct sockaddr_in {
   sa_family_t sin_family ;
   in_port_t sin_port ;
   struct in_addr sin_addr ;
   unsigned char sin_zero[((sizeof(struct sockaddr ) - sizeof(unsigned short )) - sizeof(in_port_t )) - sizeof(struct in_addr )] ;
};
#line 29 "/usr/include/x86_64-linux-gnu/sys/un.h"
struct sockaddr_un {
   sa_family_t sun_family ;
   char sun_path[108] ;
};
#line 46 "/usr/include/x86_64-linux-gnu/bits/stat.h"
struct stat {
   __dev_t st_dev ;
   __ino_t st_ino ;
   __nlink_t st_nlink ;
   __mode_t st_mode ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   int __pad0 ;
   __dev_t st_rdev ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   __syscall_slong_t __glibc_reserved[3] ;
};
#line 100 "/usr/include/netdb.h"
struct hostent {
   char *h_name ;
   char **h_aliases ;
   int h_addrtype ;
   int h_length ;
   char **h_addr_list ;
};
#line 257 "/usr/include/netdb.h"
struct servent {
   char *s_name ;
   char **s_aliases ;
   int s_port ;
   char *s_proto ;
};
#line 218 "/home/june/repo/benchmarks/collector/temp/socket-1.1/socket.c"
union __anonunion_peer_35 {
   struct sockaddr_in sa ;
   struct sockaddr_un su ;
};
#line 172 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __ssize_t;
#line 220 "/usr/include/unistd.h"
typedef __ssize_t ssize_t;
#line 54 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef long __fd_mask;
#line 64 "/usr/include/x86_64-linux-gnu/sys/select.h"
struct __anonstruct_fd_set_13 {
   __fd_mask __fds_bits[1024 / (8 * (int )sizeof(__fd_mask ))] ;
};
#line 64 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef struct __anonstruct_fd_set_13 fd_set;
#line 364 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
#line 466 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 399 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 38 "/home/june/repo/benchmarks/collector/temp/socket-1.1/siglist.c"
char *socket_siglist[65]  ;
#line 42 "/home/june/repo/benchmarks/collector/temp/socket-1.1/siglist.c"
void initialize_siglist(void) 
{ 
  register int i ;
  size_t tmp ;
  void *tmp___0 ;

  {
#line 46
  i = 0;
  {
#line 46
  while (1) {
    while_continue: /* CIL Label */ ;
#line 46
    if (! (i < 65)) {
#line 46
      goto while_break;
    }
#line 47
    socket_siglist[i] = (char *)0;
#line 46
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 49
  socket_siglist[0] = (char *)"Bogus signal";
#line 52
  socket_siglist[1] = (char *)"Hangup signal";
#line 56
  socket_siglist[2] = (char *)"Interrupt";
#line 60
  socket_siglist[3] = (char *)"Quit signal";
#line 64
  socket_siglist[4] = (char *)"Illegal instruction";
#line 68
  socket_siglist[5] = (char *)"BPT trace/trap";
#line 76
  socket_siglist[6] = (char *)"ABORT instruction";
#line 84
  socket_siglist[8] = (char *)"Floating point exception";
#line 88
  socket_siglist[9] = (char *)"Kill signal";
#line 92
  socket_siglist[7] = (char *)"Bus error";
#line 96
  socket_siglist[11] = (char *)"Segmentation fault";
#line 100
  socket_siglist[31] = (char *)"Bad system call";
#line 104
  socket_siglist[13] = (char *)"Broken pipe condition";
#line 108
  socket_siglist[14] = (char *)"Alarm clock signal";
#line 112
  socket_siglist[15] = (char *)"Termination signal";
#line 116
  socket_siglist[23] = (char *)"Urgent IO condition";
#line 120
  socket_siglist[19] = (char *)"Stop signal";
#line 124
  socket_siglist[20] = (char *)"Stopped";
#line 128
  socket_siglist[18] = (char *)"Continue signal";
#line 136
  socket_siglist[17] = (char *)"Child signal";
#line 140
  socket_siglist[21] = (char *)"Stop (tty input) signal";
#line 144
  socket_siglist[22] = (char *)"Stop (tty output) signal";
#line 148
  socket_siglist[29] = (char *)"I/O ready signal";
#line 152
  socket_siglist[24] = (char *)"CPU limit exceeded";
#line 156
  socket_siglist[25] = (char *)"File limit exceeded";
#line 160
  socket_siglist[26] = (char *)"Alarm (virtual)";
#line 164
  socket_siglist[27] = (char *)"Alarm (profile)";
#line 168
  socket_siglist[28] = (char *)"Window change";
#line 176
  socket_siglist[10] = (char *)"User signal 1";
#line 180
  socket_siglist[12] = (char *)"User signal 2";
#line 188
  socket_siglist[30] = (char *)"power failure imminent signal";
#line 215
  i = 0;
  {
#line 215
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 215
    if (! (i < 65)) {
#line 215
      goto while_break___0;
    }
#line 217
    if (! socket_siglist[i]) {
      {
#line 219
      tmp = strlen("Unknown Signal #");
#line 219
      tmp___0 = malloc(10UL + tmp);
#line 219
      socket_siglist[i] = (char *)tmp___0;
#line 222
      sprintf((char */* __restrict  */)socket_siglist[i], (char const   */* __restrict  */)"Unknown Signal #%d",
              i);
      }
    }
#line 215
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 225
  return;
}
}
#line 170 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 846
extern void perror(char const   *__s ) ;
#line 353 "/usr/include/unistd.h"
extern int close(int __fd ) ;
#line 417
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) pipe)(int *__pipedes ) ;
#line 497
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) chdir)(char const   *__path ) ;
#line 534
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) dup2)(int __fd ,
                                                                           int __fd2 ) ;
#line 573
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) execl)(char const   *__path ,
                                                                                              char const   *__arg 
                                                                                              , ...) ;
#line 631
extern  __attribute__((__nothrow__)) __pid_t ( __attribute__((__leaf__)) getppid)(void) ;
#line 667
extern  __attribute__((__nothrow__)) __pid_t ( __attribute__((__leaf__)) setsid)(void) ;
#line 756
extern  __attribute__((__nothrow__)) __pid_t fork(void) ;
#line 779
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) isatty)(int __fd ) ;
#line 543 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 102 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) __sighandler_t ( __attribute__((__leaf__)) signal)(int __sig ,
                                                                                        void (*__handler)(int  ) ) ;
#line 127
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) kill)(__pid_t __pid ,
                                                                           int __sig ) ;
#line 162 "/usr/include/x86_64-linux-gnu/sys/wait.h"
extern  __attribute__((__nothrow__)) __pid_t wait3(union wait *__stat_loc , int __options ,
                                                   struct rusage *__usage ) ;
#line 146 "/usr/include/fcntl.h"
extern int ( __attribute__((__nonnull__(1))) open)(char const   *__file , int __oflag 
                                                   , ...) ;
#line 50 "/usr/include/x86_64-linux-gnu/bits/errno.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
#line 32 "/home/june/repo/benchmarks/collector/temp/socket-1.1/globals.h"
void usage(void) ;
#line 37
void open_pipes(char *prog ) ;
#line 38
void wait_for_children(void) ;
#line 39
void perror2(char *s ) ;
#line 40
int is_number(char *s ) ;
#line 41
void init_signals(void) ;
#line 42
void add_crs(char *from , char *to , int *sizep ) ;
#line 43
void strip_crs(char *from , char *to , int *sizep ) ;
#line 44
void background(void) ;
#line 58
char *progname ;
#line 36 "/home/june/repo/benchmarks/collector/temp/socket-1.1/utils.c"
void exitsig(int sig ) 
{ 


  {
#line 39
  if (sig != 10) {
    {
#line 40
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n%s occured, exiting\n",
            socket_siglist[sig]);
    }
  }
  {
#line 42
  exit(- sig);
  }
}
}
#line 48 "/home/june/repo/benchmarks/collector/temp/socket-1.1/utils.c"
static char ustring[76]  = 
#line 48
  {      (char )'U',      (char )'s',      (char )'a',      (char )'g', 
        (char )'e',      (char )':',      (char )' ',      (char )'%', 
        (char )'s',      (char )' ',      (char )'[',      (char )'-', 
        (char )'b',      (char )'c',      (char )'l',      (char )'q', 
        (char )'r',      (char )'v',      (char )'w',      (char )']', 
        (char )' ',      (char )'[',      (char )'-',      (char )'B', 
        (char )' ',      (char )'l',      (char )'o',      (char )'c', 
        (char )'a',      (char )'l',      (char )' ',      (char )'i', 
        (char )'p',      (char )']',      (char )' ',      (char )'[', 
        (char )'-',      (char )'p',      (char )' ',      (char )'p', 
        (char )'r',      (char )'o',      (char )'g',      (char )']', 
        (char )' ',      (char )'{',      (char )'{',      (char )'-', 
        (char )'s',      (char )'|',      (char )'h',      (char )'o', 
        (char )'s',      (char )'t',      (char )'}',      (char )' ', 
        (char )'p',      (char )'o',      (char )'r',      (char )'t', 
        (char )' ',      (char )'|',      (char )' ',      (char )'[', 
        (char )'-',      (char )'s',      (char )']',      (char )' ', 
        (char )'/',      (char )'p',      (char )'a',      (char )'t', 
        (char )'h',      (char )'}',      (char )'\n',      (char )'\000'};
#line 46 "/home/june/repo/benchmarks/collector/temp/socket-1.1/utils.c"
void usage(void) 
{ 


  {
  {
#line 51
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)(ustring),
          progname);
  }
#line 52
  return;
}
}
#line 55 "/home/june/repo/benchmarks/collector/temp/socket-1.1/utils.c"
void perror2(char *s ) 
{ 


  {
  {
#line 58
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: ",
          progname);
#line 59
  perror((char const   *)s);
  }
#line 60
  return;
}
}
#line 63 "/home/june/repo/benchmarks/collector/temp/socket-1.1/utils.c"
int is_number(char *s ) 
{ 


  {
  {
#line 66
  while (1) {
    while_continue: /* CIL Label */ ;
#line 66
    if (! *s) {
#line 66
      goto while_break;
    }
#line 67
    if ((int )*s < 48) {
#line 68
      return (0);
    } else
#line 67
    if ((int )*s > 57) {
#line 68
      return (0);
    }
#line 70
    s ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 72
  return (1);
}
}
#line 77 "/home/june/repo/benchmarks/collector/temp/socket-1.1/utils.c"
void init_signals(void) 
{ 
  int i ;

  {
  {
#line 84
  initialize_siglist();
#line 86
  i = 0;
  }
  {
#line 86
  while (1) {
    while_continue: /* CIL Label */ ;
#line 86
    if (! (i < 65)) {
#line 86
      goto while_break;
    }
    {
#line 93
    if (i == 18) {
#line 93
      goto case_18;
    }
#line 93
    if (i == 19) {
#line 93
      goto case_18;
    }
#line 93
    if (i == 21) {
#line 93
      goto case_18;
    }
#line 93
    if (i == 22) {
#line 93
      goto case_18;
    }
#line 93
    if (i == 20) {
#line 93
      goto case_18;
    }
#line 100
    if (i == 17) {
#line 100
      goto case_17;
    }
#line 104
    if (i == 28) {
#line 104
      goto case_28;
    }
#line 107
    if (i == 3) {
#line 107
      goto case_3;
    }
#line 109
    goto switch_default;
    case_18: /* CIL Label */ 
    case_19: /* CIL Label */ 
    case_21: /* CIL Label */ 
    case_22: /* CIL Label */ 
    case_20: /* CIL Label */ 
#line 94
    goto __Cont;
    case_17: /* CIL Label */ 
#line 101
    goto __Cont;
    case_28: /* CIL Label */ 
#line 105
    goto __Cont;
    case_3: /* CIL Label */ 
#line 108
    goto __Cont;
    switch_default: /* CIL Label */ 
    {
#line 113
    signal(i, & exitsig);
    }
    switch_break: /* CIL Label */ ;
    }
    __Cont: /* CIL Label */ 
#line 86
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 117
  return;
}
}
#line 121 "/home/june/repo/benchmarks/collector/temp/socket-1.1/utils.c"
void open_pipes(char *prog ) 
{ 
  int from_cld[2] ;
  int to_cld[2] ;
  int *tmp ;
  int tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;
  __pid_t tmp___3 ;
  __pid_t tmp___4 ;
  int *tmp___5 ;

  {
  {
#line 128
  tmp___0 = pipe((int *)(from_cld));
  }
#line 128
  if (tmp___0 == -1) {
    {
#line 129
    perror2((char *)"pipe");
#line 130
    tmp = __errno_location();
#line 130
    exit(*tmp);
    }
  }
  {
#line 132
  tmp___2 = pipe((int *)(to_cld));
  }
#line 132
  if (tmp___2 == -1) {
    {
#line 133
    perror2((char *)"pipe");
#line 134
    tmp___1 = __errno_location();
#line 134
    exit(*tmp___1);
    }
  }
  {
#line 138
  tmp___3 = fork();
  }
  {
#line 139
  if (tmp___3 == 0) {
#line 139
    goto case_0;
  }
#line 159
  if (tmp___3 == -1) {
#line 159
    goto case_neg_1;
  }
#line 162
  goto switch_default;
  case_0: /* CIL Label */ 
  {
#line 141
  close(0);
#line 142
  close(to_cld[1]);
#line 143
  dup2(to_cld[0], 0);
#line 144
  close(to_cld[0]);
#line 146
  close(1);
#line 147
  close(from_cld[0]);
#line 148
  dup2(from_cld[1], 1);
#line 150
  close(2);
#line 151
  dup2(from_cld[1], 2);
#line 152
  close(from_cld[1]);
#line 154
  execl("/bin/sh", "sh", "-c", prog, (void *)0);
#line 155
  perror2((char *)"exec /bin/sh");
#line 157
  tmp___4 = getppid();
#line 157
  kill(tmp___4, 10);
#line 158
  exit(255);
  }
  case_neg_1: /* CIL Label */ 
  {
#line 160
  perror2((char *)"fork");
#line 161
  tmp___5 = __errno_location();
#line 161
  exit(*tmp___5);
  }
  switch_default: /* CIL Label */ 
  {
#line 164
  close(0);
#line 165
  close(from_cld[1]);
#line 166
  dup2(from_cld[0], 0);
#line 167
  close(from_cld[0]);
#line 169
  close(1);
#line 170
  close(to_cld[0]);
#line 171
  dup2(to_cld[1], 1);
#line 172
  close(to_cld[1]);
  }
  switch_break: /* CIL Label */ ;
  }
#line 174
  return;
}
}
#line 177 "/home/june/repo/benchmarks/collector/temp/socket-1.1/utils.c"
void wait_for_children(void) 
{ 
  int wret ;
  int status ;
  struct rusage rusage ;

  {
  {
#line 186
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 186
    wret = wait3((union wait *)(& status), 1, & rusage);
    }
#line 186
    if (! (wret > 0)) {
#line 186
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 190
  return;
}
}
#line 193 "/home/june/repo/benchmarks/collector/temp/socket-1.1/utils.c"
void add_crs(char *from , char *to , int *sizep ) 
{ 
  int countdown ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;

  {
#line 199
  countdown = *sizep;
  {
#line 200
  while (1) {
    while_continue: /* CIL Label */ ;
#line 200
    if (! countdown) {
#line 200
      goto while_break;
    }
#line 201
    if ((int )*from == 10) {
#line 202
      tmp = to;
#line 202
      to ++;
#line 202
      *tmp = (char )'\r';
#line 203
      (*sizep) ++;
    }
#line 205
    tmp___0 = to;
#line 205
    to ++;
#line 205
    tmp___1 = from;
#line 205
    from ++;
#line 205
    *tmp___0 = *tmp___1;
#line 206
    countdown --;
  }
  while_break: /* CIL Label */ ;
  }
#line 208
  return;
}
}
#line 211 "/home/june/repo/benchmarks/collector/temp/socket-1.1/utils.c"
void strip_crs(char *from , char *to , int *sizep ) 
{ 
  int countdown ;
  char *tmp ;
  char *tmp___0 ;

  {
#line 218
  countdown = *sizep;
  {
#line 219
  while (1) {
    while_continue: /* CIL Label */ ;
#line 219
    if (! countdown) {
#line 219
      goto while_break;
    }
#line 220
    if ((int )*from == 13) {
#line 221
      from ++;
#line 222
      (*sizep) --;
    } else {
#line 224
      tmp = to;
#line 224
      to ++;
#line 224
      tmp___0 = from;
#line 224
      from ++;
#line 224
      *tmp = *tmp___0;
    }
#line 226
    countdown --;
  }
  while_break: /* CIL Label */ ;
  }
#line 228
  return;
}
}
#line 233 "/home/june/repo/benchmarks/collector/temp/socket-1.1/utils.c"
void background(void) 
{ 
  int child_pid ;
  int nulldev_fd ;
  int i ;
  int tmp ;

  {
  {
#line 238
  child_pid = fork();
  }
  {
#line 240
  if (child_pid == -1) {
#line 240
    goto case_neg_1;
  }
#line 243
  if (child_pid == 0) {
#line 243
    goto case_0;
  }
#line 261
  goto switch_default;
  case_neg_1: /* CIL Label */ 
  {
#line 241
  perror2((char *)"fork");
#line 242
  exit(1);
  }
  case_0: /* CIL Label */ 
  {
#line 247
  setsid();
#line 249
  chdir("/");
#line 250
  nulldev_fd = open("/dev/null", 2, 0);
  }
#line 250
  if (nulldev_fd != -1) {
#line 253
    i = 0;
    {
#line 253
    while (1) {
      while_continue: /* CIL Label */ ;
#line 253
      if (! (i < 3)) {
#line 253
        goto while_break;
      }
      {
#line 254
      tmp = isatty(i);
      }
#line 254
      if (tmp) {
        {
#line 255
        dup2(nulldev_fd, i);
        }
      }
#line 253
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 258
    close(nulldev_fd);
    }
  }
#line 260
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 262
  exit(0);
  }
  switch_break: /* CIL Label */ ;
  }
#line 264
  return;
}
}
#line 132 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strncpy)(char * __restrict  __dest ,
                                                                                                  char const   * __restrict  __src ,
                                                                                                  size_t __n ) ;
#line 455
extern  __attribute__((__nothrow__)) void ( __attribute__((__nonnull__(1,2), __leaf__)) bcopy)(void const   *__src ,
                                                                                               void *__dest ,
                                                                                               size_t __n ) ;
#line 459
extern  __attribute__((__nothrow__)) void ( __attribute__((__nonnull__(1), __leaf__)) bzero)(void *__s ,
                                                                                             size_t __n ) ;
#line 147 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 826 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) unlink)(char const   *__name ) ;
#line 113 "/usr/include/x86_64-linux-gnu/sys/socket.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) socket)(int __domain ,
                                                                             int __type ,
                                                                             int __protocol ) ;
#line 123
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) bind)(int __fd ,
                                                                           struct sockaddr  const  *__addr ,
                                                                           socklen_t __len ) ;
#line 137
extern int connect(int __fd , struct sockaddr  const  *__addr , socklen_t __len ) ;
#line 233
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) listen)(int __fd ,
                                                                             int __n ) ;
#line 375 "/usr/include/netinet/in.h"
extern  __attribute__((__nothrow__)) uint16_t ( __attribute__((__leaf__)) ntohs)(uint16_t __netshort )  __attribute__((__const__)) ;
#line 377
extern  __attribute__((__nothrow__)) uint32_t ( __attribute__((__leaf__)) htonl)(uint32_t __hostlong )  __attribute__((__const__)) ;
#line 379
extern  __attribute__((__nothrow__)) uint16_t ( __attribute__((__leaf__)) htons)(uint16_t __hostshort )  __attribute__((__const__)) ;
#line 34 "/usr/include/arpa/inet.h"
extern  __attribute__((__nothrow__)) in_addr_t ( __attribute__((__leaf__)) inet_addr)(char const   *__cp ) ;
#line 209 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) stat)(char const   * __restrict  __file ,
                                                                                             struct stat * __restrict  __buf ) ;
#line 144 "/usr/include/netdb.h"
extern struct hostent *gethostbyname(char const   *__name ) ;
#line 290
extern struct servent *getservbyname(char const   *__name , char const   *__proto ) ;
#line 297
extern struct servent *getservbyport(int __port , char const   *__proto ) ;
#line 26 "/home/june/repo/benchmarks/collector/temp/socket-1.1/globals.h"
int create_server_socket_inet(long local_ip___0 , int port , int queue_length ) ;
#line 27
int create_server_socket_unix(char *pathname , int queue_length ) ;
#line 28
int create_client_socket_inet(long local_ip___0 , char **hostname , int port ) ;
#line 29
int create_client_socket_unix(char *pathname ) ;
#line 30
int resolve_service(char *name_or_number , char *protocol , char **name ) ;
#line 34 "/home/june/repo/benchmarks/collector/temp/socket-1.1/socketp.c"
int create_server_socket_inet(long local_ip___0 , int port , int queue_length ) 
{ 
  struct sockaddr_in sa ;
  int s ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 42
  s = socket(2, 1, 0);
  }
#line 42
  if (s < 0) {
#line 43
    return (-1);
  }
  {
#line 46
  bzero((void *)((char *)(& sa)), sizeof(sa));
#line 47
  sa.sin_family = (sa_family_t )2;
  }
#line 48
  if (local_ip___0) {
#line 49
    sa.sin_addr.s_addr = (in_addr_t )local_ip___0;
  } else {
    {
#line 51
    sa.sin_addr.s_addr = htonl((in_addr_t )0);
    }
  }
  {
#line 52
  sa.sin_port = htons((uint16_t )port);
#line 54
  tmp = bind(s, (struct sockaddr  const  *)((struct sockaddr *)(& sa)), (socklen_t )sizeof(sa));
  }
#line 54
  if (tmp < 0) {
#line 55
    return (-1);
  }
  {
#line 57
  tmp___0 = listen(s, queue_length);
  }
#line 57
  if (tmp___0 < 0) {
#line 58
    return (-1);
  }
#line 61
  return (s);
}
}
#line 67 "/home/june/repo/benchmarks/collector/temp/socket-1.1/socketp.c"
int create_server_socket_unix(char *pathname , int queue_length ) 
{ 
  struct sockaddr_un su ;
  int s ;
  struct stat st ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 75
  s = socket(1, 1, 0);
  }
#line 75
  if (s < 0) {
#line 76
    return (-1);
  }
  {
#line 79
  bzero((void *)((char *)(& su)), sizeof(su));
#line 80
  su.sun_family = (sa_family_t )1;
#line 81
  strncpy((char */* __restrict  */)(su.sun_path), (char const   */* __restrict  */)pathname,
          (size_t )108);
#line 82
  su.sun_path[107] = (char)0;
#line 84
  tmp = stat((char const   */* __restrict  */)(su.sun_path), (struct stat */* __restrict  */)(& st));
  }
#line 84
  if (! tmp) {
#line 84
    if ((st.st_mode & 61440U) == 49152U) {
      {
#line 85
      unlink((char const   *)(su.sun_path));
      }
    }
  }
  {
#line 87
  tmp___0 = bind(s, (struct sockaddr  const  *)((struct sockaddr *)(& su)), (socklen_t )sizeof(su));
  }
#line 87
  if (tmp___0 < 0) {
#line 88
    return (-1);
  }
  {
#line 90
  tmp___1 = listen(s, queue_length);
  }
#line 90
  if (tmp___1 < 0) {
#line 91
    return (-1);
  }
#line 94
  return (s);
}
}
#line 99 "/home/june/repo/benchmarks/collector/temp/socket-1.1/socketp.c"
int create_client_socket_inet(long local_ip___0 , char **hostname , int port ) 
{ 
  struct sockaddr_in sa ;
  struct hostent *hp ;
  int s ;
  uint32_t addr ;
  struct sockaddr_in direc ;
  int tmp ;

  {
  {
#line 111
  bzero((void *)(& sa), sizeof(sa));
#line 112
  addr = inet_addr((char const   *)*hostname);
  }
#line 112
  if (addr != 4294967295U) {
    {
#line 114
    bcopy((void const   *)(& addr), (void *)((char *)(& sa.sin_addr)), sizeof(addr));
#line 115
    sa.sin_family = (sa_family_t )2;
    }
  } else {
    {
#line 118
    hp = gethostbyname((char const   *)*hostname);
    }
#line 118
    if ((unsigned long )hp == (unsigned long )((void *)0)) {
#line 119
      return (-2);
    }
    {
#line 121
    *hostname = hp->h_name;
#line 122
    bcopy((void const   *)*(hp->h_addr_list + 0), (void *)((char *)(& sa.sin_addr)),
          (size_t )hp->h_length);
#line 123
    sa.sin_family = (sa_family_t )hp->h_addrtype;
    }
  }
  {
#line 126
  sa.sin_port = htons((u_short )port);
#line 128
  s = socket((int )sa.sin_family, 1, 0);
  }
#line 128
  if (s < 0) {
#line 129
    return (-1);
  }
#line 131
  if (local_ip___0) {
    {
#line 133
    bzero((void *)(& direc), sizeof(direc));
#line 134
    direc.sin_addr.s_addr = (in_addr_t )local_ip___0;
#line 135
    direc.sin_family = (sa_family_t )2;
#line 136
    bind(s, (struct sockaddr  const  *)((struct sockaddr *)(& direc)), (socklen_t )sizeof(direc));
    }
  }
  {
#line 138
  tmp = connect(s, (struct sockaddr  const  *)((struct sockaddr *)(& sa)), (socklen_t )sizeof(sa));
  }
#line 138
  if (tmp < 0) {
    {
#line 139
    close(s);
    }
#line 140
    return (-1);
  }
#line 142
  return (s);
}
}
#line 146 "/home/june/repo/benchmarks/collector/temp/socket-1.1/socketp.c"
int create_client_socket_unix(char *pathname ) 
{ 
  struct sockaddr_un su ;
  int s ;
  int tmp ;

  {
  {
#line 152
  su.sun_family = (sa_family_t )1;
#line 153
  strncpy((char */* __restrict  */)(su.sun_path), (char const   */* __restrict  */)pathname,
          (size_t )108);
#line 154
  su.sun_path[107] = (char)0;
#line 156
  s = socket(1, 1, 0);
  }
#line 156
  if (s < 0) {
#line 157
    return (-1);
  }
  {
#line 159
  tmp = connect(s, (struct sockaddr  const  *)((struct sockaddr *)(& su)), (socklen_t )sizeof(su));
  }
#line 159
  if (tmp < 0) {
    {
#line 160
    close(s);
    }
#line 161
    return (-1);
  }
#line 163
  return (s);
}
}
#line 170 "/home/june/repo/benchmarks/collector/temp/socket-1.1/socketp.c"
int resolve_service(char *name_or_number , char *protocol , char **name ) 
{ 
  struct servent *servent ;
  int port ;
  uint16_t tmp ;
  uint16_t tmp___0 ;
  int tmp___1 ;

  {
  {
#line 178
  tmp___1 = is_number(name_or_number);
  }
#line 178
  if (tmp___1) {
    {
#line 179
    port = atoi((char const   *)name_or_number);
    }
#line 180
    if ((unsigned long )name != (unsigned long )((void *)0)) {
      {
#line 181
      tmp = htons((uint16_t )port);
#line 181
      servent = getservbyport((int )tmp, "tcp");
      }
#line 182
      if ((unsigned long )servent != (unsigned long )((void *)0)) {
#line 183
        *name = servent->s_name;
      } else {
#line 185
        *name = (char *)((void *)0);
      }
    }
#line 188
    return (port);
  } else {
    {
#line 190
    servent = getservbyname((char const   *)name_or_number, "tcp");
    }
#line 191
    if ((unsigned long )servent == (unsigned long )((void *)0)) {
#line 192
      return (-1);
    }
#line 194
    if ((unsigned long )name != (unsigned long )((void *)0)) {
#line 195
      *name = servent->s_name;
    }
    {
#line 197
    tmp___0 = ntohs((uint16_t )servent->s_port);
    }
#line 197
    return ((int )tmp___0);
  }
}
}
#line 444 "/usr/include/unistd.h"
extern unsigned int sleep(unsigned int __seconds ) ;
#line 71 "/usr/include/getopt.h"
extern int optind ;
#line 150
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) getopt)(int ___argc ,
                                                                             char * const  *___argv ,
                                                                             char const   *__shortopts ) ;
#line 243 "/usr/include/x86_64-linux-gnu/sys/socket.h"
extern int accept(int __fd , struct sockaddr * __restrict  __addr , socklen_t * __restrict  __addr_len ) ;
#line 144 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 236
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strchr)(char const   *__s ,
                                                                                               int __c )  __attribute__((__pure__)) ;
#line 263
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strrchr)(char const   *__s ,
                                                                                                int __c )  __attribute__((__pure__)) ;
#line 137 "/usr/include/netdb.h"
extern struct hostent *gethostbyaddr(void const   *__addr , __socklen_t __len , int __type ) ;
#line 695 "/usr/include/stdio.h"
extern int puts(char const   *__s ) ;
#line 35 "/home/june/repo/benchmarks/collector/temp/socket-1.1/globals.h"
void do_io(void) ;
#line 36
char *so_release(void) ;
#line 50
int serverflag ;
#line 51
int loopflag ;
#line 52
int verboseflag ;
#line 53
int readonlyflag ;
#line 54
int writeonlyflag ;
#line 55
int quitflag ;
#line 56
int crlfflag ;
#line 57 "/home/june/repo/benchmarks/collector/temp/socket-1.1/globals.h"
int active_socket  ;
#line 58 "/home/june/repo/benchmarks/collector/temp/socket-1.1/globals.h"
char *progname  ;
#line 30 "/home/june/repo/benchmarks/collector/temp/socket-1.1/socket.c"
int forkflag  =    0;
#line 31 "/home/june/repo/benchmarks/collector/temp/socket-1.1/socket.c"
int serverflag  =    0;
#line 32 "/home/june/repo/benchmarks/collector/temp/socket-1.1/socket.c"
int loopflag  =    0;
#line 33 "/home/june/repo/benchmarks/collector/temp/socket-1.1/socket.c"
int verboseflag  =    0;
#line 34 "/home/june/repo/benchmarks/collector/temp/socket-1.1/socket.c"
int readonlyflag  =    0;
#line 35 "/home/june/repo/benchmarks/collector/temp/socket-1.1/socket.c"
int writeonlyflag  =    0;
#line 36 "/home/june/repo/benchmarks/collector/temp/socket-1.1/socket.c"
int quitflag  =    0;
#line 37 "/home/june/repo/benchmarks/collector/temp/socket-1.1/socket.c"
int crlfflag  =    0;
#line 38 "/home/june/repo/benchmarks/collector/temp/socket-1.1/socket.c"
int backgflag  =    0;
#line 41 "/home/june/repo/benchmarks/collector/temp/socket-1.1/socket.c"
char *pipe_program  =    (char *)((void *)0);
#line 42 "/home/june/repo/benchmarks/collector/temp/socket-1.1/socket.c"
int WaitForever  =    0;
#line 43 "/home/june/repo/benchmarks/collector/temp/socket-1.1/socket.c"
long local_ip  =    0L;
#line 45
void server(long local_ip___0 , char *path , int port , char *service_name ) ;
#line 46
void handle_server_connection(void) ;
#line 47
void client(long local_ip___0 , char *host , int port , char *service_name ) ;
#line 49 "/home/june/repo/benchmarks/collector/temp/socket-1.1/socket.c"
int main(int argc , char **argv ) 
{ 
  char *cp ;
  int opt ;
  int error ;
  int port ;
  char *service_name ;
  char *path ;
  char *tmp ;
  int tmp___0 ;
  struct hostent *dataip ;
  char *cad ;
  char *tmp___1 ;

  {
#line 55
  error = 0;
#line 63
  if (*(argv + 1)) {
    {
#line 63
    tmp___0 = strcmp((char const   *)*(argv + 1), "-version");
    }
#line 63
    if (! tmp___0) {
      {
#line 64
      tmp = so_release();
#line 64
      puts((char const   *)tmp);
#line 65
      exit(0);
      }
    }
  }
  {
#line 69
  progname = *(argv + 0);
#line 70
  cp = strrchr((char const   *)progname, '/');
  }
#line 70
  if (cp) {
#line 70
    progname = cp + 1;
  }
  {
#line 73
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 73
    opt = getopt(argc, (char * const  *)argv, "B:bcflp:qrsvWw?");
    }
#line 73
    if (! (opt != -1)) {
#line 73
      goto while_break;
    }
    {
#line 75
    if (opt == 102) {
#line 75
      goto case_102;
    }
#line 78
    if (opt == 99) {
#line 78
      goto case_99;
    }
#line 81
    if (opt == 66) {
#line 81
      goto case_66;
    }
#line 92
    if (opt == 119) {
#line 92
      goto case_119;
    }
#line 95
    if (opt == 112) {
#line 95
      goto case_112;
    }
#line 98
    if (opt == 113) {
#line 98
      goto case_113;
    }
#line 101
    if (opt == 114) {
#line 101
      goto case_114;
    }
#line 104
    if (opt == 115) {
#line 104
      goto case_115;
    }
#line 107
    if (opt == 118) {
#line 107
      goto case_118;
    }
#line 110
    if (opt == 108) {
#line 110
      goto case_108;
    }
#line 113
    if (opt == 98) {
#line 113
      goto case_98;
    }
#line 116
    if (opt == 87) {
#line 116
      goto case_87;
    }
#line 118
    goto switch_default;
    case_102: /* CIL Label */ 
#line 76
    forkflag = 1;
#line 77
    goto switch_break;
    case_99: /* CIL Label */ 
#line 79
    crlfflag = 1;
#line 80
    goto switch_break;
    case_66: /* CIL Label */ 
    {
#line 85
    cad = *(argv + (optind - 1));
#line 86
    dataip = gethostbyname((char const   *)cad);
    }
#line 87
    if ((unsigned long )dataip != (unsigned long )((void *)0)) {
#line 88
      local_ip = *((long *)*(dataip->h_addr_list + 0));
    }
#line 91
    goto switch_break;
    case_119: /* CIL Label */ 
#line 93
    writeonlyflag = 1;
#line 94
    goto switch_break;
    case_112: /* CIL Label */ 
#line 96
    pipe_program = *(argv + (optind - 1));
#line 97
    goto switch_break;
    case_113: /* CIL Label */ 
#line 99
    quitflag = 1;
#line 100
    goto switch_break;
    case_114: /* CIL Label */ 
#line 102
    readonlyflag = 1;
#line 103
    goto switch_break;
    case_115: /* CIL Label */ 
#line 105
    serverflag = 1;
#line 106
    goto switch_break;
    case_118: /* CIL Label */ 
#line 108
    verboseflag = 1;
#line 109
    goto switch_break;
    case_108: /* CIL Label */ 
#line 111
    loopflag = 1;
#line 112
    goto switch_break;
    case_98: /* CIL Label */ 
#line 114
    backgflag = 1;
#line 115
    goto switch_break;
    case_87: /* CIL Label */ 
#line 117
    WaitForever = 1;
    switch_default: /* CIL Label */ 
#line 119
    error ++;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 122
  if (error) {
    {
#line 123
    usage();
#line 124
    exit(15);
    }
  } else
#line 122
  if (optind >= argc) {
    {
#line 123
    usage();
#line 124
    exit(15);
    }
  }
  {
#line 126
  tmp___1 = strchr((char const   *)*(argv + optind), '/');
  }
#line 126
  if ((unsigned long )tmp___1 != (unsigned long )((void *)0)) {
#line 127
    path = *(argv + optind);
  } else {
#line 129
    path = (char *)((void *)0);
  }
#line 132
  if ((unsigned long )path == (unsigned long )((void *)0)) {
#line 132
    if ((argc - optind) + serverflag != 2) {
      {
#line 134
      usage();
#line 135
      exit(15);
      }
    } else {
#line 132
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 132
  if ((unsigned long )path != (unsigned long )((void *)0)) {
#line 132
    if (argc - optind != 1) {
      {
#line 134
      usage();
#line 135
      exit(15);
      }
    }
  }
#line 142
  if (writeonlyflag) {
#line 142
    if (readonlyflag) {
      {
#line 143
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"It does not make sense to set %s and %s.\n",
              "-r", "-w");
#line 144
      exit(15);
      }
    }
  }
#line 146
  if (loopflag) {
#line 146
    if (! serverflag) {
      {
#line 147
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"It does not make sense to set %s and %s.\n",
              "-l", "not -s");
#line 148
      exit(15);
      }
    }
  }
#line 150
  if (backgflag) {
#line 150
    if (! serverflag) {
      {
#line 151
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"It does not make sense to set %s and %s.\n",
              "-b", "not -s");
#line 152
      exit(15);
      }
    }
  }
#line 154
  if (forkflag) {
#line 154
    if (! serverflag) {
      {
#line 155
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"It does not make sense to set %s and %s.\n",
              "-f", "not -s");
      }
    }
  }
  {
#line 159
  init_signals();
  }
#line 162
  if ((unsigned long )path == (unsigned long )((void *)0)) {
    {
#line 163
    port = resolve_service(*(argv + ((optind + 1) - serverflag)), (char *)"tcp", & service_name);
    }
#line 165
    if (port < 0) {
      {
#line 166
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: unknown service\n",
              progname);
#line 167
      exit(5);
      }
    }
  } else {
#line 171
    port = -1;
  }
#line 174
  if (serverflag) {
#line 175
    if (backgflag) {
      {
#line 176
      background();
      }
    }
    {
#line 178
    server(local_ip, path, port, service_name);
    }
  } else
#line 179
  if ((unsigned long )path != (unsigned long )((void *)0)) {
    {
#line 180
    client(local_ip, path, -1, service_name);
    }
  } else {
    {
#line 182
    client(local_ip, *(argv + optind), port, service_name);
    }
  }
  {
#line 183
  exit(0);
  }
}
}
#line 187 "/home/june/repo/benchmarks/collector/temp/socket-1.1/socket.c"
void server(long local_ip___0 , char *path , int port , char *service_name ) 
{ 
  int socket_handle ;
  int alen ;
  union __anonunion_peer_35 peer ;
  struct hostent *he ;
  uint32_t norder ;
  char dotted[20] ;
  char *tmp ;
  __pid_t tmp___0 ;

  {
#line 196
  if ((unsigned long )path != (unsigned long )((void *)0)) {
    {
#line 197
    socket_handle = create_server_socket_unix(path, 1);
    }
  } else {
    {
#line 199
    socket_handle = create_server_socket_inet(local_ip___0, port, 1);
    }
  }
#line 200
  if (socket_handle < 0) {
    {
#line 201
    perror2((char *)"server socket");
#line 202
    exit(1);
    }
  }
#line 204
  if (verboseflag) {
#line 205
    if ((unsigned long )path == (unsigned long )((void *)0)) {
      {
#line 206
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"inet: listening on port %d",
              port);
      }
#line 207
      if (service_name) {
        {
#line 208
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" (%s)",
                service_name);
        }
      }
      {
#line 210
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
      }
    } else {
      {
#line 213
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"unix: bound to %s\n",
              path);
      }
    }
  }
  {
#line 217
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 223
    alen = (int )sizeof(peer);
#line 226
    active_socket = accept(socket_handle, (struct sockaddr */* __restrict  */)((struct sockaddr *)(& peer)),
                           (socklen_t */* __restrict  */)(& alen));
    }
#line 226
    if (active_socket == -1) {
      {
#line 229
      perror2((char *)"accept");
      }
    } else {
#line 232
      if (verboseflag) {
#line 234
        if ((int )peer.sa.sin_family == 2) {
          {
#line 240
          he = gethostbyaddr((void const   *)((char *)(& peer.sa.sin_addr.s_addr)),
                             (__socklen_t )sizeof(peer.sa.sin_addr.s_addr), 2);
          }
#line 242
          if (! he) {
            {
#line 243
            norder = htonl(peer.sa.sin_addr.s_addr);
#line 244
            sprintf((char */* __restrict  */)(dotted), (char const   */* __restrict  */)"%ld.%ld.%ld.%ld",
                    (norder >> 24) & 255U, (norder >> 16) & 255U, (norder >> 8) & 255U,
                    norder & 255U);
            }
          }
#line 250
          if (he) {
#line 250
            tmp = he->h_name;
          } else {
#line 250
            tmp = dotted;
          }
          {
#line 250
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"inet: connection from %s\n",
                  tmp);
          }
        } else
#line 253
        if ((int )peer.su.sun_family == 1) {
          {
#line 254
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"unix: connection from %s\n",
                  path);
          }
        }
      }
#line 256
      if (forkflag) {
        {
#line 257
        tmp___0 = fork();
        }
        {
#line 258
        if (tmp___0 == 0) {
#line 258
          goto case_0;
        }
#line 261
        if (tmp___0 == -1) {
#line 261
          goto case_neg_1;
        }
#line 264
        goto switch_default;
        case_0: /* CIL Label */ 
        {
#line 259
        handle_server_connection();
#line 260
        exit(0);
        }
        case_neg_1: /* CIL Label */ 
        {
#line 262
        perror2((char *)"fork");
        }
#line 263
        goto switch_break;
        switch_default: /* CIL Label */ 
        {
#line 265
        close(active_socket);
#line 266
        wait_for_children();
        }
        switch_break: /* CIL Label */ ;
        }
      } else {
        {
#line 269
        handle_server_connection();
        }
      }
    }
#line 217
    if (! loopflag) {
#line 217
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 274
  close(socket_handle);
  }
#line 275
  if ((unsigned long )path != (unsigned long )((void *)0)) {
    {
#line 276
    unlink((char const   *)path);
    }
  }
#line 278
  return;
}
}
#line 281 "/home/june/repo/benchmarks/collector/temp/socket-1.1/socket.c"
void handle_server_connection(void) 
{ 


  {
#line 284
  if ((unsigned long )pipe_program != (unsigned long )((void *)0)) {
    {
#line 285
    open_pipes(pipe_program);
    }
  }
  {
#line 288
  do_io();
#line 290
  close(active_socket);
  }
#line 291
  if (pipe_program) {
    {
#line 293
    wait_for_children();
    }
  }
#line 295
  return;
}
}
#line 298 "/home/june/repo/benchmarks/collector/temp/socket-1.1/socket.c"
void client(long local_ip___0 , char *host , int port , char *service_name ) 
{ 
  int *tmp ;
  int *tmp___0 ;

  {
#line 307
  if (port >= 0) {
    {
#line 308
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 309
      active_socket = create_client_socket_inet(local_ip___0, & host, port);
      }
#line 310
      if (active_socket >= 0) {
#line 311
        goto while_break;
      } else
#line 310
      if (! WaitForever) {
#line 311
        goto while_break;
      } else {
        {
#line 310
        tmp = __errno_location();
        }
#line 310
        if (*tmp != 111) {
#line 311
          goto while_break;
        }
      }
      {
#line 312
      sleep(60U);
      }
    }
    while_break: /* CIL Label */ ;
    }
  } else {
    {
#line 316
    active_socket = create_client_socket_unix(host);
    }
  }
#line 318
  if (active_socket == -1) {
    {
#line 319
    perror2((char *)"client socket");
#line 320
    tmp___0 = __errno_location();
#line 320
    exit(*tmp___0);
    }
  } else
#line 321
  if (active_socket == -2) {
    {
#line 322
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: unknown host %s\n",
            progname, host);
#line 323
    exit(13);
    }
  }
#line 325
  if (verboseflag) {
#line 326
    if (port >= 0) {
      {
#line 327
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"inet: connected to %s port %d",
              host, port);
      }
#line 328
      if (service_name) {
        {
#line 329
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" (%s)",
                service_name);
        }
      }
      {
#line 331
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
      }
    } else {
      {
#line 334
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"unix: connected to %s\n",
              host);
      }
    }
  }
#line 338
  if ((unsigned long )pipe_program != (unsigned long )((void *)0)) {
    {
#line 339
    open_pipes(pipe_program);
    }
  }
  {
#line 342
  do_io();
#line 344
  close(active_socket);
  }
#line 345
  return;
}
}
#line 360 "/usr/include/unistd.h"
extern ssize_t read(int __fd , void *__buf , size_t __nbytes ) ;
#line 366
extern ssize_t write(int __fd , void const   *__buf , size_t __n ) ;
#line 106 "/usr/include/x86_64-linux-gnu/sys/select.h"
extern int select(int __nfds , fd_set * __restrict  __readfds , fd_set * __restrict  __writefds ,
                  fd_set * __restrict  __exceptfds , struct timeval * __restrict  __timeout ) ;
#line 33 "/home/june/repo/benchmarks/collector/temp/socket-1.1/globals.h"
int do_read_write(int from , int to ) ;
#line 34
int do_write(char *buffer , int size , int to ) ;
#line 28 "/home/june/repo/benchmarks/collector/temp/socket-1.1/io.c"
int do_read_write(int from , int to ) 
{ 
  int size ;
  char input_buffer[8192] ;
  ssize_t tmp ;
  int tmp___0 ;

  {
  {
#line 34
  tmp = read(from, (void *)(input_buffer), (size_t )8192);
#line 34
  size = (int )tmp;
  }
#line 34
  if (size == -1) {
    {
#line 35
    perror2((char *)"read");
    }
#line 36
    return (-1);
  }
#line 38
  if (size == 0) {
#line 39
    if (from == active_socket) {
#line 41
      if (verboseflag) {
        {
#line 42
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"connection closed by peer\n");
        }
      }
#line 44
      return (-1);
    } else {
#line 46
      if (quitflag) {
#line 48
        if (verboseflag) {
          {
#line 49
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"connection closed\n");
          }
        }
#line 51
        return (-1);
      } else
#line 52
      if (verboseflag) {
        {
#line 53
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"end of input on stdin\n");
        }
      }
#line 55
      readonlyflag = 1;
#line 56
      return (1);
    }
  }
  {
#line 59
  tmp___0 = do_write(input_buffer, size, to);
  }
#line 59
  return (tmp___0);
}
}
#line 64 "/home/june/repo/benchmarks/collector/temp/socket-1.1/io.c"
int do_write(char *buffer , int size , int to ) 
{ 
  char buffer2[16384] ;
  int written ;
  ssize_t tmp ;
  char const   *tmp___0 ;

  {
#line 72
  if (crlfflag) {
#line 73
    if (to == active_socket) {
      {
#line 74
      add_crs(buffer, buffer2, & size);
      }
    } else {
      {
#line 76
      strip_crs(buffer, buffer2, & size);
      }
    }
#line 80
    buffer = buffer2;
  }
  {
#line 82
  while (1) {
    while_continue: /* CIL Label */ ;
#line 82
    if (! (size > 0)) {
#line 82
      goto while_break;
    }
    {
#line 84
    tmp = write(to, (void const   *)buffer, (size_t )size);
#line 84
    written = (int )tmp;
    }
#line 85
    if (written == -1) {
      {
#line 87
      perror2((char *)"write");
      }
#line 88
      if (to == active_socket) {
#line 88
        tmp___0 = "socket";
      } else {
#line 88
        tmp___0 = "stdout";
      }
      {
#line 88
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: error writing to %s\n",
              progname, tmp___0);
      }
#line 91
      return (-1);
    }
#line 93
    size -= written;
#line 94
    buffer += written;
  }
  while_break: /* CIL Label */ ;
  }
#line 96
  return (1);
}
}
#line 101 "/home/june/repo/benchmarks/collector/temp/socket-1.1/io.c"
void do_io(void) 
{ 
  fd_set readfds ;
  int fdset_width ;
  int selret ;
  int tmp ;
  int __d0 ;
  int __d1 ;
  int *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 107
  if (0 > active_socket) {
#line 107
    tmp = 0;
  } else {
#line 107
    tmp = active_socket;
  }
#line 107
  fdset_width = tmp + 1;
  {
#line 108
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 110
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 110
      __asm__  volatile   ("cld; rep; "
                           "stosq": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                           "1" (& readfds.__fds_bits[0]): "memory");
#line 110
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 111
    if (! readonlyflag) {
#line 112
      readfds.__fds_bits[0 / (8 * (int )sizeof(__fd_mask ))] |= 1L << 0 % (8 * (int )sizeof(__fd_mask ));
    }
#line 114
    if (! writeonlyflag) {
#line 115
      readfds.__fds_bits[active_socket / (8 * (int )sizeof(__fd_mask ))] |= 1L << active_socket % (8 * (int )sizeof(__fd_mask ));
    }
    {
#line 118
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 120
      selret = select(fdset_width, (fd_set */* __restrict  */)(& readfds), (fd_set */* __restrict  */)((void *)0),
                      (fd_set */* __restrict  */)((void *)0), (struct timeval */* __restrict  */)((void *)0));
      }
#line 122
      if (selret < 0) {
        {
#line 122
        tmp___0 = __errno_location();
        }
#line 122
        if (*tmp___0 != 4) {
          {
#line 123
          perror2((char *)"select");
#line 124
          exit(1);
          }
        }
      }
#line 118
      if (! (selret <= 0)) {
#line 118
        goto while_break___1;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
#line 129
    if ((readfds.__fds_bits[active_socket / (8 * (int )sizeof(__fd_mask ))] & (1L << active_socket % (8 * (int )sizeof(__fd_mask )))) != 0L) {
      {
#line 130
      tmp___1 = do_read_write(active_socket, 1);
      }
#line 130
      if (tmp___1 < 0) {
#line 131
        goto while_break;
      }
    } else {
      {
#line 134
      tmp___2 = do_read_write(0, active_socket);
      }
#line 134
      if (tmp___2 < 0) {
#line 135
        goto while_break;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 139
  return;
}
}
#line 2 "/home/june/repo/benchmarks/collector/temp/socket-1.1/so_release.c"
static char release[64]  = 
#line 2 "/home/june/repo/benchmarks/collector/temp/socket-1.1/so_release.c"
  {      (char )'S',      (char )'o',      (char )'c',      (char )'k', 
        (char )'e',      (char )'t',      (char )'-',      (char )'1', 
        (char )'.',      (char )'1',      (char )' ',      (char )'(', 
        (char )'W',      (char )'e',      (char )'d',      (char )' ', 
        (char )'S',      (char )'e',      (char )'p',      (char )' ', 
        (char )' ',      (char )'9',      (char )' ',      (char )'1', 
        (char )'9',      (char )':',      (char )'1',      (char )'1', 
        (char )':',      (char )'1',      (char )'9',      (char )' ', 
        (char )'1',      (char )'9',      (char )'9',      (char )'2', 
        (char )' ',      (char )'b',      (char )'y',      (char )' ', 
        (char )'n',      (char )'i',      (char )'c',      (char )'k', 
        (char )'e',      (char )'l',      (char )'@',      (char )'c', 
        (char )'s',      (char )'.',      (char )'t',      (char )'u', 
        (char )'-',      (char )'b',      (char )'e',      (char )'r', 
        (char )'l',      (char )'i',      (char )'n',      (char )'.', 
        (char )'d',      (char )'e',      (char )')',      (char )'\000'};
#line 1 "/home/june/repo/benchmarks/collector/temp/socket-1.1/so_release.c"
char *so_release(void) 
{ 


  {
#line 3
  return (release);
}
}
