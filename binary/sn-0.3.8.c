/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 26 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/cache.c"
struct entry {
   void *object ;
   struct entry *prev ;
   struct entry *next ;
};
#line 32 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/cache.c"
struct table {
   int maxsize ;
   int (*cmp)(void * , void * ) ;
   void (*freeobj)(void * ) ;
   int (*isstale)(void * ) ;
   struct entry *entries ;
   struct entry *freelist ;
   struct entry *freeblocks ;
   int hit ;
   int miss ;
};
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 141 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __suseconds_t;
#line 172 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __ssize_t;
#line 183 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef char *__caddr_t;
#line 220 "/usr/include/unistd.h"
typedef __ssize_t ssize_t;
#line 116 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __caddr_t caddr_t;
#line 30 "/usr/include/x86_64-linux-gnu/bits/time.h"
struct timeval {
   __time_t tv_sec ;
   __suseconds_t tv_usec ;
};
#line 43 "/usr/include/x86_64-linux-gnu/bits/uio.h"
struct iovec {
   void *iov_base ;
   size_t iov_len ;
};
#line 55 "/usr/include/x86_64-linux-gnu/sys/time.h"
struct timezone {
   int tz_minuteswest ;
   int tz_dsttime ;
};
#line 61 "/usr/include/x86_64-linux-gnu/sys/time.h"
typedef struct timezone * __restrict  __timezone_ptr_t;
#line 99 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/config.h"
enum __anonenum_bool_50 {
    FALSE = 0,
    TRUE = 1
} ;
#line 99 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/config.h"
typedef enum __anonenum_bool_50 bool;
#line 15 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/art.h"
struct article {
   char *head ;
   int hlen ;
   char *body ;
   int blen ;
};
#line 31 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/artfile.h"
struct info {
   int hoffset ;
   int hlen ;
   int boffset ;
   int blen ;
};
#line 43 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/artfile.h"
struct file {
   int magic ;
   struct info info[10] ;
};
#line 15 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/group.h"
struct group {
   int nr_articles ;
   int first ;
   int last ;
   bool nopost ;
};
#line 368 "/usr/include/x86_64-linux-gnu/zconf.h"
typedef unsigned char Byte;
#line 371 "/usr/include/x86_64-linux-gnu/zconf.h"
typedef unsigned long uLong;
#line 377 "/usr/include/x86_64-linux-gnu/zconf.h"
typedef Byte Bytef;
#line 382 "/usr/include/x86_64-linux-gnu/zconf.h"
typedef uLong uLongf;
#line 60 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/store.c"
struct storeobj {
   char *filename ;
   int compressok ;
   int fd ;
   struct file *file ;
};
#line 40 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stdarg.h"
typedef __builtin_va_list __gnuc_va_list;
#line 98 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stdarg.h"
typedef __gnuc_va_list va_list;
#line 24 "./lib/readln.h"
struct readln {
   int fd ;
   char *buf ;
   char bf[104] ;
   int size ;
   int used ;
   int eaten ;
   int tmo ;
};
#line 124 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __dev_t;
#line 125 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uid_t;
#line 126 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __gid_t;
#line 127 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __ino_t;
#line 129 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __mode_t;
#line 130 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __nlink_t;
#line 153 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blksize_t;
#line 158 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blkcnt_t;
#line 175 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __syscall_slong_t;
#line 75 "/usr/include/time.h"
typedef __time_t time_t;
#line 120 "/usr/include/time.h"
struct timespec {
   __time_t tv_sec ;
   __syscall_slong_t tv_nsec ;
};
#line 46 "/usr/include/x86_64-linux-gnu/bits/stat.h"
struct stat {
   __dev_t st_dev ;
   __ino_t st_ino ;
   __nlink_t st_nlink ;
   __mode_t st_mode ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   int __pad0 ;
   __dev_t st_rdev ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   __syscall_slong_t __glibc_reserved[3] ;
};
#line 22 "/usr/include/x86_64-linux-gnu/bits/dirent.h"
struct dirent {
   __ino_t d_ino ;
   __off_t d_off ;
   unsigned short d_reclen ;
   unsigned char d_type ;
   char d_name[256] ;
};
#line 127 "/usr/include/dirent.h"
struct __dirstream;
#line 127 "/usr/include/dirent.h"
typedef struct __dirstream DIR;
#line 39 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/group.c"
struct dir {
   DIR *dir ;
   int first ;
   int last ;
   time_t read ;
};
#line 46 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/group.c"
struct lastf {
   int name ;
   struct file *f ;
   int slotsfilled ;
};
#line 52 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/group.c"
struct groupobj {
   char *groupname ;
   struct dir dir ;
   struct lastf lastf ;
   bool nopost ;
};
#line 37 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/art.h"
struct field {
   char *pointer ;
   int len ;
};
#line 42 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/art.h"
struct xover {
   struct field subject ;
   struct field from ;
   struct field date ;
   struct field messageid ;
   struct field references ;
   struct field bytes ;
   struct field lines ;
};
#line 48 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/artfile.h"
struct fileobj {
   char *path ;
   char *map ;
   int size ;
};
#line 16 "./lib/b.h"
struct b {
   char *buf ;
   int size ;
   int used ;
};
#line 32 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/dhash.h"
struct data {
   char *messageid ;
   char *newsgroup ;
   int serial ;
};
#line 53 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/dhash.h"
struct chain {
   int serial ;
   int next ;
   char newsgroup[2] ;
   char messageid[sizeof(int ) - 2UL] ;
};
#line 65 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/dhash.h"
struct table___0 {
   int magic ;
   unsigned char next[30720] ;
};
#line 100 "/usr/include/netdb.h"
struct hostent {
   char *h_name ;
   char **h_aliases ;
   int h_addrtype ;
   int h_length ;
   char **h_addr_list ;
};
#line 64 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/allocate.c"
struct chainfile {
   int chain_magic ;
   int volatile   next[63] ;
};
#line 69 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/allocate.c"
struct table___1 {
   char *filename ;
   char *map ;
   int fd ;
   int size ;
   int oflag ;
   int mprot ;
};
#line 133 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __pid_t;
#line 133 "/usr/include/time.h"
struct tm {
   int tm_sec ;
   int tm_min ;
   int tm_hour ;
   int tm_mday ;
   int tm_mon ;
   int tm_year ;
   int tm_wday ;
   int tm_yday ;
   int tm_isdst ;
   long tm_gmtoff ;
   char const   *tm_zone ;
};
#line 232 "/usr/include/unistd.h"
typedef __gid_t gid_t;
#line 237 "/usr/include/unistd.h"
typedef __uid_t uid_t;
#line 49 "/usr/include/pwd.h"
struct passwd {
   char *pw_name ;
   char *pw_passwd ;
   __uid_t pw_uid ;
   __gid_t pw_gid ;
   char *pw_gecos ;
   char *pw_dir ;
   char *pw_shell ;
};
#line 42 "/usr/include/grp.h"
struct group___0 {
   char *gr_name ;
   char *gr_passwd ;
   __gid_t gr_gid ;
   char **gr_mem ;
};
#line 26 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/newsgroup.c"
struct ng {
   struct ng *gnext ;
   struct ng *inext ;
   int ident ;
   char group[1] ;
};
#line 53 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/newsgroup.c"
struct chunk {
   struct chunk *next ;
   char *buf ;
};
#line 22 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/key.h"
struct key {
   struct key *next ;
   int len ;
};
#line 21 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/key.c"
struct buf {
   struct buf *next ;
   char buf[1000] ;
};
#line 370 "/usr/include/x86_64-linux-gnu/zconf.h"
typedef unsigned int uInt;
#line 386 "/usr/include/x86_64-linux-gnu/zconf.h"
typedef void *voidpf;
#line 83 "/usr/include/zlib.h"
struct internal_state;
#line 85 "/usr/include/zlib.h"
struct z_stream_s {
   Bytef *next_in ;
   uInt avail_in ;
   uLong total_in ;
   Bytef *next_out ;
   uInt avail_out ;
   uLong total_out ;
   char *msg ;
   struct internal_state *state ;
   voidpf (*zalloc)(voidpf opaque , uInt items , uInt size ) ;
   void (*zfree)(voidpf opaque , voidpf address ) ;
   voidpf opaque ;
   int data_type ;
   uLong adler ;
   uLong reserved ;
};
#line 85 "/usr/include/zlib.h"
typedef struct z_stream_s z_stream;
#line 106 "/usr/include/zlib.h"
typedef z_stream *z_streamp;
#line 1742 "/usr/include/zlib.h"
struct internal_state {
   int dummy ;
};
#line 54 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef long __fd_mask;
#line 64 "/usr/include/x86_64-linux-gnu/sys/select.h"
struct __anonstruct_fd_set_13 {
   __fd_mask __fds_bits[1024 / (8 * (int )sizeof(__fd_mask ))] ;
};
#line 64 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef struct __anonstruct_fd_set_13 fd_set;
#line 135 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __clock_t;
#line 189 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __socklen_t;
#line 274 "/usr/include/unistd.h"
typedef __socklen_t socklen_t;
#line 27 "/usr/include/x86_64-linux-gnu/bits/sigset.h"
struct __anonstruct___sigset_t_12 {
   unsigned long __val[1024UL / (8UL * sizeof(unsigned long ))] ;
};
#line 27 "/usr/include/x86_64-linux-gnu/bits/sigset.h"
typedef struct __anonstruct___sigset_t_12 __sigset_t;
#line 37 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef __sigset_t sigset_t;
#line 49 "/usr/include/stdint.h"
typedef unsigned short uint16_t;
#line 51 "/usr/include/stdint.h"
typedef unsigned int uint32_t;
#line 28 "/usr/include/x86_64-linux-gnu/bits/sockaddr.h"
typedef unsigned short sa_family_t;
#line 149 "/usr/include/x86_64-linux-gnu/bits/socket.h"
struct sockaddr {
   sa_family_t sa_family ;
   char sa_data[14] ;
};
#line 30 "/usr/include/netinet/in.h"
typedef uint32_t in_addr_t;
#line 31 "/usr/include/netinet/in.h"
struct in_addr {
   in_addr_t s_addr ;
};
#line 117 "/usr/include/netinet/in.h"
typedef uint16_t in_port_t;
#line 237 "/usr/include/netinet/in.h"
struct sockaddr_in {
   sa_family_t sin_family ;
   in_port_t sin_port ;
   struct in_addr sin_addr ;
   unsigned char sin_zero[((sizeof(struct sockaddr ) - sizeof(unsigned short )) - sizeof(in_port_t )) - sizeof(struct in_addr )] ;
};
#line 32 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
union sigval {
   int sival_int ;
   void *sival_ptr ;
};
#line 32 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
typedef union sigval sigval_t;
#line 58 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
typedef __clock_t __sigchld_clock_t;
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__kill_33 {
   __pid_t si_pid ;
   __uid_t si_uid ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__timer_34 {
   int si_tid ;
   int si_overrun ;
   sigval_t si_sigval ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__rt_35 {
   __pid_t si_pid ;
   __uid_t si_uid ;
   sigval_t si_sigval ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__sigchld_36 {
   __pid_t si_pid ;
   __uid_t si_uid ;
   int si_status ;
   __sigchld_clock_t si_utime ;
   __sigchld_clock_t si_stime ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__sigfault_37 {
   void *si_addr ;
   short si_addr_lsb ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__sigpoll_38 {
   long si_band ;
   int si_fd ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__sigsys_39 {
   void *_call_addr ;
   int _syscall ;
   unsigned int _arch ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
union __anonunion__sifields_32 {
   int _pad[128UL / sizeof(int ) - 4UL] ;
   struct __anonstruct__kill_33 _kill ;
   struct __anonstruct__timer_34 _timer ;
   struct __anonstruct__rt_35 _rt ;
   struct __anonstruct__sigchld_36 _sigchld ;
   struct __anonstruct__sigfault_37 _sigfault ;
   struct __anonstruct__sigpoll_38 _sigpoll ;
   struct __anonstruct__sigsys_39 _sigsys ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct_siginfo_t_31 {
   int si_signo ;
   int si_errno ;
   int si_code ;
   union __anonunion__sifields_32 _sifields ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
typedef struct __anonstruct_siginfo_t_31 siginfo_t;
#line 24 "/usr/include/x86_64-linux-gnu/bits/sigaction.h"
union __anonunion___sigaction_handler_51 {
   void (*sa_handler)(int  ) ;
   void (*sa_sigaction)(int  , siginfo_t * , void * ) ;
};
#line 24 "/usr/include/x86_64-linux-gnu/bits/sigaction.h"
struct sigaction {
   union __anonunion___sigaction_handler_51 __sigaction_handler ;
   __sigset_t sa_mask ;
   int sa_flags ;
   void (*sa_restorer)(void) ;
};
#line 41 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/get.c"
struct job {
   int pid ;
   int sd ;
   int infd ;
   int outfd ;
   int attempts ;
   char *server ;
   unsigned long addr ;
   unsigned short port ;
   char group[1] ;
};
#line 136 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/get.c"
struct sock {
   char *server ;
   unsigned long addr ;
   unsigned short sd ;
   unsigned short port ;
};
#line 490 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/get.c"
union __anonunion_56 {
   int __in ;
   int __i ;
};
#line 495 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/get.c"
union __anonunion_57 {
   int __in ;
   int __i ;
};
#line 493 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/get.c"
union __anonunion_58 {
   int __in ;
   int __i ;
};
#line 488 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/get.c"
union __anonunion_59 {
   int __in ;
   int __i ;
};
#line 729 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/get.c"
union __anonunion_60 {
   int __in ;
   int __i ;
};
#line 733 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/get.c"
union __anonunion_61 {
   int __in ;
   int __i ;
};
#line 732 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/get.c"
union __anonunion_62 {
   int __in ;
   int __i ;
};
#line 727 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/get.c"
union __anonunion_63 {
   int __in ;
   int __i ;
};
#line 787 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/get.c"
struct s {
   struct s *next ;
   unsigned short port ;
   char server[1] ;
};
#line 57 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/snfetch.c"
struct art {
   int serial ;
   char *id ;
};
#line 231 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/post.c"
union __anonunion_49 {
   int __in ;
   int __i ;
};
#line 239 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/post.c"
union __anonunion_50 {
   int __in ;
   int __i ;
};
#line 238 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/post.c"
union __anonunion_51 {
   int __in ;
   int __i ;
};
#line 229 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/post.c"
union __anonunion_52 {
   int __in ;
   int __i ;
};
#line 79 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/snntpd.c"
struct cmd {
   char *name ;
   void (*function)(void) ;
   char needs_args ;
   char needs_group ;
   char needs_article ;
   char needs_grouplist ;
};
#line 208 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/snntpd.c"
struct __anonstruct_con_58 {
   int (*f)() ;
   char buf[40] ;
};
#line 46 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/snsplit.c"
struct export {
   char *s ;
   int len ;
   char *name ;
};
#line 371 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/snsplit.c"
union __anonunion_49___0 {
   int __in ;
   int __i ;
};
#line 376 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/snsplit.c"
union __anonunion_50___0 {
   int __in ;
   int __i ;
};
#line 374 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/snsplit.c"
union __anonunion_51___0 {
   int __in ;
   int __i ;
};
#line 369 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/snsplit.c"
union __anonunion_52___0 {
   int __in ;
   int __i ;
};
#line 61 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/lib/cmdopen.c"
union __anonunion_48 {
   int __in ;
   int __i ;
};
#line 63 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/lib/cmdopen.c"
union __anonunion_49___1 {
   int __in ;
   int __i ;
};
#line 62 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/lib/cmdopen.c"
union __anonunion_50___1 {
   int __in ;
   int __i ;
};
#line 60 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/lib/cmdopen.c"
union __anonunion_51___1 {
   int __in ;
   int __i ;
};
#line 89 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/lib/cmdopen.c"
union __anonunion_52___1 {
   int __in ;
   int __i ;
};
#line 91 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/lib/cmdopen.c"
union __anonunion_53 {
   int __in ;
   int __i ;
};
#line 90 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/lib/cmdopen.c"
union __anonunion_54 {
   int __in ;
   int __i ;
};
#line 88 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/lib/cmdopen.c"
union __anonunion_55 {
   int __in ;
   int __i ;
};
#line 36 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/sngetd.c"
struct get {
   struct get *next ;
   time_t t ;
   char group[1] ;
};
#line 490 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/get.c"
union __anonunion_56___0 {
   int __in ;
   int __i ;
};
#line 495 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/get.c"
union __anonunion_57___0 {
   int __in ;
   int __i ;
};
#line 493 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/get.c"
union __anonunion_58___0 {
   int __in ;
   int __i ;
};
#line 488 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/get.c"
union __anonunion_59___0 {
   int __in ;
   int __i ;
};
#line 729 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/get.c"
union __anonunion_60___0 {
   int __in ;
   int __i ;
};
#line 733 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/get.c"
union __anonunion_61___0 {
   int __in ;
   int __i ;
};
#line 732 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/get.c"
union __anonunion_62___0 {
   int __in ;
   int __i ;
};
#line 727 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/get.c"
union __anonunion_63___0 {
   int __in ;
   int __i ;
};
#line 85 "/usr/include/signal.h"
typedef void (*__sighandler_t)(int  );
#line 46 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/snsend.c"
enum __anonenum_ng_t_49 {
    NG_UNKNOWN = 0,
    NG_LOCAL = 1,
    NG_SPECIAL = 2,
    NG_SPECIALX = 3,
    NG_GLOBAL = 4,
    NG_FIFO = 5
} ;
#line 46 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/snsend.c"
typedef enum __anonenum_ng_t_49 ng_t;
#line 48 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/snsend.c"
struct ng___0 {
   char *s ;
   ng_t t ;
};
#line 224 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/snsend.c"
union __anonunion_50___2 {
   int __in ;
   int __i ;
};
#line 226 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/snsend.c"
union __anonunion_51___2 {
   int __in ;
   int __i ;
};
#line 222 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/snsend.c"
union __anonunion_52___2 {
   int __in ;
   int __i ;
};
#line 230 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/snsend.c"
union __anonunion_53___0 {
   int __in ;
   int __i ;
};
#line 230 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/snsend.c"
union __anonunion_54___0 {
   int __in ;
   int __i ;
};
#line 229 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/snsend.c"
union __anonunion_55___0 {
   int __in ;
   int __i ;
};
#line 468 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) calloc)(size_t __nmemb ,
                                                                               size_t __size )  __attribute__((__malloc__)) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 66 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memset)(void *__s ,
                                                                                               int __c ,
                                                                                               size_t __n ) ;
#line 50 "/usr/include/x86_64-linux-gnu/bits/errno.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
#line 18 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/cache.h"
int cache_init(int max , int (*cmp)(void * , void * ) , void (*freeobj)(void * ) ,
               int (*isstale)(void * ) ) ;
#line 20
void *cache_find(int desc___35 , void *object ) ;
#line 21
void *cache_top(int desc___35 ) ;
#line 22
void cache_insert(int desc___35 , void *object ) ;
#line 23
void cache_invalidate(int desc___35 , void *objp ) ;
#line 24
void cache_fin(int desc___35 ) ;
#line 25
void cache_stat(int desc___35 , int *hit , int *miss ) ;
#line 44 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/cache.c"
struct table table[4]  = {      {0, (int (*)(void * , void * ))0, (void (*)(void * ))0, (int (*)(void * ))0,
      (struct entry *)0, (struct entry *)0, (struct entry *)0, 0, 0}};
#line 46 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/cache.c"
int cache_init(int max , int (*cmp)(void * , void * ) , void (*freeobj)(void * ) ,
               int (*isstale)(void * ) ) 
{ 
  int i ;
  int j ;
  int *tmp ;
  int *tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;

  {
#line 53
  if (max <= 1) {
    {
#line 55
    tmp = __errno_location();
#line 55
    *tmp = 22;
    }
#line 56
    return (-1);
  } else
#line 53
  if ((unsigned long )((void *)0) == (unsigned long )cmp) {
    {
#line 55
    tmp = __errno_location();
#line 55
    *tmp = 22;
    }
#line 56
    return (-1);
  } else
#line 53
  if ((unsigned long )((void *)0) == (unsigned long )freeobj) {
    {
#line 55
    tmp = __errno_location();
#line 55
    *tmp = 22;
    }
#line 56
    return (-1);
  }
#line 59
  i = 0;
  {
#line 59
  while (1) {
    while_continue: /* CIL Label */ ;
#line 59
    if (! (i < 4)) {
#line 59
      goto while_break;
    }
#line 60
    if (0 == table[i].maxsize) {
#line 61
      goto while_break;
    }
#line 59
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 63
  if (4 == i) {
    {
#line 65
    tmp___0 = __errno_location();
#line 65
    *tmp___0 = 23;
    }
#line 66
    return (-1);
  }
  {
#line 69
  tmp___1 = calloc((size_t )max, sizeof(struct entry ));
#line 69
  table[i].freeblocks = (struct entry *)tmp___1;
  }
#line 70
  if ((unsigned long )((void *)0) == (unsigned long )table[i].freeblocks) {
#line 71
    return (-1);
  }
#line 72
  j = 0;
  {
#line 72
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 72
    if (! (j < max - 1)) {
#line 72
      goto while_break___0;
    }
#line 73
    (table[i].freeblocks + j)->next = table[i].freeblocks + (j + 1);
#line 72
    j ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 74
  table[i].freelist = table[i].freeblocks;
#line 75
  table[i].maxsize = max;
#line 76
  table[i].cmp = cmp;
#line 77
  table[i].freeobj = freeobj;
#line 78
  table[i].isstale = isstale;
#line 79
  tmp___2 = 0;
#line 79
  table[i].miss = tmp___2;
#line 79
  table[i].hit = tmp___2;
#line 81
  return (i);
}
}
#line 87 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/cache.c"
static struct entry *new_entry(int desc___35 ) 
{ 
  struct entry *ep ;
  struct entry *tmp ;

  {
#line 91
  ep = table[desc___35].freelist;
#line 91
  if (ep) {
#line 92
    table[desc___35].freelist = ep->next;
  } else {
#line 95
    ep = table[desc___35].entries;
    {
#line 95
    while (1) {
      while_continue: /* CIL Label */ ;
#line 95
      if (! ep->next) {
#line 95
        goto while_break;
      }
#line 95
      ep = ep->next;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 96
    (ep->prev)->next = (struct entry *)((void *)0);
#line 97
    (*(table[desc___35].freeobj))(ep->object);
    }
  }
#line 99
  tmp = (struct entry *)((void *)0);
#line 99
  ep->next = tmp;
#line 99
  ep->prev = tmp;
#line 100
  ep->object = (void *)0;
#line 101
  return (ep);
}
}
#line 104 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/cache.c"
void cache_fin(int desc___35 ) 
{ 
  struct entry *ep ;
  struct entry *tmp ;
  void (*freeobj)(void * ) ;

  {
#line 108
  freeobj = table[desc___35].freeobj;
#line 110
  ep = table[desc___35].entries;
  {
#line 110
  while (1) {
    while_continue: /* CIL Label */ ;
#line 110
    if (! ep) {
#line 110
      goto while_break;
    }
    {
#line 112
    (*freeobj)(ep->object);
#line 113
    tmp = ep->next;
#line 110
    ep = tmp;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 115
  free((void *)table[desc___35].freeblocks);
#line 116
  memset((void *)(& table[desc___35]), 0, sizeof(struct table ));
  }
#line 117
  return;
}
}
#line 119 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/cache.c"
void *cache_find(int desc___35 , void *object ) 
{ 
  register struct table *tp ;
  int (*cmp)(void * , void * ) ;
  int (*isstale)(void * ) ;
  struct entry *head___14 ;
  register struct entry *ep ;
  int tmp ;
  int tmp___0 ;

  {
#line 121
  tp = & table[desc___35];
#line 122
  cmp = tp->cmp;
#line 123
  isstale = tp->isstale;
#line 124
  head___14 = table[desc___35].entries;
#line 127
  ep = head___14;
  {
#line 127
  while (1) {
    while_continue: /* CIL Label */ ;
#line 127
    if (! ep) {
#line 127
      goto while_break;
    }
#line 129
    if (isstale) {
      {
#line 129
      tmp___0 = (*isstale)(ep->object);
      }
#line 129
      if (tmp___0) {
#line 132
        if (ep->prev) {
#line 133
          (ep->prev)->next = ep->next;
        } else {
#line 135
          tp->entries = ep->next;
        }
#line 136
        if (ep->next) {
#line 137
          (ep->next)->prev = ep->prev;
        }
        {
#line 138
        ep->next = (struct entry *)((void *)0);
#line 139
        (*(tp->freeobj))(ep->object);
#line 140
        ep->next = tp->freelist;
#line 141
        tp->freelist = ep;
        }
      } else {
#line 129
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
      {
#line 144
      tmp = (*cmp)(object, ep->object);
      }
#line 144
      if (0 == tmp) {
#line 148
        if ((unsigned long )ep != (unsigned long )tp->entries) {
#line 150
          (ep->prev)->next = ep->next;
#line 151
          if (ep->next) {
#line 152
            (ep->next)->prev = ep->prev;
          }
#line 153
          (tp->entries)->prev = ep;
#line 154
          ep->next = tp->entries;
#line 155
          tp->entries = ep;
#line 156
          ep->prev = (struct entry *)((void *)0);
        }
#line 158
        (tp->hit) ++;
#line 159
        return ((tp->entries)->object);
      }
    }
#line 127
    ep = ep->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 161
  (tp->miss) ++;
#line 162
  return ((void *)0);
}
}
#line 165 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/cache.c"
void cache_stat(int desc___35 , int *hit , int *miss ) 
{ 


  {
#line 167
  if (hit) {
#line 168
    *hit = table[desc___35].hit;
  }
#line 169
  if (miss) {
#line 170
    *miss = table[desc___35].miss;
  }
#line 171
  return;
}
}
#line 176 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/cache.c"
void *cache_top(int desc___35 ) 
{ 


  {
#line 178
  return ((table[desc___35].entries)->object);
}
}
#line 184 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/cache.c"
void cache_insert(int desc___35 , void *object ) 
{ 
  register struct entry *ep ;

  {
  {
#line 188
  ep = new_entry(desc___35);
#line 189
  ep->object = object;
#line 190
  ep->next = table[desc___35].entries;
  }
#line 191
  if (table[desc___35].entries) {
#line 192
    (table[desc___35].entries)->prev = ep;
  }
#line 193
  table[desc___35].entries = ep;
#line 194
  return;
}
}
#line 196 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/cache.c"
void cache_invalidate(int desc___35 , void *objp ) 
{ 
  struct entry *ep ;
  struct entry *tmp ;
  int tmp___0 ;

  {
#line 201
  ep = table[desc___35].entries;
  {
#line 201
  while (1) {
    while_continue: /* CIL Label */ ;
#line 201
    if (! ep) {
#line 201
      goto while_break;
    }
    {
#line 202
    tmp___0 = (*(table[desc___35].cmp))(objp, ep->object);
    }
#line 202
    if (0 == tmp___0) {
#line 204
      if (ep->next) {
#line 205
        (ep->next)->prev = ep->prev;
      }
#line 206
      if (ep->prev) {
#line 207
        (ep->prev)->next = ep->next;
      } else {
#line 209
        table[desc___35].entries = ep->next;
      }
      {
#line 210
      (*(table[desc___35].freeobj))(ep->object);
#line 211
      tmp = ep->next;
#line 212
      ep->object = (void *)0;
#line 213
      ep->prev = (struct entry *)((void *)0);
#line 214
      ep->next = table[desc___35].freelist;
#line 215
      table[desc___35].freelist = ep;
      }
#line 216
      goto while_break;
    } else {
#line 219
      tmp = ep->next;
    }
#line 201
    ep = tmp;
  }
  while_break: /* CIL Label */ ;
  }
#line 220
  return;
}
}
#line 14 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/field.c"
int check_field(char *field___0 , int len ) 
{ 
  int i ;

  {
#line 18
  i = 0;
  {
#line 18
  while (1) {
    while_continue: /* CIL Label */ ;
#line 18
    if (! (i < len)) {
#line 18
      goto while_break;
    }
#line 21
    if ((int )*(field___0 + i) >= 33) {
#line 21
      if ((int )*(field___0 + i) <= 57) {
#line 22
        goto __Cont;
      }
    }
#line 23
    if ((int )*(field___0 + i) >= 59) {
#line 23
      if ((int )*(field___0 + i) <= 126) {
#line 24
        goto __Cont;
      }
    }
#line 25
    if ((int )*(field___0 + i) == 58) {
#line 26
      return (i);
    }
#line 27
    if ((int )*(field___0 + i) == 32) {
#line 28
      goto while_break;
    } else
#line 27
    if ((int )*(field___0 + i) == 9) {
#line 28
      goto while_break;
    }
#line 29
    return (0);
    __Cont: /* CIL Label */ 
#line 18
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 31
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 32
    i ++;
#line 31
    if (! ((int )*(field___0 + i) == 32)) {
#line 31
      if (! ((int )*(field___0 + i) == 9)) {
#line 31
        goto while_break___0;
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 34
  if ((int )*(field___0 + i) != 58) {
#line 35
    return (0);
  }
#line 36
  return (i);
}
}
#line 334 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) __off_t ( __attribute__((__leaf__)) lseek)(int __fd ,
                                                                                __off_t __offset ,
                                                                                int __whence ) ;
#line 353
extern int close(int __fd ) ;
#line 360
extern ssize_t read(int __fd , void *__buf , size_t __nbytes ) ;
#line 366
extern ssize_t write(int __fd , void const   *__buf , size_t __n ) ;
#line 790
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) link)(char const   *__from ,
                                                                                             char const   *__to ) ;
#line 826
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) unlink)(char const   *__name ) ;
#line 1081
extern int lockf(int __fd , int __cmd , __off_t __len ) ;
#line 146 "/usr/include/fcntl.h"
extern int ( __attribute__((__nonnull__(1))) open)(char const   *__file , int __oflag 
                                                   , ...) ;
#line 46 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memcpy)(void * __restrict  __dest ,
                                                                                                 void const   * __restrict  __src ,
                                                                                                 size_t __n ) ;
#line 129
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcpy)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 144
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 399
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 187 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) unsigned long ( __attribute__((__nonnull__(1),
__leaf__)) strtoul)(char const   * __restrict  __nptr , char ** __restrict  __endptr ,
                    int __base ) ;
#line 466
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 50 "/usr/include/x86_64-linux-gnu/sys/uio.h"
extern ssize_t writev(int __fd , struct iovec  const  *__iovec , int __count ) ;
#line 71 "/usr/include/x86_64-linux-gnu/sys/time.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) gettimeofday)(struct timeval * __restrict  __tv ,
                                                                                                   __timezone_ptr_t __tz ) ;
#line 57 "/usr/include/x86_64-linux-gnu/sys/mman.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) mmap)(void *__addr ,
                                                                             size_t __len ,
                                                                             int __prot ,
                                                                             int __flags ,
                                                                             int __fd ,
                                                                             __off_t __offset ) ;
#line 76
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) munmap)(void *__addr ,
                                                                             size_t __len ) ;
#line 72 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/config.h"
int debug ;
#line 24 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/group.h"
int group_info(char *newsgroup , struct group *gp ) ;
#line 26 "./lib/out.h"
void log_(char *fmt  , ...) ;
#line 28 "./lib/format.h"
int formats(char *buf___28 , int size___1 , char *fmt  , ...) ;
#line 15 "./lib/nap.h"
void nap(int sec , int msec ) ;
#line 1160 "/usr/include/zlib.h"
extern int compress(Bytef *dest , uLongf *destLen , Bytef const   *source , uLong sourceLen ) ;
#line 53 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/store.c"
extern int rename(char const   *old , char const   *new ) ;
#line 67 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/store.c"
static int sto_cmp(void *a , void *b___13 ) 
{ 
  register struct storeobj *x ;
  register struct storeobj *y ;
  int tmp ;

  {
  {
#line 69
  x = (struct storeobj *)a;
#line 70
  y = (struct storeobj *)b___13;
#line 72
  tmp = strcmp((char const   *)x->filename, (char const   *)y->filename);
  }
#line 72
  return (tmp);
}
}
#line 75 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/store.c"
static int nosigio(ssize_t (*op)() , int fd , char *buf___28 , int len ) 
{ 
  int er ;
  int *tmp ;
  ssize_t tmp___0 ;

  {
  {
#line 79
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 79
    tmp___0 = (*op)(fd, buf___28, len);
#line 79
    er = (int )tmp___0;
    }
#line 79
    if (! (-1 == er)) {
#line 79
      goto while_break;
    }
    {
#line 80
    tmp = __errno_location();
    }
#line 80
    if (4 != *tmp) {
#line 82
      if (debug >= 1) {
        {
#line 82
        log_((char *)"nosigio:%m");
        }
      }
#line 83
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 85
  return (er);
}
}
#line 88 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/store.c"
static int copyart(int tofd , int fromfd , int fromseek , int len ) 
{ 
  char buf___28[1024] ;
  __off_t tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  {
#line 92
  tmp = lseek(fromfd, (__off_t )fromseek, 0);
  }
#line 92
  if (-1L == tmp) {
    {
#line 94
    log_((char *)"copyart:lseek:%m");
    }
#line 95
    return (-1);
  }
  {
#line 98
  while (1) {
    while_continue: /* CIL Label */ ;
#line 98
    if (! (len > 1024)) {
#line 98
      goto while_break;
    }
    {
#line 99
    tmp___0 = nosigio((ssize_t (*)())(& read), fromfd, buf___28, 1024);
    }
#line 99
    if (-1 == tmp___0) {
#line 100
      return (-1);
    } else {
      {
#line 99
      tmp___1 = nosigio((ssize_t (*)())(& write), tofd, buf___28, 1024);
      }
#line 99
      if (-1 == tmp___1) {
#line 100
        return (-1);
      }
    }
#line 98
    len -= 1024;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 101
  tmp___2 = nosigio((ssize_t (*)())(& read), fromfd, buf___28, len);
  }
#line 101
  if (-1 == tmp___2) {
#line 102
    return (-1);
  } else {
    {
#line 101
    tmp___3 = nosigio((ssize_t (*)())(& write), tofd, buf___28, len);
    }
#line 101
    if (-1 == tmp___3) {
#line 102
      return (-1);
    }
  }
#line 104
  return (0);
}
}
#line 107 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/store.c"
static int checkindex(struct info *p ) 
{ 


  {
#line 109
  if (p->hoffset > 0) {
#line 111
    if (p->boffset > 0) {
#line 112
      if (p->hlen > 0) {
#line 113
        if (p->blen > 0) {
#line 114
          return (0);
        }
      }
    }
  } else
#line 116
  if (-1 == p->hoffset) {
#line 116
    if (-1 == p->boffset) {
#line 117
      return (1);
    }
  }
#line 118
  return (-1);
}
}
#line 127 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/store.c"
static void reorder(struct storeobj *sp ) 
{ 
  char tmpname[287] ;
  char *p ;
  char *q ;
  int fd ;
  struct file f___9 ;
  int er ;
  int i ;
  char *tmp ;
  char tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char tmp___4 ;
  char *tmp___5 ;
  int *tmp___6 ;
  int tmp___7 ;
  char *p___0 ;
  int *tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  __off_t tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  __off_t tmp___17 ;
  __off_t tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;

  {
#line 133
  f___9.magic = 0;
#line 133
  f___9.info[0].hoffset = 0;
#line 133
  f___9.info[0].hlen = 0;
#line 133
  f___9.info[0].boffset = 0;
#line 133
  f___9.info[0].blen = 0;
#line 133
  f___9.info[1].hoffset = 0;
#line 133
  f___9.info[1].hlen = 0;
#line 133
  f___9.info[1].boffset = 0;
#line 133
  f___9.info[1].blen = 0;
#line 133
  f___9.info[2].hoffset = 0;
#line 133
  f___9.info[2].hlen = 0;
#line 133
  f___9.info[2].boffset = 0;
#line 133
  f___9.info[2].blen = 0;
#line 133
  f___9.info[3].hoffset = 0;
#line 133
  f___9.info[3].hlen = 0;
#line 133
  f___9.info[3].boffset = 0;
#line 133
  f___9.info[3].blen = 0;
#line 133
  f___9.info[4].hoffset = 0;
#line 133
  f___9.info[4].hlen = 0;
#line 133
  f___9.info[4].boffset = 0;
#line 133
  f___9.info[4].blen = 0;
#line 133
  f___9.info[5].hoffset = 0;
#line 133
  f___9.info[5].hlen = 0;
#line 133
  f___9.info[5].boffset = 0;
#line 133
  f___9.info[5].blen = 0;
#line 133
  f___9.info[6].hoffset = 0;
#line 133
  f___9.info[6].hlen = 0;
#line 133
  f___9.info[6].boffset = 0;
#line 133
  f___9.info[6].blen = 0;
#line 133
  f___9.info[7].hoffset = 0;
#line 133
  f___9.info[7].hlen = 0;
#line 133
  f___9.info[7].boffset = 0;
#line 133
  f___9.info[7].blen = 0;
#line 133
  f___9.info[8].hoffset = 0;
#line 133
  f___9.info[8].hlen = 0;
#line 133
  f___9.info[8].boffset = 0;
#line 133
  f___9.info[8].blen = 0;
#line 133
  f___9.info[9].hoffset = 0;
#line 133
  f___9.info[9].hlen = 0;
#line 133
  f___9.info[9].boffset = 0;
#line 133
  f___9.info[9].blen = 0;
#line 136
  p = tmpname;
#line 136
  q = sp->filename;
  {
#line 136
  while (1) {
    while_continue: /* CIL Label */ ;
#line 136
    tmp = p;
#line 136
    p ++;
#line 136
    tmp___1 = q;
#line 136
    q ++;
#line 136
    tmp___0 = *tmp___1;
#line 136
    *tmp = tmp___0;
#line 136
    if (! ((int )tmp___0 != 47)) {
#line 136
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 137
  tmp___2 = p;
#line 137
  p ++;
#line 137
  *tmp___2 = (char )'+';
  {
#line 138
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 138
    tmp___3 = p;
#line 138
    p ++;
#line 138
    tmp___5 = q;
#line 138
    q ++;
#line 138
    tmp___4 = *tmp___5;
#line 138
    *tmp___3 = tmp___4;
#line 138
    if (! tmp___4) {
#line 138
      goto while_break___0;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 139
  fd = open((char const   *)(tmpname), 194, 420);
  }
#line 140
  if (-1 == fd) {
    {
#line 142
    tmp___6 = __errno_location();
    }
#line 142
    if (17 != *tmp___6) {
      {
#line 143
      log_((char *)"reorder:open(%s):%m", tmpname);
      }
    }
#line 144
    return;
  }
  {
#line 147
  f___9.magic = 1027296;
#line 148
  tmp___7 = nosigio((ssize_t (*)())(& write), fd, (char *)(& f___9), (int )sizeof(f___9));
  }
#line 148
  if (-1 == tmp___7) {
#line 149
    goto fail;
  }
  {
#line 161
  tmp___9 = lockf(sp->fd, 2, (__off_t )0);
  }
#line 161
  if (-1 == tmp___9) {
    {
#line 165
    tmp___8 = __errno_location();
    }
#line 165
    if (11 != *tmp___8) {
#line 166
      p___0 = (char *)"reorder:can\'t lockf %s:%m";
    } else {
#line 168
      p___0 = (char *)"reorder:article in %s being cancelled?";
    }
    {
#line 169
    log_(p___0, sp->filename);
    }
#line 170
    goto fail;
  }
#line 173
  i = 0;
  {
#line 173
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 173
    if (! (i < 10)) {
#line 173
      goto while_break___1;
    }
    {
#line 174
    tmp___10 = checkindex((sp->file)->info + i);
    }
    {
#line 176
    if (tmp___10 == 0) {
#line 176
      goto case_0;
    }
#line 188
    if (tmp___10 == 1) {
#line 188
      goto case_1;
    }
#line 191
    if (tmp___10 == -1) {
#line 191
      goto case_neg_1;
    }
#line 174
    goto switch_break;
    case_0: /* CIL Label */ 
    {
#line 177
    tmp___12 = lseek(fd, (__off_t )0, 2);
#line 177
    tmp___11 = (int )tmp___12;
#line 177
    f___9.info[i].hoffset = tmp___11;
    }
#line 177
    if (tmp___11 > 0) {
      {
#line 179
      f___9.info[i].hlen = (sp->file)->info[i].hlen;
#line 180
      f___9.info[i].blen = (sp->file)->info[i].blen;
#line 181
      er = copyart(fd, sp->fd, (sp->file)->info[i].hoffset, f___9.info[i].hlen);
      }
#line 182
      if (0 == er) {
#line 183
        goto switch_break;
      }
    } else {
      {
#line 186
      log_((char *)"reorder:lseek(%s):%m", tmpname);
      }
    }
#line 187
    goto fail;
    case_1: /* CIL Label */ 
#line 189
    tmp___15 = -1;
#line 189
    f___9.info[i].hlen = tmp___15;
#line 189
    tmp___14 = tmp___15;
#line 189
    f___9.info[i].blen = tmp___14;
#line 189
    tmp___13 = tmp___14;
#line 189
    f___9.info[i].hoffset = tmp___13;
#line 189
    f___9.info[i].boffset = tmp___13;
#line 190
    goto switch_break;
    case_neg_1: /* CIL Label */ 
    {
#line 192
    log_((char *)"reorder:corrupt index in %s", sp->filename);
    }
#line 193
    goto fail;
    switch_break: /* CIL Label */ ;
    }
#line 173
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 195
  i = 0;
  {
#line 195
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 195
    if (! (i < 10)) {
#line 195
      goto while_break___2;
    }
#line 197
    if (-1 == f___9.info[i].boffset) {
#line 198
      goto __Cont;
    }
    {
#line 199
    tmp___17 = lseek(fd, (__off_t )0, 2);
#line 199
    tmp___16 = (int )tmp___17;
#line 199
    f___9.info[i].boffset = tmp___16;
    }
#line 199
    if (-1 == tmp___16) {
      {
#line 201
      log_((char *)"reorder:lseek(%s):%m", tmpname);
      }
#line 202
      goto fail;
    }
    {
#line 204
    er = copyart(fd, sp->fd, (sp->file)->info[i].boffset, f___9.info[i].blen);
    }
#line 205
    if (-1 == er) {
#line 206
      goto fail;
    }
    __Cont: /* CIL Label */ 
#line 195
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 209
  tmp___18 = lseek(fd, (__off_t )0, 0);
  }
#line 209
  if (-1L == tmp___18) {
    {
#line 211
    log_((char *)"reorder:lseek:%m");
    }
#line 212
    goto fail;
  }
  {
#line 214
  tmp___19 = nosigio((ssize_t (*)())(& write), fd, (char *)(& f___9), (int )sizeof(f___9));
  }
#line 214
  if (-1 == tmp___19) {
#line 215
    goto fail;
  }
  {
#line 216
  tmp___20 = rename((char const   *)(tmpname), (char const   *)sp->filename);
  }
#line 216
  if (-1 == tmp___20) {
    {
#line 218
    log_((char *)"reorder:rename:%m");
    }
#line 219
    goto fail;
  }
  {
#line 221
  close(fd);
  }
#line 222
  return;
  fail: 
  {
#line 225
  log_((char *)"reorder:write failed for %s:%m", sp->filename);
#line 226
  tmp___21 = unlink((char const   *)(tmpname));
  }
#line 226
  if (-1 == tmp___21) {
    {
#line 227
    log_((char *)"reorder:unlink(%s):%m", tmpname);
    }
  }
  {
#line 228
  close(fd);
  }
#line 229
  return;
}
}
#line 231 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/store.c"
static void sto_free(void *p ) 
{ 
  struct storeobj *sp ;
  int tmp ;

  {
  {
#line 233
  sp = (struct storeobj *)p;
#line 235
  close(sp->fd);
#line 236
  tmp = munmap((void *)((caddr_t )sp->file), sizeof(struct file ));
  }
#line 236
  if (-1 == tmp) {
    {
#line 237
    log_((char *)"sto_free:munmap:%m");
    }
  }
  {
#line 238
  free((void *)sp);
  }
#line 239
  return;
}
}
#line 241 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/store.c"
static int desc  ;
#line 245 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/store.c"
int sto_init(void) 
{ 


  {
  {
#line 247
  desc = cache_init(8, & sto_cmp, & sto_free, (int (*)(void * ))((void *)0));
  }
#line 248
  if (-1 == desc) {
#line 249
    return (-1);
  }
#line 250
  return (0);
}
}
#line 253 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/store.c"
void sto_fin(void) 
{ 
  int hit ;
  int miss ;

  {
#line 255
  if (debug >= 3) {
    {
#line 259
    cache_stat(desc, & hit, & miss);
#line 260
    log_((char *)"sto_fin:cache requests:%dT=%dH+%dM", hit + miss, hit, miss);
    }
  }
  {
#line 262
  cache_fin(desc);
  }
#line 263
  return;
}
}
#line 304
static int tryopen(char *fn ) ;
#line 304 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/store.c"
static struct file f  =    {1027296, {{0, 0, 0, 0}}};
#line 270 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/store.c"
static int tryopen(char *fn ) 
{ 
  char fn2[287] ;
  int fd ;
  int i ;
  char *p ;
  char *q ;
  struct timeval tv ;
  char *tmp ;
  char tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  ssize_t tmp___7 ;

  {
  {
#line 278
  fd = open((char const   *)fn, 2);
  }
#line 278
  if (fd > -1) {
    {
#line 280
    lockf(fd, 1, (__off_t )0);
    }
#line 281
    return (fd);
  }
#line 283
  p = fn2;
#line 283
  q = fn;
  {
#line 283
  while (1) {
    while_continue: /* CIL Label */ ;
#line 283
    tmp = p;
#line 283
    p ++;
#line 283
    tmp___1 = q;
#line 283
    q ++;
#line 283
    tmp___0 = *tmp___1;
#line 283
    *tmp = tmp___0;
#line 283
    if (! ((int )tmp___0 != 47)) {
#line 283
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 284
  tmp___2 = p;
#line 284
  p ++;
#line 284
  *tmp___2 = (char )'+';
#line 285
  tmp___3 = p;
#line 285
  p ++;
#line 285
  *tmp___3 = (char )'+';
#line 286
  gettimeofday((struct timeval */* __restrict  */)(& tv), (__timezone_ptr_t )0);
#line 296
  i = (int )(tv.tv_sec / 30L);
  }
  {
#line 297
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 298
    tmp___4 = p;
#line 298
    p ++;
#line 298
    *tmp___4 = (char )(48 + i % 10);
#line 297
    i /= 10;
#line 297
    if (! i) {
#line 297
      goto while_break___0;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 300
  tmp___5 = p;
#line 300
  p ++;
#line 300
  *tmp___5 = (char )'\000';
#line 302
  i = 0;
  {
#line 302
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 302
    if (! (i < 100)) {
#line 302
      goto while_break___1;
    }
#line 306
    if (14 == i % 15) {
      {
#line 307
      log_((char *)"tryopen:racing on %s", fn);
      }
    }
    {
#line 308
    fd = open((char const   *)(fn2), 194, 420);
    }
#line 308
    if (fd > -1) {
      {
#line 310
      lockf(fd, 1, (__off_t )0);
#line 311
      tmp___7 = write(fd, (void const   *)((char *)(& f)), sizeof(f));
      }
#line 311
      if (sizeof(f) == (unsigned long )tmp___7) {
        {
#line 312
        tmp___6 = link((char const   *)(fn2), (char const   *)fn);
        }
#line 312
        if (0 == tmp___6) {
          {
#line 314
          unlink((char const   *)(fn2));
          }
#line 315
          return (fd);
        }
      }
      {
#line 317
      close(fd);
#line 318
      unlink((char const   *)(fn2));
      }
    }
    {
#line 321
    fd = open((char const   *)fn, 2);
    }
#line 321
    if (fd > -1) {
      {
#line 323
      lockf(fd, 1, (__off_t )0);
      }
#line 324
      return (fd);
    }
    {
#line 302
    nap(0, 300 + i);
#line 302
    i ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 327
  log_((char *)"tryopen:timed out opening %s:%m", fn);
  }
#line 328
  return (-1);
}
}
#line 337 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/store.c"
static struct storeobj *getstore(char *filename ) 
{ 
  struct storeobj *sp ;
  struct storeobj s ;
  int fd ;
  struct file *fp ;
  char buf___28[287] ;
  int c ;
  void *tmp ;
  void *tmp___0 ;
  char *p ;
  char *q ;
  char *tmp___1 ;
  char tmp___2 ;
  char *tmp___3 ;
  char *end ;
  unsigned long tmp___4 ;
  ssize_t tmp___5 ;
  size_t tmp___6 ;
  void *tmp___7 ;

  {
  {
#line 349
  s.filename = filename;
#line 350
  tmp = cache_find(desc, (void *)(& s));
#line 350
  sp = (struct storeobj *)tmp;
  }
#line 350
  if (sp) {
    {
#line 352
    lockf(sp->fd, 1, (__off_t )0);
    }
#line 353
    return (sp);
  }
  {
#line 356
  fd = tryopen(filename);
  }
#line 356
  if (-1 == fd) {
#line 357
    return ((struct storeobj *)0);
  }
  {
#line 361
  tmp___0 = mmap((void *)0, sizeof(*fp), 3, 1, fd, (__off_t )0);
#line 361
  fp = (struct file *)tmp___0;
  }
#line 362
  if (! fp) {
    {
#line 363
    log_((char *)"getstore:mmap(%s):%m", filename);
    }
  } else
#line 362
  if ((unsigned long )fp == (unsigned long )((void *)-1)) {
    {
#line 363
    log_((char *)"getstore:mmap(%s):%m", filename);
    }
  } else {
    {
#line 364
    tmp___6 = strlen((char const   *)filename);
#line 364
    tmp___7 = malloc((sizeof(*sp) + tmp___6) + 1UL);
#line 364
    sp = (struct storeobj *)tmp___7;
    }
#line 364
    if (sp) {
      {
#line 371
      sp->fd = fd;
#line 372
      sp->file = fp;
#line 373
      sp->filename = (char *)sp + sizeof(*sp);
#line 374
      strcpy((char */* __restrict  */)sp->filename, (char const   */* __restrict  */)filename);
#line 380
      p = buf___28;
#line 380
      q = filename;
      }
      {
#line 380
      while (1) {
        while_continue: /* CIL Label */ ;
#line 380
        tmp___1 = p;
#line 380
        p ++;
#line 380
        tmp___3 = q;
#line 380
        q ++;
#line 380
        tmp___2 = *tmp___3;
#line 380
        *tmp___1 = tmp___2;
#line 380
        if (! ((int )tmp___2 != 47)) {
#line 380
          goto while_break;
        }
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 381
      strcpy((char */* __restrict  */)p, (char const   */* __restrict  */)".compress");
#line 383
      fd = open((char const   *)(buf___28), 0);
      }
#line 383
      if (fd > -1) {
        {
#line 385
        sp->compressok = 1024;
#line 386
        tmp___5 = read(fd, (void *)(buf___28), sizeof(buf___28) - 1UL);
#line 386
        c = (int )tmp___5;
        }
#line 386
        if (c > 0) {
          {
#line 390
          buf___28[c] = (char )'\000';
#line 391
          tmp___4 = strtoul((char const   */* __restrict  */)(buf___28), (char **/* __restrict  */)(& end),
                            10);
#line 391
          c = (int )tmp___4;
          }
#line 392
          if (c > 1024) {
#line 392
            if (10 == (int )*end) {
#line 393
              sp->compressok = c;
            }
          }
        }
        {
#line 395
        close(fd);
        }
      } else {
#line 399
        sp->compressok = 0;
      }
      {
#line 400
      cache_insert(desc, (void *)sp);
      }
#line 401
      return (sp);
    } else {
      {
#line 366
      log_((char *)"getstore:no memory");
#line 367
      munmap((void *)fp, sizeof(*fp));
      }
    }
  }
  {
#line 403
  close(fd);
  }
#line 404
  return ((struct storeobj *)0);
}
}
#line 413 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/store.c"
int sto_add(char *newsgroup , struct article *ap ) 
{ 
  struct storeobj *sp ;
  struct info info ;
  int filenum ;
  int slot ;
  int er ;
  char *p ;
  char filename[287] ;
  struct group g ;
  int tmp ;
  __off_t tmp___0 ;
  struct iovec iov[4] ;
  char *zbuf ;
  unsigned long zlen ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  void *tmp___3 ;

  {
  {
#line 422
  tmp = group_info(newsgroup, & g);
  }
#line 422
  if (-1 == tmp) {
#line 423
    return (-1);
  }
#line 424
  if (g.last > 0) {
#line 424
    filenum = g.last / 10;
  } else {
#line 424
    filenum = 1;
  }
  {
#line 424
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 426
    formats(filename, (int )(sizeof(filename) - 1UL), (char *)"%s/%d", newsgroup,
            filenum);
#line 427
    sp = getstore(filename);
    }
#line 427
    if (! sp) {
#line 428
      return (-1);
    }
#line 429
    slot = 0;
    {
#line 429
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 429
      if (! (slot < 10)) {
#line 429
        goto while_break___0;
      }
#line 430
      if (0 == (sp->file)->info[slot].hoffset) {
#line 431
        goto while_break___0;
      }
#line 429
      slot ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 432
    if (slot < 10) {
#line 433
      goto while_break;
    }
    {
#line 434
    lseek(sp->fd, (__off_t )0, 0);
#line 435
    lockf(sp->fd, 0, (__off_t )0);
#line 436
    cache_invalidate(desc, (void *)sp);
#line 424
    filenum ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 441
  p = ap->head;
  {
#line 441
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 441
    if (! *p) {
#line 441
      goto while_break___1;
    }
#line 442
    if (9 == (int )*p) {
#line 443
      *p = (char )' ';
    }
#line 441
    p ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 445
  tmp___0 = lseek(sp->fd, (__off_t )0, 2);
#line 445
  info.hoffset = (int )tmp___0;
#line 445
  er = info.hoffset;
  }
#line 446
  if (er > -1) {
#line 451
    info.hlen = ap->hlen + 2;
#line 452
    info.boffset = (info.hoffset + ap->hlen) + 2;
#line 453
    info.blen = ap->blen + 2;
#line 454
    iov[0].iov_base = (void *)"";
#line 455
    iov[0].iov_len = (size_t )1;
#line 456
    iov[1].iov_base = (void *)ap->head;
#line 457
    iov[1].iov_len = (size_t )(ap->hlen + 1);
#line 458
    iov[2].iov_base = (void *)"";
#line 459
    iov[2].iov_len = (size_t )1;
#line 461
    zbuf = (char *)0;
#line 462
    if (ap->body) {
#line 462
      if (ap->blen > 0) {
#line 468
        if (sp->compressok) {
#line 468
          if (ap->blen > sp->compressok) {
            {
#line 470
            zlen = (unsigned long )((ap->blen + ap->blen / 1000) + 13);
#line 471
            tmp___3 = malloc(zlen + (sizeof("c\003c\003") - 1UL));
#line 471
            zbuf = (char *)tmp___3;
            }
#line 471
            if (zbuf) {
              {
#line 473
              memcpy((void */* __restrict  */)zbuf, (void const   */* __restrict  */)"c\003c\003",
                     sizeof("c\003c\003") - 1UL);
#line 474
              er = compress((unsigned char *)zbuf + (sizeof("c\003c\003") - 1UL),
                            & zlen, (Bytef const   *)((unsigned char *)ap->body),
                            (uLong )((unsigned int )ap->blen));
              }
#line 476
              if (0 != er) {
#line 478
                if (debug >= 1) {
#line 478
                  if (-5 == er) {
#line 478
                    tmp___2 = "BUF";
                  } else {
#line 478
                    if (-4 == er) {
#line 478
                      tmp___1 = "MEM";
                    } else {
#line 478
                      tmp___1 = "[unknown]";
                    }
#line 478
                    tmp___2 = tmp___1;
                  }
                  {
#line 478
                  log_((char *)"sto_add:compression failed on %s:%d, \"Z_%s_ERROR\"",
                       newsgroup, filenum * 10 + slot, tmp___2);
                  }
                }
                {
#line 481
                free((void *)zbuf);
#line 482
                zbuf = (char *)0;
                }
              } else {
#line 485
                *(zbuf + (zlen + (sizeof("c\003c\003") - 1UL))) = (char )'\000';
              }
            } else {
              {
#line 488
              log_((char *)"sto_add:No memory to compress");
              }
            }
          }
        }
#line 490
        if (zbuf) {
#line 492
          iov[3].iov_base = (void *)zbuf;
#line 493
          iov[3].iov_len = (zlen + 1UL) + (sizeof("c\003c\003") - 1UL);
        } else {
#line 498
          iov[3].iov_base = (void *)ap->body;
#line 499
          iov[3].iov_len = (size_t )(ap->blen + 1);
        }
      } else {
#line 504
        iov[3].iov_base = (void *)"";
#line 505
        iov[3].iov_len = (size_t )1;
      }
    } else {
#line 504
      iov[3].iov_base = (void *)"";
#line 505
      iov[3].iov_len = (size_t )1;
    }
    {
#line 507
    info.blen = (int )(iov[3].iov_len + 1UL);
#line 509
    er = nosigio((ssize_t (*)())(& writev), sp->fd, (char *)(iov), 4);
    }
#line 509
    if (er > -1) {
#line 511
      (sp->file)->info[slot] = info;
#line 512
      er = filenum * 10 + slot;
    } else {
      {
#line 515
      log_((char *)"sto_add:writev(%s):%m", sp->filename);
      }
    }
#line 516
    if (zbuf) {
      {
#line 517
      free((void *)zbuf);
      }
    }
  } else {
    {
#line 520
    log_((char *)"sto_add:lseek(%s):%m", sp->filename);
    }
  }
  {
#line 522
  lseek(sp->fd, (__off_t )0, 0);
#line 523
  lockf(sp->fd, 0, (__off_t )0);
  }
#line 524
  if (slot == 9) {
    {
#line 526
    reorder(sp);
#line 527
    cache_invalidate(desc, (void *)sp);
    }
  }
#line 529
  return (er);
}
}
/* compiler builtin: 
   void __builtin_va_start(__builtin_va_list  ) ;  */
/* compiler builtin: 
   void __builtin_va_end(__builtin_va_list  ) ;  */
#line 38 "./lib/readln.h"
int readln(struct readln *rp , char **line , int ch ) ;
#line 27 "./lib/format.h"
int formatv(char *buf___28 , int size___1 , char *fmt , va_list ap ) ;
#line 18 "./lib/tokensep.h"
char *tokensep(char **p , char *delim ) ;
#line 18 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/args.c"
char *args[20]  ;
#line 19 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/args.c"
char args_outbuf[1024]  ;
#line 20 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/args.c"
char args_inbuf[512]  ;
#line 22 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/args.c"
int args_write(int fd , char *fmt  , ...) 
{ 
  va_list ap ;
  int len ;
  ssize_t tmp ;

  {
  {
#line 27
  __builtin_va_start(ap, fmt);
#line 28
  len = formatv(args_outbuf, (int )(sizeof(args_outbuf) - 2UL), fmt, ap);
#line 29
  __builtin_va_end(ap);
#line 31
  tmp = write(fd, (void const   *)(args_outbuf), (size_t )len);
  }
#line 31
  if (-1L == tmp) {
#line 33
    args_outbuf[0] = (char )'\000';
#line 34
    return (-1);
  }
#line 36
  args_outbuf[len - 2] = (char )'\000';
#line 37
  if (debug >= 2) {
    {
#line 38
    log_((char *)"-> %s", args_outbuf);
    }
  }
#line 39
  return (len);
}
}
#line 42 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/args.c"
int args_read(struct readln *rp ) 
{ 
  char *p ;
  int len ;
  int i ;
  char *tmp ;

  {
  {
#line 48
  len = readln(rp, & p, '\n');
  }
#line 49
  if (len <= 0) {
#line 51
    args_inbuf[0] = (char )'\000';
#line 52
    return (-1);
  }
#line 55
  len --;
  {
#line 55
  while (1) {
    while_continue: /* CIL Label */ ;
#line 55
    if (! (len > 0)) {
#line 55
      goto while_break;
    }
    {
#line 60
    if ((int )*(p + len) == 13) {
#line 60
      goto case_13;
    }
#line 60
    if ((int )*(p + len) == 10) {
#line 60
      goto case_13;
    }
#line 57
    goto switch_break;
    case_13: /* CIL Label */ 
    case_10: /* CIL Label */ 
#line 61
    goto __Cont;
    switch_break: /* CIL Label */ ;
    }
#line 63
    goto while_break;
    __Cont: /* CIL Label */ 
#line 55
    len --;
  }
  while_break: /* CIL Label */ ;
  }
#line 65
  *(p + (len + 1)) = (char )'\000';
#line 67
  i = 0;
  {
#line 67
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 67
    if ((unsigned long )i < sizeof(args_inbuf) - 1UL) {
#line 67
      if (! (i <= len)) {
#line 67
        goto while_break___0;
      }
    } else {
#line 67
      goto while_break___0;
    }
#line 68
    args_inbuf[i] = *(p + i);
#line 67
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 69
  args_inbuf[i] = (char )'\000';
#line 70
  if (debug >= 2) {
    {
#line 71
    log_((char *)"<- %s", args_inbuf);
    }
  }
#line 72
  if (len >= 512) {
#line 73
    return (0);
  }
#line 75
  i = 0;
  {
#line 75
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 75
    if (! (i < 20)) {
#line 75
      goto while_break___1;
    }
    {
#line 76
    tmp = tokensep(& p, (char *)" \t\r\n");
#line 76
    args[i] = tmp;
    }
#line 76
    if (! tmp) {
#line 77
      goto while_break___1;
    }
#line 75
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 78
  return (i);
}
}
#line 81 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/args.c"
void args_report(char *tag ) 
{ 
  char const   *tmp ;

  {
#line 83
  if (tag) {
#line 83
    tmp = (char const   *)tag;
  } else {
#line 83
    tmp = "";
  }
  {
#line 83
  log_((char *)"%sSent \"%s\" got \"%s\"", tmp, args_outbuf, args_inbuf);
  }
#line 84
  return;
}
}
#line 86 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/args.c"
void args_flushtodot(struct readln *rp ) 
{ 
  int tmo ;
  int len ;
  char *p ;

  {
#line 90
  tmo = rp->tmo;
#line 91
  rp->tmo = 20;
  {
#line 92
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 97
    len = readln(rp, & p, '\n');
    }
#line 98
    if (len <= 0) {
#line 99
      goto while_break;
    }
#line 100
    if (len > 1) {
#line 100
      if (46 == (int )*p) {
#line 102
        if (13 == (int )*(p + (len - 2))) {
#line 103
          *(p + (len - 2)) = (char )'\000';
        } else {
#line 105
          *(p + (len - 1)) = (char )'\000';
        }
#line 106
        if (! *(p + 1)) {
#line 107
          goto while_break;
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 110
  rp->tmo = tmo;
#line 111
  return;
}
}
#line 15 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/addr.h"
int addr_domain(char *buf___28 ) ;
#line 16
int addr_localpart(char *buf___28 ) ;
#line 17
int addr_msgid(char *buf___28 ) ;
#line 18
char *addr_qstrchr(char *str , int find ) ;
#line 19
int addr_unescape(char *from , char *to , int len ) ;
#line 40 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/addr.c"
int addr_idleft(char *buf___28 ) ;
#line 41
int addr_idright(char *buf___28 ) ;
#line 47 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/addr.c"
int addr_msgid(char *buf___28 ) 
{ 
  char *p ;
  int len ;

  {
#line 52
  p = buf___28;
#line 53
  if ((int )*p != 60) {
#line 54
    return (0);
  }
  {
#line 55
  p ++;
#line 56
  len = addr_idleft(p);
  }
#line 57
  if (! len) {
#line 58
    return (0);
  }
#line 59
  p += len;
#line 60
  if ((int )*p != 64) {
#line 61
    return (0);
  }
  {
#line 62
  p ++;
#line 63
  len = addr_idright(p);
  }
#line 64
  if (! len) {
#line 65
    return (0);
  }
#line 66
  p += len;
#line 67
  if ((int )*p != 62) {
#line 68
    return (0);
  }
#line 69
  p ++;
#line 70
  return ((int )(p - buf___28));
}
}
#line 75 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/addr.c"
int addr_domain(char *buf___28 ) 
{ 
  char *p ;
  bool lb ;

  {
#line 80
  p = buf___28;
#line 81
  lb = (bool )(91 == (int )*p);
#line 81
  if (lb) {
#line 82
    p ++;
  }
  {
#line 84
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 87
    if ((int )*p == 45) {
#line 87
      goto case_45;
    }
#line 90
    if ((int )*p == 46) {
#line 90
      goto case_46;
    }
#line 101
    if ((int )*p == 95) {
#line 101
      goto case_95;
    }
#line 101
    if ((int )*p == 90) {
#line 101
      goto case_95;
    }
#line 101
    if ((int )*p == 89) {
#line 101
      goto case_95;
    }
#line 101
    if ((int )*p == 88) {
#line 101
      goto case_95;
    }
#line 101
    if ((int )*p == 87) {
#line 101
      goto case_95;
    }
#line 101
    if ((int )*p == 86) {
#line 101
      goto case_95;
    }
#line 101
    if ((int )*p == 85) {
#line 101
      goto case_95;
    }
#line 101
    if ((int )*p == 84) {
#line 101
      goto case_95;
    }
#line 101
    if ((int )*p == 83) {
#line 101
      goto case_95;
    }
#line 101
    if ((int )*p == 82) {
#line 101
      goto case_95;
    }
#line 101
    if ((int )*p == 81) {
#line 101
      goto case_95;
    }
#line 101
    if ((int )*p == 80) {
#line 101
      goto case_95;
    }
#line 101
    if ((int )*p == 79) {
#line 101
      goto case_95;
    }
#line 101
    if ((int )*p == 78) {
#line 101
      goto case_95;
    }
#line 101
    if ((int )*p == 77) {
#line 101
      goto case_95;
    }
#line 101
    if ((int )*p == 76) {
#line 101
      goto case_95;
    }
#line 101
    if ((int )*p == 75) {
#line 101
      goto case_95;
    }
#line 101
    if ((int )*p == 74) {
#line 101
      goto case_95;
    }
#line 101
    if ((int )*p == 73) {
#line 101
      goto case_95;
    }
#line 101
    if ((int )*p == 72) {
#line 101
      goto case_95;
    }
#line 101
    if ((int )*p == 71) {
#line 101
      goto case_95;
    }
#line 101
    if ((int )*p == 70) {
#line 101
      goto case_95;
    }
#line 101
    if ((int )*p == 69) {
#line 101
      goto case_95;
    }
#line 101
    if ((int )*p == 68) {
#line 101
      goto case_95;
    }
#line 101
    if ((int )*p == 67) {
#line 101
      goto case_95;
    }
#line 101
    if ((int )*p == 66) {
#line 101
      goto case_95;
    }
#line 101
    if ((int )*p == 65) {
#line 101
      goto case_95;
    }
#line 101
    if ((int )*p == 122) {
#line 101
      goto case_95;
    }
#line 101
    if ((int )*p == 121) {
#line 101
      goto case_95;
    }
#line 101
    if ((int )*p == 120) {
#line 101
      goto case_95;
    }
#line 101
    if ((int )*p == 119) {
#line 101
      goto case_95;
    }
#line 101
    if ((int )*p == 118) {
#line 101
      goto case_95;
    }
#line 101
    if ((int )*p == 117) {
#line 101
      goto case_95;
    }
#line 101
    if ((int )*p == 116) {
#line 101
      goto case_95;
    }
#line 101
    if ((int )*p == 115) {
#line 101
      goto case_95;
    }
#line 101
    if ((int )*p == 114) {
#line 101
      goto case_95;
    }
#line 101
    if ((int )*p == 113) {
#line 101
      goto case_95;
    }
#line 101
    if ((int )*p == 112) {
#line 101
      goto case_95;
    }
#line 101
    if ((int )*p == 111) {
#line 101
      goto case_95;
    }
#line 101
    if ((int )*p == 110) {
#line 101
      goto case_95;
    }
#line 101
    if ((int )*p == 109) {
#line 101
      goto case_95;
    }
#line 101
    if ((int )*p == 108) {
#line 101
      goto case_95;
    }
#line 101
    if ((int )*p == 107) {
#line 101
      goto case_95;
    }
#line 101
    if ((int )*p == 106) {
#line 101
      goto case_95;
    }
#line 101
    if ((int )*p == 105) {
#line 101
      goto case_95;
    }
#line 101
    if ((int )*p == 104) {
#line 101
      goto case_95;
    }
#line 101
    if ((int )*p == 103) {
#line 101
      goto case_95;
    }
#line 101
    if ((int )*p == 102) {
#line 101
      goto case_95;
    }
#line 101
    if ((int )*p == 101) {
#line 101
      goto case_95;
    }
#line 101
    if ((int )*p == 100) {
#line 101
      goto case_95;
    }
#line 101
    if ((int )*p == 99) {
#line 101
      goto case_95;
    }
#line 101
    if ((int )*p == 98) {
#line 101
      goto case_95;
    }
#line 101
    if ((int )*p == 97) {
#line 101
      goto case_95;
    }
#line 104
    if ((int )*p == 57) {
#line 104
      goto case_57;
    }
#line 104
    if ((int )*p == 56) {
#line 104
      goto case_57;
    }
#line 104
    if ((int )*p == 55) {
#line 104
      goto case_57;
    }
#line 104
    if ((int )*p == 54) {
#line 104
      goto case_57;
    }
#line 104
    if ((int )*p == 53) {
#line 104
      goto case_57;
    }
#line 104
    if ((int )*p == 52) {
#line 104
      goto case_57;
    }
#line 104
    if ((int )*p == 51) {
#line 104
      goto case_57;
    }
#line 104
    if ((int )*p == 50) {
#line 104
      goto case_57;
    }
#line 104
    if ((int )*p == 49) {
#line 104
      goto case_57;
    }
#line 104
    if ((int )*p == 48) {
#line 104
      goto case_57;
    }
#line 106
    if ((int )*p == 93) {
#line 106
      goto case_93;
    }
#line 111
    goto switch_default;
    case_45: /* CIL Label */ 
#line 88
    if (lb) {
#line 89
      return (0);
    }
    case_46: /* CIL Label */ 
#line 91
    if ((unsigned long )p == (unsigned long )buf___28) {
#line 92
      return (0);
    } else
#line 91
    if ((int )*(p + -1) == 46) {
#line 92
      return (0);
    } else
#line 91
    if (! *(p + 1)) {
#line 92
      return (0);
    } else {
#line 94
      goto __Cont;
    }
    case_95: /* CIL Label */ 
    case_90: /* CIL Label */ 
    case_89: /* CIL Label */ 
    case_88: /* CIL Label */ 
    case_87: /* CIL Label */ 
    case_86: /* CIL Label */ 
    case_85: /* CIL Label */ 
    case_84: /* CIL Label */ 
    case_83: /* CIL Label */ 
    case_82: /* CIL Label */ 
    case_81: /* CIL Label */ 
    case_80: /* CIL Label */ 
    case_79: /* CIL Label */ 
    case_78: /* CIL Label */ 
    case_77: /* CIL Label */ 
    case_76: /* CIL Label */ 
    case_75: /* CIL Label */ 
    case_74: /* CIL Label */ 
    case_73: /* CIL Label */ 
    case_72: /* CIL Label */ 
    case_71: /* CIL Label */ 
    case_70: /* CIL Label */ 
    case_69: /* CIL Label */ 
    case_68: /* CIL Label */ 
    case_67: /* CIL Label */ 
    case_66: /* CIL Label */ 
    case_65: /* CIL Label */ 
    case_122: /* CIL Label */ 
    case_121: /* CIL Label */ 
    case_120: /* CIL Label */ 
    case_119: /* CIL Label */ 
    case_118: /* CIL Label */ 
    case_117: /* CIL Label */ 
    case_116: /* CIL Label */ 
    case_115: /* CIL Label */ 
    case_114: /* CIL Label */ 
    case_113: /* CIL Label */ 
    case_112: /* CIL Label */ 
    case_111: /* CIL Label */ 
    case_110: /* CIL Label */ 
    case_109: /* CIL Label */ 
    case_108: /* CIL Label */ 
    case_107: /* CIL Label */ 
    case_106: /* CIL Label */ 
    case_105: /* CIL Label */ 
    case_104: /* CIL Label */ 
    case_103: /* CIL Label */ 
    case_102: /* CIL Label */ 
    case_101: /* CIL Label */ 
    case_100: /* CIL Label */ 
    case_99: /* CIL Label */ 
    case_98: /* CIL Label */ 
    case_97: /* CIL Label */ 
#line 102
    if (lb) {
#line 103
      return (0);
    }
    case_57: /* CIL Label */ 
    case_56: /* CIL Label */ 
    case_55: /* CIL Label */ 
    case_54: /* CIL Label */ 
    case_53: /* CIL Label */ 
    case_52: /* CIL Label */ 
    case_51: /* CIL Label */ 
    case_50: /* CIL Label */ 
    case_49: /* CIL Label */ 
    case_48: /* CIL Label */ 
#line 105
    goto __Cont;
    case_93: /* CIL Label */ 
#line 107
    if (lb) {
#line 108
      p ++;
    } else {
#line 110
      return (0);
    }
    switch_default: /* CIL Label */ 
#line 112
    if ((unsigned long )buf___28 != (unsigned long )p) {
#line 113
      return ((int )(p - buf___28));
    } else {
#line 115
      return (0);
    }
    switch_break: /* CIL Label */ ;
    }
    __Cont: /* CIL Label */ 
#line 84
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 119 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/addr.c"
int addr_localpart(char *buf___28 ) 
{ 
  char *p ;
  bool dq ;
  bool bs ;

  {
#line 124
  p = buf___28;
#line 125
  bs = (bool )0;
#line 125
  dq = bs;
#line 127
  p = buf___28;
  {
#line 127
  while (1) {
    while_continue: /* CIL Label */ ;
#line 127
    if (! *p) {
#line 127
      goto while_break;
    }
#line 128
    if (! bs) {
      {
#line 131
      if ((int )*p == 34) {
#line 131
        goto case_34;
      }
#line 134
      if ((int )*p == 92) {
#line 134
        goto case_92;
      }
#line 137
      if ((int )*p == 64) {
#line 137
        goto case_64;
      }
#line 142
      if ((int )*p == 93) {
#line 142
        goto case_93;
      }
#line 142
      if ((int )*p == 91) {
#line 142
        goto case_93;
      }
#line 142
      if ((int )*p == 58) {
#line 142
        goto case_93;
      }
#line 142
      if ((int )*p == 59) {
#line 142
        goto case_93;
      }
#line 142
      if ((int )*p == 44) {
#line 142
        goto case_93;
      }
#line 142
      if ((int )*p == 62) {
#line 142
        goto case_93;
      }
#line 142
      if ((int )*p == 60) {
#line 142
        goto case_93;
      }
#line 142
      if ((int )*p == 41) {
#line 142
        goto case_93;
      }
#line 142
      if ((int )*p == 40) {
#line 142
        goto case_93;
      }
#line 146
      goto switch_default;
      case_34: /* CIL Label */ 
#line 132
      dq = (bool )(! dq);
#line 133
      goto switch_break;
      case_92: /* CIL Label */ 
#line 135
      bs = (bool )1;
#line 136
      goto switch_break;
      case_64: /* CIL Label */ 
#line 138
      if (dq) {
#line 139
        return (0);
      }
#line 140
      return ((int )(p - buf___28));
      case_93: /* CIL Label */ 
      case_91: /* CIL Label */ 
      case_58: /* CIL Label */ 
      case_59: /* CIL Label */ 
      case_44: /* CIL Label */ 
      case_62: /* CIL Label */ 
      case_60: /* CIL Label */ 
      case_41: /* CIL Label */ 
      case_40: /* CIL Label */ 
#line 143
      if (! dq) {
#line 144
        return (0);
      }
#line 145
      goto switch_break;
      switch_default: /* CIL Label */ 
#line 147
      if (! dq) {
#line 147
        if ((int )*p <= 32) {
#line 148
          return (0);
        }
      }
      switch_break: /* CIL Label */ ;
      }
    } else {
#line 151
      bs = (bool )0;
    }
#line 127
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 153
  return (0);
}
}
#line 160 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/addr.c"
char *addr_qstrchr(char *str , int find ) 
{ 
  bool bs ;
  bool dq ;
  bool cm ;

  {
#line 164
  cm = (bool )0;
#line 164
  dq = cm;
#line 164
  bs = dq;
  {
#line 164
  while (1) {
    while_continue: /* CIL Label */ ;
#line 164
    if (! *str) {
#line 164
      goto while_break;
    }
#line 165
    if (! bs) {
#line 166
      if (! cm) {
        {
#line 169
        if ((int )*str == 34) {
#line 169
          goto case_34;
        }
#line 172
        if ((int )*str == 92) {
#line 172
          goto case_92;
        }
#line 175
        if ((int )*str == 40) {
#line 175
          goto case_40;
        }
#line 179
        goto switch_default;
        case_34: /* CIL Label */ 
#line 170
        dq = (bool )(! dq);
#line 171
        goto switch_break;
        case_92: /* CIL Label */ 
#line 173
        bs = (bool )1;
#line 174
        goto switch_break;
        case_40: /* CIL Label */ 
#line 176
        if (! dq) {
#line 177
          cm = (bool )1;
        }
#line 178
        goto switch_break;
        switch_default: /* CIL Label */ 
#line 180
        if (dq) {
#line 181
          goto switch_break;
        } else
#line 180
        if (cm) {
#line 181
          goto switch_break;
        } else
#line 180
        if ((int )((char )find) != (int )*str) {
#line 181
          goto switch_break;
        }
#line 182
        return (str);
        switch_break: /* CIL Label */ ;
        }
      } else
#line 186
      if (! dq) {
#line 186
        if (41 == (int )*str) {
#line 187
          cm = (bool )0;
        }
      }
    } else {
#line 190
      bs = (bool )0;
    }
#line 164
    str ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 191
  return ((char *)((void *)0));
}
}
#line 194 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/addr.c"
int addr_unescape(char *from , char *to , int len ) 
{ 
  char *dst ;
  bool bs ;
  bool dq ;

  {
#line 199
  dq = (bool )0;
#line 199
  bs = dq;
#line 200
  dst = to;
  {
#line 201
  while (1) {
    while_continue: /* CIL Label */ ;
#line 201
    if (! (len > 0)) {
#line 201
      goto while_break;
    }
#line 203
    if (! bs) {
      {
#line 206
      if ((int )*from == 34) {
#line 206
        goto case_34;
      }
#line 209
      if ((int )*from == 92) {
#line 209
        goto case_92;
      }
#line 212
      goto switch_default;
      case_34: /* CIL Label */ 
#line 207
      dq = (bool )(! dq);
#line 208
      goto __Cont;
      case_92: /* CIL Label */ 
#line 210
      bs = (bool )1;
#line 211
      goto __Cont;
      switch_default: /* CIL Label */ ;
      switch_break: /* CIL Label */ ;
      }
    } else {
#line 216
      bs = (bool )0;
    }
#line 217
    if ((unsigned long )dst != (unsigned long )from) {
#line 218
      *dst = *from;
    }
#line 219
    dst ++;
    __Cont: /* CIL Label */ 
#line 201
    from ++;
#line 201
    len --;
  }
  while_break: /* CIL Label */ ;
  }
#line 221
  *dst = (char )'\000';
#line 222
  return ((int )(dst - to));
}
}
#line 229 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/addr.c"
int addr_idleft(char *buf___28 ) 
{ 
  char *p ;
  bool dq ;
  bool bs ;

  {
#line 232
  bs = (bool )0;
#line 234
  p = buf___28;
#line 235
  dq = (bool )((int )*p == 34);
#line 235
  if (dq) {
#line 236
    p ++;
  }
  {
#line 238
  while (1) {
    while_continue: /* CIL Label */ ;
#line 238
    if (! *p) {
#line 238
      goto while_break;
    }
#line 239
    if (! bs) {
      {
#line 242
      if ((int )*p == 34) {
#line 242
        goto case_34;
      }
#line 247
      if ((int )*p == 92) {
#line 247
        goto case_92;
      }
#line 250
      if ((int )*p == 62) {
#line 250
        goto case_62;
      }
#line 252
      if ((int )*p == 64) {
#line 252
        goto case_64;
      }
#line 257
      goto switch_default;
      case_34: /* CIL Label */ 
#line 243
      if (dq) {
#line 243
        p ++;
#line 243
        if ((int )*p == 64) {
#line 244
          return ((int )(p - buf___28));
        } else {
#line 246
          return (0);
        }
      } else {
#line 246
        return (0);
      }
      case_92: /* CIL Label */ 
#line 248
      bs = (bool )1;
#line 249
      goto switch_break;
      case_62: /* CIL Label */ 
#line 251
      return (0);
      case_64: /* CIL Label */ 
#line 253
      if (! dq) {
#line 254
        return ((int )(p - buf___28));
      } else {
#line 256
        return (0);
      }
      switch_default: /* CIL Label */ 
#line 258
      if ((int )*p < 33) {
#line 259
        return (0);
      } else
#line 258
      if ((int )*p > 126) {
#line 259
        return (0);
      }
      switch_break: /* CIL Label */ ;
      }
    } else {
#line 262
      bs = (bool )0;
    }
#line 238
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 264
  return (0);
}
}
#line 271 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/addr.c"
int addr_idright(char *buf___28 ) 
{ 
  char *p ;
  bool lb ;
  bool bs ;

  {
#line 274
  bs = (bool )0;
#line 276
  p = buf___28;
#line 277
  lb = (bool )((int )*p == 91);
#line 277
  if (lb) {
#line 278
    p ++;
  }
  {
#line 280
  while (1) {
    while_continue: /* CIL Label */ ;
#line 280
    if (! *p) {
#line 280
      goto while_break;
    }
#line 281
    if (! bs) {
      {
#line 284
      if ((int )*p == 91) {
#line 284
        goto case_91;
      }
#line 286
      if ((int )*p == 93) {
#line 286
        goto case_93;
      }
#line 291
      if ((int )*p == 92) {
#line 291
        goto case_92;
      }
#line 294
      if ((int )*p == 62) {
#line 294
        goto case_62;
      }
#line 299
      goto switch_default;
      case_91: /* CIL Label */ 
#line 285
      return (0);
      case_93: /* CIL Label */ 
#line 287
      if (lb) {
#line 287
        p ++;
#line 287
        if ((int )*p == 62) {
#line 288
          return ((int )(p - buf___28));
        } else {
#line 290
          return (0);
        }
      } else {
#line 290
        return (0);
      }
      case_92: /* CIL Label */ 
#line 292
      bs = (bool )1;
#line 293
      goto switch_break;
      case_62: /* CIL Label */ 
#line 295
      if (! lb) {
#line 296
        return ((int )(p - buf___28));
      } else {
#line 298
        return (0);
      }
      switch_default: /* CIL Label */ 
#line 300
      if ((int )*p < 33) {
#line 301
        return (0);
      } else
#line 300
      if ((int )*p > 126) {
#line 301
        return (0);
      }
      switch_break: /* CIL Label */ ;
      }
    } else {
#line 304
      bs = (bool )0;
    }
#line 280
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 306
  return (0);
}
}
#line 214 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2), __leaf__)) fstat)(int __fd ,
                                                                                            struct stat *__buf ) ;
#line 134 "/usr/include/dirent.h"
extern DIR *( __attribute__((__nonnull__(1))) opendir)(char const   *__name ) ;
#line 149
extern int ( __attribute__((__nonnull__(1))) closedir)(DIR *__dirp ) ;
#line 162
extern struct dirent *( __attribute__((__nonnull__(1))) readdir)(DIR *__dirp ) ;
#line 208
extern  __attribute__((__nothrow__)) void ( __attribute__((__nonnull__(1), __leaf__)) rewinddir)(DIR *__dirp ) ;
#line 223
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) dirfd)(DIR *__dirp ) ;
#line 176 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strdup)(char const   *__s )  __attribute__((__malloc__)) ;
#line 79 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) unsigned short const   **( __attribute__((__leaf__)) __ctype_b_loc)(void)  __attribute__((__const__)) ;
#line 192 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) time_t ( __attribute__((__leaf__)) time)(time_t *__timer ) ;
#line 22 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/group.h"
int group_init(void) ;
#line 23
void group_fin(void) ;
#line 16 "./lib/openf.h"
int openf(int mode , int flags , char *fmt  , ...) ;
#line 37 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/group.c"
static int desc___0  =    -1;
#line 59 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/group.c"
static int cmpgroup(void *a , void *b___13 ) 
{ 
  struct groupobj *x ;
  struct groupobj *y ;
  int tmp ;

  {
  {
#line 61
  x = (struct groupobj *)a;
#line 62
  y = (struct groupobj *)b___13;
#line 64
  tmp = strcmp((char const   *)x->groupname, (char const   *)y->groupname);
  }
#line 64
  return (tmp);
}
}
#line 67 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/group.c"
static void freegroup(void *p ) 
{ 
  struct groupobj *gop ;

  {
#line 69
  gop = (struct groupobj *)p;
#line 71
  if (gop->groupname) {
    {
#line 72
    free((void *)gop->groupname);
    }
  }
#line 73
  if (gop->dir.dir) {
    {
#line 74
    closedir(gop->dir.dir);
    }
  }
#line 75
  if (gop->lastf.f) {
    {
#line 76
    munmap((void *)((caddr_t )gop->lastf.f), sizeof(struct file ));
    }
  }
  {
#line 77
  free(p);
  }
#line 78
  return;
}
}
#line 80 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/group.c"
int group_init(void) 
{ 


  {
#line 82
  if (-1 != desc___0) {
#line 83
    return (0);
  }
  {
#line 84
  desc___0 = cache_init(4, & cmpgroup, & freegroup, (int (*)(void * ))((void *)0));
  }
#line 85
  if (-1 == desc___0) {
#line 86
    return (-1);
  }
#line 87
  return (0);
}
}
#line 94 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/group.c"
static int refresh(struct groupobj *gop , char *groupname ) 
{ 
  struct stat st ;
  struct dir *d ;
  struct lastf *lp ;
  bool needreread ;
  bool needrefile ;
  bool needreslot ;
  bool isemptygroup ;
  int tmp ;
  int tmp___0 ;
  struct dirent *dp ;
  int i ;
  int first ;
  int last___1 ;
  char *end ;
  int tmp___1 ;
  unsigned short const   **tmp___2 ;
  unsigned long tmp___3 ;
  int fd ;
  void *tmp___4 ;
  struct info *ip ;
  int slot ;

  {
#line 99
  needreread = (bool )0;
#line 100
  needrefile = (bool )0;
#line 101
  needreslot = (bool )0;
#line 102
  isemptygroup = (bool )0;
#line 104
  d = & gop->dir;
#line 105
  lp = & gop->lastf;
#line 107
  if (groupname) {
    {
#line 109
    memset((void *)gop, 0, sizeof(struct groupobj ));
#line 110
    gop->groupname = strdup((char const   *)groupname);
    }
#line 111
    if ((unsigned long )((void *)0) == (unsigned long )gop->groupname) {
      {
#line 113
      log_((char *)"refresh:strdup:%m");
      }
#line 114
      return (-1);
    }
    {
#line 116
    gop->dir.first = -1;
#line 117
    d->dir = opendir((char const   *)groupname);
    }
#line 118
    if ((unsigned long )((void *)0) == (unsigned long )d->dir) {
      {
#line 120
      log_((char *)"refresh:opendir:%m");
      }
#line 121
      return (-1);
    }
#line 123
    lp->name = -1;
#line 125
    needreslot = (bool )1;
#line 125
    needreread = needreslot;
#line 125
    needrefile = needreread;
  } else {
#line 131
    if (-1 == d->first) {
#line 132
      needreread = (bool )1;
    } else
#line 131
    if (0 == d->last) {
#line 132
      needreread = (bool )1;
    } else
#line 131
    if (! d->read) {
#line 132
      needreread = (bool )1;
    } else {
      {
#line 133
      tmp = dirfd(d->dir);
#line 133
      tmp___0 = fstat(tmp, & st);
      }
#line 133
      if (-1 == tmp___0) {
        {
#line 135
        log_((char *)"refresh:fstat:%m");
        }
#line 136
        return (-1);
      } else
#line 138
      if (d->read < st.st_mtim.tv_sec) {
#line 139
        needreread = (bool )1;
      }
    }
#line 140
    if (! lp->f) {
#line 141
      needreslot = (bool )1;
#line 141
      needrefile = needreslot;
    }
#line 142
    if (! needrefile) {
#line 143
      if (! lp->f) {
#line 144
        needrefile = (bool )1;
      }
    }
#line 145
    if (! needrefile) {
#line 146
      if (-1 == lp->name) {
#line 147
        needrefile = (bool )1;
      }
    }
  }
#line 150
  if (needreread) {
#line 150
    goto _L;
  } else
#line 150
  if (needreslot) {
    _L: /* CIL Label */ 
    {
#line 156
    first = -1;
#line 157
    last___1 = 0;
#line 158
    rewinddir(d->dir);
#line 159
    dp = readdir(d->dir);
    }
#line 160
    if ((unsigned long )((void *)0) == (unsigned long )dp) {
      {
#line 162
      log_((char *)"refresh:readdir:%m");
      }
#line 163
      return (-1);
    }
#line 165
    gop->nopost = (bool )0;
    {
#line 166
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 168
      tmp___2 = __ctype_b_loc();
      }
#line 168
      if (! ((int const   )*(*tmp___2 + (int )dp->d_name[0]) & 2048)) {
#line 170
        if (! gop->nopost) {
#line 170
          if (46 == (int )dp->d_name[0]) {
            {
#line 171
            tmp___1 = strcmp((char const   *)(dp->d_name), ".nopost");
            }
#line 171
            if (0 == tmp___1) {
#line 172
              gop->nopost = (bool )1;
            }
          }
        }
#line 173
        goto __Cont;
      }
      {
#line 175
      tmp___3 = strtoul((char const   */* __restrict  */)(dp->d_name), (char **/* __restrict  */)(& end),
                        10);
#line 175
      i = (int )tmp___3;
      }
#line 175
      if (i <= 0) {
#line 176
        goto __Cont;
      } else
#line 175
      if (*end) {
#line 176
        goto __Cont;
      }
#line 177
      if (first > i) {
#line 178
        first = i;
      } else
#line 177
      if (-1 == first) {
#line 178
        first = i;
      }
#line 179
      if (last___1 < i) {
#line 180
        last___1 = i;
      }
      __Cont: /* CIL Label */ 
      {
#line 166
      dp = readdir(d->dir);
      }
#line 166
      if (! dp) {
#line 166
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 183
    d->first = first;
#line 184
    d->last = last___1;
#line 185
    if (-1 == first) {
#line 185
      if (0 == last___1) {
#line 186
        isemptygroup = (bool )1;
      }
    }
#line 187
    if (last___1 != lp->name) {
#line 188
      needrefile = (bool )1;
    } else {
#line 190
      lp->name = last___1;
    }
    {
#line 191
    time(& d->read);
    }
  }
#line 194
  if (needrefile) {
#line 194
    goto _L___0;
  } else
#line 194
  if (needreslot) {
    _L___0: /* CIL Label */ 
#line 198
    if (lp->f) {
      {
#line 200
      munmap((void *)((caddr_t )lp->f), sizeof(struct file ));
#line 201
      lp->f = (struct file *)((void *)0);
      }
    }
#line 203
    if (isemptygroup) {
#line 204
      return (0);
    }
    {
#line 205
    fd = openf(0, 0, (char *)"%s/%d", gop->groupname, d->last);
    }
#line 206
    if (-1 == fd) {
      {
#line 208
      log_((char *)"refresh:open:%m");
      }
#line 209
      return (-1);
    }
    {
#line 211
    tmp___4 = mmap((void *)0, sizeof(struct file ), 1, 1, fd, (__off_t )0);
#line 211
    lp->f = (struct file *)tmp___4;
#line 212
    close(fd);
    }
#line 213
    if ((unsigned long )lp->f == (unsigned long )((void *)-1)) {
      {
#line 215
      log_((char *)"refresh:mmap:%m");
      }
#line 216
      return (-1);
    }
#line 218
    lp->slotsfilled = 0;
#line 219
    needreslot = (bool )1;
  }
#line 222
  if (needreslot) {
#line 224
    ip = (lp->f)->info;
#line 227
    slot = 9;
    {
#line 227
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 227
      if (! (slot > -1)) {
#line 227
        goto while_break___0;
      }
#line 228
      if ((ip + slot)->hoffset) {
#line 229
        goto while_break___0;
      }
#line 227
      slot --;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 230
    lp->slotsfilled = slot + 1;
  }
#line 233
  return (0);
}
}
#line 236 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/group.c"
int group_info(char *newsgroup , struct group *gp ) 
{ 
  struct groupobj *gop ;
  struct groupobj g ;
  void *tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
  {
#line 241
  g.groupname = (char *)0;
#line 241
  g.dir.dir = (DIR *)0;
#line 241
  g.dir.first = 0;
#line 241
  g.dir.last = 0;
#line 241
  g.dir.read = 0L;
#line 241
  g.lastf.name = 0;
#line 241
  g.lastf.f = (struct file *)0;
#line 241
  g.lastf.slotsfilled = 0;
#line 241
  g.nopost = 0U;
#line 243
  g.groupname = newsgroup;
#line 244
  tmp = cache_find(desc___0, (void *)(& g));
#line 244
  gop = (struct groupobj *)tmp;
  }
#line 246
  if ((unsigned long )((void *)0) == (unsigned long )gop) {
    {
#line 248
    tmp___0 = malloc(sizeof(struct groupobj ));
#line 248
    gop = (struct groupobj *)tmp___0;
    }
#line 249
    if ((unsigned long )((void *)0) == (unsigned long )gop) {
      {
#line 251
      log_((char *)"group_info:malloc:%m");
      }
#line 252
      return (-1);
    }
    {
#line 254
    tmp___1 = refresh(gop, newsgroup);
    }
#line 254
    if (-1 == tmp___1) {
      {
#line 256
      freegroup((void *)gop);
#line 257
      log_((char *)"group_info(%s)", newsgroup);
      }
#line 258
      return (-1);
    }
    {
#line 260
    cache_insert(desc___0, (void *)gop);
    }
  } else {
    {
#line 262
    tmp___2 = refresh(gop, (char *)((void *)0));
    }
#line 262
    if (-1 == tmp___2) {
      {
#line 264
      log_((char *)"group_info(%s)", newsgroup);
#line 265
      cache_invalidate(desc___0, (void *)gop);
      }
#line 266
      return (-1);
    }
  }
#line 269
  gp->nopost = gop->nopost;
#line 270
  if (-1 == gop->dir.first) {
#line 271
    tmp___5 = 0;
#line 271
    gp->nr_articles = tmp___5;
#line 271
    tmp___4 = tmp___5;
#line 271
    gp->last = tmp___4;
#line 271
    tmp___3 = tmp___4;
#line 271
    gp->first = tmp___3;
#line 271
    return (tmp___3);
  }
#line 272
  gp->first = gop->dir.first * 10;
#line 273
  gp->last = (gop->lastf.slotsfilled + gop->dir.last * 10) - 1;
#line 274
  gp->nr_articles = (gp->last - gp->first) + 1;
#line 276
  if (10 == gop->lastf.slotsfilled) {
    {
#line 278
    munmap((void *)((caddr_t )gop->lastf.f), sizeof(struct file ));
#line 279
    gop->lastf.f = (struct file *)((void *)0);
    }
  }
#line 282
  return (0);
}
}
#line 285 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/group.c"
void group_fin(void) 
{ 


  {
#line 287
  if (desc___0 > -1) {
    {
#line 288
    cache_fin(desc___0);
    }
  }
#line 289
  desc___0 = -1;
#line 290
  return;
}
}
#line 978 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) getpagesize)(void)  __attribute__((__const__)) ;
#line 147 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strncmp)(char const   *__s1 ,
                                                                                                char const   *__s2 ,
                                                                                                size_t __n )  __attribute__((__pure__)) ;
#line 285
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1,2), __leaf__)) strcspn)(char const   *__s ,
                                                                                                   char const   *__reject )  __attribute__((__pure__)) ;
#line 289
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1,2), __leaf__)) strspn)(char const   *__s ,
                                                                                                  char const   *__accept )  __attribute__((__pure__)) ;
#line 538
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strncasecmp)(char const   *__s1 ,
                                                                                                    char const   *__s2 ,
                                                                                                    size_t __n )  __attribute__((__pure__)) ;
#line 34 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/art.h"
int art_gimme(char *group , int serial , struct article *ap ) ;
#line 35
int art_gimmenoderef(char *group , int serial , struct article *ap ) ;
#line 55
int art_makexover(struct article *ap , struct xover *xp ) ;
#line 56
char *art_findfield(char *head___14 , char *fieldname ) ;
#line 57
void art_filecachestat(int *hit , int *miss ) ;
#line 23 "./lib/b.h"
int b_appendl(struct b *bp , char *str , int len ) ;
#line 33 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/art.c"
struct fileobj *file_map(char *path___1 ) ;
#line 33 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/art.c"
static size_t pagesize  =    (size_t )0;
#line 31 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/art.c"
struct fileobj *file_map(char *path___1 ) 
{ 
  struct fileobj *fp ;
  struct stat st ;
  int fd ;
  int len ;
  int tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  int tmp___3 ;
  int *tmp___4 ;

  {
#line 39
  if (! pagesize) {
    {
#line 40
    tmp = getpagesize();
#line 40
    pagesize = (size_t )tmp;
    }
  }
  {
#line 42
  fd = open((char const   *)path___1, 0);
  }
#line 43
  if (fd > -1) {
    {
#line 45
    tmp___3 = fstat(fd, & st);
    }
#line 45
    if (tmp___3 > -1) {
      {
#line 47
      tmp___0 = strlen((char const   *)path___1);
#line 47
      len = (int )tmp___0;
#line 48
      tmp___2 = malloc((sizeof(struct fileobj ) + (unsigned long )len) + 1UL);
#line 48
      fp = (struct fileobj *)tmp___2;
      }
#line 48
      if (fp) {
        {
#line 50
        fp->size = (int )(((size_t )st.st_size / pagesize + 1UL) * pagesize);
#line 51
        tmp___1 = mmap((void *)0, (size_t )fp->size, 1, 1, fd, (__off_t )0);
#line 51
        fp->map = (char *)tmp___1;
        }
#line 52
        if (fp->map) {
#line 52
          if ((unsigned long )fp->map != (unsigned long )((void *)-1)) {
#line 54
            if (1027296 == *((int *)fp->map)) {
              {
#line 56
              close(fd);
#line 57
              fp->path = strcpy((char */* __restrict  */)((char *)fp + sizeof(struct fileobj )),
                                (char const   */* __restrict  */)path___1);
              }
#line 58
              return (fp);
            } else {
              {
#line 61
              log_((char *)"file_map:%s has bad magic", path___1);
              }
            }
          } else {
            {
#line 64
            log_((char *)"file_map:mmap:%m");
            }
          }
        } else {
          {
#line 64
          log_((char *)"file_map:mmap:%m");
          }
        }
        {
#line 65
        munmap((void *)fp->map, (size_t )fp->size);
        }
      } else {
        {
#line 68
        log_((char *)"file_map:malloc:%m");
        }
      }
      {
#line 69
      free((void *)fp);
      }
    } else {
      {
#line 72
      log_((char *)"file_map:fstat:%m");
      }
    }
    {
#line 73
    close(fd);
    }
  } else {
    {
#line 75
    tmp___4 = __errno_location();
    }
#line 75
    if (2 != *tmp___4) {
      {
#line 76
      log_((char *)"file_map:open(%s):%m", path___1);
      }
    }
  }
#line 77
  return ((struct fileobj *)((void *)0));
}
}
#line 80 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/art.c"
static void file_unmap(void *p ) 
{ 
  struct fileobj *fp ;

  {
  {
#line 82
  fp = (struct fileobj *)p;
#line 84
  munmap((void *)fp->map, (size_t )fp->size);
#line 85
  free((void *)fp);
  }
#line 86
  return;
}
}
#line 88 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/art.c"
static int file_cmp(void *a , void *b___13 ) 
{ 
  struct fileobj *x ;
  struct fileobj *y ;
  int tmp ;

  {
  {
#line 90
  x = (struct fileobj *)a;
#line 91
  y = (struct fileobj *)b___13;
#line 93
  tmp = strcmp((char const   *)x->path, (char const   *)y->path);
  }
#line 93
  return (tmp);
}
}
#line 96 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/art.c"
static int desc___1  =    -1;
#line 98 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/art.c"
static int file_init(void) 
{ 


  {
  {
#line 100
  desc___1 = cache_init(8, & file_cmp, & file_unmap, (int (*)(void * ))((void *)0));
  }
#line 101
  if (-1 == desc___1) {
    {
#line 103
    log_((char *)"file_init:%m");
    }
#line 104
    return (-1);
  }
#line 106
  return (0);
}
}
#line 109 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/art.c"
static struct file *file_gimme(char *name , int *size___1 ) 
{ 
  struct fileobj f___9 ;
  struct fileobj *fp ;
  void *tmp ;

  {
  {
#line 111
  f___9.path = (char *)0;
#line 111
  f___9.map = (char *)0;
#line 111
  f___9.size = 0;
#line 114
  f___9.path = name;
#line 116
  tmp = cache_find(desc___1, (void *)(& f___9));
#line 116
  fp = (struct fileobj *)tmp;
  }
#line 116
  if ((unsigned long )((void *)0) == (unsigned long )fp) {
    {
#line 118
    fp = file_map(name);
    }
#line 118
    if ((unsigned long )((void *)0) == (unsigned long )fp) {
#line 119
      return ((struct file *)((void *)0));
    } else {
      {
#line 121
      cache_insert(desc___1, (void *)fp);
      }
    }
  }
#line 124
  if (size___1) {
#line 125
    *size___1 = fp->size;
  }
#line 126
  return ((struct file *)fp->map);
}
}
#line 137 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/art.c"
static bool file_initialized  =    (bool )0;
#line 139 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/art.c"
int art_gimmenoderef(char *group , int serial , struct article *ap ) 
{ 
  struct file *f___9 ;
  struct info info ;
  char path___1[287] ;
  int filenumber ;
  int part ;
  int filesize ;
  int lim ;
  size_t tmp ;
  int tmp___0 ;
  int *tmp___1 ;
  struct fileobj fo ;
  int *tmp___2 ;

  {
#line 148
  if (serial < 0) {
#line 149
    return (-1);
  }
  {
#line 150
  tmp = strlen((char const   *)group);
  }
#line 150
  if (tmp >= 255UL) {
#line 151
    return (-1);
  }
#line 153
  if (! file_initialized) {
    {
#line 155
    tmp___0 = file_init();
    }
#line 155
    if (-1 == tmp___0) {
#line 156
      return (-1);
    } else {
#line 158
      file_initialized = (bool )1;
    }
  }
  {
#line 161
  filenumber = serial / 10;
#line 162
  part = serial % 10;
#line 164
  formats(path___1, (int )(sizeof(path___1) - 1UL), (char *)"%s/%d", group, filenumber);
  }
  {
#line 168
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 170
    f___9 = file_gimme(path___1, & filesize);
    }
#line 170
    if (! f___9) {
#line 171
      return (-1);
    }
#line 172
    lim = (int )(f___9->info[part].boffset + f___9->info[part].blen);
#line 173
    if (lim <= 0) {
      {
#line 175
      tmp___1 = __errno_location();
#line 175
      *tmp___1 = 2;
      }
#line 176
      return (-1);
    }
#line 178
    if (lim <= filesize) {
#line 179
      goto while_break;
    }
    {
#line 184
    fo.path = path___1;
#line 185
    cache_invalidate(desc___1, (void *)(& fo));
#line 188
    f___9 = file_gimme(path___1, & filesize);
    }
#line 188
    if (! f___9) {
#line 189
      return (-1);
    }
#line 190
    lim = (int )(f___9->info[part].boffset + f___9->info[part].blen);
#line 191
    if (lim <= 0) {
      {
#line 193
      tmp___2 = __errno_location();
#line 193
      *tmp___2 = 2;
      }
#line 194
      return (-1);
    }
#line 196
    if (lim <= filesize) {
#line 197
      goto while_break;
    }
    {
#line 198
    log_((char *)"art_gimmenoderef:body extends beyond file in %s:%d", group, serial);
    }
#line 199
    return (-1);
#line 168
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 205
  info = f___9->info[part];
#line 206
  if (info.hoffset <= (int volatile   )0) {
#line 206
    goto _L;
  } else
#line 206
  if (info.boffset <= (int volatile   )0) {
    _L: /* CIL Label */ 
#line 208
    if (0 == (int )info.hoffset) {
#line 210
      if (info.boffset) {
        {
#line 211
        log_((char *)"art_gimmenoderef:corrupted index in %s:%d", group, serial);
        }
      }
    } else
#line 213
    if (info.hoffset < (int volatile   )0) {
#line 214
      if (info.boffset >= (int volatile   )0) {
        {
#line 215
        log_((char *)"art_gimmenoderef:bad cancel in %s:%d", group, serial);
        }
      }
    }
#line 216
    return (-1);
  }
#line 218
  if (info.blen < (int volatile   )2) {
    {
#line 220
    log_((char *)"art_gimmenoderef:Corrupted index in %s:%d", group, serial);
    }
#line 221
    return (-1);
  } else
#line 218
  if (info.hlen <= (int volatile   )11) {
    {
#line 220
    log_((char *)"art_gimmenoderef:Corrupted index in %s:%d", group, serial);
    }
#line 221
    return (-1);
  }
#line 224
  ap->head = ((char *)f___9 + info.hoffset) + 1;
#line 225
  ap->hlen = (int )(info.hlen - (int volatile   )2);
#line 226
  if (*(ap->head + -1)) {
    {
#line 228
    log_((char *)"art_gimmenoderef:Bad header in %s:%d", group, serial);
    }
#line 229
    return (-1);
  }
#line 232
  ap->body = ((char *)f___9 + f___9->info[part].boffset) + 1;
#line 233
  ap->blen = (int )(f___9->info[part].blen - (int volatile   )2);
#line 235
  return (0);
}
}
#line 248 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/art.c"
static char ngroup[287]  ;
#line 238 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/art.c"
int art_gimme(char *group , int serial , struct article *ap ) 
{ 
  int deref ;
  char *g ;
  int s ;
  char *p ;
  char *q ;
  char *lim ;
  int c ;
  int tmp ;
  int tmp___0 ;
  char tmp___1 ;
  char *tmp___2 ;

  {
#line 244
  g = group;
#line 245
  s = serial;
#line 246
  deref = 0;
  {
#line 246
  while (1) {
    while_continue: /* CIL Label */ ;
#line 254
    if (deref >= 10) {
#line 256
      if (debug >= 1) {
        {
#line 256
        log_((char *)"Too many aliases under %s:%d", g, s);
        }
      }
#line 257
      return (-1);
    }
    {
#line 259
    tmp = art_gimmenoderef(group, serial, ap);
    }
#line 259
    if (-1 == tmp) {
#line 260
      return (-1);
    }
#line 261
    if (-1 == ap->blen) {
#line 262
      return (-1);
    }
#line 269
    if (ap->blen > 0) {
      {
#line 269
      tmp___0 = strncmp((char const   *)ap->head, "Message-ID:", (size_t )11);
      }
#line 269
      if (tmp___0) {
#line 270
        return (0);
      }
    }
#line 272
    p = ap->head + 11;
    {
#line 272
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 272
      if (! (32 == (int )*p)) {
#line 272
        goto while_break___0;
      }
#line 272
      p ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 273
    lim = ngroup + sizeof(ngroup);
#line 274
    q = ngroup;
    {
#line 274
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 274
      tmp___1 = *p;
#line 274
      *q = tmp___1;
#line 274
      if ((int )tmp___1 != 58) {
#line 274
        if (! ((unsigned long )q < (unsigned long )lim)) {
#line 274
          goto while_break___1;
        }
      } else {
#line 274
        goto while_break___1;
      }
#line 274
      q ++;
#line 274
      p ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 275
    tmp___2 = p;
#line 275
    p ++;
#line 275
    if (58 != (int )*tmp___2) {
#line 276
      goto while_break;
    }
#line 277
    *q = (char )'\000';
#line 278
    serial = 0;
    {
#line 278
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 280
      c = (int )*p - 48;
#line 281
      if (c > 9) {
#line 282
        goto while_break___2;
      } else
#line 281
      if (c < 0) {
#line 282
        goto while_break___2;
      }
#line 278
      serial *= 10;
#line 278
      serial += c;
#line 278
      p ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 284
    if (60 != (int )*p) {
#line 285
      goto while_break;
    }
#line 286
    group = ngroup;
#line 246
    deref ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 288
  log_((char *)"art_gimme:bad alias under %s:%d", g, s);
  }
#line 289
  return (-1);
}
}
#line 292 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/art.c"
void art_filecachestat(int *hit , int *miss ) 
{ 


  {
  {
#line 294
  cache_stat(desc___1, hit, miss);
  }
#line 295
  return;
}
}
#line 297 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/art.c"
static int getfield(char *buf___28 , struct field *f___9 ) 
{ 
  register char *cp ;
  size_t tmp ;
  size_t tmp___0 ;

  {
  {
#line 299
  cp = buf___28;
#line 301
  tmp = strspn((char const   *)cp, " \t\f");
#line 301
  cp += tmp;
  }
#line 302
  if (! *cp) {
#line 304
    f___9->pointer = (char *)((void *)0);
#line 305
    return (0);
  }
  {
#line 307
  tmp___0 = strcspn((char const   *)cp, "\r\n");
#line 307
  f___9->len = (int )tmp___0;
  }
#line 308
  if (! f___9->len) {
#line 309
    return (0);
  }
#line 310
  f___9->pointer = cp;
#line 311
  return ((int )((cp + f___9->len) - buf___28));
}
}
#line 320 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/art.c"
int art_makexover(struct article *ap , struct xover *xp ) 
{ 
  struct xover x ;
  char *cp ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;

  {
#line 322
  x.subject.pointer = (char *)0;
#line 322
  x.subject.len = 0;
#line 322
  x.from.pointer = (char *)0;
#line 322
  x.from.len = 0;
#line 322
  x.date.pointer = (char *)0;
#line 322
  x.date.len = 0;
#line 322
  x.messageid.pointer = (char *)0;
#line 322
  x.messageid.len = 0;
#line 322
  x.references.pointer = (char *)0;
#line 322
  x.references.len = 0;
#line 322
  x.bytes.pointer = (char *)0;
#line 322
  x.bytes.len = 0;
#line 322
  x.lines.pointer = (char *)0;
#line 322
  x.lines.len = 0;
#line 325
  if ((unsigned long )((void *)0) == (unsigned long )ap) {
#line 326
    return (-1);
  } else
#line 325
  if ((unsigned long )((void *)0) == (unsigned long )ap->head) {
#line 326
    return (-1);
  } else
#line 325
  if ((unsigned long )((void *)0) == (unsigned long )xp) {
#line 326
    return (-1);
  }
#line 328
  cp = ap->head;
#line 330
  goto start;
  {
#line 332
  while (1) {
    while_continue: /* CIL Label */ ;
#line 332
    if (! *cp) {
#line 332
      goto while_break;
    }
#line 334
    if (10 == (int )*cp) {
#line 334
      if (*(cp + 1)) {
#line 336
        cp ++;
        start: 
        {
#line 340
        if ((int )*cp == 83) {
#line 340
          goto case_83;
        }
#line 340
        if ((int )*cp == 115) {
#line 340
          goto case_83;
        }
#line 344
        if ((int )*cp == 70) {
#line 344
          goto case_70;
        }
#line 344
        if ((int )*cp == 102) {
#line 344
          goto case_70;
        }
#line 348
        if ((int )*cp == 68) {
#line 348
          goto case_68;
        }
#line 348
        if ((int )*cp == 100) {
#line 348
          goto case_68;
        }
#line 352
        if ((int )*cp == 77) {
#line 352
          goto case_77;
        }
#line 352
        if ((int )*cp == 109) {
#line 352
          goto case_77;
        }
#line 356
        if ((int )*cp == 82) {
#line 356
          goto case_82;
        }
#line 356
        if ((int )*cp == 114) {
#line 356
          goto case_82;
        }
#line 360
        if ((int )*cp == 66) {
#line 360
          goto case_66;
        }
#line 360
        if ((int )*cp == 98) {
#line 360
          goto case_66;
        }
#line 364
        if ((int )*cp == 76) {
#line 364
          goto case_76;
        }
#line 364
        if ((int )*cp == 108) {
#line 364
          goto case_76;
        }
#line 368
        goto switch_default;
        case_83: /* CIL Label */ 
        case_115: /* CIL Label */ 
#line 341
        if (! x.subject.pointer) {
          {
#line 341
          tmp___0 = strncasecmp((char const   *)cp, "subject:", sizeof("subject:") - 1UL);
          }
#line 341
          if (0 == tmp___0) {
            {
#line 342
            tmp = getfield((cp + sizeof("subject:")) - 1, & x.subject);
#line 342
            cp += tmp;
            }
          }
        }
#line 343
        goto switch_break;
        case_70: /* CIL Label */ 
        case_102: /* CIL Label */ 
#line 345
        if (! x.from.pointer) {
          {
#line 345
          tmp___2 = strncasecmp((char const   *)cp, "from:", sizeof("from:") - 1UL);
          }
#line 345
          if (0 == tmp___2) {
            {
#line 346
            tmp___1 = getfield((cp + sizeof("from:")) - 1, & x.from);
#line 346
            cp += tmp___1;
            }
          }
        }
#line 347
        goto switch_break;
        case_68: /* CIL Label */ 
        case_100: /* CIL Label */ 
#line 349
        if (! x.date.pointer) {
          {
#line 349
          tmp___4 = strncasecmp((char const   *)cp, "date:", sizeof("date:") - 1UL);
          }
#line 349
          if (0 == tmp___4) {
            {
#line 350
            tmp___3 = getfield((cp + sizeof("date:")) - 1, & x.date);
#line 350
            cp += tmp___3;
            }
          }
        }
#line 351
        goto switch_break;
        case_77: /* CIL Label */ 
        case_109: /* CIL Label */ 
#line 353
        if (! x.messageid.pointer) {
          {
#line 353
          tmp___6 = strncasecmp((char const   *)cp, "message-id:", sizeof("message-id:") - 1UL);
          }
#line 353
          if (0 == tmp___6) {
            {
#line 354
            tmp___5 = getfield((cp + sizeof("message-id:")) - 1, & x.messageid);
#line 354
            cp += tmp___5;
            }
          }
        }
#line 355
        goto switch_break;
        case_82: /* CIL Label */ 
        case_114: /* CIL Label */ 
#line 357
        if (! x.references.pointer) {
          {
#line 357
          tmp___8 = strncasecmp((char const   *)cp, "references:", sizeof("references:") - 1UL);
          }
#line 357
          if (0 == tmp___8) {
            {
#line 358
            tmp___7 = getfield((cp + sizeof("references:")) - 1, & x.references);
#line 358
            cp += tmp___7;
            }
          }
        }
#line 359
        goto switch_break;
        case_66: /* CIL Label */ 
        case_98: /* CIL Label */ 
#line 361
        if (! x.bytes.pointer) {
          {
#line 361
          tmp___10 = strncasecmp((char const   *)cp, "bytes:", sizeof("bytes:") - 1UL);
          }
#line 361
          if (0 == tmp___10) {
            {
#line 362
            tmp___9 = getfield((cp + sizeof("bytes:")) - 1, & x.bytes);
#line 362
            cp += tmp___9;
            }
          }
        }
#line 363
        goto switch_break;
        case_76: /* CIL Label */ 
        case_108: /* CIL Label */ 
#line 365
        if (! x.lines.pointer) {
          {
#line 365
          tmp___12 = strncasecmp((char const   *)cp, "lines:", sizeof("lines:") - 1UL);
          }
#line 365
          if (0 == tmp___12) {
            {
#line 366
            tmp___11 = getfield((cp + sizeof("lines:")) - 1, & x.lines);
#line 366
            cp += tmp___11;
            }
          }
        }
#line 367
        goto switch_break;
        switch_default: /* CIL Label */ ;
        switch_break: /* CIL Label */ ;
        }
      }
    }
#line 372
    cp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 375
  *xp = x;
#line 376
  return (0);
}
}
#line 383 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/art.c"
static struct b b  =    {(char *)0, 0, 0};
#line 379 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/art.c"
char *art_findfield(char *head___14 , char *fieldname ) 
{ 
  int len ;
  char *cp ;
  char c ;
  size_t tmp ;
  char *start___0 ;
  size_t tmp___0 ;
  int tmp___1 ;

  {
  {
#line 382
  cp = head___14;
#line 386
  tmp = strlen((char const   *)fieldname);
#line 386
  len = (int )tmp;
#line 387
  b.used = 0;
#line 388
  c = (char )((int )*fieldname & -33);
  }
#line 390
  goto enter;
  {
#line 392
  while (1) {
    while_continue: /* CIL Label */ ;
#line 392
    if (! *cp) {
#line 392
      goto while_break;
    }
#line 394
    if (10 != (int )*cp) {
#line 395
      goto __Cont;
    }
#line 396
    cp ++;
    enter: 
#line 398
    if (((int )*cp & -33) == (int )c) {
      {
#line 398
      tmp___1 = strncasecmp((char const   *)cp, (char const   *)fieldname, (size_t )len);
      }
#line 398
      if (0 == tmp___1) {
#line 400
        start___0 = cp + len;
#line 402
        if (58 != (int )*start___0) {
#line 403
          goto __Cont;
        }
        {
#line 404
        start___0 ++;
#line 405
        tmp___0 = strspn((char const   *)start___0, " \t\r\n\f");
#line 405
        start___0 += tmp___0;
#line 406
        cp = start___0;
        }
        {
#line 406
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 406
          if (*cp) {
#line 406
            if (! (13 != (int )*cp)) {
#line 406
              goto while_break___0;
            }
          } else {
#line 406
            goto while_break___0;
          }
#line 406
          cp ++;
        }
        while_break___0: /* CIL Label */ ;
        }
        {
#line 407
        b_appendl(& b, start___0, (int )(cp - start___0));
        }
#line 408
        return (b.buf);
      }
    }
    __Cont: /* CIL Label */ 
#line 392
    cp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 411
  return ((char *)"");
}
}
#line 137 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcat)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 45 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/dhash.h"
int dh_open(char *pre , bool readonly ) ;
#line 46
int dh_close(void) ;
#line 48
int dh_find(struct data *dp , bool readonly ) ;
#line 70
struct table___0 *dh_table ;
#line 15 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/allocate.h"
void *allo_deref(unsigned int offset ) ;
#line 23
int allo_init(char *path___1 , int flag ) ;
#line 35
int allo_destroy(void) ;
#line 16 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/newsgroup.h"
void ng_fin(void) ;
#line 20
int ng_init(void) ;
#line 24
char *ng_newsgroup(int ident ) ;
#line 28 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/dh_find.c"
int dh_fd  =    -1;
#line 30 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/dh_find.c"
char dh_tablefile[sizeof(".table") + 32UL]  ;
#line 31 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/dh_find.c"
char dh_chainfile[sizeof(".table") + 32UL]  ;
#line 32 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/dh_find.c"
char dh_groupfile[sizeof(".newsgroup") + 32UL]  ;
#line 33 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/dh_find.c"
char dh_tmp[sizeof(".newsgroup") + 32UL]  ;
#line 34 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/dh_find.c"
bool dh_isreadonly  =    (bool )0;
#line 36 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/dh_find.c"
struct table___0 *dh_table  =    (struct table___0 *)((void *)0);
#line 40 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/dh_find.c"
unsigned int dhhash(char *buf___28 ) 
{ 
  unsigned int h ;
  int len ;
  size_t tmp ;
  char *tmp___0 ;

  {
  {
#line 43
  tmp = strlen((char const   *)buf___28);
#line 43
  len = (int )tmp;
#line 45
  h = 5381U;
  }
  {
#line 46
  while (1) {
    while_continue: /* CIL Label */ ;
#line 46
    if (! len) {
#line 46
      goto while_break;
    }
#line 48
    len --;
#line 49
    h += h << 5;
#line 50
    tmp___0 = buf___28;
#line 50
    buf___28 ++;
#line 50
    h ^= (unsigned int )*tmp___0;
  }
  while_break: /* CIL Label */ ;
  }
#line 52
  return (h % 10240U);
}
}
#line 62 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/dh_find.c"
int dhlock(void) 
{ 
  int i ;
  int tmp ;
  int *tmp___0 ;
  int tmp___1 ;

  {
#line 66
  i = 100;
  {
#line 66
  while (1) {
    while_continue: /* CIL Label */ ;
#line 66
    tmp___1 = i;
#line 66
    i --;
#line 66
    if (! tmp___1) {
#line 66
      goto while_break;
    }
    {
#line 68
    tmp = lockf(dh_fd, 2, (__off_t )0);
    }
#line 68
    if (tmp == 0) {
#line 69
      return (0);
    }
    {
#line 70
    tmp___0 = __errno_location();
    }
#line 70
    if (*tmp___0 != 11) {
#line 71
      return (-1);
    }
    {
#line 72
    nap(0, 500);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 74
  return (-1);
}
}
#line 77 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/dh_find.c"
int dhunlock(void) 
{ 


  {
  {
#line 79
  lseek(dh_fd, (__off_t )0, 0);
#line 80
  lockf(dh_fd, 0, (__off_t )0);
  }
#line 81
  return (0);
}
}
#line 84 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/dh_find.c"
struct chain *dhlocatechain(char *messageid___0 ) 
{ 
  unsigned int index___0 ;
  unsigned char *x ;
  unsigned int h ;
  struct chain *chp ;
  void *tmp ;

  {
  {
#line 91
  h = dhhash(messageid___0);
#line 92
  x = dh_table->next + h * 3U;
#line 93
  index___0 = (unsigned int )((((int )*(x + 0) << 18) | ((int )*(x + 1) << 10)) | ((int )*(x + 2) << 2));
  }
#line 94
  if (index___0 == 0U) {
#line 95
    return ((struct chain *)((void *)0));
  }
  {
#line 97
  tmp = allo_deref(index___0);
#line 97
  chp = (struct chain *)tmp;
  }
#line 98
  if ((unsigned long )chp == (unsigned long )((void *)0)) {
    {
#line 100
    log_((char *)"dhlocatechain:bad allo deref");
    }
  }
#line 102
  return (chp);
}
}
#line 105 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/dh_find.c"
static int initfile(void) 
{ 
  int fd ;
  int integer ;
  int i ;
  char foo[3] ;
  unsigned int tmp ;
  int *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  ssize_t tmp___3 ;
  ssize_t tmp___4 ;

  {
#line 108
  integer = 218885376;
#line 110
  foo[0] = (char )'\000';
#line 110
  tmp = 1U;
  {
#line 110
  while (1) {
    while_continue: /* CIL Label */ ;
#line 110
    if (tmp >= 3U) {
#line 110
      goto while_break;
    }
#line 110
    foo[tmp] = (char)0;
#line 110
    tmp ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 112
  fd = open((char const   *)(dh_tablefile), 194, 420);
  }
#line 113
  if (fd == -1) {
#line 114
    return (-1);
  }
  {
#line 115
  tmp___2 = lockf(fd, 2, (__off_t )0);
  }
#line 115
  if (tmp___2 == -1) {
    {
#line 117
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 119
      tmp___0 = __errno_location();
      }
#line 119
      if (*tmp___0 == 11) {
        {
#line 120
        nap(0, 200);
        }
      } else {
#line 122
        goto fail;
      }
      {
#line 117
      tmp___1 = lockf(fd, 2, (__off_t )0);
      }
#line 117
      if (! (tmp___1 == -1)) {
#line 117
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 125
    lockf(fd, 0, (__off_t )0);
    }
#line 126
    return (fd);
  }
  {
#line 128
  tmp___3 = write(fd, (void const   *)(& integer), sizeof(int ));
  }
#line 128
  if ((unsigned long )tmp___3 != sizeof(int )) {
#line 129
    goto fail;
  }
#line 130
  i = 0;
  {
#line 130
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 130
    if (! (i < 10240)) {
#line 130
      goto while_break___1;
    }
    {
#line 131
    tmp___4 = write(fd, (void const   *)(foo), sizeof(foo));
    }
#line 131
    if ((unsigned long )tmp___4 != sizeof(foo)) {
#line 132
      goto fail;
    }
#line 130
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 133
  lseek(fd, (__off_t )0, 0);
#line 134
  lockf(fd, 0, (__off_t )0);
  }
#line 135
  return (fd);
  fail: 
#line 138
  if (fd > -1) {
    {
#line 139
    close(fd);
    }
  }
#line 140
  return (-1);
}
}
#line 143 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/dh_find.c"
int dh_find(struct data *dp , bool readonly ) 
{ 
  struct chain *chp ;
  unsigned char *x ;
  int tmp ;
  unsigned int index___0 ;
  void *tmp___0 ;
  int tmp___1 ;

  {
#line 148
  if (! readonly) {
    {
#line 149
    tmp = dhlock();
    }
#line 149
    if (tmp == -1) {
#line 150
      return (-1);
    }
  }
  {
#line 151
  chp = dhlocatechain(dp->messageid);
  }
#line 152
  if ((unsigned long )chp == (unsigned long )((void *)0)) {
#line 153
    goto fail;
  }
  {
#line 154
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 154
    tmp___1 = strcmp((char const   *)dp->messageid, (char const   *)(chp->messageid));
    }
#line 154
    if (! (tmp___1 != 0)) {
#line 154
      goto while_break;
    }
#line 156
    index___0 = (unsigned int )chp->next;
#line 158
    if (index___0 == 0U) {
#line 159
      goto fail;
    }
    {
#line 160
    tmp___0 = allo_deref(index___0);
#line 160
    chp = (struct chain *)tmp___0;
    }
#line 161
    if ((unsigned long )chp == (unsigned long )((void *)0)) {
#line 163
      if (debug >= 2) {
        {
#line 163
        log_((char *)"dh_find:bad allo deref");
        }
      }
#line 164
      goto fail;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 167
  dp->serial = chp->serial;
#line 168
  x = (unsigned char *)(chp->newsgroup);
#line 169
  dp->newsgroup = ng_newsgroup(((int )*(x + 0) << 8) | (int )*(x + 1));
  }
#line 170
  if ((unsigned long )dp->newsgroup == (unsigned long )((void *)0)) {
#line 171
    goto fail;
  }
#line 172
  if (! readonly) {
    {
#line 173
    dhunlock();
    }
  }
#line 174
  return (0);
  fail: 
#line 177
  if (! readonly) {
    {
#line 178
    dhunlock();
    }
  }
#line 179
  return (-1);
}
}
#line 182 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/dh_find.c"
int dh_open(char *pre , bool readonly ) 
{ 
  struct stat st ;
  int prot ;
  int openflag ;
  size_t tmp ;
  int *tmp___0 ;
  int tmp___1 ;
  void *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 188
  if (pre) {
#line 188
    if (*pre) {
      {
#line 190
      tmp = strlen((char const   *)pre);
      }
#line 190
      if (tmp > 27UL) {
        {
#line 192
        log_((char *)"SNROOT too long");
        }
#line 193
        return (-1);
      }
      {
#line 195
      strcpy((char */* __restrict  */)(dh_tablefile), (char const   */* __restrict  */)pre);
#line 196
      strcat((char */* __restrict  */)(dh_tablefile), (char const   */* __restrict  */)".table");
#line 197
      strcpy((char */* __restrict  */)(dh_chainfile), (char const   */* __restrict  */)pre);
#line 198
      strcat((char */* __restrict  */)(dh_chainfile), (char const   */* __restrict  */)".chain");
#line 199
      strcpy((char */* __restrict  */)(dh_groupfile), (char const   */* __restrict  */)pre);
#line 200
      strcat((char */* __restrict  */)(dh_groupfile), (char const   */* __restrict  */)".newsgroup");
      }
    } else {
      {
#line 204
      strcpy((char */* __restrict  */)(dh_tablefile), (char const   */* __restrict  */)".table");
#line 205
      strcpy((char */* __restrict  */)(dh_chainfile), (char const   */* __restrict  */)".chain");
#line 206
      strcpy((char */* __restrict  */)(dh_groupfile), (char const   */* __restrict  */)".newsgroup");
      }
    }
  } else {
    {
#line 204
    strcpy((char */* __restrict  */)(dh_tablefile), (char const   */* __restrict  */)".table");
#line 205
    strcpy((char */* __restrict  */)(dh_chainfile), (char const   */* __restrict  */)".chain");
#line 206
    strcpy((char */* __restrict  */)(dh_groupfile), (char const   */* __restrict  */)".newsgroup");
    }
  }
#line 209
  prot = 1;
#line 210
  dh_isreadonly = (bool )(! (! readonly));
#line 210
  if (dh_isreadonly) {
#line 216
    openflag = 0;
  } else {
#line 212
    openflag = 2;
#line 213
    prot |= 2;
  }
  {
#line 218
  dh_fd = open((char const   *)(dh_tablefile), openflag);
  }
#line 218
  if (dh_fd == -1) {
    {
#line 220
    tmp___0 = __errno_location();
    }
#line 220
    if (*tmp___0 == 2) {
      {
#line 222
      dh_fd = initfile();
      }
#line 222
      if (dh_fd == -1) {
        {
#line 224
        log_((char *)"dh_open:Can\'t create %s: %m", dh_tablefile);
        }
#line 225
        return (-1);
      }
    } else {
      {
#line 230
      log_((char *)"dh_open:Can\'t open %s: %m", dh_tablefile);
      }
#line 231
      return (-1);
    }
  }
  {
#line 235
  tmp___1 = ng_init();
  }
#line 235
  if (tmp___1 == -1) {
#line 236
    goto fail;
  }
  {
#line 238
  tmp___2 = mmap((void *)0, sizeof(struct table___0 ), prot, 1, dh_fd, (__off_t )0);
#line 238
  dh_table = (struct table___0 *)tmp___2;
  }
#line 240
  if ((unsigned long )dh_table == (unsigned long )((void *)0)) {
    {
#line 242
    log_((char *)"dh_open:mmap:%m?");
#line 243
    dh_table = (struct table___0 *)((void *)0);
    }
  } else
#line 240
  if ((unsigned long )dh_table == (unsigned long )((void *)-1)) {
    {
#line 242
    log_((char *)"dh_open:mmap:%m?");
#line 243
    dh_table = (struct table___0 *)((void *)0);
    }
  } else
#line 245
  if (dh_table->magic != 218885376) {
    {
#line 246
    log_((char *)"dh_open:Bad magic");
    }
  } else {
    {
#line 247
    tmp___5 = fstat(dh_fd, & st);
    }
#line 247
    if (tmp___5 == -1) {
      {
#line 248
      log_((char *)"dh_open:fstat:%m");
      }
    } else
#line 249
    if ((unsigned long )st.st_size != sizeof(struct table___0 )) {
      {
#line 250
      log_((char *)"dh_open:table has wrong size!");
      }
    } else {
      {
#line 251
      tmp___3 = allo_init(dh_chainfile, openflag);
      }
#line 251
      if (tmp___3 == -1) {
        {
#line 251
        tmp___4 = allo_init(dh_chainfile, openflag | 64);
        }
#line 251
        if (tmp___4 == -1) {
          {
#line 254
          log_((char *)"dh_open:allo_init(%s):%m?", dh_chainfile);
          }
        } else {
#line 257
          return (0);
        }
      } else {
#line 257
        return (0);
      }
    }
  }
#line 258
  if (dh_table) {
    {
#line 260
    munmap((void *)dh_table, sizeof(struct table___0 ));
#line 261
    dh_table = (struct table___0 *)0;
    }
  }
  {
#line 263
  ng_fin();
  }
  fail: 
  {
#line 266
  close(dh_fd);
#line 267
  dh_fd = -1;
  }
#line 268
  return (dh_fd);
}
}
#line 271 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/dh_find.c"
int dh_close(void) 
{ 


  {
#line 273
  if (dh_fd > -1) {
    {
#line 275
    close(dh_fd);
#line 276
    dh_fd = -1;
    }
  }
#line 278
  if ((unsigned long )dh_table != (unsigned long )((void *)0)) {
    {
#line 280
    munmap((void *)((caddr_t )dh_table), sizeof(struct table___0 ));
#line 281
    dh_table = (struct table___0 *)((void *)0);
    }
  }
  {
#line 283
  allo_destroy();
#line 284
  ng_fin();
  }
#line 285
  return (0);
}
}
#line 879 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) gethostname)(char *__name ,
                                                                                                  size_t __len ) ;
#line 236 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strchr)(char const   *__s ,
                                                                                               int __c )  __attribute__((__pure__)) ;
#line 144 "/usr/include/netdb.h"
extern struct hostent *gethostbyname(char const   *__name ) ;
#line 17 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/hostname.c"
char *myname(void) 
{ 
  int fd ;
  char *host___0 ;
  char buf___28[256] ;
  int count ;
  char *cp ;
  ssize_t tmp ;
  struct hostent *hp ;
  int tmp___0 ;

  {
  {
#line 20
  host___0 = (char *)((void *)0);
#line 24
  fd = open(".me", 0);
  }
#line 24
  if (fd > -1) {
    {
#line 26
    tmp = read(fd, (void *)(buf___28), sizeof(buf___28) - 1UL);
#line 26
    count = (int )tmp;
    }
#line 26
    if (count > 0) {
      {
#line 30
      buf___28[count] = (char )'\000';
#line 31
      cp = strchr((char const   *)(buf___28), '\n');
      }
#line 31
      if (cp) {
#line 32
        *cp = (char )'\000';
      }
      {
#line 33
      cp = strchr((char const   *)(buf___28), '\r');
      }
#line 33
      if (cp) {
#line 34
        *cp = (char )'\000';
      }
      {
#line 35
      host___0 = strdup((char const   *)(buf___28));
      }
    }
    {
#line 37
    close(fd);
    }
  }
#line 40
  if (! host___0) {
    {
#line 44
    tmp___0 = gethostname(buf___28, sizeof(buf___28));
    }
#line 44
    if (0 == tmp___0) {
      {
#line 46
      hp = gethostbyname((char const   *)(buf___28));
      }
#line 47
      if (hp) {
#line 48
        host___0 = hp->h_name;
      }
    }
  }
#line 51
  if ((unsigned long )((void *)0) == (unsigned long )host___0) {
    {
#line 52
    host___0 = strdup("localhost");
    }
  }
#line 53
  return (host___0);
}
}
#line 19 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/allocate.h"
int allo_ref(void *obj ) ;
#line 27
int allo_make(int size___1 ) ;
#line 31
int allo_free(int chunk , int size___1 ) ;
#line 78 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/allocate.c"
static struct table___1 table___0  =    {(char *)0, (char *)0, 0, 0, 0, 0};
#line 80
static int remapfile(void) ;
#line 82 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/allocate.c"
void *allo_deref(unsigned int offset ) 
{ 
  int tmp ;

  {
#line 84
  if (offset >= (unsigned int )(table___0.size - 256)) {
    {
#line 86
    tmp = remapfile();
    }
#line 86
    if (-1 == tmp) {
#line 87
      return ((void *)0);
    } else
#line 88
    if (offset >= (unsigned int )table___0.size) {
#line 89
      return ((void *)0);
    }
  }
#line 91
  return ((void *)(table___0.map + offset));
}
}
#line 94 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/allocate.c"
int allo_ref(void *obj ) 
{ 
  int off ;

  {
#line 98
  off = (int )obj - (int )table___0.map;
#line 99
  if (off >= table___0.size) {
#line 100
    return (-1);
  }
#line 101
  return (off);
}
}
#line 106 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/allocate.c"
static int initfile___0(char *filename ) 
{ 
  struct chainfile cf ;
  int fd ;
  int i ;
  int ret ;
  ssize_t tmp ;
  int pad ;
  ssize_t tmp___0 ;

  {
  {
#line 108
  cf.chain_magic = 0;
#line 108
  cf.next[0] = 0;
#line 108
  cf.next[1] = 0;
#line 108
  cf.next[2] = 0;
#line 108
  cf.next[3] = 0;
#line 108
  cf.next[4] = 0;
#line 108
  cf.next[5] = 0;
#line 108
  cf.next[6] = 0;
#line 108
  cf.next[7] = 0;
#line 108
  cf.next[8] = 0;
#line 108
  cf.next[9] = 0;
#line 108
  cf.next[10] = 0;
#line 108
  cf.next[11] = 0;
#line 108
  cf.next[12] = 0;
#line 108
  cf.next[13] = 0;
#line 108
  cf.next[14] = 0;
#line 108
  cf.next[15] = 0;
#line 108
  cf.next[16] = 0;
#line 108
  cf.next[17] = 0;
#line 108
  cf.next[18] = 0;
#line 108
  cf.next[19] = 0;
#line 108
  cf.next[20] = 0;
#line 108
  cf.next[21] = 0;
#line 108
  cf.next[22] = 0;
#line 108
  cf.next[23] = 0;
#line 108
  cf.next[24] = 0;
#line 108
  cf.next[25] = 0;
#line 108
  cf.next[26] = 0;
#line 108
  cf.next[27] = 0;
#line 108
  cf.next[28] = 0;
#line 108
  cf.next[29] = 0;
#line 108
  cf.next[30] = 0;
#line 108
  cf.next[31] = 0;
#line 108
  cf.next[32] = 0;
#line 108
  cf.next[33] = 0;
#line 108
  cf.next[34] = 0;
#line 108
  cf.next[35] = 0;
#line 108
  cf.next[36] = 0;
#line 108
  cf.next[37] = 0;
#line 108
  cf.next[38] = 0;
#line 108
  cf.next[39] = 0;
#line 108
  cf.next[40] = 0;
#line 108
  cf.next[41] = 0;
#line 108
  cf.next[42] = 0;
#line 108
  cf.next[43] = 0;
#line 108
  cf.next[44] = 0;
#line 108
  cf.next[45] = 0;
#line 108
  cf.next[46] = 0;
#line 108
  cf.next[47] = 0;
#line 108
  cf.next[48] = 0;
#line 108
  cf.next[49] = 0;
#line 108
  cf.next[50] = 0;
#line 108
  cf.next[51] = 0;
#line 108
  cf.next[52] = 0;
#line 108
  cf.next[53] = 0;
#line 108
  cf.next[54] = 0;
#line 108
  cf.next[55] = 0;
#line 108
  cf.next[56] = 0;
#line 108
  cf.next[57] = 0;
#line 108
  cf.next[58] = 0;
#line 108
  cf.next[59] = 0;
#line 108
  cf.next[60] = 0;
#line 108
  cf.next[61] = 0;
#line 108
  cf.next[62] = 0;
#line 111
  ret = 0;
#line 113
  fd = open((char const   *)filename, 578, 420);
  }
#line 114
  if (-1 == fd) {
#line 115
    return (-1);
  }
#line 116
  cf.chain_magic = 13680336;
#line 117
  i = 0;
  {
#line 117
  while (1) {
    while_continue: /* CIL Label */ ;
#line 117
    if (! (i < 63)) {
#line 117
      goto while_break;
    }
#line 118
    cf.next[i] = (int volatile   )0;
#line 117
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 119
  tmp = write(fd, (void const   *)(& cf), sizeof(cf));
#line 119
  i = (int )tmp;
  }
#line 120
  if ((unsigned long )i == sizeof(cf)) {
#line 124
    pad = (int )(sizeof(cf) % 4UL);
#line 125
    if (pad > 0) {
#line 126
      i = 0;
      {
#line 126
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 126
        if (i < pad) {
#line 126
          if (! (0 == ret)) {
#line 126
            goto while_break___0;
          }
        } else {
#line 126
          goto while_break___0;
        }
        {
#line 127
        tmp___0 = write(fd, (void const   *)"", (size_t )1);
        }
#line 127
        if (1L != tmp___0) {
#line 128
          ret = -1;
        }
#line 126
        i ++;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
  } else {
#line 131
    ret = -1;
  }
  {
#line 132
  close(fd);
  }
#line 133
  return (ret);
}
}
#line 136 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/allocate.c"
static void unmapfile(void) 
{ 


  {
#line 138
  if (table___0.fd >= 0) {
    {
#line 140
    close(table___0.fd);
#line 141
    table___0.fd = -1;
    }
  }
#line 143
  if (table___0.map) {
    {
#line 145
    munmap((void *)table___0.map, (size_t )table___0.size);
#line 146
    table___0.map = (char *)((void *)0);
#line 147
    table___0.size = 0;
    }
  }
#line 149
  return;
}
}
#line 153
static size_t rounduptopagesize(size_t size___1 ) ;
#line 153 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/allocate.c"
static size_t pagesize___0  =    (size_t )0;
#line 151 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/allocate.c"
static size_t rounduptopagesize(size_t size___1 ) 
{ 
  int pages ;
  int tmp ;

  {
#line 156
  if (0UL == pagesize___0) {
    {
#line 157
    tmp = getpagesize();
#line 157
    pagesize___0 = (size_t )tmp;
    }
  }
#line 158
  pages = (int )(size___1 / pagesize___0 + 1UL);
#line 159
  return ((size_t )pages * pagesize___0);
}
}
#line 162 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/allocate.c"
static int mapfile(void) 
{ 
  struct stat st ;
  int tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;

  {
#line 166
  if (-1 == table___0.fd) {
    {
#line 167
    table___0.fd = open((char const   *)table___0.filename, table___0.oflag, 420);
    }
  }
#line 168
  if (-1 == table___0.fd) {
#line 169
    goto fail;
  }
  {
#line 171
  tmp = fstat(table___0.fd, & st);
  }
#line 171
  if (-1 == tmp) {
#line 172
    goto fail;
  }
  {
#line 173
  tmp___0 = rounduptopagesize((size_t )st.st_size);
#line 173
  table___0.size = (int )tmp___0;
#line 174
  tmp___1 = mmap((void *)0, (size_t )table___0.size, table___0.mprot, 1, table___0.fd,
                 (__off_t )0);
#line 174
  table___0.map = (char *)tmp___1;
  }
#line 175
  if (! table___0.map) {
#line 176
    goto fail;
  } else
#line 175
  if ((unsigned long )table___0.map == (unsigned long )((void *)-1)) {
#line 176
    goto fail;
  }
#line 178
  return (0);
  fail: 
  {
#line 181
  unmapfile();
  }
#line 182
  return (-1);
}
}
#line 189 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/allocate.c"
static int remapfile(void) 
{ 
  struct stat st ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 193
  tmp = fstat(table___0.fd, & st);
  }
#line 193
  if (-1 == tmp) {
#line 194
    return (-1);
  }
#line 196
  if (st.st_size <= (__off_t )table___0.size) {
#line 197
    return (0);
  }
  {
#line 199
  munmap((void *)table___0.map, (size_t )table___0.size);
#line 200
  tmp___0 = mapfile();
  }
#line 200
  return (tmp___0);
}
}
#line 209 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/allocate.c"
static int lock(void) 
{ 
  int *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 211
  tmp___2 = lockf(table___0.fd, 2, (__off_t )0);
  }
#line 211
  if (-1 == tmp___2) {
    {
#line 213
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 215
      tmp = __errno_location();
      }
#line 215
      if (11 != *tmp) {
#line 216
        return (-1);
      } else {
        {
#line 218
        nap(0, 200);
        }
      }
      {
#line 213
      tmp___0 = lockf(table___0.fd, 2, (__off_t )0);
      }
#line 213
      if (! (-1 == tmp___0)) {
#line 213
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 221
    tmp___1 = remapfile();
    }
#line 221
    if (-1 == tmp___1) {
#line 222
      return (-1);
    }
  }
#line 224
  return (0);
}
}
#line 227 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/allocate.c"
static void unlock(void) 
{ 


  {
  {
#line 229
  lseek(table___0.fd, (__off_t )0, 0);
#line 230
  lockf(table___0.fd, 0, (__off_t )0);
  }
#line 231
  return;
}
}
#line 233 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/allocate.c"
static int checkvalidfile(void) 
{ 


  {
#line 235
  if (table___0.size > 0) {
#line 237
    if ((unsigned long )table___0.size < sizeof(struct chainfile )) {
#line 238
      return (-1);
    }
#line 239
    if (((struct chainfile *)table___0.map)->chain_magic != 13680336) {
#line 240
      return (-1);
    }
  }
#line 242
  return (0);
}
}
#line 255 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/allocate.c"
int allo_init(char *path___1 , int flag ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 257
  if (2 == (flag & 2)) {
#line 258
    table___0.mprot = 3;
  } else {
#line 260
    table___0.mprot = 1;
  }
#line 261
  table___0.oflag = flag & 1052738;
#line 263
  if (64 == (flag & 64)) {
    {
#line 264
    tmp = initfile___0(path___1);
    }
#line 264
    if (-1 == tmp) {
#line 265
      return (-1);
    }
  }
  {
#line 267
  table___0.filename = path___1;
#line 268
  table___0.fd = -1;
#line 269
  tmp___0 = mapfile();
  }
#line 269
  if (-1 == tmp___0) {
    {
#line 271
    unmapfile();
#line 272
    table___0.filename = (char *)((void *)0);
    }
#line 273
    return (-1);
  } else {
    {
#line 269
    tmp___1 = checkvalidfile();
    }
#line 269
    if (-1 == tmp___1) {
      {
#line 271
      unmapfile();
#line 272
      table___0.filename = (char *)((void *)0);
      }
#line 273
      return (-1);
    }
  }
  {
#line 276
  table___0.filename = strdup((char const   *)path___1);
  }
#line 278
  return (0);
}
}
#line 281 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/allocate.c"
static int rounduptoalignment(int size___1 ) 
{ 


  {
#line 283
  if (size___1 <= 0) {
#line 284
    return (4);
  }
#line 285
  return (((size___1 - 1) / 4 + 1) * 4);
}
}
#line 296 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/allocate.c"
static char tmpchunk[272]  = {      (char )'\000'};
#line 294 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/allocate.c"
int allo_make(int size___1 ) 
{ 
  int chain ;
  int block ;
  int failures ;
  int tmp ;
  int tmp___0 ;
  __off_t tmp___1 ;

  {
  {
#line 301
  size___1 = rounduptoalignment(size___1);
  }
#line 302
  if (size___1 > 252) {
#line 303
    return (-1);
  }
#line 305
  chain = size___1 / 4 - 1;
#line 307
  failures = 0;
  {
#line 307
  while (1) {
    while_continue: /* CIL Label */ ;
#line 307
    if (! (failures < 10)) {
#line 307
      goto while_break;
    }
#line 309
    if (((struct chainfile *)table___0.map)->next[chain]) {
      {
#line 312
      tmp = lock();
      }
#line 312
      if (-1 == tmp) {
#line 313
        return (-1);
      }
#line 314
      block = (int )((struct chainfile *)table___0.map)->next[chain];
#line 314
      if (! block) {
        {
#line 316
        unlock();
        }
#line 317
        goto __Cont;
      }
      {
#line 319
      ((struct chainfile *)table___0.map)->next[chain] = (int volatile   )*((int *)(table___0.map + block));
#line 320
      memset((void *)(table___0.map + block), 0, (size_t )size___1);
      }
    } else {
      {
#line 325
      tmp___0 = lock();
      }
#line 325
      if (-1 == tmp___0) {
#line 326
        return (-1);
      }
      {
#line 327
      tmp___1 = lseek(table___0.fd, (__off_t )0, 2);
#line 327
      block = (int )tmp___1;
#line 328
      write(table___0.fd, (void const   *)(tmpchunk), (size_t )((1 + chain) * 4));
#line 329
      remapfile();
      }
    }
    {
#line 331
    unlock();
    }
#line 332
    return (block);
    __Cont: /* CIL Label */ 
#line 307
    failures ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 334
  return (-1);
}
}
#line 342 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/allocate.c"
int allo_free(int chunk , int size___1 ) 
{ 
  int chain ;
  int tmp ;

  {
  {
#line 346
  size___1 = rounduptoalignment(size___1);
  }
#line 347
  if (size___1 > 252) {
#line 348
    return (-1);
  }
  {
#line 350
  chain = size___1 / 4 - 1;
#line 352
  tmp = lock();
  }
#line 352
  if (-1 == tmp) {
#line 353
    return (-1);
  }
  {
#line 354
  *((int *)(table___0.map + chunk)) = (int )((struct chainfile *)table___0.map)->next[chain];
#line 355
  ((struct chainfile *)table___0.map)->next[chain] = (int volatile   )chunk;
#line 356
  unlock();
  }
#line 357
  return (0);
}
}
#line 360 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/allocate.c"
int allo_destroy(void) 
{ 


  {
  {
#line 362
  unmapfile();
#line 363
  free((void *)table___0.filename);
#line 364
  table___0.filename = (char *)((void *)0);
  }
#line 365
  return (0);
}
}
#line 47 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/dhash.h"
int dh_insert(struct data *dp ) ;
#line 49
int dh_delete(struct data *dp ) ;
#line 28 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/newsgroup.h"
int ng_ident(char *group ) ;
#line 32
int ng_addgroup(char *group ) ;
#line 56 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/dhash.c"
static unsigned char buf[2]  ;
#line 54 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/dhash.c"
static char *inttochar2(int integer ) 
{ 


  {
#line 58
  buf[0] = (unsigned char )((integer & 65535) >> 8);
#line 59
  buf[1] = (unsigned char )(integer & 255);
#line 60
  return ((char *)(buf));
}
}
#line 65 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/dhash.c"
static unsigned char buf___0[3]  ;
#line 63 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/dhash.c"
static char *inttochar3(unsigned int integer ) 
{ 


  {
#line 67
  integer >>= 2;
#line 68
  buf___0[0] = (unsigned char )((integer & 16777215U) >> 16);
#line 69
  buf___0[1] = (unsigned char )((integer & 65535U) >> 8);
#line 70
  buf___0[2] = (unsigned char )(integer & 255U);
#line 71
  return ((char *)(buf___0));
}
}
#line 74 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/dhash.c"
int dh_insert(struct data *dp ) 
{ 
  struct chain *chp ;
  unsigned int h ;
  int off ;
  int len ;
  int *tmp ;
  int tmp___0 ;
  unsigned int index___0 ;
  int *tmp___1 ;
  int tmp___2 ;
  void *tmp___3 ;
  size_t tmp___4 ;
  void *tmp___5 ;
  int ident ;
  char *tmp___6 ;
  unsigned char *x ;
  char *tmp___7 ;

  {
#line 81
  if (dh_isreadonly) {
    {
#line 83
    tmp = __errno_location();
#line 83
    *tmp = 1;
    }
#line 84
    return (-1);
  }
  {
#line 87
  tmp___0 = dhlock();
  }
#line 87
  if (tmp___0 == -1) {
#line 88
    return (-1);
  }
  {
#line 89
  chp = dhlocatechain(dp->messageid);
  }
  {
#line 90
  while (1) {
    while_continue: /* CIL Label */ ;
#line 90
    if (! ((unsigned long )chp != (unsigned long )((void *)0))) {
#line 90
      goto while_break;
    }
    {
#line 94
    tmp___2 = strcmp((char const   *)dp->messageid, (char const   *)(chp->messageid));
    }
#line 94
    if (tmp___2 == 0) {
      {
#line 96
      dhunlock();
#line 97
      tmp___1 = __errno_location();
#line 97
      *tmp___1 = 17;
      }
#line 98
      return (-1);
    }
#line 100
    index___0 = (unsigned int )chp->next;
#line 101
    if (index___0 == 0U) {
#line 102
      goto while_break;
    }
    {
#line 103
    tmp___3 = allo_deref(index___0);
#line 103
    chp = (struct chain *)tmp___3;
    }
#line 104
    if ((unsigned long )chp == (unsigned long )((void *)0)) {
      {
#line 106
      log_((char *)"dh_insert:bad deref in chain for \"<%s>\" during search", dp->messageid);
      }
#line 107
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 111
  tmp___4 = strlen((char const   *)dp->messageid);
#line 111
  len = (int )(((sizeof(struct chain ) + tmp___4) + 1UL) - sizeof(chp->messageid));
#line 112
  off = allo_make(len);
#line 113
  tmp___5 = allo_deref((unsigned int )off);
#line 113
  chp = (struct chain *)tmp___5;
  }
#line 114
  if ((unsigned long )chp == (unsigned long )((void *)0)) {
    {
#line 116
    log_((char *)"dh_insert:allo_make gave bad allo_deref");
#line 117
    dhunlock();
    }
#line 118
    return (-1);
  }
  {
#line 120
  chp->serial = dp->serial;
#line 121
  strcpy((char */* __restrict  */)(chp->messageid), (char const   */* __restrict  */)dp->messageid);
#line 125
  ident = ng_ident(dp->newsgroup);
  }
#line 126
  if (-1 == ident) {
    {
#line 127
    ident = ng_addgroup(dp->newsgroup);
    }
#line 127
    if (-1 == ident) {
#line 128
      return (-1);
    }
  }
  {
#line 129
  tmp___6 = inttochar2(ident);
#line 129
  memcpy((void */* __restrict  */)(chp->newsgroup), (void const   */* __restrict  */)tmp___6,
         (size_t )2);
#line 140
  h = dhhash(dp->messageid);
#line 143
  x = dh_table->next + h * 3U;
#line 145
  chp->next = (((int )*(x + 0) << 18) | ((int )*(x + 1) << 10)) | ((int )*(x + 2) << 2);
#line 146
  tmp___7 = inttochar3((unsigned int )off);
#line 146
  memcpy((void */* __restrict  */)x, (void const   */* __restrict  */)tmp___7, (size_t )3);
#line 148
  dhunlock();
  }
#line 149
  return (0);
}
}
#line 152 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/dhash.c"
int dh_delete(struct data *dp ) 
{ 
  struct chain *oldchp ;
  struct chain *chp ;
  int *tmp ;
  int tmp___0 ;
  unsigned int index___0 ;
  void *tmp___1 ;
  int tmp___2 ;
  unsigned int i ;
  unsigned int h ;
  unsigned int tmp___3 ;
  char *tmp___4 ;
  size_t tmp___5 ;
  int tmp___6 ;

  {
#line 154
  oldchp = (struct chain *)((void *)0);
#line 157
  if (dh_isreadonly) {
    {
#line 159
    tmp = __errno_location();
#line 159
    *tmp = 1;
    }
#line 160
    return (-1);
  }
  {
#line 163
  tmp___0 = dhlock();
  }
#line 163
  if (tmp___0 == -1) {
#line 164
    return (-1);
  }
  {
#line 165
  chp = dhlocatechain(dp->messageid);
  }
#line 166
  if ((unsigned long )chp == (unsigned long )((void *)0)) {
#line 167
    goto fail;
  }
  {
#line 169
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 169
    tmp___2 = strcmp((char const   *)(chp->messageid), (char const   *)dp->messageid);
    }
#line 169
    if (! (tmp___2 != 0)) {
#line 169
      goto while_break;
    }
#line 171
    index___0 = (unsigned int )chp->next;
#line 173
    if (index___0 == 0U) {
#line 174
      goto fail;
    }
    {
#line 175
    oldchp = chp;
#line 176
    tmp___1 = allo_deref(index___0);
#line 176
    chp = (struct chain *)tmp___1;
    }
#line 177
    if ((unsigned long )chp == (unsigned long )((void *)0)) {
#line 179
      if (debug >= 2) {
        {
#line 179
        log_((char *)"dh_delete:dereferencing bad offset");
        }
      }
#line 180
      goto fail;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 184
  chp->messageid[0] = (char )'\000';
#line 185
  if ((unsigned long )oldchp != (unsigned long )((void *)0)) {
#line 186
    oldchp->next = chp->next;
  } else {
    {
#line 189
    i = (unsigned int )chp->next;
#line 190
    tmp___3 = dhhash(dp->messageid);
#line 190
    h = tmp___3;
#line 192
    tmp___4 = inttochar3(i);
#line 192
    memcpy((void */* __restrict  */)(dh_table->next + h * 3U), (void const   */* __restrict  */)tmp___4,
           (size_t )3);
    }
  }
  {
#line 194
  tmp___5 = strlen((char const   *)dp->messageid);
#line 194
  tmp___6 = allo_ref((void *)chp);
#line 194
  allo_free(tmp___6, (int )(((sizeof(struct chain ) + tmp___5) + 1UL) - sizeof(chp->messageid)));
#line 196
  dhunlock();
  }
#line 197
  return (0);
  fail: 
  {
#line 200
  dhunlock();
  }
#line 201
  return (-1);
}
}
#line 497 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) chdir)(char const   *__path ) ;
#line 534
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) dup2)(int __fd ,
                                                                           int __fd2 ) ;
#line 603
extern  __attribute__((__noreturn__)) void _exit(int __status ) ;
#line 628
extern  __attribute__((__nothrow__)) __pid_t ( __attribute__((__leaf__)) getpid)(void) ;
#line 263 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strrchr)(char const   *__s ,
                                                                                                int __c )  __attribute__((__pure__)) ;
#line 342
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strstr)(char const   *__haystack ,
                                                                                                 char const   *__needle )  __attribute__((__pure__)) ;
#line 183 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) long ( __attribute__((__nonnull__(1), __leaf__)) strtol)(char const   * __restrict  __nptr ,
                                                                                              char ** __restrict  __endptr ,
                                                                                              int __base ) ;
#line 199 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) time_t ( __attribute__((__leaf__)) mktime)(struct tm *__tp ) ;
#line 11 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/parameters.h"
char *snroot ;
#line 15
void parameters(bool wantwriteperms ) ;
#line 18 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/times.h"
extern int times_init(void) ;
#line 19
extern void times_fin(void) ;
#line 23
extern int times_since(char *group , time_t earliest ) ;
#line 22 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/body.h"
int body(char **artbod , int *len ) ;
#line 23 "./lib/out.h"
char *progname ;
#line 27
void fail(int ex , char *fmt  , ...) ;
#line 29
int writef(int fd , char *fmt  , ...) ;
#line 23 "./lib/opt.h"
int opt_ind ;
#line 24
char *opt_arg ;
#line 26
int opt_get(int c , char **v , char *opts ) ;
#line 43 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/snscan.c"
int debug  =    0;
#line 47 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/snscan.c"
char *host  ;
#line 48 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/snscan.c"
int errors  =    0;
#line 50 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/snscan.c"
int (*print)(struct article * , char * , char * , int  )  ;
#line 51 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/snscan.c"
int (*gimme)(char * , int  , struct article * )  ;
#line 53 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/snscan.c"
void usage(void) 
{ 


  {
  {
#line 55
  fail(1, (char *)"Usage:\n%s [-n] [-s since] [-o file] newsgroup[:lo[-[hi][,...]]]\n%s [-n] [-s since] [-o file] -i id ...",
       progname, progname);
  }
#line 58
  return;
}
}
#line 60 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/snscan.c"
int snscan(char *newsgroup , int serial ) 
{ 
  struct article a ;
  char *id ;
  char *e ;
  int tmp ;
  char const   *tmp___0 ;
  int tmp___1 ;

  {
  {
#line 64
  e = (char *)((void *)0);
#line 66
  tmp = (*gimme)(newsgroup, serial, & a);
  }
#line 66
  if (tmp) {
#line 67
    return (1);
  }
#line 68
  if (*(a.head)) {
#line 68
    if (*(a.body + -1)) {
#line 77
      e = (char *)"Corrupt article %s:%d";
    } else
#line 68
    if (*(a.body + a.blen)) {
#line 77
      e = (char *)"Corrupt article %s:%d";
    } else {
      {
#line 69
      id = art_findfield(a.head, (char *)"Message-ID");
      }
#line 69
      if (id) {
#line 70
        if (*id) {
#line 70
          tmp___0 = (char const   *)id;
        } else {
#line 70
          tmp___0 = "<0>";
        }
        {
#line 70
        tmp___1 = writef(1, (char *)"%s %d %s\n", newsgroup, serial, tmp___0);
        }
#line 70
        if (tmp___1 > 0) {
#line 71
          return (0);
        } else {
          {
#line 73
          fail(2, (char *)"write error:%m");
          }
        }
      } else {
#line 75
        e = (char *)"Can\'t find %s:%d:%m?";
      }
    }
  } else {
#line 77
    e = (char *)"Corrupt article %s:%d";
  }
  {
#line 78
  log_(e, newsgroup, serial);
#line 79
  errors ++;
  }
#line 80
  return (-1);
}
}
#line 83 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/snscan.c"
static int print_native(struct article *ap , char *host___0 , char *newsgroup , int serial ) 
{ 
  struct iovec v[10] ;
  unsigned int tmp ;
  int i ;
  char buf___28[256] ;
  ssize_t tmp___0 ;

  {
#line 85
  v[0].iov_base = (void *)0;
#line 85
  v[0].iov_len = 0UL;
#line 85
  tmp = 1U;
  {
#line 85
  while (1) {
    while_continue: /* CIL Label */ ;
#line 85
    if (tmp >= 10U) {
#line 85
      goto while_break;
    }
#line 85
    v[tmp].iov_base = (void *)0;
#line 85
    v[tmp].iov_len = 0UL;
#line 85
    tmp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 86
  i = 0;
#line 89
  v[i].iov_base = (void *)ap->head;
#line 90
  v[i].iov_len = (size_t )ap->hlen;
#line 91
  i ++;
#line 93
  if (host___0) {
#line 93
    if (newsgroup) {
#line 93
      if (serial) {
        {
#line 95
        formats(buf___28, (int )(sizeof(buf___28) - 1UL), (char *)"Xref: %s %s:%d\r\n",
                host___0, newsgroup, serial);
#line 96
        v[i].iov_base = (void *)(buf___28);
#line 97
        v[i].iov_len = strlen((char const   *)(buf___28));
#line 98
        i ++;
        }
      }
    }
  }
  {
#line 101
  v[i].iov_base = (void *)"\r\n";
#line 102
  v[i].iov_len = (size_t )2;
#line 103
  i ++;
#line 105
  v[i].iov_base = (void *)ap->body;
#line 106
  v[i].iov_len = (size_t )ap->blen;
#line 107
  i ++;
#line 108
  v[i].iov_base = (void *)".\r\n";
#line 109
  v[i].iov_len = (size_t )3;
#line 110
  i ++;
#line 112
  tmp___0 = writev(1, (struct iovec  const  *)(v), i);
  }
#line 112
  return ((int )tmp___0);
}
}
#line 115 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/snscan.c"
static int print_batch(struct article *ap , char *host___0 , char *newsgroup , int serial ) 
{ 
  struct b b___13 ;
  struct iovec v[2] ;
  char *cp ;
  char *p ;
  char buf___28[256] ;
  int e ;
  int tmp ;
  size_t tmp___0 ;
  int tmp___1 ;
  ssize_t tmp___2 ;

  {
#line 117
  b___13.buf = (char *)0;
#line 117
  b___13.size = 0;
#line 117
  b___13.used = 0;
#line 124
  cp = ap->head;
  {
#line 124
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 124
    p = strchr((char const   *)cp, '\r');
    }
#line 124
    if (! p) {
#line 124
      goto while_break;
    }
    {
#line 126
    b_appendl(& b___13, cp, (int )(p - cp));
#line 127
    tmp = b_appendl(& b___13, (char *)"\n", 1);
    }
#line 127
    if (-1 == tmp) {
#line 128
      goto fail;
    }
#line 124
    cp = p + 2;
  }
  while_break: /* CIL Label */ ;
  }
#line 131
  if (host___0) {
#line 131
    if (newsgroup) {
#line 131
      if (serial) {
        {
#line 133
        formats(buf___28, (int )(sizeof(buf___28) - 1UL), (char *)"Xref: %s %s:%d\n\n",
                host___0, newsgroup, serial);
#line 134
        tmp___0 = strlen((char const   *)(buf___28));
#line 134
        b_appendl(& b___13, buf___28, (int )tmp___0);
        }
      } else {
        {
#line 137
        b_appendl(& b___13, (char *)"\n", 1);
        }
      }
    } else {
      {
#line 137
      b_appendl(& b___13, (char *)"\n", 1);
      }
    }
  } else {
    {
#line 137
    b_appendl(& b___13, (char *)"\n", 1);
    }
  }
#line 139
  cp = ap->body;
  {
#line 139
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 139
    p = strchr((char const   *)cp, '\r');
    }
#line 139
    if (! p) {
#line 139
      goto while_break___0;
    }
#line 141
    if (46 == (int )*cp) {
      {
#line 142
      b_appendl(& b___13, (char *)".", 1);
      }
    }
    {
#line 143
    b_appendl(& b___13, cp, (int )(p - cp));
#line 144
    tmp___1 = b_appendl(& b___13, (char *)"\n", 1);
    }
#line 144
    if (-1 == tmp___1) {
#line 145
      goto fail;
    }
#line 139
    cp = p + 2;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 148
  formats(buf___28, (int )(sizeof(buf___28) - 1UL), (char *)"#! rnews %d\n", b___13.used);
#line 150
  v[0].iov_base = (void *)(buf___28);
#line 151
  v[0].iov_len = strlen((char const   *)(buf___28));
#line 152
  v[1].iov_base = (void *)b___13.buf;
#line 153
  v[1].iov_len = (size_t )b___13.used;
#line 154
  tmp___2 = writev(1, (struct iovec  const  *)(v), 2);
#line 154
  e = (int )tmp___2;
#line 155
  free((void *)b___13.buf);
  }
#line 156
  return (e);
  fail: 
#line 159
  if (b___13.buf) {
    {
#line 160
    free((void *)b___13.buf);
    }
  }
#line 161
  return (-1);
}
}
#line 164 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/snscan.c"
int sncat(char *newsgroup , int serial ) 
{ 
  struct article a ;
  char *e ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 167
  e = (char *)((void *)0);
#line 169
  tmp = (*gimme)(newsgroup, serial, & a);
  }
#line 169
  if (tmp) {
#line 170
    return (1);
  }
#line 171
  if (*(a.body + -1)) {
#line 180
    e = (char *)"Corrupt body in %s:%d";
  } else
#line 171
  if (*(a.body + a.blen)) {
#line 180
    e = (char *)"Corrupt body in %s:%d";
  } else {
    {
#line 172
    tmp___1 = body(& a.body, & a.blen);
    }
#line 172
    if (0 == tmp___1) {
      {
#line 173
      tmp___0 = (*print)(& a, host, newsgroup, serial);
      }
#line 173
      if (tmp___0) {
#line 174
        return (0);
      } else {
        {
#line 176
        fail(2, (char *)"write error:%m");
        }
      }
    } else {
#line 178
      e = (char *)"Can\'t decompress? %s:%d:%m?";
    }
  }
  {
#line 181
  log_(e, newsgroup, serial);
#line 182
  errors ++;
  }
#line 183
  return (-1);
}
}
#line 186 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/snscan.c"
int sncancel(char *newsgroup , int serial ) 
{ 
  struct file *fp ;
  struct article a ;
  struct data d ;
  int slot ;
  int fd ;
  int er ;
  char path___1[287] ;
  char *id ;
  char *p ;
  int tmp ;
  void *tmp___0 ;
  int volatile   tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int *tmp___4 ;

  {
  {
#line 196
  tmp = art_gimmenoderef(newsgroup, serial, & a);
  }
#line 196
  if (-1 == tmp) {
#line 197
    return (1);
  }
  {
#line 198
  id = art_findfield(a.head, (char *)"Message-ID");
  }
#line 199
  if (! id) {
#line 199
    goto _L;
  } else
#line 199
  if (! *id) {
    _L: /* CIL Label */ 
#line 201
    if (debug >= 1) {
      {
#line 201
      log_((char *)"sncancel:Can\'t find ID in %s:%d", newsgroup, serial);
      }
    }
#line 202
    errors ++;
#line 203
    return (-1);
  }
#line 205
  if (60 == (int )*id) {
#line 206
    id ++;
  }
  {
#line 207
  p = strrchr((char const   *)id, '>');
  }
#line 207
  if (p) {
#line 208
    *p = (char )'\000';
  }
  {
#line 210
  formats(path___1, (int )(sizeof(path___1) - 1UL), (char *)"%s/%d", newsgroup, serial / 10);
#line 211
  er = 1;
#line 212
  fd = open((char const   *)(path___1), 2);
  }
#line 212
  if (fd > -1) {
    {
#line 214
    tmp___0 = mmap((void *)0, sizeof(*fp), 3, 1, fd, (__off_t )0);
#line 214
    fp = (struct file *)tmp___0;
    }
#line 215
    if (fp) {
#line 215
      if ((unsigned long )fp != (unsigned long )((void *)-1)) {
        {
#line 217
        tmp___3 = lockf(fd, 1, (__off_t )0);
        }
#line 217
        if (0 == tmp___3) {
          {
#line 219
          slot = serial % 10;
#line 220
          tmp___1 = (int volatile   )-1;
#line 220
          fp->info[slot].boffset = tmp___1;
#line 220
          fp->info[slot].hoffset = tmp___1;
#line 221
          d.messageid = id;
#line 222
          tmp___2 = dh_delete(& d);
          }
#line 222
          if (tmp___2) {
#line 223
            if (debug >= 1) {
              {
#line 223
              log_((char *)"dh_delete(<%s>):%m", id);
              }
            }
          }
#line 224
          return (0);
        } else
#line 228
        if (debug >= 1) {
          {
#line 228
          log_((char *)"lockf(%s):%m", path___1);
          }
        }
        {
#line 230
        munmap((void *)fp, sizeof(*fp));
        }
      } else {
#line 215
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 234
    if (debug >= 1) {
      {
#line 234
      log_((char *)"mmap(%s):%m", path___1);
      }
    }
    {
#line 236
    close(fd);
    }
  } else {
    {
#line 238
    tmp___4 = __errno_location();
    }
#line 238
    if (2 != *tmp___4) {
      {
#line 239
      log_((char *)"sncancel:open(%s):%m", path___1);
      }
    }
  }
#line 240
  errors += er;
#line 241
  return (-1);
}
}
#line 244 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/snscan.c"
static int range(char *spec , int *hi , int *lo ) 
{ 
  char *cp ;
  int tmp ;
  long tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  long tmp___3 ;
  int tmp___4 ;

  {
#line 248
  if ((int )*spec < 48) {
#line 249
    return (-1);
  } else
#line 248
  if ((int )*spec > 57) {
#line 249
    return (-1);
  }
  {
#line 250
  tmp___0 = strtol((char const   */* __restrict  */)spec, (char **/* __restrict  */)(& cp),
                   10);
#line 250
  tmp = (int )tmp___0;
#line 250
  *lo = tmp;
  }
#line 250
  if (tmp < 0) {
#line 251
    return (-1);
  }
#line 252
  if (! *cp) {
#line 253
    tmp___1 = 0;
#line 253
    *hi = tmp___1;
#line 253
    return (tmp___1);
  }
#line 254
  if (45 != (int )*cp) {
#line 255
    return (-1);
  }
#line 256
  spec = cp + 1;
#line 257
  if (! *spec) {
#line 259
    *hi = -1;
#line 260
    return (0);
  }
  {
#line 262
  tmp___3 = strtol((char const   */* __restrict  */)spec, (char **/* __restrict  */)(& cp),
                   10);
#line 262
  tmp___2 = (int )tmp___3;
#line 262
  *hi = tmp___2;
  }
#line 262
  if (tmp___2 < 0) {
#line 263
    return (-1);
  }
#line 264
  if (*cp) {
#line 264
    tmp___4 = -1;
  } else {
#line 264
    tmp___4 = 0;
  }
#line 264
  return (tmp___4);
}
}
#line 267 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/snscan.c"
static time_t timefmt(char *str ) 
{ 
  struct tm tm ;
  char *p ;
  unsigned long tmp ;
  unsigned long tmp___0 ;
  unsigned long tmp___1 ;
  unsigned long tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  time_t tmp___5 ;

  {
#line 269
  tm.tm_sec = 0;
#line 269
  tm.tm_min = 0;
#line 269
  tm.tm_hour = 0;
#line 269
  tm.tm_mday = 0;
#line 269
  tm.tm_mon = 0;
#line 269
  tm.tm_year = 0;
#line 269
  tm.tm_wday = 0;
#line 269
  tm.tm_yday = 0;
#line 269
  tm.tm_isdst = 0;
#line 269
  tm.tm_gmtoff = 0L;
#line 269
  tm.tm_zone = (char const   *)0;
#line 270
  p = str;
#line 272
  if ((int )*p < 48) {
#line 273
    return ((time_t )-1);
  } else
#line 272
  if ((int )*p > 57) {
#line 273
    return ((time_t )-1);
  }
  {
#line 274
  tmp = strtoul((char const   */* __restrict  */)p, (char **/* __restrict  */)(& str),
                10);
#line 274
  tm.tm_year = (int )tmp;
  }
#line 275
  if (! str) {
#line 276
    return ((time_t )-1);
  } else
#line 275
  if (! *str) {
#line 276
    return ((time_t )-1);
  }
#line 277
  if (tm.tm_year > 1900) {
#line 278
    tm.tm_year -= 1900;
  }
  {
#line 279
  str ++;
#line 279
  p = str;
#line 280
  tmp___0 = strtoul((char const   */* __restrict  */)p, (char **/* __restrict  */)(& str),
                    10);
#line 280
  tm.tm_mon = (int )tmp___0;
  }
#line 281
  if (! str) {
#line 282
    return ((time_t )-1);
  } else
#line 281
  if (! *str) {
#line 282
    return ((time_t )-1);
  }
  {
#line 283
  (tm.tm_mon) --;
#line 284
  str ++;
#line 284
  p = str;
#line 285
  tmp___1 = strtoul((char const   */* __restrict  */)p, (char **/* __restrict  */)(& str),
                    10);
#line 285
  tm.tm_mday = (int )tmp___1;
  }
#line 286
  if (str) {
#line 286
    if (*str) {
      {
#line 288
      str ++;
#line 288
      p = str;
#line 289
      tmp___2 = strtoul((char const   */* __restrict  */)p, (char **/* __restrict  */)(& str),
                        10);
#line 289
      tm.tm_hour = (int )tmp___2;
      }
#line 290
      if (str) {
#line 290
        if (*str) {
          {
#line 292
          str ++;
#line 292
          p = str;
#line 293
          tmp___3 = strtoul((char const   */* __restrict  */)p, (char **/* __restrict  */)(& str),
                            10);
#line 293
          tm.tm_min = (int )tmp___3;
          }
#line 294
          if (str) {
#line 294
            if (*str) {
              {
#line 296
              str ++;
#line 296
              p = str;
#line 297
              tmp___4 = strtoul((char const   */* __restrict  */)p, (char **/* __restrict  */)(& str),
                                10);
#line 297
              tm.tm_sec = (int )tmp___4;
              }
            }
          }
        }
      }
    }
  }
  {
#line 301
  tmp___5 = mktime(& tm);
  }
#line 301
  return (tmp___5);
}
}
#line 304 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/snscan.c"
int getnoaliases(char *group , int serial , struct article *ap ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  {
#line 306
  tmp = art_gimmenoderef(group, serial, ap);
  }
#line 306
  if (-1 == tmp) {
#line 307
    return (1);
  }
#line 308
  if (ap->blen > 0) {
#line 309
    return (0);
  }
  {
#line 310
  tmp___0 = strncasecmp((char const   *)ap->head, "Message-ID:", (size_t )11);
  }
#line 310
  if (0 == tmp___0) {
#line 311
    return (1);
  }
#line 312
  return (0);
}
}
#line 315 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/snscan.c"
int earliest(char *ng , time_t since ) 
{ 
  int start___0 ;

  {
  {
#line 319
  start___0 = times_since(ng, since);
  }
#line 319
  if (start___0 <= 0) {
#line 321
    if (-1 == start___0) {
      {
#line 323
      log_((char *)"times_since(%s):%m?", ng);
#line 324
      errors ++;
      }
    }
#line 326
    return (0);
  }
#line 328
  return (start___0);
}
}
#line 331 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/snscan.c"
int main(int argc , char **argv ) 
{ 
  time_t since ;
  int (*doit)(char * , int  ) ;
  int i ;
  int outfd___0 ;
  char *cp ;
  bool useid ;
  struct group g ;
  bool dhro ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char *p ;
  int i___0 ;
  __pid_t tmp___3 ;
  size_t tmp___4 ;
  void *tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  struct data d ;
  int tmp___10 ;
  int tmp___11 ;
  int start___0 ;
  int hi ;
  int lo ;
  int start___1 ;
  char *colon ;
  char *newsgroup ;
  char *tmp___12 ;
  char *tmp___13 ;
  char *tmp___14 ;
  int tmp___15 ;
  char *comma ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;

  {
  {
#line 337
  useid = (bool )0;
#line 341
  cp = strrchr((char const   *)*(argv + 0), '/');
  }
#line 341
  if (cp) {
#line 341
    progname = cp + 1;
  } else {
#line 341
    progname = *(argv + 0);
  }
  {
#line 343
  dhro = (bool )1;
#line 344
  tmp___1 = strcmp((char const   *)progname, "sncancel");
  }
#line 344
  if (0 == tmp___1) {
#line 346
    dhro = (bool )0;
#line 347
    doit = & sncancel;
  } else {
    {
#line 349
    tmp___0 = strcmp((char const   *)progname, "snscan");
    }
#line 349
    if (0 == tmp___0) {
#line 350
      doit = & snscan;
    } else {
      {
#line 351
      tmp = strcmp((char const   *)progname, "sncat");
      }
#line 351
      if (0 == tmp) {
#line 352
        doit = & sncat;
      } else {
        {
#line 355
        fail(1, (char *)"Eh?");
#line 356
        _exit(29);
        }
      }
    }
  }
  {
#line 359
  parameters((bool )(! dhro));
#line 361
  tmp___2 = chdir((char const   *)snroot);
  }
#line 361
  if (-1 == tmp___2) {
    {
#line 362
    fail(2, (char *)"chdir(%s):%m", snroot);
    }
  }
  {
#line 363
  host = myname();
#line 365
  gimme = & art_gimme;
#line 366
  print = & print_native;
#line 367
  since = (time_t )0;
  }
  {
#line 368
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 368
    i = opt_get(argc, argv, (char *)"so");
    }
#line 368
    if (! (i > -1)) {
#line 368
      goto while_break;
    }
    {
#line 371
    if (i == 80) {
#line 371
      goto case_80;
    }
#line 372
    if (i == 100) {
#line 372
      goto case_100;
    }
#line 373
    if (i == 110) {
#line 373
      goto case_110;
    }
#line 374
    if (i == 86) {
#line 374
      goto case_86;
    }
#line 375
    if (i == 105) {
#line 375
      goto case_105;
    }
#line 376
    if (i == 114) {
#line 376
      goto case_114;
    }
#line 377
    if (i == 111) {
#line 377
      goto case_111;
    }
#line 386
    if (i == 115) {
#line 386
      goto case_115;
    }
#line 394
    goto switch_default;
    case_80: /* CIL Label */ 
    {
#line 371
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 371
      tmp___4 = strlen((char const   *)progname);
#line 371
      i___0 = (int )(tmp___4 + 32UL);
#line 371
      tmp___5 = malloc((size_t )i___0);
#line 371
      p = (char *)tmp___5;
      }
#line 371
      if (p) {
        {
#line 371
        tmp___3 = getpid();
#line 371
        formats(p, i___0 - 1, (char *)"%s[%u]", progname, tmp___3);
        }
      }
#line 371
      progname = p;
#line 371
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 371
    goto switch_break;
    case_100: /* CIL Label */ 
#line 372
    debug ++;
#line 372
    goto switch_break;
    case_110: /* CIL Label */ 
#line 373
    gimme = & getnoaliases;
#line 373
    goto switch_break;
    case_86: /* CIL Label */ 
    {
#line 374
    writef(2, (char *)"%s version 0.3.8\n", progname);
#line 374
    _exit(0);
    }
    case_105: /* CIL Label */ 
#line 375
    useid = (bool )1;
#line 375
    goto switch_break;
    case_114: /* CIL Label */ 
#line 376
    print = & print_batch;
#line 376
    goto switch_break;
    case_111: /* CIL Label */ 
#line 378
    if (! opt_arg) {
      {
#line 379
      usage();
      }
    }
    {
#line 380
    outfd___0 = open((char const   *)opt_arg, 65, 420);
    }
#line 381
    if (-1 == outfd___0) {
      {
#line 382
      fail(2, (char *)"open(%s):%m", opt_arg);
      }
    }
    {
#line 383
    tmp___6 = dup2(outfd___0, 1);
    }
#line 383
    if (-1 == tmp___6) {
      {
#line 384
      fail(2, (char *)"dup:%m");
      }
    }
#line 385
    goto switch_break;
    case_115: /* CIL Label */ 
#line 387
    if (! opt_arg) {
      {
#line 388
      usage();
      }
    }
    {
#line 389
    since = timefmt(opt_arg);
    }
#line 389
    if (-1L == since) {
      {
#line 390
      fail(1, (char *)"Bad time format");
      }
    }
    {
#line 391
    tmp___7 = times_init();
    }
#line 391
    if (tmp___7) {
      {
#line 392
      fail(2, (char *)"times_init:%m");
      }
    }
#line 393
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 394
    usage();
    }
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 396
  if (opt_ind >= argc) {
    {
#line 397
    usage();
    }
  }
  {
#line 399
  tmp___8 = group_init();
  }
#line 399
  if (-1 == tmp___8) {
    {
#line 400
    fail(2, (char *)"group_init:%m");
    }
  }
#line 402
  if (! dhro) {
#line 402
    goto _L;
  } else
#line 402
  if (useid) {
    _L: /* CIL Label */ 
    {
#line 403
    tmp___9 = dh_open((char *)((void *)0), dhro);
    }
#line 403
    if (-1 == tmp___9) {
      {
#line 404
      fail(2, (char *)"Can\'t open database");
      }
    }
  }
#line 406
  if (useid) {
    {
#line 408
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 408
      if (opt_ind < argc) {
#line 408
        if (! *(argv + opt_ind)) {
#line 408
          goto while_break___1;
        }
      } else {
#line 408
        goto while_break___1;
      }
#line 410
      d.messageid = (char *)0;
#line 410
      d.newsgroup = (char *)0;
#line 410
      d.serial = 0;
#line 412
      if (60 == (int )*(*(argv + opt_ind))) {
        {
#line 414
        d.messageid = *(argv + opt_ind) + 1;
#line 415
        cp = strchr((char const   *)d.messageid, '>');
        }
#line 415
        if (cp) {
#line 416
          *cp = (char )'\000';
        }
      } else {
#line 419
        d.messageid = *(argv + opt_ind);
      }
      {
#line 420
      tmp___10 = dh_find(& d, dhro);
      }
#line 420
      if (-1 == tmp___10) {
#line 421
        goto __Cont;
      }
      {
#line 422
      tmp___11 = group_info(d.newsgroup, & g);
      }
#line 422
      if (-1 == tmp___11) {
        {
#line 423
        fail(2, (char *)"group_info(%s):%m", d.newsgroup);
        }
      }
#line 424
      if (since) {
        {
#line 428
        start___0 = earliest(d.newsgroup, since);
        }
#line 428
        if (0 == start___0) {
#line 429
          goto __Cont;
        }
#line 430
        if (d.serial < start___0) {
#line 431
          goto __Cont;
        }
      }
      {
#line 433
      (*doit)(d.newsgroup, d.serial);
      }
      __Cont: /* CIL Label */ 
#line 408
      opt_ind ++;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 435
    dh_close();
#line 436
    _exit(0);
    }
  }
#line 439
  if (opt_ind == argc) {
    {
#line 440
    usage();
    }
  }
  {
#line 442
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 442
    if (opt_ind < argc) {
#line 442
      if (! *(argv + opt_ind)) {
#line 442
        goto while_break___2;
      }
    } else {
#line 442
      goto while_break___2;
    }
    {
#line 448
    start___1 = 0;
#line 449
    newsgroup = *(argv + opt_ind);
#line 451
    colon = strchr((char const   *)newsgroup, ':');
    }
#line 451
    if (colon) {
#line 452
      tmp___12 = colon;
#line 452
      colon ++;
#line 452
      *tmp___12 = (char )'\000';
    }
    {
#line 453
    tmp___13 = strchr((char const   *)newsgroup, '/');
    }
#line 453
    if (tmp___13) {
      {
#line 455
      log_((char *)"Bad newsgroup name \"%s\"", newsgroup);
#line 456
      errors ++;
      }
#line 457
      goto __Cont___0;
    } else {
      {
#line 453
      tmp___14 = strstr((char const   *)newsgroup, "..");
      }
#line 453
      if (tmp___14) {
        {
#line 455
        log_((char *)"Bad newsgroup name \"%s\"", newsgroup);
#line 456
        errors ++;
        }
#line 457
        goto __Cont___0;
      }
    }
    {
#line 459
    tmp___15 = group_info(newsgroup, & g);
    }
#line 459
    if (-1 == tmp___15) {
      {
#line 461
      log_((char *)"group \"%s\":%m?", newsgroup);
#line 462
      errors ++;
      }
#line 463
      goto __Cont___0;
    }
#line 465
    if (since) {
      {
#line 466
      start___1 = earliest(newsgroup, since);
      }
#line 466
      if (0 == start___1) {
#line 467
        goto __Cont___0;
      }
    }
#line 469
    if (colon) {
      {
#line 473
      while (1) {
        while_continue___3: /* CIL Label */ ;
        {
#line 473
        comma = tokensep(& colon, (char *)",");
        }
#line 473
        if (! comma) {
#line 473
          goto while_break___3;
        }
#line 475
        if (45 == (int )*comma) {
#line 475
          if (! *(comma + 1)) {
#line 477
            i = g.first;
            {
#line 477
            while (1) {
              while_continue___4: /* CIL Label */ ;
#line 477
              if (! (i <= g.last)) {
#line 477
                goto while_break___4;
              }
              {
#line 478
              tmp___16 = (*doit)(newsgroup, i);
              }
#line 478
              if (0 == tmp___16) {
#line 479
                goto while_break___4;
              }
#line 477
              i ++;
            }
            while_break___4: /* CIL Label */ ;
            }
#line 480
            if (i > g.last) {
#line 481
              errors ++;
            }
#line 482
            i = g.last;
            {
#line 482
            while (1) {
              while_continue___5: /* CIL Label */ ;
#line 482
              if (! (i >= g.first)) {
#line 482
                goto while_break___5;
              }
              {
#line 483
              tmp___17 = (*doit)(newsgroup, i);
              }
#line 483
              if (0 == tmp___17) {
#line 484
                goto while_break___5;
              }
#line 482
              i --;
            }
            while_break___5: /* CIL Label */ ;
            }
#line 485
            if (i < g.first) {
#line 486
              errors ++;
            }
          } else {
#line 475
            goto _L___0;
          }
        } else {
          _L___0: /* CIL Label */ 
          {
#line 490
          tmp___18 = range(comma, & hi, & lo);
          }
#line 490
          if (tmp___18) {
            {
#line 492
            log_((char *)"Bad range \"%s\"", comma);
#line 493
            errors ++;
            }
#line 494
            goto while_continue___3;
          }
#line 496
          if (hi) {
#line 498
            if (-1 == hi) {
#line 499
              hi = g.last;
            } else
#line 498
            if (hi > g.last) {
#line 499
              hi = g.last;
            }
#line 500
            if (lo < g.first) {
#line 501
              lo = g.first;
            }
#line 502
            if (lo < start___1) {
#line 503
              lo = start___1;
            }
#line 504
            i = lo;
            {
#line 504
            while (1) {
              while_continue___6: /* CIL Label */ ;
#line 504
              if (! (i <= hi)) {
#line 504
                goto while_break___6;
              }
              {
#line 505
              (*doit)(newsgroup, i);
#line 504
              i ++;
              }
            }
            while_break___6: /* CIL Label */ ;
            }
          } else {
            {
#line 508
            (*doit)(newsgroup, lo);
            }
          }
        }
      }
      while_break___3: /* CIL Label */ ;
      }
    } else {
#line 513
      if (start___1) {
#line 513
        i = start___1;
      } else {
#line 513
        i = g.first;
      }
      {
#line 513
      while (1) {
        while_continue___7: /* CIL Label */ ;
#line 513
        if (! (i <= g.last)) {
#line 513
          goto while_break___7;
        }
        {
#line 514
        (*doit)(newsgroup, i);
#line 513
        i ++;
        }
      }
      while_break___7: /* CIL Label */ ;
      }
    }
    __Cont___0: /* CIL Label */ 
#line 442
    opt_ind ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 516
  if (since) {
    {
#line 517
    times_fin();
    }
  }
  {
#line 518
  group_fin();
  }
#line 519
  if (! dhro) {
    {
#line 520
    dh_close();
    }
  }
#line 521
  if (errors) {
#line 521
    tmp___19 = 3;
  } else {
#line 521
    tmp___19 = 0;
  }
  {
#line 521
  _exit(tmp___19);
  }
}
}
#line 678 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) __uid_t ( __attribute__((__leaf__)) geteuid)(void) ;
#line 684
extern  __attribute__((__nothrow__)) __gid_t ( __attribute__((__leaf__)) getegid)(void) ;
#line 700
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) setuid)(__uid_t __uid ) ;
#line 717
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) setgid)(__gid_t __gid ) ;
#line 209 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) stat)(char const   * __restrict  __file ,
                                                                                             struct stat * __restrict  __buf ) ;
#line 564 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) getenv)(char const   *__name ) ;
#line 110 "/usr/include/pwd.h"
extern struct passwd *getpwuid(__uid_t __uid ) ;
#line 105 "/usr/include/grp.h"
extern struct group___0 *getgrgid(__gid_t __gid ) ;
#line 132 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strncpy)(char * __restrict  __dest ,
                                                                                                  char const   * __restrict  __src ,
                                                                                                  size_t __n ) ;
#line 19 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/parameters.c"
char *snroot  =    (char *)"/var/spool/sn";
#line 20 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/parameters.c"
uid_t snuid  ;
#line 21 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/parameters.c"
gid_t sngid  ;
#line 23 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/parameters.c"
void parameters(bool wantwriteperms ) 
{ 
  struct stat st ;
  int tmp ;
  __uid_t tmp___0 ;
  struct passwd *pwuid ;
  struct group___0 *grgid ;
  char euid_name[40] ;
  char egid_name[40] ;
  char snuid_name[40] ;
  char sngid_name[40] ;
  __uid_t tmp___1 ;
  __gid_t tmp___2 ;
  char const   *tmp___3 ;
  char const   *tmp___4 ;
  char const   *tmp___5 ;
  char const   *tmp___6 ;
  __uid_t tmp___7 ;
  __gid_t tmp___8 ;

  {
  {
#line 27
  snroot = getenv("SNROOT");
  }
#line 27
  if (! snroot) {
#line 28
    snroot = (char *)"/var/spool/sn";
  }
  {
#line 30
  tmp = stat((char const   */* __restrict  */)snroot, (struct stat */* __restrict  */)(& st));
  }
#line 30
  if (-1 == tmp) {
    {
#line 31
    fail(2, (char *)"Can\'t find spool directory \"%s\":%m", snroot);
    }
  }
#line 32
  if (! ((st.st_mode & 61440U) == 16384U)) {
    {
#line 33
    fail(2, (char *)"\"%s\" is not a directory", snroot);
    }
  }
  {
#line 34
  snuid = st.st_uid;
#line 35
  sngid = st.st_gid;
#line 36
  tmp___0 = geteuid();
  }
#line 36
  if (0U == tmp___0) {
    {
#line 38
    setgid(sngid);
#line 39
    setuid(snuid);
    }
  }
#line 42
  if (wantwriteperms) {
    {
#line 43
    tmp___7 = geteuid();
    }
#line 43
    if (snuid != tmp___7) {
#line 43
      goto _L;
    } else {
      {
#line 43
      tmp___8 = getegid();
      }
#line 43
      if (sngid != tmp___8) {
        _L: /* CIL Label */ 
        {
#line 50
        tmp___1 = geteuid();
#line 50
        pwuid = getpwuid(tmp___1);
#line 51
        tmp___2 = getegid();
#line 51
        grgid = getgrgid(tmp___2);
        }
#line 52
        if (pwuid) {
#line 52
          tmp___3 = (char const   *)pwuid->pw_name;
        } else {
#line 52
          tmp___3 = "(unknown)";
        }
        {
#line 52
        strncpy((char */* __restrict  */)(euid_name), (char const   */* __restrict  */)tmp___3,
                (size_t )40);
        }
#line 53
        if (grgid) {
#line 53
          tmp___4 = (char const   *)grgid->gr_name;
        } else {
#line 53
          tmp___4 = "(unknown)";
        }
        {
#line 53
        strncpy((char */* __restrict  */)(egid_name), (char const   */* __restrict  */)tmp___4,
                (size_t )40);
#line 54
        pwuid = getpwuid(snuid);
#line 55
        grgid = getgrgid(sngid);
        }
#line 56
        if (pwuid) {
#line 56
          tmp___5 = (char const   *)pwuid->pw_name;
        } else {
#line 56
          tmp___5 = "(unknown)";
        }
        {
#line 56
        strncpy((char */* __restrict  */)(snuid_name), (char const   */* __restrict  */)tmp___5,
                (size_t )40);
        }
#line 57
        if (grgid) {
#line 57
          tmp___6 = (char const   *)grgid->gr_name;
        } else {
#line 57
          tmp___6 = "(unknown)";
        }
        {
#line 57
        strncpy((char */* __restrict  */)(sngid_name), (char const   */* __restrict  */)tmp___6,
                (size_t )40);
#line 59
        fail(2, (char *)"Can\'t write in spool directory \"%s\" (I am %s:%s, must be %s:%s)",
             snroot, euid_name, egid_name, snuid_name, sngid_name);
        }
      }
    }
  }
#line 62
  return;
}
}
#line 1016 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) ftruncate)(int __fd ,
                                                                                __off_t __length ) ;
#line 147 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 35 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/newsgroup.c"
static struct ng *bygroup[128]  ;
#line 36 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/newsgroup.c"
static struct ng *byident[128]  ;
#line 37 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/newsgroup.c"
static int highest  =    0;
#line 39 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/newsgroup.c"
static unsigned int hash(char *buf___28 , int len ) 
{ 
  unsigned int h ;
  char *tmp ;

  {
#line 43
  h = 5381U;
  {
#line 44
  while (1) {
    while_continue: /* CIL Label */ ;
#line 44
    if (! len) {
#line 44
      goto while_break;
    }
#line 46
    len --;
#line 47
    h += h << 5;
#line 48
    tmp = buf___28;
#line 48
    buf___28 ++;
#line 48
    h ^= (unsigned int )*tmp;
  }
  while_break: /* CIL Label */ ;
  }
#line 50
  return (h);
}
}
#line 53 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/newsgroup.c"
static struct chunk *chunks  ;
#line 58 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/newsgroup.c"
static int avail  =    0;
#line 59 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/newsgroup.c"
static int nr___0  =    0;
#line 64 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/newsgroup.c"
static int add___0(int ident , char *group , int len ) 
{ 
  struct ng *np ;
  struct ng *p ;
  int want ;
  unsigned int h ;
  struct chunk *tmp ;
  int size___1 ;
  void *tmp___0 ;
  unsigned int tmp___1 ;
  int tmp___2 ;

  {
#line 71
  len ++;
#line 72
  want = (int )(((unsigned long )len + sizeof(struct ng )) + sizeof(char *));
#line 73
  want = (int )((unsigned long )want - (unsigned long )len % sizeof(char *));
#line 74
  len --;
#line 76
  if (avail < want) {
#line 81
    if (want > 240) {
#line 81
      size___1 = want + 240;
    } else {
#line 81
      size___1 = 240;
    }
    {
#line 82
    tmp___0 = malloc((size_t )size___1);
#line 82
    tmp = (struct chunk *)tmp___0;
    }
#line 82
    if (! tmp) {
#line 83
      return (-1);
    }
#line 84
    tmp->next = chunks;
#line 85
    chunks = tmp;
#line 86
    chunks->buf = (char *)chunks + sizeof(struct chunk );
#line 87
    avail = (int )((unsigned long )size___1 - sizeof(struct chunk ));
  }
  {
#line 89
  np = (struct ng *)chunks->buf;
#line 90
  chunks->buf += want;
#line 91
  avail -= want;
#line 92
  strncpy((char */* __restrict  */)(np->group), (char const   */* __restrict  */)group,
          (size_t )len);
#line 93
  np->group[len] = (char )'\000';
#line 94
  np->ident = ident;
#line 96
  tmp___1 = hash(group, len);
#line 96
  h = tmp___1 % 128U;
#line 97
  np->gnext = bygroup[h];
#line 98
  bygroup[h] = np;
#line 99
  p = np->gnext;
  }
  {
#line 99
  while (1) {
    while_continue: /* CIL Label */ ;
#line 99
    if (! p) {
#line 99
      goto while_break;
    }
    {
#line 100
    tmp___2 = strcmp((char const   *)(p->group), (char const   *)group);
    }
#line 100
    if (0 == tmp___2) {
#line 101
      return (1);
    }
#line 99
    p = p->gnext;
  }
  while_break: /* CIL Label */ ;
  }
#line 102
  h = (unsigned int )(ident % 128);
#line 103
  np->inext = byident[h];
#line 104
  byident[h] = np;
#line 105
  p = np->inext;
  {
#line 105
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 105
    if (! p) {
#line 105
      goto while_break___0;
    }
#line 106
    if (p->ident == ident) {
#line 107
      return (1);
    }
#line 105
    p = p->inext;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 109
  if (ident > highest) {
#line 110
    highest = ident;
  }
#line 111
  nr___0 ++;
#line 112
  return (0);
}
}
#line 116 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/newsgroup.c"
static int groupfd  =    -1;
#line 117 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/newsgroup.c"
static int oldsize  =    0;
#line 118 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/newsgroup.c"
static int mapsize  =    0;
#line 119 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/newsgroup.c"
static char *mapbuf  =    (char *)((void *)0);
#line 121 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/newsgroup.c"
void ng_fin(void) 
{ 
  struct chunk *tmp ;

  {
#line 125
  if (groupfd > -1) {
    {
#line 127
    close(groupfd);
#line 128
    groupfd = -1;
    }
  }
#line 130
  if (chunks) {
    {
#line 131
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 133
      tmp = chunks->next;
#line 134
      free((void *)chunks);
#line 131
      chunks = tmp;
      }
#line 131
      if (! chunks) {
#line 131
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 137
  if (mapbuf) {
    {
#line 139
    munmap((void *)mapbuf, (size_t )mapsize);
#line 140
    mapbuf = (char *)((void *)0);
    }
  }
#line 142
  mapsize = 0;
#line 142
  oldsize = mapsize;
#line 142
  highest = oldsize;
#line 143
  return;
}
}
#line 148
static int reload(void) ;
#line 148 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/newsgroup.c"
static int pagesize___1  =    0;
#line 145 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/newsgroup.c"
static int reload(void) 
{ 
  struct stat st ;
  int newsize ;
  int tmp ;
  void *tmp___0 ;
  char *p ;
  char *lim ;
  char *ip ;
  char *gr ;
  int ident ;
  int state ;
  int tmp___1 ;

  {
  {
#line 156
  tmp = fstat(groupfd, & st);
  }
#line 156
  if (-1 == tmp) {
    {
#line 158
    log_((char *)"reload:fstat:%m");
    }
#line 159
    return (-1);
  }
#line 161
  newsize = (int )st.st_size;
#line 162
  if (! pagesize___1) {
    {
#line 163
    pagesize___1 = getpagesize();
    }
  }
#line 164
  if (newsize <= oldsize) {
#line 165
    return (0);
  }
#line 166
  if (newsize > mapsize) {
#line 166
    goto _L;
  } else
#line 166
  if (! mapsize) {
    _L: /* CIL Label */ 
#line 168
    if (mapbuf) {
      {
#line 169
      munmap((void *)mapbuf, (size_t )mapsize);
      }
    }
    {
#line 170
    mapsize = (int )((st.st_size + (__off_t )pagesize___1) - st.st_size % (long )pagesize___1);
#line 171
    tmp___0 = mmap((void *)0, (size_t )mapsize, 1, 1, groupfd, (__off_t )0);
#line 171
    mapbuf = (char *)tmp___0;
    }
#line 172
    if (! mapbuf) {
      {
#line 174
      log_((char *)"reload:mmap:%m");
      }
#line 175
      return (-1);
    } else
#line 172
    if ((unsigned long )mapbuf == (unsigned long )((void *)-1)) {
      {
#line 174
      log_((char *)"reload:mmap:%m");
      }
#line 175
      return (-1);
    }
  }
#line 188
  lim = mapbuf + newsize;
#line 189
  state = 0;
#line 189
  ident = state;
#line 190
  gr = (char *)0;
#line 190
  ip = gr;
#line 191
  p = mapbuf + oldsize;
  {
#line 191
  while (1) {
    while_continue: /* CIL Label */ ;
#line 191
    if (! ((unsigned long )p < (unsigned long )lim)) {
#line 191
      goto while_break;
    }
    {
#line 194
    if (state == 0) {
#line 194
      goto case_0;
    }
#line 195
    if (state == 1) {
#line 195
      goto case_1;
    }
#line 196
    if (state == 2) {
#line 196
      goto case_2;
    }
#line 197
    if (state == 3) {
#line 197
      goto case_3;
    }
#line 192
    goto switch_break;
    case_0: /* CIL Label */ 
#line 194
    if ((int )*p >= 48) {
#line 194
      if ((int )*p <= 57) {
#line 194
        ip = p;
#line 194
        state ++;
      }
    }
#line 194
    goto switch_break;
    case_1: /* CIL Label */ 
#line 195
    if (32 == (int )*p) {
      {
#line 195
      ident = atoi((char const   *)ip);
#line 195
      state ++;
      }
    }
#line 195
    goto switch_break;
    case_2: /* CIL Label */ 
#line 196
    if (32 != (int )*p) {
#line 196
      gr = p;
#line 196
      state ++;
    }
#line 196
    goto switch_break;
    case_3: /* CIL Label */ 
#line 198
    if (10 != (int )*p) {
#line 199
      goto switch_break;
    }
    {
#line 200
    tmp___1 = add___0(ident, gr, (int )(p - gr));
    }
#line 200
    if (-1 == tmp___1) {
      {
#line 202
      log_((char *)"reload:no memory");
      }
#line 203
      return (-1);
    }
#line 205
    state = 0;
    switch_break: /* CIL Label */ ;
    }
#line 191
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 208
  oldsize = newsize;
#line 209
  return (0);
}
}
#line 212 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/newsgroup.c"
int ng_init(void) 
{ 
  int tmp ;

  {
  {
#line 214
  groupfd = open((char const   *)(dh_groupfile), 66, 420);
  }
#line 214
  if (-1 == groupfd) {
    {
#line 215
    groupfd = open((char const   *)(dh_groupfile), 0);
    }
#line 215
    if (-1 == groupfd) {
      {
#line 217
      log_((char *)"ng_init:open(%s):%m", dh_groupfile);
      }
#line 218
      return (-1);
    }
  }
  {
#line 220
  tmp = reload();
  }
#line 220
  if (-1 == tmp) {
    {
#line 222
    close(groupfd);
#line 223
    groupfd = -1;
    }
#line 223
    return (groupfd);
  }
#line 225
  return (nr___0);
}
}
#line 228 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/newsgroup.c"
int ng_ident(char *group ) 
{ 
  struct ng *np ;
  size_t tmp ;
  unsigned int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 232
  tmp = strlen((char const   *)group);
#line 232
  tmp___0 = hash(group, (int )tmp);
#line 232
  np = bygroup[tmp___0 % 128U];
  }
  {
#line 232
  while (1) {
    while_continue: /* CIL Label */ ;
#line 232
    if (! np) {
#line 232
      goto while_break;
    }
    {
#line 233
    tmp___1 = strcmp((char const   *)group, (char const   *)(np->group));
    }
#line 233
    if (0 == tmp___1) {
#line 234
      return (np->ident);
    }
#line 232
    np = np->gnext;
  }
  while_break: /* CIL Label */ ;
  }
#line 235
  return (-1);
}
}
#line 238 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/newsgroup.c"
char *ng_newsgroup(int ident ) 
{ 
  struct ng *np ;

  {
#line 242
  np = byident[ident % 128];
  {
#line 242
  while (1) {
    while_continue: /* CIL Label */ ;
#line 242
    if (! np) {
#line 242
      goto while_break;
    }
#line 243
    if (ident == np->ident) {
#line 244
      return (np->group);
    }
#line 242
    np = np->inext;
  }
  while_break: /* CIL Label */ ;
  }
#line 245
  return ((char *)((void *)0));
}
}
#line 252 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/newsgroup.c"
int ng_addgroup(char *group ) 
{ 
  int ident ;
  char *buf___28 ;
  int tmp ;
  int len ;
  size_t tmp___0 ;
  int c ;
  int seek ;
  int tmp___1 ;
  int tmp___2 ;
  ssize_t tmp___3 ;
  __off_t tmp___4 ;
  void *tmp___5 ;
  int tmp___6 ;

  {
  {
#line 257
  tmp = lockf(groupfd, 1, (__off_t )0);
  }
#line 257
  if (-1 == tmp) {
    {
#line 259
    log_((char *)"ng_addgroup:lockf(%s):%m", dh_groupfile);
    }
#line 260
    return (-1);
  }
  {
#line 262
  ident = -1;
#line 263
  tmp___6 = reload();
  }
#line 263
  if (0 == tmp___6) {
    {
#line 264
    ident = ng_ident(group);
    }
#line 264
    if (-1 == ident) {
      {
#line 268
      tmp___0 = strlen((char const   *)group);
#line 268
      len = (int )tmp___0;
#line 269
      tmp___5 = malloc((size_t )(len + 15));
#line 269
      buf___28 = (char *)tmp___5;
      }
#line 269
      if (buf___28) {
        {
#line 273
        c = formats(buf___28, len + 14, (char *)"%u %s\n", highest + 1, group);
#line 274
        tmp___4 = lseek(groupfd, (__off_t )0, 2);
#line 274
        seek = (int )tmp___4;
        }
#line 274
        if (seek > -1) {
          {
#line 275
          tmp___3 = write(groupfd, (void const   *)buf___28, (size_t )c);
          }
#line 275
          if ((ssize_t )c == tmp___3) {
            {
#line 277
            tmp___2 = add___0(highest + 1, group, len);
            }
#line 277
            if (0 == tmp___2) {
#line 278
              ident = highest;
            } else {
              {
#line 279
              tmp___1 = ftruncate(groupfd, (__off_t )seek);
              }
#line 279
              if (-1 == tmp___1) {
                {
#line 280
                log_((char *)"ng_addgroup:ftruncate:%m");
                }
              } else {
                {
#line 282
                log_((char *)"ng_addgroup:write fail for %d %s:%m?", highest + 1,
                     group);
                }
              }
            }
          }
        }
        {
#line 284
        free((void *)buf___28);
        }
      } else {
        {
#line 287
        log_((char *)"ng_addgroup:malloc for %s:%m", group);
        }
      }
    }
  }
  {
#line 289
  lseek(groupfd, (__off_t )0, 0);
#line 290
  lockf(groupfd, 0, (__off_t )0);
  }
#line 291
  return (ident);
}
}
#line 69 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) memcmp)(void const   *__s1 ,
                                                                                               void const   *__s2 ,
                                                                                               size_t __n )  __attribute__((__pure__)) ;
#line 18 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/key.h"
char *key_exists(char *key , int len ) ;
#line 19
int key_add(char **keyp , int len ) ;
#line 20
void key_free(void) ;
#line 31
struct key *key_table[128] ;
#line 32
int nr_keys ;
#line 26 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/key.c"
static struct buf *head___0  ;
#line 27 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/key.c"
static int avail___0  =    0;
#line 28 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/key.c"
static char *keybuf  =    (char *)((void *)0);
#line 30 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/key.c"
struct key *key_table[128]  = {      (struct key *)0};
#line 31 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/key.c"
int nr_keys  =    0;
#line 33 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/key.c"
static unsigned int hv  ;
#line 35 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/key.c"
static void hash___0(char *key , int len ) 
{ 
  char *tmp ;

  {
#line 37
  hv = 5381U;
  {
#line 38
  while (1) {
    while_continue: /* CIL Label */ ;
#line 38
    if (! len) {
#line 38
      goto while_break;
    }
#line 40
    len --;
#line 41
    hv += hv << 5;
#line 42
    tmp = key;
#line 42
    key ++;
#line 42
    hv ^= (unsigned int )*tmp;
  }
  while_break: /* CIL Label */ ;
  }
#line 44
  hv %= 128U;
#line 45
  return;
}
}
#line 47 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/key.c"
char *key_exists(char *key , int len ) 
{ 
  struct key *kp ;
  int tmp ;

  {
  {
#line 51
  hash___0(key, len);
#line 52
  kp = key_table[hv];
  }
  {
#line 52
  while (1) {
    while_continue: /* CIL Label */ ;
#line 52
    if (! kp) {
#line 52
      goto while_break;
    }
#line 53
    if (kp->len == len) {
      {
#line 54
      tmp = memcmp((void const   *)((char *)kp + sizeof(struct key )), (void const   *)key,
                   (size_t )len);
      }
#line 54
      if (0 == tmp) {
#line 55
        return ((char *)kp + sizeof(struct key ));
      }
    }
#line 52
    kp = kp->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 56
  return ((char *)((void *)0));
}
}
#line 59 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/key.c"
int key_add(char **keyp , int len ) 
{ 
  struct key *kp ;
  char *key ;
  int size___1 ;
  char *tmp ;
  struct buf *x ;
  void *tmp___0 ;
  char *tmp___1 ;

  {
  {
#line 65
  key = *keyp;
#line 66
  tmp = key_exists(key, len);
  }
#line 66
  if (tmp) {
#line 67
    return (1);
  }
#line 68
  size___1 = (int )((unsigned long )len + sizeof(*kp));
#line 69
  size___1 += 4 - size___1 % 4;
#line 70
  if (avail___0 < size___1) {
    {
#line 73
    tmp___0 = malloc(sizeof(struct buf ));
#line 73
    x = (struct buf *)tmp___0;
    }
#line 73
    if (! x) {
#line 74
      return (-1);
    }
#line 75
    x->next = head___0;
#line 76
    head___0 = x;
#line 77
    avail___0 = 1000;
#line 78
    keybuf = head___0->buf;
  }
  {
#line 80
  kp = (struct key *)keybuf;
#line 81
  kp->len = len;
#line 82
  tmp___1 = (char *)kp + sizeof(struct key );
#line 82
  *keyp = tmp___1;
#line 82
  memcpy((void */* __restrict  */)tmp___1, (void const   */* __restrict  */)key, (size_t )(len + 1));
#line 83
  kp->next = key_table[hv];
#line 84
  key_table[hv] = kp;
#line 85
  keybuf += size___1;
#line 86
  avail___0 -= size___1;
#line 87
  nr_keys ++;
  }
#line 88
  return (0);
}
}
#line 91 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/key.c"
void key_free(void) 
{ 
  int i ;
  struct buf *tmp ;

  {
#line 95
  i = 0;
  {
#line 95
  while (1) {
    while_continue: /* CIL Label */ ;
#line 95
    if (! ((unsigned long )i < sizeof(key_table) / sizeof(key_table[0]))) {
#line 95
      goto while_break;
    }
#line 96
    key_table[i] = (struct key *)0;
#line 95
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 97
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 97
    if (! head___0) {
#line 97
      goto while_break___0;
    }
    {
#line 101
    tmp = head___0->next;
#line 102
    free((void *)head___0);
#line 103
    head___0 = tmp;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 105
  avail___0 = 0;
#line 105
  nr_keys = avail___0;
#line 106
  return;
}
}
#line 578 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) putenv)(char *__string ) ;
#line 17 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/path.c"
int set_path_var(void) 
{ 
  char *p ;
  char *path___1 ;
  int tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;

  {
  {
#line 22
  p = getenv("PATH");
  }
#line 22
  if (! p) {
    {
#line 23
    tmp = putenv((char *)"PATH=/usr/sbin");
    }
#line 23
    return (tmp);
  }
  {
#line 24
  path___1 = strstr((char const   *)p, "/usr/sbin");
  }
#line 24
  if (path___1) {
#line 25
    if ((unsigned long )path___1 == (unsigned long )p) {
#line 25
      goto _L;
    } else
#line 25
    if (58 == (int )*(path___1 + -1)) {
      _L: /* CIL Label */ 
#line 26
      if (! *(path___1 + (sizeof("/usr/sbin") - 1UL))) {
#line 27
        return (0);
      } else
#line 26
      if (58 == (int )*(path___1 + (sizeof("/usr/sbin") - 1UL))) {
#line 27
        return (0);
      }
    }
  }
  {
#line 28
  tmp___0 = strlen((char const   *)p);
#line 28
  tmp___1 = malloc((tmp___0 + sizeof("PATH=:/usr/sbin")) + 2UL);
#line 28
  path___1 = (char *)tmp___1;
  }
#line 29
  if (! path___1) {
#line 30
    return (-1);
  }
  {
#line 31
  strcpy((char */* __restrict  */)path___1, (char const   */* __restrict  */)"PATH=");
#line 32
  strcat((char */* __restrict  */)path___1, (char const   */* __restrict  */)p);
#line 33
  strcat((char */* __restrict  */)path___1, (char const   */* __restrict  */)":/usr/sbin");
#line 34
  tmp___2 = putenv(path___1);
  }
#line 34
  return (tmp___2);
}
}
#line 392 "/usr/include/zlib.h"
extern int inflate(z_streamp strm , int flush ) ;
#line 508
extern int inflateEnd(z_streamp strm ) ;
#line 1635
extern int inflateInit_(z_streamp strm , char const   *version , int stream_size ) ;
#line 26 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/body.c"
static char *bodbuf  =    (char *)((void *)0);
#line 24 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/body.c"
int body(char **artbod , int *len ) 
{ 
  z_stream zs ;
  int e ;
  int msize ;
  int inc ;
  void *tmp ;
  char *tmp___0 ;
  int used___0 ;
  void *tmp___1 ;

  {
#line 30
  if (bodbuf) {
    {
#line 32
    free((void *)bodbuf);
#line 33
    bodbuf = (char *)((void *)0);
    }
  }
#line 36
  if (*len < 0) {
#line 37
    return (1);
  }
#line 38
  if (0 == *len) {
#line 39
    return (0);
  } else
#line 38
  if ((unsigned long )*len < sizeof("c\003c\003") - 1UL) {
#line 39
    return (0);
  }
#line 40
  e = 0;
  {
#line 40
  while (1) {
    while_continue: /* CIL Label */ ;
#line 40
    if (! ((unsigned long )e < sizeof("c\003c\003") - 1UL)) {
#line 40
      goto while_break;
    }
#line 41
    if ((int )*(*artbod + e) != (int )*("c\003c\003" + e)) {
#line 42
      return (0);
    }
#line 40
    e ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 44
  inc = *len / 2 + 1;
#line 45
  zs.avail_out = (uInt )(5 * inc);
#line 45
  msize = (int )zs.avail_out;
#line 45
  tmp = malloc((size_t )msize);
#line 45
  zs.next_out = (Bytef *)tmp;
#line 46
  bodbuf = (char *)zs.next_out;
  }
#line 46
  if (! bodbuf) {
#line 47
    return (-1);
  }
  {
#line 48
  zs.next_in = (unsigned char *)*artbod + (sizeof("c\003c\003") - 1UL);
#line 49
  zs.avail_in = (unsigned int )((unsigned long )*len - (sizeof("c\003c\003") - 1UL));
#line 50
  zs.zalloc = (voidpf (*)(voidpf opaque , uInt items , uInt size ))0;
#line 51
  zs.zfree = (void (*)(voidpf opaque , voidpf address ))0;
#line 52
  e = inflateInit_(& zs, "1.2.8", (int )sizeof(z_stream ));
  }
#line 52
  if (e) {
#line 53
    return (0);
  }
  {
#line 55
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 55
    e = inflate(& zs, 0);
    }
#line 55
    if (! (0 == e)) {
#line 55
      goto while_break___0;
    }
#line 56
    if (zs.avail_out < 10U) {
      {
#line 61
      tmp___1 = malloc((size_t )(msize + inc));
#line 61
      tmp___0 = (char *)tmp___1;
      }
#line 61
      if (! tmp___0) {
#line 62
        goto bomb;
      }
      {
#line 63
      used___0 = (int )((uInt )msize - zs.avail_out);
#line 64
      memcpy((void */* __restrict  */)tmp___0, (void const   */* __restrict  */)bodbuf,
             (size_t )used___0);
#line 65
      zs.next_out = (unsigned char *)tmp___0 + used___0;
#line 66
      msize += inc;
#line 67
      zs.avail_out += (uInt )inc;
#line 68
      free((void *)bodbuf);
#line 69
      bodbuf = tmp___0;
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 72
  inflateEnd(& zs);
  }
#line 73
  if (1 == e) {
#line 80
    *len = (int )(zs.next_out - (unsigned char *)bodbuf);
#line 81
    *artbod = bodbuf;
#line 82
    *(bodbuf + *len) = (char )'\000';
#line 83
    return (0);
  }
  bomb: 
  {
#line 87
  free((void *)bodbuf);
#line 88
  bodbuf = (char *)((void *)0);
  }
#line 89
  return (-1);
}
}
#line 56 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/dhash.c"
static unsigned char buf___1[2]  ;
#line 54 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/dhash.c"
static char *inttochar2___0(int integer ) 
{ 


  {
#line 58
  buf___1[0] = (unsigned char )((integer & 65535) >> 8);
#line 59
  buf___1[1] = (unsigned char )(integer & 255);
#line 60
  return ((char *)(buf___1));
}
}
#line 65 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/dhash.c"
static unsigned char buf___2[3]  ;
#line 63 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/dhash.c"
static char *inttochar3___0(unsigned int integer ) 
{ 


  {
#line 67
  integer >>= 2;
#line 68
  buf___2[0] = (unsigned char )((integer & 16777215U) >> 16);
#line 69
  buf___2[1] = (unsigned char )((integer & 65535U) >> 8);
#line 70
  buf___2[2] = (unsigned char )(integer & 255U);
#line 71
  return ((char *)(buf___2));
}
}
#line 809 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) ssize_t ( __attribute__((__nonnull__(1,2), __leaf__)) readlink)(char const   * __restrict  __path ,
                                                                                                     char * __restrict  __buf ,
                                                                                                     size_t __len ) ;
#line 106 "/usr/include/x86_64-linux-gnu/sys/select.h"
extern int select(int __nfds , fd_set * __restrict  __readfds , fd_set * __restrict  __writefds ,
                  fd_set * __restrict  __exceptfds , struct timeval * __restrict  __timeout ) ;
#line 13 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/get.h"
char *optdebug ;
#line 14
char *optpipelining ;
#line 15
char *optmax ;
#line 16
bool optlogpid ;
#line 18
int throttlerate ;
#line 19
int concurrency ;
#line 23
int throttle_setfds(fd_set *rs ) ;
#line 24
void throttle(fd_set *rs ) ;
#line 25
int reap(void) ;
#line 26
int sow(void) ;
#line 28
bool sigchld ;
#line 29
bool sigusr ;
#line 31
void init(void) ;
#line 32
int add(char *group ) ;
#line 33
int jobs_not_done(void) ;
#line 34
void quit(void) ;
#line 12 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/valid.h"
extern bool is_valid_group(char *name ) ;
#line 13 "./lib/statf.h"
int statf(struct stat *stp , char *fmt  , ...) ;
#line 87 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/cache.c"
static struct entry *new_entry___0(int desc___35 ) 
{ 
  struct entry *ep ;
  struct entry *tmp ;

  {
#line 91
  ep = table[desc___35].freelist;
#line 91
  if (ep) {
#line 92
    table[desc___35].freelist = ep->next;
  } else {
#line 95
    ep = table[desc___35].entries;
    {
#line 95
    while (1) {
      while_continue: /* CIL Label */ ;
#line 95
      if (! ep->next) {
#line 95
        goto while_break;
      }
#line 95
      ep = ep->next;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 96
    (ep->prev)->next = (struct entry *)((void *)0);
#line 97
    (*(table[desc___35].freeobj))(ep->object);
    }
  }
#line 99
  tmp = (struct entry *)((void *)0);
#line 99
  ep->next = tmp;
#line 99
  ep->prev = tmp;
#line 100
  ep->object = (void *)0;
#line 101
  return (ep);
}
}
#line 105 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/dh_find.c"
static int initfile___1(void) 
{ 
  int fd ;
  int integer ;
  int i ;
  char foo[3] ;
  unsigned int tmp ;
  int *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  ssize_t tmp___3 ;
  ssize_t tmp___4 ;

  {
#line 108
  integer = 218885376;
#line 110
  foo[0] = (char )'\000';
#line 110
  tmp = 1U;
  {
#line 110
  while (1) {
    while_continue: /* CIL Label */ ;
#line 110
    if (tmp >= 3U) {
#line 110
      goto while_break;
    }
#line 110
    foo[tmp] = (char)0;
#line 110
    tmp ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 112
  fd = open((char const   *)(dh_tablefile), 194, 420);
  }
#line 113
  if (fd == -1) {
#line 114
    return (-1);
  }
  {
#line 115
  tmp___2 = lockf(fd, 2, (__off_t )0);
  }
#line 115
  if (tmp___2 == -1) {
    {
#line 117
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 119
      tmp___0 = __errno_location();
      }
#line 119
      if (*tmp___0 == 11) {
        {
#line 120
        nap(0, 200);
        }
      } else {
#line 122
        goto fail;
      }
      {
#line 117
      tmp___1 = lockf(fd, 2, (__off_t )0);
      }
#line 117
      if (! (tmp___1 == -1)) {
#line 117
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 125
    lockf(fd, 0, (__off_t )0);
    }
#line 126
    return (fd);
  }
  {
#line 128
  tmp___3 = write(fd, (void const   *)(& integer), sizeof(int ));
  }
#line 128
  if ((unsigned long )tmp___3 != sizeof(int )) {
#line 129
    goto fail;
  }
#line 130
  i = 0;
  {
#line 130
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 130
    if (! (i < 10240)) {
#line 130
      goto while_break___1;
    }
    {
#line 131
    tmp___4 = write(fd, (void const   *)(foo), sizeof(foo));
    }
#line 131
    if ((unsigned long )tmp___4 != sizeof(foo)) {
#line 132
      goto fail;
    }
#line 130
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 133
  lseek(fd, (__off_t )0, 0);
#line 134
  lockf(fd, 0, (__off_t )0);
  }
#line 135
  return (fd);
  fail: 
#line 138
  if (fd > -1) {
    {
#line 139
    close(fd);
    }
  }
#line 140
  return (-1);
}
}
#line 35 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/newsgroup.c"
static struct ng *bygroup___0[128]  ;
#line 36 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/newsgroup.c"
static struct ng *byident___0[128]  ;
#line 37 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/newsgroup.c"
static int highest___0  =    0;
#line 39 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/newsgroup.c"
static unsigned int hash___1(char *buf___28 , int len ) 
{ 
  unsigned int h ;
  char *tmp ;

  {
#line 43
  h = 5381U;
  {
#line 44
  while (1) {
    while_continue: /* CIL Label */ ;
#line 44
    if (! len) {
#line 44
      goto while_break;
    }
#line 46
    len --;
#line 47
    h += h << 5;
#line 48
    tmp = buf___28;
#line 48
    buf___28 ++;
#line 48
    h ^= (unsigned int )*tmp;
  }
  while_break: /* CIL Label */ ;
  }
#line 50
  return (h);
}
}
#line 53 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/newsgroup.c"
static struct chunk *chunks___0  ;
#line 58 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/newsgroup.c"
static int avail___1  =    0;
#line 59 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/newsgroup.c"
static int nr___1  =    0;
#line 64 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/newsgroup.c"
static int add___1(int ident , char *group , int len ) 
{ 
  struct ng *np ;
  struct ng *p ;
  int want ;
  unsigned int h ;
  struct chunk *tmp ;
  int size___1 ;
  void *tmp___0 ;
  unsigned int tmp___1 ;
  int tmp___2 ;

  {
#line 71
  len ++;
#line 72
  want = (int )(((unsigned long )len + sizeof(struct ng )) + sizeof(char *));
#line 73
  want = (int )((unsigned long )want - (unsigned long )len % sizeof(char *));
#line 74
  len --;
#line 76
  if (avail___1 < want) {
#line 81
    if (want > 240) {
#line 81
      size___1 = want + 240;
    } else {
#line 81
      size___1 = 240;
    }
    {
#line 82
    tmp___0 = malloc((size_t )size___1);
#line 82
    tmp = (struct chunk *)tmp___0;
    }
#line 82
    if (! tmp) {
#line 83
      return (-1);
    }
#line 84
    tmp->next = chunks___0;
#line 85
    chunks___0 = tmp;
#line 86
    chunks___0->buf = (char *)chunks___0 + sizeof(struct chunk );
#line 87
    avail___1 = (int )((unsigned long )size___1 - sizeof(struct chunk ));
  }
  {
#line 89
  np = (struct ng *)chunks___0->buf;
#line 90
  chunks___0->buf += want;
#line 91
  avail___1 -= want;
#line 92
  strncpy((char */* __restrict  */)(np->group), (char const   */* __restrict  */)group,
          (size_t )len);
#line 93
  np->group[len] = (char )'\000';
#line 94
  np->ident = ident;
#line 96
  tmp___1 = hash___1(group, len);
#line 96
  h = tmp___1 % 128U;
#line 97
  np->gnext = bygroup___0[h];
#line 98
  bygroup___0[h] = np;
#line 99
  p = np->gnext;
  }
  {
#line 99
  while (1) {
    while_continue: /* CIL Label */ ;
#line 99
    if (! p) {
#line 99
      goto while_break;
    }
    {
#line 100
    tmp___2 = strcmp((char const   *)(p->group), (char const   *)group);
    }
#line 100
    if (0 == tmp___2) {
#line 101
      return (1);
    }
#line 99
    p = p->gnext;
  }
  while_break: /* CIL Label */ ;
  }
#line 102
  h = (unsigned int )(ident % 128);
#line 103
  np->inext = byident___0[h];
#line 104
  byident___0[h] = np;
#line 105
  p = np->inext;
  {
#line 105
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 105
    if (! p) {
#line 105
      goto while_break___0;
    }
#line 106
    if (p->ident == ident) {
#line 107
      return (1);
    }
#line 105
    p = p->inext;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 109
  if (ident > highest___0) {
#line 110
    highest___0 = ident;
  }
#line 111
  nr___1 ++;
#line 112
  return (0);
}
}
#line 116 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/newsgroup.c"
static int groupfd___0  =    -1;
#line 117 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/newsgroup.c"
static int oldsize___0  =    0;
#line 118 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/newsgroup.c"
static int mapsize___0  =    0;
#line 119 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/newsgroup.c"
static char *mapbuf___0  =    (char *)((void *)0);
#line 148
static int reload___0(void) ;
#line 148 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/newsgroup.c"
static int pagesize___2  =    0;
#line 145 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/newsgroup.c"
static int reload___0(void) 
{ 
  struct stat st ;
  int newsize ;
  int tmp ;
  void *tmp___0 ;
  char *p ;
  char *lim ;
  char *ip ;
  char *gr ;
  int ident ;
  int state ;
  int tmp___1 ;

  {
  {
#line 156
  tmp = fstat(groupfd___0, & st);
  }
#line 156
  if (-1 == tmp) {
    {
#line 158
    log_((char *)"reload:fstat:%m");
    }
#line 159
    return (-1);
  }
#line 161
  newsize = (int )st.st_size;
#line 162
  if (! pagesize___2) {
    {
#line 163
    pagesize___2 = getpagesize();
    }
  }
#line 164
  if (newsize <= oldsize___0) {
#line 165
    return (0);
  }
#line 166
  if (newsize > mapsize___0) {
#line 166
    goto _L;
  } else
#line 166
  if (! mapsize___0) {
    _L: /* CIL Label */ 
#line 168
    if (mapbuf___0) {
      {
#line 169
      munmap((void *)mapbuf___0, (size_t )mapsize___0);
      }
    }
    {
#line 170
    mapsize___0 = (int )((st.st_size + (__off_t )pagesize___2) - st.st_size % (long )pagesize___2);
#line 171
    tmp___0 = mmap((void *)0, (size_t )mapsize___0, 1, 1, groupfd___0, (__off_t )0);
#line 171
    mapbuf___0 = (char *)tmp___0;
    }
#line 172
    if (! mapbuf___0) {
      {
#line 174
      log_((char *)"reload:mmap:%m");
      }
#line 175
      return (-1);
    } else
#line 172
    if ((unsigned long )mapbuf___0 == (unsigned long )((void *)-1)) {
      {
#line 174
      log_((char *)"reload:mmap:%m");
      }
#line 175
      return (-1);
    }
  }
#line 188
  lim = mapbuf___0 + newsize;
#line 189
  state = 0;
#line 189
  ident = state;
#line 190
  gr = (char *)0;
#line 190
  ip = gr;
#line 191
  p = mapbuf___0 + oldsize___0;
  {
#line 191
  while (1) {
    while_continue: /* CIL Label */ ;
#line 191
    if (! ((unsigned long )p < (unsigned long )lim)) {
#line 191
      goto while_break;
    }
    {
#line 194
    if (state == 0) {
#line 194
      goto case_0;
    }
#line 195
    if (state == 1) {
#line 195
      goto case_1;
    }
#line 196
    if (state == 2) {
#line 196
      goto case_2;
    }
#line 197
    if (state == 3) {
#line 197
      goto case_3;
    }
#line 192
    goto switch_break;
    case_0: /* CIL Label */ 
#line 194
    if ((int )*p >= 48) {
#line 194
      if ((int )*p <= 57) {
#line 194
        ip = p;
#line 194
        state ++;
      }
    }
#line 194
    goto switch_break;
    case_1: /* CIL Label */ 
#line 195
    if (32 == (int )*p) {
      {
#line 195
      ident = atoi((char const   *)ip);
#line 195
      state ++;
      }
    }
#line 195
    goto switch_break;
    case_2: /* CIL Label */ 
#line 196
    if (32 != (int )*p) {
#line 196
      gr = p;
#line 196
      state ++;
    }
#line 196
    goto switch_break;
    case_3: /* CIL Label */ 
#line 198
    if (10 != (int )*p) {
#line 199
      goto switch_break;
    }
    {
#line 200
    tmp___1 = add___1(ident, gr, (int )(p - gr));
    }
#line 200
    if (-1 == tmp___1) {
      {
#line 202
      log_((char *)"reload:no memory");
      }
#line 203
      return (-1);
    }
#line 205
    state = 0;
    switch_break: /* CIL Label */ ;
    }
#line 191
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 208
  oldsize___0 = newsize;
#line 209
  return (0);
}
}
#line 26 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/body.c"
static char *bodbuf___0  =    (char *)((void *)0);
#line 78 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/allocate.c"
static struct table___1 table___1  =    {(char *)0, (char *)0, 0, 0, 0, 0};
#line 80
static int remapfile___0(void) ;
#line 106 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/allocate.c"
static int initfile___2(char *filename ) 
{ 
  struct chainfile cf ;
  int fd ;
  int i ;
  int ret ;
  ssize_t tmp ;
  int pad ;
  ssize_t tmp___0 ;

  {
  {
#line 108
  cf.chain_magic = 0;
#line 108
  cf.next[0] = 0;
#line 108
  cf.next[1] = 0;
#line 108
  cf.next[2] = 0;
#line 108
  cf.next[3] = 0;
#line 108
  cf.next[4] = 0;
#line 108
  cf.next[5] = 0;
#line 108
  cf.next[6] = 0;
#line 108
  cf.next[7] = 0;
#line 108
  cf.next[8] = 0;
#line 108
  cf.next[9] = 0;
#line 108
  cf.next[10] = 0;
#line 108
  cf.next[11] = 0;
#line 108
  cf.next[12] = 0;
#line 108
  cf.next[13] = 0;
#line 108
  cf.next[14] = 0;
#line 108
  cf.next[15] = 0;
#line 108
  cf.next[16] = 0;
#line 108
  cf.next[17] = 0;
#line 108
  cf.next[18] = 0;
#line 108
  cf.next[19] = 0;
#line 108
  cf.next[20] = 0;
#line 108
  cf.next[21] = 0;
#line 108
  cf.next[22] = 0;
#line 108
  cf.next[23] = 0;
#line 108
  cf.next[24] = 0;
#line 108
  cf.next[25] = 0;
#line 108
  cf.next[26] = 0;
#line 108
  cf.next[27] = 0;
#line 108
  cf.next[28] = 0;
#line 108
  cf.next[29] = 0;
#line 108
  cf.next[30] = 0;
#line 108
  cf.next[31] = 0;
#line 108
  cf.next[32] = 0;
#line 108
  cf.next[33] = 0;
#line 108
  cf.next[34] = 0;
#line 108
  cf.next[35] = 0;
#line 108
  cf.next[36] = 0;
#line 108
  cf.next[37] = 0;
#line 108
  cf.next[38] = 0;
#line 108
  cf.next[39] = 0;
#line 108
  cf.next[40] = 0;
#line 108
  cf.next[41] = 0;
#line 108
  cf.next[42] = 0;
#line 108
  cf.next[43] = 0;
#line 108
  cf.next[44] = 0;
#line 108
  cf.next[45] = 0;
#line 108
  cf.next[46] = 0;
#line 108
  cf.next[47] = 0;
#line 108
  cf.next[48] = 0;
#line 108
  cf.next[49] = 0;
#line 108
  cf.next[50] = 0;
#line 108
  cf.next[51] = 0;
#line 108
  cf.next[52] = 0;
#line 108
  cf.next[53] = 0;
#line 108
  cf.next[54] = 0;
#line 108
  cf.next[55] = 0;
#line 108
  cf.next[56] = 0;
#line 108
  cf.next[57] = 0;
#line 108
  cf.next[58] = 0;
#line 108
  cf.next[59] = 0;
#line 108
  cf.next[60] = 0;
#line 108
  cf.next[61] = 0;
#line 108
  cf.next[62] = 0;
#line 111
  ret = 0;
#line 113
  fd = open((char const   *)filename, 578, 420);
  }
#line 114
  if (-1 == fd) {
#line 115
    return (-1);
  }
#line 116
  cf.chain_magic = 13680336;
#line 117
  i = 0;
  {
#line 117
  while (1) {
    while_continue: /* CIL Label */ ;
#line 117
    if (! (i < 63)) {
#line 117
      goto while_break;
    }
#line 118
    cf.next[i] = (int volatile   )0;
#line 117
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 119
  tmp = write(fd, (void const   *)(& cf), sizeof(cf));
#line 119
  i = (int )tmp;
  }
#line 120
  if ((unsigned long )i == sizeof(cf)) {
#line 124
    pad = (int )(sizeof(cf) % 4UL);
#line 125
    if (pad > 0) {
#line 126
      i = 0;
      {
#line 126
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 126
        if (i < pad) {
#line 126
          if (! (0 == ret)) {
#line 126
            goto while_break___0;
          }
        } else {
#line 126
          goto while_break___0;
        }
        {
#line 127
        tmp___0 = write(fd, (void const   *)"", (size_t )1);
        }
#line 127
        if (1L != tmp___0) {
#line 128
          ret = -1;
        }
#line 126
        i ++;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
  } else {
#line 131
    ret = -1;
  }
  {
#line 132
  close(fd);
  }
#line 133
  return (ret);
}
}
#line 136 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/allocate.c"
static void unmapfile___0(void) 
{ 


  {
#line 138
  if (table___1.fd >= 0) {
    {
#line 140
    close(table___1.fd);
#line 141
    table___1.fd = -1;
    }
  }
#line 143
  if (table___1.map) {
    {
#line 145
    munmap((void *)table___1.map, (size_t )table___1.size);
#line 146
    table___1.map = (char *)((void *)0);
#line 147
    table___1.size = 0;
    }
  }
#line 149
  return;
}
}
#line 153
static size_t rounduptopagesize___0(size_t size___1 ) ;
#line 153 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/allocate.c"
static size_t pagesize___3  =    (size_t )0;
#line 151 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/allocate.c"
static size_t rounduptopagesize___0(size_t size___1 ) 
{ 
  int pages ;
  int tmp ;

  {
#line 156
  if (0UL == pagesize___3) {
    {
#line 157
    tmp = getpagesize();
#line 157
    pagesize___3 = (size_t )tmp;
    }
  }
#line 158
  pages = (int )(size___1 / pagesize___3 + 1UL);
#line 159
  return ((size_t )pages * pagesize___3);
}
}
#line 162 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/allocate.c"
static int mapfile___0(void) 
{ 
  struct stat st ;
  int tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;

  {
#line 166
  if (-1 == table___1.fd) {
    {
#line 167
    table___1.fd = open((char const   *)table___1.filename, table___1.oflag, 420);
    }
  }
#line 168
  if (-1 == table___1.fd) {
#line 169
    goto fail;
  }
  {
#line 171
  tmp = fstat(table___1.fd, & st);
  }
#line 171
  if (-1 == tmp) {
#line 172
    goto fail;
  }
  {
#line 173
  tmp___0 = rounduptopagesize___0((size_t )st.st_size);
#line 173
  table___1.size = (int )tmp___0;
#line 174
  tmp___1 = mmap((void *)0, (size_t )table___1.size, table___1.mprot, 1, table___1.fd,
                 (__off_t )0);
#line 174
  table___1.map = (char *)tmp___1;
  }
#line 175
  if (! table___1.map) {
#line 176
    goto fail;
  } else
#line 175
  if ((unsigned long )table___1.map == (unsigned long )((void *)-1)) {
#line 176
    goto fail;
  }
#line 178
  return (0);
  fail: 
  {
#line 181
  unmapfile___0();
  }
#line 182
  return (-1);
}
}
#line 189 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/allocate.c"
static int remapfile___0(void) 
{ 
  struct stat st ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 193
  tmp = fstat(table___1.fd, & st);
  }
#line 193
  if (-1 == tmp) {
#line 194
    return (-1);
  }
#line 196
  if (st.st_size <= (__off_t )table___1.size) {
#line 197
    return (0);
  }
  {
#line 199
  munmap((void *)table___1.map, (size_t )table___1.size);
#line 200
  tmp___0 = mapfile___0();
  }
#line 200
  return (tmp___0);
}
}
#line 209 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/allocate.c"
static int lock___0(void) 
{ 
  int *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 211
  tmp___2 = lockf(table___1.fd, 2, (__off_t )0);
  }
#line 211
  if (-1 == tmp___2) {
    {
#line 213
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 215
      tmp = __errno_location();
      }
#line 215
      if (11 != *tmp) {
#line 216
        return (-1);
      } else {
        {
#line 218
        nap(0, 200);
        }
      }
      {
#line 213
      tmp___0 = lockf(table___1.fd, 2, (__off_t )0);
      }
#line 213
      if (! (-1 == tmp___0)) {
#line 213
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 221
    tmp___1 = remapfile___0();
    }
#line 221
    if (-1 == tmp___1) {
#line 222
      return (-1);
    }
  }
#line 224
  return (0);
}
}
#line 227 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/allocate.c"
static void unlock___0(void) 
{ 


  {
  {
#line 229
  lseek(table___1.fd, (__off_t )0, 0);
#line 230
  lockf(table___1.fd, 0, (__off_t )0);
  }
#line 231
  return;
}
}
#line 233 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/allocate.c"
static int checkvalidfile___0(void) 
{ 


  {
#line 235
  if (table___1.size > 0) {
#line 237
    if ((unsigned long )table___1.size < sizeof(struct chainfile )) {
#line 238
      return (-1);
    }
#line 239
    if (((struct chainfile *)table___1.map)->chain_magic != 13680336) {
#line 240
      return (-1);
    }
  }
#line 242
  return (0);
}
}
#line 281 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/allocate.c"
static int rounduptoalignment___0(int size___1 ) 
{ 


  {
#line 283
  if (size___1 <= 0) {
#line 284
    return (4);
  }
#line 285
  return (((size___1 - 1) / 4 + 1) * 4);
}
}
#line 296 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/allocate.c"
static char tmpchunk___0[272]  = {      (char )'\000'};
#line 33 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/art.c"
static size_t pagesize___4  =    (size_t )0;
#line 80 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/art.c"
static void file_unmap___0(void *p ) 
{ 
  struct fileobj *fp ;

  {
  {
#line 82
  fp = (struct fileobj *)p;
#line 84
  munmap((void *)fp->map, (size_t )fp->size);
#line 85
  free((void *)fp);
  }
#line 86
  return;
}
}
#line 88 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/art.c"
static int file_cmp___0(void *a , void *b___13 ) 
{ 
  struct fileobj *x ;
  struct fileobj *y ;
  int tmp ;

  {
  {
#line 90
  x = (struct fileobj *)a;
#line 91
  y = (struct fileobj *)b___13;
#line 93
  tmp = strcmp((char const   *)x->path, (char const   *)y->path);
  }
#line 93
  return (tmp);
}
}
#line 96 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/art.c"
static int desc___2  =    -1;
#line 98 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/art.c"
static int file_init___0(void) 
{ 


  {
  {
#line 100
  desc___2 = cache_init(8, & file_cmp___0, & file_unmap___0, (int (*)(void * ))((void *)0));
  }
#line 101
  if (-1 == desc___2) {
    {
#line 103
    log_((char *)"file_init:%m");
    }
#line 104
    return (-1);
  }
#line 106
  return (0);
}
}
#line 109 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/art.c"
static struct file *file_gimme___0(char *name , int *size___1 ) 
{ 
  struct fileobj f___9 ;
  struct fileobj *fp ;
  void *tmp ;

  {
  {
#line 111
  f___9.path = (char *)0;
#line 111
  f___9.map = (char *)0;
#line 111
  f___9.size = 0;
#line 114
  f___9.path = name;
#line 116
  tmp = cache_find(desc___2, (void *)(& f___9));
#line 116
  fp = (struct fileobj *)tmp;
  }
#line 116
  if ((unsigned long )((void *)0) == (unsigned long )fp) {
    {
#line 118
    fp = file_map(name);
    }
#line 118
    if ((unsigned long )((void *)0) == (unsigned long )fp) {
#line 119
      return ((struct file *)((void *)0));
    } else {
      {
#line 121
      cache_insert(desc___2, (void *)fp);
      }
    }
  }
#line 124
  if (size___1) {
#line 125
    *size___1 = fp->size;
  }
#line 126
  return ((struct file *)fp->map);
}
}
#line 137 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/art.c"
static bool file_initialized___0  =    (bool )0;
#line 248 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/art.c"
static char ngroup___0[287]  ;
#line 297 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/art.c"
static int getfield___0(char *buf___28 , struct field *f___9 ) 
{ 
  register char *cp ;
  size_t tmp ;
  size_t tmp___0 ;

  {
  {
#line 299
  cp = buf___28;
#line 301
  tmp = strspn((char const   *)cp, " \t\f");
#line 301
  cp += tmp;
  }
#line 302
  if (! *cp) {
#line 304
    f___9->pointer = (char *)((void *)0);
#line 305
    return (0);
  }
  {
#line 307
  tmp___0 = strcspn((char const   *)cp, "\r\n");
#line 307
  f___9->len = (int )tmp___0;
  }
#line 308
  if (! f___9->len) {
#line 309
    return (0);
  }
#line 310
  f___9->pointer = cp;
#line 311
  return ((int )((cp + f___9->len) - buf___28));
}
}
#line 383 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/art.c"
static struct b b___0  =    {(char *)0, 0, 0};
#line 417 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) pipe)(int *__pipedes ) ;
#line 563
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) execv)(char const   *__path ,
                                                                                              char * const  *__argv ) ;
#line 578
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) execvp)(char const   *__file ,
                                                                                               char * const  *__argv ) ;
#line 756
extern  __attribute__((__nothrow__)) __pid_t fork(void) ;
#line 137 "/usr/include/fcntl.h"
extern int fcntl(int __fd , int __cmd  , ...) ;
#line 534 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcasecmp)(char const   *__s1 ,
                                                                                                   char const   *__s2 )  __attribute__((__pure__)) ;
#line 113 "/usr/include/x86_64-linux-gnu/sys/socket.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) socket)(int __domain ,
                                                                             int __type ,
                                                                             int __protocol ) ;
#line 137
extern int connect(int __fd , struct sockaddr  const  *__addr , socklen_t __len ) ;
#line 374 "/usr/include/netinet/in.h"
extern  __attribute__((__nothrow__)) uint32_t ( __attribute__((__leaf__)) ntohl)(uint32_t __netlong )  __attribute__((__const__)) ;
#line 379
extern  __attribute__((__nothrow__)) uint16_t ( __attribute__((__leaf__)) htons)(uint16_t __hostshort )  __attribute__((__const__)) ;
#line 127 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) kill)(__pid_t __pid ,
                                                                           int __sig ) ;
#line 215
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) sigemptyset)(sigset_t *__set ) ;
#line 259
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) sigaction)(int __sig ,
                                                                                struct sigaction  const  * __restrict  __act ,
                                                                                struct sigaction * __restrict  __oact ) ;
#line 125 "/usr/include/x86_64-linux-gnu/sys/wait.h"
extern __pid_t waitpid(__pid_t __pid , int *__stat_loc , int __options ) ;
#line 17 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/get.h"
bool optnocache ;
#line 19 "./lib/cmdopen.h"
int cmdopen(char **command , int *read___0 , int *write___0 ) ;
#line 55 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/get.c"
char *optdebug  =    (char *)((void *)0);
#line 56 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/get.c"
char *optpipelining  =    (char *)((void *)0);
#line 57 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/get.c"
char *optmax  =    (char *)((void *)0);
#line 58 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/get.c"
bool optlogpid  =    (bool )0;
#line 59 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/get.c"
bool optnocache  =    (bool )0;
#line 60 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/get.c"
int throttlerate  =    0;
#line 61 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/get.c"
int concurrency  =    4;
#line 65 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/get.c"
static char path1[(255UL + sizeof("/.serial.tmp")) + 1UL]  ;
#line 66 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/get.c"
static char path2[(255UL + sizeof("/.serial.tmp")) + 1UL]  ;
#line 68 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/get.c"
static char *argv_snstore[4]  = {      (char *)"snstore"};
#line 69 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/get.c"
static int argc_snstore  ;
#line 70 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/get.c"
static char *argv_snfetch[14]  = {      (char *)"snfetch"};
#line 71 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/get.c"
static int argc_snfetch  ;
#line 76 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/get.c"
static int atou(char *buf___28 ) 
{ 
  int i ;
  int c ;

  {
#line 80
  i = 0;
  {
#line 80
  while (1) {
    while_continue: /* CIL Label */ ;
#line 80
    if (! *buf___28) {
#line 80
      goto while_break;
    }
#line 82
    c = (int )*buf___28 - 48;
#line 83
    if (c > 9) {
#line 84
      return (-1);
    } else
#line 83
    if (c < 0) {
#line 84
      return (-1);
    }
#line 85
    i *= 10;
#line 86
    i += c;
#line 80
    buf___28 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 88
  return (i);
}
}
#line 96 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/get.c"
static int stores[8]  ;
#line 97 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/get.c"
static int nstores  =    0;
#line 99 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/get.c"
static int store_get(void) 
{ 
  int pid___0 ;

  {
#line 101
  if (! nstores) {
    {
#line 105
    pid___0 = cmdopen(argv_snstore, (int *)0, stores);
    }
#line 106
    if (pid___0 <= 0) {
#line 108
      if (-19 == pid___0) {
        {
#line 109
        log_((char *)"store_get:exec snstore:PATH set?");
        }
      } else
#line 110
      if (-1 == pid___0) {
        {
#line 111
        log_((char *)"store_get:exec snstore:%m?");
        }
      } else {
        {
#line 113
        log_((char *)"store_get:snstore exited with %d", 0 - pid___0);
        }
      }
#line 114
      return (-1);
    }
    {
#line 116
    fcntl(stores[0], 2, 1);
#line 117
    nstores ++;
    }
#line 118
    if (debug >= 3) {
      {
#line 118
      log_((char *)"pipe %d is snstore pid %d", stores[0], pid___0);
      }
    }
  }
#line 120
  nstores --;
#line 120
  return (stores[nstores]);
}
}
#line 123 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/get.c"
static void store_put(int fd ) 
{ 
  int tmp ;

  {
#line 125
  if (nstores < 8) {
#line 126
    tmp = nstores;
#line 126
    nstores ++;
#line 126
    stores[tmp] = fd;
  } else {
    {
#line 128
    close(fd);
    }
  }
#line 129
  return;
}
}
#line 143 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/get.c"
static struct sock socks[8]  ;
#line 144 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/get.c"
static int nsocks  =    0;
#line 146 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/get.c"
static int sock_get(char *server , int port , unsigned long *addrp , int *reused ) 
{ 
  int i ;
  int sd ;
  int tmp ;
  struct hostent *hp ;
  struct sockaddr_in sa ;
  int fl ;
  uint32_t tmp___0 ;
  int *tmp___1 ;

  {
#line 150
  i = 0;
  {
#line 150
  while (1) {
    while_continue: /* CIL Label */ ;
#line 150
    if (! (i < nsocks)) {
#line 150
      goto while_break;
    }
#line 151
    if (port == (int )socks[i].port) {
      {
#line 152
      tmp = strcasecmp((char const   *)server, (char const   *)socks[i].server);
      }
#line 152
      if (0 == tmp) {
#line 154
        *reused = 1;
#line 155
        sd = (int )socks[i].sd;
#line 156
        *addrp = socks[i].addr;
#line 157
        nsocks --;
#line 158
        if (i != nsocks) {
#line 159
          socks[i] = socks[nsocks];
        }
#line 160
        return (sd);
      }
    }
#line 150
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 165
  *reused = 0;
#line 166
  sd = socket(2, 1, 0);
  }
#line 166
  if (sd > -1) {
    {
#line 170
    hp = gethostbyname((char const   *)server);
    }
#line 170
    if (hp) {
      {
#line 175
      sa.sin_family = (sa_family_t )2;
#line 176
      sa.sin_port = htons((uint16_t )port);
#line 177
      sa.sin_addr.s_addr = (in_addr_t )*((unsigned long *)*(hp->h_addr_list + 0));
#line 178
      tmp___0 = ntohl(sa.sin_addr.s_addr);
#line 178
      *addrp = (unsigned long )tmp___0;
#line 179
      fl = fcntl(sd, 3);
#line 180
      fcntl(sd, 4, fl | 2048);
#line 181
      i = connect(sd, (struct sockaddr  const  *)((struct sockaddr *)(& sa)), (socklen_t )sizeof(sa));
      }
#line 182
      if (i > -1) {
        {
#line 184
        fcntl(sd, 4, fl);
#line 185
        fcntl(sd, 2, 1);
        }
#line 186
        return (sd);
      } else {
        {
#line 182
        tmp___1 = __errno_location();
        }
#line 182
        if (115 == *tmp___1) {
          {
#line 184
          fcntl(sd, 4, fl);
#line 185
          fcntl(sd, 2, 1);
          }
#line 186
          return (sd);
        } else {
          {
#line 189
          log_((char *)"sock_get:connect to %s:%m?", server);
          }
        }
      }
    } else {
      {
#line 192
      log_((char *)"sock_get:resolve \"%s\"", server);
      }
    }
    {
#line 193
    close(sd);
    }
  } else {
    {
#line 196
    log_((char *)"sock_get:socket to %s:%m", server);
    }
  }
#line 197
  return (-1);
}
}
#line 200 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/get.c"
static void sock_put(int sd , char *server , unsigned long addr , int port ) 
{ 


  {
#line 202
  if (nsocks < 8) {
#line 204
    socks[nsocks].sd = (unsigned short )sd;
#line 205
    socks[nsocks].server = server;
#line 206
    socks[nsocks].port = (unsigned short )port;
#line 207
    socks[nsocks].addr = addr;
#line 208
    nsocks ++;
  } else {
    {
#line 211
    close(sd);
    }
  }
#line 212
  return;
}
}
#line 224 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/get.c"
static struct job **queue  =    (struct job **)((void *)0);
#line 225 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/get.c"
static int toff  =    0;
#line 226 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/get.c"
static int tend  =    0;
#line 227 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/get.c"
static int qsize  ;
#line 229 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/get.c"
static int queue_add(struct job *jp ) 
{ 
  struct job **tmp ;
  int newsize ;
  void *tmp___0 ;
  int tmp___1 ;

  {
#line 231
  if (tend >= qsize) {
#line 236
    if (queue) {
#line 236
      newsize = qsize * 2;
    } else {
#line 236
      newsize = 20;
    }
    {
#line 237
    tmp___0 = malloc((unsigned long )newsize * sizeof(struct job *));
#line 237
    tmp = (struct job **)tmp___0;
    }
#line 237
    if (! tmp) {
#line 238
      return (-1);
    }
#line 239
    if (queue) {
      {
#line 241
      memcpy((void */* __restrict  */)tmp, (void const   */* __restrict  */)queue,
             (unsigned long )qsize * sizeof(struct job *));
#line 242
      free((void *)queue);
      }
    }
#line 244
    queue = tmp;
#line 245
    qsize = newsize;
  }
#line 247
  tmp___1 = tend;
#line 247
  tend ++;
#line 247
  *(queue + tmp___1) = jp;
#line 248
  return (0);
}
}
#line 251 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/get.c"
static void swap(int a , int b___13 ) 
{ 
  struct job *tmp ;

  {
#line 255
  if (a == b___13) {
#line 256
    return;
  }
#line 257
  tmp = *(queue + a);
#line 258
  *(queue + a) = *(queue + b___13);
#line 259
  *(queue + b___13) = tmp;
#line 260
  return;
}
}
#line 262 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/get.c"
static void queue_todo2run(int j ) 
{ 
  int tmp ;

  {
  {
#line 262
  tmp = toff;
#line 262
  toff ++;
#line 262
  swap(tmp, j);
  }
#line 262
  return;
}
}
#line 263 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/get.c"
static void queue_run2todo(int j ) 
{ 


  {
  {
#line 263
  toff --;
#line 263
  swap(toff, j);
  }
#line 263
  return;
}
}
#line 265 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/get.c"
static void queue_rm(int j ) 
{ 


  {
#line 268
  if (j < toff) {
    {
#line 270
    queue_run2todo(j);
#line 271
    j = toff;
    }
  }
  {
#line 273
  tend --;
#line 273
  swap(j, tend);
#line 274
  free((void *)*(queue + tend));
  }
#line 275
  return;
}
}
#line 277 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/get.c"
static int similarity(char *g1 , char *g2 ) 
{ 
  char *c1 ;
  int inc1 ;
  char *c2 ;
  int inc2 ;
  int score ;
  char *tmp ;
  char *tmp___0 ;

  {
#line 285
  score = 0;
#line 286
  inc1 = 7;
  {
#line 286
  while (1) {
    while_continue: /* CIL Label */ ;
#line 286
    if (inc1) {
#line 286
      if (! *g1) {
#line 286
        goto while_break;
      }
    } else {
#line 286
      goto while_break;
    }
#line 288
    inc2 = 7;
#line 289
    c2 = g2;
    {
#line 289
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 289
      if (inc2) {
#line 289
        if (! *c2) {
#line 289
          goto while_break___0;
        }
      } else {
#line 289
        goto while_break___0;
      }
#line 292
      c1 = g1;
      {
#line 292
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 292
        if ((int )*c1 == (int )*c2) {
#line 292
          if (*c1) {
#line 292
            if (! (46 != (int )*c1)) {
#line 292
              goto while_break___1;
            }
          } else {
#line 292
            goto while_break___1;
          }
        } else {
#line 292
          goto while_break___1;
        }
#line 293
        score ++;
#line 292
        c1 ++;
#line 292
        c2 ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 294
      if ((int )*c1 == (int )*c2) {
#line 295
        score += inc1 + inc2;
      }
      {
#line 297
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 298
        if (! *c2) {
#line 299
          goto while_break___2;
        }
#line 297
        tmp = c2;
#line 297
        c2 ++;
#line 297
        if (! (46 != (int )*tmp)) {
#line 297
          goto while_break___2;
        }
      }
      while_break___2: /* CIL Label */ ;
      }
#line 289
      inc2 --;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 302
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 303
      if (! *g1) {
#line 304
        goto while_break___3;
      }
#line 302
      tmp___0 = g1;
#line 302
      g1 ++;
#line 302
      if (! (46 != (int )*tmp___0)) {
#line 302
        goto while_break___3;
      }
    }
    while_break___3: /* CIL Label */ ;
    }
#line 286
    inc1 --;
  }
  while_break: /* CIL Label */ ;
  }
#line 307
  return (score);
}
}
#line 314 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/get.c"
static int queue_getnext(void) 
{ 
  int max ;
  int bestscore ;
  int bestgroup ;
  int t ;
  int r ;
  int score ;
  int tmp ;

  {
#line 320
  max = tend - toff;
  {
#line 322
  if (max == 0) {
#line 322
    goto case_0;
  }
#line 324
  if (max == 1) {
#line 324
    goto case_1;
  }
#line 330
  if (max == 4) {
#line 330
    goto case_4;
  }
#line 330
  if (max == 3) {
#line 330
    goto case_4;
  }
#line 330
  if (max == 2) {
#line 330
    goto case_4;
  }
#line 326
  goto switch_default;
  case_0: /* CIL Label */ 
#line 323
  return (-1);
  case_1: /* CIL Label */ 
#line 325
  return (toff);
  switch_default: /* CIL Label */ 
#line 327
  max = 4;
  case_4: /* CIL Label */ 
  case_3: /* CIL Label */ 
  case_2: /* CIL Label */ ;
  switch_break: /* CIL Label */ ;
  }
#line 333
  bestscore = 10000;
#line 334
  bestgroup = toff;
#line 335
  t = toff;
  {
#line 335
  while (1) {
    while_continue: /* CIL Label */ ;
#line 335
    if (! (t < toff + max)) {
#line 335
      goto while_break;
    }
#line 339
    score = 0;
#line 340
    r = 0;
    {
#line 340
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 340
      if (! (r < toff)) {
#line 340
        goto while_break___0;
      }
      {
#line 341
      tmp = similarity((*(queue + r))->group, (*(queue + t))->group);
#line 341
      score += tmp;
#line 340
      r ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 342
    if (score < bestscore) {
#line 344
      bestscore = score;
#line 345
      bestgroup = t;
    }
#line 335
    t ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 348
  return (bestgroup);
}
}
#line 356 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/get.c"
int throttle_setfds(fd_set *rs ) 
{ 
  int max ;
  int i ;

  {
#line 360
  max = -1;
#line 361
  i = 0;
  {
#line 361
  while (1) {
    while_continue: /* CIL Label */ ;
#line 361
    if (! (i < toff)) {
#line 361
      goto while_break;
    }
#line 362
    if ((*(queue + i))->infd > -1) {
#line 364
      rs->__fds_bits[(*(queue + i))->sd / (8 * (int )sizeof(__fd_mask ))] |= 1L << (*(queue + i))->sd % (8 * (int )sizeof(__fd_mask ));
#line 365
      if ((*(queue + i))->sd > max) {
#line 366
        max = (*(queue + i))->sd;
      }
    }
#line 361
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 368
  return (max);
}
}
#line 378 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/get.c"
static struct timeval last  =    {(__time_t )0, 0L};
#line 380 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/get.c"
static int bytes  =    0;
#line 376 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/get.c"
void throttle(fd_set *rs ) 
{ 
  char buf___28[300] ;
  int i ;
  int c ;
  struct timeval tv ;
  long sec ;
  long msec ;
  long usec ;
  ssize_t tmp ;
  ssize_t tmp___0 ;

  {
#line 385
  if (bytes > 0) {
    {
#line 390
    gettimeofday((struct timeval */* __restrict  */)(& tv), (__timezone_ptr_t )0);
#line 391
    sec = tv.tv_sec - last.tv_sec;
#line 392
    usec = tv.tv_usec - last.tv_usec;
    }
#line 393
    if (usec < 0L) {
#line 395
      usec += 1000000L;
#line 396
      sec --;
    }
#line 398
    msec = (long )((bytes * 1000) / throttlerate);
#line 399
    if (msec > 0L) {
#line 401
      sec = msec / 1000L - sec;
#line 402
      usec = (msec % 1000L) * 1000L - usec;
#line 403
      if (usec < 0L) {
#line 405
        usec += 1000000L;
#line 406
        sec --;
      }
#line 408
      tv.tv_sec = sec;
#line 409
      tv.tv_usec = usec;
#line 410
      if (sec >= 0L) {
        {
#line 411
        select(0, (fd_set */* __restrict  */)((void *)0), (fd_set */* __restrict  */)((void *)0),
               (fd_set */* __restrict  */)((void *)0), (struct timeval */* __restrict  */)(& tv));
        }
      }
    }
#line 413
    bytes = 0;
  }
#line 416
  bytes = 0;
#line 417
  i = 0;
  {
#line 417
  while (1) {
    while_continue: /* CIL Label */ ;
#line 417
    if (! (i < toff)) {
#line 417
      goto while_break;
    }
#line 418
    if ((*(queue + i))->infd > -1) {
#line 418
      if ((rs->__fds_bits[(*(queue + i))->sd / (8 * (int )sizeof(__fd_mask ))] & (1L << (*(queue + i))->sd % (8 * (int )sizeof(__fd_mask )))) != 0L) {
        {
#line 420
        tmp___0 = read((*(queue + i))->sd, (void *)(buf___28), sizeof(buf___28));
#line 420
        c = (int )tmp___0;
        }
#line 420
        if (c > 0) {
          {
#line 422
          tmp = write((*(queue + i))->infd, (void const   *)(buf___28), (size_t )c);
          }
#line 422
          if (-1L == tmp) {
            {
#line 424
            log_((char *)"throttle:pipe to %s:%m", (*(queue + i))->group);
#line 425
            close((*(queue + i))->infd);
#line 426
            (*(queue + i))->infd = -1;
            }
          } else {
#line 429
            bytes += c;
          }
        }
      }
    }
#line 417
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 432
  gettimeofday((struct timeval */* __restrict  */)(& last), (__timezone_ptr_t )0);
  }
#line 433
  return;
}
}
#line 439 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/get.c"
static void readfile(char *dir , char *fn , char *buf___28 ) 
{ 
  int fd ;
  int c ;
  int i ;
  ssize_t tmp ;
  int *tmp___0 ;

  {
  {
#line 443
  formats(path1, (int )(sizeof(path1) - 1UL), (char *)"%s/%s", dir, fn);
#line 444
  fd = open((char const   *)(path1), 0);
  }
#line 444
  if (fd > -1) {
    {
#line 446
    tmp = read(fd, (void *)buf___28, (size_t )19);
#line 446
    c = (int )tmp;
#line 447
    close(fd);
    }
#line 448
    if (c > 0) {
#line 450
      *(buf___28 + c) = (char )'\000';
#line 451
      i = 0;
      {
#line 451
      while (1) {
        while_continue: /* CIL Label */ ;
#line 451
        if (! (i < c)) {
#line 451
          goto while_break;
        }
#line 453
        if (10 == (int )*(buf___28 + i)) {
#line 455
          *(buf___28 + i) = (char )'\000';
#line 456
          goto while_break;
        }
#line 458
        if ((int )*(buf___28 + i) < 48) {
          {
#line 460
          log_((char *)"readfile:bad value in %s/%s", dir, fn);
#line 461
          *buf___28 = (char )'\000';
          }
#line 462
          return;
        } else
#line 458
        if ((int )*(buf___28 + i) > 57) {
          {
#line 460
          log_((char *)"readfile:bad value in %s/%s", dir, fn);
#line 461
          *buf___28 = (char )'\000';
          }
#line 462
          return;
        }
#line 451
        i ++;
      }
      while_break: /* CIL Label */ ;
      }
#line 465
      return;
    } else {
      {
#line 468
      log_((char *)"readfile:read %s:%m", path1);
      }
    }
  } else {
    {
#line 470
    tmp___0 = __errno_location();
    }
#line 470
    if (2 != *tmp___0) {
      {
#line 471
      log_((char *)"readfile:open %s:%m", path1);
      }
    }
  }
#line 472
  *buf___28 = (char )'\000';
#line 473
  return;
}
}
#line 475 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/get.c"
int reap(void) 
{ 
  int pid___0 ;
  int ex ;
  int j ;
  struct job *jp ;
  union __anonunion_56 __constr_expr_0 ;
  union __anonunion_57 __constr_expr_1 ;
  union __anonunion_58 __constr_expr_2 ;
  union __anonunion_59 __constr_expr_3 ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  int tmp___3 ;

  {
#line 480
  if (toff <= 0) {
#line 481
    return (1);
  } else {
    {
#line 480
    pid___0 = waitpid(-1, & ex, 1);
    }
#line 480
    if (pid___0 <= 0) {
#line 481
      return (1);
    }
  }
#line 483
  j = toff - 1;
  {
#line 483
  while (1) {
    while_continue: /* CIL Label */ ;
#line 483
    if (j > -1) {
#line 483
      if (! (pid___0 != (*(queue + j))->pid)) {
#line 483
        goto while_break;
      }
    } else {
#line 483
      goto while_break;
    }
#line 483
    j --;
  }
  while_break: /* CIL Label */ ;
  }
#line 484
  if (-1 == j) {
#line 485
    return (1);
  }
#line 487
  jp = *(queue + j);
#line 488
  __constr_expr_3.__in = ex;
#line 488
  if ((__constr_expr_3.__i & 127) == 0) {
#line 490
    __constr_expr_0.__in = ex;
#line 490
    ex = (__constr_expr_0.__i & 65280) >> 8;
#line 490
    if (ex) {
      {
#line 491
      log_((char *)"reap:job %s exited %d", jp->group, ex);
      }
    }
  } else {
#line 493
    __constr_expr_2.__in = ex;
#line 493
    if ((int )((signed char )((__constr_expr_2.__i & 127) + 1)) >> 1 > 0) {
      {
#line 495
      __constr_expr_1.__in = ex;
#line 495
      ex = __constr_expr_1.__i & 127;
#line 495
      log_((char *)"reap:job %s caught signal %d", jp->group, ex);
#line 496
      ex = 0 - ex;
      }
    } else {
#line 501
      return (1);
    }
  }
#line 510
  if (ex) {
    {
#line 511
    close(jp->sd);
    }
  } else
#line 510
  if (optnocache) {
    {
#line 511
    close(jp->sd);
    }
  } else {
    {
#line 513
    sock_put(jp->sd, jp->server, jp->addr, (int )jp->port);
    }
  }
#line 514
  if (2 == ex) {
    {
#line 515
    close(jp->outfd);
    }
  } else
#line 514
  if (ex < 0) {
    {
#line 515
    close(jp->outfd);
    }
  } else
#line 514
  if (optnocache) {
    {
#line 515
    close(jp->outfd);
    }
  } else {
    {
#line 517
    store_put(jp->outfd);
    }
  }
#line 518
  if (jp->infd > -1) {
    {
#line 519
    close(jp->infd);
    }
  }
#line 521
  if (ex) {
#line 521
    if (jp->attempts <= 2) {
      {
#line 523
      tmp___1 = -1;
#line 523
      jp->pid = tmp___1;
#line 523
      tmp___0 = tmp___1;
#line 523
      jp->outfd = tmp___0;
#line 523
      tmp = tmp___0;
#line 523
      jp->sd = tmp;
#line 523
      jp->infd = tmp;
#line 524
      queue_run2todo(j);
      }
#line 525
      return (1);
    }
  }
#line 527
  if (0 == ex) {
    {
#line 529
    formats(path1, (int )(sizeof(path1) - 1UL), (char *)"%s/.serial.tmp", jp->group);
#line 530
    formats(path2, (int )(sizeof(path2) - 1UL), (char *)"%s/.serial", jp->group);
#line 531
    tmp___3 = rename((char const   *)(path1), (char const   *)(path2));
    }
#line 531
    if (-1 == tmp___3) {
      {
#line 532
      tmp___2 = __errno_location();
      }
#line 532
      if (2 != *tmp___2) {
        {
#line 533
        log_((char *)"reap:rename %s, %s:%m", path1, path2);
        }
      }
    }
  } else {
    {
#line 536
    log_((char *)"reap:Giving up on %s", jp->group);
    }
  }
  {
#line 537
  queue_rm(j);
  }
#line 538
  return (0);
}
}
#line 541 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/get.c"
bool sigchld  =    (bool )0;
#line 543 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/get.c"
static void chldhand(int x ) 
{ 


  {
#line 543
  sigchld = (bool )1;
#line 543
  return;
}
}
#line 545 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/get.c"
bool sigusr  =    (bool )0;
#line 547 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/get.c"
static void usrhand(int u ) 
{ 


  {
#line 549
  sigusr = (bool )1;
#line 550
  if (10 == u) {
#line 552
    if (throttlerate > 1) {
#line 553
      throttlerate /= 2;
    }
  } else
#line 555
  if (12 == u) {
#line 556
    throttlerate *= 2;
  }
#line 557
  return;
}
}
#line 561 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/get.c"
static void fixfd(int from , int to ) 
{ 
  int tmp ;

  {
  {
#line 563
  tmp = dup2(from, to);
  }
#line 563
  if (-1 == tmp) {
    {
#line 564
    fail(2, (char *)"Can\'t dup %d to %d:%m", from, to);
    }
  }
#line 565
  return;
}
}
#line 568 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/get.c"
int sow(void) 
{ 
  int j ;
  int reused ;
  int p[2] ;
  int tmo ;
  struct job *jp ;
  char maxbuf[20] ;
  char serialbuf[20] ;
  char timeoutbuf[20] ;
  char envgroup[255UL + sizeof("NEWSGROUP=")] ;
  char envserver[256] ;
  char envport[20UL + sizeof("TCPREMOTEPORT=")] ;
  char envip[20UL + sizeof("TCPREMOTEIP=")] ;
  char envtimeout[20UL + sizeof("TIMEOUT=")] ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  unsigned char ch ;
  unsigned long a ;
  char buf___28[32] ;
  char *p___0 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;
  char *tmp___14 ;
  int tmp___15 ;
  int pid___0 ;
  int s ;
  fd_set set ;
  char *v[2] ;
  int tmp___16 ;
  int __d0 ;
  int __d1 ;
  struct timeval tv ;
  int tmp___17 ;
  __pid_t tmp___18 ;
  int *tmp___19 ;
  union __anonunion_60 __constr_expr_4 ;
  union __anonunion_61 __constr_expr_5 ;
  union __anonunion_62 __constr_expr_6 ;
  union __anonunion_63 __constr_expr_7 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;

  {
#line 579
  if (toff >= concurrency) {
#line 580
    return (1);
  }
  {
#line 581
  j = queue_getnext();
  }
#line 581
  if (-1 == j) {
#line 582
    return (1);
  }
#line 583
  jp = *(queue + j);
#line 584
  (jp->attempts) ++;
  {
#line 586
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 588
    tmp___2 = store_get();
#line 588
    jp->outfd = tmp___2;
    }
#line 588
    if (tmp___2 > -1) {
      {
#line 590
      tmp___1 = sock_get(jp->server, (int )jp->port, & jp->addr, & reused);
#line 590
      jp->sd = tmp___1;
      }
#line 590
      if (tmp___1 > -1) {
#line 592
        if (! throttlerate) {
#line 592
          goto _L;
        } else {
          {
#line 592
          tmp___0 = pipe((int *)(p));
          }
#line 592
          if (tmp___0 > -1) {
            _L: /* CIL Label */ 
            {
#line 594
            tmp = fork();
#line 594
            jp->pid = tmp;
            }
#line 594
            if (tmp > -1) {
#line 596
              if (0 == jp->pid) {
#line 597
                goto while_break;
              }
#line 598
              if (throttlerate) {
                {
#line 600
                close(p[0]);
#line 601
                jp->infd = p[1];
                }
              } else {
#line 604
                jp->infd = -1;
              }
              {
#line 605
              queue_todo2run(j);
              }
#line 606
              return (0);
            } else {
              {
#line 609
              log_((char *)"sow:fork for %s:%m", jp->group);
              }
            }
          } else {
            {
#line 612
            log_((char *)"sow:pipe for %s:%m", jp->group);
            }
          }
        }
        {
#line 613
        close(jp->sd);
#line 614
        jp->sd = -1;
        }
      }
      {
#line 616
      store_put(jp->outfd);
#line 617
      jp->outfd = -1;
      }
    }
#line 619
    return (-1);
#line 586
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 625
  tmp___3 = chdir((char const   *)(jp->group));
  }
#line 625
  if (tmp___3) {
    {
#line 626
    fail(2, (char *)"Can\'t chdir(%s):%m", jp->group);
    }
  }
  {
#line 627
  readfile((char *)".outgoing", (char *)".timeout", (char *)(timeoutbuf));
#line 628
  tmp___4 = argc_snfetch;
#line 628
  argc_snfetch ++;
#line 628
  argv_snfetch[tmp___4] = (char *)"-t";
#line 629
  tmo = atou(timeoutbuf);
  }
#line 629
  if (tmo <= 0) {
    {
#line 631
    tmo = 120;
#line 632
    strcpy((char */* __restrict  */)(timeoutbuf), (char const   */* __restrict  */)"120");
    }
  }
#line 634
  if (debug >= 3) {
    {
#line 634
    log_((char *)"%s on socket %d, pipe %d", jp->group, jp->sd, jp->outfd);
    }
  }
  {
#line 635
  tmp___5 = argc_snfetch;
#line 635
  argc_snfetch ++;
#line 635
  argv_snfetch[tmp___5] = timeoutbuf;
#line 636
  tmp___6 = argc_snfetch;
#line 636
  argc_snfetch ++;
#line 636
  argv_snfetch[tmp___6] = jp->group;
#line 638
  formats(envgroup, (int )(sizeof(envgroup) - 1UL), (char *)"NEWSGROUP=%s", jp->group);
#line 639
  putenv(envgroup);
#line 640
  formats(envtimeout, (int )(sizeof(envtimeout) - 1UL), (char *)"TIMEOUT=%s", timeoutbuf);
#line 641
  putenv(envtimeout);
#line 642
  formats(envserver, (int )(sizeof(envserver) - 1UL), (char *)"SERVER=%s", jp->server);
#line 643
  putenv(envserver);
#line 644
  formats(envport, (int )(sizeof(envport) - 1UL), (char *)"TCPREMOTEPORT=%d", (int )jp->port);
#line 645
  putenv(envport);
#line 646
  strcpy((char */* __restrict  */)(envip), (char const   */* __restrict  */)"TCPREMOTEIP=");
#line 653
  a = jp->addr;
#line 654
  p___0 = buf___28 + 31;
#line 655
  tmp___7 = p___0;
#line 655
  p___0 --;
#line 655
  *tmp___7 = (char )'\000';
#line 656
  ch = (unsigned char )(a & 255UL);
  }
  {
#line 657
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 658
    tmp___8 = p___0;
#line 658
    p___0 --;
#line 658
    *tmp___8 = (char )(48 + (int )ch % 10);
#line 657
    ch = (unsigned char )((int )ch / 10);
#line 657
    if (! ch) {
#line 657
      goto while_break___0;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 660
  tmp___9 = p___0;
#line 660
  p___0 --;
#line 660
  *tmp___9 = (char )'.';
#line 661
  ch = (unsigned char )((a >> 8) & 255UL);
  {
#line 662
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 663
    tmp___10 = p___0;
#line 663
    p___0 --;
#line 663
    *tmp___10 = (char )(48 + (int )ch % 10);
#line 662
    ch = (unsigned char )((int )ch / 10);
#line 662
    if (! ch) {
#line 662
      goto while_break___1;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 665
  tmp___11 = p___0;
#line 665
  p___0 --;
#line 665
  *tmp___11 = (char )'.';
#line 666
  ch = (unsigned char )((a >> 16) & 255UL);
  {
#line 667
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 668
    tmp___12 = p___0;
#line 668
    p___0 --;
#line 668
    *tmp___12 = (char )(48 + (int )ch % 10);
#line 667
    ch = (unsigned char )((int )ch / 10);
#line 667
    if (! ch) {
#line 667
      goto while_break___2;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
#line 670
  tmp___13 = p___0;
#line 670
  p___0 --;
#line 670
  *tmp___13 = (char )'.';
#line 671
  ch = (unsigned char )((a >> 24) & 255UL);
  {
#line 672
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 673
    tmp___14 = p___0;
#line 673
    p___0 --;
#line 673
    *tmp___14 = (char )(48 + (int )ch % 10);
#line 672
    ch = (unsigned char )((int )ch / 10);
#line 672
    if (! ch) {
#line 672
      goto while_break___3;
    }
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 675
  strcat((char */* __restrict  */)(envip), (char const   */* __restrict  */)(p___0 + 1));
#line 677
  putenv(envip);
#line 679
  fixfd(jp->sd, 7);
  }
#line 680
  if (throttlerate) {
#line 680
    tmp___15 = p[0];
  } else {
#line 680
    tmp___15 = jp->sd;
  }
  {
#line 680
  fixfd(tmp___15, 6);
#line 681
  fixfd(jp->outfd, 1);
  }
#line 683
  if (! reused) {
    {
#line 688
    sigchld = (bool )0;
#line 689
    pid___0 = fork();
    }
#line 689
    if (-1 == pid___0) {
      {
#line 690
      fail(2, (char *)"Can\'t fork for SNHELLO:%m");
      }
    }
#line 691
    if (0 == pid___0) {
      {
#line 695
      tmp___16 = chdir(".outgoing");
      }
#line 695
      if (-1 == tmp___16) {
        {
#line 696
        fail(2, (char *)"chdir(%s/.outgoing):%m", jp->group);
        }
      }
      {
#line 697
      fixfd(2, 1);
#line 698
      v[1] = (char *)0;
#line 699
      v[0] = (char *)"./.SNHELLO";
#line 700
      execv((char const   *)v[0], (char * const  *)(v));
#line 701
      v[0] = (char *)"SNHELLO";
#line 702
      execvp((char const   *)v[0], (char * const  *)(v));
#line 703
      fail(2, (char *)"Can\'t exec %s:%m", v[0]);
      }
    }
    {
#line 705
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 705
      __asm__  volatile   ("cld; rep; "
                           "stosq": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                           "1" (& set.__fds_bits[0]): "memory");
#line 705
      goto while_break___4;
    }
    while_break___4: /* CIL Label */ ;
    }
    {
#line 706
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 706
      if (! (! sigchld)) {
#line 706
        goto while_break___5;
      }
      {
#line 710
      tv.tv_sec = (__time_t )tmo;
#line 711
      tv.tv_usec = (__suseconds_t )0;
#line 712
      set.__fds_bits[jp->sd / (8 * (int )sizeof(__fd_mask ))] |= 1L << jp->sd % (8 * (int )sizeof(__fd_mask ));
#line 713
      tmp___17 = select(jp->sd + 1, (fd_set */* __restrict  */)(& set), (fd_set */* __restrict  */)((void *)0),
                        (fd_set */* __restrict  */)((void *)0), (struct timeval */* __restrict  */)(& tv));
      }
#line 713
      if (tmp___17) {
        {
#line 715
        tv.tv_sec = (__time_t )2;
#line 716
        select(0, (fd_set */* __restrict  */)((void *)0), (fd_set */* __restrict  */)((void *)0),
               (fd_set */* __restrict  */)((void *)0), (struct timeval */* __restrict  */)(& tv));
        }
      } else {
        {
#line 719
        kill(pid___0, 14);
        }
      }
    }
    while_break___5: /* CIL Label */ ;
    }
    {
#line 721
    while (1) {
      while_continue___6: /* CIL Label */ ;
      {
#line 721
      tmp___18 = waitpid(pid___0, & s, 0);
      }
#line 721
      if (-1 == tmp___18) {
        {
#line 721
        tmp___19 = __errno_location();
        }
#line 721
        if (! (4 == *tmp___19)) {
#line 721
          goto while_break___6;
        }
      } else {
#line 721
        goto while_break___6;
      }
    }
    while_break___6: /* CIL Label */ ;
    }
#line 727
    __constr_expr_7.__in = s;
#line 727
    if ((__constr_expr_7.__i & 127) == 0) {
#line 729
      __constr_expr_4.__in = s;
#line 729
      s = (__constr_expr_4.__i & 65280) >> 8;
#line 729
      if (s) {
        {
#line 730
        fail(2, (char *)"SNHELLO(%s) exited %d", jp->group, s);
        }
      }
    } else {
#line 732
      __constr_expr_6.__in = s;
#line 732
      if ((int )((signed char )((__constr_expr_6.__i & 127) + 1)) >> 1 > 0) {
        {
#line 733
        __constr_expr_5.__in = s;
#line 733
        fail(2, (char *)"SNHELLO(%s) caught signal %d", jp->group, __constr_expr_5.__i & 127);
        }
      } else {
        {
#line 735
        fail(2, (char *)"SNHELLO(%s) unknown wait status %d", jp->group, s);
        }
      }
    }
  }
  {
#line 738
  readfile((char *)".", (char *)".serial", (char *)(serialbuf));
#line 739
  tmp___20 = argc_snfetch;
#line 739
  argc_snfetch ++;
#line 739
  argv_snfetch[tmp___20] = serialbuf;
  }
#line 740
  if ((int )serialbuf[0] == 0) {
#line 742
    if (debug >= 3) {
      {
#line 742
      log_((char *)"sow:couldn\'t get a value from %s/.serial:%m?", jp->group);
      }
    }
    {
#line 743
    strcpy((char */* __restrict  */)(serialbuf), (char const   */* __restrict  */)"0");
    }
  }
  {
#line 745
  tmp___23 = strcmp((char const   *)(serialbuf), "0");
  }
#line 745
  if (tmp___23 == 0) {
#line 746
    tmp___21 = argc_snfetch;
#line 746
    argc_snfetch ++;
#line 746
    if (optmax) {
#line 746
      argv_snfetch[tmp___21] = optmax;
    } else {
#line 746
      argv_snfetch[tmp___21] = (char *)"200";
    }
  } else {
    {
#line 749
    readfile((char *)".", (char *)".max", (char *)(maxbuf));
#line 750
    tmp___22 = argc_snfetch;
#line 750
    argc_snfetch ++;
    }
#line 750
    if (maxbuf[0]) {
#line 750
      argv_snfetch[tmp___22] = maxbuf;
    } else {
#line 750
      argv_snfetch[tmp___22] = (char *)0;
    }
  }
  {
#line 753
  argv_snfetch[argc_snfetch] = (char *)0;
#line 754
  execvp("snfetch", (char * const  *)(argv_snfetch));
#line 755
  fail(19, (char *)"sow:can\'t exec snfetch for %s:%m", jp->group);
  }
#line 757
  return (-1);
}
}
#line 760 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/get.c"
void init(void) 
{ 
  struct sigaction sa ;
  int tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
  {
#line 764
  sigemptyset(& sa.sa_mask);
#line 766
  sa.sa_flags = 0;
#line 767
  sa.__sigaction_handler.sa_handler = & chldhand;
#line 767
  sigaction(17, (struct sigaction  const  */* __restrict  */)(& sa), (struct sigaction */* __restrict  */)0);
#line 768
  sa.__sigaction_handler.sa_handler = & usrhand;
#line 768
  sigaction(10, (struct sigaction  const  */* __restrict  */)(& sa), (struct sigaction */* __restrict  */)0);
#line 769
  sa.__sigaction_handler.sa_handler = & usrhand;
#line 769
  sigaction(12, (struct sigaction  const  */* __restrict  */)(& sa), (struct sigaction */* __restrict  */)0);
#line 770
  sa.__sigaction_handler.sa_handler = (void (*)(int  ))1;
#line 770
  sigaction(13, (struct sigaction  const  */* __restrict  */)(& sa), (struct sigaction */* __restrict  */)0);
#line 772
  argc_snfetch = 1;
#line 772
  argc_snstore = argc_snfetch;
  }
#line 773
  if (optlogpid) {
#line 774
    tmp = argc_snstore;
#line 774
    argc_snstore ++;
#line 774
    tmp___0 = argc_snfetch;
#line 774
    argc_snfetch ++;
#line 774
    tmp___1 = (char *)"-P";
#line 774
    argv_snfetch[tmp___0] = tmp___1;
#line 774
    argv_snstore[tmp] = tmp___1;
  }
#line 775
  if (optdebug) {
#line 776
    tmp___2 = argc_snstore;
#line 776
    argc_snstore ++;
#line 776
    tmp___3 = argc_snfetch;
#line 776
    argc_snfetch ++;
#line 776
    tmp___4 = optdebug;
#line 776
    argv_snfetch[tmp___3] = tmp___4;
#line 776
    argv_snstore[tmp___2] = tmp___4;
  }
#line 777
  if (optpipelining) {
#line 779
    tmp___5 = argc_snfetch;
#line 779
    argc_snfetch ++;
#line 779
    argv_snfetch[tmp___5] = (char *)"-c";
#line 780
    tmp___6 = argc_snfetch;
#line 780
    argc_snfetch ++;
#line 780
    argv_snfetch[tmp___6] = optpipelining;
  }
#line 782
  argv_snstore[argc_snstore] = (char *)0;
#line 783
  return;
}
}
#line 792 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/get.c"
static struct s *servers  =    (struct s *)((void *)0);
#line 785 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/get.c"
int add(char *group ) 
{ 
  struct job *jp ;
  int c ;
  int port ;
  char *p ;
  struct s *sp ;
  size_t tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  size_t tmp___6 ;
  void *tmp___7 ;
  ssize_t tmp___8 ;

  {
  {
#line 797
  formats(path1, (int )(sizeof(path1) - 1UL), (char *)"%s/.outgoing", group);
#line 798
  tmp___8 = readlink((char const   */* __restrict  */)(path1), (char */* __restrict  */)(path2),
                     sizeof(path2) - 1UL);
#line 798
  c = (int )tmp___8;
  }
#line 798
  if (c > 0) {
    {
#line 800
    path2[c] = (char )'\000';
#line 801
    p = strrchr((char const   *)(path2), ':');
    }
#line 801
    if (p) {
      {
#line 801
      port = atou(p + 1);
      }
#line 801
      if (port > 0) {
        {
#line 803
        *p = (char )'\000';
#line 804
        p = strrchr((char const   *)(path2), '/');
        }
#line 804
        if (p) {
#line 808
          p ++;
#line 808
          sp = servers;
          {
#line 808
          while (1) {
            while_continue: /* CIL Label */ ;
#line 809
            if (! sp) {
              {
#line 811
              tmp = strlen((char const   *)p);
#line 811
              tmp___0 = malloc(sizeof(struct s ) + tmp);
#line 811
              sp = (struct s *)tmp___0;
              }
#line 811
              if (sp) {
                {
#line 813
                sp->port = (unsigned short )port;
#line 814
                strcpy((char */* __restrict  */)(sp->server), (char const   */* __restrict  */)p);
#line 815
                sp->next = servers;
#line 816
                servers = sp;
                }
              }
#line 818
              goto while_break;
            } else
#line 820
            if (port == (int )sp->port) {
              {
#line 821
              tmp___1 = strcasecmp((char const   *)(sp->server), (char const   *)p);
              }
#line 821
              if (0 == tmp___1) {
#line 822
                goto while_break;
              }
            }
#line 808
            sp = sp->next;
          }
          while_break: /* CIL Label */ ;
          }
#line 823
          if (sp) {
            {
#line 823
            tmp___6 = strlen((char const   *)group);
#line 823
            tmp___7 = malloc((sizeof(struct job ) + tmp___6) + 1UL);
#line 823
            jp = (struct job *)tmp___7;
            }
#line 823
            if (jp) {
              {
#line 825
              jp->port = (unsigned short )port;
#line 826
              jp->server = sp->server;
#line 827
              strcpy((char */* __restrict  */)(jp->group), (char const   */* __restrict  */)group);
#line 828
              tmp___4 = -1;
#line 828
              jp->infd = tmp___4;
#line 828
              tmp___3 = tmp___4;
#line 828
              jp->pid = tmp___3;
#line 828
              tmp___2 = tmp___3;
#line 828
              jp->outfd = tmp___2;
#line 828
              jp->sd = tmp___2;
#line 829
              jp->attempts = 0;
#line 830
              tmp___5 = queue_add(jp);
              }
#line 830
              if (0 == tmp___5) {
#line 831
                return (0);
              }
              {
#line 832
              free((void *)jp);
              }
            }
          }
          {
#line 834
          log_((char *)"add:No memory");
          }
        } else {
          {
#line 837
          log_((char *)"add:%s has bad server symlink", group);
          }
        }
      } else {
        {
#line 840
        log_((char *)"add:%s server symlink missing port", group);
        }
      }
    } else {
      {
#line 840
      log_((char *)"add:%s server symlink missing port", group);
      }
    }
  } else {
    {
#line 843
    log_((char *)"add:Can\'t read symlink in %s:%m", group);
    }
  }
#line 844
  return (-1);
}
}
#line 847 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/get.c"
int jobs_not_done(void) 
{ 


  {
#line 847
  return (tend);
}
}
#line 854 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/get.c"
void quit(void) 
{ 


  {
#line 856
  if (nstores) {
    {
#line 857
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 858
      nstores --;
#line 858
      close(stores[nstores]);
      }
#line 857
      if (! nstores) {
#line 857
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 860
  if (nsocks) {
    {
#line 861
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 862
      nsocks --;
#line 862
      close((int )socks[nsocks].sd);
      }
#line 861
      if (! nsocks) {
#line 861
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 864
  return;
}
}
#line 37 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/group.c"
static int desc___3  =    -1;
#line 59 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/group.c"
static int cmpgroup___0(void *a , void *b___13 ) 
{ 
  struct groupobj *x ;
  struct groupobj *y ;
  int tmp ;

  {
  {
#line 61
  x = (struct groupobj *)a;
#line 62
  y = (struct groupobj *)b___13;
#line 64
  tmp = strcmp((char const   *)x->groupname, (char const   *)y->groupname);
  }
#line 64
  return (tmp);
}
}
#line 67 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/group.c"
static void freegroup___0(void *p ) 
{ 
  struct groupobj *gop ;

  {
#line 69
  gop = (struct groupobj *)p;
#line 71
  if (gop->groupname) {
    {
#line 72
    free((void *)gop->groupname);
    }
  }
#line 73
  if (gop->dir.dir) {
    {
#line 74
    closedir(gop->dir.dir);
    }
  }
#line 75
  if (gop->lastf.f) {
    {
#line 76
    munmap((void *)((caddr_t )gop->lastf.f), sizeof(struct file ));
    }
  }
  {
#line 77
  free(p);
  }
#line 78
  return;
}
}
#line 94 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/group.c"
static int refresh___0(struct groupobj *gop , char *groupname ) 
{ 
  struct stat st ;
  struct dir *d ;
  struct lastf *lp ;
  bool needreread ;
  bool needrefile ;
  bool needreslot ;
  bool isemptygroup ;
  int tmp ;
  int tmp___0 ;
  struct dirent *dp ;
  int i ;
  int first ;
  int last___1 ;
  char *end ;
  int tmp___1 ;
  unsigned short const   **tmp___2 ;
  unsigned long tmp___3 ;
  int fd ;
  void *tmp___4 ;
  struct info *ip ;
  int slot ;

  {
#line 99
  needreread = (bool )0;
#line 100
  needrefile = (bool )0;
#line 101
  needreslot = (bool )0;
#line 102
  isemptygroup = (bool )0;
#line 104
  d = & gop->dir;
#line 105
  lp = & gop->lastf;
#line 107
  if (groupname) {
    {
#line 109
    memset((void *)gop, 0, sizeof(struct groupobj ));
#line 110
    gop->groupname = strdup((char const   *)groupname);
    }
#line 111
    if ((unsigned long )((void *)0) == (unsigned long )gop->groupname) {
      {
#line 113
      log_((char *)"refresh:strdup:%m");
      }
#line 114
      return (-1);
    }
    {
#line 116
    gop->dir.first = -1;
#line 117
    d->dir = opendir((char const   *)groupname);
    }
#line 118
    if ((unsigned long )((void *)0) == (unsigned long )d->dir) {
      {
#line 120
      log_((char *)"refresh:opendir:%m");
      }
#line 121
      return (-1);
    }
#line 123
    lp->name = -1;
#line 125
    needreslot = (bool )1;
#line 125
    needreread = needreslot;
#line 125
    needrefile = needreread;
  } else {
#line 131
    if (-1 == d->first) {
#line 132
      needreread = (bool )1;
    } else
#line 131
    if (0 == d->last) {
#line 132
      needreread = (bool )1;
    } else
#line 131
    if (! d->read) {
#line 132
      needreread = (bool )1;
    } else {
      {
#line 133
      tmp = dirfd(d->dir);
#line 133
      tmp___0 = fstat(tmp, & st);
      }
#line 133
      if (-1 == tmp___0) {
        {
#line 135
        log_((char *)"refresh:fstat:%m");
        }
#line 136
        return (-1);
      } else
#line 138
      if (d->read < st.st_mtim.tv_sec) {
#line 139
        needreread = (bool )1;
      }
    }
#line 140
    if (! lp->f) {
#line 141
      needreslot = (bool )1;
#line 141
      needrefile = needreslot;
    }
#line 142
    if (! needrefile) {
#line 143
      if (! lp->f) {
#line 144
        needrefile = (bool )1;
      }
    }
#line 145
    if (! needrefile) {
#line 146
      if (-1 == lp->name) {
#line 147
        needrefile = (bool )1;
      }
    }
  }
#line 150
  if (needreread) {
#line 150
    goto _L;
  } else
#line 150
  if (needreslot) {
    _L: /* CIL Label */ 
    {
#line 156
    first = -1;
#line 157
    last___1 = 0;
#line 158
    rewinddir(d->dir);
#line 159
    dp = readdir(d->dir);
    }
#line 160
    if ((unsigned long )((void *)0) == (unsigned long )dp) {
      {
#line 162
      log_((char *)"refresh:readdir:%m");
      }
#line 163
      return (-1);
    }
#line 165
    gop->nopost = (bool )0;
    {
#line 166
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 168
      tmp___2 = __ctype_b_loc();
      }
#line 168
      if (! ((int const   )*(*tmp___2 + (int )dp->d_name[0]) & 2048)) {
#line 170
        if (! gop->nopost) {
#line 170
          if (46 == (int )dp->d_name[0]) {
            {
#line 171
            tmp___1 = strcmp((char const   *)(dp->d_name), ".nopost");
            }
#line 171
            if (0 == tmp___1) {
#line 172
              gop->nopost = (bool )1;
            }
          }
        }
#line 173
        goto __Cont;
      }
      {
#line 175
      tmp___3 = strtoul((char const   */* __restrict  */)(dp->d_name), (char **/* __restrict  */)(& end),
                        10);
#line 175
      i = (int )tmp___3;
      }
#line 175
      if (i <= 0) {
#line 176
        goto __Cont;
      } else
#line 175
      if (*end) {
#line 176
        goto __Cont;
      }
#line 177
      if (first > i) {
#line 178
        first = i;
      } else
#line 177
      if (-1 == first) {
#line 178
        first = i;
      }
#line 179
      if (last___1 < i) {
#line 180
        last___1 = i;
      }
      __Cont: /* CIL Label */ 
      {
#line 166
      dp = readdir(d->dir);
      }
#line 166
      if (! dp) {
#line 166
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 183
    d->first = first;
#line 184
    d->last = last___1;
#line 185
    if (-1 == first) {
#line 185
      if (0 == last___1) {
#line 186
        isemptygroup = (bool )1;
      }
    }
#line 187
    if (last___1 != lp->name) {
#line 188
      needrefile = (bool )1;
    } else {
#line 190
      lp->name = last___1;
    }
    {
#line 191
    time(& d->read);
    }
  }
#line 194
  if (needrefile) {
#line 194
    goto _L___0;
  } else
#line 194
  if (needreslot) {
    _L___0: /* CIL Label */ 
#line 198
    if (lp->f) {
      {
#line 200
      munmap((void *)((caddr_t )lp->f), sizeof(struct file ));
#line 201
      lp->f = (struct file *)((void *)0);
      }
    }
#line 203
    if (isemptygroup) {
#line 204
      return (0);
    }
    {
#line 205
    fd = openf(0, 0, (char *)"%s/%d", gop->groupname, d->last);
    }
#line 206
    if (-1 == fd) {
      {
#line 208
      log_((char *)"refresh:open:%m");
      }
#line 209
      return (-1);
    }
    {
#line 211
    tmp___4 = mmap((void *)0, sizeof(struct file ), 1, 1, fd, (__off_t )0);
#line 211
    lp->f = (struct file *)tmp___4;
#line 212
    close(fd);
    }
#line 213
    if ((unsigned long )lp->f == (unsigned long )((void *)-1)) {
      {
#line 215
      log_((char *)"refresh:mmap:%m");
      }
#line 216
      return (-1);
    }
#line 218
    lp->slotsfilled = 0;
#line 219
    needreslot = (bool )1;
  }
#line 222
  if (needreslot) {
#line 224
    ip = (lp->f)->info;
#line 227
    slot = 9;
    {
#line 227
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 227
      if (! (slot > -1)) {
#line 227
        goto while_break___0;
      }
#line 228
      if ((ip + slot)->hoffset) {
#line 229
        goto while_break___0;
      }
#line 227
      slot --;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 230
    lp->slotsfilled = slot + 1;
  }
#line 233
  return (0);
}
}
#line 124 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) tolower)(int __c ) ;
#line 25 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/lib/wildmat.c"
static int match(char *candidate , char *pattern ) ;
#line 27 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/lib/wildmat.c"
static int bracket(char *candidate , char *pattern ) 
{ 
  bool negate ;
  char *end ;
  char c ;
  int flag ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;

  {
#line 29
  negate = (bool )0;
#line 32
  pattern ++;
#line 32
  end = pattern;
  {
#line 33
  while (1) {
    while_continue: /* CIL Label */ ;
#line 33
    if (*end) {
#line 33
      if (! (93 != (int )*end)) {
#line 33
        goto while_break;
      }
    } else {
#line 33
      goto while_break;
    }
#line 33
    if (92 == (int )*end) {
#line 33
      end ++;
    }
#line 33
    end ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 34
  if (! *end) {
#line 34
    return (-1);
  }
#line 35
  if (94 == (int )*pattern) {
#line 35
    negate = (bool )1;
#line 35
    pattern ++;
  }
#line 36
  if (45 == (int )*pattern) {
#line 36
    goto isnormalchar;
  }
  {
#line 37
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 37
    if (! *pattern) {
#line 37
      goto while_break___0;
    }
#line 42
    if (92 == (int )*pattern) {
#line 42
      pattern ++;
#line 42
      goto isnormalchar;
    }
#line 43
    if (93 == (int )*pattern) {
      {
#line 43
      tmp = match(candidate + 1, end + 1);
      }
#line 43
      return (1 + tmp);
    }
    {
#line 46
    if ((int )*(pattern + 1) == 0) {
#line 46
      goto case_0;
    }
#line 47
    if ((int )*(pattern + 1) == 45) {
#line 47
      goto case_45;
    }
#line 54
    goto isnormalchar;
    case_0: /* CIL Label */ 
#line 46
    return (-1);
    case_45: /* CIL Label */ 
    {
#line 48
    tmp___0 = tolower((int )*candidate);
#line 48
    c = (char )tmp___0;
#line 49
    tmp___1 = tolower((int )*pattern);
    }
#line 49
    if ((int )c >= tmp___1) {
      {
#line 49
      tmp___2 = tolower((int )*(pattern + 2));
      }
#line 49
      if ((int )c <= tmp___2) {
#line 49
        tmp___3 = 1;
      } else {
#line 49
        tmp___3 = 0;
      }
    } else {
#line 49
      tmp___3 = 0;
    }
#line 49
    flag = tmp___3;
#line 50
    if (flag) {
#line 50
      if (negate) {
#line 50
        return (-1);
      } else {
#line 50
        pattern += 2;
      }
    } else
#line 51
    if (negate) {
#line 51
      pattern += 2;
    } else {
#line 51
      return (-1);
    }
#line 52
    goto switch_break;
    isnormalchar: 
    switch_default: /* CIL Label */ 
    {
#line 55
    tmp___6 = tolower((int )*candidate);
#line 55
    tmp___7 = tolower((int )*pattern);
    }
#line 55
    if (tmp___6 == tmp___7) {
#line 57
      if (negate) {
#line 57
        pattern ++;
      } else {
        {
#line 57
        tmp___4 = match(candidate + 1, end + 1);
        }
#line 57
        return (1 + tmp___4);
      }
    } else
#line 60
    if (negate) {
      {
#line 60
      tmp___5 = match(candidate + 1, end + 1);
      }
#line 60
      return (1 + tmp___5);
    } else {
#line 60
      pattern ++;
    }
    switch_break: /* CIL Label */ ;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 63
  return (-1);
}
}
#line 66 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/lib/wildmat.c"
static int match(char *candidate , char *pattern ) 
{ 
  int ret ;
  char *c ;
  int len ;
  int clen ;
  size_t tmp ;
  size_t tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 68
  ret = 0;
  {
#line 72
  while (1) {
    while_continue: /* CIL Label */ ;
#line 74
    if (92 == (int )*pattern) {
#line 74
      goto default_char;
    }
    {
#line 77
    if ((int )*pattern == 0) {
#line 77
      goto case_0;
    }
#line 77
    if ((int )*pattern == 10) {
#line 77
      goto case_0;
    }
#line 77
    if ((int )*pattern == 13) {
#line 77
      goto case_0;
    }
#line 83
    if ((int )*pattern == 42) {
#line 83
      goto case_42;
    }
#line 104
    if ((int )*pattern == 91) {
#line 104
      goto case_91;
    }
#line 106
    if ((int )*pattern == 63) {
#line 106
      goto case_63;
    }
#line 113
    goto switch_default;
    case_0: /* CIL Label */ 
    case_10: /* CIL Label */ 
    case_13: /* CIL Label */ 
    {
#line 80
    if ((int )*candidate == 10) {
#line 80
      goto case_10___0;
    }
#line 80
    if ((int )*candidate == 13) {
#line 80
      goto case_10___0;
    }
#line 80
    if ((int )*candidate == 0) {
#line 80
      goto case_10___0;
    }
#line 78
    goto switch_break___0;
    case_10___0: /* CIL Label */ 
    case_13___0: /* CIL Label */ 
    case_0___0: /* CIL Label */ 
#line 80
    return (ret);
    switch_break___0: /* CIL Label */ ;
    }
#line 82
    return (-1);
    case_42: /* CIL Label */ 
    {
#line 89
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 89
      if (! (42 == (int )*pattern)) {
#line 89
        goto while_break___0;
      }
#line 89
      pattern ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 90
    if (! *pattern) {
      {
#line 90
      tmp = strcspn((char const   *)candidate, "\r\n");
      }
#line 90
      return ((int )((size_t )ret + tmp));
    }
    {
#line 91
    tmp___0 = strcspn((char const   *)candidate, "\r\n");
#line 91
    clen = (int )tmp___0;
#line 92
    c = candidate;
    }
    {
#line 92
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 92
      if (clen) {
#line 92
        if (! *c) {
#line 92
          goto while_break___1;
        }
      } else {
#line 92
        goto while_break___1;
      }
      {
#line 96
      if ((int )*c == 10) {
#line 96
        goto case_10___1;
      }
#line 96
      if ((int )*c == 13) {
#line 96
        goto case_10___1;
      }
#line 94
      goto switch_break___1;
      case_10___1: /* CIL Label */ 
      case_13___1: /* CIL Label */ 
#line 96
      return (-1);
      switch_break___1: /* CIL Label */ ;
      }
      {
#line 98
      len = match(c, pattern);
      }
#line 99
      if (len == clen) {
#line 99
        return ((int )((long )len + (c - candidate)));
      }
#line 92
      c ++;
#line 92
      clen --;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 101
    return (-1);
    case_91: /* CIL Label */ 
    {
#line 105
    tmp___1 = bracket(candidate, pattern);
    }
#line 105
    return (ret + tmp___1);
    case_63: /* CIL Label */ 
#line 107
    pattern ++;
#line 108
    if (! *candidate) {
#line 108
      return (-1);
    }
#line 109
    ret ++;
#line 109
    candidate ++;
#line 110
    goto while_continue;
    default_char: 
#line 112
    pattern ++;
    switch_default: /* CIL Label */ 
    {
#line 114
    tmp___2 = tolower((int )*pattern);
#line 114
    tmp___3 = tolower((int )*candidate);
    }
#line 114
    if (tmp___2 == tmp___3) {
#line 116
      pattern ++;
#line 116
      candidate ++;
#line 116
      ret ++;
    } else {
#line 119
      return (-1);
    }
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 124 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/lib/wildmat.c"
int wildmat(char *candidate , char *pattern ) 
{ 
  int tmp ;
  size_t tmp___0 ;

  {
  {
#line 126
  tmp = match(candidate, pattern);
#line 126
  tmp___0 = strcspn((char const   *)candidate, "\r\n");
  }
#line 126
  if ((size_t )tmp == tmp___0) {
#line 127
    return (1);
  }
#line 128
  return (0);
}
}
#line 26 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/key.c"
static struct buf *head___1  ;
#line 27 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/key.c"
static int avail___2  =    0;
#line 28 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/key.c"
static char *keybuf___0  =    (char *)((void *)0);
#line 33 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/key.c"
static unsigned int hv___0  ;
#line 35 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/key.c"
static void hash___2(char *key , int len ) 
{ 
  char *tmp ;

  {
#line 37
  hv___0 = 5381U;
  {
#line 38
  while (1) {
    while_continue: /* CIL Label */ ;
#line 38
    if (! len) {
#line 38
      goto while_break;
    }
#line 40
    len --;
#line 41
    hv___0 += hv___0 << 5;
#line 42
    tmp = key;
#line 42
    key ++;
#line 42
    hv___0 ^= (unsigned int )*tmp;
  }
  while_break: /* CIL Label */ ;
  }
#line 44
  hv___0 %= 128U;
#line 45
  return;
}
}
#line 87 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/cache.c"
static struct entry *new_entry___1(int desc___35 ) 
{ 
  struct entry *ep ;
  struct entry *tmp ;

  {
#line 91
  ep = table[desc___35].freelist;
#line 91
  if (ep) {
#line 92
    table[desc___35].freelist = ep->next;
  } else {
#line 95
    ep = table[desc___35].entries;
    {
#line 95
    while (1) {
      while_continue: /* CIL Label */ ;
#line 95
      if (! ep->next) {
#line 95
        goto while_break;
      }
#line 95
      ep = ep->next;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 96
    (ep->prev)->next = (struct entry *)((void *)0);
#line 97
    (*(table[desc___35].freeobj))(ep->object);
    }
  }
#line 99
  tmp = (struct entry *)((void *)0);
#line 99
  ep->next = tmp;
#line 99
  ep->prev = tmp;
#line 100
  ep->object = (void *)0;
#line 101
  return (ep);
}
}
#line 67 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/store.c"
static int sto_cmp___0(void *a , void *b___13 ) 
{ 
  register struct storeobj *x ;
  register struct storeobj *y ;
  int tmp ;

  {
  {
#line 69
  x = (struct storeobj *)a;
#line 70
  y = (struct storeobj *)b___13;
#line 72
  tmp = strcmp((char const   *)x->filename, (char const   *)y->filename);
  }
#line 72
  return (tmp);
}
}
#line 75 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/store.c"
static int nosigio___0(ssize_t (*op)() , int fd , char *buf___28 , int len ) 
{ 
  int er ;
  int *tmp ;
  ssize_t tmp___0 ;

  {
  {
#line 79
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 79
    tmp___0 = (*op)(fd, buf___28, len);
#line 79
    er = (int )tmp___0;
    }
#line 79
    if (! (-1 == er)) {
#line 79
      goto while_break;
    }
    {
#line 80
    tmp = __errno_location();
    }
#line 80
    if (4 != *tmp) {
#line 82
      if (debug >= 1) {
        {
#line 82
        log_((char *)"nosigio:%m");
        }
      }
#line 83
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 85
  return (er);
}
}
#line 88 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/store.c"
static int copyart___0(int tofd , int fromfd , int fromseek , int len ) 
{ 
  char buf___28[1024] ;
  __off_t tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  {
#line 92
  tmp = lseek(fromfd, (__off_t )fromseek, 0);
  }
#line 92
  if (-1L == tmp) {
    {
#line 94
    log_((char *)"copyart:lseek:%m");
    }
#line 95
    return (-1);
  }
  {
#line 98
  while (1) {
    while_continue: /* CIL Label */ ;
#line 98
    if (! (len > 1024)) {
#line 98
      goto while_break;
    }
    {
#line 99
    tmp___0 = nosigio___0((ssize_t (*)())(& read), fromfd, buf___28, 1024);
    }
#line 99
    if (-1 == tmp___0) {
#line 100
      return (-1);
    } else {
      {
#line 99
      tmp___1 = nosigio___0((ssize_t (*)())(& write), tofd, buf___28, 1024);
      }
#line 99
      if (-1 == tmp___1) {
#line 100
        return (-1);
      }
    }
#line 98
    len -= 1024;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 101
  tmp___2 = nosigio___0((ssize_t (*)())(& read), fromfd, buf___28, len);
  }
#line 101
  if (-1 == tmp___2) {
#line 102
    return (-1);
  } else {
    {
#line 101
    tmp___3 = nosigio___0((ssize_t (*)())(& write), tofd, buf___28, len);
    }
#line 101
    if (-1 == tmp___3) {
#line 102
      return (-1);
    }
  }
#line 104
  return (0);
}
}
#line 107 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/store.c"
static int checkindex___0(struct info *p ) 
{ 


  {
#line 109
  if (p->hoffset > 0) {
#line 111
    if (p->boffset > 0) {
#line 112
      if (p->hlen > 0) {
#line 113
        if (p->blen > 0) {
#line 114
          return (0);
        }
      }
    }
  } else
#line 116
  if (-1 == p->hoffset) {
#line 116
    if (-1 == p->boffset) {
#line 117
      return (1);
    }
  }
#line 118
  return (-1);
}
}
#line 127 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/store.c"
static void reorder___0(struct storeobj *sp ) 
{ 
  char tmpname[287] ;
  char *p ;
  char *q ;
  int fd ;
  struct file f___9 ;
  int er ;
  int i ;
  char *tmp ;
  char tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char tmp___4 ;
  char *tmp___5 ;
  int *tmp___6 ;
  int tmp___7 ;
  char *p___0 ;
  int *tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  __off_t tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  __off_t tmp___17 ;
  __off_t tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;

  {
#line 133
  f___9.magic = 0;
#line 133
  f___9.info[0].hoffset = 0;
#line 133
  f___9.info[0].hlen = 0;
#line 133
  f___9.info[0].boffset = 0;
#line 133
  f___9.info[0].blen = 0;
#line 133
  f___9.info[1].hoffset = 0;
#line 133
  f___9.info[1].hlen = 0;
#line 133
  f___9.info[1].boffset = 0;
#line 133
  f___9.info[1].blen = 0;
#line 133
  f___9.info[2].hoffset = 0;
#line 133
  f___9.info[2].hlen = 0;
#line 133
  f___9.info[2].boffset = 0;
#line 133
  f___9.info[2].blen = 0;
#line 133
  f___9.info[3].hoffset = 0;
#line 133
  f___9.info[3].hlen = 0;
#line 133
  f___9.info[3].boffset = 0;
#line 133
  f___9.info[3].blen = 0;
#line 133
  f___9.info[4].hoffset = 0;
#line 133
  f___9.info[4].hlen = 0;
#line 133
  f___9.info[4].boffset = 0;
#line 133
  f___9.info[4].blen = 0;
#line 133
  f___9.info[5].hoffset = 0;
#line 133
  f___9.info[5].hlen = 0;
#line 133
  f___9.info[5].boffset = 0;
#line 133
  f___9.info[5].blen = 0;
#line 133
  f___9.info[6].hoffset = 0;
#line 133
  f___9.info[6].hlen = 0;
#line 133
  f___9.info[6].boffset = 0;
#line 133
  f___9.info[6].blen = 0;
#line 133
  f___9.info[7].hoffset = 0;
#line 133
  f___9.info[7].hlen = 0;
#line 133
  f___9.info[7].boffset = 0;
#line 133
  f___9.info[7].blen = 0;
#line 133
  f___9.info[8].hoffset = 0;
#line 133
  f___9.info[8].hlen = 0;
#line 133
  f___9.info[8].boffset = 0;
#line 133
  f___9.info[8].blen = 0;
#line 133
  f___9.info[9].hoffset = 0;
#line 133
  f___9.info[9].hlen = 0;
#line 133
  f___9.info[9].boffset = 0;
#line 133
  f___9.info[9].blen = 0;
#line 136
  p = tmpname;
#line 136
  q = sp->filename;
  {
#line 136
  while (1) {
    while_continue: /* CIL Label */ ;
#line 136
    tmp = p;
#line 136
    p ++;
#line 136
    tmp___1 = q;
#line 136
    q ++;
#line 136
    tmp___0 = *tmp___1;
#line 136
    *tmp = tmp___0;
#line 136
    if (! ((int )tmp___0 != 47)) {
#line 136
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 137
  tmp___2 = p;
#line 137
  p ++;
#line 137
  *tmp___2 = (char )'+';
  {
#line 138
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 138
    tmp___3 = p;
#line 138
    p ++;
#line 138
    tmp___5 = q;
#line 138
    q ++;
#line 138
    tmp___4 = *tmp___5;
#line 138
    *tmp___3 = tmp___4;
#line 138
    if (! tmp___4) {
#line 138
      goto while_break___0;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 139
  fd = open((char const   *)(tmpname), 194, 420);
  }
#line 140
  if (-1 == fd) {
    {
#line 142
    tmp___6 = __errno_location();
    }
#line 142
    if (17 != *tmp___6) {
      {
#line 143
      log_((char *)"reorder:open(%s):%m", tmpname);
      }
    }
#line 144
    return;
  }
  {
#line 147
  f___9.magic = 1027296;
#line 148
  tmp___7 = nosigio___0((ssize_t (*)())(& write), fd, (char *)(& f___9), (int )sizeof(f___9));
  }
#line 148
  if (-1 == tmp___7) {
#line 149
    goto fail;
  }
  {
#line 161
  tmp___9 = lockf(sp->fd, 2, (__off_t )0);
  }
#line 161
  if (-1 == tmp___9) {
    {
#line 165
    tmp___8 = __errno_location();
    }
#line 165
    if (11 != *tmp___8) {
#line 166
      p___0 = (char *)"reorder:can\'t lockf %s:%m";
    } else {
#line 168
      p___0 = (char *)"reorder:article in %s being cancelled?";
    }
    {
#line 169
    log_(p___0, sp->filename);
    }
#line 170
    goto fail;
  }
#line 173
  i = 0;
  {
#line 173
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 173
    if (! (i < 10)) {
#line 173
      goto while_break___1;
    }
    {
#line 174
    tmp___10 = checkindex___0((sp->file)->info + i);
    }
    {
#line 176
    if (tmp___10 == 0) {
#line 176
      goto case_0;
    }
#line 188
    if (tmp___10 == 1) {
#line 188
      goto case_1;
    }
#line 191
    if (tmp___10 == -1) {
#line 191
      goto case_neg_1;
    }
#line 174
    goto switch_break;
    case_0: /* CIL Label */ 
    {
#line 177
    tmp___12 = lseek(fd, (__off_t )0, 2);
#line 177
    tmp___11 = (int )tmp___12;
#line 177
    f___9.info[i].hoffset = tmp___11;
    }
#line 177
    if (tmp___11 > 0) {
      {
#line 179
      f___9.info[i].hlen = (sp->file)->info[i].hlen;
#line 180
      f___9.info[i].blen = (sp->file)->info[i].blen;
#line 181
      er = copyart___0(fd, sp->fd, (sp->file)->info[i].hoffset, f___9.info[i].hlen);
      }
#line 182
      if (0 == er) {
#line 183
        goto switch_break;
      }
    } else {
      {
#line 186
      log_((char *)"reorder:lseek(%s):%m", tmpname);
      }
    }
#line 187
    goto fail;
    case_1: /* CIL Label */ 
#line 189
    tmp___15 = -1;
#line 189
    f___9.info[i].hlen = tmp___15;
#line 189
    tmp___14 = tmp___15;
#line 189
    f___9.info[i].blen = tmp___14;
#line 189
    tmp___13 = tmp___14;
#line 189
    f___9.info[i].hoffset = tmp___13;
#line 189
    f___9.info[i].boffset = tmp___13;
#line 190
    goto switch_break;
    case_neg_1: /* CIL Label */ 
    {
#line 192
    log_((char *)"reorder:corrupt index in %s", sp->filename);
    }
#line 193
    goto fail;
    switch_break: /* CIL Label */ ;
    }
#line 173
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 195
  i = 0;
  {
#line 195
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 195
    if (! (i < 10)) {
#line 195
      goto while_break___2;
    }
#line 197
    if (-1 == f___9.info[i].boffset) {
#line 198
      goto __Cont;
    }
    {
#line 199
    tmp___17 = lseek(fd, (__off_t )0, 2);
#line 199
    tmp___16 = (int )tmp___17;
#line 199
    f___9.info[i].boffset = tmp___16;
    }
#line 199
    if (-1 == tmp___16) {
      {
#line 201
      log_((char *)"reorder:lseek(%s):%m", tmpname);
      }
#line 202
      goto fail;
    }
    {
#line 204
    er = copyart___0(fd, sp->fd, (sp->file)->info[i].boffset, f___9.info[i].blen);
    }
#line 205
    if (-1 == er) {
#line 206
      goto fail;
    }
    __Cont: /* CIL Label */ 
#line 195
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 209
  tmp___18 = lseek(fd, (__off_t )0, 0);
  }
#line 209
  if (-1L == tmp___18) {
    {
#line 211
    log_((char *)"reorder:lseek:%m");
    }
#line 212
    goto fail;
  }
  {
#line 214
  tmp___19 = nosigio___0((ssize_t (*)())(& write), fd, (char *)(& f___9), (int )sizeof(f___9));
  }
#line 214
  if (-1 == tmp___19) {
#line 215
    goto fail;
  }
  {
#line 216
  tmp___20 = rename((char const   *)(tmpname), (char const   *)sp->filename);
  }
#line 216
  if (-1 == tmp___20) {
    {
#line 218
    log_((char *)"reorder:rename:%m");
    }
#line 219
    goto fail;
  }
  {
#line 221
  close(fd);
  }
#line 222
  return;
  fail: 
  {
#line 225
  log_((char *)"reorder:write failed for %s:%m", sp->filename);
#line 226
  tmp___21 = unlink((char const   *)(tmpname));
  }
#line 226
  if (-1 == tmp___21) {
    {
#line 227
    log_((char *)"reorder:unlink(%s):%m", tmpname);
    }
  }
  {
#line 228
  close(fd);
  }
#line 229
  return;
}
}
#line 231 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/store.c"
static void sto_free___0(void *p ) 
{ 
  struct storeobj *sp ;
  int tmp ;

  {
  {
#line 233
  sp = (struct storeobj *)p;
#line 235
  close(sp->fd);
#line 236
  tmp = munmap((void *)((caddr_t )sp->file), sizeof(struct file ));
  }
#line 236
  if (-1 == tmp) {
    {
#line 237
    log_((char *)"sto_free:munmap:%m");
    }
  }
  {
#line 238
  free((void *)sp);
  }
#line 239
  return;
}
}
#line 241 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/store.c"
static int desc___4  ;
#line 304
static int tryopen___0(char *fn ) ;
#line 304 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/store.c"
static struct file f___0  =    {1027296, {{0, 0, 0, 0}}};
#line 270 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/store.c"
static int tryopen___0(char *fn ) 
{ 
  char fn2[287] ;
  int fd ;
  int i ;
  char *p ;
  char *q ;
  struct timeval tv ;
  char *tmp ;
  char tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  ssize_t tmp___7 ;

  {
  {
#line 278
  fd = open((char const   *)fn, 2);
  }
#line 278
  if (fd > -1) {
    {
#line 280
    lockf(fd, 1, (__off_t )0);
    }
#line 281
    return (fd);
  }
#line 283
  p = fn2;
#line 283
  q = fn;
  {
#line 283
  while (1) {
    while_continue: /* CIL Label */ ;
#line 283
    tmp = p;
#line 283
    p ++;
#line 283
    tmp___1 = q;
#line 283
    q ++;
#line 283
    tmp___0 = *tmp___1;
#line 283
    *tmp = tmp___0;
#line 283
    if (! ((int )tmp___0 != 47)) {
#line 283
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 284
  tmp___2 = p;
#line 284
  p ++;
#line 284
  *tmp___2 = (char )'+';
#line 285
  tmp___3 = p;
#line 285
  p ++;
#line 285
  *tmp___3 = (char )'+';
#line 286
  gettimeofday((struct timeval */* __restrict  */)(& tv), (__timezone_ptr_t )0);
#line 296
  i = (int )(tv.tv_sec / 30L);
  }
  {
#line 297
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 298
    tmp___4 = p;
#line 298
    p ++;
#line 298
    *tmp___4 = (char )(48 + i % 10);
#line 297
    i /= 10;
#line 297
    if (! i) {
#line 297
      goto while_break___0;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 300
  tmp___5 = p;
#line 300
  p ++;
#line 300
  *tmp___5 = (char )'\000';
#line 302
  i = 0;
  {
#line 302
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 302
    if (! (i < 100)) {
#line 302
      goto while_break___1;
    }
#line 306
    if (14 == i % 15) {
      {
#line 307
      log_((char *)"tryopen:racing on %s", fn);
      }
    }
    {
#line 308
    fd = open((char const   *)(fn2), 194, 420);
    }
#line 308
    if (fd > -1) {
      {
#line 310
      lockf(fd, 1, (__off_t )0);
#line 311
      tmp___7 = write(fd, (void const   *)((char *)(& f___0)), sizeof(f___0));
      }
#line 311
      if (sizeof(f___0) == (unsigned long )tmp___7) {
        {
#line 312
        tmp___6 = link((char const   *)(fn2), (char const   *)fn);
        }
#line 312
        if (0 == tmp___6) {
          {
#line 314
          unlink((char const   *)(fn2));
          }
#line 315
          return (fd);
        }
      }
      {
#line 317
      close(fd);
#line 318
      unlink((char const   *)(fn2));
      }
    }
    {
#line 321
    fd = open((char const   *)fn, 2);
    }
#line 321
    if (fd > -1) {
      {
#line 323
      lockf(fd, 1, (__off_t )0);
      }
#line 324
      return (fd);
    }
    {
#line 302
    nap(0, 300 + i);
#line 302
    i ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 327
  log_((char *)"tryopen:timed out opening %s:%m", fn);
  }
#line 328
  return (-1);
}
}
#line 337 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/store.c"
static struct storeobj *getstore___0(char *filename ) 
{ 
  struct storeobj *sp ;
  struct storeobj s ;
  int fd ;
  struct file *fp ;
  char buf___28[287] ;
  int c ;
  void *tmp ;
  void *tmp___0 ;
  char *p ;
  char *q ;
  char *tmp___1 ;
  char tmp___2 ;
  char *tmp___3 ;
  char *end ;
  unsigned long tmp___4 ;
  ssize_t tmp___5 ;
  size_t tmp___6 ;
  void *tmp___7 ;

  {
  {
#line 349
  s.filename = filename;
#line 350
  tmp = cache_find(desc___4, (void *)(& s));
#line 350
  sp = (struct storeobj *)tmp;
  }
#line 350
  if (sp) {
    {
#line 352
    lockf(sp->fd, 1, (__off_t )0);
    }
#line 353
    return (sp);
  }
  {
#line 356
  fd = tryopen___0(filename);
  }
#line 356
  if (-1 == fd) {
#line 357
    return ((struct storeobj *)0);
  }
  {
#line 361
  tmp___0 = mmap((void *)0, sizeof(*fp), 3, 1, fd, (__off_t )0);
#line 361
  fp = (struct file *)tmp___0;
  }
#line 362
  if (! fp) {
    {
#line 363
    log_((char *)"getstore:mmap(%s):%m", filename);
    }
  } else
#line 362
  if ((unsigned long )fp == (unsigned long )((void *)-1)) {
    {
#line 363
    log_((char *)"getstore:mmap(%s):%m", filename);
    }
  } else {
    {
#line 364
    tmp___6 = strlen((char const   *)filename);
#line 364
    tmp___7 = malloc((sizeof(*sp) + tmp___6) + 1UL);
#line 364
    sp = (struct storeobj *)tmp___7;
    }
#line 364
    if (sp) {
      {
#line 371
      sp->fd = fd;
#line 372
      sp->file = fp;
#line 373
      sp->filename = (char *)sp + sizeof(*sp);
#line 374
      strcpy((char */* __restrict  */)sp->filename, (char const   */* __restrict  */)filename);
#line 380
      p = buf___28;
#line 380
      q = filename;
      }
      {
#line 380
      while (1) {
        while_continue: /* CIL Label */ ;
#line 380
        tmp___1 = p;
#line 380
        p ++;
#line 380
        tmp___3 = q;
#line 380
        q ++;
#line 380
        tmp___2 = *tmp___3;
#line 380
        *tmp___1 = tmp___2;
#line 380
        if (! ((int )tmp___2 != 47)) {
#line 380
          goto while_break;
        }
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 381
      strcpy((char */* __restrict  */)p, (char const   */* __restrict  */)".compress");
#line 383
      fd = open((char const   *)(buf___28), 0);
      }
#line 383
      if (fd > -1) {
        {
#line 385
        sp->compressok = 1024;
#line 386
        tmp___5 = read(fd, (void *)(buf___28), sizeof(buf___28) - 1UL);
#line 386
        c = (int )tmp___5;
        }
#line 386
        if (c > 0) {
          {
#line 390
          buf___28[c] = (char )'\000';
#line 391
          tmp___4 = strtoul((char const   */* __restrict  */)(buf___28), (char **/* __restrict  */)(& end),
                            10);
#line 391
          c = (int )tmp___4;
          }
#line 392
          if (c > 1024) {
#line 392
            if (10 == (int )*end) {
#line 393
              sp->compressok = c;
            }
          }
        }
        {
#line 395
        close(fd);
        }
      } else {
#line 399
        sp->compressok = 0;
      }
      {
#line 400
      cache_insert(desc___4, (void *)sp);
      }
#line 401
      return (sp);
    } else {
      {
#line 366
      log_((char *)"getstore:no memory");
#line 367
      munmap((void *)fp, sizeof(*fp));
      }
    }
  }
  {
#line 403
  close(fd);
  }
#line 404
  return ((struct storeobj *)0);
}
}
#line 37 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/group.c"
static int desc___5  =    -1;
#line 59 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/group.c"
static int cmpgroup___1(void *a , void *b___13 ) 
{ 
  struct groupobj *x ;
  struct groupobj *y ;
  int tmp ;

  {
  {
#line 61
  x = (struct groupobj *)a;
#line 62
  y = (struct groupobj *)b___13;
#line 64
  tmp = strcmp((char const   *)x->groupname, (char const   *)y->groupname);
  }
#line 64
  return (tmp);
}
}
#line 67 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/group.c"
static void freegroup___1(void *p ) 
{ 
  struct groupobj *gop ;

  {
#line 69
  gop = (struct groupobj *)p;
#line 71
  if (gop->groupname) {
    {
#line 72
    free((void *)gop->groupname);
    }
  }
#line 73
  if (gop->dir.dir) {
    {
#line 74
    closedir(gop->dir.dir);
    }
  }
#line 75
  if (gop->lastf.f) {
    {
#line 76
    munmap((void *)((caddr_t )gop->lastf.f), sizeof(struct file ));
    }
  }
  {
#line 77
  free(p);
  }
#line 78
  return;
}
}
#line 94 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/group.c"
static int refresh___1(struct groupobj *gop , char *groupname ) 
{ 
  struct stat st ;
  struct dir *d ;
  struct lastf *lp ;
  bool needreread ;
  bool needrefile ;
  bool needreslot ;
  bool isemptygroup ;
  int tmp ;
  int tmp___0 ;
  struct dirent *dp ;
  int i ;
  int first ;
  int last___1 ;
  char *end ;
  int tmp___1 ;
  unsigned short const   **tmp___2 ;
  unsigned long tmp___3 ;
  int fd ;
  void *tmp___4 ;
  struct info *ip ;
  int slot ;

  {
#line 99
  needreread = (bool )0;
#line 100
  needrefile = (bool )0;
#line 101
  needreslot = (bool )0;
#line 102
  isemptygroup = (bool )0;
#line 104
  d = & gop->dir;
#line 105
  lp = & gop->lastf;
#line 107
  if (groupname) {
    {
#line 109
    memset((void *)gop, 0, sizeof(struct groupobj ));
#line 110
    gop->groupname = strdup((char const   *)groupname);
    }
#line 111
    if ((unsigned long )((void *)0) == (unsigned long )gop->groupname) {
      {
#line 113
      log_((char *)"refresh:strdup:%m");
      }
#line 114
      return (-1);
    }
    {
#line 116
    gop->dir.first = -1;
#line 117
    d->dir = opendir((char const   *)groupname);
    }
#line 118
    if ((unsigned long )((void *)0) == (unsigned long )d->dir) {
      {
#line 120
      log_((char *)"refresh:opendir:%m");
      }
#line 121
      return (-1);
    }
#line 123
    lp->name = -1;
#line 125
    needreslot = (bool )1;
#line 125
    needreread = needreslot;
#line 125
    needrefile = needreread;
  } else {
#line 131
    if (-1 == d->first) {
#line 132
      needreread = (bool )1;
    } else
#line 131
    if (0 == d->last) {
#line 132
      needreread = (bool )1;
    } else
#line 131
    if (! d->read) {
#line 132
      needreread = (bool )1;
    } else {
      {
#line 133
      tmp = dirfd(d->dir);
#line 133
      tmp___0 = fstat(tmp, & st);
      }
#line 133
      if (-1 == tmp___0) {
        {
#line 135
        log_((char *)"refresh:fstat:%m");
        }
#line 136
        return (-1);
      } else
#line 138
      if (d->read < st.st_mtim.tv_sec) {
#line 139
        needreread = (bool )1;
      }
    }
#line 140
    if (! lp->f) {
#line 141
      needreslot = (bool )1;
#line 141
      needrefile = needreslot;
    }
#line 142
    if (! needrefile) {
#line 143
      if (! lp->f) {
#line 144
        needrefile = (bool )1;
      }
    }
#line 145
    if (! needrefile) {
#line 146
      if (-1 == lp->name) {
#line 147
        needrefile = (bool )1;
      }
    }
  }
#line 150
  if (needreread) {
#line 150
    goto _L;
  } else
#line 150
  if (needreslot) {
    _L: /* CIL Label */ 
    {
#line 156
    first = -1;
#line 157
    last___1 = 0;
#line 158
    rewinddir(d->dir);
#line 159
    dp = readdir(d->dir);
    }
#line 160
    if ((unsigned long )((void *)0) == (unsigned long )dp) {
      {
#line 162
      log_((char *)"refresh:readdir:%m");
      }
#line 163
      return (-1);
    }
#line 165
    gop->nopost = (bool )0;
    {
#line 166
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 168
      tmp___2 = __ctype_b_loc();
      }
#line 168
      if (! ((int const   )*(*tmp___2 + (int )dp->d_name[0]) & 2048)) {
#line 170
        if (! gop->nopost) {
#line 170
          if (46 == (int )dp->d_name[0]) {
            {
#line 171
            tmp___1 = strcmp((char const   *)(dp->d_name), ".nopost");
            }
#line 171
            if (0 == tmp___1) {
#line 172
              gop->nopost = (bool )1;
            }
          }
        }
#line 173
        goto __Cont;
      }
      {
#line 175
      tmp___3 = strtoul((char const   */* __restrict  */)(dp->d_name), (char **/* __restrict  */)(& end),
                        10);
#line 175
      i = (int )tmp___3;
      }
#line 175
      if (i <= 0) {
#line 176
        goto __Cont;
      } else
#line 175
      if (*end) {
#line 176
        goto __Cont;
      }
#line 177
      if (first > i) {
#line 178
        first = i;
      } else
#line 177
      if (-1 == first) {
#line 178
        first = i;
      }
#line 179
      if (last___1 < i) {
#line 180
        last___1 = i;
      }
      __Cont: /* CIL Label */ 
      {
#line 166
      dp = readdir(d->dir);
      }
#line 166
      if (! dp) {
#line 166
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 183
    d->first = first;
#line 184
    d->last = last___1;
#line 185
    if (-1 == first) {
#line 185
      if (0 == last___1) {
#line 186
        isemptygroup = (bool )1;
      }
    }
#line 187
    if (last___1 != lp->name) {
#line 188
      needrefile = (bool )1;
    } else {
#line 190
      lp->name = last___1;
    }
    {
#line 191
    time(& d->read);
    }
  }
#line 194
  if (needrefile) {
#line 194
    goto _L___0;
  } else
#line 194
  if (needreslot) {
    _L___0: /* CIL Label */ 
#line 198
    if (lp->f) {
      {
#line 200
      munmap((void *)((caddr_t )lp->f), sizeof(struct file ));
#line 201
      lp->f = (struct file *)((void *)0);
      }
    }
#line 203
    if (isemptygroup) {
#line 204
      return (0);
    }
    {
#line 205
    fd = openf(0, 0, (char *)"%s/%d", gop->groupname, d->last);
    }
#line 206
    if (-1 == fd) {
      {
#line 208
      log_((char *)"refresh:open:%m");
      }
#line 209
      return (-1);
    }
    {
#line 211
    tmp___4 = mmap((void *)0, sizeof(struct file ), 1, 1, fd, (__off_t )0);
#line 211
    lp->f = (struct file *)tmp___4;
#line 212
    close(fd);
    }
#line 213
    if ((unsigned long )lp->f == (unsigned long )((void *)-1)) {
      {
#line 215
      log_((char *)"refresh:mmap:%m");
      }
#line 216
      return (-1);
    }
#line 218
    lp->slotsfilled = 0;
#line 219
    needreslot = (bool )1;
  }
#line 222
  if (needreslot) {
#line 224
    ip = (lp->f)->info;
#line 227
    slot = 9;
    {
#line 227
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 227
      if (! (slot > -1)) {
#line 227
        goto while_break___0;
      }
#line 228
      if ((ip + slot)->hoffset) {
#line 229
        goto while_break___0;
      }
#line 227
      slot --;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 230
    lp->slotsfilled = slot + 1;
  }
#line 233
  return (0);
}
}
#line 33 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/art.c"
static size_t pagesize___5  =    (size_t )0;
#line 80 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/art.c"
static void file_unmap___1(void *p ) 
{ 
  struct fileobj *fp ;

  {
  {
#line 82
  fp = (struct fileobj *)p;
#line 84
  munmap((void *)fp->map, (size_t )fp->size);
#line 85
  free((void *)fp);
  }
#line 86
  return;
}
}
#line 88 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/art.c"
static int file_cmp___1(void *a , void *b___13 ) 
{ 
  struct fileobj *x ;
  struct fileobj *y ;
  int tmp ;

  {
  {
#line 90
  x = (struct fileobj *)a;
#line 91
  y = (struct fileobj *)b___13;
#line 93
  tmp = strcmp((char const   *)x->path, (char const   *)y->path);
  }
#line 93
  return (tmp);
}
}
#line 96 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/art.c"
static int desc___6  =    -1;
#line 98 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/art.c"
static int file_init___1(void) 
{ 


  {
  {
#line 100
  desc___6 = cache_init(8, & file_cmp___1, & file_unmap___1, (int (*)(void * ))((void *)0));
  }
#line 101
  if (-1 == desc___6) {
    {
#line 103
    log_((char *)"file_init:%m");
    }
#line 104
    return (-1);
  }
#line 106
  return (0);
}
}
#line 109 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/art.c"
static struct file *file_gimme___1(char *name , int *size___1 ) 
{ 
  struct fileobj f___9 ;
  struct fileobj *fp ;
  void *tmp ;

  {
  {
#line 111
  f___9.path = (char *)0;
#line 111
  f___9.map = (char *)0;
#line 111
  f___9.size = 0;
#line 114
  f___9.path = name;
#line 116
  tmp = cache_find(desc___6, (void *)(& f___9));
#line 116
  fp = (struct fileobj *)tmp;
  }
#line 116
  if ((unsigned long )((void *)0) == (unsigned long )fp) {
    {
#line 118
    fp = file_map(name);
    }
#line 118
    if ((unsigned long )((void *)0) == (unsigned long )fp) {
#line 119
      return ((struct file *)((void *)0));
    } else {
      {
#line 121
      cache_insert(desc___6, (void *)fp);
      }
    }
  }
#line 124
  if (size___1) {
#line 125
    *size___1 = fp->size;
  }
#line 126
  return ((struct file *)fp->map);
}
}
#line 137 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/art.c"
static bool file_initialized___1  =    (bool )0;
#line 248 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/art.c"
static char ngroup___1[287]  ;
#line 297 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/art.c"
static int getfield___1(char *buf___28 , struct field *f___9 ) 
{ 
  register char *cp ;
  size_t tmp ;
  size_t tmp___0 ;

  {
  {
#line 299
  cp = buf___28;
#line 301
  tmp = strspn((char const   *)cp, " \t\f");
#line 301
  cp += tmp;
  }
#line 302
  if (! *cp) {
#line 304
    f___9->pointer = (char *)((void *)0);
#line 305
    return (0);
  }
  {
#line 307
  tmp___0 = strcspn((char const   *)cp, "\r\n");
#line 307
  f___9->len = (int )tmp___0;
  }
#line 308
  if (! f___9->len) {
#line 309
    return (0);
  }
#line 310
  f___9->pointer = cp;
#line 311
  return ((int )((cp + f___9->len) - buf___28));
}
}
#line 383 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/art.c"
static struct b b___1  =    {(char *)0, 0, 0};
#line 105 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/dh_find.c"
static int initfile___3(void) 
{ 
  int fd ;
  int integer ;
  int i ;
  char foo[3] ;
  unsigned int tmp ;
  int *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  ssize_t tmp___3 ;
  ssize_t tmp___4 ;

  {
#line 108
  integer = 218885376;
#line 110
  foo[0] = (char )'\000';
#line 110
  tmp = 1U;
  {
#line 110
  while (1) {
    while_continue: /* CIL Label */ ;
#line 110
    if (tmp >= 3U) {
#line 110
      goto while_break;
    }
#line 110
    foo[tmp] = (char)0;
#line 110
    tmp ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 112
  fd = open((char const   *)(dh_tablefile), 194, 420);
  }
#line 113
  if (fd == -1) {
#line 114
    return (-1);
  }
  {
#line 115
  tmp___2 = lockf(fd, 2, (__off_t )0);
  }
#line 115
  if (tmp___2 == -1) {
    {
#line 117
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 119
      tmp___0 = __errno_location();
      }
#line 119
      if (*tmp___0 == 11) {
        {
#line 120
        nap(0, 200);
        }
      } else {
#line 122
        goto fail;
      }
      {
#line 117
      tmp___1 = lockf(fd, 2, (__off_t )0);
      }
#line 117
      if (! (tmp___1 == -1)) {
#line 117
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 125
    lockf(fd, 0, (__off_t )0);
    }
#line 126
    return (fd);
  }
  {
#line 128
  tmp___3 = write(fd, (void const   *)(& integer), sizeof(int ));
  }
#line 128
  if ((unsigned long )tmp___3 != sizeof(int )) {
#line 129
    goto fail;
  }
#line 130
  i = 0;
  {
#line 130
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 130
    if (! (i < 10240)) {
#line 130
      goto while_break___1;
    }
    {
#line 131
    tmp___4 = write(fd, (void const   *)(foo), sizeof(foo));
    }
#line 131
    if ((unsigned long )tmp___4 != sizeof(foo)) {
#line 132
      goto fail;
    }
#line 130
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 133
  lseek(fd, (__off_t )0, 0);
#line 134
  lockf(fd, 0, (__off_t )0);
  }
#line 135
  return (fd);
  fail: 
#line 138
  if (fd > -1) {
    {
#line 139
    close(fd);
    }
  }
#line 140
  return (-1);
}
}
#line 78 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/allocate.c"
static struct table___1 table___2  =    {(char *)0, (char *)0, 0, 0, 0, 0};
#line 80
static int remapfile___1(void) ;
#line 106 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/allocate.c"
static int initfile___4(char *filename ) 
{ 
  struct chainfile cf ;
  int fd ;
  int i ;
  int ret ;
  ssize_t tmp ;
  int pad ;
  ssize_t tmp___0 ;

  {
  {
#line 108
  cf.chain_magic = 0;
#line 108
  cf.next[0] = 0;
#line 108
  cf.next[1] = 0;
#line 108
  cf.next[2] = 0;
#line 108
  cf.next[3] = 0;
#line 108
  cf.next[4] = 0;
#line 108
  cf.next[5] = 0;
#line 108
  cf.next[6] = 0;
#line 108
  cf.next[7] = 0;
#line 108
  cf.next[8] = 0;
#line 108
  cf.next[9] = 0;
#line 108
  cf.next[10] = 0;
#line 108
  cf.next[11] = 0;
#line 108
  cf.next[12] = 0;
#line 108
  cf.next[13] = 0;
#line 108
  cf.next[14] = 0;
#line 108
  cf.next[15] = 0;
#line 108
  cf.next[16] = 0;
#line 108
  cf.next[17] = 0;
#line 108
  cf.next[18] = 0;
#line 108
  cf.next[19] = 0;
#line 108
  cf.next[20] = 0;
#line 108
  cf.next[21] = 0;
#line 108
  cf.next[22] = 0;
#line 108
  cf.next[23] = 0;
#line 108
  cf.next[24] = 0;
#line 108
  cf.next[25] = 0;
#line 108
  cf.next[26] = 0;
#line 108
  cf.next[27] = 0;
#line 108
  cf.next[28] = 0;
#line 108
  cf.next[29] = 0;
#line 108
  cf.next[30] = 0;
#line 108
  cf.next[31] = 0;
#line 108
  cf.next[32] = 0;
#line 108
  cf.next[33] = 0;
#line 108
  cf.next[34] = 0;
#line 108
  cf.next[35] = 0;
#line 108
  cf.next[36] = 0;
#line 108
  cf.next[37] = 0;
#line 108
  cf.next[38] = 0;
#line 108
  cf.next[39] = 0;
#line 108
  cf.next[40] = 0;
#line 108
  cf.next[41] = 0;
#line 108
  cf.next[42] = 0;
#line 108
  cf.next[43] = 0;
#line 108
  cf.next[44] = 0;
#line 108
  cf.next[45] = 0;
#line 108
  cf.next[46] = 0;
#line 108
  cf.next[47] = 0;
#line 108
  cf.next[48] = 0;
#line 108
  cf.next[49] = 0;
#line 108
  cf.next[50] = 0;
#line 108
  cf.next[51] = 0;
#line 108
  cf.next[52] = 0;
#line 108
  cf.next[53] = 0;
#line 108
  cf.next[54] = 0;
#line 108
  cf.next[55] = 0;
#line 108
  cf.next[56] = 0;
#line 108
  cf.next[57] = 0;
#line 108
  cf.next[58] = 0;
#line 108
  cf.next[59] = 0;
#line 108
  cf.next[60] = 0;
#line 108
  cf.next[61] = 0;
#line 108
  cf.next[62] = 0;
#line 111
  ret = 0;
#line 113
  fd = open((char const   *)filename, 578, 420);
  }
#line 114
  if (-1 == fd) {
#line 115
    return (-1);
  }
#line 116
  cf.chain_magic = 13680336;
#line 117
  i = 0;
  {
#line 117
  while (1) {
    while_continue: /* CIL Label */ ;
#line 117
    if (! (i < 63)) {
#line 117
      goto while_break;
    }
#line 118
    cf.next[i] = (int volatile   )0;
#line 117
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 119
  tmp = write(fd, (void const   *)(& cf), sizeof(cf));
#line 119
  i = (int )tmp;
  }
#line 120
  if ((unsigned long )i == sizeof(cf)) {
#line 124
    pad = (int )(sizeof(cf) % 4UL);
#line 125
    if (pad > 0) {
#line 126
      i = 0;
      {
#line 126
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 126
        if (i < pad) {
#line 126
          if (! (0 == ret)) {
#line 126
            goto while_break___0;
          }
        } else {
#line 126
          goto while_break___0;
        }
        {
#line 127
        tmp___0 = write(fd, (void const   *)"", (size_t )1);
        }
#line 127
        if (1L != tmp___0) {
#line 128
          ret = -1;
        }
#line 126
        i ++;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
  } else {
#line 131
    ret = -1;
  }
  {
#line 132
  close(fd);
  }
#line 133
  return (ret);
}
}
#line 136 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/allocate.c"
static void unmapfile___1(void) 
{ 


  {
#line 138
  if (table___2.fd >= 0) {
    {
#line 140
    close(table___2.fd);
#line 141
    table___2.fd = -1;
    }
  }
#line 143
  if (table___2.map) {
    {
#line 145
    munmap((void *)table___2.map, (size_t )table___2.size);
#line 146
    table___2.map = (char *)((void *)0);
#line 147
    table___2.size = 0;
    }
  }
#line 149
  return;
}
}
#line 153
static size_t rounduptopagesize___1(size_t size___1 ) ;
#line 153 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/allocate.c"
static size_t pagesize___6  =    (size_t )0;
#line 151 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/allocate.c"
static size_t rounduptopagesize___1(size_t size___1 ) 
{ 
  int pages ;
  int tmp ;

  {
#line 156
  if (0UL == pagesize___6) {
    {
#line 157
    tmp = getpagesize();
#line 157
    pagesize___6 = (size_t )tmp;
    }
  }
#line 158
  pages = (int )(size___1 / pagesize___6 + 1UL);
#line 159
  return ((size_t )pages * pagesize___6);
}
}
#line 162 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/allocate.c"
static int mapfile___1(void) 
{ 
  struct stat st ;
  int tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;

  {
#line 166
  if (-1 == table___2.fd) {
    {
#line 167
    table___2.fd = open((char const   *)table___2.filename, table___2.oflag, 420);
    }
  }
#line 168
  if (-1 == table___2.fd) {
#line 169
    goto fail;
  }
  {
#line 171
  tmp = fstat(table___2.fd, & st);
  }
#line 171
  if (-1 == tmp) {
#line 172
    goto fail;
  }
  {
#line 173
  tmp___0 = rounduptopagesize___1((size_t )st.st_size);
#line 173
  table___2.size = (int )tmp___0;
#line 174
  tmp___1 = mmap((void *)0, (size_t )table___2.size, table___2.mprot, 1, table___2.fd,
                 (__off_t )0);
#line 174
  table___2.map = (char *)tmp___1;
  }
#line 175
  if (! table___2.map) {
#line 176
    goto fail;
  } else
#line 175
  if ((unsigned long )table___2.map == (unsigned long )((void *)-1)) {
#line 176
    goto fail;
  }
#line 178
  return (0);
  fail: 
  {
#line 181
  unmapfile___1();
  }
#line 182
  return (-1);
}
}
#line 189 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/allocate.c"
static int remapfile___1(void) 
{ 
  struct stat st ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 193
  tmp = fstat(table___2.fd, & st);
  }
#line 193
  if (-1 == tmp) {
#line 194
    return (-1);
  }
#line 196
  if (st.st_size <= (__off_t )table___2.size) {
#line 197
    return (0);
  }
  {
#line 199
  munmap((void *)table___2.map, (size_t )table___2.size);
#line 200
  tmp___0 = mapfile___1();
  }
#line 200
  return (tmp___0);
}
}
#line 209 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/allocate.c"
static int lock___1(void) 
{ 
  int *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 211
  tmp___2 = lockf(table___2.fd, 2, (__off_t )0);
  }
#line 211
  if (-1 == tmp___2) {
    {
#line 213
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 215
      tmp = __errno_location();
      }
#line 215
      if (11 != *tmp) {
#line 216
        return (-1);
      } else {
        {
#line 218
        nap(0, 200);
        }
      }
      {
#line 213
      tmp___0 = lockf(table___2.fd, 2, (__off_t )0);
      }
#line 213
      if (! (-1 == tmp___0)) {
#line 213
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 221
    tmp___1 = remapfile___1();
    }
#line 221
    if (-1 == tmp___1) {
#line 222
      return (-1);
    }
  }
#line 224
  return (0);
}
}
#line 227 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/allocate.c"
static void unlock___1(void) 
{ 


  {
  {
#line 229
  lseek(table___2.fd, (__off_t )0, 0);
#line 230
  lockf(table___2.fd, 0, (__off_t )0);
  }
#line 231
  return;
}
}
#line 233 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/allocate.c"
static int checkvalidfile___1(void) 
{ 


  {
#line 235
  if (table___2.size > 0) {
#line 237
    if ((unsigned long )table___2.size < sizeof(struct chainfile )) {
#line 238
      return (-1);
    }
#line 239
    if (((struct chainfile *)table___2.map)->chain_magic != 13680336) {
#line 240
      return (-1);
    }
  }
#line 242
  return (0);
}
}
#line 281 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/allocate.c"
static int rounduptoalignment___1(int size___1 ) 
{ 


  {
#line 283
  if (size___1 <= 0) {
#line 284
    return (4);
  }
#line 285
  return (((size___1 - 1) / 4 + 1) * 4);
}
}
#line 296 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/allocate.c"
static char tmpchunk___1[272]  = {      (char )'\000'};
#line 56 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/dhash.c"
static unsigned char buf___3[2]  ;
#line 54 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/dhash.c"
static char *inttochar2___1(int integer ) 
{ 


  {
#line 58
  buf___3[0] = (unsigned char )((integer & 65535) >> 8);
#line 59
  buf___3[1] = (unsigned char )(integer & 255);
#line 60
  return ((char *)(buf___3));
}
}
#line 65 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/dhash.c"
static unsigned char buf___4[3]  ;
#line 63 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/dhash.c"
static char *inttochar3___1(unsigned int integer ) 
{ 


  {
#line 67
  integer >>= 2;
#line 68
  buf___4[0] = (unsigned char )((integer & 16777215U) >> 16);
#line 69
  buf___4[1] = (unsigned char )((integer & 65535U) >> 8);
#line 70
  buf___4[2] = (unsigned char )(integer & 255U);
#line 71
  return ((char *)(buf___4));
}
}
#line 35 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/newsgroup.c"
static struct ng *bygroup___1[128]  ;
#line 36 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/newsgroup.c"
static struct ng *byident___1[128]  ;
#line 37 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/newsgroup.c"
static int highest___1  =    0;
#line 39 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/newsgroup.c"
static unsigned int hash___3(char *buf___28 , int len ) 
{ 
  unsigned int h ;
  char *tmp ;

  {
#line 43
  h = 5381U;
  {
#line 44
  while (1) {
    while_continue: /* CIL Label */ ;
#line 44
    if (! len) {
#line 44
      goto while_break;
    }
#line 46
    len --;
#line 47
    h += h << 5;
#line 48
    tmp = buf___28;
#line 48
    buf___28 ++;
#line 48
    h ^= (unsigned int )*tmp;
  }
  while_break: /* CIL Label */ ;
  }
#line 50
  return (h);
}
}
#line 53 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/newsgroup.c"
static struct chunk *chunks___1  ;
#line 58 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/newsgroup.c"
static int avail___3  =    0;
#line 59 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/newsgroup.c"
static int nr___2  =    0;
#line 64 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/newsgroup.c"
static int add___2(int ident , char *group , int len ) 
{ 
  struct ng *np ;
  struct ng *p ;
  int want ;
  unsigned int h ;
  struct chunk *tmp ;
  int size___1 ;
  void *tmp___0 ;
  unsigned int tmp___1 ;
  int tmp___2 ;

  {
#line 71
  len ++;
#line 72
  want = (int )(((unsigned long )len + sizeof(struct ng )) + sizeof(char *));
#line 73
  want = (int )((unsigned long )want - (unsigned long )len % sizeof(char *));
#line 74
  len --;
#line 76
  if (avail___3 < want) {
#line 81
    if (want > 240) {
#line 81
      size___1 = want + 240;
    } else {
#line 81
      size___1 = 240;
    }
    {
#line 82
    tmp___0 = malloc((size_t )size___1);
#line 82
    tmp = (struct chunk *)tmp___0;
    }
#line 82
    if (! tmp) {
#line 83
      return (-1);
    }
#line 84
    tmp->next = chunks___1;
#line 85
    chunks___1 = tmp;
#line 86
    chunks___1->buf = (char *)chunks___1 + sizeof(struct chunk );
#line 87
    avail___3 = (int )((unsigned long )size___1 - sizeof(struct chunk ));
  }
  {
#line 89
  np = (struct ng *)chunks___1->buf;
#line 90
  chunks___1->buf += want;
#line 91
  avail___3 -= want;
#line 92
  strncpy((char */* __restrict  */)(np->group), (char const   */* __restrict  */)group,
          (size_t )len);
#line 93
  np->group[len] = (char )'\000';
#line 94
  np->ident = ident;
#line 96
  tmp___1 = hash___3(group, len);
#line 96
  h = tmp___1 % 128U;
#line 97
  np->gnext = bygroup___1[h];
#line 98
  bygroup___1[h] = np;
#line 99
  p = np->gnext;
  }
  {
#line 99
  while (1) {
    while_continue: /* CIL Label */ ;
#line 99
    if (! p) {
#line 99
      goto while_break;
    }
    {
#line 100
    tmp___2 = strcmp((char const   *)(p->group), (char const   *)group);
    }
#line 100
    if (0 == tmp___2) {
#line 101
      return (1);
    }
#line 99
    p = p->gnext;
  }
  while_break: /* CIL Label */ ;
  }
#line 102
  h = (unsigned int )(ident % 128);
#line 103
  np->inext = byident___1[h];
#line 104
  byident___1[h] = np;
#line 105
  p = np->inext;
  {
#line 105
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 105
    if (! p) {
#line 105
      goto while_break___0;
    }
#line 106
    if (p->ident == ident) {
#line 107
      return (1);
    }
#line 105
    p = p->inext;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 109
  if (ident > highest___1) {
#line 110
    highest___1 = ident;
  }
#line 111
  nr___2 ++;
#line 112
  return (0);
}
}
#line 116 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/newsgroup.c"
static int groupfd___1  =    -1;
#line 117 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/newsgroup.c"
static int oldsize___1  =    0;
#line 118 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/newsgroup.c"
static int mapsize___1  =    0;
#line 119 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/newsgroup.c"
static char *mapbuf___1  =    (char *)((void *)0);
#line 148
static int reload___1(void) ;
#line 148 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/newsgroup.c"
static int pagesize___7  =    0;
#line 145 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/newsgroup.c"
static int reload___1(void) 
{ 
  struct stat st ;
  int newsize ;
  int tmp ;
  void *tmp___0 ;
  char *p ;
  char *lim ;
  char *ip ;
  char *gr ;
  int ident ;
  int state ;
  int tmp___1 ;

  {
  {
#line 156
  tmp = fstat(groupfd___1, & st);
  }
#line 156
  if (-1 == tmp) {
    {
#line 158
    log_((char *)"reload:fstat:%m");
    }
#line 159
    return (-1);
  }
#line 161
  newsize = (int )st.st_size;
#line 162
  if (! pagesize___7) {
    {
#line 163
    pagesize___7 = getpagesize();
    }
  }
#line 164
  if (newsize <= oldsize___1) {
#line 165
    return (0);
  }
#line 166
  if (newsize > mapsize___1) {
#line 166
    goto _L;
  } else
#line 166
  if (! mapsize___1) {
    _L: /* CIL Label */ 
#line 168
    if (mapbuf___1) {
      {
#line 169
      munmap((void *)mapbuf___1, (size_t )mapsize___1);
      }
    }
    {
#line 170
    mapsize___1 = (int )((st.st_size + (__off_t )pagesize___7) - st.st_size % (long )pagesize___7);
#line 171
    tmp___0 = mmap((void *)0, (size_t )mapsize___1, 1, 1, groupfd___1, (__off_t )0);
#line 171
    mapbuf___1 = (char *)tmp___0;
    }
#line 172
    if (! mapbuf___1) {
      {
#line 174
      log_((char *)"reload:mmap:%m");
      }
#line 175
      return (-1);
    } else
#line 172
    if ((unsigned long )mapbuf___1 == (unsigned long )((void *)-1)) {
      {
#line 174
      log_((char *)"reload:mmap:%m");
      }
#line 175
      return (-1);
    }
  }
#line 188
  lim = mapbuf___1 + newsize;
#line 189
  state = 0;
#line 189
  ident = state;
#line 190
  gr = (char *)0;
#line 190
  ip = gr;
#line 191
  p = mapbuf___1 + oldsize___1;
  {
#line 191
  while (1) {
    while_continue: /* CIL Label */ ;
#line 191
    if (! ((unsigned long )p < (unsigned long )lim)) {
#line 191
      goto while_break;
    }
    {
#line 194
    if (state == 0) {
#line 194
      goto case_0;
    }
#line 195
    if (state == 1) {
#line 195
      goto case_1;
    }
#line 196
    if (state == 2) {
#line 196
      goto case_2;
    }
#line 197
    if (state == 3) {
#line 197
      goto case_3;
    }
#line 192
    goto switch_break;
    case_0: /* CIL Label */ 
#line 194
    if ((int )*p >= 48) {
#line 194
      if ((int )*p <= 57) {
#line 194
        ip = p;
#line 194
        state ++;
      }
    }
#line 194
    goto switch_break;
    case_1: /* CIL Label */ 
#line 195
    if (32 == (int )*p) {
      {
#line 195
      ident = atoi((char const   *)ip);
#line 195
      state ++;
      }
    }
#line 195
    goto switch_break;
    case_2: /* CIL Label */ 
#line 196
    if (32 != (int )*p) {
#line 196
      gr = p;
#line 196
      state ++;
    }
#line 196
    goto switch_break;
    case_3: /* CIL Label */ 
#line 198
    if (10 != (int )*p) {
#line 199
      goto switch_break;
    }
    {
#line 200
    tmp___1 = add___2(ident, gr, (int )(p - gr));
    }
#line 200
    if (-1 == tmp___1) {
      {
#line 202
      log_((char *)"reload:no memory");
      }
#line 203
      return (-1);
    }
#line 205
    state = 0;
    switch_break: /* CIL Label */ ;
    }
#line 191
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 208
  oldsize___1 = newsize;
#line 209
  return (0);
}
}
#line 26 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/key.c"
static struct buf *head___2  ;
#line 27 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/key.c"
static int avail___4  =    0;
#line 28 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/key.c"
static char *keybuf___1  =    (char *)((void *)0);
#line 33 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/key.c"
static unsigned int hv___1  ;
#line 35 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/key.c"
static void hash___4(char *key , int len ) 
{ 
  char *tmp ;

  {
#line 37
  hv___1 = 5381U;
  {
#line 38
  while (1) {
    while_continue: /* CIL Label */ ;
#line 38
    if (! len) {
#line 38
      goto while_break;
    }
#line 40
    len --;
#line 41
    hv___1 += hv___1 << 5;
#line 42
    tmp = key;
#line 42
    key ++;
#line 42
    hv___1 ^= (unsigned int )*tmp;
  }
  while_break: /* CIL Label */ ;
  }
#line 44
  hv___1 %= 128U;
#line 45
  return;
}
}
#line 36 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/lib/readln.h"
int readln_ready(int fd , int tmo , struct readln *rp ) ;
#line 31 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/snfetch.c"
struct readln input  =    {0, (char *)0, {(char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                   (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                   (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                   (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                   (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                   (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                   (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                   (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                   (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                   (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                   (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                   (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                   (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                   (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                   (char)0, (char)0, (char)0, (char)0, (char)0, (char)0}, 0, 0, 0,
    0};
#line 32 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/snfetch.c"
bool newsbatch  =    (bool )0;
#line 33 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/snfetch.c"
int pipelining  =    0;
#line 35 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/snfetch.c"
int bytesin  =    0;
#line 36 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/snfetch.c"
int nrhave  ;
#line 37 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/snfetch.c"
int nrdup  ;
#line 39 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/snfetch.c"
static void nomem(void) 
{ 


  {
  {
#line 39
  fail(2, (char *)"No memory");
  }
#line 39
  return;
}
}
#line 40 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/snfetch.c"
static void badresponse(char *cmd ) 
{ 


  {
  {
#line 40
  log_((char *)"Bad response to %s, got \"%s\"", cmd, args_inbuf);
#line 40
  _exit(3);
  }
}
}
#line 41 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/snfetch.c"
static void badoutput(char *cmd , char *line ) 
{ 


  {
  {
#line 41
  log_((char *)"Bad output to %s, got \"%s\"", cmd, line);
  }
#line 41
  return;
}
}
#line 43 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/snfetch.c"
static int doread(void) 
{ 
  int i ;

  {
  {
#line 47
  i = args_read(& input);
  }
  {
#line 49
  if (i == -1) {
#line 49
    goto case_neg_1;
  }
#line 51
  if (i == 0) {
#line 51
    goto case_0;
  }
#line 47
  goto switch_break;
  case_neg_1: /* CIL Label */ 
  {
#line 50
  fail(2, (char *)"network read error:%m");
  }
  case_0: /* CIL Label */ 
  {
#line 52
  fail(3, (char *)"invalid reply :%s", args_inbuf);
  }
  switch_break: /* CIL Label */ ;
  }
#line 54
  return (i);
}
}
#line 57 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/snfetch.c"
static struct art *arts  =    (struct art *)((void *)0);
#line 62 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/snfetch.c"
static int nr_arts  =    0;
#line 66
static void addserial(int serial , char *messageid___0 , int len ) ;
#line 66 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/snfetch.c"
static int size  =    0;
#line 64 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/snfetch.c"
static void addserial(int serial , char *messageid___0 , int len ) 
{ 
  char *id ;
  int tmp ;
  struct art *tmp___0 ;
  int newsize ;
  void *tmp___1 ;
  int tmp___2 ;

  {
  {
#line 69
  id = messageid___0;
#line 70
  tmp = key_add(& id, len);
  }
  {
#line 72
  if (tmp == -1) {
#line 72
    goto case_neg_1;
  }
#line 74
  if (tmp == 1) {
#line 74
    goto case_1;
  }
#line 77
  if (tmp == 0) {
#line 77
    goto case_0;
  }
#line 70
  goto switch_break;
  case_neg_1: /* CIL Label */ 
  {
#line 73
  nomem();
  }
  case_1: /* CIL Label */ 
#line 75
  nrdup ++;
#line 76
  return;
  case_0: /* CIL Label */ ;
  switch_break: /* CIL Label */ ;
  }
#line 79
  if (nr_arts >= size) {
#line 84
    if (size) {
#line 84
      newsize = size * 2;
    } else {
#line 84
      newsize = 30;
    }
    {
#line 85
    tmp___1 = malloc(sizeof(*arts) * (unsigned long )newsize);
#line 85
    tmp___0 = (struct art *)tmp___1;
    }
#line 85
    if (! tmp___0) {
      {
#line 86
      nomem();
      }
    }
#line 87
    if (size) {
      {
#line 89
      memcpy((void */* __restrict  */)tmp___0, (void const   */* __restrict  */)arts,
             sizeof(*arts) * (unsigned long )size);
#line 90
      free((void *)arts);
      }
    }
#line 92
    arts = tmp___0;
#line 93
    size = newsize;
  }
#line 95
  (arts + nr_arts)->serial = serial;
#line 96
  tmp___2 = nr_arts;
#line 96
  nr_arts ++;
#line 96
  (arts + tmp___2)->id = id;
#line 97
  return;
}
}
#line 99 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/snfetch.c"
void sendstat(int from , int to ) 
{ 
  int i ;
  int n ;
  int p ;
  int stopwriting ;
  int startreading ;
  int tmp ;
  char *cp ;
  char *id ;
  char *end ;
  int tmp___0 ;
  unsigned long tmp___1 ;
  unsigned long tmp___2 ;

  {
#line 103
  if (debug) {
    {
#line 104
    log_((char *)"sendstat:trying");
    }
  }
#line 105
  p = to - from;
#line 105
  if (p > pipelining) {
#line 106
    p = pipelining;
  }
#line 108
  stopwriting = to;
#line 109
  to += p;
#line 110
  startreading = from + p;
#line 111
  n = from;
  {
#line 111
  while (1) {
    while_continue: /* CIL Label */ ;
#line 111
    if (! (n <= to)) {
#line 111
      goto while_break;
    }
#line 113
    if (n <= stopwriting) {
      {
#line 114
      tmp = args_write(7, (char *)"STAT %d\r\n", n);
      }
#line 114
      if (-1 == tmp) {
        {
#line 115
        fail(2, (char *)"sendstat:args_write:%m");
        }
      }
    }
#line 116
    if (n >= startreading) {
      {
#line 122
      tmp___0 = doread();
      }
#line 122
      if (tmp___0 < 3) {
        {
#line 123
        badresponse((char *)"STAT");
        }
      }
      {
#line 124
      tmp___1 = strtoul((char const   */* __restrict  */)args[0], (char **/* __restrict  */)(& end),
                        10);
#line 124
      i = (int )tmp___1;
      }
#line 125
      if (423 == i) {
#line 126
        goto __Cont;
      } else
#line 125
      if (430 == i) {
#line 126
        goto __Cont;
      }
#line 127
      if (223 == i) {
#line 127
        if (! *end) {
#line 128
          if (60 == (int )*(args[2] + 0)) {
            {
#line 129
            id = args[2] + 1;
#line 129
            cp = strchr((char const   *)id, '>');
            }
#line 129
            if (cp) {
              {
#line 131
              *cp = (char )'\000';
#line 132
              tmp___2 = strtoul((char const   */* __restrict  */)args[1], (char **/* __restrict  */)(& end),
                                10);
#line 132
              i = (int )tmp___2;
              }
#line 133
              if (i > 0) {
#line 133
                if (! *end) {
                  {
#line 135
                  addserial(i, id, (int )(cp - id));
                  }
#line 136
                  goto __Cont;
                }
              }
            }
          }
        }
      }
      {
#line 139
      badoutput((char *)"STAT", args_inbuf);
      }
    }
    __Cont: /* CIL Label */ 
#line 111
    n ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 142
  return;
}
}
#line 144 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/snfetch.c"
void sendxhdr(int from , int to ) 
{ 
  char *fmt ;
  unsigned long tmp ;
  char *line ;
  int len ;
  int serial ;
  char *cp ;
  char *id ;
  unsigned long tmp___0 ;

  {
#line 148
  if (-1 == to) {
#line 149
    fmt = (char *)"XHDR Message-Id %d-\r\n";
  } else {
#line 151
    fmt = (char *)"XHDR Message-Id %d-%d\r\n";
  }
  {
#line 152
  args_write(7, fmt, from, to);
#line 154
  doread();
#line 155
  tmp = strtoul((char const   */* __restrict  */)args[0], (char **/* __restrict  */)0,
                10);
  }
#line 155
  if (221UL != tmp) {
    {
#line 157
    sendstat(from, to);
    }
#line 158
    return;
  }
  {
#line 161
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 168
    len = readln(& input, & line, '\n');
    }
#line 169
    if (len <= 0) {
      {
#line 170
      fail(2, (char *)"readln:%m");
      }
    }
#line 171
    len --;
#line 171
    *(line + len) = (char )'\000';
#line 172
    if (len > 0) {
#line 173
      if (13 == (int )*(line + (len - 1))) {
#line 174
        len --;
#line 174
        *(line + len) = (char )'\000';
      }
    }
#line 175
    if (1 == len) {
#line 175
      if (46 == (int )*(line + 0)) {
#line 176
        return;
      }
    }
    {
#line 178
    tmp___0 = strtoul((char const   */* __restrict  */)line, (char **/* __restrict  */)(& cp),
                      10);
#line 178
    serial = (int )tmp___0;
    }
#line 179
    if (serial > 0) {
#line 180
      if (cp) {
#line 180
        if (32 == (int )*cp) {
#line 180
          goto _L;
        } else
#line 180
        if (9 == (int )*cp) {
          _L: /* CIL Label */ 
          {
#line 181
          cp = strchr((char const   *)cp, '<');
          }
#line 181
          if (cp) {
            {
#line 182
            id = cp + 1;
#line 182
            cp = strchr((char const   *)id, '>');
            }
#line 182
            if (cp) {
              {
#line 184
              *cp = (char )'\000';
#line 185
              addserial(serial, id, (int )(cp - id));
              }
#line 186
              goto __Cont;
            }
          }
        }
      }
    }
    {
#line 188
    badoutput((char *)"XHDR", line);
    }
    __Cont: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 196
void readprint(void) ;
#line 196 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/snfetch.c"
static struct b b___2  =    {(char *)0, 0, 0};
#line 192 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/snfetch.c"
void readprint(void) 
{ 
  int len ;
  char *line ;
  char *endline ;
  int endlinelen ;
  bool seenbreak ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char buf___28[64] ;
  struct iovec v[2] ;
  int tmp___2 ;
  ssize_t tmp___3 ;
  int tmp___4 ;
  ssize_t tmp___5 ;

  {
#line 201
  if (newsbatch) {
#line 203
    endline = (char *)"\n";
#line 204
    endlinelen = 1;
  } else {
#line 208
    endline = (char *)"\r\n";
#line 209
    endlinelen = 2;
  }
#line 212
  b___2.used = 0;
#line 213
  seenbreak = (bool )0;
  {
#line 214
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 214
    len = readln(& input, & line, '\n');
    }
#line 214
    if (! (len > 1)) {
#line 214
      goto while_break;
    }
#line 216
    bytesin += len;
#line 217
    len --;
#line 217
    *(line + len) = (char )'\000';
#line 218
    if (len > 0) {
#line 219
      if (13 == (int )*(line + (len - 1))) {
#line 220
        len --;
#line 220
        *(line + len) = (char )'\000';
      }
    }
#line 221
    if (0 == len) {
#line 222
      seenbreak = (bool )1;
    }
#line 223
    if (46 == (int )*line) {
#line 225
      if (1 == len) {
#line 226
        goto while_break;
      } else
#line 227
      if (newsbatch) {
#line 229
        line ++;
#line 230
        len --;
      }
    }
#line 233
    if (len) {
      {
#line 234
      tmp = b_appendl(& b___2, line, len);
      }
#line 234
      if (tmp) {
        {
#line 235
        nomem();
        }
      }
    }
    {
#line 236
    tmp___0 = b_appendl(& b___2, endline, endlinelen);
    }
#line 236
    if (tmp___0) {
      {
#line 237
      nomem();
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 240
  if (len <= 0) {
    {
#line 241
    fail(4, (char *)"readprint:readln:%m");
    }
  }
#line 242
  if (len != 1) {
    {
#line 243
    fail(3, (char *)"readprint:bad format");
    }
  }
#line 244
  if (! seenbreak) {
    {
#line 245
    tmp___1 = b_appendl(& b___2, endline, endlinelen);
    }
#line 245
    if (tmp___1) {
      {
#line 246
      nomem();
      }
    }
  }
#line 247
  if (newsbatch) {
    {
#line 252
    tmp___2 = formats(buf___28, (int )(sizeof(buf___28) - 1UL), (char *)"#! rnews %d\n",
                      b___2.used);
#line 252
    v[0].iov_len = (size_t )tmp___2;
#line 253
    v[0].iov_base = (void *)(buf___28);
#line 254
    v[1].iov_base = (void *)b___2.buf;
#line 255
    v[1].iov_len = (size_t )b___2.used;
#line 256
    tmp___3 = writev(1, (struct iovec  const  *)(v), 2);
#line 256
    len = (int )tmp___3;
    }
  } else {
    {
#line 260
    tmp___4 = b_appendl(& b___2, (char *)".\r\n", 3);
    }
#line 260
    if (tmp___4) {
      {
#line 261
      nomem();
      }
    }
    {
#line 262
    tmp___5 = write(1, (void const   *)b___2.buf, (size_t )b___2.used);
#line 262
    len = (int )tmp___5;
    }
  }
#line 264
  if (-1 == len) {
    {
#line 265
    fail(2, (char *)"readprint:write:%m");
    }
  }
#line 266
  return;
}
}
#line 268 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/snfetch.c"
int fetch(int *nr___13 ) 
{ 
  int n ;
  int p ;
  int collected ;
  int last___1 ;
  struct data d ;
  int tmp ;
  char *end ;
  int tmp___0 ;
  unsigned long tmp___1 ;
  unsigned long tmp___2 ;

  {
#line 272
  collected = 0;
#line 272
  last___1 = collected;
#line 273
  p = pipelining;
#line 274
  if (p > nr_arts) {
#line 275
    p = nr_arts;
  }
#line 276
  n = 0;
  {
#line 276
  while (1) {
    while_continue: /* CIL Label */ ;
#line 276
    if (! (n < nr_arts + p)) {
#line 276
      goto while_break;
    }
#line 278
    if (n < nr_arts) {
      {
#line 282
      d.messageid = (arts + n)->id;
#line 283
      tmp = dh_find(& d, (bool )0);
      }
#line 283
      if (0 == tmp) {
#line 285
        nrhave ++;
#line 286
        (arts + n)->serial = -1;
      } else {
        {
#line 289
        args_write(7, (char *)"ARTICLE %d\r\n", (arts + n)->serial);
        }
      }
    }
#line 291
    if (n >= p) {
#line 291
      if ((arts + (n - p))->serial > -1) {
        {
#line 295
        tmp___0 = doread();
        }
#line 295
        if (tmp___0 < 3) {
          {
#line 296
          badresponse((char *)"ARTICLE");
          }
        }
        {
#line 297
        tmp___1 = strtoul((char const   */* __restrict  */)args[0], (char **/* __restrict  */)(& end),
                          10);
        }
        {
#line 301
        if (tmp___1 == 220UL) {
#line 301
          goto case_220;
        }
#line 307
        if (tmp___1 == 423UL) {
#line 307
          goto case_423;
        }
#line 307
        if (tmp___1 == 430UL) {
#line 307
          goto case_423;
        }
#line 299
        goto switch_default;
        switch_default: /* CIL Label */ 
        {
#line 300
        badresponse((char *)"ARTICLE");
        }
        case_220: /* CIL Label */ 
        {
#line 302
        tmp___2 = strtoul((char const   */* __restrict  */)args[1], (char **/* __restrict  */)(& end),
                          10);
#line 302
        last___1 = (int )tmp___2;
#line 303
        readprint();
#line 304
        collected ++;
        }
#line 305
        goto switch_break;
        case_423: /* CIL Label */ 
        case_430: /* CIL Label */ 
#line 308
        if (*end) {
          {
#line 309
          fail(3, (char *)"fetch:Bad response to ARTICLE, got \"%s\"", args_inbuf);
          }
        }
        switch_break: /* CIL Label */ ;
        }
      }
    }
#line 276
    n ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 313
  *nr___13 = collected;
#line 314
  return (last___1);
}
}
#line 317 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/snfetch.c"
static int cat(char *fn , int *val ) 
{ 
  char buf___28[64] ;
  int i ;
  char *end ;
  int fd ;
  int tmp ;
  ssize_t tmp___0 ;
  unsigned long tmp___1 ;

  {
  {
#line 322
  tmp = open((char const   *)fn, 0);
#line 322
  fd = tmp;
  }
#line 324
  if (-1 == fd) {
#line 325
    return (-1);
  }
  {
#line 326
  tmp___0 = read(fd, (void *)(buf___28), sizeof(buf___28) - 1UL);
#line 326
  i = (int )tmp___0;
#line 327
  close(fd);
  }
#line 328
  if (-1 == i) {
#line 329
    return (-1);
  }
  {
#line 330
  buf___28[i] = (char )'\000';
#line 331
  tmp___1 = strtoul((char const   */* __restrict  */)(buf___28), (char **/* __restrict  */)(& end),
                    10);
#line 331
  *val = (int )tmp___1;
  }
#line 332
  if (*end) {
#line 332
    if ((int )*end != 10) {
#line 333
      return (-1);
    }
  }
#line 334
  return (0);
}
}
#line 26 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/body.c"
static char *bodbuf___1  =    (char *)((void *)0);
#line 18 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/snntpd.h"
int alltolower(char *buf___28 ) ;
#line 19
int topline(char *group , char *fn , char *buf___28 , int size___1 ) ;
#line 21
char *currentgroup ;
#line 22
int currentserial ;
#line 23
struct group currentinfo ;
#line 25
int make_current(char *group ) ;
#line 31 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/list.c"
static void listactive(void) 
{ 
  struct group g ;
  struct key *kp ;
  int i ;
  int j ;
  char *group ;
  char const   *tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 38
  args_write(1, (char *)"215 list follows\r\n");
#line 40
  j = nr_keys;
#line 40
  i = 0;
  }
  {
#line 40
  while (1) {
    while_continue: /* CIL Label */ ;
#line 40
    if (i < 128) {
#line 40
      if (! (j > 0)) {
#line 40
        goto while_break;
      }
    } else {
#line 40
      goto while_break;
    }
#line 40
    kp = key_table[i];
    {
#line 40
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 40
      if (! kp) {
#line 40
        goto while_break___0;
      }
#line 42
      group = (char *)kp + sizeof(struct key );
#line 43
      if (! args[1]) {
#line 43
        goto _L;
      } else
#line 43
      if (! args[2]) {
#line 43
        goto _L;
      } else {
        {
#line 43
        tmp___1 = wildmat(group, args[2]);
        }
#line 43
        if (tmp___1) {
          _L: /* CIL Label */ 
          {
#line 44
          tmp___0 = group_info(group, & g);
          }
#line 44
          if (0 == tmp___0) {
#line 45
            if (g.nopost) {
#line 45
              tmp = "n";
            } else {
#line 45
              tmp = "y";
            }
            {
#line 45
            args_write(1, (char *)"%s %d %d %s\r\n", group, g.last, g.first, tmp);
            }
          }
        }
      }
#line 40
      kp = kp->next;
#line 40
      j --;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 40
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 48
  args_write(1, (char *)".\r\n");
  }
#line 49
  return;
}
}
#line 53 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/list.c"
static void listoverviewfmt(void) 
{ 


  {
  {
#line 55
  args_write(1, (char *)"215 ok\r\n");
#line 56
  args_write(1, (char *)"Subject:\r\nFrom:\r\nDate:\r\nMessage-ID:\r\nReferences:\r\nBytes:\r\nLines:\r\nXref:full\r\n.\r\n");
  }
#line 60
  return;
}
}
#line 62 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/list.c"
static void listnewsgroups(void) 
{ 
  char *group ;
  int i ;
  int j ;
  struct key *kp ;
  char buf___28[128] ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 64
  args_write(1, (char *)"215 Here you go\r\n");
  }
#line 66
  if (nr_keys > 0) {
#line 72
    j = nr_keys;
#line 72
    i = 0;
    {
#line 72
    while (1) {
      while_continue: /* CIL Label */ ;
#line 72
      if (i < 128) {
#line 72
        if (! (j > 0)) {
#line 72
          goto while_break;
        }
      } else {
#line 72
        goto while_break;
      }
#line 72
      kp = key_table[i];
      {
#line 72
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 72
        if (! kp) {
#line 72
          goto while_break___0;
        }
#line 74
        group = (char *)kp + sizeof(struct key );
#line 75
        if (! args[2]) {
#line 75
          goto _L;
        } else {
          {
#line 75
          tmp___0 = wildmat(group, args[2]);
          }
#line 75
          if (tmp___0) {
            _L: /* CIL Label */ 
            {
#line 79
            tmp = topline(group, (char *)".info", buf___28, (int )sizeof(buf___28));
            }
#line 79
            if (tmp <= 0) {
#line 80
              buf___28[0] = (char )'\000';
            }
            {
#line 81
            args_write(1, (char *)"%s %s\r\n", group, buf___28);
            }
          }
        }
#line 72
        kp = kp->next;
#line 72
        j --;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 72
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 85
  args_write(1, (char *)".\r\n");
  }
#line 86
  return;
}
}
#line 90 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/list.c"
static void listdistribpats(void) 
{ 


  {
  {
#line 92
  args_write(1, (char *)"215 ok\r\n");
#line 93
  args_write(1, (char *)".\r\n");
  }
#line 94
  return;
}
}
#line 96 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/list.c"
void do_list(void) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 98
  if (args[1]) {
    {
#line 100
    tmp___2 = strcasecmp((char const   *)args[1], "active");
    }
#line 100
    if (0 == tmp___2) {
      {
#line 101
      listactive();
      }
    } else {
      {
#line 102
      tmp___1 = strcasecmp((char const   *)args[1], "newsgroups");
      }
#line 102
      if (0 == tmp___1) {
        {
#line 103
        listnewsgroups();
        }
      } else {
        {
#line 104
        tmp___0 = strcasecmp((char const   *)args[1], "overview.fmt");
        }
#line 104
        if (0 == tmp___0) {
          {
#line 105
          listoverviewfmt();
          }
        } else {
          {
#line 106
          tmp = strcasecmp((char const   *)args[1], "distrib.pats");
          }
#line 106
          if (0 == tmp) {
            {
#line 107
            listdistribpats();
            }
          } else {
            {
#line 109
            args_write(1, (char *)"503 \"LIST %s\" command not implemented\r\n", args[1]);
            }
          }
        }
      }
    }
  } else {
    {
#line 112
    listactive();
    }
  }
#line 113
  return;
}
}
#line 115 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/list.c"
void do_listgroup(void) 
{ 
  struct article bogus ;
  int i ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 120
  if (args[1]) {
    {
#line 122
    tmp = alltolower(args[1]);
    }
#line 122
    if (tmp > 255) {
      {
#line 124
      args_write(1, (char *)"411 No such group\r\n");
      }
#line 125
      return;
    } else {
      {
#line 122
      tmp___0 = make_current(args[1]);
      }
#line 122
      if (tmp___0) {
        {
#line 124
        args_write(1, (char *)"411 No such group\r\n");
        }
#line 125
        return;
      }
    }
  } else
#line 128
  if (! currentgroup) {
    {
#line 130
    args_write(1, (char *)"412 No group selected\r\n");
    }
#line 131
    return;
  }
  {
#line 133
  args_write(1, (char *)"211 Article numbers follow\r\n");
#line 134
  i = currentinfo.first;
  }
  {
#line 134
  while (1) {
    while_continue: /* CIL Label */ ;
#line 134
    if (! (i <= currentinfo.last)) {
#line 134
      goto while_break;
    }
    {
#line 135
    tmp___1 = art_gimme(currentgroup, i, & bogus);
    }
#line 135
    if (0 == tmp___1) {
      {
#line 136
      writef(1, (char *)"%d\r\n", i);
      }
    }
#line 134
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 137
  args_write(1, (char *)".\r\n");
#line 138
  currentserial = currentinfo.first;
  }
#line 139
  return;
}
}
#line 26 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/body.c"
static char *bodbuf___2  =    (char *)((void *)0);
#line 26 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/key.c"
static struct buf *head___3  ;
#line 27 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/key.c"
static int avail___5  =    0;
#line 28 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/key.c"
static char *keybuf___2  =    (char *)((void *)0);
#line 33 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/key.c"
static unsigned int hv___2  ;
#line 35 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/key.c"
static void hash___5(char *key , int len ) 
{ 
  char *tmp ;

  {
#line 37
  hv___2 = 5381U;
  {
#line 38
  while (1) {
    while_continue: /* CIL Label */ ;
#line 38
    if (! len) {
#line 38
      goto while_break;
    }
#line 40
    len --;
#line 41
    hv___2 += hv___2 << 5;
#line 42
    tmp = key;
#line 42
    key ++;
#line 42
    hv___2 ^= (unsigned int )*tmp;
  }
  while_break: /* CIL Label */ ;
  }
#line 44
  hv___2 %= 128U;
#line 45
  return;
}
}
#line 16 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/lib/statf.c"
static char buf___5[4097]  ;
#line 18 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/lib/statf.c"
int statf(struct stat *stp , char *fmt  , ...) 
{ 
  int len ;
  va_list ap ;
  int *tmp ;
  int tmp___0 ;

  {
  {
#line 23
  __builtin_va_start(ap, fmt);
#line 24
  len = formatv(buf___5, (int )(sizeof(buf___5) - 1UL), fmt, ap);
#line 25
  __builtin_va_end(ap);
  }
#line 27
  if ((unsigned long )len >= sizeof(buf___5)) {
    {
#line 29
    tmp = __errno_location();
#line 29
    *tmp = 36;
    }
#line 30
    return (-1);
  }
  {
#line 32
  tmp___0 = stat((char const   */* __restrict  */)(buf___5), (struct stat */* __restrict  */)stp);
  }
#line 32
  return (tmp___0);
}
}
#line 33 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/art.c"
static size_t pagesize___8  =    (size_t )0;
#line 80 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/art.c"
static void file_unmap___2(void *p ) 
{ 
  struct fileobj *fp ;

  {
  {
#line 82
  fp = (struct fileobj *)p;
#line 84
  munmap((void *)fp->map, (size_t )fp->size);
#line 85
  free((void *)fp);
  }
#line 86
  return;
}
}
#line 88 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/art.c"
static int file_cmp___2(void *a , void *b___13 ) 
{ 
  struct fileobj *x ;
  struct fileobj *y ;
  int tmp ;

  {
  {
#line 90
  x = (struct fileobj *)a;
#line 91
  y = (struct fileobj *)b___13;
#line 93
  tmp = strcmp((char const   *)x->path, (char const   *)y->path);
  }
#line 93
  return (tmp);
}
}
#line 96 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/art.c"
static int desc___7  =    -1;
#line 98 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/art.c"
static int file_init___2(void) 
{ 


  {
  {
#line 100
  desc___7 = cache_init(8, & file_cmp___2, & file_unmap___2, (int (*)(void * ))((void *)0));
  }
#line 101
  if (-1 == desc___7) {
    {
#line 103
    log_((char *)"file_init:%m");
    }
#line 104
    return (-1);
  }
#line 106
  return (0);
}
}
#line 109 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/art.c"
static struct file *file_gimme___2(char *name , int *size___1 ) 
{ 
  struct fileobj f___9 ;
  struct fileobj *fp ;
  void *tmp ;

  {
  {
#line 111
  f___9.path = (char *)0;
#line 111
  f___9.map = (char *)0;
#line 111
  f___9.size = 0;
#line 114
  f___9.path = name;
#line 116
  tmp = cache_find(desc___7, (void *)(& f___9));
#line 116
  fp = (struct fileobj *)tmp;
  }
#line 116
  if ((unsigned long )((void *)0) == (unsigned long )fp) {
    {
#line 118
    fp = file_map(name);
    }
#line 118
    if ((unsigned long )((void *)0) == (unsigned long )fp) {
#line 119
      return ((struct file *)((void *)0));
    } else {
      {
#line 121
      cache_insert(desc___7, (void *)fp);
      }
    }
  }
#line 124
  if (size___1) {
#line 125
    *size___1 = fp->size;
  }
#line 126
  return ((struct file *)fp->map);
}
}
#line 137 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/art.c"
static bool file_initialized___2  =    (bool )0;
#line 248 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/art.c"
static char ngroup___2[287]  ;
#line 297 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/art.c"
static int getfield___2(char *buf___28 , struct field *f___9 ) 
{ 
  register char *cp ;
  size_t tmp ;
  size_t tmp___0 ;

  {
  {
#line 299
  cp = buf___28;
#line 301
  tmp = strspn((char const   *)cp, " \t\f");
#line 301
  cp += tmp;
  }
#line 302
  if (! *cp) {
#line 304
    f___9->pointer = (char *)((void *)0);
#line 305
    return (0);
  }
  {
#line 307
  tmp___0 = strcspn((char const   *)cp, "\r\n");
#line 307
  f___9->len = (int )tmp___0;
  }
#line 308
  if (! f___9->len) {
#line 309
    return (0);
  }
#line 310
  f___9->pointer = cp;
#line 311
  return ((int )((cp + f___9->len) - buf___28));
}
}
#line 383 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/art.c"
static struct b b___3  =    {(char *)0, 0, 0};
#line 78 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/allocate.c"
static struct table___1 table___3  =    {(char *)0, (char *)0, 0, 0, 0, 0};
#line 80
static int remapfile___2(void) ;
#line 106 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/allocate.c"
static int initfile___5(char *filename ) 
{ 
  struct chainfile cf ;
  int fd ;
  int i ;
  int ret ;
  ssize_t tmp ;
  int pad ;
  ssize_t tmp___0 ;

  {
  {
#line 108
  cf.chain_magic = 0;
#line 108
  cf.next[0] = 0;
#line 108
  cf.next[1] = 0;
#line 108
  cf.next[2] = 0;
#line 108
  cf.next[3] = 0;
#line 108
  cf.next[4] = 0;
#line 108
  cf.next[5] = 0;
#line 108
  cf.next[6] = 0;
#line 108
  cf.next[7] = 0;
#line 108
  cf.next[8] = 0;
#line 108
  cf.next[9] = 0;
#line 108
  cf.next[10] = 0;
#line 108
  cf.next[11] = 0;
#line 108
  cf.next[12] = 0;
#line 108
  cf.next[13] = 0;
#line 108
  cf.next[14] = 0;
#line 108
  cf.next[15] = 0;
#line 108
  cf.next[16] = 0;
#line 108
  cf.next[17] = 0;
#line 108
  cf.next[18] = 0;
#line 108
  cf.next[19] = 0;
#line 108
  cf.next[20] = 0;
#line 108
  cf.next[21] = 0;
#line 108
  cf.next[22] = 0;
#line 108
  cf.next[23] = 0;
#line 108
  cf.next[24] = 0;
#line 108
  cf.next[25] = 0;
#line 108
  cf.next[26] = 0;
#line 108
  cf.next[27] = 0;
#line 108
  cf.next[28] = 0;
#line 108
  cf.next[29] = 0;
#line 108
  cf.next[30] = 0;
#line 108
  cf.next[31] = 0;
#line 108
  cf.next[32] = 0;
#line 108
  cf.next[33] = 0;
#line 108
  cf.next[34] = 0;
#line 108
  cf.next[35] = 0;
#line 108
  cf.next[36] = 0;
#line 108
  cf.next[37] = 0;
#line 108
  cf.next[38] = 0;
#line 108
  cf.next[39] = 0;
#line 108
  cf.next[40] = 0;
#line 108
  cf.next[41] = 0;
#line 108
  cf.next[42] = 0;
#line 108
  cf.next[43] = 0;
#line 108
  cf.next[44] = 0;
#line 108
  cf.next[45] = 0;
#line 108
  cf.next[46] = 0;
#line 108
  cf.next[47] = 0;
#line 108
  cf.next[48] = 0;
#line 108
  cf.next[49] = 0;
#line 108
  cf.next[50] = 0;
#line 108
  cf.next[51] = 0;
#line 108
  cf.next[52] = 0;
#line 108
  cf.next[53] = 0;
#line 108
  cf.next[54] = 0;
#line 108
  cf.next[55] = 0;
#line 108
  cf.next[56] = 0;
#line 108
  cf.next[57] = 0;
#line 108
  cf.next[58] = 0;
#line 108
  cf.next[59] = 0;
#line 108
  cf.next[60] = 0;
#line 108
  cf.next[61] = 0;
#line 108
  cf.next[62] = 0;
#line 111
  ret = 0;
#line 113
  fd = open((char const   *)filename, 578, 420);
  }
#line 114
  if (-1 == fd) {
#line 115
    return (-1);
  }
#line 116
  cf.chain_magic = 13680336;
#line 117
  i = 0;
  {
#line 117
  while (1) {
    while_continue: /* CIL Label */ ;
#line 117
    if (! (i < 63)) {
#line 117
      goto while_break;
    }
#line 118
    cf.next[i] = (int volatile   )0;
#line 117
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 119
  tmp = write(fd, (void const   *)(& cf), sizeof(cf));
#line 119
  i = (int )tmp;
  }
#line 120
  if ((unsigned long )i == sizeof(cf)) {
#line 124
    pad = (int )(sizeof(cf) % 4UL);
#line 125
    if (pad > 0) {
#line 126
      i = 0;
      {
#line 126
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 126
        if (i < pad) {
#line 126
          if (! (0 == ret)) {
#line 126
            goto while_break___0;
          }
        } else {
#line 126
          goto while_break___0;
        }
        {
#line 127
        tmp___0 = write(fd, (void const   *)"", (size_t )1);
        }
#line 127
        if (1L != tmp___0) {
#line 128
          ret = -1;
        }
#line 126
        i ++;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
  } else {
#line 131
    ret = -1;
  }
  {
#line 132
  close(fd);
  }
#line 133
  return (ret);
}
}
#line 136 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/allocate.c"
static void unmapfile___2(void) 
{ 


  {
#line 138
  if (table___3.fd >= 0) {
    {
#line 140
    close(table___3.fd);
#line 141
    table___3.fd = -1;
    }
  }
#line 143
  if (table___3.map) {
    {
#line 145
    munmap((void *)table___3.map, (size_t )table___3.size);
#line 146
    table___3.map = (char *)((void *)0);
#line 147
    table___3.size = 0;
    }
  }
#line 149
  return;
}
}
#line 153
static size_t rounduptopagesize___2(size_t size___1 ) ;
#line 153 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/allocate.c"
static size_t pagesize___9  =    (size_t )0;
#line 151 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/allocate.c"
static size_t rounduptopagesize___2(size_t size___1 ) 
{ 
  int pages ;
  int tmp ;

  {
#line 156
  if (0UL == pagesize___9) {
    {
#line 157
    tmp = getpagesize();
#line 157
    pagesize___9 = (size_t )tmp;
    }
  }
#line 158
  pages = (int )(size___1 / pagesize___9 + 1UL);
#line 159
  return ((size_t )pages * pagesize___9);
}
}
#line 162 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/allocate.c"
static int mapfile___2(void) 
{ 
  struct stat st ;
  int tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;

  {
#line 166
  if (-1 == table___3.fd) {
    {
#line 167
    table___3.fd = open((char const   *)table___3.filename, table___3.oflag, 420);
    }
  }
#line 168
  if (-1 == table___3.fd) {
#line 169
    goto fail;
  }
  {
#line 171
  tmp = fstat(table___3.fd, & st);
  }
#line 171
  if (-1 == tmp) {
#line 172
    goto fail;
  }
  {
#line 173
  tmp___0 = rounduptopagesize___2((size_t )st.st_size);
#line 173
  table___3.size = (int )tmp___0;
#line 174
  tmp___1 = mmap((void *)0, (size_t )table___3.size, table___3.mprot, 1, table___3.fd,
                 (__off_t )0);
#line 174
  table___3.map = (char *)tmp___1;
  }
#line 175
  if (! table___3.map) {
#line 176
    goto fail;
  } else
#line 175
  if ((unsigned long )table___3.map == (unsigned long )((void *)-1)) {
#line 176
    goto fail;
  }
#line 178
  return (0);
  fail: 
  {
#line 181
  unmapfile___2();
  }
#line 182
  return (-1);
}
}
#line 189 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/allocate.c"
static int remapfile___2(void) 
{ 
  struct stat st ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 193
  tmp = fstat(table___3.fd, & st);
  }
#line 193
  if (-1 == tmp) {
#line 194
    return (-1);
  }
#line 196
  if (st.st_size <= (__off_t )table___3.size) {
#line 197
    return (0);
  }
  {
#line 199
  munmap((void *)table___3.map, (size_t )table___3.size);
#line 200
  tmp___0 = mapfile___2();
  }
#line 200
  return (tmp___0);
}
}
#line 209 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/allocate.c"
static int lock___2(void) 
{ 
  int *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 211
  tmp___2 = lockf(table___3.fd, 2, (__off_t )0);
  }
#line 211
  if (-1 == tmp___2) {
    {
#line 213
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 215
      tmp = __errno_location();
      }
#line 215
      if (11 != *tmp) {
#line 216
        return (-1);
      } else {
        {
#line 218
        nap(0, 200);
        }
      }
      {
#line 213
      tmp___0 = lockf(table___3.fd, 2, (__off_t )0);
      }
#line 213
      if (! (-1 == tmp___0)) {
#line 213
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 221
    tmp___1 = remapfile___2();
    }
#line 221
    if (-1 == tmp___1) {
#line 222
      return (-1);
    }
  }
#line 224
  return (0);
}
}
#line 227 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/allocate.c"
static void unlock___2(void) 
{ 


  {
  {
#line 229
  lseek(table___3.fd, (__off_t )0, 0);
#line 230
  lockf(table___3.fd, 0, (__off_t )0);
  }
#line 231
  return;
}
}
#line 233 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/allocate.c"
static int checkvalidfile___2(void) 
{ 


  {
#line 235
  if (table___3.size > 0) {
#line 237
    if ((unsigned long )table___3.size < sizeof(struct chainfile )) {
#line 238
      return (-1);
    }
#line 239
    if (((struct chainfile *)table___3.map)->chain_magic != 13680336) {
#line 240
      return (-1);
    }
  }
#line 242
  return (0);
}
}
#line 281 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/allocate.c"
static int rounduptoalignment___2(int size___1 ) 
{ 


  {
#line 283
  if (size___1 <= 0) {
#line 284
    return (4);
  }
#line 285
  return (((size___1 - 1) / 4 + 1) * 4);
}
}
#line 296 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/allocate.c"
static char tmpchunk___2[272]  = {      (char )'\000'};
#line 37 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/group.c"
static int desc___8  =    -1;
#line 59 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/group.c"
static int cmpgroup___2(void *a , void *b___13 ) 
{ 
  struct groupobj *x ;
  struct groupobj *y ;
  int tmp ;

  {
  {
#line 61
  x = (struct groupobj *)a;
#line 62
  y = (struct groupobj *)b___13;
#line 64
  tmp = strcmp((char const   *)x->groupname, (char const   *)y->groupname);
  }
#line 64
  return (tmp);
}
}
#line 67 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/group.c"
static void freegroup___2(void *p ) 
{ 
  struct groupobj *gop ;

  {
#line 69
  gop = (struct groupobj *)p;
#line 71
  if (gop->groupname) {
    {
#line 72
    free((void *)gop->groupname);
    }
  }
#line 73
  if (gop->dir.dir) {
    {
#line 74
    closedir(gop->dir.dir);
    }
  }
#line 75
  if (gop->lastf.f) {
    {
#line 76
    munmap((void *)((caddr_t )gop->lastf.f), sizeof(struct file ));
    }
  }
  {
#line 77
  free(p);
  }
#line 78
  return;
}
}
#line 94 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/group.c"
static int refresh___2(struct groupobj *gop , char *groupname ) 
{ 
  struct stat st ;
  struct dir *d ;
  struct lastf *lp ;
  bool needreread ;
  bool needrefile ;
  bool needreslot ;
  bool isemptygroup ;
  int tmp ;
  int tmp___0 ;
  struct dirent *dp ;
  int i ;
  int first ;
  int last___1 ;
  char *end ;
  int tmp___1 ;
  unsigned short const   **tmp___2 ;
  unsigned long tmp___3 ;
  int fd ;
  void *tmp___4 ;
  struct info *ip ;
  int slot ;

  {
#line 99
  needreread = (bool )0;
#line 100
  needrefile = (bool )0;
#line 101
  needreslot = (bool )0;
#line 102
  isemptygroup = (bool )0;
#line 104
  d = & gop->dir;
#line 105
  lp = & gop->lastf;
#line 107
  if (groupname) {
    {
#line 109
    memset((void *)gop, 0, sizeof(struct groupobj ));
#line 110
    gop->groupname = strdup((char const   *)groupname);
    }
#line 111
    if ((unsigned long )((void *)0) == (unsigned long )gop->groupname) {
      {
#line 113
      log_((char *)"refresh:strdup:%m");
      }
#line 114
      return (-1);
    }
    {
#line 116
    gop->dir.first = -1;
#line 117
    d->dir = opendir((char const   *)groupname);
    }
#line 118
    if ((unsigned long )((void *)0) == (unsigned long )d->dir) {
      {
#line 120
      log_((char *)"refresh:opendir:%m");
      }
#line 121
      return (-1);
    }
#line 123
    lp->name = -1;
#line 125
    needreslot = (bool )1;
#line 125
    needreread = needreslot;
#line 125
    needrefile = needreread;
  } else {
#line 131
    if (-1 == d->first) {
#line 132
      needreread = (bool )1;
    } else
#line 131
    if (0 == d->last) {
#line 132
      needreread = (bool )1;
    } else
#line 131
    if (! d->read) {
#line 132
      needreread = (bool )1;
    } else {
      {
#line 133
      tmp = dirfd(d->dir);
#line 133
      tmp___0 = fstat(tmp, & st);
      }
#line 133
      if (-1 == tmp___0) {
        {
#line 135
        log_((char *)"refresh:fstat:%m");
        }
#line 136
        return (-1);
      } else
#line 138
      if (d->read < st.st_mtim.tv_sec) {
#line 139
        needreread = (bool )1;
      }
    }
#line 140
    if (! lp->f) {
#line 141
      needreslot = (bool )1;
#line 141
      needrefile = needreslot;
    }
#line 142
    if (! needrefile) {
#line 143
      if (! lp->f) {
#line 144
        needrefile = (bool )1;
      }
    }
#line 145
    if (! needrefile) {
#line 146
      if (-1 == lp->name) {
#line 147
        needrefile = (bool )1;
      }
    }
  }
#line 150
  if (needreread) {
#line 150
    goto _L;
  } else
#line 150
  if (needreslot) {
    _L: /* CIL Label */ 
    {
#line 156
    first = -1;
#line 157
    last___1 = 0;
#line 158
    rewinddir(d->dir);
#line 159
    dp = readdir(d->dir);
    }
#line 160
    if ((unsigned long )((void *)0) == (unsigned long )dp) {
      {
#line 162
      log_((char *)"refresh:readdir:%m");
      }
#line 163
      return (-1);
    }
#line 165
    gop->nopost = (bool )0;
    {
#line 166
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 168
      tmp___2 = __ctype_b_loc();
      }
#line 168
      if (! ((int const   )*(*tmp___2 + (int )dp->d_name[0]) & 2048)) {
#line 170
        if (! gop->nopost) {
#line 170
          if (46 == (int )dp->d_name[0]) {
            {
#line 171
            tmp___1 = strcmp((char const   *)(dp->d_name), ".nopost");
            }
#line 171
            if (0 == tmp___1) {
#line 172
              gop->nopost = (bool )1;
            }
          }
        }
#line 173
        goto __Cont;
      }
      {
#line 175
      tmp___3 = strtoul((char const   */* __restrict  */)(dp->d_name), (char **/* __restrict  */)(& end),
                        10);
#line 175
      i = (int )tmp___3;
      }
#line 175
      if (i <= 0) {
#line 176
        goto __Cont;
      } else
#line 175
      if (*end) {
#line 176
        goto __Cont;
      }
#line 177
      if (first > i) {
#line 178
        first = i;
      } else
#line 177
      if (-1 == first) {
#line 178
        first = i;
      }
#line 179
      if (last___1 < i) {
#line 180
        last___1 = i;
      }
      __Cont: /* CIL Label */ 
      {
#line 166
      dp = readdir(d->dir);
      }
#line 166
      if (! dp) {
#line 166
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 183
    d->first = first;
#line 184
    d->last = last___1;
#line 185
    if (-1 == first) {
#line 185
      if (0 == last___1) {
#line 186
        isemptygroup = (bool )1;
      }
    }
#line 187
    if (last___1 != lp->name) {
#line 188
      needrefile = (bool )1;
    } else {
#line 190
      lp->name = last___1;
    }
    {
#line 191
    time(& d->read);
    }
  }
#line 194
  if (needrefile) {
#line 194
    goto _L___0;
  } else
#line 194
  if (needreslot) {
    _L___0: /* CIL Label */ 
#line 198
    if (lp->f) {
      {
#line 200
      munmap((void *)((caddr_t )lp->f), sizeof(struct file ));
#line 201
      lp->f = (struct file *)((void *)0);
      }
    }
#line 203
    if (isemptygroup) {
#line 204
      return (0);
    }
    {
#line 205
    fd = openf(0, 0, (char *)"%s/%d", gop->groupname, d->last);
    }
#line 206
    if (-1 == fd) {
      {
#line 208
      log_((char *)"refresh:open:%m");
      }
#line 209
      return (-1);
    }
    {
#line 211
    tmp___4 = mmap((void *)0, sizeof(struct file ), 1, 1, fd, (__off_t )0);
#line 211
    lp->f = (struct file *)tmp___4;
#line 212
    close(fd);
    }
#line 213
    if ((unsigned long )lp->f == (unsigned long )((void *)-1)) {
      {
#line 215
      log_((char *)"refresh:mmap:%m");
      }
#line 216
      return (-1);
    }
#line 218
    lp->slotsfilled = 0;
#line 219
    needreslot = (bool )1;
  }
#line 222
  if (needreslot) {
#line 224
    ip = (lp->f)->info;
#line 227
    slot = 9;
    {
#line 227
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 227
      if (! (slot > -1)) {
#line 227
        goto while_break___0;
      }
#line 228
      if ((ip + slot)->hoffset) {
#line 229
        goto while_break___0;
      }
#line 227
      slot --;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 230
    lp->slotsfilled = slot + 1;
  }
#line 233
  return (0);
}
}
#line 56 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/dhash.c"
static unsigned char buf___6[2]  ;
#line 54 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/dhash.c"
static char *inttochar2___2(int integer ) 
{ 


  {
#line 58
  buf___6[0] = (unsigned char )((integer & 65535) >> 8);
#line 59
  buf___6[1] = (unsigned char )(integer & 255);
#line 60
  return ((char *)(buf___6));
}
}
#line 65 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/dhash.c"
static unsigned char buf___7[3]  ;
#line 63 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/dhash.c"
static char *inttochar3___2(unsigned int integer ) 
{ 


  {
#line 67
  integer >>= 2;
#line 68
  buf___7[0] = (unsigned char )((integer & 16777215U) >> 16);
#line 69
  buf___7[1] = (unsigned char )((integer & 65535U) >> 8);
#line 70
  buf___7[2] = (unsigned char )(integer & 255U);
#line 71
  return ((char *)(buf___7));
}
}
#line 140 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strncat)(char * __restrict  __dest ,
                                                                                                  char const   * __restrict  __src ,
                                                                                                  size_t __n ) ;
#line 11 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/snntpd.h"
bool posting_ok ;
#line 12
char *client_ip ;
#line 27
int pipefork(int *p ) ;
#line 37 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/lib/readln.h"
void readln_done(struct readln *rp ) ;
#line 14 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/unfold.h"
extern int unfold(struct readln *in , int (*putline)(char * , int  ) ) ;
#line 35 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/post.c"
static int tmpfd  =    -1;
#line 36 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/post.c"
static bool have_newsgroups  ;
#line 37 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/post.c"
static bool have_control  ;
#line 38 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/post.c"
static int error  ;
#line 46 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/post.c"
static char *getval(char *field___0 ) 
{ 


  {
  {
#line 48
  while (1) {
    while_continue: /* CIL Label */ ;
#line 48
    if (*field___0) {
#line 48
      if (! (58 != (int )*field___0)) {
#line 48
        goto while_break;
      }
    } else {
#line 48
      goto while_break;
    }
#line 49
    field___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 50
  field___0 ++;
  {
#line 51
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 51
    if (! (32 == (int )*field___0)) {
#line 51
      if (! (9 == (int )*field___0)) {
#line 51
        goto while_break___0;
      }
    }
#line 52
    field___0 ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 53
  return (field___0);
}
}
#line 58 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/post.c"
static char env_control[1000]  ;
#line 59 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/post.c"
static char env_newsgroups[1000]  ;
#line 56 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/post.c"
static int write_tmp(char *line , int len ) 
{ 
  char *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  ssize_t tmp___3 ;
  ssize_t tmp___4 ;
  char *p ;
  int tmp___5 ;
  int tmp___6 ;

  {
#line 61
  if (error) {
#line 62
    return (0);
  }
  {
#line 63
  tmp___2 = strncasecmp((char const   *)line, "X-sn-", (size_t )5);
  }
#line 63
  if (0 == tmp___2) {
#line 64
    return (0);
  } else
#line 65
  if (! have_control) {
    {
#line 65
    tmp___1 = strncasecmp((char const   *)line, "Control:", (size_t )8);
    }
#line 65
    if (0 == tmp___1) {
      {
#line 67
      strcpy((char */* __restrict  */)(env_control), (char const   */* __restrict  */)"CONTROL=");
#line 68
      tmp = getval(line);
#line 68
      strncat((char */* __restrict  */)(env_control), (char const   */* __restrict  */)tmp,
              (size_t )991);
#line 69
      tmp___0 = putenv(env_control);
      }
#line 69
      if (tmp___0) {
#line 70
        error = 5;
      } else {
#line 72
        have_control = (bool )1;
      }
    }
  }
  {
#line 74
  tmp___3 = write(tmpfd, (void const   *)line, (size_t )len);
  }
#line 74
  if (-1L == tmp___3) {
#line 75
    error = 2;
  }
  {
#line 76
  tmp___4 = write(tmpfd, (void const   *)"\r\n", (size_t )2);
  }
#line 76
  if (-1L == tmp___4) {
#line 77
    error = 2;
  }
#line 78
  if (! have_newsgroups) {
    {
#line 78
    tmp___6 = strncasecmp((char const   *)line, "Newsgroups:", (size_t )11);
    }
#line 78
    if (0 == tmp___6) {
      {
#line 82
      p = getval(line);
#line 82
      line = p;
      }
      {
#line 82
      while (1) {
        while_continue: /* CIL Label */ ;
#line 82
        if (! *p) {
#line 82
          goto while_break;
        }
#line 83
        if (44 == (int )*p) {
#line 84
          *p = (char )' ';
        }
#line 82
        p ++;
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 85
      strcpy((char */* __restrict  */)(env_newsgroups), (char const   */* __restrict  */)"NEWSGROUPS=");
#line 86
      strncat((char */* __restrict  */)(env_newsgroups), (char const   */* __restrict  */)line,
              (size_t )988);
#line 87
      tmp___5 = putenv(env_newsgroups);
      }
#line 87
      if (tmp___5) {
#line 88
        error = 5;
      } else {
#line 90
        have_newsgroups = (bool )1;
      }
    }
  }
#line 92
  return (error);
}
}
#line 95 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/post.c"
void do_post(void) 
{ 
  char buf___28[80] ;
  char *line ;
  int len ;
  int p[2] ;
  int pid___0 ;
  int s ;
  __pid_t tmp ;
  int tmp___0 ;
  ssize_t tmp___1 ;
  ssize_t tmp___2 ;
  ssize_t tmp___3 ;
  __off_t tmp___4 ;
  char *av___0[2] ;
  int *tmp___5 ;
  struct readln prog ;
  int tmp___6 ;
  char *tmp___7 ;
  __pid_t tmp___8 ;
  int *tmp___9 ;
  char const   *tmp___10 ;
  union __anonunion_49 __constr_expr_8 ;
  union __anonunion_50 __constr_expr_9 ;
  union __anonunion_51 __constr_expr_10 ;
  union __anonunion_52 __constr_expr_11 ;
  char const   *tmp___11 ;

  {
#line 101
  if (! posting_ok) {
    {
#line 103
    args_write(1, (char *)"440 Posting not allowed\r\n");
    }
#line 104
    return;
  }
#line 107
  if (-1 == tmpfd) {
    {
#line 109
    tmp = getpid();
#line 109
    formats(buf___28, (int )(sizeof(buf___28) - 1UL), (char *)"/tmp/.post.%d", tmp);
#line 110
    tmpfd = open((char const   *)(buf___28), 194, 420);
    }
#line 111
    if (-1 == tmpfd) {
      {
#line 113
      log_((char *)"do_post:open(%s):%m", buf___28);
      }
#line 114
      goto internal;
    }
    {
#line 116
    unlink((char const   *)(buf___28));
    }
  }
  {
#line 118
  error = 0;
#line 119
  have_newsgroups = (bool )0;
#line 119
  have_control = have_newsgroups;
#line 120
  putenv((char *)"CONTROL=");
#line 121
  putenv((char *)"NEWSGROUPS=");
#line 123
  args_write(1, (char *)"340 Go ahead\r\n");
#line 127
  lseek(tmpfd, (__off_t )0, 0);
#line 128
  tmp___0 = unfold(& input, & write_tmp);
  }
  {
#line 130
  if (tmp___0 == -3) {
#line 130
    goto case_neg_3;
  }
#line 131
  if (tmp___0 == -2) {
#line 131
    goto case_neg_2;
  }
#line 132
  if (tmp___0 == -1) {
#line 132
    goto case_neg_1;
  }
#line 133
  if (tmp___0 == 0) {
#line 133
    goto case_0;
  }
#line 128
  goto switch_break;
  case_neg_3: /* CIL Label */ 
#line 130
  goto switch_break;
  case_neg_2: /* CIL Label */ 
#line 131
  error = 3;
#line 131
  goto switch_break;
  case_neg_1: /* CIL Label */ 
  {
#line 132
  log_((char *)"do_post:read error:%m");
  }
  case_0: /* CIL Label */ 
#line 133
  return;
  switch_break: /* CIL Label */ ;
  }
#line 136
  if (! error) {
#line 138
    if (client_ip) {
#line 138
      if (*client_ip) {
        {
#line 139
        writef(tmpfd, (char *)"NNTP-Posting-Host: %s\r\n", client_ip);
        }
      }
    }
    {
#line 140
    tmp___1 = write(tmpfd, (void const   *)"\r\n", (size_t )2);
    }
#line 140
    if (-1L == tmp___1) {
#line 141
      error = 2;
    }
  }
  {
#line 143
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 143
    len = readln(& input, & line, '\n');
    }
#line 143
    if (! (len > 0)) {
#line 143
      goto while_break;
    }
#line 145
    if (! error) {
#line 147
      len --;
#line 147
      if (len > 0) {
#line 148
        if (13 == (int )*(line + (len - 1))) {
#line 149
          len --;
        }
      }
      {
#line 150
      tmp___2 = write(tmpfd, (void const   *)line, (size_t )len);
      }
#line 150
      if (-1L == tmp___2) {
#line 151
        error = 2;
      }
      {
#line 152
      tmp___3 = write(tmpfd, (void const   *)"\r\n", (size_t )2);
      }
#line 152
      if (-1L == tmp___3) {
#line 153
        error = 2;
      }
    }
#line 155
    if (1 == len) {
#line 155
      if (46 == (int )*line) {
#line 156
        goto while_break;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 159
  if (! have_newsgroups) {
    {
#line 161
    args_write(1, (char *)"441 No Newsgroups line\r\n");
    }
#line 162
    return;
  }
#line 164
  if (error) {
    {
#line 168
    if (error == 1) {
#line 168
      goto case_1;
    }
#line 169
    if (error == 2) {
#line 169
      goto case_2;
    }
#line 170
    if (error == 5) {
#line 170
      goto case_5;
    }
#line 171
    if (error == 3) {
#line 171
      goto case_3;
    }
#line 172
    if (error == 4) {
#line 172
      goto case_4;
    }
#line 166
    goto switch_break___0;
    case_1: /* CIL Label */ 
    {
#line 168
    log_((char *)"do_post: read error:%m?");
    }
#line 168
    goto switch_break___0;
    case_2: /* CIL Label */ 
    {
#line 169
    log_((char *)"do_post: write(tmp):%m");
    }
#line 169
    goto switch_break___0;
    case_5: /* CIL Label */ 
    {
#line 170
    log_((char *)"do_post: no memory");
    }
#line 170
    goto switch_break___0;
    case_3: /* CIL Label */ 
    {
#line 171
    args_write(1, (char *)"441 Bad article format\r\n");
    }
#line 171
    return;
    case_4: /* CIL Label */ 
#line 172
    return;
    switch_break___0: /* CIL Label */ ;
    }
    internal: 
    {
#line 175
    args_write(1, (char *)"441 Internal error\r\n");
    }
#line 176
    return;
  }
  {
#line 178
  tmp___4 = lseek(tmpfd, (__off_t )0, 1);
#line 178
  ftruncate(tmpfd, tmp___4);
#line 180
  pid___0 = pipefork((int *)(p));
  }
#line 180
  if (-1 == pid___0) {
    {
#line 182
    log_((char *)"do_post:pipe/fork:%m");
    }
#line 183
    goto internal;
  }
#line 186
  if (0 == pid___0) {
    {
#line 190
    close(p[0]);
#line 191
    lseek(tmpfd, (__off_t )0, 0);
#line 192
    dup2(tmpfd, 0);
#line 193
    dup2(p[1], 1);
#line 194
    av___0[1] = (char *)0;
#line 195
    av___0[0] = (char *)"./.SNPOST";
#line 196
    execv((char const   *)av___0[0], (char * const  *)(av___0));
#line 197
    tmp___5 = __errno_location();
    }
#line 197
    if (2 == *tmp___5) {
      {
#line 199
      av___0[0] += 3;
#line 200
      execvp((char const   *)av___0[0], (char * const  *)(av___0));
      }
    }
    {
#line 202
    fail(2, (char *)"do_post:exec(%s):%m", av___0[0]);
    }
  }
  {
#line 205
  close(p[1]);
#line 206
  buf___28[0] = (char )'\000';
  }
  {
#line 207
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 211
    tmp___6 = readln_ready(p[0], 0, & prog);
    }
#line 211
    if (tmp___6) {
#line 212
      goto while_break___0;
    }
    {
#line 213
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 213
      len = readln(& prog, & line, '\n');
      }
#line 213
      if (! (len > 0)) {
#line 213
        goto while_break___1;
      }
      {
#line 215
      len --;
#line 215
      *(line + len) = (char )'\000';
#line 216
      log_((char *)"SNPOST:%s", line);
      }
#line 217
      if (len > 0) {
#line 218
        if (13 == (int )*(line + (len - 1))) {
#line 219
          len --;
        }
      }
#line 220
      if ((unsigned long )len > sizeof(buf___28) - 1UL) {
#line 221
        len = (int )(sizeof(buf___28) - 1UL);
      }
      {
#line 222
      tmp___7 = strncpy((char */* __restrict  */)(buf___28), (char const   */* __restrict  */)line,
                        (size_t )len);
#line 222
      *(tmp___7 + len) = (char )'\000';
      }
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 224
    readln_done(& prog);
    }
#line 207
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 228
  while (1) {
    while_continue___2: /* CIL Label */ ;
    {
#line 228
    tmp___8 = waitpid(pid___0, & s, 0);
    }
#line 228
    if (-1 == tmp___8) {
      {
#line 228
      tmp___9 = __errno_location();
      }
#line 228
      if (! (4 == *tmp___9)) {
#line 228
        goto while_break___2;
      }
    } else {
#line 228
      goto while_break___2;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
#line 229
  __constr_expr_11.__in = s;
#line 229
  if ((__constr_expr_11.__i & 127) == 0) {
#line 231
    __constr_expr_8.__in = s;
#line 231
    s = (__constr_expr_8.__i & 65280) >> 8;
#line 231
    if (0 == s) {
#line 233
      if (buf___28[0]) {
#line 233
        tmp___10 = (char const   *)(buf___28);
      } else {
#line 233
        tmp___10 = "Yummy";
      }
      {
#line 233
      args_write(1, (char *)"240 %s\r\n", tmp___10);
      }
#line 234
      return;
    }
    {
#line 236
    log_((char *)"do_post:SNPOST died with %d", s);
    }
  } else {
#line 238
    __constr_expr_10.__in = s;
#line 238
    if ((int )((signed char )((__constr_expr_10.__i & 127) + 1)) >> 1 > 0) {
      {
#line 239
      __constr_expr_9.__in = s;
#line 239
      log_((char *)"do_post:SNPOST caught signal %d", __constr_expr_9.__i & 127);
      }
    } else {
      {
#line 241
      log_((char *)"do_post:SNPOST unknown wait status %d", s);
      }
    }
  }
#line 243
  if (buf___28[0]) {
#line 243
    tmp___11 = (char const   *)(buf___28);
  } else {
#line 243
    tmp___11 = "Posting failed";
  }
  {
#line 243
  args_write(1, (char *)"441 %s\r\n", tmp___11);
  }
#line 244
  return;
}
}
#line 87 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/cache.c"
static struct entry *new_entry___2(int desc___35 ) 
{ 
  struct entry *ep ;
  struct entry *tmp ;

  {
#line 91
  ep = table[desc___35].freelist;
#line 91
  if (ep) {
#line 92
    table[desc___35].freelist = ep->next;
  } else {
#line 95
    ep = table[desc___35].entries;
    {
#line 95
    while (1) {
      while_continue: /* CIL Label */ ;
#line 95
      if (! ep->next) {
#line 95
        goto while_break;
      }
#line 95
      ep = ep->next;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 96
    (ep->prev)->next = (struct entry *)((void *)0);
#line 97
    (*(table[desc___35].freeobj))(ep->object);
    }
  }
#line 99
  tmp = (struct entry *)((void *)0);
#line 99
  ep->next = tmp;
#line 99
  ep->prev = tmp;
#line 100
  ep->object = (void *)0;
#line 101
  return (ep);
}
}
#line 239 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) struct tm *( __attribute__((__leaf__)) gmtime)(time_t const   *__timer ) ;
#line 13 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/snntpd.h"
char *me ;
#line 15
int fifo ;
#line 40 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/commands.c"
void do_ihave(void) 
{ 


  {
  {
#line 40
  args_write(1, (char *)"435 I\'m happy for you\r\n");
  }
#line 40
  return;
}
}
#line 41 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/commands.c"
void do_sendme(void) 
{ 


  {
  {
#line 41
  args_write(1, (char *)"500 No thanks\r\n");
  }
#line 41
  return;
}
}
#line 42 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/commands.c"
void do_slave(void) 
{ 


  {
  {
#line 42
  args_write(1, (char *)"202 Whatever\r\n");
  }
#line 42
  return;
}
}
#line 43 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/commands.c"
void do_help(void) 
{ 


  {
  {
#line 43
  args_write(1, (char *)"100 Help yourself\r\n.\r\n");
  }
#line 43
  return;
}
}
#line 45 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/commands.c"
void do_mode(void) 
{ 


  {
#line 47
  if (posting_ok) {
    {
#line 48
    args_write(1, (char *)"200 Hi, you can post (sn version 0.3.8)\r\n");
    }
  } else {
    {
#line 50
    args_write(1, (char *)"201 Hi, you can\'t post (sn version 0.3.8)\r\n");
    }
  }
#line 51
  return;
}
}
#line 56 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/commands.c"
static char *specgroup  ;
#line 57 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/commands.c"
static int speclo  ;
#line 57 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/commands.c"
static int spechi  ;
#line 61 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/commands.c"
static struct article article  ;
#line 62 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/commands.c"
static char *specerror  ;
#line 71 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/commands.c"
static int readspec(char *spec ) 
{ 
  char *p ;
  struct data d ;
  int tmp ;
  char *end ;
  unsigned long tmp___0 ;
  unsigned long tmp___1 ;

  {
#line 75
  if (! spec) {
#line 77
    specgroup = currentgroup;
#line 77
    if (specgroup) {
#line 78
      speclo = currentserial;
#line 78
      spechi = speclo;
#line 78
      if (spechi > 0) {
#line 79
        return (0);
      } else {
#line 81
        specerror = (char *)"420 No article selected\r\n";
      }
    } else {
#line 83
      specerror = (char *)"412 No group selected\r\n";
    }
#line 84
    return (-1);
  }
#line 87
  if (60 == (int )*spec) {
    {
#line 91
    d.messageid = spec + 1;
#line 92
    p = strchr((char const   *)d.messageid, '>');
    }
#line 92
    if (p) {
      {
#line 94
      *p = (char )'\000';
#line 95
      tmp = dh_find(& d, (bool )0);
      }
#line 95
      if (0 == tmp) {
#line 97
        speclo = d.serial;
#line 97
        spechi = speclo;
#line 98
        specgroup = d.newsgroup;
#line 99
        return (0);
      } else {
#line 102
        specerror = (char *)"430 No such article\r\n";
      }
    } else {
#line 105
      specerror = (char *)"430 Invalid message ID\r\n";
    }
#line 106
    return (-1);
  }
#line 109
  specgroup = currentgroup;
#line 109
  if (specgroup) {
    {
#line 113
    tmp___0 = strtoul((char const   */* __restrict  */)spec, (char **/* __restrict  */)(& end),
                      10);
#line 113
    speclo = (int )tmp___0;
#line 114
    spec = end;
    }
#line 115
    if (45 == (int )*end) {
#line 117
      spec ++;
#line 118
      if (*spec) {
        {
#line 120
        tmp___1 = strtoul((char const   */* __restrict  */)spec, (char **/* __restrict  */)(& end),
                          10);
#line 120
        spechi = (int )tmp___1;
        }
#line 121
        if (*end) {
#line 122
          goto invalid;
        }
#line 123
        if (spechi < speclo) {
#line 124
          goto invalid;
        }
      } else {
#line 127
        spechi = 2147483647;
      }
#line 128
      if (spechi > currentinfo.last) {
#line 130
        if (speclo <= currentinfo.last) {
#line 131
          spechi = currentinfo.last;
        } else {
#line 133
          spechi = speclo;
        }
      }
    } else
#line 136
    if (! *spec) {
#line 137
      spechi = speclo;
    } else {
#line 139
      goto invalid;
    }
  }
#line 141
  return (0);
  invalid: 
#line 144
  specerror = (char *)"501 Invalid range\r\n";
#line 145
  return (-1);
}
}
#line 148 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/commands.c"
static char *findid(void) 
{ 
  char *id ;

  {
  {
#line 152
  id = art_findfield(article.head, (char *)"Message-ID");
  }
#line 152
  if (id) {
#line 152
    if (*id) {
#line 153
      return (id);
    }
  }
#line 154
  return ((char *)"<0>");
}
}
#line 164
static void writefifo(void) ;
#line 164 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/commands.c"
static char oldgroup[256]  = {      (char )'\000'};
#line 165 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/commands.c"
static int interested  =    0;
#line 162 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/commands.c"
static void writefifo(void) 
{ 
  int len ;
  size_t tmp ;
  int tmp___0 ;

  {
#line 167
  if (-1 == fifo) {
#line 168
    return;
  }
  {
#line 169
  tmp___0 = strcasecmp((char const   *)(oldgroup), (char const   *)currentgroup);
  }
#line 169
  if (tmp___0 == 0) {
#line 171
    interested ++;
#line 172
    if (3 == interested % 10) {
      {
#line 176
      tmp = strlen((char const   *)currentgroup);
#line 176
      len = (int )tmp;
#line 177
      *(currentgroup + len) = (char )'\n';
#line 178
      write(fifo, (void const   *)currentgroup, (size_t )(len + 1));
#line 179
      *(currentgroup + len) = (char )'\000';
      }
    }
  } else {
    {
#line 184
    interested = 0;
#line 185
    strcpy((char */* __restrict  */)(oldgroup), (char const   */* __restrict  */)currentgroup);
    }
  }
#line 187
  return;
}
}
#line 192 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/commands.c"
static void putarticle(int flag , int code , char *msg ) 
{ 
  char *p ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;

  {
  {
#line 196
  tmp = readspec(args[1]);
  }
#line 196
  if (-1 == tmp) {
    {
#line 198
    args_write(1, specerror);
    }
#line 199
    return;
  }
  {
#line 201
  tmp___0 = art_gimme(specgroup, speclo, & article);
  }
#line 201
  if (-1 == tmp___0) {
    {
#line 203
    args_write(1, (char *)"430 No such article\r\n");
    }
#line 204
    return;
  }
#line 206
  if (speclo != spechi) {
    {
#line 208
    args_write(1, (char *)"512 Invalid argument\r\n");
    }
#line 209
    return;
  }
#line 212
  if (flag & 2) {
    {
#line 213
    while (1) {
      while_continue: /* CIL Label */ ;
#line 223
      if (*(article.body + -1)) {
#line 232
        p = (char *)"Article is corrupt";
      } else
#line 223
      if (*(article.body + article.blen)) {
#line 232
        p = (char *)"Article is corrupt";
      } else {
        {
#line 224
        tmp___1 = body(& article.body, & article.blen);
        }
#line 224
        if (0 == tmp___1) {
#line 225
          if (! *(article.body + article.blen)) {
#line 226
            goto while_break;
          } else {
#line 228
            p = (char *)"Internal error, uncompressed to corrupt body";
          }
        } else {
#line 230
          p = (char *)"Internal error, can\'t uncompress body";
        }
      }
      {
#line 233
      args_write(1, (char *)"423 %s\r\n", p);
      }
#line 234
      return;
#line 213
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 238
  if (! args[1]) {
    {
#line 240
    tmp___2 = findid();
#line 240
    args_write(1, (char *)"%d %d %s %s\r\n", code, speclo, tmp___2, msg);
#line 241
    currentserial = speclo;
#line 242
    writefifo();
    }
  } else
#line 238
  if (60 != (int )*(args[1])) {
    {
#line 240
    tmp___2 = findid();
#line 240
    args_write(1, (char *)"%d %d %s %s\r\n", code, speclo, tmp___2, msg);
#line 241
    currentserial = speclo;
#line 242
    writefifo();
    }
  } else {
    {
#line 245
    args_write(1, (char *)"%d %d <%s> %s\r\n", code, speclo, args[1] + 1, msg);
    }
  }
  {
#line 249
  if (flag == 0) {
#line 249
    goto case_0;
  }
#line 252
  if (flag == 3) {
#line 252
    goto case_3;
  }
#line 252
  if (flag == 1) {
#line 252
    goto case_3;
  }
#line 263
  if (flag == 2) {
#line 263
    goto case_2;
  }
#line 247
  goto switch_break;
  case_0: /* CIL Label */ 
#line 250
  return;
  case_3: /* CIL Label */ 
  case_1: /* CIL Label */ 
  {
#line 254
  p = strstr((char const   *)article.head, "Xref:");
  }
#line 255
  if (p) {
#line 255
    if ((unsigned long )p == (unsigned long )article.head) {
      {
#line 256
      writef(1, (char *)"%SXref: %s %s:%d%s", p - article.head, article.head, me,
             specgroup, speclo, p + 5);
      }
    } else
#line 255
    if (10 == (int )*(p + -1)) {
      {
#line 256
      writef(1, (char *)"%SXref: %s %s:%d%s", p - article.head, article.head, me,
             specgroup, speclo, p + 5);
      }
    } else {
      {
#line 259
      writef(1, (char *)"%sXref: %s %s:%d\r\n", article.head, me, specgroup, speclo);
      }
    }
  } else {
    {
#line 259
    writef(1, (char *)"%sXref: %s %s:%d\r\n", article.head, me, specgroup, speclo);
    }
  }
#line 260
  if (1 == flag) {
#line 261
    goto switch_break;
  }
  {
#line 262
  write(1, (void const   *)"\r\n", (size_t )2);
  }
  case_2: /* CIL Label */ 
  {
#line 264
  write(1, (void const   *)article.body, (size_t )article.blen);
  }
#line 265
  if (10 != (int )*(article.body + (article.blen - 1))) {
    {
#line 267
    log_((char *)"putarticle:%s:%d does not end in newline", specgroup, speclo);
#line 268
    write(1, (void const   *)"\r\n", (size_t )2);
    }
  }
  switch_break: /* CIL Label */ ;
  }
  {
#line 271
  args_write(1, (char *)".\r\n");
  }
#line 272
  return;
}
}
#line 274 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/commands.c"
void do_article(void) 
{ 


  {
  {
#line 274
  putarticle(3, 220, (char *)"Article follows");
  }
#line 274
  return;
}
}
#line 275 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/commands.c"
void do_body(void) 
{ 


  {
  {
#line 275
  putarticle(2, 222, (char *)"Body follows");
  }
#line 275
  return;
}
}
#line 276 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/commands.c"
void do_head(void) 
{ 


  {
  {
#line 276
  putarticle(1, 221, (char *)"Head follows");
  }
#line 276
  return;
}
}
#line 277 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/commands.c"
void do_stat(void) 
{ 


  {
  {
#line 277
  putarticle(0, 223, (char *)"Request text separately");
  }
#line 277
  return;
}
}
#line 279 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/commands.c"
void do_group(void) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  {
#line 281
  tmp = alltolower(args[1]);
  }
#line 281
  if (tmp >= 255) {
    {
#line 282
    args_write(1, (char *)"411 No such group here as %s\r\n", args[1]);
    }
  } else {
    {
#line 281
    tmp___0 = make_current(args[1]);
    }
#line 281
    if (tmp___0) {
      {
#line 282
      args_write(1, (char *)"411 No such group here as %s\r\n", args[1]);
      }
    } else {
      {
#line 285
      args_write(1, (char *)"211 %d %d %d %s\r\n", currentinfo.nr_articles, currentinfo.first,
                 currentinfo.last, args[1]);
#line 287
      specgroup = (char *)0;
#line 289
      writefifo();
      }
    }
  }
#line 291
  return;
}
}
#line 293 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/commands.c"
static void nextlast(int inc , char *ermsg ) 
{ 
  int serial ;
  int count ;
  char *tmp ;
  int tmp___0 ;

  {
#line 296
  count = 20;
#line 298
  serial = currentserial + inc;
  {
#line 298
  while (1) {
    while_continue: /* CIL Label */ ;
#line 298
    if (serial) {
#line 298
      if (! count) {
#line 298
        goto while_break;
      }
    } else {
#line 298
      goto while_break;
    }
    {
#line 299
    tmp___0 = art_gimme(currentgroup, serial, & article);
    }
#line 299
    if (0 == tmp___0) {
      {
#line 301
      tmp = findid();
#line 301
      args_write(1, (char *)"223 %d %s request text separately\r\n", serial, tmp);
#line 302
      currentserial = serial;
      }
#line 303
      return;
    }
#line 298
    serial += inc;
#line 298
    count --;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 305
  args_write(1, ermsg);
  }
#line 306
  return;
}
}
#line 308 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/commands.c"
void do_last(void) 
{ 


  {
  {
#line 308
  nextlast(-1, (char *)"422 No previous article\r\n");
  }
#line 308
  return;
}
}
#line 309 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/commands.c"
void do_next(void) 
{ 


  {
  {
#line 309
  nextlast(1, (char *)"421 No next article\r\n");
  }
#line 309
  return;
}
}
#line 315 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/commands.c"
static time_t converttime(char *date , char *clock___0 , char *gmt ) 
{ 
  struct tm tm ;
  time_t t ;
  int difference ;
  size_t tmp ;
  size_t tmp___0 ;
  time_t then ;
  time_t tmp___1 ;
  struct tm *then_tm ;
  struct tm *tmp___2 ;
  time_t tmp___3 ;
  int tmp___4 ;

  {
  {
#line 317
  tm.tm_sec = 0;
#line 317
  tm.tm_min = 0;
#line 317
  tm.tm_hour = 0;
#line 317
  tm.tm_mday = 0;
#line 317
  tm.tm_mon = 0;
#line 317
  tm.tm_year = 0;
#line 317
  tm.tm_wday = 0;
#line 317
  tm.tm_yday = 0;
#line 317
  tm.tm_isdst = 0;
#line 317
  tm.tm_gmtoff = 0L;
#line 317
  tm.tm_zone = (char const   *)0;
#line 318
  t = (time_t )0;
#line 319
  difference = 0;
#line 321
  tmp = strspn((char const   *)date, "0123456789");
  }
#line 321
  if (tmp != 6UL) {
#line 322
    return ((time_t )-1);
  } else {
    {
#line 321
    tmp___0 = strspn((char const   *)clock___0, "0123456789");
    }
#line 321
    if (tmp___0 != 6UL) {
#line 322
      return ((time_t )-1);
    }
  }
#line 324
  tm.tm_year = ((int )*date - 48) * 10 + ((int )*(date + 1) - 48);
#line 325
  date += 2;
#line 326
  if (tm.tm_year < 70) {
#line 327
    tm.tm_year += 100;
  }
#line 328
  tm.tm_mon = ((int )*date - 48) * 10 + ((int )*(date + 1) - 48);
#line 329
  date += 2;
#line 330
  (tm.tm_mon) --;
#line 331
  tm.tm_mday = ((int )*date - 48) * 10 + ((int )*(date + 1) - 48);
#line 334
  tm.tm_hour = ((int )*clock___0 - 48) * 10 + ((int )*(clock___0 + 1) - 48);
#line 335
  clock___0 += 2;
#line 336
  tm.tm_min = ((int )*clock___0 - 48) * 10 + ((int )*(clock___0 + 1) - 48);
#line 337
  clock___0 += 2;
#line 338
  tm.tm_sec = ((int )*clock___0 - 48) * 10 + ((int )*(clock___0 + 1) - 48);
#line 340
  tm.tm_isdst = -1;
#line 342
  if (gmt) {
    {
#line 342
    tmp___4 = strcasecmp((char const   *)gmt, "GMT");
    }
#line 342
    if (0 == tmp___4) {
      {
#line 345
      tmp___1 = mktime(& tm);
#line 345
      then = tmp___1;
#line 346
      tmp___2 = gmtime((time_t const   *)(& then));
#line 346
      then_tm = tmp___2;
#line 348
      then_tm->tm_isdst = -1;
#line 349
      tmp___3 = mktime(then_tm);
#line 349
      difference = (int )(then - tmp___3);
      }
    }
  }
  {
#line 352
  t = mktime(& tm);
  }
#line 353
  if (t == -1L) {
#line 354
    return ((time_t )-1);
  }
#line 355
  return (t + (time_t )difference);
}
}
#line 358 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/commands.c"
void do_newgroups(void) 
{ 
  time_t cutoff ;
  int n ;
  int i ;
  struct key *kp ;
  char *group ;
  char buf___28[287] ;
  struct stat st ;
  int tmp ;
  struct group g ;
  int tmp___0 ;

  {
  {
#line 362
  cutoff = converttime(args[1], args[2], args[3]);
  }
#line 363
  if (cutoff > 0L) {
    {
#line 366
    args_write(1, (char *)"231 new newsgroups follows\r\n");
    }
#line 367
    if (nr_keys > 0) {
#line 375
      n = nr_keys;
#line 375
      i = 0;
      {
#line 375
      while (1) {
        while_continue: /* CIL Label */ ;
#line 375
        if (i < 128) {
#line 375
          if (! (n > 0)) {
#line 375
            goto while_break;
          }
        } else {
#line 375
          goto while_break;
        }
#line 375
        kp = key_table[i];
        {
#line 375
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 375
          if (! kp) {
#line 375
            goto while_break___0;
          }
          {
#line 377
          group = (char *)kp + sizeof(struct key );
#line 378
          formats(buf___28, (int )(sizeof(buf___28) - 1UL), (char *)"%s/.created",
                  group);
#line 379
          tmp = stat((char const   */* __restrict  */)(buf___28), (struct stat */* __restrict  */)(& st));
          }
#line 379
          if (-1 == tmp) {
            {
#line 381
            log_((char *)"do_newsgroups:stat(%s/.created):%m", group);
            }
#line 382
            goto __Cont;
          }
#line 384
          if (st.st_mtim.tv_sec >= cutoff) {
            {
#line 388
            tmp___0 = group_info(group, & g);
            }
#line 388
            if (-1 == tmp___0) {
#line 389
              goto __Cont;
            }
            {
#line 390
            args_write(1, (char *)"%s %d %d y\r\n", group, g.first, g.last);
            }
          }
          __Cont: /* CIL Label */ 
#line 375
          kp = kp->next;
#line 375
          n --;
        }
        while_break___0: /* CIL Label */ ;
        }
#line 375
        i ++;
      }
      while_break: /* CIL Label */ ;
      }
    } else
#line 395
    if (debug >= 2) {
      {
#line 395
      log_((char *)"do_newgroups:we have no groups");
      }
    }
  } else {
    {
#line 398
    args_write(1, (char *)"231 Bad date or time\r\n");
    }
  }
  {
#line 399
  args_write(1, (char *)".\r\n");
  }
#line 400
  return;
}
}
#line 402 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/commands.c"
void do_newnews(void) 
{ 
  time_t cutoff ;
  int i ;
  int j ;
  int serial ;
  char *pat ;
  struct key *kp ;
  struct group g ;
  char *group ;
  char *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 409
  cutoff = converttime(args[2], args[3], args[4]);
  }
#line 411
  if (cutoff > 0L) {
    {
#line 416
    args_write(1, (char *)"230 list of new articles follows\r\n");
#line 417
    alltolower(args[1]);
    }
    {
#line 418
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 418
      pat = tokensep(args + 1, (char *)",");
      }
#line 418
      if (! pat) {
#line 418
        goto while_break;
      }
#line 419
      j = nr_keys;
#line 419
      i = 0;
      {
#line 419
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 419
        if (i < 128) {
#line 419
          if (! (j > 0)) {
#line 419
            goto while_break___0;
          }
        } else {
#line 419
          goto while_break___0;
        }
#line 419
        kp = key_table[i];
        {
#line 419
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 419
          if (! kp) {
#line 419
            goto while_break___1;
          }
          {
#line 423
          group = (char *)kp + sizeof(struct key );
#line 424
          tmp___2 = wildmat(group, pat);
          }
#line 424
          if (tmp___2) {
            {
#line 425
            tmp___1 = group_info(group, & g);
            }
#line 425
            if (0 == tmp___1) {
              {
#line 426
              serial = times_since(group, cutoff);
              }
#line 426
              if (serial > 0) {
                {
#line 427
                while (1) {
                  while_continue___2: /* CIL Label */ ;
#line 427
                  if (! (serial < g.last)) {
#line 427
                    goto while_break___2;
                  }
                  {
#line 428
                  tmp___0 = art_gimmenoderef(group, serial, & article);
                  }
#line 428
                  if (0 == tmp___0) {
                    {
#line 429
                    tmp = findid();
#line 429
                    args_write(1, (char *)"%s\r\n", tmp);
                    }
                  }
#line 427
                  serial ++;
                }
                while_break___2: /* CIL Label */ ;
                }
              }
            }
          }
#line 419
          kp = kp->next;
#line 419
          j --;
        }
        while_break___1: /* CIL Label */ ;
        }
#line 419
        i ++;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
    while_break: /* CIL Label */ ;
    }
  } else {
    {
#line 433
    args_write(1, (char *)"230 Bad date or time\r\n");
    }
  }
  {
#line 434
  args_write(1, (char *)".\r\n");
  }
#line 435
  return;
}
}
#line 437 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/commands.c"
static void xlooper(char *spec , void (*f___9)(void) , char *msg ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  {
#line 439
  tmp = readspec(spec);
  }
#line 439
  if (-1 == tmp) {
    {
#line 441
    args_write(1, specerror);
    }
#line 442
    return;
  }
  {
#line 444
  args_write(1, msg);
  }
  {
#line 445
  while (1) {
    while_continue: /* CIL Label */ ;
#line 445
    if (! (speclo <= spechi)) {
#line 445
      goto while_break;
    }
    {
#line 446
    tmp___0 = art_gimme(specgroup, speclo, & article);
    }
#line 446
    if (0 == tmp___0) {
      {
#line 447
      (*f___9)();
      }
    }
#line 445
    speclo ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 448
  args_write(1, (char *)".\r\n");
  }
#line 449
  if (spec) {
#line 449
    if (60 != (int )*spec) {
      {
#line 450
      writefifo();
      }
    }
  }
#line 451
  return;
}
}
#line 453 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/commands.c"
static void putxover(void) 
{ 
  struct xover x ;

  {
  {
#line 457
  art_makexover(& article, & x);
#line 458
  writef(1, (char *)"%d\t%S\t%S\t%S\t%S\t%S\t%S\t%S\tXref: %s %s:%d\r\n", speclo,
         x.subject.len, x.subject.pointer, x.from.len, x.from.pointer, x.date.len,
         x.date.pointer, x.messageid.len, x.messageid.pointer, x.references.len, x.references.pointer,
         x.bytes.len, x.bytes.pointer, x.lines.len, x.lines.pointer, me, specgroup,
         speclo);
  }
#line 468
  return;
}
}
#line 470 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/commands.c"
void do_xover(void) 
{ 


  {
  {
#line 470
  xlooper(args[1], & putxover, (char *)"224 XOVER follows\r\n");
  }
#line 470
  return;
}
}
#line 472 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/commands.c"
static void putxhdr(void) 
{ 
  char *id ;
  int tmp ;

  {
  {
#line 476
  id = art_findfield(article.head, args[1]);
  }
#line 477
  if (*id) {
    {
#line 478
    args_write(1, (char *)"%d %s\r\n", speclo, id);
    }
  } else {
    {
#line 479
    tmp = strcasecmp((char const   *)args[1], "xref");
    }
#line 479
    if (tmp == 0) {
      {
#line 480
      args_write(1, (char *)"%d %s %s:%d\r\n", speclo, me, specgroup, speclo);
      }
    }
  }
#line 481
  return;
}
}
#line 483 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/commands.c"
void do_xhdr(void) 
{ 


  {
  {
#line 483
  xlooper(args[2], & putxhdr, (char *)"221 XHDR follows\r\n");
  }
#line 483
  return;
}
}
#line 485 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/commands.c"
static char *field  ;
#line 487 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/commands.c"
static void putxpat(void) 
{ 
  char **globs ;
  char *line ;
  int tmp ;

  {
  {
#line 492
  globs = args + 3;
#line 493
  line = art_findfield(article.head, field);
  }
#line 493
  if (line) {
#line 493
    if (*line) {
      {
#line 494
      while (1) {
        while_continue: /* CIL Label */ ;
#line 494
        if (! *globs) {
#line 494
          goto while_break;
        }
        {
#line 495
        tmp = wildmat(line, *globs);
        }
#line 495
        if (tmp) {
          {
#line 497
          args_write(1, (char *)"%d %s: %s\r\n", speclo, field, line);
          }
#line 498
          goto while_break;
        }
#line 494
        globs ++;
      }
      while_break: /* CIL Label */ ;
      }
    }
  }
#line 500
  return;
}
}
#line 502 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/commands.c"
void do_xpat(void) 
{ 


  {
  {
#line 504
  field = args[1];
#line 505
  xlooper(args[2], & putxpat, (char *)"221 Headers follows\r\n");
  }
#line 506
  return;
}
}
#line 105 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/dh_find.c"
static int initfile___6(void) 
{ 
  int fd ;
  int integer ;
  int i ;
  char foo[3] ;
  unsigned int tmp ;
  int *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  ssize_t tmp___3 ;
  ssize_t tmp___4 ;

  {
#line 108
  integer = 218885376;
#line 110
  foo[0] = (char )'\000';
#line 110
  tmp = 1U;
  {
#line 110
  while (1) {
    while_continue: /* CIL Label */ ;
#line 110
    if (tmp >= 3U) {
#line 110
      goto while_break;
    }
#line 110
    foo[tmp] = (char)0;
#line 110
    tmp ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 112
  fd = open((char const   *)(dh_tablefile), 194, 420);
  }
#line 113
  if (fd == -1) {
#line 114
    return (-1);
  }
  {
#line 115
  tmp___2 = lockf(fd, 2, (__off_t )0);
  }
#line 115
  if (tmp___2 == -1) {
    {
#line 117
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 119
      tmp___0 = __errno_location();
      }
#line 119
      if (*tmp___0 == 11) {
        {
#line 120
        nap(0, 200);
        }
      } else {
#line 122
        goto fail;
      }
      {
#line 117
      tmp___1 = lockf(fd, 2, (__off_t )0);
      }
#line 117
      if (! (tmp___1 == -1)) {
#line 117
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 125
    lockf(fd, 0, (__off_t )0);
    }
#line 126
    return (fd);
  }
  {
#line 128
  tmp___3 = write(fd, (void const   *)(& integer), sizeof(int ));
  }
#line 128
  if ((unsigned long )tmp___3 != sizeof(int )) {
#line 129
    goto fail;
  }
#line 130
  i = 0;
  {
#line 130
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 130
    if (! (i < 10240)) {
#line 130
      goto while_break___1;
    }
    {
#line 131
    tmp___4 = write(fd, (void const   *)(foo), sizeof(foo));
    }
#line 131
    if ((unsigned long )tmp___4 != sizeof(foo)) {
#line 132
      goto fail;
    }
#line 130
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 133
  lseek(fd, (__off_t )0, 0);
#line 134
  lockf(fd, 0, (__off_t )0);
  }
#line 135
  return (fd);
  fail: 
#line 138
  if (fd > -1) {
    {
#line 139
    close(fd);
    }
  }
#line 140
  return (-1);
}
}
#line 35 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/newsgroup.c"
static struct ng *bygroup___2[128]  ;
#line 36 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/newsgroup.c"
static struct ng *byident___2[128]  ;
#line 37 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/newsgroup.c"
static int highest___2  =    0;
#line 39 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/newsgroup.c"
static unsigned int hash___6(char *buf___28 , int len ) 
{ 
  unsigned int h ;
  char *tmp ;

  {
#line 43
  h = 5381U;
  {
#line 44
  while (1) {
    while_continue: /* CIL Label */ ;
#line 44
    if (! len) {
#line 44
      goto while_break;
    }
#line 46
    len --;
#line 47
    h += h << 5;
#line 48
    tmp = buf___28;
#line 48
    buf___28 ++;
#line 48
    h ^= (unsigned int )*tmp;
  }
  while_break: /* CIL Label */ ;
  }
#line 50
  return (h);
}
}
#line 53 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/newsgroup.c"
static struct chunk *chunks___2  ;
#line 58 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/newsgroup.c"
static int avail___6  =    0;
#line 59 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/newsgroup.c"
static int nr___3  =    0;
#line 64 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/newsgroup.c"
static int add___3(int ident , char *group , int len ) 
{ 
  struct ng *np ;
  struct ng *p ;
  int want ;
  unsigned int h ;
  struct chunk *tmp ;
  int size___1 ;
  void *tmp___0 ;
  unsigned int tmp___1 ;
  int tmp___2 ;

  {
#line 71
  len ++;
#line 72
  want = (int )(((unsigned long )len + sizeof(struct ng )) + sizeof(char *));
#line 73
  want = (int )((unsigned long )want - (unsigned long )len % sizeof(char *));
#line 74
  len --;
#line 76
  if (avail___6 < want) {
#line 81
    if (want > 240) {
#line 81
      size___1 = want + 240;
    } else {
#line 81
      size___1 = 240;
    }
    {
#line 82
    tmp___0 = malloc((size_t )size___1);
#line 82
    tmp = (struct chunk *)tmp___0;
    }
#line 82
    if (! tmp) {
#line 83
      return (-1);
    }
#line 84
    tmp->next = chunks___2;
#line 85
    chunks___2 = tmp;
#line 86
    chunks___2->buf = (char *)chunks___2 + sizeof(struct chunk );
#line 87
    avail___6 = (int )((unsigned long )size___1 - sizeof(struct chunk ));
  }
  {
#line 89
  np = (struct ng *)chunks___2->buf;
#line 90
  chunks___2->buf += want;
#line 91
  avail___6 -= want;
#line 92
  strncpy((char */* __restrict  */)(np->group), (char const   */* __restrict  */)group,
          (size_t )len);
#line 93
  np->group[len] = (char )'\000';
#line 94
  np->ident = ident;
#line 96
  tmp___1 = hash___6(group, len);
#line 96
  h = tmp___1 % 128U;
#line 97
  np->gnext = bygroup___2[h];
#line 98
  bygroup___2[h] = np;
#line 99
  p = np->gnext;
  }
  {
#line 99
  while (1) {
    while_continue: /* CIL Label */ ;
#line 99
    if (! p) {
#line 99
      goto while_break;
    }
    {
#line 100
    tmp___2 = strcmp((char const   *)(p->group), (char const   *)group);
    }
#line 100
    if (0 == tmp___2) {
#line 101
      return (1);
    }
#line 99
    p = p->gnext;
  }
  while_break: /* CIL Label */ ;
  }
#line 102
  h = (unsigned int )(ident % 128);
#line 103
  np->inext = byident___2[h];
#line 104
  byident___2[h] = np;
#line 105
  p = np->inext;
  {
#line 105
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 105
    if (! p) {
#line 105
      goto while_break___0;
    }
#line 106
    if (p->ident == ident) {
#line 107
      return (1);
    }
#line 105
    p = p->inext;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 109
  if (ident > highest___2) {
#line 110
    highest___2 = ident;
  }
#line 111
  nr___3 ++;
#line 112
  return (0);
}
}
#line 116 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/newsgroup.c"
static int groupfd___2  =    -1;
#line 117 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/newsgroup.c"
static int oldsize___2  =    0;
#line 118 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/newsgroup.c"
static int mapsize___2  =    0;
#line 119 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/newsgroup.c"
static char *mapbuf___2  =    (char *)((void *)0);
#line 148
static int reload___2(void) ;
#line 148 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/newsgroup.c"
static int pagesize___10  =    0;
#line 145 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/newsgroup.c"
static int reload___2(void) 
{ 
  struct stat st ;
  int newsize ;
  int tmp ;
  void *tmp___0 ;
  char *p ;
  char *lim ;
  char *ip ;
  char *gr ;
  int ident ;
  int state ;
  int tmp___1 ;

  {
  {
#line 156
  tmp = fstat(groupfd___2, & st);
  }
#line 156
  if (-1 == tmp) {
    {
#line 158
    log_((char *)"reload:fstat:%m");
    }
#line 159
    return (-1);
  }
#line 161
  newsize = (int )st.st_size;
#line 162
  if (! pagesize___10) {
    {
#line 163
    pagesize___10 = getpagesize();
    }
  }
#line 164
  if (newsize <= oldsize___2) {
#line 165
    return (0);
  }
#line 166
  if (newsize > mapsize___2) {
#line 166
    goto _L;
  } else
#line 166
  if (! mapsize___2) {
    _L: /* CIL Label */ 
#line 168
    if (mapbuf___2) {
      {
#line 169
      munmap((void *)mapbuf___2, (size_t )mapsize___2);
      }
    }
    {
#line 170
    mapsize___2 = (int )((st.st_size + (__off_t )pagesize___10) - st.st_size % (long )pagesize___10);
#line 171
    tmp___0 = mmap((void *)0, (size_t )mapsize___2, 1, 1, groupfd___2, (__off_t )0);
#line 171
    mapbuf___2 = (char *)tmp___0;
    }
#line 172
    if (! mapbuf___2) {
      {
#line 174
      log_((char *)"reload:mmap:%m");
      }
#line 175
      return (-1);
    } else
#line 172
    if ((unsigned long )mapbuf___2 == (unsigned long )((void *)-1)) {
      {
#line 174
      log_((char *)"reload:mmap:%m");
      }
#line 175
      return (-1);
    }
  }
#line 188
  lim = mapbuf___2 + newsize;
#line 189
  state = 0;
#line 189
  ident = state;
#line 190
  gr = (char *)0;
#line 190
  ip = gr;
#line 191
  p = mapbuf___2 + oldsize___2;
  {
#line 191
  while (1) {
    while_continue: /* CIL Label */ ;
#line 191
    if (! ((unsigned long )p < (unsigned long )lim)) {
#line 191
      goto while_break;
    }
    {
#line 194
    if (state == 0) {
#line 194
      goto case_0;
    }
#line 195
    if (state == 1) {
#line 195
      goto case_1;
    }
#line 196
    if (state == 2) {
#line 196
      goto case_2;
    }
#line 197
    if (state == 3) {
#line 197
      goto case_3;
    }
#line 192
    goto switch_break;
    case_0: /* CIL Label */ 
#line 194
    if ((int )*p >= 48) {
#line 194
      if ((int )*p <= 57) {
#line 194
        ip = p;
#line 194
        state ++;
      }
    }
#line 194
    goto switch_break;
    case_1: /* CIL Label */ 
#line 195
    if (32 == (int )*p) {
      {
#line 195
      ident = atoi((char const   *)ip);
#line 195
      state ++;
      }
    }
#line 195
    goto switch_break;
    case_2: /* CIL Label */ 
#line 196
    if (32 != (int )*p) {
#line 196
      gr = p;
#line 196
      state ++;
    }
#line 196
    goto switch_break;
    case_3: /* CIL Label */ 
#line 198
    if (10 != (int )*p) {
#line 199
      goto switch_break;
    }
    {
#line 200
    tmp___1 = add___3(ident, gr, (int )(p - gr));
    }
#line 200
    if (-1 == tmp___1) {
      {
#line 202
      log_((char *)"reload:no memory");
      }
#line 203
      return (-1);
    }
#line 205
    state = 0;
    switch_break: /* CIL Label */ ;
    }
#line 191
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 208
  oldsize___2 = newsize;
#line 209
  return (0);
}
}
#line 127 "/usr/include/x86_64-linux-gnu/sys/socket.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) getsockname)(int __fd ,
                                                                                  struct sockaddr * __restrict  __addr ,
                                                                                  socklen_t * __restrict  __len ) ;
#line 141
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) getpeername)(int __fd ,
                                                                                  struct sockaddr * __restrict  __addr ,
                                                                                  socklen_t * __restrict  __len ) ;
#line 53 "/usr/include/arpa/inet.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) inet_ntoa)(struct in_addr __in ) ;
#line 12 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/snntpd.h"
char *client_ip  ;
#line 13 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/snntpd.h"
char *me  ;
#line 47 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/snntpd.c"
bool posting_ok  =    (bool )0;
#line 52 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/snntpd.c"
int fifo  =    -1;
#line 71
void do_quit(void) ;
#line 92 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/snntpd.c"
static struct cmd cmds[21]  = 
#line 92
  {      {(char *)"article", & do_article, (char)1, (char)0, (char)0, (char)0}, 
        {(char *)"body", & do_body, (char)1, (char)0, (char)0, (char)0}, 
        {(char *)"group", & do_group, (char)2, (char)0, (char)0, (char)1}, 
        {(char *)"head", & do_head, (char)1, (char)0, (char)0, (char)0}, 
        {(char *)"help", & do_help, (char)0, (char)0, (char)0, (char)0}, 
        {(char *)"ihave", & do_ihave, (char)1, (char)0, (char)0, (char)0}, 
        {(char *)"last", & do_last, (char)1, (char)1, (char)1, (char)0}, 
        {(char *)"list", & do_list, (char)1, (char)0, (char)0, (char)1}, 
        {(char *)"listgroup", & do_listgroup, (char)1, (char)0, (char)0, (char)1}, 
        {(char *)"mode", & do_mode, (char)2, (char)0, (char)0, (char)0}, 
        {(char *)"newgroups", & do_newgroups, (char)3, (char)0, (char)0, (char)1}, 
        {(char *)"newnews", & do_newnews, (char)4, (char)0, (char)0, (char)1}, 
        {(char *)"next", & do_next, (char)1, (char)1, (char)1, (char)0}, 
        {(char *)"post", & do_post, (char)1, (char)0, (char)0, (char)0}, 
        {(char *)"quit", & do_quit, (char)1, (char)0, (char)0, (char)0}, 
        {(char *)"sendme", & do_sendme, (char)0, (char)0, (char)0, (char)0}, 
        {(char *)"slave", & do_slave, (char)0, (char)0, (char)0, (char)0}, 
        {(char *)"stat", & do_stat, (char)1, (char)0, (char)0, (char)0}, 
        {(char *)"xhdr", & do_xhdr, (char)2, (char)1, (char)0, (char)0}, 
        {(char *)"xover", & do_xover, (char)1, (char)1, (char)0, (char)0}, 
        {(char *)"xpat", & do_xpat, (char)4, (char)1, (char)0, (char)0}};
#line 119 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/snntpd.c"
static void cleanup(void) 
{ 
  int hit ;
  int miss ;

  {
#line 121
  if (debug >= 3) {
    {
#line 125
    art_filecachestat(& hit, & miss);
#line 126
    log_((char *)"do_quit:cache requests:%dT=%dH+%dM", hit + miss, hit, miss);
    }
  }
  {
#line 128
  dh_close();
#line 129
  group_fin();
  }
#line 130
  if (nr_keys) {
    {
#line 131
    key_free();
    }
  }
#line 132
  return;
}
}
#line 134 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/snntpd.c"
void do_quit(void) 
{ 


  {
  {
#line 136
  args_write(1, (char *)"205 bye\r\n");
#line 137
  cleanup();
#line 138
  _exit(0);
  }
}
}
#line 143 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/snntpd.c"
static bool checkservice  =    (bool )0;
#line 145 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/snntpd.c"
static void handler(int signum ) 
{ 


  {
#line 147
  if (1 == signum) {
#line 149
    checkservice = (bool )1;
#line 150
    return;
  }
  {
#line 152
  dh_close();
#line 153
  group_fin();
#line 154
  log_((char *)"Caught signal %d, exiting", signum);
#line 155
  _exit(3);
  }
}
}
#line 158 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/snntpd.c"
static void openfifo(void) 
{ 
  struct stat st ;
  int tmp ;

  {
#line 162
  if (fifo > -1) {
#line 163
    return;
  }
  {
#line 164
  fifo = open(".fifo", 2050);
  }
#line 165
  if (-1 == fifo) {
    {
#line 167
    log_((char *)"open(fifo):%m(ok)");
    }
#line 168
    return;
  }
  {
#line 170
  tmp = fstat(fifo, & st);
  }
#line 170
  if (-1 == tmp) {
    {
#line 171
    fail(2, (char *)"openfifo:stat(.fifo):%m");
    }
  }
#line 172
  if (! ((st.st_mode & 61440U) == 4096U)) {
    {
#line 174
    close(fifo);
#line 175
    fifo = -1;
    }
#line 176
    if (debug >= 1) {
      {
#line 176
      log_((char *)".fifo is not a fifo, ok");
      }
    }
  }
#line 178
  return;
}
}
#line 180 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/snntpd.c"
static void docheckservice(void) 
{ 
  struct stat st ;
  char *reason ;
  char buf___28[256] ;
  char *p ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 183
  reason = (char *)"maintenance";
#line 187
  tmp___0 = stat((char const   */* __restrict  */)".noservice", (struct stat */* __restrict  */)(& st));
  }
#line 187
  if (0 == tmp___0) {
#line 189
    if (st.st_size) {
      {
#line 190
      tmp = topline((char *)((void *)0), (char *)".noservice", buf___28, (int )sizeof(buf___28));
      }
#line 190
      if (-1 != tmp) {
#line 191
        reason = buf___28;
      }
    }
    {
#line 192
    args_write(1, (char *)"400 Service going down: %s\r\n", reason);
#line 193
    cleanup();
#line 194
    _exit(0);
    }
  }
  {
#line 196
  tmp___1 = stat((char const   */* __restrict  */)".nopost", (struct stat */* __restrict  */)(& st));
  }
#line 196
  if (0 == tmp___1) {
#line 197
    posting_ok = (bool )0;
  } else {
    {
#line 198
    p = getenv("POSTING_OK");
    }
#line 198
    if (p) {
#line 199
      posting_ok = (bool )1;
    } else {
#line 201
      posting_ok = (bool )0;
    }
  }
  {
#line 202
  openfifo();
#line 203
  checkservice = (bool )0;
  }
#line 204
  return;
}
}
#line 208
static void init___0(void) ;
#line 208 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/snntpd.c"
static struct __anonstruct_con_58 con[2]  = {      {(int (*)())(& getpeername), {(char )'T', (char )'C', (char )'P', (char )'R',
                                   (char )'E', (char )'M', (char )'O', (char )'T',
                                   (char )'E', (char )'I', (char )'P', (char )'\000'}}, 
        {(int (*)())(& getsockname),
      {(char )'T', (char )'C', (char )'P', (char )'L', (char )'O', (char )'C', (char )'A',
       (char )'L', (char )'I', (char )'P', (char )'\000'}}};
#line 206 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/snntpd.c"
static void init___0(void) 
{ 
  struct sigaction sa ;
  struct sockaddr_in sin ;
  int i ;
  int len ;
  int tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  char *tmp___5 ;

  {
  {
#line 216
  tmp = chdir((char const   *)snroot);
  }
#line 216
  if (-1 == tmp) {
    {
#line 217
    fail(2, (char *)"chdir(%s):%m", snroot);
    }
  }
  {
#line 218
  dh_open((char *)((void *)0), (bool )0);
#line 219
  tmp___0 = group_init();
  }
#line 219
  if (-1 == tmp___0) {
    {
#line 221
    dh_close();
#line 222
    _exit(2);
    }
  }
#line 224
  i = 0;
  {
#line 224
  while (1) {
    while_continue: /* CIL Label */ ;
#line 224
    len = (int )sizeof(sin);
#line 224
    if (! (i < 2)) {
#line 224
      goto while_break;
    }
    {
#line 225
    tmp___5 = getenv((char const   *)(con[i].buf));
    }
#line 225
    if (! tmp___5) {
      {
#line 226
      tmp___4 = (*(con[i].f))(0, (struct sockaddr *)(& sin), & len);
      }
#line 226
      if (0 == tmp___4) {
        {
#line 227
        tmp___1 = inet_ntoa(sin.sin_addr);
#line 227
        tmp___2 = strcat((char */* __restrict  */)(con[i].buf), (char const   */* __restrict  */)"=");
#line 227
        tmp___3 = strcat((char */* __restrict  */)tmp___2, (char const   */* __restrict  */)tmp___1);
#line 227
        putenv(tmp___3);
        }
      }
    }
#line 224
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 228
  client_ip = (con[0].buf + sizeof("TCPREMOTEIP")) - 1;
#line 229
  if (61 == (int )*client_ip) {
#line 230
    client_ip ++;
  }
  {
#line 231
  me = myname();
#line 232
  sa.__sigaction_handler.sa_handler = & handler;
#line 233
  sigemptyset(& sa.sa_mask);
#line 234
  sa.sa_flags = 268435456;
#line 235
  sigaction(1, (struct sigaction  const  */* __restrict  */)(& sa), (struct sigaction */* __restrict  */)((void *)0));
#line 236
  sa.__sigaction_handler.sa_handler = (void (*)(int  ))1;
#line 237
  sigaction(13, (struct sigaction  const  */* __restrict  */)(& sa), (struct sigaction */* __restrict  */)((void *)0));
#line 239
  docheckservice();
  }
#line 240
  return;
}
}
#line 242 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/snntpd.c"
static int getallgroups(void) 
{ 
  DIR *dir ;
  struct dirent *dp ;
  char *gr ;
  size_t tmp ;
  int tmp___0 ;
  bool tmp___1 ;

  {
  {
#line 248
  dir = opendir(".");
  }
#line 248
  if (! dir) {
    {
#line 250
    log_((char *)"getallgroups:opendir(%s):%m", snroot);
    }
#line 251
    return (-1);
  }
#line 253
  nr_keys = 0;
  {
#line 253
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 253
    dp = readdir(dir);
    }
#line 253
    if (! dp) {
#line 253
      goto while_break;
    }
    {
#line 254
    gr = dp->d_name;
#line 254
    tmp___1 = is_valid_group(gr);
    }
#line 254
    if (tmp___1) {
      {
#line 255
      tmp = strlen((char const   *)gr);
#line 255
      tmp___0 = key_add(& gr, (int )tmp);
      }
#line 255
      if (-1 == tmp___0) {
        {
#line 256
        fail(2, (char *)"No memory");
        }
      }
    }
#line 253
    nr_keys ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 257
  closedir(dir);
  }
#line 258
  return (0);
}
}
#line 261 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/snntpd.c"
static void usage___0(void) 
{ 


  {
  {
#line 261
  fail(1, (char *)"Usage:%s [-S] [-t timeout]", progname);
  }
#line 261
  return;
}
}
#line 366 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/snntpd.c"
int alltolower(char *buf___28 ) 
{ 
  char *cp ;
  int tmp ;
  unsigned short const   **tmp___0 ;

  {
#line 370
  cp = buf___28;
  {
#line 370
  while (1) {
    while_continue: /* CIL Label */ ;
#line 370
    if (! *cp) {
#line 370
      goto while_break;
    }
    {
#line 371
    tmp___0 = __ctype_b_loc();
    }
#line 371
    if ((int const   )*(*tmp___0 + (int )*cp) & 256) {
      {
#line 372
      tmp = tolower((int )*cp);
#line 372
      *cp = (char )tmp;
      }
    }
#line 370
    cp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 373
  return ((int )(cp - buf___28));
}
}
#line 376 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/snntpd.c"
int topline(char *group , char *fn , char *buf___28 , int size___1 ) 
{ 
  int fd ;
  int i ;
  char *cp ;
  ssize_t tmp ;

  {
#line 381
  if ((unsigned long )((void *)0) == (unsigned long )group) {
    {
#line 382
    fd = open((char const   *)fn, 0);
    }
  } else {
    {
#line 384
    fd = openf(0, 0, (char *)"%s/%s", group, fn);
    }
  }
#line 385
  if (-1 == fd) {
#line 386
    return (-1);
  }
  {
#line 387
  tmp = read(fd, (void *)buf___28, (size_t )(size___1 - 1));
#line 387
  i = (int )tmp;
#line 388
  close(fd);
  }
#line 389
  if (i <= 0) {
#line 390
    return (i);
  }
  {
#line 391
  *(buf___28 + i) = (char )'\000';
#line 392
  cp = strchr((char const   *)buf___28, '\n');
  }
#line 392
  if (cp) {
#line 394
    *cp = (char )'\000';
#line 395
    return ((int )(cp - buf___28));
  }
#line 397
  return (i);
}
}
#line 400 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/snntpd.c"
char *currentgroup  =    (char *)((void *)0);
#line 401 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/snntpd.c"
int currentserial  =    -1;
#line 402 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/snntpd.c"
struct group currentinfo  =    {0, 0, 0, 0U};
#line 408 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/snntpd.c"
int make_current(char *group ) 
{ 
  void *tmp ;
  size_t tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;

  {
#line 410
  if (! currentgroup) {
    {
#line 412
    tmp = malloc((size_t )256);
#line 412
    currentgroup = (char *)tmp;
    }
#line 412
    if (! currentgroup) {
      {
#line 414
      log_((char *)"make_current:no memory");
      }
#line 415
      return (-1);
    }
    {
#line 417
    strcpy((char */* __restrict  */)currentgroup, (char const   */* __restrict  */)"no.group.selected.yet");
    }
  }
  {
#line 420
  tmp___0 = strlen((char const   *)group);
#line 420
  tmp___1 = key_exists(group, (int )tmp___0);
  }
#line 420
  if (! tmp___1) {
#line 421
    return (-1);
  }
  {
#line 422
  tmp___2 = group_info(group, & currentinfo);
  }
#line 422
  if (-1 == tmp___2) {
#line 423
    return (-1);
  }
  {
#line 424
  strcpy((char */* __restrict  */)currentgroup, (char const   */* __restrict  */)group);
#line 425
  currentserial = -1;
  }
#line 426
  return (0);
}
}
#line 429 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/snntpd.c"
int pipefork(int *p ) 
{ 
  int pid___0 ;
  int tmp ;

  {
  {
#line 431
  tmp = pipe(p);
  }
#line 431
  if (0 == tmp) {
    {
#line 435
    pid___0 = fork();
    }
#line 435
    if (pid___0 > -1) {
#line 436
      return (pid___0);
    }
    {
#line 437
    close(*(p + 0));
    }
  }
#line 439
  return (-1);
}
}
#line 87 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/cache.c"
static struct entry *new_entry___3(int desc___35 ) 
{ 
  struct entry *ep ;
  struct entry *tmp ;

  {
#line 91
  ep = table[desc___35].freelist;
#line 91
  if (ep) {
#line 92
    table[desc___35].freelist = ep->next;
  } else {
#line 95
    ep = table[desc___35].entries;
    {
#line 95
    while (1) {
      while_continue: /* CIL Label */ ;
#line 95
      if (! ep->next) {
#line 95
        goto while_break;
      }
#line 95
      ep = ep->next;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 96
    (ep->prev)->next = (struct entry *)((void *)0);
#line 97
    (*(table[desc___35].freeobj))(ep->object);
    }
  }
#line 99
  tmp = (struct entry *)((void *)0);
#line 99
  ep->next = tmp;
#line 99
  ep->prev = tmp;
#line 100
  ep->object = (void *)0;
#line 101
  return (ep);
}
}
#line 30 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/snsplit.c"
static void nomem___0(void) 
{ 


  {
  {
#line 30
  fail(2, (char *)"no memory");
  }
#line 30
  return;
}
}
#line 34 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/snsplit.c"
static int tmpfd___0  ;
#line 39 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/snsplit.c"
static char seqbuf[sizeof("SEQUENCE=000000")]  ;
#line 40 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/snsplit.c"
static char bytebuf[40]  ;
#line 41 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/snsplit.c"
static char hlbuf[50]  ;
#line 42 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/snsplit.c"
static char blbuf[50]  ;
#line 43 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/snsplit.c"
static int head_lines  ;
#line 44 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/snsplit.c"
static int body_lines  ;
#line 46 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/snsplit.c"
static struct export *exports  =    (struct export *)((void *)0);
#line 52 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/snsplit.c"
static int nrexports  ;
#line 54 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/snsplit.c"
static char **env  =    (char **)((void *)0);
#line 55 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/snsplit.c"
static int envstart  ;
#line 55 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/snsplit.c"
static int envused  ;
#line 55 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/snsplit.c"
static int envend  ;
#line 56 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/snsplit.c"
static int article_bytes  ;
#line 58 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/snsplit.c"
void clear_env(void) 
{ 
  int i ;

  {
#line 62
  i = envstart;
  {
#line 62
  while (1) {
    while_continue: /* CIL Label */ ;
#line 62
    if (! (i < envend)) {
#line 62
      goto while_break;
    }
#line 63
    if (*(env + i)) {
      {
#line 65
      free((void *)*(env + i));
#line 66
      *(env + i) = (char *)((void *)0);
      }
    }
#line 62
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 68
  i = 0;
  {
#line 68
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 68
    if (! (i < nrexports)) {
#line 68
      goto while_break___0;
    }
#line 69
    (exports + i)->s = (char *)0;
#line 68
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 70
  envused = envstart;
#line 70
  *(env + envused) = (char *)((void *)0);
#line 71
  return;
}
}
#line 73 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/snsplit.c"
void put_env(int index___0 , char *value ) 
{ 
  struct export *ep ;
  int len ;
  char *p ;
  char *q ;
  size_t tmp ;
  void *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;

  {
  {
#line 80
  ep = exports + index___0;
#line 81
  tmp = strlen((char const   *)value);
#line 81
  len = (int )(((size_t )((ep->len + 4) + 1) + tmp) + 1UL);
#line 81
  tmp___0 = malloc((size_t )len);
#line 81
  ep->s = (char *)tmp___0;
  }
#line 82
  if (! ep->s) {
    {
#line 83
    nomem___0();
    }
  }
  {
#line 84
  strcpy((char */* __restrict  */)ep->s, (char const   */* __restrict  */)"FLD_");
#line 85
  p = ep->s + 4;
#line 85
  q = ep->name;
  }
  {
#line 85
  while (1) {
    while_continue: /* CIL Label */ ;
#line 85
    if (! *q) {
#line 85
      goto while_break;
    }
#line 86
    if ((int )*q >= 97) {
#line 86
      if ((int )*q <= 122) {
#line 87
        *p = (char )((int )*q - 32);
      } else {
#line 86
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 88
    if (45 == (int )*q) {
#line 89
      *p = (char )'_';
    }
#line 85
    q ++;
#line 85
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 90
  tmp___1 = p;
#line 90
  p ++;
#line 90
  *tmp___1 = (char )'=';
#line 91
  strcpy((char */* __restrict  */)p, (char const   */* __restrict  */)value);
#line 92
  tmp___2 = envused;
#line 92
  envused ++;
#line 92
  *(env + tmp___2) = ep->s;
  }
#line 93
  return;
}
}
#line 95
extern char **environ ;
#line 97 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/snsplit.c"
void setup_env(char **headers ) 
{ 
  int i ;
  int nr___13 ;
  int seq ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  void *tmp___4 ;
  int tmp___5 ;
  char *p ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  void *tmp___9 ;
  char *tmp___10 ;
  size_t tmp___11 ;

  {
#line 102
  nr___13 = 0;
  {
#line 102
  while (1) {
    while_continue: /* CIL Label */ ;
#line 102
    if (! *(environ + nr___13)) {
#line 102
      goto while_break;
    }
#line 102
    nr___13 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 103
  seq = 0;
#line 104
  i = 0;
  {
#line 104
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 104
    if (! *(environ + i)) {
#line 104
      goto while_break___0;
    }
#line 105
    if (! seq) {
      {
#line 105
      tmp___3 = strncmp((char const   *)*(environ + i), "SEQUENCE=", (size_t )9);
      }
#line 105
      if (0 == tmp___3) {
        {
#line 107
        seq = atoi((char const   *)(*(environ + i) + 9));
#line 108
        nr___13 --;
#line 108
        *(environ + i) = *(environ + nr___13);
#line 109
        *(environ + nr___13) = (char *)0;
        }
      } else {
#line 105
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
      {
#line 111
      tmp = strncmp((char const   *)*(environ + i), "FLD_", (size_t )4);
      }
#line 111
      if (0 == tmp) {
#line 116
        nr___13 --;
#line 116
        *(environ + i) = *(environ + nr___13);
#line 117
        *(environ + nr___13) = (char *)0;
      } else {
        {
#line 111
        tmp___0 = strncmp((char const   *)*(environ + i), "BYTES=", (size_t )6);
        }
#line 111
        if (0 == tmp___0) {
#line 116
          nr___13 --;
#line 116
          *(environ + i) = *(environ + nr___13);
#line 117
          *(environ + nr___13) = (char *)0;
        } else {
          {
#line 111
          tmp___1 = strncmp((char const   *)*(environ + i), "HEAD_LINES=", (size_t )11);
          }
#line 111
          if (0 == tmp___1) {
#line 116
            nr___13 --;
#line 116
            *(environ + i) = *(environ + nr___13);
#line 117
            *(environ + nr___13) = (char *)0;
          } else {
            {
#line 111
            tmp___2 = strncmp((char const   *)*(environ + i), "BODY_LINES=", (size_t )11);
            }
#line 111
            if (0 == tmp___2) {
#line 116
              nr___13 --;
#line 116
              *(environ + i) = *(environ + nr___13);
#line 117
              *(environ + nr___13) = (char *)0;
            } else {
#line 120
              i ++;
            }
          }
        }
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 121
  tmp___4 = malloc((unsigned long )(i + 6) * sizeof(char *));
#line 121
  env = (char **)tmp___4;
  }
#line 121
  if (! env) {
    {
#line 122
    nomem___0();
    }
  }
#line 123
  nr___13 = 0;
  {
#line 123
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 123
    if (! (nr___13 < i)) {
#line 123
      goto while_break___1;
    }
#line 124
    *(env + i) = *(environ + i);
#line 123
    nr___13 ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 125
  tmp___5 = nr___13;
#line 125
  nr___13 ++;
#line 125
  *(env + tmp___5) = strcpy((char */* __restrict  */)(seqbuf), (char const   */* __restrict  */)"SEQUENCE=000000");
  }
#line 126
  if (seq > 0) {
#line 126
    if (seq < 999999) {
#line 130
      seq ++;
#line 131
      p = (seqbuf + sizeof("SEQUENCE=000000")) - 2;
      {
#line 131
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 131
        if (! (seq > 0)) {
#line 131
          goto while_break___2;
        }
#line 132
        *p = (char )((int )*p + seq % 10);
#line 131
        p --;
#line 131
        seq /= 10;
      }
      while_break___2: /* CIL Label */ ;
      }
    }
  }
#line 134
  tmp___6 = nr___13;
#line 134
  nr___13 ++;
#line 134
  *(env + tmp___6) = bytebuf;
#line 135
  tmp___7 = nr___13;
#line 135
  nr___13 ++;
#line 135
  *(env + tmp___7) = hlbuf;
#line 136
  tmp___8 = nr___13;
#line 136
  nr___13 ++;
#line 136
  *(env + tmp___8) = blbuf;
#line 137
  *(env + nr___13) = (char *)0;
#line 138
  envstart = nr___13;
#line 138
  envused = envstart;
#line 139
  envend = nr___13 + nrexports;
#line 140
  if (! headers) {
#line 141
    return;
  }
  {
#line 143
  tmp___9 = malloc((unsigned long )nrexports * sizeof(struct export ));
#line 143
  exports = (struct export *)tmp___9;
  }
#line 144
  if (! exports) {
    {
#line 145
    nomem___0();
    }
  }
#line 146
  i = 0;
  {
#line 146
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 146
    if (! (i < nrexports)) {
#line 146
      goto while_break___3;
    }
    {
#line 148
    (exports + i)->s = (char *)0;
#line 149
    tmp___10 = *(headers + i);
#line 149
    (exports + i)->name = tmp___10;
#line 149
    tmp___11 = strlen((char const   *)tmp___10);
#line 149
    (exports + i)->len = (int )tmp___11;
#line 146
    i ++;
    }
  }
  while_break___3: /* CIL Label */ ;
  }
#line 151
  return;
}
}
#line 153 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/snsplit.c"
static void writetmp(char *buf___28 , int len ) 
{ 
  ssize_t tmp ;

  {
  {
#line 155
  tmp = write(tmpfd___0, (void const   *)buf___28, (size_t )len);
  }
#line 155
  if (-1L == tmp) {
    {
#line 156
    fail(2, (char *)"can\'t write to tmp file:%m");
    }
  }
#line 157
  article_bytes += len;
#line 158
  return;
}
}
#line 160 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/snsplit.c"
int write_file(char *line , int len ) 
{ 
  int i ;
  int n ;
  char *p ;
  int tmp ;

  {
  {
#line 164
  writetmp(line, len);
#line 165
  writetmp((char *)"\n", 1);
#line 166
  head_lines ++;
#line 168
  i = 0;
  }
  {
#line 168
  while (1) {
    while_continue: /* CIL Label */ ;
#line 168
    if (! (i < nrexports)) {
#line 168
      goto while_break;
    }
#line 172
    n = (exports + i)->len;
#line 173
    if (! (exports + i)->s) {
#line 173
      if (len >= n) {
#line 173
        if (58 == (int )*(line + n)) {
          {
#line 174
          tmp = strncasecmp((char const   *)line, (char const   *)(exports + i)->name,
                            (size_t )n);
          }
#line 174
          if (0 == tmp) {
#line 178
            p = (line + n) + 1;
            {
#line 178
            while (1) {
              while_continue___0: /* CIL Label */ ;
#line 178
              if (! (32 == (int )*p)) {
#line 178
                goto while_break___0;
              }
#line 178
              p ++;
            }
            while_break___0: /* CIL Label */ ;
            }
            {
#line 179
            put_env(i, p);
            }
#line 180
            goto while_break;
          }
        }
      }
    }
#line 168
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 183
  return (0);
}
}
#line 186 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/snsplit.c"
static void shortread(void) 
{ 


  {
  {
#line 186
  fail(3, (char *)"unexpected EOF");
  }
#line 186
  return;
}
}
#line 187 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/snsplit.c"
static void badread(void) 
{ 


  {
  {
#line 187
  fail(2, (char *)"can\'t read article:%m");
  }
#line 187
  return;
}
}
#line 188 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/snsplit.c"
static void badfmt(void) 
{ 


  {
  {
#line 188
  fail(3, (char *)"bad rnews line");
  }
#line 188
  return;
}
}
#line 190 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/snsplit.c"
int read_rnews(void) 
{ 
  char *line ;
  int len ;
  int c ;
  int bytes___1 ;
  char *tmp ;
  char *tmp___0 ;
  int tmp___1 ;

  {
  {
#line 195
  len = readln(& input, & line, '\n');
  }
#line 196
  if (0 == len) {
#line 197
    return (0);
  }
#line 198
  if (-1 == len) {
    {
#line 198
    badread();
    }
  }
#line 199
  len --;
#line 199
  *(line + len) = (char )'\000';
#line 200
  if (len > 0) {
#line 201
    if (13 == (int )*(line + (len - 1))) {
#line 202
      len --;
#line 202
      *(line + len) = (char )'\000';
    }
  }
#line 203
  tmp = line;
#line 203
  line ++;
#line 203
  if (35 != (int )*tmp) {
    {
#line 203
    badfmt();
    }
  }
#line 204
  tmp___0 = line;
#line 204
  line ++;
#line 204
  if (33 != (int )*tmp___0) {
    {
#line 204
    badfmt();
    }
  }
  {
#line 205
  while (1) {
    while_continue: /* CIL Label */ ;
#line 205
    if (! (32 == (int )*line)) {
#line 205
      goto while_break;
    }
#line 206
    line ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 207
  tmp___1 = strncmp((char const   *)line, "rnews ", (size_t )6);
  }
#line 207
  if (tmp___1) {
    {
#line 207
    badfmt();
    }
  }
#line 208
  line += 6;
  {
#line 208
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 208
    if (! (32 == (int )*line)) {
#line 208
      goto while_break___0;
    }
#line 208
    line ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 209
  bytes___1 = 0;
  {
#line 209
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 209
    c = (int )*line;
#line 209
    if (! c) {
#line 209
      goto while_break___1;
    }
#line 210
    if (c < 48) {
      {
#line 210
      badfmt();
      }
    } else
#line 210
    if (c > 57) {
      {
#line 210
      badfmt();
      }
    } else {
#line 213
      bytes___1 *= 10;
#line 214
      bytes___1 += c - 48;
    }
#line 209
    line ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 217
  len = unfold(& input, & write_file);
  }
#line 218
  if (0 == len) {
    {
#line 218
    shortread();
    }
  }
#line 219
  if (len < 0) {
    {
#line 219
    badread();
    }
  }
  {
#line 220
  bytes___1 -= len;
#line 221
  writetmp((char *)"\n", 1);
  }
  {
#line 223
  while (1) {
    while_continue___2: /* CIL Label */ ;
    {
#line 225
    len = readln(& input, & line, '\n');
    }
#line 225
    if (-1 == len) {
      {
#line 225
      badread();
      }
    }
#line 226
    if (0 == len) {
      {
#line 226
      shortread();
      }
    }
#line 227
    bytes___1 -= len;
#line 227
    if (bytes___1 < 0) {
      {
#line 227
      shortread();
      }
    }
#line 228
    len --;
#line 228
    if (len > 0) {
#line 229
      if (13 == (int )*(line + (len - 1))) {
#line 230
        len --;
      }
    }
#line 231
    if (len) {
      {
#line 232
      writetmp(line, len);
      }
    }
    {
#line 233
    writetmp((char *)"\n", 1);
#line 234
    body_lines ++;
    }
#line 223
    if (! (bytes___1 > 0)) {
#line 223
      goto while_break___2;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
#line 237
  return (1);
}
}
#line 240 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/snsplit.c"
int read_wire(void) 
{ 
  char *line ;
  int len ;
  int tmp ;

  {
  {
#line 245
  tmp = unfold(& input, & write_file);
  }
  {
#line 247
  if (tmp == 0) {
#line 247
    goto case_0;
  }
#line 249
  if (tmp == -1) {
#line 249
    goto case_neg_1;
  }
#line 251
  if (tmp == -2) {
#line 251
    goto case_neg_2;
  }
#line 245
  goto switch_break;
  case_0: /* CIL Label */ 
#line 248
  return (0);
  case_neg_1: /* CIL Label */ 
  {
#line 250
  badread();
  }
  case_neg_2: /* CIL Label */ 
  {
#line 252
  badfmt();
  }
  switch_break: /* CIL Label */ ;
  }
  {
#line 254
  writetmp((char *)"\n", 1);
  }
  {
#line 255
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 255
    len = readln(& input, & line, '\n');
    }
#line 255
    if (! (len > 0)) {
#line 255
      goto while_break;
    }
#line 257
    len --;
#line 257
    if (len > 0) {
#line 258
      if (13 == (int )*(line + (len - 1))) {
#line 259
        len --;
      }
    }
#line 260
    if (46 == (int )*line) {
#line 262
      len --;
#line 262
      if (0 == len) {
#line 263
        return (1);
      }
#line 264
      line ++;
    }
#line 266
    if (len > 0) {
      {
#line 267
      writetmp(line, len);
      }
    }
    {
#line 268
    writetmp((char *)"\n", 1);
#line 269
    body_lines ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 271
  if (0 == len) {
    {
#line 272
    shortread();
    }
  }
  {
#line 273
  badread();
  }
#line 275
  return (0);
}
}
#line 280 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/snsplit.c"
static void incseq(void) 
{ 
  int i ;

  {
#line 284
  i = (int )(sizeof("SEQUENCE=000000") - 2UL);
  {
#line 284
  while (1) {
    while_continue: /* CIL Label */ ;
#line 284
    if (! ((unsigned long )i > sizeof("SEQUENCE=") - 2UL)) {
#line 284
      goto while_break;
    }
#line 286
    seqbuf[i] = (char )((int )seqbuf[i] + 1);
#line 287
    if ((int )seqbuf[i] <= 57) {
#line 288
      goto while_break;
    }
#line 289
    seqbuf[i] = (char )'0';
#line 284
    i --;
  }
  while_break: /* CIL Label */ ;
  }
#line 291
  return;
}
}
#line 67 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/store.c"
static int sto_cmp___1(void *a , void *b___13 ) 
{ 
  register struct storeobj *x ;
  register struct storeobj *y ;
  int tmp ;

  {
  {
#line 69
  x = (struct storeobj *)a;
#line 70
  y = (struct storeobj *)b___13;
#line 72
  tmp = strcmp((char const   *)x->filename, (char const   *)y->filename);
  }
#line 72
  return (tmp);
}
}
#line 75 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/store.c"
static int nosigio___1(ssize_t (*op)() , int fd , char *buf___28 , int len ) 
{ 
  int er ;
  int *tmp ;
  ssize_t tmp___0 ;

  {
  {
#line 79
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 79
    tmp___0 = (*op)(fd, buf___28, len);
#line 79
    er = (int )tmp___0;
    }
#line 79
    if (! (-1 == er)) {
#line 79
      goto while_break;
    }
    {
#line 80
    tmp = __errno_location();
    }
#line 80
    if (4 != *tmp) {
#line 82
      if (debug >= 1) {
        {
#line 82
        log_((char *)"nosigio:%m");
        }
      }
#line 83
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 85
  return (er);
}
}
#line 88 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/store.c"
static int copyart___1(int tofd , int fromfd , int fromseek , int len ) 
{ 
  char buf___28[1024] ;
  __off_t tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  {
#line 92
  tmp = lseek(fromfd, (__off_t )fromseek, 0);
  }
#line 92
  if (-1L == tmp) {
    {
#line 94
    log_((char *)"copyart:lseek:%m");
    }
#line 95
    return (-1);
  }
  {
#line 98
  while (1) {
    while_continue: /* CIL Label */ ;
#line 98
    if (! (len > 1024)) {
#line 98
      goto while_break;
    }
    {
#line 99
    tmp___0 = nosigio___1((ssize_t (*)())(& read), fromfd, buf___28, 1024);
    }
#line 99
    if (-1 == tmp___0) {
#line 100
      return (-1);
    } else {
      {
#line 99
      tmp___1 = nosigio___1((ssize_t (*)())(& write), tofd, buf___28, 1024);
      }
#line 99
      if (-1 == tmp___1) {
#line 100
        return (-1);
      }
    }
#line 98
    len -= 1024;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 101
  tmp___2 = nosigio___1((ssize_t (*)())(& read), fromfd, buf___28, len);
  }
#line 101
  if (-1 == tmp___2) {
#line 102
    return (-1);
  } else {
    {
#line 101
    tmp___3 = nosigio___1((ssize_t (*)())(& write), tofd, buf___28, len);
    }
#line 101
    if (-1 == tmp___3) {
#line 102
      return (-1);
    }
  }
#line 104
  return (0);
}
}
#line 107 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/store.c"
static int checkindex___1(struct info *p ) 
{ 


  {
#line 109
  if (p->hoffset > 0) {
#line 111
    if (p->boffset > 0) {
#line 112
      if (p->hlen > 0) {
#line 113
        if (p->blen > 0) {
#line 114
          return (0);
        }
      }
    }
  } else
#line 116
  if (-1 == p->hoffset) {
#line 116
    if (-1 == p->boffset) {
#line 117
      return (1);
    }
  }
#line 118
  return (-1);
}
}
#line 127 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/store.c"
static void reorder___1(struct storeobj *sp ) 
{ 
  char tmpname[287] ;
  char *p ;
  char *q ;
  int fd ;
  struct file f___9 ;
  int er ;
  int i ;
  char *tmp ;
  char tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char tmp___4 ;
  char *tmp___5 ;
  int *tmp___6 ;
  int tmp___7 ;
  char *p___0 ;
  int *tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  __off_t tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  __off_t tmp___17 ;
  __off_t tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;

  {
#line 133
  f___9.magic = 0;
#line 133
  f___9.info[0].hoffset = 0;
#line 133
  f___9.info[0].hlen = 0;
#line 133
  f___9.info[0].boffset = 0;
#line 133
  f___9.info[0].blen = 0;
#line 133
  f___9.info[1].hoffset = 0;
#line 133
  f___9.info[1].hlen = 0;
#line 133
  f___9.info[1].boffset = 0;
#line 133
  f___9.info[1].blen = 0;
#line 133
  f___9.info[2].hoffset = 0;
#line 133
  f___9.info[2].hlen = 0;
#line 133
  f___9.info[2].boffset = 0;
#line 133
  f___9.info[2].blen = 0;
#line 133
  f___9.info[3].hoffset = 0;
#line 133
  f___9.info[3].hlen = 0;
#line 133
  f___9.info[3].boffset = 0;
#line 133
  f___9.info[3].blen = 0;
#line 133
  f___9.info[4].hoffset = 0;
#line 133
  f___9.info[4].hlen = 0;
#line 133
  f___9.info[4].boffset = 0;
#line 133
  f___9.info[4].blen = 0;
#line 133
  f___9.info[5].hoffset = 0;
#line 133
  f___9.info[5].hlen = 0;
#line 133
  f___9.info[5].boffset = 0;
#line 133
  f___9.info[5].blen = 0;
#line 133
  f___9.info[6].hoffset = 0;
#line 133
  f___9.info[6].hlen = 0;
#line 133
  f___9.info[6].boffset = 0;
#line 133
  f___9.info[6].blen = 0;
#line 133
  f___9.info[7].hoffset = 0;
#line 133
  f___9.info[7].hlen = 0;
#line 133
  f___9.info[7].boffset = 0;
#line 133
  f___9.info[7].blen = 0;
#line 133
  f___9.info[8].hoffset = 0;
#line 133
  f___9.info[8].hlen = 0;
#line 133
  f___9.info[8].boffset = 0;
#line 133
  f___9.info[8].blen = 0;
#line 133
  f___9.info[9].hoffset = 0;
#line 133
  f___9.info[9].hlen = 0;
#line 133
  f___9.info[9].boffset = 0;
#line 133
  f___9.info[9].blen = 0;
#line 136
  p = tmpname;
#line 136
  q = sp->filename;
  {
#line 136
  while (1) {
    while_continue: /* CIL Label */ ;
#line 136
    tmp = p;
#line 136
    p ++;
#line 136
    tmp___1 = q;
#line 136
    q ++;
#line 136
    tmp___0 = *tmp___1;
#line 136
    *tmp = tmp___0;
#line 136
    if (! ((int )tmp___0 != 47)) {
#line 136
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 137
  tmp___2 = p;
#line 137
  p ++;
#line 137
  *tmp___2 = (char )'+';
  {
#line 138
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 138
    tmp___3 = p;
#line 138
    p ++;
#line 138
    tmp___5 = q;
#line 138
    q ++;
#line 138
    tmp___4 = *tmp___5;
#line 138
    *tmp___3 = tmp___4;
#line 138
    if (! tmp___4) {
#line 138
      goto while_break___0;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 139
  fd = open((char const   *)(tmpname), 194, 420);
  }
#line 140
  if (-1 == fd) {
    {
#line 142
    tmp___6 = __errno_location();
    }
#line 142
    if (17 != *tmp___6) {
      {
#line 143
      log_((char *)"reorder:open(%s):%m", tmpname);
      }
    }
#line 144
    return;
  }
  {
#line 147
  f___9.magic = 1027296;
#line 148
  tmp___7 = nosigio___1((ssize_t (*)())(& write), fd, (char *)(& f___9), (int )sizeof(f___9));
  }
#line 148
  if (-1 == tmp___7) {
#line 149
    goto fail;
  }
  {
#line 161
  tmp___9 = lockf(sp->fd, 2, (__off_t )0);
  }
#line 161
  if (-1 == tmp___9) {
    {
#line 165
    tmp___8 = __errno_location();
    }
#line 165
    if (11 != *tmp___8) {
#line 166
      p___0 = (char *)"reorder:can\'t lockf %s:%m";
    } else {
#line 168
      p___0 = (char *)"reorder:article in %s being cancelled?";
    }
    {
#line 169
    log_(p___0, sp->filename);
    }
#line 170
    goto fail;
  }
#line 173
  i = 0;
  {
#line 173
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 173
    if (! (i < 10)) {
#line 173
      goto while_break___1;
    }
    {
#line 174
    tmp___10 = checkindex___1((sp->file)->info + i);
    }
    {
#line 176
    if (tmp___10 == 0) {
#line 176
      goto case_0;
    }
#line 188
    if (tmp___10 == 1) {
#line 188
      goto case_1;
    }
#line 191
    if (tmp___10 == -1) {
#line 191
      goto case_neg_1;
    }
#line 174
    goto switch_break;
    case_0: /* CIL Label */ 
    {
#line 177
    tmp___12 = lseek(fd, (__off_t )0, 2);
#line 177
    tmp___11 = (int )tmp___12;
#line 177
    f___9.info[i].hoffset = tmp___11;
    }
#line 177
    if (tmp___11 > 0) {
      {
#line 179
      f___9.info[i].hlen = (sp->file)->info[i].hlen;
#line 180
      f___9.info[i].blen = (sp->file)->info[i].blen;
#line 181
      er = copyart___1(fd, sp->fd, (sp->file)->info[i].hoffset, f___9.info[i].hlen);
      }
#line 182
      if (0 == er) {
#line 183
        goto switch_break;
      }
    } else {
      {
#line 186
      log_((char *)"reorder:lseek(%s):%m", tmpname);
      }
    }
#line 187
    goto fail;
    case_1: /* CIL Label */ 
#line 189
    tmp___15 = -1;
#line 189
    f___9.info[i].hlen = tmp___15;
#line 189
    tmp___14 = tmp___15;
#line 189
    f___9.info[i].blen = tmp___14;
#line 189
    tmp___13 = tmp___14;
#line 189
    f___9.info[i].hoffset = tmp___13;
#line 189
    f___9.info[i].boffset = tmp___13;
#line 190
    goto switch_break;
    case_neg_1: /* CIL Label */ 
    {
#line 192
    log_((char *)"reorder:corrupt index in %s", sp->filename);
    }
#line 193
    goto fail;
    switch_break: /* CIL Label */ ;
    }
#line 173
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 195
  i = 0;
  {
#line 195
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 195
    if (! (i < 10)) {
#line 195
      goto while_break___2;
    }
#line 197
    if (-1 == f___9.info[i].boffset) {
#line 198
      goto __Cont;
    }
    {
#line 199
    tmp___17 = lseek(fd, (__off_t )0, 2);
#line 199
    tmp___16 = (int )tmp___17;
#line 199
    f___9.info[i].boffset = tmp___16;
    }
#line 199
    if (-1 == tmp___16) {
      {
#line 201
      log_((char *)"reorder:lseek(%s):%m", tmpname);
      }
#line 202
      goto fail;
    }
    {
#line 204
    er = copyart___1(fd, sp->fd, (sp->file)->info[i].boffset, f___9.info[i].blen);
    }
#line 205
    if (-1 == er) {
#line 206
      goto fail;
    }
    __Cont: /* CIL Label */ 
#line 195
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 209
  tmp___18 = lseek(fd, (__off_t )0, 0);
  }
#line 209
  if (-1L == tmp___18) {
    {
#line 211
    log_((char *)"reorder:lseek:%m");
    }
#line 212
    goto fail;
  }
  {
#line 214
  tmp___19 = nosigio___1((ssize_t (*)())(& write), fd, (char *)(& f___9), (int )sizeof(f___9));
  }
#line 214
  if (-1 == tmp___19) {
#line 215
    goto fail;
  }
  {
#line 216
  tmp___20 = rename((char const   *)(tmpname), (char const   *)sp->filename);
  }
#line 216
  if (-1 == tmp___20) {
    {
#line 218
    log_((char *)"reorder:rename:%m");
    }
#line 219
    goto fail;
  }
  {
#line 221
  close(fd);
  }
#line 222
  return;
  fail: 
  {
#line 225
  log_((char *)"reorder:write failed for %s:%m", sp->filename);
#line 226
  tmp___21 = unlink((char const   *)(tmpname));
  }
#line 226
  if (-1 == tmp___21) {
    {
#line 227
    log_((char *)"reorder:unlink(%s):%m", tmpname);
    }
  }
  {
#line 228
  close(fd);
  }
#line 229
  return;
}
}
#line 231 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/store.c"
static void sto_free___1(void *p ) 
{ 
  struct storeobj *sp ;
  int tmp ;

  {
  {
#line 233
  sp = (struct storeobj *)p;
#line 235
  close(sp->fd);
#line 236
  tmp = munmap((void *)((caddr_t )sp->file), sizeof(struct file ));
  }
#line 236
  if (-1 == tmp) {
    {
#line 237
    log_((char *)"sto_free:munmap:%m");
    }
  }
  {
#line 238
  free((void *)sp);
  }
#line 239
  return;
}
}
#line 241 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/store.c"
static int desc___9  ;
#line 304
static int tryopen___1(char *fn ) ;
#line 304 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/store.c"
static struct file f___1  =    {1027296, {{0, 0, 0, 0}}};
#line 270 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/store.c"
static int tryopen___1(char *fn ) 
{ 
  char fn2[287] ;
  int fd ;
  int i ;
  char *p ;
  char *q ;
  struct timeval tv ;
  char *tmp ;
  char tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  ssize_t tmp___7 ;

  {
  {
#line 278
  fd = open((char const   *)fn, 2);
  }
#line 278
  if (fd > -1) {
    {
#line 280
    lockf(fd, 1, (__off_t )0);
    }
#line 281
    return (fd);
  }
#line 283
  p = fn2;
#line 283
  q = fn;
  {
#line 283
  while (1) {
    while_continue: /* CIL Label */ ;
#line 283
    tmp = p;
#line 283
    p ++;
#line 283
    tmp___1 = q;
#line 283
    q ++;
#line 283
    tmp___0 = *tmp___1;
#line 283
    *tmp = tmp___0;
#line 283
    if (! ((int )tmp___0 != 47)) {
#line 283
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 284
  tmp___2 = p;
#line 284
  p ++;
#line 284
  *tmp___2 = (char )'+';
#line 285
  tmp___3 = p;
#line 285
  p ++;
#line 285
  *tmp___3 = (char )'+';
#line 286
  gettimeofday((struct timeval */* __restrict  */)(& tv), (__timezone_ptr_t )0);
#line 296
  i = (int )(tv.tv_sec / 30L);
  }
  {
#line 297
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 298
    tmp___4 = p;
#line 298
    p ++;
#line 298
    *tmp___4 = (char )(48 + i % 10);
#line 297
    i /= 10;
#line 297
    if (! i) {
#line 297
      goto while_break___0;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 300
  tmp___5 = p;
#line 300
  p ++;
#line 300
  *tmp___5 = (char )'\000';
#line 302
  i = 0;
  {
#line 302
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 302
    if (! (i < 100)) {
#line 302
      goto while_break___1;
    }
#line 306
    if (14 == i % 15) {
      {
#line 307
      log_((char *)"tryopen:racing on %s", fn);
      }
    }
    {
#line 308
    fd = open((char const   *)(fn2), 194, 420);
    }
#line 308
    if (fd > -1) {
      {
#line 310
      lockf(fd, 1, (__off_t )0);
#line 311
      tmp___7 = write(fd, (void const   *)((char *)(& f___1)), sizeof(f___1));
      }
#line 311
      if (sizeof(f___1) == (unsigned long )tmp___7) {
        {
#line 312
        tmp___6 = link((char const   *)(fn2), (char const   *)fn);
        }
#line 312
        if (0 == tmp___6) {
          {
#line 314
          unlink((char const   *)(fn2));
          }
#line 315
          return (fd);
        }
      }
      {
#line 317
      close(fd);
#line 318
      unlink((char const   *)(fn2));
      }
    }
    {
#line 321
    fd = open((char const   *)fn, 2);
    }
#line 321
    if (fd > -1) {
      {
#line 323
      lockf(fd, 1, (__off_t )0);
      }
#line 324
      return (fd);
    }
    {
#line 302
    nap(0, 300 + i);
#line 302
    i ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 327
  log_((char *)"tryopen:timed out opening %s:%m", fn);
  }
#line 328
  return (-1);
}
}
#line 337 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/store.c"
static struct storeobj *getstore___1(char *filename ) 
{ 
  struct storeobj *sp ;
  struct storeobj s ;
  int fd ;
  struct file *fp ;
  char buf___28[287] ;
  int c ;
  void *tmp ;
  void *tmp___0 ;
  char *p ;
  char *q ;
  char *tmp___1 ;
  char tmp___2 ;
  char *tmp___3 ;
  char *end ;
  unsigned long tmp___4 ;
  ssize_t tmp___5 ;
  size_t tmp___6 ;
  void *tmp___7 ;

  {
  {
#line 349
  s.filename = filename;
#line 350
  tmp = cache_find(desc___9, (void *)(& s));
#line 350
  sp = (struct storeobj *)tmp;
  }
#line 350
  if (sp) {
    {
#line 352
    lockf(sp->fd, 1, (__off_t )0);
    }
#line 353
    return (sp);
  }
  {
#line 356
  fd = tryopen___1(filename);
  }
#line 356
  if (-1 == fd) {
#line 357
    return ((struct storeobj *)0);
  }
  {
#line 361
  tmp___0 = mmap((void *)0, sizeof(*fp), 3, 1, fd, (__off_t )0);
#line 361
  fp = (struct file *)tmp___0;
  }
#line 362
  if (! fp) {
    {
#line 363
    log_((char *)"getstore:mmap(%s):%m", filename);
    }
  } else
#line 362
  if ((unsigned long )fp == (unsigned long )((void *)-1)) {
    {
#line 363
    log_((char *)"getstore:mmap(%s):%m", filename);
    }
  } else {
    {
#line 364
    tmp___6 = strlen((char const   *)filename);
#line 364
    tmp___7 = malloc((sizeof(*sp) + tmp___6) + 1UL);
#line 364
    sp = (struct storeobj *)tmp___7;
    }
#line 364
    if (sp) {
      {
#line 371
      sp->fd = fd;
#line 372
      sp->file = fp;
#line 373
      sp->filename = (char *)sp + sizeof(*sp);
#line 374
      strcpy((char */* __restrict  */)sp->filename, (char const   */* __restrict  */)filename);
#line 380
      p = buf___28;
#line 380
      q = filename;
      }
      {
#line 380
      while (1) {
        while_continue: /* CIL Label */ ;
#line 380
        tmp___1 = p;
#line 380
        p ++;
#line 380
        tmp___3 = q;
#line 380
        q ++;
#line 380
        tmp___2 = *tmp___3;
#line 380
        *tmp___1 = tmp___2;
#line 380
        if (! ((int )tmp___2 != 47)) {
#line 380
          goto while_break;
        }
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 381
      strcpy((char */* __restrict  */)p, (char const   */* __restrict  */)".compress");
#line 383
      fd = open((char const   *)(buf___28), 0);
      }
#line 383
      if (fd > -1) {
        {
#line 385
        sp->compressok = 1024;
#line 386
        tmp___5 = read(fd, (void *)(buf___28), sizeof(buf___28) - 1UL);
#line 386
        c = (int )tmp___5;
        }
#line 386
        if (c > 0) {
          {
#line 390
          buf___28[c] = (char )'\000';
#line 391
          tmp___4 = strtoul((char const   */* __restrict  */)(buf___28), (char **/* __restrict  */)(& end),
                            10);
#line 391
          c = (int )tmp___4;
          }
#line 392
          if (c > 1024) {
#line 392
            if (10 == (int )*end) {
#line 393
              sp->compressok = c;
            }
          }
        }
        {
#line 395
        close(fd);
        }
      } else {
#line 399
        sp->compressok = 0;
      }
      {
#line 400
      cache_insert(desc___9, (void *)sp);
      }
#line 401
      return (sp);
    } else {
      {
#line 366
      log_((char *)"getstore:no memory");
#line 367
      munmap((void *)fp, sizeof(*fp));
      }
    }
  }
  {
#line 403
  close(fd);
  }
#line 404
  return ((struct storeobj *)0);
}
}
#line 37 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/group.c"
static int desc___10  =    -1;
#line 59 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/group.c"
static int cmpgroup___3(void *a , void *b___13 ) 
{ 
  struct groupobj *x ;
  struct groupobj *y ;
  int tmp ;

  {
  {
#line 61
  x = (struct groupobj *)a;
#line 62
  y = (struct groupobj *)b___13;
#line 64
  tmp = strcmp((char const   *)x->groupname, (char const   *)y->groupname);
  }
#line 64
  return (tmp);
}
}
#line 67 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/group.c"
static void freegroup___3(void *p ) 
{ 
  struct groupobj *gop ;

  {
#line 69
  gop = (struct groupobj *)p;
#line 71
  if (gop->groupname) {
    {
#line 72
    free((void *)gop->groupname);
    }
  }
#line 73
  if (gop->dir.dir) {
    {
#line 74
    closedir(gop->dir.dir);
    }
  }
#line 75
  if (gop->lastf.f) {
    {
#line 76
    munmap((void *)((caddr_t )gop->lastf.f), sizeof(struct file ));
    }
  }
  {
#line 77
  free(p);
  }
#line 78
  return;
}
}
#line 94 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/group.c"
static int refresh___3(struct groupobj *gop , char *groupname ) 
{ 
  struct stat st ;
  struct dir *d ;
  struct lastf *lp ;
  bool needreread ;
  bool needrefile ;
  bool needreslot ;
  bool isemptygroup ;
  int tmp ;
  int tmp___0 ;
  struct dirent *dp ;
  int i ;
  int first ;
  int last___1 ;
  char *end ;
  int tmp___1 ;
  unsigned short const   **tmp___2 ;
  unsigned long tmp___3 ;
  int fd ;
  void *tmp___4 ;
  struct info *ip ;
  int slot ;

  {
#line 99
  needreread = (bool )0;
#line 100
  needrefile = (bool )0;
#line 101
  needreslot = (bool )0;
#line 102
  isemptygroup = (bool )0;
#line 104
  d = & gop->dir;
#line 105
  lp = & gop->lastf;
#line 107
  if (groupname) {
    {
#line 109
    memset((void *)gop, 0, sizeof(struct groupobj ));
#line 110
    gop->groupname = strdup((char const   *)groupname);
    }
#line 111
    if ((unsigned long )((void *)0) == (unsigned long )gop->groupname) {
      {
#line 113
      log_((char *)"refresh:strdup:%m");
      }
#line 114
      return (-1);
    }
    {
#line 116
    gop->dir.first = -1;
#line 117
    d->dir = opendir((char const   *)groupname);
    }
#line 118
    if ((unsigned long )((void *)0) == (unsigned long )d->dir) {
      {
#line 120
      log_((char *)"refresh:opendir:%m");
      }
#line 121
      return (-1);
    }
#line 123
    lp->name = -1;
#line 125
    needreslot = (bool )1;
#line 125
    needreread = needreslot;
#line 125
    needrefile = needreread;
  } else {
#line 131
    if (-1 == d->first) {
#line 132
      needreread = (bool )1;
    } else
#line 131
    if (0 == d->last) {
#line 132
      needreread = (bool )1;
    } else
#line 131
    if (! d->read) {
#line 132
      needreread = (bool )1;
    } else {
      {
#line 133
      tmp = dirfd(d->dir);
#line 133
      tmp___0 = fstat(tmp, & st);
      }
#line 133
      if (-1 == tmp___0) {
        {
#line 135
        log_((char *)"refresh:fstat:%m");
        }
#line 136
        return (-1);
      } else
#line 138
      if (d->read < st.st_mtim.tv_sec) {
#line 139
        needreread = (bool )1;
      }
    }
#line 140
    if (! lp->f) {
#line 141
      needreslot = (bool )1;
#line 141
      needrefile = needreslot;
    }
#line 142
    if (! needrefile) {
#line 143
      if (! lp->f) {
#line 144
        needrefile = (bool )1;
      }
    }
#line 145
    if (! needrefile) {
#line 146
      if (-1 == lp->name) {
#line 147
        needrefile = (bool )1;
      }
    }
  }
#line 150
  if (needreread) {
#line 150
    goto _L;
  } else
#line 150
  if (needreslot) {
    _L: /* CIL Label */ 
    {
#line 156
    first = -1;
#line 157
    last___1 = 0;
#line 158
    rewinddir(d->dir);
#line 159
    dp = readdir(d->dir);
    }
#line 160
    if ((unsigned long )((void *)0) == (unsigned long )dp) {
      {
#line 162
      log_((char *)"refresh:readdir:%m");
      }
#line 163
      return (-1);
    }
#line 165
    gop->nopost = (bool )0;
    {
#line 166
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 168
      tmp___2 = __ctype_b_loc();
      }
#line 168
      if (! ((int const   )*(*tmp___2 + (int )dp->d_name[0]) & 2048)) {
#line 170
        if (! gop->nopost) {
#line 170
          if (46 == (int )dp->d_name[0]) {
            {
#line 171
            tmp___1 = strcmp((char const   *)(dp->d_name), ".nopost");
            }
#line 171
            if (0 == tmp___1) {
#line 172
              gop->nopost = (bool )1;
            }
          }
        }
#line 173
        goto __Cont;
      }
      {
#line 175
      tmp___3 = strtoul((char const   */* __restrict  */)(dp->d_name), (char **/* __restrict  */)(& end),
                        10);
#line 175
      i = (int )tmp___3;
      }
#line 175
      if (i <= 0) {
#line 176
        goto __Cont;
      } else
#line 175
      if (*end) {
#line 176
        goto __Cont;
      }
#line 177
      if (first > i) {
#line 178
        first = i;
      } else
#line 177
      if (-1 == first) {
#line 178
        first = i;
      }
#line 179
      if (last___1 < i) {
#line 180
        last___1 = i;
      }
      __Cont: /* CIL Label */ 
      {
#line 166
      dp = readdir(d->dir);
      }
#line 166
      if (! dp) {
#line 166
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 183
    d->first = first;
#line 184
    d->last = last___1;
#line 185
    if (-1 == first) {
#line 185
      if (0 == last___1) {
#line 186
        isemptygroup = (bool )1;
      }
    }
#line 187
    if (last___1 != lp->name) {
#line 188
      needrefile = (bool )1;
    } else {
#line 190
      lp->name = last___1;
    }
    {
#line 191
    time(& d->read);
    }
  }
#line 194
  if (needrefile) {
#line 194
    goto _L___0;
  } else
#line 194
  if (needreslot) {
    _L___0: /* CIL Label */ 
#line 198
    if (lp->f) {
      {
#line 200
      munmap((void *)((caddr_t )lp->f), sizeof(struct file ));
#line 201
      lp->f = (struct file *)((void *)0);
      }
    }
#line 203
    if (isemptygroup) {
#line 204
      return (0);
    }
    {
#line 205
    fd = openf(0, 0, (char *)"%s/%d", gop->groupname, d->last);
    }
#line 206
    if (-1 == fd) {
      {
#line 208
      log_((char *)"refresh:open:%m");
      }
#line 209
      return (-1);
    }
    {
#line 211
    tmp___4 = mmap((void *)0, sizeof(struct file ), 1, 1, fd, (__off_t )0);
#line 211
    lp->f = (struct file *)tmp___4;
#line 212
    close(fd);
    }
#line 213
    if ((unsigned long )lp->f == (unsigned long )((void *)-1)) {
      {
#line 215
      log_((char *)"refresh:mmap:%m");
      }
#line 216
      return (-1);
    }
#line 218
    lp->slotsfilled = 0;
#line 219
    needreslot = (bool )1;
  }
#line 222
  if (needreslot) {
#line 224
    ip = (lp->f)->info;
#line 227
    slot = 9;
    {
#line 227
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 227
      if (! (slot > -1)) {
#line 227
        goto while_break___0;
      }
#line 228
      if ((ip + slot)->hoffset) {
#line 229
        goto while_break___0;
      }
#line 227
      slot --;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 230
    lp->slotsfilled = slot + 1;
  }
#line 233
  return (0);
}
}
#line 33 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/art.c"
static size_t pagesize___11  =    (size_t )0;
#line 80 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/art.c"
static void file_unmap___3(void *p ) 
{ 
  struct fileobj *fp ;

  {
  {
#line 82
  fp = (struct fileobj *)p;
#line 84
  munmap((void *)fp->map, (size_t )fp->size);
#line 85
  free((void *)fp);
  }
#line 86
  return;
}
}
#line 88 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/art.c"
static int file_cmp___3(void *a , void *b___13 ) 
{ 
  struct fileobj *x ;
  struct fileobj *y ;
  int tmp ;

  {
  {
#line 90
  x = (struct fileobj *)a;
#line 91
  y = (struct fileobj *)b___13;
#line 93
  tmp = strcmp((char const   *)x->path, (char const   *)y->path);
  }
#line 93
  return (tmp);
}
}
#line 96 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/art.c"
static int desc___11  =    -1;
#line 98 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/art.c"
static int file_init___3(void) 
{ 


  {
  {
#line 100
  desc___11 = cache_init(8, & file_cmp___3, & file_unmap___3, (int (*)(void * ))((void *)0));
  }
#line 101
  if (-1 == desc___11) {
    {
#line 103
    log_((char *)"file_init:%m");
    }
#line 104
    return (-1);
  }
#line 106
  return (0);
}
}
#line 109 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/art.c"
static struct file *file_gimme___3(char *name , int *size___1 ) 
{ 
  struct fileobj f___9 ;
  struct fileobj *fp ;
  void *tmp ;

  {
  {
#line 111
  f___9.path = (char *)0;
#line 111
  f___9.map = (char *)0;
#line 111
  f___9.size = 0;
#line 114
  f___9.path = name;
#line 116
  tmp = cache_find(desc___11, (void *)(& f___9));
#line 116
  fp = (struct fileobj *)tmp;
  }
#line 116
  if ((unsigned long )((void *)0) == (unsigned long )fp) {
    {
#line 118
    fp = file_map(name);
    }
#line 118
    if ((unsigned long )((void *)0) == (unsigned long )fp) {
#line 119
      return ((struct file *)((void *)0));
    } else {
      {
#line 121
      cache_insert(desc___11, (void *)fp);
      }
    }
  }
#line 124
  if (size___1) {
#line 125
    *size___1 = fp->size;
  }
#line 126
  return ((struct file *)fp->map);
}
}
#line 137 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/art.c"
static bool file_initialized___3  =    (bool )0;
#line 248 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/art.c"
static char ngroup___3[287]  ;
#line 297 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/art.c"
static int getfield___3(char *buf___28 , struct field *f___9 ) 
{ 
  register char *cp ;
  size_t tmp ;
  size_t tmp___0 ;

  {
  {
#line 299
  cp = buf___28;
#line 301
  tmp = strspn((char const   *)cp, " \t\f");
#line 301
  cp += tmp;
  }
#line 302
  if (! *cp) {
#line 304
    f___9->pointer = (char *)((void *)0);
#line 305
    return (0);
  }
  {
#line 307
  tmp___0 = strcspn((char const   *)cp, "\r\n");
#line 307
  f___9->len = (int )tmp___0;
  }
#line 308
  if (! f___9->len) {
#line 309
    return (0);
  }
#line 310
  f___9->pointer = cp;
#line 311
  return ((int )((cp + f___9->len) - buf___28));
}
}
#line 383 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/art.c"
static struct b b___4  =    {(char *)0, 0, 0};
#line 105 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/dh_find.c"
static int initfile___7(void) 
{ 
  int fd ;
  int integer ;
  int i ;
  char foo[3] ;
  unsigned int tmp ;
  int *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  ssize_t tmp___3 ;
  ssize_t tmp___4 ;

  {
#line 108
  integer = 218885376;
#line 110
  foo[0] = (char )'\000';
#line 110
  tmp = 1U;
  {
#line 110
  while (1) {
    while_continue: /* CIL Label */ ;
#line 110
    if (tmp >= 3U) {
#line 110
      goto while_break;
    }
#line 110
    foo[tmp] = (char)0;
#line 110
    tmp ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 112
  fd = open((char const   *)(dh_tablefile), 194, 420);
  }
#line 113
  if (fd == -1) {
#line 114
    return (-1);
  }
  {
#line 115
  tmp___2 = lockf(fd, 2, (__off_t )0);
  }
#line 115
  if (tmp___2 == -1) {
    {
#line 117
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 119
      tmp___0 = __errno_location();
      }
#line 119
      if (*tmp___0 == 11) {
        {
#line 120
        nap(0, 200);
        }
      } else {
#line 122
        goto fail;
      }
      {
#line 117
      tmp___1 = lockf(fd, 2, (__off_t )0);
      }
#line 117
      if (! (tmp___1 == -1)) {
#line 117
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 125
    lockf(fd, 0, (__off_t )0);
    }
#line 126
    return (fd);
  }
  {
#line 128
  tmp___3 = write(fd, (void const   *)(& integer), sizeof(int ));
  }
#line 128
  if ((unsigned long )tmp___3 != sizeof(int )) {
#line 129
    goto fail;
  }
#line 130
  i = 0;
  {
#line 130
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 130
    if (! (i < 10240)) {
#line 130
      goto while_break___1;
    }
    {
#line 131
    tmp___4 = write(fd, (void const   *)(foo), sizeof(foo));
    }
#line 131
    if ((unsigned long )tmp___4 != sizeof(foo)) {
#line 132
      goto fail;
    }
#line 130
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 133
  lseek(fd, (__off_t )0, 0);
#line 134
  lockf(fd, 0, (__off_t )0);
  }
#line 135
  return (fd);
  fail: 
#line 138
  if (fd > -1) {
    {
#line 139
    close(fd);
    }
  }
#line 140
  return (-1);
}
}
#line 78 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/allocate.c"
static struct table___1 table___4  =    {(char *)0, (char *)0, 0, 0, 0, 0};
#line 80
static int remapfile___3(void) ;
#line 106 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/allocate.c"
static int initfile___8(char *filename ) 
{ 
  struct chainfile cf ;
  int fd ;
  int i ;
  int ret ;
  ssize_t tmp ;
  int pad ;
  ssize_t tmp___0 ;

  {
  {
#line 108
  cf.chain_magic = 0;
#line 108
  cf.next[0] = 0;
#line 108
  cf.next[1] = 0;
#line 108
  cf.next[2] = 0;
#line 108
  cf.next[3] = 0;
#line 108
  cf.next[4] = 0;
#line 108
  cf.next[5] = 0;
#line 108
  cf.next[6] = 0;
#line 108
  cf.next[7] = 0;
#line 108
  cf.next[8] = 0;
#line 108
  cf.next[9] = 0;
#line 108
  cf.next[10] = 0;
#line 108
  cf.next[11] = 0;
#line 108
  cf.next[12] = 0;
#line 108
  cf.next[13] = 0;
#line 108
  cf.next[14] = 0;
#line 108
  cf.next[15] = 0;
#line 108
  cf.next[16] = 0;
#line 108
  cf.next[17] = 0;
#line 108
  cf.next[18] = 0;
#line 108
  cf.next[19] = 0;
#line 108
  cf.next[20] = 0;
#line 108
  cf.next[21] = 0;
#line 108
  cf.next[22] = 0;
#line 108
  cf.next[23] = 0;
#line 108
  cf.next[24] = 0;
#line 108
  cf.next[25] = 0;
#line 108
  cf.next[26] = 0;
#line 108
  cf.next[27] = 0;
#line 108
  cf.next[28] = 0;
#line 108
  cf.next[29] = 0;
#line 108
  cf.next[30] = 0;
#line 108
  cf.next[31] = 0;
#line 108
  cf.next[32] = 0;
#line 108
  cf.next[33] = 0;
#line 108
  cf.next[34] = 0;
#line 108
  cf.next[35] = 0;
#line 108
  cf.next[36] = 0;
#line 108
  cf.next[37] = 0;
#line 108
  cf.next[38] = 0;
#line 108
  cf.next[39] = 0;
#line 108
  cf.next[40] = 0;
#line 108
  cf.next[41] = 0;
#line 108
  cf.next[42] = 0;
#line 108
  cf.next[43] = 0;
#line 108
  cf.next[44] = 0;
#line 108
  cf.next[45] = 0;
#line 108
  cf.next[46] = 0;
#line 108
  cf.next[47] = 0;
#line 108
  cf.next[48] = 0;
#line 108
  cf.next[49] = 0;
#line 108
  cf.next[50] = 0;
#line 108
  cf.next[51] = 0;
#line 108
  cf.next[52] = 0;
#line 108
  cf.next[53] = 0;
#line 108
  cf.next[54] = 0;
#line 108
  cf.next[55] = 0;
#line 108
  cf.next[56] = 0;
#line 108
  cf.next[57] = 0;
#line 108
  cf.next[58] = 0;
#line 108
  cf.next[59] = 0;
#line 108
  cf.next[60] = 0;
#line 108
  cf.next[61] = 0;
#line 108
  cf.next[62] = 0;
#line 111
  ret = 0;
#line 113
  fd = open((char const   *)filename, 578, 420);
  }
#line 114
  if (-1 == fd) {
#line 115
    return (-1);
  }
#line 116
  cf.chain_magic = 13680336;
#line 117
  i = 0;
  {
#line 117
  while (1) {
    while_continue: /* CIL Label */ ;
#line 117
    if (! (i < 63)) {
#line 117
      goto while_break;
    }
#line 118
    cf.next[i] = (int volatile   )0;
#line 117
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 119
  tmp = write(fd, (void const   *)(& cf), sizeof(cf));
#line 119
  i = (int )tmp;
  }
#line 120
  if ((unsigned long )i == sizeof(cf)) {
#line 124
    pad = (int )(sizeof(cf) % 4UL);
#line 125
    if (pad > 0) {
#line 126
      i = 0;
      {
#line 126
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 126
        if (i < pad) {
#line 126
          if (! (0 == ret)) {
#line 126
            goto while_break___0;
          }
        } else {
#line 126
          goto while_break___0;
        }
        {
#line 127
        tmp___0 = write(fd, (void const   *)"", (size_t )1);
        }
#line 127
        if (1L != tmp___0) {
#line 128
          ret = -1;
        }
#line 126
        i ++;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
  } else {
#line 131
    ret = -1;
  }
  {
#line 132
  close(fd);
  }
#line 133
  return (ret);
}
}
#line 136 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/allocate.c"
static void unmapfile___3(void) 
{ 


  {
#line 138
  if (table___4.fd >= 0) {
    {
#line 140
    close(table___4.fd);
#line 141
    table___4.fd = -1;
    }
  }
#line 143
  if (table___4.map) {
    {
#line 145
    munmap((void *)table___4.map, (size_t )table___4.size);
#line 146
    table___4.map = (char *)((void *)0);
#line 147
    table___4.size = 0;
    }
  }
#line 149
  return;
}
}
#line 153
static size_t rounduptopagesize___3(size_t size___1 ) ;
#line 153 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/allocate.c"
static size_t pagesize___12  =    (size_t )0;
#line 151 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/allocate.c"
static size_t rounduptopagesize___3(size_t size___1 ) 
{ 
  int pages ;
  int tmp ;

  {
#line 156
  if (0UL == pagesize___12) {
    {
#line 157
    tmp = getpagesize();
#line 157
    pagesize___12 = (size_t )tmp;
    }
  }
#line 158
  pages = (int )(size___1 / pagesize___12 + 1UL);
#line 159
  return ((size_t )pages * pagesize___12);
}
}
#line 162 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/allocate.c"
static int mapfile___3(void) 
{ 
  struct stat st ;
  int tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;

  {
#line 166
  if (-1 == table___4.fd) {
    {
#line 167
    table___4.fd = open((char const   *)table___4.filename, table___4.oflag, 420);
    }
  }
#line 168
  if (-1 == table___4.fd) {
#line 169
    goto fail;
  }
  {
#line 171
  tmp = fstat(table___4.fd, & st);
  }
#line 171
  if (-1 == tmp) {
#line 172
    goto fail;
  }
  {
#line 173
  tmp___0 = rounduptopagesize___3((size_t )st.st_size);
#line 173
  table___4.size = (int )tmp___0;
#line 174
  tmp___1 = mmap((void *)0, (size_t )table___4.size, table___4.mprot, 1, table___4.fd,
                 (__off_t )0);
#line 174
  table___4.map = (char *)tmp___1;
  }
#line 175
  if (! table___4.map) {
#line 176
    goto fail;
  } else
#line 175
  if ((unsigned long )table___4.map == (unsigned long )((void *)-1)) {
#line 176
    goto fail;
  }
#line 178
  return (0);
  fail: 
  {
#line 181
  unmapfile___3();
  }
#line 182
  return (-1);
}
}
#line 189 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/allocate.c"
static int remapfile___3(void) 
{ 
  struct stat st ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 193
  tmp = fstat(table___4.fd, & st);
  }
#line 193
  if (-1 == tmp) {
#line 194
    return (-1);
  }
#line 196
  if (st.st_size <= (__off_t )table___4.size) {
#line 197
    return (0);
  }
  {
#line 199
  munmap((void *)table___4.map, (size_t )table___4.size);
#line 200
  tmp___0 = mapfile___3();
  }
#line 200
  return (tmp___0);
}
}
#line 209 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/allocate.c"
static int lock___3(void) 
{ 
  int *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 211
  tmp___2 = lockf(table___4.fd, 2, (__off_t )0);
  }
#line 211
  if (-1 == tmp___2) {
    {
#line 213
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 215
      tmp = __errno_location();
      }
#line 215
      if (11 != *tmp) {
#line 216
        return (-1);
      } else {
        {
#line 218
        nap(0, 200);
        }
      }
      {
#line 213
      tmp___0 = lockf(table___4.fd, 2, (__off_t )0);
      }
#line 213
      if (! (-1 == tmp___0)) {
#line 213
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 221
    tmp___1 = remapfile___3();
    }
#line 221
    if (-1 == tmp___1) {
#line 222
      return (-1);
    }
  }
#line 224
  return (0);
}
}
#line 227 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/allocate.c"
static void unlock___3(void) 
{ 


  {
  {
#line 229
  lseek(table___4.fd, (__off_t )0, 0);
#line 230
  lockf(table___4.fd, 0, (__off_t )0);
  }
#line 231
  return;
}
}
#line 233 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/allocate.c"
static int checkvalidfile___3(void) 
{ 


  {
#line 235
  if (table___4.size > 0) {
#line 237
    if ((unsigned long )table___4.size < sizeof(struct chainfile )) {
#line 238
      return (-1);
    }
#line 239
    if (((struct chainfile *)table___4.map)->chain_magic != 13680336) {
#line 240
      return (-1);
    }
  }
#line 242
  return (0);
}
}
#line 281 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/allocate.c"
static int rounduptoalignment___3(int size___1 ) 
{ 


  {
#line 283
  if (size___1 <= 0) {
#line 284
    return (4);
  }
#line 285
  return (((size___1 - 1) / 4 + 1) * 4);
}
}
#line 296 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/allocate.c"
static char tmpchunk___3[272]  = {      (char )'\000'};
#line 56 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/dhash.c"
static unsigned char buf___8[2]  ;
#line 54 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/dhash.c"
static char *inttochar2___3(int integer ) 
{ 


  {
#line 58
  buf___8[0] = (unsigned char )((integer & 65535) >> 8);
#line 59
  buf___8[1] = (unsigned char )(integer & 255);
#line 60
  return ((char *)(buf___8));
}
}
#line 65 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/dhash.c"
static unsigned char buf___9[3]  ;
#line 63 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/dhash.c"
static char *inttochar3___3(unsigned int integer ) 
{ 


  {
#line 67
  integer >>= 2;
#line 68
  buf___9[0] = (unsigned char )((integer & 16777215U) >> 16);
#line 69
  buf___9[1] = (unsigned char )((integer & 65535U) >> 8);
#line 70
  buf___9[2] = (unsigned char )(integer & 255U);
#line 71
  return ((char *)(buf___9));
}
}
#line 35 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/newsgroup.c"
static struct ng *bygroup___3[128]  ;
#line 36 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/newsgroup.c"
static struct ng *byident___3[128]  ;
#line 37 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/newsgroup.c"
static int highest___3  =    0;
#line 39 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/newsgroup.c"
static unsigned int hash___7(char *buf___28 , int len ) 
{ 
  unsigned int h ;
  char *tmp ;

  {
#line 43
  h = 5381U;
  {
#line 44
  while (1) {
    while_continue: /* CIL Label */ ;
#line 44
    if (! len) {
#line 44
      goto while_break;
    }
#line 46
    len --;
#line 47
    h += h << 5;
#line 48
    tmp = buf___28;
#line 48
    buf___28 ++;
#line 48
    h ^= (unsigned int )*tmp;
  }
  while_break: /* CIL Label */ ;
  }
#line 50
  return (h);
}
}
#line 53 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/newsgroup.c"
static struct chunk *chunks___3  ;
#line 58 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/newsgroup.c"
static int avail___7  =    0;
#line 59 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/newsgroup.c"
static int nr___4  =    0;
#line 64 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/newsgroup.c"
static int add___4(int ident , char *group , int len ) 
{ 
  struct ng *np ;
  struct ng *p ;
  int want ;
  unsigned int h ;
  struct chunk *tmp ;
  int size___1 ;
  void *tmp___0 ;
  unsigned int tmp___1 ;
  int tmp___2 ;

  {
#line 71
  len ++;
#line 72
  want = (int )(((unsigned long )len + sizeof(struct ng )) + sizeof(char *));
#line 73
  want = (int )((unsigned long )want - (unsigned long )len % sizeof(char *));
#line 74
  len --;
#line 76
  if (avail___7 < want) {
#line 81
    if (want > 240) {
#line 81
      size___1 = want + 240;
    } else {
#line 81
      size___1 = 240;
    }
    {
#line 82
    tmp___0 = malloc((size_t )size___1);
#line 82
    tmp = (struct chunk *)tmp___0;
    }
#line 82
    if (! tmp) {
#line 83
      return (-1);
    }
#line 84
    tmp->next = chunks___3;
#line 85
    chunks___3 = tmp;
#line 86
    chunks___3->buf = (char *)chunks___3 + sizeof(struct chunk );
#line 87
    avail___7 = (int )((unsigned long )size___1 - sizeof(struct chunk ));
  }
  {
#line 89
  np = (struct ng *)chunks___3->buf;
#line 90
  chunks___3->buf += want;
#line 91
  avail___7 -= want;
#line 92
  strncpy((char */* __restrict  */)(np->group), (char const   */* __restrict  */)group,
          (size_t )len);
#line 93
  np->group[len] = (char )'\000';
#line 94
  np->ident = ident;
#line 96
  tmp___1 = hash___7(group, len);
#line 96
  h = tmp___1 % 128U;
#line 97
  np->gnext = bygroup___3[h];
#line 98
  bygroup___3[h] = np;
#line 99
  p = np->gnext;
  }
  {
#line 99
  while (1) {
    while_continue: /* CIL Label */ ;
#line 99
    if (! p) {
#line 99
      goto while_break;
    }
    {
#line 100
    tmp___2 = strcmp((char const   *)(p->group), (char const   *)group);
    }
#line 100
    if (0 == tmp___2) {
#line 101
      return (1);
    }
#line 99
    p = p->gnext;
  }
  while_break: /* CIL Label */ ;
  }
#line 102
  h = (unsigned int )(ident % 128);
#line 103
  np->inext = byident___3[h];
#line 104
  byident___3[h] = np;
#line 105
  p = np->inext;
  {
#line 105
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 105
    if (! p) {
#line 105
      goto while_break___0;
    }
#line 106
    if (p->ident == ident) {
#line 107
      return (1);
    }
#line 105
    p = p->inext;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 109
  if (ident > highest___3) {
#line 110
    highest___3 = ident;
  }
#line 111
  nr___4 ++;
#line 112
  return (0);
}
}
#line 116 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/newsgroup.c"
static int groupfd___3  =    -1;
#line 117 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/newsgroup.c"
static int oldsize___3  =    0;
#line 118 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/newsgroup.c"
static int mapsize___3  =    0;
#line 119 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/newsgroup.c"
static char *mapbuf___3  =    (char *)((void *)0);
#line 148
static int reload___3(void) ;
#line 148 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/newsgroup.c"
static int pagesize___13  =    0;
#line 145 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/newsgroup.c"
static int reload___3(void) 
{ 
  struct stat st ;
  int newsize ;
  int tmp ;
  void *tmp___0 ;
  char *p ;
  char *lim ;
  char *ip ;
  char *gr ;
  int ident ;
  int state ;
  int tmp___1 ;

  {
  {
#line 156
  tmp = fstat(groupfd___3, & st);
  }
#line 156
  if (-1 == tmp) {
    {
#line 158
    log_((char *)"reload:fstat:%m");
    }
#line 159
    return (-1);
  }
#line 161
  newsize = (int )st.st_size;
#line 162
  if (! pagesize___13) {
    {
#line 163
    pagesize___13 = getpagesize();
    }
  }
#line 164
  if (newsize <= oldsize___3) {
#line 165
    return (0);
  }
#line 166
  if (newsize > mapsize___3) {
#line 166
    goto _L;
  } else
#line 166
  if (! mapsize___3) {
    _L: /* CIL Label */ 
#line 168
    if (mapbuf___3) {
      {
#line 169
      munmap((void *)mapbuf___3, (size_t )mapsize___3);
      }
    }
    {
#line 170
    mapsize___3 = (int )((st.st_size + (__off_t )pagesize___13) - st.st_size % (long )pagesize___13);
#line 171
    tmp___0 = mmap((void *)0, (size_t )mapsize___3, 1, 1, groupfd___3, (__off_t )0);
#line 171
    mapbuf___3 = (char *)tmp___0;
    }
#line 172
    if (! mapbuf___3) {
      {
#line 174
      log_((char *)"reload:mmap:%m");
      }
#line 175
      return (-1);
    } else
#line 172
    if ((unsigned long )mapbuf___3 == (unsigned long )((void *)-1)) {
      {
#line 174
      log_((char *)"reload:mmap:%m");
      }
#line 175
      return (-1);
    }
  }
#line 188
  lim = mapbuf___3 + newsize;
#line 189
  state = 0;
#line 189
  ident = state;
#line 190
  gr = (char *)0;
#line 190
  ip = gr;
#line 191
  p = mapbuf___3 + oldsize___3;
  {
#line 191
  while (1) {
    while_continue: /* CIL Label */ ;
#line 191
    if (! ((unsigned long )p < (unsigned long )lim)) {
#line 191
      goto while_break;
    }
    {
#line 194
    if (state == 0) {
#line 194
      goto case_0;
    }
#line 195
    if (state == 1) {
#line 195
      goto case_1;
    }
#line 196
    if (state == 2) {
#line 196
      goto case_2;
    }
#line 197
    if (state == 3) {
#line 197
      goto case_3;
    }
#line 192
    goto switch_break;
    case_0: /* CIL Label */ 
#line 194
    if ((int )*p >= 48) {
#line 194
      if ((int )*p <= 57) {
#line 194
        ip = p;
#line 194
        state ++;
      }
    }
#line 194
    goto switch_break;
    case_1: /* CIL Label */ 
#line 195
    if (32 == (int )*p) {
      {
#line 195
      ident = atoi((char const   *)ip);
#line 195
      state ++;
      }
    }
#line 195
    goto switch_break;
    case_2: /* CIL Label */ 
#line 196
    if (32 != (int )*p) {
#line 196
      gr = p;
#line 196
      state ++;
    }
#line 196
    goto switch_break;
    case_3: /* CIL Label */ 
#line 198
    if (10 != (int )*p) {
#line 199
      goto switch_break;
    }
    {
#line 200
    tmp___1 = add___4(ident, gr, (int )(p - gr));
    }
#line 200
    if (-1 == tmp___1) {
      {
#line 202
      log_((char *)"reload:no memory");
      }
#line 203
      return (-1);
    }
#line 205
    state = 0;
    switch_break: /* CIL Label */ ;
    }
#line 191
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 208
  oldsize___3 = newsize;
#line 209
  return (0);
}
}
#line 26 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/key.c"
static struct buf *head___4  ;
#line 27 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/key.c"
static int avail___8  =    0;
#line 28 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/key.c"
static char *keybuf___3  =    (char *)((void *)0);
#line 33 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/key.c"
static unsigned int hv___3  ;
#line 35 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/key.c"
static void hash___8(char *key , int len ) 
{ 
  char *tmp ;

  {
#line 37
  hv___3 = 5381U;
  {
#line 38
  while (1) {
    while_continue: /* CIL Label */ ;
#line 38
    if (! len) {
#line 38
      goto while_break;
    }
#line 40
    len --;
#line 41
    hv___3 += hv___3 << 5;
#line 42
    tmp = key;
#line 42
    key ++;
#line 42
    hv___3 ^= (unsigned int )*tmp;
  }
  while_break: /* CIL Label */ ;
  }
#line 44
  hv___3 %= 128U;
#line 45
  return;
}
}
#line 26 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/body.c"
static char *bodbuf___3  =    (char *)((void *)0);
#line 87 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/cache.c"
static struct entry *new_entry___4(int desc___35 ) 
{ 
  struct entry *ep ;
  struct entry *tmp ;

  {
#line 91
  ep = table[desc___35].freelist;
#line 91
  if (ep) {
#line 92
    table[desc___35].freelist = ep->next;
  } else {
#line 95
    ep = table[desc___35].entries;
    {
#line 95
    while (1) {
      while_continue: /* CIL Label */ ;
#line 95
      if (! ep->next) {
#line 95
        goto while_break;
      }
#line 95
      ep = ep->next;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 96
    (ep->prev)->next = (struct entry *)((void *)0);
#line 97
    (*(table[desc___35].freeobj))(ep->object);
    }
  }
#line 99
  tmp = (struct entry *)((void *)0);
#line 99
  ep->next = tmp;
#line 99
  ep->prev = tmp;
#line 100
  ep->object = (void *)0;
#line 101
  return (ep);
}
}
#line 67 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/store.c"
static int sto_cmp___2(void *a , void *b___13 ) 
{ 
  register struct storeobj *x ;
  register struct storeobj *y ;
  int tmp ;

  {
  {
#line 69
  x = (struct storeobj *)a;
#line 70
  y = (struct storeobj *)b___13;
#line 72
  tmp = strcmp((char const   *)x->filename, (char const   *)y->filename);
  }
#line 72
  return (tmp);
}
}
#line 75 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/store.c"
static int nosigio___2(ssize_t (*op)() , int fd , char *buf___28 , int len ) 
{ 
  int er ;
  int *tmp ;
  ssize_t tmp___0 ;

  {
  {
#line 79
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 79
    tmp___0 = (*op)(fd, buf___28, len);
#line 79
    er = (int )tmp___0;
    }
#line 79
    if (! (-1 == er)) {
#line 79
      goto while_break;
    }
    {
#line 80
    tmp = __errno_location();
    }
#line 80
    if (4 != *tmp) {
#line 82
      if (debug >= 1) {
        {
#line 82
        log_((char *)"nosigio:%m");
        }
      }
#line 83
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 85
  return (er);
}
}
#line 88 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/store.c"
static int copyart___2(int tofd , int fromfd , int fromseek , int len ) 
{ 
  char buf___28[1024] ;
  __off_t tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  {
#line 92
  tmp = lseek(fromfd, (__off_t )fromseek, 0);
  }
#line 92
  if (-1L == tmp) {
    {
#line 94
    log_((char *)"copyart:lseek:%m");
    }
#line 95
    return (-1);
  }
  {
#line 98
  while (1) {
    while_continue: /* CIL Label */ ;
#line 98
    if (! (len > 1024)) {
#line 98
      goto while_break;
    }
    {
#line 99
    tmp___0 = nosigio___2((ssize_t (*)())(& read), fromfd, buf___28, 1024);
    }
#line 99
    if (-1 == tmp___0) {
#line 100
      return (-1);
    } else {
      {
#line 99
      tmp___1 = nosigio___2((ssize_t (*)())(& write), tofd, buf___28, 1024);
      }
#line 99
      if (-1 == tmp___1) {
#line 100
        return (-1);
      }
    }
#line 98
    len -= 1024;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 101
  tmp___2 = nosigio___2((ssize_t (*)())(& read), fromfd, buf___28, len);
  }
#line 101
  if (-1 == tmp___2) {
#line 102
    return (-1);
  } else {
    {
#line 101
    tmp___3 = nosigio___2((ssize_t (*)())(& write), tofd, buf___28, len);
    }
#line 101
    if (-1 == tmp___3) {
#line 102
      return (-1);
    }
  }
#line 104
  return (0);
}
}
#line 107 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/store.c"
static int checkindex___2(struct info *p ) 
{ 


  {
#line 109
  if (p->hoffset > 0) {
#line 111
    if (p->boffset > 0) {
#line 112
      if (p->hlen > 0) {
#line 113
        if (p->blen > 0) {
#line 114
          return (0);
        }
      }
    }
  } else
#line 116
  if (-1 == p->hoffset) {
#line 116
    if (-1 == p->boffset) {
#line 117
      return (1);
    }
  }
#line 118
  return (-1);
}
}
#line 127 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/store.c"
static void reorder___2(struct storeobj *sp ) 
{ 
  char tmpname[287] ;
  char *p ;
  char *q ;
  int fd ;
  struct file f___9 ;
  int er ;
  int i ;
  char *tmp ;
  char tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char tmp___4 ;
  char *tmp___5 ;
  int *tmp___6 ;
  int tmp___7 ;
  char *p___0 ;
  int *tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  __off_t tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  __off_t tmp___17 ;
  __off_t tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;

  {
#line 133
  f___9.magic = 0;
#line 133
  f___9.info[0].hoffset = 0;
#line 133
  f___9.info[0].hlen = 0;
#line 133
  f___9.info[0].boffset = 0;
#line 133
  f___9.info[0].blen = 0;
#line 133
  f___9.info[1].hoffset = 0;
#line 133
  f___9.info[1].hlen = 0;
#line 133
  f___9.info[1].boffset = 0;
#line 133
  f___9.info[1].blen = 0;
#line 133
  f___9.info[2].hoffset = 0;
#line 133
  f___9.info[2].hlen = 0;
#line 133
  f___9.info[2].boffset = 0;
#line 133
  f___9.info[2].blen = 0;
#line 133
  f___9.info[3].hoffset = 0;
#line 133
  f___9.info[3].hlen = 0;
#line 133
  f___9.info[3].boffset = 0;
#line 133
  f___9.info[3].blen = 0;
#line 133
  f___9.info[4].hoffset = 0;
#line 133
  f___9.info[4].hlen = 0;
#line 133
  f___9.info[4].boffset = 0;
#line 133
  f___9.info[4].blen = 0;
#line 133
  f___9.info[5].hoffset = 0;
#line 133
  f___9.info[5].hlen = 0;
#line 133
  f___9.info[5].boffset = 0;
#line 133
  f___9.info[5].blen = 0;
#line 133
  f___9.info[6].hoffset = 0;
#line 133
  f___9.info[6].hlen = 0;
#line 133
  f___9.info[6].boffset = 0;
#line 133
  f___9.info[6].blen = 0;
#line 133
  f___9.info[7].hoffset = 0;
#line 133
  f___9.info[7].hlen = 0;
#line 133
  f___9.info[7].boffset = 0;
#line 133
  f___9.info[7].blen = 0;
#line 133
  f___9.info[8].hoffset = 0;
#line 133
  f___9.info[8].hlen = 0;
#line 133
  f___9.info[8].boffset = 0;
#line 133
  f___9.info[8].blen = 0;
#line 133
  f___9.info[9].hoffset = 0;
#line 133
  f___9.info[9].hlen = 0;
#line 133
  f___9.info[9].boffset = 0;
#line 133
  f___9.info[9].blen = 0;
#line 136
  p = tmpname;
#line 136
  q = sp->filename;
  {
#line 136
  while (1) {
    while_continue: /* CIL Label */ ;
#line 136
    tmp = p;
#line 136
    p ++;
#line 136
    tmp___1 = q;
#line 136
    q ++;
#line 136
    tmp___0 = *tmp___1;
#line 136
    *tmp = tmp___0;
#line 136
    if (! ((int )tmp___0 != 47)) {
#line 136
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 137
  tmp___2 = p;
#line 137
  p ++;
#line 137
  *tmp___2 = (char )'+';
  {
#line 138
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 138
    tmp___3 = p;
#line 138
    p ++;
#line 138
    tmp___5 = q;
#line 138
    q ++;
#line 138
    tmp___4 = *tmp___5;
#line 138
    *tmp___3 = tmp___4;
#line 138
    if (! tmp___4) {
#line 138
      goto while_break___0;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 139
  fd = open((char const   *)(tmpname), 194, 420);
  }
#line 140
  if (-1 == fd) {
    {
#line 142
    tmp___6 = __errno_location();
    }
#line 142
    if (17 != *tmp___6) {
      {
#line 143
      log_((char *)"reorder:open(%s):%m", tmpname);
      }
    }
#line 144
    return;
  }
  {
#line 147
  f___9.magic = 1027296;
#line 148
  tmp___7 = nosigio___2((ssize_t (*)())(& write), fd, (char *)(& f___9), (int )sizeof(f___9));
  }
#line 148
  if (-1 == tmp___7) {
#line 149
    goto fail;
  }
  {
#line 161
  tmp___9 = lockf(sp->fd, 2, (__off_t )0);
  }
#line 161
  if (-1 == tmp___9) {
    {
#line 165
    tmp___8 = __errno_location();
    }
#line 165
    if (11 != *tmp___8) {
#line 166
      p___0 = (char *)"reorder:can\'t lockf %s:%m";
    } else {
#line 168
      p___0 = (char *)"reorder:article in %s being cancelled?";
    }
    {
#line 169
    log_(p___0, sp->filename);
    }
#line 170
    goto fail;
  }
#line 173
  i = 0;
  {
#line 173
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 173
    if (! (i < 10)) {
#line 173
      goto while_break___1;
    }
    {
#line 174
    tmp___10 = checkindex___2((sp->file)->info + i);
    }
    {
#line 176
    if (tmp___10 == 0) {
#line 176
      goto case_0;
    }
#line 188
    if (tmp___10 == 1) {
#line 188
      goto case_1;
    }
#line 191
    if (tmp___10 == -1) {
#line 191
      goto case_neg_1;
    }
#line 174
    goto switch_break;
    case_0: /* CIL Label */ 
    {
#line 177
    tmp___12 = lseek(fd, (__off_t )0, 2);
#line 177
    tmp___11 = (int )tmp___12;
#line 177
    f___9.info[i].hoffset = tmp___11;
    }
#line 177
    if (tmp___11 > 0) {
      {
#line 179
      f___9.info[i].hlen = (sp->file)->info[i].hlen;
#line 180
      f___9.info[i].blen = (sp->file)->info[i].blen;
#line 181
      er = copyart___2(fd, sp->fd, (sp->file)->info[i].hoffset, f___9.info[i].hlen);
      }
#line 182
      if (0 == er) {
#line 183
        goto switch_break;
      }
    } else {
      {
#line 186
      log_((char *)"reorder:lseek(%s):%m", tmpname);
      }
    }
#line 187
    goto fail;
    case_1: /* CIL Label */ 
#line 189
    tmp___15 = -1;
#line 189
    f___9.info[i].hlen = tmp___15;
#line 189
    tmp___14 = tmp___15;
#line 189
    f___9.info[i].blen = tmp___14;
#line 189
    tmp___13 = tmp___14;
#line 189
    f___9.info[i].hoffset = tmp___13;
#line 189
    f___9.info[i].boffset = tmp___13;
#line 190
    goto switch_break;
    case_neg_1: /* CIL Label */ 
    {
#line 192
    log_((char *)"reorder:corrupt index in %s", sp->filename);
    }
#line 193
    goto fail;
    switch_break: /* CIL Label */ ;
    }
#line 173
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 195
  i = 0;
  {
#line 195
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 195
    if (! (i < 10)) {
#line 195
      goto while_break___2;
    }
#line 197
    if (-1 == f___9.info[i].boffset) {
#line 198
      goto __Cont;
    }
    {
#line 199
    tmp___17 = lseek(fd, (__off_t )0, 2);
#line 199
    tmp___16 = (int )tmp___17;
#line 199
    f___9.info[i].boffset = tmp___16;
    }
#line 199
    if (-1 == tmp___16) {
      {
#line 201
      log_((char *)"reorder:lseek(%s):%m", tmpname);
      }
#line 202
      goto fail;
    }
    {
#line 204
    er = copyart___2(fd, sp->fd, (sp->file)->info[i].boffset, f___9.info[i].blen);
    }
#line 205
    if (-1 == er) {
#line 206
      goto fail;
    }
    __Cont: /* CIL Label */ 
#line 195
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 209
  tmp___18 = lseek(fd, (__off_t )0, 0);
  }
#line 209
  if (-1L == tmp___18) {
    {
#line 211
    log_((char *)"reorder:lseek:%m");
    }
#line 212
    goto fail;
  }
  {
#line 214
  tmp___19 = nosigio___2((ssize_t (*)())(& write), fd, (char *)(& f___9), (int )sizeof(f___9));
  }
#line 214
  if (-1 == tmp___19) {
#line 215
    goto fail;
  }
  {
#line 216
  tmp___20 = rename((char const   *)(tmpname), (char const   *)sp->filename);
  }
#line 216
  if (-1 == tmp___20) {
    {
#line 218
    log_((char *)"reorder:rename:%m");
    }
#line 219
    goto fail;
  }
  {
#line 221
  close(fd);
  }
#line 222
  return;
  fail: 
  {
#line 225
  log_((char *)"reorder:write failed for %s:%m", sp->filename);
#line 226
  tmp___21 = unlink((char const   *)(tmpname));
  }
#line 226
  if (-1 == tmp___21) {
    {
#line 227
    log_((char *)"reorder:unlink(%s):%m", tmpname);
    }
  }
  {
#line 228
  close(fd);
  }
#line 229
  return;
}
}
#line 231 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/store.c"
static void sto_free___2(void *p ) 
{ 
  struct storeobj *sp ;
  int tmp ;

  {
  {
#line 233
  sp = (struct storeobj *)p;
#line 235
  close(sp->fd);
#line 236
  tmp = munmap((void *)((caddr_t )sp->file), sizeof(struct file ));
  }
#line 236
  if (-1 == tmp) {
    {
#line 237
    log_((char *)"sto_free:munmap:%m");
    }
  }
  {
#line 238
  free((void *)sp);
  }
#line 239
  return;
}
}
#line 241 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/store.c"
static int desc___12  ;
#line 304
static int tryopen___2(char *fn ) ;
#line 304 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/store.c"
static struct file f___2  =    {1027296, {{0, 0, 0, 0}}};
#line 270 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/store.c"
static int tryopen___2(char *fn ) 
{ 
  char fn2[287] ;
  int fd ;
  int i ;
  char *p ;
  char *q ;
  struct timeval tv ;
  char *tmp ;
  char tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  ssize_t tmp___7 ;

  {
  {
#line 278
  fd = open((char const   *)fn, 2);
  }
#line 278
  if (fd > -1) {
    {
#line 280
    lockf(fd, 1, (__off_t )0);
    }
#line 281
    return (fd);
  }
#line 283
  p = fn2;
#line 283
  q = fn;
  {
#line 283
  while (1) {
    while_continue: /* CIL Label */ ;
#line 283
    tmp = p;
#line 283
    p ++;
#line 283
    tmp___1 = q;
#line 283
    q ++;
#line 283
    tmp___0 = *tmp___1;
#line 283
    *tmp = tmp___0;
#line 283
    if (! ((int )tmp___0 != 47)) {
#line 283
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 284
  tmp___2 = p;
#line 284
  p ++;
#line 284
  *tmp___2 = (char )'+';
#line 285
  tmp___3 = p;
#line 285
  p ++;
#line 285
  *tmp___3 = (char )'+';
#line 286
  gettimeofday((struct timeval */* __restrict  */)(& tv), (__timezone_ptr_t )0);
#line 296
  i = (int )(tv.tv_sec / 30L);
  }
  {
#line 297
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 298
    tmp___4 = p;
#line 298
    p ++;
#line 298
    *tmp___4 = (char )(48 + i % 10);
#line 297
    i /= 10;
#line 297
    if (! i) {
#line 297
      goto while_break___0;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 300
  tmp___5 = p;
#line 300
  p ++;
#line 300
  *tmp___5 = (char )'\000';
#line 302
  i = 0;
  {
#line 302
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 302
    if (! (i < 100)) {
#line 302
      goto while_break___1;
    }
#line 306
    if (14 == i % 15) {
      {
#line 307
      log_((char *)"tryopen:racing on %s", fn);
      }
    }
    {
#line 308
    fd = open((char const   *)(fn2), 194, 420);
    }
#line 308
    if (fd > -1) {
      {
#line 310
      lockf(fd, 1, (__off_t )0);
#line 311
      tmp___7 = write(fd, (void const   *)((char *)(& f___2)), sizeof(f___2));
      }
#line 311
      if (sizeof(f___2) == (unsigned long )tmp___7) {
        {
#line 312
        tmp___6 = link((char const   *)(fn2), (char const   *)fn);
        }
#line 312
        if (0 == tmp___6) {
          {
#line 314
          unlink((char const   *)(fn2));
          }
#line 315
          return (fd);
        }
      }
      {
#line 317
      close(fd);
#line 318
      unlink((char const   *)(fn2));
      }
    }
    {
#line 321
    fd = open((char const   *)fn, 2);
    }
#line 321
    if (fd > -1) {
      {
#line 323
      lockf(fd, 1, (__off_t )0);
      }
#line 324
      return (fd);
    }
    {
#line 302
    nap(0, 300 + i);
#line 302
    i ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 327
  log_((char *)"tryopen:timed out opening %s:%m", fn);
  }
#line 328
  return (-1);
}
}
#line 337 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/store.c"
static struct storeobj *getstore___2(char *filename ) 
{ 
  struct storeobj *sp ;
  struct storeobj s ;
  int fd ;
  struct file *fp ;
  char buf___28[287] ;
  int c ;
  void *tmp ;
  void *tmp___0 ;
  char *p ;
  char *q ;
  char *tmp___1 ;
  char tmp___2 ;
  char *tmp___3 ;
  char *end ;
  unsigned long tmp___4 ;
  ssize_t tmp___5 ;
  size_t tmp___6 ;
  void *tmp___7 ;

  {
  {
#line 349
  s.filename = filename;
#line 350
  tmp = cache_find(desc___12, (void *)(& s));
#line 350
  sp = (struct storeobj *)tmp;
  }
#line 350
  if (sp) {
    {
#line 352
    lockf(sp->fd, 1, (__off_t )0);
    }
#line 353
    return (sp);
  }
  {
#line 356
  fd = tryopen___2(filename);
  }
#line 356
  if (-1 == fd) {
#line 357
    return ((struct storeobj *)0);
  }
  {
#line 361
  tmp___0 = mmap((void *)0, sizeof(*fp), 3, 1, fd, (__off_t )0);
#line 361
  fp = (struct file *)tmp___0;
  }
#line 362
  if (! fp) {
    {
#line 363
    log_((char *)"getstore:mmap(%s):%m", filename);
    }
  } else
#line 362
  if ((unsigned long )fp == (unsigned long )((void *)-1)) {
    {
#line 363
    log_((char *)"getstore:mmap(%s):%m", filename);
    }
  } else {
    {
#line 364
    tmp___6 = strlen((char const   *)filename);
#line 364
    tmp___7 = malloc((sizeof(*sp) + tmp___6) + 1UL);
#line 364
    sp = (struct storeobj *)tmp___7;
    }
#line 364
    if (sp) {
      {
#line 371
      sp->fd = fd;
#line 372
      sp->file = fp;
#line 373
      sp->filename = (char *)sp + sizeof(*sp);
#line 374
      strcpy((char */* __restrict  */)sp->filename, (char const   */* __restrict  */)filename);
#line 380
      p = buf___28;
#line 380
      q = filename;
      }
      {
#line 380
      while (1) {
        while_continue: /* CIL Label */ ;
#line 380
        tmp___1 = p;
#line 380
        p ++;
#line 380
        tmp___3 = q;
#line 380
        q ++;
#line 380
        tmp___2 = *tmp___3;
#line 380
        *tmp___1 = tmp___2;
#line 380
        if (! ((int )tmp___2 != 47)) {
#line 380
          goto while_break;
        }
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 381
      strcpy((char */* __restrict  */)p, (char const   */* __restrict  */)".compress");
#line 383
      fd = open((char const   *)(buf___28), 0);
      }
#line 383
      if (fd > -1) {
        {
#line 385
        sp->compressok = 1024;
#line 386
        tmp___5 = read(fd, (void *)(buf___28), sizeof(buf___28) - 1UL);
#line 386
        c = (int )tmp___5;
        }
#line 386
        if (c > 0) {
          {
#line 390
          buf___28[c] = (char )'\000';
#line 391
          tmp___4 = strtoul((char const   */* __restrict  */)(buf___28), (char **/* __restrict  */)(& end),
                            10);
#line 391
          c = (int )tmp___4;
          }
#line 392
          if (c > 1024) {
#line 392
            if (10 == (int )*end) {
#line 393
              sp->compressok = c;
            }
          }
        }
        {
#line 395
        close(fd);
        }
      } else {
#line 399
        sp->compressok = 0;
      }
      {
#line 400
      cache_insert(desc___12, (void *)sp);
      }
#line 401
      return (sp);
    } else {
      {
#line 366
      log_((char *)"getstore:no memory");
#line 367
      munmap((void *)fp, sizeof(*fp));
      }
    }
  }
  {
#line 403
  close(fd);
  }
#line 404
  return ((struct storeobj *)0);
}
}
#line 37 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/group.c"
static int desc___13  =    -1;
#line 59 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/group.c"
static int cmpgroup___4(void *a , void *b___13 ) 
{ 
  struct groupobj *x ;
  struct groupobj *y ;
  int tmp ;

  {
  {
#line 61
  x = (struct groupobj *)a;
#line 62
  y = (struct groupobj *)b___13;
#line 64
  tmp = strcmp((char const   *)x->groupname, (char const   *)y->groupname);
  }
#line 64
  return (tmp);
}
}
#line 67 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/group.c"
static void freegroup___4(void *p ) 
{ 
  struct groupobj *gop ;

  {
#line 69
  gop = (struct groupobj *)p;
#line 71
  if (gop->groupname) {
    {
#line 72
    free((void *)gop->groupname);
    }
  }
#line 73
  if (gop->dir.dir) {
    {
#line 74
    closedir(gop->dir.dir);
    }
  }
#line 75
  if (gop->lastf.f) {
    {
#line 76
    munmap((void *)((caddr_t )gop->lastf.f), sizeof(struct file ));
    }
  }
  {
#line 77
  free(p);
  }
#line 78
  return;
}
}
#line 94 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/group.c"
static int refresh___4(struct groupobj *gop , char *groupname ) 
{ 
  struct stat st ;
  struct dir *d ;
  struct lastf *lp ;
  bool needreread ;
  bool needrefile ;
  bool needreslot ;
  bool isemptygroup ;
  int tmp ;
  int tmp___0 ;
  struct dirent *dp ;
  int i ;
  int first ;
  int last___1 ;
  char *end ;
  int tmp___1 ;
  unsigned short const   **tmp___2 ;
  unsigned long tmp___3 ;
  int fd ;
  void *tmp___4 ;
  struct info *ip ;
  int slot ;

  {
#line 99
  needreread = (bool )0;
#line 100
  needrefile = (bool )0;
#line 101
  needreslot = (bool )0;
#line 102
  isemptygroup = (bool )0;
#line 104
  d = & gop->dir;
#line 105
  lp = & gop->lastf;
#line 107
  if (groupname) {
    {
#line 109
    memset((void *)gop, 0, sizeof(struct groupobj ));
#line 110
    gop->groupname = strdup((char const   *)groupname);
    }
#line 111
    if ((unsigned long )((void *)0) == (unsigned long )gop->groupname) {
      {
#line 113
      log_((char *)"refresh:strdup:%m");
      }
#line 114
      return (-1);
    }
    {
#line 116
    gop->dir.first = -1;
#line 117
    d->dir = opendir((char const   *)groupname);
    }
#line 118
    if ((unsigned long )((void *)0) == (unsigned long )d->dir) {
      {
#line 120
      log_((char *)"refresh:opendir:%m");
      }
#line 121
      return (-1);
    }
#line 123
    lp->name = -1;
#line 125
    needreslot = (bool )1;
#line 125
    needreread = needreslot;
#line 125
    needrefile = needreread;
  } else {
#line 131
    if (-1 == d->first) {
#line 132
      needreread = (bool )1;
    } else
#line 131
    if (0 == d->last) {
#line 132
      needreread = (bool )1;
    } else
#line 131
    if (! d->read) {
#line 132
      needreread = (bool )1;
    } else {
      {
#line 133
      tmp = dirfd(d->dir);
#line 133
      tmp___0 = fstat(tmp, & st);
      }
#line 133
      if (-1 == tmp___0) {
        {
#line 135
        log_((char *)"refresh:fstat:%m");
        }
#line 136
        return (-1);
      } else
#line 138
      if (d->read < st.st_mtim.tv_sec) {
#line 139
        needreread = (bool )1;
      }
    }
#line 140
    if (! lp->f) {
#line 141
      needreslot = (bool )1;
#line 141
      needrefile = needreslot;
    }
#line 142
    if (! needrefile) {
#line 143
      if (! lp->f) {
#line 144
        needrefile = (bool )1;
      }
    }
#line 145
    if (! needrefile) {
#line 146
      if (-1 == lp->name) {
#line 147
        needrefile = (bool )1;
      }
    }
  }
#line 150
  if (needreread) {
#line 150
    goto _L;
  } else
#line 150
  if (needreslot) {
    _L: /* CIL Label */ 
    {
#line 156
    first = -1;
#line 157
    last___1 = 0;
#line 158
    rewinddir(d->dir);
#line 159
    dp = readdir(d->dir);
    }
#line 160
    if ((unsigned long )((void *)0) == (unsigned long )dp) {
      {
#line 162
      log_((char *)"refresh:readdir:%m");
      }
#line 163
      return (-1);
    }
#line 165
    gop->nopost = (bool )0;
    {
#line 166
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 168
      tmp___2 = __ctype_b_loc();
      }
#line 168
      if (! ((int const   )*(*tmp___2 + (int )dp->d_name[0]) & 2048)) {
#line 170
        if (! gop->nopost) {
#line 170
          if (46 == (int )dp->d_name[0]) {
            {
#line 171
            tmp___1 = strcmp((char const   *)(dp->d_name), ".nopost");
            }
#line 171
            if (0 == tmp___1) {
#line 172
              gop->nopost = (bool )1;
            }
          }
        }
#line 173
        goto __Cont;
      }
      {
#line 175
      tmp___3 = strtoul((char const   */* __restrict  */)(dp->d_name), (char **/* __restrict  */)(& end),
                        10);
#line 175
      i = (int )tmp___3;
      }
#line 175
      if (i <= 0) {
#line 176
        goto __Cont;
      } else
#line 175
      if (*end) {
#line 176
        goto __Cont;
      }
#line 177
      if (first > i) {
#line 178
        first = i;
      } else
#line 177
      if (-1 == first) {
#line 178
        first = i;
      }
#line 179
      if (last___1 < i) {
#line 180
        last___1 = i;
      }
      __Cont: /* CIL Label */ 
      {
#line 166
      dp = readdir(d->dir);
      }
#line 166
      if (! dp) {
#line 166
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 183
    d->first = first;
#line 184
    d->last = last___1;
#line 185
    if (-1 == first) {
#line 185
      if (0 == last___1) {
#line 186
        isemptygroup = (bool )1;
      }
    }
#line 187
    if (last___1 != lp->name) {
#line 188
      needrefile = (bool )1;
    } else {
#line 190
      lp->name = last___1;
    }
    {
#line 191
    time(& d->read);
    }
  }
#line 194
  if (needrefile) {
#line 194
    goto _L___0;
  } else
#line 194
  if (needreslot) {
    _L___0: /* CIL Label */ 
#line 198
    if (lp->f) {
      {
#line 200
      munmap((void *)((caddr_t )lp->f), sizeof(struct file ));
#line 201
      lp->f = (struct file *)((void *)0);
      }
    }
#line 203
    if (isemptygroup) {
#line 204
      return (0);
    }
    {
#line 205
    fd = openf(0, 0, (char *)"%s/%d", gop->groupname, d->last);
    }
#line 206
    if (-1 == fd) {
      {
#line 208
      log_((char *)"refresh:open:%m");
      }
#line 209
      return (-1);
    }
    {
#line 211
    tmp___4 = mmap((void *)0, sizeof(struct file ), 1, 1, fd, (__off_t )0);
#line 211
    lp->f = (struct file *)tmp___4;
#line 212
    close(fd);
    }
#line 213
    if ((unsigned long )lp->f == (unsigned long )((void *)-1)) {
      {
#line 215
      log_((char *)"refresh:mmap:%m");
      }
#line 216
      return (-1);
    }
#line 218
    lp->slotsfilled = 0;
#line 219
    needreslot = (bool )1;
  }
#line 222
  if (needreslot) {
#line 224
    ip = (lp->f)->info;
#line 227
    slot = 9;
    {
#line 227
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 227
      if (! (slot > -1)) {
#line 227
        goto while_break___0;
      }
#line 228
      if ((ip + slot)->hoffset) {
#line 229
        goto while_break___0;
      }
#line 227
      slot --;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 230
    lp->slotsfilled = slot + 1;
  }
#line 233
  return (0);
}
}
#line 33 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/art.c"
static size_t pagesize___14  =    (size_t )0;
#line 80 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/art.c"
static void file_unmap___4(void *p ) 
{ 
  struct fileobj *fp ;

  {
  {
#line 82
  fp = (struct fileobj *)p;
#line 84
  munmap((void *)fp->map, (size_t )fp->size);
#line 85
  free((void *)fp);
  }
#line 86
  return;
}
}
#line 88 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/art.c"
static int file_cmp___4(void *a , void *b___13 ) 
{ 
  struct fileobj *x ;
  struct fileobj *y ;
  int tmp ;

  {
  {
#line 90
  x = (struct fileobj *)a;
#line 91
  y = (struct fileobj *)b___13;
#line 93
  tmp = strcmp((char const   *)x->path, (char const   *)y->path);
  }
#line 93
  return (tmp);
}
}
#line 96 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/art.c"
static int desc___14  =    -1;
#line 98 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/art.c"
static int file_init___4(void) 
{ 


  {
  {
#line 100
  desc___14 = cache_init(8, & file_cmp___4, & file_unmap___4, (int (*)(void * ))((void *)0));
  }
#line 101
  if (-1 == desc___14) {
    {
#line 103
    log_((char *)"file_init:%m");
    }
#line 104
    return (-1);
  }
#line 106
  return (0);
}
}
#line 109 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/art.c"
static struct file *file_gimme___4(char *name , int *size___1 ) 
{ 
  struct fileobj f___9 ;
  struct fileobj *fp ;
  void *tmp ;

  {
  {
#line 111
  f___9.path = (char *)0;
#line 111
  f___9.map = (char *)0;
#line 111
  f___9.size = 0;
#line 114
  f___9.path = name;
#line 116
  tmp = cache_find(desc___14, (void *)(& f___9));
#line 116
  fp = (struct fileobj *)tmp;
  }
#line 116
  if ((unsigned long )((void *)0) == (unsigned long )fp) {
    {
#line 118
    fp = file_map(name);
    }
#line 118
    if ((unsigned long )((void *)0) == (unsigned long )fp) {
#line 119
      return ((struct file *)((void *)0));
    } else {
      {
#line 121
      cache_insert(desc___14, (void *)fp);
      }
    }
  }
#line 124
  if (size___1) {
#line 125
    *size___1 = fp->size;
  }
#line 126
  return ((struct file *)fp->map);
}
}
#line 137 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/art.c"
static bool file_initialized___4  =    (bool )0;
#line 248 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/art.c"
static char ngroup___4[287]  ;
#line 297 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/art.c"
static int getfield___4(char *buf___28 , struct field *f___9 ) 
{ 
  register char *cp ;
  size_t tmp ;
  size_t tmp___0 ;

  {
  {
#line 299
  cp = buf___28;
#line 301
  tmp = strspn((char const   *)cp, " \t\f");
#line 301
  cp += tmp;
  }
#line 302
  if (! *cp) {
#line 304
    f___9->pointer = (char *)((void *)0);
#line 305
    return (0);
  }
  {
#line 307
  tmp___0 = strcspn((char const   *)cp, "\r\n");
#line 307
  f___9->len = (int )tmp___0;
  }
#line 308
  if (! f___9->len) {
#line 309
    return (0);
  }
#line 310
  f___9->pointer = cp;
#line 311
  return ((int )((cp + f___9->len) - buf___28));
}
}
#line 383 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/art.c"
static struct b b___5  =    {(char *)0, 0, 0};
#line 105 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/dh_find.c"
static int initfile___9(void) 
{ 
  int fd ;
  int integer ;
  int i ;
  char foo[3] ;
  unsigned int tmp ;
  int *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  ssize_t tmp___3 ;
  ssize_t tmp___4 ;

  {
#line 108
  integer = 218885376;
#line 110
  foo[0] = (char )'\000';
#line 110
  tmp = 1U;
  {
#line 110
  while (1) {
    while_continue: /* CIL Label */ ;
#line 110
    if (tmp >= 3U) {
#line 110
      goto while_break;
    }
#line 110
    foo[tmp] = (char)0;
#line 110
    tmp ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 112
  fd = open((char const   *)(dh_tablefile), 194, 420);
  }
#line 113
  if (fd == -1) {
#line 114
    return (-1);
  }
  {
#line 115
  tmp___2 = lockf(fd, 2, (__off_t )0);
  }
#line 115
  if (tmp___2 == -1) {
    {
#line 117
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 119
      tmp___0 = __errno_location();
      }
#line 119
      if (*tmp___0 == 11) {
        {
#line 120
        nap(0, 200);
        }
      } else {
#line 122
        goto fail;
      }
      {
#line 117
      tmp___1 = lockf(fd, 2, (__off_t )0);
      }
#line 117
      if (! (tmp___1 == -1)) {
#line 117
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 125
    lockf(fd, 0, (__off_t )0);
    }
#line 126
    return (fd);
  }
  {
#line 128
  tmp___3 = write(fd, (void const   *)(& integer), sizeof(int ));
  }
#line 128
  if ((unsigned long )tmp___3 != sizeof(int )) {
#line 129
    goto fail;
  }
#line 130
  i = 0;
  {
#line 130
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 130
    if (! (i < 10240)) {
#line 130
      goto while_break___1;
    }
    {
#line 131
    tmp___4 = write(fd, (void const   *)(foo), sizeof(foo));
    }
#line 131
    if ((unsigned long )tmp___4 != sizeof(foo)) {
#line 132
      goto fail;
    }
#line 130
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 133
  lseek(fd, (__off_t )0, 0);
#line 134
  lockf(fd, 0, (__off_t )0);
  }
#line 135
  return (fd);
  fail: 
#line 138
  if (fd > -1) {
    {
#line 139
    close(fd);
    }
  }
#line 140
  return (-1);
}
}
#line 78 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/allocate.c"
static struct table___1 table___5  =    {(char *)0, (char *)0, 0, 0, 0, 0};
#line 80
static int remapfile___4(void) ;
#line 106 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/allocate.c"
static int initfile___10(char *filename ) 
{ 
  struct chainfile cf ;
  int fd ;
  int i ;
  int ret ;
  ssize_t tmp ;
  int pad ;
  ssize_t tmp___0 ;

  {
  {
#line 108
  cf.chain_magic = 0;
#line 108
  cf.next[0] = 0;
#line 108
  cf.next[1] = 0;
#line 108
  cf.next[2] = 0;
#line 108
  cf.next[3] = 0;
#line 108
  cf.next[4] = 0;
#line 108
  cf.next[5] = 0;
#line 108
  cf.next[6] = 0;
#line 108
  cf.next[7] = 0;
#line 108
  cf.next[8] = 0;
#line 108
  cf.next[9] = 0;
#line 108
  cf.next[10] = 0;
#line 108
  cf.next[11] = 0;
#line 108
  cf.next[12] = 0;
#line 108
  cf.next[13] = 0;
#line 108
  cf.next[14] = 0;
#line 108
  cf.next[15] = 0;
#line 108
  cf.next[16] = 0;
#line 108
  cf.next[17] = 0;
#line 108
  cf.next[18] = 0;
#line 108
  cf.next[19] = 0;
#line 108
  cf.next[20] = 0;
#line 108
  cf.next[21] = 0;
#line 108
  cf.next[22] = 0;
#line 108
  cf.next[23] = 0;
#line 108
  cf.next[24] = 0;
#line 108
  cf.next[25] = 0;
#line 108
  cf.next[26] = 0;
#line 108
  cf.next[27] = 0;
#line 108
  cf.next[28] = 0;
#line 108
  cf.next[29] = 0;
#line 108
  cf.next[30] = 0;
#line 108
  cf.next[31] = 0;
#line 108
  cf.next[32] = 0;
#line 108
  cf.next[33] = 0;
#line 108
  cf.next[34] = 0;
#line 108
  cf.next[35] = 0;
#line 108
  cf.next[36] = 0;
#line 108
  cf.next[37] = 0;
#line 108
  cf.next[38] = 0;
#line 108
  cf.next[39] = 0;
#line 108
  cf.next[40] = 0;
#line 108
  cf.next[41] = 0;
#line 108
  cf.next[42] = 0;
#line 108
  cf.next[43] = 0;
#line 108
  cf.next[44] = 0;
#line 108
  cf.next[45] = 0;
#line 108
  cf.next[46] = 0;
#line 108
  cf.next[47] = 0;
#line 108
  cf.next[48] = 0;
#line 108
  cf.next[49] = 0;
#line 108
  cf.next[50] = 0;
#line 108
  cf.next[51] = 0;
#line 108
  cf.next[52] = 0;
#line 108
  cf.next[53] = 0;
#line 108
  cf.next[54] = 0;
#line 108
  cf.next[55] = 0;
#line 108
  cf.next[56] = 0;
#line 108
  cf.next[57] = 0;
#line 108
  cf.next[58] = 0;
#line 108
  cf.next[59] = 0;
#line 108
  cf.next[60] = 0;
#line 108
  cf.next[61] = 0;
#line 108
  cf.next[62] = 0;
#line 111
  ret = 0;
#line 113
  fd = open((char const   *)filename, 578, 420);
  }
#line 114
  if (-1 == fd) {
#line 115
    return (-1);
  }
#line 116
  cf.chain_magic = 13680336;
#line 117
  i = 0;
  {
#line 117
  while (1) {
    while_continue: /* CIL Label */ ;
#line 117
    if (! (i < 63)) {
#line 117
      goto while_break;
    }
#line 118
    cf.next[i] = (int volatile   )0;
#line 117
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 119
  tmp = write(fd, (void const   *)(& cf), sizeof(cf));
#line 119
  i = (int )tmp;
  }
#line 120
  if ((unsigned long )i == sizeof(cf)) {
#line 124
    pad = (int )(sizeof(cf) % 4UL);
#line 125
    if (pad > 0) {
#line 126
      i = 0;
      {
#line 126
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 126
        if (i < pad) {
#line 126
          if (! (0 == ret)) {
#line 126
            goto while_break___0;
          }
        } else {
#line 126
          goto while_break___0;
        }
        {
#line 127
        tmp___0 = write(fd, (void const   *)"", (size_t )1);
        }
#line 127
        if (1L != tmp___0) {
#line 128
          ret = -1;
        }
#line 126
        i ++;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
  } else {
#line 131
    ret = -1;
  }
  {
#line 132
  close(fd);
  }
#line 133
  return (ret);
}
}
#line 136 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/allocate.c"
static void unmapfile___4(void) 
{ 


  {
#line 138
  if (table___5.fd >= 0) {
    {
#line 140
    close(table___5.fd);
#line 141
    table___5.fd = -1;
    }
  }
#line 143
  if (table___5.map) {
    {
#line 145
    munmap((void *)table___5.map, (size_t )table___5.size);
#line 146
    table___5.map = (char *)((void *)0);
#line 147
    table___5.size = 0;
    }
  }
#line 149
  return;
}
}
#line 153
static size_t rounduptopagesize___4(size_t size___1 ) ;
#line 153 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/allocate.c"
static size_t pagesize___15  =    (size_t )0;
#line 151 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/allocate.c"
static size_t rounduptopagesize___4(size_t size___1 ) 
{ 
  int pages ;
  int tmp ;

  {
#line 156
  if (0UL == pagesize___15) {
    {
#line 157
    tmp = getpagesize();
#line 157
    pagesize___15 = (size_t )tmp;
    }
  }
#line 158
  pages = (int )(size___1 / pagesize___15 + 1UL);
#line 159
  return ((size_t )pages * pagesize___15);
}
}
#line 162 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/allocate.c"
static int mapfile___4(void) 
{ 
  struct stat st ;
  int tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;

  {
#line 166
  if (-1 == table___5.fd) {
    {
#line 167
    table___5.fd = open((char const   *)table___5.filename, table___5.oflag, 420);
    }
  }
#line 168
  if (-1 == table___5.fd) {
#line 169
    goto fail;
  }
  {
#line 171
  tmp = fstat(table___5.fd, & st);
  }
#line 171
  if (-1 == tmp) {
#line 172
    goto fail;
  }
  {
#line 173
  tmp___0 = rounduptopagesize___4((size_t )st.st_size);
#line 173
  table___5.size = (int )tmp___0;
#line 174
  tmp___1 = mmap((void *)0, (size_t )table___5.size, table___5.mprot, 1, table___5.fd,
                 (__off_t )0);
#line 174
  table___5.map = (char *)tmp___1;
  }
#line 175
  if (! table___5.map) {
#line 176
    goto fail;
  } else
#line 175
  if ((unsigned long )table___5.map == (unsigned long )((void *)-1)) {
#line 176
    goto fail;
  }
#line 178
  return (0);
  fail: 
  {
#line 181
  unmapfile___4();
  }
#line 182
  return (-1);
}
}
#line 189 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/allocate.c"
static int remapfile___4(void) 
{ 
  struct stat st ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 193
  tmp = fstat(table___5.fd, & st);
  }
#line 193
  if (-1 == tmp) {
#line 194
    return (-1);
  }
#line 196
  if (st.st_size <= (__off_t )table___5.size) {
#line 197
    return (0);
  }
  {
#line 199
  munmap((void *)table___5.map, (size_t )table___5.size);
#line 200
  tmp___0 = mapfile___4();
  }
#line 200
  return (tmp___0);
}
}
#line 209 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/allocate.c"
static int lock___4(void) 
{ 
  int *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 211
  tmp___2 = lockf(table___5.fd, 2, (__off_t )0);
  }
#line 211
  if (-1 == tmp___2) {
    {
#line 213
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 215
      tmp = __errno_location();
      }
#line 215
      if (11 != *tmp) {
#line 216
        return (-1);
      } else {
        {
#line 218
        nap(0, 200);
        }
      }
      {
#line 213
      tmp___0 = lockf(table___5.fd, 2, (__off_t )0);
      }
#line 213
      if (! (-1 == tmp___0)) {
#line 213
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 221
    tmp___1 = remapfile___4();
    }
#line 221
    if (-1 == tmp___1) {
#line 222
      return (-1);
    }
  }
#line 224
  return (0);
}
}
#line 227 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/allocate.c"
static void unlock___4(void) 
{ 


  {
  {
#line 229
  lseek(table___5.fd, (__off_t )0, 0);
#line 230
  lockf(table___5.fd, 0, (__off_t )0);
  }
#line 231
  return;
}
}
#line 233 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/allocate.c"
static int checkvalidfile___4(void) 
{ 


  {
#line 235
  if (table___5.size > 0) {
#line 237
    if ((unsigned long )table___5.size < sizeof(struct chainfile )) {
#line 238
      return (-1);
    }
#line 239
    if (((struct chainfile *)table___5.map)->chain_magic != 13680336) {
#line 240
      return (-1);
    }
  }
#line 242
  return (0);
}
}
#line 281 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/allocate.c"
static int rounduptoalignment___4(int size___1 ) 
{ 


  {
#line 283
  if (size___1 <= 0) {
#line 284
    return (4);
  }
#line 285
  return (((size___1 - 1) / 4 + 1) * 4);
}
}
#line 296 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/allocate.c"
static char tmpchunk___4[272]  = {      (char )'\000'};
#line 56 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/dhash.c"
static unsigned char buf___10[2]  ;
#line 54 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/dhash.c"
static char *inttochar2___4(int integer ) 
{ 


  {
#line 58
  buf___10[0] = (unsigned char )((integer & 65535) >> 8);
#line 59
  buf___10[1] = (unsigned char )(integer & 255);
#line 60
  return ((char *)(buf___10));
}
}
#line 65 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/dhash.c"
static unsigned char buf___11[3]  ;
#line 63 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/dhash.c"
static char *inttochar3___4(unsigned int integer ) 
{ 


  {
#line 67
  integer >>= 2;
#line 68
  buf___11[0] = (unsigned char )((integer & 16777215U) >> 16);
#line 69
  buf___11[1] = (unsigned char )((integer & 65535U) >> 8);
#line 70
  buf___11[2] = (unsigned char )(integer & 255U);
#line 71
  return ((char *)(buf___11));
}
}
#line 386 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int ( /* format attribute */  snprintf)(char * __restrict  __s ,
                                                                             size_t __maxlen ,
                                                                             char const   * __restrict  __format 
                                                                             , ...) ;
#line 29 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/sndumpdb.c"
int outfd  =    1;
#line 31 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/sndumpdb.c"
int dh_dump(int next ) 
{ 
  int i ;
  int nr___13 ;
  unsigned int index___0 ;
  struct chain *chp ;
  int empties ;
  int total ;
  int maxlen ;
  int bytes___1 ;
  char tmp_str[20] ;
  unsigned char *x ;
  int len ;
  char *group ;
  int ident ;
  void *tmp ;
  size_t tmp___0 ;

  {
#line 34
  nr___13 = 0;
#line 37
  empties = 0;
#line 38
  total = 0;
#line 39
  maxlen = 0;
#line 40
  bytes___1 = 0;
#line 43
  i = 0;
  {
#line 43
  while (1) {
    while_continue: /* CIL Label */ ;
#line 43
    if (! (i < 10240)) {
#line 43
      goto while_break;
    }
#line 45
    x = dh_table->next + i * 3;
#line 47
    index___0 = (unsigned int )((((int )*(x + 0) << 18) | ((int )*(x + 1) << 10)) | ((int )*(x + 2) << 2));
#line 48
    if (! index___0) {
#line 49
      empties ++;
    } else {
#line 52
      len = 0;
      {
#line 54
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 54
        if (! index___0) {
#line 54
          goto while_break___0;
        }
        {
#line 59
        tmp = allo_deref(index___0);
#line 59
        chp = (struct chain *)tmp;
        }
#line 60
        if ((unsigned long )((void *)0) == (unsigned long )chp) {
          {
#line 62
          log_((char *)"dh_dump:allo_deref returned bad ref");
          }
#line 63
          return (0 - nr___13);
        }
        {
#line 65
        ident = ((int )chp->newsgroup[0] << 8) | (int )chp->newsgroup[1];
#line 66
        group = ng_newsgroup(ident);
        }
#line 67
        if ((unsigned long )((void *)0) == (unsigned long )group) {
          {
#line 69
          log_((char *)"dh_dump:bad newsgroup for ident %d", ident);
          }
#line 70
          return (0 - nr___13);
        }
#line 72
        if (! next) {
          {
#line 73
          writef(outfd, (char *)"%s %d <%s>\n", group, chp->serial, chp->messageid);
          }
        } else {
          {
#line 75
          writef(outfd, (char *)"[%d,%d]%s %d <%s>\n", index___0, chp->next, group,
                 chp->serial, chp->messageid);
          }
        }
        {
#line 77
        nr___13 ++;
#line 78
        len ++;
#line 79
        tmp___0 = strlen((char const   *)(chp->messageid));
#line 79
        bytes___1 = (int )((size_t )bytes___1 + tmp___0);
#line 54
        index___0 = (unsigned int )chp->next;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
#line 81
      total += len;
#line 82
      if (len > maxlen) {
#line 83
        maxlen = len;
      }
    }
#line 43
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 87
  log_((char *)"%d chains of %d empty", empties, 10240);
#line 88
  log_((char *)"Total %d entries", total);
  }
#line 89
  if (empties < 10240) {
    {
#line 91
    snprintf((char */* __restrict  */)(tmp_str), (size_t )20, (char const   */* __restrict  */)"%.2f",
             (double )total / (double )(10240 - empties));
#line 92
    log_((char *)"for average chain length of %s", tmp_str);
    }
  }
  {
#line 94
  log_((char *)"with max chain length of %d", maxlen);
  }
#line 95
  if (total) {
    {
#line 97
    snprintf((char */* __restrict  */)(tmp_str), (size_t )20, (char const   */* __restrict  */)"%.2f",
             (double )bytes___1 / (double )total);
#line 98
    log_((char *)"Average length of ID is %s", tmp_str);
    }
  }
#line 100
  return (nr___13);
}
}
#line 35 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/newsgroup.c"
static struct ng *bygroup___4[128]  ;
#line 36 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/newsgroup.c"
static struct ng *byident___4[128]  ;
#line 37 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/newsgroup.c"
static int highest___4  =    0;
#line 39 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/newsgroup.c"
static unsigned int hash___9(char *buf___28 , int len ) 
{ 
  unsigned int h ;
  char *tmp ;

  {
#line 43
  h = 5381U;
  {
#line 44
  while (1) {
    while_continue: /* CIL Label */ ;
#line 44
    if (! len) {
#line 44
      goto while_break;
    }
#line 46
    len --;
#line 47
    h += h << 5;
#line 48
    tmp = buf___28;
#line 48
    buf___28 ++;
#line 48
    h ^= (unsigned int )*tmp;
  }
  while_break: /* CIL Label */ ;
  }
#line 50
  return (h);
}
}
#line 53 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/newsgroup.c"
static struct chunk *chunks___4  ;
#line 58 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/newsgroup.c"
static int avail___9  =    0;
#line 59 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/newsgroup.c"
static int nr___5  =    0;
#line 64 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/newsgroup.c"
static int add___5(int ident , char *group , int len ) 
{ 
  struct ng *np ;
  struct ng *p ;
  int want ;
  unsigned int h ;
  struct chunk *tmp ;
  int size___1 ;
  void *tmp___0 ;
  unsigned int tmp___1 ;
  int tmp___2 ;

  {
#line 71
  len ++;
#line 72
  want = (int )(((unsigned long )len + sizeof(struct ng )) + sizeof(char *));
#line 73
  want = (int )((unsigned long )want - (unsigned long )len % sizeof(char *));
#line 74
  len --;
#line 76
  if (avail___9 < want) {
#line 81
    if (want > 240) {
#line 81
      size___1 = want + 240;
    } else {
#line 81
      size___1 = 240;
    }
    {
#line 82
    tmp___0 = malloc((size_t )size___1);
#line 82
    tmp = (struct chunk *)tmp___0;
    }
#line 82
    if (! tmp) {
#line 83
      return (-1);
    }
#line 84
    tmp->next = chunks___4;
#line 85
    chunks___4 = tmp;
#line 86
    chunks___4->buf = (char *)chunks___4 + sizeof(struct chunk );
#line 87
    avail___9 = (int )((unsigned long )size___1 - sizeof(struct chunk ));
  }
  {
#line 89
  np = (struct ng *)chunks___4->buf;
#line 90
  chunks___4->buf += want;
#line 91
  avail___9 -= want;
#line 92
  strncpy((char */* __restrict  */)(np->group), (char const   */* __restrict  */)group,
          (size_t )len);
#line 93
  np->group[len] = (char )'\000';
#line 94
  np->ident = ident;
#line 96
  tmp___1 = hash___9(group, len);
#line 96
  h = tmp___1 % 128U;
#line 97
  np->gnext = bygroup___4[h];
#line 98
  bygroup___4[h] = np;
#line 99
  p = np->gnext;
  }
  {
#line 99
  while (1) {
    while_continue: /* CIL Label */ ;
#line 99
    if (! p) {
#line 99
      goto while_break;
    }
    {
#line 100
    tmp___2 = strcmp((char const   *)(p->group), (char const   *)group);
    }
#line 100
    if (0 == tmp___2) {
#line 101
      return (1);
    }
#line 99
    p = p->gnext;
  }
  while_break: /* CIL Label */ ;
  }
#line 102
  h = (unsigned int )(ident % 128);
#line 103
  np->inext = byident___4[h];
#line 104
  byident___4[h] = np;
#line 105
  p = np->inext;
  {
#line 105
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 105
    if (! p) {
#line 105
      goto while_break___0;
    }
#line 106
    if (p->ident == ident) {
#line 107
      return (1);
    }
#line 105
    p = p->inext;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 109
  if (ident > highest___4) {
#line 110
    highest___4 = ident;
  }
#line 111
  nr___5 ++;
#line 112
  return (0);
}
}
#line 116 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/newsgroup.c"
static int groupfd___4  =    -1;
#line 117 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/newsgroup.c"
static int oldsize___4  =    0;
#line 118 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/newsgroup.c"
static int mapsize___4  =    0;
#line 119 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/newsgroup.c"
static char *mapbuf___4  =    (char *)((void *)0);
#line 148
static int reload___4(void) ;
#line 148 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/newsgroup.c"
static int pagesize___16  =    0;
#line 145 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/newsgroup.c"
static int reload___4(void) 
{ 
  struct stat st ;
  int newsize ;
  int tmp ;
  void *tmp___0 ;
  char *p ;
  char *lim ;
  char *ip ;
  char *gr ;
  int ident ;
  int state ;
  int tmp___1 ;

  {
  {
#line 156
  tmp = fstat(groupfd___4, & st);
  }
#line 156
  if (-1 == tmp) {
    {
#line 158
    log_((char *)"reload:fstat:%m");
    }
#line 159
    return (-1);
  }
#line 161
  newsize = (int )st.st_size;
#line 162
  if (! pagesize___16) {
    {
#line 163
    pagesize___16 = getpagesize();
    }
  }
#line 164
  if (newsize <= oldsize___4) {
#line 165
    return (0);
  }
#line 166
  if (newsize > mapsize___4) {
#line 166
    goto _L;
  } else
#line 166
  if (! mapsize___4) {
    _L: /* CIL Label */ 
#line 168
    if (mapbuf___4) {
      {
#line 169
      munmap((void *)mapbuf___4, (size_t )mapsize___4);
      }
    }
    {
#line 170
    mapsize___4 = (int )((st.st_size + (__off_t )pagesize___16) - st.st_size % (long )pagesize___16);
#line 171
    tmp___0 = mmap((void *)0, (size_t )mapsize___4, 1, 1, groupfd___4, (__off_t )0);
#line 171
    mapbuf___4 = (char *)tmp___0;
    }
#line 172
    if (! mapbuf___4) {
      {
#line 174
      log_((char *)"reload:mmap:%m");
      }
#line 175
      return (-1);
    } else
#line 172
    if ((unsigned long )mapbuf___4 == (unsigned long )((void *)-1)) {
      {
#line 174
      log_((char *)"reload:mmap:%m");
      }
#line 175
      return (-1);
    }
  }
#line 188
  lim = mapbuf___4 + newsize;
#line 189
  state = 0;
#line 189
  ident = state;
#line 190
  gr = (char *)0;
#line 190
  ip = gr;
#line 191
  p = mapbuf___4 + oldsize___4;
  {
#line 191
  while (1) {
    while_continue: /* CIL Label */ ;
#line 191
    if (! ((unsigned long )p < (unsigned long )lim)) {
#line 191
      goto while_break;
    }
    {
#line 194
    if (state == 0) {
#line 194
      goto case_0;
    }
#line 195
    if (state == 1) {
#line 195
      goto case_1;
    }
#line 196
    if (state == 2) {
#line 196
      goto case_2;
    }
#line 197
    if (state == 3) {
#line 197
      goto case_3;
    }
#line 192
    goto switch_break;
    case_0: /* CIL Label */ 
#line 194
    if ((int )*p >= 48) {
#line 194
      if ((int )*p <= 57) {
#line 194
        ip = p;
#line 194
        state ++;
      }
    }
#line 194
    goto switch_break;
    case_1: /* CIL Label */ 
#line 195
    if (32 == (int )*p) {
      {
#line 195
      ident = atoi((char const   *)ip);
#line 195
      state ++;
      }
    }
#line 195
    goto switch_break;
    case_2: /* CIL Label */ 
#line 196
    if (32 != (int )*p) {
#line 196
      gr = p;
#line 196
      state ++;
    }
#line 196
    goto switch_break;
    case_3: /* CIL Label */ 
#line 198
    if (10 != (int )*p) {
#line 199
      goto switch_break;
    }
    {
#line 200
    tmp___1 = add___5(ident, gr, (int )(p - gr));
    }
#line 200
    if (-1 == tmp___1) {
      {
#line 202
      log_((char *)"reload:no memory");
      }
#line 203
      return (-1);
    }
#line 205
    state = 0;
    switch_break: /* CIL Label */ ;
    }
#line 191
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 208
  oldsize___4 = newsize;
#line 209
  return (0);
}
}
#line 26 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/key.c"
static struct buf *head___5  ;
#line 27 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/key.c"
static int avail___10  =    0;
#line 28 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/key.c"
static char *keybuf___4  =    (char *)((void *)0);
#line 33 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/key.c"
static unsigned int hv___4  ;
#line 35 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/key.c"
static void hash___10(char *key , int len ) 
{ 
  char *tmp ;

  {
#line 37
  hv___4 = 5381U;
  {
#line 38
  while (1) {
    while_continue: /* CIL Label */ ;
#line 38
    if (! len) {
#line 38
      goto while_break;
    }
#line 40
    len --;
#line 41
    hv___4 += hv___4 << 5;
#line 42
    tmp = key;
#line 42
    key ++;
#line 42
    hv___4 ^= (unsigned int )*tmp;
  }
  while_break: /* CIL Label */ ;
  }
#line 44
  hv___4 %= 128U;
#line 45
  return;
}
}
#line 26 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/body.c"
static char *bodbuf___4  =    (char *)((void *)0);
#line 25 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/lib/wildmat.c"
static int match___0(char *candidate , char *pattern ) ;
#line 27 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/lib/wildmat.c"
static int bracket___0(char *candidate , char *pattern ) 
{ 
  bool negate ;
  char *end ;
  char c ;
  int flag ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;

  {
#line 29
  negate = (bool )0;
#line 32
  pattern ++;
#line 32
  end = pattern;
  {
#line 33
  while (1) {
    while_continue: /* CIL Label */ ;
#line 33
    if (*end) {
#line 33
      if (! (93 != (int )*end)) {
#line 33
        goto while_break;
      }
    } else {
#line 33
      goto while_break;
    }
#line 33
    if (92 == (int )*end) {
#line 33
      end ++;
    }
#line 33
    end ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 34
  if (! *end) {
#line 34
    return (-1);
  }
#line 35
  if (94 == (int )*pattern) {
#line 35
    negate = (bool )1;
#line 35
    pattern ++;
  }
#line 36
  if (45 == (int )*pattern) {
#line 36
    goto isnormalchar;
  }
  {
#line 37
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 37
    if (! *pattern) {
#line 37
      goto while_break___0;
    }
#line 42
    if (92 == (int )*pattern) {
#line 42
      pattern ++;
#line 42
      goto isnormalchar;
    }
#line 43
    if (93 == (int )*pattern) {
      {
#line 43
      tmp = match___0(candidate + 1, end + 1);
      }
#line 43
      return (1 + tmp);
    }
    {
#line 46
    if ((int )*(pattern + 1) == 0) {
#line 46
      goto case_0;
    }
#line 47
    if ((int )*(pattern + 1) == 45) {
#line 47
      goto case_45;
    }
#line 54
    goto isnormalchar;
    case_0: /* CIL Label */ 
#line 46
    return (-1);
    case_45: /* CIL Label */ 
    {
#line 48
    tmp___0 = tolower((int )*candidate);
#line 48
    c = (char )tmp___0;
#line 49
    tmp___1 = tolower((int )*pattern);
    }
#line 49
    if ((int )c >= tmp___1) {
      {
#line 49
      tmp___2 = tolower((int )*(pattern + 2));
      }
#line 49
      if ((int )c <= tmp___2) {
#line 49
        tmp___3 = 1;
      } else {
#line 49
        tmp___3 = 0;
      }
    } else {
#line 49
      tmp___3 = 0;
    }
#line 49
    flag = tmp___3;
#line 50
    if (flag) {
#line 50
      if (negate) {
#line 50
        return (-1);
      } else {
#line 50
        pattern += 2;
      }
    } else
#line 51
    if (negate) {
#line 51
      pattern += 2;
    } else {
#line 51
      return (-1);
    }
#line 52
    goto switch_break;
    isnormalchar: 
    switch_default: /* CIL Label */ 
    {
#line 55
    tmp___6 = tolower((int )*candidate);
#line 55
    tmp___7 = tolower((int )*pattern);
    }
#line 55
    if (tmp___6 == tmp___7) {
#line 57
      if (negate) {
#line 57
        pattern ++;
      } else {
        {
#line 57
        tmp___4 = match___0(candidate + 1, end + 1);
        }
#line 57
        return (1 + tmp___4);
      }
    } else
#line 60
    if (negate) {
      {
#line 60
      tmp___5 = match___0(candidate + 1, end + 1);
      }
#line 60
      return (1 + tmp___5);
    } else {
#line 60
      pattern ++;
    }
    switch_break: /* CIL Label */ ;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 63
  return (-1);
}
}
#line 66 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/lib/wildmat.c"
static int match___0(char *candidate , char *pattern ) 
{ 
  int ret ;
  char *c ;
  int len ;
  int clen ;
  size_t tmp ;
  size_t tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 68
  ret = 0;
  {
#line 72
  while (1) {
    while_continue: /* CIL Label */ ;
#line 74
    if (92 == (int )*pattern) {
#line 74
      goto default_char;
    }
    {
#line 77
    if ((int )*pattern == 0) {
#line 77
      goto case_0;
    }
#line 77
    if ((int )*pattern == 10) {
#line 77
      goto case_0;
    }
#line 77
    if ((int )*pattern == 13) {
#line 77
      goto case_0;
    }
#line 83
    if ((int )*pattern == 42) {
#line 83
      goto case_42;
    }
#line 104
    if ((int )*pattern == 91) {
#line 104
      goto case_91;
    }
#line 106
    if ((int )*pattern == 63) {
#line 106
      goto case_63;
    }
#line 113
    goto switch_default;
    case_0: /* CIL Label */ 
    case_10: /* CIL Label */ 
    case_13: /* CIL Label */ 
    {
#line 80
    if ((int )*candidate == 10) {
#line 80
      goto case_10___0;
    }
#line 80
    if ((int )*candidate == 13) {
#line 80
      goto case_10___0;
    }
#line 80
    if ((int )*candidate == 0) {
#line 80
      goto case_10___0;
    }
#line 78
    goto switch_break___0;
    case_10___0: /* CIL Label */ 
    case_13___0: /* CIL Label */ 
    case_0___0: /* CIL Label */ 
#line 80
    return (ret);
    switch_break___0: /* CIL Label */ ;
    }
#line 82
    return (-1);
    case_42: /* CIL Label */ 
    {
#line 89
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 89
      if (! (42 == (int )*pattern)) {
#line 89
        goto while_break___0;
      }
#line 89
      pattern ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 90
    if (! *pattern) {
      {
#line 90
      tmp = strcspn((char const   *)candidate, "\r\n");
      }
#line 90
      return ((int )((size_t )ret + tmp));
    }
    {
#line 91
    tmp___0 = strcspn((char const   *)candidate, "\r\n");
#line 91
    clen = (int )tmp___0;
#line 92
    c = candidate;
    }
    {
#line 92
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 92
      if (clen) {
#line 92
        if (! *c) {
#line 92
          goto while_break___1;
        }
      } else {
#line 92
        goto while_break___1;
      }
      {
#line 96
      if ((int )*c == 10) {
#line 96
        goto case_10___1;
      }
#line 96
      if ((int )*c == 13) {
#line 96
        goto case_10___1;
      }
#line 94
      goto switch_break___1;
      case_10___1: /* CIL Label */ 
      case_13___1: /* CIL Label */ 
#line 96
      return (-1);
      switch_break___1: /* CIL Label */ ;
      }
      {
#line 98
      len = match___0(c, pattern);
      }
#line 99
      if (len == clen) {
#line 99
        return ((int )((long )len + (c - candidate)));
      }
#line 92
      c ++;
#line 92
      clen --;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 101
    return (-1);
    case_91: /* CIL Label */ 
    {
#line 105
    tmp___1 = bracket___0(candidate, pattern);
    }
#line 105
    return (ret + tmp___1);
    case_63: /* CIL Label */ 
#line 107
    pattern ++;
#line 108
    if (! *candidate) {
#line 108
      return (-1);
    }
#line 109
    ret ++;
#line 109
    candidate ++;
#line 110
    goto while_continue;
    default_char: 
#line 112
    pattern ++;
    switch_default: /* CIL Label */ 
    {
#line 114
    tmp___2 = tolower((int )*pattern);
#line 114
    tmp___3 = tolower((int )*candidate);
    }
#line 114
    if (tmp___2 == tmp___3) {
#line 116
      pattern ++;
#line 116
      candidate ++;
#line 116
      ret ++;
    } else {
#line 119
      return (-1);
    }
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 444 "/usr/include/unistd.h"
extern unsigned int sleep(unsigned int __seconds ) ;
#line 956
extern int fsync(int __fd ) ;
#line 20 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/lib/opt.c"
int opt_ind  =    0;
#line 21 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/lib/opt.c"
char *opt_arg  =    (char *)0;
#line 22 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/lib/opt.c"
static int opt_char  =    0;
#line 24 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/lib/opt.c"
int opt_get(int c , char **v , char *opts ) 
{ 
  int tmp ;

  {
#line 26
  if (0 == opt_ind) {
#line 26
    opt_ind = 1;
  }
  {
#line 28
  while (1) {
    while_continue: /* CIL Label */ ;
#line 30
    if (opt_ind >= c) {
#line 31
      goto done;
    }
#line 32
    if (0 == opt_char) {
#line 34
      if (45 != (int )*(*(v + opt_ind) + opt_char)) {
#line 35
        goto done;
      }
#line 36
      opt_char ++;
#line 37
      if (45 == (int )*(*(v + opt_ind) + opt_char)) {
#line 38
        if (! *(*(v + opt_ind) + (opt_char + 1))) {
#line 40
          opt_arg = (char *)0;
#line 41
          opt_char = 0;
#line 42
          return (-1);
        }
      }
#line 44
      if (! *(*(v + opt_ind) + opt_char)) {
#line 45
        goto noarg;
      }
    }
#line 47
    if (! *(*(v + opt_ind) + opt_char)) {
#line 49
      opt_ind ++;
#line 50
      opt_char = 0;
#line 51
      goto while_continue;
    }
#line 53
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 56
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 56
    if (*opts) {
#line 56
      if (! ((int )*opts != (int )*(*(v + opt_ind) + opt_char))) {
#line 56
        goto while_break___0;
      }
    } else {
#line 56
      goto while_break___0;
    }
#line 56
    opts ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 57
  if (! *opts) {
#line 58
    goto noarg;
  }
#line 60
  if (! *(*(v + opt_ind) + (opt_char + 1))) {
#line 62
    if (opt_ind + 1 == c) {
#line 64
      opt_arg = (char *)0;
#line 65
      return ((int )*opts);
    }
#line 67
    opt_arg = *(v + (opt_ind + 1));
#line 68
    opt_ind += 2;
  } else {
#line 72
    opt_arg = (*(v + opt_ind) + opt_char) + 1;
#line 73
    opt_ind ++;
  }
#line 75
  opt_char = 0;
#line 76
  return ((int )*opts);
  noarg: 
#line 79
  opt_arg = (char *)0;
#line 80
  tmp = opt_char;
#line 80
  opt_char ++;
#line 80
  return ((int )*(*(v + opt_ind) + tmp));
  done: 
#line 82
  opt_arg = (char *)0;
#line 83
  opt_char = 0;
#line 84
  return (-1);
}
}
#line 23 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/lib/readln.c"
int readln_ready(int fd , int tmo , struct readln *rp ) 
{ 
  int tmp ;

  {
#line 25
  rp->buf = rp->bf;
#line 26
  rp->size = (int )sizeof(rp->bf);
#line 27
  rp->fd = fd;
#line 28
  tmp = 0;
#line 28
  rp->used = tmp;
#line 28
  rp->eaten = tmp;
#line 29
  rp->tmo = tmo;
#line 30
  return (0);
}
}
#line 33 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/lib/readln.c"
void readln_done(struct readln *rp ) 
{ 


  {
#line 35
  if (rp) {
#line 35
    if ((unsigned long )rp->buf != (unsigned long )(rp->bf)) {
      {
#line 36
      free((void *)rp->buf);
      }
    }
  }
#line 37
  return;
}
}
#line 39 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/lib/readln.c"
int readln(struct readln *rp , char **line , int ch ) 
{ 
  char *endp ;
  int len ;
  int tmp ;
  register char *from ;
  register char *to ;
  int n ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *lim ;
  int count ;
  char *tmp___2 ;
  int tmp___3 ;
  void *tmp___4 ;
  int tmp___5 ;
  void *tmp___6 ;
  struct timeval tv ;
  fd_set set ;
  int __d0 ;
  int __d1 ;
  int tmp___7 ;
  int *tmp___8 ;
  ssize_t tmp___9 ;

  {
#line 44
  if (rp->eaten == rp->used) {
#line 45
    tmp = 0;
#line 45
    rp->used = tmp;
#line 45
    rp->eaten = tmp;
  } else
#line 46
  if (rp->eaten) {
#line 46
    if (rp->eaten + 64 >= rp->used) {
#line 52
      from = rp->buf + rp->eaten;
#line 53
      to = rp->buf;
#line 54
      n = rp->used - rp->eaten;
      {
#line 54
      while (1) {
        while_continue: /* CIL Label */ ;
#line 54
        if (! n) {
#line 54
          goto while_break;
        }
#line 55
        tmp___0 = to;
#line 55
        to ++;
#line 55
        tmp___1 = from;
#line 55
        from ++;
#line 55
        *tmp___0 = *tmp___1;
#line 54
        n --;
      }
      while_break: /* CIL Label */ ;
      }
#line 56
      rp->used -= rp->eaten;
#line 57
      rp->eaten = 0;
    }
  }
  {
#line 60
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 65
    lim = rp->buf + rp->used;
#line 66
    endp = rp->buf + rp->eaten;
    {
#line 66
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 66
      if (! ((unsigned long )endp < (unsigned long )lim)) {
#line 66
        goto while_break___1;
      }
#line 67
      if (ch == (int )*endp) {
#line 68
        goto done;
      }
#line 66
      endp ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 69
    if (rp->size - rp->used < 16) {
#line 73
      if ((unsigned long )rp->buf == (unsigned long )(rp->bf)) {
        {
#line 74
        tmp___3 = 504;
#line 74
        rp->size = tmp___3;
#line 74
        tmp___4 = malloc((size_t )tmp___3);
#line 74
        tmp___2 = (char *)tmp___4;
        }
      } else {
        {
#line 76
        tmp___5 = rp->size * 2;
#line 76
        rp->size = tmp___5;
#line 76
        tmp___6 = malloc((size_t )tmp___5);
#line 76
        tmp___2 = (char *)tmp___6;
        }
      }
#line 77
      if (! tmp___2) {
#line 78
        return (-1);
      }
      {
#line 79
      memcpy((void */* __restrict  */)tmp___2, (void const   */* __restrict  */)(rp->buf + rp->eaten),
             (size_t )(rp->used - rp->eaten));
#line 80
      rp->used -= rp->eaten;
#line 81
      rp->eaten = 0;
      }
#line 82
      if ((unsigned long )rp->buf != (unsigned long )(rp->bf)) {
        {
#line 83
        free((void *)rp->buf);
        }
      }
#line 84
      rp->buf = tmp___2;
    }
#line 86
    if (rp->tmo > 0) {
      {
#line 91
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 91
        __asm__  volatile   ("cld; rep; "
                             "stosq": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                             "1" (& set.__fds_bits[0]): "memory");
#line 91
        goto while_break___2;
      }
      while_break___2: /* CIL Label */ ;
      }
      {
#line 92
      while (1) {
        while_continue___3: /* CIL Label */ ;
        {
#line 94
        set.__fds_bits[rp->fd / (8 * (int )sizeof(__fd_mask ))] |= 1L << rp->fd % (8 * (int )sizeof(__fd_mask ));
#line 95
        tv.tv_usec = (__suseconds_t )0;
#line 96
        tv.tv_sec = (__time_t )rp->tmo;
#line 97
        tmp___7 = select(rp->fd + 1, (fd_set */* __restrict  */)(& set), (fd_set */* __restrict  */)0,
                         (fd_set */* __restrict  */)0, (struct timeval */* __restrict  */)(& tv));
        }
        {
#line 99
        if (tmp___7 == 0) {
#line 99
          goto case_0;
        }
#line 101
        if (tmp___7 == -1) {
#line 101
          goto case_neg_1;
        }
#line 97
        goto switch_break;
        case_0: /* CIL Label */ 
#line 100
        return (-1);
        case_neg_1: /* CIL Label */ 
        {
#line 102
        tmp___8 = __errno_location();
        }
#line 102
        if (4 == *tmp___8) {
#line 103
          goto __Cont;
        }
#line 104
        return (-1);
        switch_break: /* CIL Label */ ;
        }
#line 106
        goto while_break___3;
        __Cont: /* CIL Label */ ;
      }
      while_break___3: /* CIL Label */ ;
      }
    }
    {
#line 109
    tmp___9 = read(rp->fd, (void *)(rp->buf + rp->used), (size_t )(rp->size - rp->used));
#line 109
    count = (int )tmp___9;
    }
#line 110
    if (count <= 0) {
#line 111
      return (count);
    }
#line 112
    rp->used += count;
  }
  while_break___0: /* CIL Label */ ;
  }
  done: 
#line 116
  *line = rp->buf + rp->eaten;
#line 117
  len = (int )((endp + 1) - (rp->buf + rp->eaten));
#line 118
  rp->eaten = (int )((endp + 1) - rp->buf);
#line 119
  return (len);
}
}
#line 12 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/lib/tokensep.c"
char *tokensep(char **p , char *delim ) 
{ 
  char map[256] ;
  unsigned int tmp ;
  char *start___0 ;
  char *end ;

  {
#line 14
  map[0] = (char)0;
#line 14
  tmp = 1U;
  {
#line 14
  while (1) {
    while_continue: /* CIL Label */ ;
#line 14
    if (tmp >= 256U) {
#line 14
      goto while_break;
    }
#line 14
    map[tmp] = (char)0;
#line 14
    tmp ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 18
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 18
    if (! *delim) {
#line 18
      goto while_break___0;
    }
#line 20
    map[(unsigned int )*delim] = (char)1;
#line 21
    delim ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 23
  start___0 = *p;
  {
#line 23
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 23
    if (*start___0) {
#line 23
      if (! map[(unsigned int )*start___0]) {
#line 23
        goto while_break___1;
      }
    } else {
#line 23
      goto while_break___1;
    }
#line 23
    start___0 ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 24
  if (! *start___0) {
#line 25
    return ((char *)((void *)0));
  }
#line 26
  end = start___0;
  {
#line 26
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 26
    if (*end) {
#line 26
      if (! (! map[(unsigned int )*end])) {
#line 26
        goto while_break___2;
      }
    } else {
#line 26
      goto while_break___2;
    }
#line 26
    end ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 27
  if (*end) {
#line 29
    *p = end + 1;
#line 30
    *end = (char )'\000';
  } else {
#line 33
    *p = end;
  }
#line 34
  return (start___0);
}
}
/* compiler builtin: 
   void __builtin_va_arg(__builtin_va_list  , unsigned long  , void * ) ;  */
#line 413 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) strerror)(int __errnum ) ;
#line 20 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/lib/format.h"
char *istr(int i , int base , char *tmp ) ;
#line 21
char *uistr(unsigned int u , int base , char *tmp ) ;
#line 16 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/lib/format.c"
static char *ichars  =    (char *)"0123456789abcdefghijklmnopqrstuvwxyz";
#line 18 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/lib/format.c"
char *istr(int i , int base , char *tmp ) 
{ 
  int n ;
  bool negative ;

  {
#line 21
  negative = (bool )0;
#line 23
  n = 39;
#line 23
  *(tmp + n) = (char )'\000';
#line 24
  if (i < 0) {
#line 26
    negative = (bool )1;
#line 27
    i = 0 - i;
  }
  {
#line 29
  while (1) {
    while_continue: /* CIL Label */ ;
#line 30
    n --;
#line 30
    *(tmp + n) = *(ichars + i % base);
#line 29
    i /= base;
#line 29
    if (! i) {
#line 29
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 32
  if (negative) {
#line 33
    n --;
#line 33
    *(tmp + n) = (char )'-';
  }
#line 34
  return (tmp + n);
}
}
#line 37 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/lib/format.c"
char *uistr(unsigned int u , int base , char *tmp ) 
{ 
  int n ;

  {
#line 41
  n = 39;
#line 41
  *(tmp + n) = (char )'\000';
  {
#line 42
  while (1) {
    while_continue: /* CIL Label */ ;
#line 43
    n --;
#line 43
    *(tmp + n) = *(ichars + u % (unsigned int )base);
#line 42
    u /= (unsigned int )base;
#line 42
    if (! u) {
#line 42
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 45
  return (tmp + n);
}
}
#line 48 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/lib/format.c"
int formatv(char *buf___28 , int size___1 , char *fmt , va_list ap ) 
{ 
  char *p ;
  int len ;
  char tmp[40] ;
  char *lim ;
  char *start___0 ;
  int i ;
  unsigned int u ;
  int tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  size_t tmp___3 ;
  int tmp___4 ;
  size_t tmp___5 ;
  unsigned int tmp___6 ;
  size_t tmp___7 ;
  unsigned int tmp___8 ;
  size_t tmp___9 ;
  unsigned int tmp___10 ;
  size_t tmp___11 ;
  int *tmp___12 ;
  size_t tmp___13 ;
  char *tmp___14 ;
  char *tmp___15 ;
  char *tmp___16 ;

  {
#line 56
  lim = buf___28 + size___1;
#line 57
  start___0 = buf___28;
  {
#line 59
  while (1) {
    while_continue: /* CIL Label */ ;
#line 59
    if (! *fmt) {
#line 59
      goto while_break;
    }
#line 60
    if (37 == (int )*fmt) {
#line 62
      fmt ++;
#line 63
      p = (char *)0;
      {
#line 63
      if ((int )*fmt == 83) {
#line 63
        goto case_83;
      }
#line 63
      if ((int )*fmt == 115) {
#line 63
        goto case_115;
      }
#line 63
      if ((int )*fmt == 100) {
#line 63
        goto case_100;
      }
#line 63
      if ((int )*fmt == 105) {
#line 63
        goto case_100;
      }
#line 63
      if ((int )*fmt == 117) {
#line 63
        goto case_117;
      }
#line 63
      if ((int )*fmt == 111) {
#line 63
        goto case_111;
      }
#line 63
      if ((int )*fmt == 120) {
#line 63
        goto case_120;
      }
#line 63
      if ((int )*fmt == 109) {
#line 63
        goto case_109;
      }
#line 63
      if ((int )*fmt == 37) {
#line 63
        goto case_37;
      }
#line 63
      goto switch_default;
      case_83: /* CIL Label */ 
      {
#line 63
      tmp___0 = __builtin_va_arg(ap, int );
#line 63
      len = tmp___0;
#line 63
      tmp___1 = __builtin_va_arg(ap, char *);
#line 63
      p = tmp___1;
      }
#line 63
      goto switch_break;
      case_115: /* CIL Label */ 
      {
#line 63
      tmp___2 = __builtin_va_arg(ap, char *);
#line 63
      p = tmp___2;
#line 63
      tmp___3 = strlen((char const   *)p);
#line 63
      len = (int )tmp___3;
      }
#line 63
      goto switch_break;
      case_100: /* CIL Label */ 
      case_105: /* CIL Label */ 
      {
#line 63
      tmp___4 = __builtin_va_arg(ap, int );
#line 63
      i = tmp___4;
#line 63
      p = istr(i, 10, tmp);
#line 63
      tmp___5 = strlen((char const   *)p);
#line 63
      len = (int )tmp___5;
      }
#line 63
      goto switch_break;
      case_117: /* CIL Label */ 
      {
#line 63
      tmp___6 = __builtin_va_arg(ap, unsigned int );
#line 63
      u = tmp___6;
#line 63
      p = uistr(u, 10, tmp);
#line 63
      tmp___7 = strlen((char const   *)p);
#line 63
      len = (int )tmp___7;
      }
#line 63
      goto switch_break;
      case_111: /* CIL Label */ 
      {
#line 63
      tmp___8 = __builtin_va_arg(ap, unsigned int );
#line 63
      u = tmp___8;
#line 63
      p = uistr(u, 8, tmp);
#line 63
      tmp___9 = strlen((char const   *)p);
#line 63
      len = (int )tmp___9;
      }
#line 63
      goto switch_break;
      case_120: /* CIL Label */ 
      {
#line 63
      tmp___10 = __builtin_va_arg(ap, unsigned int );
#line 63
      u = tmp___10;
#line 63
      p = uistr(u, 16, tmp);
#line 63
      tmp___11 = strlen((char const   *)p);
#line 63
      len = (int )tmp___11;
      }
#line 63
      goto switch_break;
      case_109: /* CIL Label */ 
      {
#line 63
      tmp___12 = __errno_location();
#line 63
      p = strerror(*tmp___12);
#line 63
      tmp___13 = strlen((char const   *)p);
#line 63
      len = (int )tmp___13;
      }
#line 63
      goto switch_break;
      case_37: /* CIL Label */ 
#line 63
      len = 1;
#line 63
      p = (char *)"%";
#line 63
      goto switch_break;
      switch_default: /* CIL Label */ 
#line 63
      len = 0;
#line 63
      p = (char *)"";
      switch_break: /* CIL Label */ ;
      }
      {
#line 64
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 64
        if (! len) {
#line 64
          goto while_break___0;
        }
#line 66
        tmp___14 = buf___28;
#line 66
        buf___28 ++;
#line 66
        tmp___15 = p;
#line 66
        p ++;
#line 66
        *tmp___14 = *tmp___15;
#line 67
        if ((unsigned long )buf___28 >= (unsigned long )lim) {
#line 68
          goto done;
        }
#line 64
        len --;
      }
      while_break___0: /* CIL Label */ ;
      }
    } else {
#line 73
      tmp___16 = buf___28;
#line 73
      buf___28 ++;
#line 73
      *tmp___16 = *fmt;
#line 74
      if ((unsigned long )buf___28 >= (unsigned long )lim) {
#line 75
        goto while_break;
      }
    }
#line 59
    fmt ++;
  }
  while_break: /* CIL Label */ ;
  }
  done: 
#line 78
  *buf___28 = (char )'\000';
#line 79
  return ((int )(buf___28 - start___0));
}
}
#line 82 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/lib/format.c"
int formats(char *buf___28 , int size___1 , char *fmt  , ...) 
{ 
  va_list ap ;
  int r ;

  {
  {
#line 87
  __builtin_va_start(ap, fmt);
#line 88
  r = formatv(buf___28, size___1, fmt, ap);
#line 89
  __builtin_va_end(ap);
  }
#line 90
  return (r);
}
}
#line 14 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/lib/log.c"
char *progname  =    (char *)0;
#line 15 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/lib/log.c"
static char logbuf[1024]  ;
#line 17 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/lib/log.c"
void logv(char *fmt , va_list ap ) 
{ 
  int len ;
  int tmp ;
  int tmp___0 ;

  {
#line 19
  len = 0;
#line 21
  if (progname) {
    {
#line 23
    while (1) {
      while_continue: /* CIL Label */ ;
#line 23
      if (! *(progname + len)) {
#line 23
        goto while_break;
      }
#line 24
      logbuf[len] = *(progname + len);
#line 23
      len ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 25
    tmp = len;
#line 25
    len ++;
#line 25
    logbuf[tmp] = (char )':';
  }
  {
#line 27
  tmp___0 = formatv(logbuf + len, (int )((sizeof(logbuf) - (unsigned long )len) - 2UL),
                    fmt, ap);
#line 27
  len += tmp___0;
#line 28
  logbuf[len] = (char )'\n';
#line 29
  write(2, (void const   *)(logbuf), (size_t )(len + 1));
  }
#line 30
  return;
}
}
#line 36 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/lib/log.c"
void log_(char *fmt  , ...) 
{ 
  va_list ap ;

  {
  {
#line 40
  __builtin_va_start(ap, fmt);
#line 41
  logv(fmt, ap);
#line 42
  __builtin_va_end(ap);
  }
#line 43
  return;
}
}
#line 45 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/lib/log.c"
void fail(int ex , char *fmt  , ...) 
{ 
  va_list ap ;

  {
  {
#line 49
  __builtin_va_start(ap, fmt);
#line 50
  logv(fmt, ap);
#line 51
  __builtin_va_end(ap);
#line 52
  _exit(ex);
  }
}
}
#line 16 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/lib/openf.c"
static char buf___12[4097]  ;
#line 18 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/lib/openf.c"
int openf(int mode , int flags , char *fmt  , ...) 
{ 
  int len ;
  va_list ap ;
  int *tmp ;
  int tmp___0 ;

  {
  {
#line 23
  __builtin_va_start(ap, fmt);
#line 24
  len = formatv(buf___12, (int )(sizeof(buf___12) - 1UL), fmt, ap);
#line 25
  __builtin_va_end(ap);
  }
#line 27
  if ((unsigned long )len >= sizeof(buf___12)) {
    {
#line 29
    tmp = __errno_location();
#line 29
    *tmp = 36;
    }
#line 30
    return (-1);
  }
  {
#line 32
  tmp___0 = open((char const   *)(buf___12), flags, mode);
  }
#line 32
  return (tmp___0);
}
}
#line 543 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 15 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/lib/cmdopen.c"
int cmdopen(char **command , int *read___0 , int *write___0 ) 
{ 
  int p0[2] ;
  int p1[2] ;
  int pid___0 ;
  int er ;
  int s ;
  __pid_t tmp ;
  union __anonunion_48 __constr_expr_16 ;
  union __anonunion_49___1 __constr_expr_17 ;
  union __anonunion_50___1 __constr_expr_18 ;
  union __anonunion_51___1 __constr_expr_19 ;

  {
#line 17
  p0[0] = -1;
#line 17
  p0[1] = -1;
#line 18
  p1[0] = -1;
#line 18
  p1[1] = -1;
#line 19
  pid___0 = 0;
#line 20
  er = 0;
#line 23
  if (read___0) {
    {
#line 23
    er = pipe((int *)(p0));
    }
  }
#line 24
  if (write___0) {
#line 24
    if (0 == er) {
      {
#line 24
      er = pipe((int *)(p1));
      }
    }
  }
#line 25
  if (-1 == er) {
#line 25
    goto fail;
  }
  {
#line 26
  pid___0 = fork();
  }
#line 27
  if (-1 == pid___0) {
#line 27
    goto fail;
  }
#line 28
  if (0 == pid___0) {
#line 30
    if (read___0) {
#line 30
      if (write___0) {
        {
#line 32
        dup2(p0[0], 0);
#line 33
        dup2(p1[1], 1);
        }
      } else {
#line 30
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
#line 37
      if (read___0) {
        {
#line 37
        close(p0[0]);
#line 37
        dup2(p0[1], 1);
        }
      }
#line 38
      if (write___0) {
        {
#line 38
        close(p1[1]);
#line 38
        dup2(p1[0], 0);
        }
      }
    }
    {
#line 40
    execvp((char const   *)*(command + 0), (char * const  *)command);
#line 41
    exit(19);
    }
  }
#line 43
  if (read___0) {
#line 43
    if (write___0) {
#line 50
      *read___0 = p0[0];
#line 50
      *write___0 = p1[1];
    } else {
#line 43
      goto _L___0;
    }
  } else {
    _L___0: /* CIL Label */ 
#line 45
    if (read___0) {
      {
#line 45
      close(p0[1]);
#line 45
      *read___0 = p0[0];
      }
    }
#line 46
    if (write___0) {
      {
#line 46
      close(p1[0]);
#line 46
      *write___0 = p1[1];
      }
    }
  }
  {
#line 52
  tmp = waitpid(pid___0, & s, 1);
  }
  {
#line 54
  if (tmp == 0) {
#line 54
    goto case_0;
  }
#line 56
  if (tmp == -1) {
#line 56
    goto case_neg_1;
  }
#line 59
  goto switch_default;
  case_0: /* CIL Label */ 
#line 55
  return (pid___0);
  case_neg_1: /* CIL Label */ 
#line 57
  pid___0 = -1;
#line 58
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 60
  __constr_expr_19.__in = s;
#line 60
  if ((__constr_expr_19.__i & 127) == 0) {
#line 61
    __constr_expr_16.__in = s;
#line 61
    pid___0 = 0 - ((__constr_expr_16.__i & 65280) >> 8);
  } else {
#line 62
    __constr_expr_18.__in = s;
#line 62
    if ((int )((signed char )((__constr_expr_18.__i & 127) + 1)) >> 1 > 0) {
#line 63
      __constr_expr_17.__in = s;
#line 63
      pid___0 = 0 - (128 + (__constr_expr_17.__i & 127));
    }
  }
  switch_break: /* CIL Label */ ;
  }
  fail: 
#line 67
  if (p0[0] > -1) {
    {
#line 67
    close(p0[0]);
    }
  }
#line 68
  if (p0[1] > -1) {
    {
#line 68
    close(p0[1]);
    }
  }
#line 69
  if (p1[0] > -1) {
    {
#line 69
    close(p1[0]);
    }
  }
#line 70
  if (p1[1] > -1) {
    {
#line 70
    close(p1[1]);
    }
  }
#line 71
  return (pid___0);
}
}
#line 74 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/lib/cmdopen.c"
int cmdopensh(char *cmd , int *read___0 , int *write___0 ) 
{ 
  char *commands[4] ;
  int tmp ;

  {
  {
#line 76
  commands[0] = (char *)"sh";
#line 76
  commands[1] = (char *)"-c";
#line 76
  commands[2] = (char *)0;
#line 76
  commands[3] = (char *)0;
#line 78
  commands[2] = cmd;
#line 79
  tmp = cmdopen(commands, read___0, write___0);
  }
#line 79
  return (tmp);
}
}
#line 82 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/lib/cmdopen.c"
int cmdwait(int pid___0 ) 
{ 
  int s ;
  __pid_t tmp ;
  union __anonunion_52___1 __constr_expr_20 ;
  union __anonunion_53 __constr_expr_21 ;
  union __anonunion_54 __constr_expr_22 ;
  union __anonunion_55 __constr_expr_23 ;

  {
  {
#line 86
  tmp = waitpid(pid___0, & s, 0);
  }
#line 86
  if (-1 == tmp) {
#line 87
    return (-1);
  }
#line 88
  __constr_expr_23.__in = s;
#line 88
  if ((__constr_expr_23.__i & 127) == 0) {
#line 89
    __constr_expr_20.__in = s;
#line 89
    return ((__constr_expr_20.__i & 65280) >> 8);
  } else {
#line 90
    __constr_expr_22.__in = s;
#line 90
    if ((int )((signed char )((__constr_expr_22.__i & 127) + 1)) >> 1 > 0) {
#line 91
      __constr_expr_21.__in = s;
#line 91
      return (128 + (__constr_expr_21.__i & 127));
    }
  }
#line 92
  return (0);
}
}
#line 20 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/lib/out.c"
static char outbuf[1024]  ;
#line 22 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/lib/out.c"
int writefv(int fd , char *fmt , va_list ap ) 
{ 
  int wrote ;
  int used___0 ;
  char *p ;
  int len ;
  char tmp[40] ;
  int er ;
  int i ;
  unsigned int u ;
  int tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  size_t tmp___3 ;
  int tmp___4 ;
  size_t tmp___5 ;
  unsigned int tmp___6 ;
  size_t tmp___7 ;
  unsigned int tmp___8 ;
  size_t tmp___9 ;
  unsigned int tmp___10 ;
  size_t tmp___11 ;
  int *tmp___12 ;
  size_t tmp___13 ;
  ssize_t tmp___14 ;
  int tmp___15 ;
  char *tmp___16 ;
  ssize_t tmp___17 ;
  int tmp___18 ;
  ssize_t tmp___19 ;

  {
#line 31
  wrote = 0;
#line 31
  used___0 = wrote;
  {
#line 31
  while (1) {
    while_continue: /* CIL Label */ ;
#line 31
    if (! *fmt) {
#line 31
      goto while_break;
    }
#line 32
    if (37 == (int )*fmt) {
#line 34
      fmt ++;
#line 35
      if (! *fmt) {
#line 36
        goto while_break;
      }
#line 37
      p = (char *)0;
      {
#line 37
      if ((int )*fmt == 83) {
#line 37
        goto case_83;
      }
#line 37
      if ((int )*fmt == 115) {
#line 37
        goto case_115;
      }
#line 37
      if ((int )*fmt == 100) {
#line 37
        goto case_100;
      }
#line 37
      if ((int )*fmt == 105) {
#line 37
        goto case_100;
      }
#line 37
      if ((int )*fmt == 117) {
#line 37
        goto case_117;
      }
#line 37
      if ((int )*fmt == 111) {
#line 37
        goto case_111;
      }
#line 37
      if ((int )*fmt == 120) {
#line 37
        goto case_120;
      }
#line 37
      if ((int )*fmt == 109) {
#line 37
        goto case_109;
      }
#line 37
      if ((int )*fmt == 37) {
#line 37
        goto case_37;
      }
#line 37
      goto switch_default;
      case_83: /* CIL Label */ 
      {
#line 37
      tmp___0 = __builtin_va_arg(ap, int );
#line 37
      len = tmp___0;
#line 37
      tmp___1 = __builtin_va_arg(ap, char *);
#line 37
      p = tmp___1;
      }
#line 37
      goto switch_break;
      case_115: /* CIL Label */ 
      {
#line 37
      tmp___2 = __builtin_va_arg(ap, char *);
#line 37
      p = tmp___2;
#line 37
      tmp___3 = strlen((char const   *)p);
#line 37
      len = (int )tmp___3;
      }
#line 37
      goto switch_break;
      case_100: /* CIL Label */ 
      case_105: /* CIL Label */ 
      {
#line 37
      tmp___4 = __builtin_va_arg(ap, int );
#line 37
      i = tmp___4;
#line 37
      p = istr(i, 10, tmp);
#line 37
      tmp___5 = strlen((char const   *)p);
#line 37
      len = (int )tmp___5;
      }
#line 37
      goto switch_break;
      case_117: /* CIL Label */ 
      {
#line 37
      tmp___6 = __builtin_va_arg(ap, unsigned int );
#line 37
      u = tmp___6;
#line 37
      p = uistr(u, 10, tmp);
#line 37
      tmp___7 = strlen((char const   *)p);
#line 37
      len = (int )tmp___7;
      }
#line 37
      goto switch_break;
      case_111: /* CIL Label */ 
      {
#line 37
      tmp___8 = __builtin_va_arg(ap, unsigned int );
#line 37
      u = tmp___8;
#line 37
      p = uistr(u, 8, tmp);
#line 37
      tmp___9 = strlen((char const   *)p);
#line 37
      len = (int )tmp___9;
      }
#line 37
      goto switch_break;
      case_120: /* CIL Label */ 
      {
#line 37
      tmp___10 = __builtin_va_arg(ap, unsigned int );
#line 37
      u = tmp___10;
#line 37
      p = uistr(u, 16, tmp);
#line 37
      tmp___11 = strlen((char const   *)p);
#line 37
      len = (int )tmp___11;
      }
#line 37
      goto switch_break;
      case_109: /* CIL Label */ 
      {
#line 37
      tmp___12 = __errno_location();
#line 37
      p = strerror(*tmp___12);
#line 37
      tmp___13 = strlen((char const   *)p);
#line 37
      len = (int )tmp___13;
      }
#line 37
      goto switch_break;
      case_37: /* CIL Label */ 
#line 37
      len = 1;
#line 37
      p = (char *)"%";
#line 37
      goto switch_break;
      switch_default: /* CIL Label */ 
#line 37
      len = 0;
#line 37
      p = (char *)"";
      switch_break: /* CIL Label */ ;
      }
      {
#line 38
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 38
        if (! len) {
#line 38
          goto while_break___0;
        }
#line 40
        if ((unsigned long )used___0 >= sizeof(outbuf)) {
          {
#line 42
          tmp___14 = write(fd, (void const   *)(outbuf), (size_t )used___0);
#line 42
          er = (int )tmp___14;
          }
#line 43
          if (-1 == er) {
#line 44
            return (-1);
          }
#line 45
          wrote += er;
#line 46
          used___0 = 0;
        }
#line 48
        tmp___15 = used___0;
#line 48
        used___0 ++;
#line 48
        tmp___16 = p;
#line 48
        p ++;
#line 48
        outbuf[tmp___15] = *tmp___16;
#line 38
        len --;
      }
      while_break___0: /* CIL Label */ ;
      }
    } else {
#line 53
      if ((unsigned long )used___0 >= sizeof(outbuf)) {
        {
#line 55
        tmp___17 = write(fd, (void const   *)(outbuf), (size_t )used___0);
#line 55
        er = (int )tmp___17;
        }
#line 56
        if (-1 == er) {
#line 57
          return (-1);
        }
#line 58
        wrote += er;
#line 59
        used___0 = 0;
      }
#line 61
      tmp___18 = used___0;
#line 61
      used___0 ++;
#line 61
      outbuf[tmp___18] = *fmt;
    }
#line 31
    fmt ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 63
  tmp___19 = write(fd, (void const   *)(outbuf), (size_t )used___0);
#line 63
  er = (int )tmp___19;
  }
#line 64
  if (-1 == er) {
#line 65
    return (-1);
  }
#line 66
  return (wrote + er);
}
}
#line 69 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/lib/out.c"
int writef(int fd , char *fmt  , ...) 
{ 
  va_list ap ;
  int er ;

  {
  {
#line 74
  __builtin_va_start(ap, fmt);
#line 75
  er = writefv(fd, fmt, ap);
#line 76
  __builtin_va_end(ap);
  }
#line 77
  return (er);
}
}
#line 18 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/lib/b.c"
int b_appendl(struct b *bp , char *str , int len ) 
{ 
  char *tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  int newsize ;
  char *tmp___2 ;
  void *tmp___3 ;

  {
#line 20
  if ((unsigned long )((void *)0) == (unsigned long )bp->buf) {
    {
#line 21
    tmp___0 = 248;
#line 21
    bp->size = tmp___0;
#line 21
    tmp___1 = malloc((size_t )tmp___0);
#line 21
    tmp = (char *)tmp___1;
#line 21
    bp->buf = tmp;
    }
#line 21
    if ((unsigned long )((void *)0) == (unsigned long )tmp) {
#line 22
      return (-1);
    } else {
#line 24
      bp->used = 0;
    }
  }
#line 26
  if (len + bp->used >= bp->size) {
#line 31
    if (len > bp->size) {
#line 32
      newsize = bp->size + len;
    } else {
#line 34
      newsize = bp->size * 2;
    }
    {
#line 35
    newsize += 16;
#line 36
    tmp___3 = malloc((size_t )newsize);
#line 36
    tmp___2 = (char *)tmp___3;
    }
#line 37
    if ((unsigned long )((void *)0) == (unsigned long )tmp___2) {
#line 38
      return (-1);
    }
    {
#line 39
    memcpy((void */* __restrict  */)tmp___2, (void const   */* __restrict  */)bp->buf,
           (size_t )(bp->used + 1));
#line 40
    bp->buf = tmp___2;
#line 41
    bp->size = newsize;
    }
  }
  {
#line 43
  memcpy((void */* __restrict  */)(bp->buf + bp->used), (void const   */* __restrict  */)str,
         (size_t )len);
#line 44
  bp->used += len;
#line 45
  *(bp->buf + bp->used) = (char )'\000';
  }
#line 46
  return (0);
}
}
#line 15 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/lib/nap.c"
void nap(int sec , int msec ) 
{ 
  struct timeval tv ;
  int tmp ;
  int *tmp___0 ;

  {
#line 19
  tv.tv_sec = (__time_t )sec;
#line 20
  tv.tv_usec = (__suseconds_t )(msec * 1000);
  {
#line 21
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 21
    tmp = select(0, (fd_set */* __restrict  */)0, (fd_set */* __restrict  */)0, (fd_set */* __restrict  */)0,
                 (struct timeval */* __restrict  */)(& tv));
    }
#line 21
    if (-1 == tmp) {
      {
#line 21
      tmp___0 = __errno_location();
      }
#line 21
      if (! (4 == *tmp___0)) {
#line 21
        goto while_break;
      }
    } else {
#line 21
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 23
  return;
}
}
#line 16 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/lib/statf.c"
static char buf___13[4097]  ;
#line 87 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/cache.c"
static struct entry *new_entry___5(int desc___35 ) 
{ 
  struct entry *ep ;
  struct entry *tmp ;

  {
#line 91
  ep = table[desc___35].freelist;
#line 91
  if (ep) {
#line 92
    table[desc___35].freelist = ep->next;
  } else {
#line 95
    ep = table[desc___35].entries;
    {
#line 95
    while (1) {
      while_continue: /* CIL Label */ ;
#line 95
      if (! ep->next) {
#line 95
        goto while_break;
      }
#line 95
      ep = ep->next;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 96
    (ep->prev)->next = (struct entry *)((void *)0);
#line 97
    (*(table[desc___35].freeobj))(ep->object);
    }
  }
#line 99
  tmp = (struct entry *)((void *)0);
#line 99
  ep->next = tmp;
#line 99
  ep->prev = tmp;
#line 100
  ep->object = (void *)0;
#line 101
  return (ep);
}
}
#line 67 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/store.c"
static int sto_cmp___3(void *a , void *b___13 ) 
{ 
  register struct storeobj *x ;
  register struct storeobj *y ;
  int tmp ;

  {
  {
#line 69
  x = (struct storeobj *)a;
#line 70
  y = (struct storeobj *)b___13;
#line 72
  tmp = strcmp((char const   *)x->filename, (char const   *)y->filename);
  }
#line 72
  return (tmp);
}
}
#line 75 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/store.c"
static int nosigio___3(ssize_t (*op)() , int fd , char *buf___28 , int len ) 
{ 
  int er ;
  int *tmp ;
  ssize_t tmp___0 ;

  {
  {
#line 79
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 79
    tmp___0 = (*op)(fd, buf___28, len);
#line 79
    er = (int )tmp___0;
    }
#line 79
    if (! (-1 == er)) {
#line 79
      goto while_break;
    }
    {
#line 80
    tmp = __errno_location();
    }
#line 80
    if (4 != *tmp) {
#line 82
      if (debug >= 1) {
        {
#line 82
        log_((char *)"nosigio:%m");
        }
      }
#line 83
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 85
  return (er);
}
}
#line 88 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/store.c"
static int copyart___3(int tofd , int fromfd , int fromseek , int len ) 
{ 
  char buf___28[1024] ;
  __off_t tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  {
#line 92
  tmp = lseek(fromfd, (__off_t )fromseek, 0);
  }
#line 92
  if (-1L == tmp) {
    {
#line 94
    log_((char *)"copyart:lseek:%m");
    }
#line 95
    return (-1);
  }
  {
#line 98
  while (1) {
    while_continue: /* CIL Label */ ;
#line 98
    if (! (len > 1024)) {
#line 98
      goto while_break;
    }
    {
#line 99
    tmp___0 = nosigio___3((ssize_t (*)())(& read), fromfd, buf___28, 1024);
    }
#line 99
    if (-1 == tmp___0) {
#line 100
      return (-1);
    } else {
      {
#line 99
      tmp___1 = nosigio___3((ssize_t (*)())(& write), tofd, buf___28, 1024);
      }
#line 99
      if (-1 == tmp___1) {
#line 100
        return (-1);
      }
    }
#line 98
    len -= 1024;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 101
  tmp___2 = nosigio___3((ssize_t (*)())(& read), fromfd, buf___28, len);
  }
#line 101
  if (-1 == tmp___2) {
#line 102
    return (-1);
  } else {
    {
#line 101
    tmp___3 = nosigio___3((ssize_t (*)())(& write), tofd, buf___28, len);
    }
#line 101
    if (-1 == tmp___3) {
#line 102
      return (-1);
    }
  }
#line 104
  return (0);
}
}
#line 107 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/store.c"
static int checkindex___3(struct info *p ) 
{ 


  {
#line 109
  if (p->hoffset > 0) {
#line 111
    if (p->boffset > 0) {
#line 112
      if (p->hlen > 0) {
#line 113
        if (p->blen > 0) {
#line 114
          return (0);
        }
      }
    }
  } else
#line 116
  if (-1 == p->hoffset) {
#line 116
    if (-1 == p->boffset) {
#line 117
      return (1);
    }
  }
#line 118
  return (-1);
}
}
#line 127 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/store.c"
static void reorder___3(struct storeobj *sp ) 
{ 
  char tmpname[287] ;
  char *p ;
  char *q ;
  int fd ;
  struct file f___9 ;
  int er ;
  int i ;
  char *tmp ;
  char tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char tmp___4 ;
  char *tmp___5 ;
  int *tmp___6 ;
  int tmp___7 ;
  char *p___0 ;
  int *tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  __off_t tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  __off_t tmp___17 ;
  __off_t tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;

  {
#line 133
  f___9.magic = 0;
#line 133
  f___9.info[0].hoffset = 0;
#line 133
  f___9.info[0].hlen = 0;
#line 133
  f___9.info[0].boffset = 0;
#line 133
  f___9.info[0].blen = 0;
#line 133
  f___9.info[1].hoffset = 0;
#line 133
  f___9.info[1].hlen = 0;
#line 133
  f___9.info[1].boffset = 0;
#line 133
  f___9.info[1].blen = 0;
#line 133
  f___9.info[2].hoffset = 0;
#line 133
  f___9.info[2].hlen = 0;
#line 133
  f___9.info[2].boffset = 0;
#line 133
  f___9.info[2].blen = 0;
#line 133
  f___9.info[3].hoffset = 0;
#line 133
  f___9.info[3].hlen = 0;
#line 133
  f___9.info[3].boffset = 0;
#line 133
  f___9.info[3].blen = 0;
#line 133
  f___9.info[4].hoffset = 0;
#line 133
  f___9.info[4].hlen = 0;
#line 133
  f___9.info[4].boffset = 0;
#line 133
  f___9.info[4].blen = 0;
#line 133
  f___9.info[5].hoffset = 0;
#line 133
  f___9.info[5].hlen = 0;
#line 133
  f___9.info[5].boffset = 0;
#line 133
  f___9.info[5].blen = 0;
#line 133
  f___9.info[6].hoffset = 0;
#line 133
  f___9.info[6].hlen = 0;
#line 133
  f___9.info[6].boffset = 0;
#line 133
  f___9.info[6].blen = 0;
#line 133
  f___9.info[7].hoffset = 0;
#line 133
  f___9.info[7].hlen = 0;
#line 133
  f___9.info[7].boffset = 0;
#line 133
  f___9.info[7].blen = 0;
#line 133
  f___9.info[8].hoffset = 0;
#line 133
  f___9.info[8].hlen = 0;
#line 133
  f___9.info[8].boffset = 0;
#line 133
  f___9.info[8].blen = 0;
#line 133
  f___9.info[9].hoffset = 0;
#line 133
  f___9.info[9].hlen = 0;
#line 133
  f___9.info[9].boffset = 0;
#line 133
  f___9.info[9].blen = 0;
#line 136
  p = tmpname;
#line 136
  q = sp->filename;
  {
#line 136
  while (1) {
    while_continue: /* CIL Label */ ;
#line 136
    tmp = p;
#line 136
    p ++;
#line 136
    tmp___1 = q;
#line 136
    q ++;
#line 136
    tmp___0 = *tmp___1;
#line 136
    *tmp = tmp___0;
#line 136
    if (! ((int )tmp___0 != 47)) {
#line 136
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 137
  tmp___2 = p;
#line 137
  p ++;
#line 137
  *tmp___2 = (char )'+';
  {
#line 138
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 138
    tmp___3 = p;
#line 138
    p ++;
#line 138
    tmp___5 = q;
#line 138
    q ++;
#line 138
    tmp___4 = *tmp___5;
#line 138
    *tmp___3 = tmp___4;
#line 138
    if (! tmp___4) {
#line 138
      goto while_break___0;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 139
  fd = open((char const   *)(tmpname), 194, 420);
  }
#line 140
  if (-1 == fd) {
    {
#line 142
    tmp___6 = __errno_location();
    }
#line 142
    if (17 != *tmp___6) {
      {
#line 143
      log_((char *)"reorder:open(%s):%m", tmpname);
      }
    }
#line 144
    return;
  }
  {
#line 147
  f___9.magic = 1027296;
#line 148
  tmp___7 = nosigio___3((ssize_t (*)())(& write), fd, (char *)(& f___9), (int )sizeof(f___9));
  }
#line 148
  if (-1 == tmp___7) {
#line 149
    goto fail;
  }
  {
#line 161
  tmp___9 = lockf(sp->fd, 2, (__off_t )0);
  }
#line 161
  if (-1 == tmp___9) {
    {
#line 165
    tmp___8 = __errno_location();
    }
#line 165
    if (11 != *tmp___8) {
#line 166
      p___0 = (char *)"reorder:can\'t lockf %s:%m";
    } else {
#line 168
      p___0 = (char *)"reorder:article in %s being cancelled?";
    }
    {
#line 169
    log_(p___0, sp->filename);
    }
#line 170
    goto fail;
  }
#line 173
  i = 0;
  {
#line 173
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 173
    if (! (i < 10)) {
#line 173
      goto while_break___1;
    }
    {
#line 174
    tmp___10 = checkindex___3((sp->file)->info + i);
    }
    {
#line 176
    if (tmp___10 == 0) {
#line 176
      goto case_0;
    }
#line 188
    if (tmp___10 == 1) {
#line 188
      goto case_1;
    }
#line 191
    if (tmp___10 == -1) {
#line 191
      goto case_neg_1;
    }
#line 174
    goto switch_break;
    case_0: /* CIL Label */ 
    {
#line 177
    tmp___12 = lseek(fd, (__off_t )0, 2);
#line 177
    tmp___11 = (int )tmp___12;
#line 177
    f___9.info[i].hoffset = tmp___11;
    }
#line 177
    if (tmp___11 > 0) {
      {
#line 179
      f___9.info[i].hlen = (sp->file)->info[i].hlen;
#line 180
      f___9.info[i].blen = (sp->file)->info[i].blen;
#line 181
      er = copyart___3(fd, sp->fd, (sp->file)->info[i].hoffset, f___9.info[i].hlen);
      }
#line 182
      if (0 == er) {
#line 183
        goto switch_break;
      }
    } else {
      {
#line 186
      log_((char *)"reorder:lseek(%s):%m", tmpname);
      }
    }
#line 187
    goto fail;
    case_1: /* CIL Label */ 
#line 189
    tmp___15 = -1;
#line 189
    f___9.info[i].hlen = tmp___15;
#line 189
    tmp___14 = tmp___15;
#line 189
    f___9.info[i].blen = tmp___14;
#line 189
    tmp___13 = tmp___14;
#line 189
    f___9.info[i].hoffset = tmp___13;
#line 189
    f___9.info[i].boffset = tmp___13;
#line 190
    goto switch_break;
    case_neg_1: /* CIL Label */ 
    {
#line 192
    log_((char *)"reorder:corrupt index in %s", sp->filename);
    }
#line 193
    goto fail;
    switch_break: /* CIL Label */ ;
    }
#line 173
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 195
  i = 0;
  {
#line 195
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 195
    if (! (i < 10)) {
#line 195
      goto while_break___2;
    }
#line 197
    if (-1 == f___9.info[i].boffset) {
#line 198
      goto __Cont;
    }
    {
#line 199
    tmp___17 = lseek(fd, (__off_t )0, 2);
#line 199
    tmp___16 = (int )tmp___17;
#line 199
    f___9.info[i].boffset = tmp___16;
    }
#line 199
    if (-1 == tmp___16) {
      {
#line 201
      log_((char *)"reorder:lseek(%s):%m", tmpname);
      }
#line 202
      goto fail;
    }
    {
#line 204
    er = copyart___3(fd, sp->fd, (sp->file)->info[i].boffset, f___9.info[i].blen);
    }
#line 205
    if (-1 == er) {
#line 206
      goto fail;
    }
    __Cont: /* CIL Label */ 
#line 195
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 209
  tmp___18 = lseek(fd, (__off_t )0, 0);
  }
#line 209
  if (-1L == tmp___18) {
    {
#line 211
    log_((char *)"reorder:lseek:%m");
    }
#line 212
    goto fail;
  }
  {
#line 214
  tmp___19 = nosigio___3((ssize_t (*)())(& write), fd, (char *)(& f___9), (int )sizeof(f___9));
  }
#line 214
  if (-1 == tmp___19) {
#line 215
    goto fail;
  }
  {
#line 216
  tmp___20 = rename((char const   *)(tmpname), (char const   *)sp->filename);
  }
#line 216
  if (-1 == tmp___20) {
    {
#line 218
    log_((char *)"reorder:rename:%m");
    }
#line 219
    goto fail;
  }
  {
#line 221
  close(fd);
  }
#line 222
  return;
  fail: 
  {
#line 225
  log_((char *)"reorder:write failed for %s:%m", sp->filename);
#line 226
  tmp___21 = unlink((char const   *)(tmpname));
  }
#line 226
  if (-1 == tmp___21) {
    {
#line 227
    log_((char *)"reorder:unlink(%s):%m", tmpname);
    }
  }
  {
#line 228
  close(fd);
  }
#line 229
  return;
}
}
#line 231 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/store.c"
static void sto_free___3(void *p ) 
{ 
  struct storeobj *sp ;
  int tmp ;

  {
  {
#line 233
  sp = (struct storeobj *)p;
#line 235
  close(sp->fd);
#line 236
  tmp = munmap((void *)((caddr_t )sp->file), sizeof(struct file ));
  }
#line 236
  if (-1 == tmp) {
    {
#line 237
    log_((char *)"sto_free:munmap:%m");
    }
  }
  {
#line 238
  free((void *)sp);
  }
#line 239
  return;
}
}
#line 241 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/store.c"
static int desc___15  ;
#line 304
static int tryopen___3(char *fn ) ;
#line 304 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/store.c"
static struct file f___3  =    {1027296, {{0, 0, 0, 0}}};
#line 270 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/store.c"
static int tryopen___3(char *fn ) 
{ 
  char fn2[287] ;
  int fd ;
  int i ;
  char *p ;
  char *q ;
  struct timeval tv ;
  char *tmp ;
  char tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  ssize_t tmp___7 ;

  {
  {
#line 278
  fd = open((char const   *)fn, 2);
  }
#line 278
  if (fd > -1) {
    {
#line 280
    lockf(fd, 1, (__off_t )0);
    }
#line 281
    return (fd);
  }
#line 283
  p = fn2;
#line 283
  q = fn;
  {
#line 283
  while (1) {
    while_continue: /* CIL Label */ ;
#line 283
    tmp = p;
#line 283
    p ++;
#line 283
    tmp___1 = q;
#line 283
    q ++;
#line 283
    tmp___0 = *tmp___1;
#line 283
    *tmp = tmp___0;
#line 283
    if (! ((int )tmp___0 != 47)) {
#line 283
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 284
  tmp___2 = p;
#line 284
  p ++;
#line 284
  *tmp___2 = (char )'+';
#line 285
  tmp___3 = p;
#line 285
  p ++;
#line 285
  *tmp___3 = (char )'+';
#line 286
  gettimeofday((struct timeval */* __restrict  */)(& tv), (__timezone_ptr_t )0);
#line 296
  i = (int )(tv.tv_sec / 30L);
  }
  {
#line 297
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 298
    tmp___4 = p;
#line 298
    p ++;
#line 298
    *tmp___4 = (char )(48 + i % 10);
#line 297
    i /= 10;
#line 297
    if (! i) {
#line 297
      goto while_break___0;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 300
  tmp___5 = p;
#line 300
  p ++;
#line 300
  *tmp___5 = (char )'\000';
#line 302
  i = 0;
  {
#line 302
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 302
    if (! (i < 100)) {
#line 302
      goto while_break___1;
    }
#line 306
    if (14 == i % 15) {
      {
#line 307
      log_((char *)"tryopen:racing on %s", fn);
      }
    }
    {
#line 308
    fd = open((char const   *)(fn2), 194, 420);
    }
#line 308
    if (fd > -1) {
      {
#line 310
      lockf(fd, 1, (__off_t )0);
#line 311
      tmp___7 = write(fd, (void const   *)((char *)(& f___3)), sizeof(f___3));
      }
#line 311
      if (sizeof(f___3) == (unsigned long )tmp___7) {
        {
#line 312
        tmp___6 = link((char const   *)(fn2), (char const   *)fn);
        }
#line 312
        if (0 == tmp___6) {
          {
#line 314
          unlink((char const   *)(fn2));
          }
#line 315
          return (fd);
        }
      }
      {
#line 317
      close(fd);
#line 318
      unlink((char const   *)(fn2));
      }
    }
    {
#line 321
    fd = open((char const   *)fn, 2);
    }
#line 321
    if (fd > -1) {
      {
#line 323
      lockf(fd, 1, (__off_t )0);
      }
#line 324
      return (fd);
    }
    {
#line 302
    nap(0, 300 + i);
#line 302
    i ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 327
  log_((char *)"tryopen:timed out opening %s:%m", fn);
  }
#line 328
  return (-1);
}
}
#line 337 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/store.c"
static struct storeobj *getstore___3(char *filename ) 
{ 
  struct storeobj *sp ;
  struct storeobj s ;
  int fd ;
  struct file *fp ;
  char buf___28[287] ;
  int c ;
  void *tmp ;
  void *tmp___0 ;
  char *p ;
  char *q ;
  char *tmp___1 ;
  char tmp___2 ;
  char *tmp___3 ;
  char *end ;
  unsigned long tmp___4 ;
  ssize_t tmp___5 ;
  size_t tmp___6 ;
  void *tmp___7 ;

  {
  {
#line 349
  s.filename = filename;
#line 350
  tmp = cache_find(desc___15, (void *)(& s));
#line 350
  sp = (struct storeobj *)tmp;
  }
#line 350
  if (sp) {
    {
#line 352
    lockf(sp->fd, 1, (__off_t )0);
    }
#line 353
    return (sp);
  }
  {
#line 356
  fd = tryopen___3(filename);
  }
#line 356
  if (-1 == fd) {
#line 357
    return ((struct storeobj *)0);
  }
  {
#line 361
  tmp___0 = mmap((void *)0, sizeof(*fp), 3, 1, fd, (__off_t )0);
#line 361
  fp = (struct file *)tmp___0;
  }
#line 362
  if (! fp) {
    {
#line 363
    log_((char *)"getstore:mmap(%s):%m", filename);
    }
  } else
#line 362
  if ((unsigned long )fp == (unsigned long )((void *)-1)) {
    {
#line 363
    log_((char *)"getstore:mmap(%s):%m", filename);
    }
  } else {
    {
#line 364
    tmp___6 = strlen((char const   *)filename);
#line 364
    tmp___7 = malloc((sizeof(*sp) + tmp___6) + 1UL);
#line 364
    sp = (struct storeobj *)tmp___7;
    }
#line 364
    if (sp) {
      {
#line 371
      sp->fd = fd;
#line 372
      sp->file = fp;
#line 373
      sp->filename = (char *)sp + sizeof(*sp);
#line 374
      strcpy((char */* __restrict  */)sp->filename, (char const   */* __restrict  */)filename);
#line 380
      p = buf___28;
#line 380
      q = filename;
      }
      {
#line 380
      while (1) {
        while_continue: /* CIL Label */ ;
#line 380
        tmp___1 = p;
#line 380
        p ++;
#line 380
        tmp___3 = q;
#line 380
        q ++;
#line 380
        tmp___2 = *tmp___3;
#line 380
        *tmp___1 = tmp___2;
#line 380
        if (! ((int )tmp___2 != 47)) {
#line 380
          goto while_break;
        }
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 381
      strcpy((char */* __restrict  */)p, (char const   */* __restrict  */)".compress");
#line 383
      fd = open((char const   *)(buf___28), 0);
      }
#line 383
      if (fd > -1) {
        {
#line 385
        sp->compressok = 1024;
#line 386
        tmp___5 = read(fd, (void *)(buf___28), sizeof(buf___28) - 1UL);
#line 386
        c = (int )tmp___5;
        }
#line 386
        if (c > 0) {
          {
#line 390
          buf___28[c] = (char )'\000';
#line 391
          tmp___4 = strtoul((char const   */* __restrict  */)(buf___28), (char **/* __restrict  */)(& end),
                            10);
#line 391
          c = (int )tmp___4;
          }
#line 392
          if (c > 1024) {
#line 392
            if (10 == (int )*end) {
#line 393
              sp->compressok = c;
            }
          }
        }
        {
#line 395
        close(fd);
        }
      } else {
#line 399
        sp->compressok = 0;
      }
      {
#line 400
      cache_insert(desc___15, (void *)sp);
      }
#line 401
      return (sp);
    } else {
      {
#line 366
      log_((char *)"getstore:no memory");
#line 367
      munmap((void *)fp, sizeof(*fp));
      }
    }
  }
  {
#line 403
  close(fd);
  }
#line 404
  return ((struct storeobj *)0);
}
}
#line 37 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/group.c"
static int desc___16  =    -1;
#line 59 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/group.c"
static int cmpgroup___5(void *a , void *b___13 ) 
{ 
  struct groupobj *x ;
  struct groupobj *y ;
  int tmp ;

  {
  {
#line 61
  x = (struct groupobj *)a;
#line 62
  y = (struct groupobj *)b___13;
#line 64
  tmp = strcmp((char const   *)x->groupname, (char const   *)y->groupname);
  }
#line 64
  return (tmp);
}
}
#line 67 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/group.c"
static void freegroup___5(void *p ) 
{ 
  struct groupobj *gop ;

  {
#line 69
  gop = (struct groupobj *)p;
#line 71
  if (gop->groupname) {
    {
#line 72
    free((void *)gop->groupname);
    }
  }
#line 73
  if (gop->dir.dir) {
    {
#line 74
    closedir(gop->dir.dir);
    }
  }
#line 75
  if (gop->lastf.f) {
    {
#line 76
    munmap((void *)((caddr_t )gop->lastf.f), sizeof(struct file ));
    }
  }
  {
#line 77
  free(p);
  }
#line 78
  return;
}
}
#line 94 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/group.c"
static int refresh___5(struct groupobj *gop , char *groupname ) 
{ 
  struct stat st ;
  struct dir *d ;
  struct lastf *lp ;
  bool needreread ;
  bool needrefile ;
  bool needreslot ;
  bool isemptygroup ;
  int tmp ;
  int tmp___0 ;
  struct dirent *dp ;
  int i ;
  int first ;
  int last___1 ;
  char *end ;
  int tmp___1 ;
  unsigned short const   **tmp___2 ;
  unsigned long tmp___3 ;
  int fd ;
  void *tmp___4 ;
  struct info *ip ;
  int slot ;

  {
#line 99
  needreread = (bool )0;
#line 100
  needrefile = (bool )0;
#line 101
  needreslot = (bool )0;
#line 102
  isemptygroup = (bool )0;
#line 104
  d = & gop->dir;
#line 105
  lp = & gop->lastf;
#line 107
  if (groupname) {
    {
#line 109
    memset((void *)gop, 0, sizeof(struct groupobj ));
#line 110
    gop->groupname = strdup((char const   *)groupname);
    }
#line 111
    if ((unsigned long )((void *)0) == (unsigned long )gop->groupname) {
      {
#line 113
      log_((char *)"refresh:strdup:%m");
      }
#line 114
      return (-1);
    }
    {
#line 116
    gop->dir.first = -1;
#line 117
    d->dir = opendir((char const   *)groupname);
    }
#line 118
    if ((unsigned long )((void *)0) == (unsigned long )d->dir) {
      {
#line 120
      log_((char *)"refresh:opendir:%m");
      }
#line 121
      return (-1);
    }
#line 123
    lp->name = -1;
#line 125
    needreslot = (bool )1;
#line 125
    needreread = needreslot;
#line 125
    needrefile = needreread;
  } else {
#line 131
    if (-1 == d->first) {
#line 132
      needreread = (bool )1;
    } else
#line 131
    if (0 == d->last) {
#line 132
      needreread = (bool )1;
    } else
#line 131
    if (! d->read) {
#line 132
      needreread = (bool )1;
    } else {
      {
#line 133
      tmp = dirfd(d->dir);
#line 133
      tmp___0 = fstat(tmp, & st);
      }
#line 133
      if (-1 == tmp___0) {
        {
#line 135
        log_((char *)"refresh:fstat:%m");
        }
#line 136
        return (-1);
      } else
#line 138
      if (d->read < st.st_mtim.tv_sec) {
#line 139
        needreread = (bool )1;
      }
    }
#line 140
    if (! lp->f) {
#line 141
      needreslot = (bool )1;
#line 141
      needrefile = needreslot;
    }
#line 142
    if (! needrefile) {
#line 143
      if (! lp->f) {
#line 144
        needrefile = (bool )1;
      }
    }
#line 145
    if (! needrefile) {
#line 146
      if (-1 == lp->name) {
#line 147
        needrefile = (bool )1;
      }
    }
  }
#line 150
  if (needreread) {
#line 150
    goto _L;
  } else
#line 150
  if (needreslot) {
    _L: /* CIL Label */ 
    {
#line 156
    first = -1;
#line 157
    last___1 = 0;
#line 158
    rewinddir(d->dir);
#line 159
    dp = readdir(d->dir);
    }
#line 160
    if ((unsigned long )((void *)0) == (unsigned long )dp) {
      {
#line 162
      log_((char *)"refresh:readdir:%m");
      }
#line 163
      return (-1);
    }
#line 165
    gop->nopost = (bool )0;
    {
#line 166
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 168
      tmp___2 = __ctype_b_loc();
      }
#line 168
      if (! ((int const   )*(*tmp___2 + (int )dp->d_name[0]) & 2048)) {
#line 170
        if (! gop->nopost) {
#line 170
          if (46 == (int )dp->d_name[0]) {
            {
#line 171
            tmp___1 = strcmp((char const   *)(dp->d_name), ".nopost");
            }
#line 171
            if (0 == tmp___1) {
#line 172
              gop->nopost = (bool )1;
            }
          }
        }
#line 173
        goto __Cont;
      }
      {
#line 175
      tmp___3 = strtoul((char const   */* __restrict  */)(dp->d_name), (char **/* __restrict  */)(& end),
                        10);
#line 175
      i = (int )tmp___3;
      }
#line 175
      if (i <= 0) {
#line 176
        goto __Cont;
      } else
#line 175
      if (*end) {
#line 176
        goto __Cont;
      }
#line 177
      if (first > i) {
#line 178
        first = i;
      } else
#line 177
      if (-1 == first) {
#line 178
        first = i;
      }
#line 179
      if (last___1 < i) {
#line 180
        last___1 = i;
      }
      __Cont: /* CIL Label */ 
      {
#line 166
      dp = readdir(d->dir);
      }
#line 166
      if (! dp) {
#line 166
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 183
    d->first = first;
#line 184
    d->last = last___1;
#line 185
    if (-1 == first) {
#line 185
      if (0 == last___1) {
#line 186
        isemptygroup = (bool )1;
      }
    }
#line 187
    if (last___1 != lp->name) {
#line 188
      needrefile = (bool )1;
    } else {
#line 190
      lp->name = last___1;
    }
    {
#line 191
    time(& d->read);
    }
  }
#line 194
  if (needrefile) {
#line 194
    goto _L___0;
  } else
#line 194
  if (needreslot) {
    _L___0: /* CIL Label */ 
#line 198
    if (lp->f) {
      {
#line 200
      munmap((void *)((caddr_t )lp->f), sizeof(struct file ));
#line 201
      lp->f = (struct file *)((void *)0);
      }
    }
#line 203
    if (isemptygroup) {
#line 204
      return (0);
    }
    {
#line 205
    fd = openf(0, 0, (char *)"%s/%d", gop->groupname, d->last);
    }
#line 206
    if (-1 == fd) {
      {
#line 208
      log_((char *)"refresh:open:%m");
      }
#line 209
      return (-1);
    }
    {
#line 211
    tmp___4 = mmap((void *)0, sizeof(struct file ), 1, 1, fd, (__off_t )0);
#line 211
    lp->f = (struct file *)tmp___4;
#line 212
    close(fd);
    }
#line 213
    if ((unsigned long )lp->f == (unsigned long )((void *)-1)) {
      {
#line 215
      log_((char *)"refresh:mmap:%m");
      }
#line 216
      return (-1);
    }
#line 218
    lp->slotsfilled = 0;
#line 219
    needreslot = (bool )1;
  }
#line 222
  if (needreslot) {
#line 224
    ip = (lp->f)->info;
#line 227
    slot = 9;
    {
#line 227
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 227
      if (! (slot > -1)) {
#line 227
        goto while_break___0;
      }
#line 228
      if ((ip + slot)->hoffset) {
#line 229
        goto while_break___0;
      }
#line 227
      slot --;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 230
    lp->slotsfilled = slot + 1;
  }
#line 233
  return (0);
}
}
#line 33 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/art.c"
static size_t pagesize___17  =    (size_t )0;
#line 80 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/art.c"
static void file_unmap___5(void *p ) 
{ 
  struct fileobj *fp ;

  {
  {
#line 82
  fp = (struct fileobj *)p;
#line 84
  munmap((void *)fp->map, (size_t )fp->size);
#line 85
  free((void *)fp);
  }
#line 86
  return;
}
}
#line 88 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/art.c"
static int file_cmp___5(void *a , void *b___13 ) 
{ 
  struct fileobj *x ;
  struct fileobj *y ;
  int tmp ;

  {
  {
#line 90
  x = (struct fileobj *)a;
#line 91
  y = (struct fileobj *)b___13;
#line 93
  tmp = strcmp((char const   *)x->path, (char const   *)y->path);
  }
#line 93
  return (tmp);
}
}
#line 96 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/art.c"
static int desc___17  =    -1;
#line 98 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/art.c"
static int file_init___5(void) 
{ 


  {
  {
#line 100
  desc___17 = cache_init(8, & file_cmp___5, & file_unmap___5, (int (*)(void * ))((void *)0));
  }
#line 101
  if (-1 == desc___17) {
    {
#line 103
    log_((char *)"file_init:%m");
    }
#line 104
    return (-1);
  }
#line 106
  return (0);
}
}
#line 109 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/art.c"
static struct file *file_gimme___5(char *name , int *size___1 ) 
{ 
  struct fileobj f___9 ;
  struct fileobj *fp ;
  void *tmp ;

  {
  {
#line 111
  f___9.path = (char *)0;
#line 111
  f___9.map = (char *)0;
#line 111
  f___9.size = 0;
#line 114
  f___9.path = name;
#line 116
  tmp = cache_find(desc___17, (void *)(& f___9));
#line 116
  fp = (struct fileobj *)tmp;
  }
#line 116
  if ((unsigned long )((void *)0) == (unsigned long )fp) {
    {
#line 118
    fp = file_map(name);
    }
#line 118
    if ((unsigned long )((void *)0) == (unsigned long )fp) {
#line 119
      return ((struct file *)((void *)0));
    } else {
      {
#line 121
      cache_insert(desc___17, (void *)fp);
      }
    }
  }
#line 124
  if (size___1) {
#line 125
    *size___1 = fp->size;
  }
#line 126
  return ((struct file *)fp->map);
}
}
#line 137 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/art.c"
static bool file_initialized___5  =    (bool )0;
#line 248 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/art.c"
static char ngroup___5[287]  ;
#line 297 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/art.c"
static int getfield___5(char *buf___28 , struct field *f___9 ) 
{ 
  register char *cp ;
  size_t tmp ;
  size_t tmp___0 ;

  {
  {
#line 299
  cp = buf___28;
#line 301
  tmp = strspn((char const   *)cp, " \t\f");
#line 301
  cp += tmp;
  }
#line 302
  if (! *cp) {
#line 304
    f___9->pointer = (char *)((void *)0);
#line 305
    return (0);
  }
  {
#line 307
  tmp___0 = strcspn((char const   *)cp, "\r\n");
#line 307
  f___9->len = (int )tmp___0;
  }
#line 308
  if (! f___9->len) {
#line 309
    return (0);
  }
#line 310
  f___9->pointer = cp;
#line 311
  return ((int )((cp + f___9->len) - buf___28));
}
}
#line 383 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/art.c"
static struct b b___6  =    {(char *)0, 0, 0};
#line 105 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/dh_find.c"
static int initfile___11(void) 
{ 
  int fd ;
  int integer ;
  int i ;
  char foo[3] ;
  unsigned int tmp ;
  int *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  ssize_t tmp___3 ;
  ssize_t tmp___4 ;

  {
#line 108
  integer = 218885376;
#line 110
  foo[0] = (char )'\000';
#line 110
  tmp = 1U;
  {
#line 110
  while (1) {
    while_continue: /* CIL Label */ ;
#line 110
    if (tmp >= 3U) {
#line 110
      goto while_break;
    }
#line 110
    foo[tmp] = (char)0;
#line 110
    tmp ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 112
  fd = open((char const   *)(dh_tablefile), 194, 420);
  }
#line 113
  if (fd == -1) {
#line 114
    return (-1);
  }
  {
#line 115
  tmp___2 = lockf(fd, 2, (__off_t )0);
  }
#line 115
  if (tmp___2 == -1) {
    {
#line 117
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 119
      tmp___0 = __errno_location();
      }
#line 119
      if (*tmp___0 == 11) {
        {
#line 120
        nap(0, 200);
        }
      } else {
#line 122
        goto fail;
      }
      {
#line 117
      tmp___1 = lockf(fd, 2, (__off_t )0);
      }
#line 117
      if (! (tmp___1 == -1)) {
#line 117
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 125
    lockf(fd, 0, (__off_t )0);
    }
#line 126
    return (fd);
  }
  {
#line 128
  tmp___3 = write(fd, (void const   *)(& integer), sizeof(int ));
  }
#line 128
  if ((unsigned long )tmp___3 != sizeof(int )) {
#line 129
    goto fail;
  }
#line 130
  i = 0;
  {
#line 130
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 130
    if (! (i < 10240)) {
#line 130
      goto while_break___1;
    }
    {
#line 131
    tmp___4 = write(fd, (void const   *)(foo), sizeof(foo));
    }
#line 131
    if ((unsigned long )tmp___4 != sizeof(foo)) {
#line 132
      goto fail;
    }
#line 130
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 133
  lseek(fd, (__off_t )0, 0);
#line 134
  lockf(fd, 0, (__off_t )0);
  }
#line 135
  return (fd);
  fail: 
#line 138
  if (fd > -1) {
    {
#line 139
    close(fd);
    }
  }
#line 140
  return (-1);
}
}
#line 78 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/allocate.c"
static struct table___1 table___6  =    {(char *)0, (char *)0, 0, 0, 0, 0};
#line 80
static int remapfile___5(void) ;
#line 106 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/allocate.c"
static int initfile___12(char *filename ) 
{ 
  struct chainfile cf ;
  int fd ;
  int i ;
  int ret ;
  ssize_t tmp ;
  int pad ;
  ssize_t tmp___0 ;

  {
  {
#line 108
  cf.chain_magic = 0;
#line 108
  cf.next[0] = 0;
#line 108
  cf.next[1] = 0;
#line 108
  cf.next[2] = 0;
#line 108
  cf.next[3] = 0;
#line 108
  cf.next[4] = 0;
#line 108
  cf.next[5] = 0;
#line 108
  cf.next[6] = 0;
#line 108
  cf.next[7] = 0;
#line 108
  cf.next[8] = 0;
#line 108
  cf.next[9] = 0;
#line 108
  cf.next[10] = 0;
#line 108
  cf.next[11] = 0;
#line 108
  cf.next[12] = 0;
#line 108
  cf.next[13] = 0;
#line 108
  cf.next[14] = 0;
#line 108
  cf.next[15] = 0;
#line 108
  cf.next[16] = 0;
#line 108
  cf.next[17] = 0;
#line 108
  cf.next[18] = 0;
#line 108
  cf.next[19] = 0;
#line 108
  cf.next[20] = 0;
#line 108
  cf.next[21] = 0;
#line 108
  cf.next[22] = 0;
#line 108
  cf.next[23] = 0;
#line 108
  cf.next[24] = 0;
#line 108
  cf.next[25] = 0;
#line 108
  cf.next[26] = 0;
#line 108
  cf.next[27] = 0;
#line 108
  cf.next[28] = 0;
#line 108
  cf.next[29] = 0;
#line 108
  cf.next[30] = 0;
#line 108
  cf.next[31] = 0;
#line 108
  cf.next[32] = 0;
#line 108
  cf.next[33] = 0;
#line 108
  cf.next[34] = 0;
#line 108
  cf.next[35] = 0;
#line 108
  cf.next[36] = 0;
#line 108
  cf.next[37] = 0;
#line 108
  cf.next[38] = 0;
#line 108
  cf.next[39] = 0;
#line 108
  cf.next[40] = 0;
#line 108
  cf.next[41] = 0;
#line 108
  cf.next[42] = 0;
#line 108
  cf.next[43] = 0;
#line 108
  cf.next[44] = 0;
#line 108
  cf.next[45] = 0;
#line 108
  cf.next[46] = 0;
#line 108
  cf.next[47] = 0;
#line 108
  cf.next[48] = 0;
#line 108
  cf.next[49] = 0;
#line 108
  cf.next[50] = 0;
#line 108
  cf.next[51] = 0;
#line 108
  cf.next[52] = 0;
#line 108
  cf.next[53] = 0;
#line 108
  cf.next[54] = 0;
#line 108
  cf.next[55] = 0;
#line 108
  cf.next[56] = 0;
#line 108
  cf.next[57] = 0;
#line 108
  cf.next[58] = 0;
#line 108
  cf.next[59] = 0;
#line 108
  cf.next[60] = 0;
#line 108
  cf.next[61] = 0;
#line 108
  cf.next[62] = 0;
#line 111
  ret = 0;
#line 113
  fd = open((char const   *)filename, 578, 420);
  }
#line 114
  if (-1 == fd) {
#line 115
    return (-1);
  }
#line 116
  cf.chain_magic = 13680336;
#line 117
  i = 0;
  {
#line 117
  while (1) {
    while_continue: /* CIL Label */ ;
#line 117
    if (! (i < 63)) {
#line 117
      goto while_break;
    }
#line 118
    cf.next[i] = (int volatile   )0;
#line 117
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 119
  tmp = write(fd, (void const   *)(& cf), sizeof(cf));
#line 119
  i = (int )tmp;
  }
#line 120
  if ((unsigned long )i == sizeof(cf)) {
#line 124
    pad = (int )(sizeof(cf) % 4UL);
#line 125
    if (pad > 0) {
#line 126
      i = 0;
      {
#line 126
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 126
        if (i < pad) {
#line 126
          if (! (0 == ret)) {
#line 126
            goto while_break___0;
          }
        } else {
#line 126
          goto while_break___0;
        }
        {
#line 127
        tmp___0 = write(fd, (void const   *)"", (size_t )1);
        }
#line 127
        if (1L != tmp___0) {
#line 128
          ret = -1;
        }
#line 126
        i ++;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
  } else {
#line 131
    ret = -1;
  }
  {
#line 132
  close(fd);
  }
#line 133
  return (ret);
}
}
#line 136 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/allocate.c"
static void unmapfile___5(void) 
{ 


  {
#line 138
  if (table___6.fd >= 0) {
    {
#line 140
    close(table___6.fd);
#line 141
    table___6.fd = -1;
    }
  }
#line 143
  if (table___6.map) {
    {
#line 145
    munmap((void *)table___6.map, (size_t )table___6.size);
#line 146
    table___6.map = (char *)((void *)0);
#line 147
    table___6.size = 0;
    }
  }
#line 149
  return;
}
}
#line 153
static size_t rounduptopagesize___5(size_t size___1 ) ;
#line 153 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/allocate.c"
static size_t pagesize___18  =    (size_t )0;
#line 151 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/allocate.c"
static size_t rounduptopagesize___5(size_t size___1 ) 
{ 
  int pages ;
  int tmp ;

  {
#line 156
  if (0UL == pagesize___18) {
    {
#line 157
    tmp = getpagesize();
#line 157
    pagesize___18 = (size_t )tmp;
    }
  }
#line 158
  pages = (int )(size___1 / pagesize___18 + 1UL);
#line 159
  return ((size_t )pages * pagesize___18);
}
}
#line 162 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/allocate.c"
static int mapfile___5(void) 
{ 
  struct stat st ;
  int tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;

  {
#line 166
  if (-1 == table___6.fd) {
    {
#line 167
    table___6.fd = open((char const   *)table___6.filename, table___6.oflag, 420);
    }
  }
#line 168
  if (-1 == table___6.fd) {
#line 169
    goto fail;
  }
  {
#line 171
  tmp = fstat(table___6.fd, & st);
  }
#line 171
  if (-1 == tmp) {
#line 172
    goto fail;
  }
  {
#line 173
  tmp___0 = rounduptopagesize___5((size_t )st.st_size);
#line 173
  table___6.size = (int )tmp___0;
#line 174
  tmp___1 = mmap((void *)0, (size_t )table___6.size, table___6.mprot, 1, table___6.fd,
                 (__off_t )0);
#line 174
  table___6.map = (char *)tmp___1;
  }
#line 175
  if (! table___6.map) {
#line 176
    goto fail;
  } else
#line 175
  if ((unsigned long )table___6.map == (unsigned long )((void *)-1)) {
#line 176
    goto fail;
  }
#line 178
  return (0);
  fail: 
  {
#line 181
  unmapfile___5();
  }
#line 182
  return (-1);
}
}
#line 189 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/allocate.c"
static int remapfile___5(void) 
{ 
  struct stat st ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 193
  tmp = fstat(table___6.fd, & st);
  }
#line 193
  if (-1 == tmp) {
#line 194
    return (-1);
  }
#line 196
  if (st.st_size <= (__off_t )table___6.size) {
#line 197
    return (0);
  }
  {
#line 199
  munmap((void *)table___6.map, (size_t )table___6.size);
#line 200
  tmp___0 = mapfile___5();
  }
#line 200
  return (tmp___0);
}
}
#line 209 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/allocate.c"
static int lock___5(void) 
{ 
  int *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 211
  tmp___2 = lockf(table___6.fd, 2, (__off_t )0);
  }
#line 211
  if (-1 == tmp___2) {
    {
#line 213
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 215
      tmp = __errno_location();
      }
#line 215
      if (11 != *tmp) {
#line 216
        return (-1);
      } else {
        {
#line 218
        nap(0, 200);
        }
      }
      {
#line 213
      tmp___0 = lockf(table___6.fd, 2, (__off_t )0);
      }
#line 213
      if (! (-1 == tmp___0)) {
#line 213
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 221
    tmp___1 = remapfile___5();
    }
#line 221
    if (-1 == tmp___1) {
#line 222
      return (-1);
    }
  }
#line 224
  return (0);
}
}
#line 227 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/allocate.c"
static void unlock___5(void) 
{ 


  {
  {
#line 229
  lseek(table___6.fd, (__off_t )0, 0);
#line 230
  lockf(table___6.fd, 0, (__off_t )0);
  }
#line 231
  return;
}
}
#line 233 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/allocate.c"
static int checkvalidfile___5(void) 
{ 


  {
#line 235
  if (table___6.size > 0) {
#line 237
    if ((unsigned long )table___6.size < sizeof(struct chainfile )) {
#line 238
      return (-1);
    }
#line 239
    if (((struct chainfile *)table___6.map)->chain_magic != 13680336) {
#line 240
      return (-1);
    }
  }
#line 242
  return (0);
}
}
#line 281 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/allocate.c"
static int rounduptoalignment___5(int size___1 ) 
{ 


  {
#line 283
  if (size___1 <= 0) {
#line 284
    return (4);
  }
#line 285
  return (((size___1 - 1) / 4 + 1) * 4);
}
}
#line 296 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/allocate.c"
static char tmpchunk___5[272]  = {      (char )'\000'};
#line 56 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/dhash.c"
static unsigned char buf___14[2]  ;
#line 54 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/dhash.c"
static char *inttochar2___5(int integer ) 
{ 


  {
#line 58
  buf___14[0] = (unsigned char )((integer & 65535) >> 8);
#line 59
  buf___14[1] = (unsigned char )(integer & 255);
#line 60
  return ((char *)(buf___14));
}
}
#line 65 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/dhash.c"
static unsigned char buf___15[3]  ;
#line 63 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/dhash.c"
static char *inttochar3___5(unsigned int integer ) 
{ 


  {
#line 67
  integer >>= 2;
#line 68
  buf___15[0] = (unsigned char )((integer & 16777215U) >> 16);
#line 69
  buf___15[1] = (unsigned char )((integer & 65535U) >> 8);
#line 70
  buf___15[2] = (unsigned char )(integer & 255U);
#line 71
  return ((char *)(buf___15));
}
}
#line 35 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/newsgroup.c"
static struct ng *bygroup___5[128]  ;
#line 36 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/newsgroup.c"
static struct ng *byident___5[128]  ;
#line 37 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/newsgroup.c"
static int highest___5  =    0;
#line 39 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/newsgroup.c"
static unsigned int hash___11(char *buf___28 , int len ) 
{ 
  unsigned int h ;
  char *tmp ;

  {
#line 43
  h = 5381U;
  {
#line 44
  while (1) {
    while_continue: /* CIL Label */ ;
#line 44
    if (! len) {
#line 44
      goto while_break;
    }
#line 46
    len --;
#line 47
    h += h << 5;
#line 48
    tmp = buf___28;
#line 48
    buf___28 ++;
#line 48
    h ^= (unsigned int )*tmp;
  }
  while_break: /* CIL Label */ ;
  }
#line 50
  return (h);
}
}
#line 53 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/newsgroup.c"
static struct chunk *chunks___5  ;
#line 58 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/newsgroup.c"
static int avail___11  =    0;
#line 59 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/newsgroup.c"
static int nr___6  =    0;
#line 64 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/newsgroup.c"
static int add___6(int ident , char *group , int len ) 
{ 
  struct ng *np ;
  struct ng *p ;
  int want ;
  unsigned int h ;
  struct chunk *tmp ;
  int size___1 ;
  void *tmp___0 ;
  unsigned int tmp___1 ;
  int tmp___2 ;

  {
#line 71
  len ++;
#line 72
  want = (int )(((unsigned long )len + sizeof(struct ng )) + sizeof(char *));
#line 73
  want = (int )((unsigned long )want - (unsigned long )len % sizeof(char *));
#line 74
  len --;
#line 76
  if (avail___11 < want) {
#line 81
    if (want > 240) {
#line 81
      size___1 = want + 240;
    } else {
#line 81
      size___1 = 240;
    }
    {
#line 82
    tmp___0 = malloc((size_t )size___1);
#line 82
    tmp = (struct chunk *)tmp___0;
    }
#line 82
    if (! tmp) {
#line 83
      return (-1);
    }
#line 84
    tmp->next = chunks___5;
#line 85
    chunks___5 = tmp;
#line 86
    chunks___5->buf = (char *)chunks___5 + sizeof(struct chunk );
#line 87
    avail___11 = (int )((unsigned long )size___1 - sizeof(struct chunk ));
  }
  {
#line 89
  np = (struct ng *)chunks___5->buf;
#line 90
  chunks___5->buf += want;
#line 91
  avail___11 -= want;
#line 92
  strncpy((char */* __restrict  */)(np->group), (char const   */* __restrict  */)group,
          (size_t )len);
#line 93
  np->group[len] = (char )'\000';
#line 94
  np->ident = ident;
#line 96
  tmp___1 = hash___11(group, len);
#line 96
  h = tmp___1 % 128U;
#line 97
  np->gnext = bygroup___5[h];
#line 98
  bygroup___5[h] = np;
#line 99
  p = np->gnext;
  }
  {
#line 99
  while (1) {
    while_continue: /* CIL Label */ ;
#line 99
    if (! p) {
#line 99
      goto while_break;
    }
    {
#line 100
    tmp___2 = strcmp((char const   *)(p->group), (char const   *)group);
    }
#line 100
    if (0 == tmp___2) {
#line 101
      return (1);
    }
#line 99
    p = p->gnext;
  }
  while_break: /* CIL Label */ ;
  }
#line 102
  h = (unsigned int )(ident % 128);
#line 103
  np->inext = byident___5[h];
#line 104
  byident___5[h] = np;
#line 105
  p = np->inext;
  {
#line 105
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 105
    if (! p) {
#line 105
      goto while_break___0;
    }
#line 106
    if (p->ident == ident) {
#line 107
      return (1);
    }
#line 105
    p = p->inext;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 109
  if (ident > highest___5) {
#line 110
    highest___5 = ident;
  }
#line 111
  nr___6 ++;
#line 112
  return (0);
}
}
#line 116 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/newsgroup.c"
static int groupfd___5  =    -1;
#line 117 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/newsgroup.c"
static int oldsize___5  =    0;
#line 118 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/newsgroup.c"
static int mapsize___5  =    0;
#line 119 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/newsgroup.c"
static char *mapbuf___5  =    (char *)((void *)0);
#line 148
static int reload___5(void) ;
#line 148 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/newsgroup.c"
static int pagesize___19  =    0;
#line 145 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/newsgroup.c"
static int reload___5(void) 
{ 
  struct stat st ;
  int newsize ;
  int tmp ;
  void *tmp___0 ;
  char *p ;
  char *lim ;
  char *ip ;
  char *gr ;
  int ident ;
  int state ;
  int tmp___1 ;

  {
  {
#line 156
  tmp = fstat(groupfd___5, & st);
  }
#line 156
  if (-1 == tmp) {
    {
#line 158
    log_((char *)"reload:fstat:%m");
    }
#line 159
    return (-1);
  }
#line 161
  newsize = (int )st.st_size;
#line 162
  if (! pagesize___19) {
    {
#line 163
    pagesize___19 = getpagesize();
    }
  }
#line 164
  if (newsize <= oldsize___5) {
#line 165
    return (0);
  }
#line 166
  if (newsize > mapsize___5) {
#line 166
    goto _L;
  } else
#line 166
  if (! mapsize___5) {
    _L: /* CIL Label */ 
#line 168
    if (mapbuf___5) {
      {
#line 169
      munmap((void *)mapbuf___5, (size_t )mapsize___5);
      }
    }
    {
#line 170
    mapsize___5 = (int )((st.st_size + (__off_t )pagesize___19) - st.st_size % (long )pagesize___19);
#line 171
    tmp___0 = mmap((void *)0, (size_t )mapsize___5, 1, 1, groupfd___5, (__off_t )0);
#line 171
    mapbuf___5 = (char *)tmp___0;
    }
#line 172
    if (! mapbuf___5) {
      {
#line 174
      log_((char *)"reload:mmap:%m");
      }
#line 175
      return (-1);
    } else
#line 172
    if ((unsigned long )mapbuf___5 == (unsigned long )((void *)-1)) {
      {
#line 174
      log_((char *)"reload:mmap:%m");
      }
#line 175
      return (-1);
    }
  }
#line 188
  lim = mapbuf___5 + newsize;
#line 189
  state = 0;
#line 189
  ident = state;
#line 190
  gr = (char *)0;
#line 190
  ip = gr;
#line 191
  p = mapbuf___5 + oldsize___5;
  {
#line 191
  while (1) {
    while_continue: /* CIL Label */ ;
#line 191
    if (! ((unsigned long )p < (unsigned long )lim)) {
#line 191
      goto while_break;
    }
    {
#line 194
    if (state == 0) {
#line 194
      goto case_0;
    }
#line 195
    if (state == 1) {
#line 195
      goto case_1;
    }
#line 196
    if (state == 2) {
#line 196
      goto case_2;
    }
#line 197
    if (state == 3) {
#line 197
      goto case_3;
    }
#line 192
    goto switch_break;
    case_0: /* CIL Label */ 
#line 194
    if ((int )*p >= 48) {
#line 194
      if ((int )*p <= 57) {
#line 194
        ip = p;
#line 194
        state ++;
      }
    }
#line 194
    goto switch_break;
    case_1: /* CIL Label */ 
#line 195
    if (32 == (int )*p) {
      {
#line 195
      ident = atoi((char const   *)ip);
#line 195
      state ++;
      }
    }
#line 195
    goto switch_break;
    case_2: /* CIL Label */ 
#line 196
    if (32 != (int )*p) {
#line 196
      gr = p;
#line 196
      state ++;
    }
#line 196
    goto switch_break;
    case_3: /* CIL Label */ 
#line 198
    if (10 != (int )*p) {
#line 199
      goto switch_break;
    }
    {
#line 200
    tmp___1 = add___6(ident, gr, (int )(p - gr));
    }
#line 200
    if (-1 == tmp___1) {
      {
#line 202
      log_((char *)"reload:no memory");
      }
#line 203
      return (-1);
    }
#line 205
    state = 0;
    switch_break: /* CIL Label */ ;
    }
#line 191
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 208
  oldsize___5 = newsize;
#line 209
  return (0);
}
}
#line 26 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/key.c"
static struct buf *head___6  ;
#line 27 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/key.c"
static int avail___12  =    0;
#line 28 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/key.c"
static char *keybuf___5  =    (char *)((void *)0);
#line 33 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/key.c"
static unsigned int hv___5  ;
#line 35 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/key.c"
static void hash___12(char *key , int len ) 
{ 
  char *tmp ;

  {
#line 37
  hv___5 = 5381U;
  {
#line 38
  while (1) {
    while_continue: /* CIL Label */ ;
#line 38
    if (! len) {
#line 38
      goto while_break;
    }
#line 40
    len --;
#line 41
    hv___5 += hv___5 << 5;
#line 42
    tmp = key;
#line 42
    key ++;
#line 42
    hv___5 ^= (unsigned int )*tmp;
  }
  while_break: /* CIL Label */ ;
  }
#line 44
  hv___5 %= 128U;
#line 45
  return;
}
}
#line 164 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) double ( __attribute__((__nonnull__(1), __leaf__)) strtod)(char const   * __restrict  __nptr ,
                                                                                                char ** __restrict  __endptr ) ;
#line 25 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/times.h"
extern int times_expire(char *group , int until ) ;
#line 44 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/snexpire.c"
bool report  =    (bool )0;
#line 46 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/snexpire.c"
time_t parseexp(char *buf___28 ) 
{ 
  double exp ;
  char *unit ;
  int *tmp ;

  {
#line 51
  if ((unsigned long )buf___28 == (unsigned long )((void *)0)) {
#line 52
    return ((time_t )-1);
  }
  {
#line 54
  exp = strtod((char const   */* __restrict  */)buf___28, (char **/* __restrict  */)(& unit));
#line 55
  tmp = __errno_location();
  }
#line 55
  if (*tmp == 34) {
#line 56
    return ((time_t )-1);
  }
  {
#line 60
  if ((int )*unit == 121) {
#line 60
    goto case_121;
  }
#line 62
  if ((int )*unit == 109) {
#line 62
    goto case_109;
  }
#line 64
  if ((int )*unit == 119) {
#line 64
    goto case_119;
  }
#line 66
  if ((int )*unit == 100) {
#line 66
    goto case_100;
  }
#line 68
  if ((int )*unit == 104) {
#line 68
    goto case_104;
  }
#line 72
  goto switch_default;
  case_121: /* CIL Label */ 
#line 61
  exp *= 12.0;
  case_109: /* CIL Label */ 
#line 63
  exp *= 4.345;
  case_119: /* CIL Label */ 
#line 65
  exp *= 7.0;
  case_100: /* CIL Label */ 
#line 67
  exp *= 24.0;
  case_104: /* CIL Label */ 
#line 69
  exp *= 60.0;
#line 70
  exp *= 60.0;
#line 71
  if (*(unit + 1)) {
    switch_default: /* CIL Label */ 
#line 73
    return ((time_t )-1);
  }
  switch_break: /* CIL Label */ ;
  }
#line 76
  return ((time_t )exp);
}
}
#line 79 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/snexpire.c"
static time_t readexp(char *newsgroup ) 
{ 
  char buf___28[32] ;
  int fd ;
  int count ;
  time_t t ;
  int tmp ;
  ssize_t tmp___0 ;

  {
  {
#line 86
  fd = openf(0, 0, (char *)"%s/.expire", newsgroup);
  }
#line 86
  if (fd > -1) {
    {
#line 88
    tmp___0 = read(fd, (void *)(buf___28), sizeof(buf___28) - 1UL);
#line 88
    count = (int )tmp___0;
    }
#line 88
    if (count > -1) {
#line 90
      tmp = count;
#line 90
      count --;
#line 90
      buf___28[tmp] = (char )'\000';
      {
#line 90
      while (1) {
        while_continue: /* CIL Label */ ;
#line 90
        if (! (count > 0)) {
#line 90
          goto while_break;
        }
#line 91
        if ((int )buf___28[count] <= 32) {
#line 92
          buf___28[count] = (char )'\000';
        } else {
#line 94
          goto while_break;
        }
#line 90
        count --;
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 95
      t = parseexp(buf___28);
      }
#line 95
      if (t > -1L) {
        {
#line 97
        close(fd);
        }
#line 98
        return (t);
      }
      {
#line 100
      log_((char *)"bad format in %s/.expire", newsgroup);
      }
    }
    {
#line 102
    close(fd);
    }
  }
#line 104
  return ((time_t )604800);
}
}
#line 112 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/snexpire.c"
static int expire(char *newsgroup , time_t age___0 ) 
{ 
  char buf___28[255UL + sizeof("/12345678901234")] ;
  int maxfile ;
  int minfile ;
  int file ;
  int serial ;
  int i ;
  DIR *dir ;
  struct dirent *dp ;
  int tmp ;
  char *end ;
  unsigned long tmp___0 ;
  time_t tmp___1 ;
  struct article a ;
  char *id ;
  int tmp___2 ;
  struct data d ;
  char *cp ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
#line 122
  if (debug >= 3) {
    {
#line 122
    log_((char *)"expire:group: %s, max age: %d hours", newsgroup, (age___0 / 60L) / 60L);
    }
  }
  {
#line 124
  dir = opendir((char const   *)newsgroup);
  }
#line 124
  if ((unsigned long )dir == (unsigned long )((void *)0)) {
    {
#line 126
    log_((char *)"expire:opendir(%s):%m", newsgroup);
    }
#line 127
    return (0);
  }
#line 129
  maxfile = -1;
#line 129
  minfile = 2147483647;
  {
#line 129
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 129
    dp = readdir(dir);
    }
#line 129
    if (! dp) {
#line 129
      goto while_break;
    }
#line 130
    if ((int )dp->d_name[0] > 48) {
#line 130
      if ((int )dp->d_name[0] <= 57) {
        {
#line 131
        tmp___0 = strtoul((char const   */* __restrict  */)(dp->d_name), (char **/* __restrict  */)(& end),
                          10);
#line 131
        tmp = (int )tmp___0;
        }
#line 131
        if (tmp > 0) {
#line 131
          if (! *end) {
#line 133
            if (tmp > maxfile) {
#line 134
              maxfile = tmp;
            }
#line 135
            if (tmp < minfile) {
#line 136
              minfile = tmp;
            }
          }
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 138
  closedir(dir);
  }
#line 139
  if (maxfile == -1) {
#line 141
    if (debug >= 1) {
      {
#line 141
      log_((char *)"expire:group \"%s\" is empty", newsgroup);
      }
    }
#line 142
    return (0);
  }
#line 145
  if (age___0) {
    {
#line 146
    tmp___1 = time((time_t *)((void *)0));
#line 146
    serial = times_since(newsgroup, tmp___1 - age___0);
    }
    {
#line 148
    if (serial == -1) {
#line 148
      goto case_neg_1;
    }
#line 151
    if (serial == 1) {
#line 151
      goto case_1;
    }
#line 153
    if (serial == 0) {
#line 153
      goto case_0;
    }
#line 156
    goto switch_default;
    case_neg_1: /* CIL Label */ 
    {
#line 149
    log_((char *)"times_since(%s):%m", newsgroup);
    }
#line 150
    return (-1);
    case_1: /* CIL Label */ 
#line 152
    return (0);
    case_0: /* CIL Label */ 
#line 154
    maxfile --;
#line 155
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 157
    maxfile = serial / 10;
#line 158
    if (serial % 10 != 9) {
#line 159
      maxfile --;
    }
#line 160
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
#line 163
  file = maxfile;
  {
#line 163
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 163
    if (! (file >= minfile)) {
#line 163
      goto while_break___0;
    }
#line 167
    i = 10;
    {
#line 167
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 167
      if (! (i > -1)) {
#line 167
        goto while_break___1;
      }
      {
#line 171
      serial = file * 10 + i;
#line 172
      tmp___2 = art_gimmenoderef(newsgroup, serial, & a);
      }
#line 172
      if (-1 == tmp___2) {
#line 173
        goto __Cont;
      }
      {
#line 174
      id = art_findfield(a.head, (char *)"message-id");
      }
#line 175
      if (id) {
#line 175
        if (*id) {
#line 180
          if (60 == (int )*id) {
#line 181
            id ++;
          }
          {
#line 182
          cp = strchr((char const   *)id, '>');
          }
#line 182
          if (cp) {
#line 183
            *cp = (char )'\000';
          }
          {
#line 184
          d.messageid = id;
#line 185
          tmp___5 = dh_find(& d, (bool )0);
          }
#line 185
          if (0 == tmp___5) {
            {
#line 186
            tmp___4 = strcmp((char const   *)d.newsgroup, (char const   *)newsgroup);
            }
#line 186
            if (0 == tmp___4) {
#line 187
              if (d.serial == serial) {
                {
#line 188
                tmp___3 = dh_delete(& d);
                }
#line 188
                if (-1 == tmp___3) {
#line 189
                  if (debug >= 2) {
                    {
#line 189
                    log_((char *)"expire:can\'t delete id %s for %s:%d", id, newsgroup,
                         serial);
                    }
                  }
                }
              }
            }
          }
#line 190
          if (report) {
            {
#line 191
            writef(1, (char *)"%s %d %s\n", newsgroup, serial, id);
            }
          }
        } else {
#line 175
          goto _L;
        }
      } else
      _L: /* CIL Label */ 
#line 194
      if (debug >= 2) {
        {
#line 194
        log_((char *)"expire:Can\'t find id for %s:%d", newsgroup, serial);
        }
      }
      __Cont: /* CIL Label */ 
#line 167
      i --;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 197
    formats(buf___28, (int )(sizeof(buf___28) - 1UL), (char *)"%s/%d", newsgroup,
            file);
#line 198
    tmp___6 = unlink((char const   *)(buf___28));
    }
#line 198
    if (-1 == tmp___6) {
      {
#line 199
      log_((char *)"expire:unlink(%s):%m", buf___28);
      }
    }
#line 163
    file --;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 201
  times_expire(newsgroup, (maxfile + 1) * 10);
  }
#line 202
  return (0);
}
}
#line 205 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/snexpire.c"
static void usage___1(void) 
{ 


  {
  {
#line 205
  fail(1, (char *)"Usage:%s [[-exp] newsgroup]...", progname);
  }
#line 205
  return;
}
}
#line 26 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/body.c"
static char *bodbuf___5  =    (char *)((void *)0);
#line 56 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/dhash.c"
static unsigned char buf___16[2]  ;
#line 54 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/dhash.c"
static char *inttochar2___6(int integer ) 
{ 


  {
#line 58
  buf___16[0] = (unsigned char )((integer & 65535) >> 8);
#line 59
  buf___16[1] = (unsigned char )(integer & 255);
#line 60
  return ((char *)(buf___16));
}
}
#line 65 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/dhash.c"
static unsigned char buf___17[3]  ;
#line 63 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/dhash.c"
static char *inttochar3___6(unsigned int integer ) 
{ 


  {
#line 67
  integer >>= 2;
#line 68
  buf___17[0] = (unsigned char )((integer & 16777215U) >> 16);
#line 69
  buf___17[1] = (unsigned char )((integer & 65535U) >> 8);
#line 70
  buf___17[2] = (unsigned char )(integer & 255U);
#line 71
  return ((char *)(buf___17));
}
}
#line 87 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/cache.c"
static struct entry *new_entry___6(int desc___35 ) 
{ 
  struct entry *ep ;
  struct entry *tmp ;

  {
#line 91
  ep = table[desc___35].freelist;
#line 91
  if (ep) {
#line 92
    table[desc___35].freelist = ep->next;
  } else {
#line 95
    ep = table[desc___35].entries;
    {
#line 95
    while (1) {
      while_continue: /* CIL Label */ ;
#line 95
      if (! ep->next) {
#line 95
        goto while_break;
      }
#line 95
      ep = ep->next;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 96
    (ep->prev)->next = (struct entry *)((void *)0);
#line 97
    (*(table[desc___35].freeobj))(ep->object);
    }
  }
#line 99
  tmp = (struct entry *)((void *)0);
#line 99
  ep->next = tmp;
#line 99
  ep->prev = tmp;
#line 100
  ep->object = (void *)0;
#line 101
  return (ep);
}
}
#line 105 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/dh_find.c"
static int initfile___13(void) 
{ 
  int fd ;
  int integer ;
  int i ;
  char foo[3] ;
  unsigned int tmp ;
  int *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  ssize_t tmp___3 ;
  ssize_t tmp___4 ;

  {
#line 108
  integer = 218885376;
#line 110
  foo[0] = (char )'\000';
#line 110
  tmp = 1U;
  {
#line 110
  while (1) {
    while_continue: /* CIL Label */ ;
#line 110
    if (tmp >= 3U) {
#line 110
      goto while_break;
    }
#line 110
    foo[tmp] = (char)0;
#line 110
    tmp ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 112
  fd = open((char const   *)(dh_tablefile), 194, 420);
  }
#line 113
  if (fd == -1) {
#line 114
    return (-1);
  }
  {
#line 115
  tmp___2 = lockf(fd, 2, (__off_t )0);
  }
#line 115
  if (tmp___2 == -1) {
    {
#line 117
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 119
      tmp___0 = __errno_location();
      }
#line 119
      if (*tmp___0 == 11) {
        {
#line 120
        nap(0, 200);
        }
      } else {
#line 122
        goto fail;
      }
      {
#line 117
      tmp___1 = lockf(fd, 2, (__off_t )0);
      }
#line 117
      if (! (tmp___1 == -1)) {
#line 117
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 125
    lockf(fd, 0, (__off_t )0);
    }
#line 126
    return (fd);
  }
  {
#line 128
  tmp___3 = write(fd, (void const   *)(& integer), sizeof(int ));
  }
#line 128
  if ((unsigned long )tmp___3 != sizeof(int )) {
#line 129
    goto fail;
  }
#line 130
  i = 0;
  {
#line 130
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 130
    if (! (i < 10240)) {
#line 130
      goto while_break___1;
    }
    {
#line 131
    tmp___4 = write(fd, (void const   *)(foo), sizeof(foo));
    }
#line 131
    if ((unsigned long )tmp___4 != sizeof(foo)) {
#line 132
      goto fail;
    }
#line 130
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 133
  lseek(fd, (__off_t )0, 0);
#line 134
  lockf(fd, 0, (__off_t )0);
  }
#line 135
  return (fd);
  fail: 
#line 138
  if (fd > -1) {
    {
#line 139
    close(fd);
    }
  }
#line 140
  return (-1);
}
}
#line 35 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/newsgroup.c"
static struct ng *bygroup___6[128]  ;
#line 36 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/newsgroup.c"
static struct ng *byident___6[128]  ;
#line 37 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/newsgroup.c"
static int highest___6  =    0;
#line 39 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/newsgroup.c"
static unsigned int hash___13(char *buf___28 , int len ) 
{ 
  unsigned int h ;
  char *tmp ;

  {
#line 43
  h = 5381U;
  {
#line 44
  while (1) {
    while_continue: /* CIL Label */ ;
#line 44
    if (! len) {
#line 44
      goto while_break;
    }
#line 46
    len --;
#line 47
    h += h << 5;
#line 48
    tmp = buf___28;
#line 48
    buf___28 ++;
#line 48
    h ^= (unsigned int )*tmp;
  }
  while_break: /* CIL Label */ ;
  }
#line 50
  return (h);
}
}
#line 53 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/newsgroup.c"
static struct chunk *chunks___6  ;
#line 58 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/newsgroup.c"
static int avail___13  =    0;
#line 59 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/newsgroup.c"
static int nr___7  =    0;
#line 64 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/newsgroup.c"
static int add___7(int ident , char *group , int len ) 
{ 
  struct ng *np ;
  struct ng *p ;
  int want ;
  unsigned int h ;
  struct chunk *tmp ;
  int size___1 ;
  void *tmp___0 ;
  unsigned int tmp___1 ;
  int tmp___2 ;

  {
#line 71
  len ++;
#line 72
  want = (int )(((unsigned long )len + sizeof(struct ng )) + sizeof(char *));
#line 73
  want = (int )((unsigned long )want - (unsigned long )len % sizeof(char *));
#line 74
  len --;
#line 76
  if (avail___13 < want) {
#line 81
    if (want > 240) {
#line 81
      size___1 = want + 240;
    } else {
#line 81
      size___1 = 240;
    }
    {
#line 82
    tmp___0 = malloc((size_t )size___1);
#line 82
    tmp = (struct chunk *)tmp___0;
    }
#line 82
    if (! tmp) {
#line 83
      return (-1);
    }
#line 84
    tmp->next = chunks___6;
#line 85
    chunks___6 = tmp;
#line 86
    chunks___6->buf = (char *)chunks___6 + sizeof(struct chunk );
#line 87
    avail___13 = (int )((unsigned long )size___1 - sizeof(struct chunk ));
  }
  {
#line 89
  np = (struct ng *)chunks___6->buf;
#line 90
  chunks___6->buf += want;
#line 91
  avail___13 -= want;
#line 92
  strncpy((char */* __restrict  */)(np->group), (char const   */* __restrict  */)group,
          (size_t )len);
#line 93
  np->group[len] = (char )'\000';
#line 94
  np->ident = ident;
#line 96
  tmp___1 = hash___13(group, len);
#line 96
  h = tmp___1 % 128U;
#line 97
  np->gnext = bygroup___6[h];
#line 98
  bygroup___6[h] = np;
#line 99
  p = np->gnext;
  }
  {
#line 99
  while (1) {
    while_continue: /* CIL Label */ ;
#line 99
    if (! p) {
#line 99
      goto while_break;
    }
    {
#line 100
    tmp___2 = strcmp((char const   *)(p->group), (char const   *)group);
    }
#line 100
    if (0 == tmp___2) {
#line 101
      return (1);
    }
#line 99
    p = p->gnext;
  }
  while_break: /* CIL Label */ ;
  }
#line 102
  h = (unsigned int )(ident % 128);
#line 103
  np->inext = byident___6[h];
#line 104
  byident___6[h] = np;
#line 105
  p = np->inext;
  {
#line 105
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 105
    if (! p) {
#line 105
      goto while_break___0;
    }
#line 106
    if (p->ident == ident) {
#line 107
      return (1);
    }
#line 105
    p = p->inext;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 109
  if (ident > highest___6) {
#line 110
    highest___6 = ident;
  }
#line 111
  nr___7 ++;
#line 112
  return (0);
}
}
#line 116 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/newsgroup.c"
static int groupfd___6  =    -1;
#line 117 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/newsgroup.c"
static int oldsize___6  =    0;
#line 118 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/newsgroup.c"
static int mapsize___6  =    0;
#line 119 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/newsgroup.c"
static char *mapbuf___6  =    (char *)((void *)0);
#line 148
static int reload___6(void) ;
#line 148 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/newsgroup.c"
static int pagesize___20  =    0;
#line 145 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/newsgroup.c"
static int reload___6(void) 
{ 
  struct stat st ;
  int newsize ;
  int tmp ;
  void *tmp___0 ;
  char *p ;
  char *lim ;
  char *ip ;
  char *gr ;
  int ident ;
  int state ;
  int tmp___1 ;

  {
  {
#line 156
  tmp = fstat(groupfd___6, & st);
  }
#line 156
  if (-1 == tmp) {
    {
#line 158
    log_((char *)"reload:fstat:%m");
    }
#line 159
    return (-1);
  }
#line 161
  newsize = (int )st.st_size;
#line 162
  if (! pagesize___20) {
    {
#line 163
    pagesize___20 = getpagesize();
    }
  }
#line 164
  if (newsize <= oldsize___6) {
#line 165
    return (0);
  }
#line 166
  if (newsize > mapsize___6) {
#line 166
    goto _L;
  } else
#line 166
  if (! mapsize___6) {
    _L: /* CIL Label */ 
#line 168
    if (mapbuf___6) {
      {
#line 169
      munmap((void *)mapbuf___6, (size_t )mapsize___6);
      }
    }
    {
#line 170
    mapsize___6 = (int )((st.st_size + (__off_t )pagesize___20) - st.st_size % (long )pagesize___20);
#line 171
    tmp___0 = mmap((void *)0, (size_t )mapsize___6, 1, 1, groupfd___6, (__off_t )0);
#line 171
    mapbuf___6 = (char *)tmp___0;
    }
#line 172
    if (! mapbuf___6) {
      {
#line 174
      log_((char *)"reload:mmap:%m");
      }
#line 175
      return (-1);
    } else
#line 172
    if ((unsigned long )mapbuf___6 == (unsigned long )((void *)-1)) {
      {
#line 174
      log_((char *)"reload:mmap:%m");
      }
#line 175
      return (-1);
    }
  }
#line 188
  lim = mapbuf___6 + newsize;
#line 189
  state = 0;
#line 189
  ident = state;
#line 190
  gr = (char *)0;
#line 190
  ip = gr;
#line 191
  p = mapbuf___6 + oldsize___6;
  {
#line 191
  while (1) {
    while_continue: /* CIL Label */ ;
#line 191
    if (! ((unsigned long )p < (unsigned long )lim)) {
#line 191
      goto while_break;
    }
    {
#line 194
    if (state == 0) {
#line 194
      goto case_0;
    }
#line 195
    if (state == 1) {
#line 195
      goto case_1;
    }
#line 196
    if (state == 2) {
#line 196
      goto case_2;
    }
#line 197
    if (state == 3) {
#line 197
      goto case_3;
    }
#line 192
    goto switch_break;
    case_0: /* CIL Label */ 
#line 194
    if ((int )*p >= 48) {
#line 194
      if ((int )*p <= 57) {
#line 194
        ip = p;
#line 194
        state ++;
      }
    }
#line 194
    goto switch_break;
    case_1: /* CIL Label */ 
#line 195
    if (32 == (int )*p) {
      {
#line 195
      ident = atoi((char const   *)ip);
#line 195
      state ++;
      }
    }
#line 195
    goto switch_break;
    case_2: /* CIL Label */ 
#line 196
    if (32 != (int )*p) {
#line 196
      gr = p;
#line 196
      state ++;
    }
#line 196
    goto switch_break;
    case_3: /* CIL Label */ 
#line 198
    if (10 != (int )*p) {
#line 199
      goto switch_break;
    }
    {
#line 200
    tmp___1 = add___7(ident, gr, (int )(p - gr));
    }
#line 200
    if (-1 == tmp___1) {
      {
#line 202
      log_((char *)"reload:no memory");
      }
#line 203
      return (-1);
    }
#line 205
    state = 0;
    switch_break: /* CIL Label */ ;
    }
#line 191
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 208
  oldsize___6 = newsize;
#line 209
  return (0);
}
}
#line 26 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/body.c"
static char *bodbuf___6  =    (char *)((void *)0);
#line 50 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memmove)(void *__dest ,
                                                                                                  void const   *__src ,
                                                                                                  size_t __n ) ;
#line 33 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/sngetd.c"
static int fifofd  ;
#line 34 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/sngetd.c"
static int age  =    600;
#line 42 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/sngetd.c"
static struct get *recently  =    (struct get *)((void *)0);
#line 46 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/sngetd.c"
static char inbuf[256]  ;
#line 47
static void readgroup(void) ;
#line 47 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/sngetd.c"
static int start  =    0;
#line 48 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/sngetd.c"
static int used  =    0;
#line 44 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/sngetd.c"
static void readgroup(void) 
{ 
  time_t t ;
  int c ;
  ssize_t tmp ;
  char *p ;
  int end ;
  struct get *gp ;
  struct get *tmp___0 ;
  struct stat st ;
  char ch ;
  int tmp___1 ;
  size_t tmp___2 ;
  void *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  ssize_t tmp___6 ;
  bool tmp___7 ;

  {
#line 52
  if (used == start) {
#line 53
    start = 0;
#line 53
    used = start;
  }
  {
#line 54
  tmp = read(fifofd, (void *)(inbuf + used), (sizeof(inbuf) - 1UL) - (unsigned long )used);
#line 54
  c = (int )tmp;
  }
#line 54
  if (c <= 0) {
#line 55
    return;
  }
  {
#line 56
  used += c;
#line 58
  time(& t);
  }
  {
#line 60
  while (1) {
    while_continue: /* CIL Label */ ;
#line 65
    end = start;
    {
#line 65
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 65
      if (end < used) {
#line 65
        if (! (10 != (int )inbuf[end])) {
#line 65
          goto while_break___0;
        }
      } else {
#line 65
        goto while_break___0;
      }
#line 65
      end ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 66
    if (used == end) {
#line 69
      if (start > 0) {
        {
#line 71
        memmove((void *)(inbuf), (void const   *)(inbuf + start), (size_t )(used - start));
#line 72
        used -= start;
        }
      } else {
#line 75
        used = 0;
      }
#line 76
      start = 0;
#line 77
      return;
    }
#line 81
    inbuf[end] = (char )'\000';
#line 82
    p = inbuf + start;
#line 84
    if (end - start < 255) {
#line 84
      if (91 != (int )*p) {
        {
#line 91
        tmp___7 = is_valid_group(p);
        }
#line 91
        if (tmp___7) {
          {
#line 95
          tmp___6 = readlink((char const   */* __restrict  */)p, (char */* __restrict  */)(& ch),
                             (size_t )1);
          }
#line 95
          if (0L == tmp___6) {
#line 97
            if (debug >= 1) {
              {
#line 97
              log_((char *)"%s is a symlink", p);
              }
            }
          } else {
            {
#line 99
            tmp___5 = statf(& st, (char *)"%s/.outgoing", p);
            }
#line 99
            if (-1 == tmp___5) {
#line 101
              if (debug >= 1) {
                {
#line 101
                log_((char *)"%s is a local group", p);
                }
              }
            } else
#line 103
            if (! ((st.st_mode & 61440U) == 16384U)) {
#line 105
              if (debug >= 1) {
                {
#line 105
                log_((char *)"%s is not a global group", p);
                }
              }
            } else {
#line 109
              tmp___0 = (struct get *)0;
#line 109
              gp = recently;
              {
#line 109
              while (1) {
                while_continue___1: /* CIL Label */ ;
#line 109
                if (! gp) {
#line 109
                  goto while_break___1;
                }
#line 110
                if ((unsigned long )gp->t + (unsigned long )age < (unsigned long )t) {
#line 112
                  if (tmp___0) {
#line 113
                    tmp___0->next = (struct get *)0;
                  } else {
#line 115
                    recently = (struct get *)((void *)0);
                  }
                  {
#line 116
                  while (1) {
                    while_continue___2: /* CIL Label */ ;
                    {
#line 118
                    tmp___0 = gp->next;
#line 119
                    free((void *)gp);
#line 116
                    gp = tmp___0;
                    }
#line 116
                    if (! gp) {
#line 116
                      goto while_break___2;
                    }
                  }
                  while_break___2: /* CIL Label */ ;
                  }
#line 122
                  gp = recently;
#line 123
                  goto while_break___1;
                } else {
                  {
#line 125
                  tmp___1 = strcmp((char const   *)(gp->group), (char const   *)p);
                  }
#line 125
                  if (0 == tmp___1) {
#line 126
                    goto while_break___1;
                  }
                }
#line 109
                tmp___0 = gp;
#line 109
                gp = gp->next;
              }
              while_break___1: /* CIL Label */ ;
              }
#line 128
              if (! gp) {
                {
#line 130
                tmp___4 = add(p);
                }
#line 130
                if (0 == tmp___4) {
#line 132
                  if (debug >= 1) {
                    {
#line 132
                    log_((char *)"Will fetch \"%s\"", p);
                    }
                  }
                  {
#line 133
                  tmp___2 = strlen((char const   *)p);
#line 133
                  tmp___3 = malloc(sizeof(struct get ) + tmp___2);
#line 133
                  gp = (struct get *)tmp___3;
                  }
#line 133
                  if (gp) {
                    {
#line 135
                    strcpy((char */* __restrict  */)(gp->group), (char const   */* __restrict  */)p);
#line 136
                    gp->t = t;
#line 137
                    gp->next = recently;
#line 138
                    recently = gp;
                    }
                  } else {
                    {
#line 141
                    log_((char *)"Oops, no memory to remember I\'m fetching %s", p);
                    }
                  }
                }
              } else
#line 145
              if (debug >= 1) {
                {
#line 145
                log_((char *)"Already fetched/fetching for %s", p);
                }
              }
            }
          }
        } else
#line 93
        if (debug >= 1) {
          {
#line 93
          log_((char *)"%s is not a valid name", p);
          }
        }
      }
    }
#line 149
    start = end + 1;
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 78 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/allocate.c"
static struct table___1 table___7  =    {(char *)0, (char *)0, 0, 0, 0, 0};
#line 80
static int remapfile___6(void) ;
#line 106 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/allocate.c"
static int initfile___14(char *filename ) 
{ 
  struct chainfile cf ;
  int fd ;
  int i ;
  int ret ;
  ssize_t tmp ;
  int pad ;
  ssize_t tmp___0 ;

  {
  {
#line 108
  cf.chain_magic = 0;
#line 108
  cf.next[0] = 0;
#line 108
  cf.next[1] = 0;
#line 108
  cf.next[2] = 0;
#line 108
  cf.next[3] = 0;
#line 108
  cf.next[4] = 0;
#line 108
  cf.next[5] = 0;
#line 108
  cf.next[6] = 0;
#line 108
  cf.next[7] = 0;
#line 108
  cf.next[8] = 0;
#line 108
  cf.next[9] = 0;
#line 108
  cf.next[10] = 0;
#line 108
  cf.next[11] = 0;
#line 108
  cf.next[12] = 0;
#line 108
  cf.next[13] = 0;
#line 108
  cf.next[14] = 0;
#line 108
  cf.next[15] = 0;
#line 108
  cf.next[16] = 0;
#line 108
  cf.next[17] = 0;
#line 108
  cf.next[18] = 0;
#line 108
  cf.next[19] = 0;
#line 108
  cf.next[20] = 0;
#line 108
  cf.next[21] = 0;
#line 108
  cf.next[22] = 0;
#line 108
  cf.next[23] = 0;
#line 108
  cf.next[24] = 0;
#line 108
  cf.next[25] = 0;
#line 108
  cf.next[26] = 0;
#line 108
  cf.next[27] = 0;
#line 108
  cf.next[28] = 0;
#line 108
  cf.next[29] = 0;
#line 108
  cf.next[30] = 0;
#line 108
  cf.next[31] = 0;
#line 108
  cf.next[32] = 0;
#line 108
  cf.next[33] = 0;
#line 108
  cf.next[34] = 0;
#line 108
  cf.next[35] = 0;
#line 108
  cf.next[36] = 0;
#line 108
  cf.next[37] = 0;
#line 108
  cf.next[38] = 0;
#line 108
  cf.next[39] = 0;
#line 108
  cf.next[40] = 0;
#line 108
  cf.next[41] = 0;
#line 108
  cf.next[42] = 0;
#line 108
  cf.next[43] = 0;
#line 108
  cf.next[44] = 0;
#line 108
  cf.next[45] = 0;
#line 108
  cf.next[46] = 0;
#line 108
  cf.next[47] = 0;
#line 108
  cf.next[48] = 0;
#line 108
  cf.next[49] = 0;
#line 108
  cf.next[50] = 0;
#line 108
  cf.next[51] = 0;
#line 108
  cf.next[52] = 0;
#line 108
  cf.next[53] = 0;
#line 108
  cf.next[54] = 0;
#line 108
  cf.next[55] = 0;
#line 108
  cf.next[56] = 0;
#line 108
  cf.next[57] = 0;
#line 108
  cf.next[58] = 0;
#line 108
  cf.next[59] = 0;
#line 108
  cf.next[60] = 0;
#line 108
  cf.next[61] = 0;
#line 108
  cf.next[62] = 0;
#line 111
  ret = 0;
#line 113
  fd = open((char const   *)filename, 578, 420);
  }
#line 114
  if (-1 == fd) {
#line 115
    return (-1);
  }
#line 116
  cf.chain_magic = 13680336;
#line 117
  i = 0;
  {
#line 117
  while (1) {
    while_continue: /* CIL Label */ ;
#line 117
    if (! (i < 63)) {
#line 117
      goto while_break;
    }
#line 118
    cf.next[i] = (int volatile   )0;
#line 117
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 119
  tmp = write(fd, (void const   *)(& cf), sizeof(cf));
#line 119
  i = (int )tmp;
  }
#line 120
  if ((unsigned long )i == sizeof(cf)) {
#line 124
    pad = (int )(sizeof(cf) % 4UL);
#line 125
    if (pad > 0) {
#line 126
      i = 0;
      {
#line 126
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 126
        if (i < pad) {
#line 126
          if (! (0 == ret)) {
#line 126
            goto while_break___0;
          }
        } else {
#line 126
          goto while_break___0;
        }
        {
#line 127
        tmp___0 = write(fd, (void const   *)"", (size_t )1);
        }
#line 127
        if (1L != tmp___0) {
#line 128
          ret = -1;
        }
#line 126
        i ++;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
  } else {
#line 131
    ret = -1;
  }
  {
#line 132
  close(fd);
  }
#line 133
  return (ret);
}
}
#line 136 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/allocate.c"
static void unmapfile___6(void) 
{ 


  {
#line 138
  if (table___7.fd >= 0) {
    {
#line 140
    close(table___7.fd);
#line 141
    table___7.fd = -1;
    }
  }
#line 143
  if (table___7.map) {
    {
#line 145
    munmap((void *)table___7.map, (size_t )table___7.size);
#line 146
    table___7.map = (char *)((void *)0);
#line 147
    table___7.size = 0;
    }
  }
#line 149
  return;
}
}
#line 153
static size_t rounduptopagesize___6(size_t size___1 ) ;
#line 153 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/allocate.c"
static size_t pagesize___21  =    (size_t )0;
#line 151 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/allocate.c"
static size_t rounduptopagesize___6(size_t size___1 ) 
{ 
  int pages ;
  int tmp ;

  {
#line 156
  if (0UL == pagesize___21) {
    {
#line 157
    tmp = getpagesize();
#line 157
    pagesize___21 = (size_t )tmp;
    }
  }
#line 158
  pages = (int )(size___1 / pagesize___21 + 1UL);
#line 159
  return ((size_t )pages * pagesize___21);
}
}
#line 162 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/allocate.c"
static int mapfile___6(void) 
{ 
  struct stat st ;
  int tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;

  {
#line 166
  if (-1 == table___7.fd) {
    {
#line 167
    table___7.fd = open((char const   *)table___7.filename, table___7.oflag, 420);
    }
  }
#line 168
  if (-1 == table___7.fd) {
#line 169
    goto fail;
  }
  {
#line 171
  tmp = fstat(table___7.fd, & st);
  }
#line 171
  if (-1 == tmp) {
#line 172
    goto fail;
  }
  {
#line 173
  tmp___0 = rounduptopagesize___6((size_t )st.st_size);
#line 173
  table___7.size = (int )tmp___0;
#line 174
  tmp___1 = mmap((void *)0, (size_t )table___7.size, table___7.mprot, 1, table___7.fd,
                 (__off_t )0);
#line 174
  table___7.map = (char *)tmp___1;
  }
#line 175
  if (! table___7.map) {
#line 176
    goto fail;
  } else
#line 175
  if ((unsigned long )table___7.map == (unsigned long )((void *)-1)) {
#line 176
    goto fail;
  }
#line 178
  return (0);
  fail: 
  {
#line 181
  unmapfile___6();
  }
#line 182
  return (-1);
}
}
#line 189 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/allocate.c"
static int remapfile___6(void) 
{ 
  struct stat st ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 193
  tmp = fstat(table___7.fd, & st);
  }
#line 193
  if (-1 == tmp) {
#line 194
    return (-1);
  }
#line 196
  if (st.st_size <= (__off_t )table___7.size) {
#line 197
    return (0);
  }
  {
#line 199
  munmap((void *)table___7.map, (size_t )table___7.size);
#line 200
  tmp___0 = mapfile___6();
  }
#line 200
  return (tmp___0);
}
}
#line 209 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/allocate.c"
static int lock___6(void) 
{ 
  int *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 211
  tmp___2 = lockf(table___7.fd, 2, (__off_t )0);
  }
#line 211
  if (-1 == tmp___2) {
    {
#line 213
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 215
      tmp = __errno_location();
      }
#line 215
      if (11 != *tmp) {
#line 216
        return (-1);
      } else {
        {
#line 218
        nap(0, 200);
        }
      }
      {
#line 213
      tmp___0 = lockf(table___7.fd, 2, (__off_t )0);
      }
#line 213
      if (! (-1 == tmp___0)) {
#line 213
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 221
    tmp___1 = remapfile___6();
    }
#line 221
    if (-1 == tmp___1) {
#line 222
      return (-1);
    }
  }
#line 224
  return (0);
}
}
#line 227 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/allocate.c"
static void unlock___6(void) 
{ 


  {
  {
#line 229
  lseek(table___7.fd, (__off_t )0, 0);
#line 230
  lockf(table___7.fd, 0, (__off_t )0);
  }
#line 231
  return;
}
}
#line 233 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/allocate.c"
static int checkvalidfile___6(void) 
{ 


  {
#line 235
  if (table___7.size > 0) {
#line 237
    if ((unsigned long )table___7.size < sizeof(struct chainfile )) {
#line 238
      return (-1);
    }
#line 239
    if (((struct chainfile *)table___7.map)->chain_magic != 13680336) {
#line 240
      return (-1);
    }
  }
#line 242
  return (0);
}
}
#line 281 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/allocate.c"
static int rounduptoalignment___6(int size___1 ) 
{ 


  {
#line 283
  if (size___1 <= 0) {
#line 284
    return (4);
  }
#line 285
  return (((size___1 - 1) / 4 + 1) * 4);
}
}
#line 296 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/allocate.c"
static char tmpchunk___6[272]  = {      (char )'\000'};
#line 33 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/art.c"
static size_t pagesize___22  =    (size_t )0;
#line 80 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/art.c"
static void file_unmap___6(void *p ) 
{ 
  struct fileobj *fp ;

  {
  {
#line 82
  fp = (struct fileobj *)p;
#line 84
  munmap((void *)fp->map, (size_t )fp->size);
#line 85
  free((void *)fp);
  }
#line 86
  return;
}
}
#line 88 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/art.c"
static int file_cmp___6(void *a , void *b___13 ) 
{ 
  struct fileobj *x ;
  struct fileobj *y ;
  int tmp ;

  {
  {
#line 90
  x = (struct fileobj *)a;
#line 91
  y = (struct fileobj *)b___13;
#line 93
  tmp = strcmp((char const   *)x->path, (char const   *)y->path);
  }
#line 93
  return (tmp);
}
}
#line 96 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/art.c"
static int desc___18  =    -1;
#line 98 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/art.c"
static int file_init___6(void) 
{ 


  {
  {
#line 100
  desc___18 = cache_init(8, & file_cmp___6, & file_unmap___6, (int (*)(void * ))((void *)0));
  }
#line 101
  if (-1 == desc___18) {
    {
#line 103
    log_((char *)"file_init:%m");
    }
#line 104
    return (-1);
  }
#line 106
  return (0);
}
}
#line 109 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/art.c"
static struct file *file_gimme___6(char *name , int *size___1 ) 
{ 
  struct fileobj f___9 ;
  struct fileobj *fp ;
  void *tmp ;

  {
  {
#line 111
  f___9.path = (char *)0;
#line 111
  f___9.map = (char *)0;
#line 111
  f___9.size = 0;
#line 114
  f___9.path = name;
#line 116
  tmp = cache_find(desc___18, (void *)(& f___9));
#line 116
  fp = (struct fileobj *)tmp;
  }
#line 116
  if ((unsigned long )((void *)0) == (unsigned long )fp) {
    {
#line 118
    fp = file_map(name);
    }
#line 118
    if ((unsigned long )((void *)0) == (unsigned long )fp) {
#line 119
      return ((struct file *)((void *)0));
    } else {
      {
#line 121
      cache_insert(desc___18, (void *)fp);
      }
    }
  }
#line 124
  if (size___1) {
#line 125
    *size___1 = fp->size;
  }
#line 126
  return ((struct file *)fp->map);
}
}
#line 137 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/art.c"
static bool file_initialized___6  =    (bool )0;
#line 248 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/art.c"
static char ngroup___6[287]  ;
#line 297 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/art.c"
static int getfield___6(char *buf___28 , struct field *f___9 ) 
{ 
  register char *cp ;
  size_t tmp ;
  size_t tmp___0 ;

  {
  {
#line 299
  cp = buf___28;
#line 301
  tmp = strspn((char const   *)cp, " \t\f");
#line 301
  cp += tmp;
  }
#line 302
  if (! *cp) {
#line 304
    f___9->pointer = (char *)((void *)0);
#line 305
    return (0);
  }
  {
#line 307
  tmp___0 = strcspn((char const   *)cp, "\r\n");
#line 307
  f___9->len = (int )tmp___0;
  }
#line 308
  if (! f___9->len) {
#line 309
    return (0);
  }
#line 310
  f___9->pointer = cp;
#line 311
  return ((int )((cp + f___9->len) - buf___28));
}
}
#line 383 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/art.c"
static struct b b___7  =    {(char *)0, 0, 0};
#line 65 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/get.c"
static char path1___0[(255UL + sizeof("/.serial.tmp")) + 1UL]  ;
#line 66 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/get.c"
static char path2___0[(255UL + sizeof("/.serial.tmp")) + 1UL]  ;
#line 68 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/get.c"
static char *argv_snstore___0[4]  = {      (char *)"snstore"};
#line 69 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/get.c"
static int argc_snstore___0  ;
#line 70 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/get.c"
static char *argv_snfetch___0[14]  = {      (char *)"snfetch"};
#line 71 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/get.c"
static int argc_snfetch___0  ;
#line 76 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/get.c"
static int atou___0(char *buf___28 ) 
{ 
  int i ;
  int c ;

  {
#line 80
  i = 0;
  {
#line 80
  while (1) {
    while_continue: /* CIL Label */ ;
#line 80
    if (! *buf___28) {
#line 80
      goto while_break;
    }
#line 82
    c = (int )*buf___28 - 48;
#line 83
    if (c > 9) {
#line 84
      return (-1);
    } else
#line 83
    if (c < 0) {
#line 84
      return (-1);
    }
#line 85
    i *= 10;
#line 86
    i += c;
#line 80
    buf___28 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 88
  return (i);
}
}
#line 96 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/get.c"
static int stores___0[8]  ;
#line 97 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/get.c"
static int nstores___0  =    0;
#line 99 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/get.c"
static int store_get___0(void) 
{ 
  int pid___0 ;

  {
#line 101
  if (! nstores___0) {
    {
#line 105
    pid___0 = cmdopen(argv_snstore___0, (int *)0, stores___0);
    }
#line 106
    if (pid___0 <= 0) {
#line 108
      if (-19 == pid___0) {
        {
#line 109
        log_((char *)"store_get:exec snstore:PATH set?");
        }
      } else
#line 110
      if (-1 == pid___0) {
        {
#line 111
        log_((char *)"store_get:exec snstore:%m?");
        }
      } else {
        {
#line 113
        log_((char *)"store_get:snstore exited with %d", 0 - pid___0);
        }
      }
#line 114
      return (-1);
    }
    {
#line 116
    fcntl(stores___0[0], 2, 1);
#line 117
    nstores___0 ++;
    }
#line 118
    if (debug >= 3) {
      {
#line 118
      log_((char *)"pipe %d is snstore pid %d", stores___0[0], pid___0);
      }
    }
  }
#line 120
  nstores___0 --;
#line 120
  return (stores___0[nstores___0]);
}
}
#line 123 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/get.c"
static void store_put___0(int fd ) 
{ 
  int tmp ;

  {
#line 125
  if (nstores___0 < 8) {
#line 126
    tmp = nstores___0;
#line 126
    nstores___0 ++;
#line 126
    stores___0[tmp] = fd;
  } else {
    {
#line 128
    close(fd);
    }
  }
#line 129
  return;
}
}
#line 143 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/get.c"
static struct sock socks___0[8]  ;
#line 144 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/get.c"
static int nsocks___0  =    0;
#line 146 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/get.c"
static int sock_get___0(char *server , int port , unsigned long *addrp , int *reused ) 
{ 
  int i ;
  int sd ;
  int tmp ;
  struct hostent *hp ;
  struct sockaddr_in sa ;
  int fl ;
  uint32_t tmp___0 ;
  int *tmp___1 ;

  {
#line 150
  i = 0;
  {
#line 150
  while (1) {
    while_continue: /* CIL Label */ ;
#line 150
    if (! (i < nsocks___0)) {
#line 150
      goto while_break;
    }
#line 151
    if (port == (int )socks___0[i].port) {
      {
#line 152
      tmp = strcasecmp((char const   *)server, (char const   *)socks___0[i].server);
      }
#line 152
      if (0 == tmp) {
#line 154
        *reused = 1;
#line 155
        sd = (int )socks___0[i].sd;
#line 156
        *addrp = socks___0[i].addr;
#line 157
        nsocks___0 --;
#line 158
        if (i != nsocks___0) {
#line 159
          socks___0[i] = socks___0[nsocks___0];
        }
#line 160
        return (sd);
      }
    }
#line 150
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 165
  *reused = 0;
#line 166
  sd = socket(2, 1, 0);
  }
#line 166
  if (sd > -1) {
    {
#line 170
    hp = gethostbyname((char const   *)server);
    }
#line 170
    if (hp) {
      {
#line 175
      sa.sin_family = (sa_family_t )2;
#line 176
      sa.sin_port = htons((uint16_t )port);
#line 177
      sa.sin_addr.s_addr = (in_addr_t )*((unsigned long *)*(hp->h_addr_list + 0));
#line 178
      tmp___0 = ntohl(sa.sin_addr.s_addr);
#line 178
      *addrp = (unsigned long )tmp___0;
#line 179
      fl = fcntl(sd, 3);
#line 180
      fcntl(sd, 4, fl | 2048);
#line 181
      i = connect(sd, (struct sockaddr  const  *)((struct sockaddr *)(& sa)), (socklen_t )sizeof(sa));
      }
#line 182
      if (i > -1) {
        {
#line 184
        fcntl(sd, 4, fl);
#line 185
        fcntl(sd, 2, 1);
        }
#line 186
        return (sd);
      } else {
        {
#line 182
        tmp___1 = __errno_location();
        }
#line 182
        if (115 == *tmp___1) {
          {
#line 184
          fcntl(sd, 4, fl);
#line 185
          fcntl(sd, 2, 1);
          }
#line 186
          return (sd);
        } else {
          {
#line 189
          log_((char *)"sock_get:connect to %s:%m?", server);
          }
        }
      }
    } else {
      {
#line 192
      log_((char *)"sock_get:resolve \"%s\"", server);
      }
    }
    {
#line 193
    close(sd);
    }
  } else {
    {
#line 196
    log_((char *)"sock_get:socket to %s:%m", server);
    }
  }
#line 197
  return (-1);
}
}
#line 200 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/get.c"
static void sock_put___0(int sd , char *server , unsigned long addr , int port ) 
{ 


  {
#line 202
  if (nsocks___0 < 8) {
#line 204
    socks___0[nsocks___0].sd = (unsigned short )sd;
#line 205
    socks___0[nsocks___0].server = server;
#line 206
    socks___0[nsocks___0].port = (unsigned short )port;
#line 207
    socks___0[nsocks___0].addr = addr;
#line 208
    nsocks___0 ++;
  } else {
    {
#line 211
    close(sd);
    }
  }
#line 212
  return;
}
}
#line 224 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/get.c"
static struct job **queue___0  =    (struct job **)((void *)0);
#line 225 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/get.c"
static int toff___0  =    0;
#line 226 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/get.c"
static int tend___0  =    0;
#line 227 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/get.c"
static int qsize___0  ;
#line 229 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/get.c"
static int queue_add___0(struct job *jp ) 
{ 
  struct job **tmp ;
  int newsize ;
  void *tmp___0 ;
  int tmp___1 ;

  {
#line 231
  if (tend___0 >= qsize___0) {
#line 236
    if (queue___0) {
#line 236
      newsize = qsize___0 * 2;
    } else {
#line 236
      newsize = 20;
    }
    {
#line 237
    tmp___0 = malloc((unsigned long )newsize * sizeof(struct job *));
#line 237
    tmp = (struct job **)tmp___0;
    }
#line 237
    if (! tmp) {
#line 238
      return (-1);
    }
#line 239
    if (queue___0) {
      {
#line 241
      memcpy((void */* __restrict  */)tmp, (void const   */* __restrict  */)queue___0,
             (unsigned long )qsize___0 * sizeof(struct job *));
#line 242
      free((void *)queue___0);
      }
    }
#line 244
    queue___0 = tmp;
#line 245
    qsize___0 = newsize;
  }
#line 247
  tmp___1 = tend___0;
#line 247
  tend___0 ++;
#line 247
  *(queue___0 + tmp___1) = jp;
#line 248
  return (0);
}
}
#line 251 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/get.c"
static void swap___0(int a , int b___13 ) 
{ 
  struct job *tmp ;

  {
#line 255
  if (a == b___13) {
#line 256
    return;
  }
#line 257
  tmp = *(queue___0 + a);
#line 258
  *(queue___0 + a) = *(queue___0 + b___13);
#line 259
  *(queue___0 + b___13) = tmp;
#line 260
  return;
}
}
#line 262 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/get.c"
static void queue_todo2run___0(int j ) 
{ 
  int tmp ;

  {
  {
#line 262
  tmp = toff___0;
#line 262
  toff___0 ++;
#line 262
  swap___0(tmp, j);
  }
#line 262
  return;
}
}
#line 263 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/get.c"
static void queue_run2todo___0(int j ) 
{ 


  {
  {
#line 263
  toff___0 --;
#line 263
  swap___0(toff___0, j);
  }
#line 263
  return;
}
}
#line 265 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/get.c"
static void queue_rm___0(int j ) 
{ 


  {
#line 268
  if (j < toff___0) {
    {
#line 270
    queue_run2todo___0(j);
#line 271
    j = toff___0;
    }
  }
  {
#line 273
  tend___0 --;
#line 273
  swap___0(j, tend___0);
#line 274
  free((void *)*(queue___0 + tend___0));
  }
#line 275
  return;
}
}
#line 277 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/get.c"
static int similarity___0(char *g1 , char *g2 ) 
{ 
  char *c1 ;
  int inc1 ;
  char *c2 ;
  int inc2 ;
  int score ;
  char *tmp ;
  char *tmp___0 ;

  {
#line 285
  score = 0;
#line 286
  inc1 = 7;
  {
#line 286
  while (1) {
    while_continue: /* CIL Label */ ;
#line 286
    if (inc1) {
#line 286
      if (! *g1) {
#line 286
        goto while_break;
      }
    } else {
#line 286
      goto while_break;
    }
#line 288
    inc2 = 7;
#line 289
    c2 = g2;
    {
#line 289
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 289
      if (inc2) {
#line 289
        if (! *c2) {
#line 289
          goto while_break___0;
        }
      } else {
#line 289
        goto while_break___0;
      }
#line 292
      c1 = g1;
      {
#line 292
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 292
        if ((int )*c1 == (int )*c2) {
#line 292
          if (*c1) {
#line 292
            if (! (46 != (int )*c1)) {
#line 292
              goto while_break___1;
            }
          } else {
#line 292
            goto while_break___1;
          }
        } else {
#line 292
          goto while_break___1;
        }
#line 293
        score ++;
#line 292
        c1 ++;
#line 292
        c2 ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 294
      if ((int )*c1 == (int )*c2) {
#line 295
        score += inc1 + inc2;
      }
      {
#line 297
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 298
        if (! *c2) {
#line 299
          goto while_break___2;
        }
#line 297
        tmp = c2;
#line 297
        c2 ++;
#line 297
        if (! (46 != (int )*tmp)) {
#line 297
          goto while_break___2;
        }
      }
      while_break___2: /* CIL Label */ ;
      }
#line 289
      inc2 --;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 302
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 303
      if (! *g1) {
#line 304
        goto while_break___3;
      }
#line 302
      tmp___0 = g1;
#line 302
      g1 ++;
#line 302
      if (! (46 != (int )*tmp___0)) {
#line 302
        goto while_break___3;
      }
    }
    while_break___3: /* CIL Label */ ;
    }
#line 286
    inc1 --;
  }
  while_break: /* CIL Label */ ;
  }
#line 307
  return (score);
}
}
#line 314 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/get.c"
static int queue_getnext___0(void) 
{ 
  int max ;
  int bestscore ;
  int bestgroup ;
  int t ;
  int r ;
  int score ;
  int tmp ;

  {
#line 320
  max = tend___0 - toff___0;
  {
#line 322
  if (max == 0) {
#line 322
    goto case_0;
  }
#line 324
  if (max == 1) {
#line 324
    goto case_1;
  }
#line 330
  if (max == 4) {
#line 330
    goto case_4;
  }
#line 330
  if (max == 3) {
#line 330
    goto case_4;
  }
#line 330
  if (max == 2) {
#line 330
    goto case_4;
  }
#line 326
  goto switch_default;
  case_0: /* CIL Label */ 
#line 323
  return (-1);
  case_1: /* CIL Label */ 
#line 325
  return (toff___0);
  switch_default: /* CIL Label */ 
#line 327
  max = 4;
  case_4: /* CIL Label */ 
  case_3: /* CIL Label */ 
  case_2: /* CIL Label */ ;
  switch_break: /* CIL Label */ ;
  }
#line 333
  bestscore = 10000;
#line 334
  bestgroup = toff___0;
#line 335
  t = toff___0;
  {
#line 335
  while (1) {
    while_continue: /* CIL Label */ ;
#line 335
    if (! (t < toff___0 + max)) {
#line 335
      goto while_break;
    }
#line 339
    score = 0;
#line 340
    r = 0;
    {
#line 340
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 340
      if (! (r < toff___0)) {
#line 340
        goto while_break___0;
      }
      {
#line 341
      tmp = similarity___0((*(queue___0 + r))->group, (*(queue___0 + t))->group);
#line 341
      score += tmp;
#line 340
      r ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 342
    if (score < bestscore) {
#line 344
      bestscore = score;
#line 345
      bestgroup = t;
    }
#line 335
    t ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 348
  return (bestgroup);
}
}
#line 378 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/get.c"
static struct timeval last___0  =    {(__time_t )0, 0L};
#line 380 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/get.c"
static int bytes___0  =    0;
#line 439 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/get.c"
static void readfile___0(char *dir , char *fn , char *buf___28 ) 
{ 
  int fd ;
  int c ;
  int i ;
  ssize_t tmp ;
  int *tmp___0 ;

  {
  {
#line 443
  formats(path1___0, (int )(sizeof(path1___0) - 1UL), (char *)"%s/%s", dir, fn);
#line 444
  fd = open((char const   *)(path1___0), 0);
  }
#line 444
  if (fd > -1) {
    {
#line 446
    tmp = read(fd, (void *)buf___28, (size_t )19);
#line 446
    c = (int )tmp;
#line 447
    close(fd);
    }
#line 448
    if (c > 0) {
#line 450
      *(buf___28 + c) = (char )'\000';
#line 451
      i = 0;
      {
#line 451
      while (1) {
        while_continue: /* CIL Label */ ;
#line 451
        if (! (i < c)) {
#line 451
          goto while_break;
        }
#line 453
        if (10 == (int )*(buf___28 + i)) {
#line 455
          *(buf___28 + i) = (char )'\000';
#line 456
          goto while_break;
        }
#line 458
        if ((int )*(buf___28 + i) < 48) {
          {
#line 460
          log_((char *)"readfile:bad value in %s/%s", dir, fn);
#line 461
          *buf___28 = (char )'\000';
          }
#line 462
          return;
        } else
#line 458
        if ((int )*(buf___28 + i) > 57) {
          {
#line 460
          log_((char *)"readfile:bad value in %s/%s", dir, fn);
#line 461
          *buf___28 = (char )'\000';
          }
#line 462
          return;
        }
#line 451
        i ++;
      }
      while_break: /* CIL Label */ ;
      }
#line 465
      return;
    } else {
      {
#line 468
      log_((char *)"readfile:read %s:%m", path1___0);
      }
    }
  } else {
    {
#line 470
    tmp___0 = __errno_location();
    }
#line 470
    if (2 != *tmp___0) {
      {
#line 471
      log_((char *)"readfile:open %s:%m", path1___0);
      }
    }
  }
#line 472
  *buf___28 = (char )'\000';
#line 473
  return;
}
}
#line 543 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/get.c"
static void chldhand___0(int x ) 
{ 


  {
#line 543
  sigchld = (bool )1;
#line 543
  return;
}
}
#line 547 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/get.c"
static void usrhand___0(int u ) 
{ 


  {
#line 549
  sigusr = (bool )1;
#line 550
  if (10 == u) {
#line 552
    if (throttlerate > 1) {
#line 553
      throttlerate /= 2;
    }
  } else
#line 555
  if (12 == u) {
#line 556
    throttlerate *= 2;
  }
#line 557
  return;
}
}
#line 561 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/get.c"
static void fixfd___0(int from , int to ) 
{ 
  int tmp ;

  {
  {
#line 563
  tmp = dup2(from, to);
  }
#line 563
  if (-1 == tmp) {
    {
#line 564
    fail(2, (char *)"Can\'t dup %d to %d:%m", from, to);
    }
  }
#line 565
  return;
}
}
#line 792 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/get.c"
static struct s *servers___0  =    (struct s *)((void *)0);
#line 37 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/group.c"
static int desc___19  =    -1;
#line 59 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/group.c"
static int cmpgroup___6(void *a , void *b___13 ) 
{ 
  struct groupobj *x ;
  struct groupobj *y ;
  int tmp ;

  {
  {
#line 61
  x = (struct groupobj *)a;
#line 62
  y = (struct groupobj *)b___13;
#line 64
  tmp = strcmp((char const   *)x->groupname, (char const   *)y->groupname);
  }
#line 64
  return (tmp);
}
}
#line 67 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/group.c"
static void freegroup___6(void *p ) 
{ 
  struct groupobj *gop ;

  {
#line 69
  gop = (struct groupobj *)p;
#line 71
  if (gop->groupname) {
    {
#line 72
    free((void *)gop->groupname);
    }
  }
#line 73
  if (gop->dir.dir) {
    {
#line 74
    closedir(gop->dir.dir);
    }
  }
#line 75
  if (gop->lastf.f) {
    {
#line 76
    munmap((void *)((caddr_t )gop->lastf.f), sizeof(struct file ));
    }
  }
  {
#line 77
  free(p);
  }
#line 78
  return;
}
}
#line 94 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/group.c"
static int refresh___6(struct groupobj *gop , char *groupname ) 
{ 
  struct stat st ;
  struct dir *d ;
  struct lastf *lp ;
  bool needreread ;
  bool needrefile ;
  bool needreslot ;
  bool isemptygroup ;
  int tmp ;
  int tmp___0 ;
  struct dirent *dp ;
  int i ;
  int first ;
  int last___1 ;
  char *end ;
  int tmp___1 ;
  unsigned short const   **tmp___2 ;
  unsigned long tmp___3 ;
  int fd ;
  void *tmp___4 ;
  struct info *ip ;
  int slot ;

  {
#line 99
  needreread = (bool )0;
#line 100
  needrefile = (bool )0;
#line 101
  needreslot = (bool )0;
#line 102
  isemptygroup = (bool )0;
#line 104
  d = & gop->dir;
#line 105
  lp = & gop->lastf;
#line 107
  if (groupname) {
    {
#line 109
    memset((void *)gop, 0, sizeof(struct groupobj ));
#line 110
    gop->groupname = strdup((char const   *)groupname);
    }
#line 111
    if ((unsigned long )((void *)0) == (unsigned long )gop->groupname) {
      {
#line 113
      log_((char *)"refresh:strdup:%m");
      }
#line 114
      return (-1);
    }
    {
#line 116
    gop->dir.first = -1;
#line 117
    d->dir = opendir((char const   *)groupname);
    }
#line 118
    if ((unsigned long )((void *)0) == (unsigned long )d->dir) {
      {
#line 120
      log_((char *)"refresh:opendir:%m");
      }
#line 121
      return (-1);
    }
#line 123
    lp->name = -1;
#line 125
    needreslot = (bool )1;
#line 125
    needreread = needreslot;
#line 125
    needrefile = needreread;
  } else {
#line 131
    if (-1 == d->first) {
#line 132
      needreread = (bool )1;
    } else
#line 131
    if (0 == d->last) {
#line 132
      needreread = (bool )1;
    } else
#line 131
    if (! d->read) {
#line 132
      needreread = (bool )1;
    } else {
      {
#line 133
      tmp = dirfd(d->dir);
#line 133
      tmp___0 = fstat(tmp, & st);
      }
#line 133
      if (-1 == tmp___0) {
        {
#line 135
        log_((char *)"refresh:fstat:%m");
        }
#line 136
        return (-1);
      } else
#line 138
      if (d->read < st.st_mtim.tv_sec) {
#line 139
        needreread = (bool )1;
      }
    }
#line 140
    if (! lp->f) {
#line 141
      needreslot = (bool )1;
#line 141
      needrefile = needreslot;
    }
#line 142
    if (! needrefile) {
#line 143
      if (! lp->f) {
#line 144
        needrefile = (bool )1;
      }
    }
#line 145
    if (! needrefile) {
#line 146
      if (-1 == lp->name) {
#line 147
        needrefile = (bool )1;
      }
    }
  }
#line 150
  if (needreread) {
#line 150
    goto _L;
  } else
#line 150
  if (needreslot) {
    _L: /* CIL Label */ 
    {
#line 156
    first = -1;
#line 157
    last___1 = 0;
#line 158
    rewinddir(d->dir);
#line 159
    dp = readdir(d->dir);
    }
#line 160
    if ((unsigned long )((void *)0) == (unsigned long )dp) {
      {
#line 162
      log_((char *)"refresh:readdir:%m");
      }
#line 163
      return (-1);
    }
#line 165
    gop->nopost = (bool )0;
    {
#line 166
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 168
      tmp___2 = __ctype_b_loc();
      }
#line 168
      if (! ((int const   )*(*tmp___2 + (int )dp->d_name[0]) & 2048)) {
#line 170
        if (! gop->nopost) {
#line 170
          if (46 == (int )dp->d_name[0]) {
            {
#line 171
            tmp___1 = strcmp((char const   *)(dp->d_name), ".nopost");
            }
#line 171
            if (0 == tmp___1) {
#line 172
              gop->nopost = (bool )1;
            }
          }
        }
#line 173
        goto __Cont;
      }
      {
#line 175
      tmp___3 = strtoul((char const   */* __restrict  */)(dp->d_name), (char **/* __restrict  */)(& end),
                        10);
#line 175
      i = (int )tmp___3;
      }
#line 175
      if (i <= 0) {
#line 176
        goto __Cont;
      } else
#line 175
      if (*end) {
#line 176
        goto __Cont;
      }
#line 177
      if (first > i) {
#line 178
        first = i;
      } else
#line 177
      if (-1 == first) {
#line 178
        first = i;
      }
#line 179
      if (last___1 < i) {
#line 180
        last___1 = i;
      }
      __Cont: /* CIL Label */ 
      {
#line 166
      dp = readdir(d->dir);
      }
#line 166
      if (! dp) {
#line 166
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 183
    d->first = first;
#line 184
    d->last = last___1;
#line 185
    if (-1 == first) {
#line 185
      if (0 == last___1) {
#line 186
        isemptygroup = (bool )1;
      }
    }
#line 187
    if (last___1 != lp->name) {
#line 188
      needrefile = (bool )1;
    } else {
#line 190
      lp->name = last___1;
    }
    {
#line 191
    time(& d->read);
    }
  }
#line 194
  if (needrefile) {
#line 194
    goto _L___0;
  } else
#line 194
  if (needreslot) {
    _L___0: /* CIL Label */ 
#line 198
    if (lp->f) {
      {
#line 200
      munmap((void *)((caddr_t )lp->f), sizeof(struct file ));
#line 201
      lp->f = (struct file *)((void *)0);
      }
    }
#line 203
    if (isemptygroup) {
#line 204
      return (0);
    }
    {
#line 205
    fd = openf(0, 0, (char *)"%s/%d", gop->groupname, d->last);
    }
#line 206
    if (-1 == fd) {
      {
#line 208
      log_((char *)"refresh:open:%m");
      }
#line 209
      return (-1);
    }
    {
#line 211
    tmp___4 = mmap((void *)0, sizeof(struct file ), 1, 1, fd, (__off_t )0);
#line 211
    lp->f = (struct file *)tmp___4;
#line 212
    close(fd);
    }
#line 213
    if ((unsigned long )lp->f == (unsigned long )((void *)-1)) {
      {
#line 215
      log_((char *)"refresh:mmap:%m");
      }
#line 216
      return (-1);
    }
#line 218
    lp->slotsfilled = 0;
#line 219
    needreslot = (bool )1;
  }
#line 222
  if (needreslot) {
#line 224
    ip = (lp->f)->info;
#line 227
    slot = 9;
    {
#line 227
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 227
      if (! (slot > -1)) {
#line 227
        goto while_break___0;
      }
#line 228
      if ((ip + slot)->hoffset) {
#line 229
        goto while_break___0;
      }
#line 227
      slot --;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 230
    lp->slotsfilled = slot + 1;
  }
#line 233
  return (0);
}
}
#line 25 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/lib/wildmat.c"
static int match___1(char *candidate , char *pattern ) ;
#line 27 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/lib/wildmat.c"
static int bracket___1(char *candidate , char *pattern ) 
{ 
  bool negate ;
  char *end ;
  char c ;
  int flag ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;

  {
#line 29
  negate = (bool )0;
#line 32
  pattern ++;
#line 32
  end = pattern;
  {
#line 33
  while (1) {
    while_continue: /* CIL Label */ ;
#line 33
    if (*end) {
#line 33
      if (! (93 != (int )*end)) {
#line 33
        goto while_break;
      }
    } else {
#line 33
      goto while_break;
    }
#line 33
    if (92 == (int )*end) {
#line 33
      end ++;
    }
#line 33
    end ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 34
  if (! *end) {
#line 34
    return (-1);
  }
#line 35
  if (94 == (int )*pattern) {
#line 35
    negate = (bool )1;
#line 35
    pattern ++;
  }
#line 36
  if (45 == (int )*pattern) {
#line 36
    goto isnormalchar;
  }
  {
#line 37
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 37
    if (! *pattern) {
#line 37
      goto while_break___0;
    }
#line 42
    if (92 == (int )*pattern) {
#line 42
      pattern ++;
#line 42
      goto isnormalchar;
    }
#line 43
    if (93 == (int )*pattern) {
      {
#line 43
      tmp = match___1(candidate + 1, end + 1);
      }
#line 43
      return (1 + tmp);
    }
    {
#line 46
    if ((int )*(pattern + 1) == 0) {
#line 46
      goto case_0;
    }
#line 47
    if ((int )*(pattern + 1) == 45) {
#line 47
      goto case_45;
    }
#line 54
    goto isnormalchar;
    case_0: /* CIL Label */ 
#line 46
    return (-1);
    case_45: /* CIL Label */ 
    {
#line 48
    tmp___0 = tolower((int )*candidate);
#line 48
    c = (char )tmp___0;
#line 49
    tmp___1 = tolower((int )*pattern);
    }
#line 49
    if ((int )c >= tmp___1) {
      {
#line 49
      tmp___2 = tolower((int )*(pattern + 2));
      }
#line 49
      if ((int )c <= tmp___2) {
#line 49
        tmp___3 = 1;
      } else {
#line 49
        tmp___3 = 0;
      }
    } else {
#line 49
      tmp___3 = 0;
    }
#line 49
    flag = tmp___3;
#line 50
    if (flag) {
#line 50
      if (negate) {
#line 50
        return (-1);
      } else {
#line 50
        pattern += 2;
      }
    } else
#line 51
    if (negate) {
#line 51
      pattern += 2;
    } else {
#line 51
      return (-1);
    }
#line 52
    goto switch_break;
    isnormalchar: 
    switch_default: /* CIL Label */ 
    {
#line 55
    tmp___6 = tolower((int )*candidate);
#line 55
    tmp___7 = tolower((int )*pattern);
    }
#line 55
    if (tmp___6 == tmp___7) {
#line 57
      if (negate) {
#line 57
        pattern ++;
      } else {
        {
#line 57
        tmp___4 = match___1(candidate + 1, end + 1);
        }
#line 57
        return (1 + tmp___4);
      }
    } else
#line 60
    if (negate) {
      {
#line 60
      tmp___5 = match___1(candidate + 1, end + 1);
      }
#line 60
      return (1 + tmp___5);
    } else {
#line 60
      pattern ++;
    }
    switch_break: /* CIL Label */ ;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 63
  return (-1);
}
}
#line 66 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/lib/wildmat.c"
static int match___1(char *candidate , char *pattern ) 
{ 
  int ret ;
  char *c ;
  int len ;
  int clen ;
  size_t tmp ;
  size_t tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 68
  ret = 0;
  {
#line 72
  while (1) {
    while_continue: /* CIL Label */ ;
#line 74
    if (92 == (int )*pattern) {
#line 74
      goto default_char;
    }
    {
#line 77
    if ((int )*pattern == 0) {
#line 77
      goto case_0;
    }
#line 77
    if ((int )*pattern == 10) {
#line 77
      goto case_0;
    }
#line 77
    if ((int )*pattern == 13) {
#line 77
      goto case_0;
    }
#line 83
    if ((int )*pattern == 42) {
#line 83
      goto case_42;
    }
#line 104
    if ((int )*pattern == 91) {
#line 104
      goto case_91;
    }
#line 106
    if ((int )*pattern == 63) {
#line 106
      goto case_63;
    }
#line 113
    goto switch_default;
    case_0: /* CIL Label */ 
    case_10: /* CIL Label */ 
    case_13: /* CIL Label */ 
    {
#line 80
    if ((int )*candidate == 10) {
#line 80
      goto case_10___0;
    }
#line 80
    if ((int )*candidate == 13) {
#line 80
      goto case_10___0;
    }
#line 80
    if ((int )*candidate == 0) {
#line 80
      goto case_10___0;
    }
#line 78
    goto switch_break___0;
    case_10___0: /* CIL Label */ 
    case_13___0: /* CIL Label */ 
    case_0___0: /* CIL Label */ 
#line 80
    return (ret);
    switch_break___0: /* CIL Label */ ;
    }
#line 82
    return (-1);
    case_42: /* CIL Label */ 
    {
#line 89
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 89
      if (! (42 == (int )*pattern)) {
#line 89
        goto while_break___0;
      }
#line 89
      pattern ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 90
    if (! *pattern) {
      {
#line 90
      tmp = strcspn((char const   *)candidate, "\r\n");
      }
#line 90
      return ((int )((size_t )ret + tmp));
    }
    {
#line 91
    tmp___0 = strcspn((char const   *)candidate, "\r\n");
#line 91
    clen = (int )tmp___0;
#line 92
    c = candidate;
    }
    {
#line 92
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 92
      if (clen) {
#line 92
        if (! *c) {
#line 92
          goto while_break___1;
        }
      } else {
#line 92
        goto while_break___1;
      }
      {
#line 96
      if ((int )*c == 10) {
#line 96
        goto case_10___1;
      }
#line 96
      if ((int )*c == 13) {
#line 96
        goto case_10___1;
      }
#line 94
      goto switch_break___1;
      case_10___1: /* CIL Label */ 
      case_13___1: /* CIL Label */ 
#line 96
      return (-1);
      switch_break___1: /* CIL Label */ ;
      }
      {
#line 98
      len = match___1(c, pattern);
      }
#line 99
      if (len == clen) {
#line 99
        return ((int )((long )len + (c - candidate)));
      }
#line 92
      c ++;
#line 92
      clen --;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 101
    return (-1);
    case_91: /* CIL Label */ 
    {
#line 105
    tmp___1 = bracket___1(candidate, pattern);
    }
#line 105
    return (ret + tmp___1);
    case_63: /* CIL Label */ 
#line 107
    pattern ++;
#line 108
    if (! *candidate) {
#line 108
      return (-1);
    }
#line 109
    ret ++;
#line 109
    candidate ++;
#line 110
    goto while_continue;
    default_char: 
#line 112
    pattern ++;
    switch_default: /* CIL Label */ 
    {
#line 114
    tmp___2 = tolower((int )*pattern);
#line 114
    tmp___3 = tolower((int )*candidate);
    }
#line 114
    if (tmp___2 == tmp___3) {
#line 116
      pattern ++;
#line 116
      candidate ++;
#line 116
      ret ++;
    } else {
#line 119
      return (-1);
    }
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 26 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/key.c"
static struct buf *head___7  ;
#line 27 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/key.c"
static int avail___14  =    0;
#line 28 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/key.c"
static char *keybuf___6  =    (char *)((void *)0);
#line 33 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/key.c"
static unsigned int hv___6  ;
#line 35 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/key.c"
static void hash___14(char *key , int len ) 
{ 
  char *tmp ;

  {
#line 37
  hv___6 = 5381U;
  {
#line 38
  while (1) {
    while_continue: /* CIL Label */ ;
#line 38
    if (! len) {
#line 38
      goto while_break;
    }
#line 40
    len --;
#line 41
    hv___6 += hv___6 << 5;
#line 42
    tmp = key;
#line 42
    key ++;
#line 42
    hv___6 ^= (unsigned int )*tmp;
  }
  while_break: /* CIL Label */ ;
  }
#line 44
  hv___6 %= 128U;
#line 45
  return;
}
}
#line 87 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/cache.c"
static struct entry *new_entry___7(int desc___35 ) 
{ 
  struct entry *ep ;
  struct entry *tmp ;

  {
#line 91
  ep = table[desc___35].freelist;
#line 91
  if (ep) {
#line 92
    table[desc___35].freelist = ep->next;
  } else {
#line 95
    ep = table[desc___35].entries;
    {
#line 95
    while (1) {
      while_continue: /* CIL Label */ ;
#line 95
      if (! ep->next) {
#line 95
        goto while_break;
      }
#line 95
      ep = ep->next;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 96
    (ep->prev)->next = (struct entry *)((void *)0);
#line 97
    (*(table[desc___35].freeobj))(ep->object);
    }
  }
#line 99
  tmp = (struct entry *)((void *)0);
#line 99
  ep->next = tmp;
#line 99
  ep->prev = tmp;
#line 100
  ep->object = (void *)0;
#line 101
  return (ep);
}
}
#line 67 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/store.c"
static int sto_cmp___4(void *a , void *b___13 ) 
{ 
  register struct storeobj *x ;
  register struct storeobj *y ;
  int tmp ;

  {
  {
#line 69
  x = (struct storeobj *)a;
#line 70
  y = (struct storeobj *)b___13;
#line 72
  tmp = strcmp((char const   *)x->filename, (char const   *)y->filename);
  }
#line 72
  return (tmp);
}
}
#line 75 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/store.c"
static int nosigio___4(ssize_t (*op)() , int fd , char *buf___28 , int len ) 
{ 
  int er ;
  int *tmp ;
  ssize_t tmp___0 ;

  {
  {
#line 79
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 79
    tmp___0 = (*op)(fd, buf___28, len);
#line 79
    er = (int )tmp___0;
    }
#line 79
    if (! (-1 == er)) {
#line 79
      goto while_break;
    }
    {
#line 80
    tmp = __errno_location();
    }
#line 80
    if (4 != *tmp) {
#line 82
      if (debug >= 1) {
        {
#line 82
        log_((char *)"nosigio:%m");
        }
      }
#line 83
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 85
  return (er);
}
}
#line 88 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/store.c"
static int copyart___4(int tofd , int fromfd , int fromseek , int len ) 
{ 
  char buf___28[1024] ;
  __off_t tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  {
#line 92
  tmp = lseek(fromfd, (__off_t )fromseek, 0);
  }
#line 92
  if (-1L == tmp) {
    {
#line 94
    log_((char *)"copyart:lseek:%m");
    }
#line 95
    return (-1);
  }
  {
#line 98
  while (1) {
    while_continue: /* CIL Label */ ;
#line 98
    if (! (len > 1024)) {
#line 98
      goto while_break;
    }
    {
#line 99
    tmp___0 = nosigio___4((ssize_t (*)())(& read), fromfd, buf___28, 1024);
    }
#line 99
    if (-1 == tmp___0) {
#line 100
      return (-1);
    } else {
      {
#line 99
      tmp___1 = nosigio___4((ssize_t (*)())(& write), tofd, buf___28, 1024);
      }
#line 99
      if (-1 == tmp___1) {
#line 100
        return (-1);
      }
    }
#line 98
    len -= 1024;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 101
  tmp___2 = nosigio___4((ssize_t (*)())(& read), fromfd, buf___28, len);
  }
#line 101
  if (-1 == tmp___2) {
#line 102
    return (-1);
  } else {
    {
#line 101
    tmp___3 = nosigio___4((ssize_t (*)())(& write), tofd, buf___28, len);
    }
#line 101
    if (-1 == tmp___3) {
#line 102
      return (-1);
    }
  }
#line 104
  return (0);
}
}
#line 107 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/store.c"
static int checkindex___4(struct info *p ) 
{ 


  {
#line 109
  if (p->hoffset > 0) {
#line 111
    if (p->boffset > 0) {
#line 112
      if (p->hlen > 0) {
#line 113
        if (p->blen > 0) {
#line 114
          return (0);
        }
      }
    }
  } else
#line 116
  if (-1 == p->hoffset) {
#line 116
    if (-1 == p->boffset) {
#line 117
      return (1);
    }
  }
#line 118
  return (-1);
}
}
#line 127 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/store.c"
static void reorder___4(struct storeobj *sp ) 
{ 
  char tmpname[287] ;
  char *p ;
  char *q ;
  int fd ;
  struct file f___9 ;
  int er ;
  int i ;
  char *tmp ;
  char tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char tmp___4 ;
  char *tmp___5 ;
  int *tmp___6 ;
  int tmp___7 ;
  char *p___0 ;
  int *tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  __off_t tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  __off_t tmp___17 ;
  __off_t tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;

  {
#line 133
  f___9.magic = 0;
#line 133
  f___9.info[0].hoffset = 0;
#line 133
  f___9.info[0].hlen = 0;
#line 133
  f___9.info[0].boffset = 0;
#line 133
  f___9.info[0].blen = 0;
#line 133
  f___9.info[1].hoffset = 0;
#line 133
  f___9.info[1].hlen = 0;
#line 133
  f___9.info[1].boffset = 0;
#line 133
  f___9.info[1].blen = 0;
#line 133
  f___9.info[2].hoffset = 0;
#line 133
  f___9.info[2].hlen = 0;
#line 133
  f___9.info[2].boffset = 0;
#line 133
  f___9.info[2].blen = 0;
#line 133
  f___9.info[3].hoffset = 0;
#line 133
  f___9.info[3].hlen = 0;
#line 133
  f___9.info[3].boffset = 0;
#line 133
  f___9.info[3].blen = 0;
#line 133
  f___9.info[4].hoffset = 0;
#line 133
  f___9.info[4].hlen = 0;
#line 133
  f___9.info[4].boffset = 0;
#line 133
  f___9.info[4].blen = 0;
#line 133
  f___9.info[5].hoffset = 0;
#line 133
  f___9.info[5].hlen = 0;
#line 133
  f___9.info[5].boffset = 0;
#line 133
  f___9.info[5].blen = 0;
#line 133
  f___9.info[6].hoffset = 0;
#line 133
  f___9.info[6].hlen = 0;
#line 133
  f___9.info[6].boffset = 0;
#line 133
  f___9.info[6].blen = 0;
#line 133
  f___9.info[7].hoffset = 0;
#line 133
  f___9.info[7].hlen = 0;
#line 133
  f___9.info[7].boffset = 0;
#line 133
  f___9.info[7].blen = 0;
#line 133
  f___9.info[8].hoffset = 0;
#line 133
  f___9.info[8].hlen = 0;
#line 133
  f___9.info[8].boffset = 0;
#line 133
  f___9.info[8].blen = 0;
#line 133
  f___9.info[9].hoffset = 0;
#line 133
  f___9.info[9].hlen = 0;
#line 133
  f___9.info[9].boffset = 0;
#line 133
  f___9.info[9].blen = 0;
#line 136
  p = tmpname;
#line 136
  q = sp->filename;
  {
#line 136
  while (1) {
    while_continue: /* CIL Label */ ;
#line 136
    tmp = p;
#line 136
    p ++;
#line 136
    tmp___1 = q;
#line 136
    q ++;
#line 136
    tmp___0 = *tmp___1;
#line 136
    *tmp = tmp___0;
#line 136
    if (! ((int )tmp___0 != 47)) {
#line 136
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 137
  tmp___2 = p;
#line 137
  p ++;
#line 137
  *tmp___2 = (char )'+';
  {
#line 138
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 138
    tmp___3 = p;
#line 138
    p ++;
#line 138
    tmp___5 = q;
#line 138
    q ++;
#line 138
    tmp___4 = *tmp___5;
#line 138
    *tmp___3 = tmp___4;
#line 138
    if (! tmp___4) {
#line 138
      goto while_break___0;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 139
  fd = open((char const   *)(tmpname), 194, 420);
  }
#line 140
  if (-1 == fd) {
    {
#line 142
    tmp___6 = __errno_location();
    }
#line 142
    if (17 != *tmp___6) {
      {
#line 143
      log_((char *)"reorder:open(%s):%m", tmpname);
      }
    }
#line 144
    return;
  }
  {
#line 147
  f___9.magic = 1027296;
#line 148
  tmp___7 = nosigio___4((ssize_t (*)())(& write), fd, (char *)(& f___9), (int )sizeof(f___9));
  }
#line 148
  if (-1 == tmp___7) {
#line 149
    goto fail;
  }
  {
#line 161
  tmp___9 = lockf(sp->fd, 2, (__off_t )0);
  }
#line 161
  if (-1 == tmp___9) {
    {
#line 165
    tmp___8 = __errno_location();
    }
#line 165
    if (11 != *tmp___8) {
#line 166
      p___0 = (char *)"reorder:can\'t lockf %s:%m";
    } else {
#line 168
      p___0 = (char *)"reorder:article in %s being cancelled?";
    }
    {
#line 169
    log_(p___0, sp->filename);
    }
#line 170
    goto fail;
  }
#line 173
  i = 0;
  {
#line 173
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 173
    if (! (i < 10)) {
#line 173
      goto while_break___1;
    }
    {
#line 174
    tmp___10 = checkindex___4((sp->file)->info + i);
    }
    {
#line 176
    if (tmp___10 == 0) {
#line 176
      goto case_0;
    }
#line 188
    if (tmp___10 == 1) {
#line 188
      goto case_1;
    }
#line 191
    if (tmp___10 == -1) {
#line 191
      goto case_neg_1;
    }
#line 174
    goto switch_break;
    case_0: /* CIL Label */ 
    {
#line 177
    tmp___12 = lseek(fd, (__off_t )0, 2);
#line 177
    tmp___11 = (int )tmp___12;
#line 177
    f___9.info[i].hoffset = tmp___11;
    }
#line 177
    if (tmp___11 > 0) {
      {
#line 179
      f___9.info[i].hlen = (sp->file)->info[i].hlen;
#line 180
      f___9.info[i].blen = (sp->file)->info[i].blen;
#line 181
      er = copyart___4(fd, sp->fd, (sp->file)->info[i].hoffset, f___9.info[i].hlen);
      }
#line 182
      if (0 == er) {
#line 183
        goto switch_break;
      }
    } else {
      {
#line 186
      log_((char *)"reorder:lseek(%s):%m", tmpname);
      }
    }
#line 187
    goto fail;
    case_1: /* CIL Label */ 
#line 189
    tmp___15 = -1;
#line 189
    f___9.info[i].hlen = tmp___15;
#line 189
    tmp___14 = tmp___15;
#line 189
    f___9.info[i].blen = tmp___14;
#line 189
    tmp___13 = tmp___14;
#line 189
    f___9.info[i].hoffset = tmp___13;
#line 189
    f___9.info[i].boffset = tmp___13;
#line 190
    goto switch_break;
    case_neg_1: /* CIL Label */ 
    {
#line 192
    log_((char *)"reorder:corrupt index in %s", sp->filename);
    }
#line 193
    goto fail;
    switch_break: /* CIL Label */ ;
    }
#line 173
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 195
  i = 0;
  {
#line 195
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 195
    if (! (i < 10)) {
#line 195
      goto while_break___2;
    }
#line 197
    if (-1 == f___9.info[i].boffset) {
#line 198
      goto __Cont;
    }
    {
#line 199
    tmp___17 = lseek(fd, (__off_t )0, 2);
#line 199
    tmp___16 = (int )tmp___17;
#line 199
    f___9.info[i].boffset = tmp___16;
    }
#line 199
    if (-1 == tmp___16) {
      {
#line 201
      log_((char *)"reorder:lseek(%s):%m", tmpname);
      }
#line 202
      goto fail;
    }
    {
#line 204
    er = copyart___4(fd, sp->fd, (sp->file)->info[i].boffset, f___9.info[i].blen);
    }
#line 205
    if (-1 == er) {
#line 206
      goto fail;
    }
    __Cont: /* CIL Label */ 
#line 195
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 209
  tmp___18 = lseek(fd, (__off_t )0, 0);
  }
#line 209
  if (-1L == tmp___18) {
    {
#line 211
    log_((char *)"reorder:lseek:%m");
    }
#line 212
    goto fail;
  }
  {
#line 214
  tmp___19 = nosigio___4((ssize_t (*)())(& write), fd, (char *)(& f___9), (int )sizeof(f___9));
  }
#line 214
  if (-1 == tmp___19) {
#line 215
    goto fail;
  }
  {
#line 216
  tmp___20 = rename((char const   *)(tmpname), (char const   *)sp->filename);
  }
#line 216
  if (-1 == tmp___20) {
    {
#line 218
    log_((char *)"reorder:rename:%m");
    }
#line 219
    goto fail;
  }
  {
#line 221
  close(fd);
  }
#line 222
  return;
  fail: 
  {
#line 225
  log_((char *)"reorder:write failed for %s:%m", sp->filename);
#line 226
  tmp___21 = unlink((char const   *)(tmpname));
  }
#line 226
  if (-1 == tmp___21) {
    {
#line 227
    log_((char *)"reorder:unlink(%s):%m", tmpname);
    }
  }
  {
#line 228
  close(fd);
  }
#line 229
  return;
}
}
#line 231 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/store.c"
static void sto_free___4(void *p ) 
{ 
  struct storeobj *sp ;
  int tmp ;

  {
  {
#line 233
  sp = (struct storeobj *)p;
#line 235
  close(sp->fd);
#line 236
  tmp = munmap((void *)((caddr_t )sp->file), sizeof(struct file ));
  }
#line 236
  if (-1 == tmp) {
    {
#line 237
    log_((char *)"sto_free:munmap:%m");
    }
  }
  {
#line 238
  free((void *)sp);
  }
#line 239
  return;
}
}
#line 241 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/store.c"
static int desc___20  ;
#line 304
static int tryopen___4(char *fn ) ;
#line 304 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/store.c"
static struct file f___4  =    {1027296, {{0, 0, 0, 0}}};
#line 270 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/store.c"
static int tryopen___4(char *fn ) 
{ 
  char fn2[287] ;
  int fd ;
  int i ;
  char *p ;
  char *q ;
  struct timeval tv ;
  char *tmp ;
  char tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  ssize_t tmp___7 ;

  {
  {
#line 278
  fd = open((char const   *)fn, 2);
  }
#line 278
  if (fd > -1) {
    {
#line 280
    lockf(fd, 1, (__off_t )0);
    }
#line 281
    return (fd);
  }
#line 283
  p = fn2;
#line 283
  q = fn;
  {
#line 283
  while (1) {
    while_continue: /* CIL Label */ ;
#line 283
    tmp = p;
#line 283
    p ++;
#line 283
    tmp___1 = q;
#line 283
    q ++;
#line 283
    tmp___0 = *tmp___1;
#line 283
    *tmp = tmp___0;
#line 283
    if (! ((int )tmp___0 != 47)) {
#line 283
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 284
  tmp___2 = p;
#line 284
  p ++;
#line 284
  *tmp___2 = (char )'+';
#line 285
  tmp___3 = p;
#line 285
  p ++;
#line 285
  *tmp___3 = (char )'+';
#line 286
  gettimeofday((struct timeval */* __restrict  */)(& tv), (__timezone_ptr_t )0);
#line 296
  i = (int )(tv.tv_sec / 30L);
  }
  {
#line 297
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 298
    tmp___4 = p;
#line 298
    p ++;
#line 298
    *tmp___4 = (char )(48 + i % 10);
#line 297
    i /= 10;
#line 297
    if (! i) {
#line 297
      goto while_break___0;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 300
  tmp___5 = p;
#line 300
  p ++;
#line 300
  *tmp___5 = (char )'\000';
#line 302
  i = 0;
  {
#line 302
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 302
    if (! (i < 100)) {
#line 302
      goto while_break___1;
    }
#line 306
    if (14 == i % 15) {
      {
#line 307
      log_((char *)"tryopen:racing on %s", fn);
      }
    }
    {
#line 308
    fd = open((char const   *)(fn2), 194, 420);
    }
#line 308
    if (fd > -1) {
      {
#line 310
      lockf(fd, 1, (__off_t )0);
#line 311
      tmp___7 = write(fd, (void const   *)((char *)(& f___4)), sizeof(f___4));
      }
#line 311
      if (sizeof(f___4) == (unsigned long )tmp___7) {
        {
#line 312
        tmp___6 = link((char const   *)(fn2), (char const   *)fn);
        }
#line 312
        if (0 == tmp___6) {
          {
#line 314
          unlink((char const   *)(fn2));
          }
#line 315
          return (fd);
        }
      }
      {
#line 317
      close(fd);
#line 318
      unlink((char const   *)(fn2));
      }
    }
    {
#line 321
    fd = open((char const   *)fn, 2);
    }
#line 321
    if (fd > -1) {
      {
#line 323
      lockf(fd, 1, (__off_t )0);
      }
#line 324
      return (fd);
    }
    {
#line 302
    nap(0, 300 + i);
#line 302
    i ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 327
  log_((char *)"tryopen:timed out opening %s:%m", fn);
  }
#line 328
  return (-1);
}
}
#line 337 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/store.c"
static struct storeobj *getstore___4(char *filename ) 
{ 
  struct storeobj *sp ;
  struct storeobj s ;
  int fd ;
  struct file *fp ;
  char buf___28[287] ;
  int c ;
  void *tmp ;
  void *tmp___0 ;
  char *p ;
  char *q ;
  char *tmp___1 ;
  char tmp___2 ;
  char *tmp___3 ;
  char *end ;
  unsigned long tmp___4 ;
  ssize_t tmp___5 ;
  size_t tmp___6 ;
  void *tmp___7 ;

  {
  {
#line 349
  s.filename = filename;
#line 350
  tmp = cache_find(desc___20, (void *)(& s));
#line 350
  sp = (struct storeobj *)tmp;
  }
#line 350
  if (sp) {
    {
#line 352
    lockf(sp->fd, 1, (__off_t )0);
    }
#line 353
    return (sp);
  }
  {
#line 356
  fd = tryopen___4(filename);
  }
#line 356
  if (-1 == fd) {
#line 357
    return ((struct storeobj *)0);
  }
  {
#line 361
  tmp___0 = mmap((void *)0, sizeof(*fp), 3, 1, fd, (__off_t )0);
#line 361
  fp = (struct file *)tmp___0;
  }
#line 362
  if (! fp) {
    {
#line 363
    log_((char *)"getstore:mmap(%s):%m", filename);
    }
  } else
#line 362
  if ((unsigned long )fp == (unsigned long )((void *)-1)) {
    {
#line 363
    log_((char *)"getstore:mmap(%s):%m", filename);
    }
  } else {
    {
#line 364
    tmp___6 = strlen((char const   *)filename);
#line 364
    tmp___7 = malloc((sizeof(*sp) + tmp___6) + 1UL);
#line 364
    sp = (struct storeobj *)tmp___7;
    }
#line 364
    if (sp) {
      {
#line 371
      sp->fd = fd;
#line 372
      sp->file = fp;
#line 373
      sp->filename = (char *)sp + sizeof(*sp);
#line 374
      strcpy((char */* __restrict  */)sp->filename, (char const   */* __restrict  */)filename);
#line 380
      p = buf___28;
#line 380
      q = filename;
      }
      {
#line 380
      while (1) {
        while_continue: /* CIL Label */ ;
#line 380
        tmp___1 = p;
#line 380
        p ++;
#line 380
        tmp___3 = q;
#line 380
        q ++;
#line 380
        tmp___2 = *tmp___3;
#line 380
        *tmp___1 = tmp___2;
#line 380
        if (! ((int )tmp___2 != 47)) {
#line 380
          goto while_break;
        }
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 381
      strcpy((char */* __restrict  */)p, (char const   */* __restrict  */)".compress");
#line 383
      fd = open((char const   *)(buf___28), 0);
      }
#line 383
      if (fd > -1) {
        {
#line 385
        sp->compressok = 1024;
#line 386
        tmp___5 = read(fd, (void *)(buf___28), sizeof(buf___28) - 1UL);
#line 386
        c = (int )tmp___5;
        }
#line 386
        if (c > 0) {
          {
#line 390
          buf___28[c] = (char )'\000';
#line 391
          tmp___4 = strtoul((char const   */* __restrict  */)(buf___28), (char **/* __restrict  */)(& end),
                            10);
#line 391
          c = (int )tmp___4;
          }
#line 392
          if (c > 1024) {
#line 392
            if (10 == (int )*end) {
#line 393
              sp->compressok = c;
            }
          }
        }
        {
#line 395
        close(fd);
        }
      } else {
#line 399
        sp->compressok = 0;
      }
      {
#line 400
      cache_insert(desc___20, (void *)sp);
      }
#line 401
      return (sp);
    } else {
      {
#line 366
      log_((char *)"getstore:no memory");
#line 367
      munmap((void *)fp, sizeof(*fp));
      }
    }
  }
  {
#line 403
  close(fd);
  }
#line 404
  return ((struct storeobj *)0);
}
}
#line 37 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/group.c"
static int desc___21  =    -1;
#line 59 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/group.c"
static int cmpgroup___7(void *a , void *b___13 ) 
{ 
  struct groupobj *x ;
  struct groupobj *y ;
  int tmp ;

  {
  {
#line 61
  x = (struct groupobj *)a;
#line 62
  y = (struct groupobj *)b___13;
#line 64
  tmp = strcmp((char const   *)x->groupname, (char const   *)y->groupname);
  }
#line 64
  return (tmp);
}
}
#line 67 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/group.c"
static void freegroup___7(void *p ) 
{ 
  struct groupobj *gop ;

  {
#line 69
  gop = (struct groupobj *)p;
#line 71
  if (gop->groupname) {
    {
#line 72
    free((void *)gop->groupname);
    }
  }
#line 73
  if (gop->dir.dir) {
    {
#line 74
    closedir(gop->dir.dir);
    }
  }
#line 75
  if (gop->lastf.f) {
    {
#line 76
    munmap((void *)((caddr_t )gop->lastf.f), sizeof(struct file ));
    }
  }
  {
#line 77
  free(p);
  }
#line 78
  return;
}
}
#line 94 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/group.c"
static int refresh___7(struct groupobj *gop , char *groupname ) 
{ 
  struct stat st ;
  struct dir *d ;
  struct lastf *lp ;
  bool needreread ;
  bool needrefile ;
  bool needreslot ;
  bool isemptygroup ;
  int tmp ;
  int tmp___0 ;
  struct dirent *dp ;
  int i ;
  int first ;
  int last___1 ;
  char *end ;
  int tmp___1 ;
  unsigned short const   **tmp___2 ;
  unsigned long tmp___3 ;
  int fd ;
  void *tmp___4 ;
  struct info *ip ;
  int slot ;

  {
#line 99
  needreread = (bool )0;
#line 100
  needrefile = (bool )0;
#line 101
  needreslot = (bool )0;
#line 102
  isemptygroup = (bool )0;
#line 104
  d = & gop->dir;
#line 105
  lp = & gop->lastf;
#line 107
  if (groupname) {
    {
#line 109
    memset((void *)gop, 0, sizeof(struct groupobj ));
#line 110
    gop->groupname = strdup((char const   *)groupname);
    }
#line 111
    if ((unsigned long )((void *)0) == (unsigned long )gop->groupname) {
      {
#line 113
      log_((char *)"refresh:strdup:%m");
      }
#line 114
      return (-1);
    }
    {
#line 116
    gop->dir.first = -1;
#line 117
    d->dir = opendir((char const   *)groupname);
    }
#line 118
    if ((unsigned long )((void *)0) == (unsigned long )d->dir) {
      {
#line 120
      log_((char *)"refresh:opendir:%m");
      }
#line 121
      return (-1);
    }
#line 123
    lp->name = -1;
#line 125
    needreslot = (bool )1;
#line 125
    needreread = needreslot;
#line 125
    needrefile = needreread;
  } else {
#line 131
    if (-1 == d->first) {
#line 132
      needreread = (bool )1;
    } else
#line 131
    if (0 == d->last) {
#line 132
      needreread = (bool )1;
    } else
#line 131
    if (! d->read) {
#line 132
      needreread = (bool )1;
    } else {
      {
#line 133
      tmp = dirfd(d->dir);
#line 133
      tmp___0 = fstat(tmp, & st);
      }
#line 133
      if (-1 == tmp___0) {
        {
#line 135
        log_((char *)"refresh:fstat:%m");
        }
#line 136
        return (-1);
      } else
#line 138
      if (d->read < st.st_mtim.tv_sec) {
#line 139
        needreread = (bool )1;
      }
    }
#line 140
    if (! lp->f) {
#line 141
      needreslot = (bool )1;
#line 141
      needrefile = needreslot;
    }
#line 142
    if (! needrefile) {
#line 143
      if (! lp->f) {
#line 144
        needrefile = (bool )1;
      }
    }
#line 145
    if (! needrefile) {
#line 146
      if (-1 == lp->name) {
#line 147
        needrefile = (bool )1;
      }
    }
  }
#line 150
  if (needreread) {
#line 150
    goto _L;
  } else
#line 150
  if (needreslot) {
    _L: /* CIL Label */ 
    {
#line 156
    first = -1;
#line 157
    last___1 = 0;
#line 158
    rewinddir(d->dir);
#line 159
    dp = readdir(d->dir);
    }
#line 160
    if ((unsigned long )((void *)0) == (unsigned long )dp) {
      {
#line 162
      log_((char *)"refresh:readdir:%m");
      }
#line 163
      return (-1);
    }
#line 165
    gop->nopost = (bool )0;
    {
#line 166
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 168
      tmp___2 = __ctype_b_loc();
      }
#line 168
      if (! ((int const   )*(*tmp___2 + (int )dp->d_name[0]) & 2048)) {
#line 170
        if (! gop->nopost) {
#line 170
          if (46 == (int )dp->d_name[0]) {
            {
#line 171
            tmp___1 = strcmp((char const   *)(dp->d_name), ".nopost");
            }
#line 171
            if (0 == tmp___1) {
#line 172
              gop->nopost = (bool )1;
            }
          }
        }
#line 173
        goto __Cont;
      }
      {
#line 175
      tmp___3 = strtoul((char const   */* __restrict  */)(dp->d_name), (char **/* __restrict  */)(& end),
                        10);
#line 175
      i = (int )tmp___3;
      }
#line 175
      if (i <= 0) {
#line 176
        goto __Cont;
      } else
#line 175
      if (*end) {
#line 176
        goto __Cont;
      }
#line 177
      if (first > i) {
#line 178
        first = i;
      } else
#line 177
      if (-1 == first) {
#line 178
        first = i;
      }
#line 179
      if (last___1 < i) {
#line 180
        last___1 = i;
      }
      __Cont: /* CIL Label */ 
      {
#line 166
      dp = readdir(d->dir);
      }
#line 166
      if (! dp) {
#line 166
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 183
    d->first = first;
#line 184
    d->last = last___1;
#line 185
    if (-1 == first) {
#line 185
      if (0 == last___1) {
#line 186
        isemptygroup = (bool )1;
      }
    }
#line 187
    if (last___1 != lp->name) {
#line 188
      needrefile = (bool )1;
    } else {
#line 190
      lp->name = last___1;
    }
    {
#line 191
    time(& d->read);
    }
  }
#line 194
  if (needrefile) {
#line 194
    goto _L___0;
  } else
#line 194
  if (needreslot) {
    _L___0: /* CIL Label */ 
#line 198
    if (lp->f) {
      {
#line 200
      munmap((void *)((caddr_t )lp->f), sizeof(struct file ));
#line 201
      lp->f = (struct file *)((void *)0);
      }
    }
#line 203
    if (isemptygroup) {
#line 204
      return (0);
    }
    {
#line 205
    fd = openf(0, 0, (char *)"%s/%d", gop->groupname, d->last);
    }
#line 206
    if (-1 == fd) {
      {
#line 208
      log_((char *)"refresh:open:%m");
      }
#line 209
      return (-1);
    }
    {
#line 211
    tmp___4 = mmap((void *)0, sizeof(struct file ), 1, 1, fd, (__off_t )0);
#line 211
    lp->f = (struct file *)tmp___4;
#line 212
    close(fd);
    }
#line 213
    if ((unsigned long )lp->f == (unsigned long )((void *)-1)) {
      {
#line 215
      log_((char *)"refresh:mmap:%m");
      }
#line 216
      return (-1);
    }
#line 218
    lp->slotsfilled = 0;
#line 219
    needreslot = (bool )1;
  }
#line 222
  if (needreslot) {
#line 224
    ip = (lp->f)->info;
#line 227
    slot = 9;
    {
#line 227
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 227
      if (! (slot > -1)) {
#line 227
        goto while_break___0;
      }
#line 228
      if ((ip + slot)->hoffset) {
#line 229
        goto while_break___0;
      }
#line 227
      slot --;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 230
    lp->slotsfilled = slot + 1;
  }
#line 233
  return (0);
}
}
#line 33 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/art.c"
static size_t pagesize___23  =    (size_t )0;
#line 80 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/art.c"
static void file_unmap___7(void *p ) 
{ 
  struct fileobj *fp ;

  {
  {
#line 82
  fp = (struct fileobj *)p;
#line 84
  munmap((void *)fp->map, (size_t )fp->size);
#line 85
  free((void *)fp);
  }
#line 86
  return;
}
}
#line 88 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/art.c"
static int file_cmp___7(void *a , void *b___13 ) 
{ 
  struct fileobj *x ;
  struct fileobj *y ;
  int tmp ;

  {
  {
#line 90
  x = (struct fileobj *)a;
#line 91
  y = (struct fileobj *)b___13;
#line 93
  tmp = strcmp((char const   *)x->path, (char const   *)y->path);
  }
#line 93
  return (tmp);
}
}
#line 96 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/art.c"
static int desc___22  =    -1;
#line 98 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/art.c"
static int file_init___7(void) 
{ 


  {
  {
#line 100
  desc___22 = cache_init(8, & file_cmp___7, & file_unmap___7, (int (*)(void * ))((void *)0));
  }
#line 101
  if (-1 == desc___22) {
    {
#line 103
    log_((char *)"file_init:%m");
    }
#line 104
    return (-1);
  }
#line 106
  return (0);
}
}
#line 109 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/art.c"
static struct file *file_gimme___7(char *name , int *size___1 ) 
{ 
  struct fileobj f___9 ;
  struct fileobj *fp ;
  void *tmp ;

  {
  {
#line 111
  f___9.path = (char *)0;
#line 111
  f___9.map = (char *)0;
#line 111
  f___9.size = 0;
#line 114
  f___9.path = name;
#line 116
  tmp = cache_find(desc___22, (void *)(& f___9));
#line 116
  fp = (struct fileobj *)tmp;
  }
#line 116
  if ((unsigned long )((void *)0) == (unsigned long )fp) {
    {
#line 118
    fp = file_map(name);
    }
#line 118
    if ((unsigned long )((void *)0) == (unsigned long )fp) {
#line 119
      return ((struct file *)((void *)0));
    } else {
      {
#line 121
      cache_insert(desc___22, (void *)fp);
      }
    }
  }
#line 124
  if (size___1) {
#line 125
    *size___1 = fp->size;
  }
#line 126
  return ((struct file *)fp->map);
}
}
#line 137 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/art.c"
static bool file_initialized___7  =    (bool )0;
#line 248 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/art.c"
static char ngroup___7[287]  ;
#line 297 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/art.c"
static int getfield___7(char *buf___28 , struct field *f___9 ) 
{ 
  register char *cp ;
  size_t tmp ;
  size_t tmp___0 ;

  {
  {
#line 299
  cp = buf___28;
#line 301
  tmp = strspn((char const   *)cp, " \t\f");
#line 301
  cp += tmp;
  }
#line 302
  if (! *cp) {
#line 304
    f___9->pointer = (char *)((void *)0);
#line 305
    return (0);
  }
  {
#line 307
  tmp___0 = strcspn((char const   *)cp, "\r\n");
#line 307
  f___9->len = (int )tmp___0;
  }
#line 308
  if (! f___9->len) {
#line 309
    return (0);
  }
#line 310
  f___9->pointer = cp;
#line 311
  return ((int )((cp + f___9->len) - buf___28));
}
}
#line 383 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/art.c"
static struct b b___8  =    {(char *)0, 0, 0};
#line 105 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/dh_find.c"
static int initfile___15(void) 
{ 
  int fd ;
  int integer ;
  int i ;
  char foo[3] ;
  unsigned int tmp ;
  int *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  ssize_t tmp___3 ;
  ssize_t tmp___4 ;

  {
#line 108
  integer = 218885376;
#line 110
  foo[0] = (char )'\000';
#line 110
  tmp = 1U;
  {
#line 110
  while (1) {
    while_continue: /* CIL Label */ ;
#line 110
    if (tmp >= 3U) {
#line 110
      goto while_break;
    }
#line 110
    foo[tmp] = (char)0;
#line 110
    tmp ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 112
  fd = open((char const   *)(dh_tablefile), 194, 420);
  }
#line 113
  if (fd == -1) {
#line 114
    return (-1);
  }
  {
#line 115
  tmp___2 = lockf(fd, 2, (__off_t )0);
  }
#line 115
  if (tmp___2 == -1) {
    {
#line 117
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 119
      tmp___0 = __errno_location();
      }
#line 119
      if (*tmp___0 == 11) {
        {
#line 120
        nap(0, 200);
        }
      } else {
#line 122
        goto fail;
      }
      {
#line 117
      tmp___1 = lockf(fd, 2, (__off_t )0);
      }
#line 117
      if (! (tmp___1 == -1)) {
#line 117
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 125
    lockf(fd, 0, (__off_t )0);
    }
#line 126
    return (fd);
  }
  {
#line 128
  tmp___3 = write(fd, (void const   *)(& integer), sizeof(int ));
  }
#line 128
  if ((unsigned long )tmp___3 != sizeof(int )) {
#line 129
    goto fail;
  }
#line 130
  i = 0;
  {
#line 130
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 130
    if (! (i < 10240)) {
#line 130
      goto while_break___1;
    }
    {
#line 131
    tmp___4 = write(fd, (void const   *)(foo), sizeof(foo));
    }
#line 131
    if ((unsigned long )tmp___4 != sizeof(foo)) {
#line 132
      goto fail;
    }
#line 130
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 133
  lseek(fd, (__off_t )0, 0);
#line 134
  lockf(fd, 0, (__off_t )0);
  }
#line 135
  return (fd);
  fail: 
#line 138
  if (fd > -1) {
    {
#line 139
    close(fd);
    }
  }
#line 140
  return (-1);
}
}
#line 78 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/allocate.c"
static struct table___1 table___8  =    {(char *)0, (char *)0, 0, 0, 0, 0};
#line 80
static int remapfile___7(void) ;
#line 106 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/allocate.c"
static int initfile___16(char *filename ) 
{ 
  struct chainfile cf ;
  int fd ;
  int i ;
  int ret ;
  ssize_t tmp ;
  int pad ;
  ssize_t tmp___0 ;

  {
  {
#line 108
  cf.chain_magic = 0;
#line 108
  cf.next[0] = 0;
#line 108
  cf.next[1] = 0;
#line 108
  cf.next[2] = 0;
#line 108
  cf.next[3] = 0;
#line 108
  cf.next[4] = 0;
#line 108
  cf.next[5] = 0;
#line 108
  cf.next[6] = 0;
#line 108
  cf.next[7] = 0;
#line 108
  cf.next[8] = 0;
#line 108
  cf.next[9] = 0;
#line 108
  cf.next[10] = 0;
#line 108
  cf.next[11] = 0;
#line 108
  cf.next[12] = 0;
#line 108
  cf.next[13] = 0;
#line 108
  cf.next[14] = 0;
#line 108
  cf.next[15] = 0;
#line 108
  cf.next[16] = 0;
#line 108
  cf.next[17] = 0;
#line 108
  cf.next[18] = 0;
#line 108
  cf.next[19] = 0;
#line 108
  cf.next[20] = 0;
#line 108
  cf.next[21] = 0;
#line 108
  cf.next[22] = 0;
#line 108
  cf.next[23] = 0;
#line 108
  cf.next[24] = 0;
#line 108
  cf.next[25] = 0;
#line 108
  cf.next[26] = 0;
#line 108
  cf.next[27] = 0;
#line 108
  cf.next[28] = 0;
#line 108
  cf.next[29] = 0;
#line 108
  cf.next[30] = 0;
#line 108
  cf.next[31] = 0;
#line 108
  cf.next[32] = 0;
#line 108
  cf.next[33] = 0;
#line 108
  cf.next[34] = 0;
#line 108
  cf.next[35] = 0;
#line 108
  cf.next[36] = 0;
#line 108
  cf.next[37] = 0;
#line 108
  cf.next[38] = 0;
#line 108
  cf.next[39] = 0;
#line 108
  cf.next[40] = 0;
#line 108
  cf.next[41] = 0;
#line 108
  cf.next[42] = 0;
#line 108
  cf.next[43] = 0;
#line 108
  cf.next[44] = 0;
#line 108
  cf.next[45] = 0;
#line 108
  cf.next[46] = 0;
#line 108
  cf.next[47] = 0;
#line 108
  cf.next[48] = 0;
#line 108
  cf.next[49] = 0;
#line 108
  cf.next[50] = 0;
#line 108
  cf.next[51] = 0;
#line 108
  cf.next[52] = 0;
#line 108
  cf.next[53] = 0;
#line 108
  cf.next[54] = 0;
#line 108
  cf.next[55] = 0;
#line 108
  cf.next[56] = 0;
#line 108
  cf.next[57] = 0;
#line 108
  cf.next[58] = 0;
#line 108
  cf.next[59] = 0;
#line 108
  cf.next[60] = 0;
#line 108
  cf.next[61] = 0;
#line 108
  cf.next[62] = 0;
#line 111
  ret = 0;
#line 113
  fd = open((char const   *)filename, 578, 420);
  }
#line 114
  if (-1 == fd) {
#line 115
    return (-1);
  }
#line 116
  cf.chain_magic = 13680336;
#line 117
  i = 0;
  {
#line 117
  while (1) {
    while_continue: /* CIL Label */ ;
#line 117
    if (! (i < 63)) {
#line 117
      goto while_break;
    }
#line 118
    cf.next[i] = (int volatile   )0;
#line 117
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 119
  tmp = write(fd, (void const   *)(& cf), sizeof(cf));
#line 119
  i = (int )tmp;
  }
#line 120
  if ((unsigned long )i == sizeof(cf)) {
#line 124
    pad = (int )(sizeof(cf) % 4UL);
#line 125
    if (pad > 0) {
#line 126
      i = 0;
      {
#line 126
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 126
        if (i < pad) {
#line 126
          if (! (0 == ret)) {
#line 126
            goto while_break___0;
          }
        } else {
#line 126
          goto while_break___0;
        }
        {
#line 127
        tmp___0 = write(fd, (void const   *)"", (size_t )1);
        }
#line 127
        if (1L != tmp___0) {
#line 128
          ret = -1;
        }
#line 126
        i ++;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
  } else {
#line 131
    ret = -1;
  }
  {
#line 132
  close(fd);
  }
#line 133
  return (ret);
}
}
#line 136 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/allocate.c"
static void unmapfile___7(void) 
{ 


  {
#line 138
  if (table___8.fd >= 0) {
    {
#line 140
    close(table___8.fd);
#line 141
    table___8.fd = -1;
    }
  }
#line 143
  if (table___8.map) {
    {
#line 145
    munmap((void *)table___8.map, (size_t )table___8.size);
#line 146
    table___8.map = (char *)((void *)0);
#line 147
    table___8.size = 0;
    }
  }
#line 149
  return;
}
}
#line 153
static size_t rounduptopagesize___7(size_t size___1 ) ;
#line 153 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/allocate.c"
static size_t pagesize___24  =    (size_t )0;
#line 151 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/allocate.c"
static size_t rounduptopagesize___7(size_t size___1 ) 
{ 
  int pages ;
  int tmp ;

  {
#line 156
  if (0UL == pagesize___24) {
    {
#line 157
    tmp = getpagesize();
#line 157
    pagesize___24 = (size_t )tmp;
    }
  }
#line 158
  pages = (int )(size___1 / pagesize___24 + 1UL);
#line 159
  return ((size_t )pages * pagesize___24);
}
}
#line 162 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/allocate.c"
static int mapfile___7(void) 
{ 
  struct stat st ;
  int tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;

  {
#line 166
  if (-1 == table___8.fd) {
    {
#line 167
    table___8.fd = open((char const   *)table___8.filename, table___8.oflag, 420);
    }
  }
#line 168
  if (-1 == table___8.fd) {
#line 169
    goto fail;
  }
  {
#line 171
  tmp = fstat(table___8.fd, & st);
  }
#line 171
  if (-1 == tmp) {
#line 172
    goto fail;
  }
  {
#line 173
  tmp___0 = rounduptopagesize___7((size_t )st.st_size);
#line 173
  table___8.size = (int )tmp___0;
#line 174
  tmp___1 = mmap((void *)0, (size_t )table___8.size, table___8.mprot, 1, table___8.fd,
                 (__off_t )0);
#line 174
  table___8.map = (char *)tmp___1;
  }
#line 175
  if (! table___8.map) {
#line 176
    goto fail;
  } else
#line 175
  if ((unsigned long )table___8.map == (unsigned long )((void *)-1)) {
#line 176
    goto fail;
  }
#line 178
  return (0);
  fail: 
  {
#line 181
  unmapfile___7();
  }
#line 182
  return (-1);
}
}
#line 189 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/allocate.c"
static int remapfile___7(void) 
{ 
  struct stat st ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 193
  tmp = fstat(table___8.fd, & st);
  }
#line 193
  if (-1 == tmp) {
#line 194
    return (-1);
  }
#line 196
  if (st.st_size <= (__off_t )table___8.size) {
#line 197
    return (0);
  }
  {
#line 199
  munmap((void *)table___8.map, (size_t )table___8.size);
#line 200
  tmp___0 = mapfile___7();
  }
#line 200
  return (tmp___0);
}
}
#line 209 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/allocate.c"
static int lock___7(void) 
{ 
  int *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 211
  tmp___2 = lockf(table___8.fd, 2, (__off_t )0);
  }
#line 211
  if (-1 == tmp___2) {
    {
#line 213
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 215
      tmp = __errno_location();
      }
#line 215
      if (11 != *tmp) {
#line 216
        return (-1);
      } else {
        {
#line 218
        nap(0, 200);
        }
      }
      {
#line 213
      tmp___0 = lockf(table___8.fd, 2, (__off_t )0);
      }
#line 213
      if (! (-1 == tmp___0)) {
#line 213
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 221
    tmp___1 = remapfile___7();
    }
#line 221
    if (-1 == tmp___1) {
#line 222
      return (-1);
    }
  }
#line 224
  return (0);
}
}
#line 227 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/allocate.c"
static void unlock___7(void) 
{ 


  {
  {
#line 229
  lseek(table___8.fd, (__off_t )0, 0);
#line 230
  lockf(table___8.fd, 0, (__off_t )0);
  }
#line 231
  return;
}
}
#line 233 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/allocate.c"
static int checkvalidfile___7(void) 
{ 


  {
#line 235
  if (table___8.size > 0) {
#line 237
    if ((unsigned long )table___8.size < sizeof(struct chainfile )) {
#line 238
      return (-1);
    }
#line 239
    if (((struct chainfile *)table___8.map)->chain_magic != 13680336) {
#line 240
      return (-1);
    }
  }
#line 242
  return (0);
}
}
#line 281 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/allocate.c"
static int rounduptoalignment___7(int size___1 ) 
{ 


  {
#line 283
  if (size___1 <= 0) {
#line 284
    return (4);
  }
#line 285
  return (((size___1 - 1) / 4 + 1) * 4);
}
}
#line 296 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/allocate.c"
static char tmpchunk___7[272]  = {      (char )'\000'};
#line 56 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/dhash.c"
static unsigned char buf___18[2]  ;
#line 54 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/dhash.c"
static char *inttochar2___7(int integer ) 
{ 


  {
#line 58
  buf___18[0] = (unsigned char )((integer & 65535) >> 8);
#line 59
  buf___18[1] = (unsigned char )(integer & 255);
#line 60
  return ((char *)(buf___18));
}
}
#line 65 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/dhash.c"
static unsigned char buf___19[3]  ;
#line 63 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/dhash.c"
static char *inttochar3___7(unsigned int integer ) 
{ 


  {
#line 67
  integer >>= 2;
#line 68
  buf___19[0] = (unsigned char )((integer & 16777215U) >> 16);
#line 69
  buf___19[1] = (unsigned char )((integer & 65535U) >> 8);
#line 70
  buf___19[2] = (unsigned char )(integer & 255U);
#line 71
  return ((char *)(buf___19));
}
}
#line 102 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) __sighandler_t ( __attribute__((__leaf__)) signal)(int __sig ,
                                                                                        void (*__handler)(int  ) ) ;
#line 41 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/snprimedb.c"
static void handler___0(int signum ) 
{ 


  {
  {
#line 43
  dh_close();
#line 44
  log_((char *)"Caught signal %d, exiting", signum);
#line 45
  _exit(3);
  }
}
}
#line 48 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/snprimedb.c"
int nr  =    0;
#line 50 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/snprimedb.c"
int insert(char *newsgroup , char *id , int serial ) 
{ 
  struct data d ;
  char *cp ;
  int tmp ;
  int *tmp___0 ;
  int tmp___1 ;

  {
  {
#line 52
  d.messageid = (char *)0;
#line 52
  d.newsgroup = (char *)0;
#line 52
  d.serial = 0;
#line 55
  tmp = strcmp((char const   *)newsgroup, "=junk");
  }
#line 55
  if (0 == tmp) {
#line 56
    return (0);
  }
#line 57
  if (60 == (int )*id) {
    {
#line 59
    d.messageid = id + 1;
#line 60
    cp = strchr((char const   *)d.messageid, '>');
    }
#line 60
    if (cp) {
#line 61
      *cp = (char )'\000';
    }
  } else {
#line 64
    d.messageid = id;
  }
  {
#line 65
  d.newsgroup = newsgroup;
#line 66
  d.serial = serial;
#line 67
  tmp___1 = dh_insert(& d);
  }
#line 67
  if (-1 == tmp___1) {
    {
#line 69
    tmp___0 = __errno_location();
    }
#line 69
    if (17 == *tmp___0) {
      {
#line 71
      log_((char *)"insert:\"%s\" already exists in %s:%d", d.messageid, newsgroup,
           serial);
      }
#line 72
      return (1);
    } else {
      {
#line 75
      log_((char *)"insert:Can\'t insert record \"%s %s %d\":%m\n", newsgroup, d.messageid,
           serial);
      }
    }
#line 76
    return (-1);
  }
#line 78
  nr ++;
#line 79
  return (0);
}
}
#line 35 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/newsgroup.c"
static struct ng *bygroup___7[128]  ;
#line 36 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/newsgroup.c"
static struct ng *byident___7[128]  ;
#line 37 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/newsgroup.c"
static int highest___7  =    0;
#line 39 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/newsgroup.c"
static unsigned int hash___15(char *buf___28 , int len ) 
{ 
  unsigned int h ;
  char *tmp ;

  {
#line 43
  h = 5381U;
  {
#line 44
  while (1) {
    while_continue: /* CIL Label */ ;
#line 44
    if (! len) {
#line 44
      goto while_break;
    }
#line 46
    len --;
#line 47
    h += h << 5;
#line 48
    tmp = buf___28;
#line 48
    buf___28 ++;
#line 48
    h ^= (unsigned int )*tmp;
  }
  while_break: /* CIL Label */ ;
  }
#line 50
  return (h);
}
}
#line 53 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/newsgroup.c"
static struct chunk *chunks___7  ;
#line 58 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/newsgroup.c"
static int avail___15  =    0;
#line 59 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/newsgroup.c"
static int nr___8  =    0;
#line 64 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/newsgroup.c"
static int add___8(int ident , char *group , int len ) 
{ 
  struct ng *np ;
  struct ng *p ;
  int want ;
  unsigned int h ;
  struct chunk *tmp ;
  int size___1 ;
  void *tmp___0 ;
  unsigned int tmp___1 ;
  int tmp___2 ;

  {
#line 71
  len ++;
#line 72
  want = (int )(((unsigned long )len + sizeof(struct ng )) + sizeof(char *));
#line 73
  want = (int )((unsigned long )want - (unsigned long )len % sizeof(char *));
#line 74
  len --;
#line 76
  if (avail___15 < want) {
#line 81
    if (want > 240) {
#line 81
      size___1 = want + 240;
    } else {
#line 81
      size___1 = 240;
    }
    {
#line 82
    tmp___0 = malloc((size_t )size___1);
#line 82
    tmp = (struct chunk *)tmp___0;
    }
#line 82
    if (! tmp) {
#line 83
      return (-1);
    }
#line 84
    tmp->next = chunks___7;
#line 85
    chunks___7 = tmp;
#line 86
    chunks___7->buf = (char *)chunks___7 + sizeof(struct chunk );
#line 87
    avail___15 = (int )((unsigned long )size___1 - sizeof(struct chunk ));
  }
  {
#line 89
  np = (struct ng *)chunks___7->buf;
#line 90
  chunks___7->buf += want;
#line 91
  avail___15 -= want;
#line 92
  strncpy((char */* __restrict  */)(np->group), (char const   */* __restrict  */)group,
          (size_t )len);
#line 93
  np->group[len] = (char )'\000';
#line 94
  np->ident = ident;
#line 96
  tmp___1 = hash___15(group, len);
#line 96
  h = tmp___1 % 128U;
#line 97
  np->gnext = bygroup___7[h];
#line 98
  bygroup___7[h] = np;
#line 99
  p = np->gnext;
  }
  {
#line 99
  while (1) {
    while_continue: /* CIL Label */ ;
#line 99
    if (! p) {
#line 99
      goto while_break;
    }
    {
#line 100
    tmp___2 = strcmp((char const   *)(p->group), (char const   *)group);
    }
#line 100
    if (0 == tmp___2) {
#line 101
      return (1);
    }
#line 99
    p = p->gnext;
  }
  while_break: /* CIL Label */ ;
  }
#line 102
  h = (unsigned int )(ident % 128);
#line 103
  np->inext = byident___7[h];
#line 104
  byident___7[h] = np;
#line 105
  p = np->inext;
  {
#line 105
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 105
    if (! p) {
#line 105
      goto while_break___0;
    }
#line 106
    if (p->ident == ident) {
#line 107
      return (1);
    }
#line 105
    p = p->inext;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 109
  if (ident > highest___7) {
#line 110
    highest___7 = ident;
  }
#line 111
  nr___8 ++;
#line 112
  return (0);
}
}
#line 116 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/newsgroup.c"
static int groupfd___7  =    -1;
#line 117 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/newsgroup.c"
static int oldsize___7  =    0;
#line 118 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/newsgroup.c"
static int mapsize___7  =    0;
#line 119 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/newsgroup.c"
static char *mapbuf___7  =    (char *)((void *)0);
#line 148
static int reload___7(void) ;
#line 148 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/newsgroup.c"
static int pagesize___25  =    0;
#line 145 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/newsgroup.c"
static int reload___7(void) 
{ 
  struct stat st ;
  int newsize ;
  int tmp ;
  void *tmp___0 ;
  char *p ;
  char *lim ;
  char *ip ;
  char *gr ;
  int ident ;
  int state ;
  int tmp___1 ;

  {
  {
#line 156
  tmp = fstat(groupfd___7, & st);
  }
#line 156
  if (-1 == tmp) {
    {
#line 158
    log_((char *)"reload:fstat:%m");
    }
#line 159
    return (-1);
  }
#line 161
  newsize = (int )st.st_size;
#line 162
  if (! pagesize___25) {
    {
#line 163
    pagesize___25 = getpagesize();
    }
  }
#line 164
  if (newsize <= oldsize___7) {
#line 165
    return (0);
  }
#line 166
  if (newsize > mapsize___7) {
#line 166
    goto _L;
  } else
#line 166
  if (! mapsize___7) {
    _L: /* CIL Label */ 
#line 168
    if (mapbuf___7) {
      {
#line 169
      munmap((void *)mapbuf___7, (size_t )mapsize___7);
      }
    }
    {
#line 170
    mapsize___7 = (int )((st.st_size + (__off_t )pagesize___25) - st.st_size % (long )pagesize___25);
#line 171
    tmp___0 = mmap((void *)0, (size_t )mapsize___7, 1, 1, groupfd___7, (__off_t )0);
#line 171
    mapbuf___7 = (char *)tmp___0;
    }
#line 172
    if (! mapbuf___7) {
      {
#line 174
      log_((char *)"reload:mmap:%m");
      }
#line 175
      return (-1);
    } else
#line 172
    if ((unsigned long )mapbuf___7 == (unsigned long )((void *)-1)) {
      {
#line 174
      log_((char *)"reload:mmap:%m");
      }
#line 175
      return (-1);
    }
  }
#line 188
  lim = mapbuf___7 + newsize;
#line 189
  state = 0;
#line 189
  ident = state;
#line 190
  gr = (char *)0;
#line 190
  ip = gr;
#line 191
  p = mapbuf___7 + oldsize___7;
  {
#line 191
  while (1) {
    while_continue: /* CIL Label */ ;
#line 191
    if (! ((unsigned long )p < (unsigned long )lim)) {
#line 191
      goto while_break;
    }
    {
#line 194
    if (state == 0) {
#line 194
      goto case_0;
    }
#line 195
    if (state == 1) {
#line 195
      goto case_1;
    }
#line 196
    if (state == 2) {
#line 196
      goto case_2;
    }
#line 197
    if (state == 3) {
#line 197
      goto case_3;
    }
#line 192
    goto switch_break;
    case_0: /* CIL Label */ 
#line 194
    if ((int )*p >= 48) {
#line 194
      if ((int )*p <= 57) {
#line 194
        ip = p;
#line 194
        state ++;
      }
    }
#line 194
    goto switch_break;
    case_1: /* CIL Label */ 
#line 195
    if (32 == (int )*p) {
      {
#line 195
      ident = atoi((char const   *)ip);
#line 195
      state ++;
      }
    }
#line 195
    goto switch_break;
    case_2: /* CIL Label */ 
#line 196
    if (32 != (int )*p) {
#line 196
      gr = p;
#line 196
      state ++;
    }
#line 196
    goto switch_break;
    case_3: /* CIL Label */ 
#line 198
    if (10 != (int )*p) {
#line 199
      goto switch_break;
    }
    {
#line 200
    tmp___1 = add___8(ident, gr, (int )(p - gr));
    }
#line 200
    if (-1 == tmp___1) {
      {
#line 202
      log_((char *)"reload:no memory");
      }
#line 203
      return (-1);
    }
#line 205
    state = 0;
    switch_break: /* CIL Label */ ;
    }
#line 191
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 208
  oldsize___7 = newsize;
#line 209
  return (0);
}
}
#line 26 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/key.c"
static struct buf *head___8  ;
#line 27 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/key.c"
static int avail___16  =    0;
#line 28 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/key.c"
static char *keybuf___7  =    (char *)((void *)0);
#line 33 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/key.c"
static unsigned int hv___7  ;
#line 35 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/key.c"
static void hash___16(char *key , int len ) 
{ 
  char *tmp ;

  {
#line 37
  hv___7 = 5381U;
  {
#line 38
  while (1) {
    while_continue: /* CIL Label */ ;
#line 38
    if (! len) {
#line 38
      goto while_break;
    }
#line 40
    len --;
#line 41
    hv___7 += hv___7 << 5;
#line 42
    tmp = key;
#line 42
    key ++;
#line 42
    hv___7 ^= (unsigned int )*tmp;
  }
  while_break: /* CIL Label */ ;
  }
#line 44
  hv___7 %= 128U;
#line 45
  return;
}
}
#line 26 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/body.c"
static char *bodbuf___7  =    (char *)((void *)0);
#line 87 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/cache.c"
static struct entry *new_entry___8(int desc___35 ) 
{ 
  struct entry *ep ;
  struct entry *tmp ;

  {
#line 91
  ep = table[desc___35].freelist;
#line 91
  if (ep) {
#line 92
    table[desc___35].freelist = ep->next;
  } else {
#line 95
    ep = table[desc___35].entries;
    {
#line 95
    while (1) {
      while_continue: /* CIL Label */ ;
#line 95
      if (! ep->next) {
#line 95
        goto while_break;
      }
#line 95
      ep = ep->next;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 96
    (ep->prev)->next = (struct entry *)((void *)0);
#line 97
    (*(table[desc___35].freeobj))(ep->object);
    }
  }
#line 99
  tmp = (struct entry *)((void *)0);
#line 99
  ep->next = tmp;
#line 99
  ep->prev = tmp;
#line 100
  ep->object = (void *)0;
#line 101
  return (ep);
}
}
#line 67 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/store.c"
static int sto_cmp___5(void *a , void *b___13 ) 
{ 
  register struct storeobj *x ;
  register struct storeobj *y ;
  int tmp ;

  {
  {
#line 69
  x = (struct storeobj *)a;
#line 70
  y = (struct storeobj *)b___13;
#line 72
  tmp = strcmp((char const   *)x->filename, (char const   *)y->filename);
  }
#line 72
  return (tmp);
}
}
#line 75 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/store.c"
static int nosigio___5(ssize_t (*op)() , int fd , char *buf___28 , int len ) 
{ 
  int er ;
  int *tmp ;
  ssize_t tmp___0 ;

  {
  {
#line 79
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 79
    tmp___0 = (*op)(fd, buf___28, len);
#line 79
    er = (int )tmp___0;
    }
#line 79
    if (! (-1 == er)) {
#line 79
      goto while_break;
    }
    {
#line 80
    tmp = __errno_location();
    }
#line 80
    if (4 != *tmp) {
#line 82
      if (debug >= 1) {
        {
#line 82
        log_((char *)"nosigio:%m");
        }
      }
#line 83
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 85
  return (er);
}
}
#line 88 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/store.c"
static int copyart___5(int tofd , int fromfd , int fromseek , int len ) 
{ 
  char buf___28[1024] ;
  __off_t tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  {
#line 92
  tmp = lseek(fromfd, (__off_t )fromseek, 0);
  }
#line 92
  if (-1L == tmp) {
    {
#line 94
    log_((char *)"copyart:lseek:%m");
    }
#line 95
    return (-1);
  }
  {
#line 98
  while (1) {
    while_continue: /* CIL Label */ ;
#line 98
    if (! (len > 1024)) {
#line 98
      goto while_break;
    }
    {
#line 99
    tmp___0 = nosigio___5((ssize_t (*)())(& read), fromfd, buf___28, 1024);
    }
#line 99
    if (-1 == tmp___0) {
#line 100
      return (-1);
    } else {
      {
#line 99
      tmp___1 = nosigio___5((ssize_t (*)())(& write), tofd, buf___28, 1024);
      }
#line 99
      if (-1 == tmp___1) {
#line 100
        return (-1);
      }
    }
#line 98
    len -= 1024;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 101
  tmp___2 = nosigio___5((ssize_t (*)())(& read), fromfd, buf___28, len);
  }
#line 101
  if (-1 == tmp___2) {
#line 102
    return (-1);
  } else {
    {
#line 101
    tmp___3 = nosigio___5((ssize_t (*)())(& write), tofd, buf___28, len);
    }
#line 101
    if (-1 == tmp___3) {
#line 102
      return (-1);
    }
  }
#line 104
  return (0);
}
}
#line 107 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/store.c"
static int checkindex___5(struct info *p ) 
{ 


  {
#line 109
  if (p->hoffset > 0) {
#line 111
    if (p->boffset > 0) {
#line 112
      if (p->hlen > 0) {
#line 113
        if (p->blen > 0) {
#line 114
          return (0);
        }
      }
    }
  } else
#line 116
  if (-1 == p->hoffset) {
#line 116
    if (-1 == p->boffset) {
#line 117
      return (1);
    }
  }
#line 118
  return (-1);
}
}
#line 127 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/store.c"
static void reorder___5(struct storeobj *sp ) 
{ 
  char tmpname[287] ;
  char *p ;
  char *q ;
  int fd ;
  struct file f___9 ;
  int er ;
  int i ;
  char *tmp ;
  char tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char tmp___4 ;
  char *tmp___5 ;
  int *tmp___6 ;
  int tmp___7 ;
  char *p___0 ;
  int *tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  __off_t tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  __off_t tmp___17 ;
  __off_t tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;

  {
#line 133
  f___9.magic = 0;
#line 133
  f___9.info[0].hoffset = 0;
#line 133
  f___9.info[0].hlen = 0;
#line 133
  f___9.info[0].boffset = 0;
#line 133
  f___9.info[0].blen = 0;
#line 133
  f___9.info[1].hoffset = 0;
#line 133
  f___9.info[1].hlen = 0;
#line 133
  f___9.info[1].boffset = 0;
#line 133
  f___9.info[1].blen = 0;
#line 133
  f___9.info[2].hoffset = 0;
#line 133
  f___9.info[2].hlen = 0;
#line 133
  f___9.info[2].boffset = 0;
#line 133
  f___9.info[2].blen = 0;
#line 133
  f___9.info[3].hoffset = 0;
#line 133
  f___9.info[3].hlen = 0;
#line 133
  f___9.info[3].boffset = 0;
#line 133
  f___9.info[3].blen = 0;
#line 133
  f___9.info[4].hoffset = 0;
#line 133
  f___9.info[4].hlen = 0;
#line 133
  f___9.info[4].boffset = 0;
#line 133
  f___9.info[4].blen = 0;
#line 133
  f___9.info[5].hoffset = 0;
#line 133
  f___9.info[5].hlen = 0;
#line 133
  f___9.info[5].boffset = 0;
#line 133
  f___9.info[5].blen = 0;
#line 133
  f___9.info[6].hoffset = 0;
#line 133
  f___9.info[6].hlen = 0;
#line 133
  f___9.info[6].boffset = 0;
#line 133
  f___9.info[6].blen = 0;
#line 133
  f___9.info[7].hoffset = 0;
#line 133
  f___9.info[7].hlen = 0;
#line 133
  f___9.info[7].boffset = 0;
#line 133
  f___9.info[7].blen = 0;
#line 133
  f___9.info[8].hoffset = 0;
#line 133
  f___9.info[8].hlen = 0;
#line 133
  f___9.info[8].boffset = 0;
#line 133
  f___9.info[8].blen = 0;
#line 133
  f___9.info[9].hoffset = 0;
#line 133
  f___9.info[9].hlen = 0;
#line 133
  f___9.info[9].boffset = 0;
#line 133
  f___9.info[9].blen = 0;
#line 136
  p = tmpname;
#line 136
  q = sp->filename;
  {
#line 136
  while (1) {
    while_continue: /* CIL Label */ ;
#line 136
    tmp = p;
#line 136
    p ++;
#line 136
    tmp___1 = q;
#line 136
    q ++;
#line 136
    tmp___0 = *tmp___1;
#line 136
    *tmp = tmp___0;
#line 136
    if (! ((int )tmp___0 != 47)) {
#line 136
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 137
  tmp___2 = p;
#line 137
  p ++;
#line 137
  *tmp___2 = (char )'+';
  {
#line 138
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 138
    tmp___3 = p;
#line 138
    p ++;
#line 138
    tmp___5 = q;
#line 138
    q ++;
#line 138
    tmp___4 = *tmp___5;
#line 138
    *tmp___3 = tmp___4;
#line 138
    if (! tmp___4) {
#line 138
      goto while_break___0;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 139
  fd = open((char const   *)(tmpname), 194, 420);
  }
#line 140
  if (-1 == fd) {
    {
#line 142
    tmp___6 = __errno_location();
    }
#line 142
    if (17 != *tmp___6) {
      {
#line 143
      log_((char *)"reorder:open(%s):%m", tmpname);
      }
    }
#line 144
    return;
  }
  {
#line 147
  f___9.magic = 1027296;
#line 148
  tmp___7 = nosigio___5((ssize_t (*)())(& write), fd, (char *)(& f___9), (int )sizeof(f___9));
  }
#line 148
  if (-1 == tmp___7) {
#line 149
    goto fail;
  }
  {
#line 161
  tmp___9 = lockf(sp->fd, 2, (__off_t )0);
  }
#line 161
  if (-1 == tmp___9) {
    {
#line 165
    tmp___8 = __errno_location();
    }
#line 165
    if (11 != *tmp___8) {
#line 166
      p___0 = (char *)"reorder:can\'t lockf %s:%m";
    } else {
#line 168
      p___0 = (char *)"reorder:article in %s being cancelled?";
    }
    {
#line 169
    log_(p___0, sp->filename);
    }
#line 170
    goto fail;
  }
#line 173
  i = 0;
  {
#line 173
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 173
    if (! (i < 10)) {
#line 173
      goto while_break___1;
    }
    {
#line 174
    tmp___10 = checkindex___5((sp->file)->info + i);
    }
    {
#line 176
    if (tmp___10 == 0) {
#line 176
      goto case_0;
    }
#line 188
    if (tmp___10 == 1) {
#line 188
      goto case_1;
    }
#line 191
    if (tmp___10 == -1) {
#line 191
      goto case_neg_1;
    }
#line 174
    goto switch_break;
    case_0: /* CIL Label */ 
    {
#line 177
    tmp___12 = lseek(fd, (__off_t )0, 2);
#line 177
    tmp___11 = (int )tmp___12;
#line 177
    f___9.info[i].hoffset = tmp___11;
    }
#line 177
    if (tmp___11 > 0) {
      {
#line 179
      f___9.info[i].hlen = (sp->file)->info[i].hlen;
#line 180
      f___9.info[i].blen = (sp->file)->info[i].blen;
#line 181
      er = copyart___5(fd, sp->fd, (sp->file)->info[i].hoffset, f___9.info[i].hlen);
      }
#line 182
      if (0 == er) {
#line 183
        goto switch_break;
      }
    } else {
      {
#line 186
      log_((char *)"reorder:lseek(%s):%m", tmpname);
      }
    }
#line 187
    goto fail;
    case_1: /* CIL Label */ 
#line 189
    tmp___15 = -1;
#line 189
    f___9.info[i].hlen = tmp___15;
#line 189
    tmp___14 = tmp___15;
#line 189
    f___9.info[i].blen = tmp___14;
#line 189
    tmp___13 = tmp___14;
#line 189
    f___9.info[i].hoffset = tmp___13;
#line 189
    f___9.info[i].boffset = tmp___13;
#line 190
    goto switch_break;
    case_neg_1: /* CIL Label */ 
    {
#line 192
    log_((char *)"reorder:corrupt index in %s", sp->filename);
    }
#line 193
    goto fail;
    switch_break: /* CIL Label */ ;
    }
#line 173
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 195
  i = 0;
  {
#line 195
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 195
    if (! (i < 10)) {
#line 195
      goto while_break___2;
    }
#line 197
    if (-1 == f___9.info[i].boffset) {
#line 198
      goto __Cont;
    }
    {
#line 199
    tmp___17 = lseek(fd, (__off_t )0, 2);
#line 199
    tmp___16 = (int )tmp___17;
#line 199
    f___9.info[i].boffset = tmp___16;
    }
#line 199
    if (-1 == tmp___16) {
      {
#line 201
      log_((char *)"reorder:lseek(%s):%m", tmpname);
      }
#line 202
      goto fail;
    }
    {
#line 204
    er = copyart___5(fd, sp->fd, (sp->file)->info[i].boffset, f___9.info[i].blen);
    }
#line 205
    if (-1 == er) {
#line 206
      goto fail;
    }
    __Cont: /* CIL Label */ 
#line 195
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 209
  tmp___18 = lseek(fd, (__off_t )0, 0);
  }
#line 209
  if (-1L == tmp___18) {
    {
#line 211
    log_((char *)"reorder:lseek:%m");
    }
#line 212
    goto fail;
  }
  {
#line 214
  tmp___19 = nosigio___5((ssize_t (*)())(& write), fd, (char *)(& f___9), (int )sizeof(f___9));
  }
#line 214
  if (-1 == tmp___19) {
#line 215
    goto fail;
  }
  {
#line 216
  tmp___20 = rename((char const   *)(tmpname), (char const   *)sp->filename);
  }
#line 216
  if (-1 == tmp___20) {
    {
#line 218
    log_((char *)"reorder:rename:%m");
    }
#line 219
    goto fail;
  }
  {
#line 221
  close(fd);
  }
#line 222
  return;
  fail: 
  {
#line 225
  log_((char *)"reorder:write failed for %s:%m", sp->filename);
#line 226
  tmp___21 = unlink((char const   *)(tmpname));
  }
#line 226
  if (-1 == tmp___21) {
    {
#line 227
    log_((char *)"reorder:unlink(%s):%m", tmpname);
    }
  }
  {
#line 228
  close(fd);
  }
#line 229
  return;
}
}
#line 231 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/store.c"
static void sto_free___5(void *p ) 
{ 
  struct storeobj *sp ;
  int tmp ;

  {
  {
#line 233
  sp = (struct storeobj *)p;
#line 235
  close(sp->fd);
#line 236
  tmp = munmap((void *)((caddr_t )sp->file), sizeof(struct file ));
  }
#line 236
  if (-1 == tmp) {
    {
#line 237
    log_((char *)"sto_free:munmap:%m");
    }
  }
  {
#line 238
  free((void *)sp);
  }
#line 239
  return;
}
}
#line 241 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/store.c"
static int desc___23  ;
#line 304
static int tryopen___5(char *fn ) ;
#line 304 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/store.c"
static struct file f___5  =    {1027296, {{0, 0, 0, 0}}};
#line 270 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/store.c"
static int tryopen___5(char *fn ) 
{ 
  char fn2[287] ;
  int fd ;
  int i ;
  char *p ;
  char *q ;
  struct timeval tv ;
  char *tmp ;
  char tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  ssize_t tmp___7 ;

  {
  {
#line 278
  fd = open((char const   *)fn, 2);
  }
#line 278
  if (fd > -1) {
    {
#line 280
    lockf(fd, 1, (__off_t )0);
    }
#line 281
    return (fd);
  }
#line 283
  p = fn2;
#line 283
  q = fn;
  {
#line 283
  while (1) {
    while_continue: /* CIL Label */ ;
#line 283
    tmp = p;
#line 283
    p ++;
#line 283
    tmp___1 = q;
#line 283
    q ++;
#line 283
    tmp___0 = *tmp___1;
#line 283
    *tmp = tmp___0;
#line 283
    if (! ((int )tmp___0 != 47)) {
#line 283
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 284
  tmp___2 = p;
#line 284
  p ++;
#line 284
  *tmp___2 = (char )'+';
#line 285
  tmp___3 = p;
#line 285
  p ++;
#line 285
  *tmp___3 = (char )'+';
#line 286
  gettimeofday((struct timeval */* __restrict  */)(& tv), (__timezone_ptr_t )0);
#line 296
  i = (int )(tv.tv_sec / 30L);
  }
  {
#line 297
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 298
    tmp___4 = p;
#line 298
    p ++;
#line 298
    *tmp___4 = (char )(48 + i % 10);
#line 297
    i /= 10;
#line 297
    if (! i) {
#line 297
      goto while_break___0;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 300
  tmp___5 = p;
#line 300
  p ++;
#line 300
  *tmp___5 = (char )'\000';
#line 302
  i = 0;
  {
#line 302
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 302
    if (! (i < 100)) {
#line 302
      goto while_break___1;
    }
#line 306
    if (14 == i % 15) {
      {
#line 307
      log_((char *)"tryopen:racing on %s", fn);
      }
    }
    {
#line 308
    fd = open((char const   *)(fn2), 194, 420);
    }
#line 308
    if (fd > -1) {
      {
#line 310
      lockf(fd, 1, (__off_t )0);
#line 311
      tmp___7 = write(fd, (void const   *)((char *)(& f___5)), sizeof(f___5));
      }
#line 311
      if (sizeof(f___5) == (unsigned long )tmp___7) {
        {
#line 312
        tmp___6 = link((char const   *)(fn2), (char const   *)fn);
        }
#line 312
        if (0 == tmp___6) {
          {
#line 314
          unlink((char const   *)(fn2));
          }
#line 315
          return (fd);
        }
      }
      {
#line 317
      close(fd);
#line 318
      unlink((char const   *)(fn2));
      }
    }
    {
#line 321
    fd = open((char const   *)fn, 2);
    }
#line 321
    if (fd > -1) {
      {
#line 323
      lockf(fd, 1, (__off_t )0);
      }
#line 324
      return (fd);
    }
    {
#line 302
    nap(0, 300 + i);
#line 302
    i ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 327
  log_((char *)"tryopen:timed out opening %s:%m", fn);
  }
#line 328
  return (-1);
}
}
#line 337 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/store.c"
static struct storeobj *getstore___5(char *filename ) 
{ 
  struct storeobj *sp ;
  struct storeobj s ;
  int fd ;
  struct file *fp ;
  char buf___28[287] ;
  int c ;
  void *tmp ;
  void *tmp___0 ;
  char *p ;
  char *q ;
  char *tmp___1 ;
  char tmp___2 ;
  char *tmp___3 ;
  char *end ;
  unsigned long tmp___4 ;
  ssize_t tmp___5 ;
  size_t tmp___6 ;
  void *tmp___7 ;

  {
  {
#line 349
  s.filename = filename;
#line 350
  tmp = cache_find(desc___23, (void *)(& s));
#line 350
  sp = (struct storeobj *)tmp;
  }
#line 350
  if (sp) {
    {
#line 352
    lockf(sp->fd, 1, (__off_t )0);
    }
#line 353
    return (sp);
  }
  {
#line 356
  fd = tryopen___5(filename);
  }
#line 356
  if (-1 == fd) {
#line 357
    return ((struct storeobj *)0);
  }
  {
#line 361
  tmp___0 = mmap((void *)0, sizeof(*fp), 3, 1, fd, (__off_t )0);
#line 361
  fp = (struct file *)tmp___0;
  }
#line 362
  if (! fp) {
    {
#line 363
    log_((char *)"getstore:mmap(%s):%m", filename);
    }
  } else
#line 362
  if ((unsigned long )fp == (unsigned long )((void *)-1)) {
    {
#line 363
    log_((char *)"getstore:mmap(%s):%m", filename);
    }
  } else {
    {
#line 364
    tmp___6 = strlen((char const   *)filename);
#line 364
    tmp___7 = malloc((sizeof(*sp) + tmp___6) + 1UL);
#line 364
    sp = (struct storeobj *)tmp___7;
    }
#line 364
    if (sp) {
      {
#line 371
      sp->fd = fd;
#line 372
      sp->file = fp;
#line 373
      sp->filename = (char *)sp + sizeof(*sp);
#line 374
      strcpy((char */* __restrict  */)sp->filename, (char const   */* __restrict  */)filename);
#line 380
      p = buf___28;
#line 380
      q = filename;
      }
      {
#line 380
      while (1) {
        while_continue: /* CIL Label */ ;
#line 380
        tmp___1 = p;
#line 380
        p ++;
#line 380
        tmp___3 = q;
#line 380
        q ++;
#line 380
        tmp___2 = *tmp___3;
#line 380
        *tmp___1 = tmp___2;
#line 380
        if (! ((int )tmp___2 != 47)) {
#line 380
          goto while_break;
        }
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 381
      strcpy((char */* __restrict  */)p, (char const   */* __restrict  */)".compress");
#line 383
      fd = open((char const   *)(buf___28), 0);
      }
#line 383
      if (fd > -1) {
        {
#line 385
        sp->compressok = 1024;
#line 386
        tmp___5 = read(fd, (void *)(buf___28), sizeof(buf___28) - 1UL);
#line 386
        c = (int )tmp___5;
        }
#line 386
        if (c > 0) {
          {
#line 390
          buf___28[c] = (char )'\000';
#line 391
          tmp___4 = strtoul((char const   */* __restrict  */)(buf___28), (char **/* __restrict  */)(& end),
                            10);
#line 391
          c = (int )tmp___4;
          }
#line 392
          if (c > 1024) {
#line 392
            if (10 == (int )*end) {
#line 393
              sp->compressok = c;
            }
          }
        }
        {
#line 395
        close(fd);
        }
      } else {
#line 399
        sp->compressok = 0;
      }
      {
#line 400
      cache_insert(desc___23, (void *)sp);
      }
#line 401
      return (sp);
    } else {
      {
#line 366
      log_((char *)"getstore:no memory");
#line 367
      munmap((void *)fp, sizeof(*fp));
      }
    }
  }
  {
#line 403
  close(fd);
  }
#line 404
  return ((struct storeobj *)0);
}
}
#line 37 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/group.c"
static int desc___24  =    -1;
#line 59 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/group.c"
static int cmpgroup___8(void *a , void *b___13 ) 
{ 
  struct groupobj *x ;
  struct groupobj *y ;
  int tmp ;

  {
  {
#line 61
  x = (struct groupobj *)a;
#line 62
  y = (struct groupobj *)b___13;
#line 64
  tmp = strcmp((char const   *)x->groupname, (char const   *)y->groupname);
  }
#line 64
  return (tmp);
}
}
#line 67 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/group.c"
static void freegroup___8(void *p ) 
{ 
  struct groupobj *gop ;

  {
#line 69
  gop = (struct groupobj *)p;
#line 71
  if (gop->groupname) {
    {
#line 72
    free((void *)gop->groupname);
    }
  }
#line 73
  if (gop->dir.dir) {
    {
#line 74
    closedir(gop->dir.dir);
    }
  }
#line 75
  if (gop->lastf.f) {
    {
#line 76
    munmap((void *)((caddr_t )gop->lastf.f), sizeof(struct file ));
    }
  }
  {
#line 77
  free(p);
  }
#line 78
  return;
}
}
#line 94 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/group.c"
static int refresh___8(struct groupobj *gop , char *groupname ) 
{ 
  struct stat st ;
  struct dir *d ;
  struct lastf *lp ;
  bool needreread ;
  bool needrefile ;
  bool needreslot ;
  bool isemptygroup ;
  int tmp ;
  int tmp___0 ;
  struct dirent *dp ;
  int i ;
  int first ;
  int last___1 ;
  char *end ;
  int tmp___1 ;
  unsigned short const   **tmp___2 ;
  unsigned long tmp___3 ;
  int fd ;
  void *tmp___4 ;
  struct info *ip ;
  int slot ;

  {
#line 99
  needreread = (bool )0;
#line 100
  needrefile = (bool )0;
#line 101
  needreslot = (bool )0;
#line 102
  isemptygroup = (bool )0;
#line 104
  d = & gop->dir;
#line 105
  lp = & gop->lastf;
#line 107
  if (groupname) {
    {
#line 109
    memset((void *)gop, 0, sizeof(struct groupobj ));
#line 110
    gop->groupname = strdup((char const   *)groupname);
    }
#line 111
    if ((unsigned long )((void *)0) == (unsigned long )gop->groupname) {
      {
#line 113
      log_((char *)"refresh:strdup:%m");
      }
#line 114
      return (-1);
    }
    {
#line 116
    gop->dir.first = -1;
#line 117
    d->dir = opendir((char const   *)groupname);
    }
#line 118
    if ((unsigned long )((void *)0) == (unsigned long )d->dir) {
      {
#line 120
      log_((char *)"refresh:opendir:%m");
      }
#line 121
      return (-1);
    }
#line 123
    lp->name = -1;
#line 125
    needreslot = (bool )1;
#line 125
    needreread = needreslot;
#line 125
    needrefile = needreread;
  } else {
#line 131
    if (-1 == d->first) {
#line 132
      needreread = (bool )1;
    } else
#line 131
    if (0 == d->last) {
#line 132
      needreread = (bool )1;
    } else
#line 131
    if (! d->read) {
#line 132
      needreread = (bool )1;
    } else {
      {
#line 133
      tmp = dirfd(d->dir);
#line 133
      tmp___0 = fstat(tmp, & st);
      }
#line 133
      if (-1 == tmp___0) {
        {
#line 135
        log_((char *)"refresh:fstat:%m");
        }
#line 136
        return (-1);
      } else
#line 138
      if (d->read < st.st_mtim.tv_sec) {
#line 139
        needreread = (bool )1;
      }
    }
#line 140
    if (! lp->f) {
#line 141
      needreslot = (bool )1;
#line 141
      needrefile = needreslot;
    }
#line 142
    if (! needrefile) {
#line 143
      if (! lp->f) {
#line 144
        needrefile = (bool )1;
      }
    }
#line 145
    if (! needrefile) {
#line 146
      if (-1 == lp->name) {
#line 147
        needrefile = (bool )1;
      }
    }
  }
#line 150
  if (needreread) {
#line 150
    goto _L;
  } else
#line 150
  if (needreslot) {
    _L: /* CIL Label */ 
    {
#line 156
    first = -1;
#line 157
    last___1 = 0;
#line 158
    rewinddir(d->dir);
#line 159
    dp = readdir(d->dir);
    }
#line 160
    if ((unsigned long )((void *)0) == (unsigned long )dp) {
      {
#line 162
      log_((char *)"refresh:readdir:%m");
      }
#line 163
      return (-1);
    }
#line 165
    gop->nopost = (bool )0;
    {
#line 166
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 168
      tmp___2 = __ctype_b_loc();
      }
#line 168
      if (! ((int const   )*(*tmp___2 + (int )dp->d_name[0]) & 2048)) {
#line 170
        if (! gop->nopost) {
#line 170
          if (46 == (int )dp->d_name[0]) {
            {
#line 171
            tmp___1 = strcmp((char const   *)(dp->d_name), ".nopost");
            }
#line 171
            if (0 == tmp___1) {
#line 172
              gop->nopost = (bool )1;
            }
          }
        }
#line 173
        goto __Cont;
      }
      {
#line 175
      tmp___3 = strtoul((char const   */* __restrict  */)(dp->d_name), (char **/* __restrict  */)(& end),
                        10);
#line 175
      i = (int )tmp___3;
      }
#line 175
      if (i <= 0) {
#line 176
        goto __Cont;
      } else
#line 175
      if (*end) {
#line 176
        goto __Cont;
      }
#line 177
      if (first > i) {
#line 178
        first = i;
      } else
#line 177
      if (-1 == first) {
#line 178
        first = i;
      }
#line 179
      if (last___1 < i) {
#line 180
        last___1 = i;
      }
      __Cont: /* CIL Label */ 
      {
#line 166
      dp = readdir(d->dir);
      }
#line 166
      if (! dp) {
#line 166
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 183
    d->first = first;
#line 184
    d->last = last___1;
#line 185
    if (-1 == first) {
#line 185
      if (0 == last___1) {
#line 186
        isemptygroup = (bool )1;
      }
    }
#line 187
    if (last___1 != lp->name) {
#line 188
      needrefile = (bool )1;
    } else {
#line 190
      lp->name = last___1;
    }
    {
#line 191
    time(& d->read);
    }
  }
#line 194
  if (needrefile) {
#line 194
    goto _L___0;
  } else
#line 194
  if (needreslot) {
    _L___0: /* CIL Label */ 
#line 198
    if (lp->f) {
      {
#line 200
      munmap((void *)((caddr_t )lp->f), sizeof(struct file ));
#line 201
      lp->f = (struct file *)((void *)0);
      }
    }
#line 203
    if (isemptygroup) {
#line 204
      return (0);
    }
    {
#line 205
    fd = openf(0, 0, (char *)"%s/%d", gop->groupname, d->last);
    }
#line 206
    if (-1 == fd) {
      {
#line 208
      log_((char *)"refresh:open:%m");
      }
#line 209
      return (-1);
    }
    {
#line 211
    tmp___4 = mmap((void *)0, sizeof(struct file ), 1, 1, fd, (__off_t )0);
#line 211
    lp->f = (struct file *)tmp___4;
#line 212
    close(fd);
    }
#line 213
    if ((unsigned long )lp->f == (unsigned long )((void *)-1)) {
      {
#line 215
      log_((char *)"refresh:mmap:%m");
      }
#line 216
      return (-1);
    }
#line 218
    lp->slotsfilled = 0;
#line 219
    needreslot = (bool )1;
  }
#line 222
  if (needreslot) {
#line 224
    ip = (lp->f)->info;
#line 227
    slot = 9;
    {
#line 227
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 227
      if (! (slot > -1)) {
#line 227
        goto while_break___0;
      }
#line 228
      if ((ip + slot)->hoffset) {
#line 229
        goto while_break___0;
      }
#line 227
      slot --;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 230
    lp->slotsfilled = slot + 1;
  }
#line 233
  return (0);
}
}
#line 33 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/art.c"
static size_t pagesize___26  =    (size_t )0;
#line 80 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/art.c"
static void file_unmap___8(void *p ) 
{ 
  struct fileobj *fp ;

  {
  {
#line 82
  fp = (struct fileobj *)p;
#line 84
  munmap((void *)fp->map, (size_t )fp->size);
#line 85
  free((void *)fp);
  }
#line 86
  return;
}
}
#line 88 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/art.c"
static int file_cmp___8(void *a , void *b___13 ) 
{ 
  struct fileobj *x ;
  struct fileobj *y ;
  int tmp ;

  {
  {
#line 90
  x = (struct fileobj *)a;
#line 91
  y = (struct fileobj *)b___13;
#line 93
  tmp = strcmp((char const   *)x->path, (char const   *)y->path);
  }
#line 93
  return (tmp);
}
}
#line 96 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/art.c"
static int desc___25  =    -1;
#line 98 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/art.c"
static int file_init___8(void) 
{ 


  {
  {
#line 100
  desc___25 = cache_init(8, & file_cmp___8, & file_unmap___8, (int (*)(void * ))((void *)0));
  }
#line 101
  if (-1 == desc___25) {
    {
#line 103
    log_((char *)"file_init:%m");
    }
#line 104
    return (-1);
  }
#line 106
  return (0);
}
}
#line 109 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/art.c"
static struct file *file_gimme___8(char *name , int *size___1 ) 
{ 
  struct fileobj f___9 ;
  struct fileobj *fp ;
  void *tmp ;

  {
  {
#line 111
  f___9.path = (char *)0;
#line 111
  f___9.map = (char *)0;
#line 111
  f___9.size = 0;
#line 114
  f___9.path = name;
#line 116
  tmp = cache_find(desc___25, (void *)(& f___9));
#line 116
  fp = (struct fileobj *)tmp;
  }
#line 116
  if ((unsigned long )((void *)0) == (unsigned long )fp) {
    {
#line 118
    fp = file_map(name);
    }
#line 118
    if ((unsigned long )((void *)0) == (unsigned long )fp) {
#line 119
      return ((struct file *)((void *)0));
    } else {
      {
#line 121
      cache_insert(desc___25, (void *)fp);
      }
    }
  }
#line 124
  if (size___1) {
#line 125
    *size___1 = fp->size;
  }
#line 126
  return ((struct file *)fp->map);
}
}
#line 137 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/art.c"
static bool file_initialized___8  =    (bool )0;
#line 248 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/art.c"
static char ngroup___8[287]  ;
#line 297 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/art.c"
static int getfield___8(char *buf___28 , struct field *f___9 ) 
{ 
  register char *cp ;
  size_t tmp ;
  size_t tmp___0 ;

  {
  {
#line 299
  cp = buf___28;
#line 301
  tmp = strspn((char const   *)cp, " \t\f");
#line 301
  cp += tmp;
  }
#line 302
  if (! *cp) {
#line 304
    f___9->pointer = (char *)((void *)0);
#line 305
    return (0);
  }
  {
#line 307
  tmp___0 = strcspn((char const   *)cp, "\r\n");
#line 307
  f___9->len = (int )tmp___0;
  }
#line 308
  if (! f___9->len) {
#line 309
    return (0);
  }
#line 310
  f___9->pointer = cp;
#line 311
  return ((int )((cp + f___9->len) - buf___28));
}
}
#line 383 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/art.c"
static struct b b___9  =    {(char *)0, 0, 0};
#line 105 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/dh_find.c"
static int initfile___17(void) 
{ 
  int fd ;
  int integer ;
  int i ;
  char foo[3] ;
  unsigned int tmp ;
  int *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  ssize_t tmp___3 ;
  ssize_t tmp___4 ;

  {
#line 108
  integer = 218885376;
#line 110
  foo[0] = (char )'\000';
#line 110
  tmp = 1U;
  {
#line 110
  while (1) {
    while_continue: /* CIL Label */ ;
#line 110
    if (tmp >= 3U) {
#line 110
      goto while_break;
    }
#line 110
    foo[tmp] = (char)0;
#line 110
    tmp ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 112
  fd = open((char const   *)(dh_tablefile), 194, 420);
  }
#line 113
  if (fd == -1) {
#line 114
    return (-1);
  }
  {
#line 115
  tmp___2 = lockf(fd, 2, (__off_t )0);
  }
#line 115
  if (tmp___2 == -1) {
    {
#line 117
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 119
      tmp___0 = __errno_location();
      }
#line 119
      if (*tmp___0 == 11) {
        {
#line 120
        nap(0, 200);
        }
      } else {
#line 122
        goto fail;
      }
      {
#line 117
      tmp___1 = lockf(fd, 2, (__off_t )0);
      }
#line 117
      if (! (tmp___1 == -1)) {
#line 117
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 125
    lockf(fd, 0, (__off_t )0);
    }
#line 126
    return (fd);
  }
  {
#line 128
  tmp___3 = write(fd, (void const   *)(& integer), sizeof(int ));
  }
#line 128
  if ((unsigned long )tmp___3 != sizeof(int )) {
#line 129
    goto fail;
  }
#line 130
  i = 0;
  {
#line 130
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 130
    if (! (i < 10240)) {
#line 130
      goto while_break___1;
    }
    {
#line 131
    tmp___4 = write(fd, (void const   *)(foo), sizeof(foo));
    }
#line 131
    if ((unsigned long )tmp___4 != sizeof(foo)) {
#line 132
      goto fail;
    }
#line 130
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 133
  lseek(fd, (__off_t )0, 0);
#line 134
  lockf(fd, 0, (__off_t )0);
  }
#line 135
  return (fd);
  fail: 
#line 138
  if (fd > -1) {
    {
#line 139
    close(fd);
    }
  }
#line 140
  return (-1);
}
}
#line 78 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/allocate.c"
static struct table___1 table___9  =    {(char *)0, (char *)0, 0, 0, 0, 0};
#line 80
static int remapfile___8(void) ;
#line 106 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/allocate.c"
static int initfile___18(char *filename ) 
{ 
  struct chainfile cf ;
  int fd ;
  int i ;
  int ret ;
  ssize_t tmp ;
  int pad ;
  ssize_t tmp___0 ;

  {
  {
#line 108
  cf.chain_magic = 0;
#line 108
  cf.next[0] = 0;
#line 108
  cf.next[1] = 0;
#line 108
  cf.next[2] = 0;
#line 108
  cf.next[3] = 0;
#line 108
  cf.next[4] = 0;
#line 108
  cf.next[5] = 0;
#line 108
  cf.next[6] = 0;
#line 108
  cf.next[7] = 0;
#line 108
  cf.next[8] = 0;
#line 108
  cf.next[9] = 0;
#line 108
  cf.next[10] = 0;
#line 108
  cf.next[11] = 0;
#line 108
  cf.next[12] = 0;
#line 108
  cf.next[13] = 0;
#line 108
  cf.next[14] = 0;
#line 108
  cf.next[15] = 0;
#line 108
  cf.next[16] = 0;
#line 108
  cf.next[17] = 0;
#line 108
  cf.next[18] = 0;
#line 108
  cf.next[19] = 0;
#line 108
  cf.next[20] = 0;
#line 108
  cf.next[21] = 0;
#line 108
  cf.next[22] = 0;
#line 108
  cf.next[23] = 0;
#line 108
  cf.next[24] = 0;
#line 108
  cf.next[25] = 0;
#line 108
  cf.next[26] = 0;
#line 108
  cf.next[27] = 0;
#line 108
  cf.next[28] = 0;
#line 108
  cf.next[29] = 0;
#line 108
  cf.next[30] = 0;
#line 108
  cf.next[31] = 0;
#line 108
  cf.next[32] = 0;
#line 108
  cf.next[33] = 0;
#line 108
  cf.next[34] = 0;
#line 108
  cf.next[35] = 0;
#line 108
  cf.next[36] = 0;
#line 108
  cf.next[37] = 0;
#line 108
  cf.next[38] = 0;
#line 108
  cf.next[39] = 0;
#line 108
  cf.next[40] = 0;
#line 108
  cf.next[41] = 0;
#line 108
  cf.next[42] = 0;
#line 108
  cf.next[43] = 0;
#line 108
  cf.next[44] = 0;
#line 108
  cf.next[45] = 0;
#line 108
  cf.next[46] = 0;
#line 108
  cf.next[47] = 0;
#line 108
  cf.next[48] = 0;
#line 108
  cf.next[49] = 0;
#line 108
  cf.next[50] = 0;
#line 108
  cf.next[51] = 0;
#line 108
  cf.next[52] = 0;
#line 108
  cf.next[53] = 0;
#line 108
  cf.next[54] = 0;
#line 108
  cf.next[55] = 0;
#line 108
  cf.next[56] = 0;
#line 108
  cf.next[57] = 0;
#line 108
  cf.next[58] = 0;
#line 108
  cf.next[59] = 0;
#line 108
  cf.next[60] = 0;
#line 108
  cf.next[61] = 0;
#line 108
  cf.next[62] = 0;
#line 111
  ret = 0;
#line 113
  fd = open((char const   *)filename, 578, 420);
  }
#line 114
  if (-1 == fd) {
#line 115
    return (-1);
  }
#line 116
  cf.chain_magic = 13680336;
#line 117
  i = 0;
  {
#line 117
  while (1) {
    while_continue: /* CIL Label */ ;
#line 117
    if (! (i < 63)) {
#line 117
      goto while_break;
    }
#line 118
    cf.next[i] = (int volatile   )0;
#line 117
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 119
  tmp = write(fd, (void const   *)(& cf), sizeof(cf));
#line 119
  i = (int )tmp;
  }
#line 120
  if ((unsigned long )i == sizeof(cf)) {
#line 124
    pad = (int )(sizeof(cf) % 4UL);
#line 125
    if (pad > 0) {
#line 126
      i = 0;
      {
#line 126
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 126
        if (i < pad) {
#line 126
          if (! (0 == ret)) {
#line 126
            goto while_break___0;
          }
        } else {
#line 126
          goto while_break___0;
        }
        {
#line 127
        tmp___0 = write(fd, (void const   *)"", (size_t )1);
        }
#line 127
        if (1L != tmp___0) {
#line 128
          ret = -1;
        }
#line 126
        i ++;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
  } else {
#line 131
    ret = -1;
  }
  {
#line 132
  close(fd);
  }
#line 133
  return (ret);
}
}
#line 136 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/allocate.c"
static void unmapfile___8(void) 
{ 


  {
#line 138
  if (table___9.fd >= 0) {
    {
#line 140
    close(table___9.fd);
#line 141
    table___9.fd = -1;
    }
  }
#line 143
  if (table___9.map) {
    {
#line 145
    munmap((void *)table___9.map, (size_t )table___9.size);
#line 146
    table___9.map = (char *)((void *)0);
#line 147
    table___9.size = 0;
    }
  }
#line 149
  return;
}
}
#line 153
static size_t rounduptopagesize___8(size_t size___1 ) ;
#line 153 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/allocate.c"
static size_t pagesize___27  =    (size_t )0;
#line 151 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/allocate.c"
static size_t rounduptopagesize___8(size_t size___1 ) 
{ 
  int pages ;
  int tmp ;

  {
#line 156
  if (0UL == pagesize___27) {
    {
#line 157
    tmp = getpagesize();
#line 157
    pagesize___27 = (size_t )tmp;
    }
  }
#line 158
  pages = (int )(size___1 / pagesize___27 + 1UL);
#line 159
  return ((size_t )pages * pagesize___27);
}
}
#line 162 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/allocate.c"
static int mapfile___8(void) 
{ 
  struct stat st ;
  int tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;

  {
#line 166
  if (-1 == table___9.fd) {
    {
#line 167
    table___9.fd = open((char const   *)table___9.filename, table___9.oflag, 420);
    }
  }
#line 168
  if (-1 == table___9.fd) {
#line 169
    goto fail;
  }
  {
#line 171
  tmp = fstat(table___9.fd, & st);
  }
#line 171
  if (-1 == tmp) {
#line 172
    goto fail;
  }
  {
#line 173
  tmp___0 = rounduptopagesize___8((size_t )st.st_size);
#line 173
  table___9.size = (int )tmp___0;
#line 174
  tmp___1 = mmap((void *)0, (size_t )table___9.size, table___9.mprot, 1, table___9.fd,
                 (__off_t )0);
#line 174
  table___9.map = (char *)tmp___1;
  }
#line 175
  if (! table___9.map) {
#line 176
    goto fail;
  } else
#line 175
  if ((unsigned long )table___9.map == (unsigned long )((void *)-1)) {
#line 176
    goto fail;
  }
#line 178
  return (0);
  fail: 
  {
#line 181
  unmapfile___8();
  }
#line 182
  return (-1);
}
}
#line 189 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/allocate.c"
static int remapfile___8(void) 
{ 
  struct stat st ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 193
  tmp = fstat(table___9.fd, & st);
  }
#line 193
  if (-1 == tmp) {
#line 194
    return (-1);
  }
#line 196
  if (st.st_size <= (__off_t )table___9.size) {
#line 197
    return (0);
  }
  {
#line 199
  munmap((void *)table___9.map, (size_t )table___9.size);
#line 200
  tmp___0 = mapfile___8();
  }
#line 200
  return (tmp___0);
}
}
#line 209 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/allocate.c"
static int lock___8(void) 
{ 
  int *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 211
  tmp___2 = lockf(table___9.fd, 2, (__off_t )0);
  }
#line 211
  if (-1 == tmp___2) {
    {
#line 213
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 215
      tmp = __errno_location();
      }
#line 215
      if (11 != *tmp) {
#line 216
        return (-1);
      } else {
        {
#line 218
        nap(0, 200);
        }
      }
      {
#line 213
      tmp___0 = lockf(table___9.fd, 2, (__off_t )0);
      }
#line 213
      if (! (-1 == tmp___0)) {
#line 213
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 221
    tmp___1 = remapfile___8();
    }
#line 221
    if (-1 == tmp___1) {
#line 222
      return (-1);
    }
  }
#line 224
  return (0);
}
}
#line 227 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/allocate.c"
static void unlock___8(void) 
{ 


  {
  {
#line 229
  lseek(table___9.fd, (__off_t )0, 0);
#line 230
  lockf(table___9.fd, 0, (__off_t )0);
  }
#line 231
  return;
}
}
#line 233 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/allocate.c"
static int checkvalidfile___8(void) 
{ 


  {
#line 235
  if (table___9.size > 0) {
#line 237
    if ((unsigned long )table___9.size < sizeof(struct chainfile )) {
#line 238
      return (-1);
    }
#line 239
    if (((struct chainfile *)table___9.map)->chain_magic != 13680336) {
#line 240
      return (-1);
    }
  }
#line 242
  return (0);
}
}
#line 281 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/allocate.c"
static int rounduptoalignment___8(int size___1 ) 
{ 


  {
#line 283
  if (size___1 <= 0) {
#line 284
    return (4);
  }
#line 285
  return (((size___1 - 1) / 4 + 1) * 4);
}
}
#line 296 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/allocate.c"
static char tmpchunk___8[272]  = {      (char )'\000'};
#line 56 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/dhash.c"
static unsigned char buf___20[2]  ;
#line 54 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/dhash.c"
static char *inttochar2___8(int integer ) 
{ 


  {
#line 58
  buf___20[0] = (unsigned char )((integer & 65535) >> 8);
#line 59
  buf___20[1] = (unsigned char )(integer & 255);
#line 60
  return ((char *)(buf___20));
}
}
#line 65 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/dhash.c"
static unsigned char buf___21[3]  ;
#line 63 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/dhash.c"
static char *inttochar3___8(unsigned int integer ) 
{ 


  {
#line 67
  integer >>= 2;
#line 68
  buf___21[0] = (unsigned char )((integer & 16777215U) >> 16);
#line 69
  buf___21[1] = (unsigned char )((integer & 65535U) >> 8);
#line 70
  buf___21[2] = (unsigned char )(integer & 255U);
#line 71
  return ((char *)(buf___21));
}
}
#line 35 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/newsgroup.c"
static struct ng *bygroup___8[128]  ;
#line 36 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/newsgroup.c"
static struct ng *byident___8[128]  ;
#line 37 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/newsgroup.c"
static int highest___8  =    0;
#line 39 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/newsgroup.c"
static unsigned int hash___17(char *buf___28 , int len ) 
{ 
  unsigned int h ;
  char *tmp ;

  {
#line 43
  h = 5381U;
  {
#line 44
  while (1) {
    while_continue: /* CIL Label */ ;
#line 44
    if (! len) {
#line 44
      goto while_break;
    }
#line 46
    len --;
#line 47
    h += h << 5;
#line 48
    tmp = buf___28;
#line 48
    buf___28 ++;
#line 48
    h ^= (unsigned int )*tmp;
  }
  while_break: /* CIL Label */ ;
  }
#line 50
  return (h);
}
}
#line 53 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/newsgroup.c"
static struct chunk *chunks___8  ;
#line 58 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/newsgroup.c"
static int avail___17  =    0;
#line 59 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/newsgroup.c"
static int nr___9  =    0;
#line 64 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/newsgroup.c"
static int add___9(int ident , char *group , int len ) 
{ 
  struct ng *np ;
  struct ng *p ;
  int want ;
  unsigned int h ;
  struct chunk *tmp ;
  int size___1 ;
  void *tmp___0 ;
  unsigned int tmp___1 ;
  int tmp___2 ;

  {
#line 71
  len ++;
#line 72
  want = (int )(((unsigned long )len + sizeof(struct ng )) + sizeof(char *));
#line 73
  want = (int )((unsigned long )want - (unsigned long )len % sizeof(char *));
#line 74
  len --;
#line 76
  if (avail___17 < want) {
#line 81
    if (want > 240) {
#line 81
      size___1 = want + 240;
    } else {
#line 81
      size___1 = 240;
    }
    {
#line 82
    tmp___0 = malloc((size_t )size___1);
#line 82
    tmp = (struct chunk *)tmp___0;
    }
#line 82
    if (! tmp) {
#line 83
      return (-1);
    }
#line 84
    tmp->next = chunks___8;
#line 85
    chunks___8 = tmp;
#line 86
    chunks___8->buf = (char *)chunks___8 + sizeof(struct chunk );
#line 87
    avail___17 = (int )((unsigned long )size___1 - sizeof(struct chunk ));
  }
  {
#line 89
  np = (struct ng *)chunks___8->buf;
#line 90
  chunks___8->buf += want;
#line 91
  avail___17 -= want;
#line 92
  strncpy((char */* __restrict  */)(np->group), (char const   */* __restrict  */)group,
          (size_t )len);
#line 93
  np->group[len] = (char )'\000';
#line 94
  np->ident = ident;
#line 96
  tmp___1 = hash___17(group, len);
#line 96
  h = tmp___1 % 128U;
#line 97
  np->gnext = bygroup___8[h];
#line 98
  bygroup___8[h] = np;
#line 99
  p = np->gnext;
  }
  {
#line 99
  while (1) {
    while_continue: /* CIL Label */ ;
#line 99
    if (! p) {
#line 99
      goto while_break;
    }
    {
#line 100
    tmp___2 = strcmp((char const   *)(p->group), (char const   *)group);
    }
#line 100
    if (0 == tmp___2) {
#line 101
      return (1);
    }
#line 99
    p = p->gnext;
  }
  while_break: /* CIL Label */ ;
  }
#line 102
  h = (unsigned int )(ident % 128);
#line 103
  np->inext = byident___8[h];
#line 104
  byident___8[h] = np;
#line 105
  p = np->inext;
  {
#line 105
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 105
    if (! p) {
#line 105
      goto while_break___0;
    }
#line 106
    if (p->ident == ident) {
#line 107
      return (1);
    }
#line 105
    p = p->inext;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 109
  if (ident > highest___8) {
#line 110
    highest___8 = ident;
  }
#line 111
  nr___9 ++;
#line 112
  return (0);
}
}
#line 116 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/newsgroup.c"
static int groupfd___8  =    -1;
#line 117 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/newsgroup.c"
static int oldsize___8  =    0;
#line 118 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/newsgroup.c"
static int mapsize___8  =    0;
#line 119 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/newsgroup.c"
static char *mapbuf___8  =    (char *)((void *)0);
#line 148
static int reload___8(void) ;
#line 148 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/newsgroup.c"
static int pagesize___28  =    0;
#line 145 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/newsgroup.c"
static int reload___8(void) 
{ 
  struct stat st ;
  int newsize ;
  int tmp ;
  void *tmp___0 ;
  char *p ;
  char *lim ;
  char *ip ;
  char *gr ;
  int ident ;
  int state ;
  int tmp___1 ;

  {
  {
#line 156
  tmp = fstat(groupfd___8, & st);
  }
#line 156
  if (-1 == tmp) {
    {
#line 158
    log_((char *)"reload:fstat:%m");
    }
#line 159
    return (-1);
  }
#line 161
  newsize = (int )st.st_size;
#line 162
  if (! pagesize___28) {
    {
#line 163
    pagesize___28 = getpagesize();
    }
  }
#line 164
  if (newsize <= oldsize___8) {
#line 165
    return (0);
  }
#line 166
  if (newsize > mapsize___8) {
#line 166
    goto _L;
  } else
#line 166
  if (! mapsize___8) {
    _L: /* CIL Label */ 
#line 168
    if (mapbuf___8) {
      {
#line 169
      munmap((void *)mapbuf___8, (size_t )mapsize___8);
      }
    }
    {
#line 170
    mapsize___8 = (int )((st.st_size + (__off_t )pagesize___28) - st.st_size % (long )pagesize___28);
#line 171
    tmp___0 = mmap((void *)0, (size_t )mapsize___8, 1, 1, groupfd___8, (__off_t )0);
#line 171
    mapbuf___8 = (char *)tmp___0;
    }
#line 172
    if (! mapbuf___8) {
      {
#line 174
      log_((char *)"reload:mmap:%m");
      }
#line 175
      return (-1);
    } else
#line 172
    if ((unsigned long )mapbuf___8 == (unsigned long )((void *)-1)) {
      {
#line 174
      log_((char *)"reload:mmap:%m");
      }
#line 175
      return (-1);
    }
  }
#line 188
  lim = mapbuf___8 + newsize;
#line 189
  state = 0;
#line 189
  ident = state;
#line 190
  gr = (char *)0;
#line 190
  ip = gr;
#line 191
  p = mapbuf___8 + oldsize___8;
  {
#line 191
  while (1) {
    while_continue: /* CIL Label */ ;
#line 191
    if (! ((unsigned long )p < (unsigned long )lim)) {
#line 191
      goto while_break;
    }
    {
#line 194
    if (state == 0) {
#line 194
      goto case_0;
    }
#line 195
    if (state == 1) {
#line 195
      goto case_1;
    }
#line 196
    if (state == 2) {
#line 196
      goto case_2;
    }
#line 197
    if (state == 3) {
#line 197
      goto case_3;
    }
#line 192
    goto switch_break;
    case_0: /* CIL Label */ 
#line 194
    if ((int )*p >= 48) {
#line 194
      if ((int )*p <= 57) {
#line 194
        ip = p;
#line 194
        state ++;
      }
    }
#line 194
    goto switch_break;
    case_1: /* CIL Label */ 
#line 195
    if (32 == (int )*p) {
      {
#line 195
      ident = atoi((char const   *)ip);
#line 195
      state ++;
      }
    }
#line 195
    goto switch_break;
    case_2: /* CIL Label */ 
#line 196
    if (32 != (int )*p) {
#line 196
      gr = p;
#line 196
      state ++;
    }
#line 196
    goto switch_break;
    case_3: /* CIL Label */ 
#line 198
    if (10 != (int )*p) {
#line 199
      goto switch_break;
    }
    {
#line 200
    tmp___1 = add___9(ident, gr, (int )(p - gr));
    }
#line 200
    if (-1 == tmp___1) {
      {
#line 202
      log_((char *)"reload:no memory");
      }
#line 203
      return (-1);
    }
#line 205
    state = 0;
    switch_break: /* CIL Label */ ;
    }
#line 191
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 208
  oldsize___8 = newsize;
#line 209
  return (0);
}
}
#line 26 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/key.c"
static struct buf *head___9  ;
#line 27 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/key.c"
static int avail___18  =    0;
#line 28 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/key.c"
static char *keybuf___8  =    (char *)((void *)0);
#line 33 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/key.c"
static unsigned int hv___8  ;
#line 35 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/key.c"
static void hash___18(char *key , int len ) 
{ 
  char *tmp ;

  {
#line 37
  hv___8 = 5381U;
  {
#line 38
  while (1) {
    while_continue: /* CIL Label */ ;
#line 38
    if (! len) {
#line 38
      goto while_break;
    }
#line 40
    len --;
#line 41
    hv___8 += hv___8 << 5;
#line 42
    tmp = key;
#line 42
    key ++;
#line 42
    hv___8 ^= (unsigned int )*tmp;
  }
  while_break: /* CIL Label */ ;
  }
#line 44
  hv___8 %= 128U;
#line 45
  return;
}
}
#line 52 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/snmail.c"
char *suffix  =    (char *)((void *)0);
#line 53 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/snmail.c"
char *prefix  =    (char *)"local.";
#line 54 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/snmail.c"
char *in_reply_to  =    (char *)((void *)0);
#line 55 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/snmail.c"
struct b path  =    {(char *)0, 0, 0};
#line 56 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/snmail.c"
struct b references  =    {(char *)0, 0, 0};
#line 59 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/snmail.c"
void memerr(void) 
{ 


  {
  {
#line 59
  fail(71, (char *)"No memory");
  }
#line 59
  return;
}
}
#line 65 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/snmail.c"
void appendtoreferences(char *buf___28 ) 
{ 
  char *dst ;
  char *p ;
  int len ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 70
  p = buf___28;
#line 70
  dst = p;
  {
#line 71
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 71
    p = addr_qstrchr(p, '<');
    }
#line 71
    if (! p) {
#line 71
      goto while_break;
    }
    {
#line 75
    len = addr_msgid(p);
    }
#line 75
    if (len <= 0) {
#line 77
      p ++;
#line 78
      goto while_continue;
    }
    {
#line 80
    tmp = b_appendl(& references, (char *)" <", 2);
    }
#line 80
    if (-1 == tmp) {
      {
#line 80
      memerr();
      }
    }
    {
#line 81
    tmp___0 = addr_unescape(p + 1, buf___28, len - 2);
#line 81
    tmp___1 = b_appendl(& references, buf___28, tmp___0);
    }
#line 81
    if (-1 == tmp___1) {
      {
#line 81
      memerr();
      }
    }
    {
#line 82
    tmp___2 = b_appendl(& references, (char *)">", 1);
    }
#line 82
    if (-1 == tmp___2) {
      {
#line 82
      memerr();
      }
    }
#line 83
    p += len;
  }
  while_break: /* CIL Label */ ;
  }
#line 85
  return;
}
}
#line 91 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/snmail.c"
void appendtopath(char *rcvd ) 
{ 
  int len ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 93
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 97
    rcvd = addr_qstrchr(rcvd, ' ');
    }
#line 97
    if (! rcvd) {
#line 98
      return;
    }
    {
#line 99
    tmp = strncasecmp((char const   *)rcvd, " by ", (size_t )4);
    }
#line 99
    if (tmp) {
#line 100
      goto __Cont;
    }
#line 101
    rcvd += 4;
    {
#line 101
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 101
      if (! (32 == (int )*rcvd)) {
#line 101
        if (! (9 == (int )*rcvd)) {
#line 101
          goto while_break___0;
        }
      }
#line 102
      if (! *rcvd) {
#line 103
        return;
      }
#line 101
      rcvd ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 104
    len = addr_domain(rcvd);
    }
#line 104
    if (len > 0) {
      {
#line 106
      tmp___0 = b_appendl(& path, (char *)"!", 1);
      }
#line 106
      if (-1 == tmp___0) {
        {
#line 106
        memerr();
        }
      }
      {
#line 107
      tmp___1 = b_appendl(& path, rcvd, len);
      }
#line 107
      if (-1 == tmp___1) {
        {
#line 107
        memerr();
        }
      }
    }
    __Cont: /* CIL Label */ 
#line 93
    rcvd ++;
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 116 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/snmail.c"
void savelocal(char *frm ) 
{ 
  int len ;
  void *tmp ;

  {
  {
#line 120
  frm = addr_qstrchr(frm, '<');
  }
#line 120
  if (frm) {
    {
#line 121
    frm ++;
#line 121
    len = addr_localpart(frm);
    }
#line 121
    if (len > 0) {
      {
#line 123
      tmp = malloc((size_t )(len + 1));
#line 123
      suffix = (char *)tmp;
      }
#line 123
      if (! suffix) {
        {
#line 124
        memerr();
        }
      }
      {
#line 125
      addr_unescape(frm, suffix, len);
      }
    }
  }
#line 127
  return;
}
}
#line 133 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/snmail.c"
struct b head  =    {(char *)0, 0, 0};
#line 135 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/snmail.c"
static int check_from_  ;
#line 137 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/snmail.c"
int switchline(char *line , int len ) 
{ 
  char *p ;
  int i ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  size_t tmp___7 ;
  void *tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;

  {
#line 142
  if (check_from_) {
    {
#line 144
    check_from_ = 0;
#line 145
    tmp = strncmp((char const   *)line, "From ", (size_t )5);
    }
#line 145
    if (0 == tmp) {
#line 146
      return (0);
    }
  }
  {
#line 149
  tmp___0 = check_field(line, len);
  }
#line 149
  if (! tmp___0) {
    {
#line 150
    log_((char *)"accepting bad header \"%s\"", line);
    }
  }
  {
#line 153
  if ((int )*line == 70) {
#line 153
    goto case_70;
  }
#line 153
  if ((int )*line == 102) {
#line 153
    goto case_70;
  }
#line 158
  if ((int )*line == 82) {
#line 158
    goto case_82;
  }
#line 158
  if ((int )*line == 114) {
#line 158
    goto case_82;
  }
#line 172
  if ((int )*line == 73) {
#line 172
    goto case_73;
  }
#line 172
  if ((int )*line == 105) {
#line 172
    goto case_73;
  }
#line 186
  if ((int )*line == 78) {
#line 186
    goto case_78;
  }
#line 186
  if ((int )*line == 110) {
#line 186
    goto case_78;
  }
#line 151
  goto switch_break;
  case_70: /* CIL Label */ 
  case_102: /* CIL Label */ 
#line 154
  if (! suffix) {
    {
#line 155
    tmp___1 = strncasecmp((char const   *)line, "From:", (size_t )5);
    }
#line 155
    if (0 == tmp___1) {
      {
#line 156
      savelocal(line + 5);
      }
    }
  }
#line 157
  goto switch_break;
  case_82: /* CIL Label */ 
  case_114: /* CIL Label */ 
  {
#line 159
  tmp___2 = strncasecmp((char const   *)line, "Received:", (size_t )9);
  }
#line 159
  if (0 == tmp___2) {
    {
#line 161
    appendtopath(line + 9);
    }
#line 162
    return (0);
  }
  {
#line 164
  tmp___3 = strncasecmp((char const   *)line, "References:", (size_t )11);
  }
#line 164
  if (0 == tmp___3) {
    {
#line 166
    appendtoreferences(line + 11);
    }
#line 167
    return (0);
  }
  {
#line 169
  tmp___4 = strncasecmp((char const   *)line, "Return-Path:", (size_t )12);
  }
#line 169
  if (0 == tmp___4) {
    {
#line 170
    savelocal(line + 12);
    }
  }
#line 171
  goto switch_break;
  case_73: /* CIL Label */ 
  case_105: /* CIL Label */ 
  {
#line 173
  tmp___9 = strncasecmp((char const   *)line, "In-Reply-To:", (size_t )12);
  }
#line 173
  if (0 == tmp___9) {
#line 177
    tmp___5 = line + 12;
#line 177
    p = tmp___5;
    {
#line 177
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 177
      tmp___5 = addr_qstrchr(tmp___5, '<');
      }
#line 177
      if (! tmp___5) {
#line 177
        goto while_break;
      }
#line 177
      tmp___6 = tmp___5;
#line 177
      tmp___5 ++;
#line 177
      p = tmp___6;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 179
    tmp___7 = strlen((char const   *)p);
#line 179
    i = (int )tmp___7;
#line 180
    tmp___8 = malloc((size_t )(i + 1));
#line 180
    in_reply_to = (char *)tmp___8;
    }
#line 180
    if (! in_reply_to) {
      {
#line 181
      memerr();
      }
    }
    {
#line 182
    strncpy((char */* __restrict  */)in_reply_to, (char const   */* __restrict  */)p,
            (size_t )i);
    }
#line 183
    return (0);
  }
#line 185
  goto switch_break;
  case_78: /* CIL Label */ 
  case_110: /* CIL Label */ 
  {
#line 187
  tmp___10 = strncasecmp((char const   *)line, "Newsgroups:", (size_t )11);
  }
#line 187
  if (0 == tmp___10) {
#line 188
    return (0);
  }
#line 189
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 191
  tmp___11 = b_appendl(& head, line, len);
  }
#line 191
  if (-1 == tmp___11) {
    {
#line 191
    memerr();
    }
  }
  {
#line 192
  tmp___12 = b_appendl(& head, (char *)"\r\n", 2);
  }
#line 192
  if (-1 == tmp___12) {
    {
#line 192
    memerr();
    }
  }
#line 193
  return (0);
}
}
#line 26 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/body.c"
static char *bodbuf___8  =    (char *)((void *)0);
#line 87 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/cache.c"
static struct entry *new_entry___9(int desc___35 ) 
{ 
  struct entry *ep ;
  struct entry *tmp ;

  {
#line 91
  ep = table[desc___35].freelist;
#line 91
  if (ep) {
#line 92
    table[desc___35].freelist = ep->next;
  } else {
#line 95
    ep = table[desc___35].entries;
    {
#line 95
    while (1) {
      while_continue: /* CIL Label */ ;
#line 95
      if (! ep->next) {
#line 95
        goto while_break;
      }
#line 95
      ep = ep->next;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 96
    (ep->prev)->next = (struct entry *)((void *)0);
#line 97
    (*(table[desc___35].freeobj))(ep->object);
    }
  }
#line 99
  tmp = (struct entry *)((void *)0);
#line 99
  ep->next = tmp;
#line 99
  ep->prev = tmp;
#line 100
  ep->object = (void *)0;
#line 101
  return (ep);
}
}
#line 67 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/store.c"
static int sto_cmp___6(void *a , void *b___13 ) 
{ 
  register struct storeobj *x ;
  register struct storeobj *y ;
  int tmp ;

  {
  {
#line 69
  x = (struct storeobj *)a;
#line 70
  y = (struct storeobj *)b___13;
#line 72
  tmp = strcmp((char const   *)x->filename, (char const   *)y->filename);
  }
#line 72
  return (tmp);
}
}
#line 75 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/store.c"
static int nosigio___6(ssize_t (*op)() , int fd , char *buf___28 , int len ) 
{ 
  int er ;
  int *tmp ;
  ssize_t tmp___0 ;

  {
  {
#line 79
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 79
    tmp___0 = (*op)(fd, buf___28, len);
#line 79
    er = (int )tmp___0;
    }
#line 79
    if (! (-1 == er)) {
#line 79
      goto while_break;
    }
    {
#line 80
    tmp = __errno_location();
    }
#line 80
    if (4 != *tmp) {
#line 82
      if (debug >= 1) {
        {
#line 82
        log_((char *)"nosigio:%m");
        }
      }
#line 83
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 85
  return (er);
}
}
#line 88 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/store.c"
static int copyart___6(int tofd , int fromfd , int fromseek , int len ) 
{ 
  char buf___28[1024] ;
  __off_t tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  {
#line 92
  tmp = lseek(fromfd, (__off_t )fromseek, 0);
  }
#line 92
  if (-1L == tmp) {
    {
#line 94
    log_((char *)"copyart:lseek:%m");
    }
#line 95
    return (-1);
  }
  {
#line 98
  while (1) {
    while_continue: /* CIL Label */ ;
#line 98
    if (! (len > 1024)) {
#line 98
      goto while_break;
    }
    {
#line 99
    tmp___0 = nosigio___6((ssize_t (*)())(& read), fromfd, buf___28, 1024);
    }
#line 99
    if (-1 == tmp___0) {
#line 100
      return (-1);
    } else {
      {
#line 99
      tmp___1 = nosigio___6((ssize_t (*)())(& write), tofd, buf___28, 1024);
      }
#line 99
      if (-1 == tmp___1) {
#line 100
        return (-1);
      }
    }
#line 98
    len -= 1024;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 101
  tmp___2 = nosigio___6((ssize_t (*)())(& read), fromfd, buf___28, len);
  }
#line 101
  if (-1 == tmp___2) {
#line 102
    return (-1);
  } else {
    {
#line 101
    tmp___3 = nosigio___6((ssize_t (*)())(& write), tofd, buf___28, len);
    }
#line 101
    if (-1 == tmp___3) {
#line 102
      return (-1);
    }
  }
#line 104
  return (0);
}
}
#line 107 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/store.c"
static int checkindex___6(struct info *p ) 
{ 


  {
#line 109
  if (p->hoffset > 0) {
#line 111
    if (p->boffset > 0) {
#line 112
      if (p->hlen > 0) {
#line 113
        if (p->blen > 0) {
#line 114
          return (0);
        }
      }
    }
  } else
#line 116
  if (-1 == p->hoffset) {
#line 116
    if (-1 == p->boffset) {
#line 117
      return (1);
    }
  }
#line 118
  return (-1);
}
}
#line 127 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/store.c"
static void reorder___6(struct storeobj *sp ) 
{ 
  char tmpname[287] ;
  char *p ;
  char *q ;
  int fd ;
  struct file f___9 ;
  int er ;
  int i ;
  char *tmp ;
  char tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char tmp___4 ;
  char *tmp___5 ;
  int *tmp___6 ;
  int tmp___7 ;
  char *p___0 ;
  int *tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  __off_t tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  __off_t tmp___17 ;
  __off_t tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;

  {
#line 133
  f___9.magic = 0;
#line 133
  f___9.info[0].hoffset = 0;
#line 133
  f___9.info[0].hlen = 0;
#line 133
  f___9.info[0].boffset = 0;
#line 133
  f___9.info[0].blen = 0;
#line 133
  f___9.info[1].hoffset = 0;
#line 133
  f___9.info[1].hlen = 0;
#line 133
  f___9.info[1].boffset = 0;
#line 133
  f___9.info[1].blen = 0;
#line 133
  f___9.info[2].hoffset = 0;
#line 133
  f___9.info[2].hlen = 0;
#line 133
  f___9.info[2].boffset = 0;
#line 133
  f___9.info[2].blen = 0;
#line 133
  f___9.info[3].hoffset = 0;
#line 133
  f___9.info[3].hlen = 0;
#line 133
  f___9.info[3].boffset = 0;
#line 133
  f___9.info[3].blen = 0;
#line 133
  f___9.info[4].hoffset = 0;
#line 133
  f___9.info[4].hlen = 0;
#line 133
  f___9.info[4].boffset = 0;
#line 133
  f___9.info[4].blen = 0;
#line 133
  f___9.info[5].hoffset = 0;
#line 133
  f___9.info[5].hlen = 0;
#line 133
  f___9.info[5].boffset = 0;
#line 133
  f___9.info[5].blen = 0;
#line 133
  f___9.info[6].hoffset = 0;
#line 133
  f___9.info[6].hlen = 0;
#line 133
  f___9.info[6].boffset = 0;
#line 133
  f___9.info[6].blen = 0;
#line 133
  f___9.info[7].hoffset = 0;
#line 133
  f___9.info[7].hlen = 0;
#line 133
  f___9.info[7].boffset = 0;
#line 133
  f___9.info[7].blen = 0;
#line 133
  f___9.info[8].hoffset = 0;
#line 133
  f___9.info[8].hlen = 0;
#line 133
  f___9.info[8].boffset = 0;
#line 133
  f___9.info[8].blen = 0;
#line 133
  f___9.info[9].hoffset = 0;
#line 133
  f___9.info[9].hlen = 0;
#line 133
  f___9.info[9].boffset = 0;
#line 133
  f___9.info[9].blen = 0;
#line 136
  p = tmpname;
#line 136
  q = sp->filename;
  {
#line 136
  while (1) {
    while_continue: /* CIL Label */ ;
#line 136
    tmp = p;
#line 136
    p ++;
#line 136
    tmp___1 = q;
#line 136
    q ++;
#line 136
    tmp___0 = *tmp___1;
#line 136
    *tmp = tmp___0;
#line 136
    if (! ((int )tmp___0 != 47)) {
#line 136
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 137
  tmp___2 = p;
#line 137
  p ++;
#line 137
  *tmp___2 = (char )'+';
  {
#line 138
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 138
    tmp___3 = p;
#line 138
    p ++;
#line 138
    tmp___5 = q;
#line 138
    q ++;
#line 138
    tmp___4 = *tmp___5;
#line 138
    *tmp___3 = tmp___4;
#line 138
    if (! tmp___4) {
#line 138
      goto while_break___0;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 139
  fd = open((char const   *)(tmpname), 194, 420);
  }
#line 140
  if (-1 == fd) {
    {
#line 142
    tmp___6 = __errno_location();
    }
#line 142
    if (17 != *tmp___6) {
      {
#line 143
      log_((char *)"reorder:open(%s):%m", tmpname);
      }
    }
#line 144
    return;
  }
  {
#line 147
  f___9.magic = 1027296;
#line 148
  tmp___7 = nosigio___6((ssize_t (*)())(& write), fd, (char *)(& f___9), (int )sizeof(f___9));
  }
#line 148
  if (-1 == tmp___7) {
#line 149
    goto fail;
  }
  {
#line 161
  tmp___9 = lockf(sp->fd, 2, (__off_t )0);
  }
#line 161
  if (-1 == tmp___9) {
    {
#line 165
    tmp___8 = __errno_location();
    }
#line 165
    if (11 != *tmp___8) {
#line 166
      p___0 = (char *)"reorder:can\'t lockf %s:%m";
    } else {
#line 168
      p___0 = (char *)"reorder:article in %s being cancelled?";
    }
    {
#line 169
    log_(p___0, sp->filename);
    }
#line 170
    goto fail;
  }
#line 173
  i = 0;
  {
#line 173
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 173
    if (! (i < 10)) {
#line 173
      goto while_break___1;
    }
    {
#line 174
    tmp___10 = checkindex___6((sp->file)->info + i);
    }
    {
#line 176
    if (tmp___10 == 0) {
#line 176
      goto case_0;
    }
#line 188
    if (tmp___10 == 1) {
#line 188
      goto case_1;
    }
#line 191
    if (tmp___10 == -1) {
#line 191
      goto case_neg_1;
    }
#line 174
    goto switch_break;
    case_0: /* CIL Label */ 
    {
#line 177
    tmp___12 = lseek(fd, (__off_t )0, 2);
#line 177
    tmp___11 = (int )tmp___12;
#line 177
    f___9.info[i].hoffset = tmp___11;
    }
#line 177
    if (tmp___11 > 0) {
      {
#line 179
      f___9.info[i].hlen = (sp->file)->info[i].hlen;
#line 180
      f___9.info[i].blen = (sp->file)->info[i].blen;
#line 181
      er = copyart___6(fd, sp->fd, (sp->file)->info[i].hoffset, f___9.info[i].hlen);
      }
#line 182
      if (0 == er) {
#line 183
        goto switch_break;
      }
    } else {
      {
#line 186
      log_((char *)"reorder:lseek(%s):%m", tmpname);
      }
    }
#line 187
    goto fail;
    case_1: /* CIL Label */ 
#line 189
    tmp___15 = -1;
#line 189
    f___9.info[i].hlen = tmp___15;
#line 189
    tmp___14 = tmp___15;
#line 189
    f___9.info[i].blen = tmp___14;
#line 189
    tmp___13 = tmp___14;
#line 189
    f___9.info[i].hoffset = tmp___13;
#line 189
    f___9.info[i].boffset = tmp___13;
#line 190
    goto switch_break;
    case_neg_1: /* CIL Label */ 
    {
#line 192
    log_((char *)"reorder:corrupt index in %s", sp->filename);
    }
#line 193
    goto fail;
    switch_break: /* CIL Label */ ;
    }
#line 173
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 195
  i = 0;
  {
#line 195
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 195
    if (! (i < 10)) {
#line 195
      goto while_break___2;
    }
#line 197
    if (-1 == f___9.info[i].boffset) {
#line 198
      goto __Cont;
    }
    {
#line 199
    tmp___17 = lseek(fd, (__off_t )0, 2);
#line 199
    tmp___16 = (int )tmp___17;
#line 199
    f___9.info[i].boffset = tmp___16;
    }
#line 199
    if (-1 == tmp___16) {
      {
#line 201
      log_((char *)"reorder:lseek(%s):%m", tmpname);
      }
#line 202
      goto fail;
    }
    {
#line 204
    er = copyart___6(fd, sp->fd, (sp->file)->info[i].boffset, f___9.info[i].blen);
    }
#line 205
    if (-1 == er) {
#line 206
      goto fail;
    }
    __Cont: /* CIL Label */ 
#line 195
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 209
  tmp___18 = lseek(fd, (__off_t )0, 0);
  }
#line 209
  if (-1L == tmp___18) {
    {
#line 211
    log_((char *)"reorder:lseek:%m");
    }
#line 212
    goto fail;
  }
  {
#line 214
  tmp___19 = nosigio___6((ssize_t (*)())(& write), fd, (char *)(& f___9), (int )sizeof(f___9));
  }
#line 214
  if (-1 == tmp___19) {
#line 215
    goto fail;
  }
  {
#line 216
  tmp___20 = rename((char const   *)(tmpname), (char const   *)sp->filename);
  }
#line 216
  if (-1 == tmp___20) {
    {
#line 218
    log_((char *)"reorder:rename:%m");
    }
#line 219
    goto fail;
  }
  {
#line 221
  close(fd);
  }
#line 222
  return;
  fail: 
  {
#line 225
  log_((char *)"reorder:write failed for %s:%m", sp->filename);
#line 226
  tmp___21 = unlink((char const   *)(tmpname));
  }
#line 226
  if (-1 == tmp___21) {
    {
#line 227
    log_((char *)"reorder:unlink(%s):%m", tmpname);
    }
  }
  {
#line 228
  close(fd);
  }
#line 229
  return;
}
}
#line 231 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/store.c"
static void sto_free___6(void *p ) 
{ 
  struct storeobj *sp ;
  int tmp ;

  {
  {
#line 233
  sp = (struct storeobj *)p;
#line 235
  close(sp->fd);
#line 236
  tmp = munmap((void *)((caddr_t )sp->file), sizeof(struct file ));
  }
#line 236
  if (-1 == tmp) {
    {
#line 237
    log_((char *)"sto_free:munmap:%m");
    }
  }
  {
#line 238
  free((void *)sp);
  }
#line 239
  return;
}
}
#line 241 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/store.c"
static int desc___26  ;
#line 304
static int tryopen___6(char *fn ) ;
#line 304 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/store.c"
static struct file f___6  =    {1027296, {{0, 0, 0, 0}}};
#line 270 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/store.c"
static int tryopen___6(char *fn ) 
{ 
  char fn2[287] ;
  int fd ;
  int i ;
  char *p ;
  char *q ;
  struct timeval tv ;
  char *tmp ;
  char tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  ssize_t tmp___7 ;

  {
  {
#line 278
  fd = open((char const   *)fn, 2);
  }
#line 278
  if (fd > -1) {
    {
#line 280
    lockf(fd, 1, (__off_t )0);
    }
#line 281
    return (fd);
  }
#line 283
  p = fn2;
#line 283
  q = fn;
  {
#line 283
  while (1) {
    while_continue: /* CIL Label */ ;
#line 283
    tmp = p;
#line 283
    p ++;
#line 283
    tmp___1 = q;
#line 283
    q ++;
#line 283
    tmp___0 = *tmp___1;
#line 283
    *tmp = tmp___0;
#line 283
    if (! ((int )tmp___0 != 47)) {
#line 283
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 284
  tmp___2 = p;
#line 284
  p ++;
#line 284
  *tmp___2 = (char )'+';
#line 285
  tmp___3 = p;
#line 285
  p ++;
#line 285
  *tmp___3 = (char )'+';
#line 286
  gettimeofday((struct timeval */* __restrict  */)(& tv), (__timezone_ptr_t )0);
#line 296
  i = (int )(tv.tv_sec / 30L);
  }
  {
#line 297
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 298
    tmp___4 = p;
#line 298
    p ++;
#line 298
    *tmp___4 = (char )(48 + i % 10);
#line 297
    i /= 10;
#line 297
    if (! i) {
#line 297
      goto while_break___0;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 300
  tmp___5 = p;
#line 300
  p ++;
#line 300
  *tmp___5 = (char )'\000';
#line 302
  i = 0;
  {
#line 302
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 302
    if (! (i < 100)) {
#line 302
      goto while_break___1;
    }
#line 306
    if (14 == i % 15) {
      {
#line 307
      log_((char *)"tryopen:racing on %s", fn);
      }
    }
    {
#line 308
    fd = open((char const   *)(fn2), 194, 420);
    }
#line 308
    if (fd > -1) {
      {
#line 310
      lockf(fd, 1, (__off_t )0);
#line 311
      tmp___7 = write(fd, (void const   *)((char *)(& f___6)), sizeof(f___6));
      }
#line 311
      if (sizeof(f___6) == (unsigned long )tmp___7) {
        {
#line 312
        tmp___6 = link((char const   *)(fn2), (char const   *)fn);
        }
#line 312
        if (0 == tmp___6) {
          {
#line 314
          unlink((char const   *)(fn2));
          }
#line 315
          return (fd);
        }
      }
      {
#line 317
      close(fd);
#line 318
      unlink((char const   *)(fn2));
      }
    }
    {
#line 321
    fd = open((char const   *)fn, 2);
    }
#line 321
    if (fd > -1) {
      {
#line 323
      lockf(fd, 1, (__off_t )0);
      }
#line 324
      return (fd);
    }
    {
#line 302
    nap(0, 300 + i);
#line 302
    i ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 327
  log_((char *)"tryopen:timed out opening %s:%m", fn);
  }
#line 328
  return (-1);
}
}
#line 337 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/store.c"
static struct storeobj *getstore___6(char *filename ) 
{ 
  struct storeobj *sp ;
  struct storeobj s ;
  int fd ;
  struct file *fp ;
  char buf___28[287] ;
  int c ;
  void *tmp ;
  void *tmp___0 ;
  char *p ;
  char *q ;
  char *tmp___1 ;
  char tmp___2 ;
  char *tmp___3 ;
  char *end ;
  unsigned long tmp___4 ;
  ssize_t tmp___5 ;
  size_t tmp___6 ;
  void *tmp___7 ;

  {
  {
#line 349
  s.filename = filename;
#line 350
  tmp = cache_find(desc___26, (void *)(& s));
#line 350
  sp = (struct storeobj *)tmp;
  }
#line 350
  if (sp) {
    {
#line 352
    lockf(sp->fd, 1, (__off_t )0);
    }
#line 353
    return (sp);
  }
  {
#line 356
  fd = tryopen___6(filename);
  }
#line 356
  if (-1 == fd) {
#line 357
    return ((struct storeobj *)0);
  }
  {
#line 361
  tmp___0 = mmap((void *)0, sizeof(*fp), 3, 1, fd, (__off_t )0);
#line 361
  fp = (struct file *)tmp___0;
  }
#line 362
  if (! fp) {
    {
#line 363
    log_((char *)"getstore:mmap(%s):%m", filename);
    }
  } else
#line 362
  if ((unsigned long )fp == (unsigned long )((void *)-1)) {
    {
#line 363
    log_((char *)"getstore:mmap(%s):%m", filename);
    }
  } else {
    {
#line 364
    tmp___6 = strlen((char const   *)filename);
#line 364
    tmp___7 = malloc((sizeof(*sp) + tmp___6) + 1UL);
#line 364
    sp = (struct storeobj *)tmp___7;
    }
#line 364
    if (sp) {
      {
#line 371
      sp->fd = fd;
#line 372
      sp->file = fp;
#line 373
      sp->filename = (char *)sp + sizeof(*sp);
#line 374
      strcpy((char */* __restrict  */)sp->filename, (char const   */* __restrict  */)filename);
#line 380
      p = buf___28;
#line 380
      q = filename;
      }
      {
#line 380
      while (1) {
        while_continue: /* CIL Label */ ;
#line 380
        tmp___1 = p;
#line 380
        p ++;
#line 380
        tmp___3 = q;
#line 380
        q ++;
#line 380
        tmp___2 = *tmp___3;
#line 380
        *tmp___1 = tmp___2;
#line 380
        if (! ((int )tmp___2 != 47)) {
#line 380
          goto while_break;
        }
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 381
      strcpy((char */* __restrict  */)p, (char const   */* __restrict  */)".compress");
#line 383
      fd = open((char const   *)(buf___28), 0);
      }
#line 383
      if (fd > -1) {
        {
#line 385
        sp->compressok = 1024;
#line 386
        tmp___5 = read(fd, (void *)(buf___28), sizeof(buf___28) - 1UL);
#line 386
        c = (int )tmp___5;
        }
#line 386
        if (c > 0) {
          {
#line 390
          buf___28[c] = (char )'\000';
#line 391
          tmp___4 = strtoul((char const   */* __restrict  */)(buf___28), (char **/* __restrict  */)(& end),
                            10);
#line 391
          c = (int )tmp___4;
          }
#line 392
          if (c > 1024) {
#line 392
            if (10 == (int )*end) {
#line 393
              sp->compressok = c;
            }
          }
        }
        {
#line 395
        close(fd);
        }
      } else {
#line 399
        sp->compressok = 0;
      }
      {
#line 400
      cache_insert(desc___26, (void *)sp);
      }
#line 401
      return (sp);
    } else {
      {
#line 366
      log_((char *)"getstore:no memory");
#line 367
      munmap((void *)fp, sizeof(*fp));
      }
    }
  }
  {
#line 403
  close(fd);
  }
#line 404
  return ((struct storeobj *)0);
}
}
#line 37 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/group.c"
static int desc___27  =    -1;
#line 59 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/group.c"
static int cmpgroup___9(void *a , void *b___13 ) 
{ 
  struct groupobj *x ;
  struct groupobj *y ;
  int tmp ;

  {
  {
#line 61
  x = (struct groupobj *)a;
#line 62
  y = (struct groupobj *)b___13;
#line 64
  tmp = strcmp((char const   *)x->groupname, (char const   *)y->groupname);
  }
#line 64
  return (tmp);
}
}
#line 67 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/group.c"
static void freegroup___9(void *p ) 
{ 
  struct groupobj *gop ;

  {
#line 69
  gop = (struct groupobj *)p;
#line 71
  if (gop->groupname) {
    {
#line 72
    free((void *)gop->groupname);
    }
  }
#line 73
  if (gop->dir.dir) {
    {
#line 74
    closedir(gop->dir.dir);
    }
  }
#line 75
  if (gop->lastf.f) {
    {
#line 76
    munmap((void *)((caddr_t )gop->lastf.f), sizeof(struct file ));
    }
  }
  {
#line 77
  free(p);
  }
#line 78
  return;
}
}
#line 94 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/group.c"
static int refresh___9(struct groupobj *gop , char *groupname ) 
{ 
  struct stat st ;
  struct dir *d ;
  struct lastf *lp ;
  bool needreread ;
  bool needrefile ;
  bool needreslot ;
  bool isemptygroup ;
  int tmp ;
  int tmp___0 ;
  struct dirent *dp ;
  int i ;
  int first ;
  int last___1 ;
  char *end ;
  int tmp___1 ;
  unsigned short const   **tmp___2 ;
  unsigned long tmp___3 ;
  int fd ;
  void *tmp___4 ;
  struct info *ip ;
  int slot ;

  {
#line 99
  needreread = (bool )0;
#line 100
  needrefile = (bool )0;
#line 101
  needreslot = (bool )0;
#line 102
  isemptygroup = (bool )0;
#line 104
  d = & gop->dir;
#line 105
  lp = & gop->lastf;
#line 107
  if (groupname) {
    {
#line 109
    memset((void *)gop, 0, sizeof(struct groupobj ));
#line 110
    gop->groupname = strdup((char const   *)groupname);
    }
#line 111
    if ((unsigned long )((void *)0) == (unsigned long )gop->groupname) {
      {
#line 113
      log_((char *)"refresh:strdup:%m");
      }
#line 114
      return (-1);
    }
    {
#line 116
    gop->dir.first = -1;
#line 117
    d->dir = opendir((char const   *)groupname);
    }
#line 118
    if ((unsigned long )((void *)0) == (unsigned long )d->dir) {
      {
#line 120
      log_((char *)"refresh:opendir:%m");
      }
#line 121
      return (-1);
    }
#line 123
    lp->name = -1;
#line 125
    needreslot = (bool )1;
#line 125
    needreread = needreslot;
#line 125
    needrefile = needreread;
  } else {
#line 131
    if (-1 == d->first) {
#line 132
      needreread = (bool )1;
    } else
#line 131
    if (0 == d->last) {
#line 132
      needreread = (bool )1;
    } else
#line 131
    if (! d->read) {
#line 132
      needreread = (bool )1;
    } else {
      {
#line 133
      tmp = dirfd(d->dir);
#line 133
      tmp___0 = fstat(tmp, & st);
      }
#line 133
      if (-1 == tmp___0) {
        {
#line 135
        log_((char *)"refresh:fstat:%m");
        }
#line 136
        return (-1);
      } else
#line 138
      if (d->read < st.st_mtim.tv_sec) {
#line 139
        needreread = (bool )1;
      }
    }
#line 140
    if (! lp->f) {
#line 141
      needreslot = (bool )1;
#line 141
      needrefile = needreslot;
    }
#line 142
    if (! needrefile) {
#line 143
      if (! lp->f) {
#line 144
        needrefile = (bool )1;
      }
    }
#line 145
    if (! needrefile) {
#line 146
      if (-1 == lp->name) {
#line 147
        needrefile = (bool )1;
      }
    }
  }
#line 150
  if (needreread) {
#line 150
    goto _L;
  } else
#line 150
  if (needreslot) {
    _L: /* CIL Label */ 
    {
#line 156
    first = -1;
#line 157
    last___1 = 0;
#line 158
    rewinddir(d->dir);
#line 159
    dp = readdir(d->dir);
    }
#line 160
    if ((unsigned long )((void *)0) == (unsigned long )dp) {
      {
#line 162
      log_((char *)"refresh:readdir:%m");
      }
#line 163
      return (-1);
    }
#line 165
    gop->nopost = (bool )0;
    {
#line 166
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 168
      tmp___2 = __ctype_b_loc();
      }
#line 168
      if (! ((int const   )*(*tmp___2 + (int )dp->d_name[0]) & 2048)) {
#line 170
        if (! gop->nopost) {
#line 170
          if (46 == (int )dp->d_name[0]) {
            {
#line 171
            tmp___1 = strcmp((char const   *)(dp->d_name), ".nopost");
            }
#line 171
            if (0 == tmp___1) {
#line 172
              gop->nopost = (bool )1;
            }
          }
        }
#line 173
        goto __Cont;
      }
      {
#line 175
      tmp___3 = strtoul((char const   */* __restrict  */)(dp->d_name), (char **/* __restrict  */)(& end),
                        10);
#line 175
      i = (int )tmp___3;
      }
#line 175
      if (i <= 0) {
#line 176
        goto __Cont;
      } else
#line 175
      if (*end) {
#line 176
        goto __Cont;
      }
#line 177
      if (first > i) {
#line 178
        first = i;
      } else
#line 177
      if (-1 == first) {
#line 178
        first = i;
      }
#line 179
      if (last___1 < i) {
#line 180
        last___1 = i;
      }
      __Cont: /* CIL Label */ 
      {
#line 166
      dp = readdir(d->dir);
      }
#line 166
      if (! dp) {
#line 166
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 183
    d->first = first;
#line 184
    d->last = last___1;
#line 185
    if (-1 == first) {
#line 185
      if (0 == last___1) {
#line 186
        isemptygroup = (bool )1;
      }
    }
#line 187
    if (last___1 != lp->name) {
#line 188
      needrefile = (bool )1;
    } else {
#line 190
      lp->name = last___1;
    }
    {
#line 191
    time(& d->read);
    }
  }
#line 194
  if (needrefile) {
#line 194
    goto _L___0;
  } else
#line 194
  if (needreslot) {
    _L___0: /* CIL Label */ 
#line 198
    if (lp->f) {
      {
#line 200
      munmap((void *)((caddr_t )lp->f), sizeof(struct file ));
#line 201
      lp->f = (struct file *)((void *)0);
      }
    }
#line 203
    if (isemptygroup) {
#line 204
      return (0);
    }
    {
#line 205
    fd = openf(0, 0, (char *)"%s/%d", gop->groupname, d->last);
    }
#line 206
    if (-1 == fd) {
      {
#line 208
      log_((char *)"refresh:open:%m");
      }
#line 209
      return (-1);
    }
    {
#line 211
    tmp___4 = mmap((void *)0, sizeof(struct file ), 1, 1, fd, (__off_t )0);
#line 211
    lp->f = (struct file *)tmp___4;
#line 212
    close(fd);
    }
#line 213
    if ((unsigned long )lp->f == (unsigned long )((void *)-1)) {
      {
#line 215
      log_((char *)"refresh:mmap:%m");
      }
#line 216
      return (-1);
    }
#line 218
    lp->slotsfilled = 0;
#line 219
    needreslot = (bool )1;
  }
#line 222
  if (needreslot) {
#line 224
    ip = (lp->f)->info;
#line 227
    slot = 9;
    {
#line 227
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 227
      if (! (slot > -1)) {
#line 227
        goto while_break___0;
      }
#line 228
      if ((ip + slot)->hoffset) {
#line 229
        goto while_break___0;
      }
#line 227
      slot --;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 230
    lp->slotsfilled = slot + 1;
  }
#line 233
  return (0);
}
}
#line 33 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/art.c"
static size_t pagesize___29  =    (size_t )0;
#line 80 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/art.c"
static void file_unmap___9(void *p ) 
{ 
  struct fileobj *fp ;

  {
  {
#line 82
  fp = (struct fileobj *)p;
#line 84
  munmap((void *)fp->map, (size_t )fp->size);
#line 85
  free((void *)fp);
  }
#line 86
  return;
}
}
#line 88 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/art.c"
static int file_cmp___9(void *a , void *b___13 ) 
{ 
  struct fileobj *x ;
  struct fileobj *y ;
  int tmp ;

  {
  {
#line 90
  x = (struct fileobj *)a;
#line 91
  y = (struct fileobj *)b___13;
#line 93
  tmp = strcmp((char const   *)x->path, (char const   *)y->path);
  }
#line 93
  return (tmp);
}
}
#line 96 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/art.c"
static int desc___28  =    -1;
#line 98 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/art.c"
static int file_init___9(void) 
{ 


  {
  {
#line 100
  desc___28 = cache_init(8, & file_cmp___9, & file_unmap___9, (int (*)(void * ))((void *)0));
  }
#line 101
  if (-1 == desc___28) {
    {
#line 103
    log_((char *)"file_init:%m");
    }
#line 104
    return (-1);
  }
#line 106
  return (0);
}
}
#line 109 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/art.c"
static struct file *file_gimme___9(char *name , int *size___1 ) 
{ 
  struct fileobj f___9 ;
  struct fileobj *fp ;
  void *tmp ;

  {
  {
#line 111
  f___9.path = (char *)0;
#line 111
  f___9.map = (char *)0;
#line 111
  f___9.size = 0;
#line 114
  f___9.path = name;
#line 116
  tmp = cache_find(desc___28, (void *)(& f___9));
#line 116
  fp = (struct fileobj *)tmp;
  }
#line 116
  if ((unsigned long )((void *)0) == (unsigned long )fp) {
    {
#line 118
    fp = file_map(name);
    }
#line 118
    if ((unsigned long )((void *)0) == (unsigned long )fp) {
#line 119
      return ((struct file *)((void *)0));
    } else {
      {
#line 121
      cache_insert(desc___28, (void *)fp);
      }
    }
  }
#line 124
  if (size___1) {
#line 125
    *size___1 = fp->size;
  }
#line 126
  return ((struct file *)fp->map);
}
}
#line 137 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/art.c"
static bool file_initialized___9  =    (bool )0;
#line 248 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/art.c"
static char ngroup___9[287]  ;
#line 297 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/art.c"
static int getfield___9(char *buf___28 , struct field *f___9 ) 
{ 
  register char *cp ;
  size_t tmp ;
  size_t tmp___0 ;

  {
  {
#line 299
  cp = buf___28;
#line 301
  tmp = strspn((char const   *)cp, " \t\f");
#line 301
  cp += tmp;
  }
#line 302
  if (! *cp) {
#line 304
    f___9->pointer = (char *)((void *)0);
#line 305
    return (0);
  }
  {
#line 307
  tmp___0 = strcspn((char const   *)cp, "\r\n");
#line 307
  f___9->len = (int )tmp___0;
  }
#line 308
  if (! f___9->len) {
#line 309
    return (0);
  }
#line 310
  f___9->pointer = cp;
#line 311
  return ((int )((cp + f___9->len) - buf___28));
}
}
#line 383 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/art.c"
static struct b b___10  =    {(char *)0, 0, 0};
#line 105 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/dh_find.c"
static int initfile___19(void) 
{ 
  int fd ;
  int integer ;
  int i ;
  char foo[3] ;
  unsigned int tmp ;
  int *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  ssize_t tmp___3 ;
  ssize_t tmp___4 ;

  {
#line 108
  integer = 218885376;
#line 110
  foo[0] = (char )'\000';
#line 110
  tmp = 1U;
  {
#line 110
  while (1) {
    while_continue: /* CIL Label */ ;
#line 110
    if (tmp >= 3U) {
#line 110
      goto while_break;
    }
#line 110
    foo[tmp] = (char)0;
#line 110
    tmp ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 112
  fd = open((char const   *)(dh_tablefile), 194, 420);
  }
#line 113
  if (fd == -1) {
#line 114
    return (-1);
  }
  {
#line 115
  tmp___2 = lockf(fd, 2, (__off_t )0);
  }
#line 115
  if (tmp___2 == -1) {
    {
#line 117
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 119
      tmp___0 = __errno_location();
      }
#line 119
      if (*tmp___0 == 11) {
        {
#line 120
        nap(0, 200);
        }
      } else {
#line 122
        goto fail;
      }
      {
#line 117
      tmp___1 = lockf(fd, 2, (__off_t )0);
      }
#line 117
      if (! (tmp___1 == -1)) {
#line 117
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 125
    lockf(fd, 0, (__off_t )0);
    }
#line 126
    return (fd);
  }
  {
#line 128
  tmp___3 = write(fd, (void const   *)(& integer), sizeof(int ));
  }
#line 128
  if ((unsigned long )tmp___3 != sizeof(int )) {
#line 129
    goto fail;
  }
#line 130
  i = 0;
  {
#line 130
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 130
    if (! (i < 10240)) {
#line 130
      goto while_break___1;
    }
    {
#line 131
    tmp___4 = write(fd, (void const   *)(foo), sizeof(foo));
    }
#line 131
    if ((unsigned long )tmp___4 != sizeof(foo)) {
#line 132
      goto fail;
    }
#line 130
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 133
  lseek(fd, (__off_t )0, 0);
#line 134
  lockf(fd, 0, (__off_t )0);
  }
#line 135
  return (fd);
  fail: 
#line 138
  if (fd > -1) {
    {
#line 139
    close(fd);
    }
  }
#line 140
  return (-1);
}
}
#line 78 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/allocate.c"
static struct table___1 table___10  =    {(char *)0, (char *)0, 0, 0, 0, 0};
#line 80
static int remapfile___9(void) ;
#line 106 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/allocate.c"
static int initfile___20(char *filename ) 
{ 
  struct chainfile cf ;
  int fd ;
  int i ;
  int ret ;
  ssize_t tmp ;
  int pad ;
  ssize_t tmp___0 ;

  {
  {
#line 108
  cf.chain_magic = 0;
#line 108
  cf.next[0] = 0;
#line 108
  cf.next[1] = 0;
#line 108
  cf.next[2] = 0;
#line 108
  cf.next[3] = 0;
#line 108
  cf.next[4] = 0;
#line 108
  cf.next[5] = 0;
#line 108
  cf.next[6] = 0;
#line 108
  cf.next[7] = 0;
#line 108
  cf.next[8] = 0;
#line 108
  cf.next[9] = 0;
#line 108
  cf.next[10] = 0;
#line 108
  cf.next[11] = 0;
#line 108
  cf.next[12] = 0;
#line 108
  cf.next[13] = 0;
#line 108
  cf.next[14] = 0;
#line 108
  cf.next[15] = 0;
#line 108
  cf.next[16] = 0;
#line 108
  cf.next[17] = 0;
#line 108
  cf.next[18] = 0;
#line 108
  cf.next[19] = 0;
#line 108
  cf.next[20] = 0;
#line 108
  cf.next[21] = 0;
#line 108
  cf.next[22] = 0;
#line 108
  cf.next[23] = 0;
#line 108
  cf.next[24] = 0;
#line 108
  cf.next[25] = 0;
#line 108
  cf.next[26] = 0;
#line 108
  cf.next[27] = 0;
#line 108
  cf.next[28] = 0;
#line 108
  cf.next[29] = 0;
#line 108
  cf.next[30] = 0;
#line 108
  cf.next[31] = 0;
#line 108
  cf.next[32] = 0;
#line 108
  cf.next[33] = 0;
#line 108
  cf.next[34] = 0;
#line 108
  cf.next[35] = 0;
#line 108
  cf.next[36] = 0;
#line 108
  cf.next[37] = 0;
#line 108
  cf.next[38] = 0;
#line 108
  cf.next[39] = 0;
#line 108
  cf.next[40] = 0;
#line 108
  cf.next[41] = 0;
#line 108
  cf.next[42] = 0;
#line 108
  cf.next[43] = 0;
#line 108
  cf.next[44] = 0;
#line 108
  cf.next[45] = 0;
#line 108
  cf.next[46] = 0;
#line 108
  cf.next[47] = 0;
#line 108
  cf.next[48] = 0;
#line 108
  cf.next[49] = 0;
#line 108
  cf.next[50] = 0;
#line 108
  cf.next[51] = 0;
#line 108
  cf.next[52] = 0;
#line 108
  cf.next[53] = 0;
#line 108
  cf.next[54] = 0;
#line 108
  cf.next[55] = 0;
#line 108
  cf.next[56] = 0;
#line 108
  cf.next[57] = 0;
#line 108
  cf.next[58] = 0;
#line 108
  cf.next[59] = 0;
#line 108
  cf.next[60] = 0;
#line 108
  cf.next[61] = 0;
#line 108
  cf.next[62] = 0;
#line 111
  ret = 0;
#line 113
  fd = open((char const   *)filename, 578, 420);
  }
#line 114
  if (-1 == fd) {
#line 115
    return (-1);
  }
#line 116
  cf.chain_magic = 13680336;
#line 117
  i = 0;
  {
#line 117
  while (1) {
    while_continue: /* CIL Label */ ;
#line 117
    if (! (i < 63)) {
#line 117
      goto while_break;
    }
#line 118
    cf.next[i] = (int volatile   )0;
#line 117
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 119
  tmp = write(fd, (void const   *)(& cf), sizeof(cf));
#line 119
  i = (int )tmp;
  }
#line 120
  if ((unsigned long )i == sizeof(cf)) {
#line 124
    pad = (int )(sizeof(cf) % 4UL);
#line 125
    if (pad > 0) {
#line 126
      i = 0;
      {
#line 126
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 126
        if (i < pad) {
#line 126
          if (! (0 == ret)) {
#line 126
            goto while_break___0;
          }
        } else {
#line 126
          goto while_break___0;
        }
        {
#line 127
        tmp___0 = write(fd, (void const   *)"", (size_t )1);
        }
#line 127
        if (1L != tmp___0) {
#line 128
          ret = -1;
        }
#line 126
        i ++;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
  } else {
#line 131
    ret = -1;
  }
  {
#line 132
  close(fd);
  }
#line 133
  return (ret);
}
}
#line 136 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/allocate.c"
static void unmapfile___9(void) 
{ 


  {
#line 138
  if (table___10.fd >= 0) {
    {
#line 140
    close(table___10.fd);
#line 141
    table___10.fd = -1;
    }
  }
#line 143
  if (table___10.map) {
    {
#line 145
    munmap((void *)table___10.map, (size_t )table___10.size);
#line 146
    table___10.map = (char *)((void *)0);
#line 147
    table___10.size = 0;
    }
  }
#line 149
  return;
}
}
#line 153
static size_t rounduptopagesize___9(size_t size___1 ) ;
#line 153 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/allocate.c"
static size_t pagesize___30  =    (size_t )0;
#line 151 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/allocate.c"
static size_t rounduptopagesize___9(size_t size___1 ) 
{ 
  int pages ;
  int tmp ;

  {
#line 156
  if (0UL == pagesize___30) {
    {
#line 157
    tmp = getpagesize();
#line 157
    pagesize___30 = (size_t )tmp;
    }
  }
#line 158
  pages = (int )(size___1 / pagesize___30 + 1UL);
#line 159
  return ((size_t )pages * pagesize___30);
}
}
#line 162 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/allocate.c"
static int mapfile___9(void) 
{ 
  struct stat st ;
  int tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;

  {
#line 166
  if (-1 == table___10.fd) {
    {
#line 167
    table___10.fd = open((char const   *)table___10.filename, table___10.oflag, 420);
    }
  }
#line 168
  if (-1 == table___10.fd) {
#line 169
    goto fail;
  }
  {
#line 171
  tmp = fstat(table___10.fd, & st);
  }
#line 171
  if (-1 == tmp) {
#line 172
    goto fail;
  }
  {
#line 173
  tmp___0 = rounduptopagesize___9((size_t )st.st_size);
#line 173
  table___10.size = (int )tmp___0;
#line 174
  tmp___1 = mmap((void *)0, (size_t )table___10.size, table___10.mprot, 1, table___10.fd,
                 (__off_t )0);
#line 174
  table___10.map = (char *)tmp___1;
  }
#line 175
  if (! table___10.map) {
#line 176
    goto fail;
  } else
#line 175
  if ((unsigned long )table___10.map == (unsigned long )((void *)-1)) {
#line 176
    goto fail;
  }
#line 178
  return (0);
  fail: 
  {
#line 181
  unmapfile___9();
  }
#line 182
  return (-1);
}
}
#line 189 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/allocate.c"
static int remapfile___9(void) 
{ 
  struct stat st ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 193
  tmp = fstat(table___10.fd, & st);
  }
#line 193
  if (-1 == tmp) {
#line 194
    return (-1);
  }
#line 196
  if (st.st_size <= (__off_t )table___10.size) {
#line 197
    return (0);
  }
  {
#line 199
  munmap((void *)table___10.map, (size_t )table___10.size);
#line 200
  tmp___0 = mapfile___9();
  }
#line 200
  return (tmp___0);
}
}
#line 209 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/allocate.c"
static int lock___9(void) 
{ 
  int *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 211
  tmp___2 = lockf(table___10.fd, 2, (__off_t )0);
  }
#line 211
  if (-1 == tmp___2) {
    {
#line 213
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 215
      tmp = __errno_location();
      }
#line 215
      if (11 != *tmp) {
#line 216
        return (-1);
      } else {
        {
#line 218
        nap(0, 200);
        }
      }
      {
#line 213
      tmp___0 = lockf(table___10.fd, 2, (__off_t )0);
      }
#line 213
      if (! (-1 == tmp___0)) {
#line 213
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 221
    tmp___1 = remapfile___9();
    }
#line 221
    if (-1 == tmp___1) {
#line 222
      return (-1);
    }
  }
#line 224
  return (0);
}
}
#line 227 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/allocate.c"
static void unlock___9(void) 
{ 


  {
  {
#line 229
  lseek(table___10.fd, (__off_t )0, 0);
#line 230
  lockf(table___10.fd, 0, (__off_t )0);
  }
#line 231
  return;
}
}
#line 233 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/allocate.c"
static int checkvalidfile___9(void) 
{ 


  {
#line 235
  if (table___10.size > 0) {
#line 237
    if ((unsigned long )table___10.size < sizeof(struct chainfile )) {
#line 238
      return (-1);
    }
#line 239
    if (((struct chainfile *)table___10.map)->chain_magic != 13680336) {
#line 240
      return (-1);
    }
  }
#line 242
  return (0);
}
}
#line 281 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/allocate.c"
static int rounduptoalignment___9(int size___1 ) 
{ 


  {
#line 283
  if (size___1 <= 0) {
#line 284
    return (4);
  }
#line 285
  return (((size___1 - 1) / 4 + 1) * 4);
}
}
#line 296 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/allocate.c"
static char tmpchunk___9[272]  = {      (char )'\000'};
#line 56 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/dhash.c"
static unsigned char buf___22[2]  ;
#line 54 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/dhash.c"
static char *inttochar2___9(int integer ) 
{ 


  {
#line 58
  buf___22[0] = (unsigned char )((integer & 65535) >> 8);
#line 59
  buf___22[1] = (unsigned char )(integer & 255);
#line 60
  return ((char *)(buf___22));
}
}
#line 65 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/dhash.c"
static unsigned char buf___23[3]  ;
#line 63 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/dhash.c"
static char *inttochar3___9(unsigned int integer ) 
{ 


  {
#line 67
  integer >>= 2;
#line 68
  buf___23[0] = (unsigned char )((integer & 16777215U) >> 16);
#line 69
  buf___23[1] = (unsigned char )((integer & 65535U) >> 8);
#line 70
  buf___23[2] = (unsigned char )(integer & 255U);
#line 71
  return ((char *)(buf___23));
}
}
#line 803 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) symlink)(char const   *__from ,
                                                                                                char const   *__to ) ;
#line 835
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) rmdir)(char const   *__path ) ;
#line 312 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) __mode_t ( __attribute__((__leaf__)) umask)(__mode_t __mask ) ;
#line 321
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) mkdir)(char const   *__path ,
                                                                                            __mode_t __mode ) ;
#line 11 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/valid.h"
extern bool is_valid_name(char *name ) ;
#line 32 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/snnewgroup.c"
void makedir(char *fn ) 
{ 
  struct stat st ;
  int tmp ;
  int *tmp___0 ;
  int tmp___1 ;

  {
  {
#line 36
  tmp = stat((char const   */* __restrict  */)fn, (struct stat */* __restrict  */)(& st));
  }
#line 36
  if (0 == tmp) {
#line 38
    if (! ((st.st_mode & 61440U) == 16384U)) {
      {
#line 39
      fail(1, (char *)"\"%s\" exists but is not a directory, remove it first", fn);
      }
    }
#line 40
    if (debug >= 1) {
      {
#line 40
      log_((char *)"directory \"%s\" already exists, ok", fn);
      }
    }
#line 41
    return;
  }
  {
#line 43
  tmp___0 = __errno_location();
  }
#line 43
  if (2 != *tmp___0) {
    {
#line 44
    fail(2, (char *)"Weird error on stat(%s):%m", fn);
    }
  }
#line 45
  if (debug >= 1) {
    {
#line 45
    log_((char *)"Creating directory \"%s\"...", fn);
    }
  }
  {
#line 46
  tmp___1 = mkdir((char const   *)fn, (__mode_t )493);
  }
#line 46
  if (-1 == tmp___1) {
    {
#line 47
    fail(2, (char *)"Can\'t mkdir(%s):%m", fn);
    }
  }
#line 48
  if (debug >= 1) {
    {
#line 48
    log_((char *)"Done");
    }
  }
#line 49
  return;
}
}
#line 51 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/snnewgroup.c"
int touch(char *fn ) 
{ 
  int fd ;

  {
#line 55
  if (debug >= 1) {
    {
#line 55
    log_((char *)"Creating \"%s\" file...", fn);
    }
  }
  {
#line 56
  fd = open((char const   *)fn, 65, 420);
  }
#line 57
  if (fd > -1) {
#line 59
    if (debug >= 1) {
      {
#line 59
      log_((char *)"Done");
      }
    }
  } else {
    {
#line 62
    log_((char *)"Can\'t create %s:%m", fn);
    }
  }
#line 63
  return (fd);
}
}
#line 35 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/newsgroup.c"
static struct ng *bygroup___9[128]  ;
#line 36 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/newsgroup.c"
static struct ng *byident___9[128]  ;
#line 37 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/newsgroup.c"
static int highest___9  =    0;
#line 39 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/newsgroup.c"
static unsigned int hash___19(char *buf___28 , int len ) 
{ 
  unsigned int h ;
  char *tmp ;

  {
#line 43
  h = 5381U;
  {
#line 44
  while (1) {
    while_continue: /* CIL Label */ ;
#line 44
    if (! len) {
#line 44
      goto while_break;
    }
#line 46
    len --;
#line 47
    h += h << 5;
#line 48
    tmp = buf___28;
#line 48
    buf___28 ++;
#line 48
    h ^= (unsigned int )*tmp;
  }
  while_break: /* CIL Label */ ;
  }
#line 50
  return (h);
}
}
#line 53 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/newsgroup.c"
static struct chunk *chunks___9  ;
#line 58 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/newsgroup.c"
static int avail___19  =    0;
#line 59 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/newsgroup.c"
static int nr___10  =    0;
#line 64 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/newsgroup.c"
static int add___10(int ident , char *group , int len ) 
{ 
  struct ng *np ;
  struct ng *p ;
  int want ;
  unsigned int h ;
  struct chunk *tmp ;
  int size___1 ;
  void *tmp___0 ;
  unsigned int tmp___1 ;
  int tmp___2 ;

  {
#line 71
  len ++;
#line 72
  want = (int )(((unsigned long )len + sizeof(struct ng )) + sizeof(char *));
#line 73
  want = (int )((unsigned long )want - (unsigned long )len % sizeof(char *));
#line 74
  len --;
#line 76
  if (avail___19 < want) {
#line 81
    if (want > 240) {
#line 81
      size___1 = want + 240;
    } else {
#line 81
      size___1 = 240;
    }
    {
#line 82
    tmp___0 = malloc((size_t )size___1);
#line 82
    tmp = (struct chunk *)tmp___0;
    }
#line 82
    if (! tmp) {
#line 83
      return (-1);
    }
#line 84
    tmp->next = chunks___9;
#line 85
    chunks___9 = tmp;
#line 86
    chunks___9->buf = (char *)chunks___9 + sizeof(struct chunk );
#line 87
    avail___19 = (int )((unsigned long )size___1 - sizeof(struct chunk ));
  }
  {
#line 89
  np = (struct ng *)chunks___9->buf;
#line 90
  chunks___9->buf += want;
#line 91
  avail___19 -= want;
#line 92
  strncpy((char */* __restrict  */)(np->group), (char const   */* __restrict  */)group,
          (size_t )len);
#line 93
  np->group[len] = (char )'\000';
#line 94
  np->ident = ident;
#line 96
  tmp___1 = hash___19(group, len);
#line 96
  h = tmp___1 % 128U;
#line 97
  np->gnext = bygroup___9[h];
#line 98
  bygroup___9[h] = np;
#line 99
  p = np->gnext;
  }
  {
#line 99
  while (1) {
    while_continue: /* CIL Label */ ;
#line 99
    if (! p) {
#line 99
      goto while_break;
    }
    {
#line 100
    tmp___2 = strcmp((char const   *)(p->group), (char const   *)group);
    }
#line 100
    if (0 == tmp___2) {
#line 101
      return (1);
    }
#line 99
    p = p->gnext;
  }
  while_break: /* CIL Label */ ;
  }
#line 102
  h = (unsigned int )(ident % 128);
#line 103
  np->inext = byident___9[h];
#line 104
  byident___9[h] = np;
#line 105
  p = np->inext;
  {
#line 105
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 105
    if (! p) {
#line 105
      goto while_break___0;
    }
#line 106
    if (p->ident == ident) {
#line 107
      return (1);
    }
#line 105
    p = p->inext;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 109
  if (ident > highest___9) {
#line 110
    highest___9 = ident;
  }
#line 111
  nr___10 ++;
#line 112
  return (0);
}
}
#line 116 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/newsgroup.c"
static int groupfd___9  =    -1;
#line 117 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/newsgroup.c"
static int oldsize___9  =    0;
#line 118 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/newsgroup.c"
static int mapsize___9  =    0;
#line 119 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/newsgroup.c"
static char *mapbuf___9  =    (char *)((void *)0);
#line 148
static int reload___9(void) ;
#line 148 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/newsgroup.c"
static int pagesize___31  =    0;
#line 145 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/newsgroup.c"
static int reload___9(void) 
{ 
  struct stat st ;
  int newsize ;
  int tmp ;
  void *tmp___0 ;
  char *p ;
  char *lim ;
  char *ip ;
  char *gr ;
  int ident ;
  int state ;
  int tmp___1 ;

  {
  {
#line 156
  tmp = fstat(groupfd___9, & st);
  }
#line 156
  if (-1 == tmp) {
    {
#line 158
    log_((char *)"reload:fstat:%m");
    }
#line 159
    return (-1);
  }
#line 161
  newsize = (int )st.st_size;
#line 162
  if (! pagesize___31) {
    {
#line 163
    pagesize___31 = getpagesize();
    }
  }
#line 164
  if (newsize <= oldsize___9) {
#line 165
    return (0);
  }
#line 166
  if (newsize > mapsize___9) {
#line 166
    goto _L;
  } else
#line 166
  if (! mapsize___9) {
    _L: /* CIL Label */ 
#line 168
    if (mapbuf___9) {
      {
#line 169
      munmap((void *)mapbuf___9, (size_t )mapsize___9);
      }
    }
    {
#line 170
    mapsize___9 = (int )((st.st_size + (__off_t )pagesize___31) - st.st_size % (long )pagesize___31);
#line 171
    tmp___0 = mmap((void *)0, (size_t )mapsize___9, 1, 1, groupfd___9, (__off_t )0);
#line 171
    mapbuf___9 = (char *)tmp___0;
    }
#line 172
    if (! mapbuf___9) {
      {
#line 174
      log_((char *)"reload:mmap:%m");
      }
#line 175
      return (-1);
    } else
#line 172
    if ((unsigned long )mapbuf___9 == (unsigned long )((void *)-1)) {
      {
#line 174
      log_((char *)"reload:mmap:%m");
      }
#line 175
      return (-1);
    }
  }
#line 188
  lim = mapbuf___9 + newsize;
#line 189
  state = 0;
#line 189
  ident = state;
#line 190
  gr = (char *)0;
#line 190
  ip = gr;
#line 191
  p = mapbuf___9 + oldsize___9;
  {
#line 191
  while (1) {
    while_continue: /* CIL Label */ ;
#line 191
    if (! ((unsigned long )p < (unsigned long )lim)) {
#line 191
      goto while_break;
    }
    {
#line 194
    if (state == 0) {
#line 194
      goto case_0;
    }
#line 195
    if (state == 1) {
#line 195
      goto case_1;
    }
#line 196
    if (state == 2) {
#line 196
      goto case_2;
    }
#line 197
    if (state == 3) {
#line 197
      goto case_3;
    }
#line 192
    goto switch_break;
    case_0: /* CIL Label */ 
#line 194
    if ((int )*p >= 48) {
#line 194
      if ((int )*p <= 57) {
#line 194
        ip = p;
#line 194
        state ++;
      }
    }
#line 194
    goto switch_break;
    case_1: /* CIL Label */ 
#line 195
    if (32 == (int )*p) {
      {
#line 195
      ident = atoi((char const   *)ip);
#line 195
      state ++;
      }
    }
#line 195
    goto switch_break;
    case_2: /* CIL Label */ 
#line 196
    if (32 != (int )*p) {
#line 196
      gr = p;
#line 196
      state ++;
    }
#line 196
    goto switch_break;
    case_3: /* CIL Label */ 
#line 198
    if (10 != (int )*p) {
#line 199
      goto switch_break;
    }
    {
#line 200
    tmp___1 = add___10(ident, gr, (int )(p - gr));
    }
#line 200
    if (-1 == tmp___1) {
      {
#line 202
      log_((char *)"reload:no memory");
      }
#line 203
      return (-1);
    }
#line 205
    state = 0;
    switch_break: /* CIL Label */ ;
    }
#line 191
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 208
  oldsize___9 = newsize;
#line 209
  return (0);
}
}
#line 26 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/key.c"
static struct buf *head___10  ;
#line 27 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/key.c"
static int avail___20  =    0;
#line 28 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/key.c"
static char *keybuf___9  =    (char *)((void *)0);
#line 33 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/key.c"
static unsigned int hv___9  ;
#line 35 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/key.c"
static void hash___20(char *key , int len ) 
{ 
  char *tmp ;

  {
#line 37
  hv___9 = 5381U;
  {
#line 38
  while (1) {
    while_continue: /* CIL Label */ ;
#line 38
    if (! len) {
#line 38
      goto while_break;
    }
#line 40
    len --;
#line 41
    hv___9 += hv___9 << 5;
#line 42
    tmp = key;
#line 42
    key ++;
#line 42
    hv___9 ^= (unsigned int )*tmp;
  }
  while_break: /* CIL Label */ ;
  }
#line 44
  hv___9 %= 128U;
#line 45
  return;
}
}
#line 26 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/body.c"
static char *bodbuf___9  =    (char *)((void *)0);
#line 87 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/cache.c"
static struct entry *new_entry___10(int desc___35 ) 
{ 
  struct entry *ep ;
  struct entry *tmp ;

  {
#line 91
  ep = table[desc___35].freelist;
#line 91
  if (ep) {
#line 92
    table[desc___35].freelist = ep->next;
  } else {
#line 95
    ep = table[desc___35].entries;
    {
#line 95
    while (1) {
      while_continue: /* CIL Label */ ;
#line 95
      if (! ep->next) {
#line 95
        goto while_break;
      }
#line 95
      ep = ep->next;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 96
    (ep->prev)->next = (struct entry *)((void *)0);
#line 97
    (*(table[desc___35].freeobj))(ep->object);
    }
  }
#line 99
  tmp = (struct entry *)((void *)0);
#line 99
  ep->next = tmp;
#line 99
  ep->prev = tmp;
#line 100
  ep->object = (void *)0;
#line 101
  return (ep);
}
}
#line 67 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/store.c"
static int sto_cmp___7(void *a , void *b___13 ) 
{ 
  register struct storeobj *x ;
  register struct storeobj *y ;
  int tmp ;

  {
  {
#line 69
  x = (struct storeobj *)a;
#line 70
  y = (struct storeobj *)b___13;
#line 72
  tmp = strcmp((char const   *)x->filename, (char const   *)y->filename);
  }
#line 72
  return (tmp);
}
}
#line 75 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/store.c"
static int nosigio___7(ssize_t (*op)() , int fd , char *buf___28 , int len ) 
{ 
  int er ;
  int *tmp ;
  ssize_t tmp___0 ;

  {
  {
#line 79
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 79
    tmp___0 = (*op)(fd, buf___28, len);
#line 79
    er = (int )tmp___0;
    }
#line 79
    if (! (-1 == er)) {
#line 79
      goto while_break;
    }
    {
#line 80
    tmp = __errno_location();
    }
#line 80
    if (4 != *tmp) {
#line 82
      if (debug >= 1) {
        {
#line 82
        log_((char *)"nosigio:%m");
        }
      }
#line 83
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 85
  return (er);
}
}
#line 88 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/store.c"
static int copyart___7(int tofd , int fromfd , int fromseek , int len ) 
{ 
  char buf___28[1024] ;
  __off_t tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  {
#line 92
  tmp = lseek(fromfd, (__off_t )fromseek, 0);
  }
#line 92
  if (-1L == tmp) {
    {
#line 94
    log_((char *)"copyart:lseek:%m");
    }
#line 95
    return (-1);
  }
  {
#line 98
  while (1) {
    while_continue: /* CIL Label */ ;
#line 98
    if (! (len > 1024)) {
#line 98
      goto while_break;
    }
    {
#line 99
    tmp___0 = nosigio___7((ssize_t (*)())(& read), fromfd, buf___28, 1024);
    }
#line 99
    if (-1 == tmp___0) {
#line 100
      return (-1);
    } else {
      {
#line 99
      tmp___1 = nosigio___7((ssize_t (*)())(& write), tofd, buf___28, 1024);
      }
#line 99
      if (-1 == tmp___1) {
#line 100
        return (-1);
      }
    }
#line 98
    len -= 1024;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 101
  tmp___2 = nosigio___7((ssize_t (*)())(& read), fromfd, buf___28, len);
  }
#line 101
  if (-1 == tmp___2) {
#line 102
    return (-1);
  } else {
    {
#line 101
    tmp___3 = nosigio___7((ssize_t (*)())(& write), tofd, buf___28, len);
    }
#line 101
    if (-1 == tmp___3) {
#line 102
      return (-1);
    }
  }
#line 104
  return (0);
}
}
#line 107 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/store.c"
static int checkindex___7(struct info *p ) 
{ 


  {
#line 109
  if (p->hoffset > 0) {
#line 111
    if (p->boffset > 0) {
#line 112
      if (p->hlen > 0) {
#line 113
        if (p->blen > 0) {
#line 114
          return (0);
        }
      }
    }
  } else
#line 116
  if (-1 == p->hoffset) {
#line 116
    if (-1 == p->boffset) {
#line 117
      return (1);
    }
  }
#line 118
  return (-1);
}
}
#line 127 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/store.c"
static void reorder___7(struct storeobj *sp ) 
{ 
  char tmpname[287] ;
  char *p ;
  char *q ;
  int fd ;
  struct file f___9 ;
  int er ;
  int i ;
  char *tmp ;
  char tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char tmp___4 ;
  char *tmp___5 ;
  int *tmp___6 ;
  int tmp___7 ;
  char *p___0 ;
  int *tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  __off_t tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  __off_t tmp___17 ;
  __off_t tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;

  {
#line 133
  f___9.magic = 0;
#line 133
  f___9.info[0].hoffset = 0;
#line 133
  f___9.info[0].hlen = 0;
#line 133
  f___9.info[0].boffset = 0;
#line 133
  f___9.info[0].blen = 0;
#line 133
  f___9.info[1].hoffset = 0;
#line 133
  f___9.info[1].hlen = 0;
#line 133
  f___9.info[1].boffset = 0;
#line 133
  f___9.info[1].blen = 0;
#line 133
  f___9.info[2].hoffset = 0;
#line 133
  f___9.info[2].hlen = 0;
#line 133
  f___9.info[2].boffset = 0;
#line 133
  f___9.info[2].blen = 0;
#line 133
  f___9.info[3].hoffset = 0;
#line 133
  f___9.info[3].hlen = 0;
#line 133
  f___9.info[3].boffset = 0;
#line 133
  f___9.info[3].blen = 0;
#line 133
  f___9.info[4].hoffset = 0;
#line 133
  f___9.info[4].hlen = 0;
#line 133
  f___9.info[4].boffset = 0;
#line 133
  f___9.info[4].blen = 0;
#line 133
  f___9.info[5].hoffset = 0;
#line 133
  f___9.info[5].hlen = 0;
#line 133
  f___9.info[5].boffset = 0;
#line 133
  f___9.info[5].blen = 0;
#line 133
  f___9.info[6].hoffset = 0;
#line 133
  f___9.info[6].hlen = 0;
#line 133
  f___9.info[6].boffset = 0;
#line 133
  f___9.info[6].blen = 0;
#line 133
  f___9.info[7].hoffset = 0;
#line 133
  f___9.info[7].hlen = 0;
#line 133
  f___9.info[7].boffset = 0;
#line 133
  f___9.info[7].blen = 0;
#line 133
  f___9.info[8].hoffset = 0;
#line 133
  f___9.info[8].hlen = 0;
#line 133
  f___9.info[8].boffset = 0;
#line 133
  f___9.info[8].blen = 0;
#line 133
  f___9.info[9].hoffset = 0;
#line 133
  f___9.info[9].hlen = 0;
#line 133
  f___9.info[9].boffset = 0;
#line 133
  f___9.info[9].blen = 0;
#line 136
  p = tmpname;
#line 136
  q = sp->filename;
  {
#line 136
  while (1) {
    while_continue: /* CIL Label */ ;
#line 136
    tmp = p;
#line 136
    p ++;
#line 136
    tmp___1 = q;
#line 136
    q ++;
#line 136
    tmp___0 = *tmp___1;
#line 136
    *tmp = tmp___0;
#line 136
    if (! ((int )tmp___0 != 47)) {
#line 136
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 137
  tmp___2 = p;
#line 137
  p ++;
#line 137
  *tmp___2 = (char )'+';
  {
#line 138
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 138
    tmp___3 = p;
#line 138
    p ++;
#line 138
    tmp___5 = q;
#line 138
    q ++;
#line 138
    tmp___4 = *tmp___5;
#line 138
    *tmp___3 = tmp___4;
#line 138
    if (! tmp___4) {
#line 138
      goto while_break___0;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 139
  fd = open((char const   *)(tmpname), 194, 420);
  }
#line 140
  if (-1 == fd) {
    {
#line 142
    tmp___6 = __errno_location();
    }
#line 142
    if (17 != *tmp___6) {
      {
#line 143
      log_((char *)"reorder:open(%s):%m", tmpname);
      }
    }
#line 144
    return;
  }
  {
#line 147
  f___9.magic = 1027296;
#line 148
  tmp___7 = nosigio___7((ssize_t (*)())(& write), fd, (char *)(& f___9), (int )sizeof(f___9));
  }
#line 148
  if (-1 == tmp___7) {
#line 149
    goto fail;
  }
  {
#line 161
  tmp___9 = lockf(sp->fd, 2, (__off_t )0);
  }
#line 161
  if (-1 == tmp___9) {
    {
#line 165
    tmp___8 = __errno_location();
    }
#line 165
    if (11 != *tmp___8) {
#line 166
      p___0 = (char *)"reorder:can\'t lockf %s:%m";
    } else {
#line 168
      p___0 = (char *)"reorder:article in %s being cancelled?";
    }
    {
#line 169
    log_(p___0, sp->filename);
    }
#line 170
    goto fail;
  }
#line 173
  i = 0;
  {
#line 173
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 173
    if (! (i < 10)) {
#line 173
      goto while_break___1;
    }
    {
#line 174
    tmp___10 = checkindex___7((sp->file)->info + i);
    }
    {
#line 176
    if (tmp___10 == 0) {
#line 176
      goto case_0;
    }
#line 188
    if (tmp___10 == 1) {
#line 188
      goto case_1;
    }
#line 191
    if (tmp___10 == -1) {
#line 191
      goto case_neg_1;
    }
#line 174
    goto switch_break;
    case_0: /* CIL Label */ 
    {
#line 177
    tmp___12 = lseek(fd, (__off_t )0, 2);
#line 177
    tmp___11 = (int )tmp___12;
#line 177
    f___9.info[i].hoffset = tmp___11;
    }
#line 177
    if (tmp___11 > 0) {
      {
#line 179
      f___9.info[i].hlen = (sp->file)->info[i].hlen;
#line 180
      f___9.info[i].blen = (sp->file)->info[i].blen;
#line 181
      er = copyart___7(fd, sp->fd, (sp->file)->info[i].hoffset, f___9.info[i].hlen);
      }
#line 182
      if (0 == er) {
#line 183
        goto switch_break;
      }
    } else {
      {
#line 186
      log_((char *)"reorder:lseek(%s):%m", tmpname);
      }
    }
#line 187
    goto fail;
    case_1: /* CIL Label */ 
#line 189
    tmp___15 = -1;
#line 189
    f___9.info[i].hlen = tmp___15;
#line 189
    tmp___14 = tmp___15;
#line 189
    f___9.info[i].blen = tmp___14;
#line 189
    tmp___13 = tmp___14;
#line 189
    f___9.info[i].hoffset = tmp___13;
#line 189
    f___9.info[i].boffset = tmp___13;
#line 190
    goto switch_break;
    case_neg_1: /* CIL Label */ 
    {
#line 192
    log_((char *)"reorder:corrupt index in %s", sp->filename);
    }
#line 193
    goto fail;
    switch_break: /* CIL Label */ ;
    }
#line 173
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 195
  i = 0;
  {
#line 195
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 195
    if (! (i < 10)) {
#line 195
      goto while_break___2;
    }
#line 197
    if (-1 == f___9.info[i].boffset) {
#line 198
      goto __Cont;
    }
    {
#line 199
    tmp___17 = lseek(fd, (__off_t )0, 2);
#line 199
    tmp___16 = (int )tmp___17;
#line 199
    f___9.info[i].boffset = tmp___16;
    }
#line 199
    if (-1 == tmp___16) {
      {
#line 201
      log_((char *)"reorder:lseek(%s):%m", tmpname);
      }
#line 202
      goto fail;
    }
    {
#line 204
    er = copyart___7(fd, sp->fd, (sp->file)->info[i].boffset, f___9.info[i].blen);
    }
#line 205
    if (-1 == er) {
#line 206
      goto fail;
    }
    __Cont: /* CIL Label */ 
#line 195
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 209
  tmp___18 = lseek(fd, (__off_t )0, 0);
  }
#line 209
  if (-1L == tmp___18) {
    {
#line 211
    log_((char *)"reorder:lseek:%m");
    }
#line 212
    goto fail;
  }
  {
#line 214
  tmp___19 = nosigio___7((ssize_t (*)())(& write), fd, (char *)(& f___9), (int )sizeof(f___9));
  }
#line 214
  if (-1 == tmp___19) {
#line 215
    goto fail;
  }
  {
#line 216
  tmp___20 = rename((char const   *)(tmpname), (char const   *)sp->filename);
  }
#line 216
  if (-1 == tmp___20) {
    {
#line 218
    log_((char *)"reorder:rename:%m");
    }
#line 219
    goto fail;
  }
  {
#line 221
  close(fd);
  }
#line 222
  return;
  fail: 
  {
#line 225
  log_((char *)"reorder:write failed for %s:%m", sp->filename);
#line 226
  tmp___21 = unlink((char const   *)(tmpname));
  }
#line 226
  if (-1 == tmp___21) {
    {
#line 227
    log_((char *)"reorder:unlink(%s):%m", tmpname);
    }
  }
  {
#line 228
  close(fd);
  }
#line 229
  return;
}
}
#line 231 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/store.c"
static void sto_free___7(void *p ) 
{ 
  struct storeobj *sp ;
  int tmp ;

  {
  {
#line 233
  sp = (struct storeobj *)p;
#line 235
  close(sp->fd);
#line 236
  tmp = munmap((void *)((caddr_t )sp->file), sizeof(struct file ));
  }
#line 236
  if (-1 == tmp) {
    {
#line 237
    log_((char *)"sto_free:munmap:%m");
    }
  }
  {
#line 238
  free((void *)sp);
  }
#line 239
  return;
}
}
#line 241 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/store.c"
static int desc___29  ;
#line 304
static int tryopen___7(char *fn ) ;
#line 304 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/store.c"
static struct file f___7  =    {1027296, {{0, 0, 0, 0}}};
#line 270 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/store.c"
static int tryopen___7(char *fn ) 
{ 
  char fn2[287] ;
  int fd ;
  int i ;
  char *p ;
  char *q ;
  struct timeval tv ;
  char *tmp ;
  char tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  ssize_t tmp___7 ;

  {
  {
#line 278
  fd = open((char const   *)fn, 2);
  }
#line 278
  if (fd > -1) {
    {
#line 280
    lockf(fd, 1, (__off_t )0);
    }
#line 281
    return (fd);
  }
#line 283
  p = fn2;
#line 283
  q = fn;
  {
#line 283
  while (1) {
    while_continue: /* CIL Label */ ;
#line 283
    tmp = p;
#line 283
    p ++;
#line 283
    tmp___1 = q;
#line 283
    q ++;
#line 283
    tmp___0 = *tmp___1;
#line 283
    *tmp = tmp___0;
#line 283
    if (! ((int )tmp___0 != 47)) {
#line 283
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 284
  tmp___2 = p;
#line 284
  p ++;
#line 284
  *tmp___2 = (char )'+';
#line 285
  tmp___3 = p;
#line 285
  p ++;
#line 285
  *tmp___3 = (char )'+';
#line 286
  gettimeofday((struct timeval */* __restrict  */)(& tv), (__timezone_ptr_t )0);
#line 296
  i = (int )(tv.tv_sec / 30L);
  }
  {
#line 297
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 298
    tmp___4 = p;
#line 298
    p ++;
#line 298
    *tmp___4 = (char )(48 + i % 10);
#line 297
    i /= 10;
#line 297
    if (! i) {
#line 297
      goto while_break___0;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 300
  tmp___5 = p;
#line 300
  p ++;
#line 300
  *tmp___5 = (char )'\000';
#line 302
  i = 0;
  {
#line 302
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 302
    if (! (i < 100)) {
#line 302
      goto while_break___1;
    }
#line 306
    if (14 == i % 15) {
      {
#line 307
      log_((char *)"tryopen:racing on %s", fn);
      }
    }
    {
#line 308
    fd = open((char const   *)(fn2), 194, 420);
    }
#line 308
    if (fd > -1) {
      {
#line 310
      lockf(fd, 1, (__off_t )0);
#line 311
      tmp___7 = write(fd, (void const   *)((char *)(& f___7)), sizeof(f___7));
      }
#line 311
      if (sizeof(f___7) == (unsigned long )tmp___7) {
        {
#line 312
        tmp___6 = link((char const   *)(fn2), (char const   *)fn);
        }
#line 312
        if (0 == tmp___6) {
          {
#line 314
          unlink((char const   *)(fn2));
          }
#line 315
          return (fd);
        }
      }
      {
#line 317
      close(fd);
#line 318
      unlink((char const   *)(fn2));
      }
    }
    {
#line 321
    fd = open((char const   *)fn, 2);
    }
#line 321
    if (fd > -1) {
      {
#line 323
      lockf(fd, 1, (__off_t )0);
      }
#line 324
      return (fd);
    }
    {
#line 302
    nap(0, 300 + i);
#line 302
    i ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 327
  log_((char *)"tryopen:timed out opening %s:%m", fn);
  }
#line 328
  return (-1);
}
}
#line 337 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/store.c"
static struct storeobj *getstore___7(char *filename ) 
{ 
  struct storeobj *sp ;
  struct storeobj s ;
  int fd ;
  struct file *fp ;
  char buf___28[287] ;
  int c ;
  void *tmp ;
  void *tmp___0 ;
  char *p ;
  char *q ;
  char *tmp___1 ;
  char tmp___2 ;
  char *tmp___3 ;
  char *end ;
  unsigned long tmp___4 ;
  ssize_t tmp___5 ;
  size_t tmp___6 ;
  void *tmp___7 ;

  {
  {
#line 349
  s.filename = filename;
#line 350
  tmp = cache_find(desc___29, (void *)(& s));
#line 350
  sp = (struct storeobj *)tmp;
  }
#line 350
  if (sp) {
    {
#line 352
    lockf(sp->fd, 1, (__off_t )0);
    }
#line 353
    return (sp);
  }
  {
#line 356
  fd = tryopen___7(filename);
  }
#line 356
  if (-1 == fd) {
#line 357
    return ((struct storeobj *)0);
  }
  {
#line 361
  tmp___0 = mmap((void *)0, sizeof(*fp), 3, 1, fd, (__off_t )0);
#line 361
  fp = (struct file *)tmp___0;
  }
#line 362
  if (! fp) {
    {
#line 363
    log_((char *)"getstore:mmap(%s):%m", filename);
    }
  } else
#line 362
  if ((unsigned long )fp == (unsigned long )((void *)-1)) {
    {
#line 363
    log_((char *)"getstore:mmap(%s):%m", filename);
    }
  } else {
    {
#line 364
    tmp___6 = strlen((char const   *)filename);
#line 364
    tmp___7 = malloc((sizeof(*sp) + tmp___6) + 1UL);
#line 364
    sp = (struct storeobj *)tmp___7;
    }
#line 364
    if (sp) {
      {
#line 371
      sp->fd = fd;
#line 372
      sp->file = fp;
#line 373
      sp->filename = (char *)sp + sizeof(*sp);
#line 374
      strcpy((char */* __restrict  */)sp->filename, (char const   */* __restrict  */)filename);
#line 380
      p = buf___28;
#line 380
      q = filename;
      }
      {
#line 380
      while (1) {
        while_continue: /* CIL Label */ ;
#line 380
        tmp___1 = p;
#line 380
        p ++;
#line 380
        tmp___3 = q;
#line 380
        q ++;
#line 380
        tmp___2 = *tmp___3;
#line 380
        *tmp___1 = tmp___2;
#line 380
        if (! ((int )tmp___2 != 47)) {
#line 380
          goto while_break;
        }
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 381
      strcpy((char */* __restrict  */)p, (char const   */* __restrict  */)".compress");
#line 383
      fd = open((char const   *)(buf___28), 0);
      }
#line 383
      if (fd > -1) {
        {
#line 385
        sp->compressok = 1024;
#line 386
        tmp___5 = read(fd, (void *)(buf___28), sizeof(buf___28) - 1UL);
#line 386
        c = (int )tmp___5;
        }
#line 386
        if (c > 0) {
          {
#line 390
          buf___28[c] = (char )'\000';
#line 391
          tmp___4 = strtoul((char const   */* __restrict  */)(buf___28), (char **/* __restrict  */)(& end),
                            10);
#line 391
          c = (int )tmp___4;
          }
#line 392
          if (c > 1024) {
#line 392
            if (10 == (int )*end) {
#line 393
              sp->compressok = c;
            }
          }
        }
        {
#line 395
        close(fd);
        }
      } else {
#line 399
        sp->compressok = 0;
      }
      {
#line 400
      cache_insert(desc___29, (void *)sp);
      }
#line 401
      return (sp);
    } else {
      {
#line 366
      log_((char *)"getstore:no memory");
#line 367
      munmap((void *)fp, sizeof(*fp));
      }
    }
  }
  {
#line 403
  close(fd);
  }
#line 404
  return ((struct storeobj *)0);
}
}
#line 37 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/group.c"
static int desc___30  =    -1;
#line 59 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/group.c"
static int cmpgroup___10(void *a , void *b___13 ) 
{ 
  struct groupobj *x ;
  struct groupobj *y ;
  int tmp ;

  {
  {
#line 61
  x = (struct groupobj *)a;
#line 62
  y = (struct groupobj *)b___13;
#line 64
  tmp = strcmp((char const   *)x->groupname, (char const   *)y->groupname);
  }
#line 64
  return (tmp);
}
}
#line 67 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/group.c"
static void freegroup___10(void *p ) 
{ 
  struct groupobj *gop ;

  {
#line 69
  gop = (struct groupobj *)p;
#line 71
  if (gop->groupname) {
    {
#line 72
    free((void *)gop->groupname);
    }
  }
#line 73
  if (gop->dir.dir) {
    {
#line 74
    closedir(gop->dir.dir);
    }
  }
#line 75
  if (gop->lastf.f) {
    {
#line 76
    munmap((void *)((caddr_t )gop->lastf.f), sizeof(struct file ));
    }
  }
  {
#line 77
  free(p);
  }
#line 78
  return;
}
}
#line 94 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/group.c"
static int refresh___10(struct groupobj *gop , char *groupname ) 
{ 
  struct stat st ;
  struct dir *d ;
  struct lastf *lp ;
  bool needreread ;
  bool needrefile ;
  bool needreslot ;
  bool isemptygroup ;
  int tmp ;
  int tmp___0 ;
  struct dirent *dp ;
  int i ;
  int first ;
  int last___1 ;
  char *end ;
  int tmp___1 ;
  unsigned short const   **tmp___2 ;
  unsigned long tmp___3 ;
  int fd ;
  void *tmp___4 ;
  struct info *ip ;
  int slot ;

  {
#line 99
  needreread = (bool )0;
#line 100
  needrefile = (bool )0;
#line 101
  needreslot = (bool )0;
#line 102
  isemptygroup = (bool )0;
#line 104
  d = & gop->dir;
#line 105
  lp = & gop->lastf;
#line 107
  if (groupname) {
    {
#line 109
    memset((void *)gop, 0, sizeof(struct groupobj ));
#line 110
    gop->groupname = strdup((char const   *)groupname);
    }
#line 111
    if ((unsigned long )((void *)0) == (unsigned long )gop->groupname) {
      {
#line 113
      log_((char *)"refresh:strdup:%m");
      }
#line 114
      return (-1);
    }
    {
#line 116
    gop->dir.first = -1;
#line 117
    d->dir = opendir((char const   *)groupname);
    }
#line 118
    if ((unsigned long )((void *)0) == (unsigned long )d->dir) {
      {
#line 120
      log_((char *)"refresh:opendir:%m");
      }
#line 121
      return (-1);
    }
#line 123
    lp->name = -1;
#line 125
    needreslot = (bool )1;
#line 125
    needreread = needreslot;
#line 125
    needrefile = needreread;
  } else {
#line 131
    if (-1 == d->first) {
#line 132
      needreread = (bool )1;
    } else
#line 131
    if (0 == d->last) {
#line 132
      needreread = (bool )1;
    } else
#line 131
    if (! d->read) {
#line 132
      needreread = (bool )1;
    } else {
      {
#line 133
      tmp = dirfd(d->dir);
#line 133
      tmp___0 = fstat(tmp, & st);
      }
#line 133
      if (-1 == tmp___0) {
        {
#line 135
        log_((char *)"refresh:fstat:%m");
        }
#line 136
        return (-1);
      } else
#line 138
      if (d->read < st.st_mtim.tv_sec) {
#line 139
        needreread = (bool )1;
      }
    }
#line 140
    if (! lp->f) {
#line 141
      needreslot = (bool )1;
#line 141
      needrefile = needreslot;
    }
#line 142
    if (! needrefile) {
#line 143
      if (! lp->f) {
#line 144
        needrefile = (bool )1;
      }
    }
#line 145
    if (! needrefile) {
#line 146
      if (-1 == lp->name) {
#line 147
        needrefile = (bool )1;
      }
    }
  }
#line 150
  if (needreread) {
#line 150
    goto _L;
  } else
#line 150
  if (needreslot) {
    _L: /* CIL Label */ 
    {
#line 156
    first = -1;
#line 157
    last___1 = 0;
#line 158
    rewinddir(d->dir);
#line 159
    dp = readdir(d->dir);
    }
#line 160
    if ((unsigned long )((void *)0) == (unsigned long )dp) {
      {
#line 162
      log_((char *)"refresh:readdir:%m");
      }
#line 163
      return (-1);
    }
#line 165
    gop->nopost = (bool )0;
    {
#line 166
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 168
      tmp___2 = __ctype_b_loc();
      }
#line 168
      if (! ((int const   )*(*tmp___2 + (int )dp->d_name[0]) & 2048)) {
#line 170
        if (! gop->nopost) {
#line 170
          if (46 == (int )dp->d_name[0]) {
            {
#line 171
            tmp___1 = strcmp((char const   *)(dp->d_name), ".nopost");
            }
#line 171
            if (0 == tmp___1) {
#line 172
              gop->nopost = (bool )1;
            }
          }
        }
#line 173
        goto __Cont;
      }
      {
#line 175
      tmp___3 = strtoul((char const   */* __restrict  */)(dp->d_name), (char **/* __restrict  */)(& end),
                        10);
#line 175
      i = (int )tmp___3;
      }
#line 175
      if (i <= 0) {
#line 176
        goto __Cont;
      } else
#line 175
      if (*end) {
#line 176
        goto __Cont;
      }
#line 177
      if (first > i) {
#line 178
        first = i;
      } else
#line 177
      if (-1 == first) {
#line 178
        first = i;
      }
#line 179
      if (last___1 < i) {
#line 180
        last___1 = i;
      }
      __Cont: /* CIL Label */ 
      {
#line 166
      dp = readdir(d->dir);
      }
#line 166
      if (! dp) {
#line 166
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 183
    d->first = first;
#line 184
    d->last = last___1;
#line 185
    if (-1 == first) {
#line 185
      if (0 == last___1) {
#line 186
        isemptygroup = (bool )1;
      }
    }
#line 187
    if (last___1 != lp->name) {
#line 188
      needrefile = (bool )1;
    } else {
#line 190
      lp->name = last___1;
    }
    {
#line 191
    time(& d->read);
    }
  }
#line 194
  if (needrefile) {
#line 194
    goto _L___0;
  } else
#line 194
  if (needreslot) {
    _L___0: /* CIL Label */ 
#line 198
    if (lp->f) {
      {
#line 200
      munmap((void *)((caddr_t )lp->f), sizeof(struct file ));
#line 201
      lp->f = (struct file *)((void *)0);
      }
    }
#line 203
    if (isemptygroup) {
#line 204
      return (0);
    }
    {
#line 205
    fd = openf(0, 0, (char *)"%s/%d", gop->groupname, d->last);
    }
#line 206
    if (-1 == fd) {
      {
#line 208
      log_((char *)"refresh:open:%m");
      }
#line 209
      return (-1);
    }
    {
#line 211
    tmp___4 = mmap((void *)0, sizeof(struct file ), 1, 1, fd, (__off_t )0);
#line 211
    lp->f = (struct file *)tmp___4;
#line 212
    close(fd);
    }
#line 213
    if ((unsigned long )lp->f == (unsigned long )((void *)-1)) {
      {
#line 215
      log_((char *)"refresh:mmap:%m");
      }
#line 216
      return (-1);
    }
#line 218
    lp->slotsfilled = 0;
#line 219
    needreslot = (bool )1;
  }
#line 222
  if (needreslot) {
#line 224
    ip = (lp->f)->info;
#line 227
    slot = 9;
    {
#line 227
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 227
      if (! (slot > -1)) {
#line 227
        goto while_break___0;
      }
#line 228
      if ((ip + slot)->hoffset) {
#line 229
        goto while_break___0;
      }
#line 227
      slot --;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 230
    lp->slotsfilled = slot + 1;
  }
#line 233
  return (0);
}
}
#line 33 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/art.c"
static size_t pagesize___32  =    (size_t )0;
#line 80 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/art.c"
static void file_unmap___10(void *p ) 
{ 
  struct fileobj *fp ;

  {
  {
#line 82
  fp = (struct fileobj *)p;
#line 84
  munmap((void *)fp->map, (size_t )fp->size);
#line 85
  free((void *)fp);
  }
#line 86
  return;
}
}
#line 88 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/art.c"
static int file_cmp___10(void *a , void *b___13 ) 
{ 
  struct fileobj *x ;
  struct fileobj *y ;
  int tmp ;

  {
  {
#line 90
  x = (struct fileobj *)a;
#line 91
  y = (struct fileobj *)b___13;
#line 93
  tmp = strcmp((char const   *)x->path, (char const   *)y->path);
  }
#line 93
  return (tmp);
}
}
#line 96 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/art.c"
static int desc___31  =    -1;
#line 98 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/art.c"
static int file_init___10(void) 
{ 


  {
  {
#line 100
  desc___31 = cache_init(8, & file_cmp___10, & file_unmap___10, (int (*)(void * ))((void *)0));
  }
#line 101
  if (-1 == desc___31) {
    {
#line 103
    log_((char *)"file_init:%m");
    }
#line 104
    return (-1);
  }
#line 106
  return (0);
}
}
#line 109 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/art.c"
static struct file *file_gimme___10(char *name , int *size___1 ) 
{ 
  struct fileobj f___9 ;
  struct fileobj *fp ;
  void *tmp ;

  {
  {
#line 111
  f___9.path = (char *)0;
#line 111
  f___9.map = (char *)0;
#line 111
  f___9.size = 0;
#line 114
  f___9.path = name;
#line 116
  tmp = cache_find(desc___31, (void *)(& f___9));
#line 116
  fp = (struct fileobj *)tmp;
  }
#line 116
  if ((unsigned long )((void *)0) == (unsigned long )fp) {
    {
#line 118
    fp = file_map(name);
    }
#line 118
    if ((unsigned long )((void *)0) == (unsigned long )fp) {
#line 119
      return ((struct file *)((void *)0));
    } else {
      {
#line 121
      cache_insert(desc___31, (void *)fp);
      }
    }
  }
#line 124
  if (size___1) {
#line 125
    *size___1 = fp->size;
  }
#line 126
  return ((struct file *)fp->map);
}
}
#line 137 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/art.c"
static bool file_initialized___10  =    (bool )0;
#line 248 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/art.c"
static char ngroup___10[287]  ;
#line 297 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/art.c"
static int getfield___10(char *buf___28 , struct field *f___9 ) 
{ 
  register char *cp ;
  size_t tmp ;
  size_t tmp___0 ;

  {
  {
#line 299
  cp = buf___28;
#line 301
  tmp = strspn((char const   *)cp, " \t\f");
#line 301
  cp += tmp;
  }
#line 302
  if (! *cp) {
#line 304
    f___9->pointer = (char *)((void *)0);
#line 305
    return (0);
  }
  {
#line 307
  tmp___0 = strcspn((char const   *)cp, "\r\n");
#line 307
  f___9->len = (int )tmp___0;
  }
#line 308
  if (! f___9->len) {
#line 309
    return (0);
  }
#line 310
  f___9->pointer = cp;
#line 311
  return ((int )((cp + f___9->len) - buf___28));
}
}
#line 383 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/art.c"
static struct b b___11  =    {(char *)0, 0, 0};
#line 105 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/dh_find.c"
static int initfile___21(void) 
{ 
  int fd ;
  int integer ;
  int i ;
  char foo[3] ;
  unsigned int tmp ;
  int *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  ssize_t tmp___3 ;
  ssize_t tmp___4 ;

  {
#line 108
  integer = 218885376;
#line 110
  foo[0] = (char )'\000';
#line 110
  tmp = 1U;
  {
#line 110
  while (1) {
    while_continue: /* CIL Label */ ;
#line 110
    if (tmp >= 3U) {
#line 110
      goto while_break;
    }
#line 110
    foo[tmp] = (char)0;
#line 110
    tmp ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 112
  fd = open((char const   *)(dh_tablefile), 194, 420);
  }
#line 113
  if (fd == -1) {
#line 114
    return (-1);
  }
  {
#line 115
  tmp___2 = lockf(fd, 2, (__off_t )0);
  }
#line 115
  if (tmp___2 == -1) {
    {
#line 117
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 119
      tmp___0 = __errno_location();
      }
#line 119
      if (*tmp___0 == 11) {
        {
#line 120
        nap(0, 200);
        }
      } else {
#line 122
        goto fail;
      }
      {
#line 117
      tmp___1 = lockf(fd, 2, (__off_t )0);
      }
#line 117
      if (! (tmp___1 == -1)) {
#line 117
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 125
    lockf(fd, 0, (__off_t )0);
    }
#line 126
    return (fd);
  }
  {
#line 128
  tmp___3 = write(fd, (void const   *)(& integer), sizeof(int ));
  }
#line 128
  if ((unsigned long )tmp___3 != sizeof(int )) {
#line 129
    goto fail;
  }
#line 130
  i = 0;
  {
#line 130
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 130
    if (! (i < 10240)) {
#line 130
      goto while_break___1;
    }
    {
#line 131
    tmp___4 = write(fd, (void const   *)(foo), sizeof(foo));
    }
#line 131
    if ((unsigned long )tmp___4 != sizeof(foo)) {
#line 132
      goto fail;
    }
#line 130
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 133
  lseek(fd, (__off_t )0, 0);
#line 134
  lockf(fd, 0, (__off_t )0);
  }
#line 135
  return (fd);
  fail: 
#line 138
  if (fd > -1) {
    {
#line 139
    close(fd);
    }
  }
#line 140
  return (-1);
}
}
#line 78 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/allocate.c"
static struct table___1 table___11  =    {(char *)0, (char *)0, 0, 0, 0, 0};
#line 80
static int remapfile___10(void) ;
#line 106 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/allocate.c"
static int initfile___22(char *filename ) 
{ 
  struct chainfile cf ;
  int fd ;
  int i ;
  int ret ;
  ssize_t tmp ;
  int pad ;
  ssize_t tmp___0 ;

  {
  {
#line 108
  cf.chain_magic = 0;
#line 108
  cf.next[0] = 0;
#line 108
  cf.next[1] = 0;
#line 108
  cf.next[2] = 0;
#line 108
  cf.next[3] = 0;
#line 108
  cf.next[4] = 0;
#line 108
  cf.next[5] = 0;
#line 108
  cf.next[6] = 0;
#line 108
  cf.next[7] = 0;
#line 108
  cf.next[8] = 0;
#line 108
  cf.next[9] = 0;
#line 108
  cf.next[10] = 0;
#line 108
  cf.next[11] = 0;
#line 108
  cf.next[12] = 0;
#line 108
  cf.next[13] = 0;
#line 108
  cf.next[14] = 0;
#line 108
  cf.next[15] = 0;
#line 108
  cf.next[16] = 0;
#line 108
  cf.next[17] = 0;
#line 108
  cf.next[18] = 0;
#line 108
  cf.next[19] = 0;
#line 108
  cf.next[20] = 0;
#line 108
  cf.next[21] = 0;
#line 108
  cf.next[22] = 0;
#line 108
  cf.next[23] = 0;
#line 108
  cf.next[24] = 0;
#line 108
  cf.next[25] = 0;
#line 108
  cf.next[26] = 0;
#line 108
  cf.next[27] = 0;
#line 108
  cf.next[28] = 0;
#line 108
  cf.next[29] = 0;
#line 108
  cf.next[30] = 0;
#line 108
  cf.next[31] = 0;
#line 108
  cf.next[32] = 0;
#line 108
  cf.next[33] = 0;
#line 108
  cf.next[34] = 0;
#line 108
  cf.next[35] = 0;
#line 108
  cf.next[36] = 0;
#line 108
  cf.next[37] = 0;
#line 108
  cf.next[38] = 0;
#line 108
  cf.next[39] = 0;
#line 108
  cf.next[40] = 0;
#line 108
  cf.next[41] = 0;
#line 108
  cf.next[42] = 0;
#line 108
  cf.next[43] = 0;
#line 108
  cf.next[44] = 0;
#line 108
  cf.next[45] = 0;
#line 108
  cf.next[46] = 0;
#line 108
  cf.next[47] = 0;
#line 108
  cf.next[48] = 0;
#line 108
  cf.next[49] = 0;
#line 108
  cf.next[50] = 0;
#line 108
  cf.next[51] = 0;
#line 108
  cf.next[52] = 0;
#line 108
  cf.next[53] = 0;
#line 108
  cf.next[54] = 0;
#line 108
  cf.next[55] = 0;
#line 108
  cf.next[56] = 0;
#line 108
  cf.next[57] = 0;
#line 108
  cf.next[58] = 0;
#line 108
  cf.next[59] = 0;
#line 108
  cf.next[60] = 0;
#line 108
  cf.next[61] = 0;
#line 108
  cf.next[62] = 0;
#line 111
  ret = 0;
#line 113
  fd = open((char const   *)filename, 578, 420);
  }
#line 114
  if (-1 == fd) {
#line 115
    return (-1);
  }
#line 116
  cf.chain_magic = 13680336;
#line 117
  i = 0;
  {
#line 117
  while (1) {
    while_continue: /* CIL Label */ ;
#line 117
    if (! (i < 63)) {
#line 117
      goto while_break;
    }
#line 118
    cf.next[i] = (int volatile   )0;
#line 117
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 119
  tmp = write(fd, (void const   *)(& cf), sizeof(cf));
#line 119
  i = (int )tmp;
  }
#line 120
  if ((unsigned long )i == sizeof(cf)) {
#line 124
    pad = (int )(sizeof(cf) % 4UL);
#line 125
    if (pad > 0) {
#line 126
      i = 0;
      {
#line 126
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 126
        if (i < pad) {
#line 126
          if (! (0 == ret)) {
#line 126
            goto while_break___0;
          }
        } else {
#line 126
          goto while_break___0;
        }
        {
#line 127
        tmp___0 = write(fd, (void const   *)"", (size_t )1);
        }
#line 127
        if (1L != tmp___0) {
#line 128
          ret = -1;
        }
#line 126
        i ++;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
  } else {
#line 131
    ret = -1;
  }
  {
#line 132
  close(fd);
  }
#line 133
  return (ret);
}
}
#line 136 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/allocate.c"
static void unmapfile___10(void) 
{ 


  {
#line 138
  if (table___11.fd >= 0) {
    {
#line 140
    close(table___11.fd);
#line 141
    table___11.fd = -1;
    }
  }
#line 143
  if (table___11.map) {
    {
#line 145
    munmap((void *)table___11.map, (size_t )table___11.size);
#line 146
    table___11.map = (char *)((void *)0);
#line 147
    table___11.size = 0;
    }
  }
#line 149
  return;
}
}
#line 153
static size_t rounduptopagesize___10(size_t size___1 ) ;
#line 153 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/allocate.c"
static size_t pagesize___33  =    (size_t )0;
#line 151 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/allocate.c"
static size_t rounduptopagesize___10(size_t size___1 ) 
{ 
  int pages ;
  int tmp ;

  {
#line 156
  if (0UL == pagesize___33) {
    {
#line 157
    tmp = getpagesize();
#line 157
    pagesize___33 = (size_t )tmp;
    }
  }
#line 158
  pages = (int )(size___1 / pagesize___33 + 1UL);
#line 159
  return ((size_t )pages * pagesize___33);
}
}
#line 162 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/allocate.c"
static int mapfile___10(void) 
{ 
  struct stat st ;
  int tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;

  {
#line 166
  if (-1 == table___11.fd) {
    {
#line 167
    table___11.fd = open((char const   *)table___11.filename, table___11.oflag, 420);
    }
  }
#line 168
  if (-1 == table___11.fd) {
#line 169
    goto fail;
  }
  {
#line 171
  tmp = fstat(table___11.fd, & st);
  }
#line 171
  if (-1 == tmp) {
#line 172
    goto fail;
  }
  {
#line 173
  tmp___0 = rounduptopagesize___10((size_t )st.st_size);
#line 173
  table___11.size = (int )tmp___0;
#line 174
  tmp___1 = mmap((void *)0, (size_t )table___11.size, table___11.mprot, 1, table___11.fd,
                 (__off_t )0);
#line 174
  table___11.map = (char *)tmp___1;
  }
#line 175
  if (! table___11.map) {
#line 176
    goto fail;
  } else
#line 175
  if ((unsigned long )table___11.map == (unsigned long )((void *)-1)) {
#line 176
    goto fail;
  }
#line 178
  return (0);
  fail: 
  {
#line 181
  unmapfile___10();
  }
#line 182
  return (-1);
}
}
#line 189 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/allocate.c"
static int remapfile___10(void) 
{ 
  struct stat st ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 193
  tmp = fstat(table___11.fd, & st);
  }
#line 193
  if (-1 == tmp) {
#line 194
    return (-1);
  }
#line 196
  if (st.st_size <= (__off_t )table___11.size) {
#line 197
    return (0);
  }
  {
#line 199
  munmap((void *)table___11.map, (size_t )table___11.size);
#line 200
  tmp___0 = mapfile___10();
  }
#line 200
  return (tmp___0);
}
}
#line 209 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/allocate.c"
static int lock___10(void) 
{ 
  int *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 211
  tmp___2 = lockf(table___11.fd, 2, (__off_t )0);
  }
#line 211
  if (-1 == tmp___2) {
    {
#line 213
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 215
      tmp = __errno_location();
      }
#line 215
      if (11 != *tmp) {
#line 216
        return (-1);
      } else {
        {
#line 218
        nap(0, 200);
        }
      }
      {
#line 213
      tmp___0 = lockf(table___11.fd, 2, (__off_t )0);
      }
#line 213
      if (! (-1 == tmp___0)) {
#line 213
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 221
    tmp___1 = remapfile___10();
    }
#line 221
    if (-1 == tmp___1) {
#line 222
      return (-1);
    }
  }
#line 224
  return (0);
}
}
#line 227 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/allocate.c"
static void unlock___10(void) 
{ 


  {
  {
#line 229
  lseek(table___11.fd, (__off_t )0, 0);
#line 230
  lockf(table___11.fd, 0, (__off_t )0);
  }
#line 231
  return;
}
}
#line 233 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/allocate.c"
static int checkvalidfile___10(void) 
{ 


  {
#line 235
  if (table___11.size > 0) {
#line 237
    if ((unsigned long )table___11.size < sizeof(struct chainfile )) {
#line 238
      return (-1);
    }
#line 239
    if (((struct chainfile *)table___11.map)->chain_magic != 13680336) {
#line 240
      return (-1);
    }
  }
#line 242
  return (0);
}
}
#line 281 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/allocate.c"
static int rounduptoalignment___10(int size___1 ) 
{ 


  {
#line 283
  if (size___1 <= 0) {
#line 284
    return (4);
  }
#line 285
  return (((size___1 - 1) / 4 + 1) * 4);
}
}
#line 296 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/allocate.c"
static char tmpchunk___10[272]  = {      (char )'\000'};
#line 56 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/dhash.c"
static unsigned char buf___24[2]  ;
#line 54 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/dhash.c"
static char *inttochar2___10(int integer ) 
{ 


  {
#line 58
  buf___24[0] = (unsigned char )((integer & 65535) >> 8);
#line 59
  buf___24[1] = (unsigned char )(integer & 255);
#line 60
  return ((char *)(buf___24));
}
}
#line 65 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/dhash.c"
static unsigned char buf___25[3]  ;
#line 63 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/dhash.c"
static char *inttochar3___10(unsigned int integer ) 
{ 


  {
#line 67
  integer >>= 2;
#line 68
  buf___25[0] = (unsigned char )((integer & 16777215U) >> 16);
#line 69
  buf___25[1] = (unsigned char )((integer & 65535U) >> 8);
#line 70
  buf___25[2] = (unsigned char )(integer & 255U);
#line 71
  return ((char *)(buf___25));
}
}
#line 35 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/newsgroup.c"
static struct ng *bygroup___10[128]  ;
#line 36 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/newsgroup.c"
static struct ng *byident___10[128]  ;
#line 37 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/newsgroup.c"
static int highest___10  =    0;
#line 39 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/newsgroup.c"
static unsigned int hash___21(char *buf___28 , int len ) 
{ 
  unsigned int h ;
  char *tmp ;

  {
#line 43
  h = 5381U;
  {
#line 44
  while (1) {
    while_continue: /* CIL Label */ ;
#line 44
    if (! len) {
#line 44
      goto while_break;
    }
#line 46
    len --;
#line 47
    h += h << 5;
#line 48
    tmp = buf___28;
#line 48
    buf___28 ++;
#line 48
    h ^= (unsigned int )*tmp;
  }
  while_break: /* CIL Label */ ;
  }
#line 50
  return (h);
}
}
#line 53 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/newsgroup.c"
static struct chunk *chunks___10  ;
#line 58 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/newsgroup.c"
static int avail___21  =    0;
#line 59 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/newsgroup.c"
static int nr___11  =    0;
#line 64 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/newsgroup.c"
static int add___11(int ident , char *group , int len ) 
{ 
  struct ng *np ;
  struct ng *p ;
  int want ;
  unsigned int h ;
  struct chunk *tmp ;
  int size___1 ;
  void *tmp___0 ;
  unsigned int tmp___1 ;
  int tmp___2 ;

  {
#line 71
  len ++;
#line 72
  want = (int )(((unsigned long )len + sizeof(struct ng )) + sizeof(char *));
#line 73
  want = (int )((unsigned long )want - (unsigned long )len % sizeof(char *));
#line 74
  len --;
#line 76
  if (avail___21 < want) {
#line 81
    if (want > 240) {
#line 81
      size___1 = want + 240;
    } else {
#line 81
      size___1 = 240;
    }
    {
#line 82
    tmp___0 = malloc((size_t )size___1);
#line 82
    tmp = (struct chunk *)tmp___0;
    }
#line 82
    if (! tmp) {
#line 83
      return (-1);
    }
#line 84
    tmp->next = chunks___10;
#line 85
    chunks___10 = tmp;
#line 86
    chunks___10->buf = (char *)chunks___10 + sizeof(struct chunk );
#line 87
    avail___21 = (int )((unsigned long )size___1 - sizeof(struct chunk ));
  }
  {
#line 89
  np = (struct ng *)chunks___10->buf;
#line 90
  chunks___10->buf += want;
#line 91
  avail___21 -= want;
#line 92
  strncpy((char */* __restrict  */)(np->group), (char const   */* __restrict  */)group,
          (size_t )len);
#line 93
  np->group[len] = (char )'\000';
#line 94
  np->ident = ident;
#line 96
  tmp___1 = hash___21(group, len);
#line 96
  h = tmp___1 % 128U;
#line 97
  np->gnext = bygroup___10[h];
#line 98
  bygroup___10[h] = np;
#line 99
  p = np->gnext;
  }
  {
#line 99
  while (1) {
    while_continue: /* CIL Label */ ;
#line 99
    if (! p) {
#line 99
      goto while_break;
    }
    {
#line 100
    tmp___2 = strcmp((char const   *)(p->group), (char const   *)group);
    }
#line 100
    if (0 == tmp___2) {
#line 101
      return (1);
    }
#line 99
    p = p->gnext;
  }
  while_break: /* CIL Label */ ;
  }
#line 102
  h = (unsigned int )(ident % 128);
#line 103
  np->inext = byident___10[h];
#line 104
  byident___10[h] = np;
#line 105
  p = np->inext;
  {
#line 105
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 105
    if (! p) {
#line 105
      goto while_break___0;
    }
#line 106
    if (p->ident == ident) {
#line 107
      return (1);
    }
#line 105
    p = p->inext;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 109
  if (ident > highest___10) {
#line 110
    highest___10 = ident;
  }
#line 111
  nr___11 ++;
#line 112
  return (0);
}
}
#line 116 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/newsgroup.c"
static int groupfd___10  =    -1;
#line 117 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/newsgroup.c"
static int oldsize___10  =    0;
#line 118 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/newsgroup.c"
static int mapsize___10  =    0;
#line 119 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/newsgroup.c"
static char *mapbuf___10  =    (char *)((void *)0);
#line 148
static int reload___10(void) ;
#line 148 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/newsgroup.c"
static int pagesize___34  =    0;
#line 145 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/newsgroup.c"
static int reload___10(void) 
{ 
  struct stat st ;
  int newsize ;
  int tmp ;
  void *tmp___0 ;
  char *p ;
  char *lim ;
  char *ip ;
  char *gr ;
  int ident ;
  int state ;
  int tmp___1 ;

  {
  {
#line 156
  tmp = fstat(groupfd___10, & st);
  }
#line 156
  if (-1 == tmp) {
    {
#line 158
    log_((char *)"reload:fstat:%m");
    }
#line 159
    return (-1);
  }
#line 161
  newsize = (int )st.st_size;
#line 162
  if (! pagesize___34) {
    {
#line 163
    pagesize___34 = getpagesize();
    }
  }
#line 164
  if (newsize <= oldsize___10) {
#line 165
    return (0);
  }
#line 166
  if (newsize > mapsize___10) {
#line 166
    goto _L;
  } else
#line 166
  if (! mapsize___10) {
    _L: /* CIL Label */ 
#line 168
    if (mapbuf___10) {
      {
#line 169
      munmap((void *)mapbuf___10, (size_t )mapsize___10);
      }
    }
    {
#line 170
    mapsize___10 = (int )((st.st_size + (__off_t )pagesize___34) - st.st_size % (long )pagesize___34);
#line 171
    tmp___0 = mmap((void *)0, (size_t )mapsize___10, 1, 1, groupfd___10, (__off_t )0);
#line 171
    mapbuf___10 = (char *)tmp___0;
    }
#line 172
    if (! mapbuf___10) {
      {
#line 174
      log_((char *)"reload:mmap:%m");
      }
#line 175
      return (-1);
    } else
#line 172
    if ((unsigned long )mapbuf___10 == (unsigned long )((void *)-1)) {
      {
#line 174
      log_((char *)"reload:mmap:%m");
      }
#line 175
      return (-1);
    }
  }
#line 188
  lim = mapbuf___10 + newsize;
#line 189
  state = 0;
#line 189
  ident = state;
#line 190
  gr = (char *)0;
#line 190
  ip = gr;
#line 191
  p = mapbuf___10 + oldsize___10;
  {
#line 191
  while (1) {
    while_continue: /* CIL Label */ ;
#line 191
    if (! ((unsigned long )p < (unsigned long )lim)) {
#line 191
      goto while_break;
    }
    {
#line 194
    if (state == 0) {
#line 194
      goto case_0;
    }
#line 195
    if (state == 1) {
#line 195
      goto case_1;
    }
#line 196
    if (state == 2) {
#line 196
      goto case_2;
    }
#line 197
    if (state == 3) {
#line 197
      goto case_3;
    }
#line 192
    goto switch_break;
    case_0: /* CIL Label */ 
#line 194
    if ((int )*p >= 48) {
#line 194
      if ((int )*p <= 57) {
#line 194
        ip = p;
#line 194
        state ++;
      }
    }
#line 194
    goto switch_break;
    case_1: /* CIL Label */ 
#line 195
    if (32 == (int )*p) {
      {
#line 195
      ident = atoi((char const   *)ip);
#line 195
      state ++;
      }
    }
#line 195
    goto switch_break;
    case_2: /* CIL Label */ 
#line 196
    if (32 != (int )*p) {
#line 196
      gr = p;
#line 196
      state ++;
    }
#line 196
    goto switch_break;
    case_3: /* CIL Label */ 
#line 198
    if (10 != (int )*p) {
#line 199
      goto switch_break;
    }
    {
#line 200
    tmp___1 = add___11(ident, gr, (int )(p - gr));
    }
#line 200
    if (-1 == tmp___1) {
      {
#line 202
      log_((char *)"reload:no memory");
      }
#line 203
      return (-1);
    }
#line 205
    state = 0;
    switch_break: /* CIL Label */ ;
    }
#line 191
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 208
  oldsize___10 = newsize;
#line 209
  return (0);
}
}
#line 26 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/key.c"
static struct buf *head___11  ;
#line 27 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/key.c"
static int avail___22  =    0;
#line 28 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/key.c"
static char *keybuf___10  =    (char *)((void *)0);
#line 33 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/key.c"
static unsigned int hv___10  ;
#line 35 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/key.c"
static void hash___22(char *key , int len ) 
{ 
  char *tmp ;

  {
#line 37
  hv___10 = 5381U;
  {
#line 38
  while (1) {
    while_continue: /* CIL Label */ ;
#line 38
    if (! len) {
#line 38
      goto while_break;
    }
#line 40
    len --;
#line 41
    hv___10 += hv___10 << 5;
#line 42
    tmp = key;
#line 42
    key ++;
#line 42
    hv___10 ^= (unsigned int )*tmp;
  }
  while_break: /* CIL Label */ ;
  }
#line 44
  hv___10 %= 128U;
#line 45
  return;
}
}
#line 26 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/body.c"
static char *bodbuf___10  =    (char *)((void *)0);
#line 24 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/times.h"
extern int times_append(char *group , int serial ) ;
#line 43 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/snsend.c"
static char path1___1[4097]  ;
#line 44 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/snsend.c"
static char path2___1[4097]  ;
#line 48 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/snsend.c"
static struct ng___0 *newsgroups  ;
#line 53 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/snsend.c"
static struct readln input___0  =    {0, (char *)0, {(char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                   (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                   (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                   (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                   (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                   (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                   (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                   (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                   (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                   (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                   (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                   (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                   (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                   (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                   (char)0, (char)0, (char)0, (char)0, (char)0, (char)0}, 0, 0, 0,
    0};
#line 54 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/snsend.c"
static struct article art  =    {(char *)0, 0, (char *)0, 0};
#line 56 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/snsend.c"
static void nomem___1(void) 
{ 


  {
  {
#line 56
  fail(2, (char *)"No memory");
  }
#line 56
  return;
}
}
#line 58 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/snsend.c"
static char *me___0  ;
#line 59 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/snsend.c"
static int melen  ;
#line 60 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/snsend.c"
static int nrgroups  ;
#line 61 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/snsend.c"
static char *messageid  ;
#line 62 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/snsend.c"
static bool check_exist  =    (bool )0;
#line 63 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/snsend.c"
static int pid  ;
#line 64 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/snsend.c"
static struct timeval now  ;
#line 65 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/snsend.c"
static bool canalias  =    (bool )1;
#line 66 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/snsend.c"
static bool report___0  =    (bool )0;
#line 71 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/snsend.c"
static ng_t newsgroup_type(char *group ) 
{ 
  struct stat st ;
  int tmp ;
  int *tmp___0 ;
  int tmp___1 ;

  {
  {
#line 75
  formats(path1___1, (int )(sizeof(path1___1) - 1UL), (char *)"%s/.outgoing", group);
#line 76
  tmp = stat((char const   */* __restrict  */)(path1___1), (struct stat */* __restrict  */)(& st));
  }
#line 76
  if (0 == tmp) {
#line 78
    if ((st.st_mode & 61440U) == 16384U) {
#line 79
      return ((ng_t )4);
    }
#line 80
    if ((st.st_mode & 61440U) == 32768U) {
#line 82
      if (64U & st.st_mode) {
#line 83
        return ((ng_t )3);
      } else {
#line 85
        return ((ng_t )2);
      }
    }
#line 87
    if ((st.st_mode & 61440U) == 4096U) {
#line 88
      return ((ng_t )5);
    }
#line 89
    return ((ng_t )0);
  }
  {
#line 91
  tmp___0 = __errno_location();
  }
#line 91
  if (20 == *tmp___0) {
#line 92
    return ((ng_t )0);
  }
  {
#line 93
  tmp___1 = stat((char const   */* __restrict  */)group, (struct stat */* __restrict  */)(& st));
  }
#line 93
  if (0 == tmp___1) {
#line 93
    if ((st.st_mode & 61440U) == 16384U) {
#line 94
      return ((ng_t )1);
    }
  }
#line 95
  return ((ng_t )0);
}
}
#line 102 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/snsend.c"
static int writeart(int fd ) 
{ 
  ssize_t tmp ;
  ssize_t tmp___0 ;
  ssize_t tmp___1 ;
  ssize_t tmp___2 ;

  {
  {
#line 104
  tmp___2 = write(fd, (void const   *)art.head, (size_t )art.hlen);
  }
#line 104
  if (tmp___2 > -1L) {
    {
#line 105
    tmp___1 = write(fd, (void const   *)"\r\n", (size_t )2);
    }
#line 105
    if (tmp___1 > -1L) {
#line 106
      if (art.body) {
        {
#line 106
        tmp___0 = write(fd, (void const   *)art.body, (size_t )art.blen);
        }
#line 106
        if (tmp___0 > -1L) {
          {
#line 107
          tmp = write(fd, (void const   *)".\r\n", (size_t )3);
          }
#line 107
          if (tmp > -1L) {
#line 108
            return (0);
          }
        }
      }
    }
  }
#line 109
  return (-1);
}
}
#line 112 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/snsend.c"
static int store_global(char *group ) 
{ 
  struct stat st ;
  int fd ;
  int er ;
  int tmp ;
  char *tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  int *tmp___4 ;

  {
  {
#line 117
  formats(path1___1, (int )(sizeof(path1___1) - 1UL), (char *)"%s/.outgoing/$%u.%u.%u",
          group, now.tv_sec, now.tv_usec, pid);
#line 119
  tmp = stat((char const   */* __restrict  */)(path1___1), (struct stat */* __restrict  */)(& st));
  }
#line 119
  if (0 == tmp) {
#line 120
    return (0);
  }
  {
#line 121
  tmp___0 = strrchr((char const   *)(path1___1), '$');
#line 121
  *tmp___0 = (char )'+';
#line 122
  fd = open((char const   *)(path1___1), 193, 420);
  }
#line 123
  if (-1 == fd) {
    {
#line 125
    tmp___1 = __errno_location();
    }
#line 125
    if (17 == *tmp___1) {
      {
#line 127
      log_((char *)"store_global:tmp file %s exists", path1___1);
      }
#line 128
      return (0);
    } else {
      {
#line 131
      fail(2, (char *)"store_global:open(%s):%m", path1___1);
      }
    }
  }
  {
#line 133
  er = writeart(fd);
#line 134
  close(fd);
  }
#line 135
  if (0 == er) {
    {
#line 137
    strcpy((char */* __restrict  */)(path2___1), (char const   */* __restrict  */)(path1___1));
#line 138
    tmp___2 = strrchr((char const   *)(path2___1), '+');
#line 138
    *tmp___2 = (char )'$';
#line 139
    tmp___3 = link((char const   *)(path1___1), (char const   *)(path2___1));
    }
#line 139
    if (-1 == tmp___3) {
      {
#line 139
      tmp___4 = __errno_location();
      }
#line 139
      if (17 != *tmp___4) {
        {
#line 141
        er = -1;
#line 142
        log_((char *)"store_global:link(%s,%s):%m", path1___1, path2___1);
        }
      }
    }
  } else {
    {
#line 146
    log_((char *)"store_global:write(%s):%m", path1___1);
    }
  }
  {
#line 148
  unlink((char const   *)(path1___1));
  }
#line 149
  if (er) {
    {
#line 150
    _exit(2);
    }
  }
#line 151
  return (0);
}
}
#line 154 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/snsend.c"
static int store_local(char *group ) 
{ 
  struct data d ;
  int tmp ;
  int tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  int *tmp___3 ;
  int tmp___4 ;
  char const   *tmp___5 ;
  int tmp___6 ;

  {
#line 158
  d.messageid = messageid;
#line 159
  if (group) {
#line 160
    if (check_exist) {
      {
#line 161
      tmp___0 = dh_find(& d, (bool )0);
      }
#line 161
      if (0 == tmp___0) {
        {
#line 162
        tmp = strcasecmp((char const   *)group, (char const   *)d.newsgroup);
        }
#line 162
        if (0 == tmp) {
#line 164
          if (debug >= 1) {
            {
#line 164
            log_((char *)"store_local:<%s> already exists in %s, not storing", messageid,
                 group);
            }
          }
#line 165
          return (1);
        }
      }
    }
  }
#line 167
  if (group) {
#line 167
    tmp___1 = (char const   *)group;
  } else {
#line 167
    tmp___1 = "=junk";
  }
  {
#line 167
  d.serial = sto_add((char *)tmp___1, & art);
  }
#line 168
  if (-1 == d.serial) {
#line 170
    if (group) {
      {
#line 171
      _exit(2);
      }
    } else {
#line 173
      return (-1);
    }
  }
#line 175
  if (group) {
#line 175
    tmp___2 = (char const   *)group;
  } else {
#line 175
    tmp___2 = "=junk";
  }
  {
#line 175
  times_append((char *)tmp___2, d.serial);
#line 176
  d.newsgroup = group;
  }
#line 176
  if (d.newsgroup) {
#line 178
    if (d.serial < 0) {
      {
#line 179
      _exit(2);
      }
    }
    {
#line 180
    tmp___4 = dh_insert(& d);
    }
#line 180
    if (-1 == tmp___4) {
      {
#line 182
      tmp___3 = __errno_location();
      }
#line 182
      if (17 == *tmp___3) {
#line 184
        if (debug >= 1) {
          {
#line 184
          log_((char *)"store_local:oops, stored <%s> but it already exists", messageid);
          }
        }
      } else {
        {
#line 187
        log_((char *)"store_local:can\'t insert in db for <%s> in %s:%d, %m?", messageid,
             group, d.serial);
        }
      }
    }
  }
#line 191
  if (report___0) {
#line 192
    if (group) {
#line 192
      tmp___5 = (char const   *)group;
    } else {
#line 192
      tmp___5 = "=junk";
    }
    {
#line 192
    writef(1, (char *)"%s %u <%s>\n", tmp___5, d.serial, messageid);
    }
  }
#line 193
  if (group) {
#line 193
    tmp___6 = d.serial;
  } else {
#line 193
    tmp___6 = 0;
  }
#line 193
  return (tmp___6);
}
}
#line 196 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/snsend.c"
static char *av[3]  = {      (char *)"sh",      (char *)0,      (char *)0};
#line 198 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/snsend.c"
static int special(char *group , int argv0 ) 
{ 
  int pid___0 ;
  int p[2] ;
  int er ;
  int s ;
  int tmp ;
  int tmp___0 ;
  __pid_t tmp___1 ;
  int *tmp___2 ;
  union __anonunion_50___2 __constr_expr_32 ;
  union __anonunion_51___2 __constr_expr_33 ;
  union __anonunion_52___2 __constr_expr_34 ;
  union __anonunion_53___0 __constr_expr_35 ;
  union __anonunion_54___0 __constr_expr_36 ;
  union __anonunion_55___0 __constr_expr_37 ;

  {
  {
#line 202
  formats(path1___1, (int )(sizeof(path1___1) - 1UL), (char *)"./%s/.outgoing", group);
#line 203
  av[1] = path1___1;
#line 204
  tmp = pipe((int *)(p));
  }
#line 204
  if (tmp) {
    {
#line 205
    fail(2, (char *)"special:pipe:%m");
    }
  }
  {
#line 206
  pid___0 = fork();
  }
#line 206
  if (-1 == pid___0) {
    {
#line 207
    fail(2, (char *)"special:fork:%m");
    }
  }
#line 208
  if (0 == pid___0) {
    {
#line 210
    formats(path2___1, (int )(sizeof(path2___1) - 1UL), (char *)"NEWSGROUP=%s", group);
#line 211
    tmp___0 = putenv(path2___1);
    }
#line 211
    if (tmp___0) {
      {
#line 212
      fail(2, (char *)"putenv:%m?");
      }
    }
    {
#line 213
    close(p[1]);
#line 214
    dup2(p[0], 0);
#line 215
    execvp((char const   *)av[argv0], (char * const  *)(av + argv0));
#line 216
    fail(2, (char *)"exec(%s):%m", av[argv0]);
    }
  }
  {
#line 218
  close(p[0]);
#line 219
  er = writeart(p[1]);
#line 220
  close(p[1]);
  }
  {
#line 221
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 221
    tmp___1 = waitpid(pid___0, & s, 0);
    }
#line 221
    if (-1 == tmp___1) {
      {
#line 221
      tmp___2 = __errno_location();
      }
#line 221
      if (! (4 == *tmp___2)) {
#line 221
        goto while_break;
      }
    } else {
#line 221
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 222
  __constr_expr_34.__in = s;
#line 222
  if ((__constr_expr_34.__i & 127) == 0) {
#line 224
    __constr_expr_32.__in = s;
#line 224
    if (0 == (__constr_expr_32.__i & 65280) >> 8) {
#line 225
      return (0);
    }
    {
#line 226
    __constr_expr_33.__in = s;
#line 226
    s = (__constr_expr_33.__i & 65280) >> 8;
#line 227
    fail(s, (char *)"%s/.outgoing exited with %d", s, s);
    }
  }
#line 229
  __constr_expr_37.__in = s;
#line 229
  if ((int )((signed char )((__constr_expr_37.__i & 127) + 1)) >> 1 > 0) {
    {
#line 230
    __constr_expr_35.__in = s;
#line 230
    __constr_expr_36.__in = s;
#line 230
    fail((__constr_expr_36.__i & 127) + 128, (char *)"%s/.outgoing caught signal %d",
         __constr_expr_35.__i & 127);
    }
  }
  {
#line 231
  fail(9, (char *)"%s/.outgoing unknown wait status %d", group, s);
#line 232
  _exit(1);
  }
}
}
#line 235 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/snsend.c"
static int store_special(char *group ) 
{ 
  int tmp ;

  {
  {
#line 235
  tmp = special(group, 0);
  }
#line 235
  return (tmp);
}
}
#line 236 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/snsend.c"
static int store_specialx(char *group ) 
{ 
  int tmp ;

  {
  {
#line 236
  tmp = special(group, 1);
  }
#line 236
  return (tmp);
}
}
#line 238 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/snsend.c"
static int store_fifo(char *group ) 
{ 
  int fd ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 242
  formats(path1___1, (int )(sizeof(path1___1) - 1UL), (char *)"%s/.outgoing", group);
#line 243
  fd = open((char const   *)(path1___1), 2049);
  }
#line 244
  if (-1 == fd) {
    {
#line 245
    fail(2, (char *)"store_fifo:open(%s):%m", path1___1);
    }
  }
  {
#line 246
  tmp = fcntl(fd, 4, 1);
  }
#line 246
  if (-1 == tmp) {
    {
#line 247
    fail(2, (char *)"store_fifo:fcntl(%s):%m", path1___1);
    }
  }
  {
#line 248
  lockf(fd, 1, (__off_t )0);
#line 249
  tmp___0 = writeart(fd);
  }
#line 249
  if (-1 == tmp___0) {
    {
#line 250
    fail(2, (char *)"store_fifo:write(%s):%m", path1___1);
    }
  }
  {
#line 251
  close(fd);
  }
#line 252
  return (0);
}
}
#line 259 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/snsend.c"
static int localstore(void) 
{ 
  int i ;
  int serial ;
  int done ;

  {
#line 263
  done = 0;
#line 264
  i = 0;
  {
#line 264
  while (1) {
    while_continue: /* CIL Label */ ;
#line 264
    if (! (i < nrgroups)) {
#line 264
      goto while_break;
    }
#line 264
    if (! (! (newsgroups + i)->s)) {
#line 265
      if (0U != (unsigned int )(newsgroups + i)->t) {
        {
#line 267
        serial = store_local((newsgroups + i)->s);
        }
#line 268
        if (1 == serial) {
#line 269
          return (1);
        }
#line 270
        if (canalias) {
#line 270
          if (art.body) {
            {
#line 272
            art.body = (char *)0;
#line 273
            art.blen = 0;
#line 274
            art.hlen = formats(art.head, art.hlen, (char *)"Message-ID: %s:%u<%s>\r\n",
                               (newsgroups + i)->s, serial, messageid);
            }
          }
        }
#line 277
        (newsgroups + i)->s = (char *)0;
#line 278
        done ++;
      }
    }
#line 264
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 280
  return (done);
}
}
#line 291
static void junk_article(void) ;
#line 291 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/snsend.c"
static int have_junk_group  =    -1;
#line 289 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/snsend.c"
static void junk_article(void) 
{ 
  int tmp ;

  {
  {
#line 293
  log_((char *)"article <%s> not for any newsgroup", messageid);
  }
#line 294
  if (0 == have_junk_group) {
#line 295
    return;
  }
  {
#line 296
  tmp = store_local((char *)0);
  }
#line 296
  if (tmp < 0) {
#line 298
    if (debug >= 1) {
      {
#line 300
      log_((char *)">>>");
#line 301
      writeart(2);
#line 302
      log_((char *)"<<<");
      }
    }
#line 304
    have_junk_group = 0;
  } else {
#line 307
    have_junk_group = 1;
  }
#line 308
  return;
}
}
#line 310 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/snsend.c"
static void snsend(void) 
{ 
  int i ;
  int serial ;
  int done ;
  ng_t tmp ;
  int tmp___0 ;

  {
#line 314
  done = 0;
#line 315
  i = 0;
  {
#line 315
  while (1) {
    while_continue: /* CIL Label */ ;
#line 315
    if (! (i < nrgroups)) {
#line 315
      goto while_break;
    }
#line 315
    if (! (! (newsgroups + i)->s)) {
      {
#line 317
      tmp = newsgroup_type((newsgroups + i)->s);
#line 317
      (newsgroups + i)->t = tmp;
      }
      {
#line 323
      if ((unsigned int )tmp == 4U) {
#line 323
        goto case_4;
      }
#line 326
      if ((unsigned int )tmp == 2U) {
#line 326
        goto case_2;
      }
#line 329
      if ((unsigned int )tmp == 3U) {
#line 329
        goto case_3;
      }
#line 332
      if ((unsigned int )tmp == 5U) {
#line 332
        goto case_5;
      }
#line 319
      goto switch_default;
      switch_default: /* CIL Label */ 
#line 322
      goto __Cont;
      case_4: /* CIL Label */ 
      {
#line 324
      serial = store_global((newsgroups + i)->s);
      }
#line 325
      goto switch_break;
      case_2: /* CIL Label */ 
      {
#line 327
      serial = store_special((newsgroups + i)->s);
      }
#line 328
      goto switch_break;
      case_3: /* CIL Label */ 
      {
#line 330
      serial = store_specialx((newsgroups + i)->s);
      }
#line 331
      goto switch_break;
      case_5: /* CIL Label */ 
      {
#line 333
      serial = store_fifo((newsgroups + i)->s);
      }
#line 334
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
#line 336
      if (report___0) {
        {
#line 337
        writef(1, (char *)"%s %u <%s>\n", (newsgroups + i)->s, serial, messageid);
        }
      }
#line 338
      (newsgroups + i)->s = (char *)0;
#line 339
      done ++;
    }
    __Cont: /* CIL Label */ 
#line 315
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 342
  tmp___0 = localstore();
#line 342
  done += tmp___0;
  }
#line 343
  if (! done) {
    {
#line 344
    junk_article();
    }
  }
#line 345
  return;
}
}
#line 353 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/snsend.c"
static void snstore(void) 
{ 
  int i ;
  int tmp ;

  {
#line 357
  i = 0;
  {
#line 357
  while (1) {
    while_continue: /* CIL Label */ ;
#line 357
    if (! (i < nrgroups)) {
#line 357
      goto while_break;
    }
#line 357
    if (! (! (newsgroups + i)->s)) {
      {
#line 357
      (newsgroups + i)->t = newsgroup_type((newsgroups + i)->s);
      }
    }
#line 357
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 358
  tmp = localstore();
  }
#line 358
  if (0 == tmp) {
    {
#line 359
    junk_article();
    }
  }
#line 360
  return;
}
}
#line 365 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/snsend.c"
static void store___NOT(void) 
{ 
  int tmp ;

  {
  {
#line 367
  tmp = writeart(1);
  }
#line 367
  if (-1 == tmp) {
    {
#line 368
    fail(2, (char *)"write:%m");
    }
  }
#line 369
  return;
}
}
#line 374 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/snsend.c"
static void usage___2(void) 
{ 


  {
  {
#line 376
  fail(1, (char *)"Usage: %s [-rcnva]\n-r input is in rnews batch format\n-c when storing to a local newsgroup, check first if it exists\n-n do nothing; echo articles to descriptor 1\n-v for each article, write to descriptor 1 where it went\n-a do not alias crossposts\n",
       progname);
  }
#line 382
  return;
}
}
#line 390
bool read_article(bool rnews ) ;
#line 454 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/snsend.c"
static struct b msgid  =    {(char *)0, 0, 0};
#line 455 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/snsend.c"
static struct b path___0  =    {(char *)0, 0, 0};
#line 456 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/snsend.c"
static struct b body___0  =    {(char *)0, 0, 0};
#line 457 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/snsend.c"
static struct b head___12  =    {(char *)0, 0, 0};
#line 458 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/snsend.c"
static struct b htmp  =    {(char *)0, 0, 0};
#line 459 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/snsend.c"
static int body_lines___0  ;
#line 460 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/snsend.c"
static bool have_date  ;
#line 461 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/snsend.c"
static bool have_newsgroups___0  ;
#line 462 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/snsend.c"
static char *rline  ;
#line 463 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/snsend.c"
static int rlen  ;
#line 465 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/snsend.c"
static void badread___0(void) 
{ 


  {
  {
#line 465
  fail(2, (char *)"can\'t read article:%m");
  }
#line 465
  return;
}
}
#line 466 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/snsend.c"
static void eof(void) 
{ 


  {
  {
#line 466
  fail(3, (char *)"unexpected end of file");
  }
#line 466
  return;
}
}
#line 467 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/snsend.c"
static void badrnews(void) 
{ 


  {
  {
#line 467
  fail(3, (char *)"bad rnews line");
  }
#line 467
  return;
}
}
#line 469 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/snsend.c"
static bool first_call  ;
#line 471 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/snsend.c"
static void init___1(void) 
{ 


  {
#line 473
  messageid = (char *)0;
#line 474
  first_call = (bool )1;
#line 475
  path___0.used = 0;
#line 475
  msgid.used = path___0.used;
#line 475
  htmp.used = msgid.used;
#line 475
  head___12.used = htmp.used;
#line 475
  body___0.used = head___12.used;
#line 475
  body_lines___0 = body___0.used;
#line 476
  have_newsgroups___0 = (bool )0;
#line 476
  have_date = have_newsgroups___0;
#line 477
  return;
}
}
#line 479 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/snsend.c"
static int getline(void) 
{ 
  int len ;

  {
  {
#line 483
  rlen = readln(& input___0, & rline, '\n');
#line 483
  len = rlen;
  }
#line 484
  if (0 == rlen) {
#line 485
    return (0);
  }
#line 486
  if (rlen < 0) {
    {
#line 486
    badread___0();
    }
  }
#line 487
  rlen --;
#line 487
  *(rline + rlen) = (char )'\000';
#line 488
  if (rlen > 0) {
#line 489
    if (13 == (int )*(rline + (rlen - 1))) {
#line 490
      rlen --;
#line 490
      *(rline + rlen) = (char )'\000';
    }
  }
#line 491
  return (len);
}
}
#line 494 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/snsend.c"
static void appendbody(void) 
{ 
  int tmp ;
  size_t tmp___0 ;
  int tmp___1 ;

  {
  {
#line 496
  tmp = b_appendl(& body___0, rline, rlen);
  }
#line 496
  if (tmp) {
    {
#line 496
    nomem___1();
    }
  } else {
    {
#line 496
    tmp___0 = strlen("\r\n");
#line 496
    tmp___1 = b_appendl(& body___0, (char *)"\r\n", (int )tmp___0);
    }
#line 496
    if (tmp___1) {
      {
#line 496
      nomem___1();
      }
    }
  }
#line 497
  return;
}
}
#line 503
static void parsenewsgroups(char *ng ) ;
#line 503 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/snsend.c"
static int size___0  =    0;
#line 504 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/snsend.c"
static struct b ngbuf  =    {(char *)0, 0, 0};
#line 501 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/snsend.c"
static void parsenewsgroups(char *ng ) 
{ 
  char *p ;
  void *tmp ;
  size_t tmp___0 ;
  int tmp___1 ;
  struct ng___0 *tmp___2 ;
  void *tmp___3 ;
  size_t tmp___4 ;
  size_t tmp___5 ;

  {
#line 507
  if (0 == size___0) {
    {
#line 508
    size___0 = 10;
#line 508
    tmp = malloc((unsigned long )size___0 * sizeof(struct ng___0 ));
#line 508
    newsgroups = (struct ng___0 *)tmp;
    }
#line 508
    if (! newsgroups) {
      {
#line 509
      nomem___1();
      }
    }
  }
  {
#line 510
  while (1) {
    while_continue: /* CIL Label */ ;
#line 510
    if (! (32 == (int )*ng)) {
#line 510
      goto while_break;
    }
#line 511
    ng ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 513
  ngbuf.used = 0;
#line 514
  tmp___0 = strlen((char const   *)ng);
#line 514
  tmp___1 = b_appendl(& ngbuf, ng, (int )tmp___0);
  }
#line 514
  if (tmp___1) {
    {
#line 514
    nomem___1();
    }
  }
#line 515
  ng = ngbuf.buf;
#line 517
  nrgroups = 0;
  {
#line 517
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 517
    p = tokensep(& ng, (char *)",");
    }
#line 517
    if (! p) {
#line 517
      goto while_break___0;
    }
    {
#line 519
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 519
      if (! (32 == (int )*p)) {
#line 519
        goto while_break___1;
      }
#line 520
      p ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 521
    if (! *p) {
#line 522
      goto __Cont;
    }
#line 523
    if (nrgroups + 1 >= size___0) {
      {
#line 526
      tmp___3 = malloc((unsigned long )(size___0 * 2) * sizeof(struct ng___0 ));
#line 526
      tmp___2 = (struct ng___0 *)tmp___3;
      }
#line 526
      if (! tmp___2) {
        {
#line 526
        nomem___1();
        }
      }
      {
#line 527
      memcpy((void */* __restrict  */)tmp___2, (void const   */* __restrict  */)newsgroups,
             (unsigned long )size___0 * sizeof(struct ng___0 ));
#line 528
      free((void *)newsgroups);
#line 529
      newsgroups = tmp___2;
#line 530
      size___0 *= 2;
      }
    }
    {
#line 532
    while (1) {
      while_continue___2: /* CIL Label */ ;
      {
#line 532
      tmp___5 = strlen((char const   *)p);
      }
#line 532
      if (! ((int )*(p + (tmp___5 - 1UL)) == 32)) {
#line 532
        goto while_break___2;
      }
      {
#line 533
      tmp___4 = strlen((char const   *)p);
#line 533
      *(p + (tmp___4 - 1UL)) = (char )'\000';
      }
    }
    while_break___2: /* CIL Label */ ;
    }
#line 534
    (newsgroups + nrgroups)->s = p;
#line 535
    (newsgroups + nrgroups)->t = (ng_t )0;
    __Cont: /* CIL Label */ 
#line 517
    nrgroups ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 537
  return;
}
}
#line 551 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/snsend.c"
static int append(char *line , int len ) 
{ 
  char *p ;
  int c ;
  int hlen ;
  int tmp ;
  size_t tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  size_t tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  size_t tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int len___0 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  size_t tmp___21 ;
  int tmp___22 ;

  {
#line 556
  if (first_call) {
    {
#line 558
    first_call = (bool )0;
#line 559
    tmp = strncmp((char const   *)line, "From ", (size_t )5);
    }
#line 559
    if (0 == tmp) {
#line 560
      return (0);
    }
  }
  {
#line 562
  hlen = check_field(line, len);
  }
#line 563
  if (! hlen) {
#line 564
    goto badline;
  }
  {
#line 566
  while (1) {
    while_continue: /* CIL Label */ ;
#line 568
    if ((unsigned long )hlen == sizeof("References") - 1UL) {
      {
#line 568
      tmp___5 = strncasecmp((char const   *)line, "References", sizeof("References") - 1UL);
      }
#line 568
      if (0 == tmp___5) {
#line 568
        if (58 == (int )*(line + (sizeof("References") - 1UL))) {
#line 570
          if (len > 500) {
#line 572
            p = (line + len) - 500;
#line 573
            c = 500;
            {
#line 574
            while (1) {
              while_continue___0: /* CIL Label */ ;
#line 574
              if (*p) {
#line 574
                if (! (32 != (int )*p)) {
#line 574
                  goto while_break___0;
                }
              } else {
#line 574
                goto while_break___0;
              }
#line 576
              p ++;
#line 577
              c --;
            }
            while_break___0: /* CIL Label */ ;
            }
#line 579
            if (! *p) {
#line 579
              goto while_break;
            }
            {
#line 580
            tmp___0 = strlen("References: ");
#line 580
            tmp___1 = b_appendl(& htmp, (char *)"References: ", (int )tmp___0);
            }
#line 580
            if (tmp___1) {
              {
#line 580
              nomem___1();
              }
            }
            {
#line 581
            tmp___2 = b_appendl(& htmp, p + 1, c - 1);
            }
#line 581
            if (tmp___2) {
              {
#line 581
              nomem___1();
              }
            }
            {
#line 582
            tmp___3 = strlen("\r\n");
#line 582
            tmp___4 = b_appendl(& htmp, (char *)"\r\n", (int )tmp___3);
            }
#line 582
            if (tmp___4) {
              {
#line 582
              nomem___1();
              }
            }
#line 583
            return (0);
          }
#line 585
          goto while_break;
        }
      }
    }
#line 587
    if ((unsigned long )hlen == sizeof("Path") - 1UL) {
      {
#line 587
      tmp___7 = strncasecmp((char const   *)line, "Path", sizeof("Path") - 1UL);
      }
#line 587
      if (0 == tmp___7) {
#line 587
        if (58 == (int )*(line + (sizeof("Path") - 1UL))) {
#line 589
          if (path___0.used) {
#line 590
            return (0);
          }
#line 591
          line += hlen + 1;
#line 591
          len -= hlen + 1;
          {
#line 591
          while (1) {
            while_continue___1: /* CIL Label */ ;
#line 591
            if (! (32 == (int )*line)) {
#line 591
              goto while_break___1;
            }
#line 591
            line ++;
#line 591
            len --;
          }
          while_break___1: /* CIL Label */ ;
          }
          {
#line 592
          tmp___6 = b_appendl(& path___0, line, len);
          }
#line 592
          if (tmp___6) {
            {
#line 592
            nomem___1();
            }
          }
#line 593
          return (0);
        }
      }
    }
#line 595
    if ((unsigned long )hlen == sizeof("Newsgroups") - 1UL) {
      {
#line 595
      tmp___11 = strncasecmp((char const   *)line, "Newsgroups", sizeof("Newsgroups") - 1UL);
      }
#line 595
      if (0 == tmp___11) {
#line 595
        if (58 == (int )*(line + (sizeof("Newsgroups") - 1UL))) {
#line 597
          if (have_newsgroups___0) {
#line 597
            goto while_break;
          }
          {
#line 598
          tmp___8 = b_appendl(& htmp, line, len);
          }
#line 598
          if (tmp___8) {
            {
#line 598
            nomem___1();
            }
          }
          {
#line 599
          tmp___9 = strlen("\r\n");
#line 599
          tmp___10 = b_appendl(& htmp, (char *)"\r\n", (int )tmp___9);
          }
#line 599
          if (tmp___10) {
            {
#line 599
            nomem___1();
            }
          }
          {
#line 600
          have_newsgroups___0 = (bool )1;
#line 601
          parsenewsgroups((line + hlen) + 1);
          }
#line 602
          return (0);
        }
      }
    }
#line 604
    if ((unsigned long )hlen == sizeof("X-sn-Newsgroups") - 1UL) {
      {
#line 604
      tmp___12 = strncasecmp((char const   *)line, "X-sn-Newsgroups", sizeof("X-sn-Newsgroups") - 1UL);
      }
#line 604
      if (0 == tmp___12) {
#line 604
        if (58 == (int )*(line + (sizeof("X-sn-Newsgroups") - 1UL))) {
          {
#line 606
          parsenewsgroups((line + hlen) + 1);
          }
#line 607
          return (0);
        }
      }
    }
#line 609
    if ((unsigned long )hlen == sizeof("Message-ID") - 1UL) {
      {
#line 609
      tmp___14 = strncasecmp((char const   *)line, "Message-ID", sizeof("Message-ID") - 1UL);
      }
#line 609
      if (0 == tmp___14) {
#line 609
        if (58 == (int )*(line + (sizeof("Message-ID") - 1UL))) {
#line 613
          if (msgid.used) {
#line 613
            goto while_break;
          }
#line 614
          p = (line + hlen) + 1;
          {
#line 614
          while (1) {
            while_continue___2: /* CIL Label */ ;
#line 614
            if (! (32 == (int )*p)) {
#line 614
              goto while_break___2;
            }
#line 614
            p ++;
          }
          while_break___2: /* CIL Label */ ;
          }
#line 615
          if (60 != (int )*p) {
            {
#line 617
            log_((char *)"append: will replace bad Message-ID \"%s\"", p);
            }
#line 618
            return (0);
          } else {
            {
#line 615
            len___0 = addr_msgid(p);
            }
#line 615
            if (len___0 <= 0) {
              {
#line 617
              log_((char *)"append: will replace bad Message-ID \"%s\"", p);
              }
#line 618
              return (0);
            }
          }
          {
#line 620
          tmp___13 = b_appendl(& msgid, p + 1, len___0 - 2);
          }
#line 620
          if (tmp___13) {
            {
#line 620
            nomem___1();
            }
          }
#line 621
          goto while_break;
        }
      }
    }
    {
#line 623
    tmp___15 = strncasecmp((char const   *)line, "X-sn-", (size_t )5);
    }
#line 623
    if (0 == tmp___15) {
#line 624
      return (0);
    }
#line 625
    if ((unsigned long )hlen == sizeof("Bytes") - 1UL) {
      {
#line 625
      tmp___16 = strncasecmp((char const   *)line, "Bytes", sizeof("Bytes") - 1UL);
      }
#line 625
      if (0 == tmp___16) {
#line 625
        if (58 == (int )*(line + (sizeof("Bytes") - 1UL))) {
#line 625
          return (0);
        }
      }
    }
#line 626
    if ((unsigned long )hlen == sizeof("Lines") - 1UL) {
      {
#line 626
      tmp___17 = strncasecmp((char const   *)line, "Lines", sizeof("Lines") - 1UL);
      }
#line 626
      if (0 == tmp___17) {
#line 626
        if (58 == (int )*(line + (sizeof("Lines") - 1UL))) {
#line 626
          return (0);
        }
      }
    }
#line 627
    if ((unsigned long )hlen == sizeof("Xref") - 1UL) {
      {
#line 627
      tmp___18 = strncasecmp((char const   *)line, "Xref", sizeof("Xref") - 1UL);
      }
#line 627
      if (0 == tmp___18) {
#line 627
        if (58 == (int )*(line + (sizeof("Xref") - 1UL))) {
#line 627
          return (0);
        }
      }
    }
#line 628
    if ((unsigned long )hlen == sizeof("Date") - 1UL) {
      {
#line 628
      tmp___19 = strncasecmp((char const   *)line, "Date", sizeof("Date") - 1UL);
      }
#line 628
      if (0 == tmp___19) {
#line 628
        if (58 == (int )*(line + (sizeof("Date") - 1UL))) {
#line 628
          have_date = (bool )1;
        }
      }
    }
#line 566
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 631
  if (0) {
    badline: 
    {
#line 633
    log_((char *)"append:bad header \"%s\"", line);
    }
  }
  {
#line 634
  tmp___20 = b_appendl(& htmp, line, len);
  }
#line 634
  if (tmp___20) {
    {
#line 634
    nomem___1();
    }
  }
  {
#line 635
  tmp___21 = strlen("\r\n");
#line 635
  tmp___22 = b_appendl(& htmp, (char *)"\r\n", (int )tmp___21);
  }
#line 635
  if (tmp___22) {
    {
#line 635
    nomem___1();
    }
  }
#line 636
  return (0);
}
}
#line 639 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/snsend.c"
static int read_nntp(void) 
{ 
  int consumed ;
  int len ;

  {
  {
#line 643
  consumed = unfold(& input___0, & append);
  }
#line 644
  if (0 == consumed) {
#line 645
    return (0);
  }
#line 646
  if (consumed < 0) {
    {
#line 646
    badread___0();
    }
  }
#line 648
  body_lines___0 = 0;
  {
#line 648
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 652
    len = getline();
    }
#line 652
    if (0 == len) {
      {
#line 652
      eof();
      }
    }
#line 653
    consumed += len;
#line 654
    if (1 == rlen) {
#line 655
      if (46 == (int )*rline) {
#line 656
        goto while_break;
      }
    }
    {
#line 657
    body_lines___0 ++;
#line 658
    appendbody();
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 660
  return (consumed);
}
}
#line 663 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/snsend.c"
static int read_rnews___0(void) 
{ 
  int bytes___1 ;
  int c ;
  int consumed ;
  int tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  size_t tmp___3 ;
  int tmp___4 ;

  {
  {
#line 667
  tmp = getline();
  }
#line 667
  if (0 == tmp) {
#line 668
    return (0);
  }
#line 670
  tmp___0 = rline;
#line 670
  rline ++;
#line 670
  if (35 != (int )*tmp___0) {
    {
#line 670
    badrnews();
    }
  }
#line 671
  tmp___1 = rline;
#line 671
  rline ++;
#line 671
  if (33 != (int )*tmp___1) {
    {
#line 671
    badrnews();
    }
  }
  {
#line 672
  while (1) {
    while_continue: /* CIL Label */ ;
#line 672
    if (! (32 == (int )*rline)) {
#line 672
      goto while_break;
    }
#line 673
    rline ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 674
  tmp___2 = strncmp((char const   *)rline, "rnews ", (size_t )6);
  }
#line 674
  if (tmp___2) {
    {
#line 674
    badrnews();
    }
  }
#line 675
  rline += 6;
  {
#line 675
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 675
    if (! (32 == (int )*rline)) {
#line 675
      goto while_break___0;
    }
#line 675
    rline ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 676
  bytes___1 = 0;
  {
#line 676
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 676
    c = (int )*rline;
#line 676
    if (! c) {
#line 676
      goto while_break___1;
    }
#line 678
    if (c < 48) {
      {
#line 678
      badrnews();
      }
    } else
#line 678
    if (c > 57) {
      {
#line 678
      badrnews();
      }
    }
#line 679
    bytes___1 *= 10;
#line 680
    bytes___1 += c - 48;
#line 676
    rline ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 683
  consumed = unfold(& input___0, & append);
  }
#line 684
  if (0 == consumed) {
    {
#line 684
    eof();
    }
  }
#line 685
  if (consumed < 0) {
    {
#line 685
    badread___0();
    }
  }
#line 687
  body_lines___0 = 0;
  {
#line 687
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 687
    if (! (consumed < bytes___1)) {
#line 687
      goto while_break___2;
    }
    {
#line 689
    c = getline();
    }
#line 689
    if (0 == c) {
      {
#line 689
      eof();
      }
    }
#line 690
    consumed += c;
#line 691
    if (consumed > bytes___1) {
      {
#line 692
      fail(3, (char *)"rnews input overshot");
      }
    }
#line 693
    body_lines___0 ++;
#line 694
    if (46 == (int )*rline) {
      {
#line 695
      tmp___3 = strlen(".");
#line 695
      tmp___4 = b_appendl(& body___0, (char *)".", (int )tmp___3);
      }
#line 695
      if (tmp___4) {
        {
#line 695
        nomem___1();
        }
      }
    }
    {
#line 696
    appendbody();
    }
  }
  while_break___2: /* CIL Label */ ;
  }
#line 698
  return (consumed);
}
}
#line 701 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/snsend.c"
static void appendhead(char *line , int len ) 
{ 
  int tmp ;

  {
  {
#line 703
  tmp = b_appendl(& head___12, line, len);
  }
#line 703
  if (tmp) {
    {
#line 703
    nomem___1();
    }
  }
#line 704
  return;
}
}
#line 755 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/snsend.c"
static char *months[12]  = 
#line 755
  {      (char *)"Jan",      (char *)"Feb",      (char *)"Mar",      (char *)"Apr", 
        (char *)"May",      (char *)"Jun",      (char *)"Jul",      (char *)"Aug", 
        (char *)"Sep",      (char *)"Oct",      (char *)"Nov",      (char *)"Dec"};
#line 756 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/snsend.c"
static char *days[7]  = {      (char *)"Sun",      (char *)"Mon",      (char *)"Tue",      (char *)"Wed", 
        (char *)"Thu",      (char *)"Fri",      (char *)"Sat"};
#line 710 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/snsend.c"
bool read_article(bool rnews ) 
{ 
  char buf___28[80] ;
  int c ;
  int i ;
  size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  char *p ;
  time_t t ;
  struct tm *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;
  char *tmp___14 ;
  char *tmp___15 ;
  char *tmp___16 ;
  char *tmp___17 ;
  char *tmp___18 ;
  char *tmp___19 ;
  char *tmp___20 ;
  char *tmp___21 ;
  char *tmp___22 ;
  size_t tmp___23 ;
  size_t tmp___24 ;
  size_t tmp___25 ;
  size_t tmp___26 ;
  int tmp___27 ;

  {
  {
#line 715
  init___1();
  }
#line 716
  if (rnews) {
    {
#line 717
    c = read_rnews___0();
    }
  } else {
    {
#line 719
    c = read_nntp();
    }
  }
#line 720
  if (0 == c) {
#line 721
    return ((bool )0);
  }
  {
#line 725
  tmp = strlen("Path: ");
#line 725
  appendhead((char *)"Path: ", (int )tmp);
#line 726
  appendhead(me___0, melen);
  }
#line 727
  if (path___0.used) {
    {
#line 729
    tmp___0 = strlen("!");
#line 729
    appendhead((char *)"!", (int )tmp___0);
#line 730
    appendhead(path___0.buf, path___0.used);
    }
  } else
#line 733
  if (debug >= 3) {
    {
#line 733
    log_((char *)"created Path header...");
    }
  }
  {
#line 734
  tmp___1 = strlen("\r\n");
#line 734
  appendhead((char *)"\r\n", (int )tmp___1);
#line 736
  appendhead(htmp.buf, htmp.used);
  }
#line 739
  if (! msgid.used) {
    {
#line 741
    c = formats(buf___28, (int )(sizeof(buf___28) - 1UL), (char *)"%x.%x.%x@%s", pid,
                now.tv_sec, now.tv_usec, me___0);
#line 742
    tmp___2 = b_appendl(& msgid, buf___28, c);
    }
#line 742
    if (tmp___2) {
      {
#line 742
      nomem___1();
      }
    }
    {
#line 743
    tmp___3 = strlen("Message-ID: <");
#line 743
    appendhead((char *)"Message-ID: <", (int )tmp___3);
#line 744
    appendhead(buf___28, c);
#line 745
    tmp___4 = strlen(">\r\n");
#line 745
    appendhead((char *)">\r\n", (int )tmp___4);
    }
#line 746
    if (debug >= 1) {
      {
#line 746
      log_((char *)"created Message-ID \"<%s>\"", buf___28);
      }
    }
  } else
#line 749
  if (debug >= 3) {
    {
#line 749
    log_((char *)"read article \"<%s>\"", msgid.buf);
    }
  }
#line 750
  messageid = msgid.buf;
#line 753
  if (! have_date) {
    {
#line 761
    p = (buf___28 + sizeof(buf___28)) - 1;
#line 762
    tmp___6 = p;
#line 762
    p --;
#line 762
    *tmp___6 = (char )'\000';
#line 763
    time(& t);
#line 764
    tmp___5 = gmtime((time_t const   *)(& t));
#line 765
    c = tmp___5->tm_sec;
#line 765
    tmp___7 = p;
#line 765
    p --;
#line 765
    *tmp___7 = (char )(c % 10 + 48);
#line 765
    tmp___8 = p;
#line 765
    p --;
#line 765
    *tmp___8 = (char )(c / 10 + 48);
#line 765
    tmp___9 = p;
#line 765
    p --;
#line 765
    *tmp___9 = (char )':';
#line 766
    c = tmp___5->tm_min;
#line 766
    tmp___10 = p;
#line 766
    p --;
#line 766
    *tmp___10 = (char )(c % 10 + 48);
#line 766
    tmp___11 = p;
#line 766
    p --;
#line 766
    *tmp___11 = (char )(c / 10 + 48);
#line 766
    tmp___12 = p;
#line 766
    p --;
#line 766
    *tmp___12 = (char )':';
#line 767
    c = tmp___5->tm_hour;
#line 767
    tmp___13 = p;
#line 767
    p --;
#line 767
    *tmp___13 = (char )(c % 10 + 48);
#line 767
    tmp___14 = p;
#line 767
    p --;
#line 767
    *tmp___14 = (char )(c / 10 + 48);
#line 767
    tmp___15 = p;
#line 767
    p --;
#line 767
    *tmp___15 = (char )' ';
#line 768
    c = tmp___5->tm_year + 1900;
#line 769
    i = 0;
    }
    {
#line 769
    while (1) {
      while_continue: /* CIL Label */ ;
#line 769
      if (! (i < 4)) {
#line 769
        goto while_break;
      }
#line 771
      tmp___16 = p;
#line 771
      p --;
#line 771
      *tmp___16 = (char )(c % 10 + 48);
#line 772
      c /= 10;
#line 769
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 774
    tmp___17 = p;
#line 774
    p --;
#line 774
    *tmp___17 = (char )' ';
#line 775
    p -= 3;
#line 776
    memcpy((void */* __restrict  */)(p + 1), (void const   */* __restrict  */)months[tmp___5->tm_mon],
           (size_t )3);
#line 777
    tmp___18 = p;
#line 777
    p --;
#line 777
    *tmp___18 = (char )' ';
#line 778
    c = tmp___5->tm_mday;
#line 778
    tmp___19 = p;
#line 778
    p --;
#line 778
    *tmp___19 = (char )(c % 10 + 48);
#line 778
    tmp___20 = p;
#line 778
    p --;
#line 778
    *tmp___20 = (char )(c / 10 + 48);
#line 778
    tmp___21 = p;
#line 778
    p --;
#line 778
    *tmp___21 = (char )' ';
#line 779
    tmp___22 = p;
#line 779
    p --;
#line 779
    *tmp___22 = (char )',';
#line 780
    p -= 2;
#line 781
    memcpy((void */* __restrict  */)p, (void const   */* __restrict  */)days[tmp___5->tm_wday],
           (size_t )3);
#line 782
    tmp___23 = strlen("Date: ");
#line 782
    appendhead((char *)"Date: ", (int )tmp___23);
#line 783
    tmp___24 = strlen((char const   *)p);
#line 783
    appendhead(p, (int )tmp___24);
#line 784
    tmp___25 = strlen(" -0000\r\n");
#line 784
    appendhead((char *)" -0000\r\n", (int )tmp___25);
    }
#line 785
    if (debug >= 3) {
      {
#line 785
      log_((char *)"added Date to article \"<%s>\"", messageid);
      }
    }
  }
#line 788
  if (0 == body_lines___0) {
    {
#line 790
    tmp___26 = strlen("\r\n");
#line 790
    tmp___27 = b_appendl(& body___0, (char *)"\r\n", (int )tmp___26);
    }
#line 790
    if (tmp___27) {
      {
#line 790
      nomem___1();
      }
    }
#line 791
    body_lines___0 ++;
  }
  {
#line 795
  c = formats(buf___28, (int )(sizeof(buf___28) - 1UL), (char *)"Bytes: %u\r\nLines: %u\r\n",
              body___0.used, body_lines___0);
#line 796
  appendhead(buf___28, c);
#line 799
  art.head = head___12.buf;
#line 800
  art.hlen = head___12.used;
#line 801
  art.body = body___0.buf;
#line 802
  art.blen = body___0.used;
  }
#line 803
  return ((bool )1);
}
}
#line 87 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/cache.c"
static struct entry *new_entry___11(int desc___35 ) 
{ 
  struct entry *ep ;
  struct entry *tmp ;

  {
#line 91
  ep = table[desc___35].freelist;
#line 91
  if (ep) {
#line 92
    table[desc___35].freelist = ep->next;
  } else {
#line 95
    ep = table[desc___35].entries;
    {
#line 95
    while (1) {
      while_continue: /* CIL Label */ ;
#line 95
      if (! ep->next) {
#line 95
        goto while_break;
      }
#line 95
      ep = ep->next;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 96
    (ep->prev)->next = (struct entry *)((void *)0);
#line 97
    (*(table[desc___35].freeobj))(ep->object);
    }
  }
#line 99
  tmp = (struct entry *)((void *)0);
#line 99
  ep->next = tmp;
#line 99
  ep->prev = tmp;
#line 100
  ep->object = (void *)0;
#line 101
  return (ep);
}
}
#line 67 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/store.c"
static int sto_cmp___8(void *a , void *b___13 ) 
{ 
  register struct storeobj *x ;
  register struct storeobj *y ;
  int tmp ;

  {
  {
#line 69
  x = (struct storeobj *)a;
#line 70
  y = (struct storeobj *)b___13;
#line 72
  tmp = strcmp((char const   *)x->filename, (char const   *)y->filename);
  }
#line 72
  return (tmp);
}
}
#line 75 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/store.c"
static int nosigio___8(ssize_t (*op)() , int fd , char *buf___28 , int len ) 
{ 
  int er ;
  int *tmp ;
  ssize_t tmp___0 ;

  {
  {
#line 79
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 79
    tmp___0 = (*op)(fd, buf___28, len);
#line 79
    er = (int )tmp___0;
    }
#line 79
    if (! (-1 == er)) {
#line 79
      goto while_break;
    }
    {
#line 80
    tmp = __errno_location();
    }
#line 80
    if (4 != *tmp) {
#line 82
      if (debug >= 1) {
        {
#line 82
        log_((char *)"nosigio:%m");
        }
      }
#line 83
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 85
  return (er);
}
}
#line 88 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/store.c"
static int copyart___8(int tofd , int fromfd , int fromseek , int len ) 
{ 
  char buf___28[1024] ;
  __off_t tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  {
#line 92
  tmp = lseek(fromfd, (__off_t )fromseek, 0);
  }
#line 92
  if (-1L == tmp) {
    {
#line 94
    log_((char *)"copyart:lseek:%m");
    }
#line 95
    return (-1);
  }
  {
#line 98
  while (1) {
    while_continue: /* CIL Label */ ;
#line 98
    if (! (len > 1024)) {
#line 98
      goto while_break;
    }
    {
#line 99
    tmp___0 = nosigio___8((ssize_t (*)())(& read), fromfd, buf___28, 1024);
    }
#line 99
    if (-1 == tmp___0) {
#line 100
      return (-1);
    } else {
      {
#line 99
      tmp___1 = nosigio___8((ssize_t (*)())(& write), tofd, buf___28, 1024);
      }
#line 99
      if (-1 == tmp___1) {
#line 100
        return (-1);
      }
    }
#line 98
    len -= 1024;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 101
  tmp___2 = nosigio___8((ssize_t (*)())(& read), fromfd, buf___28, len);
  }
#line 101
  if (-1 == tmp___2) {
#line 102
    return (-1);
  } else {
    {
#line 101
    tmp___3 = nosigio___8((ssize_t (*)())(& write), tofd, buf___28, len);
    }
#line 101
    if (-1 == tmp___3) {
#line 102
      return (-1);
    }
  }
#line 104
  return (0);
}
}
#line 107 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/store.c"
static int checkindex___8(struct info *p ) 
{ 


  {
#line 109
  if (p->hoffset > 0) {
#line 111
    if (p->boffset > 0) {
#line 112
      if (p->hlen > 0) {
#line 113
        if (p->blen > 0) {
#line 114
          return (0);
        }
      }
    }
  } else
#line 116
  if (-1 == p->hoffset) {
#line 116
    if (-1 == p->boffset) {
#line 117
      return (1);
    }
  }
#line 118
  return (-1);
}
}
#line 127 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/store.c"
static void reorder___8(struct storeobj *sp ) 
{ 
  char tmpname[287] ;
  char *p ;
  char *q ;
  int fd ;
  struct file f___9 ;
  int er ;
  int i ;
  char *tmp ;
  char tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char tmp___4 ;
  char *tmp___5 ;
  int *tmp___6 ;
  int tmp___7 ;
  char *p___0 ;
  int *tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  __off_t tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  __off_t tmp___17 ;
  __off_t tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;

  {
#line 133
  f___9.magic = 0;
#line 133
  f___9.info[0].hoffset = 0;
#line 133
  f___9.info[0].hlen = 0;
#line 133
  f___9.info[0].boffset = 0;
#line 133
  f___9.info[0].blen = 0;
#line 133
  f___9.info[1].hoffset = 0;
#line 133
  f___9.info[1].hlen = 0;
#line 133
  f___9.info[1].boffset = 0;
#line 133
  f___9.info[1].blen = 0;
#line 133
  f___9.info[2].hoffset = 0;
#line 133
  f___9.info[2].hlen = 0;
#line 133
  f___9.info[2].boffset = 0;
#line 133
  f___9.info[2].blen = 0;
#line 133
  f___9.info[3].hoffset = 0;
#line 133
  f___9.info[3].hlen = 0;
#line 133
  f___9.info[3].boffset = 0;
#line 133
  f___9.info[3].blen = 0;
#line 133
  f___9.info[4].hoffset = 0;
#line 133
  f___9.info[4].hlen = 0;
#line 133
  f___9.info[4].boffset = 0;
#line 133
  f___9.info[4].blen = 0;
#line 133
  f___9.info[5].hoffset = 0;
#line 133
  f___9.info[5].hlen = 0;
#line 133
  f___9.info[5].boffset = 0;
#line 133
  f___9.info[5].blen = 0;
#line 133
  f___9.info[6].hoffset = 0;
#line 133
  f___9.info[6].hlen = 0;
#line 133
  f___9.info[6].boffset = 0;
#line 133
  f___9.info[6].blen = 0;
#line 133
  f___9.info[7].hoffset = 0;
#line 133
  f___9.info[7].hlen = 0;
#line 133
  f___9.info[7].boffset = 0;
#line 133
  f___9.info[7].blen = 0;
#line 133
  f___9.info[8].hoffset = 0;
#line 133
  f___9.info[8].hlen = 0;
#line 133
  f___9.info[8].boffset = 0;
#line 133
  f___9.info[8].blen = 0;
#line 133
  f___9.info[9].hoffset = 0;
#line 133
  f___9.info[9].hlen = 0;
#line 133
  f___9.info[9].boffset = 0;
#line 133
  f___9.info[9].blen = 0;
#line 136
  p = tmpname;
#line 136
  q = sp->filename;
  {
#line 136
  while (1) {
    while_continue: /* CIL Label */ ;
#line 136
    tmp = p;
#line 136
    p ++;
#line 136
    tmp___1 = q;
#line 136
    q ++;
#line 136
    tmp___0 = *tmp___1;
#line 136
    *tmp = tmp___0;
#line 136
    if (! ((int )tmp___0 != 47)) {
#line 136
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 137
  tmp___2 = p;
#line 137
  p ++;
#line 137
  *tmp___2 = (char )'+';
  {
#line 138
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 138
    tmp___3 = p;
#line 138
    p ++;
#line 138
    tmp___5 = q;
#line 138
    q ++;
#line 138
    tmp___4 = *tmp___5;
#line 138
    *tmp___3 = tmp___4;
#line 138
    if (! tmp___4) {
#line 138
      goto while_break___0;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 139
  fd = open((char const   *)(tmpname), 194, 420);
  }
#line 140
  if (-1 == fd) {
    {
#line 142
    tmp___6 = __errno_location();
    }
#line 142
    if (17 != *tmp___6) {
      {
#line 143
      log_((char *)"reorder:open(%s):%m", tmpname);
      }
    }
#line 144
    return;
  }
  {
#line 147
  f___9.magic = 1027296;
#line 148
  tmp___7 = nosigio___8((ssize_t (*)())(& write), fd, (char *)(& f___9), (int )sizeof(f___9));
  }
#line 148
  if (-1 == tmp___7) {
#line 149
    goto fail;
  }
  {
#line 161
  tmp___9 = lockf(sp->fd, 2, (__off_t )0);
  }
#line 161
  if (-1 == tmp___9) {
    {
#line 165
    tmp___8 = __errno_location();
    }
#line 165
    if (11 != *tmp___8) {
#line 166
      p___0 = (char *)"reorder:can\'t lockf %s:%m";
    } else {
#line 168
      p___0 = (char *)"reorder:article in %s being cancelled?";
    }
    {
#line 169
    log_(p___0, sp->filename);
    }
#line 170
    goto fail;
  }
#line 173
  i = 0;
  {
#line 173
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 173
    if (! (i < 10)) {
#line 173
      goto while_break___1;
    }
    {
#line 174
    tmp___10 = checkindex___8((sp->file)->info + i);
    }
    {
#line 176
    if (tmp___10 == 0) {
#line 176
      goto case_0;
    }
#line 188
    if (tmp___10 == 1) {
#line 188
      goto case_1;
    }
#line 191
    if (tmp___10 == -1) {
#line 191
      goto case_neg_1;
    }
#line 174
    goto switch_break;
    case_0: /* CIL Label */ 
    {
#line 177
    tmp___12 = lseek(fd, (__off_t )0, 2);
#line 177
    tmp___11 = (int )tmp___12;
#line 177
    f___9.info[i].hoffset = tmp___11;
    }
#line 177
    if (tmp___11 > 0) {
      {
#line 179
      f___9.info[i].hlen = (sp->file)->info[i].hlen;
#line 180
      f___9.info[i].blen = (sp->file)->info[i].blen;
#line 181
      er = copyart___8(fd, sp->fd, (sp->file)->info[i].hoffset, f___9.info[i].hlen);
      }
#line 182
      if (0 == er) {
#line 183
        goto switch_break;
      }
    } else {
      {
#line 186
      log_((char *)"reorder:lseek(%s):%m", tmpname);
      }
    }
#line 187
    goto fail;
    case_1: /* CIL Label */ 
#line 189
    tmp___15 = -1;
#line 189
    f___9.info[i].hlen = tmp___15;
#line 189
    tmp___14 = tmp___15;
#line 189
    f___9.info[i].blen = tmp___14;
#line 189
    tmp___13 = tmp___14;
#line 189
    f___9.info[i].hoffset = tmp___13;
#line 189
    f___9.info[i].boffset = tmp___13;
#line 190
    goto switch_break;
    case_neg_1: /* CIL Label */ 
    {
#line 192
    log_((char *)"reorder:corrupt index in %s", sp->filename);
    }
#line 193
    goto fail;
    switch_break: /* CIL Label */ ;
    }
#line 173
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 195
  i = 0;
  {
#line 195
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 195
    if (! (i < 10)) {
#line 195
      goto while_break___2;
    }
#line 197
    if (-1 == f___9.info[i].boffset) {
#line 198
      goto __Cont;
    }
    {
#line 199
    tmp___17 = lseek(fd, (__off_t )0, 2);
#line 199
    tmp___16 = (int )tmp___17;
#line 199
    f___9.info[i].boffset = tmp___16;
    }
#line 199
    if (-1 == tmp___16) {
      {
#line 201
      log_((char *)"reorder:lseek(%s):%m", tmpname);
      }
#line 202
      goto fail;
    }
    {
#line 204
    er = copyart___8(fd, sp->fd, (sp->file)->info[i].boffset, f___9.info[i].blen);
    }
#line 205
    if (-1 == er) {
#line 206
      goto fail;
    }
    __Cont: /* CIL Label */ 
#line 195
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 209
  tmp___18 = lseek(fd, (__off_t )0, 0);
  }
#line 209
  if (-1L == tmp___18) {
    {
#line 211
    log_((char *)"reorder:lseek:%m");
    }
#line 212
    goto fail;
  }
  {
#line 214
  tmp___19 = nosigio___8((ssize_t (*)())(& write), fd, (char *)(& f___9), (int )sizeof(f___9));
  }
#line 214
  if (-1 == tmp___19) {
#line 215
    goto fail;
  }
  {
#line 216
  tmp___20 = rename((char const   *)(tmpname), (char const   *)sp->filename);
  }
#line 216
  if (-1 == tmp___20) {
    {
#line 218
    log_((char *)"reorder:rename:%m");
    }
#line 219
    goto fail;
  }
  {
#line 221
  close(fd);
  }
#line 222
  return;
  fail: 
  {
#line 225
  log_((char *)"reorder:write failed for %s:%m", sp->filename);
#line 226
  tmp___21 = unlink((char const   *)(tmpname));
  }
#line 226
  if (-1 == tmp___21) {
    {
#line 227
    log_((char *)"reorder:unlink(%s):%m", tmpname);
    }
  }
  {
#line 228
  close(fd);
  }
#line 229
  return;
}
}
#line 231 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/store.c"
static void sto_free___8(void *p ) 
{ 
  struct storeobj *sp ;
  int tmp ;

  {
  {
#line 233
  sp = (struct storeobj *)p;
#line 235
  close(sp->fd);
#line 236
  tmp = munmap((void *)((caddr_t )sp->file), sizeof(struct file ));
  }
#line 236
  if (-1 == tmp) {
    {
#line 237
    log_((char *)"sto_free:munmap:%m");
    }
  }
  {
#line 238
  free((void *)sp);
  }
#line 239
  return;
}
}
#line 241 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/store.c"
static int desc___32  ;
#line 304
static int tryopen___8(char *fn ) ;
#line 304 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/store.c"
static struct file f___8  =    {1027296, {{0, 0, 0, 0}}};
#line 270 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/store.c"
static int tryopen___8(char *fn ) 
{ 
  char fn2[287] ;
  int fd ;
  int i ;
  char *p ;
  char *q ;
  struct timeval tv ;
  char *tmp ;
  char tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  ssize_t tmp___7 ;

  {
  {
#line 278
  fd = open((char const   *)fn, 2);
  }
#line 278
  if (fd > -1) {
    {
#line 280
    lockf(fd, 1, (__off_t )0);
    }
#line 281
    return (fd);
  }
#line 283
  p = fn2;
#line 283
  q = fn;
  {
#line 283
  while (1) {
    while_continue: /* CIL Label */ ;
#line 283
    tmp = p;
#line 283
    p ++;
#line 283
    tmp___1 = q;
#line 283
    q ++;
#line 283
    tmp___0 = *tmp___1;
#line 283
    *tmp = tmp___0;
#line 283
    if (! ((int )tmp___0 != 47)) {
#line 283
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 284
  tmp___2 = p;
#line 284
  p ++;
#line 284
  *tmp___2 = (char )'+';
#line 285
  tmp___3 = p;
#line 285
  p ++;
#line 285
  *tmp___3 = (char )'+';
#line 286
  gettimeofday((struct timeval */* __restrict  */)(& tv), (__timezone_ptr_t )0);
#line 296
  i = (int )(tv.tv_sec / 30L);
  }
  {
#line 297
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 298
    tmp___4 = p;
#line 298
    p ++;
#line 298
    *tmp___4 = (char )(48 + i % 10);
#line 297
    i /= 10;
#line 297
    if (! i) {
#line 297
      goto while_break___0;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 300
  tmp___5 = p;
#line 300
  p ++;
#line 300
  *tmp___5 = (char )'\000';
#line 302
  i = 0;
  {
#line 302
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 302
    if (! (i < 100)) {
#line 302
      goto while_break___1;
    }
#line 306
    if (14 == i % 15) {
      {
#line 307
      log_((char *)"tryopen:racing on %s", fn);
      }
    }
    {
#line 308
    fd = open((char const   *)(fn2), 194, 420);
    }
#line 308
    if (fd > -1) {
      {
#line 310
      lockf(fd, 1, (__off_t )0);
#line 311
      tmp___7 = write(fd, (void const   *)((char *)(& f___8)), sizeof(f___8));
      }
#line 311
      if (sizeof(f___8) == (unsigned long )tmp___7) {
        {
#line 312
        tmp___6 = link((char const   *)(fn2), (char const   *)fn);
        }
#line 312
        if (0 == tmp___6) {
          {
#line 314
          unlink((char const   *)(fn2));
          }
#line 315
          return (fd);
        }
      }
      {
#line 317
      close(fd);
#line 318
      unlink((char const   *)(fn2));
      }
    }
    {
#line 321
    fd = open((char const   *)fn, 2);
    }
#line 321
    if (fd > -1) {
      {
#line 323
      lockf(fd, 1, (__off_t )0);
      }
#line 324
      return (fd);
    }
    {
#line 302
    nap(0, 300 + i);
#line 302
    i ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 327
  log_((char *)"tryopen:timed out opening %s:%m", fn);
  }
#line 328
  return (-1);
}
}
#line 337 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/store.c"
static struct storeobj *getstore___8(char *filename ) 
{ 
  struct storeobj *sp ;
  struct storeobj s ;
  int fd ;
  struct file *fp ;
  char buf___28[287] ;
  int c ;
  void *tmp ;
  void *tmp___0 ;
  char *p ;
  char *q ;
  char *tmp___1 ;
  char tmp___2 ;
  char *tmp___3 ;
  char *end ;
  unsigned long tmp___4 ;
  ssize_t tmp___5 ;
  size_t tmp___6 ;
  void *tmp___7 ;

  {
  {
#line 349
  s.filename = filename;
#line 350
  tmp = cache_find(desc___32, (void *)(& s));
#line 350
  sp = (struct storeobj *)tmp;
  }
#line 350
  if (sp) {
    {
#line 352
    lockf(sp->fd, 1, (__off_t )0);
    }
#line 353
    return (sp);
  }
  {
#line 356
  fd = tryopen___8(filename);
  }
#line 356
  if (-1 == fd) {
#line 357
    return ((struct storeobj *)0);
  }
  {
#line 361
  tmp___0 = mmap((void *)0, sizeof(*fp), 3, 1, fd, (__off_t )0);
#line 361
  fp = (struct file *)tmp___0;
  }
#line 362
  if (! fp) {
    {
#line 363
    log_((char *)"getstore:mmap(%s):%m", filename);
    }
  } else
#line 362
  if ((unsigned long )fp == (unsigned long )((void *)-1)) {
    {
#line 363
    log_((char *)"getstore:mmap(%s):%m", filename);
    }
  } else {
    {
#line 364
    tmp___6 = strlen((char const   *)filename);
#line 364
    tmp___7 = malloc((sizeof(*sp) + tmp___6) + 1UL);
#line 364
    sp = (struct storeobj *)tmp___7;
    }
#line 364
    if (sp) {
      {
#line 371
      sp->fd = fd;
#line 372
      sp->file = fp;
#line 373
      sp->filename = (char *)sp + sizeof(*sp);
#line 374
      strcpy((char */* __restrict  */)sp->filename, (char const   */* __restrict  */)filename);
#line 380
      p = buf___28;
#line 380
      q = filename;
      }
      {
#line 380
      while (1) {
        while_continue: /* CIL Label */ ;
#line 380
        tmp___1 = p;
#line 380
        p ++;
#line 380
        tmp___3 = q;
#line 380
        q ++;
#line 380
        tmp___2 = *tmp___3;
#line 380
        *tmp___1 = tmp___2;
#line 380
        if (! ((int )tmp___2 != 47)) {
#line 380
          goto while_break;
        }
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 381
      strcpy((char */* __restrict  */)p, (char const   */* __restrict  */)".compress");
#line 383
      fd = open((char const   *)(buf___28), 0);
      }
#line 383
      if (fd > -1) {
        {
#line 385
        sp->compressok = 1024;
#line 386
        tmp___5 = read(fd, (void *)(buf___28), sizeof(buf___28) - 1UL);
#line 386
        c = (int )tmp___5;
        }
#line 386
        if (c > 0) {
          {
#line 390
          buf___28[c] = (char )'\000';
#line 391
          tmp___4 = strtoul((char const   */* __restrict  */)(buf___28), (char **/* __restrict  */)(& end),
                            10);
#line 391
          c = (int )tmp___4;
          }
#line 392
          if (c > 1024) {
#line 392
            if (10 == (int )*end) {
#line 393
              sp->compressok = c;
            }
          }
        }
        {
#line 395
        close(fd);
        }
      } else {
#line 399
        sp->compressok = 0;
      }
      {
#line 400
      cache_insert(desc___32, (void *)sp);
      }
#line 401
      return (sp);
    } else {
      {
#line 366
      log_((char *)"getstore:no memory");
#line 367
      munmap((void *)fp, sizeof(*fp));
      }
    }
  }
  {
#line 403
  close(fd);
  }
#line 404
  return ((struct storeobj *)0);
}
}
#line 37 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/group.c"
static int desc___33  =    -1;
#line 59 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/group.c"
static int cmpgroup___11(void *a , void *b___13 ) 
{ 
  struct groupobj *x ;
  struct groupobj *y ;
  int tmp ;

  {
  {
#line 61
  x = (struct groupobj *)a;
#line 62
  y = (struct groupobj *)b___13;
#line 64
  tmp = strcmp((char const   *)x->groupname, (char const   *)y->groupname);
  }
#line 64
  return (tmp);
}
}
#line 67 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/group.c"
static void freegroup___11(void *p ) 
{ 
  struct groupobj *gop ;

  {
#line 69
  gop = (struct groupobj *)p;
#line 71
  if (gop->groupname) {
    {
#line 72
    free((void *)gop->groupname);
    }
  }
#line 73
  if (gop->dir.dir) {
    {
#line 74
    closedir(gop->dir.dir);
    }
  }
#line 75
  if (gop->lastf.f) {
    {
#line 76
    munmap((void *)((caddr_t )gop->lastf.f), sizeof(struct file ));
    }
  }
  {
#line 77
  free(p);
  }
#line 78
  return;
}
}
#line 94 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/group.c"
static int refresh___11(struct groupobj *gop , char *groupname ) 
{ 
  struct stat st ;
  struct dir *d ;
  struct lastf *lp ;
  bool needreread ;
  bool needrefile ;
  bool needreslot ;
  bool isemptygroup ;
  int tmp ;
  int tmp___0 ;
  struct dirent *dp ;
  int i ;
  int first ;
  int last___1 ;
  char *end ;
  int tmp___1 ;
  unsigned short const   **tmp___2 ;
  unsigned long tmp___3 ;
  int fd ;
  void *tmp___4 ;
  struct info *ip ;
  int slot ;

  {
#line 99
  needreread = (bool )0;
#line 100
  needrefile = (bool )0;
#line 101
  needreslot = (bool )0;
#line 102
  isemptygroup = (bool )0;
#line 104
  d = & gop->dir;
#line 105
  lp = & gop->lastf;
#line 107
  if (groupname) {
    {
#line 109
    memset((void *)gop, 0, sizeof(struct groupobj ));
#line 110
    gop->groupname = strdup((char const   *)groupname);
    }
#line 111
    if ((unsigned long )((void *)0) == (unsigned long )gop->groupname) {
      {
#line 113
      log_((char *)"refresh:strdup:%m");
      }
#line 114
      return (-1);
    }
    {
#line 116
    gop->dir.first = -1;
#line 117
    d->dir = opendir((char const   *)groupname);
    }
#line 118
    if ((unsigned long )((void *)0) == (unsigned long )d->dir) {
      {
#line 120
      log_((char *)"refresh:opendir:%m");
      }
#line 121
      return (-1);
    }
#line 123
    lp->name = -1;
#line 125
    needreslot = (bool )1;
#line 125
    needreread = needreslot;
#line 125
    needrefile = needreread;
  } else {
#line 131
    if (-1 == d->first) {
#line 132
      needreread = (bool )1;
    } else
#line 131
    if (0 == d->last) {
#line 132
      needreread = (bool )1;
    } else
#line 131
    if (! d->read) {
#line 132
      needreread = (bool )1;
    } else {
      {
#line 133
      tmp = dirfd(d->dir);
#line 133
      tmp___0 = fstat(tmp, & st);
      }
#line 133
      if (-1 == tmp___0) {
        {
#line 135
        log_((char *)"refresh:fstat:%m");
        }
#line 136
        return (-1);
      } else
#line 138
      if (d->read < st.st_mtim.tv_sec) {
#line 139
        needreread = (bool )1;
      }
    }
#line 140
    if (! lp->f) {
#line 141
      needreslot = (bool )1;
#line 141
      needrefile = needreslot;
    }
#line 142
    if (! needrefile) {
#line 143
      if (! lp->f) {
#line 144
        needrefile = (bool )1;
      }
    }
#line 145
    if (! needrefile) {
#line 146
      if (-1 == lp->name) {
#line 147
        needrefile = (bool )1;
      }
    }
  }
#line 150
  if (needreread) {
#line 150
    goto _L;
  } else
#line 150
  if (needreslot) {
    _L: /* CIL Label */ 
    {
#line 156
    first = -1;
#line 157
    last___1 = 0;
#line 158
    rewinddir(d->dir);
#line 159
    dp = readdir(d->dir);
    }
#line 160
    if ((unsigned long )((void *)0) == (unsigned long )dp) {
      {
#line 162
      log_((char *)"refresh:readdir:%m");
      }
#line 163
      return (-1);
    }
#line 165
    gop->nopost = (bool )0;
    {
#line 166
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 168
      tmp___2 = __ctype_b_loc();
      }
#line 168
      if (! ((int const   )*(*tmp___2 + (int )dp->d_name[0]) & 2048)) {
#line 170
        if (! gop->nopost) {
#line 170
          if (46 == (int )dp->d_name[0]) {
            {
#line 171
            tmp___1 = strcmp((char const   *)(dp->d_name), ".nopost");
            }
#line 171
            if (0 == tmp___1) {
#line 172
              gop->nopost = (bool )1;
            }
          }
        }
#line 173
        goto __Cont;
      }
      {
#line 175
      tmp___3 = strtoul((char const   */* __restrict  */)(dp->d_name), (char **/* __restrict  */)(& end),
                        10);
#line 175
      i = (int )tmp___3;
      }
#line 175
      if (i <= 0) {
#line 176
        goto __Cont;
      } else
#line 175
      if (*end) {
#line 176
        goto __Cont;
      }
#line 177
      if (first > i) {
#line 178
        first = i;
      } else
#line 177
      if (-1 == first) {
#line 178
        first = i;
      }
#line 179
      if (last___1 < i) {
#line 180
        last___1 = i;
      }
      __Cont: /* CIL Label */ 
      {
#line 166
      dp = readdir(d->dir);
      }
#line 166
      if (! dp) {
#line 166
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 183
    d->first = first;
#line 184
    d->last = last___1;
#line 185
    if (-1 == first) {
#line 185
      if (0 == last___1) {
#line 186
        isemptygroup = (bool )1;
      }
    }
#line 187
    if (last___1 != lp->name) {
#line 188
      needrefile = (bool )1;
    } else {
#line 190
      lp->name = last___1;
    }
    {
#line 191
    time(& d->read);
    }
  }
#line 194
  if (needrefile) {
#line 194
    goto _L___0;
  } else
#line 194
  if (needreslot) {
    _L___0: /* CIL Label */ 
#line 198
    if (lp->f) {
      {
#line 200
      munmap((void *)((caddr_t )lp->f), sizeof(struct file ));
#line 201
      lp->f = (struct file *)((void *)0);
      }
    }
#line 203
    if (isemptygroup) {
#line 204
      return (0);
    }
    {
#line 205
    fd = openf(0, 0, (char *)"%s/%d", gop->groupname, d->last);
    }
#line 206
    if (-1 == fd) {
      {
#line 208
      log_((char *)"refresh:open:%m");
      }
#line 209
      return (-1);
    }
    {
#line 211
    tmp___4 = mmap((void *)0, sizeof(struct file ), 1, 1, fd, (__off_t )0);
#line 211
    lp->f = (struct file *)tmp___4;
#line 212
    close(fd);
    }
#line 213
    if ((unsigned long )lp->f == (unsigned long )((void *)-1)) {
      {
#line 215
      log_((char *)"refresh:mmap:%m");
      }
#line 216
      return (-1);
    }
#line 218
    lp->slotsfilled = 0;
#line 219
    needreslot = (bool )1;
  }
#line 222
  if (needreslot) {
#line 224
    ip = (lp->f)->info;
#line 227
    slot = 9;
    {
#line 227
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 227
      if (! (slot > -1)) {
#line 227
        goto while_break___0;
      }
#line 228
      if ((ip + slot)->hoffset) {
#line 229
        goto while_break___0;
      }
#line 227
      slot --;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 230
    lp->slotsfilled = slot + 1;
  }
#line 233
  return (0);
}
}
#line 33 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/art.c"
static size_t pagesize___35  =    (size_t )0;
#line 80 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/art.c"
static void file_unmap___11(void *p ) 
{ 
  struct fileobj *fp ;

  {
  {
#line 82
  fp = (struct fileobj *)p;
#line 84
  munmap((void *)fp->map, (size_t )fp->size);
#line 85
  free((void *)fp);
  }
#line 86
  return;
}
}
#line 88 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/art.c"
static int file_cmp___11(void *a , void *b___13 ) 
{ 
  struct fileobj *x ;
  struct fileobj *y ;
  int tmp ;

  {
  {
#line 90
  x = (struct fileobj *)a;
#line 91
  y = (struct fileobj *)b___13;
#line 93
  tmp = strcmp((char const   *)x->path, (char const   *)y->path);
  }
#line 93
  return (tmp);
}
}
#line 96 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/art.c"
static int desc___34  =    -1;
#line 98 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/art.c"
static int file_init___11(void) 
{ 


  {
  {
#line 100
  desc___34 = cache_init(8, & file_cmp___11, & file_unmap___11, (int (*)(void * ))((void *)0));
  }
#line 101
  if (-1 == desc___34) {
    {
#line 103
    log_((char *)"file_init:%m");
    }
#line 104
    return (-1);
  }
#line 106
  return (0);
}
}
#line 109 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/art.c"
static struct file *file_gimme___11(char *name , int *size___1 ) 
{ 
  struct fileobj f___9 ;
  struct fileobj *fp ;
  void *tmp ;

  {
  {
#line 111
  f___9.path = (char *)0;
#line 111
  f___9.map = (char *)0;
#line 111
  f___9.size = 0;
#line 114
  f___9.path = name;
#line 116
  tmp = cache_find(desc___34, (void *)(& f___9));
#line 116
  fp = (struct fileobj *)tmp;
  }
#line 116
  if ((unsigned long )((void *)0) == (unsigned long )fp) {
    {
#line 118
    fp = file_map(name);
    }
#line 118
    if ((unsigned long )((void *)0) == (unsigned long )fp) {
#line 119
      return ((struct file *)((void *)0));
    } else {
      {
#line 121
      cache_insert(desc___34, (void *)fp);
      }
    }
  }
#line 124
  if (size___1) {
#line 125
    *size___1 = fp->size;
  }
#line 126
  return ((struct file *)fp->map);
}
}
#line 137 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/art.c"
static bool file_initialized___11  =    (bool )0;
#line 248 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/art.c"
static char ngroup___11[287]  ;
#line 297 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/art.c"
static int getfield___11(char *buf___28 , struct field *f___9 ) 
{ 
  register char *cp ;
  size_t tmp ;
  size_t tmp___0 ;

  {
  {
#line 299
  cp = buf___28;
#line 301
  tmp = strspn((char const   *)cp, " \t\f");
#line 301
  cp += tmp;
  }
#line 302
  if (! *cp) {
#line 304
    f___9->pointer = (char *)((void *)0);
#line 305
    return (0);
  }
  {
#line 307
  tmp___0 = strcspn((char const   *)cp, "\r\n");
#line 307
  f___9->len = (int )tmp___0;
  }
#line 308
  if (! f___9->len) {
#line 309
    return (0);
  }
#line 310
  f___9->pointer = cp;
#line 311
  return ((int )((cp + f___9->len) - buf___28));
}
}
#line 383 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/art.c"
static struct b b___12  =    {(char *)0, 0, 0};
#line 105 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/dh_find.c"
static int initfile___23(void) 
{ 
  int fd ;
  int integer ;
  int i ;
  char foo[3] ;
  unsigned int tmp ;
  int *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  ssize_t tmp___3 ;
  ssize_t tmp___4 ;

  {
#line 108
  integer = 218885376;
#line 110
  foo[0] = (char )'\000';
#line 110
  tmp = 1U;
  {
#line 110
  while (1) {
    while_continue: /* CIL Label */ ;
#line 110
    if (tmp >= 3U) {
#line 110
      goto while_break;
    }
#line 110
    foo[tmp] = (char)0;
#line 110
    tmp ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 112
  fd = open((char const   *)(dh_tablefile), 194, 420);
  }
#line 113
  if (fd == -1) {
#line 114
    return (-1);
  }
  {
#line 115
  tmp___2 = lockf(fd, 2, (__off_t )0);
  }
#line 115
  if (tmp___2 == -1) {
    {
#line 117
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 119
      tmp___0 = __errno_location();
      }
#line 119
      if (*tmp___0 == 11) {
        {
#line 120
        nap(0, 200);
        }
      } else {
#line 122
        goto fail;
      }
      {
#line 117
      tmp___1 = lockf(fd, 2, (__off_t )0);
      }
#line 117
      if (! (tmp___1 == -1)) {
#line 117
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 125
    lockf(fd, 0, (__off_t )0);
    }
#line 126
    return (fd);
  }
  {
#line 128
  tmp___3 = write(fd, (void const   *)(& integer), sizeof(int ));
  }
#line 128
  if ((unsigned long )tmp___3 != sizeof(int )) {
#line 129
    goto fail;
  }
#line 130
  i = 0;
  {
#line 130
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 130
    if (! (i < 10240)) {
#line 130
      goto while_break___1;
    }
    {
#line 131
    tmp___4 = write(fd, (void const   *)(foo), sizeof(foo));
    }
#line 131
    if ((unsigned long )tmp___4 != sizeof(foo)) {
#line 132
      goto fail;
    }
#line 130
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 133
  lseek(fd, (__off_t )0, 0);
#line 134
  lockf(fd, 0, (__off_t )0);
  }
#line 135
  return (fd);
  fail: 
#line 138
  if (fd > -1) {
    {
#line 139
    close(fd);
    }
  }
#line 140
  return (-1);
}
}
#line 78 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/allocate.c"
static struct table___1 table___12  =    {(char *)0, (char *)0, 0, 0, 0, 0};
#line 80
static int remapfile___11(void) ;
#line 106 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/allocate.c"
static int initfile___24(char *filename ) 
{ 
  struct chainfile cf ;
  int fd ;
  int i ;
  int ret ;
  ssize_t tmp ;
  int pad ;
  ssize_t tmp___0 ;

  {
  {
#line 108
  cf.chain_magic = 0;
#line 108
  cf.next[0] = 0;
#line 108
  cf.next[1] = 0;
#line 108
  cf.next[2] = 0;
#line 108
  cf.next[3] = 0;
#line 108
  cf.next[4] = 0;
#line 108
  cf.next[5] = 0;
#line 108
  cf.next[6] = 0;
#line 108
  cf.next[7] = 0;
#line 108
  cf.next[8] = 0;
#line 108
  cf.next[9] = 0;
#line 108
  cf.next[10] = 0;
#line 108
  cf.next[11] = 0;
#line 108
  cf.next[12] = 0;
#line 108
  cf.next[13] = 0;
#line 108
  cf.next[14] = 0;
#line 108
  cf.next[15] = 0;
#line 108
  cf.next[16] = 0;
#line 108
  cf.next[17] = 0;
#line 108
  cf.next[18] = 0;
#line 108
  cf.next[19] = 0;
#line 108
  cf.next[20] = 0;
#line 108
  cf.next[21] = 0;
#line 108
  cf.next[22] = 0;
#line 108
  cf.next[23] = 0;
#line 108
  cf.next[24] = 0;
#line 108
  cf.next[25] = 0;
#line 108
  cf.next[26] = 0;
#line 108
  cf.next[27] = 0;
#line 108
  cf.next[28] = 0;
#line 108
  cf.next[29] = 0;
#line 108
  cf.next[30] = 0;
#line 108
  cf.next[31] = 0;
#line 108
  cf.next[32] = 0;
#line 108
  cf.next[33] = 0;
#line 108
  cf.next[34] = 0;
#line 108
  cf.next[35] = 0;
#line 108
  cf.next[36] = 0;
#line 108
  cf.next[37] = 0;
#line 108
  cf.next[38] = 0;
#line 108
  cf.next[39] = 0;
#line 108
  cf.next[40] = 0;
#line 108
  cf.next[41] = 0;
#line 108
  cf.next[42] = 0;
#line 108
  cf.next[43] = 0;
#line 108
  cf.next[44] = 0;
#line 108
  cf.next[45] = 0;
#line 108
  cf.next[46] = 0;
#line 108
  cf.next[47] = 0;
#line 108
  cf.next[48] = 0;
#line 108
  cf.next[49] = 0;
#line 108
  cf.next[50] = 0;
#line 108
  cf.next[51] = 0;
#line 108
  cf.next[52] = 0;
#line 108
  cf.next[53] = 0;
#line 108
  cf.next[54] = 0;
#line 108
  cf.next[55] = 0;
#line 108
  cf.next[56] = 0;
#line 108
  cf.next[57] = 0;
#line 108
  cf.next[58] = 0;
#line 108
  cf.next[59] = 0;
#line 108
  cf.next[60] = 0;
#line 108
  cf.next[61] = 0;
#line 108
  cf.next[62] = 0;
#line 111
  ret = 0;
#line 113
  fd = open((char const   *)filename, 578, 420);
  }
#line 114
  if (-1 == fd) {
#line 115
    return (-1);
  }
#line 116
  cf.chain_magic = 13680336;
#line 117
  i = 0;
  {
#line 117
  while (1) {
    while_continue: /* CIL Label */ ;
#line 117
    if (! (i < 63)) {
#line 117
      goto while_break;
    }
#line 118
    cf.next[i] = (int volatile   )0;
#line 117
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 119
  tmp = write(fd, (void const   *)(& cf), sizeof(cf));
#line 119
  i = (int )tmp;
  }
#line 120
  if ((unsigned long )i == sizeof(cf)) {
#line 124
    pad = (int )(sizeof(cf) % 4UL);
#line 125
    if (pad > 0) {
#line 126
      i = 0;
      {
#line 126
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 126
        if (i < pad) {
#line 126
          if (! (0 == ret)) {
#line 126
            goto while_break___0;
          }
        } else {
#line 126
          goto while_break___0;
        }
        {
#line 127
        tmp___0 = write(fd, (void const   *)"", (size_t )1);
        }
#line 127
        if (1L != tmp___0) {
#line 128
          ret = -1;
        }
#line 126
        i ++;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
  } else {
#line 131
    ret = -1;
  }
  {
#line 132
  close(fd);
  }
#line 133
  return (ret);
}
}
#line 136 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/allocate.c"
static void unmapfile___11(void) 
{ 


  {
#line 138
  if (table___12.fd >= 0) {
    {
#line 140
    close(table___12.fd);
#line 141
    table___12.fd = -1;
    }
  }
#line 143
  if (table___12.map) {
    {
#line 145
    munmap((void *)table___12.map, (size_t )table___12.size);
#line 146
    table___12.map = (char *)((void *)0);
#line 147
    table___12.size = 0;
    }
  }
#line 149
  return;
}
}
#line 153
static size_t rounduptopagesize___11(size_t size___1 ) ;
#line 153 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/allocate.c"
static size_t pagesize___36  =    (size_t )0;
#line 151 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/allocate.c"
static size_t rounduptopagesize___11(size_t size___1 ) 
{ 
  int pages ;
  int tmp ;

  {
#line 156
  if (0UL == pagesize___36) {
    {
#line 157
    tmp = getpagesize();
#line 157
    pagesize___36 = (size_t )tmp;
    }
  }
#line 158
  pages = (int )(size___1 / pagesize___36 + 1UL);
#line 159
  return ((size_t )pages * pagesize___36);
}
}
#line 162 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/allocate.c"
static int mapfile___11(void) 
{ 
  struct stat st ;
  int tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;

  {
#line 166
  if (-1 == table___12.fd) {
    {
#line 167
    table___12.fd = open((char const   *)table___12.filename, table___12.oflag, 420);
    }
  }
#line 168
  if (-1 == table___12.fd) {
#line 169
    goto fail;
  }
  {
#line 171
  tmp = fstat(table___12.fd, & st);
  }
#line 171
  if (-1 == tmp) {
#line 172
    goto fail;
  }
  {
#line 173
  tmp___0 = rounduptopagesize___11((size_t )st.st_size);
#line 173
  table___12.size = (int )tmp___0;
#line 174
  tmp___1 = mmap((void *)0, (size_t )table___12.size, table___12.mprot, 1, table___12.fd,
                 (__off_t )0);
#line 174
  table___12.map = (char *)tmp___1;
  }
#line 175
  if (! table___12.map) {
#line 176
    goto fail;
  } else
#line 175
  if ((unsigned long )table___12.map == (unsigned long )((void *)-1)) {
#line 176
    goto fail;
  }
#line 178
  return (0);
  fail: 
  {
#line 181
  unmapfile___11();
  }
#line 182
  return (-1);
}
}
#line 189 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/allocate.c"
static int remapfile___11(void) 
{ 
  struct stat st ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 193
  tmp = fstat(table___12.fd, & st);
  }
#line 193
  if (-1 == tmp) {
#line 194
    return (-1);
  }
#line 196
  if (st.st_size <= (__off_t )table___12.size) {
#line 197
    return (0);
  }
  {
#line 199
  munmap((void *)table___12.map, (size_t )table___12.size);
#line 200
  tmp___0 = mapfile___11();
  }
#line 200
  return (tmp___0);
}
}
#line 209 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/allocate.c"
static int lock___11(void) 
{ 
  int *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 211
  tmp___2 = lockf(table___12.fd, 2, (__off_t )0);
  }
#line 211
  if (-1 == tmp___2) {
    {
#line 213
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 215
      tmp = __errno_location();
      }
#line 215
      if (11 != *tmp) {
#line 216
        return (-1);
      } else {
        {
#line 218
        nap(0, 200);
        }
      }
      {
#line 213
      tmp___0 = lockf(table___12.fd, 2, (__off_t )0);
      }
#line 213
      if (! (-1 == tmp___0)) {
#line 213
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 221
    tmp___1 = remapfile___11();
    }
#line 221
    if (-1 == tmp___1) {
#line 222
      return (-1);
    }
  }
#line 224
  return (0);
}
}
#line 227 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/allocate.c"
static void unlock___11(void) 
{ 


  {
  {
#line 229
  lseek(table___12.fd, (__off_t )0, 0);
#line 230
  lockf(table___12.fd, 0, (__off_t )0);
  }
#line 231
  return;
}
}
#line 233 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/allocate.c"
static int checkvalidfile___11(void) 
{ 


  {
#line 235
  if (table___12.size > 0) {
#line 237
    if ((unsigned long )table___12.size < sizeof(struct chainfile )) {
#line 238
      return (-1);
    }
#line 239
    if (((struct chainfile *)table___12.map)->chain_magic != 13680336) {
#line 240
      return (-1);
    }
  }
#line 242
  return (0);
}
}
#line 281 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/allocate.c"
static int rounduptoalignment___11(int size___1 ) 
{ 


  {
#line 283
  if (size___1 <= 0) {
#line 284
    return (4);
  }
#line 285
  return (((size___1 - 1) / 4 + 1) * 4);
}
}
#line 296 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/allocate.c"
static char tmpchunk___11[272]  = {      (char )'\000'};
#line 56 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/dhash.c"
static unsigned char buf___26[2]  ;
#line 54 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/dhash.c"
static char *inttochar2___11(int integer ) 
{ 


  {
#line 58
  buf___26[0] = (unsigned char )((integer & 65535) >> 8);
#line 59
  buf___26[1] = (unsigned char )(integer & 255);
#line 60
  return ((char *)(buf___26));
}
}
#line 65 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/dhash.c"
static unsigned char buf___27[3]  ;
#line 63 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/dhash.c"
static char *inttochar3___11(unsigned int integer ) 
{ 


  {
#line 67
  integer >>= 2;
#line 68
  buf___27[0] = (unsigned char )((integer & 16777215U) >> 16);
#line 69
  buf___27[1] = (unsigned char )((integer & 65535U) >> 8);
#line 70
  buf___27[2] = (unsigned char )(integer & 255U);
#line 71
  return ((char *)(buf___27));
}
}
#line 35 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/newsgroup.c"
static struct ng *bygroup___11[128]  ;
#line 36 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/newsgroup.c"
static struct ng *byident___11[128]  ;
#line 37 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/newsgroup.c"
static int highest___11  =    0;
#line 39 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/newsgroup.c"
static unsigned int hash___23(char *buf___28 , int len ) 
{ 
  unsigned int h ;
  char *tmp ;

  {
#line 43
  h = 5381U;
  {
#line 44
  while (1) {
    while_continue: /* CIL Label */ ;
#line 44
    if (! len) {
#line 44
      goto while_break;
    }
#line 46
    len --;
#line 47
    h += h << 5;
#line 48
    tmp = buf___28;
#line 48
    buf___28 ++;
#line 48
    h ^= (unsigned int )*tmp;
  }
  while_break: /* CIL Label */ ;
  }
#line 50
  return (h);
}
}
#line 53 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/newsgroup.c"
static struct chunk *chunks___11  ;
#line 58 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/newsgroup.c"
static int avail___23  =    0;
#line 59 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/newsgroup.c"
static int nr___12  =    0;
#line 64 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/newsgroup.c"
static int add___12(int ident , char *group , int len ) 
{ 
  struct ng *np ;
  struct ng *p ;
  int want ;
  unsigned int h ;
  struct chunk *tmp ;
  int size___1 ;
  void *tmp___0 ;
  unsigned int tmp___1 ;
  int tmp___2 ;

  {
#line 71
  len ++;
#line 72
  want = (int )(((unsigned long )len + sizeof(struct ng )) + sizeof(char *));
#line 73
  want = (int )((unsigned long )want - (unsigned long )len % sizeof(char *));
#line 74
  len --;
#line 76
  if (avail___23 < want) {
#line 81
    if (want > 240) {
#line 81
      size___1 = want + 240;
    } else {
#line 81
      size___1 = 240;
    }
    {
#line 82
    tmp___0 = malloc((size_t )size___1);
#line 82
    tmp = (struct chunk *)tmp___0;
    }
#line 82
    if (! tmp) {
#line 83
      return (-1);
    }
#line 84
    tmp->next = chunks___11;
#line 85
    chunks___11 = tmp;
#line 86
    chunks___11->buf = (char *)chunks___11 + sizeof(struct chunk );
#line 87
    avail___23 = (int )((unsigned long )size___1 - sizeof(struct chunk ));
  }
  {
#line 89
  np = (struct ng *)chunks___11->buf;
#line 90
  chunks___11->buf += want;
#line 91
  avail___23 -= want;
#line 92
  strncpy((char */* __restrict  */)(np->group), (char const   */* __restrict  */)group,
          (size_t )len);
#line 93
  np->group[len] = (char )'\000';
#line 94
  np->ident = ident;
#line 96
  tmp___1 = hash___23(group, len);
#line 96
  h = tmp___1 % 128U;
#line 97
  np->gnext = bygroup___11[h];
#line 98
  bygroup___11[h] = np;
#line 99
  p = np->gnext;
  }
  {
#line 99
  while (1) {
    while_continue: /* CIL Label */ ;
#line 99
    if (! p) {
#line 99
      goto while_break;
    }
    {
#line 100
    tmp___2 = strcmp((char const   *)(p->group), (char const   *)group);
    }
#line 100
    if (0 == tmp___2) {
#line 101
      return (1);
    }
#line 99
    p = p->gnext;
  }
  while_break: /* CIL Label */ ;
  }
#line 102
  h = (unsigned int )(ident % 128);
#line 103
  np->inext = byident___11[h];
#line 104
  byident___11[h] = np;
#line 105
  p = np->inext;
  {
#line 105
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 105
    if (! p) {
#line 105
      goto while_break___0;
    }
#line 106
    if (p->ident == ident) {
#line 107
      return (1);
    }
#line 105
    p = p->inext;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 109
  if (ident > highest___11) {
#line 110
    highest___11 = ident;
  }
#line 111
  nr___12 ++;
#line 112
  return (0);
}
}
#line 116 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/newsgroup.c"
static int groupfd___11  =    -1;
#line 117 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/newsgroup.c"
static int oldsize___11  =    0;
#line 118 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/newsgroup.c"
static int mapsize___11  =    0;
#line 119 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/newsgroup.c"
static char *mapbuf___11  =    (char *)((void *)0);
#line 148
static int reload___11(void) ;
#line 148 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/newsgroup.c"
static int pagesize___37  =    0;
#line 145 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/newsgroup.c"
static int reload___11(void) 
{ 
  struct stat st ;
  int newsize ;
  int tmp ;
  void *tmp___0 ;
  char *p ;
  char *lim ;
  char *ip ;
  char *gr ;
  int ident ;
  int state ;
  int tmp___1 ;

  {
  {
#line 156
  tmp = fstat(groupfd___11, & st);
  }
#line 156
  if (-1 == tmp) {
    {
#line 158
    log_((char *)"reload:fstat:%m");
    }
#line 159
    return (-1);
  }
#line 161
  newsize = (int )st.st_size;
#line 162
  if (! pagesize___37) {
    {
#line 163
    pagesize___37 = getpagesize();
    }
  }
#line 164
  if (newsize <= oldsize___11) {
#line 165
    return (0);
  }
#line 166
  if (newsize > mapsize___11) {
#line 166
    goto _L;
  } else
#line 166
  if (! mapsize___11) {
    _L: /* CIL Label */ 
#line 168
    if (mapbuf___11) {
      {
#line 169
      munmap((void *)mapbuf___11, (size_t )mapsize___11);
      }
    }
    {
#line 170
    mapsize___11 = (int )((st.st_size + (__off_t )pagesize___37) - st.st_size % (long )pagesize___37);
#line 171
    tmp___0 = mmap((void *)0, (size_t )mapsize___11, 1, 1, groupfd___11, (__off_t )0);
#line 171
    mapbuf___11 = (char *)tmp___0;
    }
#line 172
    if (! mapbuf___11) {
      {
#line 174
      log_((char *)"reload:mmap:%m");
      }
#line 175
      return (-1);
    } else
#line 172
    if ((unsigned long )mapbuf___11 == (unsigned long )((void *)-1)) {
      {
#line 174
      log_((char *)"reload:mmap:%m");
      }
#line 175
      return (-1);
    }
  }
#line 188
  lim = mapbuf___11 + newsize;
#line 189
  state = 0;
#line 189
  ident = state;
#line 190
  gr = (char *)0;
#line 190
  ip = gr;
#line 191
  p = mapbuf___11 + oldsize___11;
  {
#line 191
  while (1) {
    while_continue: /* CIL Label */ ;
#line 191
    if (! ((unsigned long )p < (unsigned long )lim)) {
#line 191
      goto while_break;
    }
    {
#line 194
    if (state == 0) {
#line 194
      goto case_0;
    }
#line 195
    if (state == 1) {
#line 195
      goto case_1;
    }
#line 196
    if (state == 2) {
#line 196
      goto case_2;
    }
#line 197
    if (state == 3) {
#line 197
      goto case_3;
    }
#line 192
    goto switch_break;
    case_0: /* CIL Label */ 
#line 194
    if ((int )*p >= 48) {
#line 194
      if ((int )*p <= 57) {
#line 194
        ip = p;
#line 194
        state ++;
      }
    }
#line 194
    goto switch_break;
    case_1: /* CIL Label */ 
#line 195
    if (32 == (int )*p) {
      {
#line 195
      ident = atoi((char const   *)ip);
#line 195
      state ++;
      }
    }
#line 195
    goto switch_break;
    case_2: /* CIL Label */ 
#line 196
    if (32 != (int )*p) {
#line 196
      gr = p;
#line 196
      state ++;
    }
#line 196
    goto switch_break;
    case_3: /* CIL Label */ 
#line 198
    if (10 != (int )*p) {
#line 199
      goto switch_break;
    }
    {
#line 200
    tmp___1 = add___12(ident, gr, (int )(p - gr));
    }
#line 200
    if (-1 == tmp___1) {
      {
#line 202
      log_((char *)"reload:no memory");
      }
#line 203
      return (-1);
    }
#line 205
    state = 0;
    switch_break: /* CIL Label */ ;
    }
#line 191
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 208
  oldsize___11 = newsize;
#line 209
  return (0);
}
}
#line 26 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/key.c"
static struct buf *head___13  ;
#line 27 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/key.c"
static int avail___24  =    0;
#line 28 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/key.c"
static char *keybuf___11  =    (char *)((void *)0);
#line 33 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/key.c"
static unsigned int hv___11  ;
#line 35 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/key.c"
static void hash___24(char *key , int len ) 
{ 
  char *tmp ;

  {
#line 37
  hv___11 = 5381U;
  {
#line 38
  while (1) {
    while_continue: /* CIL Label */ ;
#line 38
    if (! len) {
#line 38
      goto while_break;
    }
#line 40
    len --;
#line 41
    hv___11 += hv___11 << 5;
#line 42
    tmp = key;
#line 42
    key ++;
#line 42
    hv___11 ^= (unsigned int )*tmp;
  }
  while_break: /* CIL Label */ ;
  }
#line 44
  hv___11 %= 128U;
#line 45
  return;
}
}
#line 26 "/home/june/repo/benchmarks/collector/temp/sn-0.3.8/body.c"
static char *bodbuf___11  =    (char *)((void *)0);
