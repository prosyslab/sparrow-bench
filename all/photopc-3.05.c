/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 124 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __dev_t;
#line 125 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uid_t;
#line 126 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __gid_t;
#line 127 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __ino_t;
#line 129 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __mode_t;
#line 130 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __nlink_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 153 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blksize_t;
#line 158 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blkcnt_t;
#line 175 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __syscall_slong_t;
#line 75 "/usr/include/time.h"
typedef __time_t time_t;
#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 120 "/usr/include/time.h"
struct timespec {
   __time_t tv_sec ;
   __syscall_slong_t tv_nsec ;
};
#line 46 "/usr/include/x86_64-linux-gnu/bits/stat.h"
struct stat {
   __dev_t st_dev ;
   __ino_t st_ino ;
   __nlink_t st_nlink ;
   __mode_t st_mode ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   int __pad0 ;
   __dev_t st_rdev ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   __syscall_slong_t __glibc_reserved[3] ;
};
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 133 "/usr/include/time.h"
struct tm {
   int tm_sec ;
   int tm_min ;
   int tm_hour ;
   int tm_mday ;
   int tm_mon ;
   int tm_year ;
   int tm_wday ;
   int tm_yday ;
   int tm_isdst ;
   long tm_gmtoff ;
   char const   *tm_zone ;
};
#line 162 "/home/wheatley/newnew/temp/photopc-3.05/fnames.c"
enum __anonenum_state_18 {
    deflt = 0,
    escaped = 1,
    pc1 = 2,
    pc2 = 3,
    digit = 4
} ;
#line 86 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __off_t off_t;
#line 37 "/usr/include/utime.h"
struct utimbuf {
   __time_t actime ;
   __time_t modtime ;
};
#line 133 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __pid_t;
#line 72 "/usr/include/x86_64-linux-gnu/bits/sched.h"
struct sched_param {
   int __sched_priority ;
};
#line 48 "/usr/include/x86_64-linux-gnu/sys/utsname.h"
struct utsname {
   char sysname[65] ;
   char nodename[65] ;
   char release[65] ;
   char version[65] ;
   char machine[65] ;
   char __domainname[65] ;
};
#line 23 "/usr/include/x86_64-linux-gnu/bits/termios.h"
typedef unsigned char cc_t;
#line 24 "/usr/include/x86_64-linux-gnu/bits/termios.h"
typedef unsigned int speed_t;
#line 25 "/usr/include/x86_64-linux-gnu/bits/termios.h"
typedef unsigned int tcflag_t;
#line 28 "/usr/include/x86_64-linux-gnu/bits/termios.h"
struct termios {
   tcflag_t c_iflag ;
   tcflag_t c_oflag ;
   tcflag_t c_cflag ;
   tcflag_t c_lflag ;
   cc_t c_line ;
   cc_t c_cc[32] ;
   speed_t c_ispeed ;
   speed_t c_ospeed ;
};
#line 96 "/home/wheatley/newnew/temp/photopc-3.05/eph_io.h"
struct _eph_iob {
   void (*errorcb)(int errcode , char *errstr ) ;
   void *(*realloccb)(void *old , size_t length ) ;
   void (*runcb)(off_t count ) ;
   int (*storecb)(char *data , size_t size ) ;
   int debug ;
   int fd ;
   struct termios savetios ;
   long timeout ;
};
#line 96 "/home/wheatley/newnew/temp/photopc-3.05/eph_io.h"
typedef struct _eph_iob eph_iob;
#line 2096 "/home/wheatley/newnew/temp/photopc-3.05/photopc.c"
struct _range {
   int max ;
   char *bits ;
};
#line 2096 "/home/wheatley/newnew/temp/photopc-3.05/photopc.c"
typedef struct _range range_t;
#line 2233 "/home/wheatley/newnew/temp/photopc-3.05/photopc.c"
struct _cmdlist {
   char *cmd ;
   int argc ;
   int intvl ;
   int filearg ;
   int (*executor)(eph_iob *iob , int argc , char **argv ) ;
   char *help ;
};
#line 82 "/home/wheatley/newnew/temp/photopc-3.05/exifscan.c"
struct _exifdict {
   int tag ;
   char *name ;
};
#line 231 "/home/wheatley/newnew/temp/photopc-3.05/epinfo.c"
enum __anonenum_fformat_28 {
    NONE = 0,
    APP12 = 1,
    EXIF = 2
} ;
#line 162 "/home/wheatley/newnew/temp/photopc-3.05/fnames.c"
enum __anonenum_state_18___0 {
    deflt___0 = 0,
    escaped___0 = 1,
    pc1___0 = 2,
    pc2___0 = 3,
    digit___0 = 4
} ;
#line 209 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) stat)(char const   * __restrict  __file ,
                                                                                             struct stat * __restrict  __buf ) ;
#line 321
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) mkdir)(char const   *__path ,
                                                                                            __mode_t __mode ) ;
#line 170 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 364
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
#line 205 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__leaf__)) strftime)(char * __restrict  __s ,
                                                                                  size_t __maxsize ,
                                                                                  char const   * __restrict  __format ,
                                                                                  struct tm  const  * __restrict  __tp ) ;
#line 50 "/usr/include/x86_64-linux-gnu/bits/errno.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
#line 38 "/home/wheatley/newnew/temp/photopc-3.05/fnames.h"
void makename(char *fname___0 , int flen , char *filenm , int datatype , time_t pictime ,
              char *nameformat___1 , int usetimezone___1 ) ;
#line 37 "/home/wheatley/newnew/temp/photopc-3.05/ctimez.h"
struct tm *gltimetz(time_t *clock___0 , int usetimezone___1 ) ;
#line 81 "/home/wheatley/newnew/temp/photopc-3.05/fnames.c"
static char *shortcut[3][4]  = { {        (char *)"%m%d_%%03d.jpg",        (char *)"%y%m%d%%02d.jpg",        (char *)"%Y_%m_%d-%H_%M_%S.jpg",        (char *)"%Y/%m/%d/%H_%M_%S.jpg"}, 
   {        (char *)"%m%d-%%03d.jpg",        (char *)"%y%m%d%%02d.jpt",        (char *)"%Y_%m_%d-%H_%M_%S-t.jpg",        (char *)"%Y/%m/%d/%H_%M_%S-t.jpg"}, 
   {        (char *)"%m%d_%%03d.wav",        (char *)"%y%m%d%%02d.wav",        (char *)"%Y_%m_%d-%H_%M_%S.wav",        (char *)"%Y/%m/%d/%H_%M_%S.wav"}};
#line 102 "/home/wheatley/newnew/temp/photopc-3.05/fnames.c"
static int ftype  =    0;
#line 117
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 104 "/home/wheatley/newnew/temp/photopc-3.05/fnames.c"
void makename(char *fname___0 , int flen , char *filenm , int datatype , time_t pictime ,
              char *nameformat___1 , int usetimezone___1 ) 
{ 
  int count___0 ;
  struct stat st ;
  struct tm *pictm ;
  int hascount ;
  int width ;
  int maxcount ;
  char *ifslash ;
  char *p ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  enum __anonenum_state_18 state ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;
  int tmp___4 ;
  int *tmp___5 ;
  char timestr[201] ;
  char ext[5] ;
  int tmp___6 ;
  int *tmp___7 ;
  char timestr___0[201] ;
  char timestr2[201] ;
  char ext___0[5] ;
  int tmp___8 ;
  int *tmp___9 ;
  int tmp___10 ;

  {
#line 111
  hascount = 0;
#line 112
  width = 0;
#line 117
  if ((int )*(filenm + 0) == 0) {
#line 120
    ifslash = (char *)"";
  } else {
    {
#line 117
    tmp = (int )strlen(filenm);
    }
#line 117
    if ((int )*(filenm + (tmp - 1)) == 92) {
#line 120
      ifslash = (char *)"";
    } else {
      {
#line 117
      tmp___0 = (int )strlen(filenm);
      }
#line 117
      if ((int )*(filenm + (tmp___0 - 1)) == 47) {
#line 120
        ifslash = (char *)"";
      } else {
#line 122
        ifslash = (char *)"/";
      }
    }
  }
  {
#line 125
  pictm = gltimetz(& pictime, usetimezone___1);
  }
#line 127
  if (nameformat___1) {
    {
#line 128
    tmp___1 = (int )strlen(nameformat___1);
    }
#line 128
    if (tmp___1 == 1) {
#line 129
      if ((int )*nameformat___1 == 100) {
#line 130
        ftype = 1;
#line 131
        nameformat___1 = (char *)"%010lu";
      } else
#line 132
      if ((int )*nameformat___1 == 120) {
#line 133
        ftype = 1;
#line 134
        nameformat___1 = (char *)"%08lx";
      } else
#line 136
      if ((int )*nameformat___1 >= 49) {
#line 136
        if ((int )*nameformat___1 <= 52) {
#line 138
          ftype = 2;
#line 139
          nameformat___1 = shortcut[datatype][(int )*nameformat___1 - 49];
        } else {
          {
#line 143
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"invalid shortcut `-f %c\', using default\n",
                  (int )*nameformat___1);
#line 146
          nameformat___1 = (char *)((void *)0);
          }
        }
      } else {
        {
#line 143
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"invalid shortcut `-f %c\', using default\n",
                (int )*nameformat___1);
#line 146
        nameformat___1 = (char *)((void *)0);
        }
      }
    } else {
#line 150
      ftype = 2;
    }
  }
#line 160
  if (nameformat___1) {
#line 160
    if (ftype == 2) {
#line 162
      state = (enum __anonenum_state_18 )0;
#line 164
      p = nameformat___1;
      {
#line 164
      while (1) {
        while_continue: /* CIL Label */ ;
#line 164
        if (! *p) {
#line 164
          goto while_break;
        }
        {
#line 165
        if ((unsigned int )state == 0U) {
#line 165
          goto case_0;
        }
#line 172
        if ((unsigned int )state == 1U) {
#line 172
          goto case_1;
        }
#line 175
        if ((unsigned int )state == 2U) {
#line 175
          goto case_2;
        }
#line 181
        if ((unsigned int )state == 3U) {
#line 181
          goto case_3;
        }
#line 189
        if ((unsigned int )state == 4U) {
#line 189
          goto case_4;
        }
#line 164
        goto switch_break;
        case_0: /* CIL Label */ 
        {
#line 167
        if ((int )*p == 92) {
#line 167
          goto case_92;
        }
#line 168
        if ((int )*p == 37) {
#line 168
          goto case_37;
        }
#line 169
        goto switch_default;
        case_92: /* CIL Label */ 
#line 167
        state = (enum __anonenum_state_18 )1;
#line 167
        goto switch_break___0;
        case_37: /* CIL Label */ 
#line 168
        state = (enum __anonenum_state_18 )2;
#line 168
        goto switch_break___0;
        switch_default: /* CIL Label */ 
#line 169
        state = (enum __anonenum_state_18 )0;
#line 169
        goto switch_break___0;
        switch_break___0: /* CIL Label */ ;
        }
#line 171
        goto switch_break;
        case_1: /* CIL Label */ 
#line 173
        state = (enum __anonenum_state_18 )0;
#line 174
        goto switch_break;
        case_2: /* CIL Label */ 
        {
#line 177
        if ((int )*p == 37) {
#line 177
          goto case_37___0;
        }
#line 178
        goto switch_default___0;
        case_37___0: /* CIL Label */ 
#line 177
        state = (enum __anonenum_state_18 )3;
#line 177
        goto switch_break___1;
        switch_default___0: /* CIL Label */ 
#line 178
        state = (enum __anonenum_state_18 )0;
#line 178
        goto switch_break___1;
        switch_break___1: /* CIL Label */ ;
        }
#line 180
        goto switch_break;
        case_3: /* CIL Label */ 
#line 182
        if ((int )*p >= 48) {
#line 182
          if ((int )*p <= 57) {
#line 183
            state = (enum __anonenum_state_18 )4;
#line 184
            width *= 10;
#line 185
            width += (int )*p - 48;
          } else {
#line 187
            state = (enum __anonenum_state_18 )0;
          }
        } else {
#line 187
          state = (enum __anonenum_state_18 )0;
        }
#line 188
        goto switch_break;
        case_4: /* CIL Label */ 
#line 190
        if ((int )*p >= 48) {
#line 190
          if ((int )*p <= 57) {
#line 191
            state = (enum __anonenum_state_18 )4;
#line 192
            width *= 10;
#line 193
            width += (int )*p - 48;
          } else {
#line 195
            state = (enum __anonenum_state_18 )0;
          }
        } else {
#line 195
          state = (enum __anonenum_state_18 )0;
        }
#line 196
        if ((int )*p == 100) {
#line 196
          hascount ++;
        }
#line 197
        goto switch_break;
        switch_break: /* CIL Label */ ;
        }
#line 164
        p ++;
      }
      while_break: /* CIL Label */ ;
      }
    }
  }
#line 201
  if (hascount > 1) {
    {
#line 202
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"bad `-f %s\' option: more than one count fields\n",
            nameformat___1);
#line 204
    hascount = 0;
#line 205
    width = 0;
    }
  }
#line 208
  if (hascount) {
#line 208
    if (width < 1) {
      {
#line 209
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"bad count field width in `-f %s\' option\n",
              nameformat___1);
#line 211
      hascount = 0;
#line 212
      width = 0;
      }
    } else
#line 208
    if (width > 8) {
      {
#line 209
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"bad count field width in `-f %s\' option\n",
              nameformat___1);
#line 211
      hascount = 0;
#line 212
      width = 0;
      }
    }
  }
  {
#line 216
  if (width == 1) {
#line 216
    goto case_1___0;
  }
#line 217
  if (width == 2) {
#line 217
    goto case_2___0;
  }
#line 218
  goto switch_default___1;
  case_1___0: /* CIL Label */ 
#line 216
  maxcount = 10;
#line 216
  goto switch_break___2;
  case_2___0: /* CIL Label */ 
#line 217
  maxcount = 100;
#line 217
  goto switch_break___2;
  switch_default___1: /* CIL Label */ 
#line 218
  maxcount = 1000;
#line 218
  goto switch_break___2;
  switch_break___2: /* CIL Label */ ;
  }
#line 221
  count___0 = 1;
  {
#line 221
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 221
    if (! (count___0 < maxcount)) {
#line 221
      goto while_break___0;
    }
#line 222
    if (ftype == 0) {
#line 223
      if (datatype == 2) {
#line 223
        tmp___2 = "wav";
      } else {
#line 223
        tmp___2 = "jpg";
      }
#line 223
      if (datatype == 1) {
#line 223
        tmp___3 = "-";
      } else {
#line 223
        tmp___3 = "_";
      }
      {
#line 223
      sprintf((char */* __restrict  */)fname___0, (char const   */* __restrict  */)"%s%s%02d%02d%s%03d.%s",
              filenm, ifslash, pictm->tm_mon + 1, pictm->tm_mday, tmp___3, count___0,
              tmp___2);
#line 231
      tmp___4 = stat((char const   */* __restrict  */)fname___0, (struct stat */* __restrict  */)(& st));
      }
#line 231
      if (tmp___4 < 0) {
        {
#line 231
        tmp___5 = __errno_location();
        }
#line 231
        if (*tmp___5 == 2) {
#line 232
          goto while_break___0;
        }
      }
    } else
#line 234
    if (ftype == 1) {
      {
#line 238
      sprintf((char */* __restrict  */)(timestr), (char const   */* __restrict  */)nameformat___1,
              pictime);
      }
#line 239
      if (count___0 == 1) {
#line 239
        ext[0] = (char )'\000';
      } else {
        {
#line 240
        sprintf((char */* __restrict  */)(ext), (char const   */* __restrict  */)".%03d",
                count___0 - 1);
        }
      }
      {
#line 241
      sprintf((char */* __restrict  */)fname___0, (char const   */* __restrict  */)"%s%s%s%s",
              filenm, ifslash, timestr, ext);
#line 246
      tmp___6 = stat((char const   */* __restrict  */)fname___0, (struct stat */* __restrict  */)(& st));
      }
#line 246
      if (tmp___6 < 0) {
        {
#line 246
        tmp___7 = __errno_location();
        }
#line 246
        if (*tmp___7 == 2) {
#line 247
          goto while_break___0;
        }
      }
    } else
#line 250
    if (ftype == 2) {
#line 255
      if (hascount) {
        {
#line 256
        strftime((char */* __restrict  */)(timestr2), 200UL - (size_t )width, (char const   */* __restrict  */)nameformat___1,
                 (struct tm  const  */* __restrict  */)pictm);
#line 258
        sprintf((char */* __restrict  */)(timestr___0), (char const   */* __restrict  */)(timestr2),
                count___0);
        }
      } else {
        {
#line 260
        strftime((char */* __restrict  */)(timestr___0), (size_t )200, (char const   */* __restrict  */)nameformat___1,
                 (struct tm  const  */* __restrict  */)pictm);
        }
      }
#line 263
      if (hascount) {
#line 263
        ext___0[0] = (char )'\000';
      } else
#line 263
      if (count___0 == 1) {
#line 263
        ext___0[0] = (char )'\000';
      } else {
        {
#line 264
        sprintf((char */* __restrict  */)(ext___0), (char const   */* __restrict  */)".%03d",
                count___0 - 1);
        }
      }
      {
#line 265
      sprintf((char */* __restrict  */)fname___0, (char const   */* __restrict  */)"%s%s%s%s",
              filenm, ifslash, timestr___0, ext___0);
#line 270
      tmp___8 = stat((char const   */* __restrict  */)fname___0, (struct stat */* __restrict  */)(& st));
      }
#line 270
      if (tmp___8 < 0) {
        {
#line 270
        tmp___9 = __errno_location();
        }
#line 270
        if (*tmp___9 == 2) {
#line 271
          goto while_break___0;
        }
      }
    }
#line 221
    count___0 ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 278
  *(fname___0 + (flen - 1)) = (char )'\000';
#line 282
  tmp___10 = (int )strlen(filenm);
#line 282
  p = fname___0 + tmp___10;
  }
  {
#line 282
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 282
    if (! *p) {
#line 282
      goto while_break___1;
    }
#line 282
    if ((int )*p == 47) {
      {
#line 283
      *p = (char )'\000';
#line 284
      mkdir((char const   *)fname___0, (__mode_t )511);
#line 285
      *p = (char )'/';
      }
    }
#line 282
    p ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 288
  return;
}
}
#line 239 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) struct tm *( __attribute__((__leaf__)) gmtime)(time_t const   *__timer ) ;
#line 243
extern  __attribute__((__nothrow__)) struct tm *( __attribute__((__leaf__)) localtime)(time_t const   *__timer ) ;
#line 38 "/home/wheatley/newnew/temp/photopc-3.05/ctimez.h"
char *ctimetz(time_t *clock___0 , int usetimezone___1 ) ;
#line 39
time_t zoneoffset(time_t now ) ;
#line 68 "/home/wheatley/newnew/temp/photopc-3.05/ctimez.c"
static struct tm null_tm  ;
#line 64 "/home/wheatley/newnew/temp/photopc-3.05/ctimez.c"
struct tm *gltimetz(time_t *clock___0 , int usetimezone___1 ) 
{ 
  struct tm *tm ;

  {
#line 70
  if (usetimezone___1) {
    {
#line 70
    tm = localtime((time_t const   *)clock___0);
    }
  } else {
    {
#line 71
    tm = gmtime((time_t const   *)clock___0);
    }
  }
#line 72
  if (! tm) {
#line 73
    null_tm.tm_sec = 0;
#line 74
    null_tm.tm_min = 0;
#line 75
    null_tm.tm_hour = 0;
#line 76
    null_tm.tm_mday = 1;
#line 77
    null_tm.tm_mon = 0;
#line 78
    null_tm.tm_year = 0;
#line 79
    null_tm.tm_wday = 1;
#line 80
    null_tm.tm_yday = 0;
#line 81
    null_tm.tm_isdst = 0;
#line 83
    tm = & null_tm;
  }
#line 85
  return (tm);
}
}
#line 91 "/home/wheatley/newnew/temp/photopc-3.05/ctimez.c"
static char tmbuf[80]  ;
#line 96
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcpy)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 88 "/home/wheatley/newnew/temp/photopc-3.05/ctimez.c"
char *ctimetz(time_t *clock___0 , int usetimezone___1 ) 
{ 
  struct tm *camtm ;
  char *timefmt ;

  {
#line 95
  if (*clock___0 == -1L) {
    {
#line 96
    strcpy(tmbuf, "N/A");
    }
#line 97
    return (tmbuf);
  }
  {
#line 99
  camtm = gltimetz(clock___0, usetimezone___1);
  }
#line 101
  if (usetimezone___1) {
#line 101
    timefmt = (char *)"%a %b %d %H:%M:%S %Y %Z";
  } else {
#line 102
    timefmt = (char *)"%a %b %d %H:%M:%S %Y";
  }
  {
#line 103
  strftime((char */* __restrict  */)(tmbuf), sizeof(tmbuf), (char const   */* __restrict  */)timefmt,
           (struct tm  const  */* __restrict  */)camtm);
  }
#line 109
  return (tmbuf);
}
}
#line 112 "/home/wheatley/newnew/temp/photopc-3.05/ctimez.c"
time_t zoneoffset(time_t now ) 
{ 
  struct tm ltm ;
  struct tm *tmp ;

  {
  {
#line 121
  tmp = localtime((time_t const   *)(& now));
#line 121
  ltm = *tmp;
  }
#line 123
  return (ltm.tm_gmtoff);
}
}
#line 362 "/usr/include/stdio.h"
extern int printf(char const   * __restrict  __format  , ...) ;
#line 147 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strncmp)(char const   *__s1 ,
                                                                                                char const   *__s2 ,
                                                                                                size_t __n )  __attribute__((__pure__)) ;
#line 52 "/home/wheatley/newnew/temp/photopc-3.05/a12scan.h"
int a12scan(unsigned char **buf___1 , off_t *bufsize ) ;
#line 53
unsigned char *a12search(char *key , unsigned char *buf___1 , off_t bufsize ) ;
#line 54
void a12dump(unsigned char *buf___1 , off_t bufsize ) ;
#line 74 "/home/wheatley/newnew/temp/photopc-3.05/a12scan.c"
int a12scan(unsigned char **buf___1 , off_t *bufsize ) 
{ 
  unsigned char *p ;
  off_t length ;

  {
#line 78
  length = (off_t )0;
#line 80
  p = *buf___1;
  {
#line 81
  while (1) {
    while_continue: /* CIL Label */ ;
#line 81
    if (! ((unsigned long )p < (unsigned long )(*buf___1 + *bufsize))) {
#line 81
      goto while_break;
    }
    {
#line 82
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 82
      if ((unsigned long )p < (unsigned long )(*buf___1 + *bufsize)) {
#line 82
        if (! ((int )*p != 255)) {
#line 82
          goto while_break___0;
        }
      } else {
#line 82
        goto while_break___0;
      }
#line 82
      p ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 83
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 83
      if ((unsigned long )p < (unsigned long )(*buf___1 + *bufsize)) {
#line 83
        if (! ((int )*p == 255)) {
#line 83
          goto while_break___1;
        }
      } else {
#line 83
        goto while_break___1;
      }
#line 83
      p ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 84
    if ((int )*p == 216) {
#line 84
      goto while_continue;
    }
#line 85
    length = (off_t )(((int )*(p + 1) << 8) + (int )*(p + 2));
#line 86
    if ((int )*p == 236) {
#line 87
      p += 3;
#line 88
      length -= 3L;
#line 89
      goto while_break;
    }
#line 91
    p += length;
  }
  while_break: /* CIL Label */ ;
  }
#line 93
  if ((unsigned long )p >= (unsigned long )(*buf___1 + *bufsize)) {
#line 94
    *bufsize = (off_t )0;
#line 95
    *buf___1 = (unsigned char *)((void *)0);
#line 96
    return (-1);
  }
#line 99
  *bufsize = length;
#line 100
  *buf___1 = p;
#line 101
  return (0);
}
}
#line 104 "/home/wheatley/newnew/temp/photopc-3.05/a12scan.c"
unsigned char *a12search(char *key , unsigned char *buf___1 , off_t bufsize ) 
{ 
  unsigned char *p ;
  size_t tmp ;
  int tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;

  {
#line 107
  p = buf___1;
  {
#line 110
  while (1) {
    while_continue: /* CIL Label */ ;
#line 110
    if ((unsigned long )p < (unsigned long )(buf___1 + bufsize)) {
#line 110
      if (! *p) {
#line 110
        goto while_break;
      }
    } else {
#line 110
      goto while_break;
    }
#line 110
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 111
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 111
    if ((unsigned long )p < (unsigned long )(buf___1 + bufsize)) {
#line 111
      if (! ((int )*p == 0)) {
#line 111
        goto while_break___0;
      }
    } else {
#line 111
      goto while_break___0;
    }
#line 111
    p ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 112
  if ((unsigned long )p >= (unsigned long )(buf___1 + bufsize)) {
#line 112
    p = buf___1;
  }
  {
#line 113
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 113
    if (! ((unsigned long )p < (unsigned long )(buf___1 + bufsize))) {
#line 113
      goto while_break___1;
    }
    {
#line 114
    tmp = strlen((char const   *)key);
#line 114
    tmp___0 = strncmp((char const   *)p, (char const   *)key, tmp);
    }
#line 114
    if (tmp___0 == 0) {
#line 114
      goto while_break___1;
    }
    {
#line 115
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 115
      if ((unsigned long )p < (unsigned long )(buf___1 + bufsize)) {
#line 115
        if (! ((int )*p != 10)) {
#line 115
          goto while_break___2;
        }
      } else {
#line 115
        goto while_break___2;
      }
#line 115
      p ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 116
    p ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 118
  if ((unsigned long )p >= (unsigned long )(buf___1 + bufsize)) {
#line 118
    return ((unsigned char *)((void *)0));
  }
  {
#line 119
  tmp___1 = strlen((char const   *)key);
  }
#line 119
  if ((int )*(p + tmp___1) != 61) {
#line 119
    return ((unsigned char *)((void *)0));
  }
  {
#line 120
  tmp___2 = strlen((char const   *)key);
  }
#line 120
  return ((p + tmp___2) + 1);
}
}
#line 123 "/home/wheatley/newnew/temp/photopc-3.05/a12scan.c"
void a12dump(unsigned char *buf___1 , off_t bufsize ) 
{ 
  unsigned char *p ;

  {
  {
#line 126
  p = buf___1;
#line 128
  printf((char const   */* __restrict  */)"%s\n", p);
  }
  {
#line 129
  while (1) {
    while_continue: /* CIL Label */ ;
#line 129
    if ((unsigned long )p < (unsigned long )(buf___1 + bufsize)) {
#line 129
      if (! *p) {
#line 129
        goto while_break;
      }
    } else {
#line 129
      goto while_break;
    }
#line 129
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 130
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 130
    if ((unsigned long )p < (unsigned long )(buf___1 + bufsize)) {
#line 130
      if (! ((int )*p == 0)) {
#line 130
        goto while_break___0;
      }
    } else {
#line 130
      goto while_break___0;
    }
#line 130
    p ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 131
  printf((char const   */* __restrict  */)"%s\n", p);
  }
#line 132
  return;
}
}
#line 45 "/usr/include/utime.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) utime)(char const   *__file ,
                                                                                            struct utimbuf  const  *__file_times ) ;
#line 84 "/home/wheatley/newnew/temp/photopc-3.05/filetime.c"
int setfiletime(char *fname___0 , time_t actime , time_t mtime , int usetimezone___1 ) 
{ 
  struct utimbuf utb ;
  time_t tmp ;
  time_t tmp___0 ;
  int tmp___1 ;

  {
#line 138
  if (! usetimezone___1) {
    {
#line 139
    tmp = zoneoffset(actime);
#line 139
    actime -= tmp;
#line 140
    tmp___0 = zoneoffset(mtime);
#line 140
    mtime -= tmp___0;
    }
  }
  {
#line 143
  utb.actime = actime;
#line 144
  utb.modtime = mtime;
#line 145
  tmp___1 = utime((char const   *)fname___0, (struct utimbuf  const  *)(& utb));
  }
#line 145
  return (tmp___1);
}
}
#line 169 "/usr/include/stdio.h"
extern struct _IO_FILE *stdout ;
#line 237
extern int fclose(FILE *__stream ) ;
#line 242
extern int fflush(FILE *__stream ) ;
#line 272
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 433
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) sscanf)(char const   * __restrict  __s ,
                                                                             char const   * __restrict  __format 
                                                                             , ...)  __asm__("__isoc99_sscanf")  ;
#line 709
extern size_t fread(void * __restrict  __ptr , size_t __size , size_t __n , FILE * __restrict  __stream ) ;
#line 715
extern size_t fwrite(void const   * __restrict  __ptr , size_t __size , size_t __n ,
                     FILE * __restrict  __s ) ;
#line 846
extern void perror(char const   *__s ) ;
#line 144 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) double ( __attribute__((__nonnull__(1), __leaf__)) atof)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 150
extern  __attribute__((__nothrow__)) long ( __attribute__((__nonnull__(1), __leaf__)) atol)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 466
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 776
extern  __attribute__((__nothrow__)) long ( __attribute__((__leaf__)) labs)(long __x )  __attribute__((__const__)) ;
#line 46 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memcpy)(void * __restrict  __dest ,
                                                                                                 void const   * __restrict  __src ,
                                                                                                 size_t __n ) ;
#line 66
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memset)(void *__s ,
                                                                                               int __c ,
                                                                                               size_t __n ) ;
#line 132
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strncpy)(char * __restrict  __dest ,
                                                                                                  char const   * __restrict  __src ,
                                                                                                  size_t __n ) ;
#line 137
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcat)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 140
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strncat)(char * __restrict  __dest ,
                                                                                                  char const   * __restrict  __src ,
                                                                                                  size_t __n ) ;
#line 144
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 236
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strchr)(char const   *__s ,
                                                                                               int __c )  __attribute__((__pure__)) ;
#line 289
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1,2), __leaf__)) strspn)(char const   *__s ,
                                                                                                  char const   *__accept )  __attribute__((__pure__)) ;
#line 348
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(2), __leaf__)) strtok)(char * __restrict  __s ,
                                                                                               char const   * __restrict  __delim ) ;
#line 413
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) strerror)(int __errnum ) ;
#line 534
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcasecmp)(char const   *__s1 ,
                                                                                                   char const   *__s2 )  __attribute__((__pure__)) ;
#line 192 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) time_t ( __attribute__((__leaf__)) time)(time_t *__timer ) ;
#line 293
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) tzset)(void) ;
#line 56 "/usr/include/sched.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) sched_setscheduler)(__pid_t __pid ,
                                                                                         int __policy ,
                                                                                         struct sched_param  const  *__param ) ;
#line 66
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) sched_get_priority_max)(int __algorithm ) ;
#line 69
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) sched_get_priority_min)(int __algorithm ) ;
#line 81 "/usr/include/x86_64-linux-gnu/sys/utsname.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) uname)(struct utsname *__name ) ;
#line 675 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) __uid_t ( __attribute__((__leaf__)) getuid)(void) ;
#line 678
extern  __attribute__((__nothrow__)) __uid_t ( __attribute__((__leaf__)) geteuid)(void) ;
#line 710
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) seteuid)(__uid_t __uid ) ;
#line 826
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) unlink)(char const   *__name ) ;
#line 34 "./getopt.h"
extern char *optarg ;
#line 48
extern int optind ;
#line 105
extern int getopt(int argc , char * const  *argv , char const   *shortopts ) ;
#line 124 "/home/wheatley/newnew/temp/photopc-3.05/eph_io.h"
extern eph_iob *eph_new(void (*errorcb)(int errcode , char *errstr ) , void *(*realloccb)(void *old ,
                                                                                          size_t length ) ,
                        void (*runcb)(off_t count ) , int (*storecb)(char *data ,
                                                                     size_t size ) ,
                        int debug ) ;
#line 129
extern int eph_open(eph_iob *iob , char *device_name , long speed , long defttspeed ,
                    long ttspeed ) ;
#line 131
extern int eph_close(eph_iob *iob , int newmodel ) ;
#line 132
extern void eph_free(eph_iob *iob ) ;
#line 134
extern int eph_setint(eph_iob *iob , int reg , long val ) ;
#line 135
extern int eph_setnullint(eph_iob *iob , int reg ) ;
#line 136
extern int eph_getint(eph_iob *iob , int reg , long *val ) ;
#line 137
extern int eph_action(eph_iob *iob , int reg , char *val , size_t length ) ;
#line 138
extern int eph_setvar(eph_iob *iob , int reg , char *val , off_t length ) ;
#line 139
extern int eph_getvar(eph_iob *iob , int reg , char **val , off_t *length ) ;
#line 392 "/home/wheatley/newnew/temp/photopc-3.05/photopc.c"
static char *device  =    (char *)"/dev/photopc";
#line 397 "/home/wheatley/newnew/temp/photopc-3.05/photopc.c"
static int debug  =    0;
#line 398 "/home/wheatley/newnew/temp/photopc-3.05/photopc.c"
static int quiet  =    0;
#line 399 "/home/wheatley/newnew/temp/photopc-3.05/photopc.c"
static int usetimezone  =    1;
#line 400 "/home/wheatley/newnew/temp/photopc-3.05/photopc.c"
static int setutime  =    0;
#line 401 "/home/wheatley/newnew/temp/photopc-3.05/photopc.c"
static unsigned long filesize  =    0UL;
#line 402 "/home/wheatley/newnew/temp/photopc-3.05/photopc.c"
static long frame  =    0L;
#line 403 "/home/wheatley/newnew/temp/photopc-3.05/photopc.c"
static char *nameformat  =    (char *)((void *)0);
#line 404 "/home/wheatley/newnew/temp/photopc-3.05/photopc.c"
static int switchoff  =    0;
#line 405 "/home/wheatley/newnew/temp/photopc-3.05/photopc.c"
static FILE *fp  =    (FILE *)((void *)0);
#line 406 "/home/wheatley/newnew/temp/photopc-3.05/photopc.c"
static char *fname  =    (char *)((void *)0);
#line 407 "/home/wheatley/newnew/temp/photopc-3.05/photopc.c"
static int have_folders  =    0;
#line 409 "/home/wheatley/newnew/temp/photopc-3.05/photopc.c"
void file_abort_cleanup(void) 
{ 


  {
#line 412
  if (fp) {
    {
#line 413
    fclose(fp);
#line 414
    fp = (FILE *)((void *)0);
    }
  }
#line 416
  if (fname) {
    {
#line 417
    printf((char const   */* __restrict  */)"\ndeleting file %s\n", fname);
#line 418
    unlink((char const   *)fname);
#line 419
    free((void *)fname);
#line 420
    fname = (char *)((void *)0);
    }
  }
#line 422
  return;
}
}
#line 424 "/home/wheatley/newnew/temp/photopc-3.05/photopc.c"
static long numphotos(eph_iob *iob ) 
{ 
  long r10 ;
  long r40 ;
  int tmp ;
  int tmp___0 ;
  long tmp___1 ;

  {
  {
#line 429
  tmp = eph_getint(iob, 40, & r40);
  }
#line 429
  if (tmp) {
#line 430
    r40 = -1L;
  }
  {
#line 432
  tmp___0 = eph_getint(iob, 10, & r10);
  }
#line 432
  if (tmp___0) {
#line 433
    r10 = -1L;
  }
#line 435
  if (r10 > r40) {
#line 435
    tmp___1 = r10;
  } else {
#line 435
    tmp___1 = r40;
  }
#line 435
  return (tmp___1);
}
}
#line 438 "/home/wheatley/newnew/temp/photopc-3.05/photopc.c"
static int xchdir(eph_iob *iob , char *where ) 
{ 
  char path[256] ;
  char *p ;
  int tmp ;
  size_t tmp___0 ;
  int tmp___1 ;

  {
#line 443
  if (! have_folders) {
    {
#line 444
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"no folders on this model\n");
    }
#line 445
    return (-1);
  }
  {
#line 447
  strncpy((char */* __restrict  */)(path), (char const   */* __restrict  */)where,
          sizeof(path) - 1UL);
#line 448
  path[sizeof(path) - 1UL] = (char )'\000';
#line 449
  p = path;
  }
  {
#line 449
  while (1) {
    while_continue: /* CIL Label */ ;
#line 449
    if (! *p) {
#line 449
      goto while_break;
    }
#line 449
    if ((int )*p == 47) {
#line 449
      *p = (char )'\\';
    }
#line 449
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 450
  if ((int )path[0] == 92) {
    {
#line 451
    tmp = eph_setvar(iob, 84, (char *)"\\", (off_t )1);
    }
#line 451
    if (tmp) {
      {
#line 452
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"could not chdir to \"\\\"\n");
      }
#line 453
      return (-1);
    }
  }
  {
#line 456
  p = strtok((char */* __restrict  */)(path), (char const   */* __restrict  */)"\\");
  }
  {
#line 456
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 456
    if (! p) {
#line 456
      goto while_break___0;
    }
    {
#line 457
    tmp___0 = strlen((char const   *)p);
#line 457
    tmp___1 = eph_setvar(iob, 84, p, (off_t )tmp___0);
    }
#line 457
    if (tmp___1) {
      {
#line 458
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"could not chdir to \"%s\"\n",
              p);
      }
#line 459
      return (-1);
    }
    {
#line 456
    p = strtok((char */* __restrict  */)((void *)0), (char const   */* __restrict  */)"\\");
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 462
  return (0);
}
}
#line 465 "/home/wheatley/newnew/temp/photopc-3.05/photopc.c"
static int descend(eph_iob *iob , int depth , char *root , int (*each)(eph_iob *iob ,
                                                                       char *path ) ) 
{ 
  long nfolders ;
  long i ;
  off_t f_size ;
  char *folder ;
  char *p ;
  char path[256] ;
  int rc ;
  int tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  int tmp___4 ;

  {
#line 468
  nfolders = 0L;
#line 474
  if (! have_folders) {
    {
#line 474
    tmp = (*each)(iob, root);
    }
#line 474
    return (tmp);
  }
#line 476
  if (depth > 10) {
    {
#line 477
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"cannot be that deep (%d), error!\n",
            depth);
    }
#line 478
    return (-1);
  }
  {
#line 480
  tmp___0 = xchdir(iob, root);
  }
#line 480
  if (tmp___0) {
    {
#line 481
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"chdir to \"%s\" failed\n",
            root);
    }
#line 482
    return (-1);
  }
  {
#line 485
  rc = (*each)(iob, root);
  }
#line 485
  if (rc != 0) {
#line 486
    if (debug) {
      {
#line 486
      printf((char const   */* __restrict  */)"(*each)() returned %d\n", rc);
      }
    }
#line 487
    return (rc);
  }
  {
#line 490
  eph_getint(iob, 83, & nfolders);
  }
#line 491
  if (debug) {
    {
#line 491
    printf((char const   */* __restrict  */)"descend: %s has %ld folders\n", root,
           nfolders);
    }
  }
#line 493
  if (nfolders == 0L) {
#line 493
    return (0);
  }
  {
#line 495
  tmp___1 = malloc((size_t )2048);
#line 495
  folder = (char *)tmp___1;
#line 496
  f_size = (off_t )2048;
#line 497
  path[sizeof(path) - 1UL] = (char )'\000';
#line 498
  i = 1L;
  }
  {
#line 498
  while (1) {
    while_continue: /* CIL Label */ ;
#line 498
    if (! (i <= nfolders)) {
#line 498
      goto while_break;
    }
    {
#line 499
    eph_setint(iob, 83, i);
#line 500
    eph_getvar(iob, 84, & folder, & f_size);
    }
#line 501
    if (debug) {
      {
#line 501
      printf((char const   */* __restrict  */)"depth=%4d i=%4ld:\n", depth, i);
      }
    }
    {
#line 502
    strncpy((char */* __restrict  */)(path), (char const   */* __restrict  */)root,
            sizeof(path) - 2UL);
#line 503
    tmp___2 = strlen((char const   *)(path));
    }
#line 503
    if ((int )path[tmp___2 - 1UL] != 92) {
      {
#line 504
      strncat((char */* __restrict  */)(path), (char const   */* __restrict  */)"\\",
              sizeof(path) - 2UL);
      }
    }
    {
#line 505
    strncat((char */* __restrict  */)(path), (char const   */* __restrict  */)folder,
            sizeof(path) - 2UL);
#line 506
    tmp___3 = strlen((char const   *)(path));
#line 506
    p = (path + tmp___3) - 1;
    }
    {
#line 506
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 506
      if ((int )*p == 32) {
#line 506
        if (! ((unsigned long )p > (unsigned long )(path))) {
#line 506
          goto while_break___0;
        }
      } else {
#line 506
        goto while_break___0;
      }
#line 507
      *p = (char )'\000';
#line 506
      p --;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 508
    rc = descend(iob, depth + 1, path, each);
    }
#line 508
    if (rc) {
      {
#line 509
      free((void *)folder);
      }
#line 510
      return (rc);
    }
    {
#line 512
    tmp___4 = xchdir(iob, root);
    }
#line 512
    if (tmp___4) {
      {
#line 513
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"restore dir to \"%s\" failed\n",
              root);
#line 514
      free((void *)folder);
      }
#line 515
      return (-1);
    }
#line 498
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 518
  free((void *)folder);
  }
#line 519
  if (debug) {
    {
#line 519
    printf((char const   */* __restrict  */)"descend: full tree walked through\n");
    }
  }
#line 520
  return (0);
}
}
#line 523 "/home/wheatley/newnew/temp/photopc-3.05/photopc.c"
static int nonempty(eph_iob *iob , char *path ) 
{ 
  long result ;
  int tmp ;
  size_t tmp___0 ;

  {
  {
#line 528
  tmp = eph_getint(iob, 10, & result);
  }
#line 528
  if (tmp) {
#line 529
    return (-1);
  }
#line 531
  if (result) {
    {
#line 532
    tmp___0 = strlen((char const   *)path);
    }
#line 532
    if (tmp___0 < 2UL) {
#line 533
      if (! quiet) {
        {
#line 533
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Buggy camera: nonempty root folder \"%s\", skip over\n",
                path);
        }
      }
#line 534
      return (0);
    }
#line 536
    if (! quiet) {
      {
#line 536
      printf((char const   */* __restrict  */)"Starting in folder \"%s\"\n", path);
      }
    }
#line 537
    return (1);
  } else {
#line 538
    return (0);
  }
}
}
#line 541 "/home/wheatley/newnew/temp/photopc-3.05/photopc.c"
int init(eph_iob *iob ) 
{ 
  long ret ;
  int rc ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 547
  tmp = eph_getint(iob, 1, & ret);
  }
#line 547
  if (tmp) {
#line 547
    return (-1);
  }
  {
#line 552
  rc = eph_setnullint(iob, 83);
  }
#line 552
  if (rc) {
#line 553
    if (debug) {
      {
#line 553
      printf((char const   */* __restrict  */)"setnullint(83) returned %d\n", rc);
      }
    }
  }
  {
#line 555
  tmp___0 = eph_setvar(iob, 84, (char *)"\\", (off_t )1);
  }
#line 555
  if (tmp___0) {
#line 556
    if (debug) {
      {
#line 556
      printf((char const   */* __restrict  */)"No folders on this model\n");
      }
    }
  } else {
#line 558
    have_folders = 1;
  }
#line 560
  if (have_folders) {
    {
#line 561
    tmp___1 = descend(iob, 0, (char *)"\\", & nonempty);
    }
#line 561
    if (tmp___1 < 0) {
#line 561
      return (-1);
    }
  }
#line 562
  return (0);
}
}
#line 565 "/home/wheatley/newnew/temp/photopc-3.05/photopc.c"
int setclock(eph_iob *iob , int argc , char **argv ) 
{ 
  time_t now ;
  time_t new ;
  time_t tmp ;
  int tmp___0 ;
  int tmp___1 ;
  long tmp___2 ;

  {
  {
#line 570
  time(& now);
  }
#line 572
  if (! usetimezone) {
    {
#line 573
    tmp = zoneoffset(now);
#line 573
    now += tmp;
    }
  }
  {
#line 576
  tmp___0 = eph_setint(iob, 2, now);
  }
#line 576
  if (tmp___0) {
#line 576
    return (-1);
  }
  {
#line 577
  tmp___1 = eph_getint(iob, 2, & new);
  }
#line 577
  if (tmp___1) {
#line 577
    return (-1);
  }
  {
#line 578
  tmp___2 = labs(now - new);
  }
#line 578
  if (tmp___2 > 59L) {
    {
#line 579
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"time we tried to set does not match the result\n");
    }
#line 580
    return (-1);
  } else {
#line 582
    return (0);
  }
}
}
#line 586 "/home/wheatley/newnew/temp/photopc-3.05/photopc.c"
int resolution(eph_iob *iob , int argc , char **argv ) 
{ 
  long val ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 589
  val = 0L;
#line 591
  tmp___1 = strcasecmp((char const   *)*(argv + 1), "Lo");
  }
#line 591
  if (tmp___1 == 0) {
#line 592
    val = 1L;
  } else {
    {
#line 593
    tmp___0 = strcasecmp((char const   *)*(argv + 1), "Hi");
    }
#line 593
    if (tmp___0 == 0) {
#line 594
      val = 2L;
    } else {
      {
#line 595
      tmp = strcasecmp((char const   *)*(argv + 1), "Ext");
      }
#line 595
      if (tmp == 0) {
#line 596
        val = 3L;
      } else {
        {
#line 597
        val = atol((char const   *)*(argv + 1));
        }
#line 597
        if (val == 0L) {
          {
#line 598
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"bad resolution `%s\'\n",
                  *(argv + 1));
          }
#line 599
          return (-1);
        }
      }
    }
  }
  {
#line 602
  tmp___2 = eph_setint(iob, 1, val);
  }
#line 602
  return (tmp___2);
}
}
#line 605 "/home/wheatley/newnew/temp/photopc-3.05/photopc.c"
int shutter(eph_iob *iob , int argc , char **argv ) 
{ 
  long val ;
  int adjust___0 ;
  char buffer[8] ;
  int tmp ;
  int tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
  {
#line 608
  val = 0L;
#line 609
  adjust___0 = 0;
#line 610
  buffer[0] = (char)0;
#line 610
  buffer[1] = (char)0;
#line 610
  buffer[2] = (char)0;
#line 610
  buffer[3] = (char)0;
#line 610
  buffer[4] = (char)10;
#line 610
  buffer[5] = (char)0;
#line 610
  buffer[6] = (char)0;
#line 610
  buffer[7] = (char)0;
#line 612
  tmp___3 = strcasecmp((char const   *)*(argv + 1), "Auto");
  }
#line 612
  if (tmp___3 == 0) {
#line 613
    val = 0L;
  } else {
    {
#line 614
    tmp___1 = strlen((char const   *)*(argv + 1));
    }
#line 614
    if (tmp___1 > 2UL) {
      {
#line 614
      tmp___2 = strncmp((char const   *)*(argv + 1), "1/", (size_t )2);
      }
#line 614
      if (tmp___2 == 0) {
        {
#line 615
        val = atol((char const   *)(*(argv + 1) + 2));
        }
#line 616
        if (val == 0L) {
          {
#line 617
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"bad shutter speed `%s\'\n",
                  *(argv + 1));
          }
#line 618
          return (-1);
        } else {
#line 620
          val = 1000000L / val;
        }
      } else {
#line 614
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
      {
#line 622
      tmp___0 = sscanf((char const   */* __restrict  */)*(argv + 1), (char const   */* __restrict  */)"plus%ld",
                       & val);
      }
#line 622
      if (tmp___0 == 1) {
#line 623
        adjust___0 = 1;
      } else {
        {
#line 624
        tmp = sscanf((char const   */* __restrict  */)*(argv + 1), (char const   */* __restrict  */)"minus%ld",
                     & val);
        }
#line 624
        if (tmp == 1) {
#line 625
          adjust___0 = -1;
        } else {
          {
#line 626
          val = atol((char const   *)*(argv + 1));
          }
#line 626
          if (val == 0L) {
            {
#line 627
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"bad shutter speed `%s\'\n",
                    *(argv + 1));
            }
#line 628
            return (-1);
          }
        }
      }
    }
  }
#line 631
  if (adjust___0) {
#line 632
    if (val == 0L) {
      {
#line 633
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"bad shutter adjustment `%s\'\n",
              *(argv + 1));
      }
#line 634
      return (-1);
    } else {
#line 636
      val *= (long )adjust___0;
    }
    {
#line 638
    buffer[0] = (char )(val & 255L);
#line 639
    buffer[1] = (char )((val >> 8) & 255L);
#line 640
    buffer[2] = (char )((val >> 16) & 255L);
#line 641
    buffer[3] = (char )((val >> 24) & 255L);
#line 642
    tmp___4 = eph_setvar(iob, 69, buffer, (off_t )sizeof(buffer));
    }
#line 642
    return (tmp___4);
  } else {
    {
#line 643
    tmp___5 = eph_setint(iob, 3, val);
    }
#line 643
    return (tmp___5);
  }
}
}
#line 646 "/home/wheatley/newnew/temp/photopc-3.05/photopc.c"
int aperture(eph_iob *iob , int argc , char **argv ) 
{ 
  long val ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  {
#line 649
  val = 0L;
#line 651
  tmp___2 = strcasecmp((char const   *)*(argv + 1), "Auto");
  }
#line 651
  if (tmp___2 == 0) {
#line 652
    val = 0L;
  } else {
    {
#line 653
    tmp___1 = strcasecmp((char const   *)*(argv + 1), "Lo");
    }
#line 653
    if (tmp___1 == 0) {
#line 654
      val = 1L;
    } else {
      {
#line 655
      tmp___0 = strcasecmp((char const   *)*(argv + 1), "Med");
      }
#line 655
      if (tmp___0 == 0) {
#line 656
        val = 2L;
      } else {
        {
#line 657
        tmp = strcasecmp((char const   *)*(argv + 1), "Hi");
        }
#line 657
        if (tmp == 0) {
#line 658
          val = 4L;
        } else {
          {
#line 659
          val = atol((char const   *)*(argv + 1));
          }
#line 659
          if (val == 0L) {
            {
#line 660
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"bad aperture `%s\'\n",
                    *(argv + 1));
            }
#line 661
            return (-1);
          }
        }
      }
    }
  }
  {
#line 664
  tmp___3 = eph_setint(iob, 5, val);
  }
#line 664
  return (tmp___3);
}
}
#line 667 "/home/wheatley/newnew/temp/photopc-3.05/photopc.c"
int flash(eph_iob *iob , int argc , char **argv ) 
{ 
  long val ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
  {
#line 670
  val = 0L;
#line 672
  tmp___3 = strcasecmp((char const   *)*(argv + 1), "Auto");
  }
#line 672
  if (tmp___3 == 0) {
#line 673
    val = 0L;
  } else {
    {
#line 674
    tmp___2 = strcasecmp((char const   *)*(argv + 1), "Force");
    }
#line 674
    if (tmp___2 == 0) {
#line 675
      val = 1L;
    } else {
      {
#line 676
      tmp___1 = strcasecmp((char const   *)*(argv + 1), "Off");
      }
#line 676
      if (tmp___1 == 0) {
#line 677
        val = 2L;
      } else {
        {
#line 678
        tmp___0 = strcasecmp((char const   *)*(argv + 1), "Antiredeye");
        }
#line 678
        if (tmp___0 == 0) {
#line 679
          val = 3L;
        } else {
          {
#line 680
          tmp = strcasecmp((char const   *)*(argv + 1), "Slowsync");
          }
#line 680
          if (tmp == 0) {
#line 681
            val = 4L;
          } else {
            {
#line 683
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"bad flash mode `%s\'\n",
                    *(argv + 1));
            }
#line 684
            return (-1);
          }
        }
      }
    }
  }
  {
#line 687
  tmp___4 = eph_setint(iob, 7, val);
  }
#line 687
  return (tmp___4);
}
}
#line 690 "/home/wheatley/newnew/temp/photopc-3.05/photopc.c"
int autoshut_host(eph_iob *iob , int argc , char **argv ) 
{ 
  long val ;
  int tmp ;

  {
  {
#line 693
  val = 0L;
#line 695
  val = atol((char const   *)*(argv + 1));
  }
#line 695
  if (val <= 0L) {
    {
#line 696
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"bad timer value `%s\'\n",
            *(argv + 1));
    }
#line 697
    return (-1);
  }
  {
#line 700
  tmp = eph_setint(iob, 23, val);
  }
#line 700
  return (tmp);
}
}
#line 703 "/home/wheatley/newnew/temp/photopc-3.05/photopc.c"
int autoshut_field(eph_iob *iob , int argc , char **argv ) 
{ 
  long val ;
  int tmp ;

  {
  {
#line 706
  val = 0L;
#line 708
  val = atol((char const   *)*(argv + 1));
  }
#line 708
  if (val <= 0L) {
    {
#line 709
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"bad timer value `%s\'\n",
            *(argv + 1));
    }
#line 710
    return (-1);
  }
  {
#line 713
  tmp = eph_setint(iob, 24, val);
  }
#line 713
  return (tmp);
}
}
#line 716 "/home/wheatley/newnew/temp/photopc-3.05/photopc.c"
int lcd_autoshut(eph_iob *iob , int argc , char **argv ) 
{ 
  long val ;
  int tmp ;

  {
  {
#line 719
  val = 0L;
#line 721
  val = atol((char const   *)*(argv + 1));
  }
#line 721
  if (val <= 0L) {
    {
#line 722
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"bad timer value `%s\'\n",
            *(argv + 1));
    }
#line 723
    return (-1);
  }
  {
#line 726
  tmp = eph_setint(iob, 38, val);
  }
#line 726
  return (tmp);
}
}
#line 729 "/home/wheatley/newnew/temp/photopc-3.05/photopc.c"
int lcd_brightness(eph_iob *iob , int argc , char **argv ) 
{ 
  long val ;
  int tmp ;

  {
  {
#line 732
  val = 0L;
#line 734
  val = atol((char const   *)*(argv + 1));
  }
#line 734
  if (val <= 0L) {
    {
#line 735
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"bad brighness value `%s\'\n",
            *(argv + 1));
    }
#line 736
    return (-1);
  } else
#line 734
  if (val > 7L) {
    {
#line 735
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"bad brighness value `%s\'\n",
            *(argv + 1));
    }
#line 736
    return (-1);
  }
  {
#line 739
  tmp = eph_setint(iob, 35, val);
  }
#line 739
  return (tmp);
}
}
#line 742 "/home/wheatley/newnew/temp/photopc-3.05/photopc.c"
int setid(eph_iob *iob , int argc , char **argv ) 
{ 
  size_t tmp ;
  int tmp___0 ;

  {
  {
#line 745
  tmp = strlen((char const   *)*(argv + 1));
#line 745
  tmp___0 = eph_setvar(iob, 22, *(argv + 1), (off_t )tmp);
  }
#line 745
  return (tmp___0);
}
}
#line 748 "/home/wheatley/newnew/temp/photopc-3.05/photopc.c"
int focus(eph_iob *iob , int argc , char **argv ) 
{ 
  long val ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 751
  val = 0L;
#line 753
  tmp___1 = strcasecmp((char const   *)*(argv + 1), "Macro");
  }
#line 753
  if (tmp___1 == 0) {
#line 754
    val = 1L;
  } else {
    {
#line 755
    tmp___0 = strcasecmp((char const   *)*(argv + 1), "Normal");
    }
#line 755
    if (tmp___0 == 0) {
#line 756
      val = 2L;
    } else {
      {
#line 757
      tmp = strcasecmp((char const   *)*(argv + 1), "Infinity");
      }
#line 757
      if (tmp == 0) {
#line 758
        val = 3L;
      } else {
        {
#line 759
        val = atol((char const   *)*(argv + 1));
        }
#line 759
        if (val == 0L) {
          {
#line 760
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"bad focus mode `%s\'\n",
                  *(argv + 1));
          }
#line 761
          return (-1);
        }
      }
    }
  }
  {
#line 764
  tmp___2 = eph_setint(iob, 33, val);
  }
#line 764
  return (tmp___2);
}
}
#line 767 "/home/wheatley/newnew/temp/photopc-3.05/photopc.c"
int adjust(eph_iob *iob , int argc , char **argv ) 
{ 
  long val ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
  {
#line 770
  val = 0L;
#line 772
  tmp___3 = strcasecmp((char const   *)*(argv + 1), "Normal");
  }
#line 772
  if (tmp___3 == 0) {
#line 773
    val = 0L;
  } else {
    {
#line 774
    tmp___2 = strcasecmp((char const   *)*(argv + 1), "Contrast+");
    }
#line 774
    if (tmp___2 == 0) {
#line 775
      val = 1L;
    } else {
      {
#line 776
      tmp___1 = strcasecmp((char const   *)*(argv + 1), "Contrast-");
      }
#line 776
      if (tmp___1 == 0) {
#line 777
        val = 2L;
      } else {
        {
#line 778
        tmp___0 = strcasecmp((char const   *)*(argv + 1), "Brightness+");
        }
#line 778
        if (tmp___0 == 0) {
#line 779
          val = 3L;
        } else {
          {
#line 780
          tmp = strcasecmp((char const   *)*(argv + 1), "Brightness-");
          }
#line 780
          if (tmp == 0) {
#line 781
            val = 4L;
          } else {
            {
#line 782
            val = atol((char const   *)*(argv + 1));
            }
#line 782
            if (val == 0L) {
              {
#line 783
              fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"bad adjust mode `%s\'\n",
                      *(argv + 1));
              }
#line 784
              return (-1);
            }
          }
        }
      }
    }
  }
  {
#line 787
  tmp___4 = eph_setint(iob, 19, val);
  }
#line 787
  return (tmp___4);
}
}
#line 790 "/home/wheatley/newnew/temp/photopc-3.05/photopc.c"
int whitebalance(eph_iob *iob , int argc , char **argv ) 
{ 
  long val ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
  {
#line 793
  val = 0L;
#line 795
  tmp___5 = strcasecmp((char const   *)*(argv + 1), "Auto");
  }
#line 795
  if (tmp___5 == 0) {
#line 796
    val = 0L;
  } else {
    {
#line 797
    tmp___4 = strcasecmp((char const   *)*(argv + 1), "Sunny");
    }
#line 797
    if (tmp___4 == 0) {
#line 798
      val = 1L;
    } else {
      {
#line 799
      tmp___3 = strcasecmp((char const   *)*(argv + 1), "Incandescent");
      }
#line 799
      if (tmp___3 == 0) {
#line 800
        val = 2L;
      } else {
        {
#line 801
        tmp___2 = strcasecmp((char const   *)*(argv + 1), "Fluorescent");
        }
#line 801
        if (tmp___2 == 0) {
#line 802
          val = 3L;
        } else {
          {
#line 803
          tmp___1 = strcasecmp((char const   *)*(argv + 1), "Flash");
          }
#line 803
          if (tmp___1 == 0) {
#line 804
            val = 5L;
          } else {
            {
#line 805
            tmp___0 = strcasecmp((char const   *)*(argv + 1), "Preset");
            }
#line 805
            if (tmp___0 == 0) {
#line 806
              val = 6L;
            } else {
              {
#line 807
              tmp = strcasecmp((char const   *)*(argv + 1), "Cloudy");
              }
#line 807
              if (tmp == 0) {
#line 808
                val = 255L;
              } else {
                {
#line 809
                val = atol((char const   *)*(argv + 1));
                }
#line 809
                if (val == 0L) {
                  {
#line 810
                  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"bad whitebalance mode `%s\'\n",
                          *(argv + 1));
                  }
#line 811
                  return (-1);
                }
              }
            }
          }
        }
      }
    }
  }
  {
#line 814
  tmp___6 = eph_setint(iob, 20, val);
  }
#line 814
  return (tmp___6);
}
}
#line 817 "/home/wheatley/newnew/temp/photopc-3.05/photopc.c"
int metering(eph_iob *iob , int argc , char **argv ) 
{ 
  long val ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 820
  val = 0L;
#line 822
  tmp___1 = strcasecmp((char const   *)*(argv + 1), "Center-weighted");
  }
#line 822
  if (tmp___1 == 0) {
#line 823
    val = 2L;
  } else {
    {
#line 824
    tmp___0 = strcasecmp((char const   *)*(argv + 1), "Spot");
    }
#line 824
    if (tmp___0 == 0) {
#line 825
      val = 3L;
    } else {
      {
#line 826
      tmp = strcasecmp((char const   *)*(argv + 1), "Matrix");
      }
#line 826
      if (tmp == 0) {
#line 827
        val = 5L;
      } else {
        {
#line 828
        val = atol((char const   *)*(argv + 1));
        }
#line 828
        if (val == 0L) {
          {
#line 829
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"bad metering mode `%s\'\n",
                  *(argv + 1));
          }
#line 830
          return (-1);
        }
      }
    }
  }
  {
#line 833
  tmp___2 = eph_setint(iob, 70, val);
  }
#line 833
  return (tmp___2);
}
}
#line 836 "/home/wheatley/newnew/temp/photopc-3.05/photopc.c"
int color(eph_iob *iob , int argc , char **argv ) 
{ 
  long val ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
  {
#line 839
  val = 0L;
#line 841
  tmp___5 = eph_getint(iob, 72, & val);
  }
#line 841
  if (tmp___5) {
    {
#line 842
    tmp___0 = strcasecmp((char const   *)*(argv + 1), "On");
    }
#line 842
    if (tmp___0 == 0) {
#line 843
      val = 1L;
    } else {
      {
#line 844
      tmp = strcasecmp((char const   *)*(argv + 1), "Off");
      }
#line 844
      if (tmp == 0) {
#line 845
        val = 2L;
      } else {
        {
#line 846
        val = atol((char const   *)*(argv + 1));
        }
#line 846
        if (val == 0L) {
          {
#line 847
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"bad color mode `%s\'\n",
                  *(argv + 1));
          }
#line 848
          return (-1);
        }
      }
    }
    {
#line 850
    tmp___1 = eph_setint(iob, 6, val);
    }
#line 850
    return (tmp___1);
  } else {
    {
#line 852
    tmp___3 = strcasecmp((char const   *)*(argv + 1), "On");
    }
#line 852
    if (tmp___3 == 0) {
#line 853
      val &= -17L;
    } else {
      {
#line 854
      tmp___2 = strcasecmp((char const   *)*(argv + 1), "Off");
      }
#line 854
      if (tmp___2 == 0) {
#line 855
        val |= 16L;
      } else {
        {
#line 857
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"bad color mode `%s\'\n",
                *(argv + 1));
        }
#line 858
        return (-1);
      }
    }
    {
#line 860
    tmp___4 = eph_setint(iob, 72, val);
    }
#line 860
    return (tmp___4);
  }
}
}
#line 864 "/home/wheatley/newnew/temp/photopc-3.05/photopc.c"
int dzoom(eph_iob *iob , int argc , char **argv ) 
{ 
  long val ;
  long highbits ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;

  {
  {
#line 867
  val = 0L;
#line 870
  tmp = eph_getint(iob, 72, & val);
  }
#line 870
  if (tmp) {
#line 870
    return (-1);
  }
  {
#line 871
  highbits = (val & 31L) | 8L;
#line 873
  tmp___12 = strcasecmp((char const   *)*(argv + 1), "Zero");
  }
#line 873
  if (tmp___12 == 0) {
#line 874
    val = 0L;
  } else {
    {
#line 875
    tmp___11 = strcasecmp((char const   *)*(argv + 1), "AEL/WBL");
    }
#line 875
    if (tmp___11 == 0) {
#line 876
      val |= 1L;
    } else {
      {
#line 877
      tmp___10 = strcasecmp((char const   *)*(argv + 1), "Reset");
      }
#line 877
      if (tmp___10 == 0) {
#line 878
        val &= 65534L;
      } else {
        {
#line 879
        tmp___9 = strcasecmp((char const   *)*(argv + 1), "Fisheye");
        }
#line 879
        if (tmp___9 == 0) {
#line 880
          val = (val & 65521L) | 2L;
        } else {
          {
#line 881
          tmp___8 = strcasecmp((char const   *)*(argv + 1), "Wide");
          }
#line 881
          if (tmp___8 == 0) {
#line 882
            val = (val & 65521L) | 4L;
          } else {
            {
#line 883
            tmp___7 = strcasecmp((char const   *)*(argv + 1), "Telephoto");
            }
#line 883
            if (tmp___7 == 0) {
#line 884
              val &= 65529L;
            } else {
              {
#line 885
              tmp___6 = strcasecmp((char const   *)*(argv + 1), "Auto");
              }
#line 885
              if (tmp___6 == 0) {
#line 886
                val = highbits & 23L;
              } else {
                {
#line 887
                tmp___5 = strcasecmp((char const   *)*(argv + 1), "1.25X");
                }
#line 887
                if (tmp___5 == 0) {
#line 888
                  val = highbits | 256L;
                } else {
                  {
#line 889
                  tmp___4 = strcasecmp((char const   *)*(argv + 1), "1.6X");
                  }
#line 889
                  if (tmp___4 == 0) {
#line 890
                    val = highbits | 512L;
                  } else {
                    {
#line 891
                    tmp___3 = strcasecmp((char const   *)*(argv + 1), "2.0X");
                    }
#line 891
                    if (tmp___3 == 0) {
#line 892
                      val = highbits | 768L;
                    } else {
                      {
#line 893
                      tmp___2 = strcasecmp((char const   *)*(argv + 1), "2.5X");
                      }
#line 893
                      if (tmp___2 == 0) {
#line 894
                        val = highbits | 1024L;
                      } else {
                        {
#line 895
                        tmp___1 = strcasecmp((char const   *)*(argv + 1), "1.0X");
                        }
#line 895
                        if (tmp___1 == 0) {
#line 896
                          val = highbits | 1280L;
                        } else {
                          {
#line 897
                          tmp___0 = strcasecmp((char const   *)*(argv + 1), "Off");
                          }
#line 897
                          if (tmp___0 == 0) {
#line 898
                            val = highbits | 1280L;
                          } else {
                            {
#line 899
                            val = atol((char const   *)*(argv + 1));
                            }
#line 899
                            if (val == 0L) {
                              {
#line 900
                              fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"bad dzoom mode `%s\'\n",
                                      *(argv + 1));
                              }
#line 901
                              return (-1);
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  {
#line 904
  tmp___13 = eph_setint(iob, 72, val);
  }
#line 904
  return (tmp___13);
}
}
#line 907 "/home/wheatley/newnew/temp/photopc-3.05/photopc.c"
int zoom(eph_iob *iob , int argc , char **argv ) 
{ 
  double val ;
  char buffer[8] ;
  int tmp ;

  {
  {
#line 911
  buffer[0] = (char)0;
#line 911
  buffer[1] = (char)0;
#line 911
  buffer[2] = (char)0;
#line 911
  buffer[3] = (char)0;
#line 911
  buffer[4] = (char)10;
#line 911
  buffer[5] = (char)0;
#line 911
  buffer[6] = (char)0;
#line 911
  buffer[7] = (char)0;
#line 913
  val = atof((char const   *)*(argv + 1));
  }
#line 913
  if (val <= 0.0) {
    {
#line 914
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"bad zoom value `%s\'\n",
            *(argv + 1));
    }
#line 915
    return (-1);
  } else
#line 913
  if (val >= 26.0) {
    {
#line 914
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"bad zoom value `%s\'\n",
            *(argv + 1));
    }
#line 915
    return (-1);
  }
  {
#line 917
  buffer[0] = (char )((unsigned int )(10.0 * val - 0.5));
#line 918
  tmp = eph_setvar(iob, 71, buffer, (off_t )sizeof(buffer));
  }
#line 918
  return (tmp);
}
}
#line 921 "/home/wheatley/newnew/temp/photopc-3.05/photopc.c"
int seti(eph_iob *iob , int argc , char **argv ) 
{ 
  long reg ;
  long val ;
  size_t tmp ;
  size_t tmp___0 ;
  int tmp___1 ;

  {
  {
#line 927
  reg = atol((char const   *)*(argv + 1));
  }
#line 927
  if (reg <= 0L) {
    {
#line 928
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"bad register value \"%s\"\n",
            *(argv + 1));
    }
#line 929
    return (-1);
  }
  {
#line 931
  tmp = strspn((char const   *)*(argv + 2), "0123456789");
#line 931
  tmp___0 = strlen((char const   *)*(argv + 2));
  }
#line 931
  if (tmp != tmp___0) {
    {
#line 932
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"bad set value \"%s\"\n",
            *(argv + 2));
    }
#line 933
    return (-1);
  }
  {
#line 935
  val = atol((char const   *)*(argv + 2));
#line 936
  tmp___1 = eph_setint(iob, (int )reg, val);
  }
#line 936
  return (tmp___1);
}
}
#line 939 "/home/wheatley/newnew/temp/photopc-3.05/photopc.c"
int setv(eph_iob *iob , int argc , char **argv ) 
{ 
  long reg ;
  size_t tmp ;
  int tmp___0 ;

  {
  {
#line 944
  reg = atol((char const   *)*(argv + 1));
  }
#line 944
  if (reg <= 0L) {
    {
#line 945
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"bad register value \"%s\"\n",
            *(argv + 1));
    }
#line 946
    return (-1);
  }
  {
#line 948
  tmp = strlen((char const   *)*(argv + 2));
#line 948
  tmp___0 = eph_setvar(iob, (int )reg, *(argv + 2), (off_t )tmp);
  }
#line 948
  return (tmp___0);
}
}
#line 951 "/home/wheatley/newnew/temp/photopc-3.05/photopc.c"
int snapshot(eph_iob *iob , int argc , char **argv ) 
{ 
  char zero ;
  int tmp ;

  {
  {
#line 954
  zero = (char)0;
#line 956
  tmp = eph_action(iob, 2, & zero, (size_t )1);
  }
#line 956
  if (tmp) {
#line 956
    return (-1);
  } else {
#line 957
    return (0);
  }
}
}
#line 960 "/home/wheatley/newnew/temp/photopc-3.05/photopc.c"
int erase(eph_iob *iob , int argc , char **argv ) 
{ 
  char zero ;
  long frame___0 ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 963
  zero = (char)0;
#line 966
  frame___0 = atol((char const   *)*(argv + 1));
  }
#line 966
  if (frame___0 <= 0L) {
    {
#line 967
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"bad frame number %s\n",
            *(argv + 1));
    }
#line 968
    return (-1);
  }
  {
#line 971
  tmp = eph_setint(iob, 4, frame___0);
  }
#line 971
  if (tmp) {
#line 971
    return (-1);
  }
  {
#line 972
  tmp___0 = eph_action(iob, 7, & zero, (size_t )1);
  }
#line 972
  if (tmp___0) {
#line 972
    return (-1);
  } else {
#line 973
    return (0);
  }
}
}
#line 976 "/home/wheatley/newnew/temp/photopc-3.05/photopc.c"
int protect(eph_iob *iob , int argc , char **argv ) 
{ 
  char pmode ;
  long frame___0 ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 982
  tmp___0 = strcasecmp((char const   *)*(argv + 2), "On");
  }
#line 982
  if (tmp___0 == 0) {
#line 983
    pmode = (char)1;
  } else {
    {
#line 984
    tmp = strcasecmp((char const   *)*(argv + 2), "Off");
    }
#line 984
    if (tmp == 0) {
#line 985
      pmode = (char)0;
    } else {
      {
#line 987
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"bad protect mode `%s\'\n",
              *(argv + 2));
      }
#line 988
      return (-1);
    }
  }
  {
#line 990
  frame___0 = atol((char const   *)*(argv + 1));
  }
#line 990
  if (frame___0 <= 0L) {
    {
#line 991
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"bad frame number %s\n",
            *(argv + 1));
    }
#line 992
    return (-1);
  }
  {
#line 995
  tmp___1 = eph_setint(iob, 4, frame___0);
  }
#line 995
  if (tmp___1) {
#line 995
    return (-1);
  }
  {
#line 996
  tmp___2 = eph_action(iob, 9, & pmode, (size_t )1);
  }
#line 996
  if (tmp___2) {
#line 996
    return (-1);
  } else {
#line 997
    return (0);
  }
}
}
#line 1000 "/home/wheatley/newnew/temp/photopc-3.05/photopc.c"
int eraseall(eph_iob *iob , int argc , char **argv ) 
{ 
  char zero ;
  int tmp ;

  {
  {
#line 1003
  zero = (char)0;
#line 1005
  tmp = eph_action(iob, 1, & zero, (size_t )1);
  }
#line 1005
  if (tmp) {
#line 1005
    return (-1);
  } else {
#line 1006
    return (0);
  }
}
}
#line 1009 "/home/wheatley/newnew/temp/photopc-3.05/photopc.c"
int eraselast(eph_iob *iob , int argc , char **argv ) 
{ 
  char zero ;
  int tmp ;

  {
  {
#line 1012
  zero = (char)0;
#line 1014
  tmp = eph_action(iob, 0, & zero, (size_t )1);
  }
#line 1014
  if (tmp) {
#line 1014
    return (-1);
  } else {
#line 1015
    return (0);
  }
}
}
#line 1018 "/home/wheatley/newnew/temp/photopc-3.05/photopc.c"
int mode(eph_iob *iob , int argc , char **argv ) 
{ 
  char val ;
  long tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
  {
#line 1021
  val = (char)0;
#line 1023
  tmp___5 = strcasecmp((char const   *)*(argv + 1), "Off");
  }
#line 1023
  if (tmp___5 == 0) {
#line 1024
    val = (char)1;
  } else {
    {
#line 1025
    tmp___4 = strcasecmp((char const   *)*(argv + 1), "Record");
    }
#line 1025
    if (tmp___4 == 0) {
#line 1026
      val = (char)2;
    } else {
      {
#line 1027
      tmp___3 = strcasecmp((char const   *)*(argv + 1), "Play");
      }
#line 1027
      if (tmp___3 == 0) {
#line 1028
        val = (char)3;
      } else {
        {
#line 1029
        tmp___2 = strcasecmp((char const   *)*(argv + 1), "Thumbnail");
        }
#line 1029
        if (tmp___2 == 0) {
#line 1030
          val = (char)6;
        } else {
          {
#line 1031
          tmp___1 = strcasecmp((char const   *)*(argv + 1), "Next");
          }
#line 1031
          if (tmp___1 == 0) {
#line 1032
            val = (char)7;
          } else {
            {
#line 1033
            tmp___0 = strcasecmp((char const   *)*(argv + 1), "Previous");
            }
#line 1033
            if (tmp___0 == 0) {
#line 1034
              val = (char)8;
            } else {
              {
#line 1035
              tmp = atol((char const   *)*(argv + 1));
#line 1035
              val = (char )tmp;
              }
#line 1035
              if ((int )val == 0) {
                {
#line 1036
                fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"bad mode `%s\'\n",
                        *(argv + 1));
                }
#line 1037
                return (-1);
              }
            }
          }
        }
      }
    }
  }
  {
#line 1040
  tmp___6 = eph_action(iob, 8, & val, (size_t )1);
  }
#line 1040
  if (tmp___6) {
#line 1040
    return (-1);
  } else {
#line 1041
    return (0);
  }
}
}
#line 1044 "/home/wheatley/newnew/temp/photopc-3.05/photopc.c"
int cmd(eph_iob *iob , int argc , char **argv ) 
{ 
  long ccode ;
  int intarg ;
  char chararg ;
  size_t tmp ;
  size_t tmp___0 ;
  long tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  int tmp___4 ;
  size_t tmp___5 ;
  int tmp___6 ;

  {
  {
#line 1048
  intarg = -1;
#line 1051
  tmp = strspn((char const   *)*(argv + 1), "0123456789");
#line 1051
  tmp___0 = strlen((char const   *)*(argv + 1));
  }
#line 1051
  if (tmp != tmp___0) {
    {
#line 1052
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"bad code value \"%s\"\n",
            *(argv + 1));
    }
#line 1053
    return (-1);
  } else {
    {
#line 1054
    ccode = atol((char const   *)*(argv + 1));
    }
  }
  {
#line 1055
  tmp___2 = strspn((char const   *)*(argv + 2), "0123456789");
#line 1055
  tmp___3 = strlen((char const   *)*(argv + 2));
  }
#line 1055
  if (tmp___2 == tmp___3) {
    {
#line 1056
    tmp___1 = atol((char const   *)*(argv + 2));
#line 1056
    intarg = (int )tmp___1;
    }
  }
#line 1057
  if (intarg >= 0) {
#line 1057
    if (intarg <= 255) {
      {
#line 1058
      chararg = (char )intarg;
#line 1059
      tmp___4 = eph_action(iob, (int )ccode, & chararg, (size_t )1);
      }
#line 1059
      return (tmp___4);
    } else {
      {
#line 1061
      tmp___5 = strlen((char const   *)*(argv + 2));
#line 1061
      tmp___6 = eph_action(iob, (int )ccode, *(argv + 2), tmp___5);
      }
#line 1061
      return (tmp___6);
    }
  } else {
    {
#line 1061
    tmp___5 = strlen((char const   *)*(argv + 2));
#line 1061
    tmp___6 = eph_action(iob, (int )ccode, *(argv + 2), tmp___5);
    }
#line 1061
    return (tmp___6);
  }
}
}
#line 1064 "/home/wheatley/newnew/temp/photopc-3.05/photopc.c"
static char *flashval[5]  = {      (char *)"Auto",      (char *)"Force",      (char *)"Off",      (char *)"AntiRedeye", 
        (char *)"SlowSync"};
#line 1065 "/home/wheatley/newnew/temp/photopc-3.05/photopc.c"
static char *resval[4]  = {      (char *)"Unrecognized",      (char *)"Low",      (char *)"High",      (char *)"Extended"};
#line 1066 "/home/wheatley/newnew/temp/photopc-3.05/photopc.c"
static char *macroval[4]  = {      (char *)"Unrecognized",      (char *)"Macro",      (char *)"Normal",      (char *)"Infinity"};
#line 1067 "/home/wheatley/newnew/temp/photopc-3.05/photopc.c"
static char *aperval[4]  = {      (char *)"Auto",      (char *)"Low",      (char *)"Medium",      (char *)"High"};
#line 1068 "/home/wheatley/newnew/temp/photopc-3.05/photopc.c"
static char *adjval[6]  = {      (char *)"Normal",      (char *)"Contrast+",      (char *)"Contrast-",      (char *)"Brightness+", 
        (char *)"Brightness-",      (char *)"Auto"};
#line 1070 "/home/wheatley/newnew/temp/photopc-3.05/photopc.c"
static char *wbval[7]  = {      (char *)"Auto",      (char *)"Sunny",      (char *)"Incandescent",      (char *)"Fluorescent", 
        (char *)"Unrecognized",      (char *)"Flash",      (char *)"Preset"};
#line 1072 "/home/wheatley/newnew/temp/photopc-3.05/photopc.c"
static char *meterval[7]  = {      (char *)"Unrecognized",      (char *)"Unrecognized",      (char *)"Center",      (char *)"Spot", 
        (char *)"Unrecognized",      (char *)"Matrix",      (char *)"Spot-AF-Area"};
#line 1074 "/home/wheatley/newnew/temp/photopc-3.05/photopc.c"
static char *operval[7]  = {      (char *)"Unrecognized",      (char *)"Off",      (char *)"Record",      (char *)"Play", 
        (char *)"Unrecognized",      (char *)"Unrecognized",      (char *)"Thumbnail"};
#line 1077 "/home/wheatley/newnew/temp/photopc-3.05/photopc.c"
int query(eph_iob *iob , int argc , char **argv ) 
{ 
  long result ;
  char *buffer ;
  off_t bufsize ;
  int rc ;
  void *tmp ;
  char const   *tmp___0 ;
  char *tmp___1 ;
  long tmp___2 ;
  char const   *tmp___3 ;
  char const   *tmp___4 ;
  char const   *tmp___5 ;
  char const   *tmp___6 ;
  char const   *tmp___7 ;
  char const   *tmp___8 ;
  char const   *tmp___9 ;
  char const   *tmp___10 ;
  char const   *tmp___11 ;
  char const   *tmp___12 ;
  long adj ;
  long ezoom ;
  char const   *tmp___13 ;

  {
  {
#line 1085
  tmp = malloc((size_t )2048);
#line 1085
  buffer = (char *)tmp;
#line 1087
  rc = eph_getint(iob, 1, & result);
  }
#line 1087
  if (rc == 0) {
#line 1088
    if (result < 4L) {
#line 1088
      tmp___0 = (char const   *)resval[result];
    } else {
#line 1088
      tmp___0 = "Model-specific";
    }
    {
#line 1088
    printf((char const   */* __restrict  */)"Resolution: %lu - %s\n", (unsigned long )result,
           tmp___0);
    }
  } else
#line 1090
  if (rc == 17) {
    {
#line 1091
    printf((char const   */* __restrict  */)"Resolution unavailable\n");
    }
  } else {
#line 1092
    goto failure;
  }
  {
#line 1094
  rc = eph_getint(iob, 2, & result);
  }
#line 1094
  if (rc == 0) {
#line 1095
    if (result == 0L) {
      {
#line 1096
      printf((char const   */* __restrict  */)"Camera time: not set (%ld)\n", result);
      }
    } else
#line 1095
    if (result == -1L) {
      {
#line 1096
      printf((char const   */* __restrict  */)"Camera time: not set (%ld)\n", result);
      }
    } else {
      {
#line 1098
      tmp___1 = ctimetz(& result, usetimezone);
#line 1098
      printf((char const   */* __restrict  */)"Camera time: %s\n", tmp___1);
      }
    }
  } else
#line 1101
  if (rc == 17) {
    {
#line 1102
    printf((char const   */* __restrict  */)"Camera time unavailable\n");
    }
  } else {
#line 1103
    goto failure;
  }
  {
#line 1105
  rc = eph_getint(iob, 3, & result);
  }
#line 1105
  if (rc == 0) {
#line 1106
    if (result) {
#line 1106
      tmp___2 = 1000000L / result;
    } else {
#line 1106
      tmp___2 = 0L;
    }
    {
#line 1106
    printf((char const   */* __restrict  */)"Shutter: %lu (1/%lu)\n", (unsigned long )result,
           (unsigned long )tmp___2);
    }
  } else
#line 1108
  if (rc == 17) {
    {
#line 1109
    printf((char const   */* __restrict  */)"Shutter unavailable\n");
    }
  } else {
#line 1110
    goto failure;
  }
  {
#line 1112
  rc = eph_getint(iob, 5, & result);
  }
#line 1112
  if (rc == 0) {
#line 1113
    if (result < 4L) {
#line 1113
      tmp___3 = (char const   *)aperval[result];
    } else {
#line 1113
      tmp___3 = "Unrecognized";
    }
    {
#line 1113
    printf((char const   */* __restrict  */)"Aperture: %lu - %s\n", (unsigned long )result,
           tmp___3);
    }
  } else
#line 1115
  if (rc == 17) {
    {
#line 1116
    printf((char const   */* __restrict  */)"Aperture unavailable\n");
    }
  } else {
#line 1117
    goto failure;
  }
  {
#line 1119
  rc = eph_getint(iob, 6, & result);
  }
#line 1119
  if (rc == 0) {
#line 1120
    if (result == 1L) {
#line 1120
      tmp___5 = "Color";
    } else {
#line 1120
      if (result == 2L) {
#line 1120
        tmp___4 = "B/W";
      } else {
#line 1120
        tmp___4 = "Unrecognized";
      }
#line 1120
      tmp___5 = tmp___4;
    }
    {
#line 1120
    printf((char const   */* __restrict  */)"Color mode: %lu - %s\n", result, tmp___5);
    }
  } else
#line 1122
  if (rc == 17) {
    {
#line 1123
    printf((char const   */* __restrict  */)"Color mode unavailable\n");
    }
  } else {
#line 1124
    goto failure;
  }
  {
#line 1126
  rc = eph_getint(iob, 7, & result);
  }
#line 1126
  if (rc == 0) {
#line 1127
    if (result < 5L) {
#line 1127
      tmp___6 = (char const   *)flashval[result];
    } else {
#line 1127
      tmp___6 = "Unrecognized";
    }
    {
#line 1127
    printf((char const   */* __restrict  */)"Flash: %lu - %s\n", (unsigned long )result,
           tmp___6);
    }
  } else
#line 1129
  if (rc == 17) {
    {
#line 1130
    printf((char const   */* __restrict  */)"Flash mode unavailable\n");
    }
  } else {
#line 1131
    goto failure;
  }
  {
#line 1133
  rc = eph_getint(iob, 10, & result);
  }
#line 1133
  if (rc == 0) {
    {
#line 1134
    printf((char const   */* __restrict  */)"Frames in folder: %lu\n", (unsigned long )result);
    }
  } else
#line 1135
  if (rc == 17) {
    {
#line 1136
    printf((char const   */* __restrict  */)"Frames in folder unavailable\n");
    }
  } else {
#line 1137
    goto failure;
  }
  {
#line 1139
  rc = eph_getint(iob, 40, & result);
  }
#line 1139
  if (rc == 0) {
    {
#line 1140
    printf((char const   */* __restrict  */)"Total frames: %lu\n", (unsigned long )result);
    }
  } else
#line 1141
  if (rc == 17) {
    {
#line 1142
    printf((char const   */* __restrict  */)"Total frames unavailable\n");
    }
  } else {
#line 1143
    goto failure;
  }
  {
#line 1145
  rc = eph_getint(iob, 11, & result);
  }
#line 1145
  if (rc == 0) {
    {
#line 1146
    printf((char const   */* __restrict  */)"Frames left: %lu\n", (unsigned long )result);
    }
  } else
#line 1147
  if (rc == 17) {
    {
#line 1148
    printf((char const   */* __restrict  */)"Frames left unavailable\n");
    }
  } else {
#line 1149
    goto failure;
  }
  {
#line 1151
  rc = eph_getint(iob, 16, & result);
  }
#line 1151
  if (rc == 0) {
    {
#line 1152
    printf((char const   */* __restrict  */)"Battery: %lu%%\n", (unsigned long )result);
    }
  } else
#line 1153
  if (rc == 17) {
    {
#line 1154
    printf((char const   */* __restrict  */)"Battery capacity unavailable\n");
    }
  } else {
#line 1155
    goto failure;
  }
  {
#line 1157
  rc = eph_getint(iob, 23, & result);
  }
#line 1157
  if (rc == 0) {
    {
#line 1158
    printf((char const   */* __restrict  */)"Autoshut on host: %lu sec\n", (unsigned long )result);
    }
  } else
#line 1159
  if (rc == 17) {
    {
#line 1160
    printf((char const   */* __restrict  */)"Autoshut on host timer unavailable\n");
    }
  } else {
#line 1161
    goto failure;
  }
  {
#line 1163
  rc = eph_getint(iob, 24, & result);
  }
#line 1163
  if (rc == 0) {
    {
#line 1164
    printf((char const   */* __restrict  */)"Autoshut on field: %lu sec\n", (unsigned long )result);
    }
  } else
#line 1165
  if (rc == 17) {
    {
#line 1166
    printf((char const   */* __restrict  */)"Autoshut on field timer unavailable\n");
    }
  } else {
#line 1167
    goto failure;
  }
  {
#line 1169
  rc = eph_getint(iob, 28, & result);
  }
#line 1169
  if (rc == 0) {
    {
#line 1170
    printf((char const   */* __restrict  */)"Free memory: %lu bytes\n", (unsigned long )result);
    }
  } else
#line 1171
  if (rc == 17) {
    {
#line 1172
    printf((char const   */* __restrict  */)"Free memory size unavailable\n");
    }
  } else {
#line 1173
    goto failure;
  }
  {
#line 1175
  rc = eph_getint(iob, 33, & result);
  }
#line 1175
  if (rc == 0) {
#line 1176
    if (result < 4L) {
#line 1176
      tmp___7 = (char const   *)macroval[result];
    } else {
#line 1176
      tmp___7 = "Unrecognized";
    }
    {
#line 1176
    printf((char const   */* __restrict  */)"Macro mode: %lu - %s\n", result, tmp___7);
    }
  } else
#line 1178
  if (rc == 17) {
    {
#line 1179
    printf((char const   */* __restrict  */)"Macro mode unavailable\n");
    }
  } else {
#line 1180
    goto failure;
  }
  {
#line 1182
  rc = eph_getint(iob, 34, & result);
  }
#line 1182
  if (rc == 0) {
#line 1183
    if (result < 7L) {
#line 1183
      tmp___8 = (char const   *)operval[result];
    } else {
#line 1183
      tmp___8 = "Unrecognized";
    }
    {
#line 1183
    printf((char const   */* __restrict  */)"Operation mode: %lu - %s\n", result,
           tmp___8);
    }
  } else
#line 1185
  if (rc == 17) {
    {
#line 1186
    printf((char const   */* __restrict  */)"Operation mode unavailable\n");
    }
  } else {
#line 1187
    goto failure;
  }
  {
#line 1189
  rc = eph_getint(iob, 19, & result);
  }
#line 1189
  if (rc == 0) {
#line 1190
    if (result < 6L) {
#line 1190
      tmp___9 = (char const   *)adjval[result];
    } else {
#line 1190
      tmp___9 = "Unrecognized";
    }
    {
#line 1190
    printf((char const   */* __restrict  */)"Image adjust: %lu - %s\n", (unsigned long )result,
           tmp___9);
    }
  } else
#line 1192
  if (rc == 17) {
    {
#line 1193
    printf((char const   */* __restrict  */)"Image adjust unavailable\n");
    }
  } else {
#line 1194
    goto failure;
  }
  {
#line 1196
  rc = eph_getint(iob, 20, & result);
  }
#line 1196
  if (rc == 0) {
#line 1197
    if (result < 7L) {
#line 1197
      tmp___11 = (char const   *)wbval[result];
    } else {
#line 1197
      if (result == 255L) {
#line 1197
        tmp___10 = "Cloudy";
      } else {
#line 1197
        tmp___10 = "Unrecognized";
      }
#line 1197
      tmp___11 = tmp___10;
    }
    {
#line 1197
    printf((char const   */* __restrict  */)"White balance: %lu - %s\n", (unsigned long )result,
           tmp___11);
    }
  } else
#line 1200
  if (rc == 17) {
    {
#line 1201
    printf((char const   */* __restrict  */)"White balance unavailable\n");
    }
  } else {
#line 1202
    goto failure;
  }
  {
#line 1204
  rc = eph_getint(iob, 70, & result);
  }
#line 1204
  if (rc == 0) {
#line 1205
    if (result < 7L) {
#line 1205
      tmp___12 = (char const   *)meterval[result];
    } else {
#line 1205
      tmp___12 = "Unrecognized";
    }
    {
#line 1205
    printf((char const   */* __restrict  */)"Metering mode: %lu - %s\n", (unsigned long )result,
           tmp___12);
    }
  } else
#line 1207
  if (rc == 17) {
    {
#line 1208
    printf((char const   */* __restrict  */)"Metering mode unavailable\n");
    }
  } else {
#line 1209
    goto failure;
  }
  {
#line 1211
  rc = eph_getint(iob, 35, & result);
  }
#line 1211
  if (rc == 0) {
    {
#line 1212
    printf((char const   */* __restrict  */)"LCD brightness: %lu (of 7)\n", (unsigned long )result);
    }
  } else
#line 1213
  if (rc == 17) {
    {
#line 1214
    printf((char const   */* __restrict  */)"LCD brightness unavailable\n");
    }
  } else {
#line 1215
    goto failure;
  }
  {
#line 1217
  rc = eph_getint(iob, 38, & result);
  }
#line 1217
  if (rc == 0) {
    {
#line 1218
    printf((char const   */* __restrict  */)"LCD autoshut: %lu sec\n", (unsigned long )result);
    }
  } else
#line 1219
  if (rc == 17) {
    {
#line 1220
    printf((char const   */* __restrict  */)"LCD autoshut timer unavailable\n");
    }
  } else {
#line 1221
    goto failure;
  }
  {
#line 1230
  bufsize = (off_t )2048;
#line 1230
  *(buffer + 0) = (char )'\000';
#line 1231
  rc = eph_getvar(iob, 22, & buffer, & bufsize);
  }
#line 1231
  if (rc == 0) {
    {
#line 1232
    printf((char const   */* __restrict  */)"Camera I.D.: \"%s\"\n", buffer);
    }
  } else
#line 1233
  if (rc == 17) {
    {
#line 1234
    printf((char const   */* __restrict  */)"Camera I.D. unavailable\n");
    }
  } else {
#line 1235
    goto failure;
  }
  {
#line 1237
  bufsize = (off_t )2048;
#line 1237
  *(buffer + 0) = (char )'\000';
#line 1238
  rc = eph_getvar(iob, 25, & buffer, & bufsize);
  }
#line 1238
  if (rc == 0) {
    {
#line 1239
    printf((char const   */* __restrict  */)"Serial No.: \"%s\"\n", buffer);
    }
  } else
#line 1240
  if (rc == 17) {
    {
#line 1241
    printf((char const   */* __restrict  */)"Serial No. unavailable\n");
    }
  } else {
#line 1242
    goto failure;
  }
  {
#line 1244
  bufsize = (off_t )2048;
#line 1244
  *(buffer + 0) = (char )'\000';
#line 1245
  rc = eph_getvar(iob, 26, & buffer, & bufsize);
  }
#line 1245
  if (rc == 0) {
    {
#line 1246
    printf((char const   */* __restrict  */)"Version: \"%s\"\n", buffer);
    }
  } else
#line 1247
  if (rc == 17) {
    {
#line 1248
    printf((char const   */* __restrict  */)"Version unavailable\n");
    }
  } else {
#line 1249
    goto failure;
  }
  {
#line 1251
  bufsize = (off_t )2048;
#line 1251
  *(buffer + 0) = (char )'\000';
#line 1252
  rc = eph_getvar(iob, 27, & buffer, & bufsize);
  }
#line 1252
  if (rc == 0) {
    {
#line 1253
    printf((char const   */* __restrict  */)"Model: \"%s\"\n", buffer);
    }
  } else
#line 1254
  if (rc == 17) {
    {
#line 1255
    printf((char const   */* __restrict  */)"Model unavailable\n");
    }
  } else {
#line 1256
    goto failure;
  }
  {
#line 1258
  bufsize = (off_t )2048;
#line 1258
  *(buffer + 0) = (char )'\000';
#line 1259
  rc = eph_getvar(iob, 48, & buffer, & bufsize);
  }
#line 1259
  if (rc == 0) {
    {
#line 1260
    printf((char const   */* __restrict  */)"Manufacturer: \"%s\"\n", buffer);
    }
  } else
#line 1261
  if (rc == 17) {
    {
#line 1262
    printf((char const   */* __restrict  */)"Manufacturer unavailable\n");
    }
  } else {
#line 1263
    goto failure;
  }
  {
#line 1265
  bufsize = (off_t )2048;
#line 1265
  *(buffer + 0) = (char )'\000';
#line 1266
  rc = eph_getvar(iob, 69, & buffer, & bufsize);
  }
#line 1266
  if (rc == 0) {
    {
#line 1267
    adj = (((long )((int )*(buffer + 0) & 255) + ((long )((int )*(buffer + 1) & 255) << 8)) + ((long )((int )*(buffer + 2) & 255) << 16)) + ((long )((int )*(buffer + 3) & 255) << 24);
#line 1271
    printf((char const   */* __restrict  */)"Shutter adjustment: %ld\n", adj);
    }
  } else
#line 1272
  if (rc == 17) {
    {
#line 1273
    printf((char const   */* __restrict  */)"Shutter adjustment unavailable\n");
    }
  } else {
#line 1274
    goto failure;
  }
  {
#line 1276
  bufsize = (off_t )2048;
#line 1276
  *(buffer + 0) = (char )'\000';
#line 1277
  rc = eph_getvar(iob, 71, & buffer, & bufsize);
  }
#line 1277
  if (rc == 0) {
    {
#line 1278
    ezoom = (((long )((int )*(buffer + 0) & 255) + ((long )((int )*(buffer + 1) & 255) << 8)) + ((long )((int )*(buffer + 2) & 255) << 16)) + ((long )((int )*(buffer + 3) & 255) << 24);
#line 1282
    printf((char const   */* __restrict  */)"Effective zoom: %.1f\n", (double )ezoom * .1);
    }
  } else
#line 1283
  if (rc == 17) {
    {
#line 1284
    printf((char const   */* __restrict  */)"Effective zoom unavailable\n");
    }
  } else {
#line 1285
    goto failure;
  }
  {
#line 1287
  rc = eph_getint(iob, 72, & result);
  }
#line 1287
  if (rc == 0) {
#line 1288
    if (result <= 1L) {
#line 1288
      tmp___13 = "Off";
    } else {
#line 1288
      tmp___13 = "On";
    }
    {
#line 1288
    printf((char const   */* __restrict  */)"Digital zoom mode: %lu - %s\n", (unsigned long )result,
           tmp___13);
    }
  } else
#line 1291
  if (rc == 17) {
    {
#line 1292
    printf((char const   */* __restrict  */)"Digital zoom mode unavailable\n");
    }
  } else {
#line 1293
    goto failure;
  }
  {
#line 1295
  free((void *)buffer);
  }
#line 1296
  return (0);
  failure: 
  {
#line 1299
  free((void *)buffer);
  }
#line 1300
  return (-1);
}
}
#line 1303 "/home/wheatley/newnew/temp/photopc-3.05/photopc.c"
int count(eph_iob *iob , int argc , char **argv ) 
{ 
  long tmp ;

  {
  {
#line 1306
  tmp = numphotos(iob);
#line 1306
  printf((char const   */* __restrict  */)"%ld\n", tmp);
  }
#line 1307
  return (0);
}
}
#line 1310 "/home/wheatley/newnew/temp/photopc-3.05/photopc.c"
int geti(eph_iob *iob , int argc , char **argv ) 
{ 
  long res ;
  long reg ;
  int tmp ;

  {
  {
#line 1316
  reg = atol((char const   *)*(argv + 1));
  }
#line 1316
  if (reg <= 0L) {
    {
#line 1317
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"bad register value \"%s\"\n",
            *(argv + 1));
    }
#line 1318
    return (-1);
  }
  {
#line 1321
  tmp = eph_getint(iob, (int )reg, & res);
  }
#line 1321
  if (tmp) {
#line 1321
    return (-1);
  }
  {
#line 1322
  printf((char const   */* __restrict  */)"Reg %ld=%ld\n", reg, res);
  }
#line 1323
  return (0);
}
}
#line 1326 "/home/wheatley/newnew/temp/photopc-3.05/photopc.c"
int getv(eph_iob *iob , int argc , char **argv ) 
{ 
  char *buffer ;
  void *tmp ;
  off_t bufsize ;
  int i ;
  long reg ;
  int tmp___0 ;

  {
  {
#line 1329
  tmp = malloc((size_t )2048);
#line 1329
  buffer = (char *)tmp;
#line 1330
  bufsize = (off_t )2048;
#line 1334
  reg = atol((char const   *)*(argv + 1));
  }
#line 1334
  if (reg <= 0L) {
    {
#line 1335
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"bad register value \"%s\"\n",
            *(argv + 1));
#line 1336
    free((void *)buffer);
    }
#line 1337
    return (-1);
  }
  {
#line 1340
  *(buffer + 0) = (char )'\000';
#line 1341
  tmp___0 = eph_getvar(iob, (int )reg, & buffer, & bufsize);
  }
#line 1341
  if (tmp___0) {
    {
#line 1342
    free((void *)buffer);
    }
#line 1343
    return (-1);
  }
  {
#line 1345
  printf((char const   */* __restrict  */)"Reg %ld=\"", reg);
#line 1346
  i = 0;
  }
  {
#line 1346
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1346
    if (! ((off_t )i < bufsize)) {
#line 1346
      goto while_break;
    }
#line 1347
    if ((int )*(buffer + i) >= 32) {
#line 1347
      if ((int )*(buffer + i) <= 122) {
        {
#line 1348
        printf((char const   */* __restrict  */)"%c", (int )*(buffer + i));
        }
      } else {
        {
#line 1350
        printf((char const   */* __restrict  */)"\\%03o", (int )((unsigned char )*(buffer + i)));
        }
      }
    } else {
      {
#line 1350
      printf((char const   */* __restrict  */)"\\%03o", (int )((unsigned char )*(buffer + i)));
      }
    }
#line 1346
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1353
  printf((char const   */* __restrict  */)"\"\n");
#line 1354
  free((void *)buffer);
  }
#line 1355
  return (0);
}
}
#line 1358 "/home/wheatley/newnew/temp/photopc-3.05/photopc.c"
int camsum(eph_iob *iob , int argc , char **argv ) 
{ 
  long res ;
  char *buf___1 ;
  void *tmp ;
  off_t bufsize ;
  int i ;
  int tmp___0 ;

  {
  {
#line 1362
  tmp = malloc((size_t )32);
#line 1362
  buf___1 = (char *)tmp;
#line 1363
  bufsize = (off_t )32;
#line 1366
  tmp___0 = eph_getvar(iob, 46, & buf___1, & bufsize);
  }
#line 1366
  if (tmp___0) {
    {
#line 1367
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"cannot get summary data\n");
    }
#line 1368
    return (-1);
  }
#line 1370
  i = 0;
  {
#line 1370
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1370
    if (! (i < 32)) {
#line 1370
      goto while_break;
    }
    {
#line 1371
    res = (((long )((int )*(buf___1 + i) & 255) + ((long )((int )*(buf___1 + (i + 1)) & 255) << 8)) + ((long )((int )*(buf___1 + (i + 2)) & 255) << 16)) + ((long )((int )*(buf___1 + (i + 3)) & 255) << 24);
#line 1373
    printf((char const   */* __restrict  */)"%d: %08lx\n", i / 4, res);
#line 1370
    i += 4;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1375
  free((void *)buf___1);
  }
#line 1376
  return (0);
}
}
#line 1379 "/home/wheatley/newnew/temp/photopc-3.05/photopc.c"
int picsum(eph_iob *iob , int argc , char **argv ) 
{ 
  long res ;
  char *buf___1 ;
  void *tmp ;
  off_t bufsize ;
  long frame___0 ;
  int i ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 1383
  tmp = malloc((size_t )32);
#line 1383
  buf___1 = (char *)tmp;
#line 1384
  bufsize = (off_t )32;
#line 1388
  frame___0 = atol((char const   *)*(argv + 1));
  }
#line 1388
  if (frame___0 <= 0L) {
    {
#line 1389
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"bad frame value \"%s\"\n",
            *(argv + 1));
    }
#line 1390
    return (-1);
  }
  {
#line 1392
  tmp___0 = eph_setint(iob, 4, frame___0);
  }
#line 1392
  if (tmp___0) {
    {
#line 1393
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"cannot set frame frame \"%s\"\n",
            *(argv + 1));
    }
#line 1394
    return (-1);
  }
  {
#line 1397
  tmp___1 = eph_getvar(iob, 47, & buf___1, & bufsize);
  }
#line 1397
  if (tmp___1) {
    {
#line 1398
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"cannot get summary data\n");
    }
#line 1399
    return (-1);
  }
#line 1401
  i = 0;
  {
#line 1401
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1401
    if (! (i < 32)) {
#line 1401
      goto while_break;
    }
    {
#line 1402
    res = (((long )((int )*(buf___1 + i) & 255) + ((long )((int )*(buf___1 + (i + 1)) & 255) << 8)) + ((long )((int )*(buf___1 + (i + 2)) & 255) << 16)) + ((long )((int )*(buf___1 + (i + 3)) & 255) << 24);
#line 1404
    printf((char const   */* __restrict  */)"%d: %08lx ", i / 4, res);
#line 1401
    i += 4;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1406
  printf((char const   */* __restrict  */)"\n");
#line 1407
  free((void *)buf___1);
  }
#line 1408
  return (0);
}
}
#line 1411 "/home/wheatley/newnew/temp/photopc-3.05/photopc.c"
int allregs(eph_iob *iob , int argc , char **argv ) 
{ 
  char *buffer ;
  off_t bufsize ;
  int i ;
  int rc ;
  long j ;
  long max ;
  long res ;
  void *tmp ;

  {
  {
#line 1420
  max = atol((char const   *)*(argv + 1));
  }
#line 1420
  if (max <= 0L) {
    {
#line 1421
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"bad max register value \"%s\"\n",
            *(argv + 1));
    }
#line 1422
    return (-1);
  }
#line 1425
  j = 0L;
  {
#line 1425
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1425
    if (! (j <= max)) {
#line 1425
      goto while_break;
    }
    {
#line 1426
    printf((char const   */* __restrict  */)"%3ld ", j);
    }
#line 1430
    if (j >= 12L) {
#line 1430
      if (j <= 15L) {
        {
#line 1433
        printf((char const   */* __restrict  */)"Reg %ld not queried: dangerous...\n",
               j);
        }
#line 1434
        goto __Cont;
      } else {
#line 1430
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 1430
    if (j == 39L) {
      {
#line 1433
      printf((char const   */* __restrict  */)"Reg %ld not queried: dangerous...\n",
             j);
      }
#line 1434
      goto __Cont;
    } else
#line 1430
    if (j == 43L) {
      {
#line 1433
      printf((char const   */* __restrict  */)"Reg %ld not queried: dangerous...\n",
             j);
      }
#line 1434
      goto __Cont;
    } else
#line 1430
    if (j == 44L) {
      {
#line 1433
      printf((char const   */* __restrict  */)"Reg %ld not queried: dangerous...\n",
             j);
      }
#line 1434
      goto __Cont;
    } else
#line 1430
    if (j == 47L) {
      {
#line 1433
      printf((char const   */* __restrict  */)"Reg %ld not queried: dangerous...\n",
             j);
      }
#line 1434
      goto __Cont;
    }
    {
#line 1436
    rc = eph_getint(iob, (int )j, & res);
    }
#line 1436
    if (rc == 17) {
      {
#line 1437
      printf((char const   */* __restrict  */)"N/A        ");
      }
    } else
#line 1438
    if (rc) {
      {
#line 1439
      printf((char const   */* __restrict  */)"FAIL       ");
      }
    } else {
      {
#line 1441
      printf((char const   */* __restrict  */)"%10ld ", res);
      }
    }
    {
#line 1443
    tmp = malloc((size_t )2048);
#line 1443
    buffer = (char *)tmp;
#line 1444
    *(buffer + 0) = (char )'\000';
#line 1445
    bufsize = (off_t )2048;
#line 1446
    rc = eph_getvar(iob, (int )j, & buffer, & bufsize);
    }
#line 1446
    if (rc == 17) {
      {
#line 1447
      strcpy((char */* __restrict  */)buffer, (char const   */* __restrict  */)"N/A");
      }
    } else
#line 1448
    if (rc) {
      {
#line 1449
      strcpy((char */* __restrict  */)buffer, (char const   */* __restrict  */)"FAIL");
      }
    }
    {
#line 1451
    printf((char const   */* __restrict  */)"\"");
#line 1452
    i = 0;
    }
    {
#line 1452
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1452
      if ((off_t )i < bufsize) {
#line 1452
        if (! (i < 8)) {
#line 1452
          goto while_break___0;
        }
      } else {
#line 1452
        goto while_break___0;
      }
#line 1453
      if ((int )*(buffer + i) >= 32) {
#line 1453
        if ((int )*(buffer + i) <= 122) {
          {
#line 1454
          printf((char const   */* __restrict  */)"%c", (int )*(buffer + i));
          }
        } else {
          {
#line 1456
          printf((char const   */* __restrict  */)"\\%03o", (int )((unsigned char )*(buffer + i)));
          }
        }
      } else {
        {
#line 1456
        printf((char const   */* __restrict  */)"\\%03o", (int )((unsigned char )*(buffer + i)));
        }
      }
#line 1452
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1459
    if ((off_t )i < bufsize) {
      {
#line 1459
      printf((char const   */* __restrict  */)"..");
      }
    }
    {
#line 1460
    printf((char const   */* __restrict  */)"\"\n");
#line 1461
    free((void *)buffer);
    }
    __Cont: /* CIL Label */ 
#line 1425
    j ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1463
  return (0);
}
}
#line 1466 "/home/wheatley/newnew/temp/photopc-3.05/photopc.c"
int listfiles(eph_iob *iob , char *path ) 
{ 
  char *buffer ;
  off_t bufsize ;
  int rc ;
  long res ;
  long j ;
  long max ;
  void *tmp ;
  int tmp___0 ;
  char *tmp___1 ;

  {
  {
#line 1474
  max = numphotos(iob);
  }
#line 1474
  if (max < 0L) {
#line 1475
    return (-1);
  }
#line 1477
  if (have_folders) {
    {
#line 1477
    printf((char const   */* __restrict  */)"%s: ", path);
    }
  }
#line 1478
  if (max) {
    {
#line 1479
    printf((char const   */* __restrict  */)"total %lu\nNo.    Size R P Date and Time                    Filename\n",
           max);
    }
  } else {
    {
#line 1483
    printf((char const   */* __restrict  */)"\n");
    }
  }
  {
#line 1485
  tmp = malloc((size_t )32);
#line 1485
  buffer = (char *)tmp;
#line 1486
  bufsize = (off_t )32;
#line 1487
  j = 1L;
  }
  {
#line 1487
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1487
    if (! (j <= max)) {
#line 1487
      goto while_break;
    }
    {
#line 1488
    printf((char const   */* __restrict  */)"%3ld ", j);
#line 1489
    rc = eph_setint(iob, 4, j);
    }
#line 1489
    if (rc == 17) {
      {
#line 1490
      printf((char const   */* __restrict  */)"%3ld N/A\n", j);
      }
#line 1491
      goto while_break;
    } else
#line 1492
    if (rc) {
      {
#line 1493
      printf((char const   */* __restrict  */)"%3ld FAIL\n", j);
      }
#line 1494
      goto while_break;
    }
    {
#line 1496
    rc = eph_getint(iob, 12, & res);
    }
#line 1496
    if (rc == 17) {
      {
#line 1497
      printf((char const   */* __restrict  */)"%3ld N/A    ", j);
      }
    } else
#line 1498
    if (rc) {
      {
#line 1499
      printf((char const   */* __restrict  */)"%3ld FAIL   ", j);
      }
    } else {
      {
#line 1501
      printf((char const   */* __restrict  */)"%3ld %7ld ", j, res);
      }
    }
    {
#line 1503
    rc = eph_getvar(iob, 47, & buffer, & bufsize);
    }
#line 1503
    if (rc == 17) {
      {
#line 1504
      printf((char const   */* __restrict  */)"N/A\n");
      }
#line 1505
      goto while_break;
    } else
#line 1506
    if (rc) {
      {
#line 1507
      printf((char const   */* __restrict  */)"FAIL\n");
      }
#line 1508
      goto while_break;
    }
    {
#line 1510
    res = (((long )((int )*(buffer + 12) & 255) + ((long )((int )*(buffer + 13) & 255) << 8)) + ((long )((int )*(buffer + 14) & 255) << 16)) + ((long )((int )*(buffer + 15) & 255) << 24);
#line 1512
    printf((char const   */* __restrict  */)"%01ld ", res);
#line 1513
    res = (((long )((int )*(buffer + 16) & 255) + ((long )((int )*(buffer + 17) & 255) << 8)) + ((long )((int )*(buffer + 18) & 255) << 16)) + ((long )((int )*(buffer + 19) & 255) << 24);
    }
#line 1515
    if (res) {
#line 1515
      tmp___0 = 'P';
    } else {
#line 1515
      tmp___0 = '-';
    }
    {
#line 1515
    printf((char const   */* __restrict  */)"%c ", tmp___0);
#line 1516
    res = (((long )((int )*(buffer + 20) & 255) + ((long )((int )*(buffer + 21) & 255) << 8)) + ((long )((int )*(buffer + 22) & 255) << 16)) + ((long )((int )*(buffer + 23) & 255) << 24);
    }
#line 1518
    if (res != -1L) {
      {
#line 1518
      tmp___1 = ctimetz(& res, usetimezone);
#line 1518
      printf((char const   */* __restrict  */)"%8s", tmp___1);
      }
    } else {
      {
#line 1519
      printf((char const   */* __restrict  */)"N/A                         ");
      }
    }
    {
#line 1520
    rc = eph_getvar(iob, 79, & buffer, & bufsize);
    }
#line 1520
    if (rc == 17) {
      {
#line 1521
      printf((char const   */* __restrict  */)" N/A\n");
      }
    } else
#line 1522
    if (rc) {
      {
#line 1523
      printf((char const   */* __restrict  */)" FAIL\n");
      }
    } else {
      {
#line 1525
      printf((char const   */* __restrict  */)" %s\n", buffer);
      }
    }
#line 1487
    j ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1528
  free((void *)buffer);
  }
#line 1529
  return (0);
}
}
#line 1532 "/home/wheatley/newnew/temp/photopc-3.05/photopc.c"
int llistfiles(eph_iob *iob , char *path ) 
{ 
  char *buffer ;
  char *p ;
  unsigned char *ress ;
  off_t bufsize ;
  off_t ressize ;
  int rc ;
  long j ;
  long max ;
  long res ;
  int tmp ;
  void *tmp___0 ;
  unsigned char *tmp___1 ;
  int tmp___2 ;
  unsigned char *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  unsigned char *tmp___6 ;
  int tmp___7 ;
  long tmp___8 ;
  unsigned char *tmp___9 ;
  int tmp___10 ;
  char *tmp___11 ;

  {
  {
#line 1542
  max = numphotos(iob);
  }
#line 1542
  if (max < 0L) {
#line 1543
    return (-1);
  }
#line 1545
  if (have_folders) {
    {
#line 1545
    printf((char const   */* __restrict  */)"%s: ", path);
    }
  }
#line 1546
  if (max) {
    {
#line 1547
    printf((char const   */* __restrict  */)"total %lu\nNo. P    Size R F Shuttr Date and Time\n",
           max);
    }
  } else {
    {
#line 1551
    printf((char const   */* __restrict  */)"\n");
    }
  }
#line 1553
  j = 1L;
  {
#line 1553
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1553
    if (! (j <= max)) {
#line 1553
      goto while_break;
    }
    {
#line 1554
    printf((char const   */* __restrict  */)"%3ld ", j);
#line 1555
    rc = eph_setint(iob, 4, j);
    }
#line 1555
    if (rc == 17) {
      {
#line 1556
      printf((char const   */* __restrict  */)"N/A\n");
      }
#line 1557
      goto while_break;
    } else
#line 1558
    if (rc) {
      {
#line 1559
      printf((char const   */* __restrict  */)"FAIL\n");
      }
#line 1560
      goto while_break;
    }
    {
#line 1562
    rc = eph_getint(iob, 39, & res);
    }
#line 1562
    if (rc == 17) {
      {
#line 1563
      printf((char const   */* __restrict  */)"N ");
      }
    } else
#line 1564
    if (rc) {
      {
#line 1565
      printf((char const   */* __restrict  */)"F ");
      }
    } else {
#line 1567
      if (res) {
#line 1567
        tmp = 'P';
      } else {
#line 1567
        tmp = '-';
      }
      {
#line 1567
      printf((char const   */* __restrict  */)"%c ", tmp);
      }
    }
    {
#line 1569
    rc = eph_getint(iob, 12, & res);
    }
#line 1569
    if (rc == 17) {
      {
#line 1570
      printf((char const   */* __restrict  */)"N/A    ");
      }
    } else
#line 1571
    if (rc) {
      {
#line 1572
      printf((char const   */* __restrict  */)"FAIL   ");
      }
    } else {
      {
#line 1574
      printf((char const   */* __restrict  */)"%7ld ", res);
      }
    }
    {
#line 1576
    tmp___0 = malloc((size_t )2048);
#line 1576
    buffer = (char *)tmp___0;
#line 1577
    *(buffer + 0) = (char )'\000';
#line 1578
    bufsize = (off_t )2048;
#line 1579
    rc = eph_setint(iob, 4, j);
    }
#line 1579
    if (rc == 17) {
      {
#line 1580
      printf((char const   */* __restrict  */)"N/A\n");
      }
#line 1581
      goto while_break;
    } else
#line 1582
    if (rc) {
      {
#line 1583
      printf((char const   */* __restrict  */)"FAIL\n");
      }
#line 1584
      goto while_break;
    }
    {
#line 1586
    rc = eph_getvar(iob, 15, & buffer, & bufsize);
    }
#line 1586
    if (rc == 17) {
      {
#line 1587
      printf((char const   */* __restrict  */)"N/A\n");
      }
#line 1588
      goto while_break;
    } else
#line 1589
    if (rc) {
      {
#line 1590
      printf((char const   */* __restrict  */)"FAIL\n");
      }
#line 1591
      goto while_break;
    }
    {
#line 1593
    ress = (unsigned char *)buffer;
#line 1594
    ressize = bufsize;
#line 1595
    a12scan(& ress, & ressize);
#line 1596
    tmp___1 = a12search((char *)"Resolution", ress, ressize);
#line 1596
    p = (char *)tmp___1;
#line 1597
    res = -1L;
    }
#line 1598
    if (p) {
      {
#line 1599
      tmp___2 = sscanf((char const   */* __restrict  */)p, (char const   */* __restrict  */)"%lu",
                       & res);
      }
#line 1599
      if (tmp___2 != 1) {
#line 1599
        res = -1L;
      }
    }
#line 1601
    if (res != -1L) {
      {
#line 1601
      printf((char const   */* __restrict  */)"%ld ", res);
      }
    } else {
      {
#line 1602
      printf((char const   */* __restrict  */)"N ");
      }
    }
    {
#line 1603
    tmp___3 = a12search((char *)"Flash", ress, ressize);
#line 1603
    p = (char *)tmp___3;
#line 1604
    res = -1L;
    }
#line 1605
    if (p) {
      {
#line 1606
      tmp___4 = sscanf((char const   */* __restrict  */)p, (char const   */* __restrict  */)"%lu",
                       & res);
      }
#line 1606
      if (tmp___4 != 1) {
#line 1606
        res = -1L;
      }
    }
#line 1608
    if (res != -1L) {
#line 1608
      if (res) {
#line 1608
        tmp___5 = 'F';
      } else {
#line 1608
        tmp___5 = '-';
      }
      {
#line 1608
      printf((char const   */* __restrict  */)"%c ", tmp___5);
      }
    } else {
      {
#line 1609
      printf((char const   */* __restrict  */)"N ");
      }
    }
    {
#line 1610
    tmp___6 = a12search((char *)"Shutter", ress, ressize);
#line 1610
    p = (char *)tmp___6;
#line 1611
    res = -1L;
    }
#line 1612
    if (p) {
      {
#line 1613
      tmp___7 = sscanf((char const   */* __restrict  */)p, (char const   */* __restrict  */)"%lu",
                       & res);
      }
#line 1613
      if (tmp___7 != 1) {
#line 1613
        res = -1L;
      }
    }
#line 1615
    if (res != -1L) {
#line 1615
      if (res) {
#line 1615
        tmp___8 = 1000000L / res;
      } else {
#line 1615
        tmp___8 = 0L;
      }
      {
#line 1615
      printf((char const   */* __restrict  */)"1/%-4ld ", tmp___8);
      }
    } else {
      {
#line 1616
      printf((char const   */* __restrict  */)"N/A   ");
      }
    }
    {
#line 1617
    tmp___9 = a12search((char *)"TimeDate", ress, ressize);
#line 1617
    p = (char *)tmp___9;
#line 1618
    res = -1L;
    }
#line 1619
    if (p) {
      {
#line 1620
      tmp___10 = sscanf((char const   */* __restrict  */)p, (char const   */* __restrict  */)"%lu",
                        & res);
      }
#line 1620
      if (tmp___10 != 1) {
#line 1620
        res = -1L;
      }
    }
#line 1622
    if (res != -1L) {
      {
#line 1622
      tmp___11 = ctimetz(& res, usetimezone);
#line 1622
      printf((char const   */* __restrict  */)"%8s\n", tmp___11);
      }
    } else {
      {
#line 1623
      printf((char const   */* __restrict  */)"N/A\n");
      }
    }
    {
#line 1624
    free((void *)buffer);
#line 1553
    j ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1626
  return (0);
}
}
#line 1629 "/home/wheatley/newnew/temp/photopc-3.05/photopc.c"
int list(eph_iob *iob , int argc , char **argv ) 
{ 
  int tmp ;

  {
  {
#line 1632
  tmp = descend(iob, 0, (char *)"\\", & listfiles);
  }
#line 1632
  return (tmp);
}
}
#line 1635 "/home/wheatley/newnew/temp/photopc-3.05/photopc.c"
int llist(eph_iob *iob , int argc , char **argv ) 
{ 
  int tmp ;

  {
  {
#line 1638
  tmp = descend(iob, 0, (char *)"\\", & llistfiles);
  }
#line 1638
  return (tmp);
}
}
#line 1641 "/home/wheatley/newnew/temp/photopc-3.05/photopc.c"
int cd(eph_iob *iob , int argc , char **argv ) 
{ 
  int tmp ;

  {
  {
#line 1644
  tmp = xchdir(iob, *(argv + 1));
  }
#line 1644
  return (tmp);
}
}
#line 1647 "/home/wheatley/newnew/temp/photopc-3.05/photopc.c"
static void reporterror(int errcode , char *errstr ) 
{ 


  {
#line 1650
  if (errcode != 10002) {
    {
#line 1651
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error %d: %s\n",
            errcode, errstr);
    }
  } else
#line 1650
  if (debug) {
    {
#line 1651
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error %d: %s\n",
            errcode, errstr);
    }
  }
#line 1652
  return;
}
}
#line 1654 "/home/wheatley/newnew/temp/photopc-3.05/photopc.c"
void running(off_t count___0 ) 
{ 


  {
#line 1657
  if (! quiet) {
#line 1657
    if (filesize) {
      {
#line 1659
      printf((char const   */* __restrict  */)"%lu: %lu of %lu\r", (unsigned long )frame,
             (unsigned long )count___0, filesize);
#line 1661
      fflush(stdout);
      }
    }
  }
#line 1663
  return;
}
}
#line 1665 "/home/wheatley/newnew/temp/photopc-3.05/photopc.c"
int storing(char *data , size_t len ) 
{ 
  size_t tmp ;

  {
  {
#line 1668
  tmp = fwrite((void const   */* __restrict  */)data, len, (size_t )1, (FILE */* __restrict  */)fp);
  }
#line 1668
  if (tmp != 1UL) {
    {
#line 1669
    perror((char const   *)fname);
    }
#line 1670
    return (-1);
  }
#line 1672
  return (0);
}
}
#line 1675 "/home/wheatley/newnew/temp/photopc-3.05/photopc.c"
int retrfile(eph_iob *iob , int argc , char **argv , int datatype ) 
{ 
  char *filenm ;
  char *buffer ;
  char *buf8i ;
  off_t bufsize ;
  off_t buf8isize ;
  long length ;
  long ilength ;
  long tlength ;
  long alength ;
  off_t got ;
  time_t pictime ;
  unsigned char *res ;
  off_t ressize ;
  char *p ;
  struct stat st ;
  int dreg ;
  int needfillbuffer ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  long ilength2 ;
  int tmp___7 ;
  void *tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  unsigned char *tmp___11 ;
  int tmp___12 ;
  char *tmp___13 ;
  int flen ;
  size_t tmp___14 ;
  void *tmp___15 ;
  size_t tmp___16 ;
  void *tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  char **tmp___21 ;
  int tmp___22 ;
  size_t tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;

  {
  {
#line 1688
  dreg = 0;
#line 1690
  needfillbuffer = 0;
#line 1693
  buf8isize = (off_t )32;
#line 1694
  tmp = malloc((size_t )buf8isize);
#line 1694
  buf8i = (char *)tmp;
  }
#line 1694
  if ((unsigned long )buf8i == (unsigned long )((void *)0)) {
    {
#line 1695
    perror("malloc buf8i");
    }
#line 1696
    return (-1);
  }
  {
#line 1698
  sscanf((char const   */* __restrict  */)*(argv + 1), (char const   */* __restrict  */)"%ld",
         & frame);
#line 1699
  filenm = *(argv + 2);
#line 1700
  tmp___0 = eph_setint(iob, 4, frame);
  }
#line 1700
  if (tmp___0) {
#line 1700
    return (-1);
  }
  {
#line 1701
  tmp___1 = eph_getint(iob, 12, & ilength);
  }
#line 1701
  if (tmp___1) {
#line 1701
    return (-1);
  }
#line 1702
  if (ilength < 0L) {
#line 1703
    if (debug) {
      {
#line 1703
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"uh-oh, size of frame in reg12 negative (%ld), will interpret as positive\n",
              ilength);
      }
    }
#line 1706
    ilength = - ilength;
  }
  {
#line 1708
  tmp___2 = eph_setint(iob, 4, frame);
  }
#line 1708
  if (tmp___2) {
#line 1708
    return (-1);
  }
  {
#line 1709
  tmp___3 = eph_getint(iob, 13, & tlength);
  }
#line 1709
  if (tmp___3) {
#line 1709
    return (-1);
  }
#line 1710
  if (datatype == 2) {
    {
#line 1711
    buf8isize = (off_t )32;
#line 1712
    tmp___4 = eph_setint(iob, 4, frame);
    }
#line 1712
    if (tmp___4) {
#line 1712
      return (-1);
    }
    {
#line 1713
    tmp___5 = eph_getvar(iob, 43, & buf8i, & buf8isize);
    }
#line 1713
    if (tmp___5 == 0) {
#line 1714
      alength = (((long )((int )*(buf8i + 4) & 255) + ((long )((int )*(buf8i + 5) & 255) << 8)) + ((long )((int )*(buf8i + 6) & 255) << 16)) + ((long )((int )*(buf8i + 7) & 255) << 24);
    } else {
#line 1717
      alength = 0L;
    }
#line 1718
    if (debug) {
      {
#line 1718
      printf((char const   */* __restrict  */)"Compressed audio length: %lu\n", alength);
      }
    }
#line 1720
    length = alength;
#line 1720
    filesize = (unsigned long )length;
  } else {
#line 1722
    length = tlength;
#line 1722
    filesize = (unsigned long )length;
#line 1723
    if (datatype == 0) {
#line 1724
      length += ilength;
#line 1725
      filesize = (unsigned long )ilength;
    }
  }
  {
#line 1728
  pictime = (time_t )0;
#line 1729
  buf8isize = (off_t )32;
#line 1730
  tmp___6 = eph_setint(iob, 4, frame);
  }
#line 1730
  if (tmp___6) {
#line 1730
    return (-1);
  }
  {
#line 1731
  tmp___7 = eph_getvar(iob, 47, & buf8i, & buf8isize);
  }
#line 1731
  if (tmp___7 == 0) {
#line 1734
    ilength2 = ((long )((int )*(buf8i + 0) & 255) + ((long )((int )*(buf8i + 1) & 255) << 8)) + ((long )((int )*(buf8i + 2) & 255) << 16);
#line 1736
    if (ilength2) {
#line 1736
      if (ilength == 0L) {
#line 1737
        if (debug) {
          {
#line 1737
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"uh-oh, size of frame in reg12 (%ld) is zero, will use size field from picture summary register (%ld)!\n",
                  ilength, ilength2);
          }
        }
#line 1742
        ilength = ilength2;
      }
    }
#line 1744
    if (ilength == ilength2) {
#line 1745
      pictime = (((long )((int )*(buf8i + 20) & 255) + ((long )((int )*(buf8i + 21) & 255) << 8)) + ((long )((int )*(buf8i + 22) & 255) << 16)) + ((long )((int )*(buf8i + 23) & 255) << 24);
    } else
#line 1750
    if (! quiet) {
      {
#line 1750
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"uh-oh, size of frame in reg12 (%ld) does not match size field from picture summary register (%ld), ignore summary data!\n",
              ilength, ilength2);
      }
    }
  }
#line 1758
  if (debug) {
    {
#line 1758
    printf((char const   */* __restrict  */)"got timestamp from reg47: %lu\n", pictime);
    }
  }
  {
#line 1760
  free((void *)buf8i);
#line 1787
  bufsize = (off_t )0;
#line 1788
  buffer = (char *)((void *)0);
  }
#line 1793
  if (pictime == 0L) {
#line 1793
    if (datatype == 2) {
#line 1794
      needfillbuffer = 1;
    }
  }
#line 1795
  if (datatype == 1) {
#line 1797
    bufsize = ((tlength - 1L) / 2048L + 2L) * 2048L;
  } else
#line 1795
  if (pictime == 0L) {
#line 1795
    if (datatype == 2) {
#line 1797
      bufsize = ((tlength - 1L) / 2048L + 2L) * 2048L;
    } else {
#line 1799
      bufsize = ((length - 1L) / 2048L + 2L) * 2048L;
    }
  } else {
#line 1799
    bufsize = ((length - 1L) / 2048L + 2L) * 2048L;
  }
#line 1809
  if (bufsize) {
    {
#line 1810
    tmp___8 = malloc((size_t )bufsize);
#line 1810
    buffer = (char *)tmp___8;
    }
#line 1811
    if ((unsigned long )buffer == (unsigned long )((void *)0)) {
      {
#line 1812
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"could not alloc %lu bytes\n",
              (unsigned long )bufsize);
      }
#line 1814
      return (-1);
    }
#line 1819
    got = bufsize;
    {
#line 1824
    if (datatype == 1) {
#line 1824
      goto case_1;
    }
#line 1827
    if (datatype == 0) {
#line 1827
      goto case_0;
    }
#line 1830
    if (datatype == 2) {
#line 1830
      goto case_2;
    }
#line 1823
    goto switch_break;
    case_1: /* CIL Label */ 
#line 1825
    dreg = 15;
#line 1826
    goto switch_break;
    case_0: /* CIL Label */ 
#line 1828
    dreg = 14;
#line 1829
    goto switch_break;
    case_2: /* CIL Label */ 
#line 1831
    if (pictime) {
#line 1831
      dreg = 44;
    } else {
#line 1832
      dreg = 15;
    }
#line 1833
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
    {
#line 1836
    tmp___9 = eph_setint(iob, 4, frame);
    }
#line 1836
    if (tmp___9) {
#line 1836
      return (-1);
    }
    {
#line 1837
    tmp___10 = eph_getvar(iob, dreg, & buffer, & got);
    }
#line 1837
    if (tmp___10) {
      {
#line 1838
      free((void *)buffer);
      }
#line 1839
      return (-1);
    }
#line 1841
    if (! quiet) {
      {
#line 1841
      printf((char const   */* __restrict  */)"\n");
      }
    }
  }
#line 1846
  if (pictime == 0L) {
    {
#line 1847
    res = (unsigned char *)buffer;
#line 1848
    ressize = bufsize;
#line 1849
    a12scan(& res, & ressize);
#line 1850
    tmp___11 = a12search((char *)"TimeDate", res, ressize);
#line 1850
    p = (char *)tmp___11;
#line 1851
    pictime = (time_t )-1;
    }
#line 1852
    if (p) {
      {
#line 1853
      tmp___12 = sscanf((char const   */* __restrict  */)p, (char const   */* __restrict  */)"%lu",
                        & pictime);
      }
#line 1853
      if (tmp___12 != 1) {
#line 1854
        pictime = (time_t )-1;
      }
    }
#line 1856
    if (debug) {
      {
#line 1856
      printf((char const   */* __restrict  */)"got timestamp from file: %lu\n", pictime);
      }
    }
  }
#line 1859
  if (! quiet) {
    {
#line 1860
    tmp___13 = ctimetz(& pictime, usetimezone);
#line 1860
    printf((char const   */* __restrict  */)"taken %s\n", tmp___13);
    }
  }
  {
#line 1865
  tmp___19 = strcmp((char const   *)filenm, "-");
  }
#line 1865
  if (tmp___19 == 0) {
#line 1866
    fp = stdout;
  } else {
    {
#line 1868
    tmp___18 = stat((char const   */* __restrict  */)filenm, (struct stat */* __restrict  */)(& st));
    }
#line 1868
    if (tmp___18 == 0) {
#line 1868
      if ((st.st_mode & 61440U) == 16384U) {
        {
#line 1871
        tmp___14 = strlen((char const   *)filenm);
#line 1871
        flen = (int )((tmp___14 + 200UL) + 5UL);
#line 1872
        tmp___15 = malloc((size_t )flen);
#line 1872
        fname = (char *)tmp___15;
        }
#line 1873
        if ((unsigned long )fname == (unsigned long )((void *)0)) {
#line 1874
          if (buffer) {
            {
#line 1874
            free((void *)buffer);
            }
          }
#line 1875
          return (-1);
        }
        {
#line 1877
        makename(fname, flen, filenm, datatype, pictime, nameformat, usetimezone);
        }
#line 1879
        if (! quiet) {
          {
#line 1879
          printf((char const   */* __restrict  */)"file \"%s\"\n", fname);
          }
        }
      } else {
#line 1868
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
      {
#line 1881
      tmp___16 = strlen((char const   *)filenm);
#line 1881
      tmp___17 = malloc(tmp___16 + 1UL);
#line 1881
      fname = (char *)tmp___17;
      }
#line 1882
      if ((unsigned long )fname == (unsigned long )((void *)0)) {
#line 1883
        if (buffer) {
          {
#line 1883
          free((void *)buffer);
          }
        }
#line 1884
        return (-1);
      }
      {
#line 1886
      strcpy((char */* __restrict  */)fname, (char const   */* __restrict  */)filenm);
      }
    }
    {
#line 1888
    fp = fopen((char const   */* __restrict  */)fname, (char const   */* __restrict  */)"w");
    }
#line 1888
    if ((unsigned long )fp == (unsigned long )((void *)0)) {
      {
#line 1889
      perror((char const   *)fname);
      }
#line 1890
      if (fname) {
        {
#line 1890
        free((void *)fname);
        }
      }
#line 1890
      fname = (char *)((void *)0);
#line 1891
      if (buffer) {
        {
#line 1891
        free((void *)buffer);
        }
      }
#line 1892
      return (-1);
    }
  }
#line 1904
  if (needfillbuffer) {
    {
#line 1907
    tmp___20 = eph_setint(iob, 4, frame);
    }
#line 1907
    if (tmp___20) {
#line 1907
      return (-1);
    }
#line 1909
    if (datatype == 2) {
#line 1909
      dreg = 44;
    } else {
#line 1909
      dreg = 14;
    }
#line 1910
    got = bufsize;
#line 1911
    if (buffer) {
#line 1911
      tmp___21 = & buffer;
    } else {
#line 1911
      tmp___21 = (char **)((void *)0);
    }
    {
#line 1911
    tmp___22 = eph_getvar(iob, dreg, tmp___21, & got);
    }
#line 1911
    if (tmp___22) {
      {
#line 1912
      file_abort_cleanup();
#line 1913
      free((void *)buffer);
      }
#line 1914
      return (-1);
    }
#line 1916
    if (! quiet) {
      {
#line 1916
      printf((char const   */* __restrict  */)"\n");
      }
    }
  }
  {
#line 1926
  tmp___23 = fwrite((void const   */* __restrict  */)buffer, (size_t )got, (size_t )1,
                    (FILE */* __restrict  */)fp);
  }
#line 1926
  if (tmp___23 != 1UL) {
    {
#line 1927
    perror((char const   *)fname);
#line 1928
    file_abort_cleanup();
#line 1929
    free((void *)buffer);
    }
#line 1930
    return (-1);
  }
#line 1934
  if (fp) {
    {
#line 1935
    tmp___24 = fclose(fp);
    }
#line 1935
    if (tmp___24 < 0) {
      {
#line 1936
      perror((char const   *)fname);
      }
    }
#line 1938
    fp = (FILE *)((void *)0);
  }
#line 1940
  if (fname) {
#line 1941
    if (setutime) {
      {
#line 1942
      tmp___25 = setfiletime(fname, pictime, pictime, usetimezone);
      }
#line 1942
      if (tmp___25) {
        {
#line 1943
        perror("setfiletime");
        }
      }
    }
    {
#line 1945
    free((void *)fname);
#line 1945
    fname = (char *)((void *)0);
    }
  }
#line 1947
  if (buffer) {
    {
#line 1947
    free((void *)buffer);
    }
  }
#line 1948
  return (0);
}
}
#line 1951 "/home/wheatley/newnew/temp/photopc-3.05/photopc.c"
int image(eph_iob *iob , int argc , char **argv ) 
{ 
  int tmp ;

  {
  {
#line 1954
  tmp = retrfile(iob, argc, argv, 0);
  }
#line 1954
  return (tmp);
}
}
#line 1957 "/home/wheatley/newnew/temp/photopc-3.05/photopc.c"
int thumbnail(eph_iob *iob , int argc , char **argv ) 
{ 
  int tmp ;

  {
  {
#line 1960
  tmp = retrfile(iob, argc, argv, 1);
  }
#line 1960
  return (tmp);
}
}
#line 1963 "/home/wheatley/newnew/temp/photopc-3.05/photopc.c"
int audio(eph_iob *iob , int argc , char **argv ) 
{ 
  int tmp ;

  {
  {
#line 1966
  tmp = retrfile(iob, argc, argv, 2);
  }
#line 1966
  return (tmp);
}
}
#line 1969 "/home/wheatley/newnew/temp/photopc-3.05/photopc.c"
int preview(eph_iob *iob , int argc , char **argv ) 
{ 
  FILE *fp___0 ;
  char *buffer ;
  off_t bufsize ;
  char zero ;
  int rc ;
  void *tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  size_t tmp___6 ;
  int tmp___7 ;

  {
  {
#line 1972
  fp___0 = (FILE *)((void *)0);
#line 1973
  buffer = (char *)((void *)0);
#line 1975
  zero = (char)0;
#line 1976
  rc = -1;
#line 1978
  bufsize = (off_t )2048;
#line 1979
  tmp = malloc((size_t )bufsize);
#line 1979
  buffer = (char *)tmp;
  }
#line 1980
  if ((unsigned long )buffer == (unsigned long )((void *)0)) {
    {
#line 1981
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"could not alloc %lu bytes\n",
            (unsigned long )bufsize);
    }
#line 1983
    goto exit;
  }
  {
#line 1985
  tmp___2 = strcmp((char const   *)*(argv + 1), "-");
  }
#line 1985
  if (tmp___2 == 0) {
#line 1985
    fp___0 = stdout;
  } else {
    {
#line 1986
    fp___0 = fopen((char const   */* __restrict  */)*(argv + 1), (char const   */* __restrict  */)"w");
    }
#line 1986
    if ((unsigned long )fp___0 == (unsigned long )((void *)0)) {
      {
#line 1987
      tmp___0 = __errno_location();
#line 1987
      tmp___1 = strerror(*tmp___0);
#line 1987
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"could not open file %s: %s\n",
              *(argv + 1), tmp___1);
      }
#line 1989
      goto exit;
    }
  }
  {
#line 1991
  tmp___3 = eph_action(iob, 5, & zero, (size_t )1);
  }
#line 1991
  if (tmp___3) {
#line 1991
    goto exit;
  }
  {
#line 1992
  tmp___4 = eph_setint(iob, 4, 0L);
  }
#line 1992
  if (tmp___4) {
#line 1992
    goto exit;
  }
  {
#line 1993
  tmp___5 = eph_getvar(iob, 14, & buffer, & bufsize);
  }
#line 1993
  if (tmp___5) {
#line 1993
    goto exit;
  }
  {
#line 1994
  tmp___6 = fwrite((void const   */* __restrict  */)buffer, (size_t )bufsize, (size_t )1,
                   (FILE */* __restrict  */)fp___0);
  }
#line 1994
  if (tmp___6 != 1UL) {
    {
#line 1995
    perror((char const   *)fname);
    }
#line 1996
    goto exit;
  } else {
#line 1997
    rc = 0;
  }
  exit: 
#line 2000
  if (buffer) {
    {
#line 2000
    free((void *)buffer);
    }
  }
#line 2001
  if (fp___0) {
#line 2001
    if (! ((unsigned long )fp___0 == (unsigned long )stdout)) {
      {
#line 2002
      tmp___7 = fclose(fp___0);
      }
#line 2002
      if (tmp___7 < 0) {
        {
#line 2003
        perror((char const   *)fname);
        }
      }
    }
  }
#line 2006
  return (rc);
}
}
#line 2010 "/home/wheatley/newnew/temp/photopc-3.05/photopc.c"
int upload(eph_iob *iob , int argc , char **argv ) 
{ 
  FILE *fp___0 ;
  char *buffer ;
  struct stat stbuf ;
  long res ;
  char zero ;
  int rc ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  void *tmp___4 ;
  int *tmp___5 ;
  char *tmp___6 ;
  int *tmp___7 ;
  char *tmp___8 ;
  size_t tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;

  {
  {
#line 2013
  fp___0 = (FILE *)((void *)0);
#line 2014
  buffer = (char *)((void *)0);
#line 2017
  zero = (char)0;
#line 2018
  rc = -1;
#line 2020
  tmp___1 = stat((char const   */* __restrict  */)*(argv + 1), (struct stat */* __restrict  */)(& stbuf));
  }
#line 2020
  if (tmp___1) {
    {
#line 2021
    tmp = __errno_location();
#line 2021
    tmp___0 = strerror(*tmp);
#line 2021
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"upload cannot stat file \"%s\": %s\n",
            *(argv + 1), tmp___0);
    }
#line 2023
    goto failure;
  }
  {
#line 2025
  fp___0 = fopen((char const   */* __restrict  */)*(argv + 1), (char const   */* __restrict  */)"r");
  }
#line 2025
  if ((unsigned long )fp___0 == (unsigned long )((void *)0)) {
    {
#line 2026
    tmp___2 = __errno_location();
#line 2026
    tmp___3 = strerror(*tmp___2);
#line 2026
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"upload cannot open file \"%s\": %s\n",
            *(argv + 1), tmp___3);
    }
#line 2028
    goto failure;
  }
#line 2030
  if ((size_t )stbuf.st_size == 0UL) {
    {
#line 2031
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"upload file \"%s\" has zero length\n",
            *(argv + 1));
    }
#line 2033
    goto failure;
  }
  {
#line 2035
  tmp___4 = malloc((size_t )stbuf.st_size);
#line 2035
  buffer = (char *)tmp___4;
  }
#line 2036
  if ((unsigned long )buffer == (unsigned long )((void *)0)) {
    {
#line 2037
    tmp___5 = __errno_location();
#line 2037
    tmp___6 = strerror(*tmp___5);
#line 2037
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"upload cannot allocate %lu bytes: %s\n",
            (unsigned long )stbuf.st_size, tmp___6);
    }
#line 2039
    goto failure;
  }
  {
#line 2041
  tmp___9 = fread((void */* __restrict  */)buffer, (size_t )stbuf.st_size, (size_t )1,
                  (FILE */* __restrict  */)fp___0);
  }
#line 2041
  if (tmp___9 != 1UL) {
    {
#line 2042
    tmp___7 = __errno_location();
#line 2042
    tmp___8 = strerror(*tmp___7);
#line 2042
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"upload cannot read from %s: %s\n",
            *(argv + 1), tmp___8);
    }
#line 2044
    goto failure;
  }
  {
#line 2047
  tmp___10 = eph_getint(iob, 28, & res);
  }
#line 2047
  if (tmp___10) {
    {
#line 2048
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"upload cannot get free memory\n");
    }
#line 2049
    goto failure;
  }
#line 2052
  if (res < stbuf.st_size) {
    {
#line 2053
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"upload free memory %lu less than file size%lu\n",
            res, (unsigned long )stbuf.st_size);
    }
#line 2055
    goto failure;
  }
  {
#line 2058
  tmp___11 = eph_setint(iob, 32, 267124750L);
  }
#line 2058
  if (tmp___11) {
    {
#line 2059
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"upload cannot cast magic spell\n");
    }
#line 2060
    goto failure;
  }
  {
#line 2063
  frame = 0L;
#line 2064
  filesize = (unsigned long )stbuf.st_size;
#line 2066
  tmp___12 = eph_setvar(iob, 29, buffer, stbuf.st_size);
  }
#line 2066
  if (tmp___12) {
#line 2067
    if (! quiet) {
      {
#line 2067
      printf((char const   */* __restrict  */)"\n");
      }
    }
    {
#line 2068
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"upload cannot write image\n");
    }
#line 2069
    goto failure;
  }
#line 2071
  if (! quiet) {
    {
#line 2071
    printf((char const   */* __restrict  */)"\n");
    }
  }
  {
#line 2073
  tmp___13 = eph_action(iob, 11, & zero, (size_t )1);
  }
#line 2073
  if (tmp___13) {
    {
#line 2074
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"upload cannot store image\n");
    }
#line 2075
    goto failure;
  }
#line 2078
  rc = 0;
  failure: 
#line 2081
  if (buffer) {
    {
#line 2081
    free((void *)buffer);
    }
  }
#line 2082
  if (fp___0) {
    {
#line 2082
    fclose(fp___0);
    }
  }
#line 2083
  return (rc);
}
}
#line 2087 "/home/wheatley/newnew/temp/photopc-3.05/photopc.c"
int off(eph_iob *iob , int argc , char **argv ) 
{ 


  {
#line 2090
  switchoff = 1;
#line 2091
  return (0);
}
}
#line 2101 "/home/wheatley/newnew/temp/photopc-3.05/photopc.c"
static int setbit(range_t *range , int index___0 ) 
{ 
  register int pos ;
  register int shift ;
  char *tmp ;
  int newsize ;
  void *tmp___0 ;

  {
#line 2106
  if (index___0 > range->max) {
    {
#line 2110
    newsize = (index___0 / 128 + 1) * 16;
#line 2111
    tmp___0 = malloc((size_t )newsize);
#line 2111
    tmp = (char *)tmp___0;
    }
#line 2112
    if ((unsigned long )tmp == (unsigned long )((void *)0)) {
#line 2112
      return (-1);
    }
    {
#line 2113
    memset((void *)tmp, 0, (size_t )newsize);
#line 2114
    memcpy((void */* __restrict  */)tmp, (void const   */* __restrict  */)range->bits,
           (size_t )range->max / 8UL);
    }
#line 2115
    if (range->max) {
      {
#line 2115
      free((void *)range->bits);
      }
    }
#line 2116
    range->bits = tmp;
#line 2117
    range->max = newsize * 8;
  }
#line 2119
  pos = index___0 / 8;
#line 2120
  shift = index___0 % 8;
#line 2121
  *(range->bits + pos) = (char )((int )*(range->bits + pos) | (1 << shift));
#line 2122
  return (0);
}
}
#line 2125 "/home/wheatley/newnew/temp/photopc-3.05/photopc.c"
static int bitset(range_t *range , int index___0 ) 
{ 
  register int pos ;
  register int shift ;
  int tmp ;

  {
#line 2130
  if (index___0 < 1) {
#line 2130
    return (0);
  } else
#line 2130
  if (index___0 > range->max) {
#line 2130
    return (0);
  }
#line 2131
  pos = index___0 / 8;
#line 2132
  shift = index___0 % 8;
#line 2133
  if ((int )*(range->bits + pos) & (1 << shift)) {
#line 2133
    tmp = 1;
  } else {
#line 2133
    tmp = 0;
  }
#line 2133
  return (tmp);
}
}
#line 2136 "/home/wheatley/newnew/temp/photopc-3.05/photopc.c"
static void freebits(range_t *range ) 
{ 


  {
#line 2139
  if (range->max) {
    {
#line 2139
    free((void *)range->bits);
    }
  }
#line 2140
  range->max = 0;
#line 2141
  return;
}
}
#line 2143 "/home/wheatley/newnew/temp/photopc-3.05/photopc.c"
int iterate(int (*executor)(eph_iob *iob , int argc , char **argv ) , eph_iob *iob ,
            int argc , char **argv , int intvl , int filearg ) 
{ 
  int rc ;
  long bot ;
  long top ;
  long i ;
  long step ;
  char buf___1[16] ;
  char *p ;
  char *intvlarg ;
  struct stat st ;
  range_t range ;
  int reorder ;
  int tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  size_t tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;

  {
#line 2147
  rc = 0;
#line 2152
  reorder = 0;
#line 2154
  if (intvl == 0) {
    {
#line 2154
    tmp = (*executor)(iob, argc, argv);
    }
#line 2154
    return (tmp);
  }
#line 2155
  if (intvl < 0) {
#line 2156
    reorder = 1;
#line 2157
    intvl = - intvl;
#line 2158
    range.max = 0;
  }
#line 2161
  if (filearg) {
    {
#line 2161
    tmp___1 = strchr((char const   *)*(argv + intvl), ',');
    }
#line 2161
    if (tmp___1) {
#line 2161
      goto _L;
    } else {
      {
#line 2161
      tmp___2 = strchr((char const   *)*(argv + intvl), '-');
      }
#line 2161
      if (tmp___2) {
        _L: /* CIL Label */ 
        {
#line 2163
        tmp___0 = stat((char const   */* __restrict  */)*(argv + filearg), (struct stat */* __restrict  */)(& st));
        }
#line 2163
        if (tmp___0) {
          {
#line 2164
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Must specify directory for range\n");
          }
#line 2165
          return (-1);
        } else
#line 2163
        if (! ((st.st_mode & 61440U) == 16384U)) {
          {
#line 2164
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Must specify directory for range\n");
          }
#line 2165
          return (-1);
        }
      }
    }
  }
  {
#line 2169
  intvlarg = *(argv + intvl);
#line 2170
  *(argv + intvl) = buf___1;
#line 2174
  p = strtok((char */* __restrict  */)intvlarg, (char const   */* __restrict  */)",");
  }
  {
#line 2174
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2174
    if (! p) {
#line 2174
      goto while_break;
    }
    {
#line 2175
    tmp___9 = strcasecmp((char const   *)p, "all");
    }
#line 2175
    if (tmp___9 == 0) {
#line 2176
      bot = 1L;
#line 2177
      top = -1L;
    } else {
      {
#line 2178
      tmp___8 = strcasecmp((char const   *)p, "last");
      }
#line 2178
      if (tmp___8 == 0) {
#line 2179
        bot = -1L;
#line 2180
        top = -1L;
      } else {
        {
#line 2181
        tmp___5 = strlen((char const   *)p);
#line 2181
        tmp___6 = strcasecmp((char const   *)((p + tmp___5) - 5), "-last");
        }
#line 2181
        if (tmp___6 == 0) {
          {
#line 2181
          tmp___7 = sscanf((char const   */* __restrict  */)p, (char const   */* __restrict  */)"%ld-last",
                           & bot);
          }
#line 2181
          if (tmp___7 == 1) {
#line 2183
            top = -1L;
          } else {
#line 2181
            goto _L___0;
          }
        } else {
          _L___0: /* CIL Label */ 
          {
#line 2184
          tmp___4 = sscanf((char const   */* __restrict  */)p, (char const   */* __restrict  */)"%ld-%ld",
                           & bot, & top);
          }
#line 2184
          if (! (tmp___4 == 2)) {
            {
#line 2186
            tmp___3 = sscanf((char const   */* __restrict  */)p, (char const   */* __restrict  */)"%ld",
                             & bot);
            }
#line 2186
            if (tmp___3 == 1) {
#line 2187
              top = bot;
            } else {
              {
#line 2189
              fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"bad frames interval \"%s\"\n",
                      p);
              }
#line 2190
              return (-1);
            }
          }
        }
      }
    }
#line 2192
    if (top < 1L) {
      {
#line 2193
      top = numphotos(iob);
      }
#line 2193
      if (top < 0L) {
        {
#line 2194
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"could not get number of frames\n");
        }
#line 2195
        return (-1);
      }
#line 2197
      if (bot < 1L) {
#line 2197
        bot = top;
      }
#line 2198
      if (! quiet) {
        {
#line 2198
        printf((char const   */* __restrict  */)"Processing %ld-%ld\n", bot, top);
        }
      }
#line 2199
      if (top == 0L) {
#line 2200
        if (! quiet) {
          {
#line 2200
          printf((char const   */* __restrict  */)"No frames\n");
          }
        }
#line 2201
        return (0);
      }
    }
#line 2204
    if (top >= bot) {
#line 2204
      step = 1L;
    } else {
#line 2205
      step = -1L;
    }
#line 2206
    top += step;
#line 2207
    i = bot;
    {
#line 2207
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 2207
      if (! (i != top)) {
#line 2207
        goto while_break___0;
      }
#line 2208
      if (reorder) {
        {
#line 2209
        tmp___10 = setbit(& range, (int )i);
        }
#line 2209
        if (tmp___10) {
          {
#line 2210
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"no memory for range\n");
          }
#line 2211
          return (-1);
        }
      } else {
        {
#line 2214
        sprintf((char */* __restrict  */)(buf___1), (char const   */* __restrict  */)"%ld",
                i);
#line 2215
        rc = (*executor)(iob, argc, argv);
        }
#line 2215
        if (rc) {
#line 2215
          return (rc);
        }
      }
#line 2207
      i += step;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 2174
    p = strtok((char */* __restrict  */)((void *)0), (char const   */* __restrict  */)",");
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 2220
  if (reorder) {
#line 2221
    i = (long )range.max;
    {
#line 2221
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 2221
      if (! (i > 0L)) {
#line 2221
        goto while_break___1;
      }
      {
#line 2221
      tmp___11 = bitset(& range, (int )i);
      }
#line 2221
      if (tmp___11) {
        {
#line 2222
        sprintf((char */* __restrict  */)(buf___1), (char const   */* __restrict  */)"%ld",
                i);
#line 2223
        rc = (*executor)(iob, argc, argv);
        }
#line 2223
        if (rc) {
#line 2223
          goto while_break___1;
        }
      }
#line 2221
      i --;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 2225
    freebits(& range);
    }
  }
#line 2228
  return (rc);
}
}
#line 2233 "/home/wheatley/newnew/temp/photopc-3.05/photopc.c"
struct _cmdlist cmdlist[49]  = 
#line 2233
  {      {(char *)"", 0, 0, 0, (int (*)(eph_iob *iob , int argc , char **argv ))((void *)0),
      (char *)"== Query parameters =="}, 
        {(char *)"query", 0, 0, 0, & query, (char *)""}, 
        {(char *)"count", 0, 0, 0, & count, (char *)""}, 
        {(char *)"list", 0, 0, 0, & list, (char *)""}, 
        {(char *)"llist", 0, 0, 0, & llist, (char *)""}, 
        {(char *)"cd", 1, 0, 0, & cd, (char *)"<path>"}, 
        {(char *)"geti", 1, 0, 0, & geti, (char *)"-<reg-no>"}, 
        {(char *)"getv", 1, 0, 0, & getv, (char *)"-<reg-no>"}, 
        {(char *)"camsum", 0, 0, 0, & camsum, (char *)"-"}, 
        {(char *)"picsum", 1, 1, 0, & picsum, (char *)"-<frame-list>"}, 
        {(char *)"allregs", 1, 0, 0, & allregs, (char *)"-<max-reg-no>"}, 
        {(char *)"", 0, 0, 0, (int (*)(eph_iob *iob , int argc , char **argv ))((void *)0),
      (char *)"== Do some actions =="}, 
        {(char *)"protect", 2, 1, 0, & protect, (char *)"<frame-list> `On\' | `Off\'"}, 
        {(char *)"erase",
      1, -1, 0, & erase, (char *)"<frame-list>"}, 
        {(char *)"eraseall", 0, 0, 0, & eraseall, (char *)""}, 
        {(char *)"eraselast", 0, 0, 0, & eraselast, (char *)""}, 
        {(char *)"snapshot", 0, 0, 0, & snapshot, (char *)""}, 
        {(char *)"off", 0, 0, 0, & off, (char *)""}, 
        {(char *)"", 0, 0, 0, (int (*)(eph_iob *iob , int argc , char **argv ))((void *)0),
      (char *)"== Retreive files =="}, 
        {(char *)"image", 2, 1, 2, & image, (char *)"<frame-list> <path>"}, 
        {(char *)"thumbnail", 2, 1, 2, & thumbnail, (char *)"<frame-list> <path>"}, 
        {(char *)"audio", 2, 1, 2, & audio, (char *)"<frame-list> <path>"}, 
        {(char *)"preview", 1, 0, 0, & preview, (char *)"<filename>"}, 
        {(char *)"", 0, 0, 0, (int (*)(eph_iob *iob , int argc , char **argv ))((void *)0),
      (char *)"== Upload files =="}, 
        {(char *)"upload", 1, 0, 0, & upload, (char *)"<filename>"}, 
        {(char *)"", 0, 0, 0, (int (*)(eph_iob *iob , int argc , char **argv ))((void *)0),
      (char *)"== Set parameters =="}, 
        {(char *)"mode", 1, 0, 0, & mode, (char *)"`Record\' | `Play\' | `Thumbnail\' | `Next\' | `Previous\'"}, 
        {(char *)"resolution",
      1, 0, 0, & resolution, (char *)"`Hi\' | `Lo\' | `Ext\' | <number>"}, 
        {(char *)"clock", 0, 0, 0, & setclock, (char *)""}, 
        {(char *)"shutter", 1, 0, 0, & shutter, (char *)"`Auto\' | <microseconds> | 1/<fraction-of-second>"}, 
        {(char *)"aperture",
      1, 0, 0, & aperture, (char *)"`Auto\' | `Lo\' | `Med\' | `Hi\'"}, 
        {(char *)"flash", 1, 0, 0, & flash, (char *)"`Auto\' | `Force\' | `Off\' | `AntiRedeye\' | `SlowSync\'"}, 
        {(char *)"id",
      1, 0, 0, & setid, (char *)"<string>"}, 
        {(char *)"autoshut-host", 1, 0, 0, & autoshut_host, (char *)"<seconds>"}, 
        {(char *)"autoshut-field", 1, 0, 0, & autoshut_field, (char *)"<seconds>"}, 
        {(char *)"lcd-autoshut", 1, 0, 0, & lcd_autoshut, (char *)"<seconds>"}, 
        {(char *)"lcd-brightness", 1, 0, 0, & lcd_brightness, (char *)"1 to 7"}, 
        {(char *)"focus", 1, 0, 0, & focus, (char *)"`Macro\' | `Normal\' | `Infinity\'"}, 
        {(char *)"adjust",
      1, 0, 0, & adjust, (char *)"`Normal\' | `Contrast+\' | `Contrast-\' | `Brightness+\' | `Brightness-\'"}, 
        {(char *)"metering",
      1, 0, 0, & metering, (char *)"`Center-weighted\' | `Spot\' | `Matrix\'"}, 
        {(char *)"whitebalance", 1, 0, 0, & whitebalance, (char *)"`Normal\' | `Sunny\' | `Incandescent\' | `Fluorescent\' | `Flash\' | `Preset\' | `Cloudy\'"}, 
        {(char *)"color",
      1, 0, 0, & color, (char *)"`On\' | `Off\'"}, 
        {(char *)"dzoom", 1, 0, 0, & dzoom, (char *)"`On\' | `Off\' | <number>"}, 
        {(char *)"zoom", 1, 0, 0, & zoom, (char *)"<mm>"}, 
        {(char *)"seti", 2, 0, 0, & seti, (char *)"-<reg-no> <value-to-set>"}, 
        {(char *)"setv", 2, 0, 0, & setv, (char *)"-<reg-no> <value-to-set>"}, 
        {(char *)"cmd", 2, 0, 0, & cmd, (char *)"-<cmd-code> <arg>"}, 
        {(char *)"", 0, 0, 0, (int (*)(eph_iob *iob , int argc , char **argv ))((void *)0),
      (char *)""}, 
        {(char *)((void *)0), 0, 0, 0, (int (*)(eph_iob *iob , int argc , char **argv ))((void *)0),
      (char *)((void *)0)}};
#line 2296 "/home/wheatley/newnew/temp/photopc-3.05/photopc.c"
void showhelp(char *name ) 
{ 
  int i ;

  {
  {
#line 2300
  printf((char const   */* __restrict  */)"usage: %s [-h] [-V] [-v[v]] [-q] [-z] [-t] [-f timeformat] [-s speed] [-l device] [command [params]] ...\n\n",
         name);
#line 2301
  printf((char const   */* __restrict  */)"Options:\n\n");
#line 2302
  printf((char const   */* __restrict  */)"\t-h\t- show this help screen\n");
#line 2303
  printf((char const   */* __restrict  */)"\t-V\t- show software version number\n");
#line 2304
  printf((char const   */* __restrict  */)"\t-v\t- increase debugging verbosity\n");
#line 2305
  printf((char const   */* __restrict  */)"\t-q\t- do not show running download indicator\n");
#line 2306
  printf((char const   */* __restrict  */)"\t-z\t- suppress timezone conversions (camera\'s clock is local time)\n");
#line 2307
  printf((char const   */* __restrict  */)"\t-t\t- set modification time of the files to the time of snapshot\n");
#line 2308
  printf((char const   */* __restrict  */)"\t-f fmt\t- create file names using strftime(3) with the time of snapshot\n");
#line 2309
  printf((char const   */* __restrict  */)"\t\t\t fmt = \'d\' - name is seconds since the epoch in decimal\n");
#line 2310
  printf((char const   */* __restrict  */)"\t\t\t fmt = \'x\' - name is seconds since the epoch in hex\n");
#line 2312
  printf((char const   */* __restrict  */)"\t\t\t fmt = \'1\' - name is MMDD_CCC (default)\n");
#line 2313
  printf((char const   */* __restrict  */)"\t\t\t fmt = \'2\' - name is YYMMDDCC\n");
#line 2314
  printf((char const   */* __restrict  */)"\t\t\t fmt = \'3\' - name is YYYY_MM_DD-HH_MM_SS\n");
#line 2315
  printf((char const   */* __restrict  */)"\t\t\t fmt = \'4\' - name is YYYY/MM/DD/HH_MM_SS\n");
#line 2316
  printf((char const   */* __restrict  */)"\t\t\t otherwise make file names using strftime(3),\n");
#line 2317
  printf((char const   */* __restrict  */)"\t\t\t if fmt contains `%%%%NNNd\' then place count there\n");
#line 2319
  printf((char const   */* __restrict  */)"\t-s baud\t- set communication speed to 9600,19200,38400,57600 or 115200\n");
#line 2320
  printf((char const   */* __restrict  */)"\t\t\tdefault is %d\n", 115200);
#line 2321
  printf((char const   */* __restrict  */)"\t-S baud,baud\t- set \"pseudo\" speed (see manual)\n");
#line 2322
  printf((char const   */* __restrict  */)"\t-l dev\t- use device name instead of default %s\n\n",
         device);
#line 2323
  printf((char const   */* __restrict  */)"Commands:\n");
#line 2324
  i = 0;
  }
  {
#line 2324
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2324
    if (! cmdlist[i].cmd) {
#line 2324
      goto while_break;
    }
#line 2325
    if ((int )*(cmdlist[i].help + 0) == 45) {
#line 2325
      goto __Cont;
    }
    {
#line 2326
    printf((char const   */* __restrict  */)"%-20.20s%s\n", cmdlist[i].cmd, cmdlist[i].help);
    }
    __Cont: /* CIL Label */ 
#line 2324
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2328
  printf((char const   */* __restrict  */)"EXAMPLE:\n%s id \"Eugene Crosser www.average.org\" query\n",
         name);
  }
#line 2329
  return;
}
}
#line 2331 "/home/wheatley/newnew/temp/photopc-3.05/photopc.c"
void showversion(char *name ) 
{ 
  struct utsname uts ;
  int tmp ;

  {
  {
#line 2339
  tmp = uname(& uts);
  }
#line 2339
  if (tmp) {
    {
#line 2340
    strncpy((char */* __restrict  */)(uts.sysname), (char const   */* __restrict  */)"Unix",
            sizeof(uts.sysname));
#line 2341
    uts.sysname[sizeof(uts.sysname) - 1UL] = (char )'\000';
    }
  }
  {
#line 2360
  printf((char const   */* __restrict  */)"%s version %s (%s) build %s (%s memory model)\n",
         name, "3.05", uts.sysname, "Mar  4 2016", "normal");
#line 2368
  printf((char const   */* __restrict  */)"     Copyright (c) 1997-2001 Eugene Crosser and Bruce Lightner\n");
#line 2369
  printf((char const   */* __restrict  */)"     URL: http://www.average.org/digicam/\n");
  }
#line 2370
  return;
}
}
#line 2372 "/home/wheatley/newnew/temp/photopc-3.05/photopc.c"
int main(int argc , char **argv ) 
{ 
  int c ;
  int i ;
  int rc ;
  char *cmd___0 ;
  long speed ;
  long ttspeed ;
  long defttspeed ;
  eph_iob *iob ;
  char *program ;
  struct sched_param sp ;
  int rc___0 ;
  int minp ;
  int maxp ;
  int *tmp ;
  char *tmp___0 ;
  __uid_t tmp___1 ;
  __uid_t tmp___2 ;
  int tmp___3 ;
  char *p ;
  size_t tmp___4 ;
  size_t tmp___5 ;
  void *tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;

  {
  {
#line 2375
  rc = 0;
#line 2377
  speed = 0L;
#line 2377
  ttspeed = 0L;
#line 2377
  defttspeed = 0L;
#line 2379
  program = *(argv + 0);
#line 2394
  tmp___2 = geteuid();
  }
#line 2394
  if (tmp___2 == 0U) {
    {
#line 2399
    minp = sched_get_priority_min(1);
#line 2400
    maxp = sched_get_priority_max(1);
#line 2401
    sp.__sched_priority = minp + (maxp - minp) / 2;
#line 2402
    rc___0 = sched_setscheduler(0, 1, (struct sched_param  const  *)(& sp));
    }
#line 2402
    if (rc___0 == -1) {
      {
#line 2403
      tmp = __errno_location();
#line 2403
      tmp___0 = strerror(*tmp);
#line 2403
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"failed to set realtime priority: %s\n",
              tmp___0);
      }
    }
    {
#line 2417
    tmp___1 = getuid();
#line 2417
    seteuid(tmp___1);
    }
  }
  {
#line 2425
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 2425
    c = getopt(argc, (char * const  *)argv, "l:s:S:f:vqhVzt");
    }
#line 2425
    if (! (c != -1)) {
#line 2425
      goto while_break;
    }
    {
#line 2427
    if (c == 108) {
#line 2427
      goto case_108;
    }
#line 2430
    if (c == 115) {
#line 2430
      goto case_115;
    }
#line 2435
    if (c == 83) {
#line 2435
      goto case_83;
    }
#line 2443
    if (c == 102) {
#line 2443
      goto case_102;
    }
#line 2446
    if (c == 118) {
#line 2446
      goto case_118;
    }
#line 2449
    if (c == 113) {
#line 2449
      goto case_113;
    }
#line 2452
    if (c == 104) {
#line 2452
      goto case_104;
    }
#line 2455
    if (c == 86) {
#line 2455
      goto case_86;
    }
#line 2458
    if (c == 122) {
#line 2458
      goto case_122;
    }
#line 2461
    if (c == 116) {
#line 2461
      goto case_116;
    }
#line 2464
    goto switch_default;
    case_108: /* CIL Label */ 
#line 2428
    device = optarg;
#line 2429
    goto switch_break;
    case_115: /* CIL Label */ 
    {
#line 2433
    speed = atol((char const   *)optarg);
    }
#line 2434
    goto switch_break;
    case_83: /* CIL Label */ 
    {
#line 2438
    tmp___3 = sscanf((char const   */* __restrict  */)optarg, (char const   */* __restrict  */)"%ld,%ld",
                     & defttspeed, & ttspeed);
    }
#line 2438
    if (tmp___3 != 2) {
      {
#line 2439
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"bad `-S\' setting, ignoring\n");
#line 2440
      defttspeed = 0L;
#line 2440
      ttspeed = defttspeed;
      }
    }
#line 2442
    goto switch_break;
    case_102: /* CIL Label */ 
#line 2444
    nameformat = optarg;
#line 2445
    goto switch_break;
    case_118: /* CIL Label */ 
#line 2447
    debug ++;
#line 2448
    goto switch_break;
    case_113: /* CIL Label */ 
#line 2450
    quiet = 1;
#line 2451
    goto switch_break;
    case_104: /* CIL Label */ 
    {
#line 2453
    showhelp(program);
    }
#line 2454
    return (0);
    case_86: /* CIL Label */ 
    {
#line 2456
    showversion(program);
    }
#line 2457
    return (0);
    case_122: /* CIL Label */ 
#line 2459
    usetimezone = 0;
#line 2460
    goto switch_break;
    case_116: /* CIL Label */ 
#line 2462
    setutime = 1;
#line 2463
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 2465
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" run \"%s -h\" for help\n",
            program);
    }
#line 2466
    return (1);
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2478
  tzset();
  }
#line 2494
  if ((int )*device != 47) {
    {
#line 2496
    p = device;
#line 2497
    tmp___4 = strlen("/dev/");
#line 2497
    tmp___5 = strlen((char const   *)p);
#line 2497
    tmp___6 = malloc((tmp___4 + tmp___5) + 1UL);
#line 2497
    device = (char *)tmp___6;
#line 2498
    strcpy((char */* __restrict  */)device, (char const   */* __restrict  */)"/dev/");
#line 2499
    strcat((char */* __restrict  */)device, (char const   */* __restrict  */)p);
    }
  }
  {
#line 2503
  iob = eph_new(& reporterror, (void *(*)(void *old , size_t length ))((void *)0),
                & running, & storing, debug);
  }
#line 2504
  if (! iob) {
    {
#line 2505
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"eph_new failed\n");
    }
#line 2506
    return (1);
  }
  {
#line 2509
  tmp___7 = eph_open(iob, device, speed, defttspeed, ttspeed);
  }
#line 2509
  if (tmp___7) {
    {
#line 2510
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"eph_open failed\n");
    }
#line 2511
    return (1);
  }
  {
#line 2514
  rc = init(iob);
  }
#line 2514
  if (rc) {
    {
#line 2515
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"init failed\n");
    }
#line 2516
    goto exit;
  }
  {
#line 2519
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 2519
    cmd___0 = *(argv + optind);
#line 2519
    if (! cmd___0) {
#line 2519
      goto while_break___0;
    }
#line 2520
    if (switchoff) {
      {
#line 2521
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"commands after \"off\" ignored\n");
      }
#line 2522
      goto exit;
    }
#line 2524
    i = 0;
    {
#line 2524
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 2524
      if (cmdlist[i].cmd) {
        {
#line 2524
        tmp___8 = strcmp((char const   *)cmd___0, (char const   *)cmdlist[i].cmd);
        }
#line 2524
        if (! tmp___8) {
#line 2524
          goto while_break___1;
        }
      } else {
#line 2524
        goto while_break___1;
      }
#line 2524
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 2527
    if ((unsigned long )cmdlist[i].cmd == (unsigned long )((void *)0)) {
      {
#line 2528
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"bad command \"%s\" ignored,",
              cmd___0);
#line 2529
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" run \"%s -h\" for help\n",
              program);
#line 2530
      optind ++;
      }
#line 2531
      goto while_continue___0;
    }
#line 2533
    if (optind + cmdlist[i].argc >= argc) {
      {
#line 2534
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"too few arguments for \"%s\" command\n",
              cmd___0);
#line 2535
      rc = 1;
      }
#line 2536
      goto exit;
    }
    {
#line 2538
    rc = iterate(cmdlist[i].executor, iob, cmdlist[i].argc + 1, argv + optind, cmdlist[i].intvl,
                 cmdlist[i].filearg);
    }
#line 2538
    if (rc) {
      {
#line 2544
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"command \"%s\" failed, abort\n",
              cmd___0);
      }
#line 2545
      goto exit;
    }
#line 2547
    optind += cmdlist[i].argc;
#line 2548
    optind ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  exit: 
  {
#line 2562
  eph_close(iob, switchoff);
#line 2563
  eph_free(iob);
  }
#line 2564
  return (rc);
}
}
#line 32 "/home/wheatley/newnew/temp/photopc-3.05/exifscan.h"
int exifscan(unsigned char **buf___1 , off_t *bufsize ) ;
#line 33
unsigned char *exifsearch(char *key , unsigned char *buf___1 , off_t bufsize ) ;
#line 34
void exifdump(unsigned char *buf___1 , off_t bufsize ) ;
#line 52 "/home/wheatley/newnew/temp/photopc-3.05/exifscan.c"
int exifscan(unsigned char **buf___1 , off_t *bufsize ) 
{ 
  unsigned char *p ;
  off_t length ;
  int tmp ;

  {
#line 56
  length = (off_t )0;
#line 58
  p = *buf___1;
  {
#line 59
  while (1) {
    while_continue: /* CIL Label */ ;
#line 59
    if (! ((unsigned long )p < (unsigned long )(*buf___1 + *bufsize))) {
#line 59
      goto while_break;
    }
    {
#line 60
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 60
      if ((unsigned long )p < (unsigned long )(*buf___1 + *bufsize)) {
#line 60
        if (! ((int )*p != 255)) {
#line 60
          goto while_break___0;
        }
      } else {
#line 60
        goto while_break___0;
      }
#line 60
      p ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 61
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 61
      if ((unsigned long )p < (unsigned long )(*buf___1 + *bufsize)) {
#line 61
        if (! ((int )*p == 255)) {
#line 61
          goto while_break___1;
        }
      } else {
#line 61
        goto while_break___1;
      }
#line 61
      p ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 62
    if ((int )*p == 216) {
#line 62
      goto while_continue;
    }
#line 63
    length = (off_t )(((int )*(p + 1) << 8) + (int )*(p + 2));
#line 64
    if ((int )*p == 225) {
      {
#line 64
      tmp = strcasecmp((char const   *)(p + 3), "Exif");
      }
#line 64
      if (tmp == 0) {
#line 65
        p += 3;
#line 66
        length -= 3L;
#line 67
        goto while_break;
      }
    }
#line 69
    p += length;
  }
  while_break: /* CIL Label */ ;
  }
#line 71
  if ((unsigned long )p >= (unsigned long )(*buf___1 + *bufsize)) {
#line 72
    *bufsize = (off_t )0;
#line 73
    *buf___1 = (unsigned char *)((void *)0);
#line 74
    return (-1);
  }
#line 77
  *bufsize = length;
#line 78
  *buf___1 = p;
#line 79
  return (0);
}
}
#line 82 "/home/wheatley/newnew/temp/photopc-3.05/exifscan.c"
static struct _exifdict exifdict[84]  = 
#line 82
  {      {254, (char *)"NewSubFileType"}, 
        {256, (char *)"ImageWidth"}, 
        {257, (char *)"ImageLength"}, 
        {258, (char *)"BitsPerSample"}, 
        {259, (char *)"Compression"}, 
        {262, (char *)"PhotometricInterpretation"}, 
        {266, (char *)"FillOrder"}, 
        {269, (char *)"DocumentName"}, 
        {270, (char *)"ImageDescription"}, 
        {271, (char *)"Make"}, 
        {272, (char *)"Model"}, 
        {273, (char *)"StripOffsets"}, 
        {274, (char *)"Orientation"}, 
        {277, (char *)"SamplesPerPixel"}, 
        {278, (char *)"RowsPerStrip"}, 
        {279, (char *)"StripByteCounts"}, 
        {282, (char *)"XResolution"}, 
        {283, (char *)"YResolution"}, 
        {284, (char *)"PlanarConfiguration"}, 
        {296, (char *)"ResolutionUnit"}, 
        {301, (char *)"TransferFunction"}, 
        {305, (char *)"Software"}, 
        {306, (char *)"DateTime"}, 
        {315, (char *)"Artist"}, 
        {318, (char *)"WhitePoint"}, 
        {319, (char *)"PrimaryChromaticities"}, 
        {342, (char *)"TransferRange"}, 
        {512, (char *)"JPEGProc"}, 
        {513, (char *)"JPEGInterchangeFormat"}, 
        {514, (char *)"JPEGInterchangeFormatLength"}, 
        {529, (char *)"YCbCrCoefficients"}, 
        {530, (char *)"YCbCrSubSampling"}, 
        {531, (char *)"YCbCrPositioning"}, 
        {532, (char *)"ReferenceBlackWhite"}, 
        {33421, (char *)"CFARepeatPatternDim"}, 
        {33422, (char *)"CFAPattern"}, 
        {33423, (char *)"BatteryLevel"}, 
        {33432, (char *)"Copyright"}, 
        {33434, (char *)"ExposureTime"}, 
        {33437, (char *)"FNumber"}, 
        {33723, (char *)"IPTC/NAA"}, 
        {34665, (char *)"ExifOffset"}, 
        {34675, (char *)"InterColorProfile"}, 
        {34850, (char *)"ExposureProgram"}, 
        {34852, (char *)"SpectralSensitivity"}, 
        {34853, (char *)"GPSInfo"}, 
        {34855, (char *)"ISOSpeedRatings"}, 
        {34856, (char *)"OECF"}, 
        {36864, (char *)"ExifVersion"}, 
        {36867, (char *)"DateTimeOriginal"}, 
        {36868, (char *)"DateTimeDigitized"}, 
        {37121, (char *)"ComponentsConfiguration"}, 
        {37122, (char *)"CompressedBitsPerPixel"}, 
        {37377, (char *)"ShutterSpeedValue"}, 
        {37378, (char *)"ApertureValue"}, 
        {37379, (char *)"BrightnessValue"}, 
        {37380, (char *)"ExposureBiasValue"}, 
        {37381, (char *)"MaxApertureValue"}, 
        {37382, (char *)"SubjectDistance"}, 
        {37383, (char *)"MeteringMode"}, 
        {37384, (char *)"LightSource"}, 
        {37385, (char *)"Flash"}, 
        {37386, (char *)"FocalLength"}, 
        {37500, (char *)"MakerNote"}, 
        {37510, (char *)"UserComment"}, 
        {37520, (char *)"SubSecTime"}, 
        {37521, (char *)"SubSecTimeOriginal"}, 
        {37522, (char *)"SubSecTimeDigitized"}, 
        {40960, (char *)"FlashPixVersion"}, 
        {40961, (char *)"ColorSpace"}, 
        {40962, (char *)"ExifImageWidth"}, 
        {40963, (char *)"ExifImageLength"}, 
        {40965, (char *)"InteroperabilityOffset"}, 
        {41483, (char *)"FlashEnergy"}, 
        {41484, (char *)"SpatialFrequencyResponse"}, 
        {41486, (char *)"FocalPlaneXResolution"}, 
        {41487, (char *)"FocalPlaneYResolution"}, 
        {41488, (char *)"FocalPlaneResolutionUnit"}, 
        {41492, (char *)"SubjectLocation"}, 
        {41493, (char *)"ExposureIndex"}, 
        {41495, (char *)"SensingMethod"}, 
        {41728, (char *)"FileSource"}, 
        {41729, (char *)"SceneType"}, 
        {0, (char *)((void *)0)}};
#line 172 "/home/wheatley/newnew/temp/photopc-3.05/exifscan.c"
static int typlens[10]  = 
#line 172
  {      1,      1,      2,      4, 
        8,      1,      1,      2, 
        4,      8};
#line 174 "/home/wheatley/newnew/temp/photopc-3.05/exifscan.c"
static int s2n_intel(unsigned char *data , int length , int sign ) 
{ 
  int i ;
  int msb ;
  int val ;

  {
#line 177
  val = 0;
#line 178
  i = 0;
  {
#line 178
  while (1) {
    while_continue: /* CIL Label */ ;
#line 178
    if (! (i < length)) {
#line 178
      goto while_break;
    }
#line 179
    val |= (int )*(data + i) << i * 8;
#line 178
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 181
  if (sign) {
#line 182
    msb = 1 << (length * 8 - 1);
#line 183
    if (val & msb) {
#line 183
      val -= msb << 1;
    }
  }
#line 185
  return (val);
}
}
#line 188 "/home/wheatley/newnew/temp/photopc-3.05/exifscan.c"
static int s2n_motorola(unsigned char *data , int length , int sign ) 
{ 
  int i ;
  int msb ;
  int val ;

  {
#line 191
  val = 0;
#line 192
  i = 0;
  {
#line 192
  while (1) {
    while_continue: /* CIL Label */ ;
#line 192
    if (! (i < length)) {
#line 192
      goto while_break;
    }
#line 193
    val = (val << 8) | (int )*(data + i);
#line 192
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 195
  if (sign) {
#line 196
    msb = 1 << (length * 8 - 1);
#line 197
    if (val & msb) {
#line 197
      val -= msb << 1;
    }
  }
#line 199
  return (val);
}
}
#line 202 "/home/wheatley/newnew/temp/photopc-3.05/exifscan.c"
static int (*s2n)(unsigned char *data , int length , int  )  ;
#line 205
static unsigned char *exifwalk(unsigned char *data , int where , unsigned char *(*each)(unsigned char *data ,
                                                                                        int offset ,
                                                                                        int tag ,
                                                                                        int typ ,
                                                                                        int typlen ,
                                                                                        int count ,
                                                                                        void *priv ) ,
                               void *priv ) ;
#line 215
static unsigned char *exifstr(unsigned char *data , int offset , int tag___0 , int typ ,
                              int typlen , int count___0 ) ;
#line 215 "/home/wheatley/newnew/temp/photopc-3.05/exifscan.c"
static unsigned char *buf  =    (unsigned char *)((void *)0);
#line 216 "/home/wheatley/newnew/temp/photopc-3.05/exifscan.c"
static int buflen  =    0;
#line 212 "/home/wheatley/newnew/temp/photopc-3.05/exifscan.c"
static unsigned char *exifstr(unsigned char *data , int offset , int tag___0 , int typ ,
                              int typlen , int count___0 ) 
{ 
  int len ;
  void *tmp ;
  int k ;
  int sig ;
  void *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char const   *tmp___3 ;
  size_t tmp___4 ;
  int tmp___5 ;
  char const   *tmp___6 ;
  size_t tmp___7 ;
  size_t tmp___8 ;

  {
#line 219
  if (typ == 2) {
#line 220
    len = count___0 + 3;
#line 221
    if (len > buflen) {
#line 222
      if (buf) {
        {
#line 222
        free((void *)buf);
        }
      }
      {
#line 223
      tmp = malloc((size_t )len);
#line 223
      buf = (unsigned char *)tmp;
      }
    }
#line 225
    if ((unsigned long )buf == (unsigned long )((void *)0)) {
#line 225
      return ((unsigned char *)"<no memory>");
    }
    {
#line 226
    sprintf((char */* __restrict  */)buf, (char const   */* __restrict  */)"\"%s\"",
            data + offset);
    }
  } else {
#line 231
    len = count___0 * 22 + 3;
#line 232
    if (len > buflen) {
#line 233
      if (buf) {
        {
#line 233
        free((void *)buf);
        }
      }
      {
#line 234
      tmp___0 = malloc((size_t )len);
#line 234
      buf = (unsigned char *)tmp___0;
      }
    }
#line 236
    if ((unsigned long )buf == (unsigned long )((void *)0)) {
#line 236
      return ((unsigned char *)"<no memory>");
    }
#line 237
    *(buf + 0) = (unsigned char )'\000';
#line 238
    if (typ == 6) {
#line 238
      sig = 1;
    } else
#line 238
    if (typ >= 8) {
#line 238
      sig = 1;
    } else {
#line 239
      sig = 0;
    }
#line 240
    if (count___0 > 1) {
      {
#line 240
      sprintf((char */* __restrict  */)buf, (char const   */* __restrict  */)"(");
      }
    }
#line 241
    k = 0;
    {
#line 241
    while (1) {
      while_continue: /* CIL Label */ ;
#line 241
      if (! (k < count___0)) {
#line 241
        goto while_break;
      }
#line 242
      if (typ == 5) {
#line 242
        goto _L;
      } else
#line 242
      if (typ == 10) {
        _L: /* CIL Label */ 
        {
#line 243
        tmp___1 = (*s2n)(((data + offset) + 4) + typlen * k, 4, sig);
#line 243
        tmp___2 = (*s2n)((data + offset) + typlen * k, 4, sig);
        }
#line 243
        if (k) {
#line 243
          tmp___3 = ",";
        } else {
#line 243
          tmp___3 = "";
        }
        {
#line 243
        tmp___4 = strlen((char const   *)buf);
#line 243
        sprintf((char */* __restrict  */)(buf + tmp___4), (char const   */* __restrict  */)"%s%d/%d",
                tmp___3, tmp___2, tmp___1);
        }
      } else {
        {
#line 248
        tmp___5 = (*s2n)((data + offset) + typlen * k, typlen, sig);
        }
#line 248
        if (k) {
#line 248
          tmp___6 = ",";
        } else {
#line 248
          tmp___6 = "";
        }
        {
#line 248
        tmp___7 = strlen((char const   *)buf);
#line 248
        sprintf((char */* __restrict  */)(buf + tmp___7), (char const   */* __restrict  */)"%s%d",
                tmp___6, tmp___5);
        }
      }
#line 241
      k ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 253
    if (count___0 > 1) {
      {
#line 253
      tmp___8 = strlen((char const   *)buf);
#line 253
      sprintf((char */* __restrict  */)(buf + tmp___8), (char const   */* __restrict  */)")");
      }
    }
  }
#line 255
  return (buf);
}
}
#line 258 "/home/wheatley/newnew/temp/photopc-3.05/exifscan.c"
static unsigned char *exifmatch(unsigned char *data , int offset , int tag___0 , int typ ,
                                int typlen , int count___0 , void *priv ) 
{ 
  int i ;
  int needtag ;
  unsigned char *rc ;
  int tmp ;
  unsigned char *tmp___0 ;

  {
#line 263
  needtag = 0;
#line 266
  i = 0;
  {
#line 266
  while (1) {
    while_continue: /* CIL Label */ ;
#line 266
    if (! exifdict[i].tag) {
#line 266
      goto while_break;
    }
    {
#line 267
    tmp = strcmp((char const   *)exifdict[i].name, (char const   *)((char *)priv));
    }
#line 267
    if (tmp == 0) {
#line 268
      needtag = exifdict[i].tag;
#line 269
      goto while_break;
    }
#line 266
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 272
  if (tag___0 == 34665) {
    {
#line 273
    rc = exifwalk(data, offset, & exifmatch, priv);
    }
#line 274
    if (rc) {
#line 274
      return (rc);
    }
  } else
#line 275
  if (tag___0 == 40965) {
    {
#line 276
    rc = exifwalk(data, offset, & exifmatch, priv);
    }
#line 277
    if (rc) {
#line 277
      return (rc);
    }
  }
#line 279
  if (needtag == tag___0) {
    {
#line 280
    tmp___0 = exifstr(data, offset, tag___0, typ, typlen, count___0);
    }
#line 280
    return (tmp___0);
  } else {
#line 281
    return ((unsigned char *)((void *)0));
  }
}
}
#line 284 "/home/wheatley/newnew/temp/photopc-3.05/exifscan.c"
static unsigned char *exifprt(unsigned char *data , int offset , int tag___0 , int typ ,
                              int typlen , int count___0 , void *priv ) 
{ 
  unsigned char *rc ;
  int i ;
  char *tagname ;
  char badtag[32] ;
  unsigned char *tmp ;

  {
#line 290
  tagname = (char *)((void *)0);
#line 292
  i = 0;
  {
#line 292
  while (1) {
    while_continue: /* CIL Label */ ;
#line 292
    if (! exifdict[i].tag) {
#line 292
      goto while_break;
    }
#line 293
    if (exifdict[i].tag == tag___0) {
#line 294
      tagname = exifdict[i].name;
#line 295
      goto while_break;
    }
#line 292
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 298
  if ((unsigned long )tagname == (unsigned long )((void *)0)) {
    {
#line 299
    sprintf((char */* __restrict  */)(badtag), (char const   */* __restrict  */)"TAG#%d",
            tag___0);
#line 300
    tagname = badtag;
    }
  }
#line 302
  if (tag___0 == 34665) {
    {
#line 303
    printf((char const   */* __restrict  */)"<Exif SubIFD>\n");
#line 304
    rc = exifwalk(data, offset, & exifprt, priv);
#line 305
    printf((char const   */* __restrict  */)"</Exif SubIFD>\n");
    }
#line 306
    if (rc) {
#line 306
      return (rc);
    }
  } else
#line 307
  if (tag___0 == 40965) {
    {
#line 308
    printf((char const   */* __restrict  */)"<Interoperability SubIFD>\n");
#line 309
    rc = exifwalk(data, offset, & exifprt, priv);
#line 310
    printf((char const   */* __restrict  */)"</Interoperability SubIFD>\n");
    }
#line 311
    if (rc) {
#line 311
      return (rc);
    }
  } else {
    {
#line 313
    tmp = exifstr(data, offset, tag___0, typ, typlen, count___0);
#line 313
    printf((char const   */* __restrict  */)"%s=%s\n", tagname, tmp);
    }
  }
#line 316
  return ((unsigned char *)((void *)0));
}
}
#line 319 "/home/wheatley/newnew/temp/photopc-3.05/exifscan.c"
static unsigned char *exifwalk(unsigned char *data , int where , unsigned char *(*each)(unsigned char *data ,
                                                                                        int offset ,
                                                                                        int tag ,
                                                                                        int typ ,
                                                                                        int typlen ,
                                                                                        int count ,
                                                                                        void *priv ) ,
                               void *priv ) 
{ 
  unsigned char *rc ;
  int i ;
  int tmp ;
  int ifsnum ;
  int tmp___0 ;
  int j ;
  int typlen ;
  int count___0 ;
  int offset ;
  int entry ;
  int tag___0 ;
  int tmp___1 ;
  int typ ;
  int tmp___2 ;

  {
#line 326
  rc = (unsigned char *)((void *)0);
#line 329
  if (where == 0) {
    {
#line 331
    if ((int )*(data + 0) == 73) {
#line 331
      goto case_73;
    }
#line 332
    if ((int )*(data + 0) == 77) {
#line 332
      goto case_77;
    }
#line 333
    goto switch_default;
    case_73: /* CIL Label */ 
#line 331
    s2n = & s2n_intel;
#line 331
    goto switch_break;
    case_77: /* CIL Label */ 
#line 332
    s2n = & s2n_motorola;
#line 332
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 333
    return ((unsigned char *)((void *)0));
    switch_break: /* CIL Label */ ;
    }
    {
#line 335
    where = (*s2n)(data + 4, 4, 0);
    }
  } else {
    {
#line 336
    where = (*s2n)(data + where, 4, 0);
    }
  }
#line 337
  i = where;
  {
#line 337
  while (1) {
    while_continue: /* CIL Label */ ;
#line 337
    if (! i) {
#line 337
      goto while_break;
    }
    {
#line 338
    tmp___0 = (*s2n)(data + i, 2, 0);
#line 338
    ifsnum = tmp___0;
#line 341
    j = 0;
    }
    {
#line 341
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 341
      if (! (j < ifsnum)) {
#line 341
        goto while_break___0;
      }
      {
#line 344
      entry = (i + 2) + 12 * j;
#line 345
      tmp___1 = (*s2n)(data + entry, 2, 0);
#line 345
      tag___0 = tmp___1;
#line 346
      tmp___2 = (*s2n)((data + entry) + 2, 2, 0);
#line 346
      typ = tmp___2;
      }
#line 347
      if (typ < 1) {
#line 347
        goto __Cont;
      } else
#line 347
      if (typ > 10) {
#line 347
        goto __Cont;
      }
      {
#line 348
      typlen = typlens[typ - 1];
#line 349
      count___0 = (*s2n)((data + entry) + 4, 4, 0);
#line 350
      offset = entry + 8;
      }
#line 351
      if (count___0 * typlen > 4) {
        {
#line 351
        offset = (*s2n)(data + offset, 4, 0);
        }
      }
      {
#line 352
      rc = (*each)(data, offset, tag___0, typ, typlen, count___0, priv);
      }
#line 352
      if (rc) {
#line 354
        return (rc);
      }
      __Cont: /* CIL Label */ 
#line 341
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 337
    tmp = (*s2n)(data + i, 2, 0);
#line 337
    i = (*s2n)(((data + i) + 2) + 12 * tmp, 4, 0);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 357
  return ((unsigned char *)((void *)0));
}
}
#line 360 "/home/wheatley/newnew/temp/photopc-3.05/exifscan.c"
unsigned char *exifsearch(char *key , unsigned char *buf___1 , off_t bufsize ) 
{ 
  unsigned char *tmp ;

  {
#line 363
  if ((unsigned long )buf___1 == (unsigned long )((void *)0)) {
#line 363
    return ((unsigned char *)((void *)0));
  }
  {
#line 364
  tmp = exifwalk(buf___1 + 6, 0, & exifmatch, (void *)key);
  }
#line 364
  return (tmp);
}
}
#line 367 "/home/wheatley/newnew/temp/photopc-3.05/exifscan.c"
void exifdump(unsigned char *buf___1 , off_t bufsize ) 
{ 


  {
#line 370
  if ((unsigned long )buf___1 == (unsigned long )((void *)0)) {
#line 370
    return;
  }
  {
#line 371
  exifwalk(buf___1 + 6, 0, & exifprt, (void *)0);
  }
#line 372
  return;
}
}
#line 214 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2), __leaf__)) fstat)(int __fd ,
                                                                                            struct stat *__buf ) ;
#line 180 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) rename)(char const   *__old ,
                                                                             char const   *__new ) ;
#line 858
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) fileno)(FILE *__stream ) ;
#line 199 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) time_t ( __attribute__((__leaf__)) mktime)(struct tm *__tp ) ;
#line 150 "/home/wheatley/newnew/temp/photopc-3.05/epinfo.c"
static int usetimezone___0  =    1;
#line 151 "/home/wheatley/newnew/temp/photopc-3.05/epinfo.c"
static int setutime___0  =    0;
#line 152 "/home/wheatley/newnew/temp/photopc-3.05/epinfo.c"
static int dorename  =    0;
#line 153 "/home/wheatley/newnew/temp/photopc-3.05/epinfo.c"
static char *nameformat___0  =    (char *)((void *)0);
#line 154 "/home/wheatley/newnew/temp/photopc-3.05/epinfo.c"
static char *tag  =    (char *)((void *)0);
#line 68 "/home/wheatley/newnew/temp/photopc-3.05/ctimez.c"
static struct tm null_tm___0  ;
#line 91 "/home/wheatley/newnew/temp/photopc-3.05/ctimez.c"
static char tmbuf___0[80]  ;
#line 82 "/home/wheatley/newnew/temp/photopc-3.05/exifscan.c"
static struct _exifdict exifdict___0[84]  = 
#line 82 "/home/wheatley/newnew/temp/photopc-3.05/exifscan.c"
  {      {254, (char *)"NewSubFileType"}, 
        {256, (char *)"ImageWidth"}, 
        {257, (char *)"ImageLength"}, 
        {258, (char *)"BitsPerSample"}, 
        {259, (char *)"Compression"}, 
        {262, (char *)"PhotometricInterpretation"}, 
        {266, (char *)"FillOrder"}, 
        {269, (char *)"DocumentName"}, 
        {270, (char *)"ImageDescription"}, 
        {271, (char *)"Make"}, 
        {272, (char *)"Model"}, 
        {273, (char *)"StripOffsets"}, 
        {274, (char *)"Orientation"}, 
        {277, (char *)"SamplesPerPixel"}, 
        {278, (char *)"RowsPerStrip"}, 
        {279, (char *)"StripByteCounts"}, 
        {282, (char *)"XResolution"}, 
        {283, (char *)"YResolution"}, 
        {284, (char *)"PlanarConfiguration"}, 
        {296, (char *)"ResolutionUnit"}, 
        {301, (char *)"TransferFunction"}, 
        {305, (char *)"Software"}, 
        {306, (char *)"DateTime"}, 
        {315, (char *)"Artist"}, 
        {318, (char *)"WhitePoint"}, 
        {319, (char *)"PrimaryChromaticities"}, 
        {342, (char *)"TransferRange"}, 
        {512, (char *)"JPEGProc"}, 
        {513, (char *)"JPEGInterchangeFormat"}, 
        {514, (char *)"JPEGInterchangeFormatLength"}, 
        {529, (char *)"YCbCrCoefficients"}, 
        {530, (char *)"YCbCrSubSampling"}, 
        {531, (char *)"YCbCrPositioning"}, 
        {532, (char *)"ReferenceBlackWhite"}, 
        {33421, (char *)"CFARepeatPatternDim"}, 
        {33422, (char *)"CFAPattern"}, 
        {33423, (char *)"BatteryLevel"}, 
        {33432, (char *)"Copyright"}, 
        {33434, (char *)"ExposureTime"}, 
        {33437, (char *)"FNumber"}, 
        {33723, (char *)"IPTC/NAA"}, 
        {34665, (char *)"ExifOffset"}, 
        {34675, (char *)"InterColorProfile"}, 
        {34850, (char *)"ExposureProgram"}, 
        {34852, (char *)"SpectralSensitivity"}, 
        {34853, (char *)"GPSInfo"}, 
        {34855, (char *)"ISOSpeedRatings"}, 
        {34856, (char *)"OECF"}, 
        {36864, (char *)"ExifVersion"}, 
        {36867, (char *)"DateTimeOriginal"}, 
        {36868, (char *)"DateTimeDigitized"}, 
        {37121, (char *)"ComponentsConfiguration"}, 
        {37122, (char *)"CompressedBitsPerPixel"}, 
        {37377, (char *)"ShutterSpeedValue"}, 
        {37378, (char *)"ApertureValue"}, 
        {37379, (char *)"BrightnessValue"}, 
        {37380, (char *)"ExposureBiasValue"}, 
        {37381, (char *)"MaxApertureValue"}, 
        {37382, (char *)"SubjectDistance"}, 
        {37383, (char *)"MeteringMode"}, 
        {37384, (char *)"LightSource"}, 
        {37385, (char *)"Flash"}, 
        {37386, (char *)"FocalLength"}, 
        {37500, (char *)"MakerNote"}, 
        {37510, (char *)"UserComment"}, 
        {37520, (char *)"SubSecTime"}, 
        {37521, (char *)"SubSecTimeOriginal"}, 
        {37522, (char *)"SubSecTimeDigitized"}, 
        {40960, (char *)"FlashPixVersion"}, 
        {40961, (char *)"ColorSpace"}, 
        {40962, (char *)"ExifImageWidth"}, 
        {40963, (char *)"ExifImageLength"}, 
        {40965, (char *)"InteroperabilityOffset"}, 
        {41483, (char *)"FlashEnergy"}, 
        {41484, (char *)"SpatialFrequencyResponse"}, 
        {41486, (char *)"FocalPlaneXResolution"}, 
        {41487, (char *)"FocalPlaneYResolution"}, 
        {41488, (char *)"FocalPlaneResolutionUnit"}, 
        {41492, (char *)"SubjectLocation"}, 
        {41493, (char *)"ExposureIndex"}, 
        {41495, (char *)"SensingMethod"}, 
        {41728, (char *)"FileSource"}, 
        {41729, (char *)"SceneType"}, 
        {0, (char *)((void *)0)}};
#line 172 "/home/wheatley/newnew/temp/photopc-3.05/exifscan.c"
static int typlens___0[10]  = 
#line 172
  {      1,      1,      2,      4, 
        8,      1,      1,      2, 
        4,      8};
#line 174 "/home/wheatley/newnew/temp/photopc-3.05/exifscan.c"
static int s2n_intel___0(unsigned char *data , int length , int sign ) 
{ 
  int i ;
  int msb ;
  int val ;

  {
#line 177
  val = 0;
#line 178
  i = 0;
  {
#line 178
  while (1) {
    while_continue: /* CIL Label */ ;
#line 178
    if (! (i < length)) {
#line 178
      goto while_break;
    }
#line 179
    val |= (int )*(data + i) << i * 8;
#line 178
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 181
  if (sign) {
#line 182
    msb = 1 << (length * 8 - 1);
#line 183
    if (val & msb) {
#line 183
      val -= msb << 1;
    }
  }
#line 185
  return (val);
}
}
#line 188 "/home/wheatley/newnew/temp/photopc-3.05/exifscan.c"
static int s2n_motorola___0(unsigned char *data , int length , int sign ) 
{ 
  int i ;
  int msb ;
  int val ;

  {
#line 191
  val = 0;
#line 192
  i = 0;
  {
#line 192
  while (1) {
    while_continue: /* CIL Label */ ;
#line 192
    if (! (i < length)) {
#line 192
      goto while_break;
    }
#line 193
    val = (val << 8) | (int )*(data + i);
#line 192
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 195
  if (sign) {
#line 196
    msb = 1 << (length * 8 - 1);
#line 197
    if (val & msb) {
#line 197
      val -= msb << 1;
    }
  }
#line 199
  return (val);
}
}
#line 202 "/home/wheatley/newnew/temp/photopc-3.05/exifscan.c"
static int (*s2n___0)(unsigned char *data , int length , int  )  ;
#line 205
static unsigned char *exifwalk___0(unsigned char *data , int where , unsigned char *(*each)(unsigned char *data ,
                                                                                            int offset ,
                                                                                            int tag ,
                                                                                            int typ ,
                                                                                            int typlen ,
                                                                                            int count ,
                                                                                            void *priv ) ,
                                   void *priv ) ;
#line 215
static unsigned char *exifstr___0(unsigned char *data , int offset , int tag___0 ,
                                  int typ , int typlen , int count___0 ) ;
#line 215 "/home/wheatley/newnew/temp/photopc-3.05/exifscan.c"
static unsigned char *buf___0  =    (unsigned char *)((void *)0);
#line 216 "/home/wheatley/newnew/temp/photopc-3.05/exifscan.c"
static int buflen___0  =    0;
#line 212 "/home/wheatley/newnew/temp/photopc-3.05/exifscan.c"
static unsigned char *exifstr___0(unsigned char *data , int offset , int tag___0 ,
                                  int typ , int typlen , int count___0 ) 
{ 
  int len ;
  void *tmp ;
  int k ;
  int sig ;
  void *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char const   *tmp___3 ;
  size_t tmp___4 ;
  int tmp___5 ;
  char const   *tmp___6 ;
  size_t tmp___7 ;
  size_t tmp___8 ;

  {
#line 219
  if (typ == 2) {
#line 220
    len = count___0 + 3;
#line 221
    if (len > buflen___0) {
#line 222
      if (buf___0) {
        {
#line 222
        free((void *)buf___0);
        }
      }
      {
#line 223
      tmp = malloc((size_t )len);
#line 223
      buf___0 = (unsigned char *)tmp;
      }
    }
#line 225
    if ((unsigned long )buf___0 == (unsigned long )((void *)0)) {
#line 225
      return ((unsigned char *)"<no memory>");
    }
    {
#line 226
    sprintf((char */* __restrict  */)buf___0, (char const   */* __restrict  */)"\"%s\"",
            data + offset);
    }
  } else {
#line 231
    len = count___0 * 22 + 3;
#line 232
    if (len > buflen___0) {
#line 233
      if (buf___0) {
        {
#line 233
        free((void *)buf___0);
        }
      }
      {
#line 234
      tmp___0 = malloc((size_t )len);
#line 234
      buf___0 = (unsigned char *)tmp___0;
      }
    }
#line 236
    if ((unsigned long )buf___0 == (unsigned long )((void *)0)) {
#line 236
      return ((unsigned char *)"<no memory>");
    }
#line 237
    *(buf___0 + 0) = (unsigned char )'\000';
#line 238
    if (typ == 6) {
#line 238
      sig = 1;
    } else
#line 238
    if (typ >= 8) {
#line 238
      sig = 1;
    } else {
#line 239
      sig = 0;
    }
#line 240
    if (count___0 > 1) {
      {
#line 240
      sprintf((char */* __restrict  */)buf___0, (char const   */* __restrict  */)"(");
      }
    }
#line 241
    k = 0;
    {
#line 241
    while (1) {
      while_continue: /* CIL Label */ ;
#line 241
      if (! (k < count___0)) {
#line 241
        goto while_break;
      }
#line 242
      if (typ == 5) {
#line 242
        goto _L;
      } else
#line 242
      if (typ == 10) {
        _L: /* CIL Label */ 
        {
#line 243
        tmp___1 = (*s2n___0)(((data + offset) + 4) + typlen * k, 4, sig);
#line 243
        tmp___2 = (*s2n___0)((data + offset) + typlen * k, 4, sig);
        }
#line 243
        if (k) {
#line 243
          tmp___3 = ",";
        } else {
#line 243
          tmp___3 = "";
        }
        {
#line 243
        tmp___4 = strlen((char const   *)buf___0);
#line 243
        sprintf((char */* __restrict  */)(buf___0 + tmp___4), (char const   */* __restrict  */)"%s%d/%d",
                tmp___3, tmp___2, tmp___1);
        }
      } else {
        {
#line 248
        tmp___5 = (*s2n___0)((data + offset) + typlen * k, typlen, sig);
        }
#line 248
        if (k) {
#line 248
          tmp___6 = ",";
        } else {
#line 248
          tmp___6 = "";
        }
        {
#line 248
        tmp___7 = strlen((char const   *)buf___0);
#line 248
        sprintf((char */* __restrict  */)(buf___0 + tmp___7), (char const   */* __restrict  */)"%s%d",
                tmp___6, tmp___5);
        }
      }
#line 241
      k ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 253
    if (count___0 > 1) {
      {
#line 253
      tmp___8 = strlen((char const   *)buf___0);
#line 253
      sprintf((char */* __restrict  */)(buf___0 + tmp___8), (char const   */* __restrict  */)")");
      }
    }
  }
#line 255
  return (buf___0);
}
}
#line 258 "/home/wheatley/newnew/temp/photopc-3.05/exifscan.c"
static unsigned char *exifmatch___0(unsigned char *data , int offset , int tag___0 ,
                                    int typ , int typlen , int count___0 , void *priv ) 
{ 
  int i ;
  int needtag ;
  unsigned char *rc ;
  int tmp ;
  unsigned char *tmp___0 ;

  {
#line 263
  needtag = 0;
#line 266
  i = 0;
  {
#line 266
  while (1) {
    while_continue: /* CIL Label */ ;
#line 266
    if (! exifdict___0[i].tag) {
#line 266
      goto while_break;
    }
    {
#line 267
    tmp = strcmp((char const   *)exifdict___0[i].name, (char const   *)((char *)priv));
    }
#line 267
    if (tmp == 0) {
#line 268
      needtag = exifdict___0[i].tag;
#line 269
      goto while_break;
    }
#line 266
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 272
  if (tag___0 == 34665) {
    {
#line 273
    rc = exifwalk___0(data, offset, & exifmatch___0, priv);
    }
#line 274
    if (rc) {
#line 274
      return (rc);
    }
  } else
#line 275
  if (tag___0 == 40965) {
    {
#line 276
    rc = exifwalk___0(data, offset, & exifmatch___0, priv);
    }
#line 277
    if (rc) {
#line 277
      return (rc);
    }
  }
#line 279
  if (needtag == tag___0) {
    {
#line 280
    tmp___0 = exifstr___0(data, offset, tag___0, typ, typlen, count___0);
    }
#line 280
    return (tmp___0);
  } else {
#line 281
    return ((unsigned char *)((void *)0));
  }
}
}
#line 284 "/home/wheatley/newnew/temp/photopc-3.05/exifscan.c"
static unsigned char *exifprt___0(unsigned char *data , int offset , int tag___0 ,
                                  int typ , int typlen , int count___0 , void *priv ) 
{ 
  unsigned char *rc ;
  int i ;
  char *tagname ;
  char badtag[32] ;
  unsigned char *tmp ;

  {
#line 290
  tagname = (char *)((void *)0);
#line 292
  i = 0;
  {
#line 292
  while (1) {
    while_continue: /* CIL Label */ ;
#line 292
    if (! exifdict___0[i].tag) {
#line 292
      goto while_break;
    }
#line 293
    if (exifdict___0[i].tag == tag___0) {
#line 294
      tagname = exifdict___0[i].name;
#line 295
      goto while_break;
    }
#line 292
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 298
  if ((unsigned long )tagname == (unsigned long )((void *)0)) {
    {
#line 299
    sprintf((char */* __restrict  */)(badtag), (char const   */* __restrict  */)"TAG#%d",
            tag___0);
#line 300
    tagname = badtag;
    }
  }
#line 302
  if (tag___0 == 34665) {
    {
#line 303
    printf((char const   */* __restrict  */)"<Exif SubIFD>\n");
#line 304
    rc = exifwalk___0(data, offset, & exifprt___0, priv);
#line 305
    printf((char const   */* __restrict  */)"</Exif SubIFD>\n");
    }
#line 306
    if (rc) {
#line 306
      return (rc);
    }
  } else
#line 307
  if (tag___0 == 40965) {
    {
#line 308
    printf((char const   */* __restrict  */)"<Interoperability SubIFD>\n");
#line 309
    rc = exifwalk___0(data, offset, & exifprt___0, priv);
#line 310
    printf((char const   */* __restrict  */)"</Interoperability SubIFD>\n");
    }
#line 311
    if (rc) {
#line 311
      return (rc);
    }
  } else {
    {
#line 313
    tmp = exifstr___0(data, offset, tag___0, typ, typlen, count___0);
#line 313
    printf((char const   */* __restrict  */)"%s=%s\n", tagname, tmp);
    }
  }
#line 316
  return ((unsigned char *)((void *)0));
}
}
#line 319 "/home/wheatley/newnew/temp/photopc-3.05/exifscan.c"
static unsigned char *exifwalk___0(unsigned char *data , int where , unsigned char *(*each)(unsigned char *data ,
                                                                                            int offset ,
                                                                                            int tag ,
                                                                                            int typ ,
                                                                                            int typlen ,
                                                                                            int count ,
                                                                                            void *priv ) ,
                                   void *priv ) 
{ 
  unsigned char *rc ;
  int i ;
  int tmp ;
  int ifsnum ;
  int tmp___0 ;
  int j ;
  int typlen ;
  int count___0 ;
  int offset ;
  int entry ;
  int tag___0 ;
  int tmp___1 ;
  int typ ;
  int tmp___2 ;

  {
#line 326
  rc = (unsigned char *)((void *)0);
#line 329
  if (where == 0) {
    {
#line 331
    if ((int )*(data + 0) == 73) {
#line 331
      goto case_73;
    }
#line 332
    if ((int )*(data + 0) == 77) {
#line 332
      goto case_77;
    }
#line 333
    goto switch_default;
    case_73: /* CIL Label */ 
#line 331
    s2n___0 = & s2n_intel___0;
#line 331
    goto switch_break;
    case_77: /* CIL Label */ 
#line 332
    s2n___0 = & s2n_motorola___0;
#line 332
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 333
    return ((unsigned char *)((void *)0));
    switch_break: /* CIL Label */ ;
    }
    {
#line 335
    where = (*s2n___0)(data + 4, 4, 0);
    }
  } else {
    {
#line 336
    where = (*s2n___0)(data + where, 4, 0);
    }
  }
#line 337
  i = where;
  {
#line 337
  while (1) {
    while_continue: /* CIL Label */ ;
#line 337
    if (! i) {
#line 337
      goto while_break;
    }
    {
#line 338
    tmp___0 = (*s2n___0)(data + i, 2, 0);
#line 338
    ifsnum = tmp___0;
#line 341
    j = 0;
    }
    {
#line 341
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 341
      if (! (j < ifsnum)) {
#line 341
        goto while_break___0;
      }
      {
#line 344
      entry = (i + 2) + 12 * j;
#line 345
      tmp___1 = (*s2n___0)(data + entry, 2, 0);
#line 345
      tag___0 = tmp___1;
#line 346
      tmp___2 = (*s2n___0)((data + entry) + 2, 2, 0);
#line 346
      typ = tmp___2;
      }
#line 347
      if (typ < 1) {
#line 347
        goto __Cont;
      } else
#line 347
      if (typ > 10) {
#line 347
        goto __Cont;
      }
      {
#line 348
      typlen = typlens___0[typ - 1];
#line 349
      count___0 = (*s2n___0)((data + entry) + 4, 4, 0);
#line 350
      offset = entry + 8;
      }
#line 351
      if (count___0 * typlen > 4) {
        {
#line 351
        offset = (*s2n___0)(data + offset, 4, 0);
        }
      }
      {
#line 352
      rc = (*each)(data, offset, tag___0, typ, typlen, count___0, priv);
      }
#line 352
      if (rc) {
#line 354
        return (rc);
      }
      __Cont: /* CIL Label */ 
#line 341
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 337
    tmp = (*s2n___0)(data + i, 2, 0);
#line 337
    i = (*s2n___0)(((data + i) + 2) + 12 * tmp, 4, 0);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 357
  return ((unsigned char *)((void *)0));
}
}
#line 81 "/home/wheatley/newnew/temp/photopc-3.05/fnames.c"
static char *shortcut___0[3][4]  = { {        (char *)"%m%d_%%03d.jpg",        (char *)"%y%m%d%%02d.jpg",        (char *)"%Y_%m_%d-%H_%M_%S.jpg",        (char *)"%Y/%m/%d/%H_%M_%S.jpg"}, 
   {        (char *)"%m%d-%%03d.jpg",        (char *)"%y%m%d%%02d.jpt",        (char *)"%Y_%m_%d-%H_%M_%S-t.jpg",        (char *)"%Y/%m/%d/%H_%M_%S-t.jpg"}, 
   {        (char *)"%m%d_%%03d.wav",        (char *)"%y%m%d%%02d.wav",        (char *)"%Y_%m_%d-%H_%M_%S.wav",        (char *)"%Y/%m/%d/%H_%M_%S.wav"}};
#line 102 "/home/wheatley/newnew/temp/photopc-3.05/fnames.c"
static int ftype___0  =    0;
