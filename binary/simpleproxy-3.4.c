/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 25 "/home/june/repo/benchmarks/collector/temp/simpleproxy-3.4/cfg.h"
struct Dict {
   char *name ;
   char **value ;
   int nvalues ;
};
#line 32 "/home/june/repo/benchmarks/collector/temp/simpleproxy-3.4/cfg.h"
struct Cfg {
   struct Dict **dict ;
   int nelements ;
};
#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 40 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stdarg.h"
typedef __builtin_va_list __gnuc_va_list;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 79 "/usr/include/stdio.h"
typedef __gnuc_va_list va_list;
#line 124 "/home/june/repo/benchmarks/collector/temp/simpleproxy-3.4/cfg.c"
enum __anonenum_state_26 {
    START = 0,
    NAME = 1,
    VALUE = 2,
    INQUOTE = 3,
    WHITESPACE = 4,
    COMMENT = 5
} ;
#line 125 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uid_t;
#line 129 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __mode_t;
#line 133 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __pid_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 141 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __suseconds_t;
#line 172 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __ssize_t;
#line 189 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __socklen_t;
#line 102 "/usr/include/stdio.h"
typedef __ssize_t ssize_t;
#line 30 "/usr/include/x86_64-linux-gnu/bits/time.h"
struct timeval {
   __time_t tv_sec ;
   __suseconds_t tv_usec ;
};
#line 54 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef long __fd_mask;
#line 64 "/usr/include/x86_64-linux-gnu/sys/select.h"
struct __anonstruct_fd_set_7 {
   __fd_mask __fds_bits[1024 / (8 * (int )sizeof(__fd_mask ))] ;
};
#line 64 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef struct __anonstruct_fd_set_7 fd_set;
#line 85 "/usr/include/signal.h"
typedef void (*__sighandler_t)(int  );
#line 33 "/usr/include/x86_64-linux-gnu/bits/socket.h"
typedef __socklen_t socklen_t;
#line 28 "/usr/include/x86_64-linux-gnu/bits/sockaddr.h"
typedef unsigned short sa_family_t;
#line 149 "/usr/include/x86_64-linux-gnu/bits/socket.h"
struct sockaddr {
   sa_family_t sa_family ;
   char sa_data[14] ;
};
#line 49 "/usr/include/stdint.h"
typedef unsigned short uint16_t;
#line 51 "/usr/include/stdint.h"
typedef unsigned int uint32_t;
#line 30 "/usr/include/netinet/in.h"
typedef uint32_t in_addr_t;
#line 31 "/usr/include/netinet/in.h"
struct in_addr {
   in_addr_t s_addr ;
};
#line 117 "/usr/include/netinet/in.h"
typedef uint16_t in_port_t;
#line 237 "/usr/include/netinet/in.h"
struct sockaddr_in {
   sa_family_t sin_family ;
   in_port_t sin_port ;
   struct in_addr sin_addr ;
   unsigned char sin_zero[((sizeof(struct sockaddr ) - sizeof(unsigned short )) - sizeof(in_port_t )) - sizeof(struct in_addr )] ;
};
#line 100 "/usr/include/netdb.h"
struct hostent {
   char *h_name ;
   char **h_aliases ;
   int h_addrtype ;
   int h_length ;
   char **h_addr_list ;
};
#line 257 "/usr/include/netdb.h"
struct servent {
   char *s_name ;
   char **s_aliases ;
   int s_port ;
   char *s_proto ;
};
#line 103 "/home/june/repo/benchmarks/collector/temp/simpleproxy-3.4/simpleproxy.c"
struct lst_record {
   char *s ;
   struct lst_record *next ;
};
/* compiler builtin: 
   void __builtin_va_arg(__builtin_va_list  , unsigned long  , void * ) ;  */
/* compiler builtin: 
   void __builtin_va_start(__builtin_va_list  ) ;  */
/* compiler builtin: 
   void __builtin_va_end(__builtin_va_list  ) ;  */
#line 38 "/home/june/repo/benchmarks/collector/temp/simpleproxy-3.4/cfg.h"
struct Cfg *readcfg(char const   *name ) ;
#line 39
int writecfg(char const   *name , struct Cfg *cfg___0 ) ;
#line 40
char *cfgfind(char const   *name , struct Cfg *cfg___0 , int offset ) ;
#line 41
void freecfg(struct Cfg *cfg___0 ) ;
#line 42
struct Cfg *newcfg(void) ;
#line 43
void sortcfg(struct Cfg *cfg___0 ) ;
#line 44
void cfg_add_entry(struct Cfg *cfg___0 , struct Dict *d ) ;
#line 47
void cfg_new_entry(struct Cfg *cfg___0 , char const   *name  , ...) ;
#line 48
void cfg_new_ulong_entry(struct Cfg *cfg___0 , char const   *name , unsigned long v ) ;
#line 49
void cfg_new_fmt_ulong_entry(struct Cfg *cfg___0 , char const   *name , unsigned long v ,
                             int w ) ;
#line 237 "/usr/include/stdio.h"
extern int fclose(FILE *__stream ) ;
#line 272
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 364
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
#line 531
extern int fgetc(FILE *__stream ) ;
#line 46 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memcpy)(void * __restrict  __dest ,
                                                                                                 void const   * __restrict  __src ,
                                                                                                 size_t __n ) ;
#line 144
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 176
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strdup)(char const   *__s )  __attribute__((__malloc__)) ;
#line 466 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 755
extern void *( __attribute__((__nonnull__(1,2,5))) bsearch)(void const   *__key ,
                                                            void const   *__base ,
                                                            size_t __nmemb , size_t __size ,
                                                            int (*__compar)(void const   * ,
                                                                            void const   * ) ) ;
#line 765
extern void ( __attribute__((__nonnull__(1,4))) qsort)(void *__base , size_t __nmemb ,
                                                       size_t __size , int (*__compar)(void const   * ,
                                                                                       void const   * ) ) ;
#line 79 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) unsigned short const   **( __attribute__((__leaf__)) __ctype_b_loc)(void)  __attribute__((__const__)) ;
#line 34 "/home/june/repo/benchmarks/collector/temp/simpleproxy-3.4/cfg.c"
static int cfg_entry_cmp(void const   *a , void const   *b ) 
{ 
  int tmp ;

  {
  {
#line 36
  tmp = strcmp((char const   *)(*((struct Dict **)a))->name, (char const   *)(*((struct Dict **)b))->name);
  }
#line 36
  return (tmp);
}
}
#line 39 "/home/june/repo/benchmarks/collector/temp/simpleproxy-3.4/cfg.c"
static int cfg_entry_match(void const   *a , void const   *b ) 
{ 
  int tmp ;

  {
  {
#line 41
  tmp = strcmp((char const   *)a, (char const   *)(*((struct Dict **)b))->name);
  }
#line 41
  return (tmp);
}
}
#line 44 "/home/june/repo/benchmarks/collector/temp/simpleproxy-3.4/cfg.c"
char *cfgfind(char const   *name , struct Cfg *cfg___0 , int offset ) 
{ 
  struct Dict **res ;
  void *tmp ;

  {
  {
#line 49
  tmp = bsearch((void const   *)name, (void const   *)cfg___0->dict, (size_t )cfg___0->nelements,
                sizeof(struct Dict *), & cfg_entry_match);
#line 49
  res = (struct Dict **)tmp;
  }
#line 56
  if (! res) {
#line 57
    return ((char *)((void *)0));
  }
#line 59
  if (offset >= (*res)->nvalues) {
#line 60
    return ((char *)((void *)0));
  }
#line 62
  return (*((*res)->value + offset));
}
}
#line 65 "/home/june/repo/benchmarks/collector/temp/simpleproxy-3.4/cfg.c"
int writecfg(char const   *name , struct Cfg *cfg___0 ) 
{ 
  FILE *f ;
  int j ;
  int i ;

  {
  {
#line 71
  f = fopen((char const   */* __restrict  */)name, (char const   */* __restrict  */)"wb");
  }
#line 71
  if ((unsigned long )f == (unsigned long )((void *)0)) {
#line 72
    return (-1);
  }
#line 74
  if (cfg___0) {
#line 76
    i = 0;
    {
#line 76
    while (1) {
      while_continue: /* CIL Label */ ;
#line 76
      if (! (i < cfg___0->nelements)) {
#line 76
        goto while_break;
      }
#line 78
      if (! (*(cfg___0->dict + i))->name) {
#line 79
        goto __Cont;
      }
      {
#line 80
      fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"%s\t",
              (*(cfg___0->dict + i))->name);
#line 81
      j = 0;
      }
      {
#line 81
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 81
        if (! (j < (*(cfg___0->dict + i))->nvalues)) {
#line 81
          goto while_break___0;
        }
#line 82
        if (*((*(cfg___0->dict + i))->value + j)) {
          {
#line 83
          fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)" %s",
                  *((*(cfg___0->dict + i))->value + j));
          }
        }
#line 81
        j ++;
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 84
      fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"\n");
      }
      __Cont: /* CIL Label */ 
#line 76
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 87
  fclose(f);
  }
#line 88
  return (0);
}
}
#line 91 "/home/june/repo/benchmarks/collector/temp/simpleproxy-3.4/cfg.c"
void freecfg(struct Cfg *cfg___0 ) 
{ 
  int i ;
  int j ;

  {
#line 95
  if (! cfg___0) {
#line 96
    return;
  }
#line 98
  i = 0;
  {
#line 98
  while (1) {
    while_continue: /* CIL Label */ ;
#line 98
    if (! (i < cfg___0->nelements)) {
#line 98
      goto while_break;
    }
#line 100
    if ((*(cfg___0->dict + i))->value) {
#line 102
      j = 0;
      {
#line 102
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 102
        if (! (j < (*(cfg___0->dict + i))->nvalues)) {
#line 102
          goto while_break___0;
        }
#line 103
        if (*((*(cfg___0->dict + i))->value + j)) {
          {
#line 104
          free((void *)*((*(cfg___0->dict + i))->value + j));
          }
        }
#line 102
        j ++;
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 105
      free((void *)(*(cfg___0->dict + i))->value);
      }
    }
#line 108
    if ((*(cfg___0->dict + i))->name) {
      {
#line 109
      free((void *)(*(cfg___0->dict + i))->name);
      }
    }
#line 98
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 112
  free((void *)cfg___0->dict);
#line 113
  free((void *)cfg___0);
  }
#line 114
  return;
}
}
#line 116 "/home/june/repo/benchmarks/collector/temp/simpleproxy-3.4/cfg.c"
struct Cfg *readcfg(char const   *name ) 
{ 
  struct Cfg *cfg___0 ;
  FILE *f ;
  char tmp[1024] ;
  char *s ;
  int c ;
  enum __anonenum_state_26 state ;
  void *tmp___0 ;
  unsigned short const   **tmp___1 ;
  struct Dict *tmp1 ;
  void *tmp___2 ;
  char *tmp___3 ;
  unsigned short const   **tmp___4 ;
  unsigned short const   **tmp___5 ;
  struct Dict *last ;
  char **tmp1___0 ;
  int i___0 ;
  void *tmp___6 ;
  char *tmp___7 ;
  unsigned short const   **tmp___8 ;
  char *tmp___9 ;

  {
  {
#line 124
  state = (enum __anonenum_state_26 )0;
#line 137
  f = fopen((char const   */* __restrict  */)name, (char const   */* __restrict  */)"rb");
  }
#line 137
  if ((unsigned long )f == (unsigned long )((void *)0)) {
#line 138
    return ((struct Cfg *)((void *)0));
  }
  {
#line 140
  tmp___0 = malloc(sizeof(struct Cfg ));
#line 140
  cfg___0 = (struct Cfg *)tmp___0;
#line 141
  cfg___0->nelements = 0;
#line 142
  s = tmp;
  }
  {
#line 144
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 144
    c = fgetc(f);
    }
#line 144
    if (! (c != -1)) {
#line 144
      goto while_break;
    }
    {
#line 149
    if ((unsigned int )state == 0U) {
#line 149
      goto case_0;
    }
#line 165
    if ((unsigned int )state == 1U) {
#line 165
      goto case_1;
    }
#line 191
    if ((unsigned int )state == 4U) {
#line 191
      goto case_4;
    }
#line 209
    if ((unsigned int )state == 2U) {
#line 209
      goto case_2;
    }
#line 247
    if ((unsigned int )state == 3U) {
#line 247
      goto case_3;
    }
#line 265
    if ((unsigned int )state == 5U) {
#line 265
      goto case_5;
    }
#line 147
    goto switch_break;
    case_0: /* CIL Label */ 
#line 150
    if (c == 35) {
#line 152
      state = (enum __anonenum_state_26 )5;
#line 153
      goto switch_break;
    } else {
      {
#line 156
      tmp___1 = __ctype_b_loc();
      }
#line 156
      if ((int const   )*(*tmp___1 + c) & 8192) {
#line 162
        goto switch_break;
      } else {
#line 158
        s = tmp;
#line 159
        state = (enum __anonenum_state_26 )1;
      }
    }
    case_1: /* CIL Label */ 
    {
#line 166
    tmp___4 = __ctype_b_loc();
    }
#line 166
    if ((int const   )*(*tmp___4 + c) & 8192) {
      {
#line 168
      tmp___2 = malloc(sizeof(struct Dict ));
#line 168
      tmp1 = (struct Dict *)tmp___2;
#line 169
      *s = (char )'\000';
#line 170
      tmp1->nvalues = 0;
#line 171
      tmp1->value = (char **)((void *)0);
#line 172
      tmp1->name = strdup((char const   *)(tmp));
#line 174
      cfg_add_entry(cfg___0, tmp1);
#line 176
      state = (enum __anonenum_state_26 )4;
      }
    } else {
#line 180
      tmp___3 = s;
#line 180
      s ++;
#line 180
      *tmp___3 = (char )c;
#line 181
      if ((unsigned long )s == (unsigned long )(tmp + sizeof(tmp))) {
        {
#line 184
        freecfg(cfg___0);
#line 185
        fclose(f);
        }
#line 186
        return ((struct Cfg *)((void *)0));
      }
    }
#line 189
    goto switch_break;
    case_4: /* CIL Label */ 
#line 192
    if (c == 10) {
#line 194
      state = (enum __anonenum_state_26 )0;
#line 195
      goto switch_break;
    } else {
      {
#line 199
      tmp___5 = __ctype_b_loc();
      }
#line 199
      if ((int const   )*(*tmp___5 + c) & 8192) {
#line 205
        goto switch_break;
      } else {
#line 201
        s = tmp;
#line 202
        state = (enum __anonenum_state_26 )2;
      }
    }
    case_2: /* CIL Label */ 
#line 210
    if (c == 34) {
#line 211
      state = (enum __anonenum_state_26 )3;
    } else {
      {
#line 213
      tmp___8 = __ctype_b_loc();
      }
#line 213
      if ((int const   )*(*tmp___8 + c) & 8192) {
        {
#line 215
        last = *(cfg___0->dict + (cfg___0->nelements - 1));
#line 219
        *s = (char )'\000';
#line 220
        tmp1___0 = last->value;
#line 221
        tmp___6 = malloc((unsigned long )(last->nvalues + 1) * sizeof(char *));
#line 221
        last->value = (char **)tmp___6;
        }
#line 222
        if (tmp1___0) {
#line 224
          i___0 = 0;
          {
#line 224
          while (1) {
            while_continue___0: /* CIL Label */ ;
#line 224
            if (! (i___0 < last->nvalues)) {
#line 224
              goto while_break___0;
            }
#line 225
            *(last->value + i___0) = *(tmp1___0 + i___0);
#line 224
            i___0 ++;
          }
          while_break___0: /* CIL Label */ ;
          }
          {
#line 226
          free((void *)tmp1___0);
          }
        }
        {
#line 228
        *(last->value + last->nvalues) = strdup((char const   *)(tmp));
#line 229
        (last->nvalues) ++;
        }
#line 230
        if (c == 10) {
#line 231
          state = (enum __anonenum_state_26 )0;
        } else {
#line 233
          state = (enum __anonenum_state_26 )4;
        }
      } else {
#line 236
        tmp___7 = s;
#line 236
        s ++;
#line 236
        *tmp___7 = (char )c;
#line 237
        if ((unsigned long )s == (unsigned long )(tmp + sizeof(tmp))) {
          {
#line 240
          freecfg(cfg___0);
#line 241
          fclose(f);
          }
#line 242
          return ((struct Cfg *)((void *)0));
        }
      }
    }
#line 245
    goto switch_break;
    case_3: /* CIL Label */ 
#line 248
    if (c == 34) {
#line 250
      state = (enum __anonenum_state_26 )2;
    } else {
#line 254
      tmp___9 = s;
#line 254
      s ++;
#line 254
      *tmp___9 = (char )c;
#line 255
      if ((unsigned long )s == (unsigned long )(tmp + sizeof(tmp))) {
        {
#line 258
        freecfg(cfg___0);
#line 259
        fclose(f);
        }
#line 260
        return ((struct Cfg *)((void *)0));
      }
    }
#line 263
    goto switch_break;
    case_5: /* CIL Label */ 
#line 266
    if (c == 10) {
#line 267
      state = (enum __anonenum_state_26 )0;
    }
#line 268
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 272
  sortcfg(cfg___0);
#line 273
  fclose(f);
  }
#line 274
  return (cfg___0);
}
}
#line 282 "/home/june/repo/benchmarks/collector/temp/simpleproxy-3.4/cfg.c"
void sortcfg(struct Cfg *cfg___0 ) 
{ 


  {
  {
#line 284
  qsort((void *)cfg___0->dict, (size_t )cfg___0->nelements, sizeof(struct Dict *),
        & cfg_entry_cmp);
  }
#line 289
  return;
}
}
#line 296 "/home/june/repo/benchmarks/collector/temp/simpleproxy-3.4/cfg.c"
void cfg_add_entry(struct Cfg *cfg___0 , struct Dict *d ) 
{ 
  struct Dict **last ;
  void *tmp ;
  void *tmp___0 ;

  {
#line 298
  if (cfg___0->nelements) {
    {
#line 300
    last = cfg___0->dict;
#line 301
    tmp = malloc(sizeof(struct Dict *) * (unsigned long )(cfg___0->nelements + 1));
#line 301
    cfg___0->dict = (struct Dict **)tmp;
#line 302
    memcpy((void */* __restrict  */)cfg___0->dict, (void const   */* __restrict  */)last,
           sizeof(struct Dict *) * (unsigned long )cfg___0->nelements);
#line 303
    *(cfg___0->dict + cfg___0->nelements) = d;
#line 304
    (cfg___0->nelements) ++;
#line 305
    free((void *)last);
    }
  } else {
    {
#line 309
    tmp___0 = malloc(sizeof(struct Dict *));
#line 309
    cfg___0->dict = (struct Dict **)tmp___0;
#line 310
    *(cfg___0->dict + 0) = d;
#line 311
    cfg___0->nelements = 1;
    }
  }
#line 313
  return;
}
}
#line 321 "/home/june/repo/benchmarks/collector/temp/simpleproxy-3.4/cfg.c"
void cfg_new_entry(struct Cfg *cfg___0 , char const   *name  , ...) 
{ 
  int n ;
  va_list ap ;
  struct Dict *tmp ;
  void *tmp___0 ;
  char const   *tmp___2 ;
  int i ;
  void *tmp___3 ;
  char const   *tmp___5 ;

  {
  {
#line 325
  tmp___0 = malloc(sizeof(struct Dict ));
#line 325
  tmp = (struct Dict *)tmp___0;
#line 327
  tmp->name = strdup(name);
#line 329
  __builtin_va_start(ap, name);
#line 330
  n = 0;
  }
  {
#line 331
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 331
    tmp___2 = __builtin_va_arg(ap, char const   *);
    }
#line 331
    if (! tmp___2) {
#line 331
      goto while_break;
    }
#line 331
    n ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 332
  __builtin_va_end(ap);
#line 334
  tmp->nvalues = n;
  }
#line 335
  if (n) {
    {
#line 339
    __builtin_va_start(ap, name);
#line 340
    tmp___3 = malloc((unsigned long )n * sizeof(char *));
#line 340
    tmp->value = (char **)tmp___3;
#line 341
    i = 0;
    }
    {
#line 341
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 341
      if (! (i < n)) {
#line 341
        goto while_break___0;
      }
      {
#line 342
      tmp___5 = __builtin_va_arg(ap, char const   *);
#line 342
      *(tmp->value + i) = strdup(tmp___5);
#line 341
      i ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 343
    __builtin_va_end(ap);
    }
  } else {
#line 346
    tmp->value = (char **)((void *)0);
  }
  {
#line 349
  cfg_add_entry(cfg___0, tmp);
  }
#line 350
  return;
}
}
#line 352 "/home/june/repo/benchmarks/collector/temp/simpleproxy-3.4/cfg.c"
void cfg_new_ulong_entry(struct Cfg *cfg___0 , char const   *name , unsigned long v ) 
{ 
  char tmp[80] ;

  {
  {
#line 355
  sprintf((char */* __restrict  */)(tmp), (char const   */* __restrict  */)"%lu",
          v);
#line 356
  cfg_new_entry(cfg___0, name, tmp, (void *)0);
  }
#line 357
  return;
}
}
#line 365 "/home/june/repo/benchmarks/collector/temp/simpleproxy-3.4/cfg.c"
void cfg_new_fmt_ulong_entry(struct Cfg *cfg___0 , char const   *name , unsigned long v ,
                             int w ) 
{ 
  char tmp[80] ;

  {
  {
#line 368
  sprintf((char */* __restrict  */)(tmp), (char const   */* __restrict  */)"%0*lu",
          w, v);
#line 369
  cfg_new_entry(cfg___0, name, tmp, (void *)0);
  }
#line 370
  return;
}
}
#line 372 "/home/june/repo/benchmarks/collector/temp/simpleproxy-3.4/cfg.c"
struct Cfg *newcfg(void) 
{ 
  struct Cfg *res ;
  void *tmp ;

  {
  {
#line 374
  tmp = malloc(sizeof(struct Cfg ));
#line 374
  res = (struct Cfg *)tmp;
#line 375
  res->nelements = 0;
  }
#line 376
  return (res);
}
}
#line 170 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 371
extern int vfprintf(FILE * __restrict  __s , char const   * __restrict  __format ,
                    __gnuc_va_list __arg ) ;
#line 386
extern  __attribute__((__nothrow__)) int ( /* format attribute */  snprintf)(char * __restrict  __s ,
                                                                             size_t __maxlen ,
                                                                             char const   * __restrict  __format 
                                                                             , ...) ;
#line 390
extern  __attribute__((__nothrow__)) int ( /* format attribute */  vsnprintf)(char * __restrict  __s ,
                                                                              size_t __maxlen ,
                                                                              char const   * __restrict  __format ,
                                                                              __gnuc_va_list __arg ) ;
#line 433
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) sscanf)(char const   * __restrict  __s ,
                                                                             char const   * __restrict  __format 
                                                                             , ...)  __asm__("__isoc99_sscanf")  ;
#line 622
extern char *fgets(char * __restrict  __s , int __n , FILE * __restrict  __stream ) ;
#line 106 "/usr/include/x86_64-linux-gnu/sys/select.h"
extern int select(int __nfds , fd_set * __restrict  __readfds , fd_set * __restrict  __writefds ,
                  fd_set * __restrict  __exceptfds , struct timeval * __restrict  __timeout ) ;
#line 102 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) __sighandler_t ( __attribute__((__leaf__)) signal)(int __sig ,
                                                                                        void (*__handler)(int  ) ) ;
#line 125 "/usr/include/x86_64-linux-gnu/sys/wait.h"
extern __pid_t waitpid(__pid_t __pid , int *__stat_loc , int __options ) ;
#line 113 "/usr/include/x86_64-linux-gnu/sys/socket.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) socket)(int __domain ,
                                                                             int __type ,
                                                                             int __protocol ) ;
#line 123
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) bind)(int __fd ,
                                                                           struct sockaddr  const  *__addr ,
                                                                           socklen_t __len ) ;
#line 137
extern int connect(int __fd , struct sockaddr  const  *__addr , socklen_t __len ) ;
#line 141
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) getpeername)(int __fd ,
                                                                                  struct sockaddr * __restrict  __addr ,
                                                                                  socklen_t * __restrict  __len ) ;
#line 226
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) setsockopt)(int __fd ,
                                                                                 int __level ,
                                                                                 int __optname ,
                                                                                 void const   *__optval ,
                                                                                 socklen_t __optlen ) ;
#line 233
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) listen)(int __fd ,
                                                                             int __n ) ;
#line 243
extern int accept(int __fd , struct sockaddr * __restrict  __addr , socklen_t * __restrict  __addr_len ) ;
#line 261
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) shutdown)(int __fd ,
                                                                               int __how ) ;
#line 66 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memset)(void *__s ,
                                                                                               int __c ,
                                                                                               size_t __n ) ;
#line 129
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcpy)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 147
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strncmp)(char const   *__s1 ,
                                                                                                char const   *__s2 ,
                                                                                                size_t __n )  __attribute__((__pure__)) ;
#line 236
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strchr)(char const   *__s ,
                                                                                               int __c )  __attribute__((__pure__)) ;
#line 263
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strrchr)(char const   *__s ,
                                                                                                int __c )  __attribute__((__pure__)) ;
#line 315
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strpbrk)(char const   *__s ,
                                                                                                  char const   *__accept )  __attribute__((__pure__)) ;
#line 399
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 413
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) strerror)(int __errnum ) ;
#line 534
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcasecmp)(char const   *__s1 ,
                                                                                                   char const   *__s2 )  __attribute__((__pure__)) ;
#line 353 "/usr/include/unistd.h"
extern int close(int __fd ) ;
#line 360
extern ssize_t read(int __fd , void *__buf , size_t __nbytes ) ;
#line 366
extern ssize_t write(int __fd , void const   *__buf , size_t __n ) ;
#line 444
extern unsigned int sleep(unsigned int __seconds ) ;
#line 497
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) chdir)(char const   *__path ) ;
#line 534
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) dup2)(int __fd ,
                                                                           int __fd2 ) ;
#line 628
extern  __attribute__((__nothrow__)) __pid_t ( __attribute__((__leaf__)) getpid)(void) ;
#line 667
extern  __attribute__((__nothrow__)) __pid_t ( __attribute__((__leaf__)) setsid)(void) ;
#line 678
extern  __attribute__((__nothrow__)) __uid_t ( __attribute__((__leaf__)) geteuid)(void) ;
#line 756
extern  __attribute__((__nothrow__)) __pid_t fork(void) ;
#line 57 "/usr/include/getopt.h"
extern char *optarg ;
#line 150
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) getopt)(int ___argc ,
                                                                             char * const  *___argv ,
                                                                             char const   *__shortopts ) ;
#line 147 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 150
extern  __attribute__((__nothrow__)) long ( __attribute__((__nonnull__(1), __leaf__)) atol)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 183
extern  __attribute__((__nothrow__)) long ( __attribute__((__nonnull__(1), __leaf__)) strtol)(char const   * __restrict  __nptr ,
                                                                                              char ** __restrict  __endptr ,
                                                                                              int __base ) ;
#line 543
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 312 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) __mode_t ( __attribute__((__leaf__)) umask)(__mode_t __mask ) ;
#line 175 "/usr/include/x86_64-linux-gnu/sys/syslog.h"
extern void closelog(void) ;
#line 181
extern void openlog(char const   *__ident , int __option , int __facility ) ;
#line 190
extern void ( /* format attribute */  syslog)(int __pri , char const   *__fmt  , ...) ;
#line 375 "/usr/include/netinet/in.h"
extern  __attribute__((__nothrow__)) uint16_t ( __attribute__((__leaf__)) ntohs)(uint16_t __netshort )  __attribute__((__const__)) ;
#line 377
extern  __attribute__((__nothrow__)) uint32_t ( __attribute__((__leaf__)) htonl)(uint32_t __hostlong )  __attribute__((__const__)) ;
#line 379
extern  __attribute__((__nothrow__)) uint16_t ( __attribute__((__leaf__)) htons)(uint16_t __hostshort )  __attribute__((__const__)) ;
#line 137 "/usr/include/netdb.h"
extern struct hostent *gethostbyaddr(void const   *__addr , __socklen_t __len , int __type ) ;
#line 144
extern struct hostent *gethostbyname(char const   *__name ) ;
#line 290
extern struct servent *getservbyname(char const   *__name , char const   *__proto ) ;
#line 677
extern int getnameinfo(struct sockaddr  const  * __restrict  __sa , socklen_t __salen ,
                       char * __restrict  __host , socklen_t __hostlen , char * __restrict  __serv ,
                       socklen_t __servlen , int __flags ) ;
#line 146 "/usr/include/fcntl.h"
extern int ( __attribute__((__nonnull__(1))) open)(char const   *__file , int __oflag 
                                                   , ...) ;
#line 50 "/usr/include/x86_64-linux-gnu/bits/errno.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
#line 34 "/usr/include/arpa/inet.h"
extern  __attribute__((__nothrow__)) in_addr_t ( __attribute__((__leaf__)) inet_addr)(char const   *__cp ) ;
#line 53
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) inet_ntoa)(struct in_addr __in ) ;
#line 99 "/home/june/repo/benchmarks/collector/temp/simpleproxy-3.4/simpleproxy.c"
static char *SIMPLEPROXY_VERSION  =    (char *)"simpleproxy v3.4 by lord@crocodile.org,vlad@noir.crocodile.org,verylong@noir.crocodile.org";
#line 100 "/home/june/repo/benchmarks/collector/temp/simpleproxy-3.4/simpleproxy.c"
static char *SIMPLEPROXY_USAGE  =    (char *)"simpleproxy -L <[host:]port> -R <host:port> [-d] [-v] [-V] [-7] [-i] [-p PID file] [-P <POP3 accounts list file>] [-f cfgfile] [-t tracefile] [-D delay in sec.] [-S <HTTPS proxy host:port> [-a <HTTP Auth user>:<HTTP Auth password>] ]";
#line 101 "/home/june/repo/benchmarks/collector/temp/simpleproxy-3.4/simpleproxy.c"
static char *PROXY_HEADER  =    (char *)"\nProxy-Authorization: Basic %s";
#line 109
static void daemon_start(void) ;
#line 110
static int writen(int fd , char *ptr , int nbytes ) ;
#line 111
static void pass_all(int fd , int client ) ;
#line 112
static int pass_one(int in , int out ) ;
#line 113
static int get_hostaddr(char const   *name ) ;
#line 114
static int readln(int fd , char *buf , int siz ) ;
#line 115
static void firstword(char *s ) ;
#line 116
static struct lst_record *load_pop3_list(char const   *popfile ) ;
#line 117
static int check_pop3_list(struct lst_record *lst , char *acc ) ;
#line 118
static int pop3_login(int server , int user ) ;
#line 119
static int read_pop3_cmd(int s , char *buff , int max_buf , int strip ) ;
#line 120
static void child_dead(int stat___0 ) ;
#line 121
static void write_pid(char *filename ) ;
#line 122
static int process_remote(char const   *dest_host , int dest_port , char const   *client_name ) ;
#line 123
static int open_remote(char const   *rhost , int rportn , char const   *src_name ) ;
#line 124
static void logopen(void) ;
#line 125
static void logclose(void) ;
#line 126
static void log(int type , char *format  , ...) ;
#line 127
static void ctrlc(int s ) ;
#line 128
static int https_connect(int DstSockFD___0 , char const   *remoteHost , int remotePort ) ;
#line 129
static int str2bool(char *s ) ;
#line 130
static void parse_host_port(char const   *src , char **h_ptr , int *p_ptr ) ;
#line 131
static void replace_string(char **dst , char const   *src ) ;
#line 132
static void fatal(void) ;
#line 133
static char *base64_encode(char *plaintext ) ;
#line 134
static void trace(int fd , char *buf , int siz ) ;
#line 136 "/home/june/repo/benchmarks/collector/temp/simpleproxy-3.4/simpleproxy.c"
static int isVerbose  =    0;
#line 137 "/home/june/repo/benchmarks/collector/temp/simpleproxy-3.4/simpleproxy.c"
static int isDaemon  =    0;
#line 138 "/home/june/repo/benchmarks/collector/temp/simpleproxy-3.4/simpleproxy.c"
static int isStripping  =    0;
#line 139 "/home/june/repo/benchmarks/collector/temp/simpleproxy-3.4/simpleproxy.c"
static int isStartedFromInetd  =    0;
#line 140 "/home/june/repo/benchmarks/collector/temp/simpleproxy-3.4/simpleproxy.c"
static int isUsingHTTPAuth  =    0;
#line 141 "/home/june/repo/benchmarks/collector/temp/simpleproxy-3.4/simpleproxy.c"
static long Delay  =    0L;
#line 143 "/home/june/repo/benchmarks/collector/temp/simpleproxy-3.4/simpleproxy.c"
static char *HTTPSProxyHost  =    (char *)((void *)0);
#line 144 "/home/june/repo/benchmarks/collector/temp/simpleproxy-3.4/simpleproxy.c"
static int HTTPSProxyPort  =    -1;
#line 145 "/home/june/repo/benchmarks/collector/temp/simpleproxy-3.4/simpleproxy.c"
static char *HTTPBasicAuthString  =    (char *)((void *)0);
#line 146 "/home/june/repo/benchmarks/collector/temp/simpleproxy-3.4/simpleproxy.c"
static char *Tracefile  =    (char *)((void *)0);
#line 148 "/home/june/repo/benchmarks/collector/temp/simpleproxy-3.4/simpleproxy.c"
static int SockFD  =    -1;
#line 148 "/home/june/repo/benchmarks/collector/temp/simpleproxy-3.4/simpleproxy.c"
static int SrcSockFD  =    -1;
#line 148 "/home/june/repo/benchmarks/collector/temp/simpleproxy-3.4/simpleproxy.c"
static int DstSockFD  =    -1;
#line 152 "/home/june/repo/benchmarks/collector/temp/simpleproxy-3.4/simpleproxy.c"
struct lst_record *POPList  =    (struct lst_record *)((void *)0);
#line 167
int main(int ac , char **av ) ;
#line 167 "/home/june/repo/benchmarks/collector/temp/simpleproxy-3.4/simpleproxy.c"
static struct Cfg *cfg  =    (struct Cfg *)((void *)0);
#line 154 "/home/june/repo/benchmarks/collector/temp/simpleproxy-3.4/simpleproxy.c"
int main(int ac , char **av ) 
{ 
  int clien ;
  struct sockaddr_in cli_addr ;
  struct sockaddr_in serv_addr ;
  int lportn ;
  int rportn ;
  char *lhost ;
  char *rhost ;
  char *client_name ;
  int c ;
  int errflg ;
  char *cfgfile ;
  char *popfile ;
  char *pidfile ;
  int rsp ;
  char *http_auth ;
  char *HTTPAuthHash ;
  int len ;
  char hbuf[1025] ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  size_t tmp___4 ;
  size_t tmp___5 ;
  void *tmp___6 ;
  __sighandler_t tmp___7 ;
  __uid_t tmp___8 ;
  int tmp___9 ;
  uint32_t tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int *tmp___13 ;
  char *tmp___14 ;
  int tmp___15 ;
  int *tmp___16 ;
  int *tmp___17 ;
  int *tmp___18 ;
  char *tmp___19 ;
  __pid_t tmp___20 ;
  int *tmp___21 ;
  char *tmp___22 ;
  int tmp___23 ;
  char const   *tmp___24 ;
  char const   *tmp___25 ;
  int tmp___26 ;
  char const   *tmp___27 ;
  char const   *tmp___28 ;
  char const   *tmp___29 ;
  char const   *tmp___30 ;

  {
#line 158
  lportn = -1;
#line 158
  rportn = -1;
#line 159
  lhost = (char *)((void *)0);
#line 159
  rhost = (char *)((void *)0);
#line 164
  errflg = 0;
#line 165
  cfgfile = (char *)((void *)0);
#line 166
  popfile = (char *)((void *)0);
#line 168
  pidfile = (char *)((void *)0);
#line 169
  rsp = 1;
#line 170
  http_auth = (char *)((void *)0);
#line 171
  HTTPAuthHash = (char *)((void *)0);
  {
#line 177
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 177
    c = getopt(ac, (char * const  *)av, "iVv7dhL:R:H:f:p:P:D:S:s:a:t:");
    }
#line 177
    if (! (c != -1)) {
#line 177
      goto while_break;
    }
    {
#line 180
    if (c == 118) {
#line 180
      goto case_118;
    }
#line 183
    if (c == 105) {
#line 183
      goto case_105;
    }
#line 186
    if (c == 100) {
#line 186
      goto case_100;
    }
#line 189
    if (c == 112) {
#line 189
      goto case_112;
    }
#line 192
    if (c == 102) {
#line 192
      goto case_102;
    }
#line 247
    if (c == 76) {
#line 247
      goto case_76;
    }
#line 250
    if (c == 80) {
#line 250
      goto case_80;
    }
#line 253
    if (c == 82) {
#line 253
      goto case_82;
    }
#line 256
    if (c == 72) {
#line 256
      goto case_72;
    }
#line 259
    if (c == 68) {
#line 259
      goto case_68;
    }
#line 262
    if (c == 55) {
#line 262
      goto case_55;
    }
#line 265
    if (c == 83) {
#line 265
      goto case_83;
    }
#line 268
    if (c == 115) {
#line 268
      goto case_115;
    }
#line 271
    if (c == 86) {
#line 271
      goto case_86;
    }
#line 274
    if (c == 104) {
#line 274
      goto case_104;
    }
#line 277
    if (c == 97) {
#line 277
      goto case_97;
    }
#line 283
    if (c == 116) {
#line 283
      goto case_116;
    }
#line 286
    goto switch_default;
    case_118: /* CIL Label */ 
#line 181
    isVerbose ++;
#line 182
    goto switch_break;
    case_105: /* CIL Label */ 
#line 184
    isStartedFromInetd ++;
#line 185
    goto switch_break;
    case_100: /* CIL Label */ 
#line 187
    isDaemon ++;
#line 188
    goto switch_break;
    case_112: /* CIL Label */ 
    {
#line 190
    replace_string(& pidfile, (char const   *)optarg);
    }
#line 191
    goto switch_break;
    case_102: /* CIL Label */ 
    {
#line 193
    replace_string(& cfgfile, (char const   *)optarg);
    }
#line 194
    if (cfgfile) {
      {
#line 196
      cfg = readcfg((char const   *)cfgfile);
      }
#line 196
      if ((unsigned long )cfg == (unsigned long )((void *)0)) {
        {
#line 198
        log(3, (char *)"Error reading cfg file.");
        }
#line 199
        return (1);
      } else {
#line 205
        if (! isVerbose) {
          {
#line 206
          tmp___0 = cfgfind("Verbose", cfg, 0);
#line 206
          isVerbose = str2bool(tmp___0);
          }
        }
#line 207
        if (! isStartedFromInetd) {
          {
#line 208
          tmp___1 = cfgfind("StartedFromInetd", cfg, 0);
#line 208
          isStartedFromInetd = str2bool(tmp___1);
          }
        }
#line 209
        if (! isDaemon) {
          {
#line 210
          tmp___2 = cfgfind("Daemon", cfg, 0);
#line 210
          isDaemon = str2bool(tmp___2);
          }
        }
#line 211
        if (! isStripping) {
          {
#line 212
          tmp___3 = cfgfind("Strip8bit", cfg, 0);
#line 212
          isStripping = str2bool(tmp___3);
          }
        }
        {
#line 214
        tmp = cfgfind("LocalPort", cfg, 0);
        }
#line 215
        if (tmp) {
#line 215
          if (lportn == -1) {
            {
#line 216
            parse_host_port((char const   *)tmp, (char **)((void *)0), & lportn);
            }
          }
        }
        {
#line 217
        tmp = cfgfind("RemotePort", cfg, 0);
        }
#line 218
        if (tmp) {
#line 218
          if (rportn == -1) {
            {
#line 219
            parse_host_port((char const   *)tmp, (char **)((void *)0), & rportn);
            }
          }
        }
        {
#line 220
        tmp = cfgfind("HTTPSProxyPort", cfg, 0);
        }
#line 221
        if (tmp) {
#line 221
          if (HTTPSProxyPort == -1) {
            {
#line 222
            parse_host_port((char const   *)tmp, (char **)((void *)0), & HTTPSProxyPort);
            }
          }
        }
        {
#line 224
        tmp = cfgfind("PIDFile", cfg, 0);
        }
#line 225
        if (tmp) {
#line 225
          if (! pidfile) {
            {
#line 226
            replace_string(& pidfile, (char const   *)tmp);
            }
          }
        }
        {
#line 227
        tmp = cfgfind("POP3File", cfg, 0);
        }
#line 228
        if (tmp) {
#line 228
          if (! popfile) {
            {
#line 229
            replace_string(& popfile, (char const   *)tmp);
            }
          }
        }
        {
#line 230
        tmp = cfgfind("LocalHost", cfg, 0);
        }
#line 231
        if (tmp) {
#line 231
          if (! rhost) {
            {
#line 232
            parse_host_port((char const   *)tmp, & lhost, & lportn);
            }
          }
        }
        {
#line 233
        tmp = cfgfind("RemoteHost", cfg, 0);
        }
#line 234
        if (tmp) {
#line 234
          if (! rhost) {
            {
#line 235
            parse_host_port((char const   *)tmp, & rhost, & rportn);
            }
          }
        }
        {
#line 236
        tmp = cfgfind("HTTPSProxyHost", cfg, 0);
        }
#line 237
        if (tmp) {
#line 237
          if (! HTTPSProxyHost) {
            {
#line 238
            parse_host_port((char const   *)tmp, & HTTPSProxyHost, & HTTPSProxyPort);
            }
          }
        }
        {
#line 239
        tmp = cfgfind("TraceFile", cfg, 0);
        }
#line 240
        if (tmp) {
#line 240
          if (! Tracefile) {
            {
#line 241
            replace_string(& Tracefile, (char const   *)tmp);
            }
          }
        }
        {
#line 243
        freecfg(cfg);
        }
      }
    }
#line 246
    goto switch_break;
    case_76: /* CIL Label */ 
    {
#line 248
    parse_host_port((char const   *)optarg, & lhost, & lportn);
    }
#line 249
    goto switch_break;
    case_80: /* CIL Label */ 
    {
#line 251
    replace_string(& popfile, (char const   *)optarg);
    }
#line 252
    goto switch_break;
    case_82: /* CIL Label */ 
    {
#line 254
    parse_host_port((char const   *)optarg, & rhost, & rportn);
    }
#line 255
    goto switch_break;
    case_72: /* CIL Label */ 
    {
#line 257
    replace_string(& rhost, (char const   *)optarg);
    }
#line 258
    goto switch_break;
    case_68: /* CIL Label */ 
    {
#line 260
    Delay = atol((char const   *)optarg);
    }
#line 261
    goto switch_break;
    case_55: /* CIL Label */ 
#line 263
    isStripping = 1;
#line 264
    goto switch_break;
    case_83: /* CIL Label */ 
    {
#line 266
    parse_host_port((char const   *)optarg, & HTTPSProxyHost, & HTTPSProxyPort);
    }
#line 267
    goto switch_break;
    case_115: /* CIL Label */ 
    {
#line 269
    parse_host_port((char const   *)optarg, (char **)((void *)0), & HTTPSProxyPort);
    }
#line 270
    goto switch_break;
    case_86: /* CIL Label */ 
    {
#line 272
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s\n",
            SIMPLEPROXY_VERSION);
#line 273
    exit(0);
    }
    case_104: /* CIL Label */ 
#line 275
    errflg ++;
#line 276
    goto switch_break;
    case_97: /* CIL Label */ 
#line 278
    if ((unsigned long )HTTPSProxyHost == (unsigned long )((void *)0)) {
#line 278
      if (HTTPSProxyPort == -1) {
        {
#line 279
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Warning! Proxy authorization (-a) meaningless without HTTPS parameters (-S)\n");
        }
      }
    }
#line 280
    isUsingHTTPAuth = 1;
#line 281
    http_auth = optarg;
#line 282
    goto switch_break;
    case_116: /* CIL Label */ 
    {
#line 284
    replace_string(& Tracefile, (char const   *)optarg);
    }
#line 285
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 287
    errflg ++;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 292
  if (isUsingHTTPAuth) {
    {
#line 294
    HTTPAuthHash = base64_encode(http_auth);
#line 295
    tmp___4 = strlen((char const   *)HTTPAuthHash);
#line 295
    tmp___5 = strlen((char const   *)PROXY_HEADER);
#line 295
    tmp___6 = malloc(tmp___4 + tmp___5);
#line 295
    HTTPBasicAuthString = (char *)tmp___6;
#line 296
    sprintf((char */* __restrict  */)HTTPBasicAuthString, (char const   */* __restrict  */)PROXY_HEADER,
            HTTPAuthHash);
#line 297
    free((void *)HTTPAuthHash);
    }
  } else {
#line 300
    HTTPBasicAuthString = (char *)"";
  }
#line 303
  if (isStartedFromInetd) {
#line 303
    if (lportn > 0) {
#line 304
      errflg ++;
    }
  }
#line 306
  if (! rhost) {
#line 310
    errflg ++;
  } else
#line 306
  if (rportn <= 0) {
#line 310
    errflg ++;
  } else
#line 306
  if (lportn <= 0) {
#line 306
    if (! isStartedFromInetd) {
#line 310
      errflg ++;
    } else {
#line 306
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 306
  if (HTTPSProxyHost) {
#line 306
    if (HTTPSProxyPort <= 0) {
#line 310
      errflg ++;
    }
  }
#line 314
  if (isStartedFromInetd) {
#line 315
    isDaemon ++;
  }
#line 317
  if (errflg) {
    {
#line 319
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s\n",
            SIMPLEPROXY_VERSION);
#line 320
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Usage:\n\t%s\n",
            SIMPLEPROXY_USAGE);
#line 321
    exit(1);
    }
  }
  {
#line 324
  logopen();
#line 326
  tmp___7 = signal(2, & ctrlc);
  }
#line 326
  if ((unsigned long )tmp___7 == (unsigned long )((void (*)(int  ))-1)) {
    {
#line 327
    log(3, (char *)"Error installing interrupt handler.");
    }
  }
#line 329
  if (lportn <= 1024) {
    {
#line 329
    tmp___8 = geteuid();
    }
#line 329
    if (tmp___8 != 0U) {
#line 329
      if (! isStartedFromInetd) {
#line 331
        if (! isVerbose) {
          {
#line 333
          logopen();
#line 334
          isVerbose ++;
          }
        }
        {
#line 336
        log(3, (char *)"You must be root to run SIMPLEPROXY on reserved port");
#line 337
        fatal();
        }
      }
    }
  }
#line 340
  if (popfile) {
    {
#line 341
    POPList = load_pop3_list((char const   *)popfile);
    }
  }
#line 343
  if (! isStartedFromInetd) {
#line 346
    if (isDaemon) {
      {
#line 347
      daemon_start();
      }
    }
#line 349
    if (pidfile) {
      {
#line 350
      write_pid(pidfile);
      }
    }
    {
#line 352
    SockFD = socket(2, 1, 0);
    }
#line 352
    if (SockFD < 0) {
      {
#line 354
      log(3, (char *)"Error creating socket.");
#line 355
      fatal();
      }
    }
    {
#line 358
    memset((void *)(& serv_addr), 0, sizeof(serv_addr));
#line 359
    serv_addr.sin_family = (sa_family_t )2;
    }
#line 360
    if (lhost) {
#line 360
      if (*lhost) {
        {
#line 360
        tmp___9 = get_hostaddr((char const   *)lhost);
#line 360
        serv_addr.sin_addr.s_addr = (in_addr_t )tmp___9;
        }
      } else {
        {
#line 360
        tmp___10 = htonl((in_addr_t )0);
#line 360
        serv_addr.sin_addr.s_addr = tmp___10;
        }
      }
    } else {
      {
#line 360
      tmp___10 = htonl((in_addr_t )0);
#line 360
      serv_addr.sin_addr.s_addr = tmp___10;
      }
    }
    {
#line 361
    serv_addr.sin_port = htons((uint16_t )lportn);
#line 363
    tmp___11 = setsockopt(SockFD, 1, 2, (void const   *)((void *)(& rsp)), (socklen_t )sizeof(rsp));
    }
#line 363
    if (tmp___11) {
      {
#line 364
      log(3, (char *)"Error setting socket options");
      }
    }
    {
#line 366
    tmp___12 = bind(SockFD, (struct sockaddr  const  *)((struct sockaddr *)(& serv_addr)),
                    (socklen_t )sizeof(serv_addr));
    }
#line 366
    if (tmp___12 < 0) {
      {
#line 368
      log(3, (char *)"Error binding socket.");
#line 369
      fatal();
      }
    }
    {
#line 372
    log(6, (char *)"Waiting for connections.");
#line 374
    tmp___15 = listen(SockFD, 5);
    }
#line 374
    if (tmp___15 < 0) {
      {
#line 376
      tmp___13 = __errno_location();
#line 376
      tmp___14 = strerror(*tmp___13);
#line 376
      log(3, (char *)"Error listening socket: %s", tmp___14);
#line 377
      fatal();
      }
    }
    {
#line 380
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 382
      clien = (int )sizeof(cli_addr);
#line 384
      SrcSockFD = accept(SockFD, (struct sockaddr */* __restrict  */)((struct sockaddr *)(& cli_addr)),
                         (socklen_t */* __restrict  */)(& clien));
      }
#line 386
      if (SrcSockFD < 0) {
        {
#line 388
        tmp___16 = __errno_location();
        }
#line 388
        if (*tmp___16 == 4) {
#line 389
          goto while_continue___0;
        } else {
          {
#line 388
          tmp___17 = __errno_location();
          }
#line 388
          if (*tmp___17 == 10) {
#line 389
            goto while_continue___0;
          }
        }
        {
#line 390
        tmp___18 = __errno_location();
#line 390
        tmp___19 = strerror(*tmp___18);
#line 390
        log(3, (char *)"accept error - %s", tmp___19);
#line 391
        fatal();
        }
      }
      {
#line 394
      signal(17, & child_dead);
#line 396
      tmp___20 = fork();
      }
      {
#line 398
      if (tmp___20 == -1) {
#line 398
        goto case_neg_1;
      }
#line 402
      if (tmp___20 == 0) {
#line 402
        goto case_0;
      }
#line 440
      goto switch_default___0;
      case_neg_1: /* CIL Label */ 
      {
#line 399
      tmp___21 = __errno_location();
#line 399
      tmp___22 = strerror(*tmp___21);
#line 399
      log(3, (char *)"fork error - %s", tmp___22);
      }
#line 400
      goto switch_break___0;
      case_0: /* CIL Label */ 
      {
#line 403
      tmp___23 = getnameinfo((struct sockaddr  const  */* __restrict  */)((struct sockaddr  const  *)(& cli_addr)),
                             (socklen_t )len, (char */* __restrict  */)(hbuf), (socklen_t )sizeof(hbuf),
                             (char */* __restrict  */)((void *)0), (socklen_t )0,
                             0);
      }
#line 403
      if (tmp___23 == 0) {
        {
#line 405
        client_name = strdup((char const   *)(hbuf));
        }
      } else {
        {
#line 407
        client_name = inet_ntoa(cli_addr.sin_addr);
        }
      }
#line 420
      if (rhost) {
#line 420
        if (*rhost) {
#line 420
          tmp___24 = (char const   *)rhost;
        } else {
#line 420
          tmp___24 = "localhost";
        }
      } else {
#line 420
        tmp___24 = "localhost";
      }
#line 420
      if (lhost) {
#line 420
        if (*lhost) {
#line 420
          tmp___25 = (char const   *)lhost;
        } else {
#line 420
          tmp___25 = "ANY";
        }
      } else {
#line 420
        tmp___25 = "ANY";
      }
      {
#line 420
      log(5, (char *)"Connect from %s (%s:%d->%s:%d)", client_name, tmp___25, lportn,
          tmp___24, rportn);
#line 426
      tmp___26 = process_remote((char const   *)rhost, rportn, (char const   *)client_name);
      }
#line 426
      if (tmp___26) {
        {
#line 427
        fatal();
        }
      }
#line 429
      if (rhost) {
#line 429
        if (*rhost) {
#line 429
          tmp___27 = (char const   *)rhost;
        } else {
#line 429
          tmp___27 = "localhost";
        }
      } else {
#line 429
        tmp___27 = "localhost";
      }
#line 429
      if (lhost) {
#line 429
        if (*lhost) {
#line 429
          tmp___28 = (char const   *)lhost;
        } else {
#line 429
          tmp___28 = "ANY";
        }
      } else {
#line 429
        tmp___28 = "ANY";
      }
      {
#line 429
      log(5, (char *)"Connect from %s (%s:%d->%s:%d) closed", client_name, tmp___28,
          lportn, tmp___27, rportn);
#line 435
      shutdown(SrcSockFD, 2);
#line 436
      close(SrcSockFD);
#line 437
      SrcSockFD = -1;
#line 438
      closelog();
      }
#line 439
      return (0);
      switch_default___0: /* CIL Label */ 
      {
#line 442
      close(SrcSockFD);
#line 443
      SrcSockFD = -1;
      }
      switch_break___0: /* CIL Label */ ;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  } else {
#line 450
    SrcSockFD = 0;
#line 452
    if (rhost) {
#line 452
      if (*rhost) {
#line 452
        tmp___29 = (char const   *)rhost;
      } else {
#line 452
        tmp___29 = "localhost";
      }
    } else {
#line 452
      tmp___29 = "localhost";
    }
    {
#line 452
    log(5, (char *)"Connect (inted->%s:%d)", tmp___29, rportn);
#line 456
    process_remote((char const   *)rhost, rportn, "inted");
    }
#line 457
    if (rhost) {
#line 457
      if (*rhost) {
#line 457
        tmp___30 = (char const   *)rhost;
      } else {
#line 457
        tmp___30 = "localhost";
      }
    } else {
#line 457
      tmp___30 = "localhost";
    }
    {
#line 457
    log(5, (char *)"Connect (inted->%s:%d) closed", tmp___30, rportn);
    }
  }
#line 461
  return (0);
}
}
#line 468 "/home/june/repo/benchmarks/collector/temp/simpleproxy-3.4/simpleproxy.c"
static int writen(int fd , char *ptr , int nbytes ) 
{ 
  int nleft ;
  int nwritten ;
  ssize_t tmp ;

  {
#line 472
  nleft = nbytes;
  {
#line 473
  while (1) {
    while_continue: /* CIL Label */ ;
#line 473
    if (! (nleft > 0)) {
#line 473
      goto while_break;
    }
    {
#line 475
    tmp = write(fd, (void const   *)ptr, (size_t )nleft);
#line 475
    nwritten = (int )tmp;
    }
#line 476
    if (nwritten <= 0) {
#line 477
      return (nwritten);
    }
#line 479
    nleft -= nwritten;
#line 480
    ptr += nwritten;
  }
  while_break: /* CIL Label */ ;
  }
#line 482
  return (nbytes - nleft);
}
}
#line 488 "/home/june/repo/benchmarks/collector/temp/simpleproxy-3.4/simpleproxy.c"
static void daemon_start(void) 
{ 
  __pid_t tmp ;

  {
  {
#line 492
  tmp = fork();
  }
#line 492
  if (tmp) {
    {
#line 493
    exit(0);
    }
  }
  {
#line 494
  chdir("/");
#line 495
  umask((__mode_t )0);
#line 496
  close(0);
#line 497
  close(1);
#line 498
  close(2);
#line 499
  open("/", 0);
#line 500
  dup2(0, 1);
#line 501
  dup2(0, 2);
#line 502
  setsid();
  }
#line 503
  return;
}
}
#line 506 "/home/june/repo/benchmarks/collector/temp/simpleproxy-3.4/simpleproxy.c"
static void pass_all(int fd , int client ) 
{ 
  fd_set in ;
  struct timeval tv ;
  int nsock ;
  int retval ;
  int tmp ;
  int __d0 ;
  int __d1 ;
  int *tmp___0 ;
  char *tmp___1 ;

  {
#line 512
  if (fd > client) {
#line 512
    tmp = fd;
  } else {
#line 512
    tmp = client;
  }
#line 512
  nsock = tmp + 1;
  {
#line 514
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 516
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 516
      __asm__  volatile   ("cld; rep; "
                           "stosq": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                           "1" (& in.__fds_bits[0]): "memory");
#line 516
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 517
    in.__fds_bits[fd / (8 * (int )sizeof(__fd_mask ))] |= 1L << fd % (8 * (int )sizeof(__fd_mask ));
#line 518
    in.__fds_bits[client / (8 * (int )sizeof(__fd_mask ))] |= 1L << client % (8 * (int )sizeof(__fd_mask ));
#line 520
    tv.tv_sec = (__time_t )5;
#line 521
    tv.tv_usec = (__suseconds_t )0;
#line 523
    retval = select(nsock, (fd_set */* __restrict  */)(& in), (fd_set */* __restrict  */)((void *)0),
                    (fd_set */* __restrict  */)((void *)0), (struct timeval */* __restrict  */)(& tv));
    }
    {
#line 527
    if (retval == 0) {
#line 527
      goto case_0;
    }
#line 530
    if (retval == -1) {
#line 530
      goto case_neg_1;
    }
#line 534
    goto switch_default;
    case_0: /* CIL Label */ 
#line 529
    goto switch_break;
    case_neg_1: /* CIL Label */ 
    {
#line 532
    tmp___0 = __errno_location();
#line 532
    tmp___1 = strerror(*tmp___0);
#line 532
    log(3, (char *)"i/o error - %s", tmp___1);
    }
#line 533
    return;
    switch_default: /* CIL Label */ 
#line 535
    if ((in.__fds_bits[fd / (8 * (int )sizeof(__fd_mask ))] & (1L << fd % (8 * (int )sizeof(__fd_mask )))) != 0L) {
      {
#line 536
      retval = pass_one(fd, client);
      }
    } else
#line 537
    if ((in.__fds_bits[client / (8 * (int )sizeof(__fd_mask ))] & (1L << client % (8 * (int )sizeof(__fd_mask )))) != 0L) {
      {
#line 538
      retval = pass_one(client, fd);
      }
    } else {
#line 540
      retval = -1;
    }
#line 541
    if (retval < 0) {
#line 542
      return;
    }
#line 543
    if (Delay > 0L) {
      {
#line 544
      sleep((unsigned int )Delay);
      }
    }
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 549 "/home/june/repo/benchmarks/collector/temp/simpleproxy-3.4/simpleproxy.c"
static int get_hostaddr(char const   *name ) 
{ 
  struct hostent *he ;
  int res ;
  int a1 ;
  int a2 ;
  int a3 ;
  int a4 ;
  in_addr_t tmp ;
  int tmp___0 ;

  {
  {
#line 552
  res = -1;
#line 555
  tmp___0 = sscanf((char const   */* __restrict  */)name, (char const   */* __restrict  */)"%d.%d.%d.%d",
                   & a1, & a2, & a3, & a4);
  }
#line 555
  if (tmp___0 == 4) {
    {
#line 556
    tmp = inet_addr(name);
#line 556
    res = (int )tmp;
    }
  } else {
    {
#line 559
    he = gethostbyname(name);
    }
#line 560
    if (he) {
      {
#line 561
      memcpy((void */* __restrict  */)(& res), (void const   */* __restrict  */)*(he->h_addr_list + 0),
             (size_t )he->h_length);
      }
    }
  }
#line 563
  return (res);
}
}
#line 567 "/home/june/repo/benchmarks/collector/temp/simpleproxy-3.4/simpleproxy.c"
static int pass_one(int in , int out ) 
{ 
  int nread ;
  char buff[8192] ;
  char *bufp ;
  int tmp ;

  {
  {
#line 572
  nread = readln(in, buff, 8192);
  }
#line 572
  if (nread <= 0) {
#line 573
    return (-1);
  } else {
#line 576
    if (isStripping) {
#line 579
      bufp = (buff + nread) - 1;
      {
#line 579
      while (1) {
        while_continue: /* CIL Label */ ;
#line 579
        if (! ((unsigned long )bufp >= (unsigned long )(buff))) {
#line 579
          goto while_break;
        }
#line 580
        *bufp = (char )((int )*bufp & 127);
#line 579
        bufp --;
      }
      while_break: /* CIL Label */ ;
      }
    }
    {
#line 583
    tmp = writen(out, buff, nread);
    }
#line 583
    if (tmp != nread) {
      {
#line 585
      log(3, (char *)"write error");
      }
#line 586
      return (-1);
    }
  }
#line 589
  return (0);
}
}
#line 592 "/home/june/repo/benchmarks/collector/temp/simpleproxy-3.4/simpleproxy.c"
static void child_dead(int stat___0 ) 
{ 
  __pid_t tmp ;

  {
  {
#line 594
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 594
    tmp = waitpid(-1, (int *)((void *)0), 1);
    }
#line 594
    if (! (tmp > 0)) {
#line 594
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 595
  signal(17, & child_dead);
  }
#line 596
  return;
}
}
#line 598 "/home/june/repo/benchmarks/collector/temp/simpleproxy-3.4/simpleproxy.c"
static void parse_host_port(char const   *src , char **h_ptr , int *p_ptr ) 
{ 
  struct servent *se ;
  char const   *tmp ;
  char *tmp___0 ;
  int tmp___2 ;
  uint16_t tmp___3 ;
  int tmp___4 ;
  unsigned short const   **tmp___5 ;

  {
#line 600
  if (src) {
    {
#line 604
    tmp___0 = strrchr(src, ':');
#line 604
    tmp = (char const   *)tmp___0;
    }
#line 606
    if (tmp) {
#line 608
      if (h_ptr) {
        {
#line 610
        replace_string(h_ptr, src);
#line 614
        *(*h_ptr + (tmp - src)) = (char )'\000';
        }
      }
#line 616
      tmp ++;
    } else {
#line 619
      tmp = src;
    }
    {
#line 622
    tmp___5 = __ctype_b_loc();
    }
#line 622
    if ((int const   )*(*tmp___5 + (int )*tmp) & 2048) {
      {
#line 622
      tmp___2 = atoi(tmp);
#line 622
      *p_ptr = tmp___2;
      }
    } else {
      {
#line 622
      se = getservbyname(tmp, "tcp");
      }
#line 622
      if ((unsigned long )se == (unsigned long )((void *)0)) {
#line 622
        tmp___4 = -1;
      } else {
        {
#line 622
        tmp___3 = ntohs((uint16_t )se->s_port);
#line 622
        tmp___4 = (int )tmp___3;
        }
      }
#line 622
      *p_ptr = tmp___4;
    }
  }
#line 628
  return;
}
}
#line 630 "/home/june/repo/benchmarks/collector/temp/simpleproxy-3.4/simpleproxy.c"
static void write_pid(char *filename ) 
{ 
  FILE *f ;
  __pid_t tmp ;

  {
  {
#line 634
  f = fopen((char const   */* __restrict  */)filename, (char const   */* __restrict  */)"w");
  }
#line 634
  if ((unsigned long )f == (unsigned long )((void *)0)) {
    {
#line 636
    log(4, (char *)"Can\'t open file \'%s\' to write PID", filename);
    }
#line 637
    return;
  }
  {
#line 640
  tmp = getpid();
#line 640
  fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"%d", tmp);
#line 641
  fclose(f);
  }
#line 642
  return;
}
}
#line 649 "/home/june/repo/benchmarks/collector/temp/simpleproxy-3.4/simpleproxy.c"
static struct lst_record *load_pop3_list(char const   *popfile ) 
{ 
  FILE *f ;
  char str[2048] ;
  struct lst_record *first ;
  struct lst_record *last ;
  void *tmp ;
  void *tmp___0 ;
  char *tmp___1 ;

  {
  {
#line 653
  first = (struct lst_record *)((void *)0);
#line 654
  last = (struct lst_record *)((void *)0);
#line 656
  f = fopen((char const   */* __restrict  */)popfile, (char const   */* __restrict  */)"r");
  }
#line 656
  if ((unsigned long )f == (unsigned long )((void *)0)) {
    {
#line 658
    log(3, (char *)"Can\'t open POP3 file: %s", popfile);
    }
#line 659
    return ((struct lst_record *)((void *)0));
  }
  {
#line 662
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 662
    tmp___1 = fgets((char */* __restrict  */)(str), 2040, (FILE */* __restrict  */)f);
    }
#line 662
    if (! ((unsigned long )(str) == (unsigned long )tmp___1)) {
#line 662
      goto while_break;
    }
#line 664
    if ((int )str[0] == 35) {
#line 664
      goto while_continue;
    }
    {
#line 666
    firstword(str);
    }
#line 667
    if ((int )str[0] == 0) {
#line 667
      goto while_continue;
    }
    {
#line 668
    log(6, (char *)"Adding \'%s\' to POP3 users list", str);
    }
#line 670
    if ((unsigned long )first == (unsigned long )((void *)0)) {
      {
#line 672
      tmp = malloc(sizeof(struct lst_record ));
#line 672
      first = (struct lst_record *)tmp;
#line 673
      last = first;
      }
    } else {
      {
#line 675
      tmp___0 = malloc(sizeof(struct lst_record ));
#line 675
      last->next = (struct lst_record *)tmp___0;
#line 676
      last = last->next;
      }
    }
    {
#line 678
    last->s = strdup((char const   *)(str));
#line 679
    last->next = (struct lst_record *)((void *)0);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 682
  fclose(f);
  }
#line 683
  return (first);
}
}
#line 689 "/home/june/repo/benchmarks/collector/temp/simpleproxy-3.4/simpleproxy.c"
static int check_pop3_list(struct lst_record *lst , char *acc ) 
{ 
  int tmp ;

  {
  {
#line 691
  while (1) {
    while_continue: /* CIL Label */ ;
#line 691
    if (! lst) {
#line 691
      goto while_break;
    }
    {
#line 693
    tmp = strcmp((char const   *)lst->s, (char const   *)acc);
    }
#line 693
    if (tmp == 0) {
#line 694
      return (1);
    } else {
#line 696
      lst = lst->next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 698
  return (0);
}
}
#line 701 "/home/june/repo/benchmarks/collector/temp/simpleproxy-3.4/simpleproxy.c"
static void firstword(char *s ) 
{ 


  {
  {
#line 703
  s = strpbrk((char const   *)s, "\n\t\r ");
  }
#line 704
  if (s) {
#line 705
    *s = (char )'\000';
  }
#line 706
  return;
}
}
#line 708 "/home/june/repo/benchmarks/collector/temp/simpleproxy-3.4/simpleproxy.c"
static int readln(int fd , char *buf , int siz ) 
{ 
  int nread ;
  ssize_t tmp ;

  {
  {
#line 712
  tmp = read(fd, (void *)buf, (size_t )siz);
#line 712
  nread = (int )tmp;
  }
#line 713
  if (nread <= 0) {
#line 715
    if (nread < 0) {
      {
#line 716
      log(3, (char *)"read error");
      }
    }
#line 717
    return (-1);
  } else {
#line 720
    if (Tracefile) {
      {
#line 723
      trace(fd, buf, nread);
      }
    }
#line 725
    return (nread);
  }
}
}
#line 735 "/home/june/repo/benchmarks/collector/temp/simpleproxy-3.4/simpleproxy.c"
static int read_pop3_cmd(int s , char *buff , int max_buf , int strip ) 
{ 
  int n ;
  int tmp ;

  {
  {
#line 739
  n = readln(s, buff, max_buf);
  }
#line 739
  if (n <= 0) {
#line 739
    return (-1);
  }
  {
#line 740
  while (1) {
    while_continue: /* CIL Label */ ;
#line 741
    tmp = n;
#line 741
    n --;
#line 741
    *(buff + tmp) = (char )'\000';
#line 740
    if ((int )*(buff + n) == 13) {
#line 740
      goto _L;
    } else
#line 740
    if ((int )*(buff + n) == 10) {
      _L: /* CIL Label */ 
#line 740
      if (n >= 0) {
#line 740
        if (! strip) {
#line 740
          goto while_break;
        }
      } else {
#line 740
        goto while_break;
      }
    } else {
#line 740
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 744
  return (n);
}
}
#line 754 "/home/june/repo/benchmarks/collector/temp/simpleproxy-3.4/simpleproxy.c"
static char errmsg0[28]  = 
#line 754
  {      (char )'-',      (char )'E',      (char )'R',      (char )'R', 
        (char )' ',      (char )'N',      (char )'o',      (char )'t', 
        (char )' ',      (char )'a',      (char )'l',      (char )'l', 
        (char )'o',      (char )'w',      (char )'e',      (char )'d', 
        (char )' ',      (char )'b',      (char )'y',      (char )' ', 
        (char )'p',      (char )'r',      (char )'o',      (char )'x', 
        (char )'y',      (char )'\r',      (char )'\n',      (char )'\000'};
#line 755 "/home/june/repo/benchmarks/collector/temp/simpleproxy-3.4/simpleproxy.c"
static char errmsg1[32]  = 
#line 755
  {      (char )'-',      (char )'E',      (char )'R',      (char )'R', 
        (char )' ',      (char )'C',      (char )'a',      (char )'n', 
        (char )'\'',      (char )'t',      (char )' ',      (char )'g', 
        (char )'e',      (char )'t',      (char )' ',      (char )'y', 
        (char )'o',      (char )'u',      (char )'r',      (char )' ', 
        (char )'u',      (char )'s',      (char )'e',      (char )'r', 
        (char )' ',      (char )'n',      (char )'a',      (char )'m', 
        (char )'e',      (char )'\r',      (char )'\n',      (char )'\000'};
#line 756 "/home/june/repo/benchmarks/collector/temp/simpleproxy-3.4/simpleproxy.c"
static char errmsg2[37]  = 
#line 756
  {      (char )'-',      (char )'E',      (char )'R',      (char )'R', 
        (char )' ',      (char )'U',      (char )'S',      (char )'E', 
        (char )'R',      (char )' ',      (char )'o',      (char )'r', 
        (char )' ',      (char )'Q',      (char )'U',      (char )'I', 
        (char )'T',      (char )' ',      (char )'c',      (char )'o', 
        (char )'m',      (char )'m',      (char )'a',      (char )'n', 
        (char )'d',      (char )' ',      (char )'e',      (char )'x', 
        (char )'p',      (char )'e',      (char )'c',      (char )'t', 
        (char )'e',      (char )'d',      (char )'\r',      (char )'\n', 
        (char )'\000'};
#line 757 "/home/june/repo/benchmarks/collector/temp/simpleproxy-3.4/simpleproxy.c"
static char errmsg3[37]  = 
#line 757
  {      (char )'-',      (char )'E',      (char )'R',      (char )'R', 
        (char )' ',      (char )'P',      (char )'A',      (char )'S', 
        (char )'S',      (char )' ',      (char )'o',      (char )'r', 
        (char )' ',      (char )'Q',      (char )'U',      (char )'I', 
        (char )'T',      (char )' ',      (char )'c',      (char )'o', 
        (char )'m',      (char )'m',      (char )'a',      (char )'n', 
        (char )'d',      (char )' ',      (char )'e',      (char )'x', 
        (char )'p',      (char )'e',      (char )'c',      (char )'t', 
        (char )'e',      (char )'d',      (char )'\r',      (char )'\n', 
        (char )'\000'};
#line 752 "/home/june/repo/benchmarks/collector/temp/simpleproxy-3.4/simpleproxy.c"
static int pop3_login(int server , int user ) 
{ 
  char buff[8192] ;
  char *s ;
  int tmp ;
  int tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  size_t tmp___4 ;
  int tmp___5 ;
  size_t tmp___6 ;
  size_t tmp___7 ;
  int tmp___8 ;
  size_t tmp___9 ;
  int tmp___10 ;
  size_t tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  size_t tmp___16 ;
  size_t tmp___17 ;
  int tmp___18 ;
  size_t tmp___19 ;
  int tmp___20 ;

  {
  {
#line 763
  tmp = readln(server, buff, 8192);
  }
#line 763
  if (tmp <= 0) {
#line 763
    return (1);
  }
  {
#line 764
  tmp___0 = strncmp((char const   *)(buff), "+OK", (size_t )3);
  }
#line 764
  if (tmp___0 != 0) {
#line 764
    return (1);
  }
  {
#line 767
  writen(user, (char *)"+OK ", 4);
#line 768
  tmp___1 = strlen((char const   *)SIMPLEPROXY_VERSION);
#line 768
  writen(user, SIMPLEPROXY_VERSION, (int )tmp___1);
#line 769
  writen(user, (char *)"\r\n", 2);
  }
  {
#line 771
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 774
    tmp___2 = read_pop3_cmd(user, buff, 8192, 1);
    }
#line 774
    if (tmp___2 <= 0) {
#line 775
      return (1);
    }
    {
#line 777
    tmp___3 = strncmp((char const   *)(buff), "QUIT ", (size_t )4);
    }
#line 777
    if (tmp___3 == 0) {
#line 778
      return (1);
    }
    {
#line 780
    tmp___5 = strncmp((char const   *)(buff), "USER ", (size_t )5);
    }
#line 780
    if (tmp___5 != 0) {
      {
#line 783
      tmp___4 = strlen((char const   *)(errmsg2));
#line 783
      writen(user, errmsg2, (int )tmp___4);
      }
#line 784
      goto while_continue;
    }
    {
#line 788
    s = strdup((char const   *)(buff + 5));
#line 789
    firstword(s);
    }
#line 790
    if ((int )*s == 0) {
      {
#line 793
      free((void *)s);
#line 794
      tmp___6 = strlen((char const   *)(errmsg1));
#line 794
      writen(user, errmsg1, (int )tmp___6);
      }
#line 795
      goto while_continue;
    }
    {
#line 799
    tmp___8 = check_pop3_list(POPList, s);
    }
#line 799
    if (tmp___8 == 0) {
      {
#line 802
      free((void *)s);
#line 803
      tmp___7 = strlen((char const   *)(errmsg0));
#line 803
      writen(user, errmsg0, (int )tmp___7);
      }
#line 804
      goto while_continue;
    }
    {
#line 808
    tmp___9 = strlen((char const   *)(buff));
#line 808
    writen(server, buff, (int )tmp___9);
#line 809
    writen(server, (char *)"\r\n", 2);
#line 812
    tmp___10 = read_pop3_cmd(server, buff, 8192, 0);
    }
#line 812
    if (tmp___10 <= 0) {
#line 812
      return (1);
    }
    {
#line 814
    tmp___11 = strlen((char const   *)(buff));
#line 814
    writen(user, buff, (int )tmp___11);
#line 816
    tmp___12 = strncmp((char const   *)(buff), "+OK", (size_t )3);
    }
#line 816
    if (tmp___12 != 0) {
#line 817
      goto while_continue;
    }
    {
#line 819
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 821
      tmp___13 = read_pop3_cmd(user, buff, 8192, 0);
      }
#line 821
      if (tmp___13 <= 0) {
#line 822
        return (1);
      }
      {
#line 824
      tmp___14 = strncmp((char const   *)(buff), "QUIT ", (size_t )4);
      }
#line 824
      if (tmp___14 == 0) {
#line 825
        return (1);
      }
      {
#line 827
      tmp___15 = strncmp((char const   *)(buff), "PASS ", (size_t )5);
      }
#line 827
      if (tmp___15 == 0) {
#line 828
        goto while_break___0;
      }
      {
#line 831
      tmp___16 = strlen((char const   *)(errmsg3));
#line 831
      writen(user, errmsg3, (int )tmp___16);
      }
#line 832
      goto while_continue___0;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 836
    tmp___17 = strlen((char const   *)(buff));
#line 836
    writen(server, buff, (int )tmp___17);
#line 839
    tmp___18 = read_pop3_cmd(server, buff, 8192, 0);
    }
#line 839
    if (tmp___18 <= 0) {
#line 839
      return (1);
    }
    {
#line 841
    tmp___19 = strlen((char const   *)(buff));
#line 841
    writen(user, buff, (int )tmp___19);
#line 843
    tmp___20 = strncmp((char const   *)(buff), "+OK", (size_t )3);
    }
#line 843
    if (tmp___20 == 0) {
#line 844
      return (0);
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 849 "/home/june/repo/benchmarks/collector/temp/simpleproxy-3.4/simpleproxy.c"
static int process_remote(char const   *dest_host , int dest_port , char const   *client_name ) 
{ 
  int tmp ;

  {
  {
#line 851
  DstSockFD = open_remote(dest_host, dest_port, client_name);
  }
#line 853
  if (DstSockFD == -1) {
#line 854
    return (-1);
  }
#line 856
  if (POPList) {
    {
#line 856
    tmp = pop3_login(DstSockFD, SrcSockFD);
    }
#line 856
    if (tmp) {
      {
#line 858
      log(3, (char *)"POP3 login failed for %s.", client_name);
      }
#line 859
      return (-1);
    }
  }
  {
#line 862
  pass_all(DstSockFD, SrcSockFD);
#line 864
  shutdown(DstSockFD, 2);
#line 865
  close(DstSockFD);
#line 866
  DstSockFD = -1;
  }
#line 867
  return (0);
}
}
#line 869 "/home/june/repo/benchmarks/collector/temp/simpleproxy-3.4/simpleproxy.c"
static int open_remote(char const   *rhost , int rportn , char const   *src_name ) 
{ 
  char const   *dest_host ;
  int dest_port ;
  struct sockaddr_in remote_addr ;
  int DstSockFD___0 ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 877
  if (HTTPSProxyHost) {
#line 879
    dest_host = (char const   *)HTTPSProxyHost;
#line 880
    dest_port = HTTPSProxyPort;
  } else {
#line 884
    dest_host = rhost;
#line 885
    dest_port = rportn;
  }
#line 888
  if (dest_host) {
#line 888
    if (! *dest_host) {
#line 889
      dest_host = "127.0.0.1";
    }
  } else {
#line 889
    dest_host = "127.0.0.1";
  }
  {
#line 891
  DstSockFD___0 = socket(2, 1, 0);
  }
#line 891
  if (DstSockFD___0 == -1) {
    {
#line 893
    tmp = __errno_location();
#line 893
    tmp___0 = strerror(*tmp);
#line 893
    log(3, (char *)"Can\'t create socket - %s ", tmp___0);
    }
#line 894
    return (-1);
  }
  {
#line 897
  remote_addr.sin_family = (sa_family_t )2;
#line 898
  remote_addr.sin_port = htons((uint16_t )dest_port);
#line 899
  tmp___1 = get_hostaddr(dest_host);
#line 899
  remote_addr.sin_addr.s_addr = (in_addr_t )tmp___1;
  }
#line 901
  if (remote_addr.sin_addr.s_addr == 4294967295U) {
    {
#line 903
    log(3, (char *)"Unknown host %s", dest_host);
    }
#line 904
    return (-1);
  }
  {
#line 907
  tmp___4 = connect(DstSockFD___0, (struct sockaddr  const  *)((struct sockaddr *)(& remote_addr)),
                    (socklen_t )sizeof(remote_addr));
  }
#line 907
  if (tmp___4) {
    {
#line 909
    tmp___2 = __errno_location();
#line 909
    tmp___3 = strerror(*tmp___2);
#line 909
    log(3, (char *)"connect error to %s:%d - %s", dest_host, dest_port, tmp___3);
    }
#line 910
    return (-1);
  }
#line 913
  if (HTTPSProxyHost) {
    {
#line 913
    tmp___5 = https_connect(DstSockFD___0, rhost, rportn);
    }
#line 913
    if (tmp___5) {
#line 914
      return (-1);
    }
  }
#line 916
  return (DstSockFD___0);
}
}
#line 919 "/home/june/repo/benchmarks/collector/temp/simpleproxy-3.4/simpleproxy.c"
static int https_connect(int DstSockFD___0 , char const   *remoteHost , int remotePort ) 
{ 
  char buff[8192] ;
  char *s ;
  long n ;
  size_t tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  int *tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;

  {
  {
#line 926
  sprintf((char */* __restrict  */)(buff), (char const   */* __restrict  */)"CONNECT %s:%i HTTP/1.0\nUser-agent: %s%s\n\n",
          remoteHost, remotePort, SIMPLEPROXY_VERSION, HTTPBasicAuthString);
#line 928
  tmp = strlen((char const   *)(buff));
#line 928
  n = (long )tmp;
#line 930
  tmp___2 = writen(DstSockFD___0, buff, (int )n);
  }
#line 930
  if ((long )tmp___2 != n) {
    {
#line 932
    tmp___0 = __errno_location();
#line 932
    tmp___1 = strerror(*tmp___0);
#line 932
    log(3, (char *)"write error - %s", tmp___1);
    }
#line 933
    return (-1);
  }
  {
#line 937
  tmp___5 = readln(DstSockFD___0, buff, 8192);
  }
#line 937
  if (tmp___5 <= 0) {
    {
#line 939
    tmp___3 = __errno_location();
#line 939
    tmp___4 = strerror(*tmp___3);
#line 939
    log(3, (char *)"read error - %s", tmp___4);
    }
#line 940
    return (-1);
  }
  {
#line 944
  s = strchr((char const   *)(buff), ' ');
  }
#line 944
  if (! s) {
#line 945
    return (-1);
  }
  {
#line 946
  n = strtol((char const   */* __restrict  */)s, (char **/* __restrict  */)(& s),
             10);
  }
#line 946
  if (n != 200L) {
    {
#line 948
    log(3, (char *)"error in connect through HTTPS proxy. Proxy responded:\n %s",
        buff);
    }
#line 949
    return (-1);
  }
#line 951
  return (0);
}
}
#line 954 "/home/june/repo/benchmarks/collector/temp/simpleproxy-3.4/simpleproxy.c"
static void logopen(void) 
{ 


  {
#line 956
  if (isVerbose & isDaemon) {
    {
#line 959
    openlog("simpleproxy", 19, 1 << 3);
    }
  }
#line 965
  return;
}
}
#line 967 "/home/june/repo/benchmarks/collector/temp/simpleproxy-3.4/simpleproxy.c"
static void logclose(void) 
{ 


  {
#line 969
  if (isVerbose) {
#line 969
    if (isDaemon) {
      {
#line 972
      closelog();
      }
    }
  }
#line 975
  return;
}
}
#line 990 "/home/june/repo/benchmarks/collector/temp/simpleproxy-3.4/simpleproxy.c"
static void log(int type , char *format  , ...) 
{ 
  va_list ap ;
  char buffer[8192] ;
  __pid_t tmp ;

  {
#line 993
  if (type == 7) {
#line 994
    return;
  }
#line 997
  if (isVerbose) {
    {
#line 1000
    __builtin_va_start(ap, format);
    }
#line 1002
    if (isDaemon) {
      {
#line 1007
      vsnprintf((char */* __restrict  */)(buffer), (size_t )8192, (char const   */* __restrict  */)format,
                ap);
#line 1019
      syslog(type, "%s", buffer);
      }
    } else {
      {
#line 1023
      tmp = getpid();
#line 1023
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"simpleproxy[%d]:",
              tmp);
#line 1024
      vfprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)format,
               ap);
#line 1025
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
      }
    }
    {
#line 1027
    __builtin_va_end(ap);
    }
  }
#line 1029
  return;
}
}
#line 1031 "/home/june/repo/benchmarks/collector/temp/simpleproxy-3.4/simpleproxy.c"
static void ctrlc(int s ) 
{ 


  {
  {
#line 1033
  log(6, (char *)"Interrupted... Shutting down connections");
  }
#line 1035
  if (SockFD != -1) {
    {
#line 1038
    close(SockFD);
    }
  }
#line 1040
  if (SrcSockFD != -1) {
    {
#line 1043
    close(SrcSockFD);
    }
  }
#line 1045
  if (DstSockFD != -1) {
    {
#line 1048
    close(DstSockFD);
    }
  }
  {
#line 1054
  exit(1);
  }
}
}
#line 1061 "/home/june/repo/benchmarks/collector/temp/simpleproxy-3.4/simpleproxy.c"
static int str2bool(char *s ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 1063
  if ((unsigned long )s == (unsigned long )((void *)0)) {
#line 1064
    return (0);
  } else {
    {
#line 1066
    tmp = strcasecmp((char const   *)s, "yes");
    }
#line 1066
    if (tmp) {
      {
#line 1066
      tmp___0 = strcasecmp((char const   *)s, "true");
      }
#line 1066
      if (tmp___0) {
        {
#line 1066
        tmp___1 = strcasecmp((char const   *)s, "ok");
        }
#line 1066
        if (tmp___1) {
          {
#line 1066
          tmp___2 = strcasecmp((char const   *)s, "oui");
          }
#line 1066
          if (tmp___2) {
            {
#line 1066
            tmp___3 = strcasecmp((char const   *)s, "1");
            }
#line 1066
            if (tmp___3) {
#line 1066
              tmp___4 = 0;
            } else {
#line 1066
              tmp___4 = 1;
            }
          } else {
#line 1066
            tmp___4 = 1;
          }
        } else {
#line 1066
          tmp___4 = 1;
        }
      } else {
#line 1066
        tmp___4 = 1;
      }
    } else {
#line 1066
      tmp___4 = 1;
    }
#line 1066
    return (tmp___4);
  }
}
}
#line 1074 "/home/june/repo/benchmarks/collector/temp/simpleproxy-3.4/simpleproxy.c"
static void replace_string(char **dst , char const   *src ) 
{ 
  char *tmp ;

  {
#line 1076
  if (dst) {
#line 1078
    if (*dst) {
      {
#line 1079
      free((void *)*dst);
      }
    }
#line 1080
    if (src) {
      {
#line 1080
      tmp = strdup(src);
#line 1080
      *dst = tmp;
      }
    } else {
#line 1080
      *dst = (char *)((void *)0);
    }
  }
#line 1082
  return;
}
}
#line 1084 "/home/june/repo/benchmarks/collector/temp/simpleproxy-3.4/simpleproxy.c"
static void fatal(void) 
{ 


  {
#line 1086
  if (SockFD != -1) {
    {
#line 1087
    close(SockFD);
    }
  }
#line 1088
  if (SrcSockFD != -1) {
    {
#line 1089
    close(SrcSockFD);
    }
  }
#line 1090
  if (DstSockFD != -1) {
    {
#line 1091
    close(DstSockFD);
    }
  }
  {
#line 1092
  logclose();
#line 1093
  exit(1);
  }
}
}
#line 1096 "/home/june/repo/benchmarks/collector/temp/simpleproxy-3.4/simpleproxy.c"
static char *base64_encode(char *plaintext ) 
{ 
  int i ;
  unsigned char dtable[64] ;
  char *cryptext ;
  char *ogroup ;
  size_t tmp ;
  void *tmp___0 ;
  unsigned char igroup[3] ;
  int n ;
  char *tmp___1 ;

  {
#line 1100
  cryptext = (char *)((void *)0);
#line 1105
  i = 0;
  {
#line 1105
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1105
    if (! (i < 26)) {
#line 1105
      goto while_break;
    }
#line 1106
    dtable[i] = (unsigned char )(65 + i);
#line 1107
    dtable[26 + i] = (unsigned char )(97 + i);
#line 1105
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1109
  i = 0;
  {
#line 1109
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1109
    if (! (i < 10)) {
#line 1109
      goto while_break___0;
    }
#line 1110
    dtable[52 + i] = (unsigned char )(48 + i);
#line 1109
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 1112
  dtable[62] = (unsigned char )'+';
#line 1113
  dtable[63] = (unsigned char )'/';
#line 1115
  tmp = strlen((char const   *)plaintext);
#line 1115
  tmp___0 = malloc(tmp * 2UL);
#line 1115
  cryptext = (char *)tmp___0;
#line 1116
  ogroup = cryptext;
  }
  {
#line 1118
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1118
    if (! ((int )*plaintext != 0)) {
#line 1118
      goto while_break___1;
    }
#line 1123
    igroup[2] = (unsigned char)0;
#line 1123
    igroup[1] = igroup[2];
#line 1123
    igroup[0] = igroup[1];
#line 1125
    n = 0;
    {
#line 1125
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 1125
      if (! (n < 3)) {
#line 1125
        goto while_break___2;
      }
#line 1127
      if ((int )*plaintext != 0) {
#line 1128
        tmp___1 = plaintext;
#line 1128
        plaintext ++;
#line 1128
        igroup[n] = (unsigned char )*tmp___1;
      } else {
#line 1130
        goto while_break___2;
      }
#line 1125
      n ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 1133
    if (n > 0) {
#line 1135
      *(ogroup + 0) = (char )dtable[(int )igroup[0] >> 2];
#line 1136
      *(ogroup + 1) = (char )dtable[(((int )igroup[0] & 3) << 4) | ((int )igroup[1] >> 4)];
#line 1137
      *(ogroup + 2) = (char )dtable[(((int )igroup[1] & 15) << 2) | ((int )igroup[2] >> 6)];
#line 1138
      *(ogroup + 3) = (char )dtable[(int )igroup[2] & 63];
#line 1144
      if (n < 3) {
#line 1145
        *(ogroup + 3) = (char )'=';
#line 1146
        if (n < 2) {
#line 1147
          *(ogroup + 2) = (char )'=';
        }
      }
#line 1151
      ogroup += 4;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 1155
  *ogroup = (char )'\000';
#line 1156
  return (cryptext);
}
}
#line 1159 "/home/june/repo/benchmarks/collector/temp/simpleproxy-3.4/simpleproxy.c"
static void trace(int fd , char *buf , int siz ) 
{ 
  char peer_name[256] ;
  char trace_header[256] ;
  int trace_header_len ;
  struct sockaddr_in peer_addr ;
  int peer_addr_len ;
  struct hostent *peer_host ;
  int tfd ;
  int tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  uint16_t tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  unsigned long tmp___6 ;

  {
  {
#line 1165
  peer_addr_len = (int )sizeof(peer_addr);
#line 1167
  tmp = open((char const   *)Tracefile, 1089, (((384 | (256 >> 3)) | (128 >> 3)) | ((256 >> 3) >> 3)) | ((128 >> 3) >> 3));
#line 1167
  tfd = tmp;
  }
#line 1169
  if (tfd < 0) {
    {
#line 1171
    tmp___0 = __errno_location();
#line 1171
    tmp___1 = strerror(*tmp___0);
#line 1171
    log(3, (char *)"Tracing is disabled, can\'t create/open trace file - %s", tmp___1);
#line 1172
    free((void *)Tracefile);
#line 1173
    Tracefile = (char *)((void *)0);
    }
  } else {
    {
#line 1178
    tmp___5 = getpeername(fd, (struct sockaddr */* __restrict  */)((struct sockaddr *)(& peer_addr)),
                          (socklen_t */* __restrict  */)(& peer_addr_len));
    }
#line 1178
    if (tmp___5 == 0) {
      {
#line 1180
      peer_host = gethostbyaddr((void const   *)((char *)(& peer_addr)), (__socklen_t )peer_addr_len,
                                2);
#line 1181
      tmp___2 = ntohs(peer_addr.sin_port);
      }
#line 1181
      if (peer_host) {
#line 1181
        tmp___4 = peer_host->h_name;
      } else {
        {
#line 1181
        tmp___3 = inet_ntoa(peer_addr.sin_addr);
#line 1181
        tmp___4 = tmp___3;
        }
      }
      {
#line 1181
      snprintf((char */* __restrict  */)(peer_name), sizeof(peer_name) - 1UL, (char const   */* __restrict  */)"%s:%i",
               tmp___4, (int )tmp___2);
      }
    } else {
      {
#line 1186
      strcpy((char */* __restrict  */)(peer_name), (char const   */* __restrict  */)"unknown source");
      }
    }
    {
#line 1187
    trace_header_len = snprintf((char */* __restrict  */)(trace_header), sizeof(trace_header) - 1UL,
                                (char const   */* __restrict  */)"\n---------------- Read from: %s ---------------\n",
                                peer_name);
    }
#line 1191
    if ((unsigned long )trace_header_len < sizeof(trace_header) - 1UL) {
#line 1191
      tmp___6 = (unsigned long )trace_header_len;
    } else {
#line 1191
      tmp___6 = sizeof(trace_header) - 1UL;
    }
    {
#line 1191
    write(tfd, (void const   *)(trace_header), tmp___6);
#line 1192
    write(tfd, (void const   *)buf, (size_t )siz);
#line 1193
    close(tfd);
    }
  }
#line 1195
  return;
}
}
